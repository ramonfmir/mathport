{"mem_top_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem mem_top_basic_open (f : X.presheaf.obj (op («expr⊤»))) (x : X) :\n    x ∈ X.basic_open f ↔ is_unit (X.presheaf.germ ⟨x, show x ∈ («expr⊤» : opens X) by trivial⟩ f) :=\n  mem_basic_open X f ⟨x, _⟩\n#align mem_top_basic_open mem_top_basic_open\n\n",
 "mem_basic_open":
 "@[simp]\ntheorem mem_basic_open {U : opens X} (f : X.presheaf.obj (op U)) (x : U) :\n    ↑x ∈ X.basic_open f ↔ is_unit (X.presheaf.germ x f) :=\n  by\n  constructor\n  · rintro ⟨x, hx, a⟩\n    cases subtype.eq a\n    exact hx\n  · intro h\n    exact ⟨x, h, rfl⟩\n#align mem_basic_open mem_basic_open\n\n",
 "is_unit_res_of_is_unit_germ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2021 Justus Springer. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Justus Springer, Andrew Yang\n-/\n/-- If the germ of a section `f` is a unit in the stalk at `x`, then `f` must be a unit on some small\nneighborhood around `x`.\n-/\ntheorem is_unit_res_of_is_unit_germ (U : opens X) (f : X.presheaf.obj (op U)) (x : U)\n    (h : is_unit (X.presheaf.germ x f)) :\n    ∃ (V : opens X)(i : «expr ⟶ » V U)(hxV : x.1 ∈ V), is_unit (X.presheaf.map i.op f) :=\n  by\n  obtain ⟨g', heq⟩ := h.exists_right_inv\n  obtain ⟨V, hxV, g, rfl⟩ := X.presheaf.germ_exist x.1 g'\n  let W := «expr ⊓ » U V\n  have hxW : x.1 ∈ W := ⟨x.2, hxV⟩\n  erw [← X.presheaf.germ_res_apply (opens.inf_le_left U V) ⟨x.1, hxW⟩ f, ←\n    X.presheaf.germ_res_apply (opens.inf_le_right U V) ⟨x.1, hxW⟩ g, ← RingHom.map_mul, ←\n    RingHom.map_one (X.presheaf.germ (⟨x.1, hxW⟩ : W))] at heq\n  obtain ⟨W', hxW', i₁, i₂, heq'⟩ := X.presheaf.germ_eq x.1 hxW hxW _ _ HEq\n  use W', «expr ≫ » i₁ (opens.inf_le_left U V), hxW'\n  rw [RingHom.map_one, RingHom.map_mul, ← comp_apply, ← X.presheaf.map_comp, ← op_comp] at heq'\n  exact isUnit_of_mul_eq_one _ _ heq'\n#align is_unit_res_of_is_unit_germ is_unit_res_of_is_unit_germ\n\n",
 "is_unit_res_basic_open":
 "/-- The restriction of a section `f` to the basic open of `f` is a unit. -/\ntheorem is_unit_res_basic_open {U : opens X} (f : X.presheaf.obj (op U)) :\n    is_unit (X.presheaf.map (@hom_of_le (opens X) _ _ _ (X.basic_open_le f)).op f) :=\n  by\n  apply is_unit_of_is_unit_germ\n  rintro ⟨_, ⟨x, hx, rfl⟩⟩\n  convert hx\n  rw [germ_res_apply]\n  rfl\n#align is_unit_res_basic_open is_unit_res_basic_open\n\n",
 "is_unit_of_is_unit_germ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- If a section `f` is a unit in each stalk, `f` must be a unit. -/\ntheorem is_unit_of_is_unit_germ (U : opens X) (f : X.presheaf.obj (op U)) (h : ∀ x : U, is_unit (X.presheaf.germ x f)) :\n    is_unit f :=\n  by\n  -- We pick a cover of `U` by open sets `V x`, such that `f` is a unit on each `V x`.\n  choose V iVU m h_unit using fun x : U => X.is_unit_res_of_is_unit_germ U f x (h x)\n  have hcover : U ≤ supᵢ V := by\n    intro x hxU\n    rw [opens.mem_coe, opens.mem_supr]\n    exact ⟨⟨x, hxU⟩, m ⟨x, hxU⟩⟩\n  -- Let `g x` denote the inverse of `f` in `U x`.\n  choose g hg using fun x : U => is_unit.exists_right_inv (h_unit x)\n  -- We claim that these local inverses glue together to a global inverse of `f`.\n  obtain ⟨gl, gl_spec, -⟩ := X.sheaf.exists_unique_gluing' V U iVU hcover g _\n  swap\n  · intro x y\n    apply section_ext X.sheaf («expr ⊓ » (V x) (V y))\n    rintro ⟨z, hzVx, hzVy⟩\n    rw [germ_res_apply, germ_res_apply]\n    apply (is_unit.mul_right_inj (h ⟨z, (iVU x).le hzVx⟩)).mp\n    erw [← X.presheaf.germ_res_apply (iVU x) ⟨z, hzVx⟩ f, ← RingHom.map_mul,\n      congr_arg (X.presheaf.germ (⟨z, hzVx⟩ : V x)) (hg x), germ_res_apply, ←\n      X.presheaf.germ_res_apply (iVU y) ⟨z, hzVy⟩ f, ← RingHom.map_mul,\n      congr_arg (X.presheaf.germ (⟨z, hzVy⟩ : V y)) (hg y), RingHom.map_one, RingHom.map_one]\n  apply isUnit_of_mul_eq_one f gl\n  apply X.sheaf.eq_of_locally_eq' V U iVU hcover\n  intro i\n  rw [RingHom.map_one, RingHom.map_mul, gl_spec]\n  exact hg i\n#align is_unit_of_is_unit_germ is_unit_of_is_unit_germ\n\n",
 "basic_open_res_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- This should fire before `basic_open_res`.\n@[simp]\ntheorem basic_open_res_eq {U V : «expr ᵒᵖ» (opens X)} (i : «expr ⟶ » U V) [IsIso i] (f : X.presheaf.obj U) :\n    @basic_open X (unop V) (X.presheaf.map i f) = @RingedSpace.basic_open X (unop U) f :=\n  by\n  apply le_antisymm\n  · rw [X.basic_open_res i f]\n    exact inf_le_right\n  · have := X.basic_open_res (inv i) (X.presheaf.map i f)\n    rw [← comp_apply, ← X.presheaf.map_comp, is_iso.hom_inv_id, X.presheaf.map_id] at this\n    erw [this]\n    exact inf_le_right\n#align basic_open_res_eq basic_open_res_eq\n\n",
 "basic_open_res":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem basic_open_res {U V : «expr ᵒᵖ» (opens X)} (i : «expr ⟶ » U V) (f : X.presheaf.obj U) :\n    @basic_open X (unop V) (X.presheaf.map i f) = «expr ⊓ » (unop V) (@basic_open X (unop U) f) :=\n  by\n  induction U using opposite.rec\n  induction V using opposite.rec\n  let g := i.unop; have : i = g.op := rfl; clear_value g; subst this\n  ext; constructor\n  · rintro ⟨x, hx : is_unit _, rfl⟩\n    rw [germ_res_apply] at hx\n    exact ⟨x.2, g x, hx, rfl⟩\n  · rintro ⟨hxV, x, hx, rfl⟩\n    refine' ⟨⟨x, hxV⟩, (_ : is_unit _), rfl⟩\n    rwa [germ_res_apply]\n#align basic_open_res basic_open_res\n\n",
 "basic_open_of_is_unit":
 "theorem basic_open_of_is_unit {U : opens X} {f : X.presheaf.obj (op U)} (hf : is_unit f) : X.basic_open f = U :=\n  by\n  apply le_antisymm\n  · exact X.basic_open_le f\n  intro x hx\n  erw [X.mem_basic_open f (⟨x, hx⟩ : U)]\n  exact RingHom.isUnit_map _ hf\n#align basic_open_of_is_unit basic_open_of_is_unit\n\n",
 "basic_open_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem basic_open_mul {U : opens X} (f g : X.presheaf.obj (op U)) :\n    X.basic_open (f * g) = «expr ⊓ » (X.basic_open f) (X.basic_open g) :=\n  by\n  ext1\n  dsimp [RingedSpace.basic_open]\n  rw [← Set.image_inter subtype.coe_injective]\n  congr\n  ext\n  simp_rw [map_mul]\n  exact IsUnit.mul_iff\n#align basic_open_mul basic_open_mul\n\n",
 "basic_open_le":
 "theorem basic_open_le {U : opens X} (f : X.presheaf.obj (op U)) : X.basic_open f ≤ U :=\n  by\n  rintro _ ⟨x, hx, rfl⟩\n  exact x.2\n#align basic_open_le basic_open_le\n\n"}