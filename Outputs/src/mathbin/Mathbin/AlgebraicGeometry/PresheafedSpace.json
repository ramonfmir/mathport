{"Γ_obj_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- or `rw [opens.inclusion_top_functor, ←comp_obj, ←opens.map_comp_eq],\n         erw iso.inv_hom_id, cases U, refl` after `dsimp` -/\ntheorem Γ_obj_op (X : PresheafedSpace C) : Γ.obj (op X) = X.presheaf.obj (op («expr⊤»)) :=\n  rfl\n#align Γ_obj_op Γ_obj_op\n\n",
 "Γ_map_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem Γ_map_op {X Y : PresheafedSpace.{v, v, u} C} (f : «expr ⟶ » X Y) : Γ.map f.op = f.c.app (op («expr⊤»)) :=\n  rfl\n#align Γ_map_op Γ_map_op\n\n",
 "restrict_top_presheaf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\ntheorem restrict_top_presheaf (X : PresheafedSpace C) :\n    (X.restrict (opens.open_embedding («expr⊤»))).presheaf =\n      «expr _* » (opens.inclusion_top_iso X.carrier).inv X.presheaf :=\n  by\n  dsimp\n  rw [opens.inclusion_top_functor X.carrier]\n  rfl\n#align restrict_top_presheaf restrict_top_presheaf\n\n",
 "of_restrict_top_c":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem of_restrict_top_c (X : PresheafedSpace C) :\n    (X.of_restrict (opens.open_embedding («expr⊤»))).c =\n      eq_to_hom\n        (by\n          rw [restrict_top_presheaf, ← presheaf.pushforward.comp_eq]\n          erw [iso.inv_hom_id]\n          rw [presheaf.pushforward.id_eq]) :=\n  by\n  /- another approach would be to prove the left hand side\n       is a natural isoomorphism, but I encountered a universe\n       issue when `apply nat_iso.is_iso_of_is_iso_app`. -/\n  ext U;\n  change X.presheaf.map _ = _; convert eq_to_hom_map _ _ using 1\n  congr ; simpa\n  · induction U using opposite.rec\n    dsimp\n    congr\n    ext\n    exact ⟨fun h => ⟨⟨x, trivial⟩, h, rfl⟩, fun ⟨⟨_, _⟩, h, rfl⟩ => h⟩\n#align of_restrict_top_c of_restrict_top_c\n\n",
 "mk_coe":
 "@[simp]\ntheorem mk_coe (carrier) (presheaf) :\n    (({     carrier\n            presheaf } : PresheafedSpace.{v} C) : Top.{v}) = carrier :=\n  rfl\n#align mk_coe mk_coe\n\n",
 "map_presheaf_obj_presheaf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[simp]\ntheorem map_presheaf_obj_presheaf (F : «expr ⥤ » C D) (X : PresheafedSpace C) :\n    (F.map_presheaf.obj X).presheaf = «expr ⋙ » X.presheaf F :=\n  rfl\n#align map_presheaf_obj_presheaf map_presheaf_obj_presheaf\n\n",
 "map_presheaf_obj_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem map_presheaf_obj_X (F : «expr ⥤ » C D) (X : PresheafedSpace C) :\n    (F.map_presheaf.obj X : Top.{v}) = (X : Top.{v}) :=\n  rfl\n#align map_presheaf_obj_X map_presheaf_obj_X\n\n",
 "map_presheaf_map_f":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem map_presheaf_map_f (F : «expr ⥤ » C D) {X Y : PresheafedSpace.{v, v, u} C} (f : «expr ⟶ » X Y) :\n    (F.map_presheaf.map f).base = f.base :=\n  rfl\n#align map_presheaf_map_f map_presheaf_map_f\n\n",
 "map_presheaf_map_c":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem map_presheaf_map_c (F : «expr ⥤ » C D) {X Y : PresheafedSpace.{v, v, u} C} (f : «expr ⟶ » X Y) :\n    (F.map_presheaf.map f).c = whiskerRight f.c F :=\n  rfl\n#align map_presheaf_map_c map_presheaf_map_c\n\n",
 "is_iso_of_components":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- This could be used in conjunction with `category_theory.nat_iso.is_iso_of_is_iso_app`. -/\ntheorem is_iso_of_components (f : «expr ⟶ » X Y) [IsIso f.base] [IsIso f.c] : IsIso f :=\n  by\n  convert is_iso.of_iso (iso_of_components (as_iso f.base) (as_iso f.c).symm)\n  ext; · simpa; · simp\n#align is_iso_of_components is_iso_of_components\n\n",
 "id_c_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem id_c_app (X : PresheafedSpace.{v, v, u} C) (U) :\n    ((«expr𝟙») X : «expr ⟶ » X X).c.app U =\n      X.presheaf.map\n        (eq_to_hom\n          (by\n            induction U using opposite.rec\n            cases U\n            rfl)) :=\n  by\n  induction U using opposite.rec\n  cases U\n  simp only [id_c]\n  dsimp\n  simp\n#align id_c_app id_c_app\n\n",
 "id_c":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem id_c (X : PresheafedSpace.{v, v, u} C) :\n    ((«expr𝟙») X : «expr ⟶ » X X).c = eq_to_hom (presheaf.pushforward.id_eq X.presheaf).symm :=\n  rfl\n#align id_c id_c\n\n",
 "id_base":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- The proofs below can be done by `tidy`, but it is too slow,\n   and we don't have a tactic caching mechanism. -/\n@[simp]\ntheorem id_base (X : PresheafedSpace.{v, v, u} C) : ((«expr𝟙») X : «expr ⟶ » X X).base = («expr𝟙») (X : Top.{v}) :=\n  rfl\n#align id_base id_base\n\n",
 "hext":
 "-- TODO including `injections` would make tidy work earlier.\ntheorem hext {X Y : PresheafedSpace C} (α β : hom X Y) (w : α.base = β.base) (h : HEq α.c β.c) : α = β :=\n  by\n  cases α\n  cases β\n  congr\n  exacts[w, h]\n#align hext hext\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[ext]\ntheorem ext {X Y : PresheafedSpace C} (α β : hom X Y) (w : α.base = β.base)\n    (h : «expr ≫ » α.c (whiskerRight (eq_to_hom (by rw [w])) _) = β.c) : α = β :=\n  by\n  cases α; cases β\n  dsimp [presheaf.pushforward_obj] at *\n  tidy\n#align ext ext\n\n",
 "congr_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem congr_app {X Y : PresheafedSpace.{v, v, u} C} {α β : «expr ⟶ » X Y} (h : α = β) (U) :\n    α.c.app U = «expr ≫ » (β.c.app U) (X.presheaf.map (eq_to_hom (by subst h))) :=\n  by\n  subst h\n  dsimp\n  simp\n#align congr_app congr_app\n\n",
 "comp_c_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- The `reassoc` attribute was added despite the LHS not being a composition of two homs,\n-- for the reasons explained in the docstring.\n/-- Sometimes rewriting with `comp_c_app` doesn't work because of dependent type issues.\nIn that case, `erw comp_c_app_assoc` might make progress.\nThe lemma `comp_c_app_assoc` is also better suited for rewrites in the opposite direction. -/\n@[reassoc.1, simp]\ntheorem comp_c_app {X Y Z : PresheafedSpace.{v, v, u} C} (α : «expr ⟶ » X Y) (β : «expr ⟶ » Y Z) (U) :\n    («expr ≫ » α β).c.app U = «expr ≫ » (β.c.app U) (α.c.app (op ((opens.map β.base).obj (unop U)))) :=\n  rfl\n#align comp_c_app comp_c_app\n\n",
 "comp_c":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem comp_c {X Y Z : PresheafedSpace C} (α : hom X Y) (β : hom Y Z) :\n    (comp α β).c = «expr ≫ » β.c ((presheaf.pushforward _ β.base).map α.c) :=\n  rfl\n#align comp_c comp_c\n\n",
 "comp_base":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem comp_base {X Y Z : PresheafedSpace.{v, v, u} C} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) :\n    («expr ≫ » f g).base = «expr ≫ » f.base g.base :=\n  rfl\n#align comp_base comp_base\n\n",
 "coe_to_fun_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem coe_to_fun_eq {X Y : PresheafedSpace.{v, v, u} C} (f : «expr ⟶ » X Y) : (f : X → Y) = f.base :=\n  rfl\n#align coe_to_fun_eq coe_to_fun_eq\n\n",
 "as_coe":
 "/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n@[simp]\ntheorem as_coe (X : PresheafedSpace.{w, v, u} C) : X.carrier = (X : Top.{w}) :=\n  rfl\n#align as_coe as_coe\n\n"}