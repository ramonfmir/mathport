{"Î“_obj_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- or `rw [opens.inclusion_top_functor, â†comp_obj, â†opens.map_comp_eq],\n         erw iso.inv_hom_id, cases U, refl` after `dsimp` -/\ntheorem Î“_obj_op (X : PresheafedSpace C) : Î“.obj (op X) = X.presheaf.obj (op (Â«exprâŠ¤Â»)) :=\n  rfl\n#align Î“_obj_op Î“_obj_op\n\n",
 "Î“_map_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem Î“_map_op {X Y : PresheafedSpace.{v, v, u} C} (f : Â«expr âŸ¶ Â» X Y) : Î“.map f.op = f.c.app (op (Â«exprâŠ¤Â»)) :=\n  rfl\n#align Î“_map_op Î“_map_op\n\n",
 "restrict_top_presheaf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr _* Â» -/\ntheorem restrict_top_presheaf (X : PresheafedSpace C) :\n    (X.restrict (opens.open_embedding (Â«exprâŠ¤Â»))).presheaf =\n      Â«expr _* Â» (opens.inclusion_top_iso X.carrier).inv X.presheaf :=\n  by\n  dsimp\n  rw [opens.inclusion_top_functor X.carrier]\n  rfl\n#align restrict_top_presheaf restrict_top_presheaf\n\n",
 "of_restrict_top_c":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem of_restrict_top_c (X : PresheafedSpace C) :\n    (X.of_restrict (opens.open_embedding (Â«exprâŠ¤Â»))).c =\n      eq_to_hom\n        (by\n          rw [restrict_top_presheaf, â† presheaf.pushforward.comp_eq]\n          erw [iso.inv_hom_id]\n          rw [presheaf.pushforward.id_eq]) :=\n  by\n  /- another approach would be to prove the left hand side\n       is a natural isoomorphism, but I encountered a universe\n       issue when `apply nat_iso.is_iso_of_is_iso_app`. -/\n  ext U;\n  change X.presheaf.map _ = _; convert eq_to_hom_map _ _ using 1\n  congr ; simpa\n  Â· induction U using opposite.rec\n    dsimp\n    congr\n    ext\n    exact âŸ¨fun h => âŸ¨âŸ¨x, trivialâŸ©, h, rflâŸ©, fun âŸ¨âŸ¨_, _âŸ©, h, rflâŸ© => hâŸ©\n#align of_restrict_top_c of_restrict_top_c\n\n",
 "mk_coe":
 "@[simp]\ntheorem mk_coe (carrier) (presheaf) :\n    (({     carrier\n            presheaf } : PresheafedSpace.{v} C) : Top.{v}) = carrier :=\n  rfl\n#align mk_coe mk_coe\n\n",
 "map_presheaf_obj_presheaf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n@[simp]\ntheorem map_presheaf_obj_presheaf (F : Â«expr â¥¤ Â» C D) (X : PresheafedSpace C) :\n    (F.map_presheaf.obj X).presheaf = Â«expr â‹™ Â» X.presheaf F :=\n  rfl\n#align map_presheaf_obj_presheaf map_presheaf_obj_presheaf\n\n",
 "map_presheaf_obj_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n@[simp]\ntheorem map_presheaf_obj_X (F : Â«expr â¥¤ Â» C D) (X : PresheafedSpace C) :\n    (F.map_presheaf.obj X : Top.{v}) = (X : Top.{v}) :=\n  rfl\n#align map_presheaf_obj_X map_presheaf_obj_X\n\n",
 "map_presheaf_map_f":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem map_presheaf_map_f (F : Â«expr â¥¤ Â» C D) {X Y : PresheafedSpace.{v, v, u} C} (f : Â«expr âŸ¶ Â» X Y) :\n    (F.map_presheaf.map f).base = f.base :=\n  rfl\n#align map_presheaf_map_f map_presheaf_map_f\n\n",
 "map_presheaf_map_c":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem map_presheaf_map_c (F : Â«expr â¥¤ Â» C D) {X Y : PresheafedSpace.{v, v, u} C} (f : Â«expr âŸ¶ Â» X Y) :\n    (F.map_presheaf.map f).c = whiskerRight f.c F :=\n  rfl\n#align map_presheaf_map_c map_presheaf_map_c\n\n",
 "is_iso_of_components":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- This could be used in conjunction with `category_theory.nat_iso.is_iso_of_is_iso_app`. -/\ntheorem is_iso_of_components (f : Â«expr âŸ¶ Â» X Y) [IsIso f.base] [IsIso f.c] : IsIso f :=\n  by\n  convert is_iso.of_iso (iso_of_components (as_iso f.base) (as_iso f.c).symm)\n  ext; Â· simpa; Â· simp\n#align is_iso_of_components is_iso_of_components\n\n",
 "id_c_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem id_c_app (X : PresheafedSpace.{v, v, u} C) (U) :\n    ((Â«exprğŸ™Â») X : Â«expr âŸ¶ Â» X X).c.app U =\n      X.presheaf.map\n        (eq_to_hom\n          (by\n            induction U using opposite.rec\n            cases U\n            rfl)) :=\n  by\n  induction U using opposite.rec\n  cases U\n  simp only [id_c]\n  dsimp\n  simp\n#align id_c_app id_c_app\n\n",
 "id_c":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem id_c (X : PresheafedSpace.{v, v, u} C) :\n    ((Â«exprğŸ™Â») X : Â«expr âŸ¶ Â» X X).c = eq_to_hom (presheaf.pushforward.id_eq X.presheaf).symm :=\n  rfl\n#align id_c id_c\n\n",
 "id_base":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- The proofs below can be done by `tidy`, but it is too slow,\n   and we don't have a tactic caching mechanism. -/\n@[simp]\ntheorem id_base (X : PresheafedSpace.{v, v, u} C) : ((Â«exprğŸ™Â») X : Â«expr âŸ¶ Â» X X).base = (Â«exprğŸ™Â») (X : Top.{v}) :=\n  rfl\n#align id_base id_base\n\n",
 "hext":
 "-- TODO including `injections` would make tidy work earlier.\ntheorem hext {X Y : PresheafedSpace C} (Î± Î² : hom X Y) (w : Î±.base = Î².base) (h : HEq Î±.c Î².c) : Î± = Î² :=\n  by\n  cases Î±\n  cases Î²\n  congr\n  exacts[w, h]\n#align hext hext\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[ext]\ntheorem ext {X Y : PresheafedSpace C} (Î± Î² : hom X Y) (w : Î±.base = Î².base)\n    (h : Â«expr â‰« Â» Î±.c (whiskerRight (eq_to_hom (by rw [w])) _) = Î².c) : Î± = Î² :=\n  by\n  cases Î±; cases Î²\n  dsimp [presheaf.pushforward_obj] at *\n  tidy\n#align ext ext\n\n",
 "congr_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem congr_app {X Y : PresheafedSpace.{v, v, u} C} {Î± Î² : Â«expr âŸ¶ Â» X Y} (h : Î± = Î²) (U) :\n    Î±.c.app U = Â«expr â‰« Â» (Î².c.app U) (X.presheaf.map (eq_to_hom (by subst h))) :=\n  by\n  subst h\n  dsimp\n  simp\n#align congr_app congr_app\n\n",
 "comp_c_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- The `reassoc` attribute was added despite the LHS not being a composition of two homs,\n-- for the reasons explained in the docstring.\n/-- Sometimes rewriting with `comp_c_app` doesn't work because of dependent type issues.\nIn that case, `erw comp_c_app_assoc` might make progress.\nThe lemma `comp_c_app_assoc` is also better suited for rewrites in the opposite direction. -/\n@[reassoc.1, simp]\ntheorem comp_c_app {X Y Z : PresheafedSpace.{v, v, u} C} (Î± : Â«expr âŸ¶ Â» X Y) (Î² : Â«expr âŸ¶ Â» Y Z) (U) :\n    (Â«expr â‰« Â» Î± Î²).c.app U = Â«expr â‰« Â» (Î².c.app U) (Î±.c.app (op ((opens.map Î².base).obj (unop U)))) :=\n  rfl\n#align comp_c_app comp_c_app\n\n",
 "comp_c":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem comp_c {X Y Z : PresheafedSpace C} (Î± : hom X Y) (Î² : hom Y Z) :\n    (comp Î± Î²).c = Â«expr â‰« Â» Î².c ((presheaf.pushforward _ Î².base).map Î±.c) :=\n  rfl\n#align comp_c comp_c\n\n",
 "comp_base":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem comp_base {X Y Z : PresheafedSpace.{v, v, u} C} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) :\n    (Â«expr â‰« Â» f g).base = Â«expr â‰« Â» f.base g.base :=\n  rfl\n#align comp_base comp_base\n\n",
 "coe_to_fun_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem coe_to_fun_eq {X Y : PresheafedSpace.{v, v, u} C} (f : Â«expr âŸ¶ Â» X Y) : (f : X â†’ Y) = f.base :=\n  rfl\n#align coe_to_fun_eq coe_to_fun_eq\n\n",
 "as_coe":
 "/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n@[simp]\ntheorem as_coe (X : PresheafedSpace.{w, v, u} C) : X.carrier = (X : Top.{w}) :=\n  rfl\n#align as_coe as_coe\n\n"}