{"Γ_obj_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem Γ_obj_op (X : LocallyRingedSpace) : Γ.obj (op X) = X.presheaf.obj (op («expr⊤»)) :=\n  rfl\n#align Γ_obj_op Γ_obj_op\n\n",
 "Γ_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem Γ_obj (X : «expr ᵒᵖ» LocallyRingedSpace) : Γ.obj X = (unop X).presheaf.obj (op («expr⊤»)) :=\n  rfl\n#align Γ_obj Γ_obj\n\n",
 "Γ_map_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem Γ_map_op {X Y : LocallyRingedSpace} (f : «expr ⟶ » X Y) : Γ.map f.op = f.1.c.app (op («expr⊤»)) :=\n  rfl\n#align Γ_map_op Γ_map_op\n\n",
 "Γ_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem Γ_map {X Y : «expr ᵒᵖ» LocallyRingedSpace} (f : «expr ⟶ » X Y) : Γ.map f = f.unop.1.c.app (op («expr⊤»)) :=\n  rfl\n#align Γ_map Γ_map\n\n",
 "Γ_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n-- Here we need to see that the stalk maps are really local ring homomorphisms.\n-- This can be solved by type class inference, because stalk maps of isomorphisms are isomorphisms\n-- and isomorphisms are local ring homomorphisms.\n-- We show that the stalk of the restriction is isomorphic to the original stalk,\ntheorem Γ_def : Γ = «expr ⋙ » forget_to_SheafedSpace.op SheafedSpace.Γ :=\n  rfl\n#align Γ_def Γ_def\n\n",
 "preimage_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem preimage_basic_open {X Y : LocallyRingedSpace} (f : «expr ⟶ » X Y) {U : Opens Y} (s : Y.presheaf.obj (op U)) :\n    (Opens.map f.1.base).obj (Y.to_RingedSpace.basic_open s) =\n      @RingedSpace.basic_open X.to_RingedSpace ((Opens.map f.1.base).obj U) (f.1.c.app _ s) :=\n  by\n  ext\n  constructor\n  · rintro ⟨⟨y, hyU⟩, hy : IsUnit _, rfl : y = _⟩\n    erw [RingedSpace.mem_basic_open _ _ ⟨x, show x ∈ (opens.map f.1.base).obj U from hyU⟩]\n    rw [← PresheafedSpace.stalk_map_germ_apply]\n    exact (PresheafedSpace.stalk_map f.1 _).is_unit_map hy\n  · rintro ⟨y, hy : IsUnit _, rfl⟩\n    erw [RingedSpace.mem_basic_open _ _ ⟨f.1.base y.1, y.2⟩]\n    rw [← PresheafedSpace.stalk_map_germ_apply] at hy\n    exact (is_unit_map_iff (PresheafedSpace.stalk_map f.1 _) _).mp hy\n#align preimage_basic_open preimage_basic_open\n\n",
 "comp_val_c_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem comp_val_c_app {X Y Z : LocallyRingedSpace} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) (U : «expr ᵒᵖ» (Opens Z)) :\n    («expr ≫ » f g).val.c.app U = «expr ≫ » (g.val.c.app U) (f.val.c.app (op <| (Opens.map g.val.base).obj U.unop)) :=\n  rfl\n#align comp_val_c_app comp_val_c_app\n\n",
 "comp_val_c":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem comp_val_c {X Y Z : LocallyRingedSpace.{u}} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) :\n    («expr ≫ » f g).val.c = «expr ≫ » g.val.c ((presheaf.pushforward _ g.val.base).map f.val.c) :=\n  rfl\n#align comp_val_c comp_val_c\n\n",
 "comp_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\n-- PROJECT: how about a typeclass \"has_structure_sheaf\" to mediate the 𝒪 notation, rather\n-- than defining it over and over for PresheafedSpace, LRS, Scheme, etc.\n-- TODO perhaps we should make a bundled `LocalRing` and return one here?\n-- TODO define `sheaf.stalk` so we can write `X.𝒪.stalk` here?\n@[simp]\ntheorem comp_val {X Y Z : LocallyRingedSpace} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) :\n    («expr ≫ » f g).val = «expr ≫ » f.val g.val :=\n  rfl\n#align comp_val comp_val\n\n",
 "basic_open_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n-- This actually holds for all ringed spaces with nontrivial stalks.\n@[simp]\ntheorem basic_open_zero (X : LocallyRingedSpace) (U : Opens X.carrier) :\n    X.to_RingedSpace.basic_open (0 : X.presheaf.obj <| op U) = «expr⊥» :=\n  by\n  simp only [RingedSpace.basic_open, isUnit_zero_iff, map_zero, zero_ne_one' (X.presheaf.stalk _), Set.setOf_false,\n    Set.image_empty]\n  rfl\n#align basic_open_zero basic_open_zero\n\n"}