{"exists_prime_spectrum_prod_le_and_ne_bot_of_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (z «expr ∉ » M) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\n  product of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\n  product or prime ideals ([samuel, § 3.3, Lemma 3]) -/\ntheorem exists_prime_spectrum_prod_le_and_ne_bot_of_domain (h_fA : ¬IsField A) {I : ideal A} (h_nzI : I ≠ «expr⊥») :\n    ∃ Z : Multiset (prime_spectrum A), Multiset.prod (Z.map as_ideal) ≤ I ∧ Multiset.prod (Z.map as_ideal) ≠ «expr⊥» :=\n  by\n  revert h_nzI\n  refine' is_noetherian.induction (fun (M : ideal A) hgt => _) I\n  intro h_nzM\n  have hA_nont : nontrivial A\n  apply is_domain.to_nontrivial A\n  by_cases h_topM : M = «expr⊤»\n  · rcases h_topM with rfl\n    obtain ⟨p_id, h_nzp, h_pp⟩ : ∃ p : ideal A, p ≠ «expr⊥» ∧ p.is_prime := by\n      apply ring.not_is_field_iff_exists_prime.mp h_fA\n    use ({⟨p_id, h_pp⟩} : Multiset (prime_spectrum A)), le_top\n    rwa [Multiset.map_singleton, Multiset.prod_singleton]\n  by_cases h_prM : M.is_prime\n  · use ({⟨M, h_prM⟩} : Multiset (prime_spectrum A))\n    rw [Multiset.map_singleton, Multiset.prod_singleton]\n    exact ⟨le_rfl, h_nzM⟩\n  obtain ⟨x, hx, y, hy, h_xy⟩ := (ideal.not_is_prime_iff.mp h_prM).resolve_left h_topM\n  have lt_add : ∀ (z) (_ : z ∉ M), M < M + span A {z} :=\n    by\n    intro z hz\n    refine' lt_of_le_of_ne le_sup_left fun m_eq => hz _\n    rw [m_eq]\n    exact mem_sup_right (mem_span_singleton_self z)\n  obtain ⟨Wx, h_Wx_le, h_Wx_ne⟩ := hgt (M + span A {x}) (lt_add _ hx) (ne_bot_of_gt (lt_add _ hx))\n  obtain ⟨Wy, h_Wy_le, h_Wx_ne⟩ := hgt (M + span A {y}) (lt_add _ hy) (ne_bot_of_gt (lt_add _ hy))\n  use Wx + Wy\n  rw [Multiset.map_add, Multiset.prod_add]\n  refine' ⟨le_trans (submodule.mul_le_mul h_Wx_le h_Wy_le) _, mt ideal.mul_eq_bot.mp _⟩\n  · rw [add_mul]\n    apply sup_le (show M * (M + span A {y}) ≤ M from ideal.mul_le_right)\n    rw [mul_add]\n    apply sup_le (show span A {x} * M ≤ M from ideal.mul_le_left)\n    rwa [span_mul_span, Set.singleton_mul_singleton, span_singleton_le_iff_mem]\n  · rintro (hx | hy) <;> contradiction\n#align exists_prime_spectrum_prod_le_and_ne_bot_of_domain exists_prime_spectrum_prod_le_and_ne_bot_of_domain\n\n",
 "exists_prime_spectrum_prod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (z «expr ∉ » M) -/\n/-\nCopyright (c) 2020 Filippo A. E. Nuccio. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Filippo A. E. Nuccio, Andrew Yang\n-/\n/-- In a noetherian ring, every ideal contains a product of prime ideals\n([samuel, § 3.3, Lemma 3])-/\ntheorem exists_prime_spectrum_prod_le (I : ideal R) :\n    ∃ Z : Multiset (prime_spectrum R), Multiset.prod (Z.map as_ideal) ≤ I :=\n  by\n  refine' is_noetherian.induction (fun (M : ideal R) hgt => _) I\n  by_cases h_prM : M.is_prime\n  · use {⟨M, h_prM⟩}\n    rw [Multiset.map_singleton, Multiset.prod_singleton]\n    exact le_rfl\n  by_cases htop : M = «expr⊤»\n  · rw [htop]\n    exact ⟨0, le_top⟩\n  have lt_add : ∀ (z) (_ : z ∉ M), M < M + span R {z} :=\n    by\n    intro z hz\n    refine' lt_of_le_of_ne le_sup_left fun m_eq => hz _\n    rw [m_eq]\n    exact ideal.mem_sup_right (mem_span_singleton_self z)\n  obtain ⟨x, hx, y, hy, hxy⟩ := (ideal.not_is_prime_iff.mp h_prM).resolve_left htop\n  obtain ⟨Wx, h_Wx⟩ := hgt (M + span R {x}) (lt_add _ hx)\n  obtain ⟨Wy, h_Wy⟩ := hgt (M + span R {y}) (lt_add _ hy)\n  use Wx + Wy\n  rw [Multiset.map_add, Multiset.prod_add]\n  apply le_trans (submodule.mul_le_mul h_Wx h_Wy)\n  rw [add_mul]\n  apply sup_le (show M * (M + span R {y}) ≤ M from ideal.mul_le_right)\n  rw [mul_add]\n  apply sup_le (show span R {x} * M ≤ M from ideal.mul_le_left)\n  rwa [span_mul_span, Set.singleton_mul_singleton, span_singleton_le_iff_mem]\n#align exists_prime_spectrum_prod_le exists_prime_spectrum_prod_le\n\n"}