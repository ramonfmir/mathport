{"zero_locus_vanishing_ideal_eq_closure":
 "theorem zero_locus_vanishing_ideal_eq_closure (t : set (prime_spectrum R)) :\n    zero_locus (vanishing_ideal t : set R) = closure t :=\n  by\n  apply Set.Subset.antisymm\n  · rintro x hx t' ⟨ht', ht⟩\n    obtain ⟨fs, rfl⟩ : ∃ s, t' = zero_locus s := by rwa [is_closed_iff_zero_locus] at ht'\n    rw [subset_zero_locus_iff_subset_vanishing_ideal] at ht\n    exact Set.Subset.trans ht hx\n  · rw [(is_closed_zero_locus _).closure_subset_iff]\n    exact subset_zero_locus_vanishing_ideal t\n#align zero_locus_vanishing_ideal_eq_closure zero_locus_vanishing_ideal_eq_closure\n\n",
 "zero_locus_univ":
 "@[simp]\ntheorem zero_locus_univ : zero_locus (Set.univ : set R) = ∅ :=\n  zero_locus_empty_of_one_mem (Set.mem_univ 1)\n#align zero_locus_univ zero_locus_univ\n\n",
 "zero_locus_union":
 "theorem zero_locus_union (s s' : set R) : zero_locus (s ∪ s') = zero_locus s ∩ zero_locus s' :=\n  (gc_set R).l_sup\n#align zero_locus_union zero_locus_union\n\n",
 "zero_locus_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem zero_locus_supr {ι : Sort _} (I : ι → ideal R) :\n    zero_locus\n        ((«expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (I i) :\n            ideal R) :\n          set R) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (zero_locus (I i)) :=\n  (gc R).l_supr\n#align zero_locus_supr zero_locus_supr\n\n",
 "zero_locus_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem zero_locus_sup (I J : ideal R) : zero_locus ((«expr ⊔ » I J : ideal R) : set R) = zero_locus I ∩ zero_locus J :=\n  (gc R).l_sup\n#align zero_locus_sup zero_locus_sup\n\n",
 "zero_locus_subset_zero_locus_singleton_iff":
 "theorem zero_locus_subset_zero_locus_singleton_iff (f g : R) :\n    zero_locus ({f} : set R) ⊆ zero_locus {g} ↔ g ∈ (ideal.span ({f} : set R)).radical := by\n  rw [← zero_locus_span {f}, ← zero_locus_span {g}, zero_locus_subset_zero_locus_iff, ideal.span_le,\n    Set.singleton_subset_iff, SetLike.mem_coe]\n#align zero_locus_subset_zero_locus_singleton_iff zero_locus_subset_zero_locus_singleton_iff\n\n",
 "zero_locus_subset_zero_locus_iff":
 "theorem zero_locus_subset_zero_locus_iff (I J : ideal R) :\n    zero_locus (I : set R) ⊆ zero_locus (J : set R) ↔ J ≤ I.radical :=\n  ⟨fun h =>\n    ideal.radical_le_radical_iff.mp\n      (vanishing_ideal_zero_locus_eq_radical I ▸ vanishing_ideal_zero_locus_eq_radical J ▸ vanishing_ideal_anti_mono h),\n    fun h => zero_locus_radical I ▸ zero_locus_anti_mono_ideal h⟩\n#align zero_locus_subset_zero_locus_iff zero_locus_subset_zero_locus_iff\n\n",
 "zero_locus_span":
 "@[simp]\ntheorem zero_locus_span (s : set R) : zero_locus (ideal.span s : set R) = zero_locus s :=\n  by\n  ext x\n  exact (submodule.gi R R).gc s x.as_ideal\n#align zero_locus_span zero_locus_span\n\n",
 "zero_locus_singleton_zero":
 "@[simp]\ntheorem zero_locus_singleton_zero : zero_locus ({0} : set R) = Set.univ :=\n  zero_locus_bot\n#align zero_locus_singleton_zero zero_locus_singleton_zero\n\n",
 "zero_locus_singleton_pow":
 "@[simp]\ntheorem zero_locus_singleton_pow (f : R) (n : ℕ) (hn : 0 < n) : zero_locus ({f ^ n} : set R) = zero_locus {f} :=\n  Set.ext fun x => by simpa using x.2.pow_mem_iff_mem n hn\n#align zero_locus_singleton_pow zero_locus_singleton_pow\n\n",
 "zero_locus_singleton_one":
 "@[simp]\ntheorem zero_locus_singleton_one : zero_locus ({1} : set R) = ∅ :=\n  zero_locus_empty_of_one_mem (Set.mem_singleton (1 : R))\n#align zero_locus_singleton_one zero_locus_singleton_one\n\n",
 "zero_locus_singleton_mul":
 "theorem zero_locus_singleton_mul (f g : R) : zero_locus ({f * g} : set R) = zero_locus {f} ∪ zero_locus {g} :=\n  Set.ext fun x => by simpa using x.2.mul_mem_iff_mem_or_mem\n#align zero_locus_singleton_mul zero_locus_singleton_mul\n\n",
 "zero_locus_radical":
 "@[simp]\ntheorem zero_locus_radical (I : ideal R) : zero_locus (I.radical : set R) = zero_locus I :=\n  vanishing_ideal_zero_locus_eq_radical I ▸ (gc R).l_u_l_eq_l I\n#align zero_locus_radical zero_locus_radical\n\n",
 "zero_locus_pow":
 "@[simp]\ntheorem zero_locus_pow (I : ideal R) {n : ℕ} (hn : 0 < n) : zero_locus ((I ^ n : ideal R) : set R) = zero_locus I :=\n  zero_locus_radical (I ^ n) ▸ (I.radical_pow n hn).symm ▸ zero_locus_radical I\n#align zero_locus_pow zero_locus_pow\n\n",
 "zero_locus_mul":
 "theorem zero_locus_mul (I J : ideal R) : zero_locus ((I * J : ideal R) : set R) = zero_locus I ∪ zero_locus J :=\n  Set.ext fun x => x.2.mul_le\n#align zero_locus_mul zero_locus_mul\n\n",
 "zero_locus_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem zero_locus_inf (I J : ideal R) : zero_locus ((«expr ⊓ » I J : ideal R) : set R) = zero_locus I ∪ zero_locus J :=\n  Set.ext fun x => x.2.inf_le\n#align zero_locus_inf zero_locus_inf\n\n",
 "zero_locus_empty_of_one_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem zero_locus_empty_of_one_mem {s : set R} (h : (1 : R) ∈ s) : zero_locus s = ∅ :=\n  by\n  rw [Set.eq_empty_iff_forall_not_mem]\n  intro x hx\n  rw [mem_zero_locus] at hx\n  have x_prime : x.as_ideal.is_prime := by infer_instance\n  have eq_top : x.as_ideal = «expr⊤» := by\n    rw [ideal.eq_top_iff_one]\n    exact hx h\n  apply x_prime.ne_top eq_top\n#align zero_locus_empty_of_one_mem zero_locus_empty_of_one_mem\n\n",
 "zero_locus_empty_iff_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem zero_locus_empty_iff_eq_top {I : ideal R} : zero_locus (I : set R) = ∅ ↔ I = «expr⊤» :=\n  by\n  constructor\n  · contrapose!\n    intro h\n    rcases ideal.exists_le_maximal I h with ⟨M, hM, hIM⟩\n    exact set.nonempty.ne_empty ⟨⟨M, hM.is_prime⟩, hIM⟩\n  · rintro rfl\n    apply zero_locus_empty_of_one_mem\n    trivial\n#align zero_locus_empty_iff_eq_top zero_locus_empty_iff_eq_top\n\n",
 "zero_locus_empty":
 "@[simp]\ntheorem zero_locus_empty : zero_locus (∅ : set R) = Set.univ :=\n  (gc_set R).l_bot\n#align zero_locus_empty zero_locus_empty\n\n",
 "zero_locus_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem zero_locus_bot : zero_locus ((«expr⊥» : ideal R) : set R) = Set.univ :=\n  (gc R).l_bot\n#align zero_locus_bot zero_locus_bot\n\n",
 "zero_locus_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem zero_locus_bUnion (s : set (set R)) :\n    zero_locus\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" s' : set R) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (zero_locus s') :=\n  by simp only [zero_locus_Union]\n#align zero_locus_bUnion zero_locus_bUnion\n\n",
 "zero_locus_anti_mono_ideal":
 "theorem zero_locus_anti_mono_ideal {s t : ideal R} (h : s ≤ t) : zero_locus (t : set R) ⊆ zero_locus (s : set R) :=\n  (gc R).monotone_l h\n#align zero_locus_anti_mono_ideal zero_locus_anti_mono_ideal\n\n",
 "zero_locus_anti_mono":
 "theorem zero_locus_anti_mono {s t : set R} (h : s ⊆ t) : zero_locus t ⊆ zero_locus s :=\n  (gc_set R).monotone_l h\n#align zero_locus_anti_mono zero_locus_anti_mono\n\n",
 "zero_locus_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem zero_locus_Union {ι : Sort _} (s : ι → set R) :\n    zero_locus («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (zero_locus (s i)) :=\n  (gc_set R).l_supr\n#align zero_locus_Union zero_locus_Union\n\n",
 "vanishing_ideal_zero_locus_eq_radical":
 "@[simp]\ntheorem vanishing_ideal_zero_locus_eq_radical (I : ideal R) : vanishing_ideal (zero_locus (I : set R)) = I.radical :=\n  ideal.ext fun f => by\n    rw [mem_vanishing_ideal, ideal.radical_eq_Inf, submodule.mem_Inf]\n    exact ⟨fun h x hx => h ⟨x, hx.2⟩ hx.1, fun h x hx => h x.1 ⟨hx, x.2⟩⟩\n#align vanishing_ideal_zero_locus_eq_radical vanishing_ideal_zero_locus_eq_radical\n\n",
 "vanishing_ideal_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem vanishing_ideal_univ : vanishing_ideal (∅ : set (prime_spectrum R)) = «expr⊤» := by simpa using (gc R).u_top\n#align vanishing_ideal_univ vanishing_ideal_univ\n\n",
 "vanishing_ideal_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem vanishing_ideal_union (t t' : set (prime_spectrum R)) :\n    vanishing_ideal (t ∪ t') = «expr ⊓ » (vanishing_ideal t) (vanishing_ideal t') :=\n  (gc R).u_inf\n#align vanishing_ideal_union vanishing_ideal_union\n\n",
 "vanishing_ideal_strict_anti_mono_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem vanishing_ideal_strict_anti_mono_iff {s t : set (prime_spectrum R)} (hs : is_closed s) (ht : is_closed t) :\n    «expr ⊂ » s t ↔ vanishing_ideal t < vanishing_ideal s := by\n  rw [Set.ssubset_def, vanishing_ideal_anti_mono_iff hs, vanishing_ideal_anti_mono_iff ht, lt_iff_le_not_le]\n#align vanishing_ideal_strict_anti_mono_iff vanishing_ideal_strict_anti_mono_iff\n\n",
 "vanishing_ideal_singleton":
 "@[simp]\ntheorem vanishing_ideal_singleton (x : prime_spectrum R) :\n    vanishing_ideal ({x} : set (prime_spectrum R)) = x.as_ideal := by simp [vanishing_ideal]\n#align vanishing_ideal_singleton vanishing_ideal_singleton\n\n",
 "vanishing_ideal_eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem vanishing_ideal_eq_top_iff {s : set (prime_spectrum R)} : vanishing_ideal s = «expr⊤» ↔ s = ∅ := by\n  rw [← top_le_iff, ← subset_zero_locus_iff_le_vanishing_ideal, submodule.top_coe, zero_locus_univ,\n    Set.subset_empty_iff]\n#align vanishing_ideal_eq_top_iff vanishing_ideal_eq_top_iff\n\n",
 "vanishing_ideal_closure":
 "theorem vanishing_ideal_closure (t : set (prime_spectrum R)) : vanishing_ideal (closure t) = vanishing_ideal t :=\n  zero_locus_vanishing_ideal_eq_closure t ▸ (gc R).u_l_u_eq_u t\n#align vanishing_ideal_closure vanishing_ideal_closure\n\n",
 "vanishing_ideal_anti_mono_iff":
 "theorem vanishing_ideal_anti_mono_iff {s t : set (prime_spectrum R)} (ht : is_closed t) :\n    s ⊆ t ↔ vanishing_ideal t ≤ vanishing_ideal s :=\n  ⟨vanishing_ideal_anti_mono, fun h =>\n    by\n    rw [← ht.closure_subset_iff, ← ht.closure_eq]\n    convert ← zero_locus_anti_mono_ideal h <;> apply zero_locus_vanishing_ideal_eq_closure⟩\n#align vanishing_ideal_anti_mono_iff vanishing_ideal_anti_mono_iff\n\n",
 "vanishing_ideal_anti_mono":
 "theorem vanishing_ideal_anti_mono {s t : set (prime_spectrum R)} (h : s ⊆ t) : vanishing_ideal t ≤ vanishing_ideal s :=\n  (gc R).monotone_u h\n#align vanishing_ideal_anti_mono vanishing_ideal_anti_mono\n\n",
 "vanishing_ideal_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem vanishing_ideal_Union {ι : Sort _} (t : ι → set (prime_spectrum R)) :\n    vanishing_ideal\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (vanishing_ideal (t i)) :=\n  (gc R).u_infi\n#align vanishing_ideal_Union vanishing_ideal_Union\n\n",
 "union_zero_locus":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem union_zero_locus (s s' : set R) :\n    zero_locus s ∪ zero_locus s' = zero_locus («expr ⊓ » (ideal.span s) (ideal.span s') : ideal R) :=\n  by\n  rw [zero_locus_inf]\n  simp\n#align union_zero_locus union_zero_locus\n\n",
 "t1_space_iff_is_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem t1_space_iff_is_field [IsDomain R] : t1_space (prime_spectrum R) ↔ IsField R :=\n  by\n  refine' ⟨_, fun h => _⟩\n  · intro h\n    have hbot : ideal.is_prime («expr⊥» : ideal R) := ideal.bot_prime\n    exact\n      not_not.1\n        (mt\n          (ring.ne_bot_of_is_maximal_of_not_is_field <|\n            (is_closed_singleton_iff_is_maximal _).1 (t1_space.t1 ⟨«expr⊥», hbot⟩))\n          (not_not.2 rfl))\n  · refine' ⟨fun x => (is_closed_singleton_iff_is_maximal x).2 _⟩\n    by_cases hx : x.as_ideal = «expr⊥»\n    · exact hx.symm ▸ @ideal.bot_is_maximal R (@field.to_division_ring _ h.to_field)\n    · exact absurd h (ring.not_is_field_iff_exists_prime.2 ⟨x.as_ideal, ⟨hx, x.2⟩⟩)\n#align t1_space_iff_is_field t1_space_iff_is_field\n\n",
 "sup_vanishing_ideal_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_vanishing_ideal_le (t t' : set (prime_spectrum R)) :\n    «expr ⊔ » (vanishing_ideal t) (vanishing_ideal t') ≤ vanishing_ideal (t ∩ t') :=\n  by\n  intro r\n  rw [submodule.mem_sup, mem_vanishing_ideal]\n  rintro ⟨f, hf, g, hg, rfl⟩ x ⟨hxt, hxt'⟩\n  rw [mem_vanishing_ideal] at hf hg\n  apply submodule.add_mem <;> solve_by_elim\n#align sup_vanishing_ideal_le sup_vanishing_ideal_le\n\n",
 "subset_zero_locus_vanishing_ideal":
 "theorem subset_zero_locus_vanishing_ideal (t : set (prime_spectrum R)) : t ⊆ zero_locus (vanishing_ideal t) :=\n  (gc R).l_u_le t\n#align subset_zero_locus_vanishing_ideal subset_zero_locus_vanishing_ideal\n\n",
 "subset_zero_locus_iff_subset_vanishing_ideal":
 "theorem subset_zero_locus_iff_subset_vanishing_ideal (t : set (prime_spectrum R)) (s : set R) :\n    t ⊆ zero_locus s ↔ s ⊆ vanishing_ideal t :=\n  (gc_set R) s t\n#align subset_zero_locus_iff_subset_vanishing_ideal subset_zero_locus_iff_subset_vanishing_ideal\n\n",
 "subset_zero_locus_iff_le_vanishing_ideal":
 "theorem subset_zero_locus_iff_le_vanishing_ideal (t : set (prime_spectrum R)) (I : ideal R) :\n    t ⊆ zero_locus I ↔ I ≤ vanishing_ideal t :=\n  ⟨fun h f k => (mem_vanishing_ideal _ _).mpr fun x j => (mem_zero_locus _ _).mpr (h j) k, fun h => fun x j =>\n    (mem_zero_locus _ _).mpr (le_trans h fun f h => ((mem_vanishing_ideal _ _).mp h) x j)⟩\n#align subset_zero_locus_iff_le_vanishing_ideal subset_zero_locus_iff_le_vanishing_ideal\n\n",
 "subset_vanishing_ideal_zero_locus":
 "theorem subset_vanishing_ideal_zero_locus (s : set R) : s ⊆ vanishing_ideal (zero_locus s) :=\n  (gc_set R).le_u_l s\n#align subset_vanishing_ideal_zero_locus subset_vanishing_ideal_zero_locus\n\n",
 "range_comap_of_surjective":
 "theorem range_comap_of_surjective (hf : surjective f) : Set.range (comap f) = zero_locus (ker f) :=\n  by\n  rw [← Set.image_univ]\n  convert image_comap_zero_locus_eq_zero_locus_comap _ _ hf _\n  rw [zero_locus_bot]\n#align range_comap_of_surjective range_comap_of_surjective\n\n",
 "prime_spectrum_prod_symm_inr_as_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem prime_spectrum_prod_symm_inr_as_ideal (x : prime_spectrum S) :\n    ((prime_spectrum_prod R S).symm <| sum.inr x).as_ideal = ideal.prod («expr⊤») x.as_ideal :=\n  by\n  cases x\n  rfl\n#align prime_spectrum_prod_symm_inr_as_ideal prime_spectrum_prod_symm_inr_as_ideal\n\n",
 "prime_spectrum_prod_symm_inl_as_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem prime_spectrum_prod_symm_inl_as_ideal (x : prime_spectrum R) :\n    ((prime_spectrum_prod R S).symm <| sum.inl x).as_ideal = ideal.prod x.as_ideal («expr⊤») :=\n  by\n  cases x\n  rfl\n#align prime_spectrum_prod_symm_inl_as_ideal prime_spectrum_prod_symm_inl_as_ideal\n\n",
 "preimage_comap_zero_locus_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem preimage_comap_zero_locus_aux (f : «expr →+* » R S) (s : set R) :\n    «expr ⁻¹' » (fun y => ⟨ideal.comap f y.as_ideal, infer_instance⟩ : prime_spectrum S → prime_spectrum R)\n        (zero_locus s) =\n      zero_locus («expr '' » f s) :=\n  by\n  ext x\n  simp only [mem_zero_locus, Set.image_subset_iff]\n  rfl\n#align preimage_comap_zero_locus_aux preimage_comap_zero_locus_aux\n\n",
 "preimage_comap_zero_locus":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem preimage_comap_zero_locus (s : set R) : «expr ⁻¹' » (comap f) (zero_locus s) = zero_locus («expr '' » f s) :=\n  preimage_comap_zero_locus_aux f s\n#align preimage_comap_zero_locus preimage_comap_zero_locus\n\n",
 "mem_zero_locus":
 "@[simp]\ntheorem mem_zero_locus (x : prime_spectrum R) (s : set R) : x ∈ zero_locus s ↔ s ⊆ x.as_ideal :=\n  iff.rfl\n#align mem_zero_locus mem_zero_locus\n\n",
 "mem_vanishing_ideal":
 "theorem mem_vanishing_ideal (t : set (prime_spectrum R)) (f : R) :\n    f ∈ vanishing_ideal t ↔ ∀ x : prime_spectrum R, x ∈ t → f ∈ x.as_ideal := by\n  rw [← SetLike.mem_coe, coe_vanishing_ideal, Set.mem_setOf_eq]\n#align mem_vanishing_ideal mem_vanishing_ideal\n\n",
 "mem_compl_zero_locus_iff_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_compl_zero_locus_iff_not_mem {f : R} {I : prime_spectrum R} :\n    I ∈ «expr ᶜ» (zero_locus {f} : set (prime_spectrum R)) ↔ f ∉ I.as_ideal := by\n  rw [Set.mem_compl_iff, mem_zero_locus, Set.singleton_subset_iff] <;> rfl\n#align mem_compl_zero_locus_iff_not_mem mem_compl_zero_locus_iff_not_mem\n\n",
 "mem_basic_open":
 "@[simp]\ntheorem mem_basic_open (f : R) (x : prime_spectrum R) : x ∈ basic_open f ↔ f ∉ x.as_ideal :=\n  iff.rfl\n#align mem_basic_open mem_basic_open\n\n",
 "localization_comap_range":
 "theorem localization_comap_range [algebra R S] (M : Submonoid R) [is_localization M S] :\n    Set.range (comap (algebra_map R S)) = { p | Disjoint (M : set R) p.as_ideal } :=\n  by\n  ext x\n  constructor\n  · simp_rw [disjoint_iff_inf_le]\n    rintro ⟨p, rfl⟩ x ⟨hx₁, hx₂⟩\n    exact (p.2.1 : ¬_) (p.as_ideal.eq_top_of_is_unit_mem hx₂ (is_localization.map_units S ⟨x, hx₁⟩))\n  · intro h\n    use ⟨x.as_ideal.map (algebra_map R S), is_localization.is_prime_of_is_prime_disjoint M S _ x.2 h⟩\n    ext1\n    exact is_localization.comap_map_of_is_prime_disjoint M S _ x.2 h\n#align localization_comap_range localization_comap_range\n\n",
 "localization_comap_injective":
 "theorem localization_comap_injective [algebra R S] (M : Submonoid R) [is_localization M S] :\n    function.injective (comap (algebra_map R S)) := by\n  intro p q h\n  replace h := congr_arg (fun x : prime_spectrum R => ideal.map (algebra_map R S) x.as_ideal) h\n  dsimp only at h\n  erw [is_localization.map_comap M S, is_localization.map_comap M S] at h\n  ext1\n  exact h\n#align localization_comap_injective localization_comap_injective\n\n",
 "localization_comap_inducing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem localization_comap_inducing [algebra R S] (M : Submonoid R) [is_localization M S] :\n    inducing (comap (algebra_map R S)) := by\n  constructor\n  rw [topological_space_eq_iff]\n  intro U\n  simp_rw [← is_closed_compl_iff]\n  generalize «expr ᶜ» U = Z\n  simp_rw [is_closed_induced_iff, is_closed_iff_zero_locus]\n  constructor\n  · rintro ⟨s, rfl⟩\n    refine' ⟨_, ⟨«expr ⁻¹' » (algebra_map R S) (ideal.span s), rfl⟩, _⟩\n    rw [preimage_comap_zero_locus, ← zero_locus_span, ← zero_locus_span s]\n    congr 1\n    exact congr_arg submodule.carrier (is_localization.map_comap M S (ideal.span s))\n  · rintro ⟨_, ⟨t, rfl⟩, rfl⟩\n    simp\n#align localization_comap_inducing localization_comap_inducing\n\n",
 "localization_comap_embedding":
 "theorem localization_comap_embedding [algebra R S] (M : Submonoid R) [is_localization M S] :\n    embedding (comap (algebra_map R S)) :=\n  ⟨localization_comap_inducing S M, localization_comap_injective S M⟩\n#align localization_comap_embedding localization_comap_embedding\n\n",
 "localization_away_open_embedding":
 "theorem localization_away_open_embedding (S : Type v) [CommRing S] [algebra R S] (r : R) [is_localization.away r S] :\n    open_embedding (comap (algebra_map R S)) :=\n  { to_embedding := localization_comap_embedding S (submonoid.powers r)\n    open_range := by\n      rw [localization_away_comap_range S r]\n      exact is_open_basic_open }\n#align localization_away_open_embedding localization_away_open_embedding\n\n",
 "localization_away_comap_range":
 "theorem localization_away_comap_range (S : Type v) [CommRing S] [algebra R S] (r : R) [is_localization.away r S] :\n    Set.range (comap (algebra_map R S)) = basic_open r :=\n  by\n  rw [localization_comap_range S (submonoid.powers r)]\n  ext\n  simp only [mem_zero_locus, basic_open_eq_zero_locus_compl, SetLike.mem_coe, Set.mem_setOf_eq,\n    Set.singleton_subset_iff, Set.mem_compl_iff, disjoint_iff_inf_le]\n  constructor\n  · intro h₁ h₂\n    exact h₁ ⟨submonoid.mem_powers r, h₂⟩\n  · rintro h₁ _ ⟨⟨n, rfl⟩, h₃⟩\n    exact h₁ (x.2.mem_of_pow_mem _ h₃)\n#align localization_away_comap_range localization_away_comap_range\n\n",
 "le_vanishing_ideal_zero_locus":
 "theorem le_vanishing_ideal_zero_locus (I : ideal R) : I ≤ vanishing_ideal (zero_locus I) :=\n  (gc R).le_u_l I\n#align le_vanishing_ideal_zero_locus le_vanishing_ideal_zero_locus\n\n",
 "le_iff_specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem le_iff_specializes (x y : prime_spectrum R) : x ≤ y ↔ «expr ⤳ » x y :=\n  (le_iff_mem_closure x y).trans specializes_iff_mem_closure.symm\n#align le_iff_specializes le_iff_specializes\n\n",
 "le_iff_mem_closure":
 "theorem le_iff_mem_closure (x y : prime_spectrum R) : x ≤ y ↔ y ∈ closure ({x} : set (prime_spectrum R)) := by\n  rw [← as_ideal_le_as_ideal, ← zero_locus_vanishing_ideal_eq_closure, mem_zero_locus, vanishing_ideal_singleton,\n    SetLike.coe_subset_coe]\n#align le_iff_mem_closure le_iff_mem_closure\n\n",
 "is_topological_basis_basic_opens":
 "theorem is_topological_basis_basic_opens :\n    topological_space.is_topological_basis (Set.range fun r : R => (basic_open r : set (prime_spectrum R))) :=\n  by\n  apply topological_space.is_topological_basis_of_open_of_nhds\n  · rintro _ ⟨r, rfl⟩\n    exact is_open_basic_open\n  · rintro p U hp ⟨s, hs⟩\n    rw [← compl_compl U, Set.mem_compl_iff, ← hs, mem_zero_locus, Set.not_subset] at hp\n    obtain ⟨f, hfs, hfp⟩ := hp\n    refine' ⟨basic_open f, ⟨f, rfl⟩, hfp, _⟩\n    rw [← Set.compl_subset_compl, ← hs, basic_open_eq_zero_locus_compl, compl_compl]\n    exact zero_locus_anti_mono (set.singleton_subset_iff.mpr hfs)\n#align is_topological_basis_basic_opens is_topological_basis_basic_opens\n\n",
 "is_radical_vanishing_ideal":
 "theorem is_radical_vanishing_ideal (s : set (prime_spectrum R)) : (vanishing_ideal s).is_radical :=\n  by\n  rw [← vanishing_ideal_closure, ← zero_locus_vanishing_ideal_eq_closure, vanishing_ideal_zero_locus_eq_radical]\n  apply ideal.radical_is_radical\n#align is_radical_vanishing_ideal is_radical_vanishing_ideal\n\n",
 "is_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_open_iff (U : set (prime_spectrum R)) : is_open U ↔ ∃ s, «expr ᶜ» U = zero_locus s := by\n  simp only [@eq_comm _ («expr ᶜ» U)] <;> rfl\n#align is_open_iff is_open_iff\n\n",
 "is_open_basic_open":
 "theorem is_open_basic_open {a : R} : is_open (basic_open a : set (prime_spectrum R)) :=\n  (basic_open a).property\n#align is_open_basic_open is_open_basic_open\n\n",
 "is_local_ring_hom_iff_comap_closed_point":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_local_ring_hom_iff_comap_closed_point {S : Type v} [CommRing S] [local_ring S] (f : «expr →+* » R S) :\n    is_local_ring_hom f ↔ prime_spectrum.comap f (closed_point S) = closed_point R :=\n  by\n  rw [(local_hom_tfae f).out 0 4, prime_spectrum.ext_iff]\n  rfl\n#align is_local_ring_hom_iff_comap_closed_point is_local_ring_hom_iff_comap_closed_point\n\n",
 "is_irreducible_zero_locus_iff_of_radical":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprZ( )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprZ( )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprZ( )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprZ( )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprZ( )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprZ( )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprZ( )» -/\ntheorem is_irreducible_zero_locus_iff_of_radical (I : ideal R) (hI : I.is_radical) :\n    is_irreducible (zero_locus (I : set R)) ↔ I.is_prime :=\n  by\n  rw [ideal.is_prime_iff, is_irreducible]\n  apply and_congr\n  · rw [Set.nonempty_iff_ne_empty, ne.def, zero_locus_empty_iff_eq_top]\n  · trans\n      ∀ x y : ideal R,\n        «exprZ( )» I ⊆ «exprZ( )» x ∪ «exprZ( )» y → «exprZ( )» I ⊆ «exprZ( )» x ∨ «exprZ( )» I ⊆ «exprZ( )» y\n    · simp_rw [is_preirreducible_iff_closed_union_closed, is_closed_iff_zero_locus_ideal]\n      constructor\n      · rintro h x y\n        exact h _ _ ⟨x, rfl⟩ ⟨y, rfl⟩\n      · rintro h _ _ ⟨x, rfl⟩ ⟨y, rfl⟩\n        exact h x y\n    · simp_rw [← zero_locus_inf, subset_zero_locus_iff_le_vanishing_ideal, vanishing_ideal_zero_locus_eq_radical,\n        hI.radical]\n      constructor\n      · simp_rw [← SetLike.mem_coe, ← Set.singleton_subset_iff, ← ideal.span_le, ←\n          ideal.span_singleton_mul_span_singleton]\n        refine' fun h x y h' => h _ _ _\n        rw [← hI.radical_le_iff] at h'⊢\n        simpa only [ideal.radical_inf, ideal.radical_mul] using h'\n      · simp_rw [or_iff_not_imp_left, SetLike.not_le_iff_exists]\n        rintro h s t h' ⟨x, hx, hx'⟩ y hy\n        exact h (h' ⟨ideal.mul_mem_right _ _ hx, ideal.mul_mem_left _ _ hy⟩) hx'\n#align is_irreducible_zero_locus_iff_of_radical is_irreducible_zero_locus_iff_of_radical\n\n",
 "is_irreducible_zero_locus_iff":
 "theorem is_irreducible_zero_locus_iff (I : ideal R) : is_irreducible (zero_locus (I : set R)) ↔ I.radical.is_prime :=\n  zero_locus_radical I ▸ is_irreducible_zero_locus_iff_of_radical _ I.radical_is_radical\n#align is_irreducible_zero_locus_iff is_irreducible_zero_locus_iff\n\n",
 "is_irreducible_iff_vanishing_ideal_is_prime":
 "theorem is_irreducible_iff_vanishing_ideal_is_prime {s : set (prime_spectrum R)} :\n    is_irreducible s ↔ (vanishing_ideal s).is_prime := by\n  rw [← is_irreducible_iff_closure, ← zero_locus_vanishing_ideal_eq_closure,\n    is_irreducible_zero_locus_iff_of_radical _ (is_radical_vanishing_ideal s)]\n#align is_irreducible_iff_vanishing_ideal_is_prime is_irreducible_iff_vanishing_ideal_is_prime\n\n",
 "is_compact_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_compact_basic_open (f : R) : is_compact (basic_open f : set (prime_spectrum R)) :=\n  is_compact_of_finite_subfamily_closed fun ι Z hZc hZ =>\n    by\n    let I : ι → ideal R := fun i => vanishing_ideal (Z i)\n    have hI : ∀ i, Z i = zero_locus (I i) := fun i => by\n      simpa only [zero_locus_vanishing_ideal_eq_closure] using (hZc i).closure_eq.symm\n    rw [basic_open_eq_zero_locus_compl f, Set.inter_comm, ← Set.diff_eq, Set.diff_eq_empty, funext hI, ←\n      zero_locus_supr] at hZ\n    obtain ⟨n, hn⟩ :\n      f ∈\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            (I i)).radical :=\n      by\n      rw [← vanishing_ideal_zero_locus_eq_radical]\n      apply vanishing_ideal_anti_mono hZ\n      exact subset_vanishing_ideal_zero_locus {f} (Set.mem_singleton f)\n    rcases submodule.exists_finset_of_mem_supr I hn with ⟨s, hs⟩\n    use s\n    -- Using simp_rw here, because `hI` and `zero_locus_supr` need to be applied underneath binders\n    simp_rw [basic_open_eq_zero_locus_compl f, Set.inter_comm («expr ᶜ» (zero_locus {f})), ← Set.diff_eq,\n      Set.diff_eq_empty, hI, ← zero_locus_supr]\n    rw [← zero_locus_radical]\n    -- this one can't be in `simp_rw` because it would loop\n    apply zero_locus_anti_mono\n    rw [Set.singleton_subset_iff]\n    exact ⟨n, hs⟩\n#align is_compact_basic_open is_compact_basic_open\n\n",
 "is_closed_zero_locus":
 "theorem is_closed_zero_locus (s : set R) : is_closed (zero_locus s) :=\n  by\n  rw [is_closed_iff_zero_locus]\n  exact ⟨s, rfl⟩\n#align is_closed_zero_locus is_closed_zero_locus\n\n",
 "is_closed_singleton_iff_is_maximal":
 "theorem is_closed_singleton_iff_is_maximal (x : prime_spectrum R) :\n    is_closed ({x} : set (prime_spectrum R)) ↔ x.as_ideal.is_maximal :=\n  by\n  refine' (is_closed_iff_zero_locus _).trans ⟨fun h => _, fun h => _⟩\n  · obtain ⟨s, hs⟩ := h\n    rw [eq_comm, Set.eq_singleton_iff_unique_mem] at hs\n    refine'\n      ⟨⟨x.2.1, fun I hI =>\n          not_not.1 (mt (ideal.exists_le_maximal I) <| not_exists.2 fun J => not_and.2 fun hJ hIJ => _)⟩⟩\n    exact\n      ne_of_lt (lt_of_lt_of_le hI hIJ)\n        (symm <| congr_arg prime_spectrum.as_ideal (hs.2 ⟨J, hJ.is_prime⟩ fun r hr => hIJ (le_of_lt hI <| hs.1 hr)))\n  · refine' ⟨x.as_ideal.1, _⟩\n    rw [eq_comm, Set.eq_singleton_iff_unique_mem]\n    refine' ⟨fun _ h => h, fun y hy => prime_spectrum.ext _ _ (h.eq_of_le y.2.ne_top hy).symm⟩\n#align is_closed_singleton_iff_is_maximal is_closed_singleton_iff_is_maximal\n\n",
 "is_closed_range_comap_of_surjective":
 "theorem is_closed_range_comap_of_surjective (hf : surjective f) : is_closed (Set.range (comap f)) :=\n  by\n  rw [range_comap_of_surjective _ f hf]\n  exact is_closed_zero_locus ↑(ker f)\n#align is_closed_range_comap_of_surjective is_closed_range_comap_of_surjective\n\n",
 "is_closed_iff_zero_locus_radical_ideal":
 "theorem is_closed_iff_zero_locus_radical_ideal (Z : set (prime_spectrum R)) :\n    is_closed Z ↔ ∃ I : ideal R, I.is_radical ∧ Z = zero_locus I :=\n  (is_closed_iff_zero_locus_ideal _).trans\n    ⟨fun ⟨I, hI⟩ => ⟨_, I.radical_is_radical, (zero_locus_radical I).substr hI⟩, fun ⟨I, _, hI⟩ => ⟨I, hI⟩⟩\n#align is_closed_iff_zero_locus_radical_ideal is_closed_iff_zero_locus_radical_ideal\n\n",
 "is_closed_iff_zero_locus_ideal":
 "theorem is_closed_iff_zero_locus_ideal (Z : set (prime_spectrum R)) : is_closed Z ↔ ∃ I : ideal R, Z = zero_locus I :=\n  (is_closed_iff_zero_locus _).trans ⟨fun ⟨s, hs⟩ => ⟨_, (zero_locus_span s).substr hs⟩, fun ⟨I, hI⟩ => ⟨I, hI⟩⟩\n#align is_closed_iff_zero_locus_ideal is_closed_iff_zero_locus_ideal\n\n",
 "is_closed_iff_zero_locus":
 "theorem is_closed_iff_zero_locus (Z : set (prime_spectrum R)) : is_closed Z ↔ ∃ s, Z = zero_locus s := by\n  rw [← is_open_compl_iff, is_open_iff, compl_compl]\n#align is_closed_iff_zero_locus is_closed_iff_zero_locus\n\n",
 "is_basis_basic_opens":
 "theorem is_basis_basic_opens : topological_space.opens.is_basis (Set.range (@basic_open R _)) :=\n  by\n  unfold topological_space.opens.is_basis\n  convert is_topological_basis_basic_opens\n  rw [← Set.range_comp]\n#align is_basis_basic_opens is_basis_basic_opens\n\n",
 "image_comap_zero_locus_eq_zero_locus_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_comap_zero_locus_eq_zero_locus_comap (hf : surjective f) (I : ideal S) :\n    «expr '' » (comap f) (zero_locus I) = zero_locus (I.comap f) :=\n  by\n  simp only [Set.ext_iff, Set.mem_image, mem_zero_locus, SetLike.coe_subset_coe]\n  refine' fun p => ⟨_, fun h_I_p => _⟩\n  · rintro ⟨p, hp, rfl⟩ a ha\n    exact hp ha\n  · have hp : ker f ≤ p.as_ideal := (ideal.comap_mono bot_le).trans h_I_p\n    refine' ⟨⟨p.as_ideal.map f, ideal.map_is_prime_of_surjective hf hp⟩, fun x hx => _, _⟩\n    · obtain ⟨x', rfl⟩ := hf x\n      exact ideal.mem_map_of_mem f (h_I_p hx)\n    · ext x\n      change f x ∈ p.as_ideal.map f ↔ _\n      rw [ideal.mem_map_iff_of_surjective f hf]\n      refine' ⟨_, fun hx => ⟨x, hx, rfl⟩⟩\n      rintro ⟨x', hx', heq⟩\n      rw [← sub_sub_cancel x' x]\n      refine' p.as_ideal.sub_mem hx' (hp _)\n      rwa [mem_ker, map_sub, sub_eq_zero]\n#align image_comap_zero_locus_eq_zero_locus_comap image_comap_zero_locus_eq_zero_locus_comap\n\n",
 "gc_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- `zero_locus` and `vanishing_ideal` form a galois connection. -/\ntheorem gc_set :\n    @GaloisConnection (set R) («expr ᵒᵈ» (set (prime_spectrum R))) _ _ (fun s => zero_locus s) fun t =>\n      vanishing_ideal t :=\n  by\n  have ideal_gc : GaloisConnection ideal.span coe := (submodule.gi R R).gc\n  simpa [zero_locus_span, function.comp] using ideal_gc.compose (gc R)\n#align gc_set gc_set\n\n",
 "gc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- `zero_locus` and `vanishing_ideal` form a galois connection. -/\ntheorem gc :\n    @GaloisConnection (ideal R) («expr ᵒᵈ» (set (prime_spectrum R))) _ _ (fun I => zero_locus I) fun t =>\n      vanishing_ideal t :=\n  fun I t => subset_zero_locus_iff_le_vanishing_ideal t I\n#align gc gc\n\n",
 "comap_singleton_is_closed_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comap_singleton_is_closed_of_surjective (f : «expr →+* » R S) (hf : function.surjective f)\n    (x : prime_spectrum S) (hx : is_closed ({x} : set (prime_spectrum S))) :\n    is_closed ({comap f x} : set (prime_spectrum R)) :=\n  haveI : x.as_ideal.is_maximal := (is_closed_singleton_iff_is_maximal x).1 hx\n  (is_closed_singleton_iff_is_maximal _).2 (ideal.comap_is_maximal_of_surjective f hf)\n#align comap_singleton_is_closed_of_surjective comap_singleton_is_closed_of_surjective\n\n",
 "comap_singleton_is_closed_of_is_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comap_singleton_is_closed_of_is_integral (f : «expr →+* » R S) (hf : f.is_integral) (x : prime_spectrum S)\n    (hx : is_closed ({x} : set (prime_spectrum S))) : is_closed ({comap f x} : set (prime_spectrum R)) :=\n  (is_closed_singleton_iff_is_maximal _).2\n    (ideal.is_maximal_comap_of_is_integral_of_is_maximal' f hf x.as_ideal <|\n      (is_closed_singleton_iff_is_maximal x).1 hx)\n#align comap_singleton_is_closed_of_is_integral comap_singleton_is_closed_of_is_integral\n\n",
 "comap_injective_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comap_injective_of_surjective (f : «expr →+* » R S) (hf : function.surjective f) :\n    function.injective (comap f) := fun x y h =>\n  prime_spectrum.ext _ _\n    (ideal.comap_injective_of_surjective f hf\n      (congr_arg prime_spectrum.as_ideal h : (comap f x).as_ideal = (comap f y).as_ideal))\n#align comap_injective_of_surjective comap_injective_of_surjective\n\n",
 "comap_inducing_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem comap_inducing_of_surjective (hf : surjective f) : inducing (comap f) :=\n  {\n    induced :=\n      by\n      simp_rw [topological_space_eq_iff, ← is_closed_compl_iff, is_closed_induced_iff, is_closed_iff_zero_locus]\n      refine' fun s =>\n        ⟨fun ⟨F, hF⟩ =>\n          ⟨zero_locus («expr ⁻¹' » f F), ⟨«expr ⁻¹' » f F, rfl⟩, by\n            rw [preimage_comap_zero_locus, surjective.image_preimage hf, hF]⟩,\n          _⟩\n      rintro ⟨-, ⟨F, rfl⟩, hF⟩\n      exact ⟨«expr '' » f F, hF.symm.trans (preimage_comap_zero_locus f F)⟩ }\n#align comap_inducing_of_surjective comap_inducing_of_surjective\n\n",
 "comap_id":
 "@[simp]\ntheorem comap_id : comap (RingHom.id R) = continuous_map.id _ :=\n  by\n  ext\n  rfl\n#align comap_id comap_id\n\n",
 "comap_comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comap_comp_apply (f : «expr →+* » R S) (g : «expr →+* » S S') (x : prime_spectrum S') :\n    prime_spectrum.comap (g.comp f) x = (prime_spectrum.comap f) (prime_spectrum.comap g x) :=\n  rfl\n#align comap_comp_apply comap_comp_apply\n\n",
 "comap_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem comap_comp (f : «expr →+* » R S) (g : «expr →+* » S S') : comap (g.comp f) = (comap f).comp (comap g) :=\n  rfl\n#align comap_comp comap_comp\n\n",
 "comap_closed_point":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem comap_closed_point {S : Type v} [CommRing S] [local_ring S] (f : «expr →+* » R S) [is_local_ring_hom f] :\n    prime_spectrum.comap f (closed_point S) = closed_point R :=\n  (is_local_ring_hom_iff_comap_closed_point f).mp infer_instance\n#align comap_closed_point comap_closed_point\n\n",
 "comap_as_ideal":
 "@[simp]\ntheorem comap_as_ideal (y : prime_spectrum S) : (comap f y).as_ideal = ideal.comap f y.as_ideal :=\n  rfl\n#align comap_as_ideal comap_as_ideal\n\n",
 "coe_vanishing_ideal":
 "theorem coe_vanishing_ideal (t : set (prime_spectrum R)) :\n    (vanishing_ideal t : set R) = { f : R | ∀ x : prime_spectrum R, x ∈ t → f ∈ x.as_ideal } :=\n  by\n  ext f\n  rw [vanishing_ideal, SetLike.mem_coe, submodule.mem_infi]\n  apply forall_congr'; intro x\n  rw [submodule.mem_infi]\n#align coe_vanishing_ideal coe_vanishing_ideal\n\n",
 "closure_singleton":
 "theorem closure_singleton (x) : closure ({x} : set (prime_spectrum R)) = zero_locus x.as_ideal := by\n  rw [← zero_locus_vanishing_ideal_eq_closure, vanishing_ideal_singleton]\n#align closure_singleton closure_singleton\n\n",
 "closed_embedding_comap_of_surjective":
 "theorem closed_embedding_comap_of_surjective (hf : surjective f) : closed_embedding (comap f) :=\n  { induced := (comap_inducing_of_surjective S f hf).induced\n    inj := comap_injective_of_surjective f hf\n    closed_range := is_closed_range_comap_of_surjective S f hf }\n#align closed_embedding_comap_of_surjective closed_embedding_comap_of_surjective\n\n",
 "basic_open_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem basic_open_zero : basic_open (0 : R) = «expr⊥» :=\n  topological_space.opens.ext <| by simp\n#align basic_open_zero basic_open_zero\n\n",
 "basic_open_pow":
 "@[simp]\ntheorem basic_open_pow (f : R) (n : ℕ) (hn : 0 < n) : basic_open (f ^ n) = basic_open f :=\n  topological_space.opens.ext <| by simpa using zero_locus_singleton_pow f n hn\n#align basic_open_pow basic_open_pow\n\n",
 "basic_open_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem basic_open_one : basic_open (1 : R) = «expr⊤» :=\n  topological_space.opens.ext <| by simp\n#align basic_open_one basic_open_one\n\n",
 "basic_open_mul_le_right":
 "theorem basic_open_mul_le_right (f g : R) : basic_open (f * g) ≤ basic_open g :=\n  by\n  rw [basic_open_mul f g]\n  exact inf_le_right\n#align basic_open_mul_le_right basic_open_mul_le_right\n\n",
 "basic_open_mul_le_left":
 "theorem basic_open_mul_le_left (f g : R) : basic_open (f * g) ≤ basic_open f :=\n  by\n  rw [basic_open_mul f g]\n  exact inf_le_left\n#align basic_open_mul_le_left basic_open_mul_le_left\n\n",
 "basic_open_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem basic_open_mul (f g : R) : basic_open (f * g) = «expr ⊓ » (basic_open f) (basic_open g) :=\n  topological_space.opens.ext <| by simp [zero_locus_singleton_mul]\n#align basic_open_mul basic_open_mul\n\n",
 "basic_open_le_basic_open_iff":
 "theorem basic_open_le_basic_open_iff (f g : R) : basic_open f ≤ basic_open g ↔ f ∈ (ideal.span ({g} : set R)).radical :=\n  by\n  rw [topological_space.opens.le_def, basic_open_eq_zero_locus_compl, basic_open_eq_zero_locus_compl, Set.le_eq_subset,\n    Set.compl_subset_compl, zero_locus_subset_zero_locus_singleton_iff]\n#align basic_open_le_basic_open_iff basic_open_le_basic_open_iff\n\n",
 "basic_open_eq_zero_locus_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem basic_open_eq_zero_locus_compl (r : R) : (basic_open r : set (prime_spectrum R)) = «expr ᶜ» (zero_locus {r}) :=\n  Set.ext fun x => by simpa only [Set.mem_compl_iff, mem_zero_locus, Set.singleton_subset_iff]\n#align basic_open_eq_zero_locus_compl basic_open_eq_zero_locus_compl\n\n",
 "basic_open_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem basic_open_eq_bot_iff (f : R) : basic_open f = «expr⊥» ↔ is_nilpotent f :=\n  by\n  rw [← subtype.coe_injective.eq_iff, basic_open_eq_zero_locus_compl]\n  simp only [Set.eq_univ_iff_forall, Set.singleton_subset_iff, topological_space.opens.coe_bot, nilpotent_iff_mem_prime,\n    Set.compl_empty_iff, mem_zero_locus, SetLike.mem_coe]\n  exact ⟨fun h I hI => h ⟨I, hI⟩, fun h ⟨I, hI⟩ => h I hI⟩\n#align basic_open_eq_bot_iff basic_open_eq_bot_iff\n\n",
 "as_ideal_lt_as_ideal":
 "@[simp]\ntheorem as_ideal_lt_as_ideal (x y : prime_spectrum R) : x.as_ideal < y.as_ideal ↔ x < y :=\n  iff.rfl\n#align as_ideal_lt_as_ideal as_ideal_lt_as_ideal\n\n",
 "as_ideal_le_as_ideal":
 "@[simp]\ntheorem as_ideal_le_as_ideal (x y : prime_spectrum R) : x.as_ideal ≤ y.as_ideal ↔ x ≤ y :=\n  iff.rfl\n#align as_ideal_le_as_ideal as_ideal_le_as_ideal\n\n",
 "PUnit":
 "#print PUnit /-\n/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\n/-- The prime spectrum of the zero ring is empty. -/\ntheorem PUnit (x : prime_spectrum PUnit) : false :=\n  x.1.ne_top_iff_one.1 x.2.1 <| subsingleton.elim (0 : PUnit) 1 ▸ x.1.zero_mem\n#align punit PUnit\n-/\n\n"}