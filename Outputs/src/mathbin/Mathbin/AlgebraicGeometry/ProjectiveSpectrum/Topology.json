{"zero_locus_vanishing_ideal_eq_closure":
 "theorem zero_locus_vanishing_ideal_eq_closure (t : Set (projective_spectrum ğ’œ)) :\n    zero_locus ğ’œ (vanishing_ideal t : Set A) = closure t :=\n  by\n  apply Set.Subset.antisymm\n  Â· rintro x hx t' âŸ¨ht', htâŸ©\n    obtain âŸ¨fs, rflâŸ© : âˆƒ s, t' = zero_locus ğ’œ s := by rwa [is_closed_iff_zero_locus] at ht'\n    rw [subset_zero_locus_iff_subset_vanishing_ideal] at ht\n    exact Set.Subset.trans ht hx\n  Â· rw [(is_closed_zero_locus _ _).closure_subset_iff]\n    exact subset_zero_locus_vanishing_ideal ğ’œ t\n#align zero_locus_vanishing_ideal_eq_closure zero_locus_vanishing_ideal_eq_closure\n\n",
 "zero_locus_univ":
 "@[simp]\ntheorem zero_locus_univ : zero_locus ğ’œ (Set.univ : Set A) = âˆ… :=\n  zero_locus_empty_of_one_mem _ (Set.mem_univ 1)\n#align zero_locus_univ zero_locus_univ\n\n",
 "zero_locus_union":
 "theorem zero_locus_union (s s' : Set A) : zero_locus ğ’œ (s âˆª s') = zero_locus _ s âˆ© zero_locus _ s' :=\n  (gc_set ğ’œ).l_sup\n#align zero_locus_union zero_locus_union\n\n",
 "zero_locus_supr_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem zero_locus_supr_ideal {Î³ : Sort _} (I : Î³ â†’ Ideal A) :\n    zero_locus _\n        ((Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" (I i) :\n            Ideal A) :\n          Set A) =\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\"\n        (zero_locus ğ’œ (I i)) :=\n  (gc_ideal ğ’œ).l_supr\n#align zero_locus_supr_ideal zero_locus_supr_ideal\n\n",
 "zero_locus_supr_homogeneous_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem zero_locus_supr_homogeneous_ideal {Î³ : Sort _} (I : Î³ â†’ homogeneous_ideal ğ’œ) :\n    zero_locus _\n        ((Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" (I i) :\n            homogeneous_ideal ğ’œ) :\n          Set A) =\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\"\n        (zero_locus ğ’œ (I i)) :=\n  (gc_homogeneous_ideal ğ’œ).l_supr\n#align zero_locus_supr_homogeneous_ideal zero_locus_supr_homogeneous_ideal\n\n",
 "zero_locus_sup_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\ntheorem zero_locus_sup_ideal (I J : Ideal A) :\n    zero_locus ğ’œ ((Â«expr âŠ” Â» I J : Ideal A) : Set A) = zero_locus _ I âˆ© zero_locus _ J :=\n  (gc_ideal ğ’œ).l_sup\n#align zero_locus_sup_ideal zero_locus_sup_ideal\n\n",
 "zero_locus_sup_homogeneous_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\ntheorem zero_locus_sup_homogeneous_ideal (I J : homogeneous_ideal ğ’œ) :\n    zero_locus ğ’œ ((Â«expr âŠ” Â» I J : homogeneous_ideal ğ’œ) : Set A) = zero_locus _ I âˆ© zero_locus _ J :=\n  (gc_homogeneous_ideal ğ’œ).l_sup\n#align zero_locus_sup_homogeneous_ideal zero_locus_sup_homogeneous_ideal\n\n",
 "zero_locus_span":
 "@[simp]\ntheorem zero_locus_span (s : Set A) : zero_locus ğ’œ (Ideal.span s) = zero_locus ğ’œ s :=\n  by\n  ext x\n  exact (Submodule.gi _ _).gc s x.as_homogeneous_ideal.to_ideal\n#align zero_locus_span zero_locus_span\n\n",
 "zero_locus_singleton_zero":
 "@[simp]\ntheorem zero_locus_singleton_zero : zero_locus ğ’œ ({0} : Set A) = Set.univ :=\n  zero_locus_bot _\n#align zero_locus_singleton_zero zero_locus_singleton_zero\n\n",
 "zero_locus_singleton_pow":
 "@[simp]\ntheorem zero_locus_singleton_pow (f : A) (n : â„•) (hn : 0 < n) : zero_locus ğ’œ ({f ^ n} : Set A) = zero_locus ğ’œ {f} :=\n  Set.ext fun x => by simpa using x.is_prime.pow_mem_iff_mem n hn\n#align zero_locus_singleton_pow zero_locus_singleton_pow\n\n",
 "zero_locus_singleton_one":
 "@[simp]\ntheorem zero_locus_singleton_one : zero_locus ğ’œ ({1} : Set A) = âˆ… :=\n  zero_locus_empty_of_one_mem ğ’œ (Set.mem_singleton (1 : A))\n#align zero_locus_singleton_one zero_locus_singleton_one\n\n",
 "zero_locus_singleton_mul":
 "theorem zero_locus_singleton_mul (f g : A) : zero_locus ğ’œ ({f * g} : Set A) = zero_locus ğ’œ {f} âˆª zero_locus ğ’œ {g} :=\n  Set.ext fun x => by simpa using x.is_prime.mul_mem_iff_mem_or_mem\n#align zero_locus_singleton_mul zero_locus_singleton_mul\n\n",
 "zero_locus_mul_ideal":
 "theorem zero_locus_mul_ideal (I J : Ideal A) :\n    zero_locus ğ’œ ((I * J : Ideal A) : Set A) = zero_locus ğ’œ I âˆª zero_locus ğ’œ J :=\n  Set.ext fun x => x.is_prime.mul_le\n#align zero_locus_mul_ideal zero_locus_mul_ideal\n\n",
 "zero_locus_mul_homogeneous_ideal":
 "theorem zero_locus_mul_homogeneous_ideal (I J : homogeneous_ideal ğ’œ) :\n    zero_locus ğ’œ ((I * J : homogeneous_ideal ğ’œ) : Set A) = zero_locus ğ’œ I âˆª zero_locus ğ’œ J :=\n  Set.ext fun x => x.is_prime.mul_le\n#align zero_locus_mul_homogeneous_ideal zero_locus_mul_homogeneous_ideal\n\n",
 "zero_locus_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem zero_locus_inf (I J : Ideal A) :\n    zero_locus ğ’œ ((Â«expr âŠ“ Â» I J : Ideal A) : Set A) = zero_locus ğ’œ I âˆª zero_locus ğ’œ J :=\n  Set.ext fun x => x.is_prime.inf_le\n#align zero_locus_inf zero_locus_inf\n\n",
 "zero_locus_empty_of_one_mem":
 "theorem zero_locus_empty_of_one_mem {s : Set A} (h : (1 : A) âˆˆ s) : zero_locus ğ’œ s = âˆ… :=\n  Set.eq_empty_iff_forall_not_mem.mpr fun x hx =>\n    (inferInstance : x.as_homogeneous_ideal.to_ideal.is_prime).ne_top <|\n      x.as_homogeneous_ideal.to_ideal.eq_top_iff_one.mpr <| hx h\n#align zero_locus_empty_of_one_mem zero_locus_empty_of_one_mem\n\n",
 "zero_locus_empty":
 "@[simp]\ntheorem zero_locus_empty : zero_locus ğ’œ (âˆ… : Set A) = Set.univ :=\n  (gc_set ğ’œ).l_bot\n#align zero_locus_empty zero_locus_empty\n\n",
 "zero_locus_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem zero_locus_bot : zero_locus ğ’œ ((Â«exprâŠ¥Â» : Ideal A) : Set A) = Set.univ :=\n  (gc_ideal ğ’œ).l_bot\n#align zero_locus_bot zero_locus_bot\n\n",
 "zero_locus_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem zero_locus_bUnion (s : Set (Set A)) :\n    zero_locus ğ’œ\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" s' : Set A) =\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\"\n        (zero_locus ğ’œ s') :=\n  by simp only [zero_locus_Union]\n#align zero_locus_bUnion zero_locus_bUnion\n\n",
 "zero_locus_anti_mono_ideal":
 "theorem zero_locus_anti_mono_ideal {s t : Ideal A} (h : s â‰¤ t) : zero_locus ğ’œ (t : Set A) âŠ† zero_locus ğ’œ (s : Set A) :=\n  (gc_ideal _).monotone_l h\n#align zero_locus_anti_mono_ideal zero_locus_anti_mono_ideal\n\n",
 "zero_locus_anti_mono_homogeneous_ideal":
 "theorem zero_locus_anti_mono_homogeneous_ideal {s t : homogeneous_ideal ğ’œ} (h : s â‰¤ t) :\n    zero_locus ğ’œ (t : Set A) âŠ† zero_locus ğ’œ (s : Set A) :=\n  (gc_homogeneous_ideal _).monotone_l h\n#align zero_locus_anti_mono_homogeneous_ideal zero_locus_anti_mono_homogeneous_ideal\n\n",
 "zero_locus_anti_mono":
 "theorem zero_locus_anti_mono {s t : Set A} (h : s âŠ† t) : zero_locus ğ’œ t âŠ† zero_locus ğ’œ s :=\n  (gc_set _).monotone_l h\n#align zero_locus_anti_mono zero_locus_anti_mono\n\n",
 "zero_locus_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem zero_locus_Union {Î³ : Sort _} (s : Î³ â†’ Set A) :\n    zero_locus ğ’œ\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (s i)) =\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\"\n        (zero_locus ğ’œ (s i)) :=\n  (gc_set ğ’œ).l_supr\n#align zero_locus_Union zero_locus_Union\n\n",
 "vanishing_ideal_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n@[simp]\ntheorem vanishing_ideal_univ : vanishing_ideal (âˆ… : Set (projective_spectrum ğ’œ)) = Â«exprâŠ¤Â» := by\n  simpa using (gc_ideal _).u_top\n#align vanishing_ideal_univ vanishing_ideal_univ\n\n",
 "vanishing_ideal_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem vanishing_ideal_union (t t' : Set (projective_spectrum ğ’œ)) :\n    vanishing_ideal (t âˆª t') = Â«expr âŠ“ Â» (vanishing_ideal t) (vanishing_ideal t') := by\n  ext1 <;> convert(gc_ideal ğ’œ).u_inf\n#align vanishing_ideal_union vanishing_ideal_union\n\n",
 "vanishing_ideal_singleton":
 "@[simp]\ntheorem vanishing_ideal_singleton (x : projective_spectrum ğ’œ) :\n    vanishing_ideal ({x} : Set (projective_spectrum ğ’œ)) = x.as_homogeneous_ideal := by simp [vanishing_ideal]\n#align vanishing_ideal_singleton vanishing_ideal_singleton\n\n",
 "vanishing_ideal_closure":
 "theorem vanishing_ideal_closure (t : Set (projective_spectrum ğ’œ)) : vanishing_ideal (closure t) = vanishing_ideal t :=\n  by\n  have := (gc_ideal ğ’œ).u_l_u_eq_u t\n  dsimp only at this\n  ext1\n  erw [zero_locus_vanishing_ideal_eq_closure ğ’œ t] at this\n  exact this\n#align vanishing_ideal_closure vanishing_ideal_closure\n\n",
 "vanishing_ideal_anti_mono":
 "theorem vanishing_ideal_anti_mono {s t : Set (projective_spectrum ğ’œ)} (h : s âŠ† t) :\n    vanishing_ideal t â‰¤ vanishing_ideal s :=\n  (gc_ideal _).monotone_u h\n#align vanishing_ideal_anti_mono vanishing_ideal_anti_mono\n\n",
 "vanishing_ideal_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\ntheorem vanishing_ideal_Union {Î³ : Sort _} (t : Î³ â†’ Set (projective_spectrum ğ’œ)) :\n    vanishing_ideal\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (t i)) =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        (vanishing_ideal (t i)) :=\n  homogeneous_ideal.to_ideal_injective <| by convert(gc_ideal ğ’œ).u_infi <;> exact homogeneous_ideal.to_ideal_infi _\n#align vanishing_ideal_Union vanishing_ideal_Union\n\n",
 "union_zero_locus":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem union_zero_locus (s s' : Set A) :\n    zero_locus ğ’œ s âˆª zero_locus ğ’œ s' = zero_locus ğ’œ (Â«expr âŠ“ Â» (Ideal.span s) (Ideal.span s') : Ideal A) :=\n  by\n  rw [zero_locus_inf]\n  simp\n#align union_zero_locus union_zero_locus\n\n",
 "sup_vanishing_ideal_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\ntheorem sup_vanishing_ideal_le (t t' : Set (projective_spectrum ğ’œ)) :\n    Â«expr âŠ” Â» (vanishing_ideal t) (vanishing_ideal t') â‰¤ vanishing_ideal (t âˆ© t') :=\n  by\n  intro r\n  rw [â† homogeneous_ideal.mem_iff, homogeneous_ideal.to_ideal_sup, mem_vanishing_ideal, Submodule.mem_sup]\n  rintro âŸ¨f, hf, g, hg, rflâŸ© x âŸ¨hxt, hxt'âŸ©\n  erw [mem_vanishing_ideal] at hf hg\n  apply Submodule.add_mem <;> solve_by_elim\n#align sup_vanishing_ideal_le sup_vanishing_ideal_le\n\n",
 "subset_zero_locus_vanishing_ideal":
 "theorem subset_zero_locus_vanishing_ideal (t : Set (projective_spectrum ğ’œ)) : t âŠ† zero_locus ğ’œ (vanishing_ideal t) :=\n  (gc_ideal _).l_u_le t\n#align subset_zero_locus_vanishing_ideal subset_zero_locus_vanishing_ideal\n\n",
 "subset_zero_locus_iff_subset_vanishing_ideal":
 "theorem subset_zero_locus_iff_subset_vanishing_ideal (t : Set (projective_spectrum ğ’œ)) (s : Set A) :\n    t âŠ† zero_locus ğ’œ s â†” s âŠ† vanishing_ideal t :=\n  (gc_set _) s t\n#align subset_zero_locus_iff_subset_vanishing_ideal subset_zero_locus_iff_subset_vanishing_ideal\n\n",
 "subset_zero_locus_iff_le_vanishing_ideal":
 "theorem subset_zero_locus_iff_le_vanishing_ideal (t : Set (projective_spectrum ğ’œ)) (I : Ideal A) :\n    t âŠ† zero_locus ğ’œ I â†” I â‰¤ (vanishing_ideal t).to_ideal :=\n  âŸ¨fun h f k => (mem_vanishing_ideal _ _).mpr fun x j => (mem_zero_locus _ _ _).mpr (h j) k, fun h => fun x j =>\n    (mem_zero_locus _ _ _).mpr (le_trans h fun f h => ((mem_vanishing_ideal _ _).mp h) x j)âŸ©\n#align subset_zero_locus_iff_le_vanishing_ideal subset_zero_locus_iff_le_vanishing_ideal\n\n",
 "subset_vanishing_ideal_zero_locus":
 "theorem subset_vanishing_ideal_zero_locus (s : Set A) : s âŠ† vanishing_ideal (zero_locus ğ’œ s) :=\n  (gc_set _).le_u_l s\n#align subset_vanishing_ideal_zero_locus subset_vanishing_ideal_zero_locus\n\n",
 "mem_zero_locus":
 "/-\nCopyright (c) 2020 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang, Johan Commelin\n-/\n@[simp]\ntheorem mem_zero_locus (x : projective_spectrum ğ’œ) (s : Set A) : x âˆˆ zero_locus ğ’œ s â†” s âŠ† x.as_homogeneous_ideal :=\n  iff.rfl\n#align mem_zero_locus mem_zero_locus\n\n",
 "mem_vanishing_ideal":
 "theorem mem_vanishing_ideal (t : Set (projective_spectrum ğ’œ)) (f : A) :\n    f âˆˆ vanishing_ideal t â†” âˆ€ x : projective_spectrum ğ’œ, x âˆˆ t â†’ f âˆˆ x.as_homogeneous_ideal := by\n  rw [â† SetLike.mem_coe, coe_vanishing_ideal, Set.mem_setOf_eq]\n#align mem_vanishing_ideal mem_vanishing_ideal\n\n",
 "mem_compl_zero_locus_iff_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem mem_compl_zero_locus_iff_not_mem {f : A} {I : projective_spectrum ğ’œ} :\n    I âˆˆ Â«expr á¶œÂ» (zero_locus ğ’œ {f} : Set (projective_spectrum ğ’œ)) â†” f âˆ‰ I.as_homogeneous_ideal := by\n  rw [Set.mem_compl_iff, mem_zero_locus, Set.singleton_subset_iff] <;> rfl\n#align mem_compl_zero_locus_iff_not_mem mem_compl_zero_locus_iff_not_mem\n\n",
 "mem_coe_basic_open":
 "theorem mem_coe_basic_open (f : A) (x : projective_spectrum ğ’œ) :\n    x âˆˆ (â†‘(basic_open ğ’œ f) : Set (projective_spectrum ğ’œ)) â†” f âˆ‰ x.as_homogeneous_ideal :=\n  iff.rfl\n#align mem_coe_basic_open mem_coe_basic_open\n\n",
 "mem_basic_open":
 "@[simp]\ntheorem mem_basic_open (f : A) (x : projective_spectrum ğ’œ) : x âˆˆ basic_open ğ’œ f â†” f âˆ‰ x.as_homogeneous_ideal :=\n  iff.rfl\n#align mem_basic_open mem_basic_open\n\n",
 "le_iff_mem_closure":
 "theorem le_iff_mem_closure (x y : projective_spectrum ğ’œ) : x â‰¤ y â†” y âˆˆ closure ({x} : Set (projective_spectrum ğ’œ)) :=\n  by\n  rw [â† as_ideal_le_as_ideal, â† zero_locus_vanishing_ideal_eq_closure, mem_zero_locus, vanishing_ideal_singleton]\n  simp only [coe_subset_coe, Subtype.coe_le_coe, coe_coe]\n#align le_iff_mem_closure le_iff_mem_closure\n\n",
 "is_topological_basis_basic_opens":
 "theorem is_topological_basis_basic_opens :\n    TopologicalSpace.IsTopologicalBasis (Set.range fun r : A => (basic_open ğ’œ r : Set (projective_spectrum ğ’œ))) :=\n  by\n  apply TopologicalSpace.isTopologicalBasis_of_open_of_nhds\n  Â· rintro _ âŸ¨r, rflâŸ©\n    exact is_open_basic_open ğ’œ\n  Â· rintro p U hp âŸ¨s, hsâŸ©\n    rw [â† compl_compl U, Set.mem_compl_iff, â† hs, mem_zero_locus, Set.not_subset] at hp\n    obtain âŸ¨f, hfs, hfpâŸ© := hp\n    refine' âŸ¨basic_open ğ’œ f, âŸ¨f, rflâŸ©, hfp, _âŸ©\n    rw [â† Set.compl_subset_compl, â† hs, basic_open_eq_zero_locus_compl, compl_compl]\n    exact zero_locus_anti_mono ğ’œ (set.singleton_subset_iff.mpr hfs)\n#align is_topological_basis_basic_opens is_topological_basis_basic_opens\n\n",
 "is_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem is_open_iff (U : Set (projective_spectrum ğ’œ)) : IsOpen U â†” âˆƒ s, Â«expr á¶œÂ» U = zero_locus ğ’œ s := by\n  simp only [@eq_comm _ (Â«expr á¶œÂ» U)] <;> rfl\n#align is_open_iff is_open_iff\n\n",
 "is_open_basic_open":
 "theorem is_open_basic_open {a : A} : IsOpen (basic_open ğ’œ a : Set (projective_spectrum ğ’œ)) :=\n  (basic_open ğ’œ a).is_open\n#align is_open_basic_open is_open_basic_open\n\n",
 "is_closed_zero_locus":
 "theorem is_closed_zero_locus (s : Set A) : IsClosed (zero_locus ğ’œ s) :=\n  by\n  rw [is_closed_iff_zero_locus]\n  exact âŸ¨s, rflâŸ©\n#align is_closed_zero_locus is_closed_zero_locus\n\n",
 "is_closed_iff_zero_locus":
 "theorem is_closed_iff_zero_locus (Z : Set (projective_spectrum ğ’œ)) : IsClosed Z â†” âˆƒ s, Z = zero_locus ğ’œ s := by\n  rw [â† isOpen_compl_iff, is_open_iff, compl_compl]\n#align is_closed_iff_zero_locus is_closed_iff_zero_locus\n\n",
 "ideal_le_vanishing_ideal_zero_locus":
 "theorem ideal_le_vanishing_ideal_zero_locus (I : Ideal A) : I â‰¤ (vanishing_ideal (zero_locus ğ’œ I)).to_ideal :=\n  (gc_ideal _).le_u_l I\n#align ideal_le_vanishing_ideal_zero_locus ideal_le_vanishing_ideal_zero_locus\n\n",
 "homogeneous_ideal_le_vanishing_ideal_zero_locus":
 "theorem homogeneous_ideal_le_vanishing_ideal_zero_locus (I : homogeneous_ideal ğ’œ) :\n    I â‰¤ vanishing_ideal (zero_locus ğ’œ I) :=\n  (gc_homogeneous_ideal _).le_u_l I\n#align homogeneous_ideal_le_vanishing_ideal_zero_locus homogeneous_ideal_le_vanishing_ideal_zero_locus\n\n",
 "gc_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\n/-- `zero_locus` and `vanishing_ideal` form a galois connection. -/\ntheorem gc_set :\n    @GaloisConnection (Set A) (Â«expr áµ’áµˆÂ» (Set (projective_spectrum ğ’œ))) _ _ (fun s => zero_locus ğ’œ s) fun t =>\n      vanishing_ideal t :=\n  by\n  have ideal_gc : GaloisConnection Ideal.span coe := (Submodule.gi A _).gc\n  simpa [zero_locus_span, Function.comp] using GaloisConnection.compose ideal_gc (gc_ideal ğ’œ)\n#align gc_set gc_set\n\n",
 "gc_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\n/-- `zero_locus` and `vanishing_ideal` form a galois connection. -/\ntheorem gc_ideal :\n    @GaloisConnection (Ideal A) (Â«expr áµ’áµˆÂ» (Set (projective_spectrum ğ’œ))) _ _ (fun I => zero_locus ğ’œ I) fun t =>\n      (vanishing_ideal t).to_ideal :=\n  fun I t => subset_zero_locus_iff_le_vanishing_ideal t I\n#align gc_ideal gc_ideal\n\n",
 "gc_homogeneous_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\ntheorem gc_homogeneous_ideal :\n    @GaloisConnection (homogeneous_ideal ğ’œ) (Â«expr áµ’áµˆÂ» (Set (projective_spectrum ğ’œ))) _ _ (fun I => zero_locus ğ’œ I)\n      fun t => vanishing_ideal t :=\n  fun I t => by\n  simpa [show I.to_ideal â‰¤ (vanishing_ideal t).to_ideal â†” I â‰¤ vanishing_ideal t from iff.rfl] using\n    subset_zero_locus_iff_le_vanishing_ideal t I.to_ideal\n#align gc_homogeneous_ideal gc_homogeneous_ideal\n\n",
 "coe_vanishing_ideal":
 "theorem coe_vanishing_ideal (t : Set (projective_spectrum ğ’œ)) :\n    (vanishing_ideal t : Set A) = { f | âˆ€ x : projective_spectrum ğ’œ, x âˆˆ t â†’ f âˆˆ x.as_homogeneous_ideal } :=\n  by\n  ext f\n  rw [vanishing_ideal, SetLike.mem_coe, â† homogeneous_ideal.mem_iff, homogeneous_ideal.to_ideal_infi,\n    Submodule.mem_infáµ¢]\n  apply forall_congr' fun x => _\n  rw [homogeneous_ideal.to_ideal_infi, Submodule.mem_infáµ¢, homogeneous_ideal.mem_iff]\n#align coe_vanishing_ideal coe_vanishing_ideal\n\n",
 "basic_open_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n@[simp]\ntheorem basic_open_zero : basic_open ğ’œ (0 : A) = Â«exprâŠ¥Â» :=\n  TopologicalSpace.Opens.ext <| by simp\n#align basic_open_zero basic_open_zero\n\n",
 "basic_open_pow":
 "@[simp]\ntheorem basic_open_pow (f : A) (n : â„•) (hn : 0 < n) : basic_open ğ’œ (f ^ n) = basic_open ğ’œ f :=\n  TopologicalSpace.Opens.ext <| by simpa using zero_locus_singleton_pow ğ’œ f n hn\n#align basic_open_pow basic_open_pow\n\n",
 "basic_open_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n@[simp]\ntheorem basic_open_one : basic_open ğ’œ (1 : A) = Â«exprâŠ¤Â» :=\n  TopologicalSpace.Opens.ext <| by simp\n#align basic_open_one basic_open_one\n\n",
 "basic_open_mul_le_right":
 "theorem basic_open_mul_le_right (f g : A) : basic_open ğ’œ (f * g) â‰¤ basic_open ğ’œ g :=\n  by\n  rw [basic_open_mul ğ’œ f g]\n  exact inf_le_right\n#align basic_open_mul_le_right basic_open_mul_le_right\n\n",
 "basic_open_mul_le_left":
 "theorem basic_open_mul_le_left (f g : A) : basic_open ğ’œ (f * g) â‰¤ basic_open ğ’œ f :=\n  by\n  rw [basic_open_mul ğ’œ f g]\n  exact inf_le_left\n#align basic_open_mul_le_left basic_open_mul_le_left\n\n",
 "basic_open_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem basic_open_mul (f g : A) : basic_open ğ’œ (f * g) = Â«expr âŠ“ Â» (basic_open ğ’œ f) (basic_open ğ’œ g) :=\n  TopologicalSpace.Opens.ext <| by simp [zero_locus_singleton_mul]\n#align basic_open_mul basic_open_mul\n\n",
 "basic_open_eq_zero_locus_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n@[simp]\ntheorem basic_open_eq_zero_locus_compl (r : A) :\n    (basic_open ğ’œ r : Set (projective_spectrum ğ’œ)) = Â«expr á¶œÂ» (zero_locus ğ’œ {r}) :=\n  Set.ext fun x => by simpa only [Set.mem_compl_iff, mem_zero_locus, Set.singleton_subset_iff]\n#align basic_open_eq_zero_locus_compl basic_open_eq_zero_locus_compl\n\n",
 "basic_open_eq_union_of_projection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\ntheorem basic_open_eq_union_of_projection (f : A) :\n    basic_open ğ’œ f =\n      Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n        (basic_open ğ’œ (graded_algebra.proj ğ’œ i f)) :=\n  TopologicalSpace.Opens.ext <|\n    Set.ext fun z => by\n      erw [mem_coe_basic_open, TopologicalSpace.Opens.mem_supâ‚›]\n      constructor <;> intro hz\n      Â· rcases show âˆƒ i, graded_algebra.proj ğ’œ i f âˆ‰ z.as_homogeneous_ideal\n            by\n            contrapose! hz with H\n            classical\n              rw [â† direct_sum.sum_support_decompose ğ’œ f]\n              apply Ideal.sum_mem _ fun i hi => H i with\n          âŸ¨i, hiâŸ©\n        exact âŸ¨basic_open ğ’œ (graded_algebra.proj ğ’œ i f), âŸ¨i, rflâŸ©, by rwa [mem_basic_open]âŸ©\n      Â· obtain âŸ¨_, âŸ¨i, rflâŸ©, hzâŸ© := hz\n        exact fun rid => hz (z.1.2 i rid)\n#align basic_open_eq_union_of_projection basic_open_eq_union_of_projection\n\n",
 "as_ideal_lt_as_ideal":
 "@[simp]\ntheorem as_ideal_lt_as_ideal (x y : projective_spectrum ğ’œ) : x.as_homogeneous_ideal < y.as_homogeneous_ideal â†” x < y :=\n  iff.rfl\n#align as_ideal_lt_as_ideal as_ideal_lt_as_ideal\n\n",
 "as_ideal_le_as_ideal":
 "@[simp]\ntheorem as_ideal_le_as_ideal (x y : projective_spectrum ğ’œ) : x.as_homogeneous_ideal â‰¤ y.as_homogeneous_ideal â†” x â‰¤ y :=\n  iff.rfl\n#align as_ideal_le_as_ideal as_ideal_le_as_ideal\n\n"}