{"zero_mem":
 "theorem carrier.zero_mem : (0 : A) âˆˆ carrier f_deg q := fun i =>\n  by\n  convert Submodule.zero_mem q.1 using 1\n  rw [ext_iff_val, val_mk', zero_val]; simp_rw [map_zero, zero_pow hm]\n  convert Localization.mk_zero _ using 1\n#align carrier.zero_mem carrier.zero_mem\n\n",
 "smul_mem":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprAâ°_ Â» -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem carrier.smul_mem (c x : A) (hx : x âˆˆ carrier f_deg q) : Â«expr â€¢ Â» c x âˆˆ carrier f_deg q :=\n  by\n  revert c\n  refine' direct_sum.decomposition.induction_on ğ’œ _ _ _\n  Â· rw [zero_smul]\n    exact carrier.zero_mem f_deg hm _\n  Â· rintro n âŸ¨a, haâŸ© i\n    simp_rw [Subtype.coe_mk, proj_apply, smul_eq_mul, coe_decompose_mul_of_left_mem ğ’œ i ha]\n    split_ifs\n    Â· convert_to(Quotient.mk'' âŸ¨_, âŸ¨a ^ m, pow_mem_graded m haâŸ©, âŸ¨_, _âŸ©, âŸ¨n, rflâŸ©âŸ© *\n              Quotient.mk''\n                âŸ¨_,\n                  âŸ¨proj ğ’œ (i - n) x ^ m, by\n                    run_tac\n                      mem_tacâŸ©,\n                  âŸ¨_, _âŸ©, âŸ¨i - n, rflâŸ©âŸ© :\n            Â«exprAâ°_ Â» f) âˆˆ q.1\n      Â· erw [ext_iff_val, val_mk', mul_val, val_mk', val_mk', Subtype.coe_mk]\n        simp_rw [mul_pow, Subtype.coe_mk]\n        rw [Localization.mk_mul]\n        congr\n        erw [â† pow_add, nat.add_sub_of_le h]\n      Â· exact Ideal.mul_mem_left _ _ (hx _)\n        rw [smul_eq_mul, mul_comm]\n        run_tac\n          mem_tac\n    Â· simp_rw [zero_pow hm]\n      convert carrier.zero_mem f_deg hm q i\n      rw [map_zero, zero_pow hm]\n  Â· simp_rw [add_smul]\n    exact fun _ _ => carrier.add_mem f_deg q\n#align carrier.smul_mem carrier.smul_mem\n\n",
 "relevant":
 "theorem carrier.relevant : Â¬homogeneous_ideal.irrelevant ğ’œ â‰¤ carrier.as_homogeneous_ideal f_deg hm q := fun rid =>\n  carrier.denom_not_mem f_deg hm q <| rid <| direct_sum.decompose_of_mem_ne ğ’œ f_deg hm.ne'\n#align carrier.relevant carrier.relevant\n\n",
 "prime":
 "theorem carrier.as_ideal.prime : (carrier.as_ideal f_deg hm q).is_prime :=\n  (carrier.as_ideal.homogeneous f_deg hm q).is_prime_of_homogeneous_mem_or_mem (carrier.as_ideal.ne_top f_deg hm q)\n    fun x y âŸ¨nx, hnxâŸ© âŸ¨ny, hnyâŸ© hxy =>\n    show (âˆ€ i, _ âˆˆ _) âˆ¨ âˆ€ i, _ âˆˆ _\n      by\n      rw [â† and_forall_ne nx, and_iff_left, â† and_forall_ne ny, and_iff_left]\n      Â· apply q.2.mem_or_mem\n        convert hxy (nx + ny) using 1\n        simp_rw [proj_apply, decompose_of_mem_same ğ’œ hnx, decompose_of_mem_same ğ’œ hny,\n          decompose_of_mem_same ğ’œ (mul_mem hnx hny), mul_pow, pow_add]\n        simpa only [ext_iff_val, val_mk', mul_val, mk_mul]\n      all_goals\n        intro n hn; convert q.1.zero_mem using 1\n        rw [ext_iff_val, val_mk', zero_val]; simp_rw [proj_apply, Subtype.coe_mk]\n        convert mk_zero _; rw [decompose_of_mem_ne ğ’œ _ hn.symm, zero_pow hm]\n        Â· first |exact hnx|exact hny\n#align carrier.as_ideal.prime carrier.as_ideal.prime\n\n",
 "preimage_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprAâ°_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprpbo Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprpbo Â» -/\n/-\nThe preimage of basic open set `D(a/f^n)` in `Spec Aâ°_f` under the forward map from `Proj A` to\n`Spec Aâ°_f` is the basic open set `D(a) âˆ© D(f)` in  `Proj A`. This lemma is used to prove that the\nforward map is continuous.\n-/\ntheorem preimage_eq (a b : A) (k : â„•) (a_mem : a âˆˆ ğ’œ k) (b_mem1 : b âˆˆ ğ’œ k) (b_mem2 : b âˆˆ Submonoid.powers f) :\n    Â«expr â»Â¹' Â» (to_fun ğ’œ f)\n        (@prime_spectrum.basic_open (Â«exprAâ°_ Â» f) _ (Quotient.mk'' âŸ¨k, âŸ¨a, a_memâŸ©, âŸ¨b, b_mem1âŸ©, b_mem2âŸ©) :\n          Set (prime_spectrum (homogeneous_localization.away ğ’œ f))) =\n      { x | x.1 âˆˆ Â«expr âŠ“ Â» (Â«exprpbo Â» f) (Â«exprpbo Â» a) } :=\n  by\n  classical\n    ext1 y\n    constructor <;> intro hy\n    Â· refine' âŸ¨y.2, _âŸ©\n      rw [Set.mem_preimage, SetLike.mem_coe, prime_spectrum.mem_basic_open] at hy\n      rw [projective_spectrum.mem_coe_basic_open]\n      intro a_mem_y\n      apply hy\n      rw [to_fun, mem_carrier_iff, homogeneous_localization.val_mk', Subtype.coe_mk]\n      dsimp\n      rcases b_mem2 with âŸ¨k, hkâŸ©\n      simp only [show (mk a âŸ¨b, âŸ¨k, hkâŸ©âŸ© : away f) = mk 1 âŸ¨f ^ k, âŸ¨_, rflâŸ©âŸ© * mk a 1\n          by\n          rw [mk_mul, one_mul, mul_one]\n          congr\n          rw [hk]]\n      exact Ideal.mul_mem_left _ _ (Ideal.subset_span âŸ¨_, a_mem_y, rflâŸ©)\n    Â· change y.1 âˆˆ _ at hy\n      rcases hy with âŸ¨hy1, hy2âŸ©\n      rw [projective_spectrum.mem_coe_basic_open] at hy1 hy2\n      rw [Set.mem_preimage, to_fun, SetLike.mem_coe, prime_spectrum.mem_basic_open]\n      intro rid\n      dsimp at rid\n      rcases mem_carrier.clear_denominator ğ’œ _ rid with âŸ¨c, N, acd, eq1âŸ©\n      rw [Algebra.smul_def] at eq1\n      change\n        Localization.mk (f ^ N) 1 * mk _ _ =\n          mk\n            (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              _)\n            _ at\n        eq1\n      rw [mk_mul, one_mul, mk_eq_mk', IsLocalization.eq] at eq1\n      rcases eq1 with âŸ¨âŸ¨_, âŸ¨M, rflâŸ©âŸ©, eq1âŸ©\n      rw [Submonoid.coe_one, one_mul] at eq1\n      simp only [Subtype.coe_mk] at eq1\n      rcases y.1.is_prime.mem_or_mem (show a * f ^ N * f ^ M âˆˆ _ from _) with (H1 | H3)\n      rcases y.1.is_prime.mem_or_mem H1 with (H1 | H2)\n      Â· exact hy2 H1\n      Â· exact y.2 (y.1.is_prime.mem_of_pow_mem N H2)\n      Â· exact y.2 (y.1.is_prime.mem_of_pow_mem M H3)\n      Â· rw [mul_comm _ (f ^ N), mul_comm _ (f ^ M), eq1]\n        refine' mul_mem_left _ _ (mul_mem_left _ _ (sum_mem _ fun i hi => mul_mem_left _ _ _))\n        generalize_proofs hâ‚ hâ‚‚\n        exact (Classical.choose_spec hâ‚‚).1\n#align preimage_eq preimage_eq\n\n",
 "ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem carrier.as_ideal.ne_top : carrier.as_ideal f_deg hm q â‰  Â«exprâŠ¤Â» := fun rid =>\n  carrier.denom_not_mem f_deg hm q (rid.symm â–¸ Submodule.mem_top)\n#align carrier.as_ideal.ne_top carrier.as_ideal.ne_top\n\n",
 "mem_carrier_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSpec.T Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprAâ°_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem mem_carrier_iff' (q : Â«exprSpec.T Â» (Â«exprAâ°_ Â» f)) (a : A) :\n    a âˆˆ carrier f_deg q â†”\n      âˆ€ i,\n        (Localization.mk (proj ğ’œ i a ^ m) âŸ¨f ^ i, âŸ¨i, rflâŸ©âŸ© : Localization.Away f) âˆˆ\n          Â«expr '' Â» (algebraMap (homogeneous_localization.away ğ’œ f) (Localization.Away f)) q.1.1 :=\n  (mem_carrier_iff f_deg q a).trans\n    (by\n      constructor <;> intro h i <;> specialize h i\n      Â· rw [Set.mem_image]\n        refine' âŸ¨_, h, rflâŸ©\n      Â· rw [Set.mem_image] at h\n        rcases h with âŸ¨x, h, hxâŸ©\n        convert h\n        rw [ext_iff_val, val_mk']\n        dsimp only [Subtype.coe_mk]\n        rw [â† hx]\n        rfl)\n#align mem_carrier_iff' mem_carrier_iff'\n\n",
 "mem_carrier_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSpec.T Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprAâ°_ Â» -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprAâ°_ Â» -/\ntheorem mem_carrier_iff (q : Â«exprSpec.T Â» (Â«exprAâ°_ Â» f)) (a : A) :\n    a âˆˆ carrier f_deg q â†”\n      âˆ€ i,\n        (Quotient.mk''\n              âŸ¨m * i,\n                âŸ¨proj ğ’œ i a ^ m, by\n                  run_tac\n                    mem_tacâŸ©,\n                âŸ¨f ^ i, by\n                  rw [mul_comm] <;>\n                    run_tac\n                      mem_tacâŸ©,\n                âŸ¨_, rflâŸ©âŸ© :\n            Â«exprAâ°_ Â» f) âˆˆ\n          q.1 :=\n  iff.rfl\n#align mem_carrier_iff mem_carrier_iff\n\n",
 "homogeneous":
 "theorem carrier.as_ideal.homogeneous : (carrier.as_ideal f_deg hm q).is_homogeneous ğ’œ := fun i a ha j =>\n  (em (i = j)).elim (fun h => h â–¸ by simpa only [proj_apply, decompose_coe, of_eq_same] using ha _) fun h =>\n    by\n    simp only [proj_apply, decompose_of_mem_ne ğ’œ (Submodule.coe_mem (decompose ğ’œ a i)) h, zero_pow hm]\n    convert carrier.zero_mem f_deg hm q j; rw [map_zero, zero_pow hm]\n#align carrier.as_ideal.homogeneous carrier.as_ideal.homogeneous\n\n",
 "denom_not_mem":
 "theorem carrier.denom_not_mem : f âˆ‰ carrier.as_ideal f_deg hm q := fun rid =>\n  q.is_prime.ne_top <|\n    (Ideal.eq_top_iff_one _).mpr\n      (by\n        convert rid m\n        simpa only [ext_iff_val, one_val, proj_apply, decompose_of_mem_same _ f_deg, val_mk'] using\n          (mk_self (âŸ¨_, m, rflâŸ© : Submonoid.powers f)).symm)\n#align carrier.denom_not_mem carrier.denom_not_mem\n\n",
 "clear_denominator'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚€ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mem_carrier.clear_denominator' [DecidableEq (Away f)] {z : Localization.Away f}\n    (hz : z âˆˆ span (Â«expr '' Â» (algebraMap A (Away f)) x.val.as_homogeneous_ideal)) :\n    âˆƒ (c : Â«expr â†’â‚€ Â» (Â«expr '' Â» (algebraMap A (Away f)) x.1.as_homogeneous_ideal) (Away f))(N : â„•)(acd :\n      âˆ€ y âˆˆ c.support.image c, A),\n      Â«expr â€¢ Â» (f ^ N) z =\n        algebraMap A (Away f)\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            c.support.attach (acd (c i) (Finset.mem_image.mpr âŸ¨i, âŸ¨i.2, rflâŸ©âŸ©) * i.1.2.some)) :=\n  by\n  rw [â† submodule_span_eq, Finsupp.span_eq_range_total, LinearMap.mem_range] at hz\n  rcases hz with âŸ¨c, eq1âŸ©\n  rw [Finsupp.total_apply, Finsupp.sum] at eq1\n  obtain âŸ¨âŸ¨_, N, rflâŸ©, hNâŸ© := IsLocalization.exist_integer_multiples_of_finset (Submonoid.powers f) (c.support.image c)\n  choose acd hacd using hN\n  refine' âŸ¨c, N, acd, _âŸ©\n  rw [â† eq1, smul_sum, map_sum, â† sum_attach]\n  congr 1\n  ext i\n  rw [_root_.map_mul, hacd, (Classical.choose_spec i.1.2).2, smul_eq_mul, smul_mul_assoc]\n  rfl\n#align mem_carrier.clear_denominator' mem_carrier.clear_denominator'\n\n",
 "clear_denominator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprAâ°_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚€ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mem_carrier.clear_denominator [DecidableEq (Away f)] {z : Â«exprAâ°_ Â» f} (hz : z âˆˆ carrier ğ’œ x) :\n    âˆƒ (c : Â«expr â†’â‚€ Â» (Â«expr '' Â» (algebraMap A (Away f)) x.1.as_homogeneous_ideal) (Away f))(N : â„•)(acd :\n      âˆ€ y âˆˆ c.support.image c, A),\n      Â«expr â€¢ Â» (f ^ N) z.val =\n        algebraMap A (Away f)\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            c.support.attach (acd (c i) (Finset.mem_image.mpr âŸ¨i, âŸ¨i.2, rflâŸ©âŸ©) * i.1.2.some)) :=\n  mem_carrier.clear_denominator' x <| (mem_carrier_iff ğ’œ x z).mpr hz\n#align mem_carrier.clear_denominator mem_carrier.clear_denominator\n\n",
 "carrier_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem carrier_ne_top : carrier ğ’œ x â‰  Â«exprâŠ¤Â» :=\n  by\n  have eq_top := Disjoint x\n  classical\n    contrapose! eq_top\n    obtain âŸ¨c, N, acd, eq1âŸ© := mem_carrier.clear_denominator _ x ((Ideal.eq_top_iff_one _).mp eq_top)\n    rw [Algebra.smul_def, homogeneous_localization.one_val, mul_one] at eq1\n    change\n      Localization.mk (f ^ N) 1 =\n        mk (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" _)\n          1 at\n      eq1\n    simp only [mk_eq_mk', IsLocalization.eq] at eq1\n    rcases eq1 with âŸ¨âŸ¨_, âŸ¨M, rflâŸ©âŸ©, eq1âŸ©\n    erw [one_mul, one_mul] at eq1\n    change f ^ _ * f ^ _ = f ^ _ * _ at eq1\n    rw [Set.not_disjoint_iff_nonempty_inter]\n    refine'\n      âŸ¨f ^ M * f ^ N, eq1.symm â–¸ mul_mem_left _ _ (sum_mem _ fun i hi => mul_mem_left _ _ _), âŸ¨M + N, by rw [pow_add]âŸ©âŸ©\n    generalize_proofs hâ‚ hâ‚‚\n    exact (Classical.choose_spec hâ‚‚).1\n#align carrier_ne_top carrier_ne_top\n\n",
 "add_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprAâ°_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprAâ°_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprSpec.T Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprAâ°_ Â» -/\ntheorem carrier.add_mem (q : Â«exprSpec.T Â» (Â«exprAâ°_ Â» f)) {a b : A} (ha : a âˆˆ carrier f_deg q)\n    (hb : b âˆˆ carrier f_deg q) : a + b âˆˆ carrier f_deg q :=\n  by\n  refine' fun i => (q.2.mem_or_mem _).elim id id\n  change (Quotient.mk'' âŸ¨_, _, _, _âŸ© : Â«exprAâ°_ Â» f) âˆˆ q.1; dsimp only [Subtype.coe_mk]\n  simp_rw [â† pow_add, map_add, add_pow, mul_comm, â† nsmul_eq_mul]\n  let g : â„• â†’ Â«exprAâ°_ Â» f := fun j =>\n    Â«expr â€¢ Â» ((m + m).choose j)\n      (if h2 : m + m < j then 0\n      else\n        if h1 : j â‰¤ m then\n          Quotient.mk''\n              âŸ¨m * i, âŸ¨proj ğ’œ i a ^ j * proj ğ’œ i b ^ (m - j), _âŸ©,\n                âŸ¨_, by\n                  rw [mul_comm] <;>\n                    run_tac\n                      mem_tacâŸ©,\n                âŸ¨i, rflâŸ©âŸ© *\n            Quotient.mk''\n              âŸ¨m * i,\n                âŸ¨proj ğ’œ i b ^ m, by\n                  run_tac\n                    mem_tacâŸ©,\n                âŸ¨_, by\n                  rw [mul_comm] <;>\n                    run_tac\n                      mem_tacâŸ©,\n                âŸ¨i, rflâŸ©âŸ©\n        else\n          Quotient.mk''\n              âŸ¨m * i,\n                âŸ¨proj ğ’œ i a ^ m, by\n                  run_tac\n                    mem_tacâŸ©,\n                âŸ¨_, by\n                  rw [mul_comm] <;>\n                    run_tac\n                      mem_tacâŸ©,\n                âŸ¨i, rflâŸ©âŸ© *\n            Quotient.mk''\n              âŸ¨m * i, âŸ¨proj ğ’œ i a ^ (j - m) * proj ğ’œ i b ^ (m + m - j), _âŸ©,\n                âŸ¨_, by\n                  rw [mul_comm] <;>\n                    run_tac\n                      mem_tacâŸ©,\n                âŸ¨i, rflâŸ©âŸ©)\n  rotate_left\n  Â· rw [(_ : m * i = _)]\n    run_tac\n      mem_tac\n    rw [â† add_smul, nat.add_sub_of_le h1]\n    rfl\n  Â· rw [(_ : m * i = _)]\n    run_tac\n      mem_tac\n    rw [â† add_smul]\n    congr\n    zify [le_of_not_lt h2, le_of_not_le h1]\n    abel\n  convert_to finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (range (m + m + 1)) (g i) âˆˆ\n      q.1;\n  swap\n  Â· refine' q.1.sum_mem fun j hj => nsmul_mem _ _\n    split_ifs\n    exacts[q.1.zero_mem, q.1.mul_mem_left _ (hb i), q.1.mul_mem_right _ (ha i)]\n  rw [ext_iff_val, val_mk']\n  change _ = (algebraMap (homogeneous_localization.away ğ’œ f) (Localization.Away f)) _\n  dsimp only [Subtype.coe_mk]; rw [map_sum, mk_sum]\n  apply Finset.sum_congr rfl fun j hj => _\n  change _ = homogeneous_localization.val _\n  rw [homogeneous_localization.smul_val]\n  split_ifs with h2 h1\n  Â· exact ((Finset.mem_range.1 hj).not_le h2).elim\n  all_goals simp only [mul_val, zero_val, val_mk', Subtype.coe_mk, mk_mul, â† smul_mk]; congr 2\n  Â· rw [mul_assoc, â† pow_add, add_comm (m - j), nat.add_sub_assoc h1];\n  Â· simp_rw [pow_add]\n    rfl\n  Â· rw [â† mul_assoc, â† pow_add, nat.add_sub_of_le (le_of_not_le h1)];\n  Â· simp_rw [pow_add]\n    rfl\n#align carrier.add_mem carrier.add_mem\n\n",
 "Disjoint":
 "#print Disjoint /-\ntheorem Disjoint : Disjoint (x.1.as_homogeneous_ideal.to_ideal : Set A) (Submonoid.powers f : Set A) :=\n  by\n  by_contra rid\n  rw [Set.not_disjoint_iff] at rid\n  choose g hg using rid\n  obtain âŸ¨hg1, âŸ¨k, rflâŸ©âŸ© := hg\n  by_cases k_ineq : 0 < k\n  Â· erw [x.1.is_prime.pow_mem_iff_mem _ k_ineq] at hg1\n    exact x.2 hg1\n  Â· erw [show k = 0 by linarith, pow_zero, â† Ideal.eq_top_iff_one] at hg1\n    apply x.1.is_prime.1\n    exact hg1\n#align disjoint Disjoint\n-/\n\n"}