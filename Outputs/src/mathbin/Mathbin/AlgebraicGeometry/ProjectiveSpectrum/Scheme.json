{"zero_mem":
 "theorem carrier.zero_mem : (0 : A) ∈ carrier f_deg q := fun i =>\n  by\n  convert Submodule.zero_mem q.1 using 1\n  rw [ext_iff_val, val_mk', zero_val]; simp_rw [map_zero, zero_pow hm]\n  convert Localization.mk_zero _ using 1\n#align carrier.zero_mem carrier.zero_mem\n\n",
 "smul_mem":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprA⁰_ » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem carrier.smul_mem (c x : A) (hx : x ∈ carrier f_deg q) : «expr • » c x ∈ carrier f_deg q :=\n  by\n  revert c\n  refine' direct_sum.decomposition.induction_on 𝒜 _ _ _\n  · rw [zero_smul]\n    exact carrier.zero_mem f_deg hm _\n  · rintro n ⟨a, ha⟩ i\n    simp_rw [Subtype.coe_mk, proj_apply, smul_eq_mul, coe_decompose_mul_of_left_mem 𝒜 i ha]\n    split_ifs\n    · convert_to(Quotient.mk'' ⟨_, ⟨a ^ m, pow_mem_graded m ha⟩, ⟨_, _⟩, ⟨n, rfl⟩⟩ *\n              Quotient.mk''\n                ⟨_,\n                  ⟨proj 𝒜 (i - n) x ^ m, by\n                    run_tac\n                      mem_tac⟩,\n                  ⟨_, _⟩, ⟨i - n, rfl⟩⟩ :\n            «exprA⁰_ » f) ∈ q.1\n      · erw [ext_iff_val, val_mk', mul_val, val_mk', val_mk', Subtype.coe_mk]\n        simp_rw [mul_pow, Subtype.coe_mk]\n        rw [Localization.mk_mul]\n        congr\n        erw [← pow_add, nat.add_sub_of_le h]\n      · exact Ideal.mul_mem_left _ _ (hx _)\n        rw [smul_eq_mul, mul_comm]\n        run_tac\n          mem_tac\n    · simp_rw [zero_pow hm]\n      convert carrier.zero_mem f_deg hm q i\n      rw [map_zero, zero_pow hm]\n  · simp_rw [add_smul]\n    exact fun _ _ => carrier.add_mem f_deg q\n#align carrier.smul_mem carrier.smul_mem\n\n",
 "relevant":
 "theorem carrier.relevant : ¬homogeneous_ideal.irrelevant 𝒜 ≤ carrier.as_homogeneous_ideal f_deg hm q := fun rid =>\n  carrier.denom_not_mem f_deg hm q <| rid <| direct_sum.decompose_of_mem_ne 𝒜 f_deg hm.ne'\n#align carrier.relevant carrier.relevant\n\n",
 "prime":
 "theorem carrier.as_ideal.prime : (carrier.as_ideal f_deg hm q).is_prime :=\n  (carrier.as_ideal.homogeneous f_deg hm q).is_prime_of_homogeneous_mem_or_mem (carrier.as_ideal.ne_top f_deg hm q)\n    fun x y ⟨nx, hnx⟩ ⟨ny, hny⟩ hxy =>\n    show (∀ i, _ ∈ _) ∨ ∀ i, _ ∈ _\n      by\n      rw [← and_forall_ne nx, and_iff_left, ← and_forall_ne ny, and_iff_left]\n      · apply q.2.mem_or_mem\n        convert hxy (nx + ny) using 1\n        simp_rw [proj_apply, decompose_of_mem_same 𝒜 hnx, decompose_of_mem_same 𝒜 hny,\n          decompose_of_mem_same 𝒜 (mul_mem hnx hny), mul_pow, pow_add]\n        simpa only [ext_iff_val, val_mk', mul_val, mk_mul]\n      all_goals\n        intro n hn; convert q.1.zero_mem using 1\n        rw [ext_iff_val, val_mk', zero_val]; simp_rw [proj_apply, Subtype.coe_mk]\n        convert mk_zero _; rw [decompose_of_mem_ne 𝒜 _ hn.symm, zero_pow hm]\n        · first |exact hnx|exact hny\n#align carrier.as_ideal.prime carrier.as_ideal.prime\n\n",
 "preimage_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprA⁰_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprpbo » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprpbo » -/\n/-\nThe preimage of basic open set `D(a/f^n)` in `Spec A⁰_f` under the forward map from `Proj A` to\n`Spec A⁰_f` is the basic open set `D(a) ∩ D(f)` in  `Proj A`. This lemma is used to prove that the\nforward map is continuous.\n-/\ntheorem preimage_eq (a b : A) (k : ℕ) (a_mem : a ∈ 𝒜 k) (b_mem1 : b ∈ 𝒜 k) (b_mem2 : b ∈ Submonoid.powers f) :\n    «expr ⁻¹' » (to_fun 𝒜 f)\n        (@prime_spectrum.basic_open («exprA⁰_ » f) _ (Quotient.mk'' ⟨k, ⟨a, a_mem⟩, ⟨b, b_mem1⟩, b_mem2⟩) :\n          Set (prime_spectrum (homogeneous_localization.away 𝒜 f))) =\n      { x | x.1 ∈ «expr ⊓ » («exprpbo » f) («exprpbo » a) } :=\n  by\n  classical\n    ext1 y\n    constructor <;> intro hy\n    · refine' ⟨y.2, _⟩\n      rw [Set.mem_preimage, SetLike.mem_coe, prime_spectrum.mem_basic_open] at hy\n      rw [projective_spectrum.mem_coe_basic_open]\n      intro a_mem_y\n      apply hy\n      rw [to_fun, mem_carrier_iff, homogeneous_localization.val_mk', Subtype.coe_mk]\n      dsimp\n      rcases b_mem2 with ⟨k, hk⟩\n      simp only [show (mk a ⟨b, ⟨k, hk⟩⟩ : away f) = mk 1 ⟨f ^ k, ⟨_, rfl⟩⟩ * mk a 1\n          by\n          rw [mk_mul, one_mul, mul_one]\n          congr\n          rw [hk]]\n      exact Ideal.mul_mem_left _ _ (Ideal.subset_span ⟨_, a_mem_y, rfl⟩)\n    · change y.1 ∈ _ at hy\n      rcases hy with ⟨hy1, hy2⟩\n      rw [projective_spectrum.mem_coe_basic_open] at hy1 hy2\n      rw [Set.mem_preimage, to_fun, SetLike.mem_coe, prime_spectrum.mem_basic_open]\n      intro rid\n      dsimp at rid\n      rcases mem_carrier.clear_denominator 𝒜 _ rid with ⟨c, N, acd, eq1⟩\n      rw [Algebra.smul_def] at eq1\n      change\n        Localization.mk (f ^ N) 1 * mk _ _ =\n          mk\n            (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              _)\n            _ at\n        eq1\n      rw [mk_mul, one_mul, mk_eq_mk', IsLocalization.eq] at eq1\n      rcases eq1 with ⟨⟨_, ⟨M, rfl⟩⟩, eq1⟩\n      rw [Submonoid.coe_one, one_mul] at eq1\n      simp only [Subtype.coe_mk] at eq1\n      rcases y.1.is_prime.mem_or_mem (show a * f ^ N * f ^ M ∈ _ from _) with (H1 | H3)\n      rcases y.1.is_prime.mem_or_mem H1 with (H1 | H2)\n      · exact hy2 H1\n      · exact y.2 (y.1.is_prime.mem_of_pow_mem N H2)\n      · exact y.2 (y.1.is_prime.mem_of_pow_mem M H3)\n      · rw [mul_comm _ (f ^ N), mul_comm _ (f ^ M), eq1]\n        refine' mul_mem_left _ _ (mul_mem_left _ _ (sum_mem _ fun i hi => mul_mem_left _ _ _))\n        generalize_proofs h₁ h₂\n        exact (Classical.choose_spec h₂).1\n#align preimage_eq preimage_eq\n\n",
 "ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem carrier.as_ideal.ne_top : carrier.as_ideal f_deg hm q ≠ «expr⊤» := fun rid =>\n  carrier.denom_not_mem f_deg hm q (rid.symm ▸ Submodule.mem_top)\n#align carrier.as_ideal.ne_top carrier.as_ideal.ne_top\n\n",
 "mem_carrier_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprSpec.T » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprA⁰_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_carrier_iff' (q : «exprSpec.T » («exprA⁰_ » f)) (a : A) :\n    a ∈ carrier f_deg q ↔\n      ∀ i,\n        (Localization.mk (proj 𝒜 i a ^ m) ⟨f ^ i, ⟨i, rfl⟩⟩ : Localization.Away f) ∈\n          «expr '' » (algebraMap (homogeneous_localization.away 𝒜 f) (Localization.Away f)) q.1.1 :=\n  (mem_carrier_iff f_deg q a).trans\n    (by\n      constructor <;> intro h i <;> specialize h i\n      · rw [Set.mem_image]\n        refine' ⟨_, h, rfl⟩\n      · rw [Set.mem_image] at h\n        rcases h with ⟨x, h, hx⟩\n        convert h\n        rw [ext_iff_val, val_mk']\n        dsimp only [Subtype.coe_mk]\n        rw [← hx]\n        rfl)\n#align mem_carrier_iff' mem_carrier_iff'\n\n",
 "mem_carrier_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprSpec.T » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprA⁰_ » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprA⁰_ » -/\ntheorem mem_carrier_iff (q : «exprSpec.T » («exprA⁰_ » f)) (a : A) :\n    a ∈ carrier f_deg q ↔\n      ∀ i,\n        (Quotient.mk''\n              ⟨m * i,\n                ⟨proj 𝒜 i a ^ m, by\n                  run_tac\n                    mem_tac⟩,\n                ⟨f ^ i, by\n                  rw [mul_comm] <;>\n                    run_tac\n                      mem_tac⟩,\n                ⟨_, rfl⟩⟩ :\n            «exprA⁰_ » f) ∈\n          q.1 :=\n  iff.rfl\n#align mem_carrier_iff mem_carrier_iff\n\n",
 "homogeneous":
 "theorem carrier.as_ideal.homogeneous : (carrier.as_ideal f_deg hm q).is_homogeneous 𝒜 := fun i a ha j =>\n  (em (i = j)).elim (fun h => h ▸ by simpa only [proj_apply, decompose_coe, of_eq_same] using ha _) fun h =>\n    by\n    simp only [proj_apply, decompose_of_mem_ne 𝒜 (Submodule.coe_mem (decompose 𝒜 a i)) h, zero_pow hm]\n    convert carrier.zero_mem f_deg hm q j; rw [map_zero, zero_pow hm]\n#align carrier.as_ideal.homogeneous carrier.as_ideal.homogeneous\n\n",
 "denom_not_mem":
 "theorem carrier.denom_not_mem : f ∉ carrier.as_ideal f_deg hm q := fun rid =>\n  q.is_prime.ne_top <|\n    (Ideal.eq_top_iff_one _).mpr\n      (by\n        convert rid m\n        simpa only [ext_iff_val, one_val, proj_apply, decompose_of_mem_same _ f_deg, val_mk'] using\n          (mk_self (⟨_, m, rfl⟩ : Submonoid.powers f)).symm)\n#align carrier.denom_not_mem carrier.denom_not_mem\n\n",
 "clear_denominator'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mem_carrier.clear_denominator' [DecidableEq (Away f)] {z : Localization.Away f}\n    (hz : z ∈ span («expr '' » (algebraMap A (Away f)) x.val.as_homogeneous_ideal)) :\n    ∃ (c : «expr →₀ » («expr '' » (algebraMap A (Away f)) x.1.as_homogeneous_ideal) (Away f))(N : ℕ)(acd :\n      ∀ y ∈ c.support.image c, A),\n      «expr • » (f ^ N) z =\n        algebraMap A (Away f)\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            c.support.attach (acd (c i) (Finset.mem_image.mpr ⟨i, ⟨i.2, rfl⟩⟩) * i.1.2.some)) :=\n  by\n  rw [← submodule_span_eq, Finsupp.span_eq_range_total, LinearMap.mem_range] at hz\n  rcases hz with ⟨c, eq1⟩\n  rw [Finsupp.total_apply, Finsupp.sum] at eq1\n  obtain ⟨⟨_, N, rfl⟩, hN⟩ := IsLocalization.exist_integer_multiples_of_finset (Submonoid.powers f) (c.support.image c)\n  choose acd hacd using hN\n  refine' ⟨c, N, acd, _⟩\n  rw [← eq1, smul_sum, map_sum, ← sum_attach]\n  congr 1\n  ext i\n  rw [_root_.map_mul, hacd, (Classical.choose_spec i.1.2).2, smul_eq_mul, smul_mul_assoc]\n  rfl\n#align mem_carrier.clear_denominator' mem_carrier.clear_denominator'\n\n",
 "clear_denominator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprA⁰_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mem_carrier.clear_denominator [DecidableEq (Away f)] {z : «exprA⁰_ » f} (hz : z ∈ carrier 𝒜 x) :\n    ∃ (c : «expr →₀ » («expr '' » (algebraMap A (Away f)) x.1.as_homogeneous_ideal) (Away f))(N : ℕ)(acd :\n      ∀ y ∈ c.support.image c, A),\n      «expr • » (f ^ N) z.val =\n        algebraMap A (Away f)\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            c.support.attach (acd (c i) (Finset.mem_image.mpr ⟨i, ⟨i.2, rfl⟩⟩) * i.1.2.some)) :=\n  mem_carrier.clear_denominator' x <| (mem_carrier_iff 𝒜 x z).mpr hz\n#align mem_carrier.clear_denominator mem_carrier.clear_denominator\n\n",
 "carrier_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem carrier_ne_top : carrier 𝒜 x ≠ «expr⊤» :=\n  by\n  have eq_top := Disjoint x\n  classical\n    contrapose! eq_top\n    obtain ⟨c, N, acd, eq1⟩ := mem_carrier.clear_denominator _ x ((Ideal.eq_top_iff_one _).mp eq_top)\n    rw [Algebra.smul_def, homogeneous_localization.one_val, mul_one] at eq1\n    change\n      Localization.mk (f ^ N) 1 =\n        mk (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" _)\n          1 at\n      eq1\n    simp only [mk_eq_mk', IsLocalization.eq] at eq1\n    rcases eq1 with ⟨⟨_, ⟨M, rfl⟩⟩, eq1⟩\n    erw [one_mul, one_mul] at eq1\n    change f ^ _ * f ^ _ = f ^ _ * _ at eq1\n    rw [Set.not_disjoint_iff_nonempty_inter]\n    refine'\n      ⟨f ^ M * f ^ N, eq1.symm ▸ mul_mem_left _ _ (sum_mem _ fun i hi => mul_mem_left _ _ _), ⟨M + N, by rw [pow_add]⟩⟩\n    generalize_proofs h₁ h₂\n    exact (Classical.choose_spec h₂).1\n#align carrier_ne_top carrier_ne_top\n\n",
 "add_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprA⁰_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprA⁰_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.1624094475.mem_tac -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprSpec.T » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprA⁰_ » -/\ntheorem carrier.add_mem (q : «exprSpec.T » («exprA⁰_ » f)) {a b : A} (ha : a ∈ carrier f_deg q)\n    (hb : b ∈ carrier f_deg q) : a + b ∈ carrier f_deg q :=\n  by\n  refine' fun i => (q.2.mem_or_mem _).elim id id\n  change (Quotient.mk'' ⟨_, _, _, _⟩ : «exprA⁰_ » f) ∈ q.1; dsimp only [Subtype.coe_mk]\n  simp_rw [← pow_add, map_add, add_pow, mul_comm, ← nsmul_eq_mul]\n  let g : ℕ → «exprA⁰_ » f := fun j =>\n    «expr • » ((m + m).choose j)\n      (if h2 : m + m < j then 0\n      else\n        if h1 : j ≤ m then\n          Quotient.mk''\n              ⟨m * i, ⟨proj 𝒜 i a ^ j * proj 𝒜 i b ^ (m - j), _⟩,\n                ⟨_, by\n                  rw [mul_comm] <;>\n                    run_tac\n                      mem_tac⟩,\n                ⟨i, rfl⟩⟩ *\n            Quotient.mk''\n              ⟨m * i,\n                ⟨proj 𝒜 i b ^ m, by\n                  run_tac\n                    mem_tac⟩,\n                ⟨_, by\n                  rw [mul_comm] <;>\n                    run_tac\n                      mem_tac⟩,\n                ⟨i, rfl⟩⟩\n        else\n          Quotient.mk''\n              ⟨m * i,\n                ⟨proj 𝒜 i a ^ m, by\n                  run_tac\n                    mem_tac⟩,\n                ⟨_, by\n                  rw [mul_comm] <;>\n                    run_tac\n                      mem_tac⟩,\n                ⟨i, rfl⟩⟩ *\n            Quotient.mk''\n              ⟨m * i, ⟨proj 𝒜 i a ^ (j - m) * proj 𝒜 i b ^ (m + m - j), _⟩,\n                ⟨_, by\n                  rw [mul_comm] <;>\n                    run_tac\n                      mem_tac⟩,\n                ⟨i, rfl⟩⟩)\n  rotate_left\n  · rw [(_ : m * i = _)]\n    run_tac\n      mem_tac\n    rw [← add_smul, nat.add_sub_of_le h1]\n    rfl\n  · rw [(_ : m * i = _)]\n    run_tac\n      mem_tac\n    rw [← add_smul]\n    congr\n    zify [le_of_not_lt h2, le_of_not_le h1]\n    abel\n  convert_to finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (range (m + m + 1)) (g i) ∈\n      q.1;\n  swap\n  · refine' q.1.sum_mem fun j hj => nsmul_mem _ _\n    split_ifs\n    exacts[q.1.zero_mem, q.1.mul_mem_left _ (hb i), q.1.mul_mem_right _ (ha i)]\n  rw [ext_iff_val, val_mk']\n  change _ = (algebraMap (homogeneous_localization.away 𝒜 f) (Localization.Away f)) _\n  dsimp only [Subtype.coe_mk]; rw [map_sum, mk_sum]\n  apply Finset.sum_congr rfl fun j hj => _\n  change _ = homogeneous_localization.val _\n  rw [homogeneous_localization.smul_val]\n  split_ifs with h2 h1\n  · exact ((Finset.mem_range.1 hj).not_le h2).elim\n  all_goals simp only [mul_val, zero_val, val_mk', Subtype.coe_mk, mk_mul, ← smul_mk]; congr 2\n  · rw [mul_assoc, ← pow_add, add_comm (m - j), nat.add_sub_assoc h1];\n  · simp_rw [pow_add]\n    rfl\n  · rw [← mul_assoc, ← pow_add, nat.add_sub_of_le (le_of_not_le h1)];\n  · simp_rw [pow_add]\n    rfl\n#align carrier.add_mem carrier.add_mem\n\n",
 "Disjoint":
 "#print Disjoint /-\ntheorem Disjoint : Disjoint (x.1.as_homogeneous_ideal.to_ideal : Set A) (Submonoid.powers f : Set A) :=\n  by\n  by_contra rid\n  rw [Set.not_disjoint_iff] at rid\n  choose g hg using rid\n  obtain ⟨hg1, ⟨k, rfl⟩⟩ := hg\n  by_cases k_ineq : 0 < k\n  · erw [x.1.is_prime.pow_mem_iff_mem _ k_ineq] at hg1\n    exact x.2 hg1\n  · erw [show k = 0 by linarith, pow_zero, ← Ideal.eq_top_iff_one] at hg1\n    apply x.1.is_prime.1\n    exact hg1\n#align disjoint Disjoint\n-/\n\n"}