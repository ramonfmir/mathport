{"zero_mem'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprat Â» -/\n/-\nCopyright (c) 2022 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang\n-/\ntheorem zero_mem' (U : Â«expr áµ’áµ–Â» (opens (projective_spectrum.Top ğ’œ))) :\n    (is_locally_fraction ğ’œ).pred (0 : âˆ€ x : unop U, Â«exprat Â» x.1) := fun x =>\n  âŸ¨unop U, x.2, (Â«exprğŸ™Â») (unop U), âŸ¨0, âŸ¨0, zero_mem _âŸ©, âŸ¨1, one_memâŸ©, fun y => âŸ¨_, rflâŸ©âŸ©âŸ©\n#align zero_mem' zero_mem'\n\n",
 "stalk_to_fiber_ring_hom_germ'":
 "@[simp]\ntheorem stalk_to_fiber_ring_hom_germ' (U : opens (projective_spectrum.Top ğ’œ)) (x : projective_spectrum.Top ğ’œ)\n    (hx : x âˆˆ U) (s : (Proj.structure_sheaf ğ’œ).1.obj (op U)) :\n    stalk_to_fiber_ring_hom ğ’œ x ((Proj.structure_sheaf ğ’œ).presheaf.germ âŸ¨x, hxâŸ© s) = (s.1 âŸ¨x, hxâŸ© : _) :=\n  RingHom.ext_iff.1 (germ_comp_stalk_to_fiber_ring_hom ğ’œ U âŸ¨x, hxâŸ© : _) s\n#align stalk_to_fiber_ring_hom_germ' stalk_to_fiber_ring_hom_germ'\n\n",
 "stalk_to_fiber_ring_hom_germ":
 "@[simp]\ntheorem stalk_to_fiber_ring_hom_germ (U : opens (projective_spectrum.Top ğ’œ)) (x : U)\n    (s : (Proj.structure_sheaf ğ’œ).1.obj (op U)) :\n    stalk_to_fiber_ring_hom ğ’œ x ((Proj.structure_sheaf ğ’œ).presheaf.germ x s) = s.1 x :=\n  by\n  cases x\n  exact stalk_to_fiber_ring_hom_germ' ğ’œ U _ _ _\n#align stalk_to_fiber_ring_hom_germ stalk_to_fiber_ring_hom_germ\n\n",
 "res_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- We check the sheaf condition under `forget CommRing`.\n@[simp]\ntheorem res_apply (U V : opens (projective_spectrum.Top ğ’œ)) (i : Â«expr âŸ¶ Â» V U)\n    (s : (Proj.structure_sheaf ğ’œ).1.obj (op U)) (x : V) :\n    ((Proj.structure_sheaf ğ’œ).1.map i.op s).1 x = (s.1 (i x) : _) :=\n  rfl\n#align res_apply res_apply\n\n",
 "one_mem'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprat Â» -/\ntheorem one_mem' (U : Â«expr áµ’áµ–Â» (opens (projective_spectrum.Top ğ’œ))) :\n    (is_locally_fraction ğ’œ).pred (1 : âˆ€ x : unop U, Â«exprat Â» x.1) := fun x =>\n  âŸ¨unop U, x.2, (Â«exprğŸ™Â») (unop U), âŸ¨0, âŸ¨1, one_memâŸ©, âŸ¨1, one_memâŸ©, fun y => âŸ¨_, rflâŸ©âŸ©âŸ©\n#align one_mem' one_mem'\n\n",
 "neg_mem'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprat Â» -/\ntheorem neg_mem' (U : Â«expr áµ’áµ–Â» (opens (projective_spectrum.Top ğ’œ))) (a : âˆ€ x : unop U, Â«exprat Â» x.1)\n    (ha : (is_locally_fraction ğ’œ).pred a) : (is_locally_fraction ğ’œ).pred (-a) := fun x =>\n  by\n  rcases ha x with âŸ¨V, m, i, j, âŸ¨r, r_memâŸ©, âŸ¨s, s_memâŸ©, wâŸ©\n  choose nin hy using w\n  refine' âŸ¨V, m, i, j, âŸ¨-r, submodule.neg_mem _ r_memâŸ©, âŸ¨s, s_memâŸ©, fun y => âŸ¨nin y, _âŸ©âŸ©\n  simp only [ext_iff_val, val_mk', â† subtype.val_eq_coe] at hy\n  simp only [pi.neg_apply, ext_iff_val, neg_val, hy, val_mk', â† subtype.val_eq_coe, neg_mk]\n#align neg_mem' neg_mem'\n\n",
 "mul_mem'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprat Â» -/\ntheorem mul_mem' (U : Â«expr áµ’áµ–Â» (opens (projective_spectrum.Top ğ’œ))) (a b : âˆ€ x : unop U, Â«exprat Â» x.1)\n    (ha : (is_locally_fraction ğ’œ).pred a) (hb : (is_locally_fraction ğ’œ).pred b) :\n    (is_locally_fraction ğ’œ).pred (a * b) := fun x =>\n  by\n  rcases ha x with âŸ¨Va, ma, ia, ja, âŸ¨ra, ra_memâŸ©, âŸ¨sa, sa_memâŸ©, waâŸ©\n  rcases hb x with âŸ¨Vb, mb, ib, jb, âŸ¨rb, rb_memâŸ©, âŸ¨sb, sb_memâŸ©, wbâŸ©\n  refine'\n    âŸ¨Â«expr âŠ“ Â» Va Vb, âŸ¨ma, mbâŸ©, Â«expr â‰« Â» (opens.inf_le_left _ _) ia, ja + jb,\n      âŸ¨ra * rb, set_like.mul_mem_graded ra_mem rb_memâŸ©, âŸ¨sa * sb, set_like.mul_mem_graded sa_mem sb_memâŸ©, fun y =>\n      âŸ¨fun h => _, _âŸ©âŸ©\n  Â· cases' (y : projective_spectrum.Top ğ’œ).is_prime.mem_or_mem h with h h\n    Â· choose nin hy using wa âŸ¨y, (opens.inf_le_left Va Vb y).2âŸ©\n      exact nin h\n    Â· choose nin hy using wb âŸ¨y, (opens.inf_le_right Va Vb y).2âŸ©\n      exact nin h\n  Â· simp only [pi.mul_apply, RingHom.map_mul]\n    choose nin1 hy1 using wa (opens.inf_le_left Va Vb y)\n    choose nin2 hy2 using wb (opens.inf_le_right Va Vb y)\n    rw [ext_iff_val] at hy1 hy2âŠ¢\n    erw [mul_val, hy1, hy2]\n    simpa only [val_mk', mk_mul, â† subtype.val_eq_coe]\n#align mul_mem' mul_mem'\n\n",
 "mem_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprat Â» -/\ntheorem homogeneous_localization.mem_basic_open (x : projective_spectrum.Top ğ’œ) (f : Â«exprat Â» x) :\n    x âˆˆ projective_spectrum.basic_open ğ’œ f.denom :=\n  by\n  rw [projective_spectrum.mem_basic_open]\n  exact f.denom_mem\n#align homogeneous_localization.mem_basic_open homogeneous_localization.mem_basic_open\n\n",
 "germ_comp_stalk_to_fiber_ring_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem germ_comp_stalk_to_fiber_ring_hom (U : opens (projective_spectrum.Top ğ’œ)) (x : U) :\n    Â«expr â‰« Â» ((Proj.structure_sheaf ğ’œ).presheaf.germ x) (stalk_to_fiber_ring_hom ğ’œ x) =\n      open_to_localization ğ’œ U x x.2 :=\n  limits.colimit.Î¹_desc _ _\n#align germ_comp_stalk_to_fiber_ring_hom germ_comp_stalk_to_fiber_ring_hom\n\n",
 "add_mem'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprat Â» -/\ntheorem add_mem' (U : Â«expr áµ’áµ–Â» (opens (projective_spectrum.Top ğ’œ))) (a b : âˆ€ x : unop U, Â«exprat Â» x.1)\n    (ha : (is_locally_fraction ğ’œ).pred a) (hb : (is_locally_fraction ğ’œ).pred b) :\n    (is_locally_fraction ğ’œ).pred (a + b) := fun x =>\n  by\n  rcases ha x with âŸ¨Va, ma, ia, ja, âŸ¨ra, ra_memâŸ©, âŸ¨sa, sa_memâŸ©, waâŸ©\n  rcases hb x with âŸ¨Vb, mb, ib, jb, âŸ¨rb, rb_memâŸ©, âŸ¨sb, sb_memâŸ©, wbâŸ©\n  refine'\n    âŸ¨Â«expr âŠ“ Â» Va Vb, âŸ¨ma, mbâŸ©, Â«expr â‰« Â» (opens.inf_le_left _ _) ia, ja + jb,\n      âŸ¨sb * ra + sa * rb,\n        add_mem (add_comm jb ja â–¸ mul_mem sb_mem ra_mem : sb * ra âˆˆ ğ’œ (ja + jb)) (mul_mem sa_mem rb_mem)âŸ©,\n      âŸ¨sa * sb, mul_mem sa_mem sb_memâŸ©, fun y => âŸ¨fun h => _, _âŸ©âŸ©\n  Â· cases' (y : projective_spectrum.Top ğ’œ).is_prime.mem_or_mem h with h h\n    Â· obtain âŸ¨nin, -âŸ© := wa âŸ¨y, (opens.inf_le_left Va Vb y).2âŸ©\n      exact nin h\n    Â· obtain âŸ¨nin, -âŸ© := wb âŸ¨y, (opens.inf_le_right Va Vb y).2âŸ©\n      exact nin h\n  Â· simp only [add_mul, map_add, pi.add_apply, RingHom.map_mul, ext_iff_val, add_val]\n    obtain âŸ¨nin1, hy1âŸ© := wa (opens.inf_le_left Va Vb y)\n    obtain âŸ¨nin2, hy2âŸ© := wb (opens.inf_le_right Va Vb y)\n    dsimp only at hy1 hy2\n    erw [hy1, hy2]\n    simpa only [val_mk', add_mk, â† subtype.val_eq_coe, add_comm, mul_comm sa sb]\n#align add_mem' add_mem'\n\n"}