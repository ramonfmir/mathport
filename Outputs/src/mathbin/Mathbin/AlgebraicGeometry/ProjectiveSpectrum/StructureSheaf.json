{"zero_mem'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprat » -/\n/-\nCopyright (c) 2022 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang\n-/\ntheorem zero_mem' (U : «expr ᵒᵖ» (opens (projective_spectrum.Top 𝒜))) :\n    (is_locally_fraction 𝒜).pred (0 : ∀ x : unop U, «exprat » x.1) := fun x =>\n  ⟨unop U, x.2, («expr𝟙») (unop U), ⟨0, ⟨0, zero_mem _⟩, ⟨1, one_mem⟩, fun y => ⟨_, rfl⟩⟩⟩\n#align zero_mem' zero_mem'\n\n",
 "stalk_to_fiber_ring_hom_germ'":
 "@[simp]\ntheorem stalk_to_fiber_ring_hom_germ' (U : opens (projective_spectrum.Top 𝒜)) (x : projective_spectrum.Top 𝒜)\n    (hx : x ∈ U) (s : (Proj.structure_sheaf 𝒜).1.obj (op U)) :\n    stalk_to_fiber_ring_hom 𝒜 x ((Proj.structure_sheaf 𝒜).presheaf.germ ⟨x, hx⟩ s) = (s.1 ⟨x, hx⟩ : _) :=\n  RingHom.ext_iff.1 (germ_comp_stalk_to_fiber_ring_hom 𝒜 U ⟨x, hx⟩ : _) s\n#align stalk_to_fiber_ring_hom_germ' stalk_to_fiber_ring_hom_germ'\n\n",
 "stalk_to_fiber_ring_hom_germ":
 "@[simp]\ntheorem stalk_to_fiber_ring_hom_germ (U : opens (projective_spectrum.Top 𝒜)) (x : U)\n    (s : (Proj.structure_sheaf 𝒜).1.obj (op U)) :\n    stalk_to_fiber_ring_hom 𝒜 x ((Proj.structure_sheaf 𝒜).presheaf.germ x s) = s.1 x :=\n  by\n  cases x\n  exact stalk_to_fiber_ring_hom_germ' 𝒜 U _ _ _\n#align stalk_to_fiber_ring_hom_germ stalk_to_fiber_ring_hom_germ\n\n",
 "res_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- We check the sheaf condition under `forget CommRing`.\n@[simp]\ntheorem res_apply (U V : opens (projective_spectrum.Top 𝒜)) (i : «expr ⟶ » V U)\n    (s : (Proj.structure_sheaf 𝒜).1.obj (op U)) (x : V) :\n    ((Proj.structure_sheaf 𝒜).1.map i.op s).1 x = (s.1 (i x) : _) :=\n  rfl\n#align res_apply res_apply\n\n",
 "one_mem'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprat » -/\ntheorem one_mem' (U : «expr ᵒᵖ» (opens (projective_spectrum.Top 𝒜))) :\n    (is_locally_fraction 𝒜).pred (1 : ∀ x : unop U, «exprat » x.1) := fun x =>\n  ⟨unop U, x.2, («expr𝟙») (unop U), ⟨0, ⟨1, one_mem⟩, ⟨1, one_mem⟩, fun y => ⟨_, rfl⟩⟩⟩\n#align one_mem' one_mem'\n\n",
 "neg_mem'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprat » -/\ntheorem neg_mem' (U : «expr ᵒᵖ» (opens (projective_spectrum.Top 𝒜))) (a : ∀ x : unop U, «exprat » x.1)\n    (ha : (is_locally_fraction 𝒜).pred a) : (is_locally_fraction 𝒜).pred (-a) := fun x =>\n  by\n  rcases ha x with ⟨V, m, i, j, ⟨r, r_mem⟩, ⟨s, s_mem⟩, w⟩\n  choose nin hy using w\n  refine' ⟨V, m, i, j, ⟨-r, submodule.neg_mem _ r_mem⟩, ⟨s, s_mem⟩, fun y => ⟨nin y, _⟩⟩\n  simp only [ext_iff_val, val_mk', ← subtype.val_eq_coe] at hy\n  simp only [pi.neg_apply, ext_iff_val, neg_val, hy, val_mk', ← subtype.val_eq_coe, neg_mk]\n#align neg_mem' neg_mem'\n\n",
 "mul_mem'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprat » -/\ntheorem mul_mem' (U : «expr ᵒᵖ» (opens (projective_spectrum.Top 𝒜))) (a b : ∀ x : unop U, «exprat » x.1)\n    (ha : (is_locally_fraction 𝒜).pred a) (hb : (is_locally_fraction 𝒜).pred b) :\n    (is_locally_fraction 𝒜).pred (a * b) := fun x =>\n  by\n  rcases ha x with ⟨Va, ma, ia, ja, ⟨ra, ra_mem⟩, ⟨sa, sa_mem⟩, wa⟩\n  rcases hb x with ⟨Vb, mb, ib, jb, ⟨rb, rb_mem⟩, ⟨sb, sb_mem⟩, wb⟩\n  refine'\n    ⟨«expr ⊓ » Va Vb, ⟨ma, mb⟩, «expr ≫ » (opens.inf_le_left _ _) ia, ja + jb,\n      ⟨ra * rb, set_like.mul_mem_graded ra_mem rb_mem⟩, ⟨sa * sb, set_like.mul_mem_graded sa_mem sb_mem⟩, fun y =>\n      ⟨fun h => _, _⟩⟩\n  · cases' (y : projective_spectrum.Top 𝒜).is_prime.mem_or_mem h with h h\n    · choose nin hy using wa ⟨y, (opens.inf_le_left Va Vb y).2⟩\n      exact nin h\n    · choose nin hy using wb ⟨y, (opens.inf_le_right Va Vb y).2⟩\n      exact nin h\n  · simp only [pi.mul_apply, RingHom.map_mul]\n    choose nin1 hy1 using wa (opens.inf_le_left Va Vb y)\n    choose nin2 hy2 using wb (opens.inf_le_right Va Vb y)\n    rw [ext_iff_val] at hy1 hy2⊢\n    erw [mul_val, hy1, hy2]\n    simpa only [val_mk', mk_mul, ← subtype.val_eq_coe]\n#align mul_mem' mul_mem'\n\n",
 "mem_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprat » -/\ntheorem homogeneous_localization.mem_basic_open (x : projective_spectrum.Top 𝒜) (f : «exprat » x) :\n    x ∈ projective_spectrum.basic_open 𝒜 f.denom :=\n  by\n  rw [projective_spectrum.mem_basic_open]\n  exact f.denom_mem\n#align homogeneous_localization.mem_basic_open homogeneous_localization.mem_basic_open\n\n",
 "germ_comp_stalk_to_fiber_ring_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem germ_comp_stalk_to_fiber_ring_hom (U : opens (projective_spectrum.Top 𝒜)) (x : U) :\n    «expr ≫ » ((Proj.structure_sheaf 𝒜).presheaf.germ x) (stalk_to_fiber_ring_hom 𝒜 x) =\n      open_to_localization 𝒜 U x x.2 :=\n  limits.colimit.ι_desc _ _\n#align germ_comp_stalk_to_fiber_ring_hom germ_comp_stalk_to_fiber_ring_hom\n\n",
 "add_mem'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprat » -/\ntheorem add_mem' (U : «expr ᵒᵖ» (opens (projective_spectrum.Top 𝒜))) (a b : ∀ x : unop U, «exprat » x.1)\n    (ha : (is_locally_fraction 𝒜).pred a) (hb : (is_locally_fraction 𝒜).pred b) :\n    (is_locally_fraction 𝒜).pred (a + b) := fun x =>\n  by\n  rcases ha x with ⟨Va, ma, ia, ja, ⟨ra, ra_mem⟩, ⟨sa, sa_mem⟩, wa⟩\n  rcases hb x with ⟨Vb, mb, ib, jb, ⟨rb, rb_mem⟩, ⟨sb, sb_mem⟩, wb⟩\n  refine'\n    ⟨«expr ⊓ » Va Vb, ⟨ma, mb⟩, «expr ≫ » (opens.inf_le_left _ _) ia, ja + jb,\n      ⟨sb * ra + sa * rb,\n        add_mem (add_comm jb ja ▸ mul_mem sb_mem ra_mem : sb * ra ∈ 𝒜 (ja + jb)) (mul_mem sa_mem rb_mem)⟩,\n      ⟨sa * sb, mul_mem sa_mem sb_mem⟩, fun y => ⟨fun h => _, _⟩⟩\n  · cases' (y : projective_spectrum.Top 𝒜).is_prime.mem_or_mem h with h h\n    · obtain ⟨nin, -⟩ := wa ⟨y, (opens.inf_le_left Va Vb y).2⟩\n      exact nin h\n    · obtain ⟨nin, -⟩ := wb ⟨y, (opens.inf_le_right Va Vb y).2⟩\n      exact nin h\n  · simp only [add_mul, map_add, pi.add_apply, RingHom.map_mul, ext_iff_val, add_val]\n    obtain ⟨nin1, hy1⟩ := wa (opens.inf_le_left Va Vb y)\n    obtain ⟨nin2, hy2⟩ := wb (opens.inf_le_right Va Vb y)\n    dsimp only at hy1 hy2\n    erw [hy1, hy2]\n    simpa only [val_mk', add_mk, ← subtype.val_eq_coe, add_comm, mul_comm sa sb]\n#align add_mem' add_mem'\n\n"}