{"reduce_to_affine_nbhd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem reduce_to_affine_nbhd (P : ∀ (X : Scheme) (x : X.carrier), Prop)\n    (h₁ : ∀ (R : CommRing) (x : prime_spectrum R), P (Scheme.Spec.obj <| op R) x)\n    (h₂ : ∀ {X Y} (f : «expr ⟶ » X Y) [is_open_immersion f] (x : X.carrier), P X x → P Y (f.1.base x)) :\n    ∀ (X : Scheme) (x : X.carrier), P X x := by\n  intro X x\n  obtain ⟨y, e⟩ := X.affine_cover.covers x\n  convert h₂ (X.affine_cover.map (X.affine_cover.f x)) y _\n  · rw [e]\n  apply h₁\n#align reduce_to_affine_nbhd reduce_to_affine_nbhd\n\n",
 "reduce_to_affine_global":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- To show that a statement `P` holds for all open subsets of all schemes, it suffices to show that\n1. In any scheme `X`, if `P` holds for an open cover of `U`, then `P` holds for `U`.\n2. For an open immerison `f : X ⟶ Y`, if `P` holds for the entire space of `X`, then `P` holds for\n  the image of `f`.\n3. `P` holds for the entire space of an affine scheme.\n-/\ntheorem reduce_to_affine_global (P : ∀ (X : Scheme) (U : Opens X.carrier), Prop)\n    (h₁ : ∀ (X : Scheme) (U : Opens X.carrier), (∀ x : U, ∃ (V : _)(h : x.1 ∈ V)(i : «expr ⟶ » V U), P X V) → P X U)\n    (h₂ :\n      ∀ {X Y} (f : «expr ⟶ » X Y) [hf : is_open_immersion f],\n        ∃ (U : Set X.carrier)(V : Set Y.carrier)(hU : U = «expr⊤»)(hV : V = Set.range f.1.base),\n          P X ⟨U, hU.symm ▸ isOpen_univ⟩ → P Y ⟨V, hV.symm ▸ hf.base_open.open_range⟩)\n    (h₃ : ∀ R : CommRing, P (Scheme.Spec.obj <| op R) («expr⊤»)) : ∀ (X : Scheme) (U : Opens X.carrier), P X U :=\n  by\n  intro X U\n  apply h₁\n  intro x\n  obtain ⟨_, ⟨j, rfl⟩, hx, i⟩ :=\n    X.affine_basis_cover_is_basis.exists_subset_of_mem_open (SetLike.mem_coe.2 x.prop) U.is_open\n  let U' : opens _ := ⟨_, (X.affine_basis_cover.is_open j).base_open.open_range⟩\n  let i' : «expr ⟶ » U' U := hom_of_le i\n  refine' ⟨U', hx, i', _⟩\n  obtain ⟨_, _, rfl, rfl, h₂'⟩ := h₂ (X.affine_basis_cover.map j)\n  apply h₂'\n  apply h₃\n#align reduce_to_affine_global reduce_to_affine_global\n\n",
 "map_injective_of_is_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem map_injective_of_is_integral [is_integral X] {U V : Opens X.carrier} (i : «expr ⟶ » U V) [H : Nonempty U] :\n    function.injective (X.presheaf.map i.op) :=\n  by\n  rw [injective_iff_map_eq_zero]\n  intro x hx\n  rw [← basic_open_eq_bot_iff] at hx⊢\n  rw [Scheme.basic_open_res] at hx\n  revert hx\n  contrapose!\n  simp_rw [← opens.not_nonempty_iff_eq_bot, Classical.not_not]\n  apply nonempty_preirreducible_inter U.is_open (RingedSpace.basic_open _ _).is_open\n  simpa using H\n#align map_injective_of_is_integral map_injective_of_is_integral\n\n",
 "is_reduced_of_stalk_is_reduced":
 "/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem is_reduced_of_stalk_is_reduced [∀ x : X.carrier, IsReduced (X.presheaf.stalk x)] : is_reduced X :=\n  by\n  refine' ⟨fun U => ⟨fun s hs => _⟩⟩\n  apply presheaf.section_ext X.sheaf U s 0\n  intro x\n  rw [RingHom.map_zero]\n  change X.presheaf.germ x s = 0\n  exact (hs.map _).eq_zero\n#align is_reduced_of_stalk_is_reduced is_reduced_of_stalk_is_reduced\n\n",
 "is_reduced_of_open_immersion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_reduced_of_open_immersion {X Y : Scheme} (f : «expr ⟶ » X Y) [H : is_open_immersion f] [is_reduced Y] :\n    is_reduced X := by\n  constructor\n  intro U\n  have : U = (opens.map f.1.base).obj (H.base_open.is_open_map.functor.obj U) :=\n    by\n    ext1\n    exact (Set.preimage_image_eq _ H.base_open.inj).symm\n  rw [this]\n  exact\n    isReduced_of_injective (inv <| f.1.c.app (op <| H.base_open.is_open_map.functor.obj U))\n      (as_iso <| f.1.c.app (op <| H.base_open.is_open_map.functor.obj U) :\n              «expr ≅ » (Y.presheaf.obj _) _).symm.CommRing_iso_to_ring_equiv.injective\n#align is_reduced_of_open_immersion is_reduced_of_open_immersion\n\n",
 "is_reduced_of_is_affine_is_reduced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_reduced_of_is_affine_is_reduced [is_affine X] [h : IsReduced (X.presheaf.obj (op («expr⊤»)))] :\n    is_reduced X :=\n  haveI : IsReduced (Scheme.Spec.obj (op (Scheme.Γ.obj (op X)))) :=\n    by\n    rw [affine_is_reduced_iff]\n    exact h\n  is_reduced_of_open_immersion X.iso_Spec.hom\n#align is_reduced_of_is_affine_is_reduced is_reduced_of_is_affine_is_reduced\n\n",
 "is_integral_of_open_immersion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_integral_of_open_immersion {X Y : Scheme} (f : «expr ⟶ » X Y) [H : is_open_immersion f] [is_integral Y]\n    [Nonempty X.carrier] : is_integral X := by\n  constructor\n  intro U hU\n  have : U = (opens.map f.1.base).obj (H.base_open.is_open_map.functor.obj U) :=\n    by\n    ext1\n    exact (Set.preimage_image_eq _ H.base_open.inj).symm\n  rw [this]\n  have : IsDomain (Y.presheaf.obj (op (H.base_open.is_open_map.functor.obj U))) :=\n    by\n    apply (config := { instances := false }) is_integral.component_integral\n    infer_instance\n    refine' ⟨⟨_, _, hU.some.prop, rfl⟩⟩\n  exact\n    (as_iso <| f.1.c.app (op <| H.base_open.is_open_map.functor.obj U) :\n              «expr ≅ » (Y.presheaf.obj _) _).symm.CommRing_iso_to_ring_equiv.is_domain\n      _\n#align is_integral_of_open_immersion is_integral_of_open_immersion\n\n",
 "is_integral_of_is_irreducible_is_reduced":
 "theorem is_integral_of_is_irreducible_is_reduced [is_reduced X] [H : IrreducibleSpace X.carrier] : is_integral X :=\n  by\n  constructor\n  intro U hU\n  haveI := (@LocallyRingedSpace.component_nontrivial X.to_LocallyRingedSpace U hU).1\n  have : NoZeroDivisors (X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (op U)) :=\n    by\n    refine' ⟨fun a b e => _⟩\n    simp_rw [← basic_open_eq_bot_iff, ← opens.not_nonempty_iff_eq_bot]\n    by_contra' h\n    obtain ⟨_, ⟨x, hx₁, rfl⟩, ⟨x, hx₂, e'⟩⟩ :=\n      @nonempty_preirreducible_inter _ H.1 (X.basic_open a).2 (X.basic_open b).2 h.1 h.2\n    replace e' := Subtype.eq e'\n    subst e'\n    replace e := congr_arg (X.presheaf.germ x) e\n    rw [RingHom.map_mul, RingHom.map_zero] at e\n    refine' zero_ne_one' (X.presheaf.stalk x.1) (isUnit_zero_iff.1 _)\n    convert hx₁.mul hx₂\n    exact e.symm\n  exact NoZeroDivisors.to_isDomain _\n#align is_integral_of_is_irreducible_is_reduced is_integral_of_is_irreducible_is_reduced\n\n",
 "is_integral_of_is_affine_is_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_integral_of_is_affine_is_domain [is_affine X] [Nonempty X.carrier]\n    [h : IsDomain (X.presheaf.obj (op («expr⊤»)))] : is_integral X :=\n  haveI : is_integral (Scheme.Spec.obj (op (Scheme.Γ.obj (op X)))) :=\n    by\n    rw [affine_is_integral_iff]\n    exact h\n  is_integral_of_open_immersion X.iso_Spec.hom\n#align is_integral_of_is_affine_is_domain is_integral_of_is_affine_is_domain\n\n",
 "is_integral_iff_is_irreducible_and_is_reduced":
 "theorem is_integral_iff_is_irreducible_and_is_reduced : is_integral X ↔ IrreducibleSpace X.carrier ∧ is_reduced X :=\n  ⟨fun _ => ⟨inferInstance, inferInstance⟩, fun ⟨_, _⟩ => is_integral_of_is_irreducible_is_reduced X⟩\n#align is_integral_iff_is_irreducible_and_is_reduced is_integral_iff_is_irreducible_and_is_reduced\n\n",
 "eq_zero_of_basic_open_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem eq_zero_of_basic_open_eq_bot {X : Scheme} [hX : is_reduced X] {U : Opens X.carrier} (s : X.presheaf.obj (op U))\n    (hs : X.basic_open s = «expr⊥») : s = 0 :=\n  by\n  apply Top.presheaf.section_ext X.sheaf U\n  simp_rw [RingHom.map_zero]\n  revert X U hX s\n  refine' reduce_to_affine_global _ _ _ _\n  · intro X U hx hX s hs x\n    obtain ⟨V, hx, i, H⟩ := hx x\n    specialize H (X.presheaf.map i.op s)\n    erw [Scheme.basic_open_res] at H\n    rw [hs] at H\n    specialize H inf_bot_eq ⟨x, hx⟩\n    erw [Top.presheaf.germ_res_apply] at H\n    exact H\n  · rintro X Y f hf\n    have e : «expr ⁻¹' » f.val.base (Set.range («expr⇑ » f.val.base)) = Set.univ := by\n      rw [← Set.image_univ, Set.preimage_image_eq _ hf.base_open.inj]\n    refine' ⟨_, _, e, rfl, _⟩\n    rintro H hX s hs ⟨_, x, rfl⟩\n    haveI := is_reduced_of_open_immersion f\n    specialize\n      H (f.1.c.app _ s) _\n        ⟨x, by\n          rw [opens.mem_mk, e]\n          trivial⟩\n    · rw [← Scheme.preimage_basic_open, hs]\n      ext1\n      simp [opens.map]\n    · erw [← PresheafedSpace.stalk_map_germ_apply f.1 ⟨_, _⟩ ⟨x, _⟩] at H\n      apply_fun inv <| PresheafedSpace.stalk_map f.val x  at H\n      erw [category_theory.is_iso.hom_inv_id_apply, map_zero] at H\n      exact H\n  · intro R hX s hs x\n    erw [basic_open_eq_of_affine', prime_spectrum.basic_open_eq_bot_iff] at hs\n    replace hs := hs.map (Spec_Γ_identity.app R).inv\n    -- what the hell?!\n    replace hs := @IsNilpotent.eq_zero _ _ _ _ (show _ from _) hs\n    rw [iso.hom_inv_id_apply] at hs\n    rw [hs, map_zero]\n    exact @is_reduced.component_reduced hX («expr⊤»)\n#align eq_zero_of_basic_open_eq_bot eq_zero_of_basic_open_eq_bot\n\n",
 "basic_open_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem basic_open_eq_bot_iff {X : Scheme} [is_reduced X] {U : Opens X.carrier} (s : X.presheaf.obj <| op U) :\n    X.basic_open s = «expr⊥» ↔ s = 0 :=\n  by\n  refine' ⟨eq_zero_of_basic_open_eq_bot s, _⟩\n  rintro rfl\n  simp\n#align basic_open_eq_bot_iff basic_open_eq_bot_iff\n\n",
 "affine_is_reduced_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem affine_is_reduced_iff (R : CommRing) : is_reduced (Scheme.Spec.obj <| op R) ↔ IsReduced R :=\n  by\n  refine' ⟨_, fun h => inferInstance⟩\n  intro h\n  skip\n  have : _root_.is_reduced (LocallyRingedSpace.Γ.obj (op <| Spec.to_LocallyRingedSpace.obj <| op R)) :=\n    by\n    change _root_.is_reduced ((Scheme.Spec.obj <| op R).presheaf.obj <| op («expr⊤»))\n    infer_instance\n  exact isReduced_of_injective (to_Spec_Γ R) (as_iso <| to_Spec_Γ R).CommRing_iso_to_ring_equiv.injective\n#align affine_is_reduced_iff affine_is_reduced_iff\n\n",
 "affine_is_integral_iff":
 "theorem affine_is_integral_iff (R : CommRing) : is_integral (Scheme.Spec.obj <| op R) ↔ IsDomain R :=\n  ⟨fun h =>\n    RingEquiv.isDomain ((Scheme.Spec.obj <| op R).presheaf.obj _) (as_iso <| to_Spec_Γ R).CommRing_iso_to_ring_equiv,\n    fun h => inferInstance⟩\n#align affine_is_integral_iff affine_is_integral_iff\n\n"}