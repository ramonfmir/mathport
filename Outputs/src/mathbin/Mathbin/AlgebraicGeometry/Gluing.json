{"ι_jointly_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\ntheorem ι_jointly_surjective (x : («expr𝖣»).glued.carrier) : ∃ (i : D.J)(y : (D.U i).carrier), (D.ι i).1.base y = x :=\n  («expr𝖣»).ι_jointly_surjective («expr ⋙ » forget_to_Top (forget TopCat)) x\n#align ι_jointly_surjective ι_jointly_surjective\n\n",
 "ι_iso_carrier_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem ι_iso_carrier_inv (i : D.J) :\n    «expr ≫ »\n        (D.to_LocallyRingedSpace_glue_data.to_SheafedSpace_glue_data.to_PresheafedSpace_glue_data.to_Top_glue_data.to_glue_data.ι\n          i)\n        D.iso_carrier.inv =\n      (D.ι i).1.base :=\n  by\n  delta iso_carrier\n  simp only [functor.map_iso_inv, iso.trans_inv, iso.trans_assoc, glue_data.ι_glued_iso_inv_assoc,\n    functor.map_iso_trans, category.assoc]\n  iterate 3 erw [← comp_base]\n  simp_rw [← category.assoc]\n  rw [D.to_LocallyRingedSpace_glue_data.to_SheafedSpace_glue_data.ι_iso_PresheafedSpace_inv i]\n  erw [D.to_LocallyRingedSpace_glue_data.ι_iso_SheafedSpace_inv i]\n  change («expr ≫ » _ D.iso_LocallyRingedSpace.inv).1.base = _\n  rw [D.ι_iso_LocallyRingedSpace_inv i]\n#align ι_iso_carrier_inv ι_iso_carrier_inv\n\n",
 "ι_iso_LocallyRingedSpace_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem ι_iso_LocallyRingedSpace_inv (i : D.J) :\n    «expr ≫ » (D.to_LocallyRingedSpace_glue_data.to_glue_data.ι i) D.iso_LocallyRingedSpace.inv = («expr𝖣»).ι i :=\n  («expr𝖣»).ι_glued_iso_inv forget_to_LocallyRingedSpace i\n#align ι_iso_LocallyRingedSpace_inv ι_iso_LocallyRingedSpace_inv\n\n",
 "ι_glue_morphisms":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem ι_glue_morphisms {Y : Scheme} (f : ∀ x, «expr ⟶ » (𝒰.obj x) Y)\n    (hf :\n      ∀ x y, «expr ≫ » (pullback.fst : «expr ⟶ » (pullback (𝒰.map x) (𝒰.map y)) _) (f x) = «expr ≫ » pullback.snd (f y))\n    (x : 𝒰.J) : «expr ≫ » (𝒰.map x) (𝒰.glue_morphisms f hf) = f x :=\n  by\n  rw [← ι_from_glued, category.assoc]\n  erw [is_iso.hom_inv_id_assoc, multicoequalizer.π_desc]\n#align ι_glue_morphisms ι_glue_morphisms\n\n",
 "ι_from_glued":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- The `cocycle` field could have been `by tidy` but lean timeouts.\n@[simp, reassoc.1]\ntheorem ι_from_glued (x : 𝒰.J) : «expr ≫ » (𝒰.glued_cover.ι x) 𝒰.from_glued = 𝒰.map x :=\n  Multicoequalizer.π_desc _ _ _ _ _\n#align ι_from_glued ι_from_glued\n\n",
 "ι_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\ntheorem ι_eq_iff (i j : D.J) (x : (D.U i).carrier) (y : (D.U j).carrier) :\n    ((«expr𝖣»).ι i).1.base x = ((«expr𝖣»).ι j).1.base y ↔ D.rel ⟨i, x⟩ ⟨j, y⟩ :=\n  by\n  refine'\n    iff.trans _\n      (D.to_LocallyRingedSpace_glue_data.to_SheafedSpace_glue_data.to_PresheafedSpace_glue_data.to_Top_glue_data.ι_eq_iff_rel\n        i j x y)\n  rw [← ((TopCat.mono_iff_injective D.iso_carrier.inv).mp inferInstance).eq_iff]\n  simp_rw [← comp_apply, D.ι_iso_carrier_inv]\n#align ι_eq_iff ι_eq_iff\n\n",
 "is_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_open_iff (U : Set D.glued.carrier) : IsOpen U ↔ ∀ i, IsOpen («expr ⁻¹' » (D.ι i).1.base U) :=\n  by\n  rw [← (TopCat.homeoOfIso D.iso_carrier.symm).is_open_preimage]\n  rw [Top.glue_data.is_open_iff]\n  apply forall_congr'\n  intro i\n  erw [← Set.preimage_comp, ← coe_comp, ι_iso_carrier_inv]\n#align is_open_iff is_open_iff\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem hom_ext {Y : Scheme} (f₁ f₂ : «expr ⟶ » X Y) (h : ∀ x, «expr ≫ » (𝒰.map x) f₁ = «expr ≫ » (𝒰.map x) f₂) :\n    f₁ = f₂ := by\n  rw [← cancel_epi 𝒰.from_glued]\n  apply multicoequalizer.hom_ext\n  intro x\n  erw [multicoequalizer.π_desc_assoc]\n  erw [multicoequalizer.π_desc_assoc]\n  exact h x\n#align hom_ext hom_ext\n\n",
 "glued_cover_t'_snd_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem glued_cover_t'_snd_snd (x y z : 𝒰.J) :\n    «expr ≫ » (glued_cover_t' 𝒰 x y z) («expr ≫ » pullback.snd pullback.snd) = «expr ≫ » pullback.fst pullback.fst :=\n  by\n  delta glued_cover_t'\n  simp\n#align glued_cover_t'_snd_snd glued_cover_t'_snd_snd\n\n",
 "glued_cover_t'_snd_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem glued_cover_t'_snd_fst (x y z : 𝒰.J) :\n    «expr ≫ » (glued_cover_t' 𝒰 x y z) («expr ≫ » pullback.snd pullback.fst) = «expr ≫ » pullback.fst pullback.snd :=\n  by\n  delta glued_cover_t'\n  simp\n#align glued_cover_t'_snd_fst glued_cover_t'_snd_fst\n\n",
 "glued_cover_t'_fst_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem glued_cover_t'_fst_snd (x y z : 𝒰.J) :\n    «expr ≫ » (glued_cover_t' 𝒰 x y z) («expr ≫ » pullback.fst pullback.snd) = «expr ≫ » pullback.snd pullback.snd :=\n  by\n  delta glued_cover_t'\n  simp\n#align glued_cover_t'_fst_snd glued_cover_t'_fst_snd\n\n",
 "glued_cover_t'_fst_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem glued_cover_t'_fst_fst (x y z : 𝒰.J) :\n    «expr ≫ » (𝒰.glued_cover_t' x y z) («expr ≫ » pullback.fst pullback.fst) = «expr ≫ » pullback.fst pullback.snd :=\n  by\n  delta glued_cover_t'\n  simp\n#align glued_cover_t'_fst_fst glued_cover_t'_fst_fst\n\n",
 "glued_cover_cocycle_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem glued_cover_cocycle_snd (x y z : 𝒰.J) :\n    «expr ≫ » (glued_cover_t' 𝒰 x y z)\n        («expr ≫ » (glued_cover_t' 𝒰 y z x) («expr ≫ » (glued_cover_t' 𝒰 z x y) pullback.snd)) =\n      pullback.snd :=\n  by apply pullback.hom_ext <;> simp [pullback.condition]\n#align glued_cover_cocycle_snd glued_cover_cocycle_snd\n\n",
 "glued_cover_cocycle_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem glued_cover_cocycle_fst (x y z : 𝒰.J) :\n    «expr ≫ » (glued_cover_t' 𝒰 x y z)\n        («expr ≫ » (glued_cover_t' 𝒰 y z x) («expr ≫ » (glued_cover_t' 𝒰 z x y) pullback.fst)) =\n      pullback.fst :=\n  by apply pullback.hom_ext <;> simp\n#align glued_cover_cocycle_fst glued_cover_cocycle_fst\n\n",
 "glued_cover_cocycle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem glued_cover_cocycle (x y z : 𝒰.J) :\n    «expr ≫ » (glued_cover_t' 𝒰 x y z) («expr ≫ » (glued_cover_t' 𝒰 y z x) (glued_cover_t' 𝒰 z x y)) = («expr𝟙») _ :=\n  by\n  apply pullback.hom_ext <;> simp_rw [category.id_comp, category.assoc]\n  apply glued_cover_cocycle_fst\n  apply glued_cover_cocycle_snd\n#align glued_cover_cocycle glued_cover_cocycle\n\n",
 "glue_condition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem glue_condition (i j : D.J) : «expr ≫ » (D.t i j) («expr ≫ » (D.f j i) (D.ι j)) = «expr ≫ » (D.f i j) (D.ι i) :=\n  («expr𝖣»).glue_condition i j\n#align glue_condition glue_condition\n\n",
 "from_glued_open_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem from_glued_open_map : IsOpenMap 𝒰.from_glued.1.base :=\n  by\n  intro U hU\n  rw [isOpen_iff_forall_mem_open]\n  intro x hx\n  rw [𝒰.glued_cover.is_open_iff] at hU\n  use «expr '' » 𝒰.from_glued.val.base U ∩ Set.range (𝒰.map (𝒰.f x)).1.base\n  use Set.inter_subset_left _ _\n  constructor\n  · rw [← Set.image_preimage_eq_inter_range]\n    apply show is_open_immersion (𝒰.map (𝒰.f x)) by infer_instance.base_open.is_open_map\n    convert hU (𝒰.f x) using 1\n    rw [← ι_from_glued]\n    erw [coe_comp]\n    rw [Set.preimage_comp]\n    congr 1\n    refine' Set.preimage_image_eq _ 𝒰.from_glued_injective\n  · exact ⟨hx, 𝒰.covers x⟩\n#align from_glued_open_map from_glued_open_map\n\n",
 "from_glued_open_embedding":
 "theorem from_glued_open_embedding : OpenEmbedding 𝒰.from_glued.1.base :=\n  openEmbedding_of_continuous_injective_open (by continuity) 𝒰.from_glued_injective 𝒰.from_glued_open_map\n#align from_glued_open_embedding from_glued_open_embedding\n\n",
 "from_glued_injective":
 "theorem from_glued_injective : function.injective 𝒰.from_glued.1.base :=\n  by\n  intro x y h\n  obtain ⟨i, x, rfl⟩ := 𝒰.glued_cover.ι_jointly_surjective x\n  obtain ⟨j, y, rfl⟩ := 𝒰.glued_cover.ι_jointly_surjective y\n  simp_rw [← comp_apply, ← SheafedSpace.comp_base, ← LocallyRingedSpace.comp_val] at h\n  erw [ι_from_glued, ι_from_glued] at h\n  let e :=\n    (TopCat.pullbackConeIsLimit _ _).cone_point_unique_up_to_iso\n      (is_limit_of_has_pullback_of_preserves_limit Scheme.forget_to_Top (𝒰.map i) (𝒰.map j))\n  rw [𝒰.glued_cover.ι_eq_iff]\n  right\n  use e.hom ⟨⟨x, y⟩, h⟩\n  simp_rw [← comp_apply]\n  constructor\n  · erw [is_limit.cone_point_unique_up_to_iso_hom_comp _ _ walking_cospan.left]\n    rfl\n  · erw [pullback_symmetry_hom_comp_fst, is_limit.cone_point_unique_up_to_iso_hom_comp _ _ walking_cospan.right]\n    rfl\n#align from_glued_injective from_glued_injective\n\n"}