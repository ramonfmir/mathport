{"Î“_map_morphism_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem Î“_map_morphism_restrict {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) (U : opens Y.carrier) :\n    Scheme.Î“.map (Â«expr âˆ£_ Â» f U).op =\n      Â«expr â‰« Â» (Y.presheaf.map (eq_to_hom <| U.open_embedding_obj_top.symm).op)\n        (Â«expr â‰« Â» (f.1.c.app (op U))\n          (X.presheaf.map (eq_to_hom <| ((opens.map f.val.base).obj U).open_embedding_obj_top).op)) :=\n  by\n  rw [Scheme.Î“_map_op, morphism_restrict_c_app f U (Â«exprâŠ¤Â»), f.val.c.naturality_assoc]\n  erw [â† X.presheaf.map_comp]\n  congr\n#align Î“_map_morphism_restrict Î“_map_morphism_restrict\n\n",
 "to_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem to_iso {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) [h : is_open_immersion f] [Epi f.1.base] : IsIso f :=\n  @is_iso_of_reflects_iso _ _ f\n    (Â«expr â‹™ Â» Scheme.forget_to_LocallyRingedSpace\n      (Â«expr â‹™ Â» LocallyRingedSpace.forget_to_SheafedSpace SheafedSpace.forget_to_PresheafedSpace))\n    (@PresheafedSpace.is_open_immersion.to_iso _ f.1 h _) _\n#align to_iso to_iso\n\n",
 "to_SheafedSpace_to_PresheafedSpace":
 "@[simp]\ntheorem to_SheafedSpace_to_PresheafedSpace : (to_SheafedSpace Y f).to_PresheafedSpace = X :=\n  rfl\n#align to_SheafedSpace_to_PresheafedSpace to_SheafedSpace_to_PresheafedSpace\n\n",
 "to_SheafedSpace_hom_c":
 "@[simp]\ntheorem to_SheafedSpace_hom_c : (to_SheafedSpace_hom Y f).c = f.c :=\n  rfl\n#align to_SheafedSpace_hom_c to_SheafedSpace_hom_c\n\n",
 "to_SheafedSpace_hom_base":
 "@[simp]\ntheorem to_SheafedSpace_hom_base : (to_SheafedSpace_hom Y f).base = f.base :=\n  rfl\n#align to_SheafedSpace_hom_base to_SheafedSpace_hom_base\n\n",
 "to_Scheme_to_LocallyRingedSpace":
 "@[simp]\ntheorem to_Scheme_to_LocallyRingedSpace : (to_Scheme Y f).to_LocallyRingedSpace = to_LocallyRingedSpace Y.1 f :=\n  rfl\n#align to_Scheme_to_LocallyRingedSpace to_Scheme_to_LocallyRingedSpace\n\n",
 "to_Scheme_hom_val":
 "@[simp]\ntheorem to_Scheme_hom_val : (to_Scheme_hom Y f).val = f :=\n  rfl\n#align to_Scheme_hom_val to_Scheme_hom_val\n\n",
 "to_LocallyRingedSpace_to_SheafedSpace":
 "@[simp]\ntheorem to_LocallyRingedSpace_to_SheafedSpace : (to_LocallyRingedSpace Y f).to_SheafedSpace = to_SheafedSpace Y.1 f :=\n  rfl\n#align to_LocallyRingedSpace_to_SheafedSpace to_LocallyRingedSpace_to_SheafedSpace\n\n",
 "to_LocallyRingedSpace_hom_val":
 "@[simp]\ntheorem to_LocallyRingedSpace_hom_val : (to_LocallyRingedSpace_hom Y f).val = f :=\n  rfl\n#align to_LocallyRingedSpace_hom_val to_LocallyRingedSpace_hom_val\n\n",
 "supr_opens_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem Scheme.open_cover.supr_opens_range {X : Scheme} (ğ’° : X.open_cover) :\n    Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n        (ğ’°.map i).opens_range =\n      Â«exprâŠ¤Â» :=\n  opens.ext <| by\n    rw [opens.coe_supr]\n    exact ğ’°.Union_range\n#align Scheme.open_cover.supr_opens_range Scheme.open_cover.supr_opens_range\n\n",
 "sigma_Î¹_open_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem sigma_Î¹_open_embedding : open_embedding (colimit.Î¹ F i).base :=\n  by\n  rw [â† show _ = (colimit.Î¹ F i).base from Î¹_preserves_colimits_iso_inv (SheafedSpace.forget C) F i]\n  have : _ = Â«expr â‰« Â» _ (colimit.Î¹ (discrete.functor ((Â«expr â‹™ Â» F (SheafedSpace.forget C)).obj âˆ˜ discrete.mk)) i) :=\n    has_colimit.iso_of_nat_iso_Î¹_hom discrete.nat_iso_functor i\n  rw [â† iso.eq_comp_inv] at this\n  rw [this]\n  have : Â«expr â‰« Â» (colimit.Î¹ _ _) _ = _ :=\n    Top.sigma_iso_sigma_hom_Î¹.{v, v} ((Â«expr â‹™ Â» F (SheafedSpace.forget C)).obj âˆ˜ discrete.mk) i.as\n  rw [â† iso.eq_comp_inv] at this\n  cases i\n  rw [this]\n  simp_rw [â† category.assoc, Top.open_embedding_iff_comp_is_iso, Top.open_embedding_iff_is_iso_comp]\n  dsimp\n  exact open_embedding_sigma_mk\n#align sigma_Î¹_open_embedding sigma_Î¹_open_embedding\n\n",
 "restrict_functor_map_of_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[reassoc.1]\ntheorem Scheme.restrict_functor_map_of_restrict {U V : opens X.carrier} (i : Â«expr âŸ¶ Â» U V) :\n    Â«expr â‰« Â» (X.restrict_functor.map i).1 (X.of_restrict _) = X.of_restrict _ :=\n  is_open_immersion.lift_fac _ _ _\n#align Scheme.restrict_functor_map_of_restrict Scheme.restrict_functor_map_of_restrict\n\n",
 "restrict_functor_map_base":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem Scheme.restrict_functor_map_base {U V : opens X.carrier} (i : Â«expr âŸ¶ Â» U V) :\n    (X.restrict_functor.map i).1.1.base = (opens.to_Top _).map i :=\n  by\n  ext a\n  exact\n    (congr_arg (fun f : Â«expr âŸ¶ Â» (X.restrict U.open_embedding) X => f.1.base a)\n        (X.restrict_functor_map_of_restrict i) :\n      _)\n#align Scheme.restrict_functor_map_base Scheme.restrict_functor_map_base\n\n",
 "restrict_functor_map_app_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem Scheme.restrict_functor_map_app_aux {U V : opens X.carrier} (i : Â«expr âŸ¶ Â» U V) (W : opens V) :\n    U.open_embedding.is_open_map.functor.obj ((opens.map (X.restrict_functor.map i).1.val.base).obj W) â‰¤\n      V.open_embedding.is_open_map.functor.obj W :=\n  by\n  simp only [Set.image_congr, Subtype.mk_le_mk, is_open_map.functor, Set.image_subset_iff,\n    Scheme.restrict_functor_map_base, opens.map, subtype.coe_mk, opens.inclusion_apply, Set.le_eq_subset]\n  rintro _ h\n  exact âŸ¨_, h, rflâŸ©\n#align Scheme.restrict_functor_map_app_aux Scheme.restrict_functor_map_app_aux\n\n",
 "restrict_functor_map_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem Scheme.restrict_functor_map_app {U V : opens X.carrier} (i : Â«expr âŸ¶ Â» U V) (W : opens V) :\n    (X.restrict_functor.map i).1.1.c.app (op W) = X.presheaf.map (hom_of_le <| X.restrict_functor_map_app_aux i W).op :=\n  by\n  have eâ‚ := Scheme.congr_app (X.restrict_functor_map_of_restrict i) (op <| V.open_embedding.is_open_map.functor.obj W)\n  rw [Scheme.comp_val_c_app] at eâ‚\n  have eâ‚‚ := (X.restrict_functor.map i).1.val.c.naturality (eq_to_hom W.map_functor_eq).op\n  rw [â† is_iso.eq_inv_comp] at eâ‚‚\n  dsimp at eâ‚ eâ‚‚âŠ¢\n  rw [eâ‚‚, W.adjunction_counit_map_functor, â† is_iso.eq_inv_comp, is_iso.inv_comp_eq, â† is_iso.eq_comp_inv] at eâ‚\n  simp_rw [eq_to_hom_map (opens.map _), eq_to_hom_map (is_open_map.functor _), â† functor.map_inv, â† functor.map_comp] at\n    eâ‚\n  rw [eâ‚]\n  congr 1\n#align Scheme.restrict_functor_map_app Scheme.restrict_functor_map_app\n\n",
 "range_pullback_to_base_of_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem range_pullback_to_base_of_right :\n    Set.range (Â«expr â‰« Â» pullback.fst g : Â«expr âŸ¶ Â» (pullback g f) Z).1.base =\n      Set.range g.1.base âˆ© Set.range f.1.base :=\n  by\n  rw [Scheme.comp_val_base, coe_comp, Set.range_comp, range_pullback_fst_of_right, opens.map_obj, subtype.coe_mk,\n    Set.image_preimage_eq_inter_range, Set.inter_comm]\n#align range_pullback_to_base_of_right range_pullback_to_base_of_right\n\n",
 "range_pullback_to_base_of_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem range_pullback_to_base_of_left :\n    Set.range (Â«expr â‰« Â» pullback.fst f : Â«expr âŸ¶ Â» (pullback f g) Z).1.base =\n      Set.range f.1.base âˆ© Set.range g.1.base :=\n  by\n  rw [pullback.condition, Scheme.comp_val_base, coe_comp, Set.range_comp, range_pullback_snd_of_left, opens.map_obj,\n    subtype.coe_mk, Set.image_preimage_eq_inter_range, Set.inter_comm]\n#align range_pullback_to_base_of_left range_pullback_to_base_of_left\n\n",
 "range_pullback_snd_of_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem range_pullback_snd_of_left :\n    Set.range (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) Y).1.base =\n      (opens.map g.1.base).obj âŸ¨Set.range f.1.base, H.base_open.open_rangeâŸ© :=\n  by\n  rw [â†\n    show _ = (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _).1.base from\n      preserves_pullback.iso_hom_snd Scheme.forget_to_Top f g,\n    coe_comp, Set.range_comp, set.range_iff_surjective.mpr, â†\n    @Set.preimage_univ _ _ (pullback.fst : Â«expr âŸ¶ Â» (pullback f.1.base g.1.base) _),\n    Top.pullback_snd_image_fst_preimage, Set.image_univ]\n  rfl\n  rw [â† Top.epi_iff_surjective]\n  infer_instance\n#align range_pullback_snd_of_left range_pullback_snd_of_left\n\n",
 "range_pullback_fst_of_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem range_pullback_fst_of_right :\n    Set.range (pullback.fst : Â«expr âŸ¶ Â» (pullback g f) Y).1.base =\n      (opens.map g.1.base).obj âŸ¨Set.range f.1.base, H.base_open.open_rangeâŸ© :=\n  by\n  rw [â†\n    show _ = (pullback.fst : Â«expr âŸ¶ Â» (pullback g f) _).1.base from\n      preserves_pullback.iso_hom_fst Scheme.forget_to_Top g f,\n    coe_comp, Set.range_comp, set.range_iff_surjective.mpr, â†\n    @Set.preimage_univ _ _ (pullback.snd : Â«expr âŸ¶ Â» (pullback g.1.base f.1.base) _),\n    Top.pullback_fst_image_snd_preimage, Set.image_univ]\n  rfl\n  rw [â† Top.epi_iff_surjective]\n  infer_instance\n#align range_pullback_fst_of_right range_pullback_fst_of_right\n\n",
 "pullback_snd_is_iso_of_range_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem pullback_snd_is_iso_of_range_subset (H' : Set.range g.1.base âŠ† Set.range f.1.base) :\n    IsIso (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _) :=\n  by\n  apply (config := { instances := false }) reflects_isomorphisms.reflects LocallyRingedSpace.forget_to_SheafedSpace\n  apply (config := { instances := false }) reflects_isomorphisms.reflects SheafedSpace.forget_to_PresheafedSpace\n  erw [â†\n    preserves_pullback.iso_hom_snd\n      (Â«expr â‹™ Â» LocallyRingedSpace.forget_to_SheafedSpace SheafedSpace.forget_to_PresheafedSpace) f g]\n  haveI := PresheafedSpace.is_open_immersion.pullback_snd_is_iso_of_range_subset _ _ H'\n  infer_instance\n  infer_instance\n#align pullback_snd_is_iso_of_range_subset pullback_snd_is_iso_of_range_subset\n\n",
 "pullback_restrict_iso_restrict_inv_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem pullback_restrict_iso_restrict_inv_fst {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) (U : opens Y.carrier) :\n    Â«expr â‰« Â» (pullback_restrict_iso_restrict f U).inv pullback.fst = X.of_restrict _ :=\n  by\n  delta pullback_restrict_iso_restrict\n  simp\n#align pullback_restrict_iso_restrict_inv_fst pullback_restrict_iso_restrict_inv_fst\n\n",
 "pullback_restrict_iso_restrict_hom_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem pullback_restrict_iso_restrict_hom_restrict {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) (U : opens Y.carrier) :\n    Â«expr â‰« Â» (pullback_restrict_iso_restrict f U).hom (X.of_restrict _) = pullback.fst :=\n  by\n  delta pullback_restrict_iso_restrict\n  simp\n#align pullback_restrict_iso_restrict_hom_restrict pullback_restrict_iso_restrict_hom_restrict\n\n",
 "pullback_restrict_iso_restrict_hom_morphism_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n@[simp, reassoc.1]\ntheorem pullback_restrict_iso_restrict_hom_morphism_restrict {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) (U : opens Y.carrier) :\n    Â«expr â‰« Â» (pullback_restrict_iso_restrict f U).hom (Â«expr âˆ£_ Â» f U) = pullback.snd :=\n  iso.hom_inv_id_assoc _ _\n#align pullback_restrict_iso_restrict_hom_morphism_restrict pullback_restrict_iso_restrict_hom_morphism_restrict\n\n",
 "pullback_cone_of_left_lift_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- this lemma is not a `simp` lemma, because it is an implementation detail\ntheorem pullback_cone_of_left_lift_snd :\n    Â«expr â‰« Â» (pullback_cone_of_left_lift f g s) (pullback_cone_of_left f g).snd = s.snd :=\n  by\n  ext x\n  Â· change Â«expr â‰« Â» (Â«expr â‰« Â» _ (Â«expr â‰« Â» _ _)) _ = _\n    simp_rw [category.assoc]\n    erw [s.snd.c.naturality_assoc]\n    erw [â† s.X.presheaf.map_comp, â† s.X.presheaf.map_comp]\n    trans Â«expr â‰« Â» (s.snd.c.app x) (s.X.presheaf.map ((Â«exprğŸ™Â») _))\n    Â· congr\n    Â· rw [s.X.presheaf.map_id]\n      erw [category.comp_id]\n  Â· change Â«expr â‰« Â» (pullback.lift _ _ _) pullback.snd = _\n    simp\n#align pullback_cone_of_left_lift_snd pullback_cone_of_left_lift_snd\n\n",
 "pullback_cone_of_left_lift_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- this lemma is not a `simp` lemma, because it is an implementation detail\ntheorem pullback_cone_of_left_lift_fst :\n    Â«expr â‰« Â» (pullback_cone_of_left_lift f g s) (pullback_cone_of_left f g).fst = s.fst :=\n  by\n  ext x\n  Â· induction x using opposite.rec\n    change Â«expr â‰« Â» (Â«expr â‰« Â» (Â«expr â‰« Â» _ _) (Â«expr â‰« Â» _ _)) _ = _\n    simp_rw [category.assoc]\n    erw [â† s.X.presheaf.map_comp]\n    erw [s.snd.c.naturality_assoc]\n    have := congr_app s.condition (op (hf.open_functor.obj x))\n    dsimp only [comp_c_app, unop_op] at this\n    rw [â† is_iso.comp_inv_eq] at this\n    reassoc! this\n    erw [â† this, hf.inv_app_app_assoc, s.fst.c.naturality_assoc]\n    simpa [eq_to_hom_map]\n  Â· change Â«expr â‰« Â» (pullback.lift _ _ _) pullback.fst = _\n    simp\n#align pullback_cone_of_left_lift_fst pullback_cone_of_left_lift_fst\n\n",
 "pullback_cone_of_left_condition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem pullback_cone_of_left_condition : Â«expr â‰« Â» (pullback_cone_of_left_fst f g) f = Â«expr â‰« Â» (Y.of_restrict _) g :=\n  by\n  ext U\n  Â· induction U using opposite.rec\n    dsimp only [comp_c_app, nat_trans.comp_app, unop_op, whisker_right_app, pullback_cone_of_left_fst]\n    simp only [quiver.hom.unop_op, Top.presheaf.pushforward_obj_map, app_inv_app_assoc, eq_to_hom_app, eq_to_hom_unop,\n      category.assoc, nat_trans.naturality_assoc, functor.op_map]\n    erw [â† Y.presheaf.map_comp, â† Y.presheaf.map_comp]\n    congr\n  Â· simpa using pullback.condition\n#align pullback_cone_of_left_condition pullback_cone_of_left_condition\n\n",
 "open_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_open_immersion.open_range {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) [H : is_open_immersion f] :\n    is_open (Set.range f.1.base) :=\n  H.base_open.open_range\n#align is_open_immersion.open_range is_open_immersion.open_range\n\n",
 "of_stalk_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem of_stalk_iso {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) (hf : open_embedding f.1.base)\n    [âˆ€ x, IsIso (PresheafedSpace.stalk_map f.1 x)] : is_open_immersion f :=\n  SheafedSpace.is_open_immersion.of_stalk_iso f.1 hf\n#align of_stalk_iso of_stalk_iso\n\n",
 "of_restrict_inv_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[elementwise, simp]\ntheorem of_restrict_inv_app {C : Type _} [Category C] (X : PresheafedSpace C) {Y : Top}\n    {f : Â«expr âŸ¶ Â» Y (Top.of X.carrier)} (h : open_embedding f) (U : opens (X.restrict h).carrier) :\n    (PresheafedSpace.is_open_immersion.of_restrict X h).inv_app U = (Â«exprğŸ™Â») _ :=\n  by\n  delta PresheafedSpace.is_open_immersion.inv_app\n  rw [is_iso.comp_inv_eq, category.id_comp]\n  change X.presheaf.map _ = X.presheaf.map _\n  congr\n#align of_restrict_inv_app of_restrict_inv_app\n\n",
 "morphism_restrict_Î¹":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem morphism_restrict_Î¹ {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) (U : opens Y.carrier) :\n    Â«expr â‰« Â» (Â«expr âˆ£_ Â» f U) (Y.of_restrict U.open_embedding) = Â«expr â‰« Â» (X.of_restrict _) f :=\n  by\n  delta morphism_restrict\n  rw [category.assoc, pullback.condition.symm, pullback_restrict_iso_restrict_inv_fst_assoc]\n#align morphism_restrict_Î¹ morphism_restrict_Î¹\n\n",
 "morphism_restrict_val_base":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\ntheorem morphism_restrict_val_base {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) (U : opens Y.carrier) :\n    Â«exprâ‡‘ Â» (Â«expr âˆ£_ Â» f U).1.base = U.1.restrict_preimage f.1.base :=\n  funext fun x => subtype.ext (morphism_restrict_base_coe f U x)\n#align morphism_restrict_val_base morphism_restrict_val_base\n\n",
 "morphism_restrict_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\ntheorem morphism_restrict_comp {X Y Z : Scheme} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) (U : opens Z.carrier) :\n    Â«expr âˆ£_ Â» (Â«expr â‰« Â» f g) U = (Â«expr â‰« Â» (Â«expr âˆ£_ Â» f ((opens.map g.val.base).obj U)) (Â«expr âˆ£_ Â» g U) : _) :=\n  by\n  delta morphism_restrict\n  rw [â† pullback_right_pullback_fst_iso_inv_snd_snd]\n  simp_rw [â† category.assoc]\n  congr 1\n  rw [â† cancel_mono pullback.fst]\n  simp_rw [category.assoc]\n  rw [pullback_restrict_iso_restrict_inv_fst, pullback_right_pullback_fst_iso_inv_snd_fst, â† pullback.condition,\n    pullback_restrict_iso_restrict_inv_fst_assoc, pullback_restrict_iso_restrict_inv_fst_assoc]\n  rfl\n  infer_instance\n#align morphism_restrict_comp morphism_restrict_comp\n\n",
 "morphism_restrict_c_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem morphism_restrict_c_app {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) (U : opens Y.carrier) (V : opens U) :\n    (Â«expr âˆ£_ Â» f U).1.c.app (op V) =\n      Â«expr â‰« Â» (f.1.c.app (op (U.open_embedding.is_open_map.functor.obj V)))\n        (X.presheaf.map (eq_to_hom (image_morphism_restrict_preimage f U V)).op) :=\n  by\n  have := Scheme.congr_app (morphism_restrict_Î¹ f U) (op (U.open_embedding.is_open_map.functor.obj V))\n  rw [Scheme.comp_val_c_app, Scheme.comp_val_c_app_assoc] at this\n  have e : (opens.map U.inclusion).obj (U.open_embedding.is_open_map.functor.obj V) = V :=\n    by\n    ext1\n    exact Set.preimage_image_eq _ subtype.coe_injective\n  have : Â«expr â‰« Â» _ (X.presheaf.map _) = _ :=\n    (((Â«expr âˆ£_ Â» f U).1.c.naturality (eq_to_hom e).op).symm.trans _).trans this\n  swap\n  Â· change Â«expr â‰« Â» (Y.presheaf.map _) _ = Â«expr â‰« Â» (Y.presheaf.map _) _\n    congr\n  rw [â† is_iso.eq_comp_inv, â† functor.map_inv, category.assoc] at this\n  rw [this]\n  congr 1\n  erw [â† X.presheaf.map_comp, â† X.presheaf.map_comp]\n  congr 1\n#align morphism_restrict_c_app morphism_restrict_c_app\n\n",
 "morphism_restrict_base_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\ntheorem morphism_restrict_base_coe {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) (U : opens Y.carrier) (x) :\n    @coe U Y.carrier _ ((Â«expr âˆ£_ Â» f U).1.base x) = f.1.base x.1 :=\n  congr_arg (fun f => PresheafedSpace.hom.base (LocallyRingedSpace.hom.val f) x) (morphism_restrict_Î¹ f U)\n#align morphism_restrict_base_coe morphism_restrict_base_coe\n\n",
 "lift_uniq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem lift_uniq (H' : Set.range g.1.base âŠ† Set.range f.1.base) (l : Â«expr âŸ¶ Â» Y X) (hl : Â«expr â‰« Â» l f = g) :\n    l = lift f g H' :=\n  LocallyRingedSpace.is_open_immersion.lift_uniq f g H' l hl\n#align lift_uniq lift_uniq\n\n",
 "lift_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem lift_range (H' : Set.range g.1.base âŠ† Set.range f.1.base) :\n    Set.range (lift f g H').1.base = Â«expr â»Â¹' Â» f.1.base (Set.range g.1.base) :=\n  by\n  haveI := pullback_snd_is_iso_of_range_subset f g H'\n  dsimp only [lift]\n  have : _ = (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) _).val.base :=\n    preserves_pullback.iso_hom_fst (Â«expr â‹™ Â» LocallyRingedSpace.forget_to_SheafedSpace (SheafedSpace.forget _)) f g\n  rw [LocallyRingedSpace.comp_val, SheafedSpace.comp_base, â† this, â† category.assoc, coe_comp]\n  rw [Set.range_comp, set.range_iff_surjective.mpr, Set.image_univ, Top.pullback_fst_range]\n  ext\n  constructor\n  Â· rintro âŸ¨y, eqâŸ©\n    exact âŸ¨y, eq.symmâŸ©\n  Â· rintro âŸ¨y, eqâŸ©\n    exact âŸ¨y, eq.symmâŸ©\n  Â· rw [â† Top.epi_iff_surjective]\n    rw [show (inv (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _)).val.base = _ from\n        (Â«expr â‹™ Â» LocallyRingedSpace.forget_to_SheafedSpace (SheafedSpace.forget _)).map_inv _]\n    infer_instance\n#align lift_range lift_range\n\n",
 "lift_fac":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem lift_fac (H' : Set.range g.1.base âŠ† Set.range f.1.base) : Â«expr â‰« Â» (lift f g H') f = g :=\n  LocallyRingedSpace.is_open_immersion.lift_fac f g H'\n#align lift_fac lift_fac\n\n",
 "lift_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem lift_app {X Y U : Scheme} (f : Â«expr âŸ¶ Â» U Y) (g : Â«expr âŸ¶ Â» X Y) [h : is_open_immersion f] (H)\n    (V : opens U.carrier) :\n    (is_open_immersion.lift f g H).1.c.app (op V) =\n      Â«expr â‰« Â» (f.inv_app _)\n        (Â«expr â‰« Â» (g.1.c.app _)\n          (X.presheaf.map\n            (eq_to_hom <|\n                is_open_immersion.app_eq_inv_app_app_of_comp_eq_aux _ _ _ (is_open_immersion.lift_fac f g H).symm\n                  V).op)) :=\n  is_open_immersion.app_eq_inv_app_app_of_comp_eq _ _ _ _ _\n#align lift_app lift_app\n\n",
 "iso_restrict_inv_of_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem iso_restrict_inv_of_restrict : Â«expr â‰« Â» H.iso_restrict.inv f = Y.of_restrict _ := by\n  rw [iso.inv_comp_eq, iso_restrict_hom_of_restrict]\n#align iso_restrict_inv_of_restrict iso_restrict_inv_of_restrict\n\n",
 "iso_restrict_hom_of_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\n@[simp]\ntheorem iso_restrict_hom_of_restrict : Â«expr â‰« Â» H.iso_restrict.hom (Y.of_restrict _) = f :=\n  by\n  ext\n  Â· simp only [comp_c_app, iso_restrict_hom_c_app, nat_trans.comp_app, eq_to_hom_refl, of_restrict_c_app,\n      category.assoc, whisker_right_id']\n    erw [category.comp_id, f.c.naturality_assoc, â† X.presheaf.map_comp]\n    trans Â«expr â‰« Â» (f.c.app x) (X.presheaf.map ((Â«exprğŸ™Â») _))\n    Â· congr\n    Â· erw [X.presheaf.map_id, category.comp_id]\n  Â· rfl\n#align iso_restrict_hom_of_restrict iso_restrict_hom_of_restrict\n\n",
 "is_pullback_morphism_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\ntheorem is_pullback_morphism_restrict {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) (U : opens Y.carrier) :\n    is_pullback (Â«expr âˆ£_ Â» f U) (X.of_restrict _) (Y.of_restrict _) f :=\n  by\n  delta morphism_restrict\n  nth_rw 1 [â† category.id_comp f]\n  refine'\n    (is_pullback.of_horiz_is_iso âŸ¨_âŸ©).paste_horiz (is_pullback.of_has_pullback f (Y.of_restrict U.open_embedding)).flip\n  rw [pullback_restrict_iso_restrict_inv_fst, category.comp_id]\n#align is_pullback_morphism_restrict is_pullback_morphism_restrict\n\n",
 "is_iso_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_iso_of_subset {X Y : PresheafedSpace.{v} C} (f : Â«expr âŸ¶ Â» X Y) [H : PresheafedSpace.is_open_immersion f]\n    (U : opens Y.carrier) (hU : (U : set Y.carrier) âŠ† Set.range f.base) : IsIso (f.c.app <| op U) :=\n  by\n  have : U = H.base_open.is_open_map.functor.obj ((opens.map f.base).obj U) :=\n    by\n    ext1\n    exact (set.inter_eq_left_iff_subset.mpr hU).symm.trans set.image_preimage_eq_inter_range.symm\n  convert PresheafedSpace.is_open_immersion.c_iso ((opens.map f.base).obj U)\n#align is_iso_of_subset is_iso_of_subset\n\n",
 "is_iso_iff_stalk_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem _root_.algebraic_geometry.is_iso_iff_stalk_iso {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) :\n    IsIso f â†” IsIso f.1.base âˆ§ âˆ€ x, IsIso (PresheafedSpace.stalk_map f.1 x) :=\n  by\n  rw [is_iso_iff_is_open_immersion, is_open_immersion.iff_stalk_iso, and_comm', â† and_assoc']\n  refine' and_congr âŸ¨_, _âŸ© iff.rfl\n  Â· rintro âŸ¨hâ‚, hâ‚‚âŸ©\n    convert_to\n      is_iso\n        (Top.iso_of_homeo\n            (homeomorph.homeomorph_of_continuous_open (Equiv.ofBijective _ âŸ¨hâ‚‚.inj, (Top.epi_iff_surjective _).mp hâ‚âŸ©)\n              hâ‚‚.continuous hâ‚‚.is_open_map)).hom\n    Â· ext\n      rfl\n    Â· infer_instance\n  Â· intro H\n    exact âŸ¨infer_instance, (Top.homeo_of_iso (as_iso f.1.base)).open_embeddingâŸ©\n#align algebraic_geometry.is_iso_iff_stalk_iso algebraic_geometry.is_iso_iff_stalk_iso\n\n",
 "is_iso_iff_is_open_immersion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem _root_.algebraic_geometry.is_iso_iff_is_open_immersion {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) :\n    IsIso f â†” is_open_immersion f âˆ§ Epi f.1.base :=\n  âŸ¨fun H => âŸ¨infer_instance, infer_instanceâŸ©, fun âŸ¨hâ‚, hâ‚‚âŸ© => @is_open_immersion.to_iso f hâ‚ hâ‚‚âŸ©\n#align algebraic_geometry.is_iso_iff_is_open_immersion algebraic_geometry.is_iso_iff_is_open_immersion\n\n",
 "inv_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem inv_naturality {U V : Â«expr áµ’áµ–Â» (opens X)} (i : Â«expr âŸ¶ Â» U V) :\n    Â«expr â‰« Â» (X.presheaf.map i) (H.inv_app (unop V)) =\n      Â«expr â‰« Â» (H.inv_app (unop U)) (Y.presheaf.map (H.open_functor.op.map i)) :=\n  by\n  simp only [inv_app, â† category.assoc]\n  rw [is_iso.comp_inv_eq]\n  simp only [category.assoc, f.c.naturality, is_iso.inv_hom_id_assoc, â† X.presheaf.map_comp]\n  erw [â† X.presheaf.map_comp]\n  congr\n#align inv_naturality inv_naturality\n\n",
 "inv_inv_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem inv_inv_app (U : opens X) :\n    inv (H.inv_app U) =\n      Â«expr â‰« Â» (f.c.app (op (H.open_functor.obj U)))\n        (X.presheaf.map (eq_to_hom (by simp [opens.map, Set.preimage_image_eq _ H.base_open.inj]))) :=\n  by\n  rw [â† cancel_epi (H.inv_app U)]\n  rw [is_iso.hom_inv_id]\n  delta inv_app\n  simp [â† functor.map_comp]\n#align inv_inv_app inv_inv_app\n\n",
 "inv_app_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1, elementwise]\ntheorem inv_app_app (U : opens X) :\n    Â«expr â‰« Â» (H.inv_app U) (f.c.app (op (H.open_functor.obj U))) =\n      X.presheaf.map (eq_to_hom (by simp [opens.map, Set.preimage_image_eq _ H.base_open.inj])) :=\n  by rw [inv_app, category.assoc, is_iso.inv_hom_id, category.comp_id]\n#align inv_app_app inv_app_app\n\n",
 "image_preimage_is_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem image_preimage_is_empty (j : discrete Î¹) (h : i â‰  j) (U : opens (F.obj i)) :\n    (opens.map (colimit.Î¹ (Â«expr â‹™ Â» F SheafedSpace.forget_to_PresheafedSpace) j).base).obj\n        ((opens.map (preserves_colimit_iso SheafedSpace.forget_to_PresheafedSpace F).inv.base).obj\n          ((sigma_Î¹_open_embedding F i).is_open_map.functor.obj U)) =\n      âˆ… :=\n  by\n  ext\n  apply iff_false_intro\n  rintro âŸ¨y, hy, eqâŸ©\n  replace eq :=\n    concrete_category.congr_arg\n      (Â«expr â‰ªâ‰« Â» (preserves_colimit_iso (SheafedSpace.forget C) F)\n          (Â«expr â‰ªâ‰« Â» (has_colimit.iso_of_nat_iso discrete.nat_iso_functor) (Top.sigma_iso_sigma.{v} _))).hom\n      eq\n  simp_rw [category_theory.iso.trans_hom, â† Top.comp_app, â† PresheafedSpace.comp_base] at eq\n  rw [Î¹_preserves_colimits_iso_inv] at eq\n  change\n    (Â«expr â‰« Â» ((SheafedSpace.forget C).map (colimit.Î¹ F i)) _) y =\n      (Â«expr â‰« Â» ((SheafedSpace.forget C).map (colimit.Î¹ F j)) _) x at\n    eq\n  cases i; cases j\n  rw [Î¹_preserves_colimits_iso_hom_assoc, Î¹_preserves_colimits_iso_hom_assoc, has_colimit.iso_of_nat_iso_Î¹_hom_assoc,\n    has_colimit.iso_of_nat_iso_Î¹_hom_assoc, Top.sigma_iso_sigma_hom_Î¹.{v}, Top.sigma_iso_sigma_hom_Î¹.{v}] at eq\n  exact h (congr_arg discrete.mk (congr_arg sigma.fst eq))\n#align image_preimage_is_empty image_preimage_is_empty\n\n",
 "image_morphism_restrict_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\ntheorem image_morphism_restrict_preimage {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) (U : opens Y.carrier) (V : opens U) :\n    ((opens.map f.val.base).obj U).open_embedding.is_open_map.functor.obj\n        ((opens.map (Â«expr âˆ£_ Â» f U).val.base).obj V) =\n      (opens.map f.val.base).obj (U.open_embedding.is_open_map.functor.obj V) :=\n  by\n  ext1\n  ext x\n  constructor\n  Â· rintro âŸ¨âŸ¨x, hxâŸ©, hx' : (Â«expr âˆ£_ Â» f U).1.base _ âˆˆ _, rflâŸ©\n    refine' âŸ¨âŸ¨_, hxâŸ©, _, rflâŸ©\n    convert hx'\n    ext1\n    exact (morphism_restrict_base_coe f U âŸ¨x, hxâŸ©).symm\n  Â· rintro âŸ¨âŸ¨x, hxâŸ©, hx', rfl : x = _âŸ©\n    refine' âŸ¨âŸ¨_, hxâŸ©, (_ : (Â«expr âˆ£_ Â» f U).1.base âŸ¨x, hxâŸ© âˆˆ V.1), rflâŸ©\n    convert hx'\n    ext1\n    exact morphism_restrict_base_coe f U âŸ¨x, hxâŸ©\n#align image_morphism_restrict_preimage image_morphism_restrict_preimage\n\n",
 "image_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem image_basic_open {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) [H : is_open_immersion f] {U : opens X.carrier}\n    (r : X.presheaf.obj (op U)) : f.opens_functor.obj (X.basic_open r) = Y.basic_open (f.inv_app U r) :=\n  by\n  have e := Scheme.preimage_basic_open f (f.inv_app U r)\n  rw [Scheme.hom.inv_app, PresheafedSpace.is_open_immersion.inv_app_app_apply, Scheme.basic_open_res,\n    inf_eq_right.mpr _] at e\n  rw [â† e]\n  ext1\n  refine' set.image_preimage_eq_inter_range.trans _\n  erw [Set.inter_eq_left_iff_subset]\n  refine' Set.Subset.trans (Scheme.basic_open_le _ _) (Set.image_subset_range _ _)\n  refine' le_trans (Scheme.basic_open_le _ _) (le_of_eq _)\n  ext1\n  exact (Set.preimage_image_eq _ H.base_open.inj).symm\n#align image_basic_open image_basic_open\n\n",
 "iff_stalk_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem iff_stalk_iso {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) :\n    is_open_immersion f â†” open_embedding f.1.base âˆ§ âˆ€ x, IsIso (PresheafedSpace.stalk_map f.1 x) :=\n  âŸ¨fun H => âŸ¨H.1, infer_instanceâŸ©, fun âŸ¨hâ‚, hâ‚‚âŸ© => @is_open_immersion.of_stalk_iso f hâ‚ hâ‚‚âŸ©\n#align iff_stalk_iso iff_stalk_iso\n\n",
 "compact_space":
 "theorem Scheme.open_cover.compact_space {X : Scheme} (ğ’° : X.open_cover) [Finite ğ’°.J]\n    [H : âˆ€ i, compact_space (ğ’°.obj i).carrier] : compact_space X.carrier :=\n  by\n  cases nonempty_fintype ğ’°.J\n  rw [â† is_compact_univ_iff, â† ğ’°.Union_range]\n  apply is_compact_Union\n  intro i\n  rw [is_compact_iff_compact_space]\n  exact\n    @homeomorph.compact_space _ _ (H i)\n      (Top.homeo_of_iso\n        (as_iso\n          (is_open_immersion.iso_of_range_eq (ğ’°.map i)\n                  (X.of_restrict (opens.open_embedding âŸ¨_, (ğ’°.is_open i).base_open.open_rangeâŸ©))\n                  subtype.range_coe.symm).hom.1.base))\n#align Scheme.open_cover.compact_space Scheme.open_cover.compact_space\n\n",
 "app_inv_app'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- A variant of `app_inv_app` that gives an `eq_to_hom` instead of `hom_of_le`. -/\n@[reassoc.1]\ntheorem app_inv_app' (U : opens Y) (hU : (U : set Y) âŠ† Set.range f.base) :\n    Â«expr â‰« Â» (f.c.app (op U)) (H.inv_app ((opens.map f.base).obj U)) =\n      Y.presheaf.map\n        (eq_to_hom\n            (by\n              apply has_le.le.antisymm\n              Â· exact Set.image_preimage_subset f.base U.1\n              Â· change U âŠ† _\n                refine' has_le.le.trans_eq _ (@Set.image_preimage_eq_inter_range _ _ f.base U.1).symm\n                exact set.subset_inter_iff.mpr âŸ¨fun _ h => h, hUâŸ©)).op :=\n  by\n  erw [â† category.assoc]\n  rw [is_iso.comp_inv_eq, f.c.naturality]\n  congr\n#align app_inv_app' app_inv_app'\n\n",
 "app_inv_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp, reassoc.1]\ntheorem app_inv_app (U : opens Y) :\n    Â«expr â‰« Â» (f.c.app (op U)) (H.inv_app ((opens.map f.base).obj U)) =\n      Y.presheaf.map\n        ((hom_of_le (Set.image_preimage_subset f.base U)).op :\n          Â«expr âŸ¶ Â» (op U) (op (H.open_functor.obj ((opens.map f.base).obj U)))) :=\n  by\n  erw [â† category.assoc]\n  rw [is_iso.comp_inv_eq, f.c.naturality]\n  congr\n#align app_inv_app app_inv_app\n\n",
 "app_eq_inv_app_app_of_comp_eq_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem app_eq_inv_app_app_of_comp_eq_aux {X Y U : Scheme} (f : Â«expr âŸ¶ Â» Y U) (g : Â«expr âŸ¶ Â» U X) (fg : Â«expr âŸ¶ Â» Y X)\n    (H : fg = Â«expr â‰« Â» f g) [h : is_open_immersion g] (V : opens U.carrier) :\n    (opens.map f.1.base).obj V = (opens.map fg.1.base).obj (g.opens_functor.obj V) :=\n  by\n  subst H\n  rw [Scheme.comp_val_base, opens.map_comp_obj]\n  congr 1\n  ext1\n  exact (Set.preimage_image_eq _ h.base_open.inj).symm\n#align app_eq_inv_app_app_of_comp_eq_aux app_eq_inv_app_app_of_comp_eq_aux\n\n",
 "app_eq_inv_app_app_of_comp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- The `fg` argument is to avoid nasty stuff about dependent types. -/\ntheorem app_eq_inv_app_app_of_comp_eq {X Y U : Scheme} (f : Â«expr âŸ¶ Â» Y U) (g : Â«expr âŸ¶ Â» U X) (fg : Â«expr âŸ¶ Â» Y X)\n    (H : fg = Â«expr â‰« Â» f g) [h : is_open_immersion g] (V : opens U.carrier) :\n    f.1.c.app (op V) =\n      Â«expr â‰« Â» (g.inv_app _)\n        (Â«expr â‰« Â» (fg.1.c.app _)\n          (Y.presheaf.map (eq_to_hom <| is_open_immersion.app_eq_inv_app_app_of_comp_eq_aux f g fg H V).op)) :=\n  by\n  subst H\n  rw [Scheme.comp_val_c_app, category.assoc, Scheme.hom.inv_app, PresheafedSpace.is_open_immersion.inv_app_app_assoc,\n    f.val.c.naturality_assoc, Top.presheaf.pushforward_obj_map, â† functor.map_comp]\n  convert (category.comp_id _).symm\n  convert Y.presheaf.map_id _\n#align app_eq_inv_app_app_of_comp_eq app_eq_inv_app_app_of_comp_eq\n\n",
 "affine_basis_cover_obj":
 "-- TODO: provide API to and from a presieve.\n-- Related result : `open_cover.pullback_cover`, where we pullback an open cover on `X` along a\n-- morphism `W âŸ¶ X`. This is provided at the end of the file since it needs some more results\n-- about open immersion (which in turn needs the open cover API).\ntheorem affine_basis_cover_obj (X : Scheme) (i : X.affine_basis_cover.J) :\n    X.affine_basis_cover.obj i = Spec.obj (op <| X.affine_basis_cover_ring i) :=\n  rfl\n#align affine_basis_cover_obj affine_basis_cover_obj\n\n",
 "affine_basis_cover_map_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem affine_basis_cover_map_range (X : Scheme) (x : X.carrier) (r : (X.local_affine x).some_spec.some) :\n    Set.range (X.affine_basis_cover.map âŸ¨x, râŸ©).1.base =\n      Â«expr '' Â» (X.affine_cover.map x).1.base (prime_spectrum.basic_open r).1 :=\n  by\n  erw [coe_comp, Set.range_comp]\n  congr\n  exact (prime_spectrum.localization_away_comap_range (localization.away r) r : _)\n#align affine_basis_cover_map_range affine_basis_cover_map_range\n\n",
 "affine_basis_cover_is_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem affine_basis_cover_is_basis (X : Scheme) :\n    topological_space.is_topological_basis\n      { x : set X.carrier | âˆƒ a : X.affine_basis_cover.J, x = Set.range (X.affine_basis_cover.map a).1.base } :=\n  by\n  apply topological_space.is_topological_basis_of_open_of_nhds\n  Â· rintro _ âŸ¨a, rflâŸ©\n    exact is_open_immersion.open_range (X.affine_basis_cover.map a)\n  Â· rintro a U haU hU\n    rcases X.affine_cover.covers a with âŸ¨x, eâŸ©\n    let U' := Â«expr â»Â¹' Â» (X.affine_cover.map (X.affine_cover.f a)).1.base U\n    have hxU' : x âˆˆ U' := by\n      rw [â† e] at haU\n      exact haU\n    rcases prime_spectrum.is_basis_basic_opens.exists_subset_of_mem_open hxU'\n        ((X.affine_cover.map (X.affine_cover.f a)).1.base.continuous_to_fun.is_open_preimage _ hU) with\n      âŸ¨_, âŸ¨_, âŸ¨s, rflâŸ©, rflâŸ©, hxV, hVUâŸ©\n    refine' âŸ¨_, âŸ¨âŸ¨_, sâŸ©, rflâŸ©, _, _âŸ© <;> erw [affine_basis_cover_map_range]\n    Â· exact âŸ¨x, hxV, eâŸ©\n    Â· rw [Set.image_subset_iff]\n      exact hVU\n#align affine_basis_cover_is_basis affine_basis_cover_is_basis\n\n",
 "Union_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem Scheme.open_cover.Union_range {X : Scheme} (ğ’° : X.open_cover) :\n    Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n        (Set.range (ğ’°.map i).1.base) =\n      Set.univ :=\n  by\n  rw [Set.eq_univ_iff_forall]\n  intro x\n  rw [Set.mem_unionáµ¢]\n  exact âŸ¨ğ’°.f x, ğ’°.covers xâŸ©\n#align Scheme.open_cover.Union_range Scheme.open_cover.Union_range\n\n",
 "SheafedSpace_to_SheafedSpace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expris_open_immersion -/\n@[simp]\ntheorem SheafedSpace_to_SheafedSpace {X Y : SheafedSpace.{v} C} (f : Â«expr âŸ¶ Â» X Y) [(expris_open_immersion) f] :\n    to_SheafedSpace Y f = X := by\n  cases X\n  rfl\n#align SheafedSpace_to_SheafedSpace SheafedSpace_to_SheafedSpace\n\n",
 "Scheme_to_Scheme":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem Scheme_to_Scheme {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) [is_open_immersion f] : to_Scheme Y f.1 = X :=\n  by\n  apply Scheme_eq_of_LocallyRingedSpace_eq\n  exact LocallyRingedSpace_to_LocallyRingedSpace f\n#align Scheme_to_Scheme Scheme_to_Scheme\n\n",
 "Scheme_eq_of_LocallyRingedSpace_eq":
 "theorem Scheme_eq_of_LocallyRingedSpace_eq {X Y : Scheme} (H : X.to_LocallyRingedSpace = Y.to_LocallyRingedSpace) :\n    X = Y := by\n  cases X\n  cases Y\n  congr\n  exact H\n#align Scheme_eq_of_LocallyRingedSpace_eq Scheme_eq_of_LocallyRingedSpace_eq\n\n",
 "LocallyRingedSpace_to_LocallyRingedSpace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem LocallyRingedSpace_to_LocallyRingedSpace {X Y : LocallyRingedSpace} (f : Â«expr âŸ¶ Â» X Y)\n    [LocallyRingedSpace.is_open_immersion f] : to_LocallyRingedSpace Y f.1 = X :=\n  by\n  cases X\n  delta to_LocallyRingedSpace\n  simp\n#align LocallyRingedSpace_to_LocallyRingedSpace LocallyRingedSpace_to_LocallyRingedSpace\n\n"}