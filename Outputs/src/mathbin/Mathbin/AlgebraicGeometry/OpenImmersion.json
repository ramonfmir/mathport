{"Γ_map_morphism_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem Γ_map_morphism_restrict {X Y : Scheme} (f : «expr ⟶ » X Y) (U : opens Y.carrier) :\n    Scheme.Γ.map («expr ∣_ » f U).op =\n      «expr ≫ » (Y.presheaf.map (eq_to_hom <| U.open_embedding_obj_top.symm).op)\n        («expr ≫ » (f.1.c.app (op U))\n          (X.presheaf.map (eq_to_hom <| ((opens.map f.val.base).obj U).open_embedding_obj_top).op)) :=\n  by\n  rw [Scheme.Γ_map_op, morphism_restrict_c_app f U («expr⊤»), f.val.c.naturality_assoc]\n  erw [← X.presheaf.map_comp]\n  congr\n#align Γ_map_morphism_restrict Γ_map_morphism_restrict\n\n",
 "to_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem to_iso {X Y : Scheme} (f : «expr ⟶ » X Y) [h : is_open_immersion f] [Epi f.1.base] : IsIso f :=\n  @is_iso_of_reflects_iso _ _ f\n    («expr ⋙ » Scheme.forget_to_LocallyRingedSpace\n      («expr ⋙ » LocallyRingedSpace.forget_to_SheafedSpace SheafedSpace.forget_to_PresheafedSpace))\n    (@PresheafedSpace.is_open_immersion.to_iso _ f.1 h _) _\n#align to_iso to_iso\n\n",
 "to_SheafedSpace_to_PresheafedSpace":
 "@[simp]\ntheorem to_SheafedSpace_to_PresheafedSpace : (to_SheafedSpace Y f).to_PresheafedSpace = X :=\n  rfl\n#align to_SheafedSpace_to_PresheafedSpace to_SheafedSpace_to_PresheafedSpace\n\n",
 "to_SheafedSpace_hom_c":
 "@[simp]\ntheorem to_SheafedSpace_hom_c : (to_SheafedSpace_hom Y f).c = f.c :=\n  rfl\n#align to_SheafedSpace_hom_c to_SheafedSpace_hom_c\n\n",
 "to_SheafedSpace_hom_base":
 "@[simp]\ntheorem to_SheafedSpace_hom_base : (to_SheafedSpace_hom Y f).base = f.base :=\n  rfl\n#align to_SheafedSpace_hom_base to_SheafedSpace_hom_base\n\n",
 "to_Scheme_to_LocallyRingedSpace":
 "@[simp]\ntheorem to_Scheme_to_LocallyRingedSpace : (to_Scheme Y f).to_LocallyRingedSpace = to_LocallyRingedSpace Y.1 f :=\n  rfl\n#align to_Scheme_to_LocallyRingedSpace to_Scheme_to_LocallyRingedSpace\n\n",
 "to_Scheme_hom_val":
 "@[simp]\ntheorem to_Scheme_hom_val : (to_Scheme_hom Y f).val = f :=\n  rfl\n#align to_Scheme_hom_val to_Scheme_hom_val\n\n",
 "to_LocallyRingedSpace_to_SheafedSpace":
 "@[simp]\ntheorem to_LocallyRingedSpace_to_SheafedSpace : (to_LocallyRingedSpace Y f).to_SheafedSpace = to_SheafedSpace Y.1 f :=\n  rfl\n#align to_LocallyRingedSpace_to_SheafedSpace to_LocallyRingedSpace_to_SheafedSpace\n\n",
 "to_LocallyRingedSpace_hom_val":
 "@[simp]\ntheorem to_LocallyRingedSpace_hom_val : (to_LocallyRingedSpace_hom Y f).val = f :=\n  rfl\n#align to_LocallyRingedSpace_hom_val to_LocallyRingedSpace_hom_val\n\n",
 "supr_opens_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem Scheme.open_cover.supr_opens_range {X : Scheme} (𝒰 : X.open_cover) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (𝒰.map i).opens_range =\n      «expr⊤» :=\n  opens.ext <| by\n    rw [opens.coe_supr]\n    exact 𝒰.Union_range\n#align Scheme.open_cover.supr_opens_range Scheme.open_cover.supr_opens_range\n\n",
 "sigma_ι_open_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem sigma_ι_open_embedding : open_embedding (colimit.ι F i).base :=\n  by\n  rw [← show _ = (colimit.ι F i).base from ι_preserves_colimits_iso_inv (SheafedSpace.forget C) F i]\n  have : _ = «expr ≫ » _ (colimit.ι (discrete.functor ((«expr ⋙ » F (SheafedSpace.forget C)).obj ∘ discrete.mk)) i) :=\n    has_colimit.iso_of_nat_iso_ι_hom discrete.nat_iso_functor i\n  rw [← iso.eq_comp_inv] at this\n  rw [this]\n  have : «expr ≫ » (colimit.ι _ _) _ = _ :=\n    Top.sigma_iso_sigma_hom_ι.{v, v} ((«expr ⋙ » F (SheafedSpace.forget C)).obj ∘ discrete.mk) i.as\n  rw [← iso.eq_comp_inv] at this\n  cases i\n  rw [this]\n  simp_rw [← category.assoc, Top.open_embedding_iff_comp_is_iso, Top.open_embedding_iff_is_iso_comp]\n  dsimp\n  exact open_embedding_sigma_mk\n#align sigma_ι_open_embedding sigma_ι_open_embedding\n\n",
 "restrict_functor_map_of_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem Scheme.restrict_functor_map_of_restrict {U V : opens X.carrier} (i : «expr ⟶ » U V) :\n    «expr ≫ » (X.restrict_functor.map i).1 (X.of_restrict _) = X.of_restrict _ :=\n  is_open_immersion.lift_fac _ _ _\n#align Scheme.restrict_functor_map_of_restrict Scheme.restrict_functor_map_of_restrict\n\n",
 "restrict_functor_map_base":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem Scheme.restrict_functor_map_base {U V : opens X.carrier} (i : «expr ⟶ » U V) :\n    (X.restrict_functor.map i).1.1.base = (opens.to_Top _).map i :=\n  by\n  ext a\n  exact\n    (congr_arg (fun f : «expr ⟶ » (X.restrict U.open_embedding) X => f.1.base a)\n        (X.restrict_functor_map_of_restrict i) :\n      _)\n#align Scheme.restrict_functor_map_base Scheme.restrict_functor_map_base\n\n",
 "restrict_functor_map_app_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem Scheme.restrict_functor_map_app_aux {U V : opens X.carrier} (i : «expr ⟶ » U V) (W : opens V) :\n    U.open_embedding.is_open_map.functor.obj ((opens.map (X.restrict_functor.map i).1.val.base).obj W) ≤\n      V.open_embedding.is_open_map.functor.obj W :=\n  by\n  simp only [Set.image_congr, Subtype.mk_le_mk, is_open_map.functor, Set.image_subset_iff,\n    Scheme.restrict_functor_map_base, opens.map, subtype.coe_mk, opens.inclusion_apply, Set.le_eq_subset]\n  rintro _ h\n  exact ⟨_, h, rfl⟩\n#align Scheme.restrict_functor_map_app_aux Scheme.restrict_functor_map_app_aux\n\n",
 "restrict_functor_map_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem Scheme.restrict_functor_map_app {U V : opens X.carrier} (i : «expr ⟶ » U V) (W : opens V) :\n    (X.restrict_functor.map i).1.1.c.app (op W) = X.presheaf.map (hom_of_le <| X.restrict_functor_map_app_aux i W).op :=\n  by\n  have e₁ := Scheme.congr_app (X.restrict_functor_map_of_restrict i) (op <| V.open_embedding.is_open_map.functor.obj W)\n  rw [Scheme.comp_val_c_app] at e₁\n  have e₂ := (X.restrict_functor.map i).1.val.c.naturality (eq_to_hom W.map_functor_eq).op\n  rw [← is_iso.eq_inv_comp] at e₂\n  dsimp at e₁ e₂⊢\n  rw [e₂, W.adjunction_counit_map_functor, ← is_iso.eq_inv_comp, is_iso.inv_comp_eq, ← is_iso.eq_comp_inv] at e₁\n  simp_rw [eq_to_hom_map (opens.map _), eq_to_hom_map (is_open_map.functor _), ← functor.map_inv, ← functor.map_comp] at\n    e₁\n  rw [e₁]\n  congr 1\n#align Scheme.restrict_functor_map_app Scheme.restrict_functor_map_app\n\n",
 "range_pullback_to_base_of_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem range_pullback_to_base_of_right :\n    Set.range («expr ≫ » pullback.fst g : «expr ⟶ » (pullback g f) Z).1.base =\n      Set.range g.1.base ∩ Set.range f.1.base :=\n  by\n  rw [Scheme.comp_val_base, coe_comp, Set.range_comp, range_pullback_fst_of_right, opens.map_obj, subtype.coe_mk,\n    Set.image_preimage_eq_inter_range, Set.inter_comm]\n#align range_pullback_to_base_of_right range_pullback_to_base_of_right\n\n",
 "range_pullback_to_base_of_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem range_pullback_to_base_of_left :\n    Set.range («expr ≫ » pullback.fst f : «expr ⟶ » (pullback f g) Z).1.base =\n      Set.range f.1.base ∩ Set.range g.1.base :=\n  by\n  rw [pullback.condition, Scheme.comp_val_base, coe_comp, Set.range_comp, range_pullback_snd_of_left, opens.map_obj,\n    subtype.coe_mk, Set.image_preimage_eq_inter_range, Set.inter_comm]\n#align range_pullback_to_base_of_left range_pullback_to_base_of_left\n\n",
 "range_pullback_snd_of_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem range_pullback_snd_of_left :\n    Set.range (pullback.snd : «expr ⟶ » (pullback f g) Y).1.base =\n      (opens.map g.1.base).obj ⟨Set.range f.1.base, H.base_open.open_range⟩ :=\n  by\n  rw [←\n    show _ = (pullback.snd : «expr ⟶ » (pullback f g) _).1.base from\n      preserves_pullback.iso_hom_snd Scheme.forget_to_Top f g,\n    coe_comp, Set.range_comp, set.range_iff_surjective.mpr, ←\n    @Set.preimage_univ _ _ (pullback.fst : «expr ⟶ » (pullback f.1.base g.1.base) _),\n    Top.pullback_snd_image_fst_preimage, Set.image_univ]\n  rfl\n  rw [← Top.epi_iff_surjective]\n  infer_instance\n#align range_pullback_snd_of_left range_pullback_snd_of_left\n\n",
 "range_pullback_fst_of_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem range_pullback_fst_of_right :\n    Set.range (pullback.fst : «expr ⟶ » (pullback g f) Y).1.base =\n      (opens.map g.1.base).obj ⟨Set.range f.1.base, H.base_open.open_range⟩ :=\n  by\n  rw [←\n    show _ = (pullback.fst : «expr ⟶ » (pullback g f) _).1.base from\n      preserves_pullback.iso_hom_fst Scheme.forget_to_Top g f,\n    coe_comp, Set.range_comp, set.range_iff_surjective.mpr, ←\n    @Set.preimage_univ _ _ (pullback.snd : «expr ⟶ » (pullback g.1.base f.1.base) _),\n    Top.pullback_fst_image_snd_preimage, Set.image_univ]\n  rfl\n  rw [← Top.epi_iff_surjective]\n  infer_instance\n#align range_pullback_fst_of_right range_pullback_fst_of_right\n\n",
 "pullback_snd_is_iso_of_range_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem pullback_snd_is_iso_of_range_subset (H' : Set.range g.1.base ⊆ Set.range f.1.base) :\n    IsIso (pullback.snd : «expr ⟶ » (pullback f g) _) :=\n  by\n  apply (config := { instances := false }) reflects_isomorphisms.reflects LocallyRingedSpace.forget_to_SheafedSpace\n  apply (config := { instances := false }) reflects_isomorphisms.reflects SheafedSpace.forget_to_PresheafedSpace\n  erw [←\n    preserves_pullback.iso_hom_snd\n      («expr ⋙ » LocallyRingedSpace.forget_to_SheafedSpace SheafedSpace.forget_to_PresheafedSpace) f g]\n  haveI := PresheafedSpace.is_open_immersion.pullback_snd_is_iso_of_range_subset _ _ H'\n  infer_instance\n  infer_instance\n#align pullback_snd_is_iso_of_range_subset pullback_snd_is_iso_of_range_subset\n\n",
 "pullback_restrict_iso_restrict_inv_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem pullback_restrict_iso_restrict_inv_fst {X Y : Scheme} (f : «expr ⟶ » X Y) (U : opens Y.carrier) :\n    «expr ≫ » (pullback_restrict_iso_restrict f U).inv pullback.fst = X.of_restrict _ :=\n  by\n  delta pullback_restrict_iso_restrict\n  simp\n#align pullback_restrict_iso_restrict_inv_fst pullback_restrict_iso_restrict_inv_fst\n\n",
 "pullback_restrict_iso_restrict_hom_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem pullback_restrict_iso_restrict_hom_restrict {X Y : Scheme} (f : «expr ⟶ » X Y) (U : opens Y.carrier) :\n    «expr ≫ » (pullback_restrict_iso_restrict f U).hom (X.of_restrict _) = pullback.fst :=\n  by\n  delta pullback_restrict_iso_restrict\n  simp\n#align pullback_restrict_iso_restrict_hom_restrict pullback_restrict_iso_restrict_hom_restrict\n\n",
 "pullback_restrict_iso_restrict_hom_morphism_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n@[simp, reassoc.1]\ntheorem pullback_restrict_iso_restrict_hom_morphism_restrict {X Y : Scheme} (f : «expr ⟶ » X Y) (U : opens Y.carrier) :\n    «expr ≫ » (pullback_restrict_iso_restrict f U).hom («expr ∣_ » f U) = pullback.snd :=\n  iso.hom_inv_id_assoc _ _\n#align pullback_restrict_iso_restrict_hom_morphism_restrict pullback_restrict_iso_restrict_hom_morphism_restrict\n\n",
 "pullback_cone_of_left_lift_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- this lemma is not a `simp` lemma, because it is an implementation detail\ntheorem pullback_cone_of_left_lift_snd :\n    «expr ≫ » (pullback_cone_of_left_lift f g s) (pullback_cone_of_left f g).snd = s.snd :=\n  by\n  ext x\n  · change «expr ≫ » («expr ≫ » _ («expr ≫ » _ _)) _ = _\n    simp_rw [category.assoc]\n    erw [s.snd.c.naturality_assoc]\n    erw [← s.X.presheaf.map_comp, ← s.X.presheaf.map_comp]\n    trans «expr ≫ » (s.snd.c.app x) (s.X.presheaf.map ((«expr𝟙») _))\n    · congr\n    · rw [s.X.presheaf.map_id]\n      erw [category.comp_id]\n  · change «expr ≫ » (pullback.lift _ _ _) pullback.snd = _\n    simp\n#align pullback_cone_of_left_lift_snd pullback_cone_of_left_lift_snd\n\n",
 "pullback_cone_of_left_lift_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- this lemma is not a `simp` lemma, because it is an implementation detail\ntheorem pullback_cone_of_left_lift_fst :\n    «expr ≫ » (pullback_cone_of_left_lift f g s) (pullback_cone_of_left f g).fst = s.fst :=\n  by\n  ext x\n  · induction x using opposite.rec\n    change «expr ≫ » («expr ≫ » («expr ≫ » _ _) («expr ≫ » _ _)) _ = _\n    simp_rw [category.assoc]\n    erw [← s.X.presheaf.map_comp]\n    erw [s.snd.c.naturality_assoc]\n    have := congr_app s.condition (op (hf.open_functor.obj x))\n    dsimp only [comp_c_app, unop_op] at this\n    rw [← is_iso.comp_inv_eq] at this\n    reassoc! this\n    erw [← this, hf.inv_app_app_assoc, s.fst.c.naturality_assoc]\n    simpa [eq_to_hom_map]\n  · change «expr ≫ » (pullback.lift _ _ _) pullback.fst = _\n    simp\n#align pullback_cone_of_left_lift_fst pullback_cone_of_left_lift_fst\n\n",
 "pullback_cone_of_left_condition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem pullback_cone_of_left_condition : «expr ≫ » (pullback_cone_of_left_fst f g) f = «expr ≫ » (Y.of_restrict _) g :=\n  by\n  ext U\n  · induction U using opposite.rec\n    dsimp only [comp_c_app, nat_trans.comp_app, unop_op, whisker_right_app, pullback_cone_of_left_fst]\n    simp only [quiver.hom.unop_op, Top.presheaf.pushforward_obj_map, app_inv_app_assoc, eq_to_hom_app, eq_to_hom_unop,\n      category.assoc, nat_trans.naturality_assoc, functor.op_map]\n    erw [← Y.presheaf.map_comp, ← Y.presheaf.map_comp]\n    congr\n  · simpa using pullback.condition\n#align pullback_cone_of_left_condition pullback_cone_of_left_condition\n\n",
 "open_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_open_immersion.open_range {X Y : Scheme} (f : «expr ⟶ » X Y) [H : is_open_immersion f] :\n    is_open (Set.range f.1.base) :=\n  H.base_open.open_range\n#align is_open_immersion.open_range is_open_immersion.open_range\n\n",
 "of_stalk_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem of_stalk_iso {X Y : Scheme} (f : «expr ⟶ » X Y) (hf : open_embedding f.1.base)\n    [∀ x, IsIso (PresheafedSpace.stalk_map f.1 x)] : is_open_immersion f :=\n  SheafedSpace.is_open_immersion.of_stalk_iso f.1 hf\n#align of_stalk_iso of_stalk_iso\n\n",
 "of_restrict_inv_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[elementwise, simp]\ntheorem of_restrict_inv_app {C : Type _} [Category C] (X : PresheafedSpace C) {Y : Top}\n    {f : «expr ⟶ » Y (Top.of X.carrier)} (h : open_embedding f) (U : opens (X.restrict h).carrier) :\n    (PresheafedSpace.is_open_immersion.of_restrict X h).inv_app U = («expr𝟙») _ :=\n  by\n  delta PresheafedSpace.is_open_immersion.inv_app\n  rw [is_iso.comp_inv_eq, category.id_comp]\n  change X.presheaf.map _ = X.presheaf.map _\n  congr\n#align of_restrict_inv_app of_restrict_inv_app\n\n",
 "morphism_restrict_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem morphism_restrict_ι {X Y : Scheme} (f : «expr ⟶ » X Y) (U : opens Y.carrier) :\n    «expr ≫ » («expr ∣_ » f U) (Y.of_restrict U.open_embedding) = «expr ≫ » (X.of_restrict _) f :=\n  by\n  delta morphism_restrict\n  rw [category.assoc, pullback.condition.symm, pullback_restrict_iso_restrict_inv_fst_assoc]\n#align morphism_restrict_ι morphism_restrict_ι\n\n",
 "morphism_restrict_val_base":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\ntheorem morphism_restrict_val_base {X Y : Scheme} (f : «expr ⟶ » X Y) (U : opens Y.carrier) :\n    «expr⇑ » («expr ∣_ » f U).1.base = U.1.restrict_preimage f.1.base :=\n  funext fun x => subtype.ext (morphism_restrict_base_coe f U x)\n#align morphism_restrict_val_base morphism_restrict_val_base\n\n",
 "morphism_restrict_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\ntheorem morphism_restrict_comp {X Y Z : Scheme} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) (U : opens Z.carrier) :\n    «expr ∣_ » («expr ≫ » f g) U = («expr ≫ » («expr ∣_ » f ((opens.map g.val.base).obj U)) («expr ∣_ » g U) : _) :=\n  by\n  delta morphism_restrict\n  rw [← pullback_right_pullback_fst_iso_inv_snd_snd]\n  simp_rw [← category.assoc]\n  congr 1\n  rw [← cancel_mono pullback.fst]\n  simp_rw [category.assoc]\n  rw [pullback_restrict_iso_restrict_inv_fst, pullback_right_pullback_fst_iso_inv_snd_fst, ← pullback.condition,\n    pullback_restrict_iso_restrict_inv_fst_assoc, pullback_restrict_iso_restrict_inv_fst_assoc]\n  rfl\n  infer_instance\n#align morphism_restrict_comp morphism_restrict_comp\n\n",
 "morphism_restrict_c_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem morphism_restrict_c_app {X Y : Scheme} (f : «expr ⟶ » X Y) (U : opens Y.carrier) (V : opens U) :\n    («expr ∣_ » f U).1.c.app (op V) =\n      «expr ≫ » (f.1.c.app (op (U.open_embedding.is_open_map.functor.obj V)))\n        (X.presheaf.map (eq_to_hom (image_morphism_restrict_preimage f U V)).op) :=\n  by\n  have := Scheme.congr_app (morphism_restrict_ι f U) (op (U.open_embedding.is_open_map.functor.obj V))\n  rw [Scheme.comp_val_c_app, Scheme.comp_val_c_app_assoc] at this\n  have e : (opens.map U.inclusion).obj (U.open_embedding.is_open_map.functor.obj V) = V :=\n    by\n    ext1\n    exact Set.preimage_image_eq _ subtype.coe_injective\n  have : «expr ≫ » _ (X.presheaf.map _) = _ :=\n    (((«expr ∣_ » f U).1.c.naturality (eq_to_hom e).op).symm.trans _).trans this\n  swap\n  · change «expr ≫ » (Y.presheaf.map _) _ = «expr ≫ » (Y.presheaf.map _) _\n    congr\n  rw [← is_iso.eq_comp_inv, ← functor.map_inv, category.assoc] at this\n  rw [this]\n  congr 1\n  erw [← X.presheaf.map_comp, ← X.presheaf.map_comp]\n  congr 1\n#align morphism_restrict_c_app morphism_restrict_c_app\n\n",
 "morphism_restrict_base_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\ntheorem morphism_restrict_base_coe {X Y : Scheme} (f : «expr ⟶ » X Y) (U : opens Y.carrier) (x) :\n    @coe U Y.carrier _ ((«expr ∣_ » f U).1.base x) = f.1.base x.1 :=\n  congr_arg (fun f => PresheafedSpace.hom.base (LocallyRingedSpace.hom.val f) x) (morphism_restrict_ι f U)\n#align morphism_restrict_base_coe morphism_restrict_base_coe\n\n",
 "lift_uniq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem lift_uniq (H' : Set.range g.1.base ⊆ Set.range f.1.base) (l : «expr ⟶ » Y X) (hl : «expr ≫ » l f = g) :\n    l = lift f g H' :=\n  LocallyRingedSpace.is_open_immersion.lift_uniq f g H' l hl\n#align lift_uniq lift_uniq\n\n",
 "lift_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lift_range (H' : Set.range g.1.base ⊆ Set.range f.1.base) :\n    Set.range (lift f g H').1.base = «expr ⁻¹' » f.1.base (Set.range g.1.base) :=\n  by\n  haveI := pullback_snd_is_iso_of_range_subset f g H'\n  dsimp only [lift]\n  have : _ = (pullback.fst : «expr ⟶ » (pullback f g) _).val.base :=\n    preserves_pullback.iso_hom_fst («expr ⋙ » LocallyRingedSpace.forget_to_SheafedSpace (SheafedSpace.forget _)) f g\n  rw [LocallyRingedSpace.comp_val, SheafedSpace.comp_base, ← this, ← category.assoc, coe_comp]\n  rw [Set.range_comp, set.range_iff_surjective.mpr, Set.image_univ, Top.pullback_fst_range]\n  ext\n  constructor\n  · rintro ⟨y, eq⟩\n    exact ⟨y, eq.symm⟩\n  · rintro ⟨y, eq⟩\n    exact ⟨y, eq.symm⟩\n  · rw [← Top.epi_iff_surjective]\n    rw [show (inv (pullback.snd : «expr ⟶ » (pullback f g) _)).val.base = _ from\n        («expr ⋙ » LocallyRingedSpace.forget_to_SheafedSpace (SheafedSpace.forget _)).map_inv _]\n    infer_instance\n#align lift_range lift_range\n\n",
 "lift_fac":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem lift_fac (H' : Set.range g.1.base ⊆ Set.range f.1.base) : «expr ≫ » (lift f g H') f = g :=\n  LocallyRingedSpace.is_open_immersion.lift_fac f g H'\n#align lift_fac lift_fac\n\n",
 "lift_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem lift_app {X Y U : Scheme} (f : «expr ⟶ » U Y) (g : «expr ⟶ » X Y) [h : is_open_immersion f] (H)\n    (V : opens U.carrier) :\n    (is_open_immersion.lift f g H).1.c.app (op V) =\n      «expr ≫ » (f.inv_app _)\n        («expr ≫ » (g.1.c.app _)\n          (X.presheaf.map\n            (eq_to_hom <|\n                is_open_immersion.app_eq_inv_app_app_of_comp_eq_aux _ _ _ (is_open_immersion.lift_fac f g H).symm\n                  V).op)) :=\n  is_open_immersion.app_eq_inv_app_app_of_comp_eq _ _ _ _ _\n#align lift_app lift_app\n\n",
 "iso_restrict_inv_of_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem iso_restrict_inv_of_restrict : «expr ≫ » H.iso_restrict.inv f = Y.of_restrict _ := by\n  rw [iso.inv_comp_eq, iso_restrict_hom_of_restrict]\n#align iso_restrict_inv_of_restrict iso_restrict_inv_of_restrict\n\n",
 "iso_restrict_hom_of_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\n@[simp]\ntheorem iso_restrict_hom_of_restrict : «expr ≫ » H.iso_restrict.hom (Y.of_restrict _) = f :=\n  by\n  ext\n  · simp only [comp_c_app, iso_restrict_hom_c_app, nat_trans.comp_app, eq_to_hom_refl, of_restrict_c_app,\n      category.assoc, whisker_right_id']\n    erw [category.comp_id, f.c.naturality_assoc, ← X.presheaf.map_comp]\n    trans «expr ≫ » (f.c.app x) (X.presheaf.map ((«expr𝟙») _))\n    · congr\n    · erw [X.presheaf.map_id, category.comp_id]\n  · rfl\n#align iso_restrict_hom_of_restrict iso_restrict_hom_of_restrict\n\n",
 "is_pullback_morphism_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\ntheorem is_pullback_morphism_restrict {X Y : Scheme} (f : «expr ⟶ » X Y) (U : opens Y.carrier) :\n    is_pullback («expr ∣_ » f U) (X.of_restrict _) (Y.of_restrict _) f :=\n  by\n  delta morphism_restrict\n  nth_rw 1 [← category.id_comp f]\n  refine'\n    (is_pullback.of_horiz_is_iso ⟨_⟩).paste_horiz (is_pullback.of_has_pullback f (Y.of_restrict U.open_embedding)).flip\n  rw [pullback_restrict_iso_restrict_inv_fst, category.comp_id]\n#align is_pullback_morphism_restrict is_pullback_morphism_restrict\n\n",
 "is_iso_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_iso_of_subset {X Y : PresheafedSpace.{v} C} (f : «expr ⟶ » X Y) [H : PresheafedSpace.is_open_immersion f]\n    (U : opens Y.carrier) (hU : (U : set Y.carrier) ⊆ Set.range f.base) : IsIso (f.c.app <| op U) :=\n  by\n  have : U = H.base_open.is_open_map.functor.obj ((opens.map f.base).obj U) :=\n    by\n    ext1\n    exact (set.inter_eq_left_iff_subset.mpr hU).symm.trans set.image_preimage_eq_inter_range.symm\n  convert PresheafedSpace.is_open_immersion.c_iso ((opens.map f.base).obj U)\n#align is_iso_of_subset is_iso_of_subset\n\n",
 "is_iso_iff_stalk_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem _root_.algebraic_geometry.is_iso_iff_stalk_iso {X Y : Scheme} (f : «expr ⟶ » X Y) :\n    IsIso f ↔ IsIso f.1.base ∧ ∀ x, IsIso (PresheafedSpace.stalk_map f.1 x) :=\n  by\n  rw [is_iso_iff_is_open_immersion, is_open_immersion.iff_stalk_iso, and_comm', ← and_assoc']\n  refine' and_congr ⟨_, _⟩ iff.rfl\n  · rintro ⟨h₁, h₂⟩\n    convert_to\n      is_iso\n        (Top.iso_of_homeo\n            (homeomorph.homeomorph_of_continuous_open (Equiv.ofBijective _ ⟨h₂.inj, (Top.epi_iff_surjective _).mp h₁⟩)\n              h₂.continuous h₂.is_open_map)).hom\n    · ext\n      rfl\n    · infer_instance\n  · intro H\n    exact ⟨infer_instance, (Top.homeo_of_iso (as_iso f.1.base)).open_embedding⟩\n#align algebraic_geometry.is_iso_iff_stalk_iso algebraic_geometry.is_iso_iff_stalk_iso\n\n",
 "is_iso_iff_is_open_immersion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem _root_.algebraic_geometry.is_iso_iff_is_open_immersion {X Y : Scheme} (f : «expr ⟶ » X Y) :\n    IsIso f ↔ is_open_immersion f ∧ Epi f.1.base :=\n  ⟨fun H => ⟨infer_instance, infer_instance⟩, fun ⟨h₁, h₂⟩ => @is_open_immersion.to_iso f h₁ h₂⟩\n#align algebraic_geometry.is_iso_iff_is_open_immersion algebraic_geometry.is_iso_iff_is_open_immersion\n\n",
 "inv_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem inv_naturality {U V : «expr ᵒᵖ» (opens X)} (i : «expr ⟶ » U V) :\n    «expr ≫ » (X.presheaf.map i) (H.inv_app (unop V)) =\n      «expr ≫ » (H.inv_app (unop U)) (Y.presheaf.map (H.open_functor.op.map i)) :=\n  by\n  simp only [inv_app, ← category.assoc]\n  rw [is_iso.comp_inv_eq]\n  simp only [category.assoc, f.c.naturality, is_iso.inv_hom_id_assoc, ← X.presheaf.map_comp]\n  erw [← X.presheaf.map_comp]\n  congr\n#align inv_naturality inv_naturality\n\n",
 "inv_inv_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem inv_inv_app (U : opens X) :\n    inv (H.inv_app U) =\n      «expr ≫ » (f.c.app (op (H.open_functor.obj U)))\n        (X.presheaf.map (eq_to_hom (by simp [opens.map, Set.preimage_image_eq _ H.base_open.inj]))) :=\n  by\n  rw [← cancel_epi (H.inv_app U)]\n  rw [is_iso.hom_inv_id]\n  delta inv_app\n  simp [← functor.map_comp]\n#align inv_inv_app inv_inv_app\n\n",
 "inv_app_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1, elementwise]\ntheorem inv_app_app (U : opens X) :\n    «expr ≫ » (H.inv_app U) (f.c.app (op (H.open_functor.obj U))) =\n      X.presheaf.map (eq_to_hom (by simp [opens.map, Set.preimage_image_eq _ H.base_open.inj])) :=\n  by rw [inv_app, category.assoc, is_iso.inv_hom_id, category.comp_id]\n#align inv_app_app inv_app_app\n\n",
 "image_preimage_is_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem image_preimage_is_empty (j : discrete ι) (h : i ≠ j) (U : opens (F.obj i)) :\n    (opens.map (colimit.ι («expr ⋙ » F SheafedSpace.forget_to_PresheafedSpace) j).base).obj\n        ((opens.map (preserves_colimit_iso SheafedSpace.forget_to_PresheafedSpace F).inv.base).obj\n          ((sigma_ι_open_embedding F i).is_open_map.functor.obj U)) =\n      ∅ :=\n  by\n  ext\n  apply iff_false_intro\n  rintro ⟨y, hy, eq⟩\n  replace eq :=\n    concrete_category.congr_arg\n      («expr ≪≫ » (preserves_colimit_iso (SheafedSpace.forget C) F)\n          («expr ≪≫ » (has_colimit.iso_of_nat_iso discrete.nat_iso_functor) (Top.sigma_iso_sigma.{v} _))).hom\n      eq\n  simp_rw [category_theory.iso.trans_hom, ← Top.comp_app, ← PresheafedSpace.comp_base] at eq\n  rw [ι_preserves_colimits_iso_inv] at eq\n  change\n    («expr ≫ » ((SheafedSpace.forget C).map (colimit.ι F i)) _) y =\n      («expr ≫ » ((SheafedSpace.forget C).map (colimit.ι F j)) _) x at\n    eq\n  cases i; cases j\n  rw [ι_preserves_colimits_iso_hom_assoc, ι_preserves_colimits_iso_hom_assoc, has_colimit.iso_of_nat_iso_ι_hom_assoc,\n    has_colimit.iso_of_nat_iso_ι_hom_assoc, Top.sigma_iso_sigma_hom_ι.{v}, Top.sigma_iso_sigma_hom_ι.{v}] at eq\n  exact h (congr_arg discrete.mk (congr_arg sigma.fst eq))\n#align image_preimage_is_empty image_preimage_is_empty\n\n",
 "image_morphism_restrict_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\ntheorem image_morphism_restrict_preimage {X Y : Scheme} (f : «expr ⟶ » X Y) (U : opens Y.carrier) (V : opens U) :\n    ((opens.map f.val.base).obj U).open_embedding.is_open_map.functor.obj\n        ((opens.map («expr ∣_ » f U).val.base).obj V) =\n      (opens.map f.val.base).obj (U.open_embedding.is_open_map.functor.obj V) :=\n  by\n  ext1\n  ext x\n  constructor\n  · rintro ⟨⟨x, hx⟩, hx' : («expr ∣_ » f U).1.base _ ∈ _, rfl⟩\n    refine' ⟨⟨_, hx⟩, _, rfl⟩\n    convert hx'\n    ext1\n    exact (morphism_restrict_base_coe f U ⟨x, hx⟩).symm\n  · rintro ⟨⟨x, hx⟩, hx', rfl : x = _⟩\n    refine' ⟨⟨_, hx⟩, (_ : («expr ∣_ » f U).1.base ⟨x, hx⟩ ∈ V.1), rfl⟩\n    convert hx'\n    ext1\n    exact morphism_restrict_base_coe f U ⟨x, hx⟩\n#align image_morphism_restrict_preimage image_morphism_restrict_preimage\n\n",
 "image_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem image_basic_open {X Y : Scheme} (f : «expr ⟶ » X Y) [H : is_open_immersion f] {U : opens X.carrier}\n    (r : X.presheaf.obj (op U)) : f.opens_functor.obj (X.basic_open r) = Y.basic_open (f.inv_app U r) :=\n  by\n  have e := Scheme.preimage_basic_open f (f.inv_app U r)\n  rw [Scheme.hom.inv_app, PresheafedSpace.is_open_immersion.inv_app_app_apply, Scheme.basic_open_res,\n    inf_eq_right.mpr _] at e\n  rw [← e]\n  ext1\n  refine' set.image_preimage_eq_inter_range.trans _\n  erw [Set.inter_eq_left_iff_subset]\n  refine' Set.Subset.trans (Scheme.basic_open_le _ _) (Set.image_subset_range _ _)\n  refine' le_trans (Scheme.basic_open_le _ _) (le_of_eq _)\n  ext1\n  exact (Set.preimage_image_eq _ H.base_open.inj).symm\n#align image_basic_open image_basic_open\n\n",
 "iff_stalk_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem iff_stalk_iso {X Y : Scheme} (f : «expr ⟶ » X Y) :\n    is_open_immersion f ↔ open_embedding f.1.base ∧ ∀ x, IsIso (PresheafedSpace.stalk_map f.1 x) :=\n  ⟨fun H => ⟨H.1, infer_instance⟩, fun ⟨h₁, h₂⟩ => @is_open_immersion.of_stalk_iso f h₁ h₂⟩\n#align iff_stalk_iso iff_stalk_iso\n\n",
 "compact_space":
 "theorem Scheme.open_cover.compact_space {X : Scheme} (𝒰 : X.open_cover) [Finite 𝒰.J]\n    [H : ∀ i, compact_space (𝒰.obj i).carrier] : compact_space X.carrier :=\n  by\n  cases nonempty_fintype 𝒰.J\n  rw [← is_compact_univ_iff, ← 𝒰.Union_range]\n  apply is_compact_Union\n  intro i\n  rw [is_compact_iff_compact_space]\n  exact\n    @homeomorph.compact_space _ _ (H i)\n      (Top.homeo_of_iso\n        (as_iso\n          (is_open_immersion.iso_of_range_eq (𝒰.map i)\n                  (X.of_restrict (opens.open_embedding ⟨_, (𝒰.is_open i).base_open.open_range⟩))\n                  subtype.range_coe.symm).hom.1.base))\n#align Scheme.open_cover.compact_space Scheme.open_cover.compact_space\n\n",
 "app_inv_app'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- A variant of `app_inv_app` that gives an `eq_to_hom` instead of `hom_of_le`. -/\n@[reassoc.1]\ntheorem app_inv_app' (U : opens Y) (hU : (U : set Y) ⊆ Set.range f.base) :\n    «expr ≫ » (f.c.app (op U)) (H.inv_app ((opens.map f.base).obj U)) =\n      Y.presheaf.map\n        (eq_to_hom\n            (by\n              apply has_le.le.antisymm\n              · exact Set.image_preimage_subset f.base U.1\n              · change U ⊆ _\n                refine' has_le.le.trans_eq _ (@Set.image_preimage_eq_inter_range _ _ f.base U.1).symm\n                exact set.subset_inter_iff.mpr ⟨fun _ h => h, hU⟩)).op :=\n  by\n  erw [← category.assoc]\n  rw [is_iso.comp_inv_eq, f.c.naturality]\n  congr\n#align app_inv_app' app_inv_app'\n\n",
 "app_inv_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp, reassoc.1]\ntheorem app_inv_app (U : opens Y) :\n    «expr ≫ » (f.c.app (op U)) (H.inv_app ((opens.map f.base).obj U)) =\n      Y.presheaf.map\n        ((hom_of_le (Set.image_preimage_subset f.base U)).op :\n          «expr ⟶ » (op U) (op (H.open_functor.obj ((opens.map f.base).obj U)))) :=\n  by\n  erw [← category.assoc]\n  rw [is_iso.comp_inv_eq, f.c.naturality]\n  congr\n#align app_inv_app app_inv_app\n\n",
 "app_eq_inv_app_app_of_comp_eq_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem app_eq_inv_app_app_of_comp_eq_aux {X Y U : Scheme} (f : «expr ⟶ » Y U) (g : «expr ⟶ » U X) (fg : «expr ⟶ » Y X)\n    (H : fg = «expr ≫ » f g) [h : is_open_immersion g] (V : opens U.carrier) :\n    (opens.map f.1.base).obj V = (opens.map fg.1.base).obj (g.opens_functor.obj V) :=\n  by\n  subst H\n  rw [Scheme.comp_val_base, opens.map_comp_obj]\n  congr 1\n  ext1\n  exact (Set.preimage_image_eq _ h.base_open.inj).symm\n#align app_eq_inv_app_app_of_comp_eq_aux app_eq_inv_app_app_of_comp_eq_aux\n\n",
 "app_eq_inv_app_app_of_comp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The `fg` argument is to avoid nasty stuff about dependent types. -/\ntheorem app_eq_inv_app_app_of_comp_eq {X Y U : Scheme} (f : «expr ⟶ » Y U) (g : «expr ⟶ » U X) (fg : «expr ⟶ » Y X)\n    (H : fg = «expr ≫ » f g) [h : is_open_immersion g] (V : opens U.carrier) :\n    f.1.c.app (op V) =\n      «expr ≫ » (g.inv_app _)\n        («expr ≫ » (fg.1.c.app _)\n          (Y.presheaf.map (eq_to_hom <| is_open_immersion.app_eq_inv_app_app_of_comp_eq_aux f g fg H V).op)) :=\n  by\n  subst H\n  rw [Scheme.comp_val_c_app, category.assoc, Scheme.hom.inv_app, PresheafedSpace.is_open_immersion.inv_app_app_assoc,\n    f.val.c.naturality_assoc, Top.presheaf.pushforward_obj_map, ← functor.map_comp]\n  convert (category.comp_id _).symm\n  convert Y.presheaf.map_id _\n#align app_eq_inv_app_app_of_comp_eq app_eq_inv_app_app_of_comp_eq\n\n",
 "affine_basis_cover_obj":
 "-- TODO: provide API to and from a presieve.\n-- Related result : `open_cover.pullback_cover`, where we pullback an open cover on `X` along a\n-- morphism `W ⟶ X`. This is provided at the end of the file since it needs some more results\n-- about open immersion (which in turn needs the open cover API).\ntheorem affine_basis_cover_obj (X : Scheme) (i : X.affine_basis_cover.J) :\n    X.affine_basis_cover.obj i = Spec.obj (op <| X.affine_basis_cover_ring i) :=\n  rfl\n#align affine_basis_cover_obj affine_basis_cover_obj\n\n",
 "affine_basis_cover_map_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem affine_basis_cover_map_range (X : Scheme) (x : X.carrier) (r : (X.local_affine x).some_spec.some) :\n    Set.range (X.affine_basis_cover.map ⟨x, r⟩).1.base =\n      «expr '' » (X.affine_cover.map x).1.base (prime_spectrum.basic_open r).1 :=\n  by\n  erw [coe_comp, Set.range_comp]\n  congr\n  exact (prime_spectrum.localization_away_comap_range (localization.away r) r : _)\n#align affine_basis_cover_map_range affine_basis_cover_map_range\n\n",
 "affine_basis_cover_is_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem affine_basis_cover_is_basis (X : Scheme) :\n    topological_space.is_topological_basis\n      { x : set X.carrier | ∃ a : X.affine_basis_cover.J, x = Set.range (X.affine_basis_cover.map a).1.base } :=\n  by\n  apply topological_space.is_topological_basis_of_open_of_nhds\n  · rintro _ ⟨a, rfl⟩\n    exact is_open_immersion.open_range (X.affine_basis_cover.map a)\n  · rintro a U haU hU\n    rcases X.affine_cover.covers a with ⟨x, e⟩\n    let U' := «expr ⁻¹' » (X.affine_cover.map (X.affine_cover.f a)).1.base U\n    have hxU' : x ∈ U' := by\n      rw [← e] at haU\n      exact haU\n    rcases prime_spectrum.is_basis_basic_opens.exists_subset_of_mem_open hxU'\n        ((X.affine_cover.map (X.affine_cover.f a)).1.base.continuous_to_fun.is_open_preimage _ hU) with\n      ⟨_, ⟨_, ⟨s, rfl⟩, rfl⟩, hxV, hVU⟩\n    refine' ⟨_, ⟨⟨_, s⟩, rfl⟩, _, _⟩ <;> erw [affine_basis_cover_map_range]\n    · exact ⟨x, hxV, e⟩\n    · rw [Set.image_subset_iff]\n      exact hVU\n#align affine_basis_cover_is_basis affine_basis_cover_is_basis\n\n",
 "Union_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Scheme.open_cover.Union_range {X : Scheme} (𝒰 : X.open_cover) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (Set.range (𝒰.map i).1.base) =\n      Set.univ :=\n  by\n  rw [Set.eq_univ_iff_forall]\n  intro x\n  rw [Set.mem_unionᵢ]\n  exact ⟨𝒰.f x, 𝒰.covers x⟩\n#align Scheme.open_cover.Union_range Scheme.open_cover.Union_range\n\n",
 "SheafedSpace_to_SheafedSpace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expris_open_immersion -/\n@[simp]\ntheorem SheafedSpace_to_SheafedSpace {X Y : SheafedSpace.{v} C} (f : «expr ⟶ » X Y) [(expris_open_immersion) f] :\n    to_SheafedSpace Y f = X := by\n  cases X\n  rfl\n#align SheafedSpace_to_SheafedSpace SheafedSpace_to_SheafedSpace\n\n",
 "Scheme_to_Scheme":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem Scheme_to_Scheme {X Y : Scheme} (f : «expr ⟶ » X Y) [is_open_immersion f] : to_Scheme Y f.1 = X :=\n  by\n  apply Scheme_eq_of_LocallyRingedSpace_eq\n  exact LocallyRingedSpace_to_LocallyRingedSpace f\n#align Scheme_to_Scheme Scheme_to_Scheme\n\n",
 "Scheme_eq_of_LocallyRingedSpace_eq":
 "theorem Scheme_eq_of_LocallyRingedSpace_eq {X Y : Scheme} (H : X.to_LocallyRingedSpace = Y.to_LocallyRingedSpace) :\n    X = Y := by\n  cases X\n  cases Y\n  congr\n  exact H\n#align Scheme_eq_of_LocallyRingedSpace_eq Scheme_eq_of_LocallyRingedSpace_eq\n\n",
 "LocallyRingedSpace_to_LocallyRingedSpace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem LocallyRingedSpace_to_LocallyRingedSpace {X Y : LocallyRingedSpace} (f : «expr ⟶ » X Y)\n    [LocallyRingedSpace.is_open_immersion f] : to_LocallyRingedSpace Y f.1 = X :=\n  by\n  cases X\n  delta to_LocallyRingedSpace\n  simp\n#align LocallyRingedSpace_to_LocallyRingedSpace LocallyRingedSpace_to_LocallyRingedSpace\n\n"}