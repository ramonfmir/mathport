{"source_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem locally_of_finite_type.source_open_cover_iff {X Y : Scheme.{u}} (f : «expr ⟶ » X Y)\n    (𝒰 : Scheme.open_cover.{u} X) : locally_of_finite_type f ↔ ∀ i, locally_of_finite_type («expr ≫ » (𝒰.map i) f) :=\n  locally_of_finite_type_eq.symm ▸ ring_hom.finite_type_is_local.source_open_cover_iff f 𝒰\n#align locally_of_finite_type.source_open_cover_iff locally_of_finite_type.source_open_cover_iff\n\n",
 "open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem locally_of_finite_type.open_cover_iff {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) (𝒰 : Scheme.open_cover.{u} Y) :\n    locally_of_finite_type f ↔ ∀ i, locally_of_finite_type (pullback.snd : «expr ⟶ » (pullback f (𝒰.map i)) _) :=\n  locally_of_finite_type_eq.symm ▸ ring_hom.finite_type_is_local.is_local_affine_locally.open_cover_iff f 𝒰\n#align locally_of_finite_type.open_cover_iff locally_of_finite_type.open_cover_iff\n\n",
 "locally_of_finite_type_stable_under_composition":
 "theorem locally_of_finite_type_stable_under_composition :\n    morphism_property.stable_under_composition @locally_of_finite_type :=\n  locally_of_finite_type_eq.symm ▸ ring_hom.finite_type_is_local.affine_locally_stable_under_composition\n#align locally_of_finite_type_stable_under_composition locally_of_finite_type_stable_under_composition\n\n",
 "locally_of_finite_type_respects_iso":
 "theorem locally_of_finite_type_respects_iso : morphism_property.respects_iso @locally_of_finite_type :=\n  locally_of_finite_type_eq.symm ▸\n    target_affine_locally_respects_iso (source_affine_locally_respects_iso ring_hom.finite_type_respects_iso)\n#align locally_of_finite_type_respects_iso locally_of_finite_type_respects_iso\n\n",
 "locally_of_finite_type_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem locally_of_finite_type_of_comp {X Y Z : Scheme} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z)\n    [hf : locally_of_finite_type («expr ≫ » f g)] : locally_of_finite_type f :=\n  by\n  revert hf\n  rw [locally_of_finite_type_eq]\n  apply ring_hom.finite_type_is_local.affine_locally_of_comp\n  introv H\n  exact ring_hom.finite_type.of_comp_finite_type H\n#align locally_of_finite_type_of_comp locally_of_finite_type_of_comp\n\n",
 "locally_of_finite_type_eq":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem locally_of_finite_type_eq : @locally_of_finite_type = affine_locally @ring_hom.finite_type :=\n  by\n  ext (X Y f)\n  rw [locally_of_finite_type_iff, affine_locally_iff_affine_opens_le]\n  exact ring_hom.finite_type_respects_iso\n#align locally_of_finite_type_eq locally_of_finite_type_eq\n\n",
 "affine_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem locally_of_finite_type.affine_open_cover_iff {X Y : Scheme.{u}} (f : «expr ⟶ » X Y)\n    (𝒰 : Scheme.open_cover.{u} Y) [∀ i, is_affine (𝒰.obj i)]\n    (𝒰' : ∀ i, Scheme.open_cover.{u} ((𝒰.pullback_cover f).obj i)) [∀ i j, is_affine ((𝒰' i).obj j)] :\n    locally_of_finite_type f ↔ ∀ i j, (Scheme.Γ.map («expr ≫ » ((𝒰' i).map j) pullback.snd).op).finite_type :=\n  locally_of_finite_type_eq.symm ▸ ring_hom.finite_type_is_local.affine_open_cover_iff f 𝒰 𝒰'\n#align locally_of_finite_type.affine_open_cover_iff locally_of_finite_type.affine_open_cover_iff\n\n"}