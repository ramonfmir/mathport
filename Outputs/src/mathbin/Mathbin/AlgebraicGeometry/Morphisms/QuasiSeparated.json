{"quasi_separated_stable_under_composition":
 "theorem quasi_separated_stable_under_composition : morphism_property.stable_under_composition @quasi_separated :=\n  quasi_separated_eq_diagonal_is_quasi_compact.symm â–¸\n    quasi_compact_stable_under_composition.diagonal quasi_compact_respects_iso quasi_compact_stable_under_base_change\n#align quasi_separated_stable_under_composition quasi_separated_stable_under_composition\n\n",
 "quasi_separated_stable_under_base_change":
 "theorem quasi_separated_stable_under_base_change : morphism_property.stable_under_base_change @quasi_separated :=\n  quasi_separated_eq_diagonal_is_quasi_compact.symm â–¸\n    quasi_compact_stable_under_base_change.diagonal quasi_compact_respects_iso\n#align quasi_separated_stable_under_base_change quasi_separated_stable_under_base_change\n\n",
 "quasi_separated_space_of_quasi_separated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem quasi_separated_space_of_quasi_separated {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y)\n    [hY : quasi_separated_space Y.carrier] [quasi_separated f] : quasi_separated_space X.carrier :=\n  by\n  rw [quasi_separated_space_iff_quasi_separated] at hYâŠ¢\n  have : Â«expr â‰« Â» f (terminal.from Y) = terminal.from X := terminal_is_terminal.hom_ext _ _\n  rw [â† this]\n  skip; infer_instance\n#align quasi_separated_space_of_quasi_separated quasi_separated_space_of_quasi_separated\n\n",
 "quasi_separated_space_iff_quasi_separated":
 "theorem quasi_separated_space_iff_quasi_separated (X : Scheme) :\n    quasi_separated_space X.carrier â†” quasi_separated (terminal.from X) :=\n  (quasi_separated_over_affine_iff _).symm\n#align quasi_separated_space_iff_quasi_separated quasi_separated_space_iff_quasi_separated\n\n",
 "quasi_separated_space_iff_affine":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem quasi_separated_space_iff_affine (X : Scheme) :\n    quasi_separated_space X.carrier â†” âˆ€ U V : X.affine_opens, is_compact (U âˆ© V : set X.carrier) :=\n  by\n  rw [quasi_separated_space_iff]\n  constructor\n  Â· intro H U V\n    exact H U V U.1.2 U.2.is_compact V.1.2 V.2.is_compact\n  Â· intro H\n    suffices\n      âˆ€ (U : opens X.carrier) (hU : is_compact U.1) (V : opens X.carrier) (hV : is_compact V.1),\n        is_compact (Â«expr âŠ“ Â» U V).1\n      by\n      intro U V hU hU' hV hV'\n      exact this âŸ¨U, hUâŸ© hU' âŸ¨V, hVâŸ© hV'\n    intro U hU V hV\n    apply compact_open_induction_on V hV\n    Â· simp\n    Â· intro S hS V hV\n      change is_compact (U.1 âˆ© (S.1 âˆª V.1))\n      rw [Set.inter_union_distrib_left]\n      apply hV.union\n      clear hV\n      apply compact_open_induction_on U hU\n      Â· simp\n      Â· intro S hS W hW\n        change is_compact ((S.1 âˆª W.1) âˆ© V.1)\n        rw [Set.union_inter_distrib_right]\n        apply hW.union\n        apply H\n#align quasi_separated_space_iff_affine quasi_separated_space_iff_affine\n\n",
 "quasi_separated_respects_iso":
 "theorem quasi_separated_respects_iso : morphism_property.respects_iso @quasi_separated :=\n  quasi_separated_eq_diagonal_is_quasi_compact.symm â–¸ quasi_compact_respects_iso.diagonal\n#align quasi_separated_respects_iso quasi_separated_respects_iso\n\n",
 "quasi_separated_over_affine_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem quasi_separated_over_affine_iff {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) [is_affine Y] :\n    quasi_separated f â†” quasi_separated_space X.carrier := by\n  rw [quasi_separated_eq_affine_property, quasi_separated.affine_property_is_local.affine_target_iff f,\n    quasi_separated.affine_property]\n#align quasi_separated_over_affine_iff quasi_separated_over_affine_iff\n\n",
 "quasi_separated_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem quasi_separated_of_comp {X Y Z : Scheme} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z)\n    [H : quasi_separated (Â«expr â‰« Â» f g)] : quasi_separated f :=\n  by\n  rw [(quasi_separated.affine_open_cover_tfae f).out 0 1]\n  rw [(quasi_separated.affine_open_cover_tfae (Â«expr â‰« Â» f g)).out 0 2] at H\n  use (Z.affine_cover.pullback_cover g).bind fun x => Scheme.affine_cover _\n  constructor;\n  Â· intro i\n    dsimp\n    infer_instance\n  rintro âŸ¨i, jâŸ©; dsimp at *\n  specialize H _ i\n  refine' @quasi_separated_space_of_quasi_separated _ H _\n  Â·\n    exact\n      Â«expr â‰« Â» (pullback.map _ _ _ _ ((Â«exprğŸ™Â») _) _ _ (by simp) (category.comp_id _))\n        (pullback_right_pullback_fst_iso g (Z.affine_cover.map i) f).hom\n  Â· apply algebraic_geometry.quasi_separated_of_mono\n#align quasi_separated_of_comp quasi_separated_of_comp\n\n",
 "quasi_separated_eq_diagonal_is_quasi_compact":
 "theorem quasi_separated_eq_diagonal_is_quasi_compact : @quasi_separated = morphism_property.diagonal @quasi_compact :=\n  by\n  ext\n  exact quasi_separated_iff _\n#align quasi_separated_eq_diagonal_is_quasi_compact quasi_separated_eq_diagonal_is_quasi_compact\n\n",
 "quasi_separated_eq_affine_property_diagonal":
 "theorem quasi_separated_eq_affine_property_diagonal :\n    @quasi_separated = target_affine_locally quasi_compact.affine_property.diagonal :=\n  by\n  rw [quasi_separated_eq_diagonal_is_quasi_compact, quasi_compact_eq_affine_property]\n  exact diagonal_target_affine_locally_eq_target_affine_locally _ quasi_compact.affine_property_is_local\n#align quasi_separated_eq_affine_property_diagonal quasi_separated_eq_affine_property_diagonal\n\n",
 "quasi_separated_eq_affine_property":
 "theorem quasi_separated_eq_affine_property : @quasi_separated = target_affine_locally quasi_separated.affine_property :=\n  by rw [quasi_separated_eq_affine_property_diagonal, quasi_compact_affine_property_diagonal_eq]\n#align quasi_separated_eq_affine_property quasi_separated_eq_affine_property\n\n",
 "quasi_compact_affine_property_iff_quasi_separated_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem quasi_compact_affine_property_iff_quasi_separated_space {X Y : Scheme} [is_affine Y] (f : Â«expr âŸ¶ Â» X Y) :\n    quasi_compact.affine_property.diagonal f â†” quasi_separated_space X.carrier :=\n  by\n  delta affine_target_morphism_property.diagonal\n  rw [quasi_separated_space_iff_affine]\n  constructor\n  Â· intro H U V\n    haveI : is_affine _ := U.2\n    haveI : is_affine _ := V.2\n    let g : Â«expr âŸ¶ Â» (pullback (X.of_restrict U.1.open_embedding) (X.of_restrict V.1.open_embedding)) X :=\n      Â«expr â‰« Â» pullback.fst (X.of_restrict _)\n    have : is_open_immersion g := infer_instance\n    have e := homeomorph.of_embedding _ this.base_open.to_embedding\n    rw [is_open_immersion.range_pullback_to_base_of_left] at e\n    erw [Subtype.range_coe, Subtype.range_coe] at e\n    rw [is_compact_iff_compact_space]\n    exact @homeomorph.compact_space _ _ (H _ _) e\n  Â· introv H hâ‚ hâ‚‚\n    skip\n    let g : Â«expr âŸ¶ Â» (pullback fâ‚ fâ‚‚) X := Â«expr â‰« Â» pullback.fst fâ‚\n    have : is_open_immersion g := infer_instance\n    have e := homeomorph.of_embedding _ this.base_open.to_embedding\n    rw [is_open_immersion.range_pullback_to_base_of_left] at e\n    simp_rw [is_compact_iff_compact_space] at H\n    exact\n      @homeomorph.compact_space _ _\n        (H âŸ¨âŸ¨_, hâ‚.base_open.open_rangeâŸ©, range_is_affine_open_of_open_immersion _âŸ©\n          âŸ¨âŸ¨_, hâ‚‚.base_open.open_rangeâŸ©, range_is_affine_open_of_open_immersion _âŸ©)\n        e.symm\n#align quasi_compact_affine_property_iff_quasi_separated_space quasi_compact_affine_property_iff_quasi_separated_space\n\n",
 "quasi_compact_affine_property_diagonal_eq":
 "theorem quasi_compact_affine_property_diagonal_eq :\n    quasi_compact.affine_property.diagonal = quasi_separated.affine_property :=\n  by\n  ext\n  rw [quasi_compact_affine_property_iff_quasi_separated_space]\n  rfl\n#align quasi_compact_affine_property_diagonal_eq quasi_compact_affine_property_diagonal_eq\n\n",
 "open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\ntheorem quasi_separated.open_cover_tfae {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) :\n    TFAE\n      [quasi_separated f,\n        âˆƒ ğ’° : Scheme.open_cover.{u} Y,\n          âˆ€ i : ğ’°.J, quasi_separated (pullback.snd : Â«expr âŸ¶ Â» ((ğ’°.pullback_cover f).obj i) (ğ’°.obj i)),\n        âˆ€ (ğ’° : Scheme.open_cover.{u} Y) (i : ğ’°.J),\n          quasi_separated (pullback.snd : Â«expr âŸ¶ Â» ((ğ’°.pullback_cover f).obj i) (ğ’°.obj i)),\n        âˆ€ U : opens Y.carrier, quasi_separated (Â«expr âˆ£_ Â» f U),\n        âˆ€ {U : Scheme} (g : Â«expr âŸ¶ Â» U Y) [is_open_immersion g],\n          quasi_separated (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _),\n        âˆƒ (Î¹ : Type u)(U : Î¹ â†’ opens Y.carrier)(hU : supáµ¢ U = Â«exprâŠ¤Â»), âˆ€ i, quasi_separated (Â«expr âˆ£_ Â» f (U i))] :=\n  quasi_separated.is_local_at_target.open_cover_tfae f\n#align quasi_separated.open_cover_tfae quasi_separated.open_cover_tfae\n\n",
 "open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem quasi_separated.open_cover_iff {X Y : Scheme.{u}} (ğ’° : Scheme.open_cover.{u} Y) (f : Â«expr âŸ¶ Â» X Y) :\n    quasi_separated f â†” âˆ€ i, quasi_separated (pullback.snd : Â«expr âŸ¶ Â» (pullback f (ğ’°.map i)) _) :=\n  quasi_separated.is_local_at_target.open_cover_iff f ğ’°\n#align quasi_separated.open_cover_iff quasi_separated.open_cover_iff\n\n",
 "is_quasi_separated":
 "theorem is_affine_open.is_quasi_separated {X : Scheme} {U : opens X.carrier} (hU : is_affine_open U) :\n    is_quasi_separated (U : set X.carrier) :=\n  by\n  rw [is_quasi_separated_iff_quasi_separated_space]\n  exacts[@algebraic_geometry.quasi_separated_space_of_is_affine _ hU, U.prop]\n#align is_affine_open.is_quasi_separated is_affine_open.is_quasi_separated\n\n",
 "is_localization_basic_open_of_qcqs":
 "/-- If `U` is qcqs, then `Î“(X, D(f)) â‰ƒ Î“(X, U)_f` for every `f : Î“(X, U)`.\nThis is known as the **Qcqs lemma** in [R. Vakil, *The rising sea*][RisingSea]. -/\ntheorem is_localization_basic_open_of_qcqs {X : Scheme} {U : opens X.carrier} (hU : is_compact U.1)\n    (hU' : is_quasi_separated U.1) (f : X.presheaf.obj (op U)) :\n    is_localization.away f (X.presheaf.obj (op <| X.basic_open f)) :=\n  by\n  constructor\n  Â· rintro âŸ¨_, n, rflâŸ©\n    simp only [map_pow, subtype.coe_mk, ring_hom.algebra_map_to_algebra]\n    exact IsUnit.pow _ (RingedSpace.is_unit_res_basic_open _ f)\n  Â· intro z\n    obtain âŸ¨n, y, eâŸ© := exists_eq_pow_mul_of_is_compact_of_is_quasi_separated X U hU hU' f z\n    refine' âŸ¨âŸ¨y, _, n, rflâŸ©, _âŸ©\n    simpa only [map_pow, subtype.coe_mk, ring_hom.algebra_map_to_algebra, mul_comm z] using e.symm\n  Â· intro x y\n    rw [â† sub_eq_zero, â† map_sub, ring_hom.algebra_map_to_algebra]\n    simp_rw [â† @sub_eq_zero _ _ (x * _) (y * _), â† sub_mul]\n    generalize x - y = z\n    constructor\n    Â· intro H\n      obtain âŸ¨n, eâŸ© := exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_compact X hU _ _ H\n      refine' âŸ¨âŸ¨_, n, rflâŸ©, _âŸ©\n      simpa [mul_comm z] using e\n    Â· rintro âŸ¨âŸ¨_, n, rflâŸ©, e : z * f ^ n = 0âŸ©\n      rw [â† ((RingedSpace.is_unit_res_basic_open _ f).pow n).mul_left_inj, zero_mul, â† map_pow, â† map_mul, e, map_zero]\n#align is_localization_basic_open_of_qcqs is_localization_basic_open_of_qcqs\n\n",
 "is_local_at_target":
 "theorem quasi_separated.is_local_at_target : property_is_local_at_target @quasi_separated :=\n  quasi_separated_eq_affine_property_diagonal.symm â–¸\n    quasi_compact.affine_property_is_local.diagonal.target_affine_locally_is_local\n#align quasi_separated.is_local_at_target quasi_separated.is_local_at_target\n\n",
 "exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux (X : Scheme) (S : X.affine_opens)\n    (Uâ‚ Uâ‚‚ : opens X.carrier) {nâ‚ nâ‚‚ : â„•} {yâ‚ : X.presheaf.obj (op Uâ‚)} {yâ‚‚ : X.presheaf.obj (op Uâ‚‚)}\n    {f : X.presheaf.obj (op <| Â«expr âŠ” Â» Uâ‚ Uâ‚‚)} {x : X.presheaf.obj (op <| X.basic_open f)} (hâ‚ : S.1 â‰¤ Uâ‚)\n    (hâ‚‚ : S.1 â‰¤ Uâ‚‚)\n    (eâ‚ :\n      X.presheaf.map (hom_of_le <| X.basic_open_le (X.presheaf.map (hom_of_le le_sup_left).op f) : Â«expr âŸ¶ Â» _ Uâ‚).op\n          yâ‚ =\n        X.presheaf.map\n              (hom_of_le\n                  (by\n                    erw [X.basic_open_res]\n                    exact inf_le_left)).op\n              (X.presheaf.map (hom_of_le le_sup_left).op f) ^\n            nâ‚ *\n          (X.presheaf.map\n              (hom_of_le\n                  (by\n                    erw [X.basic_open_res]\n                    exact inf_le_right)).op)\n            x)\n    (eâ‚‚ :\n      X.presheaf.map (hom_of_le <| X.basic_open_le (X.presheaf.map (hom_of_le le_sup_right).op f) : Â«expr âŸ¶ Â» _ Uâ‚‚).op\n          yâ‚‚ =\n        X.presheaf.map\n              (hom_of_le\n                  (by\n                    rw [X.basic_open_res]\n                    exact inf_le_left)).op\n              (X.presheaf.map (hom_of_le le_sup_right).op f) ^\n            nâ‚‚ *\n          (X.presheaf.map\n              (hom_of_le\n                  (by\n                    rw [X.basic_open_res]\n                    exact inf_le_right)).op)\n            x) :\n    âˆƒ n : â„•,\n      X.presheaf.map (hom_of_le <| hâ‚).op (X.presheaf.map (hom_of_le le_sup_left).op f ^ (n + nâ‚‚) * yâ‚) =\n        X.presheaf.map (hom_of_le <| hâ‚‚).op (X.presheaf.map (hom_of_le le_sup_right).op f ^ (n + nâ‚) * yâ‚‚) :=\n  by\n  have := is_localization_basic_open S.2 (X.presheaf.map (hom_of_le <| le_trans hâ‚ le_sup_left).op f)\n  obtain âŸ¨âŸ¨_, n, rflâŸ©, eâŸ© :=\n    (@is_localization.eq_iff_exists _ _ _ _ _ _ this\n          (X.presheaf.map (hom_of_le <| hâ‚).op (X.presheaf.map (hom_of_le le_sup_left).op f ^ nâ‚‚ * yâ‚))\n          (X.presheaf.map (hom_of_le <| hâ‚‚).op (X.presheaf.map (hom_of_le le_sup_right).op f ^ nâ‚ * yâ‚‚))).mp\n      _\n  swap\n  Â· simp only [map_pow, ring_hom.algebra_map_to_algebra, map_mul, â† comp_apply, â† functor.map_comp, â† op_comp,\n      hom_of_le_comp]\n    have hâ‚ƒ : X.basic_open ((X.presheaf.map (hom_of_le (hâ‚.trans le_sup_left)).op) f) â‰¤ S.val := by\n      simpa only [X.basic_open_res] using inf_le_left\n    trans\n      X.presheaf.map (hom_of_le <| hâ‚ƒ.trans <| hâ‚.trans le_sup_left).op f ^ (nâ‚‚ + nâ‚) *\n        X.presheaf.map (hom_of_le <| (X.basic_open_res f _).trans_le inf_le_right).op x\n    Â· rw [pow_add, mul_assoc]\n      congr 1\n      convert congr_arg (X.presheaf.map (hom_of_le _).op) eâ‚\n      Â· simp only [map_pow, map_mul, â† comp_apply, â† functor.map_comp, â† op_comp]\n        congr\n      Â· simp only [map_pow, map_mul, â† comp_apply, â† functor.map_comp, â† op_comp]\n        congr\n      Â· rw [X.basic_open_res, X.basic_open_res]\n        rintro x âŸ¨Hâ‚, Hâ‚‚âŸ©\n        exact âŸ¨hâ‚ Hâ‚, Hâ‚‚âŸ©\n    Â· rw [add_comm, pow_add, mul_assoc]\n      congr 1\n      convert congr_arg (X.presheaf.map (hom_of_le _).op) eâ‚‚.symm\n      Â· simp only [map_pow, map_mul, â† comp_apply, â† functor.map_comp, â† op_comp]\n        congr\n      Â· simp only [map_pow, map_mul, â† comp_apply, â† functor.map_comp, â† op_comp]\n        congr\n      Â· simp only [X.basic_open_res]\n        rintro x âŸ¨Hâ‚, Hâ‚‚âŸ©\n        exact âŸ¨hâ‚‚ Hâ‚, Hâ‚‚âŸ©\n  use n\n  conv_lhs at e => rw [mul_comm]\n  conv_rhs at e => rw [mul_comm]\n  simp only [pow_add, map_pow, map_mul, â† comp_apply, â† mul_assoc, â† functor.map_comp, subtype.coe_mk] at eâŠ¢\n  convert e\n#align\n  exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux\n\n",
 "exists_eq_pow_mul_of_is_compact_of_is_quasi_separated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr |_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr |_ Â» -/\ntheorem exists_eq_pow_mul_of_is_compact_of_is_quasi_separated (X : Scheme) (U : opens X.carrier) (hU : is_compact U.1)\n    (hU' : is_quasi_separated U.1) (f : X.presheaf.obj (op U)) (x : X.presheaf.obj (op <| X.basic_open f)) :\n    âˆƒ (n : â„•)(y : X.presheaf.obj (op U)), Â«expr |_ Â» y (X.basic_open f) = Â«expr |_ Â» f (X.basic_open f) ^ n * x :=\n  by\n  delta Top.presheaf.restrict_open Top.presheaf.restrict\n  revert hU' f x\n  apply compact_open_induction_on U hU\n  Â· intro hU' f x\n    use 0, f\n    refine' @subsingleton.elim (CommRing.subsingleton_of_is_terminal (X.sheaf.is_terminal_of_eq_empty _)) _ _\n    erw [eq_bot_iff]\n    exact X.basic_open_le f\n  Â· -- Given `f : ğ’ª(S âˆª U), x : ğ’ª(X_f)`, we need to show that `f ^ n * x` is the restriction of\n    -- some `y : ğ’ª(S âˆª U)` for some `n : â„•`.\n    intro S hS U hU hSU f x\n    -- We know that such `yâ‚, nâ‚` exists on `S` by the induction hypothesis.\n    obtain âŸ¨nâ‚, yâ‚, hyâ‚âŸ© :=\n      hU (hSU.of_subset <| Set.subset_union_left _ _) (X.presheaf.map (hom_of_le le_sup_left).op f)\n        (X.presheaf.map (hom_of_le _).op x)\n    swap\n    Â· rw [X.basic_open_res]\n      exact inf_le_right\n    -- We know that such `yâ‚‚, nâ‚‚` exists on `U` since `U` is affine.\n    obtain âŸ¨nâ‚‚, yâ‚‚, hyâ‚‚âŸ© :=\n      exists_eq_pow_mul_of_is_affine_open X _ U.2 (X.presheaf.map (hom_of_le le_sup_right).op f)\n        (X.presheaf.map (hom_of_le _).op x)\n    delta Top.presheaf.restrict_open Top.presheaf.restrict at hyâ‚‚\n    swap\n    Â· rw [X.basic_open_res]\n      exact inf_le_right\n    -- Since `S âˆª U` is quasi-separated, `S âˆ© U` can be covered by finite affine opens.\n    obtain âŸ¨s, hs', hsâŸ© :=\n      (is_compact_open_iff_eq_finset_affine_union _).mp\n        âŸ¨hSU _ _ (Set.subset_union_left _ _) S.2 hS (Set.subset_union_right _ _) U.1.2 U.2.is_compact,\n          (Â«expr âŠ“ Â» S U.1).2âŸ©\n    haveI := hs'.to_subtype\n    cases nonempty_fintype s\n    replace hs : Â«expr âŠ“ Â» S U.1 = supáµ¢ fun i : s => (i : opens X.carrier) :=\n      by\n      ext1\n      simpa using hs\n    have hsâ‚ : âˆ€ i : s, i.1.1 â‰¤ S := by\n      intro i\n      change (i : opens X.carrier) â‰¤ S\n      refine' le_trans _ inf_le_left\n      use U.1\n      erw [hs]\n      exact le_supáµ¢ _ _\n    have hsâ‚‚ : âˆ€ i : s, i.1.1 â‰¤ U.1 := by\n      intro i\n      change (i : opens X.carrier) â‰¤ U\n      refine' le_trans _ inf_le_right\n      use S\n      erw [hs]\n      exact le_supáµ¢ _ _\n    -- On each affine open in the intersection, we have `f ^ (n + nâ‚‚) * yâ‚ = f ^ (n + nâ‚) * yâ‚‚`\n    -- for some `n` since `f ^ nâ‚‚ * yâ‚ = f ^ (nâ‚ + nâ‚‚) * x = f ^ nâ‚ * yâ‚‚` on `X_f`.\n    have :\n      âˆ€ i : s,\n        âˆƒ n : â„•,\n          X.presheaf.map (hom_of_le <| hsâ‚ i).op (X.presheaf.map (hom_of_le le_sup_left).op f ^ (n + nâ‚‚) * yâ‚) =\n            X.presheaf.map (hom_of_le <| hsâ‚‚ i).op (X.presheaf.map (hom_of_le le_sup_right).op f ^ (n + nâ‚) * yâ‚‚) :=\n      by\n      intro i\n      exact exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux X i.1 S U (hsâ‚ i) (hsâ‚‚ i) hyâ‚ hyâ‚‚\n    choose n hn using this\n    -- We can thus choose a big enough `n` such that `f ^ (n + nâ‚‚) * yâ‚ = f ^ (n + nâ‚) * yâ‚‚`\n    -- on `S âˆ© U`.\n    have :\n      X.presheaf.map (hom_of_le <| inf_le_left).op\n          (X.presheaf.map (hom_of_le le_sup_left).op f ^ (finset.univ.sup n + nâ‚‚) * yâ‚) =\n        X.presheaf.map (hom_of_le <| inf_le_right).op\n          (X.presheaf.map (hom_of_le le_sup_right).op f ^ (finset.univ.sup n + nâ‚) * yâ‚‚) :=\n      by\n      fapply X.sheaf.eq_of_locally_eq' fun i : s => i.1.1\n      Â· refine' fun i => hom_of_le _\n        erw [hs]\n        exact le_supáµ¢ _ _\n      Â· exact le_of_eq hs\n      Â· intro i\n        replace hn :=\n          congr_arg\n            (fun x => X.presheaf.map (hom_of_le (le_trans (hsâ‚ i) le_sup_left)).op f ^ (finset.univ.sup n - n i) * x)\n            (hn i)\n        dsimp only at hn\n        delta Scheme.sheaf SheafedSpace.sheaf\n        simp only [â† map_pow, map_mul, â† comp_apply, â† functor.map_comp, â† op_comp, â† mul_assoc] at hnâŠ¢\n        erw [â† map_mul, â† map_mul] at hn\n        rw [â† pow_add, â† pow_add, â† add_assoc, â† add_assoc, tsub_add_cancel_of_le] at hn\n        convert hn\n        exact finset.le_sup (finset.mem_univ _)\n    use finset.univ.sup n + nâ‚ + nâ‚‚\n    -- By the sheaf condition, since `f ^ (n + nâ‚‚) * yâ‚ = f ^ (n + nâ‚) * yâ‚‚`, it can be glued into\n    -- the desired section on `S âˆª U`.\n    use (X.sheaf.obj_sup_iso_prod_eq_locus S U.1).inv âŸ¨âŸ¨_ * _, _ * _âŸ©, thisâŸ©\n    refine'\n      X.sheaf.eq_of_locally_eqâ‚‚ (hom_of_le (_ : X.basic_open (X.presheaf.map (hom_of_le le_sup_left).op f) â‰¤ _))\n        (hom_of_le (_ : X.basic_open (X.presheaf.map (hom_of_le le_sup_right).op f) â‰¤ _)) _ _ _ _ _\n    Â· rw [X.basic_open_res]\n      exact inf_le_right\n    Â· rw [X.basic_open_res]\n      exact inf_le_right\n    Â· rw [X.basic_open_res, X.basic_open_res]\n      erw [â† inf_sup_right]\n      refine' le_inf_iff.mpr âŸ¨X.basic_open_le f, le_of_eq rflâŸ©\n    Â· convert\n        congr_arg (X.presheaf.map (hom_of_le _).op)\n          (X.sheaf.obj_sup_iso_prod_eq_locus_inv_fst S U.1 âŸ¨âŸ¨_ * _, _ * _âŸ©, thisâŸ©) using\n        1\n      Â· delta Scheme.sheaf SheafedSpace.sheaf\n        simp only [â† comp_apply (X.presheaf.map _) (X.presheaf.map _), â† functor.map_comp, â† op_comp]\n        congr\n      Â· delta Scheme.sheaf SheafedSpace.sheaf\n        simp only [map_pow, map_mul, â† comp_apply, â† functor.map_comp, â† op_comp, mul_assoc, pow_add]\n        erw [hyâ‚]\n        congr 1\n        rw [â† mul_assoc, â† mul_assoc]\n        congr 1\n        rw [mul_comm, â† comp_apply, â† functor.map_comp]\n        congr\n    Â· convert\n        congr_arg (X.presheaf.map (hom_of_le _).op)\n          (X.sheaf.obj_sup_iso_prod_eq_locus_inv_snd S U.1 âŸ¨âŸ¨_ * _, _ * _âŸ©, thisâŸ©) using\n        1\n      Â· delta Scheme.sheaf SheafedSpace.sheaf\n        simp only [â† comp_apply (X.presheaf.map _) (X.presheaf.map _), â† functor.map_comp, â† op_comp]\n        congr\n      Â· delta Scheme.sheaf SheafedSpace.sheaf\n        simp only [map_pow, map_mul, â† comp_apply, â† functor.map_comp, â† op_comp, mul_assoc, pow_add]\n        erw [hyâ‚‚]\n        rw [â† comp_apply, â† functor.map_comp]\n        congr\n#align exists_eq_pow_mul_of_is_compact_of_is_quasi_separated exists_eq_pow_mul_of_is_compact_of_is_quasi_separated\n\n",
 "exists_eq_pow_mul_of_is_affine_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr |_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr |_ Â» -/\ntheorem exists_eq_pow_mul_of_is_affine_open (X : Scheme) (U : opens X.carrier) (hU : is_affine_open U)\n    (f : X.presheaf.obj (op U)) (x : X.presheaf.obj (op <| X.basic_open f)) :\n    âˆƒ (n : â„•)(y : X.presheaf.obj (op U)), Â«expr |_ Â» y (X.basic_open f) = Â«expr |_ Â» f (X.basic_open f) ^ n * x :=\n  by\n  have := (is_localization_basic_open hU f).2\n  obtain âŸ¨âŸ¨y, _, n, rflâŸ©, dâŸ© := this x\n  use n, y\n  delta Top.presheaf.restrict_open Top.presheaf.restrict\n  simpa [mul_comm x] using d.symm\n#align exists_eq_pow_mul_of_is_affine_open exists_eq_pow_mul_of_is_affine_open\n\n",
 "affine_property_is_local":
 "theorem quasi_separated.affine_property_is_local : quasi_separated.affine_property.is_local :=\n  quasi_compact_affine_property_diagonal_eq â–¸ quasi_compact.affine_property_is_local.diagonal\n#align quasi_separated.affine_property_is_local quasi_separated.affine_property_is_local\n\n",
 "affine_open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem quasi_separated.affine_open_cover_tfae {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) :\n    TFAE\n      [quasi_separated f,\n        âˆƒ (ğ’° : Scheme.open_cover.{u} Y)(_ : âˆ€ i, is_affine (ğ’°.obj i)),\n          âˆ€ i : ğ’°.J, quasi_separated_space (pullback f (ğ’°.map i)).carrier,\n        âˆ€ (ğ’° : Scheme.open_cover.{u} Y) [âˆ€ i, is_affine (ğ’°.obj i)] (i : ğ’°.J),\n          quasi_separated_space (pullback f (ğ’°.map i)).carrier,\n        âˆ€ {U : Scheme} (g : Â«expr âŸ¶ Â» U Y) [is_affine U] [is_open_immersion g],\n          quasi_separated_space (pullback f g).carrier,\n        âˆƒ (ğ’° : Scheme.open_cover.{u} Y)(_ : âˆ€ i, is_affine (ğ’°.obj i))(ğ’°' :\n          âˆ€ i : ğ’°.J, Scheme.open_cover.{u} (pullback f (ğ’°.map i)))(_ : âˆ€ i j, is_affine ((ğ’°' i).obj j)),\n          âˆ€ (i : ğ’°.J) (j k : (ğ’°' i).J), compact_space (pullback ((ğ’°' i).map j) ((ğ’°' i).map k)).carrier] :=\n  by\n  have := quasi_compact.affine_property_is_local.diagonal_affine_open_cover_tfae f\n  simp_rw [â† quasi_compact_eq_affine_property, â† quasi_separated_eq_diagonal_is_quasi_compact,\n    quasi_compact_affine_property_diagonal_eq] at this\n  exact this\n#align quasi_separated.affine_open_cover_tfae quasi_separated.affine_open_cover_tfae\n\n",
 "affine_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem quasi_separated.affine_open_cover_iff {X Y : Scheme.{u}} (ğ’° : Scheme.open_cover.{u} Y)\n    [âˆ€ i, is_affine (ğ’°.obj i)] (f : Â«expr âŸ¶ Â» X Y) :\n    quasi_separated f â†” âˆ€ i, quasi_separated_space (pullback f (ğ’°.map i)).carrier :=\n  by\n  rw [quasi_separated_eq_affine_property, quasi_separated.affine_property_is_local.affine_open_cover_iff f ğ’°]\n  rfl\n#align quasi_separated.affine_open_cover_iff quasi_separated.affine_open_cover_iff\n\n"}