{"quasi_separated_stable_under_composition":
 "theorem quasi_separated_stable_under_composition : morphism_property.stable_under_composition @quasi_separated :=\n  quasi_separated_eq_diagonal_is_quasi_compact.symm ▸\n    quasi_compact_stable_under_composition.diagonal quasi_compact_respects_iso quasi_compact_stable_under_base_change\n#align quasi_separated_stable_under_composition quasi_separated_stable_under_composition\n\n",
 "quasi_separated_stable_under_base_change":
 "theorem quasi_separated_stable_under_base_change : morphism_property.stable_under_base_change @quasi_separated :=\n  quasi_separated_eq_diagonal_is_quasi_compact.symm ▸\n    quasi_compact_stable_under_base_change.diagonal quasi_compact_respects_iso\n#align quasi_separated_stable_under_base_change quasi_separated_stable_under_base_change\n\n",
 "quasi_separated_space_of_quasi_separated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem quasi_separated_space_of_quasi_separated {X Y : Scheme} (f : «expr ⟶ » X Y)\n    [hY : quasi_separated_space Y.carrier] [quasi_separated f] : quasi_separated_space X.carrier :=\n  by\n  rw [quasi_separated_space_iff_quasi_separated] at hY⊢\n  have : «expr ≫ » f (terminal.from Y) = terminal.from X := terminal_is_terminal.hom_ext _ _\n  rw [← this]\n  skip; infer_instance\n#align quasi_separated_space_of_quasi_separated quasi_separated_space_of_quasi_separated\n\n",
 "quasi_separated_space_iff_quasi_separated":
 "theorem quasi_separated_space_iff_quasi_separated (X : Scheme) :\n    quasi_separated_space X.carrier ↔ quasi_separated (terminal.from X) :=\n  (quasi_separated_over_affine_iff _).symm\n#align quasi_separated_space_iff_quasi_separated quasi_separated_space_iff_quasi_separated\n\n",
 "quasi_separated_space_iff_affine":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem quasi_separated_space_iff_affine (X : Scheme) :\n    quasi_separated_space X.carrier ↔ ∀ U V : X.affine_opens, is_compact (U ∩ V : set X.carrier) :=\n  by\n  rw [quasi_separated_space_iff]\n  constructor\n  · intro H U V\n    exact H U V U.1.2 U.2.is_compact V.1.2 V.2.is_compact\n  · intro H\n    suffices\n      ∀ (U : opens X.carrier) (hU : is_compact U.1) (V : opens X.carrier) (hV : is_compact V.1),\n        is_compact («expr ⊓ » U V).1\n      by\n      intro U V hU hU' hV hV'\n      exact this ⟨U, hU⟩ hU' ⟨V, hV⟩ hV'\n    intro U hU V hV\n    apply compact_open_induction_on V hV\n    · simp\n    · intro S hS V hV\n      change is_compact (U.1 ∩ (S.1 ∪ V.1))\n      rw [Set.inter_union_distrib_left]\n      apply hV.union\n      clear hV\n      apply compact_open_induction_on U hU\n      · simp\n      · intro S hS W hW\n        change is_compact ((S.1 ∪ W.1) ∩ V.1)\n        rw [Set.union_inter_distrib_right]\n        apply hW.union\n        apply H\n#align quasi_separated_space_iff_affine quasi_separated_space_iff_affine\n\n",
 "quasi_separated_respects_iso":
 "theorem quasi_separated_respects_iso : morphism_property.respects_iso @quasi_separated :=\n  quasi_separated_eq_diagonal_is_quasi_compact.symm ▸ quasi_compact_respects_iso.diagonal\n#align quasi_separated_respects_iso quasi_separated_respects_iso\n\n",
 "quasi_separated_over_affine_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem quasi_separated_over_affine_iff {X Y : Scheme} (f : «expr ⟶ » X Y) [is_affine Y] :\n    quasi_separated f ↔ quasi_separated_space X.carrier := by\n  rw [quasi_separated_eq_affine_property, quasi_separated.affine_property_is_local.affine_target_iff f,\n    quasi_separated.affine_property]\n#align quasi_separated_over_affine_iff quasi_separated_over_affine_iff\n\n",
 "quasi_separated_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem quasi_separated_of_comp {X Y Z : Scheme} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z)\n    [H : quasi_separated («expr ≫ » f g)] : quasi_separated f :=\n  by\n  rw [(quasi_separated.affine_open_cover_tfae f).out 0 1]\n  rw [(quasi_separated.affine_open_cover_tfae («expr ≫ » f g)).out 0 2] at H\n  use (Z.affine_cover.pullback_cover g).bind fun x => Scheme.affine_cover _\n  constructor;\n  · intro i\n    dsimp\n    infer_instance\n  rintro ⟨i, j⟩; dsimp at *\n  specialize H _ i\n  refine' @quasi_separated_space_of_quasi_separated _ H _\n  ·\n    exact\n      «expr ≫ » (pullback.map _ _ _ _ ((«expr𝟙») _) _ _ (by simp) (category.comp_id _))\n        (pullback_right_pullback_fst_iso g (Z.affine_cover.map i) f).hom\n  · apply algebraic_geometry.quasi_separated_of_mono\n#align quasi_separated_of_comp quasi_separated_of_comp\n\n",
 "quasi_separated_eq_diagonal_is_quasi_compact":
 "theorem quasi_separated_eq_diagonal_is_quasi_compact : @quasi_separated = morphism_property.diagonal @quasi_compact :=\n  by\n  ext\n  exact quasi_separated_iff _\n#align quasi_separated_eq_diagonal_is_quasi_compact quasi_separated_eq_diagonal_is_quasi_compact\n\n",
 "quasi_separated_eq_affine_property_diagonal":
 "theorem quasi_separated_eq_affine_property_diagonal :\n    @quasi_separated = target_affine_locally quasi_compact.affine_property.diagonal :=\n  by\n  rw [quasi_separated_eq_diagonal_is_quasi_compact, quasi_compact_eq_affine_property]\n  exact diagonal_target_affine_locally_eq_target_affine_locally _ quasi_compact.affine_property_is_local\n#align quasi_separated_eq_affine_property_diagonal quasi_separated_eq_affine_property_diagonal\n\n",
 "quasi_separated_eq_affine_property":
 "theorem quasi_separated_eq_affine_property : @quasi_separated = target_affine_locally quasi_separated.affine_property :=\n  by rw [quasi_separated_eq_affine_property_diagonal, quasi_compact_affine_property_diagonal_eq]\n#align quasi_separated_eq_affine_property quasi_separated_eq_affine_property\n\n",
 "quasi_compact_affine_property_iff_quasi_separated_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem quasi_compact_affine_property_iff_quasi_separated_space {X Y : Scheme} [is_affine Y] (f : «expr ⟶ » X Y) :\n    quasi_compact.affine_property.diagonal f ↔ quasi_separated_space X.carrier :=\n  by\n  delta affine_target_morphism_property.diagonal\n  rw [quasi_separated_space_iff_affine]\n  constructor\n  · intro H U V\n    haveI : is_affine _ := U.2\n    haveI : is_affine _ := V.2\n    let g : «expr ⟶ » (pullback (X.of_restrict U.1.open_embedding) (X.of_restrict V.1.open_embedding)) X :=\n      «expr ≫ » pullback.fst (X.of_restrict _)\n    have : is_open_immersion g := infer_instance\n    have e := homeomorph.of_embedding _ this.base_open.to_embedding\n    rw [is_open_immersion.range_pullback_to_base_of_left] at e\n    erw [Subtype.range_coe, Subtype.range_coe] at e\n    rw [is_compact_iff_compact_space]\n    exact @homeomorph.compact_space _ _ (H _ _) e\n  · introv H h₁ h₂\n    skip\n    let g : «expr ⟶ » (pullback f₁ f₂) X := «expr ≫ » pullback.fst f₁\n    have : is_open_immersion g := infer_instance\n    have e := homeomorph.of_embedding _ this.base_open.to_embedding\n    rw [is_open_immersion.range_pullback_to_base_of_left] at e\n    simp_rw [is_compact_iff_compact_space] at H\n    exact\n      @homeomorph.compact_space _ _\n        (H ⟨⟨_, h₁.base_open.open_range⟩, range_is_affine_open_of_open_immersion _⟩\n          ⟨⟨_, h₂.base_open.open_range⟩, range_is_affine_open_of_open_immersion _⟩)\n        e.symm\n#align quasi_compact_affine_property_iff_quasi_separated_space quasi_compact_affine_property_iff_quasi_separated_space\n\n",
 "quasi_compact_affine_property_diagonal_eq":
 "theorem quasi_compact_affine_property_diagonal_eq :\n    quasi_compact.affine_property.diagonal = quasi_separated.affine_property :=\n  by\n  ext\n  rw [quasi_compact_affine_property_iff_quasi_separated_space]\n  rfl\n#align quasi_compact_affine_property_diagonal_eq quasi_compact_affine_property_diagonal_eq\n\n",
 "open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\ntheorem quasi_separated.open_cover_tfae {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) :\n    TFAE\n      [quasi_separated f,\n        ∃ 𝒰 : Scheme.open_cover.{u} Y,\n          ∀ i : 𝒰.J, quasi_separated (pullback.snd : «expr ⟶ » ((𝒰.pullback_cover f).obj i) (𝒰.obj i)),\n        ∀ (𝒰 : Scheme.open_cover.{u} Y) (i : 𝒰.J),\n          quasi_separated (pullback.snd : «expr ⟶ » ((𝒰.pullback_cover f).obj i) (𝒰.obj i)),\n        ∀ U : opens Y.carrier, quasi_separated («expr ∣_ » f U),\n        ∀ {U : Scheme} (g : «expr ⟶ » U Y) [is_open_immersion g],\n          quasi_separated (pullback.snd : «expr ⟶ » (pullback f g) _),\n        ∃ (ι : Type u)(U : ι → opens Y.carrier)(hU : supᵢ U = «expr⊤»), ∀ i, quasi_separated («expr ∣_ » f (U i))] :=\n  quasi_separated.is_local_at_target.open_cover_tfae f\n#align quasi_separated.open_cover_tfae quasi_separated.open_cover_tfae\n\n",
 "open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem quasi_separated.open_cover_iff {X Y : Scheme.{u}} (𝒰 : Scheme.open_cover.{u} Y) (f : «expr ⟶ » X Y) :\n    quasi_separated f ↔ ∀ i, quasi_separated (pullback.snd : «expr ⟶ » (pullback f (𝒰.map i)) _) :=\n  quasi_separated.is_local_at_target.open_cover_iff f 𝒰\n#align quasi_separated.open_cover_iff quasi_separated.open_cover_iff\n\n",
 "is_quasi_separated":
 "theorem is_affine_open.is_quasi_separated {X : Scheme} {U : opens X.carrier} (hU : is_affine_open U) :\n    is_quasi_separated (U : set X.carrier) :=\n  by\n  rw [is_quasi_separated_iff_quasi_separated_space]\n  exacts[@algebraic_geometry.quasi_separated_space_of_is_affine _ hU, U.prop]\n#align is_affine_open.is_quasi_separated is_affine_open.is_quasi_separated\n\n",
 "is_localization_basic_open_of_qcqs":
 "/-- If `U` is qcqs, then `Γ(X, D(f)) ≃ Γ(X, U)_f` for every `f : Γ(X, U)`.\nThis is known as the **Qcqs lemma** in [R. Vakil, *The rising sea*][RisingSea]. -/\ntheorem is_localization_basic_open_of_qcqs {X : Scheme} {U : opens X.carrier} (hU : is_compact U.1)\n    (hU' : is_quasi_separated U.1) (f : X.presheaf.obj (op U)) :\n    is_localization.away f (X.presheaf.obj (op <| X.basic_open f)) :=\n  by\n  constructor\n  · rintro ⟨_, n, rfl⟩\n    simp only [map_pow, subtype.coe_mk, ring_hom.algebra_map_to_algebra]\n    exact IsUnit.pow _ (RingedSpace.is_unit_res_basic_open _ f)\n  · intro z\n    obtain ⟨n, y, e⟩ := exists_eq_pow_mul_of_is_compact_of_is_quasi_separated X U hU hU' f z\n    refine' ⟨⟨y, _, n, rfl⟩, _⟩\n    simpa only [map_pow, subtype.coe_mk, ring_hom.algebra_map_to_algebra, mul_comm z] using e.symm\n  · intro x y\n    rw [← sub_eq_zero, ← map_sub, ring_hom.algebra_map_to_algebra]\n    simp_rw [← @sub_eq_zero _ _ (x * _) (y * _), ← sub_mul]\n    generalize x - y = z\n    constructor\n    · intro H\n      obtain ⟨n, e⟩ := exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_compact X hU _ _ H\n      refine' ⟨⟨_, n, rfl⟩, _⟩\n      simpa [mul_comm z] using e\n    · rintro ⟨⟨_, n, rfl⟩, e : z * f ^ n = 0⟩\n      rw [← ((RingedSpace.is_unit_res_basic_open _ f).pow n).mul_left_inj, zero_mul, ← map_pow, ← map_mul, e, map_zero]\n#align is_localization_basic_open_of_qcqs is_localization_basic_open_of_qcqs\n\n",
 "is_local_at_target":
 "theorem quasi_separated.is_local_at_target : property_is_local_at_target @quasi_separated :=\n  quasi_separated_eq_affine_property_diagonal.symm ▸\n    quasi_compact.affine_property_is_local.diagonal.target_affine_locally_is_local\n#align quasi_separated.is_local_at_target quasi_separated.is_local_at_target\n\n",
 "exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux (X : Scheme) (S : X.affine_opens)\n    (U₁ U₂ : opens X.carrier) {n₁ n₂ : ℕ} {y₁ : X.presheaf.obj (op U₁)} {y₂ : X.presheaf.obj (op U₂)}\n    {f : X.presheaf.obj (op <| «expr ⊔ » U₁ U₂)} {x : X.presheaf.obj (op <| X.basic_open f)} (h₁ : S.1 ≤ U₁)\n    (h₂ : S.1 ≤ U₂)\n    (e₁ :\n      X.presheaf.map (hom_of_le <| X.basic_open_le (X.presheaf.map (hom_of_le le_sup_left).op f) : «expr ⟶ » _ U₁).op\n          y₁ =\n        X.presheaf.map\n              (hom_of_le\n                  (by\n                    erw [X.basic_open_res]\n                    exact inf_le_left)).op\n              (X.presheaf.map (hom_of_le le_sup_left).op f) ^\n            n₁ *\n          (X.presheaf.map\n              (hom_of_le\n                  (by\n                    erw [X.basic_open_res]\n                    exact inf_le_right)).op)\n            x)\n    (e₂ :\n      X.presheaf.map (hom_of_le <| X.basic_open_le (X.presheaf.map (hom_of_le le_sup_right).op f) : «expr ⟶ » _ U₂).op\n          y₂ =\n        X.presheaf.map\n              (hom_of_le\n                  (by\n                    rw [X.basic_open_res]\n                    exact inf_le_left)).op\n              (X.presheaf.map (hom_of_le le_sup_right).op f) ^\n            n₂ *\n          (X.presheaf.map\n              (hom_of_le\n                  (by\n                    rw [X.basic_open_res]\n                    exact inf_le_right)).op)\n            x) :\n    ∃ n : ℕ,\n      X.presheaf.map (hom_of_le <| h₁).op (X.presheaf.map (hom_of_le le_sup_left).op f ^ (n + n₂) * y₁) =\n        X.presheaf.map (hom_of_le <| h₂).op (X.presheaf.map (hom_of_le le_sup_right).op f ^ (n + n₁) * y₂) :=\n  by\n  have := is_localization_basic_open S.2 (X.presheaf.map (hom_of_le <| le_trans h₁ le_sup_left).op f)\n  obtain ⟨⟨_, n, rfl⟩, e⟩ :=\n    (@is_localization.eq_iff_exists _ _ _ _ _ _ this\n          (X.presheaf.map (hom_of_le <| h₁).op (X.presheaf.map (hom_of_le le_sup_left).op f ^ n₂ * y₁))\n          (X.presheaf.map (hom_of_le <| h₂).op (X.presheaf.map (hom_of_le le_sup_right).op f ^ n₁ * y₂))).mp\n      _\n  swap\n  · simp only [map_pow, ring_hom.algebra_map_to_algebra, map_mul, ← comp_apply, ← functor.map_comp, ← op_comp,\n      hom_of_le_comp]\n    have h₃ : X.basic_open ((X.presheaf.map (hom_of_le (h₁.trans le_sup_left)).op) f) ≤ S.val := by\n      simpa only [X.basic_open_res] using inf_le_left\n    trans\n      X.presheaf.map (hom_of_le <| h₃.trans <| h₁.trans le_sup_left).op f ^ (n₂ + n₁) *\n        X.presheaf.map (hom_of_le <| (X.basic_open_res f _).trans_le inf_le_right).op x\n    · rw [pow_add, mul_assoc]\n      congr 1\n      convert congr_arg (X.presheaf.map (hom_of_le _).op) e₁\n      · simp only [map_pow, map_mul, ← comp_apply, ← functor.map_comp, ← op_comp]\n        congr\n      · simp only [map_pow, map_mul, ← comp_apply, ← functor.map_comp, ← op_comp]\n        congr\n      · rw [X.basic_open_res, X.basic_open_res]\n        rintro x ⟨H₁, H₂⟩\n        exact ⟨h₁ H₁, H₂⟩\n    · rw [add_comm, pow_add, mul_assoc]\n      congr 1\n      convert congr_arg (X.presheaf.map (hom_of_le _).op) e₂.symm\n      · simp only [map_pow, map_mul, ← comp_apply, ← functor.map_comp, ← op_comp]\n        congr\n      · simp only [map_pow, map_mul, ← comp_apply, ← functor.map_comp, ← op_comp]\n        congr\n      · simp only [X.basic_open_res]\n        rintro x ⟨H₁, H₂⟩\n        exact ⟨h₂ H₁, H₂⟩\n  use n\n  conv_lhs at e => rw [mul_comm]\n  conv_rhs at e => rw [mul_comm]\n  simp only [pow_add, map_pow, map_mul, ← comp_apply, ← mul_assoc, ← functor.map_comp, subtype.coe_mk] at e⊢\n  convert e\n#align\n  exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux\n\n",
 "exists_eq_pow_mul_of_is_compact_of_is_quasi_separated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr |_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr |_ » -/\ntheorem exists_eq_pow_mul_of_is_compact_of_is_quasi_separated (X : Scheme) (U : opens X.carrier) (hU : is_compact U.1)\n    (hU' : is_quasi_separated U.1) (f : X.presheaf.obj (op U)) (x : X.presheaf.obj (op <| X.basic_open f)) :\n    ∃ (n : ℕ)(y : X.presheaf.obj (op U)), «expr |_ » y (X.basic_open f) = «expr |_ » f (X.basic_open f) ^ n * x :=\n  by\n  delta Top.presheaf.restrict_open Top.presheaf.restrict\n  revert hU' f x\n  apply compact_open_induction_on U hU\n  · intro hU' f x\n    use 0, f\n    refine' @subsingleton.elim (CommRing.subsingleton_of_is_terminal (X.sheaf.is_terminal_of_eq_empty _)) _ _\n    erw [eq_bot_iff]\n    exact X.basic_open_le f\n  · -- Given `f : 𝒪(S ∪ U), x : 𝒪(X_f)`, we need to show that `f ^ n * x` is the restriction of\n    -- some `y : 𝒪(S ∪ U)` for some `n : ℕ`.\n    intro S hS U hU hSU f x\n    -- We know that such `y₁, n₁` exists on `S` by the induction hypothesis.\n    obtain ⟨n₁, y₁, hy₁⟩ :=\n      hU (hSU.of_subset <| Set.subset_union_left _ _) (X.presheaf.map (hom_of_le le_sup_left).op f)\n        (X.presheaf.map (hom_of_le _).op x)\n    swap\n    · rw [X.basic_open_res]\n      exact inf_le_right\n    -- We know that such `y₂, n₂` exists on `U` since `U` is affine.\n    obtain ⟨n₂, y₂, hy₂⟩ :=\n      exists_eq_pow_mul_of_is_affine_open X _ U.2 (X.presheaf.map (hom_of_le le_sup_right).op f)\n        (X.presheaf.map (hom_of_le _).op x)\n    delta Top.presheaf.restrict_open Top.presheaf.restrict at hy₂\n    swap\n    · rw [X.basic_open_res]\n      exact inf_le_right\n    -- Since `S ∪ U` is quasi-separated, `S ∩ U` can be covered by finite affine opens.\n    obtain ⟨s, hs', hs⟩ :=\n      (is_compact_open_iff_eq_finset_affine_union _).mp\n        ⟨hSU _ _ (Set.subset_union_left _ _) S.2 hS (Set.subset_union_right _ _) U.1.2 U.2.is_compact,\n          («expr ⊓ » S U.1).2⟩\n    haveI := hs'.to_subtype\n    cases nonempty_fintype s\n    replace hs : «expr ⊓ » S U.1 = supᵢ fun i : s => (i : opens X.carrier) :=\n      by\n      ext1\n      simpa using hs\n    have hs₁ : ∀ i : s, i.1.1 ≤ S := by\n      intro i\n      change (i : opens X.carrier) ≤ S\n      refine' le_trans _ inf_le_left\n      use U.1\n      erw [hs]\n      exact le_supᵢ _ _\n    have hs₂ : ∀ i : s, i.1.1 ≤ U.1 := by\n      intro i\n      change (i : opens X.carrier) ≤ U\n      refine' le_trans _ inf_le_right\n      use S\n      erw [hs]\n      exact le_supᵢ _ _\n    -- On each affine open in the intersection, we have `f ^ (n + n₂) * y₁ = f ^ (n + n₁) * y₂`\n    -- for some `n` since `f ^ n₂ * y₁ = f ^ (n₁ + n₂) * x = f ^ n₁ * y₂` on `X_f`.\n    have :\n      ∀ i : s,\n        ∃ n : ℕ,\n          X.presheaf.map (hom_of_le <| hs₁ i).op (X.presheaf.map (hom_of_le le_sup_left).op f ^ (n + n₂) * y₁) =\n            X.presheaf.map (hom_of_le <| hs₂ i).op (X.presheaf.map (hom_of_le le_sup_right).op f ^ (n + n₁) * y₂) :=\n      by\n      intro i\n      exact exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux X i.1 S U (hs₁ i) (hs₂ i) hy₁ hy₂\n    choose n hn using this\n    -- We can thus choose a big enough `n` such that `f ^ (n + n₂) * y₁ = f ^ (n + n₁) * y₂`\n    -- on `S ∩ U`.\n    have :\n      X.presheaf.map (hom_of_le <| inf_le_left).op\n          (X.presheaf.map (hom_of_le le_sup_left).op f ^ (finset.univ.sup n + n₂) * y₁) =\n        X.presheaf.map (hom_of_le <| inf_le_right).op\n          (X.presheaf.map (hom_of_le le_sup_right).op f ^ (finset.univ.sup n + n₁) * y₂) :=\n      by\n      fapply X.sheaf.eq_of_locally_eq' fun i : s => i.1.1\n      · refine' fun i => hom_of_le _\n        erw [hs]\n        exact le_supᵢ _ _\n      · exact le_of_eq hs\n      · intro i\n        replace hn :=\n          congr_arg\n            (fun x => X.presheaf.map (hom_of_le (le_trans (hs₁ i) le_sup_left)).op f ^ (finset.univ.sup n - n i) * x)\n            (hn i)\n        dsimp only at hn\n        delta Scheme.sheaf SheafedSpace.sheaf\n        simp only [← map_pow, map_mul, ← comp_apply, ← functor.map_comp, ← op_comp, ← mul_assoc] at hn⊢\n        erw [← map_mul, ← map_mul] at hn\n        rw [← pow_add, ← pow_add, ← add_assoc, ← add_assoc, tsub_add_cancel_of_le] at hn\n        convert hn\n        exact finset.le_sup (finset.mem_univ _)\n    use finset.univ.sup n + n₁ + n₂\n    -- By the sheaf condition, since `f ^ (n + n₂) * y₁ = f ^ (n + n₁) * y₂`, it can be glued into\n    -- the desired section on `S ∪ U`.\n    use (X.sheaf.obj_sup_iso_prod_eq_locus S U.1).inv ⟨⟨_ * _, _ * _⟩, this⟩\n    refine'\n      X.sheaf.eq_of_locally_eq₂ (hom_of_le (_ : X.basic_open (X.presheaf.map (hom_of_le le_sup_left).op f) ≤ _))\n        (hom_of_le (_ : X.basic_open (X.presheaf.map (hom_of_le le_sup_right).op f) ≤ _)) _ _ _ _ _\n    · rw [X.basic_open_res]\n      exact inf_le_right\n    · rw [X.basic_open_res]\n      exact inf_le_right\n    · rw [X.basic_open_res, X.basic_open_res]\n      erw [← inf_sup_right]\n      refine' le_inf_iff.mpr ⟨X.basic_open_le f, le_of_eq rfl⟩\n    · convert\n        congr_arg (X.presheaf.map (hom_of_le _).op)\n          (X.sheaf.obj_sup_iso_prod_eq_locus_inv_fst S U.1 ⟨⟨_ * _, _ * _⟩, this⟩) using\n        1\n      · delta Scheme.sheaf SheafedSpace.sheaf\n        simp only [← comp_apply (X.presheaf.map _) (X.presheaf.map _), ← functor.map_comp, ← op_comp]\n        congr\n      · delta Scheme.sheaf SheafedSpace.sheaf\n        simp only [map_pow, map_mul, ← comp_apply, ← functor.map_comp, ← op_comp, mul_assoc, pow_add]\n        erw [hy₁]\n        congr 1\n        rw [← mul_assoc, ← mul_assoc]\n        congr 1\n        rw [mul_comm, ← comp_apply, ← functor.map_comp]\n        congr\n    · convert\n        congr_arg (X.presheaf.map (hom_of_le _).op)\n          (X.sheaf.obj_sup_iso_prod_eq_locus_inv_snd S U.1 ⟨⟨_ * _, _ * _⟩, this⟩) using\n        1\n      · delta Scheme.sheaf SheafedSpace.sheaf\n        simp only [← comp_apply (X.presheaf.map _) (X.presheaf.map _), ← functor.map_comp, ← op_comp]\n        congr\n      · delta Scheme.sheaf SheafedSpace.sheaf\n        simp only [map_pow, map_mul, ← comp_apply, ← functor.map_comp, ← op_comp, mul_assoc, pow_add]\n        erw [hy₂]\n        rw [← comp_apply, ← functor.map_comp]\n        congr\n#align exists_eq_pow_mul_of_is_compact_of_is_quasi_separated exists_eq_pow_mul_of_is_compact_of_is_quasi_separated\n\n",
 "exists_eq_pow_mul_of_is_affine_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr |_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr |_ » -/\ntheorem exists_eq_pow_mul_of_is_affine_open (X : Scheme) (U : opens X.carrier) (hU : is_affine_open U)\n    (f : X.presheaf.obj (op U)) (x : X.presheaf.obj (op <| X.basic_open f)) :\n    ∃ (n : ℕ)(y : X.presheaf.obj (op U)), «expr |_ » y (X.basic_open f) = «expr |_ » f (X.basic_open f) ^ n * x :=\n  by\n  have := (is_localization_basic_open hU f).2\n  obtain ⟨⟨y, _, n, rfl⟩, d⟩ := this x\n  use n, y\n  delta Top.presheaf.restrict_open Top.presheaf.restrict\n  simpa [mul_comm x] using d.symm\n#align exists_eq_pow_mul_of_is_affine_open exists_eq_pow_mul_of_is_affine_open\n\n",
 "affine_property_is_local":
 "theorem quasi_separated.affine_property_is_local : quasi_separated.affine_property.is_local :=\n  quasi_compact_affine_property_diagonal_eq ▸ quasi_compact.affine_property_is_local.diagonal\n#align quasi_separated.affine_property_is_local quasi_separated.affine_property_is_local\n\n",
 "affine_open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem quasi_separated.affine_open_cover_tfae {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) :\n    TFAE\n      [quasi_separated f,\n        ∃ (𝒰 : Scheme.open_cover.{u} Y)(_ : ∀ i, is_affine (𝒰.obj i)),\n          ∀ i : 𝒰.J, quasi_separated_space (pullback f (𝒰.map i)).carrier,\n        ∀ (𝒰 : Scheme.open_cover.{u} Y) [∀ i, is_affine (𝒰.obj i)] (i : 𝒰.J),\n          quasi_separated_space (pullback f (𝒰.map i)).carrier,\n        ∀ {U : Scheme} (g : «expr ⟶ » U Y) [is_affine U] [is_open_immersion g],\n          quasi_separated_space (pullback f g).carrier,\n        ∃ (𝒰 : Scheme.open_cover.{u} Y)(_ : ∀ i, is_affine (𝒰.obj i))(𝒰' :\n          ∀ i : 𝒰.J, Scheme.open_cover.{u} (pullback f (𝒰.map i)))(_ : ∀ i j, is_affine ((𝒰' i).obj j)),\n          ∀ (i : 𝒰.J) (j k : (𝒰' i).J), compact_space (pullback ((𝒰' i).map j) ((𝒰' i).map k)).carrier] :=\n  by\n  have := quasi_compact.affine_property_is_local.diagonal_affine_open_cover_tfae f\n  simp_rw [← quasi_compact_eq_affine_property, ← quasi_separated_eq_diagonal_is_quasi_compact,\n    quasi_compact_affine_property_diagonal_eq] at this\n  exact this\n#align quasi_separated.affine_open_cover_tfae quasi_separated.affine_open_cover_tfae\n\n",
 "affine_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem quasi_separated.affine_open_cover_iff {X Y : Scheme.{u}} (𝒰 : Scheme.open_cover.{u} Y)\n    [∀ i, is_affine (𝒰.obj i)] (f : «expr ⟶ » X Y) :\n    quasi_separated f ↔ ∀ i, quasi_separated_space (pullback f (𝒰.map i)).carrier :=\n  by\n  rw [quasi_separated_eq_affine_property, quasi_separated.affine_property_is_local.affine_open_cover_iff f 𝒰]\n  rfl\n#align quasi_separated.affine_open_cover_iff quasi_separated.affine_open_cover_iff\n\n"}