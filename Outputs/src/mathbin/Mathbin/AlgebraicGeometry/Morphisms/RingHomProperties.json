{"Γ_pullback_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem stable_under_base_change.Γ_pullback_fst (hP : stable_under_base_change @P) (hP' : respects_iso @P)\n    {X Y S : Scheme} [is_affine X] [is_affine Y] [is_affine S] (f : «expr ⟶ » X S) (g : «expr ⟶ » Y S)\n    (H : P (Scheme.Γ.map g.op)) : P (Scheme.Γ.map (pullback.fst : «expr ⟶ » (pullback f g) _).op) :=\n  by\n  rw [← preserves_pullback.iso_inv_fst AffineScheme.forget_to_Scheme (AffineScheme.of_hom f) (AffineScheme.of_hom g),\n    op_comp, functor.map_comp, hP'.cancel_right_is_iso, AffineScheme.forget_to_Scheme_map]\n  have :=\n    _root_.congr_arg Quiver.Hom.unop\n      (preserves_pullback.iso_hom_fst AffineScheme.Γ.right_op (AffineScheme.of_hom f) (AffineScheme.of_hom g))\n  simp only [Quiver.Hom.unop_op, functor.right_op_map, unop_comp] at this\n  delta AffineScheme.Γ at this\n  simp only [Quiver.Hom.unop_op, functor.comp_map, AffineScheme.forget_to_Scheme_map, functor.op_map] at this\n  rw [← this, hP'.cancel_right_is_iso, ← pushout_iso_unop_pullback_inl_hom (Quiver.Hom.unop _) (Quiver.Hom.unop _),\n    hP'.cancel_right_is_iso]\n  exact hP.pushout_inl _ hP' _ _ H\n#align stable_under_base_change.Γ_pullback_fst stable_under_base_change.Γ_pullback_fst\n\n",
 "source_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem source_open_cover_iff {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) (𝒰 : Scheme.open_cover.{u} X) :\n    affine_locally (@P) f ↔ ∀ i, affine_locally (@P) («expr ≫ » (𝒰.map i) f) :=\n  by\n  constructor\n  · intro H i U\n    rw [morphism_restrict_comp]\n    delta morphism_restrict\n    apply hP.source_affine_locally_comp_of_is_open_immersion\n    apply H\n  · intro H U\n    haveI : is_affine _ := U.2\n    apply ((hP.open_cover_tfae («expr ∣_ » f U.1)).out 1 0).mp\n    use 𝒰.pullback_cover (X.of_restrict _)\n    intro i\n    specialize H i U\n    rw [morphism_restrict_comp] at H\n    delta morphism_restrict at H\n    have := source_affine_locally_respects_iso hP.respects_iso\n    rw [category.assoc, affine_cancel_left_is_iso this, ← affine_cancel_left_is_iso this (pullback_symmetry _ _).hom,\n      pullback_symmetry_hom_comp_snd_assoc] at H\n    exact H\n#align source_open_cover_iff source_open_cover_iff\n\n",
 "source_affine_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem source_affine_open_cover_iff {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) [is_affine Y] (𝒰 : Scheme.open_cover.{u} X)\n    [∀ i, is_affine (𝒰.obj i)] : source_affine_locally (@P) f ↔ ∀ i, P (Scheme.Γ.map («expr ≫ » (𝒰.map i) f).op) :=\n  ⟨fun H =>\n    let h := ((hP.affine_open_cover_tfae f).out 0 2).mp H\n    h 𝒰,\n    fun H =>\n    let h := ((hP.affine_open_cover_tfae f).out 1 0).mp\n    h ⟨𝒰, inferInstance, H⟩⟩\n#align source_affine_open_cover_iff source_affine_open_cover_iff\n\n",
 "source_affine_locally_respects_iso":
 "theorem source_affine_locally_respects_iso (h₁ : ring_hom.respects_iso @P) :\n    (source_affine_locally @P).to_property.respects_iso :=\n  by\n  apply affine_target_morphism_property.respects_iso_mk\n  · introv H U\n    rw [← h₁.cancel_right_is_iso _ (Scheme.Γ.map (Scheme.restrict_map_iso e.inv U.1).hom.op), ← functor.map_comp, ←\n      op_comp]\n    convert H ⟨_, U.prop.map_is_iso e.inv⟩ using 3\n    rw [is_open_immersion.iso_of_range_eq_hom, is_open_immersion.lift_fac_assoc, category.assoc, e.inv_hom_id_assoc]\n    rfl\n  · introv H U\n    rw [← category.assoc, op_comp, functor.map_comp, h₁.cancel_left_is_iso]\n    exact H U\n#align source_affine_locally_respects_iso source_affine_locally_respects_iso\n\n",
 "source_affine_locally_of_source_open_cover_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem source_affine_locally_of_source_open_cover_aux (h₁ : ring_hom.respects_iso @P)\n    (h₃ : ring_hom.of_localization_span_target @P) {X Y : Scheme} (f : «expr ⟶ » X Y) (U : X.affine_opens)\n    (s : Set (X.presheaf.obj (op U.1))) (hs : Ideal.span s = «expr⊤»)\n    (hs' : ∀ r : s, P (Scheme.Γ.map («expr ≫ » (X.of_restrict (X.basic_open r.1).open_embedding) f).op)) :\n    P (Scheme.Γ.map («expr ≫ » (X.of_restrict U.1.open_embedding) f).op) :=\n  by\n  apply_fun Ideal.map (X.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op)  at hs\n  rw [Ideal.map_span, Ideal.map_top] at hs\n  apply h₃ _ _ hs\n  rintro ⟨s, r, hr, hs⟩\n  have :=\n    (@Localization.algEquiv _ _ _ _ _\n          (@algebraic_geometry.Γ_restrict_is_localization _ U.2 s)).to_ring_equiv.to_CommRing_iso\n  refine'\n    (h₁.cancel_right_is_iso _\n          (@Localization.algEquiv _ _ _ _ _\n                  (@algebraic_geometry.Γ_restrict_is_localization _ U.2 s)).to_ring_equiv.to_CommRing_iso.hom).mp\n      _\n  subst hs\n  rw [CommRing.comp_eq_ring_hom_comp, ← RingHom.comp_assoc]\n  erw [IsLocalization.map_comp, RingHom.comp_id]\n  rw [RingHom.algebraMap_toAlgebra, op_comp, functor.map_comp, ← CommRing.comp_eq_ring_hom_comp, Scheme.Γ_map_op,\n    Scheme.Γ_map_op, Scheme.Γ_map_op, category.assoc]\n  erw [← X.presheaf.map_comp]\n  rw [← h₁.cancel_right_is_iso _ (X.presheaf.map (eq_to_hom _))]\n  convert hs' ⟨r, hr⟩ using 1\n  · erw [category.assoc]\n    rw [← X.presheaf.map_comp, op_comp, Scheme.Γ.map_comp, Scheme.Γ_map_op, Scheme.Γ_map_op]\n    congr\n  · dsimp [functor.op]\n    conv_lhs => rw [opens.open_embedding_obj_top]\n    conv_rhs => rw [opens.open_embedding_obj_top]\n    erw [Scheme.image_basic_open (X.of_restrict U.1.open_embedding)]\n    erw [PresheafedSpace.is_open_immersion.of_restrict_inv_app_apply]\n    rw [Scheme.basic_open_res_eq]\n  · infer_instance\n#align source_affine_locally_of_source_open_cover_aux source_affine_locally_of_source_open_cover_aux\n\n",
 "source_affine_locally_of_source_open_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem source_affine_locally_of_source_open_cover {X Y : Scheme} (f : «expr ⟶ » X Y) [is_affine Y] (𝒰 : X.open_cover)\n    [∀ i, is_affine (𝒰.obj i)] (H : ∀ i, P (Scheme.Γ.map («expr ≫ » (𝒰.map i) f).op)) : source_affine_locally (@P) f :=\n  by\n  let S i :=\n    (⟨⟨Set.range (𝒰.map i).1.base, (𝒰.is_open i).base_open.open_range⟩,\n        range_is_affine_open_of_open_immersion (𝒰.map i)⟩ :\n      X.affine_opens)\n  intro U\n  apply of_affine_open_cover U\n  pick_goal 5; · exact Set.range S\n  · intro U r H\n    convert hP.stable_under_composition _ _ H _ using 1\n    swap\n    · refine' X.presheaf.map (@hom_of_le _ _ ((IsOpenMap.functor _).obj _) ((IsOpenMap.functor _).obj _) _).op\n      rw [unop_op, unop_op, opens.open_embedding_obj_top, opens.open_embedding_obj_top]\n      exact X.basic_open_le _\n    · rw [op_comp, op_comp, functor.map_comp, functor.map_comp]\n      refine' (Eq.trans _ (category.assoc _ _ _).symm : _)\n      congr 1\n      refine' Eq.trans _ (X.presheaf.map_comp _ _)\n      change X.presheaf.map _ = _\n      congr\n    convert hP.holds_for_localization_away _ (X.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op r)\n    · exact (RingHom.algebraMap_toAlgebra _).symm\n    · dsimp [Scheme.Γ]\n      have := U.2\n      rw [← U.1.open_embedding_obj_top] at this\n      convert is_localization_basic_open this _ using 6 <;> rw [opens.open_embedding_obj_top] <;>\n        exact (Scheme.basic_open_res_eq _ _ _).symm\n  · introv hs hs'\n    exact source_affine_locally_of_source_open_cover_aux hP.respects_iso hP.2 _ _ _ hs hs'\n  · rw [Set.eq_univ_iff_forall]\n    intro x\n    rw [Set.mem_unionᵢ]\n    exact ⟨⟨_, 𝒰.f x, rfl⟩, 𝒰.covers x⟩\n  · rintro ⟨_, i, rfl⟩\n    specialize H i\n    rw [←\n      hP.respects_iso.cancel_right_is_iso _\n        (Scheme.Γ.map\n          (is_open_immersion.iso_of_range_eq (𝒰.map i) (X.of_restrict (S i).1.open_embedding)\n                subtype.range_coe.symm).inv.op)] at\n      H\n    rwa [← Scheme.Γ.map_comp, ← op_comp, is_open_immersion.iso_of_range_eq_inv, is_open_immersion.lift_fac_assoc] at H\n#align source_affine_locally_of_source_open_cover source_affine_locally_of_source_open_cover\n\n",
 "source_affine_locally_is_local":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (V «expr = » (opens.map f.val.base).obj (Y.basic_open r.val)) -/\ntheorem source_affine_locally_is_local (h₁ : ring_hom.respects_iso @P) (h₂ : ring_hom.localization_preserves @P)\n    (h₃ : ring_hom.of_localization_span @P) : (source_affine_locally @P).is_local :=\n  by\n  constructor\n  · exact source_affine_locally_respects_iso h₁\n  · introv H U\n    apply Scheme_restrict_basic_open_of_localization_preserves h₁ h₂ <;> assumption\n  · introv hs hs' U\n    skip\n    apply h₃ _ _ hs\n    intro r\n    have := hs' r ⟨(opens.map (X.of_restrict _).1.base).obj U.1, _⟩\n    rwa [h₁.of_restrict_morphism_restrict_iff] at this\n    · exact U.2\n    · rfl\n    · infer_instance\n    · suffices\n        ∀ (V) (_ : V = (opens.map f.val.base).obj (Y.basic_open r.val)),\n          is_affine_open ((opens.map (X.of_restrict V.open_embedding).1.base).obj U.1)\n        by exact this _ rfl\n      intro V hV\n      rw [Scheme.preimage_basic_open] at hV\n      subst hV\n      exact U.2.map_restrict_basic_open (Scheme.Γ.map f.op r.1)\n#align source_affine_locally_is_local source_affine_locally_is_local\n\n",
 "source_affine_locally_comp_of_is_open_immersion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem source_affine_locally_comp_of_is_open_immersion {X Y Z : Scheme.{u}} [is_affine Z] (f : «expr ⟶ » X Y)\n    (g : «expr ⟶ » Y Z) [is_open_immersion f] (H : source_affine_locally (@P) g) :\n    source_affine_locally (@P) («expr ≫ » f g) := by apply ((hP.open_cover_tfae g).out 0 3).mp H\n#align source_affine_locally_comp_of_is_open_immersion source_affine_locally_comp_of_is_open_immersion\n\n",
 "open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem open_cover_tfae {X Y : Scheme.{u}} [is_affine Y] (f : «expr ⟶ » X Y) :\n    TFAE\n      [source_affine_locally (@P) f,\n        ∃ 𝒰 : Scheme.open_cover.{u} X, ∀ i : 𝒰.J, source_affine_locally (@P) («expr ≫ » (𝒰.map i) f),\n        ∀ (𝒰 : Scheme.open_cover.{u} X) (i : 𝒰.J), source_affine_locally (@P) («expr ≫ » (𝒰.map i) f),\n        ∀ {U : Scheme} (g : «expr ⟶ » U X) [is_open_immersion g], source_affine_locally (@P) («expr ≫ » g f)] :=\n  by\n  tfae_have 1 → 4\n  · intro H U g hg V\n    skip\n    rw [(hP.affine_open_cover_tfae f).out 0 3] at H\n    haveI : is_affine _ := V.2\n    rw [← category.assoc]\n    apply H\n  tfae_have 4 → 3\n  · intro H 𝒰 _ i\n    skip\n    apply H\n  tfae_have 3 → 2\n  · intro H\n    refine' ⟨X.affine_cover, H _⟩\n  tfae_have 2 → 1\n  · rintro ⟨𝒰, h𝒰⟩\n    rw [(hP.affine_open_cover_tfae f).out 0 1]\n    refine' ⟨𝒰.bind fun _ => Scheme.affine_cover _, _, _⟩\n    · intro i\n      dsimp\n      infer_instance\n    · intro i\n      specialize h𝒰 i.1\n      rw [(hP.affine_open_cover_tfae («expr ≫ » (𝒰.map i.fst) f)).out 0 3] at h𝒰\n      erw [category.assoc]\n      apply @h𝒰 _ (show _ from _)\n      dsimp\n      infer_instance\n  tfae_finish\n#align open_cover_tfae open_cover_tfae\n\n",
 "of_restrict_morphism_restrict_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem respects_iso.of_restrict_morphism_restrict_iff (hP : ring_hom.respects_iso @P) {X Y : Scheme} [is_affine Y]\n    (f : «expr ⟶ » X Y) (r : Y.presheaf.obj (Opposite.op («expr⊤»))) (U : Opens X.carrier) (hU : is_affine_open U)\n    {V : Opens _} (e : V = (Opens.map (X.of_restrict ((Opens.map f.1.base).obj _).open_embedding).1.base).obj U) :\n    P\n        (Scheme.Γ.map\n          («expr ≫ » ((X.restrict ((Opens.map f.1.base).obj _).open_embedding).of_restrict V.open_embedding)\n              («expr ∣_ » f (Y.basic_open r))).op) ↔\n      P (localization.away_map (Scheme.Γ.map («expr ≫ » (X.of_restrict U.open_embedding) f).op) r) :=\n  by\n  subst e\n  convert(hP.is_localization_away_iff _ _ _ _).symm\n  rotate_left\n  · infer_instance\n  · apply RingHom.toAlgebra\n    refine' X.presheaf.map (@hom_of_le _ _ ((IsOpenMap.functor _).obj _) ((IsOpenMap.functor _).obj _) _).op\n    rw [← SetLike.coe_subset_coe]\n    dsimp\n    simp only [Set.image_univ, Subtype.range_coe, Set.image_subset_iff]\n    rfl\n  · exact algebraic_geometry.Γ_restrict_is_localization Y r\n  · rw [← U.open_embedding_obj_top] at hU\n    dsimp [Scheme.Γ_obj_op, Scheme.Γ_map_op, Scheme.restrict]\n    apply algebraic_geometry.is_localization_of_eq_basic_open _ hU\n    rw [opens.open_embedding_obj_top, opens.functor_obj_map_obj]\n    convert(X.basic_open_res (Scheme.Γ.map f.op r) (hom_of_le le_top).op).symm using 1\n    rw [opens.open_embedding_obj_top, opens.open_embedding_obj_top, inf_comm, Scheme.Γ_map_op, ←\n      Scheme.preimage_basic_open]\n  · apply IsLocalization.ringHom_ext (Submonoid.powers r) _\n    swap\n    · exact algebraic_geometry.Γ_restrict_is_localization Y r\n    rw [is_localization.away.map, IsLocalization.map_comp, RingHom.algebraMap_toAlgebra, RingHom.algebraMap_toAlgebra,\n      op_comp, functor.map_comp, op_comp, functor.map_comp]\n    refine' (@category.assoc CommRing _ _ _ _ _ _ _ _).symm.trans _\n    refine' Eq.trans _ (@category.assoc CommRing _ _ _ _ _ _ _ _)\n    dsimp only [Scheme.Γ_map, Quiver.Hom.unop_op]\n    rw [morphism_restrict_c_app, category.assoc, category.assoc, category.assoc]\n    erw [f.1.c.naturality_assoc, ← X.presheaf.map_comp, ← X.presheaf.map_comp, ← X.presheaf.map_comp]\n    congr\n#align respects_iso.of_restrict_morphism_restrict_iff respects_iso.of_restrict_morphism_restrict_iff\n\n",
 "is_open_immersion_comp_of_source_affine_locally":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_open_immersion_comp_of_source_affine_locally (h₁ : ring_hom.respects_iso @P) {X Y Z : Scheme} [is_affine X]\n    [is_affine Z] (f : «expr ⟶ » X Y) [is_open_immersion f] (g : «expr ⟶ » Y Z) (h₂ : source_affine_locally (@P) g) :\n    P (Scheme.Γ.map («expr ≫ » f g).op) :=\n  by\n  rw [← h₁.cancel_right_is_iso _ (Scheme.Γ.map (is_open_immersion.iso_of_range_eq (Y.of_restrict _) f _).hom.op), ←\n    functor.map_comp, ← op_comp]\n  convert h₂ ⟨_, range_is_affine_open_of_open_immersion f⟩ using 3\n  · rw [is_open_immersion.iso_of_range_eq_hom, is_open_immersion.lift_fac_assoc]\n  · infer_instance\n  · exact Subtype.range_coe\n  · infer_instance\n#align is_open_immersion_comp_of_source_affine_locally is_open_immersion_comp_of_source_affine_locally\n\n",
 "is_local_source_affine_locally":
 "theorem is_local_source_affine_locally : (source_affine_locally @P).is_local :=\n  source_affine_locally_is_local hP.respects_iso hP.localization_preserves\n    (@ring_hom.property_is_local.of_localization_span _ hP)\n#align is_local_source_affine_locally is_local_source_affine_locally\n\n",
 "is_local_affine_locally":
 "theorem is_local_affine_locally : property_is_local_at_target (affine_locally @P) :=\n  hP.is_local_source_affine_locally.target_affine_locally_is_local\n#align is_local_affine_locally is_local_affine_locally\n\n",
 "basic_open_iff_localization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\ntheorem respects_iso.basic_open_iff_localization (hP : respects_iso @P) {X Y : Scheme} [is_affine X] [is_affine Y]\n    (f : «expr ⟶ » X Y) (r : Y.presheaf.obj (Opposite.op («expr⊤»))) :\n    P (Scheme.Γ.map («expr ∣_ » f (Y.basic_open r)).op) ↔ P (localization.away_map (Scheme.Γ.map f.op) r) :=\n  (hP.basic_open_iff _ _).trans (hP.is_localization_away_iff _ _ _ _).symm\n#align respects_iso.basic_open_iff_localization respects_iso.basic_open_iff_localization\n\n",
 "basic_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem respects_iso.basic_open_iff (hP : respects_iso @P) {X Y : Scheme} [is_affine X] [is_affine Y]\n    (f : «expr ⟶ » X Y) (r : Y.presheaf.obj (Opposite.op («expr⊤»))) :\n    P (Scheme.Γ.map («expr ∣_ » f (Y.basic_open r)).op) ↔\n      P\n        (@is_localization.away.map (Y.presheaf.obj (Opposite.op («expr⊤»))) _\n          (Y.presheaf.obj (Opposite.op <| Y.basic_open r)) _ _ (X.presheaf.obj (Opposite.op («expr⊤»))) _\n          (X.presheaf.obj (Opposite.op <| X.basic_open (Scheme.Γ.map f.op r))) _ _ (Scheme.Γ.map f.op) r _ _) :=\n  by\n  rw [Γ_map_morphism_restrict, hP.cancel_left_is_iso, hP.cancel_right_is_iso, ←\n    hP.cancel_right_is_iso (f.val.c.app (Opposite.op (Y.basic_open r)))\n      (X.presheaf.map (eq_to_hom (Scheme.preimage_basic_open f r).symm).op),\n    ← eq_iff_iff]\n  congr\n  delta is_localization.away.map\n  refine' IsLocalization.ringHom_ext (Submonoid.powers r) _\n  convert(IsLocalization.map_comp _).symm using 1\n  change «expr ≫ » (Y.presheaf.map _) _ = «expr ≫ » _ (X.presheaf.map _)\n  rw [f.val.c.naturality_assoc]\n  erw [← X.presheaf.map_comp]\n  congr\n#align respects_iso.basic_open_iff respects_iso.basic_open_iff\n\n",
 "affine_open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem affine_open_cover_tfae {X Y : Scheme.{u}} [is_affine Y] (f : «expr ⟶ » X Y) :\n    TFAE\n      [source_affine_locally (@P) f,\n        ∃ (𝒰 : Scheme.open_cover.{u} X)(_ : ∀ i, is_affine (𝒰.obj i)),\n          ∀ i : 𝒰.J, P (Scheme.Γ.map («expr ≫ » (𝒰.map i) f).op),\n        ∀ (𝒰 : Scheme.open_cover.{u} X) [∀ i, is_affine (𝒰.obj i)] (i : 𝒰.J),\n          P (Scheme.Γ.map («expr ≫ » (𝒰.map i) f).op),\n        ∀ {U : Scheme} (g : «expr ⟶ » U X) [is_affine U] [is_open_immersion g], P (Scheme.Γ.map («expr ≫ » g f).op)] :=\n  by\n  tfae_have 1 → 4\n  · intro H U g _ hg\n    skip\n    specialize H ⟨⟨_, hg.base_open.open_range⟩, range_is_affine_open_of_open_immersion g⟩\n    rw [←\n      hP.respects_iso.cancel_right_is_iso _\n        (Scheme.Γ.map\n          (is_open_immersion.iso_of_range_eq g (X.of_restrict (opens.open_embedding ⟨_, hg.base_open.open_range⟩))\n                subtype.range_coe.symm).hom.op),\n      ← Scheme.Γ.map_comp, ← op_comp, is_open_immersion.iso_of_range_eq_hom] at H\n    erw [is_open_immersion.lift_fac_assoc] at H\n    exact H\n  tfae_have 4 → 3\n  · intro H 𝒰 _ i\n    skip\n    apply H\n  tfae_have 3 → 2\n  · intro H\n    refine' ⟨X.affine_cover, inferInstance, H _⟩\n  tfae_have 2 → 1\n  · rintro ⟨𝒰, _, h𝒰⟩\n    exact hP.source_affine_locally_of_source_open_cover f 𝒰 h𝒰\n  tfae_finish\n#align affine_open_cover_tfae affine_open_cover_tfae\n\n",
 "affine_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem affine_open_cover_iff {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) (𝒰 : Scheme.open_cover.{u} Y)\n    [∀ i, is_affine (𝒰.obj i)] (𝒰' : ∀ i, Scheme.open_cover.{u} ((𝒰.pullback_cover f).obj i))\n    [∀ i j, is_affine ((𝒰' i).obj j)] :\n    affine_locally (@P) f ↔ ∀ i j, P (Scheme.Γ.map («expr ≫ » ((𝒰' i).map j) pullback.snd).op) :=\n  (hP.is_local_source_affine_locally.affine_open_cover_iff f 𝒰).trans\n    (forall_congr' fun i => hP.source_affine_open_cover_iff _ (𝒰' i))\n#align affine_open_cover_iff affine_open_cover_iff\n\n",
 "affine_locally_stable_under_composition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem affine_locally_stable_under_composition : (affine_locally @P).stable_under_composition :=\n  by\n  intro X Y S f g hf hg\n  let 𝒰 : ∀ i, ((S.affine_cover.pullback_cover («expr ≫ » f g)).obj i).open_cover :=\n    by\n    intro i\n    refine' Scheme.open_cover.bind _ fun i => Scheme.affine_cover _\n    apply Scheme.open_cover.pushforward_iso _ (pullback_right_pullback_fst_iso g (S.affine_cover.map i) f).hom\n    apply Scheme.pullback.open_cover_of_right\n    exact (pullback g (S.affine_cover.map i)).affine_cover\n  rw [hP.affine_open_cover_iff («expr ≫ » f g) S.affine_cover _]\n  rotate_left\n  · exact 𝒰\n  · intro i j\n    dsimp at *\n    infer_instance\n  · rintro i ⟨j, k⟩\n    dsimp at i j k\n    dsimp only [Scheme.open_cover.bind_map, Scheme.open_cover.pushforward_iso_obj,\n      Scheme.pullback.open_cover_of_right_obj, Scheme.open_cover.pushforward_iso_map,\n      Scheme.pullback.open_cover_of_right_map, Scheme.open_cover.bind_obj]\n    rw [category.assoc, category.assoc, pullback_right_pullback_fst_iso_hom_snd, pullback.lift_snd_assoc,\n      category.assoc, ← category.assoc, op_comp, functor.map_comp]\n    apply hP.stable_under_composition\n    · exact (hP.affine_open_cover_iff _ _ _).mp hg _ _\n    · delta affine_locally at hf\n      rw [(hP.is_local_source_affine_locally.affine_open_cover_tfae f).out 0 3] at hf\n      specialize hf («expr ≫ » ((pullback g (S.affine_cover.map i)).affine_cover.map j) pullback.fst)\n      rw [(hP.affine_open_cover_tfae\n              (pullback.snd :\n                «expr ⟶ » (pullback f («expr ≫ » ((pullback g (S.affine_cover.map i)).affine_cover.map j) pullback.fst))\n                  _)).out\n          0 3] at\n        hf\n      apply hf\n#align affine_locally_stable_under_composition affine_locally_stable_under_composition\n\n",
 "affine_locally_respects_iso":
 "theorem affine_locally_respects_iso (h : ring_hom.respects_iso @P) : (affine_locally @P).respects_iso :=\n  target_affine_locally_respects_iso (source_affine_locally_respects_iso h)\n#align affine_locally_respects_iso affine_locally_respects_iso\n\n",
 "affine_locally_of_is_open_immersion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem affine_locally_of_is_open_immersion (hP : ring_hom.property_is_local @P) {X Y : Scheme} (f : «expr ⟶ » X Y)\n    [hf : is_open_immersion f] : affine_locally (@P) f :=\n  by\n  intro U\n  haveI H : is_affine _ := U.2\n  rw [← category.comp_id («expr ∣_ » f U)]\n  apply hP.source_affine_locally_comp_of_is_open_immersion\n  rw [hP.source_affine_open_cover_iff _ (Scheme.open_cover_of_is_iso ((«expr𝟙») _))]\n  · intro i\n    erw [category.id_comp, op_id, Scheme.Γ.map_id]\n    convert hP.holds_for_localization_away _ (1 : Scheme.Γ.obj _)\n    · exact (RingHom.algebraMap_toAlgebra _).symm\n    · infer_instance\n    · refine' is_localization.away_of_is_unit_of_bijective _ isUnit_one function.bijective_id\n  · intro i\n    exact H\n#align affine_locally_of_is_open_immersion affine_locally_of_is_open_immersion\n\n",
 "affine_locally_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem affine_locally_of_comp\n    (H :\n      ∀ {R S T : Type u} [CommRing R] [CommRing S] [CommRing T],\n        ∀ (f : «expr →+* » R S) (g : «expr →+* » S T), P (g.comp f) → P g)\n    {X Y Z : Scheme} {f : «expr ⟶ » X Y} {g : «expr ⟶ » Y Z} (h : affine_locally (@P) («expr ≫ » f g)) :\n    affine_locally (@P) f :=\n  by\n  let 𝒰 : ∀ i, ((Z.affine_cover.pullback_cover («expr ≫ » f g)).obj i).open_cover :=\n    by\n    intro i\n    refine' Scheme.open_cover.bind _ fun i => Scheme.affine_cover _\n    apply Scheme.open_cover.pushforward_iso _ (pullback_right_pullback_fst_iso g (Z.affine_cover.map i) f).hom\n    apply Scheme.pullback.open_cover_of_right\n    exact (pullback g (Z.affine_cover.map i)).affine_cover\n  have h𝒰 : ∀ i j, is_affine ((𝒰 i).obj j) := by\n    dsimp\n    infer_instance\n  let 𝒰' := (Z.affine_cover.pullback_cover g).bind fun i => Scheme.affine_cover _\n  have h𝒰' : ∀ i, is_affine (𝒰'.obj i) := by\n    dsimp\n    infer_instance\n  rw [hP.affine_open_cover_iff f 𝒰' fun i => Scheme.affine_cover _]\n  rw [hP.affine_open_cover_iff («expr ≫ » f g) Z.affine_cover 𝒰] at h\n  rintro ⟨i, j⟩ k\n  dsimp at i j k\n  specialize h i ⟨j, k⟩\n  dsimp only [Scheme.open_cover.bind_map, Scheme.open_cover.pushforward_iso_obj,\n    Scheme.pullback.open_cover_of_right_obj, Scheme.open_cover.pushforward_iso_map,\n    Scheme.pullback.open_cover_of_right_map, Scheme.open_cover.bind_obj, Scheme.open_cover.pullback_cover_obj,\n    Scheme.open_cover.pullback_cover_map] at h⊢\n  rw [category.assoc, category.assoc, pullback_right_pullback_fst_iso_hom_snd, pullback.lift_snd_assoc, category.assoc,\n    ← category.assoc, op_comp, functor.map_comp] at h\n  exact H _ _ h\n#align affine_locally_of_comp affine_locally_of_comp\n\n",
 "affine_locally_iff_affine_opens_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem affine_locally_iff_affine_opens_le (hP : ring_hom.respects_iso @P) {X Y : Scheme} (f : «expr ⟶ » X Y) :\n    affine_locally (@P) f ↔\n      ∀ (U : Y.affine_opens) (V : X.affine_opens) (e : V.1 ≤ (Opens.map f.1.base).obj U.1), P (f.app_le e) :=\n  by\n  apply forall_congr'\n  intro U\n  delta source_affine_locally\n  simp_rw [op_comp, Scheme.Γ.map_comp, Γ_map_morphism_restrict, category.assoc, Scheme.Γ_map_op, hP.cancel_left_is_iso]\n  constructor\n  · intro H V e\n    let U' := (opens.map f.val.base).obj U.1\n    have e' : U'.open_embedding.is_open_map.functor.obj ((opens.map U'.inclusion).obj V.1) = V.1 :=\n      by\n      ext1\n      refine' set.image_preimage_eq_inter_range.trans (set.inter_eq_left_iff_subset.mpr _)\n      convert e\n      exact Subtype.range_coe\n    have := H ⟨(opens.map (X.of_restrict U'.open_embedding).1.base).obj V.1, _⟩\n    erw [← X.presheaf.map_comp] at this\n    rw [← hP.cancel_right_is_iso _ (X.presheaf.map (eq_to_hom _)), category.assoc, ← X.presheaf.map_comp]\n    convert this using 1\n    · dsimp only [functor.op, unop_op]\n      rw [opens.open_embedding_obj_top]\n      congr 1\n      exact e'.symm\n    · infer_instance\n    · apply (is_affine_open_iff_of_is_open_immersion (X.of_restrict _) _).mp\n      convert V.2\n      infer_instance\n  · intro H V\n    specialize H ⟨_, V.2.image_is_open_immersion (X.of_restrict _)⟩ (Subtype.coe_image_subset _ _)\n    erw [← X.presheaf.map_comp]\n    rw [← hP.cancel_right_is_iso _ (X.presheaf.map (eq_to_hom _)), category.assoc, ← X.presheaf.map_comp]\n    convert H\n    · dsimp only [functor.op, unop_op]\n      rw [opens.open_embedding_obj_top]\n      rfl\n    · infer_instance\n#align affine_locally_iff_affine_opens_le affine_locally_iff_affine_opens_le\n\n",
 "Scheme_restrict_basic_open_of_localization_preserves":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\ntheorem Scheme_restrict_basic_open_of_localization_preserves (h₁ : ring_hom.respects_iso @P)\n    (h₂ : ring_hom.localization_preserves @P) {X Y : Scheme} [is_affine Y] (f : «expr ⟶ » X Y)\n    (r : Y.presheaf.obj (op («expr⊤»))) (H : source_affine_locally (@P) f)\n    (U : (X.restrict ((Opens.map f.1.base).obj <| Y.basic_open r).open_embedding).affine_opens) :\n    P\n      (Scheme.Γ.map\n        («expr ≫ »\n            ((X.restrict ((Opens.map f.1.base).obj <| Y.basic_open r).open_embedding).of_restrict U.1.open_embedding)\n            («expr ∣_ » f (Y.basic_open r))).op) :=\n  by\n  specialize H ⟨_, U.2.image_is_open_immersion (X.of_restrict _)⟩\n  convert(h₁.of_restrict_morphism_restrict_iff _ _ _ _ _).mpr _ using 1\n  pick_goal 5\n  · exact h₂.away r H\n  · infer_instance\n  · exact U.2.image_is_open_immersion _\n  · ext1\n    exact (Set.preimage_image_eq _ Subtype.coe_injective).symm\n#align Scheme_restrict_basic_open_of_localization_preserves Scheme_restrict_basic_open_of_localization_preserves\n\n"}