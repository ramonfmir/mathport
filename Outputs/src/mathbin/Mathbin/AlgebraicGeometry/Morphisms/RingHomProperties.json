{"Î“_pullback_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem stable_under_base_change.Î“_pullback_fst (hP : stable_under_base_change @P) (hP' : respects_iso @P)\n    {X Y S : Scheme} [is_affine X] [is_affine Y] [is_affine S] (f : Â«expr âŸ¶ Â» X S) (g : Â«expr âŸ¶ Â» Y S)\n    (H : P (Scheme.Î“.map g.op)) : P (Scheme.Î“.map (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) _).op) :=\n  by\n  rw [â† preserves_pullback.iso_inv_fst AffineScheme.forget_to_Scheme (AffineScheme.of_hom f) (AffineScheme.of_hom g),\n    op_comp, functor.map_comp, hP'.cancel_right_is_iso, AffineScheme.forget_to_Scheme_map]\n  have :=\n    _root_.congr_arg Quiver.Hom.unop\n      (preserves_pullback.iso_hom_fst AffineScheme.Î“.right_op (AffineScheme.of_hom f) (AffineScheme.of_hom g))\n  simp only [quiver.hom.unop_op, functor.right_op_map, unop_comp] at this\n  delta AffineScheme.Î“ at this\n  simp only [quiver.hom.unop_op, functor.comp_map, AffineScheme.forget_to_Scheme_map, functor.op_map] at this\n  rw [â† this, hP'.cancel_right_is_iso, â† pushout_iso_unop_pullback_inl_hom (Quiver.Hom.unop _) (Quiver.Hom.unop _),\n    hP'.cancel_right_is_iso]\n  exact hP.pushout_inl _ hP' _ _ H\n#align stable_under_base_change.Î“_pullback_fst stable_under_base_change.Î“_pullback_fst\n\n",
 "source_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem source_open_cover_iff {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) (ğ’° : Scheme.open_cover.{u} X) :\n    affine_locally (@P) f â†” âˆ€ i, affine_locally (@P) (Â«expr â‰« Â» (ğ’°.map i) f) :=\n  by\n  constructor\n  Â· intro H i U\n    rw [morphism_restrict_comp]\n    delta morphism_restrict\n    apply hP.source_affine_locally_comp_of_is_open_immersion\n    apply H\n  Â· intro H U\n    haveI : is_affine _ := U.2\n    apply ((hP.open_cover_tfae (Â«expr âˆ£_ Â» f U.1)).out 1 0).mp\n    use ğ’°.pullback_cover (X.of_restrict _)\n    intro i\n    specialize H i U\n    rw [morphism_restrict_comp] at H\n    delta morphism_restrict at H\n    have := source_affine_locally_respects_iso hP.respects_iso\n    rw [category.assoc, affine_cancel_left_is_iso this, â† affine_cancel_left_is_iso this (pullback_symmetry _ _).hom,\n      pullback_symmetry_hom_comp_snd_assoc] at H\n    exact H\n#align source_open_cover_iff source_open_cover_iff\n\n",
 "source_affine_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem source_affine_open_cover_iff {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) [is_affine Y] (ğ’° : Scheme.open_cover.{u} X)\n    [âˆ€ i, is_affine (ğ’°.obj i)] : source_affine_locally (@P) f â†” âˆ€ i, P (Scheme.Î“.map (Â«expr â‰« Â» (ğ’°.map i) f).op) :=\n  âŸ¨fun H =>\n    let h := ((hP.affine_open_cover_tfae f).out 0 2).mp H\n    h ğ’°,\n    fun H =>\n    let h := ((hP.affine_open_cover_tfae f).out 1 0).mp\n    h âŸ¨ğ’°, infer_instance, HâŸ©âŸ©\n#align source_affine_open_cover_iff source_affine_open_cover_iff\n\n",
 "source_affine_locally_respects_iso":
 "theorem source_affine_locally_respects_iso (hâ‚ : ring_hom.respects_iso @P) :\n    (source_affine_locally @P).to_property.respects_iso :=\n  by\n  apply affine_target_morphism_property.respects_iso_mk\n  Â· introv H U\n    rw [â† hâ‚.cancel_right_is_iso _ (Scheme.Î“.map (Scheme.restrict_map_iso e.inv U.1).hom.op), â† functor.map_comp, â†\n      op_comp]\n    convert H âŸ¨_, U.prop.map_is_iso e.invâŸ© using 3\n    rw [is_open_immersion.iso_of_range_eq_hom, is_open_immersion.lift_fac_assoc, category.assoc, e.inv_hom_id_assoc]\n    rfl\n  Â· introv H U\n    rw [â† category.assoc, op_comp, functor.map_comp, hâ‚.cancel_left_is_iso]\n    exact H U\n#align source_affine_locally_respects_iso source_affine_locally_respects_iso\n\n",
 "source_affine_locally_of_source_open_cover_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem source_affine_locally_of_source_open_cover_aux (hâ‚ : ring_hom.respects_iso @P)\n    (hâ‚ƒ : ring_hom.of_localization_span_target @P) {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) (U : X.affine_opens)\n    (s : set (X.presheaf.obj (op U.1))) (hs : ideal.span s = Â«exprâŠ¤Â»)\n    (hs' : âˆ€ r : s, P (Scheme.Î“.map (Â«expr â‰« Â» (X.of_restrict (X.basic_open r.1).open_embedding) f).op)) :\n    P (Scheme.Î“.map (Â«expr â‰« Â» (X.of_restrict U.1.open_embedding) f).op) :=\n  by\n  apply_fun ideal.map (X.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op)  at hs\n  rw [ideal.map_span, ideal.map_top] at hs\n  apply hâ‚ƒ _ _ hs\n  rintro âŸ¨s, r, hr, hsâŸ©\n  have :=\n    (@localization.alg_equiv _ _ _ _ _\n          (@algebraic_geometry.Î“_restrict_is_localization _ U.2 s)).to_ring_equiv.to_CommRing_iso\n  refine'\n    (hâ‚.cancel_right_is_iso _\n          (@localization.alg_equiv _ _ _ _ _\n                  (@algebraic_geometry.Î“_restrict_is_localization _ U.2 s)).to_ring_equiv.to_CommRing_iso.hom).mp\n      _\n  subst hs\n  rw [CommRing.comp_eq_ring_hom_comp, â† RingHom.comp_assoc]\n  erw [is_localization.map_comp, RingHom.comp_id]\n  rw [ring_hom.algebra_map_to_algebra, op_comp, functor.map_comp, â† CommRing.comp_eq_ring_hom_comp, Scheme.Î“_map_op,\n    Scheme.Î“_map_op, Scheme.Î“_map_op, category.assoc]\n  erw [â† X.presheaf.map_comp]\n  rw [â† hâ‚.cancel_right_is_iso _ (X.presheaf.map (eq_to_hom _))]\n  convert hs' âŸ¨r, hrâŸ© using 1\n  Â· erw [category.assoc]\n    rw [â† X.presheaf.map_comp, op_comp, Scheme.Î“.map_comp, Scheme.Î“_map_op, Scheme.Î“_map_op]\n    congr\n  Â· dsimp [functor.op]\n    conv_lhs => rw [opens.open_embedding_obj_top]\n    conv_rhs => rw [opens.open_embedding_obj_top]\n    erw [Scheme.image_basic_open (X.of_restrict U.1.open_embedding)]\n    erw [PresheafedSpace.is_open_immersion.of_restrict_inv_app_apply]\n    rw [Scheme.basic_open_res_eq]\n  Â· infer_instance\n#align source_affine_locally_of_source_open_cover_aux source_affine_locally_of_source_open_cover_aux\n\n",
 "source_affine_locally_of_source_open_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem source_affine_locally_of_source_open_cover {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) [is_affine Y] (ğ’° : X.open_cover)\n    [âˆ€ i, is_affine (ğ’°.obj i)] (H : âˆ€ i, P (Scheme.Î“.map (Â«expr â‰« Â» (ğ’°.map i) f).op)) : source_affine_locally (@P) f :=\n  by\n  let S i :=\n    (âŸ¨âŸ¨Set.range (ğ’°.map i).1.base, (ğ’°.is_open i).base_open.open_rangeâŸ©,\n        range_is_affine_open_of_open_immersion (ğ’°.map i)âŸ© :\n      X.affine_opens)\n  intro U\n  apply of_affine_open_cover U\n  pick_goal 5; Â· exact Set.range S\n  Â· intro U r H\n    convert hP.stable_under_composition _ _ H _ using 1\n    swap\n    Â· refine' X.presheaf.map (@hom_of_le _ _ ((is_open_map.functor _).obj _) ((is_open_map.functor _).obj _) _).op\n      rw [unop_op, unop_op, opens.open_embedding_obj_top, opens.open_embedding_obj_top]\n      exact X.basic_open_le _\n    Â· rw [op_comp, op_comp, functor.map_comp, functor.map_comp]\n      refine' (eq.trans _ (category.assoc _ _ _).symm : _)\n      congr 1\n      refine' eq.trans _ (X.presheaf.map_comp _ _)\n      change X.presheaf.map _ = _\n      congr\n    convert hP.holds_for_localization_away _ (X.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op r)\n    Â· exact (ring_hom.algebra_map_to_algebra _).symm\n    Â· dsimp [Scheme.Î“]\n      have := U.2\n      rw [â† U.1.open_embedding_obj_top] at this\n      convert is_localization_basic_open this _ using 6 <;> rw [opens.open_embedding_obj_top] <;>\n        exact (Scheme.basic_open_res_eq _ _ _).symm\n  Â· introv hs hs'\n    exact source_affine_locally_of_source_open_cover_aux hP.respects_iso hP.2 _ _ _ hs hs'\n  Â· rw [Set.eq_univ_iff_forall]\n    intro x\n    rw [Set.mem_unionáµ¢]\n    exact âŸ¨âŸ¨_, ğ’°.f x, rflâŸ©, ğ’°.covers xâŸ©\n  Â· rintro âŸ¨_, i, rflâŸ©\n    specialize H i\n    rw [â†\n      hP.respects_iso.cancel_right_is_iso _\n        (Scheme.Î“.map\n          (is_open_immersion.iso_of_range_eq (ğ’°.map i) (X.of_restrict (S i).1.open_embedding)\n                subtype.range_coe.symm).inv.op)] at\n      H\n    rwa [â† Scheme.Î“.map_comp, â† op_comp, is_open_immersion.iso_of_range_eq_inv, is_open_immersion.lift_fac_assoc] at H\n#align source_affine_locally_of_source_open_cover source_affine_locally_of_source_open_cover\n\n",
 "source_affine_locally_is_local":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (V Â«expr = Â» (opens.map f.val.base).obj (Y.basic_open r.val)) -/\ntheorem source_affine_locally_is_local (hâ‚ : ring_hom.respects_iso @P) (hâ‚‚ : ring_hom.localization_preserves @P)\n    (hâ‚ƒ : ring_hom.of_localization_span @P) : (source_affine_locally @P).is_local :=\n  by\n  constructor\n  Â· exact source_affine_locally_respects_iso hâ‚\n  Â· introv H U\n    apply Scheme_restrict_basic_open_of_localization_preserves hâ‚ hâ‚‚ <;> assumption\n  Â· introv hs hs' U\n    skip\n    apply hâ‚ƒ _ _ hs\n    intro r\n    have := hs' r âŸ¨(opens.map (X.of_restrict _).1.base).obj U.1, _âŸ©\n    rwa [hâ‚.of_restrict_morphism_restrict_iff] at this\n    Â· exact U.2\n    Â· rfl\n    Â· infer_instance\n    Â· suffices\n        âˆ€ (V) (_ : V = (opens.map f.val.base).obj (Y.basic_open r.val)),\n          is_affine_open ((opens.map (X.of_restrict V.open_embedding).1.base).obj U.1)\n        by exact this _ rfl\n      intro V hV\n      rw [Scheme.preimage_basic_open] at hV\n      subst hV\n      exact U.2.map_restrict_basic_open (Scheme.Î“.map f.op r.1)\n#align source_affine_locally_is_local source_affine_locally_is_local\n\n",
 "source_affine_locally_comp_of_is_open_immersion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem source_affine_locally_comp_of_is_open_immersion {X Y Z : Scheme.{u}} [is_affine Z] (f : Â«expr âŸ¶ Â» X Y)\n    (g : Â«expr âŸ¶ Â» Y Z) [is_open_immersion f] (H : source_affine_locally (@P) g) :\n    source_affine_locally (@P) (Â«expr â‰« Â» f g) := by apply ((hP.open_cover_tfae g).out 0 3).mp H\n#align source_affine_locally_comp_of_is_open_immersion source_affine_locally_comp_of_is_open_immersion\n\n",
 "open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `open_cover_tfae [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`X `Y] [\":\" (Term.explicitUniv `Scheme \".{\" [`u] \"}\")] \"}\")\n        (Term.instBinder \"[\" [] (Term.app `is_affine [`Y]) \"]\")\n        (Term.explicitBinder \"(\" [`f] [\":\" (Term.app `Â«expr âŸ¶ Â» [`X `Y])] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(Â«term[_]Â»\n           \"[\"\n           [(Term.app `source_affine_locally [(Term.explicit \"@\" `P) `f])\n            \",\"\n            (Â«termâˆƒ_,_Â»\n             \"âˆƒ\"\n             (Lean.explicitBinders\n              (Lean.unbracketedExplicitBinders\n               [(Lean.binderIdent `ğ’°)]\n               [\":\" (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`X])]))\n             \",\"\n             (Term.forall\n              \"âˆ€\"\n              [`i]\n              [(Term.typeSpec \":\" (Term.proj `ğ’° \".\" `J))]\n              \",\"\n              (Term.app\n               `source_affine_locally\n               [(Term.explicit \"@\" `P) (Term.app `Â«expr â‰« Â» [(Term.app (Term.proj `ğ’° \".\" `map) [`i]) `f])])))\n            \",\"\n            (Term.forall\n             \"âˆ€\"\n             [(Term.explicitBinder\n               \"(\"\n               [`ğ’°]\n               [\":\" (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`X])]\n               []\n               \")\")\n              (Term.explicitBinder \"(\" [`i] [\":\" (Term.proj `ğ’° \".\" `J)] [] \")\")]\n             []\n             \",\"\n             (Term.app\n              `source_affine_locally\n              [(Term.explicit \"@\" `P) (Term.app `Â«expr â‰« Â» [(Term.app (Term.proj `ğ’° \".\" `map) [`i]) `f])]))\n            \",\"\n            (Term.forall\n             \"âˆ€\"\n             [(Term.implicitBinder \"{\" [`U] [\":\" `Scheme] \"}\")\n              (Term.explicitBinder \"(\" [`g] [\":\" (Term.app `Â«expr âŸ¶ Â» [`U `X])] [] \")\")\n              (Term.instBinder \"[\" [] (Term.app `is_open_immersion [`g]) \"]\")]\n             []\n             \",\"\n             (Term.app `source_affine_locally [(Term.explicit \"@\" `P) (Term.app `Â«expr â‰« Â» [`g `f])]))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.intro \"intro\" [`H `U `g `hg `V])\n             []\n             (Tactic.skip \"skip\")\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule\n                 []\n                 (Term.app (Term.proj (Term.app `hP.affine_open_cover_tfae [`f]) \".\" `out) [(num \"0\") (num \"3\")]))]\n               \"]\")\n              [(Tactic.location \"at\" (Tactic.locationHyp [`H] []))])\n             []\n             (Std.Tactic.tacticHaveI_\n              \"haveI\"\n              (Term.haveDecl\n               (Term.haveIdDecl\n                []\n                [(Term.typeSpec \":\" (Term.app `is_affine [(Term.hole \"_\")]))]\n                \":=\"\n                (Term.proj `V \".\" (fieldIdx \"2\")))))\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» \"â†\"))] `category.assoc)] \"]\")\n              [])\n             []\n             (Tactic.apply \"apply\" `H)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"â†’\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.intro \"intro\" [`H `ğ’° (Term.hole \"_\") `i]) [] (Tactic.skip \"skip\") [] (Tactic.apply \"apply\" `H)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"â†’\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.intro \"intro\" [`H])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor \"âŸ¨\" [`X.affine_cover \",\" (Term.app `H [(Term.hole \"_\")])] \"âŸ©\"))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"âŸ¨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hğ’°)])\n                   [])]\n                 \"âŸ©\"))]\n              [])\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule\n                 []\n                 (Term.app (Term.proj (Term.app `hP.affine_open_cover_tfae [`f]) \".\" `out) [(num \"0\") (num \"1\")]))]\n               \"]\")\n              [])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor\n               \"âŸ¨\"\n               [(Term.app\n                 `ğ’°.bind\n                 [(Term.fun\n                   \"fun\"\n                   (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `Scheme.affine_cover [(Term.hole \"_\")])))])\n                \",\"\n                (Term.hole \"_\")\n                \",\"\n                (Term.hole \"_\")]\n               \"âŸ©\"))\n             []\n             (tactic__\n              (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n              [(Tactic.intro \"intro\" [`i])\n               []\n               (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n               []\n               (Tactic.tacticInfer_instance \"infer_instance\")])\n             []\n             (tactic__\n              (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n              [(Tactic.intro \"intro\" [`i])\n               []\n               (Tactic.specialize \"specialize\" (Term.app `hğ’° [(Term.proj `i \".\" (fieldIdx \"1\"))]))\n               []\n               (Tactic.rwSeq\n                \"rw\"\n                []\n                (Tactic.rwRuleSeq\n                 \"[\"\n                 [(Tactic.rwRule\n                   []\n                   (Term.app\n                    (Term.proj\n                     (Term.app `hP.affine_open_cover_tfae [(Term.app `Â«expr â‰« Â» [(Term.app `ğ’°.map [`i.fst]) `f])])\n                     \".\"\n                     `out)\n                    [(num \"0\") (num \"3\")]))]\n                 \"]\")\n                [(Tactic.location \"at\" (Tactic.locationHyp [`hğ’°] []))])\n               []\n               (Tactic.tacticErw__ \"erw\" (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `category.assoc)] \"]\") [])\n               []\n               (Tactic.apply\n                \"apply\"\n                (Term.app\n                 (Term.explicit \"@\" `hğ’°)\n                 [(Term.hole \"_\") (Term.show \"show\" (Term.hole \"_\") (Term.fromTerm \"from\" (Term.hole \"_\")))]))\n               []\n               (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n               []\n               (Tactic.tacticInfer_instance \"infer_instance\")])])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.intro \"intro\" [`H `U `g `hg `V])\n            []\n            (Tactic.skip \"skip\")\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule\n                []\n                (Term.app (Term.proj (Term.app `hP.affine_open_cover_tfae [`f]) \".\" `out) [(num \"0\") (num \"3\")]))]\n              \"]\")\n             [(Tactic.location \"at\" (Tactic.locationHyp [`H] []))])\n            []\n            (Std.Tactic.tacticHaveI_\n             \"haveI\"\n             (Term.haveDecl\n              (Term.haveIdDecl\n               []\n               [(Term.typeSpec \":\" (Term.app `is_affine [(Term.hole \"_\")]))]\n               \":=\"\n               (Term.proj `V \".\" (fieldIdx \"2\")))))\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» \"â†\"))] `category.assoc)] \"]\")\n             [])\n            []\n            (Tactic.apply \"apply\" `H)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"â†’\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.intro \"intro\" [`H `ğ’° (Term.hole \"_\") `i]) [] (Tactic.skip \"skip\") [] (Tactic.apply \"apply\" `H)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"â†’\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.intro \"intro\" [`H])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor \"âŸ¨\" [`X.affine_cover \",\" (Term.app `H [(Term.hole \"_\")])] \"âŸ©\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"âŸ¨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hğ’°)])\n                  [])]\n                \"âŸ©\"))]\n             [])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule\n                []\n                (Term.app (Term.proj (Term.app `hP.affine_open_cover_tfae [`f]) \".\" `out) [(num \"0\") (num \"1\")]))]\n              \"]\")\n             [])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor\n              \"âŸ¨\"\n              [(Term.app\n                `ğ’°.bind\n                [(Term.fun\n                  \"fun\"\n                  (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `Scheme.affine_cover [(Term.hole \"_\")])))])\n               \",\"\n               (Term.hole \"_\")\n               \",\"\n               (Term.hole \"_\")]\n              \"âŸ©\"))\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n             [(Tactic.intro \"intro\" [`i])\n              []\n              (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n              []\n              (Tactic.tacticInfer_instance \"infer_instance\")])\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n             [(Tactic.intro \"intro\" [`i])\n              []\n              (Tactic.specialize \"specialize\" (Term.app `hğ’° [(Term.proj `i \".\" (fieldIdx \"1\"))]))\n              []\n              (Tactic.rwSeq\n               \"rw\"\n               []\n               (Tactic.rwRuleSeq\n                \"[\"\n                [(Tactic.rwRule\n                  []\n                  (Term.app\n                   (Term.proj\n                    (Term.app `hP.affine_open_cover_tfae [(Term.app `Â«expr â‰« Â» [(Term.app `ğ’°.map [`i.fst]) `f])])\n                    \".\"\n                    `out)\n                   [(num \"0\") (num \"3\")]))]\n                \"]\")\n               [(Tactic.location \"at\" (Tactic.locationHyp [`hğ’°] []))])\n              []\n              (Tactic.tacticErw__ \"erw\" (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `category.assoc)] \"]\") [])\n              []\n              (Tactic.apply\n               \"apply\"\n               (Term.app\n                (Term.explicit \"@\" `hğ’°)\n                [(Term.hole \"_\") (Term.show \"show\" (Term.hole \"_\") (Term.fromTerm \"from\" (Term.hole \"_\")))]))\n              []\n              (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n              []\n              (Tactic.tacticInfer_instance \"infer_instance\")])])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n       [(Std.Tactic.rintro\n         \"rintro\"\n         [(Std.Tactic.RCases.rintroPat.one\n           (Std.Tactic.RCases.rcasesPat.tuple\n            \"âŸ¨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hğ’°)])\n              [])]\n            \"âŸ©\"))]\n         [])\n        []\n        (Tactic.rwSeq\n         \"rw\"\n         []\n         (Tactic.rwRuleSeq\n          \"[\"\n          [(Tactic.rwRule\n            []\n            (Term.app (Term.proj (Term.app `hP.affine_open_cover_tfae [`f]) \".\" `out) [(num \"0\") (num \"1\")]))]\n          \"]\")\n         [])\n        []\n        (Tactic.refine'\n         \"refine'\"\n         (Term.anonymousCtor\n          \"âŸ¨\"\n          [(Term.app\n            `ğ’°.bind\n            [(Term.fun\n              \"fun\"\n              (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `Scheme.affine_cover [(Term.hole \"_\")])))])\n           \",\"\n           (Term.hole \"_\")\n           \",\"\n           (Term.hole \"_\")]\n          \"âŸ©\"))\n        []\n        (tactic__\n         (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n         [(Tactic.intro \"intro\" [`i])\n          []\n          (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n          []\n          (Tactic.tacticInfer_instance \"infer_instance\")])\n        []\n        (tactic__\n         (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n         [(Tactic.intro \"intro\" [`i])\n          []\n          (Tactic.specialize \"specialize\" (Term.app `hğ’° [(Term.proj `i \".\" (fieldIdx \"1\"))]))\n          []\n          (Tactic.rwSeq\n           \"rw\"\n           []\n           (Tactic.rwRuleSeq\n            \"[\"\n            [(Tactic.rwRule\n              []\n              (Term.app\n               (Term.proj\n                (Term.app `hP.affine_open_cover_tfae [(Term.app `Â«expr â‰« Â» [(Term.app `ğ’°.map [`i.fst]) `f])])\n                \".\"\n                `out)\n               [(num \"0\") (num \"3\")]))]\n            \"]\")\n           [(Tactic.location \"at\" (Tactic.locationHyp [`hğ’°] []))])\n          []\n          (Tactic.tacticErw__ \"erw\" (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `category.assoc)] \"]\") [])\n          []\n          (Tactic.apply\n           \"apply\"\n           (Term.app\n            (Term.explicit \"@\" `hğ’°)\n            [(Term.hole \"_\") (Term.show \"show\" (Term.hole \"_\") (Term.fromTerm \"from\" (Term.hole \"_\")))]))\n          []\n          (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n          []\n          (Tactic.tacticInfer_instance \"infer_instance\")])])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n       [(Tactic.intro \"intro\" [`i])\n        []\n        (Tactic.specialize \"specialize\" (Term.app `hğ’° [(Term.proj `i \".\" (fieldIdx \"1\"))]))\n        []\n        (Tactic.rwSeq\n         \"rw\"\n         []\n         (Tactic.rwRuleSeq\n          \"[\"\n          [(Tactic.rwRule\n            []\n            (Term.app\n             (Term.proj\n              (Term.app `hP.affine_open_cover_tfae [(Term.app `Â«expr â‰« Â» [(Term.app `ğ’°.map [`i.fst]) `f])])\n              \".\"\n              `out)\n             [(num \"0\") (num \"3\")]))]\n          \"]\")\n         [(Tactic.location \"at\" (Tactic.locationHyp [`hğ’°] []))])\n        []\n        (Tactic.tacticErw__ \"erw\" (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `category.assoc)] \"]\") [])\n        []\n        (Tactic.apply\n         \"apply\"\n         (Term.app\n          (Term.explicit \"@\" `hğ’°)\n          [(Term.hole \"_\") (Term.show \"show\" (Term.hole \"_\") (Term.fromTerm \"from\" (Term.hole \"_\")))]))\n        []\n        (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n        []\n        (Tactic.tacticInfer_instance \"infer_instance\")])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tacticInfer_instance \"infer_instance\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.apply\n       \"apply\"\n       (Term.app\n        (Term.explicit \"@\" `hğ’°)\n        [(Term.hole \"_\") (Term.show \"show\" (Term.hole \"_\") (Term.fromTerm \"from\" (Term.hole \"_\")))]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       (Term.explicit \"@\" `hğ’°)\n       [(Term.hole \"_\") (Term.show \"show\" (Term.hole \"_\") (Term.fromTerm \"from\" (Term.hole \"_\")))])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.show', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.show', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.show \"show\" (Term.hole \"_\") (Term.fromTerm \"from\" (Term.hole \"_\")))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1023, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren\n     \"(\"\n     (Term.show \"show\" (Term.hole \"_\") (Term.fromTerm \"from\" (Term.hole \"_\")))\n     \")\")\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      (Term.explicit \"@\" `hğ’°)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hğ’°\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (some 1024, term) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tacticErw__ \"erw\" (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `category.assoc)] \"]\") [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `category.assoc\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.rwSeq\n       \"rw\"\n       []\n       (Tactic.rwRuleSeq\n        \"[\"\n        [(Tactic.rwRule\n          []\n          (Term.app\n           (Term.proj\n            (Term.app `hP.affine_open_cover_tfae [(Term.app `Â«expr â‰« Â» [(Term.app `ğ’°.map [`i.fst]) `f])])\n            \".\"\n            `out)\n           [(num \"0\") (num \"3\")]))]\n        \"]\")\n       [(Tactic.location \"at\" (Tactic.locationHyp [`hğ’°] []))])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hğ’°\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       (Term.proj\n        (Term.app `hP.affine_open_cover_tfae [(Term.app `Â«expr â‰« Â» [(Term.app `ğ’°.map [`i.fst]) `f])])\n        \".\"\n        `out)\n       [(num \"0\") (num \"3\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'num', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'num', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (num \"3\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'num', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'num', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (num \"0\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      (Term.proj (Term.app `hP.affine_open_cover_tfae [(Term.app `Â«expr â‰« Â» [(Term.app `ğ’°.map [`i.fst]) `f])]) \".\" `out)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app `hP.affine_open_cover_tfae [(Term.app `Â«expr â‰« Â» [(Term.app `ğ’°.map [`i.fst]) `f])])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `Â«expr â‰« Â» [(Term.app `ğ’°.map [`i.fst]) `f])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `f\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app `ğ’°.map [`i.fst])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `i.fst\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `ğ’°.map\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `ğ’°.map [`i.fst]) \")\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `Â«expr â‰« Â»\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren\n     \"(\"\n     (Term.app `Â«expr â‰« Â» [(Term.paren \"(\" (Term.app `ğ’°.map [`i.fst]) \")\") `f])\n     \")\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `hP.affine_open_cover_tfae\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren\n     \"(\"\n     (Term.app\n      `hP.affine_open_cover_tfae\n      [(Term.paren \"(\" (Term.app `Â«expr â‰« Â» [(Term.paren \"(\" (Term.app `ğ’°.map [`i.fst]) \")\") `f]) \")\")])\n     \")\")\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.specialize \"specialize\" (Term.app `hğ’° [(Term.proj `i \".\" (fieldIdx \"1\"))]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `hğ’° [(Term.proj `i \".\" (fieldIdx \"1\"))])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.proj `i \".\" (fieldIdx \"1\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `i\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `hğ’°\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`i])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `i\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n       [(Tactic.intro \"intro\" [`i])\n        []\n        (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n        []\n        (Tactic.tacticInfer_instance \"infer_instance\")])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tacticInfer_instance \"infer_instance\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.dsimp \"dsimp\" [] [] [] [] [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`i])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `i\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.refine'\n       \"refine'\"\n       (Term.anonymousCtor\n        \"âŸ¨\"\n        [(Term.app\n          `ğ’°.bind\n          [(Term.fun\n            \"fun\"\n            (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `Scheme.affine_cover [(Term.hole \"_\")])))])\n         \",\"\n         (Term.hole \"_\")\n         \",\"\n         (Term.hole \"_\")]\n        \"âŸ©\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor\n       \"âŸ¨\"\n       [(Term.app\n         `ğ’°.bind\n         [(Term.fun \"fun\" (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `Scheme.affine_cover [(Term.hole \"_\")])))])\n        \",\"\n        (Term.hole \"_\")\n        \",\"\n        (Term.hole \"_\")]\n       \"âŸ©\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       `ğ’°.bind\n       [(Term.fun \"fun\" (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `Scheme.affine_cover [(Term.hole \"_\")])))])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun \"fun\" (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `Scheme.affine_cover [(Term.hole \"_\")])))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `Scheme.affine_cover [(Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `Scheme.affine_cover\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `ğ’°.bind\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.rwSeq\n       \"rw\"\n       []\n       (Tactic.rwRuleSeq\n        \"[\"\n        [(Tactic.rwRule\n          []\n          (Term.app (Term.proj (Term.app `hP.affine_open_cover_tfae [`f]) \".\" `out) [(num \"0\") (num \"1\")]))]\n        \"]\")\n       [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app (Term.proj (Term.app `hP.affine_open_cover_tfae [`f]) \".\" `out) [(num \"0\") (num \"1\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'num', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'num', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (num \"1\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'num', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'num', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (num \"0\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      (Term.proj (Term.app `hP.affine_open_cover_tfae [`f]) \".\" `out)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app `hP.affine_open_cover_tfae [`f])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `f\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `hP.affine_open_cover_tfae\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `hP.affine_open_cover_tfae [`f]) \")\")\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rintro\n       \"rintro\"\n       [(Std.Tactic.RCases.rintroPat.one\n         (Std.Tactic.RCases.rcasesPat.tuple\n          \"âŸ¨\"\n          [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hğ’°)]) [])]\n          \"âŸ©\"))]\n       [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â†’ Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â†” Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â† Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  open_cover_tfae\n  { X Y : Scheme .{ u } } [ is_affine Y ] ( f : Â«expr âŸ¶ Â» X Y )\n    :\n      TFAE\n        [\n          source_affine_locally @ P f\n            ,\n            âˆƒ ğ’° : Scheme.open_cover .{ u } X , âˆ€ i : ğ’° . J , source_affine_locally @ P Â«expr â‰« Â» ğ’° . map i f\n            ,\n            âˆ€ ( ğ’° : Scheme.open_cover .{ u } X ) ( i : ğ’° . J ) , source_affine_locally @ P Â«expr â‰« Â» ğ’° . map i f\n            ,\n            âˆ€ { U : Scheme } ( g : Â«expr âŸ¶ Â» U X ) [ is_open_immersion g ] , source_affine_locally @ P Â«expr â‰« Â» g f\n          ]\n  :=\n    by\n      tfae_have 1 â†’ 4\n        Â·\n          intro H U g hg V\n            skip\n            rw [ hP.affine_open_cover_tfae f . out 0 3 ] at H\n            haveI : is_affine _ := V . 2\n            rw [ â† category.assoc ]\n            apply H\n        tfae_have 4 â†’ 3\n        Â· intro H ğ’° _ i skip apply H\n        tfae_have 3 â†’ 2\n        Â· intro H refine' âŸ¨ X.affine_cover , H _ âŸ©\n        tfae_have 2 â†’ 1\n        Â·\n          rintro âŸ¨ ğ’° , hğ’° âŸ©\n            rw [ hP.affine_open_cover_tfae f . out 0 1 ]\n            refine' âŸ¨ ğ’°.bind fun _ => Scheme.affine_cover _ , _ , _ âŸ©\n            Â· intro i dsimp infer_instance\n            Â·\n              intro i\n                specialize hğ’° i . 1\n                rw [ hP.affine_open_cover_tfae Â«expr â‰« Â» ğ’°.map i.fst f . out 0 3 ] at hğ’°\n                erw [ category.assoc ]\n                apply @ hğ’° _ show _ from _\n                dsimp\n                infer_instance\n        tfae_finish\n#align open_cover_tfae open_cover_tfae\n\n",
 "of_restrict_morphism_restrict_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem respects_iso.of_restrict_morphism_restrict_iff (hP : ring_hom.respects_iso @P) {X Y : Scheme} [is_affine Y]\n    (f : Â«expr âŸ¶ Â» X Y) (r : Y.presheaf.obj (opposite.op (Â«exprâŠ¤Â»))) (U : opens X.carrier) (hU : is_affine_open U)\n    {V : opens _} (e : V = (opens.map (X.of_restrict ((opens.map f.1.base).obj _).open_embedding).1.base).obj U) :\n    P\n        (Scheme.Î“.map\n          (Â«expr â‰« Â» ((X.restrict ((opens.map f.1.base).obj _).open_embedding).of_restrict V.open_embedding)\n              (Â«expr âˆ£_ Â» f (Y.basic_open r))).op) â†”\n      P (localization.away_map (Scheme.Î“.map (Â«expr â‰« Â» (X.of_restrict U.open_embedding) f).op) r) :=\n  by\n  subst e\n  convert (hP.is_localization_away_iff _ _ _ _).symm\n  rotate_left\n  Â· infer_instance\n  Â· apply ring_hom.to_algebra\n    refine' X.presheaf.map (@hom_of_le _ _ ((is_open_map.functor _).obj _) ((is_open_map.functor _).obj _) _).op\n    rw [opens.le_def]\n    dsimp\n    change Â«expr '' Â» coe (Â«expr '' Â» coe Set.univ) âŠ† Â«expr '' Â» coe Set.univ\n    rw [Subtype.coe_image_univ, Subtype.coe_image_univ]\n    exact Set.image_preimage_subset _ _\n  Â· exact algebraic_geometry.Î“_restrict_is_localization Y r\n  Â· rw [â† U.open_embedding_obj_top] at hU\n    dsimp [Scheme.Î“_obj_op, Scheme.Î“_map_op, Scheme.restrict]\n    apply algebraic_geometry.is_localization_of_eq_basic_open _ hU\n    rw [opens.open_embedding_obj_top, opens.functor_obj_map_obj]\n    convert (X.basic_open_res (Scheme.Î“.map f.op r) (hom_of_le le_top).op).symm using 1\n    rw [opens.open_embedding_obj_top, opens.open_embedding_obj_top, inf_comm, Scheme.Î“_map_op, â†\n      Scheme.preimage_basic_open]\n  Â· apply is_localization.ring_hom_ext (submonoid.powers r) _\n    swap\n    Â· exact algebraic_geometry.Î“_restrict_is_localization Y r\n    rw [is_localization.away.map, is_localization.map_comp, ring_hom.algebra_map_to_algebra,\n      ring_hom.algebra_map_to_algebra, op_comp, functor.map_comp, op_comp, functor.map_comp]\n    refine' (@category.assoc CommRing _ _ _ _ _ _ _ _).symm.trans _\n    refine' eq.trans _ (@category.assoc CommRing _ _ _ _ _ _ _ _)\n    dsimp only [Scheme.Î“_map, quiver.hom.unop_op]\n    rw [morphism_restrict_c_app, category.assoc, category.assoc, category.assoc]\n    erw [f.1.c.naturality_assoc, â† X.presheaf.map_comp, â† X.presheaf.map_comp, â† X.presheaf.map_comp]\n    congr\n#align respects_iso.of_restrict_morphism_restrict_iff respects_iso.of_restrict_morphism_restrict_iff\n\n",
 "is_open_immersion_comp_of_source_affine_locally":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_open_immersion_comp_of_source_affine_locally (hâ‚ : ring_hom.respects_iso @P) {X Y Z : Scheme} [is_affine X]\n    [is_affine Z] (f : Â«expr âŸ¶ Â» X Y) [is_open_immersion f] (g : Â«expr âŸ¶ Â» Y Z) (hâ‚‚ : source_affine_locally (@P) g) :\n    P (Scheme.Î“.map (Â«expr â‰« Â» f g).op) :=\n  by\n  rw [â† hâ‚.cancel_right_is_iso _ (Scheme.Î“.map (is_open_immersion.iso_of_range_eq (Y.of_restrict _) f _).hom.op), â†\n    functor.map_comp, â† op_comp]\n  convert hâ‚‚ âŸ¨_, range_is_affine_open_of_open_immersion fâŸ© using 3\n  Â· rw [is_open_immersion.iso_of_range_eq_hom, is_open_immersion.lift_fac_assoc]\n  Â· infer_instance\n  Â· exact Subtype.range_coe\n  Â· infer_instance\n#align is_open_immersion_comp_of_source_affine_locally is_open_immersion_comp_of_source_affine_locally\n\n",
 "is_local_source_affine_locally":
 "theorem is_local_source_affine_locally : (source_affine_locally @P).is_local :=\n  source_affine_locally_is_local hP.respects_iso hP.localization_preserves\n    (@ring_hom.property_is_local.of_localization_span _ hP)\n#align is_local_source_affine_locally is_local_source_affine_locally\n\n",
 "is_local_affine_locally":
 "theorem is_local_affine_locally : property_is_local_at_target (affine_locally @P) :=\n  hP.is_local_source_affine_locally.target_affine_locally_is_local\n#align is_local_affine_locally is_local_affine_locally\n\n",
 "basic_open_iff_localization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\ntheorem respects_iso.basic_open_iff_localization (hP : respects_iso @P) {X Y : Scheme} [is_affine X] [is_affine Y]\n    (f : Â«expr âŸ¶ Â» X Y) (r : Y.presheaf.obj (opposite.op (Â«exprâŠ¤Â»))) :\n    P (Scheme.Î“.map (Â«expr âˆ£_ Â» f (Y.basic_open r)).op) â†” P (localization.away_map (Scheme.Î“.map f.op) r) :=\n  (hP.basic_open_iff _ _).trans (hP.is_localization_away_iff _ _ _ _).symm\n#align respects_iso.basic_open_iff_localization respects_iso.basic_open_iff_localization\n\n",
 "basic_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem respects_iso.basic_open_iff (hP : respects_iso @P) {X Y : Scheme} [is_affine X] [is_affine Y]\n    (f : Â«expr âŸ¶ Â» X Y) (r : Y.presheaf.obj (opposite.op (Â«exprâŠ¤Â»))) :\n    P (Scheme.Î“.map (Â«expr âˆ£_ Â» f (Y.basic_open r)).op) â†”\n      P\n        (@is_localization.away.map (Y.presheaf.obj (opposite.op (Â«exprâŠ¤Â»))) _\n          (Y.presheaf.obj (opposite.op <| Y.basic_open r)) _ _ (X.presheaf.obj (opposite.op (Â«exprâŠ¤Â»))) _\n          (X.presheaf.obj (opposite.op <| X.basic_open (Scheme.Î“.map f.op r))) _ _ (Scheme.Î“.map f.op) r _ _) :=\n  by\n  rw [Î“_map_morphism_restrict, hP.cancel_left_is_iso, hP.cancel_right_is_iso, â†\n    hP.cancel_right_is_iso (f.val.c.app (opposite.op (Y.basic_open r)))\n      (X.presheaf.map (eq_to_hom (Scheme.preimage_basic_open f r).symm).op),\n    â† eq_iff_iff]\n  congr\n  delta is_localization.away.map\n  refine' is_localization.ring_hom_ext (submonoid.powers r) _\n  convert (is_localization.map_comp _).symm using 1\n  change Â«expr â‰« Â» (Y.presheaf.map _) _ = Â«expr â‰« Â» _ (X.presheaf.map _)\n  rw [f.val.c.naturality_assoc]\n  erw [â† X.presheaf.map_comp]\n  congr\n#align respects_iso.basic_open_iff respects_iso.basic_open_iff\n\n",
 "affine_open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `affine_open_cover_tfae [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`X `Y] [\":\" (Term.explicitUniv `Scheme \".{\" [`u] \"}\")] \"}\")\n        (Term.instBinder \"[\" [] (Term.app `is_affine [`Y]) \"]\")\n        (Term.explicitBinder \"(\" [`f] [\":\" (Term.app `Â«expr âŸ¶ Â» [`X `Y])] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(Â«term[_]Â»\n           \"[\"\n           [(Term.app `source_affine_locally [(Term.explicit \"@\" `P) `f])\n            \",\"\n            (Â«termâˆƒ_,_Â»\n             \"âˆƒ\"\n             (Lean.explicitBinders\n              [(Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `ğ’°)]\n                \":\"\n                (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`X])\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent (Term.hole \"_\"))]\n                \":\"\n                (Term.forall \"âˆ€\" [`i] [] \",\" (Term.app `is_affine [(Term.app (Term.proj `ğ’° \".\" `obj) [`i])]))\n                \")\")])\n             \",\"\n             (Term.forall\n              \"âˆ€\"\n              [`i]\n              [(Term.typeSpec \":\" (Term.proj `ğ’° \".\" `J))]\n              \",\"\n              (Term.app\n               `P\n               [(Term.app\n                 (Term.proj `Scheme.Î“ \".\" `map)\n                 [(Term.proj (Term.app `Â«expr â‰« Â» [(Term.app (Term.proj `ğ’° \".\" `map) [`i]) `f]) \".\" `op)])])))\n            \",\"\n            (Term.forall\n             \"âˆ€\"\n             [(Term.explicitBinder\n               \"(\"\n               [`ğ’°]\n               [\":\" (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`X])]\n               []\n               \")\")\n              (Term.instBinder\n               \"[\"\n               []\n               (Term.forall \"âˆ€\" [`i] [] \",\" (Term.app `is_affine [(Term.app (Term.proj `ğ’° \".\" `obj) [`i])]))\n               \"]\")\n              (Term.explicitBinder \"(\" [`i] [\":\" (Term.proj `ğ’° \".\" `J)] [] \")\")]\n             []\n             \",\"\n             (Term.app\n              `P\n              [(Term.app\n                (Term.proj `Scheme.Î“ \".\" `map)\n                [(Term.proj (Term.app `Â«expr â‰« Â» [(Term.app (Term.proj `ğ’° \".\" `map) [`i]) `f]) \".\" `op)])]))\n            \",\"\n            (Term.forall\n             \"âˆ€\"\n             [(Term.implicitBinder \"{\" [`U] [\":\" `Scheme] \"}\")\n              (Term.explicitBinder \"(\" [`g] [\":\" (Term.app `Â«expr âŸ¶ Â» [`U `X])] [] \")\")\n              (Term.instBinder \"[\" [] (Term.app `is_affine [`U]) \"]\")\n              (Term.instBinder \"[\" [] (Term.app `is_open_immersion [`g]) \"]\")]\n             []\n             \",\"\n             (Term.app\n              `P\n              [(Term.app (Term.proj `Scheme.Î“ \".\" `map) [(Term.proj (Term.app `Â«expr â‰« Â» [`g `f]) \".\" `op)])]))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.intro \"intro\" [`H `U `g (Term.hole \"_\") `hg])\n             []\n             (Tactic.skip \"skip\")\n             []\n             (Tactic.specialize\n              \"specialize\"\n              (Term.app\n               `H\n               [(Term.anonymousCtor\n                 \"âŸ¨\"\n                 [(Term.anonymousCtor \"âŸ¨\" [(Term.hole \"_\") \",\" `hg.base_open.open_range] \"âŸ©\")\n                  \",\"\n                  (Term.app `range_is_affine_open_of_open_immersion [`g])]\n                 \"âŸ©\")]))\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule\n                 [(patternIgnore (token.Â«â† Â» \"â†\"))]\n                 (Term.app\n                  `hP.respects_iso.cancel_right_is_iso\n                  [(Term.hole \"_\")\n                   (Term.app\n                    `Scheme.Î“.map\n                    [(Term.proj\n                      (Term.proj\n                       (Term.app\n                        `is_open_immersion.iso_of_range_eq\n                        [`g\n                         (Term.app\n                          `X.of_restrict\n                          [(Term.app\n                            `opens.open_embedding\n                            [(Term.anonymousCtor \"âŸ¨\" [(Term.hole \"_\") \",\" `hg.base_open.open_range] \"âŸ©\")])])\n                         `subtype.range_coe.symm])\n                       \".\"\n                       `hom)\n                      \".\"\n                      `op)])]))\n                \",\"\n                (Tactic.rwRule [(patternIgnore (token.Â«â† Â» \"â†\"))] `Scheme.Î“.map_comp)\n                \",\"\n                (Tactic.rwRule [(patternIgnore (token.Â«â† Â» \"â†\"))] `op_comp)\n                \",\"\n                (Tactic.rwRule [] `is_open_immersion.iso_of_range_eq_hom)]\n               \"]\")\n              [(Tactic.location \"at\" (Tactic.locationHyp [`H] []))])\n             []\n             (Tactic.tacticErw__\n              \"erw\"\n              (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `is_open_immersion.lift_fac_assoc)] \"]\")\n              [(Tactic.location \"at\" (Tactic.locationHyp [`H] []))])\n             []\n             (Tactic.exact \"exact\" `H)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"â†’\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.intro \"intro\" [`H `ğ’° (Term.hole \"_\") `i]) [] (Tactic.skip \"skip\") [] (Tactic.apply \"apply\" `H)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"â†’\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.intro \"intro\" [`H])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor \"âŸ¨\" [`X.affine_cover \",\" `infer_instance \",\" (Term.app `H [(Term.hole \"_\")])] \"âŸ©\"))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"âŸ¨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hğ’°)])\n                   [])]\n                 \"âŸ©\"))]\n              [])\n             []\n             (Tactic.exact \"exact\" (Term.app `hP.source_affine_locally_of_source_open_cover [`f `ğ’° `hğ’°]))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.intro \"intro\" [`H `U `g (Term.hole \"_\") `hg])\n            []\n            (Tactic.skip \"skip\")\n            []\n            (Tactic.specialize\n             \"specialize\"\n             (Term.app\n              `H\n              [(Term.anonymousCtor\n                \"âŸ¨\"\n                [(Term.anonymousCtor \"âŸ¨\" [(Term.hole \"_\") \",\" `hg.base_open.open_range] \"âŸ©\")\n                 \",\"\n                 (Term.app `range_is_affine_open_of_open_immersion [`g])]\n                \"âŸ©\")]))\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule\n                [(patternIgnore (token.Â«â† Â» \"â†\"))]\n                (Term.app\n                 `hP.respects_iso.cancel_right_is_iso\n                 [(Term.hole \"_\")\n                  (Term.app\n                   `Scheme.Î“.map\n                   [(Term.proj\n                     (Term.proj\n                      (Term.app\n                       `is_open_immersion.iso_of_range_eq\n                       [`g\n                        (Term.app\n                         `X.of_restrict\n                         [(Term.app\n                           `opens.open_embedding\n                           [(Term.anonymousCtor \"âŸ¨\" [(Term.hole \"_\") \",\" `hg.base_open.open_range] \"âŸ©\")])])\n                        `subtype.range_coe.symm])\n                      \".\"\n                      `hom)\n                     \".\"\n                     `op)])]))\n               \",\"\n               (Tactic.rwRule [(patternIgnore (token.Â«â† Â» \"â†\"))] `Scheme.Î“.map_comp)\n               \",\"\n               (Tactic.rwRule [(patternIgnore (token.Â«â† Â» \"â†\"))] `op_comp)\n               \",\"\n               (Tactic.rwRule [] `is_open_immersion.iso_of_range_eq_hom)]\n              \"]\")\n             [(Tactic.location \"at\" (Tactic.locationHyp [`H] []))])\n            []\n            (Tactic.tacticErw__\n             \"erw\"\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `is_open_immersion.lift_fac_assoc)] \"]\")\n             [(Tactic.location \"at\" (Tactic.locationHyp [`H] []))])\n            []\n            (Tactic.exact \"exact\" `H)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"â†’\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.intro \"intro\" [`H `ğ’° (Term.hole \"_\") `i]) [] (Tactic.skip \"skip\") [] (Tactic.apply \"apply\" `H)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"â†’\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.intro \"intro\" [`H])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor \"âŸ¨\" [`X.affine_cover \",\" `infer_instance \",\" (Term.app `H [(Term.hole \"_\")])] \"âŸ©\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"âŸ¨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hğ’°)])\n                  [])]\n                \"âŸ©\"))]\n             [])\n            []\n            (Tactic.exact \"exact\" (Term.app `hP.source_affine_locally_of_source_open_cover [`f `ğ’° `hğ’°]))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n       [(Std.Tactic.rintro\n         \"rintro\"\n         [(Std.Tactic.RCases.rintroPat.one\n           (Std.Tactic.RCases.rcasesPat.tuple\n            \"âŸ¨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n              [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hğ’°)])\n              [])]\n            \"âŸ©\"))]\n         [])\n        []\n        (Tactic.exact \"exact\" (Term.app `hP.source_affine_locally_of_source_open_cover [`f `ğ’° `hğ’°]))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.app `hP.source_affine_locally_of_source_open_cover [`f `ğ’° `hğ’°]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `hP.source_affine_locally_of_source_open_cover [`f `ğ’° `hğ’°])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hğ’°\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `ğ’°\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `f\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `hP.source_affine_locally_of_source_open_cover\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rintro\n       \"rintro\"\n       [(Std.Tactic.RCases.rintroPat.one\n         (Std.Tactic.RCases.rcasesPat.tuple\n          \"âŸ¨\"\n          [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo\n            (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n            [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hğ’°)]) [])]\n          \"âŸ©\"))]\n       [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â†’ Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â†” Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â† Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  affine_open_cover_tfae\n  { X Y : Scheme .{ u } } [ is_affine Y ] ( f : Â«expr âŸ¶ Â» X Y )\n    :\n      TFAE\n        [\n          source_affine_locally @ P f\n            ,\n            âˆƒ\n              ( ğ’° : Scheme.open_cover .{ u } X ) ( _ : âˆ€ i , is_affine ğ’° . obj i )\n              ,\n              âˆ€ i : ğ’° . J , P Scheme.Î“ . map Â«expr â‰« Â» ğ’° . map i f . op\n            ,\n            âˆ€\n              ( ğ’° : Scheme.open_cover .{ u } X ) [ âˆ€ i , is_affine ğ’° . obj i ] ( i : ğ’° . J )\n              ,\n              P Scheme.Î“ . map Â«expr â‰« Â» ğ’° . map i f . op\n            ,\n            âˆ€\n              { U : Scheme } ( g : Â«expr âŸ¶ Â» U X ) [ is_affine U ] [ is_open_immersion g ]\n              ,\n              P Scheme.Î“ . map Â«expr â‰« Â» g f . op\n          ]\n  :=\n    by\n      tfae_have 1 â†’ 4\n        Â·\n          intro H U g _ hg\n            skip\n            specialize H âŸ¨ âŸ¨ _ , hg.base_open.open_range âŸ© , range_is_affine_open_of_open_immersion g âŸ©\n            rw\n              [\n                â†\n                    hP.respects_iso.cancel_right_is_iso\n                      _\n                        Scheme.Î“.map\n                          is_open_immersion.iso_of_range_eq\n                                g\n                                  X.of_restrict opens.open_embedding âŸ¨ _ , hg.base_open.open_range âŸ©\n                                  subtype.range_coe.symm\n                              .\n                              hom\n                            .\n                            op\n                  ,\n                  â† Scheme.Î“.map_comp\n                  ,\n                  â† op_comp\n                  ,\n                  is_open_immersion.iso_of_range_eq_hom\n                ]\n              at H\n            erw [ is_open_immersion.lift_fac_assoc ] at H\n            exact H\n        tfae_have 4 â†’ 3\n        Â· intro H ğ’° _ i skip apply H\n        tfae_have 3 â†’ 2\n        Â· intro H refine' âŸ¨ X.affine_cover , infer_instance , H _ âŸ©\n        tfae_have 2 â†’ 1\n        Â· rintro âŸ¨ ğ’° , _ , hğ’° âŸ© exact hP.source_affine_locally_of_source_open_cover f ğ’° hğ’°\n        tfae_finish\n#align affine_open_cover_tfae affine_open_cover_tfae\n\n",
 "affine_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem affine_open_cover_iff {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) (ğ’° : Scheme.open_cover.{u} Y)\n    [âˆ€ i, is_affine (ğ’°.obj i)] (ğ’°' : âˆ€ i, Scheme.open_cover.{u} ((ğ’°.pullback_cover f).obj i))\n    [âˆ€ i j, is_affine ((ğ’°' i).obj j)] :\n    affine_locally (@P) f â†” âˆ€ i j, P (Scheme.Î“.map (Â«expr â‰« Â» ((ğ’°' i).map j) pullback.snd).op) :=\n  (hP.is_local_source_affine_locally.affine_open_cover_iff f ğ’°).trans\n    (forall_congr' fun i => hP.source_affine_open_cover_iff _ (ğ’°' i))\n#align affine_open_cover_iff affine_open_cover_iff\n\n",
 "affine_locally_stable_under_composition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem affine_locally_stable_under_composition : (affine_locally @P).stable_under_composition :=\n  by\n  intro X Y S f g hf hg\n  let ğ’° : âˆ€ i, ((S.affine_cover.pullback_cover (Â«expr â‰« Â» f g)).obj i).open_cover :=\n    by\n    intro i\n    refine' Scheme.open_cover.bind _ fun i => Scheme.affine_cover _\n    apply Scheme.open_cover.pushforward_iso _ (pullback_right_pullback_fst_iso g (S.affine_cover.map i) f).hom\n    apply Scheme.pullback.open_cover_of_right\n    exact (pullback g (S.affine_cover.map i)).affine_cover\n  rw [hP.affine_open_cover_iff (Â«expr â‰« Â» f g) S.affine_cover _]\n  rotate_left\n  Â· exact ğ’°\n  Â· intro i j\n    dsimp at *\n    infer_instance\n  Â· rintro i âŸ¨j, kâŸ©\n    dsimp at i j k\n    dsimp only [Scheme.open_cover.bind_map, Scheme.open_cover.pushforward_iso_obj,\n      Scheme.pullback.open_cover_of_right_obj, Scheme.open_cover.pushforward_iso_map,\n      Scheme.pullback.open_cover_of_right_map, Scheme.open_cover.bind_obj]\n    rw [category.assoc, category.assoc, pullback_right_pullback_fst_iso_hom_snd, pullback.lift_snd_assoc,\n      category.assoc, â† category.assoc, op_comp, functor.map_comp]\n    apply hP.stable_under_composition\n    Â· exact (hP.affine_open_cover_iff _ _ _).mp hg _ _\n    Â· delta affine_locally at hf\n      rw [(hP.is_local_source_affine_locally.affine_open_cover_tfae f).out 0 3] at hf\n      specialize hf (Â«expr â‰« Â» ((pullback g (S.affine_cover.map i)).affine_cover.map j) pullback.fst)\n      rw [(hP.affine_open_cover_tfae\n              (pullback.snd :\n                Â«expr âŸ¶ Â» (pullback f (Â«expr â‰« Â» ((pullback g (S.affine_cover.map i)).affine_cover.map j) pullback.fst))\n                  _)).out\n          0 3] at\n        hf\n      apply hf\n#align affine_locally_stable_under_composition affine_locally_stable_under_composition\n\n",
 "affine_locally_respects_iso":
 "theorem affine_locally_respects_iso (h : ring_hom.respects_iso @P) : (affine_locally @P).respects_iso :=\n  target_affine_locally_respects_iso (source_affine_locally_respects_iso h)\n#align affine_locally_respects_iso affine_locally_respects_iso\n\n",
 "affine_locally_of_is_open_immersion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem affine_locally_of_is_open_immersion (hP : ring_hom.property_is_local @P) {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y)\n    [hf : is_open_immersion f] : affine_locally (@P) f :=\n  by\n  intro U\n  haveI H : is_affine _ := U.2\n  rw [â† category.comp_id (Â«expr âˆ£_ Â» f U)]\n  apply hP.source_affine_locally_comp_of_is_open_immersion\n  rw [hP.source_affine_open_cover_iff _ (Scheme.open_cover_of_is_iso ((Â«exprğŸ™Â») _))]\n  Â· intro i\n    erw [category.id_comp, op_id, Scheme.Î“.map_id]\n    convert hP.holds_for_localization_away _ (1 : Scheme.Î“.obj _)\n    Â· exact (ring_hom.algebra_map_to_algebra _).symm\n    Â· infer_instance\n    Â· refine' is_localization.away_of_is_unit_of_bijective _ isUnit_one function.bijective_id\n  Â· intro i\n    exact H\n#align affine_locally_of_is_open_immersion affine_locally_of_is_open_immersion\n\n",
 "affine_locally_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’+* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’+* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem affine_locally_of_comp\n    (H :\n      âˆ€ {R S T : Type u} [CommRing R] [CommRing S] [CommRing T],\n        âˆ€ (f : Â«expr â†’+* Â» R S) (g : Â«expr â†’+* Â» S T), P (g.comp f) â†’ P g)\n    {X Y Z : Scheme} {f : Â«expr âŸ¶ Â» X Y} {g : Â«expr âŸ¶ Â» Y Z} (h : affine_locally (@P) (Â«expr â‰« Â» f g)) :\n    affine_locally (@P) f :=\n  by\n  let ğ’° : âˆ€ i, ((Z.affine_cover.pullback_cover (Â«expr â‰« Â» f g)).obj i).open_cover :=\n    by\n    intro i\n    refine' Scheme.open_cover.bind _ fun i => Scheme.affine_cover _\n    apply Scheme.open_cover.pushforward_iso _ (pullback_right_pullback_fst_iso g (Z.affine_cover.map i) f).hom\n    apply Scheme.pullback.open_cover_of_right\n    exact (pullback g (Z.affine_cover.map i)).affine_cover\n  have hğ’° : âˆ€ i j, is_affine ((ğ’° i).obj j) := by\n    dsimp\n    infer_instance\n  let ğ’°' := (Z.affine_cover.pullback_cover g).bind fun i => Scheme.affine_cover _\n  have hğ’°' : âˆ€ i, is_affine (ğ’°'.obj i) := by\n    dsimp\n    infer_instance\n  rw [hP.affine_open_cover_iff f ğ’°' fun i => Scheme.affine_cover _]\n  rw [hP.affine_open_cover_iff (Â«expr â‰« Â» f g) Z.affine_cover ğ’°] at h\n  rintro âŸ¨i, jâŸ© k\n  dsimp at i j k\n  specialize h i âŸ¨j, kâŸ©\n  dsimp only [Scheme.open_cover.bind_map, Scheme.open_cover.pushforward_iso_obj,\n    Scheme.pullback.open_cover_of_right_obj, Scheme.open_cover.pushforward_iso_map,\n    Scheme.pullback.open_cover_of_right_map, Scheme.open_cover.bind_obj, Scheme.open_cover.pullback_cover_obj,\n    Scheme.open_cover.pullback_cover_map] at hâŠ¢\n  rw [category.assoc, category.assoc, pullback_right_pullback_fst_iso_hom_snd, pullback.lift_snd_assoc, category.assoc,\n    â† category.assoc, op_comp, functor.map_comp] at h\n  exact H _ _ h\n#align affine_locally_of_comp affine_locally_of_comp\n\n",
 "affine_locally_iff_affine_opens_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem affine_locally_iff_affine_opens_le (hP : ring_hom.respects_iso @P) {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) :\n    affine_locally (@P) f â†”\n      âˆ€ (U : Y.affine_opens) (V : X.affine_opens) (e : V.1 â‰¤ (opens.map f.1.base).obj U.1), P (f.app_le e) :=\n  by\n  apply forall_congr'\n  intro U\n  delta source_affine_locally\n  simp_rw [op_comp, Scheme.Î“.map_comp, Î“_map_morphism_restrict, category.assoc, Scheme.Î“_map_op, hP.cancel_left_is_iso]\n  constructor\n  Â· intro H V e\n    let U' := (opens.map f.val.base).obj U.1\n    have e' : U'.open_embedding.is_open_map.functor.obj ((opens.map U'.inclusion).obj V.1) = V.1 :=\n      by\n      ext1\n      refine' set.image_preimage_eq_inter_range.trans (set.inter_eq_left_iff_subset.mpr _)\n      convert e\n      exact Subtype.range_coe\n    have := H âŸ¨(opens.map (X.of_restrict U'.open_embedding).1.base).obj V.1, _âŸ©\n    erw [â† X.presheaf.map_comp] at this\n    rw [â† hP.cancel_right_is_iso _ (X.presheaf.map (eq_to_hom _)), category.assoc, â† X.presheaf.map_comp]\n    convert this using 1\n    Â· dsimp only [functor.op, unop_op]\n      rw [opens.open_embedding_obj_top]\n      congr 1\n      exact e'.symm\n    Â· infer_instance\n    Â· apply (is_affine_open_iff_of_is_open_immersion (X.of_restrict _) _).mp\n      convert V.2\n      infer_instance\n  Â· intro H V\n    specialize H âŸ¨_, V.2.image_is_open_immersion (X.of_restrict _)âŸ© (Subtype.coe_image_subset _ _)\n    erw [â† X.presheaf.map_comp]\n    rw [â† hP.cancel_right_is_iso _ (X.presheaf.map (eq_to_hom _)), category.assoc, â† X.presheaf.map_comp]\n    convert H\n    Â· dsimp only [functor.op, unop_op]\n      rw [opens.open_embedding_obj_top]\n      rfl\n    Â· infer_instance\n#align affine_locally_iff_affine_opens_le affine_locally_iff_affine_opens_le\n\n",
 "Scheme_restrict_basic_open_of_localization_preserves":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\ntheorem Scheme_restrict_basic_open_of_localization_preserves (hâ‚ : ring_hom.respects_iso @P)\n    (hâ‚‚ : ring_hom.localization_preserves @P) {X Y : Scheme} [is_affine Y] (f : Â«expr âŸ¶ Â» X Y)\n    (r : Y.presheaf.obj (op (Â«exprâŠ¤Â»))) (H : source_affine_locally (@P) f)\n    (U : (X.restrict ((opens.map f.1.base).obj <| Y.basic_open r).open_embedding).affine_opens) :\n    P\n      (Scheme.Î“.map\n        (Â«expr â‰« Â»\n            ((X.restrict ((opens.map f.1.base).obj <| Y.basic_open r).open_embedding).of_restrict U.1.open_embedding)\n            (Â«expr âˆ£_ Â» f (Y.basic_open r))).op) :=\n  by\n  specialize H âŸ¨_, U.2.image_is_open_immersion (X.of_restrict _)âŸ©\n  convert (hâ‚.of_restrict_morphism_restrict_iff _ _ _ _ _).mpr _ using 1\n  pick_goal 5\n  Â· exact hâ‚‚.away r H\n  Â· infer_instance\n  Â· exact U.2.image_is_open_immersion _\n  Â· ext1\n    exact (Set.preimage_image_eq _ subtype.coe_injective).symm\n#align Scheme_restrict_basic_open_of_localization_preserves Scheme_restrict_basic_open_of_localization_preserves\n\n"}