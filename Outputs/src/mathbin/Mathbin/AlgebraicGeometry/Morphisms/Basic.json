{"universally_is_local_at_target_of_morphism_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\ntheorem universally_is_local_at_target_of_morphism_restrict (P : MorphismProperty Scheme) (hPâ‚ : P.respects_iso)\n    (hPâ‚‚ :\n      âˆ€ {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) {Î¹ : Type u} (U : Î¹ â†’ Opens Y.carrier) (hU : supáµ¢ U = Â«exprâŠ¤Â»),\n        (âˆ€ i, P (Â«expr âˆ£_ Â» f (U i))) â†’ P f) :\n    property_is_local_at_target P.universally :=\n  universally_is_local_at_target P\n    (by\n      intro X Y f ğ’° hğ’°\n      apply hPâ‚‚ f (fun i : ğ’°.J => (ğ’°.map i).opens_range) ğ’°.supr_opens_range\n      simp_rw [hPâ‚.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]\n      exact hğ’°)\n#align universally_is_local_at_target_of_morphism_restrict universally_is_local_at_target_of_morphism_restrict\n\n",
 "universally_is_local_at_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem universally_is_local_at_target (P : MorphismProperty Scheme)\n    (hP :\n      âˆ€ {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) (ğ’° : Scheme.open_cover.{u} Y),\n        (âˆ€ i : ğ’°.J, P (pullback.snd : Â«expr âŸ¶ Â» ((ğ’°.pullback_cover f).obj i) (ğ’°.obj i))) â†’ P f) :\n    property_is_local_at_target P.universally :=\n  by\n  refine'\n    âŸ¨P.universally_respects_iso, fun X Y f U =>\n      P.universally_stable_under_base_change (is_pullback_morphism_restrict f U).flip, _âŸ©\n  intro X Y f ğ’° h X' Y' iâ‚ iâ‚‚ f' H\n  apply hP _ (ğ’°.pullback_cover iâ‚‚)\n  intro i\n  dsimp\n  apply h i (pullback.lift (Â«expr â‰« Â» pullback.fst iâ‚) (Â«expr â‰« Â» pullback.snd pullback.snd) _) pullback.snd\n  swap\n  Â· rw [category.assoc, category.assoc, â† pullback.condition, â† pullback.condition_assoc, H.w]\n  refine' (is_pullback.of_right _ (pullback.lift_snd _ _ _) (is_pullback.of_has_pullback _ _)).flip\n  rw [pullback.lift_fst, â† pullback.condition]\n  exact (is_pullback.of_has_pullback _ _).paste_horiz H.flip\n#align universally_is_local_at_target universally_is_local_at_target\n\n",
 "to_property_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem affine_target_morphism_property.to_property_apply (P : affine_target_morphism_property) {X Y : Scheme}\n    (f : Â«expr âŸ¶ Â» X Y) [is_affine Y] : P.to_property f â†” P f :=\n  by\n  delta affine_target_morphism_property.to_property\n  simp [*]\n#align affine_target_morphism_property.to_property_apply affine_target_morphism_property.to_property_apply\n\n",
 "target_affine_locally_respects_iso":
 "theorem target_affine_locally_respects_iso {P : affine_target_morphism_property} (hP : P.to_property.respects_iso) :\n    (target_affine_locally P).respects_iso := by\n  constructor\n  Â· introv H U\n    rw [morphism_restrict_comp, affine_cancel_left_is_iso hP]\n    exact H U\n  Â· introv H\n    rintro âŸ¨U, hU : is_affine_open UâŸ©\n    dsimp\n    haveI : is_affine _ := hU\n    haveI : is_affine _ := hU.map_is_iso e.hom\n    rw [morphism_restrict_comp, affine_cancel_right_is_iso hP]\n    exact H âŸ¨(opens.map e.hom.val.base).obj U, hU.map_is_iso e.homâŸ©\n#align target_affine_locally_respects_iso target_affine_locally_respects_iso\n\n",
 "target_affine_locally_pullback_fst_of_right_of_stable_under_base_change":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_local.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change\n    {P : affine_target_morphism_property} (hP : P.is_local) (hP' : P.stable_under_base_change) {X Y S : Scheme}\n    (f : Â«expr âŸ¶ Â» X S) (g : Â«expr âŸ¶ Â» Y S) [is_affine S] (H : P g) :\n    target_affine_locally P (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) X) :=\n  by\n  rw [(hP.affine_open_cover_tfae (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) X)).out 0 1]\n  use X.affine_cover, inferInstance\n  intro i\n  let e := Â«expr â‰ªâ‰« Â» (pullback_symmetry _ _) (pullback_right_pullback_fst_iso f g (X.affine_cover.map i))\n  have : Â«expr â‰« Â» e.hom pullback.fst = pullback.snd := by simp\n  rw [â† this, affine_cancel_left_is_iso hP.1]\n  apply hP' <;> assumption\n#align is_local.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change is_local.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change\n\n",
 "target_affine_locally_of_open_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem target_affine_locally_of_open_cover {P : affine_target_morphism_property} (hP : P.is_local) {X Y : Scheme}\n    (f : Â«expr âŸ¶ Â» X Y) (ğ’° : Y.open_cover) [âˆ€ i, is_affine (ğ’°.obj i)]\n    (hğ’° : âˆ€ i, P (pullback.snd : Â«expr âŸ¶ Â» ((ğ’°.pullback_cover f).obj i) (ğ’°.obj i))) : target_affine_locally P f := by\n  classical\n    let S i :=\n      (âŸ¨âŸ¨Set.range (ğ’°.map i).1.base, (ğ’°.is_open i).base_open.open_rangeâŸ©,\n          range_is_affine_open_of_open_immersion (ğ’°.map i)âŸ© :\n        Y.affine_opens)\n    intro U\n    apply of_affine_open_cover U (Set.range S)\n    Â· intro U r h\n      haveI : is_affine _ := U.2\n      have := hP.2 (Â«expr âˆ£_ Â» f U.1)\n      replace this := this (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op r) h\n      rw [â† P.to_property_apply] at thisâŠ¢\n      exact (hP.1.arrow_mk_iso_iff (morphism_restrict_restrict_basic_open f _ r)).mp this\n    Â· intro U s hs H\n      haveI : is_affine _ := U.2\n      apply hP.3 (Â«expr âˆ£_ Â» f U.1) (s.image (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op))\n      Â· apply_fun Ideal.comap (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top.symm).op)  at hs\n        rw [Ideal.comap_top] at hs\n        rw [â† hs]\n        simp only [eq_to_hom_op, eq_to_hom_map, Finset.coe_image]\n        have :\n          âˆ€ {R S : CommRing} (e : S = R) (s : Set S),\n            Ideal.span (Â«expr '' Â» (eq_to_hom e) s) = Ideal.comap (eq_to_hom e.symm) (Ideal.span s) :=\n          by\n          intros\n          subst e\n          simpa\n        apply this\n      Â· rintro âŸ¨r, hrâŸ©\n        obtain âŸ¨r, hr', rflâŸ© := finset.mem_image.mp hr\n        simp_rw [â† P.to_property_apply] at HâŠ¢\n        exact (hP.1.arrow_mk_iso_iff (morphism_restrict_restrict_basic_open f _ r)).mpr (H âŸ¨r, hr'âŸ©)\n    Â· rw [Set.eq_univ_iff_forall]\n      simp only [Set.mem_unionáµ¢]\n      intro x\n      exact âŸ¨âŸ¨_, âŸ¨ğ’°.f x, rflâŸ©âŸ©, ğ’°.covers xâŸ©\n    Â· rintro âŸ¨_, i, rflâŸ©\n      simp_rw [â† P.to_property_apply] at hğ’°âŠ¢\n      exact (hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)).mpr (hğ’° i)\n#align target_affine_locally_of_open_cover target_affine_locally_of_open_cover\n\n",
 "target_affine_locally_is_local":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem affine_target_morphism_property.is_local.target_affine_locally_is_local {P : affine_target_morphism_property}\n    (hP : P.is_local) : property_is_local_at_target (target_affine_locally P) :=\n  by\n  constructor\n  Â· exact target_affine_locally_respects_iso hP.1\n  Â· intro X Y f U H V\n    rw [â† P.to_property_apply, hP.1.arrow_mk_iso_iff (morphism_restrict_restrict f _ _)]\n    convert H âŸ¨_, is_affine_open.image_is_open_immersion V.2 (Y.of_restrict _)âŸ©\n    rw [â† P.to_property_apply]\n    rfl\n  Â· rintro X Y f ğ’° hğ’°\n    rw [(hP.affine_open_cover_tfae f).out 0 1]\n    refine' âŸ¨ğ’°.bind fun _ => Scheme.affine_cover _, _, _âŸ©\n    Â· intro i\n      dsimp [Scheme.open_cover.bind]\n      infer_instance\n    Â· intro i\n      specialize hğ’° i.1\n      rw [(hP.affine_open_cover_tfae (pullback.snd : Â«expr âŸ¶ Â» (pullback f (ğ’°.map i.fst)) _)).out 0 2] at hğ’°\n      specialize hğ’° (Scheme.affine_cover _) i.2\n      let e :\n        Â«expr âŸ¶ Â» (pullback f (Â«expr â‰« Â» ((ğ’°.obj i.fst).affine_cover.map i.snd) (ğ’°.map i.fst)))\n          (pullback (pullback.snd : Â«expr âŸ¶ Â» (pullback f (ğ’°.map i.fst)) _) ((ğ’°.obj i.fst).affine_cover.map i.snd)) :=\n        by\n        refine' Â«expr â‰« Â» (pullback_symmetry _ _).hom _\n        refine' Â«expr â‰« Â» (pullback_right_pullback_fst_iso _ _ _).inv _\n        refine' Â«expr â‰« Â» (pullback_symmetry _ _).hom _\n        refine' pullback.map _ _ _ _ (pullback_symmetry _ _).hom ((Â«exprğŸ™Â») _) ((Â«exprğŸ™Â») _) _ _ <;>\n          simp only [category.comp_id, category.id_comp, pullback_symmetry_hom_comp_snd]\n      rw [â† affine_cancel_left_is_iso hP.1 e] at hğ’°\n      convert hğ’°\n      simp\n#align affine_target_morphism_property.is_local.target_affine_locally_is_local affine_target_morphism_property.is_local.target_affine_locally_is_local\n\n",
 "stable_under_base_change":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_local.stable_under_base_change {P : affine_target_morphism_property} (hP : P.is_local)\n    (hP' : P.stable_under_base_change) : (target_affine_locally P).stable_under_base_change :=\n  MorphismProperty.StableUnderBaseChange.mk (target_affine_locally_respects_iso hP.respects_iso)\n    (by\n      intro X Y S f g H\n      rw [(hP.target_affine_locally_is_local.open_cover_tfae (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) X)).out 0 1]\n      use S.affine_cover.pullback_cover f\n      intro i\n      rw [(hP.affine_open_cover_tfae g).out 0 3] at H\n      let e :\n        Â«expr â‰… Â» (pullback (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) _) ((S.affine_cover.pullback_cover f).map i)) _ :=\n        by\n        refine'\n          Â«expr â‰ªâ‰« Â» (pullback_symmetry _ _)\n            (Â«expr â‰ªâ‰« Â» (pullback_right_pullback_fst_iso f g _)\n              (Â«expr â‰ªâ‰« Â» _\n                (pullback_right_pullback_fst_iso (S.affine_cover.map i) g\n                    (pullback.snd : Â«expr âŸ¶ Â» (pullback f (S.affine_cover.map i)) _)).symm))\n        exact\n          as_iso\n            (pullback.map _ _ _ _ ((Â«exprğŸ™Â») _) ((Â«exprğŸ™Â») _) ((Â«exprğŸ™Â») _) (by simpa using pullback.condition)\n              (by simp))\n      have : Â«expr â‰« Â» e.hom pullback.fst = pullback.snd := by simp\n      rw [â† this, (target_affine_locally_respects_iso hP.1).cancel_left_is_iso]\n      apply hP.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change hP'\n      rw [â† pullback_symmetry_hom_comp_snd, affine_cancel_left_is_iso hP.1]\n      apply H)\n#align is_local.stable_under_base_change is_local.stable_under_base_change\n\n",
 "respects_iso_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem affine_target_morphism_property.respects_iso_mk {P : affine_target_morphism_property}\n    (hâ‚ : âˆ€ {X Y Z} (e : Â«expr â‰… Â» X Y) (f : Â«expr âŸ¶ Â» Y Z) [is_affine Z], P f â†’ P (Â«expr â‰« Â» e.hom f))\n    (hâ‚‚ :\n      âˆ€ {X Y Z} (e : Â«expr â‰… Â» Y Z) (f : Â«expr âŸ¶ Â» X Y) [h : is_affine Y],\n        P f â†’ @P (Â«expr â‰« Â» f e.hom) (is_affine_of_iso e.inv)) :\n    P.to_property.respects_iso := by\n  constructor\n  Â· rintro X Y Z e f âŸ¨a, hâŸ©\n    exact âŸ¨a, hâ‚ e f hâŸ©\n  Â· rintro X Y Z e f âŸ¨a, hâŸ©\n    exact âŸ¨is_affine_of_iso e.inv, hâ‚‚ e f hâŸ©\n#align affine_target_morphism_property.respects_iso_mk affine_target_morphism_property.respects_iso_mk\n\n",
 "open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\ntheorem property_is_local_at_target.open_cover_tfae {P : MorphismProperty Scheme} (hP : property_is_local_at_target P)\n    {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) :\n    TFAE\n      [P f,\n        âˆƒ ğ’° : Scheme.open_cover.{u} Y, âˆ€ i : ğ’°.J, P (pullback.snd : Â«expr âŸ¶ Â» ((ğ’°.pullback_cover f).obj i) (ğ’°.obj i)),\n        âˆ€ (ğ’° : Scheme.open_cover.{u} Y) (i : ğ’°.J), P (pullback.snd : Â«expr âŸ¶ Â» ((ğ’°.pullback_cover f).obj i) (ğ’°.obj i)),\n        âˆ€ U : Opens Y.carrier, P (Â«expr âˆ£_ Â» f U),\n        âˆ€ {U : Scheme} (g : Â«expr âŸ¶ Â» U Y) [is_open_immersion g], P (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) U),\n        âˆƒ (Î¹ : Type u)(U : Î¹ â†’ Opens Y.carrier)(hU : supáµ¢ U = Â«exprâŠ¤Â»), âˆ€ i, P (Â«expr âˆ£_ Â» f (U i))] :=\n  by\n  tfae_have 2 â†’ 1\n  Â· rintro âŸ¨ğ’°, HâŸ©\n    exact hP.3 f ğ’° H\n  tfae_have 1 â†’ 4\n  Â· intro H U\n    exact hP.2 f U H\n  tfae_have 4 â†’ 3\n  Â· intro H ğ’° i\n    rw [â† hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]\n    exact H (ğ’°.map i).opens_range\n  tfae_have 3 â†’ 2\n  Â· exact fun H => âŸ¨Y.affine_cover, H Y.affine_coverâŸ©\n  tfae_have 4 â†’ 5\n  Â· intro H U g hg\n    skip\n    rw [â† hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]\n    apply H\n  tfae_have 5 â†’ 4\n  Â· intro H U\n    erw [hP.1.cancel_left_is_iso]\n    apply H\n  tfae_have 4 â†’ 6\n  Â· intro H\n    exact âŸ¨PUnit, fun _ => Â«exprâŠ¤Â», csupáµ¢_const, fun _ => H _âŸ©\n  tfae_have 6 â†’ 2\n  Â· rintro âŸ¨Î¹, U, hU, HâŸ©\n    refine' âŸ¨Y.open_cover_of_supr_eq_top U hU, _âŸ©\n    intro i\n    rw [â† hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]\n    convert H i\n    all_goals ext1; exact Subtype.range_coe\n  tfae_finish\n#align property_is_local_at_target.open_cover_tfae property_is_local_at_target.open_cover_tfae\n\n",
 "open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem property_is_local_at_target.open_cover_iff {P : MorphismProperty Scheme} (hP : property_is_local_at_target P)\n    {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) (ğ’° : Scheme.open_cover.{u} Y) :\n    P f â†” âˆ€ i, P (pullback.snd : Â«expr âŸ¶ Â» (pullback f (ğ’°.map i)) _) :=\n  âŸ¨fun H =>\n    let h := ((hP.open_cover_tfae f).out 0 2).mp H\n    h ğ’°,\n    fun H =>\n    let h := ((hP.open_cover_tfae f).out 1 0).mp\n    h âŸ¨ğ’°, HâŸ©âŸ©\n#align property_is_local_at_target.open_cover_iff property_is_local_at_target.open_cover_iff\n\n",
 "map_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_affine_open.map_is_iso {X Y : Scheme} {U : Opens Y.carrier} (hU : is_affine_open U) (f : Â«expr âŸ¶ Â» X Y)\n    [IsIso f] : is_affine_open ((Opens.map f.1.base).obj U) :=\n  haveI : is_affine _ := hU\n  is_affine_of_iso (Â«expr âˆ£_ Â» f U)\n#align is_affine_open.map_is_iso is_affine_open.map_is_iso\n\n",
 "is_local_of_open_cover_imply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem affine_target_morphism_property.is_local_of_open_cover_imply (P : affine_target_morphism_property)\n    (hP : P.to_property.respects_iso)\n    (H :\n      âˆ€ {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y),\n        (âˆƒ (ğ’° : Scheme.open_cover.{u} Y)(_ : âˆ€ i, is_affine (ğ’°.obj i)),\n            âˆ€ i : ğ’°.J, P (pullback.snd : Â«expr âŸ¶ Â» ((ğ’°.pullback_cover f).obj i) (ğ’°.obj i))) â†’\n          âˆ€ {U : Scheme} (g : Â«expr âŸ¶ Â» U Y) [is_affine U] [is_open_immersion g],\n            P (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) U)) :\n    P.is_local := by\n  refine' âŸ¨hP, _, _âŸ©\n  Â· introv h\n    skip\n    haveI : is_affine _ := (top_is_affine_open Y).basic_open_is_affine r\n    delta morphism_restrict\n    rw [affine_cancel_left_is_iso hP]\n    refine' @H f âŸ¨Scheme.open_cover_of_is_iso ((Â«exprğŸ™Â») Y), _, _âŸ© (Y.of_restrict _) _inst _\n    Â· intro i\n      dsimp\n      infer_instance\n    Â· intro i\n      dsimp\n      rwa [â† category.comp_id pullback.snd, â† pullback.condition, affine_cancel_left_is_iso hP]\n  Â· introv hs hs'\n    skip\n    replace hs := ((top_is_affine_open Y).basic_open_union_eq_self_iff _).mpr hs\n    have := H f âŸ¨Y.open_cover_of_supr_eq_top _ hs, _, _âŸ© ((Â«exprğŸ™Â») _)\n    rwa [â† category.comp_id pullback.snd, â† pullback.condition, affine_cancel_left_is_iso hP] at this\n    Â· intro i\n      exact (top_is_affine_open Y).basic_open_is_affine _\n    Â· rintro (i : s)\n      specialize hs' i\n      haveI : is_affine _ := (top_is_affine_open Y).basic_open_is_affine i.1\n      delta morphism_restrict at hs'\n      rwa [affine_cancel_left_is_iso hP] at hs'\n#align affine_target_morphism_property.is_local_of_open_cover_imply affine_target_morphism_property.is_local_of_open_cover_imply\n\n",
 "diagonal_target_affine_locally_of_open_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem diagonal_target_affine_locally_of_open_cover (P : affine_target_morphism_property) (hP : P.is_local)\n    {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) (ğ’° : Scheme.open_cover.{u} Y) [âˆ€ i, is_affine (ğ’°.obj i)]\n    (ğ’°' : âˆ€ i, Scheme.open_cover.{u} (pullback f (ğ’°.map i))) [âˆ€ i j, is_affine ((ğ’°' i).obj j)]\n    (hğ’°' : âˆ€ i j k, P (pullback.mapDesc ((ğ’°' i).map j) ((ğ’°' i).map k) pullback.snd)) :\n    (target_affine_locally P).diagonal f :=\n  by\n  refine' (hP.affine_open_cover_iff _ _).mpr _\n  Â·\n    exact\n      (Scheme.pullback.open_cover_of_base ğ’° f f).bind fun i =>\n        Scheme.pullback.open_cover_of_left_right.{u, u} (ğ’°' i) (ğ’°' i) pullback.snd pullback.snd\n  Â· intro i\n    dsimp at *\n    infer_instance\n  Â· rintro âŸ¨i, j, kâŸ©\n    dsimp\n    convert(affine_cancel_left_is_iso hP.1 (pullback_diagonal_map_iso _ _ ((ğ’°' i).map j) ((ğ’°' i).map k)).inv\n            pullback.snd).mp\n        _\n    pick_goal 3\n    Â· convert hğ’°' i j k\n      apply pullback.hom_ext <;> simp\n    all_goals\n      apply pullback.hom_ext <;>\n        simp only [category.assoc, pullback.lift_fst, pullback.lift_snd, pullback.lift_fst_assoc,\n          pullback.lift_snd_assoc]\n#align diagonal_target_affine_locally_of_open_cover diagonal_target_affine_locally_of_open_cover\n\n",
 "diagonal_target_affine_locally_eq_target_affine_locally":
 "theorem diagonal_target_affine_locally_eq_target_affine_locally (P : affine_target_morphism_property)\n    (hP : P.is_local) : (target_affine_locally P).diagonal = target_affine_locally P.diagonal :=\n  by\n  ext (_ _ f)\n  exact ((hP.diagonal_affine_open_cover_tfae f).out 0 1).trans ((hP.diagonal.affine_open_cover_tfae f).out 1 0)\n#align diagonal_target_affine_locally_eq_target_affine_locally diagonal_target_affine_locally_eq_target_affine_locally\n\n",
 "diagonal_respects_iso":
 "theorem affine_target_morphism_property.diagonal_respects_iso (P : affine_target_morphism_property)\n    (hP : P.to_property.respects_iso) : P.diagonal.to_property.respects_iso :=\n  by\n  delta affine_target_morphism_property.diagonal\n  apply affine_target_morphism_property.respects_iso_mk\n  Â· introv H _ _\n    skip\n    rw [pullback.map_desc_comp, affine_cancel_left_is_iso hP, affine_cancel_right_is_iso hP]\n    apply H\n  Â· introv H _ _\n    skip\n    rw [pullback.map_desc_comp, affine_cancel_right_is_iso hP]\n    apply H\n#align affine_target_morphism_property.diagonal_respects_iso affine_target_morphism_property.diagonal_respects_iso\n\n",
 "diagonal_of_target_affine_locally":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem affine_target_morphism_property.diagonal_of_target_affine_locally (P : affine_target_morphism_property)\n    (hP : P.is_local) {X Y U : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» U Y) [is_affine U] [is_open_immersion g]\n    (H : (target_affine_locally P).diagonal f) : P.diagonal (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _) :=\n  by\n  rintro U V fâ‚ fâ‚‚ _ _ _ _\n  skip\n  replace H := ((hP.affine_open_cover_tfae (pullback.diagonal f)).out 0 3).mp H\n  let gâ‚ :=\n    pullback.map (Â«expr â‰« Â» fâ‚ pullback.snd) (Â«expr â‰« Â» fâ‚‚ pullback.snd) f f (Â«expr â‰« Â» fâ‚ pullback.fst)\n      (Â«expr â‰« Â» fâ‚‚ pullback.fst) g (by rw [category.assoc, category.assoc, pullback.condition])\n      (by rw [category.assoc, category.assoc, pullback.condition])\n  let gâ‚‚ : Â«expr âŸ¶ Â» (pullback fâ‚ fâ‚‚) (pullback f g) := Â«expr â‰« Â» pullback.fst fâ‚\n  specialize H gâ‚\n  rw [â† affine_cancel_left_is_iso hP.1 (pullback_diagonal_map_iso f _ fâ‚ fâ‚‚).hom]\n  convert H\n  Â·\n    apply pullback.hom_ext <;>\n      simp only [category.assoc, pullback.lift_fst, pullback.lift_snd, pullback.lift_fst_assoc, pullback.lift_snd_assoc,\n        category.comp_id, pullback_diagonal_map_iso_hom_fst, pullback_diagonal_map_iso_hom_snd]\n#align affine_target_morphism_property.diagonal_of_target_affine_locally affine_target_morphism_property.diagonal_of_target_affine_locally\n\n",
 "diagonal_affine_open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae {P : affine_target_morphism_property}\n    (hP : P.is_local) {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) :\n    TFAE\n      [(target_affine_locally P).diagonal f,\n        âˆƒ (ğ’° : Scheme.open_cover.{u} Y)(_ : âˆ€ i, is_affine (ğ’°.obj i)),\n          âˆ€ i : ğ’°.J, P.diagonal (pullback.snd : Â«expr âŸ¶ Â» (pullback f (ğ’°.map i)) _),\n        âˆ€ (ğ’° : Scheme.open_cover.{u} Y) [âˆ€ i, is_affine (ğ’°.obj i)] (i : ğ’°.J),\n          P.diagonal (pullback.snd : Â«expr âŸ¶ Â» (pullback f (ğ’°.map i)) _),\n        âˆ€ {U : Scheme} (g : Â«expr âŸ¶ Â» U Y) [is_affine U] [is_open_immersion g],\n          P.diagonal (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _),\n        âˆƒ (ğ’° : Scheme.open_cover.{u} Y)(_ : âˆ€ i, is_affine (ğ’°.obj i))(ğ’°' :\n          âˆ€ i, Scheme.open_cover.{u} (pullback f (ğ’°.map i)))(_ : âˆ€ i j, is_affine ((ğ’°' i).obj j)),\n          âˆ€ i j k, P (pullback.map_desc ((ğ’°' i).map j) ((ğ’°' i).map k) pullback.snd)] :=\n  by\n  tfae_have 1 â†’ 4\n  Â· introv H hU hg _ _\n    skip\n    apply P.diagonal_of_target_affine_locally <;> assumption\n  tfae_have 4 â†’ 3\n  Â· introv H hğ’°\n    skip\n    apply H\n  tfae_have 3 â†’ 2\n  Â· exact fun H => âŸ¨Y.affine_cover, inferInstance, H Y.affine_coverâŸ©\n  tfae_have 2 â†’ 5\n  Â· rintro âŸ¨ğ’°, hğ’°, HâŸ©\n    skip\n    refine' âŸ¨ğ’°, inferInstance, fun _ => Scheme.affine_cover _, inferInstance, _âŸ©\n    intro i j k\n    apply H\n  tfae_have 5 â†’ 1\n  Â· rintro âŸ¨ğ’°, _, ğ’°', _, HâŸ©\n    exact diagonal_target_affine_locally_of_open_cover P hP f ğ’° ğ’°' H\n  tfae_finish\n#align affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae\n\n",
 "diagonal":
 "theorem affine_target_morphism_property.is_local.diagonal {P : affine_target_morphism_property} (hP : P.is_local) :\n    P.diagonal.is_local :=\n  affine_target_morphism_property.is_local_of_open_cover_imply P.diagonal (P.diagonal_respects_iso hP.1) fun _ _ f =>\n    ((hP.diagonal_affine_open_cover_tfae f).out 1 3).mp\n#align affine_target_morphism_property.is_local.diagonal affine_target_morphism_property.is_local.diagonal\n\n",
 "affine_target_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem affine_target_morphism_property.is_local.affine_target_iff {P : affine_target_morphism_property}\n    (hP : P.is_local) {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) [is_affine Y] : target_affine_locally P f â†” P f :=\n  by\n  rw [hP.affine_open_cover_iff f _]\n  swap; Â· exact Scheme.open_cover_of_is_iso ((Â«exprğŸ™Â») Y)\n  swap;\n  Â· intro\n    dsimp\n    infer_instance\n  trans P (pullback.snd : Â«expr âŸ¶ Â» (pullback f ((Â«exprğŸ™Â») _)) _)\n  Â· exact âŸ¨fun H => H PUnit.unit, fun H _ => HâŸ©\n  rw [â† category.comp_id pullback.snd, â† pullback.condition, affine_cancel_left_is_iso hP.1]\n#align affine_target_morphism_property.is_local.affine_target_iff affine_target_morphism_property.is_local.affine_target_iff\n\n",
 "affine_open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\ntheorem affine_target_morphism_property.is_local.affine_open_cover_tfae {P : affine_target_morphism_property}\n    (hP : P.is_local) {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) :\n    TFAE\n      [target_affine_locally P f,\n        âˆƒ (ğ’° : Scheme.open_cover.{u} Y)(_ : âˆ€ i, is_affine (ğ’°.obj i)),\n          âˆ€ i : ğ’°.J, P (pullback.snd : Â«expr âŸ¶ Â» ((ğ’°.pullback_cover f).obj i) (ğ’°.obj i)),\n        âˆ€ (ğ’° : Scheme.open_cover.{u} Y) [âˆ€ i, is_affine (ğ’°.obj i)] (i : ğ’°.J),\n          P (pullback.snd : Â«expr âŸ¶ Â» ((ğ’°.pullback_cover f).obj i) (ğ’°.obj i)),\n        âˆ€ {U : Scheme} (g : Â«expr âŸ¶ Â» U Y) [is_affine U] [is_open_immersion g],\n          P (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) U),\n        âˆƒ (Î¹ : Type u)(U : Î¹ â†’ Opens Y.carrier)(hU : supáµ¢ U = Â«exprâŠ¤Â»)(hU' : âˆ€ i, is_affine_open (U i)),\n          âˆ€ i, @P (Â«expr âˆ£_ Â» f (U i)) (hU' i)] :=\n  by\n  tfae_have 1 â†’ 4\n  Â· intro H U g hâ‚ hâ‚‚\n    skip\n    replace H := H âŸ¨âŸ¨_, hâ‚‚.base_open.open_rangeâŸ©, range_is_affine_open_of_open_immersion gâŸ©\n    rw [â† P.to_property_apply] at HâŠ¢\n    rwa [â† hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]\n  tfae_have 4 â†’ 3\n  Â· intro H ğ’° hğ’° i\n    skip\n    apply H\n  tfae_have 3 â†’ 2\n  Â· exact fun H => âŸ¨Y.affine_cover, inferInstance, H Y.affine_coverâŸ©\n  tfae_have 2 â†’ 1\n  Â· rintro âŸ¨ğ’°, hğ’°, HâŸ©\n    exact target_affine_locally_of_open_cover hP f ğ’° H\n  tfae_have 5 â†’ 2\n  Â· rintro âŸ¨Î¹, U, hU, hU', HâŸ©\n    refine' âŸ¨Y.open_cover_of_supr_eq_top U hU, hU', _âŸ©\n    intro i\n    specialize H i\n    rw [â† P.to_property_apply, â† hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]\n    rw [â† P.to_property_apply] at H\n    convert H\n    all_goals ext1; exact Subtype.range_coe\n  tfae_have 1 â†’ 5\n  Â· intro H\n    refine'\n      âŸ¨Y.carrier, fun x => (Y.affine_cover.map x).opens_range, _, fun i => range_is_affine_open_of_open_immersion _, _âŸ©\n    Â· rw [eq_top_iff]\n      intro x _\n      erw [opens.mem_supr]\n      exact âŸ¨x, Y.affine_cover.covers xâŸ©\n    Â· intro i\n      exact H âŸ¨_, range_is_affine_open_of_open_immersion _âŸ©\n  tfae_finish\n#align affine_target_morphism_property.is_local.affine_open_cover_tfae affine_target_morphism_property.is_local.affine_open_cover_tfae\n\n",
 "affine_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem affine_target_morphism_property.is_local.affine_open_cover_iff {P : affine_target_morphism_property}\n    (hP : P.is_local) {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) (ğ’° : Scheme.open_cover.{u} Y)\n    [hğ’° : âˆ€ i, is_affine (ğ’°.obj i)] :\n    target_affine_locally P f â†” âˆ€ i, @P (pullback.snd : Â«expr âŸ¶ Â» (pullback f (ğ’°.map i)) _) (hğ’° i) :=\n  âŸ¨fun H =>\n    let h := ((hP.affine_open_cover_tfae f).out 0 2).mp H\n    h ğ’°,\n    fun H =>\n    let h := ((hP.affine_open_cover_tfae f).out 1 0).mp\n    h âŸ¨ğ’°, inferInstance, HâŸ©âŸ©\n#align affine_target_morphism_property.is_local.affine_open_cover_iff affine_target_morphism_property.is_local.affine_open_cover_iff\n\n",
 "affine_cancel_right_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem affine_cancel_right_is_iso {P : affine_target_morphism_property} (hP : P.to_property.respects_iso)\n    {X Y Z : Scheme} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) [IsIso g] [is_affine Z] [is_affine Y] :\n    P (Â«expr â‰« Â» f g) â†” P f := by rw [â† P.to_property_apply, â† P.to_property_apply, hP.cancel_right_is_iso]\n#align affine_cancel_right_is_iso affine_cancel_right_is_iso\n\n",
 "affine_cancel_left_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem affine_cancel_left_is_iso {P : affine_target_morphism_property} (hP : P.to_property.respects_iso)\n    {X Y Z : Scheme} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) [IsIso f] [is_affine Z] : P (Â«expr â‰« Â» f g) â†” P g := by\n  rw [â† P.to_property_apply, â† P.to_property_apply, hP.cancel_left_is_iso]\n#align affine_cancel_left_is_iso affine_cancel_left_is_iso\n\n"}