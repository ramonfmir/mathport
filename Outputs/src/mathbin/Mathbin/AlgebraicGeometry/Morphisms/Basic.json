{"universally_is_local_at_target_of_morphism_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\ntheorem universally_is_local_at_target_of_morphism_restrict (P : MorphismProperty Scheme) (hP₁ : P.respects_iso)\n    (hP₂ :\n      ∀ {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) {ι : Type u} (U : ι → Opens Y.carrier) (hU : supᵢ U = «expr⊤»),\n        (∀ i, P («expr ∣_ » f (U i))) → P f) :\n    property_is_local_at_target P.universally :=\n  universally_is_local_at_target P\n    (by\n      intro X Y f 𝒰 h𝒰\n      apply hP₂ f (fun i : 𝒰.J => (𝒰.map i).opens_range) 𝒰.supr_opens_range\n      simp_rw [hP₁.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]\n      exact h𝒰)\n#align universally_is_local_at_target_of_morphism_restrict universally_is_local_at_target_of_morphism_restrict\n\n",
 "universally_is_local_at_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem universally_is_local_at_target (P : MorphismProperty Scheme)\n    (hP :\n      ∀ {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) (𝒰 : Scheme.open_cover.{u} Y),\n        (∀ i : 𝒰.J, P (pullback.snd : «expr ⟶ » ((𝒰.pullback_cover f).obj i) (𝒰.obj i))) → P f) :\n    property_is_local_at_target P.universally :=\n  by\n  refine'\n    ⟨P.universally_respects_iso, fun X Y f U =>\n      P.universally_stable_under_base_change (is_pullback_morphism_restrict f U).flip, _⟩\n  intro X Y f 𝒰 h X' Y' i₁ i₂ f' H\n  apply hP _ (𝒰.pullback_cover i₂)\n  intro i\n  dsimp\n  apply h i (pullback.lift («expr ≫ » pullback.fst i₁) («expr ≫ » pullback.snd pullback.snd) _) pullback.snd\n  swap\n  · rw [category.assoc, category.assoc, ← pullback.condition, ← pullback.condition_assoc, H.w]\n  refine' (is_pullback.of_right _ (pullback.lift_snd _ _ _) (is_pullback.of_has_pullback _ _)).flip\n  rw [pullback.lift_fst, ← pullback.condition]\n  exact (is_pullback.of_has_pullback _ _).paste_horiz H.flip\n#align universally_is_local_at_target universally_is_local_at_target\n\n",
 "to_property_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem affine_target_morphism_property.to_property_apply (P : affine_target_morphism_property) {X Y : Scheme}\n    (f : «expr ⟶ » X Y) [is_affine Y] : P.to_property f ↔ P f :=\n  by\n  delta affine_target_morphism_property.to_property\n  simp [*]\n#align affine_target_morphism_property.to_property_apply affine_target_morphism_property.to_property_apply\n\n",
 "target_affine_locally_respects_iso":
 "theorem target_affine_locally_respects_iso {P : affine_target_morphism_property} (hP : P.to_property.respects_iso) :\n    (target_affine_locally P).respects_iso := by\n  constructor\n  · introv H U\n    rw [morphism_restrict_comp, affine_cancel_left_is_iso hP]\n    exact H U\n  · introv H\n    rintro ⟨U, hU : is_affine_open U⟩\n    dsimp\n    haveI : is_affine _ := hU\n    haveI : is_affine _ := hU.map_is_iso e.hom\n    rw [morphism_restrict_comp, affine_cancel_right_is_iso hP]\n    exact H ⟨(opens.map e.hom.val.base).obj U, hU.map_is_iso e.hom⟩\n#align target_affine_locally_respects_iso target_affine_locally_respects_iso\n\n",
 "target_affine_locally_pullback_fst_of_right_of_stable_under_base_change":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_local.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change\n    {P : affine_target_morphism_property} (hP : P.is_local) (hP' : P.stable_under_base_change) {X Y S : Scheme}\n    (f : «expr ⟶ » X S) (g : «expr ⟶ » Y S) [is_affine S] (H : P g) :\n    target_affine_locally P (pullback.fst : «expr ⟶ » (pullback f g) X) :=\n  by\n  rw [(hP.affine_open_cover_tfae (pullback.fst : «expr ⟶ » (pullback f g) X)).out 0 1]\n  use X.affine_cover, inferInstance\n  intro i\n  let e := «expr ≪≫ » (pullback_symmetry _ _) (pullback_right_pullback_fst_iso f g (X.affine_cover.map i))\n  have : «expr ≫ » e.hom pullback.fst = pullback.snd := by simp\n  rw [← this, affine_cancel_left_is_iso hP.1]\n  apply hP' <;> assumption\n#align is_local.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change is_local.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change\n\n",
 "target_affine_locally_of_open_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem target_affine_locally_of_open_cover {P : affine_target_morphism_property} (hP : P.is_local) {X Y : Scheme}\n    (f : «expr ⟶ » X Y) (𝒰 : Y.open_cover) [∀ i, is_affine (𝒰.obj i)]\n    (h𝒰 : ∀ i, P (pullback.snd : «expr ⟶ » ((𝒰.pullback_cover f).obj i) (𝒰.obj i))) : target_affine_locally P f := by\n  classical\n    let S i :=\n      (⟨⟨Set.range (𝒰.map i).1.base, (𝒰.is_open i).base_open.open_range⟩,\n          range_is_affine_open_of_open_immersion (𝒰.map i)⟩ :\n        Y.affine_opens)\n    intro U\n    apply of_affine_open_cover U (Set.range S)\n    · intro U r h\n      haveI : is_affine _ := U.2\n      have := hP.2 («expr ∣_ » f U.1)\n      replace this := this (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op r) h\n      rw [← P.to_property_apply] at this⊢\n      exact (hP.1.arrow_mk_iso_iff (morphism_restrict_restrict_basic_open f _ r)).mp this\n    · intro U s hs H\n      haveI : is_affine _ := U.2\n      apply hP.3 («expr ∣_ » f U.1) (s.image (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op))\n      · apply_fun Ideal.comap (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top.symm).op)  at hs\n        rw [Ideal.comap_top] at hs\n        rw [← hs]\n        simp only [eq_to_hom_op, eq_to_hom_map, Finset.coe_image]\n        have :\n          ∀ {R S : CommRing} (e : S = R) (s : Set S),\n            Ideal.span («expr '' » (eq_to_hom e) s) = Ideal.comap (eq_to_hom e.symm) (Ideal.span s) :=\n          by\n          intros\n          subst e\n          simpa\n        apply this\n      · rintro ⟨r, hr⟩\n        obtain ⟨r, hr', rfl⟩ := finset.mem_image.mp hr\n        simp_rw [← P.to_property_apply] at H⊢\n        exact (hP.1.arrow_mk_iso_iff (morphism_restrict_restrict_basic_open f _ r)).mpr (H ⟨r, hr'⟩)\n    · rw [Set.eq_univ_iff_forall]\n      simp only [Set.mem_unionᵢ]\n      intro x\n      exact ⟨⟨_, ⟨𝒰.f x, rfl⟩⟩, 𝒰.covers x⟩\n    · rintro ⟨_, i, rfl⟩\n      simp_rw [← P.to_property_apply] at h𝒰⊢\n      exact (hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)).mpr (h𝒰 i)\n#align target_affine_locally_of_open_cover target_affine_locally_of_open_cover\n\n",
 "target_affine_locally_is_local":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem affine_target_morphism_property.is_local.target_affine_locally_is_local {P : affine_target_morphism_property}\n    (hP : P.is_local) : property_is_local_at_target (target_affine_locally P) :=\n  by\n  constructor\n  · exact target_affine_locally_respects_iso hP.1\n  · intro X Y f U H V\n    rw [← P.to_property_apply, hP.1.arrow_mk_iso_iff (morphism_restrict_restrict f _ _)]\n    convert H ⟨_, is_affine_open.image_is_open_immersion V.2 (Y.of_restrict _)⟩\n    rw [← P.to_property_apply]\n    rfl\n  · rintro X Y f 𝒰 h𝒰\n    rw [(hP.affine_open_cover_tfae f).out 0 1]\n    refine' ⟨𝒰.bind fun _ => Scheme.affine_cover _, _, _⟩\n    · intro i\n      dsimp [Scheme.open_cover.bind]\n      infer_instance\n    · intro i\n      specialize h𝒰 i.1\n      rw [(hP.affine_open_cover_tfae (pullback.snd : «expr ⟶ » (pullback f (𝒰.map i.fst)) _)).out 0 2] at h𝒰\n      specialize h𝒰 (Scheme.affine_cover _) i.2\n      let e :\n        «expr ⟶ » (pullback f («expr ≫ » ((𝒰.obj i.fst).affine_cover.map i.snd) (𝒰.map i.fst)))\n          (pullback (pullback.snd : «expr ⟶ » (pullback f (𝒰.map i.fst)) _) ((𝒰.obj i.fst).affine_cover.map i.snd)) :=\n        by\n        refine' «expr ≫ » (pullback_symmetry _ _).hom _\n        refine' «expr ≫ » (pullback_right_pullback_fst_iso _ _ _).inv _\n        refine' «expr ≫ » (pullback_symmetry _ _).hom _\n        refine' pullback.map _ _ _ _ (pullback_symmetry _ _).hom ((«expr𝟙») _) ((«expr𝟙») _) _ _ <;>\n          simp only [category.comp_id, category.id_comp, pullback_symmetry_hom_comp_snd]\n      rw [← affine_cancel_left_is_iso hP.1 e] at h𝒰\n      convert h𝒰\n      simp\n#align affine_target_morphism_property.is_local.target_affine_locally_is_local affine_target_morphism_property.is_local.target_affine_locally_is_local\n\n",
 "stable_under_base_change":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_local.stable_under_base_change {P : affine_target_morphism_property} (hP : P.is_local)\n    (hP' : P.stable_under_base_change) : (target_affine_locally P).stable_under_base_change :=\n  MorphismProperty.StableUnderBaseChange.mk (target_affine_locally_respects_iso hP.respects_iso)\n    (by\n      intro X Y S f g H\n      rw [(hP.target_affine_locally_is_local.open_cover_tfae (pullback.fst : «expr ⟶ » (pullback f g) X)).out 0 1]\n      use S.affine_cover.pullback_cover f\n      intro i\n      rw [(hP.affine_open_cover_tfae g).out 0 3] at H\n      let e :\n        «expr ≅ » (pullback (pullback.fst : «expr ⟶ » (pullback f g) _) ((S.affine_cover.pullback_cover f).map i)) _ :=\n        by\n        refine'\n          «expr ≪≫ » (pullback_symmetry _ _)\n            («expr ≪≫ » (pullback_right_pullback_fst_iso f g _)\n              («expr ≪≫ » _\n                (pullback_right_pullback_fst_iso (S.affine_cover.map i) g\n                    (pullback.snd : «expr ⟶ » (pullback f (S.affine_cover.map i)) _)).symm))\n        exact\n          as_iso\n            (pullback.map _ _ _ _ ((«expr𝟙») _) ((«expr𝟙») _) ((«expr𝟙») _) (by simpa using pullback.condition)\n              (by simp))\n      have : «expr ≫ » e.hom pullback.fst = pullback.snd := by simp\n      rw [← this, (target_affine_locally_respects_iso hP.1).cancel_left_is_iso]\n      apply hP.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change hP'\n      rw [← pullback_symmetry_hom_comp_snd, affine_cancel_left_is_iso hP.1]\n      apply H)\n#align is_local.stable_under_base_change is_local.stable_under_base_change\n\n",
 "respects_iso_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem affine_target_morphism_property.respects_iso_mk {P : affine_target_morphism_property}\n    (h₁ : ∀ {X Y Z} (e : «expr ≅ » X Y) (f : «expr ⟶ » Y Z) [is_affine Z], P f → P («expr ≫ » e.hom f))\n    (h₂ :\n      ∀ {X Y Z} (e : «expr ≅ » Y Z) (f : «expr ⟶ » X Y) [h : is_affine Y],\n        P f → @P («expr ≫ » f e.hom) (is_affine_of_iso e.inv)) :\n    P.to_property.respects_iso := by\n  constructor\n  · rintro X Y Z e f ⟨a, h⟩\n    exact ⟨a, h₁ e f h⟩\n  · rintro X Y Z e f ⟨a, h⟩\n    exact ⟨is_affine_of_iso e.inv, h₂ e f h⟩\n#align affine_target_morphism_property.respects_iso_mk affine_target_morphism_property.respects_iso_mk\n\n",
 "open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\ntheorem property_is_local_at_target.open_cover_tfae {P : MorphismProperty Scheme} (hP : property_is_local_at_target P)\n    {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) :\n    TFAE\n      [P f,\n        ∃ 𝒰 : Scheme.open_cover.{u} Y, ∀ i : 𝒰.J, P (pullback.snd : «expr ⟶ » ((𝒰.pullback_cover f).obj i) (𝒰.obj i)),\n        ∀ (𝒰 : Scheme.open_cover.{u} Y) (i : 𝒰.J), P (pullback.snd : «expr ⟶ » ((𝒰.pullback_cover f).obj i) (𝒰.obj i)),\n        ∀ U : Opens Y.carrier, P («expr ∣_ » f U),\n        ∀ {U : Scheme} (g : «expr ⟶ » U Y) [is_open_immersion g], P (pullback.snd : «expr ⟶ » (pullback f g) U),\n        ∃ (ι : Type u)(U : ι → Opens Y.carrier)(hU : supᵢ U = «expr⊤»), ∀ i, P («expr ∣_ » f (U i))] :=\n  by\n  tfae_have 2 → 1\n  · rintro ⟨𝒰, H⟩\n    exact hP.3 f 𝒰 H\n  tfae_have 1 → 4\n  · intro H U\n    exact hP.2 f U H\n  tfae_have 4 → 3\n  · intro H 𝒰 i\n    rw [← hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]\n    exact H (𝒰.map i).opens_range\n  tfae_have 3 → 2\n  · exact fun H => ⟨Y.affine_cover, H Y.affine_cover⟩\n  tfae_have 4 → 5\n  · intro H U g hg\n    skip\n    rw [← hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]\n    apply H\n  tfae_have 5 → 4\n  · intro H U\n    erw [hP.1.cancel_left_is_iso]\n    apply H\n  tfae_have 4 → 6\n  · intro H\n    exact ⟨PUnit, fun _ => «expr⊤», csupᵢ_const, fun _ => H _⟩\n  tfae_have 6 → 2\n  · rintro ⟨ι, U, hU, H⟩\n    refine' ⟨Y.open_cover_of_supr_eq_top U hU, _⟩\n    intro i\n    rw [← hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]\n    convert H i\n    all_goals ext1; exact Subtype.range_coe\n  tfae_finish\n#align property_is_local_at_target.open_cover_tfae property_is_local_at_target.open_cover_tfae\n\n",
 "open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem property_is_local_at_target.open_cover_iff {P : MorphismProperty Scheme} (hP : property_is_local_at_target P)\n    {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) (𝒰 : Scheme.open_cover.{u} Y) :\n    P f ↔ ∀ i, P (pullback.snd : «expr ⟶ » (pullback f (𝒰.map i)) _) :=\n  ⟨fun H =>\n    let h := ((hP.open_cover_tfae f).out 0 2).mp H\n    h 𝒰,\n    fun H =>\n    let h := ((hP.open_cover_tfae f).out 1 0).mp\n    h ⟨𝒰, H⟩⟩\n#align property_is_local_at_target.open_cover_iff property_is_local_at_target.open_cover_iff\n\n",
 "map_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_affine_open.map_is_iso {X Y : Scheme} {U : Opens Y.carrier} (hU : is_affine_open U) (f : «expr ⟶ » X Y)\n    [IsIso f] : is_affine_open ((Opens.map f.1.base).obj U) :=\n  haveI : is_affine _ := hU\n  is_affine_of_iso («expr ∣_ » f U)\n#align is_affine_open.map_is_iso is_affine_open.map_is_iso\n\n",
 "is_local_of_open_cover_imply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem affine_target_morphism_property.is_local_of_open_cover_imply (P : affine_target_morphism_property)\n    (hP : P.to_property.respects_iso)\n    (H :\n      ∀ {X Y : Scheme.{u}} (f : «expr ⟶ » X Y),\n        (∃ (𝒰 : Scheme.open_cover.{u} Y)(_ : ∀ i, is_affine (𝒰.obj i)),\n            ∀ i : 𝒰.J, P (pullback.snd : «expr ⟶ » ((𝒰.pullback_cover f).obj i) (𝒰.obj i))) →\n          ∀ {U : Scheme} (g : «expr ⟶ » U Y) [is_affine U] [is_open_immersion g],\n            P (pullback.snd : «expr ⟶ » (pullback f g) U)) :\n    P.is_local := by\n  refine' ⟨hP, _, _⟩\n  · introv h\n    skip\n    haveI : is_affine _ := (top_is_affine_open Y).basic_open_is_affine r\n    delta morphism_restrict\n    rw [affine_cancel_left_is_iso hP]\n    refine' @H f ⟨Scheme.open_cover_of_is_iso ((«expr𝟙») Y), _, _⟩ (Y.of_restrict _) _inst _\n    · intro i\n      dsimp\n      infer_instance\n    · intro i\n      dsimp\n      rwa [← category.comp_id pullback.snd, ← pullback.condition, affine_cancel_left_is_iso hP]\n  · introv hs hs'\n    skip\n    replace hs := ((top_is_affine_open Y).basic_open_union_eq_self_iff _).mpr hs\n    have := H f ⟨Y.open_cover_of_supr_eq_top _ hs, _, _⟩ ((«expr𝟙») _)\n    rwa [← category.comp_id pullback.snd, ← pullback.condition, affine_cancel_left_is_iso hP] at this\n    · intro i\n      exact (top_is_affine_open Y).basic_open_is_affine _\n    · rintro (i : s)\n      specialize hs' i\n      haveI : is_affine _ := (top_is_affine_open Y).basic_open_is_affine i.1\n      delta morphism_restrict at hs'\n      rwa [affine_cancel_left_is_iso hP] at hs'\n#align affine_target_morphism_property.is_local_of_open_cover_imply affine_target_morphism_property.is_local_of_open_cover_imply\n\n",
 "diagonal_target_affine_locally_of_open_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem diagonal_target_affine_locally_of_open_cover (P : affine_target_morphism_property) (hP : P.is_local)\n    {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) (𝒰 : Scheme.open_cover.{u} Y) [∀ i, is_affine (𝒰.obj i)]\n    (𝒰' : ∀ i, Scheme.open_cover.{u} (pullback f (𝒰.map i))) [∀ i j, is_affine ((𝒰' i).obj j)]\n    (h𝒰' : ∀ i j k, P (pullback.mapDesc ((𝒰' i).map j) ((𝒰' i).map k) pullback.snd)) :\n    (target_affine_locally P).diagonal f :=\n  by\n  refine' (hP.affine_open_cover_iff _ _).mpr _\n  ·\n    exact\n      (Scheme.pullback.open_cover_of_base 𝒰 f f).bind fun i =>\n        Scheme.pullback.open_cover_of_left_right.{u, u} (𝒰' i) (𝒰' i) pullback.snd pullback.snd\n  · intro i\n    dsimp at *\n    infer_instance\n  · rintro ⟨i, j, k⟩\n    dsimp\n    convert(affine_cancel_left_is_iso hP.1 (pullback_diagonal_map_iso _ _ ((𝒰' i).map j) ((𝒰' i).map k)).inv\n            pullback.snd).mp\n        _\n    pick_goal 3\n    · convert h𝒰' i j k\n      apply pullback.hom_ext <;> simp\n    all_goals\n      apply pullback.hom_ext <;>\n        simp only [category.assoc, pullback.lift_fst, pullback.lift_snd, pullback.lift_fst_assoc,\n          pullback.lift_snd_assoc]\n#align diagonal_target_affine_locally_of_open_cover diagonal_target_affine_locally_of_open_cover\n\n",
 "diagonal_target_affine_locally_eq_target_affine_locally":
 "theorem diagonal_target_affine_locally_eq_target_affine_locally (P : affine_target_morphism_property)\n    (hP : P.is_local) : (target_affine_locally P).diagonal = target_affine_locally P.diagonal :=\n  by\n  ext (_ _ f)\n  exact ((hP.diagonal_affine_open_cover_tfae f).out 0 1).trans ((hP.diagonal.affine_open_cover_tfae f).out 1 0)\n#align diagonal_target_affine_locally_eq_target_affine_locally diagonal_target_affine_locally_eq_target_affine_locally\n\n",
 "diagonal_respects_iso":
 "theorem affine_target_morphism_property.diagonal_respects_iso (P : affine_target_morphism_property)\n    (hP : P.to_property.respects_iso) : P.diagonal.to_property.respects_iso :=\n  by\n  delta affine_target_morphism_property.diagonal\n  apply affine_target_morphism_property.respects_iso_mk\n  · introv H _ _\n    skip\n    rw [pullback.map_desc_comp, affine_cancel_left_is_iso hP, affine_cancel_right_is_iso hP]\n    apply H\n  · introv H _ _\n    skip\n    rw [pullback.map_desc_comp, affine_cancel_right_is_iso hP]\n    apply H\n#align affine_target_morphism_property.diagonal_respects_iso affine_target_morphism_property.diagonal_respects_iso\n\n",
 "diagonal_of_target_affine_locally":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem affine_target_morphism_property.diagonal_of_target_affine_locally (P : affine_target_morphism_property)\n    (hP : P.is_local) {X Y U : Scheme.{u}} (f : «expr ⟶ » X Y) (g : «expr ⟶ » U Y) [is_affine U] [is_open_immersion g]\n    (H : (target_affine_locally P).diagonal f) : P.diagonal (pullback.snd : «expr ⟶ » (pullback f g) _) :=\n  by\n  rintro U V f₁ f₂ _ _ _ _\n  skip\n  replace H := ((hP.affine_open_cover_tfae (pullback.diagonal f)).out 0 3).mp H\n  let g₁ :=\n    pullback.map («expr ≫ » f₁ pullback.snd) («expr ≫ » f₂ pullback.snd) f f («expr ≫ » f₁ pullback.fst)\n      («expr ≫ » f₂ pullback.fst) g (by rw [category.assoc, category.assoc, pullback.condition])\n      (by rw [category.assoc, category.assoc, pullback.condition])\n  let g₂ : «expr ⟶ » (pullback f₁ f₂) (pullback f g) := «expr ≫ » pullback.fst f₁\n  specialize H g₁\n  rw [← affine_cancel_left_is_iso hP.1 (pullback_diagonal_map_iso f _ f₁ f₂).hom]\n  convert H\n  ·\n    apply pullback.hom_ext <;>\n      simp only [category.assoc, pullback.lift_fst, pullback.lift_snd, pullback.lift_fst_assoc, pullback.lift_snd_assoc,\n        category.comp_id, pullback_diagonal_map_iso_hom_fst, pullback_diagonal_map_iso_hom_snd]\n#align affine_target_morphism_property.diagonal_of_target_affine_locally affine_target_morphism_property.diagonal_of_target_affine_locally\n\n",
 "diagonal_affine_open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae {P : affine_target_morphism_property}\n    (hP : P.is_local) {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) :\n    TFAE\n      [(target_affine_locally P).diagonal f,\n        ∃ (𝒰 : Scheme.open_cover.{u} Y)(_ : ∀ i, is_affine (𝒰.obj i)),\n          ∀ i : 𝒰.J, P.diagonal (pullback.snd : «expr ⟶ » (pullback f (𝒰.map i)) _),\n        ∀ (𝒰 : Scheme.open_cover.{u} Y) [∀ i, is_affine (𝒰.obj i)] (i : 𝒰.J),\n          P.diagonal (pullback.snd : «expr ⟶ » (pullback f (𝒰.map i)) _),\n        ∀ {U : Scheme} (g : «expr ⟶ » U Y) [is_affine U] [is_open_immersion g],\n          P.diagonal (pullback.snd : «expr ⟶ » (pullback f g) _),\n        ∃ (𝒰 : Scheme.open_cover.{u} Y)(_ : ∀ i, is_affine (𝒰.obj i))(𝒰' :\n          ∀ i, Scheme.open_cover.{u} (pullback f (𝒰.map i)))(_ : ∀ i j, is_affine ((𝒰' i).obj j)),\n          ∀ i j k, P (pullback.map_desc ((𝒰' i).map j) ((𝒰' i).map k) pullback.snd)] :=\n  by\n  tfae_have 1 → 4\n  · introv H hU hg _ _\n    skip\n    apply P.diagonal_of_target_affine_locally <;> assumption\n  tfae_have 4 → 3\n  · introv H h𝒰\n    skip\n    apply H\n  tfae_have 3 → 2\n  · exact fun H => ⟨Y.affine_cover, inferInstance, H Y.affine_cover⟩\n  tfae_have 2 → 5\n  · rintro ⟨𝒰, h𝒰, H⟩\n    skip\n    refine' ⟨𝒰, inferInstance, fun _ => Scheme.affine_cover _, inferInstance, _⟩\n    intro i j k\n    apply H\n  tfae_have 5 → 1\n  · rintro ⟨𝒰, _, 𝒰', _, H⟩\n    exact diagonal_target_affine_locally_of_open_cover P hP f 𝒰 𝒰' H\n  tfae_finish\n#align affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae\n\n",
 "diagonal":
 "theorem affine_target_morphism_property.is_local.diagonal {P : affine_target_morphism_property} (hP : P.is_local) :\n    P.diagonal.is_local :=\n  affine_target_morphism_property.is_local_of_open_cover_imply P.diagonal (P.diagonal_respects_iso hP.1) fun _ _ f =>\n    ((hP.diagonal_affine_open_cover_tfae f).out 1 3).mp\n#align affine_target_morphism_property.is_local.diagonal affine_target_morphism_property.is_local.diagonal\n\n",
 "affine_target_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem affine_target_morphism_property.is_local.affine_target_iff {P : affine_target_morphism_property}\n    (hP : P.is_local) {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) [is_affine Y] : target_affine_locally P f ↔ P f :=\n  by\n  rw [hP.affine_open_cover_iff f _]\n  swap; · exact Scheme.open_cover_of_is_iso ((«expr𝟙») Y)\n  swap;\n  · intro\n    dsimp\n    infer_instance\n  trans P (pullback.snd : «expr ⟶ » (pullback f ((«expr𝟙») _)) _)\n  · exact ⟨fun H => H PUnit.unit, fun H _ => H⟩\n  rw [← category.comp_id pullback.snd, ← pullback.condition, affine_cancel_left_is_iso hP.1]\n#align affine_target_morphism_property.is_local.affine_target_iff affine_target_morphism_property.is_local.affine_target_iff\n\n",
 "affine_open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\ntheorem affine_target_morphism_property.is_local.affine_open_cover_tfae {P : affine_target_morphism_property}\n    (hP : P.is_local) {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) :\n    TFAE\n      [target_affine_locally P f,\n        ∃ (𝒰 : Scheme.open_cover.{u} Y)(_ : ∀ i, is_affine (𝒰.obj i)),\n          ∀ i : 𝒰.J, P (pullback.snd : «expr ⟶ » ((𝒰.pullback_cover f).obj i) (𝒰.obj i)),\n        ∀ (𝒰 : Scheme.open_cover.{u} Y) [∀ i, is_affine (𝒰.obj i)] (i : 𝒰.J),\n          P (pullback.snd : «expr ⟶ » ((𝒰.pullback_cover f).obj i) (𝒰.obj i)),\n        ∀ {U : Scheme} (g : «expr ⟶ » U Y) [is_affine U] [is_open_immersion g],\n          P (pullback.snd : «expr ⟶ » (pullback f g) U),\n        ∃ (ι : Type u)(U : ι → Opens Y.carrier)(hU : supᵢ U = «expr⊤»)(hU' : ∀ i, is_affine_open (U i)),\n          ∀ i, @P («expr ∣_ » f (U i)) (hU' i)] :=\n  by\n  tfae_have 1 → 4\n  · intro H U g h₁ h₂\n    skip\n    replace H := H ⟨⟨_, h₂.base_open.open_range⟩, range_is_affine_open_of_open_immersion g⟩\n    rw [← P.to_property_apply] at H⊢\n    rwa [← hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]\n  tfae_have 4 → 3\n  · intro H 𝒰 h𝒰 i\n    skip\n    apply H\n  tfae_have 3 → 2\n  · exact fun H => ⟨Y.affine_cover, inferInstance, H Y.affine_cover⟩\n  tfae_have 2 → 1\n  · rintro ⟨𝒰, h𝒰, H⟩\n    exact target_affine_locally_of_open_cover hP f 𝒰 H\n  tfae_have 5 → 2\n  · rintro ⟨ι, U, hU, hU', H⟩\n    refine' ⟨Y.open_cover_of_supr_eq_top U hU, hU', _⟩\n    intro i\n    specialize H i\n    rw [← P.to_property_apply, ← hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]\n    rw [← P.to_property_apply] at H\n    convert H\n    all_goals ext1; exact Subtype.range_coe\n  tfae_have 1 → 5\n  · intro H\n    refine'\n      ⟨Y.carrier, fun x => (Y.affine_cover.map x).opens_range, _, fun i => range_is_affine_open_of_open_immersion _, _⟩\n    · rw [eq_top_iff]\n      intro x _\n      erw [opens.mem_supr]\n      exact ⟨x, Y.affine_cover.covers x⟩\n    · intro i\n      exact H ⟨_, range_is_affine_open_of_open_immersion _⟩\n  tfae_finish\n#align affine_target_morphism_property.is_local.affine_open_cover_tfae affine_target_morphism_property.is_local.affine_open_cover_tfae\n\n",
 "affine_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem affine_target_morphism_property.is_local.affine_open_cover_iff {P : affine_target_morphism_property}\n    (hP : P.is_local) {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) (𝒰 : Scheme.open_cover.{u} Y)\n    [h𝒰 : ∀ i, is_affine (𝒰.obj i)] :\n    target_affine_locally P f ↔ ∀ i, @P (pullback.snd : «expr ⟶ » (pullback f (𝒰.map i)) _) (h𝒰 i) :=\n  ⟨fun H =>\n    let h := ((hP.affine_open_cover_tfae f).out 0 2).mp H\n    h 𝒰,\n    fun H =>\n    let h := ((hP.affine_open_cover_tfae f).out 1 0).mp\n    h ⟨𝒰, inferInstance, H⟩⟩\n#align affine_target_morphism_property.is_local.affine_open_cover_iff affine_target_morphism_property.is_local.affine_open_cover_iff\n\n",
 "affine_cancel_right_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem affine_cancel_right_is_iso {P : affine_target_morphism_property} (hP : P.to_property.respects_iso)\n    {X Y Z : Scheme} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) [IsIso g] [is_affine Z] [is_affine Y] :\n    P («expr ≫ » f g) ↔ P f := by rw [← P.to_property_apply, ← P.to_property_apply, hP.cancel_right_is_iso]\n#align affine_cancel_right_is_iso affine_cancel_right_is_iso\n\n",
 "affine_cancel_left_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem affine_cancel_left_is_iso {P : affine_target_morphism_property} (hP : P.to_property.respects_iso)\n    {X Y Z : Scheme} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) [IsIso f] [is_affine Z] : P («expr ≫ » f g) ↔ P g := by\n  rw [← P.to_property_apply, ← P.to_property_apply, hP.cancel_left_is_iso]\n#align affine_cancel_left_is_iso affine_cancel_left_is_iso\n\n"}