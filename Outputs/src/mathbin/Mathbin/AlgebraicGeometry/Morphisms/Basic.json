{"universally_is_local_at_target_of_morphism_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\ntheorem universally_is_local_at_target_of_morphism_restrict (P : morphism_property Scheme) (hP₁ : P.respects_iso)\n    (hP₂ :\n      ∀ {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) {ι : Type u} (U : ι → opens Y.carrier) (hU : supᵢ U = «expr⊤»),\n        (∀ i, P («expr ∣_ » f (U i))) → P f) :\n    property_is_local_at_target P.universally :=\n  universally_is_local_at_target P\n    (by\n      intro X Y f 𝒰 h𝒰\n      apply hP₂ f (fun i : 𝒰.J => (𝒰.map i).opens_range) 𝒰.supr_opens_range\n      simp_rw [hP₁.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]\n      exact h𝒰)\n#align universally_is_local_at_target_of_morphism_restrict universally_is_local_at_target_of_morphism_restrict\n\n",
 "universally_is_local_at_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem universally_is_local_at_target (P : morphism_property Scheme)\n    (hP :\n      ∀ {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) (𝒰 : Scheme.open_cover.{u} Y),\n        (∀ i : 𝒰.J, P (pullback.snd : «expr ⟶ » ((𝒰.pullback_cover f).obj i) (𝒰.obj i))) → P f) :\n    property_is_local_at_target P.universally :=\n  by\n  refine'\n    ⟨P.universally_respects_iso, fun X Y f U =>\n      P.universally_stable_under_base_change (is_pullback_morphism_restrict f U).flip, _⟩\n  intro X Y f 𝒰 h X' Y' i₁ i₂ f' H\n  apply hP _ (𝒰.pullback_cover i₂)\n  intro i\n  dsimp\n  apply h i (pullback.lift («expr ≫ » pullback.fst i₁) («expr ≫ » pullback.snd pullback.snd) _) pullback.snd\n  swap\n  · rw [category.assoc, category.assoc, ← pullback.condition, ← pullback.condition_assoc, H.w]\n  refine' (is_pullback.of_right _ (pullback.lift_snd _ _ _) (is_pullback.of_has_pullback _ _)).flip\n  rw [pullback.lift_fst, ← pullback.condition]\n  exact (is_pullback.of_has_pullback _ _).paste_horiz H.flip\n#align universally_is_local_at_target universally_is_local_at_target\n\n",
 "to_property_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem affine_target_morphism_property.to_property_apply (P : affine_target_morphism_property) {X Y : Scheme}\n    (f : «expr ⟶ » X Y) [is_affine Y] : P.to_property f ↔ P f :=\n  by\n  delta affine_target_morphism_property.to_property\n  simp [*]\n#align affine_target_morphism_property.to_property_apply affine_target_morphism_property.to_property_apply\n\n",
 "target_affine_locally_respects_iso":
 "theorem target_affine_locally_respects_iso {P : affine_target_morphism_property} (hP : P.to_property.respects_iso) :\n    (target_affine_locally P).respects_iso := by\n  constructor\n  · introv H U\n    rw [morphism_restrict_comp, affine_cancel_left_is_iso hP]\n    exact H U\n  · introv H\n    rintro ⟨U, hU : is_affine_open U⟩\n    dsimp\n    haveI : is_affine _ := hU\n    haveI : is_affine _ := hU.map_is_iso e.hom\n    rw [morphism_restrict_comp, affine_cancel_right_is_iso hP]\n    exact H ⟨(opens.map e.hom.val.base).obj U, hU.map_is_iso e.hom⟩\n#align target_affine_locally_respects_iso target_affine_locally_respects_iso\n\n",
 "target_affine_locally_pullback_fst_of_right_of_stable_under_base_change":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_local.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change\n    {P : affine_target_morphism_property} (hP : P.is_local) (hP' : P.stable_under_base_change) {X Y S : Scheme}\n    (f : «expr ⟶ » X S) (g : «expr ⟶ » Y S) [is_affine S] (H : P g) :\n    target_affine_locally P (pullback.fst : «expr ⟶ » (pullback f g) X) :=\n  by\n  rw [(hP.affine_open_cover_tfae (pullback.fst : «expr ⟶ » (pullback f g) X)).out 0 1]\n  use X.affine_cover, infer_instance\n  intro i\n  let e := «expr ≪≫ » (pullback_symmetry _ _) (pullback_right_pullback_fst_iso f g (X.affine_cover.map i))\n  have : «expr ≫ » e.hom pullback.fst = pullback.snd := by simp\n  rw [← this, affine_cancel_left_is_iso hP.1]\n  apply hP' <;> assumption\n#align\n  is_local.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change is_local.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change\n\n",
 "target_affine_locally_of_open_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem target_affine_locally_of_open_cover {P : affine_target_morphism_property} (hP : P.is_local) {X Y : Scheme}\n    (f : «expr ⟶ » X Y) (𝒰 : Y.open_cover) [∀ i, is_affine (𝒰.obj i)]\n    (h𝒰 : ∀ i, P (pullback.snd : «expr ⟶ » ((𝒰.pullback_cover f).obj i) (𝒰.obj i))) : target_affine_locally P f := by\n  classical\n    let S i :=\n      (⟨⟨Set.range (𝒰.map i).1.base, (𝒰.is_open i).base_open.open_range⟩,\n          range_is_affine_open_of_open_immersion (𝒰.map i)⟩ :\n        Y.affine_opens)\n    intro U\n    apply of_affine_open_cover U (Set.range S)\n    · intro U r h\n      haveI : is_affine _ := U.2\n      have := hP.2 («expr ∣_ » f U.1)\n      replace this := this (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op r) h\n      rw [← P.to_property_apply] at this⊢\n      exact (hP.1.arrow_mk_iso_iff (morphism_restrict_restrict_basic_open f _ r)).mp this\n    · intro U s hs H\n      haveI : is_affine _ := U.2\n      apply hP.3 («expr ∣_ » f U.1) (s.image (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op))\n      · apply_fun ideal.comap (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top.symm).op)  at hs\n        rw [ideal.comap_top] at hs\n        rw [← hs]\n        simp only [eq_to_hom_op, eq_to_hom_map, Finset.coe_image]\n        have :\n          ∀ {R S : CommRing} (e : S = R) (s : set S),\n            ideal.span («expr '' » (eq_to_hom e) s) = ideal.comap (eq_to_hom e.symm) (ideal.span s) :=\n          by\n          intros\n          subst e\n          simpa\n        apply this\n      · rintro ⟨r, hr⟩\n        obtain ⟨r, hr', rfl⟩ := finset.mem_image.mp hr\n        simp_rw [← P.to_property_apply] at H⊢\n        exact (hP.1.arrow_mk_iso_iff (morphism_restrict_restrict_basic_open f _ r)).mpr (H ⟨r, hr'⟩)\n    · rw [Set.eq_univ_iff_forall]\n      simp only [Set.mem_unionᵢ]\n      intro x\n      exact ⟨⟨_, ⟨𝒰.f x, rfl⟩⟩, 𝒰.covers x⟩\n    · rintro ⟨_, i, rfl⟩\n      simp_rw [← P.to_property_apply] at h𝒰⊢\n      exact (hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)).mpr (h𝒰 i)\n#align target_affine_locally_of_open_cover target_affine_locally_of_open_cover\n\n",
 "target_affine_locally_is_local":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem affine_target_morphism_property.is_local.target_affine_locally_is_local {P : affine_target_morphism_property}\n    (hP : P.is_local) : property_is_local_at_target (target_affine_locally P) :=\n  by\n  constructor\n  · exact target_affine_locally_respects_iso hP.1\n  · intro X Y f U H V\n    rw [← P.to_property_apply, hP.1.arrow_mk_iso_iff (morphism_restrict_restrict f _ _)]\n    convert H ⟨_, is_affine_open.image_is_open_immersion V.2 (Y.of_restrict _)⟩\n    rw [← P.to_property_apply]\n    rfl\n  · rintro X Y f 𝒰 h𝒰\n    rw [(hP.affine_open_cover_tfae f).out 0 1]\n    refine' ⟨𝒰.bind fun _ => Scheme.affine_cover _, _, _⟩\n    · intro i\n      dsimp [Scheme.open_cover.bind]\n      infer_instance\n    · intro i\n      specialize h𝒰 i.1\n      rw [(hP.affine_open_cover_tfae (pullback.snd : «expr ⟶ » (pullback f (𝒰.map i.fst)) _)).out 0 2] at h𝒰\n      specialize h𝒰 (Scheme.affine_cover _) i.2\n      let e :\n        «expr ⟶ » (pullback f («expr ≫ » ((𝒰.obj i.fst).affine_cover.map i.snd) (𝒰.map i.fst)))\n          (pullback (pullback.snd : «expr ⟶ » (pullback f (𝒰.map i.fst)) _) ((𝒰.obj i.fst).affine_cover.map i.snd)) :=\n        by\n        refine' «expr ≫ » (pullback_symmetry _ _).hom _\n        refine' «expr ≫ » (pullback_right_pullback_fst_iso _ _ _).inv _\n        refine' «expr ≫ » (pullback_symmetry _ _).hom _\n        refine' pullback.map _ _ _ _ (pullback_symmetry _ _).hom ((«expr𝟙») _) ((«expr𝟙») _) _ _ <;>\n          simp only [category.comp_id, category.id_comp, pullback_symmetry_hom_comp_snd]\n      rw [← affine_cancel_left_is_iso hP.1 e] at h𝒰\n      convert h𝒰\n      simp\n#align\n  affine_target_morphism_property.is_local.target_affine_locally_is_local affine_target_morphism_property.is_local.target_affine_locally_is_local\n\n",
 "stable_under_base_change":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_local.stable_under_base_change {P : affine_target_morphism_property} (hP : P.is_local)\n    (hP' : P.stable_under_base_change) : (target_affine_locally P).stable_under_base_change :=\n  morphism_property.stable_under_base_change.mk (target_affine_locally_respects_iso hP.respects_iso)\n    (by\n      intro X Y S f g H\n      rw [(hP.target_affine_locally_is_local.open_cover_tfae (pullback.fst : «expr ⟶ » (pullback f g) X)).out 0 1]\n      use S.affine_cover.pullback_cover f\n      intro i\n      rw [(hP.affine_open_cover_tfae g).out 0 3] at H\n      let e :\n        «expr ≅ » (pullback (pullback.fst : «expr ⟶ » (pullback f g) _) ((S.affine_cover.pullback_cover f).map i)) _ :=\n        by\n        refine'\n          «expr ≪≫ » (pullback_symmetry _ _)\n            («expr ≪≫ » (pullback_right_pullback_fst_iso f g _)\n              («expr ≪≫ » _\n                (pullback_right_pullback_fst_iso (S.affine_cover.map i) g\n                    (pullback.snd : «expr ⟶ » (pullback f (S.affine_cover.map i)) _)).symm))\n        exact\n          as_iso\n            (pullback.map _ _ _ _ ((«expr𝟙») _) ((«expr𝟙») _) ((«expr𝟙») _) (by simpa using pullback.condition)\n              (by simp))\n      have : «expr ≫ » e.hom pullback.fst = pullback.snd := by simp\n      rw [← this, (target_affine_locally_respects_iso hP.1).cancel_left_is_iso]\n      apply hP.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change hP'\n      rw [← pullback_symmetry_hom_comp_snd, affine_cancel_left_is_iso hP.1]\n      apply H)\n#align is_local.stable_under_base_change is_local.stable_under_base_change\n\n",
 "respects_iso_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem affine_target_morphism_property.respects_iso_mk {P : affine_target_morphism_property}\n    (h₁ : ∀ {X Y Z} (e : «expr ≅ » X Y) (f : «expr ⟶ » Y Z) [is_affine Z], P f → P («expr ≫ » e.hom f))\n    (h₂ :\n      ∀ {X Y Z} (e : «expr ≅ » Y Z) (f : «expr ⟶ » X Y) [h : is_affine Y],\n        P f → @P («expr ≫ » f e.hom) (is_affine_of_iso e.inv)) :\n    P.to_property.respects_iso := by\n  constructor\n  · rintro X Y Z e f ⟨a, h⟩\n    exact ⟨a, h₁ e f h⟩\n  · rintro X Y Z e f ⟨a, h⟩\n    exact ⟨is_affine_of_iso e.inv, h₂ e f h⟩\n#align affine_target_morphism_property.respects_iso_mk affine_target_morphism_property.respects_iso_mk\n\n",
 "open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `property_is_local_at_target.open_cover_tfae [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`P] [\":\" (Term.app `morphism_property [`Scheme])] \"}\")\n        (Term.explicitBinder \"(\" [`hP] [\":\" (Term.app `property_is_local_at_target [`P])] [] \")\")\n        (Term.implicitBinder \"{\" [`X `Y] [\":\" (Term.explicitUniv `Scheme \".{\" [`u] \"}\")] \"}\")\n        (Term.explicitBinder \"(\" [`f] [\":\" (Term.app `«expr ⟶ » [`X `Y])] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `P [`f])\n            \",\"\n            («term∃_,_»\n             \"∃\"\n             (Lean.explicitBinders\n              (Lean.unbracketedExplicitBinders\n               [(Lean.binderIdent `𝒰)]\n               [\":\" (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`Y])]))\n             \",\"\n             (Term.forall\n              \"∀\"\n              [`i]\n              [(Term.typeSpec \":\" (Term.proj `𝒰 \".\" `J))]\n              \",\"\n              (Term.app\n               `P\n               [(Term.typeAscription\n                 \"(\"\n                 `pullback.snd\n                 \":\"\n                 [(Term.app\n                   `«expr ⟶ »\n                   [(Term.app (Term.proj (Term.app (Term.proj `𝒰 \".\" `pullback_cover) [`f]) \".\" `obj) [`i])\n                    (Term.app (Term.proj `𝒰 \".\" `obj) [`i])])]\n                 \")\")])))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.explicitBinder\n               \"(\"\n               [`𝒰]\n               [\":\" (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`Y])]\n               []\n               \")\")\n              (Term.explicitBinder \"(\" [`i] [\":\" (Term.proj `𝒰 \".\" `J)] [] \")\")]\n             []\n             \",\"\n             (Term.app\n              `P\n              [(Term.typeAscription\n                \"(\"\n                `pullback.snd\n                \":\"\n                [(Term.app\n                  `«expr ⟶ »\n                  [(Term.app (Term.proj (Term.app (Term.proj `𝒰 \".\" `pullback_cover) [`f]) \".\" `obj) [`i])\n                   (Term.app (Term.proj `𝒰 \".\" `obj) [`i])])]\n                \")\")]))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [`U]\n             [(Term.typeSpec \":\" (Term.app `opens [(Term.proj `Y \".\" `carrier)]))]\n             \",\"\n             (Term.app `P [(Term.app `«expr ∣_ » [`f `U])]))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.implicitBinder \"{\" [`U] [\":\" `Scheme] \"}\")\n              (Term.explicitBinder \"(\" [`g] [\":\" (Term.app `«expr ⟶ » [`U `Y])] [] \")\")\n              (Term.instBinder \"[\" [] (Term.app `is_open_immersion [`g]) \"]\")]\n             []\n             \",\"\n             (Term.app\n              `P\n              [(Term.typeAscription\n                \"(\"\n                `pullback.snd\n                \":\"\n                [(Term.app `«expr ⟶ » [(Term.app `pullback [`f `g]) `U])]\n                \")\")]))\n            \",\"\n            («term∃_,_»\n             \"∃\"\n             (Lean.explicitBinders\n              [(Lean.bracketedExplicitBinders \"(\" [(Lean.binderIdent `ι)] \":\" (Term.type \"Type\" [`u]) \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `U)]\n                \":\"\n                (Term.arrow `ι \"→\" (Term.app `opens [(Term.proj `Y \".\" `carrier)]))\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `hU)]\n                \":\"\n                («term_=_» (Term.app `supᵢ [`U]) \"=\" (Term.app `«expr⊤» []))\n                \")\")])\n             \",\"\n             (Term.forall \"∀\" [`i] [] \",\" (Term.app `P [(Term.app `«expr ∣_ » [`f (Term.app `U [`i])])])))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `𝒰)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Tactic.exact \"exact\" (Term.app (Term.proj `hP \".\" (fieldIdx \"3\")) [`f `𝒰 `H]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`H `U])\n             []\n             (Tactic.exact \"exact\" (Term.app (Term.proj `hP \".\" (fieldIdx \"2\")) [`f `U `H]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`H `𝒰 `i])\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule\n                 [(patternIgnore (token.«← » \"←\"))]\n                 (Term.app\n                  (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                  [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n               \"]\")\n              [])\n             []\n             (Tactic.exact \"exact\" (Term.app `H [(Term.proj (Term.app `𝒰.map [`i]) \".\" `opens_range)]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact\n              \"exact\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`H]\n                []\n                \"=>\"\n                (Term.anonymousCtor \"⟨\" [`Y.affine_cover \",\" (Term.app `H [`Y.affine_cover])] \"⟩\"))))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"5\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`H `U `g `hg])\n             []\n             (Tactic.skip \"skip\")\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule\n                 [(patternIgnore (token.«← » \"←\"))]\n                 (Term.app\n                  (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                  [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n               \"]\")\n              [])\n             []\n             (Tactic.apply \"apply\" `H)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`H `U])\n             []\n             (Tactic.tacticErw__\n              \"erw\"\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule [] (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `cancel_left_is_iso))]\n               \"]\")\n              [])\n             []\n             (Tactic.apply \"apply\" `H)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"6\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`H])\n             []\n             (Tactic.exact\n              \"exact\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [`PUnit\n                \",\"\n                (Term.fun \"fun\" (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `«expr⊤» [])))\n                \",\"\n                `csupᵢ_const\n                \",\"\n                (Term.fun \"fun\" (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `H [(Term.hole \"_\")])))]\n               \"⟩\"))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"→\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ι)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor \"⟨\" [(Term.app `Y.open_cover_of_supr_eq_top [`U `hU]) \",\" (Term.hole \"_\")] \"⟩\"))\n             []\n             (Tactic.intro \"intro\" [`i])\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule\n                 [(patternIgnore (token.«← » \"←\"))]\n                 (Term.app\n                  (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                  [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n               \"]\")\n              [])\n             []\n             (convert \"convert\" [] (Term.app `H [`i]) [])\n             []\n             (Tactic.allGoals\n              \"all_goals\"\n              (Tactic.tacticSeq\n               (Tactic.tacticSeq1Indented\n                [(Std.Tactic.Ext.tacticExt1___ \"ext1\" []) \";\" (Tactic.exact \"exact\" `Subtype.range_coe)])))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `𝒰)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.exact \"exact\" (Term.app (Term.proj `hP \".\" (fieldIdx \"3\")) [`f `𝒰 `H]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H `U])\n            []\n            (Tactic.exact \"exact\" (Term.app (Term.proj `hP \".\" (fieldIdx \"2\")) [`f `U `H]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H `𝒰 `i])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule\n                [(patternIgnore (token.«← » \"←\"))]\n                (Term.app\n                 (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                 [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n              \"]\")\n             [])\n            []\n            (Tactic.exact \"exact\" (Term.app `H [(Term.proj (Term.app `𝒰.map [`i]) \".\" `opens_range)]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact\n             \"exact\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`H]\n               []\n               \"=>\"\n               (Term.anonymousCtor \"⟨\" [`Y.affine_cover \",\" (Term.app `H [`Y.affine_cover])] \"⟩\"))))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"5\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H `U `g `hg])\n            []\n            (Tactic.skip \"skip\")\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule\n                [(patternIgnore (token.«← » \"←\"))]\n                (Term.app\n                 (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                 [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n              \"]\")\n             [])\n            []\n            (Tactic.apply \"apply\" `H)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H `U])\n            []\n            (Tactic.tacticErw__\n             \"erw\"\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [] (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `cancel_left_is_iso))]\n              \"]\")\n             [])\n            []\n            (Tactic.apply \"apply\" `H)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"6\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [`PUnit\n               \",\"\n               (Term.fun \"fun\" (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `«expr⊤» [])))\n               \",\"\n               `csupᵢ_const\n               \",\"\n               (Term.fun \"fun\" (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `H [(Term.hole \"_\")])))]\n              \"⟩\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"→\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ι)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor \"⟨\" [(Term.app `Y.open_cover_of_supr_eq_top [`U `hU]) \",\" (Term.hole \"_\")] \"⟩\"))\n            []\n            (Tactic.intro \"intro\" [`i])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule\n                [(patternIgnore (token.«← » \"←\"))]\n                (Term.app\n                 (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                 [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n              \"]\")\n             [])\n            []\n            (convert \"convert\" [] (Term.app `H [`i]) [])\n            []\n            (Tactic.allGoals\n             \"all_goals\"\n             (Tactic.tacticSeq\n              (Tactic.tacticSeq1Indented\n               [(Std.Tactic.Ext.tacticExt1___ \"ext1\" []) \";\" (Tactic.exact \"exact\" `Subtype.range_coe)])))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Std.Tactic.rintro\n         \"rintro\"\n         [(Std.Tactic.RCases.rintroPat.one\n           (Std.Tactic.RCases.rcasesPat.tuple\n            \"⟨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ι)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)]) [])]\n            \"⟩\"))]\n         [])\n        []\n        (Tactic.refine'\n         \"refine'\"\n         (Term.anonymousCtor \"⟨\" [(Term.app `Y.open_cover_of_supr_eq_top [`U `hU]) \",\" (Term.hole \"_\")] \"⟩\"))\n        []\n        (Tactic.intro \"intro\" [`i])\n        []\n        (Tactic.rwSeq\n         \"rw\"\n         []\n         (Tactic.rwRuleSeq\n          \"[\"\n          [(Tactic.rwRule\n            [(patternIgnore (token.«← » \"←\"))]\n            (Term.app\n             (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n             [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n          \"]\")\n         [])\n        []\n        (convert \"convert\" [] (Term.app `H [`i]) [])\n        []\n        (Tactic.allGoals\n         \"all_goals\"\n         (Tactic.tacticSeq\n          (Tactic.tacticSeq1Indented\n           [(Std.Tactic.Ext.tacticExt1___ \"ext1\" []) \";\" (Tactic.exact \"exact\" `Subtype.range_coe)])))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.allGoals\n       \"all_goals\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Std.Tactic.Ext.tacticExt1___ \"ext1\" []) \";\" (Tactic.exact \"exact\" `Subtype.range_coe)])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" `Subtype.range_coe)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `Subtype.range_coe\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.Ext.tacticExt1___ \"ext1\" [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (convert \"convert\" [] (Term.app `H [`i]) [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `H [`i])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `i\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.rwSeq\n       \"rw\"\n       []\n       (Tactic.rwRuleSeq\n        \"[\"\n        [(Tactic.rwRule\n          [(patternIgnore (token.«← » \"←\"))]\n          (Term.app\n           (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n           [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n        \"]\")\n       [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n       [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))\n      `f\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `morphism_restrict_opens_range\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren\n     \"(\"\n     (Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])\n     \")\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.proj `hP \".\" (fieldIdx \"1\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hP\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`i])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `i\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.refine'\n       \"refine'\"\n       (Term.anonymousCtor \"⟨\" [(Term.app `Y.open_cover_of_supr_eq_top [`U `hU]) \",\" (Term.hole \"_\")] \"⟩\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor \"⟨\" [(Term.app `Y.open_cover_of_supr_eq_top [`U `hU]) \",\" (Term.hole \"_\")] \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `Y.open_cover_of_supr_eq_top [`U `hU])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hU\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `U\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `Y.open_cover_of_supr_eq_top\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rintro\n       \"rintro\"\n       [(Std.Tactic.RCases.rintroPat.one\n         (Std.Tactic.RCases.rcasesPat.tuple\n          \"⟨\"\n          [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ι)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)]) [])]\n          \"⟩\"))]\n       [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"→\" (num \"2\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  property_is_local_at_target.open_cover_tfae\n  { P : morphism_property Scheme } ( hP : property_is_local_at_target P ) { X Y : Scheme .{ u } } ( f : «expr ⟶ » X Y )\n    :\n      TFAE\n        [\n          P f\n            ,\n            ∃\n              𝒰 : Scheme.open_cover .{ u } Y\n              ,\n              ∀ i : 𝒰 . J , P ( pullback.snd : «expr ⟶ » 𝒰 . pullback_cover f . obj i 𝒰 . obj i )\n            ,\n            ∀\n              ( 𝒰 : Scheme.open_cover .{ u } Y ) ( i : 𝒰 . J )\n              ,\n              P ( pullback.snd : «expr ⟶ » 𝒰 . pullback_cover f . obj i 𝒰 . obj i )\n            ,\n            ∀ U : opens Y . carrier , P «expr ∣_ » f U\n            ,\n            ∀\n              { U : Scheme } ( g : «expr ⟶ » U Y ) [ is_open_immersion g ]\n              ,\n              P ( pullback.snd : «expr ⟶ » pullback f g U )\n            ,\n            ∃ ( ι : Type u ) ( U : ι → opens Y . carrier ) ( hU : supᵢ U = «expr⊤» ) , ∀ i , P «expr ∣_ » f U i\n          ]\n  :=\n    by\n      tfae_have 2 → 1\n        · rintro ⟨ 𝒰 , H ⟩ exact hP . 3 f 𝒰 H\n        tfae_have 1 → 4\n        · intro H U exact hP . 2 f U H\n        tfae_have 4 → 3\n        · intro H 𝒰 i rw [ ← hP . 1 . arrow_mk_iso_iff morphism_restrict_opens_range f _ ] exact H 𝒰.map i . opens_range\n        tfae_have 3 → 2\n        · exact fun H => ⟨ Y.affine_cover , H Y.affine_cover ⟩\n        tfae_have 4 → 5\n        · intro H U g hg skip rw [ ← hP . 1 . arrow_mk_iso_iff morphism_restrict_opens_range f _ ] apply H\n        tfae_have 5 → 4\n        · intro H U erw [ hP . 1 . cancel_left_is_iso ] apply H\n        tfae_have 4 → 6\n        · intro H exact ⟨ PUnit , fun _ => «expr⊤» , csupᵢ_const , fun _ => H _ ⟩\n        tfae_have 6 → 2\n        ·\n          rintro ⟨ ι , U , hU , H ⟩\n            refine' ⟨ Y.open_cover_of_supr_eq_top U hU , _ ⟩\n            intro i\n            rw [ ← hP . 1 . arrow_mk_iso_iff morphism_restrict_opens_range f _ ]\n            convert H i\n            all_goals ext1 ; exact Subtype.range_coe\n        tfae_finish\n#align property_is_local_at_target.open_cover_tfae property_is_local_at_target.open_cover_tfae\n\n",
 "open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem property_is_local_at_target.open_cover_iff {P : morphism_property Scheme} (hP : property_is_local_at_target P)\n    {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) (𝒰 : Scheme.open_cover.{u} Y) :\n    P f ↔ ∀ i, P (pullback.snd : «expr ⟶ » (pullback f (𝒰.map i)) _) :=\n  ⟨fun H =>\n    let h := ((hP.open_cover_tfae f).out 0 2).mp H\n    h 𝒰,\n    fun H =>\n    let h := ((hP.open_cover_tfae f).out 1 0).mp\n    h ⟨𝒰, H⟩⟩\n#align property_is_local_at_target.open_cover_iff property_is_local_at_target.open_cover_iff\n\n",
 "map_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_affine_open.map_is_iso {X Y : Scheme} {U : opens Y.carrier} (hU : is_affine_open U) (f : «expr ⟶ » X Y)\n    [IsIso f] : is_affine_open ((opens.map f.1.base).obj U) :=\n  haveI : is_affine _ := hU\n  is_affine_of_iso («expr ∣_ » f U)\n#align is_affine_open.map_is_iso is_affine_open.map_is_iso\n\n",
 "is_local_of_open_cover_imply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem affine_target_morphism_property.is_local_of_open_cover_imply (P : affine_target_morphism_property)\n    (hP : P.to_property.respects_iso)\n    (H :\n      ∀ {X Y : Scheme.{u}} (f : «expr ⟶ » X Y),\n        (∃ (𝒰 : Scheme.open_cover.{u} Y)(_ : ∀ i, is_affine (𝒰.obj i)),\n            ∀ i : 𝒰.J, P (pullback.snd : «expr ⟶ » ((𝒰.pullback_cover f).obj i) (𝒰.obj i))) →\n          ∀ {U : Scheme} (g : «expr ⟶ » U Y) [is_affine U] [is_open_immersion g],\n            P (pullback.snd : «expr ⟶ » (pullback f g) U)) :\n    P.is_local := by\n  refine' ⟨hP, _, _⟩\n  · introv h\n    skip\n    haveI : is_affine _ := (top_is_affine_open Y).basic_open_is_affine r\n    delta morphism_restrict\n    rw [affine_cancel_left_is_iso hP]\n    refine' @H f ⟨Scheme.open_cover_of_is_iso ((«expr𝟙») Y), _, _⟩ (Y.of_restrict _) _inst _\n    · intro i\n      dsimp\n      infer_instance\n    · intro i\n      dsimp\n      rwa [← category.comp_id pullback.snd, ← pullback.condition, affine_cancel_left_is_iso hP]\n  · introv hs hs'\n    skip\n    replace hs := ((top_is_affine_open Y).basic_open_union_eq_self_iff _).mpr hs\n    have := H f ⟨Y.open_cover_of_supr_eq_top _ hs, _, _⟩ ((«expr𝟙») _)\n    rwa [← category.comp_id pullback.snd, ← pullback.condition, affine_cancel_left_is_iso hP] at this\n    · intro i\n      exact (top_is_affine_open Y).basic_open_is_affine _\n    · rintro (i : s)\n      specialize hs' i\n      haveI : is_affine _ := (top_is_affine_open Y).basic_open_is_affine i.1\n      delta morphism_restrict at hs'\n      rwa [affine_cancel_left_is_iso hP] at hs'\n#align\n  affine_target_morphism_property.is_local_of_open_cover_imply affine_target_morphism_property.is_local_of_open_cover_imply\n\n",
 "diagonal_target_affine_locally_of_open_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem diagonal_target_affine_locally_of_open_cover (P : affine_target_morphism_property) (hP : P.is_local)\n    {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) (𝒰 : Scheme.open_cover.{u} Y) [∀ i, is_affine (𝒰.obj i)]\n    (𝒰' : ∀ i, Scheme.open_cover.{u} (pullback f (𝒰.map i))) [∀ i j, is_affine ((𝒰' i).obj j)]\n    (h𝒰' : ∀ i j k, P (pullback.map_desc ((𝒰' i).map j) ((𝒰' i).map k) pullback.snd)) :\n    (target_affine_locally P).diagonal f :=\n  by\n  refine' (hP.affine_open_cover_iff _ _).mpr _\n  ·\n    exact\n      (Scheme.pullback.open_cover_of_base 𝒰 f f).bind fun i =>\n        Scheme.pullback.open_cover_of_left_right.{u, u} (𝒰' i) (𝒰' i) pullback.snd pullback.snd\n  · intro i\n    dsimp at *\n    infer_instance\n  · rintro ⟨i, j, k⟩\n    dsimp\n    convert\n      (affine_cancel_left_is_iso hP.1 (pullback_diagonal_map_iso _ _ ((𝒰' i).map j) ((𝒰' i).map k)).inv pullback.snd).mp\n        _\n    pick_goal 3\n    · convert h𝒰' i j k\n      apply pullback.hom_ext <;> simp\n    all_goals\n      apply pullback.hom_ext <;>\n        simp only [category.assoc, pullback.lift_fst, pullback.lift_snd, pullback.lift_fst_assoc,\n          pullback.lift_snd_assoc]\n#align diagonal_target_affine_locally_of_open_cover diagonal_target_affine_locally_of_open_cover\n\n",
 "diagonal_target_affine_locally_eq_target_affine_locally":
 "theorem diagonal_target_affine_locally_eq_target_affine_locally (P : affine_target_morphism_property)\n    (hP : P.is_local) : (target_affine_locally P).diagonal = target_affine_locally P.diagonal :=\n  by\n  ext (_ _ f)\n  exact ((hP.diagonal_affine_open_cover_tfae f).out 0 1).trans ((hP.diagonal.affine_open_cover_tfae f).out 1 0)\n#align diagonal_target_affine_locally_eq_target_affine_locally diagonal_target_affine_locally_eq_target_affine_locally\n\n",
 "diagonal_respects_iso":
 "theorem affine_target_morphism_property.diagonal_respects_iso (P : affine_target_morphism_property)\n    (hP : P.to_property.respects_iso) : P.diagonal.to_property.respects_iso :=\n  by\n  delta affine_target_morphism_property.diagonal\n  apply affine_target_morphism_property.respects_iso_mk\n  · introv H _ _\n    skip\n    rw [pullback.map_desc_comp, affine_cancel_left_is_iso hP, affine_cancel_right_is_iso hP]\n    apply H\n  · introv H _ _\n    skip\n    rw [pullback.map_desc_comp, affine_cancel_right_is_iso hP]\n    apply H\n#align affine_target_morphism_property.diagonal_respects_iso affine_target_morphism_property.diagonal_respects_iso\n\n",
 "diagonal_of_target_affine_locally":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem affine_target_morphism_property.diagonal_of_target_affine_locally (P : affine_target_morphism_property)\n    (hP : P.is_local) {X Y U : Scheme.{u}} (f : «expr ⟶ » X Y) (g : «expr ⟶ » U Y) [is_affine U] [is_open_immersion g]\n    (H : (target_affine_locally P).diagonal f) : P.diagonal (pullback.snd : «expr ⟶ » (pullback f g) _) :=\n  by\n  rintro U V f₁ f₂ _ _ _ _\n  skip\n  replace H := ((hP.affine_open_cover_tfae (pullback.diagonal f)).out 0 3).mp H\n  let g₁ :=\n    pullback.map («expr ≫ » f₁ pullback.snd) («expr ≫ » f₂ pullback.snd) f f («expr ≫ » f₁ pullback.fst)\n      («expr ≫ » f₂ pullback.fst) g (by rw [category.assoc, category.assoc, pullback.condition])\n      (by rw [category.assoc, category.assoc, pullback.condition])\n  let g₂ : «expr ⟶ » (pullback f₁ f₂) (pullback f g) := «expr ≫ » pullback.fst f₁\n  specialize H g₁\n  rw [← affine_cancel_left_is_iso hP.1 (pullback_diagonal_map_iso f _ f₁ f₂).hom]\n  convert H\n  ·\n    apply pullback.hom_ext <;>\n      simp only [category.assoc, pullback.lift_fst, pullback.lift_snd, pullback.lift_fst_assoc, pullback.lift_snd_assoc,\n        category.comp_id, pullback_diagonal_map_iso_hom_fst, pullback_diagonal_map_iso_hom_snd]\n#align\n  affine_target_morphism_property.diagonal_of_target_affine_locally affine_target_morphism_property.diagonal_of_target_affine_locally\n\n",
 "diagonal_affine_open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`P] [\":\" `affine_target_morphism_property] \"}\")\n        (Term.explicitBinder \"(\" [`hP] [\":\" (Term.proj `P \".\" `is_local)] [] \")\")\n        (Term.implicitBinder \"{\" [`X `Y] [\":\" (Term.explicitUniv `Scheme \".{\" [`u] \"}\")] \"}\")\n        (Term.explicitBinder \"(\" [`f] [\":\" (Term.app `«expr ⟶ » [`X `Y])] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app (Term.proj (Term.app `target_affine_locally [`P]) \".\" `diagonal) [`f])\n            \",\"\n            («term∃_,_»\n             \"∃\"\n             (Lean.explicitBinders\n              [(Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `𝒰)]\n                \":\"\n                (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`Y])\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent (Term.hole \"_\"))]\n                \":\"\n                (Term.forall \"∀\" [`i] [] \",\" (Term.app `is_affine [(Term.app (Term.proj `𝒰 \".\" `obj) [`i])]))\n                \")\")])\n             \",\"\n             (Term.forall\n              \"∀\"\n              [`i]\n              [(Term.typeSpec \":\" `𝒰.J)]\n              \",\"\n              (Term.app\n               `P.diagonal\n               [(Term.typeAscription\n                 \"(\"\n                 `pullback.snd\n                 \":\"\n                 [(Term.app `«expr ⟶ » [(Term.app `pullback [`f (Term.app `𝒰.map [`i])]) (Term.hole \"_\")])]\n                 \")\")])))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.explicitBinder\n               \"(\"\n               [`𝒰]\n               [\":\" (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`Y])]\n               []\n               \")\")\n              (Term.instBinder\n               \"[\"\n               []\n               (Term.forall \"∀\" [`i] [] \",\" (Term.app `is_affine [(Term.app (Term.proj `𝒰 \".\" `obj) [`i])]))\n               \"]\")\n              (Term.explicitBinder \"(\" [`i] [\":\" (Term.proj `𝒰 \".\" `J)] [] \")\")]\n             []\n             \",\"\n             (Term.app\n              `P.diagonal\n              [(Term.typeAscription\n                \"(\"\n                `pullback.snd\n                \":\"\n                [(Term.app `«expr ⟶ » [(Term.app `pullback [`f (Term.app `𝒰.map [`i])]) (Term.hole \"_\")])]\n                \")\")]))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.implicitBinder \"{\" [`U] [\":\" `Scheme] \"}\")\n              (Term.explicitBinder \"(\" [`g] [\":\" (Term.app `«expr ⟶ » [`U `Y])] [] \")\")\n              (Term.instBinder \"[\" [] (Term.app `is_affine [`U]) \"]\")\n              (Term.instBinder \"[\" [] (Term.app `is_open_immersion [`g]) \"]\")]\n             []\n             \",\"\n             (Term.app\n              `P.diagonal\n              [(Term.typeAscription\n                \"(\"\n                `pullback.snd\n                \":\"\n                [(Term.app `«expr ⟶ » [(Term.app `pullback [`f `g]) (Term.hole \"_\")])]\n                \")\")]))\n            \",\"\n            («term∃_,_»\n             \"∃\"\n             (Lean.explicitBinders\n              [(Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `𝒰)]\n                \":\"\n                (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`Y])\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent (Term.hole \"_\"))]\n                \":\"\n                (Term.forall \"∀\" [`i] [] \",\" (Term.app `is_affine [(Term.app (Term.proj `𝒰 \".\" `obj) [`i])]))\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `𝒰')]\n                \":\"\n                (Term.forall\n                 \"∀\"\n                 [`i]\n                 []\n                 \",\"\n                 (Term.app\n                  (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\")\n                  [(Term.app `pullback [`f (Term.app (Term.proj `𝒰 \".\" `map) [`i])])]))\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent (Term.hole \"_\"))]\n                \":\"\n                (Term.forall\n                 \"∀\"\n                 [`i `j]\n                 []\n                 \",\"\n                 (Term.app `is_affine [(Term.app (Term.proj (Term.app `𝒰' [`i]) \".\" `obj) [`j])]))\n                \")\")])\n             \",\"\n             (Term.forall\n              \"∀\"\n              [`i `j `k]\n              []\n              \",\"\n              (Term.app\n               `P\n               [(Term.app\n                 `pullback.map_desc\n                 [(Term.app (Term.proj (Term.app `𝒰' [`i]) \".\" `map) [`j])\n                  (Term.app (Term.proj (Term.app `𝒰' [`i]) \".\" `map) [`k])\n                  `pullback.snd])])))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Mathlib.Tactic.introv\n              \"introv\"\n              [(Lean.binderIdent `H)\n               (Lean.binderIdent `hU)\n               (Lean.binderIdent `hg)\n               (Lean.binderIdent (Term.hole \"_\"))\n               (Lean.binderIdent (Term.hole \"_\"))])\n             []\n             (Tactic.skip \"skip\")\n             []\n             (Tactic.«tactic_<;>_»\n              (Tactic.apply \"apply\" `P.diagonal_of_target_affine_locally)\n              \"<;>\"\n              (Tactic.assumption \"assumption\"))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Mathlib.Tactic.introv \"introv\" [(Lean.binderIdent `H) (Lean.binderIdent `h𝒰)])\n             []\n             (Tactic.skip \"skip\")\n             []\n             (Tactic.apply \"apply\" `H)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact\n              \"exact\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`H]\n                []\n                \"=>\"\n                (Term.anonymousCtor\n                 \"⟨\"\n                 [`Y.affine_cover \",\" `infer_instance \",\" (Term.app `H [`Y.affine_cover])]\n                 \"⟩\"))))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"5\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `𝒰)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h𝒰)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Tactic.skip \"skip\")\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [`𝒰\n                \",\"\n                `infer_instance\n                \",\"\n                (Term.fun\n                 \"fun\"\n                 (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `Scheme.affine_cover [(Term.hole \"_\")])))\n                \",\"\n                `infer_instance\n                \",\"\n                (Term.hole \"_\")]\n               \"⟩\"))\n             []\n             (Tactic.intro \"intro\" [`i `j `k])\n             []\n             (Tactic.apply \"apply\" `H)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `𝒰)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `𝒰')])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Tactic.exact \"exact\" (Term.app `diagonal_target_affine_locally_of_open_cover [`P `hP `f `𝒰 `𝒰' `H]))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Mathlib.Tactic.introv\n             \"introv\"\n             [(Lean.binderIdent `H)\n              (Lean.binderIdent `hU)\n              (Lean.binderIdent `hg)\n              (Lean.binderIdent (Term.hole \"_\"))\n              (Lean.binderIdent (Term.hole \"_\"))])\n            []\n            (Tactic.skip \"skip\")\n            []\n            (Tactic.«tactic_<;>_»\n             (Tactic.apply \"apply\" `P.diagonal_of_target_affine_locally)\n             \"<;>\"\n             (Tactic.assumption \"assumption\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Mathlib.Tactic.introv \"introv\" [(Lean.binderIdent `H) (Lean.binderIdent `h𝒰)])\n            []\n            (Tactic.skip \"skip\")\n            []\n            (Tactic.apply \"apply\" `H)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact\n             \"exact\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`H]\n               []\n               \"=>\"\n               (Term.anonymousCtor\n                \"⟨\"\n                [`Y.affine_cover \",\" `infer_instance \",\" (Term.app `H [`Y.affine_cover])]\n                \"⟩\"))))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"5\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `𝒰)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h𝒰)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.skip \"skip\")\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [`𝒰\n               \",\"\n               `infer_instance\n               \",\"\n               (Term.fun\n                \"fun\"\n                (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `Scheme.affine_cover [(Term.hole \"_\")])))\n               \",\"\n               `infer_instance\n               \",\"\n               (Term.hole \"_\")]\n              \"⟩\"))\n            []\n            (Tactic.intro \"intro\" [`i `j `k])\n            []\n            (Tactic.apply \"apply\" `H)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `𝒰)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `𝒰')])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.exact \"exact\" (Term.app `diagonal_target_affine_locally_of_open_cover [`P `hP `f `𝒰 `𝒰' `H]))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Std.Tactic.rintro\n         \"rintro\"\n         [(Std.Tactic.RCases.rintroPat.one\n           (Std.Tactic.RCases.rcasesPat.tuple\n            \"⟨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `𝒰)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n              [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `𝒰')]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n              [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)]) [])]\n            \"⟩\"))]\n         [])\n        []\n        (Tactic.exact \"exact\" (Term.app `diagonal_target_affine_locally_of_open_cover [`P `hP `f `𝒰 `𝒰' `H]))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.app `diagonal_target_affine_locally_of_open_cover [`P `hP `f `𝒰 `𝒰' `H]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `diagonal_target_affine_locally_of_open_cover [`P `hP `f `𝒰 `𝒰' `H])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `𝒰'\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `𝒰\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `f\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hP\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `P\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `diagonal_target_affine_locally_of_open_cover\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rintro\n       \"rintro\"\n       [(Std.Tactic.RCases.rintroPat.one\n         (Std.Tactic.RCases.rcasesPat.tuple\n          \"⟨\"\n          [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `𝒰)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo\n            (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n            [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `𝒰')]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo\n            (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n            [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)]) [])]\n          \"⟩\"))]\n       [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae\n  { P : affine_target_morphism_property } ( hP : P . is_local ) { X Y : Scheme .{ u } } ( f : «expr ⟶ » X Y )\n    :\n      TFAE\n        [\n          target_affine_locally P . diagonal f\n            ,\n            ∃\n              ( 𝒰 : Scheme.open_cover .{ u } Y ) ( _ : ∀ i , is_affine 𝒰 . obj i )\n              ,\n              ∀ i : 𝒰.J , P.diagonal ( pullback.snd : «expr ⟶ » pullback f 𝒰.map i _ )\n            ,\n            ∀\n              ( 𝒰 : Scheme.open_cover .{ u } Y ) [ ∀ i , is_affine 𝒰 . obj i ] ( i : 𝒰 . J )\n              ,\n              P.diagonal ( pullback.snd : «expr ⟶ » pullback f 𝒰.map i _ )\n            ,\n            ∀\n              { U : Scheme } ( g : «expr ⟶ » U Y ) [ is_affine U ] [ is_open_immersion g ]\n              ,\n              P.diagonal ( pullback.snd : «expr ⟶ » pullback f g _ )\n            ,\n            ∃\n              ( 𝒰 : Scheme.open_cover .{ u } Y )\n                ( _ : ∀ i , is_affine 𝒰 . obj i )\n                ( 𝒰' : ∀ i , Scheme.open_cover .{ u } pullback f 𝒰 . map i )\n                ( _ : ∀ i j , is_affine 𝒰' i . obj j )\n              ,\n              ∀ i j k , P pullback.map_desc 𝒰' i . map j 𝒰' i . map k pullback.snd\n          ]\n  :=\n    by\n      tfae_have 1 → 4\n        · introv H hU hg _ _ skip apply P.diagonal_of_target_affine_locally <;> assumption\n        tfae_have 4 → 3\n        · introv H h𝒰 skip apply H\n        tfae_have 3 → 2\n        · exact fun H => ⟨ Y.affine_cover , infer_instance , H Y.affine_cover ⟩\n        tfae_have 2 → 5\n        ·\n          rintro ⟨ 𝒰 , h𝒰 , H ⟩\n            skip\n            refine' ⟨ 𝒰 , infer_instance , fun _ => Scheme.affine_cover _ , infer_instance , _ ⟩\n            intro i j k\n            apply H\n        tfae_have 5 → 1\n        · rintro ⟨ 𝒰 , _ , 𝒰' , _ , H ⟩ exact diagonal_target_affine_locally_of_open_cover P hP f 𝒰 𝒰' H\n        tfae_finish\n#align\n  affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae\n\n",
 "diagonal":
 "theorem affine_target_morphism_property.is_local.diagonal {P : affine_target_morphism_property} (hP : P.is_local) :\n    P.diagonal.is_local :=\n  affine_target_morphism_property.is_local_of_open_cover_imply P.diagonal (P.diagonal_respects_iso hP.1) fun _ _ f =>\n    ((hP.diagonal_affine_open_cover_tfae f).out 1 3).mp\n#align affine_target_morphism_property.is_local.diagonal affine_target_morphism_property.is_local.diagonal\n\n",
 "affine_target_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem affine_target_morphism_property.is_local.affine_target_iff {P : affine_target_morphism_property}\n    (hP : P.is_local) {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) [is_affine Y] : target_affine_locally P f ↔ P f :=\n  by\n  rw [hP.affine_open_cover_iff f _]\n  swap; · exact Scheme.open_cover_of_is_iso ((«expr𝟙») Y)\n  swap;\n  · intro\n    dsimp\n    infer_instance\n  trans P (pullback.snd : «expr ⟶ » (pullback f ((«expr𝟙») _)) _)\n  · exact ⟨fun H => H PUnit.unit, fun H _ => H⟩\n  rw [← category.comp_id pullback.snd, ← pullback.condition, affine_cancel_left_is_iso hP.1]\n#align\n  affine_target_morphism_property.is_local.affine_target_iff affine_target_morphism_property.is_local.affine_target_iff\n\n",
 "affine_open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∣_ » -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `affine_target_morphism_property.is_local.affine_open_cover_tfae [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`P] [\":\" `affine_target_morphism_property] \"}\")\n        (Term.explicitBinder \"(\" [`hP] [\":\" (Term.proj `P \".\" `is_local)] [] \")\")\n        (Term.implicitBinder \"{\" [`X `Y] [\":\" (Term.explicitUniv `Scheme \".{\" [`u] \"}\")] \"}\")\n        (Term.explicitBinder \"(\" [`f] [\":\" (Term.app `«expr ⟶ » [`X `Y])] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `target_affine_locally [`P `f])\n            \",\"\n            («term∃_,_»\n             \"∃\"\n             (Lean.explicitBinders\n              [(Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `𝒰)]\n                \":\"\n                (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`Y])\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent (Term.hole \"_\"))]\n                \":\"\n                (Term.forall \"∀\" [`i] [] \",\" (Term.app `is_affine [(Term.app (Term.proj `𝒰 \".\" `obj) [`i])]))\n                \")\")])\n             \",\"\n             (Term.forall\n              \"∀\"\n              [`i]\n              [(Term.typeSpec \":\" (Term.proj `𝒰 \".\" `J))]\n              \",\"\n              (Term.app\n               `P\n               [(Term.typeAscription\n                 \"(\"\n                 `pullback.snd\n                 \":\"\n                 [(Term.app\n                   `«expr ⟶ »\n                   [(Term.app (Term.proj (Term.app `𝒰.pullback_cover [`f]) \".\" `obj) [`i]) (Term.app `𝒰.obj [`i])])]\n                 \")\")])))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.explicitBinder\n               \"(\"\n               [`𝒰]\n               [\":\" (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`Y])]\n               []\n               \")\")\n              (Term.instBinder\n               \"[\"\n               []\n               (Term.forall \"∀\" [`i] [] \",\" (Term.app `is_affine [(Term.app (Term.proj `𝒰 \".\" `obj) [`i])]))\n               \"]\")\n              (Term.explicitBinder \"(\" [`i] [\":\" (Term.proj `𝒰 \".\" `J)] [] \")\")]\n             []\n             \",\"\n             (Term.app\n              `P\n              [(Term.typeAscription\n                \"(\"\n                `pullback.snd\n                \":\"\n                [(Term.app\n                  `«expr ⟶ »\n                  [(Term.app (Term.proj (Term.app `𝒰.pullback_cover [`f]) \".\" `obj) [`i]) (Term.app `𝒰.obj [`i])])]\n                \")\")]))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.implicitBinder \"{\" [`U] [\":\" `Scheme] \"}\")\n              (Term.explicitBinder \"(\" [`g] [\":\" (Term.app `«expr ⟶ » [`U `Y])] [] \")\")\n              (Term.instBinder \"[\" [] (Term.app `is_affine [`U]) \"]\")\n              (Term.instBinder \"[\" [] (Term.app `is_open_immersion [`g]) \"]\")]\n             []\n             \",\"\n             (Term.app\n              `P\n              [(Term.typeAscription\n                \"(\"\n                `pullback.snd\n                \":\"\n                [(Term.app `«expr ⟶ » [(Term.app `pullback [`f `g]) `U])]\n                \")\")]))\n            \",\"\n            («term∃_,_»\n             \"∃\"\n             (Lean.explicitBinders\n              [(Lean.bracketedExplicitBinders \"(\" [(Lean.binderIdent `ι)] \":\" (Term.type \"Type\" [`u]) \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `U)]\n                \":\"\n                (Term.arrow `ι \"→\" (Term.app `opens [(Term.proj `Y \".\" `carrier)]))\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `hU)]\n                \":\"\n                («term_=_» (Term.app `supᵢ [`U]) \"=\" (Term.app `«expr⊤» []))\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `hU')]\n                \":\"\n                (Term.forall \"∀\" [`i] [] \",\" (Term.app `is_affine_open [(Term.app `U [`i])]))\n                \")\")])\n             \",\"\n             (Term.forall\n              \"∀\"\n              [`i]\n              []\n              \",\"\n              (Term.app (Term.explicit \"@\" `P) [(Term.app `«expr ∣_ » [`f (Term.app `U [`i])]) (Term.app `hU' [`i])])))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`H `U `g `h₁ `h₂])\n             []\n             (Tactic.skip \"skip\")\n             []\n             (Mathlib.Tactic.tacticReplace_\n              \"replace\"\n              (Term.haveDecl\n               (Term.haveIdDecl\n                [`H []]\n                []\n                \":=\"\n                (Term.app\n                 `H\n                 [(Term.anonymousCtor\n                   \"⟨\"\n                   [(Term.anonymousCtor \"⟨\" [(Term.hole \"_\") \",\" `h₂.base_open.open_range] \"⟩\")\n                    \",\"\n                    (Term.app `range_is_affine_open_of_open_immersion [`g])]\n                   \"⟩\")]))))\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `P.to_property_apply)] \"]\")\n              [(Tactic.location \"at\" (Tactic.locationHyp [`H] [(patternIgnore (token.«⊢» \"⊢\"))]))])\n             []\n             (Std.Tactic.tacticRwa__\n              \"rwa\"\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule\n                 [(patternIgnore (token.«← » \"←\"))]\n                 (Term.app\n                  (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                  [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n               \"]\")\n              [])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`H `𝒰 `h𝒰 `i]) [] (Tactic.skip \"skip\") [] (Tactic.apply \"apply\" `H)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact\n              \"exact\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`H]\n                []\n                \"=>\"\n                (Term.anonymousCtor\n                 \"⟨\"\n                 [`Y.affine_cover \",\" `infer_instance \",\" (Term.app `H [`Y.affine_cover])]\n                 \"⟩\"))))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `𝒰)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h𝒰)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Tactic.exact \"exact\" (Term.app `target_affine_locally_of_open_cover [`hP `f `𝒰 `H]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ι)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU')])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [(Term.app `Y.open_cover_of_supr_eq_top [`U `hU]) \",\" `hU' \",\" (Term.hole \"_\")]\n               \"⟩\"))\n             []\n             (Tactic.intro \"intro\" [`i])\n             []\n             (Tactic.specialize \"specialize\" (Term.app `H [`i]))\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `P.to_property_apply)\n                \",\"\n                (Tactic.rwRule\n                 [(patternIgnore (token.«← » \"←\"))]\n                 (Term.app\n                  (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                  [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n               \"]\")\n              [])\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `P.to_property_apply)] \"]\")\n              [(Tactic.location \"at\" (Tactic.locationHyp [`H] []))])\n             []\n             (convert \"convert\" [] `H [])\n             []\n             (Tactic.allGoals\n              \"all_goals\"\n              (Tactic.tacticSeq\n               (Tactic.tacticSeq1Indented\n                [(Std.Tactic.Ext.tacticExt1___ \"ext1\" []) \";\" (Tactic.exact \"exact\" `Subtype.range_coe)])))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"5\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`H])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [`Y.carrier\n                \",\"\n                (Term.fun\n                 \"fun\"\n                 (Term.basicFun [`x] [] \"=>\" (Term.proj (Term.app `Y.affine_cover.map [`x]) \".\" `opens_range)))\n                \",\"\n                (Term.hole \"_\")\n                \",\"\n                (Term.fun\n                 \"fun\"\n                 (Term.basicFun [`i] [] \"=>\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])))\n                \",\"\n                (Term.hole \"_\")]\n               \"⟩\"))\n             []\n             (tactic__\n              (cdotTk (patternIgnore (token.«· » \"·\")))\n              [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eq_top_iff)] \"]\") [])\n               []\n               (Tactic.intro \"intro\" [`x (Term.hole \"_\")])\n               []\n               (Tactic.tacticErw__ \"erw\" (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `opens.mem_supr)] \"]\") [])\n               []\n               (Tactic.exact \"exact\" (Term.anonymousCtor \"⟨\" [`x \",\" (Term.app `Y.affine_cover.covers [`x])] \"⟩\"))])\n             []\n             (tactic__\n              (cdotTk (patternIgnore (token.«· » \"·\")))\n              [(Tactic.intro \"intro\" [`i])\n               []\n               (Tactic.exact\n                \"exact\"\n                (Term.app\n                 `H\n                 [(Term.anonymousCtor\n                   \"⟨\"\n                   [(Term.hole \"_\") \",\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])]\n                   \"⟩\")]))])])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H `U `g `h₁ `h₂])\n            []\n            (Tactic.skip \"skip\")\n            []\n            (Mathlib.Tactic.tacticReplace_\n             \"replace\"\n             (Term.haveDecl\n              (Term.haveIdDecl\n               [`H []]\n               []\n               \":=\"\n               (Term.app\n                `H\n                [(Term.anonymousCtor\n                  \"⟨\"\n                  [(Term.anonymousCtor \"⟨\" [(Term.hole \"_\") \",\" `h₂.base_open.open_range] \"⟩\")\n                   \",\"\n                   (Term.app `range_is_affine_open_of_open_immersion [`g])]\n                  \"⟩\")]))))\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `P.to_property_apply)] \"]\")\n             [(Tactic.location \"at\" (Tactic.locationHyp [`H] [(patternIgnore (token.«⊢» \"⊢\"))]))])\n            []\n            (Std.Tactic.tacticRwa__\n             \"rwa\"\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule\n                [(patternIgnore (token.«← » \"←\"))]\n                (Term.app\n                 (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                 [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n              \"]\")\n             [])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H `𝒰 `h𝒰 `i]) [] (Tactic.skip \"skip\") [] (Tactic.apply \"apply\" `H)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact\n             \"exact\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`H]\n               []\n               \"=>\"\n               (Term.anonymousCtor\n                \"⟨\"\n                [`Y.affine_cover \",\" `infer_instance \",\" (Term.app `H [`Y.affine_cover])]\n                \"⟩\"))))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `𝒰)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h𝒰)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.exact \"exact\" (Term.app `target_affine_locally_of_open_cover [`hP `f `𝒰 `H]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ι)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU')])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [(Term.app `Y.open_cover_of_supr_eq_top [`U `hU]) \",\" `hU' \",\" (Term.hole \"_\")]\n              \"⟩\"))\n            []\n            (Tactic.intro \"intro\" [`i])\n            []\n            (Tactic.specialize \"specialize\" (Term.app `H [`i]))\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `P.to_property_apply)\n               \",\"\n               (Tactic.rwRule\n                [(patternIgnore (token.«← » \"←\"))]\n                (Term.app\n                 (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                 [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n              \"]\")\n             [])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `P.to_property_apply)] \"]\")\n             [(Tactic.location \"at\" (Tactic.locationHyp [`H] []))])\n            []\n            (convert \"convert\" [] `H [])\n            []\n            (Tactic.allGoals\n             \"all_goals\"\n             (Tactic.tacticSeq\n              (Tactic.tacticSeq1Indented\n               [(Std.Tactic.Ext.tacticExt1___ \"ext1\" []) \";\" (Tactic.exact \"exact\" `Subtype.range_coe)])))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"5\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [`Y.carrier\n               \",\"\n               (Term.fun\n                \"fun\"\n                (Term.basicFun [`x] [] \"=>\" (Term.proj (Term.app `Y.affine_cover.map [`x]) \".\" `opens_range)))\n               \",\"\n               (Term.hole \"_\")\n               \",\"\n               (Term.fun\n                \"fun\"\n                (Term.basicFun [`i] [] \"=>\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])))\n               \",\"\n               (Term.hole \"_\")]\n              \"⟩\"))\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.«· » \"·\")))\n             [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eq_top_iff)] \"]\") [])\n              []\n              (Tactic.intro \"intro\" [`x (Term.hole \"_\")])\n              []\n              (Tactic.tacticErw__ \"erw\" (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `opens.mem_supr)] \"]\") [])\n              []\n              (Tactic.exact \"exact\" (Term.anonymousCtor \"⟨\" [`x \",\" (Term.app `Y.affine_cover.covers [`x])] \"⟩\"))])\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.«· » \"·\")))\n             [(Tactic.intro \"intro\" [`i])\n              []\n              (Tactic.exact\n               \"exact\"\n               (Term.app\n                `H\n                [(Term.anonymousCtor\n                  \"⟨\"\n                  [(Term.hole \"_\") \",\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])]\n                  \"⟩\")]))])])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.intro \"intro\" [`H])\n        []\n        (Tactic.refine'\n         \"refine'\"\n         (Term.anonymousCtor\n          \"⟨\"\n          [`Y.carrier\n           \",\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun [`x] [] \"=>\" (Term.proj (Term.app `Y.affine_cover.map [`x]) \".\" `opens_range)))\n           \",\"\n           (Term.hole \"_\")\n           \",\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun [`i] [] \"=>\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])))\n           \",\"\n           (Term.hole \"_\")]\n          \"⟩\"))\n        []\n        (tactic__\n         (cdotTk (patternIgnore (token.«· » \"·\")))\n         [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eq_top_iff)] \"]\") [])\n          []\n          (Tactic.intro \"intro\" [`x (Term.hole \"_\")])\n          []\n          (Tactic.tacticErw__ \"erw\" (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `opens.mem_supr)] \"]\") [])\n          []\n          (Tactic.exact \"exact\" (Term.anonymousCtor \"⟨\" [`x \",\" (Term.app `Y.affine_cover.covers [`x])] \"⟩\"))])\n        []\n        (tactic__\n         (cdotTk (patternIgnore (token.«· » \"·\")))\n         [(Tactic.intro \"intro\" [`i])\n          []\n          (Tactic.exact\n           \"exact\"\n           (Term.app\n            `H\n            [(Term.anonymousCtor\n              \"⟨\"\n              [(Term.hole \"_\") \",\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])]\n              \"⟩\")]))])])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.intro \"intro\" [`i])\n        []\n        (Tactic.exact\n         \"exact\"\n         (Term.app\n          `H\n          [(Term.anonymousCtor\n            \"⟨\"\n            [(Term.hole \"_\") \",\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])]\n            \"⟩\")]))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact\n       \"exact\"\n       (Term.app\n        `H\n        [(Term.anonymousCtor\n          \"⟨\"\n          [(Term.hole \"_\") \",\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])]\n          \"⟩\")]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       `H\n       [(Term.anonymousCtor\n         \"⟨\"\n         [(Term.hole \"_\") \",\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])]\n         \"⟩\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor\n       \"⟨\"\n       [(Term.hole \"_\") \",\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])]\n       \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `range_is_affine_open_of_open_immersion\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`i])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `i\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eq_top_iff)] \"]\") [])\n        []\n        (Tactic.intro \"intro\" [`x (Term.hole \"_\")])\n        []\n        (Tactic.tacticErw__ \"erw\" (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `opens.mem_supr)] \"]\") [])\n        []\n        (Tactic.exact \"exact\" (Term.anonymousCtor \"⟨\" [`x \",\" (Term.app `Y.affine_cover.covers [`x])] \"⟩\"))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.anonymousCtor \"⟨\" [`x \",\" (Term.app `Y.affine_cover.covers [`x])] \"⟩\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor \"⟨\" [`x \",\" (Term.app `Y.affine_cover.covers [`x])] \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `Y.affine_cover.covers [`x])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `Y.affine_cover.covers\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tacticErw__ \"erw\" (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `opens.mem_supr)] \"]\") [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `opens.mem_supr\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`x (Term.hole \"_\")])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1023, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eq_top_iff)] \"]\") [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `eq_top_iff\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.refine'\n       \"refine'\"\n       (Term.anonymousCtor\n        \"⟨\"\n        [`Y.carrier\n         \",\"\n         (Term.fun \"fun\" (Term.basicFun [`x] [] \"=>\" (Term.proj (Term.app `Y.affine_cover.map [`x]) \".\" `opens_range)))\n         \",\"\n         (Term.hole \"_\")\n         \",\"\n         (Term.fun\n          \"fun\"\n          (Term.basicFun [`i] [] \"=>\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])))\n         \",\"\n         (Term.hole \"_\")]\n        \"⟩\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor\n       \"⟨\"\n       [`Y.carrier\n        \",\"\n        (Term.fun \"fun\" (Term.basicFun [`x] [] \"=>\" (Term.proj (Term.app `Y.affine_cover.map [`x]) \".\" `opens_range)))\n        \",\"\n        (Term.hole \"_\")\n        \",\"\n        (Term.fun\n         \"fun\"\n         (Term.basicFun [`i] [] \"=>\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])))\n        \",\"\n        (Term.hole \"_\")]\n       \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun \"fun\" (Term.basicFun [`i] [] \"=>\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `range_is_affine_open_of_open_immersion\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `i\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun \"fun\" (Term.basicFun [`x] [] \"=>\" (Term.proj (Term.app `Y.affine_cover.map [`x]) \".\" `opens_range)))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.proj (Term.app `Y.affine_cover.map [`x]) \".\" `opens_range)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app `Y.affine_cover.map [`x])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `Y.affine_cover.map\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `Y.affine_cover.map [`x]) \")\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `Y.carrier\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`H])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"5\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  affine_target_morphism_property.is_local.affine_open_cover_tfae\n  { P : affine_target_morphism_property } ( hP : P . is_local ) { X Y : Scheme .{ u } } ( f : «expr ⟶ » X Y )\n    :\n      TFAE\n        [\n          target_affine_locally P f\n            ,\n            ∃\n              ( 𝒰 : Scheme.open_cover .{ u } Y ) ( _ : ∀ i , is_affine 𝒰 . obj i )\n              ,\n              ∀ i : 𝒰 . J , P ( pullback.snd : «expr ⟶ » 𝒰.pullback_cover f . obj i 𝒰.obj i )\n            ,\n            ∀\n              ( 𝒰 : Scheme.open_cover .{ u } Y ) [ ∀ i , is_affine 𝒰 . obj i ] ( i : 𝒰 . J )\n              ,\n              P ( pullback.snd : «expr ⟶ » 𝒰.pullback_cover f . obj i 𝒰.obj i )\n            ,\n            ∀\n              { U : Scheme } ( g : «expr ⟶ » U Y ) [ is_affine U ] [ is_open_immersion g ]\n              ,\n              P ( pullback.snd : «expr ⟶ » pullback f g U )\n            ,\n            ∃\n              ( ι : Type u ) ( U : ι → opens Y . carrier ) ( hU : supᵢ U = «expr⊤» ) ( hU' : ∀ i , is_affine_open U i )\n              ,\n              ∀ i , @ P «expr ∣_ » f U i hU' i\n          ]\n  :=\n    by\n      tfae_have 1 → 4\n        ·\n          intro H U g h₁ h₂\n            skip\n            replace H := H ⟨ ⟨ _ , h₂.base_open.open_range ⟩ , range_is_affine_open_of_open_immersion g ⟩\n            rw [ ← P.to_property_apply ] at H ⊢\n            rwa [ ← hP . 1 . arrow_mk_iso_iff morphism_restrict_opens_range f _ ]\n        tfae_have 4 → 3\n        · intro H 𝒰 h𝒰 i skip apply H\n        tfae_have 3 → 2\n        · exact fun H => ⟨ Y.affine_cover , infer_instance , H Y.affine_cover ⟩\n        tfae_have 2 → 1\n        · rintro ⟨ 𝒰 , h𝒰 , H ⟩ exact target_affine_locally_of_open_cover hP f 𝒰 H\n        tfae_have 5 → 2\n        ·\n          rintro ⟨ ι , U , hU , hU' , H ⟩\n            refine' ⟨ Y.open_cover_of_supr_eq_top U hU , hU' , _ ⟩\n            intro i\n            specialize H i\n            rw [ ← P.to_property_apply , ← hP . 1 . arrow_mk_iso_iff morphism_restrict_opens_range f _ ]\n            rw [ ← P.to_property_apply ] at H\n            convert H\n            all_goals ext1 ; exact Subtype.range_coe\n        tfae_have 1 → 5\n        ·\n          intro H\n            refine'\n              ⟨\n                Y.carrier\n                  ,\n                  fun x => Y.affine_cover.map x . opens_range\n                  ,\n                  _\n                  ,\n                  fun i => range_is_affine_open_of_open_immersion _\n                  ,\n                  _\n                ⟩\n            · rw [ eq_top_iff ] intro x _ erw [ opens.mem_supr ] exact ⟨ x , Y.affine_cover.covers x ⟩\n            · intro i exact H ⟨ _ , range_is_affine_open_of_open_immersion _ ⟩\n        tfae_finish\n#align\n  affine_target_morphism_property.is_local.affine_open_cover_tfae affine_target_morphism_property.is_local.affine_open_cover_tfae\n\n",
 "affine_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem affine_target_morphism_property.is_local.affine_open_cover_iff {P : affine_target_morphism_property}\n    (hP : P.is_local) {X Y : Scheme.{u}} (f : «expr ⟶ » X Y) (𝒰 : Scheme.open_cover.{u} Y)\n    [h𝒰 : ∀ i, is_affine (𝒰.obj i)] :\n    target_affine_locally P f ↔ ∀ i, @P (pullback.snd : «expr ⟶ » (pullback f (𝒰.map i)) _) (h𝒰 i) :=\n  ⟨fun H =>\n    let h := ((hP.affine_open_cover_tfae f).out 0 2).mp H\n    h 𝒰,\n    fun H =>\n    let h := ((hP.affine_open_cover_tfae f).out 1 0).mp\n    h ⟨𝒰, infer_instance, H⟩⟩\n#align\n  affine_target_morphism_property.is_local.affine_open_cover_iff affine_target_morphism_property.is_local.affine_open_cover_iff\n\n",
 "affine_cancel_right_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem affine_cancel_right_is_iso {P : affine_target_morphism_property} (hP : P.to_property.respects_iso)\n    {X Y Z : Scheme} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) [IsIso g] [is_affine Z] [is_affine Y] :\n    P («expr ≫ » f g) ↔ P f := by rw [← P.to_property_apply, ← P.to_property_apply, hP.cancel_right_is_iso]\n#align affine_cancel_right_is_iso affine_cancel_right_is_iso\n\n",
 "affine_cancel_left_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem affine_cancel_left_is_iso {P : affine_target_morphism_property} (hP : P.to_property.respects_iso)\n    {X Y Z : Scheme} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) [IsIso f] [is_affine Z] : P («expr ≫ » f g) ↔ P g := by\n  rw [← P.to_property_apply, ← P.to_property_apply, hP.cancel_left_is_iso]\n#align affine_cancel_left_is_iso affine_cancel_left_is_iso\n\n"}