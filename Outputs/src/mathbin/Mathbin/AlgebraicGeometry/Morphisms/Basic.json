{"universally_is_local_at_target_of_morphism_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\ntheorem universally_is_local_at_target_of_morphism_restrict (P : morphism_property Scheme) (hPâ‚ : P.respects_iso)\n    (hPâ‚‚ :\n      âˆ€ {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) {Î¹ : Type u} (U : Î¹ â†’ opens Y.carrier) (hU : supáµ¢ U = Â«exprâŠ¤Â»),\n        (âˆ€ i, P (Â«expr âˆ£_ Â» f (U i))) â†’ P f) :\n    property_is_local_at_target P.universally :=\n  universally_is_local_at_target P\n    (by\n      intro X Y f ğ’° hğ’°\n      apply hPâ‚‚ f (fun i : ğ’°.J => (ğ’°.map i).opens_range) ğ’°.supr_opens_range\n      simp_rw [hPâ‚.arrow_mk_iso_iff (morphism_restrict_opens_range f _)]\n      exact hğ’°)\n#align universally_is_local_at_target_of_morphism_restrict universally_is_local_at_target_of_morphism_restrict\n\n",
 "universally_is_local_at_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem universally_is_local_at_target (P : morphism_property Scheme)\n    (hP :\n      âˆ€ {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) (ğ’° : Scheme.open_cover.{u} Y),\n        (âˆ€ i : ğ’°.J, P (pullback.snd : Â«expr âŸ¶ Â» ((ğ’°.pullback_cover f).obj i) (ğ’°.obj i))) â†’ P f) :\n    property_is_local_at_target P.universally :=\n  by\n  refine'\n    âŸ¨P.universally_respects_iso, fun X Y f U =>\n      P.universally_stable_under_base_change (is_pullback_morphism_restrict f U).flip, _âŸ©\n  intro X Y f ğ’° h X' Y' iâ‚ iâ‚‚ f' H\n  apply hP _ (ğ’°.pullback_cover iâ‚‚)\n  intro i\n  dsimp\n  apply h i (pullback.lift (Â«expr â‰« Â» pullback.fst iâ‚) (Â«expr â‰« Â» pullback.snd pullback.snd) _) pullback.snd\n  swap\n  Â· rw [category.assoc, category.assoc, â† pullback.condition, â† pullback.condition_assoc, H.w]\n  refine' (is_pullback.of_right _ (pullback.lift_snd _ _ _) (is_pullback.of_has_pullback _ _)).flip\n  rw [pullback.lift_fst, â† pullback.condition]\n  exact (is_pullback.of_has_pullback _ _).paste_horiz H.flip\n#align universally_is_local_at_target universally_is_local_at_target\n\n",
 "to_property_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem affine_target_morphism_property.to_property_apply (P : affine_target_morphism_property) {X Y : Scheme}\n    (f : Â«expr âŸ¶ Â» X Y) [is_affine Y] : P.to_property f â†” P f :=\n  by\n  delta affine_target_morphism_property.to_property\n  simp [*]\n#align affine_target_morphism_property.to_property_apply affine_target_morphism_property.to_property_apply\n\n",
 "target_affine_locally_respects_iso":
 "theorem target_affine_locally_respects_iso {P : affine_target_morphism_property} (hP : P.to_property.respects_iso) :\n    (target_affine_locally P).respects_iso := by\n  constructor\n  Â· introv H U\n    rw [morphism_restrict_comp, affine_cancel_left_is_iso hP]\n    exact H U\n  Â· introv H\n    rintro âŸ¨U, hU : is_affine_open UâŸ©\n    dsimp\n    haveI : is_affine _ := hU\n    haveI : is_affine _ := hU.map_is_iso e.hom\n    rw [morphism_restrict_comp, affine_cancel_right_is_iso hP]\n    exact H âŸ¨(opens.map e.hom.val.base).obj U, hU.map_is_iso e.homâŸ©\n#align target_affine_locally_respects_iso target_affine_locally_respects_iso\n\n",
 "target_affine_locally_pullback_fst_of_right_of_stable_under_base_change":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_local.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change\n    {P : affine_target_morphism_property} (hP : P.is_local) (hP' : P.stable_under_base_change) {X Y S : Scheme}\n    (f : Â«expr âŸ¶ Â» X S) (g : Â«expr âŸ¶ Â» Y S) [is_affine S] (H : P g) :\n    target_affine_locally P (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) X) :=\n  by\n  rw [(hP.affine_open_cover_tfae (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) X)).out 0 1]\n  use X.affine_cover, infer_instance\n  intro i\n  let e := Â«expr â‰ªâ‰« Â» (pullback_symmetry _ _) (pullback_right_pullback_fst_iso f g (X.affine_cover.map i))\n  have : Â«expr â‰« Â» e.hom pullback.fst = pullback.snd := by simp\n  rw [â† this, affine_cancel_left_is_iso hP.1]\n  apply hP' <;> assumption\n#align\n  is_local.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change is_local.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change\n\n",
 "target_affine_locally_of_open_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem target_affine_locally_of_open_cover {P : affine_target_morphism_property} (hP : P.is_local) {X Y : Scheme}\n    (f : Â«expr âŸ¶ Â» X Y) (ğ’° : Y.open_cover) [âˆ€ i, is_affine (ğ’°.obj i)]\n    (hğ’° : âˆ€ i, P (pullback.snd : Â«expr âŸ¶ Â» ((ğ’°.pullback_cover f).obj i) (ğ’°.obj i))) : target_affine_locally P f := by\n  classical\n    let S i :=\n      (âŸ¨âŸ¨Set.range (ğ’°.map i).1.base, (ğ’°.is_open i).base_open.open_rangeâŸ©,\n          range_is_affine_open_of_open_immersion (ğ’°.map i)âŸ© :\n        Y.affine_opens)\n    intro U\n    apply of_affine_open_cover U (Set.range S)\n    Â· intro U r h\n      haveI : is_affine _ := U.2\n      have := hP.2 (Â«expr âˆ£_ Â» f U.1)\n      replace this := this (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op r) h\n      rw [â† P.to_property_apply] at thisâŠ¢\n      exact (hP.1.arrow_mk_iso_iff (morphism_restrict_restrict_basic_open f _ r)).mp this\n    Â· intro U s hs H\n      haveI : is_affine _ := U.2\n      apply hP.3 (Â«expr âˆ£_ Â» f U.1) (s.image (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op))\n      Â· apply_fun ideal.comap (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top.symm).op)  at hs\n        rw [ideal.comap_top] at hs\n        rw [â† hs]\n        simp only [eq_to_hom_op, eq_to_hom_map, Finset.coe_image]\n        have :\n          âˆ€ {R S : CommRing} (e : S = R) (s : set S),\n            ideal.span (Â«expr '' Â» (eq_to_hom e) s) = ideal.comap (eq_to_hom e.symm) (ideal.span s) :=\n          by\n          intros\n          subst e\n          simpa\n        apply this\n      Â· rintro âŸ¨r, hrâŸ©\n        obtain âŸ¨r, hr', rflâŸ© := finset.mem_image.mp hr\n        simp_rw [â† P.to_property_apply] at HâŠ¢\n        exact (hP.1.arrow_mk_iso_iff (morphism_restrict_restrict_basic_open f _ r)).mpr (H âŸ¨r, hr'âŸ©)\n    Â· rw [Set.eq_univ_iff_forall]\n      simp only [Set.mem_unionáµ¢]\n      intro x\n      exact âŸ¨âŸ¨_, âŸ¨ğ’°.f x, rflâŸ©âŸ©, ğ’°.covers xâŸ©\n    Â· rintro âŸ¨_, i, rflâŸ©\n      simp_rw [â† P.to_property_apply] at hğ’°âŠ¢\n      exact (hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)).mpr (hğ’° i)\n#align target_affine_locally_of_open_cover target_affine_locally_of_open_cover\n\n",
 "target_affine_locally_is_local":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem affine_target_morphism_property.is_local.target_affine_locally_is_local {P : affine_target_morphism_property}\n    (hP : P.is_local) : property_is_local_at_target (target_affine_locally P) :=\n  by\n  constructor\n  Â· exact target_affine_locally_respects_iso hP.1\n  Â· intro X Y f U H V\n    rw [â† P.to_property_apply, hP.1.arrow_mk_iso_iff (morphism_restrict_restrict f _ _)]\n    convert H âŸ¨_, is_affine_open.image_is_open_immersion V.2 (Y.of_restrict _)âŸ©\n    rw [â† P.to_property_apply]\n    rfl\n  Â· rintro X Y f ğ’° hğ’°\n    rw [(hP.affine_open_cover_tfae f).out 0 1]\n    refine' âŸ¨ğ’°.bind fun _ => Scheme.affine_cover _, _, _âŸ©\n    Â· intro i\n      dsimp [Scheme.open_cover.bind]\n      infer_instance\n    Â· intro i\n      specialize hğ’° i.1\n      rw [(hP.affine_open_cover_tfae (pullback.snd : Â«expr âŸ¶ Â» (pullback f (ğ’°.map i.fst)) _)).out 0 2] at hğ’°\n      specialize hğ’° (Scheme.affine_cover _) i.2\n      let e :\n        Â«expr âŸ¶ Â» (pullback f (Â«expr â‰« Â» ((ğ’°.obj i.fst).affine_cover.map i.snd) (ğ’°.map i.fst)))\n          (pullback (pullback.snd : Â«expr âŸ¶ Â» (pullback f (ğ’°.map i.fst)) _) ((ğ’°.obj i.fst).affine_cover.map i.snd)) :=\n        by\n        refine' Â«expr â‰« Â» (pullback_symmetry _ _).hom _\n        refine' Â«expr â‰« Â» (pullback_right_pullback_fst_iso _ _ _).inv _\n        refine' Â«expr â‰« Â» (pullback_symmetry _ _).hom _\n        refine' pullback.map _ _ _ _ (pullback_symmetry _ _).hom ((Â«exprğŸ™Â») _) ((Â«exprğŸ™Â») _) _ _ <;>\n          simp only [category.comp_id, category.id_comp, pullback_symmetry_hom_comp_snd]\n      rw [â† affine_cancel_left_is_iso hP.1 e] at hğ’°\n      convert hğ’°\n      simp\n#align\n  affine_target_morphism_property.is_local.target_affine_locally_is_local affine_target_morphism_property.is_local.target_affine_locally_is_local\n\n",
 "stable_under_base_change":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ªâ‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_local.stable_under_base_change {P : affine_target_morphism_property} (hP : P.is_local)\n    (hP' : P.stable_under_base_change) : (target_affine_locally P).stable_under_base_change :=\n  morphism_property.stable_under_base_change.mk (target_affine_locally_respects_iso hP.respects_iso)\n    (by\n      intro X Y S f g H\n      rw [(hP.target_affine_locally_is_local.open_cover_tfae (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) X)).out 0 1]\n      use S.affine_cover.pullback_cover f\n      intro i\n      rw [(hP.affine_open_cover_tfae g).out 0 3] at H\n      let e :\n        Â«expr â‰… Â» (pullback (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) _) ((S.affine_cover.pullback_cover f).map i)) _ :=\n        by\n        refine'\n          Â«expr â‰ªâ‰« Â» (pullback_symmetry _ _)\n            (Â«expr â‰ªâ‰« Â» (pullback_right_pullback_fst_iso f g _)\n              (Â«expr â‰ªâ‰« Â» _\n                (pullback_right_pullback_fst_iso (S.affine_cover.map i) g\n                    (pullback.snd : Â«expr âŸ¶ Â» (pullback f (S.affine_cover.map i)) _)).symm))\n        exact\n          as_iso\n            (pullback.map _ _ _ _ ((Â«exprğŸ™Â») _) ((Â«exprğŸ™Â») _) ((Â«exprğŸ™Â») _) (by simpa using pullback.condition)\n              (by simp))\n      have : Â«expr â‰« Â» e.hom pullback.fst = pullback.snd := by simp\n      rw [â† this, (target_affine_locally_respects_iso hP.1).cancel_left_is_iso]\n      apply hP.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change hP'\n      rw [â† pullback_symmetry_hom_comp_snd, affine_cancel_left_is_iso hP.1]\n      apply H)\n#align is_local.stable_under_base_change is_local.stable_under_base_change\n\n",
 "respects_iso_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem affine_target_morphism_property.respects_iso_mk {P : affine_target_morphism_property}\n    (hâ‚ : âˆ€ {X Y Z} (e : Â«expr â‰… Â» X Y) (f : Â«expr âŸ¶ Â» Y Z) [is_affine Z], P f â†’ P (Â«expr â‰« Â» e.hom f))\n    (hâ‚‚ :\n      âˆ€ {X Y Z} (e : Â«expr â‰… Â» Y Z) (f : Â«expr âŸ¶ Â» X Y) [h : is_affine Y],\n        P f â†’ @P (Â«expr â‰« Â» f e.hom) (is_affine_of_iso e.inv)) :\n    P.to_property.respects_iso := by\n  constructor\n  Â· rintro X Y Z e f âŸ¨a, hâŸ©\n    exact âŸ¨a, hâ‚ e f hâŸ©\n  Â· rintro X Y Z e f âŸ¨a, hâŸ©\n    exact âŸ¨is_affine_of_iso e.inv, hâ‚‚ e f hâŸ©\n#align affine_target_morphism_property.respects_iso_mk affine_target_morphism_property.respects_iso_mk\n\n",
 "open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `property_is_local_at_target.open_cover_tfae [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`P] [\":\" (Term.app `morphism_property [`Scheme])] \"}\")\n        (Term.explicitBinder \"(\" [`hP] [\":\" (Term.app `property_is_local_at_target [`P])] [] \")\")\n        (Term.implicitBinder \"{\" [`X `Y] [\":\" (Term.explicitUniv `Scheme \".{\" [`u] \"}\")] \"}\")\n        (Term.explicitBinder \"(\" [`f] [\":\" (Term.app `Â«expr âŸ¶ Â» [`X `Y])] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(Â«term[_]Â»\n           \"[\"\n           [(Term.app `P [`f])\n            \",\"\n            (Â«termâˆƒ_,_Â»\n             \"âˆƒ\"\n             (Lean.explicitBinders\n              (Lean.unbracketedExplicitBinders\n               [(Lean.binderIdent `ğ’°)]\n               [\":\" (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`Y])]))\n             \",\"\n             (Term.forall\n              \"âˆ€\"\n              [`i]\n              [(Term.typeSpec \":\" (Term.proj `ğ’° \".\" `J))]\n              \",\"\n              (Term.app\n               `P\n               [(Term.typeAscription\n                 \"(\"\n                 `pullback.snd\n                 \":\"\n                 [(Term.app\n                   `Â«expr âŸ¶ Â»\n                   [(Term.app (Term.proj (Term.app (Term.proj `ğ’° \".\" `pullback_cover) [`f]) \".\" `obj) [`i])\n                    (Term.app (Term.proj `ğ’° \".\" `obj) [`i])])]\n                 \")\")])))\n            \",\"\n            (Term.forall\n             \"âˆ€\"\n             [(Term.explicitBinder\n               \"(\"\n               [`ğ’°]\n               [\":\" (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`Y])]\n               []\n               \")\")\n              (Term.explicitBinder \"(\" [`i] [\":\" (Term.proj `ğ’° \".\" `J)] [] \")\")]\n             []\n             \",\"\n             (Term.app\n              `P\n              [(Term.typeAscription\n                \"(\"\n                `pullback.snd\n                \":\"\n                [(Term.app\n                  `Â«expr âŸ¶ Â»\n                  [(Term.app (Term.proj (Term.app (Term.proj `ğ’° \".\" `pullback_cover) [`f]) \".\" `obj) [`i])\n                   (Term.app (Term.proj `ğ’° \".\" `obj) [`i])])]\n                \")\")]))\n            \",\"\n            (Term.forall\n             \"âˆ€\"\n             [`U]\n             [(Term.typeSpec \":\" (Term.app `opens [(Term.proj `Y \".\" `carrier)]))]\n             \",\"\n             (Term.app `P [(Term.app `Â«expr âˆ£_ Â» [`f `U])]))\n            \",\"\n            (Term.forall\n             \"âˆ€\"\n             [(Term.implicitBinder \"{\" [`U] [\":\" `Scheme] \"}\")\n              (Term.explicitBinder \"(\" [`g] [\":\" (Term.app `Â«expr âŸ¶ Â» [`U `Y])] [] \")\")\n              (Term.instBinder \"[\" [] (Term.app `is_open_immersion [`g]) \"]\")]\n             []\n             \",\"\n             (Term.app\n              `P\n              [(Term.typeAscription\n                \"(\"\n                `pullback.snd\n                \":\"\n                [(Term.app `Â«expr âŸ¶ Â» [(Term.app `pullback [`f `g]) `U])]\n                \")\")]))\n            \",\"\n            (Â«termâˆƒ_,_Â»\n             \"âˆƒ\"\n             (Lean.explicitBinders\n              [(Lean.bracketedExplicitBinders \"(\" [(Lean.binderIdent `Î¹)] \":\" (Term.type \"Type\" [`u]) \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `U)]\n                \":\"\n                (Term.arrow `Î¹ \"â†’\" (Term.app `opens [(Term.proj `Y \".\" `carrier)]))\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `hU)]\n                \":\"\n                (Â«term_=_Â» (Term.app `supáµ¢ [`U]) \"=\" (Term.app `Â«exprâŠ¤Â» []))\n                \")\")])\n             \",\"\n             (Term.forall \"âˆ€\" [`i] [] \",\" (Term.app `P [(Term.app `Â«expr âˆ£_ Â» [`f (Term.app `U [`i])])])))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"âŸ¨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"âŸ©\"))]\n              [])\n             []\n             (Tactic.exact \"exact\" (Term.app (Term.proj `hP \".\" (fieldIdx \"3\")) [`f `ğ’° `H]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.intro \"intro\" [`H `U])\n             []\n             (Tactic.exact \"exact\" (Term.app (Term.proj `hP \".\" (fieldIdx \"2\")) [`f `U `H]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"â†’\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.intro \"intro\" [`H `ğ’° `i])\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule\n                 [(patternIgnore (token.Â«â† Â» \"â†\"))]\n                 (Term.app\n                  (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                  [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n               \"]\")\n              [])\n             []\n             (Tactic.exact \"exact\" (Term.app `H [(Term.proj (Term.app `ğ’°.map [`i]) \".\" `opens_range)]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"â†’\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.exact\n              \"exact\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`H]\n                []\n                \"=>\"\n                (Term.anonymousCtor \"âŸ¨\" [`Y.affine_cover \",\" (Term.app `H [`Y.affine_cover])] \"âŸ©\"))))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"â†’\" (num \"5\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.intro \"intro\" [`H `U `g `hg])\n             []\n             (Tactic.skip \"skip\")\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule\n                 [(patternIgnore (token.Â«â† Â» \"â†\"))]\n                 (Term.app\n                  (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                  [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n               \"]\")\n              [])\n             []\n             (Tactic.apply \"apply\" `H)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"â†’\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.intro \"intro\" [`H `U])\n             []\n             (Tactic.tacticErw__\n              \"erw\"\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule [] (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `cancel_left_is_iso))]\n               \"]\")\n              [])\n             []\n             (Tactic.apply \"apply\" `H)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"â†’\" (num \"6\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.intro \"intro\" [`H])\n             []\n             (Tactic.exact\n              \"exact\"\n              (Term.anonymousCtor\n               \"âŸ¨\"\n               [`PUnit\n                \",\"\n                (Term.fun \"fun\" (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `Â«exprâŠ¤Â» [])))\n                \",\"\n                `csupáµ¢_const\n                \",\"\n                (Term.fun \"fun\" (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `H [(Term.hole \"_\")])))]\n               \"âŸ©\"))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"â†’\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"âŸ¨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `Î¹)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"âŸ©\"))]\n              [])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor \"âŸ¨\" [(Term.app `Y.open_cover_of_supr_eq_top [`U `hU]) \",\" (Term.hole \"_\")] \"âŸ©\"))\n             []\n             (Tactic.intro \"intro\" [`i])\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule\n                 [(patternIgnore (token.Â«â† Â» \"â†\"))]\n                 (Term.app\n                  (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                  [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n               \"]\")\n              [])\n             []\n             (convert \"convert\" [] (Term.app `H [`i]) [])\n             []\n             (Tactic.allGoals\n              \"all_goals\"\n              (Tactic.tacticSeq\n               (Tactic.tacticSeq1Indented\n                [(Std.Tactic.Ext.tacticExt1___ \"ext1\" []) \";\" (Tactic.exact \"exact\" `Subtype.range_coe)])))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"âŸ¨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"âŸ©\"))]\n             [])\n            []\n            (Tactic.exact \"exact\" (Term.app (Term.proj `hP \".\" (fieldIdx \"3\")) [`f `ğ’° `H]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.intro \"intro\" [`H `U])\n            []\n            (Tactic.exact \"exact\" (Term.app (Term.proj `hP \".\" (fieldIdx \"2\")) [`f `U `H]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"â†’\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.intro \"intro\" [`H `ğ’° `i])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule\n                [(patternIgnore (token.Â«â† Â» \"â†\"))]\n                (Term.app\n                 (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                 [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n              \"]\")\n             [])\n            []\n            (Tactic.exact \"exact\" (Term.app `H [(Term.proj (Term.app `ğ’°.map [`i]) \".\" `opens_range)]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"â†’\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.exact\n             \"exact\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`H]\n               []\n               \"=>\"\n               (Term.anonymousCtor \"âŸ¨\" [`Y.affine_cover \",\" (Term.app `H [`Y.affine_cover])] \"âŸ©\"))))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"â†’\" (num \"5\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.intro \"intro\" [`H `U `g `hg])\n            []\n            (Tactic.skip \"skip\")\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule\n                [(patternIgnore (token.Â«â† Â» \"â†\"))]\n                (Term.app\n                 (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                 [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n              \"]\")\n             [])\n            []\n            (Tactic.apply \"apply\" `H)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"â†’\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.intro \"intro\" [`H `U])\n            []\n            (Tactic.tacticErw__\n             \"erw\"\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [] (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `cancel_left_is_iso))]\n              \"]\")\n             [])\n            []\n            (Tactic.apply \"apply\" `H)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"â†’\" (num \"6\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.intro \"intro\" [`H])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.anonymousCtor\n              \"âŸ¨\"\n              [`PUnit\n               \",\"\n               (Term.fun \"fun\" (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `Â«exprâŠ¤Â» [])))\n               \",\"\n               `csupáµ¢_const\n               \",\"\n               (Term.fun \"fun\" (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `H [(Term.hole \"_\")])))]\n              \"âŸ©\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"â†’\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"âŸ¨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `Î¹)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"âŸ©\"))]\n             [])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor \"âŸ¨\" [(Term.app `Y.open_cover_of_supr_eq_top [`U `hU]) \",\" (Term.hole \"_\")] \"âŸ©\"))\n            []\n            (Tactic.intro \"intro\" [`i])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule\n                [(patternIgnore (token.Â«â† Â» \"â†\"))]\n                (Term.app\n                 (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                 [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n              \"]\")\n             [])\n            []\n            (convert \"convert\" [] (Term.app `H [`i]) [])\n            []\n            (Tactic.allGoals\n             \"all_goals\"\n             (Tactic.tacticSeq\n              (Tactic.tacticSeq1Indented\n               [(Std.Tactic.Ext.tacticExt1___ \"ext1\" []) \";\" (Tactic.exact \"exact\" `Subtype.range_coe)])))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n       [(Std.Tactic.rintro\n         \"rintro\"\n         [(Std.Tactic.RCases.rintroPat.one\n           (Std.Tactic.RCases.rcasesPat.tuple\n            \"âŸ¨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `Î¹)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)]) [])]\n            \"âŸ©\"))]\n         [])\n        []\n        (Tactic.refine'\n         \"refine'\"\n         (Term.anonymousCtor \"âŸ¨\" [(Term.app `Y.open_cover_of_supr_eq_top [`U `hU]) \",\" (Term.hole \"_\")] \"âŸ©\"))\n        []\n        (Tactic.intro \"intro\" [`i])\n        []\n        (Tactic.rwSeq\n         \"rw\"\n         []\n         (Tactic.rwRuleSeq\n          \"[\"\n          [(Tactic.rwRule\n            [(patternIgnore (token.Â«â† Â» \"â†\"))]\n            (Term.app\n             (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n             [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n          \"]\")\n         [])\n        []\n        (convert \"convert\" [] (Term.app `H [`i]) [])\n        []\n        (Tactic.allGoals\n         \"all_goals\"\n         (Tactic.tacticSeq\n          (Tactic.tacticSeq1Indented\n           [(Std.Tactic.Ext.tacticExt1___ \"ext1\" []) \";\" (Tactic.exact \"exact\" `Subtype.range_coe)])))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.allGoals\n       \"all_goals\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Std.Tactic.Ext.tacticExt1___ \"ext1\" []) \";\" (Tactic.exact \"exact\" `Subtype.range_coe)])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" `Subtype.range_coe)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `Subtype.range_coe\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.Ext.tacticExt1___ \"ext1\" [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (convert \"convert\" [] (Term.app `H [`i]) [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `H [`i])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `i\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.rwSeq\n       \"rw\"\n       []\n       (Tactic.rwRuleSeq\n        \"[\"\n        [(Tactic.rwRule\n          [(patternIgnore (token.Â«â† Â» \"â†\"))]\n          (Term.app\n           (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n           [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n        \"]\")\n       [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n       [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))\n      `f\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `morphism_restrict_opens_range\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren\n     \"(\"\n     (Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])\n     \")\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.proj `hP \".\" (fieldIdx \"1\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hP\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`i])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `i\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.refine'\n       \"refine'\"\n       (Term.anonymousCtor \"âŸ¨\" [(Term.app `Y.open_cover_of_supr_eq_top [`U `hU]) \",\" (Term.hole \"_\")] \"âŸ©\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor \"âŸ¨\" [(Term.app `Y.open_cover_of_supr_eq_top [`U `hU]) \",\" (Term.hole \"_\")] \"âŸ©\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `Y.open_cover_of_supr_eq_top [`U `hU])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hU\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `U\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `Y.open_cover_of_supr_eq_top\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rintro\n       \"rintro\"\n       [(Std.Tactic.RCases.rintroPat.one\n         (Std.Tactic.RCases.rcasesPat.tuple\n          \"âŸ¨\"\n          [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `Î¹)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)]) [])]\n          \"âŸ©\"))]\n       [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"â†’\" (num \"2\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â†’ Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â†” Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â† Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  property_is_local_at_target.open_cover_tfae\n  { P : morphism_property Scheme } ( hP : property_is_local_at_target P ) { X Y : Scheme .{ u } } ( f : Â«expr âŸ¶ Â» X Y )\n    :\n      TFAE\n        [\n          P f\n            ,\n            âˆƒ\n              ğ’° : Scheme.open_cover .{ u } Y\n              ,\n              âˆ€ i : ğ’° . J , P ( pullback.snd : Â«expr âŸ¶ Â» ğ’° . pullback_cover f . obj i ğ’° . obj i )\n            ,\n            âˆ€\n              ( ğ’° : Scheme.open_cover .{ u } Y ) ( i : ğ’° . J )\n              ,\n              P ( pullback.snd : Â«expr âŸ¶ Â» ğ’° . pullback_cover f . obj i ğ’° . obj i )\n            ,\n            âˆ€ U : opens Y . carrier , P Â«expr âˆ£_ Â» f U\n            ,\n            âˆ€\n              { U : Scheme } ( g : Â«expr âŸ¶ Â» U Y ) [ is_open_immersion g ]\n              ,\n              P ( pullback.snd : Â«expr âŸ¶ Â» pullback f g U )\n            ,\n            âˆƒ ( Î¹ : Type u ) ( U : Î¹ â†’ opens Y . carrier ) ( hU : supáµ¢ U = Â«exprâŠ¤Â» ) , âˆ€ i , P Â«expr âˆ£_ Â» f U i\n          ]\n  :=\n    by\n      tfae_have 2 â†’ 1\n        Â· rintro âŸ¨ ğ’° , H âŸ© exact hP . 3 f ğ’° H\n        tfae_have 1 â†’ 4\n        Â· intro H U exact hP . 2 f U H\n        tfae_have 4 â†’ 3\n        Â· intro H ğ’° i rw [ â† hP . 1 . arrow_mk_iso_iff morphism_restrict_opens_range f _ ] exact H ğ’°.map i . opens_range\n        tfae_have 3 â†’ 2\n        Â· exact fun H => âŸ¨ Y.affine_cover , H Y.affine_cover âŸ©\n        tfae_have 4 â†’ 5\n        Â· intro H U g hg skip rw [ â† hP . 1 . arrow_mk_iso_iff morphism_restrict_opens_range f _ ] apply H\n        tfae_have 5 â†’ 4\n        Â· intro H U erw [ hP . 1 . cancel_left_is_iso ] apply H\n        tfae_have 4 â†’ 6\n        Â· intro H exact âŸ¨ PUnit , fun _ => Â«exprâŠ¤Â» , csupáµ¢_const , fun _ => H _ âŸ©\n        tfae_have 6 â†’ 2\n        Â·\n          rintro âŸ¨ Î¹ , U , hU , H âŸ©\n            refine' âŸ¨ Y.open_cover_of_supr_eq_top U hU , _ âŸ©\n            intro i\n            rw [ â† hP . 1 . arrow_mk_iso_iff morphism_restrict_opens_range f _ ]\n            convert H i\n            all_goals ext1 ; exact Subtype.range_coe\n        tfae_finish\n#align property_is_local_at_target.open_cover_tfae property_is_local_at_target.open_cover_tfae\n\n",
 "open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem property_is_local_at_target.open_cover_iff {P : morphism_property Scheme} (hP : property_is_local_at_target P)\n    {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) (ğ’° : Scheme.open_cover.{u} Y) :\n    P f â†” âˆ€ i, P (pullback.snd : Â«expr âŸ¶ Â» (pullback f (ğ’°.map i)) _) :=\n  âŸ¨fun H =>\n    let h := ((hP.open_cover_tfae f).out 0 2).mp H\n    h ğ’°,\n    fun H =>\n    let h := ((hP.open_cover_tfae f).out 1 0).mp\n    h âŸ¨ğ’°, HâŸ©âŸ©\n#align property_is_local_at_target.open_cover_iff property_is_local_at_target.open_cover_iff\n\n",
 "map_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_affine_open.map_is_iso {X Y : Scheme} {U : opens Y.carrier} (hU : is_affine_open U) (f : Â«expr âŸ¶ Â» X Y)\n    [IsIso f] : is_affine_open ((opens.map f.1.base).obj U) :=\n  haveI : is_affine _ := hU\n  is_affine_of_iso (Â«expr âˆ£_ Â» f U)\n#align is_affine_open.map_is_iso is_affine_open.map_is_iso\n\n",
 "is_local_of_open_cover_imply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem affine_target_morphism_property.is_local_of_open_cover_imply (P : affine_target_morphism_property)\n    (hP : P.to_property.respects_iso)\n    (H :\n      âˆ€ {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y),\n        (âˆƒ (ğ’° : Scheme.open_cover.{u} Y)(_ : âˆ€ i, is_affine (ğ’°.obj i)),\n            âˆ€ i : ğ’°.J, P (pullback.snd : Â«expr âŸ¶ Â» ((ğ’°.pullback_cover f).obj i) (ğ’°.obj i))) â†’\n          âˆ€ {U : Scheme} (g : Â«expr âŸ¶ Â» U Y) [is_affine U] [is_open_immersion g],\n            P (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) U)) :\n    P.is_local := by\n  refine' âŸ¨hP, _, _âŸ©\n  Â· introv h\n    skip\n    haveI : is_affine _ := (top_is_affine_open Y).basic_open_is_affine r\n    delta morphism_restrict\n    rw [affine_cancel_left_is_iso hP]\n    refine' @H f âŸ¨Scheme.open_cover_of_is_iso ((Â«exprğŸ™Â») Y), _, _âŸ© (Y.of_restrict _) _inst _\n    Â· intro i\n      dsimp\n      infer_instance\n    Â· intro i\n      dsimp\n      rwa [â† category.comp_id pullback.snd, â† pullback.condition, affine_cancel_left_is_iso hP]\n  Â· introv hs hs'\n    skip\n    replace hs := ((top_is_affine_open Y).basic_open_union_eq_self_iff _).mpr hs\n    have := H f âŸ¨Y.open_cover_of_supr_eq_top _ hs, _, _âŸ© ((Â«exprğŸ™Â») _)\n    rwa [â† category.comp_id pullback.snd, â† pullback.condition, affine_cancel_left_is_iso hP] at this\n    Â· intro i\n      exact (top_is_affine_open Y).basic_open_is_affine _\n    Â· rintro (i : s)\n      specialize hs' i\n      haveI : is_affine _ := (top_is_affine_open Y).basic_open_is_affine i.1\n      delta morphism_restrict at hs'\n      rwa [affine_cancel_left_is_iso hP] at hs'\n#align\n  affine_target_morphism_property.is_local_of_open_cover_imply affine_target_morphism_property.is_local_of_open_cover_imply\n\n",
 "diagonal_target_affine_locally_of_open_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem diagonal_target_affine_locally_of_open_cover (P : affine_target_morphism_property) (hP : P.is_local)\n    {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) (ğ’° : Scheme.open_cover.{u} Y) [âˆ€ i, is_affine (ğ’°.obj i)]\n    (ğ’°' : âˆ€ i, Scheme.open_cover.{u} (pullback f (ğ’°.map i))) [âˆ€ i j, is_affine ((ğ’°' i).obj j)]\n    (hğ’°' : âˆ€ i j k, P (pullback.map_desc ((ğ’°' i).map j) ((ğ’°' i).map k) pullback.snd)) :\n    (target_affine_locally P).diagonal f :=\n  by\n  refine' (hP.affine_open_cover_iff _ _).mpr _\n  Â·\n    exact\n      (Scheme.pullback.open_cover_of_base ğ’° f f).bind fun i =>\n        Scheme.pullback.open_cover_of_left_right.{u, u} (ğ’°' i) (ğ’°' i) pullback.snd pullback.snd\n  Â· intro i\n    dsimp at *\n    infer_instance\n  Â· rintro âŸ¨i, j, kâŸ©\n    dsimp\n    convert\n      (affine_cancel_left_is_iso hP.1 (pullback_diagonal_map_iso _ _ ((ğ’°' i).map j) ((ğ’°' i).map k)).inv pullback.snd).mp\n        _\n    pick_goal 3\n    Â· convert hğ’°' i j k\n      apply pullback.hom_ext <;> simp\n    all_goals\n      apply pullback.hom_ext <;>\n        simp only [category.assoc, pullback.lift_fst, pullback.lift_snd, pullback.lift_fst_assoc,\n          pullback.lift_snd_assoc]\n#align diagonal_target_affine_locally_of_open_cover diagonal_target_affine_locally_of_open_cover\n\n",
 "diagonal_target_affine_locally_eq_target_affine_locally":
 "theorem diagonal_target_affine_locally_eq_target_affine_locally (P : affine_target_morphism_property)\n    (hP : P.is_local) : (target_affine_locally P).diagonal = target_affine_locally P.diagonal :=\n  by\n  ext (_ _ f)\n  exact ((hP.diagonal_affine_open_cover_tfae f).out 0 1).trans ((hP.diagonal.affine_open_cover_tfae f).out 1 0)\n#align diagonal_target_affine_locally_eq_target_affine_locally diagonal_target_affine_locally_eq_target_affine_locally\n\n",
 "diagonal_respects_iso":
 "theorem affine_target_morphism_property.diagonal_respects_iso (P : affine_target_morphism_property)\n    (hP : P.to_property.respects_iso) : P.diagonal.to_property.respects_iso :=\n  by\n  delta affine_target_morphism_property.diagonal\n  apply affine_target_morphism_property.respects_iso_mk\n  Â· introv H _ _\n    skip\n    rw [pullback.map_desc_comp, affine_cancel_left_is_iso hP, affine_cancel_right_is_iso hP]\n    apply H\n  Â· introv H _ _\n    skip\n    rw [pullback.map_desc_comp, affine_cancel_right_is_iso hP]\n    apply H\n#align affine_target_morphism_property.diagonal_respects_iso affine_target_morphism_property.diagonal_respects_iso\n\n",
 "diagonal_of_target_affine_locally":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem affine_target_morphism_property.diagonal_of_target_affine_locally (P : affine_target_morphism_property)\n    (hP : P.is_local) {X Y U : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» U Y) [is_affine U] [is_open_immersion g]\n    (H : (target_affine_locally P).diagonal f) : P.diagonal (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _) :=\n  by\n  rintro U V fâ‚ fâ‚‚ _ _ _ _\n  skip\n  replace H := ((hP.affine_open_cover_tfae (pullback.diagonal f)).out 0 3).mp H\n  let gâ‚ :=\n    pullback.map (Â«expr â‰« Â» fâ‚ pullback.snd) (Â«expr â‰« Â» fâ‚‚ pullback.snd) f f (Â«expr â‰« Â» fâ‚ pullback.fst)\n      (Â«expr â‰« Â» fâ‚‚ pullback.fst) g (by rw [category.assoc, category.assoc, pullback.condition])\n      (by rw [category.assoc, category.assoc, pullback.condition])\n  let gâ‚‚ : Â«expr âŸ¶ Â» (pullback fâ‚ fâ‚‚) (pullback f g) := Â«expr â‰« Â» pullback.fst fâ‚\n  specialize H gâ‚\n  rw [â† affine_cancel_left_is_iso hP.1 (pullback_diagonal_map_iso f _ fâ‚ fâ‚‚).hom]\n  convert H\n  Â·\n    apply pullback.hom_ext <;>\n      simp only [category.assoc, pullback.lift_fst, pullback.lift_snd, pullback.lift_fst_assoc, pullback.lift_snd_assoc,\n        category.comp_id, pullback_diagonal_map_iso_hom_fst, pullback_diagonal_map_iso_hom_snd]\n#align\n  affine_target_morphism_property.diagonal_of_target_affine_locally affine_target_morphism_property.diagonal_of_target_affine_locally\n\n",
 "diagonal_affine_open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`P] [\":\" `affine_target_morphism_property] \"}\")\n        (Term.explicitBinder \"(\" [`hP] [\":\" (Term.proj `P \".\" `is_local)] [] \")\")\n        (Term.implicitBinder \"{\" [`X `Y] [\":\" (Term.explicitUniv `Scheme \".{\" [`u] \"}\")] \"}\")\n        (Term.explicitBinder \"(\" [`f] [\":\" (Term.app `Â«expr âŸ¶ Â» [`X `Y])] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(Â«term[_]Â»\n           \"[\"\n           [(Term.app (Term.proj (Term.app `target_affine_locally [`P]) \".\" `diagonal) [`f])\n            \",\"\n            (Â«termâˆƒ_,_Â»\n             \"âˆƒ\"\n             (Lean.explicitBinders\n              [(Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `ğ’°)]\n                \":\"\n                (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`Y])\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent (Term.hole \"_\"))]\n                \":\"\n                (Term.forall \"âˆ€\" [`i] [] \",\" (Term.app `is_affine [(Term.app (Term.proj `ğ’° \".\" `obj) [`i])]))\n                \")\")])\n             \",\"\n             (Term.forall\n              \"âˆ€\"\n              [`i]\n              [(Term.typeSpec \":\" `ğ’°.J)]\n              \",\"\n              (Term.app\n               `P.diagonal\n               [(Term.typeAscription\n                 \"(\"\n                 `pullback.snd\n                 \":\"\n                 [(Term.app `Â«expr âŸ¶ Â» [(Term.app `pullback [`f (Term.app `ğ’°.map [`i])]) (Term.hole \"_\")])]\n                 \")\")])))\n            \",\"\n            (Term.forall\n             \"âˆ€\"\n             [(Term.explicitBinder\n               \"(\"\n               [`ğ’°]\n               [\":\" (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`Y])]\n               []\n               \")\")\n              (Term.instBinder\n               \"[\"\n               []\n               (Term.forall \"âˆ€\" [`i] [] \",\" (Term.app `is_affine [(Term.app (Term.proj `ğ’° \".\" `obj) [`i])]))\n               \"]\")\n              (Term.explicitBinder \"(\" [`i] [\":\" (Term.proj `ğ’° \".\" `J)] [] \")\")]\n             []\n             \",\"\n             (Term.app\n              `P.diagonal\n              [(Term.typeAscription\n                \"(\"\n                `pullback.snd\n                \":\"\n                [(Term.app `Â«expr âŸ¶ Â» [(Term.app `pullback [`f (Term.app `ğ’°.map [`i])]) (Term.hole \"_\")])]\n                \")\")]))\n            \",\"\n            (Term.forall\n             \"âˆ€\"\n             [(Term.implicitBinder \"{\" [`U] [\":\" `Scheme] \"}\")\n              (Term.explicitBinder \"(\" [`g] [\":\" (Term.app `Â«expr âŸ¶ Â» [`U `Y])] [] \")\")\n              (Term.instBinder \"[\" [] (Term.app `is_affine [`U]) \"]\")\n              (Term.instBinder \"[\" [] (Term.app `is_open_immersion [`g]) \"]\")]\n             []\n             \",\"\n             (Term.app\n              `P.diagonal\n              [(Term.typeAscription\n                \"(\"\n                `pullback.snd\n                \":\"\n                [(Term.app `Â«expr âŸ¶ Â» [(Term.app `pullback [`f `g]) (Term.hole \"_\")])]\n                \")\")]))\n            \",\"\n            (Â«termâˆƒ_,_Â»\n             \"âˆƒ\"\n             (Lean.explicitBinders\n              [(Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `ğ’°)]\n                \":\"\n                (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`Y])\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent (Term.hole \"_\"))]\n                \":\"\n                (Term.forall \"âˆ€\" [`i] [] \",\" (Term.app `is_affine [(Term.app (Term.proj `ğ’° \".\" `obj) [`i])]))\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `ğ’°')]\n                \":\"\n                (Term.forall\n                 \"âˆ€\"\n                 [`i]\n                 []\n                 \",\"\n                 (Term.app\n                  (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\")\n                  [(Term.app `pullback [`f (Term.app (Term.proj `ğ’° \".\" `map) [`i])])]))\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent (Term.hole \"_\"))]\n                \":\"\n                (Term.forall\n                 \"âˆ€\"\n                 [`i `j]\n                 []\n                 \",\"\n                 (Term.app `is_affine [(Term.app (Term.proj (Term.app `ğ’°' [`i]) \".\" `obj) [`j])]))\n                \")\")])\n             \",\"\n             (Term.forall\n              \"âˆ€\"\n              [`i `j `k]\n              []\n              \",\"\n              (Term.app\n               `P\n               [(Term.app\n                 `pullback.map_desc\n                 [(Term.app (Term.proj (Term.app `ğ’°' [`i]) \".\" `map) [`j])\n                  (Term.app (Term.proj (Term.app `ğ’°' [`i]) \".\" `map) [`k])\n                  `pullback.snd])])))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Mathlib.Tactic.introv\n              \"introv\"\n              [(Lean.binderIdent `H)\n               (Lean.binderIdent `hU)\n               (Lean.binderIdent `hg)\n               (Lean.binderIdent (Term.hole \"_\"))\n               (Lean.binderIdent (Term.hole \"_\"))])\n             []\n             (Tactic.skip \"skip\")\n             []\n             (Tactic.Â«tactic_<;>_Â»\n              (Tactic.apply \"apply\" `P.diagonal_of_target_affine_locally)\n              \"<;>\"\n              (Tactic.assumption \"assumption\"))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"â†’\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Mathlib.Tactic.introv \"introv\" [(Lean.binderIdent `H) (Lean.binderIdent `hğ’°)])\n             []\n             (Tactic.skip \"skip\")\n             []\n             (Tactic.apply \"apply\" `H)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"â†’\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.exact\n              \"exact\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`H]\n                []\n                \"=>\"\n                (Term.anonymousCtor\n                 \"âŸ¨\"\n                 [`Y.affine_cover \",\" `infer_instance \",\" (Term.app `H [`Y.affine_cover])]\n                 \"âŸ©\"))))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"5\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"âŸ¨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hğ’°)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"âŸ©\"))]\n              [])\n             []\n             (Tactic.skip \"skip\")\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor\n               \"âŸ¨\"\n               [`ğ’°\n                \",\"\n                `infer_instance\n                \",\"\n                (Term.fun\n                 \"fun\"\n                 (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `Scheme.affine_cover [(Term.hole \"_\")])))\n                \",\"\n                `infer_instance\n                \",\"\n                (Term.hole \"_\")]\n               \"âŸ©\"))\n             []\n             (Tactic.intro \"intro\" [`i `j `k])\n             []\n             (Tactic.apply \"apply\" `H)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"â†’\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"âŸ¨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°')])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"âŸ©\"))]\n              [])\n             []\n             (Tactic.exact \"exact\" (Term.app `diagonal_target_affine_locally_of_open_cover [`P `hP `f `ğ’° `ğ’°' `H]))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Mathlib.Tactic.introv\n             \"introv\"\n             [(Lean.binderIdent `H)\n              (Lean.binderIdent `hU)\n              (Lean.binderIdent `hg)\n              (Lean.binderIdent (Term.hole \"_\"))\n              (Lean.binderIdent (Term.hole \"_\"))])\n            []\n            (Tactic.skip \"skip\")\n            []\n            (Tactic.Â«tactic_<;>_Â»\n             (Tactic.apply \"apply\" `P.diagonal_of_target_affine_locally)\n             \"<;>\"\n             (Tactic.assumption \"assumption\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"â†’\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Mathlib.Tactic.introv \"introv\" [(Lean.binderIdent `H) (Lean.binderIdent `hğ’°)])\n            []\n            (Tactic.skip \"skip\")\n            []\n            (Tactic.apply \"apply\" `H)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"â†’\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.exact\n             \"exact\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`H]\n               []\n               \"=>\"\n               (Term.anonymousCtor\n                \"âŸ¨\"\n                [`Y.affine_cover \",\" `infer_instance \",\" (Term.app `H [`Y.affine_cover])]\n                \"âŸ©\"))))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"5\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"âŸ¨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hğ’°)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"âŸ©\"))]\n             [])\n            []\n            (Tactic.skip \"skip\")\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor\n              \"âŸ¨\"\n              [`ğ’°\n               \",\"\n               `infer_instance\n               \",\"\n               (Term.fun\n                \"fun\"\n                (Term.basicFun [(Term.hole \"_\")] [] \"=>\" (Term.app `Scheme.affine_cover [(Term.hole \"_\")])))\n               \",\"\n               `infer_instance\n               \",\"\n               (Term.hole \"_\")]\n              \"âŸ©\"))\n            []\n            (Tactic.intro \"intro\" [`i `j `k])\n            []\n            (Tactic.apply \"apply\" `H)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"â†’\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"âŸ¨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°')])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"âŸ©\"))]\n             [])\n            []\n            (Tactic.exact \"exact\" (Term.app `diagonal_target_affine_locally_of_open_cover [`P `hP `f `ğ’° `ğ’°' `H]))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n       [(Std.Tactic.rintro\n         \"rintro\"\n         [(Std.Tactic.RCases.rintroPat.one\n           (Std.Tactic.RCases.rcasesPat.tuple\n            \"âŸ¨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n              [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°')]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n              [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)]) [])]\n            \"âŸ©\"))]\n         [])\n        []\n        (Tactic.exact \"exact\" (Term.app `diagonal_target_affine_locally_of_open_cover [`P `hP `f `ğ’° `ğ’°' `H]))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.app `diagonal_target_affine_locally_of_open_cover [`P `hP `f `ğ’° `ğ’°' `H]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `diagonal_target_affine_locally_of_open_cover [`P `hP `f `ğ’° `ğ’°' `H])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `ğ’°'\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `ğ’°\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `f\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hP\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `P\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `diagonal_target_affine_locally_of_open_cover\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rintro\n       \"rintro\"\n       [(Std.Tactic.RCases.rintroPat.one\n         (Std.Tactic.RCases.rcasesPat.tuple\n          \"âŸ¨\"\n          [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo\n            (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n            [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°')]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo\n            (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n            [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)]) [])]\n          \"âŸ©\"))]\n       [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"â†’\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â†’ Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â†” Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â† Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae\n  { P : affine_target_morphism_property } ( hP : P . is_local ) { X Y : Scheme .{ u } } ( f : Â«expr âŸ¶ Â» X Y )\n    :\n      TFAE\n        [\n          target_affine_locally P . diagonal f\n            ,\n            âˆƒ\n              ( ğ’° : Scheme.open_cover .{ u } Y ) ( _ : âˆ€ i , is_affine ğ’° . obj i )\n              ,\n              âˆ€ i : ğ’°.J , P.diagonal ( pullback.snd : Â«expr âŸ¶ Â» pullback f ğ’°.map i _ )\n            ,\n            âˆ€\n              ( ğ’° : Scheme.open_cover .{ u } Y ) [ âˆ€ i , is_affine ğ’° . obj i ] ( i : ğ’° . J )\n              ,\n              P.diagonal ( pullback.snd : Â«expr âŸ¶ Â» pullback f ğ’°.map i _ )\n            ,\n            âˆ€\n              { U : Scheme } ( g : Â«expr âŸ¶ Â» U Y ) [ is_affine U ] [ is_open_immersion g ]\n              ,\n              P.diagonal ( pullback.snd : Â«expr âŸ¶ Â» pullback f g _ )\n            ,\n            âˆƒ\n              ( ğ’° : Scheme.open_cover .{ u } Y )\n                ( _ : âˆ€ i , is_affine ğ’° . obj i )\n                ( ğ’°' : âˆ€ i , Scheme.open_cover .{ u } pullback f ğ’° . map i )\n                ( _ : âˆ€ i j , is_affine ğ’°' i . obj j )\n              ,\n              âˆ€ i j k , P pullback.map_desc ğ’°' i . map j ğ’°' i . map k pullback.snd\n          ]\n  :=\n    by\n      tfae_have 1 â†’ 4\n        Â· introv H hU hg _ _ skip apply P.diagonal_of_target_affine_locally <;> assumption\n        tfae_have 4 â†’ 3\n        Â· introv H hğ’° skip apply H\n        tfae_have 3 â†’ 2\n        Â· exact fun H => âŸ¨ Y.affine_cover , infer_instance , H Y.affine_cover âŸ©\n        tfae_have 2 â†’ 5\n        Â·\n          rintro âŸ¨ ğ’° , hğ’° , H âŸ©\n            skip\n            refine' âŸ¨ ğ’° , infer_instance , fun _ => Scheme.affine_cover _ , infer_instance , _ âŸ©\n            intro i j k\n            apply H\n        tfae_have 5 â†’ 1\n        Â· rintro âŸ¨ ğ’° , _ , ğ’°' , _ , H âŸ© exact diagonal_target_affine_locally_of_open_cover P hP f ğ’° ğ’°' H\n        tfae_finish\n#align\n  affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae\n\n",
 "diagonal":
 "theorem affine_target_morphism_property.is_local.diagonal {P : affine_target_morphism_property} (hP : P.is_local) :\n    P.diagonal.is_local :=\n  affine_target_morphism_property.is_local_of_open_cover_imply P.diagonal (P.diagonal_respects_iso hP.1) fun _ _ f =>\n    ((hP.diagonal_affine_open_cover_tfae f).out 1 3).mp\n#align affine_target_morphism_property.is_local.diagonal affine_target_morphism_property.is_local.diagonal\n\n",
 "affine_target_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem affine_target_morphism_property.is_local.affine_target_iff {P : affine_target_morphism_property}\n    (hP : P.is_local) {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) [is_affine Y] : target_affine_locally P f â†” P f :=\n  by\n  rw [hP.affine_open_cover_iff f _]\n  swap; Â· exact Scheme.open_cover_of_is_iso ((Â«exprğŸ™Â») Y)\n  swap;\n  Â· intro\n    dsimp\n    infer_instance\n  trans P (pullback.snd : Â«expr âŸ¶ Â» (pullback f ((Â«exprğŸ™Â») _)) _)\n  Â· exact âŸ¨fun H => H PUnit.unit, fun H _ => HâŸ©\n  rw [â† category.comp_id pullback.snd, â† pullback.condition, affine_cancel_left_is_iso hP.1]\n#align\n  affine_target_morphism_property.is_local.affine_target_iff affine_target_morphism_property.is_local.affine_target_iff\n\n",
 "affine_open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `affine_target_morphism_property.is_local.affine_open_cover_tfae [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`P] [\":\" `affine_target_morphism_property] \"}\")\n        (Term.explicitBinder \"(\" [`hP] [\":\" (Term.proj `P \".\" `is_local)] [] \")\")\n        (Term.implicitBinder \"{\" [`X `Y] [\":\" (Term.explicitUniv `Scheme \".{\" [`u] \"}\")] \"}\")\n        (Term.explicitBinder \"(\" [`f] [\":\" (Term.app `Â«expr âŸ¶ Â» [`X `Y])] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(Â«term[_]Â»\n           \"[\"\n           [(Term.app `target_affine_locally [`P `f])\n            \",\"\n            (Â«termâˆƒ_,_Â»\n             \"âˆƒ\"\n             (Lean.explicitBinders\n              [(Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `ğ’°)]\n                \":\"\n                (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`Y])\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent (Term.hole \"_\"))]\n                \":\"\n                (Term.forall \"âˆ€\" [`i] [] \",\" (Term.app `is_affine [(Term.app (Term.proj `ğ’° \".\" `obj) [`i])]))\n                \")\")])\n             \",\"\n             (Term.forall\n              \"âˆ€\"\n              [`i]\n              [(Term.typeSpec \":\" (Term.proj `ğ’° \".\" `J))]\n              \",\"\n              (Term.app\n               `P\n               [(Term.typeAscription\n                 \"(\"\n                 `pullback.snd\n                 \":\"\n                 [(Term.app\n                   `Â«expr âŸ¶ Â»\n                   [(Term.app (Term.proj (Term.app `ğ’°.pullback_cover [`f]) \".\" `obj) [`i]) (Term.app `ğ’°.obj [`i])])]\n                 \")\")])))\n            \",\"\n            (Term.forall\n             \"âˆ€\"\n             [(Term.explicitBinder\n               \"(\"\n               [`ğ’°]\n               [\":\" (Term.app (Term.explicitUniv `Scheme.open_cover \".{\" [`u] \"}\") [`Y])]\n               []\n               \")\")\n              (Term.instBinder\n               \"[\"\n               []\n               (Term.forall \"âˆ€\" [`i] [] \",\" (Term.app `is_affine [(Term.app (Term.proj `ğ’° \".\" `obj) [`i])]))\n               \"]\")\n              (Term.explicitBinder \"(\" [`i] [\":\" (Term.proj `ğ’° \".\" `J)] [] \")\")]\n             []\n             \",\"\n             (Term.app\n              `P\n              [(Term.typeAscription\n                \"(\"\n                `pullback.snd\n                \":\"\n                [(Term.app\n                  `Â«expr âŸ¶ Â»\n                  [(Term.app (Term.proj (Term.app `ğ’°.pullback_cover [`f]) \".\" `obj) [`i]) (Term.app `ğ’°.obj [`i])])]\n                \")\")]))\n            \",\"\n            (Term.forall\n             \"âˆ€\"\n             [(Term.implicitBinder \"{\" [`U] [\":\" `Scheme] \"}\")\n              (Term.explicitBinder \"(\" [`g] [\":\" (Term.app `Â«expr âŸ¶ Â» [`U `Y])] [] \")\")\n              (Term.instBinder \"[\" [] (Term.app `is_affine [`U]) \"]\")\n              (Term.instBinder \"[\" [] (Term.app `is_open_immersion [`g]) \"]\")]\n             []\n             \",\"\n             (Term.app\n              `P\n              [(Term.typeAscription\n                \"(\"\n                `pullback.snd\n                \":\"\n                [(Term.app `Â«expr âŸ¶ Â» [(Term.app `pullback [`f `g]) `U])]\n                \")\")]))\n            \",\"\n            (Â«termâˆƒ_,_Â»\n             \"âˆƒ\"\n             (Lean.explicitBinders\n              [(Lean.bracketedExplicitBinders \"(\" [(Lean.binderIdent `Î¹)] \":\" (Term.type \"Type\" [`u]) \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `U)]\n                \":\"\n                (Term.arrow `Î¹ \"â†’\" (Term.app `opens [(Term.proj `Y \".\" `carrier)]))\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `hU)]\n                \":\"\n                (Â«term_=_Â» (Term.app `supáµ¢ [`U]) \"=\" (Term.app `Â«exprâŠ¤Â» []))\n                \")\")\n               (Lean.bracketedExplicitBinders\n                \"(\"\n                [(Lean.binderIdent `hU')]\n                \":\"\n                (Term.forall \"âˆ€\" [`i] [] \",\" (Term.app `is_affine_open [(Term.app `U [`i])]))\n                \")\")])\n             \",\"\n             (Term.forall\n              \"âˆ€\"\n              [`i]\n              []\n              \",\"\n              (Term.app (Term.explicit \"@\" `P) [(Term.app `Â«expr âˆ£_ Â» [`f (Term.app `U [`i])]) (Term.app `hU' [`i])])))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.intro \"intro\" [`H `U `g `hâ‚ `hâ‚‚])\n             []\n             (Tactic.skip \"skip\")\n             []\n             (Mathlib.Tactic.tacticReplace_\n              \"replace\"\n              (Term.haveDecl\n               (Term.haveIdDecl\n                [`H []]\n                []\n                \":=\"\n                (Term.app\n                 `H\n                 [(Term.anonymousCtor\n                   \"âŸ¨\"\n                   [(Term.anonymousCtor \"âŸ¨\" [(Term.hole \"_\") \",\" `hâ‚‚.base_open.open_range] \"âŸ©\")\n                    \",\"\n                    (Term.app `range_is_affine_open_of_open_immersion [`g])]\n                   \"âŸ©\")]))))\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» \"â†\"))] `P.to_property_apply)] \"]\")\n              [(Tactic.location \"at\" (Tactic.locationHyp [`H] [(patternIgnore (token.Â«âŠ¢Â» \"âŠ¢\"))]))])\n             []\n             (Std.Tactic.tacticRwa__\n              \"rwa\"\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule\n                 [(patternIgnore (token.Â«â† Â» \"â†\"))]\n                 (Term.app\n                  (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                  [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n               \"]\")\n              [])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"â†’\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.intro \"intro\" [`H `ğ’° `hğ’° `i]) [] (Tactic.skip \"skip\") [] (Tactic.apply \"apply\" `H)])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"â†’\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.exact\n              \"exact\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`H]\n                []\n                \"=>\"\n                (Term.anonymousCtor\n                 \"âŸ¨\"\n                 [`Y.affine_cover \",\" `infer_instance \",\" (Term.app `H [`Y.affine_cover])]\n                 \"âŸ©\"))))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"âŸ¨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hğ’°)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"âŸ©\"))]\n              [])\n             []\n             (Tactic.exact \"exact\" (Term.app `target_affine_locally_of_open_cover [`hP `f `ğ’° `H]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"â†’\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"âŸ¨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `Î¹)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU')])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                   [])]\n                 \"âŸ©\"))]\n              [])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor\n               \"âŸ¨\"\n               [(Term.app `Y.open_cover_of_supr_eq_top [`U `hU]) \",\" `hU' \",\" (Term.hole \"_\")]\n               \"âŸ©\"))\n             []\n             (Tactic.intro \"intro\" [`i])\n             []\n             (Tactic.specialize \"specialize\" (Term.app `H [`i]))\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» \"â†\"))] `P.to_property_apply)\n                \",\"\n                (Tactic.rwRule\n                 [(patternIgnore (token.Â«â† Â» \"â†\"))]\n                 (Term.app\n                  (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                  [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n               \"]\")\n              [])\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» \"â†\"))] `P.to_property_apply)] \"]\")\n              [(Tactic.location \"at\" (Tactic.locationHyp [`H] []))])\n             []\n             (convert \"convert\" [] `H [])\n             []\n             (Tactic.allGoals\n              \"all_goals\"\n              (Tactic.tacticSeq\n               (Tactic.tacticSeq1Indented\n                [(Std.Tactic.Ext.tacticExt1___ \"ext1\" []) \";\" (Tactic.exact \"exact\" `Subtype.range_coe)])))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"5\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n            [(Tactic.intro \"intro\" [`H])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor\n               \"âŸ¨\"\n               [`Y.carrier\n                \",\"\n                (Term.fun\n                 \"fun\"\n                 (Term.basicFun [`x] [] \"=>\" (Term.proj (Term.app `Y.affine_cover.map [`x]) \".\" `opens_range)))\n                \",\"\n                (Term.hole \"_\")\n                \",\"\n                (Term.fun\n                 \"fun\"\n                 (Term.basicFun [`i] [] \"=>\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])))\n                \",\"\n                (Term.hole \"_\")]\n               \"âŸ©\"))\n             []\n             (tactic__\n              (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n              [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eq_top_iff)] \"]\") [])\n               []\n               (Tactic.intro \"intro\" [`x (Term.hole \"_\")])\n               []\n               (Tactic.tacticErw__ \"erw\" (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `opens.mem_supr)] \"]\") [])\n               []\n               (Tactic.exact \"exact\" (Term.anonymousCtor \"âŸ¨\" [`x \",\" (Term.app `Y.affine_cover.covers [`x])] \"âŸ©\"))])\n             []\n             (tactic__\n              (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n              [(Tactic.intro \"intro\" [`i])\n               []\n               (Tactic.exact\n                \"exact\"\n                (Term.app\n                 `H\n                 [(Term.anonymousCtor\n                   \"âŸ¨\"\n                   [(Term.hole \"_\") \",\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])]\n                   \"âŸ©\")]))])])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.intro \"intro\" [`H `U `g `hâ‚ `hâ‚‚])\n            []\n            (Tactic.skip \"skip\")\n            []\n            (Mathlib.Tactic.tacticReplace_\n             \"replace\"\n             (Term.haveDecl\n              (Term.haveIdDecl\n               [`H []]\n               []\n               \":=\"\n               (Term.app\n                `H\n                [(Term.anonymousCtor\n                  \"âŸ¨\"\n                  [(Term.anonymousCtor \"âŸ¨\" [(Term.hole \"_\") \",\" `hâ‚‚.base_open.open_range] \"âŸ©\")\n                   \",\"\n                   (Term.app `range_is_affine_open_of_open_immersion [`g])]\n                  \"âŸ©\")]))))\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» \"â†\"))] `P.to_property_apply)] \"]\")\n             [(Tactic.location \"at\" (Tactic.locationHyp [`H] [(patternIgnore (token.Â«âŠ¢Â» \"âŠ¢\"))]))])\n            []\n            (Std.Tactic.tacticRwa__\n             \"rwa\"\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule\n                [(patternIgnore (token.Â«â† Â» \"â†\"))]\n                (Term.app\n                 (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                 [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n              \"]\")\n             [])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"â†’\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.intro \"intro\" [`H `ğ’° `hğ’° `i]) [] (Tactic.skip \"skip\") [] (Tactic.apply \"apply\" `H)])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"â†’\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.exact\n             \"exact\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`H]\n               []\n               \"=>\"\n               (Term.anonymousCtor\n                \"âŸ¨\"\n                [`Y.affine_cover \",\" `infer_instance \",\" (Term.app `H [`Y.affine_cover])]\n                \"âŸ©\"))))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"â†’\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"âŸ¨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ğ’°)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hğ’°)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"âŸ©\"))]\n             [])\n            []\n            (Tactic.exact \"exact\" (Term.app `target_affine_locally_of_open_cover [`hP `f `ğ’° `H]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"â†’\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"âŸ¨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `Î¹)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU')])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `H)])\n                  [])]\n                \"âŸ©\"))]\n             [])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor\n              \"âŸ¨\"\n              [(Term.app `Y.open_cover_of_supr_eq_top [`U `hU]) \",\" `hU' \",\" (Term.hole \"_\")]\n              \"âŸ©\"))\n            []\n            (Tactic.intro \"intro\" [`i])\n            []\n            (Tactic.specialize \"specialize\" (Term.app `H [`i]))\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» \"â†\"))] `P.to_property_apply)\n               \",\"\n               (Tactic.rwRule\n                [(patternIgnore (token.Â«â† Â» \"â†\"))]\n                (Term.app\n                 (Term.proj (Term.proj `hP \".\" (fieldIdx \"1\")) \".\" `arrow_mk_iso_iff)\n                 [(Term.app `morphism_restrict_opens_range [`f (Term.hole \"_\")])]))]\n              \"]\")\n             [])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.Â«â† Â» \"â†\"))] `P.to_property_apply)] \"]\")\n             [(Tactic.location \"at\" (Tactic.locationHyp [`H] []))])\n            []\n            (convert \"convert\" [] `H [])\n            []\n            (Tactic.allGoals\n             \"all_goals\"\n             (Tactic.tacticSeq\n              (Tactic.tacticSeq1Indented\n               [(Std.Tactic.Ext.tacticExt1___ \"ext1\" []) \";\" (Tactic.exact \"exact\" `Subtype.range_coe)])))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"5\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n           [(Tactic.intro \"intro\" [`H])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor\n              \"âŸ¨\"\n              [`Y.carrier\n               \",\"\n               (Term.fun\n                \"fun\"\n                (Term.basicFun [`x] [] \"=>\" (Term.proj (Term.app `Y.affine_cover.map [`x]) \".\" `opens_range)))\n               \",\"\n               (Term.hole \"_\")\n               \",\"\n               (Term.fun\n                \"fun\"\n                (Term.basicFun [`i] [] \"=>\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])))\n               \",\"\n               (Term.hole \"_\")]\n              \"âŸ©\"))\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n             [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eq_top_iff)] \"]\") [])\n              []\n              (Tactic.intro \"intro\" [`x (Term.hole \"_\")])\n              []\n              (Tactic.tacticErw__ \"erw\" (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `opens.mem_supr)] \"]\") [])\n              []\n              (Tactic.exact \"exact\" (Term.anonymousCtor \"âŸ¨\" [`x \",\" (Term.app `Y.affine_cover.covers [`x])] \"âŸ©\"))])\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n             [(Tactic.intro \"intro\" [`i])\n              []\n              (Tactic.exact\n               \"exact\"\n               (Term.app\n                `H\n                [(Term.anonymousCtor\n                  \"âŸ¨\"\n                  [(Term.hole \"_\") \",\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])]\n                  \"âŸ©\")]))])])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n       [(Tactic.intro \"intro\" [`H])\n        []\n        (Tactic.refine'\n         \"refine'\"\n         (Term.anonymousCtor\n          \"âŸ¨\"\n          [`Y.carrier\n           \",\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun [`x] [] \"=>\" (Term.proj (Term.app `Y.affine_cover.map [`x]) \".\" `opens_range)))\n           \",\"\n           (Term.hole \"_\")\n           \",\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun [`i] [] \"=>\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])))\n           \",\"\n           (Term.hole \"_\")]\n          \"âŸ©\"))\n        []\n        (tactic__\n         (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n         [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eq_top_iff)] \"]\") [])\n          []\n          (Tactic.intro \"intro\" [`x (Term.hole \"_\")])\n          []\n          (Tactic.tacticErw__ \"erw\" (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `opens.mem_supr)] \"]\") [])\n          []\n          (Tactic.exact \"exact\" (Term.anonymousCtor \"âŸ¨\" [`x \",\" (Term.app `Y.affine_cover.covers [`x])] \"âŸ©\"))])\n        []\n        (tactic__\n         (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n         [(Tactic.intro \"intro\" [`i])\n          []\n          (Tactic.exact\n           \"exact\"\n           (Term.app\n            `H\n            [(Term.anonymousCtor\n              \"âŸ¨\"\n              [(Term.hole \"_\") \",\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])]\n              \"âŸ©\")]))])])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n       [(Tactic.intro \"intro\" [`i])\n        []\n        (Tactic.exact\n         \"exact\"\n         (Term.app\n          `H\n          [(Term.anonymousCtor\n            \"âŸ¨\"\n            [(Term.hole \"_\") \",\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])]\n            \"âŸ©\")]))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact\n       \"exact\"\n       (Term.app\n        `H\n        [(Term.anonymousCtor\n          \"âŸ¨\"\n          [(Term.hole \"_\") \",\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])]\n          \"âŸ©\")]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       `H\n       [(Term.anonymousCtor\n         \"âŸ¨\"\n         [(Term.hole \"_\") \",\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])]\n         \"âŸ©\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor\n       \"âŸ¨\"\n       [(Term.hole \"_\") \",\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])]\n       \"âŸ©\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `range_is_affine_open_of_open_immersion\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`i])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `i\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.Â«Â· Â» \"Â·\")))\n       [(Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eq_top_iff)] \"]\") [])\n        []\n        (Tactic.intro \"intro\" [`x (Term.hole \"_\")])\n        []\n        (Tactic.tacticErw__ \"erw\" (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `opens.mem_supr)] \"]\") [])\n        []\n        (Tactic.exact \"exact\" (Term.anonymousCtor \"âŸ¨\" [`x \",\" (Term.app `Y.affine_cover.covers [`x])] \"âŸ©\"))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.anonymousCtor \"âŸ¨\" [`x \",\" (Term.app `Y.affine_cover.covers [`x])] \"âŸ©\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor \"âŸ¨\" [`x \",\" (Term.app `Y.affine_cover.covers [`x])] \"âŸ©\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `Y.affine_cover.covers [`x])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `Y.affine_cover.covers\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tacticErw__ \"erw\" (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `opens.mem_supr)] \"]\") [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `opens.mem_supr\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`x (Term.hole \"_\")])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1023, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `eq_top_iff)] \"]\") [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `eq_top_iff\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.refine'\n       \"refine'\"\n       (Term.anonymousCtor\n        \"âŸ¨\"\n        [`Y.carrier\n         \",\"\n         (Term.fun \"fun\" (Term.basicFun [`x] [] \"=>\" (Term.proj (Term.app `Y.affine_cover.map [`x]) \".\" `opens_range)))\n         \",\"\n         (Term.hole \"_\")\n         \",\"\n         (Term.fun\n          \"fun\"\n          (Term.basicFun [`i] [] \"=>\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])))\n         \",\"\n         (Term.hole \"_\")]\n        \"âŸ©\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor\n       \"âŸ¨\"\n       [`Y.carrier\n        \",\"\n        (Term.fun \"fun\" (Term.basicFun [`x] [] \"=>\" (Term.proj (Term.app `Y.affine_cover.map [`x]) \".\" `opens_range)))\n        \",\"\n        (Term.hole \"_\")\n        \",\"\n        (Term.fun\n         \"fun\"\n         (Term.basicFun [`i] [] \"=>\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])))\n        \",\"\n        (Term.hole \"_\")]\n       \"âŸ©\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun \"fun\" (Term.basicFun [`i] [] \"=>\" (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `range_is_affine_open_of_open_immersion [(Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `range_is_affine_open_of_open_immersion\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `i\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun \"fun\" (Term.basicFun [`x] [] \"=>\" (Term.proj (Term.app `Y.affine_cover.map [`x]) \".\" `opens_range)))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.proj (Term.app `Y.affine_cover.map [`x]) \".\" `opens_range)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app `Y.affine_cover.map [`x])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `Y.affine_cover.map\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `Y.affine_cover.map [`x]) \")\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `Y.carrier\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`H])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"â†’\" (num \"5\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â†’ Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â†” Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«â†’Â»', expected 'token.Â« â† Â»'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  affine_target_morphism_property.is_local.affine_open_cover_tfae\n  { P : affine_target_morphism_property } ( hP : P . is_local ) { X Y : Scheme .{ u } } ( f : Â«expr âŸ¶ Â» X Y )\n    :\n      TFAE\n        [\n          target_affine_locally P f\n            ,\n            âˆƒ\n              ( ğ’° : Scheme.open_cover .{ u } Y ) ( _ : âˆ€ i , is_affine ğ’° . obj i )\n              ,\n              âˆ€ i : ğ’° . J , P ( pullback.snd : Â«expr âŸ¶ Â» ğ’°.pullback_cover f . obj i ğ’°.obj i )\n            ,\n            âˆ€\n              ( ğ’° : Scheme.open_cover .{ u } Y ) [ âˆ€ i , is_affine ğ’° . obj i ] ( i : ğ’° . J )\n              ,\n              P ( pullback.snd : Â«expr âŸ¶ Â» ğ’°.pullback_cover f . obj i ğ’°.obj i )\n            ,\n            âˆ€\n              { U : Scheme } ( g : Â«expr âŸ¶ Â» U Y ) [ is_affine U ] [ is_open_immersion g ]\n              ,\n              P ( pullback.snd : Â«expr âŸ¶ Â» pullback f g U )\n            ,\n            âˆƒ\n              ( Î¹ : Type u ) ( U : Î¹ â†’ opens Y . carrier ) ( hU : supáµ¢ U = Â«exprâŠ¤Â» ) ( hU' : âˆ€ i , is_affine_open U i )\n              ,\n              âˆ€ i , @ P Â«expr âˆ£_ Â» f U i hU' i\n          ]\n  :=\n    by\n      tfae_have 1 â†’ 4\n        Â·\n          intro H U g hâ‚ hâ‚‚\n            skip\n            replace H := H âŸ¨ âŸ¨ _ , hâ‚‚.base_open.open_range âŸ© , range_is_affine_open_of_open_immersion g âŸ©\n            rw [ â† P.to_property_apply ] at H âŠ¢\n            rwa [ â† hP . 1 . arrow_mk_iso_iff morphism_restrict_opens_range f _ ]\n        tfae_have 4 â†’ 3\n        Â· intro H ğ’° hğ’° i skip apply H\n        tfae_have 3 â†’ 2\n        Â· exact fun H => âŸ¨ Y.affine_cover , infer_instance , H Y.affine_cover âŸ©\n        tfae_have 2 â†’ 1\n        Â· rintro âŸ¨ ğ’° , hğ’° , H âŸ© exact target_affine_locally_of_open_cover hP f ğ’° H\n        tfae_have 5 â†’ 2\n        Â·\n          rintro âŸ¨ Î¹ , U , hU , hU' , H âŸ©\n            refine' âŸ¨ Y.open_cover_of_supr_eq_top U hU , hU' , _ âŸ©\n            intro i\n            specialize H i\n            rw [ â† P.to_property_apply , â† hP . 1 . arrow_mk_iso_iff morphism_restrict_opens_range f _ ]\n            rw [ â† P.to_property_apply ] at H\n            convert H\n            all_goals ext1 ; exact Subtype.range_coe\n        tfae_have 1 â†’ 5\n        Â·\n          intro H\n            refine'\n              âŸ¨\n                Y.carrier\n                  ,\n                  fun x => Y.affine_cover.map x . opens_range\n                  ,\n                  _\n                  ,\n                  fun i => range_is_affine_open_of_open_immersion _\n                  ,\n                  _\n                âŸ©\n            Â· rw [ eq_top_iff ] intro x _ erw [ opens.mem_supr ] exact âŸ¨ x , Y.affine_cover.covers x âŸ©\n            Â· intro i exact H âŸ¨ _ , range_is_affine_open_of_open_immersion _ âŸ©\n        tfae_finish\n#align\n  affine_target_morphism_property.is_local.affine_open_cover_tfae affine_target_morphism_property.is_local.affine_open_cover_tfae\n\n",
 "affine_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem affine_target_morphism_property.is_local.affine_open_cover_iff {P : affine_target_morphism_property}\n    (hP : P.is_local) {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) (ğ’° : Scheme.open_cover.{u} Y)\n    [hğ’° : âˆ€ i, is_affine (ğ’°.obj i)] :\n    target_affine_locally P f â†” âˆ€ i, @P (pullback.snd : Â«expr âŸ¶ Â» (pullback f (ğ’°.map i)) _) (hğ’° i) :=\n  âŸ¨fun H =>\n    let h := ((hP.affine_open_cover_tfae f).out 0 2).mp H\n    h ğ’°,\n    fun H =>\n    let h := ((hP.affine_open_cover_tfae f).out 1 0).mp\n    h âŸ¨ğ’°, infer_instance, HâŸ©âŸ©\n#align\n  affine_target_morphism_property.is_local.affine_open_cover_iff affine_target_morphism_property.is_local.affine_open_cover_iff\n\n",
 "affine_cancel_right_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem affine_cancel_right_is_iso {P : affine_target_morphism_property} (hP : P.to_property.respects_iso)\n    {X Y Z : Scheme} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) [IsIso g] [is_affine Z] [is_affine Y] :\n    P (Â«expr â‰« Â» f g) â†” P f := by rw [â† P.to_property_apply, â† P.to_property_apply, hP.cancel_right_is_iso]\n#align affine_cancel_right_is_iso affine_cancel_right_is_iso\n\n",
 "affine_cancel_left_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem affine_cancel_left_is_iso {P : affine_target_morphism_property} (hP : P.to_property.respects_iso)\n    {X Y Z : Scheme} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) [IsIso f] [is_affine Z] : P (Â«expr â‰« Â» f g) â†” P g := by\n  rw [â† P.to_property_apply, â† P.to_property_apply, hP.cancel_left_is_iso]\n#align affine_cancel_left_is_iso affine_cancel_left_is_iso\n\n"}