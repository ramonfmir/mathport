{"quasi_compact_stable_under_composition":
 "theorem quasi_compact_stable_under_composition : morphism_property.stable_under_composition @quasi_compact :=\n  fun _ _ _ _ _ _ _ => infer_instance\n#align quasi_compact_stable_under_composition quasi_compact_stable_under_composition\n\n",
 "quasi_compact_stable_under_base_change":
 "theorem quasi_compact_stable_under_base_change : morphism_property.stable_under_base_change @quasi_compact :=\n  quasi_compact_eq_affine_property.symm ‚ñ∏\n    quasi_compact.affine_property_is_local.stable_under_base_change\n      quasi_compact.affine_property_stable_under_base_change\n#align quasi_compact_stable_under_base_change quasi_compact_stable_under_base_change\n\n",
 "quasi_compact_respects_iso":
 "theorem quasi_compact_respects_iso : morphism_property.respects_iso @quasi_compact :=\n  quasi_compact_eq_affine_property.symm ‚ñ∏ target_affine_locally_respects_iso quasi_compact.affine_property_is_local.1\n#align quasi_compact_respects_iso quasi_compact_respects_iso\n\n",
 "quasi_compact_over_affine_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\ntheorem quasi_compact_over_affine_iff {X Y : Scheme} (f : ¬´expr ‚ü∂ ¬ª X Y) [is_affine Y] :\n    quasi_compact f ‚Üî compact_space X.carrier :=\n  quasi_compact_eq_affine_property.symm ‚ñ∏ quasi_compact.affine_property_is_local.affine_target_iff f\n#align quasi_compact_over_affine_iff quasi_compact_over_affine_iff\n\n",
 "quasi_compact_iff_spectral":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem quasi_compact_iff_spectral : quasi_compact f ‚Üî is_spectral_map f.1.base :=\n  ‚ü®fun ‚ü®h‚ü© => ‚ü®by continuity, h‚ü©, fun h => ‚ü®h.2‚ü©‚ü©\n#align quasi_compact_iff_spectral quasi_compact_iff_spectral\n\n",
 "quasi_compact_iff_forall_affine":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\ntheorem quasi_compact_iff_forall_affine :\n    quasi_compact f ‚Üî ‚àÄ U : opens Y.carrier, is_affine_open U ‚Üí is_compact (¬´expr ‚Åª¬π' ¬ª f.1.base (U : set Y.carrier)) :=\n  by\n  rw [quasi_compact_iff]\n  refine' ‚ü®fun H U hU => H U U.prop hU.is_compact, _‚ü©\n  intro H U hU hU'\n  obtain ‚ü®S, hS, rfl‚ü© := (is_compact_open_iff_eq_finset_affine_union U).mp ‚ü®hU', hU‚ü©\n  simp only [Set.preimage_union·µ¢, subtype.val_eq_coe]\n  exact hS.is_compact_bUnion fun i _ => H i i.prop\n#align quasi_compact_iff_forall_affine quasi_compact_iff_forall_affine\n\n",
 "quasi_compact_iff_affine_property":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\ntheorem quasi_compact_iff_affine_property : quasi_compact f ‚Üî target_affine_locally quasi_compact.affine_property f :=\n  by\n  rw [quasi_compact_iff_forall_affine]\n  trans ‚àÄ U : Y.affine_opens, is_compact (¬´expr ‚Åª¬π' ¬ª f.1.base (U : set Y.carrier))\n  ¬∑ exact ‚ü®fun h U => h U U.prop, fun h U hU => h ‚ü®U, hU‚ü©‚ü©\n  apply forall_congr'\n  exact fun _ => is_compact_iff_compact_space\n#align quasi_compact_iff_affine_property quasi_compact_iff_affine_property\n\n",
 "quasi_compact_eq_affine_property":
 "theorem quasi_compact_eq_affine_property : @quasi_compact = target_affine_locally quasi_compact.affine_property :=\n  by\n  ext\n  exact quasi_compact_iff_affine_property _\n#align quasi_compact_eq_affine_property quasi_compact_eq_affine_property\n\n",
 "open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚à£_ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚à£_ ¬ª -/\ntheorem quasi_compact.open_cover_tfae {X Y : Scheme.{u}} (f : ¬´expr ‚ü∂ ¬ª X Y) :\n    TFAE\n      [quasi_compact f,\n        ‚àÉ ùí∞ : Scheme.open_cover.{u} Y,\n          ‚àÄ i : ùí∞.J, quasi_compact (pullback.snd : ¬´expr ‚ü∂ ¬ª ((ùí∞.pullback_cover f).obj i) (ùí∞.obj i)),\n        ‚àÄ (ùí∞ : Scheme.open_cover.{u} Y) (i : ùí∞.J),\n          quasi_compact (pullback.snd : ¬´expr ‚ü∂ ¬ª ((ùí∞.pullback_cover f).obj i) (ùí∞.obj i)),\n        ‚àÄ U : opens Y.carrier, quasi_compact (¬´expr ‚à£_ ¬ª f U),\n        ‚àÄ {U : Scheme} (g : ¬´expr ‚ü∂ ¬ª U Y) [is_open_immersion g],\n          quasi_compact (pullback.snd : ¬´expr ‚ü∂ ¬ª (pullback f g) _),\n        ‚àÉ (Œπ : Type u)(U : Œπ ‚Üí opens Y.carrier)(hU : sup·µ¢ U = ¬´expr‚ä§¬ª), ‚àÄ i, quasi_compact (¬´expr ‚à£_ ¬ª f (U i))] :=\n  quasi_compact_eq_affine_property.symm ‚ñ∏\n    quasi_compact.affine_property_is_local.target_affine_locally_is_local.open_cover_tfae f\n#align quasi_compact.open_cover_tfae quasi_compact.open_cover_tfae\n\n",
 "open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\ntheorem quasi_compact.open_cover_iff {X Y : Scheme.{u}} (ùí∞ : Scheme.open_cover.{u} Y) (f : ¬´expr ‚ü∂ ¬ª X Y) :\n    quasi_compact f ‚Üî ‚àÄ i, quasi_compact (pullback.snd : ¬´expr ‚ü∂ ¬ª (pullback f (ùí∞.map i)) _) :=\n  quasi_compact_eq_affine_property.symm ‚ñ∏\n    quasi_compact.affine_property_is_local.target_affine_locally_is_local.open_cover_iff f ùí∞\n#align quasi_compact.open_cover_iff quasi_compact.open_cover_iff\n\n",
 "is_local_at_target":
 "theorem quasi_compact.is_local_at_target : property_is_local_at_target @quasi_compact :=\n  quasi_compact_eq_affine_property.symm ‚ñ∏ quasi_compact.affine_property_is_local.target_affine_locally_is_local\n#align quasi_compact.is_local_at_target quasi_compact.is_local_at_target\n\n",
 "is_compact_open_iff_eq_finset_affine_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\ntheorem is_compact_open_iff_eq_finset_affine_union {X : Scheme} (U : set X.carrier) :\n    is_compact U ‚àß is_open U ‚Üî\n      ‚àÉ s : set X.affine_opens,\n        s.finite ‚àß\n          U = ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" i :=\n  by\n  apply opens.is_compact_open_iff_eq_finite_Union_of_is_basis (coe : X.affine_opens ‚Üí opens X.carrier)\n  ¬∑ rw [Subtype.range_coe]\n    exact is_basis_affine_open X\n  ¬∑ intro i\n    exact i.2.is_compact\n#align is_compact_open_iff_eq_finset_affine_union is_compact_open_iff_eq_finset_affine_union\n\n",
 "is_compact_open_iff_eq_basic_open_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\ntheorem is_compact_open_iff_eq_basic_open_union {X : Scheme} [is_affine X] (U : set X.carrier) :\n    is_compact U ‚àß is_open U ‚Üî\n      ‚àÉ s : set (X.presheaf.obj (op (¬´expr‚ä§¬ª))),\n        s.finite ‚àß\n          U =\n            ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\"\n              (X.basic_open i) :=\n  by\n  apply opens.is_compact_open_iff_eq_finite_Union_of_is_basis\n  ¬∑ exact is_basis_basic_open X\n  ¬∑ intro i\n    exact ((top_is_affine_open _).basic_open_is_affine _).is_compact\n#align is_compact_open_iff_eq_basic_open_union is_compact_open_iff_eq_basic_open_union\n\n",
 "is_compact_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\ntheorem is_compact_basic_open (X : Scheme) {U : opens X.carrier} (hU : is_compact (U : set X.carrier))\n    (f : X.presheaf.obj (op U)) : is_compact (X.basic_open f : set X.carrier) := by\n  classical\n    refine' ((is_compact_open_iff_eq_finset_affine_union _).mpr _).1\n    obtain ‚ü®s, hs, e‚ü© := (is_compact_open_iff_eq_finset_affine_union _).mp ‚ü®hU, U.prop‚ü©\n    let g : s ‚Üí X.affine_opens := by\n      intro V\n      use ¬´expr ‚äì ¬ª V.1 (X.basic_open f)\n      have : ¬´expr ‚ü∂ ¬ª V.1.1 U := by\n        apply hom_of_le\n        change _ ‚äÜ (U : set X.carrier)\n        rw [e]\n        convert @Set.subset_union·µ¢‚ÇÇ _ _ _ (fun (U : X.affine_opens) (h : U ‚àà s) => ‚ÜëU) V V.prop using 1\n        rfl\n      erw [‚Üê X.to_LocallyRingedSpace.to_RingedSpace.basic_open_res this.op]\n      exact is_affine_open.basic_open_is_affine V.1.prop _\n    haveI : Finite s := hs.to_subtype\n    refine' ‚ü®Set.range g, set.finite_range g, _‚ü©\n    refine' (set.inter_eq_right_iff_subset.mpr (RingedSpace.basic_open_le _ _)).symm.trans _\n    rw [e, Set.union·µ¢‚ÇÇ_inter]\n    apply le_antisymm <;> apply Set.union·µ¢‚ÇÇ_subset\n    ¬∑ intro i hi\n      refine' Set.Subset.trans _ (Set.subset_union·µ¢‚ÇÇ _ (Set.mem_range_self ‚ü®i, hi‚ü©))\n      exact Set.Subset.rfl\n    ¬∑ rintro ‚ü®i, hi‚ü© ‚ü®‚ü®j, hj‚ü©, hj'‚ü©\n      rw [‚Üê hj']\n      refine' Set.Subset.trans _ (Set.subset_union·µ¢‚ÇÇ j hj)\n      exact Set.Subset.rfl\n#align is_compact_basic_open is_compact_basic_open\n\n",
 "exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr |_ ¬ª -/\n/-- If `x : Œì(X, U)` is zero on `D(f)` for some `f : Œì(X, U)`, and `U` is quasi-compact, then\n`f ^ n * x = 0` for some `n`. -/\ntheorem exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_compact (X : Scheme) {U : opens X.carrier}\n    (hU : is_compact U.1) (x f : X.presheaf.obj (op U)) (H : ¬´expr |_ ¬ª x (X.basic_open f) = 0) :\n    ‚àÉ n : ‚Ñï, f ^ n * x = 0 :=\n  by\n  obtain ‚ü®s, hs, e‚ü© := (is_compact_open_iff_eq_finset_affine_union U.1).mp ‚ü®hU, U.2‚ü©\n  replace e : U = sup·µ¢ fun i : s => (i : opens X.carrier)\n  ¬∑ ext1\n    simpa using e\n  have h‚ÇÅ : ‚àÄ i : s, i.1.1 ‚â§ U := by\n    intro i\n    change (i : opens X.carrier) ‚â§ U\n    rw [e]\n    exact le_sup·µ¢ _ _\n  have H' := fun i : s =>\n    exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_affine_open X i.1.2 (X.presheaf.map (hom_of_le (h‚ÇÅ i)).op x)\n      (X.presheaf.map (hom_of_le (h‚ÇÅ i)).op f) _\n  swap\n  ¬∑ delta Top.presheaf.restrict_open Top.presheaf.restrict at H‚ä¢\n    convert congr_arg (X.presheaf.map (hom_of_le _).op) H\n    ¬∑ simp only [‚Üê comp_apply, ‚Üê functor.map_comp]\n      congr\n    ¬∑ rw [map_zero]\n    ¬∑ rw [X.basic_open_res]\n      exact Set.inter_subset_right _ _\n  choose n hn using H'\n  haveI := hs.to_subtype\n  cases nonempty_fintype s\n  use finset.univ.sup n\n  suffices ‚àÄ i : s, X.presheaf.map (hom_of_le (h‚ÇÅ i)).op (f ^ finset.univ.sup n * x) = 0\n    by\n    subst e\n    apply X.sheaf.eq_of_locally_eq fun i : s => (i : opens X.carrier)\n    intro i\n    rw [map_zero]\n    apply this\n  intro i\n  replace hn := congr_arg (fun x => X.presheaf.map (hom_of_le (h‚ÇÅ i)).op (f ^ (finset.univ.sup n - n i)) * x) (hn i)\n  dsimp at hn\n  simp only [‚Üê map_mul, ‚Üê map_pow] at hn\n  rwa [mul_zero, ‚Üê mul_assoc, ‚Üê pow_add, tsub_add_cancel_of_le] at hn\n  apply finset.le_sup (finset.mem_univ i)\n#align\n  exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_compact exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_compact\n\n",
 "exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_affine_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr |_ ¬ª -/\ntheorem exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_affine_open (X : Scheme) {U : opens X.carrier}\n    (hU : is_affine_open U) (x f : X.presheaf.obj (op U)) (H : ¬´expr |_ ¬ª x (X.basic_open f) = 0) :\n    ‚àÉ n : ‚Ñï, f ^ n * x = 0 :=\n  by\n  rw [‚Üê map_zero (X.presheaf.map (hom_of_le <| X.basic_open_le f : ¬´expr ‚ü∂ ¬ª (X.basic_open f) U).op)] at H\n  have := (is_localization_basic_open hU f).3\n  obtain ‚ü®‚ü®_, n, rfl‚ü©, e‚ü© := this.mp H\n  exact ‚ü®n, by simpa [mul_comm x] using e‚ü©\n#align\n  exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_affine_open exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_affine_open\n\n",
 "compact_space_iff_quasi_compact":
 "theorem compact_space_iff_quasi_compact (X : Scheme) : compact_space X.carrier ‚Üî quasi_compact (terminal.from X) :=\n  (quasi_compact_over_affine_iff _).symm\n#align compact_space_iff_quasi_compact compact_space_iff_quasi_compact\n\n",
 "compact_open_induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ü , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä•¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äî ¬ª -/\n@[elab_as_elim]\ntheorem compact_open_induction_on {P : opens X.carrier ‚Üí Prop} (S : opens X.carrier) (hS : is_compact S.1)\n    (h‚ÇÅ : P (¬´expr‚ä•¬ª))\n    (h‚ÇÇ : ‚àÄ (S : opens X.carrier) (hS : is_compact S.1) (U : X.affine_opens), P S ‚Üí P (¬´expr ‚äî ¬ª S U)) : P S := by\n  classical\n    obtain ‚ü®s, hs, hs'‚ü© := (is_compact_open_iff_eq_finset_affine_union S.1).mp ‚ü®hS, S.2‚ü©\n    replace hs' : S = sup·µ¢ fun i : s => (i : opens X.carrier) :=\n      by\n      ext1\n      simpa using hs'\n    subst hs'\n    apply hs.induction_on\n    ¬∑ convert h‚ÇÅ\n      rw [sup·µ¢_eq_bot]\n      rintro ‚ü®_, h‚ü©\n      exact h.elim\n    ¬∑ intro x s h‚ÇÉ hs h‚ÇÑ\n      have :\n        is_compact\n          (¬´expr‚®Ü , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª\"\n              (i : opens X.carrier)).1 :=\n        by\n        refine' ((is_compact_open_iff_eq_finset_affine_union _).mpr _).1\n        exact ‚ü®s, hs, by simp‚ü©\n      convert h‚ÇÇ _ this x h‚ÇÑ\n      simp only [coe_coe]\n      rw [sup·µ¢_subtype, sup_comm]\n      conv_rhs => rw [sup·µ¢_subtype]\n      exact sup·µ¢_insert\n#align compact_open_induction_on compact_open_induction_on\n\n",
 "affine_property_to_property":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n@[simp]\ntheorem quasi_compact.affine_property_to_property {X Y : Scheme} (f : ¬´expr ‚ü∂ ¬ª X Y) :\n    (quasi_compact.affine_property : _).to_property f ‚Üî is_affine Y ‚àß compact_space X.carrier :=\n  by\n  delta affine_target_morphism_property.to_property quasi_compact.affine_property\n  simp\n#align quasi_compact.affine_property_to_property quasi_compact.affine_property_to_property\n\n",
 "affine_property_stable_under_base_change":
 "theorem quasi_compact.affine_property_stable_under_base_change :\n    quasi_compact.affine_property.stable_under_base_change :=\n  by\n  intro X Y S _ _ f g h\n  rw [quasi_compact.affine_property] at h‚ä¢\n  skip\n  let ùí∞ := Scheme.pullback.open_cover_of_right Y.affine_cover.finite_subcover f g\n  have : Finite ùí∞.J := by\n    dsimp [ùí∞]\n    infer_instance\n  have : ‚àÄ i, compact_space (ùí∞.obj i).carrier := by\n    intro i\n    dsimp\n    infer_instance\n  exact ùí∞.compact_space\n#align quasi_compact.affine_property_stable_under_base_change quasi_compact.affine_property_stable_under_base_change\n\n",
 "affine_property_is_local":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\ntheorem quasi_compact.affine_property_is_local : (quasi_compact.affine_property : _).is_local :=\n  by\n  constructor\n  ¬∑ apply affine_target_morphism_property.respects_iso_mk <;> rintro X Y Z _ _ _ H\n    exacts[@homeomorph.compact_space _ _ H (Top.homeo_of_iso (as_iso e.inv.1.base)), H]\n  ¬∑ introv H\n    delta quasi_compact.affine_property at H‚ä¢\n    change compact_space ((opens.map f.val.base).obj (Y.basic_open r))\n    rw [Scheme.preimage_basic_open f r]\n    erw [‚Üê is_compact_iff_compact_space]\n    rw [‚Üê is_compact_univ_iff] at H\n    exact is_compact_basic_open X H _\n  ¬∑ rintro X Y H f S hS hS'\n    skip\n    rw [‚Üê is_affine_open.basic_open_union_eq_self_iff] at hS\n    delta quasi_compact.affine_property\n    rw [‚Üê is_compact_univ_iff]\n    change is_compact ((opens.map f.val.base).obj (¬´expr‚ä§¬ª)).1\n    rw [‚Üê hS]\n    dsimp [opens.map]\n    simp only [opens.coe_supr, Set.preimage_union·µ¢, subtype.val_eq_coe]\n    exacts[is_compact_Union fun i => is_compact_iff_compact_space.mpr (hS' i), top_is_affine_open _]\n#align quasi_compact.affine_property_is_local quasi_compact.affine_property_is_local\n\n",
 "affine_open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\ntheorem quasi_compact.affine_open_cover_tfae {X Y : Scheme.{u}} (f : ¬´expr ‚ü∂ ¬ª X Y) :\n    TFAE\n      [quasi_compact f,\n        ‚àÉ (ùí∞ : Scheme.open_cover.{u} Y)(_ : ‚àÄ i, is_affine (ùí∞.obj i)),\n          ‚àÄ i : ùí∞.J, compact_space (pullback f (ùí∞.map i)).carrier,\n        ‚àÄ (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)] (i : ùí∞.J),\n          compact_space (pullback f (ùí∞.map i)).carrier,\n        ‚àÄ {U : Scheme} (g : ¬´expr ‚ü∂ ¬ª U Y) [is_affine U] [is_open_immersion g], compact_space (pullback f g).carrier,\n        ‚àÉ (Œπ : Type u)(U : Œπ ‚Üí opens Y.carrier)(hU : sup·µ¢ U = ¬´expr‚ä§¬ª)(hU' : ‚àÄ i, is_affine_open (U i)),\n          ‚àÄ i, compact_space (¬´expr ‚Åª¬π' ¬ª f.1.base (U i).1)] :=\n  quasi_compact_eq_affine_property.symm ‚ñ∏ quasi_compact.affine_property_is_local.affine_open_cover_tfae f\n#align quasi_compact.affine_open_cover_tfae quasi_compact.affine_open_cover_tfae\n\n",
 "affine_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\ntheorem quasi_compact.affine_open_cover_iff {X Y : Scheme.{u}} (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)]\n    (f : ¬´expr ‚ü∂ ¬ª X Y) : quasi_compact f ‚Üî ‚àÄ i, compact_space (pullback f (ùí∞.map i)).carrier :=\n  quasi_compact_eq_affine_property.symm ‚ñ∏ quasi_compact.affine_property_is_local.affine_open_cover_iff f ùí∞\n#align quasi_compact.affine_open_cover_iff quasi_compact.affine_open_cover_iff\n\n"}