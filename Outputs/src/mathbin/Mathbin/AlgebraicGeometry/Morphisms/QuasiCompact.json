{"quasi_compact_stable_under_composition":
 "theorem quasi_compact_stable_under_composition : morphism_property.stable_under_composition @quasi_compact :=\n  fun _ _ _ _ _ _ _ => infer_instance\n#align quasi_compact_stable_under_composition quasi_compact_stable_under_composition\n\n",
 "quasi_compact_stable_under_base_change":
 "theorem quasi_compact_stable_under_base_change : morphism_property.stable_under_base_change @quasi_compact :=\n  quasi_compact_eq_affine_property.symm â–¸\n    quasi_compact.affine_property_is_local.stable_under_base_change\n      quasi_compact.affine_property_stable_under_base_change\n#align quasi_compact_stable_under_base_change quasi_compact_stable_under_base_change\n\n",
 "quasi_compact_respects_iso":
 "theorem quasi_compact_respects_iso : morphism_property.respects_iso @quasi_compact :=\n  quasi_compact_eq_affine_property.symm â–¸ target_affine_locally_respects_iso quasi_compact.affine_property_is_local.1\n#align quasi_compact_respects_iso quasi_compact_respects_iso\n\n",
 "quasi_compact_over_affine_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem quasi_compact_over_affine_iff {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) [is_affine Y] :\n    quasi_compact f â†” compact_space X.carrier :=\n  quasi_compact_eq_affine_property.symm â–¸ quasi_compact.affine_property_is_local.affine_target_iff f\n#align quasi_compact_over_affine_iff quasi_compact_over_affine_iff\n\n",
 "quasi_compact_iff_spectral":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem quasi_compact_iff_spectral : quasi_compact f â†” is_spectral_map f.1.base :=\n  âŸ¨fun âŸ¨hâŸ© => âŸ¨by continuity, hâŸ©, fun h => âŸ¨h.2âŸ©âŸ©\n#align quasi_compact_iff_spectral quasi_compact_iff_spectral\n\n",
 "quasi_compact_iff_forall_affine":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem quasi_compact_iff_forall_affine :\n    quasi_compact f â†” âˆ€ U : opens Y.carrier, is_affine_open U â†’ is_compact (Â«expr â»Â¹' Â» f.1.base (U : set Y.carrier)) :=\n  by\n  rw [quasi_compact_iff]\n  refine' âŸ¨fun H U hU => H U U.prop hU.is_compact, _âŸ©\n  intro H U hU hU'\n  obtain âŸ¨S, hS, rflâŸ© := (is_compact_open_iff_eq_finset_affine_union U).mp âŸ¨hU', hUâŸ©\n  simp only [Set.preimage_unionáµ¢, subtype.val_eq_coe]\n  exact hS.is_compact_bUnion fun i _ => H i i.prop\n#align quasi_compact_iff_forall_affine quasi_compact_iff_forall_affine\n\n",
 "quasi_compact_iff_affine_property":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem quasi_compact_iff_affine_property : quasi_compact f â†” target_affine_locally quasi_compact.affine_property f :=\n  by\n  rw [quasi_compact_iff_forall_affine]\n  trans âˆ€ U : Y.affine_opens, is_compact (Â«expr â»Â¹' Â» f.1.base (U : set Y.carrier))\n  Â· exact âŸ¨fun h U => h U U.prop, fun h U hU => h âŸ¨U, hUâŸ©âŸ©\n  apply forall_congr'\n  exact fun _ => is_compact_iff_compact_space\n#align quasi_compact_iff_affine_property quasi_compact_iff_affine_property\n\n",
 "quasi_compact_eq_affine_property":
 "theorem quasi_compact_eq_affine_property : @quasi_compact = target_affine_locally quasi_compact.affine_property :=\n  by\n  ext\n  exact quasi_compact_iff_affine_property _\n#align quasi_compact_eq_affine_property quasi_compact_eq_affine_property\n\n",
 "open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\ntheorem quasi_compact.open_cover_tfae {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) :\n    TFAE\n      [quasi_compact f,\n        âˆƒ ğ’° : Scheme.open_cover.{u} Y,\n          âˆ€ i : ğ’°.J, quasi_compact (pullback.snd : Â«expr âŸ¶ Â» ((ğ’°.pullback_cover f).obj i) (ğ’°.obj i)),\n        âˆ€ (ğ’° : Scheme.open_cover.{u} Y) (i : ğ’°.J),\n          quasi_compact (pullback.snd : Â«expr âŸ¶ Â» ((ğ’°.pullback_cover f).obj i) (ğ’°.obj i)),\n        âˆ€ U : opens Y.carrier, quasi_compact (Â«expr âˆ£_ Â» f U),\n        âˆ€ {U : Scheme} (g : Â«expr âŸ¶ Â» U Y) [is_open_immersion g],\n          quasi_compact (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _),\n        âˆƒ (Î¹ : Type u)(U : Î¹ â†’ opens Y.carrier)(hU : supáµ¢ U = Â«exprâŠ¤Â»), âˆ€ i, quasi_compact (Â«expr âˆ£_ Â» f (U i))] :=\n  quasi_compact_eq_affine_property.symm â–¸\n    quasi_compact.affine_property_is_local.target_affine_locally_is_local.open_cover_tfae f\n#align quasi_compact.open_cover_tfae quasi_compact.open_cover_tfae\n\n",
 "open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem quasi_compact.open_cover_iff {X Y : Scheme.{u}} (ğ’° : Scheme.open_cover.{u} Y) (f : Â«expr âŸ¶ Â» X Y) :\n    quasi_compact f â†” âˆ€ i, quasi_compact (pullback.snd : Â«expr âŸ¶ Â» (pullback f (ğ’°.map i)) _) :=\n  quasi_compact_eq_affine_property.symm â–¸\n    quasi_compact.affine_property_is_local.target_affine_locally_is_local.open_cover_iff f ğ’°\n#align quasi_compact.open_cover_iff quasi_compact.open_cover_iff\n\n",
 "is_local_at_target":
 "theorem quasi_compact.is_local_at_target : property_is_local_at_target @quasi_compact :=\n  quasi_compact_eq_affine_property.symm â–¸ quasi_compact.affine_property_is_local.target_affine_locally_is_local\n#align quasi_compact.is_local_at_target quasi_compact.is_local_at_target\n\n",
 "is_compact_open_iff_eq_finset_affine_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem is_compact_open_iff_eq_finset_affine_union {X : Scheme} (U : set X.carrier) :\n    is_compact U âˆ§ is_open U â†”\n      âˆƒ s : set X.affine_opens,\n        s.finite âˆ§\n          U = Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" i :=\n  by\n  apply opens.is_compact_open_iff_eq_finite_Union_of_is_basis (coe : X.affine_opens â†’ opens X.carrier)\n  Â· rw [Subtype.range_coe]\n    exact is_basis_affine_open X\n  Â· intro i\n    exact i.2.is_compact\n#align is_compact_open_iff_eq_finset_affine_union is_compact_open_iff_eq_finset_affine_union\n\n",
 "is_compact_open_iff_eq_basic_open_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem is_compact_open_iff_eq_basic_open_union {X : Scheme} [is_affine X] (U : set X.carrier) :\n    is_compact U âˆ§ is_open U â†”\n      âˆƒ s : set (X.presheaf.obj (op (Â«exprâŠ¤Â»))),\n        s.finite âˆ§\n          U =\n            Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n              (X.basic_open i) :=\n  by\n  apply opens.is_compact_open_iff_eq_finite_Union_of_is_basis\n  Â· exact is_basis_basic_open X\n  Â· intro i\n    exact ((top_is_affine_open _).basic_open_is_affine _).is_compact\n#align is_compact_open_iff_eq_basic_open_union is_compact_open_iff_eq_basic_open_union\n\n",
 "is_compact_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_compact_basic_open (X : Scheme) {U : opens X.carrier} (hU : is_compact (U : set X.carrier))\n    (f : X.presheaf.obj (op U)) : is_compact (X.basic_open f : set X.carrier) := by\n  classical\n    refine' ((is_compact_open_iff_eq_finset_affine_union _).mpr _).1\n    obtain âŸ¨s, hs, eâŸ© := (is_compact_open_iff_eq_finset_affine_union _).mp âŸ¨hU, U.propâŸ©\n    let g : s â†’ X.affine_opens := by\n      intro V\n      use Â«expr âŠ“ Â» V.1 (X.basic_open f)\n      have : Â«expr âŸ¶ Â» V.1.1 U := by\n        apply hom_of_le\n        change _ âŠ† (U : set X.carrier)\n        rw [e]\n        convert @Set.subset_unionáµ¢â‚‚ _ _ _ (fun (U : X.affine_opens) (h : U âˆˆ s) => â†‘U) V V.prop using 1\n        rfl\n      erw [â† X.to_LocallyRingedSpace.to_RingedSpace.basic_open_res this.op]\n      exact is_affine_open.basic_open_is_affine V.1.prop _\n    haveI : Finite s := hs.to_subtype\n    refine' âŸ¨Set.range g, set.finite_range g, _âŸ©\n    refine' (set.inter_eq_right_iff_subset.mpr (RingedSpace.basic_open_le _ _)).symm.trans _\n    rw [e, Set.unionáµ¢â‚‚_inter]\n    apply le_antisymm <;> apply Set.unionáµ¢â‚‚_subset\n    Â· intro i hi\n      refine' Set.Subset.trans _ (Set.subset_unionáµ¢â‚‚ _ (Set.mem_range_self âŸ¨i, hiâŸ©))\n      exact Set.Subset.rfl\n    Â· rintro âŸ¨i, hiâŸ© âŸ¨âŸ¨j, hjâŸ©, hj'âŸ©\n      rw [â† hj']\n      refine' Set.Subset.trans _ (Set.subset_unionáµ¢â‚‚ j hj)\n      exact Set.Subset.rfl\n#align is_compact_basic_open is_compact_basic_open\n\n",
 "exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr |_ Â» -/\n/-- If `x : Î“(X, U)` is zero on `D(f)` for some `f : Î“(X, U)`, and `U` is quasi-compact, then\n`f ^ n * x = 0` for some `n`. -/\ntheorem exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_compact (X : Scheme) {U : opens X.carrier}\n    (hU : is_compact U.1) (x f : X.presheaf.obj (op U)) (H : Â«expr |_ Â» x (X.basic_open f) = 0) :\n    âˆƒ n : â„•, f ^ n * x = 0 :=\n  by\n  obtain âŸ¨s, hs, eâŸ© := (is_compact_open_iff_eq_finset_affine_union U.1).mp âŸ¨hU, U.2âŸ©\n  replace e : U = supáµ¢ fun i : s => (i : opens X.carrier)\n  Â· ext1\n    simpa using e\n  have hâ‚ : âˆ€ i : s, i.1.1 â‰¤ U := by\n    intro i\n    change (i : opens X.carrier) â‰¤ U\n    rw [e]\n    exact le_supáµ¢ _ _\n  have H' := fun i : s =>\n    exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_affine_open X i.1.2 (X.presheaf.map (hom_of_le (hâ‚ i)).op x)\n      (X.presheaf.map (hom_of_le (hâ‚ i)).op f) _\n  swap\n  Â· delta Top.presheaf.restrict_open Top.presheaf.restrict at HâŠ¢\n    convert congr_arg (X.presheaf.map (hom_of_le _).op) H\n    Â· simp only [â† comp_apply, â† functor.map_comp]\n      congr\n    Â· rw [map_zero]\n    Â· rw [X.basic_open_res]\n      exact Set.inter_subset_right _ _\n  choose n hn using H'\n  haveI := hs.to_subtype\n  cases nonempty_fintype s\n  use finset.univ.sup n\n  suffices âˆ€ i : s, X.presheaf.map (hom_of_le (hâ‚ i)).op (f ^ finset.univ.sup n * x) = 0\n    by\n    subst e\n    apply X.sheaf.eq_of_locally_eq fun i : s => (i : opens X.carrier)\n    intro i\n    rw [map_zero]\n    apply this\n  intro i\n  replace hn := congr_arg (fun x => X.presheaf.map (hom_of_le (hâ‚ i)).op (f ^ (finset.univ.sup n - n i)) * x) (hn i)\n  dsimp at hn\n  simp only [â† map_mul, â† map_pow] at hn\n  rwa [mul_zero, â† mul_assoc, â† pow_add, tsub_add_cancel_of_le] at hn\n  apply finset.le_sup (finset.mem_univ i)\n#align\n  exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_compact exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_compact\n\n",
 "exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_affine_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr |_ Â» -/\ntheorem exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_affine_open (X : Scheme) {U : opens X.carrier}\n    (hU : is_affine_open U) (x f : X.presheaf.obj (op U)) (H : Â«expr |_ Â» x (X.basic_open f) = 0) :\n    âˆƒ n : â„•, f ^ n * x = 0 :=\n  by\n  rw [â† map_zero (X.presheaf.map (hom_of_le <| X.basic_open_le f : Â«expr âŸ¶ Â» (X.basic_open f) U).op)] at H\n  have := (is_localization_basic_open hU f).3\n  obtain âŸ¨âŸ¨_, n, rflâŸ©, eâŸ© := this.mp H\n  exact âŸ¨n, by simpa [mul_comm x] using eâŸ©\n#align\n  exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_affine_open exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_affine_open\n\n",
 "compact_space_iff_quasi_compact":
 "theorem compact_space_iff_quasi_compact (X : Scheme) : compact_space X.carrier â†” quasi_compact (terminal.from X) :=\n  (quasi_compact_over_affine_iff _).symm\n#align compact_space_iff_quasi_compact compact_space_iff_quasi_compact\n\n",
 "compact_open_induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n@[elab_as_elim]\ntheorem compact_open_induction_on {P : opens X.carrier â†’ Prop} (S : opens X.carrier) (hS : is_compact S.1)\n    (hâ‚ : P (Â«exprâŠ¥Â»))\n    (hâ‚‚ : âˆ€ (S : opens X.carrier) (hS : is_compact S.1) (U : X.affine_opens), P S â†’ P (Â«expr âŠ” Â» S U)) : P S := by\n  classical\n    obtain âŸ¨s, hs, hs'âŸ© := (is_compact_open_iff_eq_finset_affine_union S.1).mp âŸ¨hS, S.2âŸ©\n    replace hs' : S = supáµ¢ fun i : s => (i : opens X.carrier) :=\n      by\n      ext1\n      simpa using hs'\n    subst hs'\n    apply hs.induction_on\n    Â· convert hâ‚\n      rw [supáµ¢_eq_bot]\n      rintro âŸ¨_, hâŸ©\n      exact h.elim\n    Â· intro x s hâ‚ƒ hs hâ‚„\n      have :\n        is_compact\n          (Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n              (i : opens X.carrier)).1 :=\n        by\n        refine' ((is_compact_open_iff_eq_finset_affine_union _).mpr _).1\n        exact âŸ¨s, hs, by simpâŸ©\n      convert hâ‚‚ _ this x hâ‚„\n      simp only [coe_coe]\n      rw [supáµ¢_subtype, sup_comm]\n      conv_rhs => rw [supáµ¢_subtype]\n      exact supáµ¢_insert\n#align compact_open_induction_on compact_open_induction_on\n\n",
 "affine_property_to_property":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem quasi_compact.affine_property_to_property {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) :\n    (quasi_compact.affine_property : _).to_property f â†” is_affine Y âˆ§ compact_space X.carrier :=\n  by\n  delta affine_target_morphism_property.to_property quasi_compact.affine_property\n  simp\n#align quasi_compact.affine_property_to_property quasi_compact.affine_property_to_property\n\n",
 "affine_property_stable_under_base_change":
 "theorem quasi_compact.affine_property_stable_under_base_change :\n    quasi_compact.affine_property.stable_under_base_change :=\n  by\n  intro X Y S _ _ f g h\n  rw [quasi_compact.affine_property] at hâŠ¢\n  skip\n  let ğ’° := Scheme.pullback.open_cover_of_right Y.affine_cover.finite_subcover f g\n  have : Finite ğ’°.J := by\n    dsimp [ğ’°]\n    infer_instance\n  have : âˆ€ i, compact_space (ğ’°.obj i).carrier := by\n    intro i\n    dsimp\n    infer_instance\n  exact ğ’°.compact_space\n#align quasi_compact.affine_property_stable_under_base_change quasi_compact.affine_property_stable_under_base_change\n\n",
 "affine_property_is_local":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem quasi_compact.affine_property_is_local : (quasi_compact.affine_property : _).is_local :=\n  by\n  constructor\n  Â· apply affine_target_morphism_property.respects_iso_mk <;> rintro X Y Z _ _ _ H\n    exacts[@homeomorph.compact_space _ _ H (Top.homeo_of_iso (as_iso e.inv.1.base)), H]\n  Â· introv H\n    delta quasi_compact.affine_property at HâŠ¢\n    change compact_space ((opens.map f.val.base).obj (Y.basic_open r))\n    rw [Scheme.preimage_basic_open f r]\n    erw [â† is_compact_iff_compact_space]\n    rw [â† is_compact_univ_iff] at H\n    exact is_compact_basic_open X H _\n  Â· rintro X Y H f S hS hS'\n    skip\n    rw [â† is_affine_open.basic_open_union_eq_self_iff] at hS\n    delta quasi_compact.affine_property\n    rw [â† is_compact_univ_iff]\n    change is_compact ((opens.map f.val.base).obj (Â«exprâŠ¤Â»)).1\n    rw [â† hS]\n    dsimp [opens.map]\n    simp only [opens.coe_supr, Set.preimage_unionáµ¢, subtype.val_eq_coe]\n    exacts[is_compact_Union fun i => is_compact_iff_compact_space.mpr (hS' i), top_is_affine_open _]\n#align quasi_compact.affine_property_is_local quasi_compact.affine_property_is_local\n\n",
 "affine_open_cover_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem quasi_compact.affine_open_cover_tfae {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) :\n    TFAE\n      [quasi_compact f,\n        âˆƒ (ğ’° : Scheme.open_cover.{u} Y)(_ : âˆ€ i, is_affine (ğ’°.obj i)),\n          âˆ€ i : ğ’°.J, compact_space (pullback f (ğ’°.map i)).carrier,\n        âˆ€ (ğ’° : Scheme.open_cover.{u} Y) [âˆ€ i, is_affine (ğ’°.obj i)] (i : ğ’°.J),\n          compact_space (pullback f (ğ’°.map i)).carrier,\n        âˆ€ {U : Scheme} (g : Â«expr âŸ¶ Â» U Y) [is_affine U] [is_open_immersion g], compact_space (pullback f g).carrier,\n        âˆƒ (Î¹ : Type u)(U : Î¹ â†’ opens Y.carrier)(hU : supáµ¢ U = Â«exprâŠ¤Â»)(hU' : âˆ€ i, is_affine_open (U i)),\n          âˆ€ i, compact_space (Â«expr â»Â¹' Â» f.1.base (U i).1)] :=\n  quasi_compact_eq_affine_property.symm â–¸ quasi_compact.affine_property_is_local.affine_open_cover_tfae f\n#align quasi_compact.affine_open_cover_tfae quasi_compact.affine_open_cover_tfae\n\n",
 "affine_open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem quasi_compact.affine_open_cover_iff {X Y : Scheme.{u}} (ğ’° : Scheme.open_cover.{u} Y) [âˆ€ i, is_affine (ğ’°.obj i)]\n    (f : Â«expr âŸ¶ Â» X Y) : quasi_compact f â†” âˆ€ i, compact_space (pullback f (ğ’°.map i)).carrier :=\n  quasi_compact_eq_affine_property.symm â–¸ quasi_compact.affine_property_is_local.affine_open_cover_iff f ğ’°\n#align quasi_compact.affine_open_cover_iff quasi_compact.affine_open_cover_iff\n\n"}