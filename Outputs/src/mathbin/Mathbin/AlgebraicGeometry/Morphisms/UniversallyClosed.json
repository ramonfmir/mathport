{"universally_closed_stable_under_composition":
 "theorem universally_closed_stable_under_composition : stable_under_composition @universally_closed :=\n  by\n  rw [universally_closed_eq]\n  exact stable_under_composition.universally fun X Y Z f g hf hg => is_closed_map.comp hg hf\n#align universally_closed_stable_under_composition universally_closed_stable_under_composition\n\n",
 "universally_closed_stable_under_base_change":
 "theorem universally_closed_stable_under_base_change : stable_under_base_change @universally_closed :=\n  universally_closed_eq.symm â–¸ universally_stable_under_base_change (topologically @is_closed_map)\n#align universally_closed_stable_under_base_change universally_closed_stable_under_base_change\n\n",
 "universally_closed_respects_iso":
 "theorem universally_closed_respects_iso : respects_iso @universally_closed :=\n  universally_closed_eq.symm â–¸ universally_respects_iso (topologically @is_closed_map)\n#align universally_closed_respects_iso universally_closed_respects_iso\n\n",
 "universally_closed_is_local_at_target":
 "theorem universally_closed_is_local_at_target : property_is_local_at_target @universally_closed :=\n  by\n  rw [universally_closed_eq]\n  apply universally_is_local_at_target_of_morphism_restrict\n  Â·\n    exact\n      stable_under_composition.respects_iso (fun X Y Z f g hf hg => is_closed_map.comp hg hf) fun X Y f =>\n        (Top.homeo_of_iso (Scheme.forget_to_Top.map_iso f)).is_closed_map\n  Â· intro X Y f Î¹ U hU H\n    simp_rw [topologically, morphism_restrict_base] at H\n    exact (is_closed_map_iff_is_closed_map_of_supr_eq_top hU).mpr H\n#align universally_closed_is_local_at_target universally_closed_is_local_at_target\n\n",
 "universally_closed_eq":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem universally_closed_eq : @universally_closed = universally (topologically @is_closed_map) := by ext (X Y f);\n  rw [universally_closed_iff]\n#align universally_closed_eq universally_closed_eq\n\n",
 "open_cover_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem universally_closed.open_cover_iff {X Y : Scheme.{u}} (f : Â«expr âŸ¶ Â» X Y) (ð’° : Scheme.open_cover.{u} Y) :\n    universally_closed f â†” âˆ€ i, universally_closed (pullback.snd : Â«expr âŸ¶ Â» (pullback f (ð’°.map i)) _) :=\n  universally_closed_is_local_at_target.open_cover_iff f ð’°\n#align universally_closed.open_cover_iff universally_closed.open_cover_iff\n\n",
 "morphism_restrict_base":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ£_ Â» -/\ntheorem morphism_restrict_base {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) (U : opens Y.carrier) :\n    Â«exprâ‡‘ Â» (Â«expr âˆ£_ Â» f U).1.base = U.1.restrict_preimage f.1 :=\n  funext fun x => subtype.ext <| morphism_restrict_base_coe f U x\n#align morphism_restrict_base morphism_restrict_base\n\n"}