{"is_local_ring_hom_stalk_map_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_local_ring_hom_stalk_map_congr {X Y : RingedSpace} (f g : «expr ⟶ » X Y) (H : f = g) (x)\n    (h : is_local_ring_hom (PresheafedSpace.stalk_map f x)) : is_local_ring_hom (PresheafedSpace.stalk_map g x) :=\n  by\n  rw [PresheafedSpace.stalk_map.congr_hom _ _ H.symm x]\n  infer_instance\n#align is_local_ring_hom_stalk_map_congr is_local_ring_hom_stalk_map_congr\n\n",
 "is_colimit_exists_rep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem is_colimit_exists_rep {c : cocone F} (hc : is_colimit c) (x : c.X) :\n    ∃ (i : J)(y : F.obj i), (c.ι.app i).base y = x :=\n  concrete.is_colimit_exists_rep («expr ⋙ » F (SheafedSpace.forget _))\n    (is_colimit_of_preserves (SheafedSpace.forget _) hc) x\n#align is_colimit_exists_rep is_colimit_exists_rep\n\n",
 "image_basic_open_image_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_basic_open_image_preimage :\n    «expr ⁻¹' » (coequalizer.π f.1 g.1).base («expr '' » (coequalizer.π f.1 g.1).base (image_basic_open f g U s).1) =\n      (image_basic_open f g U s).1 :=\n  by\n  fapply types.coequalizer_preimage_image_eq_of_preimage_eq f.1.base g.1.base\n  · ext\n    simp_rw [types_comp_apply, ← Top.comp_app, ← PresheafedSpace.comp_base]\n    congr 2\n    exact coequalizer.condition f.1 g.1\n  · apply is_colimit_cofork_map_of_is_colimit (forget Top)\n    apply is_colimit_cofork_map_of_is_colimit (SheafedSpace.forget _)\n    exact coequalizer_is_coequalizer f.1 g.1\n  · suffices\n      (topological_space.opens.map f.1.base).obj (image_basic_open f g U s) =\n        (topological_space.opens.map g.1.base).obj (image_basic_open f g U s)\n      by injection this\n    delta image_basic_open\n    rw [preimage_basic_open f, preimage_basic_open g]\n    dsimp only [functor.op, unop_op]\n    rw [← comp_apply, ← SheafedSpace.comp_c_app', ← comp_apply, ← SheafedSpace.comp_c_app',\n      SheafedSpace.congr_app (coequalizer.condition f.1 g.1), comp_apply]\n    erw [X.to_RingedSpace.basic_open_res]\n    apply inf_eq_right.mpr\n    refine' (RingedSpace.basic_open_le _ _).trans _\n    rw [coequalizer.condition f.1 g.1]\n    exact fun _ h => h\n#align image_basic_open_image_preimage image_basic_open_image_preimage\n\n",
 "image_basic_open_image_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_basic_open_image_open : is_open («expr '' » (coequalizer.π f.1 g.1).base (image_basic_open f g U s).1) :=\n  by\n  rw [← (Top.homeo_of_iso (preserves_coequalizer.iso (SheafedSpace.forget _) f.1 g.1)).is_open_preimage,\n    Top.coequalizer_is_open_iff, ← Set.preimage_comp]\n  erw [← coe_comp]\n  rw [preserves_coequalizer.iso_hom, ι_comp_coequalizer_comparison]\n  dsimp only [SheafedSpace.forget]\n  rw [image_basic_open_image_preimage]\n  exact (image_basic_open f g U s).2\n#align image_basic_open_image_open image_basic_open_image_open\n\n",
 "colimit_exists_rep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem colimit_exists_rep (x : colimit F) : ∃ (i : J)(y : F.obj i), (colimit.ι F i).base y = x :=\n  concrete.is_colimit_exists_rep («expr ⋙ » F (SheafedSpace.forget _))\n    (is_colimit_of_preserves (SheafedSpace.forget _) (colimit.is_colimit F)) x\n#align colimit_exists_rep colimit_exists_rep\n\n"}