{"top_is_affine_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem top_is_affine_open (X : Scheme) [is_affine X] : is_affine_open («expr⊤» : Opens X.carrier) :=\n  by\n  convert range_is_affine_open_of_open_immersion ((«expr𝟙») X)\n  ext1\n  exact set.range_id.symm\n#align top_is_affine_open top_is_affine_open\n\n",
 "self_le_basic_open_union_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_affine_open.self_le_basic_open_union_iff {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (s : Set (X.presheaf.obj <| op U)) :\n    U ≤\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (X.basic_open (f : X.presheaf.obj <| op U)) ↔\n      Ideal.span s = «expr⊤» :=\n  by\n  rw [← hU.basic_open_union_eq_self_iff, @comm _ Eq]\n  refine' ⟨fun h => le_antisymm h _, le_of_eq⟩\n  simp only [supᵢ_le_iff, SetCoe.forall]\n  intro x hx\n  exact X.basic_open_le x\n#align is_affine_open.self_le_basic_open_union_iff is_affine_open.self_le_basic_open_union_iff\n\n",
 "range_is_affine_open_of_open_immersion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem range_is_affine_open_of_open_immersion {X Y : Scheme} [is_affine X] (f : «expr ⟶ » X Y)\n    [H : is_open_immersion f] : is_affine_open f.opens_range :=\n  by\n  refine' is_affine_of_iso (is_open_immersion.iso_of_range_eq f (Y.of_restrict _) _).inv\n  exact subtype.range_coe.symm\n  infer_instance\n#align range_is_affine_open_of_open_immersion range_is_affine_open_of_open_immersion\n\n",
 "opens_map_from_Spec_basic_open":
 "theorem is_affine_open.opens_map_from_Spec_basic_open {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (f : X.presheaf.obj (op U)) :\n    (Opens.map hU.from_Spec.val.base).obj (X.basic_open f) =\n      RingedSpace.basic_open _ (Spec_Γ_identity.inv.app (X.presheaf.obj <| op U) f) :=\n  by\n  erw [LocallyRingedSpace.preimage_basic_open]\n  refine'\n    Eq.trans _\n      (RingedSpace.basic_open_res_eq\n        (Scheme.Spec.obj <| op <| X.presheaf.obj (op U)).to_LocallyRingedSpace.to_RingedSpace\n        (eq_to_hom hU.from_Spec_base_preimage).op _)\n  congr\n  rw [← comp_apply]\n  congr\n  erw [← hU.Spec_Γ_identity_hom_app_from_Spec]\n  rw [iso.inv_hom_id_app_assoc]\n#align is_affine_open.opens_map_from_Spec_basic_open is_affine_open.opens_map_from_Spec_basic_open\n\n",
 "of_affine_open_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- Let `P` be a predicate on the affine open sets of `X` satisfying\n1. If `P` holds on `U`, then `P` holds on the basic open set of every section on `U`.\n2. If `P` holds for a family of basic open sets covering `U`, then `P` holds for `U`.\n3. There exists an affine open cover of `X` each satisfying `P`.\n\nThen `P` holds for every affine open of `X`.\n\nThis is also known as the **Affine communication lemma** in [*The rising sea*][RisingSea]. -/\n@[elab_as_elim]\ntheorem of_affine_open_cover {X : Scheme} (V : X.affine_opens) (S : Set X.affine_opens) {P : X.affine_opens → Prop}\n    (hP₁ : ∀ (U : X.affine_opens) (f : X.presheaf.obj <| op U.1), P U → P (X.affine_basic_open f))\n    (hP₂ :\n      ∀ (U : X.affine_opens) (s : Finset (X.presheaf.obj <| op U))\n        (hs : Ideal.span (s : Set (X.presheaf.obj <| op U)) = «expr⊤»), (∀ f : s, P (X.affine_basic_open f.1)) → P U)\n    (hS :\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" i :\n          Set X.carrier) =\n        Set.univ)\n    (hS' : ∀ U : S, P U) : P V := by\n  classical\n    have : ∀ x : V, ∃ f : X.presheaf.obj <| op V.1, ↑x ∈ X.basic_open f ∧ P (X.affine_basic_open f) :=\n      by\n      intro x\n      have : ↑x ∈ (Set.univ : Set X.carrier) := trivial\n      rw [← hS] at this\n      obtain ⟨W, hW⟩ := set.mem_Union.mp this\n      obtain ⟨f, g, e, hf⟩ := exists_basic_open_le_affine_inter V.prop W.1.prop x ⟨x.prop, hW⟩\n      refine' ⟨f, hf, _⟩\n      convert hP₁ _ g (hS' W) using 1\n      ext1\n      exact e\n    choose f hf₁ hf₂ using this\n    suffices Ideal.span (Set.range f) = «expr⊤»\n      by\n      obtain ⟨t, ht₁, ht₂⟩ := (Ideal.span_eq_top_iff_finite _).mp this\n      apply hP₂ V t ht₂\n      rintro ⟨i, hi⟩\n      obtain ⟨x, rfl⟩ := ht₁ hi\n      exact hf₂ x\n    rw [← V.prop.self_le_basic_open_union_iff]\n    intro x hx\n    rw [supᵢ_range', opens.mem_supr]\n    exact ⟨_, hf₁ ⟨x, hx⟩⟩\n#align of_affine_open_cover of_affine_open_cover\n\n",
 "mem_Spec_ess_image":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem mem_Spec_ess_image (X : Scheme) : X ∈ Scheme.Spec.ess_image ↔ is_affine X :=\n  ⟨fun h => ⟨Functor.essImage.unit_isIso h⟩, fun h => @mem_essImage_of_unit_isIso _ _ _ X h.1⟩\n#align mem_Spec_ess_image mem_Spec_ess_image\n\n",
 "map_restrict_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_affine_open.map_restrict_basic_open {X : Scheme} (r : X.presheaf.obj (op («expr⊤»))) {U : Opens X.carrier}\n    (hU : is_affine_open U) :\n    is_affine_open ((Opens.map (X.of_restrict (X.basic_open r).open_embedding).1.base).obj U) :=\n  by\n  apply (is_affine_open_iff_of_is_open_immersion (X.of_restrict (X.basic_open r).open_embedding) _).mp\n  delta PresheafedSpace.is_open_immersion.open_functor\n  dsimp\n  erw [opens.functor_obj_map_obj, opens.open_embedding_obj_top, inf_comm, ←\n    Scheme.basic_open_res _ _ (hom_of_le le_top).op]\n  exact hU.basic_open_is_affine _\n#align is_affine_open.map_restrict_basic_open is_affine_open.map_restrict_basic_open\n\n",
 "map_prime_spectrum_basic_open_of_affine":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem Scheme.map_prime_spectrum_basic_open_of_affine (X : Scheme) [is_affine X] (f : Scheme.Γ.obj (op X)) :\n    (Opens.map X.iso_Spec.hom.1.base).obj (prime_spectrum.basic_open f) = X.basic_open f :=\n  by\n  rw [← basic_open_eq_of_affine]\n  trans\n    (opens.map X.iso_Spec.hom.1.base).obj\n      ((Scheme.Spec.obj (op (Scheme.Γ.obj (op X)))).basic_open\n        ((inv (X.iso_Spec.hom.1.c.app (op ((opens.map (inv X.iso_Spec.hom).val.base).obj («expr⊤»)))))\n          ((X.presheaf.map (eq_to_hom _)) f)))\n  congr\n  · rw [← is_iso.inv_eq_inv, is_iso.inv_inv, is_iso.iso.inv_inv, nat_iso.app_hom]\n    erw [← Γ_Spec.adjunction_unit_app_app_top]\n    rfl\n  · rw [eq_to_hom_map]\n    rfl\n  · dsimp\n    congr\n  · refine' (Scheme.preimage_basic_open _ _).trans _\n    rw [is_iso.inv_hom_id_apply, Scheme.basic_open_res_eq]\n#align Scheme.map_prime_spectrum_basic_open_of_affine Scheme.map_prime_spectrum_basic_open_of_affine\n\n",
 "is_localization_stalk_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_affine_open.is_localization_stalk_aux {X : Scheme} (U : Opens X.carrier)\n    [is_affine (X.restrict U.open_embedding)] :\n    (inv (Γ_Spec.adjunction.unit.app (X.restrict U.open_embedding))).1.c.app (op ((Opens.map U.inclusion).obj U)) =\n      «expr ≫ »\n        (X.presheaf.map\n          (eqToHom <| by rw [opens.inclusion_map_eq_top] :\n              «expr ⟶ » (U.open_embedding.is_open_map.functor.obj («expr⊤»))\n                (U.open_embedding.is_open_map.functor.obj ((Opens.map U.inclusion).obj U))).op)\n        («expr ≫ » (to_Spec_Γ (X.presheaf.obj <| op (U.open_embedding.is_open_map.functor.obj («expr⊤»))))\n          ((Scheme.Spec.obj <| op <| X.presheaf.obj <| _).presheaf.map\n            (eqToHom\n                  (by\n                    rw [opens.inclusion_map_eq_top]\n                    rfl) :\n                «expr ⟶ » (unop _) («expr⊤»)).op)) :=\n  by\n  have e :\n    (opens.map (inv (Γ_Spec.adjunction.unit.app (X.restrict U.open_embedding))).1.base).obj\n        ((opens.map U.inclusion).obj U) =\n      «expr⊤» :=\n    by\n    rw [opens.inclusion_map_eq_top]\n    rfl\n  rw [Scheme.inv_val_c_app, is_iso.comp_inv_eq, Scheme.app_eq _ e, Γ_Spec.adjunction_unit_app_app_top]\n  simp only [category.assoc, eq_to_hom_op]\n  erw [← functor.map_comp_assoc]\n  rw [eq_to_hom_trans, eq_to_hom_refl, CategoryTheory.Functor.map_id, category.id_comp]\n  erw [Spec_Γ_identity.inv_hom_id_app_assoc]\n  simp only [eq_to_hom_map, eq_to_hom_trans]\n#align is_affine_open.is_localization_stalk_aux is_affine_open.is_localization_stalk_aux\n\n",
 "is_localization_stalk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem is_affine_open.is_localization_stalk {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) (x : U) :\n    is_localization.at_prime (X.presheaf.stalk x) (hU.prime_ideal_of x).as_ideal :=\n  by\n  haveI : is_affine _ := hU\n  haveI : Nonempty U := ⟨x⟩\n  rcases x with ⟨x, hx⟩\n  let y := hU.prime_ideal_of ⟨x, hx⟩\n  have : hU.from_Spec.val.base y = x := hU.from_Spec_prime_ideal_of ⟨x, hx⟩\n  change IsLocalization y.as_ideal.prime_compl _\n  clear_value y\n  subst this\n  apply\n    (IsLocalization.isLocalization_iff_of_ringEquiv _\n        (as_iso <| PresheafedSpace.stalk_map hU.from_Spec.1 y).CommRing_iso_to_ring_equiv).mpr\n  convert structure_sheaf.is_localization.to_stalk _ _ using 1\n  delta structure_sheaf.stalk_algebra\n  congr 1\n  rw [RingHom.algebraMap_toAlgebra]\n  refine' (PresheafedSpace.stalk_map_germ hU.from_Spec.1 _ ⟨_, _⟩).trans _\n  delta is_affine_open.from_Spec Scheme.iso_Spec structure_sheaf.to_stalk\n  simp only [Scheme.comp_val_c_app, category.assoc]\n  dsimp only [functor.op, as_iso_inv, unop_op]\n  erw [is_affine_open.is_localization_stalk_aux]\n  simp only [category.assoc]\n  conv_lhs => rw [← category.assoc]\n  erw [← X.presheaf.map_comp, Spec_Γ_naturality_assoc]\n  congr 1\n  simp only [← category.assoc]\n  trans «expr ≫ » _ ((structure_sheaf (X.presheaf.obj <| op U)).presheaf.germ ⟨_, _⟩)\n  · rfl\n  convert(structure_sheaf (X.presheaf.obj <| op U)).presheaf.germ_res (hom_of_le le_top) ⟨_, _⟩ using 2\n  rw [category.assoc]\n  erw [nat_trans.naturality]\n  rw [← LocallyRingedSpace.Γ_map_op, ← LocallyRingedSpace.Γ.map_comp_assoc, ← op_comp]\n  erw [← Scheme.Spec.map_comp]\n  rw [← op_comp, ← X.presheaf.map_comp]\n  trans «expr ≫ » (LocallyRingedSpace.Γ.map (Quiver.Hom.op <| Scheme.Spec.map (X.presheaf.map ((«expr𝟙») (op U))).op)) _\n  · congr\n  simp only [CategoryTheory.Functor.map_id, op_id]\n  erw [CategoryTheory.Functor.map_id]\n  rw [category.id_comp]\n  rfl\n#align is_affine_open.is_localization_stalk is_affine_open.is_localization_stalk\n\n",
 "is_localization_of_eq_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_localization_of_eq_basic_open {X : Scheme} {U V : Opens X.carrier} (i : «expr ⟶ » V U)\n    (hU : is_affine_open U) (r : X.presheaf.obj (op U)) (e : V = X.basic_open r) :\n    @is_localization.away _ r (X.presheaf.obj (op V)) _ (X.presheaf.map i.op).to_algebra :=\n  by\n  subst e\n  convert is_localization_basic_open hU r using 3\n#align is_localization_of_eq_basic_open is_localization_of_eq_basic_open\n\n",
 "is_localization_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_localization_basic_open {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (f : X.presheaf.obj (op U)) : is_localization.away f (X.presheaf.obj (op <| X.basic_open f)) :=\n  by\n  apply\n    (IsLocalization.isLocalization_iff_of_ringEquiv (Submonoid.powers f)\n        (as_iso <|\n            «expr ≫ » (basic_open_sections_to_affine hU f)\n              ((Scheme.Spec.obj _).presheaf.map\n                (eq_to_hom (basic_open_eq_of_affine _).symm).op)).CommRing_iso_to_ring_equiv).mpr\n  convert structure_sheaf.is_localization.to_basic_open _ f\n  change «expr ≫ » _ («expr ≫ » (basic_open_sections_to_affine hU f) _) = _\n  delta basic_open_sections_to_affine\n  erw [RingHom.algebraMap_toAlgebra]\n  simp only [Scheme.comp_val_c_app, category.assoc]\n  erw [hU.from_Spec.val.c.naturality_assoc]\n  rw [hU.from_Spec_app_eq]\n  dsimp\n  simp only [category.assoc, ← functor.map_comp, ← op_comp]\n  apply structure_sheaf.to_open_res\n#align is_localization_basic_open is_localization_basic_open\n\n",
 "is_compact":
 "theorem is_affine_open.is_compact {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) :\n    IsCompact (U : Set X.carrier) :=\n  by\n  convert@IsCompact.image _ _ _ _ Set.univ hU.from_Spec.1.base prime_spectrum.compact_space.1 (by continuity)\n  convert hU.from_Spec_range.symm\n  exact Set.image_univ\n#align is_affine_open.is_compact is_affine_open.is_compact\n\n",
 "is_basis_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_basis_basic_open (X : Scheme) [is_affine X] :\n    Opens.IsBasis (Set.range (X.basic_open : X.presheaf.obj (op («expr⊤»)) → Opens X.carrier)) :=\n  by\n  delta opens.is_basis\n  convert prime_spectrum.is_basis_basic_opens.inducing\n      (TopCat.homeoOfIso (Scheme.forget_to_Top.map_iso X.iso_Spec)).inducing using\n    1\n  ext\n  simp only [Set.mem_image, exists_exists_eq_and]\n  constructor\n  · rintro ⟨_, ⟨x, rfl⟩, rfl⟩\n    refine' ⟨_, ⟨_, ⟨x, rfl⟩, rfl⟩, _⟩\n    exact congr_arg opens.carrier (X.map_prime_spectrum_basic_open_of_affine x)\n  · rintro ⟨_, ⟨_, ⟨x, rfl⟩, rfl⟩, rfl⟩\n    refine' ⟨_, ⟨x, rfl⟩, _⟩\n    exact congr_arg opens.carrier (X.map_prime_spectrum_basic_open_of_affine x).symm\n#align is_basis_basic_open is_basis_basic_open\n\n",
 "is_basis_affine_open":
 "theorem is_basis_affine_open (X : Scheme) : Opens.IsBasis X.affine_opens :=\n  by\n  rw [opens.is_basis_iff_nbhd]\n  rintro U x (hU : x ∈ (U : Set X.carrier))\n  obtain ⟨S, hS, hxS, hSU⟩ := X.affine_basis_cover_is_basis.exists_subset_of_mem_open hU U.is_open\n  refine' ⟨⟨S, X.affine_basis_cover_is_basis.is_open hS⟩, _, hxS, hSU⟩\n  rcases hS with ⟨i, rfl⟩\n  exact range_is_affine_open_of_open_immersion _\n#align is_basis_affine_open is_basis_affine_open\n\n",
 "is_affine_open_iff_of_is_open_immersion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_affine_open_iff_of_is_open_immersion {X Y : Scheme} (f : «expr ⟶ » X Y) [H : is_open_immersion f]\n    (U : Opens X.carrier) : is_affine_open (H.open_functor.obj U) ↔ is_affine_open U :=\n  by\n  refine' ⟨fun hU => @is_affine_of_iso _ _ hU, fun hU => hU.image_is_open_immersion f⟩\n  refine' (is_open_immersion.iso_of_range_eq («expr ≫ » (X.of_restrict _) f) (Y.of_restrict _) _).hom\n  · rw [Scheme.comp_val_base, coe_comp, Set.range_comp]\n    dsimp [opens.inclusion]\n    rw [Subtype.range_coe, Subtype.range_coe]\n    rfl\n  · infer_instance\n#align is_affine_open_iff_of_is_open_immersion is_affine_open_iff_of_is_open_immersion\n\n",
 "is_affine_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_affine_of_iso {X Y : Scheme} (f : «expr ⟶ » X Y) [IsIso f] [h : is_affine Y] : is_affine X :=\n  by\n  rw [← mem_Spec_ess_image] at h⊢\n  exact functor.ess_image.of_iso (as_iso f).symm h\n#align is_affine_of_iso is_affine_of_iso\n\n",
 "image_is_open_immersion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_affine_open.image_is_open_immersion {X Y : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (f : «expr ⟶ » X Y) [H : is_open_immersion f] : is_affine_open (f.opens_functor.obj U) :=\n  by\n  haveI : is_affine _ := hU\n  convert range_is_affine_open_of_open_immersion («expr ≫ » (X.of_restrict U.open_embedding) f)\n  ext1\n  exact Set.image_eq_range _ _\n#align is_affine_open.image_is_open_immersion is_affine_open.image_is_open_immersion\n\n",
 "from_Spec_range":
 "theorem is_affine_open.from_Spec_range {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) :\n    Set.range hU.from_Spec.1.base = (U : Set X.carrier) :=\n  by\n  delta is_affine_open.from_Spec\n  erw [← category.assoc, Scheme.comp_val_base]\n  rw [coe_comp, Set.range_comp, set.range_iff_surjective.mpr, Set.image_univ]\n  exact Subtype.range_coe\n  rw [← TopCat.epi_iff_surjective]\n  infer_instance\n#align is_affine_open.from_Spec_range is_affine_open.from_Spec_range\n\n",
 "from_Spec_prime_ideal_of":
 "theorem is_affine_open.from_Spec_prime_ideal_of {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) (x : U) :\n    hU.from_Spec.val.base (hU.prime_ideal_of x) = x.1 :=\n  by\n  dsimp only [is_affine_open.from_Spec, Subtype.coe_mk]\n  erw [← Scheme.comp_val_base_apply, ← Scheme.comp_val_base_apply]\n  simpa only [← functor.map_comp_assoc, ← functor.map_comp, ← op_comp, eq_to_hom_trans, op_id, eq_to_hom_refl,\n    CategoryTheory.Functor.map_id, category.id_comp, iso.hom_inv_id_assoc]\n#align is_affine_open.from_Spec_prime_ideal_of is_affine_open.from_Spec_prime_ideal_of\n\n",
 "from_Spec_map_basic_open":
 "theorem is_affine_open.from_Spec_map_basic_open {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (f : X.presheaf.obj (op U)) :\n    (Opens.map hU.from_Spec.val.base).obj (X.basic_open f) = prime_spectrum.basic_open f := by simp\n#align is_affine_open.from_Spec_map_basic_open is_affine_open.from_Spec_map_basic_open\n\n",
 "from_Spec_image_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_affine_open.from_Spec_image_top {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) :\n    hU.is_open_immersion_from_Spec.base_open.is_open_map.functor.obj («expr⊤») = U :=\n  by\n  ext1\n  exact set.image_univ.trans hU.from_Spec_range\n#align is_affine_open.from_Spec_image_top is_affine_open.from_Spec_image_top\n\n",
 "from_Spec_base_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_affine_open.from_Spec_base_preimage {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) :\n    (Opens.map hU.from_Spec.val.base).obj U = «expr⊤» := by\n  ext1\n  change «expr ⁻¹' » hU.from_Spec.1.base (U : Set X.carrier) = Set.univ\n  rw [← hU.from_Spec_range, ← Set.image_univ]\n  exact Set.preimage_image_eq _ PresheafedSpace.is_open_immersion.base_open.inj\n#align is_affine_open.from_Spec_base_preimage is_affine_open.from_Spec_base_preimage\n\n",
 "from_Spec_app_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[elementwise]\ntheorem is_affine_open.from_Spec_app_eq {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) :\n    hU.from_Spec.1.c.app (op U) =\n      «expr ≫ » (Spec_Γ_identity.inv.app (X.presheaf.obj <| op U))\n        ((Scheme.Spec.obj _).presheaf.map (eqToHom hU.from_Spec_base_preimage).op) :=\n  by rw [← hU.Spec_Γ_identity_hom_app_from_Spec, iso.inv_hom_id_app_assoc]\n#align is_affine_open.from_Spec_app_eq is_affine_open.from_Spec_app_eq\n\n",
 "exists_basic_open_le_affine_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem exists_basic_open_le_affine_inter {X : Scheme} {U V : Opens X.carrier} (hU : is_affine_open U)\n    (hV : is_affine_open V) (x : X.carrier) (hx : x ∈ «expr ⊓ » U V) :\n    ∃ (f : X.presheaf.obj <| op U)(g : X.presheaf.obj <| op V), X.basic_open f = X.basic_open g ∧ x ∈ X.basic_open f :=\n  by\n  obtain ⟨f, hf₁, hf₂⟩ := hU.exists_basic_open_le ⟨x, hx.2⟩ hx.1\n  obtain ⟨g, hg₁, hg₂⟩ := hV.exists_basic_open_le ⟨x, hf₂⟩ hx.2\n  obtain ⟨f', hf'⟩ := basic_open_basic_open_is_basic_open hU f (X.presheaf.map (hom_of_le hf₁ : «expr ⟶ » _ V).op g)\n  replace hf' := (hf'.trans (RingedSpace.basic_open_res _ _ _)).trans (inf_eq_right.mpr hg₁)\n  exact ⟨f', g, hf', hf'.symm ▸ hg₂⟩\n#align exists_basic_open_le_affine_inter exists_basic_open_le_affine_inter\n\n",
 "exists_basic_open_le":
 "theorem is_affine_open.exists_basic_open_le {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    {V : Opens X.carrier} (x : V) (h : ↑x ∈ U) :\n    ∃ f : X.presheaf.obj (op U), X.basic_open f ≤ V ∧ ↑x ∈ X.basic_open f :=\n  by\n  haveI : is_affine _ := hU\n  obtain ⟨_, ⟨_, ⟨r, rfl⟩, rfl⟩, h₁, h₂⟩ :=\n    (is_basis_basic_open (X.restrict U.open_embedding)).exists_subset_of_mem_open _\n      ((opens.map U.inclusion).obj V).is_open\n  swap\n  exact ⟨x, h⟩\n  have :\n    U.open_embedding.is_open_map.functor.obj ((X.restrict U.open_embedding).basic_open r) =\n      X.basic_open (X.presheaf.map (eq_to_hom U.open_embedding_obj_top.symm).op r) :=\n    by\n    refine' (Scheme.image_basic_open (X.of_restrict U.open_embedding) r).trans _\n    erw [← Scheme.basic_open_res_eq _ _ (eq_to_hom U.open_embedding_obj_top).op]\n    rw [← comp_apply, ← CategoryTheory.Functor.map_comp, ← op_comp, eq_to_hom_trans, eq_to_hom_refl, op_id,\n      CategoryTheory.Functor.map_id, Scheme.hom.inv_app]\n    erw [PresheafedSpace.is_open_immersion.of_restrict_inv_app]\n    congr\n  use X.presheaf.map (eq_to_hom U.open_embedding_obj_top.symm).op r\n  rw [← this]\n  exact ⟨set.image_subset_iff.mpr h₂, Set.mem_image_of_mem _ h₁⟩\n  exact x.prop\n#align is_affine_open.exists_basic_open_le is_affine_open.exists_basic_open_le\n\n",
 "basic_open_union_eq_self_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_affine_open.basic_open_union_eq_self_iff {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (s : Set (X.presheaf.obj <| op U)) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (X.basic_open (f : X.presheaf.obj <| op U)) =\n        U ↔\n      Ideal.span s = «expr⊤» :=\n  by\n  trans\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (prime_spectrum.basic_open i.1).1 =\n      Set.univ\n  trans\n    «expr ⁻¹' » hU.from_Spec.1.base\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            (X.basic_open (f : X.presheaf.obj <| op U))).1 =\n      «expr ⁻¹' » hU.from_Spec.1.base U.1\n  · refine' ⟨fun h => by rw [h], _⟩\n    intro h\n    apply_fun Set.image hU.from_Spec.1.base  at h\n    rw [Set.image_preimage_eq_inter_range, Set.image_preimage_eq_inter_range, hU.from_Spec_range] at h\n    simp only [Set.inter_self, opens.carrier_eq_coe, Set.inter_eq_right_iff_subset] at h\n    ext1\n    refine' Set.Subset.antisymm _ h\n    simp only [Set.unionᵢ_subset_iff, SetCoe.forall, opens.coe_supr]\n    intro x hx\n    exact X.basic_open_le x\n  · simp only [opens.supr_def, Subtype.coe_mk, Set.preimage_unionᵢ, subtype.val_eq_coe]\n    congr 3\n    · ext1 x\n      exact congr_arg opens.carrier (hU.from_Spec_map_basic_open _)\n    · exact congr_arg opens.carrier hU.from_Spec_base_preimage\n  · simp only [opens.carrier_eq_coe, prime_spectrum.basic_open_eq_zero_locus_compl]\n    rw [← Set.compl_interᵢ, Set.compl_univ_iff, ← prime_spectrum.zero_locus_Union, ←\n      prime_spectrum.zero_locus_empty_iff_eq_top, prime_spectrum.zero_locus_span]\n    simp only [Set.unionᵢ_singleton_eq_range, Subtype.range_val_subtype, Set.setOf_mem_eq]\n#align is_affine_open.basic_open_union_eq_self_iff is_affine_open.basic_open_union_eq_self_iff\n\n",
 "basic_open_is_affine":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem is_affine_open.basic_open_is_affine {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (f : X.presheaf.obj (op U)) : is_affine_open (X.basic_open f) :=\n  by\n  convert range_is_affine_open_of_open_immersion\n      («expr ≫ » (Scheme.Spec.map (CommRing.of_hom (algebraMap (X.presheaf.obj (op U)) (Localization.Away f))).op)\n        hU.from_Spec)\n  ext1\n  have :\n    «expr '' » hU.from_Spec.val.base («expr ⁻¹' » hU.from_Spec.val.base (X.basic_open f : Set X.carrier)) =\n      (X.basic_open f : Set X.carrier) :=\n    by\n    rw [Set.image_preimage_eq_inter_range, Set.inter_eq_left_iff_subset, hU.from_Spec_range]\n    exact Scheme.basic_open_le _ _\n  rw [Scheme.hom.opens_range_coe, Scheme.comp_val_base, ← this, coe_comp, Set.range_comp]\n  congr 1\n  refine' (congr_arg coe <| Scheme.preimage_basic_open hU.from_Spec f).trans _\n  refine' Eq.trans _ (prime_spectrum.localization_away_comap_range (Localization.Away f) f).symm\n  congr 1\n  have : (opens.map hU.from_Spec.val.base).obj U = «expr⊤» :=\n    by\n    ext1\n    change «expr ⁻¹' » hU.from_Spec.1.base (U : Set X.carrier) = Set.univ\n    rw [← hU.from_Spec_range, ← Set.image_univ]\n    exact Set.preimage_image_eq _ PresheafedSpace.is_open_immersion.base_open.inj\n  refine' Eq.trans _ (basic_open_eq_of_affine f)\n  have lm : ∀ s, «expr ⊓ » ((opens.map hU.from_Spec.val.base).obj U) s = s := fun s => this.symm ▸ top_inf_eq\n  refine' Eq.trans _ (lm _)\n  refine' Eq.trans _ ((Scheme.Spec.obj <| op <| X.presheaf.obj <| op U).basic_open_res _ (eq_to_hom this).op)\n  rw [← comp_apply]\n  congr 2\n  rw [iso.eq_inv_comp]\n  erw [hU.Spec_Γ_identity_hom_app_from_Spec]\n#align is_affine_open.basic_open_is_affine is_affine_open.basic_open_is_affine\n\n",
 "basic_open_from_Spec_app":
 "@[simp]\ntheorem is_affine_open.basic_open_from_Spec_app {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (f : X.presheaf.obj (op U)) :\n    @Scheme.basic_open (Scheme.Spec.obj <| op (X.presheaf.obj <| op U)) ((Opens.map hU.from_Spec.1.base).obj U)\n        (hU.from_Spec.1.c.app (op U) f) =\n      prime_spectrum.basic_open f :=\n  by\n  rw [← Scheme.basic_open_res_eq _ _ (eq_to_hom hU.from_Spec_base_preimage.symm).op, basic_open_eq_of_affine',\n    is_affine_open.from_Spec_app_eq]\n  congr\n  rw [← comp_apply, ← comp_apply, category.assoc, ← functor.map_comp_assoc, eq_to_hom_op, eq_to_hom_op, eq_to_hom_trans,\n    eq_to_hom_refl, CategoryTheory.Functor.map_id, category.id_comp, ← iso.app_inv, iso.inv_hom_id]\n  rfl\n#align is_affine_open.basic_open_from_Spec_app is_affine_open.basic_open_from_Spec_app\n\n",
 "basic_open_basic_open_is_basic_open":
 "theorem basic_open_basic_open_is_basic_open {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (f : X.presheaf.obj (op U)) (g : X.presheaf.obj (op <| X.basic_open f)) :\n    ∃ f' : X.presheaf.obj (op U), X.basic_open f' = X.basic_open g :=\n  by\n  haveI := is_localization_basic_open hU f\n  obtain ⟨x, ⟨_, n, rfl⟩, rfl⟩ := IsLocalization.surj'' (Submonoid.powers f) g\n  use f * x\n  rw [Algebra.smul_def, Scheme.basic_open_mul, Scheme.basic_open_mul]\n  erw [Scheme.basic_open_res]\n  refine' (inf_eq_left.mpr _).symm\n  convert inf_le_left using 1\n  apply Scheme.basic_open_of_is_unit\n  apply\n    Submonoid.leftInv_le_isUnit _\n      (IsLocalization.toInvSubmonoid (Submonoid.powers f) (X.presheaf.obj (op <| X.basic_open f)) _).prop\n#align basic_open_basic_open_is_basic_open basic_open_basic_open_is_basic_open\n\n",
 "Spec_Γ_identity_hom_app_from_Spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_affine_open.Spec_Γ_identity_hom_app_from_Spec {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) :\n    «expr ≫ » (Spec_Γ_identity.hom.app (X.presheaf.obj <| op U)) (hU.from_Spec.1.c.app (op U)) =\n      (Scheme.Spec.obj _).presheaf.map (eqToHom hU.from_Spec_base_preimage).op :=\n  by\n  haveI : is_affine _ := hU\n  have e₁ := Spec_Γ_identity.hom.naturality (X.presheaf.map (eq_to_hom U.open_embedding_obj_top).op)\n  rw [← is_iso.comp_inv_eq] at e₁\n  have e₂ := Γ_Spec.adjunction_unit_app_app_top (X.restrict U.open_embedding)\n  erw [← e₂] at e₁\n  simp only [functor.id_map, Quiver.Hom.unop_op, functor.comp_map, ← functor.map_inv, ← op_inv,\n    LocallyRingedSpace.Γ_map, category.assoc, functor.right_op_map, inv_eq_to_hom] at e₁\n  delta is_affine_open.from_Spec Scheme.iso_Spec\n  rw [Scheme.comp_val_c_app, Scheme.comp_val_c_app, ← e₁]\n  simp_rw [category.assoc]\n  erw [← X.presheaf.map_comp_assoc]\n  rw [← op_comp]\n  have e₃ :\n    «expr ≫ » (U.open_embedding.is_open_map.adjunction.counit.app U) (eq_to_hom U.open_embedding_obj_top.symm) =\n      U.open_embedding.is_open_map.functor.map (eq_to_hom U.inclusion_map_eq_top) :=\n    subsingleton.elim _ _\n  have e₄ : «expr ≫ » (X.presheaf.map _) _ = _ :=\n    (as_iso (Γ_Spec.adjunction.unit.app (X.restrict U.open_embedding))).inv.1.c.naturality_assoc\n      (eq_to_hom U.inclusion_map_eq_top).op _\n  erw [e₃, e₄, ← Scheme.comp_val_c_app_assoc, iso.inv_hom_id]\n  simp only [eq_to_hom_map, eq_to_hom_op, Scheme.Spec_map_presheaf_map_eq_to_hom]\n  erw [Scheme.Spec_map_presheaf_map_eq_to_hom, category.id_comp]\n  simpa only [eq_to_hom_trans]\n#align is_affine_open.Spec_Γ_identity_hom_app_from_Spec is_affine_open.Spec_Γ_identity_hom_app_from_Spec\n\n",
 "Spec_map_presheaf_map_eq_to_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem Scheme.Spec_map_presheaf_map_eq_to_hom {X : Scheme} {U V : Opens X.carrier} (h : U = V) (W) :\n    (Scheme.Spec.map (X.presheaf.map (eqToHom h).op).op).val.c.app W =\n      eqToHom\n        (by\n          cases h\n          induction W using Opposite.rec'\n          dsimp\n          simp\n          rfl) :=\n  by\n  have : Scheme.Spec.map (X.presheaf.map ((«expr𝟙») (op U))).op = («expr𝟙») _ := by\n    rw [X.presheaf.map_id, op_id, Scheme.Spec.map_id]\n  cases h\n  refine' (Scheme.congr_app this _).trans _\n  erw [category.id_comp]\n  simpa [eq_to_hom_map]\n#align Scheme.Spec_map_presheaf_map_eq_to_hom Scheme.Spec_map_presheaf_map_eq_to_hom\n\n"}