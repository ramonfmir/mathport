{"top_is_affine_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem top_is_affine_open (X : Scheme) [is_affine X] : is_affine_open (Â«exprâŠ¤Â» : Opens X.carrier) :=\n  by\n  convert range_is_affine_open_of_open_immersion ((Â«exprğŸ™Â») X)\n  ext1\n  exact set.range_id.symm\n#align top_is_affine_open top_is_affine_open\n\n",
 "self_le_basic_open_union_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_affine_open.self_le_basic_open_union_iff {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (s : Set (X.presheaf.obj <| op U)) :\n    U â‰¤\n        Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n          (X.basic_open (f : X.presheaf.obj <| op U)) â†”\n      Ideal.span s = Â«exprâŠ¤Â» :=\n  by\n  rw [â† hU.basic_open_union_eq_self_iff, @comm _ Eq]\n  refine' âŸ¨fun h => le_antisymm h _, le_of_eqâŸ©\n  simp only [supáµ¢_le_iff, SetCoe.forall]\n  intro x hx\n  exact X.basic_open_le x\n#align is_affine_open.self_le_basic_open_union_iff is_affine_open.self_le_basic_open_union_iff\n\n",
 "range_is_affine_open_of_open_immersion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem range_is_affine_open_of_open_immersion {X Y : Scheme} [is_affine X] (f : Â«expr âŸ¶ Â» X Y)\n    [H : is_open_immersion f] : is_affine_open f.opens_range :=\n  by\n  refine' is_affine_of_iso (is_open_immersion.iso_of_range_eq f (Y.of_restrict _) _).inv\n  exact subtype.range_coe.symm\n  infer_instance\n#align range_is_affine_open_of_open_immersion range_is_affine_open_of_open_immersion\n\n",
 "opens_map_from_Spec_basic_open":
 "theorem is_affine_open.opens_map_from_Spec_basic_open {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (f : X.presheaf.obj (op U)) :\n    (Opens.map hU.from_Spec.val.base).obj (X.basic_open f) =\n      RingedSpace.basic_open _ (Spec_Î“_identity.inv.app (X.presheaf.obj <| op U) f) :=\n  by\n  erw [LocallyRingedSpace.preimage_basic_open]\n  refine'\n    Eq.trans _\n      (RingedSpace.basic_open_res_eq\n        (Scheme.Spec.obj <| op <| X.presheaf.obj (op U)).to_LocallyRingedSpace.to_RingedSpace\n        (eq_to_hom hU.from_Spec_base_preimage).op _)\n  congr\n  rw [â† comp_apply]\n  congr\n  erw [â† hU.Spec_Î“_identity_hom_app_from_Spec]\n  rw [iso.inv_hom_id_app_assoc]\n#align is_affine_open.opens_map_from_Spec_basic_open is_affine_open.opens_map_from_Spec_basic_open\n\n",
 "of_affine_open_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/-- Let `P` be a predicate on the affine open sets of `X` satisfying\n1. If `P` holds on `U`, then `P` holds on the basic open set of every section on `U`.\n2. If `P` holds for a family of basic open sets covering `U`, then `P` holds for `U`.\n3. There exists an affine open cover of `X` each satisfying `P`.\n\nThen `P` holds for every affine open of `X`.\n\nThis is also known as the **Affine communication lemma** in [*The rising sea*][RisingSea]. -/\n@[elab_as_elim]\ntheorem of_affine_open_cover {X : Scheme} (V : X.affine_opens) (S : Set X.affine_opens) {P : X.affine_opens â†’ Prop}\n    (hPâ‚ : âˆ€ (U : X.affine_opens) (f : X.presheaf.obj <| op U.1), P U â†’ P (X.affine_basic_open f))\n    (hPâ‚‚ :\n      âˆ€ (U : X.affine_opens) (s : Finset (X.presheaf.obj <| op U))\n        (hs : Ideal.span (s : Set (X.presheaf.obj <| op U)) = Â«exprâŠ¤Â»), (âˆ€ f : s, P (X.affine_basic_open f.1)) â†’ P U)\n    (hS :\n      (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" i :\n          Set X.carrier) =\n        Set.univ)\n    (hS' : âˆ€ U : S, P U) : P V := by\n  classical\n    have : âˆ€ x : V, âˆƒ f : X.presheaf.obj <| op V.1, â†‘x âˆˆ X.basic_open f âˆ§ P (X.affine_basic_open f) :=\n      by\n      intro x\n      have : â†‘x âˆˆ (Set.univ : Set X.carrier) := trivial\n      rw [â† hS] at this\n      obtain âŸ¨W, hWâŸ© := set.mem_Union.mp this\n      obtain âŸ¨f, g, e, hfâŸ© := exists_basic_open_le_affine_inter V.prop W.1.prop x âŸ¨x.prop, hWâŸ©\n      refine' âŸ¨f, hf, _âŸ©\n      convert hPâ‚ _ g (hS' W) using 1\n      ext1\n      exact e\n    choose f hfâ‚ hfâ‚‚ using this\n    suffices Ideal.span (Set.range f) = Â«exprâŠ¤Â»\n      by\n      obtain âŸ¨t, htâ‚, htâ‚‚âŸ© := (Ideal.span_eq_top_iff_finite _).mp this\n      apply hPâ‚‚ V t htâ‚‚\n      rintro âŸ¨i, hiâŸ©\n      obtain âŸ¨x, rflâŸ© := htâ‚ hi\n      exact hfâ‚‚ x\n    rw [â† V.prop.self_le_basic_open_union_iff]\n    intro x hx\n    rw [supáµ¢_range', opens.mem_supr]\n    exact âŸ¨_, hfâ‚ âŸ¨x, hxâŸ©âŸ©\n#align of_affine_open_cover of_affine_open_cover\n\n",
 "mem_Spec_ess_image":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem mem_Spec_ess_image (X : Scheme) : X âˆˆ Scheme.Spec.ess_image â†” is_affine X :=\n  âŸ¨fun h => âŸ¨Functor.essImage.unit_isIso hâŸ©, fun h => @mem_essImage_of_unit_isIso _ _ _ X h.1âŸ©\n#align mem_Spec_ess_image mem_Spec_ess_image\n\n",
 "map_restrict_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_affine_open.map_restrict_basic_open {X : Scheme} (r : X.presheaf.obj (op (Â«exprâŠ¤Â»))) {U : Opens X.carrier}\n    (hU : is_affine_open U) :\n    is_affine_open ((Opens.map (X.of_restrict (X.basic_open r).open_embedding).1.base).obj U) :=\n  by\n  apply (is_affine_open_iff_of_is_open_immersion (X.of_restrict (X.basic_open r).open_embedding) _).mp\n  delta PresheafedSpace.is_open_immersion.open_functor\n  dsimp\n  erw [opens.functor_obj_map_obj, opens.open_embedding_obj_top, inf_comm, â†\n    Scheme.basic_open_res _ _ (hom_of_le le_top).op]\n  exact hU.basic_open_is_affine _\n#align is_affine_open.map_restrict_basic_open is_affine_open.map_restrict_basic_open\n\n",
 "map_prime_spectrum_basic_open_of_affine":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem Scheme.map_prime_spectrum_basic_open_of_affine (X : Scheme) [is_affine X] (f : Scheme.Î“.obj (op X)) :\n    (Opens.map X.iso_Spec.hom.1.base).obj (prime_spectrum.basic_open f) = X.basic_open f :=\n  by\n  rw [â† basic_open_eq_of_affine]\n  trans\n    (opens.map X.iso_Spec.hom.1.base).obj\n      ((Scheme.Spec.obj (op (Scheme.Î“.obj (op X)))).basic_open\n        ((inv (X.iso_Spec.hom.1.c.app (op ((opens.map (inv X.iso_Spec.hom).val.base).obj (Â«exprâŠ¤Â»)))))\n          ((X.presheaf.map (eq_to_hom _)) f)))\n  congr\n  Â· rw [â† is_iso.inv_eq_inv, is_iso.inv_inv, is_iso.iso.inv_inv, nat_iso.app_hom]\n    erw [â† Î“_Spec.adjunction_unit_app_app_top]\n    rfl\n  Â· rw [eq_to_hom_map]\n    rfl\n  Â· dsimp\n    congr\n  Â· refine' (Scheme.preimage_basic_open _ _).trans _\n    rw [is_iso.inv_hom_id_apply, Scheme.basic_open_res_eq]\n#align Scheme.map_prime_spectrum_basic_open_of_affine Scheme.map_prime_spectrum_basic_open_of_affine\n\n",
 "is_localization_stalk_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_affine_open.is_localization_stalk_aux {X : Scheme} (U : Opens X.carrier)\n    [is_affine (X.restrict U.open_embedding)] :\n    (inv (Î“_Spec.adjunction.unit.app (X.restrict U.open_embedding))).1.c.app (op ((Opens.map U.inclusion).obj U)) =\n      Â«expr â‰« Â»\n        (X.presheaf.map\n          (eqToHom <| by rw [opens.inclusion_map_eq_top] :\n              Â«expr âŸ¶ Â» (U.open_embedding.is_open_map.functor.obj (Â«exprâŠ¤Â»))\n                (U.open_embedding.is_open_map.functor.obj ((Opens.map U.inclusion).obj U))).op)\n        (Â«expr â‰« Â» (to_Spec_Î“ (X.presheaf.obj <| op (U.open_embedding.is_open_map.functor.obj (Â«exprâŠ¤Â»))))\n          ((Scheme.Spec.obj <| op <| X.presheaf.obj <| _).presheaf.map\n            (eqToHom\n                  (by\n                    rw [opens.inclusion_map_eq_top]\n                    rfl) :\n                Â«expr âŸ¶ Â» (unop _) (Â«exprâŠ¤Â»)).op)) :=\n  by\n  have e :\n    (opens.map (inv (Î“_Spec.adjunction.unit.app (X.restrict U.open_embedding))).1.base).obj\n        ((opens.map U.inclusion).obj U) =\n      Â«exprâŠ¤Â» :=\n    by\n    rw [opens.inclusion_map_eq_top]\n    rfl\n  rw [Scheme.inv_val_c_app, is_iso.comp_inv_eq, Scheme.app_eq _ e, Î“_Spec.adjunction_unit_app_app_top]\n  simp only [category.assoc, eq_to_hom_op]\n  erw [â† functor.map_comp_assoc]\n  rw [eq_to_hom_trans, eq_to_hom_refl, CategoryTheory.Functor.map_id, category.id_comp]\n  erw [Spec_Î“_identity.inv_hom_id_app_assoc]\n  simp only [eq_to_hom_map, eq_to_hom_trans]\n#align is_affine_open.is_localization_stalk_aux is_affine_open.is_localization_stalk_aux\n\n",
 "is_localization_stalk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem is_affine_open.is_localization_stalk {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) (x : U) :\n    is_localization.at_prime (X.presheaf.stalk x) (hU.prime_ideal_of x).as_ideal :=\n  by\n  haveI : is_affine _ := hU\n  haveI : Nonempty U := âŸ¨xâŸ©\n  rcases x with âŸ¨x, hxâŸ©\n  let y := hU.prime_ideal_of âŸ¨x, hxâŸ©\n  have : hU.from_Spec.val.base y = x := hU.from_Spec_prime_ideal_of âŸ¨x, hxâŸ©\n  change IsLocalization y.as_ideal.prime_compl _\n  clear_value y\n  subst this\n  apply\n    (IsLocalization.isLocalization_iff_of_ringEquiv _\n        (as_iso <| PresheafedSpace.stalk_map hU.from_Spec.1 y).CommRing_iso_to_ring_equiv).mpr\n  convert structure_sheaf.is_localization.to_stalk _ _ using 1\n  delta structure_sheaf.stalk_algebra\n  congr 1\n  rw [RingHom.algebraMap_toAlgebra]\n  refine' (PresheafedSpace.stalk_map_germ hU.from_Spec.1 _ âŸ¨_, _âŸ©).trans _\n  delta is_affine_open.from_Spec Scheme.iso_Spec structure_sheaf.to_stalk\n  simp only [Scheme.comp_val_c_app, category.assoc]\n  dsimp only [functor.op, as_iso_inv, unop_op]\n  erw [is_affine_open.is_localization_stalk_aux]\n  simp only [category.assoc]\n  conv_lhs => rw [â† category.assoc]\n  erw [â† X.presheaf.map_comp, Spec_Î“_naturality_assoc]\n  congr 1\n  simp only [â† category.assoc]\n  trans Â«expr â‰« Â» _ ((structure_sheaf (X.presheaf.obj <| op U)).presheaf.germ âŸ¨_, _âŸ©)\n  Â· rfl\n  convert(structure_sheaf (X.presheaf.obj <| op U)).presheaf.germ_res (hom_of_le le_top) âŸ¨_, _âŸ© using 2\n  rw [category.assoc]\n  erw [nat_trans.naturality]\n  rw [â† LocallyRingedSpace.Î“_map_op, â† LocallyRingedSpace.Î“.map_comp_assoc, â† op_comp]\n  erw [â† Scheme.Spec.map_comp]\n  rw [â† op_comp, â† X.presheaf.map_comp]\n  trans Â«expr â‰« Â» (LocallyRingedSpace.Î“.map (Quiver.Hom.op <| Scheme.Spec.map (X.presheaf.map ((Â«exprğŸ™Â») (op U))).op)) _\n  Â· congr\n  simp only [CategoryTheory.Functor.map_id, op_id]\n  erw [CategoryTheory.Functor.map_id]\n  rw [category.id_comp]\n  rfl\n#align is_affine_open.is_localization_stalk is_affine_open.is_localization_stalk\n\n",
 "is_localization_of_eq_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_localization_of_eq_basic_open {X : Scheme} {U V : Opens X.carrier} (i : Â«expr âŸ¶ Â» V U)\n    (hU : is_affine_open U) (r : X.presheaf.obj (op U)) (e : V = X.basic_open r) :\n    @is_localization.away _ r (X.presheaf.obj (op V)) _ (X.presheaf.map i.op).to_algebra :=\n  by\n  subst e\n  convert is_localization_basic_open hU r using 3\n#align is_localization_of_eq_basic_open is_localization_of_eq_basic_open\n\n",
 "is_localization_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_localization_basic_open {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (f : X.presheaf.obj (op U)) : is_localization.away f (X.presheaf.obj (op <| X.basic_open f)) :=\n  by\n  apply\n    (IsLocalization.isLocalization_iff_of_ringEquiv (Submonoid.powers f)\n        (as_iso <|\n            Â«expr â‰« Â» (basic_open_sections_to_affine hU f)\n              ((Scheme.Spec.obj _).presheaf.map\n                (eq_to_hom (basic_open_eq_of_affine _).symm).op)).CommRing_iso_to_ring_equiv).mpr\n  convert structure_sheaf.is_localization.to_basic_open _ f\n  change Â«expr â‰« Â» _ (Â«expr â‰« Â» (basic_open_sections_to_affine hU f) _) = _\n  delta basic_open_sections_to_affine\n  erw [RingHom.algebraMap_toAlgebra]\n  simp only [Scheme.comp_val_c_app, category.assoc]\n  erw [hU.from_Spec.val.c.naturality_assoc]\n  rw [hU.from_Spec_app_eq]\n  dsimp\n  simp only [category.assoc, â† functor.map_comp, â† op_comp]\n  apply structure_sheaf.to_open_res\n#align is_localization_basic_open is_localization_basic_open\n\n",
 "is_compact":
 "theorem is_affine_open.is_compact {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) :\n    IsCompact (U : Set X.carrier) :=\n  by\n  convert@IsCompact.image _ _ _ _ Set.univ hU.from_Spec.1.base prime_spectrum.compact_space.1 (by continuity)\n  convert hU.from_Spec_range.symm\n  exact Set.image_univ\n#align is_affine_open.is_compact is_affine_open.is_compact\n\n",
 "is_basis_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_basis_basic_open (X : Scheme) [is_affine X] :\n    Opens.IsBasis (Set.range (X.basic_open : X.presheaf.obj (op (Â«exprâŠ¤Â»)) â†’ Opens X.carrier)) :=\n  by\n  delta opens.is_basis\n  convert prime_spectrum.is_basis_basic_opens.inducing\n      (TopCat.homeoOfIso (Scheme.forget_to_Top.map_iso X.iso_Spec)).inducing using\n    1\n  ext\n  simp only [Set.mem_image, exists_exists_eq_and]\n  constructor\n  Â· rintro âŸ¨_, âŸ¨x, rflâŸ©, rflâŸ©\n    refine' âŸ¨_, âŸ¨_, âŸ¨x, rflâŸ©, rflâŸ©, _âŸ©\n    exact congr_arg opens.carrier (X.map_prime_spectrum_basic_open_of_affine x)\n  Â· rintro âŸ¨_, âŸ¨_, âŸ¨x, rflâŸ©, rflâŸ©, rflâŸ©\n    refine' âŸ¨_, âŸ¨x, rflâŸ©, _âŸ©\n    exact congr_arg opens.carrier (X.map_prime_spectrum_basic_open_of_affine x).symm\n#align is_basis_basic_open is_basis_basic_open\n\n",
 "is_basis_affine_open":
 "theorem is_basis_affine_open (X : Scheme) : Opens.IsBasis X.affine_opens :=\n  by\n  rw [opens.is_basis_iff_nbhd]\n  rintro U x (hU : x âˆˆ (U : Set X.carrier))\n  obtain âŸ¨S, hS, hxS, hSUâŸ© := X.affine_basis_cover_is_basis.exists_subset_of_mem_open hU U.is_open\n  refine' âŸ¨âŸ¨S, X.affine_basis_cover_is_basis.is_open hSâŸ©, _, hxS, hSUâŸ©\n  rcases hS with âŸ¨i, rflâŸ©\n  exact range_is_affine_open_of_open_immersion _\n#align is_basis_affine_open is_basis_affine_open\n\n",
 "is_affine_open_iff_of_is_open_immersion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_affine_open_iff_of_is_open_immersion {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) [H : is_open_immersion f]\n    (U : Opens X.carrier) : is_affine_open (H.open_functor.obj U) â†” is_affine_open U :=\n  by\n  refine' âŸ¨fun hU => @is_affine_of_iso _ _ hU, fun hU => hU.image_is_open_immersion fâŸ©\n  refine' (is_open_immersion.iso_of_range_eq (Â«expr â‰« Â» (X.of_restrict _) f) (Y.of_restrict _) _).hom\n  Â· rw [Scheme.comp_val_base, coe_comp, Set.range_comp]\n    dsimp [opens.inclusion]\n    rw [Subtype.range_coe, Subtype.range_coe]\n    rfl\n  Â· infer_instance\n#align is_affine_open_iff_of_is_open_immersion is_affine_open_iff_of_is_open_immersion\n\n",
 "is_affine_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_affine_of_iso {X Y : Scheme} (f : Â«expr âŸ¶ Â» X Y) [IsIso f] [h : is_affine Y] : is_affine X :=\n  by\n  rw [â† mem_Spec_ess_image] at hâŠ¢\n  exact functor.ess_image.of_iso (as_iso f).symm h\n#align is_affine_of_iso is_affine_of_iso\n\n",
 "image_is_open_immersion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_affine_open.image_is_open_immersion {X Y : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (f : Â«expr âŸ¶ Â» X Y) [H : is_open_immersion f] : is_affine_open (f.opens_functor.obj U) :=\n  by\n  haveI : is_affine _ := hU\n  convert range_is_affine_open_of_open_immersion (Â«expr â‰« Â» (X.of_restrict U.open_embedding) f)\n  ext1\n  exact Set.image_eq_range _ _\n#align is_affine_open.image_is_open_immersion is_affine_open.image_is_open_immersion\n\n",
 "from_Spec_range":
 "theorem is_affine_open.from_Spec_range {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) :\n    Set.range hU.from_Spec.1.base = (U : Set X.carrier) :=\n  by\n  delta is_affine_open.from_Spec\n  erw [â† category.assoc, Scheme.comp_val_base]\n  rw [coe_comp, Set.range_comp, set.range_iff_surjective.mpr, Set.image_univ]\n  exact Subtype.range_coe\n  rw [â† TopCat.epi_iff_surjective]\n  infer_instance\n#align is_affine_open.from_Spec_range is_affine_open.from_Spec_range\n\n",
 "from_Spec_prime_ideal_of":
 "theorem is_affine_open.from_Spec_prime_ideal_of {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) (x : U) :\n    hU.from_Spec.val.base (hU.prime_ideal_of x) = x.1 :=\n  by\n  dsimp only [is_affine_open.from_Spec, Subtype.coe_mk]\n  erw [â† Scheme.comp_val_base_apply, â† Scheme.comp_val_base_apply]\n  simpa only [â† functor.map_comp_assoc, â† functor.map_comp, â† op_comp, eq_to_hom_trans, op_id, eq_to_hom_refl,\n    CategoryTheory.Functor.map_id, category.id_comp, iso.hom_inv_id_assoc]\n#align is_affine_open.from_Spec_prime_ideal_of is_affine_open.from_Spec_prime_ideal_of\n\n",
 "from_Spec_map_basic_open":
 "theorem is_affine_open.from_Spec_map_basic_open {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (f : X.presheaf.obj (op U)) :\n    (Opens.map hU.from_Spec.val.base).obj (X.basic_open f) = prime_spectrum.basic_open f := by simp\n#align is_affine_open.from_Spec_map_basic_open is_affine_open.from_Spec_map_basic_open\n\n",
 "from_Spec_image_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_affine_open.from_Spec_image_top {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) :\n    hU.is_open_immersion_from_Spec.base_open.is_open_map.functor.obj (Â«exprâŠ¤Â») = U :=\n  by\n  ext1\n  exact set.image_univ.trans hU.from_Spec_range\n#align is_affine_open.from_Spec_image_top is_affine_open.from_Spec_image_top\n\n",
 "from_Spec_base_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_affine_open.from_Spec_base_preimage {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) :\n    (Opens.map hU.from_Spec.val.base).obj U = Â«exprâŠ¤Â» := by\n  ext1\n  change Â«expr â»Â¹' Â» hU.from_Spec.1.base (U : Set X.carrier) = Set.univ\n  rw [â† hU.from_Spec_range, â† Set.image_univ]\n  exact Set.preimage_image_eq _ PresheafedSpace.is_open_immersion.base_open.inj\n#align is_affine_open.from_Spec_base_preimage is_affine_open.from_Spec_base_preimage\n\n",
 "from_Spec_app_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[elementwise]\ntheorem is_affine_open.from_Spec_app_eq {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) :\n    hU.from_Spec.1.c.app (op U) =\n      Â«expr â‰« Â» (Spec_Î“_identity.inv.app (X.presheaf.obj <| op U))\n        ((Scheme.Spec.obj _).presheaf.map (eqToHom hU.from_Spec_base_preimage).op) :=\n  by rw [â† hU.Spec_Î“_identity_hom_app_from_Spec, iso.inv_hom_id_app_assoc]\n#align is_affine_open.from_Spec_app_eq is_affine_open.from_Spec_app_eq\n\n",
 "exists_basic_open_le_affine_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem exists_basic_open_le_affine_inter {X : Scheme} {U V : Opens X.carrier} (hU : is_affine_open U)\n    (hV : is_affine_open V) (x : X.carrier) (hx : x âˆˆ Â«expr âŠ“ Â» U V) :\n    âˆƒ (f : X.presheaf.obj <| op U)(g : X.presheaf.obj <| op V), X.basic_open f = X.basic_open g âˆ§ x âˆˆ X.basic_open f :=\n  by\n  obtain âŸ¨f, hfâ‚, hfâ‚‚âŸ© := hU.exists_basic_open_le âŸ¨x, hx.2âŸ© hx.1\n  obtain âŸ¨g, hgâ‚, hgâ‚‚âŸ© := hV.exists_basic_open_le âŸ¨x, hfâ‚‚âŸ© hx.2\n  obtain âŸ¨f', hf'âŸ© := basic_open_basic_open_is_basic_open hU f (X.presheaf.map (hom_of_le hfâ‚ : Â«expr âŸ¶ Â» _ V).op g)\n  replace hf' := (hf'.trans (RingedSpace.basic_open_res _ _ _)).trans (inf_eq_right.mpr hgâ‚)\n  exact âŸ¨f', g, hf', hf'.symm â–¸ hgâ‚‚âŸ©\n#align exists_basic_open_le_affine_inter exists_basic_open_le_affine_inter\n\n",
 "exists_basic_open_le":
 "theorem is_affine_open.exists_basic_open_le {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    {V : Opens X.carrier} (x : V) (h : â†‘x âˆˆ U) :\n    âˆƒ f : X.presheaf.obj (op U), X.basic_open f â‰¤ V âˆ§ â†‘x âˆˆ X.basic_open f :=\n  by\n  haveI : is_affine _ := hU\n  obtain âŸ¨_, âŸ¨_, âŸ¨r, rflâŸ©, rflâŸ©, hâ‚, hâ‚‚âŸ© :=\n    (is_basis_basic_open (X.restrict U.open_embedding)).exists_subset_of_mem_open _\n      ((opens.map U.inclusion).obj V).is_open\n  swap\n  exact âŸ¨x, hâŸ©\n  have :\n    U.open_embedding.is_open_map.functor.obj ((X.restrict U.open_embedding).basic_open r) =\n      X.basic_open (X.presheaf.map (eq_to_hom U.open_embedding_obj_top.symm).op r) :=\n    by\n    refine' (Scheme.image_basic_open (X.of_restrict U.open_embedding) r).trans _\n    erw [â† Scheme.basic_open_res_eq _ _ (eq_to_hom U.open_embedding_obj_top).op]\n    rw [â† comp_apply, â† CategoryTheory.Functor.map_comp, â† op_comp, eq_to_hom_trans, eq_to_hom_refl, op_id,\n      CategoryTheory.Functor.map_id, Scheme.hom.inv_app]\n    erw [PresheafedSpace.is_open_immersion.of_restrict_inv_app]\n    congr\n  use X.presheaf.map (eq_to_hom U.open_embedding_obj_top.symm).op r\n  rw [â† this]\n  exact âŸ¨set.image_subset_iff.mpr hâ‚‚, Set.mem_image_of_mem _ hâ‚âŸ©\n  exact x.prop\n#align is_affine_open.exists_basic_open_le is_affine_open.exists_basic_open_le\n\n",
 "basic_open_union_eq_self_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_affine_open.basic_open_union_eq_self_iff {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (s : Set (X.presheaf.obj <| op U)) :\n    Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n          (X.basic_open (f : X.presheaf.obj <| op U)) =\n        U â†”\n      Ideal.span s = Â«exprâŠ¤Â» :=\n  by\n  trans\n    Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n        (prime_spectrum.basic_open i.1).1 =\n      Set.univ\n  trans\n    Â«expr â»Â¹' Â» hU.from_Spec.1.base\n        (Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n            (X.basic_open (f : X.presheaf.obj <| op U))).1 =\n      Â«expr â»Â¹' Â» hU.from_Spec.1.base U.1\n  Â· refine' âŸ¨fun h => by rw [h], _âŸ©\n    intro h\n    apply_fun Set.image hU.from_Spec.1.base  at h\n    rw [Set.image_preimage_eq_inter_range, Set.image_preimage_eq_inter_range, hU.from_Spec_range] at h\n    simp only [Set.inter_self, opens.carrier_eq_coe, Set.inter_eq_right_iff_subset] at h\n    ext1\n    refine' Set.Subset.antisymm _ h\n    simp only [Set.unionáµ¢_subset_iff, SetCoe.forall, opens.coe_supr]\n    intro x hx\n    exact X.basic_open_le x\n  Â· simp only [opens.supr_def, Subtype.coe_mk, Set.preimage_unionáµ¢, subtype.val_eq_coe]\n    congr 3\n    Â· ext1 x\n      exact congr_arg opens.carrier (hU.from_Spec_map_basic_open _)\n    Â· exact congr_arg opens.carrier hU.from_Spec_base_preimage\n  Â· simp only [opens.carrier_eq_coe, prime_spectrum.basic_open_eq_zero_locus_compl]\n    rw [â† Set.compl_interáµ¢, Set.compl_univ_iff, â† prime_spectrum.zero_locus_Union, â†\n      prime_spectrum.zero_locus_empty_iff_eq_top, prime_spectrum.zero_locus_span]\n    simp only [Set.unionáµ¢_singleton_eq_range, Subtype.range_val_subtype, Set.setOf_mem_eq]\n#align is_affine_open.basic_open_union_eq_self_iff is_affine_open.basic_open_union_eq_self_iff\n\n",
 "basic_open_is_affine":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem is_affine_open.basic_open_is_affine {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (f : X.presheaf.obj (op U)) : is_affine_open (X.basic_open f) :=\n  by\n  convert range_is_affine_open_of_open_immersion\n      (Â«expr â‰« Â» (Scheme.Spec.map (CommRing.of_hom (algebraMap (X.presheaf.obj (op U)) (Localization.Away f))).op)\n        hU.from_Spec)\n  ext1\n  have :\n    Â«expr '' Â» hU.from_Spec.val.base (Â«expr â»Â¹' Â» hU.from_Spec.val.base (X.basic_open f : Set X.carrier)) =\n      (X.basic_open f : Set X.carrier) :=\n    by\n    rw [Set.image_preimage_eq_inter_range, Set.inter_eq_left_iff_subset, hU.from_Spec_range]\n    exact Scheme.basic_open_le _ _\n  rw [Scheme.hom.opens_range_coe, Scheme.comp_val_base, â† this, coe_comp, Set.range_comp]\n  congr 1\n  refine' (congr_arg coe <| Scheme.preimage_basic_open hU.from_Spec f).trans _\n  refine' Eq.trans _ (prime_spectrum.localization_away_comap_range (Localization.Away f) f).symm\n  congr 1\n  have : (opens.map hU.from_Spec.val.base).obj U = Â«exprâŠ¤Â» :=\n    by\n    ext1\n    change Â«expr â»Â¹' Â» hU.from_Spec.1.base (U : Set X.carrier) = Set.univ\n    rw [â† hU.from_Spec_range, â† Set.image_univ]\n    exact Set.preimage_image_eq _ PresheafedSpace.is_open_immersion.base_open.inj\n  refine' Eq.trans _ (basic_open_eq_of_affine f)\n  have lm : âˆ€ s, Â«expr âŠ“ Â» ((opens.map hU.from_Spec.val.base).obj U) s = s := fun s => this.symm â–¸ top_inf_eq\n  refine' Eq.trans _ (lm _)\n  refine' Eq.trans _ ((Scheme.Spec.obj <| op <| X.presheaf.obj <| op U).basic_open_res _ (eq_to_hom this).op)\n  rw [â† comp_apply]\n  congr 2\n  rw [iso.eq_inv_comp]\n  erw [hU.Spec_Î“_identity_hom_app_from_Spec]\n#align is_affine_open.basic_open_is_affine is_affine_open.basic_open_is_affine\n\n",
 "basic_open_from_Spec_app":
 "@[simp]\ntheorem is_affine_open.basic_open_from_Spec_app {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (f : X.presheaf.obj (op U)) :\n    @Scheme.basic_open (Scheme.Spec.obj <| op (X.presheaf.obj <| op U)) ((Opens.map hU.from_Spec.1.base).obj U)\n        (hU.from_Spec.1.c.app (op U) f) =\n      prime_spectrum.basic_open f :=\n  by\n  rw [â† Scheme.basic_open_res_eq _ _ (eq_to_hom hU.from_Spec_base_preimage.symm).op, basic_open_eq_of_affine',\n    is_affine_open.from_Spec_app_eq]\n  congr\n  rw [â† comp_apply, â† comp_apply, category.assoc, â† functor.map_comp_assoc, eq_to_hom_op, eq_to_hom_op, eq_to_hom_trans,\n    eq_to_hom_refl, CategoryTheory.Functor.map_id, category.id_comp, â† iso.app_inv, iso.inv_hom_id]\n  rfl\n#align is_affine_open.basic_open_from_Spec_app is_affine_open.basic_open_from_Spec_app\n\n",
 "basic_open_basic_open_is_basic_open":
 "theorem basic_open_basic_open_is_basic_open {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U)\n    (f : X.presheaf.obj (op U)) (g : X.presheaf.obj (op <| X.basic_open f)) :\n    âˆƒ f' : X.presheaf.obj (op U), X.basic_open f' = X.basic_open g :=\n  by\n  haveI := is_localization_basic_open hU f\n  obtain âŸ¨x, âŸ¨_, n, rflâŸ©, rflâŸ© := IsLocalization.surj'' (Submonoid.powers f) g\n  use f * x\n  rw [Algebra.smul_def, Scheme.basic_open_mul, Scheme.basic_open_mul]\n  erw [Scheme.basic_open_res]\n  refine' (inf_eq_left.mpr _).symm\n  convert inf_le_left using 1\n  apply Scheme.basic_open_of_is_unit\n  apply\n    Submonoid.leftInv_le_isUnit _\n      (IsLocalization.toInvSubmonoid (Submonoid.powers f) (X.presheaf.obj (op <| X.basic_open f)) _).prop\n#align basic_open_basic_open_is_basic_open basic_open_basic_open_is_basic_open\n\n",
 "Spec_Î“_identity_hom_app_from_Spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem is_affine_open.Spec_Î“_identity_hom_app_from_Spec {X : Scheme} {U : Opens X.carrier} (hU : is_affine_open U) :\n    Â«expr â‰« Â» (Spec_Î“_identity.hom.app (X.presheaf.obj <| op U)) (hU.from_Spec.1.c.app (op U)) =\n      (Scheme.Spec.obj _).presheaf.map (eqToHom hU.from_Spec_base_preimage).op :=\n  by\n  haveI : is_affine _ := hU\n  have eâ‚ := Spec_Î“_identity.hom.naturality (X.presheaf.map (eq_to_hom U.open_embedding_obj_top).op)\n  rw [â† is_iso.comp_inv_eq] at eâ‚\n  have eâ‚‚ := Î“_Spec.adjunction_unit_app_app_top (X.restrict U.open_embedding)\n  erw [â† eâ‚‚] at eâ‚\n  simp only [functor.id_map, Quiver.Hom.unop_op, functor.comp_map, â† functor.map_inv, â† op_inv,\n    LocallyRingedSpace.Î“_map, category.assoc, functor.right_op_map, inv_eq_to_hom] at eâ‚\n  delta is_affine_open.from_Spec Scheme.iso_Spec\n  rw [Scheme.comp_val_c_app, Scheme.comp_val_c_app, â† eâ‚]\n  simp_rw [category.assoc]\n  erw [â† X.presheaf.map_comp_assoc]\n  rw [â† op_comp]\n  have eâ‚ƒ :\n    Â«expr â‰« Â» (U.open_embedding.is_open_map.adjunction.counit.app U) (eq_to_hom U.open_embedding_obj_top.symm) =\n      U.open_embedding.is_open_map.functor.map (eq_to_hom U.inclusion_map_eq_top) :=\n    subsingleton.elim _ _\n  have eâ‚„ : Â«expr â‰« Â» (X.presheaf.map _) _ = _ :=\n    (as_iso (Î“_Spec.adjunction.unit.app (X.restrict U.open_embedding))).inv.1.c.naturality_assoc\n      (eq_to_hom U.inclusion_map_eq_top).op _\n  erw [eâ‚ƒ, eâ‚„, â† Scheme.comp_val_c_app_assoc, iso.inv_hom_id]\n  simp only [eq_to_hom_map, eq_to_hom_op, Scheme.Spec_map_presheaf_map_eq_to_hom]\n  erw [Scheme.Spec_map_presheaf_map_eq_to_hom, category.id_comp]\n  simpa only [eq_to_hom_trans]\n#align is_affine_open.Spec_Î“_identity_hom_app_from_Spec is_affine_open.Spec_Î“_identity_hom_app_from_Spec\n\n",
 "Spec_map_presheaf_map_eq_to_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem Scheme.Spec_map_presheaf_map_eq_to_hom {X : Scheme} {U V : Opens X.carrier} (h : U = V) (W) :\n    (Scheme.Spec.map (X.presheaf.map (eqToHom h).op).op).val.c.app W =\n      eqToHom\n        (by\n          cases h\n          induction W using Opposite.rec'\n          dsimp\n          simp\n          rfl) :=\n  by\n  have : Scheme.Spec.map (X.presheaf.map ((Â«exprğŸ™Â») (op U))).op = (Â«exprğŸ™Â») _ := by\n    rw [X.presheaf.map_id, op_id, Scheme.Spec.map_id]\n  cases h\n  refine' (Scheme.congr_app this _).trans _\n  erw [category.id_comp]\n  simpa [eq_to_hom_map]\n#align Scheme.Spec_map_presheaf_map_eq_to_hom Scheme.Spec_map_presheaf_map_eq_to_hom\n\n"}