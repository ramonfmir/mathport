{"prime_ideal_of_generic_point":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem is_affine_open.prime_ideal_of_generic_point {X : Scheme} [is_integral X] {U : opens X.carrier}\n    (hU : is_affine_open U) [h : nonempty U] :\n    hU.prime_ideal_of\n        ⟨generic_point X.carrier, ((generic_point_spec X.carrier).mem_open_set_iff U.prop).mpr (by simpa using h)⟩ =\n      generic_point (Scheme.Spec.obj <| op <| X.presheaf.obj <| op U).carrier :=\n  by\n  haveI : is_affine _ := hU\n  have e : U.open_embedding.is_open_map.functor.obj («expr⊤») = U :=\n    by\n    ext1\n    exact set.image_univ.trans Subtype.range_coe\n  delta is_affine_open.prime_ideal_of\n  rw [← Scheme.comp_val_base_apply]\n  convert\n    generic_point_eq_of_is_open_immersion\n      («expr ≫ » (X.restrict U.open_embedding).iso_Spec.hom (Scheme.Spec.map (X.presheaf.map (eq_to_hom e).op).op))\n  ext1\n  exact (generic_point_eq_of_is_open_immersion (X.of_restrict U.open_embedding)).symm\n#align is_affine_open.prime_ideal_of_generic_point is_affine_open.prime_ideal_of_generic_point\n\n",
 "germ_to_function_field_injective":
 "theorem Scheme.germ_to_function_field_injective [is_integral X] (U : opens X.carrier) [nonempty U] :\n    function.injective (X.germ_to_function_field U) :=\n  germ_injective_of_is_integral _ _\n#align Scheme.germ_to_function_field_injective Scheme.germ_to_function_field_injective\n\n",
 "germ_injective_of_is_integral":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem germ_injective_of_is_integral [is_integral X] {U : opens X.carrier} (x : U) :\n    function.injective (X.presheaf.germ x) :=\n  by\n  rw [injective_iff_map_eq_zero]\n  intro y hy\n  rw [← (X.presheaf.germ x).map_zero] at hy\n  obtain ⟨W, hW, iU, iV, e⟩ := X.presheaf.germ_eq _ x.prop x.prop _ _ hy\n  cases show iU = iV from subsingleton.elim _ _\n  haveI : nonempty W := ⟨⟨_, hW⟩⟩\n  exact map_injective_of_is_integral X iU e\n#align germ_injective_of_is_integral germ_injective_of_is_integral\n\n",
 "generic_point_eq_of_is_open_immersion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem generic_point_eq_of_is_open_immersion {X Y : Scheme} (f : «expr ⟶ » X Y) [H : is_open_immersion f]\n    [hX : irreducible_space X.carrier] [irreducible_space Y.carrier] :\n    f.1.base (generic_point X.carrier : _) = (generic_point Y.carrier : _) :=\n  by\n  apply ((generic_point_spec _).eq _).symm\n  show t0_space Y.carrier; · infer_instance\n  convert (generic_point_spec X.carrier).image (show continuous f.1.base by continuity)\n  symm\n  rw [eq_top_iff, Set.top_eq_univ, Set.top_eq_univ]\n  convert subset_closure_inter_of_is_preirreducible_of_is_open _ H.base_open.open_range _\n  rw [Set.univ_inter, Set.image_univ]\n  apply (config := { instances := false }) preirreducible_space.is_preirreducible_univ\n  show preirreducible_space Y.carrier; · infer_instance\n  exact ⟨_, trivial, Set.mem_range_self hX.2.some⟩\n#align generic_point_eq_of_is_open_immersion generic_point_eq_of_is_open_immersion\n\n",
 "generic_point_eq_bot_of_affine":
 "@[simp]\ntheorem generic_point_eq_bot_of_affine (R : CommRing) [IsDomain R] :\n    generic_point (Scheme.Spec.obj <| op R).carrier = (⟨0, ideal.bot_prime⟩ : prime_spectrum R) :=\n  by\n  apply (generic_point_spec (Scheme.Spec.obj <| op R).carrier).eq\n  simp [is_generic_point_def, ← prime_spectrum.zero_locus_vanishing_ideal_eq_closure]\n#align generic_point_eq_bot_of_affine generic_point_eq_bot_of_affine\n\n",
 "function_field_is_fraction_ring_of_is_affine_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem function_field_is_fraction_ring_of_is_affine_open [is_integral X] (U : opens X.carrier) (hU : is_affine_open U)\n    [hU' : nonempty U] : is_fraction_ring (X.presheaf.obj <| op U) X.function_field :=\n  by\n  haveI : is_affine _ := hU\n  haveI : nonempty (X.restrict U.open_embedding).carrier := hU'\n  haveI : is_integral (X.restrict U.open_embedding) :=\n    @is_integral_of_is_affine_is_domain _ _ _\n      (by\n        dsimp\n        rw [opens.open_embedding_obj_top]\n        infer_instance)\n  have e : U.open_embedding.is_open_map.functor.obj («expr⊤») = U :=\n    by\n    ext1\n    exact set.image_univ.trans Subtype.range_coe\n  delta is_fraction_ring Scheme.function_field\n  convert hU.is_localization_stalk ⟨generic_point X.carrier, _⟩ using 1\n  rw [hU.prime_ideal_of_generic_point, generic_point_eq_bot_of_affine]\n  ext\n  exact mem_non_zero_divisors_iff_ne_zero\n#align function_field_is_fraction_ring_of_is_affine_open function_field_is_fraction_ring_of_is_affine_open\n\n"}