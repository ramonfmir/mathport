{"to_stalk_stalk_specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚§≥ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n@[simp, reassoc.1, elementwise]\ntheorem to_stalk_stalk_specializes {R : Type _} [CommRing R] {x y : prime_spectrum R} (h : ¬´expr ‚§≥ ¬ª x y) :\n    ¬´expr ‚â´ ¬ª (to_stalk R y) ((structure_sheaf R).presheaf.stalk_specializes h) = to_stalk R x :=\n  by\n  dsimp [to_stalk]\n  simpa [-to_open_germ]\n#align to_stalk_stalk_specializes to_stalk_stalk_specializes\n\n",
 "to_stalk_comp_stalk_to_fiber_ring_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Üí+* ¬ª -/\n@[simp]\ntheorem to_stalk_comp_stalk_to_fiber_ring_hom (x : prime_spectrum.Top R) :\n    ¬´expr ‚â´ ¬ª (to_stalk R x) (stalk_to_fiber_ring_hom R x) = (algebraMap _ _ : ¬´expr ‚Üí+* ¬ª R (Localization _)) :=\n  by\n  erw [to_stalk, category.assoc, germ_comp_stalk_to_fiber_ring_hom]\n  rfl\n#align to_stalk_comp_stalk_to_fiber_ring_hom to_stalk_comp_stalk_to_fiber_ring_hom\n\n",
 "to_open_res":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n@[simp]\ntheorem to_open_res (U V : Opens (prime_spectrum.Top R)) (i : ¬´expr ‚ü∂ ¬ª V U) :\n    ¬´expr ‚â´ ¬ª (to_open R U) ((structure_sheaf R).1.map i.op) = to_open R V :=\n  rfl\n#align to_open_res to_open_res\n\n",
 "to_open_germ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n@[simp]\ntheorem to_open_germ (U : Opens (prime_spectrum.Top R)) (x : U) :\n    ¬´expr ‚â´ ¬ª (to_open R U) ((structure_sheaf R).presheaf.germ x) = to_stalk R x :=\n  by\n  rw [‚Üê to_open_res R (¬´expr‚ä§¬ª) U (hom_of_le le_top : ¬´expr ‚ü∂ ¬ª U (¬´expr‚ä§¬ª)), category.assoc, presheaf.germ_res]\n  rfl\n#align to_open_germ to_open_germ\n\n",
 "to_open_eq_const":
 "theorem to_open_eq_const (U : Opens (prime_spectrum.Top R)) (f : R) :\n    to_open R U f = const R f 1 U fun x _ => (Ideal.ne_top_iff_one _).1 x.2.1 :=\n  Subtype.eq <| funext fun x => Eq.symm <| IsLocalization.mk'_one _ f\n#align to_open_eq_const to_open_eq_const\n\n",
 "to_open_comp_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Üí+* ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n@[elementwise, reassoc.1]\ntheorem to_open_comp_comap (f : ¬´expr ‚Üí+* ¬ª R S) (U : Opens (prime_spectrum.Top R)) :\n    ¬´expr ‚â´ ¬ª (to_open R U) (comap f U (Opens.comap (prime_spectrum.comap f) U) fun _ => id) =\n      ¬´expr ‚â´ ¬ª (CommRing.of_hom f) (to_open S _) :=\n  RingHom.ext fun s =>\n    Subtype.eq <|\n      funext fun p => by\n        simp_rw [comp_apply, comap_apply, subtype.val_eq_coe]\n        erw [localization.local_ring_hom_to_map]\n        rfl\n#align to_open_comp_comap to_open_comp_comap\n\n",
 "to_open_apply":
 "@[simp]\ntheorem to_open_apply (U : Opens (prime_spectrum.Top R)) (f : R) (x : U) : (to_open R U f).1 x = algebraMap _ _ f :=\n  rfl\n#align to_open_apply to_open_apply\n\n",
 "to_global_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n@[elementwise]\ntheorem to_global_factors :\n    to_open R (¬´expr‚ä§¬ª) =\n      ¬´expr ‚â´ ¬ª (CommRing.of_hom (algebraMap R (Localization.Away (1 : R))))\n        (¬´expr ‚â´ ¬ª (to_basic_open R (1 : R)) ((structure_sheaf R).1.map (eqToHom basic_open_one.symm).op)) :=\n  by\n  rw [‚Üê category.assoc]\n  change to_open R (¬´expr‚ä§¬ª) = ¬´expr ‚â´ ¬ª ((to_basic_open R 1).comp _) _\n  unfold CommRing.of_hom\n  rw [localization_to_basic_open R, to_open_res]\n#align to_global_factors to_global_factors\n\n",
 "to_basic_open_to_map":
 "@[simp]\ntheorem to_basic_open_to_map (s f : R) :\n    to_basic_open R s (algebraMap R (Localization.Away s) f) =\n      const R f 1 (basic_open s) fun _ _ => Submonoid.one_mem _ :=\n  (IsLocalization.lift_eq _ _).trans <| to_open_eq_const _ _ _\n#align to_basic_open_to_map to_basic_open_to_map\n\n",
 "to_basic_open_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n-- The proof here follows the argument in Hartshorne's Algebraic Geometry, Proposition II.2.2.\ntheorem to_basic_open_surjective (f : R) : function.surjective (to_basic_open R f) :=\n  by\n  intro s\n  -- In this proof, `basic_open f` will play two distinct roles: Firstly, it is an open set in the\n  -- prime spectrum. Secondly, it is used as an indexing type for various families of objects\n  -- (open sets, ring elements, ...). In order to make the distinction clear, we introduce a type\n  -- alias `Œπ` that is used whenever we want think of it as an indexing type.\n  let Œπ : Type u := basic_open f\n  -- First, we pick some cover of basic opens, on which we can represent `s` as a fraction\n  choose a' h' iDh' hxDh' s_eq' using locally_const_basic_open R (basic_open f) s\n  -- Since basic opens are compact, we can pass to a finite subcover\n  obtain ‚ü®t, ht_cover'‚ü© :=\n    (is_compact_basic_open f).elim_finite_subcover (fun i : Œπ => basic_open (h' i)) (fun i => is_open_basic_open)\n      fun x hx => _\n  swap\n  ¬∑ -- Here, we need to show that our basic opens actually form a cover of `basic_open f`\n    rw [Set.mem_union·µ¢]\n    exact ‚ü®‚ü®x, hx‚ü©, hxDh' ‚ü®x, hx‚ü©‚ü©\n  simp only [‚Üê opens.coe_supr, SetLike.coe_subset_coe] at ht_cover'\n  -- We use the normalization lemma from above to obtain the relation `a i * h j = h i * a j`\n  obtain ‚ü®a, h, iDh, ht_cover, ah_ha, s_eq‚ü© :=\n    normalize_finite_fraction_representation R (basic_open f) s t a' h' iDh' ht_cover' s_eq'\n  clear s_eq' iDh' hxDh' ht_cover' a' h'\n  simp only [‚Üê SetLike.coe_subset_coe, opens.coe_supr] at ht_cover\n  -- Next we show that some power of `f` is a linear combination of the `h i`\n  obtain ‚ü®n, hn‚ü© : f ‚àà (Ideal.span (¬´expr '' ¬ª h ‚Üët)).radical :=\n    by\n    rw [‚Üê vanishing_ideal_zero_locus_eq_radical, zero_locus_span]\n    simp only [basic_open_eq_zero_locus_compl] at ht_cover\n    rw [Set.compl_subset_comm] at ht_cover\n    -- Why doesn't `simp_rw` do this?\n    simp_rw [Set.compl_union·µ¢, compl_compl, ‚Üê zero_locus_Union, ‚Üê Finset.set_bunion·µ¢_coe, ‚Üê Set.image_eq_union·µ¢] at\n      ht_cover\n    apply vanishing_ideal_anti_mono ht_cover\n    exact subset_vanishing_ideal_zero_locus {f} (Set.mem_singleton f)\n  replace hn := Ideal.mul_mem_left _ f hn\n  erw [‚Üê pow_succ, Finsupp.mem_span_image_iff_total] at hn\n  rcases hn with ‚ü®b, b_supp, hb‚ü©\n  rw [Finsupp.total_apply_of_mem_supported R b_supp] at hb\n  dsimp at hb\n  -- Finally, we have all the ingredients.\n  -- We claim that our preimage is given by `(‚àë (i : Œπ) in t, b i * a i) / f ^ (n+1)`\n  use\n    IsLocalization.mk' (Localization.Away f)\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (b i * a i))\n      (‚ü®f ^ (n + 1), n + 1, rfl‚ü© : Submonoid.powers _)\n  rw [to_basic_open_mk']\n  -- Since the structure sheaf is a sheaf, we can show the desired equality locally.\n  -- Annoyingly, `sheaf.eq_of_locally_eq` requires an open cover indexed by a *type*, so we need to\n  -- coerce our finset `t` to a type first.\n  let tt := ((t : Set (basic_open f)) : Type u)\n  apply (structure_sheaf R).eq_of_locally_eq' (fun i : tt => basic_open (h i)) (basic_open f) fun i : tt => iDh i\n  ¬∑ -- This feels a little redundant, since already have `ht_cover` as a hypothesis\n    -- Unfortunately, `ht_cover` uses a bounded union over the set `t`, while here we have the\n    -- Union indexed by the type `tt`, so we need some boilerplate to translate one to the other\n    intro x hx\n    erw [TopologicalSpace.Opens.mem_sup·µ¢]\n    have := ht_cover hx\n    rw [‚Üê Finset.set_bunion·µ¢_coe, Set.mem_union·µ¢‚ÇÇ] at this\n    rcases this with ‚ü®i, i_mem, x_mem‚ü©\n    use i, i_mem\n  rintro ‚ü®i, hi‚ü©\n  dsimp\n  change (structure_sheaf R).1.map _ _ = (structure_sheaf R).1.map _ _\n  rw [s_eq i hi, res_const]\n  -- Again, `res_const` spits out an additional goal\n  swap\n  ¬∑ intro y hy\n    change y ‚àà basic_open (f ^ (n + 1))\n    rw [basic_open_pow f (n + 1) (by linarith)]\n    exact (le_of_hom (iDh i) : _) hy\n  -- The rest of the proof is just computation\n  apply const_ext\n  rw [‚Üê hb, Finset.sum_mul, Finset.mul_sum]\n  apply Finset.sum_congr rfl\n  intro j hj\n  rw [mul_assoc, ah_ha j hj i hi]\n  ring\n#align to_basic_open_surjective to_basic_open_surjective\n\n",
 "to_basic_open_mk'":
 "@[simp]\ntheorem to_basic_open_mk' (s f : R) (g : Submonoid.powers s) :\n    to_basic_open R s (IsLocalization.mk' (Localization.Away s) f g) =\n      const R f g (basic_open s) fun x hx => Submonoid.powers_subset hx g.2 :=\n  (IsLocalization.lift_mk'_spec _ _ _ _).2 <| by rw [to_open_eq_const, to_open_eq_const, const_mul_cancel']\n#align to_basic_open_mk' to_basic_open_mk'\n\n",
 "to_basic_open_injective":
 "-- The proof here follows the argument in Hartshorne's Algebraic Geometry, Proposition II.2.2.\ntheorem to_basic_open_injective (f : R) : function.injective (to_basic_open R f) :=\n  by\n  intro s t h_eq\n  obtain ‚ü®a, ‚ü®b, hb‚ü©, rfl‚ü© := IsLocalization.mk'_surjective (Submonoid.powers f) s\n  obtain ‚ü®c, ‚ü®d, hd‚ü©, rfl‚ü© := IsLocalization.mk'_surjective (Submonoid.powers f) t\n  simp only [to_basic_open_mk'] at h_eq\n  rw [IsLocalization.eq]\n  -- We know that the fractions `a/b` and `c/d` are equal as sections of the structure sheaf on\n  -- `basic_open f`. We need to show that they agree as elements in the localization of `R` at `f`.\n  -- This amounts showing that `r * (d * a) = r * (b * c)`, for some power `r = f ^ n` of `f`.\n  -- We define `I` as the ideal of *all* elements `r` satisfying the above equation.\n  let I : Ideal R :=\n    { carrier := { r : R | r * (d * a) = r * (b * c) }\n      zero_mem' := by simp only [Set.mem_setOf_eq, MulZeroClass.zero_mul]\n      add_mem' := fun r‚ÇÅ r‚ÇÇ hr‚ÇÅ hr‚ÇÇ => by\n        dsimp at hr‚ÇÅ hr‚ÇÇ‚ä¢\n        simp only [add_mul, hr‚ÇÅ, hr‚ÇÇ]\n      smul_mem' := fun r‚ÇÅ r‚ÇÇ hr‚ÇÇ => by\n        dsimp at hr‚ÇÇ‚ä¢\n        simp only [mul_assoc, hr‚ÇÇ] }\n  -- Our claim now reduces to showing that `f` is contained in the radical of `I`\n  suffices f ‚àà I.radical by\n    cases' this with n hn\n    exact ‚ü®‚ü®f ^ n, n, rfl‚ü©, hn‚ü©\n  rw [‚Üê vanishing_ideal_zero_locus_eq_radical, mem_vanishing_ideal]\n  intro p hfp\n  contrapose hfp\n  rw [mem_zero_locus, Set.not_subset]\n  have := congr_fun (congr_arg Subtype.val h_eq) ‚ü®p, hfp‚ü©\n  rw [const_apply, const_apply, IsLocalization.eq] at this\n  cases' this with r hr\n  exact ‚ü®r.1, hr, r.2‚ü©\n#align to_basic_open_injective to_basic_open_injective\n\n",
 "stalk_to_fiber_ring_hom_to_stalk":
 "@[simp]\ntheorem stalk_to_fiber_ring_hom_to_stalk (x : prime_spectrum.Top R) (f : R) :\n    stalk_to_fiber_ring_hom R x (to_stalk R x f) = algebraMap _ (Localization _) f :=\n  RingHom.ext_iff.1 (to_stalk_comp_stalk_to_fiber_ring_hom R x) _\n#align stalk_to_fiber_ring_hom_to_stalk stalk_to_fiber_ring_hom_to_stalk\n\n",
 "stalk_to_fiber_ring_hom_localization_to_stalk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n@[simp, reassoc.1]\ntheorem stalk_to_fiber_ring_hom_localization_to_stalk (x : prime_spectrum.Top R) :\n    ¬´expr ‚â´ ¬ª (stalk_to_fiber_ring_hom R x) (localization_to_stalk R x) = (¬´exprùüô¬ª) _ :=\n  (stalk_iso R x).hom_inv_id\n#align stalk_to_fiber_ring_hom_localization_to_stalk stalk_to_fiber_ring_hom_localization_to_stalk\n\n",
 "stalk_to_fiber_ring_hom_germ'":
 "@[simp]\ntheorem stalk_to_fiber_ring_hom_germ' (U : Opens (prime_spectrum.Top R)) (x : prime_spectrum.Top R) (hx : x ‚àà U)\n    (s : (structure_sheaf R).1.obj (op U)) :\n    stalk_to_fiber_ring_hom R x ((structure_sheaf R).presheaf.germ ‚ü®x, hx‚ü© s) = (s.1 ‚ü®x, hx‚ü© : _) :=\n  RingHom.ext_iff.1 (germ_comp_stalk_to_fiber_ring_hom R U ‚ü®x, hx‚ü© : _) s\n#align stalk_to_fiber_ring_hom_germ' stalk_to_fiber_ring_hom_germ'\n\n",
 "stalk_to_fiber_ring_hom_germ":
 "@[simp]\ntheorem stalk_to_fiber_ring_hom_germ (U : Opens (prime_spectrum.Top R)) (x : U) (s : (structure_sheaf R).1.obj (op U)) :\n    stalk_to_fiber_ring_hom R x ((structure_sheaf R).presheaf.germ x s) = s.1 x :=\n  by\n  cases x\n  exact stalk_to_fiber_ring_hom_germ' R U _ _ _\n#align stalk_to_fiber_ring_hom_germ stalk_to_fiber_ring_hom_germ\n\n",
 "stalk_specializes_stalk_to_fiber":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚§≥ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n@[simp, reassoc.1, elementwise]\ntheorem stalk_specializes_stalk_to_fiber {R : Type _} [CommRing R] {x y : prime_spectrum R} (h : ¬´expr ‚§≥ ¬ª x y) :\n    ¬´expr ‚â´ ¬ª ((structure_sheaf R).presheaf.stalk_specializes h) (structure_sheaf.stalk_to_fiber_ring_hom R x) =\n      ¬´expr ‚â´ ¬ª (structure_sheaf.stalk_to_fiber_ring_hom R y) (prime_spectrum.localization_map_of_specializes h) :=\n  by\n  change ¬´expr ‚â´ ¬ª _ (structure_sheaf.stalk_iso R x).hom = ¬´expr ‚â´ ¬ª (structure_sheaf.stalk_iso R y).hom _\n  rw [‚Üê iso.eq_comp_inv, category.assoc, ‚Üê iso.inv_comp_eq]\n  exact localization_to_stalk_stalk_specializes h\n#align stalk_specializes_stalk_to_fiber stalk_specializes_stalk_to_fiber\n\n",
 "stalk_algebra_map":
 "@[simp]\ntheorem stalk_algebra_map (p : prime_spectrum R) (r : R) :\n    algebraMap R ((structure_sheaf R).presheaf.stalk p) r = to_stalk R p r :=\n  rfl\n#align stalk_algebra_map stalk_algebra_map\n\n",
 "res_const'":
 "theorem res_const' (f g : R) (V hv) :\n    (structure_sheaf R).1.map (homOfLE hv).op (const R f g (basic_open g) fun _ => id) = const R f g V hv :=\n  rfl\n#align res_const' res_const'\n\n",
 "res_const":
 "@[simp]\ntheorem res_const (f g : R) (U hu V hv i) : (structure_sheaf R).1.map i (const R f g U hu) = const R f g V hv :=\n  rfl\n#align res_const res_const\n\n",
 "res_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n-- We check the sheaf condition under `forget CommRing`.\n@[simp]\ntheorem res_apply (U V : Opens (prime_spectrum.Top R)) (i : ¬´expr ‚ü∂ ¬ª V U) (s : (structure_sheaf R).1.obj (op U))\n    (x : V) : ((structure_sheaf R).1.map i.op s).1 x = (s.1 (i x) : _) :=\n  rfl\n#align res_apply res_apply\n\n",
 "open_to_localization_apply":
 "theorem open_to_localization_apply (U : Opens (prime_spectrum.Top R)) (x : prime_spectrum.Top R) (hx : x ‚àà U)\n    (s : (structure_sheaf R).1.obj (op U)) : open_to_localization R U x hx s = (s.1 ‚ü®x, hx‚ü© : _) :=\n  rfl\n#align open_to_localization_apply open_to_localization_apply\n\n",
 "open_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µñ¬ª -/\n@[simp]\ntheorem open_algebra_map (U : ¬´expr ·µí·µñ¬ª (Opens (prime_spectrum R))) (r : R) :\n    algebraMap R ((structure_sheaf R).val.obj U) r = to_open R (unop U) r :=\n  rfl\n#align open_algebra_map open_algebra_map\n\n",
 "normalize_finite_fraction_representation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ü , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ü , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (i j ¬´expr ‚àà ¬ª t) -/\n/-\nAuxiliary lemma for surjectivity of `to_basic_open`.\nA local representation of a section `s` as fractions `a i / h i` on finitely many basic opens\n`basic_open (h i)` can be \"normalized\" in such a way that `a i * h j = h i * a j` for all `i, j`\n-/\ntheorem normalize_finite_fraction_representation (U : Opens (prime_spectrum.Top R))\n    (s : (structure_sheaf R).1.obj (op U)) {Œπ : Type _} (t : Finset Œπ) (a h : Œπ ‚Üí R)\n    (iDh : ‚àÄ i : Œπ, ¬´expr ‚ü∂ ¬ª (basic_open (h i)) U)\n    (h_cover :\n      U ‚â§\n        ¬´expr‚®Ü , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª\"\n          (basic_open (h i)))\n    (hs : ‚àÄ i : Œπ, (const R (a i) (h i) (basic_open (h i)) fun y hy => hy) = (structure_sheaf R).1.map (iDh i).op s) :\n    ‚àÉ (a' h' : Œπ ‚Üí R)(iDh' : ‚àÄ i : Œπ, ¬´expr ‚ü∂ ¬ª (basic_open (h' i)) U),\n      U ‚â§\n          ¬´expr‚®Ü , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ü , ¬ª\"\n            (basic_open (h' i)) ‚àß\n        (‚àÄ (i) (_ : i ‚àà t) (j) (_ : j ‚àà t), a' i * h' j = h' i * a' j) ‚àß\n          ‚àÄ i ‚àà t, (structure_sheaf R).1.map (iDh' i).op s = const R (a' i) (h' i) (basic_open (h' i)) fun y hy => hy :=\n  by\n  -- First we show that the fractions `(a i * h j) / (h i * h j)` and `(h i * a j) / (h i * h j)`\n  -- coincide in the localization of `R` at `h i * h j`\n  have fractions_eq :\n    ‚àÄ i j : Œπ,\n      IsLocalization.mk' (Localization.Away _) (a i * h j) ‚ü®h i * h j, Submonoid.mem_powers _‚ü© =\n        IsLocalization.mk' _ (h i * a j) ‚ü®h i * h j, Submonoid.mem_powers _‚ü© :=\n    by\n    intro i j\n    let D := basic_open (h i * h j)\n    let iDi : ¬´expr ‚ü∂ ¬ª D (basic_open (h i)) := hom_of_le (basic_open_mul_le_left _ _)\n    let iDj : ¬´expr ‚ü∂ ¬ª D (basic_open (h j)) := hom_of_le (basic_open_mul_le_right _ _)\n    -- Crucially, we need injectivity of `to_basic_open`\n    apply to_basic_open_injective R (h i * h j)\n    rw [to_basic_open_mk', to_basic_open_mk']\n    simp only [[anonymous]]\n    -- Here, both sides of the equation are equal to a restriction of `s`\n    trans\n    convert congr_arg ((structure_sheaf R).1.map iDj.op) (hs j).symm using 1\n    convert congr_arg ((structure_sheaf R).1.map iDi.op) (hs i) using 1\n    swap\n    all_goals rw [res_const]; apply const_ext; ring\n    -- The remaining two goals were generated during the rewrite of `res_const`\n    -- These can be solved immediately\n    exacts[basic_open_mul_le_right _ _, basic_open_mul_le_left _ _]\n  -- From the equality in the localization, we obtain for each `(i,j)` some power `(h i * h j) ^ n`\n  -- which equalizes `a i * h j` and `h i * a j`\n  have exists_power : ‚àÄ i j : Œπ, ‚àÉ n : ‚Ñï, a i * h j * (h i * h j) ^ n = h i * a j * (h i * h j) ^ n :=\n    by\n    intro i j\n    obtain ‚ü®‚ü®c, n, rfl‚ü©, hc‚ü© := is_localization.eq.mp (fractions_eq i j)\n    use n + 1\n    rw [pow_succ]\n    dsimp at hc\n    convert hc using 1 <;> ring\n  let n := fun p : Œπ √ó Œπ => (exists_power p.1 p.2).some\n  have n_spec := fun p : Œπ √ó Œπ => (exists_power p.fst p.snd).some_spec\n  -- We need one power `(h i * h j) ^ N` that works for *all* pairs `(i,j)`\n  -- Since there are only finitely many indices involved, we can pick the supremum.\n  let N := (lower_set.prod t t).sup n\n  have basic_opens_eq : ‚àÄ i : Œπ, basic_open (h i ^ (N + 1)) = basic_open (h i) := fun i =>\n    basic_open_pow _ _ (by linarith)\n  -- Expanding the fraction `a i / h i` by the power `(h i) ^ N` gives the desired normalization\n  refine'\n    ‚ü®fun i => a i * h i ^ N, fun i => h i ^ (N + 1), fun i => ¬´expr ‚â´ ¬ª (eq_to_hom (basic_opens_eq i)) (iDh i), _, _, _‚ü©\n  ¬∑ simpa only [basic_opens_eq] using h_cover\n  ¬∑ intro i hi j hj\n    -- Here we need to show that our new fractions `a i / h i` satisfy the normalization condition\n    -- Of course, the power `N` we used to expand the fractions might be bigger than the power\n    -- `n (i, j)` which was originally chosen. We denote their difference by `k`\n    have n_le_N : n (i, j) ‚â§ N := Finset.le_sup (finset.mem_product.mpr ‚ü®hi, hj‚ü©)\n    cases' nat.le.dest n_le_N with k hk\n    simp only [‚Üê hk, pow_add, pow_one]\n    -- To accommodate for the difference `k`, we multiply both sides of the equation `n_spec (i, j)`\n      -- by `(h i * h j) ^ k`\n      convert congr_arg (fun z => z * (h i * h j) ^ k) (n_spec (i, j)) using 1 <;>\n      ¬∑ simp only [n, mul_pow]\n        ring\n  -- Lastly, we need to show that the new fractions still represent our original `s`\n  intro i hi\n  rw [op_comp, functor.map_comp, comp_apply, ‚Üê hs, res_const]\n  -- additional goal spit out by `res_const`\n  swap\n  exact (basic_opens_eq i).le\n  apply const_ext\n  rw [pow_succ]\n  ring\n#align normalize_finite_fraction_representation normalize_finite_fraction_representation\n\n",
 "locally_const_basic_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-\nAuxiliary lemma for surjectivity of `to_basic_open`.\nEvery section can locally be represented on basic opens `basic_opens g` as a fraction `f/g`\n-/\ntheorem locally_const_basic_open (U : Opens (prime_spectrum.Top R)) (s : (structure_sheaf R).1.obj (op U)) (x : U) :\n    ‚àÉ (f g : R)(i : ¬´expr ‚ü∂ ¬ª (basic_open g) U),\n      x.1 ‚àà basic_open g ‚àß (const R f g (basic_open g) fun y hy => hy) = (structure_sheaf R).1.map i.op s :=\n  by\n  -- First, any section `s` can be represented as a fraction `f/g` on some open neighborhood of `x`\n  -- and we may pass to a `basic_open h`, since these form a basis\n  obtain ‚ü®V, hxV : x.1 ‚àà V.1, iVU, f, g, hVDg : V ‚â§ basic_open g, s_eq‚ü© := exists_const R U s x.1 x.2\n  obtain ‚ü®_, ‚ü®h, rfl‚ü©, hxDh, hDhV : basic_open h ‚â§ V‚ü© :=\n    is_topological_basis_basic_opens.exists_subset_of_mem_open hxV V.2\n  -- The problem is of course, that `g` and `h` don't need to coincide.\n  -- But, since `basic_open h ‚â§ basic_open g`, some power of `h` must be a multiple of `g`\n  cases' (basic_open_le_basic_open_iff h g).mp (Set.Subset.trans hDhV hVDg) with n hn\n  -- Actually, we will need a *nonzero* power of `h`.\n  -- This is because we will need the equality `basic_open (h ^ n) = basic_open h`, which only\n  -- holds for a nonzero power `n`. We therefore artificially increase `n` by one.\n  replace hn := Ideal.mul_mem_left (Ideal.span {g}) h hn\n  rw [‚Üê pow_succ, Ideal.mem_span_singleton'] at hn\n  cases' hn with c hc\n  have basic_opens_eq := basic_open_pow h (n + 1) (by linarith)\n  have i_basic_open := ¬´expr ‚â´ ¬ª (eq_to_hom basic_opens_eq) (hom_of_le hDhV)\n  -- We claim that `(f * c) / h ^ (n+1)` is our desired representation\n  use f * c, h ^ (n + 1), ¬´expr ‚â´ ¬ª i_basic_open iVU, (basic_opens_eq.symm.le : _) hxDh\n  rw [op_comp, functor.map_comp, comp_apply, ‚Üê s_eq, res_const]\n  -- Note that the last rewrite here generated an additional goal, which was a parameter\n  -- of `res_const`. We prove this goal first\n  swap\n  ¬∑ intro y hy\n    rw [basic_opens_eq] at hy\n    exact (Set.Subset.trans hDhV hVDg : _) hy\n  -- All that is left is a simple calculation\n  apply const_ext\n  rw [mul_assoc f c g, hc]\n#align locally_const_basic_open locally_const_basic_open\n\n",
 "localization_to_stalk_stalk_to_fiber_ring_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n@[simp, reassoc.1]\ntheorem localization_to_stalk_stalk_to_fiber_ring_hom (x : prime_spectrum.Top R) :\n    ¬´expr ‚â´ ¬ª (localization_to_stalk R x) (stalk_to_fiber_ring_hom R x) = (¬´exprùüô¬ª) _ :=\n  (stalk_iso R x).inv_hom_id\n#align localization_to_stalk_stalk_to_fiber_ring_hom localization_to_stalk_stalk_to_fiber_ring_hom\n\n",
 "localization_to_stalk_stalk_specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚§≥ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n@[simp, reassoc.1, elementwise]\ntheorem localization_to_stalk_stalk_specializes {R : Type _} [CommRing R] {x y : prime_spectrum R} (h : ¬´expr ‚§≥ ¬ª x y) :\n    ¬´expr ‚â´ ¬ª (structure_sheaf.localization_to_stalk R y) ((structure_sheaf R).presheaf.stalk_specializes h) =\n      ¬´expr ‚â´ ¬ª (CommRing.of_hom (prime_spectrum.localization_map_of_specializes h))\n        (structure_sheaf.localization_to_stalk R x) :=\n  by\n  apply IsLocalization.ringHom_ext y.as_ideal.prime_compl\n  any_goals dsimp; infer_instance\n  erw [RingHom.comp_assoc]\n  conv_rhs => erw [RingHom.comp_assoc]\n  dsimp [CommRing.of_hom, localization_to_stalk, prime_spectrum.localization_map_of_specializes]\n  rw [IsLocalization.lift_comp, IsLocalization.lift_comp, IsLocalization.lift_comp]\n  exact to_stalk_stalk_specializes h\n#align localization_to_stalk_stalk_specializes localization_to_stalk_stalk_specializes\n\n",
 "localization_to_stalk_of":
 "@[simp]\ntheorem localization_to_stalk_of (x : prime_spectrum.Top R) (f : R) :\n    localization_to_stalk R x (algebraMap _ (Localization _) f) = to_stalk R x f :=\n  IsLocalization.lift_eq _ f\n#align localization_to_stalk_of localization_to_stalk_of\n\n",
 "localization_to_stalk_mk'":
 "@[simp]\ntheorem localization_to_stalk_mk' (x : prime_spectrum.Top R) (f : R) (s : (as_ideal x).prime_compl) :\n    localization_to_stalk R x (IsLocalization.mk' _ f s : Localization _) =\n      (structure_sheaf R).presheaf.germ (‚ü®x, s.2‚ü© : basic_open (s : R)) (const R f s (basic_open s) fun _ => id) :=\n  (IsLocalization.lift_mk'_spec _ _ _ _).2 <| by\n    erw [‚Üê germ_to_open R (basic_open s) ‚ü®x, s.2‚ü©, ‚Üê germ_to_open R (basic_open s) ‚ü®x, s.2‚ü©, ‚Üê RingHom.map_mul,\n      to_open_eq_const, to_open_eq_const, const_mul_cancel']\n#align localization_to_stalk_mk' localization_to_stalk_mk'\n\n",
 "localization_to_basic_open":
 "@[simp]\ntheorem localization_to_basic_open (f : R) :\n    RingHom.comp (to_basic_open R f) (algebraMap R (Localization.Away f)) = to_open R (basic_open f) :=\n  RingHom.ext fun g => by rw [to_basic_open, is_localization.away.lift, RingHom.comp_apply, IsLocalization.lift_eq]\n#align localization_to_basic_open localization_to_basic_open\n\n",
 "is_unit_to_stalk":
 "theorem is_unit_to_stalk (x : prime_spectrum.Top R) (f : x.as_ideal.prime_compl) : IsUnit (to_stalk R x (f : R)) :=\n  by\n  erw [‚Üê germ_to_open R (basic_open (f : R)) ‚ü®x, f.2‚ü© (f : R)]\n  exact RingHom.isUnit_map _ (is_unit_to_basic_open_self R f)\n#align is_unit_to_stalk is_unit_to_stalk\n\n",
 "is_unit_to_basic_open_self":
 "theorem is_unit_to_basic_open_self (f : R) : IsUnit (to_open R (basic_open f) f) :=\n  isUnit_of_mul_eq_one _ (const R 1 f (basic_open f) fun _ => id) <| by rw [to_open_eq_const, const_mul_rev]\n#align is_unit_to_basic_open_self is_unit_to_basic_open_self\n\n",
 "is_locally_fraction_pred":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n@[simp]\ntheorem is_locally_fraction_pred {U : Opens (prime_spectrum.Top R)} (f : ‚àÄ x : U, localizations R x) :\n    (is_locally_fraction R).pred f =\n      ‚àÄ x : U,\n        ‚àÉ (V : _)(m : x.1 ‚àà V)(i : ¬´expr ‚ü∂ ¬ª V U),\n          ‚àÉ r s : R, ‚àÄ y : V, ¬¨s ‚àà y.1.as_ideal ‚àß f (i y : U) * algebraMap _ _ s = algebraMap _ _ r :=\n  rfl\n#align is_locally_fraction_pred is_locally_fraction_pred\n\n",
 "global_sections_iso_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n@[simp]\ntheorem global_sections_iso_hom (R : CommRing) : (global_sections_iso R).hom = to_open R (¬´expr‚ä§¬ª) :=\n  rfl\n#align global_sections_iso_hom global_sections_iso_hom\n\n",
 "germ_to_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\ntheorem germ_to_top (x : prime_spectrum.Top R) (f : R) :\n    (structure_sheaf R).presheaf.germ (‚ü®x, trivial‚ü© : (¬´expr‚ä§¬ª : Opens (prime_spectrum.Top R)))\n        (to_open R (¬´expr‚ä§¬ª) f) =\n      to_stalk R x f :=\n  rfl\n#align germ_to_top germ_to_top\n\n",
 "germ_to_open":
 "@[simp]\ntheorem germ_to_open (U : Opens (prime_spectrum.Top R)) (x : U) (f : R) :\n    (structure_sheaf R).presheaf.germ x (to_open R U f) = to_stalk R x f :=\n  by\n  rw [‚Üê to_open_germ]\n  rfl\n#align germ_to_open germ_to_open\n\n",
 "germ_comp_stalk_to_fiber_ring_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n@[simp]\ntheorem germ_comp_stalk_to_fiber_ring_hom (U : Opens (prime_spectrum.Top R)) (x : U) :\n    ¬´expr ‚â´ ¬ª ((structure_sheaf R).presheaf.germ x) (stalk_to_fiber_ring_hom R x) = open_to_localization R U x x.2 :=\n  Limits.colimit.Œπ_desc _ _\n#align germ_comp_stalk_to_fiber_ring_hom germ_comp_stalk_to_fiber_ring_hom\n\n",
 "exists_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n#print exists_const /-\ntheorem exists_const (U) (s : (structure_sheaf R).1.obj (op U)) (x : prime_spectrum.Top R) (hx : x ‚àà U) :\n    ‚àÉ (V : Opens (prime_spectrum.Top R))(hxV : x ‚àà V)(i : ¬´expr ‚ü∂ ¬ª V U)(f g : R)(hg : _),\n      const R f g V hg = (structure_sheaf R).1.map i.op s :=\n  let ‚ü®V, hxV, iVU, f, g, hfg‚ü© := s.2 ‚ü®x, hx‚ü©\n  ‚ü®V, hxV, iVU, f, g, fun y hyV => (hfg ‚ü®y, hyV‚ü©).1,\n    Subtype.eq <| funext fun y => IsLocalization.mk'_eq_iff_eq_mul.2 <| Eq.symm <| (hfg y).2‚ü©\n#align exists_const exists_const\n-/\n\n",
 "eq_mk'":
 "/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Scott Morrison\n-/\ntheorem is_fraction.eq_mk' {U : Opens (prime_spectrum.Top R)} {f : ‚àÄ x : U, localizations R x} (hf : is_fraction f) :\n    ‚àÉ r s : R,\n      ‚àÄ x : U,\n        ‚àÉ hs : s ‚àâ x.1.as_ideal,\n          f x =\n            IsLocalization.mk' (localization.at_prime _) r\n              (‚ü®s, hs‚ü© : (x : prime_spectrum.Top R).as_ideal.prime_compl) :=\n  by\n  rcases hf with ‚ü®r, s, h‚ü©\n  refine' ‚ü®r, s, fun x => ‚ü®(h x).1, (is_localization.mk'_eq_iff_eq_mul.mpr _).symm‚ü©‚ü©\n  exact (h x).2.symm\n#align is_fraction.eq_mk' is_fraction.eq_mk'\n\n",
 "const_zero":
 "theorem const_zero (f : R) (U hu) : const R 0 f U hu = 0 :=\n  Subtype.eq <|\n    funext fun x =>\n      IsLocalization.mk'_eq_iff_eq_mul.2 <| by\n        erw [RingHom.map_zero, subtype.val_eq_coe, Subring.coe_zero, Pi.zero_apply, MulZeroClass.zero_mul]\n#align const_zero const_zero\n\n",
 "const_self":
 "theorem const_self (f : R) (U hu) : const R f f U hu = 1 :=\n  Subtype.eq <| funext fun x => IsLocalization.mk'_self _ _\n#align const_self const_self\n\n",
 "const_one":
 "theorem const_one (U) : (const R 1 1 U fun p _ => Submonoid.one_mem _) = 1 :=\n  const_self R 1 U _\n#align const_one const_one\n\n",
 "const_mul_rev":
 "theorem const_mul_rev (f g : R) (U hu‚ÇÅ hu‚ÇÇ) : const R f g U hu‚ÇÅ * const R g f U hu‚ÇÇ = 1 := by\n  rw [const_mul, const_congr R rfl (mul_comm g f), const_self]\n#align const_mul_rev const_mul_rev\n\n",
 "const_mul_cancel'":
 "theorem const_mul_cancel' (f g‚ÇÅ g‚ÇÇ : R) (U hu‚ÇÅ hu‚ÇÇ) : const R g‚ÇÅ g‚ÇÇ U hu‚ÇÇ * const R f g‚ÇÅ U hu‚ÇÅ = const R f g‚ÇÇ U hu‚ÇÇ :=\n  by rw [mul_comm, const_mul_cancel]\n#align const_mul_cancel' const_mul_cancel'\n\n",
 "const_mul_cancel":
 "theorem const_mul_cancel (f g‚ÇÅ g‚ÇÇ : R) (U hu‚ÇÅ hu‚ÇÇ) : const R f g‚ÇÅ U hu‚ÇÅ * const R g‚ÇÅ g‚ÇÇ U hu‚ÇÇ = const R f g‚ÇÇ U hu‚ÇÇ :=\n  by\n  rw [const_mul, const_ext]\n  rw [mul_assoc]\n#align const_mul_cancel const_mul_cancel\n\n",
 "const_mul":
 "theorem const_mul (f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : R) (U hu‚ÇÅ hu‚ÇÇ) :\n    const R f‚ÇÅ g‚ÇÅ U hu‚ÇÅ * const R f‚ÇÇ g‚ÇÇ U hu‚ÇÇ =\n      const R (f‚ÇÅ * f‚ÇÇ) (g‚ÇÅ * g‚ÇÇ) U fun x hx => Submonoid.mul_mem _ (hu‚ÇÅ x hx) (hu‚ÇÇ x hx) :=\n  Subtype.eq <| funext fun x => Eq.symm <| by convert IsLocalization.mk'_mul _ f‚ÇÅ f‚ÇÇ ‚ü®g‚ÇÅ, hu‚ÇÅ x x.2‚ü© ‚ü®g‚ÇÇ, hu‚ÇÇ x x.2‚ü©\n#align const_mul const_mul\n\n",
 "const_ext":
 "theorem const_ext {f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : R} {U hu‚ÇÅ hu‚ÇÇ} (h : f‚ÇÅ * g‚ÇÇ = f‚ÇÇ * g‚ÇÅ) : const R f‚ÇÅ g‚ÇÅ U hu‚ÇÅ = const R f‚ÇÇ g‚ÇÇ U hu‚ÇÇ :=\n  Subtype.eq <|\n    funext fun x => IsLocalization.mk'_eq_of_eq (by rw [mul_comm, Subtype.coe_mk, ‚Üê h, mul_comm, Subtype.coe_mk])\n#align const_ext const_ext\n\n",
 "const_congr":
 "theorem const_congr {f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : R} {U hu} (hf : f‚ÇÅ = f‚ÇÇ) (hg : g‚ÇÅ = g‚ÇÇ) :\n    const R f‚ÇÅ g‚ÇÅ U hu = const R f‚ÇÇ g‚ÇÇ U (hg ‚ñ∏ hu) := by substs hf hg\n#align const_congr const_congr\n\n",
 "const_apply'":
 "theorem const_apply' (f g : R) (U : Opens (prime_spectrum.Top R))\n    (hu : ‚àÄ x ‚àà U, g ‚àà (x : prime_spectrum.Top R).as_ideal.prime_compl) (x : U)\n    (hx : g ‚àà (as_ideal (x : prime_spectrum.Top R)).prime_compl) :\n    (const R f g U hu).1 x = IsLocalization.mk' _ f ‚ü®g, hx‚ü© :=\n  rfl\n#align const_apply' const_apply'\n\n",
 "const_apply":
 "/-\n\nNotation in this comment\n\nX = Spec R\nOX = structure sheaf\n\nIn the following we construct an isomorphism between OX_p and R_p given any point p corresponding\nto a prime ideal in R.\n\nWe do this via 8 steps:\n\n1. def const (f g : R) (V) (hv : V ‚â§ D_g) : OX(V) [for api]\n2. def to_open (U) : R ‚ü∂ OX(U)\n3. [2] def to_stalk (p : Spec R) : R ‚ü∂ OX_p\n4. [2] def to_basic_open (f : R) : R_f ‚ü∂ OX(D_f)\n5. [3] def localization_to_stalk (p : Spec R) : R_p ‚ü∂ OX_p\n6. def open_to_localization (U) (p) (hp : p ‚àà U) : OX(U) ‚ü∂ R_p\n7. [6] def stalk_to_fiber_ring_hom (p : Spec R) : OX_p ‚ü∂ R_p\n8. [5,7] def stalk_iso (p : Spec R) : OX_p ‚âÖ R_p\n\nIn the square brackets we list the dependencies of a construction on the previous steps.\n\n-/\n@[simp]\ntheorem const_apply (f g : R) (U : Opens (prime_spectrum.Top R))\n    (hu : ‚àÄ x ‚àà U, g ‚àà (x : prime_spectrum.Top R).as_ideal.prime_compl) (x : U) :\n    (const R f g U hu).1 x = IsLocalization.mk' _ f ‚ü®g, hu x x.2‚ü© :=\n  rfl\n#align const_apply const_apply\n\n",
 "const_add":
 "theorem const_add (f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : R) (U hu‚ÇÅ hu‚ÇÇ) :\n    const R f‚ÇÅ g‚ÇÅ U hu‚ÇÅ + const R f‚ÇÇ g‚ÇÇ U hu‚ÇÇ =\n      const R (f‚ÇÅ * g‚ÇÇ + f‚ÇÇ * g‚ÇÅ) (g‚ÇÅ * g‚ÇÇ) U fun x hx => Submonoid.mul_mem _ (hu‚ÇÅ x hx) (hu‚ÇÇ x hx) :=\n  Subtype.eq <| funext fun x => Eq.symm <| by convert IsLocalization.mk'_add f‚ÇÅ f‚ÇÇ ‚ü®g‚ÇÅ, hu‚ÇÅ x x.2‚ü© ‚ü®g‚ÇÇ, hu‚ÇÇ x x.2‚ü©\n#align const_add const_add\n\n",
 "comap_id_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/-- For an inclusion `i : V ‚ü∂ U` between open sets of the prime spectrum of `R`, the comap of the\nidentity from OO_X(U) to OO_X(V) equals as the restriction map of the structure sheaf.\n\nThis is a generalization of the fact that, for fixed `U`, the comap of the identity from OO_X(U)\nto OO_X(U) is the identity.\n-/\ntheorem comap_id_eq_map (U V : Opens (prime_spectrum.Top R)) (iVU : ¬´expr ‚ü∂ ¬ª V U) :\n    (comap (RingHom.id R) U V fun p hpV => leOfHom iVU <| by rwa [prime_spectrum.comap_id]) =\n      (structure_sheaf R).1.map iVU.op :=\n  RingHom.ext fun s =>\n    Subtype.eq <|\n      funext fun p => by\n        rw [comap_apply]\n        -- Unfortunately, we cannot use `localization.local_ring_hom_id` here, because\n        -- `prime_spectrum.comap (ring_hom.id R) p` is not *definitionally* equal to `p`. Instead, we use\n        -- that we can write `s` as a fraction `a/b` in a small neighborhood around `p`. Since\n        -- `prime_spectrum.comap (ring_hom.id R) p` equals `p`, it is also contained in the same\n        -- neighborhood, hence `s` equals `a/b` there too.\n        obtain ‚ü®W, hpW, iWU, h‚ü© := s.2 (iVU p)\n        obtain ‚ü®a, b, h'‚ü© := h.eq_mk'\n        obtain ‚ü®hb‚ÇÅ, s_eq‚ÇÅ‚ü© := h' ‚ü®p, hpW‚ü©\n        obtain ‚ü®hb‚ÇÇ, s_eq‚ÇÇ‚ü© := h' ‚ü®prime_spectrum.comap (RingHom.id _) p.1, by rwa [prime_spectrum.comap_id]‚ü©\n        dsimp only at s_eq‚ÇÅ s_eq‚ÇÇ\n        erw [s_eq‚ÇÇ, localization.local_ring_hom_mk', ‚Üê s_eq‚ÇÅ, ‚Üê res_apply]\n#align comap_id_eq_map comap_id_eq_map\n\n",
 "comap_id'":
 "@[simp]\ntheorem comap_id' (U : Opens (prime_spectrum.Top R)) :\n    (comap (RingHom.id R) U U fun p hpU => by rwa [prime_spectrum.comap_id]) = RingHom.id _ :=\n  by\n  rw [comap_id U U rfl]\n  rfl\n#align comap_id' comap_id'\n\n",
 "comap_id":
 "/-- The comap of the identity is the identity. In this variant of the lemma, two open subsets `U` and\n`V` are given as arguments, together with a proof that `U = V`. This is be useful when `U` and `V`\nare not definitionally equal.\n-/\ntheorem comap_id (U V : Opens (prime_spectrum.Top R)) (hUV : U = V) :\n    (comap (RingHom.id R) U V fun p hpV => by rwa [hUV, prime_spectrum.comap_id]) =\n      eqToHom (show (structure_sheaf R).1.obj (op U) = _ by rw [hUV]) :=\n  by erw [comap_id_eq_map U V (eq_to_hom hUV.symm), eq_to_hom_op, eq_to_hom_map]\n#align comap_id comap_id\n\n",
 "comap_fun_is_locally_fraction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Üí+* ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\ntheorem comap_fun_is_locally_fraction (f : ¬´expr ‚Üí+* ¬ª R S) (U : Opens (prime_spectrum.Top R))\n    (V : Opens (prime_spectrum.Top S)) (hUV : V.1 ‚äÜ ¬´expr ‚Åª¬π' ¬ª (prime_spectrum.comap f) U.1)\n    (s : ‚àÄ x : U, localizations R x) (hs : (is_locally_fraction R).to_prelocal_predicate.pred s) :\n    (is_locally_fraction S).to_prelocal_predicate.pred (comap_fun f U V hUV s) :=\n  by\n  rintro ‚ü®p, hpV‚ü©\n  -- Since `s` is locally fraction, we can find a neighborhood `W` of `prime_spectrum.comap f p`\n  -- in `U`, such that `s = a / b` on `W`, for some ring elements `a, b : R`.\n  rcases hs ‚ü®prime_spectrum.comap f p, hUV hpV‚ü© with ‚ü®W, m, iWU, a, b, h_frac‚ü©\n  -- We claim that we can write our new section as the fraction `f a / f b` on the neighborhood\n  -- `(comap f) ‚Åª¬π W ‚äì V` of `p`.\n  refine' ‚ü®¬´expr ‚äì ¬ª (opens.comap (comap f) W) V, ‚ü®m, hpV‚ü©, opens.inf_le_right _ _, f a, f b, _‚ü©\n  rintro ‚ü®q, ‚ü®hqW, hqV‚ü©‚ü©\n  specialize h_frac ‚ü®prime_spectrum.comap f q, hqW‚ü©\n  refine' ‚ü®h_frac.1, _‚ü©\n  dsimp only [comap_fun]\n  erw [‚Üê localization.local_ring_hom_to_map (prime_spectrum.comap f q).as_ideal, ‚Üê RingHom.map_mul, h_frac.2,\n    localization.local_ring_hom_to_map]\n  rfl\n#align comap_fun_is_locally_fraction comap_fun_is_locally_fraction\n\n",
 "comap_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Üí+* ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\ntheorem comap_const (f : ¬´expr ‚Üí+* ¬ª R S) (U : Opens (prime_spectrum.Top R)) (V : Opens (prime_spectrum.Top S))\n    (hUV : V.1 ‚äÜ ¬´expr ‚Åª¬π' ¬ª (prime_spectrum.comap f) U.1) (a b : R)\n    (hb : ‚àÄ x : prime_spectrum R, x ‚àà U ‚Üí b ‚àà x.as_ideal.prime_compl) :\n    comap f U V hUV (const R a b U hb) = const S (f a) (f b) V fun p hpV => hb (prime_spectrum.comap f p) (hUV hpV) :=\n  Subtype.eq <|\n    funext fun p => by\n      rw [comap_apply, const_apply, const_apply]\n      erw [localization.local_ring_hom_mk']\n      rfl\n#align comap_const comap_const\n\n",
 "comap_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Üí+* ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Üí+* ¬ª -/\ntheorem comap_comp (f : ¬´expr ‚Üí+* ¬ª R S) (g : ¬´expr ‚Üí+* ¬ª S P) (U : Opens (prime_spectrum.Top R))\n    (V : Opens (prime_spectrum.Top S)) (W : Opens (prime_spectrum.Top P)) (hUV : ‚àÄ p ‚àà V, prime_spectrum.comap f p ‚àà U)\n    (hVW : ‚àÄ p ‚àà W, prime_spectrum.comap g p ‚àà V) :\n    (comap (g.comp f) U W fun p hpW => hUV (prime_spectrum.comap g p) (hVW p hpW)) =\n      (comap g V W hVW).comp (comap f U V hUV) :=\n  RingHom.ext fun s =>\n    Subtype.eq <|\n      funext fun p => by\n        rw [comap_apply]\n        erw [localization.local_ring_hom_comp _ (prime_spectrum.comap g p.1).as_ideal]\n        -- refl works here, because `prime_spectrum.comap (g.comp f) p` is defeq to\n        -- `prime_spectrum.comap f (prime_spectrum.comap g p)`\n        rfl\n#align comap_comp comap_comp\n\n",
 "comap_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Üí+* ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n@[simp]\ntheorem comap_apply (f : ¬´expr ‚Üí+* ¬ª R S) (U : Opens (prime_spectrum.Top R)) (V : Opens (prime_spectrum.Top S))\n    (hUV : V.1 ‚äÜ ¬´expr ‚Åª¬π' ¬ª (prime_spectrum.comap f) U.1) (s : (structure_sheaf R).1.obj (op U)) (p : V) :\n    (comap f U V hUV s).1 p =\n      localization.local_ring_hom (prime_spectrum.comap f p.1).as_ideal _ f rfl\n        (s.1 ‚ü®prime_spectrum.comap f p.1, hUV p.2‚ü© : _) :=\n  rfl\n#align comap_apply comap_apply\n\n",
 "coe_open_to_localization":
 "@[simp]\ntheorem coe_open_to_localization (U : Opens (prime_spectrum.Top R)) (x : prime_spectrum.Top R) (hx : x ‚àà U) :\n    (open_to_localization R U x hx : (structure_sheaf R).1.obj (op U) ‚Üí localization.at_prime x.as_ideal) = fun s =>\n      (s.1 ‚ü®x, hx‚ü© : _) :=\n  rfl\n#align coe_open_to_localization coe_open_to_localization\n\n"}