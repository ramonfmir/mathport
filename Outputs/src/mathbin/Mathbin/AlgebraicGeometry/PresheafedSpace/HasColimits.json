{"map_id_c_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n@[simp]\ntheorem map_id_c_app (F : «expr ⥤ » J (PresheafedSpace.{v} C)) (j) (U) :\n    (F.map ((«expr𝟙») j)).c.app (op U) =\n      «expr ≫ » ((pushforward.id (F.obj j).presheaf).inv.app (op U))\n        ((pushforward_eq\n                (by\n                  simp\n                  rfl)\n                (F.obj j).presheaf).hom.app\n          (op U)) :=\n  by\n  cases U\n  dsimp\n  simp [PresheafedSpace.congr_app (F.map_id j)]\n  rfl\n#align map_id_c_app map_id_c_app\n\n",
 "map_comp_c_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem map_comp_c_app (F : «expr ⥤ » J (PresheafedSpace.{v} C)) {j₁ j₂ j₃} (f : «expr ⟶ » j₁ j₂) (g : «expr ⟶ » j₂ j₃)\n    (U) :\n    (F.map («expr ≫ » f g)).c.app (op U) =\n      «expr ≫ » ((F.map g).c.app (op U))\n        («expr ≫ » ((pushforward_map (F.map g).base (F.map f).c).app (op U))\n          («expr ≫ » ((pushforward.comp (F.obj j₁).presheaf (F.map f).base (F.map g).base).inv.app (op U))\n            ((pushforward_eq\n                    (by\n                      rw [F.map_comp]\n                      rfl)\n                    _).hom.app\n              _))) :=\n  by\n  cases U\n  dsimp\n  simp only [PresheafedSpace.congr_app (F.map_comp f g)]\n  dsimp; simp; dsimp; simp\n#align map_comp_c_app map_comp_c_app\n\n",
 "desc_fac":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem desc_fac (F : «expr ⥤ » J (PresheafedSpace.{v} C)) (s : cocone F) (j : J) :\n    «expr ≫ » ((colimit_cocone F).ι.app j) (desc F s) = s.ι.app j :=\n  by\n  fapply PresheafedSpace.ext\n  · simp [desc]\n  · ext\n    dsimp [desc, desc_c_app]\n    simpa\n#align desc_fac desc_fac\n\n",
 "desc_c_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n-- We still need to construct the `app` and `naturality'` fields omitted above.\ntheorem desc_c_naturality (F : «expr ⥤ » J (PresheafedSpace.{v} C)) (s : cocone F)\n    {U V : «expr ᵒᵖ» (opens («expr↥ » s.X.carrier))} (i : «expr ⟶ » U V) :\n    «expr ≫ » (s.X.presheaf.map i) (desc_c_app F s V) =\n      «expr ≫ » (desc_c_app F s U)\n        ((«expr _* » (colimit.desc («expr ⋙ » F (forget C)) ((forget C).map_cocone s))\n              (colimit_cocone F).X.presheaf).map\n          i) :=\n  by\n  dsimp [desc_c_app]\n  ext\n  simp only [limit.lift_π, nat_trans.naturality, limit.lift_π_assoc, eq_to_hom_map, assoc, pushforward_obj_map,\n    nat_trans.naturality_assoc, op_map, limit_obj_iso_limit_comp_evaluation_inv_π_app_assoc,\n    limit_obj_iso_limit_comp_evaluation_inv_π_app]\n  dsimp\n  have w :=\n    functor.congr_hom (congr_arg opens.map (colimit.ι_desc ((PresheafedSpace.forget C).map_cocone s) (unop j))) i.unop\n  simp only [opens.map_comp_map] at w\n  replace w := congr_arg Quiver.Hom.op w\n  rw [w]\n  dsimp; simp\n#align desc_c_naturality desc_c_naturality\n\n",
 "colimit_presheaf_obj_iso_componentwise_limit_inv_ι_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- We need to use the identity on the continuous maps twice, so we prepare that first:\n-- could `ext` please not reorder goals?\n@[simp]\ntheorem colimit_presheaf_obj_iso_componentwise_limit_inv_ι_app (F : «expr ⥤ » J (PresheafedSpace.{v} C))\n    (U : opens (limits.colimit F).carrier) (j : J) :\n    «expr ≫ » (colimit_presheaf_obj_iso_componentwise_limit F U).inv ((colimit.ι F j).c.app (op U)) =\n      limit.π _ (op j) :=\n  by\n  delta colimit_presheaf_obj_iso_componentwise_limit\n  rw [iso.trans_inv, iso.trans_inv, iso.app_inv, sheaf_iso_of_iso_inv, pushforward_to_of_iso_app,\n    congr_app (iso.symm_inv _)]\n  simp_rw [category.assoc]\n  rw [← functor.map_comp_assoc, nat_trans.naturality]\n  erw [← comp_c_app_assoc]\n  rw [congr_app (colimit.iso_colimit_cocone_ι_hom _ _)]\n  simp_rw [category.assoc]\n  erw [limit_obj_iso_limit_comp_evaluation_inv_π_app_assoc, lim_map_π_assoc]\n  convert category.comp_id _\n  erw [← (F.obj j).presheaf.map_id]\n  iterate 2 erw [← (F.obj j).presheaf.map_comp]\n  congr\n#align colimit_presheaf_obj_iso_componentwise_limit_inv_ι_app colimit_presheaf_obj_iso_componentwise_limit_inv_ι_app\n\n",
 "colimit_presheaf_obj_iso_componentwise_limit_hom_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem colimit_presheaf_obj_iso_componentwise_limit_hom_π (F : «expr ⥤ » J (PresheafedSpace.{v} C))\n    (U : opens (limits.colimit F).carrier) (j : J) :\n    «expr ≫ » (colimit_presheaf_obj_iso_componentwise_limit F U).hom (limit.π _ (op j)) =\n      (colimit.ι F j).c.app (op U) :=\n  by rw [← iso.eq_inv_comp, colimit_presheaf_obj_iso_componentwise_limit_inv_ι_app]\n#align colimit_presheaf_obj_iso_componentwise_limit_hom_π colimit_presheaf_obj_iso_componentwise_limit_hom_π\n\n",
 "colimit_presheaf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n@[simp]\ntheorem colimit_presheaf (F : «expr ⥤ » J (PresheafedSpace.{v} C)) :\n    (colimit F).presheaf = limit (pushforward_diagram_to_colimit F).left_op :=\n  rfl\n#align colimit_presheaf colimit_presheaf\n\n",
 "colimit_carrier":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n-- See note [dsimp, simp]\n-- The key fact is `(F.map f).c.congr`,\n-- which allows us in rewrite in the argument of `(F.map f).c.app`.\n-- Now we pick up the pieces. First, we say what we want to replace that open set by:\n-- Now we show the open sets are equal.\n-- Finally, the original goal is now easy:\n@[simp]\ntheorem colimit_carrier (F : «expr ⥤ » J (PresheafedSpace.{v} C)) :\n    (colimit F).carrier = limits.colimit («expr ⋙ » F (PresheafedSpace.forget C)) :=\n  rfl\n#align colimit_carrier colimit_carrier\n\n"}