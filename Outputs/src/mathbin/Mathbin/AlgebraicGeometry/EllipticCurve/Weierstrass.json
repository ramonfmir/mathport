{"variable_change_Δ":
 "@[simp]\ntheorem variable_change_Δ : (W.variable_change u r s t).Δ = ↑u⁻¹ ^ 12 * W.Δ :=\n  by\n  dsimp\n  ring1\n#align variable_change_Δ variable_change_Δ\n\n",
 "variable_change_j":
 "@[simp]\ntheorem variable_change_j : (E.variable_change u r s t).j = E.j :=\n  by\n  rw [j, coe_inv_variable_change_Δ']\n  have hu : (u * ↑u⁻¹ : R) ^ 12 = 1 := by rw [u.mul_inv, one_pow]\n  linear_combination (norm := (dsimp; ring1)) E.j * hu\n#align variable_change_j variable_change_j\n\n",
 "variable_change_c₆":
 "@[simp]\ntheorem variable_change_c₆ : (W.variable_change u r s t).c₆ = ↑u⁻¹ ^ 6 * W.c₆ :=\n  by\n  simp only [c₆, variable_change_b₂, variable_change_b₄, variable_change_b₆]\n  ring1\n#align variable_change_c₆ variable_change_c₆\n\n",
 "variable_change_c₄":
 "@[simp]\ntheorem variable_change_c₄ : (W.variable_change u r s t).c₄ = ↑u⁻¹ ^ 4 * W.c₄ :=\n  by\n  simp only [c₄, variable_change_b₂, variable_change_b₄]\n  ring1\n#align variable_change_c₄ variable_change_c₄\n\n",
 "variable_change_b₈":
 "@[simp]\ntheorem variable_change_b₈ :\n    (W.variable_change u r s t).b₈ = ↑u⁻¹ ^ 8 * (W.b₈ + 3 * r * W.b₆ + 3 * r ^ 2 * W.b₄ + r ^ 3 * W.b₂ + 3 * r ^ 4) :=\n  by\n  simp only [b₂, b₄, b₆, b₈, variable_change_a₁, variable_change_a₂, variable_change_a₃, variable_change_a₄,\n    variable_change_a₆]\n  ring1\n#align variable_change_b₈ variable_change_b₈\n\n",
 "variable_change_b₆":
 "@[simp]\ntheorem variable_change_b₆ :\n    (W.variable_change u r s t).b₆ = ↑u⁻¹ ^ 6 * (W.b₆ + 2 * r * W.b₄ + r ^ 2 * W.b₂ + 4 * r ^ 3) :=\n  by\n  simp only [b₂, b₄, b₆, variable_change_a₃, variable_change_a₆]\n  ring1\n#align variable_change_b₆ variable_change_b₆\n\n",
 "variable_change_b₄":
 "@[simp]\ntheorem variable_change_b₄ : (W.variable_change u r s t).b₄ = ↑u⁻¹ ^ 4 * (W.b₄ + r * W.b₂ + 6 * r ^ 2) :=\n  by\n  simp only [b₂, b₄, variable_change_a₁, variable_change_a₃, variable_change_a₄]\n  ring1\n#align variable_change_b₄ variable_change_b₄\n\n",
 "variable_change_b₂":
 "@[simp]\ntheorem variable_change_b₂ : (W.variable_change u r s t).b₂ = ↑u⁻¹ ^ 2 * (W.b₂ + 12 * r) :=\n  by\n  simp only [b₂, variable_change_a₁, variable_change_a₂]\n  ring1\n#align variable_change_b₂ variable_change_b₂\n\n",
 "two_torsion_polynomial_disc_ne_zero":
 "theorem two_torsion_polynomial_disc_ne_zero [Nontrivial R] [Invertible (2 : R)] : E.two_torsion_polynomial.disc ≠ 0 :=\n  E.two_torsion_polynomial_disc_ne_zero <| E.coe_Δ' ▸ E.Δ'.is_unit\n#align two_torsion_polynomial_disc_ne_zero two_torsion_polynomial_disc_ne_zero\n\n",
 "two_torsion_polynomial_disc_is_unit":
 "theorem two_torsion_polynomial_disc_is_unit [Invertible (2 : R)] : IsUnit W.two_torsion_polynomial.disc ↔ IsUnit W.Δ :=\n  by\n  rw [two_torsion_polynomial_disc, IsUnit.mul_iff, show (16 : R) = 2 ^ 4 by norm_num1]\n  exact and_iff_right (isUnit_of_invertible <| 2 ^ 4)\n#align two_torsion_polynomial_disc_is_unit two_torsion_polynomial_disc_is_unit\n\n",
 "two_torsion_polynomial_disc":
 "theorem two_torsion_polynomial_disc : W.two_torsion_polynomial.disc = 16 * W.Δ :=\n  by\n  dsimp [two_torsion_polynomial, Cubic.disc]\n  ring1\n#align two_torsion_polynomial_disc two_torsion_polynomial_disc\n\n",
 "smul_basis_mul_Y":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `outer_variable -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `outer_variable -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `outer_variable -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `outer_variable -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `outer_variable -/\ntheorem smul_basis_mul_Y (p q : polynomial R) :\n    («expr • » p 1 + «expr • » q (adjoin_root.mk W.polynomial (outer_variable))) *\n        adjoin_root.mk W.polynomial (outer_variable) =\n      «expr • » (q * (X ^ 3 + C W.a₂ * X ^ 2 + C W.a₄ * X + C W.a₆)) 1 +\n        «expr • » (p - q * (C W.a₁ * X + C W.a₃)) (adjoin_root.mk W.polynomial (outer_variable)) :=\n  by\n  have Y_sq :\n    adjoin_root.mk W.polynomial (outer_variable) ^ 2 =\n      adjoin_root.mk W.polynomial\n        (C (X ^ 3 + C W.a₂ * X ^ 2 + C W.a₄ * X + C W.a₆) - C (C W.a₁ * X + C W.a₃) * outer_variable) :=\n    adjoin_root.mk_eq_mk.mpr\n      ⟨1, by\n        simp only [weierstrass_curve.polynomial]\n        ring1⟩\n  simp only [smul, add_mul, mul_assoc, ← sq, Y_sq, map_sub, map_mul]\n  ring1\n#align smul_basis_mul_Y smul_basis_mul_Y\n\n",
 "smul_basis_mul_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `outer_variable -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `outer_variable -/\ntheorem smul_basis_mul_C (p q : polynomial R) :\n    («expr • » p 1 + «expr • » q (adjoin_root.mk W.polynomial (outer_variable))) * adjoin_root.mk W.polynomial (C y) =\n      «expr • » (p * y) 1 + «expr • » (q * y) (adjoin_root.mk W.polynomial (outer_variable)) :=\n  by\n  simp only [smul, map_mul]\n  ring1\n#align smul_basis_mul_C smul_basis_mul_C\n\n",
 "smul_basis_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `outer_variable -/\ntheorem smul_basis_eq_zero {p q : polynomial R}\n    (hpq : «expr • » p 1 + «expr • » q (adjoin_root.mk W.polynomial (outer_variable)) = 0) : p = 0 ∧ q = 0 :=\n  by\n  have h :=\n    fintype.linear_independent_iff.mp (coordinate_ring.basis W).linear_independent\n      («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\")\n  erw [Fin.sum_univ_succ, basis_zero, Fin.sum_univ_one, basis_one] at h\n  exact ⟨h hpq 0, h hpq 1⟩\n#align smul_basis_eq_zero smul_basis_eq_zero\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul (x : polynomial R) (y : W.coordinate_ring) : «expr • » x y = adjoin_root.mk W.polynomial (C x) * y :=\n  (algebraMap_smul W.coordinate_ring x y).symm\n#align smul smul\n\n",
 "polynomial_ne_zero":
 "theorem polynomial_ne_zero [Nontrivial R] : W.polynomial ≠ 0 :=\n  by\n  rw [polynomial_eq]\n  exact Cubic.ne_zero_of_b_ne_zero one_ne_zero\n#align polynomial_ne_zero polynomial_ne_zero\n\n",
 "polynomial_eq":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.3948480697.C_simp -/\ntheorem polynomial_eq :\n    W.polynomial = Cubic.toPoly ⟨0, 1, Cubic.toPoly ⟨0, 0, W.a₁, W.a₃⟩, Cubic.toPoly ⟨-1, -W.a₂, -W.a₄, -W.a₆⟩⟩ :=\n  by\n  simp only [weierstrass_curve.polynomial, Cubic.toPoly]\n  run_tac\n    C_simp\n  ring1\n#align polynomial_eq polynomial_eq\n\n",
 "norm_smul_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `outer_variable -/\ntheorem norm_smul_basis (p q : polynomial R) :\n    algebra.norm (polynomial R) («expr • » p 1 + «expr • » q (adjoin_root.mk W.polynomial (outer_variable))) =\n      p ^ 2 - p * q * (C W.a₁ * X + C W.a₃) - q ^ 2 * (X ^ 3 + C W.a₂ * X ^ 2 + C W.a₄ * X + C W.a₆) :=\n  by\n  simp_rw [algebra.norm_eq_matrix_det W.coordinate_ring.basis, Matrix.det_fin_two, Algebra.leftMulMatrix_eq_repr_mul,\n    basis_zero, mul_one, basis_one, smul_basis_mul_Y, map_add, Finsupp.add_apply, map_smul, Finsupp.smul_apply, ←\n    basis_zero, ← basis_one, Basis.repr_self_apply, if_pos, if_neg one_ne_zero, if_neg zero_ne_one, smul_eq_mul]\n  ring1\n#align norm_smul_basis norm_smul_basis\n\n",
 "nonsingular_zero_of_Δ_ne_zero":
 "theorem nonsingular_zero_of_Δ_ne_zero (h : W.equation 0 0) (hΔ : W.Δ ≠ 0) : W.nonsingular 0 0 :=\n  by\n  simp only [equation_zero, nonsingular_zero] at *\n  contrapose! hΔ\n  simp [h, hΔ]\n#align nonsingular_zero_of_Δ_ne_zero nonsingular_zero_of_Δ_ne_zero\n\n",
 "nonsingular_zero":
 "@[simp]\ntheorem nonsingular_zero : W.nonsingular 0 0 ↔ W.a₆ = 0 ∧ (W.a₃ ≠ 0 ∨ W.a₄ ≠ 0) := by\n  rw [nonsingular, equation_zero, C_0, eval_polynomial_X_zero, neg_ne_zero, eval_polynomial_Y_zero, or_comm']\n#align nonsingular_zero nonsingular_zero\n\n",
 "nonsingular_of_Δ_ne_zero":
 "/-- A Weierstrass curve is nonsingular at every point if its discriminant is non-zero. -/\ntheorem nonsingular_of_Δ_ne_zero {x y : R} (h : W.equation x y) (hΔ : W.Δ ≠ 0) : W.nonsingular x y :=\n  (W.nonsingular_iff_variable_change x y).mpr <|\n    nonsingular_zero_of_Δ_ne_zero _ ((W.equation_iff_variable_change x y).mp h) <| by\n      rwa [variable_change_Δ, inv_one, Units.val_one, one_pow, one_mul]\n#align nonsingular_of_Δ_ne_zero nonsingular_of_Δ_ne_zero\n\n",
 "nonsingular_iff_variable_change":
 "theorem nonsingular_iff_variable_change (x y : R) : W.nonsingular x y ↔ (W.variable_change 1 x 0 y).nonsingular 0 0 :=\n  by\n  rw [nonsingular_iff', equation_iff_variable_change, equation_zero, ← neg_ne_zero, or_comm', nonsingular_zero,\n    variable_change_a₃, variable_change_a₄, inv_one, Units.val_one]\n  congr 4 <;> ring1\n#align nonsingular_iff_variable_change nonsingular_iff_variable_change\n\n",
 "nonsingular_iff_base_change_of_base_change":
 "theorem nonsingular_iff_base_change_of_base_change [Nontrivial B] [NoZeroSMulDivisors A B] (x y : A) :\n    (W.base_change A).nonsingular x y ↔ (W.base_change B).nonsingular (algebraMap A B x) (algebraMap A B y) := by\n  rw [nonsingular_iff_base_change (W.base_change A) B, base_change_base_change]\n#align nonsingular_iff_base_change_of_base_change nonsingular_iff_base_change_of_base_change\n\n",
 "nonsingular_iff_base_change":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.2242074953.map_simp -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.2242074953.map_simp -/\ntheorem nonsingular_iff_base_change [Nontrivial A] [NoZeroSMulDivisors R A] (x y : R) :\n    W.nonsingular x y ↔ (W.base_change A).nonsingular (algebraMap R A x) (algebraMap R A y) :=\n  by\n  rw [nonsingular_iff, nonsingular_iff, and_congr <| W.equation_iff_base_change A x y]\n  refine'\n    ⟨Or.imp (not_imp_not.mpr fun h => _) (not_imp_not.mpr fun h => _),\n      Or.imp (not_imp_not.mpr fun h => _) (not_imp_not.mpr fun h => _)⟩\n  any_goals apply NoZeroSMulDivisors.algebraMap_injective R A;\n    run_tac\n      map_simp;\n    exact h\n  any_goals\n    convert congr_arg (algebraMap R A) h <;>\n      · run_tac\n          map_simp\n        rfl\n#align nonsingular_iff_base_change nonsingular_iff_base_change\n\n",
 "nonsingular_iff'":
 "theorem nonsingular_iff' (x y : R) :\n    W.nonsingular x y ↔\n      W.equation x y ∧ (W.a₁ * y - (3 * x ^ 2 + 2 * W.a₂ * x + W.a₄) ≠ 0 ∨ 2 * y + W.a₁ * x + W.a₃ ≠ 0) :=\n  by rw [nonsingular, equation_iff', eval_polynomial_X, eval_polynomial_Y]\n#align nonsingular_iff' nonsingular_iff'\n\n",
 "nonsingular_iff":
 "@[simp]\ntheorem nonsingular_iff (x y : R) :\n    W.nonsingular x y ↔ W.equation x y ∧ (W.a₁ * y ≠ 3 * x ^ 2 + 2 * W.a₂ * x + W.a₄ ∨ y ≠ -y - W.a₁ * x - W.a₃) :=\n  by\n  rw [nonsingular_iff', sub_ne_zero, ← @sub_ne_zero _ _ y]\n  congr 4 <;> ring1\n#align nonsingular_iff nonsingular_iff\n\n",
 "nonsingular":
 "theorem nonsingular [Nontrivial R] {x y : R} (h : E.equation x y) : E.nonsingular x y :=\n  E.nonsingular_of_Δ_ne_zero h <| E.coe_Δ' ▸ E.Δ'.ne_zero\n#align nonsingular nonsingular\n\n",
 "nat_degree_polynomial":
 "@[simp]\ntheorem nat_degree_polynomial [Nontrivial R] : W.polynomial.nat_degree = 2 :=\n  by\n  rw [polynomial_eq]\n  exact Cubic.natDegree_of_b_ne_zero' one_ne_zero\n#align nat_degree_polynomial nat_degree_polynomial\n\n",
 "nat_degree_norm_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_norm_ne_one [IsDomain R] (x : W.coordinate_ring) : (algebra.norm (polynomial R) x).nat_degree ≠ 1 :=\n  mt (degree_eq_iff_natDegree_eq_of_pos zero_lt_one).mpr <| degree_norm_ne_one x\n#align nat_degree_norm_ne_one nat_degree_norm_ne_one\n\n",
 "monic_polynomial":
 "theorem monic_polynomial : W.polynomial.monic := by\n  nontriviality R\n  simpa only [polynomial_eq] using Cubic.monic_of_b_eq_one'\n#align monic_polynomial monic_polynomial\n\n",
 "irreducible_polynomial":
 "theorem irreducible_polynomial [IsDomain R] : Irreducible W.polynomial :=\n  by\n  by_contra h\n  rcases(W.monic_polynomial.not_irreducible_iff_exists_add_mul_eq_coeff W.nat_degree_polynomial).mp h with\n    ⟨f, g, h0, h1⟩\n  simp only [polynomial_eq, Cubic.coeff_eq_c, Cubic.coeff_eq_d] at h0 h1\n  apply_fun degree  at h0 h1\n  rw [Cubic.degree_of_a_ne_zero' <| neg_ne_zero.mpr <| one_ne_zero' R, degree_mul] at h0\n  apply (h1.symm.le.trans Cubic.degree_of_b_eq_zero').not_lt\n  rcases nat.with_bot.add_eq_three_iff.mp h0.symm with (h | h | h | h)\n  any_goals rw [degree_add_eq_left_of_degree_lt] <;> simp only [h] <;> decide\n  any_goals rw [degree_add_eq_right_of_degree_lt] <;> simp only [h] <;> decide\n#align irreducible_polynomial irreducible_polynomial\n\n",
 "exists_smul_basis_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `outer_variable -/\ntheorem exists_smul_basis_eq (x : W.coordinate_ring) :\n    ∃ p q : polynomial R, «expr • » p 1 + «expr • » q (adjoin_root.mk W.polynomial (outer_variable)) = x :=\n  by\n  have h := (coordinate_ring.basis W).sum_equiv_fun x\n  erw [Fin.sum_univ_succ, Fin.sum_univ_one, basis_zero, basis_one] at h\n  exact ⟨_, _, h⟩\n#align exists_smul_basis_eq exists_smul_basis_eq\n\n",
 "eval_polynomial_zero":
 "@[simp]\ntheorem eval_polynomial_zero : (W.polynomial.eval 0).eval 0 = -W.a₆ := by\n  simp only [← C_0, eval_polynomial, zero_add, zero_sub, MulZeroClass.mul_zero, zero_pow (nat.zero_lt_succ _)]\n#align eval_polynomial_zero eval_polynomial_zero\n\n",
 "eval_polynomial_Y_zero":
 "@[simp]\ntheorem eval_polynomial_Y_zero : (W.polynomial_Y.eval 0).eval 0 = W.a₃ := by\n  simp only [← C_0, eval_polynomial_Y, zero_add, MulZeroClass.mul_zero]\n#align eval_polynomial_Y_zero eval_polynomial_Y_zero\n\n",
 "eval_polynomial_Y":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.2480101633.eval_simp -/\n@[simp]\ntheorem eval_polynomial_Y (x y : R) : (W.polynomial_Y.eval <| C y).eval x = 2 * y + W.a₁ * x + W.a₃ :=\n  by\n  simp only [polynomial_Y]\n  run_tac\n    eval_simp\n  rw [← add_assoc]\n#align eval_polynomial_Y eval_polynomial_Y\n\n",
 "eval_polynomial_X_zero":
 "@[simp]\ntheorem eval_polynomial_X_zero : (W.polynomial_X.eval 0).eval 0 = -W.a₄ := by\n  simp only [← C_0, eval_polynomial_X, zero_add, zero_sub, MulZeroClass.mul_zero, zero_pow zero_lt_two]\n#align eval_polynomial_X_zero eval_polynomial_X_zero\n\n",
 "eval_polynomial_X":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.2480101633.eval_simp -/\n@[simp]\ntheorem eval_polynomial_X (x y : R) :\n    (W.polynomial_X.eval <| C y).eval x = W.a₁ * y - (3 * x ^ 2 + 2 * W.a₂ * x + W.a₄) :=\n  by\n  simp only [polynomial_X]\n  run_tac\n    eval_simp\n#align eval_polynomial_X eval_polynomial_X\n\n",
 "eval_polynomial":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.2480101633.eval_simp -/\n@[simp]\ntheorem eval_polynomial (x y : R) :\n    (W.polynomial.eval <| C y).eval x = y ^ 2 + W.a₁ * x * y + W.a₃ * y - (x ^ 3 + W.a₂ * x ^ 2 + W.a₄ * x + W.a₆) :=\n  by\n  simp only [weierstrass_curve.polynomial]\n  run_tac\n    eval_simp\n  rw [add_mul, ← add_assoc]\n#align eval_polynomial eval_polynomial\n\n",
 "equation_zero":
 "@[simp]\ntheorem equation_zero : W.equation 0 0 ↔ W.a₆ = 0 := by rw [equation, C_0, eval_polynomial_zero, neg_eq_zero]\n#align equation_zero equation_zero\n\n",
 "equation_iff_variable_change":
 "theorem equation_iff_variable_change (x y : R) : W.equation x y ↔ (W.variable_change 1 x 0 y).equation 0 0 :=\n  by\n  rw [equation_iff', ← neg_eq_zero, equation_zero, variable_change_a₆, inv_one, Units.val_one]\n  congr 2\n  ring1\n#align equation_iff_variable_change equation_iff_variable_change\n\n",
 "equation_iff_base_change_of_base_change":
 "theorem equation_iff_base_change_of_base_change [Nontrivial B] [NoZeroSMulDivisors A B] (x y : A) :\n    (W.base_change A).equation x y ↔ (W.base_change B).equation (algebraMap A B x) (algebraMap A B y) := by\n  rw [equation_iff_base_change (W.base_change A) B, base_change_base_change]\n#align equation_iff_base_change_of_base_change equation_iff_base_change_of_base_change\n\n",
 "equation_iff_base_change":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.2242074953.map_simp -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.2242074953.map_simp -/\ntheorem equation_iff_base_change [Nontrivial A] [NoZeroSMulDivisors R A] (x y : R) :\n    W.equation x y ↔ (W.base_change A).equation (algebraMap R A x) (algebraMap R A y) :=\n  by\n  simp only [equation_iff]\n  refine' ⟨fun h => _, fun h => _⟩\n  ·\n    convert congr_arg (algebraMap R A) h <;>\n      · run_tac\n          map_simp\n        rfl\n  · apply NoZeroSMulDivisors.algebraMap_injective R A\n    run_tac\n      map_simp\n    exact h\n#align equation_iff_base_change equation_iff_base_change\n\n",
 "equation_iff'":
 "theorem equation_iff' (x y : R) :\n    W.equation x y ↔ y ^ 2 + W.a₁ * x * y + W.a₃ * y - (x ^ 3 + W.a₂ * x ^ 2 + W.a₄ * x + W.a₆) = 0 := by\n  rw [equation, eval_polynomial]\n#align equation_iff' equation_iff'\n\n",
 "equation_iff":
 "@[simp]\ntheorem equation_iff (x y : R) :\n    W.equation x y ↔ y ^ 2 + W.a₁ * x * y + W.a₃ * y = x ^ 3 + W.a₂ * x ^ 2 + W.a₄ * x + W.a₆ := by\n  rw [equation_iff', sub_eq_zero]\n#align equation_iff equation_iff\n\n",
 "degree_polynomial":
 "@[simp]\ntheorem degree_polynomial [Nontrivial R] : W.polynomial.degree = 2 :=\n  by\n  rw [polynomial_eq]\n  exact Cubic.degree_of_b_ne_zero' one_ne_zero\n#align degree_polynomial degree_polynomial\n\n",
 "degree_norm_smul_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `outer_variable -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem degree_norm_smul_basis [IsDomain R] (p q : polynomial R) :\n    (algebra.norm (polynomial R) <| «expr • » p 1 + «expr • » q (adjoin_root.mk W.polynomial (outer_variable))).degree =\n      max («expr • » 2 p.degree) («expr • » 2 q.degree + 3) :=\n  by\n  have hdp : (p ^ 2).degree = «expr • » 2 p.degree := degree_pow p 2\n  have hdpq : (p * q * (C W.a₁ * X + C W.a₃)).degree ≤ p.degree + q.degree + 1 := by\n    simpa only [degree_mul] using add_le_add_left degree_linear_le (p.degree + q.degree)\n  have hdq : (q ^ 2 * (X ^ 3 + C W.a₂ * X ^ 2 + C W.a₄ * X + C W.a₆)).degree = «expr • » 2 q.degree + 3 := by\n    rw [degree_mul, degree_pow, ← one_mul <| X ^ 3, ← C_1, degree_cubic <| one_ne_zero' R]\n  rw [norm_smul_basis]\n  by_cases hp : p = 0\n  ·\n    simpa only [hp, hdq, neg_zero, zero_sub, MulZeroClass.zero_mul, zero_pow zero_lt_two, degree_neg] using\n      (max_bot_left _).symm\n  by_cases hq : q = 0\n  ·\n    simpa only [hq, hdp, sub_zero, MulZeroClass.zero_mul, MulZeroClass.mul_zero, zero_pow zero_lt_two] using\n      (max_bot_right _).symm\n  rw [← not_congr degree_eq_bot] at hp hq\n  cases' p.degree with dp\n  · exact (hp rfl).elim\n  cases' q.degree with dq\n  · exact (hq rfl).elim\n  cases' le_or_lt dp (dq + 1) with hpq hpq\n  ·\n    convert(degree_sub_eq_right_of_degree_lt <|\n                (degree_sub_le _ _).trans_lt <| max_lt_iff.mpr ⟨hdp.trans_lt _, hdpq.trans_lt _⟩).trans\n            (max_eq_right_of_lt _).symm <;>\n        rw [hdq] <;>\n      exact with_bot.coe_lt_coe.mpr (by linarith only [hpq])\n  · rw [sub_sub]\n    convert(degree_sub_eq_left_of_degree_lt <|\n                (degree_add_le _ _).trans_lt <| max_lt_iff.mpr ⟨hdpq.trans_lt _, hdq.trans_lt _⟩).trans\n            (max_eq_left_of_lt _).symm <;>\n        rw [hdp] <;>\n      exact with_bot.coe_lt_coe.mpr (by linarith only [hpq])\n#align degree_norm_smul_basis degree_norm_smul_basis\n\n",
 "degree_norm_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_norm_ne_one [IsDomain R] (x : W.coordinate_ring) : (algebra.norm (polynomial R) x).degree ≠ 1 :=\n  by\n  rcases exists_smul_basis_eq x with ⟨p, q, rfl⟩\n  rw [degree_norm_smul_basis]\n  rcases p.degree with (_ | _ | _ | _) <;> cases q.degree\n  any_goals rintro (_ | _)\n  exact (lt_max_of_lt_right (by decide)).ne'\n#align degree_norm_ne_one degree_norm_ne_one\n\n",
 "coe_variable_change_Δ'":
 "theorem coe_variable_change_Δ' : (↑(E.variable_change u r s t).Δ' : R) = ↑u⁻¹ ^ 12 * E.Δ' := by\n  rw [variable_change_Δ', Units.val_mul, Units.val_pow_eq_pow_val]\n#align coe_variable_change_Δ' coe_variable_change_Δ'\n\n",
 "coe_norm_smul_basis":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.3948480697.C_simp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `outer_variable -/\ntheorem coe_norm_smul_basis (p q : polynomial R) :\n    ↑(algebra.norm (polynomial R) <| «expr • » p 1 + «expr • » q (adjoin_root.mk W.polynomial (outer_variable))) =\n      adjoin_root.mk W.polynomial ((C p + C q * X) * (C p + C q * (-X - C (C W.a₁ * X + C W.a₃)))) :=\n  adjoin_root.mk_eq_mk.mpr\n    ⟨C q ^ 2, by\n      rw [norm_smul_basis, weierstrass_curve.polynomial]\n      run_tac\n        C_simp\n      ring1⟩\n#align coe_norm_smul_basis coe_norm_smul_basis\n\n",
 "coe_inv_variable_change_Δ'":
 "theorem coe_inv_variable_change_Δ' : (↑(E.variable_change u r s t).Δ'⁻¹ : R) = u ^ 12 * ↑E.Δ'⁻¹ := by\n  rw [variable_change_Δ', mul_inv, inv_pow, inv_inv, Units.val_mul, Units.val_pow_eq_pow_val]\n#align coe_inv_variable_change_Δ' coe_inv_variable_change_Δ'\n\n",
 "coe_inv_base_change_Δ'":
 "theorem coe_inv_base_change_Δ' : ↑(E.base_change A).Δ'⁻¹ = algebraMap R A ↑E.Δ'⁻¹ :=\n  rfl\n#align coe_inv_base_change_Δ' coe_inv_base_change_Δ'\n\n",
 "coe_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem coe_basis :\n    (W.coordinate_ring.basis : Fin 2 → W.coordinate_ring) =\n      «expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\" :=\n  by\n  ext n\n  fin_cases n\n  exacts[basis_zero W, basis_one W]\n#align coe_basis coe_basis\n\n",
 "coe_base_change_Δ'":
 "theorem coe_base_change_Δ' : ↑(E.base_change A).Δ' = algebraMap R A E.Δ' :=\n  rfl\n#align coe_base_change_Δ' coe_base_change_Δ'\n\n",
 "c_relation":
 "theorem c_relation : 1728 * W.Δ = W.c₄ ^ 3 - W.c₆ ^ 2 :=\n  by\n  simp only [b₂, b₄, b₆, b₈, c₄, c₆, Δ]\n  ring1\n#align c_relation c_relation\n\n",
 "basis_zero":
 "theorem basis_zero : W.coordinate_ring.basis 0 = 1 := by simpa only [basis_apply] using pow_zero _\n#align basis_zero basis_zero\n\n",
 "basis_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `outer_variable -/\ntheorem basis_one : W.coordinate_ring.basis 1 = adjoin_root.mk W.polynomial (outer_variable) := by\n  simpa only [basis_apply] using pow_one _\n#align basis_one basis_one\n\n",
 "basis_apply":
 "theorem basis_apply (n : Fin 2) :\n    W.coordinate_ring.basis n = (adjoin_root.power_basis' W.monic_polynomial).gen ^ (n : ℕ) := by\n  classical\n    nontriviality R\n    simpa only [coordinate_ring.basis, Or.by_cases, dif_neg (not_subsingleton R), Basis.reindex_apply,\n      power_basis.basis_eq_pow]\n#align basis_apply basis_apply\n\n",
 "base_change_Δ":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.2242074953.map_simp -/\n@[simp, nolint simp_nf]\ntheorem base_change_Δ : (W.base_change A).Δ = algebraMap R A W.Δ :=\n  by\n  simp only [Δ, base_change_b₂, base_change_b₄, base_change_b₆, base_change_b₈]\n  run_tac\n    map_simp\n#align base_change_Δ base_change_Δ\n\n",
 "base_change_self":
 "theorem base_change_self : W.base_change R = W := by ext <;> rfl\n#align base_change_self base_change_self\n\n",
 "base_change_j":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.2242074953.map_simp -/\n@[simp]\ntheorem base_change_j : (E.base_change A).j = algebraMap R A E.j :=\n  by\n  simp only [j, coe_inv_base_change_Δ', base_change_to_weierstrass_curve, E.base_change_c₄]\n  run_tac\n    map_simp\n#align base_change_j base_change_j\n\n",
 "base_change_c₆":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.2242074953.map_simp -/\n@[simp]\ntheorem base_change_c₆ : (W.base_change A).c₆ = algebraMap R A W.c₆ :=\n  by\n  simp only [c₆, base_change_b₂, base_change_b₄, base_change_b₆]\n  run_tac\n    map_simp\n#align base_change_c₆ base_change_c₆\n\n",
 "base_change_c₄":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.2242074953.map_simp -/\n@[simp]\ntheorem base_change_c₄ : (W.base_change A).c₄ = algebraMap R A W.c₄ :=\n  by\n  simp only [c₄, base_change_b₂, base_change_b₄]\n  run_tac\n    map_simp\n#align base_change_c₄ base_change_c₄\n\n",
 "base_change_b₈":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.2242074953.map_simp -/\n@[simp]\ntheorem base_change_b₈ : (W.base_change A).b₈ = algebraMap R A W.b₈ :=\n  by\n  simp only [b₈, base_change_a₁, base_change_a₂, base_change_a₃, base_change_a₄, base_change_a₆]\n  run_tac\n    map_simp\n#align base_change_b₈ base_change_b₈\n\n",
 "base_change_b₆":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.2242074953.map_simp -/\n@[simp]\ntheorem base_change_b₆ : (W.base_change A).b₆ = algebraMap R A W.b₆ :=\n  by\n  simp only [b₆, base_change_a₃, base_change_a₆]\n  run_tac\n    map_simp\n#align base_change_b₆ base_change_b₆\n\n",
 "base_change_b₄":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.2242074953.map_simp -/\n@[simp]\ntheorem base_change_b₄ : (W.base_change A).b₄ = algebraMap R A W.b₄ :=\n  by\n  simp only [b₄, base_change_a₁, base_change_a₃, base_change_a₄]\n  run_tac\n    map_simp\n#align base_change_b₄ base_change_b₄\n\n",
 "base_change_b₂":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic _private.2242074953.map_simp -/\n@[simp]\ntheorem base_change_b₂ : (W.base_change A).b₂ = algebraMap R A W.b₂ :=\n  by\n  simp only [b₂, base_change_a₁, base_change_a₂]\n  run_tac\n    map_simp\n#align base_change_b₂ base_change_b₂\n\n",
 "base_change_base_change":
 "theorem base_change_base_change : (W.base_change A).base_change B = W.base_change B := by\n  ext <;> exact (IsScalarTower.algebraMap_apply R A B _).symm\n#align base_change_base_change base_change_base_change\n\n",
 "b_relation":
 "/-\nCopyright (c) 2021 Kevin Buzzard. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, David Kurniadi Angdinata\n-/\ntheorem b_relation : 4 * W.b₈ = W.b₂ * W.b₆ - W.b₄ ^ 2 :=\n  by\n  simp only [b₂, b₄, b₆, b₈]\n  ring1\n#align b_relation b_relation\n\n",
 "Y_class_ne_zero":
 "theorem Y_class_ne_zero [Nontrivial R] : Y_class W y ≠ 0 :=\n  adjoin_root.mk_ne_zero_of_nat_degree_lt W.monic_polynomial (X_sub_C_ne_zero y) <|\n    by\n    rw [nat_degree_polynomial, nat_degree_X_sub_C]\n    norm_num1\n#align Y_class_ne_zero Y_class_ne_zero\n\n",
 "X_class_ne_zero":
 "theorem X_class_ne_zero [Nontrivial R] : X_class W x ≠ 0 :=\n  adjoin_root.mk_ne_zero_of_nat_degree_lt W.monic_polynomial (C_ne_zero.mpr <| X_sub_C_ne_zero x) <|\n    by\n    rw [nat_degree_polynomial, nat_degree_C]\n    norm_num1\n#align X_class_ne_zero X_class_ne_zero\n\n"}