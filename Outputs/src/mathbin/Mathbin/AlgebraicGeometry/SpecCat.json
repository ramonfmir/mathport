{"to_pushforward_stalk_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem to_pushforward_stalk_comp :\n    «expr ≫ » f (structure_sheaf.to_pushforward_stalk f p) =\n      «expr ≫ » (structure_sheaf.to_stalk R p) ((Top.presheaf.stalk_functor _ _).map (Spec.SheafedSpace_map f).c) :=\n  by\n  rw [structure_sheaf.to_stalk]\n  erw [category.assoc]\n  rw [Top.presheaf.stalk_functor_map_germ]\n  exact Spec_Γ_naturality_assoc f _\n#align to_pushforward_stalk_comp to_pushforward_stalk_comp\n\n",
 "to_PresheafedSpace_obj_op":
 "theorem Spec.to_PresheafedSpace_obj_op (R : CommRing) :\n    Spec.to_PresheafedSpace.obj (op R) = (Spec.SheafedSpace_obj R).to_PresheafedSpace :=\n  rfl\n#align Spec.to_PresheafedSpace_obj_op Spec.to_PresheafedSpace_obj_op\n\n",
 "to_PresheafedSpace_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n@[simp]\ntheorem Spec.to_PresheafedSpace_obj (R : «expr ᵒᵖ» CommRing) :\n    Spec.to_PresheafedSpace.obj R = (Spec.SheafedSpace_obj (unop R)).to_PresheafedSpace :=\n  rfl\n#align Spec.to_PresheafedSpace_obj Spec.to_PresheafedSpace_obj\n\n",
 "to_PresheafedSpace_map_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem Spec.to_PresheafedSpace_map_op (R S : CommRing) (f : «expr ⟶ » R S) :\n    Spec.to_PresheafedSpace.map f.op = Spec.SheafedSpace_map f :=\n  rfl\n#align Spec.to_PresheafedSpace_map_op Spec.to_PresheafedSpace_map_op\n\n",
 "to_PresheafedSpace_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem Spec.to_PresheafedSpace_map (R S : «expr ᵒᵖ» CommRing) (f : «expr ⟶ » R S) :\n    Spec.to_PresheafedSpace.map f = Spec.SheafedSpace_map f.unop :=\n  rfl\n#align Spec.to_PresheafedSpace_map Spec.to_PresheafedSpace_map\n\n",
 "stalk_map_to_stalk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[elementwise]\ntheorem stalk_map_to_stalk {R S : CommRing} (f : «expr ⟶ » R S) (p : prime_spectrum S) :\n    «expr ≫ » (to_stalk R (prime_spectrum.comap f p)) (PresheafedSpace.stalk_map (Spec.SheafedSpace_map f) p) =\n      «expr ≫ » f (to_stalk S p) :=\n  by\n  erw [← to_open_germ S («expr⊤») ⟨p, trivial⟩, ← to_open_germ R («expr⊤») ⟨prime_spectrum.comap f p, trivial⟩,\n    category.assoc, PresheafedSpace.stalk_map_germ (Spec.SheafedSpace_map f) («expr⊤») ⟨p, trivial⟩,\n    Spec.SheafedSpace_map_c_app, to_open_comp_comap_assoc]\n  rfl\n#align stalk_map_to_stalk stalk_map_to_stalk\n\n",
 "local_ring_hom_comp_stalk_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Under the isomorphisms `stalk_iso`, the map `stalk_map (Spec.SheafedSpace_map f) p` corresponds\nto the induced local ring homomorphism `localization.local_ring_hom`.\n-/\n@[elementwise]\ntheorem local_ring_hom_comp_stalk_iso {R S : CommRing} (f : «expr ⟶ » R S) (p : prime_spectrum S) :\n    «expr ≫ » (stalk_iso R (prime_spectrum.comap f p)).hom\n        (@category_struct.comp _ _ (CommRing.of (localization.at_prime (prime_spectrum.comap f p).as_ideal))\n          (CommRing.of (localization.at_prime p.as_ideal)) _\n          (localization.local_ring_hom (prime_spectrum.comap f p).as_ideal p.as_ideal f rfl) (stalk_iso S p).inv) =\n      PresheafedSpace.stalk_map (Spec.SheafedSpace_map f) p :=\n  (stalk_iso R (prime_spectrum.comap f p)).eq_inv_comp.mp <|\n    (stalk_iso S p).comp_inv_eq.mpr <|\n      localization.local_ring_hom_unique _ _ _ _ fun x => by\n        rw [stalk_iso_hom, stalk_iso_inv, comp_apply, comp_apply, localization_to_stalk_of, stalk_map_to_stalk_apply,\n          stalk_to_fiber_ring_hom_to_stalk]\n#align local_ring_hom_comp_stalk_iso local_ring_hom_comp_stalk_iso\n\n",
 "is_localized_module_to_pushforward_stalk_alg_hom_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_localized_module_to_pushforward_stalk_alg_hom_aux (y) :\n    ∃ x : S × p.as_ideal.prime_compl, «expr • » x.2 y = to_pushforward_stalk_alg_hom R S p x.1 :=\n  by\n  obtain ⟨U, hp, s, e⟩ := Top.presheaf.germ_exist _ _ y\n  obtain ⟨_, ⟨r, rfl⟩, hpr, hrU⟩ :=\n    prime_spectrum.is_topological_basis_basic_opens.exists_subset_of_mem_open (show p ∈ U.1 from hp) U.2\n  change prime_spectrum.basic_open r ≤ U at hrU\n  replace e :=\n    ((«expr _* » (Spec.Top_map (algebra_map R S)) (structure_sheaf S).1).germ_res_apply (hom_of_le hrU) ⟨p, hpr⟩\n          _).trans\n      e\n  set s' := («expr _* » (Spec.Top_map (algebra_map R S)) (structure_sheaf S).1).map (hom_of_le hrU).op s with h\n  rw [← h] at e\n  clear_value s'; clear! U\n  obtain ⟨⟨s, ⟨_, n, rfl⟩⟩, hsn⟩ :=\n    @is_localization.surj _ _ _ _ _ _ (structure_sheaf.is_localization.to_basic_open S <| algebra_map R S r) s'\n  refine' ⟨⟨s, ⟨r, hpr⟩ ^ n⟩, _⟩\n  rw [Submonoid.smul_def, algebra.smul_def, algebra_map_pushforward_stalk, to_pushforward_stalk, comp_apply, comp_apply]\n  iterate 2\n    erw [←\n      («expr _* » (Spec.Top_map (algebra_map R S)) (structure_sheaf S).1).germ_res_apply (hom_of_le le_top) ⟨p, hpr⟩]\n  rw [← e, ← map_mul, mul_comm]\n  dsimp only [subtype.coe_mk] at hsn\n  rw [← map_pow (algebra_map R S)] at hsn\n  congr 1\n#align is_localized_module_to_pushforward_stalk_alg_hom_aux is_localized_module_to_pushforward_stalk_alg_hom_aux\n\n",
 "basic_open_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem Spec.basic_open_hom_ext {X : RingedSpace} {R : CommRing} {α β : «expr ⟶ » X (Spec.SheafedSpace_obj R)}\n    (w : α.base = β.base)\n    (h :\n      ∀ r : R,\n        let U := prime_spectrum.basic_open r\n        «expr ≫ » («expr ≫ » (to_open R U) (α.c.app (op U))) (X.presheaf.map (eq_to_hom (by rw [w]))) =\n          «expr ≫ » (to_open R U) (β.c.app (op U))) :\n    α = β := by\n  ext1\n  · apply ((Top.sheaf.pushforward β.base).obj X.sheaf).hom_ext _ prime_spectrum.is_basis_basic_opens\n    intro r\n    apply (structure_sheaf.to_basic_open_epi R r).1\n    simpa using h r\n  exact w\n#align Spec.basic_open_hom_ext Spec.basic_open_hom_ext\n\n",
 "algebra_map_pushforward_stalk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem algebra_map_pushforward_stalk :\n    algebra_map R ((«expr _* » (Spec.Top_map f) (structure_sheaf S).1).stalk p) =\n      «expr ≫ » f (structure_sheaf.to_pushforward_stalk f p) :=\n  rfl\n#align algebra_map_pushforward_stalk algebra_map_pushforward_stalk\n\n",
 "Top_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Justus Springer\n-/\n@[simp]\ntheorem Spec.Top_map_id (R : CommRing) : Spec.Top_map ((«expr𝟙») R) = («expr𝟙») (Spec.Top_obj R) :=\n  prime_spectrum.comap_id\n#align Spec.Top_map_id Spec.Top_map_id\n\n",
 "Top_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem Spec.Top_map_comp {R S T : CommRing} (f : «expr ⟶ » R S) (g : «expr ⟶ » S T) :\n    Spec.Top_map («expr ≫ » f g) = «expr ≫ » (Spec.Top_map g) (Spec.Top_map f) :=\n  prime_spectrum.comap_comp _ _\n#align Spec.Top_map_comp Spec.Top_map_comp\n\n",
 "Spec_Γ_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem Spec_Γ_naturality {R S : CommRing} (f : «expr ⟶ » R S) :\n    «expr ≫ » f (to_Spec_Γ S) = «expr ≫ » (to_Spec_Γ R) (Γ.map (Spec.to_LocallyRingedSpace.map f.op).op) :=\n  by\n  ext\n  symm\n  apply localization.local_ring_hom_to_map\n#align Spec_Γ_naturality Spec_Γ_naturality\n\n",
 "Spec_map_localization_is_iso":
 "/-- The stalk map of `Spec M⁻¹R ⟶ Spec R` is an iso for each `p : Spec M⁻¹R`. -/\ntheorem Spec_map_localization_is_iso (R : CommRing) (M : Submonoid R) (x : prime_spectrum (localization M)) :\n    IsIso\n      (PresheafedSpace.stalk_map (Spec.to_PresheafedSpace.map (CommRing.of_hom (algebra_map R (localization M))).op)\n        x) :=\n  by\n  erw [← local_ring_hom_comp_stalk_iso]\n  apply (config := { instances := false }) is_iso.comp_is_iso\n  infer_instance\n  apply (config := { instances := false }) is_iso.comp_is_iso\n  -- I do not know why this is defeq to the goal, but I'm happy to accept that it is.\n  exact\n    show\n      is_iso\n        (is_localization.localization_localization_at_prime_iso_localization M\n                x.as_ideal).to_ring_equiv.to_CommRing_iso.hom\n      by infer_instance\n  infer_instance\n#align Spec_map_localization_is_iso Spec_map_localization_is_iso\n\n",
 "SheafedSpace_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem Spec.SheafedSpace_map_id {R : CommRing} :\n    Spec.SheafedSpace_map ((«expr𝟙») R) = («expr𝟙») (Spec.SheafedSpace_obj R) :=\n  PresheafedSpace.ext _ _ (Spec.Top_map_id R) <|\n    nat_trans.ext _ _ <|\n      funext fun U => by\n        dsimp\n        erw [PresheafedSpace.id_c_app, comap_id]; swap\n        · rw [Spec.Top_map_id, topological_space.opens.map_id_obj_unop]\n        simpa [eq_to_hom_map]\n#align Spec.SheafedSpace_map_id Spec.SheafedSpace_map_id\n\n",
 "SheafedSpace_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem Spec.SheafedSpace_map_comp {R S T : CommRing} (f : «expr ⟶ » R S) (g : «expr ⟶ » S T) :\n    Spec.SheafedSpace_map («expr ≫ » f g) = «expr ≫ » (Spec.SheafedSpace_map g) (Spec.SheafedSpace_map f) :=\n  PresheafedSpace.ext _ _ (Spec.Top_map_comp f g) <|\n    nat_trans.ext _ _ <|\n      funext fun U => by\n        dsimp\n        rw [category_theory.functor.map_id]\n        rw [category.comp_id]\n        erw [comap_comp f g]\n        rfl\n#align Spec.SheafedSpace_map_comp Spec.SheafedSpace_map_comp\n\n",
 "LocallyRingedSpace_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n-- Here, we are showing that the map on prime spectra induced by `f` is really a morphism of\n-- *locally* ringed spaces, i.e. that the induced map on the stalks is a local ring homomorphism.\n@[simp]\ntheorem Spec.LocallyRingedSpace_map_id (R : CommRing) :\n    Spec.LocallyRingedSpace_map ((«expr𝟙») R) = («expr𝟙») (Spec.LocallyRingedSpace_obj R) :=\n  LocallyRingedSpace.hom.ext _ _ <|\n    by\n    rw [Spec.LocallyRingedSpace_map_val, Spec.SheafedSpace_map_id]\n    rfl\n#align Spec.LocallyRingedSpace_map_id Spec.LocallyRingedSpace_map_id\n\n",
 "LocallyRingedSpace_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem Spec.LocallyRingedSpace_map_comp {R S T : CommRing} (f : «expr ⟶ » R S) (g : «expr ⟶ » S T) :\n    Spec.LocallyRingedSpace_map («expr ≫ » f g) =\n      «expr ≫ » (Spec.LocallyRingedSpace_map g) (Spec.LocallyRingedSpace_map f) :=\n  LocallyRingedSpace.hom.ext _ _ <|\n    by\n    rw [Spec.LocallyRingedSpace_map_val, Spec.SheafedSpace_map_comp]\n    rfl\n#align Spec.LocallyRingedSpace_map_comp Spec.LocallyRingedSpace_map_comp\n\n"}