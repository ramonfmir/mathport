{"stalk_specializes_stalk_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¤³ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- Intuitively, the inverse of the stalk map of `Î±` at `x` should just be the stalk map of `Î²`\n-- at `Î± x`. Unfortunately, we have a problem with dependent type theory here: Because `x`\n-- is not *definitionally* equal to `Î² (Î± x)`, the map `stalk_map Î² (Î± x)` has not the correct\n-- type for an inverse.\n-- To get a proper inverse, we need to compose with the `eq_to_hom` arrow\n-- `X.stalk x âŸ¶ X.stalk ((Î± â‰« Î²).base x)`.\n@[simp, reassoc.1, elementwise]\ntheorem stalk_specializes_stalk_map {X Y : PresheafedSpace.{v} C} (f : Â«expr âŸ¶ Â» X Y) {x y : X} (h : Â«expr â¤³ Â» x y) :\n    Â«expr â‰« Â» (Y.presheaf.stalk_specializes (f.base.map_specializes h)) (stalk_map f x) =\n      Â«expr â‰« Â» (stalk_map f y) (X.presheaf.stalk_specializes h) :=\n  by\n  delta PresheafedSpace.stalk_map\n  simp [stalk_map]\n#align stalk_specializes_stalk_map stalk_specializes_stalk_map\n\n",
 "stalk_map_germ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n@[simp, elementwise, reassoc.1]\ntheorem stalk_map_germ {X Y : PresheafedSpace.{v} C} (Î± : Â«expr âŸ¶ Â» X Y) (U : Opens Y.carrier)\n    (x : (Opens.map Î±.base).obj U) :\n    Â«expr â‰« Â» (Y.presheaf.germ âŸ¨Î±.base x, x.2âŸ©) (stalk_map Î± â†‘x) = Â«expr â‰« Â» (Î±.c.app (op U)) (X.presheaf.germ x) := by\n  rw [stalk_map, stalk_functor_map_germ_assoc, stalk_pushforward_germ]\n#align stalk_map_germ stalk_map_germ\n\n",
 "restrict_stalk_iso_inv_eq_of_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem restrict_stalk_iso_inv_eq_of_restrict {U : TopCat} (X : PresheafedSpace.{v} C)\n    {f : Â«expr âŸ¶ Â» U (X : TopCat.{v})} (h : OpenEmbedding f) (x : U) :\n    (X.restrict_stalk_iso h x).inv = stalk_map (X.of_restrict h) x :=\n  by\n  ext V\n  induction V using Opposite.rec'\n  let i : Â«expr âŸ¶ Â» ((h.is_open_map.functor_nhds x).obj ((open_nhds.map f x).obj V)) V :=\n    hom_of_le (Set.image_preimage_subset f _)\n  erw [iso.comp_inv_eq, colimit.Î¹_map_assoc, colimit.Î¹_map_assoc, colimit.Î¹_pre]\n  simp_rw [category.assoc]\n  erw [colimit.Î¹_pre (Â«expr â‹™ Â» (open_nhds.inclusion (f x)).op X.presheaf) (h.is_open_map.functor_nhds x).op]\n  erw [â† X.presheaf.map_comp_assoc]\n  exact (colimit.w (Â«expr â‹™ Â» (open_nhds.inclusion (f x)).op X.presheaf) i.op).symm\n#align restrict_stalk_iso_inv_eq_of_restrict restrict_stalk_iso_inv_eq_of_restrict\n\n",
 "restrict_stalk_iso_inv_eq_germ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, elementwise, reassoc.1]\ntheorem restrict_stalk_iso_inv_eq_germ {U : TopCat} (X : PresheafedSpace.{v} C) {f : Â«expr âŸ¶ Â» U (X : TopCat.{v})}\n    (h : OpenEmbedding f) (V : Opens U) (x : U) (hx : x âˆˆ V) :\n    Â«expr â‰« Â» (X.presheaf.germ âŸ¨f x, show f x âˆˆ h.is_open_map.functor.obj V from âŸ¨x, hx, rflâŸ©âŸ©)\n        (restrict_stalk_iso X h x).inv =\n      (X.restrict h).presheaf.germ âŸ¨x, hxâŸ© :=\n  by rw [â† restrict_stalk_iso_hom_eq_germ, category.assoc, iso.hom_inv_id, category.comp_id]\n#align restrict_stalk_iso_inv_eq_germ restrict_stalk_iso_inv_eq_germ\n\n",
 "restrict_stalk_iso_hom_eq_germ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- As a left adjoint, the functor `h.is_open_map.functor_nhds x` is initial.\n-- Typeclass resolution knows that the opposite of an initial functor is final. The result\n-- follows from the general fact that postcomposing with a final functor doesn't change colimits.\n@[simp, elementwise, reassoc.1]\ntheorem restrict_stalk_iso_hom_eq_germ {U : TopCat} (X : PresheafedSpace.{v} C) {f : Â«expr âŸ¶ Â» U (X : TopCat.{v})}\n    (h : OpenEmbedding f) (V : Opens U) (x : U) (hx : x âˆˆ V) :\n    Â«expr â‰« Â» ((X.restrict h).presheaf.germ âŸ¨x, hxâŸ©) (restrict_stalk_iso X h x).hom =\n      X.presheaf.germ âŸ¨f x, show f x âˆˆ h.is_open_map.functor.obj V from âŸ¨x, hx, rflâŸ©âŸ© :=\n  colimit.Î¹_pre (Â«expr â‹™ Â» (OpenNhds.inclusion (f x)).op X.presheaf) (h.is_open_map.functor_nhds x).op (op âŸ¨V, hxâŸ©)\n#align restrict_stalk_iso_hom_eq_germ restrict_stalk_iso_hom_eq_germ\n\n",
 "id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n#print id /-\n@[simp]\ntheorem id (X : PresheafedSpace.{v} C) (x : X) : stalk_map ((Â«exprğŸ™Â») X) x = (Â«exprğŸ™Â») (X.stalk x) :=\n  by\n  dsimp [stalk_map]\n  simp only [stalk_pushforward.id]\n  rw [â† map_comp]\n  convert(stalk_functor C x).map_id X.presheaf\n  tidy\n#align id id\n-/\n\n",
 "congr_point":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem congr_point {X Y : PresheafedSpace.{v} C} (Î± : Â«expr âŸ¶ Â» X Y) (x x' : X) (h : x = x') :\n    Â«expr â‰« Â» (stalk_map Î± x) (eqToHom (show X.stalk x = X.stalk x' by rw [h])) =\n      Â«expr â‰« Â» (eqToHom (show Y.stalk (Î±.base x) = Y.stalk (Î±.base x') by rw [h])) (stalk_map Î± x') :=\n  by rw [stalk_map.congr Î± Î± rfl x x' h]\n#align congr_point congr_point\n\n",
 "congr_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem congr_hom {X Y : PresheafedSpace.{v} C} (Î± Î² : Â«expr âŸ¶ Â» X Y) (h : Î± = Î²) (x : X) :\n    stalk_map Î± x = Â«expr â‰« Â» (eqToHom (show Y.stalk (Î±.base x) = Y.stalk (Î².base x) by rw [h])) (stalk_map Î² x) := by\n  rw [â† stalk_map.congr Î± Î² h x x rfl, eq_to_hom_refl, category.comp_id]\n#align congr_hom congr_hom\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n#print congr /-\n/-- If `Î± = Î²` and `x = x'`, we would like to say that `stalk_map Î± x = stalk_map Î² x'`.\nUnfortunately, this equality is not well-formed, as their types are not _definitionally_ the same.\nTo get a proper congruence lemma, we therefore have to introduce these `eq_to_hom` arrows on\neither side of the equality.\n-/\ntheorem congr {X Y : PresheafedSpace.{v} C} (Î± Î² : Â«expr âŸ¶ Â» X Y) (hâ‚ : Î± = Î²) (x x' : X) (hâ‚‚ : x = x') :\n    Â«expr â‰« Â» (stalk_map Î± x) (eqToHom (show X.stalk x = X.stalk x' by rw [hâ‚‚])) =\n      Â«expr â‰« Â» (eqToHom (show Y.stalk (Î±.base x) = Y.stalk (Î².base x') by rw [hâ‚, hâ‚‚])) (stalk_map Î² x') :=\n  stalk_hom_ext _ fun U hx => by\n    subst hâ‚\n    subst hâ‚‚\n    simp\n#align congr congr\n-/\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- TODO understand why this proof is still gross (i.e. requires using `erw`)\n@[simp]\ntheorem comp {X Y Z : PresheafedSpace.{v} C} (Î± : Â«expr âŸ¶ Â» X Y) (Î² : Â«expr âŸ¶ Â» Y Z) (x : X) :\n    stalk_map (Â«expr â‰« Â» Î± Î²) x =\n      Â«expr â‰« Â» (stalk_map Î² (Î±.base x) : Â«expr âŸ¶ Â» (Z.stalk (Î².base (Î±.base x))) (Y.stalk (Î±.base x)))\n        (stalk_map Î± x : Â«expr âŸ¶ Â» (Y.stalk (Î±.base x)) (X.stalk x)) :=\n  by\n  dsimp [stalk_map, stalk_functor, stalk_pushforward]\n  ext U\n  induction U using Opposite.rec'\n  cases U\n  simp only [colimit.Î¹_map_assoc, colimit.Î¹_pre_assoc, colimit.Î¹_pre, whisker_left_app, whisker_right_app, assoc,\n    id_comp, map_id, map_comp]\n  dsimp\n  simp only [map_id, assoc, pushforward.comp_inv_app]\n  -- FIXME Why doesn't simp do this:\n  erw [CategoryTheory.Functor.map_id]\n  erw [CategoryTheory.Functor.map_id]\n  erw [id_comp, id_comp]\n#align comp comp\n\n"}