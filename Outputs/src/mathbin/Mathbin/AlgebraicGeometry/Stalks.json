{"stalk_specializes_stalk_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- Intuitively, the inverse of the stalk map of `α` at `x` should just be the stalk map of `β`\n-- at `α x`. Unfortunately, we have a problem with dependent type theory here: Because `x`\n-- is not *definitionally* equal to `β (α x)`, the map `stalk_map β (α x)` has not the correct\n-- type for an inverse.\n-- To get a proper inverse, we need to compose with the `eq_to_hom` arrow\n-- `X.stalk x ⟶ X.stalk ((α ≫ β).base x)`.\n@[simp, reassoc.1, elementwise]\ntheorem stalk_specializes_stalk_map {X Y : PresheafedSpace.{v} C} (f : «expr ⟶ » X Y) {x y : X} (h : «expr ⤳ » x y) :\n    «expr ≫ » (Y.presheaf.stalk_specializes (f.base.map_specializes h)) (stalk_map f x) =\n      «expr ≫ » (stalk_map f y) (X.presheaf.stalk_specializes h) :=\n  by\n  delta PresheafedSpace.stalk_map\n  simp [stalk_map]\n#align stalk_specializes_stalk_map stalk_specializes_stalk_map\n\n",
 "stalk_map_germ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n@[simp, elementwise, reassoc.1]\ntheorem stalk_map_germ {X Y : PresheafedSpace.{v} C} (α : «expr ⟶ » X Y) (U : Opens Y.carrier)\n    (x : (Opens.map α.base).obj U) :\n    «expr ≫ » (Y.presheaf.germ ⟨α.base x, x.2⟩) (stalk_map α ↑x) = «expr ≫ » (α.c.app (op U)) (X.presheaf.germ x) := by\n  rw [stalk_map, stalk_functor_map_germ_assoc, stalk_pushforward_germ]\n#align stalk_map_germ stalk_map_germ\n\n",
 "restrict_stalk_iso_inv_eq_of_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem restrict_stalk_iso_inv_eq_of_restrict {U : TopCat} (X : PresheafedSpace.{v} C)\n    {f : «expr ⟶ » U (X : TopCat.{v})} (h : OpenEmbedding f) (x : U) :\n    (X.restrict_stalk_iso h x).inv = stalk_map (X.of_restrict h) x :=\n  by\n  ext V\n  induction V using Opposite.rec'\n  let i : «expr ⟶ » ((h.is_open_map.functor_nhds x).obj ((open_nhds.map f x).obj V)) V :=\n    hom_of_le (Set.image_preimage_subset f _)\n  erw [iso.comp_inv_eq, colimit.ι_map_assoc, colimit.ι_map_assoc, colimit.ι_pre]\n  simp_rw [category.assoc]\n  erw [colimit.ι_pre («expr ⋙ » (open_nhds.inclusion (f x)).op X.presheaf) (h.is_open_map.functor_nhds x).op]\n  erw [← X.presheaf.map_comp_assoc]\n  exact (colimit.w («expr ⋙ » (open_nhds.inclusion (f x)).op X.presheaf) i.op).symm\n#align restrict_stalk_iso_inv_eq_of_restrict restrict_stalk_iso_inv_eq_of_restrict\n\n",
 "restrict_stalk_iso_inv_eq_germ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, elementwise, reassoc.1]\ntheorem restrict_stalk_iso_inv_eq_germ {U : TopCat} (X : PresheafedSpace.{v} C) {f : «expr ⟶ » U (X : TopCat.{v})}\n    (h : OpenEmbedding f) (V : Opens U) (x : U) (hx : x ∈ V) :\n    «expr ≫ » (X.presheaf.germ ⟨f x, show f x ∈ h.is_open_map.functor.obj V from ⟨x, hx, rfl⟩⟩)\n        (restrict_stalk_iso X h x).inv =\n      (X.restrict h).presheaf.germ ⟨x, hx⟩ :=\n  by rw [← restrict_stalk_iso_hom_eq_germ, category.assoc, iso.hom_inv_id, category.comp_id]\n#align restrict_stalk_iso_inv_eq_germ restrict_stalk_iso_inv_eq_germ\n\n",
 "restrict_stalk_iso_hom_eq_germ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- As a left adjoint, the functor `h.is_open_map.functor_nhds x` is initial.\n-- Typeclass resolution knows that the opposite of an initial functor is final. The result\n-- follows from the general fact that postcomposing with a final functor doesn't change colimits.\n@[simp, elementwise, reassoc.1]\ntheorem restrict_stalk_iso_hom_eq_germ {U : TopCat} (X : PresheafedSpace.{v} C) {f : «expr ⟶ » U (X : TopCat.{v})}\n    (h : OpenEmbedding f) (V : Opens U) (x : U) (hx : x ∈ V) :\n    «expr ≫ » ((X.restrict h).presheaf.germ ⟨x, hx⟩) (restrict_stalk_iso X h x).hom =\n      X.presheaf.germ ⟨f x, show f x ∈ h.is_open_map.functor.obj V from ⟨x, hx, rfl⟩⟩ :=\n  colimit.ι_pre («expr ⋙ » (OpenNhds.inclusion (f x)).op X.presheaf) (h.is_open_map.functor_nhds x).op (op ⟨V, hx⟩)\n#align restrict_stalk_iso_hom_eq_germ restrict_stalk_iso_hom_eq_germ\n\n",
 "id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n#print id /-\n@[simp]\ntheorem id (X : PresheafedSpace.{v} C) (x : X) : stalk_map ((«expr𝟙») X) x = («expr𝟙») (X.stalk x) :=\n  by\n  dsimp [stalk_map]\n  simp only [stalk_pushforward.id]\n  rw [← map_comp]\n  convert(stalk_functor C x).map_id X.presheaf\n  tidy\n#align id id\n-/\n\n",
 "congr_point":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem congr_point {X Y : PresheafedSpace.{v} C} (α : «expr ⟶ » X Y) (x x' : X) (h : x = x') :\n    «expr ≫ » (stalk_map α x) (eqToHom (show X.stalk x = X.stalk x' by rw [h])) =\n      «expr ≫ » (eqToHom (show Y.stalk (α.base x) = Y.stalk (α.base x') by rw [h])) (stalk_map α x') :=\n  by rw [stalk_map.congr α α rfl x x' h]\n#align congr_point congr_point\n\n",
 "congr_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem congr_hom {X Y : PresheafedSpace.{v} C} (α β : «expr ⟶ » X Y) (h : α = β) (x : X) :\n    stalk_map α x = «expr ≫ » (eqToHom (show Y.stalk (α.base x) = Y.stalk (β.base x) by rw [h])) (stalk_map β x) := by\n  rw [← stalk_map.congr α β h x x rfl, eq_to_hom_refl, category.comp_id]\n#align congr_hom congr_hom\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n#print congr /-\n/-- If `α = β` and `x = x'`, we would like to say that `stalk_map α x = stalk_map β x'`.\nUnfortunately, this equality is not well-formed, as their types are not _definitionally_ the same.\nTo get a proper congruence lemma, we therefore have to introduce these `eq_to_hom` arrows on\neither side of the equality.\n-/\ntheorem congr {X Y : PresheafedSpace.{v} C} (α β : «expr ⟶ » X Y) (h₁ : α = β) (x x' : X) (h₂ : x = x') :\n    «expr ≫ » (stalk_map α x) (eqToHom (show X.stalk x = X.stalk x' by rw [h₂])) =\n      «expr ≫ » (eqToHom (show Y.stalk (α.base x) = Y.stalk (β.base x') by rw [h₁, h₂])) (stalk_map β x') :=\n  stalk_hom_ext _ fun U hx => by\n    subst h₁\n    subst h₂\n    simp\n#align congr congr\n-/\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- TODO understand why this proof is still gross (i.e. requires using `erw`)\n@[simp]\ntheorem comp {X Y Z : PresheafedSpace.{v} C} (α : «expr ⟶ » X Y) (β : «expr ⟶ » Y Z) (x : X) :\n    stalk_map («expr ≫ » α β) x =\n      «expr ≫ » (stalk_map β (α.base x) : «expr ⟶ » (Z.stalk (β.base (α.base x))) (Y.stalk (α.base x)))\n        (stalk_map α x : «expr ⟶ » (Y.stalk (α.base x)) (X.stalk x)) :=\n  by\n  dsimp [stalk_map, stalk_functor, stalk_pushforward]\n  ext U\n  induction U using Opposite.rec'\n  cases U\n  simp only [colimit.ι_map_assoc, colimit.ι_pre_assoc, colimit.ι_pre, whisker_left_app, whisker_right_app, assoc,\n    id_comp, map_id, map_comp]\n  dsimp\n  simp only [map_id, assoc, pushforward.comp_inv_app]\n  -- FIXME Why doesn't simp do this:\n  erw [CategoryTheory.Functor.map_id]\n  erw [CategoryTheory.Functor.map_id]\n  erw [id_comp, id_comp]\n#align comp comp\n\n"}