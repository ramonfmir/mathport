{"Î“_Spec_left_triangle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-- `to_Spec_Î“ _` is an isomorphism so these are mutually two-sided inverses. -/\ntheorem Î“_Spec_left_triangle :\n    Â«expr â‰« Â» (to_Spec_Î“ (Î“.obj (op X))) (X.to_Î“_Spec.1.c.app (op (Â«exprâŠ¤Â»))) = (Â«exprğŸ™Â») _ :=\n  by\n  unfold to_Spec_Î“\n  rw [â† to_open_res _ (basic_open (1 : Î“.obj (op X))) (Â«exprâŠ¤Â») (eq_to_hom basic_open_one.symm)]\n  erw [category.assoc]\n  rw [nat_trans.naturality, â† category.assoc]\n  erw [X.to_Î“_Spec_SheafedSpace_app_spec 1, â† functor.map_comp]\n  convert eq_to_hom_map X.presheaf _; rfl\n#align Î“_Spec_left_triangle Î“_Spec_left_triangle\n\n",
 "to_Î“_Spec_preim_basic_open_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- The preimage of a basic open in `Spec Î“(X)` under the unit is the basic\nopen in `X` defined by the same element (they are equal as sets). -/\ntheorem to_Î“_Spec_preim_basic_open_eq (r : Î“.obj (op X)) :\n    Â«expr â»Â¹' Â» X.to_Î“_Spec_fun (basic_open r).1 = (X.to_RingedSpace.basic_open r).1 :=\n  by\n  ext\n  erw [X.to_RingedSpace.mem_top_basic_open]\n  apply not_mem_prime_iff_unit_in_stalk\n#align to_Î“_Spec_preim_basic_open_eq to_Î“_Spec_preim_basic_open_eq\n\n",
 "to_Î“_Spec_map_basic_open_eq":
 "/-- The preimage is the basic open in `X` defined by the same element `r`. -/\ntheorem to_Î“_Spec_map_basic_open_eq : X.to_Î“_Spec_map_basic_open r = X.to_RingedSpace.basic_open r :=\n  subtype.eq (X.to_Î“_Spec_preim_basic_open_eq r)\n#align to_Î“_Spec_map_basic_open_eq to_Î“_Spec_map_basic_open_eq\n\n",
 "to_Î“_Spec_continuous":
 "/-- `to_Î“_Spec_fun` is continuous. -/\ntheorem to_Î“_Spec_continuous : continuous X.to_Î“_Spec_fun :=\n  by\n  apply is_topological_basis_basic_opens.continuous\n  rintro _ âŸ¨r, rflâŸ©\n  erw [X.to_Î“_Spec_preim_basic_open_eq r]\n  exact (X.to_RingedSpace.basic_open r).2\n#align to_Î“_Spec_continuous to_Î“_Spec_continuous\n\n",
 "to_Î“_Spec_c_app_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem to_Î“_Spec_c_app_spec :\n    Â«expr â‰« Â» (to_open _ (basic_open r)) (X.to_Î“_Spec_c_app r) = X.to_to_Î“_Spec_map_basic_open r :=\n  (X.to_Î“_Spec_c_app_iff r _).2 rfl\n#align to_Î“_Spec_c_app_spec to_Î“_Spec_c_app_spec\n\n",
 "to_Î“_Spec_c_app_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- Characterization of the sheaf hom on basic opens,\n    direction â† (next lemma) is used at various places, but â†’ is not used in this file. -/\ntheorem to_Î“_Spec_c_app_iff\n    (f :\n      Â«expr âŸ¶ Â» ((structure_sheaf <| Î“.obj <| op X).val.obj (op <| basic_open r))\n        (X.presheaf.obj (op <| X.to_Î“_Spec_map_basic_open r))) :\n    Â«expr â‰« Â» (to_open _ (basic_open r)) f = X.to_to_Î“_Spec_map_basic_open r â†” f = X.to_Î“_Spec_c_app r :=\n  by\n  rw [â† is_localization.away.away_map.lift_comp r (X.is_unit_res_to_Î“_Spec_map_basic_open r)]\n  pick_goal 5; exact is_localization.to_basic_open _ r\n  constructor\n  Â· intro h\n    refine' is_localization.ring_hom_ext _ _\n    pick_goal 5\n    exact is_localization.to_basic_open _ r\n    exact h\n  apply congr_arg\n#align to_Î“_Spec_c_app_iff to_Î“_Spec_c_app_iff\n\n",
 "to_Î“_Spec_SheafedSpace_app_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem to_Î“_Spec_SheafedSpace_app_spec (r : Î“.obj (op X)) :\n    Â«expr â‰« Â» (to_open _ (basic_open r)) (X.to_Î“_Spec_SheafedSpace.c.app (op (basic_open r))) =\n      X.to_to_Î“_Spec_map_basic_open r :=\n  (X.to_Î“_Spec_SheafedSpace_app_eq r).symm â–¸ X.to_Î“_Spec_c_app_spec r\n#align to_Î“_Spec_SheafedSpace_app_spec to_Î“_Spec_SheafedSpace_app_spec\n\n",
 "to_Î“_Spec_SheafedSpace_app_eq":
 "theorem to_Î“_Spec_SheafedSpace_app_eq : X.to_Î“_Spec_SheafedSpace.c.app (op (basic_open r)) = X.to_Î“_Spec_c_app r :=\n  Top.sheaf.extend_hom_app _ _ _ _ _\n#align to_Î“_Spec_SheafedSpace_app_eq to_Î“_Spec_SheafedSpace_app_eq\n\n",
 "to_stalk_stalk_map_to_Î“_Spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr _* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- The map on stalks induced by the unit commutes with maps from `Î“(X)` to\n    stalks (in `Spec Î“(X)` and in `X`). -/\ntheorem to_stalk_stalk_map_to_Î“_Spec (x : X) :\n    Â«expr â‰« Â» (to_stalk _ _) (PresheafedSpace.stalk_map X.to_Î“_Spec_SheafedSpace x) = X.Î“_to_stalk x :=\n  by\n  rw [PresheafedSpace.stalk_map]\n  erw [â† to_open_germ _ (basic_open (1 : Î“.obj (op X))) âŸ¨X.to_Î“_Spec_fun x, by rw [basic_open_one] <;> trivialâŸ©]\n  rw [â† category.assoc, category.assoc (to_open _ _)]\n  erw [stalk_functor_map_germ]\n  rw [â† category.assoc (to_open _ _), X.to_Î“_Spec_SheafedSpace_app_spec 1]\n  unfold Î“_to_stalk\n  rw [â† stalk_pushforward_germ _ X.to_Î“_Spec_base X.presheaf (Â«exprâŠ¤Â»)]\n  congr 1\n  change Â«expr â‰« Â» ((Â«expr _* Â» X.to_Î“_Spec_base X.presheaf).map le_top.hom.op) _ = _\n  apply germ_res\n#align to_stalk_stalk_map_to_Î“_Spec to_stalk_stalk_map_to_Î“_Spec\n\n",
 "right_triangle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-- `Spec_Î“_identity` is iso so these are mutually two-sided inverses. -/\ntheorem right_triangle (R : CommRing) :\n    Â«expr â‰« Â» (identity_to_Î“_Spec.app (Spec.to_LocallyRingedSpace.obj <| op R))\n        (Spec.to_LocallyRingedSpace.map (Spec_Î“_identity.inv.app R).op) =\n      (Â«exprğŸ™Â») _ :=\n  by\n  apply LocallyRingedSpace.comp_ring_hom_ext\n  Â· ext ((p : prime_spectrum R)x)\n    erw [â† is_localization.at_prime.to_map_mem_maximal_iff ((structure_sheaf R).presheaf.stalk p) p.as_ideal x]\n    rfl\n  Â· intro r\n    apply to_open_res\n#align right_triangle right_triangle\n\n",
 "not_mem_prime_iff_unit_in_stalk":
 "/-\nCopyright (c) 2021 Junyan Xu. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Junyan Xu\n-/\ntheorem not_mem_prime_iff_unit_in_stalk (r : Î“.obj (op X)) (x : X) :\n    r âˆ‰ (X.to_Î“_Spec_fun x).as_ideal â†” is_unit (X.Î“_to_stalk x r) := by erw [local_ring.mem_maximal_ideal, not_not]\n#align not_mem_prime_iff_unit_in_stalk not_mem_prime_iff_unit_in_stalk\n\n",
 "left_triangle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem left_triangle (X : LocallyRingedSpace) :\n    Â«expr â‰« Â» (Spec_Î“_identity.inv.app (Î“.obj (op X))) ((identity_to_Î“_Spec.app X).val.c.app (op (Â«exprâŠ¤Â»))) =\n      (Â«exprğŸ™Â») _ :=\n  X.Î“_Spec_left_triangle\n#align left_triangle left_triangle\n\n",
 "is_unit_res_to_Î“_Spec_map_basic_open":
 "/-- `r` is a unit as a section on the basic open defined by `r`. -/\ntheorem is_unit_res_to_Î“_Spec_map_basic_open : is_unit (X.to_to_Î“_Spec_map_basic_open r r) :=\n  by\n  convert\n    (X.presheaf.map <| (eq_to_hom <| X.to_Î“_Spec_map_basic_open_eq r).op).is_unit_map\n      (X.to_RingedSpace.is_unit_res_basic_open r)\n  rw [â† comp_apply]\n  erw [â† functor.map_comp]\n  congr\n#align is_unit_res_to_Î“_Spec_map_basic_open is_unit_res_to_Î“_Spec_map_basic_open\n\n",
 "comp_ring_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n-- show stalk map is local hom â†“\ntheorem comp_ring_hom_ext {X : LocallyRingedSpace} {R : CommRing} {f : Â«expr âŸ¶ Â» R (Î“.obj (op X))}\n    {Î² : Â«expr âŸ¶ Â» X (Spec.LocallyRingedSpace_obj R)}\n    (w : Â«expr â‰« Â» X.to_Î“_Spec.1.base (Spec.LocallyRingedSpace_map f).1.base = Î².1.base)\n    (h :\n      âˆ€ r : R,\n        Â«expr â‰« Â» f (X.presheaf.map (hom_of_le le_top : Â«expr âŸ¶ Â» ((opens.map Î².1.base).obj (basic_open r)) _).op) =\n          Â«expr â‰« Â» (to_open R (basic_open r)) (Î².1.c.app (op (basic_open r)))) :\n    Â«expr â‰« Â» X.to_Î“_Spec (Spec.LocallyRingedSpace_map f) = Î² :=\n  by\n  ext1\n  apply Spec.basic_open_hom_ext\n  Â· intro r _\n    rw [LocallyRingedSpace.comp_val_c_app]\n    erw [to_open_comp_comap_assoc]\n    rw [category.assoc]\n    erw [to_Î“_Spec_SheafedSpace_app_spec, â† X.presheaf.map_comp]\n    convert h r\n  exact w\n#align comp_ring_hom_ext comp_ring_hom_ext\n\n",
 "adjunction_unit_app_app_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr _* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n-- This is just\n-- `(Î“_Spec.adjunction.unit.app X).1.c.app (op âŠ¤) = Spec_Î“_identity.hom.app (X.presheaf.obj (op âŠ¤))`\n-- But lean times out when trying to unify the types of the two sides.\ntheorem adjunction_unit_app_app_top (X : Scheme) :\n    @eq\n      (Â«expr âŸ¶ Â» ((Scheme.Spec.obj (op <| X.presheaf.obj (op (Â«exprâŠ¤Â»)))).presheaf.obj (op (Â«exprâŠ¤Â»)))\n        ((Â«expr _* Â» (Î“_Spec.adjunction.unit.app X).1.base X.presheaf).obj (op (Â«exprâŠ¤Â»))))\n      ((Î“_Spec.adjunction.unit.app X).val.c.app (op (Â«exprâŠ¤Â»)))\n      (Spec_Î“_identity.hom.app (X.presheaf.obj (op (Â«exprâŠ¤Â»)))) :=\n  by\n  have := congr_app Î“_Spec.adjunction.left_triangle X\n  dsimp at this\n  rw [â† is_iso.eq_comp_inv] at this\n  simp only [Î“_Spec.LocallyRingedSpace_adjunction_counit, nat_trans.op_app, category.id_comp,\n    Î“_Spec.adjunction_counit_app] at this\n  rw [â† op_inv, nat_iso.inv_inv_app, quiver.hom.op_inj.eq_iff] at this\n  exact this\n#align adjunction_unit_app_app_top adjunction_unit_app_app_top\n\n",
 "adjunction_unit_app":
 "@[simp]\ntheorem adjunction_unit_app {X : Scheme} : Î“_Spec.adjunction.unit.app X = LocallyRingedSpace_adjunction.unit.app X.1 :=\n  by\n  rw [â† adjunction.hom_equiv_id, â† adjunction.hom_equiv_id, adjunction_hom_equiv_apply]\n  rfl\n#align adjunction_unit_app adjunction_unit_app\n\n",
 "adjunction_hom_equiv_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem adjunction_hom_equiv_symm_apply {X : Scheme} {R : Â«expr áµ’áµ–Â» CommRing} (f : Â«expr âŸ¶ Â» X (Scheme.Spec.obj R)) :\n    (Î“_Spec.adjunction.hom_equiv X R).symm f = (LocallyRingedSpace_adjunction.hom_equiv X.1 R).symm f :=\n  by\n  congr 2\n  exact adjunction_hom_equiv _ _\n#align adjunction_hom_equiv_symm_apply adjunction_hom_equiv_symm_apply\n\n",
 "adjunction_hom_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- Removing this makes the following definition time out.\ntheorem adjunction_hom_equiv_apply {X : Scheme} {R : Â«expr áµ’áµ–Â» CommRing}\n    (f : Â«expr âŸ¶ Â» (op <| Scheme.Î“.obj <| op X) R) :\n    Î“_Spec.adjunction.hom_equiv X R f = LocallyRingedSpace_adjunction.hom_equiv X.1 R f :=\n  by\n  dsimp [adjunction, adjunction.restrict_fully_faithful]\n  simp\n#align adjunction_hom_equiv_apply adjunction_hom_equiv_apply\n\n",
 "adjunction_hom_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\ntheorem adjunction_hom_equiv (X : Scheme) (R : Â«expr áµ’áµ–Â» CommRing) :\n    Î“_Spec.adjunction.hom_equiv X R = LocallyRingedSpace_adjunction.hom_equiv X.1 R :=\n  equiv.ext fun f => adjunction_hom_equiv_apply f\n#align adjunction_hom_equiv adjunction_hom_equiv\n\n",
 "adjunction_counit_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n@[simp]\ntheorem adjunction_counit_app {R : Â«expr áµ’áµ–Â» CommRing} :\n    Î“_Spec.adjunction.counit.app R = LocallyRingedSpace_adjunction.counit.app R :=\n  by\n  rw [â† adjunction.hom_equiv_symm_id, â† adjunction.hom_equiv_symm_id, adjunction_hom_equiv_symm_apply]\n  rfl\n#align adjunction_counit_app adjunction_counit_app\n\n"}