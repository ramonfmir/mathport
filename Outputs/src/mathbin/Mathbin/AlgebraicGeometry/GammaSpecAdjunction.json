{"Γ_Spec_left_triangle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- `to_Spec_Γ _` is an isomorphism so these are mutually two-sided inverses. -/\ntheorem Γ_Spec_left_triangle :\n    «expr ≫ » (to_Spec_Γ (Γ.obj (op X))) (X.to_Γ_Spec.1.c.app (op («expr⊤»))) = («expr𝟙») _ :=\n  by\n  unfold to_Spec_Γ\n  rw [← to_open_res _ (basic_open (1 : Γ.obj (op X))) («expr⊤») (eq_to_hom basic_open_one.symm)]\n  erw [category.assoc]\n  rw [nat_trans.naturality, ← category.assoc]\n  erw [X.to_Γ_Spec_SheafedSpace_app_spec 1, ← functor.map_comp]\n  convert eq_to_hom_map X.presheaf _; rfl\n#align Γ_Spec_left_triangle Γ_Spec_left_triangle\n\n",
 "to_Γ_Spec_preim_basic_open_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- The preimage of a basic open in `Spec Γ(X)` under the unit is the basic\nopen in `X` defined by the same element (they are equal as sets). -/\ntheorem to_Γ_Spec_preim_basic_open_eq (r : Γ.obj (op X)) :\n    «expr ⁻¹' » X.to_Γ_Spec_fun (basic_open r).1 = (X.to_RingedSpace.basic_open r).1 :=\n  by\n  ext\n  erw [X.to_RingedSpace.mem_top_basic_open]\n  apply not_mem_prime_iff_unit_in_stalk\n#align to_Γ_Spec_preim_basic_open_eq to_Γ_Spec_preim_basic_open_eq\n\n",
 "to_Γ_Spec_map_basic_open_eq":
 "/-- The preimage is the basic open in `X` defined by the same element `r`. -/\ntheorem to_Γ_Spec_map_basic_open_eq : X.to_Γ_Spec_map_basic_open r = X.to_RingedSpace.basic_open r :=\n  subtype.eq (X.to_Γ_Spec_preim_basic_open_eq r)\n#align to_Γ_Spec_map_basic_open_eq to_Γ_Spec_map_basic_open_eq\n\n",
 "to_Γ_Spec_continuous":
 "/-- `to_Γ_Spec_fun` is continuous. -/\ntheorem to_Γ_Spec_continuous : continuous X.to_Γ_Spec_fun :=\n  by\n  apply is_topological_basis_basic_opens.continuous\n  rintro _ ⟨r, rfl⟩\n  erw [X.to_Γ_Spec_preim_basic_open_eq r]\n  exact (X.to_RingedSpace.basic_open r).2\n#align to_Γ_Spec_continuous to_Γ_Spec_continuous\n\n",
 "to_Γ_Spec_c_app_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem to_Γ_Spec_c_app_spec :\n    «expr ≫ » (to_open _ (basic_open r)) (X.to_Γ_Spec_c_app r) = X.to_to_Γ_Spec_map_basic_open r :=\n  (X.to_Γ_Spec_c_app_iff r _).2 rfl\n#align to_Γ_Spec_c_app_spec to_Γ_Spec_c_app_spec\n\n",
 "to_Γ_Spec_c_app_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Characterization of the sheaf hom on basic opens,\n    direction ← (next lemma) is used at various places, but → is not used in this file. -/\ntheorem to_Γ_Spec_c_app_iff\n    (f :\n      «expr ⟶ » ((structure_sheaf <| Γ.obj <| op X).val.obj (op <| basic_open r))\n        (X.presheaf.obj (op <| X.to_Γ_Spec_map_basic_open r))) :\n    «expr ≫ » (to_open _ (basic_open r)) f = X.to_to_Γ_Spec_map_basic_open r ↔ f = X.to_Γ_Spec_c_app r :=\n  by\n  rw [← is_localization.away.away_map.lift_comp r (X.is_unit_res_to_Γ_Spec_map_basic_open r)]\n  pick_goal 5; exact is_localization.to_basic_open _ r\n  constructor\n  · intro h\n    refine' is_localization.ring_hom_ext _ _\n    pick_goal 5\n    exact is_localization.to_basic_open _ r\n    exact h\n  apply congr_arg\n#align to_Γ_Spec_c_app_iff to_Γ_Spec_c_app_iff\n\n",
 "to_Γ_Spec_SheafedSpace_app_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem to_Γ_Spec_SheafedSpace_app_spec (r : Γ.obj (op X)) :\n    «expr ≫ » (to_open _ (basic_open r)) (X.to_Γ_Spec_SheafedSpace.c.app (op (basic_open r))) =\n      X.to_to_Γ_Spec_map_basic_open r :=\n  (X.to_Γ_Spec_SheafedSpace_app_eq r).symm ▸ X.to_Γ_Spec_c_app_spec r\n#align to_Γ_Spec_SheafedSpace_app_spec to_Γ_Spec_SheafedSpace_app_spec\n\n",
 "to_Γ_Spec_SheafedSpace_app_eq":
 "theorem to_Γ_Spec_SheafedSpace_app_eq : X.to_Γ_Spec_SheafedSpace.c.app (op (basic_open r)) = X.to_Γ_Spec_c_app r :=\n  Top.sheaf.extend_hom_app _ _ _ _ _\n#align to_Γ_Spec_SheafedSpace_app_eq to_Γ_Spec_SheafedSpace_app_eq\n\n",
 "to_stalk_stalk_map_to_Γ_Spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The map on stalks induced by the unit commutes with maps from `Γ(X)` to\n    stalks (in `Spec Γ(X)` and in `X`). -/\ntheorem to_stalk_stalk_map_to_Γ_Spec (x : X) :\n    «expr ≫ » (to_stalk _ _) (PresheafedSpace.stalk_map X.to_Γ_Spec_SheafedSpace x) = X.Γ_to_stalk x :=\n  by\n  rw [PresheafedSpace.stalk_map]\n  erw [← to_open_germ _ (basic_open (1 : Γ.obj (op X))) ⟨X.to_Γ_Spec_fun x, by rw [basic_open_one] <;> trivial⟩]\n  rw [← category.assoc, category.assoc (to_open _ _)]\n  erw [stalk_functor_map_germ]\n  rw [← category.assoc (to_open _ _), X.to_Γ_Spec_SheafedSpace_app_spec 1]\n  unfold Γ_to_stalk\n  rw [← stalk_pushforward_germ _ X.to_Γ_Spec_base X.presheaf («expr⊤»)]\n  congr 1\n  change «expr ≫ » ((«expr _* » X.to_Γ_Spec_base X.presheaf).map le_top.hom.op) _ = _\n  apply germ_res\n#align to_stalk_stalk_map_to_Γ_Spec to_stalk_stalk_map_to_Γ_Spec\n\n",
 "right_triangle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- `Spec_Γ_identity` is iso so these are mutually two-sided inverses. -/\ntheorem right_triangle (R : CommRing) :\n    «expr ≫ » (identity_to_Γ_Spec.app (Spec.to_LocallyRingedSpace.obj <| op R))\n        (Spec.to_LocallyRingedSpace.map (Spec_Γ_identity.inv.app R).op) =\n      («expr𝟙») _ :=\n  by\n  apply LocallyRingedSpace.comp_ring_hom_ext\n  · ext ((p : prime_spectrum R)x)\n    erw [← is_localization.at_prime.to_map_mem_maximal_iff ((structure_sheaf R).presheaf.stalk p) p.as_ideal x]\n    rfl\n  · intro r\n    apply to_open_res\n#align right_triangle right_triangle\n\n",
 "not_mem_prime_iff_unit_in_stalk":
 "/-\nCopyright (c) 2021 Junyan Xu. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Junyan Xu\n-/\ntheorem not_mem_prime_iff_unit_in_stalk (r : Γ.obj (op X)) (x : X) :\n    r ∉ (X.to_Γ_Spec_fun x).as_ideal ↔ is_unit (X.Γ_to_stalk x r) := by erw [local_ring.mem_maximal_ideal, not_not]\n#align not_mem_prime_iff_unit_in_stalk not_mem_prime_iff_unit_in_stalk\n\n",
 "left_triangle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem left_triangle (X : LocallyRingedSpace) :\n    «expr ≫ » (Spec_Γ_identity.inv.app (Γ.obj (op X))) ((identity_to_Γ_Spec.app X).val.c.app (op («expr⊤»))) =\n      («expr𝟙») _ :=\n  X.Γ_Spec_left_triangle\n#align left_triangle left_triangle\n\n",
 "is_unit_res_to_Γ_Spec_map_basic_open":
 "/-- `r` is a unit as a section on the basic open defined by `r`. -/\ntheorem is_unit_res_to_Γ_Spec_map_basic_open : is_unit (X.to_to_Γ_Spec_map_basic_open r r) :=\n  by\n  convert\n    (X.presheaf.map <| (eq_to_hom <| X.to_Γ_Spec_map_basic_open_eq r).op).is_unit_map\n      (X.to_RingedSpace.is_unit_res_basic_open r)\n  rw [← comp_apply]\n  erw [← functor.map_comp]\n  congr\n#align is_unit_res_to_Γ_Spec_map_basic_open is_unit_res_to_Γ_Spec_map_basic_open\n\n",
 "comp_ring_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n-- show stalk map is local hom ↓\ntheorem comp_ring_hom_ext {X : LocallyRingedSpace} {R : CommRing} {f : «expr ⟶ » R (Γ.obj (op X))}\n    {β : «expr ⟶ » X (Spec.LocallyRingedSpace_obj R)}\n    (w : «expr ≫ » X.to_Γ_Spec.1.base (Spec.LocallyRingedSpace_map f).1.base = β.1.base)\n    (h :\n      ∀ r : R,\n        «expr ≫ » f (X.presheaf.map (hom_of_le le_top : «expr ⟶ » ((opens.map β.1.base).obj (basic_open r)) _).op) =\n          «expr ≫ » (to_open R (basic_open r)) (β.1.c.app (op (basic_open r)))) :\n    «expr ≫ » X.to_Γ_Spec (Spec.LocallyRingedSpace_map f) = β :=\n  by\n  ext1\n  apply Spec.basic_open_hom_ext\n  · intro r _\n    rw [LocallyRingedSpace.comp_val_c_app]\n    erw [to_open_comp_comap_assoc]\n    rw [category.assoc]\n    erw [to_Γ_Spec_SheafedSpace_app_spec, ← X.presheaf.map_comp]\n    convert h r\n  exact w\n#align comp_ring_hom_ext comp_ring_hom_ext\n\n",
 "adjunction_unit_app_app_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr _* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n-- This is just\n-- `(Γ_Spec.adjunction.unit.app X).1.c.app (op ⊤) = Spec_Γ_identity.hom.app (X.presheaf.obj (op ⊤))`\n-- But lean times out when trying to unify the types of the two sides.\ntheorem adjunction_unit_app_app_top (X : Scheme) :\n    @eq\n      («expr ⟶ » ((Scheme.Spec.obj (op <| X.presheaf.obj (op («expr⊤»)))).presheaf.obj (op («expr⊤»)))\n        ((«expr _* » (Γ_Spec.adjunction.unit.app X).1.base X.presheaf).obj (op («expr⊤»))))\n      ((Γ_Spec.adjunction.unit.app X).val.c.app (op («expr⊤»)))\n      (Spec_Γ_identity.hom.app (X.presheaf.obj (op («expr⊤»)))) :=\n  by\n  have := congr_app Γ_Spec.adjunction.left_triangle X\n  dsimp at this\n  rw [← is_iso.eq_comp_inv] at this\n  simp only [Γ_Spec.LocallyRingedSpace_adjunction_counit, nat_trans.op_app, category.id_comp,\n    Γ_Spec.adjunction_counit_app] at this\n  rw [← op_inv, nat_iso.inv_inv_app, quiver.hom.op_inj.eq_iff] at this\n  exact this\n#align adjunction_unit_app_app_top adjunction_unit_app_app_top\n\n",
 "adjunction_unit_app":
 "@[simp]\ntheorem adjunction_unit_app {X : Scheme} : Γ_Spec.adjunction.unit.app X = LocallyRingedSpace_adjunction.unit.app X.1 :=\n  by\n  rw [← adjunction.hom_equiv_id, ← adjunction.hom_equiv_id, adjunction_hom_equiv_apply]\n  rfl\n#align adjunction_unit_app adjunction_unit_app\n\n",
 "adjunction_hom_equiv_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem adjunction_hom_equiv_symm_apply {X : Scheme} {R : «expr ᵒᵖ» CommRing} (f : «expr ⟶ » X (Scheme.Spec.obj R)) :\n    (Γ_Spec.adjunction.hom_equiv X R).symm f = (LocallyRingedSpace_adjunction.hom_equiv X.1 R).symm f :=\n  by\n  congr 2\n  exact adjunction_hom_equiv _ _\n#align adjunction_hom_equiv_symm_apply adjunction_hom_equiv_symm_apply\n\n",
 "adjunction_hom_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- Removing this makes the following definition time out.\ntheorem adjunction_hom_equiv_apply {X : Scheme} {R : «expr ᵒᵖ» CommRing}\n    (f : «expr ⟶ » (op <| Scheme.Γ.obj <| op X) R) :\n    Γ_Spec.adjunction.hom_equiv X R f = LocallyRingedSpace_adjunction.hom_equiv X.1 R f :=\n  by\n  dsimp [adjunction, adjunction.restrict_fully_faithful]\n  simp\n#align adjunction_hom_equiv_apply adjunction_hom_equiv_apply\n\n",
 "adjunction_hom_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\ntheorem adjunction_hom_equiv (X : Scheme) (R : «expr ᵒᵖ» CommRing) :\n    Γ_Spec.adjunction.hom_equiv X R = LocallyRingedSpace_adjunction.hom_equiv X.1 R :=\n  equiv.ext fun f => adjunction_hom_equiv_apply f\n#align adjunction_hom_equiv adjunction_hom_equiv\n\n",
 "adjunction_counit_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n@[simp]\ntheorem adjunction_counit_app {R : «expr ᵒᵖ» CommRing} :\n    Γ_Spec.adjunction.counit.app R = LocallyRingedSpace_adjunction.counit.app R :=\n  by\n  rw [← adjunction.hom_equiv_symm_id, ← adjunction.hom_equiv_symm_id, adjunction_hom_equiv_symm_apply]\n  rfl\n#align adjunction_counit_app adjunction_counit_app\n\n"}