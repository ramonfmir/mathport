{"sup_limsup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_limsup [ne_bot f] (a : α) : «expr ⊔ » a (limsup u f) = limsup (fun x => «expr ⊔ » a (u x)) f :=\n  by\n  simp only [limsup_eq_infi_supr, supᵢ_sup_eq, sup_infᵢ₂_eq]\n  congr ; ext s; congr ; ext hs; congr\n  exact (bsupᵢ_const (nonempty_of_mem hs)).symm\n#align sup_limsup sup_limsup\n\n",
 "sup_liminf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_liminf (a : α) : «expr ⊔ » a (liminf u f) = liminf (fun x => «expr ⊔ » a (u x)) f :=\n  by\n  simp only [liminf_eq_supr_infi]\n  rw [sup_comm, bsupᵢ_sup (⟨univ, univ_mem⟩ : ∃ i : set β, i ∈ f)]\n  simp_rw [infᵢ₂_sup_eq, @sup_comm _ _ a]\n#align sup_liminf sup_liminf\n\n",
 "sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem is_bounded_under.sup [SemilatticeSup α] {f : filter β} {u v : β → α} :\n    f.is_bounded_under (· ≤ ·) u →\n      f.is_bounded_under (· ≤ ·) v → f.is_bounded_under (· ≤ ·) fun a => «expr ⊔ » (u a) (v a)\n  |\n  ⟨bu,\n      (hu :\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n          (u x ≤ bu))⟩,\n    ⟨bv,\n      (hv :\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n          (v x ≤ bv))⟩ =>\n    ⟨«expr ⊔ » bu bv,\n      show\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n          («expr ⊔ » (u x) (v x) ≤ «expr ⊔ » bu bv)\n        by filter_upwards [hu, hv] with _ using sup_le_sup⟩\n#align is_bounded_under.sup is_bounded_under.sup\n\n",
 "sdiff_limsup":
 "theorem sdiff_limsup [ne_bot f] (a : α) : a \\ limsup u f = liminf (fun b => a \\ u b) f :=\n  by\n  rw [← compl_inj_iff]\n  simp only [sdiff_eq, liminf_compl, (· ∘ ·), compl_inf, compl_compl, sup_limsup]\n#align sdiff_limsup sdiff_limsup\n\n",
 "sdiff_liminf":
 "theorem sdiff_liminf (a : α) : a \\ liminf u f = limsup (fun b => a \\ u b) f :=\n  by\n  rw [← compl_inj_iff]\n  simp only [sdiff_eq, limsup_compl, (· ∘ ·), compl_inf, compl_compl, sup_liminf]\n#align sdiff_liminf sdiff_liminf\n\n",
 "not_is_bounded_under_of_tendsto_at_top":
 "theorem not_is_bounded_under_of_tendsto_at_top [preorder β] [NoMaxOrder β] {f : α → β} {l : filter α} [l.ne_bot]\n    (hf : tendsto f l at_top) : ¬is_bounded_under (· ≤ ·) l f :=\n  by\n  rintro ⟨b, hb⟩\n  rw [eventually_map] at hb\n  obtain ⟨b', h⟩ := exists_gt b\n  have hb' := (tendsto_at_top.mp hf) b'\n  have : { x : α | f x ≤ b } ∩ { x : α | b' ≤ f x } = ∅ :=\n    eq_empty_of_subset_empty fun x hx => (not_le_of_lt h) (le_trans hx.2 hx.1)\n  exact (nonempty_of_mem (hb.and hb')).ne_empty this\n#align not_is_bounded_under_of_tendsto_at_top not_is_bounded_under_of_tendsto_at_top\n\n",
 "not_is_bounded_under_of_tendsto_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem not_is_bounded_under_of_tendsto_at_bot [preorder β] [NoMinOrder β] {f : α → β} {l : filter α} [l.ne_bot]\n    (hf : tendsto f l at_bot) : ¬is_bounded_under (· ≥ ·) l f :=\n  @not_is_bounded_under_of_tendsto_at_top α («expr ᵒᵈ» β) _ _ _ _ _ hf\n#align not_is_bounded_under_of_tendsto_at_bot not_is_bounded_under_of_tendsto_at_bot\n\n",
 "mono_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem is_bounded_under.mono_le [preorder β] {l : filter α} {u v : α → β} (hu : is_bounded_under (· ≤ ·) l u)\n    (hv : «expr ≤ᶠ[ ] » v l u) : is_bounded_under (· ≤ ·) l v :=\n  hu.imp fun b hb => (eventually_map.1 hb).mp <| hv.mono fun x => le_trans\n#align is_bounded_under.mono_le is_bounded_under.mono_le\n\n",
 "mono_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem is_bounded_under.mono_ge [preorder β] {l : filter α} {u v : α → β} (hu : is_bounded_under (· ≥ ·) l u)\n    (hv : «expr ≤ᶠ[ ] » u l v) : is_bounded_under (· ≥ ·) l v :=\n  @is_bounded_under.mono_le α («expr ᵒᵈ» β) _ _ _ _ hu hv\n#align is_bounded_under.mono_ge is_bounded_under.mono_ge\n\n",
 "mono_blimsup'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem mono_blimsup'\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (p x → u x ≤ v x)) :\n    blimsup u f p ≤ blimsup v f p :=\n  infₛ_le_infₛ fun a ha => (ha.and h).mono fun x hx hx' => (hx.2 hx').trans (hx.1 hx')\n#align mono_blimsup' mono_blimsup'\n\n",
 "mono_blimsup":
 "theorem mono_blimsup (h : ∀ x, p x → u x ≤ v x) : blimsup u f p ≤ blimsup v f p :=\n  mono_blimsup' <| eventually_of_forall h\n#align mono_blimsup mono_blimsup\n\n",
 "mono_bliminf'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem mono_bliminf'\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (p x → u x ≤ v x)) :\n    bliminf u f p ≤ bliminf v f p :=\n  supₛ_le_supₛ fun a ha => (ha.and h).mono fun x hx hx' => (hx.1 hx').trans (hx.2 hx')\n#align mono_bliminf' mono_bliminf'\n\n",
 "mono_bliminf":
 "theorem mono_bliminf (h : ∀ x, p x → u x ≤ v x) : bliminf u f p ≤ bliminf v f p :=\n  mono_bliminf' <| eventually_of_forall h\n#align mono_bliminf mono_bliminf\n\n",
 "mono":
 "theorem is_cobounded.mono (h : f ≤ g) : f.is_cobounded r → g.is_cobounded r\n  | ⟨b, hb⟩ => ⟨b, fun a ha => hb a (h ha)⟩\n#align is_cobounded.mono is_cobounded.mono\n\n",
 "mk":
 "/-- To check that a filter is frequently bounded, it suffices to have a witness\nwhich bounds `f` at some point for every admissible set.\n\nThis is only an implication, as the other direction is wrong for the trivial filter.-/\ntheorem is_cobounded.mk [is_trans α r] (a : α) (h : ∀ s ∈ f, ∃ x ∈ s, r a x) : f.is_cobounded r :=\n  ⟨a, fun y s =>\n    let ⟨x, h₁, h₂⟩ := h _ s\n    trans h₂ h₁⟩\n#align is_cobounded.mk is_cobounded.mk\n\n",
 "limsup_set_eq":
 "/-- In other words, `limsup cofinite s` is the set of elements lying inside the family `s`\ninfinitely often. -/\ntheorem cofinite.limsup_set_eq : limsup s cofinite = { x | { n | x ∈ s n }.infinite } := by\n  simp only [← cofinite.blimsup_true s, cofinite.blimsup_set_eq, true_and_iff]\n#align cofinite.limsup_set_eq cofinite.limsup_set_eq\n\n",
 "limsup_sdiff":
 "theorem limsup_sdiff (a : α) : limsup u f \\ a = limsup (fun b => u b \\ a) f :=\n  by\n  simp only [limsup_eq_infi_supr, sdiff_eq]\n  rw [binfᵢ_inf (⟨univ, univ_mem⟩ : ∃ i : set β, i ∈ f)]\n  simp_rw [inf_comm, inf_supᵢ₂_eq, inf_comm]\n#align limsup_sdiff limsup_sdiff\n\n",
 "limsup_nat_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem limsup_nat_add (f : ℕ → α) (k : ℕ) : limsup (fun i => f (i + k)) at_top = limsup f at_top :=\n  @liminf_nat_add («expr ᵒᵈ» α) _ f k\n#align limsup_nat_add limsup_nat_add\n\n",
 "limsup_le_supr":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic filter.is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem limsup_le_supr {f : filter β} {u : β → α} :\n    limsup u f ≤\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (u n) :=\n  limsup_le_of_le\n    (by\n      run_tac\n        is_bounded_default)\n    (eventually_of_forall (le_supᵢ u))\n#align limsup_le_supr limsup_le_supr\n\n",
 "limsup_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem limsup_le_of_le {f : filter β} {u : β → α} {a}\n    (hf : f.is_cobounded_under (· ≤ ·) u := by\n      run_tac\n        is_bounded_default)\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (u n ≤ a)) :\n    limsup u f ≤ a :=\n  cinfₛ_le hf h\n#align limsup_le_of_le limsup_le_of_le\n\n",
 "limsup_le_limsup_of_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\ntheorem limsup_le_limsup_of_le {α β} [ConditionallyCompleteLattice β] {f g : filter α} (h : f ≤ g) {u : α → β}\n    (hf : f.is_cobounded_under (· ≤ ·) u := by\n      run_tac\n        is_bounded_default)\n    (hg : g.is_bounded_under (· ≤ ·) u := by\n      run_tac\n        is_bounded_default) :\n    limsup u f ≤ limsup u g :=\n  Limsup_le_Limsup_of_le (map_mono h) hf hg\n#align limsup_le_limsup_of_le limsup_le_limsup_of_le\n\n",
 "limsup_le_limsup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\ntheorem limsup_le_limsup {α : Type _} [ConditionallyCompleteLattice β] {f : filter α} {u v : α → β}\n    (h : «expr ≤ᶠ[ ] » u f v)\n    (hu : f.is_cobounded_under (· ≤ ·) u := by\n      run_tac\n        is_bounded_default)\n    (hv : f.is_bounded_under (· ≤ ·) v := by\n      run_tac\n        is_bounded_default) :\n    limsup u f ≤ limsup v f :=\n  Limsup_le_Limsup hu hv fun b => h.trans\n#align limsup_le_limsup limsup_le_limsup\n\n",
 "limsup_eq_infi_supr_of_nat'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem limsup_eq_infi_supr_of_nat' {u : ℕ → α} :\n    limsup u at_top =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (u (i + n))) :=\n  by simp only [limsup_eq_infi_supr_of_nat, supᵢ_ge_eq_supᵢ_nat_add]\n#align limsup_eq_infi_supr_of_nat' limsup_eq_infi_supr_of_nat'\n\n",
 "limsup_eq_infi_supr_of_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem limsup_eq_infi_supr_of_nat {u : ℕ → α} :\n    limsup u at_top =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (u i)) :=\n  (at_top_basis.map u).Limsup_eq_infi_Sup.trans <| by simp only [supₛ_image, infᵢ_const] <;> rfl\n#align limsup_eq_infi_supr_of_nat limsup_eq_infi_supr_of_nat\n\n",
 "limsup_eq_infi_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem has_basis.limsup_eq_infi_supr {p : ι → Prop} {s : ι → set β} {f : filter β} {u : β → α} (h : f.has_basis p s) :\n    limsup u f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (u a)) :=\n  (h.map u).Limsup_eq_infi_Sup.trans <| by simp only [supₛ_image, id]\n#align has_basis.limsup_eq_infi_supr has_basis.limsup_eq_infi_supr\n\n",
 "limsup_eq_Inf_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem limsup_eq_Inf_Sup {ι R : Type _} (F : filter ι) [CompleteLattice R] (a : ι → R) :\n    limsup a F = infₛ («expr '' » (fun I => supₛ («expr '' » a I)) F.sets) :=\n  by\n  refine' le_antisymm _ _\n  · rw [limsup_eq]\n    refine' infₛ_le_infₛ fun x hx => _\n    rcases(mem_image _ F.sets x).mp hx with ⟨I, ⟨I_mem_F, hI⟩⟩\n    filter_upwards [I_mem_F] with i hi\n    exact hI ▸ le_supₛ (mem_image_of_mem _ hi)\n  · refine' le_Inf_iff.mpr fun b hb => infₛ_le_of_le (mem_image_of_mem _ <| filter.mem_sets.mpr hb) <| supₛ_le _\n    rintro _ ⟨_, h, rfl⟩\n    exact h\n#align limsup_eq_Inf_Sup limsup_eq_Inf_Sup\n\n",
 "limsup_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem limsup_eq :\n    limsup u f =\n      infₛ\n        { a |\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n            (u n ≤ a) } :=\n  rfl\n#align limsup_eq limsup_eq\n\n",
 "limsup_const_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- Same as limsup_const applied to `⊥` but without the `ne_bot f` assumption -/\ntheorem limsup_const_bot {f : filter β} : limsup (fun x : β => («expr⊥» : α)) f = («expr⊥» : α) :=\n  by\n  rw [limsup_eq, eq_bot_iff]\n  exact infₛ_le (eventually_of_forall fun x => le_rfl)\n#align limsup_const_bot limsup_const_bot\n\n",
 "limsup_const":
 "theorem limsup_const {α : Type _} [ConditionallyCompleteLattice β] {f : filter α} [ne_bot f] (b : β) :\n    limsup (fun x => b) f = b := by simpa only [limsup_eq, eventually_const] using cinfₛ_Ici\n#align limsup_const limsup_const\n\n",
 "limsup_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem limsup_congr {α : Type _} [ConditionallyCompleteLattice β] {f : filter α} {u v : α → β}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (u a = v a)) :\n    limsup u f = limsup v f := by\n  rw [limsup_eq]\n  congr with b\n  exact eventually_congr (h.mono fun x hx => by simp [hx])\n#align limsup_congr limsup_congr\n\n",
 "limsup_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem limsup_compl : «expr ᶜ» (limsup u f) = liminf (compl ∘ u) f := by\n  simp only [limsup_eq_infi_supr, liminf_eq_supr_infi, compl_infᵢ, compl_supᵢ]\n#align limsup_compl limsup_compl\n\n",
 "limsup_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\ntheorem order_iso.limsup_apply {γ} [ConditionallyCompleteLattice β] [ConditionallyCompleteLattice γ] {f : filter α}\n    {u : α → β} (g : «expr ≃o » β γ)\n    (hu : f.is_bounded_under (· ≤ ·) u := by\n      run_tac\n        is_bounded_default)\n    (hu_co : f.is_cobounded_under (· ≤ ·) u := by\n      run_tac\n        is_bounded_default)\n    (hgu : f.is_bounded_under (· ≤ ·) fun x => g (u x) := by\n      run_tac\n        is_bounded_default)\n    (hgu_co : f.is_cobounded_under (· ≤ ·) fun x => g (u x) := by\n      run_tac\n        is_bounded_default) :\n    g (limsup u f) = limsup (fun x => g (u x)) f :=\n  by\n  refine' le_antisymm (g.to_galois_connection.l_limsup_le hgu hu_co) _\n  rw [← g.symm.symm_apply_apply <| limsup (fun x => g (u x)) f, g.symm_symm]\n  refine' g.monotone _\n  have hf : u = fun i => g.symm (g (u i)) := funext fun i => (g.symm_apply_apply (u i)).symm\n  nth_rw 1 [hf]\n  refine' g.symm.to_galois_connection.l_limsup_le _ hgu_co\n  simp_rw [g.symm_apply_apply]\n  exact hu\n#align order_iso.limsup_apply order_iso.limsup_apply\n\n",
 "liminf_set_eq":
 "/-- In other words, `liminf cofinite s` is the set of elements lying outside the family `s`\nfinitely often. -/\ntheorem cofinite.liminf_set_eq : liminf s cofinite = { x | { n | x ∉ s n }.finite } := by\n  simp only [← cofinite.bliminf_true s, cofinite.bliminf_set_eq, true_and_iff]\n#align cofinite.liminf_set_eq cofinite.liminf_set_eq\n\n",
 "liminf_sdiff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem liminf_sdiff [ne_bot f] (a : α) : liminf u f \\ a = liminf (fun b => u b \\ a) f := by\n  simp only [sdiff_eq, @inf_comm _ _ _ («expr ᶜ» a), inf_liminf]\n#align liminf_sdiff liminf_sdiff\n\n",
 "liminf_nat_add":
 "@[simp]\ntheorem liminf_nat_add (f : ℕ → α) (k : ℕ) : liminf (fun i => f (i + k)) at_top = liminf f at_top :=\n  by\n  simp_rw [liminf_eq_supr_infi_of_nat]\n  exact supᵢ_infᵢ_ge_nat_add f k\n#align liminf_nat_add liminf_nat_add\n\n",
 "liminf_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem liminf_le_of_le {f : filter β} {u : β → α} {a}\n    (hf : f.is_bounded_under (· ≥ ·) u := by\n      run_tac\n        is_bounded_default)\n    (h :\n      ∀ b,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n            (b ≤ u n) →\n          b ≤ a) :\n    liminf u f ≤ a :=\n  csupₛ_le hf h\n#align liminf_le_of_le liminf_le_of_le\n\n",
 "liminf_le_of_frequently_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem liminf_le_of_frequently_le' {α β} [CompleteLattice β] {f : filter α} {u : α → β} {x : β}\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n        (u a ≤ x)) :\n    liminf u f ≤ x := by\n  rw [liminf_eq]\n  refine' supₛ_le fun b hb => _\n  have hbx :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (b ≤ x) :=\n    by\n    revert h\n    rw [← not_imp_not, not_frequently, not_frequently]\n    exact fun h => hb.mp (h.mono fun a hbx hba hax => hbx (hba.trans hax))\n  exact hbx.exists.some_spec\n#align liminf_le_of_frequently_le' liminf_le_of_frequently_le'\n\n",
 "liminf_le_of_frequently_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\ntheorem liminf_le_of_frequently_le {α β} [ConditionallyCompleteLinearOrder β] {f : filter α} {u : α → β} {b : β}\n    (hu_le :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n        (u x ≤ b))\n    (hu : f.is_bounded_under (· ≥ ·) u := by\n      run_tac\n        is_bounded_default) :\n    liminf u f ≤ b :=\n  @le_limsup_of_frequently_le _ («expr ᵒᵈ» β) _ f u b hu_le hu\n#align liminf_le_of_frequently_le liminf_le_of_frequently_le\n\n",
 "liminf_le_limsup":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\ntheorem liminf_le_limsup {f : filter β} [ne_bot f] {u : β → α}\n    (h : f.is_bounded_under (· ≤ ·) u := by\n      run_tac\n        is_bounded_default)\n    (h' : f.is_bounded_under (· ≥ ·) u := by\n      run_tac\n        is_bounded_default) :\n    liminf u f ≤ limsup u f :=\n  Liminf_le_Limsup h h'\n#align liminf_le_limsup liminf_le_limsup\n\n",
 "liminf_le_liminf_of_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\ntheorem liminf_le_liminf_of_le {α β} [ConditionallyCompleteLattice β] {f g : filter α} (h : g ≤ f) {u : α → β}\n    (hf : f.is_bounded_under (· ≥ ·) u := by\n      run_tac\n        is_bounded_default)\n    (hg : g.is_cobounded_under (· ≥ ·) u := by\n      run_tac\n        is_bounded_default) :\n    liminf u f ≤ liminf u g :=\n  Liminf_le_Liminf_of_le (map_mono h) hf hg\n#align liminf_le_liminf_of_le liminf_le_liminf_of_le\n\n",
 "liminf_le_liminf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\ntheorem liminf_le_liminf {α : Type _} [ConditionallyCompleteLattice β] {f : filter α} {u v : α → β}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (u a ≤ v a))\n    (hu : f.is_bounded_under (· ≥ ·) u := by\n      run_tac\n        is_bounded_default)\n    (hv : f.is_cobounded_under (· ≥ ·) v := by\n      run_tac\n        is_bounded_default) :\n    liminf u f ≤ liminf v f :=\n  @limsup_le_limsup («expr ᵒᵈ» β) α _ _ _ _ h hv hu\n#align liminf_le_liminf liminf_le_liminf\n\n",
 "liminf_eq_supr_infi_of_nat'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem liminf_eq_supr_infi_of_nat' {u : ℕ → α} :\n    liminf u at_top =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u (i + n))) :=\n  @limsup_eq_infi_supr_of_nat' («expr ᵒᵈ» α) _ _\n#align liminf_eq_supr_infi_of_nat' liminf_eq_supr_infi_of_nat'\n\n",
 "liminf_eq_supr_infi_of_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem liminf_eq_supr_infi_of_nat {u : ℕ → α} :\n    liminf u at_top =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u i)) :=\n  @limsup_eq_infi_supr_of_nat («expr ᵒᵈ» α) _ u\n#align liminf_eq_supr_infi_of_nat liminf_eq_supr_infi_of_nat\n\n",
 "liminf_eq_supr_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem has_basis.liminf_eq_supr_infi {p : ι → Prop} {s : ι → set β} {f : filter β} {u : β → α} (h : f.has_basis p s) :\n    liminf u f =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u a)) :=\n  @has_basis.limsup_eq_infi_supr («expr ᵒᵈ» α) _ _ _ _ _ _ _ h\n#align has_basis.liminf_eq_supr_infi has_basis.liminf_eq_supr_infi\n\n",
 "liminf_eq_Sup_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem liminf_eq_Sup_Inf {ι R : Type _} (F : filter ι) [CompleteLattice R] (a : ι → R) :\n    liminf a F = supₛ («expr '' » (fun I => infₛ («expr '' » a I)) F.sets) :=\n  @filter.limsup_eq_Inf_Sup ι (OrderDual R) _ _ a\n#align liminf_eq_Sup_Inf liminf_eq_Sup_Inf\n\n",
 "liminf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem liminf_eq :\n    liminf u f =\n      supₛ\n        { a |\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n            (a ≤ u n) } :=\n  rfl\n#align liminf_eq liminf_eq\n\n",
 "liminf_const_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Same as limsup_const applied to `⊤` but without the `ne_bot f` assumption -/\ntheorem liminf_const_top {f : filter β} : liminf (fun x : β => («expr⊤» : α)) f = («expr⊤» : α) :=\n  @limsup_const_bot («expr ᵒᵈ» α) β _ _\n#align liminf_const_top liminf_const_top\n\n",
 "liminf_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem liminf_const {α : Type _} [ConditionallyCompleteLattice β] {f : filter α} [ne_bot f] (b : β) :\n    liminf (fun x => b) f = b :=\n  @limsup_const («expr ᵒᵈ» β) α _ f _ b\n#align liminf_const liminf_const\n\n",
 "liminf_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem liminf_congr {α : Type _} [ConditionallyCompleteLattice β] {f : filter α} {u v : α → β}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (u a = v a)) :\n    liminf u f = liminf v f :=\n  @limsup_congr («expr ᵒᵈ» β) _ _ _ _ _ h\n#align liminf_congr liminf_congr\n\n",
 "liminf_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem liminf_compl : «expr ᶜ» (liminf u f) = limsup (compl ∘ u) f := by\n  simp only [limsup_eq_infi_supr, liminf_eq_supr_infi, compl_infᵢ, compl_supᵢ]\n#align liminf_compl liminf_compl\n\n",
 "liminf_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\ntheorem order_iso.liminf_apply {γ} [ConditionallyCompleteLattice β] [ConditionallyCompleteLattice γ] {f : filter α}\n    {u : α → β} (g : «expr ≃o » β γ)\n    (hu : f.is_bounded_under (· ≥ ·) u := by\n      run_tac\n        is_bounded_default)\n    (hu_co : f.is_cobounded_under (· ≥ ·) u := by\n      run_tac\n        is_bounded_default)\n    (hgu : f.is_bounded_under (· ≥ ·) fun x => g (u x) := by\n      run_tac\n        is_bounded_default)\n    (hgu_co : f.is_cobounded_under (· ≥ ·) fun x => g (u x) := by\n      run_tac\n        is_bounded_default) :\n    g (liminf u f) = liminf (fun x => g (u x)) f :=\n  @order_iso.limsup_apply α («expr ᵒᵈ» β) («expr ᵒᵈ» γ) _ _ f u g.dual hu hu_co hgu hgu_co\n#align order_iso.liminf_apply order_iso.liminf_apply\n\n",
 "le_limsup_of_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem le_limsup_of_le {f : filter β} {u : β → α} {a}\n    (hf : f.is_bounded_under (· ≤ ·) u := by\n      run_tac\n        is_bounded_default)\n    (h :\n      ∀ b,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n            (u n ≤ b) →\n          a ≤ b) :\n    a ≤ limsup u f :=\n  le_cinfₛ hf h\n#align le_limsup_of_le le_limsup_of_le\n\n",
 "le_limsup_of_frequently_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem le_limsup_of_frequently_le' {α β} [CompleteLattice β] {f : filter α} {u : α → β} {x : β}\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n        (x ≤ u a)) :\n    x ≤ limsup u f :=\n  @liminf_le_of_frequently_le' _ («expr ᵒᵈ» β) _ _ _ _ h\n#align le_limsup_of_frequently_le' le_limsup_of_frequently_le'\n\n",
 "le_limsup_of_frequently_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\ntheorem le_limsup_of_frequently_le {α β} [ConditionallyCompleteLinearOrder β] {f : filter α} {u : α → β} {b : β}\n    (hu_le :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n        (b ≤ u x))\n    (hu : f.is_bounded_under (· ≤ ·) u := by\n      run_tac\n        is_bounded_default) :\n    b ≤ limsup u f := by\n  revert hu_le\n  rw [← not_imp_not, not_frequently]\n  simp_rw [← lt_iff_not_ge]\n  exact fun h => eventually_lt_of_limsup_lt h hu\n#align le_limsup_of_frequently_le le_limsup_of_frequently_le\n\n",
 "le_liminf_of_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem le_liminf_of_le {f : filter β} {u : β → α} {a}\n    (hf : f.is_cobounded_under (· ≥ ·) u := by\n      run_tac\n        is_bounded_default)\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (a ≤ u n)) :\n    a ≤ liminf u f :=\n  le_csupₛ hf h\n#align le_liminf_of_le le_liminf_of_le\n\n",
 "le_apply_bliminf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem Inf_hom.le_apply_bliminf [CompleteLattice γ] (g : Inf_hom α γ) : bliminf (g ∘ u) f p ≤ g (bliminf u f p) :=\n  @Sup_hom.apply_blimsup_le («expr ᵒᵈ» α) β («expr ᵒᵈ» γ) _ f p u _ g.dual\n#align Inf_hom.le_apply_bliminf Inf_hom.le_apply_bliminf\n\n",
 "le_Limsup_of_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem le_Limsup_of_le {f : filter α} {a}\n    (hf : f.is_bounded (· ≤ ·) := by\n      run_tac\n        is_bounded_default)\n    (h :\n      ∀ b,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n            (n ≤ b) →\n          a ≤ b) :\n    a ≤ Limsup f :=\n  le_cinfₛ hf h\n#align le_Limsup_of_le le_Limsup_of_le\n\n",
 "le_Liminf_of_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem le_Liminf_of_le {f : filter α} {a}\n    (hf : f.is_cobounded (· ≥ ·) := by\n      run_tac\n        is_bounded_default)\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (a ≤ n)) :\n    a ≤ Liminf f :=\n  le_csupₛ hf h\n#align le_Liminf_of_le le_Liminf_of_le\n\n",
 "l_limsup_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\ntheorem galois_connection.l_limsup_le [ConditionallyCompleteLattice β] [ConditionallyCompleteLattice γ] {f : filter α}\n    {v : α → β} {l : β → γ} {u : γ → β} (gc : GaloisConnection l u)\n    (hlv : f.is_bounded_under (· ≤ ·) fun x => l (v x) := by\n      run_tac\n        is_bounded_default)\n    (hv_co : f.is_cobounded_under (· ≤ ·) v := by\n      run_tac\n        is_bounded_default) :\n    l (limsup v f) ≤ limsup (fun x => l (v x)) f :=\n  by\n  refine' le_Limsup_of_le hlv fun c hc => _\n  rw [filter.eventually_map] at hc\n  simp_rw [gc _ _] at hc⊢\n  exact Limsup_le_of_le hv_co hc\n#align galois_connection.l_limsup_le galois_connection.l_limsup_le\n\n",
 "is_cobounded_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_cobounded_top : is_cobounded r («expr⊤») ↔ nonempty α := by\n  simp (config := { contextual := true }) [is_cobounded, eq_univ_iff_forall, exists_true_iff_nonempty]\n#align is_cobounded_top is_cobounded_top\n\n",
 "is_cobounded_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_cobounded_principal (s : set α) :\n    ((filter.principal) s).is_cobounded r ↔ ∃ b, ∀ a, (∀ x ∈ s, r x a) → r b a := by simp [is_cobounded, subset_def]\n#align is_cobounded_principal is_cobounded_principal\n\n",
 "is_cobounded_le_of_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_cobounded_le_of_bot [preorder α] [OrderBot α] {f : filter α} : f.is_cobounded (· ≤ ·) :=\n  ⟨«expr⊥», fun a h => bot_le⟩\n#align is_cobounded_le_of_bot is_cobounded_le_of_bot\n\n",
 "is_cobounded_le":
 "theorem is_bounded.is_cobounded_le [preorder α] [ne_bot f] (h : f.is_bounded (· ≥ ·)) : f.is_cobounded (· ≤ ·) :=\n  h.is_cobounded_flip\n#align is_bounded.is_cobounded_le is_bounded.is_cobounded_le\n\n",
 "is_cobounded_ge_of_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_cobounded_ge_of_top [preorder α] [OrderTop α] {f : filter α} : f.is_cobounded (· ≥ ·) :=\n  ⟨«expr⊤», fun a h => le_top⟩\n#align is_cobounded_ge_of_top is_cobounded_ge_of_top\n\n",
 "is_cobounded_ge":
 "theorem is_bounded.is_cobounded_ge [preorder α] [ne_bot f] (h : f.is_bounded (· ≤ ·)) : f.is_cobounded (· ≥ ·) :=\n  h.is_cobounded_flip\n#align is_bounded.is_cobounded_ge is_bounded.is_cobounded_ge\n\n",
 "is_cobounded_flip":
 "/-- A filter which is eventually bounded is in particular frequently bounded (in the opposite\ndirection). At least if the filter is not trivial. -/\ntheorem is_bounded.is_cobounded_flip [is_trans α r] [ne_bot f] : f.is_bounded r → f.is_cobounded (flip r)\n  | ⟨a, ha⟩ =>\n    ⟨a, fun b hb =>\n      let ⟨x, rxa, rbx⟩ := (ha.and hb).exists\n      show r b a from trans rbx rxa⟩\n#align is_bounded.is_cobounded_flip is_bounded.is_cobounded_flip\n\n",
 "is_cobounded_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_cobounded_bot : is_cobounded r («expr⊥») ↔ ∃ b, ∀ x, r b x := by simp [is_cobounded]\n#align is_cobounded_bot is_cobounded_bot\n\n",
 "is_bounded_under_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- A bounded function `u` is in particular eventually bounded. -/\ntheorem is_bounded_under_of {f : filter β} {u : β → α} : (∃ b, ∀ x, r (u x) b) → f.is_bounded_under r u\n  | ⟨b, hb⟩ =>\n    ⟨b,\n      show\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n          (r (u x) b)\n        from eventually_of_forall hb⟩\n#align is_bounded_under_of is_bounded_under_of\n\n",
 "is_bounded_under_le_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem is_bounded_under_le_sup [SemilatticeSup α] {f : filter β} {u v : β → α} :\n    (f.is_bounded_under (· ≤ ·) fun a => «expr ⊔ » (u a) (v a)) ↔\n      f.is_bounded_under (· ≤ ·) u ∧ f.is_bounded_under (· ≤ ·) v :=\n  ⟨fun h =>\n    ⟨h.mono_le <| eventually_of_forall fun _ => le_sup_left, h.mono_le <| eventually_of_forall fun _ => le_sup_right⟩,\n    fun h => h.1.sup h.2⟩\n#align is_bounded_under_le_sup is_bounded_under_le_sup\n\n",
 "is_bounded_under_le_inv":
 "@[simp, to_additive]\ntheorem is_bounded_under_le_inv [OrderedCommGroup α] {l : filter β} {u : β → α} :\n    (is_bounded_under (· ≤ ·) l fun x => (u x)⁻¹) ↔ is_bounded_under (· ≥ ·) l u :=\n  (OrderIso.inv α).is_bounded_under_ge_comp\n#align is_bounded_under_le_inv is_bounded_under_le_inv\n\n",
 "is_bounded_under_le_comp":
 "theorem antitone.is_bounded_under_le_comp [nonempty β] [linear_order β] [preorder γ] [NoMaxOrder γ] {g : β → γ}\n    {f : α → β} {l : filter α} (hg : antitone g) (hg' : tendsto g at_bot at_top) :\n    is_bounded_under (· ≤ ·) l (g ∘ f) ↔ is_bounded_under (· ≥ ·) l f :=\n  hg.dual_right.is_bounded_under_ge_comp hg'\n#align antitone.is_bounded_under_le_comp antitone.is_bounded_under_le_comp\n\n",
 "is_bounded_under_le_abs":
 "theorem is_bounded_under_le_abs [LinearOrderedAddCommGroup α] {f : filter β} {u : β → α} :\n    (f.is_bounded_under (· ≤ ·) fun a => |u a|) ↔ f.is_bounded_under (· ≤ ·) u ∧ f.is_bounded_under (· ≥ ·) u :=\n  is_bounded_under_le_sup.trans <| and_congr iff.rfl is_bounded_under_le_neg\n#align is_bounded_under_le_abs is_bounded_under_le_abs\n\n",
 "is_bounded_under_ge_inv":
 "@[simp, to_additive]\ntheorem is_bounded_under_ge_inv [OrderedCommGroup α] {l : filter β} {u : β → α} :\n    (is_bounded_under (· ≥ ·) l fun x => (u x)⁻¹) ↔ is_bounded_under (· ≤ ·) l u :=\n  (OrderIso.inv α).is_bounded_under_le_comp\n#align is_bounded_under_ge_inv is_bounded_under_ge_inv\n\n",
 "is_bounded_under_ge_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem is_bounded_under_ge_inf [SemilatticeInf α] {f : filter β} {u v : β → α} :\n    (f.is_bounded_under (· ≥ ·) fun a => «expr ⊓ » (u a) (v a)) ↔\n      f.is_bounded_under (· ≥ ·) u ∧ f.is_bounded_under (· ≥ ·) v :=\n  @is_bounded_under_le_sup («expr ᵒᵈ» α) _ _ _ _ _\n#align is_bounded_under_ge_inf is_bounded_under_ge_inf\n\n",
 "is_bounded_under_ge_comp":
 "theorem antitone.is_bounded_under_ge_comp [nonempty β] [linear_order β] [preorder γ] [NoMinOrder γ] {g : β → γ}\n    {f : α → β} {l : filter α} (hg : antitone g) (hg' : tendsto g at_top at_bot) :\n    is_bounded_under (· ≥ ·) l (g ∘ f) ↔ is_bounded_under (· ≤ ·) l f :=\n  hg.dual_right.is_bounded_under_le_comp hg'\n#align antitone.is_bounded_under_ge_comp antitone.is_bounded_under_ge_comp\n\n",
 "is_bounded_under_const":
 "theorem is_bounded_under_const [is_refl α r] {l : filter β} {a : α} : is_bounded_under r l fun _ => a :=\n  ⟨a, eventually_map.2 <| eventually_of_forall fun _ => refl _⟩\n#align is_bounded_under_const is_bounded_under_const\n\n",
 "is_bounded_under":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem is_bounded.is_bounded_under {q : β → β → Prop} {u : α → β} (hf : ∀ a₀ a₁, r a₀ a₁ → q (u a₀) (u a₁)) :\n    f.is_bounded r → f.is_bounded_under q u\n  | ⟨b, h⟩ =>\n    ⟨u b,\n      show\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n          (q (u x) (u b))\n        from h.mono fun x => hf x b⟩\n#align is_bounded.is_bounded_under is_bounded.is_bounded_under\n\n",
 "is_bounded_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_bounded_top : is_bounded r («expr⊤») ↔ ∃ t, ∀ x, r x t := by simp [is_bounded, eq_univ_iff_forall]\n#align is_bounded_top is_bounded_top\n\n",
 "is_bounded_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem is_bounded_sup [is_trans α r] (hr : ∀ b₁ b₂, ∃ b, r b₁ b ∧ r b₂ b) :\n    is_bounded r f → is_bounded r g → is_bounded r («expr ⊔ » f g)\n  | ⟨b₁, h₁⟩, ⟨b₂, h₂⟩ =>\n    let ⟨b, rb₁b, rb₂b⟩ := hr b₁ b₂\n    ⟨b, eventually_sup.mpr ⟨h₁.mono fun x h => trans h rb₁b, h₂.mono fun x h => trans h rb₂b⟩⟩\n#align is_bounded_sup is_bounded_sup\n\n",
 "is_bounded_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_bounded_principal (s : set α) : is_bounded r ((filter.principal) s) ↔ ∃ t, ∀ x ∈ s, r x t := by\n  simp [is_bounded, subset_def]\n#align is_bounded_principal is_bounded_principal\n\n",
 "is_bounded_le_of_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_bounded_le_of_top [preorder α] [OrderTop α] {f : filter α} : f.is_bounded (· ≤ ·) :=\n  ⟨«expr⊤», eventually_of_forall fun _ => le_top⟩\n#align is_bounded_le_of_top is_bounded_le_of_top\n\n",
 "is_bounded_iff":
 "/-\nCopyright (c) 2018 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel, Johannes Hölzl, Rémy Degenne\n-/\n/-- `f` is eventually bounded if and only if, there exists an admissible set on which it is\nbounded. -/\ntheorem is_bounded_iff : f.is_bounded r ↔ ∃ s ∈ f.sets, ∃ b, s ⊆ { x | r x b } :=\n  iff.intro (fun ⟨b, hb⟩ => ⟨{ a | r a b }, hb, b, Subset.refl _⟩) fun ⟨s, hs, b, hb⟩ => ⟨b, mem_of_superset hs hb⟩\n#align is_bounded_iff is_bounded_iff\n\n",
 "is_bounded_ge_of_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_bounded_ge_of_bot [preorder α] [OrderBot α] {f : filter α} : f.is_bounded (· ≥ ·) :=\n  ⟨«expr⊥», eventually_of_forall fun _ => bot_le⟩\n#align is_bounded_ge_of_bot is_bounded_ge_of_bot\n\n",
 "is_bounded_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_bounded_bot : is_bounded r («expr⊥») ↔ nonempty α := by simp [is_bounded, exists_true_iff_nonempty]\n#align is_bounded_bot is_bounded_bot\n\n",
 "infi_le_liminf":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic filter.is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem infi_le_liminf {f : filter β} {u : β → α} :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u n) ≤\n      liminf u f :=\n  le_liminf_of_le\n    (by\n      run_tac\n        is_bounded_default)\n    (eventually_of_forall (infᵢ_le u))\n#align infi_le_liminf infi_le_liminf\n\n",
 "inf_limsup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_limsup (a : α) : «expr ⊓ » a (limsup u f) = limsup (fun x => «expr ⊓ » a (u x)) f :=\n  @sup_liminf («expr ᵒᵈ» α) β _ f _ _\n#align inf_limsup inf_limsup\n\n",
 "inf_liminf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_liminf [ne_bot f] (a : α) : «expr ⊓ » a (liminf u f) = liminf (fun x => «expr ⊓ » a (u x)) f :=\n  @sup_limsup («expr ᵒᵈ» α) β _ f _ _ _\n#align inf_liminf inf_liminf\n\n",
 "inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem is_bounded_under.inf [SemilatticeInf α] {f : filter β} {u v : β → α} :\n    f.is_bounded_under (· ≥ ·) u →\n      f.is_bounded_under (· ≥ ·) v → f.is_bounded_under (· ≥ ·) fun a => «expr ⊓ » (u a) (v a) :=\n  @is_bounded_under.sup («expr ᵒᵈ» α) β _ _ _ _\n#align is_bounded_under.inf is_bounded_under.inf\n\n",
 "frequently_lt_of_lt_limsup":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_lt_of_lt_limsup {α β} [ConditionallyCompleteLinearOrder β] {f : filter α} {u : α → β} {b : β}\n    (hu : f.is_cobounded_under (· ≤ ·) u := by\n      run_tac\n        is_bounded_default)\n    (h : b < limsup u f) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n      (b < u x) :=\n  by\n  contrapose! h\n  apply Limsup_le_of_le hu\n  simpa using h\n#align frequently_lt_of_lt_limsup frequently_lt_of_lt_limsup\n\n",
 "frequently_lt_of_lt_Limsup":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_lt_of_lt_Limsup {f : filter α} [ConditionallyCompleteLinearOrder α] {a : α}\n    (hf : f.is_cobounded (· ≤ ·) := by\n      run_tac\n        is_bounded_default)\n    (h : a < Limsup f) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (a < n) :=\n  by\n  contrapose! h\n  simp only [not_frequently, not_lt] at h\n  exact Limsup_le_of_le hf h\n#align frequently_lt_of_lt_Limsup frequently_lt_of_lt_Limsup\n\n",
 "frequently_lt_of_liminf_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_lt_of_liminf_lt {α β} [ConditionallyCompleteLinearOrder β] {f : filter α} {u : α → β} {b : β}\n    (hu : f.is_cobounded_under (· ≥ ·) u := by\n      run_tac\n        is_bounded_default)\n    (h : liminf u f < b) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n      (u x < b) :=\n  @frequently_lt_of_lt_limsup _ («expr ᵒᵈ» β) _ f u b hu h\n#align frequently_lt_of_liminf_lt frequently_lt_of_liminf_lt\n\n",
 "frequently_lt_of_Liminf_lt":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_lt_of_Liminf_lt {f : filter α} [ConditionallyCompleteLinearOrder α] {a : α}\n    (hf : f.is_cobounded (· ≥ ·) := by\n      run_tac\n        is_bounded_default)\n    (h : Liminf f < a) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (n < a) :=\n  @frequently_lt_of_lt_Limsup (OrderDual α) f _ a hf h\n#align frequently_lt_of_Liminf_lt frequently_lt_of_Liminf_lt\n\n",
 "exists_forall_mem_of_has_basis_mem_blimsup'":
 "theorem exists_forall_mem_of_has_basis_mem_blimsup' {l : filter β} {b : ι → set β} (hl : l.has_basis (fun _ => true) b)\n    {u : β → set α} {p : β → Prop} {x : α} (hx : x ∈ blimsup u l p) :\n    ∃ f : ι → β, ∀ i, x ∈ u (f i) ∧ p (f i) ∧ f i ∈ b i :=\n  by\n  obtain ⟨f, hf⟩ := exists_forall_mem_of_has_basis_mem_blimsup hl hx\n  exact ⟨fun i => f ⟨i, trivial⟩, fun i => hf ⟨i, trivial⟩⟩\n#align exists_forall_mem_of_has_basis_mem_blimsup' exists_forall_mem_of_has_basis_mem_blimsup'\n\n",
 "exists_forall_mem_of_has_basis_mem_blimsup":
 "theorem exists_forall_mem_of_has_basis_mem_blimsup {l : filter β} {b : ι → set β} {q : ι → Prop} (hl : l.has_basis q b)\n    {u : β → set α} {p : β → Prop} {x : α} (hx : x ∈ blimsup u l p) :\n    ∃ f : { i | q i } → β, ∀ i, x ∈ u (f i) ∧ p (f i) ∧ f i ∈ b i :=\n  by\n  rw [blimsup_eq_infi_bsupr] at hx\n  simp only [supr_eq_Union, infi_eq_Inter, mem_Inter, mem_Union, exists_prop] at hx\n  choose g hg hg' using hx\n  refine' ⟨fun i : { i | q i } => g (b i) (hl.mem_of_mem i.2), fun i => ⟨_, _⟩⟩\n  · exact hg' (b i) (hl.mem_of_mem i.2)\n  · exact hg (b i) (hl.mem_of_mem i.2)\n#align exists_forall_mem_of_has_basis_mem_blimsup exists_forall_mem_of_has_basis_mem_blimsup\n\n",
 "eventually_lt_of_lt_liminf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_lt_of_lt_liminf {f : filter α} [ConditionallyCompleteLinearOrder β] {u : α → β} {b : β}\n    (h : b < liminf u f)\n    (hu : f.is_bounded_under (· ≥ ·) u := by\n      run_tac\n        is_bounded_default) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n      (b < u a) :=\n  by\n  obtain ⟨c, hc, hbc⟩ :\n    ∃ (c : β)(hc :\n      c ∈\n        { c : β |\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n            (c ≤ u n) }),\n      b < c :=\n    exists_lt_of_lt_csupₛ hu h\n  exact hc.mono fun x hx => lt_of_lt_of_le hbc hx\n#align eventually_lt_of_lt_liminf eventually_lt_of_lt_liminf\n\n",
 "eventually_lt_of_limsup_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_lt_of_limsup_lt {f : filter α} [ConditionallyCompleteLinearOrder β] {u : α → β} {b : β}\n    (h : limsup u f < b)\n    (hu : f.is_bounded_under (· ≤ ·) u := by\n      run_tac\n        is_bounded_default) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n      (u a < b) :=\n  @eventually_lt_of_lt_liminf _ («expr ᵒᵈ» β) _ _ _ _ h hu\n#align eventually_lt_of_limsup_lt eventually_lt_of_limsup_lt\n\n",
 "blimsup_true":
 "@[simp]\ntheorem blimsup_true (f : filter β) (u : β → α) : (blimsup u f fun x => true) = limsup u f := by\n  simp [blimsup_eq, limsup_eq]\n#align blimsup_true blimsup_true\n\n",
 "blimsup_sup_le_or":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- See also `filter.blimsup_or_eq_sup`. -/\n@[simp]\ntheorem blimsup_sup_le_or : «expr ⊔ » (blimsup u f p) (blimsup u f q) ≤ blimsup u f fun x => p x ∨ q x :=\n  sup_le (blimsup_mono <| by tauto) (blimsup_mono <| by tauto)\n#align blimsup_sup_le_or blimsup_sup_le_or\n\n",
 "blimsup_set_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem cofinite.blimsup_set_eq : blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.infinite } :=\n  by\n  simp only [blimsup_eq, le_eq_subset, eventually_cofinite, not_forall, Inf_eq_sInter, exists_prop]\n  ext x\n  refine' ⟨fun h => _, fun hx t h => _⟩ <;> contrapose! h\n  · simp only [mem_sInter, mem_set_of_eq, not_forall, exists_prop]\n    exact ⟨«expr ᶜ» {x}, by simpa using h, by simp⟩\n  · exact hx.mono fun i hi => ⟨hi.1, fun hit => h (hit hi.2)⟩\n#align cofinite.blimsup_set_eq cofinite.blimsup_set_eq\n\n",
 "blimsup_or_eq_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem blimsup_or_eq_sup : (blimsup u f fun x => p x ∨ q x) = «expr ⊔ » (blimsup u f p) (blimsup u f q) :=\n  by\n  refine' le_antisymm _ blimsup_sup_le_or\n  simp only [blimsup_eq, infₛ_sup_eq, sup_infₛ_eq, le_infᵢ₂_iff, mem_set_of_eq]\n  refine' fun a' ha' a ha => infₛ_le ((ha.and ha').mono fun b h hb => _)\n  exact or.elim hb (fun hb => le_sup_of_le_left <| h.1 hb) fun hb => le_sup_of_le_right <| h.2 hb\n#align blimsup_or_eq_sup blimsup_or_eq_sup\n\n",
 "blimsup_monotone_filter":
 "theorem blimsup_monotone_filter (h : f ≤ g) : blimsup u f p ≤ blimsup u g p :=\n  infₛ_le_infₛ fun a ha => ha.filter_mono h\n#align blimsup_monotone_filter blimsup_monotone_filter\n\n",
 "blimsup_mono":
 "theorem blimsup_mono (h : ∀ x, p x → q x) : blimsup u f p ≤ blimsup u f q :=\n  infₛ_le_infₛ fun a ha => ha.mono <| by tauto\n#align blimsup_mono blimsup_mono\n\n",
 "blimsup_false":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem blimsup_false {f : filter β} {u : β → α} : (blimsup u f fun x => false) = «expr⊥» := by simp [blimsup_eq]\n#align blimsup_false blimsup_false\n\n",
 "blimsup_eq_limsup_subtype":
 "theorem blimsup_eq_limsup_subtype {f : filter β} {u : β → α} {p : β → Prop} :\n    blimsup u f p = limsup (u ∘ (coe : { x | p x } → β)) (comap coe f) :=\n  by\n  simp only [blimsup_eq, limsup_eq, Function.comp_apply, eventually_comap, SetCoe.forall, subtype.coe_mk, mem_set_of_eq]\n  congr\n  ext a\n  exact\n    eventually_congr\n      (eventually_of_forall fun x => ⟨fun hx y hy hxy => hxy.symm ▸ hx (hxy ▸ hy), fun hx hx' => hx x hx' rfl⟩)\n#align blimsup_eq_limsup_subtype blimsup_eq_limsup_subtype\n\n",
 "blimsup_eq_infi_bsupr_of_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem blimsup_eq_infi_bsupr_of_nat {p : ℕ → Prop} {u : ℕ → α} :\n    blimsup u at_top p =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (u j)) :=\n  by\n  simp only [blimsup_eq_limsup_subtype, mem_preimage, mem_Ici, Function.comp_apply, cinfᵢ_pos, supᵢ_subtype,\n    (at_top_basis.comap (coe : { x | p x } → ℕ)).limsup_eq_infi_supr, mem_set_of_eq, subtype.coe_mk, supᵢ_and]\n#align blimsup_eq_infi_bsupr_of_nat blimsup_eq_infi_bsupr_of_nat\n\n",
 "blimsup_eq_infi_bsupr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem blimsup_eq_infi_bsupr {f : filter β} {p : β → Prop} {u : β → α} :\n    blimsup u f p =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (u b)) :=\n  by\n  refine' le_antisymm (infₛ_le_infₛ _) (infi_le_iff.mpr fun a ha => le_Inf_iff.mpr fun a' ha' => _)\n  · rintro - ⟨s, rfl⟩\n    simp only [mem_set_of_eq, le_infᵢ_iff]\n    conv =>\n      congr\n      ext\n      rw [imp.swap]\n    refine' eventually_imp_distrib_left.mpr fun h => eventually_iff_exists_mem.2 ⟨s, h, fun x h₁ h₂ => _⟩\n    exact @le_supᵢ₂ α β (fun b => p b ∧ b ∈ s) _ (fun b hb => u b) x ⟨h₂, h₁⟩\n  · obtain ⟨s, hs, hs'⟩ := eventually_iff_exists_mem.mp ha'\n    simp_rw [imp.swap] at hs'\n    exact (le_infi_iff.mp (ha s) hs).trans (by simpa only [supᵢ₂_le_iff, and_imp] )\n#align blimsup_eq_infi_bsupr blimsup_eq_infi_bsupr\n\n",
 "blimsup_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem blimsup_eq :\n    blimsup u f p =\n      infₛ\n        { a |\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n            (p x → u x ≤ a) } :=\n  rfl\n#align blimsup_eq blimsup_eq\n\n",
 "blimsup_congr'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem blimsup_congr' {f : filter β} {p q : β → Prop} {u : β → α}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (u x ≠ «expr⊥» → (p x ↔ q x))) :\n    blimsup u f p = blimsup u f q := by\n  simp only [blimsup_eq]\n  congr\n  ext a\n  refine' eventually_congr (h.mono fun b hb => _)\n  cases' eq_or_ne (u b) («expr⊥») with hu hu; · simp [hu]\n  rw [hb hu]\n#align blimsup_congr' blimsup_congr'\n\n",
 "blimsup_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem blimsup_congr {f : filter β} {u v : β → α} {p : β → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (p a → u a = v a)) :\n    blimsup u f p = blimsup v f p := by\n  rw [blimsup_eq]\n  congr with b\n  refine' eventually_congr (h.mono fun x hx => ⟨fun h₁ h₂ => _, fun h₁ h₂ => _⟩)\n  · rw [← hx h₂]\n    exact h₁ h₂\n  · rw [hx h₂]\n    exact h₁ h₂\n#align blimsup_congr blimsup_congr\n\n",
 "blimsup_and_le_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem blimsup_and_le_inf : (blimsup u f fun x => p x ∧ q x) ≤ «expr ⊓ » (blimsup u f p) (blimsup u f q) :=\n  le_inf (blimsup_mono <| by tauto) (blimsup_mono <| by tauto)\n#align blimsup_and_le_inf blimsup_and_le_inf\n\n",
 "bliminf_true":
 "@[simp]\ntheorem bliminf_true (f : filter β) (u : β → α) : (bliminf u f fun x => true) = liminf u f := by\n  simp [bliminf_eq, liminf_eq]\n#align bliminf_true bliminf_true\n\n",
 "bliminf_sup_le_and":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem bliminf_sup_le_and : «expr ⊔ » (bliminf u f p) (bliminf u f q) ≤ bliminf u f fun x => p x ∧ q x :=\n  @blimsup_and_le_inf («expr ᵒᵈ» α) β _ f p q u\n#align bliminf_sup_le_and bliminf_sup_le_and\n\n",
 "bliminf_set_eq":
 "theorem cofinite.bliminf_set_eq : bliminf s cofinite p = { x | { n | p n ∧ x ∉ s n }.finite } :=\n  by\n  rw [← compl_inj_iff]\n  simpa only [bliminf_eq_supr_binfi, compl_infᵢ, compl_supᵢ, ← blimsup_eq_infi_bsupr, cofinite.blimsup_set_eq]\n#align cofinite.bliminf_set_eq cofinite.bliminf_set_eq\n\n",
 "bliminf_or_le_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- See also `filter.bliminf_or_eq_inf`. -/\n@[simp]\ntheorem bliminf_or_le_inf : (bliminf u f fun x => p x ∨ q x) ≤ «expr ⊓ » (bliminf u f p) (bliminf u f q) :=\n  @blimsup_sup_le_or («expr ᵒᵈ» α) β _ f p q u\n#align bliminf_or_le_inf bliminf_or_le_inf\n\n",
 "bliminf_or_eq_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem bliminf_or_eq_inf : (bliminf u f fun x => p x ∨ q x) = «expr ⊓ » (bliminf u f p) (bliminf u f q) :=\n  @blimsup_or_eq_sup («expr ᵒᵈ» α) β _ f p q u\n#align bliminf_or_eq_inf bliminf_or_eq_inf\n\n",
 "bliminf_false":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem bliminf_false {f : filter β} {u : β → α} : (bliminf u f fun x => false) = «expr⊤» := by simp [bliminf_eq]\n#align bliminf_false bliminf_false\n\n",
 "bliminf_eq_supr_binfi_of_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem bliminf_eq_supr_binfi_of_nat {p : ℕ → Prop} {u : ℕ → α} :\n    bliminf u at_top p =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u j)) :=\n  @blimsup_eq_infi_bsupr_of_nat («expr ᵒᵈ» α) _ p u\n#align bliminf_eq_supr_binfi_of_nat bliminf_eq_supr_binfi_of_nat\n\n",
 "bliminf_eq_supr_binfi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem bliminf_eq_supr_binfi {f : filter β} {p : β → Prop} {u : β → α} :\n    bliminf u f p =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u b)) :=\n  @blimsup_eq_infi_bsupr («expr ᵒᵈ» α) β _ f p u\n#align bliminf_eq_supr_binfi bliminf_eq_supr_binfi\n\n",
 "bliminf_eq_liminf_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem bliminf_eq_liminf_subtype {f : filter β} {u : β → α} {p : β → Prop} :\n    bliminf u f p = liminf (u ∘ (coe : { x | p x } → β)) (comap coe f) :=\n  @blimsup_eq_limsup_subtype («expr ᵒᵈ» α) β _ f u p\n#align bliminf_eq_liminf_subtype bliminf_eq_liminf_subtype\n\n",
 "bliminf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem bliminf_eq :\n    bliminf u f p =\n      supₛ\n        { a |\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n            (p x → a ≤ u x) } :=\n  rfl\n#align bliminf_eq bliminf_eq\n\n",
 "bliminf_congr'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem bliminf_congr' {f : filter β} {p q : β → Prop} {u : β → α}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (u x ≠ «expr⊤» → (p x ↔ q x))) :\n    bliminf u f p = bliminf u f q :=\n  @blimsup_congr' («expr ᵒᵈ» α) β _ _ _ _ _ h\n#align bliminf_congr' bliminf_congr'\n\n",
 "bliminf_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem bliminf_congr {f : filter β} {u v : β → α} {p : β → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (p a → u a = v a)) :\n    bliminf u f p = bliminf v f p :=\n  @blimsup_congr («expr ᵒᵈ» α) _ _ _ _ _ _ h\n#align bliminf_congr bliminf_congr\n\n",
 "bliminf_antitone_filter":
 "theorem bliminf_antitone_filter (h : f ≤ g) : bliminf u g p ≤ bliminf u f p :=\n  supₛ_le_supₛ fun a ha => ha.filter_mono h\n#align bliminf_antitone_filter bliminf_antitone_filter\n\n",
 "bliminf_antitone":
 "theorem bliminf_antitone (h : ∀ x, p x → q x) : bliminf u f q ≤ bliminf u f p :=\n  supₛ_le_supₛ fun a ha => ha.mono <| by tauto\n#align bliminf_antitone bliminf_antitone\n\n",
 "bdd_below_range_of_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem is_bounded_under.bdd_below_range_of_cofinite [SemilatticeInf β] {f : α → β}\n    (hf : is_bounded_under (· ≥ ·) cofinite f) : BddBelow (range f) :=\n  @is_bounded_under.bdd_above_range_of_cofinite α («expr ᵒᵈ» β) _ _ hf\n#align is_bounded_under.bdd_below_range_of_cofinite is_bounded_under.bdd_below_range_of_cofinite\n\n",
 "bdd_below_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem is_bounded_under.bdd_below_range [SemilatticeInf β] {f : ℕ → β} (hf : is_bounded_under (· ≥ ·) at_top f) :\n    BddBelow (range f) :=\n  @is_bounded_under.bdd_above_range («expr ᵒᵈ» β) _ _ hf\n#align is_bounded_under.bdd_below_range is_bounded_under.bdd_below_range\n\n",
 "bdd_above_range_of_cofinite":
 "theorem is_bounded_under.bdd_above_range_of_cofinite [SemilatticeSup β] {f : α → β}\n    (hf : is_bounded_under (· ≤ ·) cofinite f) : BddAbove (range f) :=\n  by\n  rcases hf with ⟨b, hb⟩\n  haveI : nonempty β := ⟨b⟩\n  rw [← image_univ, ← union_compl_self { x | f x ≤ b }, image_union, bddAbove_union]\n  exact ⟨⟨b, ball_image_iff.2 fun x => id⟩, (hb.image f).bdd_above⟩\n#align is_bounded_under.bdd_above_range_of_cofinite is_bounded_under.bdd_above_range_of_cofinite\n\n",
 "bdd_above_range":
 "theorem is_bounded_under.bdd_above_range [SemilatticeSup β] {f : ℕ → β} (hf : is_bounded_under (· ≤ ·) at_top f) :\n    BddAbove (range f) := by\n  rw [← nat.cofinite_eq_at_top] at hf\n  exact hf.bdd_above_range_of_cofinite\n#align is_bounded_under.bdd_above_range is_bounded_under.bdd_above_range\n\n",
 "apply_limsup_iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- If `f : α → α` is a morphism of complete lattices, then the limsup of its iterates of any\n`a : α` is a fixed point. -/\n@[simp]\ntheorem complete_lattice_hom.apply_limsup_iterate (f : complete_lattice_hom α α) (a : α) :\n    f (limsup (fun n => («expr ^[ ]» f n) a) at_top) = limsup (fun n => («expr ^[ ]» f n) a) at_top :=\n  by\n  rw [limsup_eq_infi_supr_of_nat', map_infi]\n  simp_rw [_root_.map_supr, ← function.comp_apply f, ← function.iterate_succ' f, ← nat.add_succ]\n  conv_rhs => rw [infᵢ_split _ ((· < ·) (0 : ℕ))]\n  simp only [not_lt, le_zero_iff, infᵢ_infᵢ_eq_left, add_zero, infᵢ_nat_gt_zero_eq, left_eq_inf]\n  refine'\n    (infᵢ_le\n          (fun i =>\n            «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n              ((«expr ^[ ]» f (j + (i + 1))) a))\n          0).trans\n      _\n  simp only [zero_add, Function.comp_apply, supᵢ_le_iff]\n  exact fun i => le_supᵢ (fun i => («expr ^[ ]» f i) a) (i + 1)\n#align complete_lattice_hom.apply_limsup_iterate complete_lattice_hom.apply_limsup_iterate\n\n",
 "apply_liminf_iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- If `f : α → α` is a morphism of complete lattices, then the liminf of its iterates of any\n`a : α` is a fixed point. -/\ntheorem complete_lattice_hom.apply_liminf_iterate (f : complete_lattice_hom α α) (a : α) :\n    f (liminf (fun n => («expr ^[ ]» f n) a) at_top) = liminf (fun n => («expr ^[ ]» f n) a) at_top :=\n  (complete_lattice_hom.dual f).apply_limsup_iterate _\n#align complete_lattice_hom.apply_liminf_iterate complete_lattice_hom.apply_liminf_iterate\n\n",
 "apply_blimsup_le":
 "theorem Sup_hom.apply_blimsup_le [CompleteLattice γ] (g : Sup_hom α γ) : g (blimsup u f p) ≤ blimsup (g ∘ u) f p :=\n  by\n  simp only [blimsup_eq_infi_bsupr]\n  refine' ((OrderHomClass.mono g).map_infi₂_le _).trans _\n  simp only [_root_.map_supr]\n#align Sup_hom.apply_blimsup_le Sup_hom.apply_blimsup_le\n\n",
 "apply_blimsup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\ntheorem order_iso.apply_blimsup [CompleteLattice γ] (e : «expr ≃o » α γ) : e (blimsup u f p) = blimsup (e ∘ u) f p :=\n  by\n  simp only [blimsup_eq, map_Inf, Function.comp_apply]\n  congr\n  ext c\n  obtain ⟨a, rfl⟩ := e.surjective c\n  simp\n#align order_iso.apply_blimsup order_iso.apply_blimsup\n\n",
 "apply_bliminf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\ntheorem order_iso.apply_bliminf [CompleteLattice γ] (e : «expr ≃o » α γ) : e (bliminf u f p) = bliminf (e ∘ u) f p :=\n  @order_iso.apply_blimsup («expr ᵒᵈ» α) β («expr ᵒᵈ» γ) _ f p u _ e.dual\n#align order_iso.apply_bliminf order_iso.apply_bliminf\n\n",
 "Limsup_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem Limsup_top : Limsup («expr⊤» : filter α) = «expr⊤» :=\n  top_unique <| le_infₛ <| by simp [eq_univ_iff_forall] <;> exact fun b hb => top_unique <| hb _\n#align Limsup_top Limsup_top\n\n",
 "Limsup_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem Limsup_principal {s : set α} (h : BddAbove s) (hs : s.nonempty) : Limsup ((filter.principal) s) = supₛ s := by\n  simp [Limsup] <;> exact cinfₛ_upper_bounds_eq_csupₛ h hs\n#align Limsup_principal Limsup_principal\n\n",
 "Limsup_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem Limsup_le_of_le {f : filter α} {a}\n    (hf : f.is_cobounded (· ≤ ·) := by\n      run_tac\n        is_bounded_default)\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (n ≤ a)) :\n    Limsup f ≤ a :=\n  cinfₛ_le hf h\n#align Limsup_le_of_le Limsup_le_of_le\n\n",
 "Limsup_le_Limsup_of_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\ntheorem Limsup_le_Limsup_of_le {f g : filter α} (h : f ≤ g)\n    (hf : f.is_cobounded (· ≤ ·) := by\n      run_tac\n        is_bounded_default)\n    (hg : g.is_bounded (· ≤ ·) := by\n      run_tac\n        is_bounded_default) :\n    Limsup f ≤ Limsup g :=\n  Limsup_le_Limsup hf hg fun a ha => h ha\n#align Limsup_le_Limsup_of_le Limsup_le_Limsup_of_le\n\n",
 "Limsup_le_Limsup":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem Limsup_le_Limsup {f g : filter α}\n    (hf : f.is_cobounded (· ≤ ·) := by\n      run_tac\n        is_bounded_default)\n    (hg : g.is_bounded (· ≤ ·) := by\n      run_tac\n        is_bounded_default)\n    (h :\n      ∀ a,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" g\n            (n ≤ a) →\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n            (n ≤ a)) :\n    Limsup f ≤ Limsup g :=\n  cinfₛ_le_cinfₛ hf hg h\n#align Limsup_le_Limsup Limsup_le_Limsup\n\n",
 "Limsup_eq_infi_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem Limsup_eq_infi_Sup {f : filter α} :\n    Limsup f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (supₛ s) :=\n  f.basis_sets.Limsup_eq_infi_Sup\n#align Limsup_eq_infi_Sup Limsup_eq_infi_Sup\n\n",
 "Limsup_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem Limsup_bot : Limsup («expr⊥» : filter α) = «expr⊥» :=\n  bot_unique <| infₛ_le <| by simp\n#align Limsup_bot Limsup_bot\n\n",
 "Liminf_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem Liminf_top : Liminf («expr⊤» : filter α) = «expr⊥» :=\n  bot_unique <| supₛ_le <| by simp [eq_univ_iff_forall] <;> exact fun b hb => bot_unique <| hb _\n#align Liminf_top Liminf_top\n\n",
 "Liminf_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem Liminf_principal {s : set α} (h : BddBelow s) (hs : s.nonempty) : Liminf ((filter.principal) s) = infₛ s :=\n  @Limsup_principal («expr ᵒᵈ» α) _ s h hs\n#align Liminf_principal Liminf_principal\n\n",
 "Liminf_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem Liminf_le_of_le {f : filter α} {a}\n    (hf : f.is_bounded (· ≥ ·) := by\n      run_tac\n        is_bounded_default)\n    (h :\n      ∀ b,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n            (b ≤ n) →\n          b ≤ a) :\n    Liminf f ≤ a :=\n  csupₛ_le hf h\n#align Liminf_le_of_le Liminf_le_of_le\n\n",
 "Liminf_le_Limsup":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\ntheorem Liminf_le_Limsup {f : filter α} [ne_bot f]\n    (h₁ : f.is_bounded (· ≤ ·) := by\n      run_tac\n        is_bounded_default)\n    (h₂ : f.is_bounded (· ≥ ·) := by\n      run_tac\n        is_bounded_default) :\n    Liminf f ≤ Limsup f :=\n  Liminf_le_of_le h₂ fun a₀ ha₀ =>\n    le_Limsup_of_le h₁ fun a₁ ha₁ =>\n      show a₀ ≤ a₁ from\n        let ⟨b, hb₀, hb₁⟩ := (ha₀.and ha₁).exists\n        le_trans hb₀ hb₁\n#align Liminf_le_Limsup Liminf_le_Limsup\n\n",
 "Liminf_le_Liminf_of_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\ntheorem Liminf_le_Liminf_of_le {f g : filter α} (h : g ≤ f)\n    (hf : f.is_bounded (· ≥ ·) := by\n      run_tac\n        is_bounded_default)\n    (hg : g.is_cobounded (· ≥ ·) := by\n      run_tac\n        is_bounded_default) :\n    Liminf f ≤ Liminf g :=\n  Liminf_le_Liminf hf hg fun a ha => h ha\n#align Liminf_le_Liminf_of_le Liminf_le_Liminf_of_le\n\n",
 "Liminf_le_Liminf":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem Liminf_le_Liminf {f g : filter α}\n    (hf : f.is_bounded (· ≥ ·) := by\n      run_tac\n        is_bounded_default)\n    (hg : g.is_cobounded (· ≥ ·) := by\n      run_tac\n        is_bounded_default)\n    (h :\n      ∀ a,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n            (a ≤ n) →\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" g\n            (a ≤ n)) :\n    Liminf f ≤ Liminf g :=\n  csupₛ_le_csupₛ hg hf h\n#align Liminf_le_Liminf Liminf_le_Liminf\n\n",
 "Liminf_eq_supr_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem Liminf_eq_supr_Inf {f : filter α} :\n    Liminf f =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (infₛ s) :=\n  @Limsup_eq_infi_Sup («expr ᵒᵈ» α) _ _\n#align Liminf_eq_supr_Inf Liminf_eq_supr_Inf\n\n",
 "Liminf_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem Liminf_bot : Liminf («expr⊥» : filter α) = «expr⊤» :=\n  top_unique <| le_supₛ <| by simp\n#align Liminf_bot Liminf_bot\n\n"}