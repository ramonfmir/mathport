{"well_founded_iff_is_Sup_finite_compact":
 "theorem well_founded_iff_is_Sup_finite_compact : well_founded ((· > ·) : α → α → Prop) ↔ IsSupFiniteCompact α :=\n  (wellFounded_characterisations α).out 0 1\n#align well_founded_iff_is_Sup_finite_compact well_founded_iff_is_Sup_finite_compact\n\n",
 "well_founded_characterisations":
 "theorem well_founded_characterisations :\n    TFAE\n      [well_founded ((· > ·) : α → α → Prop), IsSupFiniteCompact α, IsSupClosedCompact α,\n        ∀ k : α, IsCompactElement k] :=\n  by\n  tfae_have 1 → 2; · exact well_founded.is_Sup_finite_compact α\n  tfae_have 2 → 3; · exact is_Sup_finite_compact.is_sup_closed_compact α\n  tfae_have 3 → 1; · exact is_sup_closed_compact.well_founded α\n  tfae_have 2 ↔ 4; · exact is_Sup_finite_compact_iff_all_elements_compact α\n  tfae_finish\n#align well_founded_characterisations well_founded_characterisations\n\n",
 "well_founded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem is_sup_closed_compact.well_founded (h : IsSupClosedCompact α) : well_founded ((· > ·) : α → α → Prop) :=\n  by\n  refine' rel_embedding.well_founded_iff_no_descending_seq.mpr ⟨fun a => _⟩\n  suffices Sup (Set.range a) ∈ Set.range a\n    by\n    obtain ⟨n, hn⟩ := set.mem_range.mp this\n    have h' : Sup (Set.range a) < a (n + 1) := by\n      change _ > _\n      simp [← hn, a.map_rel_iff]\n    apply lt_irrefl (a (n + 1))\n    apply lt_of_le_of_lt _ h'\n    apply le_supₛ\n    apply Set.mem_range_self\n  apply h (Set.range a)\n  · use a 37\n    apply Set.mem_range_self\n  · rintro x ⟨m, hm⟩ y ⟨n, hn⟩\n    use «expr ⊔ » m n\n    rw [← hm, ← hn]\n    apply RelHomClass.map_sup a\n#align is_sup_closed_compact.well_founded is_sup_closed_compact.well_founded\n\n",
 "supₛ_inf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print DirectedOn.supₛ_inf_eq /-\n/-- This property is sometimes referred to as `α` being upper continuous. -/\nprotected theorem DirectedOn.supₛ_inf_eq (h : DirectedOn (· ≤ ·) s) :\n    «expr ⊓ » (supₛ s) a =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" («expr ⊓ » b a) :=\n  by simp_rw [@inf_comm _ _ _ a, h.inf_Sup_eq]\n#align directed_on.Sup_inf_eq DirectedOn.supₛ_inf_eq\n-/\n\n",
 "supₛ_compact_le_eq":
 "#print supₛ_compact_le_eq /-\n@[simp]\ntheorem supₛ_compact_le_eq (b) : supₛ { c : α | CompleteLattice.IsCompactElement c ∧ c ≤ b } = b :=\n  by\n  rcases is_compactly_generated.exists_Sup_eq b with ⟨s, hs, rfl⟩\n  exact le_antisymm (supₛ_le fun c hc => hc.2) (supₛ_le_supₛ fun c cs => ⟨hs c cs, le_supₛ cs⟩)\n#align Sup_compact_le_eq supₛ_compact_le_eq\n-/\n\n",
 "supₛ_compact_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print supₛ_compact_eq_top /-\n@[simp]\ntheorem supₛ_compact_eq_top : supₛ { a : α | CompleteLattice.IsCompactElement a } = «expr⊤» :=\n  by\n  refine' Eq.trans (congr rfl (Set.ext fun x => _)) (supₛ_compact_le_eq («expr⊤»))\n  exact (and_iff_left le_top).symm\n#align Sup_compact_eq_top supₛ_compact_eq_top\n-/\n\n",
 "supᵢ_inf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print Directed.supᵢ_inf_eq /-\nprotected theorem Directed.supᵢ_inf_eq (h : Directed (· ≤ ·) f) :\n    «expr ⊓ » («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i))\n        a =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr ⊓ » (f i) a) :=\n  by rw [supᵢ, h.directed_on_range.Sup_inf_eq, supᵢ_range]\n#align directed.supr_inf_eq Directed.supᵢ_inf_eq\n-/\n\n",
 "setIndependent_unionᵢ_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print CompleteLattice.setIndependent_unionᵢ_of_directed /-\ntheorem CompleteLattice.setIndependent_unionᵢ_of_directed {η : Type _} {s : η → Set α} (hs : Directed (· ⊆ ·) s)\n    (h : ∀ i, CompleteLattice.SetIndependent (s i)) :\n    CompleteLattice.SetIndependent\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  by\n  by_cases hη : Nonempty η\n  · skip\n    rw [CompleteLattice.setIndependent_iff_finite]\n    intro t ht\n    obtain ⟨I, fi, hI⟩ := Set.finite_subset_unionᵢ t.finite_to_set ht\n    obtain ⟨i, hi⟩ := hs.finset_le fi.to_finset\n    exact (h i).mono (Set.Subset.trans hI <| Set.unionᵢ₂_subset fun j hj => hi j (fi.mem_to_finset.2 hj))\n  · rintro a ⟨_, ⟨i, _⟩, _⟩\n    exfalso\n    exact hη ⟨i⟩\n#align complete_lattice.set_independent_Union_of_directed CompleteLattice.setIndependent_unionᵢ_of_directed\n-/\n\n",
 "setIndependent_iff_finite":
 "#print CompleteLattice.setIndependent_iff_finite /-\ntheorem CompleteLattice.setIndependent_iff_finite {s : Set α} :\n    CompleteLattice.SetIndependent s ↔ ∀ t : Finset α, ↑t ⊆ s → CompleteLattice.SetIndependent (↑t : Set α) :=\n  ⟨fun hs t ht => hs.mono ht, fun h a ha =>\n    by\n    rw [disjoint_iff, inf_supₛ_eq_supᵢ_inf_sup_finset, supᵢ_eq_bot]\n    intro t\n    rw [supᵢ_eq_bot, Finset.sup_id_eq_supₛ]\n    intro ht\n    classical\n      have h' := (h (insert a t) _ (t.mem_insert_self a)).eq_bot\n      · rwa [Finset.coe_insert, Set.insert_diff_self_of_not_mem] at h'\n        exact fun con => ((Set.mem_diff a).1 (ht Con)).2 (Set.mem_singleton a)\n      · rw [Finset.coe_insert, Set.insert_subset]\n        exact ⟨ha, Set.Subset.trans ht (Set.diff_subset _ _)⟩⟩\n#align complete_lattice.set_independent_iff_finite CompleteLattice.setIndependent_iff_finite\n-/\n\n",
 "le_iff_compact_le_imp":
 "#print le_iff_compact_le_imp /-\ntheorem le_iff_compact_le_imp {a b : α} : a ≤ b ↔ ∀ c : α, CompleteLattice.IsCompactElement c → c ≤ a → c ≤ b :=\n  ⟨fun ab c hc ca => le_trans ca ab, fun h =>\n    by\n    rw [← supₛ_compact_le_eq a, ← supₛ_compact_le_eq b]\n    exact supₛ_le_supₛ fun c hc => ⟨hc.1, h c hc.1 hc.2⟩⟩\n#align le_iff_compact_le_imp le_iff_compact_le_imp\n-/\n\n",
 "is_sup_closed_compact_iff_well_founded":
 "theorem is_sup_closed_compact_iff_well_founded : IsSupClosedCompact α ↔ well_founded ((· > ·) : α → α → Prop) :=\n  (wellFounded_characterisations α).out 2 0\n#align is_sup_closed_compact_iff_well_founded is_sup_closed_compact_iff_well_founded\n\n",
 "is_sup_closed_compact":
 "theorem is_Sup_finite_compact.is_sup_closed_compact (h : IsSupFiniteCompact α) : IsSupClosedCompact α :=\n  by\n  intro s hne hsc; obtain ⟨t, ht₁, ht₂⟩ := h s; clear h\n  cases' t.eq_empty_or_nonempty with h h\n  · subst h\n    rw [Finset.sup_empty] at ht₂\n    rw [ht₂]\n    simp [eq_singleton_bot_of_supₛ_eq_bot_of_nonempty ht₂ hne]\n  · rw [ht₂]\n    exact t.sup_closed_of_sup_closed h ht₁ hsc\n#align is_Sup_finite_compact.is_sup_closed_compact is_Sup_finite_compact.is_sup_closed_compact\n\n",
 "is_compact_element_iff_le_of_directed_Sup_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- An element `k` is compact if and only if any directed set with `Sup` above\n`k` already got above `k` at some point in the set. -/\ntheorem is_compact_element_iff_le_of_directed_Sup_le (k : α) :\n    IsCompactElement k ↔ ∀ s : Set α, s.nonempty → DirectedOn (· ≤ ·) s → k ≤ supₛ s → ∃ x : α, x ∈ s ∧ k ≤ x := by\n  classical\n    constructor\n    · intro hk s hne hdir hsup\n      obtain ⟨t, ht⟩ := hk s hsup\n      -- certainly every element of t is below something in s, since ↑t ⊆ s.\n      have t_below_s : ∀ x ∈ t, ∃ y ∈ s, x ≤ y := fun x hxt => ⟨x, ht.left hxt, le_rfl⟩\n      obtain ⟨x, ⟨hxs, hsupx⟩⟩ := Finset.sup_le_of_le_directed s hne hdir t t_below_s\n      exact ⟨x, ⟨hxs, le_trans ht.right hsupx⟩⟩\n    · intro hk s hsup\n      -- Consider the set of finite joins of elements of the (plain) set s.\n      let S : Set α := { x | ∃ t : Finset α, ↑t ⊆ s ∧ x = t.sup id }\n      -- S is directed, nonempty, and still has sup above k.\n      have dir_US : DirectedOn (· ≤ ·) S := by\n        rintro x ⟨c, hc⟩ y ⟨d, hd⟩\n        use «expr ⊔ » x y\n        constructor\n        · use c ∪ d\n          constructor\n          · simp only [hc.left, hd.left, Set.union_subset_iff, Finset.coe_union, and_self_iff]\n          · simp only [hc.right, hd.right, Finset.sup_union]\n        simp only [and_self_iff, le_sup_left, le_sup_right]\n      have sup_S : Sup s ≤ Sup S := by\n        apply supₛ_le_supₛ\n        intro x hx\n        use {x}\n        simpa only [and_true_iff, id.def, Finset.coe_singleton, eq_self_iff_true, Finset.sup_singleton,\n          Set.singleton_subset_iff]\n      have Sne : S.nonempty := by\n        suffices : «expr⊥» ∈ S\n        exact Set.nonempty_of_mem this\n        use ∅\n        simp only [Set.empty_subset, Finset.coe_empty, Finset.sup_empty, eq_self_iff_true, and_self_iff]\n      -- Now apply the defn of compact and finish.\n      obtain ⟨j, ⟨hjS, hjk⟩⟩ := hk S Sne dir_US (le_trans hsup sup_S)\n      obtain ⟨t, ⟨htS, htsup⟩⟩ := hjS\n      use t\n      exact ⟨htS, by rwa [← htsup]⟩\n#align is_compact_element_iff_le_of_directed_Sup_le is_compact_element_iff_le_of_directed_Sup_le\n\n",
 "is_compact_element_iff":
 "/-\nCopyright (c) 2021 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\ntheorem is_compact_element_iff.{u} {α : Type u} [CompleteLattice α] (k : α) :\n    CompleteLattice.IsCompactElement k ↔ ∀ (ι : Type u) (s : ι → α), k ≤ supᵢ s → ∃ t : Finset ι, k ≤ t.sup s := by\n  classical\n    constructor\n    · intro H ι s hs\n      obtain ⟨t, ht, ht'⟩ := H (Set.range s) hs\n      have : ∀ x : t, ∃ i, s i = x := fun x => ht x.prop\n      choose f hf using this\n      refine' ⟨finset.univ.image f, ht'.trans _⟩\n      · rw [Finset.sup_le_iff]\n        intro b hb\n        rw [← show s (f ⟨b, hb⟩) = id b from hf _]\n        exact Finset.le_sup (Finset.mem_image_of_mem f <| Finset.mem_univ ⟨b, hb⟩)\n    · intro H s hs\n      obtain ⟨t, ht⟩ :=\n        H s coe\n          (by\n            delta supᵢ\n            rwa [Subtype.range_coe])\n      refine' ⟨t.image coe, by simp, ht.trans _⟩\n      rw [Finset.sup_le_iff]\n      exact fun x hx => @Finset.le_sup _ _ _ _ _ id _ (Finset.mem_image_of_mem coe hx)\n#align is_compact_element_iff is_compact_element_iff\n\n",
 "is_Sup_finite_compact_iff_is_sup_closed_compact":
 "theorem is_Sup_finite_compact_iff_is_sup_closed_compact : IsSupFiniteCompact α ↔ IsSupClosedCompact α :=\n  (wellFounded_characterisations α).out 1 2\n#align is_Sup_finite_compact_iff_is_sup_closed_compact is_Sup_finite_compact_iff_is_sup_closed_compact\n\n",
 "is_Sup_finite_compact_iff_all_elements_compact":
 "theorem is_Sup_finite_compact_iff_all_elements_compact : IsSupFiniteCompact α ↔ ∀ k : α, IsCompactElement k :=\n  by\n  refine' ⟨fun h k s hs => _, fun h s => _⟩\n  · obtain ⟨t, ⟨hts, htsup⟩⟩ := h s\n    use t, hts\n    rwa [← htsup]\n  · obtain ⟨t, ⟨hts, htsup⟩⟩ := h (Sup s) s (by rfl)\n    have : Sup s = t.sup id := by\n      suffices t.sup id ≤ Sup s by apply le_antisymm <;> assumption\n      simp only [id.def, Finset.sup_le_iff]\n      intro x hx\n      exact le_supₛ (hts hx)\n    use t, hts, this\n#align is_Sup_finite_compact_iff_all_elements_compact is_Sup_finite_compact_iff_all_elements_compact\n\n",
 "is_Sup_finite_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem well_founded.is_Sup_finite_compact (h : well_founded ((· > ·) : α → α → Prop)) : IsSupFiniteCompact α :=\n  fun s =>\n  by\n  obtain ⟨m, ⟨t, ⟨ht₁, rfl⟩⟩, hm⟩ :=\n    well_founded.well_founded_iff_has_min.mp h { x | ∃ t : Finset α, ↑t ⊆ s ∧ t.sup id = x } ⟨«expr⊥», ∅, by simp⟩\n  refine' ⟨t, ht₁, (supₛ_le fun y hy => _).antisymm _⟩\n  ·\n    classical\n      rw [eq_of_le_of_not_lt (Finset.sup_mono (t.subset_insert y))\n          (hm _ ⟨insert y t, by simp [Set.insert_subset, hy, ht₁]⟩)]\n      simp\n  · rw [Finset.sup_id_eq_supₛ]\n    exact supₛ_le_supₛ ht₁\n#align well_founded.is_Sup_finite_compact well_founded.is_Sup_finite_compact\n\n",
 "inf_supₛ_eq_supᵢ_inf_sup_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print inf_supₛ_eq_supᵢ_inf_sup_finset /-\n/-- This property is equivalent to `α` being upper continuous. -/\ntheorem inf_supₛ_eq_supᵢ_inf_sup_finset :\n    «expr ⊓ » a (supₛ s) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr ⊓ » a (t.sup id)) :=\n  le_antisymm\n    (by\n      rw [le_iff_compact_le_imp]\n      intro c hc hcinf\n      rw [le_inf_iff] at hcinf\n      rcases hc s hcinf.2 with ⟨t, ht1, ht2⟩\n      exact (le_inf hcinf.1 ht2).trans (le_supᵢ₂ t ht1))\n    (supᵢ_le fun t => supᵢ_le fun h => inf_le_inf_left _ ((Finset.sup_id_eq_supₛ t).symm ▸ supₛ_le_supₛ h))\n#align inf_Sup_eq_supr_inf_sup_finset inf_supₛ_eq_supᵢ_inf_sup_finset\n-/\n\n",
 "inf_supₛ_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print DirectedOn.inf_supₛ_eq /-\n/-- This property is sometimes referred to as `α` being upper continuous. -/\ntheorem DirectedOn.inf_supₛ_eq (h : DirectedOn (· ≤ ·) s) :\n    «expr ⊓ » a (supₛ s) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" («expr ⊓ » a b) :=\n  le_antisymm\n    (by\n      rw [le_iff_compact_le_imp]\n      by_cases hs : s.nonempty\n      · intro c hc hcinf\n        rw [le_inf_iff] at hcinf\n        rw [CompleteLattice.isCompactElement_iff_le_of_directed_supₛ_le] at hc\n        rcases hc s hs h hcinf.2 with ⟨d, ds, cd⟩\n        exact (le_inf hcinf.1 cd).trans (le_supᵢ₂ d ds)\n      · rw [Set.not_nonempty_iff_eq_empty] at hs\n        simp [hs])\n    supᵢ_inf_le_inf_supₛ\n#align directed_on.inf_Sup_eq DirectedOn.inf_supₛ_eq\n-/\n\n",
 "inf_supᵢ_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print Directed.inf_supᵢ_eq /-\nprotected theorem Directed.inf_supᵢ_eq (h : Directed (· ≤ ·) f) :\n    «expr ⊓ » a\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr ⊓ » a (f i)) :=\n  by rw [supᵢ, h.directed_on_range.inf_Sup_eq, supᵢ_range]\n#align directed.inf_supr_eq Directed.inf_supᵢ_eq\n-/\n\n",
 "independent_unionₛ_of_directed":
 "#print CompleteLattice.independent_unionₛ_of_directed /-\ntheorem CompleteLattice.independent_unionₛ_of_directed {s : Set (Set α)} (hs : DirectedOn (· ⊆ ·) s)\n    (h : ∀ a ∈ s, CompleteLattice.SetIndependent a) : CompleteLattice.SetIndependent (⋃₀ s) := by\n  rw [Set.unionₛ_eq_unionᵢ] <;>\n    exact CompleteLattice.setIndependent_unionᵢ_of_directed hs.directed_coe (by simpa using h)\n#align complete_lattice.independent_sUnion_of_directed CompleteLattice.independent_unionₛ_of_directed\n-/\n\n",
 "finset_sup_compact_of_compact":
 "theorem finset_sup_compact_of_compact {α β : Type _} [CompleteLattice α] {f : β → α} (s : Finset β)\n    (h : ∀ x ∈ s, IsCompactElement (f x)) : IsCompactElement (s.sup f) := by\n  classical\n    rw [is_compact_element_iff_le_of_directed_Sup_le]\n    intro d hemp hdir hsup\n    change f with id ∘ f\n    rw [← Finset.sup_image]\n    apply Finset.sup_le_of_le_directed d hemp hdir\n    rintro x hx\n    obtain ⟨p, ⟨hps, rfl⟩⟩ := finset.mem_image.mp hx\n    specialize h p hps\n    rw [is_compact_element_iff_le_of_directed_Sup_le] at h\n    specialize h d hemp hdir (le_trans (Finset.le_sup hps) hsup)\n    simpa only [exists_prop]\n#align finset_sup_compact_of_compact finset_sup_compact_of_compact\n\n",
 "finite_of_set_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem well_founded.finite_of_set_independent (h : well_founded ((· > ·) : α → α → Prop)) {s : Set α}\n    (hs : SetIndependent s) : s.finite := by\n  classical\n    refine' set.not_infinite.mp fun contra => _\n    obtain ⟨t, ht₁, ht₂⟩ := well_founded.is_Sup_finite_compact α h s\n    replace contra : ∃ x : α, x ∈ s ∧ x ≠ «expr⊥» ∧ x ∉ t\n    · have : (s \\ (insert («expr⊥») t : Finset α)).infinite := contra.diff (Finset.finite_toSet _)\n      obtain ⟨x, hx₁, hx₂⟩ := this.nonempty\n      exact ⟨x, hx₁, by simpa [not_or] using hx₂⟩\n    obtain ⟨x, hx₀, hx₁, hx₂⟩ := contra\n    replace hs : «expr ⊓ » x (Sup s) = «expr⊥»\n    · have := hs.mono (by simp [ht₁, hx₀, -Set.union_singleton] : ↑t ∪ {x} ≤ s) (by simp : x ∈ _)\n      simpa [Disjoint, hx₂, ← t.sup_id_eq_Sup, ← ht₂] using this.eq_bot\n    apply hx₁\n    rw [← hs, eq_comm, inf_eq_left]\n    exact le_supₛ hx₀\n#align well_founded.finite_of_set_independent well_founded.finite_of_set_independent\n\n",
 "finite_of_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem well_founded.finite_of_independent (hwf : well_founded ((· > ·) : α → α → Prop)) {ι : Type _} {t : ι → α}\n    (ht : Independent t) (h_ne_bot : ∀ i, t i ≠ «expr⊥») : Finite ι :=\n  haveI := (well_founded.finite_of_set_independent hwf ht.set_independent_range).to_subtype\n  Finite.of_injective_finite_range (ht.injective h_ne_bot)\n#align well_founded.finite_of_independent well_founded.finite_of_independent\n\n",
 "exists_setIndependent_of_supₛ_atoms_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print exists_setIndependent_of_supₛ_atoms_eq_top /-\ntheorem exists_setIndependent_of_supₛ_atoms_eq_top (h : supₛ { a : α | IsAtom a } = «expr⊤») :\n    ∃ s : Set α, CompleteLattice.SetIndependent s ∧ supₛ s = «expr⊤» ∧ ∀ ⦃a⦄, a ∈ s → IsAtom a :=\n  let ⟨s, s_ind, s_top, s_atoms⟩ := exists_setIndependent_isCompl_supₛ_atoms h («expr⊥»)\n  ⟨s, s_ind, eq_top_of_isCompl_bot s_top.symm, s_atoms⟩\n#align exists_set_independent_of_Sup_atoms_eq_top exists_setIndependent_of_supₛ_atoms_eq_top\n-/\n\n",
 "exists_setIndependent_isCompl_supₛ_atoms":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print exists_setIndependent_isCompl_supₛ_atoms /-\n/-- In an atomic lattice, every element `b` has a complement of the form `Sup s`, where each element\nof `s` is an atom. See also `complemented_lattice_of_Sup_atoms_eq_top`. -/\ntheorem exists_setIndependent_isCompl_supₛ_atoms (h : supₛ { a : α | IsAtom a } = «expr⊤») (b : α) :\n    ∃ s : Set α, CompleteLattice.SetIndependent s ∧ IsCompl b (supₛ s) ∧ ∀ ⦃a⦄, a ∈ s → IsAtom a :=\n  by\n  obtain ⟨s, ⟨s_ind, b_inf_Sup_s, s_atoms⟩, s_max⟩ :=\n    zorn_subset { s : Set α | CompleteLattice.SetIndependent s ∧ Disjoint b (Sup s) ∧ ∀ a ∈ s, IsAtom a }\n      fun c hc1 hc2 =>\n      ⟨⋃₀ c,\n        ⟨CompleteLattice.independent_unionₛ_of_directed hc2.directed_on fun s hs => (hc1 hs).1, _, fun a ⟨s, sc, as⟩ =>\n          (hc1 sc).2.2 a as⟩,\n        fun _ => Set.subset_unionₛ_of_mem⟩\n  swap\n  · rw [supₛ_unionₛ, ← supₛ_image, DirectedOn.disjoint_supₛ_right]\n    · rintro _ ⟨s, hs, rfl⟩\n      exact (hc1 hs).2.1\n    · rw [directedOn_image]\n      exact hc2.directed_on.mono fun s t => supₛ_le_supₛ\n  refine' ⟨s, s_ind, ⟨b_inf_Sup_s, _⟩, s_atoms⟩\n  rw [codisjoint_iff_le_sup, ← h, supₛ_le_iff]\n  intro a ha\n  rw [← inf_eq_left]\n  refine' (ha.le_iff.mp inf_le_left).resolve_left fun con => ha.1 _\n  rw [← Con, eq_comm, inf_eq_left]\n  refine' (le_supₛ _).trans le_sup_right\n  rw [← disjoint_iff] at con\n  have a_dis_Sup_s : Disjoint a (Sup s) := con.mono_right le_sup_right\n  rw [← s_max (s ∪ {a}) ⟨fun x hx => _, ⟨_, fun x hx => _⟩⟩ (Set.subset_union_left _ _)]\n  · exact Set.mem_union_right _ (Set.mem_singleton _)\n  · rw [Set.mem_union, Set.mem_singleton_iff] at hx\n    obtain rfl | xa := eq_or_ne x a\n    · simp only [Set.mem_singleton, Set.insert_diff_of_mem, Set.union_singleton]\n      exact con.mono_right ((supₛ_le_supₛ <| Set.diff_subset _ _).trans le_sup_right)\n    · have h : (s ∪ {a}) \\ {x} = s \\ {x} ∪ {a} :=\n        by\n        simp only [Set.union_singleton]\n        rw [Set.insert_diff_of_not_mem]\n        rw [Set.mem_singleton_iff]\n        exact ne.symm xa\n      rw [h, supₛ_union, supₛ_singleton]\n      apply (s_ind (hx.resolve_right xa)).disjoint_sup_right_of_disjoint_sup_left (a_dis_Sup_s.mono_right _).symm\n      rw [← supₛ_insert, Set.insert_diff_singleton, Set.insert_eq_of_mem (hx.resolve_right xa)]\n  · rw [supₛ_union, supₛ_singleton]\n    exact b_inf_Sup_s.disjoint_sup_right_of_disjoint_sup_left Con.symm\n  · rw [Set.mem_union, Set.mem_singleton_iff] at hx\n    obtain hx | rfl := hx\n    · exact s_atoms x hx\n    · exact ha\n#align exists_set_independent_is_compl_Sup_atoms exists_setIndependent_isCompl_supₛ_atoms\n-/\n\n",
 "exists_finset_of_le_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem is_compact_element.exists_finset_of_le_supr {k : α} (hk : IsCompactElement k) {ι : Type _} (f : ι → α)\n    (h : k ≤ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) :\n    ∃ s : Finset ι,\n      k ≤ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) :=\n  by\n  classical\n    let g : Finset ι → α := fun s =>\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)\n    have h1 : DirectedOn (· ≤ ·) (Set.range g) :=\n      by\n      rintro - ⟨s, rfl⟩ - ⟨t, rfl⟩\n      exact\n        ⟨g (s ∪ t), ⟨s ∪ t, rfl⟩, supᵢ_le_supᵢ_of_subset (Finset.subset_union_left s t),\n          supᵢ_le_supᵢ_of_subset (Finset.subset_union_right s t)⟩\n    have h2 : k ≤ Sup (Set.range g) :=\n      h.trans\n        (supᵢ_le fun i =>\n          le_supₛ_of_le ⟨{i}, rfl⟩ (le_supᵢ_of_le i (le_supᵢ_of_le (Finset.mem_singleton_self i) le_rfl)))\n    obtain ⟨-, ⟨s, rfl⟩, hs⟩ :=\n      (is_compact_element_iff_le_of_directed_Sup_le α k).mp hk (Set.range g) (Set.range_nonempty g) h1 h2\n    exact ⟨s, hs⟩\n#align is_compact_element.exists_finset_of_le_supr is_compact_element.exists_finset_of_le_supr\n\n",
 "disjoint_supₛ_right":
 "#print DirectedOn.disjoint_supₛ_right /-\nprotected theorem DirectedOn.disjoint_supₛ_right (h : DirectedOn (· ≤ ·) s) :\n    Disjoint a (supₛ s) ↔ ∀ ⦃b⦄, b ∈ s → Disjoint a b := by simp_rw [disjoint_iff, h.inf_Sup_eq, supᵢ_eq_bot]\n#align directed_on.disjoint_Sup_right DirectedOn.disjoint_supₛ_right\n-/\n\n",
 "disjoint_supₛ_left":
 "#print DirectedOn.disjoint_supₛ_left /-\nprotected theorem DirectedOn.disjoint_supₛ_left (h : DirectedOn (· ≤ ·) s) :\n    Disjoint (supₛ s) a ↔ ∀ ⦃b⦄, b ∈ s → Disjoint b a := by simp_rw [disjoint_iff, h.Sup_inf_eq, supᵢ_eq_bot]\n#align directed_on.disjoint_Sup_left DirectedOn.disjoint_supₛ_left\n-/\n\n",
 "disjoint_supᵢ_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print Directed.disjoint_supᵢ_right /-\nprotected theorem Directed.disjoint_supᵢ_right (h : Directed (· ≤ ·) f) :\n    Disjoint a («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) ↔\n      ∀ i, Disjoint a (f i) :=\n  by simp_rw [disjoint_iff, h.inf_supr_eq, supᵢ_eq_bot]\n#align directed.disjoint_supr_right Directed.disjoint_supᵢ_right\n-/\n\n",
 "disjoint_supᵢ_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print Directed.disjoint_supᵢ_left /-\nprotected theorem Directed.disjoint_supᵢ_left (h : Directed (· ≤ ·) f) :\n    Disjoint («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) a ↔\n      ∀ i, Disjoint (f i) a :=\n  by simp_rw [disjoint_iff, h.supr_inf_eq, supᵢ_eq_bot]\n#align directed.disjoint_supr_left Directed.disjoint_supᵢ_left\n-/\n\n",
 "directed_Sup_lt_of_lt":
 "/-- A compact element `k` has the property that any directed set lying strictly below `k` has\nits Sup strictly below `k`. -/\ntheorem is_compact_element.directed_Sup_lt_of_lt {α : Type _} [CompleteLattice α] {k : α} (hk : IsCompactElement k)\n    {s : Set α} (hemp : s.nonempty) (hdir : DirectedOn (· ≤ ·) s) (hbelow : ∀ x ∈ s, x < k) : supₛ s < k :=\n  by\n  rw [is_compact_element_iff_le_of_directed_Sup_le] at hk\n  by_contra\n  have sSup : Sup s ≤ k := supₛ_le fun s hs => (hbelow s hs).le\n  replace sSup : Sup s = k := eq_iff_le_not_lt.mpr ⟨sSup, h⟩\n  obtain ⟨x, hxs, hkx⟩ := hk s hemp hdir sSup.symm.le\n  obtain hxk := hbelow x hxs\n  exact hxk.ne (hxk.le.antisymm hkx)\n#align is_compact_element.directed_Sup_lt_of_lt is_compact_element.directed_Sup_lt_of_lt\n\n",
 "complementedLattice_of_supₛ_atoms_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print complementedLattice_of_supₛ_atoms_eq_top /-\n/-- See [Theorem 6.6][calugareanu]. -/\ntheorem complementedLattice_of_supₛ_atoms_eq_top (h : supₛ { a : α | IsAtom a } = «expr⊤») : ComplementedLattice α :=\n  ⟨fun b =>\n    let ⟨s, _, s_top, s_atoms⟩ := exists_setIndependent_isCompl_supₛ_atoms h b\n    ⟨supₛ s, s_top⟩⟩\n#align complemented_lattice_of_Sup_atoms_eq_top complementedLattice_of_supₛ_atoms_eq_top\n-/\n\n",
 "complementedLattice_of_isAtomistic":
 "#print complementedLattice_of_isAtomistic /-\n/-- See [Theorem 6.6][calugareanu]. -/\ntheorem complementedLattice_of_isAtomistic [IsAtomistic α] : ComplementedLattice α :=\n  complementedLattice_of_supₛ_atoms_eq_top supₛ_atoms_eq_top\n#align complemented_lattice_of_is_atomistic complementedLattice_of_isAtomistic\n-/\n\n",
 "complementedLattice_iff_isAtomistic":
 "#print complementedLattice_iff_isAtomistic /-\ntheorem complementedLattice_iff_isAtomistic : ComplementedLattice α ↔ IsAtomistic α :=\n  by\n  constructor <;> intros\n  · exact isAtomistic_of_complementedLattice\n  · exact complementedLattice_of_isAtomistic\n#align complemented_lattice_iff_is_atomistic complementedLattice_iff_isAtomistic\n-/\n\n",
 "compactly_generated_of_well_founded":
 "theorem compactly_generated_of_well_founded (h : well_founded ((· > ·) : α → α → Prop)) : IsCompactlyGenerated α :=\n  by\n  rw [well_founded_iff_is_Sup_finite_compact, is_Sup_finite_compact_iff_all_elements_compact] at h\n  -- x is the join of the set of compact elements {x}\n  exact ⟨fun x => ⟨{x}, ⟨fun x _ => h x, supₛ_singleton⟩⟩⟩\n#align compactly_generated_of_well_founded compactly_generated_of_well_founded\n\n",
 "coatomic_of_top_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem coatomic_of_top_compact (h : IsCompactElement («expr⊤» : α)) : IsCoatomic α :=\n  (@OrderIso.IicTop α _ _).is_coatomic_iff.mp (Iic_coatomic_of_compact_element h)\n#align coatomic_of_top_compact coatomic_of_top_compact\n\n",
 "Iic_coatomic_of_compact_element":
 "/-- A compact element `k` has the property that any `b < k` lies below a \"maximal element below\n`k`\", which is to say `[⊥, k]` is coatomic. -/\ntheorem Iic_coatomic_of_compact_element {k : α} (h : IsCompactElement k) : IsCoatomic (Set.Iic k) :=\n  ⟨fun ⟨b, hbk⟩ => by\n    by_cases htriv : b = k\n    · left\n      ext\n      simp only [htriv, Set.Iic.coe_top, Subtype.coe_mk]\n    right\n    obtain ⟨a, a₀, ba, h⟩ := zorn_nonempty_partialOrder₀ (Set.Iio k) _ b (lt_of_le_of_ne hbk htriv)\n    · refine' ⟨⟨a, le_of_lt a₀⟩, ⟨ne_of_lt a₀, fun c hck => by_contradiction fun c₀ => _⟩, ba⟩\n      cases h c.1 (lt_of_le_of_ne c.2 fun con => c₀ (Subtype.ext Con)) hck.le\n      exact lt_irrefl _ hck\n    · intro S SC cC I IS\n      by_cases hS : S.nonempty\n      · exact ⟨Sup S, h.directed_Sup_lt_of_lt hS cC.directed_on SC, fun _ => le_supₛ⟩\n      exact\n        ⟨b, lt_of_le_of_ne hbk htriv, by\n          simp only [set.not_nonempty_iff_eq_empty.mp hS, Set.mem_empty_iff_false, forall_const, forall_prop_of_false,\n            not_false_iff]⟩⟩\n#align Iic_coatomic_of_compact_element Iic_coatomic_of_compact_element\n\n"}