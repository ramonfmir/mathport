{"well_founded_iff_is_Sup_finite_compact":
 "theorem well_founded_iff_is_Sup_finite_compact : well_founded ((· > ·) : α → α → Prop) ↔ is_Sup_finite_compact α :=\n  (well_founded_characterisations α).out 0 1\n#align well_founded_iff_is_Sup_finite_compact well_founded_iff_is_Sup_finite_compact\n\n",
 "well_founded_characterisations":
 "/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `well_founded_characterisations [])\n      (Command.declSig\n       []\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app\n             `well_founded\n             [(Term.typeAscription\n               \"(\"\n               (Term.paren \"(\" («term_>_» (Term.cdot \"·\") \">\" (Term.cdot \"·\")) \")\")\n               \":\"\n               [(Term.arrow `α \"→\" (Term.arrow `α \"→\" (Term.prop \"Prop\")))]\n               \")\")])\n            \",\"\n            (Term.app `is_Sup_finite_compact [`α])\n            \",\"\n            (Term.app `is_sup_closed_compact [`α])\n            \",\"\n            (Term.forall \"∀\" [`k] [(Term.typeSpec \":\" `α)] \",\" (Term.app `is_compact_element [`k]))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact \"exact\" (Term.app `well_founded.is_Sup_finite_compact [`α]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"3\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact \"exact\" (Term.app `is_Sup_finite_compact.is_sup_closed_compact [`α]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"1\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact \"exact\" (Term.app `is_sup_closed_compact.well_founded [`α]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"↔\" (num \"4\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact \"exact\" (Term.app `is_Sup_finite_compact_iff_all_elements_compact [`α]))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact \"exact\" (Term.app `well_founded.is_Sup_finite_compact [`α]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"3\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact \"exact\" (Term.app `is_Sup_finite_compact.is_sup_closed_compact [`α]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"1\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact \"exact\" (Term.app `is_sup_closed_compact.well_founded [`α]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"↔\" (num \"4\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact \"exact\" (Term.app `is_Sup_finite_compact_iff_all_elements_compact [`α]))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.exact \"exact\" (Term.app `is_Sup_finite_compact_iff_all_elements_compact [`α]))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.app `is_Sup_finite_compact_iff_all_elements_compact [`α]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `is_Sup_finite_compact_iff_all_elements_compact [`α])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `α\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `is_Sup_finite_compact_iff_all_elements_compact\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"↔\" (num \"4\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«↔»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«↔»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«↔»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  well_founded_characterisations\n  :\n    TFAE\n      [\n        well_founded ( ( · > · ) : α → α → Prop )\n          ,\n          is_Sup_finite_compact α\n          ,\n          is_sup_closed_compact α\n          ,\n          ∀ k : α , is_compact_element k\n        ]\n  :=\n    by\n      tfae_have 1 → 2\n        ;\n        · exact well_founded.is_Sup_finite_compact α\n        tfae_have 2 → 3\n        ;\n        · exact is_Sup_finite_compact.is_sup_closed_compact α\n        tfae_have 3 → 1\n        ;\n        · exact is_sup_closed_compact.well_founded α\n        tfae_have 2 ↔ 4\n        ;\n        · exact is_Sup_finite_compact_iff_all_elements_compact α\n        tfae_finish\n#align well_founded_characterisations well_founded_characterisations\n\n",
 "well_founded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem is_sup_closed_compact.well_founded (h : is_sup_closed_compact α) : well_founded ((· > ·) : α → α → Prop) :=\n  by\n  refine' rel_embedding.well_founded_iff_no_descending_seq.mpr ⟨fun a => _⟩\n  suffices Sup (Set.range a) ∈ Set.range a\n    by\n    obtain ⟨n, hn⟩ := set.mem_range.mp this\n    have h' : Sup (Set.range a) < a (n + 1) := by\n      change _ > _\n      simp [← hn, a.map_rel_iff]\n    apply lt_irrefl (a (n + 1))\n    apply lt_of_le_of_lt _ h'\n    apply le_supₛ\n    apply Set.mem_range_self\n  apply h (Set.range a)\n  · use a 37\n    apply Set.mem_range_self\n  · rintro x ⟨m, hm⟩ y ⟨n, hn⟩\n    use «expr ⊔ » m n\n    rw [← hm, ← hn]\n    apply RelHomClass.map_sup a\n#align is_sup_closed_compact.well_founded is_sup_closed_compact.well_founded\n\n",
 "set_independent_iff_finite":
 "theorem complete_lattice.set_independent_iff_finite {s : set α} :\n    complete_lattice.set_independent s ↔ ∀ t : Finset α, ↑t ⊆ s → complete_lattice.set_independent (↑t : set α) :=\n  ⟨fun hs t ht => hs.mono ht, fun h a ha =>\n    by\n    rw [disjoint_iff, inf_Sup_eq_supr_inf_sup_finset, supᵢ_eq_bot]\n    intro t\n    rw [supᵢ_eq_bot, finset.sup_id_eq_Sup]\n    intro ht\n    classical\n      have h' := (h (insert a t) _ (t.mem_insert_self a)).eq_bot\n      · rwa [Finset.coe_insert, Set.insert_diff_self_of_not_mem] at h'\n        exact fun con => ((Set.mem_diff a).1 (ht con)).2 (Set.mem_singleton a)\n      · rw [Finset.coe_insert, Set.insert_subset]\n        exact ⟨ha, Set.Subset.trans ht (Set.diff_subset _ _)⟩⟩\n#align complete_lattice.set_independent_iff_finite complete_lattice.set_independent_iff_finite\n\n",
 "set_independent_Union_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem complete_lattice.set_independent_Union_of_directed {η : Type _} {s : η → set α} (hs : Directed (· ⊆ ·) s)\n    (h : ∀ i, complete_lattice.set_independent (s i)) :\n    complete_lattice.set_independent\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  by\n  by_cases hη : nonempty η\n  · skip\n    rw [complete_lattice.set_independent_iff_finite]\n    intro t ht\n    obtain ⟨I, fi, hI⟩ := set.finite_subset_Union t.finite_to_set ht\n    obtain ⟨i, hi⟩ := hs.finset_le fi.to_finset\n    exact (h i).mono (Set.Subset.trans hI <| Set.unionᵢ₂_subset fun j hj => hi j (fi.mem_to_finset.2 hj))\n  · rintro a ⟨_, ⟨i, _⟩, _⟩\n    exfalso\n    exact hη ⟨i⟩\n#align complete_lattice.set_independent_Union_of_directed complete_lattice.set_independent_Union_of_directed\n\n",
 "le_iff_compact_le_imp":
 "theorem le_iff_compact_le_imp {a b : α} : a ≤ b ↔ ∀ c : α, complete_lattice.is_compact_element c → c ≤ a → c ≤ b :=\n  ⟨fun ab c hc ca => le_trans ca ab, fun h =>\n    by\n    rw [← Sup_compact_le_eq a, ← Sup_compact_le_eq b]\n    exact supₛ_le_supₛ fun c hc => ⟨hc.1, h c hc.1 hc.2⟩⟩\n#align le_iff_compact_le_imp le_iff_compact_le_imp\n\n",
 "is_sup_closed_compact_iff_well_founded":
 "theorem is_sup_closed_compact_iff_well_founded : is_sup_closed_compact α ↔ well_founded ((· > ·) : α → α → Prop) :=\n  (well_founded_characterisations α).out 2 0\n#align is_sup_closed_compact_iff_well_founded is_sup_closed_compact_iff_well_founded\n\n",
 "is_sup_closed_compact":
 "theorem is_Sup_finite_compact.is_sup_closed_compact (h : is_Sup_finite_compact α) : is_sup_closed_compact α :=\n  by\n  intro s hne hsc; obtain ⟨t, ht₁, ht₂⟩ := h s; clear h\n  cases' t.eq_empty_or_nonempty with h h\n  · subst h\n    rw [finset.sup_empty] at ht₂\n    rw [ht₂]\n    simp [eq_singleton_bot_of_supₛ_eq_bot_of_nonempty ht₂ hne]\n  · rw [ht₂]\n    exact t.sup_closed_of_sup_closed h ht₁ hsc\n#align is_Sup_finite_compact.is_sup_closed_compact is_Sup_finite_compact.is_sup_closed_compact\n\n",
 "is_compact_element_iff_le_of_directed_Sup_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- An element `k` is compact if and only if any directed set with `Sup` above\n`k` already got above `k` at some point in the set. -/\ntheorem is_compact_element_iff_le_of_directed_Sup_le (k : α) :\n    is_compact_element k ↔ ∀ s : set α, s.nonempty → DirectedOn (· ≤ ·) s → k ≤ supₛ s → ∃ x : α, x ∈ s ∧ k ≤ x := by\n  classical\n    constructor\n    · intro hk s hne hdir hsup\n      obtain ⟨t, ht⟩ := hk s hsup\n      -- certainly every element of t is below something in s, since ↑t ⊆ s.\n      have t_below_s : ∀ x ∈ t, ∃ y ∈ s, x ≤ y := fun x hxt => ⟨x, ht.left hxt, le_rfl⟩\n      obtain ⟨x, ⟨hxs, hsupx⟩⟩ := finset.sup_le_of_le_directed s hne hdir t t_below_s\n      exact ⟨x, ⟨hxs, le_trans ht.right hsupx⟩⟩\n    · intro hk s hsup\n      -- Consider the set of finite joins of elements of the (plain) set s.\n      let S : set α := { x | ∃ t : Finset α, ↑t ⊆ s ∧ x = t.sup id }\n      -- S is directed, nonempty, and still has sup above k.\n      have dir_US : DirectedOn (· ≤ ·) S := by\n        rintro x ⟨c, hc⟩ y ⟨d, hd⟩\n        use «expr ⊔ » x y\n        constructor\n        · use c ∪ d\n          constructor\n          · simp only [hc.left, hd.left, Set.union_subset_iff, Finset.coe_union, and_self_iff]\n          · simp only [hc.right, hd.right, finset.sup_union]\n        simp only [and_self_iff, le_sup_left, le_sup_right]\n      have sup_S : Sup s ≤ Sup S := by\n        apply supₛ_le_supₛ\n        intro x hx\n        use {x}\n        simpa only [and_true_iff, id.def, Finset.coe_singleton, eq_self_iff_true, finset.sup_singleton,\n          Set.singleton_subset_iff]\n      have Sne : S.nonempty := by\n        suffices : «expr⊥» ∈ S\n        exact Set.nonempty_of_mem this\n        use ∅\n        simp only [Set.empty_subset, Finset.coe_empty, finset.sup_empty, eq_self_iff_true, and_self_iff]\n      -- Now apply the defn of compact and finish.\n      obtain ⟨j, ⟨hjS, hjk⟩⟩ := hk S Sne dir_US (le_trans hsup sup_S)\n      obtain ⟨t, ⟨htS, htsup⟩⟩ := hjS\n      use t\n      exact ⟨htS, by rwa [← htsup]⟩\n#align is_compact_element_iff_le_of_directed_Sup_le is_compact_element_iff_le_of_directed_Sup_le\n\n",
 "is_compact_element_iff":
 "/-\nCopyright (c) 2021 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\ntheorem is_compact_element_iff.{u} {α : Type u} [CompleteLattice α] (k : α) :\n    complete_lattice.is_compact_element k ↔ ∀ (ι : Type u) (s : ι → α), k ≤ supᵢ s → ∃ t : Finset ι, k ≤ t.sup s := by\n  classical\n    constructor\n    · intro H ι s hs\n      obtain ⟨t, ht, ht'⟩ := H (Set.range s) hs\n      have : ∀ x : t, ∃ i, s i = x := fun x => ht x.prop\n      choose f hf using this\n      refine' ⟨finset.univ.image f, ht'.trans _⟩\n      · rw [finset.sup_le_iff]\n        intro b hb\n        rw [← show s (f ⟨b, hb⟩) = id b from hf _]\n        exact finset.le_sup (Finset.mem_image_of_mem f <| finset.mem_univ ⟨b, hb⟩)\n    · intro H s hs\n      obtain ⟨t, ht⟩ :=\n        H s coe\n          (by\n            delta supᵢ\n            rwa [Subtype.range_coe])\n      refine' ⟨t.image coe, by simp, ht.trans _⟩\n      rw [finset.sup_le_iff]\n      exact fun x hx => @finset.le_sup _ _ _ _ _ id _ (Finset.mem_image_of_mem coe hx)\n#align is_compact_element_iff is_compact_element_iff\n\n",
 "is_Sup_finite_compact_iff_is_sup_closed_compact":
 "theorem is_Sup_finite_compact_iff_is_sup_closed_compact : is_Sup_finite_compact α ↔ is_sup_closed_compact α :=\n  (well_founded_characterisations α).out 1 2\n#align is_Sup_finite_compact_iff_is_sup_closed_compact is_Sup_finite_compact_iff_is_sup_closed_compact\n\n",
 "is_Sup_finite_compact_iff_all_elements_compact":
 "theorem is_Sup_finite_compact_iff_all_elements_compact : is_Sup_finite_compact α ↔ ∀ k : α, is_compact_element k :=\n  by\n  refine' ⟨fun h k s hs => _, fun h s => _⟩\n  · obtain ⟨t, ⟨hts, htsup⟩⟩ := h s\n    use t, hts\n    rwa [← htsup]\n  · obtain ⟨t, ⟨hts, htsup⟩⟩ := h (Sup s) s (by rfl)\n    have : Sup s = t.sup id := by\n      suffices t.sup id ≤ Sup s by apply le_antisymm <;> assumption\n      simp only [id.def, finset.sup_le_iff]\n      intro x hx\n      exact le_supₛ (hts hx)\n    use t, hts, this\n#align is_Sup_finite_compact_iff_all_elements_compact is_Sup_finite_compact_iff_all_elements_compact\n\n",
 "is_Sup_finite_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem well_founded.is_Sup_finite_compact (h : well_founded ((· > ·) : α → α → Prop)) : is_Sup_finite_compact α :=\n  by\n  intro s\n  let p : set α := { x | ∃ t : Finset α, ↑t ⊆ s ∧ t.sup id = x }\n  have hp : p.nonempty := by\n    use «expr⊥», ∅\n    simp\n  obtain ⟨m, ⟨t, ⟨ht₁, ht₂⟩⟩, hm⟩ := well_founded.well_founded_iff_has_max'.mp h p hp\n  use t\n  simp only [ht₁, ht₂, true_and_iff]\n  apply le_antisymm\n  · apply supₛ_le\n    intro y hy\n    classical\n      have hy' : (insert y t).sup id ∈ p := by\n        use insert y t\n        simp\n        rw [Set.insert_subset]\n        exact ⟨hy, ht₁⟩\n      have hm' : m ≤ (insert y t).sup id := by\n        rw [← ht₂]\n        exact finset.sup_mono (t.subset_insert y)\n      rw [← hm _ hy' hm']\n      simp\n  · rw [← ht₂, finset.sup_id_eq_Sup]\n    exact supₛ_le_supₛ ht₁\n#align well_founded.is_Sup_finite_compact well_founded.is_Sup_finite_compact\n\n",
 "inf_Sup_eq_supr_inf_sup_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- This property is equivalent to `α` being upper continuous. -/\ntheorem inf_Sup_eq_supr_inf_sup_finset :\n    «expr ⊓ » a (supₛ s) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr ⊓ » a (t.sup id)) :=\n  le_antisymm\n    (by\n      rw [le_iff_compact_le_imp]\n      intro c hc hcinf\n      rw [le_inf_iff] at hcinf\n      rcases hc s hcinf.2 with ⟨t, ht1, ht2⟩\n      exact (le_inf hcinf.1 ht2).trans (le_supᵢ₂ t ht1))\n    (supᵢ_le fun t => supᵢ_le fun h => inf_le_inf_left _ ((finset.sup_id_eq_Sup t).symm ▸ supₛ_le_supₛ h))\n#align inf_Sup_eq_supr_inf_sup_finset inf_Sup_eq_supr_inf_sup_finset\n\n",
 "inf_Sup_eq_of_directed_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- This property is sometimes referred to as `α` being upper continuous. -/\ntheorem inf_Sup_eq_of_directed_on (h : DirectedOn (· ≤ ·) s) :\n    «expr ⊓ » a (supₛ s) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" («expr ⊓ » a b) :=\n  le_antisymm\n    (by\n      rw [le_iff_compact_le_imp]\n      by_cases hs : s.nonempty\n      · intro c hc hcinf\n        rw [le_inf_iff] at hcinf\n        rw [complete_lattice.is_compact_element_iff_le_of_directed_Sup_le] at hc\n        rcases hc s hs h hcinf.2 with ⟨d, ds, cd⟩\n        exact (le_inf hcinf.1 cd).trans (le_supᵢ₂ d ds)\n      · rw [Set.not_nonempty_iff_eq_empty] at hs\n        simp [hs])\n    supᵢ_inf_le_inf_supₛ\n#align inf_Sup_eq_of_directed_on inf_Sup_eq_of_directed_on\n\n",
 "independent_sUnion_of_directed":
 "theorem complete_lattice.independent_sUnion_of_directed {s : set (set α)} (hs : DirectedOn (· ⊆ ·) s)\n    (h : ∀ a ∈ s, complete_lattice.set_independent a) : complete_lattice.set_independent (⋃₀ s) := by\n  rw [Set.unionₛ_eq_unionᵢ] <;>\n    exact complete_lattice.set_independent_Union_of_directed hs.directed_coe (by simpa using h)\n#align complete_lattice.independent_sUnion_of_directed complete_lattice.independent_sUnion_of_directed\n\n",
 "finset_sup_compact_of_compact":
 "theorem finset_sup_compact_of_compact {α β : Type _} [CompleteLattice α] {f : β → α} (s : Finset β)\n    (h : ∀ x ∈ s, is_compact_element (f x)) : is_compact_element (s.sup f) := by\n  classical\n    rw [is_compact_element_iff_le_of_directed_Sup_le]\n    intro d hemp hdir hsup\n    change f with id ∘ f\n    rw [← finset.sup_finset_image]\n    apply finset.sup_le_of_le_directed d hemp hdir\n    rintro x hx\n    obtain ⟨p, ⟨hps, rfl⟩⟩ := finset.mem_image.mp hx\n    specialize h p hps\n    rw [is_compact_element_iff_le_of_directed_Sup_le] at h\n    specialize h d hemp hdir (le_trans (finset.le_sup hps) hsup)\n    simpa only [exists_prop]\n#align finset_sup_compact_of_compact finset_sup_compact_of_compact\n\n",
 "finite_of_set_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem well_founded.finite_of_set_independent (h : well_founded ((· > ·) : α → α → Prop)) {s : set α}\n    (hs : set_independent s) : s.finite := by\n  classical\n    refine' set.not_infinite.mp fun contra => _\n    obtain ⟨t, ht₁, ht₂⟩ := well_founded.is_Sup_finite_compact α h s\n    replace contra : ∃ x : α, x ∈ s ∧ x ≠ «expr⊥» ∧ x ∉ t\n    · have : (s \\ (insert («expr⊥») t : Finset α)).infinite := contra.diff (finset.finite_to_set _)\n      obtain ⟨x, hx₁, hx₂⟩ := this.nonempty\n      exact ⟨x, hx₁, by simpa [not_or] using hx₂⟩\n    obtain ⟨x, hx₀, hx₁, hx₂⟩ := contra\n    replace hs : «expr ⊓ » x (Sup s) = «expr⊥»\n    · have := hs.mono (by simp [ht₁, hx₀, -Set.union_singleton] : ↑t ∪ {x} ≤ s) (by simp : x ∈ _)\n      simpa [Disjoint, hx₂, ← t.sup_id_eq_Sup, ← ht₂] using this.eq_bot\n    apply hx₁\n    rw [← hs, eq_comm, inf_eq_left]\n    exact le_supₛ hx₀\n#align well_founded.finite_of_set_independent well_founded.finite_of_set_independent\n\n",
 "finite_of_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem well_founded.finite_of_independent (hwf : well_founded ((· > ·) : α → α → Prop)) {ι : Type _} {t : ι → α}\n    (ht : independent t) (h_ne_bot : ∀ i, t i ≠ «expr⊥») : Finite ι :=\n  haveI := (well_founded.finite_of_set_independent hwf ht.set_independent_range).to_subtype\n  finite.of_injective_finite_range (ht.injective h_ne_bot)\n#align well_founded.finite_of_independent well_founded.finite_of_independent\n\n",
 "exists_finset_of_le_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem is_compact_element.exists_finset_of_le_supr {k : α} (hk : is_compact_element k) {ι : Type _} (f : ι → α)\n    (h : k ≤ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) :\n    ∃ s : Finset ι,\n      k ≤ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) :=\n  by\n  classical\n    let g : Finset ι → α := fun s =>\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)\n    have h1 : DirectedOn (· ≤ ·) (Set.range g) :=\n      by\n      rintro - ⟨s, rfl⟩ - ⟨t, rfl⟩\n      exact\n        ⟨g (s ∪ t), ⟨s ∪ t, rfl⟩, supᵢ_le_supᵢ_of_subset (Finset.subset_union_left s t),\n          supᵢ_le_supᵢ_of_subset (Finset.subset_union_right s t)⟩\n    have h2 : k ≤ Sup (Set.range g) :=\n      h.trans\n        (supᵢ_le fun i =>\n          le_supₛ_of_le ⟨{i}, rfl⟩ (le_supᵢ_of_le i (le_supᵢ_of_le (Finset.mem_singleton_self i) le_rfl)))\n    obtain ⟨-, ⟨s, rfl⟩, hs⟩ :=\n      (is_compact_element_iff_le_of_directed_Sup_le α k).mp hk (Set.range g) (Set.range_nonempty g) h1 h2\n    exact ⟨s, hs⟩\n#align is_compact_element.exists_finset_of_le_supr is_compact_element.exists_finset_of_le_supr\n\n",
 "directed_Sup_lt_of_lt":
 "/-- A compact element `k` has the property that any directed set lying strictly below `k` has\nits Sup strictly below `k`. -/\ntheorem is_compact_element.directed_Sup_lt_of_lt {α : Type _} [CompleteLattice α] {k : α} (hk : is_compact_element k)\n    {s : set α} (hemp : s.nonempty) (hdir : DirectedOn (· ≤ ·) s) (hbelow : ∀ x ∈ s, x < k) : supₛ s < k :=\n  by\n  rw [is_compact_element_iff_le_of_directed_Sup_le] at hk\n  by_contra\n  have sSup : Sup s ≤ k := supₛ_le fun s hs => (hbelow s hs).le\n  replace sSup : Sup s = k := eq_iff_le_not_lt.mpr ⟨sSup, h⟩\n  obtain ⟨x, hxs, hkx⟩ := hk s hemp hdir sSup.symm.le\n  obtain hxk := hbelow x hxs\n  exact hxk.ne (hxk.le.antisymm hkx)\n#align is_compact_element.directed_Sup_lt_of_lt is_compact_element.directed_Sup_lt_of_lt\n\n",
 "complemented_lattice_of_is_atomistic":
 "/-- See Theorem 6.6, Călugăreanu -/\ntheorem complemented_lattice_of_is_atomistic [IsAtomistic α] : ComplementedLattice α :=\n  complemented_lattice_of_Sup_atoms_eq_top supₛ_atoms_eq_top\n#align complemented_lattice_of_is_atomistic complemented_lattice_of_is_atomistic\n\n",
 "complemented_lattice_of_Sup_atoms_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- See Theorem 6.6, Călugăreanu -/\ntheorem complemented_lattice_of_Sup_atoms_eq_top (h : supₛ { a : α | IsAtom a } = «expr⊤») : ComplementedLattice α :=\n  ⟨fun b =>\n    by\n    obtain ⟨s, ⟨s_ind, b_inf_Sup_s, s_atoms⟩, s_max⟩ :=\n      zorn_subset { s : set α | complete_lattice.set_independent s ∧ «expr ⊓ » b (Sup s) = «expr⊥» ∧ ∀ a ∈ s, IsAtom a }\n        _\n    · refine'\n        ⟨Sup s, disjoint_iff.mpr b_inf_Sup_s,\n          codisjoint_iff_le_sup.mpr <| h.symm.trans_le <| supₛ_le_iff.2 fun a ha => _⟩\n      rw [← inf_eq_left]\n      refine' (ha.le_iff.mp inf_le_left).resolve_left fun con => ha.1 _\n      rw [eq_bot_iff, ← con]\n      refine' le_inf (le_refl a) ((le_supₛ _).trans le_sup_right)\n      rw [← disjoint_iff] at *\n      have a_dis_Sup_s : Disjoint a (Sup s) := con.mono_right le_sup_right\n      rw [← s_max (s ∪ {a}) ⟨fun x hx => _, ⟨_, fun x hx => _⟩⟩ (Set.subset_union_left _ _)]\n      · exact Set.mem_union_right _ (Set.mem_singleton _)\n      · rw [Set.mem_union, Set.mem_singleton_iff] at hx\n        by_cases xa : x = a\n        · simp only [xa, Set.mem_singleton, Set.insert_diff_of_mem, Set.union_singleton]\n          exact con.mono_right (le_trans (supₛ_le_supₛ (Set.diff_subset s {a})) le_sup_right)\n        · have h : (s ∪ {a}) \\ {x} = s \\ {x} ∪ {a} :=\n            by\n            simp only [Set.union_singleton]\n            rw [Set.insert_diff_of_not_mem]\n            rw [Set.mem_singleton_iff]\n            exact ne.symm xa\n          rw [h, supₛ_union, supₛ_singleton]\n          apply (s_ind (hx.resolve_right xa)).disjoint_sup_right_of_disjoint_sup_left (a_dis_Sup_s.mono_right _).symm\n          rw [← supₛ_insert, Set.insert_diff_singleton, Set.insert_eq_of_mem (hx.resolve_right xa)]\n      · rw [supₛ_union, supₛ_singleton, ← disjoint_iff]\n        exact b_inf_Sup_s.disjoint_sup_right_of_disjoint_sup_left con.symm\n      · rw [Set.mem_union, Set.mem_singleton_iff] at hx\n        cases hx\n        · exact s_atoms x hx\n        · rw [hx]\n          exact ha\n    · intro c hc1 hc2\n      refine'\n        ⟨⋃₀ c,\n          ⟨complete_lattice.independent_sUnion_of_directed hc2.directed_on fun s hs => (hc1 hs).1, _, fun a ha => _⟩,\n          fun _ => Set.subset_unionₛ_of_mem⟩\n      · rw [supₛ_unionₛ, ← supₛ_image, inf_Sup_eq_of_directed_on, supᵢ_eq_bot]\n        · intro i\n          rw [supᵢ_eq_bot]\n          intro hi\n          obtain ⟨x, xc, rfl⟩ := (Set.mem_image _ _ _).1 hi\n          exact (hc1 xc).2.1\n        · rw [directedOn_image]\n          refine' hc2.directed_on.mono fun s t => supₛ_le_supₛ\n      · rcases Set.mem_unionₛ.1 ha with ⟨s, sc, as⟩\n        exact (hc1 sc).2.2 a as⟩\n#align complemented_lattice_of_Sup_atoms_eq_top complemented_lattice_of_Sup_atoms_eq_top\n\n",
 "complemented_lattice_iff_is_atomistic":
 "theorem complemented_lattice_iff_is_atomistic : ComplementedLattice α ↔ IsAtomistic α :=\n  by\n  constructor <;> intros\n  · exact is_atomistic_of_complemented_lattice\n  · exact complemented_lattice_of_is_atomistic\n#align complemented_lattice_iff_is_atomistic complemented_lattice_iff_is_atomistic\n\n",
 "compactly_generated_of_well_founded":
 "theorem compactly_generated_of_well_founded (h : well_founded ((· > ·) : α → α → Prop)) : is_compactly_generated α :=\n  by\n  rw [well_founded_iff_is_Sup_finite_compact, is_Sup_finite_compact_iff_all_elements_compact] at h\n  -- x is the join of the set of compact elements {x}\n  exact ⟨fun x => ⟨{x}, ⟨fun x _ => h x, supₛ_singleton⟩⟩⟩\n#align compactly_generated_of_well_founded compactly_generated_of_well_founded\n\n",
 "coatomic_of_top_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem coatomic_of_top_compact (h : is_compact_element («expr⊤» : α)) : IsCoatomic α :=\n  (@OrderIso.IicTop α _ _).is_coatomic_iff.mp (Iic_coatomic_of_compact_element h)\n#align coatomic_of_top_compact coatomic_of_top_compact\n\n",
 "Sup_compact_le_eq":
 "@[simp]\ntheorem Sup_compact_le_eq (b) : supₛ { c : α | complete_lattice.is_compact_element c ∧ c ≤ b } = b :=\n  by\n  rcases is_compactly_generated.exists_Sup_eq b with ⟨s, hs, rfl⟩\n  exact le_antisymm (supₛ_le fun c hc => hc.2) (supₛ_le_supₛ fun c cs => ⟨hs c cs, le_supₛ cs⟩)\n#align Sup_compact_le_eq Sup_compact_le_eq\n\n",
 "Sup_compact_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem Sup_compact_eq_top : supₛ { a : α | complete_lattice.is_compact_element a } = «expr⊤» :=\n  by\n  refine' eq.trans (congr rfl (Set.ext fun x => _)) (Sup_compact_le_eq («expr⊤»))\n  exact (and_iff_left le_top).symm\n#align Sup_compact_eq_top Sup_compact_eq_top\n\n",
 "Iic_coatomic_of_compact_element":
 "/-- A compact element `k` has the property that any `b < k` lies below a \"maximal element below\n`k`\", which is to say `[⊥, k]` is coatomic. -/\ntheorem Iic_coatomic_of_compact_element {k : α} (h : is_compact_element k) : IsCoatomic (Set.Iic k) :=\n  ⟨fun ⟨b, hbk⟩ => by\n    by_cases htriv : b = k\n    · left\n      ext\n      simp only [htriv, Set.Iic.coe_top, subtype.coe_mk]\n    right\n    obtain ⟨a, a₀, ba, h⟩ := zorn_nonempty_partialOrder₀ (Set.Iio k) _ b (lt_of_le_of_ne hbk htriv)\n    · refine' ⟨⟨a, le_of_lt a₀⟩, ⟨ne_of_lt a₀, fun c hck => by_contradiction fun c₀ => _⟩, ba⟩\n      cases h c.1 (lt_of_le_of_ne c.2 fun con => c₀ (subtype.ext con)) hck.le\n      exact lt_irrefl _ hck\n    · intro S SC cC I IS\n      by_cases hS : S.nonempty\n      · exact ⟨Sup S, h.directed_Sup_lt_of_lt hS cC.directed_on SC, fun _ => le_supₛ⟩\n      exact\n        ⟨b, lt_of_le_of_ne hbk htriv, by\n          simp only [set.not_nonempty_iff_eq_empty.mp hS, Set.mem_empty_iff_false, forall_const, forall_prop_of_false,\n            not_false_iff]⟩⟩\n#align Iic_coatomic_of_compact_element Iic_coatomic_of_compact_element\n\n"}