{"to_Z_of_lt":
 "theorem to_Z_of_lt (hi : i < i0) : to_Z i0 i = -nat.find (exists_pred_iterate_of_le hi.le) :=\n  dif_neg (not_le.mpr hi)\n#align to_Z_of_lt to_Z_of_lt\n\n",
 "to_Z_of_ge":
 "theorem to_Z_of_ge (hi : i0 ≤ i) : to_Z i0 i = nat.find (exists_succ_iterate_of_le hi) :=\n  dif_pos hi\n#align to_Z_of_ge to_Z_of_ge\n\n",
 "to_Z_of_eq":
 "@[simp]\ntheorem to_Z_of_eq : to_Z i0 i0 = 0 := by\n  rw [to_Z_of_ge le_rfl]\n  norm_cast\n  refine' le_antisymm (Nat.find_le _) (zero_le _)\n  rw [function.iterate_zero, id.def]\n#align to_Z_of_eq to_Z_of_eq\n\n",
 "to_Z_nonneg":
 "theorem to_Z_nonneg (hi : i0 ≤ i) : 0 ≤ to_Z i0 i :=\n  by\n  rw [to_Z_of_ge hi]\n  exact nat.cast_nonneg _\n#align to_Z_nonneg to_Z_nonneg\n\n",
 "to_Z_neg":
 "theorem to_Z_neg (hi : i < i0) : to_Z i0 i < 0 :=\n  by\n  refine' lt_of_le_of_ne _ _\n  · rw [to_Z_of_lt hi, neg_nonpos]\n    exact nat.cast_nonneg _\n  · by_contra\n    have h_eq := iterate_pred_to_Z i hi\n    rw [← h_eq, h] at hi\n    simpa only [neg_zero, Int.toNat_zero, function.iterate_zero, id.def, lt_self_iff_false] using hi\n#align to_Z_neg to_Z_neg\n\n",
 "to_Z_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem to_Z_mono {i j : ι} (h_le : i ≤ j) : to_Z i0 i ≤ to_Z i0 j :=\n  by\n  by_cases hi_max : is_max i\n  · rw [le_antisymm h_le (hi_max h_le)]\n  by_cases hj_min : is_min j\n  · rw [le_antisymm h_le (hj_min h_le)]\n  cases' le_or_lt i0 i with hi hi <;> cases' le_or_lt i0 j with hj hj\n  · let m := nat.find (exists_succ_iterate_of_le h_le)\n    have hm : («expr ^[ ]» succ m) i = j := nat.find_spec (exists_succ_iterate_of_le h_le)\n    have hj_eq : j = («expr ^[ ]» succ ((to_Z i0 i).to_nat + m)) i0 :=\n      by\n      rw [← hm, add_comm]\n      nth_rw 1 [← iterate_succ_to_Z i hi]\n      rw [function.iterate_add]\n    by_contra h\n    push_neg  at h\n    by_cases hm0 : m = 0\n    · rw [hm0, function.iterate_zero, id.def] at hm\n      rw [hm] at h\n      exact lt_irrefl _ h\n    refine' hi_max (max_of_succ_le (le_trans _ (@le_of_to_Z_le _ _ _ _ _ i0 _ _ _)))\n    · exact j\n    · have h_succ_le : («expr ^[ ]» succ ((to_Z i0 i).to_nat + 1)) i0 ≤ j :=\n        by\n        rw [hj_eq]\n        refine' Monotone.monotone_iterate_of_le_map succ_mono (le_succ i0) (add_le_add_left _ _)\n        exact nat.one_le_iff_ne_zero.mpr hm0\n      rwa [function.iterate_succ', Function.comp_apply, iterate_succ_to_Z i hi] at h_succ_le\n    · exact h.le\n  · exact absurd h_le (not_le.mpr (hj.trans_le hi))\n  · exact (to_Z_neg hi).le.trans (to_Z_nonneg hj)\n  · let m := nat.find (exists_pred_iterate_of_le h_le)\n    have hm : («expr ^[ ]» pred m) j = i := nat.find_spec (exists_pred_iterate_of_le h_le)\n    have hj_eq : i = («expr ^[ ]» pred ((-to_Z i0 j).to_nat + m)) i0 :=\n      by\n      rw [← hm, add_comm]\n      nth_rw 1 [← iterate_pred_to_Z j hj]\n      rw [function.iterate_add]\n    by_contra h\n    push_neg  at h\n    by_cases hm0 : m = 0\n    · rw [hm0, function.iterate_zero, id.def] at hm\n      rw [hm] at h\n      exact lt_irrefl _ h\n    refine' hj_min (min_of_le_pred _)\n    refine' (@le_of_to_Z_le _ _ _ _ _ i0 _ _ _).trans _\n    · exact i\n    · exact h.le\n    · have h_le_pred : i ≤ («expr ^[ ]» pred ((-to_Z i0 j).to_nat + 1)) i0 :=\n        by\n        rw [hj_eq]\n        refine' Monotone.antitone_iterate_of_map_le pred_mono (pred_le i0) (add_le_add_left _ _)\n        exact nat.one_le_iff_ne_zero.mpr hm0\n      rwa [function.iterate_succ', Function.comp_apply, iterate_pred_to_Z j hj] at h_le_pred\n#align to_Z_mono to_Z_mono\n\n",
 "to_Z_le_iff":
 "theorem to_Z_le_iff (i j : ι) : to_Z i0 i ≤ to_Z i0 j ↔ i ≤ j :=\n  ⟨le_of_to_Z_le, to_Z_mono⟩\n#align to_Z_le_iff to_Z_le_iff\n\n",
 "to_Z_iterate_succ_of_not_is_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem to_Z_iterate_succ_of_not_is_max (n : ℕ) (hn : ¬is_max ((«expr ^[ ]» succ n) i0)) :\n    to_Z i0 ((«expr ^[ ]» succ n) i0) = n :=\n  by\n  let m := (to_Z i0 ((«expr ^[ ]» succ n) i0)).to_nat\n  have h_eq : («expr ^[ ]» succ m) i0 = («expr ^[ ]» succ n) i0 := iterate_succ_to_Z _ (le_succ_iterate _ _)\n  by_cases hmn : m = n\n  · nth_rw 2 [← hmn]\n    simp_rw [m]\n    rw [Int.toNat_eq_max, to_Z_of_ge (le_succ_iterate _ _), max_eq_left]\n    exact nat.cast_nonneg _\n  suffices : is_max ((«expr ^[ ]» succ n) i0); exact absurd this hn\n  exact is_max_iterate_succ_of_eq_of_ne h_eq.symm (ne.symm hmn)\n#align to_Z_iterate_succ_of_not_is_max to_Z_iterate_succ_of_not_is_max\n\n",
 "to_Z_iterate_succ_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem to_Z_iterate_succ_le (n : ℕ) : to_Z i0 ((«expr ^[ ]» succ n) i0) ≤ n :=\n  by\n  rw [to_Z_of_ge (le_succ_iterate _ _)]\n  norm_cast\n  exact nat.find_min' (exists_succ_iterate_of_le _) rfl\n#align to_Z_iterate_succ_le to_Z_iterate_succ_le\n\n",
 "to_Z_iterate_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem to_Z_iterate_succ [NoMaxOrder ι] (n : ℕ) : to_Z i0 ((«expr ^[ ]» succ n) i0) = n :=\n  to_Z_iterate_succ_of_not_is_max n (not_isMax _)\n#align to_Z_iterate_succ to_Z_iterate_succ\n\n",
 "to_Z_iterate_pred_of_not_is_min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem to_Z_iterate_pred_of_not_is_min (n : ℕ) (hn : ¬is_min ((«expr ^[ ]» pred n) i0)) :\n    to_Z i0 ((«expr ^[ ]» pred n) i0) = -n := by\n  cases n\n  · simp only [function.iterate_zero, id.def, to_Z_of_eq, Nat.cast_zero, neg_zero]\n  have : («expr ^[ ]» pred n.succ) i0 < i0 :=\n    by\n    refine' lt_of_le_of_ne (pred_iterate_le _ _) fun h_pred_iterate_eq => hn _\n    have h_pred_eq_pred : («expr ^[ ]» pred n.succ) i0 = («expr ^[ ]» pred 0) i0 := by\n      rwa [function.iterate_zero, id.def]\n    exact is_min_iterate_pred_of_eq_of_ne h_pred_eq_pred (nat.succ_ne_zero n)\n  let m := (-to_Z i0 ((«expr ^[ ]» pred n.succ) i0)).to_nat\n  have h_eq : («expr ^[ ]» pred m) i0 = («expr ^[ ]» pred n.succ) i0 := iterate_pred_to_Z _ this\n  by_cases hmn : m = n.succ\n  · nth_rw 2 [← hmn]\n    simp_rw [m]\n    rw [Int.toNat_eq_max, to_Z_of_lt this, max_eq_left, neg_neg]\n    rw [neg_neg]\n    exact nat.cast_nonneg _\n  · suffices : is_min ((«expr ^[ ]» pred n.succ) i0)\n    exact absurd this hn\n    exact is_min_iterate_pred_of_eq_of_ne h_eq.symm (ne.symm hmn)\n#align to_Z_iterate_pred_of_not_is_min to_Z_iterate_pred_of_not_is_min\n\n",
 "to_Z_iterate_pred_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem to_Z_iterate_pred_ge (n : ℕ) : -(n : ℤ) ≤ to_Z i0 ((«expr ^[ ]» pred n) i0) :=\n  by\n  cases' le_or_lt i0 ((«expr ^[ ]» pred n) i0) with h h\n  · have h_eq : («expr ^[ ]» pred n) i0 = i0 := le_antisymm (pred_iterate_le _ _) h\n    rw [h_eq, to_Z_of_eq]\n    simp only [right.neg_nonpos_iff, nat.cast_nonneg]\n  · rw [to_Z_of_lt h, neg_le_neg_iff]\n    norm_cast\n    exact nat.find_min' (exists_pred_iterate_of_le _) rfl\n#align to_Z_iterate_pred_ge to_Z_iterate_pred_ge\n\n",
 "to_Z_iterate_pred":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem to_Z_iterate_pred [NoMinOrder ι] (n : ℕ) : to_Z i0 ((«expr ^[ ]» pred n) i0) = -n :=\n  to_Z_iterate_pred_of_not_is_min n (not_isMin _)\n#align to_Z_iterate_pred to_Z_iterate_pred\n\n",
 "succ_fn_spec":
 "/-\nCopyright (c) 2022 Rémy Degenne. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Rémy Degenne\n-/\ntheorem succ_fn_spec (i : ι) : IsGLB (Set.Ioi i) (succ_fn i) :=\n  (exists_glb_Ioi i).some_spec\n#align succ_fn_spec succ_fn_spec\n\n",
 "succ_fn_le_of_lt":
 "theorem succ_fn_le_of_lt (i j : ι) (hij : i < j) : succ_fn i ≤ j :=\n  by\n  have h := succ_fn_spec i\n  rw [IsGLB, IsGreatest, mem_lowerBounds] at h\n  exact h.1 j hij\n#align succ_fn_le_of_lt succ_fn_le_of_lt\n\n",
 "le_succ_fn":
 "theorem le_succ_fn (i : ι) : i ≤ succ_fn i :=\n  by\n  rw [le_isGLB_iff (succ_fn_spec i), mem_lowerBounds]\n  exact fun x hx => le_of_lt hx\n#align le_succ_fn le_succ_fn\n\n",
 "le_of_to_Z_le":
 "theorem le_of_to_Z_le {j : ι} (h_le : to_Z i0 i ≤ to_Z i0 j) : i ≤ j :=\n  by\n  cases' le_or_lt i0 i with hi hi <;> cases' le_or_lt i0 j with hj hj\n  · rw [← iterate_succ_to_Z i hi, ← iterate_succ_to_Z j hj]\n    exact Monotone.monotone_iterate_of_le_map succ_mono (le_succ _) (Int.toNat_le_toNat h_le)\n  · exact absurd ((to_Z_neg hj).trans_le (to_Z_nonneg hi)) (not_lt.mpr h_le)\n  · exact hi.le.trans hj\n  · rw [← iterate_pred_to_Z i hi, ← iterate_pred_to_Z j hj]\n    refine' Monotone.antitone_iterate_of_map_le pred_mono (pred_le _) (Int.toNat_le_toNat _)\n    exact neg_le_neg h_le\n#align le_of_to_Z_le le_of_to_Z_le\n\n",
 "le_of_lt_succ_fn":
 "theorem le_of_lt_succ_fn (j i : ι) (hij : j < succ_fn i) : j ≤ i :=\n  by\n  rw [lt_isGLB_iff (succ_fn_spec i)] at hij\n  obtain ⟨k, hk_lb, hk⟩ := hij\n  rw [mem_lowerBounds] at hk_lb\n  exact not_lt.mp fun hi_lt_j => not_le.mpr hk (hk_lb j hi_lt_j)\n#align le_of_lt_succ_fn le_of_lt_succ_fn\n\n",
 "iterate_succ_to_Z":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_succ_to_Z (i : ι) (hi : i0 ≤ i) : («expr ^[ ]» succ (to_Z i0 i).to_nat) i0 = i :=\n  by\n  rw [to_Z_of_ge hi, Int.toNat_coe_nat]\n  exact nat.find_spec (exists_succ_iterate_of_le hi)\n#align iterate_succ_to_Z iterate_succ_to_Z\n\n",
 "iterate_pred_to_Z":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_pred_to_Z (i : ι) (hi : i < i0) : («expr ^[ ]» pred (-to_Z i0 i).to_nat) i0 = i :=\n  by\n  rw [to_Z_of_lt hi, neg_neg, Int.toNat_coe_nat]\n  exact nat.find_spec (exists_pred_iterate_of_le hi.le)\n#align iterate_pred_to_Z iterate_pred_to_Z\n\n",
 "is_max_of_succ_fn_le":
 "theorem is_max_of_succ_fn_le [locally_finite_order ι] (i : ι) (hi : succ_fn i ≤ i) : is_max i :=\n  by\n  refine' fun j hij => not_lt.mp fun hij_lt => _\n  have h_succ_fn_eq : succ_fn i = i := le_antisymm hi (le_succ_fn i)\n  have h_glb : IsGLB (finset.Ioc i j : set ι) i := by\n    rw [finset.coe_Ioc]\n    have h := succ_fn_spec i\n    rw [h_succ_fn_eq] at h\n    exact is_glb_Ioc_of_is_glb_Ioi hij_lt h\n  have hi_mem : i ∈ finset.Ioc i j := by\n    refine' finset.is_glb_mem _ h_glb _\n    exact ⟨_, finset.mem_Ioc.mpr ⟨hij_lt, le_rfl⟩⟩\n  rw [finset.mem_Ioc] at hi_mem\n  exact lt_irrefl i hi_mem.1\n#align is_max_of_succ_fn_le is_max_of_succ_fn_le\n\n",
 "is_glb_Ioc_of_is_glb_Ioi":
 "theorem is_glb_Ioc_of_is_glb_Ioi {i j k : ι} (hij_lt : i < j) (h : IsGLB (Set.Ioi i) k) : IsGLB (Set.Ioc i j) k :=\n  by\n  simp_rw [IsGLB, IsGreatest, mem_upperBounds, mem_lowerBounds] at h⊢\n  refine' ⟨fun x hx => h.1 x hx.1, fun x hx => h.2 x _⟩\n  intro y hy\n  cases' le_or_lt y j with h_le h_lt\n  · exact hx y ⟨hy, h_le⟩\n  · exact le_trans (hx j ⟨hij_lt, le_rfl⟩) h_lt.le\n#align is_glb_Ioc_of_is_glb_Ioi is_glb_Ioc_of_is_glb_Ioi\n\n",
 "injective_to_Z":
 "theorem injective_to_Z : function.injective (to_Z i0) := fun i j hij =>\n  le_antisymm (le_of_to_Z_le hij.le) (le_of_to_Z_le hij.symm.le)\n#align injective_to_Z injective_to_Z\n\n"}