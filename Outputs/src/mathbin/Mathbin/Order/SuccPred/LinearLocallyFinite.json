{"toZ_of_lt":
 "#print toZ_of_lt /-\ntheorem toZ_of_lt (hi : i < i0) : toZ i0 i = -nat.find (exists_pred_iterate_of_le hi.le) :=\n  dif_neg (not_le.mpr hi)\n#align to_Z_of_lt toZ_of_lt\n-/\n\n",
 "toZ_of_ge":
 "#print toZ_of_ge /-\ntheorem toZ_of_ge (hi : i0 ≤ i) : toZ i0 i = nat.find (exists_succ_iterate_of_le hi) :=\n  dif_pos hi\n#align to_Z_of_ge toZ_of_ge\n-/\n\n",
 "toZ_of_eq":
 "#print toZ_of_eq /-\n@[simp]\ntheorem toZ_of_eq : toZ i0 i0 = 0 := by\n  rw [toZ_of_ge le_rfl]\n  norm_cast\n  refine' le_antisymm (Nat.find_le _) (zero_le _)\n  rw [Function.iterate_zero, id.def]\n#align to_Z_of_eq toZ_of_eq\n-/\n\n",
 "toZ_nonneg":
 "#print toZ_nonneg /-\ntheorem toZ_nonneg (hi : i0 ≤ i) : 0 ≤ toZ i0 i := by\n  rw [toZ_of_ge hi]\n  exact Nat.cast_nonneg _\n#align to_Z_nonneg toZ_nonneg\n-/\n\n",
 "toZ_neg":
 "#print toZ_neg /-\ntheorem toZ_neg (hi : i < i0) : toZ i0 i < 0 :=\n  by\n  refine' lt_of_le_of_ne _ _\n  · rw [toZ_of_lt hi, neg_nonpos]\n    exact Nat.cast_nonneg _\n  · by_contra\n    have h_eq := iterate_pred_toZ i hi\n    rw [← h_eq, h] at hi\n    simpa only [neg_zero, Int.toNat_zero, Function.iterate_zero, id.def, lt_self_iff_false] using hi\n#align to_Z_neg toZ_neg\n-/\n\n",
 "toZ_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n#print toZ_mono /-\ntheorem toZ_mono {i j : ι} (h_le : i ≤ j) : toZ i0 i ≤ toZ i0 j :=\n  by\n  by_cases hi_max : IsMax i\n  · rw [le_antisymm h_le (hi_max h_le)]\n  by_cases hj_min : IsMin j\n  · rw [le_antisymm h_le (hj_min h_le)]\n  cases' le_or_lt i0 i with hi hi <;> cases' le_or_lt i0 j with hj hj\n  · let m := nat.find (exists_succ_iterate_of_le h_le)\n    have hm : («expr ^[ ]» succ m) i = j := nat.find_spec (exists_succ_iterate_of_le h_le)\n    have hj_eq : j = («expr ^[ ]» succ ((toZ i0 i).to_nat + m)) i0 :=\n      by\n      rw [← hm, add_comm]\n      nth_rw 1 [← iterate_succ_toZ i hi]\n      rw [Function.iterate_add]\n    by_contra h\n    push_neg  at h\n    by_cases hm0 : m = 0\n    · rw [hm0, Function.iterate_zero, id.def] at hm\n      rw [hm] at h\n      exact lt_irrefl _ h\n    refine' hi_max (max_of_succ_le (le_trans _ (@le_of_toZ_le _ _ _ _ _ i0 _ _ _)))\n    · exact j\n    · have h_succ_le : («expr ^[ ]» succ ((toZ i0 i).to_nat + 1)) i0 ≤ j :=\n        by\n        rw [hj_eq]\n        refine' Monotone.monotone_iterate_of_le_map succ_mono (le_succ i0) (add_le_add_left _ _)\n        exact nat.one_le_iff_ne_zero.mpr hm0\n      rwa [Function.iterate_succ', Function.comp_apply, iterate_succ_toZ i hi] at h_succ_le\n    · exact h.le\n  · exact absurd h_le (not_le.mpr (hj.trans_le hi))\n  · exact (toZ_neg hi).le.trans (toZ_nonneg hj)\n  · let m := nat.find (exists_pred_iterate_of_le h_le)\n    have hm : («expr ^[ ]» pred m) j = i := nat.find_spec (exists_pred_iterate_of_le h_le)\n    have hj_eq : i = («expr ^[ ]» pred ((-toZ i0 j).to_nat + m)) i0 :=\n      by\n      rw [← hm, add_comm]\n      nth_rw 1 [← iterate_pred_toZ j hj]\n      rw [Function.iterate_add]\n    by_contra h\n    push_neg  at h\n    by_cases hm0 : m = 0\n    · rw [hm0, Function.iterate_zero, id.def] at hm\n      rw [hm] at h\n      exact lt_irrefl _ h\n    refine' hj_min (min_of_le_pred _)\n    refine' (@le_of_toZ_le _ _ _ _ _ i0 _ _ _).trans _\n    · exact i\n    · exact h.le\n    · have h_le_pred : i ≤ («expr ^[ ]» pred ((-toZ i0 j).to_nat + 1)) i0 :=\n        by\n        rw [hj_eq]\n        refine' Monotone.antitone_iterate_of_map_le pred_mono (pred_le i0) (add_le_add_left _ _)\n        exact nat.one_le_iff_ne_zero.mpr hm0\n      rwa [Function.iterate_succ', Function.comp_apply, iterate_pred_toZ j hj] at h_le_pred\n#align to_Z_mono toZ_mono\n-/\n\n",
 "toZ_le_iff":
 "#print toZ_le_iff /-\ntheorem toZ_le_iff (i j : ι) : toZ i0 i ≤ toZ i0 j ↔ i ≤ j :=\n  ⟨le_of_toZ_le, toZ_mono⟩\n#align to_Z_le_iff toZ_le_iff\n-/\n\n",
 "toZ_iterate_succ_of_not_isMax":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n#print toZ_iterate_succ_of_not_isMax /-\ntheorem toZ_iterate_succ_of_not_isMax (n : ℕ) (hn : ¬IsMax ((«expr ^[ ]» succ n) i0)) :\n    toZ i0 ((«expr ^[ ]» succ n) i0) = n :=\n  by\n  let m := (toZ i0 ((«expr ^[ ]» succ n) i0)).to_nat\n  have h_eq : («expr ^[ ]» succ m) i0 = («expr ^[ ]» succ n) i0 := iterate_succ_toZ _ (le_succ_iterate _ _)\n  by_cases hmn : m = n\n  · nth_rw 2 [← hmn]\n    simp_rw [m]\n    rw [Int.toNat_eq_max, toZ_of_ge (le_succ_iterate _ _), max_eq_left]\n    exact Nat.cast_nonneg _\n  suffices : IsMax ((«expr ^[ ]» succ n) i0); exact absurd this hn\n  exact is_max_iterate_succ_of_eq_of_ne h_eq.symm (ne.symm hmn)\n#align to_Z_iterate_succ_of_not_is_max toZ_iterate_succ_of_not_isMax\n-/\n\n",
 "toZ_iterate_succ_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n#print toZ_iterate_succ_le /-\ntheorem toZ_iterate_succ_le (n : ℕ) : toZ i0 ((«expr ^[ ]» succ n) i0) ≤ n :=\n  by\n  rw [toZ_of_ge (le_succ_iterate _ _)]\n  norm_cast\n  exact nat.find_min' (exists_succ_iterate_of_le _) rfl\n#align to_Z_iterate_succ_le toZ_iterate_succ_le\n-/\n\n",
 "toZ_iterate_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n#print toZ_iterate_succ /-\ntheorem toZ_iterate_succ [NoMaxOrder ι] (n : ℕ) : toZ i0 ((«expr ^[ ]» succ n) i0) = n :=\n  toZ_iterate_succ_of_not_isMax n (not_isMax _)\n#align to_Z_iterate_succ toZ_iterate_succ\n-/\n\n",
 "toZ_iterate_pred_of_not_isMin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n#print toZ_iterate_pred_of_not_isMin /-\ntheorem toZ_iterate_pred_of_not_isMin (n : ℕ) (hn : ¬IsMin ((«expr ^[ ]» pred n) i0)) :\n    toZ i0 ((«expr ^[ ]» pred n) i0) = -n := by\n  cases n\n  · simp only [Function.iterate_zero, id.def, toZ_of_eq, Nat.cast_zero, neg_zero]\n  have : («expr ^[ ]» pred n.succ) i0 < i0 :=\n    by\n    refine' lt_of_le_of_ne (pred_iterate_le _ _) fun h_pred_iterate_eq => hn _\n    have h_pred_eq_pred : («expr ^[ ]» pred n.succ) i0 = («expr ^[ ]» pred 0) i0 := by\n      rwa [Function.iterate_zero, id.def]\n    exact is_min_iterate_pred_of_eq_of_ne h_pred_eq_pred (nat.succ_ne_zero n)\n  let m := (-toZ i0 ((«expr ^[ ]» pred n.succ) i0)).to_nat\n  have h_eq : («expr ^[ ]» pred m) i0 = («expr ^[ ]» pred n.succ) i0 := iterate_pred_toZ _ this\n  by_cases hmn : m = n.succ\n  · nth_rw 2 [← hmn]\n    simp_rw [m]\n    rw [Int.toNat_eq_max, toZ_of_lt this, max_eq_left, neg_neg]\n    rw [neg_neg]\n    exact Nat.cast_nonneg _\n  · suffices : IsMin ((«expr ^[ ]» pred n.succ) i0)\n    exact absurd this hn\n    exact is_min_iterate_pred_of_eq_of_ne h_eq.symm (ne.symm hmn)\n#align to_Z_iterate_pred_of_not_is_min toZ_iterate_pred_of_not_isMin\n-/\n\n",
 "toZ_iterate_pred_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n#print toZ_iterate_pred_ge /-\ntheorem toZ_iterate_pred_ge (n : ℕ) : -(n : ℤ) ≤ toZ i0 ((«expr ^[ ]» pred n) i0) :=\n  by\n  cases' le_or_lt i0 ((«expr ^[ ]» pred n) i0) with h h\n  · have h_eq : («expr ^[ ]» pred n) i0 = i0 := le_antisymm (pred_iterate_le _ _) h\n    rw [h_eq, toZ_of_eq]\n    simp only [Right.neg_nonpos_iff, Nat.cast_nonneg]\n  · rw [toZ_of_lt h, neg_le_neg_iff]\n    norm_cast\n    exact nat.find_min' (exists_pred_iterate_of_le _) rfl\n#align to_Z_iterate_pred_ge toZ_iterate_pred_ge\n-/\n\n",
 "toZ_iterate_pred":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n#print toZ_iterate_pred /-\ntheorem toZ_iterate_pred [NoMinOrder ι] (n : ℕ) : toZ i0 ((«expr ^[ ]» pred n) i0) = -n :=\n  toZ_iterate_pred_of_not_isMin n (not_isMin _)\n#align to_Z_iterate_pred toZ_iterate_pred\n-/\n\n",
 "succ_fn_spec":
 "/-\nCopyright (c) 2022 Rémy Degenne. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Rémy Degenne\n-/\ntheorem succ_fn_spec (i : ι) : IsGLB (Set.Ioi i) (succFn i) :=\n  (exists_glb_Ioi i).some_spec\n#align succ_fn_spec succ_fn_spec\n\n",
 "succ_fn_le_of_lt":
 "theorem succ_fn_le_of_lt (i j : ι) (hij : i < j) : succFn i ≤ j :=\n  by\n  have h := succ_fn_spec i\n  rw [IsGLB, IsGreatest, mem_lowerBounds] at h\n  exact h.1 j hij\n#align succ_fn_le_of_lt succ_fn_le_of_lt\n\n",
 "le_succ_fn":
 "theorem le_succ_fn (i : ι) : i ≤ succFn i :=\n  by\n  rw [le_isGLB_iff (succ_fn_spec i), mem_lowerBounds]\n  exact fun x hx => le_of_lt hx\n#align le_succ_fn le_succ_fn\n\n",
 "le_of_toZ_le":
 "#print le_of_toZ_le /-\ntheorem le_of_toZ_le {j : ι} (h_le : toZ i0 i ≤ toZ i0 j) : i ≤ j :=\n  by\n  cases' le_or_lt i0 i with hi hi <;> cases' le_or_lt i0 j with hj hj\n  · rw [← iterate_succ_toZ i hi, ← iterate_succ_toZ j hj]\n    exact Monotone.monotone_iterate_of_le_map succ_mono (le_succ _) (Int.toNat_le_toNat h_le)\n  · exact absurd ((toZ_neg hj).trans_le (toZ_nonneg hi)) (not_lt.mpr h_le)\n  · exact hi.le.trans hj\n  · rw [← iterate_pred_toZ i hi, ← iterate_pred_toZ j hj]\n    refine' Monotone.antitone_iterate_of_map_le pred_mono (pred_le _) (Int.toNat_le_toNat _)\n    exact neg_le_neg h_le\n#align le_of_to_Z_le le_of_toZ_le\n-/\n\n",
 "le_of_lt_succ_fn":
 "theorem le_of_lt_succ_fn (j i : ι) (hij : j < succFn i) : j ≤ i :=\n  by\n  rw [lt_isGLB_iff (succ_fn_spec i)] at hij\n  obtain ⟨k, hk_lb, hk⟩ := hij\n  rw [mem_lowerBounds] at hk_lb\n  exact not_lt.mp fun hi_lt_j => not_le.mpr hk (hk_lb j hi_lt_j)\n#align le_of_lt_succ_fn le_of_lt_succ_fn\n\n",
 "iterate_succ_toZ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n#print iterate_succ_toZ /-\ntheorem iterate_succ_toZ (i : ι) (hi : i0 ≤ i) : («expr ^[ ]» succ (toZ i0 i).to_nat) i0 = i :=\n  by\n  rw [toZ_of_ge hi, Int.toNat_coe_nat]\n  exact nat.find_spec (exists_succ_iterate_of_le hi)\n#align iterate_succ_to_Z iterate_succ_toZ\n-/\n\n",
 "iterate_pred_toZ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n#print iterate_pred_toZ /-\ntheorem iterate_pred_toZ (i : ι) (hi : i < i0) : («expr ^[ ]» pred (-toZ i0 i).to_nat) i0 = i :=\n  by\n  rw [toZ_of_lt hi, neg_neg, Int.toNat_coe_nat]\n  exact nat.find_spec (exists_pred_iterate_of_le hi.le)\n#align iterate_pred_to_Z iterate_pred_toZ\n-/\n\n",
 "is_max_of_succ_fn_le":
 "theorem is_max_of_succ_fn_le [LocallyFiniteOrder ι] (i : ι) (hi : succFn i ≤ i) : IsMax i :=\n  by\n  refine' fun j hij => not_lt.mp fun hij_lt => _\n  have h_succ_fn_eq : succ_fn i = i := le_antisymm hi (le_succ_fn i)\n  have h_glb : IsGLB (Finset.Ioc i j : Set ι) i := by\n    rw [Finset.coe_Ioc]\n    have h := succ_fn_spec i\n    rw [h_succ_fn_eq] at h\n    exact is_glb_Ioc_of_is_glb_Ioi hij_lt h\n  have hi_mem : i ∈ Finset.Ioc i j := by\n    refine' Finset.is_glb_mem _ h_glb _\n    exact ⟨_, finset.mem_Ioc.mpr ⟨hij_lt, le_rfl⟩⟩\n  rw [Finset.mem_Ioc] at hi_mem\n  exact lt_irrefl i hi_mem.1\n#align is_max_of_succ_fn_le is_max_of_succ_fn_le\n\n",
 "is_glb_Ioc_of_is_glb_Ioi":
 "theorem is_glb_Ioc_of_is_glb_Ioi {i j k : ι} (hij_lt : i < j) (h : IsGLB (Set.Ioi i) k) : IsGLB (Set.Ioc i j) k :=\n  by\n  simp_rw [IsGLB, IsGreatest, mem_upperBounds, mem_lowerBounds] at h⊢\n  refine' ⟨fun x hx => h.1 x hx.1, fun x hx => h.2 x _⟩\n  intro y hy\n  cases' le_or_lt y j with h_le h_lt\n  · exact hx y ⟨hy, h_le⟩\n  · exact le_trans (hx j ⟨hij_lt, le_rfl⟩) h_lt.le\n#align is_glb_Ioc_of_is_glb_Ioi is_glb_Ioc_of_is_glb_Ioi\n\n",
 "injective_toZ":
 "#print injective_toZ /-\ntheorem injective_toZ : function.injective (toZ i0) := fun i j hij =>\n  le_antisymm (le_of_toZ_le hij.le) (le_of_toZ_le hij.symm.le)\n#align injective_to_Z injective_toZ\n-/\n\n"}