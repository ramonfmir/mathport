{"transGen_of_succ_of_reflexive":
 "#print transGen_of_succ_of_reflexive /-\n/-- `(n, m)` is in the transitive closure of a reflexive relation `~` if `i ~ succ i` and\n  `succ i ~ i` for all `i` between `n` and `m`. -/\ntheorem transGen_of_succ_of_reflexive (r : α → α → Prop) {n m : α} (hr : reflexive r) (h1 : ∀ i ∈ Ico n m, r i (succ i))\n    (h2 : ∀ i ∈ Ico m n, r (succ i) i) : TransGen r n m :=\n  by\n  rcases eq_or_ne m n with (rfl | hmn); · exact trans_gen.single (hr m)\n  exact transGen_of_succ_of_ne r h1 h2 hmn.symm\n#align trans_gen_of_succ_of_reflexive transGen_of_succ_of_reflexive\n-/\n\n",
 "transGen_of_succ_of_ne":
 "#print transGen_of_succ_of_ne /-\n/-- For `n ≠ m`,`(n, m)` is in the transitive closure of a relation `~` if `i ~ succ i` and\n  `succ i ~ i` for all `i` between `n` and `m`. -/\ntheorem transGen_of_succ_of_ne (r : α → α → Prop) {n m : α} (h1 : ∀ i ∈ Ico n m, r i (succ i))\n    (h2 : ∀ i ∈ Ico m n, r (succ i) i) (hnm : n ≠ m) : TransGen r n m :=\n  (reflTransGen_iff_eq_or_transGen.mp (reflTransGen_of_succ r h1 h2)).resolve_left hnm.symm\n#align trans_gen_of_succ_of_ne transGen_of_succ_of_ne\n-/\n\n",
 "transGen_of_succ_of_lt":
 "#print transGen_of_succ_of_lt /-\n/-- For `n < m`, `(n, m)` is in the transitive closure of a relation `~` if `i ~ succ i`\n  for all `i` between `n` and `m`. -/\ntheorem transGen_of_succ_of_lt (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ico n m, r i (succ i)) (hnm : n < m) :\n    TransGen r n m :=\n  (reflTransGen_iff_eq_or_transGen.mp <| reflTransGen_of_succ_of_le r h hnm.le).resolve_left hnm.ne'\n#align trans_gen_of_succ_of_lt transGen_of_succ_of_lt\n-/\n\n",
 "transGen_of_succ_of_gt":
 "#print transGen_of_succ_of_gt /-\n/-- For `m < n`, `(n, m)` is in the transitive closure of a relation `~` if `succ i ~ i`\n  for all `i` between `n` and `m`. -/\ntheorem transGen_of_succ_of_gt (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ico m n, r (succ i) i) (hmn : m < n) :\n    TransGen r n m :=\n  (reflTransGen_iff_eq_or_transGen.mp <| reflTransGen_of_succ_of_ge r h hmn.le).resolve_left hmn.ne\n#align trans_gen_of_succ_of_gt transGen_of_succ_of_gt\n-/\n\n",
 "transGen_of_pred_of_reflexive":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print transGen_of_pred_of_reflexive /-\n/-- `(n, m)` is in the transitive closure of a reflexive relation `~` if `i ~ pred i` and\n  `pred i ~ i` for all `i` between `n` and `m`. -/\ntheorem transGen_of_pred_of_reflexive (r : α → α → Prop) {n m : α} (hr : reflexive r) (h1 : ∀ i ∈ Ioc m n, r i (pred i))\n    (h2 : ∀ i ∈ Ioc n m, r (pred i) i) : TransGen r n m :=\n  @transGen_of_succ_of_reflexive («expr ᵒᵈ» α) _ _ _ r n m hr (fun x hx => h1 x ⟨hx.2, hx.1⟩) fun x hx =>\n    h2 x ⟨hx.2, hx.1⟩\n#align trans_gen_of_pred_of_reflexive transGen_of_pred_of_reflexive\n-/\n\n",
 "transGen_of_pred_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print transGen_of_pred_of_ne /-\n/-- For `n ≠ m`, `(n, m)` is in the transitive closure of a relation `~` if `i ~ pred i` and\n  `pred i ~ i` for all `i` between `n` and `m`. -/\ntheorem transGen_of_pred_of_ne (r : α → α → Prop) {n m : α} (h1 : ∀ i ∈ Ioc m n, r i (pred i))\n    (h2 : ∀ i ∈ Ioc n m, r (pred i) i) (hnm : n ≠ m) : TransGen r n m :=\n  @transGen_of_succ_of_ne («expr ᵒᵈ» α) _ _ _ r n m (fun x hx => h1 x ⟨hx.2, hx.1⟩) (fun x hx => h2 x ⟨hx.2, hx.1⟩) hnm\n#align trans_gen_of_pred_of_ne transGen_of_pred_of_ne\n-/\n\n",
 "transGen_of_pred_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print transGen_of_pred_of_lt /-\n/-- For `n < m`, `(n, m)` is in the transitive closure of a relation `~` for `n ≠ m` if `pred i ~ i`\n  for all `i` between `n` and `m`. -/\ntheorem transGen_of_pred_of_lt (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ioc n m, r (pred i) i) (hmn : n < m) :\n    TransGen r n m :=\n  @transGen_of_succ_of_gt («expr ᵒᵈ» α) _ _ _ r _ _ (fun x hx => h x ⟨hx.2, hx.1⟩) hmn\n#align trans_gen_of_pred_of_lt transGen_of_pred_of_lt\n-/\n\n",
 "transGen_of_pred_of_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print transGen_of_pred_of_gt /-\n/-- For `m < n`, `(n, m)` is in the transitive closure of a relation `~` for `n ≠ m` if `i ~ pred i`\n  for all `i` between `n` and `m`. -/\ntheorem transGen_of_pred_of_gt (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ioc m n, r i (pred i)) (hnm : m < n) :\n    TransGen r n m :=\n  @transGen_of_succ_of_lt («expr ᵒᵈ» α) _ _ _ r _ _ (fun x hx => h x ⟨hx.2, hx.1⟩) hnm\n#align trans_gen_of_pred_of_gt transGen_of_pred_of_gt\n-/\n\n",
 "reflTransGen_of_succ_of_le":
 "#print reflTransGen_of_succ_of_le /-\n/-\nCopyright (c) 2022 Floris van Doorn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Floris van Doorn\n-/\n/-- For `n ≤ m`, `(n, m)` is in the reflexive-transitive closure of `~` if `i ~ succ i`\n  for all `i` between `n` and `m`. -/\ntheorem reflTransGen_of_succ_of_le (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ico n m, r i (succ i)) (hnm : n ≤ m) :\n    ReflTransGen r n m := by\n  revert h; refine' Succ.rec _ _ hnm\n  · intro h\n    exact refl_trans_gen.refl\n  · intro m hnm ih h\n    have : refl_trans_gen r n m := ih fun i hi => h i ⟨hi.1, hi.2.trans_le <| le_succ m⟩\n    cases' (le_succ m).eq_or_lt with hm hm\n    · rwa [← hm]\n    exact this.tail (h m ⟨hnm, hm⟩)\n#align refl_trans_gen_of_succ_of_le reflTransGen_of_succ_of_le\n-/\n\n",
 "reflTransGen_of_succ_of_ge":
 "#print reflTransGen_of_succ_of_ge /-\n/-- For `m ≤ n`, `(n, m)` is in the reflexive-transitive closure of `~` if `succ i ~ i`\n  for all `i` between `n` and `m`. -/\ntheorem reflTransGen_of_succ_of_ge (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ico m n, r (succ i) i) (hmn : m ≤ n) :\n    ReflTransGen r n m := by\n  rw [← refl_trans_gen_swap]\n  exact reflTransGen_of_succ_of_le (swap r) h hmn\n#align refl_trans_gen_of_succ_of_ge reflTransGen_of_succ_of_ge\n-/\n\n",
 "reflTransGen_of_succ":
 "#print reflTransGen_of_succ /-\n/-- `(n, m)` is in the reflexive-transitive closure of `~` if `i ~ succ i` and `succ i ~ i`\n  for all `i` between `n` and `m`. -/\ntheorem reflTransGen_of_succ (r : α → α → Prop) {n m : α} (h1 : ∀ i ∈ Ico n m, r i (succ i))\n    (h2 : ∀ i ∈ Ico m n, r (succ i) i) : ReflTransGen r n m :=\n  (le_total n m).elim (reflTransGen_of_succ_of_le r h1) <| reflTransGen_of_succ_of_ge r h2\n#align refl_trans_gen_of_succ reflTransGen_of_succ\n-/\n\n",
 "reflTransGen_of_pred_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print reflTransGen_of_pred_of_le /-\n/-- For `n ≤ m`, `(n, m)` is in the reflexive-transitive closure of `~` if `pred i ~ i`\n  for all `i` between `n` and `m`. -/\ntheorem reflTransGen_of_pred_of_le (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ioc n m, r (pred i) i) (hmn : n ≤ m) :\n    ReflTransGen r n m :=\n  @reflTransGen_of_succ_of_ge («expr ᵒᵈ» α) _ _ _ r n m (fun x hx => h x ⟨hx.2, hx.1⟩) hmn\n#align refl_trans_gen_of_pred_of_le reflTransGen_of_pred_of_le\n-/\n\n",
 "reflTransGen_of_pred_of_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print reflTransGen_of_pred_of_ge /-\n/-- For `m ≤ n`, `(n, m)` is in the reflexive-transitive closure of `~` if `i ~ pred i`\n  for all `i` between `n` and `m`. -/\ntheorem reflTransGen_of_pred_of_ge (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ioc m n, r i (pred i)) (hnm : m ≤ n) :\n    ReflTransGen r n m :=\n  @reflTransGen_of_succ_of_le («expr ᵒᵈ» α) _ _ _ r n m (fun x hx => h x ⟨hx.2, hx.1⟩) hnm\n#align refl_trans_gen_of_pred_of_ge reflTransGen_of_pred_of_ge\n-/\n\n",
 "reflTransGen_of_pred":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print reflTransGen_of_pred /-\n/-- `(n, m)` is in the reflexive-transitive closure of `~` if `i ~ pred i` and `pred i ~ i`\n  for all `i` between `n` and `m`. -/\ntheorem reflTransGen_of_pred (r : α → α → Prop) {n m : α} (h1 : ∀ i ∈ Ioc m n, r i (pred i))\n    (h2 : ∀ i ∈ Ioc n m, r (pred i) i) : ReflTransGen r n m :=\n  @reflTransGen_of_succ («expr ᵒᵈ» α) _ _ _ r n m (fun x hx => h1 x ⟨hx.2, hx.1⟩) fun x hx => h2 x ⟨hx.2, hx.1⟩\n#align refl_trans_gen_of_pred reflTransGen_of_pred\n-/\n\n"}