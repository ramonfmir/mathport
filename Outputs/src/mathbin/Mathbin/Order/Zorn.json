{"zorn_superset_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (c «expr ⊆ » S) -/\n#print zorn_superset_nonempty /-\ntheorem zorn_superset_nonempty (S : set (set α))\n    (H : ∀ (c) (_ : c ⊆ S), IsChain (· ⊆ ·) c → c.nonempty → ∃ lb ∈ S, ∀ s ∈ c, lb ⊆ s) (x) (hx : x ∈ S) :\n    ∃ m ∈ S, m ⊆ x ∧ ∀ a ∈ S, a ⊆ m → a = m :=\n  @zorn_nonempty_partialOrder₀ («expr ᵒᵈ» (set α)) _ S (fun c cS hc y yc => H _ cS hc.symm ⟨y, yc⟩) _ hx\n#align zorn_superset_nonempty zorn_superset_nonempty\n-/\n\n",
 "zorn_superset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (c «expr ⊆ » S) -/\n#print zorn_superset /-\ntheorem zorn_superset (S : set (set α)) (h : ∀ (c) (_ : c ⊆ S), IsChain (· ⊆ ·) c → ∃ lb ∈ S, ∀ s ∈ c, lb ⊆ s) :\n    ∃ m ∈ S, ∀ a ∈ S, a ⊆ m → a = m :=\n  @zorn_partialOrder₀ («expr ᵒᵈ» (set α)) _ S fun c cS hc => h c cS hc.symm\n#align zorn_superset zorn_superset\n-/\n\n",
 "zorn_subset_nonempty":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (c «expr ⊆ » S) -/\n#print zorn_subset_nonempty /-\ntheorem zorn_subset_nonempty (S : set (set α))\n    (H : ∀ (c) (_ : c ⊆ S), IsChain (· ⊆ ·) c → c.nonempty → ∃ ub ∈ S, ∀ s ∈ c, s ⊆ ub) (x) (hx : x ∈ S) :\n    ∃ m ∈ S, x ⊆ m ∧ ∀ a ∈ S, m ⊆ a → a = m :=\n  zorn_nonempty_partialOrder₀ _ (fun c cS hc y yc => H _ cS hc ⟨y, yc⟩) _ hx\n#align zorn_subset_nonempty zorn_subset_nonempty\n-/\n\n",
 "zorn_subset":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (c «expr ⊆ » S) -/\n#print zorn_subset /-\ntheorem zorn_subset (S : set (set α)) (h : ∀ (c) (_ : c ⊆ S), IsChain (· ⊆ ·) c → ∃ ub ∈ S, ∀ s ∈ c, s ⊆ ub) :\n    ∃ m ∈ S, ∀ a ∈ S, m ⊆ a → a = m :=\n  zorn_partialOrder₀ S h\n#align zorn_subset zorn_subset\n-/\n\n",
 "zorn_preorder₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (c «expr ⊆ » s) -/\n#print zorn_preorder₀ /-\ntheorem zorn_preorder₀ (s : set α) (ih : ∀ (c) (_ : c ⊆ s), IsChain (· ≤ ·) c → ∃ ub ∈ s, ∀ z ∈ c, z ≤ ub) :\n    ∃ m ∈ s, ∀ z ∈ s, m ≤ z → z ≤ m :=\n  let ⟨⟨m, hms⟩, h⟩ :=\n    @zorn_preorder s _ fun c hc =>\n      let ⟨ub, hubs, hub⟩ :=\n        ih («expr '' » subtype.val c) (fun _ ⟨⟨x, hx⟩, _, h⟩ => h ▸ hx)\n          (by rintro _ ⟨p, hpc, rfl⟩ _ ⟨q, hqc, rfl⟩ hpq <;> refine' hc hpc hqc fun t => hpq (subtype.ext_iff.1 t))\n      ⟨⟨ub, hubs⟩, fun ⟨y, hy⟩ hc => hub _ ⟨_, hc, rfl⟩⟩\n  ⟨m, hms, fun z hzs hmz => h ⟨z, hzs⟩ hmz⟩\n#align zorn_preorder₀ zorn_preorder₀\n-/\n\n",
 "zorn_preorder":
 "#print zorn_preorder /-\ntheorem zorn_preorder (h : ∀ c : set α, IsChain (· ≤ ·) c → BddAbove c) : ∃ m : α, ∀ a, m ≤ a → a ≤ m :=\n  exists_maximal_of_chains_bounded h fun a b c => le_trans\n#align zorn_preorder zorn_preorder\n-/\n\n",
 "zorn_partialOrder₀":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (c «expr ⊆ » s) -/\n#print zorn_partialOrder₀ /-\ntheorem zorn_partialOrder₀ (s : set α) (ih : ∀ (c) (_ : c ⊆ s), IsChain (· ≤ ·) c → ∃ ub ∈ s, ∀ z ∈ c, z ≤ ub) :\n    ∃ m ∈ s, ∀ z ∈ s, m ≤ z → z = m :=\n  let ⟨m, hms, hm⟩ := zorn_preorder₀ s ih\n  ⟨m, hms, fun z hzs hmz => (hm z hzs hmz).antisymm hmz⟩\n#align zorn_partial_order₀ zorn_partialOrder₀\n-/\n\n",
 "zorn_partialOrder":
 "#print zorn_partialOrder /-\ntheorem zorn_partialOrder (h : ∀ c : set α, IsChain (· ≤ ·) c → BddAbove c) : ∃ m : α, ∀ a, m ≤ a → a = m :=\n  let ⟨m, hm⟩ := zorn_preorder h\n  ⟨m, fun a ha => le_antisymm (hm a ha) ha⟩\n#align zorn_partial_order zorn_partialOrder\n-/\n\n",
 "zorn_nonempty_preorder₀":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (c «expr ⊆ » s) -/\n#print zorn_nonempty_preorder₀ /-\ntheorem zorn_nonempty_preorder₀ (s : set α)\n    (ih : ∀ (c) (_ : c ⊆ s), IsChain (· ≤ ·) c → ∀ y ∈ c, ∃ ub ∈ s, ∀ z ∈ c, z ≤ ub) (x : α) (hxs : x ∈ s) :\n    ∃ m ∈ s, x ≤ m ∧ ∀ z ∈ s, m ≤ z → z ≤ m :=\n  by\n  rcases zorn_preorder₀ ({ y ∈ s | x ≤ y }) fun c hcs hc => _ with ⟨m, ⟨hms, hxm⟩, hm⟩\n  · exact ⟨m, hms, hxm, fun z hzs hmz => hm _ ⟨hzs, hxm.trans hmz⟩ hmz⟩\n  · rcases c.eq_empty_or_nonempty with (rfl | ⟨y, hy⟩)\n    · exact ⟨x, ⟨hxs, le_rfl⟩, fun z => false.elim⟩\n    · rcases ih c (fun z hz => (hcs hz).1) hc y hy with ⟨z, hzs, hz⟩\n      exact ⟨z, ⟨hzs, (hcs hy).2.trans <| hz _ hy⟩, hz⟩\n#align zorn_nonempty_preorder₀ zorn_nonempty_preorder₀\n-/\n\n",
 "zorn_nonempty_preorder":
 "#print zorn_nonempty_preorder /-\ntheorem zorn_nonempty_preorder [nonempty α] (h : ∀ c : set α, IsChain (· ≤ ·) c → c.nonempty → BddAbove c) :\n    ∃ m : α, ∀ a, m ≤ a → a ≤ m :=\n  exists_maximal_of_nonempty_chains_bounded h fun a b c => le_trans\n#align zorn_nonempty_preorder zorn_nonempty_preorder\n-/\n\n",
 "zorn_nonempty_partialOrder₀":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (c «expr ⊆ » s) -/\n#print zorn_nonempty_partialOrder₀ /-\ntheorem zorn_nonempty_partialOrder₀ (s : set α)\n    (ih : ∀ (c) (_ : c ⊆ s), IsChain (· ≤ ·) c → ∀ y ∈ c, ∃ ub ∈ s, ∀ z ∈ c, z ≤ ub) (x : α) (hxs : x ∈ s) :\n    ∃ m ∈ s, x ≤ m ∧ ∀ z ∈ s, m ≤ z → z = m :=\n  let ⟨m, hms, hxm, hm⟩ := zorn_nonempty_preorder₀ s ih x hxs\n  ⟨m, hms, hxm, fun z hzs hmz => (hm z hzs hmz).antisymm hmz⟩\n#align zorn_nonempty_partial_order₀ zorn_nonempty_partialOrder₀\n-/\n\n",
 "zorn_nonempty_partialOrder":
 "#print zorn_nonempty_partialOrder /-\ntheorem zorn_nonempty_partialOrder [nonempty α] (h : ∀ c : set α, IsChain (· ≤ ·) c → c.nonempty → BddAbove c) :\n    ∃ m : α, ∀ a, m ≤ a → a = m :=\n  let ⟨m, hm⟩ := zorn_nonempty_preorder h\n  ⟨m, fun a ha => le_antisymm (hm a ha) ha⟩\n#align zorn_nonempty_partial_order zorn_nonempty_partialOrder\n-/\n\n",
 "zorn_nonempty_Ici₀":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (c «expr ⊆ » Ici[set.Ici] a) -/\n#print zorn_nonempty_Ici₀ /-\ntheorem zorn_nonempty_Ici₀ (a : α)\n    (ih : ∀ (c) (_ : c ⊆ Ici a), IsChain (· ≤ ·) c → ∀ y ∈ c, ∃ ub, a ≤ ub ∧ ∀ z ∈ c, z ≤ ub) (x : α) (hax : a ≤ x) :\n    ∃ m, x ≤ m ∧ ∀ z, m ≤ z → z ≤ m :=\n  let ⟨m, hma, hxm, hm⟩ := zorn_nonempty_preorder₀ (Ici a) (by simpa using ih) x hax\n  ⟨m, hxm, fun z hmz => hm _ (hax.trans <| hxm.trans hmz) hmz⟩\n#align zorn_nonempty_Ici₀ zorn_nonempty_Ici₀\n-/\n\n",
 "exists_maximal_of_nonempty_chains_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n#print exists_maximal_of_nonempty_chains_bounded /-\n/-- A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then\nthere is a maximal element.\n-/\ntheorem exists_maximal_of_nonempty_chains_bounded [nonempty α]\n    (h : ∀ c, IsChain r c → c.nonempty → ∃ ub, ∀ a ∈ c, «expr ≺ » a ub)\n    (trans : ∀ {a b c}, «expr ≺ » a b → «expr ≺ » b c → «expr ≺ » a c) : ∃ m, ∀ a, «expr ≺ » m a → «expr ≺ » a m :=\n  exists_maximal_of_chains_bounded\n    (fun c hc =>\n      (eq_empty_or_nonempty c).elim (fun h => ⟨classical.arbitrary α, fun x hx => (h ▸ hx : x ∈ (∅ : set α)).elim⟩)\n        (h c hc))\n    fun a b c => trans\n#align exists_maximal_of_nonempty_chains_bounded exists_maximal_of_nonempty_chains_bounded\n-/\n\n",
 "exists_maximal_of_chains_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≺ » -/\n#print exists_maximal_of_chains_bounded /-\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl\n-/\n/-- **Zorn's lemma**\n\nIf every chain has an upper bound, then there exists a maximal element. -/\ntheorem exists_maximal_of_chains_bounded (h : ∀ c, IsChain r c → ∃ ub, ∀ a ∈ c, «expr ≺ » a ub)\n    (trans : ∀ {a b c}, «expr ≺ » a b → «expr ≺ » b c → «expr ≺ » a c) : ∃ m, ∀ a, «expr ≺ » m a → «expr ≺ » a m :=\n  have : ∃ ub, ∀ a ∈ maxChain r, «expr ≺ » a ub := h _ <| maxChain_spec.left\n  let ⟨ub, (hub : ∀ a ∈ maxChain r, «expr ≺ » a ub)⟩ := this\n  ⟨ub, fun a ha =>\n    have : IsChain r (insert a <| maxChain r) := maxChain_spec.1.insert fun b hb _ => or.inr <| trans (hub b hb) ha\n    hub a <| by\n      rw [max_chain_spec.right this (subset_insert _ _)]\n      exact mem_insert _ _⟩\n#align exists_maximal_of_chains_bounded exists_maximal_of_chains_bounded\n-/\n\n",
 "exists_maxChain":
 "#print IsChain.exists_maxChain /-\n/-- Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.\n-/\ntheorem IsChain.exists_maxChain (hc : IsChain r c) : ∃ M, @IsMaxChain _ r M ∧ c ⊆ M :=\n  by\n  obtain ⟨M, ⟨_, hM₀⟩, hM₁, hM₂⟩ := zorn_subset_nonempty { s | c ⊆ s ∧ IsChain r s } _ c ⟨subset.rfl, hc⟩\n  · exact ⟨M, ⟨hM₀, fun d hd hMd => (hM₂ _ ⟨hM₁.trans hMd, hd⟩ hMd).symm⟩, hM₁⟩\n  rintro cs hcs₀ hcs₁ ⟨s, hs⟩\n  refine' ⟨⋃₀ cs, ⟨fun _ ha => Set.mem_unionₛ_of_mem ((hcs₀ hs).left ha) hs, _⟩, fun _ => Set.subset_unionₛ_of_mem⟩\n  rintro y ⟨sy, hsy, hysy⟩ z ⟨sz, hsz, hzsz⟩ hyz\n  obtain rfl | hsseq := eq_or_ne sy sz\n  · exact (hcs₀ hsy).right hysy hzsz hyz\n  cases' hcs₁ hsy hsz hsseq with h h\n  · exact (hcs₀ hsz).right (h hysy) hzsz hyz\n  · exact (hcs₀ hsy).right hysy (h hzsz) hyz\n#align is_chain.exists_max_chain IsChain.exists_maxChain\n-/\n\n"}