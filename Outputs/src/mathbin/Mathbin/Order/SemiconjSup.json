{"unique":
 "protected theorem unique [partial_order α] [preorder β] {f : α → β} {g₁ g₂ : β → α} (h₁ : IsOrderRightAdjoint f g₁)\n    (h₂ : IsOrderRightAdjoint f g₂) : g₁ = g₂ :=\n  funext fun y => (h₁ y).unique (h₂ y)\n#align unique unique\n\n",
 "symm_adjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n/-- If an order automorphism `fa` is semiconjugate to an order embedding `fb` by a function `g`\nand `g'` is an order right adjoint of `g` (i.e. `g' y = Sup {x | f x ≤ y}`), then `fb` is\nsemiconjugate to `fa` by `g'`.\n\nThis is a version of Proposition 2.1 from [Étienne Ghys, Groupes d'homeomorphismes du cercle et\ncohomologie bornee][ghys87:groupes]. -/\ntheorem semiconj.symm_adjoint [partial_order α] [preorder β] {fa : «expr ≃o » α α} {fb : «expr ↪o » β β} {g : α → β}\n    (h : function.semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') : function.semiconj g' fb fa :=\n  by\n  refine' fun y => (hg' _).unique _\n  rw [← fa.surjective.image_preimage { x | g x ≤ fb y }, preimage_set_of_eq]\n  simp only [h.eq, fb.le_iff_le, fa.left_ord_continuous (hg' _)]\n#align semiconj.symm_adjoint semiconj.symm_adjoint\n\n",
 "semiconj_of_is_lub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\ntheorem semiconj_of_is_lub [partial_order α] [group G] (f₁ f₂ : «expr →* » G («expr ≃o » α α)) {h : α → α}\n    (H : ∀ x, IsLUB (range fun g' => (f₁ g')⁻¹ (f₂ g' x)) (h x)) (g : G) : function.semiconj h (f₂ g) (f₁ g) :=\n  by\n  refine' fun y => (H _).unique _\n  have := (f₁ g).left_ord_continuous (H y)\n  rw [← range_comp, ← (Equiv.mulRight g).surjective.range_comp _] at this\n  simpa [(· ∘ ·)] using this\n#align semiconj_of_is_lub semiconj_of_is_lub\n\n",
 "right_mono":
 "theorem right_mono [preorder α] [preorder β] {f : α → β} {g : β → α} (h : IsOrderRightAdjoint f g) : monotone g :=\n  fun y₁ y₂ hy => (h y₁).mono (h y₂) fun x hx => le_trans hx hy\n#align right_mono right_mono\n\n",
 "order_iso_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\ntheorem order_iso_comp [preorder α] [preorder β] [preorder γ] {f : α → β} {g : β → α} (h : IsOrderRightAdjoint f g)\n    (e : «expr ≃o » β γ) : IsOrderRightAdjoint (e ∘ f) (g ∘ e.symm) := fun y => by\n  simpa [e.le_symm_apply] using h (e.symm y)\n#align order_iso_comp order_iso_comp\n\n",
 "isOrderRightAdjoint_supₛ":
 "#print isOrderRightAdjoint_supₛ /-\n/-\nCopyright (c) 2020 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov\n-/\ntheorem isOrderRightAdjoint_supₛ [CompleteLattice α] [preorder β] (f : α → β) :\n    IsOrderRightAdjoint f fun y => supₛ { x | f x ≤ y } := fun y => isLUB_supₛ _\n#align is_order_right_adjoint_Sup isOrderRightAdjoint_supₛ\n-/\n\n",
 "isOrderRightAdjoint_csupₛ":
 "#print isOrderRightAdjoint_csupₛ /-\ntheorem isOrderRightAdjoint_csupₛ [ConditionallyCompleteLattice α] [preorder β] (f : α → β) (hne : ∀ y, ∃ x, f x ≤ y)\n    (hbdd : ∀ y, BddAbove { x | f x ≤ y }) : IsOrderRightAdjoint f fun y => supₛ { x | f x ≤ y } := fun y =>\n  isLUB_csupₛ (hne y) (hbdd y)\n#align is_order_right_adjoint_cSup isOrderRightAdjoint_csupₛ\n-/\n\n",
 "comp_order_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\ntheorem comp_order_iso [preorder α] [preorder β] [preorder γ] {f : α → β} {g : β → α} (h : IsOrderRightAdjoint f g)\n    (e : «expr ≃o » γ α) : IsOrderRightAdjoint (f ∘ e) (e.symm ∘ g) :=\n  by\n  intro y\n  change IsLUB («expr ⁻¹' » e { x | f x ≤ y }) (e.symm (g y))\n  rw [e.is_lub_preimage, e.apply_symm_apply]\n  exact h y\n#align comp_order_iso comp_order_iso\n\n",
 "cSup_div_semiconj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- Consider two actions `f₁ f₂ : G → α → α` of a group on a conditionally complete lattice by order\nisomorphisms. Suppose that each set $s(x)=\\{f_1(g)^{-1} (f_2(g)(x)) | g \\in G\\}$ is bounded above.\nThen the map `x ↦ Sup s(x)` semiconjugates each `f₁ g'` to `f₂ g'`.\n\nThis is a version of Proposition 5.4 from [Étienne Ghys, Groupes d'homeomorphismes du cercle et\ncohomologie bornee][ghys87:groupes]. -/\ntheorem cSup_div_semiconj [ConditionallyCompleteLattice α] [group G] (f₁ f₂ : «expr →* » G («expr ≃o » α α))\n    (hbdd : ∀ x, BddAbove (range fun g => (f₁ g)⁻¹ (f₂ g x))) (g : G) :\n    function.semiconj\n      (fun x =>\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          ((f₁ g')⁻¹ (f₂ g' x)))\n      (f₂ g) (f₁ g) :=\n  semiconj_of_isLUB f₁ f₂ (fun x => isLUB_csupₛ (range_nonempty _) (hbdd x)) _\n#align cSup_div_semiconj cSup_div_semiconj\n\n",
 "Sup_div_semiconj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- Consider two actions `f₁ f₂ : G → α → α` of a group on a complete lattice by order\nisomorphisms. Then the map `x ↦ ⨆ g : G, (f₁ g)⁻¹ (f₂ g x)` semiconjugates each `f₁ g'` to `f₂ g'`.\n\nThis is a version of Proposition 5.4 from [Étienne Ghys, Groupes d'homeomorphismes du cercle et\ncohomologie bornee][ghys87:groupes]. -/\ntheorem Sup_div_semiconj [CompleteLattice α] [group G] (f₁ f₂ : «expr →* » G («expr ≃o » α α)) (g : G) :\n    function.semiconj\n      (fun x =>\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          ((f₁ g')⁻¹ (f₂ g' x)))\n      (f₂ g) (f₁ g) :=\n  semiconj_of_isLUB f₁ f₂ (fun x => isLUB_supᵢ) _\n#align Sup_div_semiconj Sup_div_semiconj\n\n"}