{"well_founded_lt_of_chain_height_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem well_founded_lt_of_chain_height_ne_top (s : Set α) (hs : s.chain_height ≠ «expr⊤») : WellFoundedLT s :=\n  wellFoundedGT_of_chainHeight_ne_top («expr ⁻¹' » ofDual s) <| by rwa [chain_height_dual]\n#align well_founded_lt_of_chain_height_ne_top well_founded_lt_of_chain_height_ne_top\n\n",
 "well_founded_gt_of_chain_height_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem well_founded_gt_of_chain_height_ne_top (s : Set α) (hs : s.chain_height ≠ «expr⊤») : WellFoundedGT s :=\n  by\n  obtain ⟨n, hn⟩ := WithTop.ne_top_iff_exists.1 hs\n  refine' ⟨RelEmbedding.wellFounded_iff_no_descending_seq.2 ⟨fun f => _⟩⟩\n  refine' n.lt_succ_self.not_le (WithTop.coe_le_coe.1 <| hn.symm ▸ _)\n  refine'\n    le_supᵢ₂_of_le _\n      ⟨chain'_map_of_chain' coe (fun _ _ => id) (chain'_iff_pairwise.2 <| pairwise_of_fn.2 fun i j => f.map_rel_iff.2),\n        fun i h => _⟩\n      _\n  · exact n.succ\n  · obtain ⟨a, ha, rfl⟩ := mem_map.1 h\n    exact a.prop\n  · rw [length_map, length_of_fn]\n    exact le_rfl\n#align well_founded_gt_of_chain_height_ne_top well_founded_gt_of_chain_height_ne_top\n\n",
 "one_le_chain_height_iff":
 "@[simp]\ntheorem one_le_chain_height_iff : 1 ≤ s.chain_height ↔ s.nonempty :=\n  by\n  change ((1 : ℕ) : ENat) ≤ _ ↔ _\n  rw [Set.le_chainHeight_iff]\n  constructor\n  · rintro ⟨_ | ⟨x, xs⟩, ⟨h₁, h₂⟩, h₃⟩\n    · cases h₃\n    · exact ⟨x, h₂ _ (or.inl rfl)⟩\n  · rintro ⟨x, hx⟩\n    exact ⟨[x], ⟨chain.nil, fun y h => (list.mem_singleton.mp h).symm ▸ hx⟩, rfl⟩\n#align one_le_chain_height_iff one_le_chain_height_iff\n\n",
 "nil_mem_subchain":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem nil_mem_subchain : [] ∈ s.subchain :=\n  ⟨trivial, fun x hx => hx.elim⟩\n#align nil_mem_subchain nil_mem_subchain\n\n",
 "length_le_chain_height_of_mem_subchain":
 "theorem length_le_chain_height_of_mem_subchain (hl : l ∈ s.subchain) : ↑l.length ≤ s.chain_height :=\n  le_chainHeight_iff.mpr ⟨l, hl, rfl⟩\n#align length_le_chain_height_of_mem_subchain length_le_chain_height_of_mem_subchain\n\n",
 "le_chain_height_tfae":
 "theorem le_chain_height_tfae (n : ℕ) :\n    TFAE [↑n ≤ s.chain_height, ∃ l ∈ s.subchain, length l = n, ∃ l ∈ s.subchain, n ≤ length l] :=\n  by\n  tfae_have 1 → 2; · exact s.exists_chain_of_le_chain_height\n  tfae_have 2 → 3;\n  · rintro ⟨l, hls, he⟩\n    exact ⟨l, hls, he.ge⟩\n  tfae_have 3 → 1;\n  · rintro ⟨l, hs, hn⟩\n    exact le_supᵢ₂_of_le l hs (WithTop.coe_le_coe.2 hn)\n  tfae_finish\n#align le_chain_height_tfae le_chain_height_tfae\n\n",
 "le_chain_height_iff":
 "theorem le_chain_height_iff {n : ℕ} : ↑n ≤ s.chain_height ↔ ∃ l ∈ s.subchain, length l = n :=\n  (le_chainHeight_TFAE s n).out 0 1\n#align le_chain_height_iff le_chain_height_iff\n\n",
 "le_chain_height_add_nat_iff":
 "theorem le_chain_height_add_nat_iff {n m : ℕ} : ↑n ≤ s.chain_height + m ↔ ∃ l ∈ s.subchain, n ≤ length l + m := by\n  simp_rw [← tsub_le_iff_right, ← WithTop.coe_sub, (le_chain_height_tfae s (n - m)).out 0 2]\n#align le_chain_height_add_nat_iff le_chain_height_add_nat_iff\n\n",
 "exists_chain_of_le_chain_height":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem exists_chain_of_le_chain_height {n : ℕ} (hn : ↑n ≤ s.chain_height) : ∃ l ∈ s.subchain, length l = n :=\n  by\n  cases' (le_top : s.chain_height ≤ «expr⊤»).eq_or_lt with ha ha <;> rw [chain_height_eq_supr_subtype] at ha\n  · obtain ⟨_, ⟨⟨l, h₁, h₂⟩, rfl⟩, h₃⟩ := not_bdd_above_iff'.mp ((WithTop.supr_coe_eq_top _).mp ha) n\n    exact\n      ⟨l.take n, ⟨h₁.take _, fun x h => h₂ _ <| take_subset _ _ h⟩,\n        (l.length_take n).trans <| min_eq_left <| le_of_not_ge h₃⟩\n  · rw [WithTop.supr_coe_lt_top] at ha\n    obtain ⟨⟨l, h₁, h₂⟩, e : l.length = _⟩ := Nat.supₛ_mem (Set.range_nonempty _) ha\n    refine' ⟨l.take n, ⟨h₁.take _, fun x h => h₂ _ <| take_subset _ _ h⟩, (l.length_take n).trans <| min_eq_left <| _⟩\n    rwa [e, ← WithTop.coe_le_coe, supₛ_range, WithTop.coe_supᵢ _ ha, ← chain_height_eq_supr_subtype]\n#align exists_chain_of_le_chain_height exists_chain_of_le_chain_height\n\n",
 "cons_mem_subchain_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem cons_mem_subchain_iff : sym.cons' a l ∈ s.subchain ↔ a ∈ s ∧ l ∈ s.subchain ∧ ∀ b ∈ l.head', a < b :=\n  by\n  refine'\n    ⟨fun h => ⟨h.2 _ (or.inl rfl), ⟨(chain'_cons'.mp h.1).2, fun i hi => h.2 _ (or.inr hi)⟩, (chain'_cons'.mp h.1).1⟩,\n      _⟩\n  rintro ⟨h₁, h₂, h₃⟩\n  constructor\n  · rw [chain'_cons']\n    exact ⟨h₃, h₂.1⟩\n  · rintro i (rfl | hi)\n    exacts[h₁, h₂.2 _ hi]\n#align cons_mem_subchain_iff cons_mem_subchain_iff\n\n",
 "chain_height_union_le":
 "theorem chain_height_union_le : (s ∪ t).chain_height ≤ s.chain_height + t.chain_height := by\n  classical\n    refine' supᵢ₂_le fun l hl => _\n    let l₁ := l.filter (· ∈ s)\n    let l₂ := l.filter (· ∈ t)\n    have hl₁ : ↑l₁.length ≤ s.chain_height :=\n      by\n      apply Set.length_le_chainHeight_of_mem_subchain\n      exact ⟨hl.1.sublist (filter_sublist _), fun i h => (of_mem_filter h : _)⟩\n    have hl₂ : ↑l₂.length ≤ t.chain_height :=\n      by\n      apply Set.length_le_chainHeight_of_mem_subchain\n      exact ⟨hl.1.sublist (filter_sublist _), fun i h => (of_mem_filter h : _)⟩\n    refine' le_trans _ (add_le_add hl₁ hl₂)\n    simp_rw [← WithTop.coe_add, WithTop.coe_le_coe, ← Multiset.coe_card, ← Multiset.card_add, ← Multiset.coe_filter]\n    rw [Multiset.filter_add_filter, multiset.filter_eq_self.mpr, Multiset.card_add]\n    exacts[le_add_right rfl.le, hl.2]\n#align chain_height_union_le chain_height_union_le\n\n",
 "chain_height_union_eq":
 "theorem chain_height_union_eq (s t : Set α) (H : ∀ a ∈ s, ∀ b ∈ t, a < b) :\n    (s ∪ t).chain_height = s.chain_height + t.chain_height :=\n  by\n  cases h : t.chain_height\n  · rw [WithTop.none_eq_top, add_top, eq_top_iff, ← WithTop.none_eq_top, ← h]\n    exact Set.chainHeight_mono (Set.subset_union_right _ _)\n  apply le_antisymm\n  · rw [← h]\n    exact chain_height_union_le\n  rw [WithTop.some_eq_coe, ← add_zero (s ∪ t).chain_height, ← WithTop.coe_zero, chain_height_add_le_chain_height_add]\n  intro l hl\n  obtain ⟨l', hl', rfl⟩ := exists_chain_of_le_chain_height t h.symm.le\n  refine' ⟨l ++ l', ⟨chain'.append hl.1 hl'.1 fun x hx y hy => _, fun i hi => _⟩, by simp⟩\n  · exact H x (hl.2 _ <| mem_of_mem_last' hx) y (hl'.2 _ <| mem_of_mem_head' hy)\n  · rw [mem_append] at hi\n    cases hi\n    exacts[or.inl (hl.2 _ hi), or.inr (hl'.2 _ hi)]\n#align chain_height_union_eq chain_height_union_eq\n\n",
 "chain_height_of_is_empty":
 "@[simp]\ntheorem chain_height_of_is_empty [IsEmpty α] : s.chain_height = 0 :=\n  chainHeight_eq_zero_iff.mpr (subsingleton.elim _ _)\n#align chain_height_of_is_empty chain_height_of_is_empty\n\n",
 "chain_height_mono":
 "theorem chain_height_mono (h : s ⊆ t) : s.chain_height ≤ t.chain_height :=\n  chainHeight_le_chainHeight_iff.2 fun l hl => ⟨l, ⟨hl.1, fun i hi => h <| hl.2 i hi⟩, rfl⟩\n#align chain_height_mono chain_height_mono\n\n",
 "chain_height_le_chain_height_tfae":
 "theorem chain_height_le_chain_height_tfae (s : Set α) (t : Set β) :\n    TFAE\n      [s.chain_height ≤ t.chain_height, ∀ l ∈ s.subchain, ∃ l' ∈ t.subchain, length l = length l',\n        ∀ l ∈ s.subchain, ∃ l' ∈ t.subchain, length l ≤ length l'] :=\n  by\n  tfae_have 1 ↔ 3; · convert← chain_height_add_le_chain_height_add s t 0 0 <;> apply add_zero\n  tfae_have 2 ↔ 3;\n  · refine' forall₂_congr fun l hl => _\n    simp_rw [← (le_chain_height_tfae t l.length).out 1 2, eq_comm]\n  tfae_finish\n#align chain_height_le_chain_height_tfae chain_height_le_chain_height_tfae\n\n",
 "chain_height_le_chain_height_iff_le":
 "theorem chain_height_le_chain_height_iff_le {t : Set β} :\n    s.chain_height ≤ t.chain_height ↔ ∀ l ∈ s.subchain, ∃ l' ∈ t.subchain, length l ≤ length l' :=\n  (chainHeight_le_chainHeight_TFAE s t).out 0 2\n#align chain_height_le_chain_height_iff_le chain_height_le_chain_height_iff_le\n\n",
 "chain_height_le_chain_height_iff":
 "theorem chain_height_le_chain_height_iff {t : Set β} :\n    s.chain_height ≤ t.chain_height ↔ ∀ l ∈ s.subchain, ∃ l' ∈ t.subchain, length l = length l' :=\n  (chainHeight_le_chainHeight_TFAE s t).out 0 1\n#align chain_height_le_chain_height_iff chain_height_le_chain_height_iff\n\n",
 "chain_height_insert_of_forall_lt":
 "theorem chain_height_insert_of_forall_lt (a : α) (ha : ∀ b ∈ s, b < a) :\n    (insert a s).chain_height = s.chain_height + 1 :=\n  by\n  rw [← chain_height_dual, ← chain_height_dual s]\n  exact chain_height_insert_of_forall_gt _ ha\n#align chain_height_insert_of_forall_lt chain_height_insert_of_forall_lt\n\n",
 "chain_height_insert_of_forall_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem chain_height_insert_of_forall_gt (a : α) (hx : ∀ b ∈ s, a < b) :\n    (insert a s).chain_height = s.chain_height + 1 :=\n  by\n  rw [← add_zero (insert a s).chain_height]\n  change (insert a s).chain_height + (0 : ℕ) = s.chain_height + (1 : ℕ)\n  apply le_antisymm <;> rw [chain_height_add_le_chain_height_add]\n  · rintro (_ | ⟨y, ys⟩) h\n    · exact ⟨[], nil_mem_subchain _, zero_le _⟩\n    · have h' := cons_mem_subchain_iff.mp h\n      refine' ⟨ys, ⟨h'.2.1.1, fun i hi => _⟩, by simp⟩\n      apply (h'.2.1.2 i hi).resolve_left\n      rintro rfl\n      cases' chain'_iff_pairwise.mp h.1 with _ _ hy\n      cases' h'.1 with h' h'\n      exacts[(hy _ hi).ne h', not_le_of_gt (hy _ hi) (hx _ h').le]\n  · intro l hl\n    refine' ⟨sym.cons' a l, ⟨_, _⟩, by simp⟩\n    · rw [chain'_cons']\n      exact ⟨fun y hy => hx _ (hl.2 _ (mem_of_mem_head' hy)), hl.1⟩\n    · rintro x (rfl | hx)\n      exacts[or.inl (Set.mem_singleton x), or.inr (hl.2 x hx)]\n#align chain_height_insert_of_forall_gt chain_height_insert_of_forall_gt\n\n",
 "chain_height_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem chain_height_image (f : α → β) (hf : ∀ {x y}, x < y ↔ f x < f y) (s : Set α) :\n    («expr '' » f s).chain_height = s.chain_height :=\n  by\n  apply le_antisymm <;> rw [chain_height_le_chain_height_iff]\n  · suffices ∀ l ∈ («expr '' » f s).subchain, ∃ l' ∈ s.subchain, map f l' = l\n      by\n      intro l hl\n      obtain ⟨l', h₁, rfl⟩ := this l hl\n      exact ⟨l', h₁, length_map _ _⟩\n    intro l\n    induction' l with x xs hx\n    · exact fun _ => ⟨nil, ⟨trivial, fun _ h => h.elim⟩, rfl⟩\n    · intro h\n      rw [cons_mem_subchain_iff] at h\n      obtain ⟨⟨x, hx', rfl⟩, h₁, h₂⟩ := h\n      obtain ⟨l', h₃, rfl⟩ := hx h₁\n      refine' ⟨sym.cons' x l', set.cons_mem_subchain_iff.mpr ⟨hx', h₃, _⟩, rfl⟩\n      cases l'\n      · simp\n      · simpa [← hf] using h₂\n  · intro l hl\n    refine' ⟨l.map f, ⟨_, _⟩, _⟩\n    · simp_rw [chain'_map, ← hf]\n      exact hl.1\n    · intro _ e\n      obtain ⟨a, ha, rfl⟩ := mem_map.mp e\n      exact Set.mem_image_of_mem _ (hl.2 _ ha)\n    · rw [length_map]\n#align chain_height_image chain_height_image\n\n",
 "chain_height_eq_zero_iff":
 "@[simp]\ntheorem chain_height_eq_zero_iff : s.chain_height = 0 ↔ s = ∅ := by\n  rw [← not_iff_not, ← ne.def, ← bot_eq_zero, ← bot_lt_iff_ne_bot, bot_eq_zero, ← ENat.one_le_iff_pos,\n    one_le_chain_height_iff, nonempty_iff_ne_empty]\n#align chain_height_eq_zero_iff chain_height_eq_zero_iff\n\n",
 "chain_height_eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem chain_height_eq_top_iff : s.chain_height = «expr⊤» ↔ ∀ n, ∃ l ∈ s.subchain, length l = n :=\n  by\n  refine' ⟨fun h n => le_chain_height_iff.1 (le_top.trans_eq h.symm), fun h => _⟩\n  contrapose! h; obtain ⟨n, hn⟩ := WithTop.ne_top_iff_exists.1 h\n  exact\n    ⟨n + 1, fun l hs =>\n      (Nat.lt_succ_iff.2 <| WithTop.coe_le_coe.1 <| (length_le_chain_height_of_mem_subchain hs).trans_eq hn.symm).ne⟩\n#align chain_height_eq_top_iff chain_height_eq_top_iff\n\n",
 "chain_height_eq_supr_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem chain_height_eq_supr_subtype :\n    s.chain_height =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" l.1.length :=\n  supᵢ_subtype'\n#align chain_height_eq_supr_subtype chain_height_eq_supr_subtype\n\n",
 "chain_height_eq_supr_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem chain_height_eq_supr_Iic :\n    s.chain_height =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (s ∩ Set.Iic i).chain_height :=\n  by\n  simp_rw [← chain_height_dual (_ ∩ _)]\n  rw [← chain_height_dual, chain_height_eq_supr_Ici]\n  rfl\n#align chain_height_eq_supr_Iic chain_height_eq_supr_Iic\n\n",
 "chain_height_eq_supr_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem chain_height_eq_supr_Ici :\n    s.chain_height =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (s ∩ Set.Ici i).chain_height :=\n  by\n  apply le_antisymm\n  · refine' supᵢ₂_le _\n    rintro (_ | ⟨x, xs⟩) h\n    · exact zero_le _\n    · apply le_trans _ (le_supᵢ₂ x (cons_mem_subchain_iff.mp h).1)\n      apply length_le_chain_height_of_mem_subchain\n      refine' ⟨h.1, fun i hi => ⟨h.2 i hi, _⟩⟩\n      cases hi\n      · exact hi.symm.le\n      cases' chain'_iff_pairwise.mp h.1 with _ _ h'\n      exact (h' _ hi).le\n  · exact supᵢ₂_le fun i hi => chain_height_mono <| Set.inter_subset_left _ _\n#align chain_height_eq_supr_Ici chain_height_eq_supr_Ici\n\n",
 "chain_height_empty":
 "@[simp]\ntheorem chain_height_empty : (∅ : Set α).chain_height = 0 :=\n  chainHeight_eq_zero_iff.2 rfl\n#align chain_height_empty chain_height_empty\n\n",
 "chain_height_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem chain_height_dual : («expr ⁻¹' » ofDual s).chain_height = s.chain_height := by\n  apply le_antisymm <;>\n    · rw [chain_height_le_chain_height_iff]\n      rintro l ⟨h₁, h₂⟩\n      exact ⟨l.reverse, ⟨chain'_reverse.mpr h₁, fun i h => h₂ i (mem_reverse.mp h)⟩, (length_reverse _).symm⟩\n#align chain_height_dual chain_height_dual\n\n",
 "chain_height_add_le_chain_height_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem chain_height_add_le_chain_height_add (s : Set α) (t : Set β) (n m : ℕ) :\n    s.chain_height + n ≤ t.chain_height + m ↔ ∀ l ∈ s.subchain, ∃ l' ∈ t.subchain, length l + n ≤ length l' + m :=\n  by\n  refine'\n    ⟨fun e l h =>\n      le_chain_height_add_nat_iff.1 ((add_le_add_right (length_le_chain_height_of_mem_subchain h) _).trans e), fun H =>\n      _⟩\n  by_cases s.chain_height = «expr⊤»\n  · suffices t.chain_height = «expr⊤» by\n      rw [this, top_add]\n      exact le_top\n    rw [chain_height_eq_top_iff] at h⊢\n    intro k\n    rw [(le_chain_height_tfae t k).out 1 2]\n    obtain ⟨l, hs, hl⟩ := h (k + m)\n    obtain ⟨l', ht, hl'⟩ := H l hs\n    exact ⟨l', ht, (add_le_add_iff_right m).1 <| trans (hl.symm.trans_le le_self_add) hl'⟩\n  · obtain ⟨k, hk⟩ := WithTop.ne_top_iff_exists.1 h\n    obtain ⟨l, hs, hl⟩ := le_chain_height_iff.1 hk.le\n    rw [← hk, ← hl]\n    exact le_chain_height_add_nat_iff.2 (H l hs)\n#align chain_height_add_le_chain_height_add chain_height_add_le_chain_height_add\n\n"}