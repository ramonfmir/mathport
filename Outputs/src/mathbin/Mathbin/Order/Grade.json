{"isMin_grade_iff":
 "#print isMin_grade_iff /-\n@[simp]\ntheorem isMin_grade_iff : IsMin (grade ğ•† a) â†” IsMin a :=\n  âŸ¨grade_strictMono.is_min_of_apply, IsMin.grade _âŸ©\n#align is_min_grade_iff isMin_grade_iff\n-/\n\n",
 "isMax_grade_iff":
 "#print isMax_grade_iff /-\n@[simp]\ntheorem isMax_grade_iff : IsMax (grade ğ•† a) â†” IsMax a :=\n  âŸ¨grade_strictMono.is_max_of_apply, IsMax.grade _âŸ©\n#align is_max_grade_iff isMax_grade_iff\n-/\n\n",
 "grade_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n#print grade_top /-\n@[simp]\ntheorem grade_top [OrderTop ğ•†] [OrderTop Î±] [GradeMaxOrder ğ•† Î±] : grade ğ•† (Â«exprâŠ¤Â» : Î±) = Â«exprâŠ¤Â» :=\n  (isMax_top.grade _).eq_top\n#align grade_top grade_top\n-/\n\n",
 "grade_toDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\n#print grade_toDual /-\n@[simp]\ntheorem grade_toDual [GradeOrder ğ•† Î±] (a : Î±) : grade (Â«expr áµ’áµˆÂ» ğ•†) (toDual a) = toDual (grade ğ•† a) :=\n  rfl\n#align grade_to_dual grade_toDual\n-/\n\n",
 "grade_strictMono":
 "#print grade_strictMono /-\ntheorem grade_strictMono : StrictMono (grade ğ•† : Î± â†’ ğ•†) :=\n  grade_order.grade_strict_mono\n#align grade_strict_mono grade_strictMono\n-/\n\n",
 "grade_self":
 "#print grade_self /-\n@[simp]\ntheorem grade_self (a : Î±) : grade Î± a = a :=\n  rfl\n#align grade_self grade_self\n-/\n\n",
 "grade_ofDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\n#print grade_ofDual /-\n@[simp]\ntheorem grade_ofDual [GradeOrder ğ•† Î±] (a : Â«expr áµ’áµˆÂ» Î±) : grade ğ•† (ofDual a) = ofDual (grade (Â«expr áµ’áµˆÂ» ğ•†) a) :=\n  rfl\n#align grade_of_dual grade_ofDual\n-/\n\n",
 "grade_ne_grade_iff":
 "#print grade_ne_grade_iff /-\ntheorem grade_ne_grade_iff : grade ğ•† a â‰  grade ğ•† b â†” a â‰  b :=\n  grade_injective.ne_iff\n#align grade_ne_grade_iff grade_ne_grade_iff\n-/\n\n",
 "grade_mono":
 "#print grade_mono /-\n-- graded order\ntheorem grade_mono [partial_order Î±] [GradeOrder ğ•† Î±] : Monotone (grade ğ•† : Î± â†’ ğ•†) :=\n  grade_strictMono.monotone\n#align grade_mono grade_mono\n-/\n\n",
 "grade_lt_grade_iff":
 "#print grade_lt_grade_iff /-\n@[simp]\ntheorem grade_lt_grade_iff : grade ğ•† a < grade ğ•† b â†” a < b :=\n  grade_strictMono.lt_iff_lt\n#align grade_lt_grade_iff grade_lt_grade_iff\n-/\n\n",
 "grade_le_grade_iff":
 "#print grade_le_grade_iff /-\n@[simp]\ntheorem grade_le_grade_iff : grade ğ•† a â‰¤ grade ğ•† b â†” a â‰¤ b :=\n  grade_strictMono.le_iff_le\n#align grade_le_grade_iff grade_le_grade_iff\n-/\n\n",
 "grade_injective":
 "#print grade_injective /-\n-- graded order\ntheorem grade_injective : function.injective (grade ğ•† : Î± â†’ ğ•†) :=\n  grade_strictMono.injective\n#align grade_injective grade_injective\n-/\n\n",
 "grade_eq_grade_iff":
 "#print grade_eq_grade_iff /-\n@[simp]\ntheorem grade_eq_grade_iff : grade ğ•† a = grade ğ•† b â†” a = b :=\n  grade_injective.eq_iff\n#align grade_eq_grade_iff grade_eq_grade_iff\n-/\n\n",
 "grade_covby_grade_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹– Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹– Â» -/\n#print grade_covby_grade_iff /-\ntheorem grade_covby_grade_iff : Â«expr â‹– Â» (grade ğ•† a) (grade ğ•† b) â†” Â«expr â‹– Â» a b :=\n  (covby_iff_lt_covby_grade.trans <| and_iff_right_of_imp fun h => grade_lt_grade_iff.1 h.1).symm\n#align grade_covby_grade_iff grade_covby_grade_iff\n-/\n\n",
 "grade_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n#print grade_bot /-\n-- graded order\n-- grading\n@[simp]\ntheorem grade_bot [OrderBot ğ•†] [OrderBot Î±] [GradeMinOrder ğ•† Î±] : grade ğ•† (Â«exprâŠ¥Â» : Î±) = Â«exprâŠ¥Â» :=\n  (isMin_bot.grade _).eq_bot\n#align grade_bot grade_bot\n-/\n\n",
 "grade":
 "#print IsMax.grade /-\nprotected theorem IsMax.grade (h : IsMax a) : IsMax (grade ğ•† a) :=\n  grade_max_order.is_max_grade h\n#align is_max.grade IsMax.grade\n-/\n\n",
 "covby_iff_lt_covby_grade":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹– Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹– Â» -/\n#print covby_iff_lt_covby_grade /-\ntheorem covby_iff_lt_covby_grade : Â«expr â‹– Â» a b â†” a < b âˆ§ Â«expr â‹– Â» (grade ğ•† a) (grade ğ•† b) :=\n  âŸ¨fun h => âŸ¨h.1, h.grade _âŸ©, And.imp_right fun h c ha hb => h.2 (grade_strictMono ha) <| grade_strictMono hbâŸ©\n#align covby_iff_lt_covby_grade covby_iff_lt_covby_grade\n-/\n\n"}