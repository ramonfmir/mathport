{"well_founded_iff_no_descending_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪r » -/\n/-- A relation is well-founded iff it doesn't have any infinite decreasing sequence. -/\ntheorem well_founded_iff_no_descending_seq : well_founded r ↔ IsEmpty («expr ↪r » ((· > ·) : ℕ → ℕ → Prop) r) :=\n  by\n  constructor\n  · rintro ⟨h⟩\n    exact ⟨fun f => not_acc_of_decreasing_seq f 0 (h _)⟩\n  · intro h\n    exact ⟨fun x => acc_iff_no_decreasing_seq.2 inferInstance⟩\n#align well_founded_iff_no_descending_seq well_founded_iff_no_descending_seq\n\n",
 "supᵢ_eq_monotonicSequenceLimit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\n#print WellFounded.supᵢ_eq_monotonicSequenceLimit /-\ntheorem WellFounded.supᵢ_eq_monotonicSequenceLimit [CompleteLattice α] (h : well_founded ((· > ·) : α → α → Prop))\n    (a : «expr →o » ℕ α) : supᵢ a = monotonicSequenceLimit a :=\n  by\n  apply (supᵢ_le fun m => _).antisymm (le_supᵢ a _)\n  cases' le_or_lt m (monotonicSequenceLimitIndex a) with hm hm\n  · exact a.monotone hm\n  · cases' WellFounded.monotone_chain_condition'.1 h a with n hn\n    exact (Nat.infₛ_mem ⟨n, fun k hk => (a.mono hk).eq_of_not_lt (hn k hk)⟩ m hm.le).ge\n#align well_founded.supr_eq_monotonic_sequence_limit WellFounded.supᵢ_eq_monotonicSequenceLimit\n-/\n\n",
 "order_iso_of_nat_apply":
 "@[simp]\ntheorem subtype.order_iso_of_nat_apply [DecidablePred (· ∈ s)] {n : ℕ} :\n    Subtype.orderIsoOfNat s n = Subtype.ofNat s n :=\n  by\n  simp [subtype.order_iso_of_nat]\n  congr\n#align subtype.order_iso_of_nat_apply subtype.order_iso_of_nat_apply\n\n",
 "order_embedding_of_set_range":
 "theorem order_embedding_of_set_range [DecidablePred (· ∈ s)] : Set.range (Nat.orderEmbeddingOfSet s) = s :=\n  Subtype.coe_comp_ofNat_range\n#align order_embedding_of_set_range order_embedding_of_set_range\n\n",
 "order_embedding_of_set_apply":
 "theorem order_embedding_of_set_apply [DecidablePred (· ∈ s)] {n : ℕ} : orderEmbeddingOfSet s n = Subtype.ofNat s n :=\n  rfl\n#align order_embedding_of_set_apply order_embedding_of_set_apply\n\n",
 "not_well_founded_of_decreasing_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪r » -/\ntheorem not_well_founded_of_decreasing_seq (f : «expr ↪r » ((· > ·) : ℕ → ℕ → Prop) r) : ¬well_founded r :=\n  by\n  rw [well_founded_iff_no_descending_seq, not_isEmpty_iff]\n  exact ⟨f⟩\n#align not_well_founded_of_decreasing_seq not_well_founded_of_decreasing_seq\n\n",
 "not_acc_of_decreasing_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪r » -/\ntheorem not_acc_of_decreasing_seq (f : «expr ↪r » ((· > ·) : ℕ → ℕ → Prop) r) (k : ℕ) : ¬acc r (f k) :=\n  by\n  rw [acc_iff_no_decreasing_seq, not_isEmpty_iff]\n  exact ⟨⟨f, k, rfl⟩⟩\n#align not_acc_of_decreasing_seq not_acc_of_decreasing_seq\n\n",
 "monotone_chain_condition'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →r » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\n#print WellFounded.monotone_chain_condition' /-\ntheorem WellFounded.monotone_chain_condition' [preorder α] :\n    well_founded ((· > ·) : α → α → Prop) ↔ ∀ a : «expr →o » ℕ α, ∃ n, ∀ m, n ≤ m → ¬a n < a m :=\n  by\n  refine' ⟨fun h a => _, fun h => _⟩\n  · have hne : (Set.range a).nonempty := ⟨a 0, by simp⟩\n    obtain ⟨x, ⟨n, rfl⟩, H⟩ := h.has_min _ hne\n    exact ⟨n, fun m hm => H _ (Set.mem_range_self _)⟩\n  · refine' RelEmbedding.wellFounded_iff_no_descending_seq.2 ⟨fun a => _⟩\n    obtain ⟨n, hn⟩ := h (a.swap : «expr →r » ((· < ·) : ℕ → ℕ → Prop) ((· < ·) : α → α → Prop)).to_order_hom\n    exact hn n.succ n.lt_succ_self.le ((RelEmbedding.map_rel_iff _).2 n.lt_succ_self)\n#align well_founded.monotone_chain_condition' WellFounded.monotone_chain_condition'\n-/\n\n",
 "monotone_chain_condition":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr ∀ a, «expr∃ , »((n), ∀ (m) (h : «expr ≤ »(n, m)), (_ : exprProp()))]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\n#print WellFounded.monotone_chain_condition /-\n/-- The \"monotone chain condition\" below is sometimes a convenient form of well foundedness. -/\ntheorem WellFounded.monotone_chain_condition [partial_order α] :\n    well_founded ((· > ·) : α → α → Prop) ↔ ∀ a : «expr →o » ℕ α, ∃ n, ∀ m, n ≤ m → a n = a m :=\n  WellFounded.monotone_chain_condition'.trans <|\n    by\n    trace\n      \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr ∀ a, «expr∃ , »((n), ∀ (m) (h : «expr ≤ »(n, m)), (_ : exprProp()))]]\"\n    rw [lt_iff_le_and_ne]\n    simp [a.mono h]\n#align well_founded.monotone_chain_condition WellFounded.monotone_chain_condition\n-/\n\n",
 "exists_subseq_of_forall_mem_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\ntheorem exists_subseq_of_forall_mem_union {s t : Set α} (e : ℕ → α) (he : ∀ n, e n ∈ s ∪ t) :\n    ∃ g : «expr ↪o » ℕ ℕ, (∀ n, e (g n) ∈ s) ∨ ∀ n, e (g n) ∈ t := by\n  classical\n    have : Infinite («expr ⁻¹' » e s) ∨ Infinite («expr ⁻¹' » e t) := by\n      simp only [Set.infinite_coe_iff, ← Set.infinite_union, ← Set.preimage_union,\n        Set.eq_univ_of_forall fun n => Set.mem_preimage.2 (he n), Set.infinite_univ]\n    cases this\n    exacts[⟨Nat.orderEmbeddingOfSet («expr ⁻¹' » e s), or.inl fun n => (Nat.Subtype.ofNat («expr ⁻¹' » e s) _).2⟩,\n      ⟨Nat.orderEmbeddingOfSet («expr ⁻¹' » e t), or.inr fun n => (Nat.Subtype.ofNat («expr ⁻¹' » e t) _).2⟩]\n#align exists_subseq_of_forall_mem_union exists_subseq_of_forall_mem_union\n\n",
 "exists_not_acc_lt_of_not_acc":
 "theorem exists_not_acc_lt_of_not_acc {a : α} {r} (h : ¬acc r a) : ∃ b, ¬acc r b ∧ r b a :=\n  by\n  contrapose! h\n  refine' ⟨_, fun b hr => _⟩\n  by_contra hb\n  exact h b hb hr\n#align exists_not_acc_lt_of_not_acc exists_not_acc_lt_of_not_acc\n\n",
 "exists_increasing_or_nonincreasing_subseq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n#print exists_increasing_or_nonincreasing_subseq' /-\ntheorem exists_increasing_or_nonincreasing_subseq' (r : α → α → Prop) (f : ℕ → α) :\n    ∃ g : «expr ↪o » ℕ ℕ, (∀ n : ℕ, r (f (g n)) (f (g (n + 1)))) ∨ ∀ m n : ℕ, m < n → ¬r (f (g m)) (f (g n)) := by\n  classical\n    let bad : Set ℕ := { m | ∀ n, m < n → ¬r (f m) (f n) }\n    by_cases hbad : Infinite bad\n    · haveI := hbad\n      refine' ⟨Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => _⟩\n      have h := Set.mem_range_self m\n      rw [Nat.orderEmbeddingOfSet_range bad] at h\n      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)\n    · rw [Set.infinite_coe_iff, Set.Infinite, Classical.not_not] at hbad\n      obtain ⟨m, hm⟩ : ∃ m, ∀ n, m ≤ n → ¬n ∈ bad :=\n        by\n        by_cases he : hbad.to_finset.nonempty\n        ·\n          refine'\n            ⟨(hbad.to_finset.max' he).succ, fun n hn nbad =>\n              nat.not_succ_le_self _ (hn.trans (hbad.to_finset.le_max' n (hbad.mem_to_finset.2 nbad)))⟩\n        · exact ⟨0, fun n hn nbad => he ⟨n, hbad.mem_to_finset.2 nbad⟩⟩\n      have h : ∀ n : ℕ, ∃ n' : ℕ, n < n' ∧ r (f (n + m)) (f (n' + m)) :=\n        by\n        intro n\n        have h := hm _ (le_add_of_nonneg_left n.zero_le)\n        simp only [exists_prop, Classical.not_not, Set.mem_setOf_eq, not_forall] at h\n        obtain ⟨n', hn1, hn2⟩ := h\n        obtain ⟨x, hpos, rfl⟩ := exists_pos_add_of_lt hn1\n        refine' ⟨n + x, add_lt_add_left hpos n, _⟩\n        rw [add_assoc, add_comm x m, ← add_assoc]\n        exact hn2\n      let g' : ℕ → ℕ := @nat.rec (fun _ => ℕ) m fun n gn => nat.find (h gn)\n      exact\n        ⟨(RelEmbedding.natLt (fun n => g' n + m) fun n =>\n              nat.add_lt_add_right (nat.find_spec (h (g' n))).1 m).order_embedding_of_lt_embedding,\n          or.intro_left _ fun n => (nat.find_spec (h (g' n))).2⟩\n#align exists_increasing_or_nonincreasing_subseq' exists_increasing_or_nonincreasing_subseq'\n-/\n\n",
 "exists_increasing_or_nonincreasing_subseq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n#print exists_increasing_or_nonincreasing_subseq /-\n/-- This is the infinitary Erdős–Szekeres theorem, and an important lemma in the usual proof of\n    Bolzano-Weierstrass for `ℝ`. -/\ntheorem exists_increasing_or_nonincreasing_subseq (r : α → α → Prop) [is_trans α r] (f : ℕ → α) :\n    ∃ g : «expr ↪o » ℕ ℕ, (∀ m n : ℕ, m < n → r (f (g m)) (f (g n))) ∨ ∀ m n : ℕ, m < n → ¬r (f (g m)) (f (g n)) :=\n  by\n  obtain ⟨g, hr | hnr⟩ := exists_increasing_or_nonincreasing_subseq' r f\n  · refine' ⟨g, or.intro_left _ fun m n mn => _⟩\n    obtain ⟨x, rfl⟩ := exists_add_of_le (Nat.succ_le_iff.2 mn)\n    induction' x with x ih\n    · apply hr\n    · apply is_trans.trans _ _ _ _ (hr _)\n      exact ih (lt_of_lt_of_le m.lt_succ_self (nat.le_add_right _ _))\n  · exact ⟨g, Or.intro_right _ hnr⟩\n#align exists_increasing_or_nonincreasing_subseq exists_increasing_or_nonincreasing_subseq\n-/\n\n",
 "coe_order_embedding_of_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_order_embedding_of_set [DecidablePred (· ∈ s)] : «expr⇑ » (orderEmbeddingOfSet s) = coe ∘ Subtype.ofNat s :=\n  rfl\n#align coe_order_embedding_of_set coe_order_embedding_of_set\n\n",
 "coe_nat_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\n@[simp]\ntheorem coe_nat_lt {f : ℕ → α} {H : ∀ n : ℕ, r (f n) (f (n + 1))} : «expr⇑ » (natLt f H) = f :=\n  rfl\n#align coe_nat_lt coe_nat_lt\n\n",
 "coe_nat_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_nat_gt {f : ℕ → α} {H : ∀ n : ℕ, r (f (n + 1)) (f n)} : «expr⇑ » (natGt f H) = f :=\n  rfl\n#align coe_nat_gt coe_nat_gt\n\n",
 "acc_iff_no_decreasing_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪r » -/\n/-- A value is accessible iff it isn't contained in any infinite decreasing sequence. -/\ntheorem acc_iff_no_decreasing_seq {x} :\n    acc r x ↔ IsEmpty { f : «expr ↪r » ((· > ·) : ℕ → ℕ → Prop) r // x ∈ Set.range f } :=\n  by\n  constructor\n  · refine' fun h => h.rec_on fun x h IH => _\n    constructor\n    rintro ⟨f, k, hf⟩\n    exact IsEmpty.elim' (IH (f (k + 1)) (hf ▸ f.map_rel_iff.2 (lt_add_one k))) ⟨f, _, rfl⟩\n  · have : ∀ x : { a // ¬acc r a }, ∃ y : { a // ¬acc r a }, r y.1 x.1 :=\n      by\n      rintro ⟨x, hx⟩\n      cases exists_not_acc_lt_of_not_acc hx\n      exact ⟨⟨w, h.1⟩, h.2⟩\n    obtain ⟨f, h⟩ := classical.axiom_of_choice this\n    refine' fun E =>\n      by_contradiction fun hx => E.elim' ⟨nat_gt (fun n => ((«expr ^[ ]» f n) ⟨x, hx⟩).1) fun n => _, 0, rfl⟩\n    rw [Function.iterate_succ']\n    apply h\n#align acc_iff_no_decreasing_seq acc_iff_no_decreasing_seq\n\n"}