{"u_cinfi_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem u_cinfi_set (gc : GaloisConnection l u) {s : set γ} {f : γ → β} (hf : BddBelow («expr '' » f s))\n    (hne : s.nonempty) :\n    u («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u (f i)) :=\n  gc.dual.l_csupr_set hf hne\n#align u_cinfi_set u_cinfi_set\n\n",
 "u_cinfi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem u_cinfi (gc : GaloisConnection l u) {f : ι → β} (hf : BddBelow (range f)) :\n    u («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u (f i)) :=\n  gc.dual.l_csupr hf\n#align u_cinfi u_cinfi\n\n",
 "u_cInf'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem u_cInf' (gc : GaloisConnection l u) {s : set β} (hne : s.nonempty) (hbdd : BddBelow s) :\n    u (infₛ s) = infₛ («expr '' » u s) :=\n  gc.dual.l_cSup' hne hbdd\n#align u_cInf' u_cInf'\n\n",
 "u_cInf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem u_cInf (gc : GaloisConnection l u) {s : set β} (hne : s.nonempty) (hbdd : BddBelow s) :\n    u (infₛ s) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u x) :=\n  gc.dual.l_cSup hne hbdd\n#align u_cInf u_cInf\n\n",
 "supₛ_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print WithBot.supₛ_empty /-\n@[simp]\ntheorem WithBot.supₛ_empty {α : Type _} [SupSet α] : supₛ (∅ : set (WithBot α)) = «expr⊥» :=\n  if_pos <| Set.empty_subset _\n#align with_bot.cSup_empty WithBot.supₛ_empty\n-/\n\n",
 "supᵢ_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print WithBot.supᵢ_empty /-\n@[simp]\ntheorem WithBot.supᵢ_empty {α : Type _} [is_empty ι] [SupSet α] (f : ι → WithBot α) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) = «expr⊥» :=\n  @WithTop.infᵢ_empty _ («expr ᵒᵈ» α) _ _ _\n#align with_bot.csupr_empty WithBot.supᵢ_empty\n-/\n\n",
 "supr_coe_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print WithTop.supr_coe_lt_top /-\ntheorem WithTop.supr_coe_lt_top {ι : Sort _} {α : Type _} [ConditionallyCompleteLinearOrderBot α] (f : ι → α) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f x : WithTop α) <\n        «expr⊤» ↔\n      BddAbove (Set.range f) :=\n  lt_top_iff_ne_top.trans <| (WithTop.supr_coe_eq_top f).not.trans not_not\n#align with_top.supr_coe_lt_top WithTop.supr_coe_lt_top\n-/\n\n",
 "supr_coe_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print WithTop.supr_coe_eq_top /-\ntheorem WithTop.supr_coe_eq_top {ι : Sort _} {α : Type _} [ConditionallyCompleteLinearOrderBot α] (f : ι → α) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f x : WithTop α) =\n        «expr⊤» ↔\n      ¬BddAbove (Set.range f) :=\n  by\n  rw [supᵢ_eq_top, not_bddAbove_iff]\n  refine' ⟨fun hf r => _, fun hf a ha => _⟩\n  · rcases hf r (WithTop.coe_lt_top r) with ⟨i, hi⟩\n    exact ⟨f i, ⟨i, rfl⟩, with_top.coe_lt_coe.mp hi⟩\n  · rcases hf (a.untop ha.ne) with ⟨-, ⟨i, rfl⟩, hi⟩\n    exact ⟨i, by simpa only [WithTop.coe_untop _ ha.ne] using with_top.coe_lt_coe.mpr hi⟩\n#align with_top.supr_coe_eq_top WithTop.supr_coe_eq_top\n-/\n\n",
 "subset_Icc_cinfₛ_csupₛ":
 "#print subset_Icc_cinfₛ_csupₛ /-\ntheorem subset_Icc_cinfₛ_csupₛ (hb : BddBelow s) (ha : BddAbove s) : s ⊆ Icc (infₛ s) (supₛ s) := fun x hx =>\n  ⟨cinfₛ_le hb hx, le_csupₛ ha hx⟩\n#align subset_Icc_cInf_cSup subset_Icc_cinfₛ_csupₛ\n-/\n\n",
 "not_mem_of_lt_cinfₛ":
 "#print not_mem_of_lt_cinfₛ /-\ntheorem not_mem_of_lt_cinfₛ {x : α} {s : set α} (h : x < infₛ s) (hs : BddBelow s) : x ∉ s := fun hx =>\n  lt_irrefl _ (h.trans_le (cinfₛ_le hs hx))\n#align not_mem_of_lt_cInf not_mem_of_lt_cinfₛ\n-/\n\n",
 "not_mem_of_csupₛ_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print not_mem_of_csupₛ_lt /-\ntheorem not_mem_of_csupₛ_lt {x : α} {s : set α} (h : supₛ s < x) (hs : BddAbove s) : x ∉ s :=\n  @not_mem_of_lt_cinfₛ («expr ᵒᵈ» α) _ x s h hs\n#align not_mem_of_cSup_lt not_mem_of_csupₛ_lt\n-/\n\n",
 "map_csupr_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem map_csupr_set (e : «expr ≃o » α β) {s : set γ} {f : γ → α} (hf : BddAbove («expr '' » f s)) (hne : s.nonempty) :\n    e («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (e (f i)) :=\n  e.to_galois_connection.l_csupr_set hf hne\n#align map_csupr_set map_csupr_set\n\n",
 "map_csupr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem map_csupr (e : «expr ≃o » α β) {f : ι → α} (hf : BddAbove (range f)) :\n    e («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (e (f i)) :=\n  e.to_galois_connection.l_csupr hf\n#align map_csupr map_csupr\n\n",
 "map_cinfₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Monotone.map_cinfₛ /-\ntheorem Monotone.map_cinfₛ {β : Type _} [ConditionallyCompleteLattice β] {f : α → β} (hf : monotone f)\n    (hs : s.nonempty) : f (infₛ s) = infₛ («expr '' » f s) :=\n  (hf.map_is_least (isLeast_cinfₛ hs)).cInf_eq.symm\n#align monotone.map_Inf Monotone.map_cinfₛ\n-/\n\n",
 "map_cinfi_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem map_cinfi_set (e : «expr ≃o » α β) {s : set γ} {f : γ → α} (hf : BddBelow («expr '' » f s)) (hne : s.nonempty) :\n    e («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (e (f i)) :=\n  e.dual.map_csupr_set hf hne\n#align map_cinfi_set map_cinfi_set\n\n",
 "map_cinfi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem map_cinfi (e : «expr ≃o » α β) {f : ι → α} (hf : BddBelow (range f)) :\n    e («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (e (f i)) :=\n  e.dual.map_csupr hf\n#align map_cinfi map_cinfi\n\n",
 "map_cSup'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_cSup' (e : «expr ≃o » α β) {s : set α} (hne : s.nonempty) (hbdd : BddAbove s) :\n    e (supₛ s) = supₛ («expr '' » e s) :=\n  e.to_galois_connection.l_cSup' hne hbdd\n#align map_cSup' map_cSup'\n\n",
 "map_cSup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem map_cSup (e : «expr ≃o » α β) {s : set α} (hne : s.nonempty) (hbdd : BddAbove s) :\n    e (supₛ s) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (e x) :=\n  e.to_galois_connection.l_cSup hne hbdd\n#align map_cSup map_cSup\n\n",
 "map_cInf'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_cInf' (e : «expr ≃o » α β) {s : set α} (hne : s.nonempty) (hbdd : BddBelow s) :\n    e (infₛ s) = infₛ («expr '' » e s) :=\n  e.dual.map_cSup' hne hbdd\n#align map_cInf' map_cInf'\n\n",
 "map_cInf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem map_cInf (e : «expr ≃o » α β) {s : set α} (hne : s.nonempty) (hbdd : BddBelow s) :\n    e (infₛ s) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (e x) :=\n  e.dual.map_cSup hne hbdd\n#align map_cInf map_cInf\n\n",
 "lt_csupₛ_of_lt":
 "#print lt_csupₛ_of_lt /-\n/-- b < Sup s when there is an element a in s with b < a, when s is bounded above.\nThis is essentially an iff, except that the assumptions for the two implications are\nslightly different (one needs boundedness above for one direction, nonemptiness and linear\norder for the other one), so we formulate separately the two implications, contrary to\nthe complete_lattice case.-/\ntheorem lt_csupₛ_of_lt (hs : BddAbove s) (ha : a ∈ s) (h : b < a) : b < supₛ s :=\n  lt_of_lt_of_le h (le_csupₛ hs ha)\n#align lt_cSup_of_lt lt_csupₛ_of_lt\n-/\n\n",
 "le_csupₛ_of_le":
 "#print le_csupₛ_of_le /-\ntheorem le_csupₛ_of_le (hs : BddAbove s) (hb : b ∈ s) (h : a ≤ b) : a ≤ supₛ s :=\n  le_trans h (le_csupₛ hs hb)\n#align le_cSup_of_le le_csupₛ_of_le\n-/\n\n",
 "le_csupₛ_iff'":
 "#print le_csupₛ_iff' /-\ntheorem le_csupₛ_iff' {s : set α} {a : α} (h : BddAbove s) : a ≤ supₛ s ↔ ∀ b, b ∈ upperBounds s → a ≤ b :=\n  ⟨fun h b hb => le_trans h (csupₛ_le' hb), fun hb => hb _ fun x => le_csupₛ h⟩\n#align le_cSup_iff' le_csupₛ_iff'\n-/\n\n",
 "le_csupₛ_iff":
 "#print le_csupₛ_iff /-\ntheorem le_csupₛ_iff (h : BddAbove s) (hs : s.nonempty) : a ≤ supₛ s ↔ ∀ b, b ∈ upperBounds s → a ≤ b :=\n  ⟨fun h b hb => le_trans h (csupₛ_le hs hb), fun hb => hb _ fun x => le_csupₛ h⟩\n#align le_cSup_iff le_csupₛ_iff\n-/\n\n",
 "le_csupₛ":
 "#print le_csupₛ /-\n-- section\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\ntheorem le_csupₛ (h₁ : BddAbove s) (h₂ : a ∈ s) : a ≤ supₛ s :=\n  conditionally_complete_lattice.le_cSup s a h₁ h₂\n#align le_cSup le_csupₛ\n-/\n\n",
 "le_csupᵢ_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print le_csupᵢ_set /-\ntheorem le_csupᵢ_set {f : β → α} {s : set β} (H : BddAbove («expr '' » f s)) {c : β} (hc : c ∈ s) :\n    f c ≤ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) :=\n  (le_csupₛ H <| mem_image_of_mem f hc).trans_eq supₛ_image'\n#align le_csupr_set le_csupᵢ_set\n-/\n\n",
 "le_csupᵢ_of_le":
 "#print le_csupᵢ_of_le /-\ntheorem le_csupᵢ_of_le {f : ι → α} (H : BddAbove (range f)) (c : ι) (h : a ≤ f c) : a ≤ supᵢ f :=\n  le_trans h (le_csupᵢ H c)\n#align le_csupr_of_le le_csupᵢ_of_le\n-/\n\n",
 "le_csupᵢ_iff'":
 "#print le_csupᵢ_iff' /-\ntheorem le_csupᵢ_iff' {s : ι → α} {a : α} (h : BddAbove (range s)) : a ≤ supᵢ s ↔ ∀ b, (∀ i, s i ≤ b) → a ≤ b := by\n  simp [supᵢ, h, le_csupₛ_iff', upperBounds]\n#align le_csupr_iff' le_csupᵢ_iff'\n-/\n\n",
 "le_csupᵢ":
 "#print le_csupᵢ /-\n/-- The indexed supremum of a function is bounded below by the value taken at one point-/\ntheorem le_csupᵢ {f : ι → α} (H : BddAbove (range f)) (c : ι) : f c ≤ supᵢ f :=\n  le_csupₛ H (mem_range_self _)\n#align le_csupr le_csupᵢ\n-/\n\n",
 "le_cinfₛ_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print le_cinfₛ_inter /-\n/-- The infimum of an intersection of two sets is bounded below by the maximum of the\ninfima of each set, if all sets are bounded below and nonempty.-/\ntheorem le_cinfₛ_inter : BddBelow s → BddBelow t → (s ∩ t).nonempty → «expr ⊔ » (infₛ s) (infₛ t) ≤ infₛ (s ∩ t) :=\n  @csupₛ_inter_le («expr ᵒᵈ» α) _ _ _\n#align le_cInf_inter le_cinfₛ_inter\n-/\n\n",
 "le_cinfₛ_iff''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print le_cinfₛ_iff'' /-\ntheorem le_cinfₛ_iff'' {s : set α} {a : α} (ne : s.nonempty) : a ≤ infₛ s ↔ ∀ b : α, b ∈ s → a ≤ b :=\n  le_cinfₛ_iff ⟨«expr⊥», fun a _ => bot_le⟩ ne\n#align le_cInf_iff'' le_cinfₛ_iff''\n-/\n\n",
 "le_cinfₛ_iff'":
 "#print le_cinfₛ_iff' /-\ntheorem le_cinfₛ_iff' (hs : s.nonempty) : b ≤ infₛ s ↔ b ∈ lowerBounds s :=\n  le_isGLB_iff (isLeast_cinfₛ hs).is_glb\n#align le_cInf_iff' le_cinfₛ_iff'\n-/\n\n",
 "le_cinfₛ_iff":
 "#print le_cinfₛ_iff /-\ntheorem le_cinfₛ_iff (hb : BddBelow s) (hs : s.nonempty) : a ≤ infₛ s ↔ ∀ b ∈ s, a ≤ b :=\n  le_isGLB_iff (isGLB_cinfₛ hs hb)\n#align le_cInf_iff le_cinfₛ_iff\n-/\n\n",
 "le_cinfₛ":
 "#print le_cinfₛ /-\ntheorem le_cinfₛ (h₁ : s.nonempty) (h₂ : ∀ b ∈ s, a ≤ b) : a ≤ infₛ s :=\n  conditionally_complete_lattice.le_cInf s a h₁ h₂\n#align le_cInf le_cinfₛ\n-/\n\n",
 "le_cinfᵢ_set_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print le_cinfᵢ_set_iff /-\ntheorem le_cinfᵢ_set_iff {ι : Type _} {s : set ι} {f : ι → α} {a : α} (hs : s.nonempty)\n    (hf : BddBelow («expr '' » f s)) :\n    a ≤ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i) ↔\n      ∀ i ∈ s, a ≤ f i :=\n  (le_isGLB_iff <| isGLB_cinfᵢ_set hf hs).trans ball_image_iff\n#align le_cinfi_set_iff le_cinfᵢ_set_iff\n-/\n\n",
 "le_cinfᵢ_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print le_cinfᵢ_iff' /-\ntheorem le_cinfᵢ_iff' [nonempty ι] {f : ι → α} {a : α} : a ≤ infᵢ f ↔ ∀ i, a ≤ f i :=\n  le_cinfᵢ_iff ⟨«expr⊥», fun a _ => bot_le⟩\n#align le_cinfi_iff' le_cinfᵢ_iff'\n-/\n\n",
 "le_cinfᵢ_iff":
 "#print le_cinfᵢ_iff /-\ntheorem le_cinfᵢ_iff [nonempty ι] {f : ι → α} {a : α} (hf : BddBelow (range f)) : a ≤ infᵢ f ↔ ∀ i, a ≤ f i :=\n  (le_isGLB_iff <| isGLB_cinfᵢ hf).trans forall_range_iff\n#align le_cinfi_iff le_cinfᵢ_iff\n-/\n\n",
 "le_cinfᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print le_cinfᵢ /-\n/-- The indexed minimum of a function is bounded below by a uniform lower bound-/\ntheorem le_cinfᵢ [nonempty ι] {f : ι → α} {c : α} (H : ∀ x, c ≤ f x) : c ≤ infᵢ f :=\n  @csupᵢ_le («expr ᵒᵈ» α) _ _ _ _ _ H\n#align le_cinfi le_cinfᵢ\n-/\n\n",
 "le_cSup_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem le_cSup_image {s : set α} {c : α} (hcs : c ∈ s) (h_bdd : BddAbove s) : f c ≤ supₛ («expr '' » f s) :=\n  le_csupₛ (map_bddAbove h_mono h_bdd) (mem_image_of_mem f hcs)\n#align le_cSup_image le_cSup_image\n\n",
 "le_cInf_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem le_cInf_image {s : set α} (hs : s.nonempty) {B : α} (hB : B ∈ lowerBounds s) : f B ≤ infₛ («expr '' » f s) :=\n  @csupₛ_image_le («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ _ (fun x y hxy => h_mono hxy) _ hs _ hB\n#align le_cInf_image le_cInf_image\n\n",
 "l_csupr_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem l_csupr_set (gc : GaloisConnection l u) {s : set γ} {f : γ → α} (hf : BddAbove («expr '' » f s))\n    (hne : s.nonempty) :\n    l («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (l (f i)) :=\n  by\n  haveI := hne.to_subtype\n  rw [image_eq_range] at hf\n  exact gc.l_csupr hf\n#align l_csupr_set l_csupr_set\n\n",
 "l_csupr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem l_csupr (gc : GaloisConnection l u) {f : ι → α} (hf : BddAbove (range f)) :\n    l («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (l (f i)) :=\n  by rw [supᵢ, gc.l_cSup (range_nonempty _) hf, supᵢ_range']\n#align l_csupr l_csupr\n\n",
 "l_cSup'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem l_cSup' (gc : GaloisConnection l u) {s : set α} (hne : s.nonempty) (hbdd : BddAbove s) :\n    l (supₛ s) = supₛ («expr '' » l s) := by rw [gc.l_cSup hne hbdd, supₛ_image']\n#align l_cSup' l_cSup'\n\n",
 "l_cSup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem l_cSup (gc : GaloisConnection l u) {s : set α} (hne : s.nonempty) (hbdd : BddAbove s) :\n    l (supₛ s) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (l x) :=\n  eq.symm <| IsLUB.csupᵢ_set_eq (gc.is_lub_l_image <| isLUB_csupₛ hne hbdd) hne\n#align l_cSup l_cSup\n\n",
 "is_lub_Sup'":
 "/-- The Sup of a non-empty set is its least upper bound for a conditionally\ncomplete lattice with a top. -/\ntheorem is_lub_Sup' {β : Type _} [ConditionallyCompleteLattice β] {s : set (WithTop β)} (hs : s.nonempty) :\n    IsLUB s (supₛ s) := by\n  constructor\n  · show ite _ _ _ ∈ _\n    split_ifs\n    · intro _ _\n      exact le_top\n    · rintro (⟨⟩ | a) ha\n      · contradiction\n      apply some_le_some.2\n      exact le_csupₛ h_1 ha\n    · intro _ _\n      exact le_top\n  · show ite _ _ _ ∈ _\n    split_ifs\n    · rintro (⟨⟩ | a) ha\n      · exact le_rfl\n      · exact false.elim (not_top_le_coe a (ha h))\n    · rintro (⟨⟩ | b) hb\n      · exact le_top\n      refine' some_le_some.2 (csupₛ_le _ _)\n      · rcases hs with ⟨⟨⟩ | b, hb⟩\n        · exact absurd hb h\n        · exact ⟨b, hb⟩\n      · intro a ha\n        exact some_le_some.1 (hb ha)\n    · rintro (⟨⟩ | b) hb\n      · exact le_rfl\n      · exfalso\n        apply h_1\n        use b\n        intro a ha\n        exact some_le_some.1 (hb ha)\n#align is_lub_Sup' is_lub_Sup'\n\n",
 "is_glb_Inf'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The Inf of a bounded-below set is its greatest lower bound for a conditionally\ncomplete lattice with a top. -/\ntheorem is_glb_Inf' {β : Type _} [ConditionallyCompleteLattice β] {s : set (WithTop β)} (hs : BddBelow s) :\n    IsGLB s (infₛ s) := by\n  constructor\n  · show ite _ _ _ ∈ _\n    split_ifs\n    · intro a ha\n      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))\n    · rintro (⟨⟩ | a) ha\n      · exact le_top\n      refine' some_le_some.2 (cinfₛ_le _ ha)\n      rcases hs with ⟨⟨⟩ | b, hb⟩\n      · exfalso\n        apply h\n        intro c hc\n        rw [mem_singleton_iff, ← top_le_iff]\n        exact hb hc\n      use b\n      intro c hc\n      exact some_le_some.1 (hb hc)\n  · show ite _ _ _ ∈ _\n    split_ifs\n    · intro _ _\n      exact le_top\n    · rintro (⟨⟩ | a) ha\n      · exfalso\n        apply h\n        intro b hb\n        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))\n      · refine' some_le_some.2 (le_cinfₛ _ _)\n        ·\n          classical\n            contrapose! h\n            rintro (⟨⟩ | a) ha\n            · exact mem_singleton («expr⊤»)\n            · exact (h ⟨a, ha⟩).elim\n        · intro b hb\n          rw [← some_le_some]\n          exact ha hb\n#align is_glb_Inf' is_glb_Inf'\n\n",
 "isLeast_cinfₛ":
 "#print isLeast_cinfₛ /-\ntheorem isLeast_cinfₛ (hs : s.nonempty) : IsLeast s (infₛ s) :=\n  by\n  rw [infₛ_eq_argmin_on hs]\n  exact ⟨argmin_on_mem _ _ _ _, fun a ha => argmin_on_le id _ _ ha⟩\n#align is_least_Inf isLeast_cinfₛ\n-/\n\n",
 "isLUB_supₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print isLUB_supₛ /-\ntheorem isLUB_supₛ (s : set (WithTop α)) : IsLUB s (supₛ s) :=\n  by\n  cases' s.eq_empty_or_nonempty with hs hs\n  · rw [hs]\n    show IsLUB ∅ (ite _ _ _)\n    split_ifs\n    · cases h\n    · rw [preimage_empty, csupₛ_empty]\n      exact isLUB_empty\n    · exfalso\n      apply h_1\n      use «expr⊥»\n      rintro a ⟨⟩\n  exact is_lub_Sup' hs\n#align is_lub_Sup isLUB_supₛ\n-/\n\n",
 "isLUB_csupₛ'":
 "#print isLUB_csupₛ' /-\ntheorem isLUB_csupₛ' {s : set α} (hs : BddAbove s) : IsLUB s (supₛ s) :=\n  by\n  rcases eq_empty_or_nonempty s with (rfl | hne)\n  · simp only [csupₛ_empty, isLUB_empty]\n  · exact isLUB_csupₛ hne hs\n#align is_lub_cSup' isLUB_csupₛ'\n-/\n\n",
 "isLUB_csupₛ":
 "#print isLUB_csupₛ /-\ntheorem isLUB_csupₛ (ne : s.nonempty) (H : BddAbove s) : IsLUB s (supₛ s) :=\n  ⟨fun x => le_csupₛ H, fun x => csupₛ_le ne⟩\n#align is_lub_cSup isLUB_csupₛ\n-/\n\n",
 "isLUB_csupᵢ_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print isLUB_csupᵢ_set /-\ntheorem isLUB_csupᵢ_set {f : β → α} {s : set β} (H : BddAbove («expr '' » f s)) (Hne : s.nonempty) :\n    IsLUB («expr '' » f s)\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) :=\n  by\n  rw [← supₛ_image']\n  exact isLUB_csupₛ (Hne.image _) H\n#align is_lub_csupr_set isLUB_csupᵢ_set\n-/\n\n",
 "isLUB_csupᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print isLUB_csupᵢ /-\ntheorem isLUB_csupᵢ [nonempty ι] {f : ι → α} (H : BddAbove (range f)) :\n    IsLUB (range f)\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) :=\n  isLUB_csupₛ (range_nonempty f) H\n#align is_lub_csupr isLUB_csupᵢ\n-/\n\n",
 "isGLB_infₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print isGLB_infₛ /-\ntheorem isGLB_infₛ (s : set (WithTop α)) : IsGLB s (infₛ s) :=\n  by\n  by_cases hs : BddBelow s\n  · exact is_glb_Inf' hs\n  · exfalso\n    apply hs\n    use «expr⊥»\n    intro _ _\n    exact bot_le\n#align is_glb_Inf isGLB_infₛ\n-/\n\n",
 "isGLB_cinfₛ":
 "#print isGLB_cinfₛ /-\ntheorem isGLB_cinfₛ (ne : s.nonempty) (H : BddBelow s) : IsGLB s (infₛ s) :=\n  ⟨fun x => cinfₛ_le H, fun x => le_cinfₛ ne⟩\n#align is_glb_cInf isGLB_cinfₛ\n-/\n\n",
 "isGLB_cinfᵢ_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print isGLB_cinfᵢ_set /-\ntheorem isGLB_cinfᵢ_set {f : β → α} {s : set β} (H : BddBelow («expr '' » f s)) (Hne : s.nonempty) :\n    IsGLB («expr '' » f s)\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)) :=\n  @isLUB_csupᵢ_set («expr ᵒᵈ» α) _ _ _ _ H Hne\n#align is_glb_cinfi_set isGLB_cinfᵢ_set\n-/\n\n",
 "isGLB_cinfᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print isGLB_cinfᵢ /-\ntheorem isGLB_cinfᵢ [nonempty ι] {f : ι → α} (H : BddBelow (range f)) :\n    IsGLB (range f)\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)) :=\n  isGLB_cinfₛ (range_nonempty f) H\n#align is_glb_cinfi isGLB_cinfᵢ\n-/\n\n",
 "infₛ_eq_argmin_on":
 "#print infₛ_eq_argmin_on /-\ntheorem infₛ_eq_argmin_on (hs : s.nonempty) : infₛ s = argminOn id (@is_well_founded.wf α (· < ·) _) s hs :=\n  IsLeast.cinfₛ_eq ⟨argminOn_mem _ _ _ _, fun a ha => argminOn_le id _ _ ha⟩\n#align Inf_eq_argmin_on infₛ_eq_argmin_on\n-/\n\n",
 "infₛ_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print WithTop.infₛ_empty /-\n/-\nCopyright (c) 2018 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n@[simp]\ntheorem WithTop.infₛ_empty {α : Type _} [InfSet α] : infₛ (∅ : set (WithTop α)) = «expr⊤» :=\n  if_pos <| Set.empty_subset _\n#align with_top.cInf_empty WithTop.infₛ_empty\n-/\n\n",
 "infᵢ_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print WithTop.infᵢ_empty /-\n@[simp]\ntheorem WithTop.infᵢ_empty {α : Type _} [is_empty ι] [InfSet α] (f : ι → WithTop α) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i) = «expr⊤» :=\n  by rw [infᵢ, range_eq_empty, WithTop.infₛ_empty]\n#align with_top.cinfi_empty WithTop.infᵢ_empty\n-/\n\n",
 "exists_lt_of_lt_csupₛ'":
 "#print exists_lt_of_lt_csupₛ' /-\ntheorem exists_lt_of_lt_csupₛ' {s : set α} {a : α} (h : a < supₛ s) : ∃ b ∈ s, a < b :=\n  by\n  contrapose! h\n  exact csupₛ_le' h\n#align exists_lt_of_lt_cSup' exists_lt_of_lt_csupₛ'\n-/\n\n",
 "exists_lt_of_lt_csupₛ":
 "#print exists_lt_of_lt_csupₛ /-\n/-- When b < Sup s, there is an element a in s with b < a, if s is nonempty and the order is\na linear order. -/\ntheorem exists_lt_of_lt_csupₛ (hs : s.nonempty) (hb : b < supₛ s) : ∃ a ∈ s, b < a :=\n  by\n  contrapose! hb\n  exact csupₛ_le hs hb\n#align exists_lt_of_lt_cSup exists_lt_of_lt_csupₛ\n-/\n\n",
 "exists_lt_of_lt_csupᵢ'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print exists_lt_of_lt_csupᵢ' /-\ntheorem exists_lt_of_lt_csupᵢ' {f : ι → α} {a : α}\n    (h : a < «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) :\n    ∃ i, a < f i := by\n  contrapose! h\n  exact csupᵢ_le' h\n#align exists_lt_of_lt_csupr' exists_lt_of_lt_csupᵢ'\n-/\n\n",
 "exists_lt_of_lt_csupᵢ":
 "#print exists_lt_of_lt_csupᵢ /-\n/-- Indexed version of the above lemma `exists_lt_of_lt_cSup`.\nWhen `b < supr f`, there is an element `i` such that `b < f i`.\n-/\ntheorem exists_lt_of_lt_csupᵢ [nonempty ι] {f : ι → α} (h : b < supᵢ f) : ∃ i, b < f i :=\n  let ⟨_, ⟨i, rfl⟩, h⟩ := exists_lt_of_lt_csupₛ (range_nonempty f) h\n  ⟨i, h⟩\n#align exists_lt_of_lt_csupr exists_lt_of_lt_csupᵢ\n-/\n\n",
 "exists_lt_of_cinfₛ_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print exists_lt_of_cinfₛ_lt /-\n/-- When Inf s < b, there is an element a in s with a < b, if s is nonempty and the order is\na linear order.-/\ntheorem exists_lt_of_cinfₛ_lt (hs : s.nonempty) (hb : infₛ s < b) : ∃ a ∈ s, a < b :=\n  @exists_lt_of_lt_csupₛ («expr ᵒᵈ» α) _ _ _ hs hb\n#align exists_lt_of_cInf_lt exists_lt_of_cinfₛ_lt\n-/\n\n",
 "exists_lt_of_cinfᵢ_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print exists_lt_of_cinfᵢ_lt /-\n/-- Indexed version of the above lemma `exists_lt_of_cInf_lt`\nWhen `infi f < a`, there is an element `i` such that `f i < a`.\n-/\ntheorem exists_lt_of_cinfᵢ_lt [nonempty ι] {f : ι → α} (h : infᵢ f < a) : ∃ i, f i < a :=\n  @exists_lt_of_lt_csupᵢ («expr ᵒᵈ» α) _ _ _ _ _ h\n#align exists_lt_of_cinfi_lt exists_lt_of_cinfᵢ_lt\n-/\n\n",
 "exists_between_of_forall_le":
 "#print exists_between_of_forall_le /-\n/-- If all elements of a nonempty set `s` are less than or equal to all elements\nof a nonempty set `t`, then there exists an element between these sets. -/\ntheorem exists_between_of_forall_le (sne : s.nonempty) (tne : t.nonempty) (hst : ∀ x ∈ s, ∀ y ∈ t, x ≤ y) :\n    (upperBounds s ∩ lowerBounds t).nonempty :=\n  ⟨infₛ t, fun x hx => le_cinfₛ tne <| hst x hx, fun y hy => cinfₛ_le (sne.mono hst) hy⟩\n#align exists_between_of_forall_le exists_between_of_forall_le\n-/\n\n",
 "csupₛ_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print csupₛ_union /-\n/-- The sup of a union of two sets is the max of the suprema of each subset, under the assumptions\nthat all sets are bounded above and nonempty.-/\ntheorem csupₛ_union (hs : BddAbove s) (sne : s.nonempty) (ht : BddAbove t) (tne : t.nonempty) :\n    supₛ (s ∪ t) = «expr ⊔ » (supₛ s) (supₛ t) :=\n  ((isLUB_csupₛ sne hs).union (isLUB_csupₛ tne ht)).cSup_eq sne.inl\n#align cSup_union csupₛ_union\n-/\n\n",
 "csupₛ_singleton":
 "#print csupₛ_singleton /-\n/-- The supremum of a singleton is the element of the singleton-/\n@[simp]\ntheorem csupₛ_singleton (a : α) : supₛ {a} = a :=\n  isGreatest_singleton.cSup_eq\n#align cSup_singleton csupₛ_singleton\n-/\n\n",
 "csupₛ_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print csupₛ_pair /-\n@[simp]\ntheorem csupₛ_pair (a b : α) : supₛ {a, b} = «expr ⊔ » a b :=\n  (@isLUB_pair _ _ a b).cSup_eq (insert_nonempty _ _)\n#align cSup_pair csupₛ_pair\n-/\n\n",
 "csupₛ_mem":
 "#print IsGreatest.csupₛ_mem /-\ntheorem IsGreatest.csupₛ_mem (H : IsGreatest s a) : supₛ s ∈ s :=\n  H.cSup_eq.symm ▸ H.1\n#align is_greatest.Sup_mem IsGreatest.csupₛ_mem\n-/\n\n",
 "csupₛ_lower_bounds_eq_cinfₛ":
 "#print csupₛ_lower_bounds_eq_cinfₛ /-\ntheorem csupₛ_lower_bounds_eq_cinfₛ {s : set α} (h : BddBelow s) (hs : s.nonempty) : supₛ (lowerBounds s) = infₛ s :=\n  (isLUB_csupₛ h <| hs.mono fun x hx y hy => hy hx).unique (isGLB_cinfₛ hs h).is_lub\n#align cSup_lower_bounds_eq_cInf csupₛ_lower_bounds_eq_cinfₛ\n-/\n\n",
 "csupₛ_le_iff'":
 "#print csupₛ_le_iff' /-\ntheorem csupₛ_le_iff' {s : set α} (hs : BddAbove s) {a : α} : supₛ s ≤ a ↔ ∀ x ∈ s, x ≤ a :=\n  isLUB_le_iff (isLUB_csupₛ' hs)\n#align cSup_le_iff' csupₛ_le_iff'\n-/\n\n",
 "csupₛ_le_iff":
 "#print csupₛ_le_iff /-\ntheorem csupₛ_le_iff (hb : BddAbove s) (hs : s.nonempty) : supₛ s ≤ a ↔ ∀ b ∈ s, b ≤ a :=\n  isLUB_le_iff (isLUB_csupₛ hs hb)\n#align cSup_le_iff csupₛ_le_iff\n-/\n\n",
 "csupₛ_le_csupₛ":
 "#print csupₛ_le_csupₛ /-\ntheorem csupₛ_le_csupₛ (ht : BddAbove t) (hs : s.nonempty) (h : s ⊆ t) : supₛ s ≤ supₛ t :=\n  csupₛ_le hs fun a ha => le_csupₛ ht (h ha)\n#align cSup_le_cSup csupₛ_le_csupₛ\n-/\n\n",
 "csupₛ_le'":
 "#print csupₛ_le' /-\ntheorem csupₛ_le' {s : set α} {a : α} (h : a ∈ upperBounds s) : supₛ s ≤ a :=\n  (csupₛ_le_iff' ⟨a, h⟩).2 h\n#align cSup_le' csupₛ_le'\n-/\n\n",
 "csupₛ_le":
 "#print csupₛ_le /-\ntheorem csupₛ_le (h₁ : s.nonempty) (h₂ : ∀ b ∈ s, b ≤ a) : supₛ s ≤ a :=\n  conditionally_complete_lattice.cSup_le s a h₁ h₂\n#align cSup_le csupₛ_le\n-/\n\n",
 "csupₛ_inter_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print csupₛ_inter_le /-\n/-- The supremum of an intersection of two sets is bounded by the minimum of the suprema of each\nset, if all sets are bounded above and nonempty.-/\ntheorem csupₛ_inter_le (hs : BddAbove s) (ht : BddAbove t) (hst : (s ∩ t).nonempty) :\n    supₛ (s ∩ t) ≤ «expr ⊓ » (supₛ s) (supₛ t) :=\n  csupₛ_le hst fun x hx => le_inf (le_csupₛ hs hx.1) (le_csupₛ ht hx.2)\n#align cSup_inter_le csupₛ_inter_le\n-/\n\n",
 "csupₛ_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print csupₛ_insert /-\n/-- The supremum of insert a s is the maximum of a and the supremum of s, if s is\nnonempty and bounded above.-/\ntheorem csupₛ_insert (hs : BddAbove s) (sne : s.nonempty) : supₛ (insert a s) = «expr ⊔ » a (supₛ s) :=\n  ((isLUB_csupₛ sne hs).insert a).cSup_eq (insert_nonempty a s)\n#align cSup_insert csupₛ_insert\n-/\n\n",
 "csupₛ_image2_eq_csupₛ_csupₛ":
 "#print csupₛ_image2_eq_csupₛ_csupₛ /-\ntheorem csupₛ_image2_eq_csupₛ_csupₛ (h₁ : ∀ b, GaloisConnection (swap l b) (u₁ b))\n    (h₂ : ∀ a, GaloisConnection (l a) (u₂ a)) (hs₀ : s.nonempty) (hs₁ : BddAbove s) (ht₀ : t.nonempty)\n    (ht₁ : BddAbove t) : supₛ (image2 l s t) = l (supₛ s) (supₛ t) :=\n  by\n  refine' eq_of_forall_ge_iff fun c => _\n  rw [csupₛ_le_iff (hs₁.image2 (fun _ => (h₁ _).monotone_l) (fun _ => (h₂ _).monotone_l) ht₁) (hs₀.image2 ht₀),\n    forall_image2_iff, forall₂_swap, (h₂ _).le_iff_le, csupₛ_le_iff ht₁ ht₀]\n  simp_rw [← (h₂ _).le_iff_le, (h₁ _).le_iff_le, csupₛ_le_iff hs₁ hs₀]\n#align cSup_image2_eq_cSup_cSup csupₛ_image2_eq_csupₛ_csupₛ\n-/\n\n",
 "csupₛ_image2_eq_csupₛ_cinfₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print csupₛ_image2_eq_csupₛ_cinfₛ /-\ntheorem csupₛ_image2_eq_csupₛ_cinfₛ (h₁ : ∀ b, GaloisConnection (swap l b) (u₁ b))\n    (h₂ : ∀ a, GaloisConnection (l a ∘ of_dual) (to_dual ∘ u₂ a)) :\n    s.nonempty → BddAbove s → t.nonempty → BddBelow t → supₛ (image2 l s t) = l (supₛ s) (infₛ t) :=\n  @csupₛ_image2_eq_csupₛ_csupₛ _ («expr ᵒᵈ» β) _ _ _ _ _ _ _ _ _ h₁ h₂\n#align cSup_image2_eq_cSup_cInf csupₛ_image2_eq_csupₛ_cinfₛ\n-/\n\n",
 "csupₛ_image2_eq_cinfₛ_csupₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print csupₛ_image2_eq_cinfₛ_csupₛ /-\ntheorem csupₛ_image2_eq_cinfₛ_csupₛ (h₁ : ∀ b, GaloisConnection (swap l b ∘ of_dual) (to_dual ∘ u₁ b))\n    (h₂ : ∀ a, GaloisConnection (l a) (u₂ a)) :\n    s.nonempty → BddBelow s → t.nonempty → BddAbove t → supₛ (image2 l s t) = l (infₛ s) (supₛ t) :=\n  @csupₛ_image2_eq_csupₛ_csupₛ («expr ᵒᵈ» α) _ _ _ _ _ _ _ _ _ _ h₁ h₂\n#align cSup_image2_eq_cInf_cSup csupₛ_image2_eq_cinfₛ_csupₛ\n-/\n\n",
 "csupₛ_image2_eq_cinfₛ_cinfₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print csupₛ_image2_eq_cinfₛ_cinfₛ /-\ntheorem csupₛ_image2_eq_cinfₛ_cinfₛ (h₁ : ∀ b, GaloisConnection (swap l b ∘ of_dual) (to_dual ∘ u₁ b))\n    (h₂ : ∀ a, GaloisConnection (l a ∘ of_dual) (to_dual ∘ u₂ a)) :\n    s.nonempty → BddBelow s → t.nonempty → BddBelow t → supₛ (image2 l s t) = l (infₛ s) (infₛ t) :=\n  @csupₛ_image2_eq_csupₛ_csupₛ («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ _ _ _ _ _ _ _ h₁ h₂\n#align cSup_image2_eq_cInf_cInf csupₛ_image2_eq_cinfₛ_cinfₛ\n-/\n\n",
 "csupₛ_eq_of_is_forall_le_of_forall_le_imp_ge":
 "#print csupₛ_eq_of_is_forall_le_of_forall_le_imp_ge /-\n/-- Introduction rule to prove that b is the supremum of s: it suffices to check that\n1) b is an upper bound\n2) every other upper bound b' satisfies b ≤ b'.-/\ntheorem csupₛ_eq_of_is_forall_le_of_forall_le_imp_ge (hs : s.nonempty) (h_is_ub : ∀ a ∈ s, a ≤ b)\n    (h_b_le_ub : ∀ ub, (∀ a ∈ s, a ≤ ub) → b ≤ ub) : supₛ s = b :=\n  (csupₛ_le hs h_is_ub).antisymm (h_b_le_ub _ fun a => le_csupₛ ⟨b, h_is_ub⟩)\n#align cSup_eq_of_is_forall_le_of_forall_le_imp_ge csupₛ_eq_of_is_forall_le_of_forall_le_imp_ge\n-/\n\n",
 "csupₛ_eq_of_forall_le_of_forall_lt_exists_gt":
 "#print csupₛ_eq_of_forall_le_of_forall_lt_exists_gt /-\n/-- Introduction rule to prove that `b` is the supremum of `s`: it suffices to check that `b`\nis larger than all elements of `s`, and that this is not the case of any `w<b`.\nSee `Sup_eq_of_forall_le_of_forall_lt_exists_gt` for a version in complete lattices. -/\ntheorem csupₛ_eq_of_forall_le_of_forall_lt_exists_gt (hs : s.nonempty) (H : ∀ a ∈ s, a ≤ b)\n    (H' : ∀ w, w < b → ∃ a ∈ s, w < a) : supₛ s = b :=\n  eq_of_le_of_not_lt (csupₛ_le hs H) fun hb =>\n    let ⟨a, ha, ha'⟩ := H' _ hb\n    lt_irrefl _ <| ha'.trans_le <| le_csupₛ ⟨b, H⟩ ha\n#align cSup_eq_of_forall_le_of_forall_lt_exists_gt csupₛ_eq_of_forall_le_of_forall_lt_exists_gt\n-/\n\n",
 "csupₛ_eq":
 "#print IsGreatest.csupₛ_eq /-\n/-- A greatest element of a set is the supremum of this set. -/\ntheorem IsGreatest.csupₛ_eq (H : IsGreatest s a) : supₛ s = a :=\n  H.is_lub.cSup_eq H.nonempty\n#align is_greatest.cSup_eq IsGreatest.csupₛ_eq\n-/\n\n",
 "csupₛ_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print csupₛ_empty /-\n@[simp]\ntheorem csupₛ_empty : (supₛ ∅ : α) = «expr⊥» :=\n  conditionally_complete_linear_order_bot.cSup_empty\n#align cSup_empty csupₛ_empty\n-/\n\n",
 "csupₛ_Ioo":
 "#print csupₛ_Ioo /-\n@[simp]\ntheorem csupₛ_Ioo [DenselyOrdered α] (h : a < b) : supₛ (Ioo a b) = b :=\n  (isLUB_Ioo h).cSup_eq (nonempty_Ioo.2 h)\n#align cSup_Ioo csupₛ_Ioo\n-/\n\n",
 "csupₛ_Ioc":
 "#print csupₛ_Ioc /-\n@[simp]\ntheorem csupₛ_Ioc (h : a < b) : supₛ (Ioc a b) = b :=\n  (isLUB_Ioc h).cSup_eq (nonempty_Ioc.2 h)\n#align cSup_Ioc csupₛ_Ioc\n-/\n\n",
 "csupₛ_Iio":
 "#print csupₛ_Iio /-\n@[simp]\ntheorem csupₛ_Iio [NoMinOrder α] [DenselyOrdered α] : supₛ (Iio a) = a :=\n  csupₛ_eq_of_forall_le_of_forall_lt_exists_gt nonempty_Iio (fun _ => le_of_lt) fun w hw => by\n    simpa [and_comm'] using exists_between hw\n#align cSup_Iio csupₛ_Iio\n-/\n\n",
 "csupₛ_Iic":
 "#print csupₛ_Iic /-\n@[simp]\ntheorem csupₛ_Iic : supₛ (Iic a) = a :=\n  isGreatest_Iic.cSup_eq\n#align cSup_Iic csupₛ_Iic\n-/\n\n",
 "csupₛ_Ico":
 "#print csupₛ_Ico /-\n@[simp]\ntheorem csupₛ_Ico [DenselyOrdered α] (h : a < b) : supₛ (Ico a b) = b :=\n  (isLUB_Ico h).cSup_eq (nonempty_Ico.2 h)\n#align cSup_Ico csupₛ_Ico\n-/\n\n",
 "csupₛ_Icc":
 "#print csupₛ_Icc /-\n@[simp]\ntheorem csupₛ_Icc (h : a ≤ b) : supₛ (Icc a b) = b :=\n  (isLUB_Icc h).cSup_eq (nonempty_Icc.2 h)\n#align cSup_Icc csupₛ_Icc\n-/\n\n",
 "csupᵢ_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print csupᵢ_unique /-\n@[simp]\ntheorem csupᵢ_unique [unique ι] {s : ι → α} :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s i) = s default :=\n  by\n  have : ∀ i, s i = s default := fun i => congr_arg s (unique.eq_default i)\n  simp only [this, csupᵢ_const]\n#align supr_unique csupᵢ_unique\n-/\n\n",
 "csupᵢ_set_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print csupᵢ_set_le_iff /-\ntheorem csupᵢ_set_le_iff {ι : Type _} {s : set ι} {f : ι → α} {a : α} (hs : s.nonempty)\n    (hf : BddAbove («expr '' » f s)) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) ≤ a ↔\n      ∀ i ∈ s, f i ≤ a :=\n  (isLUB_le_iff <| isLUB_csupᵢ_set hf hs).trans ball_image_iff\n#align csupr_set_le_iff csupᵢ_set_le_iff\n-/\n\n",
 "csupᵢ_set_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print IsLUB.csupᵢ_set_eq /-\ntheorem IsLUB.csupᵢ_set_eq {s : set β} {f : β → α} (H : IsLUB («expr '' » f s) a) (Hne : s.nonempty) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) = a :=\n  IsLUB.csupₛ_eq (image_eq_range f s ▸ H) (image_eq_range f s ▸ Hne.image f)\n#align is_lub.csupr_set_eq IsLUB.csupᵢ_set_eq\n-/\n\n",
 "csupᵢ_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print csupᵢ_pos /-\n@[simp]\ntheorem csupᵢ_pos {p : Prop} {f : p → α} (hp : p) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f h) = f hp :=\n  haveI := unique_prop hp\n  csupᵢ_unique\n#align csupr_pos csupᵢ_pos\n-/\n\n",
 "csupᵢ_of_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print csupᵢ_of_empty /-\n@[simp]\ntheorem csupᵢ_of_empty [is_empty ι] (f : ι → α) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) = «expr⊥» :=\n  by rw [supᵢ_of_empty', csupₛ_empty]\n#align csupr_of_empty csupᵢ_of_empty\n-/\n\n",
 "csupᵢ_mono'":
 "#print csupᵢ_mono' /-\ntheorem csupᵢ_mono' {ι'} {f : ι → α} {g : ι' → α} (hg : BddAbove (range g)) (h : ∀ i, ∃ i', f i ≤ g i') :\n    supᵢ f ≤ supᵢ g :=\n  csupᵢ_le' fun i => exists.elim (h i) (le_csupᵢ_of_le hg)\n#align csupr_mono' csupᵢ_mono'\n-/\n\n",
 "csupᵢ_mono":
 "#print csupᵢ_mono /-\n/-- The indexed supremum of two functions are comparable if the functions are pointwise comparable-/\ntheorem csupᵢ_mono {f g : ι → α} (B : BddAbove (range g)) (H : ∀ x, f x ≤ g x) : supᵢ f ≤ supᵢ g :=\n  by\n  cases isEmpty_or_nonempty ι\n  · rw [supᵢ_of_empty', supᵢ_of_empty']\n  · exact csupᵢ_le fun x => le_csupᵢ_of_le B x (H x)\n#align csupr_mono csupᵢ_mono\n-/\n\n",
 "csupᵢ_mem_Inter_Icc_of_antitone_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print csupᵢ_mem_Inter_Icc_of_antitone_Icc /-\n/-- Nested intervals lemma: if `[f n, g n]` is an antitone sequence of nonempty\nclosed intervals, then `⨆ n, f n` belongs to all the intervals `[f n, g n]`. -/\ntheorem csupᵢ_mem_Inter_Icc_of_antitone_Icc [SemilatticeSup β] {f g : β → α} (h : antitone fun n => Icc (f n) (g n))\n    (h' : ∀ n, f n ≤ g n) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f n) ∈\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (Icc (f n) (g n)) :=\n  Monotone.csupᵢ_mem_Inter_Icc_of_antitone (fun m n hmn => ((Icc_subset_Icc_iff (h' n)).1 (h hmn)).1)\n    (fun m n hmn => ((Icc_subset_Icc_iff (h' n)).1 (h hmn)).2) h'\n#align csupr_mem_Inter_Icc_of_antitone_Icc csupᵢ_mem_Inter_Icc_of_antitone_Icc\n-/\n\n",
 "csupᵢ_mem_Inter_Icc_of_antitone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print Monotone.csupᵢ_mem_Inter_Icc_of_antitone /-\n/-- Nested intervals lemma: if `f` is a monotone sequence, `g` is an antitone sequence, and\n`f n ≤ g n` for all `n`, then `⨆ n, f n` belongs to all the intervals `[f n, g n]`. -/\ntheorem Monotone.csupᵢ_mem_Inter_Icc_of_antitone [SemilatticeSup β] {f g : β → α} (hf : monotone f) (hg : antitone g)\n    (h : f ≤ g) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f n) ∈\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (Icc (f n) (g n)) :=\n  by\n  refine' mem_Inter.2 fun n => _\n  haveI : nonempty β := ⟨n⟩\n  have : ∀ m, f m ≤ g n := fun m => hf.forall_le_of_antitone hg h m n\n  exact ⟨le_csupᵢ ⟨g <| n, forall_range_iff.2 this⟩ _, csupᵢ_le this⟩\n#align monotone.csupr_mem_Inter_Icc_of_antitone Monotone.csupᵢ_mem_Inter_Icc_of_antitone\n-/\n\n",
 "csupᵢ_le_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print csupᵢ_le_iff' /-\ntheorem csupᵢ_le_iff' {f : ι → α} (h : BddAbove (range f)) {a : α} :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) ≤ a ↔\n      ∀ i, f i ≤ a :=\n  (csupₛ_le_iff' h).trans forall_range_iff\n#align csupr_le_iff' csupᵢ_le_iff'\n-/\n\n",
 "csupᵢ_le_iff":
 "#print csupᵢ_le_iff /-\ntheorem csupᵢ_le_iff [nonempty ι] {f : ι → α} {a : α} (hf : BddAbove (range f)) : supᵢ f ≤ a ↔ ∀ i, f i ≤ a :=\n  (isLUB_le_iff <| isLUB_csupᵢ hf).trans forall_range_iff\n#align csupr_le_iff csupᵢ_le_iff\n-/\n\n",
 "csupᵢ_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print csupᵢ_le' /-\ntheorem csupᵢ_le' {f : ι → α} {a : α} (h : ∀ i, f i ≤ a) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) ≤ a :=\n  csupₛ_le' <| forall_range_iff.2 h\n#align csupr_le' csupᵢ_le'\n-/\n\n",
 "csupᵢ_le":
 "#print csupᵢ_le /-\n/-- The indexed supremum of a function is bounded above by a uniform bound-/\ntheorem csupᵢ_le [nonempty ι] {f : ι → α} {c : α} (H : ∀ x, f x ≤ c) : supᵢ f ≤ c :=\n  csupₛ_le (range_nonempty f) (by rwa [forall_range_iff])\n#align csupr_le csupᵢ_le\n-/\n\n",
 "csupᵢ_false":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print csupᵢ_false /-\n@[simp]\ntheorem csupᵢ_false (f : false → α) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) = «expr⊥» :=\n  csupᵢ_of_empty f\n#align csupr_false csupᵢ_false\n-/\n\n",
 "csupᵢ_eq_of_forall_le_of_forall_lt_exists_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print csupᵢ_eq_of_forall_le_of_forall_lt_exists_gt /-\n/-- Introduction rule to prove that `b` is the supremum of `f`: it suffices to check that `b`\nis larger than `f i` for all `i`, and that this is not the case of any `w<b`.\nSee `supr_eq_of_forall_le_of_forall_lt_exists_gt` for a version in complete lattices. -/\ntheorem csupᵢ_eq_of_forall_le_of_forall_lt_exists_gt [nonempty ι] {f : ι → α} (h₁ : ∀ i, f i ≤ b)\n    (h₂ : ∀ w, w < b → ∃ i, w < f i) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) = b :=\n  csupₛ_eq_of_forall_le_of_forall_lt_exists_gt (range_nonempty f) (forall_range_iff.mpr h₁) fun w hw =>\n    exists_range_iff.mpr <| h₂ w hw\n#align csupr_eq_of_forall_le_of_forall_lt_exists_gt csupᵢ_eq_of_forall_le_of_forall_lt_exists_gt\n-/\n\n",
 "csupᵢ_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print IsLUB.csupᵢ_eq /-\ntheorem IsLUB.csupᵢ_eq [nonempty ι] {f : ι → α} (H : IsLUB (range f) a) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) = a :=\n  H.cSup_eq (range_nonempty f)\n#align is_lub.csupr_eq IsLUB.csupᵢ_eq\n-/\n\n",
 "csupᵢ_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print csupᵢ_const /-\n@[simp]\ntheorem csupᵢ_const [hι : nonempty ι] {a : α} :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" a = a := by\n  rw [supᵢ, range_const, csupₛ_singleton]\n#align csupr_const csupᵢ_const\n-/\n\n",
 "coe_supₛ'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print WithBot.coe_supₛ' /-\n@[norm_cast]\ntheorem WithBot.coe_supₛ' [SupSet α] {s : set α} (hs : s.nonempty) :\n    ↑(supₛ s) = (supₛ («expr '' » coe s) : WithBot α) :=\n  @WithTop.coe_infₛ' («expr ᵒᵈ» α) _ _ hs\n#align with_bot.coe_Sup' WithBot.coe_supₛ'\n-/\n\n",
 "coe_supᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print WithBot.coe_supᵢ /-\n@[norm_cast]\ntheorem WithBot.coe_supᵢ [nonempty ι] [SupSet α] (f : ι → α) :\n    ↑(«expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) =\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) :\n        WithBot α) :=\n  @WithTop.coe_infᵢ («expr ᵒᵈ» α) _ _ _ _\n#align with_bot.coe_supr WithBot.coe_supᵢ\n-/\n\n",
 "coe_infₛ'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print WithBot.coe_infₛ' /-\n@[norm_cast]\ntheorem WithBot.coe_infₛ' [preorder α] [InfSet α] {s : set α} (hs : BddBelow s) :\n    ↑(infₛ s) = (infₛ («expr '' » coe s) : WithBot α) :=\n  @WithTop.coe_supₛ' («expr ᵒᵈ» α) _ _ _ hs\n#align with_bot.coe_Inf' WithBot.coe_infₛ'\n-/\n\n",
 "coe_infᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print WithBot.coe_infᵢ /-\n@[norm_cast]\ntheorem WithBot.coe_infᵢ [preorder α] [InfSet α] (f : ι → α) (h : BddBelow (Set.range f)) :\n    ↑(«expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)) =\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i) :\n        WithBot α) :=\n  @WithTop.coe_supᵢ («expr ᵒᵈ» α) _ _ _ _ h\n#align with_bot.coe_infi WithBot.coe_infᵢ\n-/\n\n",
 "coe_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- A version of `with_top.coe_Sup'` with a more convenient but less general statement. -/\n@[norm_cast]\ntheorem coe_Sup {s : set α} (hb : BddAbove s) :\n    ↑(supₛ s) =\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ↑a :\n        WithTop α) :=\n  by rw [coe_Sup' hb, supₛ_image]\n#align coe_Sup coe_Sup\n\n",
 "coe_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- A version of `with_top.coe_Inf'` with a more convenient but less general statement. -/\n@[norm_cast]\ntheorem coe_Inf {s : set α} (hs : s.nonempty) :\n    ↑(infₛ s) =\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ↑a :\n        WithTop α) :=\n  by rw [coe_Inf' hs, infₛ_image]\n#align coe_Inf coe_Inf\n\n",
 "cinfₛ_upper_bounds_eq_csupₛ":
 "#print cinfₛ_upper_bounds_eq_csupₛ /-\ntheorem cinfₛ_upper_bounds_eq_csupₛ {s : set α} (h : BddAbove s) (hs : s.nonempty) : infₛ (upperBounds s) = supₛ s :=\n  (isGLB_cinfₛ h <| hs.mono fun x hx y hy => hy hx).unique (isLUB_csupₛ hs h).is_glb\n#align cInf_upper_bounds_eq_cSup cinfₛ_upper_bounds_eq_csupₛ\n-/\n\n",
 "cinfₛ_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print cinfₛ_univ /-\n@[simp]\ntheorem cinfₛ_univ : infₛ (univ : set α) = «expr⊥» :=\n  isLeast_univ.cInf_eq\n#align cInf_univ cinfₛ_univ\n-/\n\n",
 "cinfₛ_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print cinfₛ_union /-\n/-- The inf of a union of two sets is the min of the infima of each subset, under the assumptions\nthat all sets are bounded below and nonempty.-/\ntheorem cinfₛ_union (hs : BddBelow s) (sne : s.nonempty) (ht : BddBelow t) (tne : t.nonempty) :\n    infₛ (s ∪ t) = «expr ⊓ » (infₛ s) (infₛ t) :=\n  @csupₛ_union («expr ᵒᵈ» α) _ _ _ hs sne ht tne\n#align cInf_union cinfₛ_union\n-/\n\n",
 "cinfₛ_singleton":
 "#print cinfₛ_singleton /-\n/-- The infimum of a singleton is the element of the singleton-/\n@[simp]\ntheorem cinfₛ_singleton (a : α) : infₛ {a} = a :=\n  isLeast_singleton.cInf_eq\n#align cInf_singleton cinfₛ_singleton\n-/\n\n",
 "cinfₛ_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print cinfₛ_pair /-\n@[simp]\ntheorem cinfₛ_pair (a b : α) : infₛ {a, b} = «expr ⊓ » a b :=\n  (@isGLB_pair _ _ a b).cInf_eq (insert_nonempty _ _)\n#align cInf_pair cinfₛ_pair\n-/\n\n",
 "cinfₛ_mem":
 "#print cinfₛ_mem /-\ntheorem cinfₛ_mem (hs : s.nonempty) : infₛ s ∈ s :=\n  (isLeast_cinfₛ hs).1\n#align Inf_mem cinfₛ_mem\n-/\n\n",
 "cinfₛ_lt_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print cinfₛ_lt_of_lt /-\n/-- Inf s < b when there is an element a in s with a < b, when s is bounded below.\nThis is essentially an iff, except that the assumptions for the two implications are\nslightly different (one needs boundedness below for one direction, nonemptiness and linear\norder for the other one), so we formulate separately the two implications, contrary to\nthe complete_lattice case.-/\ntheorem cinfₛ_lt_of_lt : BddBelow s → a ∈ s → a < b → infₛ s < b :=\n  @lt_csupₛ_of_lt («expr ᵒᵈ» α) _ _ _ _\n#align cInf_lt_of_lt cinfₛ_lt_of_lt\n-/\n\n",
 "cinfₛ_le_of_le":
 "#print cinfₛ_le_of_le /-\ntheorem cinfₛ_le_of_le (hs : BddBelow s) (hb : b ∈ s) (h : b ≤ a) : infₛ s ≤ a :=\n  le_trans (cinfₛ_le hs hb) h\n#align cInf_le_of_le cinfₛ_le_of_le\n-/\n\n",
 "cinfₛ_le_iff":
 "#print cinfₛ_le_iff /-\ntheorem cinfₛ_le_iff (h : BddBelow s) (hs : s.nonempty) : infₛ s ≤ a ↔ ∀ b ∈ lowerBounds s, b ≤ a :=\n  ⟨fun h b hb => le_trans (le_cinfₛ hs hb) h, fun hb => hb _ fun x => cinfₛ_le h⟩\n#align cInf_le_iff cinfₛ_le_iff\n-/\n\n",
 "cinfₛ_le_csupₛ":
 "#print cinfₛ_le_csupₛ /-\n/-- If a set is bounded below and above, and nonempty, its infimum is less than or equal to\nits supremum.-/\ntheorem cinfₛ_le_csupₛ (hb : BddBelow s) (ha : BddAbove s) (ne : s.nonempty) : infₛ s ≤ supₛ s :=\n  isGLB_le_isLUB (isGLB_cinfₛ ne hb) (isLUB_csupₛ ne ha) ne\n#align cInf_le_cSup cinfₛ_le_csupₛ\n-/\n\n",
 "cinfₛ_le_cinfₛ'":
 "#print cinfₛ_le_cinfₛ' /-\ntheorem cinfₛ_le_cinfₛ' {s t : set α} (h₁ : t.nonempty) (h₂ : t ⊆ s) : infₛ s ≤ infₛ t :=\n  cinfₛ_le_cinfₛ (OrderBot.bddBelow s) h₁ h₂\n#align cInf_le_cInf' cinfₛ_le_cinfₛ'\n-/\n\n",
 "cinfₛ_le_cinfₛ":
 "#print cinfₛ_le_cinfₛ /-\ntheorem cinfₛ_le_cinfₛ (ht : BddBelow t) (hs : s.nonempty) (h : s ⊆ t) : infₛ t ≤ infₛ s :=\n  le_cinfₛ hs fun a ha => cinfₛ_le ht (h ha)\n#align cInf_le_cInf cinfₛ_le_cinfₛ\n-/\n\n",
 "cinfₛ_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print cinfₛ_le' /-\ntheorem cinfₛ_le' {s : set α} {a : α} (h : a ∈ s) : infₛ s ≤ a :=\n  cinfₛ_le ⟨«expr⊥», fun a _ => bot_le⟩ h\n#align cInf_le' cinfₛ_le'\n-/\n\n",
 "cinfₛ_le":
 "#print cinfₛ_le /-\ntheorem cinfₛ_le (h₁ : BddBelow s) (h₂ : a ∈ s) : infₛ s ≤ a :=\n  conditionally_complete_lattice.cInf_le s a h₁ h₂\n#align cInf_le cinfₛ_le\n-/\n\n",
 "cinfₛ_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print cinfₛ_insert /-\n/-- The infimum of insert a s is the minimum of a and the infimum of s, if s is\nnonempty and bounded below.-/\ntheorem cinfₛ_insert (hs : BddBelow s) (sne : s.nonempty) : infₛ (insert a s) = «expr ⊓ » a (infₛ s) :=\n  @csupₛ_insert («expr ᵒᵈ» α) _ _ _ hs sne\n#align cInf_insert cinfₛ_insert\n-/\n\n",
 "cinfₛ_image2_eq_csupₛ_csupₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print cinfₛ_image2_eq_csupₛ_csupₛ /-\ntheorem cinfₛ_image2_eq_csupₛ_csupₛ (h₁ : ∀ b, GaloisConnection (to_dual ∘ l₁ b) (swap u b ∘ of_dual))\n    (h₂ : ∀ a, GaloisConnection (to_dual ∘ l₂ a) (u a ∘ of_dual)) :\n    s.nonempty → BddAbove s → t.nonempty → BddAbove t → infₛ (image2 u s t) = u (supₛ s) (supₛ t) :=\n  @cinfₛ_image2_eq_cinfₛ_cinfₛ («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ _ _ _ _ _ _ _ h₁ h₂\n#align cInf_image2_eq_cSup_cSup cinfₛ_image2_eq_csupₛ_csupₛ\n-/\n\n",
 "cinfₛ_image2_eq_csupₛ_cinfₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print cinfₛ_image2_eq_csupₛ_cinfₛ /-\ntheorem cinfₛ_image2_eq_csupₛ_cinfₛ (h₁ : ∀ b, GaloisConnection (to_dual ∘ l₁ b) (swap u b ∘ of_dual))\n    (h₂ : ∀ a, GaloisConnection (l₂ a) (u a)) :\n    s.nonempty → BddAbove s → t.nonempty → BddBelow t → infₛ (image2 u s t) = u (supₛ s) (infₛ t) :=\n  @cinfₛ_image2_eq_cinfₛ_cinfₛ («expr ᵒᵈ» α) _ _ _ _ _ _ _ _ _ _ h₁ h₂\n#align cInf_image2_eq_cSup_cInf cinfₛ_image2_eq_csupₛ_cinfₛ\n-/\n\n",
 "cinfₛ_image2_eq_cinfₛ_csupₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print cinfₛ_image2_eq_cinfₛ_csupₛ /-\ntheorem cinfₛ_image2_eq_cinfₛ_csupₛ (h₁ : ∀ b, GaloisConnection (l₁ b) (swap u b))\n    (h₂ : ∀ a, GaloisConnection (to_dual ∘ l₂ a) (u a ∘ of_dual)) :\n    s.nonempty → BddBelow s → t.nonempty → BddAbove t → infₛ (image2 u s t) = u (infₛ s) (supₛ t) :=\n  @cinfₛ_image2_eq_cinfₛ_cinfₛ _ («expr ᵒᵈ» β) _ _ _ _ _ _ _ _ _ h₁ h₂\n#align cInf_image2_eq_cInf_cSup cinfₛ_image2_eq_cinfₛ_csupₛ\n-/\n\n",
 "cinfₛ_image2_eq_cinfₛ_cinfₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print cinfₛ_image2_eq_cinfₛ_cinfₛ /-\ntheorem cinfₛ_image2_eq_cinfₛ_cinfₛ (h₁ : ∀ b, GaloisConnection (l₁ b) (swap u b))\n    (h₂ : ∀ a, GaloisConnection (l₂ a) (u a)) :\n    s.nonempty → BddBelow s → t.nonempty → BddBelow t → infₛ (image2 u s t) = u (infₛ s) (infₛ t) :=\n  @csupₛ_image2_eq_csupₛ_csupₛ («expr ᵒᵈ» α) («expr ᵒᵈ» β) («expr ᵒᵈ» γ) _ _ _ _ _ _ l₁ l₂ (fun _ => (h₁ _).dual)\n    fun _ => (h₂ _).dual\n#align cInf_image2_eq_cInf_cInf cinfₛ_image2_eq_cinfₛ_cinfₛ\n-/\n\n",
 "cinfₛ_eq_of_forall_ge_of_forall_gt_exists_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print cinfₛ_eq_of_forall_ge_of_forall_gt_exists_lt /-\n/-- Introduction rule to prove that `b` is the infimum of `s`: it suffices to check that `b`\nis smaller than all elements of `s`, and that this is not the case of any `w>b`.\nSee `Inf_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in complete lattices. -/\ntheorem cinfₛ_eq_of_forall_ge_of_forall_gt_exists_lt :\n    s.nonempty → (∀ a ∈ s, b ≤ a) → (∀ w, b < w → ∃ a ∈ s, a < w) → infₛ s = b :=\n  @csupₛ_eq_of_forall_le_of_forall_lt_exists_gt («expr ᵒᵈ» α) _ _ _\n#align cInf_eq_of_forall_ge_of_forall_gt_exists_lt cinfₛ_eq_of_forall_ge_of_forall_gt_exists_lt\n-/\n\n",
 "cinfₛ_eq":
 "#print IsLeast.cinfₛ_eq /-\n/-- A least element of a set is the infimum of this set. -/\ntheorem IsLeast.cinfₛ_eq (H : IsLeast s a) : infₛ s = a :=\n  H.is_glb.cInf_eq H.nonempty\n#align is_least.cInf_eq IsLeast.cinfₛ_eq\n-/\n\n",
 "cinfₛ_Ioo":
 "#print cinfₛ_Ioo /-\n@[simp]\ntheorem cinfₛ_Ioo [DenselyOrdered α] (h : a < b) : infₛ (Ioo a b) = a :=\n  (isGLB_Ioo h).cInf_eq (nonempty_Ioo.2 h)\n#align cInf_Ioo cinfₛ_Ioo\n-/\n\n",
 "cinfₛ_Ioi":
 "#print cinfₛ_Ioi /-\n@[simp]\ntheorem cinfₛ_Ioi [NoMaxOrder α] [DenselyOrdered α] : infₛ (Ioi a) = a :=\n  cinfₛ_eq_of_forall_ge_of_forall_gt_exists_lt nonempty_Ioi (fun _ => le_of_lt) fun w hw => by\n    simpa using exists_between hw\n#align cInf_Ioi cinfₛ_Ioi\n-/\n\n",
 "cinfₛ_Ioc":
 "#print cinfₛ_Ioc /-\n@[simp]\ntheorem cinfₛ_Ioc [DenselyOrdered α] (h : a < b) : infₛ (Ioc a b) = a :=\n  (isGLB_Ioc h).cInf_eq (nonempty_Ioc.2 h)\n#align cInf_Ioc cinfₛ_Ioc\n-/\n\n",
 "cinfₛ_Ico":
 "#print cinfₛ_Ico /-\n@[simp]\ntheorem cinfₛ_Ico (h : a < b) : infₛ (Ico a b) = a :=\n  (isGLB_Ico h).cInf_eq (nonempty_Ico.2 h)\n#align cInf_Ico cinfₛ_Ico\n-/\n\n",
 "cinfₛ_Ici":
 "#print cinfₛ_Ici /-\n@[simp]\ntheorem cinfₛ_Ici : infₛ (Ici a) = a :=\n  isLeast_Ici.cInf_eq\n#align cInf_Ici cinfₛ_Ici\n-/\n\n",
 "cinfₛ_Icc":
 "#print cinfₛ_Icc /-\n@[simp]\ntheorem cinfₛ_Icc (h : a ≤ b) : infₛ (Icc a b) = a :=\n  (isGLB_Icc h).cInf_eq (nonempty_Icc.2 h)\n#align cInf_Icc cinfₛ_Icc\n-/\n\n",
 "cinfᵢ_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print cinfᵢ_unique /-\n@[simp]\ntheorem cinfᵢ_unique [unique ι] {s : ι → α} :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (s i) = s default :=\n  @csupᵢ_unique («expr ᵒᵈ» α) _ _ _ _\n#align infi_unique cinfᵢ_unique\n-/\n\n",
 "cinfᵢ_set_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print cinfᵢ_set_le /-\ntheorem cinfᵢ_set_le {f : β → α} {s : set β} (H : BddBelow («expr '' » f s)) {c : β} (hc : c ∈ s) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i) ≤ f c :=\n  @le_csupᵢ_set («expr ᵒᵈ» α) _ _ _ _ H _ hc\n#align cinfi_set_le cinfᵢ_set_le\n-/\n\n",
 "cinfᵢ_set_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print IsGLB.cinfᵢ_set_eq /-\ntheorem IsGLB.cinfᵢ_set_eq {s : set β} {f : β → α} (H : IsGLB («expr '' » f s) a) (Hne : s.nonempty) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i) = a :=\n  IsGLB.cinfₛ_eq (image_eq_range f s ▸ H) (image_eq_range f s ▸ Hne.image f)\n#align is_glb.cinfi_set_eq IsGLB.cinfᵢ_set_eq\n-/\n\n",
 "cinfᵢ_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print cinfᵢ_pos /-\n@[simp]\ntheorem cinfᵢ_pos {p : Prop} {f : p → α} (hp : p) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f h) = f hp :=\n  @csupᵢ_pos («expr ᵒᵈ» α) _ _ _ hp\n#align cinfi_pos cinfᵢ_pos\n-/\n\n",
 "cinfᵢ_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print cinfᵢ_mono /-\n/-- The indexed infimum of two functions are comparable if the functions are pointwise comparable-/\ntheorem cinfᵢ_mono {f g : ι → α} (B : BddBelow (range f)) (H : ∀ x, f x ≤ g x) : infᵢ f ≤ infᵢ g :=\n  @csupᵢ_mono («expr ᵒᵈ» α) _ _ _ _ B H\n#align cinfi_mono cinfᵢ_mono\n-/\n\n",
 "cinfᵢ_mem":
 "#print cinfᵢ_mem /-\ntheorem cinfᵢ_mem [nonempty ι] (f : ι → α) : infᵢ f ∈ range f :=\n  cinfₛ_mem (range_nonempty f)\n#align infi_mem cinfᵢ_mem\n-/\n\n",
 "cinfᵢ_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print cinfᵢ_le_of_le /-\ntheorem cinfᵢ_le_of_le {f : ι → α} (H : BddBelow (range f)) (c : ι) (h : f c ≤ a) : infᵢ f ≤ a :=\n  @le_csupᵢ_of_le («expr ᵒᵈ» α) _ _ _ _ H c h\n#align cinfi_le_of_le cinfᵢ_le_of_le\n-/\n\n",
 "cinfᵢ_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print cinfᵢ_le' /-\ntheorem cinfᵢ_le' (f : ι → α) (i : ι) : infᵢ f ≤ f i :=\n  cinfᵢ_le ⟨«expr⊥», fun a _ => bot_le⟩ _\n#align cinfi_le' cinfᵢ_le'\n-/\n\n",
 "cinfᵢ_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print cinfᵢ_le /-\n/-- The indexed infimum of a function is bounded above by the value taken at one point-/\ntheorem cinfᵢ_le {f : ι → α} (H : BddBelow (range f)) (c : ι) : infᵢ f ≤ f c :=\n  @le_csupᵢ («expr ᵒᵈ» α) _ _ _ H c\n#align cinfi_le cinfᵢ_le\n-/\n\n",
 "cinfᵢ_eq_of_forall_ge_of_forall_gt_exists_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print cinfᵢ_eq_of_forall_ge_of_forall_gt_exists_lt /-\n/-- Introduction rule to prove that `b` is the infimum of `f`: it suffices to check that `b`\nis smaller than `f i` for all `i`, and that this is not the case of any `w>b`.\nSee `infi_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in complete lattices. -/\ntheorem cinfᵢ_eq_of_forall_ge_of_forall_gt_exists_lt [nonempty ι] {f : ι → α} (h₁ : ∀ i, b ≤ f i)\n    (h₂ : ∀ w, b < w → ∃ i, f i < w) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i) = b :=\n  @csupᵢ_eq_of_forall_le_of_forall_lt_exists_gt («expr ᵒᵈ» α) _ _ _ _ ‹_› ‹_› ‹_›\n#align cinfi_eq_of_forall_ge_of_forall_gt_exists_lt cinfᵢ_eq_of_forall_ge_of_forall_gt_exists_lt\n-/\n\n",
 "cinfᵢ_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print IsGLB.cinfᵢ_eq /-\ntheorem IsGLB.cinfᵢ_eq [nonempty ι] {f : ι → α} (H : IsGLB (range f) a) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i) = a :=\n  H.cInf_eq (range_nonempty f)\n#align is_glb.cinfi_eq IsGLB.cinfᵢ_eq\n-/\n\n",
 "cinfᵢ_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print cinfᵢ_const /-\n@[simp]\ntheorem cinfᵢ_const [hι : nonempty ι] {a : α} :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" a = a :=\n  @csupᵢ_const («expr ᵒᵈ» α) _ _ _ _\n#align cinfi_const cinfᵢ_const\n-/\n\n",
 "cSup_image_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem cSup_image_le {s : set α} (hs : s.nonempty) {B : α} (hB : B ∈ upperBounds s) : supₛ («expr '' » f s) ≤ f B :=\n  csupₛ_le (Nonempty.image f hs) (h_mono.mem_upper_bounds_image hB)\n#align cSup_image_le cSup_image_le\n\n",
 "cInf_image_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem cInf_image_le {s : set α} {c : α} (hcs : c ∈ s) (h_bdd : BddBelow s) : infₛ («expr '' » f s) ≤ f c :=\n  @le_csupₛ_image («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ _ (fun x y hxy => h_mono hxy) _ _ hcs h_bdd\n#align cInf_image_le cInf_image_le\n\n"}