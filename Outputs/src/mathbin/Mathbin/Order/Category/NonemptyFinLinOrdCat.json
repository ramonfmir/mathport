{"mono_iff_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mono_iff_injective {A B : NonemptyFinLinOrd.{u}} (f : «expr ⟶ » A B) : Mono f ↔ function.injective f :=\n  by\n  refine' ⟨_, concrete_category.mono_of_injective f⟩\n  intro\n  intro a₁ a₂ h\n  let X : NonemptyFinLinOrd.{u} := ⟨ULift (fin 1)⟩\n  let g₁ : «expr ⟶ » X A := ⟨fun x => a₁, fun x₁ x₂ h => by rfl⟩\n  let g₂ : «expr ⟶ » X A := ⟨fun x => a₂, fun x₁ x₂ h => by rfl⟩\n  change g₁ (ulift.up (0 : fin 1)) = g₂ (ulift.up (0 : fin 1))\n  have eq : «expr ≫ » g₁ f = «expr ≫ » g₂ f := by\n    ext x\n    exact h\n  rw [cancel_mono] at eq\n  rw [eq]\n#align mono_iff_injective mono_iff_injective\n\n",
 "epi_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem epi_iff_surjective {A B : NonemptyFinLinOrd.{u}} (f : «expr ⟶ » A B) : Epi f ↔ function.surjective f :=\n  by\n  constructor\n  · intro\n    by_contra' hf'\n    rcases hf' with ⟨m, hm⟩\n    let Y : NonemptyFinLinOrd.{u} := ⟨ULift (fin 2)⟩\n    let p₁ : «expr ⟶ » B Y :=\n      ⟨fun b => if b < m then ulift.up 0 else ulift.up 1, fun x₁ x₂ h =>\n        by\n        simp only\n        split_ifs with h₁ h₂ h₂\n        any_goals apply Fin.zero_le\n        · exfalso\n          exact h₁ (lt_of_le_of_lt h h₂)\n        · rfl⟩\n    let p₂ : «expr ⟶ » B Y :=\n      ⟨fun b => if b ≤ m then ulift.up 0 else ulift.up 1, fun x₁ x₂ h =>\n        by\n        simp only\n        split_ifs with h₁ h₂ h₂\n        any_goals apply Fin.zero_le\n        · exfalso\n          exact h₁ (h.trans h₂)\n        · rfl⟩\n    have h : p₁ m = p₂ m := by\n      congr\n      rw [← cancel_epi f]\n      ext a : 2\n      simp only [comp_apply, OrderHom.coe_fun_mk]\n      split_ifs with h₁ h₂ h₂\n      any_goals rfl\n      · exfalso\n        exact h₂ (le_of_lt h₁)\n      · exfalso\n        exact hm a (eq_of_le_of_not_lt h₂ h₁)\n    simpa only [OrderHom.coe_fun_mk, lt_self_iff_false, if_false, le_refl, if_true, ULift.up_inj, Fin.one_eq_zero_iff,\n      Nat.succ_succ_ne_one] using h\n  · intro h\n    exact concrete_category.epi_of_surjective f h\n#align epi_iff_surjective epi_iff_surjective\n\n",
 "coe_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\n@[simp]\ntheorem coe_of (α : Type _) [nonempty_fin_lin_ord α] : «expr↥ » (of α) = α :=\n  rfl\n#align coe_of coe_of\n\n",
 "NonemptyFinLinOrd_dual_comp_forget_to_LinearOrder":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem NonemptyFinLinOrd_dual_comp_forget_to_LinearOrder :\n    «expr ⋙ » NonemptyFinLinOrd.dual (forget₂ NonemptyFinLinOrd LinearOrder) =\n      «expr ⋙ » (forget₂ NonemptyFinLinOrd LinearOrder) LinearOrder.dual :=\n  rfl\n#align NonemptyFinLinOrd_dual_comp_forget_to_LinearOrder NonemptyFinLinOrd_dual_comp_forget_to_LinearOrder\n\n"}