{"supₛ_within_of_ordConnected":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print supₛ_within_of_ordConnected /-\n-- The following would be a more natural way to finish, but gives a \"deep recursion\" error:\n-- simpa [subset_Sup_of_within (h_Sup t)] using\n--   (strict_mono_coe s).monotone.le_cSup_image hct h_bdd,\n/-- The `Sup` function on a nonempty `ord_connected` set `s` in a conditionally complete linear\norder takes values within `s`, for all nonempty bounded-above subsets of `s`. -/\ntheorem supₛ_within_of_ordConnected {s : Set α} [hs : OrdConnected s] ⦃t : Set s⦄ (ht : t.nonempty)\n    (h_bdd : BddAbove t) : supₛ («expr '' » coe t : Set α) ∈ s :=\n  by\n  obtain ⟨c, hct⟩ : ∃ c, c ∈ t := ht\n  obtain ⟨B, hB⟩ : ∃ B, B ∈ upperBounds t := h_bdd\n  refine' hs.out c.2 B.2 ⟨_, _⟩\n  · exact (Subtype.mono_coe s).le_cSup_image hct ⟨B, hB⟩\n  · exact (Subtype.mono_coe s).cSup_image_le ⟨c, hct⟩ hB\n#align Sup_within_of_ord_connected supₛ_within_of_ordConnected\n-/\n\n",
 "subset_supₛ_of_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print subset_supₛ_of_within /-\ntheorem subset_supₛ_of_within [Inhabited s] {t : Set s} (h : supₛ («expr '' » coe t : Set α) ∈ s) :\n    supₛ («expr '' » coe t : Set α) = (@supₛ s _ t : α) := by simp [dif_pos h]\n#align subset_Sup_of_within subset_supₛ_of_within\n-/\n\n",
 "subset_supₛ_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print subset_supₛ_def /-\n/-\nCopyright (c) 2022 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\n@[simp]\ntheorem subset_supₛ_def [Inhabited s] :\n    @supₛ s _ = fun t =>\n      if ht : supₛ («expr '' » coe t : Set α) ∈ s then ⟨supₛ («expr '' » coe t : Set α), ht⟩ else default :=\n  rfl\n#align subset_Sup_def subset_supₛ_def\n-/\n\n",
 "subset_infₛ_of_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print subset_infₛ_of_within /-\ntheorem subset_infₛ_of_within [Inhabited s] {t : Set s} (h : infₛ («expr '' » coe t : Set α) ∈ s) :\n    infₛ («expr '' » coe t : Set α) = (@infₛ s _ t : α) := by simp [dif_pos h]\n#align subset_Inf_of_within subset_infₛ_of_within\n-/\n\n",
 "subset_infₛ_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print subset_infₛ_def /-\n@[simp]\ntheorem subset_infₛ_def [Inhabited s] :\n    @infₛ s _ = fun t =>\n      if ht : infₛ («expr '' » coe t : Set α) ∈ s then ⟨infₛ («expr '' » coe t : Set α), ht⟩ else default :=\n  rfl\n#align subset_Inf_def subset_infₛ_def\n-/\n\n",
 "infₛ_within_of_ordConnected":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print infₛ_within_of_ordConnected /-\n/-- The `Inf` function on a nonempty `ord_connected` set `s` in a conditionally complete linear\norder takes values within `s`, for all nonempty bounded-below subsets of `s`. -/\ntheorem infₛ_within_of_ordConnected {s : Set α} [hs : OrdConnected s] ⦃t : Set s⦄ (ht : t.nonempty)\n    (h_bdd : BddBelow t) : infₛ («expr '' » coe t : Set α) ∈ s :=\n  by\n  obtain ⟨c, hct⟩ : ∃ c, c ∈ t := ht\n  obtain ⟨B, hB⟩ : ∃ B, B ∈ lowerBounds t := h_bdd\n  refine' hs.out B.2 c.2 ⟨_, _⟩\n  · exact (Subtype.mono_coe s).le_cInf_image ⟨c, hct⟩ hB\n  · exact (Subtype.mono_coe s).cInf_image_le hct ⟨B, hB⟩\n#align Inf_within_of_ord_connected infₛ_within_of_ordConnected\n-/\n\n"}