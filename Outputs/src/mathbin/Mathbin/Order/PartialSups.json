{"supr_partial_sups_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem supr_partial_sups_eq (f : ℕ → α) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (partial_sups f n) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f n) :=\n  csupr_partial_sups_eq <| OrderTop.bddAbove _\n#align supr_partial_sups_eq supr_partial_sups_eq\n\n",
 "supr_le_supr_of_partial_sups_le_partial_sups":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_le_supr_of_partial_sups_le_partial_sups {f g : ℕ → α} (h : partial_sups f ≤ partial_sups g) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f n) ≤\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (g n) :=\n  by\n  rw [← supr_partial_sups_eq f, ← supr_partial_sups_eq g]\n  exact supᵢ_mono h\n#align supr_le_supr_of_partial_sups_le_partial_sups supr_le_supr_of_partial_sups_le_partial_sups\n\n",
 "supr_eq_supr_of_partial_sups_eq_partial_sups":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_eq_supr_of_partial_sups_eq_partial_sups {f g : ℕ → α} (h : partial_sups f = partial_sups g) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f n) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (g n) :=\n  by simp_rw [← supr_partial_sups_eq f, ← supr_partial_sups_eq g, h]\n#align supr_eq_supr_of_partial_sups_eq_partial_sups supr_eq_supr_of_partial_sups_eq_partial_sups\n\n",
 "partial_sups_zero":
 "/-\nCopyright (c) 2021 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n@[simp]\ntheorem partial_sups_zero (f : ℕ → α) : partial_sups f 0 = f 0 :=\n  rfl\n#align partial_sups_zero partial_sups_zero\n\n",
 "partial_sups_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem partial_sups_succ (f : ℕ → α) (n : ℕ) : partial_sups f (n + 1) = «expr ⊔ » (partial_sups f n) (f (n + 1)) :=\n  rfl\n#align partial_sups_succ partial_sups_succ\n\n",
 "partial_sups_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\ntheorem partial_sups_mono : monotone (partial_sups : (ℕ → α) → «expr →o » ℕ α) :=\n  by\n  rintro f g h n\n  induction' n with n ih\n  · exact h 0\n  · exact sup_le_sup ih (h _)\n#align partial_sups_mono partial_sups_mono\n\n",
 "partial_sups_le":
 "theorem partial_sups_le (f : ℕ → α) (n : ℕ) (a : α) (w : ∀ m, m ≤ n → f m ≤ a) : partial_sups f n ≤ a :=\n  by\n  induction' n with n ih\n  · apply w 0 le_rfl\n  · exact sup_le (ih fun m p => w m (nat.le_succ_of_le p)) (w (n + 1) le_rfl)\n#align partial_sups_le partial_sups_le\n\n",
 "partial_sups_eq_sup_range":
 "theorem partial_sups_eq_sup_range [SemilatticeSup α] [OrderBot α] (f : ℕ → α) (n : ℕ) :\n    partial_sups f n = (Finset.range (n + 1)).sup f :=\n  by\n  induction' n with n ih\n  · simp\n  · dsimp [partial_sups] at ih⊢\n    rw [Finset.range_succ, finset.sup_insert, sup_comm, ih]\n#align partial_sups_eq_sup_range partial_sups_eq_sup_range\n\n",
 "partial_sups_eq_sup'_range":
 "theorem partial_sups_eq_sup'_range (f : ℕ → α) (n : ℕ) :\n    partial_sups f n = (Finset.range (n + 1)).sup' ⟨n, Finset.self_mem_range_succ n⟩ f :=\n  by\n  induction' n with n ih\n  · simp\n  · dsimp [partial_sups] at ih⊢\n    simp_rw [@Finset.range_succ n.succ]\n    rw [ih, finset.sup'_insert, sup_comm]\n#align partial_sups_eq_sup'_range partial_sups_eq_sup'_range\n\n",
 "partial_sups_eq_csupr_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem partial_sups_eq_csupr_Iic (f : ℕ → α) (n : ℕ) :\n    partial_sups f n =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) :=\n  by\n  have : Set.Iio (n + 1) = Set.Iic n := Set.ext fun _ => Nat.lt_succ_iff\n  rw [partial_sups_eq_sup'_range, finset.sup'_eq_cSup_image, Finset.coe_range, supᵢ, Set.range_comp, Subtype.range_coe,\n    this]\n#align partial_sups_eq_csupr_Iic partial_sups_eq_csupr_Iic\n\n",
 "partial_sups_eq_bsupr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem partial_sups_eq_bsupr (f : ℕ → α) (n : ℕ) :\n    partial_sups f n =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) :=\n  by simpa only [supᵢ_subtype] using partial_sups_eq_csupr_Iic f n\n#align partial_sups_eq_bsupr partial_sups_eq_bsupr\n\n",
 "partial_sups_eq":
 "theorem monotone.partial_sups_eq {f : ℕ → α} (hf : monotone f) : (partial_sups f : ℕ → α) = f :=\n  by\n  ext n\n  induction' n with n ih\n  · rfl\n  · rw [partial_sups_succ, ih, sup_eq_right.2 (hf (nat.le_succ _))]\n#align monotone.partial_sups_eq monotone.partial_sups_eq\n\n",
 "partial_sups_disjoint_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- Note this lemma requires a distributive lattice, so is not useful (or true) in situations such as\nsubmodules. -/\ntheorem partial_sups_disjoint_of_disjoint [DistribLattice α] [OrderBot α] (f : ℕ → α)\n    (h : Pairwise («expr on » Disjoint f)) {m n : ℕ} (hmn : m < n) : Disjoint (partial_sups f m) (f n) :=\n  by\n  induction' m with m ih\n  · exact h hmn.ne\n  · rw [partial_sups_succ, disjoint_sup_left]\n    exact ⟨ih (nat.lt_of_succ_lt hmn), h hmn.ne⟩\n#align partial_sups_disjoint_of_disjoint partial_sups_disjoint_of_disjoint\n\n",
 "le_partial_sups_of_le":
 "theorem le_partial_sups_of_le (f : ℕ → α) {m n : ℕ} (h : m ≤ n) : f m ≤ partial_sups f n :=\n  by\n  induction' n with n ih\n  · cases h\n    exact le_rfl\n  · cases' h with h h\n    · exact le_sup_right\n    · exact (ih h).trans le_sup_left\n#align le_partial_sups_of_le le_partial_sups_of_le\n\n",
 "le_partial_sups":
 "theorem le_partial_sups (f : ℕ → α) : f ≤ partial_sups f := fun n => le_partial_sups_of_le f le_rfl\n#align le_partial_sups le_partial_sups\n\n",
 "csupr_partial_sups_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem csupr_partial_sups_eq {f : ℕ → α} (h : BddAbove (Set.range f)) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (partial_sups f n) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f n) :=\n  by\n  refine' (csupᵢ_le fun n => _).antisymm (csupᵢ_mono _ <| le_partial_sups f)\n  · rw [partial_sups_eq_csupr_Iic]\n    exact csupᵢ_le fun i => le_csupᵢ h _\n  · rwa [bdd_above_range_partial_sups]\n#align csupr_partial_sups_eq csupr_partial_sups_eq\n\n",
 "bdd_above_range_partial_sups":
 "@[simp]\ntheorem bdd_above_range_partial_sups {f : ℕ → α} : BddAbove (Set.range (partial_sups f)) ↔ BddAbove (Set.range f) :=\n  by\n  apply exists_congr fun a => _\n  constructor\n  · rintro h b ⟨i, rfl⟩\n    exact (le_partial_sups _ _).trans (h (Set.mem_range_self i))\n  · rintro h b ⟨i, rfl⟩\n    exact partial_sups_le _ _ _ fun _ _ => h (Set.mem_range_self _)\n#align bdd_above_range_partial_sups bdd_above_range_partial_sups\n\n"}