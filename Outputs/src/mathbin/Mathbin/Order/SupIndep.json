{"sup_indep_univ_fin_two":
 "@[simp]\ntheorem sup_indep_univ_fin_two (f : fin 2 → α) : (finset.univ : Finset (fin 2)).sup_indep f ↔ Disjoint (f 0) (f 1) :=\n  haveI : (0 : fin 2) ≠ 1 := by simp\n  sup_indep_pair this\n#align sup_indep_univ_fin_two sup_indep_univ_fin_two\n\n",
 "sup_indep_univ_bool":
 "theorem sup_indep_univ_bool (f : bool → α) : (finset.univ : Finset bool).sup_indep f ↔ Disjoint (f false) (f true) :=\n  haveI : tt ≠ ff := by simp only [ne.def, not_false_iff]\n  (sup_indep_pair this).trans disjoint_comm\n#align sup_indep_univ_bool sup_indep_univ_bool\n\n",
 "sup_indep_singleton":
 "theorem sup_indep_singleton (i : ι) (f : ι → α) : ({i} : Finset ι).sup_indep f := fun s hs j hji hj =>\n  by\n  rw [eq_empty_of_ssubset_singleton ⟨hs, fun h => hj (h hji)⟩, sup_empty]\n  exact disjoint_bot_right\n#align sup_indep_singleton sup_indep_singleton\n\n",
 "sup_indep_pair":
 "@[simp]\ntheorem sup_indep_pair [decidable_eq ι] {i j : ι} (hij : i ≠ j) :\n    ({i, j} : Finset ι).sup_indep f ↔ Disjoint (f i) (f j) :=\n  ⟨fun h => h.pairwise_disjoint (by simp) (by simp) hij, fun h =>\n    by\n    rw [sup_indep_iff_disjoint_erase]\n    intro k hk\n    rw [Finset.mem_insert, Finset.mem_singleton] at hk\n    obtain rfl | rfl := hk\n    · convert h using 1\n      rw [Finset.erase_insert, finset.sup_singleton]\n      simpa using hij\n    · convert h.symm using 1\n      have : ({i, k} : Finset ι).erase k = {i} := by\n        ext\n        rw [mem_erase, mem_insert, mem_singleton, mem_singleton, and_or_left, ne.def, not_and_self_iff, or_false_iff,\n          and_iff_right_of_imp]\n        rintro rfl\n        exact hij\n      rw [this, finset.sup_singleton]⟩\n#align sup_indep_pair sup_indep_pair\n\n",
 "sup_indep_iff_pairwise_disjoint":
 "theorem sup_indep_iff_pairwise_disjoint : s.sup_indep f ↔ (s : set ι).pairwise_disjoint f :=\n  ⟨sup_indep.pairwise_disjoint, fun hs t ht i hi hit =>\n    disjoint_sup_right.2 fun j hj => hs hi (ht hj) (ne_of_mem_of_not_mem hj hit).symm⟩\n#align sup_indep_iff_pairwise_disjoint sup_indep_iff_pairwise_disjoint\n\n",
 "sup_indep_iff_disjoint_erase":
 "/-- The RHS looks like the definition of `complete_lattice.independent`. -/\ntheorem sup_indep_iff_disjoint_erase [decidable_eq ι] : s.sup_indep f ↔ ∀ i ∈ s, Disjoint (f i) ((s.erase i).sup f) :=\n  ⟨fun hs i hi => hs (erase_subset _ _) hi (not_mem_erase _ _), fun hs t ht i hi hit =>\n    (hs i hi).mono_right (sup_mono fun j hj => mem_erase.2 ⟨ne_of_mem_of_not_mem hj hit, ht hj⟩)⟩\n#align sup_indep_iff_disjoint_erase sup_indep_iff_disjoint_erase\n\n",
 "sup_indep_empty":
 "theorem sup_indep_empty (f : ι → α) : (∅ : Finset ι).sup_indep f := fun _ _ a ha => ha.elim\n#align sup_indep_empty sup_indep_empty\n\n",
 "sup":
 "/-- Bind operation for `sup_indep`. -/\ntheorem sup_indep.sup [decidable_eq ι] {s : Finset ι'} {g : ι' → Finset ι} {f : ι → α}\n    (hs : s.sup_indep fun i => (g i).sup f) (hg : ∀ i' ∈ s, (g i').sup_indep f) : (s.sup g).sup_indep f :=\n  by\n  simp_rw [sup_indep_iff_pairwise_disjoint] at hs hg⊢\n  rw [sup_eq_bUnion, coe_bUnion]\n  exact hs.bUnion_finset hg\n#align sup_indep.sup sup_indep.sup\n\n",
 "subset":
 "/-\nCopyright (c) 2021 Aaron Anderson, Yaël Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson, Kevin Buzzard, Yaël Dillies, Eric Wieser\n-/\ntheorem sup_indep.subset (ht : t.sup_indep f) (h : s ⊆ t) : s.sup_indep f := fun u hu i hi => ht (hu.trans h) (h hi)\n#align sup_indep.subset sup_indep.subset\n\n",
 "set_independent_range":
 "theorem independent.set_independent_range (ht : independent t) : set_independent <| range t :=\n  by\n  rw [set_independent_iff]\n  rw [← coe_comp_range_factorization t] at ht\n  exact ht.comp' surjective_onto_range\n#align independent.set_independent_range independent.set_independent_range\n\n",
 "set_independent_pair":
 "theorem set_independent_pair {a b : α} (hab : a ≠ b) : set_independent ({a, b} : set α) ↔ Disjoint a b :=\n  by\n  constructor\n  · intro h\n    exact h.pairwise_disjoint (mem_insert _ _) (mem_insert_of_mem _ (mem_singleton _)) hab\n  · rintro h c ((rfl : c = a) | (rfl : c = b))\n    · convert h using 1\n      simp [hab, supₛ_singleton]\n    · convert h.symm using 1\n      simp [hab, supₛ_singleton]\n#align set_independent_pair set_independent_pair\n\n",
 "set_independent_iff_pairwise_disjoint":
 "theorem set_independent_iff_pairwise_disjoint {s : set α} : set_independent s ↔ s.pairwise_disjoint id :=\n  ⟨set_independent.pairwise_disjoint, fun hs i hi => disjoint_supₛ_iff.2 fun j hj => hs hi hj.1 <| ne.symm hj.2⟩\n#align set_independent_iff_pairwise_disjoint set_independent_iff_pairwise_disjoint\n\n",
 "set_independent_iff":
 "theorem set_independent_iff {α : Type _} [CompleteLattice α] (s : set α) :\n    set_independent s ↔ independent (coe : s → α) :=\n  by\n  simp_rw [independent, set_independent, SetCoe.forall, supₛ_eq_supᵢ]\n  refine' forall₂_congr fun a ha => _\n  congr 2\n  convert supr_subtype.symm\n  simp [supᵢ_and]\n#align set_independent_iff set_independent_iff\n\n",
 "set_independent_empty":
 "@[simp]\ntheorem set_independent_empty : set_independent (∅ : set α) := fun x hx => (Set.not_mem_empty x hx).elim\n#align set_independent_empty set_independent_empty\n\n",
 "pairwise_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/-- If the elements of a set are independent, then any pair within that set is disjoint. -/\ntheorem independent.pairwise_disjoint : Pairwise («expr on » Disjoint t) := fun x y h =>\n  disjoint_supₛ_right (ht x) ⟨y, supᵢ_pos h.symm⟩\n#align independent.pairwise_disjoint independent.pairwise_disjoint\n\n",
 "mono":
 "theorem independent.mono {s t : ι → α} (hs : independent s) (hst : t ≤ s) : independent t := fun i =>\n  (hs i).mono (hst i) <| supᵢ₂_mono fun j _ => hst j\n#align independent.mono independent.mono\n\n",
 "map_order_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/-- Composing an indepedent indexed family with an order isomorphism on the elements results in\nanother indepedendent indexed family. -/\ntheorem independent.map_order_iso {ι : Sort _} {α β : Type _} [CompleteLattice α] [CompleteLattice β]\n    (f : «expr ≃o » α β) {a : ι → α} (ha : independent a) : independent (f ∘ a) := fun i =>\n  ((ha i).map_order_iso f).mono_right (f.monotone.le_map_supr₂ _)\n#align independent.map_order_iso independent.map_order_iso\n\n",
 "injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem independent.injective (ht : independent t) (h_ne_bot : ∀ i, t i ≠ «expr⊥») : injective t :=\n  by\n  intro i j h\n  by_contra' contra\n  apply h_ne_bot j\n  suffices t j ≤ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (t k)\n    by\n    replace ht := (ht i).mono_right this\n    rwa [h, disjoint_self] at ht\n  replace contra : j ≠ i\n  · exact ne.symm contra\n  exact le_supᵢ₂ j contra\n#align independent.injective independent.injective\n\n",
 "independent_pempty":
 "@[simp]\ntheorem independent_pempty (t : PEmpty → α) : independent t :=\n  fun.\n#align independent_pempty independent_pempty\n\n",
 "independent_pair":
 "theorem independent_pair {i j : ι} (hij : i ≠ j) (huniv : ∀ k, k = i ∨ k = j) : independent t ↔ Disjoint (t i) (t j) :=\n  by\n  constructor\n  · exact fun h => h.pairwise_disjoint hij\n  · rintro h k\n    obtain rfl | rfl := huniv k\n    · refine' h.mono_right (supᵢ_le fun i => supᵢ_le fun hi => eq.le _)\n      rw [(huniv i).resolve_left hi]\n    · refine' h.symm.mono_right (supᵢ_le fun j => supᵢ_le fun hj => eq.le _)\n      rw [(huniv j).resolve_right hj]\n#align independent_pair independent_pair\n\n",
 "independent_map_order_iso_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n@[simp]\ntheorem independent_map_order_iso_iff {ι : Sort _} {α β : Type _} [CompleteLattice α] [CompleteLattice β]\n    (f : «expr ≃o » α β) {a : ι → α} : independent (f ∘ a) ↔ independent a :=\n  ⟨fun h =>\n    have hf : f.symm ∘ f ∘ a = a := congr_arg (· ∘ a) f.left_inv.comp_eq_id\n    hf ▸ h.map_order_iso f.symm,\n    fun h => h.map_order_iso f⟩\n#align independent_map_order_iso_iff independent_map_order_iso_iff\n\n",
 "independent_iff_sup_indep_univ":
 "/-- A variant of `complete_lattice.independent_iff_sup_indep` for `fintype`s. -/\ntheorem complete_lattice.independent_iff_sup_indep_univ [CompleteLattice α] [fintype ι] {f : ι → α} :\n    complete_lattice.independent f ↔ finset.univ.sup_indep f := by\n  classical simp [finset.sup_indep_iff_disjoint_erase, complete_lattice.independent, finset.sup_eq_supr]\n#align complete_lattice.independent_iff_sup_indep_univ complete_lattice.independent_iff_sup_indep_univ\n\n",
 "independent_iff_sup_indep":
 "theorem complete_lattice.independent_iff_sup_indep [CompleteLattice α] {s : Finset ι} {f : ι → α} :\n    complete_lattice.independent (f ∘ (coe : s → ι)) ↔ s.sup_indep f := by\n  classical\n    rw [finset.sup_indep_iff_disjoint_erase]\n    refine' subtype.forall.trans (forall₂_congr fun a b => _)\n    rw [finset.sup_eq_supr]\n    congr 2\n    refine' supr_subtype.trans _\n    congr 1 with x\n    simp [supᵢ_and, @supᵢ_comm _ (x ∈ s)]\n#align complete_lattice.independent_iff_sup_indep complete_lattice.independent_iff_sup_indep\n\n",
 "independent_iff_pairwise_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\ntheorem independent_iff_pairwise_disjoint {f : ι → α} : independent f ↔ Pairwise («expr on » Disjoint f) :=\n  ⟨independent.pairwise_disjoint, fun hs i => disjoint_supᵢ_iff.2 fun j => disjoint_supᵢ_iff.2 fun hij => hs hij.symm⟩\n#align independent_iff_pairwise_disjoint independent_iff_pairwise_disjoint\n\n",
 "independent_empty":
 "@[simp]\ntheorem independent_empty (t : empty → α) : independent t :=\n  fun.\n#align independent_empty independent_empty\n\n",
 "independent_def''":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (j «expr ≠ » i) -/\ntheorem independent_def'' : independent t ↔ ∀ i, Disjoint (t i) (supₛ { a | ∃ (j : _)(_ : j ≠ i), t j = a }) :=\n  by\n  rw [independent_def']\n  tidy\n#align independent_def'' independent_def''\n\n",
 "independent_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem independent_def' : independent t ↔ ∀ i, Disjoint (t i) (supₛ («expr '' » t { j | j ≠ i })) :=\n  by\n  simp_rw [supₛ_image]\n  rfl\n#align independent_def' independent_def'\n\n",
 "independent_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem independent_def :\n    independent t ↔\n      ∀ i : ι,\n        Disjoint (t i)\n          («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (t j)) :=\n  iff.rfl\n#align independent_def independent_def\n\n",
 "disjoint_bsupr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- If the elements of a set are independent, then any element is disjoint from the `supr` of some\nsubset of the rest. -/\ntheorem independent.disjoint_bsupr {ι : Type _} {α : Type _} [CompleteLattice α] {t : ι → α} (ht : independent t)\n    {x : ι} {y : set ι} (hx : x ∉ y) :\n    Disjoint (t x)\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (t i)) :=\n  Disjoint.mono_right (bsupᵢ_mono fun i hi => (ne_of_mem_of_not_mem hi hx : _)) (ht x)\n#align independent.disjoint_bsupr independent.disjoint_bsupr\n\n",
 "disjoint_Sup":
 "/-- If the elements of a set are independent, then any element is disjoint from the `Sup` of some\nsubset of the rest. -/\ntheorem set_independent.disjoint_Sup {x : α} {y : set α} (hx : x ∈ s) (hy : y ⊆ s) (hxy : x ∉ y) :\n    Disjoint x (supₛ y) := by\n  have := (hs.mono <| insert_subset.mpr ⟨hx, hy⟩) (mem_insert x _)\n  rw [insert_diff_of_mem _ (mem_singleton _), diff_singleton_eq_self hxy] at this\n  exact this\n#align set_independent.disjoint_Sup set_independent.disjoint_Sup\n\n",
 "comp'":
 "theorem independent.comp' {ι ι' : Sort _} {t : ι → α} {f : ι' → ι} (ht : independent <| t ∘ f) (hf : surjective f) :\n    independent t := by\n  intro i\n  obtain ⟨i', rfl⟩ := hf i\n  rw [← hf.supr_comp]\n  exact (ht i').mono_right (bsupᵢ_mono fun j' hij => mt (congr_arg f) hij)\n#align independent.comp' independent.comp'\n\n",
 "comp":
 "/-- Composing an independent indexed family with an injective function on the index results in\nanother indepedendent indexed family. -/\ntheorem independent.comp {ι ι' : Sort _} {t : ι → α} {f : ι' → ι} (ht : independent t) (hf : injective f) :\n    independent (t ∘ f) := fun i =>\n  (ht (f i)).mono_right <| by\n    refine' (supᵢ_mono fun i => _).trans (supᵢ_comp_le _ f)\n    exact supᵢ_const_mono hf.ne\n#align independent.comp independent.comp\n\n",
 "bUnion":
 "/-- Bind operation for `sup_indep`. -/\ntheorem sup_indep.bUnion [decidable_eq ι] {s : Finset ι'} {g : ι' → Finset ι} {f : ι → α}\n    (hs : s.sup_indep fun i => (g i).sup f) (hg : ∀ i' ∈ s, (g i').sup_indep f) : (s.bUnion g).sup_indep f :=\n  by\n  rw [← sup_eq_bUnion]\n  exact hs.sup hg\n#align sup_indep.bUnion sup_indep.bUnion\n\n",
 "attach":
 "theorem sup_indep.attach (hs : s.sup_indep f) : s.attach.sup_indep (f ∘ subtype.val) :=\n  by\n  intro t ht i _ hi\n  classical\n    rw [← finset.sup_image]\n    refine' hs (image_subset_iff.2 fun (j : { x // x ∈ s }) _ => j.2) i.2 fun hi' => hi _\n    rw [mem_image] at hi'\n    obtain ⟨j, hj, hji⟩ := hi'\n    rwa [subtype.ext hji] at hj\n#align sup_indep.attach sup_indep.attach\n\n"}