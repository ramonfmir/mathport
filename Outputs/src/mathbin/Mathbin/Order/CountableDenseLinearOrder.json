{"iso_of_countable_dense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/-- Any two countable dense, nonempty linear orders without endpoints are order isomorphic. -/\ntheorem iso_of_countable_dense [Encodable α] [DenselyOrdered α] [NoMinOrder α] [NoMaxOrder α] [Nonempty α] [Encodable β]\n    [DenselyOrdered β] [NoMinOrder β] [NoMaxOrder β] [Nonempty β] : Nonempty («expr ≃o » α β) :=\n  let to_cofinal : Sum α β → Cofinal (PartialIso α β) := fun p => sum.rec_on p (definedAtLeft β) (definedAtRight α)\n  let our_ideal : Ideal (PartialIso α β) := idealOfCofinals default to_cofinal\n  let F a := funOfIdeal a our_ideal (cofinal_meets_idealOfCofinals _ to_cofinal (Sum.inl a))\n  let G b := invOfIdeal b our_ideal (cofinal_meets_idealOfCofinals _ to_cofinal (Sum.inr b))\n  ⟨OrderIso.ofCmpEqCmp (fun a => (F a).val) (fun b => (G b).val) fun a b =>\n      by\n      rcases(F a).prop with ⟨f, hf, ha⟩\n      rcases(G b).prop with ⟨g, hg, hb⟩\n      rcases our_ideal.directed _ hf _ hg with ⟨m, hm, fm, gm⟩\n      exact m.prop (a, _) (fm ha) (_, b) (gm hb)⟩\n#align iso_of_countable_dense iso_of_countable_dense\n\n",
 "exists_between_finsets":
 "/-\nCopyright (c) 2020 David Wärn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: David Wärn\n-/\n/-- Suppose `α` is a nonempty dense linear order without endpoints, and\n    suppose `lo`, `hi`, are finite subssets with all of `lo` strictly\n    before `hi`. Then there is an element of `α` strictly between `lo`\n    and `hi`. -/\ntheorem exists_between_finsets {α : Type _} [linear_order α] [DenselyOrdered α] [NoMinOrder α] [NoMaxOrder α]\n    [nonem : Nonempty α] (lo hi : Finset α) (lo_lt_hi : ∀ x ∈ lo, ∀ y ∈ hi, x < y) :\n    ∃ m : α, (∀ x ∈ lo, x < m) ∧ ∀ y ∈ hi, m < y :=\n  if nlo : lo.nonempty then\n    if nhi : hi.nonempty then\n      -- both sets are nonempty, use densely_ordered\n        exists.elim\n        (exists_between (lo_lt_hi _ (Finset.max'_mem _ nlo) _ (Finset.min'_mem _ nhi))) fun m hm =>\n        ⟨m, fun x hx => lt_of_le_of_lt (Finset.le_max' lo x hx) hm.1, fun y hy =>\n          lt_of_lt_of_le hm.2 (Finset.min'_le hi y hy)⟩\n    else-- upper set is empty, use `no_max_order`\n        exists.elim\n        (exists_gt (Finset.max' lo nlo)) fun m hm =>\n        ⟨m, fun x hx => lt_of_le_of_lt (Finset.le_max' lo x hx) hm, fun y hy => (nhi ⟨y, hy⟩).elim⟩\n  else\n    if nhi : hi.nonempty then\n      -- lower set is empty, use `no_min_order`\n        exists.elim\n        (exists_lt (Finset.min' hi nhi)) fun m hm =>\n        ⟨m, fun x hx => (nlo ⟨x, hx⟩).elim, fun y hy => lt_of_lt_of_le hm (Finset.min'_le hi y hy)⟩\n    else-- both sets are empty, use nonempty\n          nonem.elim\n        fun m => ⟨m, fun x hx => (nlo ⟨x, hx⟩).elim, fun y hy => (nhi ⟨y, hy⟩).elim⟩\n#align exists_between_finsets exists_between_finsets\n\n",
 "exists_across":
 "/-- For each `a`, we can find a `b` in the codomain, such that `a`'s relation to\nthe domain of `f` is `b`'s relation to the image of `f`.\n\nThus, if `a` is not already in `f`, then we can extend `f` by sending `a` to `b`.\n-/\ntheorem exists_across [DenselyOrdered β] [NoMinOrder β] [NoMaxOrder β] [Nonempty β] (f : PartialIso α β) (a : α) :\n    ∃ b : β, ∀ p ∈ f.val, cmp (Prod.fst p) a = cmp (Prod.snd p) b :=\n  by\n  by_cases h : ∃ b, (a, b) ∈ f.val\n  · cases' h with b hb\n    exact ⟨b, fun p hp => f.prop _ hp _ hb⟩\n  have :\n    ∀ x ∈ (f.val.filter fun p : α × β => p.fst < a).image Prod.snd,\n      ∀ y ∈ (f.val.filter fun p : α × β => a < p.fst).image Prod.snd, x < y :=\n    by\n    intro x hx y hy\n    rw [Finset.mem_image] at hx hy\n    rcases hx with ⟨p, hp1, rfl⟩\n    rcases hy with ⟨q, hq1, rfl⟩\n    rw [Finset.mem_filter] at hp1 hq1\n    rw [← lt_iff_lt_of_cmp_eq_cmp (f.prop _ hp1.1 _ hq1.1)]\n    exact lt_trans hp1.right hq1.right\n  cases' exists_between_finsets _ _ this with b hb\n  use b\n  rintro ⟨p1, p2⟩ hp\n  have : p1 ≠ a := fun he => h ⟨p2, he ▸ hp⟩\n  cases' lt_or_gt_of_ne this with hl hr\n  · have : p1 < a ∧ p2 < b := ⟨hl, hb.1 _ (finset.mem_image.mpr ⟨(p1, p2), finset.mem_filter.mpr ⟨hp, hl⟩, rfl⟩)⟩\n    rw [← cmp_eq_lt_iff, ← cmp_eq_lt_iff] at this\n    cc\n  · have : a < p1 ∧ b < p2 := ⟨hr, hb.2 _ (finset.mem_image.mpr ⟨(p1, p2), finset.mem_filter.mpr ⟨hp, hr⟩, rfl⟩)⟩\n    rw [← cmp_eq_gt_iff, ← cmp_eq_gt_iff] at this\n    cc\n#align exists_across exists_across\n\n",
 "embedding_from_countable_to_dense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n/-- Any countable linear order embeds in any nontrivial dense linear order. -/\ntheorem embedding_from_countable_to_dense [Encodable α] [DenselyOrdered β] [Nontrivial β] : Nonempty («expr ↪o » α β) :=\n  by\n  rcases exists_pair_lt β with ⟨x, y, hxy⟩\n  cases' exists_between hxy with a ha\n  haveI : Nonempty (Set.Ioo x y) := ⟨⟨a, ha⟩⟩\n  let our_ideal : Ideal (partial_iso α _) := ideal_of_cofinals default (defined_at_left (Set.Ioo x y))\n  let F a := fun_of_ideal a our_ideal (cofinal_meets_ideal_of_cofinals _ _ a)\n  refine'\n    ⟨RelEmbedding.trans (OrderEmbedding.ofStrictMono (fun a => (F a).val) fun a₁ a₂ => _) (OrderEmbedding.subtype _)⟩\n  rcases(F a₁).prop with ⟨f, hf, ha₁⟩\n  rcases(F a₂).prop with ⟨g, hg, ha₂⟩\n  rcases our_ideal.directed _ hf _ hg with ⟨m, hm, fm, gm⟩\n  exact (lt_iff_lt_of_cmp_eq_cmp <| m.prop (a₁, _) (fm ha₁) (a₂, _) (gm ha₂)).mp\n#align embedding_from_countable_to_dense embedding_from_countable_to_dense\n\n"}