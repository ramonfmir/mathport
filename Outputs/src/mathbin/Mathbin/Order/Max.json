{"to_noMinOrder":
 "#print NoBotOrder.to_noMinOrder /-\n/-\nCopyright (c) 2014 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Yury Kudryashov, Yaël Dillies\n-/\n-- See note [lower instance priority]\n-- See note [lower instance priority]\ntheorem NoBotOrder.to_noMinOrder (α : Type _) [linear_order α] [NoBotOrder α] : NoMinOrder α :=\n  {\n    exists_lt := by\n      convert fun a : α => exists_not_ge a\n      simp_rw [not_le] }\n#align no_bot_order.to_no_min_order NoBotOrder.to_noMinOrder\n-/\n\n",
 "to_noMaxOrder":
 "#print NoTopOrder.to_noMaxOrder /-\ntheorem NoTopOrder.to_noMaxOrder (α : Type _) [linear_order α] [NoTopOrder α] : NoMaxOrder α :=\n  {\n    exists_gt := by\n      convert fun a : α => exists_not_le a\n      simp_rw [not_le] }\n#align no_top_order.to_no_max_order NoTopOrder.to_noMaxOrder\n-/\n\n",
 "snd":
 "#print IsMax.snd /-\ntheorem IsMax.snd (hx : is_max x) : is_max x.2 := fun c hc =>\n  (hx <| show x ≤ (x.1, c) from (and_iff_right le_rfl).2 hc).2\n#align is_max.snd IsMax.snd\n-/\n\n",
 "prod_mk":
 "#print IsMax.prod_mk /-\ntheorem IsMax.prod_mk (ha : is_max a) (hb : is_max b) : is_max (a, b) := fun c hc => ⟨ha hc.1, hb hc.2⟩\n#align is_max.prod_mk IsMax.prod_mk\n-/\n\n",
 "not_lt":
 "#print IsMax.not_lt /-\ntheorem IsMax.not_lt (h : is_max a) : ¬a < b := fun hb => hb.not_le <| h hb.le\n#align is_max.not_lt IsMax.not_lt\n-/\n\n",
 "not_isTop":
 "#print not_isTop /-\n@[simp]\ntheorem not_isTop [NoTopOrder α] (a : α) : ¬is_top a := fun h =>\n  let ⟨b, hb⟩ := exists_not_le a\n  hb <| h _\n#align not_is_top not_isTop\n-/\n\n",
 "not_isMin_of_lt":
 "#print not_isMin_of_lt /-\n@[simp]\ntheorem not_isMin_of_lt (h : b < a) : ¬is_min a := fun ha => ha.not_lt h\n#align not_is_min_of_lt not_isMin_of_lt\n-/\n\n",
 "not_isMin_iff":
 "#print not_isMin_iff /-\n@[simp]\ntheorem not_isMin_iff : ¬is_min a ↔ ∃ b, b < a := by simp_rw [lt_iff_le_not_le, is_min, not_forall, exists_prop]\n#align not_is_min_iff not_isMin_iff\n-/\n\n",
 "not_isMin":
 "#print not_isMin /-\n@[simp]\ntheorem not_isMin [NoMinOrder α] (a : α) : ¬is_min a :=\n  not_isMin_iff.2 <| exists_lt a\n#align not_is_min not_isMin\n-/\n\n",
 "not_isMax_of_lt":
 "#print not_isMax_of_lt /-\n@[simp]\ntheorem not_isMax_of_lt (h : a < b) : ¬is_max a := fun ha => ha.not_lt h\n#align not_is_max_of_lt not_isMax_of_lt\n-/\n\n",
 "not_isMax_iff":
 "#print not_isMax_iff /-\n@[simp]\ntheorem not_isMax_iff : ¬is_max a ↔ ∃ b, a < b := by simp_rw [lt_iff_le_not_le, is_max, not_forall, exists_prop]\n#align not_is_max_iff not_isMax_iff\n-/\n\n",
 "not_isMax":
 "#print not_isMax /-\n@[simp]\ntheorem not_isMax [NoMaxOrder α] (a : α) : ¬is_max a :=\n  not_isMax_iff.2 <| exists_gt a\n#align not_is_max not_isMax\n-/\n\n",
 "not_isBot":
 "#print not_isBot /-\n@[simp]\ntheorem not_isBot [NoBotOrder α] (a : α) : ¬is_bot a := fun h =>\n  let ⟨b, hb⟩ := exists_not_ge a\n  hb <| h _\n#align not_is_bot not_isBot\n-/\n\n",
 "not_acc":
 "theorem no_max_order.not_acc [LT α] [NoMaxOrder α] (a : α) : ¬acc (· > ·) a := fun h =>\n  acc.rec_on h fun x _ => (exists_gt x).rec_on\n#align no_max_order.not_acc no_max_order.not_acc\n\n",
 "no_top_order_iff_no_max_order":
 "theorem no_top_order_iff_no_max_order (α : Type _) [linear_order α] : NoTopOrder α ↔ NoMaxOrder α :=\n  ⟨fun h =>\n    haveI := h\n    NoTopOrder.to_noMaxOrder α,\n    fun h =>\n    haveI := h\n    no_max_order.to_no_top_order α⟩\n#align no_top_order_iff_no_max_order no_top_order_iff_no_max_order\n\n",
 "no_bot_order_iff_no_min_order":
 "theorem no_bot_order_iff_no_min_order (α : Type _) [linear_order α] : NoBotOrder α ↔ NoMinOrder α :=\n  ⟨fun h =>\n    haveI := h\n    NoBotOrder.to_noMinOrder α,\n    fun h =>\n    haveI := h\n    no_min_order.to_no_bot_order α⟩\n#align no_bot_order_iff_no_min_order no_bot_order_iff_no_min_order\n\n",
 "mono":
 "#print IsMax.mono /-\ntheorem IsMax.mono (ha : is_max a) (h : a ≤ b) : is_max b := fun c hc => (ha <| h.trans hc).trans h\n#align is_max.mono IsMax.mono\n-/\n\n",
 "is_top":
 "protected theorem is_top (a : α) : is_top a := fun _ => (subsingleton.elim _ _).le\n#align is_top is_top\n\n",
 "is_min":
 "protected theorem is_min (a : α) : is_min a :=\n  (Subsingleton.isBot _).is_min\n#align is_min is_min\n\n",
 "is_max":
 "protected theorem is_max (a : α) : is_max a :=\n  (Subsingleton.isTop _).is_max\n#align is_max is_max\n\n",
 "is_bot":
 "protected theorem is_bot (a : α) : is_bot a := fun _ => (subsingleton.elim _ _).le\n#align is_bot is_bot\n\n",
 "isTop_toDual_iff":
 "#print isTop_toDual_iff /-\n@[simp]\ntheorem isTop_toDual_iff : is_top (toDual a) ↔ is_bot a :=\n  iff.rfl\n#align is_top_to_dual_iff isTop_toDual_iff\n-/\n\n",
 "isTop_ofDual_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isTop_ofDual_iff /-\n@[simp]\ntheorem isTop_ofDual_iff {a : «expr ᵒᵈ» α} : is_top (ofDual a) ↔ is_bot a :=\n  iff.rfl\n#align is_top_of_dual_iff isTop_ofDual_iff\n-/\n\n",
 "isTop_iff":
 "#print Prod.isTop_iff /-\ntheorem Prod.isTop_iff : is_top x ↔ is_top x.1 ∧ is_top x.2 :=\n  ⟨fun hx => ⟨hx.fst, hx.snd⟩, fun h => h.1.prod_mk h.2⟩\n#align prod.is_top_iff Prod.isTop_iff\n-/\n\n",
 "isMin_toDual_iff":
 "#print isMin_toDual_iff /-\n@[simp]\ntheorem isMin_toDual_iff : is_min (toDual a) ↔ is_max a :=\n  iff.rfl\n#align is_min_to_dual_iff isMin_toDual_iff\n-/\n\n",
 "isMin_ofDual_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isMin_ofDual_iff /-\n@[simp]\ntheorem isMin_ofDual_iff {a : «expr ᵒᵈ» α} : is_min (ofDual a) ↔ is_max a :=\n  iff.rfl\n#align is_min_of_dual_iff isMin_ofDual_iff\n-/\n\n",
 "isMin_iff_forall_not_lt":
 "#print isMin_iff_forall_not_lt /-\ntheorem isMin_iff_forall_not_lt : is_min a ↔ ∀ b, ¬b < a :=\n  ⟨fun h _ => h.not_lt, fun h b hba => of_not_not fun hab => h _ <| hba.lt_of_not_le hab⟩\n#align is_min_iff_forall_not_lt isMin_iff_forall_not_lt\n-/\n\n",
 "isMin_iff":
 "#print Prod.isMin_iff /-\ntheorem Prod.isMin_iff : is_min x ↔ is_min x.1 ∧ is_min x.2 :=\n  ⟨fun hx => ⟨hx.fst, hx.snd⟩, fun h => h.1.prod_mk h.2⟩\n#align prod.is_min_iff Prod.isMin_iff\n-/\n\n",
 "isMin":
 "#print IsBot.isMin /-\nprotected theorem IsBot.isMin (h : is_bot a) : is_min a := fun b _ => h b\n#align is_bot.is_min IsBot.isMin\n-/\n\n",
 "isMax_toDual_iff":
 "#print isMax_toDual_iff /-\n@[simp]\ntheorem isMax_toDual_iff : is_max (toDual a) ↔ is_min a :=\n  iff.rfl\n#align is_max_to_dual_iff isMax_toDual_iff\n-/\n\n",
 "isMax_ofDual_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isMax_ofDual_iff /-\n@[simp]\ntheorem isMax_ofDual_iff {a : «expr ᵒᵈ» α} : is_max (ofDual a) ↔ is_min a :=\n  iff.rfl\n#align is_max_of_dual_iff isMax_ofDual_iff\n-/\n\n",
 "isMax_iff_forall_not_lt":
 "#print isMax_iff_forall_not_lt /-\ntheorem isMax_iff_forall_not_lt : is_max a ↔ ∀ b, ¬a < b :=\n  ⟨fun h _ => h.not_lt, fun h b hba => of_not_not fun hab => h _ <| hba.lt_of_not_le hab⟩\n#align is_max_iff_forall_not_lt isMax_iff_forall_not_lt\n-/\n\n",
 "isMax_iff":
 "#print Prod.isMax_iff /-\ntheorem Prod.isMax_iff : is_max x ↔ is_max x.1 ∧ is_max x.2 :=\n  ⟨fun hx => ⟨hx.fst, hx.snd⟩, fun h => h.1.prod_mk h.2⟩\n#align prod.is_max_iff Prod.isMax_iff\n-/\n\n",
 "isMax":
 "#print IsTop.isMax /-\nprotected theorem IsTop.isMax (h : is_top a) : is_max a := fun b _ => h b\n#align is_top.is_max IsTop.isMax\n-/\n\n",
 "isBot_toDual_iff":
 "#print isBot_toDual_iff /-\n@[simp]\ntheorem isBot_toDual_iff : is_bot (toDual a) ↔ is_top a :=\n  iff.rfl\n#align is_bot_to_dual_iff isBot_toDual_iff\n-/\n\n",
 "isBot_ofDual_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isBot_ofDual_iff /-\n@[simp]\ntheorem isBot_ofDual_iff {a : «expr ᵒᵈ» α} : is_bot (ofDual a) ↔ is_top a :=\n  iff.rfl\n#align is_bot_of_dual_iff isBot_ofDual_iff\n-/\n\n",
 "isBot_iff":
 "#print Prod.isBot_iff /-\ntheorem Prod.isBot_iff : is_bot x ↔ is_bot x.1 ∧ is_bot x.2 :=\n  ⟨fun hx => ⟨hx.fst, hx.snd⟩, fun h => h.1.prod_mk h.2⟩\n#align prod.is_bot_iff Prod.isBot_iff\n-/\n\n",
 "fst":
 "#print IsMax.fst /-\ntheorem IsMax.fst (hx : is_max x) : is_max x.1 := fun c hc =>\n  (hx <| show x ≤ (c, x.2) from (and_iff_left le_rfl).2 hc).1\n#align is_max.fst IsMax.fst\n-/\n\n",
 "eq_of_le":
 "#print IsMax.eq_of_le /-\nprotected theorem IsMax.eq_of_le (ha : is_max a) (h : a ≤ b) : a = b :=\n  h.antisymm <| ha h\n#align is_max.eq_of_le IsMax.eq_of_le\n-/\n\n",
 "eq_of_ge":
 "#print IsMax.eq_of_ge /-\nprotected theorem IsMax.eq_of_ge (ha : is_max a) (h : a ≤ b) : b = a :=\n  h.antisymm' <| ha h\n#align is_max.eq_of_ge IsMax.eq_of_ge\n-/\n\n"}