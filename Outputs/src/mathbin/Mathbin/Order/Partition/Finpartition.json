{"sum_card_parts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_card_parts :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" P.parts i.card =\n      s.card :=\n  by\n  convert congr_arg Finset.card P.bUnion_parts\n  rw [card_bUnion P.sup_indep.pairwise_disjoint]\n  rfl\n#align sum_card_parts sum_card_parts\n\n",
 "parts_top_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem parts_top_subsingleton (a : α) [Decidable (a = «expr⊥»)] :\n    ((«expr⊤» : Finpartition a).parts : Set α).subsingleton :=\n  Set.subsingleton_of_subset_singleton fun b hb => mem_singleton.1 <| parts_top_subset _ hb\n#align parts_top_subsingleton parts_top_subsingleton\n\n",
 "parts_top_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n-- See note [reducible non instances]\ntheorem parts_top_subset (a : α) [Decidable (a = «expr⊥»)] : («expr⊤» : Finpartition a).parts ⊆ {a} :=\n  by\n  intro b hb\n  change b ∈ Finpartition.parts (dite _ _ _) at hb\n  split_ifs  at hb\n  · simp only [copy_parts, empty_parts, not_mem_empty] at hb\n    exact hb.elim\n  · exact hb\n#align parts_top_subset parts_top_subset\n\n",
 "parts_nonempty_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem parts_nonempty_iff : P.parts.nonempty ↔ a ≠ «expr⊥» := by\n  rw [nonempty_iff_ne_empty, not_iff_not, parts_eq_empty_iff]\n#align parts_nonempty_iff parts_nonempty_iff\n\n",
 "parts_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem parts_nonempty (P : Finpartition a) (ha : a ≠ «expr⊥») : P.parts.nonempty :=\n  parts_nonempty_iff.2 ha\n#align parts_nonempty parts_nonempty\n\n",
 "parts_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem parts_inf (P Q : Finpartition a) :\n    («expr ⊓ » P Q).parts =\n      ((finset.product P.parts Q.parts).image fun bc : α × α => «expr ⊓ » bc.1 bc.2).erase («expr⊥») :=\n  rfl\n#align parts_inf parts_inf\n\n",
 "parts_eq_empty_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem parts_eq_empty_iff : P.parts = ∅ ↔ a = «expr⊥» :=\n  by\n  simp_rw [← P.sup_parts]\n  refine' ⟨fun h => _, fun h => eq_empty_iff_forall_not_mem.2 fun b hb => P.not_bot_mem _⟩\n  · rw [h]\n    exact Finset.sup_empty\n  · rwa [← le_bot_iff.1 ((le_sup hb).trans h.le)]\n#align parts_eq_empty_iff parts_eq_empty_iff\n\n",
 "parts_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem parts_bot (s : Finset α) : («expr⊥» : Finpartition s).parts = s.map ⟨singleton, singleton_injective⟩ :=\n  rfl\n#align parts_bot parts_bot\n\n",
 "nonempty_of_mem_parts":
 "theorem nonempty_of_mem_parts {a : Finset α} (ha : a ∈ P.parts) : a.nonempty :=\n  nonempty_iff_ne_empty.2 <| P.ne_bot ha\n#align nonempty_of_mem_parts nonempty_of_mem_parts\n\n",
 "ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ne_bot {b : α} (hb : b ∈ P.parts) : b ≠ «expr⊥» := fun h => P.not_bot_mem <| h.subst hb\n#align ne_bot ne_bot\n\n",
 "mem_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem mem_bot_iff : t ∈ («expr⊥» : Finpartition s).parts ↔ ∃ a ∈ s, {a} = t :=\n  mem_map\n#align mem_bot_iff mem_bot_iff\n\n",
 "mem_bind":
 "theorem mem_bind : b ∈ (P.bind Q).parts ↔ ∃ A hA, b ∈ (Q A hA).parts :=\n  by\n  rw [bind, mem_bUnion]\n  constructor\n  · rintro ⟨⟨A, hA⟩, -, h⟩\n    exact ⟨A, hA, h⟩\n  · rintro ⟨A, hA, h⟩\n    exact ⟨⟨A, hA⟩, mem_attach _ ⟨A, hA⟩, h⟩\n#align mem_bind mem_bind\n\n",
 "mem_avoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem mem_avoid : c ∈ (P.avoid b).parts ↔ ∃ d ∈ P.parts, ¬d ≤ b ∧ d \\ b = c :=\n  by\n  simp only [avoid, of_erase_parts, mem_erase, ne.def, mem_image, exists_prop, ← exists_and_left,\n    @and_left_comm (c ≠ «expr⊥»)]\n  refine' exists_congr fun d => and_congr_right' <| and_congr_left _\n  rintro rfl\n  rw [sdiff_eq_bot_iff]\n#align mem_avoid mem_avoid\n\n",
 "mem_atomise":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (Q «expr ⊆ » F) -/\ntheorem mem_atomise :\n    t ∈ (atomise s F).parts ↔ t.nonempty ∧ ∃ (Q : _)(_ : Q ⊆ F), (s.filter fun i => ∀ u ∈ F, u ∈ Q ↔ i ∈ u) = t := by\n  simp only [atomise, of_erase, bot_eq_empty, mem_erase, mem_image, nonempty_iff_ne_empty, mem_singleton, and_comm',\n    mem_powerset, exists_prop]\n#align mem_atomise mem_atomise\n\n",
 "le":
 "protected theorem le {b : α} (hb : b ∈ P.parts) : b ≤ a :=\n  (le_sup hb).trans P.sup_parts.le\n#align le le\n\n",
 "exists_mem":
 "theorem exists_mem {a : α} (ha : a ∈ s) : ∃ t ∈ P.parts, a ∈ t :=\n  by\n  simp_rw [← P.sup_parts] at ha\n  exact mem_sup.1 ha\n#align exists_mem exists_mem\n\n",
 "exists_le_of_le":
 "theorem exists_le_of_le {a b : α} {P Q : Finpartition a} (h : P ≤ Q) (hb : b ∈ Q.parts) : ∃ c ∈ P.parts, c ≤ b :=\n  by\n  by_contra' H\n  refine' Q.ne_bot hb (disjoint_self.1 <| Disjoint.mono_right (Q.le hb) _)\n  rw [← P.sup_parts, Finset.disjoint_sup_right]\n  rintro c hc\n  obtain ⟨d, hd, hcd⟩ := h hc\n  refine' (Q.disjoint hb hd _).mono_right hcd\n  rintro rfl\n  exact H _ hc hcd\n#align exists_le_of_le exists_le_of_le\n\n",
 "default_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-\nCopyright (c) 2022 Yaël Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies, Bhavik Mehta\n-/\n@[simp]\ntheorem default_eq_empty : (default : Finpartition («expr⊥» : α)) = Finpartition.empty α :=\n  rfl\n#align default_eq_empty default_eq_empty\n\n",
 "card_parts_le_card":
 "theorem card_parts_le_card (P : Finpartition s) : P.parts.card ≤ s.card :=\n  by\n  rw [← card_bot s]\n  exact card_mono bot_le\n#align card_parts_le_card card_parts_le_card\n\n",
 "card_mono":
 "theorem card_mono {a : α} {P Q : Finpartition a} (h : P ≤ Q) : Q.parts.card ≤ P.parts.card := by\n  classical\n    have : ∀ b ∈ Q.parts, ∃ c ∈ P.parts, c ≤ b := fun b => exists_le_of_le h\n    choose f hP hf using this\n    rw [← card_attach]\n    refine' card_le_card_of_inj_on (fun b => f _ b.2) (fun b _ => hP _ b.2) fun b hb c hc h => _\n    exact\n      Subtype.coe_injective\n        (Q.disjoint.elim b.2 c.2 fun H =>\n          P.ne_bot (hP _ b.2) <| disjoint_self.1 <| H.mono (hf _ b.2) <| h.le.trans <| hf _ c.2)\n#align card_mono card_mono\n\n",
 "card_filter_atomise_le_two_pow":
 "theorem card_filter_atomise_le_two_pow (ht : t ∈ F) :\n    ((atomise s F).parts.filter fun u => u ⊆ t ∧ u.nonempty).card ≤ 2 ^ (F.card - 1) :=\n  by\n  suffices h :\n    ((atomise s F).parts.filter fun u => u ⊆ t ∧ u.nonempty) ⊆\n      (F.erase t).powerset.image fun P => s.filter fun i => ∀ x ∈ F, x ∈ insert t P ↔ i ∈ x\n  · refine' (card_le_of_subset h).trans (card_image_le.trans _)\n    rw [card_powerset, card_erase_of_mem ht]\n  rw [subset_iff]\n  simp only [mem_erase, mem_sdiff, mem_powerset, mem_image, exists_prop, mem_filter, and_assoc', Finset.Nonempty,\n    exists_imp, and_imp, mem_atomise, forall_apply_eq_imp_iff₂]\n  rintro P' i hi P PQ rfl hy₂ j hj\n  refine' ⟨P.erase t, erase_subset_erase _ PQ, _⟩\n  simp only [insert_erase (((mem_filter.1 hi).2 _ ht).2 <| hy₂ hi), filter_congr_decidable]\n#align card_filter_atomise_le_two_pow card_filter_atomise_le_two_pow\n\n",
 "card_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem card_extend (P : Finpartition a) (b c : α) {hb : b ≠ «expr⊥»} {hab : Disjoint a b} {hc : «expr ⊔ » a b = c} :\n    (P.extend hb hab hc).parts.card = P.parts.card + 1 :=\n  card_insert_of_not_mem fun h => hb <| hab.symm.eq_bot_of_le <| P.le h\n#align card_extend card_extend\n\n",
 "card_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem card_bot (s : Finset α) : («expr⊥» : Finpartition s).parts.card = s.card :=\n  Finset.card_map _\n#align card_bot card_bot\n\n",
 "card_bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem card_bind (Q : ∀ i ∈ P.parts, Finpartition i) :\n    (P.bind Q).parts.card =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" P.parts.attach\n        (Q _ A.2).parts.card :=\n  by\n  apply card_bUnion\n  rintro ⟨b, hb⟩ - ⟨c, hc⟩ - hbc\n  rw [Finset.disjoint_left]\n  rintro d hdb hdc\n  rw [ne.def, Subtype.mk_eq_mk] at hbc\n  exact\n    (Q b hb).ne_bot hdb\n      (eq_bot_iff.2 <| (le_inf ((Q b hb).le hdb) <| (Q c hc).le hdc).trans <| (P.disjoint hb hc hbc).le_bot)\n#align card_bind card_bind\n\n",
 "card_atomise_le":
 "theorem card_atomise_le : (atomise s F).parts.card ≤ 2 ^ F.card :=\n  (card_le_of_subset <| erase_subset _ _).trans <| Finset.card_image_le.trans (card_powerset _).le\n#align card_atomise_le card_atomise_le\n\n",
 "bUnion_parts":
 "theorem bUnion_parts : P.parts.bUnion id = s :=\n  (sup_eq_bunionᵢ _ _).symm.trans P.sup_parts\n#align bUnion_parts bUnion_parts\n\n",
 "bUnion_filter_atomise":
 "theorem bUnion_filter_atomise (ht : t ∈ F) (hts : t ⊆ s) :\n    ((atomise s F).parts.filter fun u => u ⊆ t ∧ u.nonempty).bUnion id = t :=\n  by\n  ext a\n  refine' mem_bUnion.trans ⟨fun ⟨u, hu, ha⟩ => (mem_filter.1 hu).2.1 ha, fun ha => _⟩\n  obtain ⟨u, hu, hau⟩ := (atomise s F).exists_mem (hts ha)\n  refine' ⟨u, mem_filter.2 ⟨hu, fun b hb => _, _, hau⟩, hau⟩\n  obtain ⟨Q, hQ, rfl⟩ := (mem_atomise.1 hu).2\n  rw [mem_filter] at hau hb\n  rwa [← hb.2 _ ht, hau.2 _ ht]\n#align bUnion_filter_atomise bUnion_filter_atomise\n\n",
 "atomise_empty":
 "theorem atomise_empty (hs : s.nonempty) : (atomise s ∅).parts = {s} :=\n  by\n  simp only [atomise, powerset_empty, image_singleton, not_mem_empty, IsEmpty.forall_iff, imp_true_iff, filter_true]\n  exact erase_eq_of_not_mem (not_mem_singleton.2 hs.ne_empty.symm)\n#align atomise_empty atomise_empty\n\n",
 "Disjoint":
 "#print Disjoint /-\nprotected theorem Disjoint : (P.parts : Set α).pairwise_disjoint id :=\n  P.sup_indep.pairwise_disjoint\n#align disjoint Disjoint\n-/\n\n"}