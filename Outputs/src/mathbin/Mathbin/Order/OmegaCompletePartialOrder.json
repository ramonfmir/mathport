{"Ï‰Sup_zip":
 "theorem Ï‰Sup_zip (câ‚€ : Chain Î±) (câ‚ : Chain Î²) : Ï‰Sup (câ‚€.zip câ‚) = (Ï‰Sup câ‚€, Ï‰Sup câ‚) :=\n  by\n  apply eq_of_forall_ge_iff; rintro âŸ¨zâ‚, zâ‚‚âŸ©\n  simp [Ï‰Sup_le_iff, forall_and]\n#align Ï‰Sup_zip Ï‰Sup_zip\n\n",
 "Ï‰Sup_total":
 "theorem Ï‰Sup_total {c : Chain Î±} {x : Î±} (h : âˆ€ i, c i â‰¤ x âˆ¨ x â‰¤ c i) : Ï‰Sup c â‰¤ x âˆ¨ x â‰¤ Ï‰Sup c :=\n  by_cases (fun this : âˆ€ i, c i â‰¤ x => or.inl (Ï‰Sup_le _ _ this)) fun this : Â¬âˆ€ i, c i â‰¤ x =>\n    have : âˆƒ i, Â¬c i â‰¤ x := by simp only [not_forall] at thisâŠ¢ <;> assumption\n    let âŸ¨i, hxâŸ© := this\n    have : x â‰¤ c i := (h i).resolve_left hx\n    or.inr <| le_Ï‰Sup_of_le _ this\n#align Ï‰Sup_total Ï‰Sup_total\n\n",
 "Ï‰Sup_le_Ï‰Sup_of_le":
 "@[mono]\ntheorem Ï‰Sup_le_Ï‰Sup_of_le {câ‚€ câ‚ : Chain Î±} (h : câ‚€ â‰¤ câ‚) : Ï‰Sup câ‚€ â‰¤ Ï‰Sup câ‚ :=\n  Ï‰Sup_le _ _ fun i => Exists.rec_on (h i) fun j h => le_trans h (le_Ï‰Sup _ _)\n#align Ï‰Sup_le_Ï‰Sup_of_le Ï‰Sup_le_Ï‰Sup_of_le\n\n",
 "Ï‰Sup_le_iff":
 "theorem Ï‰Sup_le_iff (c : Chain Î±) (x : Î±) : Ï‰Sup c â‰¤ x â†” âˆ€ i, c i â‰¤ x :=\n  by\n  constructor <;> intros\n  Â· trans Ï‰Sup c\n    exact le_Ï‰Sup _ _\n    assumption\n  exact Ï‰Sup_le _ _ â€¹_â€º\n#align Ï‰Sup_le_iff Ï‰Sup_le_iff\n\n",
 "Ï‰Sup_eq_some":
 "theorem Ï‰Sup_eq_some {c : Chain (Part Î±)} {a : Î±} (h : some a âˆˆ c) : Part.Ï‰Sup c = some a :=\n  have : âˆƒ a, some a âˆˆ c := âŸ¨a, hâŸ©\n  have a' : some (Classical.choose this) âˆˆ c := Classical.choose_spec this\n  calc\n    Part.Ï‰Sup c = some (Classical.choose this) := dif_pos this\n    _ = some a := congr_arg _ (eq_of_chain a' h)\n    \n#align Ï‰Sup_eq_some Ï‰Sup_eq_some\n\n",
 "Ï‰Sup_eq_none":
 "theorem Ï‰Sup_eq_none {c : Chain (Part Î±)} (h : Â¬âˆƒ a, some a âˆˆ c) : Part.Ï‰Sup c = none :=\n  dif_neg h\n#align Ï‰Sup_eq_none Ï‰Sup_eq_none\n\n",
 "Ï‰Sup_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\ntheorem Ï‰Sup_def (c : Chain (Â«expr â†’ğ’„ Â» Î± Î²)) (x : Î±) : Ï‰Sup c x = ContinuousHom.Ï‰Sup c x :=\n  rfl\n#align Ï‰Sup_def Ï‰Sup_def\n\n",
 "Ï‰Sup_bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\ntheorem Ï‰Sup_bind {Î² Î³ : Type v} (c : Chain Î±) (f : Â«expr â†’o Â» Î± (Part Î²)) (g : Â«expr â†’o Â» Î± (Î² â†’ Part Î³)) :\n    Ï‰Sup (c.map (f.bind g)) = Ï‰Sup (c.map f) >>= Ï‰Sup (c.map g) :=\n  by\n  apply eq_of_forall_ge_iff; intro x\n  simp only [Ï‰Sup_le_iff, Part.bind_le, chain.mem_map_iff, and_imp, OrderHom.bind_coe, exists_imp]\n  constructor <;> intro h'''\n  Â· intro b hb\n    apply Ï‰Sup_le _ _ _\n    rintro i y hy\n    simp only [Part.mem_Ï‰Sup] at hb\n    rcases hb with âŸ¨j, hbâŸ©\n    replace hb := hb.symm\n    simp only [Part.eq_some_iff, chain.map_coe, Function.comp_apply, OrderHom.apply_coe] at hy hb\n    replace hb : b âˆˆ f (c (max i j)) := f.mono (c.mono (le_max_right i j)) _ hb\n    replace hy : y âˆˆ g (c (max i j)) b := g.mono (c.mono (le_max_left i j)) _ _ hy\n    apply h''' (max i j)\n    simp only [exists_prop, Part.bind_eq_bind, Part.mem_bind_iff, chain.map_coe, Function.comp_apply, OrderHom.bind_coe]\n    exact âŸ¨_, hb, hyâŸ©\n  Â· intro i\n    intro y hy\n    simp only [exists_prop, Part.bind_eq_bind, Part.mem_bind_iff, chain.map_coe, Function.comp_apply,\n      OrderHom.bind_coe] at hy\n    rcases hy with âŸ¨b, hbâ‚€, hbâ‚âŸ©\n    apply h''' b _\n    Â· apply le_Ï‰Sup (c.map g) _ _ _ hbâ‚\n    Â· apply le_Ï‰Sup (c.map f) i _ hbâ‚€\n#align Ï‰Sup_bind Ï‰Sup_bind\n\n",
 "Ï‰Sup_apply_Ï‰Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\ntheorem Ï‰Sup_apply_Ï‰Sup (câ‚€ : Chain (Â«expr â†’ğ’„ Â» Î± Î²)) (câ‚ : Chain Î±) :\n    Ï‰Sup câ‚€ (Ï‰Sup câ‚) = Prod.apply (Ï‰Sup (câ‚€.zip câ‚)) := by simp [prod.apply_apply, Prod.Ï‰Sup_zip]\n#align Ï‰Sup_apply_Ï‰Sup Ï‰Sup_apply_Ï‰Sup\n\n",
 "top_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\ntheorem top_continuous : Continuous (Â«exprâŠ¤Â» : Â«expr â†’o Â» Î± Î²) :=\n  by\n  intro c; apply eq_of_forall_ge_iff; intro z\n  simp only [Ï‰Sup_le_iff, forall_const, chain.map_coe, (Â· âˆ˜ Â·), Function.const, order_hom.has_top_top,\n    OrderHom.const_coe_coe]\n#align top_continuous top_continuous\n\n",
 "to_monotone":
 "theorem continuous'.to_monotone {f : Î± â†’ Î²} (hf : Continuous' f) : Monotone f :=\n  hf.fst\n#align continuous'.to_monotone continuous'.to_monotone\n\n",
 "to_bundled":
 "theorem continuous'.to_bundled (f : Î± â†’ Î²) (hf : Continuous' f) : Continuous âŸ¨f, hf.to_monotoneâŸ© :=\n  hf.snd\n#align continuous'.to_bundled continuous'.to_bundled\n\n",
 "supr_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\ntheorem supr_continuous {Î¹ : Sort _} {f : Î¹ â†’ Â«expr â†’o Â» Î± Î²} (h : âˆ€ i, Continuous (f i)) :\n    Continuous\n      (Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" (f i)) :=\n  supâ‚›_continuous _ <| Set.forall_range_iff.2 h\n#align supr_continuous supr_continuous\n\n",
 "sup_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\ntheorem sup_continuous {f g : Â«expr â†’o Â» Î± Î²} (hf : Continuous f) (hg : Continuous g) : Continuous (Â«expr âŠ” Â» f g) :=\n  by\n  rw [â† supâ‚›_pair]; apply Sup_continuous\n  rintro f (rfl | rfl | _) <;> assumption\n#align sup_continuous sup_continuous\n\n",
 "seq_continuous'":
 "theorem seq_continuous' {Î² Î³ : Type v} (f : Î± â†’ Part (Î² â†’ Î³)) (g : Î± â†’ Part Î²) (hf : Continuous' f)\n    (hg : Continuous' g) : Continuous' fun x => f x <*> g x := by\n  simp only [seq_eq_bind_map] <;> apply bind_continuous' _ _ hf <;>\n        apply Pi.OmegaCompletePartialOrder.flipâ‚‚_continuous' <;>\n      intro <;>\n    apply map_continuous' _ _ hg\n#align seq_continuous' seq_continuous'\n\n",
 "of_bundled'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\ntheorem continuous.of_bundled' (f : Â«expr â†’o Â» Î± Î²) (hf' : Continuous f) : Continuous' f :=\n  âŸ¨f.mono, hf'âŸ©\n#align continuous.of_bundled' continuous.of_bundled'\n\n",
 "of_bundled":
 "theorem continuous.of_bundled (f : Î± â†’ Î²) (hf : Monotone f) (hf' : Continuous âŸ¨f, hfâŸ©) : Continuous' f :=\n  âŸ¨hf, hf'âŸ©\n#align continuous.of_bundled continuous.of_bundled\n\n",
 "mem_Ï‰Sup":
 "theorem mem_Ï‰Sup (x : Î±) (c : Chain (Part Î±)) : x âˆˆ Ï‰Sup c â†” some x âˆˆ c :=\n  by\n  simp [omega_complete_partial_order.Ï‰Sup, Part.Ï‰Sup]\n  constructor\n  Â· split_ifs\n    swap\n    rintro âŸ¨âŸ¨âŸ©âŸ©\n    intro h'\n    have hh := Classical.choose_spec h\n    simp at h'\n    subst x\n    exact hh\n  Â· intro h\n    have h' : âˆƒ a : Î±, some a âˆˆ c := âŸ¨_, hâŸ©\n    rw [dif_pos h']\n    have hh := Classical.choose_spec h'\n    rw [eq_of_chain hh h]\n    simp\n#align mem_Ï‰Sup mem_Ï‰Sup\n\n",
 "mem_map_iff":
 "theorem mem_map_iff {b : Î²} : b âˆˆ c.map f â†” âˆƒ a, a âˆˆ c âˆ§ f a = b :=\n  âŸ¨exists_of_mem_map _, fun h => by\n    rcases h with âŸ¨w, h, h'âŸ©\n    subst b\n    apply mem_map c _ hâŸ©\n#align mem_map_iff mem_map_iff\n\n",
 "mem_map":
 "/-\nCopyright (c) 2020 Simon Hudon. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Simon Hudon\n-/\ntheorem mem_map (x : Î±) : x âˆˆ c â†’ f x âˆˆ Chain.map c f := fun âŸ¨i, hâŸ© => âŸ¨i, h.symm â–¸ rflâŸ©\n#align mem_map mem_map\n\n",
 "mem_chain_of_mem_Ï‰Sup":
 "theorem mem_chain_of_mem_Ï‰Sup {c : Chain (Part Î±)} {a : Î±} (h : a âˆˆ Part.Ï‰Sup c) : some a âˆˆ c :=\n  by\n  simp [Part.Ï‰Sup] at h; split_ifs  at h\n  Â· have h' := Classical.choose_spec h_1\n    rw [â† eq_some_iff] at h\n    rw [â† h]\n    exact h'\n  Â· rcases h with âŸ¨âŸ¨âŸ©âŸ©\n#align mem_chain_of_mem_Ï‰Sup mem_chain_of_mem_Ï‰Sup\n\n",
 "map_le_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\n@[mono]\ntheorem map_le_map {g : Â«expr â†’o Â» Î± Î²} (h : f â‰¤ g) : c.map f â‰¤ c.map g := fun i => by\n  simp [mem_map_iff] <;> intros <;> exists i <;> apply h\n#align map_le_map map_le_map\n\n",
 "map_id":
 "@[simp]\ntheorem map_id : c.map OrderHom.id = c :=\n  OrderHom.comp_id _\n#align map_id map_id\n\n",
 "map_continuous'":
 "theorem map_continuous' {Î² Î³ : Type v} (f : Î² â†’ Î³) (g : Î± â†’ Part Î²) (hg : Continuous' g) :\n    Continuous' fun x => f <$> g x := by\n  simp only [map_eq_bind_pure_comp] <;> apply bind_continuous' _ _ hg <;> apply const_continuous'\n#align map_continuous' map_continuous'\n\n",
 "map_comp":
 "theorem map_comp : (c.map f).map g = c.map (g.comp f) :=\n  rfl\n#align map_comp map_comp\n\n",
 "le_Ï‰Sup_of_le":
 "theorem le_Ï‰Sup_of_le {c : Chain Î±} {x : Î±} (i : â„•) (h : x â‰¤ c i) : x â‰¤ Ï‰Sup c :=\n  le_trans h (le_Ï‰Sup c _)\n#align le_Ï‰Sup_of_le le_Ï‰Sup_of_le\n\n",
 "ite_continuous'":
 "theorem ite_continuous' {p : Prop} [hp : Decidable p] (f g : Î± â†’ Î²) (hf : Continuous' f) (hg : Continuous' g) :\n    Continuous' fun x => if p then f x else g x := by split_ifs <;> simp [*]\n#align ite_continuous' ite_continuous'\n\n",
 "inf_continuous'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem inf_continuous' {f g : Î± â†’ Î²} (hf : Continuous' f) (hg : Continuous' g) : Continuous' (Â«expr âŠ“ Â» f g) :=\n  âŸ¨_, inf_continuous _ _ hf.snd hg.sndâŸ©\n#align inf_continuous' inf_continuous'\n\n",
 "inf_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem inf_continuous (f g : Â«expr â†’o Â» Î± Î²) (hf : Continuous f) (hg : Continuous g) : Continuous (Â«expr âŠ“ Â» f g) :=\n  by\n  refine' fun c => eq_of_forall_ge_iff fun z => _\n  simp only [inf_le_iff, hf c, hg c, Ï‰Sup_le_iff, â† forall_or_left, â† forall_or_right, Function.comp_apply,\n    chain.map_coe, order_hom.has_inf_inf_coe]\n  exact\n    âŸ¨fun h _ => h _ _, fun h i j =>\n      (h (max i j)).imp (le_trans <| f.mono <| c.mono <| le_max_left _ _)\n        (le_trans <| g.mono <| c.mono <| le_max_right _ _)âŸ©\n#align inf_continuous inf_continuous\n\n",
 "id_continuous'":
 "theorem id_continuous' : Continuous' (@id Î±) :=\n  continuous_id.of_bundled' _\n#align id_continuous' id_continuous'\n\n",
 "id_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\n@[simp]\ntheorem id_comp (f : Â«expr â†’ğ’„ Â» Î² Î³) : id.comp f = f := by ext <;> rfl\n#align id_comp id_comp\n\n",
 "forall_forall_merge'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\n@[simp]\ntheorem forall_forall_merge' (câ‚€ : Chain (Â«expr â†’ğ’„ Â» Î± Î²)) (câ‚ : Chain Î±) (z : Î²) :\n    (âˆ€ j i : â„•, (câ‚€ i) (câ‚ j) â‰¤ z) â†” âˆ€ i : â„•, (câ‚€ i) (câ‚ i) â‰¤ z := by rw [forall_swap, forall_forall_merge]\n#align forall_forall_merge' forall_forall_merge'\n\n",
 "forall_forall_merge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\n/-- When proving that a chain of applications is below a bound `z`, it suffices to consider the\nfunctions and values being selected from the same index in the chains.\n\nThis lemma is more specific than necessary, i.e. `câ‚€` only needs to be a\nchain of monotone functions, but it is only used with continuous functions. -/\n@[simp]\ntheorem forall_forall_merge (câ‚€ : Chain (Â«expr â†’ğ’„ Â» Î± Î²)) (câ‚ : Chain Î±) (z : Î²) :\n    (âˆ€ i j : â„•, (câ‚€ i) (câ‚ j) â‰¤ z) â†” âˆ€ i : â„•, (câ‚€ i) (câ‚ i) â‰¤ z :=\n  by\n  constructor <;> introv h\n  Â· apply h\n  Â· apply le_trans _ (h (max i j))\n    trans câ‚€ i (câ‚ (max i j))\n    Â· apply (câ‚€ i).monotone\n      apply câ‚.monotone\n      apply le_max_right\n    Â· apply câ‚€.monotone\n      apply le_max_left\n#align forall_forall_merge forall_forall_merge\n\n",
 "flipâ‚‚_continuous'":
 "theorem flipâ‚‚_continuous' (f : Î³ â†’ âˆ€ x, Î² x) (hf : âˆ€ x, Continuous' fun g => f g x) : Continuous' f :=\n  Continuous.of_bundled _ (fun x y h a => (hf a).to_monotone h) (by intro c <;> ext a <;> apply (hf a).to_bundled _ c)\n#align flipâ‚‚_continuous' flipâ‚‚_continuous'\n\n",
 "flipâ‚_continuous'":
 "theorem flipâ‚_continuous' (f : âˆ€ x : Î±, Î³ â†’ Î² x) (a : Î±) (hf : Continuous' fun x y => f y x) : Continuous' (f a) :=\n  Continuous.of_bundled _ (fun x y h => hf.to_monotone h a) fun c => congr_fun (hf.to_bundled _ c) a\n#align flipâ‚_continuous' flipâ‚_continuous'\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\n@[ext]\nprotected theorem ext (f g : Â«expr â†’ğ’„ Â» Î± Î²) (h : âˆ€ x, f x = g x) : f = g := by\n  cases f <;> cases g <;> congr <;> ext <;> apply h\n#align ext ext\n\n",
 "exists_of_mem_map":
 "theorem exists_of_mem_map {b : Î²} : b âˆˆ c.map f â†’ âˆƒ a, a âˆˆ c âˆ§ f a = b := fun âŸ¨i, hâŸ© => âŸ¨c i, âŸ¨i, rflâŸ©, h.symmâŸ©\n#align exists_of_mem_map exists_of_mem_map\n\n",
 "eq_of_chain":
 "theorem eq_of_chain {c : Chain (Part Î±)} {a b : Î±} (ha : some a âˆˆ c) (hb : some b âˆˆ c) : a = b :=\n  by\n  cases' ha with i ha; replace ha := ha.symm\n  cases' hb with j hb; replace hb := hb.symm\n  wlog h : i â‰¤ j; Â· exact (this j hb i ha (le_of_not_le h)).symm\n  rw [eq_some_iff] at ha hb\n  have := c.monotone h _ ha; apply mem_unique this hb\n#align eq_of_chain eq_of_chain\n\n",
 "continuous_id":
 "#print continuous_id /-\ntheorem continuous_id : Continuous (@OrderHom.id Î± _) := by intro <;> rw [c.map_id] <;> rfl\n#align continuous_id continuous_id\n-/\n\n",
 "continuous_const":
 "#print continuous_const /-\ntheorem continuous_const (x : Î²) : Continuous (OrderHom.const Î± x) := fun c =>\n  eq_of_forall_ge_iff fun z => by simp [Ï‰Sup_le_iff]\n#align continuous_const continuous_const\n-/\n\n",
 "continuous_comp":
 "theorem continuous_comp (hfc : Continuous f) (hgc : Continuous g) : Continuous (g.comp f) :=\n  by\n  dsimp [Continuous] at *; intro\n  rw [hfc, hgc, chain.map_comp]\n#align continuous_comp continuous_comp\n\n",
 "continuous'_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\n@[simp, norm_cast]\ntheorem continuous'_coe : âˆ€ {f : Â«expr â†’o Â» Î± Î²}, Continuous' f â†” Continuous f\n  | âŸ¨f, hfâŸ© => âŸ¨fun âŸ¨hf', hcâŸ© => hc, fun hc => âŸ¨hf, hcâŸ©âŸ©\n#align continuous'_coe continuous'_coe\n\n",
 "const_continuous'":
 "theorem const_continuous' (x : Î²) : Continuous' (Function.const Î± x) :=\n  Continuous.of_bundled' (OrderHom.const Î± x) (continuous_const x)\n#align const_continuous' const_continuous'\n\n",
 "const_apply":
 "@[simp]\ntheorem const_apply (f : Î²) (a : Î±) : const f a = f :=\n  rfl\n#align const_apply const_apply\n\n",
 "congr_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\n#print congr_fun /-\n-- Input: \\r\\MIc\ntheorem congr_fun {f g : Â«expr â†’ğ’„ Â» Î± Î²} (h : f = g) (x : Î±) : f x = g x :=\n  congr_arg (fun h : Â«expr â†’ğ’„ Â» Î± Î² => h x) h\n#align congr_fun congr_fun\n-/\n\n",
 "congr_arg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\n#print congr_arg /-\ntheorem congr_arg (f : Â«expr â†’ğ’„ Â» Î± Î²) {x y : Î±} (h : x = y) : f x = f y :=\n  congr_arg (fun x : Î± => f x) h\n#align congr_arg congr_arg\n-/\n\n",
 "comp_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\n@[simp]\ntheorem comp_id (f : Â«expr â†’ğ’„ Â» Î² Î³) : f.comp id = f := by ext <;> rfl\n#align comp_id comp_id\n\n",
 "comp_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\n@[simp]\ntheorem comp_assoc (f : Â«expr â†’ğ’„ Â» Î³ Ï†) (g : Â«expr â†’ğ’„ Â» Î² Î³) (h : Â«expr â†’ğ’„ Â» Î± Î²) :\n    f.comp (g.comp h) = (f.comp g).comp h := by ext <;> rfl\n#align comp_assoc comp_assoc\n\n",
 "coe_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\nprotected theorem coe_inj (f g : Â«expr â†’ğ’„ Â» Î± Î²) (h : (f : Î± â†’ Î²) = g) : f = g :=\n  ContinuousHom.ext _ _ <| _root_.congr_fun h\n#align coe_inj coe_inj\n\n",
 "coe_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\n@[simp]\ntheorem coe_apply (a : Î±) (f : Â«expr â†’ğ’„ Â» Î± Î²) : (f : Â«expr â†’o Â» Î± Î²) a = f a :=\n  rfl\n#align coe_apply coe_apply\n\n",
 "bot_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\ntheorem bot_continuous : Continuous (Â«exprâŠ¥Â» : Â«expr â†’o Â» Î± Î²) :=\n  by\n  rw [â† supâ‚›_empty]\n  exact Sup_continuous _ fun f hf => hf.elim\n#align bot_continuous bot_continuous\n\n",
 "bind_continuous'":
 "theorem bind_continuous' {Î² Î³ : Type v} (f : Î± â†’ Part Î²) (g : Î± â†’ Î² â†’ Part Î³) :\n    Continuous' f â†’ Continuous' g â†’ Continuous' fun x => f x >>= g x\n  | âŸ¨hf, hf'âŸ©, âŸ¨hg, hg'âŸ© =>\n    Continuous.of_bundled' (OrderHom.bind âŸ¨f, hfâŸ© âŸ¨g, hgâŸ©) (by intro c <;> rw [Ï‰Sup_bind, â† hf', â† hg'] <;> rfl)\n#align bind_continuous' bind_continuous'\n\n",
 "apply_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\n@[mono]\ntheorem apply_mono {f g : Â«expr â†’ğ’„ Â» Î± Î²} {x y : Î±} (hâ‚ : f â‰¤ g) (hâ‚‚ : x â‰¤ y) : f x â‰¤ g y :=\n  OrderHom.apply_mono (show (f : Â«expr â†’o Â» Î± Î²) â‰¤ g from hâ‚) hâ‚‚\n#align apply_mono apply_mono\n\n",
 "Sup_continuous'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\ntheorem Sup_continuous' (s : Set (Î± â†’ Î²)) (hc : âˆ€ f âˆˆ s, Continuous' f) : Continuous' (supâ‚› s) :=\n  by\n  lift s to Set (Â«expr â†’o Â» Î± Î²) using fun f hf => (hc f hf).to_monotone\n  simp only [Set.ball_image_iff, continuous'_coe] at hc\n  rw [supâ‚›_image]\n  norm_cast\n  exact supr_continuous fun f => supr_continuous fun hf => hc f hf\n#align Sup_continuous' Sup_continuous'\n\n",
 "Sup_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\n-- see Note [lower instance priority]\ntheorem Sup_continuous (s : Set <| Â«expr â†’o Â» Î± Î²) (hs : âˆ€ f âˆˆ s, Continuous f) : Continuous (supâ‚› s) :=\n  by\n  intro c\n  apply eq_of_forall_ge_iff\n  intro z\n  suffices (âˆ€ f âˆˆ s, âˆ€ (n), (f : _) (c n) â‰¤ z) â†” âˆ€ (n), âˆ€ f âˆˆ s, (f : _) (c n) â‰¤ z by\n    simpa (config := { contextual := true }) [Ï‰Sup_le_iff, hs _ _ _]\n  exact âŸ¨fun H n f hf => H f hf n, fun H f hf n => H n f hfâŸ©\n#align Sup_continuous Sup_continuous\n\n",
 "Monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\n#print Monotone /-\nprotected theorem Monotone (f : Â«expr â†’ğ’„ Â» Î± Î²) : Monotone f :=\n  f.monotone'\n#align monotone Monotone\n-/\n\n",
 "Continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’ğ’„ Â» -/\n#print Continuous /-\ntheorem Continuous (F : Â«expr â†’ğ’„ Â» Î± Î²) (C : Chain Î±) : F (Ï‰Sup C) = Ï‰Sup (C.map F) :=\n  continuous_hom.cont _ _\n#align continuous Continuous\n-/\n\n"}