{"trans":
 "#print trans /-\n@[trans]\ntheorem trans {s₁ s₂ s₃ : CompositionSeries X} (h₁ : Equivalent s₁ s₂) (h₂ : Equivalent s₂ s₃) : Equivalent s₁ s₃ :=\n  ⟨h₁.some.trans h₂.some, fun i => iso_trans (h₁.some_spec i) (h₂.some_spec (h₁.some i))⟩\n#align trans trans\n-/\n\n",
 "total":
 "theorem total {s : CompositionSeries X} {x y : X} (hx : x ∈ s) (hy : y ∈ s) : x ≤ y ∨ y ≤ x :=\n  by\n  rcases Set.mem_range.1 hx with ⟨i, rfl⟩\n  rcases Set.mem_range.1 hy with ⟨j, rfl⟩\n  rw [s.strict_mono.le_iff_le, s.strict_mono.le_iff_le]\n  exact le_total i j\n#align total total\n\n",
 "top_snoc":
 "@[simp]\ntheorem top_snoc (s : CompositionSeries X) (x : X) (hsat : is_maximal s.top x) : (snoc s x hsat).top = x :=\n  Fin.snoc_last _ _\n#align top_snoc top_snoc\n\n",
 "top_mem":
 "theorem top_mem (s : CompositionSeries X) : s.top ∈ s :=\n  mem_def.2 (Set.mem_range.2 ⟨Fin.last _, rfl⟩)\n#align top_mem top_mem\n\n",
 "top_erase_top":
 "theorem top_erase_top (s : CompositionSeries X) :\n    s.erase_top.top = s ⟨s.length - 1, lt_of_le_of_lt tsub_le_self (nat.lt_succ_self _)⟩ :=\n  show s _ = s _ from\n    congr_arg s\n      (by\n        ext\n        simp only [erase_top_length, Fin.val_last, Fin.coe_castSucc, Fin.coe_ofNat_eq_mod, Fin.val_mk, coe_coe])\n#align top_erase_top top_erase_top\n\n",
 "to_list_sorted":
 "theorem to_list_sorted (s : CompositionSeries X) : s.to_list.sorted (· < ·) :=\n  List.pairwise_iff_nthLe.2 fun i j hi hij => by\n    dsimp [to_list]\n    rw [List.nthLe_ofFn', List.nthLe_ofFn']\n    exact s.strict_mono hij\n#align to_list_sorted to_list_sorted\n\n",
 "to_list_of_list":
 "@[simp]\ntheorem to_list_of_list (l : List X) (hl : l ≠ []) (hc : List.Chain' is_maximal l) : toList (ofList l hl hc) = l :=\n  by\n  refine' List.ext_nthLe _ _\n  · rw [length_to_list, length_of_list, tsub_add_cancel_of_le (nat.succ_le_of_lt <| List.length_pos_of_ne_nil hl)]\n  · intro i hi hi'\n    dsimp [of_list, to_list]\n    rw [List.nthLe_ofFn']\n    rfl\n#align to_list_of_list to_list_of_list\n\n",
 "to_list_nodup":
 "theorem to_list_nodup (s : CompositionSeries X) : s.to_list.nodup :=\n  s.to_list_sorted.nodup\n#align to_list_nodup to_list_nodup\n\n",
 "to_list_ne_nil":
 "theorem to_list_ne_nil (s : CompositionSeries X) : s.to_list ≠ [] := by\n  rw [← List.length_pos_iff_ne_nil, length_to_list] <;> exact nat.succ_pos _\n#align to_list_ne_nil to_list_ne_nil\n\n",
 "to_list_injective":
 "theorem to_list_injective : function.injective (@CompositionSeries.toList X _ _) :=\n  fun s₁ s₂ (h : List.ofFn s₁ = List.ofFn s₂) =>\n  by\n  have h₁ : s₁.length = s₂.length :=\n    Nat.succ_injective ((List.length_ofFn s₁).symm.trans <| (congr_arg list.length h).trans <| List.length_ofFn s₂)\n  have h₂ : ∀ i : Fin s₁.length.succ, s₁ i = s₂ (Fin.cast (congr_arg nat.succ h₁) i) :=\n    by\n    intro i\n    rw [← List.nthLe_ofFn s₁ i, ← List.nthLe_ofFn s₂]\n    simp [h]\n  cases s₁\n  cases s₂\n  dsimp at *\n  subst h₁\n  simp only [heq_iff_eq, eq_self_iff_true, true_and_iff]\n  simp only [Fin.cast_refl] at h₂\n  exact funext h₂\n#align to_list_injective to_list_injective\n\n",
 "symm":
 "#print symm /-\n@[symm]\ntheorem symm {s₁ s₂ : CompositionSeries X} (h : Equivalent s₁ s₂) : Equivalent s₂ s₁ :=\n  ⟨h.some.symm, fun i => iso_symm (by simpa using h.some_spec (h.some.symm i))⟩\n#align symm symm\n-/\n\n",
 "step":
 "theorem step (s : CompositionSeries X) : ∀ i : Fin s.length, is_maximal (s i.cast_succ) (s i.succ) :=\n  s.step'\n#align step step\n\n",
 "snoc_snoc_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem snoc_snoc_swap {s : CompositionSeries X} {x₁ x₂ y₁ y₂ : X} {hsat₁ : is_maximal s.top x₁}\n    {hsat₂ : is_maximal s.top x₂} {hsaty₁ : is_maximal (snoc s x₁ hsat₁).top y₁}\n    {hsaty₂ : is_maximal (snoc s x₂ hsat₂).top y₂} (hr₁ : iso (s.top, x₁) (x₂, y₂)) (hr₂ : iso (x₁, y₁) (s.top, x₂)) :\n    Equivalent (snoc (snoc s x₁ hsat₁) y₁ hsaty₁) (snoc (snoc s x₂ hsat₂) y₂ hsaty₂) :=\n  let e : «expr ≃ » (Fin (s.length + 1 + 1)) (Fin (s.length + 1 + 1)) :=\n    Equiv.swap (Fin.last _) (Fin.castSucc (Fin.last _))\n  have h1 : ∀ {i : Fin s.length}, i.cast_succ.cast_succ ≠ (Fin.last _).cast_succ := fun _ =>\n    ne_of_lt (by simp [Fin.castSucc_lt_last])\n  have h2 : ∀ {i : Fin s.length}, i.cast_succ.cast_succ ≠ Fin.last _ := fun _ =>\n    ne_of_lt (by simp [Fin.castSucc_lt_last])\n  ⟨e, by\n    intro i\n    dsimp only [e]\n    refine' Fin.lastCases _ (fun i => _) i\n    · erw [Equiv.swap_apply_left, snoc_cast_succ, snoc_last, Fin.succ_last, snoc_last, snoc_cast_succ, snoc_cast_succ,\n        Fin.succ_castSucc, snoc_cast_succ, Fin.succ_last, snoc_last]\n      exact hr₂\n    · refine' Fin.lastCases _ (fun i => _) i\n      · erw [Equiv.swap_apply_right, snoc_cast_succ, snoc_cast_succ, snoc_cast_succ, Fin.succ_castSucc, snoc_cast_succ,\n          Fin.succ_last, snoc_last, snoc_last, Fin.succ_last, snoc_last]\n        exact hr₁\n      · erw [Equiv.swap_apply_of_ne_of_ne h2 h1, snoc_cast_succ, snoc_cast_succ, snoc_cast_succ, snoc_cast_succ,\n          Fin.succ_castSucc, snoc_cast_succ, Fin.succ_castSucc, snoc_cast_succ, snoc_cast_succ, snoc_cast_succ]\n        exact (s.step i).iso_refl⟩\n#align snoc_snoc_swap snoc_snoc_swap\n\n",
 "snoc_last":
 "@[simp]\ntheorem snoc_last (s : CompositionSeries X) (x : X) (hsat : is_maximal s.top x) :\n    snoc s x hsat (Fin.last (s.length + 1)) = x :=\n  Fin.snoc_last _ _\n#align snoc_last snoc_last\n\n",
 "snoc_erase_top_top":
 "@[simp]\ntheorem snoc_erase_top_top {s : CompositionSeries X} (h : is_maximal s.erase_top.top s.top) :\n    s.erase_top.snoc s.top h = s :=\n  have h : 0 < s.length :=\n    nat.pos_of_ne_zero\n      (by\n        intro hs\n        refine' ne_of_gt (lt_of_is_maximal h) _\n        simp [top, Fin.ext_iff, hs])\n  (eq_snoc_eraseTop h).symm\n#align snoc_erase_top_top snoc_erase_top_top\n\n",
 "snoc_cast_succ":
 "@[simp]\ntheorem snoc_cast_succ (s : CompositionSeries X) (x : X) (hsat : is_maximal s.top x) (i : Fin (s.length + 1)) :\n    snoc s x hsat i.cast_succ = s i :=\n  Fin.snoc_castSucc _ _ _\n#align snoc_cast_succ snoc_cast_succ\n\n",
 "snoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\nprotected theorem snoc {s₁ s₂ : CompositionSeries X} {x₁ x₂ : X} {hsat₁ : is_maximal s₁.top x₁}\n    {hsat₂ : is_maximal s₂.top x₂} (hequiv : Equivalent s₁ s₂) (htop : iso (s₁.top, x₁) (s₂.top, x₂)) :\n    Equivalent (s₁.snoc x₁ hsat₁) (s₂.snoc x₂ hsat₂) :=\n  let e : «expr ≃ » (Fin s₁.length.succ) (Fin s₂.length.succ) :=\n    calc\n      «expr ≃ » (Fin (s₁.length + 1)) (Option (Fin s₁.length)) := finSuccEquivLast\n      «expr ≃ » _ (Option (Fin s₂.length)) := (Functor.mapEquiv Option hequiv.some)\n      «expr ≃ » _ (Fin (s₂.length + 1)) := finSuccEquivLast.symm\n      \n  ⟨e, fun i => by\n    refine' Fin.lastCases _ _ i\n    · simpa [top] using htop\n    · intro i\n      simpa [Fin.succ_castSucc] using hequiv.some_spec i⟩\n#align snoc snoc\n\n",
 "second_iso_of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem second_iso_of_eq {x y a b : X} (hm : is_maximal x a) (ha : «expr ⊔ » x y = a) (hb : «expr ⊓ » x y = b) :\n    iso (x, a) (b, y) := by substs a b <;> exact second_iso hm\n#align second_iso_of_eq second_iso_of_eq\n\n",
 "refl":
 "#print refl /-\n@[refl]\ntheorem refl (s : CompositionSeries X) : Equivalent s s :=\n  ⟨Equiv.refl _, fun _ => (s.step _).iso_refl⟩\n#align refl refl\n-/\n\n",
 "of_list_to_list'":
 "@[simp]\ntheorem of_list_to_list' (s : CompositionSeries X) : ofList s.to_list s.to_list_ne_nil s.chain'_to_list = s :=\n  ofList_toList s\n#align of_list_to_list' of_list_to_list'\n\n",
 "of_list_to_list":
 "theorem of_list_to_list (s : CompositionSeries X) : ofList s.to_list s.to_list_ne_nil s.chain'_to_list = s :=\n  by\n  refine' ext_fun _ _\n  · rw [length_of_list, length_to_list, nat.succ_sub_one]\n  · rintro ⟨i, hi⟩\n    dsimp [of_list, to_list]\n    rw [List.nthLe_ofFn']\n#align of_list_to_list of_list_to_list\n\n",
 "mem_to_list":
 "@[simp]\ntheorem mem_to_list {s : CompositionSeries X} {x : X} : x ∈ s.to_list ↔ x ∈ s := by rw [to_list, List.mem_ofFn, mem_def]\n#align mem_to_list mem_to_list\n\n",
 "mem_snoc":
 "theorem mem_snoc {s : CompositionSeries X} {x y : X} {hsat : is_maximal s.top x} : y ∈ snoc s x hsat ↔ y ∈ s ∨ y = x :=\n  by\n  simp only [snoc, mem_def]\n  constructor\n  · rintro ⟨i, rfl⟩\n    refine' Fin.lastCases _ (fun i => _) i\n    · right\n      simp\n    · left\n      simp\n  · intro h\n    rcases h with (⟨i, rfl⟩ | rfl)\n    · use i.cast_succ\n      simp\n    · use Fin.last _\n      simp\n#align mem_snoc mem_snoc\n\n",
 "mem_erase_top_of_ne_of_mem":
 "theorem mem_erase_top_of_ne_of_mem {s : CompositionSeries X} {x : X} (hx : x ≠ s.top) (hxs : x ∈ s) : x ∈ s.erase_top :=\n  by\n  rcases hxs with ⟨i, rfl⟩\n  have hi : (i : ℕ) < (s.length - 1).succ :=\n    by\n    conv_rhs => rw [← nat.succ_sub (length_pos_of_mem_ne ⟨i, rfl⟩ s.top_mem hx), nat.succ_sub_one]\n    exact lt_of_le_of_ne (nat.le_of_lt_succ i.2) (by simpa [top, s.inj, Fin.ext_iff] using hx)\n  refine' ⟨i.cast_succ, _⟩\n  simp [Fin.ext_iff, nat.mod_eq_of_lt hi]\n#align mem_erase_top_of_ne_of_mem mem_erase_top_of_ne_of_mem\n\n",
 "mem_erase_top":
 "theorem mem_erase_top {s : CompositionSeries X} {x : X} (h : 0 < s.length) : x ∈ s.erase_top ↔ x ≠ s.top ∧ x ∈ s :=\n  by\n  simp only [mem_def]\n  dsimp only [erase_top, coe_fn_mk]\n  constructor\n  · rintro ⟨i, rfl⟩\n    have hi : (i : ℕ) < s.length :=\n      by\n      conv_rhs => rw [← nat.succ_sub_one s.length, nat.succ_sub h]\n      exact i.2\n    simp [top, Fin.ext_iff, ne_of_lt hi]\n  · intro h\n    exact mem_erase_top_of_ne_of_mem h.1 h.2\n#align mem_erase_top mem_erase_top\n\n",
 "mem_def":
 "theorem mem_def {x : X} {s : CompositionSeries X} : x ∈ s ↔ x ∈ Set.range s :=\n  iff.rfl\n#align mem_def mem_def\n\n",
 "lt_top_of_mem_erase_top":
 "theorem lt_top_of_mem_erase_top {s : CompositionSeries X} {x : X} (h : 0 < s.length) (hx : x ∈ s.erase_top) :\n    x < s.top :=\n  lt_of_le_of_ne (le_top_of_mem ((mem_eraseTop h).1 hx).2) ((mem_eraseTop h).1 hx).1\n#align lt_top_of_mem_erase_top lt_top_of_mem_erase_top\n\n",
 "lt_succ":
 "theorem lt_succ (s : CompositionSeries X) (i : Fin s.length) : s i.cast_succ < s i.succ :=\n  lt_of_is_maximal (s.step _)\n#align lt_succ lt_succ\n\n",
 "length_to_list":
 "@[simp]\ntheorem length_to_list (s : CompositionSeries X) : s.to_list.length = s.length + 1 := by rw [to_list, List.length_ofFn]\n#align length_to_list length_to_list\n\n",
 "length_pos_of_mem_ne":
 "theorem length_pos_of_mem_ne {s : CompositionSeries X} {x y : X} (hx : x ∈ s) (hy : y ∈ s) (hxy : x ≠ y) :\n    0 < s.length :=\n  let ⟨i, hi⟩ := hx\n  let ⟨j, hj⟩ := hy\n  have hij : i ≠ j := mt s.inj.2 fun h => hxy (hi ▸ hj ▸ h)\n  hij.lt_or_lt.elim (fun hij => lt_of_le_of_lt (zero_le i) (lt_of_lt_of_le hij (nat.le_of_lt_succ j.2))) fun hji =>\n    lt_of_le_of_lt (zero_le j) (lt_of_lt_of_le hji (nat.le_of_lt_succ i.2))\n#align length_pos_of_mem_ne length_pos_of_mem_ne\n\n",
 "length_pos_of_bot_eq_bot_of_top_eq_top_of_length_pos":
 "theorem length_pos_of_bot_eq_bot_of_top_eq_top_of_length_pos {s₁ s₂ : CompositionSeries X} (hb : s₁.bot = s₂.bot)\n    (ht : s₁.top = s₂.top) : 0 < s₁.length → 0 < s₂.length :=\n  not_imp_not.1\n    (by\n      simp only [pos_iff_ne_zero, ne.def, not_iff_not, Classical.not_not]\n      exact length_eq_zero_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero hb.symm ht.symm)\n#align length_pos_of_bot_eq_bot_of_top_eq_top_of_length_pos length_pos_of_bot_eq_bot_of_top_eq_top_of_length_pos\n\n",
 "length_of_list":
 "theorem length_of_list (l : List X) (hl : l ≠ []) (hc : List.Chain' is_maximal l) :\n    (ofList l hl hc).length = l.length - 1 :=\n  rfl\n#align length_of_list length_of_list\n\n",
 "length_eq_zero_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero":
 "theorem length_eq_zero_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero {s₁ s₂ : CompositionSeries X}\n    (hb : s₁.bot = s₂.bot) (ht : s₁.top = s₂.top) (hs₁ : s₁.length = 0) : s₂.length = 0 :=\n  by\n  have : s₁.bot = s₁.top := congr_arg s₁ (Fin.ext (by simp [hs₁]))\n  have : Fin.last s₂.length = (0 : Fin s₂.length.succ) := s₂.injective (hb.symm.trans (this.trans ht)).symm\n  simpa [Fin.ext_iff]\n#align length_eq_zero_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero length_eq_zero_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero\n\n",
 "length_eq":
 "theorem length_eq {s₁ s₂ : CompositionSeries X} (h : Equivalent s₁ s₂) : s₁.length = s₂.length := by\n  simpa using Fintype.card_congr h.some\n#align length_eq length_eq\n\n",
 "le_top_of_mem":
 "theorem le_top_of_mem {s : CompositionSeries X} {x : X} (hx : x ∈ s) : x ≤ s.top :=\n  let ⟨i, hi⟩ := Set.mem_range.2 hx\n  hi ▸ le_top _\n#align le_top_of_mem le_top_of_mem\n\n",
 "le_top":
 "#print le_top /-\n@[simp]\ntheorem le_top {s : CompositionSeries X} (i : Fin (s.length + 1)) : s i ≤ s.top :=\n  s.strict_mono.monotone (Fin.le_last _)\n#align le_top le_top\n-/\n\n",
 "jordan_holder":
 "/-- The **Jordan-Hölder** theorem, stated for any `jordan_holder_lattice`.\nIf two composition series start and finish at the same place, they are equivalent. -/\ntheorem jordan_holder (s₁ s₂ : CompositionSeries X) (hb : s₁.bot = s₂.bot) (ht : s₁.top = s₂.top) : Equivalent s₁ s₂ :=\n  by\n  induction' hle : s₁.length with n ih generalizing s₁ s₂\n  · rw [eq_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero hb ht hle]\n  · have h0s₂ : 0 < s₂.length := length_pos_of_bot_eq_bot_of_top_eq_top_of_length_pos hb ht (hle.symm ▸ nat.succ_pos _)\n    rcases exists_top_eq_snoc_equivalant s₁ s₂.erase_top.top (ht.symm ▸ is_maximal_erase_top_top h0s₂)\n        (hb.symm ▸ s₂.bot_erase_top ▸ bot_le_of_mem (top_mem _)) with\n      ⟨t, htb, htl, htt, hteq⟩\n    have := ih t s₂.erase_top (by simp [htb, ← hb]) htt (Nat.succ_inj'.1 (htl.trans hle))\n    refine' hteq.trans _\n    conv_rhs => rw [eq_snoc_erase_top h0s₂]\n    simp only [ht]\n    exact equivalent.snoc this (by simp [htt, (is_maximal_erase_top_top h0s₂).iso_refl])\n#align jordan_holder jordan_holder\n\n",
 "iso_refl":
 "theorem is_maximal.iso_refl {x y : X} (h : is_maximal x y) : iso (x, y) (x, y) :=\n  second_iso_of_eq h (sup_eq_right.2 (le_of_lt (lt_of_is_maximal h))) (inf_eq_left.2 (le_of_lt (lt_of_is_maximal h)))\n#align is_maximal.iso_refl is_maximal.iso_refl\n\n",
 "is_maximal_of_eq_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem is_maximal_of_eq_inf (x b : X) {a y : X} (ha : «expr ⊓ » x y = a) (hxy : x ≠ y) (hxb : is_maximal x b)\n    (hyb : is_maximal y b) : is_maximal a y :=\n  by\n  have hb : «expr ⊔ » x y = b := sup_eq_of_is_maximal hxb hyb hxy\n  substs a b\n  exact is_maximal_inf_right_of_is_maximal_sup hxb hyb\n#align is_maximal_of_eq_inf is_maximal_of_eq_inf\n\n",
 "is_maximal_inf_right_of_is_maximal_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-\nCopyright (c) 2021 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\ntheorem is_maximal_inf_right_of_is_maximal_sup {x y : X} (hxz : is_maximal x («expr ⊔ » x y))\n    (hyz : is_maximal y («expr ⊔ » x y)) : is_maximal («expr ⊓ » x y) y :=\n  by\n  rw [inf_comm]\n  rw [sup_comm] at hxz hyz\n  exact is_maximal_inf_left_of_is_maximal_sup hyz hxz\n#align is_maximal_inf_right_of_is_maximal_sup is_maximal_inf_right_of_is_maximal_sup\n\n",
 "is_maximal_erase_top_top":
 "theorem is_maximal_erase_top_top {s : CompositionSeries X} (h : 0 < s.length) : is_maximal s.erase_top.top s.top :=\n  by\n  have : s.length - 1 + 1 = s.length := by conv_rhs => rw [← nat.succ_sub_one s.length] <;> rw [nat.succ_sub h]\n  rw [top_erase_top, top]\n  convert s.step ⟨s.length - 1, nat.sub_lt h zero_lt_one⟩ <;> ext <;> simp [this]\n#align is_maximal_erase_top_top is_maximal_erase_top_top\n\n",
 "injective":
 "protected theorem injective (s : CompositionSeries X) : function.injective s :=\n  s.strict_mono.injective\n#align injective injective\n\n",
 "inj":
 "@[simp]\nprotected theorem inj (s : CompositionSeries X) {i j : Fin s.length.succ} : s i = s j ↔ i = j :=\n  s.injective.eq_iff\n#align inj inj\n\n",
 "forall_mem_eq_of_length_eq_zero":
 "theorem forall_mem_eq_of_length_eq_zero {s : CompositionSeries X} (hs : s.length = 0) {x y} (hx : x ∈ s) (hy : y ∈ s) :\n    x = y :=\n  by_contradiction fun hxy => pos_iff_ne_zero.1 (length_pos_of_mem_ne hx hy hxy) hs\n#align forall_mem_eq_of_length_eq_zero forall_mem_eq_of_length_eq_zero\n\n",
 "ext_fun":
 "/-- Two `composition_series` are equal if they are the same length and\nhave the same `i`th element for every `i` -/\ntheorem ext_fun {s₁ s₂ : CompositionSeries X} (hl : s₁.length = s₂.length)\n    (h : ∀ i, s₁ i = s₂ (Fin.cast (congr_arg nat.succ hl) i)) : s₁ = s₂ :=\n  by\n  cases s₁; cases s₂\n  dsimp at *\n  subst hl\n  simpa [Function.funext_iff] using h\n#align ext_fun ext_fun\n\n",
 "ext":
 "/-- Two `composition_series` are equal if they have the same elements. See also `ext_fun`. -/\n@[ext]\ntheorem ext {s₁ s₂ : CompositionSeries X} (h : ∀ x, x ∈ s₁ ↔ x ∈ s₂) : s₁ = s₂ :=\n  toList_injective <|\n    List.eq_of_perm_of_sorted\n      (by\n        classical exact\n            List.perm_of_nodup_nodup_toFinset_eq s₁.to_list_nodup s₂.to_list_nodup (Finset.ext <| by simp [*]))\n      s₁.to_list_sorted s₂.to_list_sorted\n#align ext ext\n\n",
 "exists_top_eq_snoc_equivalant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- Given a `composition_series`, `s`, and an element `x`\nsuch that `x` is maximal inside `s.top` there is a series, `t`,\nsuch that `t.top = x`, `t.bot = s.bot`\nand `snoc t s.top _` is equivalent to `s`. -/\ntheorem exists_top_eq_snoc_equivalant (s : CompositionSeries X) (x : X) (hm : is_maximal x s.top) (hb : s.bot ≤ x) :\n    ∃ t : CompositionSeries X,\n      t.bot = s.bot ∧ t.length + 1 = s.length ∧ ∃ htx : t.top = x, Equivalent s (snoc t s.top (htx.symm ▸ hm)) :=\n  by\n  induction' hn : s.length with n ih generalizing s x\n  ·\n    exact\n      (ne_of_gt (lt_of_le_of_lt hb (lt_of_is_maximal hm)) (forall_mem_eq_of_length_eq_zero hn s.top_mem s.bot_mem)).elim\n  · have h0s : 0 < s.length := hn.symm ▸ nat.succ_pos _\n    by_cases hetx : s.erase_top.top = x\n    · use s.erase_top\n      simp [← hetx, hn]\n    · have imxs : is_maximal («expr ⊓ » x s.erase_top.top) s.erase_top.top :=\n        is_maximal_of_eq_inf x s.top rfl (ne.symm hetx) hm (is_maximal_erase_top_top h0s)\n      have := ih _ _ imxs (le_inf (by simpa) (le_top_of_mem s.erase_top.bot_mem)) (by simp [hn])\n      rcases this with ⟨t, htb, htl, htt, hteqv⟩\n      have hmtx : is_maximal t.top x :=\n        is_maximal_of_eq_inf s.erase_top.top s.top (by rw [inf_comm, htt]) hetx (is_maximal_erase_top_top h0s) hm\n      use snoc t x hmtx\n      refine' ⟨by simp [htb], by simp [htl], by simp, _⟩\n      have :\n        s.equivalent\n          ((snoc t s.erase_top.top (htt.symm ▸ imxs)).snoc s.top (by simpa using is_maximal_erase_top_top h0s)) :=\n        by\n        conv_lhs => rw [eq_snoc_erase_top h0s]\n        exact equivalent.snoc hteqv (by simpa using (is_maximal_erase_top_top h0s).iso_refl)\n      refine' this.trans _\n      refine' equivalent.snoc_snoc_swap _ _\n      ·\n        exact\n          iso_symm\n            (second_iso_of_eq hm (sup_eq_of_is_maximal hm (is_maximal_erase_top_top h0s) (ne.symm hetx)) htt.symm)\n      ·\n        exact\n          second_iso_of_eq (is_maximal_erase_top_top h0s) (sup_eq_of_is_maximal (is_maximal_erase_top_top h0s) hm hetx)\n            (by rw [inf_comm, htt])\n#align exists_top_eq_snoc_equivalant exists_top_eq_snoc_equivalant\n\n",
 "erase_top_top_le":
 "theorem erase_top_top_le (s : CompositionSeries X) : s.erase_top.top ≤ s.top := by\n  simp [erase_top, top, s.strict_mono.le_iff_le, Fin.le_iff_val_le_val, tsub_le_self]\n#align erase_top_top_le erase_top_top_le\n\n",
 "eq_snoc_erase_top":
 "theorem eq_snoc_erase_top {s : CompositionSeries X} (h : 0 < s.length) :\n    s = snoc (eraseTop s) s.top (isMaximal_eraseTop_top h) :=\n  by\n  ext x\n  simp [mem_snoc, mem_erase_top h]\n  by_cases h : x = s.top <;> simp [*, s.top_mem]\n#align eq_snoc_erase_top eq_snoc_erase_top\n\n",
 "eq_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero":
 "theorem eq_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero {s₁ s₂ : CompositionSeries X} (hb : s₁.bot = s₂.bot)\n    (ht : s₁.top = s₂.top) (hs₁0 : s₁.length = 0) : s₁ = s₂ :=\n  by\n  have : ∀ x, x ∈ s₁ ↔ x = s₁.top := fun x =>\n    ⟨fun hx => forall_mem_eq_of_length_eq_zero hs₁0 hx s₁.top_mem, fun hx => hx.symm ▸ s₁.top_mem⟩\n  have : ∀ x, x ∈ s₂ ↔ x = s₂.top := fun x =>\n    ⟨fun hx =>\n      forall_mem_eq_of_length_eq_zero (length_eq_zero_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero hb ht hs₁0) hx\n        s₂.top_mem,\n      fun hx => hx.symm ▸ s₂.top_mem⟩\n  ext\n  simp [*]\n#align eq_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero eq_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero\n\n",
 "coe_fn_mk":
 "@[simp]\ntheorem coe_fn_mk (length : ℕ) (series step) :\n    (@composition_series.mk X _ _ length series step : Fin length.succ → X) = series :=\n  rfl\n#align coe_fn_mk coe_fn_mk\n\n",
 "coe_append":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_append (s₁ s₂ : CompositionSeries X) (h) :\n    «expr⇑ » (s₁.append s₂ h) = Matrix.vecAppend (nat.add_succ _ _).symm (s₁ ∘ Fin.castSucc) s₂ :=\n  rfl\n#align coe_append coe_append\n\n",
 "chain'_to_list":
 "theorem chain'_to_list (s : CompositionSeries X) : List.Chain' is_maximal s.to_list :=\n  List.chain'_iff_nthLe.2\n    (by\n      intro i hi\n      simp only [to_list, List.nthLe_ofFn']\n      rw [length_to_list] at hi\n      exact s.step ⟨i, hi⟩)\n#align chain'_to_list chain'_to_list\n\n",
 "bot_snoc":
 "@[simp]\ntheorem bot_snoc (s : CompositionSeries X) (x : X) (hsat : is_maximal s.top x) : (snoc s x hsat).bot = s.bot := by\n  rw [bot, bot, ← snoc_cast_succ s _ _ 0, Fin.castSucc_zero]\n#align bot_snoc bot_snoc\n\n",
 "bot_mem":
 "theorem bot_mem (s : CompositionSeries X) : s.bot ∈ s :=\n  mem_def.2 (Set.mem_range.2 ⟨0, rfl⟩)\n#align bot_mem bot_mem\n\n",
 "bot_le_of_mem":
 "theorem bot_le_of_mem {s : CompositionSeries X} {x : X} (hx : x ∈ s) : s.bot ≤ x :=\n  let ⟨i, hi⟩ := Set.mem_range.2 hx\n  hi ▸ bot_le _\n#align bot_le_of_mem bot_le_of_mem\n\n",
 "bot_le":
 "#print bot_le /-\n@[simp]\ntheorem bot_le {s : CompositionSeries X} (i : Fin (s.length + 1)) : s.bot ≤ s i :=\n  s.strict_mono.monotone (Fin.zero_le _)\n#align bot_le bot_le\n-/\n\n",
 "bot_erase_top":
 "@[simp]\ntheorem bot_erase_top (s : CompositionSeries X) : s.erase_top.bot = s.bot :=\n  rfl\n#align bot_erase_top bot_erase_top\n\n",
 "append_succ_nat_add_aux":
 "theorem append_succ_nat_add_aux (i : Fin n) :\n    Matrix.vecAppend (nat.add_succ _ _).symm (a ∘ Fin.castSucc) b (Fin.natAdd m i).succ = b i.succ :=\n  by\n  cases' i with i hi\n  simp only [Matrix.vecAppend_eq_ite, add_assoc, nat.not_lt_zero, Fin.natAdd_mk, add_lt_iff_neg_left,\n    add_tsub_cancel_left, Fin.succ_mk, dif_neg, not_false_iff, Fin.val_mk]\n#align append_succ_nat_add_aux append_succ_nat_add_aux\n\n",
 "append_succ_nat_add":
 "@[simp]\ntheorem append_succ_nat_add {s₁ s₂ : CompositionSeries X} (h : s₁.top = s₂.bot) (i : Fin s₂.length) :\n    append s₁ s₂ h (Fin.natAdd s₁.length i).succ = s₂ i.succ := by rw [coe_append, append_succ_nat_add_aux _ _ i]\n#align append_succ_nat_add append_succ_nat_add\n\n",
 "append_succ_cast_add_aux":
 "theorem append_succ_cast_add_aux (i : Fin m) (h : a (Fin.last _) = b 0) :\n    Matrix.vecAppend (nat.add_succ _ _).symm (a ∘ Fin.castSucc) b (Fin.castAdd n i).succ = a i.succ :=\n  by\n  cases' i with i hi\n  simp only [Matrix.vecAppend_eq_ite, hi, Fin.succ_mk, Function.comp_apply, Fin.castSucc_mk, Fin.val_mk, Fin.castAdd_mk]\n  split_ifs\n  · rfl\n  · have : i + 1 = m := le_antisymm hi (le_of_not_gt h_1)\n    calc\n      b ⟨i + 1 - m, by simp [this]⟩ = b 0 := congr_arg b (by simp [Fin.ext_iff, this])\n      _ = a (Fin.last _) := h.symm\n      _ = _ := congr_arg a (by simp [Fin.ext_iff, this])\n      \n#align append_succ_cast_add_aux append_succ_cast_add_aux\n\n",
 "append_succ_cast_add":
 "@[simp]\ntheorem append_succ_cast_add {s₁ s₂ : CompositionSeries X} (h : s₁.top = s₂.bot) (i : Fin s₁.length) :\n    append s₁ s₂ h (Fin.castAdd s₂.length i).succ = s₁ i.succ := by rw [coe_append, append_succ_cast_add_aux _ _ _ h]\n#align append_succ_cast_add append_succ_cast_add\n\n",
 "append_nat_add_aux":
 "theorem append_nat_add_aux (i : Fin n) :\n    Matrix.vecAppend (nat.add_succ _ _).symm (a ∘ Fin.castSucc) b (Fin.natAdd m i).cast_succ = b i.cast_succ :=\n  by\n  cases i\n  simp only [Matrix.vecAppend_eq_ite, nat.not_lt_zero, Fin.natAdd_mk, add_lt_iff_neg_left, add_tsub_cancel_left,\n    dif_neg, Fin.castSucc_mk, not_false_iff, Fin.val_mk]\n#align append_nat_add_aux append_nat_add_aux\n\n",
 "append_nat_add":
 "@[simp]\ntheorem append_nat_add {s₁ s₂ : CompositionSeries X} (h : s₁.top = s₂.bot) (i : Fin s₂.length) :\n    append s₁ s₂ h (Fin.natAdd s₁.length i).cast_succ = s₂ i.cast_succ := by rw [coe_append, append_nat_add_aux _ _ i]\n#align append_nat_add append_nat_add\n\n",
 "append_cast_add_aux":
 "-- TODO: move these to `vec_notation` and rename them to better describe their statement\ntheorem append_cast_add_aux (i : Fin m) :\n    Matrix.vecAppend (nat.add_succ _ _).symm (a ∘ Fin.castSucc) b (Fin.castAdd n i).cast_succ = a i.cast_succ :=\n  by\n  cases i\n  simp [Matrix.vecAppend_eq_ite, *]\n#align append_cast_add_aux append_cast_add_aux\n\n",
 "append_cast_add":
 "@[simp]\ntheorem append_cast_add {s₁ s₂ : CompositionSeries X} (h : s₁.top = s₂.bot) (i : Fin s₁.length) :\n    append s₁ s₂ h (Fin.castAdd s₂.length i).cast_succ = s₁ i.cast_succ := by rw [coe_append, append_cast_add_aux _ _ i]\n#align append_cast_add append_cast_add\n\n",
 "append":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem append {s₁ s₂ t₁ t₂ : CompositionSeries X} (hs : s₁.top = s₂.bot) (ht : t₁.top = t₂.bot) (h₁ : Equivalent s₁ t₁)\n    (h₂ : Equivalent s₂ t₂) : Equivalent (append s₁ s₂ hs) (append t₁ t₂ ht) :=\n  let e : «expr ≃ » (Fin (s₁.length + s₂.length)) (Fin (t₁.length + t₂.length)) :=\n    calc\n      «expr ≃ » (Fin (s₁.length + s₂.length)) (Sum (Fin s₁.length) (Fin s₂.length)) := finSumFinEquiv.symm\n      «expr ≃ » _ (Sum (Fin t₁.length) (Fin t₂.length)) := (Equiv.sumCongr h₁.some h₂.some)\n      «expr ≃ » _ (Fin (t₁.length + t₂.length)) := finSumFinEquiv\n      \n  ⟨e, by\n    intro i\n    refine' Fin.addCases _ _ i\n    · intro i\n      simpa [top, bot] using h₁.some_spec i\n    · intro i\n      simpa [top, bot] using h₂.some_spec i⟩\n#align append append\n\n",
 "StrictMono":
 "#print StrictMono /-\nprotected theorem StrictMono (s : CompositionSeries X) : StrictMono s :=\n  Fin.strictMono_iff_lt_succ.2 s.lt_succ\n#align strict_mono StrictMono\n-/\n\n"}