{"upperBounds_univ":
 "#print NoMaxOrder.upperBounds_univ /-\n@[simp]\ntheorem NoMaxOrder.upperBounds_univ [NoMaxOrder α] : upperBounds (univ : set α) = ∅ :=\n  eq_empty_of_subset_empty fun b hb =>\n    let ⟨x, hx⟩ := exists_gt b\n    not_le_of_lt hx (hb trivial)\n#align no_max_order.upper_bounds_univ NoMaxOrder.upperBounds_univ\n-/\n\n",
 "upperBounds_union":
 "#print upperBounds_union /-\n@[simp]\ntheorem upperBounds_union : upperBounds (s ∪ t) = upperBounds s ∩ upperBounds t :=\n  Subset.antisymm (fun b hb => ⟨fun x hx => hb (or.inl hx), fun x hx => hb (or.inr hx)⟩) fun b hb x hx =>\n    hx.elim (fun hs => hb.1 hs) fun ht => hb.2 ht\n#align upper_bounds_union upperBounds_union\n-/\n\n",
 "upperBounds_singleton":
 "#print upperBounds_singleton /-\n@[simp]\ntheorem upperBounds_singleton : upperBounds {a} = Ici a :=\n  isLUB_singleton.upper_bounds_eq\n#align upper_bounds_singleton upperBounds_singleton\n-/\n\n",
 "upperBounds_mono_set":
 "#print upperBounds_mono_set /-\ntheorem upperBounds_mono_set ⦃s t : set α⦄ (hst : s ⊆ t) : upperBounds t ⊆ upperBounds s := fun b hb x h => hb <| hst h\n#align upper_bounds_mono_set upperBounds_mono_set\n-/\n\n",
 "upperBounds_mono_mem":
 "#print upperBounds_mono_mem /-\ntheorem upperBounds_mono_mem ⦃a b⦄ (hab : a ≤ b) : a ∈ upperBounds s → b ∈ upperBounds s := fun ha x h =>\n  le_trans (ha h) hab\n#align upper_bounds_mono_mem upperBounds_mono_mem\n-/\n\n",
 "upperBounds_mono":
 "#print upperBounds_mono /-\ntheorem upperBounds_mono ⦃s t : set α⦄ (hst : s ⊆ t) ⦃a b⦄ (hab : a ≤ b) : a ∈ upperBounds t → b ∈ upperBounds s :=\n  fun ha => upperBounds_mono_set hst <| upperBounds_mono_mem hab ha\n#align upper_bounds_mono upperBounds_mono\n-/\n\n",
 "upperBounds_insert":
 "#print upperBounds_insert /-\n@[simp]\ntheorem upperBounds_insert (a : α) (s : set α) : upperBounds (insert a s) = Ici a ∩ upperBounds s := by\n  rw [insert_eq, upperBounds_union, upperBounds_singleton]\n#align upper_bounds_insert upperBounds_insert\n-/\n\n",
 "upperBounds_eq":
 "#print IsGreatest.upperBounds_eq /-\ntheorem IsGreatest.upperBounds_eq (h : IsGreatest s a) : upperBounds s = Ici a :=\n  h.is_lub.upper_bounds_eq\n#align is_greatest.upper_bounds_eq IsGreatest.upperBounds_eq\n-/\n\n",
 "upperBounds_empty":
 "#print upperBounds_empty /-\n@[simp]\ntheorem upperBounds_empty : upperBounds (∅ : set α) = univ := by\n  simp only [upperBounds, eq_univ_iff_forall, mem_set_of_eq, ball_empty_iff, forall_true_iff]\n#align upper_bounds_empty upperBounds_empty\n-/\n\n",
 "upperBounds_Ioo":
 "#print upperBounds_Ioo /-\ntheorem upperBounds_Ioo {a b : γ} (hab : a < b) : upperBounds (Ioo a b) = Ici b :=\n  (isLUB_Ioo hab).upper_bounds_eq\n#align upper_bounds_Ioo upperBounds_Ioo\n-/\n\n",
 "upperBounds_Ioc":
 "#print upperBounds_Ioc /-\ntheorem upperBounds_Ioc (h : a < b) : upperBounds (Ioc a b) = Ici b :=\n  (isLUB_Ioc h).upper_bounds_eq\n#align upper_bounds_Ioc upperBounds_Ioc\n-/\n\n",
 "upperBounds_Iio":
 "#print upperBounds_Iio /-\ntheorem upperBounds_Iio {a : γ} : upperBounds (Iio a) = Ici a :=\n  isLUB_Iio.upper_bounds_eq\n#align upper_bounds_Iio upperBounds_Iio\n-/\n\n",
 "upperBounds_Iic":
 "#print upperBounds_Iic /-\ntheorem upperBounds_Iic : upperBounds (Iic a) = Ici a :=\n  isLUB_Iic.upper_bounds_eq\n#align upper_bounds_Iic upperBounds_Iic\n-/\n\n",
 "upperBounds_Ico":
 "#print upperBounds_Ico /-\ntheorem upperBounds_Ico {a b : γ} (hab : a < b) : upperBounds (Ico a b) = Ici b :=\n  (isLUB_Ico hab).upper_bounds_eq\n#align upper_bounds_Ico upperBounds_Ico\n-/\n\n",
 "upperBounds_Icc":
 "#print upperBounds_Icc /-\ntheorem upperBounds_Icc (h : a ≤ b) : upperBounds (Icc a b) = Ici b :=\n  (isLUB_Icc h).upper_bounds_eq\n#align upper_bounds_Icc upperBounds_Icc\n-/\n\n",
 "unique":
 "#print IsGLB.unique /-\ntheorem IsGLB.unique (Ha : IsGLB s a) (Hb : IsGLB s b) : a = b :=\n  Ha.unique Hb\n#align is_glb.unique IsGLB.unique\n-/\n\n",
 "union_upperBounds_subset_upperBounds_inter":
 "#print union_upperBounds_subset_upperBounds_inter /-\ntheorem union_upperBounds_subset_upperBounds_inter : upperBounds s ∪ upperBounds t ⊆ upperBounds (s ∩ t) :=\n  union_subset (upperBounds_mono_set <| inter_subset_left _ _) (upperBounds_mono_set <| inter_subset_right _ _)\n#align union_upper_bounds_subset_upper_bounds_inter union_upperBounds_subset_upperBounds_inter\n-/\n\n",
 "union_lowerBounds_subset_lowerBounds_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print union_lowerBounds_subset_lowerBounds_inter /-\ntheorem union_lowerBounds_subset_lowerBounds_inter : lowerBounds s ∪ lowerBounds t ⊆ lowerBounds (s ∩ t) :=\n  @union_upperBounds_subset_upperBounds_inter («expr ᵒᵈ» α) _ s t\n#align union_lower_bounds_subset_lower_bounds_inter union_lowerBounds_subset_lowerBounds_inter\n-/\n\n",
 "union":
 "#print IsGreatest.union /-\n/-- If `a` is the greatest element of `s` and `b` is the greatest element of `t`,\nthen `max a b` is the greatest element of `s ∪ t`. -/\ntheorem IsGreatest.union [linear_order γ] {a b : γ} {s t : set γ} (ha : IsGreatest s a) (hb : IsGreatest t b) :\n    IsGreatest (s ∪ t) (max a b) :=\n  ⟨by cases' le_total a b with h h <;> simp [h, ha.1, hb.1], (ha.is_lub.union hb.is_lub).1⟩\n#align is_greatest.union IsGreatest.union\n-/\n\n",
 "top_mem_upperBounds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print top_mem_upperBounds /-\ntheorem top_mem_upperBounds [OrderTop α] (s : set α) : «expr⊤» ∈ upperBounds s := fun _ _ => le_top\n#align top_mem_upper_bounds top_mem_upperBounds\n-/\n\n",
 "subsingleton_of_isLUB_le_isGLB":
 "#print Set.subsingleton_of_isLUB_le_isGLB /-\ntheorem Set.subsingleton_of_isLUB_le_isGLB (Ha : IsGLB s a) (Hb : IsLUB s b) (hab : b ≤ a) : s.subsingleton :=\n  fun x hx y hy => le_antisymm (le_of_isLUB_le_isGLB Ha Hb hab hx hy) (le_of_isLUB_le_isGLB Ha Hb hab hy hx)\n#align set.subsingleton_of_is_lub_le_is_glb Set.subsingleton_of_isLUB_le_isGLB\n-/\n\n",
 "subset_upperBounds_lowerBounds":
 "#print subset_upperBounds_lowerBounds /-\ntheorem subset_upperBounds_lowerBounds (s : set α) : s ⊆ upperBounds (lowerBounds s) := fun x hx y hy => hy hx\n#align subset_upper_bounds_lower_bounds subset_upperBounds_lowerBounds\n-/\n\n",
 "subset_lowerBounds_upperBounds":
 "#print subset_lowerBounds_upperBounds /-\ntheorem subset_lowerBounds_upperBounds (s : set α) : s ⊆ lowerBounds (upperBounds s) := fun x hx y hy => hy hx\n#align subset_lower_bounds_upper_bounds subset_lowerBounds_upperBounds\n-/\n\n",
 "of_subset_of_superset":
 "#print IsGLB.of_subset_of_superset /-\n/-- If `a` is a greatest lower bound for sets `s` and `p`, then it is a greater lower bound for any\nset `t`, `s ⊆ t ⊆ p`. -/\ntheorem IsGLB.of_subset_of_superset {s t p : set α} (hs : IsGLB s a) (hp : IsGLB p a) (hst : s ⊆ t) (htp : t ⊆ p) :\n    IsGLB t a :=\n  hs.dual.of_subset_of_superset hp hst htp\n#align is_glb.of_subset_of_superset IsGLB.of_subset_of_superset\n-/\n\n",
 "of_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsLUB.of_image /-\ntheorem IsLUB.of_image [preorder α] [preorder β] {f : α → β} (hf : ∀ {x y}, f x ≤ f y ↔ x ≤ y) {s : set α} {x : α}\n    (hx : IsLUB («expr '' » f s) (f x)) : IsLUB s x :=\n  @IsGLB.of_image («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ f (fun x y => hf) _ _ hx\n#align is_lub.of_image IsLUB.of_image\n-/\n\n",
 "not_bddBelow_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print not_bddBelow_univ /-\n@[simp]\ntheorem not_bddBelow_univ [NoMinOrder α] : ¬BddBelow (univ : set α) :=\n  @not_bddAbove_univ («expr ᵒᵈ» α) _ _\n#align not_bdd_below_univ not_bddBelow_univ\n-/\n\n",
 "not_bddBelow_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print not_bddBelow_iff' /-\n/-- A set `s` is not bounded below if and only if for each `x` there exists `y ∈ s` such that `x`\nis not less than or equal to `y`. This version only assumes `preorder` structure and uses\n`¬(x ≤ y)`. A version for linear orders is called `not_bdd_below_iff`. -/\ntheorem not_bddBelow_iff' : ¬BddBelow s ↔ ∀ x, ∃ y ∈ s, ¬x ≤ y :=\n  @not_bddAbove_iff' («expr ᵒᵈ» α) _ _\n#align not_bdd_below_iff' not_bddBelow_iff'\n-/\n\n",
 "not_bddBelow_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print not_bddBelow_iff /-\n/-- A set `s` is not bounded below if and only if for each `x` there exists `y ∈ s` that is less\nthan `x`. A version for preorders is called `not_bdd_below_iff'`. -/\ntheorem not_bddBelow_iff {α : Type _} [linear_order α] {s : set α} : ¬BddBelow s ↔ ∀ x, ∃ y ∈ s, y < x :=\n  @not_bddAbove_iff («expr ᵒᵈ» α) _ _\n#align not_bdd_below_iff not_bddBelow_iff\n-/\n\n",
 "not_bddAbove_univ":
 "#print not_bddAbove_univ /-\n@[simp]\ntheorem not_bddAbove_univ [NoMaxOrder α] : ¬BddAbove (univ : set α) := by simp [BddAbove]\n#align not_bdd_above_univ not_bddAbove_univ\n-/\n\n",
 "not_bddAbove_iff'":
 "#print not_bddAbove_iff' /-\n/-- A set `s` is not bounded above if and only if for each `x` there exists `y ∈ s` such that `x`\nis not greater than or equal to `y`. This version only assumes `preorder` structure and uses\n`¬(y ≤ x)`. A version for linear orders is called `not_bdd_above_iff`. -/\ntheorem not_bddAbove_iff' : ¬BddAbove s ↔ ∀ x, ∃ y ∈ s, ¬y ≤ x := by simp [BddAbove, upperBounds, Set.Nonempty]\n#align not_bdd_above_iff' not_bddAbove_iff'\n-/\n\n",
 "not_bddAbove_iff":
 "#print not_bddAbove_iff /-\n/-- A set `s` is not bounded above if and only if for each `x` there exists `y ∈ s` that is greater\nthan `x`. A version for preorders is called `not_bdd_above_iff'`. -/\ntheorem not_bddAbove_iff {α : Type _} [linear_order α] {s : set α} : ¬BddAbove s ↔ ∀ x, ∃ y ∈ s, x < y := by\n  simp only [not_bddAbove_iff', not_le]\n#align not_bdd_above_iff not_bddAbove_iff\n-/\n\n",
 "nonempty_of_not_bddBelow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print nonempty_of_not_bddBelow /-\ntheorem nonempty_of_not_bddBelow [ha : nonempty α] (h : ¬BddBelow s) : s.nonempty :=\n  @nonempty_of_not_bddAbove («expr ᵒᵈ» α) _ _ _ h\n#align nonempty_of_not_bdd_below nonempty_of_not_bddBelow\n-/\n\n",
 "nonempty_of_not_bddAbove":
 "#print nonempty_of_not_bddAbove /-\ntheorem nonempty_of_not_bddAbove [ha : nonempty α] (h : ¬BddAbove s) : s.nonempty :=\n  nonempty.elim ha fun x => (not_bddAbove_iff'.1 h x).imp fun a ha => ha.fst\n#align nonempty_of_not_bdd_above nonempty_of_not_bddAbove\n-/\n\n",
 "nonempty":
 "#print IsGLB.nonempty /-\ntheorem IsGLB.nonempty [NoMaxOrder α] (hs : IsGLB s a) : s.nonempty :=\n  hs.dual.nonempty\n#align is_glb.nonempty IsGLB.nonempty\n-/\n\n",
 "mono":
 "#print IsGLB.mono /-\ntheorem IsGLB.mono (ha : IsGLB s a) (hb : IsGLB t b) (hst : s ⊆ t) : b ≤ a :=\n  hb.mono ha <| lowerBounds_mono_set hst\n#align is_glb.mono IsGLB.mono\n-/\n\n",
 "mem_upper_bounds_image_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_upper_bounds_image_self : a ∈ lowerBounds t → a ∈ t → f a ∈ upperBounds («expr '' » f t) :=\n  Hf.dual_right.mem_lower_bounds_image_self\n#align mem_upper_bounds_image_self mem_upper_bounds_image_self\n\n",
 "mem_upper_bounds_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_upper_bounds_image : a ∈ lowerBounds s → f a ∈ upperBounds («expr '' » f s) :=\n  hf.dual_right.mem_lower_bounds_image\n#align mem_upper_bounds_image mem_upper_bounds_image\n\n",
 "mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds":
 "#print mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds /-\ntheorem mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds (ha : a ∈ lowerBounds s) (hb : b ∈ upperBounds t) :\n    f a b ∈ upperBounds (image2 f s t) :=\n  forall_image2_iff.2 fun x hx y hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n#align\n  mem_upper_bounds_image2_of_mem_upper_bounds_of_mem_upper_bounds mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds\n-/\n\n",
 "mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds":
 "#print mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds /-\ntheorem mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds (ha : a ∈ upperBounds s) (hb : b ∈ lowerBounds t) :\n    f a b ∈ upperBounds (image2 f s t) :=\n  forall_image2_iff.2 fun x hx y hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n#align\n  mem_upper_bounds_image2_of_mem_upper_bounds_of_mem_lower_bounds mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds\n-/\n\n",
 "mem_upperBounds_image2_of_mem_lowerBounds":
 "#print mem_upperBounds_image2_of_mem_lowerBounds /-\ntheorem mem_upperBounds_image2_of_mem_lowerBounds (ha : a ∈ lowerBounds s) (hb : b ∈ lowerBounds t) :\n    f a b ∈ upperBounds (image2 f s t) :=\n  forall_image2_iff.2 fun x hx y hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n#align mem_upper_bounds_image2_of_mem_lower_bounds mem_upperBounds_image2_of_mem_lowerBounds\n-/\n\n",
 "mem_upperBounds_image2":
 "#print mem_upperBounds_image2 /-\ntheorem mem_upperBounds_image2 (ha : a ∈ upperBounds s) (hb : b ∈ upperBounds t) : f a b ∈ upperBounds (image2 f s t) :=\n  forall_image2_iff.2 fun x hx y hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n#align mem_upper_bounds_image2 mem_upperBounds_image2\n-/\n\n",
 "mem_upperBounds":
 "#print mem_upperBounds /-\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Yury Kudryashov\n-/\ntheorem mem_upperBounds : a ∈ upperBounds s ↔ ∀ x ∈ s, x ≤ a :=\n  iff.rfl\n#align mem_upper_bounds mem_upperBounds\n-/\n\n",
 "mem_lower_bounds_image_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_lower_bounds_image_self : a ∈ upperBounds t → a ∈ t → f a ∈ lowerBounds («expr '' » f t) :=\n  Hf.dual_right.mem_upper_bounds_image_self\n#align mem_lower_bounds_image_self mem_lower_bounds_image_self\n\n",
 "mem_lower_bounds_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_lower_bounds_image : a ∈ upperBounds s → f a ∈ lowerBounds («expr '' » f s) :=\n  hf.dual_right.mem_upper_bounds_image\n#align mem_lower_bounds_image mem_lower_bounds_image\n\n",
 "mem_lowerBounds_image2_of_mem_upperBounds":
 "#print mem_lowerBounds_image2_of_mem_upperBounds /-\ntheorem mem_lowerBounds_image2_of_mem_upperBounds (ha : a ∈ upperBounds s) (hb : b ∈ upperBounds t) :\n    f a b ∈ lowerBounds (image2 f s t) :=\n  forall_image2_iff.2 fun x hx y hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n#align mem_lower_bounds_image2_of_mem_upper_bounds mem_lowerBounds_image2_of_mem_upperBounds\n-/\n\n",
 "mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_upperBounds":
 "#print mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_upperBounds /-\ntheorem mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_upperBounds (ha : a ∈ lowerBounds s) (hb : b ∈ upperBounds t) :\n    f a b ∈ lowerBounds (image2 f s t) :=\n  forall_image2_iff.2 fun x hx y hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n#align\n  mem_lower_bounds_image2_of_mem_lower_bounds_of_mem_upper_bounds mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_upperBounds\n-/\n\n",
 "mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds":
 "#print mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds /-\ntheorem mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds (ha : a ∈ upperBounds s) (hb : b ∈ lowerBounds t) :\n    f a b ∈ lowerBounds (image2 f s t) :=\n  forall_image2_iff.2 fun x hx y hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n#align\n  mem_lower_bounds_image2_of_mem_lower_bounds_of_mem_lower_bounds mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds\n-/\n\n",
 "mem_lowerBounds_image2":
 "#print mem_lowerBounds_image2 /-\ntheorem mem_lowerBounds_image2 (ha : a ∈ lowerBounds s) (hb : b ∈ lowerBounds t) : f a b ∈ lowerBounds (image2 f s t) :=\n  forall_image2_iff.2 fun x hx y hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n#align mem_lower_bounds_image2 mem_lowerBounds_image2\n-/\n\n",
 "mem_lowerBounds":
 "#print mem_lowerBounds /-\ntheorem mem_lowerBounds : a ∈ lowerBounds s ↔ ∀ x ∈ s, a ≤ x :=\n  iff.rfl\n#align mem_lower_bounds mem_lowerBounds\n-/\n\n",
 "map_is_least":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- An antitone map sends a least element of a set to a greatest element of its image. -/\ntheorem map_is_least : IsLeast s a → IsGreatest («expr '' » f s) (f a) :=\n  hf.dual_right.map_is_least\n#align map_is_least map_is_least\n\n",
 "map_is_greatest":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- An antitone map sends a greatest element of a set to a least element of its image. -/\ntheorem map_is_greatest : IsGreatest s a → IsLeast («expr '' » f s) (f a) :=\n  hf.dual_right.map_is_greatest\n#align map_is_greatest map_is_greatest\n\n",
 "map_bdd_below":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image under an antitone function of a set which is bounded below is bounded above. -/\ntheorem map_bdd_below : BddBelow s → BddAbove («expr '' » f s) :=\n  hf.dual_right.map_bdd_below\n#align map_bdd_below map_bdd_below\n\n",
 "map_bdd_above":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image under an antitone function of a set which is bounded above is bounded below. -/\ntheorem map_bdd_above : BddAbove s → BddBelow («expr '' » f s) :=\n  hf.dual_right.map_bdd_above\n#align map_bdd_above map_bdd_above\n\n",
 "lub_Iio_le":
 "#print lub_Iio_le /-\ntheorem lub_Iio_le (a : α) (hb : IsLUB (Set.Iio a) b) : b ≤ a :=\n  (isLUB_le_iff hb).mpr fun k hk => le_of_lt hk\n#align lub_Iio_le lub_Iio_le\n-/\n\n",
 "lub_Iio_eq_self_or_Iio_eq_Iic":
 "#print lub_Iio_eq_self_or_Iio_eq_Iic /-\ntheorem lub_Iio_eq_self_or_Iio_eq_Iic [partial_order γ] {j : γ} (i : γ) (hj : IsLUB (Set.Iio i) j) :\n    j = i ∨ Set.Iio i = Set.Iic j :=\n  by\n  cases' eq_or_lt_of_le (lub_Iio_le i hj) with hj_eq_i hj_lt_i\n  · exact or.inl hj_eq_i\n  · right\n    exact Set.ext fun k => ⟨fun hk_lt => hj.1 hk_lt, fun hk_le_j => lt_of_le_of_lt hk_le_j hj_lt_i⟩\n#align lub_Iio_eq_self_or_Iio_eq_Iic lub_Iio_eq_self_or_Iio_eq_Iic\n-/\n\n",
 "lt_isLUB_iff":
 "#print lt_isLUB_iff /-\ntheorem lt_isLUB_iff (h : IsLUB s a) : b < a ↔ ∃ c ∈ s, b < c := by\n  simp only [← not_le, isLUB_le_iff h, mem_upperBounds, not_forall]\n#align lt_is_lub_iff lt_isLUB_iff\n-/\n\n",
 "lt_isGLB_iff":
 "#print lt_isGLB_iff /-\ntheorem lt_isGLB_iff (ha : IsGLB s a) : b < a ↔ ∃ c ∈ lowerBounds s, b < c :=\n  isLUB_lt_iff ha.dual\n#align lt_is_glb_iff lt_isGLB_iff\n-/\n\n",
 "lowerBounds_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print NoMinOrder.lowerBounds_univ /-\n@[simp]\ntheorem NoMinOrder.lowerBounds_univ [NoMinOrder α] : lowerBounds (univ : set α) = ∅ :=\n  @NoMaxOrder.upperBounds_univ («expr ᵒᵈ» α) _ _\n#align no_min_order.lower_bounds_univ NoMinOrder.lowerBounds_univ\n-/\n\n",
 "lowerBounds_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print lowerBounds_union /-\n@[simp]\ntheorem lowerBounds_union : lowerBounds (s ∪ t) = lowerBounds s ∩ lowerBounds t :=\n  @upperBounds_union («expr ᵒᵈ» α) _ s t\n#align lower_bounds_union lowerBounds_union\n-/\n\n",
 "lowerBounds_singleton":
 "#print lowerBounds_singleton /-\n@[simp]\ntheorem lowerBounds_singleton : lowerBounds {a} = Iic a :=\n  isGLB_singleton.lower_bounds_eq\n#align lower_bounds_singleton lowerBounds_singleton\n-/\n\n",
 "lowerBounds_mono_set":
 "#print lowerBounds_mono_set /-\ntheorem lowerBounds_mono_set ⦃s t : set α⦄ (hst : s ⊆ t) : lowerBounds t ⊆ lowerBounds s := fun b hb x h => hb <| hst h\n#align lower_bounds_mono_set lowerBounds_mono_set\n-/\n\n",
 "lowerBounds_mono_mem":
 "#print lowerBounds_mono_mem /-\ntheorem lowerBounds_mono_mem ⦃a b⦄ (hab : a ≤ b) : b ∈ lowerBounds s → a ∈ lowerBounds s := fun hb x h =>\n  le_trans hab (hb h)\n#align lower_bounds_mono_mem lowerBounds_mono_mem\n-/\n\n",
 "lowerBounds_mono":
 "#print lowerBounds_mono /-\ntheorem lowerBounds_mono ⦃s t : set α⦄ (hst : s ⊆ t) ⦃a b⦄ (hab : a ≤ b) : b ∈ lowerBounds t → a ∈ lowerBounds s :=\n  fun hb => lowerBounds_mono_set hst <| lowerBounds_mono_mem hab hb\n#align lower_bounds_mono lowerBounds_mono\n-/\n\n",
 "lowerBounds_le_upperBounds":
 "#print lowerBounds_le_upperBounds /-\ntheorem lowerBounds_le_upperBounds (ha : a ∈ lowerBounds s) (hb : b ∈ upperBounds s) : s.nonempty → a ≤ b\n  | ⟨c, hc⟩ => le_trans (ha hc) (hb hc)\n#align lower_bounds_le_upper_bounds lowerBounds_le_upperBounds\n-/\n\n",
 "lowerBounds_insert":
 "#print lowerBounds_insert /-\n@[simp]\ntheorem lowerBounds_insert (a : α) (s : set α) : lowerBounds (insert a s) = Iic a ∩ lowerBounds s := by\n  rw [insert_eq, lowerBounds_union, lowerBounds_singleton]\n#align lower_bounds_insert lowerBounds_insert\n-/\n\n",
 "lowerBounds_eq":
 "#print IsLeast.lowerBounds_eq /-\ntheorem IsLeast.lowerBounds_eq (h : IsLeast s a) : lowerBounds s = Iic a :=\n  h.is_glb.lower_bounds_eq\n#align is_least.lower_bounds_eq IsLeast.lowerBounds_eq\n-/\n\n",
 "lowerBounds_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print lowerBounds_empty /-\n@[simp]\ntheorem lowerBounds_empty : lowerBounds (∅ : set α) = univ :=\n  @upperBounds_empty («expr ᵒᵈ» α) _\n#align lower_bounds_empty lowerBounds_empty\n-/\n\n",
 "lowerBounds_Ioo":
 "#print lowerBounds_Ioo /-\ntheorem lowerBounds_Ioo {a b : γ} (hab : a < b) : lowerBounds (Ioo a b) = Iic a :=\n  (isGLB_Ioo hab).lower_bounds_eq\n#align lower_bounds_Ioo lowerBounds_Ioo\n-/\n\n",
 "lowerBounds_Ioi":
 "#print lowerBounds_Ioi /-\ntheorem lowerBounds_Ioi {a : γ} : lowerBounds (Ioi a) = Iic a :=\n  isGLB_Ioi.lower_bounds_eq\n#align lower_bounds_Ioi lowerBounds_Ioi\n-/\n\n",
 "lowerBounds_Ioc":
 "#print lowerBounds_Ioc /-\ntheorem lowerBounds_Ioc {a b : γ} (hab : a < b) : lowerBounds (Ioc a b) = Iic a :=\n  (isGLB_Ioc hab).lower_bounds_eq\n#align lower_bound_Ioc lowerBounds_Ioc\n-/\n\n",
 "lowerBounds_Ico":
 "#print lowerBounds_Ico /-\ntheorem lowerBounds_Ico (h : a < b) : lowerBounds (Ico a b) = Iic a :=\n  (isGLB_Ico h).lower_bounds_eq\n#align lower_bounds_Ico lowerBounds_Ico\n-/\n\n",
 "lowerBounds_Ici":
 "#print lowerBounds_Ici /-\ntheorem lowerBounds_Ici : lowerBounds (Ici a) = Iic a :=\n  isGLB_Ici.lower_bounds_eq\n#align lower_bounds_Ici lowerBounds_Ici\n-/\n\n",
 "lowerBounds_Icc":
 "#print lowerBounds_Icc /-\ntheorem lowerBounds_Icc (h : a ≤ b) : lowerBounds (Icc a b) = Iic a :=\n  (isGLB_Icc h).lower_bounds_eq\n#align lower_bounds_Icc lowerBounds_Icc\n-/\n\n",
 "le_of_isLUB_le_isGLB":
 "#print le_of_isLUB_le_isGLB /-\ntheorem le_of_isLUB_le_isGLB {x y} (ha : IsGLB s a) (hb : IsLUB s b) (hab : b ≤ a) (hx : x ∈ s) (hy : y ∈ s) : x ≤ y :=\n  calc\n    x ≤ b := hb.1 hx\n    _ ≤ a := hab\n    _ ≤ y := ha.1 hy\n    \n#align le_of_is_lub_le_is_glb le_of_isLUB_le_isGLB\n-/\n\n",
 "le_isGLB_iff":
 "#print le_isGLB_iff /-\ntheorem le_isGLB_iff (h : IsGLB s a) : b ≤ a ↔ b ∈ lowerBounds s :=\n  by\n  rw [h.lower_bounds_eq]\n  rfl\n#align le_is_glb_iff le_isGLB_iff\n-/\n\n",
 "le_glb_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print le_glb_Ioi /-\ntheorem le_glb_Ioi (a : α) (hb : IsGLB (Set.Ioi a) b) : a ≤ b :=\n  @lub_Iio_le («expr ᵒᵈ» α) _ _ a hb\n#align le_glb_Ioi le_glb_Ioi\n-/\n\n",
 "is_lub_empty_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem is_lub_empty_iff : IsLUB ∅ a ↔ is_bot a :=\n  @is_glb_empty_iff («expr ᵒᵈ» α) _ _\n#align is_lub_empty_iff is_lub_empty_iff\n\n",
 "is_least_univ_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem is_least_univ_iff : IsLeast univ a ↔ is_bot a :=\n  @is_greatest_univ_iff («expr ᵒᵈ» α) _ _\n#align is_least_univ_iff is_least_univ_iff\n\n",
 "is_greatest_univ_iff":
 "@[simp]\ntheorem is_greatest_univ_iff : IsGreatest univ a ↔ is_top a := by simp [IsGreatest, mem_upperBounds, is_top]\n#align is_greatest_univ_iff is_greatest_univ_iff\n\n",
 "is_glb_empty_iff":
 "@[simp]\ntheorem is_glb_empty_iff : IsGLB ∅ a ↔ is_top a := by simp [IsGLB]\n#align is_glb_empty_iff is_glb_empty_iff\n\n",
 "isLeast_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print isLeast_univ /-\ntheorem isLeast_univ [OrderBot α] : IsLeast (univ : set α) («expr⊥») :=\n  @isGreatest_univ («expr ᵒᵈ» α) _ _\n#align is_least_univ isLeast_univ\n-/\n\n",
 "isLeast_union_iff":
 "#print isLeast_union_iff /-\ntheorem isLeast_union_iff {a : α} {s t : set α} :\n    IsLeast (s ∪ t) a ↔ IsLeast s a ∧ a ∈ lowerBounds t ∨ a ∈ lowerBounds s ∧ IsLeast t a := by\n  simp [IsLeast, lowerBounds_union, or_and_right, and_comm' (a ∈ t), and_assoc']\n#align is_least_union_iff isLeast_union_iff\n-/\n\n",
 "isLeast_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isLeast_singleton /-\ntheorem isLeast_singleton : IsLeast {a} a :=\n  @isGreatest_singleton («expr ᵒᵈ» α) _ a\n#align is_least_singleton isLeast_singleton\n-/\n\n",
 "isLeast_pair":
 "#print isLeast_pair /-\ntheorem isLeast_pair [linear_order γ] {a b : γ} : IsLeast {a, b} (min a b) :=\n  isLeast_singleton.insert _\n#align is_least_pair isLeast_pair\n-/\n\n",
 "isLeast_image2_of_isLeast":
 "#print IsGreatest.isLeast_image2_of_isLeast /-\ntheorem IsGreatest.isLeast_image2_of_isLeast (ha : IsGreatest s a) (hb : IsLeast t b) :\n    IsLeast (image2 f s t) (f a b) :=\n  ⟨mem_image2_of_mem ha.1 hb.1, mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds h₀ h₁ ha.2 hb.2⟩\n#align is_greatest.is_least_image2_of_is_least IsGreatest.isLeast_image2_of_isLeast\n-/\n\n",
 "isLeast_image2_of_isGreatest":
 "#print IsLeast.isLeast_image2_of_isGreatest /-\ntheorem IsLeast.isLeast_image2_of_isGreatest (ha : IsLeast s a) (hb : IsGreatest t b) :\n    IsLeast (image2 f s t) (f a b) :=\n  ⟨mem_image2_of_mem ha.1 hb.1, mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_upperBounds h₀ h₁ ha.2 hb.2⟩\n#align is_least.is_least_image2_of_is_greatest IsLeast.isLeast_image2_of_isGreatest\n-/\n\n",
 "isLeast_image2":
 "#print IsGreatest.isLeast_image2 /-\ntheorem IsGreatest.isLeast_image2 (ha : IsGreatest s a) (hb : IsGreatest t b) : IsLeast (image2 f s t) (f a b) :=\n  ⟨mem_image2_of_mem ha.1 hb.1, mem_lowerBounds_image2_of_mem_upperBounds h₀ h₁ ha.2 hb.2⟩\n#align is_greatest.is_least_image2 IsGreatest.isLeast_image2\n-/\n\n",
 "isLeast_iff_eq":
 "#print IsLeast.isLeast_iff_eq /-\ntheorem IsLeast.isLeast_iff_eq (Ha : IsLeast s a) : IsLeast s b ↔ a = b :=\n  iff.intro Ha.unique fun h => h ▸ Ha\n#align is_least.is_least_iff_eq IsLeast.isLeast_iff_eq\n-/\n\n",
 "isLeast_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print isLeast_bot_iff /-\n@[simp]\ntheorem isLeast_bot_iff [OrderBot α] : IsLeast s («expr⊥») ↔ «expr⊥» ∈ s :=\n  and_iff_left <| bot_mem_lowerBounds _\n#align is_least_bot_iff isLeast_bot_iff\n-/\n\n",
 "isLeast_Ico":
 "#print isLeast_Ico /-\ntheorem isLeast_Ico (h : a < b) : IsLeast (Ico a b) a :=\n  ⟨left_mem_Ico.2 h, fun x => And.left⟩\n#align is_least_Ico isLeast_Ico\n-/\n\n",
 "isLeast_Ici":
 "#print isLeast_Ici /-\ntheorem isLeast_Ici : IsLeast (Ici a) a :=\n  ⟨left_mem_Ici, fun x => id⟩\n#align is_least_Ici isLeast_Ici\n-/\n\n",
 "isLeast_Icc":
 "#print isLeast_Icc /-\ntheorem isLeast_Icc (h : a ≤ b) : IsLeast (Icc a b) a :=\n  ⟨left_mem_Icc.2 h, fun x => And.left⟩\n#align is_least_Icc isLeast_Icc\n-/\n\n",
 "isLUB_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print isLUB_univ /-\ntheorem isLUB_univ [OrderTop α] : IsLUB (univ : set α) («expr⊤») :=\n  isGreatest_univ.is_lub\n#align is_lub_univ isLUB_univ\n-/\n\n",
 "isLUB_singleton":
 "#print isLUB_singleton /-\ntheorem isLUB_singleton : IsLUB {a} a :=\n  isGreatest_singleton.is_lub\n#align is_lub_singleton isLUB_singleton\n-/\n\n",
 "isLUB_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isLUB_prod /-\ntheorem isLUB_prod [preorder α] [preorder β] {s : set (α × β)} (p : α × β) :\n    IsLUB s p ↔ IsLUB («expr '' » prod.fst s) p.1 ∧ IsLUB («expr '' » prod.snd s) p.2 :=\n  by\n  refine'\n    ⟨fun H =>\n      ⟨⟨monotone_fst.mem_upper_bounds_image H.1, fun a ha => _⟩,\n        ⟨monotone_snd.mem_upper_bounds_image H.1, fun a ha => _⟩⟩,\n      fun H => ⟨_, _⟩⟩\n  · suffices : (a, p.2) ∈ upperBounds s\n    exact (H.2 this).1\n    exact fun q hq => ⟨ha <| mem_image_of_mem _ hq, (H.1 hq).2⟩\n  · suffices : (p.1, a) ∈ upperBounds s\n    exact (H.2 this).2\n    exact fun q hq => ⟨(H.1 hq).1, ha <| mem_image_of_mem _ hq⟩\n  · exact fun q hq => ⟨H.1.1 <| mem_image_of_mem _ hq, H.2.1 <| mem_image_of_mem _ hq⟩\n  · exact fun q hq => ⟨H.1.2 <| monotone_fst.mem_upper_bounds_image hq, H.2.2 <| monotone_snd.mem_upper_bounds_image hq⟩\n#align is_lub_prod isLUB_prod\n-/\n\n",
 "isLUB_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isLUB_pi /-\ntheorem isLUB_pi {π : α → Type _} [∀ a, preorder (π a)] {s : set (∀ a, π a)} {f : ∀ a, π a} :\n    IsLUB s f ↔ ∀ a, IsLUB («expr '' » (function.eval a) s) (f a) := by\n  classical\n    refine' ⟨fun H a => ⟨(function.monotone_eval a).mem_upper_bounds_image H.1, fun b hb => _⟩, fun H => ⟨_, _⟩⟩\n    · suffices : function.update f a b ∈ upperBounds s\n      exact function.update_same a b f ▸ H.2 this a\n      refine' fun g hg => le_update_iff.2 ⟨hb <| mem_image_of_mem _ hg, fun i hi => H.1 hg i⟩\n    · exact fun g hg a => (H a).1 (mem_image_of_mem _ hg)\n    · exact fun g hg a => (H a).2 ((function.monotone_eval a).mem_upper_bounds_image hg)\n#align is_lub_pi isLUB_pi\n-/\n\n",
 "isLUB_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print isLUB_pair /-\ntheorem isLUB_pair [SemilatticeSup γ] {a b : γ} : IsLUB {a, b} («expr ⊔ » a b) :=\n  isLUB_singleton.insert _\n#align is_lub_pair isLUB_pair\n-/\n\n",
 "isLUB_lt_iff":
 "#print isLUB_lt_iff /-\ntheorem isLUB_lt_iff (ha : IsLUB s a) : a < b ↔ ∃ c ∈ upperBounds s, c < b :=\n  ⟨fun hb => ⟨a, ha.1, hb⟩, fun ⟨c, hcs, hcb⟩ => lt_of_le_of_lt (ha.2 hcs) hcb⟩\n#align is_lub_lt_iff isLUB_lt_iff\n-/\n\n",
 "isLUB_lowerBounds":
 "#print isLUB_lowerBounds /-\n@[simp]\ntheorem isLUB_lowerBounds : IsLUB (lowerBounds s) a ↔ IsGLB s a :=\n  ⟨fun H => ⟨fun x hx => H.2 <| subset_upperBounds_lowerBounds s hx, H.1⟩, IsGreatest.isLUB⟩\n#align is_lub_lower_bounds isLUB_lowerBounds\n-/\n\n",
 "isLUB_le_iff":
 "#print isLUB_le_iff /-\ntheorem isLUB_le_iff (h : IsLUB s a) : a ≤ b ↔ b ∈ upperBounds s :=\n  by\n  rw [h.upper_bounds_eq]\n  rfl\n#align is_lub_le_iff isLUB_le_iff\n-/\n\n",
 "isLUB_iff_le_iff":
 "#print isLUB_iff_le_iff /-\ntheorem isLUB_iff_le_iff : IsLUB s a ↔ ∀ b, a ≤ b ↔ b ∈ upperBounds s :=\n  ⟨fun h b => isLUB_le_iff h, fun H => ⟨(H _).1 le_rfl, fun b hb => (H b).2 hb⟩⟩\n#align is_lub_iff_le_iff isLUB_iff_le_iff\n-/\n\n",
 "isLUB_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print isLUB_empty /-\ntheorem isLUB_empty [OrderBot α] : IsLUB ∅ («expr⊥» : α) :=\n  @isGLB_empty («expr ᵒᵈ» α) _ _\n#align is_lub_empty isLUB_empty\n-/\n\n",
 "isLUB_Ioo":
 "#print isLUB_Ioo /-\ntheorem isLUB_Ioo {a b : γ} (hab : a < b) : IsLUB (Ioo a b) b := by simpa only [dual_Ioo] using isGLB_Ioo hab.dual\n#align is_lub_Ioo isLUB_Ioo\n-/\n\n",
 "isLUB_Ioc":
 "#print isLUB_Ioc /-\ntheorem isLUB_Ioc (h : a < b) : IsLUB (Ioc a b) b :=\n  (isGreatest_Ioc h).is_lub\n#align is_lub_Ioc isLUB_Ioc\n-/\n\n",
 "isLUB_Iio":
 "#print isLUB_Iio /-\ntheorem isLUB_Iio {a : γ} : IsLUB (Iio a) a :=\n  ⟨fun x hx => le_of_lt hx, fun y hy => le_of_forall_ge_of_dense hy⟩\n#align is_lub_Iio isLUB_Iio\n-/\n\n",
 "isLUB_Iic":
 "#print isLUB_Iic /-\ntheorem isLUB_Iic : IsLUB (Iic a) a :=\n  isGreatest_Iic.is_lub\n#align is_lub_Iic isLUB_Iic\n-/\n\n",
 "isLUB_Ico":
 "#print isLUB_Ico /-\ntheorem isLUB_Ico {a b : γ} (hab : a < b) : IsLUB (Ico a b) b := by simpa only [dual_Ioc] using isGLB_Ioc hab.dual\n#align is_lub_Ico isLUB_Ico\n-/\n\n",
 "isLUB_Icc":
 "#print isLUB_Icc /-\ntheorem isLUB_Icc (h : a ≤ b) : IsLUB (Icc a b) b :=\n  (isGreatest_Icc h).is_lub\n#align is_lub_Icc isLUB_Icc\n-/\n\n",
 "isLUB":
 "#print IsGreatest.isLUB /-\ntheorem IsGreatest.isLUB (h : IsGreatest s a) : IsLUB s a :=\n  ⟨h.2, fun b hb => hb h.1⟩\n#align is_greatest.is_lub IsGreatest.isLUB\n-/\n\n",
 "isGreatest_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print isGreatest_univ /-\ntheorem isGreatest_univ [OrderTop α] : IsGreatest (univ : set α) («expr⊤») :=\n  is_greatest_univ_iff.2 isTop_top\n#align is_greatest_univ isGreatest_univ\n-/\n\n",
 "isGreatest_union_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isGreatest_union_iff /-\ntheorem isGreatest_union_iff :\n    IsGreatest (s ∪ t) a ↔ IsGreatest s a ∧ a ∈ upperBounds t ∨ a ∈ upperBounds s ∧ IsGreatest t a :=\n  @isLeast_union_iff («expr ᵒᵈ» α) _ a s t\n#align is_greatest_union_iff isGreatest_union_iff\n-/\n\n",
 "isGreatest_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print isGreatest_top_iff /-\n@[simp]\ntheorem isGreatest_top_iff [OrderTop α] : IsGreatest s («expr⊤») ↔ «expr⊤» ∈ s :=\n  and_iff_left <| top_mem_upperBounds _\n#align is_greatest_top_iff isGreatest_top_iff\n-/\n\n",
 "isGreatest_singleton":
 "#print isGreatest_singleton /-\ntheorem isGreatest_singleton : IsGreatest {a} a :=\n  ⟨mem_singleton a, fun x hx => le_of_eq <| eq_of_mem_singleton hx⟩\n#align is_greatest_singleton isGreatest_singleton\n-/\n\n",
 "isGreatest_pair":
 "#print isGreatest_pair /-\ntheorem isGreatest_pair [linear_order γ] {a b : γ} : IsGreatest {a, b} (max a b) :=\n  isGreatest_singleton.insert _\n#align is_greatest_pair isGreatest_pair\n-/\n\n",
 "isGreatest_image2_of_isLeast":
 "#print IsGreatest.isGreatest_image2_of_isLeast /-\ntheorem IsGreatest.isGreatest_image2_of_isLeast (ha : IsGreatest s a) (hb : IsLeast t b) :\n    IsGreatest (image2 f s t) (f a b) :=\n  ⟨mem_image2_of_mem ha.1 hb.1, mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds h₀ h₁ ha.2 hb.2⟩\n#align is_greatest.is_greatest_image2_of_is_least IsGreatest.isGreatest_image2_of_isLeast\n-/\n\n",
 "isGreatest_image2_of_isGreatest":
 "#print IsLeast.isGreatest_image2_of_isGreatest /-\ntheorem IsLeast.isGreatest_image2_of_isGreatest (ha : IsLeast s a) (hb : IsGreatest t b) :\n    IsGreatest (image2 f s t) (f a b) :=\n  ⟨mem_image2_of_mem ha.1 hb.1, mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds h₀ h₁ ha.2 hb.2⟩\n#align is_least.is_greatest_image2_of_is_greatest IsLeast.isGreatest_image2_of_isGreatest\n-/\n\n",
 "isGreatest_image2":
 "#print IsLeast.isGreatest_image2 /-\ntheorem IsLeast.isGreatest_image2 (ha : IsLeast s a) (hb : IsLeast t b) : IsGreatest (image2 f s t) (f a b) :=\n  ⟨mem_image2_of_mem ha.1 hb.1, mem_upperBounds_image2_of_mem_lowerBounds h₀ h₁ ha.2 hb.2⟩\n#align is_least.is_greatest_image2 IsLeast.isGreatest_image2\n-/\n\n",
 "isGreatest_iff_eq":
 "#print IsGreatest.isGreatest_iff_eq /-\ntheorem IsGreatest.isGreatest_iff_eq (Ha : IsGreatest s a) : IsGreatest s b ↔ a = b :=\n  iff.intro Ha.unique fun h => h ▸ Ha\n#align is_greatest.is_greatest_iff_eq IsGreatest.isGreatest_iff_eq\n-/\n\n",
 "isGreatest_Ioc":
 "#print isGreatest_Ioc /-\ntheorem isGreatest_Ioc (h : a < b) : IsGreatest (Ioc a b) b :=\n  ⟨right_mem_Ioc.2 h, fun x => And.right⟩\n#align is_greatest_Ioc isGreatest_Ioc\n-/\n\n",
 "isGreatest_Iic":
 "#print isGreatest_Iic /-\ntheorem isGreatest_Iic : IsGreatest (Iic a) a :=\n  ⟨right_mem_Iic, fun x => id⟩\n#align is_greatest_Iic isGreatest_Iic\n-/\n\n",
 "isGreatest_Icc":
 "#print isGreatest_Icc /-\ntheorem isGreatest_Icc (h : a ≤ b) : IsGreatest (Icc a b) b :=\n  ⟨right_mem_Icc.2 h, fun x => And.right⟩\n#align is_greatest_Icc isGreatest_Icc\n-/\n\n",
 "isGLB_upperBounds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isGLB_upperBounds /-\n@[simp]\ntheorem isGLB_upperBounds : IsGLB (upperBounds s) a ↔ IsLUB s a :=\n  @isLUB_lowerBounds («expr ᵒᵈ» α) _ _ _\n#align is_glb_upper_bounds isGLB_upperBounds\n-/\n\n",
 "isGLB_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print isGLB_univ /-\ntheorem isGLB_univ [OrderBot α] : IsGLB (univ : set α) («expr⊥») :=\n  isLeast_univ.is_glb\n#align is_glb_univ isGLB_univ\n-/\n\n",
 "isGLB_singleton":
 "#print isGLB_singleton /-\ntheorem isGLB_singleton : IsGLB {a} a :=\n  isLeast_singleton.is_glb\n#align is_glb_singleton isGLB_singleton\n-/\n\n",
 "isGLB_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isGLB_prod /-\ntheorem isGLB_prod [preorder α] [preorder β] {s : set (α × β)} (p : α × β) :\n    IsGLB s p ↔ IsGLB («expr '' » prod.fst s) p.1 ∧ IsGLB («expr '' » prod.snd s) p.2 :=\n  @isLUB_prod («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ _ _\n#align is_glb_prod isGLB_prod\n-/\n\n",
 "isGLB_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isGLB_pi /-\ntheorem isGLB_pi {π : α → Type _} [∀ a, preorder (π a)] {s : set (∀ a, π a)} {f : ∀ a, π a} :\n    IsGLB s f ↔ ∀ a, IsGLB («expr '' » (function.eval a) s) (f a) :=\n  @isLUB_pi α (fun a => «expr ᵒᵈ» (π a)) _ s f\n#align is_glb_pi isGLB_pi\n-/\n\n",
 "isGLB_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print isGLB_pair /-\ntheorem isGLB_pair [SemilatticeInf γ] {a b : γ} : IsGLB {a, b} («expr ⊓ » a b) :=\n  isGLB_singleton.insert _\n#align is_glb_pair isGLB_pair\n-/\n\n",
 "isGLB_lt_isLUB_of_ne":
 "#print isGLB_lt_isLUB_of_ne /-\ntheorem isGLB_lt_isLUB_of_ne (Ha : IsGLB s a) (Hb : IsLUB s b) {x y} (Hx : x ∈ s) (Hy : y ∈ s) (Hxy : x ≠ y) : a < b :=\n  lt_iff_le_not_le.2\n    ⟨lowerBounds_le_upperBounds Ha.1 Hb.1 ⟨x, Hx⟩, fun hab => Hxy <| Set.subsingleton_of_isLUB_le_isGLB Ha Hb hab Hx Hy⟩\n#align is_glb_lt_is_lub_of_ne isGLB_lt_isLUB_of_ne\n-/\n\n",
 "isGLB_lt_iff":
 "#print isGLB_lt_iff /-\ntheorem isGLB_lt_iff (h : IsGLB s a) : a < b ↔ ∃ c ∈ s, c < b :=\n  lt_isLUB_iff h.dual\n#align is_glb_lt_iff isGLB_lt_iff\n-/\n\n",
 "isGLB_le_isLUB":
 "#print isGLB_le_isLUB /-\ntheorem isGLB_le_isLUB (ha : IsGLB s a) (hb : IsLUB s b) (hs : s.nonempty) : a ≤ b :=\n  lowerBounds_le_upperBounds ha.1 hb.1 hs\n#align is_glb_le_is_lub isGLB_le_isLUB\n-/\n\n",
 "isGLB_iff_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isGLB_iff_le_iff /-\ntheorem isGLB_iff_le_iff : IsGLB s a ↔ ∀ b, b ≤ a ↔ b ∈ lowerBounds s :=\n  @isLUB_iff_le_iff («expr ᵒᵈ» α) _ _ _\n#align is_glb_iff_le_iff isGLB_iff_le_iff\n-/\n\n",
 "isGLB_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print isGLB_empty /-\ntheorem isGLB_empty [OrderTop α] : IsGLB ∅ («expr⊤» : α) :=\n  is_glb_empty_iff.2 isTop_top\n#align is_glb_empty isGLB_empty\n-/\n\n",
 "isGLB_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print isGLB_Ioo /-\ntheorem isGLB_Ioo {a b : γ} (h : a < b) : IsGLB (Ioo a b) a :=\n  ⟨fun x hx => hx.1.le, fun x hx =>\n    by\n    cases' eq_or_lt_of_le (le_sup_right : a ≤ «expr ⊔ » x a) with h₁ h₂\n    · exact h₁.symm ▸ le_sup_left\n    obtain ⟨y, lty, ylt⟩ := exists_between h₂\n    apply (not_lt_of_le (sup_le (hx ⟨lty, ylt.trans_le (sup_le _ h.le)⟩) lty.le) ylt).elim\n    obtain ⟨u, au, ub⟩ := exists_between h\n    apply (hx ⟨au, ub⟩).trans ub.le⟩\n#align is_glb_Ioo isGLB_Ioo\n-/\n\n",
 "isGLB_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isGLB_Ioi /-\ntheorem isGLB_Ioi {a : γ} : IsGLB (Ioi a) a :=\n  @isLUB_Iio («expr ᵒᵈ» γ) _ _ a\n#align is_glb_Ioi isGLB_Ioi\n-/\n\n",
 "isGLB_Ioc":
 "#print isGLB_Ioc /-\ntheorem isGLB_Ioc {a b : γ} (hab : a < b) : IsGLB (Ioc a b) a :=\n  (isGLB_Ioo hab).of_subset_of_superset (isGLB_Icc hab.le) Ioo_subset_Ioc_self Ioc_subset_Icc_self\n#align is_glb_Ioc isGLB_Ioc\n-/\n\n",
 "isGLB_Ico":
 "#print isGLB_Ico /-\ntheorem isGLB_Ico (h : a < b) : IsGLB (Ico a b) a :=\n  (isLeast_Ico h).is_glb\n#align is_glb_Ico isGLB_Ico\n-/\n\n",
 "isGLB_Ici":
 "#print isGLB_Ici /-\ntheorem isGLB_Ici : IsGLB (Ici a) a :=\n  isLeast_Ici.is_glb\n#align is_glb_Ici isGLB_Ici\n-/\n\n",
 "isGLB_Icc":
 "#print isGLB_Icc /-\ntheorem isGLB_Icc (h : a ≤ b) : IsGLB (Icc a b) a :=\n  (isLeast_Icc h).is_glb\n#align is_glb_Icc isGLB_Icc\n-/\n\n",
 "isGLB":
 "#print IsLeast.isGLB /-\ntheorem IsLeast.isGLB (h : IsLeast s a) : IsGLB s a :=\n  ⟨h.2, fun b hb => hb h.1⟩\n#align is_least.is_glb IsLeast.isGLB\n-/\n\n",
 "inter_of_right":
 "#print BddBelow.inter_of_right /-\n/-- If `t` is bounded, then so is `s ∩ t` -/\ntheorem BddBelow.inter_of_right (h : BddBelow t) : BddBelow (s ∩ t) :=\n  h.mono <| inter_subset_right s t\n#align bdd_below.inter_of_right BddBelow.inter_of_right\n-/\n\n",
 "inter_of_left":
 "#print BddBelow.inter_of_left /-\n/-- If `s` is bounded, then so is `s ∩ t` -/\ntheorem BddBelow.inter_of_left (h : BddBelow s) : BddBelow (s ∩ t) :=\n  h.mono <| inter_subset_left s t\n#align bdd_below.inter_of_left BddBelow.inter_of_left\n-/\n\n",
 "inter_Iic_of_mem":
 "#print IsGLB.inter_Iic_of_mem /-\ntheorem IsGLB.inter_Iic_of_mem [linear_order γ] {s : set γ} {a b : γ} (ha : IsGLB s a) (hb : b ∈ s) :\n    IsGLB (s ∩ Iic b) a :=\n  ha.dual.inter_Ici_of_mem hb\n#align is_glb.inter_Iic_of_mem IsGLB.inter_Iic_of_mem\n-/\n\n",
 "inter_Ici_of_mem":
 "#print IsLUB.inter_Ici_of_mem /-\ntheorem IsLUB.inter_Ici_of_mem [linear_order γ] {s : set γ} {a b : γ} (ha : IsLUB s a) (hb : b ∈ s) :\n    IsLUB (s ∩ Ici b) a :=\n  ⟨fun x hx => ha.1 hx.1, fun c hc =>\n    have hbc : b ≤ c := hc ⟨hb, le_rfl⟩\n    ha.2 fun x hx => (le_total x b).elim (fun hxb => hxb.trans hbc) fun hbx => hc ⟨hx, hbx⟩⟩\n#align is_lub.inter_Ici_of_mem IsLUB.inter_Ici_of_mem\n-/\n\n",
 "insert":
 "#print IsLeast.insert /-\ntheorem IsLeast.insert [linear_order γ] (a) {b} {s : set γ} (hs : IsLeast s b) : IsLeast (insert a s) (min a b) :=\n  by\n  rw [insert_eq]\n  exact is_least_singleton.union hs\n#align is_least.insert IsLeast.insert\n-/\n\n",
 "image_upper_bounds_subset_upper_bounds_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_upper_bounds_subset_upper_bounds_image : «expr '' » f (upperBounds s) ⊆ upperBounds («expr '' » f s) :=\n  by\n  rintro _ ⟨a, ha, rfl⟩\n  exact Hf.mem_upper_bounds_image ha\n#align image_upper_bounds_subset_upper_bounds_image image_upper_bounds_subset_upper_bounds_image\n\n",
 "image_upper_bounds_subset_lower_bounds_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_upper_bounds_subset_lower_bounds_image : «expr '' » f (upperBounds s) ⊆ lowerBounds («expr '' » f s) :=\n  hf.dual_right.image_upper_bounds_subset_upper_bounds_image\n#align image_upper_bounds_subset_lower_bounds_image image_upper_bounds_subset_lower_bounds_image\n\n",
 "image_lower_bounds_subset_upper_bounds_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_lower_bounds_subset_upper_bounds_image : «expr '' » f (lowerBounds s) ⊆ upperBounds («expr '' » f s) :=\n  hf.dual_right.image_lower_bounds_subset_lower_bounds_image\n#align image_lower_bounds_subset_upper_bounds_image image_lower_bounds_subset_upper_bounds_image\n\n",
 "image_lower_bounds_subset_lower_bounds_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_lower_bounds_subset_lower_bounds_image : «expr '' » f (lowerBounds s) ⊆ lowerBounds («expr '' » f s) :=\n  Hf.dual.image_upper_bounds_subset_upper_bounds_image\n#align image_lower_bounds_subset_lower_bounds_image image_lower_bounds_subset_lower_bounds_image\n\n",
 "image2_upper_bounds_lower_bounds_subset_upper_bounds_image2":
 "theorem image2_upper_bounds_lower_bounds_subset_upper_bounds_image2 :\n    image2 f (upperBounds s) (lowerBounds t) ⊆ upperBounds (image2 f s t) :=\n  by\n  rintro _ ⟨a, b, ha, hb, rfl⟩\n  exact mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds h₀ h₁ ha hb\n#align\n  image2_upper_bounds_lower_bounds_subset_upper_bounds_image2 image2_upper_bounds_lower_bounds_subset_upper_bounds_image2\n\n",
 "image2_upperBounds_upperBounds_subset_upperBounds_image2":
 "#print image2_upperBounds_upperBounds_subset_upperBounds_image2 /-\ntheorem image2_upperBounds_upperBounds_subset_upperBounds_image2 :\n    image2 f (lowerBounds s) (lowerBounds t) ⊆ upperBounds (image2 f s t) :=\n  by\n  rintro _ ⟨a, b, ha, hb, rfl⟩\n  exact mem_upperBounds_image2_of_mem_lowerBounds h₀ h₁ ha hb\n#align\n  image2_upper_bounds_upper_bounds_subset_upper_bounds_image2 image2_upperBounds_upperBounds_subset_upperBounds_image2\n-/\n\n",
 "image2_upperBounds_upperBounds_subset":
 "#print image2_upperBounds_upperBounds_subset /-\ntheorem image2_upperBounds_upperBounds_subset : image2 f (upperBounds s) (upperBounds t) ⊆ upperBounds (image2 f s t) :=\n  by\n  rintro _ ⟨a, b, ha, hb, rfl⟩\n  exact mem_upperBounds_image2 h₀ h₁ ha hb\n#align image2_upper_bounds_upper_bounds_subset image2_upperBounds_upperBounds_subset\n-/\n\n",
 "image2_upperBounds_lowerBounds_subset_lowerBounds_image2":
 "#print image2_upperBounds_lowerBounds_subset_lowerBounds_image2 /-\ntheorem image2_upperBounds_lowerBounds_subset_lowerBounds_image2 :\n    image2 f (upperBounds s) (lowerBounds t) ⊆ lowerBounds (image2 f s t) :=\n  by\n  rintro _ ⟨a, b, ha, hb, rfl⟩\n  exact mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds h₀ h₁ ha hb\n#align\n  image2_upper_bounds_lower_bounds_subset_lower_bounds_image2 image2_upperBounds_lowerBounds_subset_lowerBounds_image2\n-/\n\n",
 "image2_lowerBounds_upperBounds_subset_upperBounds_image2":
 "#print image2_lowerBounds_upperBounds_subset_upperBounds_image2 /-\ntheorem image2_lowerBounds_upperBounds_subset_upperBounds_image2 :\n    image2 f (lowerBounds s) (upperBounds t) ⊆ upperBounds (image2 f s t) :=\n  by\n  rintro _ ⟨a, b, ha, hb, rfl⟩\n  exact mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds h₀ h₁ ha hb\n#align\n  image2_lower_bounds_upper_bounds_subset_upper_bounds_image2 image2_lowerBounds_upperBounds_subset_upperBounds_image2\n-/\n\n",
 "image2_lowerBounds_upperBounds_subset_lowerBounds_image2":
 "#print image2_lowerBounds_upperBounds_subset_lowerBounds_image2 /-\ntheorem image2_lowerBounds_upperBounds_subset_lowerBounds_image2 :\n    image2 f (lowerBounds s) (upperBounds t) ⊆ lowerBounds (image2 f s t) :=\n  by\n  rintro _ ⟨a, b, ha, hb, rfl⟩\n  exact mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_upperBounds h₀ h₁ ha hb\n#align\n  image2_lower_bounds_upper_bounds_subset_lower_bounds_image2 image2_lowerBounds_upperBounds_subset_lowerBounds_image2\n-/\n\n",
 "image2_lowerBounds_lowerBounds_subset_lowerBounds_image2":
 "#print image2_lowerBounds_lowerBounds_subset_lowerBounds_image2 /-\ntheorem image2_lowerBounds_lowerBounds_subset_lowerBounds_image2 :\n    image2 f (upperBounds s) (upperBounds t) ⊆ lowerBounds (image2 f s t) :=\n  by\n  rintro _ ⟨a, b, ha, hb, rfl⟩\n  exact mem_lowerBounds_image2_of_mem_upperBounds h₀ h₁ ha hb\n#align\n  image2_lower_bounds_lower_bounds_subset_lower_bounds_image2 image2_lowerBounds_lowerBounds_subset_lowerBounds_image2\n-/\n\n",
 "image2_lowerBounds_lowerBounds_subset":
 "#print image2_lowerBounds_lowerBounds_subset /-\ntheorem image2_lowerBounds_lowerBounds_subset : image2 f (lowerBounds s) (lowerBounds t) ⊆ lowerBounds (image2 f s t) :=\n  by\n  rintro _ ⟨a, b, ha, hb, rfl⟩\n  exact mem_lowerBounds_image2 h₀ h₁ ha hb\n#align image2_lower_bounds_lower_bounds_subset image2_lowerBounds_lowerBounds_subset\n-/\n\n",
 "image2_bddBelow":
 "#print BddAbove.image2_bddBelow /-\ntheorem BddAbove.image2_bddBelow : BddAbove s → BddAbove t → BddBelow (image2 f s t) :=\n  by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  exact ⟨f a b, mem_lowerBounds_image2_of_mem_upperBounds h₀ h₁ ha hb⟩\n#align bdd_above.image2_bdd_below BddAbove.image2_bddBelow\n-/\n\n",
 "image2_bddAbove":
 "#print BddBelow.image2_bddAbove /-\ntheorem BddBelow.image2_bddAbove : BddBelow s → BddBelow t → BddAbove (image2 f s t) :=\n  by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  exact ⟨f a b, mem_upperBounds_image2_of_mem_lowerBounds h₀ h₁ ha hb⟩\n#align bdd_below.image2_bdd_above BddBelow.image2_bddAbove\n-/\n\n",
 "image2":
 "#print IsLeast.image2 /-\ntheorem IsLeast.image2 (ha : IsLeast s a) (hb : IsLeast t b) : IsLeast (image2 f s t) (f a b) :=\n  ⟨mem_image2_of_mem ha.1 hb.1, mem_lowerBounds_image2 h₀ h₁ ha.2 hb.2⟩\n#align is_least.image2 IsLeast.image2\n-/\n\n",
 "glb_Ioi_eq_self_or_Ioi_eq_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print glb_Ioi_eq_self_or_Ioi_eq_Ici /-\ntheorem glb_Ioi_eq_self_or_Ioi_eq_Ici [partial_order γ] {j : γ} (i : γ) (hj : IsGLB (Set.Ioi i) j) :\n    j = i ∨ Set.Ioi i = Set.Ici j :=\n  @lub_Iio_eq_self_or_Iio_eq_Iic («expr ᵒᵈ» γ) _ j i hj\n#align glb_Ioi_eq_self_or_Ioi_eq_Ici glb_Ioi_eq_self_or_Ioi_eq_Ici\n-/\n\n",
 "exists_lub_Iio":
 "#print exists_lub_Iio /-\ntheorem exists_lub_Iio (i : γ) : ∃ j, IsLUB (Set.Iio i) j :=\n  by\n  by_cases h_exists_lt : ∃ j, j ∈ upperBounds (Set.Iio i) ∧ j < i\n  · obtain ⟨j, hj_ub, hj_lt_i⟩ := h_exists_lt\n    exact ⟨j, hj_ub, fun k hk_ub => hk_ub hj_lt_i⟩\n  · refine' ⟨i, fun j hj => le_of_lt hj, _⟩\n    rw [mem_lowerBounds]\n    by_contra\n    refine' h_exists_lt _\n    push_neg  at h\n    exact h\n#align exists_lub_Iio exists_lub_Iio\n-/\n\n",
 "exists_le":
 "#print BddBelow.exists_le /-\ntheorem BddBelow.exists_le [SemilatticeInf γ] {s : set γ} (hs : BddBelow s) (x₀ : γ) : ∃ x, x ≤ x₀ ∧ ∀ y ∈ s, x ≤ y :=\n  (bddBelow_iff_exists_le x₀).mp hs\n#align bdd_below.exists_le BddBelow.exists_le\n-/\n\n",
 "exists_glb_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print exists_glb_Ioi /-\ntheorem exists_glb_Ioi (i : γ) : ∃ j, IsGLB (Set.Ioi i) j :=\n  @exists_lub_Iio («expr ᵒᵈ» γ) _ i\n#align exists_glb_Ioi exists_glb_Ioi\n-/\n\n",
 "exists_ge":
 "#print BddAbove.exists_ge /-\ntheorem BddAbove.exists_ge [SemilatticeSup γ] {s : set γ} (hs : BddAbove s) (x₀ : γ) : ∃ x, x₀ ≤ x ∧ ∀ y ∈ s, y ≤ x :=\n  (bddAbove_iff_exists_ge x₀).mp hs\n#align bdd_above.exists_ge BddAbove.exists_ge\n-/\n\n",
 "exists_between'":
 "#print IsGLB.exists_between' /-\ntheorem IsGLB.exists_between' (h : IsGLB s a) (h' : a ∉ s) (hb : a < b) : ∃ c ∈ s, a < c ∧ c < b :=\n  let ⟨c, hcs, hac, hcb⟩ := h.exists_between hb\n  ⟨c, hcs, hac.lt_of_ne fun hac => h' <| hac.symm ▸ hcs, hcb⟩\n#align is_glb.exists_between' IsGLB.exists_between'\n-/\n\n",
 "exists_between":
 "#print IsGLB.exists_between /-\ntheorem IsGLB.exists_between (h : IsGLB s a) (hb : a < b) : ∃ c ∈ s, a ≤ c ∧ c < b :=\n  let ⟨c, hcs, hbc⟩ := (isGLB_lt_iff h).1 hb\n  ⟨c, hcs, h.1 hcs, hbc⟩\n#align is_glb.exists_between IsGLB.exists_between\n-/\n\n",
 "dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print IsGLB.dual /-\ntheorem IsGLB.dual (h : IsGLB s a) : IsLUB («expr ⁻¹' » of_dual s) (toDual a) :=\n  h\n#align is_glb.dual IsGLB.dual\n-/\n\n",
 "bot_mem_lowerBounds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print bot_mem_lowerBounds /-\ntheorem bot_mem_lowerBounds [OrderBot α] (s : set α) : «expr⊥» ∈ lowerBounds s := fun _ _ => bot_le\n#align bot_mem_lower_bounds bot_mem_lowerBounds\n-/\n\n",
 "bddBelow_upperBounds":
 "#print Set.Nonempty.bddBelow_upperBounds /-\ntheorem Set.Nonempty.bddBelow_upperBounds (hs : s.nonempty) : BddBelow (upperBounds s) :=\n  hs.mono (subset_lowerBounds_upperBounds s)\n#align set.nonempty.bdd_below_upper_bounds Set.Nonempty.bddBelow_upperBounds\n-/\n\n",
 "bddBelow_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print bddBelow_union /-\n/-- The union of two sets is bounded above if and only if each of the sets is.-/\ntheorem bddBelow_union [SemilatticeInf γ] {s t : set γ} : BddBelow (s ∪ t) ↔ BddBelow s ∧ BddBelow t :=\n  @bddAbove_union («expr ᵒᵈ» γ) _ s t\n#align bdd_below_union bddBelow_union\n-/\n\n",
 "bddBelow_singleton":
 "#print bddBelow_singleton /-\ntheorem bddBelow_singleton : BddBelow ({a} : set α) :=\n  isGLB_singleton.bdd_below\n#align bdd_below_singleton bddBelow_singleton\n-/\n\n",
 "bddBelow_insert":
 "#print bddBelow_insert /-\n/-- Adding a point to a set preserves its boundedness below.-/\n@[simp]\ntheorem bddBelow_insert [SemilatticeInf γ] (a : γ) {s : set γ} : BddBelow (insert a s) ↔ BddBelow s := by\n  simp only [insert_eq, bddBelow_union, bddBelow_singleton, true_and_iff]\n#align bdd_below_insert bddBelow_insert\n-/\n\n",
 "bddBelow_image2_of_bddAbove":
 "#print BddAbove.bddBelow_image2_of_bddAbove /-\ntheorem BddAbove.bddBelow_image2_of_bddAbove : BddAbove s → BddBelow t → BddBelow (image2 f s t) :=\n  by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  exact ⟨f a b, mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds h₀ h₁ ha hb⟩\n#align bdd_above.bdd_below_image2_of_bdd_above BddAbove.bddBelow_image2_of_bddAbove\n-/\n\n",
 "bddBelow_iff_subset_Ici":
 "#print bddBelow_iff_subset_Ici /-\ntheorem bddBelow_iff_subset_Ici : BddBelow s ↔ ∃ a, s ⊆ Ici a :=\n  iff.rfl\n#align bdd_below_iff_subset_Ici bddBelow_iff_subset_Ici\n-/\n\n",
 "bddBelow_iff_exists_le":
 "#print bddBelow_iff_exists_le /-\ntheorem bddBelow_iff_exists_le [SemilatticeInf γ] {s : set γ} (x₀ : γ) : BddBelow s ↔ ∃ x, x ≤ x₀ ∧ ∀ y ∈ s, x ≤ y :=\n  bddAbove_iff_exists_ge (toDual x₀)\n#align bdd_below_iff_exists_le bddBelow_iff_exists_le\n-/\n\n",
 "bddBelow_empty":
 "#print bddBelow_empty /-\n@[simp]\ntheorem bddBelow_empty [nonempty α] : BddBelow (∅ : set α) := by simp only [BddBelow, lowerBounds_empty, univ_nonempty]\n#align bdd_below_empty bddBelow_empty\n-/\n\n",
 "bddBelow_def":
 "#print bddBelow_def /-\ntheorem bddBelow_def : BddBelow s ↔ ∃ x, ∀ y ∈ s, x ≤ y :=\n  iff.rfl\n#align bdd_below_def bddBelow_def\n-/\n\n",
 "bddBelow_bddAbove_iff_subset_Icc":
 "#print bddBelow_bddAbove_iff_subset_Icc /-\ntheorem bddBelow_bddAbove_iff_subset_Icc : BddBelow s ∧ BddAbove s ↔ ∃ a b, s ⊆ Icc a b := by\n  simp only [Ici_inter_Iic.symm, subset_inter_iff, bddBelow_iff_subset_Ici, bddAbove_iff_subset_Iic, exists_and_left,\n    exists_and_right]\n#align bdd_below_bdd_above_iff_subset_Icc bddBelow_bddAbove_iff_subset_Icc\n-/\n\n",
 "bddBelow_Ioo":
 "#print bddBelow_Ioo /-\ntheorem bddBelow_Ioo : BddBelow (Ioo a b) :=\n  bddBelow_Icc.mono Ioo_subset_Icc_self\n#align bdd_below_Ioo bddBelow_Ioo\n-/\n\n",
 "bddBelow_Ioi":
 "#print bddBelow_Ioi /-\ntheorem bddBelow_Ioi : BddBelow (Ioi a) :=\n  ⟨a, fun x hx => le_of_lt hx⟩\n#align bdd_below_Ioi bddBelow_Ioi\n-/\n\n",
 "bddBelow_Ioc":
 "#print bddBelow_Ioc /-\ntheorem bddBelow_Ioc : BddBelow (Ioc a b) :=\n  bddBelow_Icc.mono Ioc_subset_Icc_self\n#align bdd_below_Ioc bddBelow_Ioc\n-/\n\n",
 "bddBelow_Ico":
 "#print bddBelow_Ico /-\ntheorem bddBelow_Ico : BddBelow (Ico a b) :=\n  bddBelow_Icc.mono Ico_subset_Icc_self\n#align bdd_below_Ico bddBelow_Ico\n-/\n\n",
 "bddBelow_Ici":
 "#print bddBelow_Ici /-\ntheorem bddBelow_Ici : BddBelow (Ici a) :=\n  isGLB_Ici.bdd_below\n#align bdd_below_Ici bddBelow_Ici\n-/\n\n",
 "bddBelow_Icc":
 "#print bddBelow_Icc /-\ntheorem bddBelow_Icc : BddBelow (Icc a b) :=\n  ⟨a, fun _ => And.left⟩\n#align bdd_below_Icc bddBelow_Icc\n-/\n\n",
 "bddBelow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print OrderBot.bddBelow /-\n/-- When there is a global minimum, every set is bounded below. -/\n@[simp]\nprotected theorem OrderBot.bddBelow [OrderBot α] (s : set α) : BddBelow s :=\n  ⟨«expr⊥», fun a ha => order_bot.bot_le a⟩\n#align order_bot.bdd_below OrderBot.bddBelow\n-/\n\n",
 "bddAbove_union":
 "#print bddAbove_union /-\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem bddAbove_union [SemilatticeSup γ] {s t : set γ} : BddAbove (s ∪ t) ↔ BddAbove s ∧ BddAbove t :=\n  ⟨fun h => ⟨h.mono <| subset_union_left s t, h.mono <| subset_union_right s t⟩, fun h => h.1.union h.2⟩\n#align bdd_above_union bddAbove_union\n-/\n\n",
 "bddAbove_singleton":
 "#print bddAbove_singleton /-\ntheorem bddAbove_singleton : BddAbove ({a} : set α) :=\n  isLUB_singleton.bdd_above\n#align bdd_above_singleton bddAbove_singleton\n-/\n\n",
 "bddAbove_lowerBounds":
 "#print Set.Nonempty.bddAbove_lowerBounds /-\ntheorem Set.Nonempty.bddAbove_lowerBounds (hs : s.nonempty) : BddAbove (lowerBounds s) :=\n  hs.mono (subset_upperBounds_lowerBounds s)\n#align set.nonempty.bdd_above_lower_bounds Set.Nonempty.bddAbove_lowerBounds\n-/\n\n",
 "bddAbove_insert":
 "#print bddAbove_insert /-\n/-- Adding a point to a set preserves its boundedness above. -/\n@[simp]\ntheorem bddAbove_insert [SemilatticeSup γ] (a : γ) {s : set γ} : BddAbove (insert a s) ↔ BddAbove s := by\n  simp only [insert_eq, bddAbove_union, bddAbove_singleton, true_and_iff]\n#align bdd_above_insert bddAbove_insert\n-/\n\n",
 "bddAbove_image2_of_bddBelow":
 "#print BddAbove.bddAbove_image2_of_bddBelow /-\ntheorem BddAbove.bddAbove_image2_of_bddBelow : BddAbove s → BddBelow t → BddAbove (image2 f s t) :=\n  by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  exact ⟨f a b, mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds h₀ h₁ ha hb⟩\n#align bdd_above.bdd_above_image2_of_bdd_below BddAbove.bddAbove_image2_of_bddBelow\n-/\n\n",
 "bddAbove_image2_of_bddAbove":
 "#print BddBelow.bddAbove_image2_of_bddAbove /-\ntheorem BddBelow.bddAbove_image2_of_bddAbove : BddBelow s → BddAbove t → BddAbove (image2 f s t) :=\n  by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  exact ⟨f a b, mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds h₀ h₁ ha hb⟩\n#align bdd_below.bdd_above_image2_of_bdd_above BddBelow.bddAbove_image2_of_bddAbove\n-/\n\n",
 "bddAbove_iff_subset_Iic":
 "#print bddAbove_iff_subset_Iic /-\ntheorem bddAbove_iff_subset_Iic : BddAbove s ↔ ∃ a, s ⊆ Iic a :=\n  iff.rfl\n#align bdd_above_iff_subset_Iic bddAbove_iff_subset_Iic\n-/\n\n",
 "bddAbove_iff_exists_ge":
 "#print bddAbove_iff_exists_ge /-\ntheorem bddAbove_iff_exists_ge [SemilatticeSup γ] {s : set γ} (x₀ : γ) : BddAbove s ↔ ∃ x, x₀ ≤ x ∧ ∀ y ∈ s, y ≤ x :=\n  by\n  rw [bddAbove_def, exists_ge_and_iff_exists]\n  exact Monotone.ball fun x hx => monotone_le\n#align bdd_above_iff_exists_ge bddAbove_iff_exists_ge\n-/\n\n",
 "bddAbove_empty":
 "#print bddAbove_empty /-\n@[simp]\ntheorem bddAbove_empty [nonempty α] : BddAbove (∅ : set α) := by simp only [BddAbove, upperBounds_empty, univ_nonempty]\n#align bdd_above_empty bddAbove_empty\n-/\n\n",
 "bddAbove_def":
 "#print bddAbove_def /-\ntheorem bddAbove_def : BddAbove s ↔ ∃ x, ∀ y ∈ s, y ≤ x :=\n  iff.rfl\n#align bdd_above_def bddAbove_def\n-/\n\n",
 "bddAbove_Ioo":
 "#print bddAbove_Ioo /-\ntheorem bddAbove_Ioo : BddAbove (Ioo a b) :=\n  bddAbove_Icc.mono Ioo_subset_Icc_self\n#align bdd_above_Ioo bddAbove_Ioo\n-/\n\n",
 "bddAbove_Ioc":
 "#print bddAbove_Ioc /-\ntheorem bddAbove_Ioc : BddAbove (Ioc a b) :=\n  bddAbove_Icc.mono Ioc_subset_Icc_self\n#align bdd_above_Ioc bddAbove_Ioc\n-/\n\n",
 "bddAbove_Iio":
 "#print bddAbove_Iio /-\ntheorem bddAbove_Iio : BddAbove (Iio a) :=\n  ⟨a, fun x hx => le_of_lt hx⟩\n#align bdd_above_Iio bddAbove_Iio\n-/\n\n",
 "bddAbove_Iic":
 "#print bddAbove_Iic /-\ntheorem bddAbove_Iic : BddAbove (Iic a) :=\n  isLUB_Iic.bdd_above\n#align bdd_above_Iic bddAbove_Iic\n-/\n\n",
 "bddAbove_Ico":
 "#print bddAbove_Ico /-\ntheorem bddAbove_Ico : BddAbove (Ico a b) :=\n  bddAbove_Icc.mono Ico_subset_Icc_self\n#align bdd_above_Ico bddAbove_Ico\n-/\n\n",
 "bddAbove_Icc":
 "#print bddAbove_Icc /-\ntheorem bddAbove_Icc : BddAbove (Icc a b) :=\n  ⟨b, fun _ => And.right⟩\n#align bdd_above_Icc bddAbove_Icc\n-/\n\n",
 "bddAbove":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print OrderTop.bddAbove /-\n/-- When there is a global maximum, every set is bounded above. -/\n@[simp]\nprotected theorem OrderTop.bddAbove [OrderTop α] (s : set α) : BddAbove s :=\n  ⟨«expr⊤», fun a ha => order_top.le_top a⟩\n#align order_top.bdd_above OrderTop.bddAbove\n-/\n\n"}