{"well_founded_on_union":
 "@[simp]\ntheorem well_founded_on_union : (s ∪ t).well_founded_on r ↔ s.well_founded_on r ∧ t.well_founded_on r :=\n  ⟨fun h => ⟨h.subset <| subset_union_left _ _, h.subset <| subset_union_right _ _⟩, fun h => h.1.union h.2⟩\n#align well_founded_on_union well_founded_on_union\n\n",
 "well_founded_on_sup":
 "theorem well_founded_on_sup [is_strict_order α r] (s : Finset ι) {f : ι → Set α} :\n    (s.sup f).well_founded_on r ↔ ∀ i ∈ s, (f i).well_founded_on r :=\n  Finset.cons_induction_on s (by simp) fun a s ha hs => by simp [-sup_set_eq_bUnion, hs]\n#align well_founded_on_sup well_founded_on_sup\n\n",
 "well_founded_on_singleton":
 "@[simp]\ntheorem well_founded_on_singleton : WellFoundedOn ({a} : Set α) r :=\n  (finite_singleton a).well_founded_on\n#align well_founded_on_singleton well_founded_on_singleton\n\n",
 "well_founded_on_insert":
 "@[simp]\ntheorem well_founded_on_insert : WellFoundedOn (insert a s) r ↔ WellFoundedOn s r := by\n  simp only [← singleton_union, well_founded_on_union, well_founded_on_singleton, true_and_iff]\n#align well_founded_on_insert well_founded_on_insert\n\n",
 "well_founded_on_iff_no_descending_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪r » -/\ntheorem well_founded_on_iff_no_descending_seq :\n    s.well_founded_on r ↔ ∀ f : «expr ↪r » ((· > ·) : ℕ → ℕ → Prop) r, ¬∀ n, f n ∈ s :=\n  by\n  simp only [well_founded_on_iff, RelEmbedding.wellFounded_iff_no_descending_seq, ← not_exists, ← not_nonempty_iff,\n    not_iff_not]\n  constructor\n  · rintro ⟨⟨f, hf⟩⟩\n    have H : ∀ n, f n ∈ s := fun n => (hf.2 n.lt_succ_self).2.2\n    refine' ⟨⟨f, _⟩, H⟩\n    simpa only [H, and_true_iff] using @hf\n  · rintro ⟨⟨f, hf⟩, hfs : ∀ n, f n ∈ s⟩\n    refine' ⟨⟨f, _⟩⟩\n    simpa only [hfs, and_true_iff] using @hf\n#align well_founded_on_iff_no_descending_seq well_founded_on_iff_no_descending_seq\n\n",
 "well_founded_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem well_founded_on_iff : s.well_founded_on r ↔ well_founded fun a b : α => r a b ∧ a ∈ s ∧ b ∈ s :=\n  by\n  have f : RelEmbedding (fun (a : s) (b : s) => r a b) fun a b : α => r a b ∧ a ∈ s ∧ b ∈ s :=\n    ⟨⟨coe, Subtype.coe_injective⟩, fun a b => by simp⟩\n  refine' ⟨fun h => _, f.well_founded⟩\n  rw [WellFounded.wellFounded_iff_has_min]\n  intro t ht\n  by_cases hst : (s ∩ t).nonempty\n  · rw [← Subtype.preimage_coe_nonempty] at hst\n    rcases h.has_min («expr ⁻¹' » coe t) hst with ⟨⟨m, ms⟩, mt, hm⟩\n    exact ⟨m, mt, fun x xt ⟨xm, xs, ms⟩ => hm ⟨x, xs⟩ xt xm⟩\n  · rcases ht with ⟨m, mt⟩\n    exact ⟨m, mt, fun x xt ⟨xm, xs, ms⟩ => hst ⟨m, ⟨ms, mt⟩⟩⟩\n#align well_founded_on_iff well_founded_on_iff\n\n",
 "well_founded_on_empty":
 "/-\nCopyright (c) 2021 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\n@[simp]\ntheorem well_founded_on_empty (r : α → α → Prop) : WellFoundedOn ∅ r :=\n  wellFounded_of_isEmpty _\n#align well_founded_on_empty well_founded_on_empty\n\n",
 "well_founded_on_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem well_founded_on_bUnion [is_strict_order α r] (s : Finset ι) {f : ι → Set α} :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (f i)).well_founded_on\n        r ↔\n      ∀ i ∈ s, (f i).well_founded_on r :=\n  by simpa only [Finset.sup_eq_supᵢ] using s.well_founded_on_sup\n#align well_founded_on_bUnion well_founded_on_bUnion\n\n",
 "well_founded_on":
 "@[simp]\nprotected theorem well_founded_on [is_strict_order α r] (s : Finset α) : Set.WellFoundedOn (↑s : Set α) r :=\n  letI := partialOrderOfSO r\n  s.is_wf\n#align well_founded_on well_founded_on\n\n",
 "union":
 "protected theorem is_pwo.union (hs : IsPwo s) (ht : IsPwo t) : IsPwo (s ∪ t) :=\n  hs.union ht\n#align is_pwo.union is_pwo.union\n\n",
 "subset":
 "theorem subset (h : t.well_founded_on r) (hst : s ⊆ t) : s.well_founded_on r :=\n  h.mono le_rfl hst\n#align subset subset\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem is_pwo.prod {t : Set β} (hs : s.is_pwo) (ht : t.is_pwo) : IsPwo (finset.product s t) :=\n  hs.prod ht\n#align is_pwo.prod is_pwo.prod\n\n",
 "partially_well_ordered_on_union":
 "@[simp]\ntheorem partially_well_ordered_on_union :\n    (s ∪ t).partially_well_ordered_on r ↔ s.partially_well_ordered_on r ∧ t.partially_well_ordered_on r :=\n  ⟨fun h => ⟨h.mono <| subset_union_left _ _, h.mono <| subset_union_right _ _⟩, fun h => h.1.union h.2⟩\n#align partially_well_ordered_on_union partially_well_ordered_on_union\n\n",
 "partially_well_ordered_on_sup":
 "theorem partially_well_ordered_on_sup (s : Finset ι) {f : ι → Set α} :\n    (s.sup f).partially_well_ordered_on r ↔ ∀ i ∈ s, (f i).partially_well_ordered_on r :=\n  Finset.cons_induction_on s (by simp) fun a s ha hs => by simp [-sup_set_eq_bUnion, hs]\n#align partially_well_ordered_on_sup partially_well_ordered_on_sup\n\n",
 "partially_well_ordered_on_sublist_forall₂":
 "/-- Higman's Lemma, which states that for any reflexive, transitive relation `r` which is\n  partially well-ordered on a set `s`, the relation `list.sublist_forall₂ r` is partially\n  well-ordered on the set of lists of elements of `s`. That relation is defined so that\n  `list.sublist_forall₂ r l₁ l₂` whenever `l₁` related pointwise by `r` to a sublist of `l₂`.  -/\ntheorem partially_well_ordered_on_sublist_forall₂ (r : α → α → Prop) [is_refl α r] [is_trans α r] {s : Set α}\n    (h : s.partially_well_ordered_on r) :\n    { l : List α | ∀ x, x ∈ l → x ∈ s }.partially_well_ordered_on (List.SublistForall₂ r) :=\n  by\n  rcases s.eq_empty_or_nonempty with (rfl | ⟨as, has⟩)\n  · apply partially_well_ordered_on.mono (Finset.partiallyWellOrderedOn {List.nil})\n    · intro l hl\n      rw [Finset.mem_coe, Finset.mem_singleton, List.eq_nil_iff_forall_not_mem]\n      exact hl\n    infer_instance\n  haveI : Inhabited α := ⟨as⟩\n  rw [iff_not_exists_is_min_bad_seq list.length]\n  rintro ⟨f, hf1, hf2⟩\n  have hnil : ∀ n, f n ≠ List.nil := fun n con => hf1.2 n n.succ n.lt_succ_self (Con.symm ▸ List.SublistForall₂.nil)\n  obtain ⟨g, hg⟩ := h.exists_monotone_subseq (List.headI ∘ f) _\n  swap;\n  · simp only [Set.range_subset_iff, Function.comp_apply]\n    exact fun n => hf1.1 n _ (List.head!_mem_self (hnil n))\n  have hf' := hf2 (g 0) (fun n => if n < g 0 then f n else list.tail (f (g (n - g 0)))) (fun m hm => (if_pos hm).symm) _\n  swap;\n  · simp only [if_neg (lt_irrefl (g 0)), tsub_self]\n    rw [list.length_tail, ← Nat.pred_eq_sub_one]\n    exact nat.pred_lt fun con => hnil _ (List.length_eq_zero.1 Con)\n  rw [is_bad_seq] at hf'\n  push_neg  at hf'\n  obtain ⟨m, n, mn, hmn⟩ := hf' _\n  swap\n  · rintro n x hx\n    split_ifs  at hx with hn hn\n    · exact hf1.1 _ _ hx\n    · refine' hf1.1 _ _ (List.tail_subset _ hx)\n  by_cases hn : n < g 0\n  · apply hf1.2 m n mn\n    rwa [if_pos hn, if_pos (mn.trans hn)] at hmn\n  · obtain ⟨n', rfl⟩ := exists_add_of_le (not_lt.1 hn)\n    rw [if_neg hn, add_comm (g 0) n', add_tsub_cancel_right] at hmn\n    split_ifs  at hmn with hm hm\n    · apply hf1.2 m (g n') (lt_of_lt_of_le hm (g.monotone n'.zero_le))\n      exact trans hmn (List.tail_sublistForall₂_self _)\n    · rw [← tsub_lt_iff_left (le_of_not_lt hm)] at mn\n      apply hf1.2 _ _ (g.lt_iff_lt.2 mn)\n      rw [← List.cons_head!_tail (hnil (g (m - g 0))), ← List.cons_head!_tail (hnil (g n'))]\n      exact List.SublistForall₂.cons (hg _ _ (le_of_lt mn)) hmn\n#align partially_well_ordered_on_sublist_forall₂ partially_well_ordered_on_sublist_forall₂\n\n",
 "partially_well_ordered_on_singleton":
 "@[simp]\ntheorem partially_well_ordered_on_singleton (a : α) : PartiallyWellOrderedOn {a} r :=\n  (finite_singleton a).partially_well_ordered_on\n#align partially_well_ordered_on_singleton partially_well_ordered_on_singleton\n\n",
 "partially_well_ordered_on_insert":
 "@[simp]\ntheorem partially_well_ordered_on_insert : PartiallyWellOrderedOn (insert a s) r ↔ PartiallyWellOrderedOn s r := by\n  simp only [← singleton_union, partially_well_ordered_on_union, partially_well_ordered_on_singleton, true_and_iff]\n#align partially_well_ordered_on_insert partially_well_ordered_on_insert\n\n",
 "partially_well_ordered_on_iff_finite_antichains":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\ntheorem partially_well_ordered_on_iff_finite_antichains [is_symm α r] :\n    s.partially_well_ordered_on r ↔ ∀ (t) (_ : t ⊆ s), IsAntichain r t → t.finite :=\n  by\n  refine' ⟨fun h t ht hrt => hrt.finite_of_partially_well_ordered_on (h.mono ht), _⟩\n  rintro hs f hf\n  by_contra' H\n  refine' infinite_range_of_injective (fun m n hmn => _) (hs _ (range_subset_iff.2 hf) _)\n  · obtain h | h | h := lt_trichotomy m n\n    · refine' (H _ _ h _).elim\n      rw [hmn]\n      exact refl _\n    · exact h\n    · refine' (H _ _ h _).elim\n      rw [hmn]\n      exact refl _\n  rintro _ ⟨m, hm, rfl⟩ _ ⟨n, hn, rfl⟩ hmn\n  obtain h | h := (ne_of_apply_ne _ hmn).lt_or_lt\n  · exact H _ _ h\n  · exact mt symm (H _ _ h)\n#align partially_well_ordered_on_iff_finite_antichains partially_well_ordered_on_iff_finite_antichains\n\n",
 "partially_well_ordered_on_iff_exists_monotone_subseq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\ntheorem partially_well_ordered_on_iff_exists_monotone_subseq :\n    s.partially_well_ordered_on r ↔\n      ∀ f : ℕ → α, (∀ n, f n ∈ s) → ∃ g : «expr ↪o » ℕ ℕ, ∀ m n : ℕ, m ≤ n → r (f (g m)) (f (g n)) :=\n  by\n  classical\n    constructor <;> intro h f hf\n    · exact h.exists_monotone_subseq f hf\n    · obtain ⟨g, gmon⟩ := h f hf\n      exact ⟨g 0, g 1, g.lt_iff_lt.2 zero_lt_one, gmon _ _ zero_le_one⟩\n#align partially_well_ordered_on_iff_exists_monotone_subseq partially_well_ordered_on_iff_exists_monotone_subseq\n\n",
 "partially_well_ordered_on_iff":
 "#print IsAntichain.partiallyWellOrderedOn_iff /-\ntheorem IsAntichain.partiallyWellOrderedOn_iff (hs : IsAntichain r s) : s.partially_well_ordered_on r ↔ s.finite :=\n  ⟨hs.finite_of_partially_well_ordered_on, Finite.partiallyWellOrderedOn⟩\n#align is_antichain.partially_well_ordered_on_iff IsAntichain.partiallyWellOrderedOn_iff\n-/\n\n",
 "partially_well_ordered_on_empty":
 "@[simp]\ntheorem partially_well_ordered_on_empty (r : α → α → Prop) : PartiallyWellOrderedOn ∅ r := fun f hf => (hf 0).elim\n#align partially_well_ordered_on_empty partially_well_ordered_on_empty\n\n",
 "partially_well_ordered_on_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem partially_well_ordered_on_bUnion (s : Finset ι) {f : ι → Set α} :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (f i)).partially_well_ordered_on\n        r ↔\n      ∀ i ∈ s, (f i).partially_well_ordered_on r :=\n  by simpa only [Finset.sup_eq_supᵢ] using s.partially_well_ordered_on_sup\n#align partially_well_ordered_on_bUnion partially_well_ordered_on_bUnion\n\n",
 "partially_well_ordered_on":
 "@[simp]\nprotected theorem partially_well_ordered_on [is_refl α r] (s : Finset α) : (s : Set α).partially_well_ordered_on r :=\n  s.finite_to_set.partially_well_ordered_on\n#align partially_well_ordered_on partially_well_ordered_on\n\n",
 "not_lt_min":
 "theorem is_wf.not_lt_min (hs : IsWf s) (hn : s.nonempty) (ha : a ∈ s) : ¬a < hs.min hn :=\n  hs.not_lt_min univ (nonempty_iff_univ_nonempty.1 hn.to_subtype) (mem_univ (⟨a, ha⟩ : s))\n#align is_wf.not_lt_min is_wf.not_lt_min\n\n",
 "mono":
 "theorem is_pwo.mono (ht : t.is_pwo) : s ⊆ t → s.is_pwo :=\n  ht.mono\n#align is_pwo.mono is_pwo.mono\n\n",
 "min_union":
 "theorem is_wf.min_union (hs : s.is_wf) (hsn : s.nonempty) (ht : t.is_wf) (htn : t.nonempty) :\n    (hs.union ht).min (union_nonempty.2 (or.intro_left _ hsn)) = min (hs.min hsn) (ht.min htn) :=\n  by\n  refine'\n    le_antisymm\n      (le_min (is_wf.min_le_min_of_subset (subset_union_left _ _))\n        (is_wf.min_le_min_of_subset (subset_union_right _ _)))\n      _\n  rw [min_le_iff]\n  exact\n    ((mem_union _ _ _).1 ((hs.union ht).min_mem (union_nonempty.2 (or.intro_left _ hsn)))).imp (hs.min_le _)\n      (ht.min_le _)\n#align is_wf.min_union is_wf.min_union\n\n",
 "min_mem":
 "theorem is_wf.min_mem (hs : IsWf s) (hn : s.nonempty) : hs.min hn ∈ s :=\n  (WellFounded.min hs univ (nonempty_iff_univ_nonempty.1 hn.to_subtype)).2\n#align is_wf.min_mem is_wf.min_mem\n\n",
 "min_le_min_of_subset":
 "theorem is_wf.min_le_min_of_subset {hs : s.is_wf} {hsn : s.nonempty} {ht : t.is_wf} {htn : t.nonempty} (hst : s ⊆ t) :\n    ht.min htn ≤ hs.min hsn :=\n  (IsWf.le_min_iff _ _).2 fun b hb => ht.min_le htn (hst hb)\n#align is_wf.min_le_min_of_subset is_wf.min_le_min_of_subset\n\n",
 "min_le":
 "theorem is_wf.min_le (hs : s.is_wf) (hn : s.nonempty) (ha : a ∈ s) : hs.min hn ≤ a :=\n  le_of_not_lt (hs.not_lt_min hn ha)\n#align is_wf.min_le is_wf.min_le\n\n",
 "le_min_iff":
 "theorem is_wf.le_min_iff (hs : s.is_wf) (hn : s.nonempty) : a ≤ hs.min hn ↔ ∀ b, b ∈ s → a ≤ b :=\n  ⟨fun ha b hb => le_trans ha (hs.min_le hn hb), fun h => h _ (hs.min_mem _)⟩\n#align is_wf.le_min_iff is_wf.le_min_iff\n\n",
 "is_wf_univ_iff":
 "theorem is_wf_univ_iff : IsWf (univ : Set α) ↔ well_founded ((· < ·) : α → α → Prop) := by\n  simp [is_wf, well_founded_on_iff]\n#align is_wf_univ_iff is_wf_univ_iff\n\n",
 "is_wf_union":
 "@[simp]\ntheorem is_wf_union : IsWf (s ∪ t) ↔ IsWf s ∧ IsWf t :=\n  wellFoundedOn_union\n#align is_wf_union is_wf_union\n\n",
 "is_wf_sup":
 "theorem is_wf_sup [preorder α] (s : Finset ι) {f : ι → Set α} : (s.sup f).is_wf ↔ ∀ i ∈ s, (f i).is_wf :=\n  s.well_founded_on_sup\n#align is_wf_sup is_wf_sup\n\n",
 "is_wf_singleton":
 "@[simp]\ntheorem is_wf_singleton {a : α} : IsWf ({a} : Set α) :=\n  (finite_singleton a).is_wf\n#align is_wf_singleton is_wf_singleton\n\n",
 "is_wf_min_singleton":
 "@[simp]\ntheorem is_wf_min_singleton (a) {hs : IsWf ({a} : Set α)} {hn : ({a} : Set α).nonempty} : hs.min hn = a :=\n  eq_of_mem_singleton (IsWf.min_mem hs hn)\n#align is_wf_min_singleton is_wf_min_singleton\n\n",
 "is_wf_insert":
 "@[simp]\ntheorem is_wf_insert {a} : IsWf (insert a s) ↔ IsWf s := by\n  simp only [← singleton_union, is_wf_union, is_wf_singleton, true_and_iff]\n#align is_wf_insert is_wf_insert\n\n",
 "is_wf_iff_no_descending_seq":
 "theorem is_wf_iff_no_descending_seq : IsWf s ↔ ∀ f : ℕ → α, StrictAnti f → ¬∀ n, f (OrderDual.toDual n) ∈ s :=\n  wellFoundedOn_iff_no_descending_seq.trans\n    ⟨fun H f hf => H ⟨⟨f, hf.injective⟩, fun a b => hf.lt_iff_lt⟩, fun H f => H f fun _ _ => f.map_rel_iff.2⟩\n#align is_wf_iff_no_descending_seq is_wf_iff_no_descending_seq\n\n",
 "is_wf_iff_is_pwo":
 "/-- In a linear order, the predicates `set.is_wf` and `set.is_pwo` are equivalent. -/\ntheorem is_wf_iff_is_pwo : s.is_wf ↔ s.is_pwo :=\n  ⟨IsWf.isPwo, IsPwo.isWf⟩\n#align is_wf_iff_is_pwo is_wf_iff_is_pwo\n\n",
 "is_wf_empty":
 "@[simp]\ntheorem is_wf_empty : IsWf (∅ : Set α) :=\n  wellFounded_of_isEmpty _\n#align is_wf_empty is_wf_empty\n\n",
 "is_wf_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem is_wf_bUnion [preorder α] (s : Finset ι) {f : ι → Set α} :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)).is_wf ↔\n      ∀ i ∈ s, (f i).is_wf :=\n  s.well_founded_on_bUnion\n#align is_wf_bUnion is_wf_bUnion\n\n",
 "is_wf":
 "@[simp]\nprotected theorem is_wf [preorder α] (s : Finset α) : Set.IsWf (↑s : Set α) :=\n  s.finite_to_set.is_wf\n#align is_wf is_wf\n\n",
 "is_pwo_union":
 "@[simp]\ntheorem is_pwo_union : IsPwo (s ∪ t) ↔ IsPwo s ∧ IsPwo t :=\n  partiallyWellOrderedOn_union\n#align is_pwo_union is_pwo_union\n\n",
 "is_pwo_sup":
 "theorem is_pwo_sup [preorder α] (s : Finset ι) {f : ι → Set α} : (s.sup f).is_pwo ↔ ∀ i ∈ s, (f i).is_pwo :=\n  s.partially_well_ordered_on_sup\n#align is_pwo_sup is_pwo_sup\n\n",
 "is_pwo_singleton":
 "@[simp]\ntheorem is_pwo_singleton (a : α) : IsPwo ({a} : Set α) :=\n  (finite_singleton a).is_pwo\n#align is_pwo_singleton is_pwo_singleton\n\n",
 "is_pwo_of_finite":
 "@[simp]\ntheorem is_pwo_of_finite [Finite α] : s.is_pwo :=\n  s.to_finite.is_pwo\n#align is_pwo_of_finite is_pwo_of_finite\n\n",
 "is_pwo_insert":
 "@[simp]\ntheorem is_pwo_insert {a} : IsPwo (insert a s) ↔ IsPwo s := by\n  simp only [← singleton_union, is_pwo_union, is_pwo_singleton, true_and_iff]\n#align is_pwo_insert is_pwo_insert\n\n",
 "is_pwo_iff_exists_monotone_subseq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\ntheorem is_pwo_iff_exists_monotone_subseq :\n    s.is_pwo ↔ ∀ f : ℕ → α, (∀ n, f n ∈ s) → ∃ g : «expr ↪o » ℕ ℕ, Monotone (f ∘ g) :=\n  partiallyWellOrderedOn_iff_exists_monotone_subseq\n#align is_pwo_iff_exists_monotone_subseq is_pwo_iff_exists_monotone_subseq\n\n",
 "is_pwo_empty":
 "@[simp]\ntheorem is_pwo_empty : IsPwo (∅ : Set α) :=\n  finite_empty.is_pwo\n#align is_pwo_empty is_pwo_empty\n\n",
 "is_pwo_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem is_pwo_bUnion [preorder α] (s : Finset ι) {f : ι → Set α} :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)).is_pwo ↔\n      ∀ i ∈ s, (f i).is_pwo :=\n  s.partially_well_ordered_on_bUnion\n#align is_pwo_bUnion is_pwo_bUnion\n\n",
 "is_pwo":
 "@[simp]\nprotected theorem is_pwo [preorder α] (s : Finset α) : Set.IsPwo (↑s : Set α) :=\n  s.partially_well_ordered_on\n#align is_pwo is_pwo\n\n",
 "isWf":
 "#print WellFounded.isWf /-\ntheorem WellFounded.isWf [LT α] (h : well_founded ((· < ·) : α → α → Prop)) (s : Set α) : s.is_wf :=\n  (Set.isWf_univ_iff.2 h).mono s.subset_univ\n#align well_founded.is_wf WellFounded.isWf\n-/\n\n",
 "isPwo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n#print Pi.isPwo /-\n/-- A version of **Dickson's lemma** any subset of functions `Π s : σ, α s` is partially well\nordered, when `σ` is a `fintype` and each `α s` is a linear well order.\nThis includes the classical case of Dickson's lemma that `ℕ ^ n` is a well partial order.\nSome generalizations would be possible based on this proof, to include cases where the target is\npartially well ordered, and also to consider the case of `set.partially_well_ordered_on` instead of\n`set.is_pwo`. -/\ntheorem Pi.isPwo {α : ι → Type _} [∀ i, linear_order (α i)] [∀ i, IsWellOrder (α i) (· < ·)] [Finite ι]\n    (s : Set (∀ i, α i)) : s.is_pwo := by\n  cases nonempty_fintype ι\n  suffices\n    ∀ s : Finset ι,\n      ∀ f : ℕ → ∀ s, α s, ∃ g : «expr ↪o » ℕ ℕ, ∀ ⦃a b : ℕ⦄, a ≤ b → ∀ (x : ι) (hs : x ∈ s), (f ∘ g) a x ≤ (f ∘ g) b x\n    by\n    refine' is_pwo_iff_exists_monotone_subseq.2 fun f hf => _\n    simpa only [Finset.mem_univ, true_imp_iff] using this Finset.univ f\n  refine' Finset.cons_induction _ _\n  · intro f\n    exists RelEmbedding.refl (· ≤ ·)\n    simp only [IsEmpty.forall_iff, imp_true_iff, forall_const, Finset.not_mem_empty]\n  · intro x s hx ih f\n    obtain ⟨g, hg⟩ := (is_well_founded.wf.is_wf univ).is_pwo.exists_monotone_subseq (fun n => f n x) mem_univ\n    obtain ⟨g', hg'⟩ := ih (f ∘ g)\n    refine' ⟨g'.trans g, fun a b hab => (Finset.forall_mem_cons _ _).2 _⟩\n    exact ⟨hg (OrderHomClass.mono g' hab), hg' hab⟩\n#align pi.is_pwo Pi.isPwo\n-/\n\n",
 "insert":
 "theorem well_founded_on.insert (h : WellFoundedOn s r) (a : α) : WellFoundedOn (insert a s) r :=\n  wellFoundedOn_insert.2 h\n#align well_founded_on.insert well_founded_on.insert\n\n",
 "induction":
 "protected theorem induction (hs : s.well_founded_on r) (hx : x ∈ s) {P : α → Prop}\n    (hP : ∀ y ∈ s, (∀ z ∈ s, r z y → P z) → P y) : P x :=\n  by\n  let Q : s → Prop := fun y => P y\n  change Q ⟨x, hx⟩\n  refine' well_founded.induction hs ⟨x, hx⟩ _\n  simpa only [Subtype.forall]\n#align induction induction\n\n",
 "image_of_monotone_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_pwo.image_of_monotone_on (hs : s.is_pwo) {f : α → β} (hf : MonotoneOn f s) : IsPwo («expr '' » f s) :=\n  hs.image_of_monotone_on hf\n#align is_pwo.image_of_monotone_on is_pwo.image_of_monotone_on\n\n",
 "image_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_pwo.image_of_monotone (hs : s.is_pwo) {f : α → β} (hf : Monotone f) : IsPwo («expr '' » f s) :=\n  hs.image_of_monotone_on (hf.monotone_on _)\n#align is_pwo.image_of_monotone is_pwo.image_of_monotone\n\n",
 "iff_not_exists_is_min_bad_seq":
 "theorem iff_not_exists_is_min_bad_seq (rk : α → ℕ) {s : Set α} :\n    s.partially_well_ordered_on r ↔ ¬∃ f, IsBadSeq r s f ∧ ∀ n, IsMinBadSeq r rk s n f :=\n  by\n  rw [iff_forall_not_is_bad_seq, ← not_exists, not_congr]\n  constructor\n  · apply exists_min_bad_of_exists_bad\n  rintro ⟨f, hf1, hf2⟩\n  exact ⟨f, hf1⟩\n#align iff_not_exists_is_min_bad_seq iff_not_exists_is_min_bad_seq\n\n",
 "iff_forall_not_is_bad_seq":
 "theorem iff_forall_not_is_bad_seq (r : α → α → Prop) (s : Set α) :\n    s.partially_well_ordered_on r ↔ ∀ f, ¬IsBadSeq r s f :=\n  forall_congr' fun f => by simp [is_bad_seq]\n#align iff_forall_not_is_bad_seq iff_forall_not_is_bad_seq\n\n",
 "finite_of_partially_well_ordered_on":
 "#print IsAntichain.finite_of_partiallyWellOrderedOn /-\ntheorem IsAntichain.finite_of_partiallyWellOrderedOn (ha : IsAntichain r s) (hp : s.partially_well_ordered_on r) :\n    s.finite := by\n  refine' not_infinite.1 fun hi => _\n  obtain ⟨m, n, hmn, h⟩ := hp (fun n => hi.nat_embedding _ n) fun n => (hi.nat_embedding _ n).2\n  exact\n    hmn.ne\n      ((hi.nat_embedding _).injective <|\n        Subtype.val_injective <| ha.eq (hi.nat_embedding _ m).2 (hi.nat_embedding _ n).2 h)\n#align is_antichain.finite_of_partially_well_ordered_on IsAntichain.finite_of_partiallyWellOrderedOn\n-/\n\n",
 "exists_monotone_subseq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\ntheorem is_pwo.exists_monotone_subseq (h : s.is_pwo) (f : ℕ → α) (hf : ∀ n, f n ∈ s) :\n    ∃ g : «expr ↪o » ℕ ℕ, Monotone (f ∘ g) :=\n  h.exists_monotone_subseq f hf\n#align is_pwo.exists_monotone_subseq is_pwo.exists_monotone_subseq\n\n",
 "exists_min_bad_of_exists_bad":
 "theorem exists_min_bad_of_exists_bad (r : α → α → Prop) (rk : α → ℕ) (s : Set α) :\n    (∃ f, IsBadSeq r s f) → ∃ f, IsBadSeq r s f ∧ ∀ n, IsMinBadSeq r rk s n f :=\n  by\n  rintro ⟨f0, hf0 : is_bad_seq r s f0⟩\n  let fs : ∀ n : ℕ, { f : ℕ → α // is_bad_seq r s f ∧ is_min_bad_seq r rk s n f } :=\n    by\n    refine' nat.rec _ _\n    · exact ⟨(min_bad_seq_of_bad_seq r rk s 0 f0 hf0).1, (min_bad_seq_of_bad_seq r rk s 0 f0 hf0).2.2⟩\n    ·\n      exact fun n fn =>\n        ⟨(min_bad_seq_of_bad_seq r rk s (n + 1) fn.1 fn.2.1).1, (min_bad_seq_of_bad_seq r rk s (n + 1) fn.1 fn.2.1).2.2⟩\n  have h : ∀ m n, m ≤ n → (fs m).1 m = (fs n).1 m := by\n    intro m n mn\n    obtain ⟨k, rfl⟩ := exists_add_of_le mn\n    clear mn\n    induction' k with k ih\n    · rfl\n    rw [ih,\n      (min_bad_seq_of_bad_seq r rk s (m + k).succ (fs (m + k)).1 (fs (m + k)).2.1).2.1 m\n        (Nat.lt_succ_iff.2 (nat.add_le_add_left k.zero_le m))]\n    rfl\n  refine' ⟨fun n => (fs n).1 n, ⟨fun n => (fs n).2.1.1 n, fun m n mn => _⟩, fun n g hg1 hg2 => _⟩\n  · dsimp\n    rw [← subtype.val_eq_coe, h m n (le_of_lt mn)]\n    convert(fs n).2.1.2 m n mn\n  · convert(fs n).2.2 g (fun m mn => Eq.trans _ (hg1 m mn)) (lt_of_lt_of_le hg2 le_rfl)\n    rw [← h m n (le_of_lt mn)]\n#align exists_min_bad_of_exists_bad exists_min_bad_of_exists_bad\n\n",
 "acc_iff_well_founded_on":
 "/-- `a` is accessible under the relation `r` iff `r` is well-founded on the downward transitive\n  closure of `a` under `r` (including `a` or not). -/\ntheorem acc_iff_well_founded_on {α} {r : α → α → Prop} {a : α} :\n    [acc r a, { b | ReflTransGen r b a }.well_founded_on r, { b | TransGen r b a }.well_founded_on r].tfae :=\n  by\n  tfae_have 1 → 2\n  · refine' fun h => ⟨fun b => _⟩\n    apply InvImage.accessible\n    rw [← acc_transGen_iff] at h⊢\n    obtain h' | h' := refl_trans_gen_iff_eq_or_trans_gen.1 b.2\n    · rwa [h'] at h\n    · exact h.inv h'\n  tfae_have 2 → 3\n  · exact fun h => h.subset fun _ => trans_gen.to_refl\n  tfae_have 3 → 1\n  · refine' fun h => acc.intro _ fun b hb => (h.apply ⟨b, trans_gen.single hb⟩).of_fibration Subtype.val _\n    exact fun ⟨c, hc⟩ d h => ⟨⟨d, trans_gen.head h hc⟩, h, rfl⟩\n  tfae_finish\n#align acc_iff_well_founded_on acc_iff_well_founded_on\n\n"}