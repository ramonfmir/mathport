{"well_founded_on_union":
 "@[simp]\ntheorem well_founded_on_union : (s ∪ t).well_founded_on r ↔ s.well_founded_on r ∧ t.well_founded_on r :=\n  ⟨fun h => ⟨h.subset <| subset_union_left _ _, h.subset <| subset_union_right _ _⟩, fun h => h.1.union h.2⟩\n#align well_founded_on_union well_founded_on_union\n\n",
 "well_founded_on_sup":
 "theorem well_founded_on_sup [is_strict_order α r] (s : Finset ι) {f : ι → set α} :\n    (s.sup f).well_founded_on r ↔ ∀ i ∈ s, (f i).well_founded_on r :=\n  Finset.cons_induction_on s (by simp) fun a s ha hs => by simp [-sup_set_eq_bUnion, hs]\n#align well_founded_on_sup well_founded_on_sup\n\n",
 "well_founded_on_singleton":
 "@[simp]\ntheorem well_founded_on_singleton : well_founded_on ({a} : set α) r :=\n  (finite_singleton a).well_founded_on\n#align well_founded_on_singleton well_founded_on_singleton\n\n",
 "well_founded_on_insert":
 "@[simp]\ntheorem well_founded_on_insert : well_founded_on (insert a s) r ↔ well_founded_on s r := by\n  simp only [← singleton_union, well_founded_on_union, well_founded_on_singleton, true_and_iff]\n#align well_founded_on_insert well_founded_on_insert\n\n",
 "well_founded_on_iff_no_descending_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪r » -/\ntheorem well_founded_on_iff_no_descending_seq :\n    s.well_founded_on r ↔ ∀ f : «expr ↪r » ((· > ·) : ℕ → ℕ → Prop) r, ¬∀ n, f n ∈ s :=\n  by\n  simp only [well_founded_on_iff, rel_embedding.well_founded_iff_no_descending_seq, ← not_exists, ← not_nonempty_iff,\n    not_iff_not]\n  constructor\n  · rintro ⟨⟨f, hf⟩⟩\n    have H : ∀ n, f n ∈ s := fun n => (hf.2 n.lt_succ_self).2.2\n    refine' ⟨⟨f, _⟩, H⟩\n    simpa only [H, and_true_iff] using @hf\n  · rintro ⟨⟨f, hf⟩, hfs : ∀ n, f n ∈ s⟩\n    refine' ⟨⟨f, _⟩⟩\n    simpa only [hfs, and_true_iff] using @hf\n#align well_founded_on_iff_no_descending_seq well_founded_on_iff_no_descending_seq\n\n",
 "well_founded_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem well_founded_on_iff : s.well_founded_on r ↔ well_founded fun a b : α => r a b ∧ a ∈ s ∧ b ∈ s :=\n  by\n  have f : RelEmbedding (fun (a : s) (b : s) => r a b) fun a b : α => r a b ∧ a ∈ s ∧ b ∈ s :=\n    ⟨⟨coe, subtype.coe_injective⟩, fun a b => by simp⟩\n  refine' ⟨fun h => _, f.well_founded⟩\n  rw [WellFounded.wellFounded_iff_has_min]\n  intro t ht\n  by_cases hst : (s ∩ t).nonempty\n  · rw [← Subtype.preimage_coe_nonempty] at hst\n    rcases h.has_min («expr ⁻¹' » coe t) hst with ⟨⟨m, ms⟩, mt, hm⟩\n    exact ⟨m, mt, fun x xt ⟨xm, xs, ms⟩ => hm ⟨x, xs⟩ xt xm⟩\n  · rcases ht with ⟨m, mt⟩\n    exact ⟨m, mt, fun x xt ⟨xm, xs, ms⟩ => hst ⟨m, ⟨ms, mt⟩⟩⟩\n#align well_founded_on_iff well_founded_on_iff\n\n",
 "well_founded_on_empty":
 "/-\nCopyright (c) 2021 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\n@[simp]\ntheorem well_founded_on_empty (r : α → α → Prop) : well_founded_on ∅ r :=\n  wellFounded_of_isEmpty _\n#align well_founded_on_empty well_founded_on_empty\n\n",
 "well_founded_on_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem well_founded_on_bUnion [is_strict_order α r] (s : Finset ι) {f : ι → set α} :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (f i)).well_founded_on\n        r ↔\n      ∀ i ∈ s, (f i).well_founded_on r :=\n  by simpa only [finset.sup_eq_supr] using s.well_founded_on_sup\n#align well_founded_on_bUnion well_founded_on_bUnion\n\n",
 "well_founded_on":
 "@[simp]\nprotected theorem well_founded_on [is_strict_order α r] (s : Finset α) : set.well_founded_on (↑s : set α) r :=\n  letI := partial_order_of_SO r\n  s.is_wf\n#align well_founded_on well_founded_on\n\n",
 "union":
 "protected theorem is_pwo.union (hs : is_pwo s) (ht : is_pwo t) : is_pwo (s ∪ t) :=\n  hs.union ht\n#align is_pwo.union is_pwo.union\n\n",
 "subset":
 "theorem subset (h : t.well_founded_on r) (hst : s ⊆ t) : s.well_founded_on r :=\n  h.mono le_rfl hst\n#align subset subset\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem is_pwo.prod {t : set β} (hs : s.is_pwo) (ht : t.is_pwo) : is_pwo (finset.product s t) :=\n  hs.prod ht\n#align is_pwo.prod is_pwo.prod\n\n",
 "partially_well_ordered_on_union":
 "@[simp]\ntheorem partially_well_ordered_on_union :\n    (s ∪ t).partially_well_ordered_on r ↔ s.partially_well_ordered_on r ∧ t.partially_well_ordered_on r :=\n  ⟨fun h => ⟨h.mono <| subset_union_left _ _, h.mono <| subset_union_right _ _⟩, fun h => h.1.union h.2⟩\n#align partially_well_ordered_on_union partially_well_ordered_on_union\n\n",
 "partially_well_ordered_on_sup":
 "theorem partially_well_ordered_on_sup (s : Finset ι) {f : ι → set α} :\n    (s.sup f).partially_well_ordered_on r ↔ ∀ i ∈ s, (f i).partially_well_ordered_on r :=\n  Finset.cons_induction_on s (by simp) fun a s ha hs => by simp [-sup_set_eq_bUnion, hs]\n#align partially_well_ordered_on_sup partially_well_ordered_on_sup\n\n",
 "partially_well_ordered_on_sublist_forall₂":
 "/-- Higman's Lemma, which states that for any reflexive, transitive relation `r` which is\n  partially well-ordered on a set `s`, the relation `list.sublist_forall₂ r` is partially\n  well-ordered on the set of lists of elements of `s`. That relation is defined so that\n  `list.sublist_forall₂ r l₁ l₂` whenever `l₁` related pointwise by `r` to a sublist of `l₂`.  -/\ntheorem partially_well_ordered_on_sublist_forall₂ (r : α → α → Prop) [is_refl α r] [is_trans α r] {s : set α}\n    (h : s.partially_well_ordered_on r) :\n    { l : list α | ∀ x, x ∈ l → x ∈ s }.partially_well_ordered_on (List.SublistForall₂ r) :=\n  by\n  rcases s.eq_empty_or_nonempty with (rfl | ⟨as, has⟩)\n  · apply partially_well_ordered_on.mono (finset.partially_well_ordered_on {list.nil})\n    · intro l hl\n      rw [Finset.mem_coe, Finset.mem_singleton, List.eq_nil_iff_forall_not_mem]\n      exact hl\n    infer_instance\n  haveI : inhabited α := ⟨as⟩\n  rw [iff_not_exists_is_min_bad_seq list.length]\n  rintro ⟨f, hf1, hf2⟩\n  have hnil : ∀ n, f n ≠ list.nil := fun n con => hf1.2 n n.succ n.lt_succ_self (con.symm ▸ List.SublistForall₂.nil)\n  obtain ⟨g, hg⟩ := h.exists_monotone_subseq (List.headI ∘ f) _\n  swap;\n  · simp only [Set.range_subset_iff, function.comp_apply]\n    exact fun n => hf1.1 n _ (List.head!_mem_self (hnil n))\n  have hf' := hf2 (g 0) (fun n => if n < g 0 then f n else list.tail (f (g (n - g 0)))) (fun m hm => (if_pos hm).symm) _\n  swap;\n  · simp only [if_neg (lt_irrefl (g 0)), tsub_self]\n    rw [list.length_tail, ← Nat.pred_eq_sub_one]\n    exact nat.pred_lt fun con => hnil _ (List.length_eq_zero.1 con)\n  rw [is_bad_seq] at hf'\n  push_neg  at hf'\n  obtain ⟨m, n, mn, hmn⟩ := hf' _\n  swap\n  · rintro n x hx\n    split_ifs  at hx with hn hn\n    · exact hf1.1 _ _ hx\n    · refine' hf1.1 _ _ (List.tail_subset _ hx)\n  by_cases hn : n < g 0\n  · apply hf1.2 m n mn\n    rwa [if_pos hn, if_pos (mn.trans hn)] at hmn\n  · obtain ⟨n', rfl⟩ := exists_add_of_le (not_lt.1 hn)\n    rw [if_neg hn, add_comm (g 0) n', add_tsub_cancel_right] at hmn\n    split_ifs  at hmn with hm hm\n    · apply hf1.2 m (g n') (lt_of_lt_of_le hm (g.monotone n'.zero_le))\n      exact trans hmn (List.tail_sublistForall₂_self _)\n    · rw [← tsub_lt_iff_left (le_of_not_lt hm)] at mn\n      apply hf1.2 _ _ (g.lt_iff_lt.2 mn)\n      rw [← List.cons_head!_tail (hnil (g (m - g 0))), ← List.cons_head!_tail (hnil (g n'))]\n      exact List.SublistForall₂.cons (hg _ _ (le_of_lt mn)) hmn\n#align partially_well_ordered_on_sublist_forall₂ partially_well_ordered_on_sublist_forall₂\n\n",
 "partially_well_ordered_on_singleton":
 "@[simp]\ntheorem partially_well_ordered_on_singleton (a : α) : partially_well_ordered_on {a} r :=\n  (finite_singleton a).partially_well_ordered_on\n#align partially_well_ordered_on_singleton partially_well_ordered_on_singleton\n\n",
 "partially_well_ordered_on_insert":
 "@[simp]\ntheorem partially_well_ordered_on_insert : partially_well_ordered_on (insert a s) r ↔ partially_well_ordered_on s r :=\n  by simp only [← singleton_union, partially_well_ordered_on_union, partially_well_ordered_on_singleton, true_and_iff]\n#align partially_well_ordered_on_insert partially_well_ordered_on_insert\n\n",
 "partially_well_ordered_on_iff_finite_antichains":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\ntheorem partially_well_ordered_on_iff_finite_antichains [is_symm α r] :\n    s.partially_well_ordered_on r ↔ ∀ (t) (_ : t ⊆ s), IsAntichain r t → t.finite :=\n  by\n  refine' ⟨fun h t ht hrt => hrt.finite_of_partially_well_ordered_on (h.mono ht), _⟩\n  rintro hs f hf\n  by_contra' H\n  refine' infinite_range_of_injective (fun m n hmn => _) (hs _ (range_subset_iff.2 hf) _)\n  · obtain h | h | h := lt_trichotomy m n\n    · refine' (H _ _ h _).elim\n      rw [hmn]\n      exact refl _\n    · exact h\n    · refine' (H _ _ h _).elim\n      rw [hmn]\n      exact refl _\n  rintro _ ⟨m, hm, rfl⟩ _ ⟨n, hn, rfl⟩ hmn\n  obtain h | h := (ne_of_apply_ne _ hmn).lt_or_lt\n  · exact H _ _ h\n  · exact mt symm (H _ _ h)\n#align partially_well_ordered_on_iff_finite_antichains partially_well_ordered_on_iff_finite_antichains\n\n",
 "partially_well_ordered_on_iff_exists_monotone_subseq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\ntheorem partially_well_ordered_on_iff_exists_monotone_subseq :\n    s.partially_well_ordered_on r ↔\n      ∀ f : ℕ → α, (∀ n, f n ∈ s) → ∃ g : «expr ↪o » ℕ ℕ, ∀ m n : ℕ, m ≤ n → r (f (g m)) (f (g n)) :=\n  by\n  classical\n    constructor <;> intro h f hf\n    · exact h.exists_monotone_subseq f hf\n    · obtain ⟨g, gmon⟩ := h f hf\n      exact ⟨g 0, g 1, g.lt_iff_lt.2 zero_lt_one, gmon _ _ zero_le_one⟩\n#align partially_well_ordered_on_iff_exists_monotone_subseq partially_well_ordered_on_iff_exists_monotone_subseq\n\n",
 "partially_well_ordered_on_iff":
 "theorem _root_.is_antichain.partially_well_ordered_on_iff (hs : IsAntichain r s) :\n    s.partially_well_ordered_on r ↔ s.finite :=\n  ⟨hs.finite_of_partially_well_ordered_on, finite.partially_well_ordered_on⟩\n#align is_antichain.partially_well_ordered_on_iff is_antichain.partially_well_ordered_on_iff\n\n",
 "partially_well_ordered_on_empty":
 "@[simp]\ntheorem partially_well_ordered_on_empty (r : α → α → Prop) : partially_well_ordered_on ∅ r := fun f hf => (hf 0).elim\n#align partially_well_ordered_on_empty partially_well_ordered_on_empty\n\n",
 "partially_well_ordered_on_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem partially_well_ordered_on_bUnion (s : Finset ι) {f : ι → set α} :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (f i)).partially_well_ordered_on\n        r ↔\n      ∀ i ∈ s, (f i).partially_well_ordered_on r :=\n  by simpa only [finset.sup_eq_supr] using s.partially_well_ordered_on_sup\n#align partially_well_ordered_on_bUnion partially_well_ordered_on_bUnion\n\n",
 "partially_well_ordered_on":
 "@[simp]\nprotected theorem partially_well_ordered_on [is_refl α r] (s : Finset α) : (s : set α).partially_well_ordered_on r :=\n  s.finite_to_set.partially_well_ordered_on\n#align partially_well_ordered_on partially_well_ordered_on\n\n",
 "not_lt_min":
 "theorem is_wf.not_lt_min (hs : is_wf s) (hn : s.nonempty) (ha : a ∈ s) : ¬a < hs.min hn :=\n  hs.not_lt_min univ (nonempty_iff_univ_nonempty.1 hn.to_subtype) (mem_univ (⟨a, ha⟩ : s))\n#align is_wf.not_lt_min is_wf.not_lt_min\n\n",
 "mono":
 "theorem is_pwo.mono (ht : t.is_pwo) : s ⊆ t → s.is_pwo :=\n  ht.mono\n#align is_pwo.mono is_pwo.mono\n\n",
 "min_union":
 "theorem is_wf.min_union (hs : s.is_wf) (hsn : s.nonempty) (ht : t.is_wf) (htn : t.nonempty) :\n    (hs.union ht).min (union_nonempty.2 (or.intro_left _ hsn)) = min (hs.min hsn) (ht.min htn) :=\n  by\n  refine'\n    le_antisymm\n      (le_min (is_wf.min_le_min_of_subset (subset_union_left _ _))\n        (is_wf.min_le_min_of_subset (subset_union_right _ _)))\n      _\n  rw [min_le_iff]\n  exact\n    ((mem_union _ _ _).1 ((hs.union ht).min_mem (union_nonempty.2 (or.intro_left _ hsn)))).imp (hs.min_le _)\n      (ht.min_le _)\n#align is_wf.min_union is_wf.min_union\n\n",
 "min_mem":
 "theorem is_wf.min_mem (hs : is_wf s) (hn : s.nonempty) : hs.min hn ∈ s :=\n  (WellFounded.min hs univ (nonempty_iff_univ_nonempty.1 hn.to_subtype)).2\n#align is_wf.min_mem is_wf.min_mem\n\n",
 "min_le_min_of_subset":
 "theorem is_wf.min_le_min_of_subset {hs : s.is_wf} {hsn : s.nonempty} {ht : t.is_wf} {htn : t.nonempty} (hst : s ⊆ t) :\n    ht.min htn ≤ hs.min hsn :=\n  (is_wf.le_min_iff _ _).2 fun b hb => ht.min_le htn (hst hb)\n#align is_wf.min_le_min_of_subset is_wf.min_le_min_of_subset\n\n",
 "min_le":
 "theorem is_wf.min_le (hs : s.is_wf) (hn : s.nonempty) (ha : a ∈ s) : hs.min hn ≤ a :=\n  le_of_not_lt (hs.not_lt_min hn ha)\n#align is_wf.min_le is_wf.min_le\n\n",
 "le_min_iff":
 "theorem is_wf.le_min_iff (hs : s.is_wf) (hn : s.nonempty) : a ≤ hs.min hn ↔ ∀ b, b ∈ s → a ≤ b :=\n  ⟨fun ha b hb => le_trans ha (hs.min_le hn hb), fun h => h _ (hs.min_mem _)⟩\n#align is_wf.le_min_iff is_wf.le_min_iff\n\n",
 "is_wf_univ_iff":
 "theorem is_wf_univ_iff : is_wf (univ : set α) ↔ well_founded ((· < ·) : α → α → Prop) := by\n  simp [is_wf, well_founded_on_iff]\n#align is_wf_univ_iff is_wf_univ_iff\n\n",
 "is_wf_union":
 "@[simp]\ntheorem is_wf_union : is_wf (s ∪ t) ↔ is_wf s ∧ is_wf t :=\n  well_founded_on_union\n#align is_wf_union is_wf_union\n\n",
 "is_wf_sup":
 "theorem is_wf_sup [preorder α] (s : Finset ι) {f : ι → set α} : (s.sup f).is_wf ↔ ∀ i ∈ s, (f i).is_wf :=\n  s.well_founded_on_sup\n#align is_wf_sup is_wf_sup\n\n",
 "is_wf_singleton":
 "@[simp]\ntheorem is_wf_singleton {a : α} : is_wf ({a} : set α) :=\n  (finite_singleton a).is_wf\n#align is_wf_singleton is_wf_singleton\n\n",
 "is_wf_min_singleton":
 "@[simp]\ntheorem is_wf_min_singleton (a) {hs : is_wf ({a} : set α)} {hn : ({a} : set α).nonempty} : hs.min hn = a :=\n  eq_of_mem_singleton (is_wf.min_mem hs hn)\n#align is_wf_min_singleton is_wf_min_singleton\n\n",
 "is_wf_insert":
 "@[simp]\ntheorem is_wf_insert {a} : is_wf (insert a s) ↔ is_wf s := by\n  simp only [← singleton_union, is_wf_union, is_wf_singleton, true_and_iff]\n#align is_wf_insert is_wf_insert\n\n",
 "is_wf_iff_no_descending_seq":
 "theorem is_wf_iff_no_descending_seq : is_wf s ↔ ∀ f : ℕ → α, strict_anti f → ¬∀ n, f (OrderDual.toDual n) ∈ s :=\n  well_founded_on_iff_no_descending_seq.trans\n    ⟨fun H f hf => H ⟨⟨f, hf.injective⟩, fun a b => hf.lt_iff_lt⟩, fun H f => H f fun _ _ => f.map_rel_iff.2⟩\n#align is_wf_iff_no_descending_seq is_wf_iff_no_descending_seq\n\n",
 "is_wf_iff_is_pwo":
 "/-- In a linear order, the predicates `set.is_wf` and `set.is_pwo` are equivalent. -/\ntheorem is_wf_iff_is_pwo : s.is_wf ↔ s.is_pwo :=\n  ⟨is_wf.is_pwo, is_pwo.is_wf⟩\n#align is_wf_iff_is_pwo is_wf_iff_is_pwo\n\n",
 "is_wf_empty":
 "@[simp]\ntheorem is_wf_empty : is_wf (∅ : set α) :=\n  wellFounded_of_isEmpty _\n#align is_wf_empty is_wf_empty\n\n",
 "is_wf_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem is_wf_bUnion [preorder α] (s : Finset ι) {f : ι → set α} :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)).is_wf ↔\n      ∀ i ∈ s, (f i).is_wf :=\n  s.well_founded_on_bUnion\n#align is_wf_bUnion is_wf_bUnion\n\n",
 "is_wf":
 "theorem well_founded.is_wf [LT α] (h : well_founded ((· < ·) : α → α → Prop)) (s : set α) : s.is_wf :=\n  (set.is_wf_univ_iff.2 h).mono s.subset_univ\n#align well_founded.is_wf well_founded.is_wf\n\n",
 "is_pwo_union":
 "@[simp]\ntheorem is_pwo_union : is_pwo (s ∪ t) ↔ is_pwo s ∧ is_pwo t :=\n  partially_well_ordered_on_union\n#align is_pwo_union is_pwo_union\n\n",
 "is_pwo_sup":
 "theorem is_pwo_sup [preorder α] (s : Finset ι) {f : ι → set α} : (s.sup f).is_pwo ↔ ∀ i ∈ s, (f i).is_pwo :=\n  s.partially_well_ordered_on_sup\n#align is_pwo_sup is_pwo_sup\n\n",
 "is_pwo_singleton":
 "@[simp]\ntheorem is_pwo_singleton (a : α) : is_pwo ({a} : set α) :=\n  (finite_singleton a).is_pwo\n#align is_pwo_singleton is_pwo_singleton\n\n",
 "is_pwo_of_finite":
 "@[simp]\ntheorem is_pwo_of_finite [Finite α] : s.is_pwo :=\n  s.to_finite.is_pwo\n#align is_pwo_of_finite is_pwo_of_finite\n\n",
 "is_pwo_insert":
 "@[simp]\ntheorem is_pwo_insert {a} : is_pwo (insert a s) ↔ is_pwo s := by\n  simp only [← singleton_union, is_pwo_union, is_pwo_singleton, true_and_iff]\n#align is_pwo_insert is_pwo_insert\n\n",
 "is_pwo_iff_exists_monotone_subseq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\ntheorem is_pwo_iff_exists_monotone_subseq :\n    s.is_pwo ↔ ∀ f : ℕ → α, (∀ n, f n ∈ s) → ∃ g : «expr ↪o » ℕ ℕ, monotone (f ∘ g) :=\n  partially_well_ordered_on_iff_exists_monotone_subseq\n#align is_pwo_iff_exists_monotone_subseq is_pwo_iff_exists_monotone_subseq\n\n",
 "is_pwo_empty":
 "@[simp]\ntheorem is_pwo_empty : is_pwo (∅ : set α) :=\n  finite_empty.is_pwo\n#align is_pwo_empty is_pwo_empty\n\n",
 "is_pwo_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem is_pwo_bUnion [preorder α] (s : Finset ι) {f : ι → set α} :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)).is_pwo ↔\n      ∀ i ∈ s, (f i).is_pwo :=\n  s.partially_well_ordered_on_bUnion\n#align is_pwo_bUnion is_pwo_bUnion\n\n",
 "is_pwo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n/-- A version of **Dickson's lemma** any subset of functions `Π s : σ, α s` is partially well\nordered, when `σ` is a `fintype` and each `α s` is a linear well order.\nThis includes the classical case of Dickson's lemma that `ℕ ^ n` is a well partial order.\nSome generalizations would be possible based on this proof, to include cases where the target is\npartially well ordered, and also to consider the case of `set.partially_well_ordered_on` instead of\n`set.is_pwo`. -/\ntheorem pi.is_pwo {α : ι → Type _} [∀ i, linear_order (α i)] [∀ i, is_well_order (α i) (· < ·)] [Finite ι]\n    (s : set (∀ i, α i)) : s.is_pwo := by\n  cases nonempty_fintype ι\n  suffices\n    ∀ s : Finset ι,\n      ∀ f : ℕ → ∀ s, α s, ∃ g : «expr ↪o » ℕ ℕ, ∀ ⦃a b : ℕ⦄, a ≤ b → ∀ (x : ι) (hs : x ∈ s), (f ∘ g) a x ≤ (f ∘ g) b x\n    by\n    refine' is_pwo_iff_exists_monotone_subseq.2 fun f hf => _\n    simpa only [finset.mem_univ, true_imp_iff] using this finset.univ f\n  refine' Finset.cons_induction _ _\n  · intro f\n    exists RelEmbedding.refl (· ≤ ·)\n    simp only [is_empty.forall_iff, imp_true_iff, forall_const, Finset.not_mem_empty]\n  · intro x s hx ih f\n    obtain ⟨g, hg⟩ := (is_well_founded.wf.is_wf univ).is_pwo.exists_monotone_subseq (fun n => f n x) mem_univ\n    obtain ⟨g', hg'⟩ := ih (f ∘ g)\n    refine' ⟨g'.trans g, fun a b hab => (Finset.forall_mem_cons _ _).2 _⟩\n    exact ⟨hg (OrderHomClass.mono g' hab), hg' hab⟩\n#align pi.is_pwo pi.is_pwo\n\n",
 "insert":
 "theorem well_founded_on.insert (h : well_founded_on s r) (a : α) : well_founded_on (insert a s) r :=\n  well_founded_on_insert.2 h\n#align well_founded_on.insert well_founded_on.insert\n\n",
 "induction":
 "protected theorem induction (hs : s.well_founded_on r) (hx : x ∈ s) {P : α → Prop}\n    (hP : ∀ y ∈ s, (∀ z ∈ s, r z y → P z) → P y) : P x :=\n  by\n  let Q : s → Prop := fun y => P y\n  change Q ⟨x, hx⟩\n  refine' well_founded.induction hs ⟨x, hx⟩ _\n  simpa only [subtype.forall]\n#align induction induction\n\n",
 "image_of_monotone_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_pwo.image_of_monotone_on (hs : s.is_pwo) {f : α → β} (hf : monotone_on f s) : is_pwo («expr '' » f s) :=\n  hs.image_of_monotone_on hf\n#align is_pwo.image_of_monotone_on is_pwo.image_of_monotone_on\n\n",
 "image_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_pwo.image_of_monotone (hs : s.is_pwo) {f : α → β} (hf : monotone f) : is_pwo («expr '' » f s) :=\n  hs.image_of_monotone_on (hf.monotone_on _)\n#align is_pwo.image_of_monotone is_pwo.image_of_monotone\n\n",
 "iff_not_exists_is_min_bad_seq":
 "theorem iff_not_exists_is_min_bad_seq (rk : α → ℕ) {s : set α} :\n    s.partially_well_ordered_on r ↔ ¬∃ f, is_bad_seq r s f ∧ ∀ n, is_min_bad_seq r rk s n f :=\n  by\n  rw [iff_forall_not_is_bad_seq, ← not_exists, not_congr]\n  constructor\n  · apply exists_min_bad_of_exists_bad\n  rintro ⟨f, hf1, hf2⟩\n  exact ⟨f, hf1⟩\n#align iff_not_exists_is_min_bad_seq iff_not_exists_is_min_bad_seq\n\n",
 "iff_forall_not_is_bad_seq":
 "theorem iff_forall_not_is_bad_seq (r : α → α → Prop) (s : set α) :\n    s.partially_well_ordered_on r ↔ ∀ f, ¬is_bad_seq r s f :=\n  forall_congr' fun f => by simp [is_bad_seq]\n#align iff_forall_not_is_bad_seq iff_forall_not_is_bad_seq\n\n",
 "finite_of_partially_well_ordered_on":
 "theorem _root_.is_antichain.finite_of_partially_well_ordered_on (ha : IsAntichain r s)\n    (hp : s.partially_well_ordered_on r) : s.finite :=\n  by\n  refine' not_infinite.1 fun hi => _\n  obtain ⟨m, n, hmn, h⟩ := hp (fun n => hi.nat_embedding _ n) fun n => (hi.nat_embedding _ n).2\n  exact\n    hmn.ne\n      ((hi.nat_embedding _).injective <|\n        subtype.val_injective <| ha.eq (hi.nat_embedding _ m).2 (hi.nat_embedding _ n).2 h)\n#align is_antichain.finite_of_partially_well_ordered_on is_antichain.finite_of_partially_well_ordered_on\n\n",
 "exists_monotone_subseq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\ntheorem is_pwo.exists_monotone_subseq (h : s.is_pwo) (f : ℕ → α) (hf : ∀ n, f n ∈ s) :\n    ∃ g : «expr ↪o » ℕ ℕ, monotone (f ∘ g) :=\n  h.exists_monotone_subseq f hf\n#align is_pwo.exists_monotone_subseq is_pwo.exists_monotone_subseq\n\n",
 "exists_min_bad_of_exists_bad":
 "theorem exists_min_bad_of_exists_bad (r : α → α → Prop) (rk : α → ℕ) (s : set α) :\n    (∃ f, is_bad_seq r s f) → ∃ f, is_bad_seq r s f ∧ ∀ n, is_min_bad_seq r rk s n f :=\n  by\n  rintro ⟨f0, hf0 : is_bad_seq r s f0⟩\n  let fs : ∀ n : ℕ, { f : ℕ → α // is_bad_seq r s f ∧ is_min_bad_seq r rk s n f } :=\n    by\n    refine' nat.rec _ _\n    · exact ⟨(min_bad_seq_of_bad_seq r rk s 0 f0 hf0).1, (min_bad_seq_of_bad_seq r rk s 0 f0 hf0).2.2⟩\n    ·\n      exact fun n fn =>\n        ⟨(min_bad_seq_of_bad_seq r rk s (n + 1) fn.1 fn.2.1).1, (min_bad_seq_of_bad_seq r rk s (n + 1) fn.1 fn.2.1).2.2⟩\n  have h : ∀ m n, m ≤ n → (fs m).1 m = (fs n).1 m := by\n    intro m n mn\n    obtain ⟨k, rfl⟩ := exists_add_of_le mn\n    clear mn\n    induction' k with k ih\n    · rfl\n    rw [ih,\n      (min_bad_seq_of_bad_seq r rk s (m + k).succ (fs (m + k)).1 (fs (m + k)).2.1).2.1 m\n        (Nat.lt_succ_iff.2 (nat.add_le_add_left k.zero_le m))]\n    rfl\n  refine' ⟨fun n => (fs n).1 n, ⟨fun n => (fs n).2.1.1 n, fun m n mn => _⟩, fun n g hg1 hg2 => _⟩\n  · dsimp\n    rw [← subtype.val_eq_coe, h m n (le_of_lt mn)]\n    convert (fs n).2.1.2 m n mn\n  · convert (fs n).2.2 g (fun m mn => eq.trans _ (hg1 m mn)) (lt_of_lt_of_le hg2 le_rfl)\n    rw [← h m n (le_of_lt mn)]\n#align exists_min_bad_of_exists_bad exists_min_bad_of_exists_bad\n\n",
 "acc_iff_well_founded_on":
 "/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers\n      [(Command.docComment\n        \"/--\"\n        \"`a` is accessible under the relation `r` iff `r` is well-founded on the downward transitive\\n  closure of `a` under `r` (including `a` or not). -/\")]\n      []\n      []\n      []\n      []\n      [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `acc_iff_well_founded_on [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`α] [] \"}\")\n        (Term.implicitBinder \"{\" [`r] [\":\" (Term.arrow `α \"→\" (Term.arrow `α \"→\" (Term.prop \"Prop\")))] \"}\")\n        (Term.implicitBinder \"{\" [`a] [\":\" `α] \"}\")]\n       (Term.typeSpec\n        \":\"\n        (Term.proj\n         («term[_]»\n          \"[\"\n          [(Term.app `acc [`r `a])\n           \",\"\n           (Term.app\n            (Term.proj\n             (Set.«term{_|_}»\n              \"{\"\n              (Std.ExtendedBinder.extBinder (Lean.binderIdent `b) [])\n              \"|\"\n              (Term.app `refl_trans_gen [`r `b `a])\n              \"}\")\n             \".\"\n             `well_founded_on)\n            [`r])\n           \",\"\n           (Term.app\n            (Term.proj\n             (Set.«term{_|_}»\n              \"{\"\n              (Std.ExtendedBinder.extBinder (Lean.binderIdent `b) [])\n              \"|\"\n              (Term.app `trans_gen [`r `b `a])\n              \"}\")\n             \".\"\n             `well_founded_on)\n            [`r])]\n          \"]\")\n         \".\"\n         `tfae)))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.refine'\n              \"refine'\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`h]\n                []\n                \"=>\"\n                (Term.anonymousCtor \"⟨\" [(Term.fun \"fun\" (Term.basicFun [`b] [] \"=>\" (Term.hole \"_\")))] \"⟩\"))))\n             []\n             (Tactic.apply \"apply\" `InvImage.accessible)\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `acc_transGen_iff)] \"]\")\n              [(Tactic.location \"at\" (Tactic.locationHyp [`h] [(patternIgnore (token.«⊢» \"⊢\"))]))])\n             []\n             (Std.Tactic.obtain\n              \"obtain\"\n              [(Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.one `h') \"|\" (Std.Tactic.RCases.rcasesPat.one `h')])]\n              []\n              [\":=\"\n               [(Term.app\n                 (Term.proj `refl_trans_gen_iff_eq_or_trans_gen \".\" (fieldIdx \"1\"))\n                 [(Term.proj `b \".\" (fieldIdx \"2\"))])]])\n             []\n             (tactic__\n              (cdotTk (patternIgnore (token.«· » \"·\")))\n              [(Std.Tactic.tacticRwa__\n                \"rwa\"\n                (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `h')] \"]\")\n                [(Tactic.location \"at\" (Tactic.locationHyp [`h] []))])])\n             []\n             (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.exact \"exact\" (Term.app `h.inv [`h']))])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact\n              \"exact\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`h]\n                []\n                \"=>\"\n                (Term.app\n                 (Term.proj `h \".\" `subset)\n                 [(Term.fun \"fun\" (Term.basicFun [(Term.hole \"_\")] [] \"=>\" `trans_gen.to_refl))]))))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.refine'\n              \"refine'\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`h]\n                []\n                \"=>\"\n                (Term.app\n                 `acc.intro\n                 [(Term.hole \"_\")\n                  (Term.fun\n                   \"fun\"\n                   (Term.basicFun\n                    [`b `hb]\n                    []\n                    \"=>\"\n                    (Term.app\n                     (Term.proj\n                      (Term.app\n                       (Term.proj `h \".\" `apply)\n                       [(Term.anonymousCtor \"⟨\" [`b \",\" (Term.app `trans_gen.single [`hb])] \"⟩\")])\n                      \".\"\n                      `of_fibration)\n                     [`subtype.val (Term.hole \"_\")])))]))))\n             []\n             (Tactic.exact\n              \"exact\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [(Term.anonymousCtor \"⟨\" [`c \",\" `hc] \"⟩\") `d `h]\n                []\n                \"=>\"\n                (Term.anonymousCtor\n                 \"⟨\"\n                 [(Term.anonymousCtor \"⟨\" [`d \",\" (Term.app `trans_gen.head [`h `hc])] \"⟩\") \",\" `h \",\" `rfl]\n                 \"⟩\"))))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.refine'\n             \"refine'\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`h]\n               []\n               \"=>\"\n               (Term.anonymousCtor \"⟨\" [(Term.fun \"fun\" (Term.basicFun [`b] [] \"=>\" (Term.hole \"_\")))] \"⟩\"))))\n            []\n            (Tactic.apply \"apply\" `InvImage.accessible)\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `acc_transGen_iff)] \"]\")\n             [(Tactic.location \"at\" (Tactic.locationHyp [`h] [(patternIgnore (token.«⊢» \"⊢\"))]))])\n            []\n            (Std.Tactic.obtain\n             \"obtain\"\n             [(Std.Tactic.RCases.rcasesPatMed\n               [(Std.Tactic.RCases.rcasesPat.one `h') \"|\" (Std.Tactic.RCases.rcasesPat.one `h')])]\n             []\n             [\":=\"\n              [(Term.app\n                (Term.proj `refl_trans_gen_iff_eq_or_trans_gen \".\" (fieldIdx \"1\"))\n                [(Term.proj `b \".\" (fieldIdx \"2\"))])]])\n            []\n            (tactic__\n             (cdotTk (patternIgnore (token.«· » \"·\")))\n             [(Std.Tactic.tacticRwa__\n               \"rwa\"\n               (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `h')] \"]\")\n               [(Tactic.location \"at\" (Tactic.locationHyp [`h] []))])])\n            []\n            (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.exact \"exact\" (Term.app `h.inv [`h']))])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact\n             \"exact\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`h]\n               []\n               \"=>\"\n               (Term.app\n                (Term.proj `h \".\" `subset)\n                [(Term.fun \"fun\" (Term.basicFun [(Term.hole \"_\")] [] \"=>\" `trans_gen.to_refl))]))))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.refine'\n             \"refine'\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`h]\n               []\n               \"=>\"\n               (Term.app\n                `acc.intro\n                [(Term.hole \"_\")\n                 (Term.fun\n                  \"fun\"\n                  (Term.basicFun\n                   [`b `hb]\n                   []\n                   \"=>\"\n                   (Term.app\n                    (Term.proj\n                     (Term.app\n                      (Term.proj `h \".\" `apply)\n                      [(Term.anonymousCtor \"⟨\" [`b \",\" (Term.app `trans_gen.single [`hb])] \"⟩\")])\n                     \".\"\n                     `of_fibration)\n                    [`subtype.val (Term.hole \"_\")])))]))))\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [(Term.anonymousCtor \"⟨\" [`c \",\" `hc] \"⟩\") `d `h]\n               []\n               \"=>\"\n               (Term.anonymousCtor\n                \"⟨\"\n                [(Term.anonymousCtor \"⟨\" [`d \",\" (Term.app `trans_gen.head [`h `hc])] \"⟩\") \",\" `h \",\" `rfl]\n                \"⟩\"))))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.refine'\n         \"refine'\"\n         (Term.fun\n          \"fun\"\n          (Term.basicFun\n           [`h]\n           []\n           \"=>\"\n           (Term.app\n            `acc.intro\n            [(Term.hole \"_\")\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`b `hb]\n               []\n               \"=>\"\n               (Term.app\n                (Term.proj\n                 (Term.app\n                  (Term.proj `h \".\" `apply)\n                  [(Term.anonymousCtor \"⟨\" [`b \",\" (Term.app `trans_gen.single [`hb])] \"⟩\")])\n                 \".\"\n                 `of_fibration)\n                [`subtype.val (Term.hole \"_\")])))]))))\n        []\n        (Tactic.exact\n         \"exact\"\n         (Term.fun\n          \"fun\"\n          (Term.basicFun\n           [(Term.anonymousCtor \"⟨\" [`c \",\" `hc] \"⟩\") `d `h]\n           []\n           \"=>\"\n           (Term.anonymousCtor\n            \"⟨\"\n            [(Term.anonymousCtor \"⟨\" [`d \",\" (Term.app `trans_gen.head [`h `hc])] \"⟩\") \",\" `h \",\" `rfl]\n            \"⟩\"))))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact\n       \"exact\"\n       (Term.fun\n        \"fun\"\n        (Term.basicFun\n         [(Term.anonymousCtor \"⟨\" [`c \",\" `hc] \"⟩\") `d `h]\n         []\n         \"=>\"\n         (Term.anonymousCtor\n          \"⟨\"\n          [(Term.anonymousCtor \"⟨\" [`d \",\" (Term.app `trans_gen.head [`h `hc])] \"⟩\") \",\" `h \",\" `rfl]\n          \"⟩\"))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun\n       \"fun\"\n       (Term.basicFun\n        [(Term.anonymousCtor \"⟨\" [`c \",\" `hc] \"⟩\") `d `h]\n        []\n        \"=>\"\n        (Term.anonymousCtor\n         \"⟨\"\n         [(Term.anonymousCtor \"⟨\" [`d \",\" (Term.app `trans_gen.head [`h `hc])] \"⟩\") \",\" `h \",\" `rfl]\n         \"⟩\")))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor\n       \"⟨\"\n       [(Term.anonymousCtor \"⟨\" [`d \",\" (Term.app `trans_gen.head [`h `hc])] \"⟩\") \",\" `h \",\" `rfl]\n       \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `rfl\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor \"⟨\" [`d \",\" (Term.app `trans_gen.head [`h `hc])] \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `trans_gen.head [`h `hc])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hc\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `trans_gen.head\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `d\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `d\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.anonymousCtor \"⟨\" [`c \",\" `hc] \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hc\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `c\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.refine'\n       \"refine'\"\n       (Term.fun\n        \"fun\"\n        (Term.basicFun\n         [`h]\n         []\n         \"=>\"\n         (Term.app\n          `acc.intro\n          [(Term.hole \"_\")\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [`b `hb]\n             []\n             \"=>\"\n             (Term.app\n              (Term.proj\n               (Term.app\n                (Term.proj `h \".\" `apply)\n                [(Term.anonymousCtor \"⟨\" [`b \",\" (Term.app `trans_gen.single [`hb])] \"⟩\")])\n               \".\"\n               `of_fibration)\n              [`subtype.val (Term.hole \"_\")])))]))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun\n       \"fun\"\n       (Term.basicFun\n        [`h]\n        []\n        \"=>\"\n        (Term.app\n         `acc.intro\n         [(Term.hole \"_\")\n          (Term.fun\n           \"fun\"\n           (Term.basicFun\n            [`b `hb]\n            []\n            \"=>\"\n            (Term.app\n             (Term.proj\n              (Term.app\n               (Term.proj `h \".\" `apply)\n               [(Term.anonymousCtor \"⟨\" [`b \",\" (Term.app `trans_gen.single [`hb])] \"⟩\")])\n              \".\"\n              `of_fibration)\n             [`subtype.val (Term.hole \"_\")])))])))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       `acc.intro\n       [(Term.hole \"_\")\n        (Term.fun\n         \"fun\"\n         (Term.basicFun\n          [`b `hb]\n          []\n          \"=>\"\n          (Term.app\n           (Term.proj\n            (Term.app\n             (Term.proj `h \".\" `apply)\n             [(Term.anonymousCtor \"⟨\" [`b \",\" (Term.app `trans_gen.single [`hb])] \"⟩\")])\n            \".\"\n            `of_fibration)\n           [`subtype.val (Term.hole \"_\")])))])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun\n       \"fun\"\n       (Term.basicFun\n        [`b `hb]\n        []\n        \"=>\"\n        (Term.app\n         (Term.proj\n          (Term.app\n           (Term.proj `h \".\" `apply)\n           [(Term.anonymousCtor \"⟨\" [`b \",\" (Term.app `trans_gen.single [`hb])] \"⟩\")])\n          \".\"\n          `of_fibration)\n         [`subtype.val (Term.hole \"_\")])))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       (Term.proj\n        (Term.app (Term.proj `h \".\" `apply) [(Term.anonymousCtor \"⟨\" [`b \",\" (Term.app `trans_gen.single [`hb])] \"⟩\")])\n        \".\"\n        `of_fibration)\n       [`subtype.val (Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))\n      `subtype.val\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      (Term.proj\n       (Term.app (Term.proj `h \".\" `apply) [(Term.anonymousCtor \"⟨\" [`b \",\" (Term.app `trans_gen.single [`hb])] \"⟩\")])\n       \".\"\n       `of_fibration)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app (Term.proj `h \".\" `apply) [(Term.anonymousCtor \"⟨\" [`b \",\" (Term.app `trans_gen.single [`hb])] \"⟩\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor \"⟨\" [`b \",\" (Term.app `trans_gen.single [`hb])] \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `trans_gen.single [`hb])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hb\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `trans_gen.single\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `b\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      (Term.proj `h \".\" `apply)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren\n     \"(\"\n     (Term.app (Term.proj `h \".\" `apply) [(Term.anonymousCtor \"⟨\" [`b \",\" (Term.app `trans_gen.single [`hb])] \"⟩\")])\n     \")\")\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hb\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `b\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `acc.intro\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\n/--\n    `a` is accessible under the relation `r` iff `r` is well-founded on the downward transitive\n      closure of `a` under `r` (including `a` or not). -/\n  theorem\n    acc_iff_well_founded_on\n    { α } { r : α → α → Prop } { a : α }\n      :\n        [ acc r a , { b | refl_trans_gen r b a } . well_founded_on r , { b | trans_gen r b a } . well_founded_on r ]\n          .\n          tfae\n    :=\n      by\n        tfae_have 1 → 2\n          ·\n            refine' fun h => ⟨ fun b => _ ⟩\n              apply InvImage.accessible\n              rw [ ← acc_transGen_iff ] at h ⊢\n              obtain h' | h' := refl_trans_gen_iff_eq_or_trans_gen . 1 b . 2\n              · rwa [ h' ] at h\n              · exact h.inv h'\n          tfae_have 2 → 3\n          · exact fun h => h . subset fun _ => trans_gen.to_refl\n          tfae_have 3 → 1\n          ·\n            refine' fun h => acc.intro _ fun b hb => h . apply ⟨ b , trans_gen.single hb ⟩ . of_fibration subtype.val _\n              exact fun ⟨ c , hc ⟩ d h => ⟨ ⟨ d , trans_gen.head h hc ⟩ , h , rfl ⟩\n          tfae_finish\n#align acc_iff_well_founded_on acc_iff_well_founded_on\n\n"}