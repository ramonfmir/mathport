{"tendsto_prod_self_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem tendsto_prod_self_iff {f : α × α → β} {x : filter α} {y : filter β} :\n    filter.tendsto f (filter.prod x x) y ↔ ∀ W ∈ y, ∃ U ∈ x, ∀ x x' : α, x ∈ U → x' ∈ U → f (x, x') ∈ W := by\n  simp only [tendsto_def, mem_prod_same_iff, prod_sub_preimage_iff, exists_prop, iff_self_iff]\n#align tendsto_prod_self_iff tendsto_prod_self_iff\n\n",
 "tendsto_lift'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_lift' {m : γ → β} {l : filter γ} :\n    tendsto m l (f.lift' h) ↔\n      ∀ s ∈ f,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n          (m a ∈ h s) :=\n  by simp only [filter.lift', tendsto_lift, tendsto_principal]\n#align tendsto_lift' tendsto_lift'\n\n",
 "tendsto_lift":
 "theorem tendsto_lift {m : γ → β} {l : filter γ} : tendsto m l (f.lift g) ↔ ∀ s ∈ f, tendsto m l (g s) := by\n  simp only [filter.lift, tendsto_infi]\n#align tendsto_lift tendsto_lift\n\n",
 "sInter_lift_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\ntheorem sInter_lift_sets (hg : monotone g) :\n    «expr⋂₀ » { s | s ∈ f.lift g } =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        («expr⋂₀ » { t | t ∈ g s }) :=\n  by simp only [sInter_eq_bInter, mem_set_of_eq, filter.mem_sets, mem_lift_sets hg, Inter_exists, @Inter_comm _ (set β)]\n#align sInter_lift_sets sInter_lift_sets\n\n",
 "sInter_lift'_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem sInter_lift'_sets (hh : monotone h) :\n    «expr⋂₀ » { s | s ∈ f.lift' h } =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (h s) :=\n  (sInter_lift_sets (monotone_principal.comp hh)).trans <| Inter₂_congr fun s hs => cinfₛ_Ici\n#align sInter_lift'_sets sInter_lift'_sets\n\n",
 "prod_same_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem prod_same_eq : filter.prod f f = f.lift' fun t : set α => finset.product t t :=\n  prod_def.trans <|\n    lift_lift'_same_eq_lift' (fun s => monotone_const.set_prod monotone_id) fun t => monotone_id.set_prod monotone_const\n#align prod_same_eq prod_same_eq\n\n",
 "prod_lift_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_lift_lift {f₁ : filter α₁} {f₂ : filter α₂} {g₁ : set α₁ → filter β₁} {g₂ : set α₂ → filter β₂}\n    (hg₁ : monotone g₁) (hg₂ : monotone g₂) :\n    filter.prod (f₁.lift g₁) (f₂.lift g₂) = f₁.lift fun s => f₂.lift fun t => filter.prod (g₁ s) (g₂ t) :=\n  by\n  simp only [prod_def, lift_assoc hg₁]\n  apply congr_arg; funext x\n  rw [lift_comm]\n  apply congr_arg; funext y\n  apply lift'_lift_assoc hg₂\n#align prod_lift_lift prod_lift_lift\n\n",
 "prod_lift'_lift'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem prod_lift'_lift' {f₁ : filter α₁} {f₂ : filter α₂} {g₁ : set α₁ → set β₁} {g₂ : set α₂ → set β₂}\n    (hg₁ : monotone g₁) (hg₂ : monotone g₂) :\n    filter.prod (f₁.lift' g₁) (f₂.lift' g₂) = f₁.lift fun s => f₂.lift' fun t => finset.product (g₁ s) (g₂ t) :=\n  calc\n    filter.prod (f₁.lift' g₁) (f₂.lift' g₂) =\n        f₁.lift fun s => f₂.lift fun t => filter.prod ((filter.principal) (g₁ s)) ((filter.principal) (g₂ t)) :=\n      prod_lift_lift (monotone_principal.comp hg₁) (monotone_principal.comp hg₂)\n    _ = f₁.lift fun s => f₂.lift fun t => (filter.principal) (finset.product (g₁ s) (g₂ t)) := by\n      simp only [prod_principal_principal]\n    \n#align prod_lift'_lift' prod_lift'_lift'\n\n",
 "prod_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem prod_def {f : filter α} {g : filter β} :\n    filter.prod f g = f.lift fun s => g.lift' fun t => finset.product s t :=\n  by\n  have :\n    ∀ (s : set α) (t : set β),\n      (filter.principal) (finset.product s t) =\n        «expr ⊓ » (((filter.principal) s).comap prod.fst) (((filter.principal) t).comap prod.snd) :=\n    by simp only [principal_eq_iff_eq, comap_principal, inf_principal] <;> intros <;> rfl\n  simp only [filter.lift', function.comp, this, lift_inf, lift_const, lift_inf]\n  rw [← comap_lift_eq, ← comap_lift_eq]\n  simp only [filter.prod, lift_principal2]\n#align prod_def prod_def\n\n",
 "principal_le_lift'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem principal_le_lift' {t : set β} : (filter.principal) t ≤ f.lift' h ↔ ∀ s ∈ f, t ⊆ h s :=\n  le_lift'\n#align principal_le_lift' principal_le_lift'\n\n",
 "monotone_lift'":
 "theorem monotone_lift' [preorder γ] {f : γ → filter α} {g : γ → set α → set β} (hf : monotone f) (hg : monotone g) :\n    monotone fun c => (f c).lift' (g c) := fun a b h => lift'_mono (hf h) (hg h)\n#align monotone_lift' monotone_lift'\n\n",
 "monotone_lift":
 "theorem monotone_lift [preorder γ] {f : γ → filter α} {g : γ → set α → filter β} (hf : monotone f) (hg : monotone g) :\n    monotone fun c => (f c).lift (g c) := fun a b h => lift_mono (hf h) (hg h)\n#align monotone_lift monotone_lift\n\n",
 "mem_prod_same_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem mem_prod_same_iff {s : set (α × α)} : s ∈ filter.prod f f ↔ ∃ t ∈ f, finset.product t t ⊆ s :=\n  by\n  rw [prod_same_eq, mem_lift'_sets]\n  exact monotone_id.set_prod monotone_id\n#align mem_prod_same_iff mem_prod_same_iff\n\n",
 "mem_lift_sets":
 "theorem mem_lift_sets (hg : monotone g) {s : set β} : s ∈ f.lift g ↔ ∃ t ∈ f, s ∈ g t :=\n  (f.basis_sets.mem_lift_iff (fun s => (g s).basis_sets) hg).trans <| by simp only [id, exists_mem_subset_iff]\n#align mem_lift_sets mem_lift_sets\n\n",
 "mem_lift_iff":
 "/-- If `(p : ι → Prop, s : ι → set α)` is a basis of a filter `f`, `g` is a monotone function\n`set α → filter γ`, and for each `i`, `(pg : β i → Prop, sg : β i → set α)` is a basis\nof the filter `g (s i)`, then `(λ (i : ι) (x : β i), p i ∧ pg i x, λ (i : ι) (x : β i), sg i x)`\nis a basis of the filter `f.lift g`.\n\nThis basis is parametrized by `i : ι` and `x : β i`, so in order to formulate this fact using\n`has_basis` one has to use `Σ i, β i` as the index type, see `filter.has_basis.lift`.\nThis lemma states the corresponding `mem_iff` statement without using a sigma type. -/\ntheorem has_basis.mem_lift_iff {ι} {p : ι → Prop} {s : ι → set α} {f : filter α} (hf : f.has_basis p s) {β : ι → Type _}\n    {pg : ∀ i, β i → Prop} {sg : ∀ i, β i → set γ} {g : set α → filter γ} (hg : ∀ i, (g <| s i).has_basis (pg i) (sg i))\n    (gm : monotone g) {s : set γ} : s ∈ f.lift g ↔ ∃ (i : ι)(hi : p i)(x : β i)(hx : pg i x), sg i x ⊆ s :=\n  by\n  refine' (mem_binfi_of_directed _ ⟨univ, univ_sets _⟩).trans _\n  · intro t₁ ht₁ t₂ ht₂\n    exact ⟨t₁ ∩ t₂, inter_mem ht₁ ht₂, gm <| inter_subset_left _ _, gm <| inter_subset_right _ _⟩\n  · simp only [← (hg _).mem_iff]\n    exact hf.exists_iff fun t₁ t₂ ht H => gm ht H\n#align has_basis.mem_lift_iff has_basis.mem_lift_iff\n\n",
 "mem_lift'_sets":
 "theorem mem_lift'_sets (hh : monotone h) {s : set β} : s ∈ f.lift' h ↔ ∃ t ∈ f, h t ⊆ s :=\n  mem_lift_sets <| monotone_principal.comp hh\n#align mem_lift'_sets mem_lift'_sets\n\n",
 "mem_lift'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem mem_lift' {t : set α} (ht : t ∈ f) : h t ∈ f.lift' h :=\n  le_principal_iff.mp <| show f.lift' h ≤ (filter.principal) (h t) from infᵢ_le_of_le t <| infᵢ_le_of_le ht <| le_rfl\n#align mem_lift' mem_lift'\n\n",
 "mem_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem mem_lift {s : set β} {t : set α} (ht : t ∈ f) (hs : s ∈ g t) : s ∈ f.lift g :=\n  le_principal_iff.mp <|\n    show f.lift g ≤ (filter.principal) s from infᵢ_le_of_le t <| infᵢ_le_of_le ht <| le_principal_iff.mpr hs\n#align mem_lift mem_lift\n\n",
 "map_lift_eq2":
 "theorem map_lift_eq2 {g : set β → filter γ} {m : α → β} (hg : monotone g) : (map m f).lift g = f.lift (g ∘ image m) :=\n  lift_map_le.antisymm <| le_lift.2 fun s hs => lift_le hs <| hg <| image_preimage_subset _ _\n#align map_lift_eq2 map_lift_eq2\n\n",
 "map_lift_eq":
 "theorem map_lift_eq {m : β → γ} (hg : monotone g) : map m (f.lift g) = f.lift (map m ∘ g) :=\n  have : monotone (map m ∘ g) := map_mono.comp hg\n  filter.ext fun s => by simp only [mem_lift_sets hg, mem_lift_sets this, exists_prop, mem_map, Function.comp_apply]\n#align map_lift_eq map_lift_eq\n\n",
 "map_lift'_eq2":
 "theorem map_lift'_eq2 {g : set β → set γ} {m : α → β} (hg : monotone g) : (map m f).lift' g = f.lift' (g ∘ image m) :=\n  map_lift_eq2 <| monotone_principal.comp hg\n#align map_lift'_eq2 map_lift'_eq2\n\n",
 "map_lift'_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem map_lift'_eq {m : β → γ} (hh : monotone h) : map m (f.lift' h) = f.lift' (image m ∘ h) :=\n  calc\n    map m (f.lift' h) = f.lift (map m ∘ filter.principal ∘ h) := map_lift_eq <| monotone_principal.comp hh\n    _ = f.lift' (image m ∘ h) := by simp only [(· ∘ ·), filter.lift', map_principal, eq_self_iff_true]\n    \n#align map_lift'_eq map_lift'_eq\n\n",
 "lift_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl\n-/\n@[simp]\ntheorem lift_top (g : set α → filter β) : («expr⊤» : filter α).lift g = g univ := by simp [filter.lift]\n#align lift_top lift_top\n\n",
 "lift_principal2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem lift_principal2 {f : filter α} : f.lift (filter.principal) = f :=\n  le_antisymm (fun s hs => mem_lift hs (mem_principal_self s))\n    (le_infᵢ fun s => le_infᵢ fun hs => by simp only [hs, le_principal_iff])\n#align lift_principal2 lift_principal2\n\n",
 "lift_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem lift_principal {s : set α} (hg : monotone g) : ((filter.principal) s).lift g = g s :=\n  (lift_le (mem_principal_self _) le_rfl).antisymm (le_lift.2 fun t ht => hg ht)\n#align lift_principal lift_principal\n\n",
 "lift_ne_bot_iff":
 "theorem lift_ne_bot_iff (hm : monotone g) : (ne_bot <| f.lift g) ↔ ∀ s ∈ f, ne_bot (g s) := by\n  simp only [ne_bot_iff, ne.def, ← empty_mem_iff_bot, mem_lift_sets hm, not_exists]\n#align lift_ne_bot_iff lift_ne_bot_iff\n\n",
 "lift_mono'":
 "theorem lift_mono' (hg : ∀ s ∈ f, g₁ s ≤ g₂ s) : f.lift g₁ ≤ f.lift g₂ :=\n  infᵢ₂_mono hg\n#align lift_mono' lift_mono'\n\n",
 "lift_mono":
 "theorem lift_mono (hf : f₁ ≤ f₂) (hg : g₁ ≤ g₂) : f₁.lift g₁ ≤ f₂.lift g₂ :=\n  infᵢ_mono fun s => infᵢ_mono' fun hs => ⟨hf hs, hg s⟩\n#align lift_mono lift_mono\n\n",
 "lift_map_le":
 "theorem lift_map_le {g : set β → filter γ} {m : α → β} : (map m f).lift g ≤ f.lift (g ∘ image m) :=\n  le_lift.2 fun s hs => lift_le (image_mem_map hs) le_rfl\n#align lift_map_le lift_map_le\n\n",
 "lift_lift_same_le_lift":
 "theorem lift_lift_same_le_lift {g : set α → set α → filter β} :\n    (f.lift fun s => f.lift (g s)) ≤ f.lift fun s => g s s :=\n  le_lift.2 fun s hs => lift_le hs <| lift_le hs le_rfl\n#align lift_lift_same_le_lift lift_lift_same_le_lift\n\n",
 "lift_lift_same_eq_lift":
 "theorem lift_lift_same_eq_lift {g : set α → set α → filter β} (hg₁ : ∀ s, monotone fun t => g s t)\n    (hg₂ : ∀ t, monotone fun s => g s t) : (f.lift fun s => f.lift (g s)) = f.lift fun s => g s s :=\n  lift_lift_same_le_lift.antisymm <|\n    le_lift.2 fun s hs =>\n      le_lift.2 fun t ht =>\n        lift_le (inter_mem hs ht) <|\n          calc\n            g (s ∩ t) (s ∩ t) ≤ g s (s ∩ t) := hg₂ (s ∩ t) (inter_subset_left _ _)\n            _ ≤ g s t := hg₁ s (inter_subset_right _ _)\n            \n#align lift_lift_same_eq_lift lift_lift_same_eq_lift\n\n",
 "lift_lift'_same_le_lift'":
 "theorem lift_lift'_same_le_lift' {g : set α → set α → set β} :\n    (f.lift fun s => f.lift' (g s)) ≤ f.lift' fun s => g s s :=\n  lift_lift_same_le_lift\n#align lift_lift'_same_le_lift' lift_lift'_same_le_lift'\n\n",
 "lift_lift'_same_eq_lift'":
 "theorem lift_lift'_same_eq_lift' {g : set α → set α → set β} (hg₁ : ∀ s, monotone fun t => g s t)\n    (hg₂ : ∀ t, monotone fun s => g s t) : (f.lift fun s => f.lift' (g s)) = f.lift' fun s => g s s :=\n  lift_lift_same_eq_lift (fun s => monotone_principal.comp (hg₁ s)) fun t => monotone_principal.comp (hg₂ t)\n#align lift_lift'_same_eq_lift' lift_lift'_same_eq_lift'\n\n",
 "lift_lift'_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem lift_lift'_assoc {g : set α → set β} {h : set β → filter γ} (hg : monotone g) (hh : monotone h) :\n    (f.lift' g).lift h = f.lift fun s => h (g s) :=\n  calc\n    (f.lift' g).lift h = f.lift fun s => ((filter.principal) (g s)).lift h := lift_assoc (monotone_principal.comp hg)\n    _ = f.lift fun s => h (g s) := by simp only [lift_principal, hh, eq_self_iff_true]\n    \n#align lift_lift'_assoc lift_lift'_assoc\n\n",
 "lift_le":
 "theorem lift_le {f : filter α} {g : set α → filter β} {h : filter β} {s : set α} (hs : s ∈ f) (hg : g s ≤ h) :\n    f.lift g ≤ h :=\n  infᵢ₂_le_of_le s hs hg\n#align lift_le lift_le\n\n",
 "lift_infi_of_map_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem lift_infi_of_map_univ {f : ι → filter α} {g : set α → filter β} (hg : ∀ s t, g (s ∩ t) = «expr ⊓ » (g s) (g t))\n    (hg' : g univ = «expr⊤») :\n    (infᵢ f).lift g =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((f i).lift g) :=\n  by\n  cases isEmpty_or_nonempty ι\n  · simp [infᵢ_of_empty, hg']\n  · exact lift_infi hg\n#align lift_infi_of_map_univ lift_infi_of_map_univ\n\n",
 "lift_infi_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem lift_infi_of_directed [nonempty ι] {f : ι → filter α} {g : set α → filter β} (hf : Directed (· ≥ ·) f)\n    (hg : monotone g) :\n    (infᵢ f).lift g =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((f i).lift g) :=\n  lift_infi_le.antisymm fun s =>\n    by\n    simp only [mem_lift_sets hg, exists_imp, mem_infi_of_directed hf]\n    exact fun t i ht hs => mem_infi_of_mem i <| mem_lift ht hs\n#align lift_infi_of_directed lift_infi_of_directed\n\n",
 "lift_infi_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem lift_infi_le {f : ι → filter α} {g : set α → filter β} :\n    (infᵢ f).lift g ≤\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((f i).lift g) :=\n  le_infᵢ fun i => lift_mono (infᵢ_le _ _) le_rfl\n#align lift_infi_le lift_infi_le\n\n",
 "lift_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem lift_infi [nonempty ι] {f : ι → filter α} {g : set α → filter β}\n    (hg : ∀ s t, g (s ∩ t) = «expr ⊓ » (g s) (g t)) :\n    (infᵢ f).lift g =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((f i).lift g) :=\n  by\n  refine' lift_infi_le.antisymm fun s => _\n  have H :\n    ∀ t ∈ infᵢ f,\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((f i).lift g) ≤\n        g t :=\n    by\n    intro t ht\n    refine' infi_sets_induct ht _ fun i s t hs ht => _\n    · inhabit ι\n      exact infᵢ₂_le_of_le default univ (infᵢ_le _ univ_mem)\n    · rw [hg]\n      exact le_inf (infᵢ₂_le_of_le i s <| infᵢ_le _ hs) ht\n  simp only [mem_lift_sets (Monotone.of_map_inf hg), exists_imp]\n  exact fun t ht hs => H t ht hs\n#align lift_infi lift_infi\n\n",
 "lift_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem lift_inf {f : filter α} {g h : set α → filter β} :\n    (f.lift fun x => «expr ⊓ » (g x) (h x)) = «expr ⊓ » (f.lift g) (f.lift h) := by simp only [filter.lift, infᵢ_inf_eq]\n#align lift_inf lift_inf\n\n",
 "lift_const":
 "@[simp]\ntheorem lift_const {f : filter α} {g : filter β} : (f.lift fun x => g) = g :=\n  infᵢ_subtype'.trans infᵢ_const\n#align lift_const lift_const\n\n",
 "lift_comm":
 "theorem lift_comm {g : filter β} {h : set α → set β → filter γ} :\n    (f.lift fun s => g.lift (h s)) = g.lift fun t => f.lift fun s => h s t :=\n  le_antisymm\n    (le_infᵢ fun i =>\n      le_infᵢ fun hi =>\n        le_infᵢ fun j => le_infᵢ fun hj => infᵢ_le_of_le j <| infᵢ_le_of_le hj <| infᵢ_le_of_le i <| infᵢ_le _ hi)\n    (le_infᵢ fun i =>\n      le_infᵢ fun hi =>\n        le_infᵢ fun j => le_infᵢ fun hj => infᵢ_le_of_le j <| infᵢ_le_of_le hj <| infᵢ_le_of_le i <| infᵢ_le _ hi)\n#align lift_comm lift_comm\n\n",
 "lift_assoc":
 "theorem lift_assoc {h : set β → filter γ} (hg : monotone g) : (f.lift g).lift h = f.lift fun s => (g s).lift h :=\n  le_antisymm\n    (le_infᵢ fun s =>\n      le_infᵢ fun hs =>\n        le_infᵢ fun t => le_infᵢ fun ht => infᵢ_le_of_le t <| infᵢ_le _ <| (mem_lift_sets hg).mpr ⟨_, hs, ht⟩)\n    (le_infᵢ fun t =>\n      le_infᵢ fun ht =>\n        let ⟨s, hs, h'⟩ := (mem_lift_sets hg).mp ht\n        infᵢ_le_of_le s <| infᵢ_le_of_le hs <| infᵢ_le_of_le t <| infᵢ_le _ h')\n#align lift_assoc lift_assoc\n\n",
 "lift'_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem lift'_top (h : set α → set β) : («expr⊤» : filter α).lift' h = (filter.principal) (h univ) :=\n  lift_top _\n#align lift'_top lift'_top\n\n",
 "lift'_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem lift'_pure {a : α} (hh : monotone h) : (pure a : filter α).lift' h = (filter.principal) (h {a}) := by\n  rw [← principal_singleton, lift'_principal hh]\n#align lift'_pure lift'_pure\n\n",
 "lift'_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem lift'_principal {s : set α} (hh : monotone h) : ((filter.principal) s).lift' h = (filter.principal) (h s) :=\n  lift_principal <| monotone_principal.comp hh\n#align lift'_principal lift'_principal\n\n",
 "lift'_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem lift'_ne_bot_iff (hh : monotone h) : ne_bot (f.lift' h) ↔ ∀ s ∈ f, (h s).nonempty :=\n  calc\n    ne_bot (f.lift' h) ↔ ∀ s ∈ f, ne_bot ((filter.principal) (h s)) := lift_ne_bot_iff (monotone_principal.comp hh)\n    _ ↔ ∀ s ∈ f, (h s).nonempty := by simp only [principal_ne_bot_iff]\n    \n#align lift'_ne_bot_iff lift'_ne_bot_iff\n\n",
 "lift'_mono'":
 "theorem lift'_mono' (hh : ∀ s ∈ f, h₁ s ⊆ h₂ s) : f.lift' h₁ ≤ f.lift' h₂ :=\n  infᵢ₂_mono fun s hs => principal_mono.mpr <| hh s hs\n#align lift'_mono' lift'_mono'\n\n",
 "lift'_mono":
 "theorem lift'_mono (hf : f₁ ≤ f₂) (hh : h₁ ≤ h₂) : f₁.lift' h₁ ≤ f₂.lift' h₂ :=\n  lift_mono hf fun s => principal_mono.mpr <| hh s\n#align lift'_mono lift'_mono\n\n",
 "lift'_map_le":
 "theorem lift'_map_le {g : set β → set γ} {m : α → β} : (map m f).lift' g ≤ f.lift' (g ∘ image m) :=\n  lift_map_le\n#align lift'_map_le lift'_map_le\n\n",
 "lift'_lift_assoc":
 "theorem lift'_lift_assoc {g : set α → filter β} {h : set β → set γ} (hg : monotone g) :\n    (f.lift g).lift' h = f.lift fun s => (g s).lift' h :=\n  lift_assoc hg\n#align lift'_lift_assoc lift'_lift_assoc\n\n",
 "lift'_lift'_assoc":
 "theorem lift'_lift'_assoc {g : set α → set β} {h : set β → set γ} (hg : monotone g) (hh : monotone h) :\n    (f.lift' g).lift' h = f.lift' fun s => h (g s) :=\n  lift_lift'_assoc hg (monotone_principal.comp hh)\n#align lift'_lift'_assoc lift'_lift'_assoc\n\n",
 "lift'_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem lift'_le {f : filter α} {g : set α → set β} {h : filter β} {s : set α} (hs : s ∈ f)\n    (hg : (filter.principal) (g s) ≤ h) : f.lift' g ≤ h :=\n  lift_le hs hg\n#align lift'_le lift'_le\n\n",
 "lift'_infi_of_map_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem lift'_infi_of_map_univ {f : ι → filter α} {g : set α → set β} (hg : ∀ {s t}, g (s ∩ t) = g s ∩ g t)\n    (hg' : g univ = univ) :\n    (infᵢ f).lift' g =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((f i).lift' g) :=\n  lift_infi_of_map_univ (fun s t => by rw [inf_principal, (· ∘ ·), ← hg])\n    (by rw [Function.comp_apply, hg', principal_univ])\n#align lift'_infi_of_map_univ lift'_infi_of_map_univ\n\n",
 "lift'_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem lift'_infi [nonempty ι] {f : ι → filter α} {g : set α → set β} (hg : ∀ s t, g (s ∩ t) = g s ∩ g t) :\n    (infᵢ f).lift' g =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((f i).lift' g) :=\n  lift_infi fun s t => by rw [inf_principal, (· ∘ ·), ← hg]\n#align lift'_infi lift'_infi\n\n",
 "lift'_inf_principal_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem lift'_inf_principal_eq {h : set α → set β} {s : set β} :\n    «expr ⊓ » (f.lift' h) ((filter.principal) s) = f.lift' fun t => h t ∩ s := by\n  simp only [filter.lift', filter.lift, (· ∘ ·), ← inf_principal, infᵢ_subtype', ← infᵢ_inf]\n#align lift'_inf_principal_eq lift'_inf_principal_eq\n\n",
 "lift'_inf_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem lift'_inf_le (f g : filter α) (s : set α → set β) :\n    («expr ⊓ » f g).lift' s ≤ «expr ⊓ » (f.lift' s) (g.lift' s) :=\n  le_inf (lift'_mono inf_le_left le_rfl) (lift'_mono inf_le_right le_rfl)\n#align lift'_inf_le lift'_inf_le\n\n",
 "lift'_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem lift'_inf (f g : filter α) {s : set α → set β} (hs : ∀ t₁ t₂, s (t₁ ∩ t₂) = s t₁ ∩ s t₂) :\n    («expr ⊓ » f g).lift' s = «expr ⊓ » (f.lift' s) (g.lift' s) :=\n  by\n  have :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (cond b f g)).lift'\n        s =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((cond b f g).lift' s) :=\n    lift'_infi @hs\n  simpa only [infᵢ_bool_eq]\n#align lift'_inf lift'_inf\n\n",
 "lift'_id":
 "@[simp]\ntheorem lift'_id {f : filter α} : f.lift' id = f :=\n  lift_principal2\n#align lift'_id lift'_id\n\n",
 "lift'_cong":
 "theorem lift'_cong (hh : ∀ s ∈ f, h₁ s = h₂ s) : f.lift' h₁ = f.lift' h₂ :=\n  le_antisymm (lift'_mono' fun s hs => le_of_eq <| hh s hs) (lift'_mono' fun s hs => le_of_eq <| (hh s hs).symm)\n#align lift'_cong lift'_cong\n\n",
 "lift'_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem lift'_bot (hh : monotone h) : («expr⊥» : filter α).lift' h = (filter.principal) (h ∅) := by\n  rw [← principal_empty, lift'_principal hh]\n#align lift'_bot lift'_bot\n\n",
 "lift'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis.lift' {ι} {p : ι → Prop} {s} (hf : f.has_basis p s) (hh : monotone h) :\n    (f.lift' h).has_basis p (h ∘ s) :=\n  by\n  refine' ⟨fun t => (hf.mem_lift_iff _ (monotone_principal.comp hh)).trans _⟩\n  show ∀ i, ((filter.principal) (h (s i))).has_basis (fun j : unit => true) fun j : unit => h (s i)\n  exact fun i => has_basis_principal _\n  simp only [exists_const]\n#align has_basis.lift' has_basis.lift'\n\n",
 "lift":
 "/-- If `(p : ι → Prop, s : ι → set α)` is a basis of a filter `f`, `g` is a monotone function\n`set α → filter γ`, and for each `i`, `(pg : β i → Prop, sg : β i → set α)` is a basis\nof the filter `g (s i)`, then `(λ (i : ι) (x : β i), p i ∧ pg i x, λ (i : ι) (x : β i), sg i x)`\nis a basis of the filter `f.lift g`.\n\nThis basis is parametrized by `i : ι` and `x : β i`, so in order to formulate this fact using\n`has_basis` one has to use `Σ i, β i` as the index type. See also `filter.has_basis.mem_lift_iff`\nfor the corresponding `mem_iff` statement formulated without using a sigma type. -/\ntheorem has_basis.lift {ι} {p : ι → Prop} {s : ι → set α} {f : filter α} (hf : f.has_basis p s) {β : ι → Type _}\n    {pg : ∀ i, β i → Prop} {sg : ∀ i, β i → set γ} {g : set α → filter γ} (hg : ∀ i, (g <| s i).has_basis (pg i) (sg i))\n    (gm : monotone g) : (f.lift g).has_basis (fun i : Σi, β i => p i.1 ∧ pg i.1 i.2) fun i : Σi, β i => sg i.1 i.2 :=\n  by\n  refine' ⟨fun t => (hf.mem_lift_iff hg gm).trans _⟩\n  simp [sigma.exists, and_assoc', exists_and_left]\n#align has_basis.lift has_basis.lift\n\n",
 "le_lift'":
 "theorem le_lift' {f : filter α} {h : set α → set β} {g : filter β} : g ≤ f.lift' h ↔ ∀ s ∈ f, h s ∈ g :=\n  le_lift.trans <| forall₂_congr fun s hs => le_principal_iff\n#align le_lift' le_lift'\n\n",
 "le_lift":
 "theorem le_lift {f : filter α} {g : set α → filter β} {h : filter β} : h ≤ f.lift g ↔ ∀ s ∈ f, h ≤ g s :=\n  le_infᵢ₂_iff\n#align le_lift le_lift\n\n",
 "eventually_lift'_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_lift'_iff (hh : monotone h) {p : β → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" (f.lift' h)\n        (p y) ↔\n      ∃ t ∈ f, ∀ y ∈ h t, p y :=\n  mem_lift'_sets hh\n#align eventually_lift'_iff eventually_lift'_iff\n\n",
 "comap_lift_eq2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem comap_lift_eq2 {m : β → α} {g : set β → filter γ} (hg : monotone g) :\n    (comap m f).lift g = f.lift (g ∘ preimage m) :=\n  le_antisymm (le_infᵢ₂ fun s hs => infᵢ₂_le («expr ⁻¹' » m s) ⟨s, hs, Subset.rfl⟩)\n    (le_infᵢ₂ fun s ⟨s', hs', (h_sub : «expr ⁻¹' » m s' ⊆ s)⟩ => infᵢ₂_le_of_le s' hs' <| hg h_sub)\n#align comap_lift_eq2 comap_lift_eq2\n\n",
 "comap_lift_eq":
 "theorem comap_lift_eq {m : γ → β} : comap m (f.lift g) = f.lift (comap m ∘ g) := by simp only [filter.lift, comap_infi]\n#align comap_lift_eq comap_lift_eq\n\n",
 "comap_lift'_eq2":
 "theorem comap_lift'_eq2 {m : β → α} {g : set β → set γ} (hg : monotone g) :\n    (comap m f).lift' g = f.lift' (g ∘ preimage m) :=\n  comap_lift_eq2 <| monotone_principal.comp hg\n#align comap_lift'_eq2 comap_lift'_eq2\n\n",
 "comap_lift'_eq":
 "theorem comap_lift'_eq {m : γ → β} : comap m (f.lift' h) = f.lift' (preimage m ∘ h) := by\n  simp only [filter.lift', comap_lift_eq, (· ∘ ·), comap_principal]\n#align comap_lift'_eq comap_lift'_eq\n\n",
 "comap_eq_lift'":
 "theorem comap_eq_lift' {f : filter β} {m : α → β} : comap m f = f.lift' (preimage m) :=\n  filter.ext fun s => (mem_lift'_sets monotone_preimage).symm\n#align comap_eq_lift' comap_eq_lift'\n\n"}