{"limsup_mul_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic filter.is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem limsup_mul_le [countable_Inter_filter f] (u v : α → ennreal) : f.limsup (u * v) ≤ f.limsup u * f.limsup v :=\n  calc\n    f.limsup (u * v) ≤ f.limsup fun x => f.limsup u * v x :=\n      by\n      refine' limsup_le_limsup _ _\n      · filter_upwards [@eventually_le_limsup _ f _ u] with x hx\n        exact ennreal.mul_le_mul hx le_rfl\n      ·\n        run_tac\n          is_bounded_default\n    _ = f.limsup u * f.limsup v := limsup_const_mul\n    \n#align limsup_mul_le limsup_mul_le\n\n",
 "limsup_liminf_le_liminf_limsup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic filter.is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem limsup_liminf_le_liminf_limsup {β} [countable β] {f : filter α} [countable_Inter_filter f] {g : filter β}\n    (u : α → β → ennreal) :\n    (f.limsup fun a : α => g.liminf fun b : β => u a b) ≤ g.liminf fun b => f.limsup fun a => u a b :=\n  by\n  have h1 :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n      (∀ b, u a b ≤ f.limsup fun a' => u a' b) :=\n    by\n    rw [eventually_countable_forall]\n    exact fun b => ennreal.eventually_le_limsup fun a => u a b\n  refine' infₛ_le (h1.mono fun x hx => filter.liminf_le_liminf (filter.eventually_of_forall hx) _)\n  run_tac\n    filter.is_bounded_default\n#align limsup_liminf_le_liminf_limsup limsup_liminf_le_liminf_limsup\n\n",
 "limsup_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem limsup_eq_zero_iff [countable_Inter_filter f] {u : α → ennreal} : f.limsup u = 0 ↔ «expr =ᶠ[ ] » u f 0 :=\n  by\n  constructor <;> intro h\n  · have hu_zero := eventually_le.trans (eventually_le_limsup u) (eventually_of_forall fun _ => le_of_eq h)\n    exact hu_zero.mono fun x hx => le_antisymm hx (zero_le _)\n  · rw [limsup_congr h]\n    simp_rw [pi.zero_apply, ← ennreal.bot_eq_zero, limsup_const_bot]\n#align limsup_eq_zero_iff limsup_eq_zero_iff\n\n",
 "limsup_const_mul_of_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic filter.is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem limsup_const_mul_of_ne_top {u : α → ennreal} {a : ennreal} (ha_top : a ≠ «expr⊤») :\n    (f.limsup fun x : α => a * u x) = a * f.limsup u :=\n  by\n  by_cases ha_zero : a = 0\n  · simp_rw [ha_zero, zero_mul, ← ennreal.bot_eq_zero]\n    exact limsup_const_bot\n  let g := fun x : ennreal => a * x\n  have hg_bij : function.bijective g :=\n    function.bijective_iff_has_inverse.mpr\n      ⟨fun x => a⁻¹ * x,\n        ⟨fun x => by simp [← mul_assoc, ennreal.inv_mul_cancel ha_zero ha_top], fun x => by\n          simp [g, ← mul_assoc, ennreal.mul_inv_cancel ha_zero ha_top]⟩⟩\n  have hg_mono : strict_mono g :=\n    Monotone.strictMono_of_injective (fun _ _ _ => by rwa [mul_le_mul_left ha_zero ha_top]) hg_bij.1\n  let g_iso := StrictMono.orderIsoOfSurjective g hg_mono hg_bij.2\n  refine' (order_iso.limsup_apply g_iso _ _ _ _).symm\n  all_goals\n    run_tac\n      is_bounded_default\n#align limsup_const_mul_of_ne_top limsup_const_mul_of_ne_top\n\n",
 "limsup_const_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem limsup_const_mul [countable_Inter_filter f] {u : α → ennreal} {a : ennreal} :\n    (f.limsup fun x : α => a * u x) = a * f.limsup u :=\n  by\n  by_cases ha_top : a ≠ «expr⊤»\n  · exact limsup_const_mul_of_ne_top ha_top\n  push_neg  at ha_top\n  by_cases hu : «expr =ᶠ[ ] » u f 0\n  · have hau : «expr =ᶠ[ ] » (fun x => a * u x) f 0 :=\n      by\n      refine' hu.mono fun x hx => _\n      rw [pi.zero_apply] at hx\n      simp [hx]\n    simp only [limsup_congr hu, limsup_congr hau, pi.zero_apply, ← bot_eq_zero, limsup_const_bot]\n    simp\n  · simp_rw [ha_top, top_mul]\n    have hu_mul :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n        («expr⊤» ≤ ite (u x = 0) (0 : ennreal) («expr⊤»)) :=\n      by\n      rw [eventually_eq, not_eventually] at hu\n      refine' hu.mono fun x hx => _\n      rw [pi.zero_apply] at hx\n      simp [hx]\n    have h_top_le : (f.limsup fun x : α => ite (u x = 0) (0 : ennreal) («expr⊤»)) = «expr⊤» :=\n      eq_top_iff.mpr (le_limsup_of_frequently_le hu_mul)\n    have hfu : f.limsup u ≠ 0 := mt limsup_eq_zero_iff.1 hu\n    simp only [h_top_le, hfu, if_false]\n#align limsup_const_mul limsup_const_mul\n\n",
 "limsup_add_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem limsup_add_le [countable_Inter_filter f] (u v : α → ennreal) : f.limsup (u + v) ≤ f.limsup u + f.limsup v :=\n  infₛ_le ((eventually_le_limsup u).mp ((eventually_le_limsup v).mono fun _ hxg hxf => add_le_add hxf hxg))\n#align limsup_add_le limsup_add_le\n\n",
 "eventually_le_limsup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-\nCopyright (c) 2021 Rémy Degenne. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Rémy Degenne\n-/\ntheorem eventually_le_limsup [countable_Inter_filter f] (u : α → ennreal) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n      (u y ≤ f.limsup u) :=\n  by\n  by_cases hx_top : f.limsup u = «expr⊤»\n  · simp_rw [hx_top]\n    exact eventually_of_forall fun a => le_top\n  have h_forall_le :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n      (∀ n : ℕ, u y < f.limsup u + (1 : ennreal) / n) :=\n    by\n    rw [eventually_countable_forall]\n    refine' fun n => eventually_lt_of_limsup_lt _\n    nth_rw 1 [← add_zero (f.limsup u)]\n    exact (ennreal.add_lt_add_iff_left hx_top).mpr (by simp)\n  refine' h_forall_le.mono fun y hy => le_of_forall_pos_le_add fun r hr_pos hx_top => _\n  have hr_ne_zero : (r : ennreal) ≠ 0 := by\n    rw [ne.def, coe_eq_zero]\n    exact (ne_of_lt hr_pos).symm\n  cases' exists_inv_nat_lt hr_ne_zero with i hi\n  rw [inv_eq_one_div] at hi\n  exact (hy i).le.trans (add_le_add_left hi.le (f.limsup u))\n#align eventually_le_limsup eventually_le_limsup\n\n"}