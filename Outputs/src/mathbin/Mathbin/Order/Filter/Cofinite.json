{"tendsto_cofinite":
 "/-- For an injective function `f`, inverse images of finite sets are finite. See also\n`filter.comap_cofinite_le` and `function.injective.comap_cofinite_eq`. -/\ntheorem function.injective.tendsto_cofinite {f : α → β} (hf : injective f) : tendsto f cofinite cofinite := fun s h =>\n  h.preimage (hf.inj_on _)\n#align function.injective.tendsto_cofinite function.injective.tendsto_cofinite\n\n",
 "nat_tendsto_at_top":
 "/-- An injective sequence `f : ℕ → ℕ` tends to infinity at infinity. -/\ntheorem function.injective.nat_tendsto_at_top {f : ℕ → ℕ} (hf : injective f) : tendsto f at_top at_top :=\n  nat.cofinite_eq_at_top ▸ hf.tendsto_cofinite\n#align function.injective.nat_tendsto_at_top function.injective.nat_tendsto_at_top\n\n",
 "mem_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Jeremy Avigad, Yury Kudryashov\n-/\n@[simp]\ntheorem mem_cofinite {s : set α} : s ∈ @cofinite α ↔ («expr ᶜ» s).finite :=\n  iff.rfl\n#align mem_cofinite mem_cofinite\n\n",
 "le_cofinite_iff_eventually_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem le_cofinite_iff_eventually_ne :\n    l ≤ cofinite ↔\n      ∀ x,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n          (y ≠ x) :=\n  le_cofinite_iff_compl_singleton_mem\n#align le_cofinite_iff_eventually_ne le_cofinite_iff_eventually_ne\n\n",
 "le_cofinite_iff_compl_singleton_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem le_cofinite_iff_compl_singleton_mem : l ≤ cofinite ↔ ∀ x, «expr ᶜ» {x} ∈ l :=\n  by\n  refine' ⟨fun h x => h (finite_singleton x).compl_mem_cofinite, fun h s (hs : («expr ᶜ» s).finite) => _⟩\n  rw [← compl_compl s, ← bUnion_of_singleton («expr ᶜ» s), compl_Union₂, filter.bInter_mem hs]\n  exact fun x _ => h x\n#align le_cofinite_iff_compl_singleton_mem le_cofinite_iff_compl_singleton_mem\n\n",
 "infinite_iff_frequently_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem _root_.set.infinite_iff_frequently_cofinite {s : set α} :\n    set.infinite s ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" cofinite\n        (x ∈ s) :=\n  frequently_cofinite_iff_infinite.symm\n#align set.infinite_iff_frequently_cofinite set.infinite_iff_frequently_cofinite\n\n",
 "has_basis_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem has_basis_cofinite : has_basis cofinite (fun s : set α => s.finite) compl :=\n  ⟨fun s =>\n    ⟨fun h => ⟨«expr ᶜ» s, h, (compl_compl s).subset⟩, fun ⟨t, htf, hts⟩ => htf.subset <| compl_subset_comm.2 hts⟩⟩\n#align has_basis_cofinite has_basis_cofinite\n\n",
 "frequently_cofinite_iff_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_cofinite_iff_infinite {p : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" cofinite\n        (p x) ↔\n      set.infinite { x | p x } :=\n  by simp only [filter.frequently, filter.eventually, mem_cofinite, compl_set_of, not_not, set.infinite]\n#align frequently_cofinite_iff_infinite frequently_cofinite_iff_infinite\n\n",
 "frequently_at_top_iff_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem nat.frequently_at_top_iff_infinite {p : ℕ → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n        (p n) ↔\n      set.infinite { n | p n } :=\n  by rw [← nat.cofinite_eq_at_top, frequently_cofinite_iff_infinite]\n#align nat.frequently_at_top_iff_infinite nat.frequently_at_top_iff_infinite\n\n",
 "exists_within_forall_le":
 "theorem filter.tendsto.exists_within_forall_le {α β : Type _} [linear_order β] {s : set α} (hs : s.nonempty) {f : α → β}\n    (hf : filter.tendsto f filter.cofinite filter.at_top) : ∃ a₀ ∈ s, ∀ a ∈ s, f a₀ ≤ f a :=\n  by\n  rcases em (∃ y ∈ s, ∃ x, f y < x) with (⟨y, hys, x, hx⟩ | not_all_top)\n  · -- the set of points `{y | f y < x}` is nonempty and finite, so we take `min` over this set\n    have : { y | ¬x ≤ f y }.finite := filter.eventually_cofinite.mp (tendsto_at_top.1 hf x)\n    simp only [not_le] at this\n    obtain ⟨a₀, ⟨ha₀ : f a₀ < x, ha₀s⟩, others_bigger⟩ := exists_min_image _ f (this.inter_of_left s) ⟨y, hx, hys⟩\n    refine' ⟨a₀, ha₀s, fun a has => (lt_or_le (f a) x).elim _ (le_trans ha₀.le)⟩\n    exact fun h => others_bigger a ⟨h, has⟩\n  · -- in this case, f is constant because all values are at top\n    push_neg  at not_all_top\n    obtain ⟨a₀, ha₀s⟩ := hs\n    exact ⟨a₀, ha₀s, fun a ha => not_all_top a ha (f a₀)⟩\n#align filter.tendsto.exists_within_forall_le filter.tendsto.exists_within_forall_le\n\n",
 "exists_within_forall_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem filter.tendsto.exists_within_forall_ge [linear_order β] {s : set α} (hs : s.nonempty) {f : α → β}\n    (hf : filter.tendsto f filter.cofinite filter.at_bot) : ∃ a₀ ∈ s, ∀ a ∈ s, f a ≤ f a₀ :=\n  @filter.tendsto.exists_within_forall_le _ («expr ᵒᵈ» β) _ _ hs _ hf\n#align filter.tendsto.exists_within_forall_ge filter.tendsto.exists_within_forall_ge\n\n",
 "exists_forall_le":
 "theorem filter.tendsto.exists_forall_le [nonempty α] [linear_order β] {f : α → β} (hf : tendsto f cofinite at_top) :\n    ∃ a₀, ∀ a, f a₀ ≤ f a :=\n  let ⟨a₀, _, ha₀⟩ := hf.exists_within_forall_le univ_nonempty\n  ⟨a₀, fun a => ha₀ a (mem_univ _)⟩\n#align filter.tendsto.exists_forall_le filter.tendsto.exists_forall_le\n\n",
 "exists_forall_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem filter.tendsto.exists_forall_ge [nonempty α] [linear_order β] {f : α → β} (hf : tendsto f cofinite at_bot) :\n    ∃ a₀, ∀ a, f a ≤ f a₀ :=\n  @filter.tendsto.exists_forall_le _ («expr ᵒᵈ» β) _ _ _ hf\n#align filter.tendsto.exists_forall_ge filter.tendsto.exists_forall_ge\n\n",
 "eventually_cofinite_nmem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem _root_.finset.eventually_cofinite_nmem (s : Finset α) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" cofinite\n      (x ∉ s) :=\n  s.finite_to_set.eventually_cofinite_nmem\n#align finset.eventually_cofinite_nmem finset.eventually_cofinite_nmem\n\n",
 "eventually_cofinite_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_cofinite_ne (x : α) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" cofinite\n      (a ≠ x) :=\n  (set.finite_singleton x).eventually_cofinite_nmem\n#align eventually_cofinite_ne eventually_cofinite_ne\n\n",
 "eventually_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_cofinite {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" cofinite\n        (p x) ↔\n      { x | ¬p x }.finite :=\n  iff.rfl\n#align eventually_cofinite eventually_cofinite\n\n",
 "disjoint_cofinite_right":
 "@[simp]\ntheorem disjoint_cofinite_right : Disjoint l cofinite ↔ ∃ s ∈ l, set.finite s :=\n  disjoint_comm.trans disjoint_cofinite_left\n#align disjoint_cofinite_right disjoint_cofinite_right\n\n",
 "disjoint_cofinite_left":
 "@[simp]\ntheorem disjoint_cofinite_left : Disjoint cofinite l ↔ ∃ s ∈ l, set.finite s :=\n  by\n  simp only [has_basis_cofinite.disjoint_iff l.basis_sets, id, disjoint_compl_left_iff_subset]\n  exact ⟨fun ⟨s, hs, t, ht, hts⟩ => ⟨t, ht, hs.subset hts⟩, fun ⟨s, hs, hsf⟩ => ⟨s, hsf, s, hs, subset.rfl⟩⟩\n#align disjoint_cofinite_left disjoint_cofinite_left\n\n",
 "coprod_cofinite":
 "/-- The coproduct of the cofinite filters on two types is the cofinite filter on their product. -/\ntheorem coprod_cofinite : (cofinite : filter α).coprod (cofinite : filter β) = cofinite :=\n  filter.coext fun s => by simp only [compl_mem_coprod, mem_cofinite, compl_compl, finite_image_fst_and_snd_iff]\n#align coprod_cofinite coprod_cofinite\n\n",
 "compl_mem_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem _root_.set.finite.compl_mem_cofinite {s : set α} (hs : s.finite) : «expr ᶜ» s ∈ @cofinite α :=\n  mem_cofinite.2 <| (compl_compl s).symm ▸ hs\n#align set.finite.compl_mem_cofinite set.finite.compl_mem_cofinite\n\n",
 "comap_cofinite_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem comap_cofinite_le (f : α → β) : comap f cofinite ≤ cofinite :=\n  le_cofinite_iff_eventually_ne.mpr fun x =>\n    mem_comap.2 ⟨«expr ᶜ» {f x}, (finite_singleton _).compl_mem_cofinite, fun y => ne_of_apply_ne f⟩\n#align comap_cofinite_le comap_cofinite_le\n\n",
 "comap_cofinite_eq":
 "/-- The pullback of the `filter.cofinite` under an injective function is equal to `filter.cofinite`.\nSee also `filter.comap_cofinite_le` and `function.injective.tendsto_cofinite`. -/\ntheorem function.injective.comap_cofinite_eq {f : α → β} (hf : injective f) : comap f cofinite = cofinite :=\n  (comap_cofinite_le f).antisymm hf.tendsto_cofinite.le_comap\n#align function.injective.comap_cofinite_eq function.injective.comap_cofinite_eq\n\n",
 "cofinite_eq_at_top":
 "/-- For natural numbers the filters `cofinite` and `at_top` coincide. -/\ntheorem nat.cofinite_eq_at_top : @cofinite ℕ = at_top :=\n  by\n  refine' le_antisymm _ at_top_le_cofinite\n  refine' at_top_basis.ge_iff.2 fun N hN => _\n  simpa only [mem_cofinite, compl_Ici] using finite_lt_nat N\n#align nat.cofinite_eq_at_top nat.cofinite_eq_at_top\n\n",
 "at_top_le_cofinite":
 "/-- If `α` is a preorder with no maximal element, then `at_top ≤ cofinite`. -/\ntheorem at_top_le_cofinite [preorder α] [NoMaxOrder α] : (at_top : filter α) ≤ cofinite :=\n  le_cofinite_iff_eventually_ne.mpr eventually_ne_at_top\n#align at_top_le_cofinite at_top_le_cofinite\n\n",
 "Coprod_cofinite":
 "/-- Finite product of finite sets is finite -/\ntheorem Coprod_cofinite {α : ι → Type _} [Finite ι] : (filter.Coprod fun i => (cofinite : filter (α i))) = cofinite :=\n  filter.coext fun s => by simp only [compl_mem_Coprod, mem_cofinite, compl_compl, forall_finite_image_eval_iff]\n#align Coprod_cofinite Coprod_cofinite\n\n"}