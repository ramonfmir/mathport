{"tendsto_coe_rat_at_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem tendsto_coe_rat_at_top_iff [LinearOrderedField R] [Archimedean R] {f : α → exprℚ} {l : filter α} :\n    tendsto (fun n => (f n : R)) l at_top ↔ tendsto f l at_top := by rw [← tendsto_comap_iff, rat.comap_coe_at_top]\n#align tendsto_coe_rat_at_top_iff tendsto_coe_rat_at_top_iff\n\n",
 "tendsto_coe_rat_at_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem tendsto_coe_rat_at_bot_iff [LinearOrderedField R] [Archimedean R] {f : α → exprℚ} {l : filter α} :\n    tendsto (fun n => (f n : R)) l at_bot ↔ tendsto f l at_bot := by rw [← tendsto_comap_iff, rat.comap_coe_at_bot]\n#align tendsto_coe_rat_at_bot_iff tendsto_coe_rat_at_bot_iff\n\n",
 "tendsto_coe_nat_at_top_iff":
 "theorem tendsto_coe_nat_at_top_iff [StrictOrderedSemiring R] [Archimedean R] {f : α → ℕ} {l : filter α} :\n    tendsto (fun n => (f n : R)) l at_top ↔ tendsto f l at_top :=\n  tendsto_at_top_embedding (fun a₁ a₂ => nat.cast_le) exists_nat_ge\n#align tendsto_coe_nat_at_top_iff tendsto_coe_nat_at_top_iff\n\n",
 "tendsto_coe_nat_at_top_at_top":
 "theorem tendsto_coe_nat_at_top_at_top [StrictOrderedSemiring R] [Archimedean R] : tendsto (coe : ℕ → R) at_top at_top :=\n  nat.mono_cast.tendsto_at_top_at_top exists_nat_ge\n#align tendsto_coe_nat_at_top_at_top tendsto_coe_nat_at_top_at_top\n\n",
 "tendsto_coe_int_at_top_iff":
 "theorem tendsto_coe_int_at_top_iff [StrictOrderedRing R] [Archimedean R] {f : α → ℤ} {l : filter α} :\n    tendsto (fun n => (f n : R)) l at_top ↔ tendsto f l at_top := by rw [← tendsto_comap_iff, int.comap_coe_at_top]\n#align tendsto_coe_int_at_top_iff tendsto_coe_int_at_top_iff\n\n",
 "tendsto_coe_int_at_top_at_top":
 "theorem tendsto_coe_int_at_top_at_top [StrictOrderedRing R] [Archimedean R] : tendsto (coe : ℤ → R) at_top at_top :=\n  Int.cast_mono.tendsto_at_top_at_top fun b =>\n    let ⟨n, hn⟩ := exists_nat_ge b\n    ⟨n, by exact_mod_cast hn⟩\n#align tendsto_coe_int_at_top_at_top tendsto_coe_int_at_top_at_top\n\n",
 "tendsto_coe_int_at_bot_iff":
 "theorem tendsto_coe_int_at_bot_iff [StrictOrderedRing R] [Archimedean R] {f : α → ℤ} {l : filter α} :\n    tendsto (fun n => (f n : R)) l at_bot ↔ tendsto f l at_bot := by rw [← tendsto_comap_iff, int.comap_coe_at_bot]\n#align tendsto_coe_int_at_bot_iff tendsto_coe_int_at_bot_iff\n\n",
 "const_mul_at_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If a function tends to infinity along a filter, then this function multiplied by a positive\nconstant (on the left) also tends to infinity. The archimedean assumption is convenient to get a\nstatement that works on `ℕ`, `ℤ` and `ℝ`, although not necessary (a version in ordered fields is\ngiven in `filter.tendsto.const_mul_at_top`). -/\ntheorem tendsto.const_mul_at_top' (hr : 0 < r) (hf : tendsto f l at_top) : tendsto (fun x => r * f x) l at_top :=\n  by\n  apply tendsto_at_top.2 fun b => _\n  obtain ⟨n : ℕ, hn : 1 ≤ «expr • » n r⟩ := archimedean.arch 1 hr\n  rw [nsmul_eq_mul'] at hn\n  filter_upwards [tendsto_at_top.1 hf (n * max b 0)] with x hx\n  calc\n    b ≤ 1 * max b 0 := by\n      rw [one_mul]\n      exact le_max_left _ _\n    _ ≤ r * n * max b 0 := mul_le_mul_of_nonneg_right hn (le_max_right _ _)\n    _ = r * (n * max b 0) := by rw [mul_assoc]\n    _ ≤ r * f x := mul_le_mul_of_nonneg_left hx (le_of_lt hr)\n    \n#align tendsto.const_mul_at_top' tendsto.const_mul_at_top'\n\n",
 "comap_coe_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem rat.comap_coe_at_top [LinearOrderedField R] [Archimedean R] : comap (coe : exprℚ → R) at_top = at_top :=\n  comap_embedding_at_top (fun _ _ => Rat.cast_le) fun r =>\n    let ⟨n, hn⟩ := exists_nat_ge r\n    ⟨n, by simpa⟩\n#align rat.comap_coe_at_top rat.comap_coe_at_top\n\n",
 "comap_coe_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem rat.comap_coe_at_bot [LinearOrderedField R] [Archimedean R] : comap (coe : exprℚ → R) at_bot = at_bot :=\n  comap_embedding_at_bot (fun _ _ => Rat.cast_le) fun r =>\n    let ⟨n, hn⟩ := exists_nat_ge (-r)\n    ⟨-n, by simpa [neg_le] ⟩\n#align rat.comap_coe_at_bot rat.comap_coe_at_bot\n\n",
 "at_top_zsmul_neg_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.at_top_zsmul_neg_const {f : α → ℤ} (hr : r < 0) (hf : tendsto f l at_top) :\n    tendsto (fun x => «expr • » (f x) r) l at_bot := by simpa using hf.at_top_zsmul_const (neg_pos.2 hr)\n#align tendsto.at_top_zsmul_neg_const tendsto.at_top_zsmul_neg_const\n\n",
 "at_top_zsmul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.at_top_zsmul_const {f : α → ℤ} (hr : 0 < r) (hf : tendsto f l at_top) :\n    tendsto (fun x => «expr • » (f x) r) l at_top :=\n  by\n  refine' tendsto_at_top.mpr fun s => _\n  obtain ⟨n : ℕ, hn : s ≤ «expr • » n r⟩ := archimedean.arch s hr\n  replace hn : s ≤ «expr • » (n : ℤ) r; · simpa\n  exact (tendsto_at_top.mp hf n).mono fun a ha => hn.trans (zsmul_le_zsmul hr.le ha)\n#align tendsto.at_top_zsmul_const tendsto.at_top_zsmul_const\n\n",
 "at_top_nsmul_neg_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.at_top_nsmul_neg_const {f : α → ℕ} (hr : r < 0) (hf : tendsto f l at_top) :\n    tendsto (fun x => «expr • » (f x) r) l at_bot := by simpa using hf.at_top_nsmul_const (neg_pos.2 hr)\n#align tendsto.at_top_nsmul_neg_const tendsto.at_top_nsmul_neg_const\n\n",
 "at_top_nsmul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.at_top_nsmul_const {f : α → ℕ} (hr : 0 < r) (hf : tendsto f l at_top) :\n    tendsto (fun x => «expr • » (f x) r) l at_top :=\n  by\n  refine' tendsto_at_top.mpr fun s => _\n  obtain ⟨n : ℕ, hn : s ≤ «expr • » n r⟩ := archimedean.arch s hr\n  exact (tendsto_at_top.mp hf n).mono fun a ha => hn.trans (nsmul_le_nsmul hr.le ha)\n#align tendsto.at_top_nsmul_const tendsto.at_top_nsmul_const\n\n",
 "at_top_mul_neg_const'":
 "/-- See also `filter.tendsto.at_top_mul_neg_const` for a version of this lemma for\n`linear_ordered_field`s which does not require the `archimedean` assumption. -/\ntheorem tendsto.at_top_mul_neg_const' (hr : r < 0) (hf : tendsto f l at_top) : tendsto (fun x => f x * r) l at_bot := by\n  simpa only [tendsto_neg_at_top_iff, mul_neg] using hf.at_top_mul_const' (neg_pos.mpr hr)\n#align tendsto.at_top_mul_neg_const' tendsto.at_top_mul_neg_const'\n\n",
 "at_top_mul_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If a function tends to infinity along a filter, then this function multiplied by a positive\nconstant (on the right) also tends to infinity. The archimedean assumption is convenient to get a\nstatement that works on `ℕ`, `ℤ` and `ℝ`, although not necessary (a version in ordered fields is\ngiven in `filter.tendsto.at_top_mul_const`). -/\ntheorem tendsto.at_top_mul_const' (hr : 0 < r) (hf : tendsto f l at_top) : tendsto (fun x => f x * r) l at_top :=\n  by\n  apply tendsto_at_top.2 fun b => _\n  obtain ⟨n : ℕ, hn : 1 ≤ «expr • » n r⟩ := archimedean.arch 1 hr\n  have hn' : 1 ≤ (n : R) * r := by rwa [nsmul_eq_mul] at hn\n  filter_upwards [tendsto_at_top.1 hf (max b 0 * n)] with x hx\n  calc\n    b ≤ max b 0 * 1 := by\n      rw [mul_one]\n      exact le_max_left _ _\n    _ ≤ max b 0 * (n * r) := mul_le_mul_of_nonneg_left hn' (le_max_right _ _)\n    _ = max b 0 * n * r := by rw [mul_assoc]\n    _ ≤ f x * r := mul_le_mul_of_nonneg_right hx (le_of_lt hr)\n    \n#align tendsto.at_top_mul_const' tendsto.at_top_mul_const'\n\n",
 "at_top_countable_basis_of_archimedean":
 "theorem at_top_countable_basis_of_archimedean [LinearOrderedSemiring R] [Archimedean R] :\n    (at_top : filter R).has_countable_basis (fun n : ℕ => true) fun n => Ici n :=\n  { countable := to_countable _\n    to_has_basis :=\n      at_top_basis.to_has_basis\n        (fun x hx =>\n          let ⟨n, hn⟩ := exists_nat_ge x\n          ⟨n, trivial, Ici_subset_Ici.2 hn⟩)\n        fun n hn => ⟨n, trivial, Subset.rfl⟩ }\n#align at_top_countable_basis_of_archimedean at_top_countable_basis_of_archimedean\n\n",
 "at_bot_zsmul_neg_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.at_bot_zsmul_neg_const {f : α → ℤ} (hr : r < 0) (hf : tendsto f l at_bot) :\n    tendsto (fun x => «expr • » (f x) r) l at_top := by simpa using hf.at_bot_zsmul_const (neg_pos.2 hr)\n#align tendsto.at_bot_zsmul_neg_const tendsto.at_bot_zsmul_neg_const\n\n",
 "at_bot_zsmul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.at_bot_zsmul_const {f : α → ℤ} (hr : 0 < r) (hf : tendsto f l at_bot) :\n    tendsto (fun x => «expr • » (f x) r) l at_bot :=\n  by\n  simp only [← tendsto_neg_at_top_iff, ← neg_zsmul] at hf⊢\n  exact hf.at_top_zsmul_const hr\n#align tendsto.at_bot_zsmul_const tendsto.at_bot_zsmul_const\n\n",
 "at_bot_mul_neg_const'":
 "/-- See also `filter.tendsto.at_bot_mul_neg_const` for a version of this lemma for\n`linear_ordered_field`s which does not require the `archimedean` assumption. -/\ntheorem tendsto.at_bot_mul_neg_const' (hr : r < 0) (hf : tendsto f l at_bot) : tendsto (fun x => f x * r) l at_top := by\n  simpa only [mul_neg, tendsto_neg_at_bot_iff] using hf.at_bot_mul_const' (neg_pos.2 hr)\n#align tendsto.at_bot_mul_neg_const' tendsto.at_bot_mul_neg_const'\n\n",
 "at_bot_mul_const'":
 "/-- See also `filter.tendsto.at_bot_mul_const` for a version of this lemma for\n`linear_ordered_field`s which does not require the `archimedean` assumption. -/\ntheorem tendsto.at_bot_mul_const' (hr : 0 < r) (hf : tendsto f l at_bot) : tendsto (fun x => f x * r) l at_bot :=\n  by\n  simp only [← tendsto_neg_at_top_iff, ← neg_mul] at hf⊢\n  exact hf.at_top_mul_const' hr\n#align tendsto.at_bot_mul_const' tendsto.at_bot_mul_const'\n\n",
 "at_bot_countable_basis_of_archimedean":
 "theorem at_bot_countable_basis_of_archimedean [LinearOrderedRing R] [Archimedean R] :\n    (at_bot : filter R).has_countable_basis (fun m : ℤ => true) fun m => Iic m :=\n  { countable := to_countable _\n    to_has_basis :=\n      at_bot_basis.to_has_basis\n        (fun x hx =>\n          let ⟨m, hm⟩ := exists_int_lt x\n          ⟨m, trivial, Iic_subset_Iic.2 hm.le⟩)\n        fun m hm => ⟨m, trivial, Subset.rfl⟩ }\n#align at_bot_countable_basis_of_archimedean at_bot_countable_basis_of_archimedean\n\n"}