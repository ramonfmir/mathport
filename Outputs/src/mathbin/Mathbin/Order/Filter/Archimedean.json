{"tendsto_rat_cast_atTop_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print tendsto_rat_cast_atTop_iff /-\ntheorem tendsto_rat_cast_atTop_iff [LinearOrderedField R] [Archimedean R] {f : α → exprℚ} {l : Filter α} :\n    Tendsto (fun n => (f n : R)) l atTop ↔ Tendsto f l atTop := by rw [← tendsto_comap_iff, Rat.comap_cast_atTop]\n#align tendsto_coe_rat_at_top_iff tendsto_rat_cast_atTop_iff\n-/\n\n",
 "tendsto_rat_cast_atBot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print tendsto_rat_cast_atBot_iff /-\ntheorem tendsto_rat_cast_atBot_iff [LinearOrderedField R] [Archimedean R] {f : α → exprℚ} {l : Filter α} :\n    Tendsto (fun n => (f n : R)) l atBot ↔ Tendsto f l atBot := by rw [← tendsto_comap_iff, Rat.comap_cast_atBot]\n#align tendsto_coe_rat_at_bot_iff tendsto_rat_cast_atBot_iff\n-/\n\n",
 "tendsto_nat_cast_atTop_iff":
 "#print tendsto_nat_cast_atTop_iff /-\ntheorem tendsto_nat_cast_atTop_iff [StrictOrderedSemiring R] [Archimedean R] {f : α → ℕ} {l : Filter α} :\n    Tendsto (fun n => (f n : R)) l atTop ↔ Tendsto f l atTop :=\n  tendsto_atTop_embedding (fun a₁ a₂ => Nat.cast_le) exists_nat_ge\n#align tendsto_coe_nat_at_top_iff tendsto_nat_cast_atTop_iff\n-/\n\n",
 "tendsto_nat_cast_atTop_atTop":
 "#print tendsto_nat_cast_atTop_atTop /-\ntheorem tendsto_nat_cast_atTop_atTop [StrictOrderedSemiring R] [Archimedean R] : Tendsto (coe : ℕ → R) atTop atTop :=\n  Nat.mono_cast.tendsto_at_top_at_top exists_nat_ge\n#align tendsto_coe_nat_at_top_at_top tendsto_nat_cast_atTop_atTop\n-/\n\n",
 "tendsto_int_cast_atTop_iff":
 "#print tendsto_int_cast_atTop_iff /-\ntheorem tendsto_int_cast_atTop_iff [StrictOrderedRing R] [Archimedean R] {f : α → ℤ} {l : Filter α} :\n    Tendsto (fun n => (f n : R)) l atTop ↔ Tendsto f l atTop := by rw [← tendsto_comap_iff, Int.comap_cast_atTop]\n#align tendsto_coe_int_at_top_iff tendsto_int_cast_atTop_iff\n-/\n\n",
 "tendsto_int_cast_atTop_atTop":
 "#print tendsto_int_cast_atTop_atTop /-\ntheorem tendsto_int_cast_atTop_atTop [StrictOrderedRing R] [Archimedean R] : Tendsto (coe : ℤ → R) atTop atTop :=\n  Int.cast_mono.tendsto_at_top_at_top fun b =>\n    let ⟨n, hn⟩ := exists_nat_ge b\n    ⟨n, by exact_mod_cast hn⟩\n#align tendsto_coe_int_at_top_at_top tendsto_int_cast_atTop_atTop\n-/\n\n",
 "tendsto_int_cast_atBot_iff":
 "#print tendsto_int_cast_atBot_iff /-\ntheorem tendsto_int_cast_atBot_iff [StrictOrderedRing R] [Archimedean R] {f : α → ℤ} {l : Filter α} :\n    Tendsto (fun n => (f n : R)) l atBot ↔ Tendsto f l atBot := by rw [← tendsto_comap_iff, Int.comap_cast_atBot]\n#align tendsto_coe_int_at_bot_iff tendsto_int_cast_atBot_iff\n-/\n\n",
 "const_mul_at_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If a function tends to infinity along a filter, then this function multiplied by a positive\nconstant (on the left) also tends to infinity. The archimedean assumption is convenient to get a\nstatement that works on `ℕ`, `ℤ` and `ℝ`, although not necessary (a version in ordered fields is\ngiven in `filter.tendsto.const_mul_at_top`). -/\ntheorem tendsto.const_mul_at_top' (hr : 0 < r) (hf : Tendsto f l atTop) : Tendsto (fun x => r * f x) l atTop :=\n  by\n  apply tendsto_at_top.2 fun b => _\n  obtain ⟨n : ℕ, hn : 1 ≤ «expr • » n r⟩ := archimedean.arch 1 hr\n  rw [nsmul_eq_mul'] at hn\n  filter_upwards [tendsto_at_top.1 hf (n * max b 0)]with x hx\n  calc\n    b ≤ 1 * max b 0 := by\n      rw [one_mul]\n      exact le_max_left _ _\n    _ ≤ r * n * max b 0 := (mul_le_mul_of_nonneg_right hn (le_max_right _ _))\n    _ = r * (n * max b 0) := by rw [mul_assoc]\n    _ ≤ r * f x := mul_le_mul_of_nonneg_left hx (le_of_lt hr)\n    \n#align tendsto.const_mul_at_top' tendsto.const_mul_at_top'\n\n",
 "comap_cast_atTop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print Rat.comap_cast_atTop /-\n@[simp]\ntheorem Rat.comap_cast_atTop [LinearOrderedField R] [Archimedean R] : comap (coe : exprℚ → R) atTop = atTop :=\n  comap_embedding_atTop (fun _ _ => Rat.cast_le) fun r =>\n    let ⟨n, hn⟩ := exists_nat_ge r\n    ⟨n, by simpa⟩\n#align rat.comap_coe_at_top Rat.comap_cast_atTop\n-/\n\n",
 "comap_cast_atBot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print Rat.comap_cast_atBot /-\n@[simp]\ntheorem Rat.comap_cast_atBot [LinearOrderedField R] [Archimedean R] : comap (coe : exprℚ → R) atBot = atBot :=\n  comap_embedding_atBot (fun _ _ => Rat.cast_le) fun r =>\n    let ⟨n, hn⟩ := exists_nat_ge (-r)\n    ⟨-n, by simpa [neg_le] ⟩\n#align rat.comap_coe_at_bot Rat.comap_cast_atBot\n-/\n\n",
 "at_top_zsmul_neg_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.at_top_zsmul_neg_const {f : α → ℤ} (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => «expr • » (f x) r) l atBot := by simpa using hf.at_top_zsmul_const (neg_pos.2 hr)\n#align tendsto.at_top_zsmul_neg_const tendsto.at_top_zsmul_neg_const\n\n",
 "at_top_zsmul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.at_top_zsmul_const {f : α → ℤ} (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => «expr • » (f x) r) l atTop :=\n  by\n  refine' tendsto_at_top.mpr fun s => _\n  obtain ⟨n : ℕ, hn : s ≤ «expr • » n r⟩ := archimedean.arch s hr\n  replace hn : s ≤ «expr • » (n : ℤ) r; · simpa\n  exact (tendsto_at_top.mp hf n).mono fun a ha => hn.trans (zsmul_le_zsmul hr.le ha)\n#align tendsto.at_top_zsmul_const tendsto.at_top_zsmul_const\n\n",
 "at_top_nsmul_neg_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.at_top_nsmul_neg_const {f : α → ℕ} (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => «expr • » (f x) r) l atBot := by simpa using hf.at_top_nsmul_const (neg_pos.2 hr)\n#align tendsto.at_top_nsmul_neg_const tendsto.at_top_nsmul_neg_const\n\n",
 "at_top_nsmul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.at_top_nsmul_const {f : α → ℕ} (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => «expr • » (f x) r) l atTop :=\n  by\n  refine' tendsto_at_top.mpr fun s => _\n  obtain ⟨n : ℕ, hn : s ≤ «expr • » n r⟩ := archimedean.arch s hr\n  exact (tendsto_at_top.mp hf n).mono fun a ha => hn.trans (nsmul_le_nsmul hr.le ha)\n#align tendsto.at_top_nsmul_const tendsto.at_top_nsmul_const\n\n",
 "at_top_mul_neg_const'":
 "/-- See also `filter.tendsto.at_top_mul_neg_const` for a version of this lemma for\n`linear_ordered_field`s which does not require the `archimedean` assumption. -/\ntheorem tendsto.at_top_mul_neg_const' (hr : r < 0) (hf : Tendsto f l atTop) : Tendsto (fun x => f x * r) l atBot := by\n  simpa only [tendsto_neg_at_top_iff, mul_neg] using hf.at_top_mul_const' (neg_pos.mpr hr)\n#align tendsto.at_top_mul_neg_const' tendsto.at_top_mul_neg_const'\n\n",
 "at_top_mul_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If a function tends to infinity along a filter, then this function multiplied by a positive\nconstant (on the right) also tends to infinity. The archimedean assumption is convenient to get a\nstatement that works on `ℕ`, `ℤ` and `ℝ`, although not necessary (a version in ordered fields is\ngiven in `filter.tendsto.at_top_mul_const`). -/\ntheorem tendsto.at_top_mul_const' (hr : 0 < r) (hf : Tendsto f l atTop) : Tendsto (fun x => f x * r) l atTop :=\n  by\n  apply tendsto_at_top.2 fun b => _\n  obtain ⟨n : ℕ, hn : 1 ≤ «expr • » n r⟩ := archimedean.arch 1 hr\n  have hn' : 1 ≤ (n : R) * r := by rwa [nsmul_eq_mul] at hn\n  filter_upwards [tendsto_at_top.1 hf (max b 0 * n)]with x hx\n  calc\n    b ≤ max b 0 * 1 := by\n      rw [mul_one]\n      exact le_max_left _ _\n    _ ≤ max b 0 * (n * r) := (mul_le_mul_of_nonneg_left hn' (le_max_right _ _))\n    _ = max b 0 * n * r := by rw [mul_assoc]\n    _ ≤ f x * r := mul_le_mul_of_nonneg_right hx (le_of_lt hr)\n    \n#align tendsto.at_top_mul_const' tendsto.at_top_mul_const'\n\n",
 "at_bot_zsmul_neg_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.at_bot_zsmul_neg_const {f : α → ℤ} (hr : r < 0) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => «expr • » (f x) r) l atTop := by simpa using hf.at_bot_zsmul_const (neg_pos.2 hr)\n#align tendsto.at_bot_zsmul_neg_const tendsto.at_bot_zsmul_neg_const\n\n",
 "at_bot_zsmul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.at_bot_zsmul_const {f : α → ℤ} (hr : 0 < r) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => «expr • » (f x) r) l atBot :=\n  by\n  simp only [← tendsto_neg_at_top_iff, ← neg_zsmul] at hf⊢\n  exact hf.at_top_zsmul_const hr\n#align tendsto.at_bot_zsmul_const tendsto.at_bot_zsmul_const\n\n",
 "at_bot_mul_neg_const'":
 "/-- See also `filter.tendsto.at_bot_mul_neg_const` for a version of this lemma for\n`linear_ordered_field`s which does not require the `archimedean` assumption. -/\ntheorem tendsto.at_bot_mul_neg_const' (hr : r < 0) (hf : Tendsto f l atBot) : Tendsto (fun x => f x * r) l atTop := by\n  simpa only [mul_neg, tendsto_neg_at_bot_iff] using hf.at_bot_mul_const' (neg_pos.2 hr)\n#align tendsto.at_bot_mul_neg_const' tendsto.at_bot_mul_neg_const'\n\n",
 "at_bot_mul_const'":
 "/-- See also `filter.tendsto.at_bot_mul_const` for a version of this lemma for\n`linear_ordered_field`s which does not require the `archimedean` assumption. -/\ntheorem tendsto.at_bot_mul_const' (hr : 0 < r) (hf : Tendsto f l atBot) : Tendsto (fun x => f x * r) l atBot :=\n  by\n  simp only [← tendsto_neg_at_top_iff, ← neg_mul] at hf⊢\n  exact hf.at_top_mul_const' hr\n#align tendsto.at_bot_mul_const' tendsto.at_bot_mul_const'\n\n",
 "atTop_hasCountableBasis_of_archimedean":
 "#print atTop_hasCountableBasis_of_archimedean /-\ntheorem atTop_hasCountableBasis_of_archimedean [LinearOrderedSemiring R] [Archimedean R] :\n    (atTop : Filter R).has_countable_basis (fun n : ℕ => True) fun n => Ici n :=\n  { countable := to_countable _\n    to_has_basis :=\n      atTop_basis.to_has_basis\n        (fun x hx =>\n          let ⟨n, hn⟩ := exists_nat_ge x\n          ⟨n, trivial, Ici_subset_Ici.2 hn⟩)\n        fun n hn => ⟨n, trivial, Subset.rfl⟩ }\n#align at_top_countable_basis_of_archimedean atTop_hasCountableBasis_of_archimedean\n-/\n\n",
 "atBot_hasCountableBasis_of_archimedean":
 "#print atBot_hasCountableBasis_of_archimedean /-\ntheorem atBot_hasCountableBasis_of_archimedean [LinearOrderedRing R] [Archimedean R] :\n    (atBot : Filter R).has_countable_basis (fun m : ℤ => True) fun m => Iic m :=\n  { countable := to_countable _\n    to_has_basis :=\n      atBot_basis.to_has_basis\n        (fun x hx =>\n          let ⟨m, hm⟩ := exists_int_lt x\n          ⟨m, trivial, Iic_subset_Iic.2 hm.le⟩)\n        fun m hm => ⟨m, trivial, Subset.rfl⟩ }\n#align at_bot_countable_basis_of_archimedean atBot_hasCountableBasis_of_archimedean\n-/\n\n"}