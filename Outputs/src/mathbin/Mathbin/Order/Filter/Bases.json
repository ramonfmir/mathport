{"to_subset":
 "theorem has_basis.to_subset (hl : l.has_basis p s) {t : ι → Set α} (h : ∀ i, p i → t i ⊆ s i)\n    (ht : ∀ i, p i → t i ∈ l) : l.has_basis p t :=\n  hl.to_has_basis' (fun i hi => ⟨i, hi, h i hi⟩) ht\n#align has_basis.to_subset has_basis.to_subset\n\n",
 "to_has_basis'":
 "theorem has_basis.to_has_basis' (hl : l.has_basis p s) (h : ∀ i, p i → ∃ i', p' i' ∧ s' i' ⊆ s i)\n    (h' : ∀ i', p' i' → s' i' ∈ l) : l.has_basis p' s' :=\n  by\n  refine' ⟨fun t => ⟨fun ht => _, fun ⟨i', hi', ht⟩ => mem_of_superset (h' i' hi') ht⟩⟩\n  rcases hl.mem_iff.1 ht with ⟨i, hi, ht⟩\n  rcases h i hi with ⟨i', hi', hs's⟩\n  exact ⟨i', hi', subset.trans hs's ht⟩\n#align has_basis.to_has_basis' has_basis.to_has_basis'\n\n",
 "to_has_basis":
 "theorem has_basis.to_has_basis (hl : l.has_basis p s) (h : ∀ i, p i → ∃ i', p' i' ∧ s' i' ⊆ s i)\n    (h' : ∀ i', p' i' → ∃ i, p i ∧ s i ⊆ s' i') : l.has_basis p' s' :=\n  hl.to_has_basis' h fun i' hi' =>\n    let ⟨i, hi, hss'⟩ := h' i' hi'\n    hl.mem_iff.2 ⟨i, hi, hss'⟩\n#align has_basis.to_has_basis has_basis.to_has_basis\n\n",
 "tendsto_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem has_basis.tendsto_right_iff (hlb : lb.has_basis pb sb) :\n    Tendsto f la lb ↔\n      ∀ (i) (hi : pb i),\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" la\n          (f x ∈ sb i) :=\n  by simpa only [tendsto, hlb.ge_iff, mem_map, Filter.Eventually]\n#align has_basis.tendsto_right_iff has_basis.tendsto_right_iff\n\n",
 "tendsto_left_iff":
 "theorem has_basis.tendsto_left_iff (hla : la.has_basis pa sa) :\n    Tendsto f la lb ↔ ∀ t ∈ lb, ∃ (i : _)(hi : pa i), MapsTo f (sa i) t :=\n  by\n  simp only [tendsto, (hla.map f).le_iff, image_subset_iff]\n  rfl\n#align has_basis.tendsto_left_iff has_basis.tendsto_left_iff\n\n",
 "tendsto_iff":
 "theorem has_basis.tendsto_iff (hla : la.has_basis pa sa) (hlb : lb.has_basis pb sb) :\n    Tendsto f la lb ↔ ∀ (ib) (hib : pb ib), ∃ (ia : _)(hia : pa ia), ∀ x ∈ sa ia, f x ∈ sb ib := by\n  simp [hlb.tendsto_right_iff, hla.eventually_iff]\n#align has_basis.tendsto_iff has_basis.tendsto_iff\n\n",
 "sup_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem has_basis.sup_pure (hl : l.has_basis p s) (x : α) : («expr ⊔ » l (pure x)).has_basis p fun i => s i ∪ {x} := by\n  simp only [← principal_singleton, hl.sup_principal]\n#align has_basis.sup_pure has_basis.sup_pure\n\n",
 "sup_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis.sup_principal (hl : l.has_basis p s) (t : Set α) :\n    («expr ⊔ » l ((filter.principal) t)).has_basis p fun i => s i ∪ t :=\n  ⟨fun u => by\n    simp only [(hl.sup' (has_basis_principal t)).mem_iff, PProd.exists, exists_prop, and_true_iff, Unique.exists_iff]⟩\n#align has_basis.sup_principal has_basis.sup_principal\n\n",
 "sup'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem has_basis.sup' (hl : l.has_basis p s) (hl' : l'.has_basis p' s') :\n    («expr ⊔ » l l').has_basis (fun i : PProd ι ι' => p i.1 ∧ p' i.2) fun i => s i.1 ∪ s' i.2 :=\n  ⟨by\n    intro t\n    simp only [mem_sup, hl.mem_iff, hl'.mem_iff, PProd.exists, union_subset_iff, exists_prop, and_assoc',\n      exists_and_left]\n    simp only [← and_assoc', exists_and_right, and_comm']⟩\n#align has_basis.sup' has_basis.sup'\n\n",
 "sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem has_basis.sup {ι ι' : Type _} {p : ι → Prop} {s : ι → Set α} {p' : ι' → Prop} {s' : ι' → Set α}\n    (hl : l.has_basis p s) (hl' : l'.has_basis p' s') :\n    («expr ⊔ » l l').has_basis (fun i : ι × ι' => p i.1 ∧ p' i.2) fun i => s i.1 ∪ s' i.2 :=\n  (hl.sup' hl').to_has_basis (fun i hi => ⟨⟨i.1, i.2⟩, hi, Subset.rfl⟩) fun i hi => ⟨⟨i.1, i.2⟩, hi, Subset.rfl⟩\n#align has_basis.sup has_basis.sup\n\n",
 "set_index_subset":
 "theorem has_basis.set_index_subset (h : l.has_basis p s) (ht : t ∈ l) : s (h.index t ht) ⊆ t :=\n  (h.mem_iff.1 ht).some_spec.snd\n#align has_basis.set_index_subset has_basis.set_index_subset\n\n",
 "set_index_mem":
 "theorem has_basis.set_index_mem (h : l.has_basis p s) (ht : t ∈ l) : s (h.index t ht) ∈ l :=\n  h.mem_of_mem <| h.property_index _\n#align has_basis.set_index_mem has_basis.set_index_mem\n\n",
 "sInter_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem has_basis.sInter_sets (h : HasBasis l p s) :\n    «expr⋂₀ » l.sets =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i) :=\n  by\n  rw [sInter_eq_bInter]\n  exact h.bInter_mem monotone_id\n#align has_basis.sInter_sets has_basis.sInter_sets\n\n",
 "restrict_subset":
 "/-- If `{s i | p i}` is a basis of a filter `l` and `V ∈ l`, then `{s i | p i ∧ s i ⊆ V}`\nis a basis of `l`. -/\ntheorem has_basis.restrict_subset (h : l.has_basis p s) {V : Set α} (hV : V ∈ l) :\n    l.has_basis (fun i => p i ∧ s i ⊆ V) s :=\n  h.restrict fun i hi =>\n    (h.mem_iff.1 (inter_mem hV (h.mem_of_mem hi))).imp fun j hj => ⟨hj.fst, subset_inter_iff.1 hj.snd⟩\n#align has_basis.restrict_subset has_basis.restrict_subset\n\n",
 "restrict":
 "/-- If `{s i | p i}` is a basis of a filter `l` and each `s i` includes `s j` such that\n`p j ∧ q j`, then `{s j | p j ∧ q j}` is a basis of `l`. -/\ntheorem has_basis.restrict (h : l.has_basis p s) {q : ι → Prop} (hq : ∀ i, p i → ∃ j, p j ∧ q j ∧ s j ⊆ s i) :\n    l.has_basis (fun i => p i ∧ q i) s :=\n  by\n  refine' ⟨fun t => ⟨fun ht => _, fun ⟨i, hpi, hti⟩ => h.mem_iff.2 ⟨i, hpi.1, hti⟩⟩⟩\n  rcases h.mem_iff.1 ht with ⟨i, hpi, hti⟩\n  rcases hq i hpi with ⟨j, hpj, hqj, hji⟩\n  exact ⟨j, ⟨hpj, hqj⟩, subset.trans hji hti⟩\n#align has_basis.restrict has_basis.restrict\n\n",
 "property_index":
 "theorem has_basis.property_index (h : l.has_basis p s) (ht : t ∈ l) : p (h.index t ht) :=\n  (h.index t ht).2\n#align has_basis.property_index has_basis.property_index\n\n",
 "prod_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem has_basis.prod_self (hl : la.has_basis pa sa) :\n    (filter.prod la la).has_basis pa fun i => finset.product (sa i) (sa i) :=\n  hl.prod_same_index hl fun i j hi hj => by\n    simpa only [exists_prop, subset_inter_iff] using hl.mem_iff.1 (inter_mem (hl.mem_of_mem hi) (hl.mem_of_mem hj))\n#align has_basis.prod_self has_basis.prod_self\n\n",
 "prod_same_index_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem has_basis.prod_same_index_mono {ι : Type _} [linear_order ι] {p : ι → Prop} {sa : ι → Set α} {sb : ι → Set β}\n    (hla : la.has_basis p sa) (hlb : lb.has_basis p sb) (hsa : MonotoneOn sa { i | p i })\n    (hsb : MonotoneOn sb { i | p i }) : (filter.prod la lb).has_basis p fun i => finset.product (sa i) (sb i) :=\n  hla.prod_same_index hlb fun i j hi hj =>\n    have : p (min i j) := min_rec' _ hi hj\n    ⟨min i j, this, hsa this hi <| min_le_left _ _, hsb this hj <| min_le_right _ _⟩\n#align has_basis.prod_same_index_mono has_basis.prod_same_index_mono\n\n",
 "prod_same_index_anti":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem has_basis.prod_same_index_anti {ι : Type _} [linear_order ι] {p : ι → Prop} {sa : ι → Set α} {sb : ι → Set β}\n    (hla : la.has_basis p sa) (hlb : lb.has_basis p sb) (hsa : AntitoneOn sa { i | p i })\n    (hsb : AntitoneOn sb { i | p i }) : (filter.prod la lb).has_basis p fun i => finset.product (sa i) (sb i) :=\n  @HasBasis.prod_same_index_mono _ _ _ _ («expr ᵒᵈ» ι) _ _ _ _ hla hlb hsa.dual_left hsb.dual_left\n#align has_basis.prod_same_index_anti has_basis.prod_same_index_anti\n\n",
 "prod_same_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem has_basis.prod_same_index {p : ι → Prop} {sb : ι → Set β} (hla : la.has_basis p sa) (hlb : lb.has_basis p sb)\n    (h_dir : ∀ {i j}, p i → p j → ∃ k, p k ∧ sa k ⊆ sa i ∧ sb k ⊆ sb j) :\n    (filter.prod la lb).has_basis p fun i => finset.product (sa i) (sb i) :=\n  by\n  simp only [has_basis_iff, (hla.prod_pprod hlb).mem_iff]\n  refine' fun t => ⟨_, _⟩\n  · rintro ⟨⟨i, j⟩, ⟨hi, hj⟩, hsub : finset.product (sa i) (sb j) ⊆ t⟩\n    rcases h_dir hi hj with ⟨k, hk, ki, kj⟩\n    exact ⟨k, hk, (Set.prod_mono ki kj).trans hsub⟩\n  · rintro ⟨i, hi, h⟩\n    exact ⟨⟨i, i⟩, ⟨hi, hi⟩, h⟩\n#align has_basis.prod_same_index has_basis.prod_same_index\n\n",
 "prod_pprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem has_basis.prod_pprod (hla : la.has_basis pa sa) (hlb : lb.has_basis pb sb) :\n    (filter.prod la lb).has_basis (fun i : PProd ι ι' => pa i.1 ∧ pb i.2) fun i => finset.product (sa i.1) (sb i.2) :=\n  (hla.comap Prod.fst).inf' (hlb.comap Prod.snd)\n#align has_basis.prod_pprod has_basis.prod_pprod\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem has_antitone_basis.prod {ι : Type _} [linear_order ι] {f : Filter α} {g : Filter β} {s : ι → Set α}\n    {t : ι → Set β} (hf : HasAntitoneBasis f s) (hg : HasAntitoneBasis g t) :\n    HasAntitoneBasis (filter.prod f g) fun n => finset.product (s n) (t n) :=\n  ⟨hf.1.prod_same_index_anti hg.1 (hf.2.antitone_on _) (hg.2.antitone_on _), hf.2.set_prod hg.2⟩\n#align has_antitone_basis.prod has_antitone_basis.prod\n\n",
 "principal_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis.principal_inf (hl : l.has_basis p s) (s' : Set α) :\n    («expr ⊓ » ((filter.principal) s') l).has_basis p fun i => s' ∩ s i := by\n  simpa only [inf_comm, inter_comm] using hl.inf_principal s'\n#align has_basis.principal_inf has_basis.principal_inf\n\n",
 "of_sets_filter_eq_generate":
 "theorem of_sets_filter_eq_generate (s : Set (Set α)) : (FilterBasis.ofSets s).filter = generate s := by\n  rw [← (filter_basis.of_sets s).generate, generate_eq_generate_inter s] <;> rfl\n#align of_sets_filter_eq_generate of_sets_filter_eq_generate\n\n",
 "not_mem_iff_inf_principal_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem not_mem_iff_inf_principal_compl {f : Filter α} {s : Set α} :\n    s ∉ f ↔ NeBot («expr ⊓ » f ((filter.principal) («expr ᶜ» s))) :=\n  (not_congr mem_iff_inf_principal_compl).trans neBot_iff.symm\n#align not_mem_iff_inf_principal_compl not_mem_iff_inf_principal_compl\n\n",
 "nonempty":
 "protected theorem has_basis.nonempty (h : l.has_basis p s) : Nonempty ι :=\n  nonempty_of_exists h.ex_mem\n#align has_basis.nonempty has_basis.nonempty\n\n",
 "ne_bot_iff":
 "theorem has_basis.ne_bot_iff (hl : l.has_basis p s) : NeBot l ↔ ∀ {i}, p i → (s i).nonempty :=\n  forall_mem_nonempty_iff_neBot.symm.trans <| hl.forall_iff fun _ _ => Nonempty.mono\n#align has_basis.ne_bot_iff has_basis.ne_bot_iff\n\n",
 "mem_prod_self_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem mem_prod_self_iff {s} : s ∈ filter.prod la la ↔ ∃ t ∈ la, finset.product t t ⊆ s :=\n  la.basis_sets.prod_self.mem_iff\n#align mem_prod_self_iff mem_prod_self_iff\n\n",
 "mem_of_superset":
 "theorem has_basis.mem_of_superset (hl : l.has_basis p s) (hi : p i) (ht : s i ⊆ t) : t ∈ l :=\n  hl.mem_iff.2 ⟨i, hi, ht⟩\n#align has_basis.mem_of_superset has_basis.mem_of_superset\n\n",
 "mem_of_mem":
 "theorem has_basis.mem_of_mem (hl : l.has_basis p s) (hi : p i) : s i ∈ l :=\n  hl.mem_of_superset hi <| Subset.refl _\n#align has_basis.mem_of_mem has_basis.mem_of_mem\n\n",
 "mem_iff_inf_principal_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem mem_iff_inf_principal_compl {f : Filter α} {s : Set α} :\n    s ∈ f ↔ «expr ⊓ » f ((filter.principal) («expr ᶜ» s)) = «expr⊥» :=\n  by\n  refine' not_iff_not.1 ((inf_principal_ne_bot_iff.trans _).symm.trans ne_bot_iff)\n  exact\n    ⟨fun h hs => by simpa [not_nonempty_empty] using h s hs, fun hs t ht =>\n      inter_compl_nonempty_iff.2 fun hts => hs <| mem_of_superset ht hts⟩\n#align mem_iff_inf_principal_compl mem_iff_inf_principal_compl\n\n",
 "mem_iff":
 "protected theorem has_antitone_basis.mem_iff [preorder ι] {l : Filter α} {s : ι → Set α} (hs : l.has_antitone_basis s)\n    {t : Set α} : t ∈ l ↔ ∃ i, s i ⊆ t :=\n  hs.to_has_basis.mem_iff.trans <| by simp only [exists_prop, true_and_iff]\n#align has_antitone_basis.mem_iff has_antitone_basis.mem_iff\n\n",
 "mem_filter_of_mem":
 "theorem mem_filter_of_mem (B : FilterBasis α) {U : Set α} : U ∈ B → U ∈ B.filter := fun U_in => ⟨U, U_in, Subset.refl _⟩\n#align mem_filter_of_mem mem_filter_of_mem\n\n",
 "mem_filter_iff":
 "protected theorem mem_filter_iff (h : IsBasis p s) {U : Set α} : U ∈ h.filter ↔ ∃ i, p i ∧ s i ⊆ U :=\n  by\n  erw [h.filter_basis.mem_filter_iff]\n  simp only [mem_filter_basis_iff h, exists_prop]\n  constructor\n  · rintro ⟨_, ⟨i, pi, rfl⟩, h⟩\n    tauto\n  · tauto\n#align mem_filter_iff mem_filter_iff\n\n",
 "mem_filter_basis_iff":
 "/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov, Johannes Hölzl, Mario Carneiro, Patrick Massot\n-/\n-- For illustration purposes, the filter basis defining (at_top : filter ℕ)\ntheorem mem_filter_basis_iff {U : Set α} : U ∈ h.filter_basis ↔ ∃ i, p i ∧ s i = U :=\n  iff.rfl\n#align mem_filter_basis_iff mem_filter_basis_iff\n\n",
 "mem":
 "protected theorem has_antitone_basis.mem [preorder ι] {l : Filter α} {s : ι → Set α} (hs : l.has_antitone_basis s)\n    (i : ι) : s i ∈ l :=\n  hs.to_has_basis.mem_of_mem trivial\n#align has_antitone_basis.mem has_antitone_basis.mem\n\n",
 "map_sigma_mk_comap":
 "theorem map_sigma_mk_comap {π : α → Type _} {π' : β → Type _} {f : α → β} (hf : function.injective f)\n    (g : ∀ a, π a → π' (f a)) (a : α) (l : Filter (π' (f a))) :\n    map (sigma.mk a) (comap (g a) l) = comap (Sigma.map f g) (map (sigma.mk (f a)) l) :=\n  by\n  refine' (((basis_sets _).comap _).map _).eq_of_same_basis _\n  convert((basis_sets _).map _).comap _\n  ext1 s\n  apply image_sigma_mk_preimage_sigma_map hf\n#align map_sigma_mk_comap map_sigma_mk_comap\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem has_antitone_basis.map {l : Filter α} {s : ι'' → Set α} {m : α → β} (hf : HasAntitoneBasis l s) :\n    HasAntitoneBasis (map m l) fun n => «expr '' » m (s n) :=\n  ⟨HasBasis.map _ hf.to_has_basis, fun i j hij => image_subset _ <| hf.2 hij⟩\n#align has_antitone_basis.map has_antitone_basis.map\n\n",
 "le_iff_forall_inf_principal_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem le_iff_forall_inf_principal_compl {f g : Filter α} :\n    f ≤ g ↔ ∀ V ∈ g, «expr ⊓ » f ((filter.principal) («expr ᶜ» V)) = «expr⊥» :=\n  forall₂_congr fun _ _ => mem_iff_inf_principal_compl\n#align le_iff_forall_inf_principal_compl le_iff_forall_inf_principal_compl\n\n",
 "le_iff":
 "theorem has_basis.le_iff (hl : l.has_basis p s) : l ≤ l' ↔ ∀ t ∈ l', ∃ (i : _)(hi : p i), s i ⊆ t := by\n  simp only [le_def, hl.mem_iff]\n#align has_basis.le_iff has_basis.le_iff\n\n",
 "le_basis_iff":
 "theorem has_basis.le_basis_iff (hl : l.has_basis p s) (hl' : l'.has_basis p' s') :\n    l ≤ l' ↔ ∀ i', p' i' → ∃ (i : _)(hi : p i), s i ⊆ s' i' := by simp only [hl'.ge_iff, hl.mem_iff]\n#align has_basis.le_basis_iff has_basis.le_basis_iff\n\n",
 "is_countably_generated_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[instance]\ntheorem is_countably_generated_top : IsCountablyGenerated («expr⊤» : Filter α) :=\n  @principal_univ α ▸ isCountablyGenerated_principal _\n#align is_countably_generated_top is_countably_generated_top\n\n",
 "is_countably_generated_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_countably_generated_seq [Countable β] (x : β → Set α) :\n    IsCountablyGenerated\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (filter.principal <| x i)) :=\n  by\n  use range x, countable_range x\n  rw [generate_eq_binfi, infᵢ_range]\n#align is_countably_generated_seq is_countably_generated_seq\n\n",
 "is_countably_generated_pure":
 "@[instance]\ntheorem is_countably_generated_pure (a : α) : IsCountablyGenerated (pure a) :=\n  by\n  rw [← principal_singleton]\n  exact is_countably_generated_principal _\n#align is_countably_generated_pure is_countably_generated_pure\n\n",
 "is_countably_generated_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[instance]\ntheorem is_countably_generated_principal (s : Set α) : IsCountablyGenerated ((filter.principal) s) :=\n  isCountablyGenerated_of_seq ⟨fun _ => s, infᵢ_const.symm⟩\n#align is_countably_generated_principal is_countably_generated_principal\n\n",
 "is_countably_generated_of_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_countably_generated_of_seq {f : Filter α}\n    (h :\n      ∃ x : ℕ → Set α,\n        f =\n          «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (filter.principal <| x i)) :\n    f.is_countably_generated := by\n  let ⟨x, h⟩ := h\n  rw [h] <;> apply is_countably_generated_seq\n#align is_countably_generated_of_seq is_countably_generated_of_seq\n\n",
 "is_countably_generated_iff_exists_antitone_basis":
 "theorem is_countably_generated_iff_exists_antitone_basis {f : Filter α} :\n    IsCountablyGenerated f ↔ ∃ x : ℕ → Set α, f.has_antitone_basis x :=\n  by\n  constructor\n  · intro h\n    exact f.exists_antitone_basis\n  · rintro ⟨x, h⟩\n    rw [h.to_has_basis.eq_infi]\n    exact is_countably_generated_seq x\n#align is_countably_generated_iff_exists_antitone_basis is_countably_generated_iff_exists_antitone_basis\n\n",
 "is_countably_generated_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[instance]\ntheorem is_countably_generated_bot : IsCountablyGenerated («expr⊥» : Filter α) :=\n  @principal_empty α ▸ isCountablyGenerated_principal _\n#align is_countably_generated_bot is_countably_generated_bot\n\n",
 "is_countably_generated_binfi_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_countably_generated_binfi_principal {B : Set <| Set α} (h : B.countable) :\n    IsCountablyGenerated\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) s)) :=\n  isCountablyGenerated_of_seq (countable_binfᵢ_principal_eq_seq_infᵢ h)\n#align is_countably_generated_binfi_principal is_countably_generated_binfi_principal\n\n",
 "is_countably_generated":
 "-- For illustration purposes, the countable filter basis defining (at_top : filter ℕ)\ntheorem has_countable_basis.is_countably_generated {f : Filter α} {p : ι → Prop} {s : ι → Set α}\n    (h : f.has_countable_basis p s) : f.is_countably_generated :=\n  ⟨⟨{ t | ∃ i, p i ∧ s i = t }, h.countable.image s, h.to_has_basis.eq_generate⟩⟩\n#align has_countable_basis.is_countably_generated has_countable_basis.is_countably_generated\n\n",
 "is_basis":
 "theorem has_basis.is_basis (h : l.has_basis p s) : IsBasis p s :=\n  { nonempty :=\n      let ⟨i, hi, H⟩ := h.mem_iff.mp univ_mem\n      ⟨i, hi⟩\n    inter := fun i j hi hj => by simpa [h.mem_iff] using l.inter_sets (h.mem_of_mem hi) (h.mem_of_mem hj) }\n#align has_basis.is_basis has_basis.is_basis\n\n",
 "inf_principal_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem inf_principal_ne_bot_iff {s : Set α} : NeBot («expr ⊓ » l ((filter.principal) s)) ↔ ∀ U ∈ l, (U ∩ s).nonempty :=\n  l.basis_sets.inf_principal_ne_bot_iff\n#align inf_principal_ne_bot_iff inf_principal_ne_bot_iff\n\n",
 "inf_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis.inf_principal (hl : l.has_basis p s) (s' : Set α) :\n    («expr ⊓ » l ((filter.principal) s')).has_basis p fun i => s i ∩ s' :=\n  ⟨fun t => by simp only [mem_inf_principal, hl.mem_iff, subset_def, mem_set_of_eq, mem_inter_iff, and_imp]⟩\n#align has_basis.inf_principal has_basis.inf_principal\n\n",
 "inf_ne_bot_iff_frequently_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem inf_ne_bot_iff_frequently_right {f g : Filter α} :\n    NeBot («expr ⊓ » f g) ↔\n      ∀ {p : α → Prop},\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" g\n            (p x) →\n          «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n            (p x) :=\n  by\n  rw [inf_comm]\n  exact inf_ne_bot_iff_frequently_left\n#align inf_ne_bot_iff_frequently_right inf_ne_bot_iff_frequently_right\n\n",
 "inf_ne_bot_iff_frequently_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem inf_ne_bot_iff_frequently_left {f g : Filter α} :\n    NeBot («expr ⊓ » f g) ↔\n      ∀ {p : α → Prop},\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n            (p x) →\n          «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" g\n            (p x) :=\n  by simpa only [inf_ne_bot_iff, frequently_iff, exists_prop, and_comm']\n#align inf_ne_bot_iff_frequently_left inf_ne_bot_iff_frequently_left\n\n",
 "inf_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_ne_bot_iff : NeBot («expr ⊓ » l l') ↔ ∀ ⦃s : Set α⦄ (hs : s ∈ l) ⦃s'⦄ (hs' : s' ∈ l'), (s ∩ s').nonempty :=\n  l.basis_sets.inf_ne_bot_iff\n#align inf_ne_bot_iff inf_ne_bot_iff\n\n",
 "inf_basis_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem has_basis.inf_basis_ne_bot_iff (hl : l.has_basis p s) (hl' : l'.has_basis p' s') :\n    NeBot («expr ⊓ » l l') ↔ ∀ ⦃i⦄ (hi : p i) ⦃i'⦄ (hi' : p' i'), (s i ∩ s' i').nonempty :=\n  (hl.inf' hl').ne_bot_iff.trans <| by simp [@forall_swap _ ι']\n#align has_basis.inf_basis_ne_bot_iff has_basis.inf_basis_ne_bot_iff\n\n",
 "inf'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem has_basis.inf' (hl : l.has_basis p s) (hl' : l'.has_basis p' s') :\n    («expr ⊓ » l l').has_basis (fun i : PProd ι ι' => p i.1 ∧ p' i.2) fun i => s i.1 ∩ s' i.2 :=\n  ⟨by\n    intro t\n    constructor\n    · simp only [mem_inf_iff, exists_prop, hl.mem_iff, hl'.mem_iff]\n      rintro ⟨t, ⟨i, hi, ht⟩, t', ⟨i', hi', ht'⟩, rfl⟩\n      use ⟨i, i'⟩, ⟨hi, hi'⟩, inter_subset_inter ht ht'\n    · rintro ⟨⟨i, i'⟩, ⟨hi, hi'⟩, H⟩\n      exact mem_inf_of_inter (hl.mem_of_mem hi) (hl'.mem_of_mem hi') H⟩\n#align has_basis.inf' has_basis.inf'\n\n",
 "inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem has_basis.inf {ι ι' : Type _} {p : ι → Prop} {s : ι → Set α} {p' : ι' → Prop} {s' : ι' → Set α}\n    (hl : l.has_basis p s) (hl' : l'.has_basis p' s') :\n    («expr ⊓ » l l').has_basis (fun i : ι × ι' => p i.1 ∧ p' i.2) fun i => s i.1 ∩ s' i.2 :=\n  (hl.inf' hl').to_has_basis (fun i hi => ⟨⟨i.1, i.2⟩, hi, Subset.rfl⟩) fun i hi => ⟨⟨i.1, i.2⟩, hi, Subset.rfl⟩\n#align has_basis.inf has_basis.inf\n\n",
 "has_basis_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem has_basis_supr {ι : Sort _} {ι' : ι → Type _} {l : ι → Filter α} {p : ∀ i, ι' i → Prop} {s : ∀ i, ι' i → Set α}\n    (hl : ∀ i, (l i).has_basis (p i) (s i)) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (l i)).has_basis\n      (fun f : ∀ i, ι' i => ∀ i, p i (f i)) fun f : ∀ i, ι' i =>\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i (f i)) :=\n  hasBasis_iff.mpr fun t => by\n    simp only [has_basis_iff, (hl _).mem_iff, classical.skolem, forall_and, Union_subset_iff, mem_supr]\n#align has_basis_supr has_basis_supr\n\n",
 "has_basis_self_subset":
 "theorem has_basis.has_basis_self_subset {p : Set α → Prop} (h : l.has_basis (fun s => s ∈ l ∧ p s) id) {V : Set α}\n    (hV : V ∈ l) : l.has_basis (fun s => s ∈ l ∧ p s ∧ s ⊆ V) id := by\n  simpa only [and_assoc'] using h.restrict_subset hV\n#align has_basis.has_basis_self_subset has_basis.has_basis_self_subset\n\n",
 "has_basis_self":
 "theorem has_basis_self {l : Filter α} {P : Set α → Prop} :\n    HasBasis l (fun s => s ∈ l ∧ P s) id ↔ ∀ t ∈ l, ∃ r ∈ l, P r ∧ r ⊆ t :=\n  by\n  simp only [has_basis_iff, exists_prop, id, and_assoc']\n  exact forall_congr' fun s => ⟨fun h => h.1, fun h => ⟨h, fun ⟨t, hl, hP, hts⟩ => mem_of_superset hl hts⟩⟩\n#align has_basis_self has_basis_self\n\n",
 "has_basis_pure":
 "theorem has_basis_pure (x : α) : (pure x : Filter α).has_basis (fun i : Unit => True) fun i => {x} := by\n  simp only [← principal_singleton, has_basis_principal]\n#align has_basis_pure has_basis_pure\n\n",
 "has_basis_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis_principal (t : Set α) : ((filter.principal) t).has_basis (fun i : Unit => True) fun i => t :=\n  ⟨fun U => by simp⟩\n#align has_basis_principal has_basis_principal\n\n",
 "has_basis_infi_principal_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- If `s : ι → set α` is an indexed family of sets, then finite intersections of `s i` form a basis\nof `⨅ i, 𝓟 (s i)`.  -/\ntheorem has_basis_infi_principal_finite {ι : Type _} (s : ι → Set α) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          ((filter.principal) (s i))).has_basis\n      (fun t : Set ι => t.finite) fun t =>\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i) :=\n  by\n  refine' ⟨fun U => (mem_infi_finite _).trans _⟩\n  simp only [infi_principal_finset, mem_Union, mem_principal, exists_prop, exists_finite_iff_finset,\n    Finset.set_binterᵢ_coe]\n#align has_basis_infi_principal_finite has_basis_infi_principal_finite\n\n",
 "has_basis_infi_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis_infi_principal {s : ι → Set α} (h : Directed (· ≥ ·) s) [Nonempty ι] :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          ((filter.principal) (s i))).has_basis\n      (fun _ => True) s :=\n  ⟨by\n    refine' fun t =>\n      (mem_infi_of_directed (h.mono_comp _ _) t).trans <| by simp only [exists_prop, true_and_iff, mem_principal]\n    exact fun _ _ => principal_mono.2⟩\n#align has_basis_infi_principal has_basis_infi_principal\n\n",
 "has_basis_infi_of_directed'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem has_basis_infi_of_directed' {ι : Type _} {ι' : ι → Sort _} [Nonempty ι] {l : ι → Filter α}\n    (s : ∀ i, ι' i → Set α) (p : ∀ i, ι' i → Prop) (hl : ∀ i, (l i).has_basis (p i) (s i)) (h : Directed (· ≥ ·) l) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (l i)).has_basis\n      (fun ii' : Σi, ι' i => p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2 :=\n  by\n  refine' ⟨fun t => _⟩\n  rw [mem_infi_of_directed h, Sigma.exists]\n  exact exists_congr fun i => (hl i).mem_iff\n#align has_basis_infi_of_directed' has_basis_infi_of_directed'\n\n",
 "has_basis_infi_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem has_basis_infi_of_directed {ι : Type _} {ι' : Sort _} [Nonempty ι] {l : ι → Filter α} (s : ι → ι' → Set α)\n    (p : ι → ι' → Prop) (hl : ∀ i, (l i).has_basis (p i) (s i)) (h : Directed (· ≥ ·) l) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (l i)).has_basis\n      (fun ii' : ι × ι' => p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2 :=\n  by\n  refine' ⟨fun t => _⟩\n  rw [mem_infi_of_directed h, Prod.exists]\n  exact exists_congr fun i => (hl i).mem_iff\n#align has_basis_infi_of_directed has_basis_infi_of_directed\n\n",
 "has_basis_infi'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem has_basis_infi' {ι : Type _} {ι' : ι → Type _} {l : ι → Filter α} {p : ∀ i, ι' i → Prop} {s : ∀ i, ι' i → Set α}\n    (hl : ∀ i, (l i).has_basis (p i) (s i)) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (l i)).has_basis\n      (fun If : Set ι × ∀ i, ι' i => If.1.finite ∧ ∀ i ∈ If.1, p i (If.2 i)) fun If : Set ι × ∀ i, ι' i =>\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i (If.2 i)) :=\n  ⟨by\n    intro t\n    constructor\n    · simp only [mem_infi', (hl _).mem_iff]\n      rintro ⟨I, hI, V, hV, -, rfl, -⟩\n      choose u hu using hV\n      exact ⟨⟨I, u⟩, ⟨hI, fun i _ => (hu i).1⟩, Inter_mono fun i => Inter_mono fun hi => (hu i).2⟩\n    · rintro ⟨⟨I, f⟩, ⟨hI₁, hI₂⟩, hsub⟩\n      refine' mem_of_superset _ hsub\n      exact (bInter_mem hI₁).mpr fun i hi => mem_infi_of_mem i <| (hl i).mem_of_mem <| hI₂ _ hi⟩\n#align has_basis_infi' has_basis_infi'\n\n",
 "has_basis_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem has_basis_infi {ι : Type _} {ι' : ι → Type _} {l : ι → Filter α} {p : ∀ i, ι' i → Prop} {s : ∀ i, ι' i → Set α}\n    (hl : ∀ i, (l i).has_basis (p i) (s i)) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (l i)).has_basis\n      (fun If : ΣI : Set ι, ∀ i : I, ι' i => If.1.finite ∧ ∀ i : If.1, p i (If.2 i)) fun If =>\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i (If.2 i)) :=\n  by\n  refine' ⟨fun t => ⟨fun ht => _, _⟩⟩\n  · rcases(has_basis_infi' hl).mem_iff.mp ht with ⟨⟨I, f⟩, ⟨hI, hf⟩, hsub⟩\n    exact ⟨⟨I, fun i => f i⟩, ⟨hI, subtype.forall.mpr hf⟩, trans_rel_right _ (Inter_subtype _ _) hsub⟩\n  · rintro ⟨⟨I, f⟩, ⟨hI, hf⟩, hsub⟩\n    refine' mem_of_superset _ hsub\n    cases hI.nonempty_fintype\n    exact Inter_mem.2 fun i => mem_infi_of_mem i <| (hl i).mem_of_mem <| hf _\n#align has_basis_infi has_basis_infi\n\n",
 "has_basis_iff":
 "theorem has_basis_iff : l.has_basis p s ↔ ∀ t, t ∈ l ↔ ∃ (i : _)(hi : p i), s i ⊆ t :=\n  ⟨fun ⟨h⟩ => h, fun h => ⟨h⟩⟩\n#align has_basis_iff has_basis_iff\n\n",
 "has_basis_generate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\ntheorem has_basis_generate (s : Set (Set α)) :\n    (generate s).has_basis (fun t => Set.Finite t ∧ t ⊆ s) fun t => «expr⋂₀ » t :=\n  ⟨fun U => by simp only [mem_generate_iff, exists_prop, and_assoc, and_left_comm]⟩\n#align has_basis_generate has_basis_generate\n\n",
 "has_basis_ge":
 "theorem has_antitone_basis.has_basis_ge [preorder ι] [IsDirected ι (· ≤ ·)] {l : Filter α} {s : ι → Set α}\n    (hs : l.has_antitone_basis s) (i : ι) : l.has_basis (fun j => i ≤ j) s :=\n  hs.1.to_has_basis (fun j _ => (exists_ge_ge i j).imp fun k hk => ⟨hk.1, hs.2 hk.2⟩) fun j hj =>\n    ⟨j, trivial, Subset.rfl⟩\n#align has_antitone_basis.has_basis_ge has_antitone_basis.has_basis_ge\n\n",
 "has_basis_binfi_principal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis_binfi_principal' {ι : Type _} {p : ι → Prop} {s : ι → Set α}\n    (h : ∀ i, p i → ∀ j, p j → ∃ (k : _)(h : p k), s k ⊆ s i ∧ s k ⊆ s j) (ne : ∃ i, p i) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          ((filter.principal) (s i))).has_basis\n      p s :=\n  Filter.hasBasis_binfᵢ_principal h ne\n#align has_basis_binfi_principal' has_basis_binfi_principal'\n\n",
 "has_basis_binfi_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹'o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis_binfi_principal {s : β → Set α} {S : Set β} (h : DirectedOn («expr ⁻¹'o » s (· ≥ ·)) S)\n    (ne : S.nonempty) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          ((filter.principal) (s i))).has_basis\n      (fun i => i ∈ S) s :=\n  ⟨by\n    refine' fun t => (mem_binfi_of_directed _ ne).trans <| by simp only [mem_principal]\n    rw [directedOn_iff_directed, ← directed_comp, (· ∘ ·)] at h⊢\n    apply h.mono_comp _ _\n    exact fun _ _ => principal_mono.2⟩\n#align has_basis_binfi_principal has_basis_binfi_principal\n\n",
 "has_basis_binfi_of_directed'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹'o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem has_basis_binfi_of_directed' {ι : Type _} {ι' : ι → Sort _} {dom : Set ι} (hdom : dom.nonempty)\n    {l : ι → Filter α} (s : ∀ i, ι' i → Set α) (p : ∀ i, ι' i → Prop) (hl : ∀ i ∈ dom, (l i).has_basis (p i) (s i))\n    (h : DirectedOn («expr ⁻¹'o » l GE.ge) dom) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (l i)).has_basis\n      (fun ii' : Σi, ι' i => ii'.1 ∈ dom ∧ p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2 :=\n  by\n  refine' ⟨fun t => _⟩\n  rw [mem_binfi_of_directed h hdom, Sigma.exists]\n  refine' exists_congr fun i => ⟨_, _⟩\n  · rintro ⟨hi, hti⟩\n    rcases(hl i hi).mem_iff.mp hti with ⟨b, hb, hbt⟩\n    exact ⟨b, ⟨hi, hb⟩, hbt⟩\n  · rintro ⟨b, ⟨hi, hb⟩, hibt⟩\n    exact ⟨hi, (hl i hi).mem_iff.mpr ⟨b, hb, hibt⟩⟩\n#align has_basis_binfi_of_directed' has_basis_binfi_of_directed'\n\n",
 "has_basis_binfi_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹'o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem has_basis_binfi_of_directed {ι : Type _} {ι' : Sort _} {dom : Set ι} (hdom : dom.nonempty) {l : ι → Filter α}\n    (s : ι → ι' → Set α) (p : ι → ι' → Prop) (hl : ∀ i ∈ dom, (l i).has_basis (p i) (s i))\n    (h : DirectedOn («expr ⁻¹'o » l GE.ge) dom) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (l i)).has_basis\n      (fun ii' : ι × ι' => ii'.1 ∈ dom ∧ p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2 :=\n  by\n  refine' ⟨fun t => _⟩\n  rw [mem_binfi_of_directed h hdom, Prod.exists]\n  refine' exists_congr fun i => ⟨_, _⟩\n  · rintro ⟨hi, hti⟩\n    rcases(hl i hi).mem_iff.mp hti with ⟨b, hb, hbt⟩\n    exact ⟨b, ⟨hi, hb⟩, hbt⟩\n  · rintro ⟨b, ⟨hi, hb⟩, hibt⟩\n    exact ⟨hi, (hl i hi).mem_iff.mpr ⟨b, hb, hibt⟩⟩\n#align has_basis_binfi_of_directed has_basis_binfi_of_directed\n\n",
 "has_basis":
 "#print FilterBasis.hasBasis /-\nprotected theorem FilterBasis.hasBasis {α : Type _} (B : FilterBasis α) :\n    HasBasis B.filter (fun s : Set α => s ∈ B) id :=\n  ⟨fun t => B.mem_filter_iff⟩\n#align filter_basis.has_basis FilterBasis.hasBasis\n-/\n\n",
 "generate_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\ntheorem generate_ne_bot_iff {s : Set (Set α)} :\n    NeBot (generate s) ↔ ∀ (t) (_ : t ⊆ s), t.finite → («expr⋂₀ » t).nonempty :=\n  (hasBasis_generate s).ne_bot_iff.trans <| by simp only [← and_imp, and_comm']\n#align generate_ne_bot_iff generate_ne_bot_iff\n\n",
 "generate_eq_generate_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem generate_eq_generate_inter (s : Set (Set α)) :\n    generate s = generate («expr '' » interₛ { t | Set.Finite t ∧ t ⊆ s }) := by\n  erw [(filter_basis.of_sets s).generate, ← (has_basis_generate s).filter_eq] <;> rfl\n#align generate_eq_generate_inter generate_eq_generate_inter\n\n",
 "generate":
 "protected theorem generate (B : FilterBasis α) : generate B.sets = B.filter :=\n  by\n  apply le_antisymm\n  · intro U U_in\n    rcases B.mem_filter_iff.mp U_in with ⟨V, V_in, h⟩\n    exact generate_sets.superset (generate_sets.basic V_in) h\n  · rw [sets_iff_generate]\n    apply mem_filter_of_mem\n#align generate generate\n\n",
 "ge_iff":
 "theorem has_basis.ge_iff (hl' : l'.has_basis p' s') : l ≤ l' ↔ ∀ i', p' i' → s' i' ∈ l :=\n  ⟨fun h i' hi' => h <| hl'.mem_of_mem hi', fun h s hs =>\n    let ⟨i', hi', hs⟩ := hl'.mem_iff.1 hs\n    mem_of_superset (h _ hi') hs⟩\n#align has_basis.ge_iff has_basis.ge_iff\n\n",
 "frequently_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem has_basis.frequently_iff (hl : l.has_basis p s) {q : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l (q x) ↔\n      ∀ i, p i → ∃ x ∈ s i, q x :=\n  by simp [Filter.Frequently, hl.eventually_iff]\n#align has_basis.frequently_iff has_basis.frequently_iff\n\n",
 "forall_mem_mem":
 "theorem has_basis.forall_mem_mem (h : HasBasis l p s) {x : α} : (∀ t ∈ l, x ∈ t) ↔ ∀ i, p i → x ∈ s i :=\n  by\n  simp only [h.mem_iff, exists_imp]\n  exact ⟨fun h i hi => h (s i) i hi subset.rfl, fun h t i hi ht => ht (h i hi)⟩\n#align has_basis.forall_mem_mem has_basis.forall_mem_mem\n\n",
 "forall_iff":
 "theorem has_basis.forall_iff (hl : l.has_basis p s) {P : Set α → Prop} (mono : ∀ ⦃s t⦄, s ⊆ t → P s → P t) :\n    (∀ s ∈ l, P s) ↔ ∀ i, p i → P (s i) :=\n  ⟨fun H i hi => H (s i) <| hl.mem_of_mem hi, fun H s hs =>\n    let ⟨i, hi, his⟩ := hl.mem_iff.1 hs\n    mono his (H i hi)⟩\n#align has_basis.forall_iff has_basis.forall_iff\n\n",
 "filter_eq_generate":
 "theorem filter_eq_generate (h : IsBasis p s) : h.filter = generate { U | ∃ i, p i ∧ s i = U } := by\n  erw [h.filter_basis.generate] <;> rfl\n#align filter_eq_generate filter_eq_generate\n\n",
 "filter_eq":
 "theorem has_basis.filter_eq (h : l.has_basis p s) : h.is_basis.filter = l :=\n  by\n  ext U\n  simp [h.mem_iff, is_basis.mem_filter_iff]\n#align has_basis.filter_eq has_basis.filter_eq\n\n",
 "ext":
 "theorem has_basis.ext (hl : l.has_basis p s) (hl' : l'.has_basis p' s') (h : ∀ i, p i → ∃ i', p' i' ∧ s' i' ⊆ s i)\n    (h' : ∀ i', p' i' → ∃ i, p i ∧ s i ⊆ s' i') : l = l' :=\n  by\n  apply le_antisymm\n  · rw [hl.le_basis_iff hl']\n    simpa using h'\n  · rw [hl'.le_basis_iff hl]\n    simpa using h\n#align has_basis.ext has_basis.ext\n\n",
 "exists_mem_filter_basis_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n#print Pairwise.exists_mem_filter_basis_of_disjoint /-\ntheorem Pairwise.exists_mem_filter_basis_of_disjoint {I : Type _} [Finite I] {l : I → Filter α} {ι : I → Sort _}\n    {p : ∀ i, ι i → Prop} {s : ∀ i, ι i → Set α} (hd : Pairwise («expr on » Disjoint l))\n    (h : ∀ i, (l i).has_basis (p i) (s i)) :\n    ∃ ind : ∀ i, ι i, (∀ i, p i (ind i)) ∧ Pairwise («expr on » Disjoint fun i => s i (ind i)) :=\n  by\n  rcases hd.exists_mem_filter_of_disjoint with ⟨t, htl, hd⟩\n  choose ind hp ht using fun i => (h i).mem_iff.1 (htl i)\n  exact ⟨ind, hp, hd.mono fun i j hij => hij.mono (ht _) (ht _)⟩\n#align pairwise.exists_mem_filter_basis_of_disjoint Pairwise.exists_mem_filter_basis_of_disjoint\n-/\n\n",
 "exists_mem_filter_basis":
 "#print Set.PairwiseDisjoint.exists_mem_filter_basis /-\ntheorem Set.PairwiseDisjoint.exists_mem_filter_basis {I : Type _} {l : I → Filter α} {ι : I → Sort _}\n    {p : ∀ i, ι i → Prop} {s : ∀ i, ι i → Set α} {S : Set I} (hd : S.pairwise_disjoint l) (hS : S.finite)\n    (h : ∀ i, (l i).has_basis (p i) (s i)) :\n    ∃ ind : ∀ i, ι i, (∀ i, p i (ind i)) ∧ S.pairwise_disjoint fun i => s i (ind i) :=\n  by\n  rcases hd.exists_mem_filter hS with ⟨t, htl, hd⟩\n  choose ind hp ht using fun i => (h i).mem_iff.1 (htl i)\n  exact ⟨ind, hp, hd.mono ht⟩\n#align set.pairwise_disjoint.exists_mem_filter_basis Set.PairwiseDisjoint.exists_mem_filter_basis\n-/\n\n",
 "exists_iff":
 "theorem has_basis.exists_iff (hl : l.has_basis p s) {P : Set α → Prop} (mono : ∀ ⦃s t⦄, s ⊆ t → P t → P s) :\n    (∃ s ∈ l, P s) ↔ ∃ (i : _)(hi : p i), P (s i) :=\n  ⟨fun ⟨s, hs, hP⟩ =>\n    let ⟨i, hi, his⟩ := hl.mem_iff.1 hs\n    ⟨i, hi, mono his hP⟩,\n    fun ⟨i, hi, hP⟩ => ⟨s i, hl.mem_of_mem hi, hP⟩⟩\n#align has_basis.exists_iff has_basis.exists_iff\n\n",
 "exists_antitone_subbasis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/-- If `f` is countably generated and `f.has_basis p s`, then `f` admits a decreasing basis\nenumerated by natural numbers such that all sets have the form `s i`. More precisely, there is a\nsequence `i n` such that `p (i n)` for all `n` and `s (i n)` is a decreasing sequence of sets which\nforms a basis of `f`-/\ntheorem has_basis.exists_antitone_subbasis {f : Filter α} [h : f.is_countably_generated] {p : ι' → Prop}\n    {s : ι' → Set α} (hs : f.has_basis p s) : ∃ x : ℕ → ι', (∀ i, p (x i)) ∧ f.has_antitone_basis fun i => s (x i) :=\n  by\n  obtain ⟨x', hx'⟩ :\n    ∃ x : ℕ → Set α,\n      f =\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          ((filter.principal) (x i)) :=\n    by\n    rcases h with ⟨s, hsc, rfl⟩\n    rw [generate_eq_binfi]\n    exact countable_binfi_principal_eq_seq_infi hsc\n  have : ∀ i, x' i ∈ f := fun i => hx'.symm ▸ (infᵢ_le (fun i => (filter.principal) (x' i)) i) (mem_principal_self _)\n  let x : ℕ → { i : ι' // p i } := fun n =>\n    nat.rec_on n (hs.index _ <| this 0) fun n xn => hs.index _ <| inter_mem (this <| n + 1) (hs.mem_of_mem xn.2)\n  have x_mono : Antitone fun i => s (x i) :=\n    by\n    refine' antitone_nat_of_succ_le fun i => _\n    exact (hs.set_index_subset _).trans (inter_subset_right _ _)\n  have x_subset : ∀ i, s (x i) ⊆ x' i := by\n    rintro (_ | i)\n    exacts[hs.set_index_subset _, subset.trans (hs.set_index_subset _) (inter_subset_left _ _)]\n  refine' ⟨fun i => x i, fun i => (x i).2, _⟩\n  have :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          ((filter.principal) (s (x i)))).has_antitone_basis\n      fun i => s (x i) :=\n    ⟨has_basis_infi_principal (directed_of_sup x_mono), x_mono⟩\n  convert this\n  exact\n    le_antisymm (le_infᵢ fun i => le_principal_iff.2 <| by cases i <;> apply hs.set_index_mem)\n      (hx'.symm ▸ le_infᵢ fun i => le_principal_iff.2 <| this.to_has_basis.mem_iff.2 ⟨i, trivial, x_subset i⟩)\n#align has_basis.exists_antitone_subbasis has_basis.exists_antitone_subbasis\n\n",
 "exists_antitone_seq":
 "theorem exists_antitone_seq (f : Filter α) [f.is_countably_generated] :\n    ∃ x : ℕ → Set α, Antitone x ∧ ∀ {s}, s ∈ f ↔ ∃ i, x i ⊆ s :=\n  let ⟨x, hx⟩ := f.exists_antitone_basis\n  ⟨x, hx.antitone, fun s => by simp [hx.to_has_basis.mem_iff]⟩\n#align exists_antitone_seq exists_antitone_seq\n\n",
 "exists_antitone_basis":
 "/-- A countably generated filter admits a basis formed by an antitone sequence of sets. -/\ntheorem exists_antitone_basis (f : Filter α) [f.is_countably_generated] : ∃ x : ℕ → Set α, f.has_antitone_basis x :=\n  let ⟨x, hxf, hx⟩ := f.basis_sets.exists_antitone_subbasis\n  ⟨x, hx⟩\n#align exists_antitone_basis exists_antitone_basis\n\n",
 "ex_mem":
 "theorem has_basis.ex_mem (h : l.has_basis p s) : ∃ i, p i :=\n  let ⟨i, pi, h⟩ := h.mem_iff.mp univ_mem\n  ⟨i, pi⟩\n#align has_basis.ex_mem has_basis.ex_mem\n\n",
 "eventually_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem has_basis.eventually_iff (hl : l.has_basis p s) {q : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l (q x) ↔\n      ∃ i, p i ∧ ∀ ⦃x⦄, x ∈ s i → q x :=\n  by simpa using hl.mem_iff\n#align has_basis.eventually_iff has_basis.eventually_iff\n\n",
 "eq_of_same_basis":
 "theorem has_basis.eq_of_same_basis (hl : l.has_basis p s) (hl' : l'.has_basis p s) : l = l' :=\n  by\n  ext t\n  rw [hl.mem_iff, hl'.mem_iff]\n#align has_basis.eq_of_same_basis has_basis.eq_of_same_basis\n\n",
 "eq_infi_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem eq_infi_principal (B : FilterBasis α) :\n    B.filter =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) s) :=\n  by\n  have : Directed (· ≥ ·) fun s : B.sets => (filter.principal) (s : Set α) :=\n    by\n    rintro ⟨U, U_in⟩ ⟨V, V_in⟩\n    rcases B.inter_sets U_in V_in with ⟨W, W_in, W_sub⟩\n    use W, W_in\n    simp only [ge_iff_le, le_principal_iff, mem_principal, Subtype.coe_mk]\n    exact subset_inter_iff.mp W_sub\n  ext U\n  simp [mem_filter_iff, mem_infi_of_directed this]\n#align eq_infi_principal eq_infi_principal\n\n",
 "eq_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis.eq_infi (h : l.has_basis (fun _ => True) s) :\n    l =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (s i)) :=\n  by simpa only [infᵢ_true] using h.eq_binfi\n#align has_basis.eq_infi has_basis.eq_infi\n\n",
 "eq_generate":
 "theorem has_basis.eq_generate (h : l.has_basis p s) : l = generate { U | ∃ i, p i ∧ s i = U } := by\n  rw [← h.is_basis.filter_eq_generate, h.filter_eq]\n#align has_basis.eq_generate has_basis.eq_generate\n\n",
 "eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem has_basis.eq_bot_iff (hl : l.has_basis p s) : l = «expr⊥» ↔ ∃ i, p i ∧ s i = ∅ :=\n  not_iff_not.1 <|\n    neBot_iff.symm.trans <| hl.ne_bot_iff.trans <| by simp only [not_exists, not_and, nonempty_iff_ne_empty]\n#align has_basis.eq_bot_iff has_basis.eq_bot_iff\n\n",
 "eq_binfi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis.eq_binfi (h : l.has_basis p s) :\n    l =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (s i)) :=\n  eq_binfᵢ_of_mem_iff_exists_mem fun t => by simp only [h.mem_iff, mem_principal]\n#align has_basis.eq_binfi has_basis.eq_binfi\n\n",
 "disjoint_pure_pure":
 "@[simp]\ntheorem disjoint_pure_pure {x y : α} : Disjoint (pure x : Filter α) (pure y) ↔ x ≠ y := by\n  simp only [← principal_singleton, disjoint_principal_principal, disjoint_singleton]\n#align disjoint_pure_pure disjoint_pure_pure\n\n",
 "disjoint_principal_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem disjoint_principal_right {f : Filter α} {s : Set α} : Disjoint f ((filter.principal) s) ↔ «expr ᶜ» s ∈ f := by\n  rw [mem_iff_inf_principal_compl, compl_compl, disjoint_iff]\n#align disjoint_principal_right disjoint_principal_right\n\n",
 "disjoint_principal_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem disjoint_principal_principal {s t : Set α} :\n    Disjoint ((filter.principal) s) ((filter.principal) t) ↔ Disjoint s t := by simp [← subset_compl_iff_disjoint_left]\n#align disjoint_principal_principal disjoint_principal_principal\n\n",
 "disjoint_principal_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem disjoint_principal_left {f : Filter α} {s : Set α} : Disjoint ((filter.principal) s) f ↔ «expr ᶜ» s ∈ f := by\n  rw [disjoint_comm, disjoint_principal_right]\n#align disjoint_principal_left disjoint_principal_left\n\n",
 "disjoint_iff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem has_basis.disjoint_iff_right (h : l.has_basis p s) : Disjoint l' l ↔ ∃ (i : _)(hi : p i), «expr ᶜ» (s i) ∈ l' :=\n  disjoint_comm.trans h.disjoint_iff_left\n#align has_basis.disjoint_iff_right has_basis.disjoint_iff_right\n\n",
 "disjoint_iff_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem has_basis.disjoint_iff_left (h : l.has_basis p s) : Disjoint l l' ↔ ∃ (i : _)(hi : p i), «expr ᶜ» (s i) ∈ l' :=\n  by\n  simp only [h.disjoint_iff l'.basis_sets, exists_prop, id, ← disjoint_principal_left,\n    (has_basis_principal _).disjoint_iff l'.basis_sets, Unique.exists_iff]\n#align has_basis.disjoint_iff_left has_basis.disjoint_iff_left\n\n",
 "disjoint_iff":
 "theorem has_basis.disjoint_iff (hl : l.has_basis p s) (hl' : l'.has_basis p' s') :\n    Disjoint l l' ↔ ∃ (i : _)(hi : p i)(i' : _)(hi' : p' i'), Disjoint (s i) (s' i') :=\n  not_iff_not.mp <| by\n    simp only [disjoint_iff, ← ne.def, ← ne_bot_iff, hl.inf_basis_ne_bot_iff hl', not_exists, bot_eq_empty, ←\n      nonempty_iff_ne_empty, inf_eq_inter]\n#align has_basis.disjoint_iff has_basis.disjoint_iff\n\n",
 "countable_binfi_principal_eq_seq_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem countable_binfi_principal_eq_seq_infi {B : Set (Set α)} (Bcbl : B.countable) :\n    ∃ x : ℕ → Set α,\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          ((filter.principal) t) =\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          ((filter.principal) (x i)) :=\n  countable_binfᵢ_eq_infᵢ_seq' Bcbl (filter.principal) principal_univ\n#align countable_binfi_principal_eq_seq_infi countable_binfi_principal_eq_seq_infi\n\n",
 "countable_binfi_eq_infi_seq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem countable_binfi_eq_infi_seq' [CompleteLattice α] {B : Set ι} (Bcbl : B.countable) (f : ι → α) {i₀ : ι}\n    (h : f i₀ = «expr⊤») :\n    ∃ x : ℕ → ι,\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f t) =\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f (x i)) :=\n  by\n  cases' B.eq_empty_or_nonempty with hB Bnonempty\n  · rw [hB, infᵢ_emptyset]\n    use fun n => i₀\n    simp [h]\n  · exact countable_binfi_eq_infi_seq Bcbl Bnonempty f\n#align countable_binfi_eq_infi_seq' countable_binfi_eq_infi_seq'\n\n",
 "countable_binfi_eq_infi_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem countable_binfi_eq_infi_seq [CompleteLattice α] {B : Set ι} (Bcbl : B.countable) (Bne : B.nonempty)\n    (f : ι → α) :\n    ∃ x : ℕ → ι,\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f t) =\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f (x i)) :=\n  let ⟨g, hg⟩ := Bcbl.exists_eq_range Bne\n  ⟨g, hg.symm ▸ infᵢ_range⟩\n#align countable_binfi_eq_infi_seq countable_binfi_eq_infi_seq\n\n",
 "coprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem has_basis.coprod {ι ι' : Type _} {pa : ι → Prop} {sa : ι → Set α} {pb : ι' → Prop} {sb : ι' → Set β}\n    (hla : la.has_basis pa sa) (hlb : lb.has_basis pb sb) :\n    (la.coprod lb).has_basis (fun i : ι × ι' => pa i.1 ∧ pb i.2) fun i =>\n      «expr ⁻¹' » Prod.fst (sa i.1) ∪ «expr ⁻¹' » Prod.snd (sb i.2) :=\n  (hla.comap Prod.fst).sup (hlb.comap Prod.snd)\n#align has_basis.coprod has_basis.coprod\n\n",
 "compl_diagonal_mem_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n@[simp]\ntheorem compl_diagonal_mem_prod {l₁ l₂ : Filter α} : «expr ᶜ» (diagonal α) ∈ filter.prod l₁ l₂ ↔ Disjoint l₁ l₂ := by\n  simp only [mem_prod_iff, Filter.disjoint_iff, prod_subset_compl_diagonal_iff_disjoint]\n#align compl_diagonal_mem_prod compl_diagonal_mem_prod\n\n",
 "comp_surjective":
 "theorem has_basis.comp_surjective (h : l.has_basis p s) {g : ι' → ι} (hg : function.surjective g) :\n    l.has_basis (p ∘ g) (s ∘ g) :=\n  ⟨fun t => h.mem_iff.trans hg.exists⟩\n#align has_basis.comp_surjective has_basis.comp_surjective\n\n",
 "comp_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem has_basis.comp_equiv (h : l.has_basis p s) (e : «expr ≃ » ι' ι) : l.has_basis (p ∘ e) (s ∘ e) :=\n  h.comp_surjective e.surjective\n#align has_basis.comp_equiv has_basis.comp_equiv\n\n",
 "comap_has_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem comap_has_basis (f : α → β) (l : Filter β) :\n    HasBasis (comap f l) (fun s : Set β => s ∈ l) fun s => «expr ⁻¹' » f s :=\n  ⟨fun t => mem_comap⟩\n#align comap_has_basis comap_has_basis\n\n",
 "comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem has_basis.comap (f : β → α) (hl : l.has_basis p s) : (l.comap f).has_basis p fun i => «expr ⁻¹' » f (s i) :=\n  ⟨by\n    intro t\n    simp only [mem_comap, exists_prop, hl.mem_iff]\n    constructor\n    · rintro ⟨t', ⟨i, hi, ht'⟩, H⟩\n      exact ⟨i, hi, subset.trans (preimage_mono ht') H⟩\n    · rintro ⟨i, hi, H⟩\n      exact ⟨s i, ⟨i, hi, subset.refl _⟩, H⟩⟩\n#align has_basis.comap has_basis.comap\n\n",
 "binfi_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\nprotected theorem has_basis.binfi_mem [CompleteLattice β] {f : Set α → β} (h : HasBasis l p s) (hf : Monotone f) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f t) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f (s i)) :=\n  le_antisymm (le_infᵢ₂ fun i hi => infᵢ₂_le (s i) (h.mem_of_mem hi)) <|\n    le_infᵢ₂ fun t ht =>\n      let ⟨i, hpi, hi⟩ := h.mem_iff.1 ht\n      infᵢ₂_le_of_le i hpi (hf hi)\n#align has_basis.binfi_mem has_basis.binfi_mem\n\n",
 "basis_sets":
 "theorem basis_sets (l : Filter α) : l.has_basis (fun s : Set α => s ∈ l) id :=\n  ⟨fun t => exists_mem_subset_iff.symm⟩\n#align basis_sets basis_sets\n\n",
 "basis_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.basis_right (H : Tendsto f la lb) (hlb : lb.has_basis pb sb) :\n    ∀ (i) (hi : pb i),\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" la\n        (f x ∈ sb i) :=\n  hlb.tendsto_right_iff.1 H\n#align tendsto.basis_right tendsto.basis_right\n\n",
 "basis_left":
 "theorem tendsto.basis_left (H : Tendsto f la lb) (hla : la.has_basis pa sa) :\n    ∀ t ∈ lb, ∃ (i : _)(hi : pa i), MapsTo f (sa i) t :=\n  hla.tendsto_left_iff.1 H\n#align tendsto.basis_left tendsto.basis_left\n\n",
 "basis_both":
 "theorem tendsto.basis_both (H : Tendsto f la lb) (hla : la.has_basis pa sa) (hlb : lb.has_basis pb sb) :\n    ∀ (ib) (hib : pb ib), ∃ (ia : _)(hia : pa ia), ∀ x ∈ sa ia, f x ∈ sb ib :=\n  (hla.tendsto_iff hlb).1 H\n#align tendsto.basis_both tendsto.basis_both\n\n",
 "bInter_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\nprotected theorem has_basis.bInter_mem {f : Set α → Set β} (h : HasBasis l p s) (hf : Monotone f) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f t) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f (s i)) :=\n  h.binfi_mem hf\n#align has_basis.bInter_mem has_basis.bInter_mem\n\n",
 "as_basis_filter":
 "theorem as_basis_filter (f : Filter α) : f.as_basis.filter = f := by ext t <;> exact exists_mem_subset_iff\n#align as_basis_filter as_basis_filter\n\n",
 "antitone_seq_of_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem antitone_seq_of_seq (s : ℕ → Set α) :\n    ∃ t : ℕ → Set α,\n      Antitone t ∧\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (filter.principal <| s i) =\n          «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            ((filter.principal) (t i)) :=\n  by\n  use fun n => «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s m);\n  constructor\n  · exact fun i j hij => bInter_mono (Iic_subset_Iic.2 hij) fun n hn => subset.refl _\n  apply le_antisymm <;> rw [le_infᵢ_iff] <;> intro i\n  · rw [le_principal_iff]\n    refine' (bInter_mem (finite_le_nat _)).2 fun j hji => _\n    rw [← le_principal_iff]\n    apply infᵢ_le_of_le j _\n    exact le_rfl\n  · apply infᵢ_le_of_le i _\n    rw [principal_mono]\n    intro a\n    simp\n    intro h\n    apply h\n    rfl\n#align antitone_seq_of_seq antitone_seq_of_seq\n\n"}