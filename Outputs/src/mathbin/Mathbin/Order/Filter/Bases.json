{"to_subset":
 "theorem has_basis.to_subset (hl : l.has_basis p s) {t : Î¹ â†’ Set Î±} (h : âˆ€ i, p i â†’ t i âŠ† s i)\n    (ht : âˆ€ i, p i â†’ t i âˆˆ l) : l.has_basis p t :=\n  hl.to_has_basis' (fun i hi => âŸ¨i, hi, h i hiâŸ©) ht\n#align has_basis.to_subset has_basis.to_subset\n\n",
 "to_has_basis'":
 "theorem has_basis.to_has_basis' (hl : l.has_basis p s) (h : âˆ€ i, p i â†’ âˆƒ i', p' i' âˆ§ s' i' âŠ† s i)\n    (h' : âˆ€ i', p' i' â†’ s' i' âˆˆ l) : l.has_basis p' s' :=\n  by\n  refine' âŸ¨fun t => âŸ¨fun ht => _, fun âŸ¨i', hi', htâŸ© => mem_of_superset (h' i' hi') htâŸ©âŸ©\n  rcases hl.mem_iff.1 ht with âŸ¨i, hi, htâŸ©\n  rcases h i hi with âŸ¨i', hi', hs'sâŸ©\n  exact âŸ¨i', hi', subset.trans hs's htâŸ©\n#align has_basis.to_has_basis' has_basis.to_has_basis'\n\n",
 "to_has_basis":
 "theorem has_basis.to_has_basis (hl : l.has_basis p s) (h : âˆ€ i, p i â†’ âˆƒ i', p' i' âˆ§ s' i' âŠ† s i)\n    (h' : âˆ€ i', p' i' â†’ âˆƒ i, p i âˆ§ s i âŠ† s' i') : l.has_basis p' s' :=\n  hl.to_has_basis' h fun i' hi' =>\n    let âŸ¨i, hi, hss'âŸ© := h' i' hi'\n    hl.mem_iff.2 âŸ¨i, hi, hss'âŸ©\n#align has_basis.to_has_basis has_basis.to_has_basis\n\n",
 "tendsto_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\ntheorem has_basis.tendsto_right_iff (hlb : lb.has_basis pb sb) :\n    Tendsto f la lb â†”\n      âˆ€ (i) (hi : pb i),\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" la\n          (f x âˆˆ sb i) :=\n  by simpa only [tendsto, hlb.ge_iff, mem_map, Filter.Eventually]\n#align has_basis.tendsto_right_iff has_basis.tendsto_right_iff\n\n",
 "tendsto_left_iff":
 "theorem has_basis.tendsto_left_iff (hla : la.has_basis pa sa) :\n    Tendsto f la lb â†” âˆ€ t âˆˆ lb, âˆƒ (i : _)(hi : pa i), MapsTo f (sa i) t :=\n  by\n  simp only [tendsto, (hla.map f).le_iff, image_subset_iff]\n  rfl\n#align has_basis.tendsto_left_iff has_basis.tendsto_left_iff\n\n",
 "tendsto_iff":
 "theorem has_basis.tendsto_iff (hla : la.has_basis pa sa) (hlb : lb.has_basis pb sb) :\n    Tendsto f la lb â†” âˆ€ (ib) (hib : pb ib), âˆƒ (ia : _)(hia : pa ia), âˆ€ x âˆˆ sa ia, f x âˆˆ sb ib := by\n  simp [hlb.tendsto_right_iff, hla.eventually_iff]\n#align has_basis.tendsto_iff has_basis.tendsto_iff\n\n",
 "sup_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\ntheorem has_basis.sup_pure (hl : l.has_basis p s) (x : Î±) : (Â«expr âŠ” Â» l (pure x)).has_basis p fun i => s i âˆª {x} := by\n  simp only [â† principal_singleton, hl.sup_principal]\n#align has_basis.sup_pure has_basis.sup_pure\n\n",
 "sup_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis.sup_principal (hl : l.has_basis p s) (t : Set Î±) :\n    (Â«expr âŠ” Â» l ((filter.principal) t)).has_basis p fun i => s i âˆª t :=\n  âŸ¨fun u => by\n    simp only [(hl.sup' (has_basis_principal t)).mem_iff, PProd.exists, exists_prop, and_true_iff, Unique.exists_iff]âŸ©\n#align has_basis.sup_principal has_basis.sup_principal\n\n",
 "sup'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\ntheorem has_basis.sup' (hl : l.has_basis p s) (hl' : l'.has_basis p' s') :\n    (Â«expr âŠ” Â» l l').has_basis (fun i : PProd Î¹ Î¹' => p i.1 âˆ§ p' i.2) fun i => s i.1 âˆª s' i.2 :=\n  âŸ¨by\n    intro t\n    simp only [mem_sup, hl.mem_iff, hl'.mem_iff, PProd.exists, union_subset_iff, exists_prop, and_assoc',\n      exists_and_left]\n    simp only [â† and_assoc', exists_and_right, and_comm']âŸ©\n#align has_basis.sup' has_basis.sup'\n\n",
 "sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\ntheorem has_basis.sup {Î¹ Î¹' : Type _} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {p' : Î¹' â†’ Prop} {s' : Î¹' â†’ Set Î±}\n    (hl : l.has_basis p s) (hl' : l'.has_basis p' s') :\n    (Â«expr âŠ” Â» l l').has_basis (fun i : Î¹ Ã— Î¹' => p i.1 âˆ§ p' i.2) fun i => s i.1 âˆª s' i.2 :=\n  (hl.sup' hl').to_has_basis (fun i hi => âŸ¨âŸ¨i.1, i.2âŸ©, hi, Subset.rflâŸ©) fun i hi => âŸ¨âŸ¨i.1, i.2âŸ©, hi, Subset.rflâŸ©\n#align has_basis.sup has_basis.sup\n\n",
 "set_index_subset":
 "theorem has_basis.set_index_subset (h : l.has_basis p s) (ht : t âˆˆ l) : s (h.index t ht) âŠ† t :=\n  (h.mem_iff.1 ht).some_spec.snd\n#align has_basis.set_index_subset has_basis.set_index_subset\n\n",
 "set_index_mem":
 "theorem has_basis.set_index_mem (h : l.has_basis p s) (ht : t âˆˆ l) : s (h.index t ht) âˆˆ l :=\n  h.mem_of_mem <| h.property_index _\n#align has_basis.set_index_mem has_basis.set_index_mem\n\n",
 "sInter_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚â‚€ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem has_basis.sInter_sets (h : HasBasis l p s) :\n    Â«exprâ‹‚â‚€ Â» l.sets =\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (s i) :=\n  by\n  rw [sInter_eq_bInter]\n  exact h.bInter_mem monotone_id\n#align has_basis.sInter_sets has_basis.sInter_sets\n\n",
 "restrict_subset":
 "/-- If `{s i | p i}` is a basis of a filter `l` and `V âˆˆ l`, then `{s i | p i âˆ§ s i âŠ† V}`\nis a basis of `l`. -/\ntheorem has_basis.restrict_subset (h : l.has_basis p s) {V : Set Î±} (hV : V âˆˆ l) :\n    l.has_basis (fun i => p i âˆ§ s i âŠ† V) s :=\n  h.restrict fun i hi =>\n    (h.mem_iff.1 (inter_mem hV (h.mem_of_mem hi))).imp fun j hj => âŸ¨hj.fst, subset_inter_iff.1 hj.sndâŸ©\n#align has_basis.restrict_subset has_basis.restrict_subset\n\n",
 "restrict":
 "/-- If `{s i | p i}` is a basis of a filter `l` and each `s i` includes `s j` such that\n`p j âˆ§ q j`, then `{s j | p j âˆ§ q j}` is a basis of `l`. -/\ntheorem has_basis.restrict (h : l.has_basis p s) {q : Î¹ â†’ Prop} (hq : âˆ€ i, p i â†’ âˆƒ j, p j âˆ§ q j âˆ§ s j âŠ† s i) :\n    l.has_basis (fun i => p i âˆ§ q i) s :=\n  by\n  refine' âŸ¨fun t => âŸ¨fun ht => _, fun âŸ¨i, hpi, htiâŸ© => h.mem_iff.2 âŸ¨i, hpi.1, htiâŸ©âŸ©âŸ©\n  rcases h.mem_iff.1 ht with âŸ¨i, hpi, htiâŸ©\n  rcases hq i hpi with âŸ¨j, hpj, hqj, hjiâŸ©\n  exact âŸ¨j, âŸ¨hpj, hqjâŸ©, subset.trans hji htiâŸ©\n#align has_basis.restrict has_basis.restrict\n\n",
 "property_index":
 "theorem has_basis.property_index (h : l.has_basis p s) (ht : t âˆˆ l) : p (h.index t ht) :=\n  (h.index t ht).2\n#align has_basis.property_index has_basis.property_index\n\n",
 "prod_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem has_basis.prod_self (hl : la.has_basis pa sa) :\n    (filter.prod la la).has_basis pa fun i => finset.product (sa i) (sa i) :=\n  hl.prod_same_index hl fun i j hi hj => by\n    simpa only [exists_prop, subset_inter_iff] using hl.mem_iff.1 (inter_mem (hl.mem_of_mem hi) (hl.mem_of_mem hj))\n#align has_basis.prod_self has_basis.prod_self\n\n",
 "prod_same_index_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem has_basis.prod_same_index_mono {Î¹ : Type _} [linear_order Î¹] {p : Î¹ â†’ Prop} {sa : Î¹ â†’ Set Î±} {sb : Î¹ â†’ Set Î²}\n    (hla : la.has_basis p sa) (hlb : lb.has_basis p sb) (hsa : MonotoneOn sa { i | p i })\n    (hsb : MonotoneOn sb { i | p i }) : (filter.prod la lb).has_basis p fun i => finset.product (sa i) (sb i) :=\n  hla.prod_same_index hlb fun i j hi hj =>\n    have : p (min i j) := min_rec' _ hi hj\n    âŸ¨min i j, this, hsa this hi <| min_le_left _ _, hsb this hj <| min_le_right _ _âŸ©\n#align has_basis.prod_same_index_mono has_basis.prod_same_index_mono\n\n",
 "prod_same_index_anti":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem has_basis.prod_same_index_anti {Î¹ : Type _} [linear_order Î¹] {p : Î¹ â†’ Prop} {sa : Î¹ â†’ Set Î±} {sb : Î¹ â†’ Set Î²}\n    (hla : la.has_basis p sa) (hlb : lb.has_basis p sb) (hsa : AntitoneOn sa { i | p i })\n    (hsb : AntitoneOn sb { i | p i }) : (filter.prod la lb).has_basis p fun i => finset.product (sa i) (sb i) :=\n  @HasBasis.prod_same_index_mono _ _ _ _ (Â«expr áµ’áµˆÂ» Î¹) _ _ _ _ hla hlb hsa.dual_left hsb.dual_left\n#align has_basis.prod_same_index_anti has_basis.prod_same_index_anti\n\n",
 "prod_same_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem has_basis.prod_same_index {p : Î¹ â†’ Prop} {sb : Î¹ â†’ Set Î²} (hla : la.has_basis p sa) (hlb : lb.has_basis p sb)\n    (h_dir : âˆ€ {i j}, p i â†’ p j â†’ âˆƒ k, p k âˆ§ sa k âŠ† sa i âˆ§ sb k âŠ† sb j) :\n    (filter.prod la lb).has_basis p fun i => finset.product (sa i) (sb i) :=\n  by\n  simp only [has_basis_iff, (hla.prod_pprod hlb).mem_iff]\n  refine' fun t => âŸ¨_, _âŸ©\n  Â· rintro âŸ¨âŸ¨i, jâŸ©, âŸ¨hi, hjâŸ©, hsub : finset.product (sa i) (sb j) âŠ† tâŸ©\n    rcases h_dir hi hj with âŸ¨k, hk, ki, kjâŸ©\n    exact âŸ¨k, hk, (Set.prod_mono ki kj).trans hsubâŸ©\n  Â· rintro âŸ¨i, hi, hâŸ©\n    exact âŸ¨âŸ¨i, iâŸ©, âŸ¨hi, hiâŸ©, hâŸ©\n#align has_basis.prod_same_index has_basis.prod_same_index\n\n",
 "prod_pprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem has_basis.prod_pprod (hla : la.has_basis pa sa) (hlb : lb.has_basis pb sb) :\n    (filter.prod la lb).has_basis (fun i : PProd Î¹ Î¹' => pa i.1 âˆ§ pb i.2) fun i => finset.product (sa i.1) (sb i.2) :=\n  (hla.comap Prod.fst).inf' (hlb.comap Prod.snd)\n#align has_basis.prod_pprod has_basis.prod_pprod\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem has_antitone_basis.prod {Î¹ : Type _} [linear_order Î¹] {f : Filter Î±} {g : Filter Î²} {s : Î¹ â†’ Set Î±}\n    {t : Î¹ â†’ Set Î²} (hf : HasAntitoneBasis f s) (hg : HasAntitoneBasis g t) :\n    HasAntitoneBasis (filter.prod f g) fun n => finset.product (s n) (t n) :=\n  âŸ¨hf.1.prod_same_index_anti hg.1 (hf.2.antitone_on _) (hg.2.antitone_on _), hf.2.set_prod hg.2âŸ©\n#align has_antitone_basis.prod has_antitone_basis.prod\n\n",
 "principal_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis.principal_inf (hl : l.has_basis p s) (s' : Set Î±) :\n    (Â«expr âŠ“ Â» ((filter.principal) s') l).has_basis p fun i => s' âˆ© s i := by\n  simpa only [inf_comm, inter_comm] using hl.inf_principal s'\n#align has_basis.principal_inf has_basis.principal_inf\n\n",
 "of_sets_filter_eq_generate":
 "theorem of_sets_filter_eq_generate (s : Set (Set Î±)) : (FilterBasis.ofSets s).filter = generate s := by\n  rw [â† (filter_basis.of_sets s).generate, generate_eq_generate_inter s] <;> rfl\n#align of_sets_filter_eq_generate of_sets_filter_eq_generate\n\n",
 "not_mem_iff_inf_principal_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem not_mem_iff_inf_principal_compl {f : Filter Î±} {s : Set Î±} :\n    s âˆ‰ f â†” NeBot (Â«expr âŠ“ Â» f ((filter.principal) (Â«expr á¶œÂ» s))) :=\n  (not_congr mem_iff_inf_principal_compl).trans neBot_iff.symm\n#align not_mem_iff_inf_principal_compl not_mem_iff_inf_principal_compl\n\n",
 "nonempty":
 "protected theorem has_basis.nonempty (h : l.has_basis p s) : Nonempty Î¹ :=\n  nonempty_of_exists h.ex_mem\n#align has_basis.nonempty has_basis.nonempty\n\n",
 "ne_bot_iff":
 "theorem has_basis.ne_bot_iff (hl : l.has_basis p s) : NeBot l â†” âˆ€ {i}, p i â†’ (s i).nonempty :=\n  forall_mem_nonempty_iff_neBot.symm.trans <| hl.forall_iff fun _ _ => Nonempty.mono\n#align has_basis.ne_bot_iff has_basis.ne_bot_iff\n\n",
 "mem_prod_self_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem mem_prod_self_iff {s} : s âˆˆ filter.prod la la â†” âˆƒ t âˆˆ la, finset.product t t âŠ† s :=\n  la.basis_sets.prod_self.mem_iff\n#align mem_prod_self_iff mem_prod_self_iff\n\n",
 "mem_of_superset":
 "theorem has_basis.mem_of_superset (hl : l.has_basis p s) (hi : p i) (ht : s i âŠ† t) : t âˆˆ l :=\n  hl.mem_iff.2 âŸ¨i, hi, htâŸ©\n#align has_basis.mem_of_superset has_basis.mem_of_superset\n\n",
 "mem_of_mem":
 "theorem has_basis.mem_of_mem (hl : l.has_basis p s) (hi : p i) : s i âˆˆ l :=\n  hl.mem_of_superset hi <| Subset.refl _\n#align has_basis.mem_of_mem has_basis.mem_of_mem\n\n",
 "mem_iff_inf_principal_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem mem_iff_inf_principal_compl {f : Filter Î±} {s : Set Î±} :\n    s âˆˆ f â†” Â«expr âŠ“ Â» f ((filter.principal) (Â«expr á¶œÂ» s)) = Â«exprâŠ¥Â» :=\n  by\n  refine' not_iff_not.1 ((inf_principal_ne_bot_iff.trans _).symm.trans ne_bot_iff)\n  exact\n    âŸ¨fun h hs => by simpa [not_nonempty_empty] using h s hs, fun hs t ht =>\n      inter_compl_nonempty_iff.2 fun hts => hs <| mem_of_superset ht htsâŸ©\n#align mem_iff_inf_principal_compl mem_iff_inf_principal_compl\n\n",
 "mem_iff":
 "protected theorem has_antitone_basis.mem_iff [preorder Î¹] {l : Filter Î±} {s : Î¹ â†’ Set Î±} (hs : l.has_antitone_basis s)\n    {t : Set Î±} : t âˆˆ l â†” âˆƒ i, s i âŠ† t :=\n  hs.to_has_basis.mem_iff.trans <| by simp only [exists_prop, true_and_iff]\n#align has_antitone_basis.mem_iff has_antitone_basis.mem_iff\n\n",
 "mem_filter_of_mem":
 "theorem mem_filter_of_mem (B : FilterBasis Î±) {U : Set Î±} : U âˆˆ B â†’ U âˆˆ B.filter := fun U_in => âŸ¨U, U_in, Subset.refl _âŸ©\n#align mem_filter_of_mem mem_filter_of_mem\n\n",
 "mem_filter_iff":
 "protected theorem mem_filter_iff (h : IsBasis p s) {U : Set Î±} : U âˆˆ h.filter â†” âˆƒ i, p i âˆ§ s i âŠ† U :=\n  by\n  erw [h.filter_basis.mem_filter_iff]\n  simp only [mem_filter_basis_iff h, exists_prop]\n  constructor\n  Â· rintro âŸ¨_, âŸ¨i, pi, rflâŸ©, hâŸ©\n    tauto\n  Â· tauto\n#align mem_filter_iff mem_filter_iff\n\n",
 "mem_filter_basis_iff":
 "/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov, Johannes HÃ¶lzl, Mario Carneiro, Patrick Massot\n-/\n-- For illustration purposes, the filter basis defining (at_top : filter â„•)\ntheorem mem_filter_basis_iff {U : Set Î±} : U âˆˆ h.filter_basis â†” âˆƒ i, p i âˆ§ s i = U :=\n  iff.rfl\n#align mem_filter_basis_iff mem_filter_basis_iff\n\n",
 "mem":
 "protected theorem has_antitone_basis.mem [preorder Î¹] {l : Filter Î±} {s : Î¹ â†’ Set Î±} (hs : l.has_antitone_basis s)\n    (i : Î¹) : s i âˆˆ l :=\n  hs.to_has_basis.mem_of_mem trivial\n#align has_antitone_basis.mem has_antitone_basis.mem\n\n",
 "map_sigma_mk_comap":
 "theorem map_sigma_mk_comap {Ï€ : Î± â†’ Type _} {Ï€' : Î² â†’ Type _} {f : Î± â†’ Î²} (hf : function.injective f)\n    (g : âˆ€ a, Ï€ a â†’ Ï€' (f a)) (a : Î±) (l : Filter (Ï€' (f a))) :\n    map (sigma.mk a) (comap (g a) l) = comap (Sigma.map f g) (map (sigma.mk (f a)) l) :=\n  by\n  refine' (((basis_sets _).comap _).map _).eq_of_same_basis _\n  convert((basis_sets _).map _).comap _\n  ext1 s\n  apply image_sigma_mk_preimage_sigma_map hf\n#align map_sigma_mk_comap map_sigma_mk_comap\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem has_antitone_basis.map {l : Filter Î±} {s : Î¹'' â†’ Set Î±} {m : Î± â†’ Î²} (hf : HasAntitoneBasis l s) :\n    HasAntitoneBasis (map m l) fun n => Â«expr '' Â» m (s n) :=\n  âŸ¨HasBasis.map _ hf.to_has_basis, fun i j hij => image_subset _ <| hf.2 hijâŸ©\n#align has_antitone_basis.map has_antitone_basis.map\n\n",
 "le_iff_forall_inf_principal_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem le_iff_forall_inf_principal_compl {f g : Filter Î±} :\n    f â‰¤ g â†” âˆ€ V âˆˆ g, Â«expr âŠ“ Â» f ((filter.principal) (Â«expr á¶œÂ» V)) = Â«exprâŠ¥Â» :=\n  forallâ‚‚_congr fun _ _ => mem_iff_inf_principal_compl\n#align le_iff_forall_inf_principal_compl le_iff_forall_inf_principal_compl\n\n",
 "le_iff":
 "theorem has_basis.le_iff (hl : l.has_basis p s) : l â‰¤ l' â†” âˆ€ t âˆˆ l', âˆƒ (i : _)(hi : p i), s i âŠ† t := by\n  simp only [le_def, hl.mem_iff]\n#align has_basis.le_iff has_basis.le_iff\n\n",
 "le_basis_iff":
 "theorem has_basis.le_basis_iff (hl : l.has_basis p s) (hl' : l'.has_basis p' s') :\n    l â‰¤ l' â†” âˆ€ i', p' i' â†’ âˆƒ (i : _)(hi : p i), s i âŠ† s' i' := by simp only [hl'.ge_iff, hl.mem_iff]\n#align has_basis.le_basis_iff has_basis.le_basis_iff\n\n",
 "is_countably_generated_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n@[instance]\ntheorem is_countably_generated_top : IsCountablyGenerated (Â«exprâŠ¤Â» : Filter Î±) :=\n  @principal_univ Î± â–¸ isCountablyGenerated_principal _\n#align is_countably_generated_top is_countably_generated_top\n\n",
 "is_countably_generated_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_countably_generated_seq [Countable Î²] (x : Î² â†’ Set Î±) :\n    IsCountablyGenerated\n      (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        (filter.principal <| x i)) :=\n  by\n  use range x, countable_range x\n  rw [generate_eq_binfi, infáµ¢_range]\n#align is_countably_generated_seq is_countably_generated_seq\n\n",
 "is_countably_generated_pure":
 "@[instance]\ntheorem is_countably_generated_pure (a : Î±) : IsCountablyGenerated (pure a) :=\n  by\n  rw [â† principal_singleton]\n  exact is_countably_generated_principal _\n#align is_countably_generated_pure is_countably_generated_pure\n\n",
 "is_countably_generated_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[instance]\ntheorem is_countably_generated_principal (s : Set Î±) : IsCountablyGenerated ((filter.principal) s) :=\n  isCountablyGenerated_of_seq âŸ¨fun _ => s, infáµ¢_const.symmâŸ©\n#align is_countably_generated_principal is_countably_generated_principal\n\n",
 "is_countably_generated_of_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_countably_generated_of_seq {f : Filter Î±}\n    (h :\n      âˆƒ x : â„• â†’ Set Î±,\n        f =\n          Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n            (filter.principal <| x i)) :\n    f.is_countably_generated := by\n  let âŸ¨x, hâŸ© := h\n  rw [h] <;> apply is_countably_generated_seq\n#align is_countably_generated_of_seq is_countably_generated_of_seq\n\n",
 "is_countably_generated_iff_exists_antitone_basis":
 "theorem is_countably_generated_iff_exists_antitone_basis {f : Filter Î±} :\n    IsCountablyGenerated f â†” âˆƒ x : â„• â†’ Set Î±, f.has_antitone_basis x :=\n  by\n  constructor\n  Â· intro h\n    exact f.exists_antitone_basis\n  Â· rintro âŸ¨x, hâŸ©\n    rw [h.to_has_basis.eq_infi]\n    exact is_countably_generated_seq x\n#align is_countably_generated_iff_exists_antitone_basis is_countably_generated_iff_exists_antitone_basis\n\n",
 "is_countably_generated_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n@[instance]\ntheorem is_countably_generated_bot : IsCountablyGenerated (Â«exprâŠ¥Â» : Filter Î±) :=\n  @principal_empty Î± â–¸ isCountablyGenerated_principal _\n#align is_countably_generated_bot is_countably_generated_bot\n\n",
 "is_countably_generated_binfi_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_countably_generated_binfi_principal {B : Set <| Set Î±} (h : B.countable) :\n    IsCountablyGenerated\n      (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) s)) :=\n  isCountablyGenerated_of_seq (countable_binfáµ¢_principal_eq_seq_infáµ¢ h)\n#align is_countably_generated_binfi_principal is_countably_generated_binfi_principal\n\n",
 "is_countably_generated":
 "-- For illustration purposes, the countable filter basis defining (at_top : filter â„•)\ntheorem has_countable_basis.is_countably_generated {f : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±}\n    (h : f.has_countable_basis p s) : f.is_countably_generated :=\n  âŸ¨âŸ¨{ t | âˆƒ i, p i âˆ§ s i = t }, h.countable.image s, h.to_has_basis.eq_generateâŸ©âŸ©\n#align has_countable_basis.is_countably_generated has_countable_basis.is_countably_generated\n\n",
 "is_basis":
 "theorem has_basis.is_basis (h : l.has_basis p s) : IsBasis p s :=\n  { nonempty :=\n      let âŸ¨i, hi, HâŸ© := h.mem_iff.mp univ_mem\n      âŸ¨i, hiâŸ©\n    inter := fun i j hi hj => by simpa [h.mem_iff] using l.inter_sets (h.mem_of_mem hi) (h.mem_of_mem hj) }\n#align has_basis.is_basis has_basis.is_basis\n\n",
 "inf_principal_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem inf_principal_ne_bot_iff {s : Set Î±} : NeBot (Â«expr âŠ“ Â» l ((filter.principal) s)) â†” âˆ€ U âˆˆ l, (U âˆ© s).nonempty :=\n  l.basis_sets.inf_principal_ne_bot_iff\n#align inf_principal_ne_bot_iff inf_principal_ne_bot_iff\n\n",
 "inf_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis.inf_principal (hl : l.has_basis p s) (s' : Set Î±) :\n    (Â«expr âŠ“ Â» l ((filter.principal) s')).has_basis p fun i => s i âˆ© s' :=\n  âŸ¨fun t => by simp only [mem_inf_principal, hl.mem_iff, subset_def, mem_set_of_eq, mem_inter_iff, and_imp]âŸ©\n#align has_basis.inf_principal has_basis.inf_principal\n\n",
 "inf_ne_bot_iff_frequently_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\ntheorem inf_ne_bot_iff_frequently_right {f g : Filter Î±} :\n    NeBot (Â«expr âŠ“ Â» f g) â†”\n      âˆ€ {p : Î± â†’ Prop},\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" g\n            (p x) â†’\n          Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" f\n            (p x) :=\n  by\n  rw [inf_comm]\n  exact inf_ne_bot_iff_frequently_left\n#align inf_ne_bot_iff_frequently_right inf_ne_bot_iff_frequently_right\n\n",
 "inf_ne_bot_iff_frequently_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\ntheorem inf_ne_bot_iff_frequently_left {f g : Filter Î±} :\n    NeBot (Â«expr âŠ“ Â» f g) â†”\n      âˆ€ {p : Î± â†’ Prop},\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" f\n            (p x) â†’\n          Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" g\n            (p x) :=\n  by simpa only [inf_ne_bot_iff, frequently_iff, exists_prop, and_comm']\n#align inf_ne_bot_iff_frequently_left inf_ne_bot_iff_frequently_left\n\n",
 "inf_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem inf_ne_bot_iff : NeBot (Â«expr âŠ“ Â» l l') â†” âˆ€ â¦ƒs : Set Î±â¦„ (hs : s âˆˆ l) â¦ƒs'â¦„ (hs' : s' âˆˆ l'), (s âˆ© s').nonempty :=\n  l.basis_sets.inf_ne_bot_iff\n#align inf_ne_bot_iff inf_ne_bot_iff\n\n",
 "inf_basis_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem has_basis.inf_basis_ne_bot_iff (hl : l.has_basis p s) (hl' : l'.has_basis p' s') :\n    NeBot (Â«expr âŠ“ Â» l l') â†” âˆ€ â¦ƒiâ¦„ (hi : p i) â¦ƒi'â¦„ (hi' : p' i'), (s i âˆ© s' i').nonempty :=\n  (hl.inf' hl').ne_bot_iff.trans <| by simp [@forall_swap _ Î¹']\n#align has_basis.inf_basis_ne_bot_iff has_basis.inf_basis_ne_bot_iff\n\n",
 "inf'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem has_basis.inf' (hl : l.has_basis p s) (hl' : l'.has_basis p' s') :\n    (Â«expr âŠ“ Â» l l').has_basis (fun i : PProd Î¹ Î¹' => p i.1 âˆ§ p' i.2) fun i => s i.1 âˆ© s' i.2 :=\n  âŸ¨by\n    intro t\n    constructor\n    Â· simp only [mem_inf_iff, exists_prop, hl.mem_iff, hl'.mem_iff]\n      rintro âŸ¨t, âŸ¨i, hi, htâŸ©, t', âŸ¨i', hi', ht'âŸ©, rflâŸ©\n      use âŸ¨i, i'âŸ©, âŸ¨hi, hi'âŸ©, inter_subset_inter ht ht'\n    Â· rintro âŸ¨âŸ¨i, i'âŸ©, âŸ¨hi, hi'âŸ©, HâŸ©\n      exact mem_inf_of_inter (hl.mem_of_mem hi) (hl'.mem_of_mem hi') HâŸ©\n#align has_basis.inf' has_basis.inf'\n\n",
 "inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem has_basis.inf {Î¹ Î¹' : Type _} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {p' : Î¹' â†’ Prop} {s' : Î¹' â†’ Set Î±}\n    (hl : l.has_basis p s) (hl' : l'.has_basis p' s') :\n    (Â«expr âŠ“ Â» l l').has_basis (fun i : Î¹ Ã— Î¹' => p i.1 âˆ§ p' i.2) fun i => s i.1 âˆ© s' i.2 :=\n  (hl.inf' hl').to_has_basis (fun i hi => âŸ¨âŸ¨i.1, i.2âŸ©, hi, Subset.rflâŸ©) fun i hi => âŸ¨âŸ¨i.1, i.2âŸ©, hi, Subset.rflâŸ©\n#align has_basis.inf has_basis.inf\n\n",
 "has_basis_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem has_basis_supr {Î¹ : Sort _} {Î¹' : Î¹ â†’ Type _} {l : Î¹ â†’ Filter Î±} {p : âˆ€ i, Î¹' i â†’ Prop} {s : âˆ€ i, Î¹' i â†’ Set Î±}\n    (hl : âˆ€ i, (l i).has_basis (p i) (s i)) :\n    (Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" (l i)).has_basis\n      (fun f : âˆ€ i, Î¹' i => âˆ€ i, p i (f i)) fun f : âˆ€ i, Î¹' i =>\n      Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (s i (f i)) :=\n  hasBasis_iff.mpr fun t => by\n    simp only [has_basis_iff, (hl _).mem_iff, classical.skolem, forall_and, Union_subset_iff, mem_supr]\n#align has_basis_supr has_basis_supr\n\n",
 "has_basis_self_subset":
 "theorem has_basis.has_basis_self_subset {p : Set Î± â†’ Prop} (h : l.has_basis (fun s => s âˆˆ l âˆ§ p s) id) {V : Set Î±}\n    (hV : V âˆˆ l) : l.has_basis (fun s => s âˆˆ l âˆ§ p s âˆ§ s âŠ† V) id := by\n  simpa only [and_assoc'] using h.restrict_subset hV\n#align has_basis.has_basis_self_subset has_basis.has_basis_self_subset\n\n",
 "has_basis_self":
 "theorem has_basis_self {l : Filter Î±} {P : Set Î± â†’ Prop} :\n    HasBasis l (fun s => s âˆˆ l âˆ§ P s) id â†” âˆ€ t âˆˆ l, âˆƒ r âˆˆ l, P r âˆ§ r âŠ† t :=\n  by\n  simp only [has_basis_iff, exists_prop, id, and_assoc']\n  exact forall_congr' fun s => âŸ¨fun h => h.1, fun h => âŸ¨h, fun âŸ¨t, hl, hP, htsâŸ© => mem_of_superset hl htsâŸ©âŸ©\n#align has_basis_self has_basis_self\n\n",
 "has_basis_pure":
 "theorem has_basis_pure (x : Î±) : (pure x : Filter Î±).has_basis (fun i : Unit => True) fun i => {x} := by\n  simp only [â† principal_singleton, has_basis_principal]\n#align has_basis_pure has_basis_pure\n\n",
 "has_basis_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis_principal (t : Set Î±) : ((filter.principal) t).has_basis (fun i : Unit => True) fun i => t :=\n  âŸ¨fun U => by simpâŸ©\n#align has_basis_principal has_basis_principal\n\n",
 "has_basis_infi_principal_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/-- If `s : Î¹ â†’ set Î±` is an indexed family of sets, then finite intersections of `s i` form a basis\nof `â¨… i, ğ“Ÿ (s i)`.  -/\ntheorem has_basis_infi_principal_finite {Î¹ : Type _} (s : Î¹ â†’ Set Î±) :\n    (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n          ((filter.principal) (s i))).has_basis\n      (fun t : Set Î¹ => t.finite) fun t =>\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (s i) :=\n  by\n  refine' âŸ¨fun U => (mem_infi_finite _).trans _âŸ©\n  simp only [infi_principal_finset, mem_Union, mem_principal, exists_prop, exists_finite_iff_finset,\n    Finset.set_binteráµ¢_coe]\n#align has_basis_infi_principal_finite has_basis_infi_principal_finite\n\n",
 "has_basis_infi_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis_infi_principal {s : Î¹ â†’ Set Î±} (h : Directed (Â· â‰¥ Â·) s) [Nonempty Î¹] :\n    (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n          ((filter.principal) (s i))).has_basis\n      (fun _ => True) s :=\n  âŸ¨by\n    refine' fun t =>\n      (mem_infi_of_directed (h.mono_comp _ _) t).trans <| by simp only [exists_prop, true_and_iff, mem_principal]\n    exact fun _ _ => principal_mono.2âŸ©\n#align has_basis_infi_principal has_basis_infi_principal\n\n",
 "has_basis_infi_of_directed'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\ntheorem has_basis_infi_of_directed' {Î¹ : Type _} {Î¹' : Î¹ â†’ Sort _} [Nonempty Î¹] {l : Î¹ â†’ Filter Î±}\n    (s : âˆ€ i, Î¹' i â†’ Set Î±) (p : âˆ€ i, Î¹' i â†’ Prop) (hl : âˆ€ i, (l i).has_basis (p i) (s i)) (h : Directed (Â· â‰¥ Â·) l) :\n    (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (l i)).has_basis\n      (fun ii' : Î£i, Î¹' i => p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2 :=\n  by\n  refine' âŸ¨fun t => _âŸ©\n  rw [mem_infi_of_directed h, Sigma.exists]\n  exact exists_congr fun i => (hl i).mem_iff\n#align has_basis_infi_of_directed' has_basis_infi_of_directed'\n\n",
 "has_basis_infi_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\ntheorem has_basis_infi_of_directed {Î¹ : Type _} {Î¹' : Sort _} [Nonempty Î¹] {l : Î¹ â†’ Filter Î±} (s : Î¹ â†’ Î¹' â†’ Set Î±)\n    (p : Î¹ â†’ Î¹' â†’ Prop) (hl : âˆ€ i, (l i).has_basis (p i) (s i)) (h : Directed (Â· â‰¥ Â·) l) :\n    (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (l i)).has_basis\n      (fun ii' : Î¹ Ã— Î¹' => p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2 :=\n  by\n  refine' âŸ¨fun t => _âŸ©\n  rw [mem_infi_of_directed h, Prod.exists]\n  exact exists_congr fun i => (hl i).mem_iff\n#align has_basis_infi_of_directed has_basis_infi_of_directed\n\n",
 "has_basis_infi'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem has_basis_infi' {Î¹ : Type _} {Î¹' : Î¹ â†’ Type _} {l : Î¹ â†’ Filter Î±} {p : âˆ€ i, Î¹' i â†’ Prop} {s : âˆ€ i, Î¹' i â†’ Set Î±}\n    (hl : âˆ€ i, (l i).has_basis (p i) (s i)) :\n    (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (l i)).has_basis\n      (fun If : Set Î¹ Ã— âˆ€ i, Î¹' i => If.1.finite âˆ§ âˆ€ i âˆˆ If.1, p i (If.2 i)) fun If : Set Î¹ Ã— âˆ€ i, Î¹' i =>\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (s i (If.2 i)) :=\n  âŸ¨by\n    intro t\n    constructor\n    Â· simp only [mem_infi', (hl _).mem_iff]\n      rintro âŸ¨I, hI, V, hV, -, rfl, -âŸ©\n      choose u hu using hV\n      exact âŸ¨âŸ¨I, uâŸ©, âŸ¨hI, fun i _ => (hu i).1âŸ©, Inter_mono fun i => Inter_mono fun hi => (hu i).2âŸ©\n    Â· rintro âŸ¨âŸ¨I, fâŸ©, âŸ¨hIâ‚, hIâ‚‚âŸ©, hsubâŸ©\n      refine' mem_of_superset _ hsub\n      exact (bInter_mem hIâ‚).mpr fun i hi => mem_infi_of_mem i <| (hl i).mem_of_mem <| hIâ‚‚ _ hiâŸ©\n#align has_basis_infi' has_basis_infi'\n\n",
 "has_basis_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem has_basis_infi {Î¹ : Type _} {Î¹' : Î¹ â†’ Type _} {l : Î¹ â†’ Filter Î±} {p : âˆ€ i, Î¹' i â†’ Prop} {s : âˆ€ i, Î¹' i â†’ Set Î±}\n    (hl : âˆ€ i, (l i).has_basis (p i) (s i)) :\n    (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (l i)).has_basis\n      (fun If : Î£I : Set Î¹, âˆ€ i : I, Î¹' i => If.1.finite âˆ§ âˆ€ i : If.1, p i (If.2 i)) fun If =>\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (s i (If.2 i)) :=\n  by\n  refine' âŸ¨fun t => âŸ¨fun ht => _, _âŸ©âŸ©\n  Â· rcases(has_basis_infi' hl).mem_iff.mp ht with âŸ¨âŸ¨I, fâŸ©, âŸ¨hI, hfâŸ©, hsubâŸ©\n    exact âŸ¨âŸ¨I, fun i => f iâŸ©, âŸ¨hI, subtype.forall.mpr hfâŸ©, trans_rel_right _ (Inter_subtype _ _) hsubâŸ©\n  Â· rintro âŸ¨âŸ¨I, fâŸ©, âŸ¨hI, hfâŸ©, hsubâŸ©\n    refine' mem_of_superset _ hsub\n    cases hI.nonempty_fintype\n    exact Inter_mem.2 fun i => mem_infi_of_mem i <| (hl i).mem_of_mem <| hf _\n#align has_basis_infi has_basis_infi\n\n",
 "has_basis_iff":
 "theorem has_basis_iff : l.has_basis p s â†” âˆ€ t, t âˆˆ l â†” âˆƒ (i : _)(hi : p i), s i âŠ† t :=\n  âŸ¨fun âŸ¨hâŸ© => h, fun h => âŸ¨hâŸ©âŸ©\n#align has_basis_iff has_basis_iff\n\n",
 "has_basis_generate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚â‚€ Â» -/\ntheorem has_basis_generate (s : Set (Set Î±)) :\n    (generate s).has_basis (fun t => Set.Finite t âˆ§ t âŠ† s) fun t => Â«exprâ‹‚â‚€ Â» t :=\n  âŸ¨fun U => by simp only [mem_generate_iff, exists_prop, and_assoc, and_left_comm]âŸ©\n#align has_basis_generate has_basis_generate\n\n",
 "has_basis_ge":
 "theorem has_antitone_basis.has_basis_ge [preorder Î¹] [IsDirected Î¹ (Â· â‰¤ Â·)] {l : Filter Î±} {s : Î¹ â†’ Set Î±}\n    (hs : l.has_antitone_basis s) (i : Î¹) : l.has_basis (fun j => i â‰¤ j) s :=\n  hs.1.to_has_basis (fun j _ => (exists_ge_ge i j).imp fun k hk => âŸ¨hk.1, hs.2 hk.2âŸ©) fun j hj =>\n    âŸ¨j, trivial, Subset.rflâŸ©\n#align has_antitone_basis.has_basis_ge has_antitone_basis.has_basis_ge\n\n",
 "has_basis_binfi_principal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis_binfi_principal' {Î¹ : Type _} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±}\n    (h : âˆ€ i, p i â†’ âˆ€ j, p j â†’ âˆƒ (k : _)(h : p k), s k âŠ† s i âˆ§ s k âŠ† s j) (ne : âˆƒ i, p i) :\n    (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n          ((filter.principal) (s i))).has_basis\n      p s :=\n  Filter.hasBasis_binfáµ¢_principal h ne\n#align has_basis_binfi_principal' has_basis_binfi_principal'\n\n",
 "has_basis_binfi_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹'o Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis_binfi_principal {s : Î² â†’ Set Î±} {S : Set Î²} (h : DirectedOn (Â«expr â»Â¹'o Â» s (Â· â‰¥ Â·)) S)\n    (ne : S.nonempty) :\n    (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n          ((filter.principal) (s i))).has_basis\n      (fun i => i âˆˆ S) s :=\n  âŸ¨by\n    refine' fun t => (mem_binfi_of_directed _ ne).trans <| by simp only [mem_principal]\n    rw [directedOn_iff_directed, â† directed_comp, (Â· âˆ˜ Â·)] at hâŠ¢\n    apply h.mono_comp _ _\n    exact fun _ _ => principal_mono.2âŸ©\n#align has_basis_binfi_principal has_basis_binfi_principal\n\n",
 "has_basis_binfi_of_directed'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹'o Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\ntheorem has_basis_binfi_of_directed' {Î¹ : Type _} {Î¹' : Î¹ â†’ Sort _} {dom : Set Î¹} (hdom : dom.nonempty)\n    {l : Î¹ â†’ Filter Î±} (s : âˆ€ i, Î¹' i â†’ Set Î±) (p : âˆ€ i, Î¹' i â†’ Prop) (hl : âˆ€ i âˆˆ dom, (l i).has_basis (p i) (s i))\n    (h : DirectedOn (Â«expr â»Â¹'o Â» l GE.ge) dom) :\n    (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (l i)).has_basis\n      (fun ii' : Î£i, Î¹' i => ii'.1 âˆˆ dom âˆ§ p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2 :=\n  by\n  refine' âŸ¨fun t => _âŸ©\n  rw [mem_binfi_of_directed h hdom, Sigma.exists]\n  refine' exists_congr fun i => âŸ¨_, _âŸ©\n  Â· rintro âŸ¨hi, htiâŸ©\n    rcases(hl i hi).mem_iff.mp hti with âŸ¨b, hb, hbtâŸ©\n    exact âŸ¨b, âŸ¨hi, hbâŸ©, hbtâŸ©\n  Â· rintro âŸ¨b, âŸ¨hi, hbâŸ©, hibtâŸ©\n    exact âŸ¨hi, (hl i hi).mem_iff.mpr âŸ¨b, hb, hibtâŸ©âŸ©\n#align has_basis_binfi_of_directed' has_basis_binfi_of_directed'\n\n",
 "has_basis_binfi_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹'o Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\ntheorem has_basis_binfi_of_directed {Î¹ : Type _} {Î¹' : Sort _} {dom : Set Î¹} (hdom : dom.nonempty) {l : Î¹ â†’ Filter Î±}\n    (s : Î¹ â†’ Î¹' â†’ Set Î±) (p : Î¹ â†’ Î¹' â†’ Prop) (hl : âˆ€ i âˆˆ dom, (l i).has_basis (p i) (s i))\n    (h : DirectedOn (Â«expr â»Â¹'o Â» l GE.ge) dom) :\n    (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (l i)).has_basis\n      (fun ii' : Î¹ Ã— Î¹' => ii'.1 âˆˆ dom âˆ§ p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2 :=\n  by\n  refine' âŸ¨fun t => _âŸ©\n  rw [mem_binfi_of_directed h hdom, Prod.exists]\n  refine' exists_congr fun i => âŸ¨_, _âŸ©\n  Â· rintro âŸ¨hi, htiâŸ©\n    rcases(hl i hi).mem_iff.mp hti with âŸ¨b, hb, hbtâŸ©\n    exact âŸ¨b, âŸ¨hi, hbâŸ©, hbtâŸ©\n  Â· rintro âŸ¨b, âŸ¨hi, hbâŸ©, hibtâŸ©\n    exact âŸ¨hi, (hl i hi).mem_iff.mpr âŸ¨b, hb, hibtâŸ©âŸ©\n#align has_basis_binfi_of_directed has_basis_binfi_of_directed\n\n",
 "has_basis":
 "#print FilterBasis.hasBasis /-\nprotected theorem FilterBasis.hasBasis {Î± : Type _} (B : FilterBasis Î±) :\n    HasBasis B.filter (fun s : Set Î± => s âˆˆ B) id :=\n  âŸ¨fun t => B.mem_filter_iffâŸ©\n#align filter_basis.has_basis FilterBasis.hasBasis\n-/\n\n",
 "generate_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚â‚€ Â» -/\ntheorem generate_ne_bot_iff {s : Set (Set Î±)} :\n    NeBot (generate s) â†” âˆ€ (t) (_ : t âŠ† s), t.finite â†’ (Â«exprâ‹‚â‚€ Â» t).nonempty :=\n  (hasBasis_generate s).ne_bot_iff.trans <| by simp only [â† and_imp, and_comm']\n#align generate_ne_bot_iff generate_ne_bot_iff\n\n",
 "generate_eq_generate_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem generate_eq_generate_inter (s : Set (Set Î±)) :\n    generate s = generate (Â«expr '' Â» interâ‚› { t | Set.Finite t âˆ§ t âŠ† s }) := by\n  erw [(filter_basis.of_sets s).generate, â† (has_basis_generate s).filter_eq] <;> rfl\n#align generate_eq_generate_inter generate_eq_generate_inter\n\n",
 "generate":
 "protected theorem generate (B : FilterBasis Î±) : generate B.sets = B.filter :=\n  by\n  apply le_antisymm\n  Â· intro U U_in\n    rcases B.mem_filter_iff.mp U_in with âŸ¨V, V_in, hâŸ©\n    exact generate_sets.superset (generate_sets.basic V_in) h\n  Â· rw [sets_iff_generate]\n    apply mem_filter_of_mem\n#align generate generate\n\n",
 "ge_iff":
 "theorem has_basis.ge_iff (hl' : l'.has_basis p' s') : l â‰¤ l' â†” âˆ€ i', p' i' â†’ s' i' âˆˆ l :=\n  âŸ¨fun h i' hi' => h <| hl'.mem_of_mem hi', fun h s hs =>\n    let âŸ¨i', hi', hsâŸ© := hl'.mem_iff.1 hs\n    mem_of_superset (h _ hi') hsâŸ©\n#align has_basis.ge_iff has_basis.ge_iff\n\n",
 "frequently_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\ntheorem has_basis.frequently_iff (hl : l.has_basis p s) {q : Î± â†’ Prop} :\n    Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" l (q x) â†”\n      âˆ€ i, p i â†’ âˆƒ x âˆˆ s i, q x :=\n  by simp [Filter.Frequently, hl.eventually_iff]\n#align has_basis.frequently_iff has_basis.frequently_iff\n\n",
 "forall_mem_mem":
 "theorem has_basis.forall_mem_mem (h : HasBasis l p s) {x : Î±} : (âˆ€ t âˆˆ l, x âˆˆ t) â†” âˆ€ i, p i â†’ x âˆˆ s i :=\n  by\n  simp only [h.mem_iff, exists_imp]\n  exact âŸ¨fun h i hi => h (s i) i hi subset.rfl, fun h t i hi ht => ht (h i hi)âŸ©\n#align has_basis.forall_mem_mem has_basis.forall_mem_mem\n\n",
 "forall_iff":
 "theorem has_basis.forall_iff (hl : l.has_basis p s) {P : Set Î± â†’ Prop} (mono : âˆ€ â¦ƒs tâ¦„, s âŠ† t â†’ P s â†’ P t) :\n    (âˆ€ s âˆˆ l, P s) â†” âˆ€ i, p i â†’ P (s i) :=\n  âŸ¨fun H i hi => H (s i) <| hl.mem_of_mem hi, fun H s hs =>\n    let âŸ¨i, hi, hisâŸ© := hl.mem_iff.1 hs\n    mono his (H i hi)âŸ©\n#align has_basis.forall_iff has_basis.forall_iff\n\n",
 "filter_eq_generate":
 "theorem filter_eq_generate (h : IsBasis p s) : h.filter = generate { U | âˆƒ i, p i âˆ§ s i = U } := by\n  erw [h.filter_basis.generate] <;> rfl\n#align filter_eq_generate filter_eq_generate\n\n",
 "filter_eq":
 "theorem has_basis.filter_eq (h : l.has_basis p s) : h.is_basis.filter = l :=\n  by\n  ext U\n  simp [h.mem_iff, is_basis.mem_filter_iff]\n#align has_basis.filter_eq has_basis.filter_eq\n\n",
 "ext":
 "theorem has_basis.ext (hl : l.has_basis p s) (hl' : l'.has_basis p' s') (h : âˆ€ i, p i â†’ âˆƒ i', p' i' âˆ§ s' i' âŠ† s i)\n    (h' : âˆ€ i', p' i' â†’ âˆƒ i, p i âˆ§ s i âŠ† s' i') : l = l' :=\n  by\n  apply le_antisymm\n  Â· rw [hl.le_basis_iff hl']\n    simpa using h'\n  Â· rw [hl'.le_basis_iff hl]\n    simpa using h\n#align has_basis.ext has_basis.ext\n\n",
 "exists_mem_filter_basis_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr on Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr on Â» -/\n#print Pairwise.exists_mem_filter_basis_of_disjoint /-\ntheorem Pairwise.exists_mem_filter_basis_of_disjoint {I : Type _} [Finite I] {l : I â†’ Filter Î±} {Î¹ : I â†’ Sort _}\n    {p : âˆ€ i, Î¹ i â†’ Prop} {s : âˆ€ i, Î¹ i â†’ Set Î±} (hd : Pairwise (Â«expr on Â» Disjoint l))\n    (h : âˆ€ i, (l i).has_basis (p i) (s i)) :\n    âˆƒ ind : âˆ€ i, Î¹ i, (âˆ€ i, p i (ind i)) âˆ§ Pairwise (Â«expr on Â» Disjoint fun i => s i (ind i)) :=\n  by\n  rcases hd.exists_mem_filter_of_disjoint with âŸ¨t, htl, hdâŸ©\n  choose ind hp ht using fun i => (h i).mem_iff.1 (htl i)\n  exact âŸ¨ind, hp, hd.mono fun i j hij => hij.mono (ht _) (ht _)âŸ©\n#align pairwise.exists_mem_filter_basis_of_disjoint Pairwise.exists_mem_filter_basis_of_disjoint\n-/\n\n",
 "exists_mem_filter_basis":
 "#print Set.PairwiseDisjoint.exists_mem_filter_basis /-\ntheorem Set.PairwiseDisjoint.exists_mem_filter_basis {I : Type _} {l : I â†’ Filter Î±} {Î¹ : I â†’ Sort _}\n    {p : âˆ€ i, Î¹ i â†’ Prop} {s : âˆ€ i, Î¹ i â†’ Set Î±} {S : Set I} (hd : S.pairwise_disjoint l) (hS : S.finite)\n    (h : âˆ€ i, (l i).has_basis (p i) (s i)) :\n    âˆƒ ind : âˆ€ i, Î¹ i, (âˆ€ i, p i (ind i)) âˆ§ S.pairwise_disjoint fun i => s i (ind i) :=\n  by\n  rcases hd.exists_mem_filter hS with âŸ¨t, htl, hdâŸ©\n  choose ind hp ht using fun i => (h i).mem_iff.1 (htl i)\n  exact âŸ¨ind, hp, hd.mono htâŸ©\n#align set.pairwise_disjoint.exists_mem_filter_basis Set.PairwiseDisjoint.exists_mem_filter_basis\n-/\n\n",
 "exists_iff":
 "theorem has_basis.exists_iff (hl : l.has_basis p s) {P : Set Î± â†’ Prop} (mono : âˆ€ â¦ƒs tâ¦„, s âŠ† t â†’ P t â†’ P s) :\n    (âˆƒ s âˆˆ l, P s) â†” âˆƒ (i : _)(hi : p i), P (s i) :=\n  âŸ¨fun âŸ¨s, hs, hPâŸ© =>\n    let âŸ¨i, hi, hisâŸ© := hl.mem_iff.1 hs\n    âŸ¨i, hi, mono his hPâŸ©,\n    fun âŸ¨i, hi, hPâŸ© => âŸ¨s i, hl.mem_of_mem hi, hPâŸ©âŸ©\n#align has_basis.exists_iff has_basis.exists_iff\n\n",
 "exists_antitone_subbasis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/-- If `f` is countably generated and `f.has_basis p s`, then `f` admits a decreasing basis\nenumerated by natural numbers such that all sets have the form `s i`. More precisely, there is a\nsequence `i n` such that `p (i n)` for all `n` and `s (i n)` is a decreasing sequence of sets which\nforms a basis of `f`-/\ntheorem has_basis.exists_antitone_subbasis {f : Filter Î±} [h : f.is_countably_generated] {p : Î¹' â†’ Prop}\n    {s : Î¹' â†’ Set Î±} (hs : f.has_basis p s) : âˆƒ x : â„• â†’ Î¹', (âˆ€ i, p (x i)) âˆ§ f.has_antitone_basis fun i => s (x i) :=\n  by\n  obtain âŸ¨x', hx'âŸ© :\n    âˆƒ x : â„• â†’ Set Î±,\n      f =\n        Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n          ((filter.principal) (x i)) :=\n    by\n    rcases h with âŸ¨s, hsc, rflâŸ©\n    rw [generate_eq_binfi]\n    exact countable_binfi_principal_eq_seq_infi hsc\n  have : âˆ€ i, x' i âˆˆ f := fun i => hx'.symm â–¸ (infáµ¢_le (fun i => (filter.principal) (x' i)) i) (mem_principal_self _)\n  let x : â„• â†’ { i : Î¹' // p i } := fun n =>\n    nat.rec_on n (hs.index _ <| this 0) fun n xn => hs.index _ <| inter_mem (this <| n + 1) (hs.mem_of_mem xn.2)\n  have x_mono : Antitone fun i => s (x i) :=\n    by\n    refine' antitone_nat_of_succ_le fun i => _\n    exact (hs.set_index_subset _).trans (inter_subset_right _ _)\n  have x_subset : âˆ€ i, s (x i) âŠ† x' i := by\n    rintro (_ | i)\n    exacts[hs.set_index_subset _, subset.trans (hs.set_index_subset _) (inter_subset_left _ _)]\n  refine' âŸ¨fun i => x i, fun i => (x i).2, _âŸ©\n  have :\n    (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n          ((filter.principal) (s (x i)))).has_antitone_basis\n      fun i => s (x i) :=\n    âŸ¨has_basis_infi_principal (directed_of_sup x_mono), x_monoâŸ©\n  convert this\n  exact\n    le_antisymm (le_infáµ¢ fun i => le_principal_iff.2 <| by cases i <;> apply hs.set_index_mem)\n      (hx'.symm â–¸ le_infáµ¢ fun i => le_principal_iff.2 <| this.to_has_basis.mem_iff.2 âŸ¨i, trivial, x_subset iâŸ©)\n#align has_basis.exists_antitone_subbasis has_basis.exists_antitone_subbasis\n\n",
 "exists_antitone_seq":
 "theorem exists_antitone_seq (f : Filter Î±) [f.is_countably_generated] :\n    âˆƒ x : â„• â†’ Set Î±, Antitone x âˆ§ âˆ€ {s}, s âˆˆ f â†” âˆƒ i, x i âŠ† s :=\n  let âŸ¨x, hxâŸ© := f.exists_antitone_basis\n  âŸ¨x, hx.antitone, fun s => by simp [hx.to_has_basis.mem_iff]âŸ©\n#align exists_antitone_seq exists_antitone_seq\n\n",
 "exists_antitone_basis":
 "/-- A countably generated filter admits a basis formed by an antitone sequence of sets. -/\ntheorem exists_antitone_basis (f : Filter Î±) [f.is_countably_generated] : âˆƒ x : â„• â†’ Set Î±, f.has_antitone_basis x :=\n  let âŸ¨x, hxf, hxâŸ© := f.basis_sets.exists_antitone_subbasis\n  âŸ¨x, hxâŸ©\n#align exists_antitone_basis exists_antitone_basis\n\n",
 "ex_mem":
 "theorem has_basis.ex_mem (h : l.has_basis p s) : âˆƒ i, p i :=\n  let âŸ¨i, pi, hâŸ© := h.mem_iff.mp univ_mem\n  âŸ¨i, piâŸ©\n#align has_basis.ex_mem has_basis.ex_mem\n\n",
 "eventually_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\ntheorem has_basis.eventually_iff (hl : l.has_basis p s) {q : Î± â†’ Prop} :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" l (q x) â†”\n      âˆƒ i, p i âˆ§ âˆ€ â¦ƒxâ¦„, x âˆˆ s i â†’ q x :=\n  by simpa using hl.mem_iff\n#align has_basis.eventually_iff has_basis.eventually_iff\n\n",
 "eq_of_same_basis":
 "theorem has_basis.eq_of_same_basis (hl : l.has_basis p s) (hl' : l'.has_basis p s) : l = l' :=\n  by\n  ext t\n  rw [hl.mem_iff, hl'.mem_iff]\n#align has_basis.eq_of_same_basis has_basis.eq_of_same_basis\n\n",
 "eq_infi_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem eq_infi_principal (B : FilterBasis Î±) :\n    B.filter =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) s) :=\n  by\n  have : Directed (Â· â‰¥ Â·) fun s : B.sets => (filter.principal) (s : Set Î±) :=\n    by\n    rintro âŸ¨U, U_inâŸ© âŸ¨V, V_inâŸ©\n    rcases B.inter_sets U_in V_in with âŸ¨W, W_in, W_subâŸ©\n    use W, W_in\n    simp only [ge_iff_le, le_principal_iff, mem_principal, Subtype.coe_mk]\n    exact subset_inter_iff.mp W_sub\n  ext U\n  simp [mem_filter_iff, mem_infi_of_directed this]\n#align eq_infi_principal eq_infi_principal\n\n",
 "eq_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis.eq_infi (h : l.has_basis (fun _ => True) s) :\n    l =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) (s i)) :=\n  by simpa only [infáµ¢_true] using h.eq_binfi\n#align has_basis.eq_infi has_basis.eq_infi\n\n",
 "eq_generate":
 "theorem has_basis.eq_generate (h : l.has_basis p s) : l = generate { U | âˆƒ i, p i âˆ§ s i = U } := by\n  rw [â† h.is_basis.filter_eq_generate, h.filter_eq]\n#align has_basis.eq_generate has_basis.eq_generate\n\n",
 "eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem has_basis.eq_bot_iff (hl : l.has_basis p s) : l = Â«exprâŠ¥Â» â†” âˆƒ i, p i âˆ§ s i = âˆ… :=\n  not_iff_not.1 <|\n    neBot_iff.symm.trans <| hl.ne_bot_iff.trans <| by simp only [not_exists, not_and, nonempty_iff_ne_empty]\n#align has_basis.eq_bot_iff has_basis.eq_bot_iff\n\n",
 "eq_binfi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem has_basis.eq_binfi (h : l.has_basis p s) :\n    l =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) (s i)) :=\n  eq_binfáµ¢_of_mem_iff_exists_mem fun t => by simp only [h.mem_iff, mem_principal]\n#align has_basis.eq_binfi has_basis.eq_binfi\n\n",
 "disjoint_pure_pure":
 "@[simp]\ntheorem disjoint_pure_pure {x y : Î±} : Disjoint (pure x : Filter Î±) (pure y) â†” x â‰  y := by\n  simp only [â† principal_singleton, disjoint_principal_principal, disjoint_singleton]\n#align disjoint_pure_pure disjoint_pure_pure\n\n",
 "disjoint_principal_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n@[simp]\ntheorem disjoint_principal_right {f : Filter Î±} {s : Set Î±} : Disjoint f ((filter.principal) s) â†” Â«expr á¶œÂ» s âˆˆ f := by\n  rw [mem_iff_inf_principal_compl, compl_compl, disjoint_iff]\n#align disjoint_principal_right disjoint_principal_right\n\n",
 "disjoint_principal_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem disjoint_principal_principal {s t : Set Î±} :\n    Disjoint ((filter.principal) s) ((filter.principal) t) â†” Disjoint s t := by simp [â† subset_compl_iff_disjoint_left]\n#align disjoint_principal_principal disjoint_principal_principal\n\n",
 "disjoint_principal_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n@[simp]\ntheorem disjoint_principal_left {f : Filter Î±} {s : Set Î±} : Disjoint ((filter.principal) s) f â†” Â«expr á¶œÂ» s âˆˆ f := by\n  rw [disjoint_comm, disjoint_principal_right]\n#align disjoint_principal_left disjoint_principal_left\n\n",
 "disjoint_iff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem has_basis.disjoint_iff_right (h : l.has_basis p s) : Disjoint l' l â†” âˆƒ (i : _)(hi : p i), Â«expr á¶œÂ» (s i) âˆˆ l' :=\n  disjoint_comm.trans h.disjoint_iff_left\n#align has_basis.disjoint_iff_right has_basis.disjoint_iff_right\n\n",
 "disjoint_iff_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem has_basis.disjoint_iff_left (h : l.has_basis p s) : Disjoint l l' â†” âˆƒ (i : _)(hi : p i), Â«expr á¶œÂ» (s i) âˆˆ l' :=\n  by\n  simp only [h.disjoint_iff l'.basis_sets, exists_prop, id, â† disjoint_principal_left,\n    (has_basis_principal _).disjoint_iff l'.basis_sets, Unique.exists_iff]\n#align has_basis.disjoint_iff_left has_basis.disjoint_iff_left\n\n",
 "disjoint_iff":
 "theorem has_basis.disjoint_iff (hl : l.has_basis p s) (hl' : l'.has_basis p' s') :\n    Disjoint l l' â†” âˆƒ (i : _)(hi : p i)(i' : _)(hi' : p' i'), Disjoint (s i) (s' i') :=\n  not_iff_not.mp <| by\n    simp only [disjoint_iff, â† ne.def, â† ne_bot_iff, hl.inf_basis_ne_bot_iff hl', not_exists, bot_eq_empty, â†\n      nonempty_iff_ne_empty, inf_eq_inter]\n#align has_basis.disjoint_iff has_basis.disjoint_iff\n\n",
 "countable_binfi_principal_eq_seq_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem countable_binfi_principal_eq_seq_infi {B : Set (Set Î±)} (Bcbl : B.countable) :\n    âˆƒ x : â„• â†’ Set Î±,\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n          ((filter.principal) t) =\n        Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n          ((filter.principal) (x i)) :=\n  countable_binfáµ¢_eq_infáµ¢_seq' Bcbl (filter.principal) principal_univ\n#align countable_binfi_principal_eq_seq_infi countable_binfi_principal_eq_seq_infi\n\n",
 "countable_binfi_eq_infi_seq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\ntheorem countable_binfi_eq_infi_seq' [CompleteLattice Î±] {B : Set Î¹} (Bcbl : B.countable) (f : Î¹ â†’ Î±) {iâ‚€ : Î¹}\n    (h : f iâ‚€ = Â«exprâŠ¤Â») :\n    âˆƒ x : â„• â†’ Î¹,\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (f t) =\n        Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (f (x i)) :=\n  by\n  cases' B.eq_empty_or_nonempty with hB Bnonempty\n  Â· rw [hB, infáµ¢_emptyset]\n    use fun n => iâ‚€\n    simp [h]\n  Â· exact countable_binfi_eq_infi_seq Bcbl Bnonempty f\n#align countable_binfi_eq_infi_seq' countable_binfi_eq_infi_seq'\n\n",
 "countable_binfi_eq_infi_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\ntheorem countable_binfi_eq_infi_seq [CompleteLattice Î±] {B : Set Î¹} (Bcbl : B.countable) (Bne : B.nonempty)\n    (f : Î¹ â†’ Î±) :\n    âˆƒ x : â„• â†’ Î¹,\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (f t) =\n        Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (f (x i)) :=\n  let âŸ¨g, hgâŸ© := Bcbl.exists_eq_range Bne\n  âŸ¨g, hg.symm â–¸ infáµ¢_rangeâŸ©\n#align countable_binfi_eq_infi_seq countable_binfi_eq_infi_seq\n\n",
 "coprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem has_basis.coprod {Î¹ Î¹' : Type _} {pa : Î¹ â†’ Prop} {sa : Î¹ â†’ Set Î±} {pb : Î¹' â†’ Prop} {sb : Î¹' â†’ Set Î²}\n    (hla : la.has_basis pa sa) (hlb : lb.has_basis pb sb) :\n    (la.coprod lb).has_basis (fun i : Î¹ Ã— Î¹' => pa i.1 âˆ§ pb i.2) fun i =>\n      Â«expr â»Â¹' Â» Prod.fst (sa i.1) âˆª Â«expr â»Â¹' Â» Prod.snd (sb i.2) :=\n  (hla.comap Prod.fst).sup (hlb.comap Prod.snd)\n#align has_basis.coprod has_basis.coprod\n\n",
 "compl_diagonal_mem_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n@[simp]\ntheorem compl_diagonal_mem_prod {lâ‚ lâ‚‚ : Filter Î±} : Â«expr á¶œÂ» (diagonal Î±) âˆˆ filter.prod lâ‚ lâ‚‚ â†” Disjoint lâ‚ lâ‚‚ := by\n  simp only [mem_prod_iff, Filter.disjoint_iff, prod_subset_compl_diagonal_iff_disjoint]\n#align compl_diagonal_mem_prod compl_diagonal_mem_prod\n\n",
 "comp_surjective":
 "theorem has_basis.comp_surjective (h : l.has_basis p s) {g : Î¹' â†’ Î¹} (hg : function.surjective g) :\n    l.has_basis (p âˆ˜ g) (s âˆ˜ g) :=\n  âŸ¨fun t => h.mem_iff.trans hg.existsâŸ©\n#align has_basis.comp_surjective has_basis.comp_surjective\n\n",
 "comp_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒ Â» -/\ntheorem has_basis.comp_equiv (h : l.has_basis p s) (e : Â«expr â‰ƒ Â» Î¹' Î¹) : l.has_basis (p âˆ˜ e) (s âˆ˜ e) :=\n  h.comp_surjective e.surjective\n#align has_basis.comp_equiv has_basis.comp_equiv\n\n",
 "comap_has_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem comap_has_basis (f : Î± â†’ Î²) (l : Filter Î²) :\n    HasBasis (comap f l) (fun s : Set Î² => s âˆˆ l) fun s => Â«expr â»Â¹' Â» f s :=\n  âŸ¨fun t => mem_comapâŸ©\n#align comap_has_basis comap_has_basis\n\n",
 "comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem has_basis.comap (f : Î² â†’ Î±) (hl : l.has_basis p s) : (l.comap f).has_basis p fun i => Â«expr â»Â¹' Â» f (s i) :=\n  âŸ¨by\n    intro t\n    simp only [mem_comap, exists_prop, hl.mem_iff]\n    constructor\n    Â· rintro âŸ¨t', âŸ¨i, hi, ht'âŸ©, HâŸ©\n      exact âŸ¨i, hi, subset.trans (preimage_mono ht') HâŸ©\n    Â· rintro âŸ¨i, hi, HâŸ©\n      exact âŸ¨s i, âŸ¨i, hi, subset.refl _âŸ©, HâŸ©âŸ©\n#align has_basis.comap has_basis.comap\n\n",
 "binfi_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\nprotected theorem has_basis.binfi_mem [CompleteLattice Î²] {f : Set Î± â†’ Î²} (h : HasBasis l p s) (hf : Monotone f) :\n    Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (f t) =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (f (s i)) :=\n  le_antisymm (le_infáµ¢â‚‚ fun i hi => infáµ¢â‚‚_le (s i) (h.mem_of_mem hi)) <|\n    le_infáµ¢â‚‚ fun t ht =>\n      let âŸ¨i, hpi, hiâŸ© := h.mem_iff.1 ht\n      infáµ¢â‚‚_le_of_le i hpi (hf hi)\n#align has_basis.binfi_mem has_basis.binfi_mem\n\n",
 "basis_sets":
 "theorem basis_sets (l : Filter Î±) : l.has_basis (fun s : Set Î± => s âˆˆ l) id :=\n  âŸ¨fun t => exists_mem_subset_iff.symmâŸ©\n#align basis_sets basis_sets\n\n",
 "basis_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\ntheorem tendsto.basis_right (H : Tendsto f la lb) (hlb : lb.has_basis pb sb) :\n    âˆ€ (i) (hi : pb i),\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" la\n        (f x âˆˆ sb i) :=\n  hlb.tendsto_right_iff.1 H\n#align tendsto.basis_right tendsto.basis_right\n\n",
 "basis_left":
 "theorem tendsto.basis_left (H : Tendsto f la lb) (hla : la.has_basis pa sa) :\n    âˆ€ t âˆˆ lb, âˆƒ (i : _)(hi : pa i), MapsTo f (sa i) t :=\n  hla.tendsto_left_iff.1 H\n#align tendsto.basis_left tendsto.basis_left\n\n",
 "basis_both":
 "theorem tendsto.basis_both (H : Tendsto f la lb) (hla : la.has_basis pa sa) (hlb : lb.has_basis pb sb) :\n    âˆ€ (ib) (hib : pb ib), âˆƒ (ia : _)(hia : pa ia), âˆ€ x âˆˆ sa ia, f x âˆˆ sb ib :=\n  (hla.tendsto_iff hlb).1 H\n#align tendsto.basis_both tendsto.basis_both\n\n",
 "bInter_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\nprotected theorem has_basis.bInter_mem {f : Set Î± â†’ Set Î²} (h : HasBasis l p s) (hf : Monotone f) :\n    Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f t) =\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f (s i)) :=\n  h.binfi_mem hf\n#align has_basis.bInter_mem has_basis.bInter_mem\n\n",
 "as_basis_filter":
 "theorem as_basis_filter (f : Filter Î±) : f.as_basis.filter = f := by ext t <;> exact exists_mem_subset_iff\n#align as_basis_filter as_basis_filter\n\n",
 "antitone_seq_of_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem antitone_seq_of_seq (s : â„• â†’ Set Î±) :\n    âˆƒ t : â„• â†’ Set Î±,\n      Antitone t âˆ§\n        Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n            (filter.principal <| s i) =\n          Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n            ((filter.principal) (t i)) :=\n  by\n  use fun n => Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (s m);\n  constructor\n  Â· exact fun i j hij => bInter_mono (Iic_subset_Iic.2 hij) fun n hn => subset.refl _\n  apply le_antisymm <;> rw [le_infáµ¢_iff] <;> intro i\n  Â· rw [le_principal_iff]\n    refine' (bInter_mem (finite_le_nat _)).2 fun j hji => _\n    rw [â† le_principal_iff]\n    apply infáµ¢_le_of_le j _\n    exact le_rfl\n  Â· apply infáµ¢_le_of_le i _\n    rw [principal_mono]\n    intro a\n    simp\n    intro h\n    apply h\n    rfl\n#align antitone_seq_of_seq antitone_seq_of_seq\n\n"}