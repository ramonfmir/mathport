{"tendsto_indicator_bUnion_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem tendsto_indicator_bUnion_finset {ι} [Zero β] (s : ι → set α) (f : α → β) (a : α) :\n    tendsto\n      (fun n : Finset ι =>\n        indicator\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) f a)\n      at_top (pure <| indicator (unionᵢ s) f a) :=\n  by\n  rw [Union_eq_Union_finset s]\n  refine'\n    monotone.tendsto_indicator\n      (fun n : Finset ι =>\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))\n      _ f a\n  exact fun t₁ t₂ => bUnion_subset_bUnion_left\n#align tendsto_indicator_bUnion_finset tendsto_indicator_bUnion_finset\n\n",
 "tendsto_indicator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem antitone.tendsto_indicator {ι} [preorder ι] [Zero β] (s : ι → set α) (hs : antitone s) (f : α → β) (a : α) :\n    tendsto (fun i => indicator (s i) f a) at_top\n      (pure <|\n        indicator\n          («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)) f\n          a) :=\n  by\n  by_cases h : ∃ i, a ∉ s i\n  · rcases h with ⟨i, hi⟩\n    refine' tendsto_pure.2 ((eventually_ge_at_top i).mono fun n hn => _)\n    rw [indicator_of_not_mem _ _, indicator_of_not_mem _ _]\n    · simp only [mem_Inter, not_forall]\n      exact ⟨i, hi⟩\n    · intro h\n      have := hs hn h\n      contradiction\n  · push_neg  at h\n    simp only [indicator_of_mem, h, mem_Inter.2 h, tendsto_const_pure]\n#align antitone.tendsto_indicator antitone.tendsto_indicator\n\n",
 "support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem filter.eventually_eq.support [Zero β] {f g : α → β} {l : filter α} (h : «expr =ᶠ[ ] » f l g) :\n    «expr =ᶠ[ ] » (function.support f) l (function.support g) :=\n  by\n  filter_upwards [h] with x hx\n  rw [eq_iff_iff]\n  change f x ≠ 0 ↔ g x ≠ 0\n  rw [hx]\n#align filter.eventually_eq.support filter.eventually_eq.support\n\n",
 "indicator_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem filter.eventually_eq.indicator_zero [Zero β] {l : filter α} {f : α → β} {s : set α} (hf : «expr =ᶠ[ ] » f l 0) :\n    «expr =ᶠ[ ] » (s.indicator f) l 0 := by\n  refine' hf.indicator.trans _\n  rw [indicator_zero']\n#align filter.eventually_eq.indicator_zero filter.eventually_eq.indicator_zero\n\n",
 "indicator_union_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem indicator_union_eventually_eq\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (a ∉ s ∩ t)) :\n    «expr =ᶠ[ ] » (indicator (s ∪ t) f) l (indicator s f + indicator t f) :=\n  h.mono fun a ha => indicator_union_of_not_mem_inter ha _\n#align indicator_union_eventually_eq indicator_union_eventually_eq\n\n",
 "indicator_eventually_le_indicator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem indicator_eventually_le_indicator (h : «expr ≤ᶠ[ ] » f («expr ⊓ » l ((filter.principal) s)) g) :\n    «expr ≤ᶠ[ ] » (indicator s f) l (indicator s g) :=\n  (eventually_inf_principal.1 h).mono fun a h => indicator_rel_indicator le_rfl h\n#align indicator_eventually_le_indicator indicator_eventually_le_indicator\n\n",
 "indicator_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/-\nCopyright (c) 2020 Zhouhang Zhou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Zhouhang Zhou, Yury Kudryashov\n-/\ntheorem indicator_eventually_eq (hf : «expr =ᶠ[ ] » f («expr ⊓ » l ((filter.principal) s)) g)\n    (hs : «expr =ᶠ[ ] » s l t) : «expr =ᶠ[ ] » (indicator s f) l (indicator t g) :=\n  (eventually_inf_principal.1 hf).mp <|\n    hs.mem_iff.mono fun x hst hfg =>\n      by_cases (fun hxs : x ∈ s => by simp only [*, hst.1 hxs, indicator_of_mem]) fun hxs => by\n        simp only [indicator_of_not_mem hxs, indicator_of_not_mem (mt hst.2 hxs)]\n#align indicator_eventually_eq indicator_eventually_eq\n\n",
 "indicator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem filter.eventually_eq.indicator [Zero β] {l : filter α} {f g : α → β} {s : set α} (hfg : «expr =ᶠ[ ] » f l g) :\n    «expr =ᶠ[ ] » (s.indicator f) l (s.indicator g) :=\n  by\n  filter_upwards [hfg] with x hx\n  by_cases x ∈ s\n  · rwa [indicator_of_mem h, indicator_of_mem h]\n  · rw [indicator_of_not_mem h, indicator_of_not_mem h]\n#align filter.eventually_eq.indicator filter.eventually_eq.indicator\n\n"}