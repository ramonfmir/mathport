{"univ_mem'":
 "theorem univ_mem' (h : ∀ a, a ∈ s) : s ∈ f :=\n  mem_of_superset univ_mem fun x _ => h x\n#align univ_mem' univ_mem'\n\n",
 "univ_mem":
 "@[simp]\ntheorem univ_mem : univ ∈ f :=\n  f.univ_sets\n#align univ_mem univ_mem\n\n",
 "union_mem_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem union_mem_sup {f g : Filter α} {s t : Set α} (hs : s ∈ f) (ht : t ∈ g) : s ∪ t ∈ «expr ⊔ » f g :=\n  ⟨mem_of_superset hs (subset_union_left s t), mem_of_superset ht (subset_union_right s t)⟩\n#align union_mem_sup union_mem_sup\n\n",
 "union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n@[mono]\ntheorem eventually_le.union {s t s' t' : Set α} {l : Filter α} (h : «expr ≤ᶠ[ ] » s l t) (h' : «expr ≤ᶠ[ ] » s' l t') :\n    «expr ≤ᶠ[ ] » (s ∪ s' : Set α) l (t ∪ t' : Set α) :=\n  h'.mp <| h.mono fun x => Or.imp\n#align eventually_le.union eventually_le.union\n\n",
 "trans_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n@[trans]\ntheorem eventually_eq.trans_le (H₁ : «expr =ᶠ[ ] » f l g) (H₂ : «expr ≤ᶠ[ ] » g l h) : «expr ≤ᶠ[ ] » f l h :=\n  H₁.le.trans H₂\n#align eventually_eq.trans_le eventually_eq.trans_le\n\n",
 "trans_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n@[trans]\ntheorem eventually_le.trans_eq (H₁ : «expr ≤ᶠ[ ] » f l g) (H₂ : «expr =ᶠ[ ] » g l h) : «expr ≤ᶠ[ ] » f l h :=\n  H₁.trans H₂.le\n#align eventually_le.trans_eq eventually_le.trans_eq\n\n",
 "trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n@[trans]\ntheorem eventually_le.trans (H₁ : «expr ≤ᶠ[ ] » f l g) (H₂ : «expr ≤ᶠ[ ] » g l h) : «expr ≤ᶠ[ ] » f l h :=\n  H₂.mp <| H₁.mono fun x => le_trans\n#align eventually_le.trans eventually_le.trans\n\n",
 "tendsto_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem tendsto_top {f : α → β} {l : Filter α} : Tendsto f l («expr⊤») :=\n  le_top\n#align tendsto_top tendsto_top\n\n",
 "tendsto_supr_supr":
 "theorem tendsto_supr_supr {f : α → β} {x : ι → Filter α} {y : ι → Filter β} (h : ∀ i, Tendsto f (x i) (y i)) :\n    Tendsto f (supᵢ x) (supᵢ y) :=\n  tendsto_supᵢ.2 fun i => (h i).mono_right <| le_supᵢ _ _\n#align tendsto_supr_supr tendsto_supr_supr\n\n",
 "tendsto_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem tendsto_supr {f : α → β} {x : ι → Filter α} {y : Filter β} :\n    Tendsto f («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (x i))\n        y ↔\n      ∀ i, Tendsto f (x i) y :=\n  by simp only [tendsto, map_supᵢ, supᵢ_le_iff]\n#align tendsto_supr tendsto_supr\n\n",
 "tendsto_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem tendsto_sup {f : α → β} {x₁ x₂ : Filter α} {y : Filter β} :\n    Tendsto f («expr ⊔ » x₁ x₂) y ↔ Tendsto f x₁ y ∧ Tendsto f x₂ y := by simp only [tendsto, map_sup, sup_le_iff]\n#align tendsto_sup tendsto_sup\n\n",
 "tendsto_pure_pure":
 "theorem tendsto_pure_pure (f : α → β) (a : α) : Tendsto f (pure a) (pure (f a)) :=\n  tendsto_pure.2 rfl\n#align tendsto_pure_pure tendsto_pure_pure\n\n",
 "tendsto_pure_left":
 "theorem tendsto_pure_left {f : α → β} {a : α} {l : Filter β} : Tendsto f (pure a) l ↔ ∀ s ∈ l, f a ∈ s :=\n  iff.rfl\n#align tendsto_pure_left tendsto_pure_left\n\n",
 "tendsto_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem tendsto_pure {f : α → β} {a : Filter α} {b : β} :\n    Tendsto f a (pure b) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" a\n        (f x = b) :=\n  by simp only [tendsto, le_pure_iff, mem_map', mem_singleton_iff, Filter.Eventually]\n#align tendsto_pure tendsto_pure\n\n",
 "tendsto_principal_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem tendsto_principal_principal {f : α → β} {s : Set α} {t : Set β} :\n    Tendsto f ((filter.principal) s) ((filter.principal) t) ↔ ∀ a ∈ s, f a ∈ t := by\n  simp only [tendsto_principal, eventually_principal]\n#align tendsto_principal_principal tendsto_principal_principal\n\n",
 "tendsto_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem tendsto_principal {f : α → β} {l : Filter α} {s : Set β} :\n    Tendsto f l ((filter.principal) s) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (f a ∈ s) :=\n  by simp only [tendsto, le_principal_iff, mem_map', Filter.Eventually]\n#align tendsto_principal tendsto_principal\n\n",
 "tendsto_of_is_empty":
 "theorem tendsto_of_is_empty [IsEmpty α] {f : α → β} {la : Filter α} {lb : Filter β} : Tendsto f la lb := by\n  simp only [filter_eq_bot_of_is_empty la, tendsto_bot]\n#align tendsto_of_is_empty tendsto_of_is_empty\n\n",
 "tendsto_map'_iff":
 "@[simp]\ntheorem tendsto_map'_iff {f : β → γ} {g : α → β} {x : Filter α} {y : Filter γ} :\n    Tendsto f (map g x) y ↔ Tendsto (f ∘ g) x y :=\n  by\n  rw [tendsto, map_map]\n  rfl\n#align tendsto_map'_iff tendsto_map'_iff\n\n",
 "tendsto_map'":
 "theorem tendsto_map' {f : β → γ} {g : α → β} {x : Filter α} {y : Filter γ} (h : Tendsto (f ∘ g) x y) :\n    Tendsto f (map g x) y := by rwa [tendsto, map_map]\n#align tendsto_map' tendsto_map'\n\n",
 "tendsto_map":
 "theorem tendsto_map {f : α → β} {x : Filter α} : Tendsto f x (map f x) :=\n  le_refl (map f x)\n#align tendsto_map tendsto_map\n\n",
 "tendsto_infi_infi":
 "theorem tendsto_infi_infi {f : α → β} {x : ι → Filter α} {y : ι → Filter β} (h : ∀ i, Tendsto f (x i) (y i)) :\n    Tendsto f (infᵢ x) (infᵢ y) :=\n  tendsto_infᵢ.2 fun i => tendsto_infᵢ' i (h i)\n#align tendsto_infi_infi tendsto_infi_infi\n\n",
 "tendsto_infi'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem tendsto_infi' {f : α → β} {x : ι → Filter α} {y : Filter β} (i : ι) (hi : Tendsto f (x i) y) :\n    Tendsto f («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (x i))\n      y :=\n  hi.mono_left <| infᵢ_le _ _\n#align tendsto_infi' tendsto_infi'\n\n",
 "tendsto_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem tendsto_infi {f : α → β} {x : Filter α} {y : ι → Filter β} :\n    Tendsto f x\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (y i)) ↔\n      ∀ i, Tendsto f x (y i) :=\n  by simp only [tendsto, iff_self_iff, le_infᵢ_iff]\n#align tendsto_infi tendsto_infi\n\n",
 "tendsto_inf_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem tendsto_inf_right {f : α → β} {x₁ x₂ : Filter α} {y : Filter β} (h : Tendsto f x₂ y) :\n    Tendsto f («expr ⊓ » x₁ x₂) y :=\n  le_trans (map_mono inf_le_right) h\n#align tendsto_inf_right tendsto_inf_right\n\n",
 "tendsto_inf_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem tendsto_inf_left {f : α → β} {x₁ x₂ : Filter α} {y : Filter β} (h : Tendsto f x₁ y) :\n    Tendsto f («expr ⊓ » x₁ x₂) y :=\n  le_trans (map_mono inf_le_left) h\n#align tendsto_inf_left tendsto_inf_left\n\n",
 "tendsto_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem tendsto_inf {f : α → β} {x : Filter α} {y₁ y₂ : Filter β} :\n    Tendsto f x («expr ⊓ » y₁ y₂) ↔ Tendsto f x y₁ ∧ Tendsto f x y₂ := by simp only [tendsto, le_inf_iff, iff_self_iff]\n#align tendsto_inf tendsto_inf\n\n",
 "tendsto_iff_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_iff_eventually {f : α → β} {l₁ : Filter α} {l₂ : Filter β} :\n    Tendsto f l₁ l₂ ↔\n      ∀ ⦃p : β → Prop⦄,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l₂\n            (p y) →\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l₁\n            (p (f x)) :=\n  iff.rfl\n#align tendsto_iff_eventually tendsto_iff_eventually\n\n",
 "tendsto_iff_comap":
 "theorem tendsto_iff_comap {f : α → β} {l₁ : Filter α} {l₂ : Filter β} : Tendsto f l₁ l₂ ↔ l₁ ≤ l₂.comap f :=\n  map_le_iff_le_comap\n#align tendsto_iff_comap tendsto_iff_comap\n\n",
 "tendsto_id'":
 "theorem tendsto_id' {x y : Filter α} : Tendsto id x y ↔ x ≤ y :=\n  iff.rfl\n#align tendsto_id' tendsto_id'\n\n",
 "tendsto_id":
 "theorem tendsto_id {x : Filter α} : Tendsto id x x :=\n  le_refl x\n#align tendsto_id tendsto_id\n\n",
 "tendsto_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem tendsto_def {f : α → β} {l₁ : Filter α} {l₂ : Filter β} : Tendsto f l₁ l₂ ↔ ∀ s ∈ l₂, «expr ⁻¹' » f s ∈ l₁ :=\n  iff.rfl\n#align tendsto_def tendsto_def\n\n",
 "tendsto_const_pure":
 "theorem tendsto_const_pure {a : Filter α} {b : β} : Tendsto (fun x => b) a (pure b) :=\n  tendsto_pure.2 <| univ_mem' fun _ => rfl\n#align tendsto_const_pure tendsto_const_pure\n\n",
 "tendsto_congr'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem tendsto_congr' {f₁ f₂ : α → β} {l₁ : Filter α} {l₂ : Filter β} (hl : «expr =ᶠ[ ] » f₁ l₁ f₂) :\n    Tendsto f₁ l₁ l₂ ↔ Tendsto f₂ l₁ l₂ := by rw [tendsto, tendsto, map_congr hl]\n#align tendsto_congr' tendsto_congr'\n\n",
 "tendsto_congr":
 "theorem tendsto_congr {f₁ f₂ : α → β} {l₁ : Filter α} {l₂ : Filter β} (h : ∀ x, f₁ x = f₂ x) :\n    Tendsto f₁ l₁ l₂ ↔ Tendsto f₂ l₁ l₂ :=\n  tendsto_congr' (univ_mem' h)\n#align tendsto_congr tendsto_congr\n\n",
 "tendsto_comap_iff":
 "@[simp]\ntheorem tendsto_comap_iff {f : α → β} {g : β → γ} {a : Filter α} {c : Filter γ} :\n    Tendsto f a (c.comap g) ↔ Tendsto (g ∘ f) a c :=\n  ⟨fun h => tendsto_comap.comp h, fun h => map_le_iff_le_comap.mp <| by rwa [map_map]⟩\n#align tendsto_comap_iff tendsto_comap_iff\n\n",
 "tendsto_comap'_iff":
 "theorem tendsto_comap'_iff {m : α → β} {f : Filter α} {g : Filter β} {i : γ → α} (h : range i ∈ f) :\n    Tendsto (m ∘ i) (comap i f) g ↔ Tendsto m f g :=\n  by\n  rw [tendsto, ← map_compose]\n  simp only [(· ∘ ·), map_comap_of_mem h, tendsto]\n#align tendsto_comap'_iff tendsto_comap'_iff\n\n",
 "tendsto_comap":
 "theorem tendsto_comap {f : α → β} {x : Filter β} : Tendsto f (comap f x) x :=\n  map_comap_le\n#align tendsto_comap tendsto_comap\n\n",
 "tendsto_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem tendsto_bot {f : α → β} {l : Filter β} : Tendsto f («expr⊥») l := by simp [tendsto]\n#align tendsto_bot tendsto_bot\n\n",
 "tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print Set.MapsTo.tendsto /-\ntheorem Set.MapsTo.tendsto {α β} {s : Set α} {t : Set β} {f : α → β} (h : MapsTo f s t) :\n    Filter.Tendsto f ((filter.principal) s) ((filter.principal) t) :=\n  Filter.tendsto_principal_principal.2 h\n#align set.maps_to.tendsto Set.MapsTo.tendsto\n-/\n\n",
 "symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n@[symm]\ntheorem eventually_eq.symm {f g : α → β} {l : Filter α} (H : «expr =ᶠ[ ] » f l g) : «expr =ᶠ[ ] » g l f :=\n  H.mono fun _ => Eq.symm\n#align eventually_eq.symm eventually_eq.symm\n\n",
 "supr_sets_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem supr_sets_eq {f : ι → Filter α} :\n    (supᵢ f).sets =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i).sets :=\n  (giGenerate α).gc.u_infi\n#align supr_sets_eq supr_sets_eq\n\n",
 "supr_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem supr_principal {ι : Sort w} {s : ι → Set α} :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        ((filter.principal) (s x)) =\n      (filter.principal)\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  Filter.ext fun x => by simp only [mem_supr, mem_principal, Union_subset_iff]\n#align supr_principal supr_principal\n\n",
 "supr_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem supr_ne_bot {f : ι → Filter α} :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)).ne_bot ↔\n      ∃ i, (f i).ne_bot :=\n  by simp [ne_bot_iff]\n#align supr_ne_bot supr_ne_bot\n\n",
 "supr_join":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem supr_join {ι : Sort w} {f : ι → Filter (Filter α)} :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (join (f x)) =\n      join («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f x)) :=\n  Filter.ext fun x => by simp only [mem_supr, mem_join]\n#align supr_join supr_join\n\n",
 "supr_inf_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem supr_inf_principal (f : ι → Filter α) (s : Set α) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr ⊓ » (f i) ((filter.principal) s)) =\n      «expr ⊓ » («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i))\n        ((filter.principal) s) :=\n  by\n  ext\n  simp only [mem_supr, mem_inf_principal]\n#align supr_inf_principal supr_inf_principal\n\n",
 "sup_sets_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_sets_eq {f g : Filter α} : («expr ⊔ » f g).sets = f.sets ∩ g.sets :=\n  (giGenerate α).gc.u_inf\n#align sup_sets_eq sup_sets_eq\n\n",
 "sup_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem sup_principal {s t : Set α} :\n    «expr ⊔ » ((filter.principal) s) ((filter.principal) t) = (filter.principal) (s ∪ t) :=\n  Filter.ext fun u => by simp only [union_subset_iff, mem_sup, mem_principal]\n#align sup_principal sup_principal\n\n",
 "sup_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem sup_ne_bot {f g : Filter α} : NeBot («expr ⊔ » f g) ↔ NeBot f ∨ NeBot g := by simp [ne_bot_iff, not_and_or]\n#align sup_ne_bot sup_ne_bot\n\n",
 "sup_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem eventually_le.sup_le [SemilatticeSup β] {l : Filter α} {f g h : α → β} (hf : «expr ≤ᶠ[ ] » f l h)\n    (hg : «expr ≤ᶠ[ ] » g l h) : «expr ≤ᶠ[ ] » («expr ⊔ » f g) l h := by\n  filter_upwards [hf, hg]with x hfx hgx using sup_le hfx hgx\n#align eventually_le.sup_le eventually_le.sup_le\n\n",
 "sup_join":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem sup_join {f₁ f₂ : Filter (Filter α)} : «expr ⊔ » (join f₁) (join f₂) = join («expr ⊔ » f₁ f₂) :=\n  Filter.ext fun x => by simp only [mem_sup, mem_join]\n#align sup_join sup_join\n\n",
 "sup_bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_bind {f g : Filter α} {h : α → Filter β} : bind («expr ⊔ » f g) h = «expr ⊔ » (bind f h) (bind g h) := by\n  simp only [bind, sup_join, map_sup, eq_self_iff_true]\n#align sup_bind sup_bind\n\n",
 "sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem tendsto.sup {f : α → β} {x₁ x₂ : Filter α} {y : Filter β} :\n    Tendsto f x₁ y → Tendsto f x₂ y → Tendsto f («expr ⊔ » x₁ x₂) y := fun h₁ h₂ => tendsto_sup.mpr ⟨h₁, h₂⟩\n#align tendsto.sup tendsto.sup\n\n",
 "subtype_coe_map_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem subtype_coe_map_comap (s : Set α) (f : Filter α) :\n    map (coe : s → α) (comap (coe : s → α) f) = «expr ⊓ » f ((filter.principal) s) := by\n  rw [map_comap, Subtype.range_coe]\n#align subtype_coe_map_comap subtype_coe_map_comap\n\n",
 "sub_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem eventually_eq.sub_eq [AddGroup β] {f g : α → β} {l : Filter α} (h : «expr =ᶠ[ ] » f l g) :\n    «expr =ᶠ[ ] » (f - g) l 0 := by simpa using (eventually_eq.sub (eventually_eq.refl l f) h).symm\n#align eventually_eq.sub_eq eventually_eq.sub_eq\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem eventually_eq.smul {𝕜} [SMul 𝕜 β] {l : Filter α} {f f' : α → 𝕜} {g g' : α → β} (hf : «expr =ᶠ[ ] » f l f')\n    (hg : «expr =ᶠ[ ] » g l g') : «expr =ᶠ[ ] » (fun x => «expr • » (f x) (g x)) l fun x => «expr • » (f' x) (g' x) :=\n  hf.comp₂ («expr • » · ·) hg\n#align eventually_eq.smul eventually_eq.smul\n\n",
 "singleton_mem_pure":
 "theorem singleton_mem_pure {a : α} : {a} ∈ (pure a : Filter α) :=\n  mem_singleton a\n#align singleton_mem_pure singleton_mem_pure\n\n",
 "sets_iff_generate":
 "theorem sets_iff_generate {s : Set (Set α)} {f : Filter α} : f ≤ Filter.generate s ↔ s ⊆ f.sets :=\n  iff.intro (fun h u hu => h <| generate_sets.basic <| hu) fun h u hu =>\n    hu.rec_on h univ_mem (fun x y _ hxy hx => mem_of_superset hx hxy) fun x y _ _ hx hy => inter_mem hx hy\n#align sets_iff_generate sets_iff_generate\n\n",
 "sequence_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- This is a separate section in order to open `list`, but mostly because of universe\n   equality requirements in `traverse` -/\ntheorem sequence_mono : ∀ as bs : List (Filter α), Forall₂ (· ≤ ·) as bs → sequence as ≤ sequence bs\n  | [], [], forall₂.nil => le_rfl\n  | sym.cons' a as, sym.cons' b bs, forall₂.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs)\n#align sequence_mono sequence_mono\n\n",
 "seq_pure":
 "@[simp]\ntheorem seq_pure (f : Filter (α → β)) (a : α) : seq f (pure a) = map (fun g : α → β => g a) f :=\n  by\n  refine' le_antisymm (le_map fun s hs => _) (le_seq fun s hs t ht => _)\n  · rw [← seq_singleton]\n    exact seq_mem_seq hs singleton_mem_pure\n  · refine' sets_of_superset (map (fun g : α → β => g a) f) (image_mem_map hs) _\n    rintro b ⟨g, hg, rfl⟩\n    exact ⟨g, hg, a, ht, rfl⟩\n#align seq_pure seq_pure\n\n",
 "seq_mono":
 "@[mono]\ntheorem seq_mono {f₁ f₂ : Filter (α → β)} {g₁ g₂ : Filter α} (hf : f₁ ≤ f₂) (hg : g₁ ≤ g₂) : f₁.seq g₁ ≤ f₂.seq g₂ :=\n  le_seq fun s hs t ht => seq_mem_seq (hf hs) (hg ht)\n#align seq_mono seq_mono\n\n",
 "seq_mem_seq":
 "theorem seq_mem_seq {f : Filter (α → β)} {g : Filter α} {s : Set (α → β)} {t : Set α} (hs : s ∈ f) (ht : t ∈ g) :\n    s.seq t ∈ f.seq g :=\n  ⟨s, hs, t, ht, fun f hf a ha => ⟨f, hf, a, ha, rfl⟩⟩\n#align seq_mem_seq seq_mem_seq\n\n",
 "seq_eq_filter_seq":
 "theorem seq_eq_filter_seq.{l} {α β : Type l} (f : Filter (α → β)) (g : Filter α) : f <*> g = seq f g :=\n  rfl\n#align seq_eq_filter_seq seq_eq_filter_seq\n\n",
 "seq_assoc":
 "@[simp]\ntheorem seq_assoc (x : Filter α) (g : Filter (α → β)) (h : Filter (β → γ)) :\n    seq h (seq g x) = seq (seq (map (· ∘ ·) h) g) x :=\n  by\n  refine' le_antisymm (le_seq fun s hs t ht => _) (le_seq fun s hs t ht => _)\n  · rcases mem_seq_iff.1 hs with ⟨u, hu, v, hv, hs⟩\n    rcases mem_map_iff_exists_image.1 hu with ⟨w, hw, hu⟩\n    refine' mem_of_superset _ (Set.seq_mono ((Set.seq_mono hu subset.rfl).trans hs) subset.rfl)\n    rw [← Set.seq_seq]\n    exact seq_mem_seq hw (seq_mem_seq hv ht)\n  · rcases mem_seq_iff.1 ht with ⟨u, hu, v, hv, ht⟩\n    refine' mem_of_superset _ (Set.seq_mono subset.rfl ht)\n    rw [Set.seq_seq]\n    exact seq_mem_seq (seq_mem_seq (image_mem_map hs) hu) hv\n#align seq_assoc seq_assoc\n\n",
 "sInter_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n@[simp]\ntheorem sInter_mem {s : Set (Set α)} (hfin : s.finite) : «expr⋂₀ » s ∈ f ↔ ∀ U ∈ s, U ∈ f := by\n  rw [sInter_eq_bInter, bInter_mem hfin]\n#align sInter_mem sInter_mem\n\n",
 "sInter_comap_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem sInter_comap_sets (f : α → β) (F : Filter β) :\n    «expr⋂₀ » (comap f F).sets =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        («expr ⁻¹' » f U) :=\n  by\n  ext x\n  suffices (∀ (A : Set α) (B : Set β), B ∈ F → «expr ⁻¹' » f B ⊆ A → x ∈ A) ↔ ∀ B : Set β, B ∈ F → f x ∈ B by\n    simp only [mem_sInter, mem_Inter, Filter.mem_sets, mem_comap, this, and_imp, exists_prop, mem_preimage, exists_imp]\n  constructor\n  · intro h U U_in\n    simpa only [subset.refl, forall_prop_of_true, mem_preimage] using h («expr ⁻¹' » f U) U U_in\n  · intro h V U U_in f_U_V\n    exact f_U_V (h U U_in)\n#align sInter_comap_sets sInter_comap_sets\n\n",
 "rw":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_eq.rw {l : Filter α} {f g : α → β} (h : «expr =ᶠ[ ] » f l g) (p : α → β → Prop)\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (p x (f x))) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (p x (g x)) :=\n  hf.congr <| h.mono fun x hx => hx ▸ iff.rfl\n#align eventually_eq.rw eventually_eq.rw\n\n",
 "rfl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem eventually_le.rfl : «expr ≤ᶠ[ ] » f l f :=\n  EventuallyLE.refl l f\n#align eventually_le.rfl eventually_le.rfl\n\n",
 "refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n@[refl]\ntheorem eventually_le.refl (l : Filter α) (f : α → β) : «expr ≤ᶠ[ ] » f l f :=\n  EventuallyEq.rfl.le\n#align eventually_le.refl eventually_le.refl\n\n",
 "range_mem_map":
 "theorem range_mem_map : range m ∈ map m f := by\n  rw [← image_univ]\n  exact image_mem_map univ_mem\n#align range_mem_map range_mem_map\n\n",
 "push_pull'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\nprotected theorem push_pull' (f : α → β) (F : Filter α) (G : Filter β) :\n    map f («expr ⊓ » (comap f G) F) = «expr ⊓ » G (map f F) := by simp only [Filter.push_pull, inf_comm]\n#align push_pull' push_pull'\n\n",
 "push_pull":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\nprotected theorem push_pull (f : α → β) (F : Filter α) (G : Filter β) :\n    map f («expr ⊓ » F (comap f G)) = «expr ⊓ » (map f F) G :=\n  by\n  apply le_antisymm\n  ·\n    calc\n      map f («expr ⊓ » F (comap f G)) ≤ «expr ⊓ » (map f F) (map f <| comap f G) := map_inf_le\n      _ ≤ «expr ⊓ » (map f F) G := inf_le_inf_left (map f F) map_comap_le\n      \n  · rintro U ⟨V, V_in, W, ⟨Z, Z_in, hZ⟩, h⟩\n    apply mem_inf_of_inter (image_mem_map V_in) Z_in\n    calc\n      «expr '' » f V ∩ Z = «expr '' » f (V ∩ «expr ⁻¹' » f Z) := by rw [image_inter_preimage]\n      _ ⊆ «expr '' » f (V ∩ W) := (image_subset _ (inter_subset_inter_right _ ‹_›))\n      _ = «expr '' » f («expr ⁻¹' » f U) := by rw [h]\n      _ ⊆ U := image_preimage_subset f U\n      \n#align push_pull push_pull\n\n",
 "pure_sets":
 "theorem pure_sets (a : α) : (pure a : Filter α).sets = { s | a ∈ s } :=\n  rfl\n#align pure_sets pure_sets\n\n",
 "pure_seq_eq_map":
 "@[simp]\ntheorem pure_seq_eq_map (g : α → β) (f : Filter α) : seq (pure g) f = f.map g :=\n  by\n  refine' le_antisymm (le_map fun s hs => _) (le_seq fun s hs t ht => _)\n  · rw [← singleton_seq]\n    apply seq_mem_seq _ hs\n    exact singleton_mem_pure\n  · refine' sets_of_superset (map g f) (image_mem_map ht) _\n    rintro b ⟨a, ha, rfl⟩\n    exact ⟨g, hs, a, ha, rfl⟩\n#align pure_seq_eq_map pure_seq_eq_map\n\n",
 "pure_le_iff":
 "theorem pure_le_iff {a : α} {l : Filter α} : pure a ≤ l ↔ ∀ s ∈ l, a ∈ s :=\n  iff.rfl\n#align pure_le_iff pure_le_iff\n\n",
 "pure_injective":
 "theorem pure_injective : injective (pure : α → Filter α) := fun a b hab => (Filter.ext_iff.1 hab { x | a = x }).1 rfl\n#align pure_injective pure_injective\n\n",
 "pure_bind":
 "@[simp]\ntheorem pure_bind (a : α) (m : α → Filter β) : bind (pure a) m = m a := by\n  simp only [has_bind.bind, bind, map_pure, join_pure]\n#align pure_bind pure_bind\n\n",
 "prod_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem eventually_eq.prod_mk {l} {f f' : α → β} (hf : «expr =ᶠ[ ] » f l f') {g g' : α → γ}\n    (hg : «expr =ᶠ[ ] » g l g') : «expr =ᶠ[ ] » (fun x => (f x, g x)) l fun x => (f' x, g' x) :=\n  hf.mp <|\n    hg.mono <| by\n      intros\n      simp only [*]\n#align eventually_eq.prod_mk eventually_eq.prod_mk\n\n",
 "prod_map_seq_comm":
 "theorem prod_map_seq_comm (f : Filter α) (g : Filter β) : (map prod.mk f).seq g = seq (map (fun b a => (a, b)) g) f :=\n  by\n  refine' le_antisymm (le_seq fun s hs t ht => _) (le_seq fun s hs t ht => _)\n  · rcases mem_map_iff_exists_image.1 hs with ⟨u, hu, hs⟩\n    refine' mem_of_superset _ (Set.seq_mono hs subset.rfl)\n    rw [← Set.prod_image_seq_comm]\n    exact seq_mem_seq (image_mem_map ht) hu\n  · rcases mem_map_iff_exists_image.1 hs with ⟨u, hu, hs⟩\n    refine' mem_of_superset _ (Set.seq_mono hs subset.rfl)\n    rw [Set.prod_image_seq_comm]\n    exact seq_mem_seq (image_mem_map ht) hu\n#align prod_map_seq_comm prod_map_seq_comm\n\n",
 "principal_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem principal_univ : (filter.principal) (univ : Set α) = «expr⊤» :=\n  top_unique <| by simp only [le_principal_iff, mem_top, eq_self_iff_true]\n#align principal_univ principal_univ\n\n",
 "principal_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem principal_singleton (a : α) : (filter.principal) {a} = pure a :=\n  Filter.ext fun s => by simp only [mem_pure, mem_principal, singleton_subset_iff]\n#align principal_singleton principal_singleton\n\n",
 "principal_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem principal_ne_bot_iff {s : Set α} : NeBot ((filter.principal) s) ↔ s.nonempty :=\n  neBot_iff.trans <| (not_congr principal_eq_bot_iff).trans nonempty_iff_ne_empty.symm\n#align principal_ne_bot_iff principal_ne_bot_iff\n\n",
 "principal_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem principal_mono {s t : Set α} : (filter.principal) s ≤ (filter.principal) t ↔ s ⊆ t := by\n  simp only [le_principal_iff, iff_self_iff, mem_principal]\n#align principal_mono principal_mono\n\n",
 "principal_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem principal_le_iff {s : Set α} {f : Filter α} : (filter.principal) s ≤ f ↔ ∀ V ∈ f, s ⊆ V :=\n  by\n  change (∀ V, V ∈ f → V ∈ _) ↔ _\n  simp_rw [mem_principal]\n#align principal_le_iff principal_le_iff\n\n",
 "principal_eq_map_coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem principal_eq_map_coe_top (s : Set α) : (filter.principal) s = map (coe : s → α) («expr⊤») := by simp\n#align principal_eq_map_coe_top principal_eq_map_coe_top\n\n",
 "principal_eq_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem principal_eq_iff_eq {s t : Set α} : (filter.principal) s = (filter.principal) t ↔ s = t := by\n  simp only [le_antisymm_iff, le_principal_iff, mem_principal] <;> rfl\n#align principal_eq_iff_eq principal_eq_iff_eq\n\n",
 "principal_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem principal_eq_bot_iff {s : Set α} : (filter.principal) s = «expr⊥» ↔ s = ∅ :=\n  empty_mem_iff_bot.symm.trans <| mem_principal.trans subset_empty_iff\n#align principal_eq_bot_iff principal_eq_bot_iff\n\n",
 "principal_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem principal_empty : (filter.principal) (∅ : Set α) = «expr⊥» :=\n  bot_unique fun s _ => empty_subset _\n#align principal_empty principal_empty\n\n",
 "principal_bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem principal_bind {s : Set α} {f : α → Filter β} :\n    bind ((filter.principal) s) f =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f x) :=\n  show\n    join (map f ((filter.principal) s)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f x)\n    by simp only [supₛ_image, join_principal_eq_Sup, map_principal, eq_self_iff_true]\n#align principal_bind principal_bind\n\n",
 "preimage_mem_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_mem_comap (ht : t ∈ g) : «expr ⁻¹' » m t ∈ comap m g :=\n  ⟨t, ht, Subset.rfl⟩\n#align preimage_mem_comap preimage_mem_comap\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem eventually_eq.preimage {l : Filter α} {f g : α → β} (h : «expr =ᶠ[ ] » f l g) (s : Set β) :\n    «expr =ᶠ[ ] » («expr ⁻¹' » f s) l («expr ⁻¹' » g s) :=\n  h.fun_comp s\n#align eventually_eq.preimage eventually_eq.preimage\n\n",
 "piecewise":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\nprotected theorem tendsto.piecewise {l₁ : Filter α} {l₂ : Filter β} {f g : α → β} {s : Set α} [∀ x, Decidable (x ∈ s)]\n    (h₀ : Tendsto f («expr ⊓ » l₁ ((filter.principal) s)) l₂)\n    (h₁ : Tendsto g («expr ⊓ » l₁ ((filter.principal) («expr ᶜ» s))) l₂) : Tendsto (piecewise s f g) l₁ l₂ :=\n  h₀.if h₁\n#align tendsto.piecewise tendsto.piecewise\n\n",
 "of_tendsto_comp":
 "theorem tendsto.of_tendsto_comp {f : α → β} {g : β → γ} {a : Filter α} {b : Filter β} {c : Filter γ}\n    (hfg : Tendsto (g ∘ f) a c) (hg : comap g c ≤ b) : Tendsto f a b :=\n  by\n  rw [tendsto_iff_comap] at hfg⊢\n  calc\n    a ≤ comap (g ∘ f) c := hfg\n    _ ≤ comap f b := by simpa [comap_comap] using comap_mono hg\n    \n#align tendsto.of_tendsto_comp tendsto.of_tendsto_comp\n\n",
 "of_map":
 "theorem ne_bot.of_map : NeBot (f.map m) → NeBot f :=\n  (map_neBot_iff m).1\n#align ne_bot.of_map ne_bot.of_map\n\n",
 "not_tendsto":
 "/-- If two filters are disjoint, then a function cannot tend to both of them along a non-trivial\nfilter. -/\ntheorem tendsto.not_tendsto {f : α → β} {a : Filter α} {b₁ b₂ : Filter β} (hf : Tendsto f a b₁) [NeBot a]\n    (hb : Disjoint b₁ b₂) : ¬Tendsto f a b₂ := fun hf' => (tendsto_inf.2 ⟨hf, hf'⟩).ne_bot.ne hb.eq_bot\n#align tendsto.not_tendsto tendsto.not_tendsto\n\n",
 "not_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem not_ne_bot {α : Type _} {f : Filter α} : ¬f.ne_bot ↔ f = «expr⊥» :=\n  not_iff_comm.1 neBot_iff.symm\n#align not_ne_bot not_ne_bot\n\n",
 "not_le":
 "#print not_le /-\nprotected theorem not_le : ¬f ≤ g ↔ ∃ s ∈ g, s ∉ f := by simp_rw [le_def, not_forall]\n#align not_le not_le\n-/\n\n",
 "not_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem not_frequently {p : α → Prop} {f : Filter α} :\n    ¬«expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (p x) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f ¬p x :=\n  by simp only [Filter.Frequently, Classical.not_not]\n#align not_frequently not_frequently\n\n",
 "not_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n@[simp]\ntheorem not_eventually {p : α → Prop} {f : Filter α} :\n    ¬«expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (p x) ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f ¬p x :=\n  by simp [Filter.Frequently]\n#align not_eventually not_eventually\n\n",
 "not_disjoint_self_iff":
 "theorem not_disjoint_self_iff : ¬Disjoint f f ↔ f.ne_bot := by rw [disjoint_self, ne_bot_iff]\n#align not_disjoint_self_iff not_disjoint_self_iff\n\n",
 "not_disjoint":
 "theorem ne_bot.not_disjoint (hf : f.ne_bot) (hs : s ∈ f) (ht : t ∈ f) : ¬Disjoint s t := fun h =>\n  not_disjoint_self_iff.2 hf <| Filter.disjoint_iff.2 ⟨s, hs, t, ht, h⟩\n#align ne_bot.not_disjoint ne_bot.not_disjoint\n\n",
 "nontrivial_iff_nonempty":
 "theorem nontrivial_iff_nonempty : Nontrivial (Filter α) ↔ Nonempty α :=\n  ⟨fun h =>\n    by_contra fun h' =>\n      haveI := not_nonempty_iff.1 h'\n      not_subsingleton (Filter α) inferInstance,\n    @filter.nontrivial α⟩\n#align nontrivial_iff_nonempty nontrivial_iff_nonempty\n\n",
 "nonempty_of_ne_bot":
 "theorem nonempty_of_ne_bot (f : Filter α) [NeBot f] : Nonempty α :=\n  nonempty_of_exists <| nonempty_of_mem (univ_mem : univ ∈ f)\n#align nonempty_of_ne_bot nonempty_of_ne_bot\n\n",
 "nonempty_of_mem":
 "theorem ne_bot.nonempty_of_mem {f : Filter α} (hf : NeBot f) {s : Set α} (hs : s ∈ f) : s.nonempty :=\n  @nonempty_of_mem α f hf s hs\n#align ne_bot.nonempty_of_mem ne_bot.nonempty_of_mem\n\n",
 "ne_top_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eventually.ne_top_of_lt [partial_order β] [OrderTop β] {l : Filter α} {f g : α → β}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (f x < g x)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (f x ≠ «expr⊤») :=\n  h.mono fun x hx => hx.ne_top\n#align eventually.ne_top_of_lt eventually.ne_top_of_lt\n\n",
 "ne_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually.ne_of_lt [preorder β] {l : Filter α} {f g : α → β}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (f x < g x)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (f x ≠ g x) :=\n  h.mono fun x hx => hx.ne\n#align eventually.ne_of_lt eventually.ne_of_lt\n\n",
 "ne_bot_of_le":
 "theorem ne_bot_of_le {f g : Filter α} [hf : NeBot f] (hg : f ≤ g) : NeBot g :=\n  hf.mono hg\n#align ne_bot_of_le ne_bot_of_le\n\n",
 "ne_bot_of_comap":
 "theorem ne_bot_of_comap (h : (comap m g).ne_bot) : g.ne_bot :=\n  by\n  rw [ne_bot_iff] at *\n  contrapose! h\n  rw [h]\n  exact comap_bot\n#align ne_bot_of_comap ne_bot_of_comap\n\n",
 "ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- We lift the complete lattice along the Galois connection `generate` / `sets`. Unfortunately,\n  we want to have different definitional equalities for the lattice operations. So we define them\n  upfront and change the lattice operations for the complete lattice instance. -/\n-- le  \n-- top \n-- bot \n-- sup \n-- inf \n-- Sup \n-- Inf\ntheorem ne_bot_iff {f : Filter α} : NeBot f ↔ f ≠ «expr⊥» :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n#align ne_bot_iff ne_bot_iff\n\n",
 "ne_bot":
 "theorem tendsto.ne_bot {f : α → β} {x : Filter α} {y : Filter β} (h : Tendsto f x y) [hx : NeBot x] : NeBot y :=\n  (hx.map _).mono h\n#align tendsto.ne_bot tendsto.ne_bot\n\n",
 "ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ne_bot.ne {f : Filter α} (hf : NeBot f) : f ≠ «expr⊥» :=\n  ne_bot.ne'\n#align ne_bot.ne ne_bot.ne\n\n",
 "mul_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem eventually_le.mul_nonneg [OrderedSemiring β] {l : Filter α} {f g : α → β} (hf : «expr ≤ᶠ[ ] » 0 l f)\n    (hg : «expr ≤ᶠ[ ] » 0 l g) : «expr ≤ᶠ[ ] » 0 l (f * g) := by filter_upwards [hf, hg]with x using mul_nonneg\n#align eventually_le.mul_nonneg eventually_le.mul_nonneg\n\n",
 "mul_le_mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n@[to_additive eventually_le.add_le_add]\ntheorem eventually_le.mul_le_mul' [Mul β] [preorder β] [CovariantClass β β (· * ·) (· ≤ ·)]\n    [CovariantClass β β (swap (· * ·)) (· ≤ ·)] {l : Filter α} {f₁ f₂ g₁ g₂ : α → β} (hf : «expr ≤ᶠ[ ] » f₁ l f₂)\n    (hg : «expr ≤ᶠ[ ] » g₁ l g₂) : «expr ≤ᶠ[ ] » (f₁ * g₁) l (f₂ * g₂) := by\n  filter_upwards [hf, hg]with x hfx hgx using mul_le_mul' hfx hgx\n#align eventually_le.mul_le_mul' eventually_le.mul_le_mul'\n\n",
 "mul_le_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem eventually_le.mul_le_mul [MulZeroClass β] [partial_order β] [PosMulMono β] [MulPosMono β] {l : Filter α}\n    {f₁ f₂ g₁ g₂ : α → β} (hf : «expr ≤ᶠ[ ] » f₁ l f₂) (hg : «expr ≤ᶠ[ ] » g₁ l g₂) (hg₀ : «expr ≤ᶠ[ ] » 0 l g₁)\n    (hf₀ : «expr ≤ᶠ[ ] » 0 l f₂) : «expr ≤ᶠ[ ] » (f₁ * g₁) l (f₂ * g₂) := by\n  filter_upwards [hf, hg, hg₀, hf₀]with x using mul_le_mul\n#align eventually_le.mul_le_mul eventually_le.mul_le_mul\n\n",
 "mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n@[to_additive]\ntheorem eventually_eq.mul [Mul β] {f f' g g' : α → β} {l : Filter α} (h : «expr =ᶠ[ ] » f l g)\n    (h' : «expr =ᶠ[ ] » f' l g') : «expr =ᶠ[ ] » (fun x => f x * f' x) l fun x => g x * g' x :=\n  h.comp₂ (· * ·) h'\n#align eventually_eq.mul eventually_eq.mul\n\n",
 "mp_mem":
 "theorem mp_mem (hs : s ∈ f) (h : { x | x ∈ s → x ∈ t } ∈ f) : t ∈ f :=\n  mem_of_superset (inter_mem hs h) fun x ⟨h₁, h₂⟩ => h₂ h₁\n#align mp_mem mp_mem\n\n",
 "mp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently.mp {p q : α → Prop} {f : Filter α}\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (p x))\n    (hpq :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (p x → q x)) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (q x) :=\n  mt (fun hq => hq.mp <| hpq.mono fun x => mt) h\n#align frequently.mp frequently.mp\n\n",
 "monotone_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[mono]\ntheorem monotone_principal : Monotone (filter.principal : Set α → Filter α) := fun _ _ => principal_mono.2\n#align monotone_principal monotone_principal\n\n",
 "monotone_mem":
 "theorem monotone_mem {f : Filter α} : Monotone fun s => s ∈ f := fun s t hst h => mem_of_superset h hst\n#align monotone_mem monotone_mem\n\n",
 "mono_right":
 "theorem tendsto.mono_right {f : α → β} {x : Filter α} {y z : Filter β} (hy : Tendsto f x y) (hz : y ≤ z) :\n    Tendsto f x z :=\n  le_trans hy hz\n#align tendsto.mono_right tendsto.mono_right\n\n",
 "mono_left":
 "theorem tendsto.mono_left {f : α → β} {x y : Filter α} {z : Filter β} (hx : Tendsto f x z) (h : y ≤ x) :\n    Tendsto f y z :=\n  (map_mono h).trans hx\n#align tendsto.mono_left tendsto.mono_left\n\n",
 "mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently.mono {p q : α → Prop} {f : Filter α}\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (p x))\n    (hpq : ∀ x, p x → q x) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (q x) :=\n  h.mp (eventually_of_forall hpq)\n#align frequently.mono frequently.mono\n\n",
 "mk_of_closure_sets":
 "theorem mk_of_closure_sets {s : Set (Set α)} {hs : (generate s).sets = s} : Filter.mkOfClosure s hs = generate s :=\n  Filter.ext fun u => show u ∈ (Filter.mkOfClosure s hs).sets ↔ u ∈ (generate s).sets from hs.symm ▸ iff.rfl\n#align mk_of_closure_sets mk_of_closure_sets\n\n",
 "mem_traverse_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem mem_traverse_iff (fs : List β') (t : Set (List α')) :\n    t ∈ traverse f fs ↔ ∃ us : List (Set α'), Forall₂ (fun b (s : Set α') => s ∈ f b) fs us ∧ sequence us ⊆ t :=\n  by\n  constructor\n  · induction fs generalizing t\n    case nil =>\n      simp only [sequence, mem_pure, imp_self, forall₂_nil_left_iff, exists_eq_left, Set.pure_def, singleton_subset_iff,\n        traverse_nil]\n    case cons b fs ih t =>\n      intro ht\n      rcases mem_seq_iff.1 ht with ⟨u, hu, v, hv, ht⟩\n      rcases mem_map_iff_exists_image.1 hu with ⟨w, hw, hwu⟩\n      rcases ih v hv with ⟨us, hus, hu⟩\n      exact ⟨sym.cons' w us, forall₂.cons hw hus, (Set.seq_mono hwu hu).trans ht⟩\n  · rintro ⟨us, hus, hs⟩\n    exact mem_of_superset (mem_traverse _ _ hus) hs\n#align mem_traverse_iff mem_traverse_iff\n\n",
 "mem_traverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem mem_traverse :\n    ∀ (fs : List β') (us : List γ'), Forall₂ (fun b c => s c ∈ f b) fs us → traverse s us ∈ traverse f fs\n  | [], [], forall₂.nil => mem_pure.2 <| mem_singleton _\n  | sym.cons' f fs, sym.cons' u us, forall₂.cons h hs => seq_mem_seq (image_mem_map h) (mem_traverse fs us hs)\n#align mem_traverse mem_traverse\n\n",
 "mem_top_iff_forall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem mem_top_iff_forall {s : Set α} : s ∈ («expr⊤» : Filter α) ↔ ∀ x, x ∈ s :=\n  iff.rfl\n#align mem_top_iff_forall mem_top_iff_forall\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem mem_top {s : Set α} : s ∈ («expr⊤» : Filter α) ↔ s = univ := by rw [mem_top_iff_forall, eq_univ_iff_forall]\n#align mem_top mem_top\n\n",
 "mem_supr":
 "@[simp]\ntheorem mem_supr {x : Set α} {f : ι → Filter α} : x ∈ supᵢ f ↔ ∀ i, x ∈ f i := by\n  simp only [← Filter.mem_sets, supr_sets_eq, iff_self_iff, mem_Inter]\n#align mem_supr mem_supr\n\n",
 "mem_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem mem_sup {f g : Filter α} {s : Set α} : s ∈ «expr ⊔ » f g ↔ s ∈ f ∧ s ∈ g :=\n  iff.rfl\n#align mem_sup mem_sup\n\n",
 "mem_sets":
 "@[simp]\nprotected theorem mem_sets : s ∈ f.sets ↔ s ∈ f :=\n  iff.rfl\n#align mem_sets mem_sets\n\n",
 "mem_seq_iff":
 "theorem mem_seq_iff {f : Filter (α → β)} {g : Filter α} {s : Set β} : s ∈ f.seq g ↔ ∃ u ∈ f, ∃ t ∈ g, Set.seq u t ⊆ s :=\n  by simp only [mem_seq_def, seq_subset, exists_prop, iff_self_iff]\n#align mem_seq_iff mem_seq_iff\n\n",
 "mem_seq_def":
 "theorem mem_seq_def {f : Filter (α → β)} {g : Filter α} {s : Set β} :\n    s ∈ f.seq g ↔ ∃ u ∈ f, ∃ t ∈ g, ∀ x ∈ u, ∀ y ∈ t, (x : α → β) y ∈ s :=\n  iff.rfl\n#align mem_seq_def mem_seq_def\n\n",
 "mem_pure":
 "@[simp]\ntheorem mem_pure {a : α} {s : Set α} : s ∈ (pure a : Filter α) ↔ a ∈ s :=\n  iff.rfl\n#align mem_pure mem_pure\n\n",
 "mem_principal_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem mem_principal_self (s : Set α) : s ∈ (filter.principal) s :=\n  Subset.rfl\n#align mem_principal_self mem_principal_self\n\n",
 "mem_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem mem_principal {s t : Set α} : s ∈ (filter.principal) t ↔ t ⊆ s :=\n  iff.rfl\n#align mem_principal mem_principal\n\n",
 "mem_of_superset":
 "theorem mem_of_superset {x y : Set α} (hx : x ∈ f) (hxy : x ⊆ y) : y ∈ f :=\n  f.sets_of_superset hx hxy\n#align mem_of_superset mem_of_superset\n\n",
 "mem_of_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem mem_of_eq_bot {f : Filter α} {s : Set α} (h : «expr ⊓ » f ((filter.principal) («expr ᶜ» s)) = «expr⊥») :\n    s ∈ f := by rwa [inf_principal_eq_bot, compl_compl] at h\n#align mem_of_eq_bot mem_of_eq_bot\n\n",
 "mem_mk":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Jeremy Avigad\n-/\n@[simp]\nprotected theorem mem_mk {t : Set (Set α)} {h₁ h₂ h₃} : s ∈ mk t h₁ h₂ h₃ ↔ s ∈ t :=\n  iff.rfl\n#align mem_mk mem_mk\n\n",
 "mem_map_seq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_map_seq_iff {f : Filter α} {g : Filter β} {m : α → β → γ} {s : Set γ} :\n    s ∈ (f.map m).seq g ↔ ∃ t u, t ∈ g ∧ u ∈ f ∧ ∀ x ∈ u, ∀ y ∈ t, m x y ∈ s :=\n  iff.intro (fun ⟨t, ht, s, hs, hts⟩ => ⟨s, «expr ⁻¹' » m t, hs, ht, fun a => hts _⟩) fun ⟨t, s, ht, hs, hts⟩ =>\n    ⟨«expr '' » m s, image_mem_map hs, t, ht, fun f ⟨a, has, Eq⟩ => Eq ▸ hts _ has⟩\n#align mem_map_seq_iff mem_map_seq_iff\n\n",
 "mem_map_iff_exists_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_map_iff_exists_image : t ∈ map m f ↔ ∃ s ∈ f, «expr '' » m s ⊆ t :=\n  ⟨fun ht => ⟨«expr ⁻¹' » m t, ht, image_preimage_subset _ _⟩, fun ⟨s, hs, ht⟩ => mem_of_superset (image_mem_map hs) ht⟩\n#align mem_map_iff_exists_image mem_map_iff_exists_image\n\n",
 "mem_map'":
 "theorem mem_map' : t ∈ map m f ↔ { x | m x ∈ t } ∈ f :=\n  iff.rfl\n#align mem_map' mem_map'\n\n",
 "mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem mem_map : t ∈ map m f ↔ «expr ⁻¹' » m t ∈ f :=\n  iff.rfl\n#align mem_map mem_map\n\n",
 "mem_join":
 "@[simp]\ntheorem mem_join {s : Set α} {f : Filter (Filter α)} : s ∈ join f ↔ { t | s ∈ t } ∈ f :=\n  iff.rfl\n#align mem_join mem_join\n\n",
 "mem_infi_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem mem_infi_of_mem {f : ι → Filter α} (i : ι) :\n    ∀ {s},\n      s ∈ f i →\n        s ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i) :=\n  show «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i) ≤ f i from\n    infᵢ_le _ _\n#align mem_infi_of_mem mem_infi_of_mem\n\n",
 "mem_infi_of_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem mem_infi_of_finite {ι : Type _} [Finite ι] {α : Type _} {f : ι → Filter α} (s) :\n    s ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i) ↔\n      ∃ t : ι → Set α,\n        (∀ i, t i ∈ f i) ∧\n          s = «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (t i) :=\n  by\n  refine' ⟨exists_Inter_of_mem_infi, _⟩\n  rintro ⟨t, ht, rfl⟩\n  exact Inter_mem.2 fun i => mem_infi_of_mem i (ht i)\n#align mem_infi_of_finite mem_infi_of_finite\n\n",
 "mem_infi_of_directed":
 "theorem mem_infi_of_directed {f : ι → Filter α} (h : Directed (· ≥ ·) f) [Nonempty ι] (s) : s ∈ infᵢ f ↔ ∃ i, s ∈ f i :=\n  by simp only [← Filter.mem_sets, infi_sets_eq h, mem_Union]\n#align mem_infi_of_directed mem_infi_of_directed\n\n",
 "mem_infi_of_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem mem_infi_of_Inter {ι} {s : ι → Filter α} {U : Set α} {I : Set ι} (I_fin : I.finite) {V : I → Set α}\n    (hV : ∀ i, V i ∈ s i)\n    (hU : «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (V i) ⊆ U) :\n    U ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (s i) :=\n  by\n  haveI := I_fin.fintype\n  refine' mem_of_superset (Inter_mem.2 fun i => _) hU\n  exact mem_infi_of_mem i (hV _)\n#align mem_infi_of_Inter mem_infi_of_Inter\n\n",
 "mem_infi_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n-- The dual version does not hold! `filter α` is not a `complete_distrib_lattice`. -/\ntheorem mem_infi_finset {s : Finset α} {f : α → Filter β} {t : Set β} :\n    t ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f a) ↔\n      ∃ p : α → Set β,\n        (∀ a ∈ s, p a ∈ f a) ∧\n          t = «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (p a) :=\n  by\n  simp only [← Finset.set_binterᵢ_coe, bInter_eq_Inter, infᵢ_subtype']\n  refine' ⟨fun h => _, _⟩\n  · rcases(mem_infi_of_finite _).1 h with ⟨p, hp, rfl⟩\n    refine' ⟨fun a => if h : a ∈ s then p ⟨a, h⟩ else univ, fun a ha => by simpa [ha] using hp ⟨a, ha⟩, _⟩\n    refine' Inter_congr_of_surjective id surjective_id _\n    rintro ⟨a, ha⟩\n    simp [ha]\n  · rintro ⟨p, hpf, rfl⟩\n    exact Inter_mem.2 fun a => mem_infi_of_mem a (hpf a a.2)\n#align mem_infi_finset mem_infi_finset\n\n",
 "mem_infi_finite'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem mem_infi_finite' {f : ι → Filter α} (s) :\n    s ∈ infᵢ f ↔\n      ∃ t : Finset (PLift ι),\n        s ∈\n          «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (f (PLift.down i)) :=\n  (Set.ext_iff.1 (infᵢ_sets_eq_finite' f) s).trans mem_unionᵢ\n#align mem_infi_finite' mem_infi_finite'\n\n",
 "mem_infi_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem mem_infi_finite {ι : Type _} {f : ι → Filter α} (s) :\n    s ∈ infᵢ f ↔\n      ∃ t : Finset ι,\n        s ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i) :=\n  (Set.ext_iff.1 (infᵢ_sets_eq_finite f) s).trans mem_unionᵢ\n#align mem_infi_finite mem_infi_finite\n\n",
 "mem_infi'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (i «expr ∉ » I) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem mem_infi' {ι} {s : ι → Filter α} {U : Set α} :\n    U ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (s i) ↔\n      ∃ I : Set ι,\n        I.finite ∧\n          ∃ V : ι → Set α,\n            (∀ i, V i ∈ s i) ∧\n              (∀ (i) (_ : i ∉ I), V i = univ) ∧\n                U =\n                    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n                      (V i) ∧\n                  U =\n                    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n                      (V i) :=\n  by\n  simp only [mem_infi, SetCoe.forall', bInter_eq_Inter]\n  refine' ⟨_, fun ⟨I, If, V, hVs, _, hVU, _⟩ => ⟨I, If, fun i => V i, fun i => hVs i, hVU⟩⟩\n  rintro ⟨I, If, V, hV, rfl⟩\n  refine' ⟨I, If, fun i => if hi : i ∈ I then V ⟨i, hi⟩ else univ, fun i => _, fun i hi => _, _⟩\n  · split_ifs\n    exacts[hV _, univ_mem]\n  · exact dif_neg hi\n  ·\n    simp only [Inter_dite, bInter_eq_Inter, dif_pos (Subtype.coe_prop _), Subtype.coe_eta, Inter_univ, inter_univ,\n      eq_self_iff_true, true_and_iff]\n#align mem_infi' mem_infi'\n\n",
 "mem_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem mem_infi {ι} {s : ι → Filter α} {U : Set α} :\n    U ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (s i) ↔\n      ∃ I : Set ι,\n        I.finite ∧\n          ∃ V : I → Set α,\n            (∀ i, V i ∈ s i) ∧\n              U =\n                «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (V i) :=\n  by\n  constructor\n  · rw [infi_eq_generate, mem_generate_iff]\n    rintro ⟨t, tsub, tfin, tinter⟩\n    rcases eq_finite_Union_of_finite_subset_Union tfin tsub with ⟨I, Ifin, σ, σfin, σsub, rfl⟩\n    rw [sInter_Union] at tinter\n    set V := fun i => U ∪ «expr⋂₀ » (σ i) with hV\n    have V_in : ∀ i, V i ∈ s i := by\n      rintro i\n      have : «expr⋂₀ » (σ i) ∈ s i := by\n        rw [sInter_mem (σfin _)]\n        apply σsub\n      exact mem_of_superset this (subset_union_right _ _)\n    refine' ⟨I, Ifin, V, V_in, _⟩\n    rwa [hV, ← union_Inter, union_eq_self_of_subset_right]\n  · rintro ⟨I, Ifin, V, V_in, rfl⟩\n    exact mem_infi_of_Inter Ifin V_in subset.rfl\n#align mem_infi mem_infi\n\n",
 "mem_inf_principal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_inf_principal' {f : Filter α} {s t : Set α} : s ∈ «expr ⊓ » f ((filter.principal) t) ↔ «expr ᶜ» t ∪ s ∈ f :=\n  by\n  simp only [← le_principal_iff, (is_compl_principal s).le_left_iff, disjoint_assoc, inf_principal, ←\n    (is_compl_principal (t ∩ «expr ᶜ» s)).le_right_iff, compl_inter, compl_compl]\n#align mem_inf_principal' mem_inf_principal'\n\n",
 "mem_inf_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem mem_inf_principal {f : Filter α} {s t : Set α} :\n    s ∈ «expr ⊓ » f ((filter.principal) t) ↔ { x | x ∈ t → x ∈ s } ∈ f :=\n  by\n  simp only [mem_inf_principal', imp_iff_not_or]\n  rfl\n#align mem_inf_principal mem_inf_principal\n\n",
 "mem_inf_of_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem mem_inf_of_right {f g : Filter α} {s : Set α} (h : s ∈ g) : s ∈ «expr ⊓ » f g :=\n  ⟨univ, univ_mem, s, h, (univ_inter s).symm⟩\n#align mem_inf_of_right mem_inf_of_right\n\n",
 "mem_inf_of_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem mem_inf_of_left {f g : Filter α} {s : Set α} (h : s ∈ f) : s ∈ «expr ⊓ » f g :=\n  ⟨s, h, univ, univ_mem, (inter_univ s).symm⟩\n#align mem_inf_of_left mem_inf_of_left\n\n",
 "mem_inf_of_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem mem_inf_of_inter {f g : Filter α} {s t u : Set α} (hs : s ∈ f) (ht : t ∈ g) (h : s ∩ t ⊆ u) :\n    u ∈ «expr ⊓ » f g :=\n  mem_of_superset (inter_mem_inf hs ht) h\n#align mem_inf_of_inter mem_inf_of_inter\n\n",
 "mem_inf_iff_superset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem mem_inf_iff_superset {f g : Filter α} {s : Set α} : s ∈ «expr ⊓ » f g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, t₁ ∩ t₂ ⊆ s :=\n  ⟨fun ⟨t₁, h₁, t₂, h₂, Eq⟩ => ⟨t₁, h₁, t₂, h₂, Eq ▸ Subset.rfl⟩, fun ⟨t₁, h₁, t₂, h₂, sub⟩ =>\n    mem_inf_of_inter h₁ h₂ sub⟩\n#align mem_inf_iff_superset mem_inf_iff_superset\n\n",
 "mem_inf_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem mem_inf_iff {f g : Filter α} {s : Set α} : s ∈ «expr ⊓ » f g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, s = t₁ ∩ t₂ :=\n  iff.rfl\n#align mem_inf_iff mem_inf_iff\n\n",
 "mem_generate_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\ntheorem mem_generate_iff {s : Set <| Set α} {U : Set α} :\n    U ∈ generate s ↔ ∃ (t : _)(_ : t ⊆ s), Set.Finite t ∧ «expr⋂₀ » t ⊆ U :=\n  by\n  constructor <;> intro h\n  · induction h\n    case basic V V_in => exact ⟨{V}, singleton_subset_iff.2 V_in, finite_singleton _, (sInter_singleton _).subset⟩\n    case univ => exact ⟨∅, empty_subset _, finite_empty, subset_univ _⟩\n    case superset V W hV' hVW hV =>\n      rcases hV with ⟨t, hts, ht, htV⟩\n      exact ⟨t, hts, ht, htV.trans hVW⟩\n    case inter V W hV' hW' hV hW =>\n      rcases hV, hW with ⟨⟨t, hts, ht, htV⟩, u, hus, hu, huW⟩\n      exact ⟨t ∪ u, union_subset hts hus, ht.union hu, (sInter_union _ _).subset.trans <| inter_subset_inter htV huW⟩\n  · rcases h with ⟨t, hts, tfin, h⟩\n    exact mem_of_superset ((sInter_mem tfin).2 fun V hV => generate_sets.basic <| hts hV) h\n#align mem_generate_iff mem_generate_iff\n\n",
 "mem_comap_prod_mk":
 "/-- RHS form is used, e.g., in the definition of `uniform_space`. -/\ntheorem mem_comap_prod_mk {x : α} {s : Set β} {F : Filter (α × β)} :\n    s ∈ comap (prod.mk x) F ↔ { p : α × β | p.fst = x → p.snd ∈ s } ∈ F := by\n  simp_rw [mem_comap', Prod.ext_iff, and_imp, @forall_swap β (_ = _), forall_eq, eq_comm]\n#align mem_comap_prod_mk mem_comap_prod_mk\n\n",
 "mem_comap_iff_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_comap_iff_compl : s ∈ comap f l ↔ «expr ᶜ» («expr '' » f («expr ᶜ» s)) ∈ l := by\n  simp only [mem_comap', compl_def, mem_image, mem_set_of_eq, not_exists, not_and', Classical.not_not]\n#align mem_comap_iff_compl mem_comap_iff_compl\n\n",
 "mem_comap_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_comap_iff {f : Filter β} {m : α → β} (inj : injective m) (large : Set.range m ∈ f) {S : Set α} :\n    S ∈ comap m f ↔ «expr '' » m S ∈ f := by rw [← image_mem_map_iff inj, map_comap_of_mem large]\n#align mem_comap_iff mem_comap_iff\n\n",
 "mem_comap'":
 "theorem mem_comap' : s ∈ comap f l ↔ { y | ∀ ⦃x⦄, f x = y → x ∈ s } ∈ l :=\n  ⟨fun ⟨t, ht, hts⟩ => mem_of_superset ht fun y hy x hx => hts <| mem_preimage.2 <| by rwa [hx], fun h =>\n    ⟨_, h, fun x hx => hx rfl⟩⟩\n#align mem_comap' mem_comap'\n\n",
 "mem_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem mem_comap : s ∈ comap m g ↔ ∃ t ∈ g, «expr ⁻¹' » m t ⊆ s :=\n  iff.rfl\n#align mem_comap mem_comap\n\n",
 "mem_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem mem_bot {s : Set α} : s ∈ («expr⊥» : Filter α) :=\n  trivial\n#align mem_bot mem_bot\n\n",
 "mem_binfi_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹'o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem mem_binfi_of_directed {f : β → Filter α} {s : Set β} (h : DirectedOn («expr ⁻¹'o » f (· ≥ ·)) s)\n    (ne : s.nonempty) {t : Set α} :\n    t ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i) ↔\n      ∃ i ∈ s, t ∈ f i :=\n  by\n  haveI : Nonempty { x // x ∈ s } := ne.to_subtype <;>\n      erw [infᵢ_subtype', mem_infi_of_directed h.directed_coe, Subtype.exists] <;>\n    rfl\n#align mem_binfi_of_directed mem_binfi_of_directed\n\n",
 "mem_bind'":
 "theorem mem_bind' {s : Set β} {f : Filter α} {m : α → Filter β} : s ∈ bind f m ↔ { a | s ∈ m a } ∈ f :=\n  iff.rfl\n#align mem_bind' mem_bind'\n\n",
 "mem_bind":
 "@[simp]\ntheorem mem_bind {s : Set β} {f : Filter α} {m : α → Filter β} : s ∈ bind f m ↔ ∃ t ∈ f, ∀ x ∈ t, s ∈ m x :=\n  calc\n    s ∈ bind f m ↔ { a | s ∈ m a } ∈ f := iff.rfl\n    _ ↔ ∃ t ∈ f, t ⊆ { a | s ∈ m a } := exists_mem_subset_iff.symm\n    _ ↔ ∃ t ∈ f, ∀ x ∈ t, s ∈ m x := iff.rfl\n    \n#align mem_bind mem_bind\n\n",
 "mem_Sup":
 "@[simp]\ntheorem mem_Sup {x : Set α} {s : Set (Filter α)} : x ∈ supₛ s ↔ ∀ f ∈ s, x ∈ (f : Filter α) :=\n  iff.rfl\n#align mem_Sup mem_Sup\n\n",
 "map_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem map_top (f : α → β) : map f («expr⊤») = (filter.principal) (range f) := by\n  rw [← principal_univ, map_principal, image_univ]\n#align map_top map_top\n\n",
 "map_swap_eq_comap_swap":
 "theorem map_swap_eq_comap_swap {f : Filter (α × β)} : Prod.swap <$> f = comap Prod.swap f :=\n  map_eq_comap_of_inverse Prod.swap_swap_eq Prod.swap_swap_eq\n#align map_swap_eq_comap_swap map_swap_eq_comap_swap\n\n",
 "map_swap4_eq_comap":
 "/-- A useful lemma when dealing with uniformities. -/\ntheorem map_swap4_eq_comap {f : Filter ((α × β) × γ × δ)} :\n    map (fun p : (α × β) × γ × δ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) f =\n      comap (fun p : (α × γ) × β × δ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) f :=\n  map_eq_comap_of_inverse (funext fun ⟨⟨_, _⟩, ⟨_, _⟩⟩ => rfl) (funext fun ⟨⟨_, _⟩, ⟨_, _⟩⟩ => rfl)\n#align map_swap4_eq_comap map_swap4_eq_comap\n\n",
 "map_supᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print map_supᵢ /-\n@[simp]\ntheorem map_supᵢ {f : ι → Filter α} :\n    map m («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (map m (f i)) :=\n  (gc_map_comap m).l_supr\n#align map_supr map_supᵢ\n-/\n\n",
 "map_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem map_sup : map m («expr ⊔ » f₁ f₂) = «expr ⊔ » (map m f₁) (map m f₂) :=\n  (gc_map_comap m).l_sup\n#align map_sup map_sup\n\n",
 "map_pure":
 "@[simp]\ntheorem map_pure (f : α → β) (a : α) : map f (pure a) = pure (f a) :=\n  rfl\n#align map_pure map_pure\n\n",
 "map_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem map_principal {s : Set α} {f : α → β} : map f ((filter.principal) s) = (filter.principal) (Set.image f s) :=\n  Filter.ext fun a => image_subset_iff.symm\n#align map_principal map_principal\n\n",
 "map_ne_bot_iff":
 "theorem map_ne_bot_iff (f : α → β) {F : Filter α} : NeBot (map f F) ↔ NeBot F := by\n  simp only [ne_bot_iff, ne, map_eq_bot_iff]\n#align map_ne_bot_iff map_ne_bot_iff\n\n",
 "map_mono":
 "@[mono]\ntheorem map_mono : Monotone (map m) :=\n  (gc_map_comap m).monotone_l\n#align map_mono map_mono\n\n",
 "map_map":
 "@[simp]\ntheorem map_map : Filter.map m' (Filter.map m f) = Filter.map (m' ∘ m) f :=\n  congr_fun (@Filter.map_compose m m') f\n#align map_map map_map\n\n",
 "map_le_map_iff_of_inj_on":
 "theorem map_le_map_iff_of_inj_on {l₁ l₂ : Filter α} {f : α → β} {s : Set α} (h₁ : s ∈ l₁) (h₂ : s ∈ l₂)\n    (hinj : InjOn f s) : map f l₁ ≤ map f l₂ ↔ l₁ ≤ l₂ :=\n  ⟨fun h t ht =>\n    mp_mem h₁ <|\n      mem_of_superset (h <| image_mem_map (inter_mem h₂ ht)) fun y ⟨x, ⟨hxs, hxt⟩, hxy⟩ hys => hinj hxs hys hxy ▸ hxt,\n    fun h => map_mono h⟩\n#align map_le_map_iff_of_inj_on map_le_map_iff_of_inj_on\n\n",
 "map_le_map_iff":
 "theorem map_le_map_iff {f g : Filter α} {m : α → β} (hm : injective m) : map m f ≤ map m g ↔ f ≤ g := by\n  rw [map_le_iff_le_comap, comap_map hm]\n#align map_le_map_iff map_le_map_iff\n\n",
 "map_le_iff_le_comap":
 "theorem map_le_iff_le_comap : map m f ≤ g ↔ f ≤ comap m g :=\n  ⟨fun h s ⟨t, ht, hts⟩ => mem_of_superset (h ht) hts, fun h s ht => h ⟨_, ht, Subset.rfl⟩⟩\n#align map_le_iff_le_comap map_le_iff_le_comap\n\n",
 "map_injective":
 "theorem map_injective {m : α → β} (hm : injective m) : injective (map m) := fun f g => (map_inj hm).1\n#align map_injective map_injective\n\n",
 "map_inj":
 "theorem map_inj {f g : Filter α} {m : α → β} (hm : injective m) : map m f = map m g ↔ f = g :=\n  map_eq_map_iff_of_injOn univ_mem univ_mem (hm.inj_on _)\n#align map_inj map_inj\n\n",
 "map_infi_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n-- this is a generic rule for monotone functions:\ntheorem map_infi_le {f : ι → Filter α} {m : α → β} :\n    map m (infᵢ f) ≤\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (map m (f i)) :=\n  le_infᵢ fun i => map_mono <| infᵢ_le _ _\n#align map_infi_le map_infi_le\n\n",
 "map_infi_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem map_infi_eq {f : ι → Filter α} {m : α → β} (hf : Directed (· ≥ ·) f) [Nonempty ι] :\n    map m (infᵢ f) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (map m (f i)) :=\n  map_infᵢ_le.antisymm fun s (hs : Preimage m s ∈ infᵢ f) =>\n    let ⟨i, hi⟩ := (mem_infᵢ_of_directed hf _).1 hs\n    have :\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (map m (f i)) ≤\n        (filter.principal) s :=\n      infᵢ_le_of_le i <| by\n        simp only [le_principal_iff, mem_map]\n        assumption\n    Filter.le_principal_iff.1 this\n#align map_infi_eq map_infi_eq\n\n",
 "map_inf_principal_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem map_inf_principal_preimage {f : α → β} {s : Set β} {l : Filter α} :\n    map f («expr ⊓ » l ((filter.principal) («expr ⁻¹' » f s))) = «expr ⊓ » (map f l) ((filter.principal) s) :=\n  Filter.ext fun t => by simp only [mem_map', mem_inf_principal, mem_set_of_eq, mem_preimage]\n#align map_inf_principal_preimage map_inf_principal_preimage\n\n",
 "map_inf_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem map_inf_le {f g : Filter α} {m : α → β} : map m («expr ⊓ » f g) ≤ «expr ⊓ » (map m f) (map m g) :=\n  (@map_mono _ _ m).map_inf_le f g\n#align map_inf_le map_inf_le\n\n",
 "map_inf'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem map_inf' {f g : Filter α} {m : α → β} {t : Set α} (htf : t ∈ f) (htg : t ∈ g) (h : InjOn m t) :\n    map m («expr ⊓ » f g) = «expr ⊓ » (map m f) (map m g) :=\n  by\n  lift f to Filter t using htf; lift g to Filter t using htg\n  replace h : injective (m ∘ coe) := h.injective\n  simp only [map_map, ← map_inf Subtype.coe_injective, map_inf h]\n#align map_inf' map_inf'\n\n",
 "map_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem map_inf {f g : Filter α} {m : α → β} (h : injective m) :\n    map m («expr ⊓ » f g) = «expr ⊓ » (map m f) (map m g) :=\n  by\n  refine' map_inf_le.antisymm _\n  rintro t ⟨s₁, hs₁, s₂, hs₂, ht : «expr ⁻¹' » m t = s₁ ∩ s₂⟩\n  refine' mem_inf_of_inter (image_mem_map hs₁) (image_mem_map hs₂) _\n  rw [← image_inter h, image_subset_iff, ht]\n#align map_inf map_inf\n\n",
 "map_id'":
 "@[simp]\ntheorem map_id' : Filter.map (fun x => x) f = f :=\n  map_id\n#align map_id' map_id'\n\n",
 "map_id":
 "@[simp]\ntheorem map_id : Filter.map id f = f :=\n  filter_eq <| rfl\n#align map_id map_id\n\n",
 "map_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem map_equiv_symm (e : «expr ≃ » α β) (f : Filter β) : map e.symm f = comap e f :=\n  map_injective e.injective <| by rw [map_map, e.self_comp_symm, map_id, map_comap_of_surjective e.surjective]\n#align map_equiv_symm map_equiv_symm\n\n",
 "map_eq_of_inverse":
 "theorem map_eq_of_inverse {f : Filter α} {g : Filter β} {φ : α → β} (ψ : β → α) (eq : φ ∘ ψ = id) (hφ : Tendsto φ f g)\n    (hψ : Tendsto ψ g f) : map φ f = g :=\n  by\n  refine' le_antisymm hφ (le_trans _ (map_mono hψ))\n  rw [map_map, Eq, map_id]\n  exact le_rfl\n#align map_eq_of_inverse map_eq_of_inverse\n\n",
 "map_eq_map_iff_of_inj_on":
 "theorem map_eq_map_iff_of_inj_on {f g : Filter α} {m : α → β} {s : Set α} (hsf : s ∈ f) (hsg : s ∈ g) (hm : InjOn m s) :\n    map m f = map m g ↔ f = g := by\n  simp only [le_antisymm_iff, map_le_map_iff_of_inj_on hsf hsg hm, map_le_map_iff_of_inj_on hsg hsf hm]\n#align map_eq_map_iff_of_inj_on map_eq_map_iff_of_inj_on\n\n",
 "map_eq_comap_of_inverse":
 "theorem map_eq_comap_of_inverse {f : Filter α} {m : α → β} {n : β → α} (h₁ : m ∘ n = id) (h₂ : n ∘ m = id) :\n    map m f = comap n f :=\n  map_equiv_symm ⟨n, m, congr_fun h₁, congr_fun h₂⟩ f\n#align map_eq_comap_of_inverse map_eq_comap_of_inverse\n\n",
 "map_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print map_eq_bot_iff /-\n@[simp]\ntheorem map_eq_bot_iff : map m f = «expr⊥» ↔ f = «expr⊥» :=\n  ⟨by\n    rw [← empty_mem_iff_bot, ← empty_mem_iff_bot]\n    exact id, fun h => by simp only [h, map_bot]⟩\n#align map_eq_bot_iff map_eq_bot_iff\n-/\n\n",
 "map_def":
 "@[simp]\ntheorem map_def {α β} (m : α → β) (f : Filter α) : m <$> f = map m f :=\n  rfl\n#align map_def map_def\n\n",
 "map_const":
 "theorem map_const [NeBot f] {c : β} : (f.map fun x => c) = pure c :=\n  by\n  ext s\n  by_cases h : c ∈ s <;> simp [h]\n#align map_const map_const\n\n",
 "map_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n#print map_congr /-\n/-- If functions `m₁` and `m₂` are eventually equal at a filter `f`, then\nthey map this filter to the same filter. -/\ntheorem map_congr {m₁ m₂ : α → β} {f : Filter α} (h : «expr =ᶠ[ ] » m₁ f m₂) : map m₁ f = map m₂ f :=\n  Filter.ext' fun p => by\n    simp only [eventually_map]\n    exact eventually_congr (h.mono fun x hx => hx ▸ iff.rfl)\n#align map_congr map_congr\n-/\n\n",
 "map_compose":
 "@[simp]\ntheorem map_compose : Filter.map m' ∘ Filter.map m = Filter.map (m' ∘ m) :=\n  funext fun _ => filter_eq <| rfl\n#align map_compose map_compose\n\n",
 "map_comm":
 "theorem map_comm (F : Filter α) : map ψ (map φ F) = map ρ (map θ F) := by rw [Filter.map_map, H, ← Filter.map_map]\n#align map_comm map_comm\n\n",
 "map_comap_of_surjective":
 "theorem map_comap_of_surjective {f : α → β} (hf : surjective f) (l : Filter β) : map f (comap f l) = l :=\n  map_comap_of_mem <| by simp only [hf.range_eq, univ_mem]\n#align map_comap_of_surjective map_comap_of_surjective\n\n",
 "map_comap_of_mem":
 "theorem map_comap_of_mem {f : Filter β} {m : α → β} (hf : range m ∈ f) : (f.comap m).map m = f := by\n  rw [map_comap, inf_eq_left.2 (le_principal_iff.2 hf)]\n#align map_comap_of_mem map_comap_of_mem\n\n",
 "map_comap_le":
 "theorem map_comap_le : map m (comap m g) ≤ g :=\n  (gc_map_comap m).l_u_le _\n#align map_comap_le map_comap_le\n\n",
 "map_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem map_comap (f : Filter β) (m : α → β) : (f.comap m).map m = «expr ⊓ » f ((filter.principal) (range m)) :=\n  by\n  refine' le_antisymm (le_inf map_comap_le <| le_principal_iff.2 range_mem_map) _\n  rintro t' ⟨t, ht, sub⟩\n  refine' mem_inf_principal.2 (mem_of_superset ht _)\n  rintro _ hxt ⟨x, rfl⟩\n  exact sub hxt\n#align map_comap map_comap\n\n",
 "map_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem map_bot : map m («expr⊥») = «expr⊥» :=\n  (gc_map_comap m).l_bot\n#align map_bot map_bot\n\n",
 "map_binfi_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹'o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem map_binfi_eq {ι : Type w} {f : ι → Filter α} {m : α → β} {p : ι → Prop}\n    (h : DirectedOn («expr ⁻¹'o » f (· ≥ ·)) { x | p x }) (ne : ∃ i, p i) :\n    map m («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (map m (f i)) :=\n  by\n  haveI := nonempty_subtype.2 ne\n  simp only [infᵢ_subtype']\n  exact map_infi_eq h.directed_coe\n#align map_binfi_eq map_binfi_eq\n\n",
 "map":
 "theorem ne_bot.map (hf : NeBot f) (m : α → β) : NeBot (map m f) :=\n  (map_neBot_iff m).2 hf\n#align ne_bot.map ne_bot.map\n\n",
 "lt_top_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eventually.lt_top_of_ne [partial_order β] [OrderTop β] {l : Filter α} {f : α → β}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (f x ≠ «expr⊤»)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (f x < «expr⊤») :=\n  h.mono fun x hx => hx.lt_top\n#align eventually.lt_top_of_ne eventually.lt_top_of_ne\n\n",
 "lt_top_iff_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eventually.lt_top_iff_ne_top [partial_order β] [OrderTop β] {l : Filter α} {f : α → β} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (f x < «expr⊤») ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (f x ≠ «expr⊤») :=\n  ⟨Eventually.ne_of_lt, Eventually.lt_top_of_ne⟩\n#align eventually.lt_top_iff_ne_top eventually.lt_top_iff_ne_top\n\n",
 "le_sup_of_le_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem eventually_le.le_sup_of_le_right [SemilatticeSup β] {l : Filter α} {f g h : α → β} (hg : «expr ≤ᶠ[ ] » h l g) :\n    «expr ≤ᶠ[ ] » h l («expr ⊔ » f g) := by filter_upwards [hg]with x hgx using le_sup_of_le_right hgx\n#align eventually_le.le_sup_of_le_right eventually_le.le_sup_of_le_right\n\n",
 "le_sup_of_le_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem eventually_le.le_sup_of_le_left [SemilatticeSup β] {l : Filter α} {f g h : α → β} (hf : «expr ≤ᶠ[ ] » h l f) :\n    «expr ≤ᶠ[ ] » h l («expr ⊔ » f g) := by filter_upwards [hf]with x hfx using le_sup_of_le_left hfx\n#align eventually_le.le_sup_of_le_left eventually_le.le_sup_of_le_left\n\n",
 "le_seq":
 "theorem le_seq {f : Filter (α → β)} {g : Filter α} {h : Filter β} (hh : ∀ t ∈ f, ∀ u ∈ g, Set.seq t u ∈ h) :\n    h ≤ seq f g := fun s ⟨t, ht, u, hu, hs⟩ =>\n  mem_of_superset (hh _ ht _ hu) fun b ⟨m, hm, a, ha, Eq⟩ => Eq ▸ hs _ hm _ ha\n#align le_seq le_seq\n\n",
 "le_pure_iff":
 "@[simp]\ntheorem le_pure_iff {f : Filter α} {a : α} : f ≤ pure a ↔ {a} ∈ f := by rw [← principal_singleton, le_principal_iff]\n#align le_pure_iff le_pure_iff\n\n",
 "le_principal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem le_principal_iff {s : Set α} {f : Filter α} : f ≤ (filter.principal) s ↔ s ∈ f :=\n  show (∀ {t}, s ⊆ t → t ∈ f) ↔ s ∈ f from ⟨fun h => h (Subset.refl s), fun hs t ht => mem_of_superset hs ht⟩\n#align le_principal_iff le_principal_iff\n\n",
 "le_map_of_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem le_map_of_right_inverse {mab : α → β} {mba : β → α} {f : Filter α} {g : Filter β}\n    (h₁ : «expr =ᶠ[ ] » (mab ∘ mba) g id) (h₂ : Tendsto mba g f) : g ≤ map mab f :=\n  by\n  rw [← @map_id _ g, ← map_congr h₁, ← map_map]\n  exact map_mono h₂\n#align le_map_of_right_inverse le_map_of_right_inverse\n\n",
 "le_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem le_map_iff {f : Filter α} {m : α → β} {g : Filter β} : g ≤ f.map m ↔ ∀ s ∈ f, «expr '' » m s ∈ g :=\n  ⟨fun h s hs => h (image_mem_map hs), le_map⟩\n#align le_map_iff le_map_iff\n\n",
 "le_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem le_map {f : Filter α} {m : α → β} {g : Filter β} (h : ∀ s ∈ f, «expr '' » m s ∈ g) : g ≤ f.map m := fun s hs =>\n  mem_of_superset (h _ hs) <| image_preimage_subset _ _\n#align le_map le_map\n\n",
 "le_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem eventually_le.le_iff_eq [partial_order β] {l : Filter α} {f g : α → β} (h : «expr ≤ᶠ[ ] » f l g) :\n    «expr ≤ᶠ[ ] » g l f ↔ «expr =ᶠ[ ] » g l f :=\n  ⟨fun h' => h'.antisymm h, EventuallyEq.le⟩\n#align eventually_le.le_iff_eq eventually_le.le_iff_eq\n\n",
 "le_def":
 "theorem le_def : f ≤ g ↔ ∀ x ∈ g, x ∈ f :=\n  iff.rfl\n#align le_def le_def\n\n",
 "le_comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem le_comap_top (f : α → β) (l : Filter α) : l ≤ comap f («expr⊤») :=\n  by\n  rw [comap_top]\n  exact le_top\n#align le_comap_top le_comap_top\n\n",
 "le_comap_map":
 "theorem le_comap_map : f ≤ comap m (map m f) :=\n  (gc_map_comap m).le_u_l _\n#align le_comap_map le_comap_map\n\n",
 "le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem eventually_eq.le (h : «expr =ᶠ[ ] » f l g) : «expr ≤ᶠ[ ] » f l g :=\n  h.mono fun x => le_of_eq\n#align eventually_eq.le eventually_eq.le\n\n",
 "join_pure":
 "@[simp]\ntheorem join_pure (f : Filter α) : join (pure f) = f :=\n  Filter.ext fun s => iff.rfl\n#align join_pure join_pure\n\n",
 "join_principal_eq_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem join_principal_eq_Sup {s : Set (Filter α)} : join ((filter.principal) s) = supₛ s :=\n  rfl\n#align join_principal_eq_Sup join_principal_eq_Sup\n\n",
 "join_mono":
 "@[mono]\ntheorem join_mono {f₁ f₂ : Filter (Filter α)} (h : f₁ ≤ f₂) : join f₁ ≤ join f₂ := fun s hs => h hs\n#align join_mono join_mono\n\n",
 "join_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem join_le {f : Filter (Filter α)} {l : Filter α}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (m ≤ l)) :\n    join f ≤ l := fun s hs => h.mono fun m hm => hm hs\n#align join_le join_le\n\n",
 "is_compl_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_compl_principal (s : Set α) : IsCompl ((filter.principal) s) ((filter.principal) («expr ᶜ» s)) :=\n  IsCompl.of_eq (by rw [inf_principal, inter_compl_self, principal_empty]) <| by\n    rw [sup_principal, union_compl_self, principal_univ]\n#align is_compl_principal is_compl_principal\n\n",
 "inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n@[to_additive]\ntheorem eventually_eq.inv [Inv β] {f g : α → β} {l : Filter α} (h : «expr =ᶠ[ ] » f l g) :\n    «expr =ᶠ[ ] » (fun x => (f x)⁻¹) l fun x => (g x)⁻¹ :=\n  h.fun_comp has_inv.inv\n#align eventually_eq.inv eventually_eq.inv\n\n",
 "inter_mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inter_mem_inf {α : Type u} {f g : Filter α} {s t : Set α} (hs : s ∈ f) (ht : t ∈ g) : s ∩ t ∈ «expr ⊓ » f g :=\n  ⟨s, hs, t, ht, rfl⟩\n#align inter_mem_inf inter_mem_inf\n\n",
 "inter_mem_iff":
 "@[simp]\ntheorem inter_mem_iff {s t : Set α} : s ∩ t ∈ f ↔ s ∈ f ∧ t ∈ f :=\n  ⟨fun h => ⟨mem_of_superset h (inter_subset_left s t), mem_of_superset h (inter_subset_right s t)⟩,\n    and_imp.2 inter_mem⟩\n#align inter_mem_iff inter_mem_iff\n\n",
 "inter_mem":
 "theorem inter_mem {s t : Set α} (hs : s ∈ f) (ht : t ∈ f) : s ∩ t ∈ f :=\n  f.inter_sets hs ht\n#align inter_mem inter_mem\n\n",
 "inter_eventually_eq_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem inter_eventually_eq_right {s t : Set α} {l : Filter α} :\n    «expr =ᶠ[ ] » (s ∩ t : Set α) l t ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (x ∈ t → x ∈ s) :=\n  by rw [inter_comm, inter_eventually_eq_left]\n#align inter_eventually_eq_right inter_eventually_eq_right\n\n",
 "inter_eventually_eq_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem inter_eventually_eq_left {s t : Set α} {l : Filter α} :\n    «expr =ᶠ[ ] » (s ∩ t : Set α) l s ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (x ∈ s → x ∈ t) :=\n  by simp only [eventually_eq_set, mem_inter_iff, and_iff_left_iff_imp]\n#align inter_eventually_eq_left inter_eventually_eq_left\n\n",
 "inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n@[mono]\ntheorem eventually_le.inter {s t s' t' : Set α} {l : Filter α} (h : «expr ≤ᶠ[ ] » s l t) (h' : «expr ≤ᶠ[ ] » s' l t') :\n    «expr ≤ᶠ[ ] » (s ∩ s' : Set α) l (t ∩ t' : Set α) :=\n  h'.mp <| h.mono fun x => and.imp\n#align eventually_le.inter eventually_le.inter\n\n",
 "infi_sets_induct":
 "@[elab_as_elim]\ntheorem infi_sets_induct {f : ι → Filter α} {s : Set α} (hs : s ∈ infᵢ f) {p : Set α → Prop} (uni : p univ)\n    (ins : ∀ {i s₁ s₂}, s₁ ∈ f i → p s₂ → p (s₁ ∩ s₂)) : p s :=\n  by\n  rw [mem_infi_finite'] at hs\n  simp only [← Finset.inf_eq_infᵢ] at hs\n  rcases hs with ⟨is, his⟩\n  revert s\n  refine' Finset.induction_on is _ _\n  · intro s hs\n    rwa [mem_top.1 hs]\n  · rintro ⟨i⟩ js his ih s hs\n    rw [Finset.inf_insert, mem_inf_iff] at hs\n    rcases hs with ⟨s₁, hs₁, s₂, hs₂, rfl⟩\n    exact ins hs₁ (ih hs₂)\n#align infi_sets_induct infi_sets_induct\n\n",
 "infi_sets_eq_finite'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem infi_sets_eq_finite' (f : ι → Filter α) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)).sets =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (f (PLift.down i))).sets :=\n  by\n  rw [← infi_sets_eq_finite, ← equiv.plift.surjective.infi_comp]\n  rfl\n#align infi_sets_eq_finite' infi_sets_eq_finite'\n\n",
 "infi_sets_eq_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem infi_sets_eq_finite {ι : Type _} (f : ι → Filter α) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)).sets =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)).sets :=\n  by\n  rw [infᵢ_eq_infᵢ_finset, infi_sets_eq]\n  exact directed_of_sup fun s₁ s₂ => binfᵢ_mono\n#align infi_sets_eq_finite infi_sets_eq_finite\n\n",
 "infi_sets_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem infi_sets_eq {f : ι → Filter α} (h : Directed (· ≥ ·) f) [ne : Nonempty ι] :\n    (infᵢ f).sets =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i).sets :=\n  let ⟨i⟩ := ne\n  let u :=\n    { sets := «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i).sets\n      univ_sets := by simp only [mem_Union] <;> exact ⟨i, univ_mem⟩\n      sets_of_superset := by\n        simp only [mem_Union, exists_imp] <;> intro x y i hx hxy <;> exact ⟨i, mem_of_superset hx hxy⟩\n      inter_sets := by\n        simp only [mem_Union, exists_imp]\n        intro x y a hx b hy\n        rcases h a b with ⟨c, ha, hb⟩\n        exact ⟨c, inter_mem (ha hx) (hb hy)⟩ }\n  have : u = infᵢ f := eq_infᵢ_of_mem_iff_exists_mem fun s => by simp only [Filter.mem_mk, mem_Union, Filter.mem_sets]\n  congr_arg filter.sets this.symm\n#align infi_sets_eq infi_sets_eq\n\n",
 "infi_principal_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp]\ntheorem infi_principal_finset {ι : Type w} (s : Finset ι) (f : ι → Set α) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (f i)) =\n      (filter.principal)\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  by\n  induction' s using Finset.induction_on with i s hi hs\n  · simp\n  · rw [Finset.infᵢ_insert, Finset.set_binterᵢ_insert, hs, inf_principal]\n#align infi_principal_finset infi_principal_finset\n\n",
 "infi_principal_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem infi_principal_finite {ι : Type w} {s : Set ι} (hs : s.finite) (f : ι → Set α) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (f i)) =\n      (filter.principal)\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  by\n  lift s to Finset ι using hs\n  exact_mod_cast infi_principal_finset s f\n#align infi_principal_finite infi_principal_finite\n\n",
 "infi_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp]\ntheorem infi_principal {ι : Type w} [Finite ι] (f : ι → Set α) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (f i)) =\n      (filter.principal)\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  by\n  cases nonempty_fintype ι\n  simpa using infi_principal_finset Finset.univ f\n#align infi_principal infi_principal\n\n",
 "infi_ne_bot_of_directed'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- If `f : ι → filter α` is directed, `ι` is not empty, and `∀ i, f i ≠ ⊥`, then `infi f ≠ ⊥`.\nSee also `infi_ne_bot_of_directed` for a version assuming `nonempty α` instead of `nonempty ι`. -/\ntheorem infi_ne_bot_of_directed' {f : ι → Filter α} [Nonempty ι] (hd : Directed (· ≥ ·) f) (hb : ∀ i, NeBot (f i)) :\n    NeBot (infᵢ f) :=\n  ⟨by\n    intro h\n    have he : ∅ ∈ infᵢ f := h.symm ▸ (mem_bot : ∅ ∈ («expr⊥» : Filter α))\n    obtain ⟨i, hi⟩ : ∃ i, ∅ ∈ f i\n    exact (mem_infi_of_directed hd ∅).1 he\n    exact (hb i).ne (empty_mem_iff_bot.1 hi)⟩\n#align infi_ne_bot_of_directed' infi_ne_bot_of_directed'\n\n",
 "infi_ne_bot_of_directed":
 "/-- If `f : ι → filter α` is directed, `α` is not empty, and `∀ i, f i ≠ ⊥`, then `infi f ≠ ⊥`.\nSee also `infi_ne_bot_of_directed'` for a version assuming `nonempty ι` instead of `nonempty α`. -/\ntheorem infi_ne_bot_of_directed {f : ι → Filter α} [hn : Nonempty α] (hd : Directed (· ≥ ·) f) (hb : ∀ i, NeBot (f i)) :\n    NeBot (infᵢ f) := by\n  cases isEmpty_or_nonempty ι\n  · constructor\n    simp [infᵢ_of_empty f, top_ne_bot]\n  · exact infi_ne_bot_of_directed' hd hb\n#align infi_ne_bot_of_directed infi_ne_bot_of_directed\n\n",
 "infi_ne_bot_iff_of_directed'":
 "theorem infi_ne_bot_iff_of_directed' {f : ι → Filter α} [Nonempty ι] (hd : Directed (· ≥ ·) f) :\n    NeBot (infᵢ f) ↔ ∀ i, NeBot (f i) :=\n  ⟨fun H i => H.mono (infᵢ_le _ i), infᵢ_neBot_of_directed' hd⟩\n#align infi_ne_bot_iff_of_directed' infi_ne_bot_iff_of_directed'\n\n",
 "infi_ne_bot_iff_of_directed":
 "theorem infi_ne_bot_iff_of_directed {f : ι → Filter α} [Nonempty α] (hd : Directed (· ≥ ·) f) :\n    NeBot (infᵢ f) ↔ ∀ i, NeBot (f i) :=\n  ⟨fun H i => H.mono (infᵢ_le _ i), infᵢ_neBot_of_directed hd⟩\n#align infi_ne_bot_iff_of_directed infi_ne_bot_iff_of_directed\n\n",
 "infi_eq_generate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem infi_eq_generate (s : ι → Filter α) :\n    infᵢ s =\n      generate\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i).sets) :=\n  show generate _ = generate _ from congr_arg _ <| congr_arg supₛ <| (range_comp _ _).symm\n#align infi_eq_generate infi_eq_generate\n\n",
 "inf_principal_eq_bot_iff_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem inf_principal_eq_bot_iff_comap {F : Filter α} {s : Set α} :\n    «expr ⊓ » F ((filter.principal) s) = «expr⊥» ↔ comap (coe : s → α) F = «expr⊥» := by\n  rw [principal_eq_map_coe_top s, ← Filter.push_pull', inf_top_eq, map_eq_bot_iff]\n#align inf_principal_eq_bot_iff_comap inf_principal_eq_bot_iff_comap\n\n",
 "inf_principal_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem inf_principal_eq_bot {f : Filter α} {s : Set α} :\n    «expr ⊓ » f ((filter.principal) s) = «expr⊥» ↔ «expr ᶜ» s ∈ f :=\n  by\n  rw [← empty_mem_iff_bot, mem_inf_principal]\n  rfl\n#align inf_principal_eq_bot inf_principal_eq_bot\n\n",
 "inf_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem inf_principal {s t : Set α} :\n    «expr ⊓ » ((filter.principal) s) ((filter.principal) t) = (filter.principal) (s ∩ t) :=\n  le_antisymm (by simp only [le_principal_iff, mem_inf_iff] <;> exact ⟨s, subset.rfl, t, subset.rfl, rfl⟩)\n    (by simp [le_inf_iff, inter_subset_left, inter_subset_right])\n#align inf_principal inf_principal\n\n",
 "inf_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem inf_eq_bot_iff {f g : Filter α} : «expr ⊓ » f g = «expr⊥» ↔ ∃ U ∈ f, ∃ V ∈ g, U ∩ V = ∅ := by\n  simpa only [← disjoint_iff, Set.disjoint_iff_inter_eq_empty] using Filter.disjoint_iff\n#align inf_eq_bot_iff inf_eq_bot_iff\n\n",
 "inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem tendsto.inf {f : α → β} {x₁ x₂ : Filter α} {y₁ y₂ : Filter β} (h₁ : Tendsto f x₁ y₁) (h₂ : Tendsto f x₂ y₂) :\n    Tendsto f («expr ⊓ » x₁ x₂) («expr ⊓ » y₁ y₂) :=\n  tendsto_inf.2 ⟨tendsto_inf_left h₁, tendsto_inf_right h₂⟩\n#align tendsto.inf tendsto.inf\n\n",
 "image_mem_of_mem_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_mem_of_mem_comap {f : Filter α} {c : β → α} (h : range c ∈ f) {W : Set β} (W_in : W ∈ comap c f) :\n    «expr '' » c W ∈ f := by\n  rw [← map_comap_of_mem h]\n  exact image_mem_map W_in\n#align image_mem_of_mem_comap image_mem_of_mem_comap\n\n",
 "image_mem_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_mem_map_iff (hf : injective m) : «expr '' » m s ∈ map m f ↔ s ∈ f :=\n  ⟨fun h => by rwa [← preimage_image_eq s hf], image_mem_map⟩\n#align image_mem_map_iff image_mem_map_iff\n\n",
 "image_mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_mem_map (hs : s ∈ f) : «expr '' » m s ∈ map m f :=\n  f.sets_of_superset hs <| subset_preimage_image m s\n#align image_mem_map image_mem_map\n\n",
 "image_coe_mem_of_mem_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_coe_mem_of_mem_comap {f : Filter α} {U : Set α} (h : U ∈ f) {W : Set U}\n    (W_in : W ∈ comap (coe : U → α) f) : «expr '' » coe W ∈ f :=\n  image_mem_of_mem_comap (by simp [h]) W_in\n#align image_coe_mem_of_mem_comap image_coe_mem_of_mem_comap\n\n",
 "if'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\nprotected theorem tendsto.if' {α β : Type _} {l₁ : Filter α} {l₂ : Filter β} {f g : α → β} {p : α → Prop}\n    [DecidablePred p] (hf : Tendsto f l₁ l₂) (hg : Tendsto g l₁ l₂) :\n    Tendsto (fun a => if p a then f a else g a) l₁ l₂ :=\n  by\n  replace hf : tendsto f («expr ⊓ » l₁ ((filter.principal) { x | p x })) l₂ := tendsto_inf_left hf\n  replace hg : tendsto g («expr ⊓ » l₁ ((filter.principal) { x | ¬p x })) l₂ := tendsto_inf_left hg\n  exact hf.if hg\n#align tendsto.if' tendsto.if'\n\n",
 "if":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\nprotected theorem tendsto.if {l₁ : Filter α} {l₂ : Filter β} {f g : α → β} {p : α → Prop} [∀ x, Decidable (p x)]\n    (h₀ : Tendsto f («expr ⊓ » l₁ ((filter.principal) { x | p x })) l₂)\n    (h₁ : Tendsto g («expr ⊓ » l₁ ((filter.principal) { x | ¬p x })) l₂) :\n    Tendsto (fun x => if p x then f x else g x) l₁ l₂ :=\n  by\n  simp only [tendsto_def, mem_inf_principal] at *\n  intro s hs\n  filter_upwards [h₀ s hs, h₁ s hs]\n  simp only [mem_preimage]\n  intro x hp₀ hp₁\n  split_ifs\n  exacts[hp₀ h, hp₁ h]\n#align tendsto.if tendsto.if\n\n",
 "generate_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem generate_univ : Filter.generate univ = («expr⊥» : Filter α) :=\n  mkOfClosure_sets.symm\n#align generate_univ generate_univ\n\n",
 "generate_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem generate_union {s t : Set (Set α)} :\n    Filter.generate (s ∪ t) = «expr ⊓ » (Filter.generate s) (Filter.generate t) :=\n  (giGenerate α).gc.l_sup\n#align generate_union generate_union\n\n",
 "generate_eq_binfi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem generate_eq_binfi (S : Set (Set α)) :\n    generate S =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) s) :=\n  eq_of_forall_le_iff fun f => by simp [sets_iff_generate, le_principal_iff, subset_def]\n#align generate_eq_binfi generate_eq_binfi\n\n",
 "generate_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem generate_empty : Filter.generate ∅ = («expr⊤» : Filter α) :=\n  (giGenerate α).gc.l_bot\n#align generate_empty generate_empty\n\n",
 "generate_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem generate_Union {s : ι → Set (Set α)} :\n    Filter.generate\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (Filter.generate (s i)) :=\n  (giGenerate α).gc.l_supr\n#align generate_Union generate_Union\n\n",
 "gc_map_comap":
 "theorem gc_map_comap (m : α → β) : GaloisConnection (map m) (comap m) := fun f g => map_le_iff_le_comap\n#align gc_map_comap gc_map_comap\n\n",
 "fun_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem eventually_eq.fun_comp {f g : α → β} {l : Filter α} (H : «expr =ᶠ[ ] » f l g) (h : β → γ) :\n    «expr =ᶠ[ ] » (h ∘ f) l (h ∘ g) :=\n  H.mono fun x hx => congr_arg h hx\n#align eventually_eq.fun_comp eventually_eq.fun_comp\n\n",
 "frequently_true_iff_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n@[simp]\ntheorem frequently_true_iff_ne_bot (f : Filter α) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f True ↔\n      NeBot f :=\n  by simp [Filter.Frequently, -not_eventually, eventually_false_iff_eq_bot, ne_bot_iff]\n#align frequently_true_iff_ne_bot frequently_true_iff_ne_bot\n\n",
 "frequently_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem frequently_top {p : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" («expr⊤»)\n        (p x) ↔\n      ∃ x, p x :=\n  by simp [Filter.Frequently]\n#align frequently_top frequently_top\n\n",
 "frequently_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n@[simp]\ntheorem frequently_supr {p : α → Prop} {fs : β → Filter α} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (fs b)) (p x) ↔\n      ∃ b,\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" (fs b)\n          (p x) :=\n  by simp [Filter.Frequently, -not_eventually, not_forall]\n#align frequently_supr frequently_supr\n\n",
 "frequently_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_sup {p : α → Prop} {f g : Filter α} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n        («expr ⊔ » f g) (p x) ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (p x) ∨\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" g\n          (p x) :=\n  by simp only [Filter.Frequently, eventually_sup, not_and_or]\n#align frequently_sup frequently_sup\n\n",
 "frequently_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem frequently_principal {a : Set α} {p : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n        ((filter.principal) a) (p x) ↔\n      ∃ x ∈ a, p x :=\n  by simp [Filter.Frequently, not_forall]\n#align frequently_principal frequently_principal\n\n",
 "frequently_or_distrib_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_or_distrib_right {f : Filter α} [NeBot f] {p : α → Prop} {q : Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n        (p x ∨ q) ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (p x) ∨\n        q :=\n  by simp\n#align frequently_or_distrib_right frequently_or_distrib_right\n\n",
 "frequently_or_distrib_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_or_distrib_left {f : Filter α} [NeBot f] {p : Prop} {q : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n        (p ∨ q x) ↔\n      p ∨\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n          (q x) :=\n  by simp\n#align frequently_or_distrib_left frequently_or_distrib_left\n\n",
 "frequently_or_distrib":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n@[simp]\ntheorem frequently_or_distrib {f : Filter α} {p q : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n        (p x ∨ q x) ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (p x) ∨\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n          (q x) :=\n  by simp only [Filter.Frequently, ← not_and_or, not_or, eventually_and]\n#align frequently_or_distrib frequently_or_distrib\n\n",
 "frequently_of_forall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_of_forall {f : Filter α} [NeBot f] {p : α → Prop} (h : ∀ x, p x) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (p x) :=\n  Eventually.frequently (eventually_of_forall h)\n#align frequently_of_forall frequently_of_forall\n\n",
 "frequently_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem tendsto.frequently_map {l₁ : Filter α} {l₂ : Filter β} {p : α → Prop} {q : β → Prop} (f : α → β)\n    (c : Filter.Tendsto f l₁ l₂) (w : ∀ x, p x → q (f x))\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l₁\n        (p x)) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l₂ (q y) :=\n  c.frequently (h.mono w)\n#align tendsto.frequently_map tendsto.frequently_map\n\n",
 "frequently_imp_distrib_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem frequently_imp_distrib_right {f : Filter α} [NeBot f] {p : α → Prop} {q : Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n        (p x → q) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (p x) →\n        q :=\n  by simp\n#align frequently_imp_distrib_right frequently_imp_distrib_right\n\n",
 "frequently_imp_distrib_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_imp_distrib_left {f : Filter α} [NeBot f] {p : Prop} {q : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n        (p → q x) ↔\n      p →\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n          (q x) :=\n  by simp\n#align frequently_imp_distrib_left frequently_imp_distrib_left\n\n",
 "frequently_imp_distrib":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n@[simp]\ntheorem frequently_imp_distrib {f : Filter α} {p q : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n        (p x → q x) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (p x) →\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n          (q x) :=\n  by simp [imp_iff_not_or, not_eventually, frequently_or_distrib]\n#align frequently_imp_distrib frequently_imp_distrib\n\n",
 "frequently_iff_forall_eventually_exists_and":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem frequently_iff_forall_eventually_exists_and {p : α → Prop} {f : Filter α} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (p x) ↔\n      ∀ {q : α → Prop},\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n            (q x) →\n          ∃ x, p x ∧ q x :=\n  ⟨fun hp q hq => (hp.and_eventually hq).exists, fun H hp => by simpa only [and_not_self_iff, exists_false] using H hp⟩\n#align frequently_iff_forall_eventually_exists_and frequently_iff_forall_eventually_exists_and\n\n",
 "frequently_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_iff {f : Filter α} {P : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (P x) ↔\n      ∀ {U}, U ∈ f → ∃ x ∈ U, P x :=\n  by\n  simp only [frequently_iff_forall_eventually_exists_and, exists_prop, and_comm' (P _)]\n  rfl\n#align frequently_iff frequently_iff\n\n",
 "frequently_false":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n@[simp]\ntheorem frequently_false (f : Filter α) :\n    ¬«expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f False :=\n  by simp\n#align frequently_false frequently_false\n\n",
 "frequently_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n@[simp]\ntheorem frequently_const {f : Filter α} [NeBot f] {p : Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f p ↔ p :=\n  by_cases (fun h : p => by simpa [h] ) fun h => by simp [h]\n#align frequently_const frequently_const\n\n",
 "frequently_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n@[simp]\ntheorem frequently_comap :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" (comap f l)\n        (p a) ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l\n        (∃ a, f a = b ∧ p a) :=\n  by simp only [Filter.Frequently, eventually_comap, not_exists, not_and]\n#align frequently_comap frequently_comap\n\n",
 "frequently_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem frequently_bot {p : α → Prop} :\n    ¬«expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" («expr⊥»)\n        (p x) :=\n  by simp\n#align frequently_bot frequently_bot\n\n",
 "frequently_and_distrib_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n@[simp]\ntheorem frequently_and_distrib_right {f : Filter α} {p : α → Prop} {q : Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n        (p x ∧ q) ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (p x) ∧\n        q :=\n  by simp only [and_comm' _ q, frequently_and_distrib_left]\n#align frequently_and_distrib_right frequently_and_distrib_right\n\n",
 "frequently_and_distrib_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n@[simp]\ntheorem frequently_and_distrib_left {f : Filter α} {p : Prop} {q : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n        (p ∧ q x) ↔\n      p ∧\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n          (q x) :=\n  by simp only [Filter.Frequently, not_and, eventually_imp_distrib_left, not_imp]\n#align frequently_and_distrib_left frequently_and_distrib_left\n\n",
 "frequently_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n@[simp]\ntheorem frequently_Sup {p : α → Prop} {fs : Set (Filter α)} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" (supₛ fs)\n        (p x) ↔\n      ∃ f ∈ fs,\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n          (p x) :=\n  by simp [Filter.Frequently, -not_eventually, not_forall]\n#align frequently_Sup frequently_Sup\n\n",
 "frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem tendsto.frequently {f : α → β} {l₁ : Filter α} {l₂ : Filter β} {p : β → Prop} (hf : Tendsto f l₁ l₂)\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l₁\n        (p (f x))) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l₂ (p y) :=\n  mt hf.eventually h\n#align tendsto.frequently tendsto.frequently\n\n",
 "forall_mem_nonempty_iff_ne_bot":
 "theorem forall_mem_nonempty_iff_ne_bot {f : Filter α} : (∀ s : Set α, s ∈ f → s.nonempty) ↔ NeBot f :=\n  ⟨fun h => ⟨fun hf => not_nonempty_empty (h ∅ <| hf.symm ▸ mem_bot)⟩, @nonempty_of_mem _ _⟩\n#align forall_mem_nonempty_iff_ne_bot forall_mem_nonempty_iff_ne_bot\n\n",
 "forall_in_swap":
 "theorem forall_in_swap {β : Type _} {p : Set α → β → Prop} : (∀ a ∈ f, ∀ (b), p a b) ↔ ∀ (b), ∀ a ∈ f, p a b :=\n  Set.forall_in_swap\n#align forall_in_swap forall_in_swap\n\n",
 "forall_eventually_of_eventually_forall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem forall_eventually_of_eventually_forall {f : Filter α} {p : α → β → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (∀ y, p x y)) :\n    ∀ y,\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (p x y) :=\n  by\n  intro y\n  filter_upwards [h]\n  tauto\n#align forall_eventually_of_eventually_forall forall_eventually_of_eventually_forall\n\n",
 "filter_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem eventually_eq.filter_mono {l l' : Filter α} {f g : α → β} (h₁ : «expr =ᶠ[ ] » f l g) (h₂ : l' ≤ l) :\n    «expr =ᶠ[ ] » f l' g :=\n  h₂ h₁\n#align eventually_eq.filter_mono eventually_eq.filter_mono\n\n",
 "filter_map_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Function.Surjective.filter_map_top /-\ntheorem Function.Surjective.filter_map_top {f : α → β} (hf : surjective f) : map f («expr⊤») = «expr⊤» :=\n  (congr_arg _ comap_top).symm.trans <| map_comap_of_surjective hf («expr⊤»)\n#align function.surjective.filter_map_top Function.Surjective.filter_map_top\n-/\n\n",
 "filter_map":
 "#print Function.Commute.filter_map /-\ntheorem Function.Commute.filter_map {f g : α → α} (h : Function.Commute f g) : Function.Commute (map f) (map g) :=\n  h.filter_map\n#align function.commute.filter_map Function.Commute.filter_map\n-/\n\n",
 "filter_eq_iff":
 "theorem filter_eq_iff : f = g ↔ f.sets = g.sets :=\n  ⟨congr_arg _, filter_eq⟩\n#align filter_eq_iff filter_eq_iff\n\n",
 "filter_eq_bot_of_is_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem filter_eq_bot_of_is_empty [IsEmpty α] (f : Filter α) : f = «expr⊥» :=\n  empty_mem_iff_bot.mp <| univ_mem' isEmptyElim\n#align filter_eq_bot_of_is_empty filter_eq_bot_of_is_empty\n\n",
 "filter_eq":
 "theorem filter_eq : ∀ {f g : Filter α}, f.sets = g.sets → f = g\n  | ⟨a, _, _, _⟩, ⟨_, _, _, _⟩, rfl => rfl\n#align filter_eq filter_eq\n\n",
 "filter_comap":
 "#print Function.Commute.filter_comap /-\ntheorem Function.Commute.filter_comap {f g : α → α} (h : Function.Commute f g) : Function.Commute (comap f) (comap g) :=\n  h.filter_comap\n#align function.commute.filter_comap Function.Commute.filter_comap\n-/\n\n",
 "ext_iff":
 "protected theorem ext_iff : f = g ↔ ∀ s, s ∈ f ↔ s ∈ g := by simp only [filter_eq_iff, ext_iff, Filter.mem_sets]\n#align ext_iff ext_iff\n\n",
 "ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\nprotected theorem ext' {f₁ f₂ : Filter α}\n    (h :\n      ∀ p : α → Prop,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f₁\n            (p x) ↔\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f₂\n            (p x)) :\n    f₁ = f₂ :=\n  Filter.ext h\n#align ext' ext'\n\n",
 "ext":
 "@[ext]\nprotected theorem ext : (∀ s, s ∈ f ↔ s ∈ g) → f = g :=\n  Filter.ext_iff.2\n#align ext ext\n\n",
 "exists_mem_subset_iff":
 "theorem exists_mem_subset_iff : (∃ t ∈ f, t ⊆ s) ↔ s ∈ f :=\n  ⟨fun ⟨t, ht, ts⟩ => mem_of_superset ht ts, fun hs => ⟨s, hs, Subset.rfl⟩⟩\n#align exists_mem_subset_iff exists_mem_subset_iff\n\n",
 "exists_mem_filter_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n#print Pairwise.exists_mem_filter_of_disjoint /-\ntheorem Pairwise.exists_mem_filter_of_disjoint {ι : Type _} [Finite ι] {l : ι → Filter α}\n    (hd : Pairwise («expr on » Disjoint l)) : ∃ s : ι → Set α, (∀ i, s i ∈ l i) ∧ Pairwise («expr on » Disjoint s) :=\n  by\n  simp only [Pairwise, function.on_fun, Filter.disjoint_iff, Subtype.exists'] at hd\n  choose! s t hst using hd\n  refine'\n    ⟨fun i =>\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (@s i j ∩ @t j i),\n      fun i => _, fun i j hij => _⟩\n  exacts[Inter_mem.2 fun j => inter_mem (@s i j).2 (@t j i).2,\n    (hst hij).mono ((Inter_subset _ j).trans (inter_subset_left _ _))\n      ((Inter_subset _ i).trans (inter_subset_right _ _))]\n#align pairwise.exists_mem_filter_of_disjoint Pairwise.exists_mem_filter_of_disjoint\n-/\n\n",
 "exists_mem_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n#print Set.PairwiseDisjoint.exists_mem_filter /-\ntheorem Set.PairwiseDisjoint.exists_mem_filter {ι : Type _} {l : ι → Filter α} {t : Set ι} (hd : t.pairwise_disjoint l)\n    (ht : t.finite) : ∃ s : ι → Set α, (∀ i, s i ∈ l i) ∧ t.pairwise_disjoint s :=\n  by\n  cases ht\n  obtain ⟨s, hd⟩ : ∃ s : ∀ i : t, { s : Set α // s ∈ l i }, Pairwise («expr on » Disjoint fun i => (s i : Set α)) :=\n    by\n    rcases(hd.subtype _ _).exists_mem_filter_of_disjoint with ⟨s, hsl, hsd⟩\n    exact ⟨fun i => ⟨s i, hsl i⟩, hsd⟩\n  -- TODO: Lean fails to find `can_lift` instance and fails to use an instance supplied by `letI`\n  rcases@Subtype.exists_pi_extension ι (fun i => { s // s ∈ l i }) _ _ s with ⟨s, rfl⟩\n  exact ⟨fun i => s i, fun i => (s i).2, Pairwise.set_of_subtype _ _ hd⟩\n#align set.pairwise_disjoint.exists_mem_filter Set.PairwiseDisjoint.exists_mem_filter\n-/\n\n",
 "exists_mem_and_iff":
 "theorem exists_mem_and_iff {P : Set α → Prop} {Q : Set α → Prop} (hP : Antitone P) (hQ : Antitone Q) :\n    ((∃ u ∈ f, P u) ∧ ∃ u ∈ f, Q u) ↔ ∃ u ∈ f, P u ∧ Q u :=\n  by\n  constructor\n  · rintro ⟨⟨u, huf, hPu⟩, v, hvf, hQv⟩\n    exact ⟨u ∩ v, inter_mem huf hvf, hP (inter_subset_left _ _) hPu, hQ (inter_subset_right _ _) hQv⟩\n  · rintro ⟨u, huf, hPu, hQu⟩\n    exact ⟨⟨u, huf, hPu⟩, u, huf, hQu⟩\n#align exists_mem_and_iff exists_mem_and_iff\n\n",
 "exists_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem eventually_eq.exists_mem {l : Filter α} {f g : α → β} (h : «expr =ᶠ[ ] » f l g) : ∃ s ∈ l, EqOn f g s :=\n  h.exists_mem\n#align eventually_eq.exists_mem eventually_eq.exists_mem\n\n",
 "exists_Inter_of_mem_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem exists_Inter_of_mem_infi {ι : Type _} {α : Type _} {f : ι → Filter α} {s}\n    (hs : s ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)) :\n    ∃ t : ι → Set α,\n      (∀ i, t i ∈ f i) ∧\n        s = «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (t i) :=\n  let ⟨I, If, V, hVs, hV', hVU, hVU'⟩ := mem_infᵢ'.1 hs\n  ⟨V, hVs, hVU'⟩\n#align exists_Inter_of_mem_infi exists_Inter_of_mem_infi\n\n",
 "exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually.exists {p : α → Prop} {f : Filter α} [NeBot f]\n    (hp :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (p x)) :\n    ∃ x, p x :=\n  hp.frequently.exists\n#align eventually.exists eventually.exists\n\n",
 "eventually_true":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_true (f : Filter α) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f True :=\n  univ_mem\n#align eventually_true eventually_true\n\n",
 "eventually_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem eventually_top {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" («expr⊤»)\n        (p x) ↔\n      ∀ x, p x :=\n  iff.rfl\n#align eventually_top eventually_top\n\n",
 "eventually_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_supr {p : α → Prop} {fs : ι → Filter α} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (fs b)) (p x) ↔\n      ∀ b,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" (fs b)\n          (p x) :=\n  mem_supᵢ\n#align eventually_supr eventually_supr\n\n",
 "eventually_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_sup {p : α → Prop} {f g : Filter α} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        («expr ⊔ » f g) (p x) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (p x) ∧\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" g\n          (p x) :=\n  iff.rfl\n#align eventually_sup eventually_sup\n\n",
 "eventually_sub_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem eventually_sub_nonneg [OrderedRing β] {l : Filter α} {f g : α → β} :\n    «expr ≤ᶠ[ ] » 0 l (g - f) ↔ «expr ≤ᶠ[ ] » f l g :=\n  eventually_congr <| eventually_of_forall fun x => sub_nonneg\n#align eventually_sub_nonneg eventually_sub_nonneg\n\n",
 "eventually_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_pure {a : α} {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" (pure a)\n        (p x) ↔\n      p a :=\n  iff.rfl\n#align eventually_pure eventually_pure\n\n",
 "eventually_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem eventually_principal {a : Set α} {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        ((filter.principal) a) (p x) ↔\n      ∀ x ∈ a, p x :=\n  iff.rfl\n#align eventually_principal eventually_principal\n\n",
 "eventually_or_distrib_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_or_distrib_right {f : Filter α} {p : α → Prop} {q : Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (p x ∨ q) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (p x) ∨\n        q :=\n  by simp only [or_comm' _ q, eventually_or_distrib_left]\n#align eventually_or_distrib_right eventually_or_distrib_right\n\n",
 "eventually_or_distrib_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_or_distrib_left {f : Filter α} {p : Prop} {q : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (p ∨ q x) ↔\n      p ∨\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n          (q x) :=\n  by_cases (fun h : p => by simp [h]) fun h => by simp [h]\n#align eventually_or_distrib_left eventually_or_distrib_left\n\n",
 "eventually_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_of_mem {f : Filter α} {P : α → Prop} {U : Set α} (hU : U ∈ f) (h : ∀ x ∈ U, P x) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (P x) :=\n  mem_of_superset hU h\n#align eventually_of_mem eventually_of_mem\n\n",
 "eventually_of_forall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_of_forall {p : α → Prop} {f : Filter α} (hp : ∀ x, p x) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (p x) :=\n  univ_mem' hp\n#align eventually_of_forall eventually_of_forall\n\n",
 "eventually_mem_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_mem_set {s : Set α} {l : Filter α} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l (x ∈ s) ↔\n      s ∈ l :=\n  iff.rfl\n#align eventually_mem_set eventually_mem_set\n\n",
 "eventually_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_map {P : β → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" (map m f)\n        (P b) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (P (m a)) :=\n  iff.rfl\n#align eventually_map eventually_map\n\n",
 "eventually_le_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem eventually_le_congr {f f' g g' : α → β} (hf : «expr =ᶠ[ ] » f l f') (hg : «expr =ᶠ[ ] » g l g') :\n    «expr ≤ᶠ[ ] » f l g ↔ «expr ≤ᶠ[ ] » f' l g' :=\n  ⟨fun H => H.congr hf hg, fun H => H.congr hf.symm hg.symm⟩\n#align eventually_le_congr eventually_le_congr\n\n",
 "eventually_le_bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n@[simp]\ntheorem eventually_le_bind [LE γ] {f : Filter α} {m : α → Filter β} {g₁ g₂ : β → γ} :\n    «expr ≤ᶠ[ ] » g₁ (bind f m) g₂ ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        («expr ≤ᶠ[ ] » g₁ (m x) g₂) :=\n  iff.rfl\n#align eventually_le_bind eventually_le_bind\n\n",
 "eventually_le_antisymm_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem eventually_le_antisymm_iff [partial_order β] {l : Filter α} {f g : α → β} :\n    «expr =ᶠ[ ] » f l g ↔ «expr ≤ᶠ[ ] » f l g ∧ «expr ≤ᶠ[ ] » g l f := by\n  simp only [eventually_eq, eventually_le, le_antisymm_iff, eventually_and]\n#align eventually_le_antisymm_iff eventually_le_antisymm_iff\n\n",
 "eventually_inf_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_inf_principal {f : Filter α} {p : α → Prop} {s : Set α} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        («expr ⊓ » f ((filter.principal) s)) (p x) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (x ∈ s → p x) :=\n  mem_inf_principal\n#align eventually_inf_principal eventually_inf_principal\n\n",
 "eventually_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem eventually_inf {f g : Filter α} {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        («expr ⊓ » f g) (p x) ↔\n      ∃ s ∈ f, ∃ t ∈ g, ∀ x ∈ s ∩ t, p x :=\n  mem_inf_iff_superset\n#align eventually_inf eventually_inf\n\n",
 "eventually_imp_distrib_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n@[simp]\ntheorem eventually_imp_distrib_right {f : Filter α} {p : α → Prop} {q : Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (p x → q) ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (p x) →\n        q :=\n  by simp only [imp_iff_not_or, eventually_or_distrib_right, not_frequently]\n#align eventually_imp_distrib_right eventually_imp_distrib_right\n\n",
 "eventually_imp_distrib_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_imp_distrib_left {f : Filter α} {p : Prop} {q : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (p → q x) ↔\n      p →\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n          (q x) :=\n  by simp only [imp_iff_not_or, eventually_or_distrib_left]\n#align eventually_imp_distrib_left eventually_imp_distrib_left\n\n",
 "eventually_iff_exists_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_iff_exists_mem {p : α → Prop} {f : Filter α} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (p x) ↔\n      ∃ v ∈ f, ∀ y ∈ v, p y :=\n  exists_mem_subset_iff.symm\n#align eventually_iff_exists_mem eventually_iff_exists_mem\n\n",
 "eventually_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_iff {f : Filter α} {P : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (P x) ↔\n      { x | P x } ∈ f :=\n  iff.rfl\n#align eventually_iff eventually_iff\n\n",
 "eventually_false_iff_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem eventually_false_iff_eq_bot {f : Filter α} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f False ↔\n      f = «expr⊥» :=\n  empty_mem_iff_bot\n#align eventually_false_iff_eq_bot eventually_false_iff_eq_bot\n\n",
 "eventually_eq_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n@[simp]\ntheorem eventually_eq_univ {s : Set α} {l : Filter α} : «expr =ᶠ[ ] » s l univ ↔ s ∈ l := by simp [eventually_eq_set]\n#align eventually_eq_univ eventually_eq_univ\n\n",
 "eventually_eq_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_eq_set {s t : Set α} {l : Filter α} :\n    «expr =ᶠ[ ] » s l t ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (x ∈ s ↔ x ∈ t) :=\n  eventually_congr <| eventually_of_forall fun x => ⟨eq.to_iff, iff.to_eq⟩\n#align eventually_eq_set eventually_eq_set\n\n",
 "eventually_eq_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem eventually_eq_principal {s : Set α} {f g : α → β} : «expr =ᶠ[ ] » f ((filter.principal) s) g ↔ EqOn f g s :=\n  iff.rfl\n#align eventually_eq_principal eventually_eq_principal\n\n",
 "eventually_eq_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem eventually_eq_of_mem {l : Filter α} {f g : α → β} {s : Set α} (hs : s ∈ l) (h : EqOn f g s) :\n    «expr =ᶠ[ ] » f l g :=\n  eventually_of_mem hs h\n#align eventually_eq_of_mem eventually_eq_of_mem\n\n",
 "eventually_eq_of_left_inv_of_right_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem eventually_eq_of_left_inv_of_right_inv {f : α → β} {g₁ g₂ : β → α} {fa : Filter α} {fb : Filter β}\n    (hleft :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" fa\n        (g₁ (f x) = x))\n    (hright :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" fb\n        (f (g₂ y) = y))\n    (htendsto : Tendsto g₂ fb fa) : «expr =ᶠ[ ] » g₁ fb g₂ :=\n  (htendsto.eventually hleft).mp <| hright.mono fun y hr hl => (congr_arg g₁ hr.symm).trans hl\n#align eventually_eq_of_left_inv_of_right_inv eventually_eq_of_left_inv_of_right_inv\n\n",
 "eventually_eq_inf_principal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_eq_inf_principal_iff {F : Filter α} {s : Set α} {f g : α → β} :\n    «expr =ᶠ[ ] » f («expr ⊓ » F ((filter.principal) s)) g ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" F\n        (x ∈ s → f x = g x) :=\n  eventually_inf_principal\n#align eventually_eq_inf_principal_iff eventually_eq_inf_principal_iff\n\n",
 "eventually_eq_iff_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem eventually_eq_iff_sub [AddGroup β] {f g : α → β} {l : Filter α} :\n    «expr =ᶠ[ ] » f l g ↔ «expr =ᶠ[ ] » (f - g) l 0 :=\n  ⟨fun h => h.sub_eq, fun h => by simpa using h.add (eventually_eq.refl l g)⟩\n#align eventually_eq_iff_sub eventually_eq_iff_sub\n\n",
 "eventually_eq_iff_exists_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem eventually_eq_iff_exists_mem {l : Filter α} {f g : α → β} : «expr =ᶠ[ ] » f l g ↔ ∃ s ∈ l, EqOn f g s :=\n  eventually_iff_exists_mem\n#align eventually_eq_iff_exists_mem eventually_eq_iff_exists_mem\n\n",
 "eventually_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_eq_empty {s : Set α} {l : Filter α} :\n    «expr =ᶠ[ ] » s l (∅ : Set α) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (x ∉ s) :=\n  eventuallyEq_set.trans <| by simp\n#align eventually_eq_empty eventually_eq_empty\n\n",
 "eventually_eq_bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n@[simp]\ntheorem eventually_eq_bind {f : Filter α} {m : α → Filter β} {g₁ g₂ : β → γ} :\n    «expr =ᶠ[ ] » g₁ (bind f m) g₂ ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        («expr =ᶠ[ ] » g₁ (m x) g₂) :=\n  iff.rfl\n#align eventually_eq_bind eventually_eq_bind\n\n",
 "eventually_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_const {f : Filter α} [t : NeBot f] {p : Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f p ↔ p :=\n  by_cases (fun h : p => by simp [h]) fun h => by simpa [h] using t.ne\n#align eventually_const eventually_const\n\n",
 "eventually_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_congr {f : Filter α} {p q : α → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (p x ↔ q x)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (p x) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (q x) :=\n  ⟨fun hp => hp.congr h, fun hq => hq.congr <| by simpa only [iff.comm] using h⟩\n#align eventually_congr eventually_congr\n\n",
 "eventually_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_comap :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" (comap f l)\n        (p a) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (∀ a, f a = b → p a) :=\n  mem_comap'\n#align eventually_comap eventually_comap\n\n",
 "eventually_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem eventually_bot {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" («expr⊥»)\n      (p x) :=\n  ⟨⟩\n#align eventually_bot eventually_bot\n\n",
 "eventually_bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_bind {f : Filter α} {m : α → Filter β} {p : β → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" (bind f m)\n        (p y) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        («expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" (m x)\n          (p y)) :=\n  iff.rfl\n#align eventually_bind eventually_bind\n\n",
 "eventually_and":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_and {p q : α → Prop} {f : Filter α} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (p x ∧ q x) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (p x) ∧\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n          (q x) :=\n  inter_mem_iff\n#align eventually_and eventually_and\n\n",
 "eventually_all_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_all_finset {ι} (I : Finset ι) {l} {p : ι → α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (∀ i ∈ I, p i x) ↔\n      ∀ i ∈ I,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n          (p i x) :=\n  I.finite_to_set.eventually_all\n#align eventually_all_finset eventually_all_finset\n\n",
 "eventually_all_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_all_finite {ι} {I : Set ι} (hI : I.finite) {l} {p : ι → α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (∀ i ∈ I, p i x) ↔\n      ∀ i ∈ I,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n          (p i x) :=\n  by simpa only [Filter.Eventually, set_of_forall] using bInter_mem hI\n#align eventually_all_finite eventually_all_finite\n\n",
 "eventually_all":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_all {ι : Type _} [Finite ι] {l} {p : ι → α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (∀ i, p i x) ↔\n      ∀ i,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n          (p i x) :=\n  by\n  cases nonempty_fintype ι\n  simpa only [Filter.Eventually, set_of_forall] using Inter_mem\n#align eventually_all eventually_all\n\n",
 "eventually_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_Sup {p : α → Prop} {fs : Set (Filter α)} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" (supₛ fs)\n        (p x) ↔\n      ∀ f ∈ fs,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n          (p x) :=\n  iff.rfl\n#align eventually_Sup eventually_Sup\n\n",
 "eventuallyLE":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n#print HasSubset.Subset.eventuallyLE /-\ntheorem HasSubset.Subset.eventuallyLE {α} {l : Filter α} {s t : Set α} (h : s ⊆ t) : «expr ≤ᶠ[ ] » s l t :=\n  Filter.eventually_of_forall h\n#align has_subset.subset.eventually_le HasSubset.Subset.eventuallyLE\n-/\n\n",
 "eventuallyEq_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n#print Set.EqOn.eventuallyEq_of_mem /-\ntheorem Set.EqOn.eventuallyEq_of_mem {α β} {s : Set α} {l : Filter α} {f g : α → β} (h : EqOn f g s) (hl : s ∈ l) :\n    «expr =ᶠ[ ] » f l g :=\n  h.eventually_eq.filter_mono <| Filter.le_principal_iff.2 hl\n#align set.eq_on.eventually_eq_of_mem Set.EqOn.eventuallyEq_of_mem\n-/\n\n",
 "eventuallyEq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print Set.EqOn.eventuallyEq /-\ntheorem Set.EqOn.eventuallyEq {α β} {s : Set α} {f g : α → β} (h : EqOn f g s) :\n    «expr =ᶠ[ ] » f ((filter.principal) s) g :=\n  h\n#align set.eq_on.eventually_eq Set.EqOn.eventuallyEq\n-/\n\n",
 "eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.eventually {f : α → β} {l₁ : Filter α} {l₂ : Filter β} {p : β → Prop} (hf : Tendsto f l₁ l₂)\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l₂\n        (p y)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l₁\n      (p (f x)) :=\n  hf h\n#align tendsto.eventually tendsto.eventually\n\n",
 "eq_top_of_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- There are only two filters on a `subsingleton`: `⊥` and `⊤`. If the type is empty, then they are\nequal. -/\ntheorem eq_top_of_ne_bot [subsingleton α] (l : Filter α) [NeBot l] : l = «expr⊤» :=\n  by\n  refine' top_unique fun s hs => _\n  obtain rfl : s = univ; exact Subsingleton.eq_univ_of_nonempty (nonempty_of_mem hs)\n  exact univ_mem\n#align eq_top_of_ne_bot eq_top_of_ne_bot\n\n",
 "eq_infi_of_mem_iff_exists_mem":
 "theorem eq_infi_of_mem_iff_exists_mem {f : ι → Filter α} {l : Filter α} (h : ∀ {s}, s ∈ l ↔ ∃ i, s ∈ f i) :\n    l = infᵢ f :=\n  eq_infₛ_of_mem_iff_exists_mem fun s => h.trans exists_range_iff.symm\n#align eq_infi_of_mem_iff_exists_mem eq_infi_of_mem_iff_exists_mem\n\n",
 "eq_binfi_of_mem_iff_exists_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem eq_binfi_of_mem_iff_exists_mem {f : ι → Filter α} {p : ι → Prop} {l : Filter α}\n    (h : ∀ {s}, s ∈ l ↔ ∃ (i : _)(_ : p i), s ∈ f i) :\n    l = «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i) :=\n  by\n  rw [infᵢ_subtype']\n  apply eq_infi_of_mem_iff_exists_mem\n  intro s\n  exact h.trans ⟨fun ⟨i, pi, si⟩ => ⟨⟨i, pi⟩, si⟩, fun ⟨⟨i, pi⟩, si⟩ => ⟨i, pi, si⟩⟩\n#align eq_binfi_of_mem_iff_exists_mem eq_binfi_of_mem_iff_exists_mem\n\n",
 "eq_Inf_of_mem_iff_exists_mem":
 "theorem eq_Inf_of_mem_iff_exists_mem {S : Set (Filter α)} {l : Filter α} (h : ∀ {s}, s ∈ l ↔ ∃ f ∈ S, s ∈ f) :\n    l = infₛ S :=\n  le_antisymm (le_infₛ fun f hf s hs => h.2 ⟨f, hf, hs⟩) fun s hs =>\n    let ⟨f, hf, hs⟩ := h.1 hs\n    (infₛ_le hf : infₛ S ≤ f) hs\n#align eq_Inf_of_mem_iff_exists_mem eq_Inf_of_mem_iff_exists_mem\n\n",
 "empty_not_mem":
 "@[simp]\ntheorem empty_not_mem (f : Filter α) [NeBot f] : ¬∅ ∈ f := fun h => (nonempty_of_mem h).ne_empty rfl\n#align empty_not_mem empty_not_mem\n\n",
 "empty_mem_iff_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem empty_mem_iff_bot {f : Filter α} : ∅ ∈ f ↔ f = «expr⊥» :=\n  ⟨fun h => bot_unique fun s _ => mem_of_superset h (empty_subset s), fun h => h.symm ▸ mem_bot⟩\n#align empty_mem_iff_bot empty_mem_iff_bot\n\n",
 "div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n@[to_additive]\ntheorem eventually_eq.div [Div β] {f f' g g' : α → β} {l : Filter α} (h : «expr =ᶠ[ ] » f l g)\n    (h' : «expr =ᶠ[ ] » f' l g') : «expr =ᶠ[ ] » (fun x => f x / f' x) l fun x => g x / g' x :=\n  h.comp₂ (· / ·) h'\n#align eventually_eq.div eventually_eq.div\n\n",
 "disjoint_of_disjoint_of_mem":
 "theorem disjoint_of_disjoint_of_mem {f g : Filter α} {s t : Set α} (h : Disjoint s t) (hs : s ∈ f) (ht : t ∈ g) :\n    Disjoint f g :=\n  Filter.disjoint_iff.mpr ⟨s, hs, t, ht, h⟩\n#align disjoint_of_disjoint_of_mem disjoint_of_disjoint_of_mem\n\n",
 "disjoint_map":
 "theorem disjoint_map {m : α → β} (hm : injective m) {f₁ f₂ : Filter α} :\n    Disjoint (map m f₁) (map m f₂) ↔ Disjoint f₁ f₂ := by simp only [disjoint_iff, ← map_inf hm, map_eq_bot_iff]\n#align disjoint_map disjoint_map\n\n",
 "disjoint_iff":
 "#print disjoint_iff /-\nprotected theorem disjoint_iff {f g : Filter α} : Disjoint f g ↔ ∃ s ∈ f, ∃ t ∈ g, Disjoint s t := by\n  simp only [disjoint_iff, ← empty_mem_iff_bot, mem_inf_iff, inf_eq_inter, bot_eq_empty, @eq_comm _ ∅]\n#align disjoint_iff disjoint_iff\n-/\n\n",
 "disjoint_comap_iff":
 "theorem disjoint_comap_iff (h : surjective m) : Disjoint (comap m g₁) (comap m g₂) ↔ Disjoint g₁ g₂ := by\n  rw [disjoint_iff, disjoint_iff, ← comap_inf, comap_surjective_eq_bot h]\n#align disjoint_comap_iff disjoint_comap_iff\n\n",
 "disjoint_comap":
 "theorem disjoint_comap (h : Disjoint g₁ g₂) : Disjoint (comap m g₁) (comap m g₂) := by\n  simp only [disjoint_iff, ← comap_inf, h.eq_bot, comap_bot]\n#align disjoint_comap disjoint_comap\n\n",
 "disjoint":
 "protected theorem tendsto.disjoint {f : α → β} {la₁ la₂ : Filter α} {lb₁ lb₂ : Filter β} (h₁ : Tendsto f la₁ lb₁)\n    (hd : Disjoint lb₁ lb₂) (h₂ : Tendsto f la₂ lb₂) : Disjoint la₁ la₂ :=\n  (disjoint_comap hd).mono h₁.le_comap h₂.le_comap\n#align tendsto.disjoint tendsto.disjoint\n\n",
 "diff_mem_inf_principal_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem diff_mem_inf_principal_compl {f : Filter α} {s : Set α} (hs : s ∈ f) (t : Set α) :\n    s \\ t ∈ «expr ⊓ » f ((filter.principal) («expr ᶜ» t)) :=\n  inter_mem_inf hs <| mem_principal_self («expr ᶜ» t)\n#align diff_mem_inf_principal_compl diff_mem_inf_principal_compl\n\n",
 "diff_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem diff_mem {s t : Set α} (hs : s ∈ f) (ht : «expr ᶜ» t ∈ f) : s \\ t ∈ f :=\n  inter_mem hs ht\n#align diff_mem diff_mem\n\n",
 "diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n@[mono]\ntheorem eventually_le.diff {s t s' t' : Set α} {l : Filter α} (h : «expr ≤ᶠ[ ] » s l t) (h' : «expr ≤ᶠ[ ] » t' l s') :\n    «expr ≤ᶠ[ ] » (s \\ s' : Set α) l (t \\ t' : Set α) :=\n  h.inter h'.compl\n#align eventually_le.diff eventually_le.diff\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem eventually_eq.const_smul {𝕜} [SMul 𝕜 β] {l : Filter α} {f g : α → β} (h : «expr =ᶠ[ ] » f l g) (c : 𝕜) :\n    «expr =ᶠ[ ] » (fun x => «expr • » c (f x)) l fun x => «expr • » c (g x) :=\n  h.fun_comp fun x => «expr • » c x\n#align eventually_eq.const_smul eventually_eq.const_smul\n\n",
 "congr_sets":
 "theorem congr_sets (h : { x | x ∈ s ↔ x ∈ t } ∈ f) : s ∈ f ↔ t ∈ f :=\n  ⟨fun hs => mp_mem hs (mem_of_superset h fun x => Iff.mp), fun hs => mp_mem hs (mem_of_superset h fun x => Iff.mpr)⟩\n#align congr_sets congr_sets\n\n",
 "congr'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem tendsto.congr' {f₁ f₂ : α → β} {l₁ : Filter α} {l₂ : Filter β} (hl : «expr =ᶠ[ ] » f₁ l₁ f₂)\n    (h : Tendsto f₁ l₁ l₂) : Tendsto f₂ l₁ l₂ :=\n  (tendsto_congr' hl).1 h\n#align tendsto.congr' tendsto.congr'\n\n",
 "congr":
 "theorem tendsto.congr {f₁ f₂ : α → β} {l₁ : Filter α} {l₂ : Filter β} (h : ∀ x, f₁ x = f₂ x) :\n    Tendsto f₁ l₁ l₂ → Tendsto f₂ l₁ l₂ :=\n  (tendsto_congr h).1\n#align tendsto.congr tendsto.congr\n\n",
 "comp₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem eventually_eq.comp₂ {δ} {f f' : α → β} {g g' : α → γ} {l} (Hf : «expr =ᶠ[ ] » f l f') (h : β → γ → δ)\n    (Hg : «expr =ᶠ[ ] » g l g') : «expr =ᶠ[ ] » (fun x => h (f x) (g x)) l fun x => h (f' x) (g' x) :=\n  (Hf.prod_mk Hg).fun_comp (uncurry h)\n#align eventually_eq.comp₂ eventually_eq.comp₂\n\n",
 "compl_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem compl_not_mem {f : Filter α} {s : Set α} [NeBot f] (h : s ∈ f) : «expr ᶜ» s ∉ f := fun hsc =>\n  (nonempty_of_mem (inter_mem h hsc)).ne_empty <| inter_compl_self s\n#align compl_not_mem compl_not_mem\n\n",
 "compl_mem_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem compl_mem_comap : «expr ᶜ» s ∈ comap f l ↔ «expr ᶜ» («expr '' » f s) ∈ l := by\n  rw [mem_comap_iff_compl, compl_compl]\n#align compl_mem_comap compl_mem_comap\n\n",
 "compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[mono]\ntheorem eventually_le.compl {s t : Set α} {l : Filter α} (h : «expr ≤ᶠ[ ] » s l t) :\n    «expr ≤ᶠ[ ] » («expr ᶜ» t : Set α) l («expr ᶜ» s : Set α) :=\n  h.mono fun x => mt\n#align eventually_le.compl eventually_le.compl\n\n",
 "comp":
 "theorem tendsto.comp {f : α → β} {g : β → γ} {x : Filter α} {y : Filter β} {z : Filter γ} (hg : Tendsto g y z)\n    (hf : Tendsto f x y) : Tendsto (g ∘ f) x z := fun s hs => hf (hg hs)\n#align tendsto.comp tendsto.comp\n\n",
 "comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_top : comap m («expr⊤») = «expr⊤» :=\n  (gc_map_comap m).u_top\n#align comap_top comap_top\n\n",
 "comap_surjective_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem comap_surjective_eq_bot {f : Filter β} {m : α → β} (hm : surjective m) : comap m f = «expr⊥» ↔ f = «expr⊥» := by\n  rw [comap_eq_bot_iff_compl_range, hm.range_eq, compl_univ, empty_mem_iff_bot]\n#align comap_surjective_eq_bot comap_surjective_eq_bot\n\n",
 "comap_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem comap_supr {ι} {f : ι → Filter β} {m : α → β} :\n    comap m (supᵢ f) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (comap m (f i)) :=\n  le_antisymm\n    (fun s hs =>\n      have : ∀ i, ∃ t, t ∈ f i ∧ «expr ⁻¹' » m t ⊆ s := by\n        simpa only [mem_comap, exists_prop, mem_supr] using mem_supr.1 hs\n      let ⟨t, ht⟩ := classical.axiom_of_choice this\n      ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i),\n        mem_supᵢ.2 fun i => (f i).sets_of_superset (ht i).1 (subset_unionᵢ _ _),\n        by\n        rw [preimage_Union, Union_subset_iff]\n        exact fun i => (ht i).2⟩)\n    (supᵢ_le fun i => comap_mono <| le_supᵢ _ _)\n#align comap_supr comap_supr\n\n",
 "comap_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem comap_sup : comap m («expr ⊔ » g₁ g₂) = «expr ⊔ » (comap m g₁) (comap m g₂) := by\n  rw [sup_eq_supᵢ, comap_supr, supᵢ_bool_eq, Bool.cond_true, Bool.cond_false]\n#align comap_sup comap_sup\n\n",
 "comap_snd_ne_bot_iff":
 "@[simp]\ntheorem comap_snd_ne_bot_iff {f : Filter β} : (f.comap (Prod.snd : α × β → β)).ne_bot ↔ Nonempty α ∧ f.ne_bot :=\n  by\n  cases' isEmpty_or_nonempty α with hα hα\n  · rw [filter_eq_bot_of_is_empty (f.comap _), ← not_iff_not] <;> [simp, infer_instance]\n  · simp [comap_ne_bot_iff_frequently, hα]\n#align comap_snd_ne_bot_iff comap_snd_ne_bot_iff\n\n",
 "comap_snd_ne_bot":
 "@[instance]\ntheorem comap_snd_ne_bot [Nonempty α] {f : Filter β} [NeBot f] : (f.comap (Prod.snd : α × β → β)).ne_bot :=\n  comap_snd_neBot_iff.2 ⟨‹_›, ‹_›⟩\n#align comap_snd_ne_bot comap_snd_ne_bot\n\n",
 "comap_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem comap_pure {b : β} : comap m (pure b) = (filter.principal) («expr ⁻¹' » m {b}) := by\n  rw [← principal_singleton, comap_principal]\n#align comap_pure comap_pure\n\n",
 "comap_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem comap_principal {t : Set β} : comap m ((filter.principal) t) = (filter.principal) («expr ⁻¹' » m t) :=\n  Filter.ext fun s =>\n    ⟨fun ⟨u, (hu : t ⊆ u), (b : preimage m u ⊆ s)⟩ => (preimage_mono hu).trans b, fun h => ⟨t, Subset.refl t, h⟩⟩\n#align comap_principal comap_principal\n\n",
 "comap_of_surj":
 "theorem ne_bot.comap_of_surj {f : Filter β} {m : α → β} (hf : NeBot f) (hm : surjective m) : NeBot (comap m f) :=\n  hf.comap_of_range_mem <| univ_mem' hm\n#align ne_bot.comap_of_surj ne_bot.comap_of_surj\n\n",
 "comap_of_range_mem":
 "theorem ne_bot.comap_of_range_mem {f : Filter β} {m : α → β} (hf : NeBot f) (hm : range m ∈ f) : NeBot (comap m f) :=\n  comap_neBot_iff_frequently.2 <| Eventually.frequently hm\n#align ne_bot.comap_of_range_mem ne_bot.comap_of_range_mem\n\n",
 "comap_of_image_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem ne_bot.comap_of_image_mem {f : Filter β} {m : α → β} (hf : NeBot f) {s : Set α} (hs : «expr '' » m s ∈ f) :\n    NeBot (comap m f) :=\n  hf.comap_of_range_mem <| mem_of_superset hs (image_subset_range _ _)\n#align ne_bot.comap_of_image_mem ne_bot.comap_of_image_mem\n\n",
 "comap_ne_bot_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem comap_ne_bot_iff_frequently {f : Filter β} {m : α → β} :\n    NeBot (comap m f) ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n        (y ∈ range m) :=\n  by simp [comap_ne_bot_iff, frequently_iff, ← exists_and_left, and_comm]\n#align comap_ne_bot_iff_frequently comap_ne_bot_iff_frequently\n\n",
 "comap_ne_bot_iff_compl_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem comap_ne_bot_iff_compl_range {f : Filter β} {m : α → β} : NeBot (comap m f) ↔ «expr ᶜ» (range m) ∉ f :=\n  comap_neBot_iff_frequently\n#align comap_ne_bot_iff_compl_range comap_ne_bot_iff_compl_range\n\n",
 "comap_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem comap_ne_bot_iff {f : Filter β} {m : α → β} : NeBot (comap m f) ↔ ∀ t ∈ f, ∃ a, m a ∈ t :=\n  by\n  simp only [← forall_mem_nonempty_iff_ne_bot, mem_comap, forall_exists_index]\n  exact ⟨fun h t t_in => h («expr ⁻¹' » m t) t t_in subset.rfl, fun h s t ht hst => (h t ht).imp hst⟩\n#align comap_ne_bot_iff comap_ne_bot_iff\n\n",
 "comap_ne_bot":
 "theorem comap_ne_bot {f : Filter β} {m : α → β} (hm : ∀ t ∈ f, ∃ a, m a ∈ t) : NeBot (comap m f) :=\n  comap_neBot_iff.mpr hm\n#align comap_ne_bot comap_ne_bot\n\n",
 "comap_mono":
 "@[mono]\ntheorem comap_mono : Monotone (comap m) :=\n  (gc_map_comap m).monotone_u\n#align comap_mono comap_mono\n\n",
 "comap_map":
 "theorem comap_map {f : Filter α} {m : α → β} (h : injective m) : comap m (map m f) = f :=\n  le_antisymm\n    (fun s hs => mem_of_superset (preimage_mem_comap <| image_mem_map hs) <| by simp only [preimage_image_eq s h])\n    le_comap_map\n#align comap_map comap_map\n\n",
 "comap_le_comap_iff":
 "theorem comap_le_comap_iff {f g : Filter β} {m : α → β} (hf : range m ∈ f) : comap m f ≤ comap m g ↔ f ≤ g :=\n  ⟨fun h => map_comap_of_mem hf ▸ (map_mono h).trans map_comap_le, fun h => comap_mono h⟩\n#align comap_le_comap_iff comap_le_comap_iff\n\n",
 "comap_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem comap_infi {f : ι → Filter β} :\n    comap m («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (comap m (f i)) :=\n  (gc_map_comap m).u_infi\n#align comap_infi comap_infi\n\n",
 "comap_inf_principal_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem comap_inf_principal_range : comap m («expr ⊓ » g ((filter.principal) (range m))) = comap m g := by simp\n#align comap_inf_principal_range comap_inf_principal_range\n\n",
 "comap_inf_principal_ne_bot_of_image_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem comap_inf_principal_ne_bot_of_image_mem {f : Filter β} {m : α → β} (hf : NeBot f) {s : Set α}\n    (hs : «expr '' » m s ∈ f) : NeBot («expr ⊓ » (comap m f) ((filter.principal) s)) :=\n  by\n  refine' ⟨compl_compl s ▸ mt mem_of_eq_bot _⟩\n  rintro ⟨t, ht, hts⟩\n  rcases hf.nonempty_of_mem (inter_mem hs ht) with ⟨_, ⟨x, hxs, rfl⟩, hxt⟩\n  exact absurd hxs (hts hxt)\n#align comap_inf_principal_ne_bot_of_image_mem comap_inf_principal_ne_bot_of_image_mem\n\n",
 "comap_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem comap_inf : comap m («expr ⊓ » g₁ g₂) = «expr ⊓ » (comap m g₁) (comap m g₂) :=\n  (gc_map_comap m).u_inf\n#align comap_inf comap_inf\n\n",
 "comap_id'":
 "theorem comap_id' : comap (fun x => x) f = f :=\n  comap_id\n#align comap_id' comap_id'\n\n",
 "comap_id":
 "theorem comap_id : comap id f = f :=\n  le_antisymm (fun s => preimage_mem_comap) fun s ⟨t, ht, hst⟩ => mem_of_superset ht hst\n#align comap_id comap_id\n\n",
 "comap_fst_ne_bot_iff":
 "@[simp]\ntheorem comap_fst_ne_bot_iff {f : Filter α} : (f.comap (Prod.fst : α × β → α)).ne_bot ↔ f.ne_bot ∧ Nonempty β :=\n  by\n  cases isEmpty_or_nonempty β\n  · rw [filter_eq_bot_of_is_empty (f.comap _), ← not_iff_not] <;> [simp [*], infer_instance]\n  · simp [comap_ne_bot_iff_frequently, h]\n#align comap_fst_ne_bot_iff comap_fst_ne_bot_iff\n\n",
 "comap_fst_ne_bot":
 "@[instance]\ntheorem comap_fst_ne_bot [Nonempty β] {f : Filter α} [NeBot f] : (f.comap (Prod.fst : α × β → α)).ne_bot :=\n  comap_fst_neBot_iff.2 ⟨‹_›, ‹_›⟩\n#align comap_fst_ne_bot comap_fst_ne_bot\n\n",
 "comap_eval_ne_bot_iff'":
 "theorem comap_eval_ne_bot_iff' {ι : Type _} {α : ι → Type _} {i : ι} {f : Filter (α i)} :\n    (comap (eval i) f).ne_bot ↔ (∀ j, Nonempty (α j)) ∧ NeBot f :=\n  by\n  cases' isEmpty_or_nonempty (∀ j, α j) with H H\n  · rw [filter_eq_bot_of_is_empty (f.comap _), ← not_iff_not] <;> [skip, assumption]\n    simp [← Classical.nonempty_pi]\n  · have : ∀ j, Nonempty (α j) := Classical.nonempty_pi.1 H\n    simp [comap_ne_bot_iff_frequently, *]\n#align comap_eval_ne_bot_iff' comap_eval_ne_bot_iff'\n\n",
 "comap_eval_ne_bot_iff":
 "@[simp]\ntheorem comap_eval_ne_bot_iff {ι : Type _} {α : ι → Type _} [∀ j, Nonempty (α j)] {i : ι} {f : Filter (α i)} :\n    (comap (eval i) f).ne_bot ↔ NeBot f := by simp [comap_eval_ne_bot_iff', *]\n#align comap_eval_ne_bot_iff comap_eval_ne_bot_iff\n\n",
 "comap_eval_ne_bot":
 "@[instance]\ntheorem comap_eval_ne_bot {ι : Type _} {α : ι → Type _} [∀ j, Nonempty (α j)] (i : ι) (f : Filter (α i)) [NeBot f] :\n    (comap (eval i) f).ne_bot :=\n  comap_eval_neBot_iff.2 ‹_›\n#align comap_eval_ne_bot comap_eval_ne_bot\n\n",
 "comap_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem comap_equiv_symm (e : «expr ≃ » α β) (f : Filter α) : comap e.symm f = map e f :=\n  (map_eq_comap_of_inverse e.self_comp_symm e.symm_comp_self).symm\n#align comap_equiv_symm comap_equiv_symm\n\n",
 "comap_eq_of_inverse":
 "theorem comap_eq_of_inverse {f : Filter α} {g : Filter β} {φ : α → β} (ψ : β → α) (eq : ψ ∘ φ = id) (hφ : Tendsto φ f g)\n    (hψ : Tendsto ψ g f) : comap φ g = f :=\n  by\n  refine' ((comap_mono <| map_le_iff_le_comap.1 hψ).trans _).antisymm (map_le_iff_le_comap.1 hφ)\n  rw [comap_comap, Eq, comap_id]\n  exact le_rfl\n#align comap_eq_of_inverse comap_eq_of_inverse\n\n",
 "comap_eq_bot_iff_compl_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem comap_eq_bot_iff_compl_range {f : Filter β} {m : α → β} : comap m f = «expr⊥» ↔ «expr ᶜ» (range m) ∈ f :=\n  not_iff_not.mp <| neBot_iff.symm.trans comap_neBot_iff_compl_range\n#align comap_eq_bot_iff_compl_range comap_eq_bot_iff_compl_range\n\n",
 "comap_const_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem comap_const_of_not_mem {x : β} (ht : t ∈ g) (hx : x ∉ t) : comap (fun y : α => x) g = «expr⊥» :=\n  empty_mem_iff_bot.1 <| mem_comap'.2 <| mem_of_superset ht fun x' hx' y h => hx <| h.symm ▸ hx'\n#align comap_const_of_not_mem comap_const_of_not_mem\n\n",
 "comap_const_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem comap_const_of_mem {x : β} (h : ∀ t ∈ g, x ∈ t) : comap (fun y : α => x) g = «expr⊤» :=\n  top_unique fun s hs => univ_mem' fun y => h _ (mem_comap'.1 hs) rfl\n#align comap_const_of_mem comap_const_of_mem\n\n",
 "comap_comm":
 "theorem comap_comm (G : Filter δ) : comap φ (comap ψ G) = comap θ (comap ρ G) := by\n  rw [Filter.comap_comap, H, ← Filter.comap_comap]\n#align comap_comm comap_comm\n\n",
 "comap_comap":
 "theorem comap_comap {m : γ → β} {n : β → α} : comap m (comap n f) = comap (n ∘ m) f :=\n  Filter.coext fun s => by simp only [compl_mem_comap, image_image]\n#align comap_comap comap_comap\n\n",
 "comap_coe_ne_bot_of_le_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem comap_coe_ne_bot_of_le_principal {s : Set γ} {l : Filter γ} [h : NeBot l] (h' : l ≤ (filter.principal) s) :\n    NeBot (comap (coe : s → γ) l) :=\n  h.comap_of_range_mem <| (@Subtype.range_coe γ s).symm ▸ h' (mem_principal_self s)\n#align comap_coe_ne_bot_of_le_principal comap_coe_ne_bot_of_le_principal\n\n",
 "comap_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem comap_bot : comap m («expr⊥») = «expr⊥» :=\n  bot_unique fun s _ => ⟨∅, mem_bot, by simp only [empty_subset, preimage_empty]⟩\n#align comap_bot comap_bot\n\n",
 "comap_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem comap_Sup {s : Set (Filter β)} {m : α → β} :\n    comap m (supₛ s) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (comap m f) :=\n  by simp only [supₛ_eq_supᵢ, comap_supr, eq_self_iff_true]\n#align comap_Sup comap_Sup\n\n",
 "comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually.comap {p : β → Prop}\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" g (p b))\n    (f : α → β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" (comap f g)\n      (p (f a)) :=\n  preimage_mem_comap hf\n#align eventually.comap eventually.comap\n\n",
 "coext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- An extensionality lemma that is useful for filters with good lemmas about `sᶜ ∈ f` (e.g.,\n`filter.comap`, `filter.coprod`, `filter.Coprod`, `filter.cofinite`). -/\nprotected theorem coext (h : ∀ s, «expr ᶜ» s ∈ f ↔ «expr ᶜ» s ∈ g) : f = g :=\n  Filter.ext <| compl_surjective.forall.2 h\n#align coext coext\n\n",
 "choice":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually.choice {r : α → β → Prop} {l : Filter α} [l.ne_bot]\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (∃ y, r x y)) :\n    ∃ f : α → β,\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (r x (f x)) :=\n  by\n  classical\n    use fun x => if hx : ∃ y, r x y then Classical.choose hx else Classical.choose (Classical.choose_spec h.exists)\n    filter_upwards [h]\n    intro x hx\n    rw [dif_pos hx]\n    exact Classical.choose_spec hx\n#align eventually.choice eventually.choice\n\n",
 "bot_sets_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem bot_sets_eq : («expr⊥» : Filter α).sets = univ :=\n  rfl\n#align bot_sets_eq bot_sets_eq\n\n",
 "binfi_sets_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹'o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem binfi_sets_eq {f : β → Filter α} {s : Set β} (h : DirectedOn («expr ⁻¹'o » f (· ≥ ·)) s) (ne : s.nonempty) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)).sets =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i).sets :=\n  ext fun t => by simp [mem_binfi_of_directed h ne]\n#align binfi_sets_eq binfi_sets_eq\n\n",
 "bind_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n@[mono]\ntheorem bind_mono {f₁ f₂ : Filter α} {g₁ g₂ : α → Filter β} (hf : f₁ ≤ f₂) (hg : «expr ≤ᶠ[ ] » g₁ f₁ g₂) :\n    bind f₁ g₁ ≤ bind f₂ g₂ :=\n  by\n  refine' le_trans (fun s hs => _) (join_mono <| map_mono hf)\n  simp only [mem_join, mem_bind', mem_map] at hs⊢\n  filter_upwards [hg, hs]with _ hx hs using hx hs\n#align bind_mono bind_mono\n\n",
 "bind_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem bind_le {f : Filter α} {g : α → Filter β} {l : Filter β}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (g x ≤ l)) :\n    f.bind g ≤ l :=\n  join_le <| eventually_map.2 h\n#align bind_le bind_le\n\n",
 "bind_inf_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem bind_inf_principal {f : Filter α} {g : α → Filter β} {s : Set β} :\n    (f.bind fun x => «expr ⊓ » (g x) ((filter.principal) s)) = «expr ⊓ » (f.bind g) ((filter.principal) s) :=\n  Filter.ext fun s => by simp only [mem_bind, mem_inf_principal]\n#align bind_inf_principal bind_inf_principal\n\n",
 "bind_def":
 "@[simp]\ntheorem bind_def {α β} (f : Filter α) (m : α → Filter β) : f >>= m = bind f m :=\n  rfl\n#align bind_def bind_def\n\n",
 "bInter_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp]\ntheorem bInter_mem {β : Type v} {s : β → Set α} {is : Set β} (hf : is.finite) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i) ∈ f ↔\n      ∀ i ∈ is, s i ∈ f :=\n  Finite.induction_on hf (by simp) fun i s hi _ hs => by simp [hs]\n#align bInter_mem bInter_mem\n\n",
 "bInter_finset_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp]\ntheorem bInter_finset_mem {β : Type v} {s : β → Set α} (is : Finset β) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i) ∈ f ↔\n      ∀ i ∈ is, s i ∈ f :=\n  binterᵢ_mem is.finite_to_set\n#align bInter_finset_mem bInter_finset_mem\n\n",
 "antisymm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem eventually_le.antisymm [partial_order β] {l : Filter α} {f g : α → β} (h₁ : «expr ≤ᶠ[ ] » f l g)\n    (h₂ : «expr ≤ᶠ[ ] » g l f) : «expr =ᶠ[ ] » f l g :=\n  h₂.mp <| h₁.mono fun x => le_antisymm\n#align eventually_le.antisymm eventually_le.antisymm\n\n",
 "and_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem eventually.and_frequently {p q : α → Prop} {f : Filter α}\n    (hp :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (p x))\n    (hq :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (q x)) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n      (p x ∧ q x) :=\n  by simpa only [and_comm] using hq.and_eventually hp\n#align eventually.and_frequently eventually.and_frequently\n\n",
 "and_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently.and_eventually {p q : α → Prop} {f : Filter α}\n    (hp :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f (p x))\n    (hq :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f (q x)) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" f\n      (p x ∧ q x) :=\n  by\n  refine' mt (fun h => hq.mp <| h.mono _) hp\n  exact fun x hpq hq hp => hpq ⟨hp, hq⟩\n#align frequently.and_eventually frequently.and_eventually\n\n",
 "and":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\nprotected theorem eventually.and {p q : α → Prop} {f : Filter α} :\n    f.eventually p →\n      f.eventually q →\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n          (p x ∧ q x) :=\n  inter_mem\n#align eventually.and eventually.and\n\n",
 "Sup_sets_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem Sup_sets_eq {s : Set (Filter α)} :\n    (supₛ s).sets =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (f : Filter α).sets :=\n  (giGenerate α).gc.u_Inf\n#align Sup_sets_eq Sup_sets_eq\n\n",
 "LawfulMonad":
 "#print LawfulMonad /-\n-- this section needs to be before applicative, otherwise the wrong instance will be chosen\nprotected theorem LawfulMonad : LawfulMonad Filter :=\n  { id_map := fun α f => filter_eq rfl\n    pure_bind := fun α β => pure_bind\n    bind_assoc := fun α β γ f m₁ m₂ => filter_eq rfl\n    bind_pure_comp_eq_map := fun α β f x =>\n      Filter.ext fun s => by\n        simp only [has_bind.bind, bind, functor.map, mem_map', mem_join, mem_set_of_eq, comp, mem_pure] }\n#align is_lawful_monad LawfulMonad\n-/\n\n",
 "Inter_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp]\ntheorem Inter_mem {β : Type v} {s : β → Set α} [Finite β] :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i) ∈ f ↔\n      ∀ i, s i ∈ f :=\n  by simpa using bInter_mem finite_univ\n#align Inter_mem Inter_mem\n\n",
 "Inf_ne_bot_of_directed'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem Inf_ne_bot_of_directed' {s : Set (Filter α)} (hne : s.nonempty) (hd : DirectedOn (· ≥ ·) s)\n    (hbot : «expr⊥» ∉ s) : NeBot (infₛ s) :=\n  (infₛ_eq_infᵢ' s).symm ▸\n    @infᵢ_neBot_of_directed' _ _ _ hne.to_subtype hd.directed_coe fun ⟨f, hf⟩ => ⟨ne_of_mem_of_not_mem hf hbot⟩\n#align Inf_ne_bot_of_directed' Inf_ne_bot_of_directed'\n\n",
 "Inf_ne_bot_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem Inf_ne_bot_of_directed [Nonempty α] {s : Set (Filter α)} (hd : DirectedOn (· ≥ ·) s) (hbot : «expr⊥» ∉ s) :\n    NeBot (infₛ s) :=\n  (infₛ_eq_infᵢ' s).symm ▸ infᵢ_neBot_of_directed hd.directed_coe fun ⟨f, hf⟩ => ⟨ne_of_mem_of_not_mem hf hbot⟩\n#align Inf_ne_bot_of_directed Inf_ne_bot_of_directed\n\n",
 "Iic_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem Iic_principal (s : Set α) : Iic ((filter.principal) s) = { l | s ∈ l } :=\n  Set.ext fun x => le_principal_iff\n#align Iic_principal Iic_principal\n\n"}