{"tendsto_pi":
 "theorem tendsto_pi {β : Type _} {m : β → ∀ i, α i} {l : Filter β} :\n    Tendsto m l (pi f) ↔ ∀ i, Tendsto (fun x => m x i) l (f i) := by simp only [pi, tendsto_infi, tendsto_comap_iff]\n#align tendsto_pi tendsto_pi\n\n",
 "tendsto_eval_pi":
 "/-\nCopyright (c) 2021 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov, Alex Kontorovich\n-/\ntheorem tendsto_eval_pi (f : ∀ i, Filter (α i)) (i : ι) : Tendsto (eval i) (pi f) (f i) :=\n  tendsto_infᵢ' i tendsto_comap\n#align tendsto_eval_pi tendsto_eval_pi\n\n",
 "pi_ne_bot":
 "@[simp]\ntheorem pi_ne_bot : NeBot (pi f) ↔ ∀ i, NeBot (f i) := by simp [ne_bot_iff]\n#align pi_ne_bot pi_ne_bot\n\n",
 "pi_mono":
 "@[mono]\ntheorem pi_mono (h : ∀ i, f₁ i ≤ f₂ i) : pi f₁ ≤ pi f₂ :=\n  infᵢ_mono fun i => comap_mono <| h i\n#align pi_mono pi_mono\n\n",
 "pi_mem_pi_iff":
 "@[simp]\ntheorem pi_mem_pi_iff [∀ i, NeBot (f i)] {I : Set ι} (hI : I.finite) : I.pi s ∈ pi f ↔ ∀ i ∈ I, s i ∈ f i :=\n  ⟨fun h i hi => mem_of_pi_mem_pi h hi, pi_mem_pi hI⟩\n#align pi_mem_pi_iff pi_mem_pi_iff\n\n",
 "pi_mem_pi":
 "theorem pi_mem_pi {I : Set ι} (hI : I.finite) (h : ∀ i ∈ I, s i ∈ f i) : I.pi s ∈ pi f :=\n  by\n  rw [pi_def, bInter_eq_Inter]\n  refine' mem_infi_of_Inter hI (fun i => _) subset.rfl\n  exact preimage_mem_comap (h i i.2)\n#align pi_mem_pi pi_mem_pi\n\n",
 "pi_map_Coprod":
 "theorem tendsto.pi_map_Coprod {g : ∀ i, Filter (β i)} (h : ∀ i, Tendsto (m i) (f i) (g i)) :\n    Tendsto (fun k : ∀ i, α i => fun i => m i (k i)) (Filter.coprodᵢ f) (Filter.coprodᵢ g) :=\n  map_pi_map_coprodᵢ_le.trans (coprodᵢ_mono h)\n#align tendsto.pi_map_Coprod tendsto.pi_map_Coprod\n\n",
 "pi_le_pi":
 "@[simp]\ntheorem pi_le_pi [∀ i, NeBot (f₁ i)] : pi f₁ ≤ pi f₂ ↔ ∀ i, f₁ i ≤ f₂ i :=\n  ⟨fun h i => map_eval_pi f₁ i ▸ (tendsto_eval_pi _ _).mono_left h, pi_mono⟩\n#align pi_le_pi pi_le_pi\n\n",
 "pi_inj":
 "@[simp]\ntheorem pi_inj [∀ i, NeBot (f₁ i)] : pi f₁ = pi f₂ ↔ f₁ = f₂ :=\n  by\n  refine' ⟨fun h => _, congr_arg pi⟩\n  have hle : f₁ ≤ f₂ := pi_le_pi.1 h.le\n  haveI : ∀ i, ne_bot (f₂ i) := fun i => ne_bot_of_le (hle i)\n  exact hle.antisymm (pi_le_pi.1 h.ge)\n#align pi_inj pi_inj\n\n",
 "pi_inf_principal_univ_pi_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem pi_inf_principal_univ_pi_ne_bot :\n    NeBot («expr ⊓ » (pi f) ((filter.principal) (Set.pi univ s))) ↔\n      ∀ i, NeBot («expr ⊓ » (f i) ((filter.principal) (s i))) :=\n  by simp [ne_bot_iff]\n#align pi_inf_principal_univ_pi_ne_bot pi_inf_principal_univ_pi_ne_bot\n\n",
 "pi_inf_principal_univ_pi_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem pi_inf_principal_univ_pi_eq_bot :\n    «expr ⊓ » (pi f) ((filter.principal) (Set.pi univ s)) = «expr⊥» ↔\n      ∃ i, «expr ⊓ » (f i) ((filter.principal) (s i)) = «expr⊥» :=\n  by\n  constructor\n  · simp only [inf_principal_eq_bot, mem_pi]\n    contrapose!\n    rintro\n      (hsf :\n          ∀ i,\n            «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n              (f i) (x ∈ s i))\n      I If t htf hts\n    have : ∀ i, (s i ∩ t i).nonempty := fun i => ((hsf i).and_eventually (htf i)).exists\n    choose x hxs hxt\n    exact hts (fun i hi => hxt i) (mem_univ_pi.2 hxs)\n  · simp only [inf_principal_eq_bot]\n    rintro ⟨i, hi⟩\n    filter_upwards [mem_pi_of_mem i hi]with x using mt fun h => h i trivial\n#align pi_inf_principal_univ_pi_eq_bot pi_inf_principal_univ_pi_eq_bot\n\n",
 "pi_inf_principal_pi_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n@[simp]\ntheorem pi_inf_principal_pi_ne_bot [∀ i, NeBot (f i)] {I : Set ι} :\n    NeBot («expr ⊓ » (pi f) ((filter.principal) (I.pi s))) ↔\n      ∀ i ∈ I, NeBot («expr ⊓ » (f i) ((filter.principal) (s i))) :=\n  by simp [ne_bot_iff]\n#align pi_inf_principal_pi_ne_bot pi_inf_principal_pi_ne_bot\n\n",
 "pi_inf_principal_pi_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem pi_inf_principal_pi_eq_bot [∀ i, NeBot (f i)] {I : Set ι} :\n    «expr ⊓ » (pi f) ((filter.principal) (Set.pi I s)) = «expr⊥» ↔\n      ∃ i ∈ I, «expr ⊓ » (f i) ((filter.principal) (s i)) = «expr⊥» :=\n  by\n  rw [← univ_pi_piecewise I, pi_inf_principal_univ_pi_eq_bot]\n  refine' exists_congr fun i => _\n  by_cases hi : i ∈ I <;> simp [hi, (‹∀ i, ne_bot (f i)› i).ne]\n#align pi_inf_principal_pi_eq_bot pi_inf_principal_pi_eq_bot\n\n",
 "pi_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem pi_eq_bot : pi f = «expr⊥» ↔ ∃ i, f i = «expr⊥» := by\n  simpa using @pi_inf_principal_univ_pi_eq_bot ι α f fun _ => univ\n#align pi_eq_bot pi_eq_bot\n\n",
 "mem_pi_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mem_pi_of_mem (i : ι) {s : Set (α i)} (hs : s ∈ f i) : «expr ⁻¹' » (eval i) s ∈ pi f :=\n  mem_infᵢ_of_mem i <| preimage_mem_comap hs\n#align mem_pi_of_mem mem_pi_of_mem\n\n",
 "mem_pi'":
 "theorem mem_pi' {s : Set (∀ i, α i)} :\n    s ∈ pi f ↔ ∃ I : Finset ι, ∃ t : ∀ i, Set (α i), (∀ i, t i ∈ f i) ∧ Set.pi (↑I) t ⊆ s :=\n  mem_pi.trans exists_finite_iff_finset\n#align mem_pi' mem_pi'\n\n",
 "mem_pi":
 "theorem mem_pi {s : Set (∀ i, α i)} :\n    s ∈ pi f ↔ ∃ I : Set ι, I.finite ∧ ∃ t : ∀ i, Set (α i), (∀ i, t i ∈ f i) ∧ I.pi t ⊆ s :=\n  by\n  constructor\n  · simp only [pi, mem_infi', mem_comap, pi_def]\n    rintro ⟨I, If, V, hVf, hVI, rfl, -⟩\n    choose t htf htV using hVf\n    exact ⟨I, If, t, htf, Inter₂_mono fun i _ => htV i⟩\n  · rintro ⟨I, If, t, htf, hts⟩\n    exact mem_of_superset (pi_mem_pi If fun i _ => htf i) hts\n#align mem_pi mem_pi\n\n",
 "mem_of_pi_mem_pi":
 "theorem mem_of_pi_mem_pi [∀ i, NeBot (f i)] {I : Set ι} (h : I.pi s ∈ pi f) {i : ι} (hi : i ∈ I) : s i ∈ f i :=\n  by\n  rcases mem_pi.1 h with ⟨I', I'f, t, htf, hts⟩\n  refine' mem_of_superset (htf i) fun x hx => _\n  have : ∀ i, (t i).nonempty := fun i => nonempty_of_mem (htf i)\n  choose g hg\n  have : update g i x ∈ I'.pi t := by\n    intro j hj\n    rcases eq_or_ne j i with (rfl | hne) <;> simp [*]\n  simpa using hts this i hi\n#align mem_of_pi_mem_pi mem_of_pi_mem_pi\n\n",
 "mem_Coprod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mem_Coprod_iff {s : Set (∀ i, α i)} : s ∈ Filter.coprodᵢ f ↔ ∀ i : ι, ∃ t₁ ∈ f i, «expr ⁻¹' » (eval i) t₁ ⊆ s :=\n  by simp [Filter.coprodᵢ]\n#align mem_Coprod_iff mem_Coprod_iff\n\n",
 "map_pi_map_Coprod_le":
 "theorem map_pi_map_Coprod_le :\n    map (fun k : ∀ i, α i => fun i => m i (k i)) (Filter.coprodᵢ f) ≤ Filter.coprodᵢ fun i => map (m i) (f i) :=\n  by\n  simp only [le_def, mem_map, mem_Coprod_iff]\n  intro s h i\n  obtain ⟨t, H, hH⟩ := h i\n  exact ⟨{ x : α i | m i x ∈ t }, H, fun x hx => hH hx⟩\n#align map_pi_map_Coprod_le map_pi_map_Coprod_le\n\n",
 "map_eval_pi":
 "@[simp]\ntheorem map_eval_pi (f : ∀ i, Filter (α i)) [∀ i, NeBot (f i)] (i : ι) : map (eval i) (pi f) = f i :=\n  by\n  refine' le_antisymm (tendsto_eval_pi f i) fun s hs => _\n  rcases mem_pi.1 (mem_map.1 hs) with ⟨I, hIf, t, htf, hI⟩\n  rw [← image_subset_iff] at hI\n  refine' mem_of_superset (htf i) ((subset_eval_image_pi _ _).trans hI)\n  exact nonempty_of_mem (pi_mem_pi hIf fun i hi => htf i)\n#align map_eval_pi map_eval_pi\n\n",
 "le_pi":
 "theorem le_pi {g : Filter (∀ i, α i)} : g ≤ pi f ↔ ∀ i, Tendsto (eval i) g (f i) :=\n  tendsto_pi\n#align le_pi le_pi\n\n",
 "has_basis_pi":
 "theorem has_basis_pi {ι' : ι → Type} {s : ∀ i, ι' i → Set (α i)} {p : ∀ i, ι' i → Prop}\n    (h : ∀ i, (f i).has_basis (p i) (s i)) :\n    (pi f).has_basis (fun If : Set ι × ∀ i, ι' i => If.1.finite ∧ ∀ i ∈ If.1, p i (If.2 i))\n      fun If : Set ι × ∀ i, ι' i => If.1.pi fun i => s i <| If.2 i :=\n  by\n  have : (pi f).has_basis _ _ := has_basis_infi' fun i => (h i).comap (eval i : (∀ j, α j) → α i)\n  convert this\n  ext\n  simp\n#align has_basis_pi has_basis_pi\n\n",
 "compl_mem_Coprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem compl_mem_Coprod {s : Set (∀ i, α i)} :\n    «expr ᶜ» s ∈ Filter.coprodᵢ f ↔ ∀ i, «expr ᶜ» («expr '' » (eval i) s) ∈ f i := by\n  simp only [Filter.coprodᵢ, mem_supr, compl_mem_comap]\n#align compl_mem_Coprod compl_mem_Coprod\n\n",
 "Coprod_ne_bot_iff'":
 "theorem Coprod_ne_bot_iff' : NeBot (Filter.coprodᵢ f) ↔ (∀ i, Nonempty (α i)) ∧ ∃ d, NeBot (f d) := by\n  simp only [Filter.coprodᵢ, supr_ne_bot, ← exists_and_left, ← comap_eval_ne_bot_iff']\n#align Coprod_ne_bot_iff' Coprod_ne_bot_iff'\n\n",
 "Coprod_ne_bot_iff":
 "@[simp]\ntheorem Coprod_ne_bot_iff [∀ i, Nonempty (α i)] : NeBot (Filter.coprodᵢ f) ↔ ∃ d, NeBot (f d) := by\n  simp [Coprod_ne_bot_iff', *]\n#align Coprod_ne_bot_iff Coprod_ne_bot_iff\n\n",
 "Coprod_ne_bot":
 "@[instance]\ntheorem Coprod_ne_bot [∀ i, Nonempty (α i)] [Nonempty ι] (f : ∀ i, Filter (α i)) [H : ∀ i, NeBot (f i)] :\n    NeBot (Filter.coprodᵢ f) :=\n  (H (Classical.arbitrary ι)).Coprod\n#align Coprod_ne_bot Coprod_ne_bot\n\n",
 "Coprod_mono":
 "@[mono]\ntheorem Coprod_mono (hf : ∀ i, f₁ i ≤ f₂ i) : Filter.coprodᵢ f₁ ≤ Filter.coprodᵢ f₂ :=\n  supᵢ_mono fun i => comap_mono (hf i)\n#align Coprod_mono Coprod_mono\n\n",
 "Coprod_eq_bot_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem Coprod_eq_bot_iff' : Filter.coprodᵢ f = «expr⊥» ↔ (∃ i, IsEmpty (α i)) ∨ f = «expr⊥» := by\n  simpa [not_and_or, funext_iff] using not_congr Coprod_ne_bot_iff'\n#align Coprod_eq_bot_iff' Coprod_eq_bot_iff'\n\n",
 "Coprod_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem Coprod_eq_bot_iff [∀ i, Nonempty (α i)] : Filter.coprodᵢ f = «expr⊥» ↔ f = «expr⊥» := by\n  simpa [funext_iff] using not_congr Coprod_ne_bot_iff\n#align Coprod_eq_bot_iff Coprod_eq_bot_iff\n\n",
 "Coprod_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem Coprod_bot' : Filter.coprodᵢ («expr⊥» : ∀ i, Filter (α i)) = «expr⊥» :=\n  coprodᵢ_eq_bot_iff'.2 (or.inr rfl)\n#align Coprod_bot' Coprod_bot'\n\n",
 "Coprod_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem Coprod_bot : Filter.coprodᵢ (fun _ => «expr⊥» : ∀ i, Filter (α i)) = «expr⊥» :=\n  coprodᵢ_bot'\n#align Coprod_bot Coprod_bot\n\n",
 "Coprod":
 "theorem ne_bot.Coprod [∀ i, Nonempty (α i)] {i : ι} (h : NeBot (f i)) : NeBot (Filter.coprodᵢ f) :=\n  coprodᵢ_neBot_iff.2 ⟨i, h⟩\n#align ne_bot.Coprod ne_bot.Coprod\n\n"}