{"zero_pow_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem zero_pow_eventually_eq [monoid_with_zero α] : «expr =ᶠ[ ] » (fun n : ℕ => (0 : α) ^ n) at_top fun n => 0 :=\n  eventually_at_top.2 ⟨1, fun n hn => zero_pow (zero_lt_one.trans_le hn)⟩\n#align zero_pow_eventually_eq zero_pow_eventually_eq\n\n",
 "unbounded_of_tendsto_at_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem unbounded_of_tendsto_at_top' [nonempty α] [SemilatticeInf α] [preorder β] [NoMaxOrder β] {f : α → β}\n    (h : tendsto f at_bot at_top) : ¬BddAbove (range f) :=\n  @unbounded_of_tendsto_at_top («expr ᵒᵈ» α) _ _ _ _ _ _ h\n#align unbounded_of_tendsto_at_top' unbounded_of_tendsto_at_top'\n\n",
 "unbounded_of_tendsto_at_top":
 "theorem unbounded_of_tendsto_at_top [nonempty α] [SemilatticeSup α] [preorder β] [NoMaxOrder β] {f : α → β}\n    (h : tendsto f at_top at_top) : ¬BddAbove (range f) :=\n  by\n  rintro ⟨M, hM⟩\n  cases' mem_at_top_sets.mp (h <| Ioi_mem_at_top M) with a ha\n  apply lt_irrefl M\n  calc\n    M < f a := ha a le_rfl\n    _ ≤ M := hM (Set.mem_range_self a)\n    \n#align unbounded_of_tendsto_at_top unbounded_of_tendsto_at_top\n\n",
 "unbounded_of_tendsto_at_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem unbounded_of_tendsto_at_bot' [nonempty α] [SemilatticeInf α] [preorder β] [NoMinOrder β] {f : α → β}\n    (h : tendsto f at_bot at_bot) : ¬BddBelow (range f) :=\n  @unbounded_of_tendsto_at_top («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ _ _ _ h\n#align unbounded_of_tendsto_at_bot' unbounded_of_tendsto_at_bot'\n\n",
 "unbounded_of_tendsto_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem unbounded_of_tendsto_at_bot [nonempty α] [SemilatticeSup α] [preorder β] [NoMinOrder β] {f : α → β}\n    (h : tendsto f at_top at_bot) : ¬BddBelow (range f) :=\n  @unbounded_of_tendsto_at_top _ («expr ᵒᵈ» β) _ _ _ _ _ h\n#align unbounded_of_tendsto_at_bot unbounded_of_tendsto_at_bot\n\n",
 "tendsto_sub_at_top_nat":
 "theorem tendsto_sub_at_top_nat (k : ℕ) : tendsto (fun a => a - k) at_top at_top :=\n  le_of_eq (map_sub_at_top_eq_nat k)\n#align tendsto_sub_at_top_nat tendsto_sub_at_top_nat\n\n",
 "tendsto_pow_at_top_iff":
 "@[simp]\ntheorem tendsto_pow_at_top_iff {n : ℕ} : tendsto (fun x : α => x ^ n) at_top at_top ↔ n ≠ 0 :=\n  ⟨fun h hn => by simpa only [hn, pow_zero, not_tendsto_const_at_top] using h, tendsto_pow_at_top⟩\n#align tendsto_pow_at_top_iff tendsto_pow_at_top_iff\n\n",
 "tendsto_pow_at_top":
 "/-- The monomial function `x^n` tends to `+∞` at `+∞` for any positive natural `n`.\nA version for positive real powers exists as `tendsto_rpow_at_top`. -/\ntheorem tendsto_pow_at_top {n : ℕ} (hn : n ≠ 0) : tendsto (fun x : α => x ^ n) at_top at_top :=\n  tendsto_at_top_mono' _ ((eventually_ge_at_top 1).mono fun x hx => le_self_pow hx hn) tendsto_id\n#align tendsto_pow_at_top tendsto_pow_at_top\n\n",
 "tendsto_of_subseq_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- A sequence converges if every subsequence has a convergent subsequence. -/\ntheorem tendsto_of_subseq_tendsto {α ι : Type _} {x : ι → α} {f : filter α} {l : filter ι} [l.is_countably_generated]\n    (hxy : ∀ ns : ℕ → ι, tendsto ns at_top l → ∃ ms : ℕ → ℕ, tendsto (fun n => x (ns <| ms n)) at_top f) :\n    tendsto x l f := by\n  by_contra h\n  obtain ⟨s, hs, hfreq⟩ :\n    ∃ s ∈ f,\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l\n        (x n ∉ s) :=\n    by rwa [not_tendsto_iff_exists_frequently_nmem] at h\n  obtain ⟨y, hy_tendsto, hy_freq⟩ := exists_seq_forall_of_frequently hfreq\n  specialize hxy y hy_tendsto\n  obtain ⟨ms, hms_tendsto⟩ := hxy\n  specialize hms_tendsto hs\n  rw [mem_map] at hms_tendsto\n  have hms_freq : ∀ n : ℕ, x (y (ms n)) ∉ s := fun n => hy_freq (ms n)\n  have h_empty : «expr ⁻¹' » (fun n : ℕ => x (y (ms n))) s = ∅ :=\n    by\n    ext1 n\n    simp only [Set.mem_preimage, Set.mem_empty_iff_false, iff_false_iff]\n    exact hms_freq n\n  rw [h_empty] at hms_tendsto\n  exact empty_not_mem at_top hms_tendsto\n#align tendsto_of_subseq_tendsto tendsto_of_subseq_tendsto\n\n",
 "tendsto_of_seq_tendsto":
 "theorem tendsto_of_seq_tendsto {f : α → β} {k : filter α} {l : filter β} [k.is_countably_generated] :\n    (∀ x : ℕ → α, tendsto x at_top k → tendsto (f ∘ x) at_top l) → tendsto f k l :=\n  tendsto_iff_seq_tendsto.2\n#align tendsto_of_seq_tendsto tendsto_of_seq_tendsto\n\n",
 "tendsto_neg_const_mul_pow_at_top":
 "theorem tendsto_neg_const_mul_pow_at_top {c : α} {n : ℕ} (hn : n ≠ 0) (hc : c < 0) :\n    tendsto (fun x => c * x ^ n) at_top at_bot :=\n  tendsto.neg_const_mul_at_top hc (tendsto_pow_at_top hn)\n#align tendsto_neg_const_mul_pow_at_top tendsto_neg_const_mul_pow_at_top\n\n",
 "tendsto_neg_at_top_iff":
 "@[simp]\ntheorem tendsto_neg_at_top_iff : tendsto (fun x => -f x) l at_top ↔ tendsto f l at_bot :=\n  (OrderIso.neg β).tendsto_at_bot_iff\n#align tendsto_neg_at_top_iff tendsto_neg_at_top_iff\n\n",
 "tendsto_neg_at_top_at_bot":
 "theorem tendsto_neg_at_top_at_bot : tendsto (has_neg.neg : β → β) at_top at_bot :=\n  (OrderIso.neg β).tendsto_at_top\n#align tendsto_neg_at_top_at_bot tendsto_neg_at_top_at_bot\n\n",
 "tendsto_neg_at_bot_iff":
 "@[simp]\ntheorem tendsto_neg_at_bot_iff : tendsto (fun x => -f x) l at_bot ↔ tendsto f l at_top :=\n  (OrderIso.neg β).tendsto_at_top_iff\n#align tendsto_neg_at_bot_iff tendsto_neg_at_bot_iff\n\n",
 "tendsto_neg_at_bot_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_neg_at_bot_at_top : tendsto (has_neg.neg : β → β) at_bot at_top :=\n  @tendsto_neg_at_top_at_bot («expr ᵒᵈ» β) _\n#align tendsto_neg_at_bot_at_top tendsto_neg_at_bot_at_top\n\n",
 "tendsto_mul_self_at_top":
 "theorem tendsto_mul_self_at_top : tendsto (fun x : α => x * x) at_top at_top :=\n  tendsto_id.at_top_mul_at_top tendsto_id\n#align tendsto_mul_self_at_top tendsto_mul_self_at_top\n\n",
 "tendsto_mul_const_at_top_of_pos":
 "/-- If `r` is a positive constant, then `λ x, f x * r` tends to infinity along a filter if and only\nif `f` tends to infinity along the same filter. -/\ntheorem tendsto_mul_const_at_top_of_pos (hr : 0 < r) : tendsto (fun x => f x * r) l at_top ↔ tendsto f l at_top := by\n  simpa only [mul_comm] using tendsto_const_mul_at_top_of_pos hr\n#align tendsto_mul_const_at_top_of_pos tendsto_mul_const_at_top_of_pos\n\n",
 "tendsto_mul_const_at_top_of_neg":
 "/-- If `r` is a negative constant, then `λ x, f x * r` tends to infinity along a filter if and only\nif `f` tends to negative infinity along the same filter. -/\ntheorem tendsto_mul_const_at_top_of_neg (hr : r < 0) : tendsto (fun x => f x * r) l at_top ↔ tendsto f l at_bot := by\n  simpa only [mul_comm] using tendsto_const_mul_at_top_of_neg hr\n#align tendsto_mul_const_at_top_of_neg tendsto_mul_const_at_top_of_neg\n\n",
 "tendsto_mul_const_at_top_iff_pos":
 "/-- If `f` tends to infinity along a nontrivial filter `l`, then `λ x, f x * r` tends to infinity\nif and only if `0 < r. `-/\ntheorem tendsto_mul_const_at_top_iff_pos [ne_bot l] (h : tendsto f l at_top) :\n    tendsto (fun x => f x * r) l at_top ↔ 0 < r := by simp only [mul_comm _ r, tendsto_const_mul_at_top_iff_pos h]\n#align tendsto_mul_const_at_top_iff_pos tendsto_mul_const_at_top_iff_pos\n\n",
 "tendsto_mul_const_at_top_iff_neg":
 "/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `λ x, f x * r` tends to\ninfinity if and only if `r < 0. `-/\ntheorem tendsto_mul_const_at_top_iff_neg [ne_bot l] (h : tendsto f l at_bot) :\n    tendsto (fun x => f x * r) l at_top ↔ r < 0 := by simp only [mul_comm _ r, tendsto_const_mul_at_top_iff_neg h]\n#align tendsto_mul_const_at_top_iff_neg tendsto_mul_const_at_top_iff_neg\n\n",
 "tendsto_mul_const_at_top_iff":
 "/-- The function `λ x, f x * r` tends to infinity along a nontrivial filter if and only if `r > 0`\nand `f` tends to infinity or `r < 0` and `f` tends to negative infinity. -/\ntheorem tendsto_mul_const_at_top_iff [ne_bot l] :\n    tendsto (fun x => f x * r) l at_top ↔ 0 < r ∧ tendsto f l at_top ∨ r < 0 ∧ tendsto f l at_bot := by\n  simp only [mul_comm _ r, tendsto_const_mul_at_top_iff]\n#align tendsto_mul_const_at_top_iff tendsto_mul_const_at_top_iff\n\n",
 "tendsto_mul_const_at_bot_of_pos":
 "/-- If `r` is a positive constant, then `λ x, f x * r` tends to negative infinity along a filter if\nand only if `f` tends to negative infinity along the same filter. -/\ntheorem tendsto_mul_const_at_bot_of_pos (hr : 0 < r) : tendsto (fun x => f x * r) l at_bot ↔ tendsto f l at_bot := by\n  simpa only [mul_comm] using tendsto_const_mul_at_bot_of_pos hr\n#align tendsto_mul_const_at_bot_of_pos tendsto_mul_const_at_bot_of_pos\n\n",
 "tendsto_mul_const_at_bot_of_neg":
 "/-- If `r` is a negative constant, then `λ x, f x * r` tends to negative infinity along a filter if\nand only if `f` tends to infinity along the same filter. -/\ntheorem tendsto_mul_const_at_bot_of_neg (hr : r < 0) : tendsto (fun x => f x * r) l at_bot ↔ tendsto f l at_top := by\n  simpa only [mul_comm] using tendsto_const_mul_at_bot_of_neg hr\n#align tendsto_mul_const_at_bot_of_neg tendsto_mul_const_at_bot_of_neg\n\n",
 "tendsto_mul_const_at_bot_iff_pos":
 "/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `λ x, f x * r` tends to\nnegative infinity if and only if `0 < r. `-/\ntheorem tendsto_mul_const_at_bot_iff_pos [ne_bot l] (h : tendsto f l at_bot) :\n    tendsto (fun x => f x * r) l at_bot ↔ 0 < r := by simp only [mul_comm _ r, tendsto_const_mul_at_bot_iff_pos h]\n#align tendsto_mul_const_at_bot_iff_pos tendsto_mul_const_at_bot_iff_pos\n\n",
 "tendsto_mul_const_at_bot_iff_neg":
 "/-- If `f` tends to infinity along a nontrivial filter `l`, then `λ x, f x * r` tends to negative\ninfinity if and only if `r < 0. `-/\ntheorem tendsto_mul_const_at_bot_iff_neg [ne_bot l] (h : tendsto f l at_top) :\n    tendsto (fun x => f x * r) l at_bot ↔ r < 0 := by simp only [mul_comm _ r, tendsto_const_mul_at_bot_iff_neg h]\n#align tendsto_mul_const_at_bot_iff_neg tendsto_mul_const_at_bot_iff_neg\n\n",
 "tendsto_mul_const_at_bot_iff":
 "/-- The function `λ x, f x * r` tends to negative infinity along a nontrivial filter if and only if\n`r > 0` and `f` tends to negative infinity or `r < 0` and `f` tends to infinity. -/\ntheorem tendsto_mul_const_at_bot_iff [ne_bot l] :\n    tendsto (fun x => f x * r) l at_bot ↔ 0 < r ∧ tendsto f l at_bot ∨ r < 0 ∧ tendsto f l at_top := by\n  simp only [mul_comm _ r, tendsto_const_mul_at_bot_iff]\n#align tendsto_mul_const_at_bot_iff tendsto_mul_const_at_bot_iff\n\n",
 "tendsto_iff_seq_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- An abstract version of continuity of sequentially continuous functions on metric spaces:\nif a filter `k` is countably generated then `tendsto f k l` iff for every sequence `u`\nconverging to `k`, `f ∘ u` tends to `l`. -/\ntheorem tendsto_iff_seq_tendsto {f : α → β} {k : filter α} {l : filter β} [k.is_countably_generated] :\n    tendsto f k l ↔ ∀ x : ℕ → α, tendsto x at_top k → tendsto (f ∘ x) at_top l :=\n  by\n  refine' ⟨fun h x hx => h.comp hx, fun H s hs => _⟩\n  contrapose! H\n  have : ne_bot («expr ⊓ » k ((filter.principal) («expr ⁻¹' » f («expr ᶜ» s)))) := by\n    simpa [ne_bot_iff, inf_principal_eq_bot]\n  rcases(«expr ⊓ » k ((filter.principal) («expr ⁻¹' » f («expr ᶜ» s)))).exists_seq_tendsto with ⟨x, hx⟩\n  rw [tendsto_inf, tendsto_principal] at hx\n  refine' ⟨x, hx.1, fun h => _⟩\n  rcases(hx.2.and (h hs)).exists with ⟨N, hnmem, hmem⟩\n  exact hnmem hmem\n#align tendsto_iff_seq_tendsto tendsto_iff_seq_tendsto\n\n",
 "tendsto_iff_forall_eventually_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_iff_forall_eventually_mem {α ι : Type _} {x : ι → α} {f : filter α} {l : filter ι} :\n    tendsto x l f ↔\n      ∀ s ∈ f,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n          (x n ∈ s) :=\n  by\n  rw [tendsto_def]\n  refine' forall_congr' fun s => imp_congr_right fun hsf => _\n  rfl\n#align tendsto_iff_forall_eventually_mem tendsto_iff_forall_eventually_mem\n\n",
 "tendsto_finset_range":
 "theorem tendsto_finset_range : tendsto Finset.range at_top at_top :=\n  Finset.range_mono.tendsto_at_top_at_top finset.exists_nat_subset_range\n#align tendsto_finset_range tendsto_finset_range\n\n",
 "tendsto_finset_preimage_at_top_at_top":
 "theorem tendsto_finset_preimage_at_top_at_top {f : α → β} (hf : function.injective f) :\n    tendsto (fun s : Finset β => s.preimage f (hf.inj_on _)) at_top at_top :=\n  (finset.monotone_preimage hf).tendsto_at_top_finset fun x =>\n    ⟨{f x}, finset.mem_preimage.2 <| Finset.mem_singleton_self _⟩\n#align tendsto_finset_preimage_at_top_at_top tendsto_finset_preimage_at_top_at_top\n\n",
 "tendsto_finset_image_at_top_at_top":
 "theorem tendsto_finset_image_at_top_at_top {i : β → γ} {j : γ → β} (h : function.left_inverse j i) :\n    tendsto (Finset.image j) at_top at_top :=\n  (Finset.image_mono j).tendsto_at_top_finset fun a =>\n    ⟨{i a}, by simp only [Finset.image_singleton, h a, Finset.mem_singleton]⟩\n#align tendsto_finset_image_at_top_at_top tendsto_finset_image_at_top_at_top\n\n",
 "tendsto_const_mul_pow_at_top_iff":
 "theorem tendsto_const_mul_pow_at_top_iff : tendsto (fun x => c * x ^ n) at_top at_top ↔ n ≠ 0 ∧ 0 < c :=\n  by\n  refine' ⟨fun h => ⟨_, _⟩, fun h => tendsto_const_mul_pow_at_top h.1 h.2⟩\n  · rintro rfl\n    simpa only [pow_zero, not_tendsto_const_at_top] using h\n  · rcases((h.eventually_gt_at_top 0).and (eventually_ge_at_top 0)).exists with ⟨k, hck, hk⟩\n    exact pos_of_mul_pos_left hck (pow_nonneg hk _)\n#align tendsto_const_mul_pow_at_top_iff tendsto_const_mul_pow_at_top_iff\n\n",
 "tendsto_const_mul_pow_at_top":
 "theorem tendsto_const_mul_pow_at_top (hn : n ≠ 0) (hc : 0 < c) : tendsto (fun x => c * x ^ n) at_top at_top :=\n  tendsto.const_mul_at_top hc (tendsto_pow_at_top hn)\n#align tendsto_const_mul_pow_at_top tendsto_const_mul_pow_at_top\n\n",
 "tendsto_const_mul_pow_at_bot_iff":
 "theorem tendsto_const_mul_pow_at_bot_iff {c : α} {n : ℕ} : tendsto (fun x => c * x ^ n) at_top at_bot ↔ n ≠ 0 ∧ c < 0 :=\n  by simp only [← tendsto_neg_at_top_iff, ← neg_mul, tendsto_const_mul_pow_at_top_iff, neg_pos]\n#align tendsto_const_mul_pow_at_bot_iff tendsto_const_mul_pow_at_bot_iff\n\n",
 "tendsto_const_mul_at_top_of_pos":
 "/-- If `r` is a positive constant, then `λ x, r * f x` tends to infinity along a filter if and only\nif `f` tends to infinity along the same filter. -/\ntheorem tendsto_const_mul_at_top_of_pos (hr : 0 < r) : tendsto (fun x => r * f x) l at_top ↔ tendsto f l at_top :=\n  ⟨fun h => h.at_top_of_const_mul hr, fun h =>\n    tendsto.at_top_of_const_mul (inv_pos.2 hr) <| by simpa only [inv_mul_cancel_left₀ hr.ne'] ⟩\n#align tendsto_const_mul_at_top_of_pos tendsto_const_mul_at_top_of_pos\n\n",
 "tendsto_const_mul_at_top_of_neg":
 "/-- If `r` is a negative constant, then `λ x, r * f x` tends to infinity along a filter if and only\nif `f` tends to negative infinity along the same filter. -/\ntheorem tendsto_const_mul_at_top_of_neg (hr : r < 0) : tendsto (fun x => r * f x) l at_top ↔ tendsto f l at_bot := by\n  simpa only [neg_mul, tendsto_neg_at_bot_iff] using tendsto_const_mul_at_bot_of_pos (neg_pos.2 hr)\n#align tendsto_const_mul_at_top_of_neg tendsto_const_mul_at_top_of_neg\n\n",
 "tendsto_const_mul_at_top_iff_pos":
 "/-- If `f` tends to infinity along a nontrivial filter `l`, then `λ x, r * f x` tends to infinity\nif and only if `0 < r. `-/\ntheorem tendsto_const_mul_at_top_iff_pos [ne_bot l] (h : tendsto f l at_top) :\n    tendsto (fun x => r * f x) l at_top ↔ 0 < r :=\n  by\n  refine' ⟨fun hrf => not_le.mp fun hr => _, fun hr => (tendsto_const_mul_at_top_of_pos hr).mpr h⟩\n  rcases((h.eventually_ge_at_top 0).and (hrf.eventually_gt_at_top 0)).exists with ⟨x, hx, hrx⟩\n  exact (mul_nonpos_of_nonpos_of_nonneg hr hx).not_lt hrx\n#align tendsto_const_mul_at_top_iff_pos tendsto_const_mul_at_top_iff_pos\n\n",
 "tendsto_const_mul_at_top_iff_neg":
 "/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `λ x, r * f x` tends to\ninfinity if and only if `r < 0. `-/\ntheorem tendsto_const_mul_at_top_iff_neg [ne_bot l] (h : tendsto f l at_bot) :\n    tendsto (fun x => r * f x) l at_top ↔ r < 0 := by\n  simp [tendsto_const_mul_at_top_iff, h, h.not_tendsto disjoint_at_bot_at_top]\n#align tendsto_const_mul_at_top_iff_neg tendsto_const_mul_at_top_iff_neg\n\n",
 "tendsto_const_mul_at_top_iff":
 "/-- The function `λ x, r * f x` tends to infinity along a nontrivial filter if and only if `r > 0`\nand `f` tends to infinity or `r < 0` and `f` tends to negative infinity. -/\ntheorem tendsto_const_mul_at_top_iff [ne_bot l] :\n    tendsto (fun x => r * f x) l at_top ↔ 0 < r ∧ tendsto f l at_top ∨ r < 0 ∧ tendsto f l at_bot :=\n  by\n  rcases lt_trichotomy r 0 with (hr | rfl | hr)\n  · simp [hr, hr.not_lt, tendsto_const_mul_at_top_of_neg]\n  · simp [not_tendsto_const_at_top]\n  · simp [hr, hr.not_lt, tendsto_const_mul_at_top_of_pos]\n#align tendsto_const_mul_at_top_iff tendsto_const_mul_at_top_iff\n\n",
 "tendsto_const_mul_at_bot_of_pos":
 "/-- If `r` is a positive constant, then `λ x, r * f x` tends to negative infinity along a filter if\nand only if `f` tends to negative infinity along the same filter. -/\ntheorem tendsto_const_mul_at_bot_of_pos (hr : 0 < r) : tendsto (fun x => r * f x) l at_bot ↔ tendsto f l at_bot := by\n  simpa only [← mul_neg, ← tendsto_neg_at_top_iff] using tendsto_const_mul_at_top_of_pos hr\n#align tendsto_const_mul_at_bot_of_pos tendsto_const_mul_at_bot_of_pos\n\n",
 "tendsto_const_mul_at_bot_of_neg":
 "/-- If `r` is a negative constant, then `λ x, r * f x` tends to negative infinity along a filter if\nand only if `f` tends to infinity along the same filter. -/\ntheorem tendsto_const_mul_at_bot_of_neg (hr : r < 0) : tendsto (fun x => r * f x) l at_bot ↔ tendsto f l at_top := by\n  simpa only [neg_mul, tendsto_neg_at_top_iff] using tendsto_const_mul_at_top_of_pos (neg_pos.2 hr)\n#align tendsto_const_mul_at_bot_of_neg tendsto_const_mul_at_bot_of_neg\n\n",
 "tendsto_const_mul_at_bot_iff_pos":
 "/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `λ x, r * f x` tends to\nnegative infinity if and only if `0 < r. `-/\ntheorem tendsto_const_mul_at_bot_iff_pos [ne_bot l] (h : tendsto f l at_bot) :\n    tendsto (fun x => r * f x) l at_bot ↔ 0 < r := by\n  simp [tendsto_const_mul_at_bot_iff, h, h.not_tendsto disjoint_at_bot_at_top]\n#align tendsto_const_mul_at_bot_iff_pos tendsto_const_mul_at_bot_iff_pos\n\n",
 "tendsto_const_mul_at_bot_iff_neg":
 "/-- If `f` tends to infinity along a nontrivial filter `l`, then `λ x, r * f x` tends to negative\ninfinity if and only if `r < 0. `-/\ntheorem tendsto_const_mul_at_bot_iff_neg [ne_bot l] (h : tendsto f l at_top) :\n    tendsto (fun x => r * f x) l at_bot ↔ r < 0 := by\n  simp [tendsto_const_mul_at_bot_iff, h, h.not_tendsto disjoint_at_top_at_bot]\n#align tendsto_const_mul_at_bot_iff_neg tendsto_const_mul_at_bot_iff_neg\n\n",
 "tendsto_const_mul_at_bot_iff":
 "/-- The function `λ x, r * f x` tends to negative infinity along a nontrivial filter if and only if\n`r > 0` and `f` tends to negative infinity or `r < 0` and `f` tends to infinity. -/\ntheorem tendsto_const_mul_at_bot_iff [ne_bot l] :\n    tendsto (fun x => r * f x) l at_bot ↔ 0 < r ∧ tendsto f l at_bot ∨ r < 0 ∧ tendsto f l at_top := by\n  simp only [← tendsto_neg_at_top_iff, ← mul_neg, tendsto_const_mul_at_top_iff, neg_neg]\n#align tendsto_const_mul_at_bot_iff tendsto_const_mul_at_bot_iff\n\n",
 "tendsto_comp_coe_Ioi_at_top":
 "@[simp]\ntheorem tendsto_comp_coe_Ioi_at_top [SemilatticeSup α] [NoMaxOrder α] {a : α} {f : α → β} {l : filter β} :\n    tendsto (fun x : Ioi a => f x) at_top l ↔ tendsto f at_top l := by rw [← map_coe_Ioi_at_top a, tendsto_map'_iff]\n#align tendsto_comp_coe_Ioi_at_top tendsto_comp_coe_Ioi_at_top\n\n",
 "tendsto_comp_coe_Iio_at_bot":
 "@[simp]\ntheorem tendsto_comp_coe_Iio_at_bot [SemilatticeInf α] [NoMinOrder α] {a : α} {f : α → β} {l : filter β} :\n    tendsto (fun x : Iio a => f x) at_bot l ↔ tendsto f at_bot l := by rw [← map_coe_Iio_at_bot a, tendsto_map'_iff]\n#align tendsto_comp_coe_Iio_at_bot tendsto_comp_coe_Iio_at_bot\n\n",
 "tendsto_comp_coe_Iic_at_bot":
 "@[simp]\ntheorem tendsto_comp_coe_Iic_at_bot [SemilatticeInf α] {a : α} {f : α → β} {l : filter β} :\n    tendsto (fun x : Iic a => f x) at_bot l ↔ tendsto f at_bot l := by rw [← map_coe_Iic_at_bot a, tendsto_map'_iff]\n#align tendsto_comp_coe_Iic_at_bot tendsto_comp_coe_Iic_at_bot\n\n",
 "tendsto_comp_coe_Ici_at_top":
 "@[simp]\ntheorem tendsto_comp_coe_Ici_at_top [SemilatticeSup α] {a : α} {f : α → β} {l : filter β} :\n    tendsto (fun x : Ici a => f x) at_top l ↔ tendsto f at_top l := by rw [← map_coe_Ici_at_top a, tendsto_map'_iff]\n#align tendsto_comp_coe_Ici_at_top tendsto_comp_coe_Ici_at_top\n\n",
 "tendsto_bit1_at_top":
 "theorem tendsto_bit1_at_top : tendsto bit1 (at_top : filter α) at_top :=\n  tendsto_at_top_add_nonneg_right tendsto_bit0_at_top fun _ => zero_le_one\n#align tendsto_bit1_at_top tendsto_bit1_at_top\n\n",
 "tendsto_bit0_at_top":
 "theorem tendsto_bit0_at_top : tendsto bit0 (at_top : filter β) at_top :=\n  tendsto_at_top_add tendsto_id tendsto_id\n#align tendsto_bit0_at_top tendsto_bit0_at_top\n\n",
 "tendsto_bit0_at_bot":
 "theorem tendsto_bit0_at_bot : tendsto bit0 (at_bot : filter β) at_bot :=\n  tendsto_at_bot_add tendsto_id tendsto_id\n#align tendsto_bit0_at_bot tendsto_bit0_at_bot\n\n",
 "tendsto_at_top_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem tendsto_at_top_pure [partial_order α] [OrderTop α] (f : α → β) : tendsto f at_top (pure <| f («expr⊤»)) :=\n  (order_top.at_top_eq α).symm ▸ tendsto_pure_pure _ _\n#align tendsto_at_top_pure tendsto_at_top_pure\n\n",
 "tendsto_at_top_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem tendsto_at_top_principal [nonempty β] [SemilatticeSup β] {f : β → α} {s : set α} :\n    tendsto f at_top ((filter.principal) s) ↔ ∃ N, ∀ n ≥ N, f n ∈ s := by\n  rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_at_top_sets] <;> rfl\n#align tendsto_at_top_principal tendsto_at_top_principal\n\n",
 "tendsto_at_top_of_monotone_of_subseq":
 "theorem tendsto_at_top_of_monotone_of_subseq [preorder ι] [preorder α] {u : ι → α} {φ : ι' → ι} (h : monotone u)\n    {l : filter ι'} [ne_bot l] (H : tendsto (u ∘ φ) l at_top) : tendsto u at_top at_top :=\n  tendsto_at_top_of_monotone_of_filter h (tendsto_map' H)\n#align tendsto_at_top_of_monotone_of_subseq tendsto_at_top_of_monotone_of_subseq\n\n",
 "tendsto_at_top_of_monotone_of_filter":
 "/-- If a monotone function `u : ι → α` tends to `at_top` along *some* non-trivial filter `l`, then\nit tends to `at_top` along `at_top`. -/\ntheorem tendsto_at_top_of_monotone_of_filter [preorder ι] [preorder α] {l : filter ι} {u : ι → α} (h : monotone u)\n    [ne_bot l] (hu : tendsto u l at_top) : tendsto u at_top at_top :=\n  h.tendsto_at_top_at_top fun b => (hu.eventually (mem_at_top b)).exists\n#align tendsto_at_top_of_monotone_of_filter tendsto_at_top_of_monotone_of_filter\n\n",
 "tendsto_at_top_of_add_const_right":
 "theorem tendsto_at_top_of_add_const_right (C : β) (hf : tendsto (fun x => f x + C) l at_top) : tendsto f l at_top :=\n  tendsto_at_top.2 fun b => (tendsto_at_top.1 hf (b + C)).mono fun x => le_of_add_le_add_right\n#align tendsto_at_top_of_add_const_right tendsto_at_top_of_add_const_right\n\n",
 "tendsto_at_top_of_add_const_left":
 "theorem tendsto_at_top_of_add_const_left (C : β) (hf : tendsto (fun x => C + f x) l at_top) : tendsto f l at_top :=\n  tendsto_at_top.2 fun b => (tendsto_at_top.1 hf (C + b)).mono fun x => le_of_add_le_add_left\n#align tendsto_at_top_of_add_const_left tendsto_at_top_of_add_const_left\n\n",
 "tendsto_at_top_of_add_bdd_above_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_top_of_add_bdd_above_right' (C)\n    (hC :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (g x ≤ C))\n    (h : tendsto (fun x => f x + g x) l at_top) : tendsto f l at_top :=\n  tendsto_at_top_of_add_const_right C (tendsto_at_top_mono' l (hC.mono fun x hx => add_le_add_left hx (f x)) h)\n#align tendsto_at_top_of_add_bdd_above_right' tendsto_at_top_of_add_bdd_above_right'\n\n",
 "tendsto_at_top_of_add_bdd_above_right":
 "theorem tendsto_at_top_of_add_bdd_above_right (C) (hC : ∀ x, g x ≤ C) :\n    tendsto (fun x => f x + g x) l at_top → tendsto f l at_top :=\n  tendsto_at_top_of_add_bdd_above_right' C (univ_mem' hC)\n#align tendsto_at_top_of_add_bdd_above_right tendsto_at_top_of_add_bdd_above_right\n\n",
 "tendsto_at_top_of_add_bdd_above_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_top_of_add_bdd_above_left' (C)\n    (hC :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (f x ≤ C))\n    (h : tendsto (fun x => f x + g x) l at_top) : tendsto g l at_top :=\n  tendsto_at_top_of_add_const_left C (tendsto_at_top_mono' l (hC.mono fun x hx => add_le_add_right hx (g x)) h)\n#align tendsto_at_top_of_add_bdd_above_left' tendsto_at_top_of_add_bdd_above_left'\n\n",
 "tendsto_at_top_of_add_bdd_above_left":
 "theorem tendsto_at_top_of_add_bdd_above_left (C) (hC : ∀ x, f x ≤ C) :\n    tendsto (fun x => f x + g x) l at_top → tendsto g l at_top :=\n  tendsto_at_top_of_add_bdd_above_left' C (univ_mem' hC)\n#align tendsto_at_top_of_add_bdd_above_left tendsto_at_top_of_add_bdd_above_left\n\n",
 "tendsto_at_top_mono'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem tendsto_at_top_mono' [preorder β] (l : filter α) ⦃f₁ f₂ : α → β⦄ (h : «expr ≤ᶠ[ ] » f₁ l f₂) :\n    tendsto f₁ l at_top → tendsto f₂ l at_top := fun h₁ =>\n  tendsto_at_top.2 fun b => mp_mem (tendsto_at_top.1 h₁ b) (monotone_mem (fun a ha ha₁ => le_trans ha₁ ha) h)\n#align tendsto_at_top_mono' tendsto_at_top_mono'\n\n",
 "tendsto_at_top_mono":
 "theorem tendsto_at_top_mono [preorder β] {l : filter α} {f g : α → β} (h : ∀ n, f n ≤ g n) :\n    tendsto f l at_top → tendsto g l at_top :=\n  tendsto_at_top_mono' l <| eventually_of_forall h\n#align tendsto_at_top_mono tendsto_at_top_mono\n\n",
 "tendsto_at_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n@[simp]\ntheorem tendsto_at_top_iff {l : filter γ} {f : γ → α} (e : «expr ≃o » α β) :\n    tendsto (fun x => e (f x)) l at_top ↔ tendsto f l at_top := by rw [← e.comap_at_top, tendsto_comap_iff]\n#align tendsto_at_top_iff tendsto_at_top_iff\n\n",
 "tendsto_at_top_finset_of_monotone":
 "/-- If `f` is a monotone sequence of `finset`s and each `x` belongs to one of `f n`, then\n`tendsto f at_top at_top`. -/\ntheorem tendsto_at_top_finset_of_monotone [preorder β] {f : β → Finset α} (h : monotone f)\n    (h' : ∀ x : α, ∃ n, x ∈ f n) : tendsto f at_top at_top :=\n  by\n  simp only [at_top_finset_eq_infi, tendsto_infi, tendsto_principal]\n  intro a\n  rcases h' a with ⟨b, hb⟩\n  exact eventually.mono (mem_at_top b) fun b' hb' => le_trans (Finset.singleton_subset_iff.2 hb) (h hb')\n#align tendsto_at_top_finset_of_monotone tendsto_at_top_finset_of_monotone\n\n",
 "tendsto_at_top_embedding":
 "theorem tendsto_at_top_embedding [preorder β] [preorder γ] {f : α → β} {e : β → γ} {l : filter α}\n    (hm : ∀ b₁ b₂, e b₁ ≤ e b₂ ↔ b₁ ≤ b₂) (hu : ∀ c, ∃ b, c ≤ e b) : tendsto (e ∘ f) l at_top ↔ tendsto f l at_top := by\n  rw [← comap_embedding_at_top hm hu, tendsto_comap_iff]\n#align tendsto_at_top_embedding tendsto_at_top_embedding\n\n",
 "tendsto_at_top_diagonal":
 "theorem tendsto_at_top_diagonal [SemilatticeSup α] : tendsto (fun a : α => (a, a)) at_top at_top :=\n  by\n  rw [← prod_at_top_at_top_eq]\n  exact tendsto_id.prod_mk tendsto_id\n#align tendsto_at_top_diagonal tendsto_at_top_diagonal\n\n",
 "tendsto_at_top_at_top_of_monotone'":
 "/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded\nabove, then `tendsto u at_top at_top`. -/\ntheorem tendsto_at_top_at_top_of_monotone' [preorder ι] [linear_order α] {u : ι → α} (h : monotone u)\n    (H : ¬BddAbove (range u)) : tendsto u at_top at_top :=\n  by\n  apply h.tendsto_at_top_at_top\n  intro b\n  rcases not_bddAbove_iff.1 H b with ⟨_, ⟨N, rfl⟩, hN⟩\n  exact ⟨N, le_of_lt hN⟩\n#align tendsto_at_top_at_top_of_monotone' tendsto_at_top_at_top_of_monotone'\n\n",
 "tendsto_at_top_at_top_of_monotone":
 "theorem tendsto_at_top_at_top_of_monotone [preorder α] [preorder β] {f : α → β} (hf : monotone f)\n    (h : ∀ b, ∃ a, b ≤ f a) : tendsto f at_top at_top :=\n  tendsto_infi.2 fun b =>\n    tendsto_principal.2 <|\n      let ⟨a, ha⟩ := h b\n      mem_of_superset (mem_at_top a) fun a' ha' => le_trans ha (hf ha')\n#align tendsto_at_top_at_top_of_monotone tendsto_at_top_at_top_of_monotone\n\n",
 "tendsto_at_top_at_top_iff_of_monotone":
 "theorem tendsto_at_top_at_top_iff_of_monotone [nonempty α] [SemilatticeSup α] [preorder β] {f : α → β}\n    (hf : monotone f) : tendsto f at_top at_top ↔ ∀ b : β, ∃ a : α, b ≤ f a :=\n  tendsto_at_top_at_top.trans <|\n    forall_congr' fun b => exists_congr fun a => ⟨fun h => h a (le_refl a), fun h a' ha' => le_trans h <| hf ha'⟩\n#align tendsto_at_top_at_top_iff_of_monotone tendsto_at_top_at_top_iff_of_monotone\n\n",
 "tendsto_at_top_at_top":
 "/-- A function `f` grows to `+∞` independent of an order-preserving embedding `e`. -/\ntheorem tendsto_at_top_at_top [nonempty α] [SemilatticeSup α] [preorder β] {f : α → β} :\n    tendsto f at_top at_top ↔ ∀ b : β, ∃ i : α, ∀ a : α, i ≤ a → b ≤ f a :=\n  iff.trans tendsto_infi <| forall_congr' fun b => tendsto_at_top_principal\n#align tendsto_at_top_at_top tendsto_at_top_at_top\n\n",
 "tendsto_at_top_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_top_at_bot [nonempty α] [SemilatticeSup α] [preorder β] {f : α → β} :\n    tendsto f at_top at_bot ↔ ∀ b : β, ∃ i : α, ∀ a : α, i ≤ a → f a ≤ b :=\n  @tendsto_at_top_at_top α («expr ᵒᵈ» β) _ _ _ f\n#align tendsto_at_top_at_bot tendsto_at_top_at_bot\n\n",
 "tendsto_at_top_add_right_of_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_top_add_right_of_le' (C : β) (hf : tendsto f l at_top)\n    (hg :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (C ≤ g x)) :\n    tendsto (fun x => f x + g x) l at_top :=\n  @tendsto_at_top_of_add_bdd_above_right' _ _ _ l (fun x => f x + g x) (fun x => -g x) (-C) (by simp [hg])\n    (by simp [hf])\n#align tendsto_at_top_add_right_of_le' tendsto_at_top_add_right_of_le'\n\n",
 "tendsto_at_top_add_right_of_le":
 "theorem tendsto_at_top_add_right_of_le (C : β) (hf : tendsto f l at_top) (hg : ∀ x, C ≤ g x) :\n    tendsto (fun x => f x + g x) l at_top :=\n  tendsto_at_top_add_right_of_le' l C hf (univ_mem' hg)\n#align tendsto_at_top_add_right_of_le tendsto_at_top_add_right_of_le\n\n",
 "tendsto_at_top_add_nonneg_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_top_add_nonneg_right' (hf : tendsto f l at_top)\n    (hg :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (0 ≤ g x)) :\n    tendsto (fun x => f x + g x) l at_top :=\n  tendsto_at_top_mono' l (monotone_mem (fun x => le_add_of_nonneg_right) hg) hf\n#align tendsto_at_top_add_nonneg_right' tendsto_at_top_add_nonneg_right'\n\n",
 "tendsto_at_top_add_nonneg_right":
 "theorem tendsto_at_top_add_nonneg_right (hf : tendsto f l at_top) (hg : ∀ x, 0 ≤ g x) :\n    tendsto (fun x => f x + g x) l at_top :=\n  tendsto_at_top_add_nonneg_right' hf (eventually_of_forall hg)\n#align tendsto_at_top_add_nonneg_right tendsto_at_top_add_nonneg_right\n\n",
 "tendsto_at_top_add_nonneg_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_top_add_nonneg_left'\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (0 ≤ f x))\n    (hg : tendsto g l at_top) : tendsto (fun x => f x + g x) l at_top :=\n  tendsto_at_top_mono' l (hf.mono fun x => le_add_of_nonneg_left) hg\n#align tendsto_at_top_add_nonneg_left' tendsto_at_top_add_nonneg_left'\n\n",
 "tendsto_at_top_add_nonneg_left":
 "theorem tendsto_at_top_add_nonneg_left (hf : ∀ x, 0 ≤ f x) (hg : tendsto g l at_top) :\n    tendsto (fun x => f x + g x) l at_top :=\n  tendsto_at_top_add_nonneg_left' (eventually_of_forall hf) hg\n#align tendsto_at_top_add_nonneg_left tendsto_at_top_add_nonneg_left\n\n",
 "tendsto_at_top_add_left_of_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_top_add_left_of_le' (C : β)\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (C ≤ f x))\n    (hg : tendsto g l at_top) : tendsto (fun x => f x + g x) l at_top :=\n  @tendsto_at_top_of_add_bdd_above_left' _ _ _ l (fun x => -f x) (fun x => f x + g x) (-C) (by simpa) (by simpa)\n#align tendsto_at_top_add_left_of_le' tendsto_at_top_add_left_of_le'\n\n",
 "tendsto_at_top_add_left_of_le":
 "theorem tendsto_at_top_add_left_of_le (C : β) (hf : ∀ x, C ≤ f x) (hg : tendsto g l at_top) :\n    tendsto (fun x => f x + g x) l at_top :=\n  tendsto_at_top_add_left_of_le' l C (univ_mem' hf) hg\n#align tendsto_at_top_add_left_of_le tendsto_at_top_add_left_of_le\n\n",
 "tendsto_at_top_add_const_right":
 "theorem tendsto_at_top_add_const_right (C : β) (hf : tendsto f l at_top) : tendsto (fun x => f x + C) l at_top :=\n  tendsto_at_top_add_right_of_le' l C hf (univ_mem' fun _ => le_refl C)\n#align tendsto_at_top_add_const_right tendsto_at_top_add_const_right\n\n",
 "tendsto_at_top_add_const_left":
 "theorem tendsto_at_top_add_const_left (C : β) (hf : tendsto f l at_top) : tendsto (fun x => C + f x) l at_top :=\n  tendsto_at_top_add_left_of_le' l C (univ_mem' fun _ => le_refl C) hf\n#align tendsto_at_top_add_const_left tendsto_at_top_add_const_left\n\n",
 "tendsto_at_top_add":
 "theorem tendsto_at_top_add (hf : tendsto f l at_top) (hg : tendsto g l at_top) :\n    tendsto (fun x => f x + g x) l at_top :=\n  tendsto_at_top_add_nonneg_left' (tendsto_at_top.mp hf 0) hg\n#align tendsto_at_top_add tendsto_at_top_add\n\n",
 "tendsto_at_top'":
 "theorem tendsto_at_top' [nonempty α] [SemilatticeSup α] {f : α → β} {l : filter β} :\n    tendsto f at_top l ↔ ∀ s ∈ l, ∃ a, ∀ b ≥ a, f b ∈ s := by simp only [tendsto_def, mem_at_top_sets] <;> rfl\n#align tendsto_at_top' tendsto_at_top'\n\n",
 "tendsto_at_top":
 "theorem _root_.strict_mono.tendsto_at_top {φ : ℕ → ℕ} (h : strict_mono φ) : tendsto φ at_top at_top :=\n  tendsto_at_top_mono h.id_le tendsto_id\n#align strict_mono.tendsto_at_top strict_mono.tendsto_at_top\n\n",
 "tendsto_at_bot_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem tendsto_at_bot_pure [partial_order α] [OrderBot α] (f : α → β) : tendsto f at_bot (pure <| f («expr⊥»)) :=\n  @tendsto_at_top_pure («expr ᵒᵈ» α) _ _ _ _\n#align tendsto_at_bot_pure tendsto_at_bot_pure\n\n",
 "tendsto_at_bot_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem tendsto_at_bot_principal [nonempty β] [SemilatticeInf β] {f : β → α} {s : set α} :\n    tendsto f at_bot ((filter.principal) s) ↔ ∃ N, ∀ n ≤ N, f n ∈ s :=\n  @tendsto_at_top_principal _ («expr ᵒᵈ» β) _ _ _ _\n#align tendsto_at_bot_principal tendsto_at_bot_principal\n\n",
 "tendsto_at_bot_of_monotone_of_subseq":
 "theorem tendsto_at_bot_of_monotone_of_subseq [preorder ι] [preorder α] {u : ι → α} {φ : ι' → ι} (h : monotone u)\n    {l : filter ι'} [ne_bot l] (H : tendsto (u ∘ φ) l at_bot) : tendsto u at_bot at_bot :=\n  tendsto_at_bot_of_monotone_of_filter h (tendsto_map' H)\n#align tendsto_at_bot_of_monotone_of_subseq tendsto_at_bot_of_monotone_of_subseq\n\n",
 "tendsto_at_bot_of_monotone_of_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- If a monotone function `u : ι → α` tends to `at_bot` along *some* non-trivial filter `l`, then\nit tends to `at_bot` along `at_bot`. -/\ntheorem tendsto_at_bot_of_monotone_of_filter [preorder ι] [preorder α] {l : filter ι} {u : ι → α} (h : monotone u)\n    [ne_bot l] (hu : tendsto u l at_bot) : tendsto u at_bot at_bot :=\n  @tendsto_at_top_of_monotone_of_filter («expr ᵒᵈ» ι) («expr ᵒᵈ» α) _ _ _ _ h.dual _ hu\n#align tendsto_at_bot_of_monotone_of_filter tendsto_at_bot_of_monotone_of_filter\n\n",
 "tendsto_at_bot_of_add_const_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_of_add_const_right (C : β) (hf : tendsto (fun x => f x + C) l at_bot) : tendsto f l at_bot :=\n  @tendsto_at_top_of_add_const_right _ («expr ᵒᵈ» β) _ _ _ C hf\n#align tendsto_at_bot_of_add_const_right tendsto_at_bot_of_add_const_right\n\n",
 "tendsto_at_bot_of_add_const_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_of_add_const_left (C : β) (hf : tendsto (fun x => C + f x) l at_bot) : tendsto f l at_bot :=\n  @tendsto_at_top_of_add_const_left _ («expr ᵒᵈ» β) _ _ _ C hf\n#align tendsto_at_bot_of_add_const_left tendsto_at_bot_of_add_const_left\n\n",
 "tendsto_at_bot_of_add_bdd_below_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_bot_of_add_bdd_below_right' (C)\n    (hC :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (C ≤ g x))\n    (h : tendsto (fun x => f x + g x) l at_bot) : tendsto f l at_bot :=\n  @tendsto_at_top_of_add_bdd_above_right' _ («expr ᵒᵈ» β) _ _ _ _ C hC h\n#align tendsto_at_bot_of_add_bdd_below_right' tendsto_at_bot_of_add_bdd_below_right'\n\n",
 "tendsto_at_bot_of_add_bdd_below_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_of_add_bdd_below_right (C) (hC : ∀ x, C ≤ g x) :\n    tendsto (fun x => f x + g x) l at_bot → tendsto f l at_bot :=\n  @tendsto_at_top_of_add_bdd_above_right _ («expr ᵒᵈ» β) _ _ _ _ C hC\n#align tendsto_at_bot_of_add_bdd_below_right tendsto_at_bot_of_add_bdd_below_right\n\n",
 "tendsto_at_bot_of_add_bdd_below_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_bot_of_add_bdd_below_left' (C)\n    (hC :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (C ≤ f x))\n    (h : tendsto (fun x => f x + g x) l at_bot) : tendsto g l at_bot :=\n  @tendsto_at_top_of_add_bdd_above_left' _ («expr ᵒᵈ» β) _ _ _ _ C hC h\n#align tendsto_at_bot_of_add_bdd_below_left' tendsto_at_bot_of_add_bdd_below_left'\n\n",
 "tendsto_at_bot_of_add_bdd_below_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_of_add_bdd_below_left (C) (hC : ∀ x, C ≤ f x) :\n    tendsto (fun x => f x + g x) l at_bot → tendsto g l at_bot :=\n  @tendsto_at_top_of_add_bdd_above_left _ («expr ᵒᵈ» β) _ _ _ _ C hC\n#align tendsto_at_bot_of_add_bdd_below_left tendsto_at_bot_of_add_bdd_below_left\n\n",
 "tendsto_at_bot_mono'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem tendsto_at_bot_mono' [preorder β] (l : filter α) ⦃f₁ f₂ : α → β⦄ (h : «expr ≤ᶠ[ ] » f₁ l f₂) :\n    tendsto f₂ l at_bot → tendsto f₁ l at_bot :=\n  @tendsto_at_top_mono' _ («expr ᵒᵈ» β) _ _ _ _ h\n#align tendsto_at_bot_mono' tendsto_at_bot_mono'\n\n",
 "tendsto_at_bot_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_mono [preorder β] {l : filter α} {f g : α → β} (h : ∀ n, f n ≤ g n) :\n    tendsto g l at_bot → tendsto f l at_bot :=\n  @tendsto_at_top_mono _ («expr ᵒᵈ» β) _ _ _ _ h\n#align tendsto_at_bot_mono tendsto_at_bot_mono\n\n",
 "tendsto_at_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n@[simp]\ntheorem tendsto_at_bot_iff {l : filter γ} {f : γ → α} (e : «expr ≃o » α β) :\n    tendsto (fun x => e (f x)) l at_bot ↔ tendsto f l at_bot :=\n  e.dual.tendsto_at_top_iff\n#align tendsto_at_bot_iff tendsto_at_bot_iff\n\n",
 "tendsto_at_bot_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- A function `f` goes to `-∞` independent of an order-preserving embedding `e`. -/\ntheorem tendsto_at_bot_embedding [preorder β] [preorder γ] {f : α → β} {e : β → γ} {l : filter α}\n    (hm : ∀ b₁ b₂, e b₁ ≤ e b₂ ↔ b₁ ≤ b₂) (hu : ∀ c, ∃ b, e b ≤ c) : tendsto (e ∘ f) l at_bot ↔ tendsto f l at_bot :=\n  @tendsto_at_top_embedding α («expr ᵒᵈ» β) («expr ᵒᵈ» γ) _ _ f e l (function.swap hm) hu\n#align tendsto_at_bot_embedding tendsto_at_bot_embedding\n\n",
 "tendsto_at_bot_diagonal":
 "theorem tendsto_at_bot_diagonal [SemilatticeInf α] : tendsto (fun a : α => (a, a)) at_bot at_bot :=\n  by\n  rw [← prod_at_bot_at_bot_eq]\n  exact tendsto_id.prod_mk tendsto_id\n#align tendsto_at_bot_diagonal tendsto_at_bot_diagonal\n\n",
 "tendsto_at_bot_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_at_top [nonempty α] [SemilatticeInf α] [preorder β] {f : α → β} :\n    tendsto f at_bot at_top ↔ ∀ b : β, ∃ i : α, ∀ a : α, a ≤ i → b ≤ f a :=\n  @tendsto_at_top_at_top («expr ᵒᵈ» α) β _ _ _ f\n#align tendsto_at_bot_at_top tendsto_at_bot_at_top\n\n",
 "tendsto_at_bot_at_bot_of_monotone'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded\nbelow, then `tendsto u at_bot at_bot`. -/\ntheorem tendsto_at_bot_at_bot_of_monotone' [preorder ι] [linear_order α] {u : ι → α} (h : monotone u)\n    (H : ¬BddBelow (range u)) : tendsto u at_bot at_bot :=\n  @tendsto_at_top_at_top_of_monotone' («expr ᵒᵈ» ι) («expr ᵒᵈ» α) _ _ _ h.dual H\n#align tendsto_at_bot_at_bot_of_monotone' tendsto_at_bot_at_bot_of_monotone'\n\n",
 "tendsto_at_bot_at_bot_of_monotone":
 "theorem tendsto_at_bot_at_bot_of_monotone [preorder α] [preorder β] {f : α → β} (hf : monotone f)\n    (h : ∀ b, ∃ a, f a ≤ b) : tendsto f at_bot at_bot :=\n  tendsto_infi.2 fun b =>\n    tendsto_principal.2 <|\n      let ⟨a, ha⟩ := h b\n      mem_of_superset (mem_at_bot a) fun a' ha' => le_trans (hf ha') ha\n#align tendsto_at_bot_at_bot_of_monotone tendsto_at_bot_at_bot_of_monotone\n\n",
 "tendsto_at_bot_at_bot_iff_of_monotone":
 "theorem tendsto_at_bot_at_bot_iff_of_monotone [nonempty α] [SemilatticeInf α] [preorder β] {f : α → β}\n    (hf : monotone f) : tendsto f at_bot at_bot ↔ ∀ b : β, ∃ a : α, f a ≤ b :=\n  tendsto_at_bot_at_bot.trans <|\n    forall_congr' fun b => exists_congr fun a => ⟨fun h => h a (le_refl a), fun h a' ha' => le_trans (hf ha') h⟩\n#align tendsto_at_bot_at_bot_iff_of_monotone tendsto_at_bot_at_bot_iff_of_monotone\n\n",
 "tendsto_at_bot_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_at_bot [nonempty α] [SemilatticeInf α] [preorder β] {f : α → β} :\n    tendsto f at_bot at_bot ↔ ∀ b : β, ∃ i : α, ∀ a : α, a ≤ i → f a ≤ b :=\n  @tendsto_at_top_at_top («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ _ f\n#align tendsto_at_bot_at_bot tendsto_at_bot_at_bot\n\n",
 "tendsto_at_bot_add_right_of_ge'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_bot_add_right_of_ge' (C : β) (hf : tendsto f l at_bot)\n    (hg :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (g x ≤ C)) :\n    tendsto (fun x => f x + g x) l at_bot :=\n  @tendsto_at_top_add_right_of_le' _ («expr ᵒᵈ» β) _ _ _ _ C hf hg\n#align tendsto_at_bot_add_right_of_ge' tendsto_at_bot_add_right_of_ge'\n\n",
 "tendsto_at_bot_add_right_of_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_add_right_of_ge (C : β) (hf : tendsto f l at_bot) (hg : ∀ x, g x ≤ C) :\n    tendsto (fun x => f x + g x) l at_bot :=\n  @tendsto_at_top_add_right_of_le _ («expr ᵒᵈ» β) _ _ _ _ C hf hg\n#align tendsto_at_bot_add_right_of_ge tendsto_at_bot_add_right_of_ge\n\n",
 "tendsto_at_bot_add_nonpos_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_bot_add_nonpos_right' (hf : tendsto f l at_bot)\n    (hg :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (g x ≤ 0)) :\n    tendsto (fun x => f x + g x) l at_bot :=\n  @tendsto_at_top_add_nonneg_right' _ («expr ᵒᵈ» β) _ _ _ _ hf hg\n#align tendsto_at_bot_add_nonpos_right' tendsto_at_bot_add_nonpos_right'\n\n",
 "tendsto_at_bot_add_nonpos_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_add_nonpos_right (hf : tendsto f l at_bot) (hg : ∀ x, g x ≤ 0) :\n    tendsto (fun x => f x + g x) l at_bot :=\n  @tendsto_at_top_add_nonneg_right _ («expr ᵒᵈ» β) _ _ _ _ hf hg\n#align tendsto_at_bot_add_nonpos_right tendsto_at_bot_add_nonpos_right\n\n",
 "tendsto_at_bot_add_nonpos_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_bot_add_nonpos_left'\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (f x ≤ 0))\n    (hg : tendsto g l at_bot) : tendsto (fun x => f x + g x) l at_bot :=\n  @tendsto_at_top_add_nonneg_left' _ («expr ᵒᵈ» β) _ _ _ _ hf hg\n#align tendsto_at_bot_add_nonpos_left' tendsto_at_bot_add_nonpos_left'\n\n",
 "tendsto_at_bot_add_nonpos_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_add_nonpos_left (hf : ∀ x, f x ≤ 0) (hg : tendsto g l at_bot) :\n    tendsto (fun x => f x + g x) l at_bot :=\n  @tendsto_at_top_add_nonneg_left _ («expr ᵒᵈ» β) _ _ _ _ hf hg\n#align tendsto_at_bot_add_nonpos_left tendsto_at_bot_add_nonpos_left\n\n",
 "tendsto_at_bot_add_left_of_ge'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_bot_add_left_of_ge' (C : β)\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (f x ≤ C))\n    (hg : tendsto g l at_bot) : tendsto (fun x => f x + g x) l at_bot :=\n  @tendsto_at_top_add_left_of_le' _ («expr ᵒᵈ» β) _ _ _ _ C hf hg\n#align tendsto_at_bot_add_left_of_ge' tendsto_at_bot_add_left_of_ge'\n\n",
 "tendsto_at_bot_add_left_of_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_add_left_of_ge (C : β) (hf : ∀ x, f x ≤ C) (hg : tendsto g l at_bot) :\n    tendsto (fun x => f x + g x) l at_bot :=\n  @tendsto_at_top_add_left_of_le _ («expr ᵒᵈ» β) _ _ _ _ C hf hg\n#align tendsto_at_bot_add_left_of_ge tendsto_at_bot_add_left_of_ge\n\n",
 "tendsto_at_bot_add_const_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_add_const_right (C : β) (hf : tendsto f l at_bot) : tendsto (fun x => f x + C) l at_bot :=\n  @tendsto_at_top_add_const_right _ («expr ᵒᵈ» β) _ _ _ C hf\n#align tendsto_at_bot_add_const_right tendsto_at_bot_add_const_right\n\n",
 "tendsto_at_bot_add_const_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_add_const_left (C : β) (hf : tendsto f l at_bot) : tendsto (fun x => C + f x) l at_bot :=\n  @tendsto_at_top_add_const_left _ («expr ᵒᵈ» β) _ _ _ C hf\n#align tendsto_at_bot_add_const_left tendsto_at_bot_add_const_left\n\n",
 "tendsto_at_bot_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_add (hf : tendsto f l at_bot) (hg : tendsto g l at_bot) :\n    tendsto (fun x => f x + g x) l at_bot :=\n  @tendsto_at_top_add _ («expr ᵒᵈ» β) _ _ _ _ hf hg\n#align tendsto_at_bot_add tendsto_at_bot_add\n\n",
 "tendsto_at_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot' [nonempty α] [SemilatticeInf α] {f : α → β} {l : filter β} :\n    tendsto f at_bot l ↔ ∀ s ∈ l, ∃ a, ∀ b ≤ a, f b ∈ s :=\n  @tendsto_at_top' («expr ᵒᵈ» α) _ _ _ _ _\n#align tendsto_at_bot' tendsto_at_bot'\n\n",
 "tendsto_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\ntheorem tendsto_at_bot (e : «expr ≃o » α β) : tendsto e at_bot at_bot :=\n  e.map_at_bot.le\n#align tendsto_at_bot tendsto_at_bot\n\n",
 "tendsto_add_at_top_nat":
 "theorem tendsto_add_at_top_nat (k : ℕ) : tendsto (fun a => a + k) at_top at_top :=\n  le_of_eq (map_add_at_top_eq_nat k)\n#align tendsto_add_at_top_nat tendsto_add_at_top_nat\n\n",
 "tendsto_add_at_top_iff_nat":
 "theorem tendsto_add_at_top_iff_nat {f : ℕ → α} {l : filter α} (k : ℕ) :\n    tendsto (fun n => f (n + k)) at_top l ↔ tendsto f at_top l :=\n  show tendsto (f ∘ fun n => n + k) at_top l ↔ tendsto f at_top l by rw [← tendsto_map'_iff, map_add_at_top_eq_nat]\n#align tendsto_add_at_top_iff_nat tendsto_add_at_top_iff_nat\n\n",
 "tendsto_abs_at_top_at_top":
 "/-- $\\lim_{x\\to+\\infty}|x|=+\\infty$ -/\ntheorem tendsto_abs_at_top_at_top : tendsto (abs : α → α) at_top at_top :=\n  tendsto_at_top_mono le_abs_self tendsto_id\n#align tendsto_abs_at_top_at_top tendsto_abs_at_top_at_top\n\n",
 "tendsto_abs_at_bot_at_top":
 "/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem tendsto_abs_at_bot_at_top : tendsto (abs : α → α) at_bot at_top :=\n  tendsto_at_top_mono neg_le_abs_self tendsto_neg_at_bot_at_top\n#align tendsto_abs_at_bot_at_top tendsto_abs_at_bot_at_top\n\n",
 "tendsto_Ioi_at_top":
 "theorem tendsto_Ioi_at_top [SemilatticeSup α] {a : α} {f : β → Ioi a} {l : filter β} :\n    tendsto f l at_top ↔ tendsto (fun x => (f x : α)) l at_top := by rw [at_top_Ioi_eq, tendsto_comap_iff]\n#align tendsto_Ioi_at_top tendsto_Ioi_at_top\n\n",
 "tendsto_Iio_at_bot":
 "theorem tendsto_Iio_at_bot [SemilatticeInf α] {a : α} {f : β → Iio a} {l : filter β} :\n    tendsto f l at_bot ↔ tendsto (fun x => (f x : α)) l at_bot := by rw [at_bot_Iio_eq, tendsto_comap_iff]\n#align tendsto_Iio_at_bot tendsto_Iio_at_bot\n\n",
 "tendsto_Iic_at_bot":
 "theorem tendsto_Iic_at_bot [SemilatticeInf α] {a : α} {f : β → Iic a} {l : filter β} :\n    tendsto f l at_bot ↔ tendsto (fun x => (f x : α)) l at_bot := by rw [at_bot_Iic_eq, tendsto_comap_iff]\n#align tendsto_Iic_at_bot tendsto_Iic_at_bot\n\n",
 "tendsto_Ici_at_top":
 "theorem tendsto_Ici_at_top [SemilatticeSup α] {a : α} {f : β → Ici a} {l : filter β} :\n    tendsto f l at_top ↔ tendsto (fun x => (f x : α)) l at_top := by rw [at_top_Ici_eq, tendsto_comap_iff]\n#align tendsto_Ici_at_top tendsto_Ici_at_top\n\n",
 "tendsto":
 "protected theorem has_antitone_basis.tendsto [preorder ι] {l : filter α} {s : ι → set α} (hl : l.has_antitone_basis s)\n    {φ : ι → α} (h : ∀ i : ι, φ i ∈ s i) : tendsto φ at_top l := fun t ht =>\n  mem_map.2 <| (hl.eventually_subset ht).mono fun i hi => hi (h i)\n#align has_antitone_basis.tendsto has_antitone_basis.tendsto\n\n",
 "subseq_tendsto_of_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem subseq_tendsto_of_ne_bot {f : filter α} [is_countably_generated f] {u : ℕ → α}\n    (hx : ne_bot («expr ⊓ » f (map u at_top))) : ∃ θ : ℕ → ℕ, strict_mono θ ∧ tendsto (u ∘ θ) at_top f :=\n  by\n  obtain ⟨B, h⟩ := f.exists_antitone_basis\n  have : ∀ N, ∃ n ≥ N, u n ∈ B N := fun N =>\n    filter.inf_map_at_top_ne_bot_iff.mp hx _ (h.to_has_basis.mem_of_mem trivial) N\n  choose φ hφ using this\n  cases' forall_and_distrib.mp hφ with φ_ge φ_in\n  have lim_uφ : tendsto (u ∘ φ) at_top f := h.tendsto φ_in\n  have lim_φ : tendsto φ at_top at_top := tendsto_at_top_mono φ_ge tendsto_id\n  obtain ⟨ψ, hψ, hψφ⟩ : ∃ ψ : ℕ → ℕ, strict_mono ψ ∧ strict_mono (φ ∘ ψ)\n  exact strict_mono_subseq_of_tendsto_at_top lim_φ\n  exact ⟨φ ∘ ψ, hψφ, lim_uφ.comp hψ.tendsto_at_top⟩\n#align subseq_tendsto_of_ne_bot subseq_tendsto_of_ne_bot\n\n",
 "subseq_mem":
 "theorem tendsto.subseq_mem {F : filter α} {V : ℕ → set α} (h : ∀ n, V n ∈ F) {u : ℕ → α} (hu : tendsto u at_top F) :\n    ∃ φ : ℕ → ℕ, strict_mono φ ∧ ∀ n, u (φ n) ∈ V n :=\n  extraction_forall_of_eventually' (fun n => tendsto_at_top'.mp hu _ (h n) : ∀ n, ∃ N, ∀ k ≥ N, u k ∈ V n)\n#align tendsto.subseq_mem tendsto.subseq_mem\n\n",
 "subseq_forall_of_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem subseq_forall_of_frequently {ι : Type _} {x : ℕ → ι} {p : ι → Prop} {l : filter ι}\n    (h_tendsto : tendsto x at_top l)\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n        (p (x n))) :\n    ∃ ns : ℕ → ℕ, tendsto (fun n => x (ns n)) at_top l ∧ ∀ n, p (x (ns n)) :=\n  by\n  rw [tendsto_iff_seq_tendsto] at h_tendsto\n  choose ns hge hns using frequently_at_top.1 h\n  exact ⟨ns, h_tendsto ns (tendsto_at_top_mono hge tendsto_id), hns⟩\n#align subseq_forall_of_frequently subseq_forall_of_frequently\n\n",
 "subbasis_with_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- Given an antitone basis `s : ℕ → set α` of a filter, extract an antitone subbasis `s ∘ φ`,\n`φ : ℕ → ℕ`, such that `m < n` implies `r (φ m) (φ n)`. This lemma can be used to extract an\nantitone basis with basis sets decreasing \"sufficiently fast\". -/\ntheorem has_antitone_basis.subbasis_with_rel {f : filter α} {s : ℕ → set α} (hs : f.has_antitone_basis s)\n    {r : ℕ → ℕ → Prop}\n    (hr :\n      ∀ m,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n          (r m n)) :\n    ∃ φ : ℕ → ℕ, strict_mono φ ∧ (∀ ⦃m n⦄, m < n → r (φ m) (φ n)) ∧ f.has_antitone_basis (s ∘ φ) :=\n  by\n  rsuffices ⟨φ, hφ, hrφ⟩ : ∃ φ : ℕ → ℕ, strict_mono φ ∧ ∀ m n, m < n → r (φ m) (φ n)\n  · exact ⟨φ, hφ, hrφ, hs.comp_strict_mono hφ⟩\n  have :\n    ∀ t : set ℕ,\n      t.finite →\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n          (∀ m ∈ t, m < n ∧ r m n) :=\n    fun t ht => (eventually_all_finite ht).2 fun m hm => (eventually_gt_at_top m).and (hr _)\n  rcases seq_of_forall_finite_exists fun t ht => (this t ht).exists with ⟨φ, hφ⟩\n  simp only [ball_image_iff, forall_and, mem_Iio] at hφ\n  exact ⟨φ, forall_swap.2 hφ.1, forall_swap.2 hφ.2⟩\n#align has_antitone_basis.subbasis_with_rel has_antitone_basis.subbasis_with_rel\n\n",
 "strict_mono_subseq_of_tendsto_at_top":
 "theorem strict_mono_subseq_of_tendsto_at_top {β : Type _} [linear_order β] [NoMaxOrder β] {u : ℕ → β}\n    (hu : tendsto u at_top at_top) : ∃ φ : ℕ → ℕ, strict_mono φ ∧ strict_mono (u ∘ φ) :=\n  let ⟨φ, h, h'⟩ := extraction_of_frequently_at_top (frequently_high_scores hu)\n  ⟨φ, h, fun n m hnm => h' m _ (h hnm)⟩\n#align strict_mono_subseq_of_tendsto_at_top strict_mono_subseq_of_tendsto_at_top\n\n",
 "strict_mono_subseq_of_id_le":
 "theorem strict_mono_subseq_of_id_le {u : ℕ → ℕ} (hu : ∀ n, n ≤ u n) :\n    ∃ φ : ℕ → ℕ, strict_mono φ ∧ strict_mono (u ∘ φ) :=\n  strict_mono_subseq_of_tendsto_at_top (tendsto_at_top_mono hu tendsto_id)\n#align strict_mono_subseq_of_id_le strict_mono_subseq_of_id_le\n\n",
 "prod_map_prod_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem tendsto.prod_map_prod_at_top [SemilatticeSup γ] {F : filter α} {G : filter β} {f : α → γ} {g : β → γ}\n    (hf : tendsto f F at_top) (hg : tendsto g G at_top) : tendsto (prod.map f g) (filter.prod F G) at_top :=\n  by\n  rw [← prod_at_top_at_top_eq]\n  exact hf.prod_map hg\n#align tendsto.prod_map_prod_at_top tendsto.prod_map_prod_at_top\n\n",
 "prod_map_prod_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem tendsto.prod_map_prod_at_bot [SemilatticeInf γ] {F : filter α} {G : filter β} {f : α → γ} {g : β → γ}\n    (hf : tendsto f F at_bot) (hg : tendsto g G at_bot) : tendsto (prod.map f g) (filter.prod F G) at_bot :=\n  by\n  rw [← prod_at_bot_at_bot_eq]\n  exact hf.prod_map hg\n#align tendsto.prod_map_prod_at_bot tendsto.prod_map_prod_at_bot\n\n",
 "prod_map_at_top_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_map_at_top_eq {α₁ α₂ β₁ β₂ : Type _} [SemilatticeSup β₁] [SemilatticeSup β₂] (u₁ : β₁ → α₁)\n    (u₂ : β₂ → α₂) : filter.prod (map u₁ at_top) (map u₂ at_top) = map (prod.map u₁ u₂) at_top := by\n  rw [prod_map_map_eq, prod_at_top_at_top_eq, prod.map_def]\n#align prod_map_at_top_eq prod_map_at_top_eq\n\n",
 "prod_map_at_bot_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_map_at_bot_eq {α₁ α₂ β₁ β₂ : Type _} [SemilatticeInf β₁] [SemilatticeInf β₂] (u₁ : β₁ → α₁)\n    (u₂ : β₂ → α₂) : filter.prod (map u₁ at_bot) (map u₂ at_bot) = map (prod.map u₁ u₂) at_bot :=\n  @prod_map_at_top_eq _ _ («expr ᵒᵈ» β₁) («expr ᵒᵈ» β₂) _ _ _ _\n#align prod_map_at_bot_eq prod_map_at_bot_eq\n\n",
 "prod_at_top_at_top_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_at_top_at_top_eq {β₁ β₂ : Type _} [SemilatticeSup β₁] [SemilatticeSup β₂] :\n    filter.prod (at_top : filter β₁) (at_top : filter β₂) = (at_top : filter (β₁ × β₂)) :=\n  by\n  cases (isEmpty_or_nonempty β₁).symm\n  cases (isEmpty_or_nonempty β₂).symm\n  · simp [at_top, prod_infi_left, prod_infi_right, infᵢ_prod]\n    exact infᵢ_comm\n  · simp only [at_top.filter_eq_bot_of_is_empty, prod_bot]\n  · simp only [at_top.filter_eq_bot_of_is_empty, bot_prod]\n#align prod_at_top_at_top_eq prod_at_top_at_top_eq\n\n",
 "prod_at_top":
 "theorem tendsto.prod_at_top [SemilatticeSup α] [SemilatticeSup γ] {f g : α → γ} (hf : tendsto f at_top at_top)\n    (hg : tendsto g at_top at_top) : tendsto (prod.map f g) at_top at_top :=\n  by\n  rw [← prod_at_top_at_top_eq]\n  exact hf.prod_map_prod_at_top hg\n#align tendsto.prod_at_top tendsto.prod_at_top\n\n",
 "prod_at_bot_at_bot_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_at_bot_at_bot_eq {β₁ β₂ : Type _} [SemilatticeInf β₁] [SemilatticeInf β₂] :\n    filter.prod (at_bot : filter β₁) (at_bot : filter β₂) = (at_bot : filter (β₁ × β₂)) :=\n  @prod_at_top_at_top_eq («expr ᵒᵈ» β₁) («expr ᵒᵈ» β₂) _ _\n#align prod_at_bot_at_bot_eq prod_at_bot_at_bot_eq\n\n",
 "prod_at_bot":
 "theorem tendsto.prod_at_bot [SemilatticeInf α] [SemilatticeInf γ] {f g : α → γ} (hf : tendsto f at_bot at_bot)\n    (hg : tendsto g at_bot at_bot) : tendsto (prod.map f g) at_bot at_bot :=\n  by\n  rw [← prod_at_bot_at_bot_eq]\n  exact hf.prod_map_prod_at_bot hg\n#align tendsto.prod_at_bot tendsto.prod_at_bot\n\n",
 "nsmul_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.nsmul_at_top (hf : tendsto f l at_top) {n : ℕ} (hn : 0 < n) :\n    tendsto (fun x => «expr • » n (f x)) l at_top :=\n  tendsto_at_top.2 fun y =>\n    (tendsto_at_top.1 hf y).mp <|\n      (tendsto_at_top.1 hf 0).mono fun x h₀ hy =>\n        calc\n          y ≤ f x := hy\n          _ = «expr • » 1 (f x) := (one_nsmul _).symm\n          _ ≤ «expr • » n (f x) := nsmul_le_nsmul h₀ hn\n          \n#align tendsto.nsmul_at_top tendsto.nsmul_at_top\n\n",
 "nsmul_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.nsmul_at_bot (hf : tendsto f l at_bot) {n : ℕ} (hn : 0 < n) :\n    tendsto (fun x => «expr • » n (f x)) l at_bot :=\n  @tendsto.nsmul_at_top α («expr ᵒᵈ» β) _ l f hf n hn\n#align tendsto.nsmul_at_bot tendsto.nsmul_at_bot\n\n",
 "not_tendsto_pow_at_top_at_bot":
 "theorem not_tendsto_pow_at_top_at_bot [LinearOrderedRing α] : ∀ {n : ℕ}, ¬tendsto (fun x : α => x ^ n) at_top at_bot\n  | 0 => by simp [not_tendsto_const_at_bot]\n  | n + 1 => (tendsto_pow_at_top n.succ_ne_zero).not_tendsto disjoint_at_top_at_bot\n#align not_tendsto_pow_at_top_at_bot not_tendsto_pow_at_top_at_bot\n\n",
 "not_tendsto_iff_exists_frequently_nmem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem not_tendsto_iff_exists_frequently_nmem {α ι : Type _} {x : ι → α} {f : filter α} {l : filter ι} :\n    ¬tendsto x l f ↔\n      ∃ s ∈ f,\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l\n          (x n ∉ s) :=\n  by\n  rw [tendsto_iff_forall_eventually_mem]\n  push_neg\n  refine' exists_congr fun s => _\n  rw [not_eventually, exists_prop]\n#align not_tendsto_iff_exists_frequently_nmem not_tendsto_iff_exists_frequently_nmem\n\n",
 "not_tendsto_const_at_top":
 "theorem not_tendsto_const_at_top [preorder α] [NoMaxOrder α] (x : α) (l : filter β) [l.ne_bot] :\n    ¬tendsto (fun _ => x) l at_top :=\n  tendsto_const_pure.not_tendsto (disjoint_pure_at_top x)\n#align not_tendsto_const_at_top not_tendsto_const_at_top\n\n",
 "not_tendsto_const_at_bot":
 "theorem not_tendsto_const_at_bot [preorder α] [NoMinOrder α] (x : α) (l : filter β) [l.ne_bot] :\n    ¬tendsto (fun _ => x) l at_bot :=\n  tendsto_const_pure.not_tendsto (disjoint_pure_at_bot x)\n#align not_tendsto_const_at_bot not_tendsto_const_at_bot\n\n",
 "nonneg_of_eventually_pow_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem nonneg_of_eventually_pow_nonneg [LinearOrderedRing α] {a : α}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (0 ≤ a ^ (n : ℕ))) :\n    0 ≤ a :=\n  let ⟨n, hn⟩ := (tendsto_bit1_at_top.eventually h).exists\n  pow_bit1_nonneg_iff.1 hn\n#align nonneg_of_eventually_pow_nonneg nonneg_of_eventually_pow_nonneg\n\n",
 "neg_const_mul_at_top":
 "/-- If a function tends to infinity along a filter, then this function multiplied by a negative\nconstant (on the left) tends to negative infinity. -/\ntheorem tendsto.neg_const_mul_at_top (hr : r < 0) (hf : tendsto f l at_top) : tendsto (fun x => r * f x) l at_bot :=\n  (tendsto_const_mul_at_bot_of_neg hr).2 hf\n#align tendsto.neg_const_mul_at_top tendsto.neg_const_mul_at_top\n\n",
 "neg_const_mul_at_bot":
 "/-- If a function tends to negative infinity along a filter, then this function multiplied by\na negative constant (on the left) tends to positive infinity. -/\ntheorem tendsto.neg_const_mul_at_bot (hr : r < 0) (hf : tendsto f l at_bot) : tendsto (fun x => r * f x) l at_top :=\n  (tendsto_const_mul_at_top_of_neg hr).2 hf\n#align tendsto.neg_const_mul_at_bot tendsto.neg_const_mul_at_bot\n\n",
 "mem_at_top_sets":
 "@[simp]\ntheorem mem_at_top_sets [nonempty α] [SemilatticeSup α] {s : set α} :\n    s ∈ (at_top : filter α) ↔ ∃ a : α, ∀ b ≥ a, b ∈ s :=\n  at_top_basis.mem_iff.trans <| exists_congr fun _ => exists_const _\n#align mem_at_top_sets mem_at_top_sets\n\n",
 "mem_at_top":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Jeremy Avigad, Yury Kudryashov, Patrick Massot\n-/\ntheorem mem_at_top [preorder α] (a : α) : { b : α | a ≤ b } ∈ @at_top α _ :=\n  mem_infi_of_mem a <| Subset.refl _\n#align mem_at_top mem_at_top\n\n",
 "mem_at_bot_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem mem_at_bot_sets [nonempty α] [SemilatticeInf α] {s : set α} :\n    s ∈ (at_bot : filter α) ↔ ∃ a : α, ∀ b ≤ a, b ∈ s :=\n  @mem_at_top_sets («expr ᵒᵈ» α) _ _ _\n#align mem_at_bot_sets mem_at_bot_sets\n\n",
 "mem_at_bot":
 "theorem mem_at_bot [preorder α] (a : α) : { b : α | b ≤ a } ∈ @at_bot α _ :=\n  mem_infi_of_mem a <| Subset.refl _\n#align mem_at_bot mem_at_bot\n\n",
 "map_sub_at_top_eq_nat":
 "theorem map_sub_at_top_eq_nat (k : ℕ) : map (fun a => a - k) at_top = at_top :=\n  map_at_top_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _) (fun a b _ => tsub_le_iff_right)\n    fun b _ => by rw [add_tsub_cancel_right]\n#align map_sub_at_top_eq_nat map_sub_at_top_eq_nat\n\n",
 "map_neg_at_top":
 "theorem map_neg_at_top : map (has_neg.neg : β → β) at_top = at_bot :=\n  (OrderIso.neg β).map_at_top\n#align map_neg_at_top map_neg_at_top\n\n",
 "map_neg_at_bot":
 "theorem map_neg_at_bot : map (has_neg.neg : β → β) at_bot = at_top :=\n  (OrderIso.neg β).map_at_bot\n#align map_neg_at_bot map_neg_at_bot\n\n",
 "map_div_at_top_eq_nat":
 "theorem map_div_at_top_eq_nat (k : ℕ) (hk : 0 < k) : map (fun a => a / k) at_top = at_top :=\n  map_at_top_eq_of_gc (fun b => b * k + (k - 1)) 1 (fun a b h => Nat.div_le_div_right h)\n    (fun a b _ =>\n      calc\n        a / k ≤ b ↔ a / k < b + 1 := by rw [← nat.succ_eq_add_one, Nat.lt_succ_iff]\n        _ ↔ a < (b + 1) * k := nat.div_lt_iff_lt_mul hk\n        _ ↔ _ := by\n          cases k\n          exact (lt_irrefl _ hk).elim\n          rw [add_mul, one_mul, nat.succ_sub_succ_eq_sub, tsub_zero, nat.add_succ, Nat.lt_succ_iff]\n        )\n    fun b _ =>\n    calc\n      b = b * k / k := by rw [nat.mul_div_cancel b hk]\n      _ ≤ (b * k + (k - 1)) / k := Nat.div_le_div_right <| nat.le_add_right _ _\n      \n#align map_div_at_top_eq_nat map_div_at_top_eq_nat\n\n",
 "map_coe_at_top_of_Ici_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_coe_at_top_of_Ici_subset [SemilatticeSup α] {a : α} {s : set α} (h : Ici a ⊆ s) :\n    map (coe : s → α) at_top = at_top :=\n  by\n  have : Directed (· ≥ ·) fun x : s => (filter.principal) (Ici x) :=\n    by\n    intro x y\n    use ⟨«expr ⊔ » («expr ⊔ » x y) a, h le_sup_right⟩\n    simp only [ge_iff_le, principal_mono, Ici_subset_Ici, ← Subtype.coe_le_coe, subtype.coe_mk]\n    exact ⟨le_sup_left.trans le_sup_left, le_sup_right.trans le_sup_left⟩\n  haveI : nonempty s := ⟨⟨a, h le_rfl⟩⟩\n  simp only [le_antisymm_iff, at_top, le_infᵢ_iff, le_principal_iff, mem_map, mem_set_of_eq, map_infi_eq this,\n    map_principal]\n  constructor\n  · intro x\n    refine' mem_of_superset (mem_infi_of_mem ⟨«expr ⊔ » x a, h le_sup_right⟩ (mem_principal_self _)) _\n    rintro _ ⟨y, hy, rfl⟩\n    exact le_trans le_sup_left (Subtype.coe_le_coe.2 hy)\n  · intro x\n    filter_upwards [mem_at_top («expr ⊔ » (↑x) a)] with b hb\n    exact ⟨⟨b, h <| le_sup_right.trans hb⟩, Subtype.coe_le_coe.1 (le_sup_left.trans hb), rfl⟩\n#align map_coe_at_top_of_Ici_subset map_coe_at_top_of_Ici_subset\n\n",
 "map_coe_Ioi_at_top":
 "/-- The image of the filter `at_top` on `Ioi a` under the coercion equals `at_top`. -/\n@[simp]\ntheorem map_coe_Ioi_at_top [SemilatticeSup α] [NoMaxOrder α] (a : α) : map (coe : Ioi a → α) at_top = at_top :=\n  let ⟨b, hb⟩ := exists_gt a\n  map_coe_at_top_of_Ici_subset <| Ici_subset_Ioi.2 hb\n#align map_coe_Ioi_at_top map_coe_Ioi_at_top\n\n",
 "map_coe_Iio_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient\norder. -/\n@[simp]\ntheorem map_coe_Iio_at_bot [SemilatticeInf α] [NoMinOrder α] (a : α) : map (coe : Iio a → α) at_bot = at_bot :=\n  @map_coe_Ioi_at_top («expr ᵒᵈ» α) _ _ _\n#align map_coe_Iio_at_bot map_coe_Iio_at_bot\n\n",
 "map_coe_Iic_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient\norder. -/\n@[simp]\ntheorem map_coe_Iic_at_bot [SemilatticeInf α] (a : α) : map (coe : Iic a → α) at_bot = at_bot :=\n  @map_coe_Ici_at_top («expr ᵒᵈ» α) _ _\n#align map_coe_Iic_at_bot map_coe_Iic_at_bot\n\n",
 "map_coe_Ici_at_top":
 "/-- The image of the filter `at_top` on `Ici a` under the coercion equals `at_top`. -/\n@[simp]\ntheorem map_coe_Ici_at_top [SemilatticeSup α] (a : α) : map (coe : Ici a → α) at_top = at_top :=\n  map_coe_at_top_of_Ici_subset (Subset.refl _)\n#align map_coe_Ici_at_top map_coe_Ici_at_top\n\n",
 "map_at_top_finset_prod_le_of_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Let `f` and `g` be two maps to the same commutative monoid. This lemma gives a sufficient\ncondition for comparison of the filter `at_top.map (λ s, ∏ b in s, f b)` with\n`at_top.map (λ s, ∏ b in s, g b)`. This is useful to compare the set of limit points of\n`Π b in s, f b` as `s → at_top` with the similar set for `g`. -/\n@[to_additive\n      \"Let `f` and `g` be two maps to the same commutative additive monoid. This lemma gives\\na sufficient condition for comparison of the filter `at_top.map (λ s, ∑ b in s, f b)` with\\n`at_top.map (λ s, ∑ b in s, g b)`. This is useful to compare the set of limit points of\\n`∑ b in s, f b` as `s → at_top` with the similar set for `g`.\"]\ntheorem map_at_top_finset_prod_le_of_prod_eq [comm_monoid α] {f : β → α} {g : γ → α}\n    (h_eq :\n      ∀ u : Finset γ,\n        ∃ v : Finset β,\n          ∀ v',\n            v ⊆ v' →\n              ∃ u',\n                u ⊆ u' ∧\n                  finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" u'\n                      (g x) =\n                    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" v'\n                      (f b)) :\n    (at_top.map fun s : Finset β =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f b)) ≤\n      at_top.map fun s : Finset γ =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g x) :=\n  by\n  rw [map_at_top_eq, map_at_top_eq] <;>\n    exact\n      le_infᵢ fun b =>\n        let ⟨v, hv⟩ := h_eq b\n        infᵢ_le_of_le v <| by simp [Set.image_subset_iff] <;> exact hv\n#align map_at_top_finset_prod_le_of_prod_eq map_at_top_finset_prod_le_of_prod_eq\n\n",
 "map_at_top_finset_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x «expr ∉ » set.range[set.range] g) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Let `g : γ → β` be an injective function and `f : β → α` be a function from the codomain of `g`\nto a commutative monoid. Suppose that `f x = 1` outside of the range of `g`. Then the filters\n`at_top.map (λ s, ∏ i in s, f (g i))` and `at_top.map (λ s, ∏ i in s, f i)` coincide.\n\nThe additive version of this lemma is used to prove the equality `∑' x, f (g x) = ∑' y, f y` under\nthe same assumptions.-/\n@[to_additive]\ntheorem function.injective.map_at_top_finset_prod_eq [comm_monoid α] {g : γ → β} (hg : function.injective g) {f : β → α}\n    (hf : ∀ (x) (_ : x ∉ Set.range g), f x = 1) :\n    map\n        (fun s =>\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f (g i)))\n        at_top =\n      map\n        (fun s =>\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i))\n        at_top :=\n  by\n  apply le_antisymm <;> refine' map_at_top_finset_prod_le_of_prod_eq fun s => _\n  · refine' ⟨s.preimage g (hg.inj_on _), fun t ht => _⟩\n    refine' ⟨t.image g ∪ s, Finset.subset_union_right _ _, _⟩\n    rw [← finset.prod_image (hg.inj_on _)]\n    refine' (prod_subset (subset_union_left _ _) _).symm\n    simp only [Finset.mem_union, Finset.mem_image]\n    refine' fun y hy hyt => hf y (mt _ hyt)\n    rintro ⟨x, rfl⟩\n    exact ⟨x, ht (finset.mem_preimage.2 <| hy.resolve_left hyt), rfl⟩\n  · refine' ⟨s.image g, fun t ht => _⟩\n    simp only [← prod_preimage _ _ (hg.inj_on _) _ fun x _ => hf x]\n    exact ⟨_, (image_subset_iff_subset_preimage _).1 ht, rfl⟩\n#align function.injective.map_at_top_finset_prod_eq function.injective.map_at_top_finset_prod_eq\n\n",
 "map_at_top_eq_of_gc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- A function `f` maps upwards closed sets (at_top sets) to upwards closed sets when it is a\nGalois insertion. The Galois \"insertion\" and \"connection\" is weakened to only require it to be an\ninsertion and a connetion above `b'`. -/\ntheorem map_at_top_eq_of_gc [SemilatticeSup α] [SemilatticeSup β] {f : α → β} (g : β → α) (b' : β) (hf : monotone f)\n    (gc : ∀ a, ∀ b ≥ b', f a ≤ b ↔ a ≤ g b) (hgi : ∀ b ≥ b', b ≤ f (g b)) : map f at_top = at_top :=\n  by\n  refine'\n    le_antisymm (hf.tendsto_at_top_at_top fun b => ⟨g («expr ⊔ » b b'), le_sup_left.trans <| hgi _ le_sup_right⟩) _\n  rw [@map_at_top_eq _ _ ⟨g b'⟩]\n  refine' le_infᵢ fun a => infᵢ_le_of_le («expr ⊔ » (f a) b') <| principal_mono.2 fun b hb => _\n  rw [mem_Ici, sup_le_iff] at hb\n  exact ⟨g b, (gc _ _ hb.2).1 hb.1, le_antisymm ((gc _ _ hb.2).2 le_rfl) (hgi _ hb.2)⟩\n#align map_at_top_eq_of_gc map_at_top_eq_of_gc\n\n",
 "map_at_top_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_at_top_eq [nonempty α] [SemilatticeSup α] {f : α → β} :\n    at_top.map f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (filter.principal <| «expr '' » f { a' | a ≤ a' }) :=\n  (at_top_basis.map _).eq_infi\n#align map_at_top_eq map_at_top_eq\n\n",
 "map_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n@[simp]\ntheorem map_at_top (e : «expr ≃o » α β) : map (e : α → β) at_top = at_top := by\n  rw [← e.comap_at_top, map_comap_of_surjective e.surjective]\n#align map_at_top map_at_top\n\n",
 "map_at_bot_eq_of_gc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem map_at_bot_eq_of_gc [SemilatticeInf α] [SemilatticeInf β] {f : α → β} (g : β → α) (b' : β) (hf : monotone f)\n    (gc : ∀ a, ∀ b ≤ b', b ≤ f a ↔ g b ≤ a) (hgi : ∀ b ≤ b', f (g b) ≤ b) : map f at_bot = at_bot :=\n  @map_at_top_eq_of_gc («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ _ _ _ hf.dual gc hgi\n#align map_at_bot_eq_of_gc map_at_bot_eq_of_gc\n\n",
 "map_at_bot_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_at_bot_eq [nonempty α] [SemilatticeInf α] {f : α → β} :\n    at_bot.map f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (filter.principal <| «expr '' » f { a' | a' ≤ a }) :=\n  @map_at_top_eq («expr ᵒᵈ» α) _ _ _ _\n#align map_at_bot_eq map_at_bot_eq\n\n",
 "map_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n@[simp]\ntheorem map_at_bot (e : «expr ≃o » α β) : map (e : α → β) at_bot = at_bot :=\n  e.dual.map_at_top\n#align map_at_bot map_at_bot\n\n",
 "map_add_at_top_eq_nat":
 "theorem map_add_at_top_eq_nat (k : ℕ) : map (fun a => a + k) at_top = at_top :=\n  map_at_top_eq_of_gc (fun a => a - k) k (fun a b h => add_le_add_right h k) (fun a b h => (le_tsub_iff_right h).symm)\n    fun a h => by rw [tsub_add_cancel_of_le h]\n#align map_add_at_top_eq_nat map_add_at_top_eq_nat\n\n",
 "low_scores":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n-- see Note [nolint_ge]\n/-- If `u` is a sequence which is unbounded below,\nthen after any point, it reaches a value strictly smaller than all previous values.\n-/\n@[nolint ge_or_gt]\ntheorem low_scores [linear_order β] [NoMinOrder β] {u : ℕ → β} (hu : tendsto u at_top at_bot) :\n    ∀ N, ∃ n ≥ N, ∀ k < n, u n < u k :=\n  @high_scores («expr ᵒᵈ» β) _ _ _ hu\n#align low_scores low_scores\n\n",
 "inf_map_at_top_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_map_at_top_ne_bot_iff [SemilatticeSup α] [nonempty α] {F : filter β} {u : α → β} :\n    ne_bot («expr ⊓ » F (map u at_top)) ↔ ∀ U ∈ F, ∀ N, ∃ n ≥ N, u n ∈ U := by\n  simp_rw [inf_ne_bot_iff_frequently_left, frequently_map, frequently_at_top] <;> rfl\n#align inf_map_at_top_ne_bot_iff inf_map_at_top_ne_bot_iff\n\n",
 "inf_map_at_bot_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_map_at_bot_ne_bot_iff [SemilatticeInf α] [nonempty α] {F : filter β} {u : α → β} :\n    ne_bot («expr ⊓ » F (map u at_bot)) ↔ ∀ U ∈ F, ∀ N, ∃ n ≤ N, u n ∈ U :=\n  @inf_map_at_top_ne_bot_iff («expr ᵒᵈ» α) _ _ _ _ _\n#align inf_map_at_bot_ne_bot_iff inf_map_at_bot_ne_bot_iff\n\n",
 "high_scores":
 "/-- If `u` is a sequence which is unbounded above,\nthen after any point, it reaches a value strictly greater than all previous values.\n-/\ntheorem high_scores [linear_order β] [NoMaxOrder β] {u : ℕ → β} (hu : tendsto u at_top at_top) :\n    ∀ N, ∃ n ≥ N, ∀ k < n, u k < u n := by\n  intro N\n  obtain ⟨k : ℕ, hkn : k ≤ N, hku : ∀ l ≤ N, u l ≤ u k⟩ : ∃ k ≤ N, ∀ l ≤ N, u l ≤ u k\n  exact exists_max_image _ u (finite_le_nat N) ⟨N, le_refl N⟩\n  have ex : ∃ n ≥ N, u k < u n := exists_lt_of_tendsto_at_top hu _ _\n  obtain ⟨n : ℕ, hnN : n ≥ N, hnk : u k < u n, hn_min : ∀ m, m < n → N ≤ m → u m ≤ u k⟩ :\n    ∃ n ≥ N, u k < u n ∧ ∀ m, m < n → N ≤ m → u m ≤ u k :=\n    by\n    rcases nat.find_x ex with ⟨n, ⟨hnN, hnk⟩, hn_min⟩\n    push_neg  at hn_min\n    exact ⟨n, hnN, hnk, hn_min⟩\n  use n, hnN\n  rintro (l : ℕ) (hl : l < n)\n  have hlk : u l ≤ u k := by\n    cases' (le_total l N : l ≤ N ∨ N ≤ l) with H H\n    · exact hku l H\n    · exact hn_min l hl H\n  calc\n    u l ≤ u k := hlk\n    _ < u n := hnk\n    \n#align high_scores high_scores\n\n",
 "frequently_low_scores":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/-- If `u` is a sequence which is unbounded below,\nthen it `frequently` reaches a value strictly smaller than all previous values.\n-/\ntheorem frequently_low_scores [linear_order β] [NoMinOrder β] {u : ℕ → β} (hu : tendsto u at_top at_bot) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n      (∀ k < n, u n < u k) :=\n  @frequently_high_scores («expr ᵒᵈ» β) _ _ _ hu\n#align frequently_low_scores frequently_low_scores\n\n",
 "frequently_iff_seq_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_iff_seq_frequently {ι : Type _} {l : filter ι} {p : ι → Prop} [hl : l.is_countably_generated] :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l (p n) ↔\n      ∃ x : ℕ → ι,\n        tendsto x at_top l ∧\n          «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n            (p (x n)) :=\n  by\n  refine' ⟨fun h_freq => _, fun h_exists_freq => _⟩\n  · have : ne_bot («expr ⊓ » l ((filter.principal) { x : ι | p x })) := by simpa [ne_bot_iff, inf_principal_eq_bot]\n    obtain ⟨x, hx⟩ := exists_seq_tendsto («expr ⊓ » l ((filter.principal) { x : ι | p x }))\n    rw [tendsto_inf] at hx\n    cases' hx with hx_l hx_p\n    refine' ⟨x, hx_l, _⟩\n    rw [tendsto_principal] at hx_p\n    exact hx_p.frequently\n  · obtain ⟨x, hx_tendsto, hx_freq⟩ := h_exists_freq\n    simp_rw [filter.frequently, filter.eventually] at hx_freq⊢\n    have : { n : ℕ | ¬p (x n) } = { n | x n ∈ { y | ¬p y } } := rfl\n    rw [this, ← mem_map'] at hx_freq\n    contrapose! hx_freq\n    exact hx_tendsto hx_freq\n#align frequently_iff_seq_frequently frequently_iff_seq_frequently\n\n",
 "frequently_high_scores":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/-- If `u` is a sequence which is unbounded above,\nthen it `frequently` reaches a value strictly greater than all previous values.\n-/\ntheorem frequently_high_scores [linear_order β] [NoMaxOrder β] {u : ℕ → β} (hu : tendsto u at_top at_top) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n      (∀ k < n, u k < u n) :=\n  by simpa [frequently_at_top] using high_scores hu\n#align frequently_high_scores frequently_high_scores\n\n",
 "frequently_at_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_at_top' [SemilatticeSup α] [nonempty α] [NoMaxOrder α] {p : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n        (p x) ↔\n      ∀ a, ∃ b > a, p b :=\n  by simp [at_top_basis_Ioi.frequently_iff]\n#align frequently_at_top' frequently_at_top'\n\n",
 "frequently_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_at_top [SemilatticeSup α] [nonempty α] {p : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n        (p x) ↔\n      ∀ a, ∃ b ≥ a, p b :=\n  by simp [at_top_basis.frequently_iff]\n#align frequently_at_top frequently_at_top\n\n",
 "frequently_at_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_at_bot' [SemilatticeInf α] [nonempty α] [NoMinOrder α] {p : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_bot\n        (p x) ↔\n      ∀ a, ∃ b < a, p b :=\n  @frequently_at_top' («expr ᵒᵈ» α) _ _ _ _\n#align frequently_at_bot' frequently_at_bot'\n\n",
 "frequently_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_at_bot [SemilatticeInf α] [nonempty α] {p : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_bot\n        (p x) ↔\n      ∀ a, ∃ b ≤ a, p b :=\n  @frequently_at_top («expr ᵒᵈ» α) _ _ _\n#align frequently_at_bot frequently_at_bot\n\n",
 "forall_exists_of_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently.forall_exists_of_at_top [SemilatticeSup α] [nonempty α] {p : α → Prop}\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n        (p x)) :\n    ∀ a, ∃ b ≥ a, p b :=\n  frequently_at_top.mp h\n#align frequently.forall_exists_of_at_top frequently.forall_exists_of_at_top\n\n",
 "forall_exists_of_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently.forall_exists_of_at_bot [SemilatticeInf α] [nonempty α] {p : α → Prop}\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_bot\n        (p x)) :\n    ∀ a, ∃ b ≤ a, p b :=\n  frequently_at_bot.mp h\n#align frequently.forall_exists_of_at_bot frequently.forall_exists_of_at_bot\n\n",
 "extraction_of_frequently_at_top'":
 "theorem extraction_of_frequently_at_top' {P : ℕ → Prop} (h : ∀ N, ∃ n > N, P n) :\n    ∃ φ : ℕ → ℕ, strict_mono φ ∧ ∀ n, P (φ n) := by\n  choose u hu using h\n  cases' forall_and_distrib.mp hu with hu hu'\n  exact ⟨u ∘ nat.rec 0 fun n v => u v, strictMono_nat_of_lt_succ fun n => hu _, fun n => hu' _⟩\n#align extraction_of_frequently_at_top' extraction_of_frequently_at_top'\n\n",
 "extraction_of_frequently_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem extraction_of_frequently_at_top {P : ℕ → Prop}\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n        (P n)) :\n    ∃ φ : ℕ → ℕ, strict_mono φ ∧ ∀ n, P (φ n) :=\n  by\n  rw [frequently_at_top'] at h\n  exact extraction_of_frequently_at_top' h\n#align extraction_of_frequently_at_top extraction_of_frequently_at_top\n\n",
 "extraction_of_eventually_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem extraction_of_eventually_at_top {P : ℕ → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (P n)) :\n    ∃ φ : ℕ → ℕ, strict_mono φ ∧ ∀ n, P (φ n) :=\n  extraction_of_frequently_at_top h.frequently\n#align extraction_of_eventually_at_top extraction_of_eventually_at_top\n\n",
 "extraction_forall_of_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem extraction_forall_of_frequently {P : ℕ → ℕ → Prop}\n    (h :\n      ∀ n,\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n          (P n k)) :\n    ∃ φ : ℕ → ℕ, strict_mono φ ∧ ∀ n, P n (φ n) :=\n  by\n  simp only [frequently_at_top'] at h\n  choose u hu hu' using h\n  use (fun n => nat.rec_on n (u 0 0) fun n v => u (n + 1) v : ℕ → ℕ)\n  constructor\n  · apply strictMono_nat_of_lt_succ\n    intro n\n    apply hu\n  · intro n\n    cases n <;> simp [hu']\n#align extraction_forall_of_frequently extraction_forall_of_frequently\n\n",
 "extraction_forall_of_eventually'":
 "theorem extraction_forall_of_eventually' {P : ℕ → ℕ → Prop} (h : ∀ n, ∃ N, ∀ k ≥ N, P n k) :\n    ∃ φ : ℕ → ℕ, strict_mono φ ∧ ∀ n, P n (φ n) :=\n  extraction_forall_of_eventually (by simp [eventually_at_top, h])\n#align extraction_forall_of_eventually' extraction_forall_of_eventually'\n\n",
 "extraction_forall_of_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem extraction_forall_of_eventually {P : ℕ → ℕ → Prop}\n    (h :\n      ∀ n,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n          (P n k)) :\n    ∃ φ : ℕ → ℕ, strict_mono φ ∧ ∀ n, P n (φ n) :=\n  extraction_forall_of_frequently fun n => (h n).frequently\n#align extraction_forall_of_eventually extraction_forall_of_eventually\n\n",
 "exists_seq_tendsto":
 "/-- If `f` is a nontrivial countably generated filter, then there exists a sequence that converges\nto `f`. -/\ntheorem exists_seq_tendsto (f : filter α) [is_countably_generated f] [ne_bot f] : ∃ x : ℕ → α, tendsto x at_top f :=\n  by\n  obtain ⟨B, h⟩ := f.exists_antitone_basis\n  choose x hx using fun n => filter.nonempty_of_mem (h.mem n)\n  exact ⟨x, h.tendsto hx⟩\n#align exists_seq_tendsto exists_seq_tendsto\n\n",
 "exists_seq_forall_of_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem exists_seq_forall_of_frequently {ι : Type _} {l : filter ι} {p : ι → Prop} [hl : l.is_countably_generated]\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l (p n)) :\n    ∃ ns : ℕ → ι, tendsto ns at_top l ∧ ∀ n, p (ns n) :=\n  by\n  rw [frequently_iff_seq_frequently] at h\n  obtain ⟨x, hx_tendsto, hx_freq⟩ := h\n  obtain ⟨n_to_n, h_tendsto, h_freq⟩ := subseq_forall_of_frequently hx_tendsto hx_freq\n  exact ⟨x ∘ n_to_n, h_tendsto, h_freq⟩\n#align exists_seq_forall_of_frequently exists_seq_forall_of_frequently\n\n",
 "exists_lt_of_tendsto_at_top":
 "theorem exists_lt_of_tendsto_at_top [SemilatticeSup α] [preorder β] [NoMaxOrder β] {u : α → β}\n    (h : tendsto u at_top at_top) (a : α) (b : β) : ∃ a' ≥ a, b < u a' :=\n  by\n  cases' exists_gt b with b' hb'\n  rcases exists_le_of_tendsto_at_top h a b' with ⟨a', ha', ha''⟩\n  exact ⟨a', ha', lt_of_lt_of_le hb' ha''⟩\n#align exists_lt_of_tendsto_at_top exists_lt_of_tendsto_at_top\n\n",
 "exists_lt_of_tendsto_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n-- see Note [nolint_ge]\n@[nolint ge_or_gt]\ntheorem exists_lt_of_tendsto_at_bot [SemilatticeSup α] [preorder β] [NoMinOrder β] {u : α → β}\n    (h : tendsto u at_top at_bot) : ∀ a b, ∃ a' ≥ a, u a' < b :=\n  @exists_lt_of_tendsto_at_top _ («expr ᵒᵈ» β) _ _ _ _ h\n#align exists_lt_of_tendsto_at_bot exists_lt_of_tendsto_at_bot\n\n",
 "exists_lt_mul_self":
 "theorem exists_lt_mul_self (a : R) : ∃ x ≥ 0, a < x * x :=\n  let ⟨x, hxa, hx0⟩ :=\n    ((tendsto_mul_self_at_top.eventually (eventually_gt_at_top a)).and (eventually_ge_at_top 0)).exists\n  ⟨x, hx0, hxa⟩\n#align exists_lt_mul_self exists_lt_mul_self\n\n",
 "exists_le_of_tendsto_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem exists_le_of_tendsto_at_top [SemilatticeSup α] [preorder β] {u : α → β} (h : tendsto u at_top at_top) (a : α)\n    (b : β) : ∃ a' ≥ a, b ≤ u a' :=\n  by\n  have :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (a ≤ x ∧ b ≤ u x) :=\n    (eventually_ge_at_top a).and (h.eventually <| eventually_ge_at_top b)\n  haveI : nonempty α := ⟨a⟩\n  rcases this.exists with ⟨a', ha, hb⟩\n  exact ⟨a', ha, hb⟩\n#align exists_le_of_tendsto_at_top exists_le_of_tendsto_at_top\n\n",
 "exists_le_of_tendsto_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n-- see Note [nolint_ge]\n@[nolint ge_or_gt]\ntheorem exists_le_of_tendsto_at_bot [SemilatticeSup α] [preorder β] {u : α → β} (h : tendsto u at_top at_bot) :\n    ∀ a b, ∃ a' ≥ a, u a' ≤ b :=\n  @exists_le_of_tendsto_at_top _ («expr ᵒᵈ» β) _ _ _ h\n#align exists_le_of_tendsto_at_bot exists_le_of_tendsto_at_bot\n\n",
 "exists_le_mul_self":
 "theorem exists_le_mul_self (a : R) : ∃ x ≥ 0, a ≤ x * x :=\n  let ⟨x, hx0, hxa⟩ := exists_lt_mul_self a\n  ⟨x, hx0, hxa.le⟩\n#align exists_le_mul_self exists_le_mul_self\n\n",
 "exists_forall_of_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually.exists_forall_of_at_top [SemilatticeSup α] [nonempty α] {p : α → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (p x)) :\n    ∃ a, ∀ b ≥ a, p b :=\n  eventually_at_top.mp h\n#align eventually.exists_forall_of_at_top eventually.exists_forall_of_at_top\n\n",
 "exists_forall_of_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually.exists_forall_of_at_bot [SemilatticeInf α] [nonempty α] {p : α → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_bot\n        (p x)) :\n    ∃ a, ∀ b ≤ a, p b :=\n  eventually_at_bot.mp h\n#align eventually.exists_forall_of_at_bot eventually.exists_forall_of_at_bot\n\n",
 "eventually_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem has_antitone_basis.eventually_subset [preorder ι] {l : filter α} {s : ι → set α} (hl : l.has_antitone_basis s)\n    {t : set α} (ht : t ∈ l) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (s i ⊆ t) :=\n  let ⟨i, _, hi⟩ := hl.to_has_basis.mem_iff.1 ht\n  (eventually_ge_at_top i).mono fun j hj => (hl.antitone hj).trans hi\n#align has_antitone_basis.eventually_subset has_antitone_basis.eventually_subset\n\n",
 "eventually_ne_at_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.eventually_ne_at_top' [preorder β] [NoMaxOrder β] {f : α → β} {l : filter α} (hf : tendsto f l at_top)\n    (c : α) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l (x ≠ c) :=\n  (hf.eventually_ne_at_top (f c)).mono fun x => ne_of_apply_ne f\n#align tendsto.eventually_ne_at_top' tendsto.eventually_ne_at_top'\n\n",
 "eventually_ne_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.eventually_ne_at_top [preorder β] [NoMaxOrder β] {f : α → β} {l : filter α} (hf : tendsto f l at_top)\n    (c : β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (f x ≠ c) :=\n  hf.eventually (eventually_ne_at_top c)\n#align tendsto.eventually_ne_at_top tendsto.eventually_ne_at_top\n\n",
 "eventually_ne_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.eventually_ne_at_bot [preorder β] [NoMinOrder β] {f : α → β} {l : filter α} (hf : tendsto f l at_bot)\n    (c : β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (f x ≠ c) :=\n  hf.eventually (eventually_ne_at_bot c)\n#align tendsto.eventually_ne_at_bot tendsto.eventually_ne_at_bot\n\n",
 "eventually_lt_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.eventually_lt_at_bot [preorder β] [NoMinOrder β] {f : α → β} {l : filter α} (hf : tendsto f l at_bot)\n    (c : β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (f x < c) :=\n  hf.eventually (eventually_lt_at_bot c)\n#align tendsto.eventually_lt_at_bot tendsto.eventually_lt_at_bot\n\n",
 "eventually_le_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.eventually_le_at_bot [preorder β] {f : α → β} {l : filter α} (hf : tendsto f l at_bot) (c : β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (f x ≤ c) :=\n  hf.eventually (eventually_le_at_bot c)\n#align tendsto.eventually_le_at_bot tendsto.eventually_le_at_bot\n\n",
 "eventually_iff_seq_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_iff_seq_eventually {ι : Type _} {l : filter ι} {p : ι → Prop} [hl : l.is_countably_generated] :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l (p n) ↔\n      ∀ x : ℕ → ι,\n        tendsto x at_top l →\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n            (p (x n)) :=\n  by\n  have :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l (p n) ↔\n      ¬«expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l ¬p n :=\n    by\n    rw [not_frequently]\n    simp_rw [not_not]\n  rw [this, frequently_iff_seq_frequently]\n  push_neg\n  simp_rw [not_frequently, not_not]\n#align eventually_iff_seq_eventually eventually_iff_seq_eventually\n\n",
 "eventually_gt_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.eventually_gt_at_top [preorder β] [NoMaxOrder β] {f : α → β} {l : filter α} (hf : tendsto f l at_top)\n    (c : β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (c < f x) :=\n  hf.eventually (eventually_gt_at_top c)\n#align tendsto.eventually_gt_at_top tendsto.eventually_gt_at_top\n\n",
 "eventually_ge_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.eventually_ge_at_top [preorder β] {f : α → β} {l : filter α} (hf : tendsto f l at_top) (c : β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (c ≤ f x) :=\n  hf.eventually (eventually_ge_at_top c)\n#align tendsto.eventually_ge_at_top tendsto.eventually_ge_at_top\n\n",
 "eventually_at_top_prod_self'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_at_top_prod_self' [SemilatticeSup α] [nonempty α] {p : α × α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (p x) ↔\n      ∃ a, ∀ k ≥ a, ∀ l ≥ a, p (k, l) :=\n  by\n  rw [filter.eventually_at_top_prod_self]\n  apply exists_congr\n  tauto\n#align eventually_at_top_prod_self' eventually_at_top_prod_self'\n\n",
 "eventually_at_top_prod_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_at_top_prod_self [SemilatticeSup α] [nonempty α] {p : α × α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (p x) ↔\n      ∃ a, ∀ k l, a ≤ k → a ≤ l → p (k, l) :=\n  by simp [← prod_at_top_at_top_eq, at_top_basis.prod_self.eventually_iff]\n#align eventually_at_top_prod_self eventually_at_top_prod_self\n\n",
 "eventually_at_top_curry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_at_top_curry [SemilatticeSup α] [SemilatticeSup β] {p : α × β → Prop}\n    (hp :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        filter.at_top (p x)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      («expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (p (k, l))) :=\n  by\n  rw [← prod_at_top_at_top_eq] at hp\n  exact hp.curry\n#align eventually_at_top_curry eventually_at_top_curry\n\n",
 "eventually_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_at_top [SemilatticeSup α] [nonempty α] {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (p x) ↔\n      ∃ a, ∀ b ≥ a, p b :=\n  mem_at_top_sets\n#align eventually_at_top eventually_at_top\n\n",
 "eventually_at_bot_prod_self'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_at_bot_prod_self' [SemilatticeInf α] [nonempty α] {p : α × α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_bot\n        (p x) ↔\n      ∃ a, ∀ k ≤ a, ∀ l ≤ a, p (k, l) :=\n  by\n  rw [filter.eventually_at_bot_prod_self]\n  apply exists_congr\n  tauto\n#align eventually_at_bot_prod_self' eventually_at_bot_prod_self'\n\n",
 "eventually_at_bot_prod_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_at_bot_prod_self [SemilatticeInf α] [nonempty α] {p : α × α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_bot\n        (p x) ↔\n      ∃ a, ∀ k l, k ≤ a → l ≤ a → p (k, l) :=\n  by simp [← prod_at_bot_at_bot_eq, at_bot_basis.prod_self.eventually_iff]\n#align eventually_at_bot_prod_self eventually_at_bot_prod_self\n\n",
 "eventually_at_bot_curry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_at_bot_curry [SemilatticeInf α] [SemilatticeInf β] {p : α × β → Prop}\n    (hp :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        filter.at_bot (p x)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_bot\n      («expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_bot\n        (p (k, l))) :=\n  @eventually_at_top_curry («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ _ hp\n#align eventually_at_bot_curry eventually_at_bot_curry\n\n",
 "eventually_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_at_bot [SemilatticeInf α] [nonempty α] {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_bot\n        (p x) ↔\n      ∃ a, ∀ b ≤ a, p b :=\n  mem_at_bot_sets\n#align eventually_at_bot eventually_at_bot\n\n",
 "disjoint_pure_at_top":
 "theorem disjoint_pure_at_top [preorder α] [NoMaxOrder α] (x : α) : Disjoint (pure x) at_top :=\n  Disjoint.symm ((disjoint_at_top_principal_Iic x).mono_right <| le_principal_iff.2 le_rfl)\n#align disjoint_pure_at_top disjoint_pure_at_top\n\n",
 "disjoint_pure_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem disjoint_pure_at_bot [preorder α] [NoMinOrder α] (x : α) : Disjoint (pure x) at_bot :=\n  @disjoint_pure_at_top («expr ᵒᵈ» α) _ _ _\n#align disjoint_pure_at_bot disjoint_pure_at_bot\n\n",
 "disjoint_at_top_principal_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem disjoint_at_top_principal_Iio [preorder α] (x : α) : Disjoint at_top ((filter.principal) (Iio x)) :=\n  @disjoint_at_bot_principal_Ioi («expr ᵒᵈ» α) _ _\n#align disjoint_at_top_principal_Iio disjoint_at_top_principal_Iio\n\n",
 "disjoint_at_top_principal_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem disjoint_at_top_principal_Iic [preorder α] [NoMaxOrder α] (x : α) :\n    Disjoint at_top ((filter.principal) (Iic x)) :=\n  disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl).symm (Ioi_mem_at_top x) (mem_principal_self _)\n#align disjoint_at_top_principal_Iic disjoint_at_top_principal_Iic\n\n",
 "disjoint_at_top_at_bot":
 "theorem disjoint_at_top_at_bot [partial_order α] [nontrivial α] : Disjoint (at_top : filter α) at_bot :=\n  disjoint_at_bot_at_top.symm\n#align disjoint_at_top_at_bot disjoint_at_top_at_bot\n\n",
 "disjoint_at_bot_principal_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem disjoint_at_bot_principal_Ioi [preorder α] (x : α) : Disjoint at_bot ((filter.principal) (Ioi x)) :=\n  disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl) (Iic_mem_at_bot x) (mem_principal_self _)\n#align disjoint_at_bot_principal_Ioi disjoint_at_bot_principal_Ioi\n\n",
 "disjoint_at_bot_principal_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem disjoint_at_bot_principal_Ici [preorder α] [NoMinOrder α] (x : α) :\n    Disjoint at_bot ((filter.principal) (Ici x)) :=\n  @disjoint_at_top_principal_Iic («expr ᵒᵈ» α) _ _ _\n#align disjoint_at_bot_principal_Ici disjoint_at_bot_principal_Ici\n\n",
 "disjoint_at_bot_at_top":
 "theorem disjoint_at_bot_at_top [partial_order α] [nontrivial α] : Disjoint (at_bot : filter α) at_top :=\n  by\n  rcases exists_pair_ne α with ⟨x, y, hne⟩\n  by_cases hle : x ≤ y\n  · refine' disjoint_of_disjoint_of_mem _ (Iic_mem_at_bot x) (Ici_mem_at_top y)\n    exact Iic_disjoint_Ici.2 (hle.lt_of_ne hne).not_le\n  · refine' disjoint_of_disjoint_of_mem _ (Iic_mem_at_bot y) (Ici_mem_at_top x)\n    exact Iic_disjoint_Ici.2 hle\n#align disjoint_at_bot_at_top disjoint_at_bot_at_top\n\n",
 "const_mul_at_top":
 "/-- If a function tends to infinity along a filter, then this function multiplied by a positive\nconstant (on the left) also tends to infinity. For a version working in `ℕ` or `ℤ`, use\n`filter.tendsto.const_mul_at_top'` instead. -/\ntheorem tendsto.const_mul_at_top (hr : 0 < r) (hf : tendsto f l at_top) : tendsto (fun x => r * f x) l at_top :=\n  (tendsto_const_mul_at_top_of_pos hr).2 hf\n#align tendsto.const_mul_at_top tendsto.const_mul_at_top\n\n",
 "const_mul_at_bot":
 "/-- If a function tends to negative infinity along a filter, then this function multiplied by\na positive constant (on the left) also tends to negative infinity. -/\ntheorem tendsto.const_mul_at_bot (hr : 0 < r) (hf : tendsto f l at_bot) : tendsto (fun x => r * f x) l at_bot :=\n  (tendsto_const_mul_at_bot_of_pos hr).2 hf\n#align tendsto.const_mul_at_bot tendsto.const_mul_at_bot\n\n",
 "comp_strict_mono":
 "theorem has_antitone_basis.comp_strict_mono {l : filter α} {s : ℕ → set α} (hs : l.has_antitone_basis s) {φ : ℕ → ℕ}\n    (hφ : strict_mono φ) : l.has_antitone_basis (s ∘ φ) :=\n  hs.comp_mono hφ.monotone hφ.tendsto_at_top\n#align has_antitone_basis.comp_strict_mono has_antitone_basis.comp_strict_mono\n\n",
 "comp_mono":
 "theorem has_antitone_basis.comp_mono [SemilatticeSup ι] [nonempty ι] [preorder ι'] {l : filter α} {s : ι' → set α}\n    (hs : l.has_antitone_basis s) {φ : ι → ι'} (φ_mono : monotone φ) (hφ : tendsto φ at_top at_top) :\n    l.has_antitone_basis (s ∘ φ) :=\n  ⟨hs.to_has_basis.to_has_basis\n      (fun n hn => (hφ.eventually (eventually_ge_at_top n)).exists.imp fun m hm => ⟨trivial, hs.antitone hm⟩)\n      fun n hn => ⟨φ n, trivial, Subset.rfl⟩,\n    hs.antitone.comp_monotone φ_mono⟩\n#align has_antitone_basis.comp_mono has_antitone_basis.comp_mono\n\n",
 "comap_neg_at_top":
 "@[simp]\ntheorem comap_neg_at_top : comap (has_neg.neg : β → β) at_top = at_bot :=\n  (OrderIso.neg β).comap_at_bot\n#align comap_neg_at_top comap_neg_at_top\n\n",
 "comap_neg_at_bot":
 "@[simp]\ntheorem comap_neg_at_bot : comap (has_neg.neg : β → β) at_bot = at_top :=\n  (OrderIso.neg β).comap_at_top\n#align comap_neg_at_bot comap_neg_at_bot\n\n",
 "comap_embedding_at_top":
 "theorem comap_embedding_at_top [preorder β] [preorder γ] {e : β → γ} (hm : ∀ b₁ b₂, e b₁ ≤ e b₂ ↔ b₁ ≤ b₂)\n    (hu : ∀ c, ∃ b, c ≤ e b) : comap e at_top = at_top :=\n  le_antisymm (le_infᵢ fun b => le_principal_iff.2 <| mem_comap.2 ⟨Ici (e b), mem_at_top _, fun x => (hm _ _).1⟩)\n    (tendsto_at_top_at_top_of_monotone (fun _ _ => (hm _ _).2) hu).le_comap\n#align comap_embedding_at_top comap_embedding_at_top\n\n",
 "comap_embedding_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem comap_embedding_at_bot [preorder β] [preorder γ] {e : β → γ} (hm : ∀ b₁ b₂, e b₁ ≤ e b₂ ↔ b₁ ≤ b₂)\n    (hu : ∀ c, ∃ b, e b ≤ c) : comap e at_bot = at_bot :=\n  @comap_embedding_at_top («expr ᵒᵈ» β) («expr ᵒᵈ» γ) _ _ e (function.swap hm) hu\n#align comap_embedding_at_bot comap_embedding_at_bot\n\n",
 "comap_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n@[simp]\ntheorem comap_at_top (e : «expr ≃o » α β) : comap e at_top = at_top := by simp [at_top, ← e.surjective.infi_comp]\n#align comap_at_top comap_at_top\n\n",
 "comap_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n@[simp]\ntheorem comap_at_bot (e : «expr ≃o » α β) : comap e at_bot = at_bot :=\n  e.dual.comap_at_top\n#align comap_at_bot comap_at_bot\n\n",
 "comap_abs_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem comap_abs_at_top : comap (abs : α → α) at_top = «expr ⊔ » at_bot at_top :=\n  by\n  refine'\n    le_antisymm (((at_top_basis.comap _).le_basis_iff (at_bot_basis.sup at_top_basis)).2 _)\n      (sup_le tendsto_abs_at_bot_at_top.le_comap tendsto_abs_at_top_at_top.le_comap)\n  rintro ⟨a, b⟩ -\n  refine' ⟨max (-a) b, trivial, fun x hx => _⟩\n  rw [mem_preimage, mem_Ici, le_abs', max_le_iff, ← min_neg_neg, le_min_iff, neg_neg] at hx\n  exact hx.imp And.left And.right\n#align comap_abs_at_top comap_abs_at_top\n\n",
 "at_top_of_mul_const":
 "theorem tendsto.at_top_of_mul_const {c : α} (hc : 0 < c) (hf : tendsto (fun x => f x * c) l at_top) :\n    tendsto f l at_top :=\n  tendsto_at_top.2 fun b => (tendsto_at_top.1 hf (b * c)).mono fun x hx => le_of_mul_le_mul_right hx hc\n#align tendsto.at_top_of_mul_const tendsto.at_top_of_mul_const\n\n",
 "at_top_of_const_mul":
 "theorem tendsto.at_top_of_const_mul {c : α} (hc : 0 < c) (hf : tendsto (fun x => c * f x) l at_top) :\n    tendsto f l at_top :=\n  tendsto_at_top.2 fun b => (tendsto_at_top.1 hf (c * b)).mono fun x hx => le_of_mul_le_mul_left hx hc\n#align tendsto.at_top_of_const_mul tendsto.at_top_of_const_mul\n\n",
 "at_top_ne_bot":
 "@[instance]\ntheorem at_top_ne_bot [nonempty α] [SemilatticeSup α] : ne_bot (at_top : filter α) :=\n  at_top_basis.ne_bot_iff.2 fun a _ => nonempty_Ici\n#align at_top_ne_bot at_top_ne_bot\n\n",
 "at_top_mul_neg_const":
 "/-- If a function tends to infinity along a filter, then this function multiplied by a negative\nconstant (on the right) tends to negative infinity. -/\ntheorem tendsto.at_top_mul_neg_const (hr : r < 0) (hf : tendsto f l at_top) : tendsto (fun x => f x * r) l at_bot :=\n  (tendsto_mul_const_at_bot_of_neg hr).2 hf\n#align tendsto.at_top_mul_neg_const tendsto.at_top_mul_neg_const\n\n",
 "at_top_mul_const":
 "/-- If a function tends to infinity along a filter, then this function multiplied by a positive\nconstant (on the right) also tends to infinity. For a version working in `ℕ` or `ℤ`, use\n`filter.tendsto.at_top_mul_const'` instead. -/\ntheorem tendsto.at_top_mul_const (hr : 0 < r) (hf : tendsto f l at_top) : tendsto (fun x => f x * r) l at_top :=\n  (tendsto_mul_const_at_top_of_pos hr).2 hf\n#align tendsto.at_top_mul_const tendsto.at_top_mul_const\n\n",
 "at_top_mul_at_top":
 "theorem tendsto.at_top_mul_at_top (hf : tendsto f l at_top) (hg : tendsto g l at_top) :\n    tendsto (fun x => f x * g x) l at_top :=\n  by\n  refine' tendsto_at_top_mono' _ _ hg\n  filter_upwards [hg.eventually (eventually_ge_at_top 0),\n    hf.eventually (eventually_ge_at_top 1)] with _ using le_mul_of_one_le_left\n#align tendsto.at_top_mul_at_top tendsto.at_top_mul_at_top\n\n",
 "at_top_mul_at_bot":
 "theorem tendsto.at_top_mul_at_bot (hf : tendsto f l at_top) (hg : tendsto g l at_bot) :\n    tendsto (fun x => f x * g x) l at_bot :=\n  by\n  have := hf.at_top_mul_at_top <| tendsto_neg_at_bot_at_top.comp hg\n  simpa only [(· ∘ ·), neg_mul_eq_mul_neg, neg_neg] using tendsto_neg_at_top_at_bot.comp this\n#align tendsto.at_top_mul_at_bot tendsto.at_top_mul_at_bot\n\n",
 "at_top_finset_eq_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem at_top_finset_eq_infi :\n    (at_top : filter <| Finset α) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (Ici {x})) :=\n  by\n  refine' le_antisymm (le_infᵢ fun i => le_principal_iff.2 <| mem_at_top {i}) _\n  refine' le_infᵢ fun s => le_principal_iff.2 <| mem_infi_of_Inter s.finite_to_set (fun i => mem_principal_self _) _\n  simp only [subset_def, mem_Inter, SetCoe.forall, mem_Ici, Finset.le_iff_subset, Finset.mem_singleton,\n    Finset.subset_iff, forall_eq]\n  dsimp\n  exact fun t => id\n#align at_top_finset_eq_infi at_top_finset_eq_infi\n\n",
 "at_top_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[nontriviality]\ntheorem subsingleton.at_top_eq (α) [subsingleton α] [preorder α] : (at_top : filter α) = «expr⊤» :=\n  by\n  refine' top_unique fun s hs x => _\n  letI : unique α := ⟨⟨x⟩, fun y => subsingleton.elim y x⟩\n  rw [at_top, cinfᵢ_unique, unique.default_eq x, mem_principal] at hs\n  exact hs left_mem_Ici\n#align subsingleton.at_top_eq subsingleton.at_top_eq\n\n",
 "at_top_div_const":
 "/-- If a function tends to infinity along a filter, then this function divided by a positive\nconstant also tends to infinity. -/\ntheorem tendsto.at_top_div_const (hr : 0 < r) (hf : tendsto f l at_top) : tendsto (fun x => f x / r) l at_top := by\n  simpa only [div_eq_mul_inv] using hf.at_top_mul_const (inv_pos.2 hr)\n#align tendsto.at_top_div_const tendsto.at_top_div_const\n\n",
 "at_top_countable_basis":
 "theorem at_top_countable_basis [nonempty α] [SemilatticeSup α] [countable α] :\n    has_countable_basis (at_top : filter α) (fun _ => true) Ici :=\n  { at_top_basis with countable := to_countable _ }\n#align at_top_countable_basis at_top_countable_basis\n\n",
 "at_top_basis_Ioi":
 "theorem at_top_basis_Ioi [nonempty α] [SemilatticeSup α] [NoMaxOrder α] : (@at_top α _).has_basis (fun _ => true) Ioi :=\n  at_top_basis.to_has_basis (fun a ha => ⟨a, ha, Ioi_subset_Ici_self⟩) fun a ha =>\n    (exists_gt a).imp fun b hb => ⟨ha, Ici_subset_Ioi.2 hb⟩\n#align at_top_basis_Ioi at_top_basis_Ioi\n\n",
 "at_top_basis'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem at_top_basis' [SemilatticeSup α] (a : α) : (@at_top α _).has_basis (fun x => a ≤ x) Ici :=\n  ⟨fun t =>\n    (@at_top_basis α ⟨a⟩ _).mem_iff.trans\n      ⟨fun ⟨x, _, hx⟩ => ⟨«expr ⊔ » x a, le_sup_right, fun y hy => hx (le_trans le_sup_left hy)⟩, fun ⟨x, _, hx⟩ =>\n        ⟨x, trivial, hx⟩⟩⟩\n#align at_top_basis' at_top_basis'\n\n",
 "at_top_basis":
 "theorem at_top_basis [nonempty α] [SemilatticeSup α] : (@at_top α _).has_basis (fun _ => true) Ici :=\n  has_basis_infi_principal (directed_of_sup fun a b => Ici_subset_Ici.2)\n#align at_top_basis at_top_basis\n\n",
 "at_top_Ioi_eq":
 "/-- The `at_top` filter for an open interval `Ioi a` comes from the `at_top` filter in the ambient\norder. -/\ntheorem at_top_Ioi_eq [SemilatticeSup α] (a : α) : at_top = comap (coe : Ioi a → α) at_top :=\n  by\n  nontriviality\n  rcases nontrivial_iff_nonempty.1 ‹_› with ⟨b, hb⟩\n  rw [← map_coe_at_top_of_Ici_subset (Ici_subset_Ioi.2 hb), comap_map subtype.coe_injective]\n#align at_top_Ioi_eq at_top_Ioi_eq\n\n",
 "at_top_Ici_eq":
 "/-- The `at_top` filter for an open interval `Ici a` comes from the `at_top` filter in the ambient\norder. -/\ntheorem at_top_Ici_eq [SemilatticeSup α] (a : α) : at_top = comap (coe : Ici a → α) at_top := by\n  rw [← map_coe_Ici_at_top a, comap_map subtype.coe_injective]\n#align at_top_Ici_eq at_top_Ici_eq\n\n",
 "at_bot_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[instance]\ntheorem at_bot_ne_bot [nonempty α] [SemilatticeInf α] : ne_bot (at_bot : filter α) :=\n  @at_top_ne_bot («expr ᵒᵈ» α) _ _\n#align at_bot_ne_bot at_bot_ne_bot\n\n",
 "at_bot_mul_neg_const":
 "/-- If a function tends to negative infinity along a filter, then this function multiplied by\na negative constant (on the right) tends to positive infinity. -/\ntheorem tendsto.at_bot_mul_neg_const (hr : r < 0) (hf : tendsto f l at_bot) : tendsto (fun x => f x * r) l at_top :=\n  (tendsto_mul_const_at_top_of_neg hr).2 hf\n#align tendsto.at_bot_mul_neg_const tendsto.at_bot_mul_neg_const\n\n",
 "at_bot_mul_const":
 "/-- If a function tends to negative infinity along a filter, then this function multiplied by\na positive constant (on the right) also tends to negative infinity. -/\ntheorem tendsto.at_bot_mul_const (hr : 0 < r) (hf : tendsto f l at_bot) : tendsto (fun x => f x * r) l at_bot :=\n  (tendsto_mul_const_at_bot_of_pos hr).2 hf\n#align tendsto.at_bot_mul_const tendsto.at_bot_mul_const\n\n",
 "at_bot_mul_at_top":
 "theorem tendsto.at_bot_mul_at_top (hf : tendsto f l at_bot) (hg : tendsto g l at_top) :\n    tendsto (fun x => f x * g x) l at_bot :=\n  by\n  have : tendsto (fun x => -f x * g x) l at_top := (tendsto_neg_at_bot_at_top.comp hf).at_top_mul_at_top hg\n  simpa only [(· ∘ ·), neg_mul_eq_neg_mul, neg_neg] using tendsto_neg_at_top_at_bot.comp this\n#align tendsto.at_bot_mul_at_top tendsto.at_bot_mul_at_top\n\n",
 "at_bot_mul_at_bot":
 "theorem tendsto.at_bot_mul_at_bot (hf : tendsto f l at_bot) (hg : tendsto g l at_bot) :\n    tendsto (fun x => f x * g x) l at_top :=\n  by\n  have : tendsto (fun x => -f x * -g x) l at_top :=\n    (tendsto_neg_at_bot_at_top.comp hf).at_top_mul_at_top (tendsto_neg_at_bot_at_top.comp hg)\n  simpa only [neg_mul_neg] using this\n#align tendsto.at_bot_mul_at_bot tendsto.at_bot_mul_at_bot\n\n",
 "at_bot_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[nontriviality]\ntheorem subsingleton.at_bot_eq (α) [subsingleton α] [preorder α] : (at_bot : filter α) = «expr⊤» :=\n  @subsingleton.at_top_eq («expr ᵒᵈ» α) _ _\n#align subsingleton.at_bot_eq subsingleton.at_bot_eq\n\n",
 "at_bot_div_const":
 "/-- If a function tends to negative infinity along a filter, then this function divided by\na positive constant also tends to negative infinity. -/\ntheorem tendsto.at_bot_div_const (hr : 0 < r) (hf : tendsto f l at_bot) : tendsto (fun x => f x / r) l at_bot := by\n  simpa only [div_eq_mul_inv] using hf.at_bot_mul_const (inv_pos.2 hr)\n#align tendsto.at_bot_div_const tendsto.at_bot_div_const\n\n",
 "at_bot_countable_basis":
 "theorem at_bot_countable_basis [nonempty α] [SemilatticeInf α] [countable α] :\n    has_countable_basis (at_bot : filter α) (fun _ => true) Iic :=\n  { at_bot_basis with countable := to_countable _ }\n#align at_bot_countable_basis at_bot_countable_basis\n\n",
 "at_bot_basis'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem at_bot_basis' [SemilatticeInf α] (a : α) : (@at_bot α _).has_basis (fun x => x ≤ a) Iic :=\n  @at_top_basis' («expr ᵒᵈ» α) _ _\n#align at_bot_basis' at_bot_basis'\n\n",
 "at_bot_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem at_bot_basis [nonempty α] [SemilatticeInf α] : (@at_bot α _).has_basis (fun _ => true) Iic :=\n  @at_top_basis («expr ᵒᵈ» α) _ _\n#align at_bot_basis at_bot_basis\n\n",
 "at_bot_Iio_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient\norder. -/\ntheorem at_bot_Iio_eq [SemilatticeInf α] (a : α) : at_bot = comap (coe : Iio a → α) at_bot :=\n  @at_top_Ioi_eq («expr ᵒᵈ» α) _ _\n#align at_bot_Iio_eq at_bot_Iio_eq\n\n",
 "at_bot_Iic_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient\norder. -/\ntheorem at_bot_Iic_eq [SemilatticeInf α] (a : α) : at_bot = comap (coe : Iic a → α) at_bot :=\n  @at_top_Ici_eq («expr ᵒᵈ» α) _ _\n#align at_bot_Iic_eq at_bot_Iic_eq\n\n",
 "Ioi_mem_at_top":
 "theorem Ioi_mem_at_top [preorder α] [NoMaxOrder α] (x : α) : Ioi x ∈ (at_top : filter α) :=\n  let ⟨z, hz⟩ := exists_gt x\n  mem_of_superset (mem_at_top z) fun y h => lt_of_lt_of_le hz h\n#align Ioi_mem_at_top Ioi_mem_at_top\n\n",
 "Iio_mem_at_bot":
 "theorem Iio_mem_at_bot [preorder α] [NoMinOrder α] (x : α) : Iio x ∈ (at_bot : filter α) :=\n  let ⟨z, hz⟩ := exists_lt x\n  mem_of_superset (mem_at_bot z) fun y h => lt_of_le_of_lt h hz\n#align Iio_mem_at_bot Iio_mem_at_bot\n\n",
 "Iic_mem_at_bot":
 "theorem Iic_mem_at_bot [preorder α] (a : α) : Iic a ∈ (at_bot : filter α) :=\n  mem_at_bot a\n#align Iic_mem_at_bot Iic_mem_at_bot\n\n",
 "Ici_mem_at_top":
 "theorem Ici_mem_at_top [preorder α] (a : α) : Ici a ∈ (at_top : filter α) :=\n  mem_at_top a\n#align Ici_mem_at_top Ici_mem_at_top\n\n"}