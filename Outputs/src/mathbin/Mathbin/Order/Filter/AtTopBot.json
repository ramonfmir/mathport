{"zero_pow_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem zero_pow_eventually_eq [MonoidWithZero α] : «expr =ᶠ[ ] » (fun n : ℕ => (0 : α) ^ n) atTop fun n => 0 :=\n  eventually_atTop.2 ⟨1, fun n hn => zero_pow (zero_lt_one.trans_le hn)⟩\n#align zero_pow_eventually_eq zero_pow_eventually_eq\n\n",
 "unbounded_of_tendsto_at_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem unbounded_of_tendsto_at_top' [Nonempty α] [SemilatticeInf α] [preorder β] [NoMaxOrder β] {f : α → β}\n    (h : Tendsto f atBot atTop) : ¬BddAbove (range f) :=\n  @unbounded_of_tendsto_atTop («expr ᵒᵈ» α) _ _ _ _ _ _ h\n#align unbounded_of_tendsto_at_top' unbounded_of_tendsto_at_top'\n\n",
 "unbounded_of_tendsto_at_top":
 "theorem unbounded_of_tendsto_at_top [Nonempty α] [SemilatticeSup α] [preorder β] [NoMaxOrder β] {f : α → β}\n    (h : Tendsto f atTop atTop) : ¬BddAbove (range f) :=\n  by\n  rintro ⟨M, hM⟩\n  cases' mem_at_top_sets.mp (h <| Ioi_mem_at_top M) with a ha\n  apply lt_irrefl M\n  calc\n    M < f a := ha a le_rfl\n    _ ≤ M := hM (Set.mem_range_self a)\n    \n#align unbounded_of_tendsto_at_top unbounded_of_tendsto_at_top\n\n",
 "unbounded_of_tendsto_at_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem unbounded_of_tendsto_at_bot' [Nonempty α] [SemilatticeInf α] [preorder β] [NoMinOrder β] {f : α → β}\n    (h : Tendsto f atBot atBot) : ¬BddBelow (range f) :=\n  @unbounded_of_tendsto_atTop («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ _ _ _ h\n#align unbounded_of_tendsto_at_bot' unbounded_of_tendsto_at_bot'\n\n",
 "unbounded_of_tendsto_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem unbounded_of_tendsto_at_bot [Nonempty α] [SemilatticeSup α] [preorder β] [NoMinOrder β] {f : α → β}\n    (h : Tendsto f atTop atBot) : ¬BddBelow (range f) :=\n  @unbounded_of_tendsto_atTop _ («expr ᵒᵈ» β) _ _ _ _ _ h\n#align unbounded_of_tendsto_at_bot unbounded_of_tendsto_at_bot\n\n",
 "tendsto_sub_at_top_nat":
 "theorem tendsto_sub_at_top_nat (k : ℕ) : Tendsto (fun a => a - k) atTop atTop :=\n  le_of_eq (map_sub_atTop_eq_nat k)\n#align tendsto_sub_at_top_nat tendsto_sub_at_top_nat\n\n",
 "tendsto_pow_at_top_iff":
 "@[simp]\ntheorem tendsto_pow_at_top_iff {n : ℕ} : Tendsto (fun x : α => x ^ n) atTop atTop ↔ n ≠ 0 :=\n  ⟨fun h hn => by simpa only [hn, pow_zero, not_tendsto_const_at_top] using h, tendsto_pow_atTop⟩\n#align tendsto_pow_at_top_iff tendsto_pow_at_top_iff\n\n",
 "tendsto_pow_at_top":
 "/-- The monomial function `x^n` tends to `+∞` at `+∞` for any positive natural `n`.\nA version for positive real powers exists as `tendsto_rpow_at_top`. -/\ntheorem tendsto_pow_at_top {n : ℕ} (hn : n ≠ 0) : Tendsto (fun x : α => x ^ n) atTop atTop :=\n  tendsto_atTop_mono' _ ((eventually_ge_atTop 1).mono fun x hx => le_self_pow hx hn) tendsto_id\n#align tendsto_pow_at_top tendsto_pow_at_top\n\n",
 "tendsto_of_subseq_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- A sequence converges if every subsequence has a convergent subsequence. -/\ntheorem tendsto_of_subseq_tendsto {α ι : Type _} {x : ι → α} {f : Filter α} {l : Filter ι} [l.is_countably_generated]\n    (hxy : ∀ ns : ℕ → ι, Tendsto ns atTop l → ∃ ms : ℕ → ℕ, Tendsto (fun n => x (ns <| ms n)) atTop f) :\n    Tendsto x l f := by\n  by_contra h\n  obtain ⟨s, hs, hfreq⟩ :\n    ∃ s ∈ f,\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l\n        (x n ∉ s) :=\n    by rwa [not_tendsto_iff_exists_frequently_nmem] at h\n  obtain ⟨y, hy_tendsto, hy_freq⟩ := exists_seq_forall_of_frequently hfreq\n  specialize hxy y hy_tendsto\n  obtain ⟨ms, hms_tendsto⟩ := hxy\n  specialize hms_tendsto hs\n  rw [mem_map] at hms_tendsto\n  have hms_freq : ∀ n : ℕ, x (y (ms n)) ∉ s := fun n => hy_freq (ms n)\n  have h_empty : «expr ⁻¹' » (fun n : ℕ => x (y (ms n))) s = ∅ :=\n    by\n    ext1 n\n    simp only [Set.mem_preimage, Set.mem_empty_iff_false, iff_false_iff]\n    exact hms_freq n\n  rw [h_empty] at hms_tendsto\n  exact empty_not_mem at_top hms_tendsto\n#align tendsto_of_subseq_tendsto tendsto_of_subseq_tendsto\n\n",
 "tendsto_of_seq_tendsto":
 "theorem tendsto_of_seq_tendsto {f : α → β} {k : Filter α} {l : Filter β} [k.is_countably_generated] :\n    (∀ x : ℕ → α, Tendsto x atTop k → Tendsto (f ∘ x) atTop l) → Tendsto f k l :=\n  tendsto_iff_seq_tendsto.2\n#align tendsto_of_seq_tendsto tendsto_of_seq_tendsto\n\n",
 "tendsto_neg_const_mul_pow_at_top":
 "theorem tendsto_neg_const_mul_pow_at_top {c : α} {n : ℕ} (hn : n ≠ 0) (hc : c < 0) :\n    Tendsto (fun x => c * x ^ n) atTop atBot :=\n  Tendsto.neg_const_mul_atTop hc (tendsto_pow_atTop hn)\n#align tendsto_neg_const_mul_pow_at_top tendsto_neg_const_mul_pow_at_top\n\n",
 "tendsto_neg_at_top_iff":
 "@[simp]\ntheorem tendsto_neg_at_top_iff : Tendsto (fun x => -f x) l atTop ↔ Tendsto f l atBot :=\n  (OrderIso.neg β).tendsto_at_bot_iff\n#align tendsto_neg_at_top_iff tendsto_neg_at_top_iff\n\n",
 "tendsto_neg_at_top_at_bot":
 "theorem tendsto_neg_at_top_at_bot : Tendsto (has_neg.neg : β → β) atTop atBot :=\n  (OrderIso.neg β).tendsto_at_top\n#align tendsto_neg_at_top_at_bot tendsto_neg_at_top_at_bot\n\n",
 "tendsto_neg_at_bot_iff":
 "@[simp]\ntheorem tendsto_neg_at_bot_iff : Tendsto (fun x => -f x) l atBot ↔ Tendsto f l atTop :=\n  (OrderIso.neg β).tendsto_at_top_iff\n#align tendsto_neg_at_bot_iff tendsto_neg_at_bot_iff\n\n",
 "tendsto_neg_at_bot_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_neg_at_bot_at_top : Tendsto (has_neg.neg : β → β) atBot atTop :=\n  @tendsto_neg_atTop_atBot («expr ᵒᵈ» β) _\n#align tendsto_neg_at_bot_at_top tendsto_neg_at_bot_at_top\n\n",
 "tendsto_mul_self_at_top":
 "theorem tendsto_mul_self_at_top : Tendsto (fun x : α => x * x) atTop atTop :=\n  tendsto_id.at_top_mul_at_top tendsto_id\n#align tendsto_mul_self_at_top tendsto_mul_self_at_top\n\n",
 "tendsto_mul_const_at_top_of_pos":
 "/-- If `r` is a positive constant, then `λ x, f x * r` tends to infinity along a filter if and only\nif `f` tends to infinity along the same filter. -/\ntheorem tendsto_mul_const_at_top_of_pos (hr : 0 < r) : Tendsto (fun x => f x * r) l atTop ↔ Tendsto f l atTop := by\n  simpa only [mul_comm] using tendsto_const_mul_at_top_of_pos hr\n#align tendsto_mul_const_at_top_of_pos tendsto_mul_const_at_top_of_pos\n\n",
 "tendsto_mul_const_at_top_of_neg":
 "/-- If `r` is a negative constant, then `λ x, f x * r` tends to infinity along a filter if and only\nif `f` tends to negative infinity along the same filter. -/\ntheorem tendsto_mul_const_at_top_of_neg (hr : r < 0) : Tendsto (fun x => f x * r) l atTop ↔ Tendsto f l atBot := by\n  simpa only [mul_comm] using tendsto_const_mul_at_top_of_neg hr\n#align tendsto_mul_const_at_top_of_neg tendsto_mul_const_at_top_of_neg\n\n",
 "tendsto_mul_const_at_top_iff_pos":
 "/-- If `f` tends to infinity along a nontrivial filter `l`, then `λ x, f x * r` tends to infinity\nif and only if `0 < r. `-/\ntheorem tendsto_mul_const_at_top_iff_pos [NeBot l] (h : Tendsto f l atTop) :\n    Tendsto (fun x => f x * r) l atTop ↔ 0 < r := by simp only [mul_comm _ r, tendsto_const_mul_at_top_iff_pos h]\n#align tendsto_mul_const_at_top_iff_pos tendsto_mul_const_at_top_iff_pos\n\n",
 "tendsto_mul_const_at_top_iff_neg":
 "/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `λ x, f x * r` tends to\ninfinity if and only if `r < 0. `-/\ntheorem tendsto_mul_const_at_top_iff_neg [NeBot l] (h : Tendsto f l atBot) :\n    Tendsto (fun x => f x * r) l atTop ↔ r < 0 := by simp only [mul_comm _ r, tendsto_const_mul_at_top_iff_neg h]\n#align tendsto_mul_const_at_top_iff_neg tendsto_mul_const_at_top_iff_neg\n\n",
 "tendsto_mul_const_at_top_iff":
 "/-- The function `λ x, f x * r` tends to infinity along a nontrivial filter if and only if `r > 0`\nand `f` tends to infinity or `r < 0` and `f` tends to negative infinity. -/\ntheorem tendsto_mul_const_at_top_iff [NeBot l] :\n    Tendsto (fun x => f x * r) l atTop ↔ 0 < r ∧ Tendsto f l atTop ∨ r < 0 ∧ Tendsto f l atBot := by\n  simp only [mul_comm _ r, tendsto_const_mul_at_top_iff]\n#align tendsto_mul_const_at_top_iff tendsto_mul_const_at_top_iff\n\n",
 "tendsto_mul_const_at_bot_of_pos":
 "/-- If `r` is a positive constant, then `λ x, f x * r` tends to negative infinity along a filter if\nand only if `f` tends to negative infinity along the same filter. -/\ntheorem tendsto_mul_const_at_bot_of_pos (hr : 0 < r) : Tendsto (fun x => f x * r) l atBot ↔ Tendsto f l atBot := by\n  simpa only [mul_comm] using tendsto_const_mul_at_bot_of_pos hr\n#align tendsto_mul_const_at_bot_of_pos tendsto_mul_const_at_bot_of_pos\n\n",
 "tendsto_mul_const_at_bot_of_neg":
 "/-- If `r` is a negative constant, then `λ x, f x * r` tends to negative infinity along a filter if\nand only if `f` tends to infinity along the same filter. -/\ntheorem tendsto_mul_const_at_bot_of_neg (hr : r < 0) : Tendsto (fun x => f x * r) l atBot ↔ Tendsto f l atTop := by\n  simpa only [mul_comm] using tendsto_const_mul_at_bot_of_neg hr\n#align tendsto_mul_const_at_bot_of_neg tendsto_mul_const_at_bot_of_neg\n\n",
 "tendsto_mul_const_at_bot_iff_pos":
 "/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `λ x, f x * r` tends to\nnegative infinity if and only if `0 < r. `-/\ntheorem tendsto_mul_const_at_bot_iff_pos [NeBot l] (h : Tendsto f l atBot) :\n    Tendsto (fun x => f x * r) l atBot ↔ 0 < r := by simp only [mul_comm _ r, tendsto_const_mul_at_bot_iff_pos h]\n#align tendsto_mul_const_at_bot_iff_pos tendsto_mul_const_at_bot_iff_pos\n\n",
 "tendsto_mul_const_at_bot_iff_neg":
 "/-- If `f` tends to infinity along a nontrivial filter `l`, then `λ x, f x * r` tends to negative\ninfinity if and only if `r < 0. `-/\ntheorem tendsto_mul_const_at_bot_iff_neg [NeBot l] (h : Tendsto f l atTop) :\n    Tendsto (fun x => f x * r) l atBot ↔ r < 0 := by simp only [mul_comm _ r, tendsto_const_mul_at_bot_iff_neg h]\n#align tendsto_mul_const_at_bot_iff_neg tendsto_mul_const_at_bot_iff_neg\n\n",
 "tendsto_mul_const_at_bot_iff":
 "/-- The function `λ x, f x * r` tends to negative infinity along a nontrivial filter if and only if\n`r > 0` and `f` tends to negative infinity or `r < 0` and `f` tends to infinity. -/\ntheorem tendsto_mul_const_at_bot_iff [NeBot l] :\n    Tendsto (fun x => f x * r) l atBot ↔ 0 < r ∧ Tendsto f l atBot ∨ r < 0 ∧ Tendsto f l atTop := by\n  simp only [mul_comm _ r, tendsto_const_mul_at_bot_iff]\n#align tendsto_mul_const_at_bot_iff tendsto_mul_const_at_bot_iff\n\n",
 "tendsto_iff_seq_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- An abstract version of continuity of sequentially continuous functions on metric spaces:\nif a filter `k` is countably generated then `tendsto f k l` iff for every sequence `u`\nconverging to `k`, `f ∘ u` tends to `l`. -/\ntheorem tendsto_iff_seq_tendsto {f : α → β} {k : Filter α} {l : Filter β} [k.is_countably_generated] :\n    Tendsto f k l ↔ ∀ x : ℕ → α, Tendsto x atTop k → Tendsto (f ∘ x) atTop l :=\n  by\n  refine' ⟨fun h x hx => h.comp hx, fun H s hs => _⟩\n  contrapose! H\n  have : ne_bot («expr ⊓ » k ((filter.principal) («expr ⁻¹' » f («expr ᶜ» s)))) := by\n    simpa [ne_bot_iff, inf_principal_eq_bot]\n  rcases(«expr ⊓ » k ((filter.principal) («expr ⁻¹' » f («expr ᶜ» s)))).exists_seq_tendsto with ⟨x, hx⟩\n  rw [tendsto_inf, tendsto_principal] at hx\n  refine' ⟨x, hx.1, fun h => _⟩\n  rcases(hx.2.and (h hs)).exists with ⟨N, hnmem, hmem⟩\n  exact hnmem hmem\n#align tendsto_iff_seq_tendsto tendsto_iff_seq_tendsto\n\n",
 "tendsto_iff_forall_eventually_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_iff_forall_eventually_mem {α ι : Type _} {x : ι → α} {f : Filter α} {l : Filter ι} :\n    Tendsto x l f ↔\n      ∀ s ∈ f,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n          (x n ∈ s) :=\n  by\n  rw [tendsto_def]\n  refine' forall_congr' fun s => imp_congr_right fun hsf => _\n  rfl\n#align tendsto_iff_forall_eventually_mem tendsto_iff_forall_eventually_mem\n\n",
 "tendsto_finset_range":
 "theorem tendsto_finset_range : Tendsto Finset.range atTop atTop :=\n  Finset.range_mono.tendsto_at_top_at_top Finset.exists_nat_subset_range\n#align tendsto_finset_range tendsto_finset_range\n\n",
 "tendsto_finset_preimage_at_top_at_top":
 "theorem tendsto_finset_preimage_at_top_at_top {f : α → β} (hf : function.injective f) :\n    Tendsto (fun s : Finset β => s.preimage f (hf.inj_on _)) atTop atTop :=\n  (Finset.monotone_preimage hf).tendsto_at_top_finset fun x =>\n    ⟨{f x}, Finset.mem_preimage.2 <| Finset.mem_singleton_self _⟩\n#align tendsto_finset_preimage_at_top_at_top tendsto_finset_preimage_at_top_at_top\n\n",
 "tendsto_finset_image_at_top_at_top":
 "theorem tendsto_finset_image_at_top_at_top {i : β → γ} {j : γ → β} (h : function.left_inverse j i) :\n    Tendsto (Finset.image j) atTop atTop :=\n  (Finset.image_mono j).tendsto_at_top_finset fun a =>\n    ⟨{i a}, by simp only [Finset.image_singleton, h a, Finset.mem_singleton]⟩\n#align tendsto_finset_image_at_top_at_top tendsto_finset_image_at_top_at_top\n\n",
 "tendsto_const_mul_pow_at_top_iff":
 "theorem tendsto_const_mul_pow_at_top_iff : Tendsto (fun x => c * x ^ n) atTop atTop ↔ n ≠ 0 ∧ 0 < c :=\n  by\n  refine' ⟨fun h => ⟨_, _⟩, fun h => tendsto_const_mul_pow_at_top h.1 h.2⟩\n  · rintro rfl\n    simpa only [pow_zero, not_tendsto_const_at_top] using h\n  · rcases((h.eventually_gt_at_top 0).and (eventually_ge_at_top 0)).exists with ⟨k, hck, hk⟩\n    exact pos_of_mul_pos_left hck (pow_nonneg hk _)\n#align tendsto_const_mul_pow_at_top_iff tendsto_const_mul_pow_at_top_iff\n\n",
 "tendsto_const_mul_pow_at_top":
 "theorem tendsto_const_mul_pow_at_top (hn : n ≠ 0) (hc : 0 < c) : Tendsto (fun x => c * x ^ n) atTop atTop :=\n  Tendsto.const_mul_atTop hc (tendsto_pow_atTop hn)\n#align tendsto_const_mul_pow_at_top tendsto_const_mul_pow_at_top\n\n",
 "tendsto_const_mul_pow_at_bot_iff":
 "theorem tendsto_const_mul_pow_at_bot_iff {c : α} {n : ℕ} : Tendsto (fun x => c * x ^ n) atTop atBot ↔ n ≠ 0 ∧ c < 0 :=\n  by simp only [← tendsto_neg_at_top_iff, ← neg_mul, tendsto_const_mul_pow_at_top_iff, neg_pos]\n#align tendsto_const_mul_pow_at_bot_iff tendsto_const_mul_pow_at_bot_iff\n\n",
 "tendsto_const_mul_at_top_of_pos":
 "/-- If `r` is a positive constant, then `λ x, r * f x` tends to infinity along a filter if and only\nif `f` tends to infinity along the same filter. -/\ntheorem tendsto_const_mul_at_top_of_pos (hr : 0 < r) : Tendsto (fun x => r * f x) l atTop ↔ Tendsto f l atTop :=\n  ⟨fun h => h.at_top_of_const_mul hr, fun h =>\n    Tendsto.atTop_of_const_mul (inv_pos.2 hr) <| by simpa only [inv_mul_cancel_left₀ hr.ne'] ⟩\n#align tendsto_const_mul_at_top_of_pos tendsto_const_mul_at_top_of_pos\n\n",
 "tendsto_const_mul_at_top_of_neg":
 "/-- If `r` is a negative constant, then `λ x, r * f x` tends to infinity along a filter if and only\nif `f` tends to negative infinity along the same filter. -/\ntheorem tendsto_const_mul_at_top_of_neg (hr : r < 0) : Tendsto (fun x => r * f x) l atTop ↔ Tendsto f l atBot := by\n  simpa only [neg_mul, tendsto_neg_at_bot_iff] using tendsto_const_mul_at_bot_of_pos (neg_pos.2 hr)\n#align tendsto_const_mul_at_top_of_neg tendsto_const_mul_at_top_of_neg\n\n",
 "tendsto_const_mul_at_top_iff_pos":
 "/-- If `f` tends to infinity along a nontrivial filter `l`, then `λ x, r * f x` tends to infinity\nif and only if `0 < r. `-/\ntheorem tendsto_const_mul_at_top_iff_pos [NeBot l] (h : Tendsto f l atTop) :\n    Tendsto (fun x => r * f x) l atTop ↔ 0 < r :=\n  by\n  refine' ⟨fun hrf => not_le.mp fun hr => _, fun hr => (tendsto_const_mul_at_top_of_pos hr).mpr h⟩\n  rcases((h.eventually_ge_at_top 0).and (hrf.eventually_gt_at_top 0)).exists with ⟨x, hx, hrx⟩\n  exact (mul_nonpos_of_nonpos_of_nonneg hr hx).not_lt hrx\n#align tendsto_const_mul_at_top_iff_pos tendsto_const_mul_at_top_iff_pos\n\n",
 "tendsto_const_mul_at_top_iff_neg":
 "/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `λ x, r * f x` tends to\ninfinity if and only if `r < 0. `-/\ntheorem tendsto_const_mul_at_top_iff_neg [NeBot l] (h : Tendsto f l atBot) :\n    Tendsto (fun x => r * f x) l atTop ↔ r < 0 := by\n  simp [tendsto_const_mul_at_top_iff, h, h.not_tendsto disjoint_at_bot_at_top]\n#align tendsto_const_mul_at_top_iff_neg tendsto_const_mul_at_top_iff_neg\n\n",
 "tendsto_const_mul_at_top_iff":
 "/-- The function `λ x, r * f x` tends to infinity along a nontrivial filter if and only if `r > 0`\nand `f` tends to infinity or `r < 0` and `f` tends to negative infinity. -/\ntheorem tendsto_const_mul_at_top_iff [NeBot l] :\n    Tendsto (fun x => r * f x) l atTop ↔ 0 < r ∧ Tendsto f l atTop ∨ r < 0 ∧ Tendsto f l atBot :=\n  by\n  rcases lt_trichotomy r 0 with (hr | rfl | hr)\n  · simp [hr, hr.not_lt, tendsto_const_mul_at_top_of_neg]\n  · simp [not_tendsto_const_at_top]\n  · simp [hr, hr.not_lt, tendsto_const_mul_at_top_of_pos]\n#align tendsto_const_mul_at_top_iff tendsto_const_mul_at_top_iff\n\n",
 "tendsto_const_mul_at_bot_of_pos":
 "/-- If `r` is a positive constant, then `λ x, r * f x` tends to negative infinity along a filter if\nand only if `f` tends to negative infinity along the same filter. -/\ntheorem tendsto_const_mul_at_bot_of_pos (hr : 0 < r) : Tendsto (fun x => r * f x) l atBot ↔ Tendsto f l atBot := by\n  simpa only [← mul_neg, ← tendsto_neg_at_top_iff] using tendsto_const_mul_at_top_of_pos hr\n#align tendsto_const_mul_at_bot_of_pos tendsto_const_mul_at_bot_of_pos\n\n",
 "tendsto_const_mul_at_bot_of_neg":
 "/-- If `r` is a negative constant, then `λ x, r * f x` tends to negative infinity along a filter if\nand only if `f` tends to infinity along the same filter. -/\ntheorem tendsto_const_mul_at_bot_of_neg (hr : r < 0) : Tendsto (fun x => r * f x) l atBot ↔ Tendsto f l atTop := by\n  simpa only [neg_mul, tendsto_neg_at_top_iff] using tendsto_const_mul_at_top_of_pos (neg_pos.2 hr)\n#align tendsto_const_mul_at_bot_of_neg tendsto_const_mul_at_bot_of_neg\n\n",
 "tendsto_const_mul_at_bot_iff_pos":
 "/-- If `f` tends to negative infinity along a nontrivial filter `l`, then `λ x, r * f x` tends to\nnegative infinity if and only if `0 < r. `-/\ntheorem tendsto_const_mul_at_bot_iff_pos [NeBot l] (h : Tendsto f l atBot) :\n    Tendsto (fun x => r * f x) l atBot ↔ 0 < r := by\n  simp [tendsto_const_mul_at_bot_iff, h, h.not_tendsto disjoint_at_bot_at_top]\n#align tendsto_const_mul_at_bot_iff_pos tendsto_const_mul_at_bot_iff_pos\n\n",
 "tendsto_const_mul_at_bot_iff_neg":
 "/-- If `f` tends to infinity along a nontrivial filter `l`, then `λ x, r * f x` tends to negative\ninfinity if and only if `r < 0. `-/\ntheorem tendsto_const_mul_at_bot_iff_neg [NeBot l] (h : Tendsto f l atTop) :\n    Tendsto (fun x => r * f x) l atBot ↔ r < 0 := by\n  simp [tendsto_const_mul_at_bot_iff, h, h.not_tendsto disjoint_at_top_at_bot]\n#align tendsto_const_mul_at_bot_iff_neg tendsto_const_mul_at_bot_iff_neg\n\n",
 "tendsto_const_mul_at_bot_iff":
 "/-- The function `λ x, r * f x` tends to negative infinity along a nontrivial filter if and only if\n`r > 0` and `f` tends to negative infinity or `r < 0` and `f` tends to infinity. -/\ntheorem tendsto_const_mul_at_bot_iff [NeBot l] :\n    Tendsto (fun x => r * f x) l atBot ↔ 0 < r ∧ Tendsto f l atBot ∨ r < 0 ∧ Tendsto f l atTop := by\n  simp only [← tendsto_neg_at_top_iff, ← mul_neg, tendsto_const_mul_at_top_iff, neg_neg]\n#align tendsto_const_mul_at_bot_iff tendsto_const_mul_at_bot_iff\n\n",
 "tendsto_comp_coe_Ioi_at_top":
 "@[simp]\ntheorem tendsto_comp_coe_Ioi_at_top [SemilatticeSup α] [NoMaxOrder α] {a : α} {f : α → β} {l : Filter β} :\n    Tendsto (fun x : Ioi a => f x) atTop l ↔ Tendsto f atTop l := by rw [← map_coe_Ioi_at_top a, tendsto_map'_iff]\n#align tendsto_comp_coe_Ioi_at_top tendsto_comp_coe_Ioi_at_top\n\n",
 "tendsto_comp_coe_Iio_at_bot":
 "@[simp]\ntheorem tendsto_comp_coe_Iio_at_bot [SemilatticeInf α] [NoMinOrder α] {a : α} {f : α → β} {l : Filter β} :\n    Tendsto (fun x : Iio a => f x) atBot l ↔ Tendsto f atBot l := by rw [← map_coe_Iio_at_bot a, tendsto_map'_iff]\n#align tendsto_comp_coe_Iio_at_bot tendsto_comp_coe_Iio_at_bot\n\n",
 "tendsto_comp_coe_Iic_at_bot":
 "@[simp]\ntheorem tendsto_comp_coe_Iic_at_bot [SemilatticeInf α] {a : α} {f : α → β} {l : Filter β} :\n    Tendsto (fun x : Iic a => f x) atBot l ↔ Tendsto f atBot l := by rw [← map_coe_Iic_at_bot a, tendsto_map'_iff]\n#align tendsto_comp_coe_Iic_at_bot tendsto_comp_coe_Iic_at_bot\n\n",
 "tendsto_comp_coe_Ici_at_top":
 "@[simp]\ntheorem tendsto_comp_coe_Ici_at_top [SemilatticeSup α] {a : α} {f : α → β} {l : Filter β} :\n    Tendsto (fun x : Ici a => f x) atTop l ↔ Tendsto f atTop l := by rw [← map_coe_Ici_at_top a, tendsto_map'_iff]\n#align tendsto_comp_coe_Ici_at_top tendsto_comp_coe_Ici_at_top\n\n",
 "tendsto_bit1_at_top":
 "theorem tendsto_bit1_at_top : Tendsto bit1 (atTop : Filter α) atTop :=\n  tendsto_atTop_add_nonneg_right tendsto_bit0_atTop fun _ => zero_le_one\n#align tendsto_bit1_at_top tendsto_bit1_at_top\n\n",
 "tendsto_bit0_at_top":
 "theorem tendsto_bit0_at_top : Tendsto bit0 (atTop : Filter β) atTop :=\n  tendsto_atTop_add tendsto_id tendsto_id\n#align tendsto_bit0_at_top tendsto_bit0_at_top\n\n",
 "tendsto_bit0_at_bot":
 "theorem tendsto_bit0_at_bot : Tendsto bit0 (atBot : Filter β) atBot :=\n  tendsto_atBot_add tendsto_id tendsto_id\n#align tendsto_bit0_at_bot tendsto_bit0_at_bot\n\n",
 "tendsto_at_top_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem tendsto_at_top_pure [partial_order α] [OrderTop α] (f : α → β) : Tendsto f atTop (pure <| f («expr⊤»)) :=\n  (OrderTop.atTop_eq α).symm ▸ tendsto_pure_pure _ _\n#align tendsto_at_top_pure tendsto_at_top_pure\n\n",
 "tendsto_at_top_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem tendsto_at_top_principal [Nonempty β] [SemilatticeSup β] {f : β → α} {s : Set α} :\n    Tendsto f atTop ((filter.principal) s) ↔ ∃ N, ∀ n ≥ N, f n ∈ s := by\n  rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_at_top_sets] <;> rfl\n#align tendsto_at_top_principal tendsto_at_top_principal\n\n",
 "tendsto_at_top_of_monotone_of_subseq":
 "theorem tendsto_at_top_of_monotone_of_subseq [preorder ι] [preorder α] {u : ι → α} {φ : ι' → ι} (h : Monotone u)\n    {l : Filter ι'} [NeBot l] (H : Tendsto (u ∘ φ) l atTop) : Tendsto u atTop atTop :=\n  tendsto_atTop_of_monotone_of_filter h (tendsto_map' H)\n#align tendsto_at_top_of_monotone_of_subseq tendsto_at_top_of_monotone_of_subseq\n\n",
 "tendsto_at_top_of_monotone_of_filter":
 "/-- If a monotone function `u : ι → α` tends to `at_top` along *some* non-trivial filter `l`, then\nit tends to `at_top` along `at_top`. -/\ntheorem tendsto_at_top_of_monotone_of_filter [preorder ι] [preorder α] {l : Filter ι} {u : ι → α} (h : Monotone u)\n    [NeBot l] (hu : Tendsto u l atTop) : Tendsto u atTop atTop :=\n  h.tendsto_at_top_at_top fun b => (hu.eventually (mem_atTop b)).exists\n#align tendsto_at_top_of_monotone_of_filter tendsto_at_top_of_monotone_of_filter\n\n",
 "tendsto_at_top_of_add_const_right":
 "theorem tendsto_at_top_of_add_const_right (C : β) (hf : Tendsto (fun x => f x + C) l atTop) : Tendsto f l atTop :=\n  tendsto_atTop.2 fun b => (tendsto_atTop.1 hf (b + C)).mono fun x => le_of_add_le_add_right\n#align tendsto_at_top_of_add_const_right tendsto_at_top_of_add_const_right\n\n",
 "tendsto_at_top_of_add_const_left":
 "theorem tendsto_at_top_of_add_const_left (C : β) (hf : Tendsto (fun x => C + f x) l atTop) : Tendsto f l atTop :=\n  tendsto_atTop.2 fun b => (tendsto_atTop.1 hf (C + b)).mono fun x => le_of_add_le_add_left\n#align tendsto_at_top_of_add_const_left tendsto_at_top_of_add_const_left\n\n",
 "tendsto_at_top_of_add_bdd_above_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_top_of_add_bdd_above_right' (C)\n    (hC :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (g x ≤ C))\n    (h : Tendsto (fun x => f x + g x) l atTop) : Tendsto f l atTop :=\n  tendsto_atTop_of_add_const_right C (tendsto_atTop_mono' l (hC.mono fun x hx => add_le_add_left hx (f x)) h)\n#align tendsto_at_top_of_add_bdd_above_right' tendsto_at_top_of_add_bdd_above_right'\n\n",
 "tendsto_at_top_of_add_bdd_above_right":
 "theorem tendsto_at_top_of_add_bdd_above_right (C) (hC : ∀ x, g x ≤ C) :\n    Tendsto (fun x => f x + g x) l atTop → Tendsto f l atTop :=\n  tendsto_atTop_of_add_bdd_above_right' C (univ_mem' hC)\n#align tendsto_at_top_of_add_bdd_above_right tendsto_at_top_of_add_bdd_above_right\n\n",
 "tendsto_at_top_of_add_bdd_above_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_top_of_add_bdd_above_left' (C)\n    (hC :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (f x ≤ C))\n    (h : Tendsto (fun x => f x + g x) l atTop) : Tendsto g l atTop :=\n  tendsto_atTop_of_add_const_left C (tendsto_atTop_mono' l (hC.mono fun x hx => add_le_add_right hx (g x)) h)\n#align tendsto_at_top_of_add_bdd_above_left' tendsto_at_top_of_add_bdd_above_left'\n\n",
 "tendsto_at_top_of_add_bdd_above_left":
 "theorem tendsto_at_top_of_add_bdd_above_left (C) (hC : ∀ x, f x ≤ C) :\n    Tendsto (fun x => f x + g x) l atTop → Tendsto g l atTop :=\n  tendsto_atTop_of_add_bdd_above_left' C (univ_mem' hC)\n#align tendsto_at_top_of_add_bdd_above_left tendsto_at_top_of_add_bdd_above_left\n\n",
 "tendsto_at_top_mono'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem tendsto_at_top_mono' [preorder β] (l : Filter α) ⦃f₁ f₂ : α → β⦄ (h : «expr ≤ᶠ[ ] » f₁ l f₂) :\n    Tendsto f₁ l atTop → Tendsto f₂ l atTop := fun h₁ =>\n  tendsto_atTop.2 fun b => mp_mem (tendsto_atTop.1 h₁ b) (monotone_mem (fun a ha ha₁ => le_trans ha₁ ha) h)\n#align tendsto_at_top_mono' tendsto_at_top_mono'\n\n",
 "tendsto_at_top_mono":
 "theorem tendsto_at_top_mono [preorder β] {l : Filter α} {f g : α → β} (h : ∀ n, f n ≤ g n) :\n    Tendsto f l atTop → Tendsto g l atTop :=\n  tendsto_atTop_mono' l <| eventually_of_forall h\n#align tendsto_at_top_mono tendsto_at_top_mono\n\n",
 "tendsto_at_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n@[simp]\ntheorem tendsto_at_top_iff {l : Filter γ} {f : γ → α} (e : «expr ≃o » α β) :\n    Tendsto (fun x => e (f x)) l atTop ↔ Tendsto f l atTop := by rw [← e.comap_at_top, tendsto_comap_iff]\n#align tendsto_at_top_iff tendsto_at_top_iff\n\n",
 "tendsto_at_top_finset_of_monotone":
 "/-- If `f` is a monotone sequence of `finset`s and each `x` belongs to one of `f n`, then\n`tendsto f at_top at_top`. -/\ntheorem tendsto_at_top_finset_of_monotone [preorder β] {f : β → Finset α} (h : Monotone f)\n    (h' : ∀ x : α, ∃ n, x ∈ f n) : Tendsto f atTop atTop :=\n  by\n  simp only [at_top_finset_eq_infi, tendsto_infi, tendsto_principal]\n  intro a\n  rcases h' a with ⟨b, hb⟩\n  exact eventually.mono (mem_at_top b) fun b' hb' => le_trans (Finset.singleton_subset_iff.2 hb) (h hb')\n#align tendsto_at_top_finset_of_monotone tendsto_at_top_finset_of_monotone\n\n",
 "tendsto_at_top_embedding":
 "theorem tendsto_at_top_embedding [preorder β] [preorder γ] {f : α → β} {e : β → γ} {l : Filter α}\n    (hm : ∀ b₁ b₂, e b₁ ≤ e b₂ ↔ b₁ ≤ b₂) (hu : ∀ c, ∃ b, c ≤ e b) : Tendsto (e ∘ f) l atTop ↔ Tendsto f l atTop := by\n  rw [← comap_embedding_at_top hm hu, tendsto_comap_iff]\n#align tendsto_at_top_embedding tendsto_at_top_embedding\n\n",
 "tendsto_at_top_diagonal":
 "theorem tendsto_at_top_diagonal [SemilatticeSup α] : Tendsto (fun a : α => (a, a)) atTop atTop :=\n  by\n  rw [← prod_at_top_at_top_eq]\n  exact tendsto_id.prod_mk tendsto_id\n#align tendsto_at_top_diagonal tendsto_at_top_diagonal\n\n",
 "tendsto_at_top_at_top_of_monotone'":
 "/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded\nabove, then `tendsto u at_top at_top`. -/\ntheorem tendsto_at_top_at_top_of_monotone' [preorder ι] [linear_order α] {u : ι → α} (h : Monotone u)\n    (H : ¬BddAbove (range u)) : Tendsto u atTop atTop :=\n  by\n  apply h.tendsto_at_top_at_top\n  intro b\n  rcases not_bddAbove_iff.1 H b with ⟨_, ⟨N, rfl⟩, hN⟩\n  exact ⟨N, le_of_lt hN⟩\n#align tendsto_at_top_at_top_of_monotone' tendsto_at_top_at_top_of_monotone'\n\n",
 "tendsto_at_top_at_top_of_monotone":
 "theorem tendsto_at_top_at_top_of_monotone [preorder α] [preorder β] {f : α → β} (hf : Monotone f)\n    (h : ∀ b, ∃ a, b ≤ f a) : Tendsto f atTop atTop :=\n  tendsto_infᵢ.2 fun b =>\n    tendsto_principal.2 <|\n      let ⟨a, ha⟩ := h b\n      mem_of_superset (mem_atTop a) fun a' ha' => le_trans ha (hf ha')\n#align tendsto_at_top_at_top_of_monotone tendsto_at_top_at_top_of_monotone\n\n",
 "tendsto_at_top_at_top_iff_of_monotone":
 "theorem tendsto_at_top_at_top_iff_of_monotone [Nonempty α] [SemilatticeSup α] [preorder β] {f : α → β}\n    (hf : Monotone f) : Tendsto f atTop atTop ↔ ∀ b : β, ∃ a : α, b ≤ f a :=\n  tendsto_atTop_atTop.trans <|\n    forall_congr' fun b => exists_congr fun a => ⟨fun h => h a (le_refl a), fun h a' ha' => le_trans h <| hf ha'⟩\n#align tendsto_at_top_at_top_iff_of_monotone tendsto_at_top_at_top_iff_of_monotone\n\n",
 "tendsto_at_top_at_top":
 "/-- A function `f` grows to `+∞` independent of an order-preserving embedding `e`. -/\ntheorem tendsto_at_top_at_top [Nonempty α] [SemilatticeSup α] [preorder β] {f : α → β} :\n    Tendsto f atTop atTop ↔ ∀ b : β, ∃ i : α, ∀ a : α, i ≤ a → b ≤ f a :=\n  iff.trans tendsto_infᵢ <| forall_congr' fun b => tendsto_atTop_principal\n#align tendsto_at_top_at_top tendsto_at_top_at_top\n\n",
 "tendsto_at_top_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_top_at_bot [Nonempty α] [SemilatticeSup α] [preorder β] {f : α → β} :\n    Tendsto f atTop atBot ↔ ∀ b : β, ∃ i : α, ∀ a : α, i ≤ a → f a ≤ b :=\n  @tendsto_atTop_atTop α («expr ᵒᵈ» β) _ _ _ f\n#align tendsto_at_top_at_bot tendsto_at_top_at_bot\n\n",
 "tendsto_at_top_add_right_of_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_top_add_right_of_le' (C : β) (hf : Tendsto f l atTop)\n    (hg :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (C ≤ g x)) :\n    Tendsto (fun x => f x + g x) l atTop :=\n  @tendsto_atTop_of_add_bdd_above_right' _ _ _ l (fun x => f x + g x) (fun x => -g x) (-C) (by simp [hg]) (by simp [hf])\n#align tendsto_at_top_add_right_of_le' tendsto_at_top_add_right_of_le'\n\n",
 "tendsto_at_top_add_right_of_le":
 "theorem tendsto_at_top_add_right_of_le (C : β) (hf : Tendsto f l atTop) (hg : ∀ x, C ≤ g x) :\n    Tendsto (fun x => f x + g x) l atTop :=\n  tendsto_atTop_add_right_of_le' l C hf (univ_mem' hg)\n#align tendsto_at_top_add_right_of_le tendsto_at_top_add_right_of_le\n\n",
 "tendsto_at_top_add_nonneg_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_top_add_nonneg_right' (hf : Tendsto f l atTop)\n    (hg :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (0 ≤ g x)) :\n    Tendsto (fun x => f x + g x) l atTop :=\n  tendsto_atTop_mono' l (monotone_mem (fun x => le_add_of_nonneg_right) hg) hf\n#align tendsto_at_top_add_nonneg_right' tendsto_at_top_add_nonneg_right'\n\n",
 "tendsto_at_top_add_nonneg_right":
 "theorem tendsto_at_top_add_nonneg_right (hf : Tendsto f l atTop) (hg : ∀ x, 0 ≤ g x) :\n    Tendsto (fun x => f x + g x) l atTop :=\n  tendsto_atTop_add_nonneg_right' hf (eventually_of_forall hg)\n#align tendsto_at_top_add_nonneg_right tendsto_at_top_add_nonneg_right\n\n",
 "tendsto_at_top_add_nonneg_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_top_add_nonneg_left'\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (0 ≤ f x))\n    (hg : Tendsto g l atTop) : Tendsto (fun x => f x + g x) l atTop :=\n  tendsto_atTop_mono' l (hf.mono fun x => le_add_of_nonneg_left) hg\n#align tendsto_at_top_add_nonneg_left' tendsto_at_top_add_nonneg_left'\n\n",
 "tendsto_at_top_add_nonneg_left":
 "theorem tendsto_at_top_add_nonneg_left (hf : ∀ x, 0 ≤ f x) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x + g x) l atTop :=\n  tendsto_atTop_add_nonneg_left' (eventually_of_forall hf) hg\n#align tendsto_at_top_add_nonneg_left tendsto_at_top_add_nonneg_left\n\n",
 "tendsto_at_top_add_left_of_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_top_add_left_of_le' (C : β)\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (C ≤ f x))\n    (hg : Tendsto g l atTop) : Tendsto (fun x => f x + g x) l atTop :=\n  @tendsto_atTop_of_add_bdd_above_left' _ _ _ l (fun x => -f x) (fun x => f x + g x) (-C) (by simpa) (by simpa)\n#align tendsto_at_top_add_left_of_le' tendsto_at_top_add_left_of_le'\n\n",
 "tendsto_at_top_add_left_of_le":
 "theorem tendsto_at_top_add_left_of_le (C : β) (hf : ∀ x, C ≤ f x) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x + g x) l atTop :=\n  tendsto_atTop_add_left_of_le' l C (univ_mem' hf) hg\n#align tendsto_at_top_add_left_of_le tendsto_at_top_add_left_of_le\n\n",
 "tendsto_at_top_add_const_right":
 "theorem tendsto_at_top_add_const_right (C : β) (hf : Tendsto f l atTop) : Tendsto (fun x => f x + C) l atTop :=\n  tendsto_atTop_add_right_of_le' l C hf (univ_mem' fun _ => le_refl C)\n#align tendsto_at_top_add_const_right tendsto_at_top_add_const_right\n\n",
 "tendsto_at_top_add_const_left":
 "theorem tendsto_at_top_add_const_left (C : β) (hf : Tendsto f l atTop) : Tendsto (fun x => C + f x) l atTop :=\n  tendsto_atTop_add_left_of_le' l C (univ_mem' fun _ => le_refl C) hf\n#align tendsto_at_top_add_const_left tendsto_at_top_add_const_left\n\n",
 "tendsto_at_top_add":
 "theorem tendsto_at_top_add (hf : Tendsto f l atTop) (hg : Tendsto g l atTop) : Tendsto (fun x => f x + g x) l atTop :=\n  tendsto_atTop_add_nonneg_left' (tendsto_atTop.mp hf 0) hg\n#align tendsto_at_top_add tendsto_at_top_add\n\n",
 "tendsto_at_top'":
 "theorem tendsto_at_top' [Nonempty α] [SemilatticeSup α] {f : α → β} {l : Filter β} :\n    Tendsto f atTop l ↔ ∀ s ∈ l, ∃ a, ∀ b ≥ a, f b ∈ s := by simp only [tendsto_def, mem_at_top_sets] <;> rfl\n#align tendsto_at_top' tendsto_at_top'\n\n",
 "tendsto_at_top":
 "#print StrictMono.tendsto_atTop /-\ntheorem StrictMono.tendsto_atTop {φ : ℕ → ℕ} (h : StrictMono φ) : Tendsto φ atTop atTop :=\n  tendsto_atTop_mono h.id_le tendsto_id\n#align strict_mono.tendsto_at_top StrictMono.tendsto_atTop\n-/\n\n",
 "tendsto_at_bot_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem tendsto_at_bot_pure [partial_order α] [OrderBot α] (f : α → β) : Tendsto f atBot (pure <| f («expr⊥»)) :=\n  @tendsto_atTop_pure («expr ᵒᵈ» α) _ _ _ _\n#align tendsto_at_bot_pure tendsto_at_bot_pure\n\n",
 "tendsto_at_bot_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem tendsto_at_bot_principal [Nonempty β] [SemilatticeInf β] {f : β → α} {s : Set α} :\n    Tendsto f atBot ((filter.principal) s) ↔ ∃ N, ∀ n ≤ N, f n ∈ s :=\n  @tendsto_atTop_principal _ («expr ᵒᵈ» β) _ _ _ _\n#align tendsto_at_bot_principal tendsto_at_bot_principal\n\n",
 "tendsto_at_bot_of_monotone_of_subseq":
 "theorem tendsto_at_bot_of_monotone_of_subseq [preorder ι] [preorder α] {u : ι → α} {φ : ι' → ι} (h : Monotone u)\n    {l : Filter ι'} [NeBot l] (H : Tendsto (u ∘ φ) l atBot) : Tendsto u atBot atBot :=\n  tendsto_atBot_of_monotone_of_filter h (tendsto_map' H)\n#align tendsto_at_bot_of_monotone_of_subseq tendsto_at_bot_of_monotone_of_subseq\n\n",
 "tendsto_at_bot_of_monotone_of_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- If a monotone function `u : ι → α` tends to `at_bot` along *some* non-trivial filter `l`, then\nit tends to `at_bot` along `at_bot`. -/\ntheorem tendsto_at_bot_of_monotone_of_filter [preorder ι] [preorder α] {l : Filter ι} {u : ι → α} (h : Monotone u)\n    [NeBot l] (hu : Tendsto u l atBot) : Tendsto u atBot atBot :=\n  @tendsto_atTop_of_monotone_of_filter («expr ᵒᵈ» ι) («expr ᵒᵈ» α) _ _ _ _ h.dual _ hu\n#align tendsto_at_bot_of_monotone_of_filter tendsto_at_bot_of_monotone_of_filter\n\n",
 "tendsto_at_bot_of_add_const_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_of_add_const_right (C : β) (hf : Tendsto (fun x => f x + C) l atBot) : Tendsto f l atBot :=\n  @tendsto_atTop_of_add_const_right _ («expr ᵒᵈ» β) _ _ _ C hf\n#align tendsto_at_bot_of_add_const_right tendsto_at_bot_of_add_const_right\n\n",
 "tendsto_at_bot_of_add_const_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_of_add_const_left (C : β) (hf : Tendsto (fun x => C + f x) l atBot) : Tendsto f l atBot :=\n  @tendsto_atTop_of_add_const_left _ («expr ᵒᵈ» β) _ _ _ C hf\n#align tendsto_at_bot_of_add_const_left tendsto_at_bot_of_add_const_left\n\n",
 "tendsto_at_bot_of_add_bdd_below_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_bot_of_add_bdd_below_right' (C)\n    (hC :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (C ≤ g x))\n    (h : Tendsto (fun x => f x + g x) l atBot) : Tendsto f l atBot :=\n  @tendsto_atTop_of_add_bdd_above_right' _ («expr ᵒᵈ» β) _ _ _ _ C hC h\n#align tendsto_at_bot_of_add_bdd_below_right' tendsto_at_bot_of_add_bdd_below_right'\n\n",
 "tendsto_at_bot_of_add_bdd_below_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_of_add_bdd_below_right (C) (hC : ∀ x, C ≤ g x) :\n    Tendsto (fun x => f x + g x) l atBot → Tendsto f l atBot :=\n  @tendsto_atTop_of_add_bdd_above_right _ («expr ᵒᵈ» β) _ _ _ _ C hC\n#align tendsto_at_bot_of_add_bdd_below_right tendsto_at_bot_of_add_bdd_below_right\n\n",
 "tendsto_at_bot_of_add_bdd_below_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_bot_of_add_bdd_below_left' (C)\n    (hC :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (C ≤ f x))\n    (h : Tendsto (fun x => f x + g x) l atBot) : Tendsto g l atBot :=\n  @tendsto_atTop_of_add_bdd_above_left' _ («expr ᵒᵈ» β) _ _ _ _ C hC h\n#align tendsto_at_bot_of_add_bdd_below_left' tendsto_at_bot_of_add_bdd_below_left'\n\n",
 "tendsto_at_bot_of_add_bdd_below_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_of_add_bdd_below_left (C) (hC : ∀ x, C ≤ f x) :\n    Tendsto (fun x => f x + g x) l atBot → Tendsto g l atBot :=\n  @tendsto_atTop_of_add_bdd_above_left _ («expr ᵒᵈ» β) _ _ _ _ C hC\n#align tendsto_at_bot_of_add_bdd_below_left tendsto_at_bot_of_add_bdd_below_left\n\n",
 "tendsto_at_bot_mono'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem tendsto_at_bot_mono' [preorder β] (l : Filter α) ⦃f₁ f₂ : α → β⦄ (h : «expr ≤ᶠ[ ] » f₁ l f₂) :\n    Tendsto f₂ l atBot → Tendsto f₁ l atBot :=\n  @tendsto_atTop_mono' _ («expr ᵒᵈ» β) _ _ _ _ h\n#align tendsto_at_bot_mono' tendsto_at_bot_mono'\n\n",
 "tendsto_at_bot_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_mono [preorder β] {l : Filter α} {f g : α → β} (h : ∀ n, f n ≤ g n) :\n    Tendsto g l atBot → Tendsto f l atBot :=\n  @tendsto_atTop_mono _ («expr ᵒᵈ» β) _ _ _ _ h\n#align tendsto_at_bot_mono tendsto_at_bot_mono\n\n",
 "tendsto_at_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n@[simp]\ntheorem tendsto_at_bot_iff {l : Filter γ} {f : γ → α} (e : «expr ≃o » α β) :\n    Tendsto (fun x => e (f x)) l atBot ↔ Tendsto f l atBot :=\n  e.dual.tendsto_at_top_iff\n#align tendsto_at_bot_iff tendsto_at_bot_iff\n\n",
 "tendsto_at_bot_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- A function `f` goes to `-∞` independent of an order-preserving embedding `e`. -/\ntheorem tendsto_at_bot_embedding [preorder β] [preorder γ] {f : α → β} {e : β → γ} {l : Filter α}\n    (hm : ∀ b₁ b₂, e b₁ ≤ e b₂ ↔ b₁ ≤ b₂) (hu : ∀ c, ∃ b, e b ≤ c) : Tendsto (e ∘ f) l atBot ↔ Tendsto f l atBot :=\n  @tendsto_atTop_embedding α («expr ᵒᵈ» β) («expr ᵒᵈ» γ) _ _ f e l (function.swap hm) hu\n#align tendsto_at_bot_embedding tendsto_at_bot_embedding\n\n",
 "tendsto_at_bot_diagonal":
 "theorem tendsto_at_bot_diagonal [SemilatticeInf α] : Tendsto (fun a : α => (a, a)) atBot atBot :=\n  by\n  rw [← prod_at_bot_at_bot_eq]\n  exact tendsto_id.prod_mk tendsto_id\n#align tendsto_at_bot_diagonal tendsto_at_bot_diagonal\n\n",
 "tendsto_at_bot_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_at_top [Nonempty α] [SemilatticeInf α] [preorder β] {f : α → β} :\n    Tendsto f atBot atTop ↔ ∀ b : β, ∃ i : α, ∀ a : α, a ≤ i → b ≤ f a :=\n  @tendsto_atTop_atTop («expr ᵒᵈ» α) β _ _ _ f\n#align tendsto_at_bot_at_top tendsto_at_bot_at_top\n\n",
 "tendsto_at_bot_at_bot_of_monotone'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded\nbelow, then `tendsto u at_bot at_bot`. -/\ntheorem tendsto_at_bot_at_bot_of_monotone' [preorder ι] [linear_order α] {u : ι → α} (h : Monotone u)\n    (H : ¬BddBelow (range u)) : Tendsto u atBot atBot :=\n  @tendsto_atTop_atTop_of_monotone' («expr ᵒᵈ» ι) («expr ᵒᵈ» α) _ _ _ h.dual H\n#align tendsto_at_bot_at_bot_of_monotone' tendsto_at_bot_at_bot_of_monotone'\n\n",
 "tendsto_at_bot_at_bot_of_monotone":
 "theorem tendsto_at_bot_at_bot_of_monotone [preorder α] [preorder β] {f : α → β} (hf : Monotone f)\n    (h : ∀ b, ∃ a, f a ≤ b) : Tendsto f atBot atBot :=\n  tendsto_infᵢ.2 fun b =>\n    tendsto_principal.2 <|\n      let ⟨a, ha⟩ := h b\n      mem_of_superset (mem_atBot a) fun a' ha' => le_trans (hf ha') ha\n#align tendsto_at_bot_at_bot_of_monotone tendsto_at_bot_at_bot_of_monotone\n\n",
 "tendsto_at_bot_at_bot_iff_of_monotone":
 "theorem tendsto_at_bot_at_bot_iff_of_monotone [Nonempty α] [SemilatticeInf α] [preorder β] {f : α → β}\n    (hf : Monotone f) : Tendsto f atBot atBot ↔ ∀ b : β, ∃ a : α, f a ≤ b :=\n  tendsto_atBot_atBot.trans <|\n    forall_congr' fun b => exists_congr fun a => ⟨fun h => h a (le_refl a), fun h a' ha' => le_trans (hf ha') h⟩\n#align tendsto_at_bot_at_bot_iff_of_monotone tendsto_at_bot_at_bot_iff_of_monotone\n\n",
 "tendsto_at_bot_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_at_bot [Nonempty α] [SemilatticeInf α] [preorder β] {f : α → β} :\n    Tendsto f atBot atBot ↔ ∀ b : β, ∃ i : α, ∀ a : α, a ≤ i → f a ≤ b :=\n  @tendsto_atTop_atTop («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ _ f\n#align tendsto_at_bot_at_bot tendsto_at_bot_at_bot\n\n",
 "tendsto_at_bot_add_right_of_ge'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_bot_add_right_of_ge' (C : β) (hf : Tendsto f l atBot)\n    (hg :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (g x ≤ C)) :\n    Tendsto (fun x => f x + g x) l atBot :=\n  @tendsto_atTop_add_right_of_le' _ («expr ᵒᵈ» β) _ _ _ _ C hf hg\n#align tendsto_at_bot_add_right_of_ge' tendsto_at_bot_add_right_of_ge'\n\n",
 "tendsto_at_bot_add_right_of_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_add_right_of_ge (C : β) (hf : Tendsto f l atBot) (hg : ∀ x, g x ≤ C) :\n    Tendsto (fun x => f x + g x) l atBot :=\n  @tendsto_atTop_add_right_of_le _ («expr ᵒᵈ» β) _ _ _ _ C hf hg\n#align tendsto_at_bot_add_right_of_ge tendsto_at_bot_add_right_of_ge\n\n",
 "tendsto_at_bot_add_nonpos_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_bot_add_nonpos_right' (hf : Tendsto f l atBot)\n    (hg :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (g x ≤ 0)) :\n    Tendsto (fun x => f x + g x) l atBot :=\n  @tendsto_atTop_add_nonneg_right' _ («expr ᵒᵈ» β) _ _ _ _ hf hg\n#align tendsto_at_bot_add_nonpos_right' tendsto_at_bot_add_nonpos_right'\n\n",
 "tendsto_at_bot_add_nonpos_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_add_nonpos_right (hf : Tendsto f l atBot) (hg : ∀ x, g x ≤ 0) :\n    Tendsto (fun x => f x + g x) l atBot :=\n  @tendsto_atTop_add_nonneg_right _ («expr ᵒᵈ» β) _ _ _ _ hf hg\n#align tendsto_at_bot_add_nonpos_right tendsto_at_bot_add_nonpos_right\n\n",
 "tendsto_at_bot_add_nonpos_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_bot_add_nonpos_left'\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (f x ≤ 0))\n    (hg : Tendsto g l atBot) : Tendsto (fun x => f x + g x) l atBot :=\n  @tendsto_atTop_add_nonneg_left' _ («expr ᵒᵈ» β) _ _ _ _ hf hg\n#align tendsto_at_bot_add_nonpos_left' tendsto_at_bot_add_nonpos_left'\n\n",
 "tendsto_at_bot_add_nonpos_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_add_nonpos_left (hf : ∀ x, f x ≤ 0) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x + g x) l atBot :=\n  @tendsto_atTop_add_nonneg_left _ («expr ᵒᵈ» β) _ _ _ _ hf hg\n#align tendsto_at_bot_add_nonpos_left tendsto_at_bot_add_nonpos_left\n\n",
 "tendsto_at_bot_add_left_of_ge'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_at_bot_add_left_of_ge' (C : β)\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (f x ≤ C))\n    (hg : Tendsto g l atBot) : Tendsto (fun x => f x + g x) l atBot :=\n  @tendsto_atTop_add_left_of_le' _ («expr ᵒᵈ» β) _ _ _ _ C hf hg\n#align tendsto_at_bot_add_left_of_ge' tendsto_at_bot_add_left_of_ge'\n\n",
 "tendsto_at_bot_add_left_of_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_add_left_of_ge (C : β) (hf : ∀ x, f x ≤ C) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x + g x) l atBot :=\n  @tendsto_atTop_add_left_of_le _ («expr ᵒᵈ» β) _ _ _ _ C hf hg\n#align tendsto_at_bot_add_left_of_ge tendsto_at_bot_add_left_of_ge\n\n",
 "tendsto_at_bot_add_const_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_add_const_right (C : β) (hf : Tendsto f l atBot) : Tendsto (fun x => f x + C) l atBot :=\n  @tendsto_atTop_add_const_right _ («expr ᵒᵈ» β) _ _ _ C hf\n#align tendsto_at_bot_add_const_right tendsto_at_bot_add_const_right\n\n",
 "tendsto_at_bot_add_const_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_add_const_left (C : β) (hf : Tendsto f l atBot) : Tendsto (fun x => C + f x) l atBot :=\n  @tendsto_atTop_add_const_left _ («expr ᵒᵈ» β) _ _ _ C hf\n#align tendsto_at_bot_add_const_left tendsto_at_bot_add_const_left\n\n",
 "tendsto_at_bot_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot_add (hf : Tendsto f l atBot) (hg : Tendsto g l atBot) : Tendsto (fun x => f x + g x) l atBot :=\n  @tendsto_atTop_add _ («expr ᵒᵈ» β) _ _ _ _ hf hg\n#align tendsto_at_bot_add tendsto_at_bot_add\n\n",
 "tendsto_at_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem tendsto_at_bot' [Nonempty α] [SemilatticeInf α] {f : α → β} {l : Filter β} :\n    Tendsto f atBot l ↔ ∀ s ∈ l, ∃ a, ∀ b ≤ a, f b ∈ s :=\n  @tendsto_atTop' («expr ᵒᵈ» α) _ _ _ _ _\n#align tendsto_at_bot' tendsto_at_bot'\n\n",
 "tendsto_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\ntheorem tendsto_at_bot (e : «expr ≃o » α β) : Tendsto e atBot atBot :=\n  e.map_at_bot.le\n#align tendsto_at_bot tendsto_at_bot\n\n",
 "tendsto_add_at_top_nat":
 "theorem tendsto_add_at_top_nat (k : ℕ) : Tendsto (fun a => a + k) atTop atTop :=\n  le_of_eq (map_add_atTop_eq_nat k)\n#align tendsto_add_at_top_nat tendsto_add_at_top_nat\n\n",
 "tendsto_add_at_top_iff_nat":
 "theorem tendsto_add_at_top_iff_nat {f : ℕ → α} {l : Filter α} (k : ℕ) :\n    Tendsto (fun n => f (n + k)) atTop l ↔ Tendsto f atTop l :=\n  show Tendsto (f ∘ fun n => n + k) atTop l ↔ Tendsto f atTop l by rw [← tendsto_map'_iff, map_add_at_top_eq_nat]\n#align tendsto_add_at_top_iff_nat tendsto_add_at_top_iff_nat\n\n",
 "tendsto_abs_at_top_at_top":
 "/-- $\\lim_{x\\to+\\infty}|x|=+\\infty$ -/\ntheorem tendsto_abs_at_top_at_top : Tendsto (abs : α → α) atTop atTop :=\n  tendsto_atTop_mono le_abs_self tendsto_id\n#align tendsto_abs_at_top_at_top tendsto_abs_at_top_at_top\n\n",
 "tendsto_abs_at_bot_at_top":
 "/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem tendsto_abs_at_bot_at_top : Tendsto (abs : α → α) atBot atTop :=\n  tendsto_atTop_mono neg_le_abs_self tendsto_neg_atBot_atTop\n#align tendsto_abs_at_bot_at_top tendsto_abs_at_bot_at_top\n\n",
 "tendsto_Ioi_at_top":
 "theorem tendsto_Ioi_at_top [SemilatticeSup α] {a : α} {f : β → Ioi a} {l : Filter β} :\n    Tendsto f l atTop ↔ Tendsto (fun x => (f x : α)) l atTop := by rw [at_top_Ioi_eq, tendsto_comap_iff]\n#align tendsto_Ioi_at_top tendsto_Ioi_at_top\n\n",
 "tendsto_Iio_at_bot":
 "theorem tendsto_Iio_at_bot [SemilatticeInf α] {a : α} {f : β → Iio a} {l : Filter β} :\n    Tendsto f l atBot ↔ Tendsto (fun x => (f x : α)) l atBot := by rw [at_bot_Iio_eq, tendsto_comap_iff]\n#align tendsto_Iio_at_bot tendsto_Iio_at_bot\n\n",
 "tendsto_Iic_at_bot":
 "theorem tendsto_Iic_at_bot [SemilatticeInf α] {a : α} {f : β → Iic a} {l : Filter β} :\n    Tendsto f l atBot ↔ Tendsto (fun x => (f x : α)) l atBot := by rw [at_bot_Iic_eq, tendsto_comap_iff]\n#align tendsto_Iic_at_bot tendsto_Iic_at_bot\n\n",
 "tendsto_Ici_at_top":
 "theorem tendsto_Ici_at_top [SemilatticeSup α] {a : α} {f : β → Ici a} {l : Filter β} :\n    Tendsto f l atTop ↔ Tendsto (fun x => (f x : α)) l atTop := by rw [at_top_Ici_eq, tendsto_comap_iff]\n#align tendsto_Ici_at_top tendsto_Ici_at_top\n\n",
 "tendsto":
 "protected theorem has_antitone_basis.tendsto [preorder ι] {l : Filter α} {s : ι → Set α} (hl : l.has_antitone_basis s)\n    {φ : ι → α} (h : ∀ i : ι, φ i ∈ s i) : Tendsto φ atTop l := fun t ht =>\n  mem_map.2 <| (hl.eventually_subset ht).mono fun i hi => hi (h i)\n#align has_antitone_basis.tendsto has_antitone_basis.tendsto\n\n",
 "subseq_tendsto_of_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem subseq_tendsto_of_ne_bot {f : Filter α} [IsCountablyGenerated f] {u : ℕ → α}\n    (hx : NeBot («expr ⊓ » f (map u atTop))) : ∃ θ : ℕ → ℕ, StrictMono θ ∧ Tendsto (u ∘ θ) atTop f :=\n  by\n  obtain ⟨B, h⟩ := f.exists_antitone_basis\n  have : ∀ N, ∃ n ≥ N, u n ∈ B N := fun N =>\n    filter.inf_map_at_top_ne_bot_iff.mp hx _ (h.to_has_basis.mem_of_mem trivial) N\n  choose φ hφ using this\n  cases' forall_and_distrib.mp hφ with φ_ge φ_in\n  have lim_uφ : tendsto (u ∘ φ) at_top f := h.tendsto φ_in\n  have lim_φ : tendsto φ at_top at_top := tendsto_at_top_mono φ_ge tendsto_id\n  obtain ⟨ψ, hψ, hψφ⟩ : ∃ ψ : ℕ → ℕ, StrictMono ψ ∧ StrictMono (φ ∘ ψ)\n  exact strict_mono_subseq_of_tendsto_at_top lim_φ\n  exact ⟨φ ∘ ψ, hψφ, lim_uφ.comp hψ.tendsto_at_top⟩\n#align subseq_tendsto_of_ne_bot subseq_tendsto_of_ne_bot\n\n",
 "subseq_mem":
 "theorem tendsto.subseq_mem {F : Filter α} {V : ℕ → Set α} (h : ∀ n, V n ∈ F) {u : ℕ → α} (hu : Tendsto u atTop F) :\n    ∃ φ : ℕ → ℕ, StrictMono φ ∧ ∀ n, u (φ n) ∈ V n :=\n  extraction_forall_of_eventually' (fun n => tendsto_atTop'.mp hu _ (h n) : ∀ n, ∃ N, ∀ k ≥ N, u k ∈ V n)\n#align tendsto.subseq_mem tendsto.subseq_mem\n\n",
 "subseq_forall_of_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem subseq_forall_of_frequently {ι : Type _} {x : ℕ → ι} {p : ι → Prop} {l : Filter ι}\n    (h_tendsto : Tendsto x atTop l)\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n        (p (x n))) :\n    ∃ ns : ℕ → ℕ, Tendsto (fun n => x (ns n)) atTop l ∧ ∀ n, p (x (ns n)) :=\n  by\n  rw [tendsto_iff_seq_tendsto] at h_tendsto\n  choose ns hge hns using frequently_at_top.1 h\n  exact ⟨ns, h_tendsto ns (tendsto_at_top_mono hge tendsto_id), hns⟩\n#align subseq_forall_of_frequently subseq_forall_of_frequently\n\n",
 "subbasis_with_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- Given an antitone basis `s : ℕ → set α` of a filter, extract an antitone subbasis `s ∘ φ`,\n`φ : ℕ → ℕ`, such that `m < n` implies `r (φ m) (φ n)`. This lemma can be used to extract an\nantitone basis with basis sets decreasing \"sufficiently fast\". -/\ntheorem has_antitone_basis.subbasis_with_rel {f : Filter α} {s : ℕ → Set α} (hs : f.has_antitone_basis s)\n    {r : ℕ → ℕ → Prop}\n    (hr :\n      ∀ m,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n          (r m n)) :\n    ∃ φ : ℕ → ℕ, StrictMono φ ∧ (∀ ⦃m n⦄, m < n → r (φ m) (φ n)) ∧ f.has_antitone_basis (s ∘ φ) :=\n  by\n  rsuffices ⟨φ, hφ, hrφ⟩ : ∃ φ : ℕ → ℕ, StrictMono φ ∧ ∀ m n, m < n → r (φ m) (φ n)\n  · exact ⟨φ, hφ, hrφ, hs.comp_strict_mono hφ⟩\n  have :\n    ∀ t : Set ℕ,\n      t.finite →\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n          (∀ m ∈ t, m < n ∧ r m n) :=\n    fun t ht => (eventually_all_finite ht).2 fun m hm => (eventually_gt_at_top m).and (hr _)\n  rcases seq_of_forall_finite_exists fun t ht => (this t ht).exists with ⟨φ, hφ⟩\n  simp only [ball_image_iff, forall_and, mem_Iio] at hφ\n  exact ⟨φ, forall_swap.2 hφ.1, forall_swap.2 hφ.2⟩\n#align has_antitone_basis.subbasis_with_rel has_antitone_basis.subbasis_with_rel\n\n",
 "strict_mono_subseq_of_tendsto_at_top":
 "theorem strict_mono_subseq_of_tendsto_at_top {β : Type _} [linear_order β] [NoMaxOrder β] {u : ℕ → β}\n    (hu : Tendsto u atTop atTop) : ∃ φ : ℕ → ℕ, StrictMono φ ∧ StrictMono (u ∘ φ) :=\n  let ⟨φ, h, h'⟩ := extraction_of_frequently_atTop (frequently_high_scores hu)\n  ⟨φ, h, fun n m hnm => h' m _ (h hnm)⟩\n#align strict_mono_subseq_of_tendsto_at_top strict_mono_subseq_of_tendsto_at_top\n\n",
 "strict_mono_subseq_of_id_le":
 "theorem strict_mono_subseq_of_id_le {u : ℕ → ℕ} (hu : ∀ n, n ≤ u n) : ∃ φ : ℕ → ℕ, StrictMono φ ∧ StrictMono (u ∘ φ) :=\n  strictMono_subseq_of_tendsto_atTop (tendsto_atTop_mono hu tendsto_id)\n#align strict_mono_subseq_of_id_le strict_mono_subseq_of_id_le\n\n",
 "prod_map_prod_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem tendsto.prod_map_prod_at_top [SemilatticeSup γ] {F : Filter α} {G : Filter β} {f : α → γ} {g : β → γ}\n    (hf : Tendsto f F atTop) (hg : Tendsto g G atTop) : Tendsto (prod.map f g) (filter.prod F G) atTop :=\n  by\n  rw [← prod_at_top_at_top_eq]\n  exact hf.prod_map hg\n#align tendsto.prod_map_prod_at_top tendsto.prod_map_prod_at_top\n\n",
 "prod_map_prod_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem tendsto.prod_map_prod_at_bot [SemilatticeInf γ] {F : Filter α} {G : Filter β} {f : α → γ} {g : β → γ}\n    (hf : Tendsto f F atBot) (hg : Tendsto g G atBot) : Tendsto (prod.map f g) (filter.prod F G) atBot :=\n  by\n  rw [← prod_at_bot_at_bot_eq]\n  exact hf.prod_map hg\n#align tendsto.prod_map_prod_at_bot tendsto.prod_map_prod_at_bot\n\n",
 "prod_map_at_top_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_map_at_top_eq {α₁ α₂ β₁ β₂ : Type _} [SemilatticeSup β₁] [SemilatticeSup β₂] (u₁ : β₁ → α₁)\n    (u₂ : β₂ → α₂) : filter.prod (map u₁ atTop) (map u₂ atTop) = map (prod.map u₁ u₂) atTop := by\n  rw [prod_map_map_eq, prod_at_top_at_top_eq, Prod.map_def]\n#align prod_map_at_top_eq prod_map_at_top_eq\n\n",
 "prod_map_at_bot_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_map_at_bot_eq {α₁ α₂ β₁ β₂ : Type _} [SemilatticeInf β₁] [SemilatticeInf β₂] (u₁ : β₁ → α₁)\n    (u₂ : β₂ → α₂) : filter.prod (map u₁ atBot) (map u₂ atBot) = map (prod.map u₁ u₂) atBot :=\n  @prod_map_atTop_eq _ _ («expr ᵒᵈ» β₁) («expr ᵒᵈ» β₂) _ _ _ _\n#align prod_map_at_bot_eq prod_map_at_bot_eq\n\n",
 "prod_at_top_at_top_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_at_top_at_top_eq {β₁ β₂ : Type _} [SemilatticeSup β₁] [SemilatticeSup β₂] :\n    filter.prod (atTop : Filter β₁) (atTop : Filter β₂) = (atTop : Filter (β₁ × β₂)) :=\n  by\n  cases (isEmpty_or_nonempty β₁).symm\n  cases (isEmpty_or_nonempty β₂).symm\n  · simp [at_top, prod_infi_left, prod_infi_right, infᵢ_prod]\n    exact infᵢ_comm\n  · simp only [at_top.filter_eq_bot_of_is_empty, prod_bot]\n  · simp only [at_top.filter_eq_bot_of_is_empty, bot_prod]\n#align prod_at_top_at_top_eq prod_at_top_at_top_eq\n\n",
 "prod_at_top":
 "theorem tendsto.prod_at_top [SemilatticeSup α] [SemilatticeSup γ] {f g : α → γ} (hf : Tendsto f atTop atTop)\n    (hg : Tendsto g atTop atTop) : Tendsto (prod.map f g) atTop atTop :=\n  by\n  rw [← prod_at_top_at_top_eq]\n  exact hf.prod_map_prod_at_top hg\n#align tendsto.prod_at_top tendsto.prod_at_top\n\n",
 "prod_at_bot_at_bot_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_at_bot_at_bot_eq {β₁ β₂ : Type _} [SemilatticeInf β₁] [SemilatticeInf β₂] :\n    filter.prod (atBot : Filter β₁) (atBot : Filter β₂) = (atBot : Filter (β₁ × β₂)) :=\n  @prod_atTop_atTop_eq («expr ᵒᵈ» β₁) («expr ᵒᵈ» β₂) _ _\n#align prod_at_bot_at_bot_eq prod_at_bot_at_bot_eq\n\n",
 "prod_at_bot":
 "theorem tendsto.prod_at_bot [SemilatticeInf α] [SemilatticeInf γ] {f g : α → γ} (hf : Tendsto f atBot atBot)\n    (hg : Tendsto g atBot atBot) : Tendsto (prod.map f g) atBot atBot :=\n  by\n  rw [← prod_at_bot_at_bot_eq]\n  exact hf.prod_map_prod_at_bot hg\n#align tendsto.prod_at_bot tendsto.prod_at_bot\n\n",
 "nsmul_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.nsmul_at_top (hf : Tendsto f l atTop) {n : ℕ} (hn : 0 < n) :\n    Tendsto (fun x => «expr • » n (f x)) l atTop :=\n  tendsto_atTop.2 fun y =>\n    (tendsto_atTop.1 hf y).mp <|\n      (tendsto_atTop.1 hf 0).mono fun x h₀ hy =>\n        calc\n          y ≤ f x := hy\n          _ = «expr • » 1 (f x) := (one_nsmul _).symm\n          _ ≤ «expr • » n (f x) := nsmul_le_nsmul h₀ hn\n          \n#align tendsto.nsmul_at_top tendsto.nsmul_at_top\n\n",
 "nsmul_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tendsto.nsmul_at_bot (hf : Tendsto f l atBot) {n : ℕ} (hn : 0 < n) :\n    Tendsto (fun x => «expr • » n (f x)) l atBot :=\n  @Tendsto.nsmul_atTop α («expr ᵒᵈ» β) _ l f hf n hn\n#align tendsto.nsmul_at_bot tendsto.nsmul_at_bot\n\n",
 "not_tendsto_pow_at_top_at_bot":
 "theorem not_tendsto_pow_at_top_at_bot [LinearOrderedRing α] : ∀ {n : ℕ}, ¬Tendsto (fun x : α => x ^ n) atTop atBot\n  | 0 => by simp [not_tendsto_const_at_bot]\n  | n + 1 => (tendsto_pow_atTop n.succ_ne_zero).not_tendsto disjoint_atTop_atBot\n#align not_tendsto_pow_at_top_at_bot not_tendsto_pow_at_top_at_bot\n\n",
 "not_tendsto_iff_exists_frequently_nmem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem not_tendsto_iff_exists_frequently_nmem {α ι : Type _} {x : ι → α} {f : Filter α} {l : Filter ι} :\n    ¬Tendsto x l f ↔\n      ∃ s ∈ f,\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l\n          (x n ∉ s) :=\n  by\n  rw [tendsto_iff_forall_eventually_mem]\n  push_neg\n  refine' exists_congr fun s => _\n  rw [not_eventually, exists_prop]\n#align not_tendsto_iff_exists_frequently_nmem not_tendsto_iff_exists_frequently_nmem\n\n",
 "not_tendsto_const_at_top":
 "theorem not_tendsto_const_at_top [preorder α] [NoMaxOrder α] (x : α) (l : Filter β) [l.ne_bot] :\n    ¬Tendsto (fun _ => x) l atTop :=\n  tendsto_const_pure.not_tendsto (disjoint_pure_atTop x)\n#align not_tendsto_const_at_top not_tendsto_const_at_top\n\n",
 "not_tendsto_const_at_bot":
 "theorem not_tendsto_const_at_bot [preorder α] [NoMinOrder α] (x : α) (l : Filter β) [l.ne_bot] :\n    ¬Tendsto (fun _ => x) l atBot :=\n  tendsto_const_pure.not_tendsto (disjoint_pure_atBot x)\n#align not_tendsto_const_at_bot not_tendsto_const_at_bot\n\n",
 "nonneg_of_eventually_pow_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem nonneg_of_eventually_pow_nonneg [LinearOrderedRing α] {a : α}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n        (0 ≤ a ^ (n : ℕ))) :\n    0 ≤ a :=\n  let ⟨n, hn⟩ := (tendsto_bit1_atTop.eventually h).exists\n  pow_bit1_nonneg_iff.1 hn\n#align nonneg_of_eventually_pow_nonneg nonneg_of_eventually_pow_nonneg\n\n",
 "neg_const_mul_at_top":
 "/-- If a function tends to infinity along a filter, then this function multiplied by a negative\nconstant (on the left) tends to negative infinity. -/\ntheorem tendsto.neg_const_mul_at_top (hr : r < 0) (hf : Tendsto f l atTop) : Tendsto (fun x => r * f x) l atBot :=\n  (tendsto_const_mul_atBot_of_neg hr).2 hf\n#align tendsto.neg_const_mul_at_top tendsto.neg_const_mul_at_top\n\n",
 "neg_const_mul_at_bot":
 "/-- If a function tends to negative infinity along a filter, then this function multiplied by\na negative constant (on the left) tends to positive infinity. -/\ntheorem tendsto.neg_const_mul_at_bot (hr : r < 0) (hf : Tendsto f l atBot) : Tendsto (fun x => r * f x) l atTop :=\n  (tendsto_const_mul_atTop_of_neg hr).2 hf\n#align tendsto.neg_const_mul_at_bot tendsto.neg_const_mul_at_bot\n\n",
 "mem_at_top_sets":
 "@[simp]\ntheorem mem_at_top_sets [Nonempty α] [SemilatticeSup α] {s : Set α} :\n    s ∈ (atTop : Filter α) ↔ ∃ a : α, ∀ b ≥ a, b ∈ s :=\n  atTop_basis.mem_iff.trans <| exists_congr fun _ => exists_const _\n#align mem_at_top_sets mem_at_top_sets\n\n",
 "mem_at_top":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Jeremy Avigad, Yury Kudryashov, Patrick Massot\n-/\ntheorem mem_at_top [preorder α] (a : α) : { b : α | a ≤ b } ∈ @atTop α _ :=\n  mem_infᵢ_of_mem a <| Subset.refl _\n#align mem_at_top mem_at_top\n\n",
 "mem_at_bot_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem mem_at_bot_sets [Nonempty α] [SemilatticeInf α] {s : Set α} :\n    s ∈ (atBot : Filter α) ↔ ∃ a : α, ∀ b ≤ a, b ∈ s :=\n  @mem_atTop_sets («expr ᵒᵈ» α) _ _ _\n#align mem_at_bot_sets mem_at_bot_sets\n\n",
 "mem_at_bot":
 "theorem mem_at_bot [preorder α] (a : α) : { b : α | b ≤ a } ∈ @atBot α _ :=\n  mem_infᵢ_of_mem a <| Subset.refl _\n#align mem_at_bot mem_at_bot\n\n",
 "map_sub_at_top_eq_nat":
 "theorem map_sub_at_top_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=\n  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _) (fun a b _ => tsub_le_iff_right)\n    fun b _ => by rw [add_tsub_cancel_right]\n#align map_sub_at_top_eq_nat map_sub_at_top_eq_nat\n\n",
 "map_neg_at_top":
 "theorem map_neg_at_top : map (has_neg.neg : β → β) atTop = atBot :=\n  (OrderIso.neg β).map_at_top\n#align map_neg_at_top map_neg_at_top\n\n",
 "map_neg_at_bot":
 "theorem map_neg_at_bot : map (has_neg.neg : β → β) atBot = atTop :=\n  (OrderIso.neg β).map_at_bot\n#align map_neg_at_bot map_neg_at_bot\n\n",
 "map_div_at_top_eq_nat":
 "theorem map_div_at_top_eq_nat (k : ℕ) (hk : 0 < k) : map (fun a => a / k) atTop = atTop :=\n  map_atTop_eq_of_gc (fun b => b * k + (k - 1)) 1 (fun a b h => Nat.div_le_div_right h)\n    (fun a b _ =>\n      calc\n        a / k ≤ b ↔ a / k < b + 1 := by rw [← nat.succ_eq_add_one, Nat.lt_succ_iff]\n        _ ↔ a < (b + 1) * k := (nat.div_lt_iff_lt_mul hk)\n        _ ↔ _ := by\n          cases k\n          exact (lt_irrefl _ hk).elim\n          rw [add_mul, one_mul, nat.succ_sub_succ_eq_sub, tsub_zero, nat.add_succ, Nat.lt_succ_iff]\n        )\n    fun b _ =>\n    calc\n      b = b * k / k := by rw [nat.mul_div_cancel b hk]\n      _ ≤ (b * k + (k - 1)) / k := Nat.div_le_div_right <| nat.le_add_right _ _\n      \n#align map_div_at_top_eq_nat map_div_at_top_eq_nat\n\n",
 "map_coe_at_top_of_Ici_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_coe_at_top_of_Ici_subset [SemilatticeSup α] {a : α} {s : Set α} (h : Ici a ⊆ s) :\n    map (coe : s → α) atTop = atTop :=\n  by\n  have : Directed (· ≥ ·) fun x : s => (filter.principal) (Ici x) :=\n    by\n    intro x y\n    use ⟨«expr ⊔ » («expr ⊔ » x y) a, h le_sup_right⟩\n    simp only [ge_iff_le, principal_mono, Ici_subset_Ici, ← Subtype.coe_le_coe, Subtype.coe_mk]\n    exact ⟨le_sup_left.trans le_sup_left, le_sup_right.trans le_sup_left⟩\n  haveI : Nonempty s := ⟨⟨a, h le_rfl⟩⟩\n  simp only [le_antisymm_iff, at_top, le_infᵢ_iff, le_principal_iff, mem_map, mem_set_of_eq, map_infi_eq this,\n    map_principal]\n  constructor\n  · intro x\n    refine' mem_of_superset (mem_infi_of_mem ⟨«expr ⊔ » x a, h le_sup_right⟩ (mem_principal_self _)) _\n    rintro _ ⟨y, hy, rfl⟩\n    exact le_trans le_sup_left (Subtype.coe_le_coe.2 hy)\n  · intro x\n    filter_upwards [mem_at_top («expr ⊔ » (↑x) a)]with b hb\n    exact ⟨⟨b, h <| le_sup_right.trans hb⟩, Subtype.coe_le_coe.1 (le_sup_left.trans hb), rfl⟩\n#align map_coe_at_top_of_Ici_subset map_coe_at_top_of_Ici_subset\n\n",
 "map_coe_Ioi_at_top":
 "/-- The image of the filter `at_top` on `Ioi a` under the coercion equals `at_top`. -/\n@[simp]\ntheorem map_coe_Ioi_at_top [SemilatticeSup α] [NoMaxOrder α] (a : α) : map (coe : Ioi a → α) atTop = atTop :=\n  let ⟨b, hb⟩ := exists_gt a\n  map_val_atTop_of_Ici_subset <| Ici_subset_Ioi.2 hb\n#align map_coe_Ioi_at_top map_coe_Ioi_at_top\n\n",
 "map_coe_Iio_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient\norder. -/\n@[simp]\ntheorem map_coe_Iio_at_bot [SemilatticeInf α] [NoMinOrder α] (a : α) : map (coe : Iio a → α) atBot = atBot :=\n  @map_val_Ioi_atTop («expr ᵒᵈ» α) _ _ _\n#align map_coe_Iio_at_bot map_coe_Iio_at_bot\n\n",
 "map_coe_Iic_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient\norder. -/\n@[simp]\ntheorem map_coe_Iic_at_bot [SemilatticeInf α] (a : α) : map (coe : Iic a → α) atBot = atBot :=\n  @map_val_Ici_atTop («expr ᵒᵈ» α) _ _\n#align map_coe_Iic_at_bot map_coe_Iic_at_bot\n\n",
 "map_coe_Ici_at_top":
 "/-- The image of the filter `at_top` on `Ici a` under the coercion equals `at_top`. -/\n@[simp]\ntheorem map_coe_Ici_at_top [SemilatticeSup α] (a : α) : map (coe : Ici a → α) atTop = atTop :=\n  map_val_atTop_of_Ici_subset (Subset.refl _)\n#align map_coe_Ici_at_top map_coe_Ici_at_top\n\n",
 "map_at_top_finset_prod_le_of_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Let `f` and `g` be two maps to the same commutative monoid. This lemma gives a sufficient\ncondition for comparison of the filter `at_top.map (λ s, ∏ b in s, f b)` with\n`at_top.map (λ s, ∏ b in s, g b)`. This is useful to compare the set of limit points of\n`Π b in s, f b` as `s → at_top` with the similar set for `g`. -/\n@[to_additive\n      \"Let `f` and `g` be two maps to the same commutative additive monoid. This lemma gives\\na sufficient condition for comparison of the filter `at_top.map (λ s, ∑ b in s, f b)` with\\n`at_top.map (λ s, ∑ b in s, g b)`. This is useful to compare the set of limit points of\\n`∑ b in s, f b` as `s → at_top` with the similar set for `g`.\"]\ntheorem map_at_top_finset_prod_le_of_prod_eq [CommMonoid α] {f : β → α} {g : γ → α}\n    (h_eq :\n      ∀ u : Finset γ,\n        ∃ v : Finset β,\n          ∀ v',\n            v ⊆ v' →\n              ∃ u',\n                u ⊆ u' ∧\n                  finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" u'\n                      (g x) =\n                    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" v'\n                      (f b)) :\n    (atTop.map fun s : Finset β =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f b)) ≤\n      atTop.map fun s : Finset γ =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g x) :=\n  by\n  rw [map_at_top_eq, map_at_top_eq] <;>\n    exact\n      le_infᵢ fun b =>\n        let ⟨v, hv⟩ := h_eq b\n        infᵢ_le_of_le v <| by simp [Set.image_subset_iff] <;> exact hv\n#align map_at_top_finset_prod_le_of_prod_eq map_at_top_finset_prod_le_of_prod_eq\n\n",
 "map_at_top_eq_of_gc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- A function `f` maps upwards closed sets (at_top sets) to upwards closed sets when it is a\nGalois insertion. The Galois \"insertion\" and \"connection\" is weakened to only require it to be an\ninsertion and a connetion above `b'`. -/\ntheorem map_at_top_eq_of_gc [SemilatticeSup α] [SemilatticeSup β] {f : α → β} (g : β → α) (b' : β) (hf : Monotone f)\n    (gc : ∀ a, ∀ b ≥ b', f a ≤ b ↔ a ≤ g b) (hgi : ∀ b ≥ b', b ≤ f (g b)) : map f atTop = atTop :=\n  by\n  refine'\n    le_antisymm (hf.tendsto_at_top_at_top fun b => ⟨g («expr ⊔ » b b'), le_sup_left.trans <| hgi _ le_sup_right⟩) _\n  rw [@map_at_top_eq _ _ ⟨g b'⟩]\n  refine' le_infᵢ fun a => infᵢ_le_of_le («expr ⊔ » (f a) b') <| principal_mono.2 fun b hb => _\n  rw [mem_Ici, sup_le_iff] at hb\n  exact ⟨g b, (gc _ _ hb.2).1 hb.1, le_antisymm ((gc _ _ hb.2).2 le_rfl) (hgi _ hb.2)⟩\n#align map_at_top_eq_of_gc map_at_top_eq_of_gc\n\n",
 "map_at_top_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_at_top_eq [Nonempty α] [SemilatticeSup α] {f : α → β} :\n    atTop.map f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (filter.principal <| «expr '' » f { a' | a ≤ a' }) :=\n  (atTop_basis.map _).eq_infi\n#align map_at_top_eq map_at_top_eq\n\n",
 "map_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n@[simp]\ntheorem map_at_top (e : «expr ≃o » α β) : map (e : α → β) atTop = atTop := by\n  rw [← e.comap_at_top, map_comap_of_surjective e.surjective]\n#align map_at_top map_at_top\n\n",
 "map_at_bot_eq_of_gc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem map_at_bot_eq_of_gc [SemilatticeInf α] [SemilatticeInf β] {f : α → β} (g : β → α) (b' : β) (hf : Monotone f)\n    (gc : ∀ a, ∀ b ≤ b', b ≤ f a ↔ g b ≤ a) (hgi : ∀ b ≤ b', f (g b) ≤ b) : map f atBot = atBot :=\n  @map_atTop_eq_of_gc («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ _ _ _ hf.dual gc hgi\n#align map_at_bot_eq_of_gc map_at_bot_eq_of_gc\n\n",
 "map_at_bot_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_at_bot_eq [Nonempty α] [SemilatticeInf α] {f : α → β} :\n    atBot.map f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (filter.principal <| «expr '' » f { a' | a' ≤ a }) :=\n  @map_atTop_eq («expr ᵒᵈ» α) _ _ _ _\n#align map_at_bot_eq map_at_bot_eq\n\n",
 "map_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n@[simp]\ntheorem map_at_bot (e : «expr ≃o » α β) : map (e : α → β) atBot = atBot :=\n  e.dual.map_at_top\n#align map_at_bot map_at_bot\n\n",
 "map_atTop_finset_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » set.range[set.range] g) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print Function.Injective.map_atTop_finset_prod_eq /-\n/-- Let `g : γ → β` be an injective function and `f : β → α` be a function from the codomain of `g`\nto a commutative monoid. Suppose that `f x = 1` outside of the range of `g`. Then the filters\n`at_top.map (λ s, ∏ i in s, f (g i))` and `at_top.map (λ s, ∏ i in s, f i)` coincide.\n\nThe additive version of this lemma is used to prove the equality `∑' x, f (g x) = ∑' y, f y` under\nthe same assumptions.-/\n@[to_additive]\ntheorem Function.Injective.map_atTop_finset_prod_eq [CommMonoid α] {g : γ → β} (hg : function.injective g) {f : β → α}\n    (hf : ∀ (x) (_ : x ∉ Set.range g), f x = 1) :\n    map\n        (fun s =>\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f (g i)))\n        atTop =\n      map\n        (fun s =>\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i))\n        atTop :=\n  by\n  apply le_antisymm <;> refine' map_at_top_finset_prod_le_of_prod_eq fun s => _\n  · refine' ⟨s.preimage g (hg.inj_on _), fun t ht => _⟩\n    refine' ⟨t.image g ∪ s, Finset.subset_union_right _ _, _⟩\n    rw [← Finset.prod_image (hg.inj_on _)]\n    refine' (prod_subset (subset_union_left _ _) _).symm\n    simp only [Finset.mem_union, Finset.mem_image]\n    refine' fun y hy hyt => hf y (mt _ hyt)\n    rintro ⟨x, rfl⟩\n    exact ⟨x, ht (Finset.mem_preimage.2 <| hy.resolve_left hyt), rfl⟩\n  · refine' ⟨s.image g, fun t ht => _⟩\n    simp only [← prod_preimage _ _ (hg.inj_on _) _ fun x _ => hf x]\n    exact ⟨_, (image_subset_iff_subset_preimage _).1 ht, rfl⟩\n#align function.injective.map_at_top_finset_prod_eq Function.Injective.map_atTop_finset_prod_eq\n#align function.injective.map_at_top_finset_sum_eq Function.Injective.map_atTop_finset_sum_eq\n-/\n\n",
 "map_add_at_top_eq_nat":
 "theorem map_add_at_top_eq_nat (k : ℕ) : map (fun a => a + k) atTop = atTop :=\n  map_atTop_eq_of_gc (fun a => a - k) k (fun a b h => add_le_add_right h k) (fun a b h => (le_tsub_iff_right h).symm)\n    fun a h => by rw [tsub_add_cancel_of_le h]\n#align map_add_at_top_eq_nat map_add_at_top_eq_nat\n\n",
 "low_scores":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n-- see Note [nolint_ge]\n/-- If `u` is a sequence which is unbounded below,\nthen after any point, it reaches a value strictly smaller than all previous values.\n-/\n@[nolint ge_or_gt]\ntheorem low_scores [linear_order β] [NoMinOrder β] {u : ℕ → β} (hu : Tendsto u atTop atBot) :\n    ∀ N, ∃ n ≥ N, ∀ k < n, u n < u k :=\n  @high_scores («expr ᵒᵈ» β) _ _ _ hu\n#align low_scores low_scores\n\n",
 "inf_map_at_top_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_map_at_top_ne_bot_iff [SemilatticeSup α] [Nonempty α] {F : Filter β} {u : α → β} :\n    NeBot («expr ⊓ » F (map u atTop)) ↔ ∀ U ∈ F, ∀ N, ∃ n ≥ N, u n ∈ U := by\n  simp_rw [inf_ne_bot_iff_frequently_left, frequently_map, frequently_at_top] <;> rfl\n#align inf_map_at_top_ne_bot_iff inf_map_at_top_ne_bot_iff\n\n",
 "inf_map_at_bot_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_map_at_bot_ne_bot_iff [SemilatticeInf α] [Nonempty α] {F : Filter β} {u : α → β} :\n    NeBot («expr ⊓ » F (map u atBot)) ↔ ∀ U ∈ F, ∀ N, ∃ n ≤ N, u n ∈ U :=\n  @inf_map_atTop_neBot_iff («expr ᵒᵈ» α) _ _ _ _ _\n#align inf_map_at_bot_ne_bot_iff inf_map_at_bot_ne_bot_iff\n\n",
 "high_scores":
 "/-- If `u` is a sequence which is unbounded above,\nthen after any point, it reaches a value strictly greater than all previous values.\n-/\ntheorem high_scores [linear_order β] [NoMaxOrder β] {u : ℕ → β} (hu : Tendsto u atTop atTop) :\n    ∀ N, ∃ n ≥ N, ∀ k < n, u k < u n := by\n  intro N\n  obtain ⟨k : ℕ, hkn : k ≤ N, hku : ∀ l ≤ N, u l ≤ u k⟩ : ∃ k ≤ N, ∀ l ≤ N, u l ≤ u k\n  exact exists_max_image _ u (finite_le_nat N) ⟨N, le_refl N⟩\n  have ex : ∃ n ≥ N, u k < u n := exists_lt_of_tendsto_at_top hu _ _\n  obtain ⟨n : ℕ, hnN : n ≥ N, hnk : u k < u n, hn_min : ∀ m, m < n → N ≤ m → u m ≤ u k⟩ :\n    ∃ n ≥ N, u k < u n ∧ ∀ m, m < n → N ≤ m → u m ≤ u k :=\n    by\n    rcases nat.find_x ex with ⟨n, ⟨hnN, hnk⟩, hn_min⟩\n    push_neg  at hn_min\n    exact ⟨n, hnN, hnk, hn_min⟩\n  use n, hnN\n  rintro (l : ℕ) (hl : l < n)\n  have hlk : u l ≤ u k := by\n    cases' (le_total l N : l ≤ N ∨ N ≤ l) with H H\n    · exact hku l H\n    · exact hn_min l hl H\n  calc\n    u l ≤ u k := hlk\n    _ < u n := hnk\n    \n#align high_scores high_scores\n\n",
 "frequently_low_scores":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/-- If `u` is a sequence which is unbounded below,\nthen it `frequently` reaches a value strictly smaller than all previous values.\n-/\ntheorem frequently_low_scores [linear_order β] [NoMinOrder β] {u : ℕ → β} (hu : Tendsto u atTop atBot) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n      (∀ k < n, u n < u k) :=\n  @frequently_high_scores («expr ᵒᵈ» β) _ _ _ hu\n#align frequently_low_scores frequently_low_scores\n\n",
 "frequently_iff_seq_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_iff_seq_frequently {ι : Type _} {l : Filter ι} {p : ι → Prop} [hl : l.is_countably_generated] :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l (p n) ↔\n      ∃ x : ℕ → ι,\n        Tendsto x atTop l ∧\n          «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n            (p (x n)) :=\n  by\n  refine' ⟨fun h_freq => _, fun h_exists_freq => _⟩\n  · have : ne_bot («expr ⊓ » l ((filter.principal) { x : ι | p x })) := by simpa [ne_bot_iff, inf_principal_eq_bot]\n    obtain ⟨x, hx⟩ := exists_seq_tendsto («expr ⊓ » l ((filter.principal) { x : ι | p x }))\n    rw [tendsto_inf] at hx\n    cases' hx with hx_l hx_p\n    refine' ⟨x, hx_l, _⟩\n    rw [tendsto_principal] at hx_p\n    exact hx_p.frequently\n  · obtain ⟨x, hx_tendsto, hx_freq⟩ := h_exists_freq\n    simp_rw [Filter.Frequently, Filter.Eventually] at hx_freq⊢\n    have : { n : ℕ | ¬p (x n) } = { n | x n ∈ { y | ¬p y } } := rfl\n    rw [this, ← mem_map'] at hx_freq\n    contrapose! hx_freq\n    exact hx_tendsto hx_freq\n#align frequently_iff_seq_frequently frequently_iff_seq_frequently\n\n",
 "frequently_high_scores":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/-- If `u` is a sequence which is unbounded above,\nthen it `frequently` reaches a value strictly greater than all previous values.\n-/\ntheorem frequently_high_scores [linear_order β] [NoMaxOrder β] {u : ℕ → β} (hu : Tendsto u atTop atTop) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n      (∀ k < n, u k < u n) :=\n  by simpa [frequently_at_top] using high_scores hu\n#align frequently_high_scores frequently_high_scores\n\n",
 "frequently_at_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_at_top' [SemilatticeSup α] [Nonempty α] [NoMaxOrder α] {p : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n        (p x) ↔\n      ∀ a, ∃ b > a, p b :=\n  by simp [at_top_basis_Ioi.frequently_iff]\n#align frequently_at_top' frequently_at_top'\n\n",
 "frequently_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_at_top [SemilatticeSup α] [Nonempty α] {p : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n        (p x) ↔\n      ∀ a, ∃ b ≥ a, p b :=\n  by simp [at_top_basis.frequently_iff]\n#align frequently_at_top frequently_at_top\n\n",
 "frequently_at_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_at_bot' [SemilatticeInf α] [Nonempty α] [NoMinOrder α] {p : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atBot\n        (p x) ↔\n      ∀ a, ∃ b < a, p b :=\n  @frequently_atTop' («expr ᵒᵈ» α) _ _ _ _\n#align frequently_at_bot' frequently_at_bot'\n\n",
 "frequently_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently_at_bot [SemilatticeInf α] [Nonempty α] {p : α → Prop} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atBot\n        (p x) ↔\n      ∀ a, ∃ b ≤ a, p b :=\n  @frequently_atTop («expr ᵒᵈ» α) _ _ _\n#align frequently_at_bot frequently_at_bot\n\n",
 "forall_exists_of_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently.forall_exists_of_at_top [SemilatticeSup α] [Nonempty α] {p : α → Prop}\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n        (p x)) :\n    ∀ a, ∃ b ≥ a, p b :=\n  frequently_atTop.mp h\n#align frequently.forall_exists_of_at_top frequently.forall_exists_of_at_top\n\n",
 "forall_exists_of_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem frequently.forall_exists_of_at_bot [SemilatticeInf α] [Nonempty α] {p : α → Prop}\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atBot\n        (p x)) :\n    ∀ a, ∃ b ≤ a, p b :=\n  frequently_atBot.mp h\n#align frequently.forall_exists_of_at_bot frequently.forall_exists_of_at_bot\n\n",
 "extraction_of_frequently_at_top'":
 "theorem extraction_of_frequently_at_top' {P : ℕ → Prop} (h : ∀ N, ∃ n > N, P n) :\n    ∃ φ : ℕ → ℕ, StrictMono φ ∧ ∀ n, P (φ n) := by\n  choose u hu using h\n  cases' forall_and_distrib.mp hu with hu hu'\n  exact ⟨u ∘ nat.rec 0 fun n v => u v, strictMono_nat_of_lt_succ fun n => hu _, fun n => hu' _⟩\n#align extraction_of_frequently_at_top' extraction_of_frequently_at_top'\n\n",
 "extraction_of_frequently_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem extraction_of_frequently_at_top {P : ℕ → Prop}\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n        (P n)) :\n    ∃ φ : ℕ → ℕ, StrictMono φ ∧ ∀ n, P (φ n) :=\n  by\n  rw [frequently_at_top'] at h\n  exact extraction_of_frequently_at_top' h\n#align extraction_of_frequently_at_top extraction_of_frequently_at_top\n\n",
 "extraction_of_eventually_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem extraction_of_eventually_at_top {P : ℕ → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n        (P n)) :\n    ∃ φ : ℕ → ℕ, StrictMono φ ∧ ∀ n, P (φ n) :=\n  extraction_of_frequently_atTop h.frequently\n#align extraction_of_eventually_at_top extraction_of_eventually_at_top\n\n",
 "extraction_forall_of_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem extraction_forall_of_frequently {P : ℕ → ℕ → Prop}\n    (h :\n      ∀ n,\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n          (P n k)) :\n    ∃ φ : ℕ → ℕ, StrictMono φ ∧ ∀ n, P n (φ n) :=\n  by\n  simp only [frequently_at_top'] at h\n  choose u hu hu' using h\n  use (fun n => nat.rec_on n (u 0 0) fun n v => u (n + 1) v : ℕ → ℕ)\n  constructor\n  · apply strictMono_nat_of_lt_succ\n    intro n\n    apply hu\n  · intro n\n    cases n <;> simp [hu']\n#align extraction_forall_of_frequently extraction_forall_of_frequently\n\n",
 "extraction_forall_of_eventually'":
 "theorem extraction_forall_of_eventually' {P : ℕ → ℕ → Prop} (h : ∀ n, ∃ N, ∀ k ≥ N, P n k) :\n    ∃ φ : ℕ → ℕ, StrictMono φ ∧ ∀ n, P n (φ n) :=\n  extraction_forall_of_eventually (by simp [eventually_at_top, h])\n#align extraction_forall_of_eventually' extraction_forall_of_eventually'\n\n",
 "extraction_forall_of_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem extraction_forall_of_eventually {P : ℕ → ℕ → Prop}\n    (h :\n      ∀ n,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n          (P n k)) :\n    ∃ φ : ℕ → ℕ, StrictMono φ ∧ ∀ n, P n (φ n) :=\n  extraction_forall_of_frequently fun n => (h n).frequently\n#align extraction_forall_of_eventually extraction_forall_of_eventually\n\n",
 "exists_seq_tendsto":
 "/-- If `f` is a nontrivial countably generated filter, then there exists a sequence that converges\nto `f`. -/\ntheorem exists_seq_tendsto (f : Filter α) [IsCountablyGenerated f] [NeBot f] : ∃ x : ℕ → α, Tendsto x atTop f :=\n  by\n  obtain ⟨B, h⟩ := f.exists_antitone_basis\n  choose x hx using fun n => Filter.nonempty_of_mem (h.mem n)\n  exact ⟨x, h.tendsto hx⟩\n#align exists_seq_tendsto exists_seq_tendsto\n\n",
 "exists_seq_forall_of_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem exists_seq_forall_of_frequently {ι : Type _} {l : Filter ι} {p : ι → Prop} [hl : l.is_countably_generated]\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l (p n)) :\n    ∃ ns : ℕ → ι, Tendsto ns atTop l ∧ ∀ n, p (ns n) :=\n  by\n  rw [frequently_iff_seq_frequently] at h\n  obtain ⟨x, hx_tendsto, hx_freq⟩ := h\n  obtain ⟨n_to_n, h_tendsto, h_freq⟩ := subseq_forall_of_frequently hx_tendsto hx_freq\n  exact ⟨x ∘ n_to_n, h_tendsto, h_freq⟩\n#align exists_seq_forall_of_frequently exists_seq_forall_of_frequently\n\n",
 "exists_lt_of_tendsto_at_top":
 "theorem exists_lt_of_tendsto_at_top [SemilatticeSup α] [preorder β] [NoMaxOrder β] {u : α → β}\n    (h : Tendsto u atTop atTop) (a : α) (b : β) : ∃ a' ≥ a, b < u a' :=\n  by\n  cases' exists_gt b with b' hb'\n  rcases exists_le_of_tendsto_at_top h a b' with ⟨a', ha', ha''⟩\n  exact ⟨a', ha', lt_of_lt_of_le hb' ha''⟩\n#align exists_lt_of_tendsto_at_top exists_lt_of_tendsto_at_top\n\n",
 "exists_lt_of_tendsto_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n-- see Note [nolint_ge]\n@[nolint ge_or_gt]\ntheorem exists_lt_of_tendsto_at_bot [SemilatticeSup α] [preorder β] [NoMinOrder β] {u : α → β}\n    (h : Tendsto u atTop atBot) : ∀ a b, ∃ a' ≥ a, u a' < b :=\n  @exists_lt_of_tendsto_atTop _ («expr ᵒᵈ» β) _ _ _ _ h\n#align exists_lt_of_tendsto_at_bot exists_lt_of_tendsto_at_bot\n\n",
 "exists_lt_mul_self":
 "#print exists_lt_mul_self /-\ntheorem exists_lt_mul_self (a : R) : ∃ x ≥ 0, a < x * x :=\n  let ⟨x, hxa, hx0⟩ := ((tendsto_mul_self_atTop.eventually (eventually_gt_atTop a)).and (eventually_ge_atTop 0)).exists\n  ⟨x, hx0, hxa⟩\n#align exists_lt_mul_self exists_lt_mul_self\n-/\n\n",
 "exists_le_of_tendsto_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem exists_le_of_tendsto_at_top [SemilatticeSup α] [preorder β] {u : α → β} (h : Tendsto u atTop atTop) (a : α)\n    (b : β) : ∃ a' ≥ a, b ≤ u a' :=\n  by\n  have :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (a ≤ x ∧ b ≤ u x) :=\n    (eventually_ge_at_top a).and (h.eventually <| eventually_ge_at_top b)\n  haveI : Nonempty α := ⟨a⟩\n  rcases this.exists with ⟨a', ha, hb⟩\n  exact ⟨a', ha, hb⟩\n#align exists_le_of_tendsto_at_top exists_le_of_tendsto_at_top\n\n",
 "exists_le_of_tendsto_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n-- see Note [nolint_ge]\n@[nolint ge_or_gt]\ntheorem exists_le_of_tendsto_at_bot [SemilatticeSup α] [preorder β] {u : α → β} (h : Tendsto u atTop atBot) :\n    ∀ a b, ∃ a' ≥ a, u a' ≤ b :=\n  @exists_le_of_tendsto_atTop _ («expr ᵒᵈ» β) _ _ _ h\n#align exists_le_of_tendsto_at_bot exists_le_of_tendsto_at_bot\n\n",
 "exists_le_mul_self":
 "#print exists_le_mul_self /-\ntheorem exists_le_mul_self (a : R) : ∃ x ≥ 0, a ≤ x * x :=\n  let ⟨x, hx0, hxa⟩ := exists_lt_mul_self a\n  ⟨x, hx0, hxa.le⟩\n#align exists_le_mul_self exists_le_mul_self\n-/\n\n",
 "exists_forall_of_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually.exists_forall_of_at_top [SemilatticeSup α] [Nonempty α] {p : α → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n        (p x)) :\n    ∃ a, ∀ b ≥ a, p b :=\n  eventually_atTop.mp h\n#align eventually.exists_forall_of_at_top eventually.exists_forall_of_at_top\n\n",
 "exists_forall_of_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually.exists_forall_of_at_bot [SemilatticeInf α] [Nonempty α] {p : α → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atBot\n        (p x)) :\n    ∃ a, ∀ b ≤ a, p b :=\n  eventually_atBot.mp h\n#align eventually.exists_forall_of_at_bot eventually.exists_forall_of_at_bot\n\n",
 "eventually_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem has_antitone_basis.eventually_subset [preorder ι] {l : Filter α} {s : ι → Set α} (hl : l.has_antitone_basis s)\n    {t : Set α} (ht : t ∈ l) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n      (s i ⊆ t) :=\n  let ⟨i, _, hi⟩ := hl.to_has_basis.mem_iff.1 ht\n  (eventually_ge_atTop i).mono fun j hj => (hl.antitone hj).trans hi\n#align has_antitone_basis.eventually_subset has_antitone_basis.eventually_subset\n\n",
 "eventually_ne_at_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.eventually_ne_at_top' [preorder β] [NoMaxOrder β] {f : α → β} {l : Filter α} (hf : Tendsto f l atTop)\n    (c : α) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l (x ≠ c) :=\n  (hf.eventually_ne_at_top (f c)).mono fun x => ne_of_apply_ne f\n#align tendsto.eventually_ne_at_top' tendsto.eventually_ne_at_top'\n\n",
 "eventually_ne_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.eventually_ne_at_top [preorder β] [NoMaxOrder β] {f : α → β} {l : Filter α} (hf : Tendsto f l atTop)\n    (c : β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (f x ≠ c) :=\n  hf.eventually (eventually_ne_atTop c)\n#align tendsto.eventually_ne_at_top tendsto.eventually_ne_at_top\n\n",
 "eventually_ne_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.eventually_ne_at_bot [preorder β] [NoMinOrder β] {f : α → β} {l : Filter α} (hf : Tendsto f l atBot)\n    (c : β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (f x ≠ c) :=\n  hf.eventually (eventually_ne_atBot c)\n#align tendsto.eventually_ne_at_bot tendsto.eventually_ne_at_bot\n\n",
 "eventually_lt_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.eventually_lt_at_bot [preorder β] [NoMinOrder β] {f : α → β} {l : Filter α} (hf : Tendsto f l atBot)\n    (c : β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (f x < c) :=\n  hf.eventually (eventually_lt_atBot c)\n#align tendsto.eventually_lt_at_bot tendsto.eventually_lt_at_bot\n\n",
 "eventually_le_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.eventually_le_at_bot [preorder β] {f : α → β} {l : Filter α} (hf : Tendsto f l atBot) (c : β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (f x ≤ c) :=\n  hf.eventually (eventually_le_atBot c)\n#align tendsto.eventually_le_at_bot tendsto.eventually_le_at_bot\n\n",
 "eventually_iff_seq_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_iff_seq_eventually {ι : Type _} {l : Filter ι} {p : ι → Prop} [hl : l.is_countably_generated] :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l (p n) ↔\n      ∀ x : ℕ → ι,\n        Tendsto x atTop l →\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n            (p (x n)) :=\n  by\n  have :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l (p n) ↔\n      ¬«expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l ¬p n :=\n    by\n    rw [not_frequently]\n    simp_rw [Classical.not_not]\n  rw [this, frequently_iff_seq_frequently]\n  push_neg\n  simp_rw [not_frequently, Classical.not_not]\n#align eventually_iff_seq_eventually eventually_iff_seq_eventually\n\n",
 "eventually_gt_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.eventually_gt_at_top [preorder β] [NoMaxOrder β] {f : α → β} {l : Filter α} (hf : Tendsto f l atTop)\n    (c : β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (c < f x) :=\n  hf.eventually (eventually_gt_atTop c)\n#align tendsto.eventually_gt_at_top tendsto.eventually_gt_at_top\n\n",
 "eventually_ge_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto.eventually_ge_at_top [preorder β] {f : α → β} {l : Filter α} (hf : Tendsto f l atTop) (c : β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (c ≤ f x) :=\n  hf.eventually (eventually_ge_atTop c)\n#align tendsto.eventually_ge_at_top tendsto.eventually_ge_at_top\n\n",
 "eventually_at_top_prod_self'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_at_top_prod_self' [SemilatticeSup α] [Nonempty α] {p : α × α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n        (p x) ↔\n      ∃ a, ∀ k ≥ a, ∀ l ≥ a, p (k, l) :=\n  by\n  rw [Filter.eventually_atTop_prod_self]\n  apply exists_congr\n  tauto\n#align eventually_at_top_prod_self' eventually_at_top_prod_self'\n\n",
 "eventually_at_top_prod_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_at_top_prod_self [SemilatticeSup α] [Nonempty α] {p : α × α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n        (p x) ↔\n      ∃ a, ∀ k l, a ≤ k → a ≤ l → p (k, l) :=\n  by simp [← prod_at_top_at_top_eq, at_top_basis.prod_self.eventually_iff]\n#align eventually_at_top_prod_self eventually_at_top_prod_self\n\n",
 "eventually_at_top_curry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_at_top_curry [SemilatticeSup α] [SemilatticeSup β] {p : α × β → Prop}\n    (hp :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        Filter.atTop (p x)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n      («expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n        (p (k, l))) :=\n  by\n  rw [← prod_at_top_at_top_eq] at hp\n  exact hp.curry\n#align eventually_at_top_curry eventually_at_top_curry\n\n",
 "eventually_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_at_top [SemilatticeSup α] [Nonempty α] {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atTop\n        (p x) ↔\n      ∃ a, ∀ b ≥ a, p b :=\n  mem_atTop_sets\n#align eventually_at_top eventually_at_top\n\n",
 "eventually_at_bot_prod_self'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_at_bot_prod_self' [SemilatticeInf α] [Nonempty α] {p : α × α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atBot\n        (p x) ↔\n      ∃ a, ∀ k ≤ a, ∀ l ≤ a, p (k, l) :=\n  by\n  rw [Filter.eventually_atBot_prod_self]\n  apply exists_congr\n  tauto\n#align eventually_at_bot_prod_self' eventually_at_bot_prod_self'\n\n",
 "eventually_at_bot_prod_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_at_bot_prod_self [SemilatticeInf α] [Nonempty α] {p : α × α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atBot\n        (p x) ↔\n      ∃ a, ∀ k l, k ≤ a → l ≤ a → p (k, l) :=\n  by simp [← prod_at_bot_at_bot_eq, at_bot_basis.prod_self.eventually_iff]\n#align eventually_at_bot_prod_self eventually_at_bot_prod_self\n\n",
 "eventually_at_bot_curry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_at_bot_curry [SemilatticeInf α] [SemilatticeInf β] {p : α × β → Prop}\n    (hp :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        Filter.atBot (p x)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atBot\n      («expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atBot\n        (p (k, l))) :=\n  @eventually_atTop_curry («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ _ hp\n#align eventually_at_bot_curry eventually_at_bot_curry\n\n",
 "eventually_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[simp]\ntheorem eventually_at_bot [SemilatticeInf α] [Nonempty α] {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" atBot\n        (p x) ↔\n      ∃ a, ∀ b ≤ a, p b :=\n  mem_atBot_sets\n#align eventually_at_bot eventually_at_bot\n\n",
 "disjoint_pure_at_top":
 "theorem disjoint_pure_at_top [preorder α] [NoMaxOrder α] (x : α) : Disjoint (pure x) atTop :=\n  Disjoint.symm ((disjoint_atTop_principal_Iic x).mono_right <| le_principal_iff.2 le_rfl)\n#align disjoint_pure_at_top disjoint_pure_at_top\n\n",
 "disjoint_pure_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem disjoint_pure_at_bot [preorder α] [NoMinOrder α] (x : α) : Disjoint (pure x) atBot :=\n  @disjoint_pure_atTop («expr ᵒᵈ» α) _ _ _\n#align disjoint_pure_at_bot disjoint_pure_at_bot\n\n",
 "disjoint_at_top_principal_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem disjoint_at_top_principal_Iio [preorder α] (x : α) : Disjoint atTop ((filter.principal) (Iio x)) :=\n  @disjoint_atBot_principal_Ioi («expr ᵒᵈ» α) _ _\n#align disjoint_at_top_principal_Iio disjoint_at_top_principal_Iio\n\n",
 "disjoint_at_top_principal_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem disjoint_at_top_principal_Iic [preorder α] [NoMaxOrder α] (x : α) :\n    Disjoint atTop ((filter.principal) (Iic x)) :=\n  disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl).symm (Ioi_mem_atTop x) (mem_principal_self _)\n#align disjoint_at_top_principal_Iic disjoint_at_top_principal_Iic\n\n",
 "disjoint_at_top_at_bot":
 "theorem disjoint_at_top_at_bot [partial_order α] [Nontrivial α] : Disjoint (atTop : Filter α) atBot :=\n  disjoint_atBot_atTop.symm\n#align disjoint_at_top_at_bot disjoint_at_top_at_bot\n\n",
 "disjoint_at_bot_principal_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem disjoint_at_bot_principal_Ioi [preorder α] (x : α) : Disjoint atBot ((filter.principal) (Ioi x)) :=\n  disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl) (Iic_mem_atBot x) (mem_principal_self _)\n#align disjoint_at_bot_principal_Ioi disjoint_at_bot_principal_Ioi\n\n",
 "disjoint_at_bot_principal_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem disjoint_at_bot_principal_Ici [preorder α] [NoMinOrder α] (x : α) :\n    Disjoint atBot ((filter.principal) (Ici x)) :=\n  @disjoint_atTop_principal_Iic («expr ᵒᵈ» α) _ _ _\n#align disjoint_at_bot_principal_Ici disjoint_at_bot_principal_Ici\n\n",
 "disjoint_at_bot_at_top":
 "theorem disjoint_at_bot_at_top [partial_order α] [Nontrivial α] : Disjoint (atBot : Filter α) atTop :=\n  by\n  rcases exists_pair_ne α with ⟨x, y, hne⟩\n  by_cases hle : x ≤ y\n  · refine' disjoint_of_disjoint_of_mem _ (Iic_mem_at_bot x) (Ici_mem_at_top y)\n    exact Iic_disjoint_Ici.2 (hle.lt_of_ne hne).not_le\n  · refine' disjoint_of_disjoint_of_mem _ (Iic_mem_at_bot y) (Ici_mem_at_top x)\n    exact Iic_disjoint_Ici.2 hle\n#align disjoint_at_bot_at_top disjoint_at_bot_at_top\n\n",
 "const_mul_at_top":
 "/-- If a function tends to infinity along a filter, then this function multiplied by a positive\nconstant (on the left) also tends to infinity. For a version working in `ℕ` or `ℤ`, use\n`filter.tendsto.const_mul_at_top'` instead. -/\ntheorem tendsto.const_mul_at_top (hr : 0 < r) (hf : Tendsto f l atTop) : Tendsto (fun x => r * f x) l atTop :=\n  (tendsto_const_mul_atTop_of_pos hr).2 hf\n#align tendsto.const_mul_at_top tendsto.const_mul_at_top\n\n",
 "const_mul_at_bot":
 "/-- If a function tends to negative infinity along a filter, then this function multiplied by\na positive constant (on the left) also tends to negative infinity. -/\ntheorem tendsto.const_mul_at_bot (hr : 0 < r) (hf : Tendsto f l atBot) : Tendsto (fun x => r * f x) l atBot :=\n  (tendsto_const_mul_atBot_of_pos hr).2 hf\n#align tendsto.const_mul_at_bot tendsto.const_mul_at_bot\n\n",
 "comp_strict_mono":
 "theorem has_antitone_basis.comp_strict_mono {l : Filter α} {s : ℕ → Set α} (hs : l.has_antitone_basis s) {φ : ℕ → ℕ}\n    (hφ : StrictMono φ) : l.has_antitone_basis (s ∘ φ) :=\n  hs.comp_mono hφ.monotone hφ.tendsto_at_top\n#align has_antitone_basis.comp_strict_mono has_antitone_basis.comp_strict_mono\n\n",
 "comp_mono":
 "theorem has_antitone_basis.comp_mono [SemilatticeSup ι] [Nonempty ι] [preorder ι'] {l : Filter α} {s : ι' → Set α}\n    (hs : l.has_antitone_basis s) {φ : ι → ι'} (φ_mono : Monotone φ) (hφ : Tendsto φ atTop atTop) :\n    l.has_antitone_basis (s ∘ φ) :=\n  ⟨hs.to_has_basis.to_has_basis\n      (fun n hn => (hφ.eventually (eventually_ge_atTop n)).exists.imp fun m hm => ⟨trivial, hs.antitone hm⟩) fun n hn =>\n      ⟨φ n, trivial, Subset.rfl⟩,\n    hs.antitone.comp_monotone φ_mono⟩\n#align has_antitone_basis.comp_mono has_antitone_basis.comp_mono\n\n",
 "comap_neg_at_top":
 "@[simp]\ntheorem comap_neg_at_top : comap (has_neg.neg : β → β) atTop = atBot :=\n  (OrderIso.neg β).comap_at_bot\n#align comap_neg_at_top comap_neg_at_top\n\n",
 "comap_neg_at_bot":
 "@[simp]\ntheorem comap_neg_at_bot : comap (has_neg.neg : β → β) atBot = atTop :=\n  (OrderIso.neg β).comap_at_top\n#align comap_neg_at_bot comap_neg_at_bot\n\n",
 "comap_embedding_at_top":
 "theorem comap_embedding_at_top [preorder β] [preorder γ] {e : β → γ} (hm : ∀ b₁ b₂, e b₁ ≤ e b₂ ↔ b₁ ≤ b₂)\n    (hu : ∀ c, ∃ b, c ≤ e b) : comap e atTop = atTop :=\n  le_antisymm (le_infᵢ fun b => le_principal_iff.2 <| mem_comap.2 ⟨Ici (e b), mem_atTop _, fun x => (hm _ _).1⟩)\n    (tendsto_atTop_atTop_of_monotone (fun _ _ => (hm _ _).2) hu).le_comap\n#align comap_embedding_at_top comap_embedding_at_top\n\n",
 "comap_embedding_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem comap_embedding_at_bot [preorder β] [preorder γ] {e : β → γ} (hm : ∀ b₁ b₂, e b₁ ≤ e b₂ ↔ b₁ ≤ b₂)\n    (hu : ∀ c, ∃ b, e b ≤ c) : comap e atBot = atBot :=\n  @comap_embedding_atTop («expr ᵒᵈ» β) («expr ᵒᵈ» γ) _ _ e (function.swap hm) hu\n#align comap_embedding_at_bot comap_embedding_at_bot\n\n",
 "comap_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n@[simp]\ntheorem comap_at_top (e : «expr ≃o » α β) : comap e atTop = atTop := by simp [at_top, ← e.surjective.infi_comp]\n#align comap_at_top comap_at_top\n\n",
 "comap_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n@[simp]\ntheorem comap_at_bot (e : «expr ≃o » α β) : comap e atBot = atBot :=\n  e.dual.comap_at_top\n#align comap_at_bot comap_at_bot\n\n",
 "comap_abs_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem comap_abs_at_top : comap (abs : α → α) atTop = «expr ⊔ » atBot atTop :=\n  by\n  refine'\n    le_antisymm (((at_top_basis.comap _).le_basis_iff (at_bot_basis.sup at_top_basis)).2 _)\n      (sup_le tendsto_abs_at_bot_at_top.le_comap tendsto_abs_at_top_at_top.le_comap)\n  rintro ⟨a, b⟩ -\n  refine' ⟨max (-a) b, trivial, fun x hx => _⟩\n  rw [mem_preimage, mem_Ici, le_abs', max_le_iff, ← min_neg_neg, le_min_iff, neg_neg] at hx\n  exact hx.imp And.left And.right\n#align comap_abs_at_top comap_abs_at_top\n\n",
 "at_top_of_mul_const":
 "theorem tendsto.at_top_of_mul_const {c : α} (hc : 0 < c) (hf : Tendsto (fun x => f x * c) l atTop) :\n    Tendsto f l atTop :=\n  tendsto_atTop.2 fun b => (tendsto_atTop.1 hf (b * c)).mono fun x hx => le_of_mul_le_mul_right hx hc\n#align tendsto.at_top_of_mul_const tendsto.at_top_of_mul_const\n\n",
 "at_top_of_const_mul":
 "theorem tendsto.at_top_of_const_mul {c : α} (hc : 0 < c) (hf : Tendsto (fun x => c * f x) l atTop) :\n    Tendsto f l atTop :=\n  tendsto_atTop.2 fun b => (tendsto_atTop.1 hf (c * b)).mono fun x hx => le_of_mul_le_mul_left hx hc\n#align tendsto.at_top_of_const_mul tendsto.at_top_of_const_mul\n\n",
 "at_top_ne_bot":
 "@[instance]\ntheorem at_top_ne_bot [Nonempty α] [SemilatticeSup α] : NeBot (atTop : Filter α) :=\n  atTop_basis.ne_bot_iff.2 fun a _ => nonempty_Ici\n#align at_top_ne_bot at_top_ne_bot\n\n",
 "at_top_mul_neg_const":
 "/-- If a function tends to infinity along a filter, then this function multiplied by a negative\nconstant (on the right) tends to negative infinity. -/\ntheorem tendsto.at_top_mul_neg_const (hr : r < 0) (hf : Tendsto f l atTop) : Tendsto (fun x => f x * r) l atBot :=\n  (tendsto_mul_const_atBot_of_neg hr).2 hf\n#align tendsto.at_top_mul_neg_const tendsto.at_top_mul_neg_const\n\n",
 "at_top_mul_const":
 "/-- If a function tends to infinity along a filter, then this function multiplied by a positive\nconstant (on the right) also tends to infinity. For a version working in `ℕ` or `ℤ`, use\n`filter.tendsto.at_top_mul_const'` instead. -/\ntheorem tendsto.at_top_mul_const (hr : 0 < r) (hf : Tendsto f l atTop) : Tendsto (fun x => f x * r) l atTop :=\n  (tendsto_mul_const_atTop_of_pos hr).2 hf\n#align tendsto.at_top_mul_const tendsto.at_top_mul_const\n\n",
 "at_top_mul_at_top":
 "theorem tendsto.at_top_mul_at_top (hf : Tendsto f l atTop) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x * g x) l atTop :=\n  by\n  refine' tendsto_at_top_mono' _ _ hg\n  filter_upwards [hg.eventually (eventually_ge_at_top 0),\n    hf.eventually (eventually_ge_at_top 1)]with _ using le_mul_of_one_le_left\n#align tendsto.at_top_mul_at_top tendsto.at_top_mul_at_top\n\n",
 "at_top_mul_at_bot":
 "theorem tendsto.at_top_mul_at_bot (hf : Tendsto f l atTop) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x * g x) l atBot :=\n  by\n  have := hf.at_top_mul_at_top <| tendsto_neg_atBot_atTop.comp hg\n  simpa only [(· ∘ ·), neg_mul_eq_mul_neg, neg_neg] using tendsto_neg_at_top_at_bot.comp this\n#align tendsto.at_top_mul_at_bot tendsto.at_top_mul_at_bot\n\n",
 "at_top_finset_eq_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem at_top_finset_eq_infi :\n    (atTop : Filter <| Finset α) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (Ici {x})) :=\n  by\n  refine' le_antisymm (le_infᵢ fun i => le_principal_iff.2 <| mem_at_top {i}) _\n  refine' le_infᵢ fun s => le_principal_iff.2 <| mem_infi_of_Inter s.finite_to_set (fun i => mem_principal_self _) _\n  simp only [subset_def, mem_Inter, SetCoe.forall, mem_Ici, Finset.le_iff_subset, Finset.mem_singleton,\n    Finset.subset_iff, forall_eq]\n  dsimp\n  exact fun t => id\n#align at_top_finset_eq_infi at_top_finset_eq_infi\n\n",
 "at_top_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[nontriviality]\ntheorem subsingleton.at_top_eq (α) [subsingleton α] [preorder α] : (atTop : Filter α) = «expr⊤» :=\n  by\n  refine' top_unique fun s hs x => _\n  letI : Unique α := ⟨⟨x⟩, fun y => subsingleton.elim y x⟩\n  rw [at_top, cinfᵢ_unique, Unique.default_eq x, mem_principal] at hs\n  exact hs left_mem_Ici\n#align subsingleton.at_top_eq subsingleton.at_top_eq\n\n",
 "at_top_div_const":
 "/-- If a function tends to infinity along a filter, then this function divided by a positive\nconstant also tends to infinity. -/\ntheorem tendsto.at_top_div_const (hr : 0 < r) (hf : Tendsto f l atTop) : Tendsto (fun x => f x / r) l atTop := by\n  simpa only [div_eq_mul_inv] using hf.at_top_mul_const (inv_pos.2 hr)\n#align tendsto.at_top_div_const tendsto.at_top_div_const\n\n",
 "at_top_countable_basis":
 "theorem at_top_countable_basis [Nonempty α] [SemilatticeSup α] [Countable α] :\n    HasCountableBasis (atTop : Filter α) (fun _ => True) Ici :=\n  { atTop_basis with countable := to_countable _ }\n#align at_top_countable_basis at_top_countable_basis\n\n",
 "at_top_basis_Ioi":
 "theorem at_top_basis_Ioi [Nonempty α] [SemilatticeSup α] [NoMaxOrder α] : (@atTop α _).has_basis (fun _ => True) Ioi :=\n  atTop_basis.to_has_basis (fun a ha => ⟨a, ha, Ioi_subset_Ici_self⟩) fun a ha =>\n    (exists_gt a).imp fun b hb => ⟨ha, Ici_subset_Ioi.2 hb⟩\n#align at_top_basis_Ioi at_top_basis_Ioi\n\n",
 "at_top_basis'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem at_top_basis' [SemilatticeSup α] (a : α) : (@atTop α _).has_basis (fun x => a ≤ x) Ici :=\n  ⟨fun t =>\n    (@atTop_basis α ⟨a⟩ _).mem_iff.trans\n      ⟨fun ⟨x, _, hx⟩ => ⟨«expr ⊔ » x a, le_sup_right, fun y hy => hx (le_trans le_sup_left hy)⟩, fun ⟨x, _, hx⟩ =>\n        ⟨x, trivial, hx⟩⟩⟩\n#align at_top_basis' at_top_basis'\n\n",
 "at_top_basis":
 "theorem at_top_basis [Nonempty α] [SemilatticeSup α] : (@atTop α _).has_basis (fun _ => True) Ici :=\n  hasBasis_infᵢ_principal (directed_of_sup fun a b => Ici_subset_Ici.2)\n#align at_top_basis at_top_basis\n\n",
 "at_top_Ioi_eq":
 "/-- The `at_top` filter for an open interval `Ioi a` comes from the `at_top` filter in the ambient\norder. -/\ntheorem at_top_Ioi_eq [SemilatticeSup α] (a : α) : atTop = comap (coe : Ioi a → α) atTop :=\n  by\n  nontriviality\n  rcases nontrivial_iff_nonempty.1 ‹_› with ⟨b, hb⟩\n  rw [← map_coe_at_top_of_Ici_subset (Ici_subset_Ioi.2 hb), comap_map Subtype.coe_injective]\n#align at_top_Ioi_eq at_top_Ioi_eq\n\n",
 "at_top_Ici_eq":
 "/-- The `at_top` filter for an open interval `Ici a` comes from the `at_top` filter in the ambient\norder. -/\ntheorem at_top_Ici_eq [SemilatticeSup α] (a : α) : atTop = comap (coe : Ici a → α) atTop := by\n  rw [← map_coe_Ici_at_top a, comap_map Subtype.coe_injective]\n#align at_top_Ici_eq at_top_Ici_eq\n\n",
 "at_bot_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[instance]\ntheorem at_bot_ne_bot [Nonempty α] [SemilatticeInf α] : NeBot (atBot : Filter α) :=\n  @atTop_neBot («expr ᵒᵈ» α) _ _\n#align at_bot_ne_bot at_bot_ne_bot\n\n",
 "at_bot_mul_neg_const":
 "/-- If a function tends to negative infinity along a filter, then this function multiplied by\na negative constant (on the right) tends to positive infinity. -/\ntheorem tendsto.at_bot_mul_neg_const (hr : r < 0) (hf : Tendsto f l atBot) : Tendsto (fun x => f x * r) l atTop :=\n  (tendsto_mul_const_atTop_of_neg hr).2 hf\n#align tendsto.at_bot_mul_neg_const tendsto.at_bot_mul_neg_const\n\n",
 "at_bot_mul_const":
 "/-- If a function tends to negative infinity along a filter, then this function multiplied by\na positive constant (on the right) also tends to negative infinity. -/\ntheorem tendsto.at_bot_mul_const (hr : 0 < r) (hf : Tendsto f l atBot) : Tendsto (fun x => f x * r) l atBot :=\n  (tendsto_mul_const_atBot_of_pos hr).2 hf\n#align tendsto.at_bot_mul_const tendsto.at_bot_mul_const\n\n",
 "at_bot_mul_at_top":
 "theorem tendsto.at_bot_mul_at_top (hf : Tendsto f l atBot) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x * g x) l atBot :=\n  by\n  have : Tendsto (fun x => -f x * g x) l atTop := (tendsto_neg_atBot_atTop.comp hf).at_top_mul_at_top hg\n  simpa only [(· ∘ ·), neg_mul_eq_neg_mul, neg_neg] using tendsto_neg_at_top_at_bot.comp this\n#align tendsto.at_bot_mul_at_top tendsto.at_bot_mul_at_top\n\n",
 "at_bot_mul_at_bot":
 "theorem tendsto.at_bot_mul_at_bot (hf : Tendsto f l atBot) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x * g x) l atTop :=\n  by\n  have : Tendsto (fun x => -f x * -g x) l atTop :=\n    (tendsto_neg_atBot_atTop.comp hf).at_top_mul_at_top (tendsto_neg_atBot_atTop.comp hg)\n  simpa only [neg_mul_neg] using this\n#align tendsto.at_bot_mul_at_bot tendsto.at_bot_mul_at_bot\n\n",
 "at_bot_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[nontriviality]\ntheorem subsingleton.at_bot_eq (α) [subsingleton α] [preorder α] : (atBot : Filter α) = «expr⊤» :=\n  @Subsingleton.atTop_eq («expr ᵒᵈ» α) _ _\n#align subsingleton.at_bot_eq subsingleton.at_bot_eq\n\n",
 "at_bot_div_const":
 "/-- If a function tends to negative infinity along a filter, then this function divided by\na positive constant also tends to negative infinity. -/\ntheorem tendsto.at_bot_div_const (hr : 0 < r) (hf : Tendsto f l atBot) : Tendsto (fun x => f x / r) l atBot := by\n  simpa only [div_eq_mul_inv] using hf.at_bot_mul_const (inv_pos.2 hr)\n#align tendsto.at_bot_div_const tendsto.at_bot_div_const\n\n",
 "at_bot_countable_basis":
 "theorem at_bot_countable_basis [Nonempty α] [SemilatticeInf α] [Countable α] :\n    HasCountableBasis (atBot : Filter α) (fun _ => True) Iic :=\n  { atBot_basis with countable := to_countable _ }\n#align at_bot_countable_basis at_bot_countable_basis\n\n",
 "at_bot_basis'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem at_bot_basis' [SemilatticeInf α] (a : α) : (@atBot α _).has_basis (fun x => x ≤ a) Iic :=\n  @atTop_basis' («expr ᵒᵈ» α) _ _\n#align at_bot_basis' at_bot_basis'\n\n",
 "at_bot_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem at_bot_basis [Nonempty α] [SemilatticeInf α] : (@atBot α _).has_basis (fun _ => True) Iic :=\n  @atTop_basis («expr ᵒᵈ» α) _ _\n#align at_bot_basis at_bot_basis\n\n",
 "at_bot_Iio_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient\norder. -/\ntheorem at_bot_Iio_eq [SemilatticeInf α] (a : α) : atBot = comap (coe : Iio a → α) atBot :=\n  @atTop_Ioi_eq («expr ᵒᵈ» α) _ _\n#align at_bot_Iio_eq at_bot_Iio_eq\n\n",
 "at_bot_Iic_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient\norder. -/\ntheorem at_bot_Iic_eq [SemilatticeInf α] (a : α) : atBot = comap (coe : Iic a → α) atBot :=\n  @atTop_Ici_eq («expr ᵒᵈ» α) _ _\n#align at_bot_Iic_eq at_bot_Iic_eq\n\n",
 "Ioi_mem_at_top":
 "theorem Ioi_mem_at_top [preorder α] [NoMaxOrder α] (x : α) : Ioi x ∈ (atTop : Filter α) :=\n  let ⟨z, hz⟩ := exists_gt x\n  mem_of_superset (mem_atTop z) fun y h => lt_of_lt_of_le hz h\n#align Ioi_mem_at_top Ioi_mem_at_top\n\n",
 "Iio_mem_at_bot":
 "theorem Iio_mem_at_bot [preorder α] [NoMinOrder α] (x : α) : Iio x ∈ (atBot : Filter α) :=\n  let ⟨z, hz⟩ := exists_lt x\n  mem_of_superset (mem_atBot z) fun y h => lt_of_le_of_lt h hz\n#align Iio_mem_at_bot Iio_mem_at_bot\n\n",
 "Iic_mem_at_bot":
 "theorem Iic_mem_at_bot [preorder α] (a : α) : Iic a ∈ (atBot : Filter α) :=\n  mem_atBot a\n#align Iic_mem_at_bot Iic_mem_at_bot\n\n",
 "Ici_mem_at_top":
 "theorem Ici_mem_at_top [preorder α] (a : α) : Ici a ∈ (atTop : Filter α) :=\n  mem_atTop a\n#align Ici_mem_at_top Ici_mem_at_top\n\n"}