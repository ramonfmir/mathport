{"tendsto_principal_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_max_filter.tendsto_principal_Iic (h : is_max_filter f l a) : tendsto f l (filter.principal <| Iic (f a)) :=\n  tendsto_principal.2 h\n#align is_max_filter.tendsto_principal_Iic is_max_filter.tendsto_principal_Iic\n\n",
 "tendsto_principal_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_min_filter.tendsto_principal_Ici (h : is_min_filter f l a) : tendsto f l (filter.principal <| Ici (f a)) :=\n  tendsto_principal.2 h\n#align is_min_filter.tendsto_principal_Ici is_min_filter.tendsto_principal_Ici\n\n",
 "supr_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem is_max_on.supr_eq (hx₀ : x₀ ∈ s) (h : is_max_on f s x₀) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f x) = f x₀ :=\n  haveI : nonempty s := ⟨⟨x₀, hx₀⟩⟩\n  csupᵢ_eq_of_forall_le_of_forall_lt_exists_gt (fun x => h x.prop) fun w hw => ⟨⟨x₀, hx₀⟩, hw⟩\n#align is_max_on.supr_eq is_max_on.supr_eq\n\n",
 "sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem is_max_on.sup (hf : is_max_on f s a) (hg : is_max_on g s a) : is_max_on (fun x => «expr ⊔ » (f x) (g x)) s a :=\n  hf.sup hg\n#align is_max_on.sup is_max_on.sup\n\n",
 "sub":
 "theorem is_max_on.sub (hf : is_max_on f s a) (hg : is_min_on g s a) : is_max_on (fun x => f x - g x) s a := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n#align is_max_on.sub is_max_on.sub\n\n",
 "on_subset":
 "theorem is_extr_on.on_subset (hf : is_extr_on f t a) (h : s ⊆ t) : is_extr_on f s a :=\n  hf.filter_mono <| principal_mono.2 h\n#align is_extr_on.on_subset is_extr_on.on_subset\n\n",
 "on_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_extr_on.on_preimage (g : δ → α) {b : δ} (hf : is_extr_on f s (g b)) :\n    is_extr_on (f ∘ g) («expr ⁻¹' » g s) b :=\n  hf.elim (fun hf => (hf.on_preimage g).is_extr) fun hf => (hf.on_preimage g).is_extr\n#align is_extr_on.on_preimage is_extr_on.on_preimage\n\n",
 "neg":
 "theorem is_extr_on.neg (hf : is_extr_on f s a) : is_extr_on (fun x => -f x) s a :=\n  hf.elim (fun hf => hf.neg.is_extr) fun hf => hf.neg.is_extr\n#align is_extr_on.neg is_extr_on.neg\n\n",
 "min":
 "theorem is_max_on.min (hf : is_max_on f s a) (hg : is_max_on g s a) : is_max_on (fun x => min (f x) (g x)) s a :=\n  hf.min hg\n#align is_max_on.min is_max_on.min\n\n",
 "max":
 "theorem is_max_on.max (hf : is_max_on f s a) (hg : is_max_on g s a) : is_max_on (fun x => max (f x) (g x)) s a :=\n  hf.max hg\n#align is_max_on.max is_max_on.max\n\n",
 "is_min_on_univ_iff":
 "theorem is_min_on_univ_iff : is_min_on f univ a ↔ ∀ x, f a ≤ f x :=\n  univ_subset_iff.trans eq_univ_iff_forall\n#align is_min_on_univ_iff is_min_on_univ_iff\n\n",
 "is_min_on_iff":
 "theorem is_min_on_iff : is_min_on f s a ↔ ∀ x ∈ s, f a ≤ f x :=\n  iff.rfl\n#align is_min_on_iff is_min_on_iff\n\n",
 "is_min_on_dual_iff":
 "theorem is_min_on_dual_iff : is_min_on (to_dual ∘ f) s a ↔ is_max_on f s a :=\n  iff.rfl\n#align is_min_on_dual_iff is_min_on_dual_iff\n\n",
 "is_min_on_const":
 "theorem is_min_on_const {b : β} : is_min_on (fun _ => b) s a :=\n  is_min_filter_const\n#align is_min_on_const is_min_on_const\n\n",
 "is_min_filter_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem filter.eventually_eq.is_min_filter_iff {α β : Type _} [preorder β] {f g : α → β} {a : α} {l : filter α}\n    (heq : «expr =ᶠ[ ] » f l g) (hfga : f a = g a) : is_min_filter f l a ↔ is_min_filter g l a :=\n  ⟨fun h => h.congr HEq hfga, fun h => h.congr HEq.symm hfga.symm⟩\n#align filter.eventually_eq.is_min_filter_iff filter.eventually_eq.is_min_filter_iff\n\n",
 "is_min_filter_dual_iff":
 "theorem is_min_filter_dual_iff : is_min_filter (to_dual ∘ f) l a ↔ is_max_filter f l a :=\n  iff.rfl\n#align is_min_filter_dual_iff is_min_filter_dual_iff\n\n",
 "is_min_filter_const":
 "theorem is_min_filter_const {b : β} : is_min_filter (fun _ => b) l a :=\n  univ_mem' fun _ => le_rfl\n#align is_min_filter_const is_min_filter_const\n\n",
 "is_min_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem filter.eventually_le.is_min_filter {α β : Type _} [preorder β] {f g : α → β} {a : α} {l : filter α}\n    (hle : «expr ≤ᶠ[ ] » f l g) (hfga : f a = g a) (h : is_min_filter f l a) : is_min_filter g l a :=\n  @filter.eventually_le.is_max_filter _ («expr ᵒᵈ» β) _ _ _ _ _ hle hfga h\n#align filter.eventually_le.is_min_filter filter.eventually_le.is_min_filter\n\n",
 "is_max_on_univ_iff":
 "theorem is_max_on_univ_iff : is_max_on f univ a ↔ ∀ x, f x ≤ f a :=\n  univ_subset_iff.trans eq_univ_iff_forall\n#align is_max_on_univ_iff is_max_on_univ_iff\n\n",
 "is_max_on_iff":
 "theorem is_max_on_iff : is_max_on f s a ↔ ∀ x ∈ s, f x ≤ f a :=\n  iff.rfl\n#align is_max_on_iff is_max_on_iff\n\n",
 "is_max_on_dual_iff":
 "theorem is_max_on_dual_iff : is_max_on (to_dual ∘ f) s a ↔ is_min_on f s a :=\n  iff.rfl\n#align is_max_on_dual_iff is_max_on_dual_iff\n\n",
 "is_max_on_const":
 "theorem is_max_on_const {b : β} : is_max_on (fun _ => b) s a :=\n  is_max_filter_const\n#align is_max_on_const is_max_on_const\n\n",
 "is_max_filter_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem filter.eventually_eq.is_max_filter_iff {α β : Type _} [preorder β] {f g : α → β} {a : α} {l : filter α}\n    (heq : «expr =ᶠ[ ] » f l g) (hfga : f a = g a) : is_max_filter f l a ↔ is_max_filter g l a :=\n  ⟨fun h => h.congr HEq hfga, fun h => h.congr HEq.symm hfga.symm⟩\n#align filter.eventually_eq.is_max_filter_iff filter.eventually_eq.is_max_filter_iff\n\n",
 "is_max_filter_dual_iff":
 "theorem is_max_filter_dual_iff : is_max_filter (to_dual ∘ f) l a ↔ is_min_filter f l a :=\n  iff.rfl\n#align is_max_filter_dual_iff is_max_filter_dual_iff\n\n",
 "is_max_filter_const":
 "theorem is_max_filter_const {b : β} : is_max_filter (fun _ => b) l a :=\n  univ_mem' fun _ => le_rfl\n#align is_max_filter_const is_max_filter_const\n\n",
 "is_max_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem filter.eventually_le.is_max_filter {α β : Type _} [preorder β] {f g : α → β} {a : α} {l : filter α}\n    (hle : «expr ≤ᶠ[ ] » g l f) (hfga : f a = g a) (h : is_max_filter f l a) : is_max_filter g l a :=\n  by\n  refine' hle.mp (h.mono fun x hf hgf => _)\n  rw [← hfga]\n  exact le_trans hgf hf\n#align filter.eventually_le.is_max_filter filter.eventually_le.is_max_filter\n\n",
 "is_extr_on_dual_iff":
 "theorem is_extr_on_dual_iff : is_extr_on (to_dual ∘ f) s a ↔ is_extr_on f s a :=\n  or_comm' _ _\n#align is_extr_on_dual_iff is_extr_on_dual_iff\n\n",
 "is_extr_on_const":
 "theorem is_extr_on_const {b : β} : is_extr_on (fun _ => b) s a :=\n  is_extr_filter_const\n#align is_extr_on_const is_extr_on_const\n\n",
 "is_extr_filter_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem filter.eventually_eq.is_extr_filter_iff {α β : Type _} [preorder β] {f g : α → β} {a : α} {l : filter α}\n    (heq : «expr =ᶠ[ ] » f l g) (hfga : f a = g a) : is_extr_filter f l a ↔ is_extr_filter g l a :=\n  ⟨fun h => h.congr HEq hfga, fun h => h.congr HEq.symm hfga.symm⟩\n#align filter.eventually_eq.is_extr_filter_iff filter.eventually_eq.is_extr_filter_iff\n\n",
 "is_extr_filter_dual_iff":
 "theorem is_extr_filter_dual_iff : is_extr_filter (to_dual ∘ f) l a ↔ is_extr_filter f l a :=\n  or_comm' _ _\n#align is_extr_filter_dual_iff is_extr_filter_dual_iff\n\n",
 "is_extr_filter_const":
 "theorem is_extr_filter_const {b : β} : is_extr_filter (fun _ => b) l a :=\n  is_min_filter_const.is_extr\n#align is_extr_filter_const is_extr_filter_const\n\n",
 "is_extr":
 "theorem is_max_on.is_extr (h : is_max_on f s a) : is_extr_on f s a :=\n  h.is_extr\n#align is_max_on.is_extr is_max_on.is_extr\n\n",
 "inter":
 "theorem is_extr_on.inter (hf : is_extr_on f s a) (t) : is_extr_on f (s ∩ t) a :=\n  hf.on_subset (inter_subset_left s t)\n#align is_extr_on.inter is_extr_on.inter\n\n",
 "infi_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem is_min_on.infi_eq (hx₀ : x₀ ∈ s) (h : is_min_on f s x₀) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f x) = f x₀ :=\n  @is_max_on.supr_eq («expr ᵒᵈ» α) β _ _ _ _ hx₀ h\n#align is_min_on.infi_eq is_min_on.infi_eq\n\n",
 "inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem is_max_on.inf (hf : is_max_on f s a) (hg : is_max_on g s a) : is_max_on (fun x => «expr ⊓ » (f x) (g x)) s a :=\n  hf.inf hg\n#align is_max_on.inf is_max_on.inf\n\n",
 "filter_mono":
 "theorem is_extr_filter.filter_mono (h : is_extr_filter f l a) (hl : l' ≤ l) : is_extr_filter f l' a :=\n  h.elim (fun h => (h.filter_mono hl).is_extr) fun h => (h.filter_mono hl).is_extr\n#align is_extr_filter.filter_mono is_extr_filter.filter_mono\n\n",
 "filter_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem is_extr_filter.filter_inf (h : is_extr_filter f l a) (l') : is_extr_filter f («expr ⊓ » l l') a :=\n  h.filter_mono inf_le_left\n#align is_extr_filter.filter_inf is_extr_filter.filter_inf\n\n",
 "elim":
 "/-\nCopyright (c) 2019 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\ntheorem is_extr_on.elim {p : Prop} : is_extr_on f s a → (is_min_on f s a → p) → (is_max_on f s a → p) → p :=\n  or.elim\n#align is_extr_on.elim is_extr_on.elim\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem is_extr_filter.congr {α β : Type _} [preorder β] {f g : α → β} {a : α} {l : filter α} (h : is_extr_filter f l a)\n    (heq : «expr =ᶠ[ ] » f l g) (hfga : f a = g a) : is_extr_filter g l a :=\n  by\n  rw [is_extr_filter] at *\n  rwa [← heq.is_max_filter_iff hfga, ← heq.is_min_filter_iff hfga]\n#align is_extr_filter.congr is_extr_filter.congr\n\n",
 "comp_tendsto":
 "theorem is_extr_filter.comp_tendsto {g : δ → α} {l' : filter δ} {b : δ} (hf : is_extr_filter f l (g b))\n    (hg : tendsto g l' l) : is_extr_filter (f ∘ g) l' b :=\n  hf.elim (fun hf => (hf.comp_tendsto hg).is_extr) fun hf => (hf.comp_tendsto hg).is_extr\n#align is_extr_filter.comp_tendsto is_extr_filter.comp_tendsto\n\n",
 "comp_mono":
 "theorem is_extr_on.comp_mono (hf : is_extr_on f s a) {g : β → γ} (hg : monotone g) : is_extr_on (g ∘ f) s a :=\n  hf.comp_mono hg\n#align is_extr_on.comp_mono is_extr_on.comp_mono\n\n",
 "comp_maps_to":
 "theorem is_extr_on.comp_maps_to {t : set δ} {g : δ → α} {b : δ} (hf : is_extr_on f s a) (hg : MapsTo g t s)\n    (ha : g b = a) : is_extr_on (f ∘ g) t b :=\n  hf.elim (fun h => or.inl <| h.comp_maps_to hg ha) fun h => or.inr <| h.comp_maps_to hg ha\n#align is_extr_on.comp_maps_to is_extr_on.comp_maps_to\n\n",
 "comp_antitone":
 "theorem is_extr_on.comp_antitone (hf : is_extr_on f s a) {g : β → γ} (hg : antitone g) : is_extr_on (g ∘ f) s a :=\n  hf.comp_antitone hg\n#align is_extr_on.comp_antitone is_extr_on.comp_antitone\n\n",
 "bicomp_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\ntheorem is_max_on.bicomp_mono [preorder δ] {op : β → γ → δ}\n    (hop : («expr ⇒ » (· ≤ ·) («expr ⇒ » (· ≤ ·) (· ≤ ·))) op op) (hf : is_max_on f s a) {g : α → γ}\n    (hg : is_max_on g s a) : is_max_on (fun x => op (f x) (g x)) s a :=\n  hf.bicomp_mono hop hg\n#align is_max_on.bicomp_mono is_max_on.bicomp_mono\n\n",
 "add":
 "theorem is_max_on.add (hf : is_max_on f s a) (hg : is_max_on g s a) : is_max_on (fun x => f x + g x) s a :=\n  hf.add hg\n#align is_max_on.add is_max_on.add\n\n"}