{"tendsto_swap4_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem tendsto_swap4_prod {f : Filter α} {g : Filter β} {h : Filter γ} {k : Filter δ} :\n    Tendsto (fun p : (α × β) × γ × δ => ((p.1.1, p.2.1), (p.1.2, p.2.2)))\n      (filter.prod (filter.prod f g) (filter.prod h k)) (filter.prod (filter.prod f h) (filter.prod g k)) :=\n  map_swap4_prod.le\n#align tendsto_swap4_prod tendsto_swap4_prod\n\n",
 "tendsto_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem tendsto_snd {f : Filter α} {g : Filter β} : Tendsto Prod.snd (filter.prod f g) g :=\n  tendsto_inf_right tendsto_comap\n#align tendsto_snd tendsto_snd\n\n",
 "tendsto_prod_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem tendsto_prod_swap {α1 α2 : Type _} {a1 : Filter α1} {a2 : Filter α2} :\n    Tendsto (Prod.swap : α1 × α2 → α2 × α1) (filter.prod a1 a2) (filter.prod a2 a1) :=\n  tendsto_snd.prod_mk tendsto_fst\n#align tendsto_prod_swap tendsto_prod_swap\n\n",
 "tendsto_prod_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem tendsto_prod_iff' {f : Filter α} {g : Filter β} {g' : Filter γ} {s : α → β × γ} :\n    Tendsto s f (filter.prod g g') ↔ Tendsto (fun n => (s n).1) f g ∧ Tendsto (fun n => (s n).2) f g' :=\n  by\n  unfold Filter.prod\n  simp only [tendsto_inf, tendsto_comap_iff, iff_self_iff]\n#align tendsto_prod_iff' tendsto_prod_iff'\n\n",
 "tendsto_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem tendsto_prod_iff {f : α × β → γ} {x : Filter α} {y : Filter β} {z : Filter γ} :\n    Filter.Tendsto f (filter.prod x y) z ↔ ∀ W ∈ z, ∃ U ∈ x, ∃ V ∈ y, ∀ x y, x ∈ U → y ∈ V → f (x, y) ∈ W := by\n  simp only [tendsto_def, mem_prod_iff, prod_sub_preimage_iff, exists_prop, iff_self_iff]\n#align tendsto_prod_iff tendsto_prod_iff\n\n",
 "tendsto_prod_assoc_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem tendsto_prod_assoc_symm {f : Filter α} {g : Filter β} {h : Filter γ} :\n    Tendsto (Equiv.prodAssoc α β γ).symm (filter.prod f (filter.prod g h)) (filter.prod (filter.prod f g) h) :=\n  (prod_assoc_symm f g h).le\n#align tendsto_prod_assoc_symm tendsto_prod_assoc_symm\n\n",
 "tendsto_prod_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem tendsto_prod_assoc {f : Filter α} {g : Filter β} {h : Filter γ} :\n    Tendsto (Equiv.prodAssoc α β γ) (filter.prod (filter.prod f g) h) (filter.prod f (filter.prod g h)) :=\n  (prod_assoc f g h).le\n#align tendsto_prod_assoc tendsto_prod_assoc\n\n",
 "tendsto_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem tendsto_fst {f : Filter α} {g : Filter β} : Tendsto Prod.fst (filter.prod f g) f :=\n  tendsto_inf_left tendsto_comap\n#align tendsto_fst tendsto_fst\n\n",
 "tendsto_diag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem tendsto_diag : Tendsto (fun i => (i, i)) f (filter.prod f f) :=\n  tendsto_iff_eventually.mpr fun _ hpr => hpr.diag_of_prod\n#align tendsto_diag tendsto_diag\n\n",
 "sup_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem sup_prod (f₁ f₂ : Filter α) (g : Filter β) :\n    filter.prod («expr ⊔ » f₁ f₂) g = «expr ⊔ » (filter.prod f₁ g) (filter.prod f₂ g) := by\n  rw [Filter.prod, comap_sup, inf_sup_right, ← Filter.prod, ← Filter.prod]\n#align sup_prod sup_prod\n\n",
 "pure_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n@[simp]\ntheorem pure_prod {a : α} {f : Filter β} : filter.prod (pure a) f = map (prod.mk a) f := by\n  rw [prod_eq, map_pure, pure_seq_eq_map]\n#align pure_prod pure_prod\n\n",
 "prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem prod_top {f : Filter α} : filter.prod f («expr⊤» : Filter β) = f.comap Prod.fst := by\n  rw [Filter.prod, comap_top, inf_top_eq]\n#align prod_top prod_top\n\n",
 "prod_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_sup (f : Filter α) (g₁ g₂ : Filter β) :\n    filter.prod f («expr ⊔ » g₁ g₂) = «expr ⊔ » (filter.prod f g₁) (filter.prod f g₂) := by\n  rw [Filter.prod, comap_sup, inf_sup_left, ← Filter.prod, ← Filter.prod]\n#align prod_sup prod_sup\n\n",
 "prod_pure_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_pure_pure {a : α} {b : β} : filter.prod (pure a) (pure b) = pure (a, b) := by simp\n#align prod_pure_pure prod_pure_pure\n\n",
 "prod_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n@[simp]\ntheorem prod_pure {f : Filter α} {b : β} : filter.prod f (pure b) = map (fun a => (a, b)) f := by\n  rw [prod_eq, seq_pure, map_map]\n#align prod_pure prod_pure\n\n",
 "prod_principal_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem prod_principal_principal {s : Set α} {t : Set β} :\n    filter.prod ((filter.principal) s) ((filter.principal) t) = (filter.principal) (finset.product s t) := by\n  simp only [Filter.prod, comap_principal, principal_eq_iff_eq, comap_principal, inf_principal] <;> rfl\n#align prod_principal_principal prod_principal_principal\n\n",
 "prod_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_ne_bot {f : Filter α} {g : Filter β} : NeBot (filter.prod f g) ↔ NeBot f ∧ NeBot g := by\n  simp only [ne_bot_iff, ne, prod_eq_bot, not_or]\n#align prod_ne_bot prod_ne_bot\n\n",
 "prod_mono_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_mono_right (f : Filter α) {g₁ g₂ : Filter β} (hf : g₁ ≤ g₂) : filter.prod f g₁ ≤ filter.prod f g₂ :=\n  Filter.prod_mono rfl.le hf\n#align prod_mono_right prod_mono_right\n\n",
 "prod_mono_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_mono_left (g : Filter β) {f₁ f₂ : Filter α} (hf : f₁ ≤ f₂) : filter.prod f₁ g ≤ filter.prod f₂ g :=\n  Filter.prod_mono hf rfl.le\n#align prod_mono_left prod_mono_left\n\n",
 "prod_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n@[mono]\ntheorem prod_mono {f₁ f₂ : Filter α} {g₁ g₂ : Filter β} (hf : f₁ ≤ f₂) (hg : g₁ ≤ g₂) :\n    filter.prod f₁ g₁ ≤ filter.prod f₂ g₂ :=\n  inf_le_inf (comap_mono hf) (comap_mono hg)\n#align prod_mono prod_mono\n\n",
 "prod_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem eventually.prod_mk {la : Filter α} {pa : α → Prop}\n    (ha :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" la (pa x))\n    {lb : Filter β} {pb : β → Prop}\n    (hb :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" lb\n        (pb y)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (filter.prod la lb) (pa (p : α × β).1 ∧ pb p.2) :=\n  (ha.prod_inl lb).and (hb.prod_inr la)\n#align eventually.prod_mk eventually.prod_mk\n\n",
 "prod_mem_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n@[simp]\ntheorem prod_mem_prod_iff {s : Set α} {t : Set β} {f : Filter α} {g : Filter β} [f.ne_bot] [g.ne_bot] :\n    finset.product s t ∈ filter.prod f g ↔ s ∈ f ∧ t ∈ g :=\n  ⟨fun h =>\n    let ⟨s', hs', t', ht', H⟩ := mem_prod_iff.1 h\n    (prod_subset_prod_iff.1 H).elim (fun ⟨hs's, ht't⟩ => ⟨mem_of_superset hs' hs's, mem_of_superset ht' ht't⟩) fun h =>\n      h.elim (fun hs'e => absurd hs'e (nonempty_of_mem hs').ne_empty) fun ht'e =>\n        absurd ht'e (nonempty_of_mem ht').ne_empty,\n    fun h => prod_mem_prod h.1 h.2⟩\n#align prod_mem_prod_iff prod_mem_prod_iff\n\n",
 "prod_mem_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/-\nCopyright (c) 2022 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johanes Hölzl, Patrick Massot, Yury Kudryashov, Kevin Wilson, Heather Macbeth\n-/\ntheorem prod_mem_prod {s : Set α} {t : Set β} {f : Filter α} {g : Filter β} (hs : s ∈ f) (ht : t ∈ g) :\n    finset.product s t ∈ filter.prod f g :=\n  inter_mem_inf (preimage_mem_comap hs) (preimage_mem_comap ht)\n#align prod_mem_prod prod_mem_prod\n\n",
 "prod_map_map_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_map_map_eq' {α₁ : Type _} {α₂ : Type _} {β₁ : Type _} {β₂ : Type _} (f : α₁ → α₂) (g : β₁ → β₂)\n    (F : Filter α₁) (G : Filter β₁) : filter.prod (map f F) (map g G) = map (prod.map f g) (filter.prod F G) :=\n  prod_map_map_eq\n#align prod_map_map_eq' prod_map_map_eq'\n\n",
 "prod_map_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_map_map_eq.{u, v, w, x} {α₁ : Type u} {α₂ : Type v} {β₁ : Type w} {β₂ : Type x} {f₁ : Filter α₁}\n    {f₂ : Filter α₂} {m₁ : α₁ → β₁} {m₂ : α₂ → β₂} :\n    filter.prod (map m₁ f₁) (map m₂ f₂) = map (fun p : α₁ × α₂ => (m₁ p.1, m₂ p.2)) (filter.prod f₁ f₂) :=\n  le_antisymm\n    (fun s hs =>\n      let ⟨s₁, hs₁, s₂, hs₂, h⟩ := mem_prod_iff.mp hs\n      filter.sets_of_superset _ (prod_mem_prod (image_mem_map hs₁) (image_mem_map hs₂)) <|\n        calc\n          finset.product («expr '' » m₁ s₁) («expr '' » m₂ s₂) =\n              «expr '' » (fun p : α₁ × α₂ => (m₁ p.1, m₂ p.2)) (finset.product s₁ s₂) :=\n            Set.prod_image_image_eq\n          _ ⊆ _ := by rwa [image_subset_iff]\n          )\n    ((Tendsto.comp le_rfl tendsto_fst).prod_mk (Tendsto.comp le_rfl tendsto_snd))\n#align prod_map_map_eq prod_map_map_eq\n\n",
 "prod_map_coprod":
 "theorem tendsto.prod_map_coprod {δ : Type _} {f : α → γ} {g : β → δ} {a : Filter α} {b : Filter β} {c : Filter γ}\n    {d : Filter δ} (hf : Tendsto f a c) (hg : Tendsto g b d) : Tendsto (prod.map f g) (a.coprod b) (c.coprod d) :=\n  map_prod_map_coprod_le.trans (coprod_mono hf hg)\n#align tendsto.prod_map_coprod tendsto.prod_map_coprod\n\n",
 "prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem tendsto.prod_map {δ : Type _} {f : α → γ} {g : β → δ} {a : Filter α} {b : Filter β} {c : Filter γ}\n    {d : Filter δ} (hf : Tendsto f a c) (hg : Tendsto g b d) :\n    Tendsto (prod.map f g) (filter.prod a b) (filter.prod c d) :=\n  by\n  erw [tendsto, ← prod_map_map_eq]\n  exact Filter.prod_mono hf hg\n#align tendsto.prod_map tendsto.prod_map\n\n",
 "prod_le_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n@[simp]\ntheorem prod_le_prod {f₁ f₂ : Filter α} {g₁ g₂ : Filter β} [NeBot f₁] [NeBot g₁] :\n    filter.prod f₁ g₁ ≤ filter.prod f₂ g₂ ↔ f₁ ≤ f₂ ∧ g₁ ≤ g₂ :=\n  ⟨fun h => ⟨map_fst_prod f₁ g₁ ▸ tendsto_fst.mono_left h, map_snd_prod f₁ g₁ ▸ tendsto_snd.mono_left h⟩, fun h =>\n    prod_mono h.1 h.2⟩\n#align prod_le_prod prod_le_prod\n\n",
 "prod_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem eventually.prod_inr {lb : Filter β} {p : β → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" lb (p x))\n    (la : Filter α) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (filter.prod la lb) (p (x : α × β).2) :=\n  tendsto_snd.eventually h\n#align eventually.prod_inr eventually.prod_inr\n\n",
 "prod_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem eventually.prod_inl {la : Filter α} {p : α → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" la (p x))\n    (lb : Filter β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (filter.prod la lb) (p (x : α × β).1) :=\n  tendsto_fst.eventually h\n#align eventually.prod_inl eventually.prod_inl\n\n",
 "prod_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n@[simp]\ntheorem prod_inj {f₁ f₂ : Filter α} {g₁ g₂ : Filter β} [NeBot f₁] [NeBot g₁] :\n    filter.prod f₁ g₁ = filter.prod f₂ g₂ ↔ f₁ = f₂ ∧ g₁ = g₂ :=\n  by\n  refine' ⟨fun h => _, fun h => h.1 ▸ h.2 ▸ rfl⟩\n  have hle : f₁ ≤ f₂ ∧ g₁ ≤ g₂ := prod_le_prod.1 h.le\n  haveI := ne_bot_of_le hle.1; haveI := ne_bot_of_le hle.2\n  exact ⟨hle.1.antisymm <| (prod_le_prod.1 h.ge).1, hle.2.antisymm <| (prod_le_prod.1 h.ge).2⟩\n#align prod_inj prod_inj\n\n",
 "prod_infi_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_infi_right [Nonempty ι] {f : Filter α} {g : ι → Filter β} :\n    filter.prod f\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (g i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (filter.prod f (g i)) :=\n  by\n  rw [Filter.prod, comap_infi, inf_infᵢ]\n  simp only [Filter.prod, eq_self_iff_true]\n#align prod_infi_right prod_infi_right\n\n",
 "prod_infi_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_infi_left [Nonempty ι] {f : ι → Filter α} {g : Filter β} :\n    filter.prod («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i))\n        g =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (filter.prod (f i) g) :=\n  by\n  rw [Filter.prod, comap_infi, infᵢ_inf]\n  simp only [Filter.prod, eq_self_iff_true]\n#align prod_infi_left prod_infi_left\n\n",
 "prod_inf_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem prod_inf_prod {f₁ f₂ : Filter α} {g₁ g₂ : Filter β} :\n    «expr ⊓ » (filter.prod f₁ g₁) (filter.prod f₂ g₂) = filter.prod («expr ⊓ » f₁ f₂) («expr ⊓ » g₁ g₂) := by\n  simp only [Filter.prod, comap_inf, inf_comm, inf_assoc, inf_left_comm]\n#align prod_inf_prod prod_inf_prod\n\n",
 "prod_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem prod_eq_bot {f : Filter α} {g : Filter β} : filter.prod f g = «expr⊥» ↔ f = «expr⊥» ∨ g = «expr⊥» :=\n  by\n  constructor\n  · intro h\n    rcases mem_prod_iff.1 (empty_mem_iff_bot.2 h) with ⟨s, hs, t, ht, hst⟩\n    rw [subset_empty_iff, Set.prod_eq_empty_iff] at hst\n    cases' hst with s_eq t_eq\n    · left\n      exact empty_mem_iff_bot.1 (s_eq ▸ hs)\n    · right\n      exact empty_mem_iff_bot.1 (t_eq ▸ ht)\n  · rintro (rfl | rfl)\n    exact bot_prod\n    exact prod_bot\n#align prod_eq_bot prod_eq_bot\n\n",
 "prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_eq {f : Filter α} {g : Filter β} : filter.prod f g = (f.map prod.mk).seq g :=\n  by\n  have h := f.map_prod id g\n  rwa [map_id] at h\n#align prod_eq prod_eq\n\n",
 "prod_comm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_comm' : filter.prod f g = comap Prod.swap (filter.prod g f) := by\n  simp only [Filter.prod, comap_comap, (· ∘ ·), inf_comm, Prod.fst_swap, eq_self_iff_true, Prod.snd_swap, comap_inf]\n#align prod_comm' prod_comm'\n\n",
 "prod_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_comm : filter.prod f g = map (fun p : β × α => (p.2, p.1)) (filter.prod g f) :=\n  by\n  rw [prod_comm', ← map_swap_eq_comap_swap]\n  rfl\n#align prod_comm prod_comm\n\n",
 "prod_comap_comap_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_comap_comap_eq.{u, v, w, x} {α₁ : Type u} {α₂ : Type v} {β₁ : Type w} {β₂ : Type x} {f₁ : Filter α₁}\n    {f₂ : Filter α₂} {m₁ : β₁ → α₁} {m₂ : β₂ → α₂} :\n    filter.prod (comap m₁ f₁) (comap m₂ f₂) = comap (fun p : β₁ × β₂ => (m₁ p.1, m₂ p.2)) (filter.prod f₁ f₂) := by\n  simp only [Filter.prod, comap_comap, eq_self_iff_true, comap_inf]\n#align prod_comap_comap_eq prod_comap_comap_eq\n\n",
 "prod_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem prod_bot {f : Filter α} : filter.prod f («expr⊥» : Filter β) = «expr⊥» := by simp [Filter.prod]\n#align prod_bot prod_bot\n\n",
 "prod_assoc_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_assoc_symm (f : Filter α) (g : Filter β) (h : Filter γ) :\n    map (Equiv.prodAssoc α β γ).symm (filter.prod f (filter.prod g h)) = filter.prod (filter.prod f g) h := by\n  simp_rw [map_equiv_symm, Filter.prod, comap_inf, comap_comap, inf_assoc, Function.comp, Equiv.prodAssoc_apply]\n#align prod_assoc_symm prod_assoc_symm\n\n",
 "prod_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem prod_assoc (f : Filter α) (g : Filter β) (h : Filter γ) :\n    map (Equiv.prodAssoc α β γ) (filter.prod (filter.prod f g) h) = filter.prod f (filter.prod g h) := by\n  simp_rw [← comap_equiv_symm, Filter.prod, comap_inf, comap_comap, inf_assoc, Function.comp,\n    Equiv.prodAssoc_symm_apply]\n#align prod_assoc prod_assoc\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem ne_bot.prod {f : Filter α} {g : Filter β} (hf : NeBot f) (hg : NeBot g) : NeBot (filter.prod f g) :=\n  prod_neBot.2 ⟨hf, hg⟩\n#align ne_bot.prod ne_bot.prod\n\n",
 "principal_coprod_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem principal_coprod_principal (s : Set α) (t : Set β) :\n    ((filter.principal) s).coprod ((filter.principal) t) =\n      (filter.principal) («expr ᶜ» (finset.product («expr ᶜ» s) («expr ᶜ» t))) :=\n  by\n  rw [Filter.coprod, comap_principal, comap_principal, sup_principal, Set.prod_eq, compl_inter, preimage_compl,\n    preimage_compl, compl_compl, compl_compl]\n#align principal_coprod_principal principal_coprod_principal\n\n",
 "mem_prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem mem_prod_top {f : Filter α} {s : Set (α × β)} :\n    s ∈ filter.prod f («expr⊤» : Filter β) ↔ { a | ∀ b, (a, b) ∈ s } ∈ f :=\n  by\n  rw [← principal_univ, mem_prod_principal]\n  simp only [mem_univ, forall_true_left]\n#align mem_prod_top mem_prod_top\n\n",
 "mem_prod_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem mem_prod_principal {f : Filter α} {s : Set (α × β)} {t : Set β} :\n    s ∈ filter.prod f ((filter.principal) t) ↔ { a | ∀ b ∈ t, (a, b) ∈ s } ∈ f :=\n  by\n  rw [← @exists_mem_subset_iff _ f, mem_prod_iff]\n  refine' exists₂_congr fun u u_in => ⟨_, fun h => ⟨t, mem_principal_self t, _⟩⟩\n  · rintro ⟨v, v_in, hv⟩ a a_in b b_in\n    exact hv (mk_mem_prod a_in <| v_in b_in)\n  · rintro ⟨x, y⟩ ⟨hx, hy⟩\n    exact h hx y hy\n#align mem_prod_principal mem_prod_principal\n\n",
 "mem_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem mem_prod_iff {s : Set (α × β)} {f : Filter α} {g : Filter β} :\n    s ∈ filter.prod f g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, finset.product t₁ t₂ ⊆ s :=\n  by\n  simp only [Filter.prod]\n  constructor\n  · rintro ⟨t₁, ⟨s₁, hs₁, hts₁⟩, t₂, ⟨s₂, hs₂, hts₂⟩, rfl⟩\n    exact ⟨s₁, hs₁, s₂, hs₂, fun p ⟨h, h'⟩ => ⟨hts₁ h, hts₂ h'⟩⟩\n  · rintro ⟨t₁, ht₁, t₂, ht₂, h⟩\n    exact mem_inf_of_inter (preimage_mem_comap ht₁) (preimage_mem_comap ht₂) h\n#align mem_prod_iff mem_prod_iff\n\n",
 "mem_coprod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mem_coprod_iff {s : Set (α × β)} {f : Filter α} {g : Filter β} :\n    s ∈ f.coprod g ↔ (∃ t₁ ∈ f, «expr ⁻¹' » Prod.fst t₁ ⊆ s) ∧ ∃ t₂ ∈ g, «expr ⁻¹' » Prod.snd t₂ ⊆ s := by\n  simp [Filter.coprod]\n#align mem_coprod_iff mem_coprod_iff\n\n",
 "map_swap4_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/-- A useful lemma when dealing with uniformities. -/\ntheorem map_swap4_prod {f : Filter α} {g : Filter β} {h : Filter γ} {k : Filter δ} :\n    map (fun p : (α × β) × γ × δ => ((p.1.1, p.2.1), (p.1.2, p.2.2)))\n        (filter.prod (filter.prod f g) (filter.prod h k)) =\n      filter.prod (filter.prod f h) (filter.prod g k) :=\n  by simp_rw [map_swap4_eq_comap, Filter.prod, comap_inf, comap_comap, inf_assoc, inf_left_comm]\n#align map_swap4_prod map_swap4_prod\n\n",
 "map_snd_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n@[simp]\ntheorem map_snd_prod (f : Filter α) (g : Filter β) [NeBot f] : map Prod.snd (filter.prod f g) = g := by\n  rw [prod_comm, map_map, (· ∘ ·), map_fst_prod]\n#align map_snd_prod map_snd_prod\n\n",
 "map_pure_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem map_pure_prod (f : α → β → γ) (a : α) (B : Filter β) :\n    Filter.map (function.uncurry f) (filter.prod (pure a) B) = Filter.map (f a) B :=\n  by\n  rw [Filter.pure_prod]\n  rfl\n#align map_pure_prod map_pure_prod\n\n",
 "map_prod_map_coprod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n-- this inequality can be strict; see `map_const_principal_coprod_map_id_principal` and\n-- `map_prod_map_const_id_principal_coprod_principal` below.\ntheorem map_prod_map_coprod_le.{u, v, w, x} {α₁ : Type u} {α₂ : Type v} {β₁ : Type w} {β₂ : Type x} {f₁ : Filter α₁}\n    {f₂ : Filter α₂} {m₁ : α₁ → β₁} {m₂ : α₂ → β₂} :\n    map (prod.map m₁ m₂) (f₁.coprod f₂) ≤ (map m₁ f₁).coprod (map m₂ f₂) :=\n  by\n  intro s\n  simp only [mem_map, mem_coprod_iff]\n  rintro ⟨⟨u₁, hu₁, h₁⟩, u₂, hu₂, h₂⟩\n  refine' ⟨⟨«expr ⁻¹' » m₁ u₁, hu₁, fun _ hx => h₁ _⟩, ⟨«expr ⁻¹' » m₂ u₂, hu₂, fun _ hx => h₂ _⟩⟩ <;> convert hx\n#align map_prod_map_coprod_le map_prod_map_coprod_le\n\n",
 "map_prod_map_const_id_principal_coprod_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/-- Characterization of the `filter.map` of the coproduct of two principal filters `𝓟 {a}` and\n`𝓟 {i}`, under the `prod.map` of two functions, respectively the constant function `λ a, b` and the\nidentity function.  Together with the previous lemma,\n`map_const_principal_coprod_map_id_principal`, this provides an example showing that the inequality\nin the lemma `map_prod_map_coprod_le` can be strict. -/\ntheorem map_prod_map_const_id_principal_coprod_principal {α β ι : Type _} (a : α) (b : β) (i : ι) :\n    map (prod.map (fun _ : α => b) id) (((filter.principal) {a}).coprod ((filter.principal) {i})) =\n      (filter.principal) (finset.product ({b} : Set β) (univ : Set ι)) :=\n  by\n  rw [principal_coprod_principal, map_principal]\n  congr\n  ext ⟨b', i'⟩\n  constructor\n  · rintro ⟨⟨a'', i''⟩, h₁, h₂, h₃⟩\n    simp\n  · rintro ⟨h₁, h₂⟩\n    use (a, i')\n    simpa using h₁.symm\n#align map_prod_map_const_id_principal_coprod_principal map_prod_map_const_id_principal_coprod_principal\n\n",
 "map_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n#print map_prod /-\nprotected theorem map_prod (m : α × β → γ) (f : Filter α) (g : Filter β) :\n    map m (filter.prod f g) = (f.map fun a b => m (a, b)).seq g :=\n  by\n  simp [Filter.ext_iff, mem_prod_iff, mem_map_seq_iff]\n  intro s\n  constructor\n  exact fun ⟨t, ht, s, hs, h⟩ => ⟨s, hs, t, ht, fun x hx y hy => @h ⟨x, y⟩ ⟨hx, hy⟩⟩\n  exact fun ⟨s, hs, t, ht, h⟩ => ⟨t, ht, s, hs, fun ⟨x, y⟩ ⟨hx, hy⟩ => h x hx y hy⟩\n#align map_prod map_prod\n-/\n\n",
 "map_fst_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n@[simp]\ntheorem map_fst_prod (f : Filter α) (g : Filter β) [NeBot g] : map Prod.fst (filter.prod f g) = f :=\n  by\n  refine' le_antisymm tendsto_fst fun s hs => _\n  rw [mem_map, mem_prod_iff] at hs\n  rcases hs with ⟨t₁, h₁, t₂, h₂, hs⟩\n  rw [← image_subset_iff, fst_image_prod] at hs\n  exacts[mem_of_superset h₁ hs, nonempty_of_mem h₂]\n#align map_fst_prod map_fst_prod\n\n",
 "map_const_principal_coprod_map_id_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/-- Characterization of the coproduct of the `filter.map`s of two principal filters `𝓟 {a}` and\n`𝓟 {i}`, the first under the constant function `λ a, b` and the second under the identity function.\nTogether with the next lemma, `map_prod_map_const_id_principal_coprod_principal`, this provides an\nexample showing that the inequality in the lemma `map_prod_map_coprod_le` can be strict. -/\ntheorem map_const_principal_coprod_map_id_principal {α β ι : Type _} (a : α) (b : β) (i : ι) :\n    (map (fun _ : α => b) ((filter.principal) {a})).coprod (map id ((filter.principal) {i})) =\n      (filter.principal) (finset.product ({b} : Set β) univ ∪ finset.product univ ({i} : Set ι)) :=\n  by\n  simp only [map_principal, Filter.coprod, comap_principal, sup_principal, image_singleton, image_id, prod_univ,\n    univ_prod]\n#align map_const_principal_coprod_map_id_principal map_const_principal_coprod_map_id_principal\n\n",
 "le_prod_map_fst_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem le_prod_map_fst_snd {f : Filter (α × β)} : f ≤ filter.prod (map Prod.fst f) (map Prod.snd f) :=\n  le_inf le_comap_map le_comap_map\n#align le_prod_map_fst_snd le_prod_map_fst_snd\n\n",
 "eventually_swap_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem eventually_swap_iff {p : α × β → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (filter.prod f g) (p x) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (filter.prod g f) (p y.swap) :=\n  by\n  rw [prod_comm, eventually_map]\n  simpa\n#align eventually_swap_iff eventually_swap_iff\n\n",
 "eventually_prod_principal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_prod_principal_iff {p : α × β → Prop} {s : Set β} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (filter.prod f ((filter.principal) s)) (p x) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n        (∀ y : β, y ∈ s → p (x, y)) :=\n  by\n  rw [eventually_iff, eventually_iff, mem_prod_principal]\n  simp only [mem_set_of_eq]\n#align eventually_prod_principal_iff eventually_prod_principal_iff\n\n",
 "eventually_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_prod_iff {p : α × β → Prop} {f : Filter α} {g : Filter β} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (filter.prod f g) (p x) ↔\n      ∃ (pa : α → Prop)(ha :\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n          (pa x))(pb :\n        β → Prop)(hb :\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" g\n          (pb y)),\n        ∀ {x}, pa x → ∀ {y}, pb y → p (x, y) :=\n  by simpa only [Set.prod_subset_iff] using @mem_prod_iff α β p f g\n#align eventually_prod_iff eventually_prod_iff\n\n",
 "diag_of_prod_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem eventually.diag_of_prod_right {f : Filter α} {g : Filter γ} {p : α × γ × γ → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (filter.prod f (filter.prod g g)) (p x) →\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (filter.prod f g) (p (x.1, x.2, x.2)) :=\n  by\n  intro h\n  obtain ⟨t, ht, s, hs, hst⟩ := eventually_prod_iff.1 h\n  refine' (ht.prod_mk hs.diag_of_prod).mono fun x hx => by simp only [hst hx.1 hx.2, prod.mk.eta]\n#align eventually.diag_of_prod_right eventually.diag_of_prod_right\n\n",
 "diag_of_prod_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem eventually.diag_of_prod_left {f : Filter α} {g : Filter γ} {p : (α × α) × γ → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (filter.prod (filter.prod f f) g) (p x) →\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (filter.prod f g) (p ((x.1, x.1), x.2)) :=\n  by\n  intro h\n  obtain ⟨t, ht, s, hs, hst⟩ := eventually_prod_iff.1 h\n  refine' (ht.diag_of_prod.prod_mk hs).mono fun x hx => by simp only [hst hx.1 hx.2, prod.mk.eta]\n#align eventually.diag_of_prod_left eventually.diag_of_prod_left\n\n",
 "diag_of_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- A fact that is eventually true about all pairs `l ×ᶠ l` is eventually true about\nall diagonal pairs `(i, i)` -/\ntheorem eventually.diag_of_prod {f : Filter α} {p : α × α → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (filter.prod f f) (p i)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n      (p (i, i)) :=\n  by\n  obtain ⟨t, ht, s, hs, hst⟩ := eventually_prod_iff.1 h\n  apply (ht.and hs).mono fun x hx => hst hx.1 hx.2\n#align eventually.diag_of_prod eventually.diag_of_prod\n\n",
 "curry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually.curry {la : Filter α} {lb : Filter β} {p : α × β → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (filter.prod la lb) (p x)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" la\n      («expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" lb\n        (p (x, y))) :=\n  by\n  rcases eventually_prod_iff.1 h with ⟨pa, ha, pb, hb, h⟩\n  exact ha.mono fun a ha => hb.mono fun b hb => h ha hb\n#align eventually.curry eventually.curry\n\n",
 "coprod_ne_bot_right":
 "@[instance]\ntheorem coprod_ne_bot_right [NeBot g] [Nonempty α] : (f.coprod g).ne_bot :=\n  coprod_neBot_iff.2 (or.inr ⟨‹_›, ‹_›⟩)\n#align coprod_ne_bot_right coprod_ne_bot_right\n\n",
 "coprod_ne_bot_left":
 "@[instance]\ntheorem coprod_ne_bot_left [NeBot f] [Nonempty β] : (f.coprod g).ne_bot :=\n  coprod_neBot_iff.2 (or.inl ⟨‹_›, ‹_›⟩)\n#align coprod_ne_bot_left coprod_ne_bot_left\n\n",
 "coprod_ne_bot_iff":
 "theorem coprod_ne_bot_iff : (f.coprod g).ne_bot ↔ f.ne_bot ∧ Nonempty β ∨ Nonempty α ∧ g.ne_bot := by\n  simp [Filter.coprod]\n#align coprod_ne_bot_iff coprod_ne_bot_iff\n\n",
 "coprod_mono":
 "@[mono]\ntheorem coprod_mono {f₁ f₂ : Filter α} {g₁ g₂ : Filter β} (hf : f₁ ≤ f₂) (hg : g₁ ≤ g₂) : f₁.coprod g₁ ≤ f₂.coprod g₂ :=\n  sup_le_sup (comap_mono hf) (comap_mono hg)\n#align coprod_mono coprod_mono\n\n",
 "coprod_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem coprod_bot (l : Filter α) : l.coprod («expr⊥» : Filter β) = comap Prod.fst l := by simp [Filter.coprod]\n#align coprod_bot coprod_bot\n\n",
 "compl_mem_coprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem compl_mem_coprod {s : Set (α × β)} {la : Filter α} {lb : Filter β} :\n    «expr ᶜ» s ∈ la.coprod lb ↔ «expr ᶜ» («expr '' » Prod.fst s) ∈ la ∧ «expr ᶜ» («expr '' » Prod.snd s) ∈ lb := by\n  simp only [Filter.coprod, mem_sup, compl_mem_comap]\n#align compl_mem_coprod compl_mem_coprod\n\n",
 "comap_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem comap_prod (f : α → β × γ) (b : Filter β) (c : Filter γ) :\n    comap f (filter.prod b c) = «expr ⊓ » (comap (Prod.fst ∘ f) b) (comap (Prod.snd ∘ f) c) := by\n  erw [comap_inf, Filter.comap_comap, Filter.comap_comap]\n#align comap_prod comap_prod\n\n",
 "bot_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem bot_prod {g : Filter β} : filter.prod («expr⊥» : Filter α) g = «expr⊥» := by simp [Filter.prod]\n#align bot_prod bot_prod\n\n",
 "bot_coprod_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem bot_coprod_bot : («expr⊥» : Filter α).coprod («expr⊥» : Filter β) = «expr⊥» := by simp\n#align bot_coprod_bot bot_coprod_bot\n\n",
 "bot_coprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem bot_coprod (l : Filter β) : («expr⊥» : Filter α).coprod l = comap Prod.snd l := by simp [Filter.coprod]\n#align bot_coprod bot_coprod\n\n"}