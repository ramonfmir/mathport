{"supₛ_atoms_le_eq":
 "#print supₛ_atoms_le_eq /-\n@[simp]\ntheorem supₛ_atoms_le_eq (b : α) : supₛ { a : α | IsAtom a ∧ a ≤ b } = b :=\n  by\n  rcases eq_Sup_atoms b with ⟨s, rfl, hs⟩\n  exact le_antisymm (supₛ_le fun _ => And.right) (supₛ_le_supₛ fun a ha => ⟨hs a ha, le_supₛ ha⟩)\n#align Sup_atoms_le_eq supₛ_atoms_le_eq\n-/\n\n",
 "supₛ_atoms_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print supₛ_atoms_eq_top /-\n@[simp]\ntheorem supₛ_atoms_eq_top : supₛ { a : α | IsAtom a } = «expr⊤» :=\n  by\n  refine' eq.trans (congr rfl (Set.ext fun x => _)) (supₛ_atoms_le_eq («expr⊤»))\n  exact (and_iff_left le_top).symm\n#align Sup_atoms_eq_top supₛ_atoms_eq_top\n-/\n\n",
 "sup_eq_top_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print IsCoatom.sup_eq_top_of_ne /-\ntheorem IsCoatom.sup_eq_top_of_ne [SemilatticeSup α] [OrderTop α] {a b : α} (ha : IsCoatom a) (hb : IsCoatom b)\n    (hab : a ≠ b) : «expr ⊔ » a b = «expr⊤» :=\n  ha.dual.inf_eq_bot_of_ne hb.dual hab\n#align is_coatom.sup_eq_top_of_ne IsCoatom.sup_eq_top_of_ne\n-/\n\n",
 "of_isCoatom_coe_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print IsCoatom.of_isCoatom_coe_Ici /-\ntheorem IsCoatom.of_isCoatom_coe_Ici {a : Set.Ici x} (ha : IsCoatom a) : IsCoatom (a : α) :=\n  @IsAtom.of_isAtom_coe_Iic («expr ᵒᵈ» α) _ _ x a ha\n#align is_coatom.of_is_coatom_coe_Ici IsCoatom.of_isCoatom_coe_Ici\n-/\n\n",
 "of_isAtom_coe_Iic":
 "#print IsAtom.of_isAtom_coe_Iic /-\ntheorem IsAtom.of_isAtom_coe_Iic {a : Set.Iic x} (ha : IsAtom a) : IsAtom (a : α) :=\n  ⟨fun con => ha.1 (subtype.ext con), fun b hba => subtype.mk_eq_mk.1 (ha.2 ⟨b, hba.le.trans a.prop⟩ hba)⟩\n#align is_atom.of_is_atom_coe_Iic IsAtom.of_isAtom_coe_Iic\n-/\n\n",
 "lt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print IsCoatom.lt_iff /-\ntheorem IsCoatom.lt_iff (h : IsCoatom a) : a < x ↔ x = «expr⊤» :=\n  h.dual.lt_iff\n#align is_coatom.lt_iff IsCoatom.lt_iff\n-/\n\n",
 "le_iff_atom_le_imp":
 "#print le_iff_atom_le_imp /-\ntheorem le_iff_atom_le_imp {a b : α} : a ≤ b ↔ ∀ c : α, IsAtom c → c ≤ a → c ≤ b :=\n  ⟨fun ab c hc ca => le_trans ca ab, fun h =>\n    by\n    rw [← supₛ_atoms_le_eq a, ← supₛ_atoms_le_eq b]\n    exact supₛ_le_supₛ fun c hc => ⟨hc.1, h c hc.1 hc.2⟩⟩\n#align le_iff_atom_le_imp le_iff_atom_le_imp\n-/\n\n",
 "le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print IsCoatom.le_iff /-\ntheorem IsCoatom.le_iff (h : IsCoatom a) : a ≤ x ↔ x = «expr⊤» ∨ x = a :=\n  h.dual.le_iff\n#align is_coatom.le_iff IsCoatom.le_iff\n-/\n\n",
 "is_simple_order_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\ntheorem is_simple_order_iff [BoundedOrder α] [BoundedOrder β] (f : «expr ≃o » α β) :\n    IsSimpleOrder α ↔ IsSimpleOrder β := by\n  rw [isSimpleOrder_iff_isAtom_top, isSimpleOrder_iff_isAtom_top, ← f.is_atom_iff («expr⊤»), f.map_top]\n#align is_simple_order_iff is_simple_order_iff\n\n",
 "is_simple_order_Iic_iff_is_atom":
 "theorem is_simple_order_Iic_iff_is_atom [partial_order α] [OrderBot α] {a : α} : IsSimpleOrder (Iic a) ↔ IsAtom a :=\n  isSimpleOrder_iff_isAtom_top.trans <|\n    and_congr (not_congr subtype.mk_eq_mk)\n      ⟨fun h b ab => subtype.mk_eq_mk.1 (h ⟨b, le_of_lt ab⟩ ab), fun h ⟨b, hab⟩ hbotb =>\n        subtype.mk_eq_mk.2 (h b (Subtype.mk_lt_mk.1 hbotb))⟩\n#align is_simple_order_Iic_iff_is_atom is_simple_order_Iic_iff_is_atom\n\n",
 "is_simple_order_Ici_iff_is_coatom":
 "theorem is_simple_order_Ici_iff_is_coatom [partial_order α] [OrderTop α] {a : α} : IsSimpleOrder (Ici a) ↔ IsCoatom a :=\n  isSimpleOrder_iff_isCoatom_bot.trans <|\n    and_congr (not_congr subtype.mk_eq_mk)\n      ⟨fun h b ab => subtype.mk_eq_mk.1 (h ⟨b, le_of_lt ab⟩ ab), fun h ⟨b, hab⟩ hbotb =>\n        subtype.mk_eq_mk.2 (h b (Subtype.mk_lt_mk.1 hbotb))⟩\n#align is_simple_order_Ici_iff_is_coatom is_simple_order_Ici_iff_is_coatom\n\n",
 "is_coatomic_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\nprotected theorem is_coatomic_iff [OrderTop α] [OrderTop β] (f : «expr ≃o » α β) : IsCoatomic α ↔ IsCoatomic β := by\n  simp only [← isAtomic_dual_iff_isCoatomic, f.dual.is_atomic_iff]\n#align is_coatomic_iff is_coatomic_iff\n\n",
 "is_coatom_singleton_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_coatom_singleton_compl (x : α) : IsCoatom («expr ᶜ» {x} : set α) :=\n  (isCoatom_iff («expr ᶜ» {x})).mpr ⟨x, rfl⟩\n#align is_coatom_singleton_compl is_coatom_singleton_compl\n\n",
 "is_coatom_of_map_top_of_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_coatom_of_map_top_of_image [OrderTop α] [OrderTop β] (f : «expr ↪o » β α) (htop : f («expr⊤») = «expr⊤»)\n    {b : β} (hb : IsCoatom (f b)) : IsCoatom b :=\n  f.dual.is_atom_of_map_bot_of_image htop hb\n#align is_coatom_of_map_top_of_image is_coatom_of_map_top_of_image\n\n",
 "is_coatom_of_l_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_coatom_of_l_top [OrderTop α] [OrderTop β] {l : α → β} {u : β → α} (gi : GaloisCoinsertion l u)\n    (hbot : l («expr⊤») = «expr⊤») {a : α} (hb : IsCoatom (l a)) : IsCoatom a :=\n  gi.dual.is_atom_of_u_bot hbot hb.dual\n#align is_coatom_of_l_top is_coatom_of_l_top\n\n",
 "is_coatom_of_image":
 "theorem is_coatom_of_image [OrderTop α] [OrderTop β] {l : α → β} {u : β → α} (gi : GaloisInsertion l u) {b : β}\n    (hb : IsCoatom (u b)) : IsCoatom b :=\n  OrderEmbedding.isCoatom_of_map_top_of_image ⟨⟨u, gi.u_injective⟩, @GaloisInsertion.u_le_u_iff _ _ _ _ _ _ gi⟩\n    gi.gc.u_top hb\n#align is_coatom_of_image is_coatom_of_image\n\n",
 "is_coatom_iff_is_atom":
 "theorem is_coatom_iff_is_atom : IsCoatom a ↔ IsAtom b :=\n  hc.symm.is_atom_iff_is_coatom.symm\n#align is_coatom_iff_is_atom is_coatom_iff_is_atom\n\n",
 "is_coatom_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_coatom_iff' [OrderTop α] [OrderTop β] [IsCoatomic β] {l : α → β} {u : β → α} (gi : GaloisCoinsertion l u)\n    (htop : l («expr⊤») = «expr⊤») (h_coatom : ∀ b, IsCoatom b → l (u b) = b) (a : α) : IsCoatom (l a) ↔ IsCoatom a :=\n  gi.dual.is_atom_iff' htop h_coatom a\n#align is_coatom_iff' is_coatom_iff'\n\n",
 "is_atomic_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\nprotected theorem is_atomic_iff [OrderBot α] [OrderBot β] (f : «expr ≃o » α β) : IsAtomic α ↔ IsAtomic β := by\n  simp only [is_atomic_iff, f.surjective.forall, f.surjective.exists, ← map_bot f, f.eq_iff_eq, f.le_iff_le,\n    f.is_atom_iff]\n#align is_atomic_iff is_atomic_iff\n\n",
 "is_atom_singleton":
 "theorem is_atom_singleton (x : α) : IsAtom ({x} : set α) :=\n  ⟨singleton_ne_empty _, fun s hs => ssubset_singleton_iff.mp hs⟩\n#align is_atom_singleton is_atom_singleton\n\n",
 "is_atom_of_u_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_atom_of_u_bot [OrderBot α] [OrderBot β] {l : α → β} {u : β → α} (gi : GaloisInsertion l u)\n    (hbot : u («expr⊥») = «expr⊥») {b : β} (hb : IsAtom (u b)) : IsAtom b :=\n  OrderEmbedding.isAtom_of_map_bot_of_image ⟨⟨u, gi.u_injective⟩, @GaloisInsertion.u_le_u_iff _ _ _ _ _ _ gi⟩ hbot hb\n#align is_atom_of_u_bot is_atom_of_u_bot\n\n",
 "is_atom_of_map_bot_of_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_atom_of_map_bot_of_image [OrderBot α] [OrderBot β] (f : «expr ↪o » β α) (hbot : f («expr⊥») = «expr⊥»)\n    {b : β} (hb : IsAtom (f b)) : IsAtom b :=\n  by\n  simp only [← bot_covby_iff] at hb⊢\n  exact Covby.of_image f (hbot.symm ▸ hb)\n#align is_atom_of_map_bot_of_image is_atom_of_map_bot_of_image\n\n",
 "is_atom_of_image":
 "theorem is_atom_of_image [OrderBot α] [OrderBot β] {l : α → β} {u : β → α} (gi : GaloisCoinsertion l u) {a : α}\n    (hb : IsAtom (l a)) : IsAtom a :=\n  gi.dual.is_coatom_of_image hb.dual\n#align is_atom_of_image is_atom_of_image\n\n",
 "is_atom_iff_is_coatom":
 "theorem is_atom_iff_is_coatom : IsAtom a ↔ IsCoatom b :=\n  Set.isSimpleOrder_Iic_iff_isAtom.symm.trans <|\n    hc.Iic_order_iso_Ici.is_simple_order_iff.trans Set.isSimpleOrder_Ici_iff_isCoatom\n#align is_atom_iff_is_coatom is_atom_iff_is_coatom\n\n",
 "is_atom_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_atom_iff' [OrderBot α] [IsAtomic α] [OrderBot β] {l : α → β} {u : β → α} (gi : GaloisInsertion l u)\n    (hbot : u («expr⊥») = «expr⊥») (h_atom : ∀ a, IsAtom a → u (l a) = a) (b : β) : IsAtom (u b) ↔ IsAtom b := by\n  rw [← gi.is_atom_iff hbot h_atom, gi.l_u_eq]\n#align is_atom_iff' is_atom_iff'\n\n",
 "isSimpleOrder_iff_isSimpleOrder_orderDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isSimpleOrder_iff_isSimpleOrder_orderDual /-\ntheorem isSimpleOrder_iff_isSimpleOrder_orderDual [LE α] [BoundedOrder α] :\n    IsSimpleOrder α ↔ IsSimpleOrder («expr ᵒᵈ» α) :=\n  by\n  constructor <;> intro i <;> haveI := i\n  ·\n    exact\n      { exists_pair_ne := @exists_pair_ne α _\n        eq_bot_or_eq_top := fun a => Or.symm (eq_bot_or_eq_top (OrderDual.ofDual a) : _ ∨ _) }\n  ·\n    exact\n      { exists_pair_ne := @exists_pair_ne («expr ᵒᵈ» α) _\n        eq_bot_or_eq_top := fun a => Or.symm (eq_bot_or_eq_top (OrderDual.toDual a)) }\n#align is_simple_order_iff_is_simple_order_order_dual isSimpleOrder_iff_isSimpleOrder_orderDual\n-/\n\n",
 "isSimpleOrder_iff_isCoatom_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print isSimpleOrder_iff_isCoatom_bot /-\ntheorem isSimpleOrder_iff_isCoatom_bot [partial_order α] [BoundedOrder α] : IsSimpleOrder α ↔ IsCoatom («expr⊥» : α) :=\n  isSimpleOrder_iff_isSimpleOrder_orderDual.trans isSimpleOrder_iff_isAtom_top\n#align is_simple_order_iff_is_coatom_bot isSimpleOrder_iff_isCoatom_bot\n-/\n\n",
 "isSimpleOrder_iff_isAtom_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print isSimpleOrder_iff_isAtom_top /-\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n-- It is important that in this section `is_simple_order` is the last type-class argument.\ntheorem isSimpleOrder_iff_isAtom_top [partial_order α] [BoundedOrder α] : IsSimpleOrder α ↔ IsAtom («expr⊤» : α) :=\n  ⟨fun h => @isAtom_top _ _ _ h, fun h =>\n    { exists_pair_ne := ⟨«expr⊤», «expr⊥», h.1⟩\n      eq_bot_or_eq_top := fun a => ((eq_or_lt_of_le le_top).imp_right (h.2 a)).symm }⟩\n#align is_simple_order_iff_is_atom_top isSimpleOrder_iff_isAtom_top\n-/\n\n",
 "isCoatomistic_dual_iff_isAtomistic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isCoatomistic_dual_iff_isAtomistic /-\n@[simp]\ntheorem isCoatomistic_dual_iff_isAtomistic : IsCoatomistic («expr ᵒᵈ» α) ↔ IsAtomistic α :=\n  ⟨fun h => ⟨fun b => by apply h.eq_Inf_coatoms⟩, fun h => ⟨fun b => by apply h.eq_Sup_atoms⟩⟩\n#align is_coatomistic_dual_iff_is_atomistic isCoatomistic_dual_iff_isAtomistic\n-/\n\n",
 "isCoatomic_of_orderTop_gt_wellFounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isCoatomic_of_orderTop_gt_wellFounded /-\ntheorem isCoatomic_of_orderTop_gt_wellFounded [OrderTop α] (h : well_founded ((· > ·) : α → α → Prop)) : IsCoatomic α :=\n  isAtomic_dual_iff_isCoatomic.1 (@isAtomic_of_orderBot_wellFounded_lt («expr ᵒᵈ» α) _ _ h)\n#align is_coatomic_of_order_top_gt_well_founded isCoatomic_of_orderTop_gt_wellFounded\n-/\n\n",
 "isCoatomic_of_isAtomic_of_complementedLattice_of_isModular":
 "#print isCoatomic_of_isAtomic_of_complementedLattice_of_isModular /-\ntheorem isCoatomic_of_isAtomic_of_complementedLattice_of_isModular [IsAtomic α] : IsCoatomic α :=\n  ⟨fun x => by\n    rcases exists_is_compl x with ⟨y, xy⟩\n    apply (eq_bot_or_exists_atom_le y).imp _ _\n    · rintro rfl\n      exact eq_top_of_isCompl_bot xy\n    · rintro ⟨a, ha, ay⟩\n      rcases exists_is_compl (xy.symm.Iic_order_iso_Ici ⟨a, ay⟩) with ⟨⟨b, xb⟩, hb⟩\n      refine' ⟨↑(⟨b, xb⟩ : Set.Ici x), IsCoatom.of_isCoatom_coe_Ici _, xb⟩\n      rw [← hb.is_atom_iff_is_coatom, OrderIso.isAtom_iff]\n      apply ha.Iic⟩\n#align\n  is_coatomic_of_is_atomic_of_complemented_lattice_of_is_modular isCoatomic_of_isAtomic_of_complementedLattice_of_isModular\n-/\n\n",
 "isCoatomic_iff_forall_isCoatomic_Ici":
 "#print isCoatomic_iff_forall_isCoatomic_Ici /-\ntheorem isCoatomic_iff_forall_isCoatomic_Ici [OrderTop α] : IsCoatomic α ↔ ∀ x : α, IsCoatomic (Set.Ici x) :=\n  isAtomic_dual_iff_isCoatomic.symm.trans <|\n    isAtomic_iff_forall_isAtomic_Iic.trans <| forall_congr' fun x => isCoatomic_dual_iff_isAtomic.symm.trans iff.rfl\n#align is_coatomic_iff_forall_is_coatomic_Ici isCoatomic_iff_forall_isCoatomic_Ici\n-/\n\n",
 "isCoatomic_dual_iff_isAtomic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isCoatomic_dual_iff_isAtomic /-\n@[simp]\ntheorem isCoatomic_dual_iff_isAtomic [OrderBot α] : IsCoatomic («expr ᵒᵈ» α) ↔ IsAtomic α :=\n  ⟨fun h => ⟨fun b => by apply h.eq_top_or_exists_le_coatom⟩, fun h => ⟨fun b => by apply h.eq_bot_or_exists_atom_le⟩⟩\n#align is_coatomic_dual_iff_is_atomic isCoatomic_dual_iff_isAtomic\n-/\n\n",
 "isCoatom_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print isCoatom_iff /-\ntheorem isCoatom_iff (s : set α) : IsCoatom s ↔ ∃ x, s = «expr ᶜ» {x} := by\n  simp_rw [is_compl_compl.is_coatom_iff_is_atom, isAtom_iff, @eq_comm _ s, compl_eq_comm]\n#align is_coatom_iff isCoatom_iff\n-/\n\n",
 "isCoatom_dual_iff_isAtom":
 "#print isCoatom_dual_iff_isAtom /-\n@[simp]\ntheorem isCoatom_dual_iff_isAtom [OrderBot α] {a : α} : IsCoatom (OrderDual.toDual a) ↔ IsAtom a :=\n  iff.rfl\n#align is_coatom_dual_iff_is_atom isCoatom_dual_iff_isAtom\n-/\n\n",
 "isCoatom_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print isCoatom_bot /-\n@[simp]\ntheorem isCoatom_bot : IsCoatom («expr⊥» : α) :=\n  isAtom_dual_iff_isCoatom.1 isAtom_top\n#align is_coatom_bot isCoatom_bot\n-/\n\n",
 "isAtomistic_dual_iff_isCoatomistic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isAtomistic_dual_iff_isCoatomistic /-\n@[simp]\ntheorem isAtomistic_dual_iff_isCoatomistic : IsAtomistic («expr ᵒᵈ» α) ↔ IsCoatomistic α :=\n  ⟨fun h => ⟨fun b => by apply h.eq_Sup_atoms⟩, fun h => ⟨fun b => by apply h.eq_Inf_coatoms⟩⟩\n#align is_atomistic_dual_iff_is_coatomistic isAtomistic_dual_iff_isCoatomistic\n-/\n\n",
 "isAtomic_of_orderBot_wellFounded_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print isAtomic_of_orderBot_wellFounded_lt /-\ntheorem isAtomic_of_orderBot_wellFounded_lt [OrderBot α] (h : well_founded ((· < ·) : α → α → Prop)) : IsAtomic α :=\n  ⟨fun a =>\n    or_iff_not_imp_left.2 fun ha =>\n      let ⟨b, hb, hm⟩ := h.has_min { b | b ≠ «expr⊥» ∧ b ≤ a } ⟨a, ha, le_rfl⟩\n      ⟨b, ⟨hb.1, fun c => not_imp_not.1 fun hc hl => hm c ⟨hc, hl.le.trans hb.2⟩ hl⟩, hb.2⟩⟩\n#align is_atomic_of_order_bot_well_founded_lt isAtomic_of_orderBot_wellFounded_lt\n-/\n\n",
 "isAtomic_of_isCoatomic_of_complementedLattice_of_isModular":
 "#print isAtomic_of_isCoatomic_of_complementedLattice_of_isModular /-\ntheorem isAtomic_of_isCoatomic_of_complementedLattice_of_isModular [IsCoatomic α] : IsAtomic α :=\n  isCoatomic_dual_iff_isAtomic.1 isCoatomic_of_isAtomic_of_complementedLattice_of_isModular\n#align\n  is_atomic_of_is_coatomic_of_complemented_lattice_of_is_modular isAtomic_of_isCoatomic_of_complementedLattice_of_isModular\n-/\n\n",
 "isAtomic_iff_isCoatomic":
 "#print isAtomic_iff_isCoatomic /-\ntheorem isAtomic_iff_isCoatomic : IsAtomic α ↔ IsCoatomic α :=\n  ⟨fun h => @isCoatomic_of_isAtomic_of_complementedLattice_of_isModular _ _ _ _ _ h, fun h =>\n    @isAtomic_of_isCoatomic_of_complementedLattice_of_isModular _ _ _ _ _ h⟩\n#align is_atomic_iff_is_coatomic isAtomic_iff_isCoatomic\n-/\n\n",
 "isAtomic_iff_forall_isAtomic_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print isAtomic_iff_forall_isAtomic_Iic /-\ntheorem isAtomic_iff_forall_isAtomic_Iic [OrderBot α] : IsAtomic α ↔ ∀ x : α, IsAtomic (Set.Iic x) :=\n  ⟨@IsAtomic.Set.Iic.isAtomic _ _ _, fun h =>\n    ⟨fun x =>\n      ((@eq_bot_or_exists_atom_le _ _ _ (h x)) («expr⊤» : Set.Iic x)).imp subtype.mk_eq_mk.1\n        (Exists.imp' coe fun ⟨a, ha⟩ => and.imp_left IsAtom.of_isAtom_coe_Iic)⟩⟩\n#align is_atomic_iff_forall_is_atomic_Iic isAtomic_iff_forall_isAtomic_Iic\n-/\n\n",
 "isAtomic_dual_iff_isCoatomic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isAtomic_dual_iff_isCoatomic /-\n@[simp]\ntheorem isAtomic_dual_iff_isCoatomic [OrderTop α] : IsAtomic («expr ᵒᵈ» α) ↔ IsCoatomic α :=\n  ⟨fun h => ⟨fun b => by apply h.eq_bot_or_exists_atom_le⟩, fun h => ⟨fun b => by apply h.eq_top_or_exists_le_coatom⟩⟩\n#align is_atomic_dual_iff_is_coatomic isAtomic_dual_iff_isCoatomic\n-/\n\n",
 "isAtom_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print isAtom_top /-\n@[simp]\ntheorem isAtom_top : IsAtom («expr⊤» : α) :=\n  ⟨top_ne_bot, fun a ha => or.resolve_right (eq_bot_or_eq_top a) (ne_of_lt ha)⟩\n#align is_atom_top isAtom_top\n-/\n\n",
 "isAtom_iff":
 "#print isAtom_iff /-\ntheorem isAtom_iff (s : set α) : IsAtom s ↔ ∃ x, s = {x} :=\n  by\n  refine'\n    ⟨_, by\n      rintro ⟨x, rfl⟩\n      exact is_atom_singleton x⟩\n  rw [isAtom_iff, bot_eq_empty, ← nonempty_iff_ne_empty]\n  rintro ⟨⟨x, hx⟩, hs⟩\n  exact\n    ⟨x,\n      eq_singleton_iff_unique_mem.2\n        ⟨hx, fun y hy => (hs {y} (singleton_ne_empty _) (singleton_subset_iff.2 hy) hx).symm⟩⟩\n#align is_atom_iff isAtom_iff\n-/\n\n",
 "isAtom_dual_iff_isCoatom":
 "#print isAtom_dual_iff_isCoatom /-\n@[simp]\ntheorem isAtom_dual_iff_isCoatom [OrderTop α] {a : α} : IsAtom (OrderDual.toDual a) ↔ IsCoatom a :=\n  iff.rfl\n#align is_atom_dual_iff_is_coatom isAtom_dual_iff_isCoatom\n-/\n\n",
 "inf_eq_bot_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print IsAtom.inf_eq_bot_of_ne /-\ntheorem IsAtom.inf_eq_bot_of_ne [SemilatticeInf α] [OrderBot α] {a b : α} (ha : IsAtom a) (hb : IsAtom b)\n    (hab : a ≠ b) : «expr ⊓ » a b = «expr⊥» :=\n  hab.not_le_or_not_le.elim (ha.lt_iff.1 ∘ inf_lt_left.2) (hb.lt_iff.1 ∘ inf_lt_right.2)\n#align is_atom.inf_eq_bot_of_ne IsAtom.inf_eq_bot_of_ne\n-/\n\n",
 "eq_top_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_top_of_lt : b = «expr⊤» :=\n  (is_simple_order.eq_bot_or_eq_top _).resolve_left h.ne_bot\n#align eq_top_of_lt eq_top_of_lt\n\n",
 "eq_bot_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem eq_bot_of_lt : a = «expr⊥» :=\n  (is_simple_order.eq_bot_or_eq_top _).resolve_right h.ne_top\n#align eq_bot_of_lt eq_bot_of_lt\n\n",
 "disjoint_of_ne":
 "#print IsAtom.disjoint_of_ne /-\ntheorem IsAtom.disjoint_of_ne [SemilatticeInf α] [OrderBot α] {a b : α} (ha : IsAtom a) (hb : IsAtom b) (hab : a ≠ b) :\n    Disjoint a b :=\n  disjoint_iff.mpr (IsAtom.inf_eq_bot_of_ne ha hb hab)\n#align is_atom.disjoint_of_ne IsAtom.disjoint_of_ne\n-/\n\n",
 "covby_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋖ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print covby_top_iff /-\n@[simp]\ntheorem covby_top_iff : «expr ⋖ » a («expr⊤») ↔ IsCoatom a :=\n  toDual_covby_toDual_iff.symm.trans bot_covby_iff\n#align covby_top_iff covby_top_iff\n-/\n\n",
 "covby_iff_coatom_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋖ » -/\n#print covby_iff_coatom_Iic /-\ntheorem covby_iff_coatom_Iic (h : a ≤ b) : «expr ⋖ » a b ↔ IsCoatom (⟨a, h⟩ : Set.Iic b) := by simp\n#align covby_iff_coatom_Iic covby_iff_coatom_Iic\n-/\n\n",
 "covby_iff_atom_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋖ » -/\n#print covby_iff_atom_Ici /-\ntheorem covby_iff_atom_Ici (h : a ≤ b) : «expr ⋖ » a b ↔ IsAtom (⟨b, h⟩ : Set.Ici a) := by simp\n#align covby_iff_atom_Ici covby_iff_atom_Ici\n-/\n\n",
 "bot_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print IsSimpleOrder.bot_ne_top /-\ntheorem IsSimpleOrder.bot_ne_top [LE α] [BoundedOrder α] [IsSimpleOrder α] : («expr⊥» : α) ≠ («expr⊤» : α) :=\n  by\n  obtain ⟨a, b, h⟩ := exists_pair_ne α\n  rcases eq_bot_or_eq_top a with (rfl | rfl) <;> rcases eq_bot_or_eq_top b with (rfl | rfl) <;>\n    first |simpa|simpa using h.symm\n#align is_simple_order.bot_ne_top IsSimpleOrder.bot_ne_top\n-/\n\n",
 "bot_covby_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋖ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print bot_covby_top /-\ntheorem bot_covby_top : «expr ⋖ » («expr⊥» : α) («expr⊤») :=\n  isAtom_top.bot_covby\n#align bot_covby_top bot_covby_top\n-/\n\n",
 "bot_covby_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋖ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print bot_covby_iff /-\n@[simp]\ntheorem bot_covby_iff : «expr ⋖ » («expr⊥») a ↔ IsAtom a := by simp only [Covby, bot_lt_iff_ne_bot, IsAtom, not_imp_not]\n#align bot_covby_iff bot_covby_iff\n-/\n\n",
 "IsSimpleOrder":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n#print IsSimpleOrder /-\ntheorem IsSimpleOrder [BoundedOrder α] [BoundedOrder β] [h : IsSimpleOrder β] (f : «expr ≃o » α β) : IsSimpleOrder α :=\n  f.is_simple_order_iff.mpr h\n#align is_simple_order IsSimpleOrder\n-/\n\n",
 "Iic_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print IsAtom.Iic_eq /-\ntheorem IsAtom.Iic_eq (h : IsAtom a) : Set.Iic a = {«expr⊥», a} :=\n  Set.ext fun x => h.le_iff\n#align is_atom.Iic_eq IsAtom.Iic_eq\n-/\n\n",
 "Iic":
 "#print IsAtom.Iic /-\n/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\ntheorem IsAtom.Iic (ha : IsAtom a) (hax : a ≤ x) : IsAtom (⟨a, hax⟩ : Set.Iic x) :=\n  ⟨fun con => ha.1 (subtype.mk_eq_mk.1 con), fun ⟨b, hb⟩ hba => subtype.mk_eq_mk.2 (ha.2 b hba)⟩\n#align is_atom.Iic IsAtom.Iic\n-/\n\n",
 "Ici_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print IsCoatom.Ici_eq /-\ntheorem IsCoatom.Ici_eq (h : IsCoatom a) : Set.Ici a = {«expr⊤», a} :=\n  h.dual.Iic_eq\n#align is_coatom.Ici_eq IsCoatom.Ici_eq\n-/\n\n",
 "Ici":
 "#print IsCoatom.Ici /-\ntheorem IsCoatom.Ici (ha : IsCoatom a) (hax : x ≤ a) : IsCoatom (⟨a, hax⟩ : Set.Ici x) :=\n  ha.dual.Iic hax\n#align is_coatom.Ici IsCoatom.Ici\n-/\n\n"}