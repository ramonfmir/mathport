{"snd":
 "theorem smooth.snd {f : N â†’ M Ã— M'} (hf : smooth J (I.prod I') f) : smooth J I' fun x => (f x).2 :=\n  smooth_snd.comp hf\n#align smooth.snd smooth.snd\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self.self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem smooth.smul {f : M â†’ ğ•œ} {g : M â†’ V} (hf : smooth I (model_with_corners_self.self ğ•œ) f)\n    (hg : smooth I (model_with_corners_self ğ•œ V) g) :\n    smooth I (model_with_corners_self ğ•œ V) fun p => Â«expr â€¢ Â» (f p) (g p) :=\n  hf.smul hg\n#align smooth.smul smooth.smul\n\n",
 "smooth_within_at_univ":
 "theorem smooth_within_at_univ : smooth_within_at I I' f univ x â†” smooth_at I I' f x :=\n  cont_mdiff_within_at_univ\n#align smooth_within_at_univ smooth_within_at_univ\n\n",
 "smooth_within_at_snd":
 "theorem smooth_within_at_snd {s : Set (M Ã— N)} {p : M Ã— N} : smooth_within_at (I.prod J) J Prod.snd s p :=\n  cont_mdiff_within_at_snd\n#align smooth_within_at_snd smooth_within_at_snd\n\n",
 "smooth_within_at_pi_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem smooth_within_at_pi_space :\n    smooth_within_at I (model_with_corners_self ğ•œ (âˆ€ i, Fi i)) Ï† s x â†”\n      âˆ€ i, smooth_within_at I (model_with_corners_self ğ•œ (Fi i)) (fun x => Ï† x i) s x :=\n  cont_mdiff_within_at_pi_space\n#align smooth_within_at_pi_space smooth_within_at_pi_space\n\n",
 "smooth_within_at_one":
 "@[to_additive]\ntheorem smooth_within_at_one [One M'] : smooth_within_at I I' (1 : M â†’ M') s x :=\n  cont_mdiff_within_at_one\n#align smooth_within_at_one smooth_within_at_one\n\n",
 "smooth_within_at_iff_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem smooth_within_at_iff_target :\n    smooth_within_at I I' f s x â†”\n      ContinuousWithinAt f s x âˆ§ smooth_within_at I (model_with_corners_self ğ•œ E') (ext_chart_at I' (f x) âˆ˜ f) s x :=\n  cont_mdiff_within_at_iff_target\n#align smooth_within_at_iff_target smooth_within_at_iff_target\n\n",
 "smooth_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `with_top.nat.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem smooth_within_at_iff :\n    smooth_within_at I I' f s x â†”\n      ContinuousWithinAt f s x âˆ§\n        cont_diff_within_at ğ•œ (with_top.nat.top) (ext_chart_at I' (f x) âˆ˜ f âˆ˜ (ext_chart_at I x).symm)\n          (Â«expr â»Â¹' Â» (ext_chart_at I x).symm s âˆ© range I) (ext_chart_at I x x) :=\n  cont_mdiff_within_at_iff\n#align smooth_within_at_iff smooth_within_at_iff\n\n",
 "smooth_within_at_id":
 "theorem smooth_within_at_id : smooth_within_at I I (id : M â†’ M) s x :=\n  cont_mdiff_within_at_id\n#align smooth_within_at_id smooth_within_at_id\n\n",
 "smooth_within_at_fst":
 "theorem smooth_within_at_fst {s : Set (M Ã— N)} {p : M Ã— N} : smooth_within_at (I.prod J) I Prod.fst s p :=\n  cont_mdiff_within_at_fst\n#align smooth_within_at_fst smooth_within_at_fst\n\n",
 "smooth_within_at_const":
 "theorem smooth_within_at_const : smooth_within_at I I' (fun x : M => c) s x :=\n  cont_mdiff_within_at_const\n#align smooth_within_at_const smooth_within_at_const\n\n",
 "smooth_within_at":
 "theorem smooth_at.smooth_within_at (hf : smooth_at I I' f x) : smooth_within_at I I' f s x :=\n  cont_mdiff_at.cont_mdiff_within_at hf\n#align smooth_at.smooth_within_at smooth_at.smooth_within_at\n\n",
 "smooth_snd":
 "theorem smooth_snd : smooth (I.prod J) J (@Prod.snd M N) :=\n  cont_mdiff_snd\n#align smooth_snd smooth_snd\n\n",
 "smooth_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self.self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- On any vector space, multiplication by a scalar is a smooth operation. -/\ntheorem smooth_smul :\n    smooth ((model_with_corners_self.self ğ•œ).prod (model_with_corners_self ğ•œ V)) (model_with_corners_self ğ•œ V)\n      fun p : ğ•œ Ã— V => Â«expr â€¢ Â» p.1 p.2 :=\n  smooth_iff.2 âŸ¨continuous_smul, fun x y => cont_diff_smul.cont_diff_onâŸ©\n#align smooth_smul smooth_smul\n\n",
 "smooth_prod_assoc":
 "theorem smooth_prod_assoc :\n    smooth ((I.prod I').prod J) (I.prod (I'.prod J)) fun x : (M Ã— M') Ã— N => (x.1.1, x.1.2, x.2) :=\n  smooth_fst.fst.prod_mk <| smooth_fst.snd.prod_mk smooth_snd\n#align smooth_prod_assoc smooth_prod_assoc\n\n",
 "smooth_pi_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem smooth_pi_space :\n    smooth I (model_with_corners_self ğ•œ (âˆ€ i, Fi i)) Ï† â†”\n      âˆ€ i, smooth I (model_with_corners_self ğ•œ (Fi i)) fun x => Ï† x i :=\n  cont_mdiff_pi_space\n#align smooth_pi_space smooth_pi_space\n\n",
 "smooth_one":
 "@[to_additive]\ntheorem smooth_one [One M'] : smooth I I' (1 : M â†’ M') := by simp only [Pi.one_def, smooth_const]\n#align smooth_one smooth_one\n\n",
 "smooth_on_univ":
 "theorem smooth_on_univ : smooth_on I I' f univ â†” smooth I I' f :=\n  cont_mdiff_on_univ\n#align smooth_on_univ smooth_on_univ\n\n",
 "smooth_on_snd":
 "theorem smooth_on_snd {s : Set (M Ã— N)} : smooth_on (I.prod J) J Prod.snd s :=\n  cont_mdiff_on_snd\n#align smooth_on_snd smooth_on_snd\n\n",
 "smooth_on_pi_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem smooth_on_pi_space :\n    smooth_on I (model_with_corners_self ğ•œ (âˆ€ i, Fi i)) Ï† s â†”\n      âˆ€ i, smooth_on I (model_with_corners_self ğ•œ (Fi i)) (fun x => Ï† x i) s :=\n  cont_mdiff_on_pi_space\n#align smooth_on_pi_space smooth_on_pi_space\n\n",
 "smooth_on_one":
 "@[to_additive]\ntheorem smooth_on_one [One M'] : smooth_on I I' (1 : M â†’ M') s :=\n  cont_mdiff_on_one\n#align smooth_on_one smooth_on_one\n\n",
 "smooth_on_iff_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem smooth_on_iff_target :\n    smooth_on I I' f s â†”\n      ContinuousOn f s âˆ§\n        âˆ€ y : M',\n          smooth_on I (model_with_corners_self ğ•œ E') (ext_chart_at I' y âˆ˜ f)\n            (s âˆ© Â«expr â»Â¹' Â» f (ext_chart_at I' y).source) :=\n  cont_mdiff_on_iff_target\n#align smooth_on_iff_target smooth_on_iff_target\n\n",
 "smooth_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem smooth_on_iff :\n    smooth_on I I' f s â†”\n      ContinuousOn f s âˆ§\n        âˆ€ (x : M) (y : M'),\n          cont_diff_on ğ•œ (Â«exprâŠ¤Â») (ext_chart_at I' y âˆ˜ f âˆ˜ (ext_chart_at I x).symm)\n            ((ext_chart_at I x).target âˆ©\n              Â«expr â»Â¹' Â» (ext_chart_at I x).symm (s âˆ© Â«expr â»Â¹' Â» f (ext_chart_at I' y).source)) :=\n  cont_mdiff_on_iff\n#align smooth_on_iff smooth_on_iff\n\n",
 "smooth_on_id":
 "theorem smooth_on_id : smooth_on I I (id : M â†’ M) s :=\n  cont_mdiff_on_id\n#align smooth_on_id smooth_on_id\n\n",
 "smooth_on_fst":
 "theorem smooth_on_fst {s : Set (M Ã— N)} : smooth_on (I.prod J) I Prod.fst s :=\n  cont_mdiff_on_fst\n#align smooth_on_fst smooth_on_fst\n\n",
 "smooth_on_const":
 "theorem smooth_on_const : smooth_on I I' (fun x : M => c) s :=\n  cont_mdiff_on_const\n#align smooth_on_const smooth_on_const\n\n",
 "smooth_on":
 "theorem smooth.smooth_on (hf : smooth I I' f) : smooth_on I I' f s :=\n  cont_mdiff.cont_mdiff_on hf\n#align smooth.smooth_on smooth.smooth_on\n\n",
 "smooth_iff_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem smooth_iff_target :\n    smooth I I' f â†”\n      Continuous f âˆ§\n        âˆ€ y : M',\n          smooth_on I (model_with_corners_self ğ•œ E') (ext_chart_at I' y âˆ˜ f)\n            (Â«expr â»Â¹' Â» f (ext_chart_at I' y).source) :=\n  cont_mdiff_iff_target\n#align smooth_iff_target smooth_iff_target\n\n",
 "smooth_iff_proj_smooth":
 "theorem smooth_iff_proj_smooth {f : M â†’ M' Ã— N'} :\n    smooth I (I'.prod J') f â†” smooth I I' (Prod.fst âˆ˜ f) âˆ§ smooth I J' (Prod.snd âˆ˜ f) :=\n  by\n  constructor\n  Â· intro h\n    exact âŸ¨smooth_fst.comp h, smooth_snd.comp hâŸ©\n  Â· rintro âŸ¨h_fst, h_sndâŸ©\n    simpa only [prod.mk.eta] using h_fst.prod_mk h_snd\n#align smooth_iff_proj_smooth smooth_iff_proj_smooth\n\n",
 "smooth_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem smooth_iff :\n    smooth I I' f â†”\n      Continuous f âˆ§\n        âˆ€ (x : M) (y : M'),\n          cont_diff_on ğ•œ (Â«exprâŠ¤Â») (ext_chart_at I' y âˆ˜ f âˆ˜ (ext_chart_at I x).symm)\n            ((ext_chart_at I x).target âˆ©\n              Â«expr â»Â¹' Â» (ext_chart_at I x).symm (Â«expr â»Â¹' Â» f (ext_chart_at I' y).source)) :=\n  cont_mdiff_iff\n#align smooth_iff smooth_iff\n\n",
 "smooth_id":
 "theorem smooth_id : smooth I I (id : M â†’ M) :=\n  cont_mdiff_id\n#align smooth_id smooth_id\n\n",
 "smooth_fst":
 "theorem smooth_fst : smooth (I.prod J) I (@Prod.fst M N) :=\n  cont_mdiff_fst\n#align smooth_fst smooth_fst\n\n",
 "smooth_const":
 "theorem smooth_const : smooth I I' fun x : M => c :=\n  cont_mdiff_const\n#align smooth_const smooth_const\n\n",
 "smooth_at_snd":
 "theorem smooth_at_snd {p : M Ã— N} : smooth_at (I.prod J) J Prod.snd p :=\n  cont_mdiff_at_snd\n#align smooth_at_snd smooth_at_snd\n\n",
 "smooth_at_pi_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem smooth_at_pi_space :\n    smooth_at I (model_with_corners_self ğ•œ (âˆ€ i, Fi i)) Ï† x â†”\n      âˆ€ i, smooth_at I (model_with_corners_self ğ•œ (Fi i)) (fun x => Ï† x i) x :=\n  cont_mdiff_at_pi_space\n#align smooth_at_pi_space smooth_at_pi_space\n\n",
 "smooth_at_one":
 "@[to_additive]\ntheorem smooth_at_one [One M'] : smooth_at I I' (1 : M â†’ M') x :=\n  cont_mdiff_at_one\n#align smooth_at_one smooth_at_one\n\n",
 "smooth_at_iff_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem smooth_at_iff_target {x : M} :\n    smooth_at I I' f x â†” ContinuousAt f x âˆ§ smooth_at I (model_with_corners_self ğ•œ E') (ext_chart_at I' (f x) âˆ˜ f) x :=\n  cont_mdiff_at_iff_target\n#align smooth_at_iff_target smooth_at_iff_target\n\n",
 "smooth_at_id":
 "theorem smooth_at_id : smooth_at I I (id : M â†’ M) x :=\n  cont_mdiff_at_id\n#align smooth_at_id smooth_at_id\n\n",
 "smooth_at_fst":
 "theorem smooth_at_fst {p : M Ã— N} : smooth_at (I.prod J) I Prod.fst p :=\n  cont_mdiff_at_fst\n#align smooth_at_fst smooth_at_fst\n\n",
 "smooth_at_const":
 "theorem smooth_at_const : smooth_at I I' (fun x : M => c) x :=\n  cont_mdiff_at_const\n#align smooth_at_const smooth_at_const\n\n",
 "smooth_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem smooth_on.smooth_at (h : smooth_on I I' f s) (hx : s âˆˆ (nhds) x) : smooth_at I I' f x :=\n  h.cont_mdiff_at hx\n#align smooth_on.smooth_at smooth_on.smooth_at\n\n",
 "smooth":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem cont_mdiff.smooth (h : cont_mdiff I I' (Â«exprâŠ¤Â») f) : smooth I I' f :=\n  h\n#align cont_mdiff.smooth cont_mdiff.smooth\n\n",
 "prod_mk_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem smooth.prod_mk_space {f : M â†’ E'} {g : M â†’ F'} (hf : smooth I (model_with_corners_self ğ•œ E') f)\n    (hg : smooth I (model_with_corners_self ğ•œ F') g) :\n    smooth I (model_with_corners_self ğ•œ (E' Ã— F')) fun x => (f x, g x) :=\n  hf.prod_mk_space hg\n#align smooth.prod_mk_space smooth.prod_mk_space\n\n",
 "prod_mk":
 "theorem smooth.prod_mk {f : M â†’ M'} {g : M â†’ N'} (hf : smooth I I' f) (hg : smooth I J' g) :\n    smooth I (I'.prod J') fun x => (f x, g x) :=\n  hf.prod_mk hg\n#align smooth.prod_mk smooth.prod_mk\n\n",
 "prod_map'":
 "theorem cont_mdiff_at.prod_map' {p : M Ã— N} (hf : cont_mdiff_at I I' n f p.1) (hg : cont_mdiff_at J J' n g p.2) :\n    cont_mdiff_at (I.prod J) (I'.prod J') n (prod.map f g) p :=\n  by\n  rcases p with âŸ¨âŸ©\n  exact hf.prod_map hg\n#align cont_mdiff_at.prod_map' cont_mdiff_at.prod_map'\n\n",
 "prod_map":
 "theorem smooth.prod_map (hf : smooth I I' f) (hg : smooth J J' g) : smooth (I.prod J) (I'.prod J') (prod.map f g) :=\n  hf.prod_map hg\n#align smooth.prod_map smooth.prod_map\n\n",
 "of_succ":
 "theorem cont_mdiff.of_succ {n : â„•} (h : cont_mdiff I I' n.succ f) : cont_mdiff I I' n f := fun x => (h x).of_succ\n#align cont_mdiff.of_succ cont_mdiff.of_succ\n\n",
 "of_le":
 "theorem cont_mdiff.of_le (hf : cont_mdiff I I' n f) (le : m â‰¤ n) : cont_mdiff I I' m f := fun x => (hf x).of_le le\n#align cont_mdiff.of_le cont_mdiff.of_le\n\n",
 "mono_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_mdiff_within_at.mono_of_mem (hf : cont_mdiff_within_at I I' n f s x) (hts : s âˆˆ nhds_within t x) :\n    cont_mdiff_within_at I I' n f t x :=\n  StructureGroupoid.LocalInvariantProp.liftPropWithinAt_mono_of_mem (cont_diff_within_at_prop_mono_of_mem I I' n) hf hts\n#align cont_mdiff_within_at.mono_of_mem cont_mdiff_within_at.mono_of_mem\n\n",
 "mono":
 "theorem cont_mdiff_on.mono (hf : cont_mdiff_on I I' n f s) (hts : t âŠ† s) : cont_mdiff_on I I' n f t := fun x hx =>\n  (hf x (hts hx)).mono hts\n#align cont_mdiff_on.mono cont_mdiff_on.mono\n\n",
 "is_local_structomorph_on_cont_diff_groupoid_iff_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_local_structomorph_on_cont_diff_groupoid_iff_aux {f : LocalHomeomorph M M'}\n    (hf : LiftPropOn (cont_diff_groupoid (Â«exprâŠ¤Â») I).is_local_structomorph_within_at f f.source) :\n    smooth_on I I f f.source :=\n  by\n  -- It suffices to show smoothness near each `x`\n  apply cont_mdiff_on_of_locally_cont_mdiff_on\n  intro x hx\n  let c := chart_at H x\n  let c' := chart_at H (f x)\n  obtain âŸ¨-, hxfâŸ© := hf x hx\n  -- Since `f` is a local structomorph, it is locally equal to some transferred element `e` of\n  -- the `cont_diff_groupoid`.\n  obtain âŸ¨e, he, he' : eq_on (c' âˆ˜ f âˆ˜ c.symm) e (Â«expr â»Â¹' Â» c.symm f.source âˆ© e.source), hex : c x âˆˆ e.sourceâŸ© :=\n    hxf (by simp only [hx, mfld_simps])\n  -- We choose a convenient set `s` in `M`.\n  let s : Set M := (f.trans c').source âˆ© ((c.trans e).trans c'.symm).source\n  refine' âŸ¨s, (f.trans c').open_source.inter ((c.trans e).trans c'.symm).open_source, _, _âŸ©\n  Â· simp only [mfld_simps]\n    rw [â† he'] <;> simp only [hx, hex, mfld_simps]\n  -- We need to show `f` is `cont_mdiff_on` the domain `s âˆ© f.source`.  We show this in two\n  -- steps: `f` is equal to `c'.symm âˆ˜ e âˆ˜ c` on that domain and that function is\n  -- `cont_mdiff_on` it.\n  have Hâ‚ : cont_mdiff_on I I (Â«exprâŠ¤Â») (c'.symm âˆ˜ e âˆ˜ c) s :=\n    by\n    have hc' : cont_mdiff_on I I (Â«exprâŠ¤Â») c'.symm _ := cont_mdiff_on_chart_symm\n    have he'' : cont_mdiff_on I I (Â«exprâŠ¤Â») e _ := cont_mdiff_on_of_mem_cont_diff_groupoid he\n    have hc : cont_mdiff_on I I (Â«exprâŠ¤Â») c _ := cont_mdiff_on_chart\n    refine' (hc'.comp' (he''.comp' hc)).mono _\n    mfld_set_tac\n  have Hâ‚‚ : eq_on f (c'.symm âˆ˜ e âˆ˜ c) s := by\n    intro y hy\n    simp only [mfld_simps] at hy\n    have hyâ‚ : f y âˆˆ c'.source := by simp only [hy, mfld_simps]\n    have hyâ‚‚ : y âˆˆ c.source := by simp only [hy, mfld_simps]\n    have hyâ‚ƒ : c y âˆˆ Â«expr â»Â¹' Â» c.symm f.source âˆ© e.source := by simp only [hy, mfld_simps]\n    calc\n      f y = c'.symm (c' (f y)) := by rw [c'.left_inv hyâ‚]\n      _ = c'.symm (c' (f (c.symm (c y)))) := by rw [c.left_inv hyâ‚‚]\n      _ = c'.symm (e (c y)) := by rw [â† he' hyâ‚ƒ]\n      \n  refine' (Hâ‚.congr Hâ‚‚).mono _\n  mfld_set_tac\n#align is_local_structomorph_on_cont_diff_groupoid_iff_aux is_local_structomorph_on_cont_diff_groupoid_iff_aux\n\n",
 "is_local_structomorph_on_cont_diff_groupoid_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- Let `M` and `M'` be smooth manifolds with the same model-with-corners, `I`.  Then `f : M â†’ M'`\nis a local structomorphism for `I`, if and only if it is manifold-smooth on the domain of definition\nin both directions. -/\ntheorem is_local_structomorph_on_cont_diff_groupoid_iff (f : LocalHomeomorph M M') :\n    LiftPropOn (cont_diff_groupoid (Â«exprâŠ¤Â») I).is_local_structomorph_within_at f f.source â†”\n      smooth_on I I f f.source âˆ§ smooth_on I I f.symm f.target :=\n  by\n  constructor\n  Â· intro h\n    refine'\n      âŸ¨is_local_structomorph_on_cont_diff_groupoid_iff_aux h, is_local_structomorph_on_cont_diff_groupoid_iff_aux _âŸ©\n    -- todo: we can generalize this part of the proof to a lemma\n    intro X hX\n    let x := f.symm X\n    have hx : x âˆˆ f.source := f.symm.maps_to hX\n    let c := chart_at H x\n    let c' := chart_at H X\n    obtain âŸ¨-, hxfâŸ© := h x hx\n    refine' âŸ¨(f.symm.continuous_at hX).continuous_within_at, fun h2x => _âŸ©\n    obtain âŸ¨e, he, h2e, hef, hexâŸ© :\n      âˆƒ e : LocalHomeomorph H H,\n        e âˆˆ cont_diff_groupoid (Â«exprâŠ¤Â») I âˆ§\n          e.source âŠ† (local_homeomorph.trans c.symm (local_homeomorph.trans f c')).source âˆ§\n            eq_on (c' âˆ˜ f âˆ˜ c.symm) e e.source âˆ§ c x âˆˆ e.source :=\n      by\n      have h1 : c' = chart_at H (f x) := by simp only [f.right_inv hX]\n      have h2 :\n        Â«exprâ‡‘ Â» c' âˆ˜ Â«exprâ‡‘ Â» f âˆ˜ Â«exprâ‡‘ Â» c.symm =\n          Â«exprâ‡‘ Â» (local_homeomorph.trans c.symm (local_homeomorph.trans f c')) :=\n        rfl\n      have hcx : c x âˆˆ Â«expr â»Â¹' Â» c.symm f.source := by simp only [hx, mfld_simps]\n      rw [h2]\n      rw [â† h1, h2, LocalHomeomorph.isLocalStructomorphWithinAt_iff'] at hxf\n      Â· exact hxf hcx\n      Â· mfld_set_tac\n      Â· apply or.inl\n        simp only [hx, h1, mfld_simps]\n    have h2X : c' X = e (c (f.symm X)) := by\n      rw [â† hef hex]\n      dsimp only [Function.comp]\n      have hfX : f.symm X âˆˆ c.source := by simp only [hX, mfld_simps]\n      rw [c.left_inv hfX, f.right_inv hX]\n    have h3e : eq_on (c âˆ˜ f.symm âˆ˜ c'.symm) e.symm (Â«expr â»Â¹' Â» c'.symm f.target âˆ© e.target) :=\n      by\n      have h1 : eq_on (local_homeomorph.trans c.symm (local_homeomorph.trans f c')).symm e.symm (e.target âˆ© e.target) :=\n        by\n        apply eq_on.symm\n        refine' e.is_image_source_target.symm_eq_on_of_inter_eq_of_eq_on _ _\n        Â· rw [inter_self, inter_eq_right_iff_subset.mpr h2e]\n        rw [inter_self]\n        exact hef.symm\n      have h2 : e.target âŠ† (local_homeomorph.trans c.symm (local_homeomorph.trans f c')).target :=\n        by\n        intro x hx\n        rw [â† e.right_inv hx, â† hef (e.symm.maps_to hx)]\n        exact LocalHomeomorph.mapsTo _ (h2e <| e.symm.maps_to hx)\n      rw [inter_self] at h1\n      rwa [inter_eq_right_iff_subset.mpr]\n      refine' h2.trans _\n      mfld_set_tac\n    refine' âŸ¨e.symm, StructureGroupoid.symm _ he, h3e, _âŸ©\n    rw [h2X]\n    exact e.maps_to hex\n  Â· -- We now show the converse: a local homeomorphism `f : M â†’ M'` which is smooth in both\n    -- directions is a local structomorphism.  We do this by proposing\n    -- `((chart_at H x).symm.trans f).trans (chart_at H (f x))` as a candidate for a structomorphism\n    -- of `H`.\n    rintro âŸ¨hâ‚, hâ‚‚âŸ© x hx\n    refine' âŸ¨(hâ‚ x hx).continuous_within_at, _âŸ©\n    let c := chart_at H x\n    let c' := chart_at H (f x)\n    rintro (hx' : c x âˆˆ Â«expr â»Â¹' Â» c.symm f.source)\n    -- propose `(c.symm.trans f).trans c'` as a candidate for a local structomorphism of `H`\n    refine' âŸ¨(c.symm.trans f).trans c', âŸ¨_, _âŸ©, (_ : eq_on (c' âˆ˜ f âˆ˜ c.symm) _ _), _âŸ©\n    Â· -- smoothness of the candidate local structomorphism in the forward direction\n      intro y hy\n      simp only [mfld_simps] at hy\n      have H : cont_mdiff_within_at I I (Â«exprâŠ¤Â») f (local_homeomorph.trans f c').source ((ext_chart_at I x).symm y) :=\n        by\n        refine' (hâ‚ ((ext_chart_at I x).symm y) _).mono _\n        Â· simp only [hy, mfld_simps]\n        Â· mfld_set_tac\n      have hy' : (ext_chart_at I x).symm y âˆˆ c.source := by simp only [hy, mfld_simps]\n      have hy'' : f ((ext_chart_at I x).symm y) âˆˆ c'.source := by simp only [hy, mfld_simps]\n      rw [cont_mdiff_within_at_iff_of_mem_source hy' hy''] at H\n      Â· convert H.2.mono _\n        Â· simp only [hy, mfld_simps]\n        Â· mfld_set_tac\n      Â· infer_instance\n      Â· infer_instance\n    Â· -- smoothness of the candidate local structomorphism in the reverse direction\n      intro y hy\n      simp only [mfld_simps] at hy\n      have H :\n        cont_mdiff_within_at I I (Â«exprâŠ¤Â») f.symm (local_homeomorph.trans f.symm c).source\n          ((ext_chart_at I (f x)).symm y) :=\n        by\n        refine' (hâ‚‚ ((ext_chart_at I (f x)).symm y) _).mono _\n        Â· simp only [hy, mfld_simps]\n        Â· mfld_set_tac\n      have hy' : (ext_chart_at I (f x)).symm y âˆˆ c'.source := by simp only [hy, mfld_simps]\n      have hy'' : f.symm ((ext_chart_at I (f x)).symm y) âˆˆ c.source := by simp only [hy, mfld_simps]\n      rw [cont_mdiff_within_at_iff_of_mem_source hy' hy''] at H\n      Â· convert H.2.mono _\n        Â· simp only [hy, mfld_simps]\n        Â· mfld_set_tac\n      Â· infer_instance\n      Â· infer_instance\n    -- now check the candidate local structomorphism agrees with `f` where it is supposed to\n    Â· simp only [mfld_simps]\n    Â· simp only [hx', mfld_simps]\n#align is_local_structomorph_on_cont_diff_groupoid_iff is_local_structomorph_on_cont_diff_groupoid_iff\n\n",
 "fst":
 "theorem smooth.fst {f : N â†’ M Ã— M'} (hf : smooth J (I.prod I') f) : smooth J I fun x => (f x).1 :=\n  smooth_fst.comp hf\n#align smooth.fst smooth.fst\n\n",
 "continuous_within_at":
 "theorem cont_mdiff_within_at.continuous_within_at (hf : cont_mdiff_within_at I I' n f s x) : ContinuousWithinAt f s x :=\n  hf.1\n#align cont_mdiff_within_at.continuous_within_at cont_mdiff_within_at.continuous_within_at\n\n",
 "continuous_on":
 "theorem cont_mdiff_on.continuous_on (hf : cont_mdiff_on I I' n f s) : ContinuousOn f s := fun x hx =>\n  (hf x hx).continuous_within_at\n#align cont_mdiff_on.continuous_on cont_mdiff_on.continuous_on\n\n",
 "continuous_at":
 "theorem cont_mdiff_at.continuous_at (hf : cont_mdiff_at I I' n f x) : ContinuousAt f x :=\n  (continuousWithinAt_univ _ _).1 <| cont_mdiff_within_at.continuous_within_at hf\n#align cont_mdiff_at.continuous_at cont_mdiff_at.continuous_at\n\n",
 "continuous":
 "theorem cont_mdiff.continuous (hf : cont_mdiff I I' n f) : Continuous f :=\n  continuous_iff_continuousAt.2 fun x => (hf x).continuous_at\n#align cont_mdiff.continuous cont_mdiff.continuous\n\n",
 "cont_mdiff_within_at_univ":
 "theorem cont_mdiff_within_at_univ : cont_mdiff_within_at I I' n f univ x â†” cont_mdiff_at I I' n f x :=\n  iff.rfl\n#align cont_mdiff_within_at_univ cont_mdiff_within_at_univ\n\n",
 "cont_mdiff_within_at_top":
 "theorem cont_mdiff_within_at_top : smooth_within_at I I' f s x â†” âˆ€ n : â„•, cont_mdiff_within_at I I' n f s x :=\n  âŸ¨fun h n => âŸ¨h.1, cont_diff_within_at_top.1 h.2 nâŸ©, fun H => âŸ¨(H 0).1, cont_diff_within_at_top.2 fun n => (H n).2âŸ©âŸ©\n#align cont_mdiff_within_at_top cont_mdiff_within_at_top\n\n",
 "cont_mdiff_within_at_snd":
 "theorem cont_mdiff_within_at_snd {s : Set (M Ã— N)} {p : M Ã— N} : cont_mdiff_within_at (I.prod J) J n Prod.snd s p :=\n  by\n  rw [cont_mdiff_within_at_iff']\n  refine' âŸ¨continuousWithinAt_snd, _âŸ©\n  refine' cont_diff_within_at_snd.congr (fun y hy => _) _\n  Â· simp only [mfld_simps] at hy\n    simp only [hy, mfld_simps]\n  Â· simp only [mfld_simps]\n#align cont_mdiff_within_at_snd cont_mdiff_within_at_snd\n\n",
 "cont_mdiff_within_at_prod_iff":
 "theorem cont_mdiff_within_at_prod_iff (f : M â†’ M' Ã— N') {s : Set M} {x : M} :\n    cont_mdiff_within_at I (I'.prod J') n f s x â†”\n      cont_mdiff_within_at I I' n (Prod.fst âˆ˜ f) s x âˆ§ cont_mdiff_within_at I J' n (Prod.snd âˆ˜ f) s x :=\n  by\n  refine' âŸ¨fun h => âŸ¨h.fst, h.sndâŸ©, fun h => _âŸ©\n  simpa only [prod.mk.eta] using h.1.prod_mk h.2\n#align cont_mdiff_within_at_prod_iff cont_mdiff_within_at_prod_iff\n\n",
 "cont_mdiff_within_at_pi_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_within_at_pi_space :\n    cont_mdiff_within_at I (model_with_corners_self ğ•œ (âˆ€ i, Fi i)) n Ï† s x â†”\n      âˆ€ i, cont_mdiff_within_at I (model_with_corners_self ğ•œ (Fi i)) n (fun x => Ï† x i) s x :=\n  by\n  simp only [cont_mdiff_within_at_iff, continuousWithinAt_pi, cont_diff_within_at_pi, forall_and,\n    written_in_ext_chart_at, ext_chart_at_model_space_eq_id, (Â· âˆ˜ Â·), LocalEquiv.refl_coe, id]\n#align cont_mdiff_within_at_pi_space cont_mdiff_within_at_pi_space\n\n",
 "cont_mdiff_within_at_one":
 "@[to_additive]\ntheorem cont_mdiff_within_at_one [One M'] : cont_mdiff_within_at I I' n (1 : M â†’ M') s x :=\n  cont_mdiff_at_const.cont_mdiff_within_at\n#align cont_mdiff_within_at_one cont_mdiff_within_at_one\n\n",
 "cont_mdiff_within_at_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_mdiff_within_at_inter' (ht : t âˆˆ nhds_within s x) :\n    cont_mdiff_within_at I I' n f (s âˆ© t) x â†” cont_mdiff_within_at I I' n f s x :=\n  (cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_inter' ht\n#align cont_mdiff_within_at_inter' cont_mdiff_within_at_inter'\n\n",
 "cont_mdiff_within_at_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_mdiff_within_at_inter (ht : t âˆˆ (nhds) x) :\n    cont_mdiff_within_at I I' n f (s âˆ© t) x â†” cont_mdiff_within_at I I' n f s x :=\n  (cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_inter ht\n#align cont_mdiff_within_at_inter cont_mdiff_within_at_inter\n\n",
 "cont_mdiff_within_at_iff_target_of_mem_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_within_at_iff_target_of_mem_source {x : M} {y : M'} (hy : f x âˆˆ (chart_at H' y).source) :\n    cont_mdiff_within_at I I' n f s x â†”\n      ContinuousWithinAt f s x âˆ§ cont_mdiff_within_at I (model_with_corners_self ğ•œ E') n (ext_chart_at I' y âˆ˜ f) s x :=\n  by\n  simp_rw [cont_mdiff_within_at]\n  rw [(cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_indep_chart_target\n      (chart_mem_maximal_atlas I' y) hy,\n    and_congr_right]\n  intro hf\n  simp_rw [StructureGroupoid.liftPropWithinAt_self_target]\n  simp_rw [((chart_at H' y).continuous_at hy).comp_continuous_within_at hf]\n  rw [â† ext_chart_at_source I'] at hy\n  simp_rw [(continuous_at_ext_chart_at' I' _ hy).comp_continuous_within_at hf]\n  rfl\n#align cont_mdiff_within_at_iff_target_of_mem_source cont_mdiff_within_at_iff_target_of_mem_source\n\n",
 "cont_mdiff_within_at_iff_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/-- One can reformulate smoothness within a set at a point as continuity within this set at this\npoint, and smoothness in the corresponding extended chart in the target. -/\ntheorem cont_mdiff_within_at_iff_target :\n    cont_mdiff_within_at I I' n f s x â†”\n      ContinuousWithinAt f s x âˆ§\n        cont_mdiff_within_at I (model_with_corners_self ğ•œ E') n (ext_chart_at I' (f x) âˆ˜ f) s x :=\n  by\n  simp_rw [cont_mdiff_within_at, lift_prop_within_at, â† and_assoc']\n  have cont :\n    ContinuousWithinAt f s x âˆ§ ContinuousWithinAt (ext_chart_at I' (f x) âˆ˜ f) s x â†” ContinuousWithinAt f s x :=\n    by\n    refine' âŸ¨fun h => h.1, fun h => âŸ¨h, _âŸ©âŸ©\n    have hâ‚‚ := (chart_at H' (f x)).continuous_to_fun.continuous_within_at (mem_chart_source _ _)\n    refine' ((I'.continuous_at.comp_continuous_within_at hâ‚‚).comp' h).mono_of_mem _\n    exact\n      inter_mem self_mem_nhdsWithin\n        (h.preimage_mem_nhds_within <| (chart_at _ _).open_source.mem_nhds <| mem_chart_source _ _)\n  simp_rw [cont, cont_diff_within_at_prop, ext_chart_at, local_homeomorph.extend, LocalEquiv.coe_trans,\n    model_with_corners.to_local_equiv_coe, LocalHomeomorph.coe_coe, model_with_corners_self_coe, chartAt_self_eq,\n    local_homeomorph.refl_apply, comp.left_id]\n#align cont_mdiff_within_at_iff_target cont_mdiff_within_at_iff_target\n\n",
 "cont_mdiff_within_at_iff_source_of_mem_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem cont_mdiff_within_at_iff_source_of_mem_source {x' : M} (hx' : x' âˆˆ (chart_at H x).source) :\n    cont_mdiff_within_at I I' n f s x' â†”\n      cont_mdiff_within_at (model_with_corners_self ğ•œ E) I' n (f âˆ˜ (ext_chart_at I x).symm)\n        (Â«expr â»Â¹' Â» (ext_chart_at I x).symm s âˆ© range I) (ext_chart_at I x x') :=\n  cont_mdiff_within_at_iff_source_of_mem_maximal_atlas (chart_mem_maximal_atlas I x) hx'\n#align cont_mdiff_within_at_iff_source_of_mem_source cont_mdiff_within_at_iff_source_of_mem_source\n\n",
 "cont_mdiff_within_at_iff_source_of_mem_maximal_atlas":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem cont_mdiff_within_at_iff_source_of_mem_maximal_atlas (he : e âˆˆ maximal_atlas I M) (hx : x âˆˆ e.source) :\n    cont_mdiff_within_at I I' n f s x â†”\n      cont_mdiff_within_at (model_with_corners_self ğ•œ E) I' n (f âˆ˜ (e.extend I).symm)\n        (Â«expr â»Â¹' Â» (e.extend I).symm s âˆ© range I) (e.extend I x) :=\n  by\n  have h2x := hx; rw [â† e.extend_source I] at h2x\n  simp_rw [cont_mdiff_within_at,\n    (cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_indep_chart_source he hx,\n    StructureGroupoid.liftPropWithinAt_self_source, e.extend_symm_continuous_within_at_comp_right_iff,\n    cont_diff_within_at_prop_self_source, cont_diff_within_at_prop, Function.comp, e.left_inv hx,\n    (e.extend I).left_inv h2x]\n  rfl\n#align cont_mdiff_within_at_iff_source_of_mem_maximal_atlas cont_mdiff_within_at_iff_source_of_mem_maximal_atlas\n\n",
 "cont_mdiff_within_at_iff_of_mem_source'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem cont_mdiff_within_at_iff_of_mem_source' {x' : M} {y : M'} (hx : x' âˆˆ (chart_at H x).source)\n    (hy : f x' âˆˆ (chart_at H' y).source) :\n    cont_mdiff_within_at I I' n f s x' â†”\n      ContinuousWithinAt f s x' âˆ§\n        cont_diff_within_at ğ•œ n (ext_chart_at I' y âˆ˜ f âˆ˜ (ext_chart_at I x).symm)\n          ((ext_chart_at I x).target âˆ©\n            Â«expr â»Â¹' Â» (ext_chart_at I x).symm (s âˆ© Â«expr â»Â¹' Â» f (ext_chart_at I' y).source))\n          (ext_chart_at I x x') :=\n  by\n  refine' (cont_mdiff_within_at_iff_of_mem_source hx hy).trans _\n  rw [â† ext_chart_at_source I] at hx\n  rw [â† ext_chart_at_source I'] at hy\n  rw [and_congr_right_iff]\n  set e := ext_chart_at I x; set e' := ext_chart_at I' (f x)\n  refine' fun hc => cont_diff_within_at_congr_nhds _\n  rw [â† e.image_source_inter_eq', â† map_ext_chart_at_nhds_within_eq_image' I x hx, â†\n    map_ext_chart_at_nhds_within' I x hx, inter_comm, nhdsWithin_inter_of_mem]\n  exact hc (ext_chart_at_source_mem_nhds' _ _ hy)\n#align cont_mdiff_within_at_iff_of_mem_source' cont_mdiff_within_at_iff_of_mem_source'\n\n",
 "cont_mdiff_within_at_iff_of_mem_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- One can reformulate smoothness within a set at a point as continuity within this set at this\npoint, and smoothness in any chart containing that point. -/\ntheorem cont_mdiff_within_at_iff_of_mem_source {x' : M} {y : M'} (hx : x' âˆˆ (chart_at H x).source)\n    (hy : f x' âˆˆ (chart_at H' y).source) :\n    cont_mdiff_within_at I I' n f s x' â†”\n      ContinuousWithinAt f s x' âˆ§\n        cont_diff_within_at ğ•œ n (ext_chart_at I' y âˆ˜ f âˆ˜ (ext_chart_at I x).symm)\n          (Â«expr â»Â¹' Â» (ext_chart_at I x).symm s âˆ© range I) (ext_chart_at I x x') :=\n  cont_mdiff_within_at_iff_of_mem_maximal_atlas (chart_mem_maximal_atlas _ x) (chart_mem_maximal_atlas _ y) hx hy\n#align cont_mdiff_within_at_iff_of_mem_source cont_mdiff_within_at_iff_of_mem_source\n\n",
 "cont_mdiff_within_at_iff_of_mem_maximal_atlas":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem cont_mdiff_within_at_iff_of_mem_maximal_atlas {x : M} (he : e âˆˆ maximal_atlas I M)\n    (he' : e' âˆˆ maximal_atlas I' M') (hx : x âˆˆ e.source) (hy : f x âˆˆ e'.source) :\n    cont_mdiff_within_at I I' n f s x â†”\n      ContinuousWithinAt f s x âˆ§\n        cont_diff_within_at ğ•œ n (e'.extend I' âˆ˜ f âˆ˜ (e.extend I).symm) (Â«expr â»Â¹' Â» (e.extend I).symm s âˆ© range I)\n          (e.extend I x) :=\n  (cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_indep_chart he hx he' hy\n#align cont_mdiff_within_at_iff_of_mem_maximal_atlas cont_mdiff_within_at_iff_of_mem_maximal_atlas\n\n",
 "cont_mdiff_within_at_iff_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\ntheorem cont_mdiff_within_at_iff_nat :\n    cont_mdiff_within_at I I' n f s x â†” âˆ€ m : â„•, (m : Â«exprâ„•âˆÂ») â‰¤ n â†’ cont_mdiff_within_at I I' m f s x :=\n  by\n  refine' âŸ¨fun h m hm => h.of_le hm, fun h => _âŸ©\n  cases n\n  Â· exact cont_mdiff_within_at_top.2 fun n => h n le_top\n  Â· exact h n le_rfl\n#align cont_mdiff_within_at_iff_nat cont_mdiff_within_at_iff_nat\n\n",
 "cont_mdiff_within_at_iff_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- An alternative formulation of `cont_mdiff_within_at_iff_of_mem_maximal_atlas`\n  if the set if `s` lies in `e.source`. -/\ntheorem cont_mdiff_within_at_iff_image {x : M} (he : e âˆˆ maximal_atlas I M) (he' : e' âˆˆ maximal_atlas I' M')\n    (hs : s âŠ† e.source) (hx : x âˆˆ e.source) (hy : f x âˆˆ e'.source) :\n    cont_mdiff_within_at I I' n f s x â†”\n      ContinuousWithinAt f s x âˆ§\n        cont_diff_within_at ğ•œ n (e'.extend I' âˆ˜ f âˆ˜ (e.extend I).symm) (Â«expr '' Â» (e.extend I) s) (e.extend I x) :=\n  by\n  rw [cont_mdiff_within_at_iff_of_mem_maximal_atlas he he' hx hy, and_congr_right_iff]\n  refine' fun hf => cont_diff_within_at_congr_nhds _\n  simp_rw [nhdsWithin_eq_iff_eventuallyEq, e.extend_symm_preimage_inter_range_eventually_eq I hs hx]\n#align cont_mdiff_within_at_iff_image cont_mdiff_within_at_iff_image\n\n",
 "cont_mdiff_within_at_iff_cont_mdiff_on_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- A function is `C^n` within a set at a point, for `n : â„•`, if and only if it is `C^n` on\na neighborhood of this point. -/\ntheorem cont_mdiff_within_at_iff_cont_mdiff_on_nhds {n : â„•} :\n    cont_mdiff_within_at I I' n f s x â†” âˆƒ u âˆˆ nhds_within (insert x s) x, cont_mdiff_on I I' n f u :=\n  by\n  constructor\n  Â· intro h\n    -- the property is true in charts. We will pull such a good neighborhood in the chart to the\n    -- manifold. For this, we need to restrict to a small enough set where everything makes sense\n    obtain âŸ¨o, o_open, xo, ho, h'oâŸ© :\n      âˆƒ o : Set M, IsOpen o âˆ§ x âˆˆ o âˆ§ o âŠ† (chart_at H x).source âˆ§ o âˆ© s âŠ† Â«expr â»Â¹' Â» f (chart_at H' (f x)).source :=\n      by\n      have : (chart_at H' (f x)).source âˆˆ (nhds) (f x) :=\n        IsOpen.mem_nhds (local_homeomorph.open_source _) (mem_chart_source H' (f x))\n      rcases mem_nhdsWithin.1 (h.1.preimage_mem_nhds_within this) with âŸ¨u, u_open, xu, huâŸ©\n      refine' âŸ¨u âˆ© (chart_at H x).source, _, âŸ¨xu, mem_chart_source _ _âŸ©, _, _âŸ©\n      Â· exact IsOpen.inter u_open (local_homeomorph.open_source _)\n      Â· intro y hy\n        exact hy.2\n      Â· intro y hy\n        exact hu âŸ¨hy.1.1, hy.2âŸ©\n    have h' : cont_mdiff_within_at I I' n f (s âˆ© o) x := h.mono (inter_subset_left _ _)\n    simp only [cont_mdiff_within_at, lift_prop_within_at, cont_diff_within_at_prop] at h'\n    -- let `u` be a good neighborhood in the chart where the function is smooth\n    rcases h.2.cont_diff_on le_rfl with âŸ¨u, u_nhds, u_subset, huâŸ©\n    -- pull it back to the manifold, and intersect with a suitable neighborhood of `x`, to get the\n    -- desired good neighborhood `v`.\n    let v := insert x s âˆ© o âˆ© Â«expr â»Â¹' Â» (ext_chart_at I x) u\n    have v_incl : v âŠ† (chart_at H x).source := fun y hy => ho hy.1.2\n    have v_incl' : âˆ€ y âˆˆ v, f y âˆˆ (chart_at H' (f x)).source :=\n      by\n      intro y hy\n      rcases hy.1.1 with (rfl | h')\n      Â· simp only [mfld_simps]\n      Â· apply h'o âŸ¨hy.1.2, h'âŸ©\n    refine' âŸ¨v, _, _âŸ©\n    show v âˆˆ nhds_within (insert x s) x\n    Â· rw [nhdsWithin_restrict _ xo o_open]\n      refine' Filter.inter_mem self_mem_nhdsWithin _\n      suffices : u âˆˆ nhds_within (Â«expr '' Â» (ext_chart_at I x) (insert x s âˆ© o)) (ext_chart_at I x x)\n      exact (continuous_at_ext_chart_at I x).continuous_within_at.preimage_mem_nhds_within' this\n      apply nhdsWithin_mono _ _ u_nhds\n      rw [image_subset_iff]\n      intro y hy\n      rcases hy.1 with (rfl | h')\n      Â· simp only [mem_insert_iff, mfld_simps]\n      Â· simp only [mem_insert_iff, ho hy.2, h', h'o âŸ¨hy.2, h'âŸ©, mfld_simps]\n    show cont_mdiff_on I I' n f v\n    Â· intro y hy\n      have : ContinuousWithinAt f v y :=\n        by\n        apply\n          (((continuous_on_ext_chart_at_symm I' (f x) _ _).comp' (hu _ hy.2).continuous_within_at).comp'\n              (continuous_on_ext_chart_at I x _ _)).congr_mono\n        Â· intro z hz\n          simp only [v_incl hz, v_incl' z hz, mfld_simps]\n        Â· intro z hz\n          simp only [v_incl hz, v_incl' z hz, mfld_simps]\n          exact hz.2\n        Â· simp only [v_incl hy, v_incl' y hy, mfld_simps]\n        Â· simp only [v_incl hy, v_incl' y hy, mfld_simps]\n        Â· simp only [v_incl hy, mfld_simps]\n      refine' (cont_mdiff_within_at_iff_of_mem_source' (v_incl hy) (v_incl' y hy)).mpr âŸ¨this, _âŸ©\n      Â· apply hu.mono\n        Â· intro z hz\n          simp only [v, mfld_simps] at hz\n          have : I ((chart_at H x) ((chart_at H x).symm (I.symm z))) âˆˆ u := by simp only [hz]\n          simpa only [hz, mfld_simps] using this\n        Â· have exty : I (chart_at H x y) âˆˆ u := hy.2\n          simp only [v_incl hy, v_incl' y hy, exty, hy.1.1, hy.1.2, mfld_simps]\n  Â· rintro âŸ¨u, u_nhds, huâŸ©\n    have : cont_mdiff_within_at I I' (â†‘n) f (insert x s âˆ© u) x :=\n      haveI : x âˆˆ insert x s := mem_insert x s\n      hu.mono (inter_subset_right _ _) _ âŸ¨this, mem_of_mem_nhdsWithin this u_nhdsâŸ©\n    rw [cont_mdiff_within_at_inter' u_nhds] at this\n    exact this.mono (subset_insert x s)\n#align cont_mdiff_within_at_iff_cont_mdiff_on_nhds cont_mdiff_within_at_iff_cont_mdiff_on_nhds\n\n",
 "cont_mdiff_within_at_iff_cont_diff_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_within_at_iff_cont_diff_within_at {f : E â†’ E'} {s : Set E} {x : E} :\n    cont_mdiff_within_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f s x â†”\n      cont_diff_within_at ğ•œ n f s x :=\n  by\n  simp (config := { contextual := true }) only [cont_mdiff_within_at, lift_prop_within_at, cont_diff_within_at_prop,\n    iff_def, mfld_simps]\n  exact cont_diff_within_at.continuous_within_at\n#align cont_mdiff_within_at_iff_cont_diff_within_at cont_mdiff_within_at_iff_cont_diff_within_at\n\n",
 "cont_mdiff_within_at_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- One can reformulate smoothness within a set at a point as continuity within this set at this\npoint, and smoothness in the corresponding extended chart. This form states smoothness of `f`\nwritten in such a way that the set is restricted to lie within the domain/codomain of the\ncorresponding charts.\nEven though this expression is more complicated than the one in `cont_mdiff_within_at_iff`, it is\na smaller set, but their germs at `ext_chart_at I x x` are equal. It is sometimes useful to rewrite\nusing this in the goal.\n-/\ntheorem cont_mdiff_within_at_iff' :\n    cont_mdiff_within_at I I' n f s x â†”\n      ContinuousWithinAt f s x âˆ§\n        cont_diff_within_at ğ•œ n (ext_chart_at I' (f x) âˆ˜ f âˆ˜ (ext_chart_at I x).symm)\n          ((ext_chart_at I x).target âˆ©\n            Â«expr â»Â¹' Â» (ext_chart_at I x).symm (s âˆ© Â«expr â»Â¹' Â» f (ext_chart_at I' (f x)).source))\n          (ext_chart_at I x x) :=\n  by\n  rw [cont_mdiff_within_at_iff, and_congr_right_iff]\n  set e := ext_chart_at I x; set e' := ext_chart_at I' (f x)\n  refine' fun hc => cont_diff_within_at_congr_nhds _\n  rw [â† e.image_source_inter_eq', â† map_ext_chart_at_nhds_within_eq_image, â† map_ext_chart_at_nhds_within, inter_comm,\n    nhdsWithin_inter_of_mem]\n  exact hc (ext_chart_at_source_mem_nhds _ _)\n#align cont_mdiff_within_at_iff' cont_mdiff_within_at_iff'\n\n",
 "cont_mdiff_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.cont_mdiff_within_at_iff (hâ‚ : Â«expr =á¶ [ ] Â» fâ‚ (nhds_within s x) f) (hx : fâ‚ x = f x) :\n    cont_mdiff_within_at I I' n fâ‚ s x â†” cont_mdiff_within_at I I' n f s x :=\n  (cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_congr_iff_of_eventually_eq hâ‚ hx\n#align filter.eventually_eq.cont_mdiff_within_at_iff filter.eventually_eq.cont_mdiff_within_at_iff\n\n",
 "cont_mdiff_within_at_id":
 "theorem cont_mdiff_within_at_id : cont_mdiff_within_at I I n (id : M â†’ M) s x :=\n  cont_mdiff_at_id.cont_mdiff_within_at\n#align cont_mdiff_within_at_id cont_mdiff_within_at_id\n\n",
 "cont_mdiff_within_at_fst":
 "theorem cont_mdiff_within_at_fst {s : Set (M Ã— N)} {p : M Ã— N} : cont_mdiff_within_at (I.prod J) I n Prod.fst s p :=\n  by\n  rw [cont_mdiff_within_at_iff']\n  refine' âŸ¨continuousWithinAt_fst, _âŸ©\n  refine' cont_diff_within_at_fst.congr (fun y hy => _) _\n  Â· simp only [mfld_simps] at hy\n    simp only [hy, mfld_simps]\n  Â· simp only [mfld_simps]\n#align cont_mdiff_within_at_fst cont_mdiff_within_at_fst\n\n",
 "cont_mdiff_within_at_const":
 "theorem cont_mdiff_within_at_const : cont_mdiff_within_at I I' n (fun x : M => c) s x :=\n  cont_mdiff_at_const.cont_mdiff_within_at\n#align cont_mdiff_within_at_const cont_mdiff_within_at_const\n\n",
 "cont_mdiff_within_at_congr_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_mdiff_within_at_congr_nhds (hst : nhds_within s x = nhds_within t x) :\n    cont_mdiff_within_at I I' n f s x â†” cont_mdiff_within_at I I' n f t x :=\n  âŸ¨fun h => h.mono_of_mem <| hst â–¸ self_mem_nhdsWithin, fun h => h.mono_of_mem <| hst.symm â–¸ self_mem_nhdsWithinâŸ©\n#align cont_mdiff_within_at_congr_nhds cont_mdiff_within_at_congr_nhds\n\n",
 "cont_mdiff_within_at_congr":
 "theorem cont_mdiff_within_at_congr (hâ‚ : âˆ€ y âˆˆ s, fâ‚ y = f y) (hx : fâ‚ x = f x) :\n    cont_mdiff_within_at I I' n fâ‚ s x â†” cont_mdiff_within_at I I' n f s x :=\n  (cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_congr_iff hâ‚ hx\n#align cont_mdiff_within_at_congr cont_mdiff_within_at_congr\n\n",
 "cont_mdiff_within_at":
 "theorem cont_mdiff_at.cont_mdiff_within_at (hf : cont_mdiff_at I I' n f x) : cont_mdiff_within_at I I' n f s x :=\n  cont_mdiff_within_at.mono hf (subset_univ _)\n#align cont_mdiff_at.cont_mdiff_within_at cont_mdiff_at.cont_mdiff_within_at\n\n",
 "cont_mdiff_top":
 "theorem cont_mdiff_top : smooth I I' f â†” âˆ€ n : â„•, cont_mdiff I I' n f :=\n  âŸ¨fun h n => h.of_le le_top, fun h x => cont_mdiff_within_at_top.2 fun n => h n xâŸ©\n#align cont_mdiff_top cont_mdiff_top\n\n",
 "cont_mdiff_snd":
 "theorem cont_mdiff_snd : cont_mdiff (I.prod J) J n (@Prod.snd M N) := fun x => cont_mdiff_at_snd\n#align cont_mdiff_snd cont_mdiff_snd\n\n",
 "cont_mdiff_pi_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_pi_space :\n    cont_mdiff I (model_with_corners_self ğ•œ (âˆ€ i, Fi i)) n Ï† â†”\n      âˆ€ i, cont_mdiff I (model_with_corners_self ğ•œ (Fi i)) n fun x => Ï† x i :=\n  âŸ¨fun h i x => cont_mdiff_at_pi_space.1 (h x) i, fun h x => cont_mdiff_at_pi_space.2 fun i => h i xâŸ©\n#align cont_mdiff_pi_space cont_mdiff_pi_space\n\n",
 "cont_mdiff_one":
 "@[to_additive]\ntheorem cont_mdiff_one [One M'] : cont_mdiff I I' n (1 : M â†’ M') := by simp only [Pi.one_def, cont_mdiff_const]\n#align cont_mdiff_one cont_mdiff_one\n\n",
 "cont_mdiff_on_univ":
 "theorem cont_mdiff_on_univ : cont_mdiff_on I I' n f univ â†” cont_mdiff I I' n f := by\n  simp only [cont_mdiff_on, cont_mdiff, cont_mdiff_within_at_univ, forall_prop_of_true, mem_univ]\n#align cont_mdiff_on_univ cont_mdiff_on_univ\n\n",
 "cont_mdiff_on_top":
 "theorem cont_mdiff_on_top : smooth_on I I' f s â†” âˆ€ n : â„•, cont_mdiff_on I I' n f s :=\n  âŸ¨fun h n => h.of_le le_top, fun h x hx => cont_mdiff_within_at_top.2 fun n => h n x hxâŸ©\n#align cont_mdiff_on_top cont_mdiff_on_top\n\n",
 "cont_mdiff_on_symm_of_mem_maximal_atlas":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `with_top.nat.top -/\n/-- The inverse of an atlas member is `C^n` for any `n`. -/\ntheorem cont_mdiff_on_symm_of_mem_maximal_atlas (h : e âˆˆ maximal_atlas I M) : cont_mdiff_on I I n e.symm e.target :=\n  cont_mdiff_on.of_le\n    ((cont_diff_within_at_local_invariant_prop I I (with_top.nat.top)).lift_prop_on_symm_of_mem_maximal_atlas\n      (cont_diff_within_at_prop_id I) h)\n    le_top\n#align cont_mdiff_on_symm_of_mem_maximal_atlas cont_mdiff_on_symm_of_mem_maximal_atlas\n\n",
 "cont_mdiff_on_snd":
 "theorem cont_mdiff_on_snd {s : Set (M Ã— N)} : cont_mdiff_on (I.prod J) J n Prod.snd s := fun x hx =>\n  cont_mdiff_within_at_snd\n#align cont_mdiff_on_snd cont_mdiff_on_snd\n\n",
 "cont_mdiff_on_pi_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_on_pi_space :\n    cont_mdiff_on I (model_with_corners_self ğ•œ (âˆ€ i, Fi i)) n Ï† s â†”\n      âˆ€ i, cont_mdiff_on I (model_with_corners_self ğ•œ (Fi i)) n (fun x => Ï† x i) s :=\n  âŸ¨fun h i x hx => cont_mdiff_within_at_pi_space.1 (h x hx) i, fun h x hx =>\n    cont_mdiff_within_at_pi_space.2 fun i => h i x hxâŸ©\n#align cont_mdiff_on_pi_space cont_mdiff_on_pi_space\n\n",
 "cont_mdiff_on_one":
 "@[to_additive]\ntheorem cont_mdiff_on_one [One M'] : cont_mdiff_on I I' n (1 : M â†’ M') s :=\n  cont_mdiff_one.cont_mdiff_on\n#align cont_mdiff_on_one cont_mdiff_on_one\n\n",
 "cont_mdiff_on_of_mem_maximal_atlas":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `with_top.nat.top -/\n/-- An atlas member is `C^n` for any `n`. -/\ntheorem cont_mdiff_on_of_mem_maximal_atlas (h : e âˆˆ maximal_atlas I M) : cont_mdiff_on I I n e e.source :=\n  cont_mdiff_on.of_le\n    ((cont_diff_within_at_local_invariant_prop I I (with_top.nat.top)).lift_prop_on_of_mem_maximal_atlas\n      (cont_diff_within_at_prop_id I) h)\n    le_top\n#align cont_mdiff_on_of_mem_maximal_atlas cont_mdiff_on_of_mem_maximal_atlas\n\n",
 "cont_mdiff_on_of_mem_cont_diff_groupoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- An element of `cont_diff_groupoid âŠ¤ I` is `C^n` for any `n`. -/\ntheorem cont_mdiff_on_of_mem_cont_diff_groupoid {e' : LocalHomeomorph H H} (h : e' âˆˆ cont_diff_groupoid (Â«exprâŠ¤Â») I) :\n    cont_mdiff_on I I n e' e'.source :=\n  (cont_diff_within_at_local_invariant_prop I I n).lift_prop_on_of_mem_groupoid (cont_diff_within_at_prop_id I) h\n#align cont_mdiff_on_of_mem_cont_diff_groupoid cont_mdiff_on_of_mem_cont_diff_groupoid\n\n",
 "cont_mdiff_on_of_locally_cont_mdiff_on":
 "/-- Being `C^n` is a local property. -/\ntheorem cont_mdiff_on_of_locally_cont_mdiff_on (h : âˆ€ x âˆˆ s, âˆƒ u, IsOpen u âˆ§ x âˆˆ u âˆ§ cont_mdiff_on I I' n f (s âˆ© u)) :\n    cont_mdiff_on I I' n f s :=\n  (cont_diff_within_at_local_invariant_prop I I' n).lift_prop_on_of_locally_lift_prop_on h\n#align cont_mdiff_on_of_locally_cont_mdiff_on cont_mdiff_on_of_locally_cont_mdiff_on\n\n",
 "cont_mdiff_on_iff_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- One can reformulate smoothness on a set as continuity on this set, and smoothness in any\nextended chart in the target. -/\ntheorem cont_mdiff_on_iff_target :\n    cont_mdiff_on I I' n f s â†”\n      ContinuousOn f s âˆ§\n        âˆ€ y : M',\n          cont_mdiff_on I (model_with_corners_self ğ•œ E') n (ext_chart_at I' y âˆ˜ f)\n            (s âˆ© Â«expr â»Â¹' Â» f (ext_chart_at I' y).source) :=\n  by\n  inhabit E'\n  simp only [cont_mdiff_on_iff, model_with_corners.source_eq, chartAt_self_eq, LocalHomeomorph.refl_localEquiv,\n    LocalEquiv.refl_trans, ext_chart_at, local_homeomorph.extend, Set.preimage_univ, Set.inter_univ,\n    and_congr_right_iff]\n  intro h\n  constructor\n  Â· refine' fun h' y => âŸ¨_, fun x _ => h' x yâŸ©\n    have h'' : ContinuousOn _ univ := (model_with_corners.continuous I').continuous_on\n    convert(h''.comp' (chart_at H' y).continuous_to_fun).comp' h\n    simp\n  Â· exact fun h' x y => (h' y).2 x default\n#align cont_mdiff_on_iff_target cont_mdiff_on_iff_target\n\n",
 "cont_mdiff_on_iff_source_of_mem_maximal_atlas":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem cont_mdiff_on_iff_source_of_mem_maximal_atlas (he : e âˆˆ maximal_atlas I M) (hs : s âŠ† e.source) :\n    cont_mdiff_on I I' n f s â†”\n      cont_mdiff_on (model_with_corners_self ğ•œ E) I' n (f âˆ˜ (e.extend I).symm) (Â«expr '' Â» (e.extend I) s) :=\n  by\n  simp_rw [cont_mdiff_on, Set.ball_image_iff]\n  refine' forallâ‚‚_congr fun x hx => _\n  rw [cont_mdiff_within_at_iff_source_of_mem_maximal_atlas he (hs hx)]\n  apply cont_mdiff_within_at_congr_nhds\n  simp_rw [nhdsWithin_eq_iff_eventuallyEq, e.extend_symm_preimage_inter_range_eventually_eq I hs (hs hx)]\n#align cont_mdiff_on_iff_source_of_mem_maximal_atlas cont_mdiff_on_iff_source_of_mem_maximal_atlas\n\n",
 "cont_mdiff_on_iff_of_subset_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- If the set where you want `f` to be smooth lies entirely in a single chart, and `f` maps it\n  into a single chart, the smoothness of `f` on that set can be expressed by purely looking in\n  these charts.\n  Note: this lemma uses `ext_chart_at I x '' s` instead of `(ext_chart_at I x).symm â»Â¹' s` to ensure\n  that this set lies in `(ext_chart_at I x).target`. -/\ntheorem cont_mdiff_on_iff_of_subset_source {x : M} {y : M'} (hs : s âŠ† (chart_at H x).source)\n    (h2s : MapsTo f s (chart_at H' y).source) :\n    cont_mdiff_on I I' n f s â†”\n      ContinuousOn f s âˆ§\n        cont_diff_on ğ•œ n (ext_chart_at I' y âˆ˜ f âˆ˜ (ext_chart_at I x).symm) (Â«expr '' Â» (ext_chart_at I x) s) :=\n  cont_mdiff_on_iff_of_mem_maximal_atlas (chart_mem_maximal_atlas I x) (chart_mem_maximal_atlas I' y) hs h2s\n#align cont_mdiff_on_iff_of_subset_source cont_mdiff_on_iff_of_subset_source\n\n",
 "cont_mdiff_on_iff_of_mem_maximal_atlas":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem cont_mdiff_on_iff_of_mem_maximal_atlas (he : e âˆˆ maximal_atlas I M) (he' : e' âˆˆ maximal_atlas I' M')\n    (hs : s âŠ† e.source) (h2s : MapsTo f s e'.source) :\n    cont_mdiff_on I I' n f s â†”\n      ContinuousOn f s âˆ§ cont_diff_on ğ•œ n (e'.extend I' âˆ˜ f âˆ˜ (e.extend I).symm) (Â«expr '' Â» (e.extend I) s) :=\n  by\n  simp_rw [ContinuousOn, cont_diff_on, Set.ball_image_iff, â† forall_and, cont_mdiff_on]\n  exact forallâ‚‚_congr fun x hx => cont_mdiff_within_at_iff_image he he' hs (hs hx) (h2s hx)\n#align cont_mdiff_on_iff_of_mem_maximal_atlas cont_mdiff_on_iff_of_mem_maximal_atlas\n\n",
 "cont_mdiff_on_iff_cont_diff_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_on_iff_cont_diff_on {f : E â†’ E'} {s : Set E} :\n    cont_mdiff_on (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f s â†” cont_diff_on ğ•œ n f s :=\n  forall_congr' <| by simp [cont_mdiff_within_at_iff_cont_diff_within_at]\n#align cont_mdiff_on_iff_cont_diff_on cont_mdiff_on_iff_cont_diff_on\n\n",
 "cont_mdiff_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- One can reformulate smoothness on a set as continuity on this set, and smoothness in any\nextended chart. -/\ntheorem cont_mdiff_on_iff :\n    cont_mdiff_on I I' n f s â†”\n      ContinuousOn f s âˆ§\n        âˆ€ (x : M) (y : M'),\n          cont_diff_on ğ•œ n (ext_chart_at I' y âˆ˜ f âˆ˜ (ext_chart_at I x).symm)\n            ((ext_chart_at I x).target âˆ©\n              Â«expr â»Â¹' Â» (ext_chart_at I x).symm (s âˆ© Â«expr â»Â¹' Â» f (ext_chart_at I' y).source)) :=\n  by\n  constructor\n  Â· intro h\n    refine' âŸ¨fun x hx => (h x hx).1, fun x y z hz => _âŸ©\n    simp only [mfld_simps] at hz\n    let w := (ext_chart_at I x).symm z\n    have : w âˆˆ s := by simp only [w, hz, mfld_simps]\n    specialize h w this\n    have w1 : w âˆˆ (chart_at H x).source := by simp only [w, hz, mfld_simps]\n    have w2 : f w âˆˆ (chart_at H' y).source := by simp only [w, hz, mfld_simps]\n    convert((cont_mdiff_within_at_iff_of_mem_source w1 w2).mp h).2.mono _\n    Â· simp only [w, hz, mfld_simps]\n    Â· mfld_set_tac\n  Â· rintro âŸ¨hcont, hdiffâŸ© x hx\n    refine' (cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_iff.mpr _\n    refine' âŸ¨hcont x hx, _âŸ©\n    dsimp [cont_diff_within_at_prop]\n    convert hdiff x (f x) (ext_chart_at I x x) (by simp only [hx, mfld_simps]) using 1\n    mfld_set_tac\n#align cont_mdiff_on_iff cont_mdiff_on_iff\n\n",
 "cont_mdiff_on_id":
 "theorem cont_mdiff_on_id : cont_mdiff_on I I n (id : M â†’ M) s :=\n  cont_mdiff_id.cont_mdiff_on\n#align cont_mdiff_on_id cont_mdiff_on_id\n\n",
 "cont_mdiff_on_fst":
 "theorem cont_mdiff_on_fst {s : Set (M Ã— N)} : cont_mdiff_on (I.prod J) I n Prod.fst s := fun x hx =>\n  cont_mdiff_within_at_fst\n#align cont_mdiff_on_fst cont_mdiff_on_fst\n\n",
 "cont_mdiff_on_ext_chart_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_on_ext_chart_at :\n    cont_mdiff_on I (model_with_corners_self ğ•œ E) n (ext_chart_at I x) (chart_at H x).source := fun x' hx' =>\n  (cont_mdiff_at_ext_chart_at' hx').cont_mdiff_within_at\n#align cont_mdiff_on_ext_chart_at cont_mdiff_on_ext_chart_at\n\n",
 "cont_mdiff_on_const":
 "theorem cont_mdiff_on_const : cont_mdiff_on I I' n (fun x : M => c) s :=\n  cont_mdiff_const.cont_mdiff_on\n#align cont_mdiff_on_const cont_mdiff_on_const\n\n",
 "cont_mdiff_on_congr":
 "theorem cont_mdiff_on_congr (hâ‚ : âˆ€ y âˆˆ s, fâ‚ y = f y) : cont_mdiff_on I I' n fâ‚ s â†” cont_mdiff_on I I' n f s :=\n  (cont_diff_within_at_local_invariant_prop I I' n).lift_prop_on_congr_iff hâ‚\n#align cont_mdiff_on_congr cont_mdiff_on_congr\n\n",
 "cont_mdiff_on_chart_symm":
 "theorem cont_mdiff_on_chart_symm : cont_mdiff_on I I n (chart_at H x).symm (chart_at H x).target :=\n  cont_mdiff_on_symm_of_mem_maximal_atlas <| chart_mem_maximal_atlas I x\n#align cont_mdiff_on_chart_symm cont_mdiff_on_chart_symm\n\n",
 "cont_mdiff_on_chart":
 "theorem cont_mdiff_on_chart : cont_mdiff_on I I n (chart_at H x) (chart_at H x).source :=\n  cont_mdiff_on_of_mem_maximal_atlas <| chart_mem_maximal_atlas I x\n#align cont_mdiff_on_chart cont_mdiff_on_chart\n\n",
 "cont_mdiff_on":
 "theorem cont_mdiff.cont_mdiff_on (hf : cont_mdiff I I' n f) : cont_mdiff_on I I' n f s := fun x hx =>\n  (hf x).cont_mdiff_within_at\n#align cont_mdiff.cont_mdiff_on cont_mdiff.cont_mdiff_on\n\n",
 "cont_mdiff_of_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_of_support {f : M â†’ F} (hf : âˆ€ x âˆˆ tsupport f, cont_mdiff_at I (model_with_corners_self ğ•œ F) n f x) :\n    cont_mdiff I (model_with_corners_self ğ•œ F) n f := by\n  intro x\n  by_cases hx : x âˆˆ tsupport f\n  Â· exact hf x hx\n  Â· refine' cont_mdiff_at.congr_of_eventually_eq _ (eventuallyEq_zero_nhds.2 hx)\n    exact cont_mdiff_at_const\n#align cont_mdiff_of_support cont_mdiff_of_support\n\n",
 "cont_mdiff_of_locally_cont_mdiff_on":
 "theorem cont_mdiff_of_locally_cont_mdiff_on (h : âˆ€ x, âˆƒ u, IsOpen u âˆ§ x âˆˆ u âˆ§ cont_mdiff_on I I' n f u) :\n    cont_mdiff I I' n f :=\n  (cont_diff_within_at_local_invariant_prop I I' n).lift_prop_of_locally_lift_prop_on h\n#align cont_mdiff_of_locally_cont_mdiff_on cont_mdiff_of_locally_cont_mdiff_on\n\n",
 "cont_mdiff_model":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_model : cont_mdiff I (model_with_corners_self ğ•œ E) n I :=\n  by\n  intro x\n  refine' (cont_mdiff_at_iff _ _).mpr âŸ¨I.continuous_at, _âŸ©\n  simp only [mfld_simps]\n  refine' cont_diff_within_at_id.congr_of_eventually_eq _ _\n  Â· exact eventually_eq_of_mem self_mem_nhdsWithin fun xâ‚‚ => I.right_inv\n  simp_rw [Function.comp_apply, I.left_inv, id_def]\n#align cont_mdiff_model cont_mdiff_model\n\n",
 "cont_mdiff_iff_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- One can reformulate smoothness as continuity and smoothness in any extended chart in the\ntarget. -/\ntheorem cont_mdiff_iff_target :\n    cont_mdiff I I' n f â†”\n      Continuous f âˆ§\n        âˆ€ y : M',\n          cont_mdiff_on I (model_with_corners_self ğ•œ E') n (ext_chart_at I' y âˆ˜ f)\n            (Â«expr â»Â¹' Â» f (ext_chart_at I' y).source) :=\n  by\n  rw [â† cont_mdiff_on_univ, cont_mdiff_on_iff_target]\n  simp [continuous_iff_continuousOn_univ]\n#align cont_mdiff_iff_target cont_mdiff_iff_target\n\n",
 "cont_mdiff_iff_cont_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_iff_cont_diff {f : E â†’ E'} :\n    cont_mdiff (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f â†” cont_diff ğ•œ n f := by\n  rw [â† cont_diff_on_univ, â† cont_mdiff_on_univ, cont_mdiff_on_iff_cont_diff_on]\n#align cont_mdiff_iff_cont_diff cont_mdiff_iff_cont_diff\n\n",
 "cont_mdiff_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- One can reformulate smoothness as continuity and smoothness in any extended chart. -/\ntheorem cont_mdiff_iff :\n    cont_mdiff I I' n f â†”\n      Continuous f âˆ§\n        âˆ€ (x : M) (y : M'),\n          cont_diff_on ğ•œ n (ext_chart_at I' y âˆ˜ f âˆ˜ (ext_chart_at I x).symm)\n            ((ext_chart_at I x).target âˆ©\n              Â«expr â»Â¹' Â» (ext_chart_at I x).symm (Â«expr â»Â¹' Â» f (ext_chart_at I' y).source)) :=\n  by simp [â† cont_mdiff_on_univ, cont_mdiff_on_iff, continuous_iff_continuousOn_univ]\n#align cont_mdiff_iff cont_mdiff_iff\n\n",
 "cont_mdiff_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `with_top.nat.top -/\ntheorem cont_mdiff_id : cont_mdiff I I n (id : M â†’ M) :=\n  cont_mdiff.of_le\n    ((cont_diff_within_at_local_invariant_prop I I (with_top.nat.top)).lift_prop_id (cont_diff_within_at_prop_id I))\n    le_top\n#align cont_mdiff_id cont_mdiff_id\n\n",
 "cont_mdiff_fst":
 "theorem cont_mdiff_fst : cont_mdiff (I.prod J) I n (@Prod.fst M N) := fun x => cont_mdiff_at_fst\n#align cont_mdiff_fst cont_mdiff_fst\n\n",
 "cont_mdiff_const":
 "theorem cont_mdiff_const : cont_mdiff I I' n fun x : M => c :=\n  by\n  intro x\n  refine' âŸ¨continuousWithinAt_const, _âŸ©\n  simp only [cont_diff_within_at_prop, (Â· âˆ˜ Â·)]\n  exact cont_diff_within_at_const\n#align cont_mdiff_const cont_mdiff_const\n\n",
 "cont_mdiff_at_top":
 "theorem cont_mdiff_at_top : smooth_at I I' f x â†” âˆ€ n : â„•, cont_mdiff_at I I' n f x :=\n  cont_mdiff_within_at_top\n#align cont_mdiff_at_top cont_mdiff_at_top\n\n",
 "cont_mdiff_at_symm_of_mem_maximal_atlas":
 "theorem cont_mdiff_at_symm_of_mem_maximal_atlas {x : H} (h : e âˆˆ maximal_atlas I M) (hx : x âˆˆ e.target) :\n    cont_mdiff_at I I n e.symm x :=\n  (cont_mdiff_on_symm_of_mem_maximal_atlas h).cont_mdiff_at <| e.open_target.mem_nhds hx\n#align cont_mdiff_at_symm_of_mem_maximal_atlas cont_mdiff_at_symm_of_mem_maximal_atlas\n\n",
 "cont_mdiff_at_snd":
 "theorem cont_mdiff_at_snd {p : M Ã— N} : cont_mdiff_at (I.prod J) J n Prod.snd p :=\n  cont_mdiff_within_at_snd\n#align cont_mdiff_at_snd cont_mdiff_at_snd\n\n",
 "cont_mdiff_at_prod_iff":
 "theorem cont_mdiff_at_prod_iff (f : M â†’ M' Ã— N') {x : M} :\n    cont_mdiff_at I (I'.prod J') n f x â†”\n      cont_mdiff_at I I' n (Prod.fst âˆ˜ f) x âˆ§ cont_mdiff_at I J' n (Prod.snd âˆ˜ f) x :=\n  by\n  simp_rw [â† cont_mdiff_within_at_univ]\n  exact cont_mdiff_within_at_prod_iff f\n#align cont_mdiff_at_prod_iff cont_mdiff_at_prod_iff\n\n",
 "cont_mdiff_at_pi_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_at_pi_space :\n    cont_mdiff_at I (model_with_corners_self ğ•œ (âˆ€ i, Fi i)) n Ï† x â†”\n      âˆ€ i, cont_mdiff_at I (model_with_corners_self ğ•œ (Fi i)) n (fun x => Ï† x i) x :=\n  cont_mdiff_within_at_pi_space\n#align cont_mdiff_at_pi_space cont_mdiff_at_pi_space\n\n",
 "cont_mdiff_at_one":
 "@[to_additive]\ntheorem cont_mdiff_at_one [One M'] : cont_mdiff_at I I' n (1 : M â†’ M') x :=\n  cont_mdiff_one.cont_mdiff_at\n#align cont_mdiff_at_one cont_mdiff_at_one\n\n",
 "cont_mdiff_at_of_mem_maximal_atlas":
 "theorem cont_mdiff_at_of_mem_maximal_atlas (h : e âˆˆ maximal_atlas I M) (hx : x âˆˆ e.source) : cont_mdiff_at I I n e x :=\n  (cont_mdiff_on_of_mem_maximal_atlas h).cont_mdiff_at <| e.open_source.mem_nhds hx\n#align cont_mdiff_at_of_mem_maximal_atlas cont_mdiff_at_of_mem_maximal_atlas\n\n",
 "cont_mdiff_at_iff_target_of_mem_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_at_iff_target_of_mem_source {x : M} {y : M'} (hy : f x âˆˆ (chart_at H' y).source) :\n    cont_mdiff_at I I' n f x â†”\n      ContinuousAt f x âˆ§ cont_mdiff_at I (model_with_corners_self ğ•œ E') n (ext_chart_at I' y âˆ˜ f) x :=\n  by\n  rw [cont_mdiff_at, cont_mdiff_within_at_iff_target_of_mem_source hy, continuousWithinAt_univ, cont_mdiff_at]\n  infer_instance\n#align cont_mdiff_at_iff_target_of_mem_source cont_mdiff_at_iff_target_of_mem_source\n\n",
 "cont_mdiff_at_iff_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_at_iff_target {x : M} :\n    cont_mdiff_at I I' n f x â†”\n      ContinuousAt f x âˆ§ cont_mdiff_at I (model_with_corners_self ğ•œ E') n (ext_chart_at I' (f x) âˆ˜ f) x :=\n  by rw [cont_mdiff_at, cont_mdiff_at, cont_mdiff_within_at_iff_target, continuousWithinAt_univ]\n#align cont_mdiff_at_iff_target cont_mdiff_at_iff_target\n\n",
 "cont_mdiff_at_iff_source_of_mem_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_at_iff_source_of_mem_source {x' : M} (hx' : x' âˆˆ (chart_at H x).source) :\n    cont_mdiff_at I I' n f x' â†”\n      cont_mdiff_within_at (model_with_corners_self ğ•œ E) I' n (f âˆ˜ (ext_chart_at I x).symm) (range I)\n        (ext_chart_at I x x') :=\n  by simp_rw [cont_mdiff_at, cont_mdiff_within_at_iff_source_of_mem_source hx', preimage_univ, univ_inter]\n#align cont_mdiff_at_iff_source_of_mem_source cont_mdiff_at_iff_source_of_mem_source\n\n",
 "cont_mdiff_at_iff_of_mem_source":
 "theorem cont_mdiff_at_iff_of_mem_source {x' : M} {y : M'} (hx : x' âˆˆ (chart_at H x).source)\n    (hy : f x' âˆˆ (chart_at H' y).source) :\n    cont_mdiff_at I I' n f x' â†”\n      ContinuousAt f x' âˆ§\n        cont_diff_within_at ğ•œ n (ext_chart_at I' y âˆ˜ f âˆ˜ (ext_chart_at I x).symm) (range I) (ext_chart_at I x x') :=\n  (cont_mdiff_within_at_iff_of_mem_source hx hy).trans <| by rw [continuousWithinAt_univ, preimage_univ, univ_inter]\n#align cont_mdiff_at_iff_of_mem_source cont_mdiff_at_iff_of_mem_source\n\n",
 "cont_mdiff_at_iff_cont_mdiff_on_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A function is `C^n` at a point, for `n : â„•`, if and only if it is `C^n` on\na neighborhood of this point. -/\ntheorem cont_mdiff_at_iff_cont_mdiff_on_nhds {n : â„•} :\n    cont_mdiff_at I I' n f x â†” âˆƒ u âˆˆ (nhds) x, cont_mdiff_on I I' n f u := by\n  simp [â† cont_mdiff_within_at_univ, cont_mdiff_within_at_iff_cont_mdiff_on_nhds, nhdsWithin_univ]\n#align cont_mdiff_at_iff_cont_mdiff_on_nhds cont_mdiff_at_iff_cont_mdiff_on_nhds\n\n",
 "cont_mdiff_at_iff_cont_mdiff_at_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Note: This does not hold for `n = âˆ`. `f` being `C^âˆ` at `x` means that for every `n`, `f` is\n`C^n` on some neighborhood of `x`, but this neighborhood can depend on `n`. -/\ntheorem cont_mdiff_at_iff_cont_mdiff_at_nhds {n : â„•} :\n    cont_mdiff_at I I' n f x â†”\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) x)\n        (cont_mdiff_at I I' n f x') :=\n  by\n  refine' âŸ¨_, fun h => h.self_of_nhdsâŸ©\n  rw [cont_mdiff_at_iff_cont_mdiff_on_nhds]\n  rintro âŸ¨u, hu, hâŸ©\n  refine' (eventually_mem_nhds.mpr hu).mono fun x' hx' => _\n  exact (h x' <| mem_of_mem_nhds hx').cont_mdiff_at hx'\n#align cont_mdiff_at_iff_cont_mdiff_at_nhds cont_mdiff_at_iff_cont_mdiff_at_nhds\n\n",
 "cont_mdiff_at_iff_cont_diff_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_at_iff_cont_diff_at {f : E â†’ E'} {x : E} :\n    cont_mdiff_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f x â†” cont_diff_at ğ•œ n f x := by\n  rw [â† cont_mdiff_within_at_univ, cont_mdiff_within_at_iff_cont_diff_within_at, cont_diff_within_at_univ]\n#align cont_mdiff_at_iff_cont_diff_at cont_mdiff_at_iff_cont_diff_at\n\n",
 "cont_mdiff_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.cont_mdiff_at_iff (hâ‚ : Â«expr =á¶ [ ] Â» fâ‚ ((nhds) x) f) :\n    cont_mdiff_at I I' n fâ‚ x â†” cont_mdiff_at I I' n f x :=\n  (cont_diff_within_at_local_invariant_prop I I' n).lift_prop_at_congr_iff_of_eventually_eq hâ‚\n#align filter.eventually_eq.cont_mdiff_at_iff filter.eventually_eq.cont_mdiff_at_iff\n\n",
 "cont_mdiff_at_id":
 "theorem cont_mdiff_at_id : cont_mdiff_at I I n (id : M â†’ M) x :=\n  cont_mdiff_id.cont_mdiff_at\n#align cont_mdiff_at_id cont_mdiff_at_id\n\n",
 "cont_mdiff_at_fst":
 "theorem cont_mdiff_at_fst {p : M Ã— N} : cont_mdiff_at (I.prod J) I n Prod.fst p :=\n  cont_mdiff_within_at_fst\n#align cont_mdiff_at_fst cont_mdiff_at_fst\n\n",
 "cont_mdiff_at_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_at_extend {x : M} (he : e âˆˆ maximal_atlas I M) (hx : x âˆˆ e.source) :\n    cont_mdiff_at I (model_with_corners_self ğ•œ E) n (e.extend I) x :=\n  (cont_mdiff_model _).comp x <| cont_mdiff_at_of_mem_maximal_atlas he hx\n#align cont_mdiff_at_extend cont_mdiff_at_extend\n\n",
 "cont_mdiff_at_ext_chart_at'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_at_ext_chart_at' {x' : M} (h : x' âˆˆ (chart_at H x).source) :\n    cont_mdiff_at I (model_with_corners_self ğ•œ E) n (ext_chart_at I x) x' :=\n  cont_mdiff_at_extend (chart_mem_maximal_atlas I x) h\n#align cont_mdiff_at_ext_chart_at' cont_mdiff_at_ext_chart_at'\n\n",
 "cont_mdiff_at_ext_chart_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff_at_ext_chart_at : cont_mdiff_at I (model_with_corners_self ğ•œ E) n (ext_chart_at I x) x :=\n  cont_mdiff_at_ext_chart_at' <| mem_chart_source H x\n#align cont_mdiff_at_ext_chart_at cont_mdiff_at_ext_chart_at\n\n",
 "cont_mdiff_at_const":
 "theorem cont_mdiff_at_const : cont_mdiff_at I I' n (fun x : M => c) x :=\n  cont_mdiff_const.cont_mdiff_at\n#align cont_mdiff_at_const cont_mdiff_at_const\n\n",
 "cont_mdiff_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_mdiff_on.cont_mdiff_at (h : cont_mdiff_on I I' n f s) (hx : s âˆˆ (nhds) x) : cont_mdiff_at I I' n f x :=\n  (h x (mem_of_mem_nhds hx)).cont_mdiff_at hx\n#align cont_mdiff_on.cont_mdiff_at cont_mdiff_on.cont_mdiff_at\n\n",
 "cont_mdiff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem continuous_linear_map.cont_mdiff (L : Â«expr â†’L[ ] Â» E ğ•œ F) :\n    cont_mdiff (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ F) n L :=\n  L.cont_diff.cont_mdiff\n#align continuous_linear_map.cont_mdiff continuous_linear_map.cont_mdiff\n\n",
 "cont_diff_within_at_prop_self_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem cont_diff_within_at_prop_self_target {f : H â†’ E'} {s : Set H} {x : H} :\n    cont_diff_within_at_prop I (model_with_corners_self ğ•œ E') n f s x â†”\n      cont_diff_within_at ğ•œ n (f âˆ˜ I.symm) (Â«expr â»Â¹' Â» I.symm s âˆ© range I) (I x) :=\n  iff.rfl\n#align cont_diff_within_at_prop_self_target cont_diff_within_at_prop_self_target\n\n",
 "cont_diff_within_at_prop_self_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/-\nCopyright (c) 2020 SÃ©bastien GouÃ«zel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: SÃ©bastien GouÃ«zel, Floris van Doorn\n-/\n-- declare a smooth manifold `M` over the pair `(E, H)`.\n-- declare a smooth manifold `M'` over the pair `(E', H')`.\n-- declare a manifold `M''` over the pair `(E'', H'')`.\n-- declare a smooth manifold `N` over the pair `(F, G)`.\n-- declare a smooth manifold `N'` over the pair `(F', G')`.\n-- Fâ‚, Fâ‚‚, Fâ‚ƒ, Fâ‚„ are normed spaces\n-- declare functions, sets, points and smoothness indices\ntheorem cont_diff_within_at_prop_self_source {f : E â†’ H'} {s : Set E} {x : E} :\n    cont_diff_within_at_prop (model_with_corners_self ğ•œ E) I' n f s x â†” cont_diff_within_at ğ•œ n (I' âˆ˜ f) s x :=\n  by\n  simp_rw [cont_diff_within_at_prop, model_with_corners_self_coe, range_id, inter_univ]\n  rfl\n#align cont_diff_within_at_prop_self_source cont_diff_within_at_prop_self_source\n\n",
 "cont_diff_within_at_prop_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_diff_within_at_prop_self {f : E â†’ E'} {s : Set E} {x : E} :\n    cont_diff_within_at_prop (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f s x â†”\n      cont_diff_within_at ğ•œ n f s x :=\n  cont_diff_within_at_prop_self_source (model_with_corners_self ğ•œ E')\n#align cont_diff_within_at_prop_self cont_diff_within_at_prop_self\n\n",
 "cont_diff_within_at_prop_mono_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem cont_diff_within_at_prop_mono_of_mem (n : Â«exprâ„•âˆÂ») â¦ƒs x tâ¦„ â¦ƒf : H â†’ H'â¦„ (hts : s âˆˆ nhds_within t x)\n    (h : cont_diff_within_at_prop I I' n f s x) : cont_diff_within_at_prop I I' n f t x :=\n  by\n  refine' h.mono_of_mem _\n  refine' inter_mem _ (mem_of_superset self_mem_nhdsWithin <| inter_subset_right _ _)\n  rwa [â† Filter.mem_map, â† I.image_eq, I.symm_map_nhds_within_image]\n#align cont_diff_within_at_prop_mono_of_mem cont_diff_within_at_prop_mono_of_mem\n\n",
 "cont_diff_within_at_prop_id":
 "theorem cont_diff_within_at_prop_id (x : H) : cont_diff_within_at_prop I I n id univ x :=\n  by\n  simp [cont_diff_within_at_prop]\n  have : cont_diff_within_at ğ•œ n id (range I) (I x) := cont_diff_id.cont_diff_at.cont_diff_within_at\n  apply this.congr fun y hy => _\n  Â· simp only [mfld_simps]\n  Â· simp only [model_with_corners.right_inv I hy, mfld_simps]\n#align cont_diff_within_at_prop_id cont_diff_within_at_prop_id\n\n",
 "cont_diff_within_at_local_invariant_prop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `with_top.nat.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `with_top.nat.top -/\n/-- Being `Câ¿` in the model space is a local property, invariant under smooth maps. Therefore,\nit will lift nicely to manifolds. -/\ntheorem cont_diff_within_at_local_invariant_prop (n : Â«exprâ„•âˆÂ») :\n    (cont_diff_groupoid (with_top.nat.top) I).local_invariant_prop (cont_diff_groupoid (with_top.nat.top) I')\n      (cont_diff_within_at_prop I I' n) :=\n  { is_local := by\n      intro s x u f u_open xu\n      have : Â«expr â»Â¹' Â» I.symm (s âˆ© u) âˆ© range I = Â«expr â»Â¹' Â» I.symm s âˆ© range I âˆ© Â«expr â»Â¹' Â» I.symm u := by\n        simp only [inter_right_comm, preimage_inter]\n      rw [cont_diff_within_at_prop, cont_diff_within_at_prop, this]\n      symm\n      apply cont_diff_within_at_inter\n      have : u âˆˆ (nhds) (I.symm (I x)) := by\n        rw [model_with_corners.left_inv]\n        exact IsOpen.mem_nhds u_open xu\n      apply ContinuousAt.preimage_mem_nhds I.continuous_symm.continuous_at this\n    right_invariance' := by\n      intro s x f e he hx h\n      rw [cont_diff_within_at_prop] at hâŠ¢\n      have : I x = (I âˆ˜ e.symm âˆ˜ I.symm) (I (e x)) := by simp only [hx, mfld_simps]\n      rw [this] at h\n      have : I (e x) âˆˆ Â«expr â»Â¹' Â» I.symm e.target âˆ© range I := by simp only [hx, mfld_simps]\n      have := ((mem_groupoid_of_pregroupoid.2 he).2.cont_diff_within_at this).of_le le_top\n      convert(h.comp' _ this).mono_of_mem _ using 1\n      Â· ext y\n        simp only [mfld_simps]\n      refine'\n        mem_nhds_within.mpr\n          âŸ¨Â«expr â»Â¹' Â» I.symm e.target, e.open_target.preimage I.continuous_symm, by\n            simp_rw [mem_preimage, I.left_inv, e.maps_to hx], _âŸ©\n      mfld_set_tac\n    congr_of_forall := by\n      intro s x f g h hx hf\n      apply hf.congr\n      Â· intro y hy\n        simp only [mfld_simps] at hy\n        simp only [h, hy, mfld_simps]\n      Â· simp only [hx, mfld_simps]\n    left_invariance' := by\n      intro s x f e' he' hs hx h\n      rw [cont_diff_within_at_prop] at hâŠ¢\n      have A : (I' âˆ˜ f âˆ˜ I.symm) (I x) âˆˆ Â«expr â»Â¹' Â» I'.symm e'.source âˆ© range I' := by simp only [hx, mfld_simps]\n      have := ((mem_groupoid_of_pregroupoid.2 he').1.cont_diff_within_at A).of_le le_top\n      convert this.comp _ h _\n      Â· ext y\n        simp only [mfld_simps]\n      Â· intro y hy\n        simp only [mfld_simps] at hy\n        simpa only [hy, mfld_simps] using hs hy.1 }\n#align cont_diff_within_at_local_invariant_prop cont_diff_within_at_local_invariant_prop\n\n",
 "congr_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cont_mdiff_at.congr_of_eventually_eq (h : cont_mdiff_at I I' n f x) (hâ‚ : Â«expr =á¶ [ ] Â» fâ‚ ((nhds) x) f) :\n    cont_mdiff_at I I' n fâ‚ x :=\n  (cont_diff_within_at_local_invariant_prop I I' n).lift_prop_at_congr_of_eventually_eq h hâ‚\n#align cont_mdiff_at.congr_of_eventually_eq cont_mdiff_at.congr_of_eventually_eq\n\n",
 "congr":
 "theorem cont_mdiff_on.congr (h : cont_mdiff_on I I' n f s) (hâ‚ : âˆ€ y âˆˆ s, fâ‚ y = f y) : cont_mdiff_on I I' n fâ‚ s :=\n  (cont_diff_within_at_local_invariant_prop I I' n).lift_prop_on_congr h hâ‚\n#align cont_mdiff_on.congr cont_mdiff_on.congr\n\n",
 "comp_smooth_within_at":
 "/-- `g âˆ˜ f` is `C^âˆ` within `s` at `x` if `g` is `C^âˆ` at `f x` and\n`f` is `C^âˆ` within `s` at `x`. -/\ntheorem smooth_at.comp_smooth_within_at {g : M' â†’ M''} (x : M) (hg : smooth_at I' I'' g (f x))\n    (hf : smooth_within_at I I' f s x) : smooth_within_at I I'' (g âˆ˜ f) s x :=\n  hg.comp_cont_mdiff_within_at x hf\n#align smooth_at.comp_smooth_within_at smooth_at.comp_smooth_within_at\n\n",
 "comp_smooth_on":
 "theorem smooth.comp_smooth_on {f : M â†’ M'} {g : M' â†’ M''} {s : Set M} (hg : smooth I' I'' g) (hf : smooth_on I I' f s) :\n    smooth_on I I'' (g âˆ˜ f) s :=\n  hg.smooth_on.comp hf Set.subset_preimage_univ\n#align smooth.comp_smooth_on smooth.comp_smooth_on\n\n",
 "comp_smooth":
 "theorem smooth_on.comp_smooth {t : Set M'} {g : M' â†’ M''} (hg : smooth_on I' I'' g t) (hf : smooth I I' f)\n    (ht : âˆ€ x, f x âˆˆ t) : smooth I I'' (g âˆ˜ f) :=\n  hg.comp_cont_mdiff hf ht\n#align smooth_on.comp_smooth smooth_on.comp_smooth\n\n",
 "comp_cont_mdiff_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_diff_within_at.comp_cont_mdiff_within_at {g : F â†’ F'} {f : M â†’ F} {s : Set M} {t : Set F} {x : M}\n    (hg : cont_diff_within_at ğ•œ n g t (f x)) (hf : cont_mdiff_within_at I (model_with_corners_self ğ•œ F) n f s x)\n    (h : s âŠ† Â«expr â»Â¹' Â» f t) : cont_mdiff_within_at I (model_with_corners_self ğ•œ F') n (g âˆ˜ f) s x :=\n  by\n  rw [cont_mdiff_within_at_iff] at *\n  refine' âŸ¨hg.continuous_within_at.comp hf.1 h, _âŸ©\n  rw [â† (ext_chart_at I x).left_inv (mem_ext_chart_source I x)] at hg\n  apply cont_diff_within_at.comp _ hg hf.2 _\n  exact (inter_subset_left _ _).trans (preimage_mono h)\n#align cont_diff_within_at.comp_cont_mdiff_within_at cont_diff_within_at.comp_cont_mdiff_within_at\n\n",
 "comp_cont_mdiff_on":
 "theorem cont_mdiff.comp_cont_mdiff_on {f : M â†’ M'} {g : M' â†’ M''} {s : Set M} (hg : cont_mdiff I' I'' n g)\n    (hf : cont_mdiff_on I I' n f s) : cont_mdiff_on I I'' n (g âˆ˜ f) s :=\n  hg.cont_mdiff_on.comp hf Set.subset_preimage_univ\n#align cont_mdiff.comp_cont_mdiff_on cont_mdiff.comp_cont_mdiff_on\n\n",
 "comp_cont_mdiff_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_diff_at.comp_cont_mdiff_at {g : F â†’ F'} {f : M â†’ F} {x : M} (hg : cont_diff_at ğ•œ n g (f x))\n    (hf : cont_mdiff_at I (model_with_corners_self ğ•œ F) n f x) :\n    cont_mdiff_at I (model_with_corners_self ğ•œ F') n (g âˆ˜ f) x :=\n  hg.comp_cont_mdiff_within_at hf Subset.rfl\n#align cont_diff_at.comp_cont_mdiff_at cont_diff_at.comp_cont_mdiff_at\n\n",
 "comp_cont_mdiff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_diff.comp_cont_mdiff {g : F â†’ F'} {f : M â†’ F} (hg : cont_diff ğ•œ n g)\n    (hf : cont_mdiff I (model_with_corners_self ğ•œ F) n f) : cont_mdiff I (model_with_corners_self ğ•œ F') n (g âˆ˜ f) :=\n  fun x => hg.cont_diff_at.comp_cont_mdiff_at (hf x)\n#align cont_diff.comp_cont_mdiff cont_diff.comp_cont_mdiff\n\n",
 "comp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- The composition of `C^âˆ` functions within domains at points is `C^âˆ`. -/\ntheorem smooth_within_at.comp' {t : Set M'} {g : M' â†’ M''} (x : M) (hg : smooth_within_at I' I'' g t (f x))\n    (hf : smooth_within_at I I' f s x) : smooth_within_at I I'' (g âˆ˜ f) (s âˆ© Â«expr â»Â¹' Â» f t) x :=\n  hg.comp' x hf\n#align smooth_within_at.comp' smooth_within_at.comp'\n\n",
 "comp":
 "/-- The composition of `C^âˆ` functions at points is `C^âˆ`. -/\ntheorem smooth_at.comp {g : M' â†’ M''} (x : M) (hg : smooth_at I' I'' g (f x)) (hf : smooth_at I I' f x) :\n    smooth_at I I'' (g âˆ˜ f) x :=\n  hg.comp x hf\n#align smooth_at.comp smooth_at.comp\n\n",
 "clm_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem cont_mdiff.clm_prod_map {g : M â†’ Â«expr â†’L[ ] Â» Fâ‚ ğ•œ Fâ‚ƒ} {f : M â†’ Â«expr â†’L[ ] Â» Fâ‚‚ ğ•œ Fâ‚„}\n    (hg : cont_mdiff I (model_with_corners_self ğ•œ (Â«expr â†’L[ ] Â» Fâ‚ ğ•œ Fâ‚ƒ)) n g)\n    (hf : cont_mdiff I (model_with_corners_self ğ•œ (Â«expr â†’L[ ] Â» Fâ‚‚ ğ•œ Fâ‚„)) n f) :\n    cont_mdiff I (model_with_corners_self ğ•œ (Â«expr â†’L[ ] Â» (Fâ‚ Ã— Fâ‚‚) ğ•œ (Fâ‚ƒ Ã— Fâ‚„))) n fun x => (g x).prod_map (f x) :=\n  fun x => (hg x).clm_prod_map (hf x)\n#align cont_mdiff.clm_prod_map cont_mdiff.clm_prod_map\n\n",
 "clm_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem cont_mdiff.clm_comp {g : M â†’ Â«expr â†’L[ ] Â» Fâ‚ ğ•œ Fâ‚ƒ} {f : M â†’ Â«expr â†’L[ ] Â» Fâ‚‚ ğ•œ Fâ‚}\n    (hg : cont_mdiff I (model_with_corners_self ğ•œ (Â«expr â†’L[ ] Â» Fâ‚ ğ•œ Fâ‚ƒ)) n g)\n    (hf : cont_mdiff I (model_with_corners_self ğ•œ (Â«expr â†’L[ ] Â» Fâ‚‚ ğ•œ Fâ‚)) n f) :\n    cont_mdiff I (model_with_corners_self ğ•œ (Â«expr â†’L[ ] Â» Fâ‚‚ ğ•œ Fâ‚ƒ)) n fun x => (g x).comp (f x) := fun x =>\n  (hg x).clm_comp (hf x)\n#align cont_mdiff.clm_comp cont_mdiff.clm_comp\n\n",
 "clm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem cont_mdiff.clm_apply {g : M â†’ Â«expr â†’L[ ] Â» Fâ‚ ğ•œ Fâ‚‚} {f : M â†’ Fâ‚}\n    (hg : cont_mdiff I (model_with_corners_self ğ•œ (Â«expr â†’L[ ] Â» Fâ‚ ğ•œ Fâ‚‚)) n g)\n    (hf : cont_mdiff I (model_with_corners_self ğ•œ Fâ‚) n f) :\n    cont_mdiff I (model_with_corners_self ğ•œ Fâ‚‚) n fun x => g x (f x) := fun x => (hg x).clm_apply (hf x)\n#align cont_mdiff.clm_apply cont_mdiff.clm_apply\n\n"}