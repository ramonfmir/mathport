{"tangent_map_tangent_bundle_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/-- The derivative of the zero section of the tangent bundle maps `⟨x, v⟩` to `⟨⟨x, 0⟩, ⟨v, 0⟩⟩`.\n\nNote that, as currently framed, this is a statement in coordinates, thus reliant on the choice\nof the coordinate system we use on the tangent bundle.\n\nHowever, the result itself is coordinate-dependent only to the extent that the coordinates\ndetermine a splitting of the tangent bundle.  Moreover, there is a canonical splitting at each\npoint of the zero section (since there is a canonical horizontal space there, the tangent space\nto the zero section, in addition to the canonical vertical space which is the kernel of the\nderivative of the projection), and this canonical splitting is also the one that comes from the\ncoordinates on the tangent bundle in our definitions. So this statement is not as crazy as it\nmay seem.\n\nTODO define splittings of vector bundles; state this result invariantly. -/\ntheorem tangent_map_tangent_bundle_pure (p : tangent_bundle I M) :\n    tangent_map I I.tangent (zero_section (tangent_space I)) p = ⟨⟨p.proj, 0⟩, ⟨p.2, 0⟩⟩ :=\n  by\n  rcases p with ⟨x, v⟩\n  have N : «expr ⁻¹' » I.symm (chart_at H x).target ∈ (nhds) (I ((chart_at H x) x)) :=\n    by\n    apply IsOpen.mem_nhds\n    apply (local_homeomorph.open_target _).preimage I.continuous_inv_fun\n    simp only [mfld_simps]\n  have A : mdifferentiable_at I I.tangent (fun x => @total_space_mk M (tangent_space I) x 0) x :=\n    haveI : smooth I (I.prod (model_with_corners_self 𝕜 E)) (zero_section (tangent_space I : M → Type _)) :=\n      bundle.smooth_zero_section 𝕜 (tangent_space I : M → Type _)\n    this.mdifferentiable_at\n  have B : fderiv_within 𝕜 (fun x' : E => (x', (0 : E))) (Set.range («expr⇑ » I)) (I ((chart_at H x) x)) v = (v, 0) :=\n    by\n    rw [fderiv_within_eq_fderiv, differentiable_at.fderiv_prod]\n    · simp\n    · exact differentiable_at_id'\n    · exact differentiable_at_const _\n    · exact model_with_corners.unique_diff_at_image I\n    · exact differentiable_at_id'.prod (differentiable_at_const _)\n  simp only [bundle.zero_section, tangent_map, mfderiv, total_space.proj_mk, A, if_pos, chart_at,\n    fiber_bundle.charted_space_chart_at, tangent_bundle.trivialization_at_apply, tangent_bundle_core, Function.comp,\n    ContinuousLinearMap.map_zero, mfld_simps]\n  rw [← fderiv_within_inter N (I.unique_diff (I ((chart_at H x) x)) (Set.mem_range_self _))] at B\n  rw [← fderiv_within_inter N (I.unique_diff (I ((chart_at H x) x)) (Set.mem_range_self _)), ← B]\n  congr 2\n  apply fderiv_within_congr _ fun y hy => _\n  · simp only [Prod.mk.inj_iff, mfld_simps]\n  · apply unique_diff_within_at.inter (I.unique_diff _ _) N\n    simp only [mfld_simps]\n  · simp only [mfld_simps] at hy\n    simp only [hy, Prod.mk.inj_iff, mfld_simps]\n#align tangent_map_tangent_bundle_pure tangent_map_tangent_bundle_pure\n\n",
 "mdifferentiable_within_at":
 "theorem smooth.mdifferentiable_within_at (hf : smooth I I' f) : mdifferentiable_within_at I I' f s x :=\n  hf.mdifferentiable_at.mdifferentiable_within_at\n#align smooth.mdifferentiable_within_at smooth.mdifferentiable_within_at\n\n",
 "mdifferentiable_on":
 "theorem smooth_on.mdifferentiable_on (hf : smooth_on I I' f s) : mdifferentiable_on I I' f s :=\n  hf.mdifferentiable_on le_top\n#align smooth_on.mdifferentiable_on smooth_on.mdifferentiable_on\n\n",
 "mdifferentiable_at":
 "theorem smooth.mdifferentiable_at (hf : smooth I I' f) : mdifferentiable_at I I' f x :=\n  hf.mdifferentiable x\n#align smooth.mdifferentiable_at smooth.mdifferentiable_at\n\n",
 "mdifferentiable":
 "theorem smooth.mdifferentiable (hf : smooth I I' f) : mdifferentiable I I' f :=\n  cont_mdiff.mdifferentiable hf le_top\n#align smooth.mdifferentiable smooth.mdifferentiable\n\n",
 "continuous_tangent_map":
 "/-- If a function is `C^n`, with `1 ≤ n`, then its bundled derivative is continuous. -/\ntheorem cont_mdiff.continuous_tangent_map (hf : cont_mdiff I I' n f) (hmn : 1 ≤ n) : Continuous (tangent_map I I' f) :=\n  by\n  rw [← cont_mdiff_on_univ] at hf\n  rw [continuous_iff_continuousOn_univ]\n  convert hf.continuous_on_tangent_map_within hmn unique_mdiff_on_univ\n  rw [tangent_map_within_univ]\n#align cont_mdiff.continuous_tangent_map cont_mdiff.continuous_tangent_map\n\n",
 "continuous_on_tangent_map_within_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/-- If a function is `C^n` with `1 ≤ n` on a domain with unique derivatives, then its bundled\nderivative is continuous. In this auxiliary lemma, we prove this fact when the source and target\nspace are model spaces in models with corners. The general fact is proved in\n`cont_mdiff_on.continuous_on_tangent_map_within`-/\ntheorem cont_mdiff_on.continuous_on_tangent_map_within_aux {f : H → H'} {s : Set H} (hf : cont_mdiff_on I I' n f s)\n    (hn : 1 ≤ n) (hs : unique_mdiff_on I s) :\n    ContinuousOn (tangent_map_within I I' f s) («expr ⁻¹' » ((exprπ) (tangent_space I)) s) :=\n  by\n  suffices h :\n    ContinuousOn\n      (fun p : H × E =>\n        (f p.fst,\n          (fderiv_within 𝕜 (written_in_ext_chart_at I I' p.fst f) («expr ⁻¹' » I.symm s ∩ range I)\n                ((ext_chart_at I p.fst) p.fst) :\n              «expr →L[ ] » E 𝕜 E')\n            p.snd))\n      («expr ⁻¹' » Prod.fst s)\n  · have A := (tangent_bundle_model_space_homeomorph H I).continuous\n    rw [continuous_iff_continuousOn_univ] at A\n    have B := ((tangent_bundle_model_space_homeomorph H' I').symm.continuous.comp_continuous_on h).comp' A\n    have :\n      univ ∩ «expr ⁻¹' » («expr⇑ » (tangent_bundle_model_space_homeomorph H I)) («expr ⁻¹' » Prod.fst s) =\n        «expr ⁻¹' » ((exprπ) (tangent_space I)) s :=\n      by\n      ext ⟨x, v⟩\n      simp only [mfld_simps]\n    rw [this] at B\n    apply B.congr\n    rintro ⟨x, v⟩ hx\n    dsimp [tangent_map_within]\n    ext\n    · rfl\n    simp only [mfld_simps]\n    apply congr_fun\n    apply congr_arg\n    rw [mdifferentiable_within_at.mfderiv_within (hf.mdifferentiable_on hn x hx)]\n    rfl\n  suffices h :\n    ContinuousOn\n      (fun p : H × E =>\n        (fderiv_within 𝕜 (I' ∘ f ∘ I.symm) («expr ⁻¹' » I.symm s ∩ range I) (I p.fst) : «expr →L[ ] » E 𝕜 E') p.snd)\n      («expr ⁻¹' » Prod.fst s)\n  · dsimp [written_in_ext_chart_at, ext_chart_at]\n    apply ContinuousOn.prod (ContinuousOn.comp hf.continuous_on continuous_fst.continuous_on (subset.refl _))\n    apply h.congr\n    intro p hp\n    rfl\n  suffices h : ContinuousOn (fderiv_within 𝕜 (I' ∘ f ∘ I.symm) («expr ⁻¹' » I.symm s ∩ range I)) («expr '' » I s)\n  · have C := ContinuousOn.comp h I.continuous_to_fun.continuous_on (subset.refl _)\n    have A : Continuous fun q : «expr →L[ ] » E 𝕜 E' × E => q.1 q.2 := is_bounded_bilinear_map_apply.continuous\n    have B :\n      ContinuousOn (fun p : H × E => (fderiv_within 𝕜 (I' ∘ f ∘ I.symm) («expr ⁻¹' » I.symm s ∩ range I) (I p.1), p.2))\n        («expr ⁻¹' » Prod.fst s) :=\n      by\n      apply ContinuousOn.prod _ continuous_snd.continuous_on\n      refine' (ContinuousOn.comp C continuous_fst.continuous_on _ : _)\n      exact preimage_mono (subset_preimage_image _ _)\n    exact A.comp_continuous_on B\n  rw [cont_mdiff_on_iff] at hf\n  let x : H := I.symm (0 : E)\n  let y : H' := I'.symm (0 : E')\n  have A := hf.2 x y\n  simp only [I.image_eq, inter_comm, mfld_simps] at A⊢\n  apply A.continuous_on_fderiv_within _ hn\n  convert hs.unique_diff_on_target_inter x using 1\n  simp only [inter_comm, mfld_simps]\n#align cont_mdiff_on.continuous_on_tangent_map_within_aux cont_mdiff_on.continuous_on_tangent_map_within_aux\n\n",
 "continuous_on_tangent_map_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/-- If a function is `C^n` on a domain with unique derivatives, with `1 ≤ n`, then its bundled\nderivative is continuous there. -/\ntheorem cont_mdiff_on.continuous_on_tangent_map_within (hf : cont_mdiff_on I I' n f s) (hmn : 1 ≤ n)\n    (hs : unique_mdiff_on I s) :\n    ContinuousOn (tangent_map_within I I' f s) («expr ⁻¹' » ((exprπ) (tangent_space I)) s) :=\n  haveI :\n    cont_mdiff_on I.tangent I'.tangent 0 (tangent_map_within I I' f s) («expr ⁻¹' » ((exprπ) (tangent_space I)) s) :=\n    hf.cont_mdiff_on_tangent_map_within hmn hs\n  this.continuous_on\n#align cont_mdiff_on.continuous_on_tangent_map_within cont_mdiff_on.continuous_on_tangent_map_within\n\n",
 "cont_mdiff_tangent_map":
 "/-- If a function is `C^n`, then its bundled derivative is `C^m` when `m+1 ≤ n`. -/\ntheorem cont_mdiff.cont_mdiff_tangent_map (hf : cont_mdiff I I' n f) (hmn : m + 1 ≤ n) :\n    cont_mdiff I.tangent I'.tangent m (tangent_map I I' f) :=\n  by\n  rw [← cont_mdiff_on_univ] at hf⊢\n  convert hf.cont_mdiff_on_tangent_map_within hmn unique_mdiff_on_univ\n  rw [tangent_map_within_univ]\n#align cont_mdiff.cont_mdiff_tangent_map cont_mdiff.cont_mdiff_tangent_map\n\n",
 "cont_mdiff_on_tangent_map_within_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/-- If a function is `C^n` on a domain with unique derivatives, then its bundled derivative is\n`C^m` when `m+1 ≤ n`. In this auxiliary lemma, we prove this fact when the source and target space\nare model spaces in models with corners. The general fact is proved in\n`cont_mdiff_on.cont_mdiff_on_tangent_map_within` -/\ntheorem cont_mdiff_on.cont_mdiff_on_tangent_map_within_aux {f : H → H'} {s : Set H} (hf : cont_mdiff_on I I' n f s)\n    (hmn : m + 1 ≤ n) (hs : unique_mdiff_on I s) :\n    cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' f s) («expr ⁻¹' » ((exprπ) (tangent_space I)) s) :=\n  by\n  have m_le_n : m ≤ n := by\n    apply le_trans _ hmn\n    have : m + 0 ≤ m + 1 := add_le_add_left (zero_le _) _\n    simpa only [add_zero] using this\n  have one_le_n : 1 ≤ n := by\n    apply le_trans _ hmn\n    change 0 + 1 ≤ m + 1\n    exact add_le_add_right (zero_le _) _\n  have U' : unique_diff_on 𝕜 (range I ∩ «expr ⁻¹' » I.symm s) :=\n    by\n    intro y hy\n    simpa only [unique_mdiff_on, unique_mdiff_within_at, hy.1, inter_comm, mfld_simps] using hs (I.symm y) hy.2\n  rw [cont_mdiff_on_iff]\n  refine' ⟨hf.continuous_on_tangent_map_within_aux one_le_n hs, fun p q => _⟩\n  have A :\n    lower_set.prod (range I) univ ∩\n        «expr ⁻¹' » ((Equiv.sigmaEquivProd H E).symm ∘ fun p : E × E => (I.symm p.fst, p.snd))\n          («expr ⁻¹' » ((exprπ) (tangent_space I)) s) =\n      lower_set.prod (range I ∩ «expr ⁻¹' » I.symm s) univ :=\n    by\n    ext ⟨x, v⟩\n    simp only [mfld_simps]\n  suffices h :\n    cont_diff_on 𝕜 m\n      (((fun p : H' × E' => (I' p.fst, p.snd)) ∘ Equiv.sigmaEquivProd H' E') ∘\n        tangent_map_within I I' f s ∘ (Equiv.sigmaEquivProd H E).symm ∘ fun p : E × E => (I.symm p.fst, p.snd))\n      (lower_set.prod (range («expr⇑ » I) ∩ «expr ⁻¹' » («expr⇑ » I.symm) s) univ)\n  · simpa [A] using h\n  change\n    cont_diff_on 𝕜 m\n      (fun p : E × E => ((I' (f (I.symm p.fst)), (mfderiv_within I I' f s (I.symm p.fst) : E → E') p.snd) : E' × E'))\n      (lower_set.prod (range I ∩ «expr ⁻¹' » I.symm s) univ)\n  -- check that all bits in this formula are `C^n`\n  have hf' := cont_mdiff_on_iff.1 hf\n  have A : cont_diff_on 𝕜 m (I' ∘ f ∘ I.symm) (range I ∩ «expr ⁻¹' » I.symm s) := by\n    simpa only [mfld_simps] using (hf'.2 (I.symm 0) (I'.symm 0)).of_le m_le_n\n  have B : cont_diff_on 𝕜 m ((I' ∘ f ∘ I.symm) ∘ Prod.fst) (lower_set.prod (range I ∩ «expr ⁻¹' » I.symm s) univ) :=\n    A.comp cont_diff_fst.cont_diff_on (prod_subset_preimage_fst _ _)\n  suffices C :\n    cont_diff_on 𝕜 m (fun p : E × E => (fderiv_within 𝕜 (I' ∘ f ∘ I.symm) («expr ⁻¹' » I.symm s ∩ range I) p.1 : _) p.2)\n      (lower_set.prod (range I ∩ «expr ⁻¹' » I.symm s) univ)\n  · apply cont_diff_on.prod B _\n    apply C.congr fun p hp => _\n    simp only [mfld_simps] at hp\n    simp only [mfderiv_within, hf.mdifferentiable_on one_le_n _ hp.2, hp.1, if_pos, mfld_simps]\n  have D :\n    cont_diff_on 𝕜 m (fun x => fderiv_within 𝕜 (I' ∘ f ∘ I.symm) («expr ⁻¹' » I.symm s ∩ range I) x)\n      (range I ∩ «expr ⁻¹' » I.symm s) :=\n    by\n    have : cont_diff_on 𝕜 n (I' ∘ f ∘ I.symm) (range I ∩ «expr ⁻¹' » I.symm s) := by\n      simpa only [mfld_simps] using hf'.2 (I.symm 0) (I'.symm 0)\n    simpa only [inter_comm] using this.fderiv_within U' hmn\n  have := D.comp cont_diff_fst.cont_diff_on (prod_subset_preimage_fst _ _)\n  have := cont_diff_on.prod this cont_diff_snd.cont_diff_on\n  exact is_bounded_bilinear_map_apply.cont_diff.comp_cont_diff_on this\n#align cont_mdiff_on.cont_mdiff_on_tangent_map_within_aux cont_mdiff_on.cont_mdiff_on_tangent_map_within_aux\n\n",
 "cont_mdiff_on_tangent_map_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/-- If a function is `C^n` on a domain with unique derivatives, then its bundled derivative\nis `C^m` when `m+1 ≤ n`. -/\ntheorem cont_mdiff_on.cont_mdiff_on_tangent_map_within (hf : cont_mdiff_on I I' n f s) (hmn : m + 1 ≤ n)\n    (hs : unique_mdiff_on I s) :\n    cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' f s) («expr ⁻¹' » ((exprπ) (tangent_space I)) s) :=\n  by\n  /- The strategy of the proof is to avoid unfolding the definitions, and reduce by functoriality\n    to the case of functions on the model spaces, where we have already proved the result.\n    Let `l` and `r` be the charts to the left and to the right, so that we have\n    ```\n       l^{-1}      f       r\n    H --------> M ---> M' ---> H'\n    ```\n    Then the tangent map `T(r ∘ f ∘ l)` is smooth by a previous result. Consider the composition\n    ```\n        Tl        T(r ∘ f ∘ l^{-1})         Tr^{-1}\n    TM -----> TH -------------------> TH' ---------> TM'\n    ```\n    where `Tr^{-1}` and `Tl` are the tangent maps of `r^{-1}` and `l`. Writing `Tl` and `Tr^{-1}` as\n    composition of charts (called `Dl` and `il` for `l` and `Dr` and `ir` in the proof below), it\n    follows that they are smooth. The composition of all these maps is `Tf`, and is therefore smooth\n    as a composition of smooth maps.\n    -/\n  have m_le_n : m ≤ n := by\n    apply le_trans _ hmn\n    have : m + 0 ≤ m + 1 := add_le_add_left (zero_le _) _\n    simpa only [add_zero]\n  have one_le_n : 1 ≤ n := by\n    apply le_trans _ hmn\n    change 0 + 1 ≤ m + 1\n    exact add_le_add_right (zero_le _) _\n  -- First step: local reduction on the space, to a set `s'` which is contained in chart domains.\n  refine' cont_mdiff_on_of_locally_cont_mdiff_on fun p hp => _\n  have hf' := cont_mdiff_on_iff.1 hf\n  simp only [mfld_simps] at hp\n  let l := chart_at H p.proj\n  set Dl := chart_at (ModelProd H E) p with hDl\n  let r := chart_at H' (f p.proj)\n  let Dr := chart_at (ModelProd H' E') (tangent_map_within I I' f s p)\n  let il := chart_at (ModelProd H E) (tangent_map I I l p)\n  let ir := chart_at (ModelProd H' E') (tangent_map I I' (r ∘ f) p)\n  let s' := «expr ⁻¹' » f r.source ∩ s ∩ l.source\n  let s'_lift := «expr ⁻¹' » ((exprπ) (tangent_space I)) s'\n  let s'l := l.target ∩ «expr ⁻¹' » l.symm s'\n  let s'l_lift := «expr ⁻¹' » ((exprπ) (tangent_space I)) s'l\n  rcases continuousOn_iff'.1 hf'.1 r.source r.open_source with ⟨o, o_open, ho⟩\n  suffices h : cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' f s) s'_lift\n  · refine' ⟨«expr ⁻¹' » ((exprπ) (tangent_space I)) (o ∩ l.source), _, _, _⟩\n    show IsOpen («expr ⁻¹' » ((exprπ) (tangent_space I)) (o ∩ l.source))\n    exact (IsOpen.inter o_open l.open_source).preimage (continuous_proj E _)\n    show p ∈ «expr ⁻¹' » ((exprπ) (tangent_space I)) (o ∩ l.source)\n    · simp\n      have : p.proj ∈ «expr ⁻¹' » f r.source ∩ s := by simp [hp]\n      rw [ho] at this\n      exact this.1\n    · have :\n        «expr ⁻¹' » ((exprπ) (tangent_space I)) s ∩ «expr ⁻¹' » ((exprπ) (tangent_space I)) (o ∩ l.source) = s'_lift :=\n        by\n        dsimp only [s'_lift, s']\n        rw [ho]\n        mfld_set_tac\n      rw [this]\n      exact h\n  /- Second step: check that all functions are smooth, and use the chain rule to write the bundled\n    derivative as a composition of a function between model spaces and of charts.\n    Convention: statements about the differentiability of `a ∘ b ∘ c` are named `diff_abc`. Statements\n    about differentiability in the bundle have a `_lift` suffix. -/\n  have U' : unique_mdiff_on I s' := by\n    apply unique_mdiff_on.inter _ l.open_source\n    rw [ho, inter_comm]\n    exact hs.inter o_open\n  have U'l : unique_mdiff_on I s'l := U'.unique_mdiff_on_preimage (mdifferentiable_chart _ _)\n  have diff_f : cont_mdiff_on I I' n f s' := hf.mono (by mfld_set_tac)\n  have diff_r : cont_mdiff_on I' I' n r r.source := cont_mdiff_on_chart\n  have diff_rf : cont_mdiff_on I I' n (r ∘ f) s' :=\n    by\n    apply cont_mdiff_on.comp diff_r diff_f fun x hx => _\n    simp only [s', mfld_simps] at hx\n    simp only [hx, mfld_simps]\n  have diff_l : cont_mdiff_on I I n l.symm s'l :=\n    haveI A : cont_mdiff_on I I n l.symm l.target := cont_mdiff_on_chart_symm\n    A.mono (by mfld_set_tac)\n  have diff_rfl : cont_mdiff_on I I' n (r ∘ f ∘ l.symm) s'l :=\n    by\n    apply cont_mdiff_on.comp diff_rf diff_l\n    mfld_set_tac\n  have diff_rfl_lift : cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' (r ∘ f ∘ l.symm) s'l) s'l_lift :=\n    diff_rfl.cont_mdiff_on_tangent_map_within_aux hmn U'l\n  have diff_irrfl_lift :\n    cont_mdiff_on I.tangent I'.tangent m (ir ∘ tangent_map_within I I' (r ∘ f ∘ l.symm) s'l) s'l_lift :=\n    haveI A : cont_mdiff_on I'.tangent I'.tangent m ir ir.source := cont_mdiff_on_chart\n    cont_mdiff_on.comp A diff_rfl_lift fun p hp => by simp only [ir, mfld_simps]\n  have diff_Drirrfl_lift :\n    cont_mdiff_on I.tangent I'.tangent m (Dr.symm ∘ ir ∘ tangent_map_within I I' (r ∘ f ∘ l.symm) s'l) s'l_lift :=\n    by\n    have A : cont_mdiff_on I'.tangent I'.tangent m Dr.symm Dr.target := cont_mdiff_on_chart_symm\n    apply cont_mdiff_on.comp A diff_irrfl_lift fun p hp => _\n    simp only [s'l_lift, mfld_simps] at hp\n    simp only [ir, hp, mfld_simps]\n  -- conclusion of this step: the composition of all the maps above is smooth\n  have diff_DrirrflilDl :\n    cont_mdiff_on I.tangent I'.tangent m (Dr.symm ∘ (ir ∘ tangent_map_within I I' (r ∘ f ∘ l.symm) s'l) ∘ il.symm ∘ Dl)\n      s'_lift :=\n    by\n    have A : cont_mdiff_on I.tangent I.tangent m Dl Dl.source := cont_mdiff_on_chart\n    have A' : cont_mdiff_on I.tangent I.tangent m Dl s'_lift :=\n      by\n      apply A.mono fun p hp => _\n      simp only [s'_lift, mfld_simps] at hp\n      simp only [Dl, hp, mfld_simps]\n    have B : cont_mdiff_on I.tangent I.tangent m il.symm il.target := cont_mdiff_on_chart_symm\n    have C : cont_mdiff_on I.tangent I.tangent m (il.symm ∘ Dl) s'_lift :=\n      cont_mdiff_on.comp B A' fun p hp => by simp only [il, mfld_simps]\n    apply cont_mdiff_on.comp diff_Drirrfl_lift C fun p hp => _\n    simp only [s'_lift, mfld_simps] at hp\n    simp only [il, s'l_lift, hp, total_space.proj, mfld_simps]\n  /- Third step: check that the composition of all the maps indeed coincides with the derivative we\n    are looking for -/\n  have eq_comp :\n    ∀ q ∈ s'_lift,\n      tangent_map_within I I' f s q = (Dr.symm ∘ ir ∘ tangent_map_within I I' (r ∘ f ∘ l.symm) s'l ∘ il.symm ∘ Dl) q :=\n    by\n    intro q hq\n    simp only [s'_lift, mfld_simps] at hq\n    have U'q : unique_mdiff_within_at I s' q.1 := by\n      apply U'\n      simp only [hq, s', mfld_simps]\n    have U'lq : unique_mdiff_within_at I s'l (Dl q).1 := by\n      apply U'l\n      simp only [hq, s'l, mfld_simps]\n    have A :\n      tangent_map_within I I' ((r ∘ f) ∘ l.symm) s'l (il.symm (Dl q)) =\n        tangent_map_within I I' (r ∘ f) s' (tangent_map_within I I l.symm s'l (il.symm (Dl q))) :=\n      by\n      refine' tangent_map_within_comp_at (il.symm (Dl q)) _ _ (fun p hp => _) U'lq\n      · apply diff_rf.mdifferentiable_on one_le_n\n        simp only [hq, mfld_simps]\n      · apply diff_l.mdifferentiable_on one_le_n\n        simp only [s'l, hq, mfld_simps]\n      · simp only [mfld_simps] at hp\n        simp only [hp, mfld_simps]\n    have B : tangent_map_within I I l.symm s'l (il.symm (Dl q)) = q :=\n      by\n      have : tangent_map_within I I l.symm s'l (il.symm (Dl q)) = tangent_map I I l.symm (il.symm (Dl q)) :=\n        by\n        refine' tangent_map_within_eq_tangent_map U'lq _\n        refine' mdifferentiable_at_atlas_symm _ (chart_mem_atlas _ _) _\n        simp only [hq, mfld_simps]\n      rw [this, tangent_map_chart_symm, hDl]\n      · simp only [hq, mfld_simps]\n        have : q ∈ (chart_at (ModelProd H E) p).source := by simp only [hq, mfld_simps]\n        exact (chart_at (ModelProd H E) p).left_inv this\n      · simp only [hq, mfld_simps]\n    have C :\n      tangent_map_within I I' (r ∘ f) s' q = tangent_map_within I' I' r r.source (tangent_map_within I I' f s' q) :=\n      by\n      refine' tangent_map_within_comp_at q _ _ (fun r hr => _) U'q\n      · apply diff_r.mdifferentiable_on one_le_n\n        simp only [hq, mfld_simps]\n      · apply diff_f.mdifferentiable_on one_le_n\n        simp only [hq, mfld_simps]\n      · simp only [s', mfld_simps] at hr\n        simp only [hr, mfld_simps]\n    have D :\n      Dr.symm (ir (tangent_map_within I' I' r r.source (tangent_map_within I I' f s' q))) =\n        tangent_map_within I I' f s' q :=\n      by\n      have A :\n        tangent_map_within I' I' r r.source (tangent_map_within I I' f s' q) =\n          tangent_map I' I' r (tangent_map_within I I' f s' q) :=\n        by\n        apply tangent_map_within_eq_tangent_map\n        · apply is_open.unique_mdiff_within_at _ r.open_source\n          simp [hq]\n        · refine' mdifferentiable_at_atlas _ (chart_mem_atlas _ _) _\n          simp only [hq, mfld_simps]\n      have : f p.proj = (tangent_map_within I I' f s p).1 := rfl\n      rw [A]\n      dsimp [r, Dr]\n      rw [this, tangent_map_chart]\n      · simp only [hq, mfld_simps]\n        have : tangent_map_within I I' f s' q ∈ (chart_at (ModelProd H' E') (tangent_map_within I I' f s p)).source :=\n          by simp only [hq, mfld_simps]\n        exact (chart_at (ModelProd H' E') (tangent_map_within I I' f s p)).left_inv this\n      · simp only [hq, mfld_simps]\n    have E : tangent_map_within I I' f s' q = tangent_map_within I I' f s q :=\n      by\n      refine' tangent_map_within_subset (by mfld_set_tac) U'q _\n      apply hf.mdifferentiable_on one_le_n\n      simp only [hq, mfld_simps]\n    simp only [(· ∘ ·), A, B, C, D, E.symm]\n  exact diff_DrirrflilDl.congr eq_comp\n#align cont_mdiff_on.cont_mdiff_on_tangent_map_within cont_mdiff_on.cont_mdiff_on_tangent_map_within\n\n"}