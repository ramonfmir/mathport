{"target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n@[simp, mfld_simps]\ntheorem target (i : atlas H M) : (Z.to_vector_bundle_core.local_triv i).target = lower_set.prod i.1.source univ :=\n  rfl\n#align target target\n\n",
 "tangent_bundle_proj_open":
 "/-- The tangent bundle projection on the basis is an open map. -/\ntheorem tangent_bundle_proj_open : is_open_map (tangent_bundle.proj I M) :=\n  (tangent_bundle_core I M).to_vector_bundle_core.is_open_map_proj\n#align tangent_bundle_proj_open tangent_bundle_proj_open\n\n",
 "tangent_bundle_proj_continuous":
 "/- In general, the definition of tangent_bundle and tangent_space are not reducible, so that type\nclass inference does not pick wrong instances. In this section, we record the right instances for\nthem, noting in particular that the tangent bundle is a smooth manifold. -/\n/-- The tangent bundle projection on the basis is a continuous map. -/\ntheorem tangent_bundle_proj_continuous : continuous (tangent_bundle.proj I M) :=\n  (tangent_bundle_core I M).to_vector_bundle_core.continuous_proj\n#align tangent_bundle_proj_continuous tangent_bundle_proj_continuous\n\n",
 "tangent_bundle_model_space_homeomorph_coe_symm":
 "@[simp, mfld_simps]\ntheorem tangent_bundle_model_space_homeomorph_coe_symm :\n    ((tangent_bundle_model_space_homeomorph H I).symm : model_prod H E ‚Üí tangent_bundle I H) =\n      (equiv.sigma_equiv_prod H E).symm :=\n  rfl\n#align tangent_bundle_model_space_homeomorph_coe_symm tangent_bundle_model_space_homeomorph_coe_symm\n\n",
 "tangent_bundle_model_space_homeomorph_coe":
 "@[simp, mfld_simps]\ntheorem tangent_bundle_model_space_homeomorph_coe :\n    (tangent_bundle_model_space_homeomorph H I : tangent_bundle I H ‚Üí model_prod H E) = equiv.sigma_equiv_prod H E :=\n  rfl\n#align tangent_bundle_model_space_homeomorph_coe tangent_bundle_model_space_homeomorph_coe\n\n",
 "tangent_bundle_model_space_coe_chart_at_symm":
 "@[simp, mfld_simps]\ntheorem tangent_bundle_model_space_coe_chart_at_symm (p : tangent_bundle I H) :\n    ((chart_at (model_prod H E) p).symm : model_prod H E ‚Üí tangent_bundle I H) = (equiv.sigma_equiv_prod H E).symm :=\n  by\n  unfold_coes\n  simp only [mfld_simps]\n#align tangent_bundle_model_space_coe_chart_at_symm tangent_bundle_model_space_coe_chart_at_symm\n\n",
 "tangent_bundle_model_space_coe_chart_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚áë ¬ª -/\n@[simp, mfld_simps]\ntheorem tangent_bundle_model_space_coe_chart_at (p : tangent_bundle I H) :\n    ¬´expr‚áë ¬ª (chart_at (model_prod H E) p) = equiv.sigma_equiv_prod H E :=\n  by\n  unfold_coes\n  simp only [mfld_simps]\n#align tangent_bundle_model_space_coe_chart_at tangent_bundle_model_space_coe_chart_at\n\n",
 "tangent_bundle_model_space_chart_at":
 "/-- In the tangent bundle to the model space, the charts are just the canonical identification\nbetween a product type and a sigma type, a.k.a. `equiv.sigma_equiv_prod`. -/\n@[simp, mfld_simps]\ntheorem tangent_bundle_model_space_chart_at (p : tangent_bundle I H) :\n    (chart_at (model_prod H E) p).to_local_equiv = (equiv.sigma_equiv_prod H E).to_local_equiv :=\n  by\n  have A : ‚àÄ x_fst, fderiv_within ùïú (I ‚àò I.symm) (range I) (I x_fst) = continuous_linear_map.id ùïú E :=\n    by\n    intro x_fst\n    have : fderiv_within ùïú (I ‚àò I.symm) (range I) (I x_fst) = fderiv_within ùïú id (range I) (I x_fst) :=\n      by\n      refine' fderiv_within_congr I.unique_diff_at_image (fun y hy => _) (by simp)\n      exact model_with_corners.right_inv _ hy\n    rwa [fderiv_within_id I.unique_diff_at_image] at this\n  ext x : 1\n  show (chart_at (model_prod H E) p : tangent_bundle I H ‚Üí model_prod H E) x = (equiv.sigma_equiv_prod H E) x\n  ¬∑ cases x\n    simp only [chart_at, basic_smooth_vector_bundle_core.chart, tangent_bundle_core,\n      basic_smooth_vector_bundle_core.to_vector_bundle_core, A, prod.mk.inj_iff, continuous_linear_map.coe_id',\n      mfld_simps]\n  show ‚àÄ x, (chart_at (model_prod H E) p).to_local_equiv.symm x = (equiv.sigma_equiv_prod H E).symm x\n  ¬∑ rintro ‚ü®x_fst, x_snd‚ü©\n    simp only [basic_smooth_vector_bundle_core.to_vector_bundle_core, tangent_bundle_core, A,\n      continuous_linear_map.coe_id', basic_smooth_vector_bundle_core.chart, chart_at, continuous_linear_map.coe_coe,\n      sigma.mk.inj_iff, mfld_simps]\n  show (chart_at (model_prod H E) p).to_local_equiv.source = univ\n  ¬∑ simp only [chart_at, mfld_simps]\n#align tangent_bundle_model_space_chart_at tangent_bundle_model_space_chart_at\n\n",
 "proj_apply":
 "/- We have to check that the charts belong to the smooth groupoid, i.e., they are smooth on their\n  source, and their inverses are smooth on the target. Since both objects are of the same kind, it\n  suffices to prove the first statement in A below, and then glue back the pieces at the end. -/\n-- check separately that the two components of the coordinate change are smooth\n-- the coordinate change on the base is just a coordinate change for `M`, smooth since\n-- `M` is smooth\n/- The coordinate change in the fiber is more complicated as its definition involves the\n      reference chart chosen at each point. However, it appears with its inverse, so using the\n      cocycle property one can get rid of it, and then conclude using the smoothness of the\n      cocycle as given in the definition of basic smooth bundles. -/\n/- Locally, a self-change of coordinate is just the identity, thus its derivative is the\n    identity. One just needs to write this carefully, paying attention to the sets where the\n    functions are defined. -/\n/- The cocycle property is just the fact that the derivative of a composition is the product of\n    the derivatives. One needs however to check that all the functions one considers are smooth, and\n    to pay attention to the domains where these functions are defined, making this proof a little\n    bit cumbersome although there is nothing complicated here. -/\n-- is empty if the base manifold is empty\n@[simp, mfld_simps]\ntheorem tangent_bundle.proj_apply (x : M) (v : tangent_space I x) : tangent_bundle.proj I M ‚ü®x, v‚ü© = x :=\n  rfl\n#align tangent_bundle.proj_apply tangent_bundle.proj_apply\n\n",
 "mem_chart_target_iff":
 "@[simp, mfld_simps]\ntheorem mem_chart_target_iff (p : H √ó F) (q : Z.to_vector_bundle_core.total_space) :\n    p ‚àà (chart_at (model_prod H F) q).target ‚Üî p.1 ‚àà (chart_at H q.1).target := by simp only [chart_at, mfld_simps]\n#align mem_chart_target_iff mem_chart_target_iff\n\n",
 "mem_chart_source_iff":
 "@[simp, mfld_simps]\ntheorem mem_chart_source_iff (p q : Z.to_vector_bundle_core.total_space) :\n    p ‚àà (chart_at (model_prod H F) q).source ‚Üî p.1 ‚àà (chart_at H q.1).source := by simp only [chart_at, mfld_simps]\n#align mem_chart_source_iff mem_chart_source_iff\n\n",
 "mem_atlas_iff":
 "theorem mem_atlas_iff (f : local_homeomorph Z.to_vector_bundle_core.total_space (model_prod H F)) :\n    f ‚àà atlas (model_prod H F) Z.to_vector_bundle_core.total_space ‚Üî\n      ‚àÉ (e : local_homeomorph M H)(he : e ‚àà atlas H M), f = Z.chart he :=\n  by simp only [atlas, mem_Union, mem_singleton_iff]\n#align mem_atlas_iff mem_atlas_iff\n\n",
 "coord_change_smooth":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `with_top.nat.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ÜíL[ ] ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `with_top.nat.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `with_top.nat.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\ntheorem coord_change_smooth (i j : atlas H M) :\n    cont_diff_on ùïú (with_top.nat.top) (fun p : E √ó F => Z.coord_change i j (I.symm p.1) p.2)\n      (lower_set.prod (¬´expr '' ¬ª I (i.1.symm.trans j.1).source) univ) :=\n  by\n  have A : cont_diff ùïú (with_top.nat.top) fun p : ¬´expr ‚ÜíL[ ] ¬ª F ùïú F √ó F => p.1 p.2 :=\n    by\n    apply is_bounded_bilinear_map.cont_diff\n    exact is_bounded_bilinear_map_apply\n  have B :\n    cont_diff_on ùïú (with_top.nat.top) (fun p : E √ó F => (Z.coord_change i j (I.symm p.1), p.snd))\n      (lower_set.prod (¬´expr '' ¬ª I (i.1.symm.trans j.1).source) univ) :=\n    by\n    apply cont_diff_on.prod _ _\n    ¬∑ exact (Z.coord_change_smooth_clm i j).comp cont_diff_fst.cont_diff_on (prod_subset_preimage_fst _ _)\n    ¬∑ exact is_bounded_linear_map.snd.cont_diff.cont_diff_on\n  exact A.comp_cont_diff_on B\n#align coord_change_smooth coord_change_smooth\n\n",
 "coord_change_self'":
 "/-- A reformulation of `coord_change_self`, formulated in terms of a point in `M`. -/\ntheorem coord_change_self' {i : atlas H M} {x : M} (hi : x ‚àà i.1.source) (v : F) : Z.coord_change i i (i x) v = v :=\n  Z.coord_change_self i (i x) (i.1.maps_to hi) v\n#align coord_change_self' coord_change_self'\n\n",
 "coord_change_continuous":
 "theorem coord_change_continuous (i j : atlas H M) : continuous_on (Z.coord_change i j) (i.1.symm.trans j.1).source :=\n  by\n  intro x hx\n  apply\n    (((Z.coord_change_smooth_clm i j).continuous_on.continuous_within_at (mem_image_of_mem I hx)).comp\n        I.continuous_within_at _).congr\n  ¬∑ intro y hy\n    simp only [mfld_simps]\n  ¬∑ simp only [mfld_simps]\n  ¬∑ exact maps_to_image I _\n#align coord_change_continuous coord_change_continuous\n\n",
 "coord_change_comp_eq_self'":
 "/-- `Z.coord_change j i` is a partial inverse of `Z.coord_change i j`,\nformulated in terms of a point in `M`. -/\ntheorem coord_change_comp_eq_self' {i j : atlas H M} {x : M} (hi : x ‚àà i.1.source) (hj : x ‚àà j.1.source) (v : F) :\n    Z.coord_change j i (j x) (Z.coord_change i j (i x) v) = v := by\n  rw [Z.coord_change_comp' hi hj hi v, Z.coord_change_self' hi]\n#align coord_change_comp_eq_self' coord_change_comp_eq_self'\n\n",
 "coord_change_comp_eq_self":
 "/-- `Z.coord_change j i` is a partial inverse of `Z.coord_change i j`. -/\ntheorem coord_change_comp_eq_self (i j : atlas H M) {x : H} (hx : x ‚àà (i.1.symm.trans j.1).source) (v : F) :\n    Z.coord_change j i (i.1.symm.trans j.1 x) (Z.coord_change i j x v) = v :=\n  by\n  rw [Z.coord_change_comp i j i x _ v, Z.coord_change_self _ _ hx.1]\n  simp only [mfld_simps] at hx\n  simp only [hx.1, hx.2, mfld_simps]\n#align coord_change_comp_eq_self coord_change_comp_eq_self\n\n",
 "coord_change_comp'":
 "/-\nCopyright (c) 2019 S√©bastien Gou√´zel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: S√©bastien Gou√´zel\n-/\n/-- A reformulation of `coord_change_comp`, formulated in terms of a point in `M`.\nThe conditions on this point a significantly simpler than in `coord_change_comp`. -/\ntheorem coord_change_comp' {i j k : atlas H M} {x : M} (hi : x ‚àà i.1.source) (hj : x ‚àà j.1.source) (hk : x ‚àà k.1.source)\n    (v : F) : Z.coord_change j k (j x) (Z.coord_change i j (i x) v) = Z.coord_change i k (i x) v :=\n  by\n  rw [show j x = _ by rw [‚Üê i.1.left_inv hi]]\n  apply Z.coord_change_comp\n  simp only [hi, hj, hk, mfld_simps]\n#align coord_change_comp' coord_change_comp'\n\n",
 "coe_chart_at_symm_fst":
 "@[simp, mfld_simps]\ntheorem coe_chart_at_symm_fst (p : H √ó F) (q : Z.to_vector_bundle_core.total_space) :\n    ((chart_at (model_prod H F) q).symm p).1 = ((chart_at H q.1).symm : H ‚Üí M) p.1 :=\n  rfl\n#align coe_chart_at_symm_fst coe_chart_at_symm_fst\n\n",
 "coe_chart_at_fst":
 "@[simp, mfld_simps]\ntheorem coe_chart_at_fst (p q : Z.to_vector_bundle_core.total_space) :\n    ((chart_at (model_prod H F) q) p).1 = chart_at H q.1 p.1 :=\n  rfl\n#align coe_chart_at_fst coe_chart_at_fst\n\n",
 "chart_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n@[simp, mfld_simps]\ntheorem chart_target (e : local_homeomorph M H) (he : e ‚àà atlas H M) :\n    (Z.chart he).target = lower_set.prod e.target univ :=\n  by\n  simp only [chart]\n  mfld_set_tac\n#align chart_target chart_target\n\n",
 "chart_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n@[simp, mfld_simps]\ntheorem chart_source (e : local_homeomorph M H) (he : e ‚àà atlas H M) :\n    (Z.chart he).source = ¬´expr ‚Åª¬π' ¬ª Z.to_vector_bundle_core.proj e.source :=\n  by\n  simp only [chart, mem_prod]\n  mfld_set_tac\n#align chart_source chart_source\n\n",
 "chart_apply":
 "theorem chart_apply {x : M} (z : Z.to_vector_bundle_core.total_space) :\n    Z.chart (chart_mem_atlas H x) z =\n      (chart_at H x z.proj, Z.coord_change (achart H z.proj) (achart H x) (achart H z.proj z.proj) z.2) :=\n  rfl\n#align chart_apply chart_apply\n\n",
 "base_set":
 "@[simp, mfld_simps]\ntheorem base_set (i : atlas H M) : (Z.to_vector_bundle_core.local_triv i).base_set = i.1.source :=\n  rfl\n#align base_set base_set\n\n"}