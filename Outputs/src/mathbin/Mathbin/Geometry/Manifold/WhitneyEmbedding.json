{"exists_immersion_euclidean":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self.euclidean -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self.euclidean -/\n/-- Baby version of the **Whitney weak embedding theorem**: if `M` admits a finite covering by\nsupports of bump functions, then for some `n` it can be immersed into the `n`-dimensional\nEuclidean space. -/\ntheorem exists_immersion_euclidean [Finite ι] (f : smooth_bump_covering ι I M) :\n    ∃ (n : ℕ)(e : M → euclidean_space (exprℝ) (Fin n)),\n      smooth I (model_with_corners_self.euclidean n) e ∧\n        injective e ∧ ∀ x : M, injective (mfderiv I (model_with_corners_self.euclidean n) e x) :=\n  by\n  cases nonempty_fintype ι\n  set F := euclidean_space (exprℝ) (Fin <| finrank (exprℝ) (ι → E × exprℝ))\n  letI : IsNoetherian (exprℝ) (E × exprℝ) := IsNoetherian.iff_fg.2 inferInstance\n  letI : FiniteDimensional (exprℝ) (ι → E × exprℝ) := IsNoetherian.iff_fg.1 inferInstance\n  set eEF : «expr ≃L[ ] » (ι → E × exprℝ) (exprℝ) F :=\n    continuous_linear_equiv.of_finrank_eq finrank_euclidean_space_fin.symm\n  refine'\n    ⟨_, eEF ∘ f.embedding_pi_tangent, eEF.to_diffeomorph.smooth.comp f.embedding_pi_tangent.smooth,\n      eEF.injective.comp f.embedding_pi_tangent_injective, fun x => _⟩\n  rw [mfderiv_comp _ eEF.differentiable_at.mdifferentiable_at f.embedding_pi_tangent.mdifferentiable_at, eEF.mfderiv_eq]\n  exact eEF.injective.comp (f.embedding_pi_tangent_injective_mfderiv _ trivial)\n#align exists_immersion_euclidean exists_immersion_euclidean\n\n",
 "exists_embedding_euclidean_of_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self.euclidean -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self.euclidean -/\n/-- Baby version of the Whitney weak embedding theorem: if `M` admits a finite covering by\nsupports of bump functions, then for some `n` it can be embedded into the `n`-dimensional\nEuclidean space. -/\ntheorem exists_embedding_euclidean_of_compact [T2Space M] [CompactSpace M] :\n    ∃ (n : ℕ)(e : M → euclidean_space (exprℝ) (Fin n)),\n      smooth I (model_with_corners_self.euclidean n) e ∧\n        ClosedEmbedding e ∧ ∀ x : M, injective (mfderiv I (model_with_corners_self.euclidean n) e x) :=\n  by\n  rcases smooth_bump_covering.exists_is_subordinate I isClosed_univ fun (x : M) _ => univ_mem with ⟨ι, f, -⟩\n  haveI := f.fintype\n  rcases f.exists_immersion_euclidean with ⟨n, e, hsmooth, hinj, hinj_mfderiv⟩\n  exact ⟨n, e, hsmooth, hsmooth.continuous.closed_embedding hinj, hinj_mfderiv⟩\n#align exists_embedding_euclidean_of_compact exists_embedding_euclidean_of_compact\n\n",
 "embedding_pi_tangent_ker_mfderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem embedding_pi_tangent_ker_mfderiv (x : M) (hx : x ∈ s) :\n    LinearMap.ker (mfderiv I (model_with_corners_self (exprℝ) (ι → E × exprℝ)) f.embedding_pi_tangent x) = «expr⊥» :=\n  by\n  apply bot_unique\n  rw [← (mdifferentiable_chart I (f.c (f.ind x hx))).ker_mfderiv_eq_bot (f.mem_chart_at_ind_source x hx), ←\n    comp_embedding_pi_tangent_mfderiv]\n  exact LinearMap.ker_le_ker_comp _ _\n#align embedding_pi_tangent_ker_mfderiv embedding_pi_tangent_ker_mfderiv\n\n",
 "embedding_pi_tangent_injective_mfderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem embedding_pi_tangent_injective_mfderiv (x : M) (hx : x ∈ s) :\n    injective (mfderiv I (model_with_corners_self (exprℝ) (ι → E × exprℝ)) f.embedding_pi_tangent x) :=\n  LinearMap.ker_eq_bot.1 (f.embedding_pi_tangent_ker_mfderiv x hx)\n#align embedding_pi_tangent_injective_mfderiv embedding_pi_tangent_injective_mfderiv\n\n",
 "embedding_pi_tangent_injective":
 "theorem embedding_pi_tangent_injective (f : smooth_bump_covering ι I M) : injective f.embedding_pi_tangent :=\n  injective_iff_injOn_univ.2 f.embedding_pi_tangent_inj_on\n#align embedding_pi_tangent_injective embedding_pi_tangent_injective\n\n",
 "embedding_pi_tangent_inj_on":
 "theorem embedding_pi_tangent_inj_on : InjOn f.embedding_pi_tangent s :=\n  by\n  intro x hx y hy h\n  simp only [embedding_pi_tangent_coe, funext_iff] at h\n  obtain ⟨h₁, h₂⟩ := Prod.mk.inj_iff.1 (h (f.ind x hx))\n  rw [f.apply_ind x hx] at h₂\n  rw [← h₂, f.apply_ind x hx, one_smul, one_smul] at h₁\n  have := f.mem_ext_chart_at_source_of_eq_one h₂.symm\n  exact (ext_chart_at I (f.c _)).inj_on (f.mem_ext_chart_at_ind_source x hx) this h₁\n#align embedding_pi_tangent_inj_on embedding_pi_tangent_inj_on\n\n",
 "embedding_pi_tangent_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2021 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov\n-/\n@[local simp]\ntheorem embedding_pi_tangent_coe :\n    «expr⇑ » f.embedding_pi_tangent = fun x i => («expr • » (f i x) (ext_chart_at I (f.c i) x), f i x) :=\n  rfl\n#align embedding_pi_tangent_coe embedding_pi_tangent_coe\n\n",
 "comp_embedding_pi_tangent_mfderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem comp_embedding_pi_tangent_mfderiv (x : M) (hx : x ∈ s) :\n    ((ContinuousLinearMap.fst (exprℝ) E (exprℝ)).comp\n            (@ContinuousLinearMap.proj (exprℝ) _ ι (fun _ => E × exprℝ) _ _ (fun _ => inferInstance) (f.ind x hx))).comp\n        (mfderiv I (model_with_corners_self (exprℝ) (ι → E × exprℝ)) f.embedding_pi_tangent x) =\n      mfderiv I I (chart_at H (f.c (f.ind x hx))) x :=\n  by\n  set L :=\n    (ContinuousLinearMap.fst (exprℝ) E (exprℝ)).comp\n      (@ContinuousLinearMap.proj (exprℝ) _ ι (fun _ => E × exprℝ) _ _ (fun _ => inferInstance) (f.ind x hx))\n  have := L.has_mfderiv_at.comp x f.embedding_pi_tangent.mdifferentiable_at.has_mfderiv_at\n  convert has_mfderiv_at_unique this _\n  refine' (has_mfderiv_at_ext_chart_at I (f.mem_chart_at_ind_source x hx)).congr_of_eventually_eq _\n  refine' (f.eventually_eq_one x hx).mono fun y hy => _\n  simp only [embedding_pi_tangent_coe, ContinuousLinearMap.coe_comp', (· ∘ ·), ContinuousLinearMap.coe_fst',\n    ContinuousLinearMap.proj_apply]\n  rw [hy, Pi.one_apply, one_smul]\n#align comp_embedding_pi_tangent_mfderiv comp_embedding_pi_tangent_mfderiv\n\n"}