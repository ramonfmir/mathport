{"right_invariance":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem right_invariance {s : Set H} {x : H} {f : H → H'} {e : LocalHomeomorph H H} (he : e ∈ G) (hxe : x ∈ e.source) :\n    P (f ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) ↔ P f s x :=\n  by\n  refine' ⟨fun h => _, hG.right_invariance' he hxe⟩\n  have := hG.right_invariance' (G.symm he) (e.maps_to hxe) h\n  rw [e.symm_symm, e.left_inv hxe] at this\n  refine' hG.congr _ ((hG.congr_set _).mp this)\n  · refine' eventually_of_mem (e.open_source.mem_nhds hxe) fun x' hx' => _\n    simp_rw [Function.comp_apply, e.left_inv hx']\n  · rw [eventually_eq_set]\n    refine' eventually_of_mem (e.open_source.mem_nhds hxe) fun x' hx' => _\n    simp_rw [mem_preimage, e.left_inv hx']\n#align right_invariance right_invariance\n\n",
 "lift_prop_within_at_univ":
 "theorem lift_prop_within_at_univ : LiftPropWithinAt P g univ x ↔ LiftPropAt P g x :=\n  iff.rfl\n#align lift_prop_within_at_univ lift_prop_within_at_univ\n\n",
 "lift_prop_within_at_self_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lift_prop_within_at_self_target {f : M → H'} :\n    LiftPropWithinAt P f s x ↔\n      ContinuousWithinAt f s x ∧ P (f ∘ (chart_at H x).symm) («expr ⁻¹' » (chart_at H x).symm s) (chart_at H x x) :=\n  iff.rfl\n#align lift_prop_within_at_self_target lift_prop_within_at_self_target\n\n",
 "lift_prop_within_at_self_source":
 "theorem lift_prop_within_at_self_source {f : H → M'} {s : Set H} {x : H} :\n    LiftPropWithinAt P f s x ↔ ContinuousWithinAt f s x ∧ P (chart_at H' (f x) ∘ f) s x :=\n  iff.rfl\n#align lift_prop_within_at_self_source lift_prop_within_at_self_source\n\n",
 "lift_prop_within_at_self":
 "theorem lift_prop_within_at_self {f : H → H'} {s : Set H} {x : H} :\n    LiftPropWithinAt P f s x ↔ ContinuousWithinAt f s x ∧ P f s x :=\n  iff.rfl\n#align lift_prop_within_at_self lift_prop_within_at_self\n\n",
 "lift_prop_within_at_of_lift_prop_at_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem lift_prop_within_at_of_lift_prop_at_of_mem_nhds (h : LiftPropAt P g x) (hs : s ∈ (nhds) x) :\n    LiftPropWithinAt P g s x := by rwa [← univ_inter s, hG.lift_prop_within_at_inter hs]\n#align lift_prop_within_at_of_lift_prop_at_of_mem_nhds lift_prop_within_at_of_lift_prop_at_of_mem_nhds\n\n",
 "lift_prop_within_at_of_lift_prop_at":
 "theorem lift_prop_within_at_of_lift_prop_at (mono : ∀ ⦃s x t⦄ ⦃f : H → H'⦄, t ⊆ s → P f s x → P f t x)\n    (h : LiftPropAt P g x) : LiftPropWithinAt P g s x :=\n  by\n  rw [← lift_prop_within_at_univ] at h\n  exact lift_prop_within_at_mono mono h (subset_univ _)\n#align lift_prop_within_at_of_lift_prop_at lift_prop_within_at_of_lift_prop_at\n\n",
 "lift_prop_within_at_mono_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem lift_prop_within_at_mono_of_mem (mono_of_mem : ∀ ⦃s x t⦄ ⦃f : H → H'⦄, s ∈ nhds_within t x → P f s x → P f t x)\n    (h : LiftPropWithinAt P g s x) (hst : s ∈ nhds_within t x) : LiftPropWithinAt P g t x :=\n  by\n  refine' ⟨h.1.mono_of_mem hst, mono_of_mem _ h.2⟩\n  simp_rw [← mem_map, (chart_at H x).symm.map_nhds_within_preimage_eq (mem_chart_target H x),\n    (chart_at H x).left_inv (mem_chart_source H x), hst]\n#align lift_prop_within_at_mono_of_mem lift_prop_within_at_mono_of_mem\n\n",
 "lift_prop_within_at_mono":
 "theorem lift_prop_within_at_mono (mono : ∀ ⦃s x t⦄ ⦃f : H → H'⦄, t ⊆ s → P f s x → P f t x)\n    (h : LiftPropWithinAt P g s x) (hts : t ⊆ s) : LiftPropWithinAt P g t x :=\n  by\n  refine' ⟨h.1.mono hts, _⟩\n  apply mono (fun y hy => _) h.2\n  simp only [mfld_simps] at hy\n  simp only [hy, hts _, mfld_simps]\n#align lift_prop_within_at_mono lift_prop_within_at_mono\n\n",
 "lift_prop_within_at_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem lift_prop_within_at_inter' (ht : t ∈ nhds_within s x) :\n    LiftPropWithinAt P g (s ∩ t) x ↔ LiftPropWithinAt P g s x :=\n  by\n  rw [lift_prop_within_at, lift_prop_within_at, continuousWithinAt_inter' ht, hG.congr_set]\n  simp_rw [eventually_eq_set, mem_preimage,\n    (chart_at H x).eventually_nhds' (fun x => x ∈ s ∩ t ↔ x ∈ s) (mem_chart_source H x)]\n  exact (mem_nhds_within_iff_eventually_eq.mp ht).symm.mem_iff\n#align lift_prop_within_at_inter' lift_prop_within_at_inter'\n\n",
 "lift_prop_within_at_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem lift_prop_within_at_inter (ht : t ∈ (nhds) x) : LiftPropWithinAt P g (s ∩ t) x ↔ LiftPropWithinAt P g s x :=\n  hG.lift_prop_within_at_inter' (mem_nhdsWithin_of_mem_nhds ht)\n#align lift_prop_within_at_inter lift_prop_within_at_inter\n\n",
 "lift_prop_within_at_indep_chart_target_aux2":
 "theorem lift_prop_within_at_indep_chart_target_aux2 (g : H → M') {x : H} {s : Set H} (hf : f ∈ G'.maximal_atlas M')\n    (xf : g x ∈ f.source) (hf' : f' ∈ G'.maximal_atlas M') (xf' : g x ∈ f'.source) (hgs : ContinuousWithinAt g s x) :\n    P (f ∘ g) s x ↔ P (f' ∘ g) s x :=\n  by\n  have hcont : ContinuousWithinAt (f ∘ g) s x := (f.continuous_at xf).comp_continuous_within_at hgs\n  rw [← hG.left_invariance (compatible_of_mem_maximal_atlas hf hf') hcont (by simp only [xf, xf', mfld_simps])]\n  refine' hG.congr_iff_nhds_within _ (by simp only [xf, mfld_simps])\n  exact (hgs.eventually <| f.eventually_left_inverse xf).mono fun y => congr_arg f'\n#align lift_prop_within_at_indep_chart_target_aux2 lift_prop_within_at_indep_chart_target_aux2\n\n",
 "lift_prop_within_at_indep_chart_target_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lift_prop_within_at_indep_chart_target_aux {g : X → M'} {e : LocalHomeomorph X H} {x : X} {s : Set X}\n    (xe : x ∈ e.source) (hf : f ∈ G'.maximal_atlas M') (xf : g x ∈ f.source) (hf' : f' ∈ G'.maximal_atlas M')\n    (xf' : g x ∈ f'.source) (hgs : ContinuousWithinAt g s x) :\n    P (f ∘ g ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) ↔ P (f' ∘ g ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) :=\n  by\n  rw [← e.left_inv xe] at xf xf' hgs\n  refine' hG.lift_prop_within_at_indep_chart_target_aux2 (g ∘ e.symm) hf xf hf' xf' _\n  exact hgs.comp (e.symm.continuous_at <| e.maps_to xe).continuous_within_at subset.rfl\n#align lift_prop_within_at_indep_chart_target_aux lift_prop_within_at_indep_chart_target_aux\n\n",
 "lift_prop_within_at_indep_chart_target":
 "/-- A version of `lift_prop_within_at_indep_chart`, only for the target. -/\ntheorem lift_prop_within_at_indep_chart_target [HasGroupoid M' G'] (hf : f ∈ G'.maximal_atlas M')\n    (xf : g x ∈ f.source) : LiftPropWithinAt P g s x ↔ ContinuousWithinAt g s x ∧ LiftPropWithinAt P (f ∘ g) s x :=\n  by\n  rw [lift_prop_within_at_self_target, lift_prop_within_at, and_congr_right_iff]\n  intro hg\n  simp_rw [(f.continuous_at xf).comp_continuous_within_at hg, true_and_iff]\n  exact\n    hG.lift_prop_within_at_indep_chart_target_aux (mem_chart_source _ _) (chart_mem_maximal_atlas _ _)\n      (mem_chart_source _ _) hf xf hg\n#align lift_prop_within_at_indep_chart_target lift_prop_within_at_indep_chart_target\n\n",
 "lift_prop_within_at_indep_chart_source_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lift_prop_within_at_indep_chart_source_aux (g : M → H') (he : e ∈ G.maximal_atlas M) (xe : x ∈ e.source)\n    (he' : e' ∈ G.maximal_atlas M) (xe' : x ∈ e'.source) :\n    P (g ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) ↔ P (g ∘ e'.symm) («expr ⁻¹' » e'.symm s) (e' x) :=\n  by\n  rw [← hG.right_invariance (compatible_of_mem_maximal_atlas he he')]\n  swap; · simp only [xe, xe', mfld_simps]\n  simp_rw [LocalHomeomorph.trans_apply, e.left_inv xe]\n  rw [hG.congr_iff]\n  · refine' hG.congr_set _\n    refine' (eventually_of_mem _ fun y (hy : y ∈ «expr ⁻¹' » e'.symm e.source) => _).set_eq\n    · refine' (e'.symm.continuous_at <| e'.maps_to xe').preimage_mem_nhds (e.open_source.mem_nhds _)\n      simp_rw [e'.left_inv xe', xe]\n    simp_rw [mem_preimage, LocalHomeomorph.coe_trans_symm, LocalHomeomorph.symm_symm, Function.comp_apply,\n      e.left_inv hy]\n  · refine' ((e'.eventually_nhds' _ xe').mpr <| e.eventually_left_inverse xe).mono fun y hy => _\n    simp only [mfld_simps]\n    rw [hy]\n#align lift_prop_within_at_indep_chart_source_aux lift_prop_within_at_indep_chart_source_aux\n\n",
 "lift_prop_within_at_indep_chart_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- A version of `lift_prop_within_at_indep_chart`, only for the source. -/\ntheorem lift_prop_within_at_indep_chart_source [HasGroupoid M G] (he : e ∈ G.maximal_atlas M) (xe : x ∈ e.source) :\n    LiftPropWithinAt P g s x ↔ LiftPropWithinAt P (g ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) :=\n  by\n  have := e.symm.continuous_within_at_iff_continuous_within_at_comp_right xe\n  rw [e.symm_symm] at this\n  rw [lift_prop_within_at_self_source, lift_prop_within_at, ← this]\n  simp_rw [Function.comp_apply, e.left_inv xe]\n  refine' and_congr iff.rfl _\n  rw [hG.lift_prop_within_at_indep_chart_source_aux (chart_at H' (g x) ∘ g) (chart_mem_maximal_atlas G x)\n      (mem_chart_source H x) he xe]\n#align lift_prop_within_at_indep_chart_source lift_prop_within_at_indep_chart_source\n\n",
 "lift_prop_within_at_indep_chart_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If a property of a germ of function `g` on a pointed set `(s, x)` is invariant under the\nstructure groupoid (by composition in the source space and in the target space), then\nexpressing it in charted spaces does not depend on the element of the maximal atlas one uses\nboth in the source and in the target manifolds, provided they are defined around `x` and `g x`\nrespectively, and provided `g` is continuous within `s` at `x` (otherwise, the local behavior\nof `g` at `x` can not be captured with a chart in the target). -/\ntheorem lift_prop_within_at_indep_chart_aux (he : e ∈ G.maximal_atlas M) (xe : x ∈ e.source)\n    (he' : e' ∈ G.maximal_atlas M) (xe' : x ∈ e'.source) (hf : f ∈ G'.maximal_atlas M') (xf : g x ∈ f.source)\n    (hf' : f' ∈ G'.maximal_atlas M') (xf' : g x ∈ f'.source) (hgs : ContinuousWithinAt g s x) :\n    P (f ∘ g ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) ↔ P (f' ∘ g ∘ e'.symm) («expr ⁻¹' » e'.symm s) (e' x) := by\n  rw [hG.lift_prop_within_at_indep_chart_source_aux (f ∘ g) he xe he' xe',\n    hG.lift_prop_within_at_indep_chart_target_aux xe' hf xf hf' xf' hgs]\n#align lift_prop_within_at_indep_chart_aux lift_prop_within_at_indep_chart_aux\n\n",
 "lift_prop_within_at_indep_chart'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- A version of `lift_prop_within_at_indep_chart`, that uses `lift_prop_within_at` on both sides.\n-/\ntheorem lift_prop_within_at_indep_chart' [HasGroupoid M G] [HasGroupoid M' G'] (he : e ∈ G.maximal_atlas M)\n    (xe : x ∈ e.source) (hf : f ∈ G'.maximal_atlas M') (xf : g x ∈ f.source) :\n    LiftPropWithinAt P g s x ↔\n      ContinuousWithinAt g s x ∧ LiftPropWithinAt P (f ∘ g ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) :=\n  by\n  rw [hG.lift_prop_within_at_indep_chart he xe hf xf, lift_prop_within_at_self, and_left_comm, iff.comm,\n    and_iff_right_iff_imp]\n  intro h\n  have h1 := (e.symm.continuous_within_at_iff_continuous_within_at_comp_right xe).mp h.1\n  have : ContinuousAt f ((g ∘ e.symm) (e x)) := by simp_rw [Function.comp, e.left_inv xe, f.continuous_at xf]\n  exact this.comp_continuous_within_at h1\n#align lift_prop_within_at_indep_chart' lift_prop_within_at_indep_chart'\n\n",
 "lift_prop_within_at_indep_chart":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lift_prop_within_at_indep_chart [HasGroupoid M G] [HasGroupoid M' G'] (he : e ∈ G.maximal_atlas M)\n    (xe : x ∈ e.source) (hf : f ∈ G'.maximal_atlas M') (xf : g x ∈ f.source) :\n    LiftPropWithinAt P g s x ↔ ContinuousWithinAt g s x ∧ P (f ∘ g ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) :=\n  and_congr_right <|\n    hG.lift_prop_within_at_indep_chart_aux (chart_mem_maximalAtlas _ _) (mem_chart_source _ _) he xe\n      (chart_mem_maximalAtlas _ _) (mem_chart_source _ _) hf xf\n#align lift_prop_within_at_indep_chart lift_prop_within_at_indep_chart\n\n",
 "lift_prop_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- `lift_prop_within_at P f s x` is equivalent to a definition where we restrict the set we are\n  considering to the domain of the charts at `x` and `f x`. -/\ntheorem lift_prop_within_at_iff {f : M → M'} :\n    LiftPropWithinAt P f s x ↔\n      ContinuousWithinAt f s x ∧\n        P (chart_at H' (f x) ∘ f ∘ (chart_at H x).symm)\n          ((chart_at H x).target ∩ «expr ⁻¹' » (chart_at H x).symm (s ∩ «expr ⁻¹' » f (chart_at H' (f x)).source))\n          (chart_at H x x) :=\n  by\n  refine' and_congr_right fun hf => hG.congr_set _\n  exact\n    LocalHomeomorph.preimage_eventuallyEq_target_inter_preimage_inter hf (mem_chart_source H x)\n      (chart_source_mem_nhds H' (f x))\n#align lift_prop_within_at_iff lift_prop_within_at_iff\n\n",
 "lift_prop_within_at_congr_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem lift_prop_within_at_congr_of_eventually_eq (h : LiftPropWithinAt P g s x)\n    (h₁ : «expr =ᶠ[ ] » g' (nhds_within s x) g) (hx : g' x = g x) : LiftPropWithinAt P g' s x :=\n  by\n  refine' ⟨h.1.congr_of_eventually_eq h₁ hx, _⟩\n  refine'\n    hG.congr_nhds_within' _ (by simp_rw [Function.comp_apply, (chart_at H x).left_inv (mem_chart_source H x), hx]) h.2\n  simp_rw [eventually_eq, Function.comp_apply,\n    (chart_at H x).eventually_nhds_within' (fun y => chart_at H' (g' x) (g' y) = chart_at H' (g x) (g y))\n      (mem_chart_source H x)]\n  exact h₁.mono fun y hy => by rw [hx, hy]\n#align lift_prop_within_at_congr_of_eventually_eq lift_prop_within_at_congr_of_eventually_eq\n\n",
 "lift_prop_within_at_congr_iff_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem lift_prop_within_at_congr_iff_of_eventually_eq (h₁ : «expr =ᶠ[ ] » g' (nhds_within s x) g) (hx : g' x = g x) :\n    LiftPropWithinAt P g' s x ↔ LiftPropWithinAt P g s x :=\n  ⟨fun h => hG.lift_prop_within_at_congr_of_eventually_eq h h₁.symm hx.symm, fun h =>\n    hG.lift_prop_within_at_congr_of_eventually_eq h h₁ hx⟩\n#align lift_prop_within_at_congr_iff_of_eventually_eq lift_prop_within_at_congr_iff_of_eventually_eq\n\n",
 "lift_prop_within_at_congr_iff":
 "theorem lift_prop_within_at_congr_iff (h₁ : ∀ y ∈ s, g' y = g y) (hx : g' x = g x) :\n    LiftPropWithinAt P g' s x ↔ LiftPropWithinAt P g s x :=\n  hG.lift_prop_within_at_congr_iff_of_eventually_eq (eventually_nhdsWithin_of_forall h₁) hx\n#align lift_prop_within_at_congr_iff lift_prop_within_at_congr_iff\n\n",
 "lift_prop_within_at_congr":
 "theorem lift_prop_within_at_congr (h : LiftPropWithinAt P g s x) (h₁ : ∀ y ∈ s, g' y = g y) (hx : g' x = g x) :\n    LiftPropWithinAt P g' s x :=\n  (hG.lift_prop_within_at_congr_iff h₁ hx).mpr h\n#align lift_prop_within_at_congr lift_prop_within_at_congr\n\n",
 "lift_prop_on_univ":
 "theorem lift_prop_on_univ : LiftPropOn P g univ ↔ LiftProp P g := by simp [lift_prop_on, lift_prop, lift_prop_at]\n#align lift_prop_on_univ lift_prop_on_univ\n\n",
 "lift_prop_on_symm_of_mem_maximal_atlas":
 "theorem lift_prop_on_symm_of_mem_maximal_atlas [HasGroupoid M G] (hG : G.local_invariant_prop G Q)\n    (hQ : ∀ y, Q id univ y) (he : e ∈ maximalAtlas M G) : LiftPropOn Q e.symm e.target :=\n  by\n  intro x hx\n  apply hG.lift_prop_within_at_of_lift_prop_at_of_mem_nhds (hG.lift_prop_at_symm_of_mem_maximal_atlas hQ he hx)\n  exact IsOpen.mem_nhds e.open_target hx\n#align lift_prop_on_symm_of_mem_maximal_atlas lift_prop_on_symm_of_mem_maximal_atlas\n\n",
 "lift_prop_on_of_mem_maximal_atlas":
 "theorem lift_prop_on_of_mem_maximal_atlas [HasGroupoid M G] (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y)\n    (he : e ∈ maximalAtlas M G) : LiftPropOn Q e e.source :=\n  by\n  intro x hx\n  apply hG.lift_prop_within_at_of_lift_prop_at_of_mem_nhds (hG.lift_prop_at_of_mem_maximal_atlas hQ he hx)\n  exact IsOpen.mem_nhds e.open_source hx\n#align lift_prop_on_of_mem_maximal_atlas lift_prop_on_of_mem_maximal_atlas\n\n",
 "lift_prop_on_of_mem_groupoid":
 "theorem lift_prop_on_of_mem_groupoid (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y) {f : LocalHomeomorph H H}\n    (hf : f ∈ G) : LiftPropOn Q f f.source :=\n  liftPropOn_of_mem_maximalAtlas hG hQ (G.mem_maximal_atlas_of_mem_groupoid hf)\n#align lift_prop_on_of_mem_groupoid lift_prop_on_of_mem_groupoid\n\n",
 "lift_prop_on_of_locally_lift_prop_on":
 "theorem lift_prop_on_of_locally_lift_prop_on (h : ∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ LiftPropOn P g (s ∩ u)) :\n    LiftPropOn P g s := by\n  intro x hx\n  rcases h x hx with ⟨u, u_open, xu, hu⟩\n  have := hu x ⟨hx, xu⟩\n  rwa [hG.lift_prop_within_at_inter] at this\n  exact IsOpen.mem_nhds u_open xu\n#align lift_prop_on_of_locally_lift_prop_on lift_prop_on_of_locally_lift_prop_on\n\n",
 "lift_prop_on_of_lift_prop":
 "theorem lift_prop_on_of_lift_prop (mono : ∀ ⦃s x t⦄ ⦃f : H → H'⦄, t ⊆ s → P f s x → P f t x) (h : LiftProp P g) :\n    LiftPropOn P g s := by\n  rw [← lift_prop_on_univ] at h\n  exact lift_prop_on_mono mono h (subset_univ _)\n#align lift_prop_on_of_lift_prop lift_prop_on_of_lift_prop\n\n",
 "lift_prop_on_mono":
 "theorem lift_prop_on_mono (mono : ∀ ⦃s x t⦄ ⦃f : H → H'⦄, t ⊆ s → P f s x → P f t x) (h : LiftPropOn P g t)\n    (hst : s ⊆ t) : LiftPropOn P g s := fun x hx => liftPropWithinAt_mono mono (h x (hst hx)) hst\n#align lift_prop_on_mono lift_prop_on_mono\n\n",
 "lift_prop_on_indep_chart":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lift_prop_on_indep_chart [HasGroupoid M G] [HasGroupoid M' G'] (he : e ∈ G.maximal_atlas M)\n    (hf : f ∈ G'.maximal_atlas M') (h : LiftPropOn P g s) {y : H}\n    (hy : y ∈ e.target ∩ «expr ⁻¹' » e.symm (s ∩ «expr ⁻¹' » g f.source)) :\n    P (f ∘ g ∘ e.symm) («expr ⁻¹' » e.symm s) y :=\n  by\n  convert((hG.lift_prop_within_at_indep_chart he (e.symm_maps_to hy.1) hf hy.2.2).1 (h _ hy.2.1)).2\n  rw [e.right_inv hy.1]\n#align lift_prop_on_indep_chart lift_prop_on_indep_chart\n\n",
 "lift_prop_on_congr_iff":
 "theorem lift_prop_on_congr_iff (h₁ : ∀ y ∈ s, g' y = g y) : LiftPropOn P g' s ↔ LiftPropOn P g s :=\n  ⟨fun h => hG.lift_prop_on_congr h fun y hy => (h₁ y hy).symm, fun h => hG.lift_prop_on_congr h h₁⟩\n#align lift_prop_on_congr_iff lift_prop_on_congr_iff\n\n",
 "lift_prop_on_congr":
 "theorem lift_prop_on_congr (h : LiftPropOn P g s) (h₁ : ∀ y ∈ s, g' y = g y) : LiftPropOn P g' s := fun x hx =>\n  hG.lift_prop_within_at_congr (h x hx) h₁ (h₁ x hx)\n#align lift_prop_on_congr lift_prop_on_congr\n\n",
 "lift_prop_on_chart_symm":
 "theorem lift_prop_on_chart_symm [HasGroupoid M G] (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y) :\n    LiftPropOn Q (chart_at H x).symm (chart_at H x).target :=\n  hG.lift_prop_on_symm_of_mem_maximal_atlas hQ (chart_mem_maximalAtlas G x)\n#align lift_prop_on_chart_symm lift_prop_on_chart_symm\n\n",
 "lift_prop_on_chart":
 "theorem lift_prop_on_chart [HasGroupoid M G] (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y) :\n    LiftPropOn Q (chart_at H x) (chart_at H x).source :=\n  hG.lift_prop_on_of_mem_maximal_atlas hQ (chart_mem_maximalAtlas G x)\n#align lift_prop_on_chart lift_prop_on_chart\n\n",
 "lift_prop_of_locally_lift_prop_on":
 "theorem lift_prop_of_locally_lift_prop_on (h : ∀ x, ∃ u, IsOpen u ∧ x ∈ u ∧ LiftPropOn P g u) : LiftProp P g :=\n  by\n  rw [← lift_prop_on_univ]\n  apply hG.lift_prop_on_of_locally_lift_prop_on fun x hx => _\n  simp [h x]\n#align lift_prop_of_locally_lift_prop_on lift_prop_of_locally_lift_prop_on\n\n",
 "lift_prop_iff":
 "theorem lift_prop_iff {P : (H → H') → Set H → H → Prop} {f : M → M'} :\n    LiftProp P f ↔ Continuous f ∧ ∀ x, P (chart_at H' (f x) ∘ f ∘ (chart_at H x).symm) univ (chart_at H x x) := by\n  simp_rw [lift_prop, lift_prop_at_iff, forall_and, continuous_iff_continuousAt]\n#align lift_prop_iff lift_prop_iff\n\n",
 "lift_prop_id":
 "theorem lift_prop_id (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y) : LiftProp Q (id : M → M) :=\n  by\n  simp_rw [lift_prop_iff, continuous_id, true_and_iff]\n  exact fun x => hG.congr' ((chart_at H x).eventually_right_inverse <| mem_chart_target H x) (hQ _)\n#align lift_prop_id lift_prop_id\n\n",
 "lift_prop_at_symm_of_mem_maximal_atlas":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lift_prop_at_symm_of_mem_maximal_atlas [HasGroupoid M G] {x : H} (hG : G.local_invariant_prop G Q)\n    (hQ : ∀ y, Q id univ y) (he : e ∈ maximalAtlas M G) (hx : x ∈ e.target) : LiftPropAt Q e.symm x :=\n  by\n  suffices h : Q (e ∘ e.symm) univ x\n  · have A : «expr ⁻¹' » e.symm e.source ∩ e.target = e.target := by mfld_set_tac\n    have : e.symm x ∈ e.source := by simp only [hx, mfld_simps]\n    rw [lift_prop_at, hG.lift_prop_within_at_indep_chart G.id_mem_maximal_atlas (mem_univ _) he this]\n    refine' ⟨(e.symm.continuous_at hx).continuous_within_at, _⟩\n    simp only [h, mfld_simps]\n  exact hG.congr' (e.eventually_right_inverse hx) (hQ x)\n#align lift_prop_at_symm_of_mem_maximal_atlas lift_prop_at_symm_of_mem_maximal_atlas\n\n",
 "lift_prop_at_of_mem_maximal_atlas":
 "theorem lift_prop_at_of_mem_maximal_atlas [HasGroupoid M G] (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y)\n    (he : e ∈ maximalAtlas M G) (hx : x ∈ e.source) : LiftPropAt Q e x :=\n  by\n  simp_rw [lift_prop_at, hG.lift_prop_within_at_indep_chart he hx G.id_mem_maximal_atlas (mem_univ _),\n    (e.continuous_at hx).continuous_within_at, true_and_iff]\n  exact hG.congr' (e.eventually_right_inverse' hx) (hQ _)\n#align lift_prop_at_of_mem_maximal_atlas lift_prop_at_of_mem_maximal_atlas\n\n",
 "lift_prop_at_of_mem_groupoid":
 "theorem lift_prop_at_of_mem_groupoid (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y) {f : LocalHomeomorph H H}\n    (hf : f ∈ G) {x : H} (hx : x ∈ f.source) : LiftPropAt Q f x :=\n  liftPropAt_of_mem_maximalAtlas hG hQ (G.mem_maximal_atlas_of_mem_groupoid hf) hx\n#align lift_prop_at_of_mem_groupoid lift_prop_at_of_mem_groupoid\n\n",
 "lift_prop_at_of_lift_prop_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem lift_prop_at_of_lift_prop_within_at (h : LiftPropWithinAt P g s x) (hs : s ∈ (nhds) x) : LiftPropAt P g x := by\n  rwa [← univ_inter s, hG.lift_prop_within_at_inter hs] at h\n#align lift_prop_at_of_lift_prop_within_at lift_prop_at_of_lift_prop_within_at\n\n",
 "lift_prop_at_iff":
 "theorem lift_prop_at_iff {P : (H → H') → Set H → H → Prop} {f : M → M'} {x : M} :\n    LiftPropAt P f x ↔ ContinuousAt f x ∧ P (chart_at H' (f x) ∘ f ∘ (chart_at H x).symm) univ (chart_at H x x) := by\n  rw [lift_prop_at, lift_prop_within_at, continuousWithinAt_univ, preimage_univ]\n#align lift_prop_at_iff lift_prop_at_iff\n\n",
 "lift_prop_at_congr_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem lift_prop_at_congr_of_eventually_eq (h : LiftPropAt P g x) (h₁ : «expr =ᶠ[ ] » g' ((nhds) x) g) :\n    LiftPropAt P g' x :=\n  (hG.lift_prop_at_congr_iff_of_eventually_eq h₁).mpr h\n#align lift_prop_at_congr_of_eventually_eq lift_prop_at_congr_of_eventually_eq\n\n",
 "lift_prop_at_congr_iff_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem lift_prop_at_congr_iff_of_eventually_eq (h₁ : «expr =ᶠ[ ] » g' ((nhds) x) g) :\n    LiftPropAt P g' x ↔ LiftPropAt P g x :=\n  hG.lift_prop_within_at_congr_iff_of_eventually_eq (by simp_rw [nhdsWithin_univ, h₁]) h₁.eq_of_nhds\n#align lift_prop_at_congr_iff_of_eventually_eq lift_prop_at_congr_iff_of_eventually_eq\n\n",
 "lift_prop_at_chart_symm":
 "theorem lift_prop_at_chart_symm [HasGroupoid M G] (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y) :\n    LiftPropAt Q (chart_at H x).symm ((chart_at H x) x) :=\n  hG.lift_prop_at_symm_of_mem_maximal_atlas hQ (chart_mem_maximalAtlas G x) (by simp)\n#align lift_prop_at_chart_symm lift_prop_at_chart_symm\n\n",
 "lift_prop_at_chart":
 "theorem lift_prop_at_chart [HasGroupoid M G] (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y) :\n    LiftPropAt Q (chart_at H x) x :=\n  hG.lift_prop_at_of_mem_maximal_atlas hQ (chart_mem_maximalAtlas G x) (mem_chart_source H x)\n#align lift_prop_at_chart lift_prop_at_chart\n\n",
 "left_invariance":
 "theorem left_invariance {s : Set H} {x : H} {f : H → H'} {e' : LocalHomeomorph H' H'} (he' : e' ∈ G')\n    (hfs : ContinuousWithinAt f s x) (hxe' : f x ∈ e'.source) : P (e' ∘ f) s x ↔ P f s x :=\n  by\n  have h2f := hfs.preimage_mem_nhds_within (e'.open_source.mem_nhds hxe')\n  have h3f :=\n    ((e'.continuous_at hxe').comp_continuous_within_at hfs).preimage_mem_nhds_within <|\n      e'.symm.open_source.mem_nhds <| e'.maps_to hxe'\n  constructor\n  · intro h\n    rw [hG.is_local_nhds h3f] at h\n    have h2 := hG.left_invariance' (G'.symm he') (inter_subset_right _ _) (e'.maps_to hxe') h\n    rw [← hG.is_local_nhds h3f] at h2\n    refine' hG.congr_nhds_within _ (e'.left_inv hxe') h2\n    exact eventually_of_mem h2f fun x' => e'.left_inv\n  · simp_rw [hG.is_local_nhds h2f]\n    exact hG.left_invariance' he' (inter_subset_right _ _) hxe'\n#align left_invariance left_invariance\n\n",
 "is_local_structomorph_within_at_source_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print LocalHomeomorph.isLocalStructomorphWithinAt_source_iff /-\n/-- A slight reformulation of `is_local_structomorph_within_at` when `f` is a local homeomorph and\n  the set we're considering is `f.source`. -/\ntheorem LocalHomeomorph.isLocalStructomorphWithinAt_source_iff {G : StructureGroupoid H} [ClosedUnderRestriction G]\n    (f : LocalHomeomorph H H) {x : H} :\n    G.is_local_structomorph_within_at («expr⇑ » f) f.source x ↔\n      x ∈ f.source →\n        ∃ e : LocalHomeomorph H H, e ∈ G ∧ e.source ⊆ f.source ∧ EqOn f («expr⇑ » e) e.source ∧ x ∈ e.source :=\n  haveI : x ∈ f.source ∪ «expr ᶜ» f.source := by simp_rw [union_compl_self]\n  f.is_local_structomorph_within_at_iff' subset.rfl this\n#align local_homeomorph.is_local_structomorph_within_at_source_iff LocalHomeomorph.isLocalStructomorphWithinAt_source_iff\n-/\n\n",
 "is_local_structomorph_within_at_local_invariant_prop":
 "/-- For a groupoid `G` which is `closed_under_restriction`, being a local structomorphism is a local\ninvariant property. -/\ntheorem is_local_structomorph_within_at_local_invariant_prop [ClosedUnderRestriction G] :\n    LocalInvariantProp G G (IsLocalStructomorphWithinAt G) :=\n  { is_local := by\n      intro s x u f hu hux\n      constructor\n      · rintro h hx\n        rcases h hx.1 with ⟨e, heG, hef, hex⟩\n        have : s ∩ u ∩ e.source ⊆ s ∩ e.source := by mfld_set_tac\n        exact ⟨e, heG, hef.mono this, hex⟩\n      · rintro h hx\n        rcases h ⟨hx, hux⟩ with ⟨e, heG, hef, hex⟩\n        refine' ⟨e.restr (interior u), _, _, _⟩\n        · exact closedUnderRestriction' heG isOpen_interior\n        · have : s ∩ u ∩ e.source = s ∩ (e.source ∩ u) := by mfld_set_tac\n          simpa only [this, interior_interior, hu.interior_eq, mfld_simps] using hef\n        · simp only [*, interior_interior, hu.interior_eq, mfld_simps]\n    right_invariance' := by\n      intro s x f e' he'G he'x h hx\n      have hxs : x ∈ s := by simpa only [e'.left_inv he'x, mfld_simps] using hx\n      rcases h hxs with ⟨e, heG, hef, hex⟩\n      refine' ⟨e'.symm.trans e, G.trans (G.symm he'G) heG, _, _⟩\n      · intro y hy\n        simp only [mfld_simps] at hy\n        simp only [hef ⟨hy.1, hy.2.2⟩, mfld_simps]\n      · simp only [hex, he'x, mfld_simps]\n    congr_of_forall := by\n      intro s x f g hfgs hfg' h hx\n      rcases h hx with ⟨e, heG, hef, hex⟩\n      refine' ⟨e, heG, _, hex⟩\n      intro y hy\n      rw [← hef hy, hfgs y hy.1]\n    left_invariance' := by\n      intro s x f e' he'G he' hfx h hx\n      rcases h hx with ⟨e, heG, hef, hex⟩\n      refine' ⟨e.trans e', G.trans heG he'G, _, _⟩\n      · intro y hy\n        simp only [mfld_simps] at hy\n        simp only [hef ⟨hy.1, hy.2.1⟩, mfld_simps]\n      · simpa only [hex, hef ⟨hx, hex⟩, mfld_simps] using hfx }\n#align is_local_structomorph_within_at_local_invariant_prop is_local_structomorph_within_at_local_invariant_prop\n\n",
 "is_local_structomorph_within_at_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print LocalHomeomorph.isLocalStructomorphWithinAt_iff' /-\n/-- A slight reformulation of `is_local_structomorph_within_at` when `f` is a local homeomorph and\n  the set we're considering is a superset of `f.source`. -/\ntheorem LocalHomeomorph.isLocalStructomorphWithinAt_iff' {G : StructureGroupoid H} [ClosedUnderRestriction G]\n    (f : LocalHomeomorph H H) {s : Set H} {x : H} (hs : f.source ⊆ s) (hx : x ∈ f.source ∪ «expr ᶜ» s) :\n    G.is_local_structomorph_within_at («expr⇑ » f) s x ↔\n      x ∈ s → ∃ e : LocalHomeomorph H H, e ∈ G ∧ e.source ⊆ f.source ∧ EqOn f («expr⇑ » e) e.source ∧ x ∈ e.source :=\n  by\n  simp_rw [f.is_local_structomorph_within_at_iff hx]\n  refine' imp_congr_right fun hx => exists_congr fun e => and_congr_right fun he => _\n  refine' and_congr_right fun h2e => _\n  rw [inter_eq_right_iff_subset.mpr (h2e.trans hs)]\n#align local_homeomorph.is_local_structomorph_within_at_iff' LocalHomeomorph.isLocalStructomorphWithinAt_iff'\n-/\n\n",
 "is_local_structomorph_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print LocalHomeomorph.isLocalStructomorphWithinAt_iff /-\n/-- A slight reformulation of `is_local_structomorph_within_at` when `f` is a local homeomorph.\n  This gives us an `e` that is defined on a subset of `f.source`. -/\ntheorem LocalHomeomorph.isLocalStructomorphWithinAt_iff {G : StructureGroupoid H} [ClosedUnderRestriction G]\n    (f : LocalHomeomorph H H) {s : Set H} {x : H} (hx : x ∈ f.source ∪ «expr ᶜ» s) :\n    G.is_local_structomorph_within_at («expr⇑ » f) s x ↔\n      x ∈ s →\n        ∃ e : LocalHomeomorph H H, e ∈ G ∧ e.source ⊆ f.source ∧ EqOn f («expr⇑ » e) (s ∩ e.source) ∧ x ∈ e.source :=\n  by\n  constructor\n  · intro hf h2x\n    obtain ⟨e, he, hfe, hxe⟩ := hf h2x\n    refine' ⟨e.restr f.source, closedUnderRestriction' he f.open_source, _, _, hxe, _⟩\n    · simp_rw [local_homeomorph.restr_source]\n      refine' (inter_subset_right _ _).trans interior_subset\n    · intro x' hx'\n      exact hfe ⟨hx'.1, hx'.2.1⟩\n    · rw [f.open_source.interior_eq]\n      exact or.resolve_right hx (not_not.mpr h2x)\n  · intro hf hx\n    obtain ⟨e, he, h2e, hfe, hxe⟩ := hf hx\n    exact ⟨e, he, hfe, hxe⟩\n#align local_homeomorph.is_local_structomorph_within_at_iff LocalHomeomorph.isLocalStructomorphWithinAt_iff\n-/\n\n",
 "is_local_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem is_local_nhds {s u : Set H} {x : H} {f : H → H'} (hu : u ∈ nhds_within s x) : P f s x ↔ P f (s ∩ u) x :=\n  hG.congr_set <| mem_nhdsWithin_iff_eventuallyEq.mp hu\n#align is_local_nhds is_local_nhds\n\n",
 "congr_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-\nCopyright (c) 2020 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel, Floris van Doorn\n-/\ntheorem congr_set {s t : Set H} {x : H} {f : H → H'} (hu : «expr =ᶠ[ ] » s ((nhds) x) t) : P f s x ↔ P f t x :=\n  by\n  obtain ⟨o, host, ho, hxo⟩ := mem_nhds_iff.mp hu.mem_iff\n  simp_rw [subset_def, mem_set_of, ← and_congr_left_iff, ← mem_inter_iff, ← Set.ext_iff] at host\n  rw [hG.is_local ho hxo, host, ← hG.is_local ho hxo]\n#align congr_set congr_set\n\n",
 "congr_nhds_within'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem congr_nhds_within' {s : Set H} {x : H} {f g : H → H'} (h1 : «expr =ᶠ[ ] » f (nhds_within s x) g)\n    (h2 : f x = g x) (hP : P g s x) : P f s x :=\n  (hG.congr_iff_nhds_within h1 h2).mpr hP\n#align congr_nhds_within' congr_nhds_within'\n\n",
 "congr_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem congr_nhds_within {s : Set H} {x : H} {f g : H → H'} (h1 : «expr =ᶠ[ ] » f (nhds_within s x) g) (h2 : f x = g x)\n    (hP : P f s x) : P g s x :=\n  (hG.congr_iff_nhds_within h1 h2).mp hP\n#align congr_nhds_within congr_nhds_within\n\n",
 "congr_iff_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem congr_iff_nhds_within {s : Set H} {x : H} {f g : H → H'} (h1 : «expr =ᶠ[ ] » f (nhds_within s x) g)\n    (h2 : f x = g x) : P f s x ↔ P g s x := by\n  simp_rw [hG.is_local_nhds h1]\n  exact ⟨hG.congr_of_forall (fun y hy => hy.2) h2, hG.congr_of_forall (fun y hy => hy.2.symm) h2.symm⟩\n#align congr_iff_nhds_within congr_iff_nhds_within\n\n",
 "congr_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem congr_iff {s : Set H} {x : H} {f g : H → H'} (h : «expr =ᶠ[ ] » f ((nhds) x) g) : P f s x ↔ P g s x :=\n  hG.congr_iff_nhds_within (mem_nhdsWithin_of_mem_nhds h) (mem_of_mem_nhds h : _)\n#align congr_iff congr_iff\n\n",
 "congr'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem congr' {s : Set H} {x : H} {f g : H → H'} (h : «expr =ᶠ[ ] » f ((nhds) x) g) (hP : P g s x) : P f s x :=\n  hG.congr h.symm hP\n#align congr' congr'\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print congr /-\ntheorem congr {s : Set H} {x : H} {f g : H → H'} (h : «expr =ᶠ[ ] » f ((nhds) x) g) (hP : P f s x) : P g s x :=\n  (hG.congr_iff h).mp hP\n#align congr congr\n-/\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\ntheorem has_groupoid.comp (H : ∀ e ∈ G₂, LiftPropOn (IsLocalStructomorphWithinAt G₁) (e : H₂ → H₂) e.source) :\n    @HasGroupoid H₁ _ H₃ _ (ChartedSpace.comp H₁ H₂ H₃) G₁ :=\n  {\n    compatible := by\n      rintro _ _ ⟨e, f, he, hf, rfl⟩ ⟨e', f', he', hf', rfl⟩\n      apply G₁.locality\n      intro x hx\n      simp only [mfld_simps] at hx\n      have hxs : x ∈ «expr ⁻¹' » f.symm (local_homeomorph.trans e.symm e').source := by simp only [hx, mfld_simps]\n      have hxs' :\n        x ∈\n          f.target ∩\n            «expr ⁻¹' » f.symm\n              ((local_homeomorph.trans e.symm e').source ∩ «expr ⁻¹' » (local_homeomorph.trans e.symm e') f'.source) :=\n        by simp only [hx, mfld_simps]\n      obtain ⟨φ, hφG₁, hφ, hφ_dom⟩ :=\n        local_invariant_prop.lift_prop_on_indep_chart (is_local_structomorph_within_at_local_invariant_prop G₁)\n          (G₁.subset_maximal_atlas hf) (G₁.subset_maximal_atlas hf') (H _ (G₂.compatible he he')) hxs' hxs\n      simp_rw [← LocalHomeomorph.coe_trans, LocalHomeomorph.trans_assoc] at hφ\n      simp_rw [LocalHomeomorph.trans_symm_eq_symm_trans_symm, LocalHomeomorph.trans_assoc]\n      have hs :\n        IsOpen (local_homeomorph.trans f.symm (local_homeomorph.trans e.symm (local_homeomorph.trans e' f'))).source :=\n        (local_homeomorph.trans f.symm (local_homeomorph.trans e.symm (local_homeomorph.trans e' f'))).open_source\n      refine' ⟨_, hs.inter φ.open_source, _, _⟩\n      · simp only [hx, hφ_dom, mfld_simps]\n      · refine' G₁.eq_on_source (closedUnderRestriction' hφG₁ hs) _\n        rw [LocalHomeomorph.restr_source_inter]\n        refine' (hφ.mono _).restr_eq_on_source\n        mfld_set_tac }\n#align has_groupoid.comp has_groupoid.comp\n\n"}