{"right_invariance":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem right_invariance {s : set H} {x : H} {f : H → H'} {e : local_homeomorph H H} (he : e ∈ G) (hxe : x ∈ e.source) :\n    P (f ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) ↔ P f s x :=\n  by\n  refine' ⟨fun h => _, hG.right_invariance' he hxe⟩\n  have := hG.right_invariance' (G.symm he) (e.maps_to hxe) h\n  rw [e.symm_symm, e.left_inv hxe] at this\n  refine' hG.congr _ ((hG.congr_set _).mp this)\n  · refine' eventually_of_mem (e.open_source.mem_nhds hxe) fun x' hx' => _\n    simp_rw [function.comp_apply, e.left_inv hx']\n  · rw [eventually_eq_set]\n    refine' eventually_of_mem (e.open_source.mem_nhds hxe) fun x' hx' => _\n    simp_rw [mem_preimage, e.left_inv hx']\n#align right_invariance right_invariance\n\n",
 "lift_prop_within_at_univ":
 "theorem lift_prop_within_at_univ : lift_prop_within_at P g univ x ↔ lift_prop_at P g x :=\n  iff.rfl\n#align lift_prop_within_at_univ lift_prop_within_at_univ\n\n",
 "lift_prop_within_at_self_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lift_prop_within_at_self_target {f : M → H'} :\n    lift_prop_within_at P f s x ↔\n      continuous_within_at f s x ∧ P (f ∘ (chart_at H x).symm) («expr ⁻¹' » (chart_at H x).symm s) (chart_at H x x) :=\n  iff.rfl\n#align lift_prop_within_at_self_target lift_prop_within_at_self_target\n\n",
 "lift_prop_within_at_self_source":
 "theorem lift_prop_within_at_self_source {f : H → M'} {s : set H} {x : H} :\n    lift_prop_within_at P f s x ↔ continuous_within_at f s x ∧ P (chart_at H' (f x) ∘ f) s x :=\n  iff.rfl\n#align lift_prop_within_at_self_source lift_prop_within_at_self_source\n\n",
 "lift_prop_within_at_self":
 "theorem lift_prop_within_at_self {f : H → H'} {s : set H} {x : H} :\n    lift_prop_within_at P f s x ↔ continuous_within_at f s x ∧ P f s x :=\n  iff.rfl\n#align lift_prop_within_at_self lift_prop_within_at_self\n\n",
 "lift_prop_within_at_of_lift_prop_at_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem lift_prop_within_at_of_lift_prop_at_of_mem_nhds (h : lift_prop_at P g x) (hs : s ∈ (nhds) x) :\n    lift_prop_within_at P g s x := by rwa [← univ_inter s, hG.lift_prop_within_at_inter hs]\n#align lift_prop_within_at_of_lift_prop_at_of_mem_nhds lift_prop_within_at_of_lift_prop_at_of_mem_nhds\n\n",
 "lift_prop_within_at_of_lift_prop_at":
 "theorem lift_prop_within_at_of_lift_prop_at (mono : ∀ ⦃s x t⦄ ⦃f : H → H'⦄, t ⊆ s → P f s x → P f t x)\n    (h : lift_prop_at P g x) : lift_prop_within_at P g s x :=\n  by\n  rw [← lift_prop_within_at_univ] at h\n  exact lift_prop_within_at_mono mono h (subset_univ _)\n#align lift_prop_within_at_of_lift_prop_at lift_prop_within_at_of_lift_prop_at\n\n",
 "lift_prop_within_at_mono_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem lift_prop_within_at_mono_of_mem (mono_of_mem : ∀ ⦃s x t⦄ ⦃f : H → H'⦄, s ∈ nhds_within t x → P f s x → P f t x)\n    (h : lift_prop_within_at P g s x) (hst : s ∈ nhds_within t x) : lift_prop_within_at P g t x :=\n  by\n  refine' ⟨h.1.mono_of_mem hst, mono_of_mem _ h.2⟩\n  simp_rw [← mem_map, (chart_at H x).symm.map_nhds_within_preimage_eq (mem_chart_target H x),\n    (chart_at H x).left_inv (mem_chart_source H x), hst]\n#align lift_prop_within_at_mono_of_mem lift_prop_within_at_mono_of_mem\n\n",
 "lift_prop_within_at_mono":
 "theorem lift_prop_within_at_mono (mono : ∀ ⦃s x t⦄ ⦃f : H → H'⦄, t ⊆ s → P f s x → P f t x)\n    (h : lift_prop_within_at P g s x) (hts : t ⊆ s) : lift_prop_within_at P g t x :=\n  by\n  refine' ⟨h.1.mono hts, _⟩\n  apply mono (fun y hy => _) h.2\n  simp only [mfld_simps] at hy\n  simp only [hy, hts _, mfld_simps]\n#align lift_prop_within_at_mono lift_prop_within_at_mono\n\n",
 "lift_prop_within_at_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem lift_prop_within_at_inter' (ht : t ∈ nhds_within s x) :\n    lift_prop_within_at P g (s ∩ t) x ↔ lift_prop_within_at P g s x :=\n  by\n  rw [lift_prop_within_at, lift_prop_within_at, continuous_within_at_inter' ht, hG.congr_set]\n  simp_rw [eventually_eq_set, mem_preimage,\n    (chart_at H x).eventually_nhds' (fun x => x ∈ s ∩ t ↔ x ∈ s) (mem_chart_source H x)]\n  exact (mem_nhds_within_iff_eventually_eq.mp ht).symm.mem_iff\n#align lift_prop_within_at_inter' lift_prop_within_at_inter'\n\n",
 "lift_prop_within_at_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem lift_prop_within_at_inter (ht : t ∈ (nhds) x) :\n    lift_prop_within_at P g (s ∩ t) x ↔ lift_prop_within_at P g s x :=\n  hG.lift_prop_within_at_inter' (mem_nhds_within_of_mem_nhds ht)\n#align lift_prop_within_at_inter lift_prop_within_at_inter\n\n",
 "lift_prop_within_at_indep_chart_target_aux2":
 "theorem lift_prop_within_at_indep_chart_target_aux2 (g : H → M') {x : H} {s : set H} (hf : f ∈ G'.maximal_atlas M')\n    (xf : g x ∈ f.source) (hf' : f' ∈ G'.maximal_atlas M') (xf' : g x ∈ f'.source) (hgs : continuous_within_at g s x) :\n    P (f ∘ g) s x ↔ P (f' ∘ g) s x :=\n  by\n  have hcont : continuous_within_at (f ∘ g) s x := (f.continuous_at xf).comp_continuous_within_at hgs\n  rw [← hG.left_invariance (compatible_of_mem_maximal_atlas hf hf') hcont (by simp only [xf, xf', mfld_simps])]\n  refine' hG.congr_iff_nhds_within _ (by simp only [xf, mfld_simps])\n  exact (hgs.eventually <| f.eventually_left_inverse xf).mono fun y => congr_arg f'\n#align lift_prop_within_at_indep_chart_target_aux2 lift_prop_within_at_indep_chart_target_aux2\n\n",
 "lift_prop_within_at_indep_chart_target_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lift_prop_within_at_indep_chart_target_aux {g : X → M'} {e : local_homeomorph X H} {x : X} {s : set X}\n    (xe : x ∈ e.source) (hf : f ∈ G'.maximal_atlas M') (xf : g x ∈ f.source) (hf' : f' ∈ G'.maximal_atlas M')\n    (xf' : g x ∈ f'.source) (hgs : continuous_within_at g s x) :\n    P (f ∘ g ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) ↔ P (f' ∘ g ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) :=\n  by\n  rw [← e.left_inv xe] at xf xf' hgs\n  refine' hG.lift_prop_within_at_indep_chart_target_aux2 (g ∘ e.symm) hf xf hf' xf' _\n  exact hgs.comp (e.symm.continuous_at <| e.maps_to xe).continuous_within_at subset.rfl\n#align lift_prop_within_at_indep_chart_target_aux lift_prop_within_at_indep_chart_target_aux\n\n",
 "lift_prop_within_at_indep_chart_target":
 "/-- A version of `lift_prop_within_at_indep_chart`, only for the target. -/\ntheorem lift_prop_within_at_indep_chart_target [has_groupoid M' G'] (hf : f ∈ G'.maximal_atlas M')\n    (xf : g x ∈ f.source) :\n    lift_prop_within_at P g s x ↔ continuous_within_at g s x ∧ lift_prop_within_at P (f ∘ g) s x :=\n  by\n  rw [lift_prop_within_at_self_target, lift_prop_within_at, and_congr_right_iff]\n  intro hg\n  simp_rw [(f.continuous_at xf).comp_continuous_within_at hg, true_and_iff]\n  exact\n    hG.lift_prop_within_at_indep_chart_target_aux (mem_chart_source _ _) (chart_mem_maximal_atlas _ _)\n      (mem_chart_source _ _) hf xf hg\n#align lift_prop_within_at_indep_chart_target lift_prop_within_at_indep_chart_target\n\n",
 "lift_prop_within_at_indep_chart_source_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lift_prop_within_at_indep_chart_source_aux (g : M → H') (he : e ∈ G.maximal_atlas M) (xe : x ∈ e.source)\n    (he' : e' ∈ G.maximal_atlas M) (xe' : x ∈ e'.source) :\n    P (g ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) ↔ P (g ∘ e'.symm) («expr ⁻¹' » e'.symm s) (e' x) :=\n  by\n  rw [← hG.right_invariance (compatible_of_mem_maximal_atlas he he')]\n  swap; · simp only [xe, xe', mfld_simps]\n  simp_rw [local_homeomorph.trans_apply, e.left_inv xe]\n  rw [hG.congr_iff]\n  · refine' hG.congr_set _\n    refine' (eventually_of_mem _ fun y (hy : y ∈ «expr ⁻¹' » e'.symm e.source) => _).set_eq\n    · refine' (e'.symm.continuous_at <| e'.maps_to xe').preimage_mem_nhds (e.open_source.mem_nhds _)\n      simp_rw [e'.left_inv xe', xe]\n    simp_rw [mem_preimage, local_homeomorph.coe_trans_symm, local_homeomorph.symm_symm, function.comp_apply,\n      e.left_inv hy]\n  · refine' ((e'.eventually_nhds' _ xe').mpr <| e.eventually_left_inverse xe).mono fun y hy => _\n    simp only [mfld_simps]\n    rw [hy]\n#align lift_prop_within_at_indep_chart_source_aux lift_prop_within_at_indep_chart_source_aux\n\n",
 "lift_prop_within_at_indep_chart_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- A version of `lift_prop_within_at_indep_chart`, only for the source. -/\ntheorem lift_prop_within_at_indep_chart_source [has_groupoid M G] (he : e ∈ G.maximal_atlas M) (xe : x ∈ e.source) :\n    lift_prop_within_at P g s x ↔ lift_prop_within_at P (g ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) :=\n  by\n  have := e.symm.continuous_within_at_iff_continuous_within_at_comp_right xe\n  rw [e.symm_symm] at this\n  rw [lift_prop_within_at_self_source, lift_prop_within_at, ← this]\n  simp_rw [Function.comp_apply, e.left_inv xe]\n  refine' and_congr iff.rfl _\n  rw [hG.lift_prop_within_at_indep_chart_source_aux (chart_at H' (g x) ∘ g) (chart_mem_maximal_atlas G x)\n      (mem_chart_source H x) he xe]\n#align lift_prop_within_at_indep_chart_source lift_prop_within_at_indep_chart_source\n\n",
 "lift_prop_within_at_indep_chart_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If a property of a germ of function `g` on a pointed set `(s, x)` is invariant under the\nstructure groupoid (by composition in the source space and in the target space), then\nexpressing it in charted spaces does not depend on the element of the maximal atlas one uses\nboth in the source and in the target manifolds, provided they are defined around `x` and `g x`\nrespectively, and provided `g` is continuous within `s` at `x` (otherwise, the local behavior\nof `g` at `x` can not be captured with a chart in the target). -/\ntheorem lift_prop_within_at_indep_chart_aux (he : e ∈ G.maximal_atlas M) (xe : x ∈ e.source)\n    (he' : e' ∈ G.maximal_atlas M) (xe' : x ∈ e'.source) (hf : f ∈ G'.maximal_atlas M') (xf : g x ∈ f.source)\n    (hf' : f' ∈ G'.maximal_atlas M') (xf' : g x ∈ f'.source) (hgs : continuous_within_at g s x) :\n    P (f ∘ g ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) ↔ P (f' ∘ g ∘ e'.symm) («expr ⁻¹' » e'.symm s) (e' x) := by\n  rw [hG.lift_prop_within_at_indep_chart_source_aux (f ∘ g) he xe he' xe',\n    hG.lift_prop_within_at_indep_chart_target_aux xe' hf xf hf' xf' hgs]\n#align lift_prop_within_at_indep_chart_aux lift_prop_within_at_indep_chart_aux\n\n",
 "lift_prop_within_at_indep_chart'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- A version of `lift_prop_within_at_indep_chart`, that uses `lift_prop_within_at` on both sides.\n-/\ntheorem lift_prop_within_at_indep_chart' [has_groupoid M G] [has_groupoid M' G'] (he : e ∈ G.maximal_atlas M)\n    (xe : x ∈ e.source) (hf : f ∈ G'.maximal_atlas M') (xf : g x ∈ f.source) :\n    lift_prop_within_at P g s x ↔\n      continuous_within_at g s x ∧ lift_prop_within_at P (f ∘ g ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) :=\n  by\n  rw [hG.lift_prop_within_at_indep_chart he xe hf xf, lift_prop_within_at_self, and_left_comm, iff.comm,\n    and_iff_right_iff_imp]\n  intro h\n  have h1 := (e.symm.continuous_within_at_iff_continuous_within_at_comp_right xe).mp h.1\n  have : continuous_at f ((g ∘ e.symm) (e x)) := by simp_rw [function.comp, e.left_inv xe, f.continuous_at xf]\n  exact this.comp_continuous_within_at h1\n#align lift_prop_within_at_indep_chart' lift_prop_within_at_indep_chart'\n\n",
 "lift_prop_within_at_indep_chart":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lift_prop_within_at_indep_chart [has_groupoid M G] [has_groupoid M' G'] (he : e ∈ G.maximal_atlas M)\n    (xe : x ∈ e.source) (hf : f ∈ G'.maximal_atlas M') (xf : g x ∈ f.source) :\n    lift_prop_within_at P g s x ↔ continuous_within_at g s x ∧ P (f ∘ g ∘ e.symm) («expr ⁻¹' » e.symm s) (e x) :=\n  and_congr_right <|\n    hG.lift_prop_within_at_indep_chart_aux (chart_mem_maximal_atlas _ _) (mem_chart_source _ _) he xe\n      (chart_mem_maximal_atlas _ _) (mem_chart_source _ _) hf xf\n#align lift_prop_within_at_indep_chart lift_prop_within_at_indep_chart\n\n",
 "lift_prop_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- `lift_prop_within_at P f s x` is equivalent to a definition where we restrict the set we are\n  considering to the domain of the charts at `x` and `f x`. -/\ntheorem lift_prop_within_at_iff {f : M → M'} :\n    lift_prop_within_at P f s x ↔\n      continuous_within_at f s x ∧\n        P (chart_at H' (f x) ∘ f ∘ (chart_at H x).symm)\n          ((chart_at H x).target ∩ «expr ⁻¹' » (chart_at H x).symm (s ∩ «expr ⁻¹' » f (chart_at H' (f x)).source))\n          (chart_at H x x) :=\n  by\n  refine' and_congr_right fun hf => hG.congr_set _\n  exact\n    local_homeomorph.preimage_eventually_eq_target_inter_preimage_inter hf (mem_chart_source H x)\n      (chart_source_mem_nhds H' (f x))\n#align lift_prop_within_at_iff lift_prop_within_at_iff\n\n",
 "lift_prop_within_at_congr_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem lift_prop_within_at_congr_of_eventually_eq (h : lift_prop_within_at P g s x)\n    (h₁ : «expr =ᶠ[ ] » g' (nhds_within s x) g) (hx : g' x = g x) : lift_prop_within_at P g' s x :=\n  by\n  refine' ⟨h.1.congr_of_eventually_eq h₁ hx, _⟩\n  refine'\n    hG.congr_nhds_within' _ (by simp_rw [function.comp_apply, (chart_at H x).left_inv (mem_chart_source H x), hx]) h.2\n  simp_rw [eventually_eq, Function.comp_apply,\n    (chart_at H x).eventually_nhds_within' (fun y => chart_at H' (g' x) (g' y) = chart_at H' (g x) (g y))\n      (mem_chart_source H x)]\n  exact h₁.mono fun y hy => by rw [hx, hy]\n#align lift_prop_within_at_congr_of_eventually_eq lift_prop_within_at_congr_of_eventually_eq\n\n",
 "lift_prop_within_at_congr_iff_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem lift_prop_within_at_congr_iff_of_eventually_eq (h₁ : «expr =ᶠ[ ] » g' (nhds_within s x) g) (hx : g' x = g x) :\n    lift_prop_within_at P g' s x ↔ lift_prop_within_at P g s x :=\n  ⟨fun h => hG.lift_prop_within_at_congr_of_eventually_eq h h₁.symm hx.symm, fun h =>\n    hG.lift_prop_within_at_congr_of_eventually_eq h h₁ hx⟩\n#align lift_prop_within_at_congr_iff_of_eventually_eq lift_prop_within_at_congr_iff_of_eventually_eq\n\n",
 "lift_prop_within_at_congr_iff":
 "theorem lift_prop_within_at_congr_iff (h₁ : ∀ y ∈ s, g' y = g y) (hx : g' x = g x) :\n    lift_prop_within_at P g' s x ↔ lift_prop_within_at P g s x :=\n  hG.lift_prop_within_at_congr_iff_of_eventually_eq (eventually_nhds_within_of_forall h₁) hx\n#align lift_prop_within_at_congr_iff lift_prop_within_at_congr_iff\n\n",
 "lift_prop_within_at_congr":
 "theorem lift_prop_within_at_congr (h : lift_prop_within_at P g s x) (h₁ : ∀ y ∈ s, g' y = g y) (hx : g' x = g x) :\n    lift_prop_within_at P g' s x :=\n  (hG.lift_prop_within_at_congr_iff h₁ hx).mpr h\n#align lift_prop_within_at_congr lift_prop_within_at_congr\n\n",
 "lift_prop_on_univ":
 "theorem lift_prop_on_univ : lift_prop_on P g univ ↔ lift_prop P g := by simp [lift_prop_on, lift_prop, lift_prop_at]\n#align lift_prop_on_univ lift_prop_on_univ\n\n",
 "lift_prop_on_symm_of_mem_maximal_atlas":
 "theorem lift_prop_on_symm_of_mem_maximal_atlas [has_groupoid M G] (hG : G.local_invariant_prop G Q)\n    (hQ : ∀ y, Q id univ y) (he : e ∈ maximal_atlas M G) : lift_prop_on Q e.symm e.target :=\n  by\n  intro x hx\n  apply hG.lift_prop_within_at_of_lift_prop_at_of_mem_nhds (hG.lift_prop_at_symm_of_mem_maximal_atlas hQ he hx)\n  exact is_open.mem_nhds e.open_target hx\n#align lift_prop_on_symm_of_mem_maximal_atlas lift_prop_on_symm_of_mem_maximal_atlas\n\n",
 "lift_prop_on_of_mem_maximal_atlas":
 "theorem lift_prop_on_of_mem_maximal_atlas [has_groupoid M G] (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y)\n    (he : e ∈ maximal_atlas M G) : lift_prop_on Q e e.source :=\n  by\n  intro x hx\n  apply hG.lift_prop_within_at_of_lift_prop_at_of_mem_nhds (hG.lift_prop_at_of_mem_maximal_atlas hQ he hx)\n  exact is_open.mem_nhds e.open_source hx\n#align lift_prop_on_of_mem_maximal_atlas lift_prop_on_of_mem_maximal_atlas\n\n",
 "lift_prop_on_of_locally_lift_prop_on":
 "theorem lift_prop_on_of_locally_lift_prop_on (h : ∀ x ∈ s, ∃ u, is_open u ∧ x ∈ u ∧ lift_prop_on P g (s ∩ u)) :\n    lift_prop_on P g s := by\n  intro x hx\n  rcases h x hx with ⟨u, u_open, xu, hu⟩\n  have := hu x ⟨hx, xu⟩\n  rwa [hG.lift_prop_within_at_inter] at this\n  exact is_open.mem_nhds u_open xu\n#align lift_prop_on_of_locally_lift_prop_on lift_prop_on_of_locally_lift_prop_on\n\n",
 "lift_prop_on_of_lift_prop":
 "theorem lift_prop_on_of_lift_prop (mono : ∀ ⦃s x t⦄ ⦃f : H → H'⦄, t ⊆ s → P f s x → P f t x) (h : lift_prop P g) :\n    lift_prop_on P g s := by\n  rw [← lift_prop_on_univ] at h\n  exact lift_prop_on_mono mono h (subset_univ _)\n#align lift_prop_on_of_lift_prop lift_prop_on_of_lift_prop\n\n",
 "lift_prop_on_mono":
 "theorem lift_prop_on_mono (mono : ∀ ⦃s x t⦄ ⦃f : H → H'⦄, t ⊆ s → P f s x → P f t x) (h : lift_prop_on P g t)\n    (hst : s ⊆ t) : lift_prop_on P g s := fun x hx => lift_prop_within_at_mono mono (h x (hst hx)) hst\n#align lift_prop_on_mono lift_prop_on_mono\n\n",
 "lift_prop_on_indep_chart":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lift_prop_on_indep_chart [has_groupoid M G] [has_groupoid M' G'] (he : e ∈ G.maximal_atlas M)\n    (hf : f ∈ G'.maximal_atlas M') (h : lift_prop_on P g s) {y : H}\n    (hy : y ∈ e.target ∩ «expr ⁻¹' » e.symm (s ∩ «expr ⁻¹' » g f.source)) :\n    P (f ∘ g ∘ e.symm) («expr ⁻¹' » e.symm s) y :=\n  by\n  convert ((hG.lift_prop_within_at_indep_chart he (e.symm_maps_to hy.1) hf hy.2.2).1 (h _ hy.2.1)).2\n  rw [e.right_inv hy.1]\n#align lift_prop_on_indep_chart lift_prop_on_indep_chart\n\n",
 "lift_prop_on_congr_iff":
 "theorem lift_prop_on_congr_iff (h₁ : ∀ y ∈ s, g' y = g y) : lift_prop_on P g' s ↔ lift_prop_on P g s :=\n  ⟨fun h => hG.lift_prop_on_congr h fun y hy => (h₁ y hy).symm, fun h => hG.lift_prop_on_congr h h₁⟩\n#align lift_prop_on_congr_iff lift_prop_on_congr_iff\n\n",
 "lift_prop_on_congr":
 "theorem lift_prop_on_congr (h : lift_prop_on P g s) (h₁ : ∀ y ∈ s, g' y = g y) : lift_prop_on P g' s := fun x hx =>\n  hG.lift_prop_within_at_congr (h x hx) h₁ (h₁ x hx)\n#align lift_prop_on_congr lift_prop_on_congr\n\n",
 "lift_prop_on_chart_symm":
 "theorem lift_prop_on_chart_symm [has_groupoid M G] (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y) :\n    lift_prop_on Q (chart_at H x).symm (chart_at H x).target :=\n  hG.lift_prop_on_symm_of_mem_maximal_atlas hQ (chart_mem_maximal_atlas G x)\n#align lift_prop_on_chart_symm lift_prop_on_chart_symm\n\n",
 "lift_prop_on_chart":
 "theorem lift_prop_on_chart [has_groupoid M G] (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y) :\n    lift_prop_on Q (chart_at H x) (chart_at H x).source :=\n  hG.lift_prop_on_of_mem_maximal_atlas hQ (chart_mem_maximal_atlas G x)\n#align lift_prop_on_chart lift_prop_on_chart\n\n",
 "lift_prop_of_locally_lift_prop_on":
 "theorem lift_prop_of_locally_lift_prop_on (h : ∀ x, ∃ u, is_open u ∧ x ∈ u ∧ lift_prop_on P g u) : lift_prop P g :=\n  by\n  rw [← lift_prop_on_univ]\n  apply hG.lift_prop_on_of_locally_lift_prop_on fun x hx => _\n  simp [h x]\n#align lift_prop_of_locally_lift_prop_on lift_prop_of_locally_lift_prop_on\n\n",
 "lift_prop_iff":
 "theorem lift_prop_iff {P : (H → H') → set H → H → Prop} {f : M → M'} :\n    lift_prop P f ↔ continuous f ∧ ∀ x, P (chart_at H' (f x) ∘ f ∘ (chart_at H x).symm) univ (chart_at H x x) := by\n  simp_rw [lift_prop, lift_prop_at_iff, forall_and, continuous_iff_continuous_at]\n#align lift_prop_iff lift_prop_iff\n\n",
 "lift_prop_id":
 "theorem lift_prop_id (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y) : lift_prop Q (id : M → M) :=\n  by\n  simp_rw [lift_prop_iff, continuous_id, true_and_iff]\n  exact fun x => hG.congr' ((chart_at H x).eventually_right_inverse <| mem_chart_target H x) (hQ _)\n#align lift_prop_id lift_prop_id\n\n",
 "lift_prop_at_symm_of_mem_maximal_atlas":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem lift_prop_at_symm_of_mem_maximal_atlas [has_groupoid M G] {x : H} (hG : G.local_invariant_prop G Q)\n    (hQ : ∀ y, Q id univ y) (he : e ∈ maximal_atlas M G) (hx : x ∈ e.target) : lift_prop_at Q e.symm x :=\n  by\n  suffices h : Q (e ∘ e.symm) univ x\n  · have A : «expr ⁻¹' » e.symm e.source ∩ e.target = e.target := by mfld_set_tac\n    have : e.symm x ∈ e.source := by simp only [hx, mfld_simps]\n    rw [lift_prop_at, hG.lift_prop_within_at_indep_chart G.id_mem_maximal_atlas (mem_univ _) he this]\n    refine' ⟨(e.symm.continuous_at hx).continuous_within_at, _⟩\n    simp only [h, mfld_simps]\n  exact hG.congr' (e.eventually_right_inverse hx) (hQ x)\n#align lift_prop_at_symm_of_mem_maximal_atlas lift_prop_at_symm_of_mem_maximal_atlas\n\n",
 "lift_prop_at_of_mem_maximal_atlas":
 "theorem lift_prop_at_of_mem_maximal_atlas [has_groupoid M G] (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y)\n    (he : e ∈ maximal_atlas M G) (hx : x ∈ e.source) : lift_prop_at Q e x :=\n  by\n  simp_rw [lift_prop_at, hG.lift_prop_within_at_indep_chart he hx G.id_mem_maximal_atlas (mem_univ _),\n    (e.continuous_at hx).continuous_within_at, true_and_iff]\n  exact hG.congr' (e.eventually_right_inverse' hx) (hQ _)\n#align lift_prop_at_of_mem_maximal_atlas lift_prop_at_of_mem_maximal_atlas\n\n",
 "lift_prop_at_of_lift_prop_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem lift_prop_at_of_lift_prop_within_at (h : lift_prop_within_at P g s x) (hs : s ∈ (nhds) x) :\n    lift_prop_at P g x := by rwa [← univ_inter s, hG.lift_prop_within_at_inter hs] at h\n#align lift_prop_at_of_lift_prop_within_at lift_prop_at_of_lift_prop_within_at\n\n",
 "lift_prop_at_iff":
 "theorem lift_prop_at_iff {P : (H → H') → set H → H → Prop} {f : M → M'} {x : M} :\n    lift_prop_at P f x ↔ continuous_at f x ∧ P (chart_at H' (f x) ∘ f ∘ (chart_at H x).symm) univ (chart_at H x x) := by\n  rw [lift_prop_at, lift_prop_within_at, continuous_within_at_univ, preimage_univ]\n#align lift_prop_at_iff lift_prop_at_iff\n\n",
 "lift_prop_at_congr_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem lift_prop_at_congr_of_eventually_eq (h : lift_prop_at P g x) (h₁ : «expr =ᶠ[ ] » g' ((nhds) x) g) :\n    lift_prop_at P g' x :=\n  (hG.lift_prop_at_congr_iff_of_eventually_eq h₁).mpr h\n#align lift_prop_at_congr_of_eventually_eq lift_prop_at_congr_of_eventually_eq\n\n",
 "lift_prop_at_congr_iff_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem lift_prop_at_congr_iff_of_eventually_eq (h₁ : «expr =ᶠ[ ] » g' ((nhds) x) g) :\n    lift_prop_at P g' x ↔ lift_prop_at P g x :=\n  hG.lift_prop_within_at_congr_iff_of_eventually_eq (by simp_rw [nhds_within_univ, h₁]) h₁.eq_of_nhds\n#align lift_prop_at_congr_iff_of_eventually_eq lift_prop_at_congr_iff_of_eventually_eq\n\n",
 "lift_prop_at_chart_symm":
 "theorem lift_prop_at_chart_symm [has_groupoid M G] (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y) :\n    lift_prop_at Q (chart_at H x).symm ((chart_at H x) x) :=\n  hG.lift_prop_at_symm_of_mem_maximal_atlas hQ (chart_mem_maximal_atlas G x) (by simp)\n#align lift_prop_at_chart_symm lift_prop_at_chart_symm\n\n",
 "lift_prop_at_chart":
 "theorem lift_prop_at_chart [has_groupoid M G] (hG : G.local_invariant_prop G Q) (hQ : ∀ y, Q id univ y) :\n    lift_prop_at Q (chart_at H x) x :=\n  hG.lift_prop_at_of_mem_maximal_atlas hQ (chart_mem_maximal_atlas G x) (mem_chart_source H x)\n#align lift_prop_at_chart lift_prop_at_chart\n\n",
 "left_invariance":
 "theorem left_invariance {s : set H} {x : H} {f : H → H'} {e' : local_homeomorph H' H'} (he' : e' ∈ G')\n    (hfs : continuous_within_at f s x) (hxe' : f x ∈ e'.source) : P (e' ∘ f) s x ↔ P f s x :=\n  by\n  have h2f := hfs.preimage_mem_nhds_within (e'.open_source.mem_nhds hxe')\n  have h3f :=\n    ((e'.continuous_at hxe').comp_continuous_within_at hfs).preimage_mem_nhds_within <|\n      e'.symm.open_source.mem_nhds <| e'.maps_to hxe'\n  constructor\n  · intro h\n    rw [hG.is_local_nhds h3f] at h\n    have h2 := hG.left_invariance' (G'.symm he') (inter_subset_right _ _) (e'.maps_to hxe') h\n    rw [← hG.is_local_nhds h3f] at h2\n    refine' hG.congr_nhds_within _ (e'.left_inv hxe') h2\n    exact eventually_of_mem h2f fun x' => e'.left_inv\n  · simp_rw [hG.is_local_nhds h2f]\n    exact hG.left_invariance' he' (inter_subset_right _ _) hxe'\n#align left_invariance left_invariance\n\n",
 "is_local_structomorph_within_at_local_invariant_prop":
 "/-- For a groupoid `G` which is `closed_under_restriction`, being a local structomorphism is a local\ninvariant property. -/\ntheorem is_local_structomorph_within_at_local_invariant_prop [closed_under_restriction G] :\n    local_invariant_prop G G (is_local_structomorph_within_at G) :=\n  { is_local := by\n      intro s x u f hu hux\n      constructor\n      · rintro h hx\n        rcases h hx.1 with ⟨e, heG, hef, hex⟩\n        have : s ∩ u ∩ e.source ⊆ s ∩ e.source := by mfld_set_tac\n        exact ⟨e, heG, hef.mono this, hex⟩\n      · rintro h hx\n        rcases h ⟨hx, hux⟩ with ⟨e, heG, hef, hex⟩\n        refine' ⟨e.restr (interior u), _, _, _⟩\n        · exact closed_under_restriction' heG is_open_interior\n        · have : s ∩ u ∩ e.source = s ∩ (e.source ∩ u) := by mfld_set_tac\n          simpa only [this, interior_interior, hu.interior_eq, mfld_simps] using hef\n        · simp only [*, interior_interior, hu.interior_eq, mfld_simps]\n    right_invariance' := by\n      intro s x f e' he'G he'x h hx\n      have hxs : x ∈ s := by simpa only [e'.left_inv he'x, mfld_simps] using hx\n      rcases h hxs with ⟨e, heG, hef, hex⟩\n      refine' ⟨e'.symm.trans e, G.trans (G.symm he'G) heG, _, _⟩\n      · intro y hy\n        simp only [mfld_simps] at hy\n        simp only [hef ⟨hy.1, hy.2.2⟩, mfld_simps]\n      · simp only [hex, he'x, mfld_simps]\n    congr_of_forall := by\n      intro s x f g hfgs hfg' h hx\n      rcases h hx with ⟨e, heG, hef, hex⟩\n      refine' ⟨e, heG, _, hex⟩\n      intro y hy\n      rw [← hef hy, hfgs y hy.1]\n    left_invariance' := by\n      intro s x f e' he'G he' hfx h hx\n      rcases h hx with ⟨e, heG, hef, hex⟩\n      refine' ⟨e.trans e', G.trans heG he'G, _, _⟩\n      · intro y hy\n        simp only [mfld_simps] at hy\n        simp only [hef ⟨hy.1, hy.2.1⟩, mfld_simps]\n      · simpa only [hex, hef ⟨hx, hex⟩, mfld_simps] using hfx }\n#align is_local_structomorph_within_at_local_invariant_prop is_local_structomorph_within_at_local_invariant_prop\n\n",
 "is_local_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem is_local_nhds {s u : set H} {x : H} {f : H → H'} (hu : u ∈ nhds_within s x) : P f s x ↔ P f (s ∩ u) x :=\n  hG.congr_set <| mem_nhds_within_iff_eventually_eq.mp hu\n#align is_local_nhds is_local_nhds\n\n",
 "congr_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-\nCopyright (c) 2020 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel, Floris van Doorn\n-/\ntheorem congr_set {s t : set H} {x : H} {f : H → H'} (hu : «expr =ᶠ[ ] » s ((nhds) x) t) : P f s x ↔ P f t x :=\n  by\n  obtain ⟨o, host, ho, hxo⟩ := mem_nhds_iff.mp hu.mem_iff\n  simp_rw [subset_def, mem_set_of, ← and_congr_left_iff, ← mem_inter_iff, ← Set.ext_iff] at host\n  rw [hG.is_local ho hxo, host, ← hG.is_local ho hxo]\n#align congr_set congr_set\n\n",
 "congr_nhds_within'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem congr_nhds_within' {s : set H} {x : H} {f g : H → H'} (h1 : «expr =ᶠ[ ] » f (nhds_within s x) g)\n    (h2 : f x = g x) (hP : P g s x) : P f s x :=\n  (hG.congr_iff_nhds_within h1 h2).mpr hP\n#align congr_nhds_within' congr_nhds_within'\n\n",
 "congr_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem congr_nhds_within {s : set H} {x : H} {f g : H → H'} (h1 : «expr =ᶠ[ ] » f (nhds_within s x) g) (h2 : f x = g x)\n    (hP : P f s x) : P g s x :=\n  (hG.congr_iff_nhds_within h1 h2).mp hP\n#align congr_nhds_within congr_nhds_within\n\n",
 "congr_iff_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem congr_iff_nhds_within {s : set H} {x : H} {f g : H → H'} (h1 : «expr =ᶠ[ ] » f (nhds_within s x) g)\n    (h2 : f x = g x) : P f s x ↔ P g s x := by\n  simp_rw [hG.is_local_nhds h1]\n  exact ⟨hG.congr_of_forall (fun y hy => hy.2) h2, hG.congr_of_forall (fun y hy => hy.2.symm) h2.symm⟩\n#align congr_iff_nhds_within congr_iff_nhds_within\n\n",
 "congr_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem congr_iff {s : set H} {x : H} {f g : H → H'} (h : «expr =ᶠ[ ] » f ((nhds) x) g) : P f s x ↔ P g s x :=\n  hG.congr_iff_nhds_within (mem_nhds_within_of_mem_nhds h) (mem_of_mem_nhds h : _)\n#align congr_iff congr_iff\n\n",
 "congr'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem congr' {s : set H} {x : H} {f g : H → H'} (h : «expr =ᶠ[ ] » f ((nhds) x) g) (hP : P g s x) : P f s x :=\n  hG.congr h.symm hP\n#align congr' congr'\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print congr /-\ntheorem congr {s : set H} {x : H} {f g : H → H'} (h : «expr =ᶠ[ ] » f ((nhds) x) g) (hP : P f s x) : P g s x :=\n  (hG.congr_iff h).mp hP\n#align congr congr\n-/\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\ntheorem has_groupoid.comp (H : ∀ e ∈ G₂, lift_prop_on (is_local_structomorph_within_at G₁) (e : H₂ → H₂) e.source) :\n    @has_groupoid H₁ _ H₃ _ (charted_space.comp H₁ H₂ H₃) G₁ :=\n  {\n    compatible := by\n      rintro _ _ ⟨e, f, he, hf, rfl⟩ ⟨e', f', he', hf', rfl⟩\n      apply G₁.locality\n      intro x hx\n      simp only [mfld_simps] at hx\n      have hxs : x ∈ «expr ⁻¹' » f.symm (local_homeomorph.trans e.symm e').source := by simp only [hx, mfld_simps]\n      have hxs' :\n        x ∈\n          f.target ∩\n            «expr ⁻¹' » f.symm\n              ((local_homeomorph.trans e.symm e').source ∩ «expr ⁻¹' » (local_homeomorph.trans e.symm e') f'.source) :=\n        by simp only [hx, mfld_simps]\n      obtain ⟨φ, hφG₁, hφ, hφ_dom⟩ :=\n        local_invariant_prop.lift_prop_on_indep_chart (is_local_structomorph_within_at_local_invariant_prop G₁)\n          (G₁.subset_maximal_atlas hf) (G₁.subset_maximal_atlas hf') (H _ (G₂.compatible he he')) hxs' hxs\n      simp_rw [← local_homeomorph.coe_trans, local_homeomorph.trans_assoc] at hφ\n      simp_rw [local_homeomorph.trans_symm_eq_symm_trans_symm, local_homeomorph.trans_assoc]\n      have hs :\n        is_open (local_homeomorph.trans f.symm (local_homeomorph.trans e.symm (local_homeomorph.trans e' f'))).source :=\n        (local_homeomorph.trans f.symm (local_homeomorph.trans e.symm (local_homeomorph.trans e' f'))).open_source\n      refine' ⟨_, hs.inter φ.open_source, _, _⟩\n      · simp only [hx, hφ_dom, mfld_simps]\n      · refine' G₁.eq_on_source (closed_under_restriction' hφG₁ hs) _\n        rw [local_homeomorph.restr_source_inter]\n        refine' (hφ.mono _).restr_eq_on_source\n        mfld_set_tac }\n#align has_groupoid.comp has_groupoid.comp\n\n"}