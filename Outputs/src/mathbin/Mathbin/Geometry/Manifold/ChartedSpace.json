{"trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n#print StructureGroupoid.trans /-\n/-\nCopyright (c) 2019 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n/- Notational shortcut for the composition of local homeomorphisms and local equivs, i.e.,\n`local_homeomorph.trans` and `local_equiv.trans`.\nNote that, as is usual for equivs, the composition is from left to right, hence the direction of\nthe arrow. -/\ntheorem StructureGroupoid.trans (G : StructureGroupoid H) {e e' : LocalHomeomorph H H} (he : e ∈ G) (he' : e' ∈ G) :\n    local_homeomorph.trans e e' ∈ G :=\n  G.trans' e e' he he'\n#align structure_groupoid.trans StructureGroupoid.trans\n-/\n\n",
 "symm":
 "#print StructureGroupoid.symm /-\ntheorem StructureGroupoid.symm (G : StructureGroupoid H) {e : LocalHomeomorph H H} (he : e ∈ G) : e.symm ∈ G :=\n  G.symm' e he\n#align structure_groupoid.symm StructureGroupoid.symm\n-/\n\n",
 "subset_maximalAtlas":
 "#print StructureGroupoid.subset_maximalAtlas /-\n/-- The elements of the atlas belong to the maximal atlas for any structure groupoid -/\ntheorem StructureGroupoid.subset_maximalAtlas [HasGroupoid M G] : atlas H M ⊆ G.maximal_atlas M := fun e he e' he' =>\n  ⟨G.compatible he he', G.compatible he' he⟩\n#align structure_groupoid.subset_maximal_atlas StructureGroupoid.subset_maximalAtlas\n-/\n\n",
 "singleton_has_groupoid":
 "theorem singleton_has_groupoid {f : α → H} (h : OpenEmbedding f) (G : StructureGroupoid H) [ClosedUnderRestriction G] :\n    @HasGroupoid _ _ _ _ h.singleton_charted_space G :=\n  (h.to_local_homeomorph f).singleton_has_groupoid (by simp) G\n#align singleton_has_groupoid singleton_has_groupoid\n\n",
 "singleton_charted_space_mem_atlas_eq":
 "theorem singleton_charted_space_mem_atlas_eq (h : e.source = Set.univ) (e' : LocalHomeomorph α H)\n    (h' : e' ∈ (e.singleton_charted_space h).atlas) : e' = e :=\n  h'\n#align singleton_charted_space_mem_atlas_eq singleton_charted_space_mem_atlas_eq\n\n",
 "singleton_charted_space_chart_at_source":
 "theorem singleton_charted_space_chart_at_source (h : e.source = Set.univ) {x : α} :\n    (@chart_at H _ α _ (e.singleton_charted_space h) x).source = Set.univ :=\n  h\n#align singleton_charted_space_chart_at_source singleton_charted_space_chart_at_source\n\n",
 "singleton_charted_space_chart_at_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem singleton_charted_space_chart_at_eq {f : α → H} (h : OpenEmbedding f) {x : α} :\n    «expr⇑ » (@chart_at H _ α _ h.singleton_charted_space x) = f :=\n  rfl\n#align singleton_charted_space_chart_at_eq singleton_charted_space_chart_at_eq\n\n",
 "secondCountable_of_sigma_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print ChartedSpace.secondCountable_of_sigma_compact /-\ntheorem ChartedSpace.secondCountable_of_sigma_compact [SecondCountableTopology H] [SigmaCompactSpace M] :\n    SecondCountableTopology M :=\n  by\n  obtain ⟨s, hsc, hsU⟩ :\n    ∃ s,\n      Set.Countable s ∧\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (chart_at H x).source =\n          univ :=\n    countable_cover_nhds_of_sigma_compact fun x : M => chart_source_mem_nhds H x\n  exact ChartedSpace.secondCountable_of_countable_cover H hsU hsc\n#align charted_space.second_countable_of_sigma_compact ChartedSpace.secondCountable_of_sigma_compact\n-/\n\n",
 "secondCountable_of_countable_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print ChartedSpace.secondCountable_of_countable_cover /-\ntheorem ChartedSpace.secondCountable_of_countable_cover [SecondCountableTopology H] {s : Set M}\n    (hs :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (chart_at H x).source =\n        univ)\n    (hsc : s.countable) : SecondCountableTopology M :=\n  by\n  haveI : ∀ x : M, second_countable_topology (chart_at H x).source := fun x =>\n    (chart_at H x).second_countable_topology_source\n  haveI := hsc.to_encodable\n  rw [bUnion_eq_Union] at hs\n  exact second_countable_topology_of_countable_cover (fun x : s => (chart_at H (x : M)).open_source) hs\n#align charted_space.second_countable_of_countable_cover ChartedSpace.secondCountable_of_countable_cover\n-/\n\n",
 "prodChartedSpace_chartAt":
 "#print prodChartedSpace_chartAt /-\n@[simp, mfld_simps]\ntheorem prodChartedSpace_chartAt : chart_at (ModelProd H H') x = (chart_at H x.fst).prod (chart_at H' x.snd) :=\n  rfl\n#align prod_charted_space_chart_at prodChartedSpace_chartAt\n-/\n\n",
 "piChartedSpace_chartAt":
 "#print piChartedSpace_chartAt /-\n@[simp, mfld_simps]\ntheorem piChartedSpace_chartAt {ι : Type _} [Fintype ι] (H : ι → Type _) [∀ i, TopologicalSpace (H i)] (M : ι → Type _)\n    [∀ i, TopologicalSpace (M i)] [∀ i, ChartedSpace (H i) (M i)] (f : ∀ i, M i) :\n    chart_at (ModelPi H) f = LocalHomeomorph.pi fun i => chart_at (H i) (f i) :=\n  rfl\n#align pi_charted_space_chart_at piChartedSpace_chartAt\n-/\n\n",
 "open_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem open_target (he : e ∈ c.atlas) : IsOpen e.target :=\n  by\n  have E : e.target ∩ «expr ⁻¹' » e.symm e.source = e.target :=\n    subset.antisymm (inter_subset_left _ _) fun x hx => ⟨hx, LocalEquiv.target_subset_preimage_source _ hx⟩\n  simpa [LocalEquiv.trans_source, E] using c.open_source e e he he\n#align open_target open_target\n\n",
 "open_source'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\ntheorem open_source' (he : e ∈ c.atlas) : (is_open_of c.to_topological_space) e.source :=\n  by\n  apply topological_space.generate_open.basic\n  simp only [exists_prop, mem_Union, mem_singleton_iff]\n  refine' ⟨e, he, univ, isOpen_univ, _⟩\n  simp only [Set.univ_inter, Set.preimage_univ]\n#align open_source' open_source'\n\n",
 "modelProd_range_prod_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print modelProd_range_prod_id /-\n-- Next lemma shows up often when dealing with derivatives, register it as simp.\n@[simp, mfld_simps]\ntheorem modelProd_range_prod_id {H : Type _} {H' : Type _} {α : Type _} (f : H → α) :\n    (range fun p : ModelProd H H' => (f p.1, p.2)) = lower_set.prod (range f) (univ : Set H') := by\n  rw [prod_range_univ_eq]\n#align model_prod_range_prod_id modelProd_range_prod_id\n-/\n\n",
 "mem_pregroupoid_of_eq_on_source":
 "#print mem_pregroupoid_of_eq_on_source /-\ntheorem mem_pregroupoid_of_eq_on_source (PG : Pregroupoid H) {e e' : LocalHomeomorph H H} (he' : e ≈ e')\n    (he : PG.property e e.source) : PG.property e' e'.source :=\n  by\n  rw [← he'.1]\n  exact PG.congr e.open_source he'.eq_on.symm he\n#align mem_pregroupoid_of_eq_on_source mem_pregroupoid_of_eq_on_source\n-/\n\n",
 "mem_maximalAtlas_of_mem_groupoid":
 "#print StructureGroupoid.mem_maximalAtlas_of_mem_groupoid /-\n/-- In the model space, any element of the groupoid is in the maximal atlas. -/\ntheorem StructureGroupoid.mem_maximalAtlas_of_mem_groupoid {f : LocalHomeomorph H H} (hf : f ∈ G) :\n    f ∈ G.maximal_atlas H := by\n  rintro e (rfl : e = LocalHomeomorph.refl H)\n  exact ⟨G.trans (G.symm hf) G.id_mem, G.trans (G.symm G.id_mem) hf⟩\n#align structure_groupoid.mem_maximal_atlas_of_mem_groupoid StructureGroupoid.mem_maximalAtlas_of_mem_groupoid\n-/\n\n",
 "mem_maximalAtlas_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n#print mem_maximalAtlas_iff /-\ntheorem mem_maximalAtlas_iff {e : LocalHomeomorph M H} :\n    e ∈ G.maximal_atlas M ↔\n      ∀ e' ∈ atlas H M, local_homeomorph.trans e.symm e' ∈ G ∧ local_homeomorph.trans e'.symm e ∈ G :=\n  iff.rfl\n#align mem_maximal_atlas_iff mem_maximalAtlas_iff\n-/\n\n",
 "mem_groupoid_of_pregroupoid":
 "#print mem_groupoid_of_pregroupoid /-\ntheorem mem_groupoid_of_pregroupoid {PG : Pregroupoid H} {e : LocalHomeomorph H H} :\n    e ∈ PG.groupoid ↔ PG.property e e.source ∧ PG.property e.symm e.target :=\n  iff.rfl\n#align mem_groupoid_of_pregroupoid mem_groupoid_of_pregroupoid\n-/\n\n",
 "mem_chart_target":
 "#print mem_chart_target /-\ntheorem mem_chart_target (x : M) : chart_at H x x ∈ (chart_at H x).target :=\n  (chart_at H x).map_source (mem_chart_source _ _)\n#align mem_chart_target mem_chart_target\n-/\n\n",
 "mem_achart_source":
 "#print mem_achart_source /-\ntheorem mem_achart_source (x : M) : x ∈ (achart H x).1.source :=\n  mem_chart_source H x\n#align mem_achart_source mem_achart_source\n-/\n\n",
 "locallyConnectedSpace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print ChartedSpace.locallyConnectedSpace /-\n/-- If a topological space admits an atlas with locally connected charts, then the space itself is\nlocally connected. -/\ntheorem ChartedSpace.locallyConnectedSpace [LocallyConnectedSpace H] : LocallyConnectedSpace M :=\n  by\n  let E : M → LocalHomeomorph M H := chart_at H\n  refine'\n    locallyConnectedSpace_of_connected_bases (fun x s => «expr '' » (E x).symm s)\n      (fun x s => (IsOpen s ∧ E x x ∈ s ∧ IsConnected s) ∧ s ⊆ (E x).target) _ _\n  · intro x\n    simpa only [LocalHomeomorph.symm_map_nhds_eq, mem_chart_source] using\n      ((locally_connected_space.open_connected_basis (E x x)).restrict_subset\n            ((E x).open_target.mem_nhds (mem_chart_target H x))).map\n        (E x).symm\n  · rintro x s ⟨⟨-, -, hsconn⟩, hssubset⟩\n    exact hsconn.is_preconnected.image _ ((E x).continuous_on_symm.mono hssubset)\n#align charted_space.locally_connected_space ChartedSpace.locallyConnectedSpace\n-/\n\n",
 "locallyCompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print ChartedSpace.locallyCompact /-\n/-- If a topological space admits an atlas with locally compact charts, then the space itself\nis locally compact. -/\ntheorem ChartedSpace.locallyCompact [LocallyCompactSpace H] : LocallyCompactSpace M :=\n  by\n  have :\n    ∀ x : M,\n      ((nhds) x).has_basis (fun s => s ∈ (nhds) (chart_at H x x) ∧ IsCompact s ∧ s ⊆ (chart_at H x).target) fun s =>\n        «expr '' » (chart_at H x).symm s :=\n    by\n    intro x\n    rw [← (chart_at H x).symm_map_nhds_eq (mem_chart_source H x)]\n    exact ((compact_basis_nhds (chart_at H x x)).has_basis_self_subset (chart_target_mem_nhds H x)).map _\n  refine' locallyCompactSpace_of_hasBasis this _\n  rintro x s ⟨h₁, h₂, h₃⟩\n  exact h₂.image_of_continuous_on ((chart_at H x).continuous_on_symm.mono h₃)\n#align charted_space.locally_compact ChartedSpace.locallyCompact\n-/\n\n",
 "locality":
 "#print StructureGroupoid.locality /-\ntheorem StructureGroupoid.locality (G : StructureGroupoid H) {e : LocalHomeomorph H H}\n    (h : ∀ x ∈ e.source, ∃ s, IsOpen s ∧ x ∈ s ∧ e.restr s ∈ G) : e ∈ G :=\n  G.locality' e h\n#align structure_groupoid.locality StructureGroupoid.locality\n-/\n\n",
 "le_iff":
 "#print StructureGroupoid.le_iff /-\ntheorem StructureGroupoid.le_iff {G₁ G₂ : StructureGroupoid H} : G₁ ≤ G₂ ↔ ∀ e, e ∈ G₁ → e ∈ G₂ :=\n  iff.rfl\n#align structure_groupoid.le_iff StructureGroupoid.le_iff\n-/\n\n",
 "id_mem_maximalAtlas":
 "#print StructureGroupoid.id_mem_maximalAtlas /-\n/-- In the model space, the identity is in any maximal atlas. -/\ntheorem StructureGroupoid.id_mem_maximalAtlas : LocalHomeomorph.refl H ∈ G.maximal_atlas H :=\n  G.subset_maximal_atlas <| by simp\n#align structure_groupoid.id_mem_maximal_atlas StructureGroupoid.id_mem_maximalAtlas\n-/\n\n",
 "id_mem":
 "#print StructureGroupoid.id_mem /-\ntheorem StructureGroupoid.id_mem (G : StructureGroupoid H) : LocalHomeomorph.refl H ∈ G :=\n  G.id_mem'\n#align structure_groupoid.id_mem StructureGroupoid.id_mem\n-/\n\n",
 "idRestrGroupoid_mem":
 "#print idRestrGroupoid_mem /-\ntheorem idRestrGroupoid_mem {s : Set H} (hs : IsOpen s) : ofSet s hs ∈ @idRestrGroupoid H _ :=\n  ⟨s, hs, by rfl⟩\n#align id_restr_groupoid_mem idRestrGroupoid_mem\n-/\n\n",
 "hasGroupoid_of_pregroupoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n#print hasGroupoid_of_pregroupoid /-\ntheorem hasGroupoid_of_pregroupoid (PG : Pregroupoid H)\n    (h :\n      ∀ {e e' : LocalHomeomorph M H},\n        e ∈ atlas H M →\n          e' ∈ atlas H M → PG.property (local_homeomorph.trans e.symm e') (local_homeomorph.trans e.symm e').source) :\n    HasGroupoid M PG.groupoid :=\n  ⟨fun e e' he he' => mem_groupoid_of_pregroupoid.mpr ⟨h he he', h he' he⟩⟩\n#align has_groupoid_of_pregroupoid hasGroupoid_of_pregroupoid\n-/\n\n",
 "hasGroupoid_of_le":
 "#print hasGroupoid_of_le /-\ntheorem hasGroupoid_of_le {G₁ G₂ : StructureGroupoid H} (h : HasGroupoid M G₁) (hle : G₁ ≤ G₂) : HasGroupoid M G₂ :=\n  ⟨fun e e' he he' => hle (h.compatible he he')⟩\n#align has_groupoid_of_le hasGroupoid_of_le\n-/\n\n",
 "groupoid_of_pregroupoid_le":
 "#print groupoid_of_pregroupoid_le /-\ntheorem groupoid_of_pregroupoid_le (PG₁ PG₂ : Pregroupoid H) (h : ∀ f s, PG₁.property f s → PG₂.property f s) :\n    PG₁.groupoid ≤ PG₂.groupoid := by\n  refine' StructureGroupoid.le_iff.2 fun e he => _\n  rw [mem_groupoid_of_pregroupoid] at he⊢\n  exact ⟨h _ _ he.1, h _ _ he.2⟩\n#align groupoid_of_pregroupoid_le groupoid_of_pregroupoid_le\n-/\n\n",
 "eq_on_source":
 "#print StructureGroupoid.eq_on_source /-\ntheorem StructureGroupoid.eq_on_source (G : StructureGroupoid H) {e e' : LocalHomeomorph H H} (he : e ∈ G)\n    (h : e' ≈ e) : e' ∈ G :=\n  G.eq_on_source' e e' he h\n#align structure_groupoid.eq_on_source StructureGroupoid.eq_on_source\n-/\n\n",
 "compatible_of_mem_maximalAtlas":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n#print StructureGroupoid.compatible_of_mem_maximalAtlas /-\n/-- Changing coordinates between two elements of the maximal atlas gives rise to an element\nof the structure groupoid. -/\ntheorem StructureGroupoid.compatible_of_mem_maximalAtlas {e e' : LocalHomeomorph M H} (he : e ∈ G.maximal_atlas M)\n    (he' : e' ∈ G.maximal_atlas M) : local_homeomorph.trans e.symm e' ∈ G :=\n  by\n  apply G.locality fun x hx => _\n  set f := chart_at H (e.symm x) with hf\n  let s := e.target ∩ «expr ⁻¹' » e.symm f.source\n  have hs : IsOpen s := by apply e.symm.continuous_to_fun.preimage_open_of_open <;> apply open_source\n  have xs : x ∈ s := by\n    dsimp at hx\n    simp [s, hx]\n  refine' ⟨s, hs, xs, _⟩\n  have A : local_homeomorph.trans e.symm f ∈ G := (mem_maximalAtlas_iff.1 he f (chart_mem_atlas _ _)).1\n  have B : local_homeomorph.trans f.symm e' ∈ G := (mem_maximalAtlas_iff.1 he' f (chart_mem_atlas _ _)).2\n  have C : local_homeomorph.trans (local_homeomorph.trans e.symm f) (local_homeomorph.trans f.symm e') ∈ G :=\n    G.trans A B\n  have D :\n    local_homeomorph.trans (local_homeomorph.trans e.symm f) (local_homeomorph.trans f.symm e') ≈\n      (local_homeomorph.trans e.symm e').restr s :=\n    calc\n      local_homeomorph.trans (local_homeomorph.trans e.symm f) (local_homeomorph.trans f.symm e') =\n          local_homeomorph.trans e.symm (local_homeomorph.trans (local_homeomorph.trans f f.symm) e') :=\n        by simp [trans_assoc]\n      _ ≈ local_homeomorph.trans e.symm (local_homeomorph.trans (of_set f.source f.open_source) e') := by\n        simp [eq_on_source.trans', trans_self_symm]\n      _ ≈ local_homeomorph.trans (local_homeomorph.trans e.symm (of_set f.source f.open_source)) e' := by\n        simp [trans_assoc]\n      _ ≈ local_homeomorph.trans (e.symm.restr s) e' := by simp [s, trans_of_set']\n      _ ≈ (local_homeomorph.trans e.symm e').restr s := by simp [restr_trans]\n      \n  exact G.eq_on_source C (setoid.symm D)\n#align structure_groupoid.compatible_of_mem_maximal_atlas StructureGroupoid.compatible_of_mem_maximalAtlas\n-/\n\n",
 "compatible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n#print StructureGroupoid.compatible /-\n/-- Reformulate in the `structure_groupoid` namespace the compatibility condition of charts in a\ncharted space admitting a structure groupoid, to make it more easily accessible with dot\nnotation. -/\ntheorem StructureGroupoid.compatible {H : Type _} [TopologicalSpace H] (G : StructureGroupoid H) {M : Type _}\n    [TopologicalSpace M] [ChartedSpace H M] [HasGroupoid M G] {e e' : LocalHomeomorph M H} (he : e ∈ atlas H M)\n    (he' : e' ∈ atlas H M) : local_homeomorph.trans e.symm e' ∈ G :=\n  has_groupoid.compatible G he he'\n#align structure_groupoid.compatible StructureGroupoid.compatible\n-/\n\n",
 "coe_achart":
 "#print coe_achart /-\n@[simp, mfld_simps]\ntheorem coe_achart (x : M) : (achart H x : LocalHomeomorph M H) = chart_at H x :=\n  rfl\n#align coe_achart coe_achart\n-/\n\n",
 "closedUnderRestriction_iff_id_le":
 "#print closedUnderRestriction_iff_id_le /-\n/-- A groupoid is closed under restriction if and only if it contains the trivial restriction-closed\ngroupoid. -/\ntheorem closedUnderRestriction_iff_id_le (G : StructureGroupoid H) : ClosedUnderRestriction G ↔ idRestrGroupoid ≤ G :=\n  by\n  constructor\n  · intro _i\n    apply structure_groupoid.le_iff.mpr\n    rintro e ⟨s, hs, hes⟩\n    refine' G.eq_on_source _ hes\n    convert closedUnderRestriction' G.id_mem hs\n    change s = _ ∩ _\n    rw [hs.interior_eq]\n    simp only [mfld_simps]\n  · intro h\n    constructor\n    intro e he s hs\n    rw [← of_set_trans (e : LocalHomeomorph H H) hs]\n    refine' G.trans _ he\n    apply structure_groupoid.le_iff.mp h\n    exact idRestrGroupoid_mem hs\n#align closed_under_restriction_iff_id_le closedUnderRestriction_iff_id_le\n-/\n\n",
 "closedUnderRestriction'":
 "#print closedUnderRestriction' /-\ntheorem closedUnderRestriction' {G : StructureGroupoid H} [ClosedUnderRestriction G] {e : LocalHomeomorph H H}\n    (he : e ∈ G) {s : Set H} (hs : IsOpen s) : e.restr s ∈ G :=\n  closed_under_restriction.closed_under_restriction he s hs\n#align closed_under_restriction' closedUnderRestriction'\n-/\n\n",
 "chartedSpaceSelf_prod":
 "#print chartedSpaceSelf_prod /-\ntheorem chartedSpaceSelf_prod : prodChartedSpace H H H' H' = chartedSpaceSelf (H × H') :=\n  by\n  ext1\n  · simp [prodChartedSpace, atlas]\n  · ext1\n    simp [chartAt_self_eq]\n    rfl\n#align charted_space_self_prod chartedSpaceSelf_prod\n-/\n\n",
 "chartedSpaceSelf_atlas":
 "#print chartedSpaceSelf_atlas /-\n/-- In the trivial charted_space structure of a space modelled over itself through the identity, the\natlas members are just the identity -/\n@[simp, mfld_simps]\ntheorem chartedSpaceSelf_atlas {H : Type _} [TopologicalSpace H] {e : LocalHomeomorph H H} :\n    e ∈ atlas H H ↔ e = LocalHomeomorph.refl H := by simp [atlas, charted_space.atlas]\n#align charted_space_self_atlas chartedSpaceSelf_atlas\n-/\n\n",
 "chart_target_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print chart_target_mem_nhds /-\ntheorem chart_target_mem_nhds (x : M) : (chart_at H x).target ∈ (nhds) (chart_at H x x) :=\n  (chart_at H x).open_target.mem_nhds <| mem_chart_target H x\n#align chart_target_mem_nhds chart_target_mem_nhds\n-/\n\n",
 "chart_source_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print chart_source_mem_nhds /-\ntheorem chart_source_mem_nhds (x : M) : (chart_at H x).source ∈ (nhds) x :=\n  (chart_at H x).open_source.mem_nhds <| mem_chart_source H x\n#align chart_source_mem_nhds chart_source_mem_nhds\n-/\n\n",
 "chart_mem_maximalAtlas":
 "#print StructureGroupoid.chart_mem_maximalAtlas /-\ntheorem StructureGroupoid.chart_mem_maximalAtlas [HasGroupoid M G] (x : M) : chart_at H x ∈ G.maximal_atlas M :=\n  G.subset_maximal_atlas (chart_mem_atlas H x)\n#align structure_groupoid.chart_mem_maximal_atlas StructureGroupoid.chart_mem_maximalAtlas\n-/\n\n",
 "chartAt_self_eq":
 "#print chartAt_self_eq /-\n/-- In the model space, chart_at is always the identity -/\ntheorem chartAt_self_eq {H : Type _} [TopologicalSpace H] {x : H} : chart_at H x = LocalHomeomorph.refl H := by\n  simpa using chart_mem_atlas H x\n#align chart_at_self_eq chartAt_self_eq\n-/\n\n",
 "achart_val":
 "#print achart_val /-\n@[simp, mfld_simps]\ntheorem achart_val (x : M) : (achart H x).1 = chart_at H x :=\n  rfl\n#align achart_val achart_val\n-/\n\n",
 "achart_def":
 "#print achart_def /-\ntheorem achart_def (x : M) : achart H x = ⟨chart_at H x, chart_mem_atlas H x⟩ :=\n  rfl\n#align achart_def achart_def\n-/\n\n"}