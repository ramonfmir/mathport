{"trans_local_homeomorph_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/-\nCopyright (c) 2022 Floris van Doorn, Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Floris van Doorn, Heather Macbeth\n-/\n/-- Compute the composition of two local homeomorphisms induced by fiberwise linear\nequivalences. -/\ntheorem trans_local_homeomorph_apply (hU : IsOpen U) (hφ : ContinuousOn (fun x => φ x : B → «expr →L[ ] » F 𝕜 F) U)\n    (h2φ : ContinuousOn (fun x => (φ x).symm : B → «expr →L[ ] » F 𝕜 F) U) (hU' : IsOpen U')\n    (hφ' : ContinuousOn (fun x => φ' x : B → «expr →L[ ] » F 𝕜 F) U')\n    (h2φ' : ContinuousOn (fun x => (φ' x).symm : B → «expr →L[ ] » F 𝕜 F) U') (b : B) (v : F) :\n    (local_homeomorph.trans (fiberwise_linear.local_homeomorph φ hU hφ h2φ)\n          (fiberwise_linear.local_homeomorph φ' hU' hφ' h2φ'))\n        ⟨b, v⟩ =\n      ⟨b, φ' b (φ b v)⟩ :=\n  rfl\n#align trans_local_homeomorph_apply trans_local_homeomorph_apply\n\n",
 "target_trans_local_homeomorph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/-- Compute the target of the composition of two local homeomorphisms induced by fiberwise linear\nequivalences. -/\ntheorem target_trans_local_homeomorph (hU : IsOpen U) (hφ : ContinuousOn (fun x => φ x : B → «expr →L[ ] » F 𝕜 F) U)\n    (h2φ : ContinuousOn (fun x => (φ x).symm : B → «expr →L[ ] » F 𝕜 F) U) (hU' : IsOpen U')\n    (hφ' : ContinuousOn (fun x => φ' x : B → «expr →L[ ] » F 𝕜 F) U')\n    (h2φ' : ContinuousOn (fun x => (φ' x).symm : B → «expr →L[ ] » F 𝕜 F) U') :\n    (local_homeomorph.trans (fiberwise_linear.local_homeomorph φ hU hφ h2φ)\n          (fiberwise_linear.local_homeomorph φ' hU' hφ' h2φ')).target =\n      lower_set.prod (U ∩ U') univ :=\n  by\n  dsimp only [fiberwise_linear.local_homeomorph]\n  mfld_set_tac\n#align target_trans_local_homeomorph target_trans_local_homeomorph\n\n",
 "source_trans_local_homeomorph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/-- Compute the source of the composition of two local homeomorphisms induced by fiberwise linear\nequivalences. -/\ntheorem source_trans_local_homeomorph (hU : IsOpen U) (hφ : ContinuousOn (fun x => φ x : B → «expr →L[ ] » F 𝕜 F) U)\n    (h2φ : ContinuousOn (fun x => (φ x).symm : B → «expr →L[ ] » F 𝕜 F) U) (hU' : IsOpen U')\n    (hφ' : ContinuousOn (fun x => φ' x : B → «expr →L[ ] » F 𝕜 F) U')\n    (h2φ' : ContinuousOn (fun x => (φ' x).symm : B → «expr →L[ ] » F 𝕜 F) U') :\n    (local_homeomorph.trans (fiberwise_linear.local_homeomorph φ hU hφ h2φ)\n          (fiberwise_linear.local_homeomorph φ' hU' hφ' h2φ')).source =\n      lower_set.prod (U ∩ U') univ :=\n  by\n  dsimp only [fiberwise_linear.local_homeomorph]\n  mfld_set_tac\n#align source_trans_local_homeomorph source_trans_local_homeomorph\n\n",
 "mem_smooth_fiberwise_linear_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n-- the hard work has been extracted to `locality_aux₁` and `locality_aux₂`\n@[simp]\ntheorem mem_smooth_fiberwise_linear_iff (e : LocalHomeomorph (B × F) (B × F)) :\n    e ∈ smooth_fiberwise_linear B F IB ↔\n      ∃ (φ : B → «expr ≃L[ ] » F 𝕜 F)(U : Set B)(hU : IsOpen U)(hφ :\n        smooth_on IB (model_with_corners_self 𝕜 («expr →L[ ] » F 𝕜 F)) (fun x => φ x : B → «expr →L[ ] » F 𝕜 F) U)(h2φ :\n        smooth_on IB (model_with_corners_self 𝕜 («expr →L[ ] » F 𝕜 F)) (fun x => (φ x).symm : B → «expr →L[ ] » F 𝕜 F)\n          U),\n        e.eq_on_source (fiberwise_linear.local_homeomorph φ hU hφ.continuous_on h2φ.continuous_on) :=\n  show e ∈ Set.unionᵢ _ ↔ _ by\n    simp only [mem_Union]\n    rfl\n#align mem_smooth_fiberwise_linear_iff mem_smooth_fiberwise_linear_iff\n\n",
 "locality_aux₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr (_, _)]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- Let `e` be a local homeomorphism of `B × F` whose source is `U ×ˢ univ`, for some set `U` in\n`B`, and which, at any point `x` in `U`, admits a neighbourhood `u` of `x` such that `e` is equal on\n`u ×ˢ univ` to some bi-smooth fiberwise linear local homeomorphism.  Then `e` itself is equal to\nsome bi-smooth fiberwise linear local homeomorphism.\n\nThis is the key mathematical point of the `locality` condition in the construction of the\n`structure_groupoid` of bi-smooth fiberwise linear local homeomorphisms.  The proof is by gluing\ntogether the various bi-smooth fiberwise linear local homeomorphism which exist locally.\n\nThe `U` in the conclusion is the same `U` as in the hypothesis. We state it like this, because this\nis exactly what we need for `smooth_fiberwise_linear`. -/\ntheorem smooth_fiberwise_linear.locality_aux₂ (e : LocalHomeomorph (B × F) (B × F)) (U : Set B)\n    (hU : e.source = lower_set.prod U univ)\n    (h :\n      ∀ x ∈ U,\n        ∃ (φ : B → «expr ≃L[ ] » F 𝕜 F)(u : Set B)(hu : IsOpen u)(hUu : u ⊆ U)(hux : x ∈ u)(hφ :\n          smooth_on IB (model_with_corners_self 𝕜 («expr →L[ ] » F 𝕜 F)) (fun x => (φ x : «expr →L[ ] » F 𝕜 F)) u)(h2φ :\n          smooth_on IB (model_with_corners_self 𝕜 («expr →L[ ] » F 𝕜 F)) (fun x => ((φ x).symm : «expr →L[ ] » F 𝕜 F))\n            u),\n          (e.restr (lower_set.prod u univ)).eq_on_source\n            (fiberwise_linear.local_homeomorph φ hu hφ.continuous_on h2φ.continuous_on)) :\n    ∃ (Φ : B → «expr ≃L[ ] » F 𝕜 F)(U : Set B)(hU₀ : IsOpen U)(hΦ :\n      smooth_on IB (model_with_corners_self 𝕜 («expr →L[ ] » F 𝕜 F)) (fun x => (Φ x : «expr →L[ ] » F 𝕜 F)) U)(h2Φ :\n      smooth_on IB (model_with_corners_self 𝕜 («expr →L[ ] » F 𝕜 F)) (fun x => ((Φ x).symm : «expr →L[ ] » F 𝕜 F)) U),\n      e.eq_on_source (fiberwise_linear.local_homeomorph Φ hU₀ hΦ.continuous_on h2Φ.continuous_on) :=\n  by\n  classical\n    rw [SetCoe.forall'] at h\n    choose! φ u hu hUu hux hφ h2φ heφ using h\n    have heuφ : ∀ x : U, eq_on e (fun q => (q.1, φ x q.1 q.2)) (lower_set.prod (u x) univ) :=\n      by\n      intro x p hp\n      refine' (heφ x).2 _\n      rw [(heφ x).1]\n      exact hp\n    have huφ : ∀ (x x' : U) (y : B) (hyx : y ∈ u x) (hyx' : y ∈ u x'), φ x y = φ x' y :=\n      by\n      intro p p' y hyp hyp'\n      ext v\n      have h1 : e (y, v) = (y, φ p y v) := heuφ _ ⟨(id hyp : (y, v).fst ∈ u p), trivial⟩\n      have h2 : e (y, v) = (y, φ p' y v) := heuφ _ ⟨(id hyp' : (y, v).fst ∈ u p'), trivial⟩\n      exact congr_arg Prod.snd (h1.symm.trans h2)\n    have hUu' :\n      U = «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u i) :=\n      by\n      ext x\n      rw [mem_Union]\n      refine' ⟨fun h => ⟨⟨x, h⟩, hux _⟩, _⟩\n      rintro ⟨x, hx⟩\n      exact hUu x hx\n    have hU' : IsOpen U := by\n      rw [hUu']\n      apply isOpen_unionᵢ hu\n    let Φ₀ : U → «expr ≃L[ ] » F 𝕜 F := Union_lift u (fun x => φ x ∘ coe) huφ U hUu'.le\n    let Φ : B → «expr ≃L[ ] » F 𝕜 F := fun y => if hy : y ∈ U then Φ₀ ⟨y, hy⟩ else ContinuousLinearEquiv.refl 𝕜 F\n    have hΦ : ∀ (y) (hy : y ∈ U), Φ y = Φ₀ ⟨y, hy⟩ := fun y hy => dif_pos hy\n    have hΦφ : ∀ x : U, ∀ y ∈ u x, Φ y = φ x y := by\n      intro x y hyu\n      refine' (hΦ y (hUu x hyu)).trans _\n      exact Union_lift_mk ⟨y, hyu⟩ _\n    have hΦ : smooth_on IB (model_with_corners_self 𝕜 («expr →L[ ] » F 𝕜 F)) (fun y => (Φ y : «expr →L[ ] » F 𝕜 F)) U :=\n      by\n      apply cont_mdiff_on_of_locally_cont_mdiff_on\n      intro x hx\n      refine' ⟨u ⟨x, hx⟩, hu ⟨x, hx⟩, hux _, _⟩\n      refine' (cont_mdiff_on.congr (hφ ⟨x, hx⟩) _).mono (inter_subset_right _ _)\n      intro y hy\n      rw [hΦφ ⟨x, hx⟩ y hy]\n    have h2Φ :\n      smooth_on IB (model_with_corners_self 𝕜 («expr →L[ ] » F 𝕜 F)) (fun y => ((Φ y).symm : «expr →L[ ] » F 𝕜 F)) U :=\n      by\n      apply cont_mdiff_on_of_locally_cont_mdiff_on\n      intro x hx\n      refine' ⟨u ⟨x, hx⟩, hu ⟨x, hx⟩, hux _, _⟩\n      refine' (cont_mdiff_on.congr (h2φ ⟨x, hx⟩) _).mono (inter_subset_right _ _)\n      intro y hy\n      rw [hΦφ ⟨x, hx⟩ y hy]\n    refine' ⟨Φ, U, hU', hΦ, h2Φ, hU, fun p hp => _⟩\n    rw [hU] at hp\n    -- using rw on the next line seems to cause a timeout in kernel type-checking\n    refine' (heuφ ⟨p.fst, hp.1⟩ ⟨hux _, hp.2⟩).trans _\n    trace \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr (_, _)]]\"\n    rw [hΦφ]\n    apply hux\n#align smooth_fiberwise_linear.locality_aux₂ smooth_fiberwise_linear.locality_aux₂\n\n",
 "locality_aux₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/-- Let `e` be a local homeomorphism of `B × F`.  Suppose that at every point `p` in the source of\n`e`, there is some neighbourhood `s` of `p` on which `e` is equal to a bi-smooth fiberwise linear\nlocal homeomorphism.\nThen the source of `e` is of the form `U ×ˢ univ`, for some set `U` in `B`, and, at any point `x` in\n`U`, admits a neighbourhood `u` of `x` such that `e` is equal on `u ×ˢ univ` to some bi-smooth\nfiberwise linear local homeomorphism. -/\ntheorem smooth_fiberwise_linear.locality_aux₁ (e : LocalHomeomorph (B × F) (B × F))\n    (h :\n      ∀ p ∈ e.source,\n        ∃ s : Set (B × F),\n          IsOpen s ∧\n            p ∈ s ∧\n              ∃ (φ : B → «expr ≃L[ ] » F 𝕜 F)(u : Set B)(hu : IsOpen u)(hφ :\n                smooth_on IB (model_with_corners_self 𝕜 («expr →L[ ] » F 𝕜 F)) (fun x => (φ x : «expr →L[ ] » F 𝕜 F))\n                  u)(h2φ :\n                smooth_on IB (model_with_corners_self 𝕜 («expr →L[ ] » F 𝕜 F))\n                  (fun x => ((φ x).symm : «expr →L[ ] » F 𝕜 F)) u),\n                (e.restr s).eq_on_source (fiberwise_linear.local_homeomorph φ hu hφ.continuous_on h2φ.continuous_on)) :\n    ∃ (U : Set B)(hU : e.source = lower_set.prod U univ),\n      ∀ x ∈ U,\n        ∃ (φ : B → «expr ≃L[ ] » F 𝕜 F)(u : Set B)(hu : IsOpen u)(huU : u ⊆ U)(hux : x ∈ u)(hφ :\n          smooth_on IB (model_with_corners_self 𝕜 («expr →L[ ] » F 𝕜 F)) (fun x => (φ x : «expr →L[ ] » F 𝕜 F)) u)(h2φ :\n          smooth_on IB (model_with_corners_self 𝕜 («expr →L[ ] » F 𝕜 F)) (fun x => ((φ x).symm : «expr →L[ ] » F 𝕜 F))\n            u),\n          (e.restr (lower_set.prod u univ)).eq_on_source\n            (fiberwise_linear.local_homeomorph φ hu hφ.continuous_on h2φ.continuous_on) :=\n  by\n  rw [SetCoe.forall'] at h\n  -- choose s hs hsp φ u hu hφ h2φ heφ using h,\n  -- the following 2 lines should be `choose s hs hsp φ u hu hφ h2φ heφ using h,`\n  -- `choose` produces a proof term that takes a long time to type-check by the kernel (it seems)\n  -- porting note: todo: try using `choose` again in Lean 4\n  simp only [classical.skolem, ← exists_prop] at h\n  rcases h with ⟨s, hs, hsp, φ, u, hu, hφ, h2φ, heφ⟩\n  have hesu : ∀ p : e.source, e.source ∩ s p = lower_set.prod (u p) univ :=\n    by\n    intro p\n    rw [← e.restr_source' (s _) (hs _)]\n    exact (heφ p).1\n  have hu' : ∀ p : e.source, (p : B × F).fst ∈ u p := by\n    intro p\n    have : (p : B × F) ∈ e.source ∩ s p := ⟨p.prop, hsp p⟩\n    simpa only [hesu, mem_prod, mem_univ, and_true_iff] using this\n  have heu : ∀ p : e.source, ∀ q : B × F, q.fst ∈ u p → q ∈ e.source :=\n    by\n    intro p q hq\n    have : q ∈ lower_set.prod (u p) (univ : Set F) := ⟨hq, trivial⟩\n    rw [← hesu p] at this\n    exact this.1\n  have he : e.source = lower_set.prod («expr '' » Prod.fst e.source) (univ : Set F) :=\n    by\n    apply HasSubset.Subset.antisymm\n    · intro p hp\n      exact ⟨⟨p, hp, rfl⟩, trivial⟩\n    · rintro ⟨x, v⟩ ⟨⟨p, hp, rfl : p.fst = x⟩, -⟩\n      exact heu ⟨p, hp⟩ (p.fst, v) (hu' ⟨p, hp⟩)\n  refine' ⟨«expr '' » Prod.fst e.source, he, _⟩\n  rintro x ⟨p, hp, rfl⟩\n  refine' ⟨φ ⟨p, hp⟩, u ⟨p, hp⟩, hu ⟨p, hp⟩, _, hu' _, hφ ⟨p, hp⟩, h2φ ⟨p, hp⟩, _⟩\n  · intro y hy\n    refine' ⟨(y, 0), heu ⟨p, hp⟩ ⟨_, _⟩ hy, rfl⟩\n  · rw [← hesu, e.restr_source_inter]\n    exact heφ ⟨p, hp⟩\n#align smooth_fiberwise_linear.locality_aux₁ smooth_fiberwise_linear.locality_aux₁\n\n"}