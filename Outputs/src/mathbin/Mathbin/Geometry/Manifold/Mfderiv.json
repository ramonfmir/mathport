{"written_in_ext_chart_model_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n@[simp, mfld_simps]\ntheorem written_in_ext_chart_model_space :\n    written_in_ext_chart_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') x f = f :=\n  rfl\n#align written_in_ext_chart_model_space written_in_ext_chart_model_space\n\n",
 "written_in_ext_chart_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem written_in_ext_chart_comp (h : ContinuousWithinAt f s x) :\n    { y |\n        written_in_ext_chart_at I I'' x (g ∘ f) y =\n          (written_in_ext_chart_at I' I'' (f x) g ∘ written_in_ext_chart_at I I' x f) y } ∈\n      nhds_within («expr ⁻¹' » (ext_chart_at I x).symm s ∩ range I) ((ext_chart_at I x) x) :=\n  by\n  apply\n    @Filter.mem_of_superset _ _ («expr ⁻¹' » (f ∘ (ext_chart_at I x).symm) (ext_chart_at I' (f x)).source) _\n      (ext_chart_at_preimage_mem_nhds_within I x (h.preimage_mem_nhds_within (ext_chart_at_source_mem_nhds _ _)))\n  mfld_set_tac\n#align written_in_ext_chart_comp written_in_ext_chart_comp\n\n",
 "unique_mdiff_within_at_univ":
 "--\ntheorem unique_mdiff_within_at_univ : unique_mdiff_within_at I univ x :=\n  by\n  unfold unique_mdiff_within_at\n  simp only [preimage_univ, univ_inter]\n  exact I.unique_diff _ (mem_range_self _)\n#align unique_mdiff_within_at_univ unique_mdiff_within_at_univ\n\n",
 "unique_mdiff_within_at_iff_unique_diff_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem unique_mdiff_within_at_iff_unique_diff_within_at :\n    unique_mdiff_within_at (model_with_corners_self 𝕜 E) s x ↔ unique_diff_within_at 𝕜 s x := by\n  simp only [unique_mdiff_within_at, mfld_simps]\n#align unique_mdiff_within_at_iff_unique_diff_within_at unique_mdiff_within_at_iff_unique_diff_within_at\n\n",
 "unique_mdiff_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem unique_mdiff_within_at_iff {s : Set M} {x : M} :\n    unique_mdiff_within_at I s x ↔\n      unique_diff_within_at 𝕜 («expr ⁻¹' » (ext_chart_at I x).symm s ∩ (ext_chart_at I x).target)\n        ((ext_chart_at I x) x) :=\n  by\n  apply unique_diff_within_at_congr\n  rw [nhdsWithin_inter, nhdsWithin_inter, nhds_within_ext_chart_at_target_eq]\n#align unique_mdiff_within_at_iff unique_mdiff_within_at_iff\n\n",
 "unique_mdiff_within_at":
 "theorem is_open.unique_mdiff_within_at (xs : x ∈ s) (hs : IsOpen s) : unique_mdiff_within_at I s x :=\n  by\n  have := unique_mdiff_within_at.inter (unique_mdiff_within_at_univ I) (IsOpen.mem_nhds hs xs)\n  rwa [univ_inter] at this\n#align is_open.unique_mdiff_within_at is_open.unique_mdiff_within_at\n\n",
 "unique_mdiff_on_univ":
 "theorem unique_mdiff_on_univ : unique_mdiff_on I (univ : Set M) :=\n  isOpen_univ.unique_mdiff_on\n#align unique_mdiff_on_univ unique_mdiff_on_univ\n\n",
 "unique_mdiff_on_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_equiv.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_equiv.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If a set has the unique differential property, then its image under a local\ndiffeomorphism also has the unique differential property. -/\ntheorem unique_mdiff_on.unique_mdiff_on_preimage [smooth_manifold_with_corners I' M'] (hs : unique_mdiff_on I s)\n    {e : LocalHomeomorph M M'} (he : e.mdifferentiable I I') : unique_mdiff_on I' (e.target ∩ «expr ⁻¹' » e.symm s) :=\n  by\n  /- Start from a point `x` in the image, and let `z` be its preimage. Then the unique\n    derivative property at `x` is expressed through `ext_chart_at I' x`, and the unique\n    derivative property at `z` is expressed through `ext_chart_at I z`. We will argue that\n    the composition of these two charts with `e` is a local diffeomorphism in vector spaces,\n    and therefore preserves the unique differential property thanks to lemma\n    `has_fderiv_within_at.unique_diff_within_at`, saying that a differentiable function with onto\n    derivative preserves the unique derivative property.-/\n  intro x hx\n  let z := e.symm x\n  have z_source : z ∈ e.source := by simp only [hx.1, mfld_simps]\n  have zx : e z = x := by simp only [z, hx.1, mfld_simps]\n  let F := ext_chart_at I z\n  -- the unique derivative property at `z` is expressed through its preferred chart,\n  -- that we call `F`.\n  have B :\n    unique_diff_within_at 𝕜 («expr ⁻¹' » F.symm (s ∩ (e.source ∩ «expr ⁻¹' » e (ext_chart_at I' x).source)) ∩ F.target)\n      (F z) :=\n    by\n    have : unique_mdiff_within_at I s z := hs _ hx.2\n    have S : e.source ∩ «expr ⁻¹' » e (ext_chart_at I' x).source ∈ (nhds) z :=\n      by\n      apply IsOpen.mem_nhds\n      apply e.continuous_on.preimage_open_of_open e.open_source (is_open_ext_chart_at_source I' x)\n      simp only [z_source, zx, mfld_simps]\n    have := this.inter S\n    rw [unique_mdiff_within_at_iff] at this\n    exact this\n  -- denote by `G` the change of coordinate, i.e., the composition of the two extended charts and\n  -- of `e`\n  let G := local_equiv.trans F.symm (local_equiv.trans e.to_local_equiv (ext_chart_at I' x))\n  -- `G` is differentiable\n  have Diff :\n    (local_homeomorph.trans (chart_at H z).symm (local_homeomorph.trans e (chart_at H' x))).mdifferentiable I I' :=\n    by\n    have A := mdifferentiable_of_mem_atlas I (chart_mem_atlas H z)\n    have B := mdifferentiable_of_mem_atlas I' (chart_mem_atlas H' x)\n    exact A.symm.trans (he.trans B)\n  have Mmem :\n    (chart_at H z : M → H) z ∈\n      (local_homeomorph.trans (chart_at H z).symm (local_homeomorph.trans e (chart_at H' x))).source :=\n    by simp only [z_source, zx, mfld_simps]\n  have A : differentiable_within_at 𝕜 G (range I) (F z) := by\n    refine' (Diff.mdifferentiable_at Mmem).2.congr (fun p hp => _) _ <;> simp only [G, F, mfld_simps]\n  -- let `G'` be its derivative\n  let G' := fderiv_within 𝕜 G (range I) (F z)\n  have D₁ : has_fderiv_within_at G G' (range I) (F z) := A.has_fderiv_within_at\n  have D₂ :\n    has_fderiv_within_at G G'\n      («expr ⁻¹' » F.symm (s ∩ (e.source ∩ «expr ⁻¹' » e (ext_chart_at I' x).source)) ∩ F.target) (F z) :=\n    D₁.mono (by mfld_set_tac)\n  -- The derivative `G'` is onto, as it is the derivative of a local diffeomorphism, the composition\n  -- of the two charts and of `e`.\n  have C : DenseRange (G' : E → E') :=\n    by\n    have :\n      G' =\n        mfderiv I I' (local_homeomorph.trans (chart_at H z).symm (local_homeomorph.trans e (chart_at H' x)))\n          ((chart_at H z : M → H) z) :=\n      by\n      rw [(Diff.mdifferentiable_at Mmem).mfderiv]\n      rfl\n    rw [this]\n    exact (Diff.mfderiv_surjective Mmem).dense_range\n  -- key step: thanks to what we have proved about it, `G` preserves the unique derivative property\n  have key :\n    unique_diff_within_at 𝕜\n      («expr '' » G («expr ⁻¹' » F.symm (s ∩ (e.source ∩ «expr ⁻¹' » e (ext_chart_at I' x).source)) ∩ F.target))\n      (G (F z)) :=\n    D₂.unique_diff_within_at B C\n  have : G (F z) = (ext_chart_at I' x) x := by\n    dsimp [G, F]\n    simp only [hx.1, mfld_simps]\n  rw [this] at key\n  apply key.mono\n  show\n    «expr '' » G («expr ⁻¹' » F.symm (s ∩ (e.source ∩ «expr ⁻¹' » e (ext_chart_at I' x).source)) ∩ F.target) ⊆\n      «expr ⁻¹' » (ext_chart_at I' x).symm e.target ∩ «expr ⁻¹' » (ext_chart_at I' x).symm («expr ⁻¹' » e.symm s) ∩\n        range I'\n  rw [image_subset_iff]\n  mfld_set_tac\n#align unique_mdiff_on.unique_mdiff_on_preimage unique_mdiff_on.unique_mdiff_on_preimage\n\n",
 "unique_mdiff_on_iff_unique_diff_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem unique_mdiff_on_iff_unique_diff_on : unique_mdiff_on (model_with_corners_self 𝕜 E) s ↔ unique_diff_on 𝕜 s := by\n  simp [unique_mdiff_on, unique_diff_on, unique_mdiff_within_at_iff_unique_diff_within_at]\n#align unique_mdiff_on_iff_unique_diff_on unique_mdiff_on_iff_unique_diff_on\n\n",
 "unique_mdiff_on":
 "theorem is_open.unique_mdiff_on (hs : IsOpen s) : unique_mdiff_on I s := fun x hx =>\n  is_open.unique_mdiff_within_at hx hs\n#align is_open.unique_mdiff_on is_open.unique_mdiff_on\n\n",
 "unique_diff_on_target_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If a set in a manifold has the unique derivative property, then its pullback by any extended\nchart, in the vector space, also has the unique derivative property. -/\ntheorem unique_mdiff_on.unique_diff_on_target_inter (hs : unique_mdiff_on I s) (x : M) :\n    unique_diff_on 𝕜 ((ext_chart_at I x).target ∩ «expr ⁻¹' » (ext_chart_at I x).symm s) :=\n  by\n  -- this is just a reformulation of `unique_mdiff_on.unique_mdiff_on_preimage`, using as `e`\n  -- the local chart at `x`.\n  intro z hz\n  simp only [mfld_simps] at hz\n  have : (chart_at H x).mdifferentiable I I := mdifferentiable_chart _ _\n  have T := (hs.unique_mdiff_on_preimage this) (I.symm z)\n  simp only [hz.left.left, hz.left.right, hz.right, unique_mdiff_within_at, mfld_simps] at T⊢\n  convert T using 1\n  rw [@preimage_comp _ _ _ _ (chart_at H x).symm]\n  mfld_set_tac\n#align unique_mdiff_on.unique_diff_on_target_inter unique_mdiff_on.unique_diff_on_target_inter\n\n",
 "unique_diff_on_inter_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- When considering functions between manifolds, this statement shows up often. It entails\nthe unique differential of the pullback in extended charts of the set where the function can\nbe read in the charts. -/\ntheorem unique_mdiff_on.unique_diff_on_inter_preimage (hs : unique_mdiff_on I s) (x : M) (y : M') {f : M → M'}\n    (hf : ContinuousOn f s) :\n    unique_diff_on 𝕜\n      ((ext_chart_at I x).target ∩\n        «expr ⁻¹' » (ext_chart_at I x).symm (s ∩ «expr ⁻¹' » f (ext_chart_at I' y).source)) :=\n  haveI : unique_mdiff_on I (s ∩ «expr ⁻¹' » f (ext_chart_at I' y).source) :=\n    by\n    intro z hz\n    apply (hs z hz.1).inter'\n    apply (hf z hz.1).preimage_mem_nhds_within\n    exact (is_open_ext_chart_at_source I' y).mem_nhds hz.2\n  this.unique_diff_on_target_inter _\n#align unique_mdiff_on.unique_diff_on_inter_preimage unique_mdiff_on.unique_diff_on_inter_preimage\n\n",
 "union":
 "theorem has_mfderiv_within_at.union (hs : has_mfderiv_within_at I I' f s x f')\n    (ht : has_mfderiv_within_at I I' f t x f') : has_mfderiv_within_at I I' f (s ∪ t) x f' :=\n  by\n  constructor\n  · exact ContinuousWithinAt.union hs.1 ht.1\n  · convert has_fderiv_within_at.union hs.2 ht.2\n    simp only [union_inter_distrib_right, preimage_union]\n#align has_mfderiv_within_at.union has_mfderiv_within_at.union\n\n",
 "trans":
 "#print trans /-\ntheorem trans (he' : e'.mdifferentiable I' I'') : (e.trans e').mdifferentiable I I'' :=\n  by\n  constructor\n  · intro x hx\n    simp only [mfld_simps] at hx\n    exact ((he'.mdifferentiable_at hx.2).comp _ (he.mdifferentiable_at hx.1)).mdifferentiable_within_at\n  · intro x hx\n    simp only [mfld_simps] at hx\n    exact ((he.symm.mdifferentiable_at hx.2).comp _ (he'.symm.mdifferentiable_at hx.1)).mdifferentiable_within_at\n#align trans trans\n-/\n\n",
 "tangent_map_within_univ":
 "theorem tangent_map_within_univ : tangent_map_within I I' f univ = tangent_map I I' f :=\n  by\n  ext p : 1\n  simp only [tangent_map_within, tangent_map, mfld_simps]\n#align tangent_map_within_univ tangent_map_within_univ\n\n",
 "tangent_map_within_subset":
 "theorem tangent_map_within_subset {p : tangent_bundle I M} (st : s ⊆ t) (hs : unique_mdiff_within_at I s p.1)\n    (h : mdifferentiable_within_at I I' f t p.1) : tangent_map_within I I' f s p = tangent_map_within I I' f t p :=\n  by\n  simp only [tangent_map_within, mfld_simps]\n  rw [mfderiv_within_subset st hs h]\n#align tangent_map_within_subset tangent_map_within_subset\n\n",
 "tangent_map_within_proj":
 "@[simp, mfld_simps]\ntheorem tangent_map_within_proj {p : tangent_bundle I M} : (tangent_map_within I I' f s p).proj = f p.proj :=\n  rfl\n#align tangent_map_within_proj tangent_map_within_proj\n\n",
 "tangent_map_within_id":
 "theorem tangent_map_within_id {p : tangent_bundle I M} (hs : unique_mdiff_within_at I s p.proj) :\n    tangent_map_within I I (id : M → M) s p = p :=\n  by\n  simp only [tangent_map_within, id.def]\n  rw [mfderiv_within_id]\n  · rcases p with ⟨⟩\n    rfl\n  · exact hs\n#align tangent_map_within_id tangent_map_within_id\n\n",
 "tangent_map_within_fst":
 "@[simp, mfld_simps]\ntheorem tangent_map_within_fst {p : tangent_bundle I M} : (tangent_map_within I I' f s p).1 = f p.1 :=\n  rfl\n#align tangent_map_within_fst tangent_map_within_fst\n\n",
 "tangent_map_within_eq_tangent_map":
 "theorem tangent_map_within_eq_tangent_map {p : tangent_bundle I M} (hs : unique_mdiff_within_at I s p.1)\n    (h : mdifferentiable_at I I' f p.1) : tangent_map_within I I' f s p = tangent_map I I' f p :=\n  by\n  rw [← mdifferentiable_within_at_univ] at h\n  rw [← tangent_map_within_univ]\n  exact tangent_map_within_subset (subset_univ _) hs h\n#align tangent_map_within_eq_tangent_map tangent_map_within_eq_tangent_map\n\n",
 "tangent_map_within_congr":
 "theorem tangent_map_within_congr (h : ∀ x ∈ s, f x = f₁ x) (p : tangent_bundle I M) (hp : p.1 ∈ s)\n    (hs : unique_mdiff_within_at I s p.1) : tangent_map_within I I' f s p = tangent_map_within I I' f₁ s p :=\n  by\n  simp only [tangent_map_within, h p.fst hp, true_and_iff, eq_self_iff_true, heq_iff_eq, Sigma.mk.inj_iff]\n  congr 1\n  exact mfderiv_within_congr hs h (h _ hp)\n#align tangent_map_within_congr tangent_map_within_congr\n\n",
 "tangent_map_within_comp_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem tangent_map_within_comp_at (p : tangent_bundle I M) (hg : mdifferentiable_within_at I' I'' g u (f p.1))\n    (hf : mdifferentiable_within_at I I' f s p.1) (h : s ⊆ «expr ⁻¹' » f u) (hps : unique_mdiff_within_at I s p.1) :\n    tangent_map_within I I'' (g ∘ f) s p = tangent_map_within I' I'' g u (tangent_map_within I I' f s p) :=\n  by\n  simp only [tangent_map_within, mfld_simps]\n  rw [mfderiv_within_comp p.1 hg hf h hps]\n  rfl\n#align tangent_map_within_comp_at tangent_map_within_comp_at\n\n",
 "tangent_map_proj":
 "@[simp, mfld_simps]\ntheorem tangent_map_proj {p : tangent_bundle I M} : (tangent_map I I' f p).proj = f p.proj :=\n  rfl\n#align tangent_map_proj tangent_map_proj\n\n",
 "tangent_map_id":
 "@[simp, mfld_simps]\ntheorem tangent_map_id : tangent_map I I (id : M → M) = id :=\n  by\n  ext1 ⟨x, v⟩\n  simp [tangent_map]\n#align tangent_map_id tangent_map_id\n\n",
 "tangent_map_fst":
 "@[simp, mfld_simps]\ntheorem tangent_map_fst {p : tangent_bundle I M} : (tangent_map I I' f p).1 = f p.1 :=\n  rfl\n#align tangent_map_fst tangent_map_fst\n\n",
 "tangent_map_comp_at":
 "theorem tangent_map_comp_at (p : tangent_bundle I M) (hg : mdifferentiable_at I' I'' g (f p.1))\n    (hf : mdifferentiable_at I I' f p.1) : tangent_map I I'' (g ∘ f) p = tangent_map I' I'' g (tangent_map I I' f p) :=\n  by\n  simp only [tangent_map, mfld_simps]\n  rw [mfderiv_comp p.1 hg hf]\n  rfl\n#align tangent_map_comp_at tangent_map_comp_at\n\n",
 "tangent_map_comp":
 "theorem tangent_map_comp (hg : mdifferentiable I' I'' g) (hf : mdifferentiable I I' f) :\n    tangent_map I I'' (g ∘ f) = tangent_map I' I'' g ∘ tangent_map I I' f :=\n  by\n  ext p : 1\n  exact tangent_map_comp_at _ (hg _) (hf _)\n#align tangent_map_comp tangent_map_comp\n\n",
 "tangent_map_chart_symm":
 "/-- The derivative of the inverse of the chart at a base point is the inverse of the chart of the\ntangent bundle, composed with the identification between the tangent bundle of the model space and\nthe product space. -/\ntheorem tangent_map_chart_symm {p : tangent_bundle I M} {q : tangent_bundle I H} (h : q.1 ∈ (chart_at H p.1).target) :\n    tangent_map I I (chart_at H p.1).symm q =\n      ((chart_at (ModelProd H E) p).symm : ModelProd H E → tangent_bundle I M) ((Equiv.sigmaEquivProd H E) q) :=\n  by\n  dsimp only [tangent_map]\n  rw [mdifferentiable_at.mfderiv (mdifferentiable_at_atlas_symm _ (chart_mem_atlas _ _) h)]\n  -- a trivial instance is needed after the rewrite, handle it right now.\n  rotate_left;\n  · infer_instance\n  simp only [ContinuousLinearMap.coe_coe, tangent_bundle.chart_at, h, tangent_bundle_core, chart_at, Sigma.mk.inj_iff,\n    mfld_simps]\n#align tangent_map_chart_symm tangent_map_chart_symm\n\n",
 "tangent_map_chart":
 "/-- The derivative of the chart at a base point is the chart of the tangent bundle, composed with\nthe identification between the tangent bundle of the model space and the product space. -/\ntheorem tangent_map_chart {p q : tangent_bundle I M} (h : q.1 ∈ (chart_at H p.1).source) :\n    tangent_map I I (chart_at H p.1) q =\n      (Equiv.sigmaEquivProd _ _).symm ((chart_at (ModelProd H E) p : tangent_bundle I M → ModelProd H E) q) :=\n  by\n  dsimp [tangent_map]\n  rw [mdifferentiable_at.mfderiv]\n  · rfl\n  · exact mdifferentiable_at_atlas _ (chart_mem_atlas _ _) h\n#align tangent_map_chart tangent_map_chart\n\n",
 "tangent_bundle_proj_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem unique_mdiff_on.tangent_bundle_proj_preimage (hs : unique_mdiff_on I s) :\n    unique_mdiff_on I.tangent («expr ⁻¹' » ((exprπ) (tangent_space I)) s) :=\n  hs.smooth_bundle_preimage _\n#align unique_mdiff_on.tangent_bundle_proj_preimage unique_mdiff_on.tangent_bundle_proj_preimage\n\n",
 "symm_comp_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem symm_comp_deriv {x : M} (hx : x ∈ e.source) :\n    (mfderiv I' I e.symm (e x)).comp (mfderiv I I' e x) = ContinuousLinearMap.id 𝕜 (tangent_space I x) :=\n  by\n  have : mfderiv I I (e.symm ∘ e) x = (mfderiv I' I e.symm (e x)).comp (mfderiv I I' e x) :=\n    mfderiv_comp x (he.mdifferentiable_at_symm (e.map_source hx)) (he.mdifferentiable_at hx)\n  rw [← this]\n  have : mfderiv I I (_root_.id : M → M) x = ContinuousLinearMap.id _ _ := mfderiv_id I\n  rw [← this]\n  apply filter.eventually_eq.mfderiv_eq\n  have : e.source ∈ (nhds) x := IsOpen.mem_nhds e.open_source hx\n  exact Filter.mem_of_superset this (by mfld_set_tac)\n#align symm_comp_deriv symm_comp_deriv\n\n",
 "symm":
 "#print symm /-\ntheorem symm : e.symm.mdifferentiable I' I :=\n  ⟨he.2, he.1⟩\n#align symm symm\n-/\n\n",
 "sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem mdifferentiable.sub (hf : mdifferentiable I (model_with_corners_self 𝕜 E') f)\n    (hg : mdifferentiable I (model_with_corners_self 𝕜 E') g) :\n    mdifferentiable I (model_with_corners_self 𝕜 E') (f - g) := fun x => (hf x).sub (hg x)\n#align mdifferentiable.sub mdifferentiable.sub\n\n",
 "smooth_bundle_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/-- In a smooth fiber bundle, the preimage under the projection of a set with\nunique differential in the basis also has unique differential. -/\ntheorem unique_mdiff_on.smooth_bundle_preimage (hs : unique_mdiff_on I s) :\n    unique_mdiff_on (I.prod (model_with_corners_self 𝕜 F)) («expr ⁻¹' » ((exprπ) Z) s) :=\n  by\n  /- Using a chart (and the fact that unique differentiability is invariant under charts), we\n    reduce the situation to the model space, where we can use the fact that products respect\n    unique differentiability. -/\n  intro p hp\n  replace hp : p.fst ∈ s\n  · simpa only [mfld_simps] using hp\n  let e₀ := chart_at H p.1\n  let e := chart_at (ModelProd H F) p\n  have h2s :\n    ∀ x,\n      x ∈ e.target ∩ «expr ⁻¹' » e.symm («expr ⁻¹' » ((exprπ) Z) s) ↔\n        (x.1 ∈ e₀.target ∧ e₀.symm x.1 ∈ (trivialization_at F Z p.1).base_set) ∧ e₀.symm x.1 ∈ s :=\n    by\n    intro x\n    have A : x ∈ e.target ↔ x.1 ∈ e₀.target ∧ e₀.symm x.1 ∈ (trivialization_at F Z p.1).base_set := by\n      simp only [e, fiber_bundle.charted_space_chart_at, Trivialization.mem_target, Bundle.TotalSpace.proj, mfld_simps]\n    rw [← A, mem_inter_iff, and_congr_right_iff]\n    intro hx\n    simp only [fiber_bundle.charted_space_chart_at_symm_fst p x hx, mfld_simps]\n  -- It suffices to prove unique differentiability in a chart\n  suffices h :\n    unique_mdiff_on (I.prod (model_with_corners_self 𝕜 F)) (e.target ∩ «expr ⁻¹' » e.symm («expr ⁻¹' » ((exprπ) Z) s))\n  · have A :\n      unique_mdiff_on (I.prod (model_with_corners_self 𝕜 F))\n        (e.symm.target ∩ «expr ⁻¹' » e.symm.symm (e.target ∩ «expr ⁻¹' » e.symm («expr ⁻¹' » ((exprπ) Z) s))) :=\n      by\n      apply h.unique_mdiff_on_preimage\n      exact (mdifferentiable_of_mem_atlas _ (chart_mem_atlas _ _)).symm\n      infer_instance\n    have : p ∈ e.symm.target ∩ «expr ⁻¹' » e.symm.symm (e.target ∩ «expr ⁻¹' » e.symm («expr ⁻¹' » ((exprπ) Z) s)) := by\n      simp only [e, hp, mfld_simps]\n    apply (A _ this).mono\n    intro q hq\n    simp only [e, LocalHomeomorph.left_inv _ hq.1, mfld_simps] at hq\n    simp only [hq, mfld_simps]\n  intro q hq\n  simp only [unique_mdiff_within_at, model_with_corners.prod, -preimage_inter, mfld_simps]\n  have :\n    nhds_within (lower_set.prod («expr ⁻¹' » I.symm (e₀.target ∩ «expr ⁻¹' » e₀.symm s) ∩ range I) univ) (I q.1, q.2) ≤\n      nhds_within\n        («expr ⁻¹' » (fun p : E × F => (I.symm p.1, p.snd))\n            (e.target ∩ «expr ⁻¹' » e.symm («expr ⁻¹' » ((exprπ) Z) s)) ∩\n          lower_set.prod (range I) univ)\n        (I q.1, q.2) :=\n    by\n    rw [nhdsWithin_le_iff, mem_nhdsWithin]\n    refine' ⟨«expr ⁻¹' » (fun p : E × F => (I.symm p.1, p.snd)) e.target, _, _, _⟩\n    · exact e.open_target.preimage (I.continuous_symm.prod_map continuous_id)\n    · simp only [prod.mk.eta, mfld_simps] at hq\n      simp only [prod.mk.eta, hq, mfld_simps]\n    rintro x hx\n    simp only [mfld_simps] at hx\n    have h2x := hx\n    simp only [e, fiber_bundle.charted_space_chart_at, Trivialization.mem_target, mfld_simps] at h2x\n    simp only [h2s, hx, h2x, -preimage_inter, mfld_simps]\n  refine' unique_diff_within_at.mono_nhds _ this\n  rw [h2s] at hq\n  -- apply unique differentiability of products to conclude\n  apply unique_diff_on.prod _ unique_diff_on_univ\n  · simp only [hq, mfld_simps]\n  · intro x hx\n    have A : unique_mdiff_on I (e₀.target ∩ «expr ⁻¹' » e₀.symm s) :=\n      by\n      apply hs.unique_mdiff_on_preimage\n      exact mdifferentiable_of_mem_atlas _ (chart_mem_atlas _ _)\n      infer_instance\n    simp only [unique_mdiff_on, unique_mdiff_within_at, preimage_inter, mfld_simps] at A\n    have B := A (I.symm x) hx.1.1 hx.1.2\n    rwa [← preimage_inter, model_with_corners.right_inv _ hx.2] at B\n#align unique_mdiff_on.smooth_bundle_preimage unique_mdiff_on.smooth_bundle_preimage\n\n",
 "range_mfderiv_eq_univ":
 "theorem range_mfderiv_eq_univ {x : M} (hx : x ∈ e.source) : range (mfderiv I I' e x) = univ :=\n  (he.mfderiv_surjective hx).range_eq\n#align range_mfderiv_eq_univ range_mfderiv_eq_univ\n\n",
 "range_mfderiv_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_mfderiv_eq_top {x : M} (hx : x ∈ e.source) : LinearMap.range (mfderiv I I' e x) = «expr⊤» :=\n  (he.mfderiv hx).to_linear_equiv.range\n#align range_mfderiv_eq_top range_mfderiv_eq_top\n\n",
 "nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_mfderiv_within_at.nhds_within (h : has_mfderiv_within_at I I' f s x f') (ht : s ∈ nhds_within t x) :\n    has_mfderiv_within_at I I' f t x f' :=\n  (has_mfderiv_within_at_inter' ht).1 (h.mono (inter_subset_right _ _))\n#align has_mfderiv_within_at.nhds_within has_mfderiv_within_at.nhds_within\n\n",
 "neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem mdifferentiable.neg (hf : mdifferentiable I (model_with_corners_self 𝕜 E') f) :\n    mdifferentiable I (model_with_corners_self 𝕜 E') (-f) := fun x => (hf x).neg\n#align mdifferentiable.neg mdifferentiable.neg\n\n",
 "mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_mfderiv_at.mul' (hp : has_mfderiv_at I (model_with_corners_self 𝕜 F') p z p')\n    (hq : has_mfderiv_at I (model_with_corners_self 𝕜 F') q z q') :\n    has_mfderiv_at I (model_with_corners_self 𝕜 F') (p * q) z\n      («expr • » (p z) q' + p'.smul_right (q z) : «expr →L[ ] » E 𝕜 F') :=\n  has_mfderiv_within_at_univ.mp <| hp.has_mfderiv_within_at.mul' hq.has_mfderiv_within_at\n#align has_mfderiv_at.mul' has_mfderiv_at.mul'\n\n",
 "mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_mfderiv_at.mul (hp : has_mfderiv_at I (model_with_corners_self 𝕜 F') p z p')\n    (hq : has_mfderiv_at I (model_with_corners_self 𝕜 F') q z q') :\n    has_mfderiv_at I (model_with_corners_self 𝕜 F') (p * q) z\n      («expr • » (p z) q' + «expr • » (q z) p' : «expr →L[ ] » E 𝕜 F') :=\n  has_mfderiv_within_at_univ.mp <| hp.has_mfderiv_within_at.mul hq.has_mfderiv_within_at\n#align has_mfderiv_at.mul has_mfderiv_at.mul\n\n",
 "mono":
 "theorem mdifferentiable_on.mono (h : mdifferentiable_on I I' f t) (st : s ⊆ t) : mdifferentiable_on I I' f s :=\n  fun x hx => (h x (st hx)).mono st\n#align mdifferentiable_on.mono mdifferentiable_on.mono\n\n",
 "mfderiv_zero_of_not_mdifferentiable_at":
 "theorem mfderiv_zero_of_not_mdifferentiable_at (h : ¬mdifferentiable_at I I' f x) : mfderiv I I' f x = 0 := by\n  simp only [mfderiv, h, if_neg, not_false_iff]\n#align mfderiv_zero_of_not_mdifferentiable_at mfderiv_zero_of_not_mdifferentiable_at\n\n",
 "mfderiv_within_zero_of_not_mdifferentiable_within_at":
 "theorem mfderiv_within_zero_of_not_mdifferentiable_within_at (h : ¬mdifferentiable_within_at I I' f s x) :\n    mfderiv_within I I' f s x = 0 := by simp only [mfderiv_within, h, if_neg, not_false_iff]\n#align mfderiv_within_zero_of_not_mdifferentiable_within_at mfderiv_within_zero_of_not_mdifferentiable_within_at\n\n",
 "mfderiv_within_univ":
 "@[simp, mfld_simps]\ntheorem mfderiv_within_univ : mfderiv_within I I' f univ = mfderiv I I' f :=\n  by\n  ext x : 1\n  simp only [mfderiv_within, mfderiv, mfld_simps]\n  rw [mdifferentiable_within_at_univ]\n#align mfderiv_within_univ mfderiv_within_univ\n\n",
 "mfderiv_within_subset":
 "theorem mfderiv_within_subset (st : s ⊆ t) (hs : unique_mdiff_within_at I s x)\n    (h : mdifferentiable_within_at I I' f t x) : mfderiv_within I I' f s x = mfderiv_within I I' f t x :=\n  ((mdifferentiable_within_at.has_mfderiv_within_at h).mono st).mfderiv_within hs\n#align mfderiv_within_subset mfderiv_within_subset\n\n",
 "mfderiv_within_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mfderiv_within_inter (ht : t ∈ (nhds) x) (hs : unique_mdiff_within_at I s x) :\n    mfderiv_within I I' f (s ∩ t) x = mfderiv_within I I' f s x := by\n  rw [mfderiv_within, mfderiv_within, ext_chart_at_preimage_inter_eq, mdifferentiable_within_at_inter ht,\n    fderiv_within_inter (ext_chart_at_preimage_mem_nhds I x ht) hs]\n#align mfderiv_within_inter mfderiv_within_inter\n\n",
 "mfderiv_within_id":
 "theorem mfderiv_within_id (hxs : unique_mdiff_within_at I s x) :\n    mfderiv_within I I (@id M) s x = ContinuousLinearMap.id 𝕜 (tangent_space I x) :=\n  by\n  rw [mdifferentiable.mfderiv_within (mdifferentiable_at_id I) hxs]\n  exact mfderiv_id I\n#align mfderiv_within_id mfderiv_within_id\n\n",
 "mfderiv_within_eq_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/-- For maps between vector spaces, `mfderiv_within` and `fderiv_within` coincide -/\n@[simp]\ntheorem mfderiv_within_eq_fderiv_within :\n    mfderiv_within (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x = fderiv_within 𝕜 f s x :=\n  by\n  by_cases h : mdifferentiable_within_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x\n  · simp only [mfderiv_within, h, if_pos, mfld_simps]\n  · simp only [mfderiv_within, h, if_neg, not_false_iff]\n    rw [mdifferentiable_within_at_iff_differentiable_within_at] at h\n    exact (fderiv_within_zero_of_not_differentiable_within_at h).symm\n#align mfderiv_within_eq_fderiv_within mfderiv_within_eq_fderiv_within\n\n",
 "mfderiv_within_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem mfderiv_within_eq (hs : unique_mdiff_within_at (model_with_corners_self 𝕜 E) s x) :\n    mfderiv_within (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x = (f : «expr →L[ ] » E 𝕜 E') :=\n  f.has_mfderiv_within_at.mfderiv_within hs\n#align mfderiv_within_eq mfderiv_within_eq\n\n",
 "mfderiv_within_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem mfderiv_within_const (hxs : unique_mdiff_within_at I s x) :\n    mfderiv_within I I' (fun y : M => c) s x = (0 : «expr →L[ ] » (tangent_space I x) 𝕜 (tangent_space I' c)) :=\n  (has_mfderiv_within_at_const _ _ _ _ _).mfderiv_within hxs\n#align mfderiv_within_const mfderiv_within_const\n\n",
 "mfderiv_within_congr_mono":
 "theorem mdifferentiable_within_at.mfderiv_within_congr_mono (h : mdifferentiable_within_at I I' f s x)\n    (hs : ∀ x ∈ t, f₁ x = f x) (hx : f₁ x = f x) (hxt : unique_mdiff_within_at I t x) (h₁ : t ⊆ s) :\n    mfderiv_within I I' f₁ t x = (mfderiv_within I I' f s x : _) :=\n  (has_mfderiv_within_at.congr_mono h.has_mfderiv_within_at hs hx h₁).mfderiv_within hxt\n#align mdifferentiable_within_at.mfderiv_within_congr_mono mdifferentiable_within_at.mfderiv_within_congr_mono\n\n",
 "mfderiv_within_congr":
 "theorem mfderiv_within_congr (hs : unique_mdiff_within_at I s x) (hL : ∀ x ∈ s, f₁ x = f x) (hx : f₁ x = f x) :\n    mfderiv_within I I' f₁ s x = (mfderiv_within I I' f s x : _) :=\n  filter.eventually_eq.mfderiv_within_eq hs (Filter.eventuallyEq_of_mem self_mem_nhdsWithin hL) hx\n#align mfderiv_within_congr mfderiv_within_congr\n\n",
 "mfderiv_within_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mfderiv_within_comp (hg : mdifferentiable_within_at I' I'' g u (f x))\n    (hf : mdifferentiable_within_at I I' f s x) (h : s ⊆ «expr ⁻¹' » f u) (hxs : unique_mdiff_within_at I s x) :\n    mfderiv_within I I'' (g ∘ f) s x = (mfderiv_within I' I'' g u (f x)).comp (mfderiv_within I I' f s x) :=\n  by\n  apply has_mfderiv_within_at.mfderiv_within _ hxs\n  exact has_mfderiv_within_at.comp x hg.has_mfderiv_within_at hf.has_mfderiv_within_at h\n#align mfderiv_within_comp mfderiv_within_comp\n\n",
 "mfderiv_within":
 "theorem mdifferentiable.mfderiv_within (h : mdifferentiable_at I I' f x) (hxs : unique_mdiff_within_at I s x) :\n    mfderiv_within I I' f s x = mfderiv I I' f x :=\n  by\n  apply has_mfderiv_within_at.mfderiv_within _ hxs\n  exact h.has_mfderiv_at.has_mfderiv_within_at\n#align mdifferentiable.mfderiv_within mdifferentiable.mfderiv_within\n\n",
 "mfderiv_surjective":
 "theorem mfderiv_surjective {x : M} (hx : x ∈ e.source) : function.surjective (mfderiv I I' e x) :=\n  (he.mfderiv hx).surjective\n#align mfderiv_surjective mfderiv_surjective\n\n",
 "mfderiv_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem mfderiv_sub (hf : mdifferentiable_at I (model_with_corners_self 𝕜 E') f z)\n    (hg : mdifferentiable_at I (model_with_corners_self 𝕜 E') g z) :\n    (mfderiv I (model_with_corners_self 𝕜 E') (f - g) z : «expr →L[ ] » (tangent_space I z) 𝕜 E') =\n      (mfderiv I (model_with_corners_self 𝕜 E') f z - mfderiv I (model_with_corners_self 𝕜 E') g z :\n        «expr →L[ ] » (tangent_space I z) 𝕜 E') :=\n  (hf.has_mfderiv_at.sub hg.has_mfderiv_at).mfderiv\n#align mfderiv_sub mfderiv_sub\n\n",
 "mfderiv_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem mfderiv_neg (f : M → E') (x : M) :\n    (mfderiv I (model_with_corners_self 𝕜 E') (-f) x : «expr →L[ ] » (tangent_space I x) 𝕜 E') =\n      (-mfderiv I (model_with_corners_self 𝕜 E') f x : «expr →L[ ] » (tangent_space I x) 𝕜 E') :=\n  by\n  simp_rw [mfderiv]\n  by_cases hf : mdifferentiable_at I (model_with_corners_self 𝕜 E') f x\n  · exact hf.has_mfderiv_at.neg.mfderiv\n  · rw [if_neg hf]\n    rw [← mdifferentiable_at_neg] at hf\n    rw [if_neg hf, neg_zero]\n#align mfderiv_neg mfderiv_neg\n\n",
 "mfderiv_injective":
 "theorem mfderiv_injective {x : M} (hx : x ∈ e.source) : function.injective (mfderiv I I' e x) :=\n  (he.mfderiv hx).injective\n#align mfderiv_injective mfderiv_injective\n\n",
 "mfderiv_id":
 "@[simp, mfld_simps]\ntheorem mfderiv_id : mfderiv I I (@id M) x = ContinuousLinearMap.id 𝕜 (tangent_space I x) :=\n  has_mfderiv_at.mfderiv (has_mfderiv_at_id I x)\n#align mfderiv_id mfderiv_id\n\n",
 "mfderiv_eq_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/-- For maps between vector spaces, `mfderiv` and `fderiv` coincide -/\n@[simp]\ntheorem mfderiv_eq_fderiv : mfderiv (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x = fderiv 𝕜 f x :=\n  by\n  rw [← mfderiv_within_univ, ← fderiv_within_univ]\n  exact mfderiv_within_eq_fderiv_within\n#align mfderiv_eq_fderiv mfderiv_eq_fderiv\n\n",
 "mfderiv_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem mfderiv_eq :\n    mfderiv (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x = (f : «expr →L[ ] » E 𝕜 E') :=\n  f.has_mfderiv_at.mfderiv\n#align mfderiv_eq mfderiv_eq\n\n",
 "mfderiv_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp, mfld_simps]\ntheorem mfderiv_const :\n    mfderiv I I' (fun y : M => c) x = (0 : «expr →L[ ] » (tangent_space I x) 𝕜 (tangent_space I' c)) :=\n  has_mfderiv_at.mfderiv (has_mfderiv_at_const I I' c x)\n#align mfderiv_const mfderiv_const\n\n",
 "mfderiv_comp":
 "theorem mfderiv_comp (hg : mdifferentiable_at I' I'' g (f x)) (hf : mdifferentiable_at I I' f x) :\n    mfderiv I I'' (g ∘ f) x = (mfderiv I' I'' g (f x)).comp (mfderiv I I' f x) :=\n  by\n  apply has_mfderiv_at.mfderiv\n  exact has_mfderiv_at.comp x hg.has_mfderiv_at hf.has_mfderiv_at\n#align mfderiv_comp mfderiv_comp\n\n",
 "mfderiv_bijective":
 "theorem mfderiv_bijective {x : M} (hx : x ∈ e.source) : function.bijective (mfderiv I I' e x) :=\n  (he.mfderiv hx).bijective\n#align mfderiv_bijective mfderiv_bijective\n\n",
 "mfderiv_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem mfderiv_add (hf : mdifferentiable_at I (model_with_corners_self 𝕜 E') f z)\n    (hg : mdifferentiable_at I (model_with_corners_self 𝕜 E') g z) :\n    (mfderiv I (model_with_corners_self 𝕜 E') (f + g) z : «expr →L[ ] » (tangent_space I z) 𝕜 E') =\n      (mfderiv I (model_with_corners_self 𝕜 E') f z + mfderiv I (model_with_corners_self 𝕜 E') g z :\n        «expr →L[ ] » (tangent_space I z) 𝕜 E') :=\n  (hf.has_mfderiv_at.add hg.has_mfderiv_at).mfderiv\n#align mfderiv_add mfderiv_add\n\n",
 "mfderiv":
 "theorem has_mfderiv_at.mfderiv (h : has_mfderiv_at I I' f x f') : mfderiv I I' f x = f' :=\n  (has_mfderiv_at_unique h h.mdifferentiable_at.has_mfderiv_at).symm\n#align has_mfderiv_at.mfderiv has_mfderiv_at.mfderiv\n\n",
 "mdifferentiable_within_at_univ":
 "theorem mdifferentiable_within_at_univ : mdifferentiable_within_at I I' f univ x ↔ mdifferentiable_at I I' f x := by\n  simp only [mdifferentiable_within_at, mdifferentiable_at, continuousWithinAt_univ, mfld_simps]\n#align mdifferentiable_within_at_univ mdifferentiable_within_at_univ\n\n",
 "mdifferentiable_within_at_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem mdifferentiable_within_at_inter' (ht : t ∈ nhds_within s x) :\n    mdifferentiable_within_at I I' f (s ∩ t) x ↔ mdifferentiable_within_at I I' f s x :=\n  by\n  rw [mdifferentiable_within_at, mdifferentiable_within_at, ext_chart_at_preimage_inter_eq,\n    differentiable_within_at_inter', continuousWithinAt_inter' ht]\n  exact ext_chart_at_preimage_mem_nhds_within I x ht\n#align mdifferentiable_within_at_inter' mdifferentiable_within_at_inter'\n\n",
 "mdifferentiable_within_at_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mdifferentiable_within_at_inter (ht : t ∈ (nhds) x) :\n    mdifferentiable_within_at I I' f (s ∩ t) x ↔ mdifferentiable_within_at I I' f s x :=\n  by\n  rw [mdifferentiable_within_at, mdifferentiable_within_at, ext_chart_at_preimage_inter_eq,\n    differentiable_within_at_inter, continuousWithinAt_inter ht]\n  exact ext_chart_at_preimage_mem_nhds I x ht\n#align mdifferentiable_within_at_inter mdifferentiable_within_at_inter\n\n",
 "mdifferentiable_within_at_iff_of_mem_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- One can reformulate differentiability within a set at a point as continuity within this set at\nthis point, and differentiability in any chart containing that point. -/\ntheorem mdifferentiable_within_at_iff_of_mem_source {x' : M} {y : M'} (hx : x' ∈ (charted_space.chart_at H x).source)\n    (hy : f x' ∈ (charted_space.chart_at H' y).source) :\n    mdifferentiable_within_at I I' f s x' ↔\n      ContinuousWithinAt f s x' ∧\n        differentiable_within_at 𝕜 (ext_chart_at I' y ∘ f ∘ (ext_chart_at I x).symm)\n          («expr ⁻¹' » (ext_chart_at I x).symm s ∩ Set.range I) ((ext_chart_at I x) x') :=\n  (differentiable_within_at_local_invariant_prop I I').lift_prop_within_at_indep_chart\n    (StructureGroupoid.chart_mem_maximalAtlas _ x) hx (StructureGroupoid.chart_mem_maximalAtlas _ y) hy\n#align mdifferentiable_within_at_iff_of_mem_source mdifferentiable_within_at_iff_of_mem_source\n\n",
 "mdifferentiable_within_at_iff_lift_prop_within_at":
 "theorem mdifferentiable_within_at_iff_lift_prop_within_at (f : M → M') (s : Set M) (x : M) :\n    mdifferentiable_within_at I I' f s x ↔ LiftPropWithinAt (differentiable_within_at_prop I I') f s x := by rfl\n#align mdifferentiable_within_at_iff_lift_prop_within_at mdifferentiable_within_at_iff_lift_prop_within_at\n\n",
 "mdifferentiable_within_at_iff_differentiable_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/-- For maps between vector spaces, `mdifferentiable_within_at` and `fdifferentiable_within_at`\ncoincide -/\ntheorem mdifferentiable_within_at_iff_differentiable_within_at :\n    mdifferentiable_within_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x ↔\n      differentiable_within_at 𝕜 f s x :=\n  by\n  simp only [mdifferentiable_within_at, mfld_simps]\n  exact ⟨fun H => H.2, fun H => ⟨H.continuous_within_at, H⟩⟩\n#align mdifferentiable_within_at_iff_differentiable_within_at mdifferentiable_within_at_iff_differentiable_within_at\n\n",
 "mdifferentiable_within_at_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.mdifferentiable_within_at_iff (h₁ : «expr =ᶠ[ ] » f₁ (nhds_within s x) f)\n    (hx : f₁ x = f x) : mdifferentiable_within_at I I' f s x ↔ mdifferentiable_within_at I I' f₁ s x :=\n  by\n  constructor\n  · intro h\n    apply h.congr_of_eventually_eq h₁ hx\n  · intro h\n    apply h.congr_of_eventually_eq _ hx.symm\n    apply h₁.mono\n    intro y\n    apply Eq.symm\n#align filter.eventually_eq.mdifferentiable_within_at_iff filter.eventually_eq.mdifferentiable_within_at_iff\n\n",
 "mdifferentiable_within_at_id":
 "theorem mdifferentiable_within_at_id : mdifferentiable_within_at I I (@id M) s x :=\n  (mdifferentiable_at_id I).mdifferentiable_within_at\n#align mdifferentiable_within_at_id mdifferentiable_within_at_id\n\n",
 "mdifferentiable_within_at_const":
 "theorem mdifferentiable_within_at_const : mdifferentiable_within_at I I' (fun y : M => c) s x :=\n  (mdifferentiable_at_const I I').mdifferentiable_within_at\n#align mdifferentiable_within_at_const mdifferentiable_within_at_const\n\n",
 "mdifferentiable_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\nprotected theorem mdifferentiable_within_at {s x} : mdifferentiable_within_at I (model_with_corners_self 𝕜 E) I s x :=\n  I.has_mfderiv_within_at.mdifferentiable_within_at\n#align mdifferentiable_within_at mdifferentiable_within_at\n\n",
 "mdifferentiable_on_univ":
 "theorem mdifferentiable_on_univ : mdifferentiable_on I I' f univ ↔ mdifferentiable I I' f :=\n  by\n  simp only [mdifferentiable_on, mdifferentiable_within_at_univ, mfld_simps]\n  rfl\n#align mdifferentiable_on_univ mdifferentiable_on_univ\n\n",
 "mdifferentiable_on_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem mdifferentiable_on_symm : mdifferentiable_on (model_with_corners_self 𝕜 E) I I.symm (range I) := fun x hx =>\n  (I.has_mfderiv_within_at_symm hx).mdifferentiable_within_at\n#align mdifferentiable_on_symm mdifferentiable_on_symm\n\n",
 "mdifferentiable_on_of_locally_mdifferentiable_on":
 "theorem mdifferentiable_on_of_locally_mdifferentiable_on\n    (h : ∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ mdifferentiable_on I I' f (s ∩ u)) : mdifferentiable_on I I' f s :=\n  by\n  intro x xs\n  rcases h x xs with ⟨t, t_open, xt, ht⟩\n  exact (mdifferentiable_within_at_inter (IsOpen.mem_nhds t_open xt)).1 (ht x ⟨xs, xt⟩)\n#align mdifferentiable_on_of_locally_mdifferentiable_on mdifferentiable_on_of_locally_mdifferentiable_on\n\n",
 "mdifferentiable_on_iff_differentiable_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/-- For maps between vector spaces, `mdifferentiable_on` and `differentiable_on` coincide -/\ntheorem mdifferentiable_on_iff_differentiable_on :\n    mdifferentiable_on (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s ↔ differentiable_on 𝕜 f s := by\n  simp only [mdifferentiable_on, differentiable_on, mdifferentiable_within_at_iff_differentiable_within_at]\n#align mdifferentiable_on_iff_differentiable_on mdifferentiable_on_iff_differentiable_on\n\n",
 "mdifferentiable_on_id":
 "theorem mdifferentiable_on_id : mdifferentiable_on I I (@id M) s :=\n  (mdifferentiable_id I).mdifferentiable_on\n#align mdifferentiable_on_id mdifferentiable_on_id\n\n",
 "mdifferentiable_on_ext_chart_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem mdifferentiable_on_ext_chart_at :\n    mdifferentiable_on I (model_with_corners_self 𝕜 E) (ext_chart_at I x) (chart_at H x).source := fun y hy =>\n  (has_mfderiv_within_at_ext_chart_at I hy).mdifferentiable_within_at\n#align mdifferentiable_on_ext_chart_at mdifferentiable_on_ext_chart_at\n\n",
 "mdifferentiable_on_const":
 "theorem mdifferentiable_on_const : mdifferentiable_on I I' (fun y : M => c) s :=\n  (mdifferentiable_const I I').mdifferentiable_on\n#align mdifferentiable_on_const mdifferentiable_on_const\n\n",
 "mdifferentiable_on_atlas_symm":
 "theorem mdifferentiable_on_atlas_symm (h : e ∈ atlas H M) : mdifferentiable_on I I e.symm e.target := fun x hx =>\n  (mdifferentiable_at_atlas_symm I h hx).mdifferentiable_within_at\n#align mdifferentiable_on_atlas_symm mdifferentiable_on_atlas_symm\n\n",
 "mdifferentiable_on_atlas":
 "theorem mdifferentiable_on_atlas (h : e ∈ atlas H M) : mdifferentiable_on I I e e.source := fun x hx =>\n  (mdifferentiable_at_atlas I h hx).mdifferentiable_within_at\n#align mdifferentiable_on_atlas mdifferentiable_on_atlas\n\n",
 "mdifferentiable_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\nprotected theorem mdifferentiable_on {s} : mdifferentiable_on I (model_with_corners_self 𝕜 E) I s := fun x hx =>\n  I.mdifferentiable_within_at\n#align mdifferentiable_on mdifferentiable_on\n\n",
 "mdifferentiable_of_mem_atlas":
 "theorem mdifferentiable_of_mem_atlas (h : e ∈ atlas H M) : e.mdifferentiable I I :=\n  ⟨mdifferentiable_on_atlas I h, mdifferentiable_on_atlas_symm I h⟩\n#align mdifferentiable_of_mem_atlas mdifferentiable_of_mem_atlas\n\n",
 "mdifferentiable_iff_differentiable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/-- For maps between vector spaces, `mdifferentiable` and `differentiable` coincide -/\ntheorem mdifferentiable_iff_differentiable :\n    mdifferentiable (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f ↔ differentiable 𝕜 f := by\n  simp only [mdifferentiable, differentiable, mdifferentiable_at_iff_differentiable_at]\n#align mdifferentiable_iff_differentiable mdifferentiable_iff_differentiable\n\n",
 "mdifferentiable_id":
 "theorem mdifferentiable_id : mdifferentiable I I (@id M) := fun x => mdifferentiable_at_id I\n#align mdifferentiable_id mdifferentiable_id\n\n",
 "mdifferentiable_const":
 "theorem mdifferentiable_const : mdifferentiable I I' fun y : M => c := fun x => mdifferentiable_at_const I I'\n#align mdifferentiable_const mdifferentiable_const\n\n",
 "mdifferentiable_chart":
 "theorem mdifferentiable_chart (x : M) : (chart_at H x).mdifferentiable I I :=\n  mdifferentiable_of_mem_atlas _ (chart_mem_atlas _ _)\n#align mdifferentiable_chart mdifferentiable_chart\n\n",
 "mdifferentiable_at_symm":
 "theorem mdifferentiable_at_symm {x : M'} (hx : x ∈ e.target) : mdifferentiable_at I' I e.symm x :=\n  (he.2 x hx).mdifferentiable_at (IsOpen.mem_nhds e.open_target hx)\n#align mdifferentiable_at_symm mdifferentiable_at_symm\n\n",
 "mdifferentiable_at_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem mdifferentiable_at_neg :\n    mdifferentiable_at I (model_with_corners_self 𝕜 E') (-f) z ↔\n      mdifferentiable_at I (model_with_corners_self 𝕜 E') f z :=\n  ⟨fun hf => by convert hf.neg <;> rw [neg_neg], fun hf => hf.neg⟩\n#align mdifferentiable_at_neg mdifferentiable_at_neg\n\n",
 "mdifferentiable_at_iff_of_mem_source":
 "theorem mdifferentiable_at_iff_of_mem_source {x' : M} {y : M'} (hx : x' ∈ (charted_space.chart_at H x).source)\n    (hy : f x' ∈ (charted_space.chart_at H' y).source) :\n    mdifferentiable_at I I' f x' ↔\n      ContinuousAt f x' ∧\n        differentiable_within_at 𝕜 (ext_chart_at I' y ∘ f ∘ (ext_chart_at I x).symm) (Set.range I)\n          ((ext_chart_at I x) x') :=\n  mdifferentiable_within_at_univ.symm.trans <|\n    (mdifferentiable_within_at_iff_of_mem_source hx hy).trans <| by\n      rw [continuousWithinAt_univ, Set.preimage_univ, Set.univ_inter]\n#align mdifferentiable_at_iff_of_mem_source mdifferentiable_at_iff_of_mem_source\n\n",
 "mdifferentiable_at_iff_lift_prop_at":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]] -/\ntheorem mdifferentiable_at_iff_lift_prop_at (f : M → M') (x : M) :\n    mdifferentiable_at I I' f x ↔ LiftPropAt (differentiable_within_at_prop I I') f x :=\n  by\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr «expr ∧ »(_, _)]]\"\n  · rw [continuousWithinAt_univ]\n  · simp [differentiable_within_at_prop, Set.univ_inter]\n#align mdifferentiable_at_iff_lift_prop_at mdifferentiable_at_iff_lift_prop_at\n\n",
 "mdifferentiable_at_iff_differentiable_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/-- For maps between vector spaces, `mdifferentiable_at` and `differentiable_at` coincide -/\ntheorem mdifferentiable_at_iff_differentiable_at :\n    mdifferentiable_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x ↔ differentiable_at 𝕜 f x :=\n  by\n  simp only [mdifferentiable_at, differentiable_within_at_univ, mfld_simps]\n  exact ⟨fun H => H.2, fun H => ⟨H.continuous_at, H⟩⟩\n#align mdifferentiable_at_iff_differentiable_at mdifferentiable_at_iff_differentiable_at\n\n",
 "mdifferentiable_at_id":
 "theorem mdifferentiable_at_id : mdifferentiable_at I I (@id M) x :=\n  (has_mfderiv_at_id I x).mdifferentiable_at\n#align mdifferentiable_at_id mdifferentiable_at_id\n\n",
 "mdifferentiable_at_ext_chart_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem mdifferentiable_at_ext_chart_at (h : y ∈ (chart_at H x).source) :\n    mdifferentiable_at I (model_with_corners_self 𝕜 E) (ext_chart_at I x) y :=\n  (has_mfderiv_at_ext_chart_at I h).mdifferentiable_at\n#align mdifferentiable_at_ext_chart_at mdifferentiable_at_ext_chart_at\n\n",
 "mdifferentiable_at_const":
 "theorem mdifferentiable_at_const : mdifferentiable_at I I' (fun y : M => c) x :=\n  (has_mfderiv_at_const I I' c x).mdifferentiable_at\n#align mdifferentiable_at_const mdifferentiable_at_const\n\n",
 "mdifferentiable_at_atlas_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `with_top.nat.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `with_top.nat.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mdifferentiable_at_atlas_symm (h : e ∈ atlas H M) {x : H} (hx : x ∈ e.target) :\n    mdifferentiable_at I I e.symm x :=\n  by\n  refine' ⟨(e.continuous_on_symm x hx).continuous_at (IsOpen.mem_nhds e.open_target hx), _⟩\n  have mem : I x ∈ «expr ⁻¹' » I.symm (local_homeomorph.trans e.symm (chart_at H (e.symm x))).source ∩ range I := by\n    simp only [hx, mfld_simps]\n  have : e.symm.trans (chart_at H (e.symm x)) ∈ cont_diff_groupoid (with_top.nat.top) I :=\n    has_groupoid.compatible _ h (chart_mem_atlas H _)\n  have A :\n    cont_diff_on 𝕜 (with_top.nat.top) (I ∘ e.symm.trans (chart_at H (e.symm x)) ∘ I.symm)\n      («expr ⁻¹' » I.symm (e.symm.trans (chart_at H (e.symm x))).source ∩ range I) :=\n    this.1\n  have B := A.differentiable_on le_top (I x) mem\n  simp only [mfld_simps] at B\n  rw [inter_comm, differentiable_within_at_inter] at B\n  · simpa only [mfld_simps]\n  · apply IsOpen.mem_nhds ((local_homeomorph.open_source _).preimage I.continuous_symm) mem.1\n#align mdifferentiable_at_atlas_symm mdifferentiable_at_atlas_symm\n\n",
 "mdifferentiable_at_atlas":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `local_homeomorph.trans -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `with_top.nat.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `with_top.nat.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mdifferentiable_at_atlas (h : e ∈ atlas H M) {x : M} (hx : x ∈ e.source) : mdifferentiable_at I I e x :=\n  by\n  refine' ⟨(e.continuous_on x hx).continuous_at (IsOpen.mem_nhds e.open_source hx), _⟩\n  have mem :\n    I ((chart_at H x : M → H) x) ∈ «expr ⁻¹' » I.symm (local_homeomorph.trans (chart_at H x).symm e).source ∩ range I :=\n    by simp only [hx, mfld_simps]\n  have : (chart_at H x).symm.trans e ∈ cont_diff_groupoid (with_top.nat.top) I :=\n    has_groupoid.compatible _ (chart_mem_atlas H x) h\n  have A :\n    cont_diff_on 𝕜 (with_top.nat.top) (I ∘ (chart_at H x).symm.trans e ∘ I.symm)\n      («expr ⁻¹' » I.symm ((chart_at H x).symm.trans e).source ∩ range I) :=\n    this.1\n  have B := A.differentiable_on le_top (I ((chart_at H x : M → H) x)) mem\n  simp only [mfld_simps] at B\n  rw [inter_comm, differentiable_within_at_inter] at B\n  · simpa only [mfld_simps]\n  · apply IsOpen.mem_nhds ((local_homeomorph.open_source _).preimage I.continuous_symm) mem.1\n#align mdifferentiable_at_atlas mdifferentiable_at_atlas\n\n",
 "mdifferentiable_at":
 "protected theorem mdifferentiable_at {x : M} (hx : x ∈ e.source) : mdifferentiable_at I I' e x :=\n  (he.1 x hx).mdifferentiable_at (IsOpen.mem_nhds e.open_source hx)\n#align mdifferentiable_at mdifferentiable_at\n\n",
 "mdifferentiable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\nprotected theorem mdifferentiable : mdifferentiable I (model_with_corners_self 𝕜 E) I := fun x => I.mdifferentiable_at\n#align mdifferentiable mdifferentiable\n\n",
 "ker_mfderiv_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_mfderiv_eq_bot {x : M} (hx : x ∈ e.source) : LinearMap.ker (mfderiv I I' e x) = «expr⊥» :=\n  (he.mfderiv hx).to_linear_equiv.ker\n#align ker_mfderiv_eq_bot ker_mfderiv_eq_bot\n\n",
 "inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem unique_mdiff_within_at.inter' (hs : unique_mdiff_within_at I s x) (ht : t ∈ nhds_within s x) :\n    unique_mdiff_within_at I (s ∩ t) x :=\n  by\n  rw [unique_mdiff_within_at, ext_chart_at_preimage_inter_eq]\n  exact unique_diff_within_at.inter' hs (ext_chart_at_preimage_mem_nhds_within I x ht)\n#align unique_mdiff_within_at.inter' unique_mdiff_within_at.inter'\n\n",
 "inter":
 "theorem unique_mdiff_on.inter (hs : unique_mdiff_on I s) (ht : IsOpen t) : unique_mdiff_on I (s ∩ t) := fun x hx =>\n  unique_mdiff_within_at.inter (hs _ hx.1) (IsOpen.mem_nhds ht hx.2)\n#align unique_mdiff_on.inter unique_mdiff_on.inter\n\n",
 "has_mfderiv_within_at_univ":
 "@[simp, mfld_simps]\ntheorem has_mfderiv_within_at_univ : has_mfderiv_within_at I I' f univ x f' ↔ has_mfderiv_at I I' f x f' := by\n  simp only [has_mfderiv_within_at, has_mfderiv_at, continuousWithinAt_univ, mfld_simps]\n#align has_mfderiv_within_at_univ has_mfderiv_within_at_univ\n\n",
 "has_mfderiv_within_at_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem has_mfderiv_within_at_symm {x} (hx : x ∈ range I) :\n    has_mfderiv_within_at (model_with_corners_self 𝕜 E) I I.symm (range I) x (ContinuousLinearMap.id _ _) :=\n  ⟨I.continuous_within_at_symm,\n    (has_fderiv_within_at_id _ _).congr' (fun y hy => I.right_inv_on hy.1) ⟨hx, mem_range_self _⟩⟩\n#align has_mfderiv_within_at_symm has_mfderiv_within_at_symm\n\n",
 "has_mfderiv_within_at_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_mfderiv_within_at_inter' (h : t ∈ nhds_within s x) :\n    has_mfderiv_within_at I I' f (s ∩ t) x f' ↔ has_mfderiv_within_at I I' f s x f' :=\n  by\n  rw [has_mfderiv_within_at, has_mfderiv_within_at, ext_chart_at_preimage_inter_eq, has_fderiv_within_at_inter',\n    continuousWithinAt_inter' h]\n  exact ext_chart_at_preimage_mem_nhds_within I x h\n#align has_mfderiv_within_at_inter' has_mfderiv_within_at_inter'\n\n",
 "has_mfderiv_within_at_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_mfderiv_within_at_inter (h : t ∈ (nhds) x) :\n    has_mfderiv_within_at I I' f (s ∩ t) x f' ↔ has_mfderiv_within_at I I' f s x f' :=\n  by\n  rw [has_mfderiv_within_at, has_mfderiv_within_at, ext_chart_at_preimage_inter_eq, has_fderiv_within_at_inter,\n    continuousWithinAt_inter h]\n  exact ext_chart_at_preimage_mem_nhds I x h\n#align has_mfderiv_within_at_inter has_mfderiv_within_at_inter\n\n",
 "has_mfderiv_within_at_iff_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem has_mfderiv_within_at_iff_has_fderiv_within_at {f'} :\n    has_mfderiv_within_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x f' ↔\n      has_fderiv_within_at f f' s x :=\n  by\n  simpa only [has_mfderiv_within_at, and_iff_right_iff_imp, mfld_simps] using has_fderiv_within_at.continuous_within_at\n#align has_mfderiv_within_at_iff_has_fderiv_within_at has_mfderiv_within_at_iff_has_fderiv_within_at\n\n",
 "has_mfderiv_within_at_id":
 "theorem has_mfderiv_within_at_id (s : Set M) (x : M) :\n    has_mfderiv_within_at I I (@id M) s x (ContinuousLinearMap.id 𝕜 (tangent_space I x)) :=\n  (has_mfderiv_at_id I x).has_mfderiv_within_at\n#align has_mfderiv_within_at_id has_mfderiv_within_at_id\n\n",
 "has_mfderiv_within_at_ext_chart_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem has_mfderiv_within_at_ext_chart_at (h : y ∈ (chart_at H x).source) :\n    has_mfderiv_within_at I (model_with_corners_self 𝕜 E) (ext_chart_at I x) s y (mfderiv I I (chart_at H x) y : _) :=\n  (has_mfderiv_at_ext_chart_at I h).has_mfderiv_within_at\n#align has_mfderiv_within_at_ext_chart_at has_mfderiv_within_at_ext_chart_at\n\n",
 "has_mfderiv_within_at_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_mfderiv_within_at_const (c : M') (s : Set M) (x : M) :\n    has_mfderiv_within_at I I' (fun y : M => c) s x (0 : «expr →L[ ] » (tangent_space I x) 𝕜 (tangent_space I' c)) :=\n  (has_mfderiv_at_const I I' c x).has_mfderiv_within_at\n#align has_mfderiv_within_at_const has_mfderiv_within_at_const\n\n",
 "has_mfderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\nprotected theorem has_mfderiv_within_at {s x} :\n    has_mfderiv_within_at I (model_with_corners_self 𝕜 E) I s x (ContinuousLinearMap.id _ _) :=\n  I.has_mfderiv_at.has_mfderiv_within_at\n#align has_mfderiv_within_at has_mfderiv_within_at\n\n",
 "has_mfderiv_at_unique":
 "theorem has_mfderiv_at_unique (h₀ : has_mfderiv_at I I' f x f₀') (h₁ : has_mfderiv_at I I' f x f₁') : f₀' = f₁' :=\n  by\n  rw [← has_mfderiv_within_at_univ] at h₀ h₁\n  exact (unique_mdiff_within_at_univ I).eq h₀ h₁\n#align has_mfderiv_at_unique has_mfderiv_at_unique\n\n",
 "has_mfderiv_at_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem has_mfderiv_at_neg :\n    has_mfderiv_at I (model_with_corners_self 𝕜 E') (-f) z (-f') ↔\n      has_mfderiv_at I (model_with_corners_self 𝕜 E') f z f' :=\n  ⟨fun hf => by convert hf.neg <;> rw [neg_neg], fun hf => hf.neg⟩\n#align has_mfderiv_at_neg has_mfderiv_at_neg\n\n",
 "has_mfderiv_at_iff_has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem has_mfderiv_at_iff_has_fderiv_at {f'} :\n    has_mfderiv_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x f' ↔ has_fderiv_at f f' x := by\n  rw [← has_mfderiv_within_at_univ, has_mfderiv_within_at_iff_has_fderiv_within_at, has_fderiv_within_at_univ]\n#align has_mfderiv_at_iff_has_fderiv_at has_mfderiv_at_iff_has_fderiv_at\n\n",
 "has_mfderiv_at_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_mfderiv_at_id (x : M) : has_mfderiv_at I I (@id M) x (ContinuousLinearMap.id 𝕜 (tangent_space I x)) :=\n  by\n  refine' ⟨continuous_id.continuous_at, _⟩\n  have :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within (range I) ((ext_chart_at I x) x)) ((ext_chart_at I x ∘ (ext_chart_at I x).symm) y = id y) :=\n    by\n    apply Filter.mem_of_superset (ext_chart_at_target_mem_nhds_within I x)\n    mfld_set_tac\n  apply has_fderiv_within_at.congr_of_eventually_eq (has_fderiv_within_at_id _ _) this\n  simp only [mfld_simps]\n#align has_mfderiv_at_id has_mfderiv_at_id\n\n",
 "has_mfderiv_at_ext_chart_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem has_mfderiv_at_ext_chart_at (h : y ∈ (chart_at H x).source) :\n    has_mfderiv_at I (model_with_corners_self 𝕜 E) (ext_chart_at I x) y (mfderiv I I (chart_at H x) y : _) :=\n  I.has_mfderiv_at.comp y ((mdifferentiable_chart I x).mdifferentiable_at h).has_mfderiv_at\n#align has_mfderiv_at_ext_chart_at has_mfderiv_at_ext_chart_at\n\n",
 "has_mfderiv_at_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_mfderiv_at_const (c : M') (x : M) :\n    has_mfderiv_at I I' (fun y : M => c) x (0 : «expr →L[ ] » (tangent_space I x) 𝕜 (tangent_space I' c)) :=\n  by\n  refine' ⟨continuous_const.continuous_at, _⟩\n  simp only [written_in_ext_chart_at, (· ∘ ·), has_fderiv_within_at_const]\n#align has_mfderiv_at_const has_mfderiv_at_const\n\n",
 "has_mfderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\nprotected theorem has_mfderiv_at {x} :\n    has_mfderiv_at I (model_with_corners_self 𝕜 E) I x (ContinuousLinearMap.id _ _) :=\n  ⟨I.continuous_at, (has_fderiv_within_at_id _ _).congr' I.right_inv_on (mem_range_self _)⟩\n#align has_mfderiv_at has_mfderiv_at\n\n",
 "eq":
 "theorem unique_mdiff_on.eq (U : unique_mdiff_on I s) (hx : x ∈ s) (h : has_mfderiv_within_at I I' f s x f')\n    (h₁ : has_mfderiv_within_at I I' f s x f₁') : f' = f₁' :=\n  unique_mdiff_within_at.eq (U _ hx) h h₁\n#align unique_mdiff_on.eq unique_mdiff_on.eq\n\n",
 "differentiable_within_at_local_invariant_prop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2020 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel, Floris van Doorn\n-/\n/-- Being differentiable in the model space is a local property, invariant under smooth maps.\nTherefore, it will lift nicely to manifolds. -/\ntheorem differentiable_within_at_local_invariant_prop :\n    (cont_diff_groupoid («expr⊤») I).local_invariant_prop (cont_diff_groupoid («expr⊤») I')\n      (differentiable_within_at_prop I I') :=\n  { is_local := by\n      intro s x u f u_open xu\n      have : «expr ⁻¹' » I.symm (s ∩ u) ∩ Set.range I = «expr ⁻¹' » I.symm s ∩ Set.range I ∩ «expr ⁻¹' » I.symm u := by\n        simp only [Set.inter_right_comm, Set.preimage_inter]\n      rw [differentiable_within_at_prop, differentiable_within_at_prop, this]\n      symm\n      apply differentiable_within_at_inter\n      have : u ∈ (nhds) (I.symm (I x)) := by\n        rw [model_with_corners.left_inv]\n        exact IsOpen.mem_nhds u_open xu\n      apply ContinuousAt.preimage_mem_nhds I.continuous_symm.continuous_at this\n    right_invariance' := by\n      intro s x f e he hx h\n      rw [differentiable_within_at_prop] at h⊢\n      have : I x = (I ∘ e.symm ∘ I.symm) (I (e x)) := by simp only [hx, mfld_simps]\n      rw [this] at h\n      have : I (e x) ∈ «expr ⁻¹' » I.symm e.target ∩ Set.range I := by simp only [hx, mfld_simps]\n      have := (mem_groupoid_of_pregroupoid.2 he).2.cont_diff_within_at this\n      convert(h.comp' _ (this.differentiable_within_at le_top)).mono_of_mem _ using 1\n      · ext y\n        simp only [mfld_simps]\n      refine'\n        mem_nhds_within.mpr\n          ⟨«expr ⁻¹' » I.symm e.target, e.open_target.preimage I.continuous_symm, by\n            simp_rw [Set.mem_preimage, I.left_inv, e.maps_to hx], _⟩\n      mfld_set_tac\n    congr_of_forall := by\n      intro s x f g h hx hf\n      apply hf.congr\n      · intro y hy\n        simp only [mfld_simps] at hy\n        simp only [h, hy, mfld_simps]\n      · simp only [hx, mfld_simps]\n    left_invariance' := by\n      intro s x f e' he' hs hx h\n      rw [differentiable_within_at_prop] at h⊢\n      have A : (I' ∘ f ∘ I.symm) (I x) ∈ «expr ⁻¹' » I'.symm e'.source ∩ Set.range I' := by simp only [hx, mfld_simps]\n      have := (mem_groupoid_of_pregroupoid.2 he').1.cont_diff_within_at A\n      convert(this.differentiable_within_at le_top).comp _ h _\n      · ext y\n        simp only [mfld_simps]\n      · intro y hy\n        simp only [mfld_simps] at hy\n        simpa only [hy, mfld_simps] using hs hy.1 }\n#align differentiable_within_at_local_invariant_prop differentiable_within_at_local_invariant_prop\n\n",
 "continuous_within_at":
 "theorem mdifferentiable_within_at.continuous_within_at (h : mdifferentiable_within_at I I' f s x) :\n    ContinuousWithinAt f s x :=\n  h.1\n#align mdifferentiable_within_at.continuous_within_at mdifferentiable_within_at.continuous_within_at\n\n",
 "continuous_on":
 "theorem mdifferentiable_on.continuous_on (h : mdifferentiable_on I I' f s) : ContinuousOn f s := fun x hx =>\n  (h x hx).continuous_within_at\n#align mdifferentiable_on.continuous_on mdifferentiable_on.continuous_on\n\n",
 "continuous_at":
 "theorem mdifferentiable_at.continuous_at (h : mdifferentiable_at I I' f x) : ContinuousAt f x :=\n  h.1\n#align mdifferentiable_at.continuous_at mdifferentiable_at.continuous_at\n\n",
 "continuous":
 "theorem mdifferentiable.continuous (h : mdifferentiable I I' f) : Continuous f :=\n  continuous_iff_continuousAt.2 fun x => (h x).continuous_at\n#align mdifferentiable.continuous mdifferentiable.continuous\n\n",
 "const_smul_mfderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem const_smul_mfderiv (hf : mdifferentiable_at I (model_with_corners_self 𝕜 E') f z) (s : 𝕜) :\n    (mfderiv I (model_with_corners_self 𝕜 E') («expr • » s f) z : «expr →L[ ] » (tangent_space I z) 𝕜 E') =\n      («expr • » s (mfderiv I (model_with_corners_self 𝕜 E') f z) : «expr →L[ ] » (tangent_space I z) 𝕜 E') :=\n  (hf.has_mfderiv_at.const_smul s).mfderiv\n#align const_smul_mfderiv const_smul_mfderiv\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mdifferentiable.const_smul (s : 𝕜) (hf : mdifferentiable I (model_with_corners_self 𝕜 E') f) :\n    mdifferentiable I (model_with_corners_self 𝕜 E') («expr • » s f) := fun x => (hf x).const_smul s\n#align mdifferentiable.const_smul mdifferentiable.const_smul\n\n",
 "congr_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mdifferentiable_at.congr_of_eventually_eq (h : mdifferentiable_at I I' f x)\n    (hL : «expr =ᶠ[ ] » f₁ ((nhds) x) f) : mdifferentiable_at I I' f₁ x :=\n  (h.has_mfderiv_at.congr_of_eventually_eq hL).mdifferentiable_at\n#align mdifferentiable_at.congr_of_eventually_eq mdifferentiable_at.congr_of_eventually_eq\n\n",
 "congr_mono":
 "theorem mdifferentiable_on.congr_mono (h : mdifferentiable_on I I' f s) (h' : ∀ x ∈ t, f₁ x = f x) (h₁ : t ⊆ s) :\n    mdifferentiable_on I I' f₁ t := fun x hx => (h x (h₁ hx)).congr_mono h' (h' x hx) h₁\n#align mdifferentiable_on.congr_mono mdifferentiable_on.congr_mono\n\n",
 "congr":
 "theorem mdifferentiable_within_at.congr (h : mdifferentiable_within_at I I' f s x) (ht : ∀ x ∈ s, f₁ x = f x)\n    (hx : f₁ x = f x) : mdifferentiable_within_at I I' f₁ s x :=\n  (has_mfderiv_within_at.congr_mono h.has_mfderiv_within_at ht hx (Subset.refl _)).mdifferentiable_within_at\n#align mdifferentiable_within_at.congr mdifferentiable_within_at.congr\n\n",
 "comp_symm_deriv":
 "theorem comp_symm_deriv {x : M'} (hx : x ∈ e.target) :\n    (mfderiv I I' e (e.symm x)).comp (mfderiv I' I e.symm x) = ContinuousLinearMap.id 𝕜 (tangent_space I' x) :=\n  he.symm.symm_comp_deriv hx\n#align comp_symm_deriv comp_symm_deriv\n\n",
 "comp_has_mfderiv_within_at":
 "theorem has_mfderiv_at.comp_has_mfderiv_within_at (hg : has_mfderiv_at I' I'' g (f x) g')\n    (hf : has_mfderiv_within_at I I' f s x f') : has_mfderiv_within_at I I'' (g ∘ f) s x (g'.comp f') :=\n  by\n  rw [← has_mfderiv_within_at_univ] at *\n  exact has_mfderiv_within_at.comp x (hg.mono (subset_univ _)) hf subset_preimage_univ\n#align has_mfderiv_at.comp_has_mfderiv_within_at has_mfderiv_at.comp_has_mfderiv_within_at\n\n",
 "comp":
 "theorem mdifferentiable.comp (hg : mdifferentiable I' I'' g) (hf : mdifferentiable I I' f) :\n    mdifferentiable I I'' (g ∘ f) := fun x => mdifferentiable_at.comp x (hg (f x)) (hf x)\n#align mdifferentiable.comp mdifferentiable.comp\n\n",
 "add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `model_with_corners_self -/\ntheorem mdifferentiable.add (hf : mdifferentiable I (model_with_corners_self 𝕜 E') f)\n    (hg : mdifferentiable I (model_with_corners_self 𝕜 E') g) :\n    mdifferentiable I (model_with_corners_self 𝕜 E') (f + g) := fun x => (hf x).add (hg x)\n#align mdifferentiable.add mdifferentiable.add\n\n"}