{"wbtw_second_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- If the vector passed to `second_inter` is given by a subtraction involving the point in\n`second_inter`, and the second point is not outside the sphere, the second point is weakly\nbetween the first point and the result of `second_inter`. -/\ntheorem sphere.wbtw_second_inter {s : sphere P} {p p' : P} (hp : p ∈ s) (hp' : dist p' s.center ≤ s.radius) :\n    wbtw (exprℝ) p p' (s.second_inter p («expr -ᵥ » p' p)) :=\n  by\n  by_cases h : p' = p; · simp [h]\n  refine'\n    wbtw_of_collinear_of_dist_center_le_radius (s.second_inter_collinear p p') hp hp' ((sphere.second_inter_mem _).2 hp)\n      _\n  intro he\n  rw [eq_comm, sphere.second_inter_eq_self_iff, ← neg_neg («expr -ᵥ » p' p), inner_neg_left, neg_vsub_eq_vsub_rev,\n    neg_eq_zero, eq_comm] at he\n  exact ((inner_pos_or_eq_of_dist_le_radius hp hp').resolve_right (ne.symm h)).ne he\n#align sphere.wbtw_second_inter sphere.wbtw_second_inter\n\n",
 "wbtw_of_collinear_of_dist_center_le_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Given three collinear points, two on a sphere and one not outside it, the one not outside it\nis weakly between the other two points. -/\ntheorem wbtw_of_collinear_of_dist_center_le_radius {s : sphere P} {p₁ p₂ p₃ : P}\n    (h : collinear (exprℝ) ({p₁, p₂, p₃} : set P)) (hp₁ : p₁ ∈ s) (hp₂ : dist p₂ s.center ≤ s.radius) (hp₃ : p₃ ∈ s)\n    (hp₁p₃ : p₁ ≠ p₃) : wbtw (exprℝ) p₁ p₂ p₃ :=\n  h.wbtw_of_dist_eq_of_dist_le hp₁ hp₂ hp₃ hp₁p₃\n#align wbtw_of_collinear_of_dist_center_le_radius wbtw_of_collinear_of_dist_center_le_radius\n\n",
 "vsub_orthogonal_projection_mem_direction_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- Subtracting the `orthogonal_projection` from `p` produces a result\nin the orthogonal direction. -/\ntheorem vsub_orthogonal_projection_mem_direction_orthogonal (s : affine_subspace (exprℝ) P) [nonempty s]\n    [complete_space s.direction] (p : P) : «expr -ᵥ » p (orthogonal_projection s p) ∈ «expr ᗮ» s.direction :=\n  direction_mk' p («expr ᗮ» s.direction) ▸\n    vsub_mem_direction (self_mem_mk' _ _) (orthogonal_projection_mem_orthogonal s p)\n#align vsub_orthogonal_projection_mem_direction_orthogonal vsub_orthogonal_projection_mem_direction_orthogonal\n\n",
 "vsub_orthogonal_projection_mem_direction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Subtracting the `orthogonal_projection` from a point in the given\nsubspace produces a result in the direction of the given subspace. -/\ntheorem vsub_orthogonal_projection_mem_direction {s : affine_subspace (exprℝ) P} [nonempty s]\n    [complete_space s.direction] {p1 : P} (p2 : P) (hp1 : p1 ∈ s) :\n    ↑(«expr -ᵥ » (⟨p1, hp1⟩ : s) (orthogonal_projection s p2) : s.direction) ∈ s.direction :=\n  («expr -ᵥ » (⟨p1, hp1⟩ : s) (orthogonal_projection s p2) : s.direction).2\n#align vsub_orthogonal_projection_mem_direction vsub_orthogonal_projection_mem_direction\n\n",
 "subset_sphere":
 "theorem subset_sphere {ps : set P} {s : sphere P} : ps ⊆ s ↔ ∀ p ∈ ps, p ∈ s :=\n  iff.rfl\n#align subset_sphere subset_sphere\n\n",
 "subset":
 "/-- A subset of a concyclic set is concyclic. -/\ntheorem concyclic.subset {ps₁ ps₂ : set P} (hs : ps₁ ⊆ ps₂) (h : concyclic ps₂) : concyclic ps₁ :=\n  ⟨h.1.subset hs, h.2.subset hs⟩\n#align concyclic.subset concyclic.subset\n\n",
 "second_inter_zero":
 "/-- If the vector is zero, `second_inter` gives the original point. -/\n@[simp]\ntheorem sphere.second_inter_zero (s : sphere P) (p : P) : s.second_inter p (0 : V) = p := by simp [sphere.second_inter]\n#align sphere.second_inter_zero sphere.second_inter_zero\n\n",
 "second_inter_vsub_mem_affine_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If the vector passed to `second_inter` is given by a subtraction involving the point in\n`second_inter`, the result lies in the span of the two points. -/\ntheorem sphere.second_inter_vsub_mem_affine_span (s : sphere P) (p₁ p₂ : P) :\n    s.second_inter p₁ («expr -ᵥ » p₂ p₁) ∈ «exprline[ , , ]» (exprℝ) p₁ p₂ :=\n  smul_vsub_vadd_mem_affine_span_pair _ _ _\n#align sphere.second_inter_vsub_mem_affine_span sphere.second_inter_vsub_mem_affine_span\n\n",
 "second_inter_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- `second_inter` is unchanged by multiplying the vector by a nonzero real. -/\n@[simp]\ntheorem sphere.second_inter_smul (s : sphere P) (p : P) (v : V) {r : exprℝ} (hr : r ≠ 0) :\n    s.second_inter p («expr • » r v) = s.second_inter p v :=\n  by\n  simp_rw [sphere.second_inter, real_inner_smul_left, inner_smul_right, smul_smul, div_mul_eq_div_div]\n  rw [mul_comm, ← mul_div_assoc, ← mul_div_assoc, mul_div_cancel_left _ hr, mul_comm, mul_assoc,\n    mul_div_cancel_left _ hr, mul_comm]\n#align sphere.second_inter_smul sphere.second_inter_smul\n\n",
 "second_inter_second_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Applying `second_inter` twice returns the original point. -/\n@[simp]\ntheorem sphere.second_inter_second_inter (s : sphere P) (p : P) (v : V) : s.second_inter (s.second_inter p v) v = p :=\n  by\n  by_cases hv : v = 0; · simp [hv]\n  have hv' : inner.real v v ≠ 0 := inner_self_eq_zero.not.2 hv\n  simp only [sphere.second_inter, vadd_vsub_assoc, vadd_vadd, inner_add_right, inner_smul_right, div_mul_cancel _ hv']\n  rw [← @vsub_eq_zero_iff_eq V, vadd_vsub, ← add_smul, ← add_div]\n  convert zero_smul (exprℝ) _\n  convert zero_div _\n  ring\n#align sphere.second_inter_second_inter sphere.second_inter_second_inter\n\n",
 "second_inter_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- `second_inter` is unchanged by negating the vector. -/\n@[simp]\ntheorem sphere.second_inter_neg (s : sphere P) (p : P) (v : V) : s.second_inter p (-v) = s.second_inter p v := by\n  rw [← neg_one_smul (exprℝ) v, s.second_inter_smul p v (by norm_num : (-1 : exprℝ) ≠ 0)]\n#align sphere.second_inter_neg sphere.second_inter_neg\n\n",
 "second_inter_mem":
 "/-- The point given by `second_inter` lies on the sphere. -/\n@[simp]\ntheorem sphere.second_inter_mem {s : sphere P} {p : P} (v : V) : s.second_inter p v ∈ s ↔ p ∈ s := by\n  simp_rw [mem_sphere, sphere.second_inter_dist]\n#align sphere.second_inter_mem sphere.second_inter_mem\n\n",
 "second_inter_eq_self_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- The point given by `second_inter` equals the original point if and only if the line is\northogonal to the radius vector. -/\ntheorem sphere.second_inter_eq_self_iff {s : sphere P} {p : P} {v : V} :\n    s.second_inter p v = p ↔ inner.real v («expr -ᵥ » p s.center) = 0 :=\n  by\n  refine' ⟨fun hp => _, fun hp => _⟩\n  · by_cases hv : v = 0\n    · simp [hv]\n    rwa [sphere.second_inter, eq_comm, eq_vadd_iff_vsub_eq, vsub_self, eq_comm, smul_eq_zero, or_iff_left hv,\n      div_eq_zero_iff, inner_self_eq_zero, or_iff_left hv, mul_eq_zero,\n      or_iff_right (by norm_num : (-2 : exprℝ) ≠ 0)] at hp\n  · rw [sphere.second_inter, hp, mul_zero, zero_div, zero_smul, zero_vadd]\n#align sphere.second_inter_eq_self_iff sphere.second_inter_eq_self_iff\n\n",
 "second_inter_eq_line_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- If the vector passed to `second_inter` is given by a subtraction involving the point in\n`second_inter`, the result of `second_inter` may be expressed using `line_map`. -/\ntheorem sphere.second_inter_eq_line_map (s : sphere P) (p p' : P) :\n    s.second_inter p («expr -ᵥ » p' p) =\n      affine_map.line_map p p'\n        (-2 * inner.real («expr -ᵥ » p' p) («expr -ᵥ » p s.center) / inner.real («expr -ᵥ » p' p) («expr -ᵥ » p' p)) :=\n  rfl\n#align sphere.second_inter_eq_line_map sphere.second_inter_eq_line_map\n\n",
 "second_inter_dist":
 "/-- The distance between `second_inter` and the center equals the distance between the original\npoint and the center. -/\n@[simp]\ntheorem sphere.second_inter_dist (s : sphere P) (p : P) (v : V) :\n    dist (s.second_inter p v) s.center = dist p s.center :=\n  by\n  rw [sphere.second_inter]\n  by_cases hv : v = 0; · simp [hv]\n  rw [dist_smul_vadd_eq_dist _ _ hv]\n  exact or.inr rfl\n#align sphere.second_inter_dist sphere.second_inter_dist\n\n",
 "second_inter_collinear":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- If the vector passed to `second_inter` is given by a subtraction involving the point in\n`second_inter`, the three points are collinear. -/\ntheorem sphere.second_inter_collinear (s : sphere P) (p p' : P) :\n    collinear (exprℝ) ({p, p', s.second_inter p («expr -ᵥ » p' p)} : set P) :=\n  by\n  rw [Set.pair_comm, Set.insert_comm]\n  exact\n    (collinear_insert_iff_of_mem_affine_span (s.second_inter_vsub_mem_affine_span _ _)).2 (collinear_pair (exprℝ) _ _)\n#align sphere.second_inter_collinear sphere.second_inter_collinear\n\n",
 "sbtw_second_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- If the vector passed to `second_inter` is given by a subtraction involving the point in\n`second_inter`, and the second point is inside the sphere, the second point is strictly between\nthe first point and the result of `second_inter`. -/\ntheorem sphere.sbtw_second_inter {s : sphere P} {p p' : P} (hp : p ∈ s) (hp' : dist p' s.center < s.radius) :\n    sbtw (exprℝ) p p' (s.second_inter p («expr -ᵥ » p' p)) :=\n  by\n  refine' ⟨sphere.wbtw_second_inter hp hp'.le, _, _⟩\n  · rintro rfl\n    rw [mem_sphere] at hp\n    simpa [hp] using hp'\n  · rintro h\n    rw [h, mem_sphere.1 ((sphere.second_inter_mem _).2 hp)] at hp'\n    exact lt_irrefl _ hp'\n#align sphere.sbtw_second_inter sphere.sbtw_second_inter\n\n",
 "sbtw_of_collinear_of_dist_center_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Given three collinear points, two on a sphere and one inside it, the one inside it is\nstrictly between the other two points. -/\ntheorem sbtw_of_collinear_of_dist_center_lt_radius {s : sphere P} {p₁ p₂ p₃ : P}\n    (h : collinear (exprℝ) ({p₁, p₂, p₃} : set P)) (hp₁ : p₁ ∈ s) (hp₂ : dist p₂ s.center < s.radius) (hp₃ : p₃ ∈ s)\n    (hp₁p₃ : p₁ ≠ p₃) : sbtw (exprℝ) p₁ p₂ p₃ :=\n  h.sbtw_of_dist_eq_of_dist_lt hp₁ hp₂ hp₃ hp₁p₃\n#align sbtw_of_collinear_of_dist_center_lt_radius sbtw_of_collinear_of_dist_center_lt_radius\n\n",
 "reflection_vadd_smul_vsub_orthogonal_projection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Reflecting a vector plus a point in the subspace produces the\nnegation of that vector plus the point if the vector is a multiple of\nthe result of subtracting a point's orthogonal projection from that\npoint. -/\ntheorem reflection_vadd_smul_vsub_orthogonal_projection {s : affine_subspace (exprℝ) P} [nonempty s]\n    [complete_space s.direction] {p₁ : P} (p₂ : P) (r : exprℝ) (hp₁ : p₁ ∈ s) :\n    reflection s («expr +ᵥ » («expr • » r («expr -ᵥ » p₂ (orthogonal_projection s p₂))) p₁) =\n      «expr +ᵥ » (-«expr • » r («expr -ᵥ » p₂ (orthogonal_projection s p₂))) p₁ :=\n  reflection_orthogonal_vadd hp₁ (submodule.smul_mem _ _ (vsub_orthogonal_projection_mem_direction_orthogonal s _))\n#align reflection_vadd_smul_vsub_orthogonal_projection reflection_vadd_smul_vsub_orthogonal_projection\n\n",
 "reflection_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Reflection is its own inverse. -/\n@[simp]\ntheorem reflection_symm (s : affine_subspace (exprℝ) P) [nonempty s] [complete_space s.direction] :\n    (reflection s).symm = reflection s := by\n  ext\n  rw [← (reflection s).injective.eq_iff]\n  simp\n#align reflection_symm reflection_symm\n\n",
 "reflection_reflection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Reflecting twice in the same subspace. -/\n@[simp]\ntheorem reflection_reflection (s : affine_subspace (exprℝ) P) [nonempty s] [complete_space s.direction] (p : P) :\n    reflection s (reflection s p) = p :=\n  by\n  have :\n    ∀ a : s,\n      ∀ b : V,\n        (_root_.orthogonal_projection s.direction) b = 0 →\n          reflection s (reflection s («expr +ᵥ » b a)) = «expr +ᵥ » b a :=\n    by\n    intro a b h\n    have : «expr -ᵥ » (a : P) («expr +ᵥ » b a) = -b := by rw [vsub_vadd_eq_vsub_sub, vsub_self, zero_sub]\n    simp [reflection, h, this]\n  rw [← vsub_vadd p (orthogonal_projection s p)]\n  exact this (orthogonal_projection s p) _ (orthogonal_projection_vsub_orthogonal_projection s p)\n#align reflection_reflection reflection_reflection\n\n",
 "reflection_orthogonal_vadd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/-- Reflecting an orthogonal vector plus a point in the subspace\nproduces the negation of that vector plus the point. -/\ntheorem reflection_orthogonal_vadd {s : affine_subspace (exprℝ) P} [nonempty s] [complete_space s.direction] {p : P}\n    (hp : p ∈ s) {v : V} (hv : v ∈ «expr ᗮ» s.direction) : reflection s («expr +ᵥ » v p) = «expr +ᵥ » (-v) p :=\n  by\n  rw [reflection_apply, orthogonal_projection_vadd_eq_self hp hv, vsub_vadd_eq_vsub_sub]\n  simp\n#align reflection_orthogonal_vadd reflection_orthogonal_vadd\n\n",
 "reflection_mem_of_le_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The reflection of a point in a subspace is contained in any larger\nsubspace containing both the point and the subspace reflected in. -/\ntheorem reflection_mem_of_le_of_mem {s₁ s₂ : affine_subspace (exprℝ) P} [nonempty s₁] [complete_space s₁.direction]\n    (hle : s₁ ≤ s₂) {p : P} (hp : p ∈ s₂) : reflection s₁ p ∈ s₂ :=\n  by\n  rw [reflection_apply]\n  have ho : ↑(orthogonal_projection s₁ p) ∈ s₂ := hle (orthogonal_projection_mem p)\n  exact vadd_mem_of_mem_direction (vsub_mem_direction ho hp) ho\n#align reflection_mem_of_le_of_mem reflection_mem_of_le_of_mem\n\n",
 "reflection_involutive":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Reflection is involutive. -/\ntheorem reflection_involutive (s : affine_subspace (exprℝ) P) [nonempty s] [complete_space s.direction] :\n    function.involutive (reflection s) :=\n  reflection_reflection s\n#align reflection_involutive reflection_involutive\n\n",
 "reflection_eq_self_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A point is its own reflection if and only if it is in the\nsubspace. -/\ntheorem reflection_eq_self_iff {s : affine_subspace (exprℝ) P} [nonempty s] [complete_space s.direction] (p : P) :\n    reflection s p = p ↔ p ∈ s :=\n  by\n  rw [← orthogonal_projection_eq_self_iff, reflection_apply]\n  constructor\n  · intro h\n    rw [← @vsub_eq_zero_iff_eq V, vadd_vsub_assoc, ← two_smul (exprℝ) («expr -ᵥ » (↑(orthogonal_projection s p)) p),\n      smul_eq_zero] at h\n    norm_num at h\n    exact h\n  · intro h\n    simp [h]\n#align reflection_eq_self_iff reflection_eq_self_iff\n\n",
 "reflection_eq_iff_orthogonal_projection_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Reflecting a point in two subspaces produces the same result if\nand only if the point has the same orthogonal projection in each of\nthose subspaces. -/\ntheorem reflection_eq_iff_orthogonal_projection_eq (s₁ s₂ : affine_subspace (exprℝ) P) [nonempty s₁] [nonempty s₂]\n    [complete_space s₁.direction] [complete_space s₂.direction] (p : P) :\n    reflection s₁ p = reflection s₂ p ↔ (orthogonal_projection s₁ p : P) = orthogonal_projection s₂ p :=\n  by\n  rw [reflection_apply, reflection_apply]\n  constructor\n  · intro h\n    rw [← @vsub_eq_zero_iff_eq V, vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, add_comm, add_sub_assoc,\n      vsub_sub_vsub_cancel_right, ←\n      two_smul (exprℝ) («expr -ᵥ » (orthogonal_projection s₁ p : P) (orthogonal_projection s₂ p)), smul_eq_zero] at h\n    norm_num at h\n    exact h\n  · intro h\n    rw [h]\n#align reflection_eq_iff_orthogonal_projection_eq reflection_eq_iff_orthogonal_projection_eq\n\n",
 "reflection_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- The result of reflecting. -/\ntheorem reflection_apply (s : affine_subspace (exprℝ) P) [nonempty s] [complete_space s.direction] (p : P) :\n    reflection s p = «expr +ᵥ » («expr -ᵥ » (↑(orthogonal_projection s p)) p) (orthogonal_projection s p) :=\n  rfl\n#align reflection_apply reflection_apply\n\n",
 "orthogonal_projection_vsub_orthogonal_projection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Subtracting the `orthogonal_projection` from `p` produces a result in the kernel of the linear\npart of the orthogonal projection. -/\ntheorem orthogonal_projection_vsub_orthogonal_projection (s : affine_subspace (exprℝ) P) [nonempty s]\n    [complete_space s.direction] (p : P) :\n    _root_.orthogonal_projection s.direction («expr -ᵥ » p (orthogonal_projection s p)) = 0 :=\n  by\n  apply orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero\n  intro c hc\n  rw [← neg_vsub_eq_vsub_rev, inner_neg_right, orthogonal_projection_vsub_mem_direction_orthogonal s p c hc, neg_zero]\n#align orthogonal_projection_vsub_orthogonal_projection orthogonal_projection_vsub_orthogonal_projection\n\n",
 "orthogonal_projection_vsub_mem_direction_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- Subtracting `p` from its `orthogonal_projection` produces a result\nin the orthogonal direction. -/\ntheorem orthogonal_projection_vsub_mem_direction_orthogonal (s : affine_subspace (exprℝ) P) [nonempty s]\n    [complete_space s.direction] (p : P) : «expr -ᵥ » (orthogonal_projection s p : P) p ∈ «expr ᗮ» s.direction :=\n  orthogonal_projection_fn_vsub_mem_direction_orthogonal p\n#align orthogonal_projection_vsub_mem_direction_orthogonal orthogonal_projection_vsub_mem_direction_orthogonal\n\n",
 "orthogonal_projection_vsub_mem_direction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Subtracting a point in the given subspace from the\n`orthogonal_projection` produces a result in the direction of the\ngiven subspace. -/\ntheorem orthogonal_projection_vsub_mem_direction {s : affine_subspace (exprℝ) P} [nonempty s]\n    [complete_space s.direction] {p1 : P} (p2 : P) (hp1 : p1 ∈ s) :\n    ↑(«expr -ᵥ » (orthogonal_projection s p2) ⟨p1, hp1⟩ : s.direction) ∈ s.direction :=\n  («expr -ᵥ » (orthogonal_projection s p2) ⟨p1, hp1⟩ : s.direction).2\n#align orthogonal_projection_vsub_mem_direction orthogonal_projection_vsub_mem_direction\n\n",
 "orthogonal_projection_vadd_smul_vsub_orthogonal_projection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Adding a vector to a point in the given subspace, then taking the\northogonal projection, produces the original point if the vector is a\nmultiple of the result of subtracting a point's orthogonal projection\nfrom that point. -/\ntheorem orthogonal_projection_vadd_smul_vsub_orthogonal_projection {s : affine_subspace (exprℝ) P} [nonempty s]\n    [complete_space s.direction] {p1 : P} (p2 : P) (r : exprℝ) (hp : p1 ∈ s) :\n    orthogonal_projection s («expr +ᵥ » («expr • » r («expr -ᵥ » p2 (orthogonal_projection s p2) : V)) p1) = ⟨p1, hp⟩ :=\n  orthogonal_projection_vadd_eq_self hp\n    (submodule.smul_mem _ _ (vsub_orthogonal_projection_mem_direction_orthogonal s _))\n#align\n  orthogonal_projection_vadd_smul_vsub_orthogonal_projection orthogonal_projection_vadd_smul_vsub_orthogonal_projection\n\n",
 "orthogonal_projection_vadd_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/-- Adding a vector to a point in the given subspace, then taking the\northogonal projection, produces the original point if the vector was\nin the orthogonal direction. -/\ntheorem orthogonal_projection_vadd_eq_self {s : affine_subspace (exprℝ) P} [nonempty s] [complete_space s.direction]\n    {p : P} (hp : p ∈ s) {v : V} (hv : v ∈ «expr ᗮ» s.direction) : orthogonal_projection s («expr +ᵥ » v p) = ⟨p, hp⟩ :=\n  by\n  have h := vsub_orthogonal_projection_mem_direction_orthogonal s («expr +ᵥ » v p)\n  rw [vadd_vsub_assoc, submodule.add_mem_iff_right _ hv] at h\n  refine' (eq_of_vsub_eq_zero _).symm\n  ext\n  refine' submodule.disjoint_def.1 s.direction.orthogonal_disjoint _ _ h\n  exact (_ : s.direction).2\n#align orthogonal_projection_vadd_eq_self orthogonal_projection_vadd_eq_self\n\n",
 "orthogonal_projection_orthogonal_projection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Orthogonal projection is idempotent. -/\n@[simp]\ntheorem orthogonal_projection_orthogonal_projection (s : affine_subspace (exprℝ) P) [nonempty s]\n    [complete_space s.direction] (p : P) :\n    orthogonal_projection s (orthogonal_projection s p) = orthogonal_projection s p :=\n  by\n  ext\n  rw [orthogonal_projection_eq_self_iff]\n  exact orthogonal_projection_mem p\n#align orthogonal_projection_orthogonal_projection orthogonal_projection_orthogonal_projection\n\n",
 "orthogonal_projection_mem_subspace_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem orthogonal_projection_mem_subspace_eq_self {s : affine_subspace (exprℝ) P} [nonempty s]\n    [complete_space s.direction] (p : s) : orthogonal_projection s p = p :=\n  by\n  ext\n  rw [orthogonal_projection_eq_self_iff]\n  exact p.2\n#align orthogonal_projection_mem_subspace_eq_self orthogonal_projection_mem_subspace_eq_self\n\n",
 "orthogonal_projection_mem_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- The `orthogonal_projection` lies in the orthogonal subspace. -/\ntheorem orthogonal_projection_mem_orthogonal (s : affine_subspace (exprℝ) P) [nonempty s] [complete_space s.direction]\n    (p : P) : ↑(orthogonal_projection s p) ∈ mk' p («expr ᗮ» s.direction) :=\n  orthogonal_projection_fn_mem_orthogonal p\n#align orthogonal_projection_mem_orthogonal orthogonal_projection_mem_orthogonal\n\n",
 "orthogonal_projection_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The `orthogonal_projection` lies in the given subspace. -/\ntheorem orthogonal_projection_mem {s : affine_subspace (exprℝ) P} [nonempty s] [complete_space s.direction] (p : P) :\n    ↑(orthogonal_projection s p) ∈ s :=\n  (orthogonal_projection s p).2\n#align orthogonal_projection_mem orthogonal_projection_mem\n\n",
 "orthogonal_projection_linear":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The linear map corresponding to `orthogonal_projection`. -/\n@[simp]\ntheorem orthogonal_projection_linear {s : affine_subspace (exprℝ) P} [nonempty s] [complete_space s.direction] :\n    (orthogonal_projection s).linear = _root_.orthogonal_projection s.direction :=\n  rfl\n#align orthogonal_projection_linear orthogonal_projection_linear\n\n",
 "orthogonal_projection_fn_vsub_mem_direction_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- Subtracting `p` from its `orthogonal_projection_fn` produces a\nresult in the orthogonal direction.  This lemma is only intended for\nuse in setting up the bundled version and should not be used once that\nis defined. -/\ntheorem orthogonal_projection_fn_vsub_mem_direction_orthogonal {s : affine_subspace (exprℝ) P} [nonempty s]\n    [complete_space s.direction] (p : P) : «expr -ᵥ » (orthogonal_projection_fn s p) p ∈ «expr ᗮ» s.direction :=\n  direction_mk' p («expr ᗮ» s.direction) ▸\n    vsub_mem_direction (orthogonal_projection_fn_mem_orthogonal p) (self_mem_mk' _ _)\n#align orthogonal_projection_fn_vsub_mem_direction_orthogonal orthogonal_projection_fn_vsub_mem_direction_orthogonal\n\n",
 "orthogonal_projection_fn_mem_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- The `orthogonal_projection_fn` lies in the orthogonal\nsubspace.  This lemma is only intended for use in setting up the\nbundled version and should not be used once that is defined. -/\ntheorem orthogonal_projection_fn_mem_orthogonal {s : affine_subspace (exprℝ) P} [nonempty s]\n    [complete_space s.direction] (p : P) : orthogonal_projection_fn s p ∈ mk' p («expr ᗮ» s.direction) :=\n  by\n  rw [← mem_coe, ← Set.singleton_subset_iff, ← inter_eq_singleton_orthogonal_projection_fn]\n  exact Set.inter_subset_right _ _\n#align orthogonal_projection_fn_mem_orthogonal orthogonal_projection_fn_mem_orthogonal\n\n",
 "orthogonal_projection_fn_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The `orthogonal_projection_fn` lies in the given subspace.  This\nlemma is only intended for use in setting up the bundled version and\nshould not be used once that is defined. -/\ntheorem orthogonal_projection_fn_mem {s : affine_subspace (exprℝ) P} [nonempty s] [complete_space s.direction] (p : P) :\n    orthogonal_projection_fn s p ∈ s :=\n  by\n  rw [← mem_coe, ← Set.singleton_subset_iff, ← inter_eq_singleton_orthogonal_projection_fn]\n  exact Set.inter_subset_left _ _\n#align orthogonal_projection_fn_mem orthogonal_projection_fn_mem\n\n",
 "orthogonal_projection_fn_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem orthogonal_projection_fn_eq {s : affine_subspace (exprℝ) P} [nonempty s] [complete_space s.direction] (p : P) :\n    orthogonal_projection_fn s p = orthogonal_projection s p :=\n  rfl\n#align orthogonal_projection_fn_eq orthogonal_projection_fn_eq\n\n",
 "orthogonal_projection_eq_self_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A point equals its orthogonal projection if and only if it lies in\nthe subspace. -/\ntheorem orthogonal_projection_eq_self_iff {s : affine_subspace (exprℝ) P} [nonempty s] [complete_space s.direction]\n    {p : P} : ↑(orthogonal_projection s p) = p ↔ p ∈ s :=\n  by\n  constructor\n  · exact fun h => h ▸ orthogonal_projection_mem p\n  · intro h\n    have hp : p ∈ (s : set P) ∩ mk' p («expr ᗮ» s.direction) := ⟨h, self_mem_mk' p _⟩\n    rw [inter_eq_singleton_orthogonal_projection p] at hp\n    symm\n    exact hp\n#align orthogonal_projection_eq_self_iff orthogonal_projection_eq_self_iff\n\n",
 "ne_iff":
 "theorem sphere.ne_iff {s₁ s₂ : sphere P} : s₁ ≠ s₂ ↔ s₁.center ≠ s₂.center ∨ s₁.radius ≠ s₂.radius := by\n  rw [← not_and_or, ← sphere.ext_iff]\n#align sphere.ne_iff sphere.ne_iff\n\n",
 "mk_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem sphere.mk_radius (c : P) (r : exprℝ) : (⟨c, r⟩ : sphere P).radius = r :=\n  rfl\n#align sphere.mk_radius sphere.mk_radius\n\n",
 "mk_center_radius":
 "@[simp]\ntheorem sphere.mk_center_radius (s : sphere P) : (⟨s.center, s.radius⟩ : sphere P) = s := by ext <;> rfl\n#align sphere.mk_center_radius sphere.mk_center_radius\n\n",
 "mk_center":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem sphere.mk_center (c : P) (r : exprℝ) : (⟨c, r⟩ : sphere P).center = c :=\n  rfl\n#align sphere.mk_center sphere.mk_center\n\n",
 "mem_sphere'":
 "theorem mem_sphere' {p : P} {s : sphere P} : p ∈ s ↔ dist s.center p = s.radius :=\n  metric.mem_sphere'\n#align mem_sphere' mem_sphere'\n\n",
 "mem_sphere":
 "theorem mem_sphere {p : P} {s : sphere P} : p ∈ s ↔ dist p s.center = s.radius :=\n  iff.rfl\n#align mem_sphere mem_sphere\n\n",
 "mem_coe":
 "@[simp]\ntheorem sphere.mem_coe {p : P} {s : sphere P} : p ∈ (s : set P) ↔ p ∈ s :=\n  iff.rfl\n#align sphere.mem_coe sphere.mem_coe\n\n",
 "inter_eq_singleton_orthogonal_projection_fn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- The intersection of the subspace and the orthogonal subspace\nthrough the given point is the `orthogonal_projection_fn` of that\npoint onto the subspace.  This lemma is only intended for use in\nsetting up the bundled version and should not be used once that is\ndefined. -/\ntheorem inter_eq_singleton_orthogonal_projection_fn {s : affine_subspace (exprℝ) P} [nonempty s]\n    [complete_space s.direction] (p : P) :\n    (s : set P) ∩ mk' p («expr ᗮ» s.direction) = {orthogonal_projection_fn s p} :=\n  Classical.choose_spec <|\n    inter_eq_singleton_of_nonempty_of_is_compl (nonempty_subtype.mp ‹_›) (mk'_nonempty p («expr ᗮ» s.direction))\n      (by\n        rw [direction_mk' p («expr ᗮ» s.direction)]\n        exact submodule.is_compl_orthogonal_of_complete_space)\n#align inter_eq_singleton_orthogonal_projection_fn inter_eq_singleton_orthogonal_projection_fn\n\n",
 "inter_eq_singleton_orthogonal_projection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- The intersection of the subspace and the orthogonal subspace\nthrough the given point is the `orthogonal_projection` of that point\nonto the subspace. -/\ntheorem inter_eq_singleton_orthogonal_projection {s : affine_subspace (exprℝ) P} [nonempty s]\n    [complete_space s.direction] (p : P) : (s : set P) ∩ mk' p («expr ᗮ» s.direction) = {orthogonal_projection s p} :=\n  by\n  rw [← orthogonal_projection_fn_eq]\n  exact inter_eq_singleton_orthogonal_projection_fn p\n#align inter_eq_singleton_orthogonal_projection inter_eq_singleton_orthogonal_projection\n\n",
 "inner_weighted_vsub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The inner product of two vectors given with `weighted_vsub`, in\nterms of the pairwise distances. -/\ntheorem inner_weighted_vsub {ι₁ : Type _} {s₁ : Finset ι₁} {w₁ : ι₁ → exprℝ} (p₁ : ι₁ → P)\n    (h₁ : finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s₁ (w₁ i) = 0)\n    {ι₂ : Type _} {s₂ : Finset ι₂} {w₂ : ι₂ → exprℝ} (p₂ : ι₂ → P)\n    (h₂ :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s₂ (w₂ i) = 0) :\n    inner.real (s₁.weighted_vsub p₁ w₁) (s₂.weighted_vsub p₂ w₂) =\n      -finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s₁\n            (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s₂\n              (w₁ i₁ * w₂ i₂ * (dist (p₁ i₁) (p₂ i₂) * dist (p₁ i₁) (p₂ i₂)))) /\n        2 :=\n  by\n  rw [finset.weighted_vsub_apply, finset.weighted_vsub_apply, inner_sum_smul_sum_smul_of_sum_eq_zero _ h₁ _ h₂]\n  simp_rw [vsub_sub_vsub_cancel_right]\n  rcongr (i₁ i₂) <;> rw [dist_eq_norm_vsub V (p₁ i₁) (p₂ i₂)]\n#align inner_weighted_vsub inner_weighted_vsub\n\n",
 "inner_vsub_vsub_of_mem_sphere_of_mem_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Suppose that `p₁` and `p₂` lie in spheres `s₁` and `s₂`.  Then the vector between the centers\nof those spheres is orthogonal to that between `p₁` and `p₂`; this is a version of\n`inner_vsub_vsub_of_dist_eq_of_dist_eq` for bundled spheres.  (In two dimensions, this says that\nthe diagonals of a kite are orthogonal.) -/\ntheorem inner_vsub_vsub_of_mem_sphere_of_mem_sphere {p₁ p₂ : P} {s₁ s₂ : sphere P} (hp₁s₁ : p₁ ∈ s₁) (hp₂s₁ : p₂ ∈ s₁)\n    (hp₁s₂ : p₁ ∈ s₂) (hp₂s₂ : p₂ ∈ s₂) : inner.real («expr -ᵥ » s₂.center s₁.center) («expr -ᵥ » p₂ p₁) = 0 :=\n  inner_vsub_vsub_of_dist_eq_of_dist_eq (dist_center_eq_dist_center_of_mem_sphere hp₁s₁ hp₂s₁)\n    (dist_center_eq_dist_center_of_mem_sphere hp₁s₂ hp₂s₂)\n#align inner_vsub_vsub_of_mem_sphere_of_mem_sphere inner_vsub_vsub_of_mem_sphere_of_mem_sphere\n\n",
 "inner_vsub_vsub_of_dist_eq_of_dist_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Suppose that `c₁` is equidistant from `p₁` and `p₂`, and the same\napplies to `c₂`.  Then the vector between `c₁` and `c₂` is orthogonal\nto that between `p₁` and `p₂`.  (In two dimensions, this says that the\ndiagonals of a kite are orthogonal.) -/\ntheorem inner_vsub_vsub_of_dist_eq_of_dist_eq {c₁ c₂ p₁ p₂ : P} (hc₁ : dist p₁ c₁ = dist p₂ c₁)\n    (hc₂ : dist p₁ c₂ = dist p₂ c₂) : inner.real («expr -ᵥ » c₂ c₁) («expr -ᵥ » p₂ p₁) = 0 :=\n  by\n  have h : inner.real («expr -ᵥ » c₂ c₁ + «expr -ᵥ » c₂ c₁) («expr -ᵥ » p₂ p₁) = 0 :=\n    by\n    conv_lhs =>\n      congr\n      congr\n      rw [← vsub_sub_vsub_cancel_right c₂ c₁ p₁]\n      skip\n      rw [← vsub_sub_vsub_cancel_right c₂ c₁ p₂]\n    rw [sub_add_sub_comm, inner_sub_left]\n    conv_lhs =>\n      congr\n      rw [← vsub_sub_vsub_cancel_right p₂ p₁ c₂]\n      skip\n      rw [← vsub_sub_vsub_cancel_right p₂ p₁ c₁]\n    rw [dist_comm p₁, dist_comm p₂, dist_eq_norm_vsub V _ p₁, dist_eq_norm_vsub V _ p₂, ←\n      real_inner_add_sub_eq_zero_iff] at hc₁ hc₂\n    simp_rw [← neg_vsub_eq_vsub_rev c₁, ← neg_vsub_eq_vsub_rev c₂, sub_neg_eq_add, neg_add_eq_sub, hc₁, hc₂, sub_zero]\n  simpa [inner_add_left, ← mul_two, (by norm_num : (2 : exprℝ) ≠ 0)] using h\n#align inner_vsub_vsub_of_dist_eq_of_dist_eq inner_vsub_vsub_of_dist_eq_of_dist_eq\n\n",
 "inner_pos_or_eq_of_dist_le_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Given a point on a sphere and a point not outside it, the inner product between the\ndifference of those points and the radius vector is positive unless the points are equal. -/\ntheorem inner_pos_or_eq_of_dist_le_radius {s : sphere P} {p₁ p₂ : P} (hp₁ : p₁ ∈ s)\n    (hp₂ : dist p₂ s.center ≤ s.radius) : 0 < inner.real («expr -ᵥ » p₁ p₂) («expr -ᵥ » p₁ s.center) ∨ p₁ = p₂ :=\n  by\n  by_cases h : p₁ = p₂; · exact or.inr h\n  refine' or.inl _\n  rw [mem_sphere] at hp₁\n  rw [← vsub_sub_vsub_cancel_right p₁ p₂ s.center, inner_sub_left,\n    real_inner_self_eq_norm_mul_norm,--, ←dist_eq_norm_vsub, hp₁\n    sub_pos]\n  refine' lt_of_le_of_ne ((real_inner_le_norm _ _).trans (mul_le_mul_of_nonneg_right _ (norm_nonneg _))) _\n  · rwa [← dist_eq_norm_vsub, ← dist_eq_norm_vsub, hp₁]\n  · rcases hp₂.lt_or_eq with (hp₂' | hp₂')\n    · refine' ((real_inner_le_norm _ _).trans_lt (mul_lt_mul_of_pos_right _ _)).ne\n      · rwa [← hp₁, @dist_eq_norm_vsub V, @dist_eq_norm_vsub V] at hp₂'\n      · rw [norm_pos_iff, vsub_ne_zero]\n        rintro rfl\n        rw [← hp₁] at hp₂'\n        refine' (dist_nonneg.not_lt : ¬dist p₂ s.center < 0) _\n        simpa using hp₂'\n    · rw [← hp₁, @dist_eq_norm_vsub V, @dist_eq_norm_vsub V] at hp₂'\n      nth_rw 1 [← hp₂']\n      rw [ne.def, inner_eq_norm_mul_iff_real, hp₂', ← sub_eq_zero, ← smul_sub, vsub_sub_vsub_cancel_right, ← ne.def,\n        smul_ne_zero_iff, vsub_ne_zero, and_iff_left (ne.symm h), norm_ne_zero_iff, vsub_ne_zero]\n      rintro rfl\n      refine' h (eq.symm _)\n      simpa using hp₂'\n#align inner_pos_or_eq_of_dist_le_radius inner_pos_or_eq_of_dist_le_radius\n\n",
 "inner_pos_of_dist_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Given a point on a sphere and a point inside it, the inner product between the difference of\nthose points and the radius vector is positive. -/\ntheorem inner_pos_of_dist_lt_radius {s : sphere P} {p₁ p₂ : P} (hp₁ : p₁ ∈ s) (hp₂ : dist p₂ s.center < s.radius) :\n    0 < inner.real («expr -ᵥ » p₁ p₂) («expr -ᵥ » p₁ s.center) :=\n  by\n  by_cases h : p₁ = p₂\n  · rw [h, mem_sphere] at hp₁\n    exact false.elim (hp₂.ne hp₁)\n  exact (inner_pos_or_eq_of_dist_le_radius hp₁ hp₂.le).resolve_right h\n#align inner_pos_of_dist_lt_radius inner_pos_of_dist_lt_radius\n\n",
 "inner_nonneg_of_dist_le_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Given a point on a sphere and a point not outside it, the inner product between the\ndifference of those points and the radius vector is nonnegative. -/\ntheorem inner_nonneg_of_dist_le_radius {s : sphere P} {p₁ p₂ : P} (hp₁ : p₁ ∈ s) (hp₂ : dist p₂ s.center ≤ s.radius) :\n    0 ≤ inner.real («expr -ᵥ » p₁ p₂) («expr -ᵥ » p₁ s.center) :=\n  by\n  rcases inner_pos_or_eq_of_dist_le_radius hp₁ hp₂ with (h | rfl)\n  · exact h.le\n  · simp\n#align inner_nonneg_of_dist_le_radius inner_nonneg_of_dist_le_radius\n\n",
 "eq_reflection_of_eq_subspace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem eq_reflection_of_eq_subspace {s s' : affine_subspace (exprℝ) P} [nonempty s] [nonempty s']\n    [complete_space s.direction] [complete_space s'.direction] (h : s = s') (p : P) :\n    (reflection s p : P) = (reflection s' p : P) := by subst h\n#align eq_reflection_of_eq_subspace eq_reflection_of_eq_subspace\n\n",
 "eq_orthogonal_projection_of_eq_subspace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem eq_orthogonal_projection_of_eq_subspace {s s' : affine_subspace (exprℝ) P} [nonempty s] [nonempty s']\n    [complete_space s.direction] [complete_space s'.direction] (h : s = s') (p : P) :\n    (orthogonal_projection s p : P) = (orthogonal_projection s' p : P) :=\n  by\n  change orthogonal_projection_fn s p = orthogonal_projection_fn s' p\n  congr\n  exact h\n#align eq_orthogonal_projection_of_eq_subspace eq_orthogonal_projection_of_eq_subspace\n\n",
 "eq_or_eq_second_inter_of_mem_mk'_span_singleton_iff_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A point on a line through a point on a sphere equals that point or `second_inter`. -/\ntheorem sphere.eq_or_eq_second_inter_of_mem_mk'_span_singleton_iff_mem {s : sphere P} {p : P} (hp : p ∈ s) {v : V}\n    {p' : P} (hp' : p' ∈ affine_subspace.mk' p («expr ∙ » (exprℝ) v)) : p' = p ∨ p' = s.second_inter p v ↔ p' ∈ s :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · rcases h with (h | h)\n    · rwa [h]\n    · rwa [h, sphere.second_inter_mem]\n  · rw [affine_subspace.mem_mk'_iff_vsub_mem, submodule.mem_span_singleton] at hp'\n    rcases hp' with ⟨r, hr⟩\n    rw [eq_comm, ← eq_vadd_iff_vsub_eq] at hr\n    subst hr\n    by_cases hv : v = 0\n    · simp [hv]\n    rw [sphere.second_inter]\n    rw [mem_sphere] at h hp\n    rw [← hp, dist_smul_vadd_eq_dist _ _ hv] at h\n    rcases h with (h | h) <;> simp [h]\n#align\n  sphere.eq_or_eq_second_inter_of_mem_mk'_span_singleton_iff_mem sphere.eq_or_eq_second_inter_of_mem_mk'_span_singleton_iff_mem\n\n",
 "eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Two spheres intersect in at most two points in a two-dimensional subspace containing their\ncenters; this is a version of `eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two` for bundled\nspheres. -/\ntheorem eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two {s : affine_subspace (exprℝ) P}\n    [finite_dimensional (exprℝ) s.direction] (hd : finrank (exprℝ) s.direction = 2) {s₁ s₂ : sphere P} {p₁ p₂ p : P}\n    (hs₁ : s₁.center ∈ s) (hs₂ : s₂.center ∈ s) (hp₁s : p₁ ∈ s) (hp₂s : p₂ ∈ s) (hps : p ∈ s) (hs : s₁ ≠ s₂)\n    (hp : p₁ ≠ p₂) (hp₁s₁ : p₁ ∈ s₁) (hp₂s₁ : p₂ ∈ s₁) (hps₁ : p ∈ s₁) (hp₁s₂ : p₁ ∈ s₂) (hp₂s₂ : p₂ ∈ s₂)\n    (hps₂ : p ∈ s₂) : p = p₁ ∨ p = p₂ :=\n  eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two hd hs₁ hs₂ hp₁s hp₂s hps\n    ((sphere.center_ne_iff_ne_of_mem hps₁ hps₂).2 hs) hp hp₁s₁ hp₂s₁ hps₁ hp₁s₂ hp₂s₂ hps₂\n#align eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two\n\n",
 "eq_of_mem_sphere_of_mem_sphere_of_finrank_eq_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Two spheres intersect in at most two points in two-dimensional space; this is a version of\n`eq_of_dist_eq_of_dist_eq_of_finrank_eq_two` for bundled spheres. -/\ntheorem eq_of_mem_sphere_of_mem_sphere_of_finrank_eq_two [finite_dimensional (exprℝ) V] (hd : finrank (exprℝ) V = 2)\n    {s₁ s₂ : sphere P} {p₁ p₂ p : P} (hs : s₁ ≠ s₂) (hp : p₁ ≠ p₂) (hp₁s₁ : p₁ ∈ s₁) (hp₂s₁ : p₂ ∈ s₁) (hps₁ : p ∈ s₁)\n    (hp₁s₂ : p₁ ∈ s₂) (hp₂s₂ : p₂ ∈ s₂) (hps₂ : p ∈ s₂) : p = p₁ ∨ p = p₂ :=\n  eq_of_dist_eq_of_dist_eq_of_finrank_eq_two hd ((sphere.center_ne_iff_ne_of_mem hps₁ hps₂).2 hs) hp hp₁s₁ hp₂s₁ hps₁\n    hp₁s₂ hp₂s₂ hps₂\n#align eq_of_mem_sphere_of_mem_sphere_of_finrank_eq_two eq_of_mem_sphere_of_mem_sphere_of_finrank_eq_two\n\n",
 "eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Distances `r₁` `r₂` of `p` from two different points `c₁` `c₂` determine at\nmost two points `p₁` `p₂` in a two-dimensional subspace containing those points\n(two circles intersect in at most two points). -/\ntheorem eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two {s : affine_subspace (exprℝ) P}\n    [finite_dimensional (exprℝ) s.direction] (hd : finrank (exprℝ) s.direction = 2) {c₁ c₂ p₁ p₂ p : P} (hc₁s : c₁ ∈ s)\n    (hc₂s : c₂ ∈ s) (hp₁s : p₁ ∈ s) (hp₂s : p₂ ∈ s) (hps : p ∈ s) {r₁ r₂ : exprℝ} (hc : c₁ ≠ c₂) (hp : p₁ ≠ p₂)\n    (hp₁c₁ : dist p₁ c₁ = r₁) (hp₂c₁ : dist p₂ c₁ = r₁) (hpc₁ : dist p c₁ = r₁) (hp₁c₂ : dist p₁ c₂ = r₂)\n    (hp₂c₂ : dist p₂ c₂ = r₂) (hpc₂ : dist p c₂ = r₂) : p = p₁ ∨ p = p₂ :=\n  by\n  have ho : inner.real («expr -ᵥ » c₂ c₁) («expr -ᵥ » p₂ p₁) = 0 :=\n    inner_vsub_vsub_of_dist_eq_of_dist_eq (hp₁c₁.trans hp₂c₁.symm) (hp₁c₂.trans hp₂c₂.symm)\n  have hop : inner.real («expr -ᵥ » c₂ c₁) («expr -ᵥ » p p₁) = 0 :=\n    inner_vsub_vsub_of_dist_eq_of_dist_eq (hp₁c₁.trans hpc₁.symm) (hp₁c₂.trans hpc₂.symm)\n  let b : fin 2 → V := «expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\"\n  have hb : linear_independent (exprℝ) b :=\n    by\n    refine' linear_independent_of_ne_zero_of_inner_eq_zero _ _\n    · intro i\n      fin_cases i <;> simp [b, hc.symm, hp.symm]\n    · intro i j hij\n      fin_cases i <;> fin_cases j <;> try exact false.elim (hij rfl)\n      · exact ho\n      · rw [real_inner_comm]\n        exact ho\n  have hbs : submodule.span (exprℝ) (Set.range b) = s.direction :=\n    by\n    refine' eq_of_le_of_finrank_eq _ _\n    · rw [submodule.span_le, Set.range_subset_iff]\n      intro i\n      fin_cases i\n      · exact vsub_mem_direction hc₂s hc₁s\n      · exact vsub_mem_direction hp₂s hp₁s\n    · rw [finrank_span_eq_card hb, fintype.card_fin, hd]\n  have hv : ∀ v ∈ s.direction, ∃ t₁ t₂ : exprℝ, v = «expr • » t₁ («expr -ᵥ » c₂ c₁) + «expr • » t₂ («expr -ᵥ » p₂ p₁) :=\n    by\n    intro v hv\n    have hr : Set.range b = {«expr -ᵥ » c₂ c₁, «expr -ᵥ » p₂ p₁} :=\n      by\n      have hu : (finset.univ : Finset (fin 2)) = {0, 1} := by decide\n      rw [← fintype.coe_image_univ, hu]\n      simp\n      rfl\n    rw [← hbs, hr, submodule.mem_span_insert] at hv\n    rcases hv with ⟨t₁, v', hv', hv⟩\n    rw [submodule.mem_span_singleton] at hv'\n    rcases hv' with ⟨t₂, rfl⟩\n    exact ⟨t₁, t₂, hv⟩\n  rcases hv («expr -ᵥ » p p₁) (vsub_mem_direction hps hp₁s) with ⟨t₁, t₂, hpt⟩\n  simp only [hpt, inner_add_right, inner_smul_right, ho, mul_zero, add_zero, mul_eq_zero, inner_self_eq_zero,\n    vsub_eq_zero_iff_eq, hc.symm, or_false_iff] at hop\n  rw [hop, zero_smul, zero_add, ← eq_vadd_iff_vsub_eq] at hpt\n  subst hpt\n  have hp' : («expr -ᵥ » p₂ p₁ : V) ≠ 0 := by simp [hp.symm]\n  have hp₂ : dist («expr +ᵥ » («expr • » (1 : exprℝ) («expr -ᵥ » p₂ p₁)) p₁) c₁ = r₁ := by simp [hp₂c₁]\n  rw [← hp₁c₁, dist_smul_vadd_eq_dist _ _ hp'] at hpc₁ hp₂\n  simp only [one_ne_zero, false_or_iff] at hp₂\n  rw [hp₂.symm] at hpc₁\n  cases hpc₁ <;> simp [hpc₁]\n#align eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two\n\n",
 "eq_of_dist_eq_of_dist_eq_of_finrank_eq_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Distances `r₁` `r₂` of `p` from two different points `c₁` `c₂` determine at\nmost two points `p₁` `p₂` in two-dimensional space (two circles intersect in at\nmost two points). -/\ntheorem eq_of_dist_eq_of_dist_eq_of_finrank_eq_two [finite_dimensional (exprℝ) V] (hd : finrank (exprℝ) V = 2)\n    {c₁ c₂ p₁ p₂ p : P} {r₁ r₂ : exprℝ} (hc : c₁ ≠ c₂) (hp : p₁ ≠ p₂) (hp₁c₁ : dist p₁ c₁ = r₁)\n    (hp₂c₁ : dist p₂ c₁ = r₁) (hpc₁ : dist p c₁ = r₁) (hp₁c₂ : dist p₁ c₂ = r₂) (hp₂c₂ : dist p₂ c₂ = r₂)\n    (hpc₂ : dist p c₂ = r₂) : p = p₁ ∨ p = p₂ :=\n  haveI hd' : finrank (exprℝ) («expr⊤» : affine_subspace (exprℝ) P).direction = 2 :=\n    by\n    rw [direction_top, finrank_top]\n    exact hd\n  eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two hd' (mem_top (exprℝ) V _) (mem_top (exprℝ) V _)\n    (mem_top (exprℝ) V _) (mem_top (exprℝ) V _) (mem_top (exprℝ) V _) hc hp hp₁c₁ hp₂c₁ hpc₁ hp₁c₂ hp₂c₂ hpc₂\n#align eq_of_dist_eq_of_dist_eq_of_finrank_eq_two eq_of_dist_eq_of_dist_eq_of_finrank_eq_two\n\n",
 "dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The square of the distance between two points constructed by\nadding multiples of the same orthogonal vector to points in the same\nsubspace. -/\ntheorem dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd {s : affine_subspace (exprℝ) P} {p1 p2 : P} (hp1 : p1 ∈ s)\n    (hp2 : p2 ∈ s) (r1 r2 : exprℝ) {v : V} (hv : v ∈ «expr ᗮ» s.direction) :\n    dist («expr +ᵥ » («expr • » r1 v) p1) («expr +ᵥ » («expr • » r2 v) p2) *\n        dist («expr +ᵥ » («expr • » r1 v) p1) («expr +ᵥ » («expr • » r2 v) p2) =\n      dist p1 p2 * dist p1 p2 + (r1 - r2) * (r1 - r2) * («expr‖ ‖» v * «expr‖ ‖» v) :=\n  calc\n    dist («expr +ᵥ » («expr • » r1 v) p1) («expr +ᵥ » («expr • » r2 v) p2) *\n          dist («expr +ᵥ » («expr • » r1 v) p1) («expr +ᵥ » («expr • » r2 v) p2) =\n        «expr‖ ‖» («expr -ᵥ » p1 p2 + «expr • » (r1 - r2) v) * «expr‖ ‖» («expr -ᵥ » p1 p2 + «expr • » (r1 - r2) v) :=\n      by\n      rw [dist_eq_norm_vsub V («expr +ᵥ » («expr • » r1 v) p1), vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, sub_smul,\n        add_comm, add_sub_assoc]\n    _ =\n        «expr‖ ‖» («expr -ᵥ » p1 p2) * «expr‖ ‖» («expr -ᵥ » p1 p2) +\n          «expr‖ ‖» («expr • » (r1 - r2) v) * «expr‖ ‖» («expr • » (r1 - r2) v) :=\n      norm_add_sq_eq_norm_sq_add_norm_sq_real\n        (submodule.inner_right_of_mem_orthogonal (vsub_mem_direction hp1 hp2) (submodule.smul_mem _ _ hv))\n    _ =\n        «expr‖ ‖» («expr -ᵥ » p1 p2 : V) * «expr‖ ‖» («expr -ᵥ » p1 p2 : V) +\n          |r1 - r2| * |r1 - r2| * «expr‖ ‖» v * «expr‖ ‖» v :=\n      by\n      rw [norm_smul, real.norm_eq_abs]\n      ring\n    _ = dist p1 p2 * dist p1 p2 + (r1 - r2) * (r1 - r2) * («expr‖ ‖» v * «expr‖ ‖» v) := by\n      rw [dist_eq_norm_vsub V p1, abs_mul_abs_self, mul_assoc]\n    \n#align dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd\n\n",
 "dist_sq_eq_dist_orthogonal_projection_sq_add_dist_orthogonal_projection_sq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The square of the distance from a point in `s` to `p2` equals the\nsum of the squares of the distances of the two points to the\n`orthogonal_projection`. -/\ntheorem dist_sq_eq_dist_orthogonal_projection_sq_add_dist_orthogonal_projection_sq {s : affine_subspace (exprℝ) P}\n    [nonempty s] [complete_space s.direction] {p1 : P} (p2 : P) (hp1 : p1 ∈ s) :\n    dist p1 p2 * dist p1 p2 =\n      dist p1 (orthogonal_projection s p2) * dist p1 (orthogonal_projection s p2) +\n        dist p2 (orthogonal_projection s p2) * dist p2 (orthogonal_projection s p2) :=\n  by\n  rw [dist_comm p2 _, dist_eq_norm_vsub V p1 _, dist_eq_norm_vsub V p1 _, dist_eq_norm_vsub V _ p2, ←\n    vsub_add_vsub_cancel p1 (orthogonal_projection s p2) p2, norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero]\n  exact\n    submodule.inner_right_of_mem_orthogonal (vsub_orthogonal_projection_mem_direction p2 hp1)\n      (orthogonal_projection_vsub_mem_direction_orthogonal s p2)\n#align\n  dist_sq_eq_dist_orthogonal_projection_sq_add_dist_orthogonal_projection_sq dist_sq_eq_dist_orthogonal_projection_sq_add_dist_orthogonal_projection_sq\n\n",
 "dist_smul_vadd_sq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- The squared distance between points on a line (expressed as a\nmultiple of a fixed vector added to a point) and another point,\nexpressed as a quadratic. -/\ntheorem dist_smul_vadd_sq (r : exprℝ) (v : V) (p₁ p₂ : P) :\n    dist («expr +ᵥ » («expr • » r v) p₁) p₂ * dist («expr +ᵥ » («expr • » r v) p₁) p₂ =\n      inner.real v v * r * r + 2 * inner.real v («expr -ᵥ » p₁ p₂) * r +\n        inner.real («expr -ᵥ » p₁ p₂) («expr -ᵥ » p₁ p₂) :=\n  by\n  rw [dist_eq_norm_vsub V _ p₂, ← real_inner_self_eq_norm_mul_norm, vadd_vsub_assoc, real_inner_add_add_self,\n    real_inner_smul_left, real_inner_smul_left, real_inner_smul_right]\n  ring\n#align dist_smul_vadd_sq dist_smul_vadd_sq\n\n",
 "dist_smul_vadd_eq_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/-- The condition for two points on a line to be equidistant from\nanother point. -/\ntheorem dist_smul_vadd_eq_dist {v : V} (p₁ p₂ : P) (hv : v ≠ 0) (r : exprℝ) :\n    dist («expr +ᵥ » («expr • » r v) p₁) p₂ = dist p₁ p₂ ↔\n      r = 0 ∨ r = -2 * inner.real v («expr -ᵥ » p₁ p₂) / inner.real v v :=\n  by\n  conv_lhs =>\n    rw [← mul_self_inj_of_nonneg dist_nonneg dist_nonneg, dist_smul_vadd_sq, ← sub_eq_zero, add_sub_assoc,\n      dist_eq_norm_vsub V p₁ p₂, ← real_inner_self_eq_norm_mul_norm, sub_self]\n  have hvi : inner.real v v ≠ 0 := by simpa using hv\n  have hd :\n    discrim (inner.real v v) (2 * inner.real v («expr -ᵥ » p₁ p₂)) 0 =\n      2 * inner.real v («expr -ᵥ » p₁ p₂) * (2 * inner.real v («expr -ᵥ » p₁ p₂)) :=\n    by\n    rw [discrim]\n    ring\n  rw [quadratic_eq_zero_iff hvi hd, add_left_neg, zero_div, neg_mul_eq_neg_mul, ← mul_sub_right_distrib, sub_eq_add_neg,\n    ← mul_two, mul_assoc, mul_div_assoc, mul_div_mul_left, mul_div_assoc]\n  norm_num\n#align dist_smul_vadd_eq_dist dist_smul_vadd_eq_dist\n\n",
 "dist_reflection_eq_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A point in the subspace is equidistant from another point and its\nreflection. -/\ntheorem dist_reflection_eq_of_mem (s : affine_subspace (exprℝ) P) [nonempty s] [complete_space s.direction] {p₁ : P}\n    (hp₁ : p₁ ∈ s) (p₂ : P) : dist p₁ (reflection s p₂) = dist p₁ p₂ :=\n  by\n  rw [← reflection_eq_self_iff p₁] at hp₁\n  convert (reflection s).dist_map p₁ p₂\n  rw [hp₁]\n#align dist_reflection_eq_of_mem dist_reflection_eq_of_mem\n\n",
 "dist_reflection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The distance between `p₁` and the reflection of `p₂` equals that\nbetween the reflection of `p₁` and `p₂`. -/\ntheorem dist_reflection (s : affine_subspace (exprℝ) P) [nonempty s] [complete_space s.direction] (p₁ p₂ : P) :\n    dist p₁ (reflection s p₂) = dist (reflection s p₁) p₂ :=\n  by\n  conv_lhs => rw [← reflection_reflection s p₁]\n  exact (reflection s).dist_map _ _\n#align dist_reflection dist_reflection\n\n",
 "dist_orthogonal_projection_ne_zero_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The distance between a point and its orthogonal projection is\nnonzero if it does not lie in the subspace. -/\ntheorem dist_orthogonal_projection_ne_zero_of_not_mem {s : affine_subspace (exprℝ) P} [nonempty s]\n    [complete_space s.direction] {p : P} (hp : p ∉ s) : dist p (orthogonal_projection s p) ≠ 0 :=\n  mt dist_orthogonal_projection_eq_zero_iff.mp hp\n#align dist_orthogonal_projection_ne_zero_of_not_mem dist_orthogonal_projection_ne_zero_of_not_mem\n\n",
 "dist_orthogonal_projection_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The distance to a point's orthogonal projection is 0 iff it lies in the subspace. -/\ntheorem dist_orthogonal_projection_eq_zero_iff {s : affine_subspace (exprℝ) P} [nonempty s] [complete_space s.direction]\n    {p : P} : dist p (orthogonal_projection s p) = 0 ↔ p ∈ s := by\n  rw [dist_comm, dist_eq_zero, orthogonal_projection_eq_self_iff]\n#align dist_orthogonal_projection_eq_zero_iff dist_orthogonal_projection_eq_zero_iff\n\n",
 "dist_of_mem_subset_sphere":
 "theorem dist_of_mem_subset_sphere {p : P} {ps : set P} {s : sphere P} (hp : p ∈ ps) (hps : ps ⊆ (s : set P)) :\n    dist p s.center = s.radius :=\n  mem_sphere.1 (sphere.mem_coe.1 (Set.mem_of_mem_of_subset hp hps))\n#align dist_of_mem_subset_sphere dist_of_mem_subset_sphere\n\n",
 "dist_of_mem_subset_mk_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem dist_of_mem_subset_mk_sphere {p c : P} {ps : set P} {r : exprℝ} (hp : p ∈ ps)\n    (hps : ps ⊆ ↑(⟨c, r⟩ : sphere P)) : dist p c = r :=\n  dist_of_mem_subset_sphere hp hps\n#align dist_of_mem_subset_mk_sphere dist_of_mem_subset_mk_sphere\n\n",
 "dist_left_midpoint_eq_dist_right_midpoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2020 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers, Manuel Candales\n-/\n/-- The midpoint of the segment AB is the same distance from A as it is from B. -/\ntheorem dist_left_midpoint_eq_dist_right_midpoint (p1 p2 : P) :\n    dist p1 (midpoint (exprℝ) p1 p2) = dist p2 (midpoint (exprℝ) p1 p2) := by\n  rw [dist_left_midpoint p1 p2, dist_right_midpoint p1 p2]\n#align dist_left_midpoint_eq_dist_right_midpoint dist_left_midpoint_eq_dist_right_midpoint\n\n",
 "dist_center_eq_dist_center_of_mem_sphere'":
 "theorem dist_center_eq_dist_center_of_mem_sphere' {p₁ p₂ : P} {s : sphere P} (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s) :\n    dist s.center p₁ = dist s.center p₂ := by rw [mem_sphere'.1 hp₁, mem_sphere'.1 hp₂]\n#align dist_center_eq_dist_center_of_mem_sphere' dist_center_eq_dist_center_of_mem_sphere'\n\n",
 "dist_center_eq_dist_center_of_mem_sphere":
 "theorem dist_center_eq_dist_center_of_mem_sphere {p₁ p₂ : P} {s : sphere P} (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s) :\n    dist p₁ s.center = dist p₂ s.center := by rw [mem_sphere.1 hp₁, mem_sphere.1 hp₂]\n#align dist_center_eq_dist_center_of_mem_sphere dist_center_eq_dist_center_of_mem_sphere\n\n",
 "dist_affine_combination":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The distance between two points given with `affine_combination`,\nin terms of the pairwise distances between the points in that\ncombination. -/\ntheorem dist_affine_combination {ι : Type _} {s : Finset ι} {w₁ w₂ : ι → exprℝ} (p : ι → P)\n    (h₁ : finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (w₁ i) = 1)\n    (h₂ :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (w₂ i) = 1) :\n    by\n    have a₁ := s.affine_combination p w₁ <;> have a₂ := s.affine_combination p w₂ <;>\n      exact\n        dist a₁ a₂ * dist a₁ a₂ =\n          -finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                  ((w₁ - w₂) i₁ * (w₁ - w₂) i₂ * (dist (p i₁) (p i₂) * dist (p i₁) (p i₂)))) /\n            2 :=\n  by\n  rw [dist_eq_norm_vsub V (s.affine_combination p w₁) (s.affine_combination p w₂), ← inner_self_eq_norm_mul_norm,\n    finset.affine_combination_vsub]\n  have h :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s ((w₁ - w₂) i) =\n      0 :=\n    by simp_rw [pi.sub_apply, finset.sum_sub_distrib, h₁, h₂, sub_self]\n  exact inner_weighted_vsub p h p h\n#align dist_affine_combination dist_affine_combination\n\n",
 "cospherical_singleton":
 "/-- A single point is cospherical. -/\ntheorem cospherical_singleton (p : P) : cospherical ({p} : set P) :=\n  by\n  use p\n  simp\n#align cospherical_singleton cospherical_singleton\n\n",
 "cospherical_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Two points are cospherical. -/\ntheorem cospherical_pair (p₁ p₂ : P) : cospherical ({p₁, p₂} : set P) :=\n  by\n  use «expr +ᵥ » («expr • » (2⁻¹ : exprℝ) («expr -ᵥ » p₂ p₁)) p₁, (2⁻¹ : exprℝ) * dist p₂ p₁\n  intro p\n  rw [Set.mem_insert_iff, Set.mem_singleton_iff]\n  rintro ⟨_ | _⟩\n  · rw [dist_eq_norm_vsub V p₁, vsub_vadd_eq_vsub_sub, vsub_self, zero_sub, norm_neg, norm_smul, dist_eq_norm_vsub V p₂]\n    simp\n  · rw [H, dist_eq_norm_vsub V p₂, vsub_vadd_eq_vsub_sub, dist_eq_norm_vsub V p₂]\n    conv_lhs =>\n      congr\n      congr\n      rw [← one_smul (exprℝ) («expr -ᵥ » p₂ p₁ : V)]\n    rw [← sub_smul, norm_smul]\n    norm_num\n#align cospherical_pair cospherical_pair\n\n",
 "cospherical_iff_exists_sphere":
 "/-- A set of points is cospherical if and only if they lie in some sphere. -/\ntheorem cospherical_iff_exists_sphere {ps : set P} : cospherical ps ↔ ∃ s : sphere P, ps ⊆ (s : set P) :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · rcases h with ⟨c, r, h⟩\n    exact ⟨⟨c, r⟩, h⟩\n  · rcases h with ⟨s, h⟩\n    exact ⟨s.center, s.radius, h⟩\n#align cospherical_iff_exists_sphere cospherical_iff_exists_sphere\n\n",
 "cospherical_empty":
 "/-- The empty set is cospherical. -/\ntheorem cospherical_empty : cospherical (∅ : set P) :=\n  by\n  use add_torsor.nonempty.some\n  simp\n#align cospherical_empty cospherical_empty\n\n",
 "cospherical_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The definition of `cospherical`. -/\ntheorem cospherical_def (ps : set P) :\n    cospherical ps ↔ ∃ (center : P)(radius : exprℝ), ∀ p ∈ ps, dist p center = radius :=\n  iff.rfl\n#align cospherical_def cospherical_def\n\n",
 "cospherical":
 "/-- The set of points in a sphere is cospherical. -/\ntheorem sphere.cospherical (s : sphere P) : cospherical (s : set P) :=\n  cospherical_iff_exists_sphere.2 ⟨s, Set.Subset.rfl⟩\n#align sphere.cospherical sphere.cospherical\n\n",
 "concyclic_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A single point is concyclic. -/\ntheorem concyclic_singleton (p : P) : concyclic ({p} : set P) :=\n  ⟨cospherical_singleton p, coplanar_singleton (exprℝ) p⟩\n#align concyclic_singleton concyclic_singleton\n\n",
 "concyclic_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Two points are concyclic. -/\ntheorem concyclic_pair (p₁ p₂ : P) : concyclic ({p₁, p₂} : set P) :=\n  ⟨cospherical_pair p₁ p₂, coplanar_pair (exprℝ) p₁ p₂⟩\n#align concyclic_pair concyclic_pair\n\n",
 "concyclic_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The empty set is concyclic. -/\ntheorem concyclic_empty : concyclic (∅ : set P) :=\n  ⟨cospherical_empty, coplanar_empty (exprℝ) P⟩\n#align concyclic_empty concyclic_empty\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem sphere.coe_mk (c : P) (r : exprℝ) : ↑(⟨c, r⟩ : sphere P) = metric.sphere c r :=\n  rfl\n#align sphere.coe_mk sphere.coe_mk\n\n",
 "coe_def":
 "theorem sphere.coe_def (s : sphere P) : (s : set P) = metric.sphere s.center s.radius :=\n  rfl\n#align sphere.coe_def sphere.coe_def\n\n",
 "center_ne_iff_ne_of_mem":
 "theorem sphere.center_ne_iff_ne_of_mem {s₁ s₂ : sphere P} {p : P} (hs₁ : p ∈ s₁) (hs₂ : p ∈ s₂) :\n    s₁.center ≠ s₂.center ↔ s₁ ≠ s₂ :=\n  (sphere.center_eq_iff_eq_of_mem hs₁ hs₂).not\n#align sphere.center_ne_iff_ne_of_mem sphere.center_ne_iff_ne_of_mem\n\n",
 "center_eq_iff_eq_of_mem":
 "theorem sphere.center_eq_iff_eq_of_mem {s₁ s₂ : sphere P} {p : P} (hs₁ : p ∈ s₁) (hs₂ : p ∈ s₂) :\n    s₁.center = s₂.center ↔ s₁ = s₂ :=\n  by\n  refine' ⟨fun h => sphere.ext _ _ h _, fun h => h ▸ rfl⟩\n  rw [mem_sphere] at hs₁ hs₂\n  rw [← hs₁, ← hs₂, h]\n#align sphere.center_eq_iff_eq_of_mem sphere.center_eq_iff_eq_of_mem\n\n",
 "affine_independent_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/-- The three points of a cospherical set are affinely independent. -/\ntheorem cospherical.affine_independent_of_ne {p₁ p₂ p₃ : P} (hs : cospherical ({p₁, p₂, p₃} : set P)) (h₁₂ : p₁ ≠ p₂)\n    (h₁₃ : p₁ ≠ p₃) (h₂₃ : p₂ ≠ p₃) :\n    affine_independent (exprℝ)\n      («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  hs.affine_independent_of_mem_of_ne (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_insert _ _))\n    (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))) h₁₂ h₁₃ h₂₃\n#align cospherical.affine_independent_of_ne cospherical.affine_independent_of_ne\n\n",
 "affine_independent_of_mem_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/-- Any three points in a cospherical set are affinely independent. -/\ntheorem cospherical.affine_independent_of_mem_of_ne {s : set P} (hs : cospherical s) {p₁ p₂ p₃ : P} (h₁ : p₁ ∈ s)\n    (h₂ : p₂ ∈ s) (h₃ : p₃ ∈ s) (h₁₂ : p₁ ≠ p₂) (h₁₃ : p₁ ≠ p₃) (h₂₃ : p₂ ≠ p₃) :\n    affine_independent (exprℝ)\n      («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  by\n  refine' hs.affine_independent _ _\n  · simp [h₁, h₂, h₃, Set.insert_subset]\n  · erw [fin.cons_injective_iff, fin.cons_injective_iff]\n    simp [h₁₂, h₁₃, h₂₃, function.injective]\n#align cospherical.affine_independent_of_mem_of_ne cospherical.affine_independent_of_mem_of_ne\n\n",
 "affine_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Any three points in a cospherical set are affinely independent. -/\ntheorem cospherical.affine_independent {s : set P} (hs : cospherical s) {p : fin 3 → P} (hps : Set.range p ⊆ s)\n    (hpi : function.injective p) : affine_independent (exprℝ) p :=\n  by\n  rw [affine_independent_iff_not_collinear]\n  intro hc\n  rw [collinear_iff_of_mem (Set.mem_range_self (0 : fin 3))] at hc\n  rcases hc with ⟨v, hv⟩\n  rw [Set.forall_range_iff] at hv\n  have hv0 : v ≠ 0 := by\n    intro h\n    have he : p 1 = p 0 := by simpa [h] using hv 1\n    exact (by decide : (1 : fin 3) ≠ 0) (hpi he)\n  rcases hs with ⟨c, r, hs⟩\n  have hs' := fun i => hs (p i) (Set.mem_of_mem_of_subset (Set.mem_range_self _) hps)\n  choose f hf using hv\n  have hsd : ∀ i, dist («expr +ᵥ » («expr • » (f i) v) (p 0)) c = r :=\n    by\n    intro i\n    rw [← hf]\n    exact hs' i\n  have hf0 : f 0 = 0 := by\n    have hf0' := hf 0\n    rw [eq_comm, ← @vsub_eq_zero_iff_eq V, vadd_vsub, smul_eq_zero] at hf0'\n    simpa [hv0] using hf0'\n  have hfi : function.injective f := by\n    intro i j h\n    have hi := hf i\n    rw [h, ← hf j] at hi\n    exact hpi hi\n  simp_rw [← hsd 0, hf0, zero_smul, zero_vadd, dist_smul_vadd_eq_dist (p 0) c hv0] at hsd\n  have hfn0 : ∀ i, i ≠ 0 → f i ≠ 0 := fun i => (hfi.ne_iff' hf0).2\n  have hfn0' : ∀ i, i ≠ 0 → f i = -2 * inner.real v («expr -ᵥ » (p 0) c) / inner.real v v :=\n    by\n    intro i hi\n    have hsdi := hsd i\n    simpa [hfn0, hi] using hsdi\n  have hf12 : f 1 = f 2 := by rw [hfn0' 1 (by decide), hfn0' 2 (by decide)]\n  exact (by decide : (1 : fin 3) ≠ 2) (hfi hf12)\n#align cospherical.affine_independent cospherical.affine_independent\n\n"}