{"wbtw_of_collinear_of_dist_center_le_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Given three collinear points, two on a sphere and one not outside it, the one not outside it\nis weakly between the other two points. -/\ntheorem wbtw_of_collinear_of_dist_center_le_radius {s : sphere P} {p₁ p₂ p₃ : P}\n    (h : Collinear (exprℝ) ({p₁, p₂, p₃} : Set P)) (hp₁ : p₁ ∈ s) (hp₂ : dist p₂ s.center ≤ s.radius) (hp₃ : p₃ ∈ s)\n    (hp₁p₃ : p₁ ≠ p₃) : wbtw (exprℝ) p₁ p₂ p₃ :=\n  h.wbtw_of_dist_eq_of_dist_le hp₁ hp₂ hp₃ hp₁p₃\n#align wbtw_of_collinear_of_dist_center_le_radius wbtw_of_collinear_of_dist_center_le_radius\n\n",
 "subset_sphere":
 "theorem subset_sphere {ps : Set P} {s : sphere P} : ps ⊆ s ↔ ∀ p ∈ ps, p ∈ s :=\n  iff.rfl\n#align subset_sphere subset_sphere\n\n",
 "subset":
 "/-- A subset of a concyclic set is concyclic. -/\ntheorem concyclic.subset {ps₁ ps₂ : Set P} (hs : ps₁ ⊆ ps₂) (h : concyclic ps₂) : concyclic ps₁ :=\n  ⟨h.1.subset hs, h.2.subset hs⟩\n#align concyclic.subset concyclic.subset\n\n",
 "sbtw_of_collinear_of_dist_center_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Given three collinear points, two on a sphere and one inside it, the one inside it is\nstrictly between the other two points. -/\ntheorem sbtw_of_collinear_of_dist_center_lt_radius {s : sphere P} {p₁ p₂ p₃ : P}\n    (h : Collinear (exprℝ) ({p₁, p₂, p₃} : Set P)) (hp₁ : p₁ ∈ s) (hp₂ : dist p₂ s.center < s.radius) (hp₃ : p₃ ∈ s)\n    (hp₁p₃ : p₁ ≠ p₃) : sbtw (exprℝ) p₁ p₂ p₃ :=\n  h.sbtw_of_dist_eq_of_dist_lt hp₁ hp₂ hp₃ hp₁p₃\n#align sbtw_of_collinear_of_dist_center_lt_radius sbtw_of_collinear_of_dist_center_lt_radius\n\n",
 "ne_iff":
 "theorem sphere.ne_iff {s₁ s₂ : sphere P} : s₁ ≠ s₂ ↔ s₁.center ≠ s₂.center ∨ s₁.radius ≠ s₂.radius := by\n  rw [← not_and_or, ← sphere.ext_iff]\n#align sphere.ne_iff sphere.ne_iff\n\n",
 "mk_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem sphere.mk_radius (c : P) (r : exprℝ) : (⟨c, r⟩ : sphere P).radius = r :=\n  rfl\n#align sphere.mk_radius sphere.mk_radius\n\n",
 "mk_center_radius":
 "@[simp]\ntheorem sphere.mk_center_radius (s : sphere P) : (⟨s.center, s.radius⟩ : sphere P) = s := by ext <;> rfl\n#align sphere.mk_center_radius sphere.mk_center_radius\n\n",
 "mk_center":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2020 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers\n-/\ntheorem sphere.mk_center (c : P) (r : exprℝ) : (⟨c, r⟩ : sphere P).center = c :=\n  rfl\n#align sphere.mk_center sphere.mk_center\n\n",
 "mem_sphere'":
 "theorem mem_sphere' {p : P} {s : sphere P} : p ∈ s ↔ dist s.center p = s.radius :=\n  Metric.mem_sphere'\n#align mem_sphere' mem_sphere'\n\n",
 "mem_sphere":
 "theorem mem_sphere {p : P} {s : sphere P} : p ∈ s ↔ dist p s.center = s.radius :=\n  iff.rfl\n#align mem_sphere mem_sphere\n\n",
 "mem_coe":
 "@[simp]\ntheorem sphere.mem_coe {p : P} {s : sphere P} : p ∈ (s : Set P) ↔ p ∈ s :=\n  iff.rfl\n#align sphere.mem_coe sphere.mem_coe\n\n",
 "inner_vsub_vsub_of_mem_sphere_of_mem_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Suppose that `p₁` and `p₂` lie in spheres `s₁` and `s₂`.  Then the vector between the centers\nof those spheres is orthogonal to that between `p₁` and `p₂`; this is a version of\n`inner_vsub_vsub_of_dist_eq_of_dist_eq` for bundled spheres.  (In two dimensions, this says that\nthe diagonals of a kite are orthogonal.) -/\ntheorem inner_vsub_vsub_of_mem_sphere_of_mem_sphere {p₁ p₂ : P} {s₁ s₂ : sphere P} (hp₁s₁ : p₁ ∈ s₁) (hp₂s₁ : p₂ ∈ s₁)\n    (hp₁s₂ : p₁ ∈ s₂) (hp₂s₂ : p₂ ∈ s₂) : inner.real («expr -ᵥ » s₂.center s₁.center) («expr -ᵥ » p₂ p₁) = 0 :=\n  inner_vsub_vsub_of_dist_eq_of_dist_eq (dist_center_eq_dist_center_of_mem_sphere hp₁s₁ hp₂s₁)\n    (dist_center_eq_dist_center_of_mem_sphere hp₁s₂ hp₂s₂)\n#align inner_vsub_vsub_of_mem_sphere_of_mem_sphere inner_vsub_vsub_of_mem_sphere_of_mem_sphere\n\n",
 "inner_pos_or_eq_of_dist_le_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Given a point on a sphere and a point not outside it, the inner product between the\ndifference of those points and the radius vector is positive unless the points are equal. -/\ntheorem inner_pos_or_eq_of_dist_le_radius {s : sphere P} {p₁ p₂ : P} (hp₁ : p₁ ∈ s)\n    (hp₂ : dist p₂ s.center ≤ s.radius) : 0 < inner.real («expr -ᵥ » p₁ p₂) («expr -ᵥ » p₁ s.center) ∨ p₁ = p₂ :=\n  by\n  by_cases h : p₁ = p₂; · exact or.inr h\n  refine' or.inl _\n  rw [mem_sphere] at hp₁\n  rw [← vsub_sub_vsub_cancel_right p₁ p₂ s.center, inner_sub_left,\n    real_inner_self_eq_norm_mul_norm,--, ←dist_eq_norm_vsub, hp₁\n    sub_pos]\n  refine' lt_of_le_of_ne ((real_inner_le_norm _ _).trans (mul_le_mul_of_nonneg_right _ (norm_nonneg _))) _\n  · rwa [← dist_eq_norm_vsub, ← dist_eq_norm_vsub, hp₁]\n  · rcases hp₂.lt_or_eq with (hp₂' | hp₂')\n    · refine' ((real_inner_le_norm _ _).trans_lt (mul_lt_mul_of_pos_right _ _)).ne\n      · rwa [← hp₁, @dist_eq_norm_vsub V, @dist_eq_norm_vsub V] at hp₂'\n      · rw [norm_pos_iff, vsub_ne_zero]\n        rintro rfl\n        rw [← hp₁] at hp₂'\n        refine' (dist_nonneg.not_lt : ¬dist p₂ s.center < 0) _\n        simpa using hp₂'\n    · rw [← hp₁, @dist_eq_norm_vsub V, @dist_eq_norm_vsub V] at hp₂'\n      nth_rw 1 [← hp₂']\n      rw [ne.def, inner_eq_norm_mul_iff_real, hp₂', ← sub_eq_zero, ← smul_sub, vsub_sub_vsub_cancel_right, ← ne.def,\n        smul_ne_zero_iff, vsub_ne_zero, and_iff_left (ne.symm h), norm_ne_zero_iff, vsub_ne_zero]\n      rintro rfl\n      refine' h (Eq.symm _)\n      simpa using hp₂'\n#align inner_pos_or_eq_of_dist_le_radius inner_pos_or_eq_of_dist_le_radius\n\n",
 "inner_pos_of_dist_lt_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Given a point on a sphere and a point inside it, the inner product between the difference of\nthose points and the radius vector is positive. -/\ntheorem inner_pos_of_dist_lt_radius {s : sphere P} {p₁ p₂ : P} (hp₁ : p₁ ∈ s) (hp₂ : dist p₂ s.center < s.radius) :\n    0 < inner.real («expr -ᵥ » p₁ p₂) («expr -ᵥ » p₁ s.center) :=\n  by\n  by_cases h : p₁ = p₂\n  · rw [h, mem_sphere] at hp₁\n    exact false.elim (hp₂.ne hp₁)\n  exact (inner_pos_or_eq_of_dist_le_radius hp₁ hp₂.le).resolve_right h\n#align inner_pos_of_dist_lt_radius inner_pos_of_dist_lt_radius\n\n",
 "inner_nonneg_of_dist_le_radius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Given a point on a sphere and a point not outside it, the inner product between the\ndifference of those points and the radius vector is nonnegative. -/\ntheorem inner_nonneg_of_dist_le_radius {s : sphere P} {p₁ p₂ : P} (hp₁ : p₁ ∈ s) (hp₂ : dist p₂ s.center ≤ s.radius) :\n    0 ≤ inner.real («expr -ᵥ » p₁ p₂) («expr -ᵥ » p₁ s.center) :=\n  by\n  rcases inner_pos_or_eq_of_dist_le_radius hp₁ hp₂ with (h | rfl)\n  · exact h.le\n  · simp\n#align inner_nonneg_of_dist_le_radius inner_nonneg_of_dist_le_radius\n\n",
 "eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Two spheres intersect in at most two points in a two-dimensional subspace containing their\ncenters; this is a version of `eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two` for bundled\nspheres. -/\ntheorem eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two {s : AffineSubspace (exprℝ) P}\n    [FiniteDimensional (exprℝ) s.direction] (hd : finrank (exprℝ) s.direction = 2) {s₁ s₂ : sphere P} {p₁ p₂ p : P}\n    (hs₁ : s₁.center ∈ s) (hs₂ : s₂.center ∈ s) (hp₁s : p₁ ∈ s) (hp₂s : p₂ ∈ s) (hps : p ∈ s) (hs : s₁ ≠ s₂)\n    (hp : p₁ ≠ p₂) (hp₁s₁ : p₁ ∈ s₁) (hp₂s₁ : p₂ ∈ s₁) (hps₁ : p ∈ s₁) (hp₁s₂ : p₁ ∈ s₂) (hp₂s₂ : p₂ ∈ s₂)\n    (hps₂ : p ∈ s₂) : p = p₁ ∨ p = p₂ :=\n  eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two hd hs₁ hs₂ hp₁s hp₂s hps\n    ((sphere.center_ne_iff_ne_of_mem hps₁ hps₂).2 hs) hp hp₁s₁ hp₂s₁ hps₁ hp₁s₂ hp₂s₂ hps₂\n#align eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two\n\n",
 "eq_of_mem_sphere_of_mem_sphere_of_finrank_eq_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Two spheres intersect in at most two points in two-dimensional space; this is a version of\n`eq_of_dist_eq_of_dist_eq_of_finrank_eq_two` for bundled spheres. -/\ntheorem eq_of_mem_sphere_of_mem_sphere_of_finrank_eq_two [FiniteDimensional (exprℝ) V] (hd : finrank (exprℝ) V = 2)\n    {s₁ s₂ : sphere P} {p₁ p₂ p : P} (hs : s₁ ≠ s₂) (hp : p₁ ≠ p₂) (hp₁s₁ : p₁ ∈ s₁) (hp₂s₁ : p₂ ∈ s₁) (hps₁ : p ∈ s₁)\n    (hp₁s₂ : p₁ ∈ s₂) (hp₂s₂ : p₂ ∈ s₂) (hps₂ : p ∈ s₂) : p = p₁ ∨ p = p₂ :=\n  eq_of_dist_eq_of_dist_eq_of_finrank_eq_two hd ((sphere.center_ne_iff_ne_of_mem hps₁ hps₂).2 hs) hp hp₁s₁ hp₂s₁ hps₁\n    hp₁s₂ hp₂s₂ hps₂\n#align eq_of_mem_sphere_of_mem_sphere_of_finrank_eq_two eq_of_mem_sphere_of_mem_sphere_of_finrank_eq_two\n\n",
 "dist_of_mem_subset_sphere":
 "theorem dist_of_mem_subset_sphere {p : P} {ps : Set P} {s : sphere P} (hp : p ∈ ps) (hps : ps ⊆ (s : Set P)) :\n    dist p s.center = s.radius :=\n  mem_sphere.1 (sphere.mem_coe.1 (Set.mem_of_mem_of_subset hp hps))\n#align dist_of_mem_subset_sphere dist_of_mem_subset_sphere\n\n",
 "dist_of_mem_subset_mk_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem dist_of_mem_subset_mk_sphere {p c : P} {ps : Set P} {r : exprℝ} (hp : p ∈ ps)\n    (hps : ps ⊆ ↑(⟨c, r⟩ : sphere P)) : dist p c = r :=\n  dist_of_mem_subset_sphere hp hps\n#align dist_of_mem_subset_mk_sphere dist_of_mem_subset_mk_sphere\n\n",
 "dist_center_eq_dist_center_of_mem_sphere'":
 "theorem dist_center_eq_dist_center_of_mem_sphere' {p₁ p₂ : P} {s : sphere P} (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s) :\n    dist s.center p₁ = dist s.center p₂ := by rw [mem_sphere'.1 hp₁, mem_sphere'.1 hp₂]\n#align dist_center_eq_dist_center_of_mem_sphere' dist_center_eq_dist_center_of_mem_sphere'\n\n",
 "dist_center_eq_dist_center_of_mem_sphere":
 "theorem dist_center_eq_dist_center_of_mem_sphere {p₁ p₂ : P} {s : sphere P} (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s) :\n    dist p₁ s.center = dist p₂ s.center := by rw [mem_sphere.1 hp₁, mem_sphere.1 hp₂]\n#align dist_center_eq_dist_center_of_mem_sphere dist_center_eq_dist_center_of_mem_sphere\n\n",
 "cospherical_singleton":
 "/-- A single point is cospherical. -/\ntheorem cospherical_singleton (p : P) : cospherical ({p} : Set P) :=\n  by\n  use p\n  simp\n#align cospherical_singleton cospherical_singleton\n\n",
 "cospherical_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Two points are cospherical. -/\ntheorem cospherical_pair (p₁ p₂ : P) : cospherical ({p₁, p₂} : Set P) :=\n  ⟨midpoint (exprℝ) p₁ p₂, («expr‖ ‖» (2 : exprℝ))⁻¹ * dist p₁ p₂,\n    by\n    rintro p (rfl | rfl | _)\n    · rw [dist_comm, dist_midpoint_left]\n    · rw [dist_comm, dist_midpoint_right]⟩\n#align cospherical_pair cospherical_pair\n\n",
 "cospherical_iff_exists_sphere":
 "/-- A set of points is cospherical if and only if they lie in some sphere. -/\ntheorem cospherical_iff_exists_sphere {ps : Set P} : cospherical ps ↔ ∃ s : sphere P, ps ⊆ (s : Set P) :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · rcases h with ⟨c, r, h⟩\n    exact ⟨⟨c, r⟩, h⟩\n  · rcases h with ⟨s, h⟩\n    exact ⟨s.center, s.radius, h⟩\n#align cospherical_iff_exists_sphere cospherical_iff_exists_sphere\n\n",
 "cospherical_empty":
 "/-- The empty set is cospherical. -/\ntheorem cospherical_empty [Nonempty P] : cospherical (∅ : Set P) :=\n  let ⟨p⟩ := ‹Nonempty P›\n  ⟨p, 0, fun p => false.elim⟩\n#align cospherical_empty cospherical_empty\n\n",
 "cospherical_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The definition of `cospherical`. -/\ntheorem cospherical_def (ps : Set P) :\n    cospherical ps ↔ ∃ (center : P)(radius : exprℝ), ∀ p ∈ ps, dist p center = radius :=\n  iff.rfl\n#align cospherical_def cospherical_def\n\n",
 "cospherical":
 "/-- The set of points in a sphere is cospherical. -/\ntheorem sphere.cospherical (s : sphere P) : cospherical (s : Set P) :=\n  cospherical_iff_exists_sphere.2 ⟨s, Set.Subset.rfl⟩\n#align sphere.cospherical sphere.cospherical\n\n",
 "concyclic_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A single point is concyclic. -/\ntheorem concyclic_singleton (p : P) : concyclic ({p} : Set P) :=\n  ⟨cospherical_singleton p, coplanar_singleton (exprℝ) p⟩\n#align concyclic_singleton concyclic_singleton\n\n",
 "concyclic_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Two points are concyclic. -/\ntheorem concyclic_pair (p₁ p₂ : P) : concyclic ({p₁, p₂} : Set P) :=\n  ⟨cospherical_pair p₁ p₂, coplanar_pair (exprℝ) p₁ p₂⟩\n#align concyclic_pair concyclic_pair\n\n",
 "concyclic_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The empty set is concyclic. -/\ntheorem concyclic_empty : concyclic (∅ : Set P) :=\n  ⟨cospherical_empty, coplanar_empty (exprℝ) P⟩\n#align concyclic_empty concyclic_empty\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem sphere.coe_mk (c : P) (r : exprℝ) : ↑(⟨c, r⟩ : sphere P) = Metric.sphere c r :=\n  rfl\n#align sphere.coe_mk sphere.coe_mk\n\n",
 "coe_def":
 "theorem sphere.coe_def (s : sphere P) : (s : Set P) = Metric.sphere s.center s.radius :=\n  rfl\n#align sphere.coe_def sphere.coe_def\n\n",
 "center_ne_iff_ne_of_mem":
 "theorem sphere.center_ne_iff_ne_of_mem {s₁ s₂ : sphere P} {p : P} (hs₁ : p ∈ s₁) (hs₂ : p ∈ s₂) :\n    s₁.center ≠ s₂.center ↔ s₁ ≠ s₂ :=\n  (sphere.center_eq_iff_eq_of_mem hs₁ hs₂).not\n#align sphere.center_ne_iff_ne_of_mem sphere.center_ne_iff_ne_of_mem\n\n",
 "center_eq_iff_eq_of_mem":
 "theorem sphere.center_eq_iff_eq_of_mem {s₁ s₂ : sphere P} {p : P} (hs₁ : p ∈ s₁) (hs₂ : p ∈ s₂) :\n    s₁.center = s₂.center ↔ s₁ = s₂ :=\n  by\n  refine' ⟨fun h => sphere.ext _ _ h _, fun h => h ▸ rfl⟩\n  rw [mem_sphere] at hs₁ hs₂\n  rw [← hs₁, ← hs₂, h]\n#align sphere.center_eq_iff_eq_of_mem sphere.center_eq_iff_eq_of_mem\n\n",
 "affine_independent_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/-- The three points of a cospherical set are affinely independent. -/\ntheorem cospherical.affine_independent_of_ne {p₁ p₂ p₃ : P} (hs : cospherical ({p₁, p₂, p₃} : Set P)) (h₁₂ : p₁ ≠ p₂)\n    (h₁₃ : p₁ ≠ p₃) (h₂₃ : p₂ ≠ p₃) :\n    AffineIndependent (exprℝ)\n      («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  hs.affine_independent_of_mem_of_ne (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_insert _ _))\n    (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))) h₁₂ h₁₃ h₂₃\n#align cospherical.affine_independent_of_ne cospherical.affine_independent_of_ne\n\n",
 "affine_independent_of_mem_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/-- Any three points in a cospherical set are affinely independent. -/\ntheorem cospherical.affine_independent_of_mem_of_ne {s : Set P} (hs : cospherical s) {p₁ p₂ p₃ : P} (h₁ : p₁ ∈ s)\n    (h₂ : p₂ ∈ s) (h₃ : p₃ ∈ s) (h₁₂ : p₁ ≠ p₂) (h₁₃ : p₁ ≠ p₃) (h₂₃ : p₂ ≠ p₃) :\n    AffineIndependent (exprℝ)\n      («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  by\n  refine' hs.affine_independent _ _\n  · simp [h₁, h₂, h₃, Set.insert_subset]\n  · erw [Fin.cons_injective_iff, Fin.cons_injective_iff]\n    simp [h₁₂, h₁₃, h₂₃, function.injective]\n#align cospherical.affine_independent_of_mem_of_ne cospherical.affine_independent_of_mem_of_ne\n\n",
 "affine_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Any three points in a cospherical set are affinely independent. -/\ntheorem cospherical.affine_independent {s : Set P} (hs : cospherical s) {p : Fin 3 → P} (hps : Set.range p ⊆ s)\n    (hpi : function.injective p) : AffineIndependent (exprℝ) p :=\n  by\n  rw [affineIndependent_iff_not_collinear]\n  intro hc\n  rw [collinear_iff_of_mem (Set.mem_range_self (0 : Fin 3))] at hc\n  rcases hc with ⟨v, hv⟩\n  rw [Set.forall_range_iff] at hv\n  have hv0 : v ≠ 0 := by\n    intro h\n    have he : p 1 = p 0 := by simpa [h] using hv 1\n    exact (by decide : (1 : Fin 3) ≠ 0) (hpi he)\n  rcases hs with ⟨c, r, hs⟩\n  have hs' := fun i => hs (p i) (Set.mem_of_mem_of_subset (Set.mem_range_self _) hps)\n  choose f hf using hv\n  have hsd : ∀ i, dist («expr +ᵥ » («expr • » (f i) v) (p 0)) c = r :=\n    by\n    intro i\n    rw [← hf]\n    exact hs' i\n  have hf0 : f 0 = 0 := by\n    have hf0' := hf 0\n    rw [eq_comm, ← @vsub_eq_zero_iff_eq V, vadd_vsub, smul_eq_zero] at hf0'\n    simpa [hv0] using hf0'\n  have hfi : function.injective f := by\n    intro i j h\n    have hi := hf i\n    rw [h, ← hf j] at hi\n    exact hpi hi\n  simp_rw [← hsd 0, hf0, zero_smul, zero_vadd, dist_smul_vadd_eq_dist (p 0) c hv0] at hsd\n  have hfn0 : ∀ i, i ≠ 0 → f i ≠ 0 := fun i => (hfi.ne_iff' hf0).2\n  have hfn0' : ∀ i, i ≠ 0 → f i = -2 * inner.real v («expr -ᵥ » (p 0) c) / inner.real v v :=\n    by\n    intro i hi\n    have hsdi := hsd i\n    simpa [hfn0, hi] using hsdi\n  have hf12 : f 1 = f 2 := by rw [hfn0' 1 (by decide), hfn0' 2 (by decide)]\n  exact (by decide : (1 : Fin 3) ≠ 2) (hfi hf12)\n#align cospherical.affine_independent cospherical.affine_independent\n\n"}