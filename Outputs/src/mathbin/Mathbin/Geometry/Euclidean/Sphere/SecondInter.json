{"wbtw_second_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- If the vector passed to `second_inter` is given by a subtraction involving the point in\n`second_inter`, and the second point is not outside the sphere, the second point is weakly\nbetween the first point and the result of `second_inter`. -/\ntheorem sphere.wbtw_second_inter {s : sphere P} {p p' : P} (hp : p ∈ s) (hp' : dist p' s.center ≤ s.radius) :\n    wbtw (exprℝ) p p' (s.second_inter p («expr -ᵥ » p' p)) :=\n  by\n  by_cases h : p' = p; · simp [h]\n  refine'\n    wbtw_of_collinear_of_dist_center_le_radius (s.second_inter_collinear p p') hp hp' ((sphere.second_inter_mem _).2 hp)\n      _\n  intro he\n  rw [eq_comm, sphere.second_inter_eq_self_iff, ← neg_neg («expr -ᵥ » p' p), inner_neg_left, neg_vsub_eq_vsub_rev,\n    neg_eq_zero, eq_comm] at he\n  exact ((inner_pos_or_eq_of_dist_le_radius hp hp').resolve_right (ne.symm h)).ne he\n#align sphere.wbtw_second_inter sphere.wbtw_second_inter\n\n",
 "second_inter_zero":
 "/-- If the vector is zero, `second_inter` gives the original point. -/\n@[simp]\ntheorem sphere.second_inter_zero (s : sphere P) (p : P) : s.second_inter p (0 : V) = p := by simp [sphere.second_inter]\n#align sphere.second_inter_zero sphere.second_inter_zero\n\n",
 "second_inter_vsub_mem_affine_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If the vector passed to `second_inter` is given by a subtraction involving the point in\n`second_inter`, the result lies in the span of the two points. -/\ntheorem sphere.second_inter_vsub_mem_affine_span (s : sphere P) (p₁ p₂ : P) :\n    s.second_inter p₁ («expr -ᵥ » p₂ p₁) ∈ «exprline[ , , ]» (exprℝ) p₁ p₂ :=\n  smul_vsub_vadd_mem_affineSpan_pair _ _ _\n#align sphere.second_inter_vsub_mem_affine_span sphere.second_inter_vsub_mem_affine_span\n\n",
 "second_inter_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- `second_inter` is unchanged by multiplying the vector by a nonzero real. -/\n@[simp]\ntheorem sphere.second_inter_smul (s : sphere P) (p : P) (v : V) {r : exprℝ} (hr : r ≠ 0) :\n    s.second_inter p («expr • » r v) = s.second_inter p v :=\n  by\n  simp_rw [sphere.second_inter, real_inner_smul_left, inner_smul_right, smul_smul, div_mul_eq_div_div]\n  rw [mul_comm, ← mul_div_assoc, ← mul_div_assoc, mul_div_cancel_left _ hr, mul_comm, mul_assoc,\n    mul_div_cancel_left _ hr, mul_comm]\n#align sphere.second_inter_smul sphere.second_inter_smul\n\n",
 "second_inter_second_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Applying `second_inter` twice returns the original point. -/\n@[simp]\ntheorem sphere.second_inter_second_inter (s : sphere P) (p : P) (v : V) : s.second_inter (s.second_inter p v) v = p :=\n  by\n  by_cases hv : v = 0; · simp [hv]\n  have hv' : inner.real v v ≠ 0 := inner_self_ne_zero.2 hv\n  simp only [sphere.second_inter, vadd_vsub_assoc, vadd_vadd, inner_add_right, inner_smul_right, div_mul_cancel _ hv']\n  rw [← @vsub_eq_zero_iff_eq V, vadd_vsub, ← add_smul, ← add_div]\n  convert zero_smul (exprℝ) _\n  convert zero_div _\n  ring\n#align sphere.second_inter_second_inter sphere.second_inter_second_inter\n\n",
 "second_inter_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- `second_inter` is unchanged by negating the vector. -/\n@[simp]\ntheorem sphere.second_inter_neg (s : sphere P) (p : P) (v : V) : s.second_inter p (-v) = s.second_inter p v := by\n  rw [← neg_one_smul (exprℝ) v, s.second_inter_smul p v (by norm_num : (-1 : exprℝ) ≠ 0)]\n#align sphere.second_inter_neg sphere.second_inter_neg\n\n",
 "second_inter_mem":
 "/-- The point given by `second_inter` lies on the sphere. -/\n@[simp]\ntheorem sphere.second_inter_mem {s : sphere P} {p : P} (v : V) : s.second_inter p v ∈ s ↔ p ∈ s := by\n  simp_rw [mem_sphere, sphere.second_inter_dist]\n#align sphere.second_inter_mem sphere.second_inter_mem\n\n",
 "second_inter_eq_self_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- The point given by `second_inter` equals the original point if and only if the line is\northogonal to the radius vector. -/\ntheorem sphere.second_inter_eq_self_iff {s : sphere P} {p : P} {v : V} :\n    s.second_inter p v = p ↔ inner.real v («expr -ᵥ » p s.center) = 0 :=\n  by\n  refine' ⟨fun hp => _, fun hp => _⟩\n  · by_cases hv : v = 0\n    · simp [hv]\n    rwa [sphere.second_inter, eq_comm, eq_vadd_iff_vsub_eq, vsub_self, eq_comm, smul_eq_zero, or_iff_left hv,\n      div_eq_zero_iff, inner_self_eq_zero, or_iff_left hv, mul_eq_zero,\n      or_iff_right (by norm_num : (-2 : exprℝ) ≠ 0)] at hp\n  · rw [sphere.second_inter, hp, MulZeroClass.mul_zero, zero_div, zero_smul, zero_vadd]\n#align sphere.second_inter_eq_self_iff sphere.second_inter_eq_self_iff\n\n",
 "second_inter_eq_line_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- If the vector passed to `second_inter` is given by a subtraction involving the point in\n`second_inter`, the result of `second_inter` may be expressed using `line_map`. -/\ntheorem sphere.second_inter_eq_line_map (s : sphere P) (p p' : P) :\n    s.second_inter p («expr -ᵥ » p' p) =\n      AffineMap.lineMap p p'\n        (-2 * inner.real («expr -ᵥ » p' p) («expr -ᵥ » p s.center) / inner.real («expr -ᵥ » p' p) («expr -ᵥ » p' p)) :=\n  rfl\n#align sphere.second_inter_eq_line_map sphere.second_inter_eq_line_map\n\n",
 "second_inter_dist":
 "/-\nCopyright (c) 2022 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers\n-/\n/-- The distance between `second_inter` and the center equals the distance between the original\npoint and the center. -/\n@[simp]\ntheorem sphere.second_inter_dist (s : sphere P) (p : P) (v : V) :\n    dist (s.second_inter p v) s.center = dist p s.center :=\n  by\n  rw [sphere.second_inter]\n  by_cases hv : v = 0; · simp [hv]\n  rw [dist_smul_vadd_eq_dist _ _ hv]\n  exact or.inr rfl\n#align sphere.second_inter_dist sphere.second_inter_dist\n\n",
 "second_inter_collinear":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- If the vector passed to `second_inter` is given by a subtraction involving the point in\n`second_inter`, the three points are collinear. -/\ntheorem sphere.second_inter_collinear (s : sphere P) (p p' : P) :\n    Collinear (exprℝ) ({p, p', s.second_inter p («expr -ᵥ » p' p)} : Set P) :=\n  by\n  rw [Set.pair_comm, Set.insert_comm]\n  exact\n    (collinear_insert_iff_of_mem_affineSpan (s.second_inter_vsub_mem_affine_span _ _)).2 (collinear_pair (exprℝ) _ _)\n#align sphere.second_inter_collinear sphere.second_inter_collinear\n\n",
 "sbtw_second_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- If the vector passed to `second_inter` is given by a subtraction involving the point in\n`second_inter`, and the second point is inside the sphere, the second point is strictly between\nthe first point and the result of `second_inter`. -/\ntheorem sphere.sbtw_second_inter {s : sphere P} {p p' : P} (hp : p ∈ s) (hp' : dist p' s.center < s.radius) :\n    sbtw (exprℝ) p p' (s.second_inter p («expr -ᵥ » p' p)) :=\n  by\n  refine' ⟨sphere.wbtw_second_inter hp hp'.le, _, _⟩\n  · rintro rfl\n    rw [mem_sphere] at hp\n    simpa [hp] using hp'\n  · rintro h\n    rw [h, mem_sphere.1 ((sphere.second_inter_mem _).2 hp)] at hp'\n    exact lt_irrefl _ hp'\n#align sphere.sbtw_second_inter sphere.sbtw_second_inter\n\n",
 "eq_or_eq_second_inter_of_mem_mk'_span_singleton_iff_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A point on a line through a point on a sphere equals that point or `second_inter`. -/\ntheorem sphere.eq_or_eq_second_inter_of_mem_mk'_span_singleton_iff_mem {s : sphere P} {p : P} (hp : p ∈ s) {v : V}\n    {p' : P} (hp' : p' ∈ AffineSubspace.mk' p («expr ∙ » (exprℝ) v)) : p' = p ∨ p' = s.second_inter p v ↔ p' ∈ s :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · rcases h with (h | h)\n    · rwa [h]\n    · rwa [h, sphere.second_inter_mem]\n  · rw [AffineSubspace.mem_mk'_iff_vsub_mem, Submodule.mem_span_singleton] at hp'\n    rcases hp' with ⟨r, hr⟩\n    rw [eq_comm, ← eq_vadd_iff_vsub_eq] at hr\n    subst hr\n    by_cases hv : v = 0\n    · simp [hv]\n    rw [sphere.second_inter]\n    rw [mem_sphere] at h hp\n    rw [← hp, dist_smul_vadd_eq_dist _ _ hv] at h\n    rcases h with (h | h) <;> simp [h]\n#align sphere.eq_or_eq_second_inter_of_mem_mk'_span_singleton_iff_mem sphere.eq_or_eq_second_inter_of_mem_mk'_span_singleton_iff_mem\n\n"}