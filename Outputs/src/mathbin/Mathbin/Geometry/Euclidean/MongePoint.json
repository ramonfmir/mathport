{"vector_span_le_altitude_direction_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/-- The vector span of the opposite face lies in the direction\northogonal to an altitude. -/\ntheorem vector_span_le_altitude_direction_orthogonal {n : ℕ} (s : simplex (exprℝ) P (n + 1)) (i : fin (n + 2)) :\n    vector_span (exprℝ) («expr '' » s.points ↑(finset.univ.erase i)) ≤ «expr ᗮ» (s.altitude i).direction :=\n  by\n  rw [direction_altitude]\n  exact\n    le_trans (vector_span (exprℝ) («expr '' » s.points ↑(finset.univ.erase i))).le_orthogonal_orthogonal\n      (submodule.orthogonal_le inf_le_left)\n#align vector_span_le_altitude_direction_orthogonal vector_span_le_altitude_direction_orthogonal\n\n",
 "sum_monge_point_weights_with_circumcenter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- `monge_point_weights_with_circumcenter` sums to 1. -/\n@[simp]\ntheorem sum_monge_point_weights_with_circumcenter (n : ℕ) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (monge_point_weights_with_circumcenter n i) =\n      1 :=\n  by\n  simp_rw [sum_points_with_circumcenter, monge_point_weights_with_circumcenter, sum_const, card_fin, nsmul_eq_mul]\n  have hn1 : (n + 1 : exprℝ) ≠ 0 := by exact_mod_cast nat.succ_ne_zero _\n  field_simp [hn1]\n  ring\n#align sum_monge_point_weights_with_circumcenter sum_monge_point_weights_with_circumcenter\n\n",
 "sum_monge_point_vsub_face_centroid_weights_with_circumcenter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- `monge_point_vsub_face_centroid_weights_with_circumcenter` sums to 0. -/\n@[simp]\ntheorem sum_monge_point_vsub_face_centroid_weights_with_circumcenter {n : ℕ} {i₁ i₂ : fin (n + 3)} (h : i₁ ≠ i₂) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (monge_point_vsub_face_centroid_weights_with_circumcenter i₁ i₂ i) =\n      0 :=\n  by\n  rw [monge_point_vsub_face_centroid_weights_with_circumcenter_eq_sub h]\n  simp_rw [pi.sub_apply, sum_sub_distrib, sum_monge_point_weights_with_circumcenter]\n  rw [sum_centroid_weights_with_circumcenter, sub_self]\n  simp [← card_pos, card_compl, h]\n#align\n  sum_monge_point_vsub_face_centroid_weights_with_circumcenter sum_monge_point_vsub_face_centroid_weights_with_circumcenter\n\n",
 "orthocenter_replace_orthocenter_eq_point":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Suppose we are given a triangle `t₁`, and replace one of its\nvertices by its orthocenter, yielding triangle `t₂` (with vertices not\nnecessarily listed in the same order).  Then the orthocenter of `t₂`\nis the vertex of `t₁` that was replaced. -/\ntheorem orthocenter_replace_orthocenter_eq_point {t₁ t₂ : triangle (exprℝ) P} {i₁ i₂ i₃ j₁ j₂ j₃ : fin 3}\n    (hi₁₂ : i₁ ≠ i₂) (hi₁₃ : i₁ ≠ i₃) (hi₂₃ : i₂ ≠ i₃) (hj₁₂ : j₁ ≠ j₂) (hj₁₃ : j₁ ≠ j₃) (hj₂₃ : j₂ ≠ j₃)\n    (h₁ : t₂.points j₁ = t₁.orthocenter) (h₂ : t₂.points j₂ = t₁.points i₂) (h₃ : t₂.points j₃ = t₁.points i₃) :\n    t₂.orthocenter = t₁.points i₁ :=\n  by\n  refine' (triangle.eq_orthocenter_of_forall_mem_altitude hj₂₃ _ _).symm\n  · rw [altitude_replace_orthocenter_eq_affine_span hi₁₂ hi₁₃ hi₂₃ hj₁₂ hj₁₃ hj₂₃ h₁ h₂ h₃]\n    exact mem_affine_span (exprℝ) (Set.mem_insert _ _)\n  · rw [altitude_replace_orthocenter_eq_affine_span hi₁₃ hi₁₂ hi₂₃.symm hj₁₃ hj₁₂ hj₂₃.symm h₁ h₃ h₂]\n    exact mem_affine_span (exprℝ) (Set.mem_insert _ _)\n#align orthocenter_replace_orthocenter_eq_point orthocenter_replace_orthocenter_eq_point\n\n",
 "orthocenter_mem_altitude":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The orthocenter lies in the altitudes. -/\ntheorem orthocenter_mem_altitude (t : triangle (exprℝ) P) {i₁ : fin 3} : t.orthocenter ∈ t.altitude i₁ :=\n  by\n  obtain ⟨i₂, i₃, h₁₂, h₂₃, h₁₃⟩ : ∃ i₂ i₃, i₁ ≠ i₂ ∧ i₂ ≠ i₃ ∧ i₁ ≠ i₃ := by decide!\n  rw [orthocenter_eq_monge_point, t.altitude_eq_monge_plane h₁₂ h₁₃ h₂₃]\n  exact t.monge_point_mem_monge_plane\n#align orthocenter_mem_altitude orthocenter_mem_altitude\n\n",
 "orthocenter_mem_affine_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The orthocenter lies in the affine span. -/\ntheorem orthocenter_mem_affine_span (t : triangle (exprℝ) P) :\n    t.orthocenter ∈ affine_span (exprℝ) (Set.range t.points) :=\n  t.monge_point_mem_affine_span\n#align orthocenter_mem_affine_span orthocenter_mem_affine_span\n\n",
 "orthocenter_eq_smul_vsub_vadd_circumcenter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The position of the orthocenter in relation to the circumcenter\nand centroid. -/\ntheorem orthocenter_eq_smul_vsub_vadd_circumcenter (t : triangle (exprℝ) P) :\n    t.orthocenter =\n      «expr +ᵥ »\n        («expr • » (3 : exprℝ) («expr -ᵥ » ((univ : Finset (fin 3)).centroid (exprℝ) t.points) t.circumcenter : V))\n        t.circumcenter :=\n  by\n  rw [orthocenter_eq_monge_point, monge_point_eq_smul_vsub_vadd_circumcenter]\n  norm_num\n#align orthocenter_eq_smul_vsub_vadd_circumcenter orthocenter_eq_smul_vsub_vadd_circumcenter\n\n",
 "orthocenter_eq_of_range_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Two triangles with the same points have the same orthocenter. -/\ntheorem orthocenter_eq_of_range_eq {t₁ t₂ : triangle (exprℝ) P} (h : Set.range t₁.points = Set.range t₂.points) :\n    t₁.orthocenter = t₂.orthocenter :=\n  monge_point_eq_of_range_eq h\n#align orthocenter_eq_of_range_eq orthocenter_eq_of_range_eq\n\n",
 "orthocenter_eq_monge_point":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The orthocenter equals the Monge point. -/\ntheorem orthocenter_eq_monge_point (t : triangle (exprℝ) P) : t.orthocenter = t.monge_point :=\n  rfl\n#align orthocenter_eq_monge_point orthocenter_eq_monge_point\n\n",
 "monge_point_vsub_face_centroid_weights_with_circumcenter_eq_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- `monge_point_vsub_face_centroid_weights_with_circumcenter` is the\nresult of subtracting `centroid_weights_with_circumcenter` from\n`monge_point_weights_with_circumcenter`. -/\ntheorem monge_point_vsub_face_centroid_weights_with_circumcenter_eq_sub {n : ℕ} {i₁ i₂ : fin (n + 3)} (h : i₁ ≠ i₂) :\n    monge_point_vsub_face_centroid_weights_with_circumcenter i₁ i₂ =\n      monge_point_weights_with_circumcenter n - centroid_weights_with_circumcenter («expr ᶜ» {i₁, i₂}) :=\n  by\n  ext i\n  cases i\n  · rw [pi.sub_apply, monge_point_weights_with_circumcenter, centroid_weights_with_circumcenter,\n      monge_point_vsub_face_centroid_weights_with_circumcenter]\n    have hu : card («expr ᶜ» {i₁, i₂} : Finset (fin (n + 3))) = n + 1 := by simp [card_compl, fintype.card_fin, h]\n    rw [hu]\n    by_cases hi : i = i₁ ∨ i = i₂ <;> simp [compl_eq_univ_sdiff, hi]\n  ·\n    simp [monge_point_weights_with_circumcenter, centroid_weights_with_circumcenter,\n      monge_point_vsub_face_centroid_weights_with_circumcenter]\n#align\n  monge_point_vsub_face_centroid_weights_with_circumcenter_eq_sub monge_point_vsub_face_centroid_weights_with_circumcenter_eq_sub\n\n",
 "monge_point_vsub_face_centroid_eq_weighted_vsub_of_points_with_circumcenter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The Monge point of an (n+2)-simplex, minus the centroid of an\nn-dimensional face, in terms of `points_with_circumcenter`. -/\ntheorem monge_point_vsub_face_centroid_eq_weighted_vsub_of_points_with_circumcenter {n : ℕ}\n    (s : simplex (exprℝ) P (n + 2)) {i₁ i₂ : fin (n + 3)} (h : i₁ ≠ i₂) :\n    «expr -ᵥ » s.monge_point ((«expr ᶜ» {i₁, i₂} : Finset (fin (n + 3))).centroid (exprℝ) s.points) =\n      (univ : Finset (points_with_circumcenter_index (n + 2))).weighted_vsub s.points_with_circumcenter\n        (monge_point_vsub_face_centroid_weights_with_circumcenter i₁ i₂) :=\n  by\n  simp_rw [monge_point_eq_affine_combination_of_points_with_circumcenter,\n    centroid_eq_affine_combination_of_points_with_circumcenter, affine_combination_vsub,\n    monge_point_vsub_face_centroid_weights_with_circumcenter_eq_sub h]\n#align\n  monge_point_vsub_face_centroid_eq_weighted_vsub_of_points_with_circumcenter monge_point_vsub_face_centroid_eq_weighted_vsub_of_points_with_circumcenter\n\n",
 "monge_point_mem_monge_plane":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The Monge point lies in the Monge planes. -/\ntheorem monge_point_mem_monge_plane {n : ℕ} (s : simplex (exprℝ) P (n + 2)) {i₁ i₂ : fin (n + 3)} :\n    s.monge_point ∈ s.monge_plane i₁ i₂ :=\n  by\n  rw [monge_plane_def, mem_inf_iff, ← vsub_right_mem_direction_iff_mem (self_mem_mk' _ _), direction_mk',\n    submodule.mem_orthogonal']\n  refine' ⟨_, s.monge_point_mem_affine_span⟩\n  intro v hv\n  rcases submodule.mem_span_singleton.mp hv with ⟨r, rfl⟩\n  rw [inner_smul_right, s.inner_monge_point_vsub_face_centroid_vsub, mul_zero]\n#align monge_point_mem_monge_plane monge_point_mem_monge_plane\n\n",
 "monge_point_mem_affine_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The Monge point lies in the affine span. -/\ntheorem monge_point_mem_affine_span {n : ℕ} (s : simplex (exprℝ) P n) :\n    s.monge_point ∈ affine_span (exprℝ) (Set.range s.points) :=\n  smul_vsub_vadd_mem _ _ (centroid_mem_affine_span_of_card_eq_add_one (exprℝ) _ (card_fin (n + 1)))\n    s.circumcenter_mem_affine_span s.circumcenter_mem_affine_span\n#align monge_point_mem_affine_span monge_point_mem_affine_span\n\n",
 "monge_point_eq_smul_vsub_vadd_circumcenter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2020 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers\n-/\n/-- The position of the Monge point in relation to the circumcenter\nand centroid. -/\ntheorem monge_point_eq_smul_vsub_vadd_circumcenter {n : ℕ} (s : simplex (exprℝ) P n) :\n    s.monge_point =\n      «expr +ᵥ »\n        («expr • » (((n + 1 : ℕ) : exprℝ) / ((n - 1 : ℕ) : exprℝ))\n          («expr -ᵥ » ((univ : Finset (fin (n + 1))).centroid (exprℝ) s.points) s.circumcenter))\n        s.circumcenter :=\n  rfl\n#align monge_point_eq_smul_vsub_vadd_circumcenter monge_point_eq_smul_vsub_vadd_circumcenter\n\n",
 "monge_point_eq_of_range_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Two simplices with the same points have the same Monge point. -/\ntheorem monge_point_eq_of_range_eq {n : ℕ} {s₁ s₂ : simplex (exprℝ) P n}\n    (h : Set.range s₁.points = Set.range s₂.points) : s₁.monge_point = s₂.monge_point := by\n  simp_rw [monge_point_eq_smul_vsub_vadd_circumcenter, centroid_eq_of_range_eq h, circumcenter_eq_of_range_eq h]\n#align monge_point_eq_of_range_eq monge_point_eq_of_range_eq\n\n",
 "monge_point_eq_affine_combination_of_points_with_circumcenter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The Monge point of an (n+2)-simplex, in terms of\n`points_with_circumcenter`. -/\ntheorem monge_point_eq_affine_combination_of_points_with_circumcenter {n : ℕ} (s : simplex (exprℝ) P (n + 2)) :\n    s.monge_point =\n      (univ : Finset (points_with_circumcenter_index (n + 2))).affine_combination s.points_with_circumcenter\n        (monge_point_weights_with_circumcenter n) :=\n  by\n  rw [monge_point_eq_smul_vsub_vadd_circumcenter, centroid_eq_affine_combination_of_points_with_circumcenter,\n    circumcenter_eq_affine_combination_of_points_with_circumcenter, affine_combination_vsub, ← linear_map.map_smul,\n    weighted_vsub_vadd_affine_combination]\n  congr with i\n  rw [pi.add_apply, pi.smul_apply, smul_eq_mul, pi.sub_apply]\n  have hn1 : (n + 1 : exprℝ) ≠ 0 := by exact_mod_cast nat.succ_ne_zero _\n  cases i <;>\n      simp_rw [centroid_weights_with_circumcenter, circumcenter_weights_with_circumcenter,\n        monge_point_weights_with_circumcenter] <;>\n    rw [add_tsub_assoc_of_le (by decide : 1 ≤ 2), (by decide : 2 - 1 = 1)]\n  · rw [if_pos (mem_univ _), sub_zero, add_zero, card_fin]\n    have hn3 : (n + 2 + 1 : exprℝ) ≠ 0 := by exact_mod_cast nat.succ_ne_zero _\n    field_simp [hn1, hn3, mul_comm]\n  · field_simp [hn1]\n    ring\n#align\n  monge_point_eq_affine_combination_of_points_with_circumcenter monge_point_eq_affine_combination_of_points_with_circumcenter\n\n",
 "monge_plane_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The definition of a Monge plane. -/\ntheorem monge_plane_def {n : ℕ} (s : simplex (exprℝ) P (n + 2)) (i₁ i₂ : fin (n + 3)) :\n    s.monge_plane i₁ i₂ =\n      «expr ⊓ »\n        (mk' ((«expr ᶜ» {i₁, i₂} : Finset (fin (n + 3))).centroid (exprℝ) s.points)\n          («expr ᗮ» («expr ∙ » (exprℝ) («expr -ᵥ » (s.points i₁) (s.points i₂)))))\n        (affine_span (exprℝ) (Set.range s.points)) :=\n  rfl\n#align monge_plane_def monge_plane_def\n\n",
 "monge_plane_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The Monge plane associated with vertices `i₁` and `i₂` equals that\nassociated with `i₂` and `i₁`. -/\ntheorem monge_plane_comm {n : ℕ} (s : simplex (exprℝ) P (n + 2)) (i₁ i₂ : fin (n + 3)) :\n    s.monge_plane i₁ i₂ = s.monge_plane i₂ i₁ :=\n  by\n  simp_rw [monge_plane_def]\n  congr 3\n  · congr 1\n    exact pair_comm _ _\n  · ext\n    simp_rw [submodule.mem_span_singleton]\n    constructor\n    all_goals rintro ⟨r, rfl⟩; use -r; rw [neg_smul, ← smul_neg, neg_vsub_eq_vsub_rev]\n#align monge_plane_comm monge_plane_comm\n\n",
 "mem_altitude":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A vertex lies in the corresponding altitude. -/\ntheorem mem_altitude {n : ℕ} (s : simplex (exprℝ) P (n + 1)) (i : fin (n + 2)) : s.points i ∈ s.altitude i :=\n  (mem_inf_iff _ _ _).2 ⟨self_mem_mk' _ _, mem_affine_span (exprℝ) (Set.mem_range_self _)⟩\n#align mem_altitude mem_altitude\n\n",
 "inner_monge_point_vsub_face_centroid_vsub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- The Monge point of an (n+2)-simplex, minus the centroid of an\nn-dimensional face, is orthogonal to the difference of the two\nvertices not in that face. -/\ntheorem inner_monge_point_vsub_face_centroid_vsub {n : ℕ} (s : simplex (exprℝ) P (n + 2)) {i₁ i₂ : fin (n + 3)} :\n    inner.real («expr -ᵥ » s.monge_point ((«expr ᶜ» {i₁, i₂} : Finset (fin (n + 3))).centroid (exprℝ) s.points))\n        («expr -ᵥ » (s.points i₁) (s.points i₂)) =\n      0 :=\n  by\n  by_cases h : i₁ = i₂\n  · simp [h]\n  simp_rw [monge_point_vsub_face_centroid_eq_weighted_vsub_of_points_with_circumcenter s h,\n    point_eq_affine_combination_of_points_with_circumcenter, affine_combination_vsub]\n  have hs :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        ((point_weights_with_circumcenter i₁ - point_weights_with_circumcenter i₂) i) =\n      0 :=\n    by simp\n  rw [inner_weighted_vsub _ (sum_monge_point_vsub_face_centroid_weights_with_circumcenter h) _ hs,\n    sum_points_with_circumcenter, points_with_circumcenter_eq_circumcenter]\n  simp only [monge_point_vsub_face_centroid_weights_with_circumcenter, points_with_circumcenter_point]\n  let fs : Finset (fin (n + 3)) := {i₁, i₂}\n  have hfs : ∀ i : fin (n + 3), i ∉ fs → i ≠ i₁ ∧ i ≠ i₂ :=\n    by\n    intro i hi\n    constructor <;>\n      · intro hj\n        simpa [← hj] using hi\n  rw [← sum_subset fs.subset_univ _]\n  · simp_rw [sum_points_with_circumcenter, points_with_circumcenter_eq_circumcenter, points_with_circumcenter_point,\n      pi.sub_apply, point_weights_with_circumcenter]\n    rw [← sum_subset fs.subset_univ _]\n    · simp_rw [sum_insert (not_mem_singleton.2 h), sum_singleton]\n      repeat' rw [← sum_subset fs.subset_univ _]\n      · simp_rw [sum_insert (not_mem_singleton.2 h), sum_singleton]\n        simp [h, ne.symm h, dist_comm (s.points i₁)]\n      all_goals intro i hu hi; simp [hfs i hi]\n    · intro i hu hi\n      simp [hfs i hi, point_weights_with_circumcenter]\n  · intro i hu hi\n    simp [hfs i hi]\n#align inner_monge_point_vsub_face_centroid_vsub inner_monge_point_vsub_face_centroid_vsub\n\n",
 "finrank_direction_altitude":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- An altitude is one-dimensional (i.e., a line). -/\n@[simp]\ntheorem finrank_direction_altitude {n : ℕ} (s : simplex (exprℝ) P (n + 1)) (i : fin (n + 2)) :\n    finrank (exprℝ) (s.altitude i).direction = 1 :=\n  by\n  rw [direction_altitude]\n  have h :=\n    submodule.finrank_add_inf_finrank_orthogonal\n      (vector_span_mono (exprℝ) (Set.image_subset_range s.points ↑(univ.erase i)))\n  have hc : card (univ.erase i) = n + 1 := by\n    rw [card_erase_of_mem (mem_univ _)]\n    simp\n  refine' add_left_cancel (trans h _)\n  rw [s.independent.finrank_vector_span (fintype.card_fin _), ← Finset.coe_image,\n    s.independent.finrank_vector_span_image_finset hc]\n#align finrank_direction_altitude finrank_direction_altitude\n\n",
 "exists_of_range_subset_orthocentric_system":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- This is an auxiliary lemma giving information about the relation\nof two triangles in an orthocentric system; it abstracts some\nreasoning, with no geometric content, that is common to some other\nlemmas.  Suppose the orthocentric system is generated by triangle `t`,\nand we are given three points `p` in the orthocentric system.  Then\neither we can find indices `i₁`, `i₂` and `i₃` for `p` such that `p\ni₁` is the orthocenter of `t` and `p i₂` and `p i₃` are points `j₂`\nand `j₃` of `t`, or `p` has the same points as `t`. -/\ntheorem exists_of_range_subset_orthocentric_system {t : triangle (exprℝ) P} (ho : t.orthocenter ∉ Set.range t.points)\n    {p : fin 3 → P} (hps : Set.range p ⊆ insert t.orthocenter (Set.range t.points)) (hpi : function.injective p) :\n    (∃ i₁ i₂ i₃ j₂ j₃ : fin 3,\n        i₁ ≠ i₂ ∧\n          i₁ ≠ i₃ ∧\n            i₂ ≠ i₃ ∧\n              (∀ i : fin 3, i = i₁ ∨ i = i₂ ∨ i = i₃) ∧\n                p i₁ = t.orthocenter ∧ j₂ ≠ j₃ ∧ t.points j₂ = p i₂ ∧ t.points j₃ = p i₃) ∨\n      Set.range p = Set.range t.points :=\n  by\n  by_cases h : t.orthocenter ∈ Set.range p\n  · left\n    rcases h with ⟨i₁, h₁⟩\n    obtain ⟨i₂, i₃, h₁₂, h₁₃, h₂₃, h₁₂₃⟩ :\n      ∃ i₂ i₃ : fin 3, i₁ ≠ i₂ ∧ i₁ ≠ i₃ ∧ i₂ ≠ i₃ ∧ ∀ i : fin 3, i = i₁ ∨ i = i₂ ∨ i = i₃ :=\n      by\n      clear h₁\n      decide!\n    have h : ∀ i, i₁ ≠ i → ∃ j : fin 3, t.points j = p i :=\n      by\n      intro i hi\n      replace hps :=\n        Set.mem_of_mem_insert_of_ne (Set.mem_of_mem_of_subset (Set.mem_range_self i) hps) (h₁ ▸ hpi.ne hi.symm)\n      exact hps\n    rcases h i₂ h₁₂ with ⟨j₂, h₂⟩\n    rcases h i₃ h₁₃ with ⟨j₃, h₃⟩\n    have hj₂₃ : j₂ ≠ j₃ := by\n      intro he\n      rw [he, h₃] at h₂\n      exact h₂₃.symm (hpi h₂)\n    exact ⟨i₁, i₂, i₃, j₂, j₃, h₁₂, h₁₃, h₂₃, h₁₂₃, h₁, hj₂₃, h₂, h₃⟩\n  · right\n    have hs := Set.subset_diff_singleton hps h\n    rw [Set.insert_diff_self_of_not_mem ho] at hs\n    refine' set.eq_of_subset_of_card_le hs _\n    rw [set.card_range_of_injective hpi, set.card_range_of_injective t.independent.injective]\n#align exists_of_range_subset_orthocentric_system exists_of_range_subset_orthocentric_system\n\n",
 "exists_dist_eq_circumradius_of_subset_insert_orthocenter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- For any three points in an orthocentric system generated by\ntriangle `t`, there is a point in the subspace spanned by the triangle\nfrom which the distance of all those three points equals the circumradius. -/\ntheorem exists_dist_eq_circumradius_of_subset_insert_orthocenter {t : triangle (exprℝ) P}\n    (ho : t.orthocenter ∉ Set.range t.points) {p : fin 3 → P}\n    (hps : Set.range p ⊆ insert t.orthocenter (Set.range t.points)) (hpi : function.injective p) :\n    ∃ c ∈ affine_span (exprℝ) (Set.range t.points), ∀ p₁ ∈ Set.range p, dist p₁ c = t.circumradius :=\n  by\n  rcases exists_of_range_subset_orthocentric_system ho hps hpi with\n    (⟨i₁, i₂, i₃, j₂, j₃, h₁₂, h₁₃, h₂₃, h₁₂₃, h₁, hj₂₃, h₂, h₃⟩ | hs)\n  · use reflection (affine_span (exprℝ) («expr '' » t.points {j₂, j₃})) t.circumcenter,\n      reflection_mem_of_le_of_mem (affine_span_mono (exprℝ) (Set.image_subset_range _ _)) t.circumcenter_mem_affine_span\n    intro p₁ hp₁\n    rcases hp₁ with ⟨i, rfl⟩\n    replace h₁₂₃ := h₁₂₃ i\n    repeat' cases h₁₂₃\n    · rw [h₁]\n      exact triangle.dist_orthocenter_reflection_circumcenter t hj₂₃\n    · rw [← h₂, dist_reflection_eq_of_mem _ (mem_affine_span (exprℝ) (Set.mem_image_of_mem _ (Set.mem_insert _ _)))]\n      exact t.dist_circumcenter_eq_circumradius _\n    · rw [← h₃,\n        dist_reflection_eq_of_mem _\n          (mem_affine_span (exprℝ) (Set.mem_image_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))))]\n      exact t.dist_circumcenter_eq_circumradius _\n  · use t.circumcenter, t.circumcenter_mem_affine_span\n    intro p₁ hp₁\n    rw [hs] at hp₁\n    rcases hp₁ with ⟨i, rfl⟩\n    exact t.dist_circumcenter_eq_circumradius _\n#align exists_dist_eq_circumradius_of_subset_insert_orthocenter exists_dist_eq_circumradius_of_subset_insert_orthocenter\n\n",
 "exists_circumradius_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- All triangles in an orthocentric system have the same circumradius. -/\ntheorem orthocentric_system.exists_circumradius_eq {s : set P} (ho : orthocentric_system s) :\n    ∃ r : exprℝ, ∀ t : triangle (exprℝ) P, Set.range t.points ⊆ s → t.circumradius = r :=\n  by\n  rcases ho with ⟨t, hto, hts⟩\n  use t.circumradius\n  intro t₂ ht₂\n  have ht₂s := ht₂\n  rw [hts] at ht₂\n  rcases exists_dist_eq_circumradius_of_subset_insert_orthocenter hto ht₂ t₂.independent.injective with ⟨c, hc, h⟩\n  rw [Set.forall_range_iff] at h\n  have hs : Set.range t.points ⊆ s := by\n    rw [hts]\n    exact Set.subset_insert _ _\n  rw [affine_span_of_orthocentric_system ⟨t, hto, hts⟩ hs t.independent.injective, ←\n    affine_span_of_orthocentric_system ⟨t, hto, hts⟩ ht₂s t₂.independent.injective] at hc\n  exact (t₂.eq_circumradius_of_dist_eq hc h).symm\n#align orthocentric_system.exists_circumradius_eq orthocentric_system.exists_circumradius_eq\n\n",
 "eq_orthocenter_of_forall_mem_altitude":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The orthocenter is the only point lying in any two of the\naltitudes. -/\ntheorem eq_orthocenter_of_forall_mem_altitude {t : triangle (exprℝ) P} {i₁ i₂ : fin 3} {p : P} (h₁₂ : i₁ ≠ i₂)\n    (h₁ : p ∈ t.altitude i₁) (h₂ : p ∈ t.altitude i₂) : p = t.orthocenter :=\n  by\n  obtain ⟨i₃, h₂₃, h₁₃⟩ : ∃ i₃, i₂ ≠ i₃ ∧ i₁ ≠ i₃ := by\n    clear h₁ h₂\n    decide!\n  rw [t.altitude_eq_monge_plane h₁₃ h₁₂ h₂₃.symm] at h₁\n  rw [t.altitude_eq_monge_plane h₂₃ h₁₂.symm h₁₃.symm] at h₂\n  rw [orthocenter_eq_monge_point]\n  have ha : ∀ i, i₃ ≠ i → p ∈ t.monge_plane i₃ i := by\n    intro i hi\n    have hi₁₂ : i₁ = i ∨ i₂ = i := by\n      clear h₁ h₂\n      decide!\n    cases hi₁₂\n    · exact hi₁₂ ▸ h₂\n    · exact hi₁₂ ▸ h₁\n  exact eq_monge_point_of_forall_mem_monge_plane ha\n#align eq_orthocenter_of_forall_mem_altitude eq_orthocenter_of_forall_mem_altitude\n\n",
 "eq_monge_point_of_forall_mem_monge_plane":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The Monge point is the only point in all the Monge planes from any\none vertex. -/\ntheorem eq_monge_point_of_forall_mem_monge_plane {n : ℕ} {s : simplex (exprℝ) P (n + 2)} {i₁ : fin (n + 3)} {p : P}\n    (h : ∀ i₂, i₁ ≠ i₂ → p ∈ s.monge_plane i₁ i₂) : p = s.monge_point :=\n  by\n  rw [← @vsub_eq_zero_iff_eq V]\n  have h' :\n    ∀ i₂,\n      i₁ ≠ i₂ →\n        «expr -ᵥ » p s.monge_point ∈\n          «expr ⊓ » («expr ᗮ» («expr ∙ » (exprℝ) («expr -ᵥ » (s.points i₁) (s.points i₂))))\n            (vector_span (exprℝ) (Set.range s.points)) :=\n    by\n    intro i₂ hne\n    rw [← s.direction_monge_plane, vsub_right_mem_direction_iff_mem s.monge_point_mem_monge_plane]\n    exact h i₂ hne\n  have hi :\n    «expr -ᵥ » p s.monge_point ∈\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr ᗮ» («expr ∙ » (exprℝ) («expr -ᵥ » (s.points i₁) (s.points i₂)))) :=\n    by\n    rw [submodule.mem_infi]\n    exact fun i => (submodule.mem_inf.1 (h' i i.property)).1\n  rw [submodule.infi_orthogonal, ← submodule.span_Union] at hi\n  have hu :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        ({«expr -ᵥ » (s.points i₁) (s.points i)} : set V) =\n      «expr '' » ((«expr -ᵥ » · ·) (s.points i₁)) («expr '' » s.points (Set.univ \\ {i₁})) :=\n    by\n    rw [Set.image_image]\n    ext x\n    simp_rw [Set.mem_unionᵢ, Set.mem_image, Set.mem_singleton_iff, Set.mem_diff_singleton]\n    constructor\n    · rintro ⟨i, rfl⟩\n      use i, ⟨Set.mem_univ _, i.property.symm⟩\n    · rintro ⟨i, ⟨hiu, hi⟩, rfl⟩\n      use ⟨i, hi.symm⟩, rfl\n  rw [hu, ← vector_span_image_eq_span_vsub_set_left_ne (exprℝ) _ (Set.mem_univ _), Set.image_univ] at hi\n  have hv : «expr -ᵥ » p s.monge_point ∈ vector_span (exprℝ) (Set.range s.points) :=\n    by\n    let s₁ : Finset (fin (n + 3)) := univ.erase i₁\n    obtain ⟨i₂, h₂⟩ := card_pos.1 (show 0 < card s₁ by simp [card_erase_of_mem])\n    have h₁₂ : i₁ ≠ i₂ := (ne_of_mem_erase h₂).symm\n    exact (submodule.mem_inf.1 (h' i₂ h₁₂)).2\n  exact submodule.disjoint_def.1 (vector_span (exprℝ) (Set.range s.points)).orthogonal_disjoint _ hv hi\n#align eq_monge_point_of_forall_mem_monge_plane eq_monge_point_of_forall_mem_monge_plane\n\n",
 "eq_insert_orthocenter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Given any triangle in an orthocentric system, the fourth point is\nits orthocenter. -/\ntheorem orthocentric_system.eq_insert_orthocenter {s : set P} (ho : orthocentric_system s) {t : triangle (exprℝ) P}\n    (ht : Set.range t.points ⊆ s) : s = insert t.orthocenter (Set.range t.points) :=\n  by\n  rcases ho with ⟨t₀, ht₀o, ht₀s⟩\n  rw [ht₀s] at ht\n  rcases exists_of_range_subset_orthocentric_system ht₀o ht t.independent.injective with\n    (⟨i₁, i₂, i₃, j₂, j₃, h₁₂, h₁₃, h₂₃, h₁₂₃, h₁, hj₂₃, h₂, h₃⟩ | hs)\n  · obtain ⟨j₁, hj₁₂, hj₁₃, hj₁₂₃⟩ : ∃ j₁ : fin 3, j₁ ≠ j₂ ∧ j₁ ≠ j₃ ∧ ∀ j : fin 3, j = j₁ ∨ j = j₂ ∨ j = j₃ :=\n      by\n      clear h₂ h₃\n      decide!\n    suffices h : t₀.points j₁ = t.orthocenter\n    · have hui : (Set.univ : set (fin 3)) = {i₁, i₂, i₃} := by\n        ext x\n        simpa using h₁₂₃ x\n      have huj : (Set.univ : set (fin 3)) = {j₁, j₂, j₃} := by\n        ext x\n        simpa using hj₁₂₃ x\n      rw [← h, ht₀s, ← Set.image_univ, huj, ← Set.image_univ, hui]\n      simp_rw [Set.image_insert_eq, Set.image_singleton, h₁, ← h₂, ← h₃]\n      rw [Set.insert_comm]\n    exact (triangle.orthocenter_replace_orthocenter_eq_point hj₁₂ hj₁₃ hj₂₃ h₁₂ h₁₃ h₂₃ h₁ h₂.symm h₃.symm).symm\n  · rw [hs]\n    convert ht₀s using 2\n    exact triangle.orthocenter_eq_of_range_eq hs\n#align orthocentric_system.eq_insert_orthocenter orthocentric_system.eq_insert_orthocenter\n\n",
 "dist_orthocenter_reflection_circumcenter_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The distance from the orthocenter to the reflection of the\ncircumcenter in a side equals the circumradius, variant using a\n`finset`. -/\ntheorem dist_orthocenter_reflection_circumcenter_finset (t : triangle (exprℝ) P) {i₁ i₂ : fin 3} (h : i₁ ≠ i₂) :\n    dist t.orthocenter\n        (reflection (affine_span (exprℝ) («expr '' » t.points ↑({i₁, i₂} : Finset (fin 3)))) t.circumcenter) =\n      t.circumradius :=\n  by\n  convert dist_orthocenter_reflection_circumcenter _ h\n  simp\n#align dist_orthocenter_reflection_circumcenter_finset dist_orthocenter_reflection_circumcenter_finset\n\n",
 "dist_orthocenter_reflection_circumcenter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The distance from the orthocenter to the reflection of the\ncircumcenter in a side equals the circumradius. -/\ntheorem dist_orthocenter_reflection_circumcenter (t : triangle (exprℝ) P) {i₁ i₂ : fin 3} (h : i₁ ≠ i₂) :\n    dist t.orthocenter (reflection (affine_span (exprℝ) («expr '' » t.points {i₁, i₂})) t.circumcenter) =\n      t.circumradius :=\n  by\n  rw [← mul_self_inj_of_nonneg dist_nonneg t.circumradius_nonneg,\n    t.reflection_circumcenter_eq_affine_combination_of_points_with_circumcenter h, t.orthocenter_eq_monge_point,\n    monge_point_eq_affine_combination_of_points_with_circumcenter,\n    dist_affine_combination t.points_with_circumcenter (sum_monge_point_weights_with_circumcenter _)\n      (sum_reflection_circumcenter_weights_with_circumcenter h)]\n  simp_rw [sum_points_with_circumcenter, pi.sub_apply, monge_point_weights_with_circumcenter,\n    reflection_circumcenter_weights_with_circumcenter]\n  have hu : ({i₁, i₂} : Finset (fin 3)) ⊆ univ := subset_univ _\n  obtain ⟨i₃, hi₃, hi₃₁, hi₃₂⟩ : ∃ i₃, univ \\ ({i₁, i₂} : Finset (fin 3)) = {i₃} ∧ i₃ ≠ i₁ ∧ i₃ ≠ i₂ := by decide!\n  simp_rw [← sum_sdiff hu, hi₃]\n  simp [hi₃₁, hi₃₂]\n  norm_num\n#align dist_orthocenter_reflection_circumcenter dist_orthocenter_reflection_circumcenter\n\n",
 "direction_monge_plane":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The direction of a Monge plane. -/\ntheorem direction_monge_plane {n : ℕ} (s : simplex (exprℝ) P (n + 2)) {i₁ i₂ : fin (n + 3)} :\n    (s.monge_plane i₁ i₂).direction =\n      «expr ⊓ » («expr ᗮ» («expr ∙ » (exprℝ) («expr -ᵥ » (s.points i₁) (s.points i₂))))\n        (vector_span (exprℝ) (Set.range s.points)) :=\n  by rw [monge_plane_def, direction_inf_of_mem_inf s.monge_point_mem_monge_plane, direction_mk', direction_affine_span]\n#align direction_monge_plane direction_monge_plane\n\n",
 "direction_altitude":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The direction of an altitude. -/\ntheorem direction_altitude {n : ℕ} (s : simplex (exprℝ) P (n + 1)) (i : fin (n + 2)) :\n    (s.altitude i).direction =\n      «expr ⊓ » («expr ᗮ» (vector_span (exprℝ) («expr '' » s.points ↑(finset.univ.erase i))))\n        (vector_span (exprℝ) (Set.range s.points)) :=\n  by\n  rw [altitude_def, direction_inf_of_mem (self_mem_mk' (s.points i) _) (mem_affine_span (exprℝ) (Set.mem_range_self _)),\n    direction_mk', direction_affine_span, direction_affine_span]\n#align direction_altitude direction_altitude\n\n",
 "altitude_replace_orthocenter_eq_affine_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Suppose we are given a triangle `t₁`, and replace one of its\nvertices by its orthocenter, yielding triangle `t₂` (with vertices not\nnecessarily listed in the same order).  Then an altitude of `t₂` from\na vertex that was not replaced is the corresponding side of `t₁`. -/\ntheorem altitude_replace_orthocenter_eq_affine_span {t₁ t₂ : triangle (exprℝ) P} {i₁ i₂ i₃ j₁ j₂ j₃ : fin 3}\n    (hi₁₂ : i₁ ≠ i₂) (hi₁₃ : i₁ ≠ i₃) (hi₂₃ : i₂ ≠ i₃) (hj₁₂ : j₁ ≠ j₂) (hj₁₃ : j₁ ≠ j₃) (hj₂₃ : j₂ ≠ j₃)\n    (h₁ : t₂.points j₁ = t₁.orthocenter) (h₂ : t₂.points j₂ = t₁.points i₂) (h₃ : t₂.points j₃ = t₁.points i₃) :\n    t₂.altitude j₂ = «exprline[ , , ]» (exprℝ) (t₁.points i₁) (t₁.points i₂) :=\n  by\n  symm\n  rw [← h₂, t₂.affine_span_pair_eq_altitude_iff]\n  rw [h₂]\n  use t₁.independent.injective.ne hi₁₂\n  have he : affine_span (exprℝ) (Set.range t₂.points) = affine_span (exprℝ) (Set.range t₁.points) :=\n    by\n    refine'\n      ext_of_direction_eq _\n        ⟨t₁.points i₃, mem_affine_span (exprℝ) ⟨j₃, h₃⟩, mem_affine_span (exprℝ) (Set.mem_range_self _)⟩\n    refine' eq_of_le_of_finrank_eq (direction_le (span_points_subset_coe_of_subset_coe _)) _\n    · have hu : (finset.univ : Finset (fin 3)) = {j₁, j₂, j₃} :=\n        by\n        clear h₁ h₂ h₃\n        decide!\n      rw [← Set.image_univ, ← finset.coe_univ, hu, Finset.coe_insert, Finset.coe_insert, Finset.coe_singleton,\n        Set.image_insert_eq, Set.image_insert_eq, Set.image_singleton, h₁, h₂, h₃, Set.insert_subset, Set.insert_subset,\n        Set.singleton_subset_iff]\n      exact\n        ⟨t₁.orthocenter_mem_affine_span, mem_affine_span (exprℝ) (Set.mem_range_self _),\n          mem_affine_span (exprℝ) (Set.mem_range_self _)⟩\n    ·\n      rw [direction_affine_span, direction_affine_span, t₁.independent.finrank_vector_span (fintype.card_fin _),\n        t₂.independent.finrank_vector_span (fintype.card_fin _)]\n  rw [he]\n  use mem_affine_span (exprℝ) (Set.mem_range_self _)\n  have hu : finset.univ.erase j₂ = {j₁, j₃} := by\n    clear h₁ h₂ h₃\n    decide!\n  rw [hu, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton, h₁, h₃]\n  have hle :\n    «expr ᗮ» (t₁.altitude i₃).direction ≤\n      «expr ᗮ» («exprline[ , , ]» (exprℝ) t₁.orthocenter (t₁.points i₃)).direction :=\n    submodule.orthogonal_le (direction_le (affine_span_orthocenter_point_le_altitude _ _))\n  refine' hle ((t₁.vector_span_le_altitude_direction_orthogonal i₃) _)\n  have hui : finset.univ.erase i₃ = {i₁, i₂} := by\n    clear hle h₂ h₃\n    decide!\n  rw [hui, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton]\n  refine' vsub_mem_vector_span (exprℝ) (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_singleton _))\n#align altitude_replace_orthocenter_eq_affine_span altitude_replace_orthocenter_eq_affine_span\n\n",
 "altitude_eq_monge_plane":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- In the case of a triangle, altitudes are the same thing as Monge\nplanes. -/\ntheorem altitude_eq_monge_plane (t : triangle (exprℝ) P) {i₁ i₂ i₃ : fin 3} (h₁₂ : i₁ ≠ i₂) (h₁₃ : i₁ ≠ i₃)\n    (h₂₃ : i₂ ≠ i₃) : t.altitude i₁ = t.monge_plane i₂ i₃ :=\n  by\n  have hs : («expr ᶜ» {i₂, i₃} : Finset (fin 3)) = {i₁} := by decide!\n  have he : univ.erase i₁ = {i₂, i₃} := by decide!\n  rw [monge_plane_def, altitude_def, direction_affine_span, hs, he, centroid_singleton, coe_insert, coe_singleton,\n    vector_span_image_eq_span_vsub_set_left_ne (exprℝ) _ (Set.mem_insert i₂ _)]\n  simp [h₂₃, submodule.span_insert_eq_span]\n#align altitude_eq_monge_plane altitude_eq_monge_plane\n\n",
 "altitude_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The definition of an altitude. -/\ntheorem altitude_def {n : ℕ} (s : simplex (exprℝ) P (n + 1)) (i : fin (n + 2)) :\n    s.altitude i =\n      «expr ⊓ » (mk' (s.points i) («expr ᗮ» (affine_span (exprℝ) («expr '' » s.points ↑(univ.erase i))).direction))\n        (affine_span (exprℝ) (Set.range s.points)) :=\n  rfl\n#align altitude_def altitude_def\n\n",
 "affine_span_pair_eq_altitude_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᗮ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A line through a vertex is the altitude through that vertex if and\nonly if it is orthogonal to the opposite face. -/\ntheorem affine_span_pair_eq_altitude_iff {n : ℕ} (s : simplex (exprℝ) P (n + 1)) (i : fin (n + 2)) (p : P) :\n    «exprline[ , , ]» (exprℝ) p (s.points i) = s.altitude i ↔\n      p ≠ s.points i ∧\n        p ∈ affine_span (exprℝ) (Set.range s.points) ∧\n          «expr -ᵥ » p (s.points i) ∈\n            «expr ᗮ» (affine_span (exprℝ) («expr '' » s.points ↑(finset.univ.erase i))).direction :=\n  by\n  rw [eq_iff_direction_eq_of_mem (mem_affine_span (exprℝ) (Set.mem_insert_of_mem _ (Set.mem_singleton _)))\n      (s.mem_altitude _),\n    ← vsub_right_mem_direction_iff_mem (mem_affine_span (exprℝ) (Set.mem_range_self i)) p, direction_affine_span,\n    direction_affine_span, direction_affine_span]\n  constructor\n  · intro h\n    constructor\n    · intro heq\n      rw [HEq, Set.pair_eq_singleton, vector_span_singleton] at h\n      have hd : finrank (exprℝ) (s.altitude i).direction = 0 := by rw [← h, finrank_bot]\n      simpa using hd\n    · rw [← submodule.mem_inf, _root_.inf_comm, ← direction_altitude, ← h]\n      exact vsub_mem_vector_span (exprℝ) (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_singleton _))\n  · rintro ⟨hne, h⟩\n    rw [← submodule.mem_inf, _root_.inf_comm, ← direction_altitude] at h\n    rw [vector_span_eq_span_vsub_set_left_ne (exprℝ) (Set.mem_insert _ _),\n      Set.insert_diff_of_mem _ (Set.mem_singleton _),\n      Set.diff_singleton_eq_self fun h => hne (Set.mem_singleton_iff.1 h), Set.image_singleton]\n    refine' eq_of_le_of_finrank_eq _ _\n    · rw [submodule.span_le]\n      simpa using h\n    · rw [finrank_direction_altitude, finrank_span_set_eq_card]\n      · simp\n      · refine' linear_independent_singleton _\n        simpa using hne\n#align affine_span_pair_eq_altitude_iff affine_span_pair_eq_altitude_iff\n\n",
 "affine_span_orthocenter_point_le_altitude":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The affine span of the orthocenter and a vertex is contained in\nthe altitude. -/\ntheorem affine_span_orthocenter_point_le_altitude (t : triangle (exprℝ) P) (i : fin 3) :\n    «exprline[ , , ]» (exprℝ) t.orthocenter (t.points i) ≤ t.altitude i :=\n  by\n  refine' span_points_subset_coe_of_subset_coe _\n  rw [Set.insert_subset, Set.singleton_subset_iff]\n  exact ⟨t.orthocenter_mem_altitude, t.mem_altitude i⟩\n#align affine_span_orthocenter_point_le_altitude affine_span_orthocenter_point_le_altitude\n\n",
 "affine_span_of_orthocentric_system":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Any three points in an orthocentric system span the same subspace\nas the whole orthocentric system. -/\ntheorem affine_span_of_orthocentric_system {s : set P} (ho : orthocentric_system s) {p : fin 3 → P}\n    (hps : Set.range p ⊆ s) (hpi : function.injective p) : affine_span (exprℝ) (Set.range p) = affine_span (exprℝ) s :=\n  by\n  have ha := ho.affine_independent hps hpi\n  rcases ho with ⟨t, hto, hts⟩\n  have hs : affine_span (exprℝ) s = affine_span (exprℝ) (Set.range t.points) := by\n    rw [hts, affine_span_insert_eq_affine_span (exprℝ) t.orthocenter_mem_affine_span]\n  refine'\n    ext_of_direction_eq _\n      ⟨p 0, mem_affine_span (exprℝ) (Set.mem_range_self _), mem_affine_span (exprℝ) (hps (Set.mem_range_self _))⟩\n  have hfd : finite_dimensional (exprℝ) (affine_span (exprℝ) s).direction :=\n    by\n    rw [hs]\n    infer_instance\n  haveI := hfd\n  refine' eq_of_le_of_finrank_eq (direction_le (affine_span_mono (exprℝ) hps)) _\n  rw [hs, direction_affine_span, direction_affine_span, ha.finrank_vector_span (fintype.card_fin _),\n    t.independent.finrank_vector_span (fintype.card_fin _)]\n#align affine_span_of_orthocentric_system affine_span_of_orthocentric_system\n\n",
 "affine_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Any three points in an orthocentric system are affinely independent. -/\ntheorem orthocentric_system.affine_independent {s : set P} (ho : orthocentric_system s) {p : fin 3 → P}\n    (hps : Set.range p ⊆ s) (hpi : function.injective p) : affine_independent (exprℝ) p :=\n  by\n  rcases ho with ⟨t, hto, hst⟩\n  rw [hst] at hps\n  rcases exists_dist_eq_circumradius_of_subset_insert_orthocenter hto hps hpi with ⟨c, hcs, hc⟩\n  exact cospherical.affine_independent ⟨c, t.circumradius, hc⟩ Set.Subset.rfl hpi\n#align orthocentric_system.affine_independent orthocentric_system.affine_independent\n\n"}