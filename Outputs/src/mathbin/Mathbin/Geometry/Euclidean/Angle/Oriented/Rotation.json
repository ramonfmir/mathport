{"rotation_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Rotation by 0 is the identity. -/\n@[simp]\ntheorem rotation_zero : o.rotation 0 = linear_isometry_equiv.refl (exprℝ) V := by ext <;> simp [rotation]\n#align rotation_zero rotation_zero\n\n",
 "rotation_trans":
 "/-- Rotating twice is equivalent to rotating by the sum of the angles. -/\n@[simp]\ntheorem rotation_trans (θ₁ θ₂ : real.angle) : (o.rotation θ₁).trans (o.rotation θ₂) = o.rotation (θ₂ + θ₁) :=\n  linear_isometry_equiv.ext fun _ => by rw [← rotation_rotation, linear_isometry_equiv.trans_apply]\n#align rotation_trans rotation_trans\n\n",
 "rotation_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprJ -/\ntheorem rotation_symm_apply (θ : real.angle) (x : V) :\n    (o.rotation θ).symm x = «expr • » (real.angle.cos θ) x - «expr • » (real.angle.sin θ) ((exprJ) x) :=\n  rfl\n#align rotation_symm_apply rotation_symm_apply\n\n",
 "rotation_symm":
 "/-- The inverse of `rotation` is rotation by the negation of the angle. -/\n@[simp]\ntheorem rotation_symm (θ : real.angle) : (o.rotation θ).symm = o.rotation (-θ) := by\n  ext <;> simp [o.rotation_apply, o.rotation_symm_apply, sub_eq_add_neg]\n#align rotation_symm rotation_symm\n\n",
 "rotation_rotation":
 "/-- Rotating twice is equivalent to rotating by the sum of the angles. -/\n@[simp]\ntheorem rotation_rotation (θ₁ θ₂ : real.angle) (x : V) : o.rotation θ₁ (o.rotation θ₂ x) = o.rotation (θ₁ + θ₂) x :=\n  by\n  simp only [o.rotation_apply, ← mul_smul, real.angle.cos_add, real.angle.sin_add, add_smul, sub_smul,\n    linear_isometry_equiv.trans_apply, smul_add, linear_isometry_equiv.map_add, linear_isometry_equiv.map_smul,\n    right_angle_rotation_right_angle_rotation, smul_neg]\n  ring_nf\n  abel\n#align rotation_rotation rotation_rotation\n\n",
 "rotation_pi_div_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprJ -/\n/-- Rotation by π / 2 is the \"right-angle-rotation\" map `J`. -/\ntheorem rotation_pi_div_two : o.rotation (real.pi / 2 : exprℝ) = exprJ :=\n  by\n  ext x\n  simp [rotation]\n#align rotation_pi_div_two rotation_pi_div_two\n\n",
 "rotation_pi_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/-- Rotation by π is negation. -/\ntheorem rotation_pi_apply (x : V) : o.rotation (real.pi) x = -x := by simp\n#align rotation_pi_apply rotation_pi_apply\n\n",
 "rotation_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Rotation by π is negation. -/\n@[simp]\ntheorem rotation_pi : o.rotation (real.pi) = linear_isometry_equiv.neg (exprℝ) :=\n  by\n  ext x\n  simp [rotation]\n#align rotation_pi rotation_pi\n\n",
 "rotation_oangle_eq_iff_norm_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Rotating a vector by the angle to another vector gives the second vector if and only if the\nnorms are equal. -/\n@[simp]\ntheorem rotation_oangle_eq_iff_norm_eq (x y : V) : o.rotation (o.oangle x y) x = y ↔ «expr‖ ‖» x = «expr‖ ‖» y :=\n  by\n  constructor\n  · intro h\n    rw [← h, linear_isometry_equiv.norm_map]\n  · intro h\n    rw [o.eq_iff_oangle_eq_zero_of_norm_eq] <;> simp [h]\n#align rotation_oangle_eq_iff_norm_eq rotation_oangle_eq_iff_norm_eq\n\n",
 "rotation_neg_orientation_eq_neg":
 "/-- Negating the orientation negates the angle in `rotation`. -/\ntheorem rotation_neg_orientation_eq_neg (θ : real.angle) : (-o).rotation θ = o.rotation (-θ) :=\n  linear_isometry_equiv.ext <| by simp [rotation_apply]\n#align rotation_neg_orientation_eq_neg rotation_neg_orientation_eq_neg\n\n",
 "rotation_map_complex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- Rotation in an oriented real inner product space of dimension 2 can be evaluated in terms of a\ncomplex-number representation of the space. -/\ntheorem rotation_map_complex (θ : real.angle) (f : «expr ≃ₗᵢ[ ] » V (exprℝ) (exprℂ))\n    (hf : orientation.map (fin 2) f.to_linear_equiv o = complex.orientation) (x : V) :\n    f (o.rotation θ x) = θ.exp_map_circle * f x :=\n  by\n  rw [← complex.rotation, ← hf, o.rotation_map]\n  simp\n#align rotation_map_complex rotation_map_complex\n\n",
 "rotation_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem rotation_map (θ : real.angle) (f : «expr ≃ₗᵢ[ ] » V (exprℝ) V') (x : V') :\n    (orientation.map (fin 2) f.to_linear_equiv o).rotation θ x = f (o.rotation θ (f.symm x)) := by\n  simp [rotation_apply, o.right_angle_rotation_map]\n#align rotation_map rotation_map\n\n",
 "rotation_eq_self_iff_angle_eq_zero":
 "/-- A rotation of a nonzero vector equals that vector if and only if the angle is zero. -/\n@[simp]\ntheorem rotation_eq_self_iff_angle_eq_zero {x : V} (hx : x ≠ 0) (θ : real.angle) : o.rotation θ x = x ↔ θ = 0 :=\n  by\n  constructor\n  · intro h\n    rw [eq_comm]\n    simpa [hx, h] using o.oangle_rotation_right hx hx θ\n  · intro h\n    simp [h]\n#align rotation_eq_self_iff_angle_eq_zero rotation_eq_self_iff_angle_eq_zero\n\n",
 "rotation_eq_self_iff":
 "/-- A rotation of a vector equals that vector if and only if the vector or the angle is zero. -/\ntheorem rotation_eq_self_iff (x : V) (θ : real.angle) : o.rotation θ x = x ↔ x = 0 ∨ θ = 0 := by\n  by_cases h : x = 0 <;> simp [h]\n#align rotation_eq_self_iff rotation_eq_self_iff\n\n",
 "rotation_eq_matrix_to_lin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr!![ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation -/\ntheorem rotation_eq_matrix_to_lin (θ : real.angle) {x : V} (hx : x ≠ 0) :\n    (o.rotation θ).to_linear_map =\n      matrix.to_lin (o.basis_right_angle_rotation x hx) (o.basis_right_angle_rotation x hx)\n        («expr!![ » \"./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation\") :=\n  by\n  apply (o.basis_right_angle_rotation x hx).ext\n  intro i\n  fin_cases i\n  · rw [matrix.to_lin_self]\n    simp [rotation_apply, fin.sum_univ_succ]\n  · rw [matrix.to_lin_self]\n    simp [rotation_apply, fin.sum_univ_succ, add_comm]\n#align rotation_eq_matrix_to_lin rotation_eq_matrix_to_lin\n\n",
 "rotation_aux_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprJ -/\n/-\nCopyright (c) 2022 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers, Heather Macbeth\n-/\n@[simp]\ntheorem rotation_aux_apply (θ : real.angle) (x : V) :\n    o.rotation_aux θ x = «expr • » (real.angle.cos θ) x + «expr • » (real.angle.sin θ) ((exprJ) x) :=\n  rfl\n#align rotation_aux_apply rotation_aux_apply\n\n",
 "rotation_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprJ -/\ntheorem rotation_apply (θ : real.angle) (x : V) :\n    o.rotation θ x = «expr • » (real.angle.cos θ) x + «expr • » (real.angle.sin θ) ((exprJ) x) :=\n  rfl\n#align rotation_apply rotation_apply\n\n",
 "rotation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp]\nprotected theorem _root_.complex.rotation (θ : real.angle) (z : exprℂ) :\n    complex.orientation.rotation θ z = θ.exp_map_circle * z :=\n  by\n  simp only [rotation_apply, complex.right_angle_rotation, real.angle.coe_exp_map_circle, real_smul]\n  ring\n#align complex.rotation complex.rotation\n\n",
 "oangle_rotation_self_right":
 "/-- A vector has an angle of `θ` from the rotation of that vector by `θ`. -/\n@[simp]\ntheorem oangle_rotation_self_right {x : V} (hx : x ≠ 0) (θ : real.angle) : o.oangle x (o.rotation θ x) = θ := by\n  simp [hx]\n#align oangle_rotation_self_right oangle_rotation_self_right\n\n",
 "oangle_rotation_self_left":
 "/-- The rotation of a vector by `θ` has an angle of `-θ` from that vector. -/\n@[simp]\ntheorem oangle_rotation_self_left {x : V} (hx : x ≠ 0) (θ : real.angle) : o.oangle (o.rotation θ x) x = -θ := by\n  simp [hx]\n#align oangle_rotation_self_left oangle_rotation_self_left\n\n",
 "oangle_rotation_right":
 "/-- Rotating the second vector by `θ` adds `θ` to the angle between two vectors. -/\n@[simp]\ntheorem oangle_rotation_right {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : real.angle) :\n    o.oangle x (o.rotation θ y) = o.oangle x y + θ :=\n  by\n  simp only [oangle, o.kahler_rotation_right]\n  rw [complex.arg_mul_coe_angle, real.angle.arg_exp_map_circle]\n  · abel\n  · exact ne_zero_of_mem_circle _\n  · exact o.kahler_ne_zero hx hy\n#align oangle_rotation_right oangle_rotation_right\n\n",
 "oangle_rotation_oangle_right":
 "/-- Rotating the first vector by the angle between the two vectors and swapping the vectors\nresults an an angle of 0. -/\n@[simp]\ntheorem oangle_rotation_oangle_right (x y : V) : o.oangle y (o.rotation (o.oangle x y) x) = 0 :=\n  by\n  rw [oangle_rev]\n  simp\n#align oangle_rotation_oangle_right oangle_rotation_oangle_right\n\n",
 "oangle_rotation_oangle_left":
 "/-- Rotating the first vector by the angle between the two vectors results an an angle of 0. -/\n@[simp]\ntheorem oangle_rotation_oangle_left (x y : V) : o.oangle (o.rotation (o.oangle x y) x) y = 0 :=\n  by\n  by_cases hx : x = 0\n  · simp [hx]\n  · by_cases hy : y = 0\n    · simp [hy]\n    · simp [hx, hy]\n#align oangle_rotation_oangle_left oangle_rotation_oangle_left\n\n",
 "oangle_rotation_left":
 "/-- Rotating the first vector by `θ` subtracts `θ` from the angle between two vectors. -/\n@[simp]\ntheorem oangle_rotation_left {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : real.angle) :\n    o.oangle (o.rotation θ x) y = o.oangle x y - θ :=\n  by\n  simp only [oangle, o.kahler_rotation_left']\n  rw [complex.arg_mul_coe_angle, real.angle.arg_exp_map_circle]\n  · abel\n  · exact ne_zero_of_mem_circle _\n  · exact o.kahler_ne_zero hx hy\n#align oangle_rotation_left oangle_rotation_left\n\n",
 "oangle_rotation":
 "/-- Rotating both vectors by the same angle does not change the angle between those vectors. -/\n@[simp]\ntheorem oangle_rotation (x y : V) (θ : real.angle) : o.oangle (o.rotation θ x) (o.rotation θ y) = o.oangle x y := by\n  by_cases hx : x = 0 <;> by_cases hy : y = 0 <;> simp [hx, hy]\n#align oangle_rotation oangle_rotation\n\n",
 "oangle_eq_iff_eq_pos_smul_rotation_or_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The angle between two vectors is `θ` if and only if they are nonzero and the second vector\nis the first rotated by `θ` and scaled by a positive real, or `θ` and at least one of the\nvectors are zero. -/\ntheorem oangle_eq_iff_eq_pos_smul_rotation_or_eq_zero {x y : V} (θ : real.angle) :\n    o.oangle x y = θ ↔\n      (x ≠ 0 ∧ y ≠ 0 ∧ ∃ r : exprℝ, 0 < r ∧ y = «expr • » r (o.rotation θ x)) ∨ θ = 0 ∧ (x = 0 ∨ y = 0) :=\n  by\n  by_cases hx : x = 0\n  · simp [hx, eq_comm]\n  · by_cases hy : y = 0\n    · simp [hy, eq_comm]\n    · rw [o.oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero hx hy]\n      simp [hx, hy]\n#align oangle_eq_iff_eq_pos_smul_rotation_or_eq_zero oangle_eq_iff_eq_pos_smul_rotation_or_eq_zero\n\n",
 "oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The angle between two nonzero vectors is `θ` if and only if the second vector is the first\nrotated by `θ` and scaled by a positive real. -/\ntheorem oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : real.angle) :\n    o.oangle x y = θ ↔ ∃ r : exprℝ, 0 < r ∧ y = «expr • » r (o.rotation θ x) :=\n  by\n  constructor\n  · intro h\n    rw [o.oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero hx hy] at h\n    exact ⟨«expr‖ ‖» y / «expr‖ ‖» x, div_pos (norm_pos_iff.2 hy) (norm_pos_iff.2 hx), h⟩\n  · rintro ⟨r, hr, rfl⟩\n    rw [o.oangle_smul_right_of_pos _ _ hr, o.oangle_rotation_self_right hx]\n#align oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero\n\n",
 "oangle_eq_iff_eq_norm_div_norm_smul_rotation_or_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The angle between two vectors is `θ` if and only if they are nonzero and the second vector\nis the first rotated by `θ` and scaled by the ratio of the norms, or `θ` and at least one of the\nvectors are zero. -/\ntheorem oangle_eq_iff_eq_norm_div_norm_smul_rotation_or_eq_zero {x y : V} (θ : real.angle) :\n    o.oangle x y = θ ↔\n      x ≠ 0 ∧ y ≠ 0 ∧ y = «expr • » («expr‖ ‖» y / «expr‖ ‖» x) (o.rotation θ x) ∨ θ = 0 ∧ (x = 0 ∨ y = 0) :=\n  by\n  by_cases hx : x = 0\n  · simp [hx, eq_comm]\n  · by_cases hy : y = 0\n    · simp [hy, eq_comm]\n    · rw [o.oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero hx hy]\n      simp [hx, hy]\n#align oangle_eq_iff_eq_norm_div_norm_smul_rotation_or_eq_zero oangle_eq_iff_eq_norm_div_norm_smul_rotation_or_eq_zero\n\n",
 "oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The angle between two nonzero vectors is `θ` if and only if the second vector is the first\nrotated by `θ` and scaled by the ratio of the norms. -/\ntheorem oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : real.angle) :\n    o.oangle x y = θ ↔ y = «expr • » («expr‖ ‖» y / «expr‖ ‖» x) (o.rotation θ x) :=\n  by\n  have hp := div_pos (norm_pos_iff.2 hy) (norm_pos_iff.2 hx)\n  constructor\n  · rintro rfl\n    rw [← linear_isometry_equiv.map_smul, ← o.oangle_smul_left_of_pos x y hp, eq_comm, rotation_oangle_eq_iff_norm_eq,\n      norm_smul, real.norm_of_nonneg hp.le, div_mul_cancel _ (norm_ne_zero_iff.2 hx)]\n  · intro hye\n    rw [hye, o.oangle_smul_right_of_pos _ _ hp, o.oangle_rotation_self_right hx]\n#align oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero\n\n",
 "neg_rotation_pi_div_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Negating a rotation by π / 2 is equivalent to rotation by -π / 2. -/\ntheorem neg_rotation_pi_div_two (x : V) : -o.rotation (real.pi / 2 : exprℝ) x = o.rotation (-real.pi / 2 : exprℝ) x :=\n  neg_eq_iff_neg_eq.1 <| o.neg_rotation_neg_pi_div_two _\n#align neg_rotation_pi_div_two neg_rotation_pi_div_two\n\n",
 "neg_rotation_neg_pi_div_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Negating a rotation by -π / 2 is equivalent to rotation by π / 2. -/\n@[simp]\ntheorem neg_rotation_neg_pi_div_two (x : V) :\n    -o.rotation (-real.pi / 2 : exprℝ) x = o.rotation (real.pi / 2 : exprℝ) x := by\n  rw [neg_rotation, ← real.angle.coe_add, neg_div, ← sub_eq_add_neg, sub_half]\n#align neg_rotation_neg_pi_div_two neg_rotation_neg_pi_div_two\n\n",
 "neg_rotation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/-- Negating a rotation is equivalent to rotation by π plus the angle. -/\ntheorem neg_rotation (θ : real.angle) (x : V) : -o.rotation θ x = o.rotation (real.pi + θ) x := by\n  rw [← o.rotation_pi_apply, rotation_rotation]\n#align neg_rotation neg_rotation\n\n",
 "linear_equiv_det_rotation":
 "/-- The determinant of `rotation` (as a linear equiv) is equal to `1`. -/\n@[simp]\ntheorem linear_equiv_det_rotation (θ : real.angle) : (o.rotation θ).to_linear_equiv.det = 1 :=\n  Units.ext <| o.det_rotation θ\n#align linear_equiv_det_rotation linear_equiv_det_rotation\n\n",
 "kahler_rotation_right":
 "/-- Rotating the second of two vectors by `θ` scales their Kahler form by `cos θ + sin θ * I`. -/\n@[simp]\ntheorem kahler_rotation_right (x y : V) (θ : real.angle) :\n    o.kahler x (o.rotation θ y) = θ.exp_map_circle * o.kahler x y :=\n  by\n  simp only [o.rotation_apply, map_add, linear_map.map_smulₛₗ, RingHom.id_apply, real_smul,\n    kahler_right_angle_rotation_right, real.angle.coe_exp_map_circle]\n  ring\n#align kahler_rotation_right kahler_rotation_right\n\n",
 "kahler_rotation_left'":
 "/-- Rotating the first of two vectors by `θ` scales their Kahler form by `cos (-θ) + sin (-θ) * I`.\n-/\ntheorem kahler_rotation_left' (x y : V) (θ : real.angle) :\n    o.kahler (o.rotation θ x) y = (-θ).exp_map_circle * o.kahler x y := by\n  simpa [coe_inv_circle_eq_conj, -kahler_rotation_left] using o.kahler_rotation_left x y θ\n#align kahler_rotation_left' kahler_rotation_left'\n\n",
 "kahler_rotation_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- Rotating the first of two vectors by `θ` scales their Kahler form by `cos θ - sin θ * I`. -/\n@[simp]\ntheorem kahler_rotation_left (x y : V) (θ : real.angle) :\n    o.kahler (o.rotation θ x) y = (star_ring_end) (θ.exp_map_circle : exprℂ) * o.kahler x y :=\n  by\n  simp only [o.rotation_apply, map_add, map_mul, linear_map.map_smulₛₗ, RingHom.id_apply, linear_map.add_apply,\n    linear_map.smul_apply, real_smul, kahler_right_angle_rotation_left, real.angle.coe_exp_map_circle,\n    is_R_or_C.conj_of_real, conj_I]\n  ring\n#align kahler_rotation_left kahler_rotation_left\n\n",
 "inner_smul_rotation_pi_div_two_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The inner product between a multiple of a vector and a multiple of a `π / 2` rotation of\nthat vector is zero. -/\n@[simp]\ntheorem inner_smul_rotation_pi_div_two_smul_right (x : V) (r₁ r₂ : exprℝ) :\n    inner.real («expr • » r₂ x) («expr • » r₁ (o.rotation (real.pi / 2 : exprℝ) x)) = 0 := by\n  rw [real_inner_comm, inner_smul_rotation_pi_div_two_smul_left]\n#align inner_smul_rotation_pi_div_two_smul_right inner_smul_rotation_pi_div_two_smul_right\n\n",
 "inner_smul_rotation_pi_div_two_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The inner product between a multiple of a `π / 2` rotation of a vector and a multiple of\nthat vector is zero. -/\n@[simp]\ntheorem inner_smul_rotation_pi_div_two_smul_left (x : V) (r₁ r₂ : exprℝ) :\n    inner.real («expr • » r₁ (o.rotation (real.pi / 2 : exprℝ) x)) («expr • » r₂ x) = 0 := by\n  rw [inner_smul_right, inner_smul_rotation_pi_div_two_left, mul_zero]\n#align inner_smul_rotation_pi_div_two_smul_left inner_smul_rotation_pi_div_two_smul_left\n\n",
 "inner_smul_rotation_pi_div_two_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The inner product between a vector and a multiple of a `π / 2` rotation of that vector is\nzero. -/\n@[simp]\ntheorem inner_smul_rotation_pi_div_two_right (x : V) (r : exprℝ) :\n    inner.real x («expr • » r (o.rotation (real.pi / 2 : exprℝ) x)) = 0 := by\n  rw [real_inner_comm, inner_smul_rotation_pi_div_two_left]\n#align inner_smul_rotation_pi_div_two_right inner_smul_rotation_pi_div_two_right\n\n",
 "inner_smul_rotation_pi_div_two_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The inner product between a multiple of a `π / 2` rotation of a vector and that vector is\nzero. -/\n@[simp]\ntheorem inner_smul_rotation_pi_div_two_left (x : V) (r : exprℝ) :\n    inner.real («expr • » r (o.rotation (real.pi / 2 : exprℝ) x)) x = 0 := by\n  rw [inner_smul_left, inner_rotation_pi_div_two_left, mul_zero]\n#align inner_smul_rotation_pi_div_two_left inner_smul_rotation_pi_div_two_left\n\n",
 "inner_rotation_pi_div_two_right_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The inner product between a multiple of a vector and a `π / 2` rotation of that vector is\nzero. -/\n@[simp]\ntheorem inner_rotation_pi_div_two_right_smul (x : V) (r : exprℝ) :\n    inner.real («expr • » r x) (o.rotation (real.pi / 2 : exprℝ) x) = 0 := by\n  rw [real_inner_comm, inner_rotation_pi_div_two_left_smul]\n#align inner_rotation_pi_div_two_right_smul inner_rotation_pi_div_two_right_smul\n\n",
 "inner_rotation_pi_div_two_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The inner product between a vector and a `π / 2` rotation of that vector is zero. -/\n@[simp]\ntheorem inner_rotation_pi_div_two_right (x : V) : inner.real x (o.rotation (real.pi / 2 : exprℝ) x) = 0 := by\n  rw [real_inner_comm, inner_rotation_pi_div_two_left]\n#align inner_rotation_pi_div_two_right inner_rotation_pi_div_two_right\n\n",
 "inner_rotation_pi_div_two_left_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The inner product between a `π / 2` rotation of a vector and a multiple of that vector is\nzero. -/\n@[simp]\ntheorem inner_rotation_pi_div_two_left_smul (x : V) (r : exprℝ) :\n    inner.real (o.rotation (real.pi / 2 : exprℝ) x) («expr • » r x) = 0 := by\n  rw [inner_smul_right, inner_rotation_pi_div_two_left, mul_zero]\n#align inner_rotation_pi_div_two_left_smul inner_rotation_pi_div_two_left_smul\n\n",
 "inner_rotation_pi_div_two_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The inner product between a `π / 2` rotation of a vector and that vector is zero. -/\n@[simp]\ntheorem inner_rotation_pi_div_two_left (x : V) : inner.real (o.rotation (real.pi / 2 : exprℝ) x) x = 0 := by\n  rw [rotation_pi_div_two, inner_right_angle_rotation_self]\n#align inner_rotation_pi_div_two_left inner_rotation_pi_div_two_left\n\n",
 "inner_eq_zero_iff_eq_zero_or_eq_smul_rotation_pi_div_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The inner product between two vectors is zero if and only if the first vector is zero or\nthe second is a multiple of a `π / 2` rotation of that vector. -/\ntheorem inner_eq_zero_iff_eq_zero_or_eq_smul_rotation_pi_div_two {x y : V} :\n    inner.real x y = 0 ↔ x = 0 ∨ ∃ r : exprℝ, «expr • » r (o.rotation (real.pi / 2 : exprℝ) x) = y :=\n  by\n  rw [← o.eq_zero_or_oangle_eq_iff_inner_eq_zero]\n  refine' ⟨fun h => _, fun h => _⟩\n  · rcases h with (rfl | rfl | h | h)\n    · exact or.inl rfl\n    · exact or.inr ⟨0, zero_smul _ _⟩\n    · obtain ⟨r, hr, rfl⟩ :=\n        (o.oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero (o.left_ne_zero_of_oangle_eq_pi_div_two h)\n              (o.right_ne_zero_of_oangle_eq_pi_div_two h) _).1\n          h\n      exact or.inr ⟨r, rfl⟩\n    · obtain ⟨r, hr, rfl⟩ :=\n        (o.oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero (o.left_ne_zero_of_oangle_eq_neg_pi_div_two h)\n              (o.right_ne_zero_of_oangle_eq_neg_pi_div_two h) _).1\n          h\n      refine' or.inr ⟨-r, _⟩\n      rw [neg_smul, ← smul_neg, o.neg_rotation_pi_div_two]\n  · rcases h with (rfl | ⟨r, rfl⟩)\n    · exact or.inl rfl\n    · by_cases hx : x = 0\n      · exact or.inl hx\n      rcases lt_trichotomy r 0 with (hr | rfl | hr)\n      · refine' or.inr (or.inr (or.inr _))\n        rw [o.oangle_smul_right_of_neg _ _ hr, o.neg_rotation_pi_div_two, o.oangle_rotation_self_right hx]\n      · exact or.inr (or.inl (zero_smul _ _))\n      · refine' or.inr (or.inr (or.inl _))\n        rw [o.oangle_smul_right_of_pos _ _ hr, o.oangle_rotation_self_right hx]\n#align inner_eq_zero_iff_eq_zero_or_eq_smul_rotation_pi_div_two inner_eq_zero_iff_eq_zero_or_eq_smul_rotation_pi_div_two\n\n",
 "exists_linear_isometry_equiv_eq_of_det_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprJ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprJ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗᵢ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Any linear isometric equivalence in `V` with positive determinant is `rotation`. -/\ntheorem exists_linear_isometry_equiv_eq_of_det_pos {f : «expr ≃ₗᵢ[ ] » V (exprℝ) V}\n    (hd : 0 < (f.to_linear_equiv : «expr →ₗ[ ] » V (exprℝ) V).det) : ∃ θ : real.angle, f = o.rotation θ :=\n  by\n  haveI : nontrivial V := finite_dimensional.nontrivial_of_finrank_eq_succ (fact.out (finrank (exprℝ) V = 2))\n  obtain ⟨x, hx⟩ : ∃ x, x ≠ (0 : V) := exists_ne (0 : V)\n  use o.oangle x (f x)\n  apply linear_isometry_equiv.to_linear_equiv_injective\n  apply linear_equiv.to_linear_map_injective\n  apply (o.basis_right_angle_rotation x hx).ext\n  intro i\n  symm\n  fin_cases i\n  · simp\n  have : o.oangle ((exprJ) x) (f ((exprJ) x)) = o.oangle x (f x) := by\n    simp only [oangle, o.linear_isometry_equiv_comp_right_angle_rotation f hd, o.kahler_comp_right_angle_rotation]\n  simp [← this]\n#align exists_linear_isometry_equiv_eq_of_det_pos exists_linear_isometry_equiv_eq_of_det_pos\n\n",
 "eq_rotation_self_iff_angle_eq_zero":
 "/-- A nonzero vector equals a rotation of that vector if and only if the angle is zero. -/\n@[simp]\ntheorem eq_rotation_self_iff_angle_eq_zero {x : V} (hx : x ≠ 0) (θ : real.angle) : x = o.rotation θ x ↔ θ = 0 := by\n  rw [← o.rotation_eq_self_iff_angle_eq_zero hx, eq_comm]\n#align eq_rotation_self_iff_angle_eq_zero eq_rotation_self_iff_angle_eq_zero\n\n",
 "eq_rotation_self_iff":
 "/-- A vector equals a rotation of that vector if and only if the vector or the angle is zero. -/\ntheorem eq_rotation_self_iff (x : V) (θ : real.angle) : x = o.rotation θ x ↔ x = 0 ∨ θ = 0 := by\n  rw [← rotation_eq_self_iff, eq_comm]\n#align eq_rotation_self_iff eq_rotation_self_iff\n\n",
 "det_rotation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The determinant of `rotation` (as a linear map) is equal to `1`. -/\n@[simp]\ntheorem det_rotation (θ : real.angle) : (o.rotation θ).to_linear_map.det = 1 :=\n  by\n  haveI : nontrivial V := finite_dimensional.nontrivial_of_finrank_eq_succ (fact.out (finrank (exprℝ) V = 2))\n  obtain ⟨x, hx⟩ : ∃ x, x ≠ (0 : V) := exists_ne (0 : V)\n  rw [o.rotation_eq_matrix_to_lin θ hx]\n  simpa [sq] using θ.cos_sq_add_sin_sq\n#align det_rotation det_rotation\n\n"}