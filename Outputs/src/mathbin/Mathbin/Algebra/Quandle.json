{"well_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf_hom -/\n-- Define the `group` instances in two steps so `inv` can be inferred correctly.\n-- TODO: is there a non-invasive way of defining the instance directly?\n/-- Show that `to_envel_group.map_aux` sends equivalent expressions to equal terms.\n-/\ntheorem well_def {R : Type _} [Rack R] {G : Type _} [Group G] (f : shelf_hom R (Quandle.Conj G)) :\n    ∀ {a b : PreEnvelGroup R}, PreEnvelGroupRel' R a b → toEnvelGroup.mapAux f a = toEnvelGroup.mapAux f b\n  | a, b, refl => rfl\n  | a, b, symm h => (well_def h).symm\n  | a, b, trans hac hcb => Eq.trans (well_def hac) (well_def hcb)\n  | _, _, congr_mul ha hb => by simp [to_envel_group.map_aux, well_def ha, well_def hb]\n  | _, _, congr_inv ha => by simp [to_envel_group.map_aux, well_def ha]\n  | _, _, assoc a b c => by apply mul_assoc\n  | _, _, one_mul a => by simp [to_envel_group.map_aux]\n  | _, _, mul_one a => by simp [to_envel_group.map_aux]\n  | _, _, mul_left_inv a => by simp [to_envel_group.map_aux]\n  | _, _, act_incl x y => by simp [to_envel_group.map_aux]\n#align well_def well_def\n\n",
 "univ_uniq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- The homomorphism `to_envel_group.map f` is the unique map that fits into the commutative\ntriangle in `to_envel_group.univ`.\n-/\ntheorem to_envel_group.univ_uniq (R : Type _) [Rack R] (G : Type _) [Group G] (f : shelf_hom R (Quandle.Conj G))\n    (g : «expr →* » (EnvelGroup R) G) (h : f = (Quandle.Conj.map g).comp (toEnvelGroup R)) : g = toEnvelGroup.map f :=\n  h.symm ▸ (toEnvelGroup.map.apply_symm_apply g).symm\n#align to_envel_group.univ_uniq to_envel_group.univ_uniq\n\n",
 "univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf_hom -/\n/-- Given a homomorphism from a rack to a group, it factors through the enveloping group.\n-/\ntheorem to_envel_group.univ (R : Type _) [Rack R] (G : Type _) [Group G] (f : shelf_hom R (Quandle.Conj G)) :\n    (Quandle.Conj.map (toEnvelGroup.map f)).comp (toEnvelGroup R) = f :=\n  toEnvelGroup.map.symm_apply_apply f\n#align to_envel_group.univ to_envel_group.univ\n\n",
 "trans":
 "@[trans]\ntheorem pre_envel_group_rel.trans {R : Type u} [Rack R] {a b c : PreEnvelGroup R} :\n    PreEnvelGroupRel R a b → PreEnvelGroupRel R b c → PreEnvelGroupRel R a c\n  | ⟨rab⟩, ⟨rbc⟩ => (rab.trans rbc).rel\n#align pre_envel_group_rel.trans pre_envel_group_rel.trans\n\n",
 "to_fun_eq_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf_hom -/\n@[simp]\ntheorem to_fun_eq_coe (f : shelf_hom S₁ S₂) : f.to_fun = f :=\n  rfl\n#align to_fun_eq_coe to_fun_eq_coe\n\n",
 "symm":
 "@[symm]\ntheorem pre_envel_group_rel.symm {R : Type u} [Rack R] {a b : PreEnvelGroup R} :\n    PreEnvelGroupRel R a b → PreEnvelGroupRel R b a\n  | ⟨r⟩ => r.symm.rel\n#align pre_envel_group_rel.symm pre_envel_group_rel.symm\n\n",
 "self_inv_act_inv_act_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n@[simp]\ntheorem self_inv_act_inv_act_eq {x y : R} : rack.inv_act (rack.inv_act x x) y = rack.inv_act x y :=\n  by\n  have h := @self_act_act_eq _ _ (op x) (op y)\n  simpa using h\n#align self_inv_act_inv_act_eq self_inv_act_inv_act_eq\n\n",
 "self_inv_act_eq_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\ntheorem self_inv_act_eq_iff_eq {x y : R} : rack.inv_act x x = rack.inv_act y y ↔ x = y :=\n  by\n  have h := @self_act_eq_iff_eq _ _ (op x) (op y)\n  simpa using h\n#align self_inv_act_eq_iff_eq self_inv_act_eq_iff_eq\n\n",
 "self_inv_act_act_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n@[simp]\ntheorem self_inv_act_act_eq {x y : R} : shelf.act (rack.inv_act x x) y = shelf.act x y :=\n  by\n  have h := @self_act_inv_act_eq _ _ (op x) (op y)\n  simpa using h\n#align self_inv_act_act_eq self_inv_act_act_eq\n\n",
 "self_distrib_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\ntheorem self_distrib_inv {x y z : R} :\n    rack.inv_act x (rack.inv_act y z) = rack.inv_act (rack.inv_act x y) (rack.inv_act x z) :=\n  by\n  rw [← left_cancel (rack.inv_act x y), right_inv, ← left_cancel x, right_inv, self_distrib]\n  repeat' rw [right_inv]\n#align self_distrib_inv self_distrib_inv\n\n",
 "self_distrib":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\ntheorem self_distrib {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) (shelf.act x z) :=\n  shelf.self_distrib\n#align self_distrib self_distrib\n\n",
 "self_act_inv_act_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n@[simp]\ntheorem self_act_inv_act_eq {x y : R} : rack.inv_act (shelf.act x x) y = rack.inv_act x y :=\n  by\n  rw [← left_cancel (shelf.act x x)]\n  rw [right_inv]\n  rw [self_act_act_eq]\n  rw [right_inv]\n#align self_act_inv_act_eq self_act_inv_act_eq\n\n",
 "self_act_eq_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\ntheorem self_act_eq_iff_eq {x y : R} : shelf.act x x = shelf.act y y ↔ x = y :=\n  by\n  constructor; swap; rintro rfl; rfl\n  intro h\n  trans rack.inv_act (shelf.act x x) (shelf.act x x)\n  rw [← left_cancel (shelf.act x x), right_inv, self_act_act_eq]\n  rw [h, ← left_cancel (shelf.act y y), right_inv, self_act_act_eq]\n#align self_act_eq_iff_eq self_act_eq_iff_eq\n\n",
 "self_act_act_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n@[simp]\ntheorem self_act_act_eq {x y : R} : shelf.act (shelf.act x x) y = shelf.act x y := by\n  rw [← right_inv x y, ← self_distrib]\n#align self_act_act_eq self_act_act_eq\n\n",
 "rel":
 "/-- A quick way to convert a `pre_envel_group_rel'` to a `pre_envel_group_rel`.\n-/\ntheorem pre_envel_group_rel'.rel {R : Type u} [Rack R] {a b : PreEnvelGroup R} :\n    PreEnvelGroupRel' R a b → PreEnvelGroupRel R a b :=\n  pre_envel_group_rel.rel\n#align pre_envel_group_rel'.rel pre_envel_group_rel'.rel\n\n",
 "refl":
 "@[refl]\ntheorem pre_envel_group_rel.refl {R : Type u} [Rack R] {a : PreEnvelGroup R} : PreEnvelGroupRel R a a :=\n  pre_envel_group_rel.rel pre_envel_group_rel'.refl\n#align pre_envel_group_rel.refl pre_envel_group_rel.refl\n\n",
 "op_inv_act_op_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n@[simp]\ntheorem op_inv_act_op_eq {x y : R} : rack.inv_act (op x) (op y) = op (shelf.act x y) :=\n  rfl\n#align op_inv_act_op_eq op_inv_act_op_eq\n\n",
 "op_act_op_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n@[simp]\ntheorem op_act_op_eq {x y : R} : shelf.act (op x) (op y) = op (rack.inv_act x y) :=\n  rfl\n#align op_act_op_eq op_act_op_eq\n\n",
 "map_act":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n@[simp]\ntheorem map_act (f : shelf_hom S₁ S₂) {x y : S₁} : f (shelf.act x y) = shelf.act (f x) (f y) :=\n  map_act' f\n#align map_act map_act\n\n",
 "left_cancel_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\ntheorem left_cancel_inv (x : R) {y y' : R} : rack.inv_act x y = rack.inv_act x y' ↔ y = y' :=\n  by\n  constructor\n  apply (act x).symm.injective\n  rintro rfl\n  rfl\n#align left_cancel_inv left_cancel_inv\n\n",
 "left_cancel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\ntheorem left_cancel (x : R) {y y' : R} : shelf.act x y = shelf.act x y' ↔ y = y' :=\n  by\n  constructor\n  apply (act x).injective\n  rintro rfl\n  rfl\n#align left_cancel left_cancel\n\n",
 "involutory_inv_act_eq_act":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\ntheorem involutory_inv_act_eq_act {R : Type _} [Rack R] (h : IsInvolutory R) (x y : R) :\n    rack.inv_act x y = shelf.act x y := by\n  rw [← left_cancel x, right_inv]\n  exact ((h x).left_inverse y).symm\n#align involutory_inv_act_eq_act involutory_inv_act_eq_act\n\n",
 "inv_act_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n@[simp]\ntheorem inv_act_apply (x y : R) : (act' x)⁻¹ y = rack.inv_act x y :=\n  rfl\n#align inv_act_apply inv_act_apply\n\n",
 "inv_act_act_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n@[simp]\ntheorem inv_act_act_eq (x y : R) : rack.inv_act x (shelf.act x y) = y :=\n  left_inv x y\n#align inv_act_act_eq inv_act_act_eq\n\n",
 "inv":
 "theorem dihedral_act.inv (n : ℕ) (a : ZMod n) : Function.Involutive (dihedralAct n a) :=\n  by\n  intro b\n  dsimp [dihedral_act]\n  ring\n#align dihedral_act.inv dihedral_act.inv\n\n",
 "fix_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n@[simp]\ntheorem fix_inv {x : Q} : rack.inv_act x x = x :=\n  by\n  rw [← left_cancel x]\n  simp\n#align fix_inv fix_inv\n\n",
 "envel_action_prop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n@[simp]\ntheorem envel_action_prop {R : Type _} [Rack R] (x y : R) : envelAction (toEnvelGroup R x) y = shelf.act x y :=\n  rfl\n#align envel_action_prop envel_action_prop\n\n",
 "conj_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\ntheorem conj_swap {G : Type _} [Group G] (x y : Conj G) : shelf.act x y = y ↔ shelf.act y x = x :=\n  by\n  dsimp [conj] at *; constructor\n  repeat' intro h; conv_rhs => rw [eq_mul_inv_of_mul_eq (eq_mul_inv_of_mul_eq h)]; simp\n#align conj_swap conj_swap\n\n",
 "conj_act_eq_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n@[simp]\ntheorem conj_act_eq_conj {G : Type _} [Group G] (x y : Conj G) : shelf.act x y = ((x : G) * (y : G) * (x : G)⁻¹ : G) :=\n  rfl\n#align conj_act_eq_conj conj_act_eq_conj\n\n",
 "comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf_hom -/\n@[simp]\ntheorem comp_apply (g : shelf_hom S₂ S₃) (f : shelf_hom S₁ S₂) (x : S₁) : (g.comp f) x = g (f x) :=\n  rfl\n#align comp_apply comp_apply\n\n",
 "assoc_iff_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/-- Associative racks are uninteresting.\n-/\ntheorem assoc_iff_id {R : Type _} [Rack R] {x y z : R} :\n    shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z ↔ shelf.act x z = z :=\n  by\n  rw [self_distrib]\n  rw [left_cancel]\n#align assoc_iff_id assoc_iff_id\n\n",
 "assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/-- The associativity of a unital shelf comes for free.\n-/\ntheorem assoc (x y z : S) : shelf.act (shelf.act x y) z = shelf.act x (shelf.act y z) := by\n  rw [self_distrib, self_distrib, act_act_self_eq, act_self_act_eq]\n#align assoc assoc\n\n",
 "ad_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/-- The *adjoint action* of a rack on itself is `op'`, and the adjoint\naction of `x ◃ y` is the conjugate of the action of `y` by the action\nof `x`. It is another way to understand the self-distributivity axiom.\n\nThis is used in the natural rack homomorphism `to_conj` from `R` to\n`conj (R ≃ R)` defined by `op'`.\n-/\ntheorem ad_conj {R : Type _} [Rack R] (x y : R) : act' (shelf.act x y) = act' x * act' y * (act' x)⁻¹ :=\n  by\n  rw [eq_mul_inv_iff_mul_eq]; ext z\n  apply self_distrib.symm\n#align ad_conj ad_conj\n\n",
 "act_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n@[simp]\ntheorem act_symm_apply (x y : R) : (act' x).symm y = rack.inv_act x y :=\n  rfl\n#align act_symm_apply act_symm_apply\n\n",
 "act_self_act_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\ntheorem act_self_act_eq (x y : S) : shelf.act x (shelf.act x y) = shelf.act x y :=\n  by\n  have h : shelf.act x (shelf.act x y) = shelf.act (shelf.act x 1) (shelf.act x y) := by rw [act_one]\n  rw [h, ← shelf.self_distrib, one_act]\n#align act_self_act_eq act_self_act_eq\n\n",
 "act_inv_act_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rack.inv_act -/\n@[simp]\ntheorem act_inv_act_eq (x y : R) : shelf.act x (rack.inv_act x y) = y :=\n  right_inv x y\n#align act_inv_act_eq act_inv_act_eq\n\n",
 "act_idem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\ntheorem act_idem (x : S) : shelf.act x x = x := by rw [← act_one x, ← shelf.self_distrib, act_one, act_one]\n#align act_idem act_idem\n\n",
 "act_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n@[simp]\ntheorem act_apply (x y : R) : act' x y = shelf.act x y :=\n  rfl\n#align act_apply act_apply\n\n",
 "act_act_self_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `shelf.act -/\n/-\nCopyright (c) 2020 Kyle Miller. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kyle Miller\n-/\n/-- A monoid is *graphic* if, for all `x` and `y`, the *graphic identity*\n`(x * y) * x = x * y` holds.  For a unital shelf, this graphic\nidentity holds.\n-/\ntheorem act_act_self_eq (x y : S) : shelf.act (shelf.act x y) x = shelf.act x y :=\n  by\n  have h : shelf.act (shelf.act x y) x = shelf.act (shelf.act x y) (shelf.act x 1) := by rw [act_one]\n  rw [h, ← shelf.self_distrib, act_one]\n#align act_act_self_eq act_act_self_eq\n\n"}