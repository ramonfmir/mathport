{"symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print symm /-\n/-- Swap the direction of a `ring_hom_inv_pair`. This is not an instance as it would loop, and better\ninstances are often available and may often be preferrable to using this one. Indeed, this\ndeclaration is not currently used in mathlib.\n\nSee note [reducible non-instances].\n-/\n@[reducible]\ntheorem symm (σ₁₂ : «expr →+* » R₁ R₂) (σ₂₁ : «expr →+* » R₂ R₁) [RingHomInvPair σ₁₂ σ₂₁] : RingHomInvPair σ₂₁ σ₁₂ :=\n  ⟨ring_hom_inv_pair.comp_eq₂, ring_hom_inv_pair.comp_eq⟩\n#align symm symm\n-/\n\n",
 "surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print RingHom.surjective /-\ntheorem RingHom.surjective (σ : «expr →+* » R₁ R₂) [t : RingHomSurjective σ] : function.surjective σ :=\n  t.is_surjective\n#align ring_hom.is_surjective RingHom.surjective\n-/\n\n",
 "of_ring_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- Construct a `ring_hom_inv_pair` from both directions of a ring equiv.\n\nThis is not an instance, as for equivalences that are involutions, a better instance\nwould be `ring_hom_inv_pair e e`. Indeed, this declaration is not currently used in mathlib.\n\nSee note [reducible non-instances].\n-/\n@[reducible]\ntheorem of_ring_equiv (e : «expr ≃+* » R₁ R₂) : RingHomInvPair (↑e : «expr →+* » R₁ R₂) ↑e.symm :=\n  ⟨e.symm_to_ring_hom_comp_to_ring_hom, e.symm.symm_to_ring_hom_comp_to_ring_hom⟩\n#align of_ring_equiv of_ring_equiv\n\n",
 "comp_apply_eq₂":
 "@[simp]\ntheorem comp_apply_eq₂ {x : R₂} : σ (σ' x) = x :=\n  by\n  rw [← RingHom.comp_apply, comp_eq₂]\n  simp\n#align comp_apply_eq₂ comp_apply_eq₂\n\n",
 "comp_apply_eq":
 "@[simp]\ntheorem comp_apply_eq {x : R₁} : σ' (σ x) = x :=\n  by\n  rw [← RingHom.comp_apply, comp_eq]\n  simp\n#align comp_apply_eq comp_apply_eq\n\n",
 "comp_apply":
 "/-\nCopyright (c) 2021 Frédéric Dupuis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Frédéric Dupuis, Heather Macbeth\n-/\n@[simp]\ntheorem comp_apply [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] {x : R₁} : σ₂₃ (σ₁₂ x) = σ₁₃ x :=\n  RingHom.congr_fun comp_eq x\n#align comp_apply comp_apply\n\n",
 "comp":
 "-- The linter gives a false positive, since `σ₂` is an out_param\n/-- This cannot be an instance as there is no way to infer `σ₁₂` and `σ₂₃`. -/\ntheorem comp [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] [RingHomSurjective σ₁₂] [RingHomSurjective σ₂₃] : RingHomSurjective σ₁₃ :=\n  {\n    is_surjective := by\n      have := σ₂₃.is_surjective.comp σ₁₂.is_surjective\n      rwa [← RingHom.coe_comp, ring_hom_comp_triple.comp_eq] at this }\n#align comp comp\n\n"}