{"two_ne_zero":
 "/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\n@[protected]\ntheorem ring.two_ne_zero {R : Type _} [NonAssocSemiring R] [nontrivial R] (hR : ring_char R ≠ 2) : (2 : R) ≠ 0 :=\n  by\n  rw [ne.def, (by norm_cast : (2 : R) = (2 : ℕ)), ring_char.spec, Nat.dvd_prime Nat.prime_two]\n  exact mt (or_iff_left hR).mp char_p.ring_char_ne_one\n#align ring.two_ne_zero ring.two_ne_zero\n\n",
 "sum_pow_char":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_pow_char {ι : Type _} (s : Finset ι) (f : ι → R) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i) ^ p =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i ^ p) :=\n  (frobenius R p).map_sum _ _\n#align sum_pow_char sum_pow_char\n\n",
 "sub_pow_char_pow_of_commute":
 "theorem sub_pow_char_pow_of_commute [Ring R] {p : ℕ} [fact p.prime] [char_p R p] {n : ℕ} (x y : R) (h : Commute x y) :\n    (x - y) ^ p ^ n = x ^ p ^ n - y ^ p ^ n := by\n  induction n; · simp\n  rw [pow_succ', pow_mul, pow_mul, pow_mul, n_ih]\n  apply sub_pow_char_of_commute; apply Commute.pow_pow h\n#align sub_pow_char_pow_of_commute sub_pow_char_pow_of_commute\n\n",
 "sub_pow_char_pow":
 "theorem sub_pow_char_pow [CommRing R] {p : ℕ} [fact p.prime] [char_p R p] {n : ℕ} (x y : R) :\n    (x - y) ^ p ^ n = x ^ p ^ n - y ^ p ^ n :=\n  sub_pow_char_pow_of_commute _ _ _ (Commute.all _ _)\n#align sub_pow_char_pow sub_pow_char_pow\n\n",
 "sub_pow_char_of_commute":
 "theorem sub_pow_char_of_commute [Ring R] {p : ℕ} [fact p.prime] [char_p R p] (x y : R) (h : Commute x y) :\n    (x - y) ^ p = x ^ p - y ^ p :=\n  by\n  rw [eq_sub_iff_add_eq, ← add_pow_char_of_commute _ _ _ (Commute.sub_left h rfl)]\n  simp; repeat' infer_instance\n#align sub_pow_char_of_commute sub_pow_char_of_commute\n\n",
 "sub_pow_char":
 "theorem sub_pow_char [CommRing R] {p : ℕ} [fact p.prime] [char_p R p] (x y : R) : (x - y) ^ p = x ^ p - y ^ p :=\n  sub_pow_char_of_commute _ _ _ (Commute.all _ _)\n#align sub_pow_char sub_pow_char\n\n",
 "spec":
 "theorem spec : ∀ x : ℕ, (x : R) = 0 ↔ ring_char R ∣ x := by\n  letI := (Classical.choose_spec (char_p.exists_unique R)).1 <;> unfold ring_char <;>\n    exact char_p.cast_eq_zero_iff R (ring_char R)\n#align spec spec\n\n",
 "ring_char_of_prime_eq_zero":
 "theorem ring_char_of_prime_eq_zero [nontrivial R] {p : ℕ} (hprime : Nat.Prime p) (hp0 : (p : R) = 0) :\n    ring_char R = p :=\n  or.resolve_left ((Nat.dvd_prime hprime).1 (ring_char.dvd hp0)) ring_char_ne_one\n#align ring_char_of_prime_eq_zero ring_char_of_prime_eq_zero\n\n",
 "ring_char_ne_zero_of_finite":
 "theorem ring_char_ne_zero_of_finite [Finite R] : ring_char R ≠ 0 :=\n  char_ne_zero_of_finite R (ring_char R)\n#align ring_char_ne_zero_of_finite ring_char_ne_zero_of_finite\n\n",
 "ring_char_ne_one":
 "theorem ring_char_ne_one [nontrivial R] : ring_char R ≠ 1 :=\n  by\n  intro h\n  apply zero_ne_one' R\n  symm\n  rw [← Nat.cast_one, ring_char.spec, h]\n#align ring_char_ne_one ring_char_ne_one\n\n",
 "pow_prime_pow_mul_eq_one_iff":
 "@[simp]\ntheorem pow_prime_pow_mul_eq_one_iff (p k m : ℕ) [fact p.prime] [char_p R p] (x : R) :\n    x ^ (p ^ k * m) = 1 ↔ x ^ m = 1 := by\n  induction' k with k hk\n  · rw [pow_zero, one_mul]\n  · refine' ⟨fun h => _, fun h => _⟩\n    · rw [pow_succ, mul_assoc, pow_mul', ← frobenius_def, ← frobenius_one p] at h\n      exact hk.1 (frobenius_inj R p h)\n    · rw [pow_mul', h, one_pow]\n#align pow_prime_pow_mul_eq_one_iff pow_prime_pow_mul_eq_one_iff\n\n",
 "of_not_dvd":
 "theorem of_not_dvd [char_p R p] (h : ¬p ∣ n) : ne_zero (n : R) :=\n  ⟨(char_p.cast_eq_zero_iff R p n).not.mpr h⟩\n#align of_not_dvd of_not_dvd\n\n",
 "of_eq":
 "#print of_eq /-\ntheorem of_eq {p : ℕ} (h : ring_char R = p) : char_p R p :=\n  char_p.congr (ring_char R) h\n#align of_eq of_eq\n-/\n\n",
 "not_char_dvd":
 "theorem not_char_dvd (p : ℕ) [char_p R p] (k : ℕ) [h : ne_zero (k : R)] : ¬p ∣ k := by\n  rwa [← char_p.cast_eq_zero_iff R p k, ← ne.def, ← neZero_iff]\n#align not_char_dvd not_char_dvd\n\n",
 "nontrivial_of_char_ne_one":
 "theorem nontrivial_of_char_ne_one {v : ℕ} (hv : v ≠ 1) [hr : char_p R v] : nontrivial R :=\n  ⟨⟨(1 : ℕ), 0, fun h => hv <| by rwa [char_p.cast_eq_zero_iff _ v, Nat.dvd_one] at h <;> assumption⟩⟩\n#align nontrivial_of_char_ne_one nontrivial_of_char_ne_one\n\n",
 "neg_one_pow_char_pow":
 "theorem char_p.neg_one_pow_char_pow [CommRing R] (p n : ℕ) [char_p R p] [fact p.prime] : (-1 : R) ^ p ^ n = -1 :=\n  by\n  rw [eq_neg_iff_add_eq_zero]\n  nth_rw 2 [← one_pow (p ^ n)]\n  rw [← add_pow_char_pow, add_left_neg, zero_pow (pow_pos (fact.out (Nat.Prime p)).pos _)]\n#align char_p.neg_one_pow_char_pow char_p.neg_one_pow_char_pow\n\n",
 "neg_one_pow_char":
 "theorem char_p.neg_one_pow_char [CommRing R] (p : ℕ) [char_p R p] [fact p.prime] : (-1 : R) ^ p = -1 :=\n  by\n  rw [eq_neg_iff_add_eq_zero]\n  nth_rw 2 [← one_pow p]\n  rw [← add_pow_char, add_left_neg, zero_pow (fact.out (Nat.Prime p)).pos]\n#align char_p.neg_one_pow_char char_p.neg_one_pow_char\n\n",
 "neg_one_ne_one_of_char_ne_two":
 "-- We have `char_p.neg_one_ne_one`, which assumes `[ring R] (p : ℕ) [char_p R p] [fact (2 < p)]`.\n-- This is a version using `ring_char` instead.\n/-- Characteristic `≠ 2` and nontrivial implies that `-1 ≠ 1`. -/\ntheorem ring.neg_one_ne_one_of_char_ne_two {R : Type _} [NonAssocRing R] [nontrivial R] (hR : ring_char R ≠ 2) :\n    (-1 : R) ≠ 1 := fun h => ring.two_ne_zero hR (neg_eq_iff_add_eq_zero.mp h)\n#align ring.neg_one_ne_one_of_char_ne_two ring.neg_one_ne_one_of_char_ne_two\n\n",
 "neg_one_ne_one":
 "theorem char_p.neg_one_ne_one [Ring R] (p : ℕ) [char_p R p] [fact (2 < p)] : (-1 : R) ≠ (1 : R) :=\n  by\n  suffices (2 : R) ≠ 0 by\n    symm\n    rw [ne.def, ← sub_eq_zero, sub_neg_eq_add]\n    exact this\n  intro h\n  rw [show (2 : R) = (2 : ℕ) by norm_cast] at h\n  have := (char_p.cast_eq_zero_iff R p 2).mp h\n  have := nat.le_of_dvd (by decide) this\n  rw [fact_iff] at *\n  linarith\n#align char_p.neg_one_ne_one char_p.neg_one_ne_one\n\n",
 "multiset_sum_pow_char":
 "theorem multiset_sum_pow_char (s : Multiset R) : s.sum ^ p = (s.map (· ^ p)).sum :=\n  (frobenius R p).map_multiset_sum _\n#align multiset_sum_pow_char multiset_sum_pow_char\n\n",
 "map_iterate_frobenius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem ring_hom.map_iterate_frobenius (n : ℕ) :\n    g ((«expr ^[ ]» (frobenius R p) n) x) = («expr ^[ ]» (frobenius S p) n) (g x) :=\n  g.to_monoid_hom.map_iterate_frobenius p x n\n#align ring_hom.map_iterate_frobenius ring_hom.map_iterate_frobenius\n\n",
 "map_frobenius":
 "theorem ring_hom.map_frobenius : g (frobenius R p x) = frobenius S p (g x) :=\n  g.map_pow x p\n#align ring_hom.map_frobenius ring_hom.map_frobenius\n\n",
 "list_sum_pow_char":
 "theorem list_sum_pow_char (l : list R) : l.sum ^ p = (l.map (· ^ p)).sum :=\n  (frobenius R p).map_list_sum _\n#align list_sum_pow_char list_sum_pow_char\n\n",
 "iterate_map_frobenius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem ring_hom.iterate_map_frobenius (f : «expr →+* » R R) (p : ℕ) [fact p.prime] [char_p R p] (n : ℕ) :\n    («expr ^[ ]» f n) (frobenius R p x) = frobenius R p ((«expr ^[ ]» f n) x) :=\n  f.iterate_map_pow _ _ _\n#align ring_hom.iterate_map_frobenius ring_hom.iterate_map_frobenius\n\n",
 "iterate_frobenius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_frobenius (n : ℕ) : («expr ^[ ]» (frobenius R p) n) x = x ^ p ^ n :=\n  by\n  induction n; · simp\n  rw [function.iterate_succ', pow_succ', pow_mul, function.comp_apply, frobenius_def, n_ih]\n#align iterate_frobenius iterate_frobenius\n\n",
 "is_square_of_char_two'":
 "/-- If `ring_char R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. -/\ntheorem is_square_of_char_two' {R : Type _} [Finite R] [CommRing R] [is_reduced R] [char_p R 2] (a : R) : IsSquare a :=\n  by\n  cases nonempty_fintype R\n  exact\n    Exists.imp (fun b h => pow_two b ▸ eq.symm h)\n      (((fintype.bijective_iff_injective_and_card _).mpr ⟨frobenius_inj R 2, rfl⟩).surjective a)\n#align is_square_of_char_two' is_square_of_char_two'\n\n",
 "int_coe_eq_int_coe_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [ZMOD ]» -/\ntheorem char_p.int_coe_eq_int_coe_iff [AddGroupWithOne R] (p : ℕ) [char_p R p] (a b : ℤ) :\n    (a : R) = (b : R) ↔ «expr ≡ [ZMOD ]» a b p := by\n  rw [eq_comm, ← sub_eq_zero, ← Int.cast_sub, char_p.int_cast_eq_zero_iff R p, Int.modEq_iff_dvd]\n#align char_p.int_coe_eq_int_coe_iff char_p.int_coe_eq_int_coe_iff\n\n",
 "int_cast_eq_zero_iff":
 "theorem char_p.int_cast_eq_zero_iff [AddGroupWithOne R] (p : ℕ) [char_p R p] (a : ℤ) : (a : R) = 0 ↔ (p : ℤ) ∣ a :=\n  by\n  rcases lt_trichotomy a 0 with (h | rfl | h)\n  · rw [← neg_eq_zero, ← Int.cast_neg, ← dvd_neg]\n    lift -a to ℕ using neg_nonneg.mpr (le_of_lt h) with b\n    rw [Int.cast_ofNat, char_p.cast_eq_zero_iff R p, Int.coe_nat_dvd]\n  · simp only [Int.cast_zero, eq_self_iff_true, dvd_zero]\n  · lift a to ℕ using le_of_lt h with b\n    rw [Int.cast_ofNat, char_p.cast_eq_zero_iff R p, Int.coe_nat_dvd]\n#align char_p.int_cast_eq_zero_iff char_p.int_cast_eq_zero_iff\n\n",
 "frobenius_zero":
 "theorem frobenius_zero : frobenius R p 0 = 0 :=\n  (frobenius R p).map_zero\n#align frobenius_zero frobenius_zero\n\n",
 "frobenius_sub":
 "theorem frobenius_sub : frobenius R p (x - y) = frobenius R p x - frobenius R p y :=\n  (frobenius R p).map_sub x y\n#align frobenius_sub frobenius_sub\n\n",
 "frobenius_one":
 "theorem frobenius_one : frobenius R p 1 = 1 :=\n  one_pow _\n#align frobenius_one frobenius_one\n\n",
 "frobenius_neg":
 "theorem frobenius_neg : frobenius R p (-x) = -frobenius R p x :=\n  (frobenius R p).map_neg x\n#align frobenius_neg frobenius_neg\n\n",
 "frobenius_nat_cast":
 "theorem frobenius_nat_cast (n : ℕ) : frobenius R p n = n :=\n  map_nat_cast (frobenius R p) n\n#align frobenius_nat_cast frobenius_nat_cast\n\n",
 "frobenius_mul":
 "theorem frobenius_mul : frobenius R p (x * y) = frobenius R p x * frobenius R p y :=\n  (frobenius R p).map_mul x y\n#align frobenius_mul frobenius_mul\n\n",
 "frobenius_inj":
 "theorem frobenius_inj [CommRing R] [is_reduced R] (p : ℕ) [fact p.prime] [char_p R p] :\n    function.injective (frobenius R p) := fun x h H =>\n  by\n  rw [← sub_eq_zero] at H⊢\n  rw [← frobenius_sub] at H\n  exact is_reduced.eq_zero _ ⟨_, H⟩\n#align frobenius_inj frobenius_inj\n\n",
 "frobenius_def":
 "theorem frobenius_def : frobenius R p x = x ^ p :=\n  rfl\n#align frobenius_def frobenius_def\n\n",
 "frobenius_add":
 "theorem frobenius_add : frobenius R p (x + y) = frobenius R p x + frobenius R p y :=\n  (frobenius R p).map_add x y\n#align frobenius_add frobenius_add\n\n",
 "false_of_nontrivial_of_char_one":
 "-- see Note [lower instance priority]\ntheorem false_of_nontrivial_of_char_one [nontrivial R] [char_p R 1] : false :=\n  false_of_nontrivial_of_subsingleton R\n#align false_of_nontrivial_of_char_one false_of_nontrivial_of_char_one\n\n",
 "exists_unique":
 "theorem char_p.exists_unique [NonAssocSemiring R] : ∃! p, char_p R p :=\n  let ⟨c, H⟩ := char_p.exists R\n  ⟨c, H, fun y H2 => char_p.eq R H2 H⟩\n#align char_p.exists_unique char_p.exists_unique\n\n",
 "exists":
 "theorem char_p.exists [NonAssocSemiring R] : ∃ p, char_p R p :=\n  letI := classical.dec_eq R\n  by_cases\n    (fun H : ∀ p : ℕ, (p : R) = 0 → p = 0 =>\n      ⟨0, ⟨fun x => by rw [zero_dvd_iff] <;> exact ⟨H x, by rintro rfl <;> simp⟩⟩⟩)\n    fun H =>\n    ⟨nat.find (not_forall.1 H),\n      ⟨fun x =>\n        ⟨fun H1 =>\n          nat.dvd_of_mod_eq_zero\n            (by_contradiction fun H2 =>\n              nat.find_min (not_forall.1 H)\n                (nat.mod_lt x <| nat.pos_of_ne_zero <| not_of_not_imp <| nat.find_spec (not_forall.1 H))\n                (not_imp_of_and_not\n                  ⟨by\n                    rwa [← nat.mod_add_div x (nat.find (not_forall.1 H)), Nat.cast_add, nat.cast_mul,\n                      of_not_not (not_not_of_not_imp <| nat.find_spec (not_forall.1 H)), zero_mul, add_zero] at H1,\n                    H2⟩)),\n          fun H1 => by\n          rw [← Nat.mul_div_cancel' H1, nat.cast_mul, of_not_not (not_not_of_not_imp <| nat.find_spec (not_forall.1 H)),\n            zero_mul]⟩⟩⟩\n#align char_p.exists char_p.exists\n\n",
 "eq_zero":
 "@[simp]\ntheorem eq_zero [CharZero R] : ring_char R = 0 :=\n  eq R 0\n#align eq_zero eq_zero\n\n",
 "eq_self_iff_eq_zero_of_char_ne_two":
 "/-- Characteristic `≠ 2` in a domain implies that `-a = a` iff `a = 0`. -/\ntheorem ring.eq_self_iff_eq_zero_of_char_ne_two {R : Type _} [NonAssocRing R] [nontrivial R] [no_zero_divisors R]\n    (hR : ring_char R ≠ 2) {a : R} : -a = a ↔ a = 0 :=\n  ⟨fun h => (mul_eq_zero.mp <| (two_mul a).trans <| neg_eq_iff_add_eq_zero.mp h).resolve_left (ring.two_ne_zero hR),\n    fun h => ((congr_arg (fun x => -x) h).trans neg_zero).trans h.symm⟩\n#align ring.eq_self_iff_eq_zero_of_char_ne_two ring.eq_self_iff_eq_zero_of_char_ne_two\n\n",
 "eq_iff_modeq_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [ZMOD ]» -/\ntheorem eq_iff_modeq_int [Ring R] (p : ℕ) [char_p R p] (a b : ℤ) : (a : R) = b ↔ «expr ≡ [ZMOD ]» a b p := by\n  rw [eq_comm, ← sub_eq_zero, ← Int.cast_sub, char_p.int_cast_eq_zero_iff R p, Int.modEq_iff_dvd]\n#align eq_iff_modeq_int eq_iff_modeq_int\n\n",
 "eq_iff":
 "theorem eq_iff {p : ℕ} : ring_char R = p ↔ char_p R p :=\n  ⟨of_eq, @eq R _ p⟩\n#align eq_iff eq_iff\n\n",
 "eq":
 "theorem eq (p : ℕ) [C : char_p R p] : ring_char R = p :=\n  ((Classical.choose_spec (char_p.exists_unique R)).2 p C).symm\n#align eq eq\n\n",
 "dvd":
 "theorem dvd {x : ℕ} (hx : (x : R) = 0) : ring_char R ∣ x :=\n  (spec R x).1 hx\n#align dvd dvd\n\n",
 "congr":
 "theorem char_p.congr {R : Type u} [AddMonoidWithOne R] {p : ℕ} (q : ℕ) [hq : char_p R q] (h : q = p) : char_p R p :=\n  h ▸ hq\n#align char_p.congr char_p.congr\n\n",
 "char_p_to_char_zero":
 "theorem char_p_to_char_zero (R : Type _) [AddGroupWithOne R] [char_p R 0] : CharZero R :=\n  charZero_of_inj_zero fun n h0 => eq_zero_of_zero_dvd ((cast_eq_zero_iff R 0 n).mp h0)\n#align char_p_to_char_zero char_p_to_char_zero\n\n",
 "char_p_of_prime_pow_injective":
 "theorem char_p_of_prime_pow_injective (R) [Ring R] [fintype R] (p : ℕ) [hp : fact p.prime] (n : ℕ)\n    (hn : fintype.card R = p ^ n) (hR : ∀ i ≤ n, (p ^ i : R) = 0 → i = n) : char_p R (p ^ n) :=\n  by\n  obtain ⟨c, hc⟩ := char_p.exists R\n  skip\n  have hcpn : c ∣ p ^ n := by rw [← char_p.cast_eq_zero_iff R c, ← hn, char_p.cast_card_eq_zero]\n  obtain ⟨i, hi, hc⟩ : ∃ i ≤ n, c = p ^ i := by rwa [Nat.dvd_prime_pow hp.1] at hcpn\n  obtain rfl : i = n := by\n    apply hR i hi\n    rw [← Nat.cast_pow, ← hc, char_p.cast_eq_zero]\n  rwa [← hc]\n#align char_p_of_prime_pow_injective char_p_of_prime_pow_injective\n\n",
 "char_p_of_ne_zero":
 "theorem char_p_of_ne_zero (hn : fintype.card R = n) (hR : ∀ i < n, (i : R) = 0 → i = 0) : char_p R n :=\n  {\n    cast_eq_zero_iff := by\n      have H : (n : R) = 0 := by rw [← hn, char_p.cast_card_eq_zero]\n      intro k\n      constructor\n      · intro h\n        rw [← nat.mod_add_div k n, Nat.cast_add, nat.cast_mul, H, zero_mul, add_zero] at h\n        rw [nat.dvd_iff_mod_eq_zero]\n        apply hR _ (nat.mod_lt _ _) h\n        rw [← hn, fintype.card_pos_iff]\n        exact ⟨0⟩\n      · rintro ⟨k, rfl⟩\n        rw [nat.cast_mul, H, zero_mul] }\n#align char_p_of_ne_zero char_p_of_ne_zero\n\n",
 "char_p_iff_char_p":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem ring_hom.char_p_iff_char_p {K L : Type _} [DivisionRing K] [Semiring L] [nontrivial L] (f : «expr →+* » K L)\n    (p : ℕ) : char_p K p ↔ char_p L p := by simp only [char_p_iff, ← f.injective.eq_iff, map_nat_cast f, f.map_zero]\n#align ring_hom.char_p_iff_char_p ring_hom.char_p_iff_char_p\n\n",
 "char_ne_zero_of_finite":
 "/-- The characteristic of a finite ring cannot be zero. -/\ntheorem char_ne_zero_of_finite (p : ℕ) [char_p R p] [Finite R] : p ≠ 0 :=\n  by\n  rintro rfl\n  haveI : CharZero R := char_p_to_char_zero R\n  cases nonempty_fintype R\n  exact absurd Nat.cast_injective (not_injective_infinite_finite (coe : ℕ → R))\n#align char_ne_zero_of_finite char_ne_zero_of_finite\n\n",
 "char_ne_one":
 "theorem char_ne_one [nontrivial R] (p : ℕ) [hc : char_p R p] : p ≠ 1 := fun hp : p = 1 =>\n  have : (1 : R) = 0 := by simpa using (cast_eq_zero_iff R p 1).mpr (hp ▸ dvd_refl p)\n  absurd this one_ne_zero\n#align char_ne_one char_ne_one\n\n",
 "char_is_prime_or_zero":
 "theorem char_is_prime_or_zero (p : ℕ) [hc : char_p R p] : Nat.Prime p ∨ p = 0 :=\n  match p, hc with\n  | 0, _ => or.inr rfl\n  | 1, hc => absurd (eq.refl (1 : ℕ)) (@char_ne_one R _ _ (1 : ℕ) hc)\n  | m + 2, hc => or.inl (@char_is_prime_of_two_le R _ _ (m + 2) hc (nat.le_add_left 2 m))\n#align char_is_prime_or_zero char_is_prime_or_zero\n\n",
 "char_is_prime_of_two_le":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (d «expr ∣ » p) -/\ntheorem char_is_prime_of_two_le (p : ℕ) [hc : char_p R p] (hp : 2 ≤ p) : Nat.Prime p :=\n  suffices ∀ (d) (_ : d ∣ p), d = 1 ∨ d = p from Nat.prime_def_lt''.mpr ⟨hp, this⟩\n  fun (d : ℕ) (hdvd : ∃ e, p = d * e) =>\n  let ⟨e, hmul⟩ := hdvd\n  have : (p : R) = 0 := (cast_eq_zero_iff R p p).mpr (dvd_refl p)\n  have : (d : R) * e = 0 := @cast_mul R _ d e ▸ hmul ▸ this\n  or.elim (eq_zero_or_eq_zero_of_mul_eq_zero this)\n    (fun hd : (d : R) = 0 =>\n      have : p ∣ d := (cast_eq_zero_iff R p d).mp hd\n      show d = 1 ∨ d = p from or.inr (dvd_antisymm ⟨e, hmul⟩ this))\n    fun he : (e : R) = 0 =>\n    have : p ∣ e := (cast_eq_zero_iff R p e).mp he\n    have : e ∣ p := dvd_of_mul_left_eq d (eq.symm hmul)\n    have : e = p := dvd_antisymm ‹e ∣ p› ‹p ∣ e›\n    have h₀ : 0 < p := two_pos.trans_le hp\n    have : d * p = 1 * p := by rw [‹e = p›] at hmul <;> rw [one_mul] <;> exact eq.symm hmul\n    show d = 1 ∨ d = p from or.inl (mul_right_cancel₀ h₀.ne' this)\n#align char_is_prime_of_two_le char_is_prime_of_two_le\n\n",
 "char_is_prime_of_pos":
 "theorem char_is_prime_of_pos (p : ℕ) [ne_zero p] [char_p R p] : fact p.prime :=\n  ⟨(char_p.char_is_prime_or_zero R _).resolve_right <| ne_zero.ne p⟩\n#align char_is_prime_of_pos char_is_prime_of_pos\n\n",
 "char_is_prime":
 "theorem char_is_prime (p : ℕ) [char_p R p] : p.prime :=\n  or.resolve_right (char_is_prime_or_zero R p) (char_ne_zero_of_finite R p)\n#align char_is_prime char_is_prime\n\n",
 "cast_ring_char":
 "@[simp]\ntheorem nat.cast_ring_char : (ring_char R : R) = 0 := by rw [ring_char.spec]\n#align nat.cast_ring_char nat.cast_ring_char\n\n",
 "cast_inj_on_of_ring_char_ne_two":
 "/-- If two integers from `{0, 1, -1}` result in equal elements in a ring `R`\nthat is nontrivial and of characteristic not `2`, then they are equal. -/\ntheorem int.cast_inj_on_of_ring_char_ne_two {R : Type _} [NonAssocRing R] [nontrivial R] (hR : ring_char R ≠ 2) :\n    ({0, 1, -1} : set ℤ).inj_on (coe : ℤ → R) := by\n  intro a ha b hb h\n  apply eq_of_sub_eq_zero\n  by_contra hf\n  change a = 0 ∨ a = 1 ∨ a = -1 at ha\n  change b = 0 ∨ b = 1 ∨ b = -1 at hb\n  have hh : a - b = 1 ∨ b - a = 1 ∨ a - b = 2 ∨ b - a = 2 :=\n    by\n    rcases ha with (ha | ha | ha) <;> rcases hb with (hb | hb | hb)\n    pick_goal 5\n    pick_goal 9\n    -- move goals with `a = b` to the front\n    iterate 3 rw [ha, hb, sub_self] at hf; tauto\n    -- 6 goals remain\n    all_goals rw [ha, hb]; norm_num\n  have h' : ((a - b : ℤ) : R) = 0 := by exact_mod_cast sub_eq_zero_of_eq h\n  have h'' : ((b - a : ℤ) : R) = 0 := by exact_mod_cast sub_eq_zero_of_eq h.symm\n  rcases hh with (hh | hh | hh | hh)\n  · rw [hh, (by norm_cast : ((1 : ℤ) : R) = 1)] at h'\n    exact one_ne_zero h'\n  · rw [hh, (by norm_cast : ((1 : ℤ) : R) = 1)] at h''\n    exact one_ne_zero h''\n  · rw [hh, (by norm_cast : ((2 : ℤ) : R) = 2)] at h'\n    exact ring.two_ne_zero hR h'\n  · rw [hh, (by norm_cast : ((2 : ℤ) : R) = 2)] at h''\n    exact ring.two_ne_zero hR h''\n#align int.cast_inj_on_of_ring_char_ne_two int.cast_inj_on_of_ring_char_ne_two\n\n",
 "cast_eq_zero":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Joey van Langen, Casper Putz\n-/\ntheorem char_p.cast_eq_zero [AddMonoidWithOne R] (p : ℕ) [char_p R p] : (p : R) = 0 :=\n  (char_p.cast_eq_zero_iff R p p).2 (dvd_refl p)\n#align char_p.cast_eq_zero char_p.cast_eq_zero\n\n",
 "cast_eq_mod":
 "theorem cast_eq_mod (p : ℕ) [char_p R p] (k : ℕ) : (k : R) = (k % p : ℕ) :=\n  calc\n    (k : R) = ↑(k % p + p * (k / p)) := by rw [nat.mod_add_div]\n    _ = ↑(k % p) := by simp [cast_eq_zero]\n    \n#align cast_eq_mod cast_eq_mod\n\n",
 "cast_card_eq_zero":
 "@[simp]\ntheorem char_p.cast_card_eq_zero [AddGroupWithOne R] [fintype R] : (fintype.card R : R) = 0 := by\n  rw [← nsmul_one, card_nsmul_eq_zero]\n#align char_p.cast_card_eq_zero char_p.cast_card_eq_zero\n\n",
 "add_pow_char_pow_of_commute":
 "theorem add_pow_char_pow_of_commute [Semiring R] {p : ℕ} [fact p.prime] [char_p R p] {n : ℕ} (x y : R)\n    (h : Commute x y) : (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n :=\n  by\n  induction n; · simp\n  rw [pow_succ', pow_mul, pow_mul, pow_mul, n_ih]\n  apply add_pow_char_of_commute; apply Commute.pow_pow h\n#align add_pow_char_pow_of_commute add_pow_char_pow_of_commute\n\n",
 "add_pow_char_pow":
 "theorem add_pow_char_pow [CommSemiring R] {p : ℕ} [fact p.prime] [char_p R p] {n : ℕ} (x y : R) :\n    (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n :=\n  add_pow_char_pow_of_commute _ _ _ (Commute.all _ _)\n#align add_pow_char_pow add_pow_char_pow\n\n",
 "add_pow_char_of_commute":
 "theorem add_pow_char_of_commute [Semiring R] {p : ℕ} [fact p.prime] [char_p R p] (x y : R) (h : Commute x y) :\n    (x + y) ^ p = x ^ p + y ^ p :=\n  by\n  rw [commute.add_pow h, finset.sum_range_succ_comm, tsub_self, pow_zero, Nat.choose_self]\n  rw [Nat.cast_one, mul_one, mul_one]; congr 1\n  convert finset.sum_eq_single 0 _ _\n  · simp only [mul_one, one_mul, Nat.choose_zero_right, tsub_zero, Nat.cast_one, pow_zero]\n  · intro b h1 h2\n    suffices (p.choose b : R) = 0 by\n      rw [this]\n      simp\n    rw [char_p.cast_eq_zero_iff R p]\n    refine' Nat.Prime.dvd_choose_self (pos_iff_ne_zero.mpr h2) _ (fact.out _)\n    rwa [← Finset.mem_range]\n  · intro h1\n    contrapose! h1\n    rw [Finset.mem_range]\n    exact Nat.Prime.pos (fact.out _)\n#align add_pow_char_of_commute add_pow_char_of_commute\n\n",
 "add_pow_char":
 "theorem add_pow_char [CommSemiring R] {p : ℕ} [fact p.prime] [char_p R p] (x y : R) : (x + y) ^ p = x ^ p + y ^ p :=\n  add_pow_char_of_commute _ _ _ (Commute.all _ _)\n#align add_pow_char add_pow_char\n\n",
 "add_order_of_one":
 "theorem char_p.add_order_of_one (R) [Semiring R] : char_p R (add_order_of (1 : R)) :=\n  ⟨fun n => by rw [← Nat.smul_one_eq_coe, add_order_of_dvd_iff_nsmul_eq_zero]⟩\n#align char_p.add_order_of_one char_p.add_order_of_one\n\n"}