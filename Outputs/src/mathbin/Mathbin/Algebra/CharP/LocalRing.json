{"char_p_zero_or_prime_power":
 "/-\nCopyright (c) 2022 Jon Eugster. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jon Eugster\n-/\n/-- In a local ring the characteristics is either zero or a prime power. -/\ntheorem char_p_zero_or_prime_power (R : Type _) [CommRing R] [local_ring R] (q : ℕ) [char_R_q : CharP R q] :\n    q = 0 ∨ IsPrimePow q :=\n  by\n  -- Assume `q := char(R)` is not zero.\n  apply or_iff_not_imp_left.2\n  intro q_pos\n  let K := local_ring.residue_field R\n  haveI RM_char := ringChar.charP K\n  let r := ringChar K\n  let n := q.factorization r\n  -- `r := char(R/m)` is either prime or zero:\n  cases' CharP.char_is_prime_or_zero K r with r_prime r_zero\n  · let a := q / r ^ n\n    -- If `r` is prime, we can write it as `r = a * q^n` ...\n    have q_eq_a_mul_rn : q = r ^ n * a := by rw [Nat.mul_div_cancel' (Nat.ord_proj_dvd q r)]\n    have r_ne_dvd_a := Nat.not_dvd_ord_compl r_prime q_pos\n    have rn_dvd_q : r ^ n ∣ q := ⟨a, q_eq_a_mul_rn⟩\n    rw [mul_comm] at q_eq_a_mul_rn\n    have a_dvd_q : a ∣ q := ⟨r ^ n, q_eq_a_mul_rn⟩\n    -- ... where `a` is a unit.\n    have a_unit : IsUnit (a : R) := by\n      by_contra g\n      rw [← mem_nonunits_iff] at g\n      rw [← local_ring.mem_maximal_ideal] at g\n      have a_cast_zero := Ideal.Quotient.eq_zero_iff_mem.2 g\n      rw [map_natCast] at a_cast_zero\n      have r_dvd_a := (ringChar.spec K a).1 a_cast_zero\n      exact absurd r_dvd_a r_ne_dvd_a\n    -- Let `b` be the inverse of `a`.\n    cases' a_unit.exists_left_inv with a_inv h_inv_mul_a\n    have rn_cast_zero : ↑(r ^ n) = (0 : R) :=\n      by\n      rw [Nat.cast_pow, ← @mul_one R _ (r ^ n), mul_comm, ← Classical.choose_spec a_unit.exists_left_inv, mul_assoc, ←\n        Nat.cast_pow, ← Nat.cast_mul, ← q_eq_a_mul_rn, CharP.cast_eq_zero R q]\n      simp\n    have q_eq_rn := nat.dvd_antisymm ((char_p.cast_eq_zero_iff R q (r ^ n)).mp rn_cast_zero) rn_dvd_q\n    have n_pos : n ≠ 0 := fun n_zero => absurd (by simpa [n_zero] using q_eq_rn) (CharP.char_ne_one R q)\n    -- Definition of prime power: `∃ r n, prime r ∧ 0 < n ∧ r ^ n = q`.\n    exact ⟨r, ⟨n, ⟨r_prime.prime, ⟨pos_iff_ne_zero.mpr n_pos, q_eq_rn.symm⟩⟩⟩⟩\n  · haveI K_char_p_0 := ringChar.of_eq r_zero\n    haveI K_char_zero : CharZero K := CharP.charP_to_charZero K\n    haveI R_char_zero := RingHom.charZero (local_ring.residue R)\n    -- Finally, `r = 0` would lead to a contradiction:\n    have q_zero := CharP.eq R char_R_q (CharP.ofCharZero R)\n    exact absurd q_zero q_pos\n#align char_p_zero_or_prime_power char_p_zero_or_prime_power\n\n"}