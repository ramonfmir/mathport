{"ringChar_eq":
 "#print Algebra.ringChar_eq /-\ntheorem Algebra.ringChar_eq : ringChar K = ringChar L :=\n  by\n  rw [ringChar.eq_iff, Algebra.charP_iff K L]\n  apply ringChar.charP\n#align algebra.ring_char_eq Algebra.ringChar_eq\n-/\n\n",
 "char_zero_of_is_fraction_ring":
 "/-- If `R` has characteristic `0`, then so does Frac(R). -/\ntheorem char_zero_of_is_fraction_ring [CharZero R] : CharZero K :=\n  @CharP.charP_to_charZero K _ (charP_of_isFractionRing R 0)\n#align char_zero_of_is_fraction_ring char_zero_of_is_fraction_ring\n\n",
 "char_p_of_is_fraction_ring":
 "/-- If `R` has characteristic `p`, then so does Frac(R). -/\ntheorem char_p_of_is_fraction_ring [CharP R p] : CharP K p :=\n  charP_of_injective_algebraMap (IsFractionRing.injective R K) p\n#align char_p_of_is_fraction_ring char_p_of_is_fraction_ring\n\n",
 "charZero_of_injective_algebraMap":
 "#print charZero_of_injective_algebraMap /-\n/-- If the algebra map `R →+* A` is injective and `R` has characteristic zero then so does `A`. -/\ntheorem charZero_of_injective_algebraMap {R A : Type _} [CommSemiring R] [Semiring A] [Algebra R A]\n    (h : function.injective (algebraMap R A)) [CharZero R] : CharZero A :=\n  {\n    cast_injective := fun x y hxy => by\n      change algebraMap ℕ A x = algebraMap ℕ A y at hxy\n      rw [IsScalarTower.algebraMap_apply ℕ R A x] at hxy\n      rw [IsScalarTower.algebraMap_apply ℕ R A y] at hxy\n      exact char_zero.cast_injective (h hxy) }\n#align char_zero_of_injective_algebra_map charZero_of_injective_algebraMap\n-/\n\n",
 "charZero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print algebraRat.charZero /-\n/-- A nontrivial `ℚ`-algebra has characteristic zero.\n\nThis cannot be a (local) instance because it would immediately form a loop with the\ninstance `algebra_rat`. It's probably easier to go the other way: prove `char_zero R` and\nautomatically receive an `algebra ℚ R` instance.\n-/\ntheorem algebraRat.charZero [Ring R] [Algebra (exprℚ) R] : CharZero R :=\n  @CharP.charP_to_charZero R _ (algebraRat.charP_zero R)\n#align algebra_rat.char_zero algebraRat.charZero\n-/\n\n",
 "charP_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print algebraRat.charP_zero /-\n-- `char_p.char_p_to_char_zero A _ (char_p_of_injective_algebra_map h 0)` does not work\n-- here as it would require `ring A`.\n/-- A nontrivial `ℚ`-algebra has `char_p` equal to zero.\n\nThis cannot be a (local) instance because it would immediately form a loop with the\ninstance `algebra_rat`. It's probably easier to go the other way: prove `char_zero R` and\nautomatically receive an `algebra ℚ R` instance.\n-/\ntheorem algebraRat.charP_zero [Semiring R] [Algebra (exprℚ) R] : CharP R 0 :=\n  charP_of_injective_algebraMap (algebraMap (exprℚ) R).injective 0\n#align algebra_rat.char_p_zero algebraRat.charP_zero\n-/\n\n",
 "charP_of_injective_algebraMap'":
 "#print charP_of_injective_algebraMap' /-\ntheorem charP_of_injective_algebraMap' (R A : Type _) [Field R] [Semiring A] [Algebra R A] [Nontrivial A] (p : ℕ)\n    [CharP R p] : CharP A p :=\n  charP_of_injective_algebraMap (algebraMap R A).injective p\n#align char_p_of_injective_algebra_map' charP_of_injective_algebraMap'\n-/\n\n",
 "charP_of_injective_algebraMap":
 "#print charP_of_injective_algebraMap /-\n/-\nCopyright (c) 2021 Jon Eugster. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jon Eugster, Eric Wieser\n-/\n/-- If the algebra map `R →+* A` is injective then `A` has the same characteristic as `R`. -/\ntheorem charP_of_injective_algebraMap {R A : Type _} [CommSemiring R] [Semiring A] [Algebra R A]\n    (h : function.injective (algebraMap R A)) (p : ℕ) [CharP R p] : CharP A p :=\n  {\n    cast_eq_zero_iff := fun x => by\n      rw [← char_p.cast_eq_zero_iff R p x]\n      change algebraMap ℕ A x = 0 ↔ algebraMap ℕ R x = 0\n      rw [IsScalarTower.algebraMap_apply ℕ R A x]\n      refine' iff.trans _ h.eq_iff\n      rw [RingHom.map_zero] }\n#align char_p_of_injective_algebra_map charP_of_injective_algebraMap\n-/\n\n",
 "charP_iff":
 "#print Algebra.charP_iff /-\ntheorem Algebra.charP_iff (p : ℕ) : CharP K p ↔ CharP L p :=\n  (algebraMap K L).char_p_iff_char_p p\n#align algebra.char_p_iff Algebra.charP_iff\n-/\n\n"}