{"split_equal_mixed_char":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- Split a `Prop` in characteristic zero into equal and mixed characteristic.\n-/\ntheorem split_equal_mixed_char [CharZero R] (h_equal : algebra (exprℚ) R → P)\n    (h_mixed : ∀ p : ℕ, Nat.Prime p → mixed_char_zero R p → P) : P :=\n  by\n  by_cases h : ∃ p > 0, mixed_char_zero R p\n  · rcases h with ⟨p, ⟨H, hp⟩⟩\n    rw [← mixed_char_zero.reduce_to_p_prime] at h_mixed\n    exact h_mixed p H hp\n  · apply h_equal\n    rw [← not_Q_algebra_iff_not_equal_char_zero, not_isEmpty_iff] at h\n    exact h.some\n#align split_equal_mixed_char split_equal_mixed_char\n\n",
 "split_by_characteristic_local_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- In a `local_ring R`, split any `Prop` over `R` into the three cases:\n- *prime power* characteristic.\n- equal characteristic zero.\n- mixed characteristic `(0, p)`.\n-/\ntheorem split_by_characteristic_local_ring [local_ring R] (h_pos : ∀ p : ℕ, is_prime_pow p → char_p R p → P)\n    (h_equal : algebra (exprℚ) R → P) (h_mixed : ∀ p : ℕ, Nat.Prime p → mixed_char_zero R p → P) : P :=\n  by\n  refine' split_by_characteristic R _ h_equal h_mixed\n  intro p p_pos p_char\n  have p_ppow : is_prime_pow (p : ℕ) := or_iff_not_imp_left.mp (char_p_zero_or_prime_power R p) p_pos\n  exact h_pos p p_ppow p_char\n#align split_by_characteristic_local_ring split_by_characteristic_local_ring\n\n",
 "split_by_characteristic_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- In a `is_domain R`, split any `Prop` over `R` into the three cases:\n- *prime* characteristic.\n- equal characteristic zero.\n- mixed characteristic `(0, p)`.\n-/\ntheorem split_by_characteristic_domain [IsDomain R] (h_pos : ∀ p : ℕ, Nat.Prime p → char_p R p → P)\n    (h_equal : algebra (exprℚ) R → P) (h_mixed : ∀ p : ℕ, Nat.Prime p → mixed_char_zero R p → P) : P :=\n  by\n  refine' split_by_characteristic R _ h_equal h_mixed\n  intro p p_pos p_char\n  have p_prime : Nat.Prime p := or_iff_not_imp_right.mp (char_p.char_is_prime_or_zero R p) p_pos\n  exact h_pos p p_prime p_char\n#align split_by_characteristic_domain split_by_characteristic_domain\n\n",
 "split_by_characteristic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- Split any `Prop` over `R` into the three cases:\n- positive characteristic.\n- equal characteristic zero.\n- mixed characteristic `(0, p)`.\n-/\ntheorem split_by_characteristic (h_pos : ∀ p : ℕ, p ≠ 0 → char_p R p → P) (h_equal : algebra (exprℚ) R → P)\n    (h_mixed : ∀ p : ℕ, Nat.Prime p → mixed_char_zero R p → P) : P :=\n  by\n  cases' char_p.exists R with p p_char\n  by_cases p = 0\n  · rw [h] at p_char\n    skip\n    -- make `p_char : char_p R 0` an instance.\n    haveI h0 : CharZero R := char_p.char_p_to_char_zero R\n    exact split_equal_mixed_char R h_equal h_mixed\n  exact h_pos p h p_char\n#align split_by_characteristic split_by_characteristic\n\n",
 "reduce_to_p_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-\nCopyright (c) 2022 Jon Eugster. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jon Eugster\n-/\n/-- Reduction to `p` prime: When proving any statement `P` about mixed characteristic rings we\ncan always assume that `p` is prime.\n-/\ntheorem reduce_to_p_prime {P : Prop} :\n    (∀ p > 0, mixed_char_zero R p → P) ↔ ∀ p : ℕ, p.prime → mixed_char_zero R p → P :=\n  by\n  constructor\n  · intro h q q_prime q_mixed_char\n    exact h q (Nat.Prime.pos q_prime) q_mixed_char\n  · intro h q q_pos q_mixed_char\n    rcases q_mixed_char.char_p_quotient with ⟨I, hI_ne_top, hI_char⟩\n    -- Krull's Thm: There exists a prime ideal `P` such that `I ≤ P`\n    rcases ideal.exists_le_maximal I hI_ne_top with ⟨M, hM_max, h_IM⟩\n    skip\n    -- make `hI_char : char_p (R ⧸ I) q` an instance.\n    let r := ring_char («expr ⧸ » R M)\n    have r_pos : r ≠ 0 :=\n      by\n      have q_zero := congr_arg (ideal.quotient.factor I M h_IM) (char_p.cast_eq_zero («expr ⧸ » R I) q)\n      simp only [map_nat_cast, map_zero] at q_zero\n      apply ne_zero_of_dvd_ne_zero (ne_of_gt q_pos)\n      exact (char_p.cast_eq_zero_iff («expr ⧸ » R M) r q).mp q_zero\n    have r_prime : Nat.Prime r := or_iff_not_imp_right.1 (char_p.char_is_prime_or_zero («expr ⧸ » R M) r) r_pos\n    apply h r r_prime\n    haveI : CharZero R := q_mixed_char.to_char_zero\n    exact ⟨⟨M, hM_max.ne_top, ring_char.of_eq rfl⟩⟩\n#align reduce_to_p_prime reduce_to_p_prime\n\n",
 "reduce_to_maximal_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- Reduction to `I` prime ideal: When proving statements about mixed characteristic rings,\nafter we reduced to `p` prime, we can assume that the ideal `I` in the definition is maximal.\n-/\ntheorem reduce_to_maximal_ideal {p : ℕ} (hp : Nat.Prime p) :\n    (∃ I : ideal R, I ≠ «expr⊤» ∧ char_p («expr ⧸ » R I) p) ↔ ∃ I : ideal R, I.is_maximal ∧ char_p («expr ⧸ » R I) p :=\n  by\n  constructor\n  · intro g\n    rcases g with ⟨I, ⟨hI_not_top, hI⟩⟩\n    -- Krull's Thm: There exists a prime ideal `M` such that `I ≤ M`.\n    rcases ideal.exists_le_maximal I hI_not_top with ⟨M, ⟨hM_max, hM⟩⟩\n    use M\n    constructor\n    exact hM_max\n    · cases' char_p.exists («expr ⧸ » R M) with r hr\n      convert hr\n      skip\n      -- make `hr : char_p (R ⧸ M) r` an instance.\n      have r_dvd_p : r ∣ p := by\n        rw [← char_p.cast_eq_zero_iff («expr ⧸ » R M) r p]\n        convert congr_arg (ideal.quotient.factor I M hM) (char_p.cast_eq_zero («expr ⧸ » R I) p)\n      symm\n      apply (Nat.Prime.eq_one_or_self_of_dvd hp r r_dvd_p).resolve_left\n      exact char_p.char_ne_one («expr ⧸ » R M) r\n  · rintro ⟨I, hI_max, hI⟩\n    use I\n    exact ⟨ideal.is_maximal.ne_top hI_max, hI⟩\n#align reduce_to_maximal_ideal reduce_to_maximal_ideal\n\n",
 "pnat_coe_units_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- Internal: Not intended to be used outside this local construction. -/\ntheorem equal_char_zero.pnat_coe_units_eq_one [fact (∀ I : ideal R, I ≠ «expr⊤» → CharZero («expr ⧸ » R I))] :\n    ((1 : «exprℕ+») : «expr ˣ» R) = 1 := by\n  apply Units.ext\n  rw [Units.val_one]\n  change ((equal_char_zero.pnat_coe_is_unit R 1).unit : R) = 1\n  rw [is_unit.unit_spec (equal_char_zero.pnat_coe_is_unit R 1)]\n  rw [coe_coe, PNat.one_coe, Nat.cast_one]\n#align equal_char_zero.pnat_coe_units_eq_one equal_char_zero.pnat_coe_units_eq_one\n\n",
 "pnat_coe_units_coe_eq_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- Internal: Not intended to be used outside this local construction. -/\ntheorem equal_char_zero.pnat_coe_units_coe_eq_coe [fact (∀ I : ideal R, I ≠ «expr⊤» → CharZero («expr ⧸ » R I))]\n    (n : «exprℕ+») : ((n : «expr ˣ» R) : R) = ↑n :=\n  by\n  change ((equal_char_zero.pnat_coe_is_unit R n).unit : R) = ↑n\n  simp only [is_unit.unit_spec]\n#align equal_char_zero.pnat_coe_units_coe_eq_coe equal_char_zero.pnat_coe_units_coe_eq_coe\n\n",
 "pnat_coe_is_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/-- Internal: Not intended to be used outside this local construction. -/\ntheorem equal_char_zero.pnat_coe_is_unit [h : fact (∀ I : ideal R, I ≠ «expr⊤» → CharZero («expr ⧸ » R I))]\n    (n : «exprℕ+») : is_unit (n : R) :=\n  by\n  -- `n : R` is a unit iff `(n)` is not a proper ideal in `R`.\n  rw [← ideal.span_singleton_eq_top]\n  -- So by contrapositive, we should show the quotient does not have characteristic zero.\n  apply not_imp_comm.mp (h.elim (ideal.span {n}))\n  intro h_char_zero\n  -- In particular, the image of `n` in the quotient should be nonzero.\n  apply h_char_zero.cast_injective.ne n.ne_zero\n  -- But `n` generates the ideal, so its image is clearly zero.\n  rw [← map_nat_cast (ideal.quotient.mk _), Nat.cast_zero, ideal.quotient.eq_zero_iff_mem]\n  exact ideal.subset_span (Set.mem_singleton _)\n#align equal_char_zero.pnat_coe_is_unit equal_char_zero.pnat_coe_is_unit\n\n",
 "not_mixed_char_to_equal_char_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- Not mixed characteristic implies equal characteristic.\n-/\ntheorem not_mixed_char_to_equal_char_zero [CharZero R] (h : ∀ p > 0, ¬mixed_char_zero R p) :\n    ∀ I : ideal R, I ≠ «expr⊤» → CharZero («expr ⧸ » R I) :=\n  by\n  intro I hI_ne_top\n  apply char_p.char_p_to_char_zero _\n  cases' char_p.exists («expr ⧸ » R I) with p hp\n  cases p\n  · exact hp\n  · have h_mixed : mixed_char_zero R p.succ := ⟨⟨I, ⟨hI_ne_top, hp⟩⟩⟩\n    exact absurd h_mixed (h p.succ p.succ_pos)\n#align not_mixed_char_to_equal_char_zero not_mixed_char_to_equal_char_zero\n\n",
 "not_Q_algebra_iff_not_equal_char_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- A ring of characteristic zero is not a `ℚ`-algebra iff it has mixed characteristic for some `p`.\n-/\ntheorem not_Q_algebra_iff_not_equal_char_zero [CharZero R] :\n    is_empty (algebra (exprℚ) R) ↔ ∃ p > 0, mixed_char_zero R p :=\n  by\n  rw [← not_iff_not]\n  push_neg\n  rw [not_isEmpty_iff, ← equal_char_zero_iff_not_mixed_char]\n  apply Q_algebra_iff_equal_char_zero\n#align not_Q_algebra_iff_not_equal_char_zero not_Q_algebra_iff_not_equal_char_zero\n\n",
 "equal_char_zero_to_not_mixed_char":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- Equal characteristic implies not mixed characteristic.\n-/\ntheorem equal_char_zero_to_not_mixed_char (h : ∀ I : ideal R, I ≠ «expr⊤» → CharZero («expr ⧸ » R I)) :\n    ∀ p > 0, ¬mixed_char_zero R p := by\n  intro p p_pos\n  by_contra hp_mixed_char\n  rcases hp_mixed_char.char_p_quotient with ⟨I, hI_ne_top, hI_p⟩\n  replace hI_zero : char_p («expr ⧸ » R I) 0 := @char_p.of_char_zero _ _ (h I hI_ne_top)\n  exact absurd (char_p.eq («expr ⧸ » R I) hI_p hI_zero) (ne_of_gt p_pos)\n#align equal_char_zero_to_not_mixed_char equal_char_zero_to_not_mixed_char\n\n",
 "equal_char_zero_iff_not_mixed_char":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- A ring of characteristic zero has equal characteristic iff it does not\nhave mixed characteristic for any `p`.\n-/\ntheorem equal_char_zero_iff_not_mixed_char [CharZero R] :\n    (∀ I : ideal R, I ≠ «expr⊤» → CharZero («expr ⧸ » R I)) ↔ ∀ p > 0, ¬mixed_char_zero R p :=\n  ⟨equal_char_zero_to_not_mixed_char R, not_mixed_char_to_equal_char_zero R⟩\n#align equal_char_zero_iff_not_mixed_char equal_char_zero_iff_not_mixed_char\n\n",
 "Q_algebra_to_equal_char_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n-- argument `[nontrivial R]` is used in the first line of the proof.\n/-- `ℚ`-algebra implies equal characteristic.\n-/\n@[nolint unused_arguments]\ntheorem Q_algebra_to_equal_char_zero [nontrivial R] [algebra (exprℚ) R] :\n    ∀ I : ideal R, I ≠ «expr⊤» → CharZero («expr ⧸ » R I) :=\n  by\n  haveI : CharZero R := algebra_rat.char_zero R\n  intro I hI\n  constructor\n  intro a b h_ab\n  contrapose! hI\n  -- `↑a - ↑b` is a unit contained in `I`, which contradicts `I ≠ ⊤`.\n  refine' I.eq_top_of_is_unit_mem _ (IsUnit.map (algebra_map (exprℚ) R) (IsUnit.mk0 (a - b : exprℚ) _))\n  · simpa only [← ideal.quotient.eq_zero_iff_mem, map_sub, sub_eq_zero, map_nat_cast]\n  simpa only [ne.def, sub_eq_zero] using (@Nat.cast_injective (exprℚ) _ _).ne hI\n#align Q_algebra_to_equal_char_zero Q_algebra_to_equal_char_zero\n\n",
 "Q_algebra_iff_equal_char_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- A ring is a `ℚ`-algebra iff it has equal characteristic zero.\n-/\ntheorem Q_algebra_iff_equal_char_zero [nontrivial R] :\n    nonempty (algebra (exprℚ) R) ↔ ∀ I : ideal R, I ≠ «expr⊤» → CharZero («expr ⧸ » R I) :=\n  by\n  constructor\n  · intro h_alg\n    haveI h_alg' : algebra (exprℚ) R := h_alg.some\n    apply Q_algebra_to_equal_char_zero\n  · intro h\n    apply nonempty.intro\n    exact equal_char_zero_to_Q_algebra R h\n#align Q_algebra_iff_equal_char_zero Q_algebra_iff_equal_char_zero\n\n"}