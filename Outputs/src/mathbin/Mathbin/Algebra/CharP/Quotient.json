{"quotient'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- If an ideal does not contain any coercions of natural numbers other than zero, then its quotient\ninherits the characteristic of the underlying ring. -/\ntheorem quotient' {R : Type _} [CommRing R] (p : ℕ) [CharP R p] (I : Ideal R) (h : ∀ x : ℕ, (x : R) ∈ I → (x : R) = 0) :\n    CharP («expr ⧸ » R I) p :=\n  ⟨fun x => by\n    rw [← cast_eq_zero_iff R p x, ← map_natCast (Ideal.Quotient.mk I)]\n    refine' ideal.quotient.eq.trans (_ : ↑x - 0 ∈ I ↔ _)\n    rw [sub_zero]\n    exact ⟨h x, fun h' => h'.symm ▸ I.zero_mem⟩⟩\n#align quotient' quotient'\n\n",
 "quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Eric Wieser\n-/\ntheorem quotient (R : Type u) [CommRing R] (p : ℕ) [hp1 : Fact p.prime] (hp2 : ↑p ∈ nonunits R) :\n    CharP («expr ⧸ » R (Ideal.span {p} : Ideal R)) p :=\n  have hp0 : (p : «expr ⧸ » R (Ideal.span {p} : Ideal R)) = 0 :=\n    map_natCast (Ideal.Quotient.mk (Ideal.span {p} : Ideal R)) p ▸\n      Ideal.Quotient.eq_zero_iff_mem.2 (Ideal.subset_span <| Set.mem_singleton _)\n  ringChar.of_eq <|\n    or.resolve_left ((Nat.dvd_prime hp1.1).1 <| ringChar.dvd hp0) fun h1 =>\n      hp2 <|\n        isUnit_iff_dvd_one.2 <|\n          Ideal.mem_span_singleton.1 <|\n            Ideal.Quotient.eq_zero_iff_mem.1 <| @subsingleton.elim (@char_p.subsingleton _ <| ringChar.of_eq h1) _ _\n#align quotient quotient\n\n",
 "index_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print Ideal.Quotient.index_eq_zero /-\ntheorem Ideal.Quotient.index_eq_zero {R : Type _} [CommRing R] (I : Ideal R) :\n    (I.to_add_subgroup.index : «expr ⧸ » R I) = 0 :=\n  by\n  rw [AddSubgroup.index, Nat.card_eq]\n  split_ifs with hq; swap; simp\n  by_contra h\n  -- TODO: can we avoid rewriting the `I.to_add_subgroup` here?\n  letI : Fintype («expr ⧸ » R I) := @Fintype.ofFinite _ hq\n  have h : (Fintype.card («expr ⧸ » R I) : «expr ⧸ » R I) ≠ 0 := h\n  simpa using h\n#align ideal.quotient.index_eq_zero Ideal.Quotient.index_eq_zero\n-/\n\n"}