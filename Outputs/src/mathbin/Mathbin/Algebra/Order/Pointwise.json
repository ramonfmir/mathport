{"supₛ_one":
 "#print supₛ_one /-\n@[simp, to_additive]\ntheorem supₛ_one : supₛ (1 : Set α) = 1 :=\n  supₛ_singleton\n#align Sup_one supₛ_one\n#align Sup_zero supₛ_zero\n-/\n\n",
 "supₛ_mul":
 "#print supₛ_mul /-\n@[to_additive]\ntheorem supₛ_mul : supₛ (s * t) = supₛ s * supₛ t :=\n  supₛ_image2_eq_supₛ_supₛ (fun _ => (OrderIso.mulRight _).to_galois_connection) fun _ =>\n    (OrderIso.mulLeft _).to_galois_connection\n#align Sup_mul supₛ_mul\n#align Sup_add supₛ_add\n-/\n\n",
 "supₛ_inv":
 "#print supₛ_inv /-\n@[to_additive]\ntheorem supₛ_inv (s : Set α) : supₛ s⁻¹ = (infₛ s)⁻¹ :=\n  by\n  rw [← image_inv, supₛ_image]\n  exact ((OrderIso.inv α).map_Inf _).symm\n#align Sup_inv supₛ_inv\n#align Sup_neg supₛ_neg\n-/\n\n",
 "supₛ_div":
 "#print supₛ_div /-\n@[to_additive]\ntheorem supₛ_div : supₛ (s / t) = supₛ s / infₛ t := by simp_rw [div_eq_mul_inv, supₛ_mul, supₛ_inv]\n#align Sup_div supₛ_div\n#align Sup_sub supₛ_sub\n-/\n\n",
 "smul_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_Ioo : «expr • » r (Ioo a b) = Ioo («expr • » r a) («expr • » r b) :=\n  by\n  ext x\n  simp only [mem_smul_set, smul_eq_mul, mem_Ioo]\n  constructor\n  · rintro ⟨a, ⟨a_h_left_left, a_h_left_right⟩, rfl⟩\n    constructor\n    exact (mul_lt_mul_left hr).mpr a_h_left_left\n    exact (mul_lt_mul_left hr).mpr a_h_left_right\n  · rintro ⟨a_left, a_right⟩\n    use x / r\n    refine' ⟨⟨(lt_div_iff' hr).mpr a_left, (div_lt_iff' hr).mpr a_right⟩, _⟩\n    rw [mul_div_cancel' _ (ne_of_gt hr)]\n#align smul_Ioo smul_Ioo\n\n",
 "smul_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_Ioi : «expr • » r (Ioi a) = Ioi («expr • » r a) :=\n  by\n  ext x\n  simp only [mem_smul_set, smul_eq_mul, mem_Ioi]\n  constructor\n  · rintro ⟨a_w, a_h_left, rfl⟩\n    exact (mul_lt_mul_left hr).mpr a_h_left\n  · rintro h\n    use x / r\n    constructor\n    exact (lt_div_iff' hr).mpr h\n    exact mul_div_cancel' _ (ne_of_gt hr)\n#align smul_Ioi smul_Ioi\n\n",
 "smul_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_Ioc : «expr • » r (Ioc a b) = Ioc («expr • » r a) («expr • » r b) :=\n  by\n  ext x\n  simp only [mem_smul_set, smul_eq_mul, mem_Ioc]\n  constructor\n  · rintro ⟨a, ⟨a_h_left_left, a_h_left_right⟩, rfl⟩\n    constructor\n    exact (mul_lt_mul_left hr).mpr a_h_left_left\n    exact (mul_le_mul_left hr).mpr a_h_left_right\n  · rintro ⟨a_left, a_right⟩\n    use x / r\n    refine' ⟨⟨(lt_div_iff' hr).mpr a_left, (div_le_iff' hr).mpr a_right⟩, _⟩\n    rw [mul_div_cancel' _ (ne_of_gt hr)]\n#align smul_Ioc smul_Ioc\n\n",
 "smul_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_Iio : «expr • » r (Iio a) = Iio («expr • » r a) :=\n  by\n  ext x\n  simp only [mem_smul_set, smul_eq_mul, mem_Iio]\n  constructor\n  · rintro ⟨a_w, a_h_left, rfl⟩\n    exact (mul_lt_mul_left hr).mpr a_h_left\n  · rintro h\n    use x / r\n    constructor\n    exact (div_lt_iff' hr).mpr h\n    exact mul_div_cancel' _ (ne_of_gt hr)\n#align smul_Iio smul_Iio\n\n",
 "smul_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_Iic : «expr • » r (Iic a) = Iic («expr • » r a) :=\n  by\n  ext x\n  simp only [mem_smul_set, smul_eq_mul, mem_Iio]\n  constructor\n  · rintro ⟨a_w, a_h_left, rfl⟩\n    exact (mul_le_mul_left hr).mpr a_h_left\n  · rintro h\n    use x / r\n    constructor\n    exact (div_le_iff' hr).mpr h\n    exact mul_div_cancel' _ (ne_of_gt hr)\n#align smul_Iic smul_Iic\n\n",
 "smul_Ico":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_Ico : «expr • » r (Ico a b) = Ico («expr • » r a) («expr • » r b) :=\n  by\n  ext x\n  simp only [mem_smul_set, smul_eq_mul, mem_Ico]\n  constructor\n  · rintro ⟨a, ⟨a_h_left_left, a_h_left_right⟩, rfl⟩\n    constructor\n    exact (mul_le_mul_left hr).mpr a_h_left_left\n    exact (mul_lt_mul_left hr).mpr a_h_left_right\n  · rintro ⟨a_left, a_right⟩\n    use x / r\n    refine' ⟨⟨(le_div_iff' hr).mpr a_left, (div_lt_iff' hr).mpr a_right⟩, _⟩\n    rw [mul_div_cancel' _ (ne_of_gt hr)]\n#align smul_Ico smul_Ico\n\n",
 "smul_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_Ici : «expr • » r (Ici a) = Ici («expr • » r a) :=\n  by\n  ext x\n  simp only [mem_smul_set, smul_eq_mul, mem_Ioi]\n  constructor\n  · rintro ⟨a_w, a_h_left, rfl⟩\n    exact (mul_le_mul_left hr).mpr a_h_left\n  · rintro h\n    use x / r\n    constructor\n    exact (le_div_iff' hr).mpr h\n    exact mul_div_cancel' _ (ne_of_gt hr)\n#align smul_Ici smul_Ici\n\n",
 "smul_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_Icc : «expr • » r (Icc a b) = Icc («expr • » r a) («expr • » r b) :=\n  by\n  ext x\n  simp only [mem_smul_set, smul_eq_mul, mem_Icc]\n  constructor\n  · rintro ⟨a, ⟨a_h_left_left, a_h_left_right⟩, rfl⟩\n    constructor\n    exact (mul_le_mul_left hr).mpr a_h_left_left\n    exact (mul_le_mul_left hr).mpr a_h_left_right\n  · rintro ⟨a_left, a_right⟩\n    use x / r\n    refine' ⟨⟨(le_div_iff' hr).mpr a_left, (div_le_iff' hr).mpr a_right⟩, _⟩\n    rw [mul_div_cancel' _ (ne_of_gt hr)]\n#align smul_Icc smul_Icc\n\n",
 "infₛ_one":
 "#print infₛ_one /-\n@[simp, to_additive]\ntheorem infₛ_one : infₛ (1 : Set α) = 1 :=\n  infₛ_singleton\n#align Inf_one infₛ_one\n#align Inf_zero infₛ_zero\n-/\n\n",
 "infₛ_mul":
 "#print infₛ_mul /-\n@[to_additive]\ntheorem infₛ_mul : infₛ (s * t) = infₛ s * infₛ t :=\n  infₛ_image2_eq_infₛ_infₛ (fun _ => (OrderIso.mulRight _).symm.to_galois_connection) fun _ =>\n    (OrderIso.mulLeft _).symm.to_galois_connection\n#align Inf_mul infₛ_mul\n#align Inf_add infₛ_add\n-/\n\n",
 "infₛ_inv":
 "#print infₛ_inv /-\n@[to_additive]\ntheorem infₛ_inv (s : Set α) : infₛ s⁻¹ = (supₛ s)⁻¹ :=\n  by\n  rw [← image_inv, infₛ_image]\n  exact ((OrderIso.inv α).map_Sup _).symm\n#align Inf_inv infₛ_inv\n#align Inf_neg infₛ_neg\n-/\n\n",
 "infₛ_div":
 "#print infₛ_div /-\n@[to_additive]\ntheorem infₛ_div : infₛ (s / t) = infₛ s / supₛ t := by simp_rw [div_eq_mul_inv, infₛ_mul, infₛ_inv]\n#align Inf_div infₛ_div\n#align Inf_sub infₛ_sub\n-/\n\n",
 "csupₛ_one":
 "#print csupₛ_one /-\n/-\nCopyright (c) 2021 Alex J. Best. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alex J. Best, Yaël Dillies\n-/\n@[simp, to_additive]\ntheorem csupₛ_one : supₛ (1 : Set α) = 1 :=\n  csupₛ_singleton _\n#align cSup_one csupₛ_one\n#align cSup_zero csupₛ_zero\n-/\n\n",
 "csupₛ_mul":
 "#print csupₛ_mul /-\n@[to_additive]\ntheorem csupₛ_mul (hs₀ : s.nonempty) (hs₁ : BddAbove s) (ht₀ : t.nonempty) (ht₁ : BddAbove t) :\n    supₛ (s * t) = supₛ s * supₛ t :=\n  csupₛ_image2_eq_csupₛ_csupₛ (fun _ => (OrderIso.mulRight _).to_galois_connection)\n    (fun _ => (OrderIso.mulLeft _).to_galois_connection) hs₀ hs₁ ht₀ ht₁\n#align cSup_mul csupₛ_mul\n#align cSup_add csupₛ_add\n-/\n\n",
 "csupₛ_inv":
 "#print csupₛ_inv /-\n@[to_additive]\ntheorem csupₛ_inv (hs₀ : s.nonempty) (hs₁ : BddBelow s) : supₛ s⁻¹ = (infₛ s)⁻¹ :=\n  by\n  rw [← image_inv]\n  exact ((OrderIso.inv α).map_cInf' hs₀ hs₁).symm\n#align cSup_inv csupₛ_inv\n#align cSup_neg csupₛ_neg\n-/\n\n",
 "csupₛ_div":
 "#print csupₛ_div /-\n@[to_additive]\ntheorem csupₛ_div (hs₀ : s.nonempty) (hs₁ : BddAbove s) (ht₀ : t.nonempty) (ht₁ : BddBelow t) :\n    supₛ (s / t) = supₛ s / infₛ t := by\n  rw [div_eq_mul_inv, csupₛ_mul hs₀ hs₁ ht₀.inv ht₁.inv, csupₛ_inv ht₀ ht₁, div_eq_mul_inv]\n#align cSup_div csupₛ_div\n#align cSup_sub csupₛ_sub\n-/\n\n",
 "cinfₛ_one":
 "#print cinfₛ_one /-\n@[simp, to_additive]\ntheorem cinfₛ_one : infₛ (1 : Set α) = 1 :=\n  cinfₛ_singleton _\n#align cInf_one cinfₛ_one\n#align cInf_zero cinfₛ_zero\n-/\n\n",
 "cinfₛ_mul":
 "#print cinfₛ_mul /-\n@[to_additive]\ntheorem cinfₛ_mul (hs₀ : s.nonempty) (hs₁ : BddBelow s) (ht₀ : t.nonempty) (ht₁ : BddBelow t) :\n    infₛ (s * t) = infₛ s * infₛ t :=\n  cinfₛ_image2_eq_cinfₛ_cinfₛ (fun _ => (OrderIso.mulRight _).symm.to_galois_connection)\n    (fun _ => (OrderIso.mulLeft _).symm.to_galois_connection) hs₀ hs₁ ht₀ ht₁\n#align cInf_mul cinfₛ_mul\n#align cInf_add cinfₛ_add\n-/\n\n",
 "cinfₛ_inv":
 "#print cinfₛ_inv /-\n@[to_additive]\ntheorem cinfₛ_inv (hs₀ : s.nonempty) (hs₁ : BddAbove s) : infₛ s⁻¹ = (supₛ s)⁻¹ :=\n  by\n  rw [← image_inv]\n  exact ((OrderIso.inv α).map_cSup' hs₀ hs₁).symm\n#align cInf_inv cinfₛ_inv\n#align cInf_neg cinfₛ_neg\n-/\n\n",
 "cinfₛ_div":
 "#print cinfₛ_div /-\n@[to_additive]\ntheorem cinfₛ_div (hs₀ : s.nonempty) (hs₁ : BddBelow s) (ht₀ : t.nonempty) (ht₁ : BddAbove t) :\n    infₛ (s / t) = infₛ s / supₛ t := by\n  rw [div_eq_mul_inv, cinfₛ_mul hs₀ hs₁ ht₀.inv ht₁.inv, cinfₛ_inv ht₀ ht₁, div_eq_mul_inv]\n#align cInf_div cinfₛ_div\n#align cInf_sub cinfₛ_sub\n-/\n\n"}