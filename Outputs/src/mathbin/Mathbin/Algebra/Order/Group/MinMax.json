{"min_inv_inv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print min_inv_inv' /-\n@[to_additive min_neg_neg]\ntheorem min_inv_inv' (a b : α) : min a⁻¹ b⁻¹ = (max a b)⁻¹ :=\n  Eq.symm <| @Monotone.map_max α («expr ᵒᵈ» α) _ _ has_inv.inv a b fun a b => inv_le_inv_iff.mpr\n#align min_inv_inv' min_inv_inv'\n#align min_neg_neg min_neg_neg\n-/\n\n",
 "min_div_div_right'":
 "#print min_div_div_right' /-\n@[to_additive min_sub_sub_right]\ntheorem min_div_div_right' (a b c : α) : min (a / c) (b / c) = min a b / c := by\n  simpa only [div_eq_mul_inv] using min_mul_mul_right a b c⁻¹\n#align min_div_div_right' min_div_div_right'\n#align min_sub_sub_right min_sub_sub_right\n-/\n\n",
 "min_div_div_left'":
 "#print min_div_div_left' /-\n@[to_additive min_sub_sub_left]\ntheorem min_div_div_left' (a b c : α) : min (a / b) (a / c) = a / max b c := by\n  simp only [div_eq_mul_inv, min_mul_mul_left, min_inv_inv']\n#align min_div_div_left' min_div_div_left'\n#align min_sub_sub_left min_sub_sub_left\n-/\n\n",
 "max_sub_max_le_max":
 "#print max_sub_max_le_max /-\ntheorem max_sub_max_le_max (a b c d : α) : max a b - max c d ≤ max (a - c) (b - d) :=\n  by\n  simp only [sub_le_iff_le_add, max_le_iff]; constructor\n  calc\n    a = a - c + c := (sub_add_cancel a c).symm\n    _ ≤ max (a - c) (b - d) + max c d := add_le_add (le_max_left _ _) (le_max_left _ _)\n    \n  calc\n    b = b - d + d := (sub_add_cancel b d).symm\n    _ ≤ max (a - c) (b - d) + max c d := add_le_add (le_max_right _ _) (le_max_right _ _)\n    \n#align max_sub_max_le_max max_sub_max_le_max\n-/\n\n",
 "max_one_div_max_inv_one_eq_self":
 "#print max_one_div_max_inv_one_eq_self /-\n/-\nCopyright (c) 2016 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Leonardo de Moura, Mario Carneiro, Johannes Hölzl\n-/\n@[simp, to_additive]\ntheorem max_one_div_max_inv_one_eq_self (a : α) : max a 1 / max a⁻¹ 1 = a := by\n  rcases le_total a 1 with (h | h) <;> simp [h]\n#align max_one_div_max_inv_one_eq_self max_one_div_max_inv_one_eq_self\n#align max_zero_sub_max_neg_zero_eq_self max_zero_sub_max_neg_zero_eq_self\n-/\n\n",
 "max_inv_inv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print max_inv_inv' /-\n@[to_additive max_neg_neg]\ntheorem max_inv_inv' (a b : α) : max a⁻¹ b⁻¹ = (min a b)⁻¹ :=\n  Eq.symm <| @Monotone.map_min α («expr ᵒᵈ» α) _ _ has_inv.inv a b fun a b => inv_le_inv_iff.mpr\n#align max_inv_inv' max_inv_inv'\n#align max_neg_neg max_neg_neg\n-/\n\n",
 "max_div_div_right'":
 "#print max_div_div_right' /-\n@[to_additive max_sub_sub_right]\ntheorem max_div_div_right' (a b c : α) : max (a / c) (b / c) = max a b / c := by\n  simpa only [div_eq_mul_inv] using max_mul_mul_right a b c⁻¹\n#align max_div_div_right' max_div_div_right'\n#align max_sub_sub_right max_sub_sub_right\n-/\n\n",
 "max_div_div_left'":
 "#print max_div_div_left' /-\n@[to_additive max_sub_sub_left]\ntheorem max_div_div_left' (a b c : α) : max (a / b) (a / c) = a / min b c := by\n  simp only [div_eq_mul_inv, max_mul_mul_left, max_inv_inv']\n#align max_div_div_left' max_div_div_left'\n#align max_sub_sub_left max_sub_sub_left\n-/\n\n",
 "abs_min_sub_min_le_max":
 "#print abs_min_sub_min_le_max /-\ntheorem abs_min_sub_min_le_max (a b c d : α) : |min a b - min c d| ≤ max (|a - c|) (|b - d|) := by\n  simpa only [max_neg_neg, neg_sub_neg, abs_sub_comm] using abs_max_sub_max_le_max (-a) (-b) (-c) (-d)\n#align abs_min_sub_min_le_max abs_min_sub_min_le_max\n-/\n\n",
 "abs_max_sub_max_le_max":
 "#print abs_max_sub_max_le_max /-\ntheorem abs_max_sub_max_le_max (a b c d : α) : |max a b - max c d| ≤ max (|a - c|) (|b - d|) :=\n  by\n  refine' abs_sub_le_iff.2 ⟨_, _⟩\n  · exact (max_sub_max_le_max _ _ _ _).trans (max_le_max (le_abs_self _) (le_abs_self _))\n  · rw [abs_sub_comm a c, abs_sub_comm b d]\n    exact (max_sub_max_le_max _ _ _ _).trans (max_le_max (le_abs_self _) (le_abs_self _))\n#align abs_max_sub_max_le_max abs_max_sub_max_le_max\n-/\n\n",
 "abs_max_sub_max_le_abs":
 "#print abs_max_sub_max_le_abs /-\ntheorem abs_max_sub_max_le_abs (a b c : α) : |max a c - max b c| ≤ |a - b| := by\n  simpa only [sub_self, abs_zero, max_eq_left (abs_nonneg _)] using abs_max_sub_max_le_max a c b c\n#align abs_max_sub_max_le_abs abs_max_sub_max_le_abs\n-/\n\n"}