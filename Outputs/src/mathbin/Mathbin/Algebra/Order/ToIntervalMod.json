{"to_Ioc_mod_zsmul_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ioc_mod_zsmul_add (a : α) {b : α} (hb : 0 < b) (x : α) (m : ℤ) :\n    to_Ioc_mod a hb («expr • » m b + x) = to_Ioc_mod a hb x := by rw [add_comm, to_Ioc_mod_add_zsmul]\n#align to_Ioc_mod_zsmul_add to_Ioc_mod_zsmul_add\n\n",
 "to_Ioc_mod_to_Ioc_mod":
 "@[simp]\ntheorem to_Ioc_mod_to_Ioc_mod (a₁ a₂ : α) {b : α} (hb : 0 < b) (x : α) :\n    to_Ioc_mod a₁ hb (to_Ioc_mod a₂ hb x) = to_Ioc_mod a₁ hb x :=\n  by\n  rw [to_Ioc_mod_eq_to_Ioc_mod]\n  exact ⟨to_Ioc_div a₂ hb x, self_sub_to_Ioc_mod a₂ hb x⟩\n#align to_Ioc_mod_to_Ioc_mod to_Ioc_mod_to_Ioc_mod\n\n",
 "to_Ioc_mod_to_Ico_mod":
 "@[simp]\ntheorem to_Ioc_mod_to_Ico_mod (a₁ a₂ : α) {b : α} (hb : 0 < b) (x : α) :\n    to_Ioc_mod a₁ hb (to_Ico_mod a₂ hb x) = to_Ioc_mod a₁ hb x :=\n  by\n  rw [to_Ioc_mod_eq_to_Ioc_mod]\n  exact ⟨to_Ico_div a₂ hb x, self_sub_to_Ico_mod a₂ hb x⟩\n#align to_Ioc_mod_to_Ico_mod to_Ioc_mod_to_Ico_mod\n\n",
 "to_Ioc_mod_sub_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ioc_mod_sub_zsmul (a : α) {b : α} (hb : 0 < b) (x : α) (m : ℤ) :\n    to_Ioc_mod a hb (x - «expr • » m b) = to_Ioc_mod a hb x := by rw [sub_eq_add_neg, ← neg_smul, to_Ioc_mod_add_zsmul]\n#align to_Ioc_mod_sub_zsmul to_Ioc_mod_sub_zsmul\n\n",
 "to_Ioc_mod_sub_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ioc_mod_sub_self (a : α) {b : α} (hb : 0 < b) (x : α) :\n    to_Ioc_mod a hb x - x = «expr • » (-to_Ioc_div a hb x) b := by rw [to_Ioc_mod, sub_sub_cancel_left, neg_smul]\n#align to_Ioc_mod_sub_self to_Ioc_mod_sub_self\n\n",
 "to_Ioc_mod_sub'":
 "theorem to_Ioc_mod_sub' (a : α) {b : α} (hb : 0 < b) (x y : α) :\n    to_Ioc_mod a hb (x - y) = to_Ioc_mod (a + y) hb x - y := by simp_rw [to_Ioc_mod, to_Ioc_div_sub', sub_right_comm]\n#align to_Ioc_mod_sub' to_Ioc_mod_sub'\n\n",
 "to_Ioc_mod_sub":
 "@[simp]\ntheorem to_Ioc_mod_sub (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ioc_mod a hb (x - b) = to_Ioc_mod a hb x :=\n  by\n  convert to_Ioc_mod_sub_zsmul a hb x 1\n  exact (one_zsmul _).symm\n#align to_Ioc_mod_sub to_Ioc_mod_sub\n\n",
 "to_Ioc_mod_periodic":
 "theorem to_Ioc_mod_periodic (a : α) {b : α} (hb : 0 < b) : function.periodic (to_Ioc_mod a hb) b :=\n  to_Ioc_mod_add_right a hb\n#align to_Ioc_mod_periodic to_Ioc_mod_periodic\n\n",
 "to_Ioc_mod_neg":
 "theorem to_Ioc_mod_neg (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ioc_mod a hb (-x) = b - to_Ico_mod (-a) hb x :=\n  by\n  simp_rw [to_Ioc_mod, to_Ico_mod, to_Ioc_div_neg, neg_smul, add_smul]\n  abel\n#align to_Ioc_mod_neg to_Ioc_mod_neg\n\n",
 "to_Ioc_mod_mem_Ioc":
 "theorem to_Ioc_mod_mem_Ioc (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ioc_mod a hb x ∈ Set.Ioc a (a + b) :=\n  sub_to_Ioc_div_zsmul_mem_Ioc a hb x\n#align to_Ioc_mod_mem_Ioc to_Ioc_mod_mem_Ioc\n\n",
 "to_Ioc_mod_le_to_Ico_mod_add":
 "theorem to_Ioc_mod_le_to_Ico_mod_add (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ioc_mod a hb x ≤ to_Ico_mod a hb x + b :=\n  by\n  rw [to_Ico_mod, to_Ioc_mod, sub_add, sub_le_sub_iff_left, sub_le_iff_le_add, ← add_one_zsmul,\n    (zsmul_strictMono_left hb).le_iff_le]\n  apply (to_Ioc_div_wcovby_to_Ico_div _ _ _).le_succ\n#align to_Ioc_mod_le_to_Ico_mod_add to_Ioc_mod_le_to_Ico_mod_add\n\n",
 "to_Ioc_mod_le_right":
 "theorem to_Ioc_mod_le_right (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ioc_mod a hb x ≤ a + b :=\n  (Set.mem_Ioc.1 (to_Ioc_mod_mem_Ioc a hb x)).2\n#align to_Ioc_mod_le_right to_Ioc_mod_le_right\n\n",
 "to_Ioc_mod_eq_to_Ioc_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem to_Ioc_mod_eq_to_Ioc_mod (a : α) {b x y : α} (hb : 0 < b) :\n    to_Ioc_mod a hb x = to_Ioc_mod a hb y ↔ ∃ z : ℤ, y - x = «expr • » z b :=\n  by\n  refine' ⟨fun h => ⟨to_Ioc_div a hb y - to_Ioc_div a hb x, _⟩, fun h => _⟩\n  · conv_lhs => rw [← to_Ioc_mod_add_to_Ioc_div_zsmul a hb x, ← to_Ioc_mod_add_to_Ioc_div_zsmul a hb y]\n    rw [h, sub_smul]\n    abel\n  · rcases h with ⟨z, hz⟩\n    rw [sub_eq_iff_eq_add] at hz\n    rw [hz, to_Ioc_mod_zsmul_add]\n#align to_Ioc_mod_eq_to_Ioc_mod to_Ioc_mod_eq_to_Ioc_mod\n\n",
 "to_Ioc_mod_eq_sub_fract_mul":
 "theorem to_Ioc_mod_eq_sub_fract_mul (a : α) {b : α} (hb : 0 < b) (x : α) :\n    to_Ioc_mod a hb x = a + b - Int.fract ((a + b - x) / b) * b :=\n  by\n  rw [to_Ioc_mod, to_Ioc_div_eq_neg_floor, Int.fract]\n  field_simp [hb.ne.symm]\n  ring\n#align to_Ioc_mod_eq_sub_fract_mul to_Ioc_mod_eq_sub_fract_mul\n\n",
 "to_Ioc_mod_eq_self":
 "theorem to_Ioc_mod_eq_self {a b x : α} (hb : 0 < b) : to_Ioc_mod a hb x = x ↔ x ∈ Set.Ioc a (a + b) :=\n  by\n  rw [to_Ioc_mod_eq_iff, and_iff_left]\n  refine' ⟨0, _⟩\n  simp\n#align to_Ioc_mod_eq_self to_Ioc_mod_eq_self\n\n",
 "to_Ioc_mod_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem to_Ioc_mod_eq_iff {a b x y : α} (hb : 0 < b) :\n    to_Ioc_mod a hb x = y ↔ y ∈ Set.Ioc a (a + b) ∧ ∃ z : ℤ, x = y + «expr • » z b :=\n  by\n  refine'\n    ⟨fun h => ⟨h ▸ to_Ioc_mod_mem_Ioc a hb x, to_Ioc_div a hb x, h ▸ (to_Ioc_mod_add_to_Ioc_div_zsmul _ hb _).symm⟩,\n      fun h => _⟩\n  rcases h with ⟨hy, z, hz⟩\n  rw [← sub_eq_iff_eq_add] at hz\n  subst hz\n  rw [eq_to_Ioc_div_of_sub_zsmul_mem_Ioc hb hy]\n  rfl\n#align to_Ioc_mod_eq_iff to_Ioc_mod_eq_iff\n\n",
 "to_Ioc_mod_apply_right":
 "theorem to_Ioc_mod_apply_right (a : α) {b : α} (hb : 0 < b) : to_Ioc_mod a hb (a + b) = a + b :=\n  by\n  rw [to_Ioc_mod_eq_iff hb, Set.right_mem_Ioc]\n  refine' ⟨lt_add_of_pos_right _ hb, 0, _⟩\n  simp\n#align to_Ioc_mod_apply_right to_Ioc_mod_apply_right\n\n",
 "to_Ioc_mod_apply_left":
 "@[simp]\ntheorem to_Ioc_mod_apply_left (a : α) {b : α} (hb : 0 < b) : to_Ioc_mod a hb a = a + b :=\n  by\n  rw [to_Ioc_mod_eq_iff hb, Set.right_mem_Ioc]\n  refine' ⟨lt_add_of_pos_right _ hb, -1, _⟩\n  simp\n#align to_Ioc_mod_apply_left to_Ioc_mod_apply_left\n\n",
 "to_Ioc_mod_add_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ioc_mod_add_zsmul (a : α) {b : α} (hb : 0 < b) (x : α) (m : ℤ) :\n    to_Ioc_mod a hb (x + «expr • » m b) = to_Ioc_mod a hb x :=\n  by\n  rw [to_Ioc_mod, to_Ioc_div_add_zsmul, to_Ioc_mod, add_smul]\n  abel\n#align to_Ioc_mod_add_zsmul to_Ioc_mod_add_zsmul\n\n",
 "to_Ioc_mod_add_to_Ioc_div_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ioc_mod_add_to_Ioc_div_zsmul (a : α) {b : α} (hb : 0 < b) (x : α) :\n    to_Ioc_mod a hb x + «expr • » (to_Ioc_div a hb x) b = x := by rw [to_Ioc_mod, sub_add_cancel]\n#align to_Ioc_mod_add_to_Ioc_div_zsmul to_Ioc_mod_add_to_Ioc_div_zsmul\n\n",
 "to_Ioc_mod_add_right'":
 "theorem to_Ioc_mod_add_right' (a : α) {b : α} (hb : 0 < b) (x y : α) :\n    to_Ioc_mod a hb (x + y) = to_Ioc_mod (a - y) hb x + y := by\n  simp_rw [to_Ioc_mod, to_Ioc_div_add_right', sub_add_eq_add_sub]\n#align to_Ioc_mod_add_right' to_Ioc_mod_add_right'\n\n",
 "to_Ioc_mod_add_right":
 "@[simp]\ntheorem to_Ioc_mod_add_right (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ioc_mod a hb (x + b) = to_Ioc_mod a hb x :=\n  by\n  convert to_Ioc_mod_add_zsmul a hb x 1\n  exact (one_zsmul _).symm\n#align to_Ioc_mod_add_right to_Ioc_mod_add_right\n\n",
 "to_Ioc_mod_add_left":
 "@[simp]\ntheorem to_Ioc_mod_add_left (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ioc_mod a hb (b + x) = to_Ioc_mod a hb x := by\n  rw [add_comm, to_Ioc_mod_add_right]\n#align to_Ioc_mod_add_left to_Ioc_mod_add_left\n\n",
 "to_Ioc_div_zsmul_sub_to_Ioc_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ioc_div_zsmul_sub_to_Ioc_mod (a : α) {b : α} (hb : 0 < b) (x : α) :\n    «expr • » (to_Ioc_div a hb x) b + to_Ioc_mod a hb x = x := by rw [add_comm, to_Ioc_mod_add_to_Ioc_div_zsmul]\n#align to_Ioc_div_zsmul_sub_to_Ioc_mod to_Ioc_div_zsmul_sub_to_Ioc_mod\n\n",
 "to_Ioc_div_zsmul_sub_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ioc_div_zsmul_sub_self (a : α) {b : α} (hb : 0 < b) (x : α) :\n    «expr • » (to_Ioc_div a hb x) b - x = -to_Ioc_mod a hb x := by rw [to_Ioc_mod, neg_sub]\n#align to_Ioc_div_zsmul_sub_self to_Ioc_div_zsmul_sub_self\n\n",
 "to_Ioc_div_zsmul_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ioc_div_zsmul_add (a : α) {b : α} (hb : 0 < b) (x : α) (m : ℤ) :\n    to_Ioc_div a hb («expr • » m b + x) = to_Ioc_div a hb x + m := by rw [add_comm, to_Ioc_div_add_zsmul, add_comm]\n#align to_Ioc_div_zsmul_add to_Ioc_div_zsmul_add\n\n",
 "to_Ioc_div_wcovby_to_Ico_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⩿ » -/\ntheorem to_Ioc_div_wcovby_to_Ico_div (a : α) {b : α} (hb : 0 < b) (x : α) :\n    «expr ⩿ » (to_Ioc_div a hb x) (to_Ico_div a hb x) :=\n  by\n  suffices to_Ioc_div a hb x = to_Ico_div a hb x ∨ to_Ioc_div a hb x + 1 = to_Ico_div a hb x by\n    rwa [wcovby_iff_eq_or_covby, ← Order.succ_eq_iff_covby]\n  rw [eq_comm, ← mem_Ioo_mod_iff_to_Ico_div_eq_to_Ioc_div, eq_comm, ←\n    not_mem_Ioo_mod_iff_to_Ico_div_eq_to_Ioc_div_add_one]\n  exact em _\n#align to_Ioc_div_wcovby_to_Ico_div to_Ioc_div_wcovby_to_Ico_div\n\n",
 "to_Ioc_div_sub_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ioc_div_sub_zsmul (a : α) {b : α} (hb : 0 < b) (x : α) (m : ℤ) :\n    to_Ioc_div a hb (x - «expr • » m b) = to_Ioc_div a hb x - m := by\n  rw [sub_eq_add_neg, ← neg_smul, to_Ioc_div_add_zsmul, sub_eq_add_neg]\n#align to_Ioc_div_sub_zsmul to_Ioc_div_sub_zsmul\n\n",
 "to_Ioc_div_sub'":
 "theorem to_Ioc_div_sub' (a : α) {b : α} (hb : 0 < b) (x y : α) : to_Ioc_div a hb (x - y) = to_Ioc_div (a + y) hb x :=\n  by\n  rw [eq_comm]\n  apply eq_to_Ioc_div_of_sub_zsmul_mem_Ioc\n  rw [← sub_right_comm, Set.sub_mem_Ioc_iff_left, add_right_comm]\n  exact sub_to_Ioc_div_zsmul_mem_Ioc (a + y) hb x\n#align to_Ioc_div_sub' to_Ioc_div_sub'\n\n",
 "to_Ioc_div_sub":
 "@[simp]\ntheorem to_Ioc_div_sub (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ioc_div a hb (x - b) = to_Ioc_div a hb x - 1 :=\n  by\n  convert to_Ioc_div_sub_zsmul a hb x 1\n  exact (one_zsmul _).symm\n#align to_Ioc_div_sub to_Ioc_div_sub\n\n",
 "to_Ioc_div_neg":
 "theorem to_Ioc_div_neg (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ioc_div a hb (-x) = -(to_Ico_div (-a) hb x + 1) := by\n  rw [← neg_neg x, to_Ico_div_neg, neg_neg, neg_neg, neg_add', neg_neg, add_sub_cancel]\n#align to_Ioc_div_neg to_Ioc_div_neg\n\n",
 "to_Ioc_div_eq_neg_floor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\ntheorem to_Ioc_div_eq_neg_floor (a : α) {b : α} (hb : 0 < b) (x : α) :\n    to_Ioc_div a hb x = -«expr⌊ ⌋» ((a + b - x) / b) :=\n  by\n  refine' (eq_to_Ioc_div_of_sub_zsmul_mem_Ioc hb _).symm\n  rw [Set.mem_Ioc, zsmul_eq_mul, Int.cast_neg, neg_mul, sub_neg_eq_add, ← sub_nonneg, sub_add_eq_sub_sub]\n  refine' ⟨_, Int.sub_floor_div_mul_nonneg _ hb⟩\n  rw [← add_lt_add_iff_right b, add_assoc, add_comm x, ← sub_lt_iff_lt_add, add_comm (_ * _), ← sub_lt_iff_lt_add]\n  exact Int.sub_floor_div_mul_lt _ hb\n#align to_Ioc_div_eq_neg_floor to_Ioc_div_eq_neg_floor\n\n",
 "to_Ioc_div_apply_right":
 "theorem to_Ioc_div_apply_right (a : α) {b : α} (hb : 0 < b) : to_Ioc_div a hb (a + b) = 0 :=\n  by\n  refine' (eq_to_Ioc_div_of_sub_zsmul_mem_Ioc hb _).symm\n  simp [hb]\n#align to_Ioc_div_apply_right to_Ioc_div_apply_right\n\n",
 "to_Ioc_div_apply_left":
 "@[simp]\ntheorem to_Ioc_div_apply_left (a : α) {b : α} (hb : 0 < b) : to_Ioc_div a hb a = -1 :=\n  by\n  refine' (eq_to_Ioc_div_of_sub_zsmul_mem_Ioc hb _).symm\n  simp [hb]\n#align to_Ioc_div_apply_left to_Ioc_div_apply_left\n\n",
 "to_Ioc_div_add_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ioc_div_add_zsmul (a : α) {b : α} (hb : 0 < b) (x : α) (m : ℤ) :\n    to_Ioc_div a hb (x + «expr • » m b) = to_Ioc_div a hb x + m :=\n  by\n  refine' (eq_to_Ioc_div_of_sub_zsmul_mem_Ioc hb _).symm\n  convert sub_to_Ioc_div_zsmul_mem_Ioc a hb x using 1\n  simp [add_smul]\n#align to_Ioc_div_add_zsmul to_Ioc_div_add_zsmul\n\n",
 "to_Ioc_div_add_right'":
 "theorem to_Ioc_div_add_right' (a : α) {b : α} (hb : 0 < b) (x y : α) :\n    to_Ioc_div a hb (x + y) = to_Ioc_div (a - y) hb x := by rw [← sub_neg_eq_add, to_Ioc_div_sub', sub_eq_add_neg]\n#align to_Ioc_div_add_right' to_Ioc_div_add_right'\n\n",
 "to_Ioc_div_add_right":
 "@[simp]\ntheorem to_Ioc_div_add_right (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ioc_div a hb (x + b) = to_Ioc_div a hb x + 1 :=\n  by\n  convert to_Ioc_div_add_zsmul a hb x 1\n  exact (one_zsmul _).symm\n#align to_Ioc_div_add_right to_Ioc_div_add_right\n\n",
 "to_Ioc_div_add_left":
 "@[simp]\ntheorem to_Ioc_div_add_left (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ioc_div a hb (b + x) = to_Ioc_div a hb x + 1 := by\n  rw [add_comm, to_Ioc_div_add_right]\n#align to_Ioc_div_add_left to_Ioc_div_add_left\n\n",
 "to_Ico_mod_zsmul_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ico_mod_zsmul_add (a : α) {b : α} (hb : 0 < b) (x : α) (m : ℤ) :\n    to_Ico_mod a hb («expr • » m b + x) = to_Ico_mod a hb x := by rw [add_comm, to_Ico_mod_add_zsmul]\n#align to_Ico_mod_zsmul_add to_Ico_mod_zsmul_add\n\n",
 "to_Ico_mod_zero_one":
 "theorem to_Ico_mod_zero_one (x : α) : to_Ico_mod (0 : α) zero_lt_one x = Int.fract x := by\n  simp [to_Ico_mod_eq_add_fract_mul]\n#align to_Ico_mod_zero_one to_Ico_mod_zero_one\n\n",
 "to_Ico_mod_to_Ioc_mod":
 "@[simp]\ntheorem to_Ico_mod_to_Ioc_mod (a₁ a₂ : α) {b : α} (hb : 0 < b) (x : α) :\n    to_Ico_mod a₁ hb (to_Ioc_mod a₂ hb x) = to_Ico_mod a₁ hb x :=\n  by\n  rw [to_Ico_mod_eq_to_Ico_mod]\n  exact ⟨to_Ioc_div a₂ hb x, self_sub_to_Ioc_mod a₂ hb x⟩\n#align to_Ico_mod_to_Ioc_mod to_Ico_mod_to_Ioc_mod\n\n",
 "to_Ico_mod_to_Ico_mod":
 "@[simp]\ntheorem to_Ico_mod_to_Ico_mod (a₁ a₂ : α) {b : α} (hb : 0 < b) (x : α) :\n    to_Ico_mod a₁ hb (to_Ico_mod a₂ hb x) = to_Ico_mod a₁ hb x :=\n  by\n  rw [to_Ico_mod_eq_to_Ico_mod]\n  exact ⟨to_Ico_div a₂ hb x, self_sub_to_Ico_mod a₂ hb x⟩\n#align to_Ico_mod_to_Ico_mod to_Ico_mod_to_Ico_mod\n\n",
 "to_Ico_mod_sub_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ico_mod_sub_zsmul (a : α) {b : α} (hb : 0 < b) (x : α) (m : ℤ) :\n    to_Ico_mod a hb (x - «expr • » m b) = to_Ico_mod a hb x := by rw [sub_eq_add_neg, ← neg_smul, to_Ico_mod_add_zsmul]\n#align to_Ico_mod_sub_zsmul to_Ico_mod_sub_zsmul\n\n",
 "to_Ico_mod_sub_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ico_mod_sub_self (a : α) {b : α} (hb : 0 < b) (x : α) :\n    to_Ico_mod a hb x - x = «expr • » (-to_Ico_div a hb x) b := by rw [to_Ico_mod, sub_sub_cancel_left, neg_smul]\n#align to_Ico_mod_sub_self to_Ico_mod_sub_self\n\n",
 "to_Ico_mod_sub'":
 "theorem to_Ico_mod_sub' (a : α) {b : α} (hb : 0 < b) (x y : α) :\n    to_Ico_mod a hb (x - y) = to_Ico_mod (a + y) hb x - y := by simp_rw [to_Ico_mod, to_Ico_div_sub', sub_right_comm]\n#align to_Ico_mod_sub' to_Ico_mod_sub'\n\n",
 "to_Ico_mod_sub":
 "@[simp]\ntheorem to_Ico_mod_sub (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ico_mod a hb (x - b) = to_Ico_mod a hb x :=\n  by\n  convert to_Ico_mod_sub_zsmul a hb x 1\n  exact (one_zsmul _).symm\n#align to_Ico_mod_sub to_Ico_mod_sub\n\n",
 "to_Ico_mod_periodic":
 "theorem to_Ico_mod_periodic (a : α) {b : α} (hb : 0 < b) : function.periodic (to_Ico_mod a hb) b :=\n  to_Ico_mod_add_right a hb\n#align to_Ico_mod_periodic to_Ico_mod_periodic\n\n",
 "to_Ico_mod_neg":
 "theorem to_Ico_mod_neg (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ico_mod a hb (-x) = b - to_Ioc_mod (-a) hb x :=\n  by\n  simp_rw [to_Ico_mod, to_Ioc_mod, to_Ico_div_neg, neg_smul, add_smul]\n  abel\n#align to_Ico_mod_neg to_Ico_mod_neg\n\n",
 "to_Ico_mod_mem_Ico'":
 "theorem to_Ico_mod_mem_Ico' {b : α} (hb : 0 < b) (x : α) : to_Ico_mod 0 hb x ∈ Set.Ico 0 b :=\n  by\n  convert to_Ico_mod_mem_Ico 0 hb x\n  exact (zero_add b).symm\n#align to_Ico_mod_mem_Ico' to_Ico_mod_mem_Ico'\n\n",
 "to_Ico_mod_mem_Ico":
 "theorem to_Ico_mod_mem_Ico (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ico_mod a hb x ∈ Set.Ico a (a + b) :=\n  sub_to_Ico_div_zsmul_mem_Ico a hb x\n#align to_Ico_mod_mem_Ico to_Ico_mod_mem_Ico\n\n",
 "to_Ico_mod_lt_right":
 "theorem to_Ico_mod_lt_right (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ico_mod a hb x < a + b :=\n  (Set.mem_Ico.1 (to_Ico_mod_mem_Ico a hb x)).2\n#align to_Ico_mod_lt_right to_Ico_mod_lt_right\n\n",
 "to_Ico_mod_le_to_Ioc_mod":
 "theorem to_Ico_mod_le_to_Ioc_mod (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ico_mod a hb x ≤ to_Ioc_mod a hb x :=\n  by\n  rw [to_Ico_mod, to_Ioc_mod, sub_le_sub_iff_left]\n  exact zsmul_mono_left hb.le (to_Ioc_div_wcovby_to_Ico_div _ _ _).le\n#align to_Ico_mod_le_to_Ioc_mod to_Ico_mod_le_to_Ioc_mod\n\n",
 "to_Ico_mod_eq_to_Ico_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem to_Ico_mod_eq_to_Ico_mod (a : α) {b x y : α} (hb : 0 < b) :\n    to_Ico_mod a hb x = to_Ico_mod a hb y ↔ ∃ z : ℤ, y - x = «expr • » z b :=\n  by\n  refine' ⟨fun h => ⟨to_Ico_div a hb y - to_Ico_div a hb x, _⟩, fun h => _⟩\n  · conv_lhs => rw [← to_Ico_mod_add_to_Ico_div_zsmul a hb x, ← to_Ico_mod_add_to_Ico_div_zsmul a hb y]\n    rw [h, sub_smul]\n    abel\n  · rcases h with ⟨z, hz⟩\n    rw [sub_eq_iff_eq_add] at hz\n    rw [hz, to_Ico_mod_zsmul_add]\n#align to_Ico_mod_eq_to_Ico_mod to_Ico_mod_eq_to_Ico_mod\n\n",
 "to_Ico_mod_eq_self":
 "theorem to_Ico_mod_eq_self {a b x : α} (hb : 0 < b) : to_Ico_mod a hb x = x ↔ x ∈ Set.Ico a (a + b) :=\n  by\n  rw [to_Ico_mod_eq_iff, and_iff_left]\n  refine' ⟨0, _⟩\n  simp\n#align to_Ico_mod_eq_self to_Ico_mod_eq_self\n\n",
 "to_Ico_mod_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem to_Ico_mod_eq_iff {a b x y : α} (hb : 0 < b) :\n    to_Ico_mod a hb x = y ↔ y ∈ Set.Ico a (a + b) ∧ ∃ z : ℤ, x = y + «expr • » z b :=\n  by\n  refine'\n    ⟨fun h => ⟨h ▸ to_Ico_mod_mem_Ico a hb x, to_Ico_div a hb x, h ▸ (to_Ico_mod_add_to_Ico_div_zsmul _ _ _).symm⟩,\n      fun h => _⟩\n  rcases h with ⟨hy, z, hz⟩\n  rw [← sub_eq_iff_eq_add] at hz\n  subst hz\n  rw [eq_to_Ico_div_of_sub_zsmul_mem_Ico hb hy]\n  rfl\n#align to_Ico_mod_eq_iff to_Ico_mod_eq_iff\n\n",
 "to_Ico_mod_eq_fract_mul":
 "theorem to_Ico_mod_eq_fract_mul {b : α} (hb : 0 < b) (x : α) : to_Ico_mod 0 hb x = Int.fract (x / b) * b := by\n  simp [to_Ico_mod_eq_add_fract_mul]\n#align to_Ico_mod_eq_fract_mul to_Ico_mod_eq_fract_mul\n\n",
 "to_Ico_mod_eq_add_fract_mul":
 "theorem to_Ico_mod_eq_add_fract_mul (a : α) {b : α} (hb : 0 < b) (x : α) :\n    to_Ico_mod a hb x = a + Int.fract ((x - a) / b) * b :=\n  by\n  rw [to_Ico_mod, to_Ico_div_eq_floor, Int.fract]\n  field_simp [hb.ne.symm]\n  ring\n#align to_Ico_mod_eq_add_fract_mul to_Ico_mod_eq_add_fract_mul\n\n",
 "to_Ico_mod_apply_right":
 "theorem to_Ico_mod_apply_right (a : α) {b : α} (hb : 0 < b) : to_Ico_mod a hb (a + b) = a :=\n  by\n  rw [to_Ico_mod_eq_iff hb, Set.left_mem_Ico]\n  refine' ⟨lt_add_of_pos_right _ hb, 1, _⟩\n  simp\n#align to_Ico_mod_apply_right to_Ico_mod_apply_right\n\n",
 "to_Ico_mod_apply_left":
 "@[simp]\ntheorem to_Ico_mod_apply_left (a : α) {b : α} (hb : 0 < b) : to_Ico_mod a hb a = a :=\n  by\n  rw [to_Ico_mod_eq_iff hb, Set.left_mem_Ico]\n  refine' ⟨lt_add_of_pos_right _ hb, 0, _⟩\n  simp\n#align to_Ico_mod_apply_left to_Ico_mod_apply_left\n\n",
 "to_Ico_mod_add_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ico_mod_add_zsmul (a : α) {b : α} (hb : 0 < b) (x : α) (m : ℤ) :\n    to_Ico_mod a hb (x + «expr • » m b) = to_Ico_mod a hb x :=\n  by\n  rw [to_Ico_mod, to_Ico_div_add_zsmul, to_Ico_mod, add_smul]\n  abel\n#align to_Ico_mod_add_zsmul to_Ico_mod_add_zsmul\n\n",
 "to_Ico_mod_add_to_Ico_div_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ico_mod_add_to_Ico_div_zsmul (a : α) {b : α} (hb : 0 < b) (x : α) :\n    to_Ico_mod a hb x + «expr • » (to_Ico_div a hb x) b = x := by rw [to_Ico_mod, sub_add_cancel]\n#align to_Ico_mod_add_to_Ico_div_zsmul to_Ico_mod_add_to_Ico_div_zsmul\n\n",
 "to_Ico_mod_add_right'":
 "theorem to_Ico_mod_add_right' (a : α) {b : α} (hb : 0 < b) (x y : α) :\n    to_Ico_mod a hb (x + y) = to_Ico_mod (a - y) hb x + y := by\n  simp_rw [to_Ico_mod, to_Ico_div_add_right', sub_add_eq_add_sub]\n#align to_Ico_mod_add_right' to_Ico_mod_add_right'\n\n",
 "to_Ico_mod_add_right":
 "@[simp]\ntheorem to_Ico_mod_add_right (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ico_mod a hb (x + b) = to_Ico_mod a hb x :=\n  by\n  convert to_Ico_mod_add_zsmul a hb x 1\n  exact (one_zsmul _).symm\n#align to_Ico_mod_add_right to_Ico_mod_add_right\n\n",
 "to_Ico_mod_add_left":
 "@[simp]\ntheorem to_Ico_mod_add_left (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ico_mod a hb (b + x) = to_Ico_mod a hb x := by\n  rw [add_comm, to_Ico_mod_add_right]\n#align to_Ico_mod_add_left to_Ico_mod_add_left\n\n",
 "to_Ico_div_zsmul_sub_to_Ico_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ico_div_zsmul_sub_to_Ico_mod (a : α) {b : α} (hb : 0 < b) (x : α) :\n    «expr • » (to_Ico_div a hb x) b + to_Ico_mod a hb x = x := by rw [add_comm, to_Ico_mod_add_to_Ico_div_zsmul]\n#align to_Ico_div_zsmul_sub_to_Ico_mod to_Ico_div_zsmul_sub_to_Ico_mod\n\n",
 "to_Ico_div_zsmul_sub_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ico_div_zsmul_sub_self (a : α) {b : α} (hb : 0 < b) (x : α) :\n    «expr • » (to_Ico_div a hb x) b - x = -to_Ico_mod a hb x := by rw [to_Ico_mod, neg_sub]\n#align to_Ico_div_zsmul_sub_self to_Ico_div_zsmul_sub_self\n\n",
 "to_Ico_div_zsmul_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ico_div_zsmul_add (a : α) {b : α} (hb : 0 < b) (x : α) (m : ℤ) :\n    to_Ico_div a hb («expr • » m b + x) = m + to_Ico_div a hb x := by rw [add_comm, to_Ico_div_add_zsmul, add_comm]\n#align to_Ico_div_zsmul_add to_Ico_div_zsmul_add\n\n",
 "to_Ico_div_zero_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\ntheorem to_Ico_div_zero_one (x : α) : to_Ico_div (0 : α) zero_lt_one x = «expr⌊ ⌋» x := by simp [to_Ico_div_eq_floor]\n#align to_Ico_div_zero_one to_Ico_div_zero_one\n\n",
 "to_Ico_div_sub_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ico_div_sub_zsmul (a : α) {b : α} (hb : 0 < b) (x : α) (m : ℤ) :\n    to_Ico_div a hb (x - «expr • » m b) = to_Ico_div a hb x - m := by\n  rw [sub_eq_add_neg, ← neg_smul, to_Ico_div_add_zsmul, sub_eq_add_neg]\n#align to_Ico_div_sub_zsmul to_Ico_div_sub_zsmul\n\n",
 "to_Ico_div_sub'":
 "theorem to_Ico_div_sub' (a : α) {b : α} (hb : 0 < b) (x y : α) : to_Ico_div a hb (x - y) = to_Ico_div (a + y) hb x :=\n  by\n  rw [eq_comm]\n  apply eq_to_Ico_div_of_sub_zsmul_mem_Ico\n  rw [← sub_right_comm, Set.sub_mem_Ico_iff_left, add_right_comm]\n  exact sub_to_Ico_div_zsmul_mem_Ico (a + y) hb x\n#align to_Ico_div_sub' to_Ico_div_sub'\n\n",
 "to_Ico_div_sub":
 "@[simp]\ntheorem to_Ico_div_sub (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ico_div a hb (x - b) = to_Ico_div a hb x - 1 :=\n  by\n  convert to_Ico_div_sub_zsmul a hb x 1\n  exact (one_zsmul _).symm\n#align to_Ico_div_sub to_Ico_div_sub\n\n",
 "to_Ico_div_neg":
 "theorem to_Ico_div_neg (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ico_div a hb (-x) = -(to_Ioc_div (-a) hb x + 1) :=\n  by\n  suffices to_Ico_div a hb (-x) = -to_Ioc_div (-(a + b)) hb x by\n    rwa [neg_add, ← sub_eq_add_neg, ← to_Ioc_div_add_right', to_Ioc_div_add_right] at this\n  rw [eq_neg_iff_eq_neg, eq_comm]\n  apply eq_to_Ioc_div_of_sub_zsmul_mem_Ioc\n  obtain ⟨hc, ho⟩ := sub_to_Ico_div_zsmul_mem_Ico a hb (-x)\n  rw [← neg_lt_neg_iff, neg_sub' (-x), neg_neg, ← neg_smul] at ho\n  rw [← neg_le_neg_iff, neg_sub' (-x), neg_neg, ← neg_smul] at hc\n  refine' ⟨ho, hc.trans_eq _⟩\n  rw [neg_add, neg_add_cancel_right]\n#align to_Ico_div_neg to_Ico_div_neg\n\n",
 "to_Ico_div_eq_floor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\ntheorem to_Ico_div_eq_floor (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ico_div a hb x = «expr⌊ ⌋» ((x - a) / b) :=\n  by\n  refine' (eq_to_Ico_div_of_sub_zsmul_mem_Ico hb _).symm\n  rw [Set.mem_Ico, zsmul_eq_mul, ← sub_nonneg, add_comm, sub_right_comm, ← sub_lt_iff_lt_add, sub_right_comm _ _ a]\n  exact ⟨Int.sub_floor_div_mul_nonneg _ hb, Int.sub_floor_div_mul_lt _ hb⟩\n#align to_Ico_div_eq_floor to_Ico_div_eq_floor\n\n",
 "to_Ico_div_apply_right":
 "theorem to_Ico_div_apply_right (a : α) {b : α} (hb : 0 < b) : to_Ico_div a hb (a + b) = 1 :=\n  by\n  refine' (eq_to_Ico_div_of_sub_zsmul_mem_Ico hb _).symm\n  simp [hb]\n#align to_Ico_div_apply_right to_Ico_div_apply_right\n\n",
 "to_Ico_div_apply_left":
 "@[simp]\ntheorem to_Ico_div_apply_left (a : α) {b : α} (hb : 0 < b) : to_Ico_div a hb a = 0 :=\n  by\n  refine' (eq_to_Ico_div_of_sub_zsmul_mem_Ico hb _).symm\n  simp [hb]\n#align to_Ico_div_apply_left to_Ico_div_apply_left\n\n",
 "to_Ico_div_add_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_Ico_div_add_zsmul (a : α) {b : α} (hb : 0 < b) (x : α) (m : ℤ) :\n    to_Ico_div a hb (x + «expr • » m b) = to_Ico_div a hb x + m :=\n  by\n  refine' (eq_to_Ico_div_of_sub_zsmul_mem_Ico hb _).symm\n  convert sub_to_Ico_div_zsmul_mem_Ico a hb x using 1\n  simp [add_smul]\n#align to_Ico_div_add_zsmul to_Ico_div_add_zsmul\n\n",
 "to_Ico_div_add_right'":
 "theorem to_Ico_div_add_right' (a : α) {b : α} (hb : 0 < b) (x y : α) :\n    to_Ico_div a hb (x + y) = to_Ico_div (a - y) hb x := by rw [← sub_neg_eq_add, to_Ico_div_sub', sub_eq_add_neg]\n#align to_Ico_div_add_right' to_Ico_div_add_right'\n\n",
 "to_Ico_div_add_right":
 "@[simp]\ntheorem to_Ico_div_add_right (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ico_div a hb (x + b) = to_Ico_div a hb x + 1 :=\n  by\n  convert to_Ico_div_add_zsmul a hb x 1\n  exact (one_zsmul _).symm\n#align to_Ico_div_add_right to_Ico_div_add_right\n\n",
 "to_Ico_div_add_left":
 "@[simp]\ntheorem to_Ico_div_add_left (a : α) {b : α} (hb : 0 < b) (x : α) : to_Ico_div a hb (b + x) = to_Ico_div a hb x + 1 := by\n  rw [add_comm, to_Ico_div_add_right]\n#align to_Ico_div_add_left to_Ico_div_add_left\n\n",
 "tfae_mem_Ioo_mod":
 "/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `tfae_mem_Ioo_mod [])\n      (Command.declSig\n       []\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `mem_Ioo_mod [`a `b `x])\n            \",\"\n            («term_=_» (Term.app `to_Ico_mod [`a `hb `x]) \"=\" (Term.app `to_Ioc_mod [`a `hb `x]))\n            \",\"\n            («term_≠_» («term_+_» (Term.app `to_Ico_mod [`a `hb `x]) \"+\" `b) \"≠\" (Term.app `to_Ioc_mod [`a `hb `x]))\n            \",\"\n            («term_≠_» (Term.app `to_Ico_mod [`a `hb `x]) \"≠\" `a)]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact\n              \"exact\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [(Term.anonymousCtor \"⟨\" [`i \",\" `hi] \"⟩\")]\n                []\n                \"=>\"\n                (Term.app\n                 (Term.proj\n                  (Term.app\n                   (Term.proj (Term.app `to_Ico_mod_eq_iff [`hb]) \".\" (fieldIdx \"2\"))\n                   [(Term.anonymousCtor\n                     \"⟨\"\n                     [(Term.app `Set.Ioo_subset_Ico_self [`hi])\n                      \",\"\n                      `i\n                      \",\"\n                      (Term.proj (Term.app `sub_add_cancel [`x (Term.hole \"_\")]) \".\" `symm)]\n                     \"⟩\")])\n                  \".\"\n                  `trans)\n                 [(Term.proj\n                   (Term.app\n                    (Term.proj (Term.app `to_Ioc_mod_eq_iff [`hb]) \".\" (fieldIdx \"2\"))\n                    [(Term.anonymousCtor\n                      \"⟨\"\n                      [(Term.app `Set.Ioo_subset_Ioc_self [`hi])\n                       \",\"\n                       `i\n                       \",\"\n                       (Term.proj (Term.app `sub_add_cancel [`x (Term.hole \"_\")]) \".\" `symm)]\n                      \"⟩\")])\n                   \".\"\n                   `symm)]))))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`h])\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule [] `h) \",\" (Tactic.rwRule [] `ne) \",\" (Tactic.rwRule [] `add_right_eq_self)]\n               \"]\")\n              [])\n             []\n             (Tactic.exact \"exact\" `hb.ne')])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.refine' \"refine'\" (Term.app `mt [(Term.fun \"fun\" (Term.basicFun [`h] [] \"=>\" (Term.hole \"_\")))]))\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule [] `h)\n                \",\"\n                (Tactic.rwRule [] `eq_comm)\n                \",\"\n                (Tactic.rwRule [] `to_Ioc_mod_eq_iff)\n                \",\"\n                (Tactic.rwRule [] `Set.right_mem_Ioc)]\n               \"]\")\n              [])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [(Term.app `lt_add_of_pos_right [`a `hb])\n                \",\"\n                («term_-_» (Term.app `to_Ico_div [`a `hb `x]) \"-\" (num \"1\"))\n                \",\"\n                (Term.hole \"_\")]\n               \"⟩\"))\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule [] `sub_one_zsmul)\n                \",\"\n                (Tactic.rwRule [] `add_add_add_comm)\n                \",\"\n                (Tactic.rwRule [] `add_right_neg)\n                \",\"\n                (Tactic.rwRule [] `add_zero)]\n               \"]\")\n              [])\n             []\n             (Mathlib.Tactic.Conv.convLHS\n              \"conv_lhs\"\n              []\n              []\n              \"=>\"\n              (Tactic.Conv.convSeq\n               (Tactic.Conv.convSeq1Indented\n                [(Tactic.Conv.convRw__\n                  \"rw\"\n                  []\n                  (Tactic.rwRuleSeq\n                   \"[\"\n                   [(Tactic.rwRule\n                     [(patternIgnore (token.«← » \"←\"))]\n                     (Term.app `to_Ico_mod_add_to_Ico_div_zsmul [`a `hb `x]))\n                    \",\"\n                    (Tactic.rwRule [] `h)]\n                   \"]\"))])))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.tacticHave_\n              \"have\"\n              (Term.haveDecl (Term.haveIdDecl [`h' []] [] \":=\" (Term.app `to_Ico_mod_mem_Ico [`a `hb `x]))))\n             []\n             (Tactic.exact\n              \"exact\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`h]\n                []\n                \"=>\"\n                (Term.anonymousCtor\n                 \"⟨\"\n                 [(Term.hole \"_\")\n                  \",\"\n                  (Term.app (Term.proj (Term.proj `h' \".\" (fieldIdx \"1\")) \".\" `lt_of_ne') [`h])\n                  \",\"\n                  (Term.proj `h' \".\" (fieldIdx \"2\"))]\n                 \"⟩\"))))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact\n             \"exact\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [(Term.anonymousCtor \"⟨\" [`i \",\" `hi] \"⟩\")]\n               []\n               \"=>\"\n               (Term.app\n                (Term.proj\n                 (Term.app\n                  (Term.proj (Term.app `to_Ico_mod_eq_iff [`hb]) \".\" (fieldIdx \"2\"))\n                  [(Term.anonymousCtor\n                    \"⟨\"\n                    [(Term.app `Set.Ioo_subset_Ico_self [`hi])\n                     \",\"\n                     `i\n                     \",\"\n                     (Term.proj (Term.app `sub_add_cancel [`x (Term.hole \"_\")]) \".\" `symm)]\n                    \"⟩\")])\n                 \".\"\n                 `trans)\n                [(Term.proj\n                  (Term.app\n                   (Term.proj (Term.app `to_Ioc_mod_eq_iff [`hb]) \".\" (fieldIdx \"2\"))\n                   [(Term.anonymousCtor\n                     \"⟨\"\n                     [(Term.app `Set.Ioo_subset_Ioc_self [`hi])\n                      \",\"\n                      `i\n                      \",\"\n                      (Term.proj (Term.app `sub_add_cancel [`x (Term.hole \"_\")]) \".\" `symm)]\n                     \"⟩\")])\n                  \".\"\n                  `symm)]))))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`h])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [] `h) \",\" (Tactic.rwRule [] `ne) \",\" (Tactic.rwRule [] `add_right_eq_self)]\n              \"]\")\n             [])\n            []\n            (Tactic.exact \"exact\" `hb.ne')])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.refine' \"refine'\" (Term.app `mt [(Term.fun \"fun\" (Term.basicFun [`h] [] \"=>\" (Term.hole \"_\")))]))\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [] `h)\n               \",\"\n               (Tactic.rwRule [] `eq_comm)\n               \",\"\n               (Tactic.rwRule [] `to_Ioc_mod_eq_iff)\n               \",\"\n               (Tactic.rwRule [] `Set.right_mem_Ioc)]\n              \"]\")\n             [])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [(Term.app `lt_add_of_pos_right [`a `hb])\n               \",\"\n               («term_-_» (Term.app `to_Ico_div [`a `hb `x]) \"-\" (num \"1\"))\n               \",\"\n               (Term.hole \"_\")]\n              \"⟩\"))\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [] `sub_one_zsmul)\n               \",\"\n               (Tactic.rwRule [] `add_add_add_comm)\n               \",\"\n               (Tactic.rwRule [] `add_right_neg)\n               \",\"\n               (Tactic.rwRule [] `add_zero)]\n              \"]\")\n             [])\n            []\n            (Mathlib.Tactic.Conv.convLHS\n             \"conv_lhs\"\n             []\n             []\n             \"=>\"\n             (Tactic.Conv.convSeq\n              (Tactic.Conv.convSeq1Indented\n               [(Tactic.Conv.convRw__\n                 \"rw\"\n                 []\n                 (Tactic.rwRuleSeq\n                  \"[\"\n                  [(Tactic.rwRule\n                    [(patternIgnore (token.«← » \"←\"))]\n                    (Term.app `to_Ico_mod_add_to_Ico_div_zsmul [`a `hb `x]))\n                   \",\"\n                   (Tactic.rwRule [] `h)]\n                  \"]\"))])))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.tacticHave_\n             \"have\"\n             (Term.haveDecl (Term.haveIdDecl [`h' []] [] \":=\" (Term.app `to_Ico_mod_mem_Ico [`a `hb `x]))))\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`h]\n               []\n               \"=>\"\n               (Term.anonymousCtor\n                \"⟨\"\n                [(Term.hole \"_\")\n                 \",\"\n                 (Term.app (Term.proj (Term.proj `h' \".\" (fieldIdx \"1\")) \".\" `lt_of_ne') [`h])\n                 \",\"\n                 (Term.proj `h' \".\" (fieldIdx \"2\"))]\n                \"⟩\"))))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.tacticHave_\n         \"have\"\n         (Term.haveDecl (Term.haveIdDecl [`h' []] [] \":=\" (Term.app `to_Ico_mod_mem_Ico [`a `hb `x]))))\n        []\n        (Tactic.exact\n         \"exact\"\n         (Term.fun\n          \"fun\"\n          (Term.basicFun\n           [`h]\n           []\n           \"=>\"\n           (Term.anonymousCtor\n            \"⟨\"\n            [(Term.hole \"_\")\n             \",\"\n             (Term.app (Term.proj (Term.proj `h' \".\" (fieldIdx \"1\")) \".\" `lt_of_ne') [`h])\n             \",\"\n             (Term.proj `h' \".\" (fieldIdx \"2\"))]\n            \"⟩\"))))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact\n       \"exact\"\n       (Term.fun\n        \"fun\"\n        (Term.basicFun\n         [`h]\n         []\n         \"=>\"\n         (Term.anonymousCtor\n          \"⟨\"\n          [(Term.hole \"_\")\n           \",\"\n           (Term.app (Term.proj (Term.proj `h' \".\" (fieldIdx \"1\")) \".\" `lt_of_ne') [`h])\n           \",\"\n           (Term.proj `h' \".\" (fieldIdx \"2\"))]\n          \"⟩\"))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun\n       \"fun\"\n       (Term.basicFun\n        [`h]\n        []\n        \"=>\"\n        (Term.anonymousCtor\n         \"⟨\"\n         [(Term.hole \"_\")\n          \",\"\n          (Term.app (Term.proj (Term.proj `h' \".\" (fieldIdx \"1\")) \".\" `lt_of_ne') [`h])\n          \",\"\n          (Term.proj `h' \".\" (fieldIdx \"2\"))]\n         \"⟩\")))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor\n       \"⟨\"\n       [(Term.hole \"_\")\n        \",\"\n        (Term.app (Term.proj (Term.proj `h' \".\" (fieldIdx \"1\")) \".\" `lt_of_ne') [`h])\n        \",\"\n        (Term.proj `h' \".\" (fieldIdx \"2\"))]\n       \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.proj `h' \".\" (fieldIdx \"2\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `h'\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app (Term.proj (Term.proj `h' \".\" (fieldIdx \"1\")) \".\" `lt_of_ne') [`h])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      (Term.proj (Term.proj `h' \".\" (fieldIdx \"1\")) \".\" `lt_of_ne')\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.proj `h' \".\" (fieldIdx \"1\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `h'\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tacticHave_\n       \"have\"\n       (Term.haveDecl (Term.haveIdDecl [`h' []] [] \":=\" (Term.app `to_Ico_mod_mem_Ico [`a `hb `x]))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `to_Ico_mod_mem_Ico [`a `hb `x])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hb\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `a\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `to_Ico_mod_mem_Ico\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  tfae_mem_Ioo_mod\n  :\n    TFAE\n      [\n        mem_Ioo_mod a b x\n          ,\n          to_Ico_mod a hb x = to_Ioc_mod a hb x\n          ,\n          to_Ico_mod a hb x + b ≠ to_Ioc_mod a hb x\n          ,\n          to_Ico_mod a hb x ≠ a\n        ]\n  :=\n    by\n      tfae_have 1 → 2\n        ·\n          exact\n            fun\n              ⟨ i , hi ⟩\n                =>\n                to_Ico_mod_eq_iff hb . 2 ⟨ Set.Ioo_subset_Ico_self hi , i , sub_add_cancel x _ . symm ⟩ . trans\n                  to_Ioc_mod_eq_iff hb . 2 ⟨ Set.Ioo_subset_Ioc_self hi , i , sub_add_cancel x _ . symm ⟩ . symm\n        tfae_have 2 → 3\n        · intro h rw [ h , ne , add_right_eq_self ] exact hb.ne'\n        tfae_have 3 → 4\n        ·\n          refine' mt fun h => _\n            rw [ h , eq_comm , to_Ioc_mod_eq_iff , Set.right_mem_Ioc ]\n            refine' ⟨ lt_add_of_pos_right a hb , to_Ico_div a hb x - 1 , _ ⟩\n            rw [ sub_one_zsmul , add_add_add_comm , add_right_neg , add_zero ]\n            conv_lhs => rw [ ← to_Ico_mod_add_to_Ico_div_zsmul a hb x , h ]\n        tfae_have 4 → 1\n        · have h' := to_Ico_mod_mem_Ico a hb x exact fun h => ⟨ _ , h' . 1 . lt_of_ne' h , h' . 2 ⟩\n        tfae_finish\n#align tfae_mem_Ioo_mod tfae_mem_Ioo_mod\n\n",
 "sub_to_Ioc_div_zsmul_mem_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sub_to_Ioc_div_zsmul_mem_Ioc (a : α) {b : α} (hb : 0 < b) (x : α) :\n    x - «expr • » (to_Ioc_div a hb x) b ∈ Set.Ioc a (a + b) :=\n  (exists_unique_sub_zsmul_mem_Ioc hb x a).some_spec.1\n#align sub_to_Ioc_div_zsmul_mem_Ioc sub_to_Ioc_div_zsmul_mem_Ioc\n\n",
 "sub_to_Ico_div_zsmul_mem_Ico":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2022 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers\n-/\ntheorem sub_to_Ico_div_zsmul_mem_Ico (a : α) {b : α} (hb : 0 < b) (x : α) :\n    x - «expr • » (to_Ico_div a hb x) b ∈ Set.Ico a (a + b) :=\n  (exists_unique_sub_zsmul_mem_Ico hb x a).some_spec.1\n#align sub_to_Ico_div_zsmul_mem_Ico sub_to_Ico_div_zsmul_mem_Ico\n\n",
 "self_sub_to_Ioc_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem self_sub_to_Ioc_mod (a : α) {b : α} (hb : 0 < b) (x : α) :\n    x - to_Ioc_mod a hb x = «expr • » (to_Ioc_div a hb x) b := by rw [to_Ioc_mod, sub_sub_cancel]\n#align self_sub_to_Ioc_mod self_sub_to_Ioc_mod\n\n",
 "self_sub_to_Ioc_div_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem self_sub_to_Ioc_div_zsmul (a : α) {b : α} (hb : 0 < b) (x : α) :\n    x - «expr • » (to_Ioc_div a hb x) b = to_Ioc_mod a hb x :=\n  rfl\n#align self_sub_to_Ioc_div_zsmul self_sub_to_Ioc_div_zsmul\n\n",
 "self_sub_to_Ico_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem self_sub_to_Ico_mod (a : α) {b : α} (hb : 0 < b) (x : α) :\n    x - to_Ico_mod a hb x = «expr • » (to_Ico_div a hb x) b := by rw [to_Ico_mod, sub_sub_cancel]\n#align self_sub_to_Ico_mod self_sub_to_Ico_mod\n\n",
 "self_sub_to_Ico_div_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem self_sub_to_Ico_div_zsmul (a : α) {b : α} (hb : 0 < b) (x : α) :\n    x - «expr • » (to_Ico_div a hb x) b = to_Ico_mod a hb x :=\n  rfl\n#align self_sub_to_Ico_div_zsmul self_sub_to_Ico_div_zsmul\n\n",
 "not_mem_Ioo_mod_iff_to_Ioc_eq_right":
 "theorem not_mem_Ioo_mod_iff_to_Ioc_eq_right : ¬mem_Ioo_mod a b x ↔ to_Ioc_mod a hb x = a + b :=\n  (mem_Ioo_mod_iff_to_Ioc_mod_ne_right hb).not_left\n#align not_mem_Ioo_mod_iff_to_Ioc_eq_right not_mem_Ioo_mod_iff_to_Ioc_eq_right\n\n",
 "not_mem_Ioo_mod_iff_to_Ico_mod_eq_left":
 "theorem not_mem_Ioo_mod_iff_to_Ico_mod_eq_left : ¬mem_Ioo_mod a b x ↔ to_Ico_mod a hb x = a :=\n  (mem_Ioo_mod_iff_to_Ico_mod_ne_left hb).not_left\n#align not_mem_Ioo_mod_iff_to_Ico_mod_eq_left not_mem_Ioo_mod_iff_to_Ico_mod_eq_left\n\n",
 "not_mem_Ioo_mod_iff_to_Ico_mod_add_period_eq_to_Ioc_mod":
 "theorem not_mem_Ioo_mod_iff_to_Ico_mod_add_period_eq_to_Ioc_mod :\n    ¬mem_Ioo_mod a b x ↔ to_Ico_mod a hb x + b = to_Ioc_mod a hb x :=\n  (mem_Ioo_mod_iff_to_Ico_mod_add_period_ne_to_Ioc_mod hb).not_left\n#align not_mem_Ioo_mod_iff_to_Ico_mod_add_period_eq_to_Ioc_mod not_mem_Ioo_mod_iff_to_Ico_mod_add_period_eq_to_Ioc_mod\n\n",
 "not_mem_Ioo_mod_iff_to_Ico_div_eq_to_Ioc_div_add_one":
 "theorem not_mem_Ioo_mod_iff_to_Ico_div_eq_to_Ioc_div_add_one :\n    ¬mem_Ioo_mod a b x ↔ to_Ico_div a hb x = to_Ioc_div a hb x + 1 :=\n  (mem_Ioo_mod_iff_to_Ico_div_ne_to_Ioc_div_add_one hb).not_left\n#align not_mem_Ioo_mod_iff_to_Ico_div_eq_to_Ioc_div_add_one not_mem_Ioo_mod_iff_to_Ico_div_eq_to_Ioc_div_add_one\n\n",
 "not_mem_Ioo_mod_iff_eq_mod_zmultiples":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem not_mem_Ioo_mod_iff_eq_mod_zmultiples :\n    ¬mem_Ioo_mod a b x ↔ (x : «expr ⧸ » α (add_subgroup.zmultiples b)) = a := by\n  simp_rw [not_mem_Ioo_mod_iff_eq_add_zsmul hb, quotient_add_group.eq_iff_sub_mem, add_subgroup.mem_zmultiples_iff,\n    eq_sub_iff_add_eq', eq_comm]\n#align not_mem_Ioo_mod_iff_eq_mod_zmultiples not_mem_Ioo_mod_iff_eq_mod_zmultiples\n\n",
 "not_mem_Ioo_mod_iff_eq_add_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem not_mem_Ioo_mod_iff_eq_add_zsmul : ¬mem_Ioo_mod a b x ↔ ∃ z : ℤ, x = a + «expr • » z b := by\n  simpa only [not_forall, not_ne_iff] using (mem_Ioo_mod_iff_ne_add_zsmul hb).not\n#align not_mem_Ioo_mod_iff_eq_add_zsmul not_mem_Ioo_mod_iff_eq_add_zsmul\n\n",
 "mem_Ioo_mod_iff_to_Ioc_mod_ne_right":
 "theorem mem_Ioo_mod_iff_to_Ioc_mod_ne_right : mem_Ioo_mod a b x ↔ to_Ioc_mod a hb x ≠ a + b :=\n  by\n  rw [mem_Ioo_mod_iff_to_Ico_mod_eq_to_Ioc_mod, to_Ico_mod_eq_iff hb]\n  obtain ⟨h₁, h₂⟩ := to_Ioc_mod_mem_Ioc a hb x\n  exact ⟨fun h => h.1.2.ne, fun h => ⟨⟨h₁.le, h₂.lt_of_ne h⟩, _, (to_Ioc_mod_add_to_Ioc_div_zsmul _ _ _).symm⟩⟩\n#align mem_Ioo_mod_iff_to_Ioc_mod_ne_right mem_Ioo_mod_iff_to_Ioc_mod_ne_right\n\n",
 "mem_Ioo_mod_iff_to_Ico_mod_ne_left":
 "theorem mem_Ioo_mod_iff_to_Ico_mod_ne_left : mem_Ioo_mod a b x ↔ to_Ico_mod a hb x ≠ a :=\n  (tfae_mem_Ioo_mod a hb x).out 0 3\n#align mem_Ioo_mod_iff_to_Ico_mod_ne_left mem_Ioo_mod_iff_to_Ico_mod_ne_left\n\n",
 "mem_Ioo_mod_iff_to_Ico_mod_eq_to_Ioc_mod":
 "theorem mem_Ioo_mod_iff_to_Ico_mod_eq_to_Ioc_mod : mem_Ioo_mod a b x ↔ to_Ico_mod a hb x = to_Ioc_mod a hb x :=\n  (tfae_mem_Ioo_mod a hb x).out 0 1\n#align mem_Ioo_mod_iff_to_Ico_mod_eq_to_Ioc_mod mem_Ioo_mod_iff_to_Ico_mod_eq_to_Ioc_mod\n\n",
 "mem_Ioo_mod_iff_to_Ico_mod_add_period_ne_to_Ioc_mod":
 "theorem mem_Ioo_mod_iff_to_Ico_mod_add_period_ne_to_Ioc_mod :\n    mem_Ioo_mod a b x ↔ to_Ico_mod a hb x + b ≠ to_Ioc_mod a hb x :=\n  (tfae_mem_Ioo_mod a hb x).out 0 2\n#align mem_Ioo_mod_iff_to_Ico_mod_add_period_ne_to_Ioc_mod mem_Ioo_mod_iff_to_Ico_mod_add_period_ne_to_Ioc_mod\n\n",
 "mem_Ioo_mod_iff_to_Ico_div_ne_to_Ioc_div_add_one":
 "theorem mem_Ioo_mod_iff_to_Ico_div_ne_to_Ioc_div_add_one :\n    mem_Ioo_mod a b x ↔ to_Ico_div a hb x ≠ to_Ioc_div a hb x + 1 := by\n  rw [mem_Ioo_mod_iff_to_Ico_mod_add_period_ne_to_Ioc_mod hb, ne, ne, to_Ico_mod, to_Ioc_mod, ← eq_sub_iff_add_eq,\n    sub_sub, sub_right_inj, ← add_one_zsmul, (zsmul_strictMono_left hb).injective.eq_iff]\n#align mem_Ioo_mod_iff_to_Ico_div_ne_to_Ioc_div_add_one mem_Ioo_mod_iff_to_Ico_div_ne_to_Ioc_div_add_one\n\n",
 "mem_Ioo_mod_iff_to_Ico_div_eq_to_Ioc_div":
 "theorem mem_Ioo_mod_iff_to_Ico_div_eq_to_Ioc_div : mem_Ioo_mod a b x ↔ to_Ico_div a hb x = to_Ioc_div a hb x := by\n  rw [mem_Ioo_mod_iff_to_Ico_mod_eq_to_Ioc_mod hb, to_Ico_mod, to_Ioc_mod, sub_right_inj,\n    (zsmul_strictMono_left hb).injective.eq_iff]\n#align mem_Ioo_mod_iff_to_Ico_div_eq_to_Ioc_div mem_Ioo_mod_iff_to_Ico_div_eq_to_Ioc_div\n\n",
 "mem_Ioo_mod_iff_ne_mod_zmultiples":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem mem_Ioo_mod_iff_ne_mod_zmultiples : mem_Ioo_mod a b x ↔ (x : «expr ⧸ » α (add_subgroup.zmultiples b)) ≠ a :=\n  (not_mem_Ioo_mod_iff_eq_mod_zmultiples hb).not_right\n#align mem_Ioo_mod_iff_ne_mod_zmultiples mem_Ioo_mod_iff_ne_mod_zmultiples\n\n",
 "mem_Ioo_mod_iff_ne_add_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_Ioo_mod_iff_ne_add_zsmul : mem_Ioo_mod a b x ↔ ∀ z : ℤ, x ≠ a + «expr • » z b :=\n  by\n  rw [mem_Ioo_mod_iff_to_Ico_mod_ne_left hb, ← not_iff_not]\n  push_neg; constructor <;> intro h\n  · rw [← h]\n    exact ⟨_, (to_Ico_mod_add_to_Ico_div_zsmul _ _ _).symm⟩\n  · rw [to_Ico_mod_eq_iff, Set.left_mem_Ico]\n    exact ⟨lt_add_of_pos_right a hb, h⟩\n#align mem_Ioo_mod_iff_ne_add_zsmul mem_Ioo_mod_iff_ne_add_zsmul\n\n",
 "left_lt_to_Ioc_mod":
 "theorem left_lt_to_Ioc_mod (a : α) {b : α} (hb : 0 < b) (x : α) : a < to_Ioc_mod a hb x :=\n  (Set.mem_Ioc.1 (to_Ioc_mod_mem_Ioc a hb x)).1\n#align left_lt_to_Ioc_mod left_lt_to_Ioc_mod\n\n",
 "left_le_to_Ico_mod":
 "theorem left_le_to_Ico_mod (a : α) {b : α} (hb : 0 < b) (x : α) : a ≤ to_Ico_mod a hb x :=\n  (Set.mem_Ico.1 (to_Ico_mod_mem_Ico a hb x)).1\n#align left_le_to_Ico_mod left_le_to_Ico_mod\n\n",
 "equiv_Ioc_mod_coe":
 "@[simp]\ntheorem quotient_add_group.equiv_Ioc_mod_coe (a : α) {b : α} (hb : 0 < b) (x : α) :\n    quotient_add_group.equiv_Ioc_mod a hb ↑x = ⟨to_Ioc_mod a hb x, to_Ioc_mod_mem_Ioc a hb _⟩ :=\n  rfl\n#align quotient_add_group.equiv_Ioc_mod_coe quotient_add_group.equiv_Ioc_mod_coe\n\n",
 "equiv_Ico_mod_coe":
 "@[simp]\ntheorem quotient_add_group.equiv_Ico_mod_coe (a : α) {b : α} (hb : 0 < b) (x : α) :\n    quotient_add_group.equiv_Ico_mod a hb ↑x = ⟨to_Ico_mod a hb x, to_Ico_mod_mem_Ico a hb _⟩ :=\n  rfl\n#align quotient_add_group.equiv_Ico_mod_coe quotient_add_group.equiv_Ico_mod_coe\n\n",
 "eq_to_Ioc_div_of_sub_zsmul_mem_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem eq_to_Ioc_div_of_sub_zsmul_mem_Ioc {a b x : α} (hb : 0 < b) {y : ℤ}\n    (hy : x - «expr • » y b ∈ Set.Ioc a (a + b)) : y = to_Ioc_div a hb x :=\n  (exists_unique_sub_zsmul_mem_Ioc hb x a).some_spec.2 y hy\n#align eq_to_Ioc_div_of_sub_zsmul_mem_Ioc eq_to_Ioc_div_of_sub_zsmul_mem_Ioc\n\n",
 "eq_to_Ico_div_of_sub_zsmul_mem_Ico":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem eq_to_Ico_div_of_sub_zsmul_mem_Ico {a b x : α} (hb : 0 < b) {y : ℤ}\n    (hy : x - «expr • » y b ∈ Set.Ico a (a + b)) : y = to_Ico_div a hb x :=\n  (exists_unique_sub_zsmul_mem_Ico hb x a).some_spec.2 y hy\n#align eq_to_Ico_div_of_sub_zsmul_mem_Ico eq_to_Ico_div_of_sub_zsmul_mem_Ico\n\n",
 "Ico_eq_locus_Ioc_eq_Union_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem Ico_eq_locus_Ioc_eq_Union_Ioo :\n    { x | to_Ico_mod a hb x = to_Ioc_mod a hb x } =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (Set.Ioo (a + «expr • » z b) (a + b + «expr • » z b)) :=\n  by\n  ext1; simp_rw [Set.mem_setOf, Set.mem_unionᵢ, ← Set.sub_mem_Ioo_iff_left]\n  exact (mem_Ioo_mod_iff_to_Ico_mod_eq_to_Ioc_mod hb).symm\n#align Ico_eq_locus_Ioc_eq_Union_Ioo Ico_eq_locus_Ioc_eq_Union_Ioo\n\n"}