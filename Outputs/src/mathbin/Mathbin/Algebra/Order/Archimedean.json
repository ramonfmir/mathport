{"pow_unbounded_of_one_lt":
 "#print pow_unbounded_of_one_lt /-\ntheorem pow_unbounded_of_one_lt (x : α) {y : α} (hy1 : 1 < y) : ∃ n : ℕ, x < y ^ n :=\n  sub_add_cancel y 1 ▸ add_one_pow_unbounded_of_pos _ (sub_pos.2 hy1)\n#align pow_unbounded_of_one_lt pow_unbounded_of_one_lt\n-/\n\n",
 "le_of_forall_rat_lt_imp_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print le_of_forall_rat_lt_imp_le /-\ntheorem le_of_forall_rat_lt_imp_le (h : ∀ q : exprℚ, (q : α) < x → (q : α) ≤ y) : x ≤ y :=\n  le_of_not_lt fun hyx =>\n    let ⟨q, hy, hx⟩ := exists_rat_btwn hyx\n    hy.not_le <| h _ hx\n#align le_of_forall_rat_lt_imp_le le_of_forall_rat_lt_imp_le\n-/\n\n",
 "le_of_forall_lt_rat_imp_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print le_of_forall_lt_rat_imp_le /-\ntheorem le_of_forall_lt_rat_imp_le (h : ∀ q : exprℚ, y < q → x ≤ q) : x ≤ y :=\n  le_of_not_lt fun hyx =>\n    let ⟨q, hy, hx⟩ := exists_rat_btwn hyx\n    hx.not_le <| h _ hy\n#align le_of_forall_lt_rat_imp_le le_of_forall_lt_rat_imp_le\n-/\n\n",
 "exists_rat_near":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print exists_rat_near /-\ntheorem exists_rat_near (x : α) (ε0 : 0 < ε) : ∃ q : exprℚ, |x - q| < ε :=\n  let ⟨q, h₁, h₂⟩ := exists_rat_btwn <| ((sub_lt_self_iff x).2 ε0).trans ((lt_add_iff_pos_left x).2 ε0)\n  ⟨q, abs_sub_lt_iff.2 ⟨sub_lt_comm.1 h₁, sub_lt_iff_lt_add.2 h₂⟩⟩\n#align exists_rat_near exists_rat_near\n-/\n\n",
 "exists_rat_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print exists_rat_lt /-\ntheorem exists_rat_lt (x : α) : ∃ q : exprℚ, (q : α) < x :=\n  let ⟨n, h⟩ := exists_int_lt x\n  ⟨n, by rwa [Rat.cast_coe_int]⟩\n#align exists_rat_lt exists_rat_lt\n-/\n\n",
 "exists_rat_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print exists_rat_gt /-\ntheorem exists_rat_gt (x : α) : ∃ q : exprℚ, x < q :=\n  let ⟨n, h⟩ := exists_nat_gt x\n  ⟨n, by rwa [Rat.cast_coe_nat]⟩\n#align exists_rat_gt exists_rat_gt\n-/\n\n",
 "exists_rat_btwn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print exists_rat_btwn /-\ntheorem exists_rat_btwn {x y : α} (h : x < y) : ∃ q : exprℚ, x < q ∧ (q : α) < y :=\n  by\n  cases' exists_nat_gt (y - x)⁻¹ with n nh\n  cases' exists_floor (x * n) with z zh\n  refine' ⟨(z + 1 : ℤ) / n, _⟩\n  have n0' := (inv_pos.2 (sub_pos.2 h)).trans nh\n  have n0 := Nat.cast_pos.1 n0'\n  rw [Rat.cast_div_of_ne_zero, Rat.cast_coe_nat, Rat.cast_coe_int, div_lt_iff n0']\n  refine' ⟨(lt_div_iff n0').2 <| (lt_iff_lt_of_le_iff_le (zh _)).1 (lt_add_one _), _⟩\n  rw [Int.cast_add, Int.cast_one]\n  refine' lt_of_le_of_lt (add_le_add_right ((zh _).1 le_rfl) _) _\n  rwa [← lt_sub_iff_add_lt', ← sub_mul, ← div_lt_iff' (sub_pos.2 h), one_div]\n  · rw [Rat.coe_int_den, Nat.cast_one]\n    exact one_ne_zero\n  · intro H\n    rw [Rat.coe_nat_num, Int.cast_ofNat, Nat.cast_eq_zero] at H\n    subst H\n    cases n0\n  · rw [Rat.coe_nat_den, Nat.cast_one]\n    exact one_ne_zero\n#align exists_rat_btwn exists_rat_btwn\n-/\n\n",
 "exists_pow_lt_of_lt_one":
 "#print exists_pow_lt_of_lt_one /-\n/-- For any `y < 1` and any positive `x`, there exists `n : ℕ` with `y ^ n < x`. -/\ntheorem exists_pow_lt_of_lt_one (hx : 0 < x) (hy : y < 1) : ∃ n : ℕ, y ^ n < x :=\n  by\n  by_cases y_pos : y ≤ 0\n  · use 1\n    simp only [pow_one]\n    linarith\n  rw [not_le] at y_pos\n  rcases pow_unbounded_of_one_lt x⁻¹ (one_lt_inv y_pos hy) with ⟨q, hq⟩\n  exact ⟨q, by rwa [inv_pow, inv_lt_inv hx (pow_pos y_pos _)] at hq⟩\n#align exists_pow_lt_of_lt_one exists_pow_lt_of_lt_one\n-/\n\n",
 "exists_pos_rat_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print exists_pos_rat_lt /-\ntheorem exists_pos_rat_lt {x : α} (x0 : 0 < x) : ∃ q : exprℚ, 0 < q ∧ (q : α) < x := by\n  simpa only [Rat.cast_pos] using exists_rat_btwn x0\n#align exists_pos_rat_lt exists_pos_rat_lt\n-/\n\n",
 "exists_nat_pow_near_of_lt_one":
 "#print exists_nat_pow_near_of_lt_one /-\n/-- Given `x` and `y` between `0` and `1`, `x` is between two successive powers of `y`.\nThis is the same as `exists_nat_pow_near`, but for elements between `0` and `1` -/\ntheorem exists_nat_pow_near_of_lt_one (xpos : 0 < x) (hx : x ≤ 1) (ypos : 0 < y) (hy : y < 1) :\n    ∃ n : ℕ, y ^ (n + 1) < x ∧ x ≤ y ^ n :=\n  by\n  rcases exists_nat_pow_near (one_le_inv_iff.2 ⟨xpos, hx⟩) (one_lt_inv_iff.2 ⟨ypos, hy⟩) with ⟨n, hn, h'n⟩\n  refine' ⟨n, _, _⟩\n  · rwa [inv_pow, inv_lt_inv xpos (pow_pos ypos _)] at h'n\n  · rwa [inv_pow, inv_le_inv (pow_pos ypos _) xpos] at hn\n#align exists_nat_pow_near_of_lt_one exists_nat_pow_near_of_lt_one\n-/\n\n",
 "exists_nat_pow_near":
 "#print exists_nat_pow_near /-\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem exists_nat_pow_near {x : α} {y : α} (hx : 1 ≤ x) (hy : 1 < y) : ∃ n : ℕ, y ^ n ≤ x ∧ x < y ^ (n + 1) :=\n  by\n  have h : ∃ n : ℕ, x < y ^ n := pow_unbounded_of_one_lt _ hy\n  classical exact\n      let n := nat.find h\n      have hn : x < y ^ n := nat.find_spec h\n      have hnp : 0 < n := pos_iff_ne_zero.2 fun hn0 => by rw [hn0, pow_zero] at hn <;> exact not_le_of_gt hn hx\n      have hnsp : nat.pred n + 1 = n := nat.succ_pred_eq_of_pos hnp\n      have hltn : nat.pred n < n := nat.pred_lt (ne_of_gt hnp)\n      ⟨nat.pred n, le_of_not_lt (nat.find_min h hltn), by rwa [hnsp]⟩\n#align exists_nat_pow_near exists_nat_pow_near\n-/\n\n",
 "exists_nat_one_div_lt":
 "#print exists_nat_one_div_lt /-\ntheorem exists_nat_one_div_lt {ε : α} (hε : 0 < ε) : ∃ n : ℕ, 1 / (n + 1 : α) < ε :=\n  by\n  cases' exists_nat_gt (1 / ε) with n hn\n  use n\n  rw [div_lt_iff, ← div_lt_iff' hε]\n  · apply hn.trans\n    simp [zero_lt_one]\n  · exact n.cast_add_one_pos\n#align exists_nat_one_div_lt exists_nat_one_div_lt\n-/\n\n",
 "exists_nat_gt":
 "#print exists_nat_gt /-\ntheorem exists_nat_gt [StrictOrderedSemiring α] [Archimedean α] (x : α) : ∃ n : ℕ, x < n :=\n  let ⟨n, h⟩ := archimedean.arch x zero_lt_one\n  ⟨n + 1, lt_of_le_of_lt (by rwa [← nsmul_one]) (Nat.cast_lt.2 (nat.lt_succ_self _))⟩\n#align exists_nat_gt exists_nat_gt\n-/\n\n",
 "exists_nat_ge":
 "#print exists_nat_ge /-\ntheorem exists_nat_ge [StrictOrderedSemiring α] [Archimedean α] (x : α) : ∃ n : ℕ, x ≤ n :=\n  by\n  nontriviality α\n  exact (exists_nat_gt x).imp fun n => le_of_lt\n#align exists_nat_ge exists_nat_ge\n-/\n\n",
 "exists_mem_Ioc_zpow":
 "#print exists_mem_Ioc_zpow /-\n/-- Every positive `x` is between two successive integer powers of\nanother `y` greater than one. This is the same as `exists_mem_Ico_zpow`,\nbut with ≤ and < the other way around. -/\ntheorem exists_mem_Ioc_zpow (hx : 0 < x) (hy : 1 < y) : ∃ n : ℤ, x ∈ Ioc (y ^ n) (y ^ (n + 1)) :=\n  let ⟨m, hle, hlt⟩ := exists_mem_Ico_zpow (inv_pos.2 hx) hy\n  have hyp : 0 < y := lt_trans zero_lt_one hy\n  ⟨-(m + 1), by rwa [zpow_neg, inv_lt (zpow_pos_of_pos hyp _) hx], by\n    rwa [neg_add, neg_add_cancel_right, zpow_neg, le_inv hx (zpow_pos_of_pos hyp _)]⟩\n#align exists_mem_Ioc_zpow exists_mem_Ioc_zpow\n-/\n\n",
 "exists_mem_Ico_zpow":
 "#print exists_mem_Ico_zpow /-\n/-- Every positive `x` is between two successive integer powers of\nanother `y` greater than one. This is the same as `exists_mem_Ioc_zpow`,\nbut with ≤ and < the other way around. -/\ntheorem exists_mem_Ico_zpow (hx : 0 < x) (hy : 1 < y) : ∃ n : ℤ, x ∈ Ico (y ^ n) (y ^ (n + 1)) := by\n  classical exact\n      let ⟨N, hN⟩ := pow_unbounded_of_one_lt x⁻¹ hy\n      have he : ∃ m : ℤ, y ^ m ≤ x :=\n        ⟨-N,\n          le_of_lt\n            (by\n              rw [zpow_neg y ↑N, zpow_ofNat]\n              exact (inv_lt hx (lt_trans (inv_pos.2 hx) hN)).1 hN)⟩\n      let ⟨M, hM⟩ := pow_unbounded_of_one_lt x hy\n      have hb : ∃ b : ℤ, ∀ m, y ^ m ≤ x → m ≤ b :=\n        ⟨M, fun m hm =>\n          le_of_not_lt fun hlt =>\n            not_lt_of_ge (zpow_le_of_le hy.le hlt.le) (lt_of_le_of_lt hm (by rwa [← zpow_ofNat] at hM))⟩\n      let ⟨n, hn₁, hn₂⟩ := Int.exists_greatest_of_bdd hb he\n      ⟨n, hn₁, lt_of_not_ge fun hge => not_le_of_gt (int.lt_succ _) (hn₂ _ hge)⟩\n#align exists_mem_Ico_zpow exists_mem_Ico_zpow\n-/\n\n",
 "exists_int_lt":
 "#print exists_int_lt /-\ntheorem exists_int_lt (x : α) : ∃ n : ℤ, (n : α) < x :=\n  let ⟨n, h⟩ := exists_int_gt (-x)\n  ⟨-n, by rw [Int.cast_neg] <;> exact neg_lt.1 h⟩\n#align exists_int_lt exists_int_lt\n-/\n\n",
 "exists_int_gt":
 "#print exists_int_gt /-\ntheorem exists_int_gt (x : α) : ∃ n : ℤ, x < n :=\n  let ⟨n, h⟩ := exists_nat_gt x\n  ⟨n, by rwa [Int.cast_ofNat]⟩\n#align exists_int_gt exists_int_gt\n-/\n\n",
 "exists_floor":
 "#print exists_floor /-\ntheorem exists_floor (x : α) : ∃ fl : ℤ, ∀ z : ℤ, z ≤ fl ↔ (z : α) ≤ x :=\n  by\n  haveI := classical.prop_decidable\n  have : ∃ ub : ℤ, (ub : α) ≤ x ∧ ∀ z : ℤ, (z : α) ≤ x → z ≤ ub :=\n    Int.exists_greatest_of_bdd\n      (let ⟨n, hn⟩ := exists_int_gt x\n      ⟨n, fun z h' => Int.cast_le.1 <| le_trans h' <| le_of_lt hn⟩)\n      (let ⟨n, hn⟩ := exists_int_lt x\n      ⟨n, le_of_lt hn⟩)\n  refine' this.imp fun fl h z => _\n  cases' h with h₁ h₂\n  exact ⟨fun h => le_trans (Int.cast_le.2 h) h₁, h₂ z⟩\n#align exists_floor exists_floor\n-/\n\n",
 "existsUnique_zsmul_near_of_pos'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print existsUnique_zsmul_near_of_pos' /-\ntheorem existsUnique_zsmul_near_of_pos' {a : α} (ha : 0 < a) (g : α) :\n    ∃! k : ℤ, 0 ≤ g - «expr • » k a ∧ g - «expr • » k a < a := by\n  simpa only [sub_nonneg, add_zsmul, one_zsmul, sub_lt_iff_lt_add'] using existsUnique_zsmul_near_of_pos ha g\n#align exists_unique_zsmul_near_of_pos' existsUnique_zsmul_near_of_pos'\n-/\n\n",
 "existsUnique_zsmul_near_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print existsUnique_zsmul_near_of_pos /-\n/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\n/-- An archimedean decidable linearly ordered `add_comm_group` has a version of the floor: for\n`a > 0`, any `g` in the group lies between some two consecutive multiples of `a`. -/\ntheorem existsUnique_zsmul_near_of_pos {a : α} (ha : 0 < a) (g : α) :\n    ∃! k : ℤ, «expr • » k a ≤ g ∧ g < «expr • » (k + 1) a :=\n  by\n  let s : Set ℤ := { n : ℤ | «expr • » n a ≤ g }\n  obtain ⟨k, hk : -g ≤ «expr • » k a⟩ := archimedean.arch (-g) ha\n  have h_ne : s.nonempty := ⟨-k, by simpa using neg_le_neg hk⟩\n  obtain ⟨k, hk⟩ := archimedean.arch g ha\n  have h_bdd : ∀ n ∈ s, n ≤ (k : ℤ) := by\n    intro n hn\n    apply (zsmul_le_zsmul_iff ha).mp\n    rw [← coe_nat_zsmul] at hk\n    exact le_trans hn hk\n  obtain ⟨m, hm, hm'⟩ := Int.exists_greatest_of_bdd ⟨k, h_bdd⟩ h_ne\n  have hm'' : g < «expr • » (m + 1) a := by\n    contrapose! hm'\n    exact ⟨m + 1, hm', lt_add_one _⟩\n  refine' ⟨m, ⟨hm, hm''⟩, fun n hn => (hm' n hn.1).antisymm <| int.le_of_lt_add_one _⟩\n  rw [← zsmul_lt_zsmul_iff ha]\n  exact lt_of_le_of_lt hm hn.2\n#align exists_unique_zsmul_near_of_pos existsUnique_zsmul_near_of_pos\n-/\n\n",
 "existsUnique_sub_zsmul_mem_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print existsUnique_sub_zsmul_mem_Ioc /-\ntheorem existsUnique_sub_zsmul_mem_Ioc {a : α} (ha : 0 < a) (b c : α) :\n    ∃! m : ℤ, b - «expr • » m a ∈ Set.Ioc c (c + a) :=\n  (Equiv.neg ℤ).bijective.exists_unique_iff.2 <| by\n    simpa only [Equiv.neg_apply, neg_zsmul, sub_neg_eq_add] using existsUnique_add_zsmul_mem_Ioc ha b c\n#align exists_unique_sub_zsmul_mem_Ioc existsUnique_sub_zsmul_mem_Ioc\n-/\n\n",
 "existsUnique_sub_zsmul_mem_Ico":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print existsUnique_sub_zsmul_mem_Ico /-\ntheorem existsUnique_sub_zsmul_mem_Ico {a : α} (ha : 0 < a) (b c : α) :\n    ∃! m : ℤ, b - «expr • » m a ∈ Set.Ico c (c + a) := by\n  simpa only [mem_Ico, le_sub_iff_add_le, zero_add, add_comm c, sub_lt_iff_lt_add', add_assoc] using\n    existsUnique_zsmul_near_of_pos' ha (b - c)\n#align exists_unique_sub_zsmul_mem_Ico existsUnique_sub_zsmul_mem_Ico\n-/\n\n",
 "existsUnique_add_zsmul_mem_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print existsUnique_add_zsmul_mem_Ioc /-\ntheorem existsUnique_add_zsmul_mem_Ioc {a : α} (ha : 0 < a) (b c : α) :\n    ∃! m : ℤ, b + «expr • » m a ∈ Set.Ioc c (c + a) :=\n  (Equiv.addRight (1 : ℤ)).bijective.exists_unique_iff.2 <| by\n    simpa only [add_one_zsmul, sub_lt_iff_lt_add', le_sub_iff_add_le', ← add_assoc, and_comm, mem_Ioc,\n      Equiv.coe_addRight, add_le_add_iff_right] using existsUnique_zsmul_near_of_pos ha (c - b)\n#align exists_unique_add_zsmul_mem_Ioc existsUnique_add_zsmul_mem_Ioc\n-/\n\n",
 "existsUnique_add_zsmul_mem_Ico":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print existsUnique_add_zsmul_mem_Ico /-\ntheorem existsUnique_add_zsmul_mem_Ico {a : α} (ha : 0 < a) (b c : α) :\n    ∃! m : ℤ, b + «expr • » m a ∈ Set.Ico c (c + a) :=\n  (Equiv.neg ℤ).bijective.exists_unique_iff.2 <| by\n    simpa only [Equiv.neg_apply, neg_zsmul, ← sub_eq_add_neg] using existsUnique_sub_zsmul_mem_Ico ha b c\n#align exists_unique_add_zsmul_mem_Ico existsUnique_add_zsmul_mem_Ico\n-/\n\n",
 "eq_of_forall_rat_lt_iff_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print eq_of_forall_rat_lt_iff_lt /-\ntheorem eq_of_forall_rat_lt_iff_lt (h : ∀ q : exprℚ, (q : α) < x ↔ (q : α) < y) : x = y :=\n  (le_of_forall_rat_lt_imp_le fun q hq => ((h q).1 hq).le).antisymm <|\n    le_of_forall_rat_lt_imp_le fun q hq => ((h q).2 hq).le\n#align eq_of_forall_rat_lt_iff_lt eq_of_forall_rat_lt_iff_lt\n-/\n\n",
 "eq_of_forall_lt_rat_iff_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print eq_of_forall_lt_rat_iff_lt /-\ntheorem eq_of_forall_lt_rat_iff_lt (h : ∀ q : exprℚ, x < q ↔ y < q) : x = y :=\n  (le_of_forall_lt_rat_imp_le fun q hq => ((h q).2 hq).le).antisymm <|\n    le_of_forall_lt_rat_imp_le fun q hq => ((h q).1 hq).le\n#align eq_of_forall_lt_rat_iff_lt eq_of_forall_lt_rat_iff_lt\n-/\n\n",
 "archimedean_iff_rat_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print archimedean_iff_rat_lt /-\ntheorem archimedean_iff_rat_lt : Archimedean α ↔ ∀ x : α, ∃ q : exprℚ, x < q :=\n  ⟨@exists_rat_gt α _, fun H =>\n    archimedean_iff_nat_lt.2 fun x =>\n      let ⟨q, h⟩ := H x\n      ⟨«expr⌈ ⌉₊» q,\n        lt_of_lt_of_le h <| by simpa only [Rat.cast_coe_nat] using (@Rat.cast_le α _ _ _).2 (Nat.le_ceil _)⟩⟩\n#align archimedean_iff_rat_lt archimedean_iff_rat_lt\n-/\n\n",
 "archimedean_iff_rat_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print archimedean_iff_rat_le /-\ntheorem archimedean_iff_rat_le : Archimedean α ↔ ∀ x : α, ∃ q : exprℚ, x ≤ q :=\n  archimedean_iff_rat_lt.trans\n    ⟨fun H x => (H x).imp fun _ => le_of_lt, fun H x =>\n      let ⟨n, h⟩ := H x\n      ⟨n + 1, lt_of_le_of_lt h (Rat.cast_lt.2 (lt_add_one _))⟩⟩\n#align archimedean_iff_rat_le archimedean_iff_rat_le\n-/\n\n",
 "archimedean_iff_nat_lt":
 "#print archimedean_iff_nat_lt /-\ntheorem archimedean_iff_nat_lt : Archimedean α ↔ ∀ x : α, ∃ n : ℕ, x < n :=\n  ⟨@exists_nat_gt α _, fun H =>\n    ⟨fun x y y0 => (H (x / y)).imp fun n h => le_of_lt <| by rwa [div_lt_iff y0, ← nsmul_eq_mul] at h⟩⟩\n#align archimedean_iff_nat_lt archimedean_iff_nat_lt\n-/\n\n",
 "archimedean_iff_nat_le":
 "#print archimedean_iff_nat_le /-\ntheorem archimedean_iff_nat_le : Archimedean α ↔ ∀ x : α, ∃ n : ℕ, x ≤ n :=\n  archimedean_iff_nat_lt.trans\n    ⟨fun H x => (H x).imp fun _ => le_of_lt, fun H x =>\n      let ⟨n, h⟩ := H x\n      ⟨n + 1, lt_of_le_of_lt h (Nat.cast_lt.2 (lt_add_one _))⟩⟩\n#align archimedean_iff_nat_le archimedean_iff_nat_le\n-/\n\n",
 "archimedean_iff_int_lt":
 "#print archimedean_iff_int_lt /-\ntheorem archimedean_iff_int_lt : Archimedean α ↔ ∀ x : α, ∃ n : ℤ, x < n :=\n  ⟨@exists_int_gt α _, by\n    rw [archimedean_iff_nat_lt]\n    intro h x\n    obtain ⟨n, h⟩ := h x\n    refine' ⟨n.to_nat, h.trans_le _⟩\n    exact_mod_cast Int.self_le_toNat _⟩\n#align archimedean_iff_int_lt archimedean_iff_int_lt\n-/\n\n",
 "archimedean_iff_int_le":
 "#print archimedean_iff_int_le /-\ntheorem archimedean_iff_int_le : Archimedean α ↔ ∀ x : α, ∃ n : ℤ, x ≤ n :=\n  archimedean_iff_int_lt.trans\n    ⟨fun H x => (H x).imp fun _ => le_of_lt, fun H x =>\n      let ⟨n, h⟩ := H x\n      ⟨n + 1, lt_of_le_of_lt h (Int.cast_lt.2 (lt_add_one _))⟩⟩\n#align archimedean_iff_int_le archimedean_iff_int_le\n-/\n\n",
 "add_one_pow_unbounded_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print add_one_pow_unbounded_of_pos /-\ntheorem add_one_pow_unbounded_of_pos [StrictOrderedSemiring α] [Archimedean α] (x : α) {y : α} (hy : 0 < y) :\n    ∃ n : ℕ, x < (y + 1) ^ n :=\n  have : 0 ≤ 1 + y := add_nonneg zero_le_one hy.le\n  let ⟨n, h⟩ := archimedean.arch x hy\n  ⟨n,\n    calc\n      x ≤ «expr • » n y := h\n      _ = n * y := (nsmul_eq_mul _ _)\n      _ < 1 + n * y := (lt_one_add _)\n      _ ≤ (1 + y) ^ n :=\n        (one_add_mul_le_pow' (mul_nonneg hy.le hy.le) (mul_nonneg this this) (add_nonneg zero_le_two hy.le) _)\n      _ = (y + 1) ^ n := by rw [add_comm]\n      ⟩\n#align add_one_pow_unbounded_of_pos add_one_pow_unbounded_of_pos\n-/\n\n"}