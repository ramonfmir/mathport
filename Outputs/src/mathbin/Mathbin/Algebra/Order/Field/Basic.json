{"zpow_pos_of_pos":
 "#print zpow_pos_of_pos /-\ntheorem zpow_pos_of_pos (ha : 0 < a) : ∀ n : ℤ, 0 < a ^ n\n  | (n : ℕ) => by\n    rw [zpow_ofNat]\n    exact pow_pos ha _\n  | -[n+1] => by\n    rw [zpow_negSucc]\n    exact inv_pos.2 (pow_pos ha _)\n#align zpow_pos_of_pos zpow_pos_of_pos\n-/\n\n",
 "zpow_nonneg":
 "#print zpow_nonneg /-\ntheorem zpow_nonneg (ha : 0 ≤ a) : ∀ n : ℤ, 0 ≤ a ^ n\n  | (n : ℕ) => by\n    rw [zpow_ofNat]\n    exact pow_nonneg ha _\n  | -[n+1] => by\n    rw [zpow_negSucc]\n    exact inv_nonneg.2 (pow_nonneg ha _)\n#align zpow_nonneg zpow_nonneg\n-/\n\n",
 "two_inv_lt_one":
 "#print two_inv_lt_one /-\ntheorem two_inv_lt_one : (2⁻¹ : α) < 1 :=\n  (one_div _).symm.trans_lt one_half_lt_one\n#align two_inv_lt_one two_inv_lt_one\n-/\n\n",
 "sub_self_div_two":
 "#print sub_self_div_two /-\ntheorem sub_self_div_two (a : α) : a - a / 2 = a / 2 :=\n  by\n  suffices a / 2 + a / 2 - a / 2 = a / 2 by rwa [add_halves] at this\n  rw [add_sub_cancel]\n#align sub_self_div_two sub_self_div_two\n-/\n\n",
 "sub_one_div_inv_le_two":
 "#print sub_one_div_inv_le_two /-\n/-- An inequality involving `2`. -/\ntheorem sub_one_div_inv_le_two (a2 : 2 ≤ a) : (1 - 1 / a)⁻¹ ≤ 2 :=\n  by\n  -- Take inverses on both sides to obtain `2⁻¹ ≤ 1 - 1 / a`\n  refine' (inv_le_inv_of_le (inv_pos.2 <| zero_lt_two' α) _).trans_eq (inv_inv (2 : α))\n  -- move `1 / a` to the left and `1 - 1 / 2 = 1 / 2` to the right to obtain `1 / a ≤ ⅟ 2`\n  refine' (le_sub_iff_add_le.2 (_ : _ + 2⁻¹ = _).le).trans ((sub_le_sub_iff_left 1).2 _)\n  ·-- show 2⁻¹ + 2⁻¹ = 1\n    exact (two_mul _).symm.trans (mul_inv_cancel two_ne_zero)\n  ·-- take inverses on both sides and use the assumption `2 ≤ a`.\n    exact (one_div a).le.trans (inv_le_inv_of_le zero_lt_two a2)\n#align sub_one_div_inv_le_two sub_one_div_inv_le_two\n-/\n\n",
 "one_lt_one_div":
 "#print one_lt_one_div /-\ntheorem one_lt_one_div (h1 : 0 < a) (h2 : a < 1) : 1 < 1 / a := by rwa [lt_one_div zero_lt_one h1, one_div_one]\n#align one_lt_one_div one_lt_one_div\n-/\n\n",
 "one_lt_inv_iff":
 "#print one_lt_inv_iff /-\ntheorem one_lt_inv_iff : 1 < a⁻¹ ↔ 0 < a ∧ a < 1 :=\n  ⟨fun h => ⟨inv_pos.1 (zero_lt_one.trans h), inv_inv a ▸ inv_lt_one h⟩, and_imp.2 one_lt_inv⟩\n#align one_lt_inv_iff one_lt_inv_iff\n-/\n\n",
 "one_lt_inv":
 "#print one_lt_inv /-\ntheorem one_lt_inv (h₁ : 0 < a) (h₂ : a < 1) : 1 < a⁻¹ := by rwa [lt_inv zero_lt_one h₁, inv_one]\n#align one_lt_inv one_lt_inv\n-/\n\n",
 "one_lt_div_of_neg":
 "#print one_lt_div_of_neg /-\ntheorem one_lt_div_of_neg (hb : b < 0) : 1 < a / b ↔ a < b := by rw [lt_div_iff_of_neg hb, one_mul]\n#align one_lt_div_of_neg one_lt_div_of_neg\n-/\n\n",
 "one_lt_div_iff":
 "#print one_lt_div_iff /-\ntheorem one_lt_div_iff : 1 < a / b ↔ 0 < b ∧ b < a ∨ b < 0 ∧ a < b :=\n  by\n  rcases lt_trichotomy b 0 with (hb | rfl | hb)\n  · simp [hb, hb.not_lt, one_lt_div_of_neg]\n  · simp [lt_irrefl, zero_le_one]\n  · simp [hb, hb.not_lt, one_lt_div]\n#align one_lt_div_iff one_lt_div_iff\n-/\n\n",
 "one_lt_div":
 "#print one_lt_div /-\ntheorem one_lt_div (hb : 0 < b) : 1 < a / b ↔ b < a := by rw [lt_div_iff hb, one_mul]\n#align one_lt_div one_lt_div\n-/\n\n",
 "one_le_one_div":
 "#print one_le_one_div /-\ntheorem one_le_one_div (h1 : 0 < a) (h2 : a ≤ 1) : 1 ≤ 1 / a := by rwa [le_one_div zero_lt_one h1, one_div_one]\n#align one_le_one_div one_le_one_div\n-/\n\n",
 "one_le_inv_iff":
 "#print one_le_inv_iff /-\ntheorem one_le_inv_iff : 1 ≤ a⁻¹ ↔ 0 < a ∧ a ≤ 1 :=\n  ⟨fun h => ⟨inv_pos.1 (zero_lt_one.trans_le h), inv_inv a ▸ inv_le_one h⟩, and_imp.2 one_le_inv⟩\n#align one_le_inv_iff one_le_inv_iff\n-/\n\n",
 "one_le_inv":
 "#print one_le_inv /-\ntheorem one_le_inv (h₁ : 0 < a) (h₂ : a ≤ 1) : 1 ≤ a⁻¹ := by rwa [le_inv zero_lt_one h₁, inv_one]\n#align one_le_inv one_le_inv\n-/\n\n",
 "one_le_div_of_neg":
 "#print one_le_div_of_neg /-\ntheorem one_le_div_of_neg (hb : b < 0) : 1 ≤ a / b ↔ a ≤ b := by rw [le_div_iff_of_neg hb, one_mul]\n#align one_le_div_of_neg one_le_div_of_neg\n-/\n\n",
 "one_le_div_iff":
 "#print one_le_div_iff /-\ntheorem one_le_div_iff : 1 ≤ a / b ↔ 0 < b ∧ b ≤ a ∨ b < 0 ∧ a ≤ b :=\n  by\n  rcases lt_trichotomy b 0 with (hb | rfl | hb)\n  · simp [hb, hb.not_lt, one_le_div_of_neg]\n  · simp [lt_irrefl, zero_lt_one.not_le, zero_lt_one]\n  · simp [hb, hb.not_lt, one_le_div]\n#align one_le_div_iff one_le_div_iff\n-/\n\n",
 "one_le_div":
 "#print one_le_div /-\ntheorem one_le_div (hb : 0 < b) : 1 ≤ a / b ↔ b ≤ a := by rw [le_div_iff hb, one_mul]\n#align one_le_div one_le_div\n-/\n\n",
 "one_half_pos":
 "#print one_half_pos /-\ntheorem one_half_pos : (0 : α) < 1 / 2 :=\n  half_pos zero_lt_one\n#align one_half_pos one_half_pos\n-/\n\n",
 "one_half_lt_one":
 "#print one_half_lt_one /-\ntheorem one_half_lt_one : (1 / 2 : α) < 1 :=\n  half_lt_self zero_lt_one\n#align one_half_lt_one one_half_lt_one\n-/\n\n",
 "one_div_strictAntiOn":
 "#print one_div_strictAntiOn /-\ntheorem one_div_strictAntiOn : StrictAntiOn (fun x : α => 1 / x) (Set.Ioi 0) := fun x x1 y y1 xy =>\n  (one_div_lt_one_div (Set.mem_Ioi.mp y1) (Set.mem_Ioi.mp x1)).mpr xy\n#align one_div_strict_anti_on one_div_strictAntiOn\n-/\n\n",
 "one_div_pow_strictAnti":
 "#print one_div_pow_strictAnti /-\ntheorem one_div_pow_strictAnti (a1 : 1 < a) : StrictAnti fun n : ℕ => 1 / a ^ n := fun m n =>\n  one_div_pow_lt_one_div_pow_of_lt a1\n#align one_div_pow_strict_anti one_div_pow_strictAnti\n-/\n\n",
 "one_div_pow_lt_one_div_pow_of_lt":
 "#print one_div_pow_lt_one_div_pow_of_lt /-\ntheorem one_div_pow_lt_one_div_pow_of_lt (a1 : 1 < a) {m n : ℕ} (mn : m < n) : 1 / a ^ n < 1 / a ^ m := by\n  refine' (one_div_lt_one_div _ _).mpr (pow_lt_pow a1 mn) <;> exact pow_pos (trans zero_lt_one a1) _\n#align one_div_pow_lt_one_div_pow_of_lt one_div_pow_lt_one_div_pow_of_lt\n-/\n\n",
 "one_div_pow_le_one_div_pow_of_le":
 "#print one_div_pow_le_one_div_pow_of_le /-\ntheorem one_div_pow_le_one_div_pow_of_le (a1 : 1 ≤ a) {m n : ℕ} (mn : m ≤ n) : 1 / a ^ n ≤ 1 / a ^ m := by\n  refine' (one_div_le_one_div _ _).mpr (pow_le_pow a1 mn) <;> exact pow_pos (zero_lt_one.trans_le a1) _\n#align one_div_pow_le_one_div_pow_of_le one_div_pow_le_one_div_pow_of_le\n-/\n\n",
 "one_div_pow_anti":
 "#print one_div_pow_anti /-\ntheorem one_div_pow_anti (a1 : 1 ≤ a) : Antitone fun n : ℕ => 1 / a ^ n := fun m n =>\n  one_div_pow_le_one_div_pow_of_le a1\n#align one_div_pow_anti one_div_pow_anti\n-/\n\n",
 "one_div_pos":
 "#print one_div_pos /-\ntheorem one_div_pos : 0 < 1 / a ↔ 0 < a :=\n  inv_eq_one_div a ▸ inv_pos\n#align one_div_pos one_div_pos\n-/\n\n",
 "one_div_nonpos":
 "#print one_div_nonpos /-\ntheorem one_div_nonpos : 1 / a ≤ 0 ↔ a ≤ 0 :=\n  inv_eq_one_div a ▸ inv_nonpos\n#align one_div_nonpos one_div_nonpos\n-/\n\n",
 "one_div_nonneg":
 "#print one_div_nonneg /-\ntheorem one_div_nonneg : 0 ≤ 1 / a ↔ 0 ≤ a :=\n  inv_eq_one_div a ▸ inv_nonneg\n#align one_div_nonneg one_div_nonneg\n-/\n\n",
 "one_div_neg":
 "#print one_div_neg /-\ntheorem one_div_neg : 1 / a < 0 ↔ a < 0 :=\n  inv_eq_one_div a ▸ inv_lt_zero\n#align one_div_neg one_div_neg\n-/\n\n",
 "one_div_lt_one_div_of_neg_of_lt":
 "#print one_div_lt_one_div_of_neg_of_lt /-\ntheorem one_div_lt_one_div_of_neg_of_lt (hb : b < 0) (h : a < b) : 1 / b < 1 / a := by\n  rwa [div_lt_iff_of_neg' hb, ← div_eq_mul_one_div, div_lt_one_of_neg (h.trans hb)]\n#align one_div_lt_one_div_of_neg_of_lt one_div_lt_one_div_of_neg_of_lt\n-/\n\n",
 "one_div_lt_one_div_of_neg":
 "#print one_div_lt_one_div_of_neg /-\n/-- For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and\n  `lt_of_one_div_lt_one_div` -/\ntheorem one_div_lt_one_div_of_neg (ha : a < 0) (hb : b < 0) : 1 / a < 1 / b ↔ b < a :=\n  lt_iff_lt_of_le_iff_le (one_div_le_one_div_of_neg hb ha)\n#align one_div_lt_one_div_of_neg one_div_lt_one_div_of_neg\n-/\n\n",
 "one_div_lt_one_div_of_lt":
 "#print one_div_lt_one_div_of_lt /-\ntheorem one_div_lt_one_div_of_lt (ha : 0 < a) (h : a < b) : 1 / b < 1 / a := by\n  rwa [lt_div_iff' ha, ← div_eq_mul_one_div, div_lt_one (ha.trans h)]\n#align one_div_lt_one_div_of_lt one_div_lt_one_div_of_lt\n-/\n\n",
 "one_div_lt_one_div":
 "#print one_div_lt_one_div /-\n/-- For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and\n  `lt_of_one_div_lt_one_div` -/\ntheorem one_div_lt_one_div (ha : 0 < a) (hb : 0 < b) : 1 / a < 1 / b ↔ b < a :=\n  div_lt_div_left zero_lt_one ha hb\n#align one_div_lt_one_div one_div_lt_one_div\n-/\n\n",
 "one_div_lt_of_neg":
 "#print one_div_lt_of_neg /-\ntheorem one_div_lt_of_neg (ha : a < 0) (hb : b < 0) : 1 / a < b ↔ 1 / b < a := by simpa using inv_lt_of_neg ha hb\n#align one_div_lt_of_neg one_div_lt_of_neg\n-/\n\n",
 "one_div_lt_neg_one":
 "#print one_div_lt_neg_one /-\ntheorem one_div_lt_neg_one (h1 : a < 0) (h2 : -1 < a) : 1 / a < -1 :=\n  suffices 1 / a < 1 / -1 by rwa [one_div_neg_one_eq_neg_one] at this\n  one_div_lt_one_div_of_neg_of_lt h1 h2\n#align one_div_lt_neg_one one_div_lt_neg_one\n-/\n\n",
 "one_div_lt":
 "#print one_div_lt /-\ntheorem one_div_lt (ha : 0 < a) (hb : 0 < b) : 1 / a < b ↔ 1 / b < a := by simpa using inv_lt ha hb\n#align one_div_lt one_div_lt\n-/\n\n",
 "one_div_le_one_div_of_neg_of_le":
 "#print one_div_le_one_div_of_neg_of_le /-\ntheorem one_div_le_one_div_of_neg_of_le (hb : b < 0) (h : a ≤ b) : 1 / b ≤ 1 / a := by\n  rwa [div_le_iff_of_neg' hb, ← div_eq_mul_one_div, div_le_one_of_neg (h.trans_lt hb)]\n#align one_div_le_one_div_of_neg_of_le one_div_le_one_div_of_neg_of_le\n-/\n\n",
 "one_div_le_one_div_of_neg":
 "#print one_div_le_one_div_of_neg /-\n/-- For the single implications with fewer assumptions, see `one_div_lt_one_div_of_neg_of_lt` and\n  `lt_of_one_div_lt_one_div` -/\ntheorem one_div_le_one_div_of_neg (ha : a < 0) (hb : b < 0) : 1 / a ≤ 1 / b ↔ b ≤ a := by\n  simpa [one_div] using inv_le_inv_of_neg ha hb\n#align one_div_le_one_div_of_neg one_div_le_one_div_of_neg\n-/\n\n",
 "one_div_le_one_div_of_le":
 "#print one_div_le_one_div_of_le /-\ntheorem one_div_le_one_div_of_le (ha : 0 < a) (h : a ≤ b) : 1 / b ≤ 1 / a := by simpa using inv_le_inv_of_le ha h\n#align one_div_le_one_div_of_le one_div_le_one_div_of_le\n-/\n\n",
 "one_div_le_one_div":
 "#print one_div_le_one_div /-\n/-- For the single implications with fewer assumptions, see `one_div_le_one_div_of_le` and\n  `le_of_one_div_le_one_div` -/\ntheorem one_div_le_one_div (ha : 0 < a) (hb : 0 < b) : 1 / a ≤ 1 / b ↔ b ≤ a :=\n  div_le_div_left zero_lt_one ha hb\n#align one_div_le_one_div one_div_le_one_div\n-/\n\n",
 "one_div_le_of_neg":
 "#print one_div_le_of_neg /-\ntheorem one_div_le_of_neg (ha : a < 0) (hb : b < 0) : 1 / a ≤ b ↔ 1 / b ≤ a := by simpa using inv_le_of_neg ha hb\n#align one_div_le_of_neg one_div_le_of_neg\n-/\n\n",
 "one_div_le_neg_one":
 "#print one_div_le_neg_one /-\ntheorem one_div_le_neg_one (h1 : a < 0) (h2 : -1 ≤ a) : 1 / a ≤ -1 :=\n  suffices 1 / a ≤ 1 / -1 by rwa [one_div_neg_one_eq_neg_one] at this\n  one_div_le_one_div_of_neg_of_le h1 h2\n#align one_div_le_neg_one one_div_le_neg_one\n-/\n\n",
 "one_div_le":
 "#print one_div_le /-\ntheorem one_div_le (ha : 0 < a) (hb : 0 < b) : 1 / a ≤ b ↔ 1 / b ≤ a := by simpa using inv_le ha hb\n#align one_div_le one_div_le\n-/\n\n",
 "mul_sub_mul_div_mul_nonpos_iff":
 "#print mul_sub_mul_div_mul_nonpos_iff /-\ntheorem mul_sub_mul_div_mul_nonpos_iff (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) ≤ 0 ↔ a / c ≤ b / d := by\n  rw [mul_comm b c, ← div_sub_div _ _ hc hd, sub_nonpos]\n#align mul_sub_mul_div_mul_nonpos_iff mul_sub_mul_div_mul_nonpos_iff\n-/\n\n",
 "mul_sub_mul_div_mul_neg_iff":
 "#print mul_sub_mul_div_mul_neg_iff /-\ntheorem mul_sub_mul_div_mul_neg_iff (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) < 0 ↔ a / c < b / d := by\n  rw [mul_comm b c, ← div_sub_div _ _ hc hd, sub_lt_zero]\n#align mul_sub_mul_div_mul_neg_iff mul_sub_mul_div_mul_neg_iff\n-/\n\n",
 "mul_self_inj_of_nonneg":
 "#print mul_self_inj_of_nonneg /-\ntheorem mul_self_inj_of_nonneg (a0 : 0 ≤ a) (b0 : 0 ≤ b) : a * a = b * b ↔ a = b :=\n  mul_self_eq_mul_self_iff.trans <|\n    or_iff_left_of_imp fun h => by\n      subst a\n      have : b = 0 := le_antisymm (neg_nonneg.1 a0) b0\n      rw [this, neg_zero]\n#align mul_self_inj_of_nonneg mul_self_inj_of_nonneg\n-/\n\n",
 "mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsLUB.mul_right /-\n-- TODO: Generalize to `linear_ordered_semifield`\ntheorem IsLUB.mul_right {s : Set α} (ha : 0 ≤ a) (hs : IsLUB s b) : IsLUB («expr '' » (fun b => b * a) s) (b * a) := by\n  simpa [mul_comm] using hs.mul_left ha\n#align is_lub.mul_right IsLUB.mul_right\n-/\n\n",
 "mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsLUB.mul_left /-\n-- TODO: Generalize to `linear_ordered_semifield`\ntheorem IsLUB.mul_left {s : Set α} (ha : 0 ≤ a) (hs : IsLUB s b) : IsLUB («expr '' » (fun b => a * b) s) (a * b) :=\n  by\n  rcases lt_or_eq_of_le ha with (ha | rfl)\n  · exact (OrderIso.mulLeft₀ _ ha).is_lub_image'.2 hs\n  · simp_rw [MulZeroClass.zero_mul]\n    rw [hs.nonempty.image_const]\n    exact isLUB_singleton\n#align is_lub.mul_left IsLUB.mul_left\n-/\n\n",
 "mul_le_of_nonneg_of_le_div":
 "#print mul_le_of_nonneg_of_le_div /-\n/-- One direction of `div_le_iff` where `c` is allowed to be `0` (but `b` must be nonnegative) -/\ntheorem mul_le_of_nonneg_of_le_div (hb : 0 ≤ b) (hc : 0 ≤ c) (h : a ≤ b / c) : a * c ≤ b :=\n  by\n  obtain rfl | hc := hc.eq_or_lt\n  · simpa using hb\n  · rwa [le_div_iff hc] at h\n#align mul_le_of_nonneg_of_le_div mul_le_of_nonneg_of_le_div\n-/\n\n",
 "mul_le_mul_of_mul_div_le":
 "#print mul_le_mul_of_mul_div_le /-\ntheorem mul_le_mul_of_mul_div_le (h : a * (b / c) ≤ d) (hc : 0 < c) : b * a ≤ d * c :=\n  by\n  rw [← mul_div_assoc] at h\n  rwa [mul_comm b, ← div_le_iff hc]\n#align mul_le_mul_of_mul_div_le mul_le_mul_of_mul_div_le\n-/\n\n",
 "mul_inv_lt_iff'":
 "#print mul_inv_lt_iff' /-\ntheorem mul_inv_lt_iff' (h : 0 < b) : a * b⁻¹ < c ↔ a < c * b := by rw [mul_comm, inv_mul_lt_iff' h]\n#align mul_inv_lt_iff' mul_inv_lt_iff'\n-/\n\n",
 "mul_inv_lt_iff":
 "#print mul_inv_lt_iff /-\ntheorem mul_inv_lt_iff (h : 0 < b) : a * b⁻¹ < c ↔ a < b * c := by rw [mul_comm, inv_mul_lt_iff h]\n#align mul_inv_lt_iff mul_inv_lt_iff\n-/\n\n",
 "mul_inv_le_iff'":
 "#print mul_inv_le_iff' /-\ntheorem mul_inv_le_iff' (h : 0 < b) : a * b⁻¹ ≤ c ↔ a ≤ c * b := by rw [mul_comm, inv_mul_le_iff' h]\n#align mul_inv_le_iff' mul_inv_le_iff'\n-/\n\n",
 "mul_inv_le_iff":
 "#print mul_inv_le_iff /-\ntheorem mul_inv_le_iff (h : 0 < b) : a * b⁻¹ ≤ c ↔ a ≤ b * c := by rw [mul_comm, inv_mul_le_iff h]\n#align mul_inv_le_iff mul_inv_le_iff\n-/\n\n",
 "min_div_div_right_of_nonpos":
 "#print min_div_div_right_of_nonpos /-\ntheorem min_div_div_right_of_nonpos (hc : c ≤ 0) (a b : α) : min (a / c) (b / c) = max a b / c :=\n  Eq.symm <| Antitone.map_max fun x y => div_le_div_of_nonpos_of_le hc\n#align min_div_div_right_of_nonpos min_div_div_right_of_nonpos\n-/\n\n",
 "min_div_div_right":
 "#print min_div_div_right /-\n-- see Note [lower instance priority]\ntheorem min_div_div_right {c : α} (hc : 0 ≤ c) (a b : α) : min (a / c) (b / c) = min a b / c :=\n  Eq.symm <| Monotone.map_min fun x y => div_le_div_of_le hc\n#align min_div_div_right min_div_div_right\n-/\n\n",
 "max_div_div_right_of_nonpos":
 "#print max_div_div_right_of_nonpos /-\ntheorem max_div_div_right_of_nonpos (hc : c ≤ 0) (a b : α) : max (a / c) (b / c) = min a b / c :=\n  Eq.symm <| Antitone.map_min fun x y => div_le_div_of_nonpos_of_le hc\n#align max_div_div_right_of_nonpos max_div_div_right_of_nonpos\n-/\n\n",
 "max_div_div_right":
 "#print max_div_div_right /-\ntheorem max_div_div_right {c : α} (hc : 0 ≤ c) (a b : α) : max (a / c) (b / c) = max a b / c :=\n  Eq.symm <| Monotone.map_max fun x y => div_le_div_of_le hc\n#align max_div_div_right max_div_div_right\n-/\n\n",
 "lt_one_div_of_neg":
 "#print lt_one_div_of_neg /-\ntheorem lt_one_div_of_neg (ha : a < 0) (hb : b < 0) : a < 1 / b ↔ b < 1 / a := by simpa using lt_inv_of_neg ha hb\n#align lt_one_div_of_neg lt_one_div_of_neg\n-/\n\n",
 "lt_one_div":
 "#print lt_one_div /-\ntheorem lt_one_div (ha : 0 < a) (hb : 0 < b) : a < 1 / b ↔ b < 1 / a := by simpa using lt_inv ha hb\n#align lt_one_div lt_one_div\n-/\n\n",
 "lt_of_one_div_lt_one_div":
 "#print lt_of_one_div_lt_one_div /-\ntheorem lt_of_one_div_lt_one_div (ha : 0 < a) (h : 1 / a < 1 / b) : b < a :=\n  lt_imp_lt_of_le_imp_le (one_div_le_one_div_of_le ha) h\n#align lt_of_one_div_lt_one_div lt_of_one_div_lt_one_div\n-/\n\n",
 "lt_of_neg_of_one_div_lt_one_div":
 "#print lt_of_neg_of_one_div_lt_one_div /-\ntheorem lt_of_neg_of_one_div_lt_one_div (hb : b < 0) (h : 1 / a < 1 / b) : b < a :=\n  lt_imp_lt_of_le_imp_le (one_div_le_one_div_of_neg_of_le hb) h\n#align lt_of_neg_of_one_div_lt_one_div lt_of_neg_of_one_div_lt_one_div\n-/\n\n",
 "lt_inv_of_neg":
 "#print lt_inv_of_neg /-\ntheorem lt_inv_of_neg (ha : a < 0) (hb : b < 0) : a < b⁻¹ ↔ b < a⁻¹ :=\n  lt_iff_lt_of_le_iff_le (inv_le_of_neg hb ha)\n#align lt_inv_of_neg lt_inv_of_neg\n-/\n\n",
 "lt_inv":
 "#print lt_inv /-\ntheorem lt_inv (ha : 0 < a) (hb : 0 < b) : a < b⁻¹ ↔ b < a⁻¹ :=\n  lt_iff_lt_of_le_iff_le (inv_le hb ha)\n#align lt_inv lt_inv\n-/\n\n",
 "lt_div_iff_of_neg'":
 "#print lt_div_iff_of_neg' /-\ntheorem lt_div_iff_of_neg' (hc : c < 0) : a < b / c ↔ b < c * a := by rw [mul_comm, lt_div_iff_of_neg hc]\n#align lt_div_iff_of_neg' lt_div_iff_of_neg'\n-/\n\n",
 "lt_div_iff_of_neg":
 "#print lt_div_iff_of_neg /-\ntheorem lt_div_iff_of_neg (hc : c < 0) : a < b / c ↔ b < a * c :=\n  lt_iff_lt_of_le_iff_le <| div_le_iff_of_neg hc\n#align lt_div_iff_of_neg lt_div_iff_of_neg\n-/\n\n",
 "lt_div_iff'":
 "#print lt_div_iff' /-\ntheorem lt_div_iff' (hc : 0 < c) : a < b / c ↔ c * a < b := by rw [mul_comm, lt_div_iff hc]\n#align lt_div_iff' lt_div_iff'\n-/\n\n",
 "lt_div_iff":
 "#print lt_div_iff /-\ntheorem lt_div_iff (hc : 0 < c) : a < b / c ↔ a * c < b :=\n  lt_iff_lt_of_le_iff_le <| div_le_iff hc\n#align lt_div_iff lt_div_iff\n-/\n\n",
 "left_lt_add_div_two":
 "#print left_lt_add_div_two /-\ntheorem left_lt_add_div_two : a < (a + b) / 2 ↔ a < b := by simp [lt_div_iff, mul_two]\n#align left_lt_add_div_two left_lt_add_div_two\n-/\n\n",
 "le_one_div_of_neg":
 "#print le_one_div_of_neg /-\ntheorem le_one_div_of_neg (ha : a < 0) (hb : b < 0) : a ≤ 1 / b ↔ b ≤ 1 / a := by simpa using le_inv_of_neg ha hb\n#align le_one_div_of_neg le_one_div_of_neg\n-/\n\n",
 "le_one_div":
 "#print le_one_div /-\ntheorem le_one_div (ha : 0 < a) (hb : 0 < b) : a ≤ 1 / b ↔ b ≤ 1 / a := by simpa using le_inv ha hb\n#align le_one_div le_one_div\n-/\n\n",
 "le_of_one_div_le_one_div":
 "#print le_of_one_div_le_one_div /-\ntheorem le_of_one_div_le_one_div (ha : 0 < a) (h : 1 / a ≤ 1 / b) : b ≤ a :=\n  le_imp_le_of_lt_imp_lt (one_div_lt_one_div_of_lt ha) h\n#align le_of_one_div_le_one_div le_of_one_div_le_one_div\n-/\n\n",
 "le_of_neg_of_one_div_le_one_div":
 "#print le_of_neg_of_one_div_le_one_div /-\ntheorem le_of_neg_of_one_div_le_one_div (hb : b < 0) (h : 1 / a ≤ 1 / b) : b ≤ a :=\n  le_imp_le_of_lt_imp_lt (one_div_lt_one_div_of_neg_of_lt hb) h\n#align le_of_neg_of_one_div_le_one_div le_of_neg_of_one_div_le_one_div\n-/\n\n",
 "le_of_forall_sub_le":
 "#print le_of_forall_sub_le /-\ntheorem le_of_forall_sub_le (h : ∀ ε > 0, b - ε ≤ a) : b ≤ a :=\n  by\n  contrapose! h\n  simpa only [and_comm' ((0 : α) < _), lt_sub_iff_add_lt, gt_iff_lt] using exists_add_lt_and_pos_of_lt h\n#align le_of_forall_sub_le le_of_forall_sub_le\n-/\n\n",
 "le_inv_of_neg":
 "#print le_inv_of_neg /-\ntheorem le_inv_of_neg (ha : a < 0) (hb : b < 0) : a ≤ b⁻¹ ↔ b ≤ a⁻¹ := by\n  rw [← inv_le_inv_of_neg (inv_lt_zero.2 hb) ha, inv_inv]\n#align le_inv_of_neg le_inv_of_neg\n-/\n\n",
 "le_inv":
 "#print le_inv /-\ntheorem le_inv (ha : 0 < a) (hb : 0 < b) : a ≤ b⁻¹ ↔ b ≤ a⁻¹ := by rw [← inv_le_inv (inv_pos.2 hb) ha, inv_inv]\n#align le_inv le_inv\n-/\n\n",
 "le_div_self":
 "#print le_div_self /-\ntheorem le_div_self (ha : 0 ≤ a) (hb₀ : 0 < b) (hb₁ : b ≤ 1) : a ≤ a / b := by\n  simpa only [div_one] using div_le_div_of_le_left ha hb₀ hb₁\n#align le_div_self le_div_self\n-/\n\n",
 "le_div_iff_of_neg'":
 "#print le_div_iff_of_neg' /-\ntheorem le_div_iff_of_neg' (hc : c < 0) : a ≤ b / c ↔ b ≤ c * a := by rw [mul_comm, le_div_iff_of_neg hc]\n#align le_div_iff_of_neg' le_div_iff_of_neg'\n-/\n\n",
 "le_div_iff_of_neg":
 "#print le_div_iff_of_neg /-\ntheorem le_div_iff_of_neg (hc : c < 0) : a ≤ b / c ↔ b ≤ a * c := by\n  rw [← neg_neg c, mul_neg, div_neg, le_neg, div_le_iff (neg_pos.2 hc), neg_mul]\n#align le_div_iff_of_neg le_div_iff_of_neg\n-/\n\n",
 "le_div_iff'":
 "#print le_div_iff' /-\ntheorem le_div_iff' (hc : 0 < c) : a ≤ b / c ↔ c * a ≤ b := by rw [mul_comm, le_div_iff hc]\n#align le_div_iff' le_div_iff'\n-/\n\n",
 "le_div_iff":
 "#print le_div_iff /-\ntheorem le_div_iff (hc : 0 < c) : a ≤ b / c ↔ a * c ≤ b :=\n  ⟨fun h => div_mul_cancel b (ne_of_lt hc).symm ▸ mul_le_mul_of_nonneg_right h hc.le, fun h =>\n    calc\n      a = a * c * (1 / c) := mul_mul_div a (ne_of_lt hc).symm\n      _ ≤ b * (1 / c) := (mul_le_mul_of_nonneg_right h (one_div_pos.2 hc).le)\n      _ = b / c := (div_eq_mul_one_div b c).symm\n      ⟩\n#align le_div_iff le_div_iff\n-/\n\n",
 "inv_strictAntiOn":
 "#print inv_strictAntiOn /-\ntheorem inv_strictAntiOn : StrictAntiOn (fun x : α => x⁻¹) (Set.Ioi 0) := fun x hx y hy xy => (inv_lt_inv hy hx).2 xy\n#align inv_strict_anti_on inv_strictAntiOn\n-/\n\n",
 "inv_pow_strictAnti":
 "#print inv_pow_strictAnti /-\ntheorem inv_pow_strictAnti (a1 : 1 < a) : StrictAnti fun n : ℕ => (a ^ n)⁻¹ := fun m n => inv_pow_lt_inv_pow_of_lt a1\n#align inv_pow_strict_anti inv_pow_strictAnti\n-/\n\n",
 "inv_pow_lt_inv_pow_of_lt":
 "#print inv_pow_lt_inv_pow_of_lt /-\ntheorem inv_pow_lt_inv_pow_of_lt (a1 : 1 < a) {m n : ℕ} (mn : m < n) : (a ^ n)⁻¹ < (a ^ m)⁻¹ := by\n  convert one_div_pow_lt_one_div_pow_of_lt a1 mn <;> simp\n#align inv_pow_lt_inv_pow_of_lt inv_pow_lt_inv_pow_of_lt\n-/\n\n",
 "inv_pow_le_inv_pow_of_le":
 "#print inv_pow_le_inv_pow_of_le /-\ntheorem inv_pow_le_inv_pow_of_le (a1 : 1 ≤ a) {m n : ℕ} (mn : m ≤ n) : (a ^ n)⁻¹ ≤ (a ^ m)⁻¹ := by\n  convert one_div_pow_le_one_div_pow_of_le a1 mn <;> simp\n#align inv_pow_le_inv_pow_of_le inv_pow_le_inv_pow_of_le\n-/\n\n",
 "inv_pow_anti":
 "#print inv_pow_anti /-\ntheorem inv_pow_anti (a1 : 1 ≤ a) : Antitone fun n : ℕ => (a ^ n)⁻¹ := fun m n => inv_pow_le_inv_pow_of_le a1\n#align inv_pow_anti inv_pow_anti\n-/\n\n",
 "inv_pos_lt_iff_one_lt_mul'":
 "#print inv_pos_lt_iff_one_lt_mul' /-\ntheorem inv_pos_lt_iff_one_lt_mul' (ha : 0 < a) : a⁻¹ < b ↔ 1 < a * b :=\n  by\n  rw [inv_eq_one_div]\n  exact div_lt_iff' ha\n#align inv_pos_lt_iff_one_lt_mul' inv_pos_lt_iff_one_lt_mul'\n-/\n\n",
 "inv_pos_lt_iff_one_lt_mul":
 "#print inv_pos_lt_iff_one_lt_mul /-\ntheorem inv_pos_lt_iff_one_lt_mul (ha : 0 < a) : a⁻¹ < b ↔ 1 < b * a :=\n  by\n  rw [inv_eq_one_div]\n  exact div_lt_iff ha\n#align inv_pos_lt_iff_one_lt_mul inv_pos_lt_iff_one_lt_mul\n-/\n\n",
 "inv_pos_le_iff_one_le_mul'":
 "#print inv_pos_le_iff_one_le_mul' /-\ntheorem inv_pos_le_iff_one_le_mul' (ha : 0 < a) : a⁻¹ ≤ b ↔ 1 ≤ a * b :=\n  by\n  rw [inv_eq_one_div]\n  exact div_le_iff' ha\n#align inv_pos_le_iff_one_le_mul' inv_pos_le_iff_one_le_mul'\n-/\n\n",
 "inv_pos_le_iff_one_le_mul":
 "#print inv_pos_le_iff_one_le_mul /-\ntheorem inv_pos_le_iff_one_le_mul (ha : 0 < a) : a⁻¹ ≤ b ↔ 1 ≤ b * a :=\n  by\n  rw [inv_eq_one_div]\n  exact div_le_iff ha\n#align inv_pos_le_iff_one_le_mul inv_pos_le_iff_one_le_mul\n-/\n\n",
 "inv_pos":
 "#print inv_pos /-\n/-\nCopyright (c) 2014 Robert Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Lewis, Leonardo de Moura, Mario Carneiro, Floris van Doorn\n-/\n@[simp]\ntheorem inv_pos : 0 < a⁻¹ ↔ 0 < a :=\n  suffices ∀ a : α, 0 < a → 0 < a⁻¹ from ⟨fun h => inv_inv a ▸ this _ h, this a⟩\n  fun a ha => flip lt_of_mul_lt_mul_left ha.le <| by simp [ne_of_gt ha, zero_lt_one]\n#align inv_pos inv_pos\n-/\n\n",
 "inv_nonpos":
 "#print inv_nonpos /-\n@[simp]\ntheorem inv_nonpos : a⁻¹ ≤ 0 ↔ a ≤ 0 := by simp only [← not_lt, inv_pos]\n#align inv_nonpos inv_nonpos\n-/\n\n",
 "inv_nonneg":
 "#print inv_nonneg /-\n@[simp]\ntheorem inv_nonneg : 0 ≤ a⁻¹ ↔ 0 ≤ a := by simp only [le_iff_eq_or_lt, inv_pos, zero_eq_inv]\n#align inv_nonneg inv_nonneg\n-/\n\n",
 "inv_mul_lt_iff'":
 "#print inv_mul_lt_iff' /-\ntheorem inv_mul_lt_iff' (h : 0 < b) : b⁻¹ * a < c ↔ a < c * b := by rw [inv_mul_lt_iff h, mul_comm]\n#align inv_mul_lt_iff' inv_mul_lt_iff'\n-/\n\n",
 "inv_mul_lt_iff":
 "#print inv_mul_lt_iff /-\ntheorem inv_mul_lt_iff (h : 0 < b) : b⁻¹ * a < c ↔ a < b * c :=\n  by\n  rw [inv_eq_one_div, mul_comm, ← div_eq_mul_one_div]\n  exact div_lt_iff' h\n#align inv_mul_lt_iff inv_mul_lt_iff\n-/\n\n",
 "inv_mul_le_iff'":
 "#print inv_mul_le_iff' /-\ntheorem inv_mul_le_iff' (h : 0 < b) : b⁻¹ * a ≤ c ↔ a ≤ c * b := by rw [inv_mul_le_iff h, mul_comm]\n#align inv_mul_le_iff' inv_mul_le_iff'\n-/\n\n",
 "inv_mul_le_iff":
 "#print inv_mul_le_iff /-\ntheorem inv_mul_le_iff (h : 0 < b) : b⁻¹ * a ≤ c ↔ a ≤ b * c :=\n  by\n  rw [inv_eq_one_div, mul_comm, ← div_eq_mul_one_div]\n  exact div_le_iff' h\n#align inv_mul_le_iff inv_mul_le_iff\n-/\n\n",
 "inv_lt_zero":
 "#print inv_lt_zero /-\n@[simp]\ntheorem inv_lt_zero : a⁻¹ < 0 ↔ a < 0 := by simp only [← not_le, inv_nonneg]\n#align inv_lt_zero inv_lt_zero\n-/\n\n",
 "inv_lt_one_iff_of_pos":
 "#print inv_lt_one_iff_of_pos /-\ntheorem inv_lt_one_iff_of_pos (h₀ : 0 < a) : a⁻¹ < 1 ↔ 1 < a :=\n  ⟨fun h₁ => inv_inv a ▸ one_lt_inv (inv_pos.2 h₀) h₁, inv_lt_one⟩\n#align inv_lt_one_iff_of_pos inv_lt_one_iff_of_pos\n-/\n\n",
 "inv_lt_one_iff":
 "#print inv_lt_one_iff /-\ntheorem inv_lt_one_iff : a⁻¹ < 1 ↔ a ≤ 0 ∨ 1 < a :=\n  by\n  cases' le_or_lt a 0 with ha ha\n  · simp [ha, (inv_nonpos.2 ha).trans_lt zero_lt_one]\n  · simp only [ha.not_le, false_or_iff, inv_lt_one_iff_of_pos ha]\n#align inv_lt_one_iff inv_lt_one_iff\n-/\n\n",
 "inv_lt_one":
 "#print inv_lt_one /-\ntheorem inv_lt_one (ha : 1 < a) : a⁻¹ < 1 := by rwa [inv_lt (zero_lt_one.trans ha) zero_lt_one, inv_one]\n#align inv_lt_one inv_lt_one\n-/\n\n",
 "inv_lt_of_neg":
 "#print inv_lt_of_neg /-\ntheorem inv_lt_of_neg (ha : a < 0) (hb : b < 0) : a⁻¹ < b ↔ b⁻¹ < a :=\n  lt_iff_lt_of_le_iff_le (le_inv_of_neg hb ha)\n#align inv_lt_of_neg inv_lt_of_neg\n-/\n\n",
 "inv_lt_of_inv_lt":
 "#print inv_lt_of_inv_lt /-\ntheorem inv_lt_of_inv_lt (ha : 0 < a) (h : a⁻¹ < b) : b⁻¹ < a :=\n  (inv_lt ha ((inv_pos.2 ha).trans h)).1 h\n#align inv_lt_of_inv_lt inv_lt_of_inv_lt\n-/\n\n",
 "inv_lt_inv_of_neg":
 "#print inv_lt_inv_of_neg /-\ntheorem inv_lt_inv_of_neg (ha : a < 0) (hb : b < 0) : a⁻¹ < b⁻¹ ↔ b < a :=\n  lt_iff_lt_of_le_iff_le (inv_le_inv_of_neg hb ha)\n#align inv_lt_inv_of_neg inv_lt_inv_of_neg\n-/\n\n",
 "inv_lt_inv_of_lt":
 "#print inv_lt_inv_of_lt /-\ntheorem inv_lt_inv_of_lt (hb : 0 < b) (h : b < a) : a⁻¹ < b⁻¹ :=\n  (inv_lt_inv (hb.trans h) hb).2 h\n#align inv_lt_inv_of_lt inv_lt_inv_of_lt\n-/\n\n",
 "inv_lt_inv":
 "#print inv_lt_inv /-\n/-- See `inv_lt_inv_of_lt` for the implication from right-to-left with one fewer assumption. -/\ntheorem inv_lt_inv (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b⁻¹ ↔ b < a :=\n  lt_iff_lt_of_le_iff_le (inv_le_inv hb ha)\n#align inv_lt_inv inv_lt_inv\n-/\n\n",
 "inv_lt":
 "#print inv_lt /-\n/-- In a linear ordered field, for positive `a` and `b` we have `a⁻¹ < b ↔ b⁻¹ < a`.\nSee also `inv_lt_of_inv_lt` for a one-sided implication with one fewer assumption. -/\ntheorem inv_lt (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b ↔ b⁻¹ < a :=\n  lt_iff_lt_of_le_iff_le (le_inv hb ha)\n#align inv_lt inv_lt\n-/\n\n",
 "inv_le_one_iff":
 "#print inv_le_one_iff /-\ntheorem inv_le_one_iff : a⁻¹ ≤ 1 ↔ a ≤ 0 ∨ 1 ≤ a :=\n  by\n  rcases em (a = 1) with (rfl | ha)\n  · simp [le_rfl]\n  · simp only [Ne.le_iff_lt (ne.symm ha), Ne.le_iff_lt (mt inv_eq_one.1 ha), inv_lt_one_iff]\n#align inv_le_one_iff inv_le_one_iff\n-/\n\n",
 "inv_le_one":
 "#print inv_le_one /-\ntheorem inv_le_one (ha : 1 ≤ a) : a⁻¹ ≤ 1 := by rwa [inv_le (zero_lt_one.trans_le ha) zero_lt_one, inv_one]\n#align inv_le_one inv_le_one\n-/\n\n",
 "inv_le_of_neg":
 "#print inv_le_of_neg /-\ntheorem inv_le_of_neg (ha : a < 0) (hb : b < 0) : a⁻¹ ≤ b ↔ b⁻¹ ≤ a := by\n  rw [← inv_le_inv_of_neg hb (inv_lt_zero.2 ha), inv_inv]\n#align inv_le_of_neg inv_le_of_neg\n-/\n\n",
 "inv_le_of_inv_le":
 "#print inv_le_of_inv_le /-\ntheorem inv_le_of_inv_le (ha : 0 < a) (h : a⁻¹ ≤ b) : b⁻¹ ≤ a :=\n  (inv_le ha ((inv_pos.2 ha).trans_le h)).1 h\n#align inv_le_of_inv_le inv_le_of_inv_le\n-/\n\n",
 "inv_le_inv_of_neg":
 "#print inv_le_inv_of_neg /-\ntheorem inv_le_inv_of_neg (ha : a < 0) (hb : b < 0) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a := by\n  rw [← one_div, div_le_iff_of_neg ha, ← div_eq_inv_mul, div_le_iff_of_neg hb, one_mul]\n#align inv_le_inv_of_neg inv_le_inv_of_neg\n-/\n\n",
 "inv_le_inv_of_le":
 "#print inv_le_inv_of_le /-\ntheorem inv_le_inv_of_le (ha : 0 < a) (h : a ≤ b) : b⁻¹ ≤ a⁻¹ := by\n  rwa [← one_div a, le_div_iff' ha, ← div_eq_mul_inv, div_le_iff (ha.trans_le h), one_mul]\n#align inv_le_inv_of_le inv_le_inv_of_le\n-/\n\n",
 "inv_le_inv":
 "#print inv_le_inv /-\n/-- See `inv_le_inv_of_le` for the implication from right-to-left with one fewer assumption. -/\ntheorem inv_le_inv (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a := by\n  rw [← one_div, div_le_iff ha, ← div_eq_inv_mul, le_div_iff hb, one_mul]\n#align inv_le_inv inv_le_inv\n-/\n\n",
 "inv_le":
 "#print inv_le /-\n/-- In a linear ordered field, for positive `a` and `b` we have `a⁻¹ ≤ b ↔ b⁻¹ ≤ a`.\nSee also `inv_le_of_inv_le` for a one-sided implication with one fewer assumption. -/\ntheorem inv_le (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b ↔ b⁻¹ ≤ a := by rw [← inv_le_inv hb (inv_pos.2 ha), inv_inv]\n#align inv_le inv_le\n-/\n\n",
 "half_pos":
 "#print half_pos /-\ntheorem half_pos (h : 0 < a) : 0 < a / 2 :=\n  div_pos h zero_lt_two\n#align half_pos half_pos\n-/\n\n",
 "half_lt_self_iff":
 "#print half_lt_self_iff /-\n@[simp]\ntheorem half_lt_self_iff : a / 2 < a ↔ 0 < a := by rw [div_lt_iff (zero_lt_two' α), mul_two, lt_add_iff_pos_left]\n#align half_lt_self_iff half_lt_self_iff\n-/\n\n",
 "half_le_self_iff":
 "#print half_le_self_iff /-\n@[simp]\ntheorem half_le_self_iff : a / 2 ≤ a ↔ 0 ≤ a := by rw [div_le_iff (zero_lt_two' α), mul_two, le_add_iff_nonneg_left]\n#align half_le_self_iff half_le_self_iff\n-/\n\n",
 "exists_pos_mul_lt":
 "#print exists_pos_mul_lt /-\ntheorem exists_pos_mul_lt {a : α} (h : 0 < a) (b : α) : ∃ c : α, 0 < c ∧ b * c < a :=\n  by\n  have : 0 < a / max (b + 1) 1 := div_pos h (lt_max_iff.2 (or.inr zero_lt_one))\n  refine' ⟨a / max (b + 1) 1, this, _⟩\n  rw [← lt_div_iff this, div_div_cancel' h.ne']\n  exact lt_max_iff.2 (or.inl <| lt_add_one _)\n#align exists_pos_mul_lt exists_pos_mul_lt\n-/\n\n",
 "exists_pos_lt_mul":
 "#print exists_pos_lt_mul /-\ntheorem exists_pos_lt_mul {a : α} (h : 0 < a) (b : α) : ∃ c : α, 0 < c ∧ b < c * a :=\n  let ⟨c, hc₀, hc⟩ := exists_pos_mul_lt h b\n  ⟨c⁻¹, inv_pos.2 hc₀, by rwa [← div_eq_inv_mul, lt_div_iff hc₀]⟩\n#align exists_pos_lt_mul exists_pos_lt_mul\n-/\n\n",
 "exists_add_lt_and_pos_of_lt":
 "#print exists_add_lt_and_pos_of_lt /-\ntheorem exists_add_lt_and_pos_of_lt (h : b < a) : ∃ c, b + c < a ∧ 0 < c :=\n  ⟨(a - b) / 2, add_sub_div_two_lt h, div_pos (sub_pos_of_lt h) zero_lt_two⟩\n#align exists_add_lt_and_pos_of_lt exists_add_lt_and_pos_of_lt\n-/\n\n",
 "div_two_sub_self":
 "#print div_two_sub_self /-\ntheorem div_two_sub_self (a : α) : a / 2 - a = -(a / 2) :=\n  by\n  suffices a / 2 - (a / 2 + a / 2) = -(a / 2) by rwa [add_halves] at this\n  rw [sub_add_eq_sub_sub, sub_self, zero_sub]\n#align div_two_sub_self div_two_sub_self\n-/\n\n",
 "div_self_le_one":
 "#print div_self_le_one /-\ntheorem div_self_le_one (a : α) : a / a ≤ 1 :=\n  if h : a = 0 then by simp [h] else by simp [h]\n#align div_self_le_one div_self_le_one\n-/\n\n",
 "div_pos_of_neg_of_neg":
 "#print div_pos_of_neg_of_neg /-\ntheorem div_pos_of_neg_of_neg (ha : a < 0) (hb : b < 0) : 0 < a / b :=\n  div_pos_iff.2 <| or.inr ⟨ha, hb⟩\n#align div_pos_of_neg_of_neg div_pos_of_neg_of_neg\n-/\n\n",
 "div_pos_iff":
 "#print div_pos_iff /-\ntheorem div_pos_iff : 0 < a / b ↔ 0 < a ∧ 0 < b ∨ a < 0 ∧ b < 0 := by simp [division_def, mul_pos_iff]\n#align div_pos_iff div_pos_iff\n-/\n\n",
 "div_pos":
 "#print div_pos /-\ntheorem div_pos (ha : 0 < a) (hb : 0 < b) : 0 < a / b :=\n  by\n  rw [div_eq_mul_inv]\n  exact mul_pos ha (inv_pos.2 hb)\n#align div_pos div_pos\n-/\n\n",
 "div_nonpos_of_nonpos_of_nonneg":
 "#print div_nonpos_of_nonpos_of_nonneg /-\ntheorem div_nonpos_of_nonpos_of_nonneg (ha : a ≤ 0) (hb : 0 ≤ b) : a / b ≤ 0 :=\n  by\n  rw [div_eq_mul_inv]\n  exact mul_nonpos_of_nonpos_of_nonneg ha (inv_nonneg.2 hb)\n#align div_nonpos_of_nonpos_of_nonneg div_nonpos_of_nonpos_of_nonneg\n-/\n\n",
 "div_nonpos_of_nonneg_of_nonpos":
 "#print div_nonpos_of_nonneg_of_nonpos /-\ntheorem div_nonpos_of_nonneg_of_nonpos (ha : 0 ≤ a) (hb : b ≤ 0) : a / b ≤ 0 :=\n  by\n  rw [div_eq_mul_inv]\n  exact mul_nonpos_of_nonneg_of_nonpos ha (inv_nonpos.2 hb)\n#align div_nonpos_of_nonneg_of_nonpos div_nonpos_of_nonneg_of_nonpos\n-/\n\n",
 "div_nonpos_iff":
 "#print div_nonpos_iff /-\ntheorem div_nonpos_iff : a / b ≤ 0 ↔ 0 ≤ a ∧ b ≤ 0 ∨ a ≤ 0 ∧ 0 ≤ b := by simp [division_def, mul_nonpos_iff]\n#align div_nonpos_iff div_nonpos_iff\n-/\n\n",
 "div_nonneg_of_nonpos":
 "#print div_nonneg_of_nonpos /-\ntheorem div_nonneg_of_nonpos (ha : a ≤ 0) (hb : b ≤ 0) : 0 ≤ a / b :=\n  div_nonneg_iff.2 <| or.inr ⟨ha, hb⟩\n#align div_nonneg_of_nonpos div_nonneg_of_nonpos\n-/\n\n",
 "div_nonneg_iff":
 "#print div_nonneg_iff /-\ntheorem div_nonneg_iff : 0 ≤ a / b ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0 := by simp [division_def, mul_nonneg_iff]\n#align div_nonneg_iff div_nonneg_iff\n-/\n\n",
 "div_nonneg":
 "#print div_nonneg /-\ntheorem div_nonneg (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a / b :=\n  by\n  rw [div_eq_mul_inv]\n  exact mul_nonneg ha (inv_nonneg.2 hb)\n#align div_nonneg div_nonneg\n-/\n\n",
 "div_neg_of_pos_of_neg":
 "#print div_neg_of_pos_of_neg /-\ntheorem div_neg_of_pos_of_neg (ha : 0 < a) (hb : b < 0) : a / b < 0 :=\n  div_neg_iff.2 <| or.inl ⟨ha, hb⟩\n#align div_neg_of_pos_of_neg div_neg_of_pos_of_neg\n-/\n\n",
 "div_neg_of_neg_of_pos":
 "#print div_neg_of_neg_of_pos /-\ntheorem div_neg_of_neg_of_pos (ha : a < 0) (hb : 0 < b) : a / b < 0 :=\n  div_neg_iff.2 <| or.inr ⟨ha, hb⟩\n#align div_neg_of_neg_of_pos div_neg_of_neg_of_pos\n-/\n\n",
 "div_neg_iff":
 "#print div_neg_iff /-\ntheorem div_neg_iff : a / b < 0 ↔ 0 < a ∧ b < 0 ∨ a < 0 ∧ 0 < b := by simp [division_def, mul_neg_iff]\n#align div_neg_iff div_neg_iff\n-/\n\n",
 "div_mul_le_div_mul_of_div_le_div":
 "#print div_mul_le_div_mul_of_div_le_div /-\ntheorem div_mul_le_div_mul_of_div_le_div (h : a / b ≤ c / d) (he : 0 ≤ e) : a / (b * e) ≤ c / (d * e) :=\n  by\n  rw [div_mul_eq_div_mul_one_div, div_mul_eq_div_mul_one_div]\n  exact mul_le_mul_of_nonneg_right h (one_div_nonneg.2 he)\n#align div_mul_le_div_mul_of_div_le_div div_mul_le_div_mul_of_div_le_div\n-/\n\n",
 "div_lt_self":
 "#print div_lt_self /-\ntheorem div_lt_self (ha : 0 < a) (hb : 1 < b) : a / b < a := by\n  simpa only [div_one] using div_lt_div_of_lt_left ha zero_lt_one hb\n#align div_lt_self div_lt_self\n-/\n\n",
 "div_lt_one_of_neg":
 "#print div_lt_one_of_neg /-\ntheorem div_lt_one_of_neg (hb : b < 0) : a / b < 1 ↔ b < a := by rw [div_lt_iff_of_neg hb, one_mul]\n#align div_lt_one_of_neg div_lt_one_of_neg\n-/\n\n",
 "div_lt_one_iff":
 "#print div_lt_one_iff /-\ntheorem div_lt_one_iff : a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a :=\n  by\n  rcases lt_trichotomy b 0 with (hb | rfl | hb)\n  · simp [hb, hb.not_lt, hb.ne, div_lt_one_of_neg]\n  · simp [zero_lt_one]\n  · simp [hb, hb.not_lt, div_lt_one, hb.ne.symm]\n#align div_lt_one_iff div_lt_one_iff\n-/\n\n",
 "div_lt_one":
 "#print div_lt_one /-\ntheorem div_lt_one (hb : 0 < b) : a / b < 1 ↔ a < b := by rw [div_lt_iff hb, one_mul]\n#align div_lt_one div_lt_one\n-/\n\n",
 "div_lt_iff_of_neg'":
 "#print div_lt_iff_of_neg' /-\ntheorem div_lt_iff_of_neg' (hc : c < 0) : b / c < a ↔ c * a < b := by rw [mul_comm, div_lt_iff_of_neg hc]\n#align div_lt_iff_of_neg' div_lt_iff_of_neg'\n-/\n\n",
 "div_lt_iff_of_neg":
 "#print div_lt_iff_of_neg /-\ntheorem div_lt_iff_of_neg (hc : c < 0) : b / c < a ↔ a * c < b :=\n  lt_iff_lt_of_le_iff_le <| le_div_iff_of_neg hc\n#align div_lt_iff_of_neg div_lt_iff_of_neg\n-/\n\n",
 "div_lt_iff'":
 "#print div_lt_iff' /-\ntheorem div_lt_iff' (hc : 0 < c) : b / c < a ↔ b < c * a := by rw [mul_comm, div_lt_iff hc]\n#align div_lt_iff' div_lt_iff'\n-/\n\n",
 "div_lt_iff":
 "#print div_lt_iff /-\ntheorem div_lt_iff (hc : 0 < c) : b / c < a ↔ b < a * c :=\n  lt_iff_lt_of_le_iff_le (le_div_iff hc)\n#align div_lt_iff div_lt_iff\n-/\n\n",
 "div_lt_div_right_of_neg":
 "#print div_lt_div_right_of_neg /-\ntheorem div_lt_div_right_of_neg (hc : c < 0) : a / c < b / c ↔ b < a :=\n  lt_iff_lt_of_le_iff_le <| div_le_div_right_of_neg hc\n#align div_lt_div_right_of_neg div_lt_div_right_of_neg\n-/\n\n",
 "div_lt_div_right":
 "#print div_lt_div_right /-\ntheorem div_lt_div_right (hc : 0 < c) : a / c < b / c ↔ a < b :=\n  lt_iff_lt_of_le_iff_le <| div_le_div_right hc\n#align div_lt_div_right div_lt_div_right\n-/\n\n",
 "div_lt_div_of_neg_of_lt":
 "#print div_lt_div_of_neg_of_lt /-\ntheorem div_lt_div_of_neg_of_lt (hc : c < 0) (h : b < a) : a / c < b / c :=\n  by\n  rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]\n  exact mul_lt_mul_of_neg_right h (one_div_neg.2 hc)\n#align div_lt_div_of_neg_of_lt div_lt_div_of_neg_of_lt\n-/\n\n",
 "div_lt_div_of_lt_left":
 "#print div_lt_div_of_lt_left /-\ntheorem div_lt_div_of_lt_left (hc : 0 < c) (hb : 0 < b) (h : b < a) : c / a < c / b :=\n  (div_lt_div_left hc (hb.trans h) hb).mpr h\n#align div_lt_div_of_lt_left div_lt_div_of_lt_left\n-/\n\n",
 "div_lt_div_of_lt":
 "#print div_lt_div_of_lt /-\ntheorem div_lt_div_of_lt (hc : 0 < c) (h : a < b) : a / c < b / c :=\n  by\n  rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]\n  exact mul_lt_mul_of_pos_right h (one_div_pos.2 hc)\n#align div_lt_div_of_lt div_lt_div_of_lt\n-/\n\n",
 "div_lt_div_left":
 "#print div_lt_div_left /-\ntheorem div_lt_div_left (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : a / b < a / c ↔ c < b := by\n  simp only [div_eq_mul_inv, mul_lt_mul_left ha, inv_lt_inv hb hc]\n#align div_lt_div_left div_lt_div_left\n-/\n\n",
 "div_lt_div_iff":
 "#print div_lt_div_iff /-\ntheorem div_lt_div_iff (b0 : 0 < b) (d0 : 0 < d) : a / b < c / d ↔ a * d < c * b := by\n  rw [lt_div_iff d0, div_mul_eq_mul_div, div_lt_iff b0]\n#align div_lt_div_iff div_lt_div_iff\n-/\n\n",
 "div_lt_div'":
 "#print div_lt_div' /-\ntheorem div_lt_div' (hac : a ≤ c) (hbd : d < b) (c0 : 0 < c) (d0 : 0 < d) : a / b < c / d :=\n  (div_lt_div_iff (d0.trans hbd) d0).2 (mul_lt_mul' hac hbd d0.le c0)\n#align div_lt_div' div_lt_div'\n-/\n\n",
 "div_lt_div":
 "#print div_lt_div /-\ntheorem div_lt_div (hac : a < c) (hbd : d ≤ b) (c0 : 0 ≤ c) (d0 : 0 < d) : a / b < c / d :=\n  (div_lt_div_iff (d0.trans_le hbd) d0).2 (mul_lt_mul hac hbd d0 c0)\n#align div_lt_div div_lt_div\n-/\n\n",
 "div_le_self":
 "#print div_le_self /-\ntheorem div_le_self (ha : 0 ≤ a) (hb : 1 ≤ b) : a / b ≤ a := by\n  simpa only [div_one] using div_le_div_of_le_left ha zero_lt_one hb\n#align div_le_self div_le_self\n-/\n\n",
 "div_le_one_of_neg":
 "#print div_le_one_of_neg /-\ntheorem div_le_one_of_neg (hb : b < 0) : a / b ≤ 1 ↔ b ≤ a := by rw [div_le_iff_of_neg hb, one_mul]\n#align div_le_one_of_neg div_le_one_of_neg\n-/\n\n",
 "div_le_one_of_le":
 "#print div_le_one_of_le /-\ntheorem div_le_one_of_le (h : a ≤ b) (hb : 0 ≤ b) : a / b ≤ 1 :=\n  div_le_of_nonneg_of_le_mul hb zero_le_one <| by rwa [one_mul]\n#align div_le_one_of_le div_le_one_of_le\n-/\n\n",
 "div_le_one_of_ge":
 "#print div_le_one_of_ge /-\ntheorem div_le_one_of_ge (h : b ≤ a) (hb : b ≤ 0) : a / b ≤ 1 := by\n  simpa only [neg_div_neg_eq] using div_le_one_of_le (neg_le_neg h) (neg_nonneg_of_nonpos hb)\n#align div_le_one_of_ge div_le_one_of_ge\n-/\n\n",
 "div_le_one_iff":
 "#print div_le_one_iff /-\ntheorem div_le_one_iff : a / b ≤ 1 ↔ 0 < b ∧ a ≤ b ∨ b = 0 ∨ b < 0 ∧ b ≤ a :=\n  by\n  rcases lt_trichotomy b 0 with (hb | rfl | hb)\n  · simp [hb, hb.not_lt, hb.ne, div_le_one_of_neg]\n  · simp [zero_le_one]\n  · simp [hb, hb.not_lt, div_le_one, hb.ne.symm]\n#align div_le_one_iff div_le_one_iff\n-/\n\n",
 "div_le_one":
 "#print div_le_one /-\ntheorem div_le_one (hb : 0 < b) : a / b ≤ 1 ↔ a ≤ b := by rw [div_le_iff hb, one_mul]\n#align div_le_one div_le_one\n-/\n\n",
 "div_le_of_nonneg_of_le_mul":
 "#print div_le_of_nonneg_of_le_mul /-\n/-- One direction of `div_le_iff` where `b` is allowed to be `0` (but `c` must be nonnegative) -/\ntheorem div_le_of_nonneg_of_le_mul (hb : 0 ≤ b) (hc : 0 ≤ c) (h : a ≤ c * b) : a / b ≤ c :=\n  by\n  rcases eq_or_lt_of_le hb with (rfl | hb')\n  simp [hc]\n  rwa [div_le_iff hb']\n#align div_le_of_nonneg_of_le_mul div_le_of_nonneg_of_le_mul\n-/\n\n",
 "div_le_iff_of_neg'":
 "#print div_le_iff_of_neg' /-\ntheorem div_le_iff_of_neg' (hc : c < 0) : b / c ≤ a ↔ c * a ≤ b := by rw [mul_comm, div_le_iff_of_neg hc]\n#align div_le_iff_of_neg' div_le_iff_of_neg'\n-/\n\n",
 "div_le_iff_of_neg":
 "#print div_le_iff_of_neg /-\ntheorem div_le_iff_of_neg (hc : c < 0) : b / c ≤ a ↔ a * c ≤ b :=\n  ⟨fun h => div_mul_cancel b (ne_of_lt hc) ▸ mul_le_mul_of_nonpos_right h hc.le, fun h =>\n    calc\n      a = a * c * (1 / c) := mul_mul_div a (ne_of_lt hc)\n      _ ≥ b * (1 / c) := (mul_le_mul_of_nonpos_right h (one_div_neg.2 hc).le)\n      _ = b / c := (div_eq_mul_one_div b c).symm\n      ⟩\n#align div_le_iff_of_neg div_le_iff_of_neg\n-/\n\n",
 "div_le_iff'":
 "#print div_le_iff' /-\ntheorem div_le_iff' (hb : 0 < b) : a / b ≤ c ↔ a ≤ b * c := by rw [mul_comm, div_le_iff hb]\n#align div_le_iff' div_le_iff'\n-/\n\n",
 "div_le_iff":
 "#print div_le_iff /-\ntheorem div_le_iff (hb : 0 < b) : a / b ≤ c ↔ a ≤ c * b :=\n  ⟨fun h =>\n    calc\n      a = a / b * b := by rw [div_mul_cancel _ (ne_of_lt hb).symm]\n      _ ≤ c * b := mul_le_mul_of_nonneg_right h hb.le\n      ,\n    fun h =>\n    calc\n      a / b = a * (1 / b) := div_eq_mul_one_div a b\n      _ ≤ c * b * (1 / b) := (mul_le_mul_of_nonneg_right h (one_div_pos.2 hb).le)\n      _ = c * b / b := (div_eq_mul_one_div (c * b) b).symm\n      _ = c := by refine' (div_eq_iff (ne_of_gt hb)).mpr rfl\n      ⟩\n#align div_le_iff div_le_iff\n-/\n\n",
 "div_le_div_right_of_neg":
 "#print div_le_div_right_of_neg /-\ntheorem div_le_div_right_of_neg (hc : c < 0) : a / c ≤ b / c ↔ b ≤ a :=\n  ⟨le_imp_le_of_lt_imp_lt <| div_lt_div_of_neg_of_lt hc, div_le_div_of_nonpos_of_le <| hc.le⟩\n#align div_le_div_right_of_neg div_le_div_right_of_neg\n-/\n\n",
 "div_le_div_right":
 "#print div_le_div_right /-\ntheorem div_le_div_right (hc : 0 < c) : a / c ≤ b / c ↔ a ≤ b :=\n  ⟨le_imp_le_of_lt_imp_lt <| div_lt_div_of_lt hc, div_le_div_of_le <| hc.le⟩\n#align div_le_div_right div_le_div_right\n-/\n\n",
 "div_le_div_of_nonpos_of_le":
 "#print div_le_div_of_nonpos_of_le /-\ntheorem div_le_div_of_nonpos_of_le (hc : c ≤ 0) (h : b ≤ a) : a / c ≤ b / c :=\n  by\n  rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]\n  exact mul_le_mul_of_nonpos_right h (one_div_nonpos.2 hc)\n#align div_le_div_of_nonpos_of_le div_le_div_of_nonpos_of_le\n-/\n\n",
 "div_le_div_of_le_of_nonneg":
 "#print div_le_div_of_le_of_nonneg /-\ntheorem div_le_div_of_le_of_nonneg (hab : a ≤ b) (hc : 0 ≤ c) : a / c ≤ b / c :=\n  div_le_div_of_le hc hab\n#align div_le_div_of_le_of_nonneg div_le_div_of_le_of_nonneg\n-/\n\n",
 "div_le_div_of_le_left":
 "#print div_le_div_of_le_left /-\n-- Not a `mono` lemma b/c `div_le_div` is strictly more general\ntheorem div_le_div_of_le_left (ha : 0 ≤ a) (hc : 0 < c) (h : c ≤ b) : a / b ≤ a / c :=\n  by\n  rw [div_eq_mul_inv, div_eq_mul_inv]\n  exact mul_le_mul_of_nonneg_left ((inv_le_inv (hc.trans_le h) hc).mpr h) ha\n#align div_le_div_of_le_left div_le_div_of_le_left\n-/\n\n",
 "div_le_div_of_le":
 "#print div_le_div_of_le /-\n@[mono]\ntheorem div_le_div_of_le (hc : 0 ≤ c) (h : a ≤ b) : a / c ≤ b / c :=\n  by\n  rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]\n  exact mul_le_mul_of_nonneg_right h (one_div_nonneg.2 hc)\n#align div_le_div_of_le div_le_div_of_le\n-/\n\n",
 "div_le_div_left":
 "#print div_le_div_left /-\ntheorem div_le_div_left (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : a / b ≤ a / c ↔ c ≤ b :=\n  le_iff_le_iff_lt_iff_lt.2 (div_lt_div_left ha hc hb)\n#align div_le_div_left div_le_div_left\n-/\n\n",
 "div_le_div_iff":
 "#print div_le_div_iff /-\ntheorem div_le_div_iff (b0 : 0 < b) (d0 : 0 < d) : a / b ≤ c / d ↔ a * d ≤ c * b := by\n  rw [le_div_iff d0, div_mul_eq_mul_div, div_le_iff b0]\n#align div_le_div_iff div_le_div_iff\n-/\n\n",
 "div_le_div":
 "#print div_le_div /-\n@[mono]\ntheorem div_le_div (hc : 0 ≤ c) (hac : a ≤ c) (hd : 0 < d) (hbd : d ≤ b) : a / b ≤ c / d :=\n  by\n  rw [div_le_div_iff (hd.trans_le hbd) hd]\n  exact mul_le_mul hac hbd hd.le hc\n#align div_le_div div_le_div\n-/\n\n",
 "div_const":
 "#print StrictMono.div_const /-\ntheorem StrictMono.div_const {β : Type _} [preorder β] {f : β → α} (hf : StrictMono f) {c : α} (hc : 0 < c) :\n    StrictMono fun x => f x / c := by simpa only [div_eq_mul_inv] using hf.mul_const (inv_pos.2 hc)\n#align strict_mono.div_const StrictMono.div_const\n-/\n\n",
 "add_sub_div_two_lt":
 "#print add_sub_div_two_lt /-\ntheorem add_sub_div_two_lt (h : a < b) : a + (b - a) / 2 < b := by\n  rwa [← div_sub_div_same, sub_eq_add_neg, add_comm (b / 2), ← add_assoc, ← sub_eq_add_neg, ← lt_sub_iff_add_lt,\n    sub_self_div_two, sub_self_div_two, div_lt_div_right (zero_lt_two' α)]\n#align add_sub_div_two_lt add_sub_div_two_lt\n-/\n\n",
 "add_self_div_two":
 "#print add_self_div_two /-\n-- TODO: Generalize to `division_semiring`\ntheorem add_self_div_two (a : α) : (a + a) / 2 = a := by rw [← mul_two, mul_div_cancel a two_ne_zero]\n#align add_self_div_two add_self_div_two\n-/\n\n",
 "add_halves":
 "#print add_halves /-\n/- TODO: Unify `add_halves` and `add_halves'` into a single lemma about\n`division_semiring` + `char_zero` -/\ntheorem add_halves (a : α) : a / 2 + a / 2 = a := by rw [div_add_div_same, ← two_mul, mul_div_cancel_left a two_ne_zero]\n#align add_halves add_halves\n-/\n\n",
 "add_div_two_lt_right":
 "#print add_div_two_lt_right /-\ntheorem add_div_two_lt_right : (a + b) / 2 < b ↔ a < b := by simp [div_lt_iff, mul_two]\n#align add_div_two_lt_right add_div_two_lt_right\n-/\n\n",
 "abs_one_div":
 "#print abs_one_div /-\ntheorem abs_one_div (a : α) : |1 / a| = 1 / |a| := by rw [abs_div, abs_one]\n#align abs_one_div abs_one_div\n-/\n\n",
 "abs_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print abs_inv /-\ntheorem abs_inv (a : α) : |a⁻¹| = (|a|)⁻¹ :=\n  map_inv₀ (absHom : «expr →*₀ » α α) a\n#align abs_inv abs_inv\n-/\n\n",
 "abs_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print abs_div /-\ntheorem abs_div (a b : α) : |a / b| = |a| / |b| :=\n  map_div₀ (absHom : «expr →*₀ » α α) a b\n#align abs_div abs_div\n-/\n\n"}