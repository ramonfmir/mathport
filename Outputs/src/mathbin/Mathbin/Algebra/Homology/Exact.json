{"mono_iff_exact_zero_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mono_iff_exact_zero_left [has_kernels V] {B C : V} (f : «expr ⟶ » B C) : Mono f ↔ exact (0 : «expr ⟶ » 0 B) f :=\n  ⟨fun h => exact_zero_mono _, fun h =>\n    preadditive.mono_of_kernel_iso_zero\n      («expr ≪≫ » (kernel_subobject_iso f).symm (iso_zero_of_epi_zero (by simpa using h.epi)))⟩\n#align mono_iff_exact_zero_left mono_iff_exact_zero_left\n\n",
 "kernel_ι_eq_zero_of_exact_zero_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem kernel_ι_eq_zero_of_exact_zero_left (h : exact (0 : «expr ⟶ » A B) g) : kernel.ι g = 0 :=\n  by\n  rw [← kernel_subobject_arrow']\n  simp [kernel_subobject_arrow_eq_zero_of_exact_zero_left A h]\n#align kernel_ι_eq_zero_of_exact_zero_left kernel_ι_eq_zero_of_exact_zero_left\n\n",
 "kernel_subobject_arrow_eq_zero_of_exact_zero_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem kernel_subobject_arrow_eq_zero_of_exact_zero_left (h : exact (0 : «expr ⟶ » A B) g) :\n    (kernel_subobject g).arrow = 0 :=\n  by\n  rw [← cancel_epi (image_to_kernel (0 : «expr ⟶ » A B) g h.w), ←\n    cancel_epi (factor_thru_image_subobject (0 : «expr ⟶ » A B))]\n  simp\n#align kernel_subobject_arrow_eq_zero_of_exact_zero_left kernel_subobject_arrow_eq_zero_of_exact_zero_left\n\n",
 "kernel_comp_cokernel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem kernel_comp_cokernel (h : exact f g) : «expr ≫ » (kernel.ι g) (cokernel.π f) = 0 :=\n  by\n  rw [← kernel_subobject_arrow', category.assoc]\n  convert comp_zero\n  apply zero_of_epi_comp (image_to_kernel f g h.w) _\n  rw [image_to_kernel_arrow_assoc, ← image_subobject_arrow, category.assoc, ← iso.eq_inv_comp]\n  ext\n  simp\n#align kernel_comp_cokernel kernel_comp_cokernel\n\n",
 "image_to_kernel_is_iso_of_image_eq_kernel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem image_to_kernel_is_iso_of_image_eq_kernel {A B C : V} (f : «expr ⟶ » A B) (g : «expr ⟶ » B C)\n    (p : image_subobject f = kernel_subobject g) :\n    IsIso (image_to_kernel f g (comp_eq_zero_of_image_eq_kernel f g p)) :=\n  by\n  refine' ⟨⟨subobject.of_le _ _ p.ge, _⟩⟩\n  dsimp [image_to_kernel]\n  simp only [subobject.of_le_comp_of_le, subobject.of_le_refl]\n  simp\n#align image_to_kernel_is_iso_of_image_eq_kernel image_to_kernel_is_iso_of_image_eq_kernel\n\n",
 "fork_ι_comp_cofork_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem fork_ι_comp_cofork_π (h : exact f g) (s : kernel_fork g) (t : cokernel_cofork f) :\n    «expr ≫ » (fork.ι s) (cofork.π t) = 0 :=\n  comp_eq_zero_of_exact f g h (kernel_fork.condition s) (cokernel_cofork.condition t)\n#align fork_ι_comp_cofork_π fork_ι_comp_cofork_π\n\n",
 "exact_zero_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem exact_zero_mono {B C : V} (f : «expr ⟶ » B C) [Mono f] : exact (0 : «expr ⟶ » 0 B) f :=\n  ⟨by simp, infer_instance⟩\n#align exact_zero_mono exact_zero_mono\n\n",
 "exact_zero_left_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem exact_zero_left_of_mono [has_zero_object V] [Mono g] : exact (0 : «expr ⟶ » A B) g :=\n  ⟨by simp, image_to_kernel_epi_of_zero_of_mono _⟩\n#align exact_zero_left_of_mono exact_zero_left_of_mono\n\n",
 "exact_of_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem exact_of_zero {A C : V} (f : «expr ⟶ » A 0) (g : «expr ⟶ » 0 C) : exact f g :=\n  by\n  obtain rfl : f = 0 := by ext\n  obtain rfl : g = 0 := by ext\n  fconstructor\n  · simp\n  · exact image_to_kernel_epi_of_zero_of_mono 0\n#align exact_of_zero exact_of_zero\n\n",
 "exact_of_iso_of_exact'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- A reformulation of `preadditive.exact_of_iso_of_exact` that does not involve the arrow\ncategory. -/\ntheorem preadditive.exact_of_iso_of_exact' {A₁ B₁ C₁ A₂ B₂ C₂ : V} (f₁ : «expr ⟶ » A₁ B₁) (g₁ : «expr ⟶ » B₁ C₁)\n    (f₂ : «expr ⟶ » A₂ B₂) (g₂ : «expr ⟶ » B₂ C₂) (α : «expr ≅ » A₁ A₂) (β : «expr ≅ » B₁ B₂) (γ : «expr ≅ » C₁ C₂)\n    (hsq₁ : «expr ≫ » α.hom f₂ = «expr ≫ » f₁ β.hom) (hsq₂ : «expr ≫ » β.hom g₂ = «expr ≫ » g₁ γ.hom)\n    (h : exact f₁ g₁) : exact f₂ g₂ :=\n  preadditive.exact_of_iso_of_exact f₁ g₁ f₂ g₂ (arrow.iso_mk α β hsq₁) (arrow.iso_mk β γ hsq₂) rfl h\n#align preadditive.exact_of_iso_of_exact' preadditive.exact_of_iso_of_exact'\n\n",
 "exact_of_iso_of_exact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem preadditive.exact_of_iso_of_exact {A₁ B₁ C₁ A₂ B₂ C₂ : V} (f₁ : «expr ⟶ » A₁ B₁) (g₁ : «expr ⟶ » B₁ C₁)\n    (f₂ : «expr ⟶ » A₂ B₂) (g₂ : «expr ⟶ » B₂ C₂) (α : «expr ≅ » (arrow.mk f₁) (arrow.mk f₂))\n    (β : «expr ≅ » (arrow.mk g₁) (arrow.mk g₂)) (p : α.hom.right = β.hom.left) (h : exact f₁ g₁) : exact f₂ g₂ :=\n  by\n  rw [preadditive.exact_iff_homology_zero] at h⊢\n  rcases h with ⟨w₁, ⟨i⟩⟩\n  suffices w₂ : «expr ≫ » f₂ g₂ = 0; exact ⟨w₂, ⟨(homology.map_iso w₁ w₂ α β p).symm.trans i⟩⟩\n  rw [← cancel_epi α.hom.left, ← cancel_mono β.inv.right, comp_zero, zero_comp, ← w₁]\n  simp only [← arrow.mk_hom f₁, ← arrow.left_hom_inv_right α.hom, ← arrow.mk_hom g₁, ← arrow.left_hom_inv_right β.hom,\n    p]\n  simp only [arrow.mk_hom, is_iso.inv_hom_id_assoc, category.assoc, ← arrow.inv_right, is_iso.iso.inv_hom]\n#align preadditive.exact_of_iso_of_exact preadditive.exact_of_iso_of_exact\n\n",
 "exact_of_image_eq_kernel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- We'll prove the converse later, when `V` is abelian.\ntheorem exact_of_image_eq_kernel {A B C : V} (f : «expr ⟶ » A B) (g : «expr ⟶ » B C)\n    (p : image_subobject f = kernel_subobject g) : exact f g :=\n  { w := comp_eq_zero_of_image_eq_kernel f g p\n    epi := by\n      haveI := image_to_kernel_is_iso_of_image_eq_kernel f g p\n      infer_instance }\n#align exact_of_image_eq_kernel exact_of_image_eq_kernel\n\n",
 "exact_of_exact_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem exact_of_exact_map (F : «expr ⥤ » V W) [reflects_exact_sequences F] {A B C : V} {f : «expr ⟶ » A B}\n    {g : «expr ⟶ » B C} (hfg : exact (F.map f) (F.map g)) : exact f g :=\n  reflects_exact_sequences.reflects f g hfg\n#align exact_of_exact_map exact_of_exact_map\n\n",
 "exact_kernel_ι":
 "theorem exact_kernel_ι : exact (kernel.ι f) f :=\n  by\n  rw [← kernel_subobject_arrow', exact_iso_comp]\n  exact exact_kernel_subobject_arrow\n#align exact_kernel_ι exact_kernel_ι\n\n",
 "exact_kernel_subobject_arrow":
 "theorem exact_kernel_subobject_arrow : exact (kernel_subobject f).arrow f :=\n  by\n  refine' ⟨by simp, _⟩\n  apply @is_iso.epi_of_iso _ _ _ _ _ _\n  exact\n    ⟨⟨factor_thru_image_subobject _, by\n        ext\n        simp, by\n        ext\n        simp⟩⟩\n#align exact_kernel_subobject_arrow exact_kernel_subobject_arrow\n\n",
 "exact_iso_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem exact_iso_comp [IsIso f] : exact («expr ≫ » f g) h ↔ exact g h :=\n  ⟨fun w => by\n    rw [← is_iso.inv_hom_id_assoc f g]\n    exact exact_epi_comp w, fun w => exact_epi_comp w⟩\n#align exact_iso_comp exact_iso_comp\n\n",
 "exact_iff_homology_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel\n-/\n-- One nice feature of this definition is that we have\n-- `epi f → exact g h → exact (f ≫ g) h` and `exact f g → mono h → exact f (g ≫ h)`,\n-- which do not necessarily hold in a non-abelian category with the usual definition of `exact`.\n-- This works as an instance even though `exact` itself is not a class, as long as the goal is\n-- literally of the form `epi (image_to_kernel f g h.w)` (where `h : exact f g`). If the proof of\n-- `f ≫ g = 0` looks different, we are out of luck and have to add the instance by hand.\n/-- In any preadditive category,\ncomposable morphisms `f g` are exact iff they compose to zero and the homology vanishes.\n-/\ntheorem preadditive.exact_iff_homology_zero {A B C : V} (f : «expr ⟶ » A B) (g : «expr ⟶ » B C) :\n    exact f g ↔ ∃ w : «expr ≫ » f g = 0, nonempty («expr ≅ » (homology f g w) 0) :=\n  ⟨fun h => ⟨h.w, ⟨cokernel.of_epi _⟩⟩, fun h => by\n    obtain ⟨w, ⟨i⟩⟩ := h\n    exact ⟨w, preadditive.epi_of_cokernel_zero ((cancel_mono i.hom).mp (by ext))⟩⟩\n#align preadditive.exact_iff_homology_zero preadditive.exact_iff_homology_zero\n\n",
 "exact_iff_exact_of_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem preadditive.exact_iff_exact_of_iso {A₁ B₁ C₁ A₂ B₂ C₂ : V} (f₁ : «expr ⟶ » A₁ B₁) (g₁ : «expr ⟶ » B₁ C₁)\n    (f₂ : «expr ⟶ » A₂ B₂) (g₂ : «expr ⟶ » B₂ C₂) (α : «expr ≅ » (arrow.mk f₁) (arrow.mk f₂))\n    (β : «expr ≅ » (arrow.mk g₁) (arrow.mk g₂)) (p : α.hom.right = β.hom.left) : exact f₁ g₁ ↔ exact f₂ g₂ :=\n  ⟨preadditive.exact_of_iso_of_exact _ _ _ _ _ _ p,\n    preadditive.exact_of_iso_of_exact _ _ _ _ α.symm β.symm\n      (by\n        rw [← cancel_mono α.hom.right]\n        simp only [iso.symm_hom, ← comma.comp_right, α.inv_hom_id]\n        simp only [p, ← comma.comp_left, arrow.id_right, arrow.id_left, iso.inv_hom_id]\n        rfl)⟩\n#align preadditive.exact_iff_exact_of_iso preadditive.exact_iff_exact_of_iso\n\n",
 "exact_epi_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem exact_epi_zero {A B : V} (f : «expr ⟶ » A B) [Epi f] : exact f (0 : «expr ⟶ » B 0) :=\n  ⟨by simp, infer_instance⟩\n#align exact_epi_zero exact_epi_zero\n\n",
 "exact_epi_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem exact_epi_comp (hgh : exact g h) [Epi f] : exact («expr ≫ » f g) h :=\n  by\n  refine' ⟨by simp [hgh.w], _⟩\n  rw [image_to_kernel_comp_left]\n  infer_instance\n#align exact_epi_comp exact_epi_comp\n\n",
 "exact_comp_mono_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The dual of this lemma is only true when `V` is abelian, see `abelian.exact_epi_comp_iff`. -/\ntheorem exact_comp_mono_iff [Mono h] : exact f («expr ≫ » g h) ↔ exact f g :=\n  by\n  refine' ⟨fun hfg => ⟨zero_of_comp_mono h (by rw [category.assoc, hfg.1]), _⟩, fun h => exact_comp_mono h⟩\n  rw [← (iso.eq_comp_inv _).1 (image_to_kernel_comp_mono _ _ h hfg.1)]\n  haveI := hfg.2; infer_instance\n#align exact_comp_mono_iff exact_comp_mono_iff\n\n",
 "exact_comp_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem exact_comp_mono (hfg : exact f g) [Mono h] : exact f («expr ≫ » g h) :=\n  by\n  refine' ⟨by simp [hfg.w_assoc], _⟩\n  rw [image_to_kernel_comp_right f g h hfg.w]\n  infer_instance\n#align exact_comp_mono exact_comp_mono\n\n",
 "exact_comp_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem exact_comp_iso [IsIso h] : exact f («expr ≫ » g h) ↔ exact f g :=\n  exact_comp_mono_iff\n#align exact_comp_iso exact_comp_iso\n\n",
 "exact_comp_inv_hom_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem exact_comp_inv_hom_comp (i : «expr ≅ » D B) (h : exact f g) : exact («expr ≫ » f i.inv) («expr ≫ » i.hom g) :=\n  exact_comp_hom_inv_comp i.symm h\n#align exact_comp_inv_hom_comp exact_comp_inv_hom_comp\n\n",
 "exact_comp_hom_inv_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem exact_comp_hom_inv_comp_iff (i : «expr ≅ » B D) : exact («expr ≫ » f i.hom) («expr ≫ » i.inv g) ↔ exact f g :=\n  ⟨fun h => by simpa using exact_comp_inv_hom_comp i h, exact_comp_hom_inv_comp i⟩\n#align exact_comp_hom_inv_comp_iff exact_comp_hom_inv_comp_iff\n\n",
 "exact_comp_hom_inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem exact_comp_hom_inv_comp (i : «expr ≅ » B D) (h : exact f g) : exact («expr ≫ » f i.hom) («expr ≫ » i.inv g) :=\n  by\n  refine' ⟨by simp [h.w], _⟩\n  rw [image_to_kernel_comp_hom_inv_comp]\n  haveI := h.epi\n  infer_instance\n#align exact_comp_hom_inv_comp exact_comp_hom_inv_comp\n\n",
 "epi_iff_exact_zero_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem epi_iff_exact_zero_right [has_equalizers V] {A B : V} (f : «expr ⟶ » A B) :\n    Epi f ↔ exact f (0 : «expr ⟶ » B 0) :=\n  ⟨fun h => exact_epi_zero _, fun h => by\n    have e₁ := h.epi\n    rw [image_to_kernel_zero_right] at e₁\n    have e₂ :\n      epi\n        («expr ≫ » («expr ≫ » (image_subobject f).arrow (inv (kernel_subobject 0).arrow)) (kernel_subobject 0).arrow) :=\n      @epi_comp _ _ _ _ _ _ e₁ _ _\n    rw [category.assoc, is_iso.inv_hom_id, category.comp_id] at e₂\n    rw [← image_subobject_arrow] at e₂\n    skip\n    haveI : epi (image.ι f) := epi_of_epi (image_subobject_iso f).hom (image.ι f)\n    apply epi_of_epi_image⟩\n#align epi_iff_exact_zero_right epi_iff_exact_zero_right\n\n",
 "comp_eq_zero_of_image_eq_kernel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem comp_eq_zero_of_image_eq_kernel {A B C : V} (f : «expr ⟶ » A B) (g : «expr ⟶ » B C)\n    (p : image_subobject f = kernel_subobject g) : «expr ≫ » f g = 0 :=\n  by\n  rw [← image_subobject_arrow_comp f, category.assoc]\n  convert comp_zero\n  rw [p]\n  simp\n#align comp_eq_zero_of_image_eq_kernel comp_eq_zero_of_image_eq_kernel\n\n",
 "comp_eq_zero_of_exact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem comp_eq_zero_of_exact (h : exact f g) {X Y : V} {ι : «expr ⟶ » X B} (hι : «expr ≫ » ι g = 0) {π : «expr ⟶ » B Y}\n    (hπ : «expr ≫ » f π = 0) : «expr ≫ » ι π = 0 := by\n  rw [← kernel.lift_ι _ _ hι, ← cokernel.π_desc _ _ hπ, category.assoc, kernel_comp_cokernel_assoc _ _ h, zero_comp,\n    comp_zero]\n#align comp_eq_zero_of_exact comp_eq_zero_of_exact\n\n"}