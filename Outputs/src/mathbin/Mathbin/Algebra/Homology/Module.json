{"homology_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[ext]\ntheorem homology_ext' {M : ModuleCat R} (i : ι) {h k : «expr ⟶ » (C.homology i) M}\n    (w : ∀ x : LinearMap.ker (C.d_from i), h (to_homology x) = k (to_homology x)) : h = k :=\n  homology_ext _ w\n#align homology_ext' homology_ext'\n\n",
 "homology_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2021 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n/-- To prove that two maps out of a homology group are equal,\nit suffices to check they are equal on the images of cycles.\n-/\ntheorem homology_ext {L M N K : ModuleCat R} {f : «expr ⟶ » L M} {g : «expr ⟶ » M N} (w : «expr ≫ » f g = 0)\n    {h k : «expr ⟶ » (homology f g w) K}\n    (w :\n      ∀ x : LinearMap.ker g,\n        h (cokernel.π (imageToKernel _ _ w) (to_kernel_subobject x)) =\n          k (cokernel.π (imageToKernel _ _ w) (to_kernel_subobject x))) :\n    h = k := by\n  refine' cokernel_funext fun n => _\n  -- Gosh it would be nice if `equiv_rw` could directly use an isomorphism, or an enriched `≃`.\n  equiv_rw(«expr ≪≫ » (kernel_subobject_iso g) (Module.kernel_iso_ker g)).to_linear_equiv.to_equiv  at n\n  convert w n <;> simp [to_kernel_subobject]\n#align homology_ext homology_ext\n\n",
 "cycles_map_to_cycles":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem cycles_map_to_cycles (f : «expr ⟶ » C D) {i : ι} (x : LinearMap.ker (C.d_from i)) :\n    (cyclesMap f i) (to_cycles x) = to_cycles ⟨f.f i x.1, by simp [x.2]⟩ :=\n  by\n  ext\n  simp\n#align cycles_map_to_cycles cycles_map_to_cycles\n\n",
 "cycles_ext":
 "@[ext]\ntheorem cycles_ext {C : HomologicalComplex (ModuleCat.{u} R) c} {i : ι} {x y : C.cycles i}\n    (w : (C.cycles i).arrow x = (C.cycles i).arrow y) : x = y :=\n  by\n  apply_fun (C.cycles i).arrow using (ModuleCat.mono_iff_injective _).mp (cycles C i).arrow_mono\n  exact w\n#align cycles_ext cycles_ext\n\n"}