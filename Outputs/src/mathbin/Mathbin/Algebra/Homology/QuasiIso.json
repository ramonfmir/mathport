{"to_single₀_exact_d_f_at_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\ntheorem to_single₀_exact_d_f_at_zero [hf : quasi_iso f] : Exact (X.d 1 0) (f.f 0) :=\n  by\n  rw [preadditive.exact_iff_homology_zero]\n  have h : «expr ≫ » (X.d 1 0) (f.f 0) = 0 := by simp only [← f.2 1 0 rfl, ChainComplex.single₀_obj_X_d, comp_zero]\n  refine' ⟨h, nonempty.intro («expr ≪≫ » (homology_iso_kernel_desc _ _ _) _)⟩\n  · suffices is_iso (cokernel.desc _ _ h) by\n      haveI := this\n      apply kernel.of_mono\n    rw [← to_single₀_cokernel_at_zero_iso_hom_eq]\n    infer_instance\n#align to_single₀_exact_d_f_at_zero to_single₀_exact_d_f_at_zero\n\n",
 "to_single₀_exact_at_succ":
 "theorem to_single₀_exact_at_succ [hf : quasi_iso f] (n : ℕ) : Exact (X.d (n + 2) (n + 1)) (X.d (n + 1) n) :=\n  (Preadditive.exact_iff_homology_zero _ _).2\n    ⟨X.d_comp_d _ _ _,\n      ⟨(ChainComplex.homologySuccIso _ _).symm.trans ((@asIso _ _ _ _ _ (hf.1 (n + 1))).trans homologyZeroZero)⟩⟩\n#align to_single₀_exact_at_succ to_single₀_exact_at_succ\n\n",
 "to_single₀_epi_at_zero":
 "theorem to_single₀_epi_at_zero [hf : quasi_iso f] : Epi (f.f 0) :=\n  by\n  constructor\n  intro Z g h Hgh\n  rw [← cokernel.π_desc (X.d 1 0) (f.f 0) (by rw [← f.2 1 0 rfl] <;> exact comp_zero), ←\n    to_single₀_cokernel_at_zero_iso_hom_eq] at Hgh\n  rw [(@cancel_epi _ _ _ _ _ _ (epi_comp _ _) _ _).1 Hgh]\n#align to_single₀_epi_at_zero to_single₀_epi_at_zero\n\n",
 "to_single₀_cokernel_at_zero_iso_hom_eq":
 "theorem to_single₀_cokernel_at_zero_iso_hom_eq [hf : quasi_iso f] :\n    f.to_single₀_cokernel_at_zero_iso.hom =\n      cokernel.desc (X.d 1 0) (f.f 0) (by rw [← f.2 1 0 rfl] <;> exact comp_zero) :=\n  by\n  ext\n  dsimp only [to_single₀_cokernel_at_zero_iso, ChainComplex.homologyZeroIso, homologyOfZeroRight, homology.mapIso,\n    ChainComplex.homologyFunctor0Single₀, cokernel.map]\n  dsimp\n  simp only [cokernel.π_desc, category.assoc, homology.map_desc, cokernel.π_desc_assoc]\n  simp [homology.desc, iso.refl_inv (X.X 0)]\n#align to_single₀_cokernel_at_zero_iso_hom_eq to_single₀_cokernel_at_zero_iso_hom_eq\n\n",
 "to_quasi_iso_inv":
 "theorem to_quasi_iso_inv {C D : HomologicalComplex W c} (e : HomotopyEquiv C D) (i : ι) :\n    (@asIso _ _ _ _ _ (e.to_quasi_iso.1 i)).inv = (homologyFunctor W c i).map e.inv :=\n  by\n  symm\n  simp only [← iso.hom_comp_eq_id, as_iso_hom, ← functor.map_comp, ← (homologyFunctor W c i).map_id,\n    homology_map_eq_of_homotopy e.homotopy_hom_inv_id _]\n#align to_quasi_iso_inv to_quasi_iso_inv\n\n",
 "to_quasi_iso":
 "/-- An homotopy equivalence is a quasi-isomorphism. -/\ntheorem to_quasi_iso {C D : HomologicalComplex W c} (e : HomotopyEquiv C D) : quasi_iso e.hom :=\n  ⟨fun i => by\n    refine' ⟨⟨(homologyFunctor W c i).map e.inv, _⟩⟩\n    simp only [← functor.map_comp, ← (homologyFunctor W c i).map_id]\n    constructor <;> apply homology_map_eq_of_homotopy\n    exacts[e.homotopy_hom_inv_id, e.homotopy_inv_hom_id]⟩\n#align to_quasi_iso to_quasi_iso\n\n",
 "quasi_iso_of_map_quasi_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem category_theory.functor.quasi_iso_of_map_quasi_iso {C D : HomologicalComplex A c} (f : «expr ⟶ » C D)\n    (hf : quasi_iso ((F.map_homological_complex _).map f)) : quasi_iso f :=\n  ⟨fun i =>\n    haveI : is_iso (F.map ((homologyFunctor A c i).map f)) :=\n      by\n      rw [← functor.comp_map, ← nat_iso.naturality_2 (F.homology_functor_iso i) f, functor.comp_map]\n      infer_instance\n    is_iso_of_reflects_iso _ F⟩\n#align category_theory.functor.quasi_iso_of_map_quasi_iso category_theory.functor.quasi_iso_of_map_quasi_iso\n\n",
 "quasi_iso_of_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem quasi_iso_of_comp_right (f : «expr ⟶ » C D) (g : «expr ⟶ » D E) [quasi_iso g] [quasi_iso («expr ≫ » f g)] :\n    quasi_iso f :=\n  { is_iso := fun i => IsIso.of_isIso_fac_right ((homologyFunctor V c i).map_comp f g).symm }\n#align quasi_iso_of_comp_right quasi_iso_of_comp_right\n\n",
 "quasi_iso_of_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2021 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Joël Riou\n-/\ntheorem quasi_iso_of_comp_left (f : «expr ⟶ » C D) [quasi_iso f] (g : «expr ⟶ » D E) [quasi_iso («expr ≫ » f g)] :\n    quasi_iso g :=\n  { is_iso := fun i => IsIso.of_isIso_fac_left ((homologyFunctor V c i).map_comp f g).symm }\n#align quasi_iso_of_comp_left quasi_iso_of_comp_left\n\n",
 "from_single₀_mono_at_zero":
 "theorem from_single₀_mono_at_zero [hf : quasi_iso f] : Mono (f.f 0) :=\n  by\n  constructor\n  intro Z g h Hgh\n  rw [← kernel.lift_ι (X.d 0 1) (f.f 0) (by rw [f.2 0 1 rfl] <;> exact zero_comp), ←\n    from_single₀_kernel_at_zero_iso_inv_eq] at Hgh\n  rw [(@cancel_mono _ _ _ _ _ _ (mono_comp _ _) _ _).1 Hgh]\n#align from_single₀_mono_at_zero from_single₀_mono_at_zero\n\n",
 "from_single₀_kernel_at_zero_iso_inv_eq":
 "theorem from_single₀_kernel_at_zero_iso_inv_eq [hf : quasi_iso f] :\n    f.from_single₀_kernel_at_zero_iso.inv = kernel.lift (X.d 0 1) (f.f 0) (by rw [f.2 0 1 rfl] <;> exact zero_comp) :=\n  by\n  ext\n  dsimp only [from_single₀_kernel_at_zero_iso, CochainComplex.homologyZeroIso, homologyOfZeroLeft, homology.mapIso,\n    CochainComplex.homologyFunctor0Single₀, kernel.map]\n  simp only [iso.trans_inv, iso.app_inv, iso.symm_inv, category.assoc, equalizer_as_kernel, kernel.lift_ι]\n  dsimp\n  simp only [category.assoc, homology.π_map, cokernel_zero_iso_target_hom, cokernel_iso_of_eq_hom_comp_desc,\n    kernel_subobject_arrow, homology.π_map_assoc, is_iso.inv_comp_eq]\n  simp [homology.π, kernel_subobject_map_comp, iso.refl_hom (X.X 0), category.comp_id]\n#align from_single₀_kernel_at_zero_iso_inv_eq from_single₀_kernel_at_zero_iso_inv_eq\n\n",
 "from_single₀_exact_f_d_at_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ » -/\ntheorem from_single₀_exact_f_d_at_zero [hf : quasi_iso f] : Exact (f.f 0) (X.d 0 1) :=\n  by\n  rw [preadditive.exact_iff_homology_zero]\n  have h : «expr ≫ » (f.f 0) (X.d 0 1) = 0 := by\n    simp only [HomologicalComplex.Hom.comm, CochainComplex.single₀_obj_X_d, zero_comp]\n  refine' ⟨h, nonempty.intro («expr ≪≫ » (homologyIsoCokernelLift _ _ _) _)⟩\n  · suffices is_iso (kernel.lift (X.d 0 1) (f.f 0) h) by\n      haveI := this\n      apply cokernel.of_epi\n    rw [← from_single₀_kernel_at_zero_iso_inv_eq f]\n    infer_instance\n#align from_single₀_exact_f_d_at_zero from_single₀_exact_f_d_at_zero\n\n",
 "from_single₀_exact_at_succ":
 "theorem from_single₀_exact_at_succ [hf : quasi_iso f] (n : ℕ) : Exact (X.d n (n + 1)) (X.d (n + 1) (n + 2)) :=\n  (Preadditive.exact_iff_homology_zero _ _).2\n    ⟨X.d_comp_d _ _ _,\n      ⟨(CochainComplex.homologySuccIso _ _).symm.trans ((@asIso _ _ _ _ _ (hf.1 (n + 1))).symm.trans homologyZeroZero)⟩⟩\n#align from_single₀_exact_at_succ from_single₀_exact_at_succ\n\n"}