{"π_section_eq_id_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem π_section_eq_id_sub : «expr ≫ » g h.section = («expr𝟙») _ - «expr ≫ » h.retraction f :=\n  eq_sub_iff_add_eq.mpr ((add_comm _ _).trans h.split_add)\n#align π_section_eq_id_sub π_section_eq_id_sub\n\n",
 "ι_retraction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp, reassoc.1]\ntheorem ι_retraction : «expr ≫ » f h.retraction = («expr𝟙») A :=\n  by\n  delta retraction\n  simp\n#align ι_retraction ι_retraction\n\n",
 "splittings_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem splittings_comm (h h' : splitting f g) :\n    «expr ≫ » h'.section h.retraction = -«expr ≫ » h.section h'.retraction :=\n  by\n  haveI := h.mono\n  rw [← cancel_mono f]\n  simp [retraction_ι_eq_id_sub]\n#align splittings_comm splittings_comm\n\n",
 "split_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem split_add : «expr ≫ » h.retraction f + «expr ≫ » g h.section = («expr𝟙») _ :=\n  by\n  delta splitting.section retraction\n  rw [← cancel_mono h.iso.hom, ← cancel_epi h.iso.inv]\n  simp only [category.comp_id, category.id_comp, category.assoc, iso.inv_hom_id_assoc, iso.inv_hom_id,\n    limits.biprod.total, preadditive.comp_add, preadditive.add_comp, splitting.comp_iso_eq_inl,\n    splitting.iso_comp_eq_snd_assoc]\n#align split_add split_add\n\n",
 "split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem split : split f g := by\n  let φ := «expr ≫ » h.iso.hom biprod.fst\n  let χ := «expr ≫ » biprod.inr h.iso.inv\n  refine' ⟨⟨h.retraction, h.section, h.ι_retraction, h.section_π, _, h.section_retraction, h.split_add⟩⟩\n  rw [← h.inl_comp_iso_eq, category.assoc, h.iso_comp_eq_snd, biprod.inl_snd]\n#align split split\n\n",
 "short_exact":
 "protected theorem short_exact : short_exact f g :=\n  { mono := h.mono\n    epi := h.epi\n    exact := h.exact }\n#align short_exact short_exact\n\n",
 "section_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp, reassoc.1]\ntheorem section_π : «expr ≫ » h.section g = («expr𝟙») C :=\n  by\n  delta splitting.section\n  simp\n#align section_π section_π\n\n",
 "section_retraction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem section_retraction : «expr ≫ » h.section h.retraction = 0 :=\n  by\n  delta splitting.section retraction\n  simp\n#align section_retraction section_retraction\n\n",
 "right_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem split.right_split (h : split f g) : right_split f g :=\n  { right_split := by\n      obtain ⟨φ, χ, -, h1, -⟩ := h\n      exact ⟨χ, h1⟩\n    mono := by\n      obtain ⟨φ, χ, h1, -⟩ := h\n      have : mono («expr ≫ » f φ) := by\n        rw [h1]\n        infer_instance\n      exact mono_of_mono f φ\n    exact := h.exact }\n#align split.right_split split.right_split\n\n",
 "retraction_ι_eq_id_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem retraction_ι_eq_id_sub : «expr ≫ » h.retraction f = («expr𝟙») _ - «expr ≫ » g h.section :=\n  eq_sub_iff_add_eq.mpr h.split_add\n#align retraction_ι_eq_id_sub retraction_ι_eq_id_sub\n\n",
 "mono":
 "protected theorem mono : Mono f := by\n  apply mono_of_mono _ h.retraction\n  rw [h.ι_retraction]\n  infer_instance\n#align mono mono\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem split.map {𝒜 ℬ : Type _} [Category 𝒜] [preadditive 𝒜] [Category ℬ] [preadditive ℬ] (F : «expr ⥤ » 𝒜 ℬ)\n    [functor.additive F] {A B C : 𝒜} {f : «expr ⟶ » A B} {g : «expr ⟶ » B C} (h : split f g) :\n    split (F.map f) (F.map g) := by\n  obtain ⟨φ, χ, h1, h2, h3, h4, h5⟩ := h\n  refine' ⟨⟨F.map φ, F.map χ, _⟩⟩\n  simp only [← F.map_comp, ← F.map_id, ← F.map_add, F.map_zero, *, eq_self_iff_true, and_true_iff]\n#align split.map split.map\n\n",
 "left_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem split.left_split (h : split f g) : left_split f g :=\n  { left_split := by\n      obtain ⟨φ, χ, h1, -⟩ := h\n      exact ⟨φ, h1⟩\n    epi := by\n      obtain ⟨φ, χ, -, h2, -⟩ := h\n      have : epi («expr ≫ » χ g) := by\n        rw [h2]\n        infer_instance\n      exact epi_of_epi χ g\n    exact := h.exact }\n#align split.left_split split.left_split\n\n",
 "iso_hom_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem iso_hom_fst : «expr ≫ » h.iso.hom biprod.fst = h.retraction :=\n  rfl\n#align iso_hom_fst iso_hom_fst\n\n",
 "iso_comp_eq_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem iso_comp_eq_snd : «expr ≫ » h.iso.inv g = biprod.snd := by rw [iso.inv_comp_eq, h.iso_comp_snd_eq]\n#align iso_comp_eq_snd iso_comp_eq_snd\n\n",
 "inr_iso_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem inr_iso_inv : «expr ≫ » biprod.inr h.iso.inv = h.section :=\n  rfl\n#align inr_iso_inv inr_iso_inv\n\n",
 "inl_comp_iso_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem inl_comp_iso_eq : «expr ≫ » biprod.inl h.iso.inv = f := by rw [iso.comp_inv_eq, h.comp_iso_eq_inl]\n#align inl_comp_iso_eq inl_comp_iso_eq\n\n",
 "exact_of_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem exact_of_split {A B C : 𝒜} {f : «expr ⟶ » A B} {g : «expr ⟶ » B C} {χ : «expr ⟶ » C B} {φ : «expr ⟶ » B A}\n    (hfg : «expr ≫ » f g = 0) (H : «expr ≫ » φ f + «expr ≫ » g χ = («expr𝟙») B) : exact f g :=\n  { w := hfg\n    epi :=\n      by\n      let ψ : «expr ⟶ » (kernel_subobject g : 𝒜) (image_subobject f) :=\n        «expr ≫ » (subobject.arrow _) («expr ≫ » φ (factor_thru_image_subobject f))\n      suffices «expr ≫ » ψ (image_to_kernel f g hfg) = («expr𝟙») _\n        by\n        convert epi_of_epi ψ _\n        rw [this]\n        infer_instance\n      rw [← cancel_mono (subobject.arrow _)]\n      swap\n      · infer_instance\n      simp only [image_to_kernel_arrow, image_subobject_arrow_comp, category.id_comp, category.assoc]\n      calc\n        «expr ≫ » (kernel_subobject g).arrow («expr ≫ » φ f) = «expr ≫ » (kernel_subobject g).arrow ((«expr𝟙») B) := _\n        _ = (kernel_subobject g).arrow := category.comp_id _\n        \n      rw [← H, preadditive.comp_add]\n      simp only [add_zero, zero_comp, kernel_subobject_arrow_comp_assoc] }\n#align exact_of_split exact_of_split\n\n",
 "exact_inr_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/-- The sequence `B ⟶ A ⊞ B ⟶ A` is exact. -/\ntheorem exact_inr_fst [has_binary_biproducts 𝒜] (A B : 𝒜) :\n    exact (biprod.inr : «expr ⟶ » B («expr ⊞ » A B)) biprod.fst :=\n  exact_of_split biprod.inr_fst ((add_comm _ _).trans biprod.total)\n#align exact_inr_fst exact_inr_fst\n\n",
 "exact_inl_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/-- The sequence `A ⟶ A ⊞ B ⟶ B` is exact. -/\ntheorem exact_inl_snd [has_binary_biproducts 𝒜] (A B : 𝒜) :\n    exact (biprod.inl : «expr ⟶ » A («expr ⊞ » A B)) biprod.snd :=\n  exact_of_split biprod.inl_snd biprod.total\n#align exact_inl_snd exact_inl_snd\n\n",
 "exact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊞ » -/\nprotected theorem exact : exact f g :=\n  by\n  rw [exact_iff_exact_of_iso f g (biprod.inl : «expr ⟶ » A («expr ⊞ » A C)) (biprod.snd : «expr ⟶ » («expr ⊞ » A C) C) _\n      _ _]\n  · exact exact_inl_snd _ _\n  · refine' arrow.iso_mk (iso.refl _) h.iso _\n    simp only [iso.refl_hom, arrow.mk_hom, category.id_comp, comp_iso_eq_inl]\n  · refine' arrow.iso_mk h.iso (iso.refl _) _\n    dsimp\n    simp\n  · rfl\n#align exact exact\n\n",
 "epi":
 "protected theorem epi : Epi g :=\n  by\n  apply (config := { instances := false }) epi_of_epi h.section\n  rw [h.section_π]\n  infer_instance\n#align epi epi\n\n",
 "comp_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem comp_eq_zero : «expr ≫ » f g = 0 :=\n  h.split.1.some_spec.some_spec.2.2.1\n#align comp_eq_zero comp_eq_zero\n\n"}