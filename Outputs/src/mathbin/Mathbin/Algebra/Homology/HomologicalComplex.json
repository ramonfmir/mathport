{"zero_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem zero_apply (C D : HomologicalComplex V c) (i : Î¹) : (0 : Â«expr âŸ¶ Â» C D).f i = 0 :=\n  rfl\n#align zero_apply zero_apply\n\n",
 "sq_to_right":
 "@[simp]\ntheorem sq_to_right (f : Hom Câ‚ Câ‚‚) (j : Î¹) : (f.sq_to j).right = f.f j :=\n  rfl\n#align sq_to_right sq_to_right\n\n",
 "sq_to_left":
 "@[simp]\ntheorem sq_to_left (f : Hom Câ‚ Câ‚‚) (j : Î¹) : (f.sq_to j).left = f.prev j :=\n  rfl\n#align sq_to_left sq_to_left\n\n",
 "sq_from_right":
 "@[simp]\ntheorem sq_from_right (f : Hom Câ‚ Câ‚‚) (i : Î¹) : (f.sq_from i).right = f.next i :=\n  rfl\n#align sq_from_right sq_from_right\n\n",
 "sq_from_left":
 "@[simp]\ntheorem sq_from_left (f : Hom Câ‚ Câ‚‚) (i : Î¹) : (f.sq_from i).left = f.f i :=\n  rfl\n#align sq_from_left sq_from_left\n\n",
 "sq_from_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem sq_from_id (Câ‚ : HomologicalComplex V c) (i : Î¹) : sqFrom ((Â«exprğŸ™Â») Câ‚) i = (Â«exprğŸ™Â») _ :=\n  rfl\n#align sq_from_id sq_from_id\n\n",
 "sq_from_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem sq_from_comp (f : Â«expr âŸ¶ Â» Câ‚ Câ‚‚) (g : Â«expr âŸ¶ Â» Câ‚‚ Câ‚ƒ) (i : Î¹) :\n    sqFrom (Â«expr â‰« Â» f g) i = Â«expr â‰« Â» (sqFrom f i) (sqFrom g i) :=\n  rfl\n#align sq_from_comp sq_from_comp\n\n",
 "prev_nat_zero":
 "@[simp]\ntheorem prev_nat_zero : (ComplexShape.up â„•).prev 0 = 0 := by\n  classical\n    refine' dif_neg _\n    push_neg\n    intro\n    apply nat.no_confusion\n#align prev_nat_zero prev_nat_zero\n\n",
 "prev_nat_succ":
 "@[simp]\ntheorem prev_nat_succ (i : â„•) : (ComplexShape.up â„•).prev (i + 1) = i :=\n  (ComplexShape.up â„•).prev_eq' rfl\n#align prev_nat_succ prev_nat_succ\n\n",
 "prev_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem prev_eq (f : Hom Câ‚ Câ‚‚) {i j : Î¹} (w : c.rel i j) :\n    f.prev j = Â«expr â‰« Â» (Câ‚.X_prev_iso w).hom (Â«expr â‰« Â» (f.f i) (Câ‚‚.X_prev_iso w).inv) :=\n  by\n  obtain rfl := c.prev_eq' w\n  simp only [X_prev_iso, eq_to_iso_refl, iso.refl_hom, iso.refl_inv, id_comp, comp_id]\n#align prev_eq prev_eq\n\n",
 "prev":
 "@[simp]\ntheorem prev (Î± : Type _) [AddGroup Î±] [One Î±] (i : Î±) : (ComplexShape.up Î±).prev i = i - 1 :=\n  (ComplexShape.up Î±).prev_eq' <| sub_add_cancel _ _\n#align prev prev\n\n",
 "of_d_ne":
 "theorem of_d_ne {i j : Î±} (h : i + 1 â‰  j) : (of X d sq).d i j = 0 :=\n  by\n  dsimp [of]\n  rw [dif_neg h]\n#align of_d_ne of_d_ne\n\n",
 "of_d":
 "@[simp]\ntheorem of_d (j : Î±) : (of X d sq).d j (j + 1) = d j :=\n  by\n  dsimp [of]\n  rw [if_pos rfl, category.comp_id]\n#align of_d of_d\n\n",
 "of_X":
 "@[simp]\ntheorem of_X (n : Î±) : (of X d sq).X n = X n :=\n  rfl\n#align of_X of_X\n\n",
 "next_nat_zero":
 "@[simp]\ntheorem next_nat_zero : (ComplexShape.down â„•).next 0 = 0 := by\n  classical\n    refine' dif_neg _\n    push_neg\n    intro\n    apply nat.no_confusion\n#align next_nat_zero next_nat_zero\n\n",
 "next_nat_succ":
 "@[simp]\ntheorem next_nat_succ (i : â„•) : (ComplexShape.down â„•).next (i + 1) = i :=\n  (ComplexShape.down â„•).next_eq' rfl\n#align next_nat_succ next_nat_succ\n\n",
 "next_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem next_eq (f : Hom Câ‚ Câ‚‚) {i j : Î¹} (w : c.rel i j) :\n    f.next i = Â«expr â‰« Â» (Câ‚.X_next_iso w).hom (Â«expr â‰« Â» (f.f j) (Câ‚‚.X_next_iso w).inv) :=\n  by\n  obtain rfl := c.next_eq' w\n  simp only [X_next_iso, eq_to_iso_refl, iso.refl_hom, iso.refl_inv, id_comp, comp_id]\n#align next_eq next_eq\n\n",
 "next":
 "@[simp]\ntheorem next (Î± : Type _) [AddRightCancelSemigroup Î±] [One Î±] (i : Î±) : (ComplexShape.up Î±).next i = i + 1 :=\n  (ComplexShape.up Î±).next_eq' rfl\n#align next next\n\n",
 "mk_hom_f_succ_succ":
 "@[simp]\ntheorem mk_hom_f_succ_succ (n : â„•) :\n    (mkHom P Q zero one one_zero_comm succ).f (n + 2) =\n      (succ n\n          âŸ¨(mkHom P Q zero one one_zero_comm succ).f n, (mkHom P Q zero one one_zero_comm succ).f (n + 1),\n            (mkHom P Q zero one one_zero_comm succ).comm n (n + 1)âŸ©).1 :=\n  by\n  dsimp [mk_hom, mk_hom_aux]\n  induction n <;> congr\n#align mk_hom_f_succ_succ mk_hom_f_succ_succ\n\n",
 "mk_hom_f_1":
 "@[simp]\ntheorem mk_hom_f_1 : (mkHom P Q zero one one_zero_comm succ).f 1 = one :=\n  rfl\n#align mk_hom_f_1 mk_hom_f_1\n\n",
 "mk_hom_f_0":
 "-- TODO simp lemmas for the inductive steps? It's not entirely clear that they are needed.\n@[simp]\ntheorem mk_hom_f_0 : (mkHom P Q zero one one_zero_comm succ).f 0 = zero :=\n  rfl\n#align mk_hom_f_0 mk_hom_f_0\n\n",
 "mk_d_2_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem mk_d_2_0 : (mk Xâ‚€ Xâ‚ Xâ‚‚ dâ‚€ dâ‚ s succ).d 1 2 = dâ‚ :=\n  by\n  change ite (2 = 1 + 1) (Â«expr â‰« Â» dâ‚ ((Â«exprğŸ™Â») Xâ‚‚)) 0 = dâ‚\n  rw [if_pos rfl, category.comp_id]\n#align mk_d_2_0 mk_d_2_0\n\n",
 "mk_d_1_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem mk_d_1_0 : (mk Xâ‚€ Xâ‚ Xâ‚‚ dâ‚€ dâ‚ s succ).d 0 1 = dâ‚€ :=\n  by\n  change ite (1 = 0 + 1) (Â«expr â‰« Â» dâ‚€ ((Â«exprğŸ™Â») Xâ‚)) 0 = dâ‚€\n  rw [if_pos rfl, category.comp_id]\n#align mk_d_1_0 mk_d_1_0\n\n",
 "mk_X_2":
 "@[simp]\ntheorem mk_X_2 : (mk Xâ‚€ Xâ‚ Xâ‚‚ dâ‚€ dâ‚ s succ).X 2 = Xâ‚‚ :=\n  rfl\n#align mk_X_2 mk_X_2\n\n",
 "mk_X_1":
 "@[simp]\ntheorem mk_X_1 : (mk Xâ‚€ Xâ‚ Xâ‚‚ dâ‚€ dâ‚ s succ).X 1 = Xâ‚ :=\n  rfl\n#align mk_X_1 mk_X_1\n\n",
 "mk_X_0":
 "@[simp]\ntheorem mk_X_0 : (mk Xâ‚€ Xâ‚ Xâ‚‚ dâ‚€ dâ‚ s succ).X 0 = Xâ‚€ :=\n  rfl\n#align mk_X_0 mk_X_0\n\n",
 "mk'_d_1_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem mk'_d_1_0 : (mk' Xâ‚€ Xâ‚ dâ‚€ succ').d 0 1 = dâ‚€ :=\n  by\n  change ite (1 = 0 + 1) (Â«expr â‰« Â» dâ‚€ ((Â«exprğŸ™Â») Xâ‚)) 0 = dâ‚€\n  rw [if_pos rfl, category.comp_id]\n#align mk'_d_1_0 mk'_d_1_0\n\n",
 "mk'_X_1":
 "@[simp]\ntheorem mk'_X_1 : (mk' Xâ‚€ Xâ‚ dâ‚€ succ').X 1 = Xâ‚ :=\n  rfl\n#align mk'_X_1 mk'_X_1\n\n",
 "mk'_X_0":
 "-- TODO simp lemmas for the inductive steps? It's not entirely clear that they are needed.\n@[simp]\ntheorem mk'_X_0 : (mk' Xâ‚€ Xâ‚ dâ‚€ succ').X 0 = Xâ‚€ :=\n  rfl\n#align mk'_X_0 mk'_X_0\n\n",
 "kernel_from_eq_kernel":
 "theorem kernel_from_eq_kernel [HasKernels V] {i j : Î¹} (r : c.rel i j) :\n    kernelSubobject (C.d_from i) = kernelSubobject (C.d i j) :=\n  by\n  rw [C.d_from_eq r]\n  apply kernel_subobject_comp_mono\n#align kernel_from_eq_kernel kernel_from_eq_kernel\n\n",
 "kernel_eq_kernel":
 "theorem kernel_eq_kernel [HasKernels V] {i j j' : Î¹} (r : c.rel i j) (r' : c.rel i j') :\n    kernelSubobject (C.d i j) = kernelSubobject (C.d i j') :=\n  by\n  rw [â† d_comp_eq_to_hom C r r']\n  apply kernel_subobject_comp_mono\n#align kernel_eq_kernel kernel_eq_kernel\n\n",
 "iso_of_components_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem iso_of_components_app (f : âˆ€ i, Â«expr â‰… Â» (Câ‚.X i) (Câ‚‚.X i))\n    (hf : âˆ€ i j, c.rel i j â†’ Â«expr â‰« Â» (f i).hom (Câ‚‚.d i j) = Â«expr â‰« Â» (Câ‚.d i j) (f j).hom) (i : Î¹) :\n    isoApp (isoOfComponents f hf) i = f i := by\n  ext\n  simp\n#align iso_of_components_app iso_of_components_app\n\n",
 "is_zero_zero":
 "theorem is_zero_zero [HasZeroObject V] : IsZero (zero : HomologicalComplex V c) := by\n  refine' âŸ¨fun X => âŸ¨âŸ¨âŸ¨0âŸ©, fun f => _âŸ©âŸ©, fun X => âŸ¨âŸ¨âŸ¨0âŸ©, fun f => _âŸ©âŸ©âŸ© <;> ext\n#align is_zero_zero is_zero_zero\n\n",
 "is_iso_of_components":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_iso_of_components (f : Â«expr âŸ¶ Â» Câ‚ Câ‚‚) [âˆ€ n : Î¹, IsIso (f.f n)] : IsIso f :=\n  by\n  convert is_iso.of_iso (HomologicalComplex.Hom.isoOfComponents (fun n => as_iso (f.f n)) (by tidy))\n  ext n\n  rfl\n#align is_iso_of_components is_iso_of_components\n\n",
 "image_to_eq_image":
 "theorem image_to_eq_image [HasImages V] [HasEqualizers V] {i j : Î¹} (r : c.rel i j) :\n    imageSubobject (C.d_to j) = imageSubobject (C.d i j) :=\n  by\n  rw [C.d_to_eq r]\n  apply image_subobject_iso_comp\n#align image_to_eq_image image_to_eq_image\n\n",
 "image_eq_image":
 "theorem image_eq_image [HasImages V] [HasEqualizers V] {i i' j : Î¹} (r : c.rel i j) (r' : c.rel i' j) :\n    imageSubobject (C.d i j) = imageSubobject (C.d i' j) :=\n  by\n  rw [â† eq_to_hom_comp_d C r r']\n  apply image_subobject_iso_comp\n#align image_eq_image image_eq_image\n\n",
 "id_f":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem id_f (C : HomologicalComplex V c) (i : Î¹) : hom.f ((Â«exprğŸ™Â») C) i = (Â«exprğŸ™Â») (C.X i) :=\n  rfl\n#align id_f id_f\n\n",
 "hom_f_injective":
 "-- We'll use this later to show that `homological_complex V c` is preadditive when `V` is.\ntheorem hom_f_injective {Câ‚ Câ‚‚ : HomologicalComplex V c} : function.injective fun f : Hom Câ‚ Câ‚‚ => f.f := by tidy\n#align hom_f_injective hom_f_injective\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem ext {Câ‚ Câ‚‚ : HomologicalComplex V c} (h_X : Câ‚.X = Câ‚‚.X)\n    (h_d :\n      âˆ€ i j : Î¹,\n        c.rel i j â†’\n          Â«expr â‰« Â» (Câ‚.d i j) (eqToHom (congr_fun h_X j)) = Â«expr â‰« Â» (eqToHom (congr_fun h_X i)) (Câ‚‚.d i j)) :\n    Câ‚ = Câ‚‚ := by\n  cases Câ‚\n  cases Câ‚‚\n  dsimp at h_X\n  subst h_X\n  simp only [true_and_iff, eq_self_iff_true, heq_iff_eq]\n  ext (i j)\n  by_cases hij : c.rel i j\n  Â· simpa only [id_comp, eq_to_hom_refl, comp_id] using h_d i j hij\n  Â· rw [Câ‚_shape' i j hij, Câ‚‚_shape' i j hij]\n#align ext ext\n\n",
 "eq_to_hom_f":
 "@[simp]\ntheorem eq_to_hom_f {Câ‚ Câ‚‚ : HomologicalComplex V c} (h : Câ‚ = Câ‚‚) (n : Î¹) :\n    homological_complex.hom.f (eqToHom h) n = eqToHom (congr_fun (congr_arg homological_complex.X h) n) :=\n  by\n  subst h\n  rfl\n#align eq_to_hom_f eq_to_hom_f\n\n",
 "eq_to_hom_comp_d":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- If `C.d i j` and `C.d i' j` are both allowed, then we must have `i = i'`,\nand so the differentials only differ by an `eq_to_hom`.\n-/\n@[simp]\ntheorem eq_to_hom_comp_d {i i' j : Î¹} (rij : c.rel i j) (rij' : c.rel i' j) :\n    Â«expr â‰« Â» (eqToHom (congr_arg C.X (c.prev_eq rij rij'))) (C.d i' j) = C.d i j :=\n  by\n  have P : âˆ€ h : i = i', Â«expr â‰« Â» (eq_to_hom (congr_arg C.X h)) (C.d i' j) = C.d i j :=\n    by\n    rintro rfl\n    simp\n  apply P\n#align eq_to_hom_comp_d eq_to_hom_comp_d\n\n",
 "d_to_eq_zero":
 "@[simp]\ntheorem d_to_eq_zero {j : Î¹} (h : Â¬c.rel (c.prev j) j) : C.d_to j = 0 :=\n  C.shape _ _ h\n#align d_to_eq_zero d_to_eq_zero\n\n",
 "d_to_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem d_to_eq {i j : Î¹} (r : c.rel i j) : C.d_to j = Â«expr â‰« Â» (C.X_prev_iso r).hom (C.d i j) :=\n  by\n  obtain rfl := c.prev_eq' r\n  exact (category.id_comp _).symm\n#align d_to_eq d_to_eq\n\n",
 "d_to_comp_d_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem d_to_comp_d_from (j : Î¹) : Â«expr â‰« Â» (C.d_to j) (C.d_from j) = 0 :=\n  C.d_comp_d _ _ _\n#align d_to_comp_d_from d_to_comp_d_from\n\n",
 "d_from_eq_zero":
 "@[simp]\ntheorem d_from_eq_zero {i : Î¹} (h : Â¬c.rel i (c.next i)) : C.d_from i = 0 :=\n  C.shape _ _ h\n#align d_from_eq_zero d_from_eq_zero\n\n",
 "d_from_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem d_from_eq {i j : Î¹} (r : c.rel i j) : C.d_from i = Â«expr â‰« Â» (C.d i j) (C.X_next_iso r).inv :=\n  by\n  obtain rfl := c.next_eq' r\n  exact (category.comp_id _).symm\n#align d_from_eq d_from_eq\n\n",
 "d_from_comp_X_next_iso_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem d_from_comp_X_next_iso_self {i : Î¹} (h : Â¬c.rel i (c.next i)) :\n    Â«expr â‰« Â» (C.d_from i) (C.X_next_iso_self h).hom = 0 := by simp [h]\n#align d_from_comp_X_next_iso_self d_from_comp_X_next_iso_self\n\n",
 "d_from_comp_X_next_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem d_from_comp_X_next_iso {i j : Î¹} (r : c.rel i j) : Â«expr â‰« Â» (C.d_from i) (C.X_next_iso r).hom = C.d i j := by\n  simp [C.d_from_eq r]\n#align d_from_comp_X_next_iso d_from_comp_X_next_iso\n\n",
 "d_comp_eq_to_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- If `C.d i j` and `C.d i j'` are both allowed, then we must have `j = j'`,\nand so the differentials only differ by an `eq_to_hom`.\n-/\n@[simp]\ntheorem d_comp_eq_to_hom {i j j' : Î¹} (rij : c.rel i j) (rij' : c.rel i j') :\n    Â«expr â‰« Â» (C.d i j') (eqToHom (congr_arg C.X (c.next_eq rij' rij))) = C.d i j :=\n  by\n  have P : âˆ€ h : j' = j, Â«expr â‰« Â» (C.d i j') (eq_to_hom (congr_arg C.X h)) = C.d i j :=\n    by\n    rintro rfl\n    simp\n  apply P\n#align d_comp_eq_to_hom d_comp_eq_to_hom\n\n",
 "d_comp_d":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-\nCopyright (c) 2021 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Scott Morrison\n-/\n@[simp, reassoc.1]\ntheorem d_comp_d (C : HomologicalComplex V c) (i j k : Î¹) : Â«expr â‰« Â» (C.d i j) (C.d j k) = 0 :=\n  by\n  by_cases hij : c.rel i j\n  Â· by_cases hjk : c.rel j k\n    Â· exact C.d_comp_d' i j k hij hjk\n    Â· rw [C.shape j k hjk, comp_zero]\n  Â· rw [C.shape i j hij, zero_comp]\n#align d_comp_d d_comp_d\n\n",
 "congr_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem congr_hom {C D : HomologicalComplex V c} {f g : Â«expr âŸ¶ Â» C D} (w : f = g) (i : Î¹) : f.f i = g.f i :=\n  congr_fun (congr_arg hom.f w) i\n#align congr_hom congr_hom\n\n",
 "comp_f":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem comp_f {Câ‚ Câ‚‚ Câ‚ƒ : HomologicalComplex V c} (f : Â«expr âŸ¶ Â» Câ‚ Câ‚‚) (g : Â«expr âŸ¶ Â» Câ‚‚ Câ‚ƒ) (i : Î¹) :\n    (Â«expr â‰« Â» f g).f i = Â«expr â‰« Â» (f.f i) (g.f i) :=\n  rfl\n#align comp_f comp_f\n\n",
 "comm_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1, elementwise]\ntheorem comm_to (f : Hom Câ‚ Câ‚‚) (j : Î¹) : Â«expr â‰« Â» (f.prev j) (Câ‚‚.d_to j) = Â«expr â‰« Â» (Câ‚.d_to j) (f.f j) :=\n  f.comm _ _\n#align comm_to comm_to\n\n",
 "comm_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1, elementwise]\ntheorem comm_from (f : Hom Câ‚ Câ‚‚) (i : Î¹) : Â«expr â‰« Â» (f.f i) (Câ‚‚.d_from i) = Â«expr â‰« Â» (Câ‚.d_from i) (f.next i) :=\n  f.comm _ _\n#align comm_from comm_from\n\n",
 "comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem hom.comm {A B : HomologicalComplex V c} (f : A.hom B) (i j : Î¹) :\n    Â«expr â‰« Â» (f.f i) (B.d i j) = Â«expr â‰« Â» (A.d i j) (f.f j) :=\n  by\n  by_cases hij : c.rel i j\n  Â· exact f.comm' i j hij\n  rw [A.shape i j hij, B.shape i j hij, comp_zero, zero_comp]\n#align hom.comm hom.comm\n\n",
 "X_prev_iso_self_comp_d_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem X_prev_iso_self_comp_d_to {j : Î¹} (h : Â¬c.rel (c.prev j) j) :\n    Â«expr â‰« Â» (C.X_prev_iso_self h).inv (C.d_to j) = 0 := by simp [h]\n#align X_prev_iso_self_comp_d_to X_prev_iso_self_comp_d_to\n\n",
 "X_prev_iso_comp_d_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem X_prev_iso_comp_d_to {i j : Î¹} (r : c.rel i j) : Â«expr â‰« Â» (C.X_prev_iso r).inv (C.d_to j) = C.d i j := by\n  simp [C.d_to_eq r]\n#align X_prev_iso_comp_d_to X_prev_iso_comp_d_to\n\n"}