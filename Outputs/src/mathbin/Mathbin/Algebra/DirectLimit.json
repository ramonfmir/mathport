{"zero_exact_aux2":
 "theorem of.zero_exact_aux2 {x : free_comm_ring (Σi, G i)} {s t} (hxs : is_supported x s) {j k}\n    (hj : ∀ z : Σi, G i, z ∈ s → z.1 ≤ j) (hk : ∀ z : Σi, G i, z ∈ t → z.1 ≤ k) (hjk : j ≤ k) (hst : s ⊆ t) :\n    f' j k hjk (lift (fun ix : s => f' ix.1.1 j (hj ix ix.2) ix.1.2) (restriction s x)) =\n      lift (fun ix : t => f' ix.1.1 k (hk ix ix.2) ix.1.2) (restriction t x) :=\n  by\n  refine' Subring.InClosure.recOn hxs _ _ _ _\n  ·\n    rw [(restriction _).map_one, (free_comm_ring.lift _).map_one, (f' j k hjk).map_one, (restriction _).map_one,\n      (free_comm_ring.lift _).map_one]\n  ·\n    rw [(restriction _).map_neg, (restriction _).map_one, (free_comm_ring.lift _).map_neg,\n      (free_comm_ring.lift _).map_one, (f' j k hjk).map_neg, (f' j k hjk).map_one, (restriction _).map_neg,\n      (restriction _).map_one, (free_comm_ring.lift _).map_neg, (free_comm_ring.lift _).map_one]\n  · rintro _ ⟨p, hps, rfl⟩ n ih\n    rw [(restriction _).map_mul, (free_comm_ring.lift _).map_mul, (f' j k hjk).map_mul, ih, (restriction _).map_mul,\n      (free_comm_ring.lift _).map_mul, restriction_of, dif_pos hps, lift_of, restriction_of, dif_pos (hst hps), lift_of]\n    dsimp only\n    have := directed_system.map_map fun i j h => f' i j h\n    dsimp only at this\n    rw [this]\n    rfl\n  · rintro x y ihx ihy\n    rw [(restriction _).map_add, (free_comm_ring.lift _).map_add, (f' j k hjk).map_add, ihx, ihy,\n      (restriction _).map_add, (free_comm_ring.lift _).map_add]\n#align of.zero_exact_aux2 of.zero_exact_aux2\n\n",
 "zero_exact_aux":
 "theorem of.zero_exact_aux [Nonempty ι] [IsDirected ι (· ≤ ·)] {x : free_comm_ring (Σi, G i)}\n    (H : Ideal.Quotient.mk _ x = (0 : direct_limit G fun i j h => f' i j h)) :\n    ∃ j s,\n      ∃ H : ∀ k : Σi, G i, k ∈ s → k.1 ≤ j,\n        is_supported x s ∧ lift (fun ix : s => f' ix.1.1 j (H ix ix.2) ix.1.2) (restriction s x) = (0 : G j) :=\n  by\n  refine' span_induction (Ideal.Quotient.eq_zero_iff_mem.1 H) _ _ _ _\n  · rintro x (⟨i, j, hij, x, rfl⟩ | ⟨i, rfl⟩ | ⟨i, x, y, rfl⟩ | ⟨i, x, y, rfl⟩)\n    · refine'\n        ⟨j, {⟨i, x⟩, ⟨j, f' i j hij x⟩}, _,\n          is_supported_sub (is_supported_of.2 <| or.inr rfl) (is_supported_of.2 <| or.inl rfl), _⟩\n      · rintro k (rfl | ⟨rfl | _⟩)\n        exact hij\n        rfl\n      · rw [(restriction _).map_sub, (free_comm_ring.lift _).map_sub, restriction_of, dif_pos, restriction_of, dif_pos,\n          lift_of, lift_of]\n        dsimp only\n        have := directed_system.map_map fun i j h => f' i j h\n        dsimp only at this\n        rw [this]\n        exact sub_self _\n        exacts[or.inr rfl, or.inl rfl]\n    · refine' ⟨i, {⟨i, 1⟩}, _, is_supported_sub (is_supported_of.2 rfl) is_supported_one, _⟩\n      · rintro k (rfl | h)\n        rfl\n      · rw [(restriction _).map_sub, (free_comm_ring.lift _).map_sub, restriction_of, dif_pos, (restriction _).map_one,\n          lift_of, (free_comm_ring.lift _).map_one]\n        dsimp only\n        rw [(f' i i _).map_one, sub_self]\n        · exact Set.mem_singleton _\n    · refine'\n        ⟨i, {⟨i, x + y⟩, ⟨i, x⟩, ⟨i, y⟩}, _,\n          is_supported_sub (is_supported_of.2 <| or.inl rfl)\n            (is_supported_add (is_supported_of.2 <| or.inr <| or.inl rfl) (is_supported_of.2 <| or.inr <| or.inr rfl)),\n          _⟩\n      · rintro k (rfl | ⟨rfl | ⟨rfl | hk⟩⟩) <;> rfl\n      · rw [(restriction _).map_sub, (restriction _).map_add, restriction_of, restriction_of, restriction_of, dif_pos,\n          dif_pos, dif_pos, (free_comm_ring.lift _).map_sub, (free_comm_ring.lift _).map_add, lift_of, lift_of, lift_of]\n        dsimp only\n        rw [(f' i i _).map_add]\n        exact sub_self _\n        exacts[or.inl rfl, or.inr (or.inr rfl), or.inr (or.inl rfl)]\n    · refine'\n        ⟨i, {⟨i, x * y⟩, ⟨i, x⟩, ⟨i, y⟩}, _,\n          is_supported_sub (is_supported_of.2 <| or.inl rfl)\n            (is_supported_mul (is_supported_of.2 <| or.inr <| or.inl rfl) (is_supported_of.2 <| or.inr <| or.inr rfl)),\n          _⟩\n      · rintro k (rfl | ⟨rfl | ⟨rfl | hk⟩⟩) <;> rfl\n      · rw [(restriction _).map_sub, (restriction _).map_mul, restriction_of, restriction_of, restriction_of, dif_pos,\n          dif_pos, dif_pos, (free_comm_ring.lift _).map_sub, (free_comm_ring.lift _).map_mul, lift_of, lift_of, lift_of]\n        dsimp only\n        rw [(f' i i _).map_mul]\n        exacts[sub_self _, or.inl rfl, or.inr (or.inr rfl), or.inr (or.inl rfl)]\n  · refine' Nonempty.elim (by infer_instance) fun ind : ι => _\n    refine' ⟨ind, ∅, fun _ => false.elim, is_supported_zero, _⟩\n    rw [(restriction _).map_zero, (free_comm_ring.lift _).map_zero]\n  · rintro x y ⟨i, s, hi, hxs, ihs⟩ ⟨j, t, hj, hyt, iht⟩\n    obtain ⟨k, hik, hjk⟩ := exists_ge_ge i j\n    have : ∀ z : Σi, G i, z ∈ s ∪ t → z.1 ≤ k := by\n      rintro z (hz | hz)\n      exact le_trans (hi z hz) hik\n      exact le_trans (hj z hz) hjk\n    refine'\n      ⟨k, s ∪ t, this,\n        is_supported_add (is_supported_upwards hxs <| Set.subset_union_left s t)\n          (is_supported_upwards hyt <| Set.subset_union_right s t),\n        _⟩\n    ·\n      rw [(restriction _).map_add, (free_comm_ring.lift _).map_add, ←\n        of.zero_exact_aux2 G f' hxs hi this hik (Set.subset_union_left s t), ←\n        of.zero_exact_aux2 G f' hyt hj this hjk (Set.subset_union_right s t), ihs, (f' i k hik).map_zero, iht,\n        (f' j k hjk).map_zero, zero_add]\n  · rintro x y ⟨j, t, hj, hyt, iht⟩\n    rw [smul_eq_mul]\n    rcases exists_finset_support x with ⟨s, hxs⟩\n    rcases(s.image Sigma.fst).exists_le with ⟨i, hi⟩\n    obtain ⟨k, hik, hjk⟩ := exists_ge_ge i j\n    have : ∀ z : Σi, G i, z ∈ ↑s ∪ t → z.1 ≤ k := by\n      rintro z (hz | hz)\n      exacts[(hi z.1 <| Finset.mem_image.2 ⟨z, hz, rfl⟩).trans hik, (hj z hz).trans hjk]\n    refine'\n      ⟨k, ↑s ∪ t, this,\n        is_supported_mul (is_supported_upwards hxs <| Set.subset_union_left (↑s) t)\n          (is_supported_upwards hyt <| Set.subset_union_right (↑s) t),\n        _⟩\n    rw [(restriction _).map_mul, (free_comm_ring.lift _).map_mul, ←\n      of.zero_exact_aux2 G f' hyt hj this hjk (Set.subset_union_right (↑s) t), iht, (f' j k hjk).map_zero,\n      MulZeroClass.mul_zero]\n#align of.zero_exact_aux of.zero_exact_aux\n\n",
 "zero_exact":
 "/-- A component that corresponds to zero in the direct limit is already zero in some\nbigger module in the directed system. -/\ntheorem of.zero_exact [IsDirected ι (· ≤ ·)] {i x} (hix : of G (fun i j h => f' i j h) i x = 0) :\n    ∃ (j : _)(hij : i ≤ j), f' i j hij x = 0 :=\n  haveI : Nonempty ι := ⟨i⟩\n  let ⟨j, s, H, hxs, hx⟩ := of.zero_exact_aux hix\n  have hixs : (⟨i, x⟩ : Σi, G i) ∈ s := is_supported_of.1 hxs\n  ⟨j, H ⟨i, x⟩ hixs, by rw [restriction_of, dif_pos hixs, lift_of] at hx <;> exact hx⟩\n#align of.zero_exact of.zero_exact\n\n",
 "totalize_of_not_le":
 "theorem totalize_of_not_le {i j} (h : ¬i ≤ j) : totalize G f i j = 0 :=\n  dif_neg h\n#align totalize_of_not_le totalize_of_not_le\n\n",
 "totalize_of_le":
 "theorem totalize_of_le {i j} (h : i ≤ j) : totalize G f i j = f i j h :=\n  dif_pos h\n#align totalize_of_le totalize_of_le\n\n",
 "to_module_totalize_of_le":
 "theorem to_module_totalize_of_le {x : DirectSum ι G} {i j : ι} (hij : i ≤ j) (hx : ∀ k ∈ x.support, k ≤ i) :\n    DirectSum.toModule R ι (G j) (fun k => totalize G f k j) x =\n      f i j hij (DirectSum.toModule R ι (G i) (fun k => totalize G f k i) x) :=\n  by\n  rw [← @Dfinsupp.sum_single ι G _ _ _ x]\n  unfold Dfinsupp.sum\n  simp only [LinearMap.map_sum]\n  refine' Finset.sum_congr rfl fun k hk => _\n  rw [DirectSum.single_eq_lof R k (x k), DirectSum.toModule_lof, DirectSum.toModule_lof, totalize_of_le (hx k hk),\n    totalize_of_le (le_trans (hx k hk) hij), directed_system.map_map]\n#align to_module_totalize_of_le to_module_totalize_of_le\n\n",
 "of_injective":
 "/-- If the maps in the directed system are injective, then the canonical maps\nfrom the components to the direct limits are injective. -/\ntheorem of_injective [IsDirected ι (· ≤ ·)] [directed_system G fun i j h => f' i j h]\n    (hf : ∀ i j hij, function.injective (f' i j hij)) (i) : function.injective (of G (fun i j h => f' i j h) i) :=\n  by\n  suffices ∀ x, of G (fun i j h => f' i j h) i x = 0 → x = 0\n    by\n    intro x y hxy\n    rw [← sub_eq_zero]\n    apply this\n    rw [(of G _ i).map_sub, hxy, sub_self]\n  intro x hx\n  rcases of.zero_exact hx with ⟨j, hij, hfx⟩\n  apply hf i j hij\n  rw [hfx, (f' i j hij).map_zero]\n#align of_injective of_injective\n\n",
 "of_f":
 "@[simp]\ntheorem of_f {i j} (hij) (x) : of G f j (f i j hij x) = of G f i x :=\n  Ideal.Quotient.eq.2 <| subset_span <| or.inl ⟨i, j, hij, x, rfl⟩\n#align of_f of_f\n\n",
 "mul_inv_cancel":
 "#print mul_inv_cancel /-\nprotected theorem mul_inv_cancel {p : ring.direct_limit G f} (hp : p ≠ 0) : p * inv G f p = 1 := by\n  rw [inv, dif_neg hp, Classical.choose_spec (direct_limit.exists_inv G f hp)]\n#align mul_inv_cancel mul_inv_cancel\n-/\n\n",
 "map_self":
 "/-\nCopyright (c) 2019 Kenny Lau, Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Chris Hughes\n-/\n/-- A copy of `directed_system.map_self` specialized to linear maps, as otherwise the\n`λ i j h, f i j h` can confuse the simplifier. -/\ntheorem directed_system.map_self [directed_system G fun i j h => f i j h] (i x h) : f i i h x = x :=\n  directed_system.map_self (fun i j h => f i j h) i x h\n#align directed_system.map_self directed_system.map_self\n\n",
 "map_map":
 "/-- A copy of `directed_system.map_map` specialized to linear maps, as otherwise the\n`λ i j h, f i j h` can confuse the simplifier. -/\ntheorem directed_system.map_map [directed_system G fun i j h => f i j h] {i j k} (hij hjk x) :\n    f j k hjk (f i j hij x) = f i k (le_trans hij hjk) x :=\n  directed_system.map_map (fun i j h => f i j h) hij hjk x\n#align directed_system.map_map directed_system.map_map\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem lift_unique [Nonempty ι] [IsDirected ι (· ≤ ·)] (F : «expr →+* » (direct_limit G f) P) (x) :\n    F x = lift G f P (fun i => F.comp <| of G f i) (fun i j hij x => by simp) x :=\n  direct_limit.induction_on x fun i x => by simp\n#align lift_unique lift_unique\n\n",
 "lift_of":
 "@[simp]\ntheorem lift_of (i x) : lift G f P g Hg (of G f i x) = g i x :=\n  free_comm_ring.lift_of _ _\n#align lift_of lift_of\n\n",
 "inv_mul_cancel":
 "#print inv_mul_cancel /-\nprotected theorem inv_mul_cancel {p : ring.direct_limit G f} (hp : p ≠ 0) : inv G f p * p = 1 := by\n  rw [_root_.mul_comm, direct_limit.mul_inv_cancel G f hp]\n#align inv_mul_cancel inv_mul_cancel\n-/\n\n",
 "induction_on":
 "@[elab_as_elim]\ntheorem induction_on [Nonempty ι] [IsDirected ι (· ≤ ·)] {C : direct_limit G f → Prop} (z : direct_limit G f)\n    (ih : ∀ i x, C (of G f i x)) : C z :=\n  let ⟨i, x, hx⟩ := exists_of z\n  hx ▸ ih i x\n#align induction_on induction_on\n\n",
 "exists_of":
 "theorem polynomial.exists_of [Nonempty ι] [IsDirected ι (· ≤ ·)]\n    (q : Polynomial (direct_limit G fun i j h => f' i j h)) :\n    ∃ i p, Polynomial.map (of G (fun i j h => f' i j h) i) p = q :=\n  Polynomial.induction_on q\n    (fun z =>\n      let ⟨i, x, h⟩ := exists_of z\n      ⟨i, C x, by rw [map_C, h]⟩)\n    (fun q₁ q₂ ⟨i₁, p₁, ih₁⟩ ⟨i₂, p₂, ih₂⟩ =>\n      let ⟨i, h1, h2⟩ := exists_ge_ge i₁ i₂\n      ⟨i, p₁.map (f' i₁ i h1) + p₂.map (f' i₂ i h2),\n        by\n        rw [Polynomial.map_add, map_map, map_map, ← ih₁, ← ih₂]\n        congr 2 <;> ext x <;> simp_rw [RingHom.comp_apply, of_f]⟩)\n    fun n z ih =>\n    let ⟨i, x, h⟩ := exists_of z\n    ⟨i, C x * X ^ (n + 1), by rw [Polynomial.map_mul, map_C, h, Polynomial.map_pow, map_X]⟩\n#align polynomial.exists_of polynomial.exists_of\n\n",
 "exists_inv":
 "theorem exists_inv {p : ring.direct_limit G f} : p ≠ 0 → ∃ y, p * y = 1 :=\n  ring.direct_limit.induction_on p fun i x H =>\n    ⟨ring.direct_limit.of G f i x⁻¹, by\n      erw [← (ring.direct_limit.of _ _ _).map_mul,\n        mul_inv_cancel fun h : x = 0 => H <| by rw [h, (ring.direct_limit.of _ _ _).map_zero],\n        (ring.direct_limit.of _ _ _).map_one]⟩\n#align exists_inv exists_inv\n\n",
 "directed_system":
 "protected theorem directed_system [h : directed_system G fun i j h => f i j h] :\n    directed_system G fun i j hij => (f i j hij).to_int_linear_map :=\n  h\n#align directed_system directed_system\n\n"}