{"sol_space_rank":
 "-- note: `strong_rank_condition` is the same as `nontrivial` on `comm_ring`s, but that result,\n-- `comm_ring_strong_rank_condition`, is in a much later file.\n/-- The dimension of `E.sol_space` is `E.order`. -/\ntheorem sol_space_rank : Module.rank α E.sol_space = E.order :=\n  letI := nontrivial_of_invariantBasisNumber α\n  @rank_fin_fun α _ _ E.order ▸ E.to_init.rank_eq\n#align sol_space_rank sol_space_rank\n\n",
 "sol_eq_of_eq_init":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/-- Two solutions are equal iff they are equal on `range E.order`. -/\ntheorem sol_eq_of_eq_init (u v : ℕ → α) (hu : E.is_solution u) (hv : E.is_solution v) :\n    u = v ↔ Set.EqOn u v ↑(range E.order) :=\n  by\n  refine' iff.intro (fun h x hx => h ▸ rfl) _\n  intro h\n  set u' : «expr↥ » E.sol_space := ⟨u, hu⟩\n  set v' : «expr↥ » E.sol_space := ⟨v, hv⟩\n  change u'.val = v'.val\n  suffices h' : u' = v'; exact h' ▸ rfl\n  rw [← E.to_init.to_equiv.apply_eq_iff_eq, LinearEquiv.coe_toEquiv]\n  ext x\n  exact_mod_cast h (mem_range.mpr x.2)\n#align sol_eq_of_eq_init sol_eq_of_eq_init\n\n",
 "mk_sol_eq_init":
 "/-- `E.mk_sol init`'s first `E.order` terms are `init`. -/\ntheorem mk_sol_eq_init (init : Fin E.order → α) : ∀ n : Fin E.order, E.mk_sol init n = init n := fun n =>\n  by\n  rw [mk_sol]\n  simp only [n.is_lt, dif_pos, Fin.mk_val, Fin.eta]\n#align mk_sol_eq_init mk_sol_eq_init\n\n",
 "is_sol_mk_sol":
 "/-\nCopyright (c) 2020 Anatole Dedecker. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anatole Dedecker\n-/\n/-- `E.mk_sol` indeed gives solutions to `E`. -/\ntheorem is_sol_mk_sol (init : Fin E.order → α) : E.is_solution (E.mk_sol init) := fun n => by rw [mk_sol] <;> simp\n#align is_sol_mk_sol is_sol_mk_sol\n\n",
 "is_sol_iff_mem_sol_space":
 "/-- Defining property of the solution space : `u` is a solution\n  iff it belongs to the solution space. -/\ntheorem is_sol_iff_mem_sol_space (u : ℕ → α) : E.is_solution u ↔ u ∈ E.sol_space :=\n  iff.rfl\n#align is_sol_iff_mem_sol_space is_sol_iff_mem_sol_space\n\n",
 "geom_sol_iff_root_char_poly":
 "/-- The geometric sequence `q^n` is a solution of `E` iff\n  `q` is a root of `E`'s characteristic polynomial. -/\ntheorem geom_sol_iff_root_char_poly (q : α) : (E.is_solution fun n => q ^ n) ↔ E.char_poly.is_root q :=\n  by\n  rw [char_poly, Polynomial.IsRoot.def, Polynomial.eval]\n  simp only [Polynomial.eval₂_finset_sum, one_mul, RingHom.id_apply, Polynomial.eval₂_monomial, Polynomial.eval₂_sub]\n  constructor\n  · intro h\n    simpa [sub_eq_zero] using h 0\n  · intro h n\n    simp only [pow_add, sub_eq_zero.mp h, mul_sum]\n    exact sum_congr rfl fun _ _ => by ring\n#align geom_sol_iff_root_char_poly geom_sol_iff_root_char_poly\n\n",
 "eq_mk_of_is_sol_of_eq_init'":
 "/-- If `u` is a solution to `E` and `init` designates its first `E.order` values,\n  then `u = E.mk_sol init`. This proves that `E.mk_sol init` is the only solution\n  of `E` whose first `E.order` values are given by `init`. -/\ntheorem eq_mk_of_is_sol_of_eq_init' {u : ℕ → α} {init : Fin E.order → α} (h : E.is_solution u)\n    (heq : ∀ n : Fin E.order, u n = init n) : u = E.mk_sol init :=\n  funext (E.eq_mk_of_is_sol_of_eq_init h HEq)\n#align eq_mk_of_is_sol_of_eq_init' eq_mk_of_is_sol_of_eq_init'\n\n",
 "eq_mk_of_is_sol_of_eq_init":
 "/-- If `u` is a solution to `E` and `init` designates its first `E.order` values,\n  then `∀ n, u n = E.mk_sol init n`. -/\ntheorem eq_mk_of_is_sol_of_eq_init {u : ℕ → α} {init : Fin E.order → α} (h : E.is_solution u)\n    (heq : ∀ n : Fin E.order, u n = init n) : ∀ n, u n = E.mk_sol init n\n  | n =>\n    if h' : n < E.order then by rw [mk_sol] <;> simp only [h', dif_pos] <;> exact_mod_cast HEq ⟨n, h'⟩\n    else by\n      rw [mk_sol, ← tsub_add_cancel_of_le (le_of_not_lt h'), h (n - E.order)]\n      simp [h']\n      congr with k\n      exact\n        by\n        have wf : n - E.order + k < n :=\n          by\n          rw [add_comm, ← add_tsub_assoc_of_le (not_lt.mp h'), tsub_lt_iff_left]\n          · exact add_lt_add_right k.is_lt n\n          · convert add_le_add (zero_le (k : ℕ)) (not_lt.mp h')\n            simp only [zero_add]\n        rw [eq_mk_of_is_sol_of_eq_init]\n#align eq_mk_of_is_sol_of_eq_init eq_mk_of_is_sol_of_eq_init\n\n"}