{"prod_X_sub_C_next_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem prod_X_sub_C_next_coeff {s : Finset ι} (f : ι → R) :\n    nextCoeff\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (X - C (f i))) =\n      -finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i) :=\n  by simpa using multiset_prod_X_sub_C_next_coeff (s.1.map f)\n#align prod_X_sub_C_next_coeff prod_X_sub_C_next_coeff\n\n",
 "prod_X_sub_C_coeff_card_pred":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem prod_X_sub_C_coeff_card_pred (s : Finset ι) (f : ι → R) (hs : 0 < s.card) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n            (X - C (f i))).coeff\n        (s.card - 1) =\n      -finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i) :=\n  by simpa using multiset_prod_X_sub_C_coeff_card_pred (s.1.map f) (by simpa using hs)\n#align prod_X_sub_C_coeff_card_pred prod_X_sub_C_coeff_card_pred\n\n",
 "nat_degree_sum_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem nat_degree_sum_le (f : ι → polynomial S) :\n    natDegree\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i)) ≤\n      s.fold max 0 (natDegree ∘ f) :=\n  by simpa using nat_degree_multiset_sum_le (s.val.map f)\n#align nat_degree_sum_le nat_degree_sum_le\n\n",
 "nat_degree_prod_of_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem nat_degree_prod_of_monic (h : ∀ i ∈ s, (f i).monic) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (f i)).nat_degree =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (f i).nat_degree :=\n  by simpa using nat_degree_multiset_prod_of_monic (s.1.map f) (by simpa using h)\n#align nat_degree_prod_of_monic nat_degree_prod_of_monic\n\n",
 "nat_degree_prod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem nat_degree_prod_le :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (f i)).nat_degree ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (f i).nat_degree :=\n  by simpa using nat_degree_multiset_prod_le (s.1.map f)\n#align nat_degree_prod_le nat_degree_prod_le\n\n",
 "nat_degree_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The degree of a product of polynomials is equal to\nthe sum of the degrees, provided that the product of leading coefficients is nonzero.\n\nSee `polynomial.nat_degree_prod` (without the `'`) for a version for integral domains,\nwhere this condition is automatically satisfied.\n-/\ntheorem nat_degree_prod'\n    (h :\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (f i).leading_coeff ≠\n        0) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (f i)).nat_degree =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (f i).nat_degree :=\n  by simpa using nat_degree_multiset_prod' (s.1.map f) (by simpa using h)\n#align nat_degree_prod' nat_degree_prod'\n\n",
 "nat_degree_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The degree of a product of polynomials is equal to\nthe sum of the degrees.\n\nSee `polynomial.nat_degree_prod'` (with a `'`) for a version for commutative semirings,\nwhere additionally, the product of the leading coefficients must be nonzero.\n-/\ntheorem nat_degree_prod (h : ∀ i ∈ s, f i ≠ 0) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (f i)).nat_degree =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (f i).nat_degree :=\n  by\n  nontriviality R\n  apply nat_degree_prod'\n  rw [prod_ne_zero_iff]\n  intro x hx; simp [h x hx]\n#align nat_degree_prod nat_degree_prod\n\n",
 "nat_degree_multiset_sum_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_multiset_sum_le (l : Multiset (polynomial S)) :\n    natDegree l.sum ≤ (l.map natDegree).foldr max max_left_comm 0 :=\n  Quotient.inductionOn l (by simpa using nat_degree_list_sum_le)\n#align nat_degree_multiset_sum_le nat_degree_multiset_sum_le\n\n",
 "nat_degree_multiset_prod_of_monic":
 "theorem nat_degree_multiset_prod_of_monic (h : ∀ f ∈ t, Monic f) : t.prod.nat_degree = (t.map natDegree).sum :=\n  by\n  nontriviality R\n  apply nat_degree_multiset_prod'\n  suffices (t.map fun f => leading_coeff f).prod = 1 by\n    rw [this]\n    simp\n  convert prod_replicate t.card (1 : R)\n  · simp only [eq_replicate, Multiset.card_map, eq_self_iff_true, true_and_iff]\n    rintro i hi\n    obtain ⟨i, hi, rfl⟩ := multiset.mem_map.mp hi\n    apply h\n    assumption\n  · simp\n#align nat_degree_multiset_prod_of_monic nat_degree_multiset_prod_of_monic\n\n",
 "nat_degree_multiset_prod_le":
 "theorem nat_degree_multiset_prod_le : t.prod.nat_degree ≤ (t.map natDegree).sum :=\n  Quotient.inductionOn t (by simpa using nat_degree_list_prod_le)\n#align nat_degree_multiset_prod_le nat_degree_multiset_prod_le\n\n",
 "nat_degree_multiset_prod'":
 "/-- The degree of a product of polynomials is equal to\nthe sum of the degrees, provided that the product of leading coefficients is nonzero.\n\nSee `polynomial.nat_degree_multiset_prod` (without the `'`) for a version for integral domains,\nwhere this condition is automatically satisfied.\n-/\ntheorem nat_degree_multiset_prod' (h : (t.map fun f => leadingCoeff f).prod ≠ 0) :\n    t.prod.nat_degree = (t.map fun f => natDegree f).sum :=\n  by\n  revert h\n  refine' Multiset.induction_on t _ fun a t ih ht => _; · simp\n  rw [Multiset.map_cons, Multiset.prod_cons] at ht⊢\n  rw [Multiset.sum_cons, Polynomial.natDegree_mul', ih]\n  · apply right_ne_zero_of_mul ht\n  · rwa [Polynomial.leadingCoeff_multiset_prod']\n    apply right_ne_zero_of_mul ht\n#align nat_degree_multiset_prod' nat_degree_multiset_prod'\n\n",
 "nat_degree_multiset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_multiset_prod (h : (0 : polynomial R) ∉ t) : natDegree t.prod = (t.map natDegree).sum :=\n  by\n  nontriviality R\n  rw [nat_degree_multiset_prod']\n  simp_rw [ne.def, Multiset.prod_eq_zero_iff, Multiset.mem_map, leading_coeff_eq_zero]\n  rintro ⟨_, h, rfl⟩\n  contradiction\n#align nat_degree_multiset_prod nat_degree_multiset_prod\n\n",
 "nat_degree_list_sum_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson, Jalex Stark\n-/\ntheorem nat_degree_list_sum_le (l : List (polynomial S)) : natDegree l.sum ≤ (l.map natDegree).foldr max 0 :=\n  List.sum_le_foldr_max natDegree (by simp) natDegree_add_le _\n#align nat_degree_list_sum_le nat_degree_list_sum_le\n\n",
 "nat_degree_list_prod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_list_prod_le (l : List (polynomial S)) : natDegree l.prod ≤ (l.map natDegree).sum :=\n  by\n  induction' l with hd tl IH\n  · simp\n  · simpa using nat_degree_mul_le.trans (add_le_add_left IH _)\n#align nat_degree_list_prod_le nat_degree_list_prod_le\n\n",
 "multiset_prod_X_sub_C_next_coeff":
 "-- Eventually this can be generalized with Vieta's formulas\n-- plus the connection between roots and factorization.\ntheorem multiset_prod_X_sub_C_next_coeff (t : Multiset R) : nextCoeff (t.map fun x => X - C x).prod = -t.sum :=\n  by\n  rw [next_coeff_multiset_prod]\n  · simp only [next_coeff_X_sub_C]\n    exact t.sum_hom (-AddMonoidHom.id R)\n  · intros\n    apply monic_X_sub_C\n#align multiset_prod_X_sub_C_next_coeff multiset_prod_X_sub_C_next_coeff\n\n",
 "multiset_prod_X_sub_C_coeff_card_pred":
 "theorem multiset_prod_X_sub_C_coeff_card_pred (t : Multiset R) (ht : 0 < t.card) :\n    (t.map fun x => X - C x).prod.coeff (t.card - 1) = -t.sum :=\n  by\n  nontriviality R\n  convert multiset_prod_X_sub_C_next_coeff (by assumption)\n  rw [next_coeff]; split_ifs\n  · rw [nat_degree_multiset_prod_of_monic] at h <;> simp only [Multiset.mem_map] at *\n    swap\n    · rintro _ ⟨_, _, rfl⟩\n      apply monic_X_sub_C\n    simp_rw [Multiset.sum_eq_zero_iff, Multiset.mem_map] at h\n    contrapose! h\n    obtain ⟨x, hx⟩ := card_pos_iff_exists_mem.mp ht\n    exact ⟨_, ⟨_, ⟨x, hx, rfl⟩, nat_degree_X_sub_C _⟩, one_ne_zero⟩\n  congr ; rw [nat_degree_multiset_prod_of_monic] <;> · simp [nat_degree_X_sub_C, monic_X_sub_C]\n#align multiset_prod_X_sub_C_coeff_card_pred multiset_prod_X_sub_C_coeff_card_pred\n\n",
 "leading_coeff_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- The leading coefficient of a product of polynomials is equal to\nthe product of the leading coefficients, provided that this product is nonzero.\n\nSee `polynomial.leading_coeff_prod` (without the `'`) for a version for integral domains,\nwhere this condition is automatically satisfied.\n-/\ntheorem leading_coeff_prod'\n    (h :\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (f i).leading_coeff ≠\n        0) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (f i)).leading_coeff =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (f i).leading_coeff :=\n  by simpa using leading_coeff_multiset_prod' (s.1.map f) (by simpa using h)\n#align leading_coeff_prod' leading_coeff_prod'\n\n",
 "leading_coeff_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- The leading coefficient of a product of polynomials is equal to\nthe product of the leading coefficients.\n\nSee `polynomial.leading_coeff_prod'` (with a `'`) for a version for commutative semirings,\nwhere additionally, the product of the leading coefficients must be nonzero.\n-/\ntheorem leading_coeff_prod :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (f i)).leading_coeff =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (f i).leading_coeff :=\n  by simpa using leading_coeff_multiset_prod (s.1.map f)\n#align leading_coeff_prod leading_coeff_prod\n\n",
 "leading_coeff_multiset_prod'":
 "/-- The leading coefficient of a product of polynomials is equal to\nthe product of the leading coefficients, provided that this product is nonzero.\n\nSee `polynomial.leading_coeff_multiset_prod` (without the `'`) for a version for integral domains,\nwhere this condition is automatically satisfied.\n-/\ntheorem leading_coeff_multiset_prod' (h : (t.map leadingCoeff).prod ≠ 0) :\n    t.prod.leading_coeff = (t.map leadingCoeff).prod :=\n  by\n  induction' t using Multiset.induction_on with a t ih; · simp\n  simp only [Multiset.map_cons, Multiset.prod_cons] at h⊢\n  rw [Polynomial.leadingCoeff_mul'] <;>\n    · rwa [ih]\n      apply right_ne_zero_of_mul h\n#align leading_coeff_multiset_prod' leading_coeff_multiset_prod'\n\n",
 "leading_coeff_multiset_prod":
 "/-- The leading coefficient of a product of polynomials is equal to\nthe product of the leading coefficients.\n\nSee `polynomial.leading_coeff_multiset_prod'` (with a `'`) for a version for commutative semirings,\nwhere additionally, the product of the leading coefficients must be nonzero.\n-/\ntheorem leading_coeff_multiset_prod : t.prod.leading_coeff = (t.map fun f => leadingCoeff f).prod :=\n  by\n  rw [← leading_coeff_hom_apply, MonoidHom.map_multiset_prod]\n  rfl\n#align leading_coeff_multiset_prod leading_coeff_multiset_prod\n\n",
 "degree_prod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem degree_prod_le :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)).degree ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i).degree :=\n  by simpa only [Multiset.map_map] using degree_multiset_prod_le (s.1.map f)\n#align degree_prod_le degree_prod_le\n\n",
 "degree_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The degree of a product of polynomials is equal to\nthe sum of the degrees, where the degree of the zero polynomial is ⊥.\n-/\ntheorem degree_prod [Nontrivial R] :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)).degree =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i).degree :=\n  map_prod (@degreeMonoidHom R _ _ _) _ _\n#align degree_prod degree_prod\n\n",
 "degree_multiset_prod_le":
 "/-- The degree of a product of polynomials is at most the sum of the degrees,\nwhere the degree of the zero polynomial is ⊥.\n-/\ntheorem degree_multiset_prod_le : t.prod.degree ≤ (t.map Polynomial.degree).sum :=\n  Quotient.inductionOn t (by simpa using degree_list_prod_le)\n#align degree_multiset_prod_le degree_multiset_prod_le\n\n",
 "degree_multiset_prod":
 "/-- The degree of a product of polynomials is equal to\nthe sum of the degrees, where the degree of the zero polynomial is ⊥.\n-/\ntheorem degree_multiset_prod [Nontrivial R] : t.prod.degree = (t.map fun f => degree f).sum :=\n  map_multiset_prod (@degreeMonoidHom R _ _ _) _\n#align degree_multiset_prod degree_multiset_prod\n\n",
 "degree_list_sum_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_list_sum_le (l : List (polynomial S)) : degree l.sum ≤ (l.map natDegree).maximum :=\n  by\n  by_cases h : l.sum = 0\n  · simp [h]\n  · rw [degree_eq_nat_degree h]\n    suffices (l.map nat_degree).maximum = ((l.map nat_degree).foldr max 0 : ℕ)\n      by\n      rw [this]\n      simpa [this] using nat_degree_list_sum_le l\n    rw [← List.foldr_max_of_ne_nil]\n    · congr\n    contrapose! h\n    rw [List.map_eq_nil] at h\n    simp [h]\n#align degree_list_sum_le degree_list_sum_le\n\n",
 "degree_list_prod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_list_prod_le (l : List (polynomial S)) : degree l.prod ≤ (l.map degree).sum :=\n  by\n  induction' l with hd tl IH\n  · simp\n  · simpa using (degree_mul_le _ _).trans (add_le_add_left IH _)\n#align degree_list_prod_le degree_list_prod_le\n\n",
 "degree_list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- The degree of a product of polynomials is equal to\nthe sum of the degrees, where the degree of the zero polynomial is ⊥.\n`[nontrivial R]` is needed, otherwise for `l = []` we have `⊥` in the LHS and `0` in the RHS.\n-/\ntheorem degree_list_prod [Nontrivial R] (l : List (polynomial R)) : l.prod.degree = (l.map degree).sum :=\n  map_list_prod (@degreeMonoidHom R _ _ _) l\n#align degree_list_prod degree_list_prod\n\n",
 "coeff_zero_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem coeff_zero_prod :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)).coeff\n        0 =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        ((f i).coeff 0) :=\n  by simpa using coeff_zero_multiset_prod (s.1.map f)\n#align coeff_zero_prod coeff_zero_prod\n\n",
 "coeff_zero_multiset_prod":
 "theorem coeff_zero_multiset_prod : t.prod.coeff 0 = (t.map fun f => coeff f 0).prod :=\n  by\n  refine' Multiset.induction_on t _ fun a t ht => _; · simp\n  rw [Multiset.prod_cons, Multiset.map_cons, Multiset.prod_cons, Polynomial.mul_coeff_zero, ht]\n#align coeff_zero_multiset_prod coeff_zero_multiset_prod\n\n",
 "coeff_prod_of_nat_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem coeff_prod_of_nat_degree_le (f : ι → polynomial R) (n : ℕ) (h : ∀ p ∈ s, natDegree (f p) ≤ n) :\n    coeff (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i))\n        (s.card * n) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (coeff (f i) n) :=\n  by\n  cases' s with l hl\n  convert coeff_multiset_prod_of_nat_degree_le (l.map f) _ _\n  · simp\n  · simp\n  · simpa using h\n#align coeff_prod_of_nat_degree_le coeff_prod_of_nat_degree_le\n\n",
 "coeff_multiset_prod_of_nat_degree_le":
 "theorem coeff_multiset_prod_of_nat_degree_le (n : ℕ) (hl : ∀ p ∈ t, natDegree p ≤ n) :\n    coeff t.prod (t.card * n) = (t.map fun p => coeff p n).prod :=\n  by\n  induction t using Quotient.inductionOn\n  simpa using coeff_list_prod_of_nat_degree_le _ _ hl\n#align coeff_multiset_prod_of_nat_degree_le coeff_multiset_prod_of_nat_degree_le\n\n",
 "coeff_list_prod_of_nat_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem coeff_list_prod_of_nat_degree_le (l : List (polynomial S)) (n : ℕ) (hl : ∀ p ∈ l, natDegree p ≤ n) :\n    coeff (List.prod l) (l.length * n) = (l.map fun p => coeff p n).prod :=\n  by\n  induction' l with hd tl IH\n  · simp\n  · have hl' : ∀ p ∈ tl, nat_degree p ≤ n := fun p hp => hl p (list.mem_cons_of_mem _ hp)\n    simp only [List.prod_cons, list.map, list.length]\n    rw [add_mul, one_mul, add_comm, ← IH hl', mul_comm tl.length]\n    have h : nat_degree tl.prod ≤ n * tl.length :=\n      by\n      refine' (nat_degree_list_prod_le _).trans _\n      rw [← tl.length_map nat_degree, mul_comm]\n      refine' List.sum_le_card_nsmul _ _ _\n      simpa using hl'\n    have hdn : nat_degree hd ≤ n := hl _ (list.mem_cons_self _ _)\n    rcases hdn.eq_or_lt with (rfl | hdn')\n    · cases' h.eq_or_lt with h' h'\n      · rw [← h', coeff_mul_degree_add_degree, leading_coeff, leading_coeff]\n      · rw [coeff_eq_zero_of_nat_degree_lt, coeff_eq_zero_of_nat_degree_lt h', MulZeroClass.mul_zero]\n        exact nat_degree_mul_le.trans_lt (add_lt_add_left h' _)\n    · rw [coeff_eq_zero_of_nat_degree_lt hdn', coeff_eq_zero_of_nat_degree_lt, MulZeroClass.zero_mul]\n      exact nat_degree_mul_le.trans_lt (add_lt_add_of_lt_of_le hdn' h)\n#align coeff_list_prod_of_nat_degree_le coeff_list_prod_of_nat_degree_le\n\n"}