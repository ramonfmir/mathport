{"squarefree_one":
 "#print squarefree_one /-\n@[simp]\ntheorem squarefree_one [CommMonoid R] : Squarefree (1 : R) :=\n  isUnit_one.squarefree\n#align squarefree_one squarefree_one\n-/\n\n",
 "squarefree_of_dvd":
 "#print Squarefree.squarefree_of_dvd /-\ntheorem Squarefree.squarefree_of_dvd [CommMonoid R] {x y : R} (hdvd : x ∣ y) (hsq : Squarefree y) : Squarefree x :=\n  fun a h => hsq _ (h.trans hdvd)\n#align squarefree.squarefree_of_dvd Squarefree.squarefree_of_dvd\n-/\n\n",
 "squarefree_nat_abs":
 "@[simp]\ntheorem squarefree_nat_abs {n : ℤ} : Squarefree n.nat_abs ↔ Squarefree n := by\n  simp_rw [Squarefree, nat_abs_surjective.forall, ← nat_abs_mul, nat_abs_dvd_iff_dvd, is_unit_iff_nat_abs_eq,\n    Nat.isUnit_iff]\n#align squarefree_nat_abs squarefree_nat_abs\n\n",
 "squarefree_iff_nodup_normalized_factors":
 "theorem squarefree_iff_nodup_normalized_factors [NormalizationMonoid R] [DecidableEq R] {x : R} (x0 : x ≠ 0) :\n    Squarefree x ↔ Multiset.Nodup (normalizedFactors x) :=\n  by\n  have drel : DecidableRel (has_dvd.dvd : R → R → Prop) := by classical infer_instance\n  haveI := drel\n  rw [multiplicity.squarefree_iff_multiplicity_le_one, Multiset.nodup_iff_count_le_one]\n  haveI := nontrivial_of_ne x 0 x0\n  constructor <;> intro h a\n  · by_cases hmem : a ∈ normalized_factors x\n    · have ha := irreducible_of_normalized_factor _ hmem\n      rcases h a with (h | h)\n      · rw [← normalize_normalized_factor _ hmem]\n        rw [multiplicity_eq_count_normalized_factors ha x0] at h\n        assumption_mod_cast\n      · have := ha.1\n        contradiction\n    · simp [Multiset.count_eq_zero_of_not_mem hmem]\n  · rw [or_iff_not_imp_right]\n    intro hu\n    by_cases h0 : a = 0\n    · simp [h0, x0]\n    rcases WfDvdMonoid.exists_irreducible_factor hu h0 with ⟨b, hib, hdvd⟩\n    apply le_trans (multiplicity.multiplicity_le_multiplicity_of_dvd_left hdvd)\n    rw [multiplicity_eq_count_normalized_factors hib x0]\n    specialize h (normalize b)\n    assumption_mod_cast\n#align squarefree_iff_nodup_normalized_factors squarefree_iff_nodup_normalized_factors\n\n",
 "squarefree_iff_multiplicity_le_one":
 "theorem squarefree_iff_multiplicity_le_one (r : R) : Squarefree r ↔ ∀ x : R, multiplicity x r ≤ 1 ∨ IsUnit x :=\n  by\n  refine' forall_congr' fun a => _\n  rw [← sq, pow_dvd_iff_le_multiplicity, or_iff_not_imp_left, not_le, imp_congr _ iff.rfl]\n  simpa using PartENat.add_one_le_iff_lt (PartENat.natCast_ne_top 1)\n#align squarefree_iff_multiplicity_le_one squarefree_iff_multiplicity_le_one\n\n",
 "squarefree_iff_irreducible_sq_not_dvd_of_ne_zero":
 "#print squarefree_iff_irreducible_sq_not_dvd_of_ne_zero /-\ntheorem squarefree_iff_irreducible_sq_not_dvd_of_ne_zero {r : R} (hr : r ≠ 0) :\n    Squarefree r ↔ ∀ x : R, Irreducible x → ¬x * x ∣ r := by\n  simpa [hr] using (irreducible_sq_not_dvd_iff_eq_zero_and_no_irreducibles_or_squarefree r).symm\n#align squarefree_iff_irreducible_sq_not_dvd_of_ne_zero squarefree_iff_irreducible_sq_not_dvd_of_ne_zero\n-/\n\n",
 "squarefree_iff_irreducible_sq_not_dvd_of_exists_irreducible":
 "#print squarefree_iff_irreducible_sq_not_dvd_of_exists_irreducible /-\ntheorem squarefree_iff_irreducible_sq_not_dvd_of_exists_irreducible {r : R} (hr : ∃ x : R, Irreducible x) :\n    Squarefree r ↔ ∀ x : R, Irreducible x → ¬x * x ∣ r :=\n  by\n  rw [irreducible_sq_not_dvd_iff_eq_zero_and_no_irreducibles_or_squarefree, ← not_exists]\n  simp only [hr, not_true, false_or_iff, and_false_iff]\n#align squarefree_iff_irreducible_sq_not_dvd_of_exists_irreducible squarefree_iff_irreducible_sq_not_dvd_of_exists_irreducible\n-/\n\n",
 "squarefree_coe_nat":
 "@[simp]\ntheorem squarefree_coe_nat {n : ℕ} : Squarefree (n : ℤ) ↔ Squarefree n := by rw [← squarefree_nat_abs, nat_abs_of_nat]\n#align squarefree_coe_nat squarefree_coe_nat\n\n",
 "squarefree":
 "#print IsRadical.squarefree /-\ntheorem IsRadical.squarefree {x : R} (h0 : x ≠ 0) (h : IsRadical x) : Squarefree x :=\n  by\n  rintro z ⟨w, rfl⟩\n  specialize h 2 (z * w) ⟨w, by simp_rw [pow_two, mul_left_comm, ← mul_assoc]⟩\n  rwa [← one_mul (z * w), mul_assoc, mul_dvd_mul_iff_right, ← isUnit_iff_dvd_one] at h\n  rw [mul_assoc, mul_ne_zero_iff] at h0; exact h0.2\n#align is_radical.squarefree IsRadical.squarefree\n-/\n\n",
 "of_mul_right":
 "#print Squarefree.of_mul_right /-\ntheorem Squarefree.of_mul_right [CommMonoid R] {m n : R} (hmn : Squarefree (m * n)) : Squarefree n := fun p hp =>\n  hmn p (dvd_mul_of_dvd_right hp m)\n#align squarefree.of_mul_right Squarefree.of_mul_right\n-/\n\n",
 "of_mul_left":
 "#print Squarefree.of_mul_left /-\ntheorem Squarefree.of_mul_left [CommMonoid R] {m n : R} (hmn : Squarefree (m * n)) : Squarefree m := fun p hp =>\n  hmn p (dvd_mul_of_dvd_left hp n)\n#align squarefree.of_mul_left Squarefree.of_mul_left\n-/\n\n",
 "not_squarefree_zero":
 "#print not_squarefree_zero /-\n@[simp]\ntheorem not_squarefree_zero [MonoidWithZero R] [Nontrivial R] : ¬Squarefree (0 : R) :=\n  by\n  erw [not_forall]\n  exact ⟨0, by simp⟩\n#align not_squarefree_zero not_squarefree_zero\n-/\n\n",
 "ne_zero":
 "#print Squarefree.ne_zero /-\ntheorem Squarefree.ne_zero [MonoidWithZero R] [Nontrivial R] {m : R} (hm : Squarefree (m : R)) : m ≠ 0 :=\n  by\n  rintro rfl\n  exact not_squarefree_zero hm\n#align squarefree.ne_zero Squarefree.ne_zero\n-/\n\n",
 "isRadical_iff_squarefree_or_zero":
 "#print isRadical_iff_squarefree_or_zero /-\ntheorem isRadical_iff_squarefree_or_zero {x : R} : IsRadical x ↔ Squarefree x ∨ x = 0 :=\n  ⟨fun hx => (em <| x = 0).elim or.inr fun h => or.inl <| hx.squarefree h,\n    or.rec Squarefree.isRadical <| by\n      rintro rfl\n      rw [zero_isRadical_iff]\n      infer_instance⟩\n#align is_radical_iff_squarefree_or_zero isRadical_iff_squarefree_or_zero\n-/\n\n",
 "isRadical_iff_squarefree_of_ne_zero":
 "#print isRadical_iff_squarefree_of_ne_zero /-\ntheorem isRadical_iff_squarefree_of_ne_zero {x : R} (h : x ≠ 0) : IsRadical x ↔ Squarefree x :=\n  ⟨IsRadical.squarefree h, Squarefree.isRadical⟩\n#align is_radical_iff_squarefree_of_ne_zero isRadical_iff_squarefree_of_ne_zero\n-/\n\n",
 "isRadical":
 "#print Squarefree.isRadical /-\ntheorem Squarefree.isRadical {x : R} (hx : Squarefree x) : IsRadical x :=\n  (isRadical_iff_pow_one_lt 2 one_lt_two).2 fun y hy =>\n    And.right <|\n      (dvd_gcd_iff x x y).1\n        (by\n          by_cases gcd x y = 0;\n          · rw [h]\n            apply dvd_zero\n          replace hy := ((dvd_gcd_iff x x _).2 ⟨dvd_rfl, hy⟩).trans gcd_pow_right_dvd_pow_gcd\n          obtain ⟨z, hz⟩ := gcd_dvd_left x y\n          nth_rw 1 [hz] at hy⊢\n          rw [pow_two, mul_dvd_mul_iff_left h] at hy\n          obtain ⟨w, hw⟩ := hy\n          exact (hx z ⟨w, by rwa [mul_right_comm, ← hw]⟩).mul_right_dvd.2 dvd_rfl)\n#align squarefree.is_radical Squarefree.isRadical\n-/\n\n",
 "irreducible_sq_not_dvd_iff_eq_zero_and_no_irreducibles_or_squarefree":
 "#print irreducible_sq_not_dvd_iff_eq_zero_and_no_irreducibles_or_squarefree /-\ntheorem irreducible_sq_not_dvd_iff_eq_zero_and_no_irreducibles_or_squarefree (r : R) :\n    (∀ x : R, Irreducible x → ¬x * x ∣ r) ↔ (r = 0 ∧ ∀ x : R, ¬Irreducible x) ∨ Squarefree r :=\n  by\n  symm\n  constructor\n  · rintro (⟨rfl, h⟩ | h)\n    · simpa using h\n    intro x hx t\n    exact hx.not_unit (h x t)\n  intro h\n  rcases eq_or_ne r 0 with (rfl | hr)\n  · exact or.inl (by simpa using h)\n  right\n  intro x hx\n  by_contra i\n  have : x ≠ 0 := by\n    rintro rfl\n    apply hr\n    simpa only [zero_dvd_iff, MulZeroClass.mul_zero] using hx\n  obtain ⟨j, hj₁, hj₂⟩ := WfDvdMonoid.exists_irreducible_factor i this\n  exact h _ hj₁ ((mul_dvd_mul hj₂ hj₂).trans hx)\n#align irreducible_sq_not_dvd_iff_eq_zero_and_no_irreducibles_or_squarefree irreducible_sq_not_dvd_iff_eq_zero_and_no_irreducibles_or_squarefree\n-/\n\n",
 "gcd_right":
 "#print Squarefree.gcd_right /-\ntheorem Squarefree.gcd_right (a : α) {b : α} (hb : Squarefree b) : Squarefree (gcd a b) :=\n  hb.squarefree_of_dvd (gcd_dvd_right _ _)\n#align squarefree.gcd_right Squarefree.gcd_right\n-/\n\n",
 "gcd_left":
 "#print Squarefree.gcd_left /-\ntheorem Squarefree.gcd_left {a : α} (b : α) (ha : Squarefree a) : Squarefree (gcd a b) :=\n  ha.squarefree_of_dvd (gcd_dvd_left _ _)\n#align squarefree.gcd_left Squarefree.gcd_left\n-/\n\n",
 "finite_prime_left":
 "theorem finite_prime_left {a b : R} (ha : Prime a) (hb : b ≠ 0) : multiplicity.Finite a b := by\n  classical\n    revert hb\n    refine' WfDvdMonoid.induction_on_irreducible b (by contradiction) (fun u hu hu' => _) fun b p hb hp ih hpb => _\n    · rw [multiplicity.finite_iff_dom, multiplicity.isUnit_right ha.not_unit hu]\n      exact PartENat.dom_natCast 0\n    · refine'\n        multiplicity.finite_mul ha\n          (multiplicity.finite_iff_dom.mpr (PartENat.dom_of_le_natCast (show multiplicity a p ≤ ↑1 from _))) (ih hb)\n      norm_cast\n      exact ((multiplicity.squarefree_iff_multiplicity_le_one p).mp hp.squarefree a).resolve_right ha.not_unit\n#align finite_prime_left finite_prime_left\n\n",
 "dvd_pow_iff_dvd_of_squarefree":
 "theorem dvd_pow_iff_dvd_of_squarefree {x y : R} {n : ℕ} (hsq : Squarefree x) (h0 : n ≠ 0) : x ∣ y ^ n ↔ x ∣ y := by\n  classical\n    haveI := UniqueFactorizationMonoid.toGCDMonoid R\n    exact ⟨hsq.is_radical n y, fun h => h.pow h0⟩\n#align dvd_pow_iff_dvd_of_squarefree dvd_pow_iff_dvd_of_squarefree\n\n"}