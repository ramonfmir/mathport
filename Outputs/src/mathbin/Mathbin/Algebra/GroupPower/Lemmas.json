{"zsmul_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print zsmul_one /-\ntheorem zsmul_one [AddGroupWithOne A] (n : ℤ) : «expr • » n (1 : A) = n := by cases n <;> simp\n#align zsmul_one zsmul_one\n-/\n\n",
 "zsmul_int_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print zsmul_int_one /-\ntheorem zsmul_int_one (n : ℤ) : «expr • » n 1 = n := by simp\n#align zsmul_int_one zsmul_int_one\n-/\n\n",
 "zsmul_int_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print zsmul_int_int /-\ntheorem zsmul_int_int (a b : ℤ) : «expr • » a b = a * b := by simp\n#align zsmul_int_int zsmul_int_int\n-/\n\n",
 "zsmul_eq_mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print zsmul_eq_mul' /-\ntheorem zsmul_eq_mul' [Ring R] (a : R) (n : ℤ) : «expr • » n a = a * n := by rw [zsmul_eq_mul, (n.cast_commute a).eq]\n#align zsmul_eq_mul' zsmul_eq_mul'\n-/\n\n",
 "zsmul_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print zsmul_eq_mul /-\n@[simp]\ntheorem zsmul_eq_mul [Ring R] (a : R) : ∀ n : ℤ, «expr • » n a = n * a\n  | (n : ℕ) => by rw [coe_nat_zsmul, nsmul_eq_mul, Int.cast_ofNat]\n  | -[n+1] => by simp [Nat.cast_succ, neg_add_rev, Int.cast_negSucc, add_mul]\n#align zsmul_eq_mul zsmul_eq_mul\n-/\n\n",
 "zpowersMulHom_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print zpowersMulHom_symm_apply /-\n@[simp]\ntheorem zpowersMulHom_symm_apply [comm_group G] (f : «expr →* » (Multiplicative ℤ) G) :\n    (zpowersMulHom G).symm f = f (Multiplicative.ofAdd 1) :=\n  rfl\n#align zpowers_mul_hom_symm_apply zpowersMulHom_symm_apply\n-/\n\n",
 "zpowersMulHom_apply":
 "#print zpowersMulHom_apply /-\n@[simp]\ntheorem zpowersMulHom_apply [comm_group G] (x : G) (n : Multiplicative ℤ) : zpowersMulHom G x n = x ^ n.to_add :=\n  rfl\n#align zpowers_mul_hom_apply zpowersMulHom_apply\n-/\n\n",
 "zpowersHom_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print zpowersHom_symm_apply /-\n@[simp]\ntheorem zpowersHom_symm_apply [group G] (f : «expr →* » (Multiplicative ℤ) G) :\n    (zpowersHom G).symm f = f (Multiplicative.ofAdd 1) :=\n  rfl\n#align zpowers_hom_symm_apply zpowersHom_symm_apply\n-/\n\n",
 "zpowersHom_apply":
 "#print zpowersHom_apply /-\n@[simp]\ntheorem zpowersHom_apply [group G] (x : G) (n : Multiplicative ℤ) : zpowersHom G x n = x ^ n.to_add :=\n  rfl\n#align zpowers_hom_apply zpowersHom_apply\n-/\n\n",
 "zpow_sub_one":
 "#print zpow_sub_one /-\n@[to_additive sub_one_zsmul]\ntheorem zpow_sub_one (a : G) (n : ℤ) : a ^ (n - 1) = a ^ n * a⁻¹ :=\n  calc\n    a ^ (n - 1) = a ^ (n - 1) * a * a⁻¹ := (mul_inv_cancel_right _ _).symm\n    _ = a ^ n * a⁻¹ := by rw [← zpow_add_one, sub_add_cancel]\n    \n#align zpow_sub_one zpow_sub_one\n-/\n\n",
 "zpow_sub":
 "#print zpow_sub /-\n@[to_additive sub_zsmul]\ntheorem zpow_sub (a : G) (m n : ℤ) : a ^ (m - n) = a ^ m * (a ^ n)⁻¹ := by rw [sub_eq_add_neg, zpow_add, zpow_neg]\n#align zpow_sub zpow_sub\n-/\n\n",
 "zpow_strictMono_right":
 "#print zpow_strictMono_right /-\n@[to_additive zsmul_strictMono_left]\ntheorem zpow_strictMono_right (ha : 1 < a) : strict_mono fun n : ℤ => a ^ n := fun m n h =>\n  calc\n    a ^ m = a ^ m * 1 := (mul_one _).symm\n    _ < a ^ m * a ^ (n - m) := mul_lt_mul_left' (one_lt_zpow' ha <| sub_pos_of_lt h) _\n    _ = a ^ n := by\n      rw [← zpow_add]\n      simp\n    \n#align zpow_strict_mono_right zpow_strictMono_right\n-/\n\n",
 "zpow_strictMono_left":
 "#print zpow_strictMono_left /-\n@[to_additive zsmul_strictMono_right]\ntheorem zpow_strictMono_left (hn : 0 < n) : strict_mono ((· ^ n) : α → α) := fun a b hab =>\n  by\n  rw [← one_lt_div', ← div_zpow]\n  exact one_lt_zpow' (one_lt_div'.2 hab) hn\n#align zpow_strict_mono_left zpow_strictMono_left\n-/\n\n",
 "zpow_one_add":
 "#print zpow_one_add /-\n@[to_additive one_add_zsmul]\ntheorem zpow_one_add (a : G) (i : ℤ) : a ^ (1 + i) = a * a ^ i := by rw [zpow_add, zpow_one]\n#align zpow_one_add zpow_one_add\n-/\n\n",
 "zpow_mul_comm":
 "#print zpow_mul_comm /-\n@[to_additive]\ntheorem zpow_mul_comm (a : G) (i j : ℤ) : a ^ i * a ^ j = a ^ j * a ^ i :=\n  (Commute.refl _).zpow_zpow _ _\n#align zpow_mul_comm zpow_mul_comm\n-/\n\n",
 "zpow_mul'":
 "#print zpow_mul' /-\n@[to_additive mul_zsmul]\ntheorem zpow_mul' (a : α) (m n : ℤ) : a ^ (m * n) = (a ^ n) ^ m := by rw [mul_comm, zpow_mul]\n#align zpow_mul' zpow_mul'\n-/\n\n",
 "zpow_mul":
 "#print zpow_mul /-\n-- Note that `mul_zsmul` and `zpow_mul` have the primes swapped since their argument order,\n-- and therefore the more \"natural\" choice of lemma, is reversed.\n@[to_additive mul_zsmul']\ntheorem zpow_mul (a : α) : ∀ m n : ℤ, a ^ (m * n) = (a ^ m) ^ n\n  | (m : ℕ), (n : ℕ) => by\n    rw [zpow_ofNat, zpow_ofNat, ← pow_mul, ← zpow_ofNat]\n    rfl\n  | (m : ℕ), -[n+1] =>\n    by\n    rw [zpow_ofNat, zpow_negSucc, ← pow_mul, coe_nat_mul_neg_succ, zpow_neg, inv_inj, ← zpow_ofNat]\n    rfl\n  | -[m+1], (n : ℕ) =>\n    by\n    rw [zpow_ofNat, zpow_negSucc, ← inv_pow, ← pow_mul, neg_succ_mul_coe_nat, zpow_neg, inv_pow, inv_inj, ← zpow_ofNat]\n    rfl\n  | -[m+1], -[n+1] =>\n    by\n    rw [zpow_negSucc, zpow_negSucc, neg_succ_mul_neg_succ, inv_pow, inv_inv, ← pow_mul, ← zpow_ofNat]\n    rfl\n#align zpow_mul zpow_mul\n-/\n\n",
 "zpow_mono_right":
 "#print zpow_mono_right /-\n@[to_additive zsmul_mono_left]\ntheorem zpow_mono_right (ha : 1 ≤ a) : monotone fun n : ℤ => a ^ n := fun m n h =>\n  calc\n    a ^ m = a ^ m * 1 := (mul_one _).symm\n    _ ≤ a ^ m * a ^ (n - m) := mul_le_mul_left' (one_le_zpow ha <| sub_nonneg_of_le h) _\n    _ = a ^ n := by\n      rw [← zpow_add]\n      simp\n    \n#align zpow_mono_right zpow_mono_right\n-/\n\n",
 "zpow_mono_left":
 "#print zpow_mono_left /-\n@[to_additive zsmul_mono_right]\ntheorem zpow_mono_left (hn : 0 ≤ n) : monotone ((· ^ n) : α → α) := fun a b hab =>\n  by\n  rw [← one_le_div', ← div_zpow]\n  exact one_le_zpow (one_le_div'.2 hab) hn\n#align zpow_mono_left zpow_mono_left\n-/\n\n",
 "zpow_lt_zpow_iff'":
 "#print zpow_lt_zpow_iff' /-\n@[to_additive]\ntheorem zpow_lt_zpow_iff' (hn : 0 < n) {a b : α} : a ^ n < b ^ n ↔ a < b :=\n  (zpow_strictMono_left α hn).lt_iff_lt\n#align zpow_lt_zpow_iff' zpow_lt_zpow_iff'\n-/\n\n",
 "zpow_lt_zpow_iff":
 "#print zpow_lt_zpow_iff /-\n@[to_additive]\ntheorem zpow_lt_zpow_iff (ha : 1 < a) : a ^ m < a ^ n ↔ m < n :=\n  (zpow_strictMono_right ha).lt_iff_lt\n#align zpow_lt_zpow_iff zpow_lt_zpow_iff\n-/\n\n",
 "zpow_lt_zpow'":
 "#print zpow_lt_zpow' /-\n@[to_additive]\ntheorem zpow_lt_zpow' (hn : 0 < n) (h : a < b) : a ^ n < b ^ n :=\n  zpow_strictMono_left α hn h\n#align zpow_lt_zpow' zpow_lt_zpow'\n-/\n\n",
 "zpow_lt_zpow":
 "#print zpow_lt_zpow /-\n@[to_additive]\ntheorem zpow_lt_zpow (ha : 1 < a) (h : m < n) : a ^ m < a ^ n :=\n  zpow_strictMono_right ha h\n#align zpow_lt_zpow zpow_lt_zpow\n-/\n\n",
 "zpow_left_injective":
 "#print zpow_left_injective /-\n@[nolint to_additive_doc,\n  to_additive zsmul_right_injective\n      \"See also `smul_right_injective`. TODO: provide a `no_zero_smul_divisors` instance. We can't do that\\nhere because importing that definition would create import cycles.\"]\ntheorem zpow_left_injective (hn : n ≠ 0) : function.injective ((· ^ n) : α → α) :=\n  by\n  cases hn.symm.lt_or_lt\n  · exact (zpow_strictMono_left α h).injective\n  · refine' fun a b (hab : a ^ n = b ^ n) => (zpow_strictMono_left α (neg_pos.mpr h)).injective _\n    rw [zpow_neg, zpow_neg, hab]\n#align zpow_left_injective zpow_left_injective\n-/\n\n",
 "zpow_left_inj":
 "#print zpow_left_inj /-\n@[to_additive zsmul_right_inj]\ntheorem zpow_left_inj (hn : n ≠ 0) : a ^ n = b ^ n ↔ a = b :=\n  (zpow_left_injective hn).eq_iff\n#align zpow_left_inj zpow_left_inj\n-/\n\n",
 "zpow_le_zpow_iff'":
 "#print zpow_le_zpow_iff' /-\n@[to_additive]\ntheorem zpow_le_zpow_iff' (hn : 0 < n) {a b : α} : a ^ n ≤ b ^ n ↔ a ≤ b :=\n  (zpow_strictMono_left α hn).le_iff_le\n#align zpow_le_zpow_iff' zpow_le_zpow_iff'\n-/\n\n",
 "zpow_le_zpow_iff":
 "#print zpow_le_zpow_iff /-\n@[to_additive]\ntheorem zpow_le_zpow_iff (ha : 1 < a) : a ^ m ≤ a ^ n ↔ m ≤ n :=\n  (zpow_strictMono_right ha).le_iff_le\n#align zpow_le_zpow_iff zpow_le_zpow_iff\n-/\n\n",
 "zpow_le_zpow'":
 "#print zpow_le_zpow' /-\n@[to_additive]\ntheorem zpow_le_zpow' (hn : 0 ≤ n) (h : a ≤ b) : a ^ n ≤ b ^ n :=\n  zpow_mono_left α hn h\n#align zpow_le_zpow' zpow_le_zpow'\n-/\n\n",
 "zpow_le_zpow":
 "#print zpow_le_zpow /-\n@[to_additive]\ntheorem zpow_le_zpow (ha : 1 ≤ a) (h : m ≤ n) : a ^ m ≤ a ^ n :=\n  zpow_mono_right ha h\n#align zpow_le_zpow zpow_le_zpow\n-/\n\n",
 "zpow_eq_zpow_iff'":
 "#print zpow_eq_zpow_iff' /-\n/-- Alias of `zsmul_right_inj`, for ease of discovery alongside `zsmul_le_zsmul_iff'` and\n`zsmul_lt_zsmul_iff'`. -/\n@[to_additive\n      \"Alias of `zsmul_right_inj`, for ease of discovery alongside `zsmul_le_zsmul_iff'` and\\n`zsmul_lt_zsmul_iff'`.\"]\ntheorem zpow_eq_zpow_iff' (hn : n ≠ 0) : a ^ n = b ^ n ↔ a = b :=\n  zpow_left_inj hn\n#align zpow_eq_zpow_iff' zpow_eq_zpow_iff'\n-/\n\n",
 "zpow_bit1":
 "#print zpow_bit1 /-\n@[to_additive bit1_zsmul]\ntheorem zpow_bit1 (a : G) (n : ℤ) : a ^ bit1 n = a ^ n * a ^ n * a := by rw [bit1, zpow_add, zpow_bit0, zpow_one]\n#align zpow_bit1 zpow_bit1\n-/\n\n",
 "zpow_bit0_neg":
 "#print zpow_bit0_neg /-\n@[simp]\ntheorem zpow_bit0_neg [HasDistribNeg α] (x : α) (n : ℤ) : (-x) ^ bit0 n = x ^ bit0 n := by\n  rw [zpow_bit0', zpow_bit0', neg_mul_neg]\n#align zpow_bit0_neg zpow_bit0_neg\n-/\n\n",
 "zpow_bit0'":
 "#print zpow_bit0' /-\n@[to_additive bit0_zsmul']\ntheorem zpow_bit0' (a : α) (n : ℤ) : a ^ bit0 n = (a * a) ^ n :=\n  (zpow_bit0 a n).trans ((Commute.refl a).mul_zpow n).symm\n#align zpow_bit0' zpow_bit0'\n-/\n\n",
 "zpow_bit0":
 "#print zpow_bit0 /-\n@[to_additive bit0_zsmul]\ntheorem zpow_bit0 (a : α) : ∀ n : ℤ, a ^ bit0 n = a ^ n * a ^ n\n  | (n : ℕ) => by simp only [zpow_ofNat, ← Int.ofNat_bit0, pow_bit0]\n  | -[n+1] => by\n    simp [← mul_inv_rev, ← pow_bit0]\n    rw [neg_succ_of_nat_eq, bit0_neg, zpow_neg]\n    norm_cast\n#align zpow_bit0 zpow_bit0\n-/\n\n",
 "zpow_add_one":
 "#print zpow_add_one /-\n@[to_additive add_one_zsmul]\ntheorem zpow_add_one (a : G) : ∀ n : ℤ, a ^ (n + 1) = a ^ n * a\n  | (n : ℕ) => by simp only [← Int.ofNat_succ, zpow_ofNat, pow_succ']\n  | -[0+1] => by erw [zpow_zero, zpow_negSucc, pow_one, mul_left_inv]\n  | -[n + 1+1] => by\n    rw [zpow_negSucc, pow_succ, mul_inv_rev, inv_mul_cancel_right]\n    rw [Int.negSucc_eq, neg_add, add_assoc, neg_add_self, add_zero]\n    exact zpow_negSucc _ _\n#align zpow_add_one zpow_add_one\n-/\n\n",
 "zpow_add":
 "#print zpow_add /-\n@[to_additive add_zsmul]\ntheorem zpow_add (a : G) (m n : ℤ) : a ^ (m + n) = a ^ m * a ^ n :=\n  by\n  induction' n using int.induction_on with n ihn n ihn\n  case hz => simp\n  · simp only [← add_assoc, zpow_add_one, ihn, mul_assoc]\n  · rw [zpow_sub_one, ← mul_assoc, ← ihn, ← zpow_sub_one, add_sub_assoc]\n#align zpow_add zpow_add\n-/\n\n",
 "zmultiplesHom_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n#print zmultiplesHom_symm_apply /-\n@[simp]\ntheorem zmultiplesHom_symm_apply [add_group A] (f : «expr →+ » ℤ A) : (zmultiplesHom A).symm f = f 1 :=\n  rfl\n#align zmultiples_hom_symm_apply zmultiplesHom_symm_apply\n-/\n\n",
 "zmultiplesHom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print zmultiplesHom_apply /-\n@[simp]\ntheorem zmultiplesHom_apply [add_group A] (x : A) (n : ℤ) : zmultiplesHom A x n = «expr • » n x :=\n  rfl\n#align zmultiples_hom_apply zmultiplesHom_apply\n-/\n\n",
 "zmultiplesAddHom_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n#print zmultiplesAddHom_symm_apply /-\n@[simp]\ntheorem zmultiplesAddHom_symm_apply [add_comm_group A] (f : «expr →+ » ℤ A) : (zmultiplesAddHom A).symm f = f 1 :=\n  rfl\n#align zmultiples_add_hom_symm_apply zmultiplesAddHom_symm_apply\n-/\n\n",
 "zmultiplesAddHom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print zmultiplesAddHom_apply /-\n@[simp]\ntheorem zmultiplesAddHom_apply [add_comm_group A] (x : A) (n : ℤ) : zmultiplesAddHom A x n = «expr • » n x :=\n  rfl\n#align zmultiples_add_hom_apply zmultiplesAddHom_apply\n-/\n\n",
 "unop_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[simp]\ntheorem unop_zpow [div_inv_monoid M] (x : «expr ᵐᵒᵖ» M) (z : ℤ) : unop (x ^ z) = unop x ^ z :=\n  rfl\n#align unop_zpow unop_zpow\n\n",
 "unop_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[simp]\ntheorem unop_pow [monoid M] (x : «expr ᵐᵒᵖ» M) (n : ℕ) : unop (x ^ n) = unop x ^ n :=\n  rfl\n#align unop_pow unop_pow\n\n",
 "units_zpow_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[simp, to_additive]\ntheorem units_zpow_right {a : M} {u : «expr ˣ» M} (h : Commute a u) (m : ℤ) : Commute a ↑(u ^ m) :=\n  h.units_zpow_right m\n#align units_zpow_right units_zpow_right\n\n",
 "units_zpow_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[simp, to_additive]\ntheorem units_zpow_left {u : «expr ˣ» M} {a : M} (h : Commute (↑u) a) (m : ℤ) : Commute (↑(u ^ m)) a :=\n  (h.symm.units_zpow_right m).symm\n#align units_zpow_left units_zpow_left\n\n",
 "toAdd_zpow":
 "#print Int.toAdd_zpow /-\n@[simp]\ntheorem Int.toAdd_zpow (a : Multiplicative ℤ) (b : ℤ) : toAdd (a ^ b) = toAdd a * b :=\n  int.induction_on b (by simp) (by simp (config := { contextual := true }) [zpow_add, mul_add])\n    (by simp (config := { contextual := true }) [zpow_add, mul_add, sub_eq_add_neg, -int.add_neg_one])\n#align int.to_add_zpow Int.toAdd_zpow\n-/\n\n",
 "toAdd_pow":
 "#print Int.toAdd_pow /-\n@[simp]\ntheorem Int.toAdd_pow (a : Multiplicative ℤ) (b : ℕ) : toAdd (a ^ b) = toAdd a * b := by\n  induction b <;> simp [*, mul_add, pow_succ, add_comm]\n#align int.to_add_pow Int.toAdd_pow\n-/\n\n",
 "strictMono_pow_bit1":
 "#print strictMono_pow_bit1 /-\ntheorem strictMono_pow_bit1 (n : ℕ) : strict_mono fun a : R => a ^ bit1 n :=\n  by\n  intro a b hab\n  cases' le_total a 0 with ha ha\n  · cases' le_or_lt b 0 with hb hb\n    · rw [← neg_lt_neg_iff, ← neg_pow_bit1, ← neg_pow_bit1]\n      exact pow_lt_pow_of_lt_left (neg_lt_neg hab) (neg_nonneg.2 hb) (bit1_pos (zero_le n))\n    · exact (pow_bit1_nonpos_iff.2 ha).trans_lt (pow_bit1_pos_iff.2 hb)\n  · exact pow_lt_pow_of_lt_left hab ha (bit1_pos (zero_le n))\n#align strict_mono_pow_bit1 strictMono_pow_bit1\n-/\n\n",
 "sq_le":
 "#print sq_le /-\ntheorem sq_le (h₀ : 0 ≤ a) (h₁ : a ≤ 1) : a ^ 2 ≤ a :=\n  pow_le_of_le_one h₀ h₁ two_ne_zero\n#align sq_le sq_le\n-/\n\n",
 "smul_pow'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_pow' /-\n@[simp]\ntheorem smul_pow' [MulDistribMulAction M N] (x : M) (m : N) (n : ℕ) : «expr • » x (m ^ n) = «expr • » x m ^ n :=\n  by\n  induction' n with n ih\n  · rw [pow_zero, pow_zero]\n    exact smul_one x\n  · rw [pow_succ, pow_succ]\n    exact (smul_mul' x m (m ^ n)).trans (congr_arg _ ih)\n#align smul_pow' smul_pow'\n-/\n\n",
 "smul_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_pow /-\ntheorem smul_pow [MulAction M N] [IsScalarTower M N N] [SMulCommClass M N N] (k : M) (x : N) (p : ℕ) :\n    «expr • » k x ^ p = «expr • » (k ^ p) (x ^ p) :=\n  by\n  induction' p with p IH\n  · simp\n  · rw [pow_succ', IH, smul_mul_smul, ← pow_succ', ← pow_succ']\n#align smul_pow smul_pow\n-/\n\n",
 "sign_cases_of_C_mul_pow_nonneg":
 "#print sign_cases_of_C_mul_pow_nonneg /-\ntheorem sign_cases_of_C_mul_pow_nonneg {C r : R} (h : ∀ n : ℕ, 0 ≤ C * r ^ n) : C = 0 ∨ 0 < C ∧ 0 ≤ r :=\n  by\n  have : 0 ≤ C := by simpa only [pow_zero, mul_one] using h 0\n  refine' this.eq_or_lt.elim (fun h => or.inl h.symm) fun hC => or.inr ⟨hC, _⟩\n  refine' nonneg_of_mul_nonneg_right _ hC\n  simpa only [pow_one] using h 1\n#align sign_cases_of_C_mul_pow_nonneg sign_cases_of_C_mul_pow_nonneg\n-/\n\n",
 "self_cast_nat_mul_cast_nat_mul":
 "@[simp]\ntheorem self_cast_nat_mul_cast_nat_mul (m n : ℕ) : Commute (m * a : R) (n * a : R) :=\n  (Commute.refl a).cast_nat_mul_cast_nat_mul m n\n#align self_cast_nat_mul_cast_nat_mul self_cast_nat_mul_cast_nat_mul\n\n",
 "self_cast_nat_mul":
 "@[simp]\ntheorem self_cast_nat_mul (n : ℕ) : Commute a (n * a : R) :=\n  (Commute.refl a).cast_nat_mul_right n\n#align self_cast_nat_mul self_cast_nat_mul\n\n",
 "self_cast_int_mul_cast_int_mul":
 "theorem self_cast_int_mul_cast_int_mul : Commute (m * a : R) (n * a : R) :=\n  (Commute.refl a).cast_int_mul_cast_int_mul m n\n#align self_cast_int_mul_cast_int_mul self_cast_int_mul_cast_int_mul\n\n",
 "self_cast_int_mul":
 "@[simp]\ntheorem self_cast_int_mul : Commute a (n * a : R) :=\n  (Commute.refl a).cast_int_mul_right n\n#align self_cast_int_mul self_cast_int_mul\n\n",
 "powersMulHom_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print powersMulHom_symm_apply /-\n@[simp]\ntheorem powersMulHom_symm_apply [comm_monoid M] (f : «expr →* » (Multiplicative ℕ) M) :\n    (powersMulHom M).symm f = f (Multiplicative.ofAdd 1) :=\n  rfl\n#align powers_mul_hom_symm_apply powersMulHom_symm_apply\n-/\n\n",
 "powersMulHom_apply":
 "#print powersMulHom_apply /-\n@[simp]\ntheorem powersMulHom_apply [comm_monoid M] (x : M) (n : Multiplicative ℕ) : powersMulHom M x n = x ^ n.to_add :=\n  rfl\n#align powers_mul_hom_apply powersMulHom_apply\n-/\n\n",
 "powersHom_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print powersHom_symm_apply /-\n@[simp]\ntheorem powersHom_symm_apply [monoid M] (f : «expr →* » (Multiplicative ℕ) M) :\n    (powersHom M).symm f = f (Multiplicative.ofAdd 1) :=\n  rfl\n#align powers_hom_symm_apply powersHom_symm_apply\n-/\n\n",
 "powersHom_apply":
 "#print powersHom_apply /-\n@[simp]\ntheorem powersHom_apply [monoid M] (x : M) (n : Multiplicative ℕ) : powersHom M x n = x ^ n.to_add :=\n  rfl\n#align powers_hom_apply powersHom_apply\n-/\n\n",
 "pow_right_injective":
 "theorem pow_right_injective {x : ℤ} (h : 1 < x.nat_abs) : function.injective ((· ^ ·) x : ℕ → ℤ) :=\n  by\n  suffices function.injective (nat_abs ∘ ((· ^ ·) x : ℕ → ℤ)) by exact function.injective.of_comp this\n  convert Nat.pow_right_injective h\n  ext n\n  rw [Function.comp_apply, nat_abs_pow]\n#align pow_right_injective pow_right_injective\n\n",
 "pow_ofPowEqOne":
 "#print Units.pow_ofPowEqOne /-\n@[simp, to_additive]\ntheorem Units.pow_ofPowEqOne {x : M} {n : ℕ} (hx : x ^ n = 1) (hn : n ≠ 0) : Units.ofPowEqOne x n hx hn ^ n = 1 :=\n  Units.ext <| by rwa [Units.val_pow_eq_pow_val, units.coe_of_pow_eq_one, Units.val_one]\n#align units.pow_of_pow_eq_one Units.pow_ofPowEqOne\n-/\n\n",
 "pow_le_pow_of_le_one_aux":
 "#print pow_le_pow_of_le_one_aux /-\nprivate theorem pow_le_pow_of_le_one_aux (h : 0 ≤ a) (ha : a ≤ 1) (i : ℕ) : ∀ k : ℕ, a ^ (i + k) ≤ a ^ i\n  | 0 => by simp\n  | k + 1 => by\n    rw [← add_assoc, ← one_mul (a ^ i), pow_succ]\n    exact mul_le_mul ha (pow_le_pow_of_le_one_aux _) (pow_nonneg h _) zero_le_one\n#align pow_le_pow_of_le_one_aux pow_le_pow_of_le_one_aux\n-/\n\n",
 "pow_le_pow_of_le_one":
 "#print pow_le_pow_of_le_one /-\ntheorem pow_le_pow_of_le_one (h : 0 ≤ a) (ha : a ≤ 1) {i j : ℕ} (hij : i ≤ j) : a ^ j ≤ a ^ i :=\n  by\n  let ⟨k, hk⟩ := Nat.exists_eq_add_of_le hij\n  rw [hk] <;> exact pow_le_pow_of_le_one_aux h ha _ _\n#align pow_le_pow_of_le_one pow_le_pow_of_le_one\n-/\n\n",
 "pow_le_of_le_one":
 "#print pow_le_of_le_one /-\ntheorem pow_le_of_le_one (h₀ : 0 ≤ a) (h₁ : a ≤ 1) {n : ℕ} (hn : n ≠ 0) : a ^ n ≤ a :=\n  (pow_one a).subst (pow_le_pow_of_le_one h₀ h₁ (nat.pos_of_ne_zero hn))\n#align pow_le_of_le_one pow_le_of_le_one\n-/\n\n",
 "pow_bit1_pos_iff":
 "#print pow_bit1_pos_iff /-\n@[simp]\ntheorem pow_bit1_pos_iff : 0 < a ^ bit1 n ↔ 0 < a :=\n  lt_iff_lt_of_le_iff_le pow_bit1_nonpos_iff\n#align pow_bit1_pos_iff pow_bit1_pos_iff\n-/\n\n",
 "pow_bit1_nonpos_iff":
 "#print pow_bit1_nonpos_iff /-\n@[simp]\ntheorem pow_bit1_nonpos_iff : a ^ bit1 n ≤ 0 ↔ a ≤ 0 := by\n  simp only [le_iff_lt_or_eq, pow_bit1_neg_iff, pow_eq_zero_iff (bit1_pos (zero_le n))]\n#align pow_bit1_nonpos_iff pow_bit1_nonpos_iff\n-/\n\n",
 "pow_bit1_nonneg_iff":
 "#print pow_bit1_nonneg_iff /-\n@[simp]\ntheorem pow_bit1_nonneg_iff : 0 ≤ a ^ bit1 n ↔ 0 ≤ a :=\n  le_iff_le_iff_lt_iff_lt.2 pow_bit1_neg_iff\n#align pow_bit1_nonneg_iff pow_bit1_nonneg_iff\n-/\n\n",
 "pow_bit1_neg_iff":
 "#print pow_bit1_neg_iff /-\n@[simp]\ntheorem pow_bit1_neg_iff : a ^ bit1 n < 0 ↔ a < 0 :=\n  ⟨fun h => not_le.1 fun h' => not_le.2 h <| pow_nonneg h' _, fun ha => pow_bit1_neg ha n⟩\n#align pow_bit1_neg_iff pow_bit1_neg_iff\n-/\n\n",
 "pow":
 "#print IsUnit.pow /-\n@[to_additive]\ntheorem IsUnit.pow {m : M} (n : ℕ) : is_unit m → is_unit (m ^ n) := fun ⟨u, hu⟩ => ⟨u ^ n, hu ▸ u.coe_pow _⟩\n#align is_unit.pow IsUnit.pow\n-/\n\n",
 "op_zpow":
 "/-- Moving to the opposite group or group_with_zero commutes with taking powers. -/\n@[simp]\ntheorem op_zpow [div_inv_monoid M] (x : M) (z : ℤ) : op (x ^ z) = op x ^ z :=\n  rfl\n#align op_zpow op_zpow\n\n",
 "op_pow":
 "/-- Moving to the opposite monoid commutes with taking powers. -/\n@[simp]\ntheorem op_pow [monoid M] (x : M) (n : ℕ) : op (x ^ n) = op x ^ n :=\n  rfl\n#align op_pow op_pow\n\n",
 "one_lt_zpow'":
 "#print one_lt_zpow' /-\n@[to_additive zsmul_pos]\ntheorem one_lt_zpow' (ha : 1 < a) {k : ℤ} (hk : (0 : ℤ) < k) : 1 < a ^ k :=\n  by\n  lift k to ℕ using int.le_of_lt hk\n  rw [zpow_ofNat]\n  exact one_lt_pow' ha (coe_nat_pos.mp hk).ne'\n#align one_lt_zpow' one_lt_zpow'\n-/\n\n",
 "one_add_mul_sub_le_pow":
 "#print one_add_mul_sub_le_pow /-\n/-- Bernoulli's inequality reformulated to estimate `a^n`. -/\ntheorem one_add_mul_sub_le_pow (H : -1 ≤ a) (n : ℕ) : 1 + (n : R) * (a - 1) ≤ a ^ n :=\n  by\n  have : -2 ≤ a - 1 := by rwa [bit0, neg_add, ← sub_eq_add_neg, sub_le_sub_iff_right]\n  simpa only [add_sub_cancel'_right] using one_add_mul_le_pow this n\n#align one_add_mul_sub_le_pow one_add_mul_sub_le_pow\n-/\n\n",
 "one_add_mul_le_pow'":
 "#print one_add_mul_le_pow' /-\n/-- Bernoulli's inequality. This version works for semirings but requires\nadditional hypotheses `0 ≤ a * a` and `0 ≤ (1 + a) * (1 + a)`. -/\ntheorem one_add_mul_le_pow' (Hsq : 0 ≤ a * a) (Hsq' : 0 ≤ (1 + a) * (1 + a)) (H : 0 ≤ 2 + a) :\n    ∀ n : ℕ, 1 + (n : R) * a ≤ (1 + a) ^ n\n  | 0 => by simp\n  | 1 => by simp\n  | n + 2 =>\n    have : 0 ≤ (n : R) * (a * a * (2 + a)) + a * a := add_nonneg (mul_nonneg n.cast_nonneg (mul_nonneg Hsq H)) Hsq\n    calc\n      1 + (↑(n + 2) : R) * a ≤ 1 + ↑(n + 2) * a + (n * (a * a * (2 + a)) + a * a) := (le_add_iff_nonneg_right _).2 this\n      _ = (1 + a) * (1 + a) * (1 + n * a) :=\n        by\n        simp [add_mul, mul_add, bit0, mul_assoc, (n.cast_commute (_ : R)).left_comm]\n        ac_rfl\n      _ ≤ (1 + a) * (1 + a) * (1 + a) ^ n := mul_le_mul_of_nonneg_left (one_add_mul_le_pow' n) Hsq'\n      _ = (1 + a) ^ (n + 2) := by simp only [pow_succ, mul_assoc]\n      \n#align one_add_mul_le_pow' one_add_mul_le_pow'\n-/\n\n",
 "one_add_mul_le_pow":
 "#print one_add_mul_le_pow /-\n/-- Bernoulli's inequality for `n : ℕ`, `-2 ≤ a`. -/\ntheorem one_add_mul_le_pow (H : -2 ≤ a) (n : ℕ) : 1 + (n : R) * a ≤ (1 + a) ^ n :=\n  one_add_mul_le_pow' (mul_self_nonneg _) (mul_self_nonneg _) (neg_le_iff_add_nonneg'.1 H) _\n#align one_add_mul_le_pow one_add_mul_le_pow\n-/\n\n",
 "ofAdd_mul":
 "#print Int.ofAdd_mul /-\n@[simp]\ntheorem Int.ofAdd_mul (a b : ℤ) : ofAdd (a * b) = ofAdd a ^ b :=\n  (Int.toAdd_zpow _ _).symm\n#align int.of_add_mul Int.ofAdd_mul\n-/\n\n",
 "nsmul_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print nsmul_one /-\n/-\nCopyright (c) 2015 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Robert Y. Lewis\n-/\n@[simp]\ntheorem nsmul_one [AddMonoidWithOne A] : ∀ n : ℕ, «expr • » n (1 : A) = n :=\n  by\n  refine' eq_nat_cast' (⟨_, _, _⟩ : «expr →+ » ℕ A) _\n  · show «expr • » 0 (1 : A) = 0\n    simp [zero_nsmul]\n  · show ∀ x y : ℕ, «expr • » (x + y) (1 : A) = «expr • » x 1 + «expr • » y 1\n    simp [add_nsmul]\n  · show «expr • » 1 (1 : A) = 1\n    simp\n#align nsmul_one nsmul_one\n-/\n\n",
 "nsmul_eq_mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem nsmul_eq_mul' [NonAssocSemiring R] (a : R) (n : ℕ) : «expr • » n a = a * n := by\n  induction' n with n ih <;> [rw [zero_nsmul, Nat.cast_zero, mul_zero],\n    rw [succ_nsmul', ih, Nat.cast_succ, mul_add, mul_one]]\n#align nsmul_eq_mul' nsmul_eq_mul'ₓ\n\n",
 "nsmul_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem nsmul_eq_mul [NonAssocSemiring R] (n : ℕ) (a : R) : «expr • » n a = n * a := by\n  rw [nsmul_eq_mul', (n.cast_commute a).eq]\n#align nsmul_eq_mul nsmul_eq_mulₓ\n\n",
 "neg_one_pow_eq_pow_mod_two":
 "#print neg_one_pow_eq_pow_mod_two /-\ntheorem neg_one_pow_eq_pow_mod_two [Ring R] {n : ℕ} : (-1 : R) ^ n = (-1) ^ (n % 2) := by\n  rw [← nat.mod_add_div n 2, pow_add, pow_mul] <;> simp [sq]\n#align neg_one_pow_eq_pow_mod_two neg_one_pow_eq_pow_mod_two\n-/\n\n",
 "nat_abs_sq":
 "theorem nat_abs_sq (x : ℤ) : (x.nat_abs ^ 2 : ℤ) = x ^ 2 := by rw [sq, Int.natAbs_mul_self', sq]\n#align nat_abs_sq nat_abs_sq\n\n",
 "natAbs_pow":
 "#print Int.natAbs_pow /-\ntheorem Int.natAbs_pow (n : ℤ) (k : ℕ) : Int.natAbs (n ^ k) = Int.natAbs n ^ k := by\n  induction' k with k ih <;> [rfl, rw [pow_succ', Int.natAbs_mul, pow_succ', ih]]\n#align int.nat_abs_pow Int.natAbs_pow\n-/\n\n",
 "multiplesHom_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n#print multiplesHom_symm_apply /-\n@[simp]\ntheorem multiplesHom_symm_apply [add_monoid A] (f : «expr →+ » ℕ A) : (multiplesHom A).symm f = f 1 :=\n  rfl\n#align multiples_hom_symm_apply multiplesHom_symm_apply\n-/\n\n",
 "multiplesHom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print multiplesHom_apply /-\n@[simp]\ntheorem multiplesHom_apply [add_monoid A] (x : A) (n : ℕ) : multiplesHom A x n = «expr • » n x :=\n  rfl\n#align multiples_hom_apply multiplesHom_apply\n-/\n\n",
 "multiplesAddHom_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n#print multiplesAddHom_symm_apply /-\n@[simp]\ntheorem multiplesAddHom_symm_apply [add_comm_monoid A] (f : «expr →+ » ℕ A) : (multiplesAddHom A).symm f = f 1 :=\n  rfl\n#align multiples_add_hom_symm_apply multiplesAddHom_symm_apply\n-/\n\n",
 "multiplesAddHom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print multiplesAddHom_apply /-\n@[simp]\ntheorem multiplesAddHom_apply [add_comm_monoid A] (x : A) (n : ℕ) : multiplesAddHom A x n = «expr • » n x :=\n  rfl\n#align multiples_add_hom_apply multiplesAddHom_apply\n-/\n\n",
 "mul_zpow_self":
 "#print mul_zpow_self /-\n@[to_additive add_self_zsmul]\ntheorem mul_zpow_self (b : G) (m : ℤ) : b ^ m * b = b ^ (m + 1) :=\n  by\n  conv_lhs =>\n    congr\n    skip\n    rw [← zpow_one b]\n  rw [← zpow_add, add_comm]\n#align mul_zpow_self mul_zpow_self\n-/\n\n",
 "mul_self_zpow":
 "#print mul_self_zpow /-\n@[to_additive add_zsmul_self]\ntheorem mul_self_zpow (b : G) (m : ℤ) : b * b ^ m = b ^ (m + 1) :=\n  by\n  conv_lhs =>\n    congr\n    rw [← zpow_one b]\n  rw [← zpow_add, add_comm]\n#align mul_self_zpow mul_self_zpow\n-/\n\n",
 "mul_bit1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print mul_bit1 /-\ntheorem mul_bit1 [NonAssocRing R] {n r : R} : r * bit1 n = «expr • » (2 : ℤ) (r * n) + r :=\n  by\n  dsimp [bit1]\n  rw [mul_add, mul_bit0, mul_one]\n#align mul_bit1 mul_bit1\n-/\n\n",
 "mul_bit0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print mul_bit0 /-\ntheorem mul_bit0 [NonUnitalNonAssocRing R] {n r : R} : r * bit0 n = «expr • » (2 : ℤ) (r * n) :=\n  by\n  dsimp [bit0]\n  rw [mul_add, add_zsmul, one_zsmul]\n#align mul_bit0 mul_bit0\n-/\n\n",
 "le_self_sq":
 "theorem le_self_sq (b : ℤ) : b ≤ b ^ 2 :=\n  le_trans le_natAbs (natAbs_le_self_sq _)\n#align le_self_sq le_self_sq\n\n",
 "isUnit_pow_succ_iff":
 "#print isUnit_pow_succ_iff /-\n@[to_additive]\ntheorem isUnit_pow_succ_iff {m : M} {n : ℕ} : is_unit (m ^ (n + 1)) ↔ is_unit m :=\n  isUnit_pow_iff n.succ_ne_zero\n#align is_unit_pow_succ_iff isUnit_pow_succ_iff\n-/\n\n",
 "isUnit_pow_iff":
 "#print isUnit_pow_iff /-\n@[simp, to_additive]\ntheorem isUnit_pow_iff {a : M} {n : ℕ} (hn : n ≠ 0) : is_unit (a ^ n) ↔ is_unit a :=\n  ⟨fun ⟨u, hu⟩ => (u.of_pow a hn hu.symm).is_unit, fun h => h.pow n⟩\n#align is_unit_pow_iff isUnit_pow_iff\n-/\n\n",
 "isUnit_ofPowEqOne":
 "#print isUnit_ofPowEqOne /-\n@[to_additive]\ntheorem isUnit_ofPowEqOne {x : M} {n : ℕ} (hx : x ^ n = 1) (hn : n ≠ 0) : is_unit x :=\n  (Units.ofPowEqOne x n hx hn).is_unit\n#align is_unit_of_pow_eq_one isUnit_ofPowEqOne\n-/\n\n",
 "invOf_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n#print invOf_pow /-\ntheorem invOf_pow (m : M) [Invertible m] (n : ℕ) [Invertible (m ^ n)] : («expr⅟») (m ^ n) = («expr⅟») m ^ n :=\n  @invertible_unique M _ (m ^ n) (m ^ n) _ (invertiblePow m n) rfl\n#align inv_of_pow invOf_pow\n-/\n\n",
 "ext_mnat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidHom.ext_mnat /-\n@[ext]\ntheorem MonoidHom.ext_mnat [monoid M] ⦃f g : «expr →* » (Multiplicative ℕ) M⦄\n    (h : f (Multiplicative.ofAdd 1) = g (Multiplicative.ofAdd 1)) : f = g :=\n  MonoidHom.ext fun n => by rw [f.apply_mnat, g.apply_mnat, h]\n#align monoid_hom.ext_mnat MonoidHom.ext_mnat\n-/\n\n",
 "conj_pow'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem conj_pow' (u : «expr ˣ» M) (x : M) (n : ℕ) : (↑u⁻¹ * x * u) ^ n = ↑u⁻¹ * x ^ n * u :=\n  u⁻¹.conj_pow x n\n#align conj_pow' conj_pow'\n\n",
 "conj_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n#print conj_pow /-\ntheorem conj_pow (u : «expr ˣ» M) (x : M) (n : ℕ) : (↑u * x * ↑u⁻¹) ^ n = u * x ^ n * ↑u⁻¹ :=\n  (divp_eq_iff_mul_eq.2 ((u.mk_semiconj_by x).pow_right n).eq.symm).symm\n#align conj_pow conj_pow\n-/\n\n",
 "coe_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print WithBot.coe_nsmul /-\n@[simp]\ntheorem WithBot.coe_nsmul [add_monoid A] (a : A) (n : ℕ) : ((«expr • » n a : A) : WithBot A) = «expr • » n a :=\n  AddMonoidHom.map_nsmul ⟨(coe : A → WithBot A), with_bot.coe_zero, WithBot.coe_add⟩ a n\n#align with_bot.coe_nsmul WithBot.coe_nsmul\n-/\n\n",
 "coe_nat_pow":
 "#print Int.coe_nat_pow /-\n@[simp, norm_cast]\ntheorem Int.coe_nat_pow (n m : ℕ) : ((n ^ m : ℕ) : ℤ) = n ^ m := by\n  induction' m with m ih <;> [exact Int.ofNat_one, rw [pow_succ', pow_succ', Int.ofNat_mul, ih]]\n#align int.coe_nat_pow Int.coe_nat_pow\n-/\n\n",
 "cast_pow":
 "@[simp, norm_cast]\ntheorem Int.cast_pow [Ring R] (n : ℤ) (m : ℕ) : (↑(n ^ m) : R) = ↑n ^ m :=\n  by\n  induction' m with m ih\n  · rw [pow_zero, pow_zero, Int.cast_one]\n  · rw [pow_succ, pow_succ, Int.cast_mul, ih]\n#align int.cast_pow Int.cast_powₓ\n\n",
 "cast_nat_mul_self":
 "@[simp]\ntheorem cast_nat_mul_self (n : ℕ) : Commute ((n : R) * a) a :=\n  (Commute.refl a).cast_nat_mul_left n\n#align cast_nat_mul_self cast_nat_mul_self\n\n",
 "cast_nat_mul_right":
 "@[simp]\ntheorem cast_nat_mul_right (h : Commute a b) (n : ℕ) : Commute a ((n : R) * b) :=\n  h.cast_nat_mul_right n\n#align cast_nat_mul_right cast_nat_mul_right\n\n",
 "cast_nat_mul_left":
 "@[simp]\ntheorem cast_nat_mul_left (h : Commute a b) (n : ℕ) : Commute ((n : R) * a) b :=\n  h.cast_nat_mul_left n\n#align cast_nat_mul_left cast_nat_mul_left\n\n",
 "cast_nat_mul_cast_nat_mul":
 "@[simp]\ntheorem cast_nat_mul_cast_nat_mul (h : Commute a b) (m n : ℕ) : Commute (m * a : R) (n * b : R) :=\n  h.cast_nat_mul_cast_nat_mul m n\n#align cast_nat_mul_cast_nat_mul cast_nat_mul_cast_nat_mul\n\n",
 "cast_int_right":
 "@[simp]\ntheorem cast_int_right : Commute a m := by\n  rw [← mul_one (m : R)]\n  exact (one_right a).cast_int_mul_right m\n#align cast_int_right cast_int_right\n\n",
 "cast_int_mul_self":
 "@[simp]\ntheorem cast_int_mul_self : Commute ((n : R) * a) a :=\n  (Commute.refl a).cast_int_mul_left n\n#align cast_int_mul_self cast_int_mul_self\n\n",
 "cast_int_mul_right":
 "@[simp]\ntheorem cast_int_mul_right (h : Commute a b) (m : ℤ) : Commute a (m * b : R) :=\n  h.cast_int_mul_right m\n#align cast_int_mul_right cast_int_mul_right\n\n",
 "cast_int_mul_left":
 "@[simp]\ntheorem cast_int_mul_left (h : Commute a b) (m : ℤ) : Commute ((m : R) * a) b :=\n  h.cast_int_mul_left m\n#align cast_int_mul_left cast_int_mul_left\n\n",
 "cast_int_mul_cast_int_mul":
 "theorem cast_int_mul_cast_int_mul (h : Commute a b) (m n : ℤ) : Commute (m * a : R) (n * b : R) :=\n  h.cast_int_mul_cast_int_mul m n\n#align cast_int_mul_cast_int_mul cast_int_mul_cast_int_mul\n\n",
 "cast_int_left":
 "@[simp]\ntheorem cast_int_left : Commute (m : R) a := by\n  rw [← mul_one (m : R)]\n  exact (one_left a).cast_int_mul_left m\n#align cast_int_left cast_int_left\n\n",
 "bit1_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print bit1_mul /-\ntheorem bit1_mul [NonAssocRing R] {n r : R} : bit1 n * r = «expr • » (2 : ℤ) (n * r) + r :=\n  by\n  dsimp [bit1]\n  rw [add_mul, bit0_mul, one_mul]\n#align bit1_mul bit1_mul\n-/\n\n",
 "bit0_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print bit0_mul /-\n-- The next four lemmas allow us to replace multiplication by a numeral with a `zsmul` expression.\n-- They are used by the `noncomm_ring` tactic, to normalise expressions before passing to `abel`.\ntheorem bit0_mul [NonUnitalNonAssocRing R] {n r : R} : bit0 n * r = «expr • » (2 : ℤ) (n * r) :=\n  by\n  dsimp [bit0]\n  rw [add_mul, add_zsmul, one_zsmul]\n#align bit0_mul bit0_mul\n-/\n\n",
 "apply_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print AddMonoidHom.apply_nat /-\ntheorem AddMonoidHom.apply_nat [add_monoid M] (f : «expr →+ » ℕ M) (n : ℕ) : f n = «expr • » n (f 1) := by\n  rw [← multiplesHom_symm_apply, ← multiplesHom_apply, equiv.apply_symm_apply]\n#align add_monoid_hom.apply_nat AddMonoidHom.apply_nat\n-/\n\n",
 "apply_mnat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidHom.apply_mnat /-\n-- TODO use to_additive in the rest of this file\ntheorem MonoidHom.apply_mnat [monoid M] (f : «expr →* » (Multiplicative ℕ) M) (n : Multiplicative ℕ) :\n    f n = f (Multiplicative.ofAdd 1) ^ n.to_add := by\n  rw [← powersHom_symm_apply, ← powersHom_apply, equiv.apply_symm_apply]\n#align monoid_hom.apply_mnat MonoidHom.apply_mnat\n-/\n\n",
 "apply_mint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidHom.apply_mint /-\ntheorem MonoidHom.apply_mint [group M] (f : «expr →* » (Multiplicative ℤ) M) (n : Multiplicative ℤ) :\n    f n = f (Multiplicative.ofAdd 1) ^ n.to_add := by\n  rw [← zpowersHom_symm_apply, ← zpowersHom_apply, equiv.apply_symm_apply]\n#align monoid_hom.apply_mint MonoidHom.apply_mint\n-/\n\n",
 "apply_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print AddMonoidHom.apply_int /-\ntheorem AddMonoidHom.apply_int [add_group M] (f : «expr →+ » ℤ M) (n : ℤ) : f n = «expr • » n (f 1) := by\n  rw [← zmultiplesHom_symm_apply, ← zmultiplesHom_apply, equiv.apply_symm_apply]\n#align add_monoid_hom.apply_int AddMonoidHom.apply_int\n-/\n\n",
 "abs_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print abs_zsmul /-\ntheorem abs_zsmul (n : ℤ) (a : α) : |«expr • » n a| = «expr • » (|n|) (|a|) :=\n  by\n  obtain n0 | n0 := le_total 0 n\n  · lift n to ℕ using n0\n    simp only [abs_nsmul, abs_coe_nat, coe_nat_zsmul]\n  · lift -n to ℕ using neg_nonneg.2 n0 with m h\n    rw [← abs_neg («expr • » n a), ← neg_zsmul, ← abs_neg n, ← h, coe_nat_zsmul, abs_coe_nat, coe_nat_zsmul]\n    exact abs_nsmul m _\n#align abs_zsmul abs_zsmul\n-/\n\n",
 "abs_pow":
 "#print abs_pow /-\n@[simp]\ntheorem abs_pow (a : R) (n : ℕ) : |a ^ n| = |a| ^ n :=\n  (pow_abs a n).symm\n#align abs_pow abs_pow\n-/\n\n",
 "abs_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print abs_nsmul /-\ntheorem abs_nsmul (n : ℕ) (a : α) : |«expr • » n a| = «expr • » n (|a|) :=\n  by\n  cases' le_total a 0 with hneg hpos\n  · rw [abs_of_nonpos hneg, ← abs_neg, ← neg_nsmul, abs_of_nonneg]\n    exact nsmul_nonneg (neg_nonneg.mpr hneg) n\n  · rw [abs_of_nonneg hpos, abs_of_nonneg]\n    exact nsmul_nonneg hpos n\n#align abs_nsmul abs_nsmul\n-/\n\n",
 "abs_le_self_sq":
 "theorem abs_le_self_sq (a : ℤ) : (Int.natAbs a : ℤ) ≤ a ^ 2 :=\n  by\n  rw [← Int.natAbs_sq a, sq]\n  norm_cast\n  apply Nat.le_mul_self\n#align abs_le_self_sq abs_le_self_sq\n\n",
 "abs_add_eq_add_abs_le":
 "#print abs_add_eq_add_abs_le /-\ntheorem abs_add_eq_add_abs_le (hle : a ≤ b) : |a + b| = |a| + |b| ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0 :=\n  by\n  obtain a0 | a0 := le_or_lt 0 a <;> obtain b0 | b0 := le_or_lt 0 b\n  · simp [a0, b0, abs_of_nonneg, add_nonneg a0 b0]\n  · exact (lt_irrefl (0 : α) <| a0.trans_lt <| hle.trans_lt b0).elim\n  any_goals simp [a0.le, b0.le, abs_of_nonpos, add_nonpos, add_comm]\n  have : (|a + b| = -a + b ↔ b ≤ 0) ↔ (|a + b| = |a| + |b| ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0) := by\n    simp [a0, a0.le, a0.not_le, b0, abs_of_neg, abs_of_nonneg]\n  refine' this.mp ⟨fun h => _, fun h => by simp only [le_antisymm h b0, abs_of_neg a0, add_zero]⟩\n  obtain ab | ab := le_or_lt (a + b) 0\n  · refine' le_of_eq (eq_zero_of_neg_eq _)\n    rwa [abs_of_nonpos ab, neg_add_rev, add_comm, add_right_inj] at h\n  · refine' (lt_irrefl (0 : α) _).elim\n    rw [abs_of_pos ab, add_left_inj] at h\n    rwa [eq_zero_of_neg_eq h.symm] at a0\n#align abs_add_eq_add_abs_le abs_add_eq_add_abs_le\n-/\n\n",
 "abs_add_eq_add_abs_iff":
 "#print abs_add_eq_add_abs_iff /-\ntheorem abs_add_eq_add_abs_iff (a b : α) : |a + b| = |a| + |b| ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0 :=\n  by\n  obtain ab | ab := le_total a b\n  · exact abs_add_eq_add_abs_le ab\n  · rw [add_comm a, add_comm (abs _), abs_add_eq_add_abs_le ab, and_comm, @and_comm (b ≤ 0)]\n#align abs_add_eq_add_abs_iff abs_add_eq_add_abs_iff\n-/\n\n"}