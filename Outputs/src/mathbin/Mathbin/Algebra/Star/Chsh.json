{"tsirelson_inequality_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr√2» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr√2» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr√2» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr√2» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr√2» -/\n-- This calculation, which we need for Tsirelson's bound,\n-- defeated me. Thanks for the rescue from Shing Tak Lam!\ntheorem tsirelson_inequality_aux : «expr√2» * «expr√2» ^ 3 = «expr√2» * (2 * («expr√2»)⁻¹ + 4 * ((«expr√2»)⁻¹ * 2⁻¹)) :=\n  by\n  ring_nf; field_simp [(@real.sqrt_pos 2).2 (by norm_num)]\n  convert congr_arg (· ^ 2) (@real.sq_sqrt 2 (by norm_num)) using 1 <;> simp only [← pow_mul] <;> norm_num\n#align tsirelson_inequality_aux tsirelson_inequality_aux\n\n",
 "tsirelson_inequality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr√2» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr√2» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr√2» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr√2» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr√2» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr√2» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr√2» -/\n/-- In a noncommutative ordered `*`-algebra over ℝ,\nTsirelson's bound for a CHSH tuple (A₀, A₁, B₀, B₁) is\n`A₀ * B₀ + A₀ * B₁ + A₁ * B₀ - A₁ * B₁ ≤ 2^(3/2) • 1`.\n\nWe prove this by providing an explicit sum-of-squares decomposition\nof the difference.\n\n(We could work over `ℤ[2^(1/2), 2^(-1/2)]` if we really wanted to!)\n-/\ntheorem tsirelson_inequality [OrderedRing R] [StarOrderedRing R] [algebra (exprℝ) R] [ordered_smul (exprℝ) R]\n    [StarModule (exprℝ) R] (A₀ A₁ B₀ B₁ : R) (T : is_CHSH_tuple A₀ A₁ B₀ B₁) :\n    A₀ * B₀ + A₀ * B₁ + A₁ * B₀ - A₁ * B₁ ≤ «expr • » («expr√2» ^ 3) 1 :=\n  by\n  -- abel will create `ℤ` multiplication. We will `simp` them away to `ℝ` multiplication.\n  have M : ∀ (m : ℤ) (a : exprℝ) (x : R), «expr • » m («expr • » a x) = «expr • » ((m : exprℝ) * a) x := fun m a x => by\n    rw [zsmul_eq_smul_cast (exprℝ), ← mul_smul]\n  let P := «expr • » («expr√2»)⁻¹ (A₁ + A₀) - B₀\n  let Q := «expr • » («expr√2»)⁻¹ (A₁ - A₀) + B₁\n  have w :\n    «expr • » («expr√2» ^ 3) 1 - A₀ * B₀ - A₀ * B₁ - A₁ * B₀ + A₁ * B₁ = «expr • » («expr√2»)⁻¹ (P ^ 2 + Q ^ 2) :=\n    by\n    dsimp [P, Q]\n    -- distribute out all the powers and products appearing on the RHS\n    simp only [sq, sub_mul, mul_sub, add_mul, mul_add, smul_add, smul_sub]\n    -- pull all coefficients out to the front, and combine `√2`s where possible\n    simp only [algebra.mul_smul_comm, algebra.smul_mul_assoc, ← mul_smul, sqrt_two_inv_mul_self]\n    -- replace Aᵢ * Aᵢ = 1 and Bᵢ * Bᵢ = 1\n    simp only [← sq, T.A₀_inv, T.A₁_inv, T.B₀_inv, T.B₁_inv]\n    -- move Aᵢ to the left of Bᵢ\n    simp only [← T.A₀B₀_commutes, ← T.A₀B₁_commutes, ← T.A₁B₀_commutes, ← T.A₁B₁_commutes]\n    -- collect terms, simplify coefficients, and collect terms again:\n    abel\n    -- all terms coincide, but the last one. Simplify all other terms\n    simp only [M]\n    simp only [neg_mul, Int.cast_bit0, one_mul, mul_inv_cancel_of_invertible, Int.cast_one, one_smul, Int.cast_neg,\n      add_right_inj, neg_smul, ← add_smul]\n    -- just look at the coefficients now:\n    congr\n    exact mul_left_cancel₀ (by norm_num) tsirelson_inequality_aux\n  have pos : 0 ≤ «expr • » («expr√2»)⁻¹ (P ^ 2 + Q ^ 2) :=\n    by\n    have P_sa : star P = P := by\n      dsimp [P]\n      simp only [star_smul, star_add, star_sub, star_id_of_comm, T.A₀_sa, T.A₁_sa, T.B₀_sa, T.B₁_sa]\n    have Q_sa : star Q = Q := by\n      dsimp [Q]\n      simp only [star_smul, star_add, star_sub, star_id_of_comm, T.A₀_sa, T.A₁_sa, T.B₀_sa, T.B₁_sa]\n    have P2_nonneg : 0 ≤ P ^ 2 := by\n      rw [sq]\n      conv =>\n        congr\n        skip\n        congr\n        rw [← P_sa]\n      convert (star_mul_self_nonneg : 0 ≤ star P * P)\n    have Q2_nonneg : 0 ≤ Q ^ 2 := by\n      rw [sq]\n      conv =>\n        congr\n        skip\n        congr\n        rw [← Q_sa]\n      convert (star_mul_self_nonneg : 0 ≤ star Q * Q)\n    convert smul_le_smul_of_nonneg (add_nonneg P2_nonneg Q2_nonneg) (le_of_lt (show 0 < («expr√2»)⁻¹ by norm_num))\n    -- `norm_num` can't directly show `0 ≤ √2⁻¹`\n    simp\n  apply le_of_sub_nonneg\n  simpa only [sub_add_eq_sub_sub, ← sub_add, w] using pos\n#align tsirelson_inequality tsirelson_inequality\n\n",
 "sqrt_two_inv_mul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr√2» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr√2» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem sqrt_two_inv_mul_self : («expr√2»)⁻¹ * («expr√2»)⁻¹ = (2⁻¹ : exprℝ) :=\n  by\n  rw [← mul_inv]\n  norm_num\n#align sqrt_two_inv_mul_self sqrt_two_inv_mul_self\n\n",
 "CHSH_inequality_of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Given a CHSH tuple (A₀, A₁, B₀, B₁) in a *commutative* ordered `*`-algebra over ℝ,\n`A₀ * B₀ + A₀ * B₁ + A₁ * B₀ - A₁ * B₁ ≤ 2`.\n\n(We could work over ℤ[⅟2] if we wanted to!)\n-/\ntheorem CHSH_inequality_of_comm [OrderedCommRing R] [StarOrderedRing R] [algebra (exprℝ) R] [ordered_smul (exprℝ) R]\n    (A₀ A₁ B₀ B₁ : R) (T : is_CHSH_tuple A₀ A₁ B₀ B₁) : A₀ * B₀ + A₀ * B₁ + A₁ * B₀ - A₁ * B₁ ≤ 2 :=\n  by\n  let P := 2 - A₀ * B₀ - A₀ * B₁ - A₁ * B₀ + A₁ * B₁\n  have i₁ : 0 ≤ P := by\n    have idem : P * P = 4 * P := CHSH_id T.A₀_inv T.A₁_inv T.B₀_inv T.B₁_inv\n    have idem' : P = «expr • » (1 / 4 : exprℝ) (P * P) :=\n      by\n      have h : 4 * P = «expr • » (4 : exprℝ) P := by simp [algebra.smul_def]\n      rw [idem, h, ← mul_smul]\n      norm_num\n    have sa : star P = P := by\n      dsimp [P]\n      simp only [star_add, star_sub, star_mul, star_bit0, star_one, T.A₀_sa, T.A₁_sa, T.B₀_sa, T.B₁_sa, mul_comm B₀,\n        mul_comm B₁]\n    rw [idem']\n    conv_rhs =>\n      congr\n      skip\n      congr\n      rw [← sa]\n    convert smul_le_smul_of_nonneg (star_mul_self_nonneg : 0 ≤ star P * P) _\n    · simp\n    · infer_instance\n    · norm_num\n  apply le_of_sub_nonneg\n  simpa only [sub_add_eq_sub_sub, ← sub_add] using i₁\n#align CHSH_inequality_of_comm CHSH_inequality_of_comm\n\n",
 "CHSH_id":
 "/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\ntheorem CHSH_id [CommRing R] {A₀ A₁ B₀ B₁ : R} (A₀_inv : A₀ ^ 2 = 1) (A₁_inv : A₁ ^ 2 = 1) (B₀_inv : B₀ ^ 2 = 1)\n    (B₁_inv : B₁ ^ 2 = 1) :\n    (2 - A₀ * B₀ - A₀ * B₁ - A₁ * B₀ + A₁ * B₁) * (2 - A₀ * B₀ - A₀ * B₁ - A₁ * B₀ + A₁ * B₁) =\n      4 * (2 - A₀ * B₀ - A₀ * B₁ - A₁ * B₀ + A₁ * B₁) :=\n  by\n  -- If we had a Gröbner basis algorithm, this would be trivial.\n  -- Without one, it is somewhat tedious!\n  rw [← sub_eq_zero]\n  repeat'\n    ring_nf\n    simp only [A₁_inv, B₁_inv, sub_eq_add_neg, add_mul, mul_add, sub_mul, mul_sub, add_assoc, neg_add, neg_sub, sub_add,\n      sub_sub, neg_mul, ← sq, A₀_inv, B₀_inv, ← sq, ← mul_assoc, one_mul, mul_one, add_right_neg, add_zero,\n      sub_eq_add_neg, A₀_inv, mul_one, add_right_neg, zero_mul]\n#align CHSH_id CHSH_id\n\n"}