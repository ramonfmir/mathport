{"succ_succ_nth_convergent'_aux_eq_succ_nth_convergent'_aux_squash_seq":
 "/-- The auxiliary function `convergents'_aux` returns the same value for a sequence and the\ncorresponding squashed sequence at the squashed position. -/\ntheorem succ_succ_nth_convergent'_aux_eq_succ_nth_convergent'_aux_squash_seq :\n    convergents'Aux s (n + 2) = convergents'Aux (squashSeq s n) (n + 1) :=\n  by\n  cases' s_succ_nth_eq : s.nth <| n + 1 with gp_succ_n\n  case none =>\n    rw [squash_seq_eq_self_of_terminated s_succ_nth_eq, convergents'_aux_stable_step_of_terminated s_succ_nth_eq]\n  case some =>\n    induction' n with m IH generalizing s gp_succ_n\n    case zero =>\n      obtain ⟨gp_head, s_head_eq⟩ : ∃ gp_head, s.head = some gp_head\n      exact s.ge_stable zero_le_one s_succ_nth_eq\n      have : (squash_seq s 0).head = some ⟨gp_head.a, gp_head.b + gp_succ_n.a / gp_succ_n.b⟩ :=\n        squash_seq_nth_of_not_terminated s_head_eq s_succ_nth_eq\n      simp [*, convergents'_aux, seq.head, seq.nth_tail]\n    case succ =>\n      obtain ⟨gp_head, s_head_eq⟩ : ∃ gp_head, s.head = some gp_head\n      exact s.ge_stable (m + 2).zero_le s_succ_nth_eq\n      suffices\n        gp_head.a / (gp_head.b + convergents'_aux s.tail (m + 2)) = convergents'_aux (squash_seq s (m + 1)) (m + 2) by\n        simpa only [convergents'_aux, s_head_eq]\n      have : convergents'_aux s.tail (m + 2) = convergents'_aux (squash_seq s.tail m) (m + 1) :=\n        by\n        refine' IH gp_succ_n _\n        simpa [seq.nth_tail] using s_succ_nth_eq\n      have : (squash_seq s (m + 1)).head = some gp_head := (squash_seq_nth_of_lt m.succ_pos).trans s_head_eq\n      simp only [*, convergents'_aux, squash_seq_succ_n_tail_eq_squash_seq_tail_n]\n#align succ_succ_nth_convergent'_aux_eq_succ_nth_convergent'_aux_squash_seq succ_succ_nth_convergent'_aux_eq_succ_nth_convergent'_aux_squash_seq\n\n",
 "succ_nth_convergent_eq_squash_gcf_nth_convergent":
 "/-- The convergents coincide in the expected way at the squashed position if the partial denominator\nat the squashed position is not zero. -/\ntheorem succ_nth_convergent_eq_squash_gcf_nth_convergent [Field K]\n    (nth_part_denom_ne_zero : ∀ {b : K}, g.partial_denominators.nth n = some b → b ≠ 0) :\n    g.convergents (n + 1) = (squashGCF g n).convergents n :=\n  by\n  cases' decidable.em (g.terminated_at n) with terminated_at_n not_terminated_at_n\n  · have : squash_gcf g n = g := squash_gcf_eq_self_of_terminated terminated_at_n\n    simp only [this, convergents_stable_of_terminated n.le_succ terminated_at_n]\n  · obtain ⟨⟨a, b⟩, s_nth_eq⟩ : ∃ gp_n, g.s.nth n = some gp_n\n    exact option.ne_none_iff_exists'.mp not_terminated_at_n\n    have b_ne_zero : b ≠ 0 := nth_part_denom_ne_zero (part_denom_eq_s_b s_nth_eq)\n    cases' n with n'\n    case\n      zero =>\n      suffices (b * g.h + a) / b = g.h + a / b by\n        simpa [squash_gcf, s_nth_eq, convergent_eq_conts_a_div_conts_b,\n          continuants_recurrence_aux s_nth_eq zeroth_continuant_aux_eq_one_zero first_continuant_aux_eq_h_one]\n      calc\n        (b * g.h + a) / b = b * g.h / b + a / b := by ring\n        -- requires `field`, not `division_ring`\n            _ =\n            g.h + a / b :=\n          by rw [mul_div_cancel_left _ b_ne_zero]\n        \n    case\n      succ =>\n      obtain ⟨⟨pa, pb⟩, s_n'th_eq⟩ : ∃ gp_n', g.s.nth n' = some gp_n' := g.s.ge_stable n'.le_succ s_nth_eq\n      -- Notations\n      let g' := squash_gcf g (n' + 1)\n      set pred_conts := g.continuants_aux (n' + 1) with succ_n'th_conts_aux_eq\n      set ppred_conts := g.continuants_aux n' with n'th_conts_aux_eq\n      let pA := pred_conts.a\n      let pB := pred_conts.b\n      let ppA := ppred_conts.a\n      let ppB := ppred_conts.b\n      set pred_conts' := g'.continuants_aux (n' + 1) with succ_n'th_conts_aux_eq'\n      set ppred_conts' := g'.continuants_aux n' with n'th_conts_aux_eq'\n      let pA' := pred_conts'.a\n      let pB' := pred_conts'.b\n      let ppA' := ppred_conts'.a\n      let ppB' := ppred_conts'.b\n      -- first compute the convergent of the squashed gcf\n      have : g'.convergents (n' + 1) = ((pb + a / b) * pA' + pa * ppA') / ((pb + a / b) * pB' + pa * ppB') :=\n        by\n        have : g'.s.nth n' = some ⟨pa, pb + a / b⟩ := squash_seq_nth_of_not_terminated s_n'th_eq s_nth_eq\n        rw [convergent_eq_conts_a_div_conts_b,\n          continuants_recurrence_aux this n'th_conts_aux_eq'.symm succ_n'th_conts_aux_eq'.symm]\n      rw [this]\n      -- then compute the convergent of the original gcf by recursively unfolding the continuants\n      -- computation twice\n      have : g.convergents (n' + 2) = (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB) :=\n        by\n        -- use the recurrence once\n        have : g.continuants_aux (n' + 2) = ⟨pb * pA + pa * ppA, pb * pB + pa * ppB⟩ :=\n          continuants_aux_recurrence s_n'th_eq n'th_conts_aux_eq.symm succ_n'th_conts_aux_eq.symm\n        -- and a second time\n        rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux s_nth_eq succ_n'th_conts_aux_eq.symm this]\n      rw [this]\n      suffices\n        ((pb + a / b) * pA + pa * ppA) / ((pb + a / b) * pB + pa * ppB) =\n          (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB)\n        by\n        obtain ⟨eq1, eq2, eq3, eq4⟩ : pA' = pA ∧ pB' = pB ∧ ppA' = ppA ∧ ppB' = ppB := by\n          simp [*, (continuants_aux_eq_continuants_aux_squash_gcf_of_le <| le_refl <| n' + 1).symm,\n            (continuants_aux_eq_continuants_aux_squash_gcf_of_le n'.le_succ).symm]\n        symm\n        simpa only [eq1, eq2, eq3, eq4, mul_div_cancel _ b_ne_zero]\n      field_simp\n      congr 1 <;> ring\n#align succ_nth_convergent_eq_squash_gcf_nth_convergent succ_nth_convergent_eq_squash_gcf_nth_convergent\n\n",
 "succ_nth_convergent'_eq_squash_gcf_nth_convergent'":
 "/-- `convergents'` returns the same value for a gcf and the corresponding squashed gcf at the\nsquashed position. -/\ntheorem succ_nth_convergent'_eq_squash_gcf_nth_convergent' : g.convergents' (n + 1) = (squashGCF g n).convergents' n :=\n  by\n  cases n\n  case zero =>\n    cases g_s_head_eq : g.s.nth 0 <;> simp [g_s_head_eq, squash_gcf, convergents', convergents'_aux, seq.head]\n  case succ =>\n    simp only [succ_succ_nth_convergent'_aux_eq_succ_nth_convergent'_aux_squash_seq, convergents', squash_gcf]\n#align succ_nth_convergent'_eq_squash_gcf_nth_convergent' succ_nth_convergent'_eq_squash_gcf_nth_convergent'\n\n",
 "squash_seq_succ_n_tail_eq_squash_seq_tail_n":
 "/-- Squashing at position `n + 1` and taking the tail is the same as squashing the tail of the\nsequence at position `n`. -/\ntheorem squash_seq_succ_n_tail_eq_squash_seq_tail_n : (squashSeq s (n + 1)).tail = squashSeq s.tail n :=\n  by\n  cases' s_succ_succ_nth_eq : s.nth (n + 2) with gp_succ_succ_n\n  case none =>\n    have : squash_seq s (n + 1) = s := squash_seq_eq_self_of_terminated s_succ_succ_nth_eq\n    cases s_succ_nth_eq : s.nth (n + 1) <;> simp only [squash_seq, seq.nth_tail, s_succ_nth_eq, s_succ_succ_nth_eq]\n  case some =>\n    obtain ⟨gp_succ_n, s_succ_nth_eq⟩ : ∃ gp_succ_n, s.nth (n + 1) = some gp_succ_n;\n    exact s.ge_stable (n + 1).le_succ s_succ_succ_nth_eq\n    -- apply extensionality with `m` and continue by cases `m = n`.\n    ext1 m\n    cases' decidable.em (m = n) with m_eq_n m_ne_n\n    · have : s.tail.nth n = some gp_succ_n := (s.nth_tail n).trans s_succ_nth_eq\n      simp [*, squash_seq]\n    · have : s.tail.nth m = s.nth (m + 1) := s.nth_tail m\n      cases s_succ_mth_eq : s.nth (m + 1)\n      all_goals have s_tail_mth_eq := this.trans s_succ_mth_eq\n      · simp only [*, squash_seq, seq.nth_tail, seq.nth_zip_with, Option.map₂_none_right]\n      · simp [*, squash_seq]\n#align squash_seq_succ_n_tail_eq_squash_seq_tail_n squash_seq_succ_n_tail_eq_squash_seq_tail_n\n\n",
 "squash_seq_nth_of_not_terminated":
 "/-- If the sequence has not terminated before position `n + 1`, the value at `n + 1` gets\nsquashed into position `n`. -/\ntheorem squash_seq_nth_of_not_terminated {gp_n gp_succ_n : Pair K} (s_nth_eq : s.nth n = some gp_n)\n    (s_succ_nth_eq : s.nth (n + 1) = some gp_succ_n) :\n    (squashSeq s n).nth n = some ⟨gp_n.a, gp_n.b + gp_succ_n.a / gp_succ_n.b⟩ := by simp [*, squash_seq]\n#align squash_seq_nth_of_not_terminated squash_seq_nth_of_not_terminated\n\n",
 "squash_seq_nth_of_lt":
 "/-- The values before the squashed position stay the same. -/\ntheorem squash_seq_nth_of_lt {m : ℕ} (m_lt_n : m < n) : (squashSeq s n).nth m = s.nth m :=\n  by\n  cases s_succ_nth_eq : s.nth (n + 1)\n  case none => rw [squash_seq_eq_self_of_terminated s_succ_nth_eq]\n  case some =>\n    obtain ⟨gp_n, s_nth_eq⟩ : ∃ gp_n, s.nth n = some gp_n; exact s.ge_stable n.le_succ s_succ_nth_eq\n    obtain ⟨gp_m, s_mth_eq⟩ : ∃ gp_m, s.nth m = some gp_m; exact s.ge_stable (le_of_lt m_lt_n) s_nth_eq\n    simp [*, squash_seq, m_lt_n.ne]\n#align squash_seq_nth_of_lt squash_seq_nth_of_lt\n\n",
 "squash_seq_eq_self_of_terminated":
 "/-\nCopyright (c) 2020 Kevin Kappelmann. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Kappelmann\n-/\n-- return the squashed value at position `n`; otherwise, do nothing.\n/-- If the sequence already terminated at position `n + 1`, nothing gets squashed. -/\ntheorem squash_seq_eq_self_of_terminated (terminated_at_succ_n : s.terminated_at (n + 1)) : squashSeq s n = s :=\n  by\n  change s.nth (n + 1) = none at terminated_at_succ_n\n  cases s_nth_eq : s.nth n <;> simp only [*, squash_seq]\n#align squash_seq_eq_self_of_terminated squash_seq_eq_self_of_terminated\n\n",
 "squash_gcf_nth_of_lt":
 "/-- The values before the squashed position stay the same. -/\ntheorem squash_gcf_nth_of_lt {m : ℕ} (m_lt_n : m < n) : (squashGCF g (n + 1)).s.nth m = g.s.nth m := by\n  simp only [squash_gcf, squash_seq_nth_of_lt m_lt_n]\n#align squash_gcf_nth_of_lt squash_gcf_nth_of_lt\n\n",
 "squash_gcf_eq_self_of_terminated":
 "/-- If the gcf already terminated at position `n`, nothing gets squashed. -/\ntheorem squash_gcf_eq_self_of_terminated (terminated_at_n : TerminatedAt g n) : squashGCF g n = g :=\n  by\n  cases n\n  case zero =>\n    change g.s.nth 0 = none at terminated_at_n\n    simp only [convergents', squash_gcf, convergents'_aux, terminated_at_n]\n  case succ => cases g; simp [squash_seq_eq_self_of_terminated terminated_at_n, squash_gcf]\n#align squash_gcf_eq_self_of_terminated squash_gcf_eq_self_of_terminated\n\n",
 "convergents_eq_convergents'":
 "/-- Shows that the recurrence relation (`convergents`) and direct evaluation (`convergents'`) of a\n(regular) continued fraction coincide. -/\ntheorem convergents_eq_convergents' [LinearOrderedField K] {c : ContinuedFraction K} :\n    (↑c : GeneralizedContinuedFraction K).convergents = (↑c : GeneralizedContinuedFraction K).convergents' :=\n  by\n  ext n\n  apply convergents_eq_convergents'\n  intro gp m m_lt_n s_nth_eq\n  exact\n    ⟨zero_lt_one.trans_le ((c : SimpleContinuedFraction K).property m gp.a (part_num_eq_s_a s_nth_eq)).symm.le,\n      c.property m gp.b <| part_denom_eq_s_b s_nth_eq⟩\n#align convergents_eq_convergents' convergents_eq_convergents'\n\n",
 "continuants_aux_eq_continuants_aux_squash_gcf_of_le":
 "/-- The auxiliary continuants before the squashed position stay the same. -/\ntheorem continuants_aux_eq_continuants_aux_squash_gcf_of_le {m : ℕ} :\n    m ≤ n → continuantsAux g m = (squashGCF g n).continuants_aux m :=\n  nat.strong_induction_on m\n    (by\n      clear m\n      intro m IH m_le_n\n      cases' m with m'\n      · rfl\n      · cases' n with n'\n        · exact (m'.not_succ_le_zero m_le_n).elim\n        -- 1 ≰ 0\n        · cases' m' with m''\n          · rfl\n          · -- get some inequalities to instantiate the IH for m'' and m'' + 1\n            have m'_lt_n : m'' + 1 < n' + 1 := m_le_n\n            have succ_m''th_conts_aux_eq := IH (m'' + 1) (lt_add_one (m'' + 1)) m'_lt_n.le\n            have : m'' < m'' + 2 := lt_add_of_pos_right m'' zero_lt_two\n            have m''th_conts_aux_eq := IH m'' this (le_trans this.le m_le_n)\n            have : (squash_gcf g (n' + 1)).s.nth m'' = g.s.nth m'' :=\n              squash_gcf_nth_of_lt (nat.succ_lt_succ_iff.mp m'_lt_n)\n            simp [continuants_aux, succ_m''th_conts_aux_eq, m''th_conts_aux_eq, this])\n#align continuants_aux_eq_continuants_aux_squash_gcf_of_le continuants_aux_eq_continuants_aux_squash_gcf_of_le\n\n"}