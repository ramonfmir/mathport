{"terminates_of_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- The continued fraction of a rational number terminates. -/\ntheorem terminates_of_rat (q : exprℚ) : (of q).terminates :=\n  exists.elim (int_fract_pair.exists_nth_stream_eq_none_of_rat q) fun n stream_nth_eq_none =>\n    exists.intro n\n      (have : IntFractPair.stream q (n + 1) = none := IntFractPair.stream_isSeq q stream_nth_eq_none\n      of_terminatedAt_n_iff_succ_nth_intFractPair_stream_eq_none.elim_right this)\n#align terminates_of_rat terminates_of_rat\n\n",
 "terminates_iff_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- The continued fraction `generalized_continued_fraction.of v` terminates if and only if `v ∈ ℚ`.\n-/\ntheorem terminates_iff_rat (v : K) : (of v).terminates ↔ ∃ q : exprℚ, v = (q : K) :=\n  iff.intro\n    (fun terminates_v : (of v).terminates =>\n      show ∃ q : exprℚ, v = (q : K) from exists_rat_eq_of_terminates terminates_v)\n    fun exists_q_eq_v : ∃ q : exprℚ, v = (↑q : K) =>\n    exists.elim exists_q_eq_v fun q => fun v_eq_q : v = ↑q =>\n      have : (of q).terminates := terminates_of_rat q\n      (of_terminates_iff_of_rat_terminates v_eq_q).elim_right this\n#align terminates_iff_rat terminates_iff_rat\n\n",
 "stream_succ_nth_fr_num_lt_nth_fr_num_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- Shows that the sequence of numerators of the fractional parts of the stream is strictly\nantitone. -/\ntheorem stream_succ_nth_fr_num_lt_nth_fr_num_rat {ifp_n ifp_succ_n : IntFractPair (exprℚ)}\n    (stream_nth_eq : IntFractPair.stream q n = some ifp_n)\n    (stream_succ_nth_eq : IntFractPair.stream q (n + 1) = some ifp_succ_n) : ifp_succ_n.fr.num < ifp_n.fr.num :=\n  by\n  obtain ⟨ifp_n', stream_nth_eq', ifp_n_fract_ne_zero, int_fract_pair.of_eq_ifp_succ_n⟩ :\n    ∃ ifp_n', int_fract_pair.stream q n = some ifp_n' ∧ ifp_n'.fr ≠ 0 ∧ int_fract_pair.of ifp_n'.fr⁻¹ = ifp_succ_n\n  exact succ_nth_stream_eq_some_iff.elim_left stream_succ_nth_eq\n  have : ifp_n = ifp_n' := by injection Eq.trans stream_nth_eq.symm stream_nth_eq'\n  cases this\n  rw [← int_fract_pair.of_eq_ifp_succ_n]\n  cases' nth_stream_fr_nonneg_lt_one stream_nth_eq with zero_le_ifp_n_fract ifp_n_fract_lt_one\n  have : 0 < ifp_n.fr := lt_of_le_of_ne zero_le_ifp_n_fract <| ifp_n_fract_ne_zero.symm\n  exact of_inv_fr_num_lt_num_of_pos this\n#align stream_succ_nth_fr_num_lt_nth_fr_num_rat stream_succ_nth_fr_num_lt_nth_fr_num_rat\n\n",
 "stream_nth_fr_num_le_fr_num_sub_n_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem stream_nth_fr_num_le_fr_num_sub_n_rat :\n    ∀ {ifp_n : IntFractPair (exprℚ)},\n      IntFractPair.stream q n = some ifp_n → ifp_n.fr.num ≤ (IntFractPair.of q).fr.num - n :=\n  by\n  induction' n with n IH\n  case zero =>\n    intro ifp_zero stream_zero_eq\n    have : int_fract_pair.of q = ifp_zero := by injection stream_zero_eq\n    simp [le_refl, this.symm]\n  case succ =>\n    intro ifp_succ_n stream_succ_nth_eq\n    suffices ifp_succ_n.fr.num + 1 ≤ (int_fract_pair.of q).fr.num - n\n      by\n      rw [Int.ofNat_succ, sub_add_eq_sub_sub]\n      solve_by_elim [le_sub_right_of_add_le]\n    rcases succ_nth_stream_eq_some_iff.elim_left stream_succ_nth_eq with ⟨ifp_n, stream_nth_eq, -⟩\n    have : ifp_succ_n.fr.num < ifp_n.fr.num := stream_succ_nth_fr_num_lt_nth_fr_num_rat stream_nth_eq stream_succ_nth_eq\n    have : ifp_succ_n.fr.num + 1 ≤ ifp_n.fr.num := int.add_one_le_of_lt this\n    exact le_trans this (IH stream_nth_eq)\n#align stream_nth_fr_num_le_fr_num_sub_n_rat stream_nth_fr_num_le_fr_num_sub_n_rat\n\n",
 "of_terminates_iff_of_rat_terminates":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem of_terminates_iff_of_rat_terminates {v : K} {q : exprℚ} (v_eq_q : v = (q : K)) :\n    (of v).terminates ↔ (of q).terminates := by\n  constructor <;> intro h <;> cases' h with n h <;> use n <;>\n        simp only [seq.terminated_at, (coe_of_s_nth_rat_eq v_eq_q n).symm] at h⊢ <;>\n      cases (of q).s.nth n <;>\n    trivial\n#align of_terminates_iff_of_rat_terminates of_terminates_iff_of_rat_terminates\n\n",
 "of_inv_fr_num_lt_num_of_pos":
 "/-- Shows that for any `q : ℚ` with `0 < q < 1`, the numerator of the fractional part of\n`int_fract_pair.of q⁻¹` is smaller than the numerator of `q`.\n-/\ntheorem of_inv_fr_num_lt_num_of_pos (q_pos : 0 < q) : (IntFractPair.of q⁻¹).fr.num < q.num :=\n  Rat.fract_inv_num_lt_num_of_pos q_pos\n#align of_inv_fr_num_lt_num_of_pos of_inv_fr_num_lt_num_of_pos\n\n",
 "exists_rat_eq_of_terminates":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- Every terminating continued fraction corresponds to a rational number. -/\ntheorem exists_rat_eq_of_terminates (terminates : (of v).terminates) : ∃ q : exprℚ, v = ↑q :=\n  by\n  obtain ⟨n, v_eq_conv⟩ : ∃ n, v = (of v).convergents n\n  exact of_correctness_of_terminates terminates\n  obtain ⟨q, conv_eq_q⟩ : ∃ q : exprℚ, (of v).convergents n = (↑q : K)\n  exact exists_rat_eq_nth_convergent v n\n  have : v = (↑q : K) := Eq.trans v_eq_conv conv_eq_q\n  use q, this\n#align exists_rat_eq_of_terminates exists_rat_eq_of_terminates\n\n",
 "exists_rat_eq_nth_numerator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem exists_rat_eq_nth_numerator : ∃ q : exprℚ, (of v).numerators n = (q : K) :=\n  by\n  rcases exists_gcf_pair_rat_eq_nth_conts v n with ⟨⟨a, _⟩, nth_cont_eq⟩\n  use a\n  simp [num_eq_conts_a, nth_cont_eq]\n#align exists_rat_eq_nth_numerator exists_rat_eq_nth_numerator\n\n",
 "exists_rat_eq_nth_denominator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem exists_rat_eq_nth_denominator : ∃ q : exprℚ, (of v).denominators n = (q : K) :=\n  by\n  rcases exists_gcf_pair_rat_eq_nth_conts v n with ⟨⟨_, b⟩, nth_cont_eq⟩\n  use b\n  simp [denom_eq_conts_b, nth_cont_eq]\n#align exists_rat_eq_nth_denominator exists_rat_eq_nth_denominator\n\n",
 "exists_rat_eq_nth_convergent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem exists_rat_eq_nth_convergent : ∃ q : exprℚ, (of v).convergents n = (q : K) :=\n  by\n  rcases exists_rat_eq_nth_numerator v n with ⟨Aₙ, nth_num_eq⟩\n  rcases exists_rat_eq_nth_denominator v n with ⟨Bₙ, nth_denom_eq⟩\n  use Aₙ / Bₙ\n  simp [nth_num_eq, nth_denom_eq, convergent_eq_num_div_denom]\n#align exists_rat_eq_nth_convergent exists_rat_eq_nth_convergent\n\n",
 "exists_nth_stream_eq_none_of_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem exists_nth_stream_eq_none_of_rat (q : exprℚ) : ∃ n : ℕ, IntFractPair.stream q n = none :=\n  by\n  let fract_q_num := (Int.fract q).num; let n := fract_q_num.nat_abs + 1\n  cases' stream_nth_eq : int_fract_pair.stream q n with ifp\n  · use n\n    exact stream_nth_eq\n  · -- arrive at a contradiction since the numerator decreased num + 1 times but every fractional\n    -- value is nonnegative.\n    have ifp_fr_num_le_q_fr_num_sub_n : ifp.fr.num ≤ fract_q_num - n :=\n      stream_nth_fr_num_le_fr_num_sub_n_rat stream_nth_eq\n    have : fract_q_num - n = -1 :=\n      by\n      have : 0 ≤ fract_q_num := rat.num_nonneg_iff_zero_le.elim_right (Int.fract_nonneg q)\n      simp [Int.natAbs_of_nonneg this, sub_add_eq_sub_sub_swap, sub_right_comm]\n    have : ifp.fr.num ≤ -1 := by rwa [this] at ifp_fr_num_le_q_fr_num_sub_n\n    have : 0 ≤ ifp.fr := (nth_stream_fr_nonneg_lt_one stream_nth_eq).left\n    have : 0 ≤ ifp.fr.num := rat.num_nonneg_iff_zero_le.elim_right this\n    linarith\n#align exists_nth_stream_eq_none_of_rat exists_nth_stream_eq_none_of_rat\n\n",
 "exists_gcf_pair_rat_eq_of_nth_conts_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-\nCopyright (c) 2020 Kevin Kappelmann. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Kappelmann\n-/\n/-\nWe will have to constantly coerce along our structures in the following proofs using their provided\nmap functions.\n-/\ntheorem exists_gcf_pair_rat_eq_of_nth_conts_aux :\n    ∃ conts : Pair (exprℚ), (of v).continuants_aux n = (conts.map coe : Pair K) :=\n  nat.strong_induction_on n\n    (by\n      clear n\n      let g := of v\n      intro n IH\n      rcases n with (_ | _ | n)\n      -- n = 0\n      · suffices ∃ gp : pair (exprℚ), pair.mk (1 : K) 0 = gp.map coe by simpa [continuants_aux]\n        use pair.mk 1 0\n        simp\n      -- n = 1\n      · suffices ∃ conts : pair (exprℚ), pair.mk g.h 1 = conts.map coe by simpa [continuants_aux]\n        use pair.mk («expr⌊ ⌋» v) 1\n        simp\n      -- 2 ≤ n\n      · cases' IH (n + 1) <| lt_add_one (n + 1) with pred_conts pred_conts_eq\n        -- invoke the IH\n        cases' s_ppred_nth_eq : g.s.nth n with gp_n\n        -- option.none\n        · use pred_conts\n          have : g.continuants_aux (n + 2) = g.continuants_aux (n + 1) :=\n            continuants_aux_stable_of_terminated (n + 1).le_succ s_ppred_nth_eq\n          simp only [this, pred_conts_eq]\n        -- option.some\n        · -- invoke the IH a second time\n          cases' IH n <| lt_of_le_of_lt n.le_succ <| lt_add_one <| n + 1 with ppred_conts ppred_conts_eq\n          obtain ⟨a_eq_one, z, b_eq_z⟩ : gp_n.a = 1 ∧ ∃ z : ℤ, gp_n.b = (z : K)\n          exact of_part_num_eq_one_and_exists_int_part_denom_eq s_ppred_nth_eq\n          -- finally, unfold the recurrence to obtain the required rational value.\n          simp only [a_eq_one, b_eq_z, continuants_aux_recurrence s_ppred_nth_eq ppred_conts_eq pred_conts_eq]\n          use next_continuants 1 (z : exprℚ) ppred_conts pred_conts\n          cases ppred_conts\n          cases pred_conts\n          simp [next_continuants, next_numerator, next_denominator])\n#align exists_gcf_pair_rat_eq_of_nth_conts_aux exists_gcf_pair_rat_eq_of_nth_conts_aux\n\n",
 "exists_gcf_pair_rat_eq_nth_conts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem exists_gcf_pair_rat_eq_nth_conts : ∃ conts : Pair (exprℚ), (of v).continuants n = (conts.map coe : Pair K) :=\n  by\n  rw [nth_cont_eq_succ_nth_cont_aux]\n  exact exists_gcf_pair_rat_eq_of_nth_conts_aux v <| n + 1\n#align exists_gcf_pair_rat_eq_nth_conts exists_gcf_pair_rat_eq_nth_conts\n\n",
 "coe_stream_rat_eq":
 "theorem coe_stream_rat_eq :\n    ((IntFractPair.stream q).map (option.map (mapFr coe)) : Stream' <| Option <| IntFractPair K) =\n      IntFractPair.stream v :=\n  by\n  funext n\n  exact int_fract_pair.coe_stream_nth_rat_eq v_eq_q n\n#align coe_stream_rat_eq coe_stream_rat_eq\n\n",
 "coe_stream_nth_rat_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem coe_stream_nth_rat_eq :\n    ((IntFractPair.stream q n).map (mapFr coe) : Option <| IntFractPair K) = IntFractPair.stream v n :=\n  by\n  induction' n with n IH\n  case zero => simp [int_fract_pair.stream, coe_of_rat_eq v_eq_q]\n  case succ =>\n    rw [v_eq_q] at IH\n    cases' stream_q_nth_eq : int_fract_pair.stream q n with ifp_n\n    case none => simp [int_fract_pair.stream, IH.symm, v_eq_q, stream_q_nth_eq]\n    case some =>\n      cases' ifp_n with b fr\n      cases' decidable.em (fr = 0) with fr_zero fr_ne_zero\n      · simp [int_fract_pair.stream, IH.symm, v_eq_q, stream_q_nth_eq, fr_zero]\n      · replace IH : some (int_fract_pair.mk b ↑fr) = int_fract_pair.stream (↑q) n\n        · rwa [stream_q_nth_eq] at IH\n        have : (fr : K)⁻¹ = ((fr⁻¹ : exprℚ) : K) := by norm_cast\n        have coe_of_fr := coe_of_rat_eq this\n        simpa [int_fract_pair.stream, IH.symm, v_eq_q, stream_q_nth_eq, fr_ne_zero]\n#align coe_stream_nth_rat_eq coe_stream_nth_rat_eq\n\n",
 "coe_of_s_rat_eq":
 "theorem coe_of_s_rat_eq : ((of q).s.map (Pair.map coe) : Seq <| Pair K) = (of v).s :=\n  by\n  ext n\n  rw [← coe_of_s_nth_rat_eq v_eq_q]\n  rfl\n#align coe_of_s_rat_eq coe_of_s_rat_eq\n\n",
 "coe_of_s_nth_rat_eq":
 "theorem coe_of_s_nth_rat_eq : (((of q).s.nth n).map (Pair.map coe) : Option <| Pair K) = (of v).s.nth n :=\n  by\n  simp only [of, int_fract_pair.seq1, seq.map_nth, seq.nth_tail]\n  simp only [seq.nth]\n  rw [← int_fract_pair.coe_stream_rat_eq v_eq_q]\n  rcases succ_nth_stream_eq : int_fract_pair.stream q (n + 1) with (_ | ⟨_, _⟩) <;>\n    simp [Stream'.map, Stream'.nth, succ_nth_stream_eq]\n#align coe_of_s_nth_rat_eq coe_of_s_nth_rat_eq\n\n",
 "coe_of_rat_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/-- Given `(v : K), (q : ℚ), and v = q`, we have that `gcf.of q = gcf.of v` -/\ntheorem coe_of_rat_eq : (⟨(of q).h, (of q).s.map (Pair.map coe)⟩ : GeneralizedContinuedFraction K) = of v :=\n  by\n  cases' gcf_v_eq : of v with h s\n  subst v\n  obtain rfl : ↑(«expr⌊ ⌋» ↑q) = h := by injection gcf_v_eq\n  simp [coe_of_h_rat_eq rfl, coe_of_s_rat_eq rfl, gcf_v_eq]\n#align coe_of_rat_eq coe_of_rat_eq\n\n",
 "coe_of_h_rat_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem coe_of_h_rat_eq : (↑((of q).h : exprℚ) : K) = (of v).h :=\n  by\n  unfold of int_fract_pair.seq1\n  rw [← int_fract_pair.coe_of_rat_eq v_eq_q]\n  simp\n#align coe_of_h_rat_eq coe_of_h_rat_eq\n\n"}