{"succ_nth_stream_eq_some_iff":
 "/-- Gives a recurrence to compute the `n + 1`th value of the sequence of integer and fractional\nparts of a value in case of non-termination.\n-/\ntheorem succ_nth_stream_eq_some_iff {ifp_succ_n : IntFractPair K} :\n    IntFractPair.stream v (n + 1) = some ifp_succ_n ↔\n      ∃ ifp_n : IntFractPair K,\n        IntFractPair.stream v n = some ifp_n ∧ ifp_n.fr ≠ 0 ∧ IntFractPair.of ifp_n.fr⁻¹ = ifp_succ_n :=\n  by simp [int_fract_pair.stream, ite_eq_iff]\n#align succ_nth_stream_eq_some_iff succ_nth_stream_eq_some_iff\n\n",
 "succ_nth_stream_eq_none_iff":
 "/-- Gives a recurrence to compute the `n + 1`th value of the sequence of integer and fractional\nparts of a value in case of termination.\n-/\ntheorem succ_nth_stream_eq_none_iff :\n    IntFractPair.stream v (n + 1) = none ↔\n      IntFractPair.stream v n = none ∨ ∃ ifp, IntFractPair.stream v n = some ifp ∧ ifp.fr = 0 :=\n  by\n  rw [int_fract_pair.stream]\n  cases int_fract_pair.stream v n <;> simp [imp_false]\n#align succ_nth_stream_eq_none_iff succ_nth_stream_eq_none_iff\n\n",
 "stream_zero":
 "/-\nCopyright (c) 2020 Kevin Kappelmann. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Kappelmann\n-/\n-- Fix a discrete linear ordered floor field and a value `v`.\ntheorem stream_zero (v : K) : IntFractPair.stream v 0 = some (IntFractPair.of v) :=\n  rfl\n#align stream_zero stream_zero\n\n",
 "stream_succ_of_some":
 "/-- An easier to use version of one direction of\n`generalized_continued_fraction.int_fract_pair.succ_nth_stream_eq_some_iff`.\n-/\ntheorem stream_succ_of_some {p : IntFractPair K} (h : IntFractPair.stream v n = some p) (h' : p.fr ≠ 0) :\n    IntFractPair.stream v (n + 1) = some (IntFractPair.of p.fr⁻¹) :=\n  succ_nth_stream_eq_some_iff.mpr ⟨p, h, h', rfl⟩\n#align stream_succ_of_some stream_succ_of_some\n\n",
 "stream_succ_of_int":
 "/-- The stream of `int_fract_pair`s of an integer stops after the first term.\n-/\ntheorem stream_succ_of_int (a : ℤ) (n : ℕ) : IntFractPair.stream (a : K) (n + 1) = none :=\n  by\n  induction' n with n ih\n  · refine' int_fract_pair.stream_eq_none_of_fr_eq_zero (int_fract_pair.stream_zero (a : K)) _\n    simp only [int_fract_pair.of, Int.fract_intCast]\n  · exact int_fract_pair.succ_nth_stream_eq_none_iff.mpr (or.inl ih)\n#align stream_succ_of_int stream_succ_of_int\n\n",
 "stream_succ":
 "/-- A recurrence relation that expresses the `(n+1)`th term of the stream of `int_fract_pair`s\nof `v` for non-integer `v` in terms of the `n`th term of the stream associated to\nthe inverse of the fractional part of `v`.\n-/\ntheorem stream_succ (h : Int.fract v ≠ 0) (n : ℕ) :\n    IntFractPair.stream v (n + 1) = IntFractPair.stream (Int.fract v)⁻¹ n :=\n  by\n  induction' n with n ih\n  · have H : (int_fract_pair.of v).fr = Int.fract v := rfl\n    rw [stream_zero, stream_succ_of_some (stream_zero v) (ne_of_eq_of_ne H h), H]\n  · cases' eq_or_ne (int_fract_pair.stream (Int.fract v)⁻¹ n) none with hnone hsome\n    · rw [hnone] at ih\n      rw [succ_nth_stream_eq_none_iff.mpr (or.inl hnone), succ_nth_stream_eq_none_iff.mpr (or.inl ih)]\n    · obtain ⟨p, hp⟩ := option.ne_none_iff_exists'.mp hsome\n      rw [hp] at ih\n      cases' eq_or_ne p.fr 0 with hz hnz\n      · rw [stream_eq_none_of_fr_eq_zero hp hz, stream_eq_none_of_fr_eq_zero ih hz]\n      · rw [stream_succ_of_some hp hnz, stream_succ_of_some ih hnz]\n#align stream_succ stream_succ\n\n",
 "stream_eq_none_of_fr_eq_zero":
 "theorem stream_eq_none_of_fr_eq_zero {ifp_n : IntFractPair K} (stream_nth_eq : IntFractPair.stream v n = some ifp_n)\n    (nth_fr_eq_zero : ifp_n.fr = 0) : IntFractPair.stream v (n + 1) = none :=\n  by\n  cases' ifp_n with _ fr\n  change fr = 0 at nth_fr_eq_zero\n  simp [int_fract_pair.stream, stream_nth_eq, nth_fr_eq_zero]\n#align stream_eq_none_of_fr_eq_zero stream_eq_none_of_fr_eq_zero\n\n",
 "seq1_fst_eq_of":
 "/-- The head term of the sequence with head of `v` is just the integer part of `v`. -/\n@[simp]\ntheorem int_fract_pair.seq1_fst_eq_of : (IntFractPair.seq1 v).fst = IntFractPair.of v :=\n  rfl\n#align int_fract_pair.seq1_fst_eq_of int_fract_pair.seq1_fst_eq_of\n\n",
 "of_terminated_at_n_iff_succ_nth_int_fract_pair_stream_eq_none":
 "theorem of_terminated_at_n_iff_succ_nth_int_fract_pair_stream_eq_none :\n    (of v).terminated_at n ↔ IntFractPair.stream v (n + 1) = none := by\n  rw [of_terminated_at_iff_int_fract_pair_seq1_terminated_at, Stream'.Seq.TerminatedAt,\n    int_fract_pair.nth_seq1_eq_succ_nth_stream]\n#align of_terminated_at_n_iff_succ_nth_int_fract_pair_stream_eq_none of_terminated_at_n_iff_succ_nth_int_fract_pair_stream_eq_none\n\n",
 "of_terminated_at_iff_int_fract_pair_seq1_terminated_at":
 "theorem of_terminated_at_iff_int_fract_pair_seq1_terminated_at :\n    (of v).terminated_at n ↔ (IntFractPair.seq1 v).snd.terminated_at n :=\n  Option.map_eq_none\n#align of_terminated_at_iff_int_fract_pair_seq1_terminated_at of_terminated_at_iff_int_fract_pair_seq1_terminated_at\n\n",
 "of_s_tail":
 "/-- This expresses the tail of the coefficient sequence of the `generalized_continued_fraction.of`\nan element `v` of `K` as the coefficient sequence of that of the inverse of the\nfractional part of `v`.\n-/\ntheorem of_s_tail : (of v).s.tail = (of (fract v)⁻¹).s :=\n  Seq.ext fun n => Seq.get?_tail (of v).s n ▸ of_s_succ v n\n#align of_s_tail of_s_tail\n\n",
 "of_s_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/-- Recurrence for the `generalized_continued_fraction.of` an element `v` of `K` in terms of\nthat of the inverse of the fractional part of `v`.\n-/\ntheorem of_s_succ (n : ℕ) : (of v).s.nth (n + 1) = (of (fract v)⁻¹).s.nth n :=\n  by\n  cases' eq_or_ne (fract v) 0 with h h\n  · obtain ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨«expr⌊ ⌋» v, eq_of_sub_eq_zero h⟩\n    rw [fract_int_cast, inv_zero, of_s_of_int, ← cast_zero, of_s_of_int, seq.nth_nil, seq.nth_nil]\n  cases' eq_or_ne ((of (fract v)⁻¹).s.nth n) none with h₁ h₁\n  ·\n    rwa [h₁, ← terminated_at_iff_s_none, of_terminated_at_n_iff_succ_nth_int_fract_pair_stream_eq_none, stream_succ h, ←\n      of_terminated_at_n_iff_succ_nth_int_fract_pair_stream_eq_none, terminated_at_iff_s_none]\n  · obtain ⟨p, hp⟩ := option.ne_none_iff_exists'.mp h₁\n    obtain ⟨p', hp'₁, _⟩ := exists_succ_nth_stream_of_gcf_of_nth_eq_some hp\n    have Hp := nth_of_eq_some_of_succ_nth_int_fract_pair_stream hp'₁\n    rw [← stream_succ h] at hp'₁\n    rw [Hp, nth_of_eq_some_of_succ_nth_int_fract_pair_stream hp'₁]\n#align of_s_succ of_s_succ\n\n",
 "of_s_of_int":
 "/-- If `a` is an integer, then the coefficient sequence of its continued fraction is empty.\n-/\ntheorem of_s_of_int (a : ℤ) : (of (a : K)).s = Seq.nil :=\n  haveI h : ∀ n, (of (a : K)).s.nth n = none := by\n    intro n\n    induction' n with n ih\n    · rw [of_s_head_aux, stream_succ_of_int, option.bind]\n    · exact (of (a : K)).s.prop ih\n  seq.ext fun n => (h n).trans (seq.nth_nil n).symm\n#align of_s_of_int of_s_of_int\n\n",
 "of_s_head_aux":
 "theorem of_s_head_aux (v : K) :\n    (of v).s.nth 0 =\n      (IntFractPair.stream v 1).bind\n        (some ∘ fun p =>\n          { a := 1\n            b := p.b }) :=\n  by\n  rw [of, int_fract_pair.seq1, of._match_1]\n  simp only [seq.map_tail, seq.map, seq.tail, seq.head, seq.nth, Stream'.map]\n  rw [← Stream'.nth_succ, Stream'.nth, option.map]\n#align of_s_head_aux of_s_head_aux\n\n",
 "of_s_head":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/-- This gives the first pair of coefficients of the continued fraction of a non-integer `v`.\n-/\ntheorem of_s_head (h : fract v ≠ 0) : (of v).s.head = some ⟨1, «expr⌊ ⌋» (fract v)⁻¹⟩ :=\n  by\n  change (of v).s.nth 0 = _\n  rw [of_s_head_aux, stream_succ_of_some (stream_zero v) h, option.bind]\n  rfl\n#align of_s_head of_s_head\n\n",
 "of_h_eq_int_fract_pair_seq1_fst_b":
 "theorem of_h_eq_int_fract_pair_seq1_fst_b : (of v).h = (IntFractPair.seq1 v).fst.b :=\n  by\n  cases aux_seq_eq : int_fract_pair.seq1 v\n  simp [of, aux_seq_eq]\n#align of_h_eq_int_fract_pair_seq1_fst_b of_h_eq_int_fract_pair_seq1_fst_b\n\n",
 "of_h_eq_floor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/-- The head term of the gcf of `v` is `⌊v⌋`. -/\n@[simp]\ntheorem of_h_eq_floor : (of v).h = «expr⌊ ⌋» v := by simp [of_h_eq_int_fract_pair_seq1_fst_b, int_fract_pair.of]\n#align of_h_eq_floor of_h_eq_floor\n\n",
 "nth_seq1_eq_succ_nth_stream":
 "theorem int_fract_pair.nth_seq1_eq_succ_nth_stream :\n    (IntFractPair.seq1 v).snd.nth n = (IntFractPair.stream v) (n + 1) :=\n  rfl\n#align int_fract_pair.nth_seq1_eq_succ_nth_stream int_fract_pair.nth_seq1_eq_succ_nth_stream\n\n",
 "nth_of_eq_some_of_succ_nth_int_fract_pair_stream":
 "/-- Shows how the entries of the sequence of the computed continued fraction can be obtained by the\ninteger parts of the stream of integer and fractional parts.\n-/\ntheorem nth_of_eq_some_of_succ_nth_int_fract_pair_stream {ifp_succ_n : IntFractPair K}\n    (stream_succ_nth_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n) : (of v).s.nth n = some ⟨1, ifp_succ_n.b⟩ :=\n  by\n  unfold of int_fract_pair.seq1\n  rw [seq.map_tail, seq.nth_tail, seq.map_nth]\n  simp [seq.nth, stream_succ_nth_eq]\n#align nth_of_eq_some_of_succ_nth_int_fract_pair_stream nth_of_eq_some_of_succ_nth_int_fract_pair_stream\n\n",
 "nth_of_eq_some_of_nth_int_fract_pair_stream_fr_ne_zero":
 "/-- Shows how the entries of the sequence of the computed continued fraction can be obtained by the\nfractional parts of the stream of integer and fractional parts.\n-/\ntheorem nth_of_eq_some_of_nth_int_fract_pair_stream_fr_ne_zero {ifp_n : IntFractPair K}\n    (stream_nth_eq : IntFractPair.stream v n = some ifp_n) (nth_fr_ne_zero : ifp_n.fr ≠ 0) :\n    (of v).s.nth n = some ⟨1, (IntFractPair.of ifp_n.fr⁻¹).b⟩ :=\n  have : IntFractPair.stream v (n + 1) = some (IntFractPair.of ifp_n.fr⁻¹) :=\n    by\n    cases ifp_n\n    simp [int_fract_pair.stream, stream_nth_eq, nth_fr_ne_zero]\n  get?_of_eq_some_of_succ_get?_intFractPair_stream this\n#align nth_of_eq_some_of_nth_int_fract_pair_stream_fr_ne_zero nth_of_eq_some_of_nth_int_fract_pair_stream_fr_ne_zero\n\n",
 "exists_succ_nth_stream_of_gcf_of_nth_eq_some":
 "theorem int_fract_pair.exists_succ_nth_stream_of_gcf_of_nth_eq_some {gp_n : Pair K}\n    (s_nth_eq : (of v).s.nth n = some gp_n) :\n    ∃ ifp : IntFractPair K, IntFractPair.stream v (n + 1) = some ifp ∧ (ifp.b : K) = gp_n.b :=\n  by\n  obtain ⟨ifp, stream_succ_nth_eq, gp_n_eq⟩ :\n    ∃ ifp, int_fract_pair.stream v (n + 1) = some ifp ∧ pair.mk 1 (ifp.b : K) = gp_n :=\n    by\n    unfold of int_fract_pair.seq1 at s_nth_eq\n    rwa [seq.map_tail, seq.nth_tail, seq.map_nth, Option.map_eq_some'] at s_nth_eq\n  cases gp_n_eq\n  injection gp_n_eq with _ ifp_b_eq_gp_n_b\n  exists ifp\n  exact ⟨stream_succ_nth_eq, ifp_b_eq_gp_n_b⟩\n#align int_fract_pair.exists_succ_nth_stream_of_gcf_of_nth_eq_some int_fract_pair.exists_succ_nth_stream_of_gcf_of_nth_eq_some\n\n",
 "exists_succ_nth_stream_of_fr_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\ntheorem exists_succ_nth_stream_of_fr_zero {ifp_succ_n : IntFractPair K}\n    (stream_succ_nth_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n) (succ_nth_fr_eq_zero : ifp_succ_n.fr = 0) :\n    ∃ ifp_n : IntFractPair K, IntFractPair.stream v n = some ifp_n ∧ ifp_n.fr⁻¹ = «expr⌊ ⌋» ifp_n.fr⁻¹ :=\n  by\n  -- get the witness from `succ_nth_stream_eq_some_iff` and prove that it has the additional\n  -- properties\n  rcases succ_nth_stream_eq_some_iff.mp stream_succ_nth_eq with ⟨ifp_n, seq_nth_eq, nth_fr_ne_zero, rfl⟩\n  refine' ⟨ifp_n, seq_nth_eq, _⟩\n  simpa only [int_fract_pair.of, Int.fract, sub_eq_zero] using succ_nth_fr_eq_zero\n#align exists_succ_nth_stream_of_fr_zero exists_succ_nth_stream_of_fr_zero\n\n",
 "convergents'_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/-- The recurrence relation for the `convergents'` of the continued fraction expansion\nof an element `v` of `K` in terms of the convergents of the inverse of its fractional part.\n-/\ntheorem convergents'_succ : (of v).convergents' (n + 1) = «expr⌊ ⌋» v + 1 / (of (fract v)⁻¹).convergents' n :=\n  by\n  cases' eq_or_ne (fract v) 0 with h h\n  · obtain ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨«expr⌊ ⌋» v, eq_of_sub_eq_zero h⟩\n    rw [convergents'_of_int, fract_int_cast, inv_zero, ← cast_zero, convergents'_of_int, cast_zero, div_zero, add_zero,\n      floor_int_cast]\n  · rw [convergents', of_h_eq_floor, add_right_inj, convergents'_aux_succ_some (of_s_head h)]\n    exact congr_arg ((· / ·) 1) (by rw [convergents', of_h_eq_floor, add_right_inj, of_s_tail])\n#align convergents'_succ convergents'_succ\n\n",
 "convergents'_of_int":
 "/-- If `a` is an integer, then the `convergents'` of its continued fraction expansion\nare all equal to `a`.\n-/\ntheorem convergents'_of_int (a : ℤ) : (of (a : K)).convergents' n = a :=\n  by\n  induction' n with n ih\n  · simp only [zeroth_convergent'_eq_h, of_h_eq_floor, floor_int_cast]\n  · rw [convergents', of_h_eq_floor, floor_int_cast, add_right_eq_self]\n    exact convergents'_aux_succ_none ((of_s_of_int K a).symm ▸ seq.nth_nil 0) _\n#align convergents'_of_int convergents'_of_int\n\n"}