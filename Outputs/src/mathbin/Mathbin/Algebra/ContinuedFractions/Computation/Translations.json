{"succ_nth_stream_eq_some_iff":
 "/-- Gives a recurrence to compute the `n + 1`th value of the sequence of integer and fractional\nparts of a value in case of non-termination.\n-/\ntheorem succ_nth_stream_eq_some_iff {ifp_succ_n : int_fract_pair K} :\n    int_fract_pair.stream v (n + 1) = some ifp_succ_n ↔\n      ∃ ifp_n : int_fract_pair K,\n        int_fract_pair.stream v n = some ifp_n ∧ ifp_n.fr ≠ 0 ∧ int_fract_pair.of ifp_n.fr⁻¹ = ifp_succ_n :=\n  by simp [int_fract_pair.stream, ite_eq_iff]\n#align succ_nth_stream_eq_some_iff succ_nth_stream_eq_some_iff\n\n",
 "succ_nth_stream_eq_none_iff":
 "/-- Gives a recurrence to compute the `n + 1`th value of the sequence of integer and fractional\nparts of a value in case of termination.\n-/\ntheorem succ_nth_stream_eq_none_iff :\n    int_fract_pair.stream v (n + 1) = none ↔\n      int_fract_pair.stream v n = none ∨ ∃ ifp, int_fract_pair.stream v n = some ifp ∧ ifp.fr = 0 :=\n  by\n  rw [int_fract_pair.stream]\n  cases int_fract_pair.stream v n <;> simp [imp_false]\n#align succ_nth_stream_eq_none_iff succ_nth_stream_eq_none_iff\n\n",
 "stream_eq_none_of_fr_eq_zero":
 "/-\nCopyright (c) 2020 Kevin Kappelmann. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Kappelmann\n-/\n-- Fix a discrete linear ordered floor field and a value `v`.\ntheorem stream_eq_none_of_fr_eq_zero {ifp_n : int_fract_pair K} (stream_nth_eq : int_fract_pair.stream v n = some ifp_n)\n    (nth_fr_eq_zero : ifp_n.fr = 0) : int_fract_pair.stream v (n + 1) = none :=\n  by\n  cases' ifp_n with _ fr\n  change fr = 0 at nth_fr_eq_zero\n  simp [int_fract_pair.stream, stream_nth_eq, nth_fr_eq_zero]\n#align stream_eq_none_of_fr_eq_zero stream_eq_none_of_fr_eq_zero\n\n",
 "seq1_fst_eq_of":
 "/-- The head term of the sequence with head of `v` is just the integer part of `v`. -/\n@[simp]\ntheorem int_fract_pair.seq1_fst_eq_of : (int_fract_pair.seq1 v).fst = int_fract_pair.of v :=\n  rfl\n#align int_fract_pair.seq1_fst_eq_of int_fract_pair.seq1_fst_eq_of\n\n",
 "of_terminated_at_n_iff_succ_nth_int_fract_pair_stream_eq_none":
 "theorem of_terminated_at_n_iff_succ_nth_int_fract_pair_stream_eq_none :\n    (of v).terminated_at n ↔ int_fract_pair.stream v (n + 1) = none := by\n  rw [of_terminated_at_iff_int_fract_pair_seq1_terminated_at, seq.terminated_at,\n    int_fract_pair.nth_seq1_eq_succ_nth_stream]\n#align\n  of_terminated_at_n_iff_succ_nth_int_fract_pair_stream_eq_none of_terminated_at_n_iff_succ_nth_int_fract_pair_stream_eq_none\n\n",
 "of_terminated_at_iff_int_fract_pair_seq1_terminated_at":
 "theorem of_terminated_at_iff_int_fract_pair_seq1_terminated_at :\n    (of v).terminated_at n ↔ (int_fract_pair.seq1 v).snd.terminated_at n :=\n  option.map_eq_none\n#align of_terminated_at_iff_int_fract_pair_seq1_terminated_at of_terminated_at_iff_int_fract_pair_seq1_terminated_at\n\n",
 "of_h_eq_int_fract_pair_seq1_fst_b":
 "theorem of_h_eq_int_fract_pair_seq1_fst_b : (of v).h = (int_fract_pair.seq1 v).fst.b :=\n  by\n  cases aux_seq_eq : int_fract_pair.seq1 v\n  simp [of, aux_seq_eq]\n#align of_h_eq_int_fract_pair_seq1_fst_b of_h_eq_int_fract_pair_seq1_fst_b\n\n",
 "of_h_eq_floor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/-- The head term of the gcf of `v` is `⌊v⌋`. -/\n@[simp]\ntheorem of_h_eq_floor : (of v).h = «expr⌊ ⌋» v := by simp [of_h_eq_int_fract_pair_seq1_fst_b, int_fract_pair.of]\n#align of_h_eq_floor of_h_eq_floor\n\n",
 "nth_seq1_eq_succ_nth_stream":
 "theorem int_fract_pair.nth_seq1_eq_succ_nth_stream :\n    (int_fract_pair.seq1 v).snd.nth n = (int_fract_pair.stream v) (n + 1) :=\n  rfl\n#align int_fract_pair.nth_seq1_eq_succ_nth_stream int_fract_pair.nth_seq1_eq_succ_nth_stream\n\n",
 "nth_of_eq_some_of_succ_nth_int_fract_pair_stream":
 "/-- Shows how the entries of the sequence of the computed continued fraction can be obtained by the\ninteger parts of the stream of integer and fractional parts.\n-/\ntheorem nth_of_eq_some_of_succ_nth_int_fract_pair_stream {ifp_succ_n : int_fract_pair K}\n    (stream_succ_nth_eq : int_fract_pair.stream v (n + 1) = some ifp_succ_n) :\n    (of v).s.nth n = some ⟨1, ifp_succ_n.b⟩ :=\n  by\n  unfold of int_fract_pair.seq1\n  rw [seq.map_tail, seq.nth_tail, seq.map_nth]\n  simp [seq.nth, stream_succ_nth_eq]\n#align nth_of_eq_some_of_succ_nth_int_fract_pair_stream nth_of_eq_some_of_succ_nth_int_fract_pair_stream\n\n",
 "nth_of_eq_some_of_nth_int_fract_pair_stream_fr_ne_zero":
 "/-- Shows how the entries of the sequence of the computed continued fraction can be obtained by the\nfractional parts of the stream of integer and fractional parts.\n-/\ntheorem nth_of_eq_some_of_nth_int_fract_pair_stream_fr_ne_zero {ifp_n : int_fract_pair K}\n    (stream_nth_eq : int_fract_pair.stream v n = some ifp_n) (nth_fr_ne_zero : ifp_n.fr ≠ 0) :\n    (of v).s.nth n = some ⟨1, (int_fract_pair.of ifp_n.fr⁻¹).b⟩ :=\n  have : int_fract_pair.stream v (n + 1) = some (int_fract_pair.of ifp_n.fr⁻¹) :=\n    by\n    cases ifp_n\n    simp [int_fract_pair.stream, stream_nth_eq, nth_fr_ne_zero]\n  nth_of_eq_some_of_succ_nth_int_fract_pair_stream this\n#align nth_of_eq_some_of_nth_int_fract_pair_stream_fr_ne_zero nth_of_eq_some_of_nth_int_fract_pair_stream_fr_ne_zero\n\n",
 "exists_succ_nth_stream_of_gcf_of_nth_eq_some":
 "/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `int_fract_pair.exists_succ_nth_stream_of_gcf_of_nth_eq_some [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`gp_n] [\":\" (Term.app `pair [`K])] \"}\")\n        (Term.explicitBinder\n         \"(\"\n         [`s_nth_eq]\n         [\":\"\n          («term_=_»\n           (Term.app (Term.proj (Term.proj (Term.app `of [`v]) \".\" `s) \".\" `nth) [`n])\n           \"=\"\n           (Term.app `some [`gp_n]))]\n         []\n         \")\")]\n       (Term.typeSpec\n        \":\"\n        («term∃_,_»\n         \"∃\"\n         (Lean.explicitBinders\n          (Lean.unbracketedExplicitBinders [(Lean.binderIdent `ifp)] [\":\" (Term.app `int_fract_pair [`K])]))\n         \",\"\n         («term_∧_»\n          («term_=_» (Term.app `int_fract_pair.stream [`v («term_+_» `n \"+\" (num \"1\"))]) \"=\" (Term.app `some [`ifp]))\n          \"∧\"\n          («term_=_» (Term.typeAscription \"(\" (Term.proj `ifp \".\" `b) \":\" [`K] \")\") \"=\" (Term.proj `gp_n \".\" `b))))))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Std.Tactic.obtain\n            \"obtain\"\n            [(Std.Tactic.RCases.rcasesPatMed\n              [(Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ifp)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `stream_succ_nth_eq)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `gp_n_eq)])\n                  [])]\n                \"⟩\")])]\n            [\":\"\n             («term∃_,_»\n              \"∃\"\n              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `ifp)] []))\n              \",\"\n              («term_∧_»\n               («term_=_»\n                (Term.app `int_fract_pair.stream [`v («term_+_» `n \"+\" (num \"1\"))])\n                \"=\"\n                (Term.app `some [`ifp]))\n               \"∧\"\n               («term_=_»\n                (Term.app `pair.mk [(num \"1\") (Term.typeAscription \"(\" (Term.proj `ifp \".\" `b) \":\" [`K] \")\")])\n                \"=\"\n                `gp_n)))]\n            [\":=\"\n             [(Term.byTactic\n               \"by\"\n               (Tactic.tacticSeq\n                (Tactic.tacticSeq1Indented\n                 [(Tactic.unfold\n                   \"unfold\"\n                   [`of `int_fract_pair.seq1]\n                   [(Tactic.location \"at\" (Tactic.locationHyp [`s_nth_eq] []))])\n                  []\n                  (Std.Tactic.tacticRwa__\n                   \"rwa\"\n                   (Tactic.rwRuleSeq\n                    \"[\"\n                    [(Tactic.rwRule [] `seq.map_tail)\n                     \",\"\n                     (Tactic.rwRule [] `seq.nth_tail)\n                     \",\"\n                     (Tactic.rwRule [] `seq.map_nth)\n                     \",\"\n                     (Tactic.rwRule [] `option.map_eq_some')]\n                    \"]\")\n                   [(Tactic.location \"at\" (Tactic.locationHyp [`s_nth_eq] []))])])))]])\n           []\n           (Tactic.cases \"cases\" [(Tactic.casesTarget [] `gp_n_eq)] [] [])\n           []\n           (Tactic.injection \"injection\" `gp_n_eq [\"with\" [\"_\" `ifp_b_eq_gp_n_b]])\n           []\n           (Tactic.«tacticExists_,,» \"exists\" [`ifp])\n           []\n           (Tactic.exact \"exact\" (Term.anonymousCtor \"⟨\" [`stream_succ_nth_eq \",\" `ifp_b_eq_gp_n_b] \"⟩\"))])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Std.Tactic.obtain\n           \"obtain\"\n           [(Std.Tactic.RCases.rcasesPatMed\n             [(Std.Tactic.RCases.rcasesPat.tuple\n               \"⟨\"\n               [(Std.Tactic.RCases.rcasesPatLo\n                 (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ifp)])\n                 [])\n                \",\"\n                (Std.Tactic.RCases.rcasesPatLo\n                 (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `stream_succ_nth_eq)])\n                 [])\n                \",\"\n                (Std.Tactic.RCases.rcasesPatLo\n                 (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `gp_n_eq)])\n                 [])]\n               \"⟩\")])]\n           [\":\"\n            («term∃_,_»\n             \"∃\"\n             (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `ifp)] []))\n             \",\"\n             («term_∧_»\n              («term_=_»\n               (Term.app `int_fract_pair.stream [`v («term_+_» `n \"+\" (num \"1\"))])\n               \"=\"\n               (Term.app `some [`ifp]))\n              \"∧\"\n              («term_=_»\n               (Term.app `pair.mk [(num \"1\") (Term.typeAscription \"(\" (Term.proj `ifp \".\" `b) \":\" [`K] \")\")])\n               \"=\"\n               `gp_n)))]\n           [\":=\"\n            [(Term.byTactic\n              \"by\"\n              (Tactic.tacticSeq\n               (Tactic.tacticSeq1Indented\n                [(Tactic.unfold\n                  \"unfold\"\n                  [`of `int_fract_pair.seq1]\n                  [(Tactic.location \"at\" (Tactic.locationHyp [`s_nth_eq] []))])\n                 []\n                 (Std.Tactic.tacticRwa__\n                  \"rwa\"\n                  (Tactic.rwRuleSeq\n                   \"[\"\n                   [(Tactic.rwRule [] `seq.map_tail)\n                    \",\"\n                    (Tactic.rwRule [] `seq.nth_tail)\n                    \",\"\n                    (Tactic.rwRule [] `seq.map_nth)\n                    \",\"\n                    (Tactic.rwRule [] `option.map_eq_some')]\n                   \"]\")\n                  [(Tactic.location \"at\" (Tactic.locationHyp [`s_nth_eq] []))])])))]])\n          []\n          (Tactic.cases \"cases\" [(Tactic.casesTarget [] `gp_n_eq)] [] [])\n          []\n          (Tactic.injection \"injection\" `gp_n_eq [\"with\" [\"_\" `ifp_b_eq_gp_n_b]])\n          []\n          (Tactic.«tacticExists_,,» \"exists\" [`ifp])\n          []\n          (Tactic.exact \"exact\" (Term.anonymousCtor \"⟨\" [`stream_succ_nth_eq \",\" `ifp_b_eq_gp_n_b] \"⟩\"))])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.anonymousCtor \"⟨\" [`stream_succ_nth_eq \",\" `ifp_b_eq_gp_n_b] \"⟩\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor \"⟨\" [`stream_succ_nth_eq \",\" `ifp_b_eq_gp_n_b] \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `ifp_b_eq_gp_n_b\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `stream_succ_nth_eq\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.«tacticExists_,,» \"exists\" [`ifp])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `ifp\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.injection \"injection\" `gp_n_eq [\"with\" [\"_\" `ifp_b_eq_gp_n_b]])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '_', expected 'ident'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '_', expected 'Lean.Parser.Term.hole'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  int_fract_pair.exists_succ_nth_stream_of_gcf_of_nth_eq_some\n  { gp_n : pair K } ( s_nth_eq : of v . s . nth n = some gp_n )\n    : ∃ ifp : int_fract_pair K , int_fract_pair.stream v n + 1 = some ifp ∧ ( ifp . b : K ) = gp_n . b\n  :=\n    by\n      obtain\n          ⟨ ifp , stream_succ_nth_eq , gp_n_eq ⟩\n          : ∃ ifp , int_fract_pair.stream v n + 1 = some ifp ∧ pair.mk 1 ( ifp . b : K ) = gp_n\n          :=\n            by\n              unfold of int_fract_pair.seq1 at s_nth_eq\n                rwa [ seq.map_tail , seq.nth_tail , seq.map_nth , option.map_eq_some' ] at s_nth_eq\n        cases gp_n_eq\n        injection gp_n_eq with _ ifp_b_eq_gp_n_b\n        exists ifp\n        exact ⟨ stream_succ_nth_eq , ifp_b_eq_gp_n_b ⟩\n#align\n  int_fract_pair.exists_succ_nth_stream_of_gcf_of_nth_eq_some int_fract_pair.exists_succ_nth_stream_of_gcf_of_nth_eq_some\n\n",
 "exists_succ_nth_stream_of_fr_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\ntheorem exists_succ_nth_stream_of_fr_zero {ifp_succ_n : int_fract_pair K}\n    (stream_succ_nth_eq : int_fract_pair.stream v (n + 1) = some ifp_succ_n) (succ_nth_fr_eq_zero : ifp_succ_n.fr = 0) :\n    ∃ ifp_n : int_fract_pair K, int_fract_pair.stream v n = some ifp_n ∧ ifp_n.fr⁻¹ = «expr⌊ ⌋» ifp_n.fr⁻¹ :=\n  by\n  -- get the witness from `succ_nth_stream_eq_some_iff` and prove that it has the additional\n  -- properties\n  rcases succ_nth_stream_eq_some_iff.mp stream_succ_nth_eq with ⟨ifp_n, seq_nth_eq, nth_fr_ne_zero, rfl⟩\n  refine' ⟨ifp_n, seq_nth_eq, _⟩\n  simpa only [int_fract_pair.of, Int.fract, sub_eq_zero] using succ_nth_fr_eq_zero\n#align exists_succ_nth_stream_of_fr_zero exists_succ_nth_stream_of_fr_zero\n\n"}