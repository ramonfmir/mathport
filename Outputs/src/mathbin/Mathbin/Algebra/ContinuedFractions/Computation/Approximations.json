{"zero_le_of_denom":
 "/-- Shows that all denominators are nonnegative. -/\ntheorem zero_le_of_denom : 0 ≤ (of v).denominators n :=\n  by\n  rw [denom_eq_conts_b, nth_cont_eq_succ_nth_cont_aux]\n  exact zero_le_of_continuants_aux_b\n#align zero_le_of_denom zero_le_of_denom\n\n",
 "zero_le_of_continuants_aux_b":
 "theorem zero_le_of_continuants_aux_b : 0 ≤ ((of v).continuants_aux n).b :=\n  by\n  let g := of v\n  induction' n with n IH\n  case zero => rfl\n  case succ =>\n    cases' decidable.em <| g.terminated_at (n - 1) with terminated not_terminated\n    · cases n\n      -- terminating case\n      · simp [zero_le_one]\n      · have : g.continuants_aux (n + 2) = g.continuants_aux (n + 1) :=\n          continuants_aux_stable_step_of_terminated terminated\n        simp only [this, IH]\n    ·\n      calc\n        -- non-terminating case\n            (0 : K) ≤\n            fib (n + 1) :=\n          by exact_mod_cast (n + 1).fib.zero_le\n        _ ≤ ((of v).continuants_aux (n + 1)).b := fib_le_of_continuants_aux_b (or.inr not_terminated)\n        \n#align zero_le_of_continuants_aux_b zero_le_of_continuants_aux_b\n\n",
 "succ_nth_stream_b_le_nth_stream_fr_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/-- Shows that the `n + 1`th integer part `bₙ₊₁` of the stream is smaller or equal than the inverse of\nthe `n`th fractional part `frₙ` of the stream.\nThis result is straight-forward as `bₙ₊₁` is defined as the floor of `1 / frₙ`\n-/\ntheorem succ_nth_stream_b_le_nth_stream_fr_inv {ifp_n ifp_succ_n : IntFractPair K}\n    (nth_stream_eq : IntFractPair.stream v n = some ifp_n)\n    (succ_nth_stream_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n) : (ifp_succ_n.b : K) ≤ ifp_n.fr⁻¹ :=\n  by\n  suffices («expr⌊ ⌋» ifp_n.fr⁻¹ : K) ≤ ifp_n.fr⁻¹\n    by\n    cases' ifp_n with _ ifp_n_fr\n    have : ifp_n_fr ≠ 0 := by\n      intro h\n      simpa [h, int_fract_pair.stream, nth_stream_eq] using succ_nth_stream_eq\n    have : int_fract_pair.of ifp_n_fr⁻¹ = ifp_succ_n := by\n      simpa [this, int_fract_pair.stream, nth_stream_eq, Option.coe_def] using succ_nth_stream_eq\n    rwa [← this]\n  exact floor_le ifp_n.fr⁻¹\n#align succ_nth_stream_b_le_nth_stream_fr_inv succ_nth_stream_b_le_nth_stream_fr_inv\n\n",
 "succ_nth_fib_le_of_nth_denom":
 "/-- Shows that the `n`th denominator is greater than or equal to the `n + 1`th fibonacci number,\nthat is `nat.fib (n + 1) ≤ Bₙ`. -/\ntheorem succ_nth_fib_le_of_nth_denom (hyp : n = 0 ∨ ¬(of v).terminated_at (n - 1)) :\n    (fib (n + 1) : K) ≤ (of v).denominators n :=\n  by\n  rw [denom_eq_conts_b, nth_cont_eq_succ_nth_cont_aux]\n  have : n + 1 ≤ 1 ∨ ¬(of v).terminated_at (n - 1) := by\n    cases n\n    case zero => exact or.inl <| le_refl 1\n    case succ => exact or.inr (or.resolve_left hyp n.succ_ne_zero)\n  exact fib_le_of_continuants_aux_b this\n#align succ_nth_fib_le_of_nth_denom succ_nth_fib_le_of_nth_denom\n\n",
 "sub_convergents_eq":
 "/-- This lemma follows from the finite correctness proof, the determinant equality, and\nby simplifying the difference. -/\ntheorem sub_convergents_eq {ifp : IntFractPair K} (stream_nth_eq : IntFractPair.stream v n = some ifp) :\n    let g := of v\n    let B := (g.continuants_aux (n + 1)).b\n    let pB := (g.continuants_aux n).b\n    v - g.convergents n = if ifp.fr = 0 then 0 else (-1) ^ n / (B * (ifp.fr⁻¹ * B + pB)) :=\n  by\n  -- set up some shorthand notation\n  let g := of v\n  let conts := g.continuants_aux (n + 1)\n  let pred_conts := g.continuants_aux n\n  have g_finite_correctness : v = GeneralizedContinuedFraction.compExactValue pred_conts conts ifp.fr :=\n    comp_exact_value_correctness_of_stream_eq_some stream_nth_eq\n  cases' decidable.em (ifp.fr = 0) with ifp_fr_eq_zero ifp_fr_ne_zero\n  · suffices v - g.convergents n = 0 by simpa [ifp_fr_eq_zero]\n    replace g_finite_correctness : v = g.convergents n\n    · simpa [GeneralizedContinuedFraction.compExactValue, ifp_fr_eq_zero] using g_finite_correctness\n    exact sub_eq_zero.elim_right g_finite_correctness\n  · -- more shorthand notation\n    let A := conts.a\n    let B := conts.b\n    let pA := pred_conts.a\n    let pB := pred_conts.b\n    -- first, let's simplify the goal as `ifp.fr ≠ 0`\n    suffices v - A / B = (-1) ^ n / (B * (ifp.fr⁻¹ * B + pB)) by simpa [ifp_fr_ne_zero]\n    -- now we can unfold `g.comp_exact_value` to derive the following equality for `v`\n    replace g_finite_correctness : v = (pA + ifp.fr⁻¹ * A) / (pB + ifp.fr⁻¹ * B)\n    ·\n      simpa [GeneralizedContinuedFraction.compExactValue, ifp_fr_ne_zero, next_continuants, next_numerator,\n        next_denominator, add_comm] using g_finite_correctness\n    -- let's rewrite this equality for `v` in our goal\n    suffices (pA + ifp.fr⁻¹ * A) / (pB + ifp.fr⁻¹ * B) - A / B = (-1) ^ n / (B * (ifp.fr⁻¹ * B + pB)) by\n      rwa [g_finite_correctness]\n    -- To continue, we need use the determinant equality. So let's derive the needed hypothesis.\n    have n_eq_zero_or_not_terminated_at_pred_n : n = 0 ∨ ¬g.terminated_at (n - 1) :=\n      by\n      cases' n with n'\n      · simp\n      · have : int_fract_pair.stream v (n' + 1) ≠ none := by simp [stream_nth_eq]\n        have : ¬g.terminated_at n' :=\n          (not_congr of_terminated_at_n_iff_succ_nth_int_fract_pair_stream_eq_none).elim_right this\n        exact or.inr this\n    have determinant_eq : pA * B - pB * A = (-1) ^ n := determinant_aux n_eq_zero_or_not_terminated_at_pred_n\n    -- now all we got to do is to rewrite this equality in our goal and re-arrange terms;\n    -- however, for this, we first have to derive quite a few tedious inequalities.\n    have pB_ineq : (fib n : K) ≤ pB :=\n      haveI : n ≤ 1 ∨ ¬g.terminated_at (n - 2) :=\n        by\n        cases' n_eq_zero_or_not_terminated_at_pred_n with n_eq_zero not_terminated_at_pred_n\n        · simp [n_eq_zero]\n        · exact or.inr <| mt (terminated_stable (n - 1).pred_le) not_terminated_at_pred_n\n      fib_le_of_continuants_aux_b this\n    have B_ineq : (fib (n + 1) : K) ≤ B :=\n      haveI : n + 1 ≤ 1 ∨ ¬g.terminated_at (n + 1 - 2) :=\n        by\n        cases' n_eq_zero_or_not_terminated_at_pred_n with n_eq_zero not_terminated_at_pred_n\n        · simp [n_eq_zero, le_refl]\n        · exact or.inr not_terminated_at_pred_n\n      fib_le_of_continuants_aux_b this\n    have zero_lt_B : 0 < B :=\n      haveI : 1 ≤ B := le_trans (by exact_mod_cast fib_pos (lt_of_le_of_ne n.succ.zero_le n.succ_ne_zero.symm)) B_ineq\n      lt_of_lt_of_le zero_lt_one this\n    have zero_ne_B : 0 ≠ B := ne_of_lt zero_lt_B\n    have : 0 ≠ pB + ifp.fr⁻¹ * B :=\n      by\n      have : (0 : K) ≤ fib n := by exact_mod_cast (fib n).zero_le\n      -- 0 ≤ fib n ≤ pB\n      have zero_le_pB : 0 ≤ pB := le_trans this pB_ineq\n      have : 0 < ifp.fr⁻¹ := by\n        suffices 0 < ifp.fr by rwa [inv_pos]\n        have : 0 ≤ ifp.fr := int_fract_pair.nth_stream_fr_nonneg stream_nth_eq\n        change ifp.fr ≠ 0 at ifp_fr_ne_zero\n        exact lt_of_le_of_ne this ifp_fr_ne_zero.symm\n      have : 0 < ifp.fr⁻¹ * B := mul_pos this zero_lt_B\n      have : 0 < pB + ifp.fr⁻¹ * B := add_pos_of_nonneg_of_pos zero_le_pB this\n      exact ne_of_lt this\n    -- finally, let's do the rewriting\n    calc\n      (pA + ifp.fr⁻¹ * A) / (pB + ifp.fr⁻¹ * B) - A / B =\n          ((pA + ifp.fr⁻¹ * A) * B - (pB + ifp.fr⁻¹ * B) * A) / ((pB + ifp.fr⁻¹ * B) * B) :=\n        by rw [div_sub_div _ _ this.symm zero_ne_B.symm]\n      _ = (pA * B + ifp.fr⁻¹ * A * B - (pB * A + ifp.fr⁻¹ * B * A)) / _ := by repeat' rw [add_mul]\n      _ = (pA * B - pB * A) / ((pB + ifp.fr⁻¹ * B) * B) := by ring\n      _ = (-1) ^ n / ((pB + ifp.fr⁻¹ * B) * B) := by rw [determinant_eq]\n      _ = (-1) ^ n / (B * (ifp.fr⁻¹ * B + pB)) := by ac_rfl\n      \n#align sub_convergents_eq sub_convergents_eq\n\n",
 "one_le_succ_nth_stream_b":
 "/-- Shows that the integer parts of the stream are at least one. -/\ntheorem one_le_succ_nth_stream_b {ifp_succ_n : IntFractPair K}\n    (succ_nth_stream_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n) : 1 ≤ ifp_succ_n.b :=\n  by\n  obtain ⟨ifp_n, nth_stream_eq, stream_nth_fr_ne_zero, ⟨-⟩⟩ :\n    ∃ ifp_n, int_fract_pair.stream v n = some ifp_n ∧ ifp_n.fr ≠ 0 ∧ int_fract_pair.of ifp_n.fr⁻¹ = ifp_succ_n\n  exact succ_nth_stream_eq_some_iff.elim_left succ_nth_stream_eq\n  suffices 1 ≤ ifp_n.fr⁻¹ by\n    rw_mod_cast [le_floor]\n    assumption\n  suffices ifp_n.fr ≤ 1\n    by\n    have h : 0 < ifp_n.fr := lt_of_le_of_ne (nth_stream_fr_nonneg nth_stream_eq) stream_nth_fr_ne_zero.symm\n    apply one_le_inv h this\n  simp only [le_of_lt (nth_stream_fr_lt_one nth_stream_eq)]\n#align one_le_succ_nth_stream_b one_le_succ_nth_stream_b\n\n",
 "of_part_num_eq_one_and_exists_int_part_denom_eq":
 "/-- Shows that the partial numerators `aᵢ` of the continued fraction are equal to one and the partial\ndenominators `bᵢ` correspond to integers.\n-/\ntheorem of_part_num_eq_one_and_exists_int_part_denom_eq {gp : GeneralizedContinuedFraction.Pair K}\n    (nth_s_eq : (of v).s.nth n = some gp) : gp.a = 1 ∧ ∃ z : ℤ, gp.b = (z : K) :=\n  by\n  obtain ⟨ifp, stream_succ_nth_eq, -⟩ : ∃ ifp, int_fract_pair.stream v (n + 1) = some ifp ∧ _\n  exact int_fract_pair.exists_succ_nth_stream_of_gcf_of_nth_eq_some nth_s_eq\n  have : gp = ⟨1, ifp.b⟩ :=\n    by\n    have : (of v).s.nth n = some ⟨1, ifp.b⟩ := nth_of_eq_some_of_succ_nth_int_fract_pair_stream stream_succ_nth_eq\n    have : some gp = some ⟨1, ifp.b⟩ := by rwa [nth_s_eq] at this\n    injection this\n  simp [this]\n#align of_part_num_eq_one_and_exists_int_part_denom_eq of_part_num_eq_one_and_exists_int_part_denom_eq\n\n",
 "of_part_num_eq_one":
 "/-- Shows that the partial numerators `aᵢ` are equal to one. -/\ntheorem of_part_num_eq_one {a : K} (nth_part_num_eq : (of v).partial_numerators.nth n = some a) : a = 1 :=\n  by\n  obtain ⟨gp, nth_s_eq, gp_a_eq_a_n⟩ : ∃ gp, (of v).s.nth n = some gp ∧ gp.a = a\n  exact exists_s_a_of_part_num nth_part_num_eq\n  have : gp.a = 1 := (of_part_num_eq_one_and_exists_int_part_denom_eq nth_s_eq).left\n  rwa [gp_a_eq_a_n] at this\n#align of_part_num_eq_one of_part_num_eq_one\n\n",
 "of_one_le_nth_part_denom":
 "/-- Shows that the integer parts of the continued fraction are at least one. -/\ntheorem of_one_le_nth_part_denom {b : K} (nth_part_denom_eq : (of v).partial_denominators.nth n = some b) : 1 ≤ b :=\n  by\n  obtain ⟨gp_n, nth_s_eq, ⟨-⟩⟩ : ∃ gp_n, (of v).s.nth n = some gp_n ∧ gp_n.b = b;\n  exact exists_s_b_of_part_denom nth_part_denom_eq\n  obtain ⟨ifp_n, succ_nth_stream_eq, ifp_n_b_eq_gp_n_b⟩ :\n    ∃ ifp, int_fract_pair.stream v (n + 1) = some ifp ∧ (ifp.b : K) = gp_n.b\n  exact int_fract_pair.exists_succ_nth_stream_of_gcf_of_nth_eq_some nth_s_eq\n  rw [← ifp_n_b_eq_gp_n_b]\n  exact_mod_cast int_fract_pair.one_le_succ_nth_stream_b succ_nth_stream_eq\n#align of_one_le_nth_part_denom of_one_le_nth_part_denom\n\n",
 "of_denom_mono":
 "/-- Shows that the sequence of denominators is monotone, that is `Bₙ ≤ Bₙ₊₁`. -/\ntheorem of_denom_mono : (of v).denominators n ≤ (of v).denominators (n + 1) :=\n  by\n  let g := of v\n  cases' decidable.em <| g.partial_denominators.terminated_at n with terminated not_terminated\n  · have : g.partial_denominators.nth n = none := by rwa [Stream'.Seq.TerminatedAt] at terminated\n    have : g.terminated_at n :=\n      terminated_at_iff_part_denom_none.elim_right (by rwa [Stream'.Seq.TerminatedAt] at terminated)\n    have : g.denominators (n + 1) = g.denominators n := denominators_stable_of_terminated n.le_succ this\n    rw [this]\n  · obtain ⟨b, nth_part_denom_eq⟩ : ∃ b, g.partial_denominators.nth n = some b\n    exact option.ne_none_iff_exists'.mp not_terminated\n    have : 1 ≤ b := of_one_le_nth_part_denom nth_part_denom_eq\n    calc\n      g.denominators n ≤ b * g.denominators n := by simpa using mul_le_mul_of_nonneg_right this zero_le_of_denom\n      _ ≤ g.denominators (n + 1) := le_of_succ_nth_denom nth_part_denom_eq\n      \n#align of_denom_mono of_denom_mono\n\n",
 "nth_stream_fr_nonneg_lt_one":
 "/-\nCopyright (c) 2020 Kevin Kappelmann. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Kappelmann\n-/\n/-- Shows that the fractional parts of the stream are in `[0,1)`. -/\ntheorem nth_stream_fr_nonneg_lt_one {ifp_n : IntFractPair K} (nth_stream_eq : IntFractPair.stream v n = some ifp_n) :\n    0 ≤ ifp_n.fr ∧ ifp_n.fr < 1 := by\n  cases n\n  case zero =>\n    have : int_fract_pair.of v = ifp_n := by injection nth_stream_eq\n    rw [← this, int_fract_pair.of]\n    exact ⟨fract_nonneg _, fract_lt_one _⟩\n  case succ =>\n    rcases succ_nth_stream_eq_some_iff.elim_left nth_stream_eq with ⟨_, _, _, ifp_of_eq_ifp_n⟩\n    rw [← ifp_of_eq_ifp_n, int_fract_pair.of]\n    exact ⟨fract_nonneg _, fract_lt_one _⟩\n#align nth_stream_fr_nonneg_lt_one nth_stream_fr_nonneg_lt_one\n\n",
 "nth_stream_fr_nonneg":
 "/-- Shows that the fractional parts of the stream are nonnegative. -/\ntheorem nth_stream_fr_nonneg {ifp_n : IntFractPair K} (nth_stream_eq : IntFractPair.stream v n = some ifp_n) :\n    0 ≤ ifp_n.fr :=\n  (nth_stream_fr_nonneg_lt_one nth_stream_eq).left\n#align nth_stream_fr_nonneg nth_stream_fr_nonneg\n\n",
 "nth_stream_fr_lt_one":
 "/-- Shows that the fractional parts of the stream are smaller than one. -/\ntheorem nth_stream_fr_lt_one {ifp_n : IntFractPair K} (nth_stream_eq : IntFractPair.stream v n = some ifp_n) :\n    ifp_n.fr < 1 :=\n  (nth_stream_fr_nonneg_lt_one nth_stream_eq).right\n#align nth_stream_fr_lt_one nth_stream_fr_lt_one\n\n",
 "le_of_succ_succ_nth_continuants_aux_b":
 "theorem le_of_succ_succ_nth_continuants_aux_b {b : K} (nth_part_denom_eq : (of v).partial_denominators.nth n = some b) :\n    b * ((of v).continuants_aux <| n + 1).b ≤ ((of v).continuants_aux <| n + 2).b :=\n  by\n  obtain ⟨gp_n, nth_s_eq, rfl⟩ : ∃ gp_n, (of v).s.nth n = some gp_n ∧ gp_n.b = b\n  exact exists_s_b_of_part_denom nth_part_denom_eq\n  simp [of_part_num_eq_one (part_num_eq_s_a nth_s_eq), zero_le_of_continuants_aux_b,\n    GeneralizedContinuedFraction.continuantsAux_recurrence nth_s_eq rfl rfl]\n#align le_of_succ_succ_nth_continuants_aux_b le_of_succ_succ_nth_continuants_aux_b\n\n",
 "le_of_succ_nth_denom":
 "/-- Shows that `bₙ * Bₙ ≤ Bₙ₊₁`, where `bₙ` is the `n`th partial denominator and `Bₙ₊₁` and `Bₙ` are\nthe `n + 1`th and `n`th denominator of the continued fraction. -/\ntheorem le_of_succ_nth_denom {b : K} (nth_part_denom_eq : (of v).partial_denominators.nth n = some b) :\n    b * (of v).denominators n ≤ (of v).denominators (n + 1) :=\n  by\n  rw [denom_eq_conts_b, nth_cont_eq_succ_nth_cont_aux]\n  exact le_of_succ_succ_nth_continuants_aux_b nth_part_denom_eq\n#align le_of_succ_nth_denom le_of_succ_nth_denom\n\n",
 "fib_le_of_continuants_aux_b":
 "-- open `nat` as we will make use of fibonacci numbers.\ntheorem fib_le_of_continuants_aux_b :\n    n ≤ 1 ∨ ¬(of v).terminated_at (n - 2) → (fib n : K) ≤ ((of v).continuants_aux n).b :=\n  nat.strong_induction_on n\n    (by\n      clear n\n      intro n IH hyp\n      rcases n with (_ | _ | n)\n      · simp [fib_add_two, continuants_aux]\n      -- case n = 0\n      · simp [fib_add_two, continuants_aux]\n      -- case n = 1\n      · let g := of v\n        -- case 2 ≤ n\n        have : ¬n + 2 ≤ 1 := by linarith\n        have not_terminated_at_n : ¬g.terminated_at n := or.resolve_left hyp this\n        obtain ⟨gp, s_ppred_nth_eq⟩ : ∃ gp, g.s.nth n = some gp\n        exact option.ne_none_iff_exists'.mp not_terminated_at_n\n        set pconts := g.continuants_aux (n + 1) with pconts_eq\n        set ppconts := g.continuants_aux n with ppconts_eq\n        -- use the recurrence of continuants_aux\n        suffices (fib n : K) + fib (n + 1) ≤ gp.a * ppconts.b + gp.b * pconts.b by\n          simpa [fib_add_two, add_comm, continuants_aux_recurrence s_ppred_nth_eq ppconts_eq pconts_eq]\n        -- make use of the fact that gp.a = 1\n        suffices (fib n : K) + fib (n + 1) ≤ ppconts.b + gp.b * pconts.b by\n          simpa [of_part_num_eq_one <| part_num_eq_s_a s_ppred_nth_eq]\n        have not_terminated_at_pred_n : ¬g.terminated_at (n - 1) :=\n          mt (terminated_stable <| nat.sub_le n 1) not_terminated_at_n\n        have not_terminated_at_ppred_n : ¬terminated_at g (n - 2) :=\n          mt (terminated_stable (n - 1).pred_le) not_terminated_at_pred_n\n        -- use the IH to get the inequalities for `pconts` and `ppconts`\n        have : (fib (n + 1) : K) ≤ pconts.b := IH _ (nat.lt.base <| n + 1) (or.inr not_terminated_at_pred_n)\n        have ppred_nth_fib_le_ppconts_B : (fib n : K) ≤ ppconts.b :=\n          IH n (lt_trans (nat.lt.base n) <| nat.lt.base <| n + 1) (or.inr not_terminated_at_ppred_n)\n        suffices : (fib (n + 1) : K) ≤ gp.b * pconts.b\n        solve_by_elim [add_le_add ppred_nth_fib_le_ppconts_B]\n        -- finally use the fact that 1 ≤ gp.b to solve the goal\n        suffices 1 * (fib (n + 1) : K) ≤ gp.b * pconts.b by rwa [one_mul] at this\n        have one_le_gp_b : (1 : K) ≤ gp.b := of_one_le_nth_part_denom (part_denom_eq_s_b s_ppred_nth_eq)\n        have : (0 : K) ≤ fib (n + 1) := by exact_mod_cast (fib (n + 1)).zero_le\n        have : (0 : K) ≤ gp.b := le_trans zero_le_one one_le_gp_b\n        mono)\n#align fib_le_of_continuants_aux_b fib_le_of_continuants_aux_b\n\n",
 "exists_int_eq_of_part_denom":
 "/-- Shows that the partial denominators `bᵢ` correspond to an integer. -/\ntheorem exists_int_eq_of_part_denom {b : K} (nth_part_denom_eq : (of v).partial_denominators.nth n = some b) :\n    ∃ z : ℤ, b = (z : K) :=\n  by\n  obtain ⟨gp, nth_s_eq, gp_b_eq_b_n⟩ : ∃ gp, (of v).s.nth n = some gp ∧ gp.b = b\n  exact exists_s_b_of_part_denom nth_part_denom_eq\n  have : ∃ z : ℤ, gp.b = (z : K) := (of_part_num_eq_one_and_exists_int_part_denom_eq nth_s_eq).right\n  rwa [gp_b_eq_b_n] at this\n#align exists_int_eq_of_part_denom exists_int_eq_of_part_denom\n\n",
 "determinant_aux":
 "theorem determinant_aux (hyp : n = 0 ∨ ¬(of v).terminated_at (n - 1)) :\n    ((of v).continuants_aux n).a * ((of v).continuants_aux (n + 1)).b -\n        ((of v).continuants_aux n).b * ((of v).continuants_aux (n + 1)).a =\n      (-1) ^ n :=\n  by\n  induction' n with n IH\n  case zero => simp [continuants_aux]\n  case\n    succ =>\n    -- set up some shorthand notation\n    let g := of v\n    let conts := continuants_aux g (n + 2)\n    set pred_conts := continuants_aux g (n + 1) with pred_conts_eq\n    set ppred_conts := continuants_aux g n with ppred_conts_eq\n    let pA := pred_conts.a\n    let pB := pred_conts.b\n    let ppA := ppred_conts.a\n    let ppB := ppred_conts.b\n    -- let's change the goal to something more readable\n    change pA * conts.b - pB * conts.a = (-1) ^ (n + 1)\n    have not_terminated_at_n : ¬terminated_at g n := or.resolve_left hyp n.succ_ne_zero\n    obtain ⟨gp, s_nth_eq⟩ : ∃ gp, g.s.nth n = some gp\n    exact option.ne_none_iff_exists'.elim_left not_terminated_at_n\n    -- unfold the recurrence relation for `conts` once and simplify to derive the following\n    suffices pA * (ppB + gp.b * pB) - pB * (ppA + gp.b * pA) = (-1) ^ (n + 1)\n      by\n      simp only [conts, continuants_aux_recurrence s_nth_eq ppred_conts_eq pred_conts_eq]\n      have gp_a_eq_one : gp.a = 1 := of_part_num_eq_one (part_num_eq_s_a s_nth_eq)\n      rw [gp_a_eq_one, this.symm]\n      ring\n    suffices : pA * ppB - pB * ppA = (-1) ^ (n + 1)\n    calc\n      pA * (ppB + gp.b * pB) - pB * (ppA + gp.b * pA) = pA * ppB + pA * gp.b * pB - pB * ppA - pB * gp.b * pA := by ring\n      _ = pA * ppB - pB * ppA := by ring\n      _ = (-1) ^ (n + 1) := by assumption\n      \n    suffices ppA * pB - ppB * pA = (-1) ^ n\n      by\n      have pow_succ_n : (-1 : K) ^ (n + 1) = -1 * (-1) ^ n := pow_succ (-1) n\n      rw [pow_succ_n, ← this]\n      ring\n    exact IH <| or.inr <| mt (terminated_stable <| n.sub_le 1) not_terminated_at_n\n#align determinant_aux determinant_aux\n\n",
 "determinant":
 "/-- The determinant formula `Aₙ * Bₙ₊₁ - Bₙ * Aₙ₊₁ = (-1)^(n + 1)` -/\ntheorem determinant (not_terminated_at_n : ¬(of v).terminated_at n) :\n    (of v).numerators n * (of v).denominators (n + 1) - (of v).denominators n * (of v).numerators (n + 1) =\n      (-1) ^ (n + 1) :=\n  determinant_aux <| or.inr <| not_terminated_at_n\n#align determinant determinant\n\n",
 "abs_sub_convergents_le'":
 "/-- Shows that `|v - Aₙ / Bₙ| ≤ 1 / (bₙ * Bₙ * Bₙ)`. This bound is worse than the one shown in\n`gcf.abs_sub_convergents_le`, but sometimes it is easier to apply and sufficient for one's use case.\n -/\ntheorem abs_sub_convergents_le' {b : K} (nth_part_denom_eq : (of v).partial_denominators.nth n = some b) :\n    |v - (of v).convergents n| ≤ 1 / (b * (of v).denominators n * (of v).denominators n) :=\n  by\n  have not_terminated_at_n : ¬(of v).terminated_at n := by simp [terminated_at_iff_part_denom_none, nth_part_denom_eq]\n  refine' (abs_sub_convergents_le not_terminated_at_n).trans _\n  -- One can show that `0 < (generalized_continued_fraction.of v).denominators n` but it's easier\n  -- to consider the case `(generalized_continued_fraction.of v).denominators n = 0`.\n  rcases zero_le_of_denom.eq_or_gt with ((hB : (GeneralizedContinuedFraction.of v).denominators n = 0) | hB)\n  · simp only [hB, MulZeroClass.mul_zero, MulZeroClass.zero_mul, div_zero]\n  · apply one_div_le_one_div_of_le\n    · have : 0 < b := zero_lt_one.trans_le (of_one_le_nth_part_denom nth_part_denom_eq)\n      apply_rules [mul_pos]\n    · conv_rhs => rw [mul_comm]\n      exact mul_le_mul_of_nonneg_right (le_of_succ_nth_denom nth_part_denom_eq) hB.le\n#align abs_sub_convergents_le' abs_sub_convergents_le'\n\n",
 "abs_sub_convergents_le":
 "/-- Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)` -/\ntheorem abs_sub_convergents_le (not_terminated_at_n : ¬(of v).terminated_at n) :\n    |v - (of v).convergents n| ≤ 1 / ((of v).denominators n * ((of v).denominators <| n + 1)) :=\n  by\n  -- shorthand notation\n  let g := of v\n  let nextConts := g.continuants_aux (n + 2)\n  set conts := continuants_aux g (n + 1) with conts_eq\n  set pred_conts := continuants_aux g n with pred_conts_eq\n  -- change the goal to something more readable\n  change |v - convergents g n| ≤ 1 / (conts.b * nextConts.b)\n  obtain ⟨gp, s_nth_eq⟩ : ∃ gp, g.s.nth n = some gp\n  exact option.ne_none_iff_exists'.elim_left not_terminated_at_n\n  have gp_a_eq_one : gp.a = 1 := of_part_num_eq_one (part_num_eq_s_a s_nth_eq)\n  -- unfold the recurrence relation for `nextConts.b`\n  have nextConts_b_eq : nextConts.b = pred_conts.b + gp.b * conts.b := by\n    simp [nextConts, continuants_aux_recurrence s_nth_eq pred_conts_eq conts_eq, gp_a_eq_one, pred_conts_eq.symm,\n      conts_eq.symm, add_comm]\n  let denom := conts.b * (pred_conts.b + gp.b * conts.b)\n  suffices |v - g.convergents n| ≤ 1 / denom by\n    rw [nextConts_b_eq]\n    congr 1\n  obtain ⟨ifp_succ_n, succ_nth_stream_eq, ifp_succ_n_b_eq_gp_b⟩ :\n    ∃ ifp_succ_n, int_fract_pair.stream v (n + 1) = some ifp_succ_n ∧ (ifp_succ_n.b : K) = gp.b\n  exact int_fract_pair.exists_succ_nth_stream_of_gcf_of_nth_eq_some s_nth_eq\n  obtain ⟨ifp_n, stream_nth_eq, stream_nth_fr_ne_zero, if_of_eq_ifp_succ_n⟩ :\n    ∃ ifp_n, int_fract_pair.stream v n = some ifp_n ∧ ifp_n.fr ≠ 0 ∧ int_fract_pair.of ifp_n.fr⁻¹ = ifp_succ_n\n  exact int_fract_pair.succ_nth_stream_eq_some_iff.elim_left succ_nth_stream_eq\n  let denom' := conts.b * (pred_conts.b + ifp_n.fr⁻¹ * conts.b)\n  -- now we can use `sub_convergents_eq` to simplify our goal\n  suffices |(-1) ^ n / denom'| ≤ 1 / denom\n    by\n    have : v - g.convergents n = (-1) ^ n / denom' :=\n      by\n      -- apply `sub_convergens_eq` and simplify the result\n      have tmp := sub_convergents_eq stream_nth_eq\n      delta at tmp\n      simp only [stream_nth_fr_ne_zero, conts_eq.symm, pred_conts_eq.symm] at tmp\n      rw [tmp]\n      simp only [denom']\n      ring_nf\n    rwa [this]\n  -- derive some tedious inequalities that we need to rewrite our goal\n  have nextConts_b_ineq : (fib (n + 2) : K) ≤ pred_conts.b + gp.b * conts.b :=\n    by\n    have : (fib (n + 2) : K) ≤ nextConts.b := fib_le_of_continuants_aux_b (or.inr not_terminated_at_n)\n    rwa [nextConts_b_eq] at this\n  have conts_b_ineq : (fib (n + 1) : K) ≤ conts.b :=\n    haveI : ¬g.terminated_at (n - 1) := mt (terminated_stable n.pred_le) not_terminated_at_n\n    fib_le_of_continuants_aux_b <| or.inr this\n  have zero_lt_conts_b : 0 < conts.b :=\n    haveI : (0 : K) < fib (n + 1) := by exact_mod_cast fib_pos (lt_of_le_of_ne n.succ.zero_le n.succ_ne_zero.symm)\n    lt_of_lt_of_le this conts_b_ineq\n  -- `denom'` is positive, so we can remove `|⬝|` from our goal\n  suffices 1 / denom' ≤ 1 / denom\n    by\n    have : |(-1) ^ n / denom'| = 1 / denom' :=\n      by\n      suffices 1 / |denom'| = 1 / denom' by rwa [abs_div, abs_neg_one_pow n]\n      have : 0 < denom' :=\n        by\n        have : 0 ≤ pred_conts.b :=\n          haveI : (fib n : K) ≤ pred_conts.b :=\n            haveI : ¬g.terminated_at (n - 2) := mt (terminated_stable (n.sub_le 2)) not_terminated_at_n\n            fib_le_of_continuants_aux_b <| or.inr this\n          le_trans (by exact_mod_cast (fib n).zero_le) this\n        have : 0 < ifp_n.fr⁻¹ :=\n          haveI zero_le_ifp_n_fract : 0 ≤ ifp_n.fr := int_fract_pair.nth_stream_fr_nonneg stream_nth_eq\n          inv_pos.elim_right (lt_of_le_of_ne zero_le_ifp_n_fract stream_nth_fr_ne_zero.symm)\n        any_goals repeat' first |apply mul_pos|apply add_pos_of_nonneg_of_pos <;> assumption\n      rwa [abs_of_pos this]\n    rwa [this]\n  suffices : 0 < denom ∧ denom ≤ denom'\n  exact div_le_div_of_le_left zero_le_one this.left this.right\n  constructor\n  · have : 0 < pred_conts.b + gp.b * conts.b :=\n      lt_of_lt_of_le (by exact_mod_cast fib_pos (lt_of_le_of_ne n.succ.succ.zero_le n.succ.succ_ne_zero.symm))\n        nextConts_b_ineq\n    solve_by_elim [mul_pos]\n  · -- we can cancel multiplication by `conts.b` and addition with `pred_conts.b`\n    suffices : gp.b * conts.b ≤ ifp_n.fr⁻¹ * conts.b\n    exact (mul_le_mul_left zero_lt_conts_b).elim_right <| (add_le_add_iff_left pred_conts.b).elim_right this\n    suffices (ifp_succ_n.b : K) * conts.b ≤ ifp_n.fr⁻¹ * conts.b by rwa [← ifp_succ_n_b_eq_gp_b]\n    have : (ifp_succ_n.b : K) ≤ ifp_n.fr⁻¹ :=\n      int_fract_pair.succ_nth_stream_b_le_nth_stream_fr_inv stream_nth_eq succ_nth_stream_eq\n    have : 0 ≤ conts.b := le_of_lt zero_lt_conts_b\n    mono\n#align abs_sub_convergents_le abs_sub_convergents_le\n\n"}