{"of_correctness_of_terminates":
 "/-- If `generalized_continued_fraction.of v` terminates, then there is `n : ℕ` such that the `n`th\nconvergent is exactly `v`.\n-/\ntheorem of_correctness_of_terminates (terminates : (of v).terminates) : ∃ n : ℕ, v = (of v).convergents n :=\n  exists.elim terminates fun n terminated_at_n => exists.intro n (of_correctness_of_terminated_at terminated_at_n)\n#align of_correctness_of_terminates of_correctness_of_terminates\n\n",
 "of_correctness_of_terminated_at":
 "/-- If `generalized_continued_fraction.of v` terminated at step `n`, then the `n`th convergent is\nexactly `v`.\n-/\ntheorem of_correctness_of_terminated_at (terminated_at_n : (of v).terminated_at n) : v = (of v).convergents n :=\n  have : int_fract_pair.stream v (n + 1) = none :=\n    of_terminated_at_n_iff_succ_nth_int_fract_pair_stream_eq_none.elim_left terminated_at_n\n  of_correctness_of_nth_stream_eq_none this\n#align of_correctness_of_terminated_at of_correctness_of_terminated_at\n\n",
 "of_correctness_of_nth_stream_eq_none":
 "/-- The convergent of `generalized_continued_fraction.of v` at step `n - 1` is exactly `v` if the\n`int_fract_pair.stream` of the corresponding continued fraction terminated at step `n`. -/\ntheorem of_correctness_of_nth_stream_eq_none (nth_stream_eq_none : int_fract_pair.stream v n = none) :\n    v = (of v).convergents (n - 1) := by\n  induction' n with n IH\n  case zero => contradiction\n  -- int_fract_pair.stream v 0 ≠ none\n  case succ =>\n    rename' nth_stream_eq_none => succ_nth_stream_eq_none\n    let g := of v\n    change v = g.convergents n\n    have : int_fract_pair.stream v n = none ∨ ∃ ifp, int_fract_pair.stream v n = some ifp ∧ ifp.fr = 0 :=\n      int_fract_pair.succ_nth_stream_eq_none_iff.elim_left succ_nth_stream_eq_none\n    rcases this with (⟨nth_stream_eq_none⟩ | ⟨ifp_n, nth_stream_eq, nth_stream_fr_eq_zero⟩)\n    · cases' n with n'\n      · contradiction\n      -- int_fract_pair.stream v 0 ≠ none\n      · have : g.terminated_at n' :=\n          of_terminated_at_n_iff_succ_nth_int_fract_pair_stream_eq_none.elim_right nth_stream_eq_none\n        have : g.convergents (n' + 1) = g.convergents n' := convergents_stable_of_terminated n'.le_succ this\n        rw [this]\n        exact IH nth_stream_eq_none\n    · simpa [nth_stream_fr_eq_zero, comp_exact_value] using comp_exact_value_correctness_of_stream_eq_some nth_stream_eq\n#align of_correctness_of_nth_stream_eq_none of_correctness_of_nth_stream_eq_none\n\n",
 "of_correctness_at_top_of_terminates":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- If `generalized_continued_fraction.of v` terminates, then its convergents will eventually always\nbe `v`.\n-/\ntheorem of_correctness_at_top_of_terminates (terminates : (of v).terminates) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (v = (of v).convergents n) :=\n  by\n  rw [eventually_at_top]\n  obtain ⟨n, terminated_at_n⟩ : ∃ n, (of v).terminated_at n\n  exact terminates\n  use n\n  intro m m_geq_n\n  rw [convergents_stable_of_terminated m_geq_n terminated_at_n]\n  exact of_correctness_of_terminated_at terminated_at_n\n#align of_correctness_at_top_of_terminates of_correctness_at_top_of_terminates\n\n",
 "comp_exact_value_correctness_of_stream_eq_some_aux_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/-\nCopyright (c) 2020 Kevin Kappelmann. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Kappelmann\n-/\n-- if the fractional part is zero, we exactly approximated the value by the last continuants\n-- otherwise, we have to include the fractional part in a final continuants step.\n/-- Just a computational lemma we need for the next main proof. -/\nprotected theorem comp_exact_value_correctness_of_stream_eq_some_aux_comp {a : K} (b c : K)\n    (fract_a_ne_zero : Int.fract a ≠ 0) : ((«expr⌊ ⌋» a : K) * b + c) / Int.fract a + b = (b * a + c) / Int.fract a :=\n  by\n  field_simp [fract_a_ne_zero]\n  rw [Int.fract]\n  ring\n#align comp_exact_value_correctness_of_stream_eq_some_aux_comp comp_exact_value_correctness_of_stream_eq_some_aux_comp\n\n",
 "comp_exact_value_correctness_of_stream_eq_some":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/-- Shows the correctness of `comp_exact_value` in case the continued fraction\n`generalized_continued_fraction.of v` did not terminate at position `n`. That is, we obtain the\nvalue `v` if we pass the two successive (auxiliary) continuants at positions `n` and `n + 1` as well\nas the fractional part at `int_fract_pair.stream n` to `comp_exact_value`.\n\nThe correctness might be seen more readily if one uses `convergents'` to evaluate the continued\nfraction. Here is an example to illustrate the idea:\n\nLet `(v : ℚ) := 3.4`. We have\n- `generalized_continued_fraction.int_fract_pair.stream v 0 = some ⟨3, 0.4⟩`, and\n- `generalized_continued_fraction.int_fract_pair.stream v 1 = some ⟨2, 0.5⟩`.\nNow `(generalized_continued_fraction.of v).convergents' 1 = 3 + 1/2`, and our fractional term at\nposition `2` is `0.5`. We hence have `v = 3 + 1/(2 + 0.5) = 3 + 1/2.5 = 3.4`. This computation\ncorresponds exactly to the one using the recurrence equation in `comp_exact_value`.\n-/\ntheorem comp_exact_value_correctness_of_stream_eq_some :\n    ∀ {ifp_n : int_fract_pair K},\n      int_fract_pair.stream v n = some ifp_n →\n        v = comp_exact_value ((of v).continuants_aux n) ((of v).continuants_aux <| n + 1) ifp_n.fr :=\n  by\n  let g := of v\n  induction' n with n IH\n  · intro ifp_zero stream_zero_eq\n    -- nat.zero\n    have : int_fract_pair.of v = ifp_zero :=\n      by\n      have : int_fract_pair.stream v 0 = some (int_fract_pair.of v) := rfl\n      simpa only [this] using stream_zero_eq\n    cases this\n    cases' decidable.em (Int.fract v = 0) with fract_eq_zero fract_ne_zero\n    -- int.fract v = 0; we must then have `v = ⌊v⌋`\n    · suffices v = «expr⌊ ⌋» v by simpa [continuants_aux, fract_eq_zero, comp_exact_value]\n      calc\n        v = Int.fract v + «expr⌊ ⌋» v := by rw [Int.fract_add_floor]\n        _ = «expr⌊ ⌋» v := by simp [fract_eq_zero]\n        \n    -- int.fract v ≠ 0; the claim then easily follows by unfolding a single computation step\n    ·\n      field_simp [continuants_aux, next_continuants, next_numerator, next_denominator, of_h_eq_floor, comp_exact_value,\n        fract_ne_zero]\n  · intro ifp_succ_n succ_nth_stream_eq\n    -- nat.succ\n    obtain ⟨ifp_n, nth_stream_eq, nth_fract_ne_zero, -⟩ :\n      ∃ ifp_n, int_fract_pair.stream v n = some ifp_n ∧ ifp_n.fr ≠ 0 ∧ int_fract_pair.of ifp_n.fr⁻¹ = ifp_succ_n\n    exact int_fract_pair.succ_nth_stream_eq_some_iff.elim_left succ_nth_stream_eq\n    -- introduce some notation\n    let conts := g.continuants_aux (n + 2)\n    set pconts := g.continuants_aux (n + 1) with pconts_eq\n    set ppconts := g.continuants_aux n with ppconts_eq\n    cases' decidable.em (ifp_succ_n.fr = 0) with ifp_succ_n_fr_eq_zero ifp_succ_n_fr_ne_zero\n    -- ifp_succ_n.fr = 0\n    · suffices v = conts.a / conts.b by simpa [comp_exact_value, ifp_succ_n_fr_eq_zero]\n      -- use the IH and the fact that ifp_n.fr⁻¹ = ⌊ifp_n.fr⁻¹⌋ to prove this case\n      obtain ⟨ifp_n', nth_stream_eq', ifp_n_fract_inv_eq_floor⟩ :\n        ∃ ifp_n, int_fract_pair.stream v n = some ifp_n ∧ ifp_n.fr⁻¹ = «expr⌊ ⌋» ifp_n.fr⁻¹\n      exact int_fract_pair.exists_succ_nth_stream_of_fr_zero succ_nth_stream_eq ifp_succ_n_fr_eq_zero\n      have : ifp_n' = ifp_n := by injection eq.trans nth_stream_eq'.symm nth_stream_eq\n      cases this\n      have s_nth_eq : g.s.nth n = some ⟨1, «expr⌊ ⌋» ifp_n.fr⁻¹⟩ :=\n        nth_of_eq_some_of_nth_int_fract_pair_stream_fr_ne_zero nth_stream_eq nth_fract_ne_zero\n      rw [← ifp_n_fract_inv_eq_floor] at s_nth_eq\n      suffices v = comp_exact_value ppconts pconts ifp_n.fr by\n        simpa [conts, continuants_aux, s_nth_eq, comp_exact_value, nth_fract_ne_zero] using this\n      exact IH nth_stream_eq\n    -- ifp_succ_n.fr ≠ 0\n    · -- use the IH to show that the following equality suffices\n      suffices comp_exact_value ppconts pconts ifp_n.fr = comp_exact_value pconts conts ifp_succ_n.fr\n        by\n        have : v = comp_exact_value ppconts pconts ifp_n.fr := IH nth_stream_eq\n        conv_lhs => rw [this]\n        assumption\n      -- get the correspondence between ifp_n and ifp_succ_n\n      obtain ⟨ifp_n', nth_stream_eq', ifp_n_fract_ne_zero, ⟨refl⟩⟩ :\n        ∃ ifp_n, int_fract_pair.stream v n = some ifp_n ∧ ifp_n.fr ≠ 0 ∧ int_fract_pair.of ifp_n.fr⁻¹ = ifp_succ_n\n      exact int_fract_pair.succ_nth_stream_eq_some_iff.elim_left succ_nth_stream_eq\n      have : ifp_n' = ifp_n := by injection eq.trans nth_stream_eq'.symm nth_stream_eq\n      cases this\n      -- get the correspondence between ifp_n and g.s.nth n\n      have s_nth_eq : g.s.nth n = some ⟨1, («expr⌊ ⌋» ifp_n.fr⁻¹ : K)⟩ :=\n        nth_of_eq_some_of_nth_int_fract_pair_stream_fr_ne_zero nth_stream_eq ifp_n_fract_ne_zero\n      -- the claim now follows by unfolding the definitions and tedious calculations\n      -- some shorthand notation\n      let ppA := ppconts.a\n      let ppB := ppconts.b\n      let pA := pconts.a\n      let pB := pconts.b\n      have : comp_exact_value ppconts pconts ifp_n.fr = (ppA + ifp_n.fr⁻¹ * pA) / (ppB + ifp_n.fr⁻¹ * pB) :=\n        by\n        -- unfold comp_exact_value and the convergent computation once\n        field_simp [ifp_n_fract_ne_zero, comp_exact_value, next_continuants, next_numerator, next_denominator]\n        ac_rfl\n      rw [this]\n      -- two calculations needed to show the claim\n      have tmp_calc := comp_exact_value_correctness_of_stream_eq_some_aux_comp pA ppA ifp_succ_n_fr_ne_zero\n      have tmp_calc' := comp_exact_value_correctness_of_stream_eq_some_aux_comp pB ppB ifp_succ_n_fr_ne_zero\n      rw [inv_eq_one_div] at tmp_calc tmp_calc'\n      have : Int.fract (1 / ifp_n.fr) ≠ 0 := by simpa using ifp_succ_n_fr_ne_zero\n      -- now unfold the recurrence one step and simplify both sides to arrive at the conclusion\n      field_simp [conts, comp_exact_value, continuants_aux_recurrence s_nth_eq ppconts_eq pconts_eq, next_continuants,\n        next_numerator, next_denominator, this, tmp_calc, tmp_calc']\n      ac_rfl\n#align comp_exact_value_correctness_of_stream_eq_some comp_exact_value_correctness_of_stream_eq_some\n\n"}