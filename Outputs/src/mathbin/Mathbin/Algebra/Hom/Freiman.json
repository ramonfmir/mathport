{"to_fun_eq_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[simp, to_additive]\ntheorem to_fun_eq_coe (f : freiman_hom A n β) : f.to_fun = f :=\n  rfl\n#align to_fun_eq_coe to_fun_eq_coe\n\n",
 "to_freiman_hom_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[to_additive]\ntheorem freiman_hom.to_freiman_hom_injective (h : m ≤ n) :\n    function.injective (freiman_hom.to_freiman_hom h : freiman_hom A n β → freiman_hom A m β) := fun f g hfg =>\n  freiman_hom.ext <| by convert fun_like.ext_iff.1 hfg\n#align freiman_hom.to_freiman_hom_injective freiman_hom.to_freiman_hom_injective\n\n",
 "to_freiman_hom_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[simp, to_additive add_freiman_hom.to_add_freiman_hom_coe]\ntheorem freiman_hom.to_freiman_hom_coe (h : m ≤ n) (f : freiman_hom A n β) : (f.to_freiman_hom h : α → β) = f :=\n  rfl\n#align freiman_hom.to_freiman_hom_coe freiman_hom.to_freiman_hom_coe\n\n",
 "one_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[simp, to_additive]\ntheorem one_comp (f : freiman_hom A n β) {hf} : (1 : freiman_hom B n γ).comp f hf = 1 :=\n  rfl\n#align one_comp one_comp\n\n",
 "one_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[simp, to_additive]\ntheorem one_apply (x : α) : (1 : freiman_hom A n β) x = 1 :=\n  rfl\n#align one_apply one_apply\n\n",
 "mul_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[to_additive]\ntheorem mul_comp (g₁ g₂ : freiman_hom B n γ) (f : freiman_hom A n β) {hg hg₁ hg₂} :\n    (g₁ * g₂).comp f hg = g₁.comp f hg₁ * g₂.comp f hg₂ :=\n  rfl\n#align mul_comp mul_comp\n\n",
 "mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[simp, to_additive]\ntheorem mul_apply (f g : freiman_hom A n β) (x : α) : (f * g) x = f x * g x :=\n  rfl\n#align mul_apply mul_apply\n\n",
 "mk_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[simp, to_additive]\ntheorem mk_coe (f : freiman_hom A n β) (h) : mk f h = f :=\n  ext fun _ => rfl\n#align mk_coe mk_coe\n\n",
 "map_prod_eq_map_prod_of_le":
 "@[to_additive]\ntheorem map_prod_eq_map_prod_of_le [freiman_hom_class F A β n] (f : F) {s t : Multiset α} (hsA : ∀ x ∈ s, x ∈ A)\n    (htA : ∀ x ∈ t, x ∈ A) (hs : s.card = m) (ht : t.card = m) (hst : s.prod = t.prod) (h : m ≤ n) :\n    (s.map f).prod = (t.map f).prod := by\n  obtain rfl | hm := m.eq_zero_or_pos\n  · rw [card_eq_zero] at hs ht\n    rw [hs, ht]\n  rw [← hs, card_pos_iff_exists_mem] at hm\n  obtain ⟨a, ha⟩ := hm\n  suffices ((s + replicate (n - m) a).map f).prod = ((t + replicate (n - m) a).map f).prod\n    by\n    simp_rw [Multiset.map_add, prod_add] at this\n    exact mul_right_cancel this\n  replace ha := hsA _ ha\n  refine' map_prod_eq_map_prod f (fun x hx => _) (fun x hx => _) _ _ _\n  rotate_left 2\n  assumption\n  -- Can't infer `A` and `n` from the context, so do it manually.\n  · rw [mem_add] at hx\n    refine' hx.elim (hsA _) fun h => _\n    rwa [eq_of_mem_replicate h]\n  · rw [mem_add] at hx\n    refine' hx.elim (htA _) fun h => _\n    rwa [eq_of_mem_replicate h]\n  · rw [card_add, hs, card_replicate, add_tsub_cancel_of_le h]\n  · rw [card_add, ht, card_replicate, add_tsub_cancel_of_le h]\n  · rw [prod_add, prod_add, hst]\n#align map_prod_eq_map_prod_of_le map_prod_eq_map_prod_of_le\n\n",
 "map_prod_eq_map_prod":
 "/-\nCopyright (c) 2022 Yaël Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies\n-/\n@[to_additive]\ntheorem map_prod_eq_map_prod [freiman_hom_class F A β n] (f : F) {s t : Multiset α} (hsA : ∀ ⦃x⦄, x ∈ s → x ∈ A)\n    (htA : ∀ ⦃x⦄, x ∈ t → x ∈ A) (hs : s.card = n) (ht : t.card = n) (h : s.prod = t.prod) :\n    (s.map f).prod = (t.map f).prod :=\n  freiman_hom_class.map_prod_eq_map_prod' f hsA htA hs ht h\n#align map_prod_eq_map_prod map_prod_eq_map_prod\n\n",
 "map_mul_map_eq_map_mul_map":
 "@[to_additive]\ntheorem map_mul_map_eq_map_mul_map [freiman_hom_class F A β 2] (f : F) (ha : a ∈ A) (hb : b ∈ A) (hc : c ∈ A)\n    (hd : d ∈ A) (h : a * b = c * d) : f a * f b = f c * f d :=\n  by\n  simp_rw [← prod_pair] at h⊢\n  refine' map_prod_eq_map_prod f _ _ (card_pair _ _) (card_pair _ _) h <;> simp [ha, hb, hc, hd]\n#align map_mul_map_eq_map_mul_map map_mul_map_eq_map_mul_map\n\n",
 "inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[simp, to_additive]\ntheorem inv_comp (f : freiman_hom B n G) (g : freiman_hom A n β) {hf hf'} : f⁻¹.comp g hf = (f.comp g hf')⁻¹ :=\n  ext fun x => rfl\n#align inv_comp inv_comp\n\n",
 "inv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[simp, to_additive]\ntheorem inv_apply (f : freiman_hom A n G) (x : α) : f⁻¹ x = (f x)⁻¹ :=\n  rfl\n#align inv_apply inv_apply\n\n",
 "id_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[simp, to_additive]\ntheorem id_comp (f : freiman_hom A n β) {hf} : (freiman_hom.id B n).comp f hf = f :=\n  ext fun x => rfl\n#align id_comp id_comp\n\n",
 "freiman_hom_class_of_le":
 "/-- A `n`-Freiman homomorphism is also a `m`-Freiman homomorphism for any `m ≤ n`. -/\n@[to_additive add_freiman_hom.add_freiman_hom_class_of_le\n      \"An additive `n`-Freiman homomorphism is\\nalso an additive `m`-Freiman homomorphism for any `m ≤ n`.\"]\ntheorem freiman_hom.freiman_hom_class_of_le [freiman_hom_class F A β n] (h : m ≤ n) : freiman_hom_class F A β m :=\n  { map_prod_eq_map_prod' := fun f s t hsA htA hs ht hst => map_prod_eq_map_prod_of_le f hsA htA hs ht hst h }\n#align freiman_hom.freiman_hom_class_of_le freiman_hom.freiman_hom_class_of_le\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[ext, to_additive]\ntheorem ext ⦃f g : freiman_hom A n β⦄ (h : ∀ x, f x = g x) : f = g :=\n  fun_like.ext f g h\n#align ext ext\n\n",
 "div_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[simp, to_additive]\ntheorem div_comp (f₁ f₂ : freiman_hom B n G) (g : freiman_hom A n β) {hf hf₁ hf₂} :\n    (f₁ / f₂).comp g hf = f₁.comp g hf₁ / f₂.comp g hf₂ :=\n  ext fun x => rfl\n#align div_comp div_comp\n\n",
 "div_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[simp, to_additive]\ntheorem div_apply (f g : freiman_hom A n G) (x : α) : (f / g) x = f x / g x :=\n  rfl\n#align div_apply div_apply\n\n",
 "const_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[simp, to_additive]\ntheorem const_comp (n : ℕ) (c : γ) (f : freiman_hom A n β) {hf} : (const B n c).comp f hf = const A n c :=\n  rfl\n#align const_comp const_comp\n\n",
 "const_apply":
 "@[simp, to_additive]\ntheorem const_apply (n : ℕ) (b : β) (x : α) : const A n b x = b :=\n  rfl\n#align const_apply const_apply\n\n",
 "comp_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[simp, to_additive]\ntheorem comp_id (f : freiman_hom A n β) {hf} : f.comp (freiman_hom.id A n) hf = f :=\n  ext fun x => rfl\n#align comp_id comp_id\n\n",
 "comp_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[to_additive]\ntheorem comp_assoc (f : freiman_hom A n β) (g : freiman_hom B n γ) (h : freiman_hom C n δ) {hf hhg hgf}\n    {hh : A.maps_to (g.comp f hgf) C} : (h.comp g hhg).comp f hf = h.comp (g.comp f hgf) hh :=\n  rfl\n#align comp_assoc comp_assoc\n\n",
 "comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[to_additive]\ntheorem comp_apply (f : freiman_hom B n γ) (g : freiman_hom A n β) {hfg} (x : α) : f.comp g hfg x = f (g x) :=\n  rfl\n#align comp_apply comp_apply\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, to_additive]\ntheorem coe_mk (f : α → β)\n    (h :\n      ∀ s t : Multiset α,\n        (∀ ⦃x⦄, x ∈ s → x ∈ A) →\n          (∀ ⦃x⦄, x ∈ t → x ∈ A) → s.card = n → t.card = n → s.prod = t.prod → (s.map f).prod = (t.map f).prod) :\n    «expr⇑ » (mk f h) = f :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "coe_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, to_additive]\ntheorem coe_comp (f : freiman_hom B n γ) (g : freiman_hom A n β) {hfg} : «expr⇑ » (f.comp g hfg) = f ∘ g :=\n  rfl\n#align coe_comp coe_comp\n\n",
 "cancel_right_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[to_additive]\ntheorem cancel_right_on {g₁ g₂ : freiman_hom B n γ} {f : freiman_hom A n β} (hf : A.surj_on f B) {hf'} :\n    A.eq_on (g₁.comp f hf') (g₂.comp f hf') ↔ B.eq_on g₁ g₂ :=\n  hf.cancel_right hf'\n#align cancel_right_on cancel_right_on\n\n",
 "cancel_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[to_additive]\ntheorem cancel_right {g₁ g₂ : freiman_hom B n γ} {f : freiman_hom A n β} (hf : function.surjective f) {hg₁ hg₂} :\n    g₁.comp f hg₁ = g₂.comp f hg₂ ↔ g₁ = g₂ :=\n  ⟨fun h => ext <| hf.forall.2 <| fun_like.ext_iff.1 h, fun h => h ▸ rfl⟩\n#align cancel_right cancel_right\n\n",
 "cancel_left_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `freiman_hom -/\n@[to_additive]\ntheorem cancel_left_on {g : freiman_hom B n γ} {f₁ f₂ : freiman_hom A n β} (hg : B.inj_on g) {hf₁ hf₂} :\n    A.eq_on (g.comp f₁ hf₁) (g.comp f₂ hf₂) ↔ A.eq_on f₁ f₂ :=\n  hg.cancel_left hf₁ hf₂\n#align cancel_left_on cancel_left_on\n\n"}