{"to_fun_eq_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n@[simp]\ntheorem monoid_with_zero_hom.to_fun_eq_coe [MulZeroOneClass M] [MulZeroOneClass N] (f : «expr →*₀ » M N) :\n    f.to_fun = f :=\n  rfl\n#align monoid_with_zero_hom.to_fun_eq_coe monoid_with_zero_hom.to_fun_eq_coe\n\n",
 "toZeroHom_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.toZeroHom_injective /-\ntheorem MonoidWithZeroHom.toZeroHom_injective [MulZeroOneClass M] [MulZeroOneClass N] :\n    function.injective (monoid_with_zero_hom.to_zero_hom : «expr →*₀ » M N → ZeroHom M N) := fun f g h =>\n  MonoidWithZeroHom.ext <| ZeroHom.ext_iff.mp h\n#align monoid_with_zero_hom.to_zero_hom_injective MonoidWithZeroHom.toZeroHom_injective\n-/\n\n",
 "toZeroHom_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.toZeroHom_coe /-\n@[simp]\ntheorem MonoidWithZeroHom.toZeroHom_coe [MulZeroOneClass M] [MulZeroOneClass N] (f : «expr →*₀ » M N) :\n    (f.to_zero_hom : M → N) = f :=\n  rfl\n#align monoid_with_zero_hom.to_zero_hom_coe MonoidWithZeroHom.toZeroHom_coe\n-/\n\n",
 "toOneHom_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidHom.toOneHom_injective /-\n@[to_additive]\ntheorem MonoidHom.toOneHom_injective [MulOneClass M] [MulOneClass N] :\n    function.injective (monoid_hom.to_one_hom : «expr →* » M N → OneHom M N) := fun f g h =>\n  MonoidHom.ext <| OneHom.ext_iff.mp h\n#align monoid_hom.to_one_hom_injective MonoidHom.toOneHom_injective\n#align add_monoid_hom.to_zero_hom_injective AddMonoidHom.toZeroHom_injective\n-/\n\n",
 "toOneHom_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidHom.toOneHom_coe /-\n@[simp, to_additive]\ntheorem MonoidHom.toOneHom_coe [MulOneClass M] [MulOneClass N] (f : «expr →* » M N) : (f.to_one_hom : M → N) = f :=\n  rfl\n#align monoid_hom.to_one_hom_coe MonoidHom.toOneHom_coe\n#align add_monoid_hom.to_zero_hom_coe AddMonoidHom.toZeroHom_coe\n-/\n\n",
 "toMulHom_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ* » -/\n#print MonoidHom.toMulHom_injective /-\n@[to_additive]\ntheorem MonoidHom.toMulHom_injective [MulOneClass M] [MulOneClass N] :\n    function.injective (monoid_hom.to_mul_hom : «expr →* » M N → «expr →ₙ* » M N) := fun f g h =>\n  MonoidHom.ext <| MulHom.ext_iff.mp h\n#align monoid_hom.to_mul_hom_injective MonoidHom.toMulHom_injective\n#align add_monoid_hom.to_add_hom_injective AddMonoidHom.toAddHom_injective\n-/\n\n",
 "toMulHom_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidHom.toMulHom_coe /-\n@[simp, to_additive]\ntheorem MonoidHom.toMulHom_coe [MulOneClass M] [MulOneClass N] (f : «expr →* » M N) : (f.to_mul_hom : M → N) = f :=\n  rfl\n#align monoid_hom.to_mul_hom_coe MonoidHom.toMulHom_coe\n#align add_monoid_hom.to_add_hom_coe AddMonoidHom.toAddHom_coe\n-/\n\n",
 "toMonoidHom_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidWithZeroHom.toMonoidHom_injective /-\ntheorem MonoidWithZeroHom.toMonoidHom_injective [MulZeroOneClass M] [MulZeroOneClass N] :\n    function.injective (monoid_with_zero_hom.to_monoid_hom : «expr →*₀ » M N → «expr →* » M N) := fun f g h =>\n  MonoidWithZeroHom.ext <| MonoidHom.ext_iff.mp h\n#align monoid_with_zero_hom.to_monoid_hom_injective MonoidWithZeroHom.toMonoidHom_injective\n-/\n\n",
 "toMonoidHom_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.toMonoidHom_coe /-\n@[simp]\ntheorem MonoidWithZeroHom.toMonoidHom_coe [MulZeroOneClass M] [MulZeroOneClass N] (f : «expr →*₀ » M N) :\n    (f.to_monoid_hom : M → N) = f :=\n  rfl\n#align monoid_with_zero_hom.to_monoid_hom_coe MonoidWithZeroHom.toMonoidHom_coe\n-/\n\n",
 "toFun_eq_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidHom.toFun_eq_coe /-\n@[simp, to_additive]\ntheorem MonoidHom.toFun_eq_coe [MulOneClass M] [MulOneClass N] (f : «expr →* » M N) : f.to_fun = f :=\n  rfl\n#align monoid_hom.to_fun_eq_coe MonoidHom.toFun_eq_coe\n#align add_monoid_hom.to_fun_eq_coe AddMonoidHom.toFun_eq_coe\n-/\n\n",
 "one_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem one_comp [MulOneClass M] [MulOneClass N] [MulOneClass P] (f : «expr →* » M N) :\n    (1 : «expr →* » N P).comp f = 1 :=\n  rfl\n#align one_comp one_comp\n\n",
 "one_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidHom.one_apply /-\n@[simp, to_additive]\ntheorem MonoidHom.one_apply [MulOneClass M] [MulOneClass N] (x : M) : (1 : «expr →* » M N) x = 1 :=\n  rfl\n#align monoid_hom.one_apply MonoidHom.one_apply\n#align add_monoid_hom.zero_apply AddMonoidHom.zero_apply\n-/\n\n",
 "of_map":
 "/-\nCopyright (c) 2018 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Kevin Buzzard, Scott Morrison, Johan Commelin, Chris Hughes,\n  Johannes Hölzl, Yury Kudryashov\n-/\n-- monoids\n-- groups\n-- homs\n-- for easy multiple inheritance\n-- Instances and lemmas are defined below through `@[to_additive]`.\ntheorem of_map {R M} [Zero R] [Zero M] [ZeroHomClass F R M] (f : F) {r : R} [NeZero (f r)] : NeZero r :=\n  ⟨fun h => ne (f r) <| by convert ZeroHomClass.map_zero f⟩\n#align of_map of_map\n\n",
 "of_injective":
 "theorem of_injective {R M} [Zero R] {r : R} [NeZero r] [Zero M] [ZeroHomClass F R M] {f : F}\n    (hf : function.injective f) : NeZero (f r) :=\n  ⟨by\n    rw [← ZeroHomClass.map_zero f]\n    exact hf.ne (ne r)⟩\n#align of_injective of_injective\n\n",
 "ne_one_of_map":
 "#print ne_one_of_map /-\n@[to_additive]\ntheorem ne_one_of_map {R S F : Type _} [One R] [One S] [OneHomClass F R S] {f : F} {x : R} (hx : f x ≠ 1) : x ≠ 1 :=\n  ne_of_apply_ne f <| ne_of_ne_of_eq hx (map_one f).symm\n#align ne_one_of_map ne_one_of_map\n#align ne_zero_of_map ne_zero_of_map\n-/\n\n",
 "mul_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem mul_comp [MulOneClass M] [MulOneClass N] [CommMonoid P] (g₁ g₂ : «expr →* » N P) (f : «expr →* » M N) :\n    (g₁ * g₂).comp f = g₁.comp f * g₂.comp f :=\n  rfl\n#align mul_comp mul_comp\n\n",
 "mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem mul_apply {M N} {mM : MulOneClass M} {mN : CommMonoid N} (f g : «expr →* » M N) (x : M) :\n    (f * g) x = f x * g x :=\n  rfl\n#align mul_apply mul_apply\n\n",
 "mk_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.mk_coe /-\n@[simp]\ntheorem MonoidWithZeroHom.mk_coe [MulZeroOneClass M] [MulZeroOneClass N] (f : «expr →*₀ » M N) (h0 h1 hmul) :\n    monoid_with_zero_hom.mk f h0 h1 hmul = f :=\n  MonoidWithZeroHom.ext fun _ => rfl\n#align monoid_with_zero_hom.mk_coe MonoidWithZeroHom.mk_coe\n-/\n\n",
 "map_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print map_zsmul /-\n/-- Additive group homomorphisms preserve integer scaling. -/\ntheorem map_zsmul [AddGroup G] [SubtractionMonoid H] [AddMonoidHomClass F G H] (f : F) (n : ℤ) (g : G) :\n    f («expr • » n g) = «expr • » n (f g) :=\n  map_zsmul.aux f g n\n#align map_zsmul map_zsmul\n-/\n\n",
 "map_zpow'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidHom.map_zpow' /-\n@[to_additive]\nprotected theorem MonoidHom.map_zpow' [DivInvMonoid M] [DivInvMonoid N] (f : «expr →* » M N) (hf : ∀ x, f x⁻¹ = (f x)⁻¹)\n    (a : M) (n : ℤ) : f (a ^ n) = f a ^ n :=\n  map_zpow' f hf a n\n#align monoid_hom.map_zpow' MonoidHom.map_zpow'\n#align add_monoid_hom.map_zsmul' AddMonoidHom.map_zsmul'\n-/\n\n",
 "map_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print map_zpow /-\n/-- Group homomorphisms preserve integer power. -/\n@[to_additive \"Additive group homomorphisms preserve integer scaling.\"]\nprotected theorem map_zpow [Group α] [DivisionMonoid β] (f : «expr →* » α β) (g : α) (n : ℤ) : f (g ^ n) = f g ^ n :=\n  map_zpow f g n\n#align map_zpow map_zpow\n#align map_zsmul map_zsmul\n-/\n\n",
 "map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.map_zero /-\nprotected theorem MonoidWithZeroHom.map_zero [MulZeroOneClass M] [MulZeroOneClass N] (f : «expr →*₀ » M N) : f 0 = 0 :=\n  f.map_zero'\n#align monoid_with_zero_hom.map_zero MonoidWithZeroHom.map_zero\n-/\n\n",
 "map_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidHom.map_pow /-\n@[to_additive AddMonoidHom.map_nsmul]\nprotected theorem MonoidHom.map_pow [Monoid M] [Monoid N] (f : «expr →* » M N) (a : M) (n : ℕ) : f (a ^ n) = f a ^ n :=\n  map_pow f a n\n#align monoid_hom.map_pow MonoidHom.map_pow\n#align add_monoid_hom.map_nsmul AddMonoidHom.map_nsmul\n-/\n\n",
 "map_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.map_one /-\nprotected theorem MonoidWithZeroHom.map_one [MulZeroOneClass M] [MulZeroOneClass N] (f : «expr →*₀ » M N) : f 1 = 1 :=\n  f.map_one'\n#align monoid_with_zero_hom.map_one MonoidWithZeroHom.map_one\n-/\n\n",
 "map_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print map_nsmul /-\n@[simp]\ntheorem map_nsmul [AddMonoid G] [AddMonoid H] [AddMonoidHomClass F G H] (f : F) (n : ℕ) (a : G) :\n    f («expr • » n a) = «expr • » n (f a) :=\n  map_nsmul.aux f a n\n#align map_nsmul map_nsmul\n-/\n\n",
 "map_ne_one_iff":
 "#print map_ne_one_iff /-\n@[to_additive]\ntheorem map_ne_one_iff {R S F : Type _} [One R] [One S] [OneHomClass F R S] (f : F) (hf : function.injective f)\n    {x : R} : f x ≠ 1 ↔ x ≠ 1 :=\n  (map_eq_one_iff f hf).not\n#align map_ne_one_iff map_ne_one_iff\n#align map_ne_zero_iff map_ne_zero_iff\n-/\n\n",
 "map_mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print map_mul_inv /-\n/-- Group homomorphisms preserve division. -/\n@[to_additive \"Additive group homomorphisms preserve subtraction.\"]\nprotected theorem map_mul_inv [Group α] [DivisionMonoid β] (f : «expr →* » α β) (g h : α) :\n    f (g * h⁻¹) = f g * (f h)⁻¹ :=\n  map_mul_inv f g h\n#align map_mul_inv map_mul_inv\n#align map_add_neg map_add_neg\n-/\n\n",
 "map_mul_eq_one":
 "#print map_mul_eq_one /-\n@[to_additive]\ntheorem map_mul_eq_one [MonoidHomClass F M N] (f : F) {a b : M} (h : a * b = 1) : f a * f b = 1 := by\n  rw [← map_mul, h, map_one]\n#align map_mul_eq_one map_mul_eq_one\n#align map_add_eq_zero map_add_eq_zero\n-/\n\n",
 "map_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.map_mul /-\nprotected theorem MonoidWithZeroHom.map_mul [MulZeroOneClass M] [MulZeroOneClass N] (f : «expr →*₀ » M N) (a b : M) :\n    f (a * b) = f a * f b :=\n  f.map_mul' a b\n#align monoid_with_zero_hom.map_mul MonoidWithZeroHom.map_mul\n-/\n\n",
 "map_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print map_inv /-\n/-- Group homomorphisms preserve inverse. -/\n@[to_additive \"Additive group homomorphisms preserve negation.\"]\nprotected theorem map_inv [Group α] [DivisionMonoid β] (f : «expr →* » α β) (a : α) : f a⁻¹ = (f a)⁻¹ :=\n  map_inv f _\n#align map_inv map_inv\n#align map_neg map_neg\n-/\n\n",
 "map_exists_right_inv":
 "/-- Given a monoid homomorphism `f : M →* N` and an element `x : M`, if `x` has a right inverse,\nthen `f x` has a right inverse too. For elements invertible on both sides see `is_unit.map`. -/\n@[to_additive\n      \"Given an add_monoid homomorphism `f : M →+ N` and an element `x : M`, if `x` has\\na right inverse, then `f x` has a right inverse too.\"]\ntheorem map_exists_right_inv (f : F) {x : M} (hx : ∃ y, x * y = 1) : ∃ y, f x * y = 1 :=\n  let ⟨y, hy⟩ := hx\n  ⟨f y, map_mul_eq_one f hy⟩\n#align map_exists_right_inv map_exists_right_inv\n\n",
 "map_exists_left_inv":
 "/-- Given a monoid homomorphism `f : M →* N` and an element `x : M`, if `x` has a left inverse,\nthen `f x` has a left inverse too. For elements invertible on both sides see `is_unit.map`. -/\n@[to_additive\n      \"Given an add_monoid homomorphism `f : M →+ N` and an element `x : M`, if `x` has\\na left inverse, then `f x` has a left inverse too. For elements invertible on both sides see\\n`is_add_unit.map`.\"]\ntheorem map_exists_left_inv (f : F) {x : M} (hx : ∃ y, y * x = 1) : ∃ y, y * f x = 1 :=\n  let ⟨y, hy⟩ := hx\n  ⟨f y, map_mul_eq_one f hy⟩\n#align map_exists_left_inv map_exists_left_inv\n\n",
 "map_eq_one_iff":
 "#print map_eq_one_iff /-\n@[to_additive]\ntheorem map_eq_one_iff [OneHomClass F M N] (f : F) (hf : function.injective f) {x : M} : f x = 1 ↔ x = 1 :=\n  hf.eq_iff' (map_one f)\n#align map_eq_one_iff map_eq_one_iff\n#align map_eq_zero_iff map_eq_zero_iff\n-/\n\n",
 "map_div'":
 "#print map_div' /-\n@[to_additive]\ntheorem map_div' [DivInvMonoid G] [DivInvMonoid H] [MonoidHomClass F G H] (f : F) (hf : ∀ a, f a⁻¹ = (f a)⁻¹)\n    (a b : G) : f (a / b) = f a / f b := by rw [div_eq_mul_inv, div_eq_mul_inv, map_mul, hf]\n#align map_div' map_div'\n#align map_sub' map_sub'\n-/\n\n",
 "map_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print map_div /-\n/-- Group homomorphisms preserve division. -/\n@[to_additive \"Additive group homomorphisms preserve subtraction.\"]\nprotected theorem map_div [Group α] [DivisionMonoid β] (f : «expr →* » α β) (g h : α) : f (g / h) = f g / f h :=\n  map_div f g h\n#align map_div map_div\n#align map_sub map_sub\n-/\n\n",
 "inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem inv_comp {M N A} {mM : MulOneClass M} {gN : MulOneClass N} {gA : CommGroup A} (φ : «expr →* » N A)\n    (ψ : «expr →* » M N) : φ⁻¹.comp ψ = (φ.comp ψ)⁻¹ := by\n  ext\n  simp only [Function.comp_apply, inv_apply, coe_comp]\n#align inv_comp inv_comp\n\n",
 "inv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem inv_apply {M G} {mM : MulOneClass M} {gG : CommGroup G} (f : «expr →* » M G) (x : M) : f⁻¹ x = (f x)⁻¹ :=\n  rfl\n#align inv_apply inv_apply\n\n",
 "invMonoidHom_apply":
 "#print invMonoidHom_apply /-\n@[simp]\ntheorem invMonoidHom_apply (a : α) : invMonoidHom a = a⁻¹ :=\n  rfl\n#align inv_monoid_hom_apply invMonoidHom_apply\n-/\n\n",
 "injective_iff_map_eq_one'":
 "#print injective_iff_map_eq_one' /-\n/-- A homomorphism from a group to a monoid is injective iff its kernel is trivial,\nstated as an iff on the triviality of the kernel.\nFor the implication, see `injective_iff_map_eq_one`. -/\n@[to_additive\n      \"A homomorphism from an additive group to an additive monoid is injective iff its\\nkernel is trivial, stated as an iff on the triviality of the kernel. For the implication, see\\n`injective_iff_map_eq_zero`.\"]\ntheorem injective_iff_map_eq_one' {G H} [Group G] [MulOneClass H] [MonoidHomClass F G H] (f : F) :\n    function.injective f ↔ ∀ a, f a = 1 ↔ a = 1 :=\n  (injective_iff_map_eq_one f).trans <| forall_congr' fun a => ⟨fun h => ⟨h, fun H => H.symm ▸ map_one f⟩, Iff.mp⟩\n#align injective_iff_map_eq_one' injective_iff_map_eq_one'\n#align injective_iff_map_eq_zero' injective_iff_map_eq_zero'\n-/\n\n",
 "injective_iff_map_eq_one":
 "#print injective_iff_map_eq_one /-\n/-- A homomorphism from a group to a monoid is injective iff its kernel is trivial.\nFor the iff statement on the triviality of the kernel, see `injective_iff_map_eq_one'`.  -/\n@[to_additive\n      \"A homomorphism from an additive group to an additive monoid is injective iff\\nits kernel is trivial. For the iff statement on the triviality of the kernel,\\nsee `injective_iff_map_eq_zero'`.\"]\ntheorem injective_iff_map_eq_one {G H} [Group G] [MulOneClass H] [MonoidHomClass F G H] (f : F) :\n    function.injective f ↔ ∀ a, f a = 1 → a = 1 :=\n  ⟨fun h x => (map_eq_one_iff f h).mp, fun h x y hxy =>\n    mul_inv_eq_one.1 <| h _ <| by rw [map_mul, hxy, ← map_mul, mul_inv_self, map_one]⟩\n#align injective_iff_map_eq_one injective_iff_map_eq_one\n#align injective_iff_map_eq_zero injective_iff_map_eq_zero\n-/\n\n",
 "id_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.id_comp /-\n@[simp]\ntheorem MonoidWithZeroHom.id_comp [MulZeroOneClass M] [MulZeroOneClass N] (f : «expr →*₀ » M N) :\n    (MonoidWithZeroHom.id N).comp f = f :=\n  MonoidWithZeroHom.ext fun x => rfl\n#align monoid_with_zero_hom.id_comp MonoidWithZeroHom.id_comp\n-/\n\n",
 "ext_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.ext_iff /-\n/-- Deprecated: use `fun_like.ext_iff` instead. -/\ntheorem MonoidWithZeroHom.ext_iff [MulZeroOneClass M] [MulZeroOneClass N] {f g : «expr →*₀ » M N} :\n    f = g ↔ ∀ x, f x = g x :=\n  FunLike.ext_iff\n#align monoid_with_zero_hom.ext_iff MonoidWithZeroHom.ext_iff\n-/\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.ext /-\n@[ext]\ntheorem MonoidWithZeroHom.ext [MulZeroOneClass M] [MulZeroOneClass N] ⦃f g : «expr →*₀ » M N⦄ (h : ∀ x, f x = g x) :\n    f = g :=\n  FunLike.ext _ _ h\n#align monoid_with_zero_hom.ext MonoidWithZeroHom.ext\n-/\n\n",
 "div_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem div_apply {M G} {mM : MulOneClass M} {gG : CommGroup G} (f g : «expr →* » M G) (x : M) :\n    (f / g) x = f x / g x :=\n  rfl\n#align div_apply div_apply\n\n",
 "copy_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.copy_eq /-\ntheorem MonoidWithZeroHom.copy_eq {hM : MulZeroOneClass M} {hN : MulZeroOneClass N} (f : «expr →*₀ » M N) (f' : M → N)\n    (h : f' = f) : f.copy f' h = f :=\n  FunLike.ext' h\n#align monoid_with_zero_hom.copy_eq MonoidWithZeroHom.copy_eq\n-/\n\n",
 "congr_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.congr_fun /-\n/-- Deprecated: use `fun_like.congr_fun` instead. -/\ntheorem MonoidWithZeroHom.congr_fun [MulZeroOneClass M] [MulZeroOneClass N] {f g : «expr →*₀ » M N} (h : f = g)\n    (x : M) : f x = g x :=\n  FunLike.congr_fun h x\n#align monoid_with_zero_hom.congr_fun MonoidWithZeroHom.congr_fun\n-/\n\n",
 "congr_arg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.congr_arg /-\n/-- Deprecated: use `fun_like.congr_arg` instead. -/\ntheorem MonoidWithZeroHom.congr_arg [MulZeroOneClass M] [MulZeroOneClass N] (f : «expr →*₀ » M N) {x y : M}\n    (h : x = y) : f x = f y :=\n  FunLike.congr_arg f h\n#align monoid_with_zero_hom.congr_arg MonoidWithZeroHom.congr_arg\n-/\n\n",
 "comp_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem comp_one [MulOneClass M] [MulOneClass N] [MulOneClass P] (f : «expr →* » N P) :\n    f.comp (1 : «expr →* » M N) = 1 := by\n  ext\n  simp only [map_one, coe_comp, Function.comp_apply, one_apply]\n#align comp_one comp_one\n\n",
 "comp_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem comp_mul [MulOneClass M] [CommMonoid N] [CommMonoid P] (g : «expr →* » N P) (f₁ f₂ : «expr →* » M N) :\n    g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂ := by\n  ext\n  simp only [mul_apply, Function.comp_apply, map_mul, coe_comp]\n#align comp_mul comp_mul\n\n",
 "comp_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem comp_inv {M A B} {mM : MulOneClass M} {mA : CommGroup A} {mB : CommGroup B} (φ : «expr →* » A B)\n    (ψ : «expr →* » M A) : φ.comp ψ⁻¹ = (φ.comp ψ)⁻¹ := by\n  ext\n  simp only [Function.comp_apply, inv_apply, map_inv, coe_comp]\n#align comp_inv comp_inv\n\n",
 "comp_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.comp_id /-\n@[simp]\ntheorem MonoidWithZeroHom.comp_id [MulZeroOneClass M] [MulZeroOneClass N] (f : «expr →*₀ » M N) :\n    f.comp (MonoidWithZeroHom.id M) = f :=\n  MonoidWithZeroHom.ext fun x => rfl\n#align monoid_with_zero_hom.comp_id MonoidWithZeroHom.comp_id\n-/\n\n",
 "comp_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.comp_assoc /-\ntheorem MonoidWithZeroHom.comp_assoc {Q : Type _} [MulZeroOneClass M] [MulZeroOneClass N] [MulZeroOneClass P]\n    [MulZeroOneClass Q] (f : «expr →*₀ » M N) (g : «expr →*₀ » N P) (h : «expr →*₀ » P Q) :\n    (h.comp g).comp f = h.comp (g.comp f) :=\n  rfl\n#align monoid_with_zero_hom.comp_assoc MonoidWithZeroHom.comp_assoc\n-/\n\n",
 "comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.comp_apply /-\ntheorem MonoidWithZeroHom.comp_apply [MulZeroOneClass M] [MulZeroOneClass N] [MulZeroOneClass P] (g : «expr →*₀ » N P)\n    (f : «expr →*₀ » M N) (x : M) : g.comp f x = g (f x) :=\n  rfl\n#align monoid_with_zero_hom.comp_apply MonoidWithZeroHom.comp_apply\n-/\n\n",
 "coe_one":
 "@[simp]\ntheorem coe_one : ((1 : AddMonoid.End A) : A → A) = id :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_of_map_mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, to_additive]\ntheorem coe_of_map_mul_inv {H : Type _} [Group H] (f : G → H) (map_div : ∀ a b : G, f (a * b⁻¹) = f a * (f b)⁻¹) :\n    «expr⇑ » (ofMapMulInv f map_div) = f :=\n  rfl\n#align coe_of_map_mul_inv coe_of_map_mul_inv\n\n",
 "coe_of_map_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, to_additive]\ntheorem coe_of_map_div {H : Type _} [Group H] (f : G → H) (hf : ∀ x y, f (x / y) = f x / f y) :\n    «expr⇑ » (ofMapDiv f hf) = f :=\n  rfl\n#align coe_of_map_div coe_of_map_div\n\n",
 "coe_mul":
 "@[simp]\ntheorem coe_mul (f g) : ((f * g : AddMonoid.End A) : A → A) = f ∘ g :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_mk":
 "#print MonoidWithZeroHom.coe_mk /-\n@[simp]\ntheorem MonoidWithZeroHom.coe_mk [MulZeroOneClass M] [MulZeroOneClass N] (f : M → N) (h0 h1 hmul) :\n    (monoid_with_zero_hom.mk f h0 h1 hmul : M → N) = f :=\n  rfl\n#align monoid_with_zero_hom.coe_mk MonoidWithZeroHom.coe_mk\n-/\n\n",
 "coe_invMonoidHom":
 "#print coe_invMonoidHom /-\n@[simp]\ntheorem coe_invMonoidHom : (invMonoidHom : α → α) = has_inv.inv :=\n  rfl\n#align coe_inv_monoid_hom coe_invMonoidHom\n-/\n\n",
 "coe_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.coe_inj /-\n/-- Deprecated: use `fun_like.coe_injective` instead. -/\ntheorem MonoidWithZeroHom.coe_inj [MulZeroOneClass M] [MulZeroOneClass N] ⦃f g : «expr →*₀ » M N⦄\n    (h : (f : M → N) = g) : f = g :=\n  FunLike.coe_injective h\n#align monoid_with_zero_hom.coe_inj MonoidWithZeroHom.coe_inj\n-/\n\n",
 "coe_eq_to_zero_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n@[simp]\ntheorem monoid_with_zero_hom.coe_eq_to_zero_hom {mM : MulZeroOneClass M} {mN : MulZeroOneClass N}\n    (f : «expr →*₀ » M N) : (f : ZeroHom M N) = f.to_zero_hom :=\n  rfl\n#align monoid_with_zero_hom.coe_eq_to_zero_hom monoid_with_zero_hom.coe_eq_to_zero_hom\n\n",
 "coe_eq_to_one_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n-- completely uninteresting lemmas about coercion to function, that all homs need\n@[simp, to_additive]\ntheorem monoid_hom.coe_eq_to_one_hom {mM : MulOneClass M} {mN : MulOneClass N} (f : «expr →* » M N) :\n    (f : OneHom M N) = f.to_one_hom :=\n  rfl\n#align monoid_hom.coe_eq_to_one_hom monoid_hom.coe_eq_to_one_hom\n\n",
 "coe_eq_to_mul_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ* » -/\n@[simp, to_additive]\ntheorem monoid_hom.coe_eq_to_mul_hom {mM : MulOneClass M} {mN : MulOneClass N} (f : «expr →* » M N) :\n    (f : «expr →ₙ* » M N) = f.to_mul_hom :=\n  rfl\n#align monoid_hom.coe_eq_to_mul_hom monoid_hom.coe_eq_to_mul_hom\n\n",
 "coe_eq_to_monoid_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp]\ntheorem monoid_with_zero_hom.coe_eq_to_monoid_hom {mM : MulZeroOneClass M} {mN : MulZeroOneClass N}\n    (f : «expr →*₀ » M N) : (f : «expr →* » M N) = f.to_monoid_hom :=\n  rfl\n#align monoid_with_zero_hom.coe_eq_to_monoid_hom monoid_with_zero_hom.coe_eq_to_monoid_hom\n\n",
 "coe_copy_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ* » -/\n#print MulHom.coe_copy_eq /-\n@[to_additive]\ntheorem MulHom.coe_copy_eq {hM : Mul M} {hN : Mul N} (f : «expr →ₙ* » M N) (f' : M → N) (h : f' = f) :\n    f.copy f' h = f :=\n  FunLike.ext' h\n#align mul_hom.coe_copy_eq MulHom.coe_copy_eq\n#align add_hom.coe_copy_eq AddHom.coe_copy_eq\n-/\n\n",
 "coe_copy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print MonoidWithZeroHom.coe_copy /-\n@[simp]\ntheorem MonoidWithZeroHom.coe_copy {hM : MulZeroOneClass M} {hN : MulZeroOneClass N} (f : «expr →*₀ » M N) (f' : M → N)\n    (h : f' = f) : «expr⇑ » (f.copy f' h) = f' :=\n  rfl\n#align monoid_with_zero_hom.coe_copy MonoidWithZeroHom.coe_copy\n-/\n\n",
 "coe_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print MonoidWithZeroHom.coe_comp /-\n@[simp]\ntheorem MonoidWithZeroHom.coe_comp [MulZeroOneClass M] [MulZeroOneClass N] [MulZeroOneClass P] (g : «expr →*₀ » N P)\n    (f : «expr →*₀ » M N) : «expr⇑ » (g.comp f) = g ∘ f :=\n  rfl\n#align monoid_with_zero_hom.coe_comp MonoidWithZeroHom.coe_comp\n-/\n\n",
 "coe_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.coe_coe /-\n@[simp]\ntheorem MonoidWithZeroHom.coe_coe [MonoidWithZeroHomClass F M N] (f : F) : ((f : «expr →*₀ » M N) : M → N) = f :=\n  rfl\n#align monoid_with_zero_hom.coe_coe MonoidWithZeroHom.coe_coe\n-/\n\n",
 "cancel_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.cancel_right /-\ntheorem MonoidWithZeroHom.cancel_right [MulZeroOneClass M] [MulZeroOneClass N] [MulZeroOneClass P]\n    {g₁ g₂ : «expr →*₀ » N P} {f : «expr →*₀ » M N} (hf : function.surjective f) : g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => MonoidWithZeroHom.ext <| hf.forall.2 (MonoidWithZeroHom.ext_iff.1 h), fun h => h ▸ rfl⟩\n#align monoid_with_zero_hom.cancel_right MonoidWithZeroHom.cancel_right\n-/\n\n",
 "cancel_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n#print MonoidWithZeroHom.cancel_left /-\ntheorem MonoidWithZeroHom.cancel_left [MulZeroOneClass M] [MulZeroOneClass N] [MulZeroOneClass P] {g : «expr →*₀ » N P}\n    {f₁ f₂ : «expr →*₀ » M N} (hg : function.injective g) : g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h =>\n    MonoidWithZeroHom.ext fun x => hg <| by rw [← MonoidWithZeroHom.comp_apply, h, MonoidWithZeroHom.comp_apply],\n    fun h => h ▸ rfl⟩\n#align monoid_with_zero_hom.cancel_left MonoidWithZeroHom.cancel_left\n-/\n\n"}