{"single_mem_grade_by":
 "theorem single_mem_grade_by {R} [CommSemiring R] (f : M → ι) (m : M) (r : R) :\n    Finsupp.single m r ∈ grade_by R f (f m) := by\n  intro x hx\n  rw [finset.mem_singleton.mp (Finsupp.support_single_subset hx)]\n#align single_mem_grade_by single_mem_grade_by\n\n",
 "single_mem_grade":
 "theorem single_mem_grade {R} [CommSemiring R] (i : M) (r : R) : Finsupp.single i r ∈ grade R i :=\n  single_mem_grade_by _ _ _\n#align single_mem_grade single_mem_grade\n\n",
 "mem_grade_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem mem_grade_iff' (m : M) (a : AddMonoidAlgebra R M) :\n    a ∈ grade R m ↔\n      a ∈ ((Finsupp.lsingle m : «expr →ₗ[ ] » R R («expr →₀ » M R)).range : Submodule R (AddMonoidAlgebra R M)) :=\n  by\n  rw [mem_grade_iff, Finsupp.support_subset_singleton']\n  apply exists_congr\n  intro r\n  constructor <;> exact Eq.symm\n#align mem_grade_iff' mem_grade_iff'\n\n",
 "mem_grade_iff":
 "theorem mem_grade_iff (m : M) (a : AddMonoidAlgebra R M) : a ∈ grade R m ↔ a.support ⊆ {m} :=\n  by\n  rw [← Finset.coe_subset, Finset.coe_singleton]\n  rfl\n#align mem_grade_iff mem_grade_iff\n\n",
 "mem_grade_by_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mem_grade_by_iff (f : M → ι) (i : ι) (a : AddMonoidAlgebra R M) :\n    a ∈ grade_by R f i ↔ (a.support : Set M) ⊆ «expr ⁻¹' » f {i} := by rfl\n#align mem_grade_by_iff mem_grade_by_iff\n\n",
 "is_internal":
 "/-- `add_monoid_algebra.grades` describe an internally graded algebra -/\ntheorem grade.is_internal : DirectSum.IsInternal (grade R : ι → Submodule R _) :=\n  direct_sum.decomposition.is_internal _\n#align grade.is_internal grade.is_internal\n\n",
 "grade_eq_lsingle_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem grade_eq_lsingle_range (m : M) : grade R m = (Finsupp.lsingle m : «expr →ₗ[ ] » R R («expr →₀ » M R)).range :=\n  Submodule.ext (mem_grade_iff' R m)\n#align grade_eq_lsingle_range grade_eq_lsingle_range\n\n",
 "grade_by_id":
 "/-\nCopyright (c) 2021 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\ntheorem grade_by_id : grade_by R (id : M → M) = grade R := by rfl\n#align grade_by_id grade_by_id\n\n",
 "decompose_single":
 "-- Lean can't find this later without us repeating it\n@[simp]\ntheorem grade.decompose_single (i : ι) (r : R) :\n    direct_sum.decompose (grade R : ι → Submodule _ _) (Finsupp.single i r : AddMonoidAlgebra _ _) =\n      DirectSum.of (fun i : ι => grade R i) i ⟨Finsupp.single i r, single_mem_grade _ _⟩ :=\n  decompose_aux_single _ _ _\n#align grade.decompose_single grade.decompose_single\n\n",
 "decompose_aux_single":
 "theorem decompose_aux_single (m : M) (r : R) :\n    decompose_aux f (Finsupp.single m r) =\n      DirectSum.of (fun i : ι => grade_by R f i) (f m) ⟨Finsupp.single m r, single_mem_grade_by _ _ _⟩ :=\n  by\n  refine' (lift_single _ _ _).trans _\n  refine' (DirectSum.of_smul _ _ _ _).symm.trans _\n  apply direct_sum.of_eq_of_graded_monoid_eq\n  refine' Sigma.subtype_ext rfl _\n  refine' (Finsupp.smul_single' _ _ _).trans _\n  rw [mul_one]\n  rfl\n#align decompose_aux_single decompose_aux_single\n\n",
 "decompose_aux_eq_decompose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n-- Lean can't find this later without us repeating it\n@[simp]\ntheorem decompose_aux_eq_decompose :\n    «expr⇑ »\n        (decompose_aux f :\n          «expr →ₐ[ ] » (AddMonoidAlgebra R M) R\n            (direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\"\n              (grade_by R f i))) =\n      direct_sum.decompose (grade_by R f) :=\n  rfl\n#align decompose_aux_eq_decompose decompose_aux_eq_decompose\n\n",
 "decompose_aux_coe":
 "theorem decompose_aux_coe {i : ι} (x : grade_by R f i) :\n    decompose_aux f ↑x = DirectSum.of (fun i => grade_by R f i) i x :=\n  by\n  obtain ⟨x, hx⟩ := x\n  revert hx\n  refine' Finsupp.induction x _ _\n  · intro hx\n    symm\n    exact AddMonoidHom.map_zero _\n  · intro m b y hmy hb ih hmby\n    have : Disjoint (Finsupp.single m b).support y.support := by\n      simpa only [Finsupp.support_single_ne_zero _ hb, Finset.disjoint_singleton_left]\n    rw [mem_grade_by_iff, Finsupp.support_add_eq this, Finset.coe_union, Set.union_subset_iff] at hmby\n    cases' hmby with h1 h2\n    have : f m = i := by rwa [Finsupp.support_single_ne_zero _ hb, Finset.coe_singleton, Set.singleton_subset_iff] at h1\n    subst this\n    simp only [AlgHom.map_add, Submodule.coe_mk, decompose_aux_single f m]\n    let ih' := ih h2\n    dsimp at ih'\n    rw [ih', ← AddMonoidHom.map_add]\n    apply direct_sum.of_eq_of_graded_monoid_eq\n    congr 2\n#align decompose_aux_coe decompose_aux_coe\n\n"}