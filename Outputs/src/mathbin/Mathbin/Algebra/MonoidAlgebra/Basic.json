{"smul_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_of [MulOneClass G] (g : G) (r : k) : «expr • » r (of k G g) = single g r := by simp\n#align smul_of smul_of\n\n",
 "single_zero_mul_apply":
 "theorem single_zero_mul_apply [AddZeroClass G] (f : AddMonoidAlgebra k G) (r : k) (x : G) :\n    (single 0 r * f : AddMonoidAlgebra k G) x = r * f x :=\n  f.single_mul_apply_aux r _ _ _ fun a => by rw [zero_add]\n#align single_zero_mul_apply single_zero_mul_apply\n\n",
 "single_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- This should be a `@[simp]` lemma, but the simp_nf linter times out if we add this.\n-- Probably the correct fix is to make a `[add_]monoid_algebra.single` with the correct type,\n-- instead of relying on `finsupp.single`.\ntheorem single_pow [AddMonoid G] {a : G} {b : k} :\n    ∀ n : ℕ, (single a b ^ n : AddMonoidAlgebra k G) = single («expr • » n a) (b ^ n)\n  | 0 => by\n    simp only [pow_zero, zero_nsmul]\n    rfl\n  | n + 1 => by rw [pow_succ, pow_succ, single_pow n, single_mul_single, add_comm, add_nsmul, one_nsmul]\n#align single_pow single_pow\n\n",
 "single_one_mul_apply":
 "theorem single_one_mul_apply [MulOneClass G] (f : MonoidAlgebra k G) (r : k) (x : G) : (single 1 r * f) x = r * f x :=\n  f.single_mul_apply_aux fun a => by rw [one_mul]\n#align single_one_mul_apply single_one_mul_apply\n\n",
 "single_one_comm":
 "theorem single_one_comm [CommSemiring k] [MulOneClass G] (r : k) (f : MonoidAlgebra k G) :\n    single 1 r * f = f * single 1 r := by\n  ext\n  rw [single_one_mul_apply, mul_single_one_apply, mul_comm]\n#align single_one_comm single_one_comm\n\n",
 "single_mul_single":
 "theorem single_mul_single [Add G] {a₁ a₂ : G} {b₁ b₂ : k} :\n    (single a₁ b₁ * single a₂ b₂ : AddMonoidAlgebra k G) = single (a₁ + a₂) (b₁ * b₂) :=\n  @MonoidAlgebra.single_mul_single k (Multiplicative G) _ _ _ _ _ _\n#align single_mul_single single_mul_single\n\n",
 "single_mul_apply_of_not_exists_mul":
 "theorem single_mul_apply_of_not_exists_mul [Mul G] (r : k) {g g' : G} (x : MonoidAlgebra k G) (h : ¬∃ d, g' = g * d) :\n    (Finsupp.single g r * x : MonoidAlgebra k G) g' = 0 := by\n  classical\n    rw [mul_apply, Finsupp.sum_single_index]\n    swap\n    · simp_rw [Finsupp.sum, MulZeroClass.zero_mul, if_t_t, Finset.sum_const_zero]\n    · apply Finset.sum_eq_zero\n      simp_rw [ite_eq_right_iff]\n      rintro g'' hg'' rfl\n      exfalso\n      exact h ⟨_, rfl⟩\n#align single_mul_apply_of_not_exists_mul single_mul_apply_of_not_exists_mul\n\n",
 "single_mul_apply_of_not_exists_add":
 "theorem single_mul_apply_of_not_exists_add [Add G] (r : k) {g g' : G} (x : AddMonoidAlgebra k G)\n    (h : ¬∃ d, g' = g + d) : (Finsupp.single g r * x : AddMonoidAlgebra k G) g' = 0 :=\n  @MonoidAlgebra.single_mul_apply_of_not_exists_mul k (Multiplicative G) _ _ _ _ _ _ h\n#align single_mul_apply_of_not_exists_add single_mul_apply_of_not_exists_add\n\n",
 "single_mul_apply_aux":
 "theorem single_mul_apply_aux [Add G] (f : AddMonoidAlgebra k G) (r : k) (x y z : G) (H : ∀ a, x + a = y ↔ a = z) :\n    (single x r * f : AddMonoidAlgebra k G) y = r * f z :=\n  @MonoidAlgebra.single_mul_apply_aux k (Multiplicative G) _ _ _ _ _ _ _ H\n#align single_mul_apply_aux single_mul_apply_aux\n\n",
 "single_mul_apply":
 "theorem single_mul_apply [AddGroup G] (r : k) (x : G) (f : AddMonoidAlgebra k G) (y : G) :\n    (single x r * f : AddMonoidAlgebra k G) y = r * f (-x + y) :=\n  @MonoidAlgebra.single_mul_apply k (Multiplicative G) _ _ _ _ _ _\n#align single_mul_apply single_mul_apply\n\n",
 "single_eq_algebra_map_mul_of":
 "theorem single_eq_algebra_map_mul_of [CommSemiring k] [Monoid G] (a : G) (b : k) :\n    single a b = algebraMap k (MonoidAlgebra k G) b * of k G a := by simp\n#align single_eq_algebra_map_mul_of single_eq_algebra_map_mul_of\n\n",
 "single_algebra_map_eq_algebra_map_mul_of":
 "theorem single_algebra_map_eq_algebra_map_mul_of {A : Type _} [CommSemiring k] [Semiring A] [Algebra k A] [Monoid G]\n    (a : G) (b : k) : single a (algebraMap k A b) = algebraMap k (MonoidAlgebra A G) b * of A G a := by simp\n#align single_algebra_map_eq_algebra_map_mul_of single_algebra_map_eq_algebra_map_mul_of\n\n",
 "ring_hom_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- If two ring homomorphisms from `add_monoid_algebra k G` are equal on all `single a 1`\nand `single 0 b`, then they are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem ring_hom_ext' {R} [Semiring k] [AddMonoid G] [Semiring R] {f g : «expr →+* » (AddMonoidAlgebra k G) R}\n    (h₁ : f.comp singleZeroRingHom = g.comp singleZeroRingHom)\n    (h_of :\n      (f : «expr →* » (AddMonoidAlgebra k G) R).comp (of k G) =\n        (g : «expr →* » (AddMonoidAlgebra k G) R).comp (of k G)) :\n    f = g :=\n  ringHom_ext (RingHom.congr_fun h₁) (MonoidHom.congr_fun h_of)\n#align ring_hom_ext' ring_hom_ext'\n\n",
 "ring_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If two ring homomorphisms from `add_monoid_algebra k G` are equal on all `single a 1`\nand `single 0 b`, then they are equal. -/\ntheorem ring_hom_ext {R} [Semiring k] [AddMonoid G] [Semiring R] {f g : «expr →+* » (AddMonoidAlgebra k G) R}\n    (h₀ : ∀ b, f (single 0 b) = g (single 0 b)) (h_of : ∀ a, f (single a 1) = g (single a 1)) : f = g :=\n  @MonoidAlgebra.ringHom_ext k (Multiplicative G) R _ _ _ _ _ h₀ h_of\n#align ring_hom_ext ring_hom_ext\n\n",
 "prod_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_single [CommSemiring k] [AddCommMonoid G] {s : Finset ι} {a : ι → G} {b : ι → k} :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (single (a i) (b i)) =\n      single (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (a i))\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (b i)) :=\n  Finset.cons_induction_on s rfl fun a s has ih => by\n    rw [prod_cons has, ih, single_mul_single, sum_cons has, prod_cons has]\n#align prod_single prod_single\n\n",
 "op_ring_equiv_symm_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[simp]\ntheorem op_ring_equiv_symm_single [AddCommMonoid G] (r : «expr ᵐᵒᵖ» k) (x : «expr ᵐᵒᵖ» G) :\n    AddMonoidAlgebra.opRingEquiv.symm (single x r) = op (single x r.unop) := by simp\n#align op_ring_equiv_symm_single op_ring_equiv_symm_single\n\n",
 "op_ring_equiv_single":
 "@[simp]\ntheorem op_ring_equiv_single [AddCommMonoid G] (r : k) (x : G) :\n    AddMonoidAlgebra.opRingEquiv (op (single x r)) = single x (op r) := by simp\n#align op_ring_equiv_single op_ring_equiv_single\n\n",
 "one_def":
 "theorem one_def : (1 : AddMonoidAlgebra k G) = single 0 1 :=\n  rfl\n#align one_def one_def\n\n",
 "of_injective":
 "theorem of_injective [Nontrivial k] [AddZeroClass G] : function.injective (of k G) := fun a b h => by\n  simpa using (single_eq_single_iff _ _ _ _).mp h\n#align of_injective of_injective\n\n",
 "of_apply":
 "@[simp]\ntheorem of_apply [AddZeroClass G] (a : Multiplicative G) : of k G a = single a.to_add 1 :=\n  rfl\n#align of_apply of_apply\n\n",
 "of'_eq_of":
 "theorem of'_eq_of [AddZeroClass G] (a : G) : of' k G a = of k G a :=\n  rfl\n#align of'_eq_of of'_eq_of\n\n",
 "of'_apply":
 "@[simp]\ntheorem of'_apply (a : G) : of' k G a = single a 1 :=\n  rfl\n#align of'_apply of'_apply\n\n",
 "non_unital_alg_hom_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙₐ[ ] » -/\n/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem non_unital_alg_hom_ext' [DistribMulAction k A] {φ₁ φ₂ : «expr →ₙₐ[ ] » (AddMonoidAlgebra k G) k A}\n    (h : φ₁.to_mul_hom.comp (ofMagma k G) = φ₂.to_mul_hom.comp (ofMagma k G)) : φ₁ = φ₂ :=\n  @MonoidAlgebra.nonUnitalAlgHom_ext' k (Multiplicative G) _ _ _ _ _ φ₁ φ₂ h\n#align non_unital_alg_hom_ext' non_unital_alg_hom_ext'\n\n",
 "non_unital_alg_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙₐ[ ] » -/\n/-- A non_unital `k`-algebra homomorphism from `add_monoid_algebra k G` is uniquely defined by its\nvalues on the functions `single a 1`. -/\ntheorem non_unital_alg_hom_ext [DistribMulAction k A] {φ₁ φ₂ : «expr →ₙₐ[ ] » (AddMonoidAlgebra k G) k A}\n    (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=\n  @MonoidAlgebra.nonUnitalAlgHom_ext k (Multiplicative G) _ _ _ _ _ φ₁ φ₂ h\n#align non_unital_alg_hom_ext non_unital_alg_hom_ext\n\n",
 "nat_cast_def":
 "theorem nat_cast_def (n : ℕ) : (n : AddMonoidAlgebra k G) = single 0 n :=\n  rfl\n#align nat_cast_def nat_cast_def\n\n",
 "mul_single_zero_apply":
 "theorem mul_single_zero_apply [AddZeroClass G] (f : AddMonoidAlgebra k G) (r : k) (x : G) :\n    (f * single 0 r) x = f x * r :=\n  f.mul_single_apply_aux r _ _ _ fun a => by rw [add_zero]\n#align mul_single_zero_apply mul_single_zero_apply\n\n",
 "mul_single_one_apply":
 "theorem mul_single_one_apply [MulOneClass G] (f : MonoidAlgebra k G) (r : k) (x : G) : (f * single 1 r) x = f x * r :=\n  f.mul_single_apply_aux fun a => by rw [mul_one]\n#align mul_single_one_apply mul_single_one_apply\n\n",
 "mul_single_apply_of_not_exists_mul":
 "theorem mul_single_apply_of_not_exists_mul [Mul G] (r : k) {g g' : G} (x : MonoidAlgebra k G) (h : ¬∃ d, g' = d * g) :\n    (x * Finsupp.single g r : MonoidAlgebra k G) g' = 0 := by\n  classical\n    rw [mul_apply, Finsupp.sum_comm, Finsupp.sum_single_index]\n    swap\n    · simp_rw [Finsupp.sum, MulZeroClass.mul_zero, if_t_t, Finset.sum_const_zero]\n    · apply Finset.sum_eq_zero\n      simp_rw [ite_eq_right_iff]\n      rintro g'' hg'' rfl\n      exfalso\n      exact h ⟨_, rfl⟩\n#align mul_single_apply_of_not_exists_mul mul_single_apply_of_not_exists_mul\n\n",
 "mul_single_apply_of_not_exists_add":
 "theorem mul_single_apply_of_not_exists_add [Add G] (r : k) {g g' : G} (x : AddMonoidAlgebra k G)\n    (h : ¬∃ d, g' = d + g) : (x * Finsupp.single g r : AddMonoidAlgebra k G) g' = 0 :=\n  @MonoidAlgebra.mul_single_apply_of_not_exists_mul k (Multiplicative G) _ _ _ _ _ _ h\n#align mul_single_apply_of_not_exists_add mul_single_apply_of_not_exists_add\n\n",
 "mul_single_apply_aux":
 "theorem mul_single_apply_aux [Add G] (f : AddMonoidAlgebra k G) (r : k) (x y z : G) (H : ∀ a, a + x = z ↔ a = y) :\n    (f * single x r) z = f y * r :=\n  @MonoidAlgebra.mul_single_apply_aux k (Multiplicative G) _ _ _ _ _ _ _ H\n#align mul_single_apply_aux mul_single_apply_aux\n\n",
 "mul_single_apply":
 "theorem mul_single_apply [AddGroup G] (f : AddMonoidAlgebra k G) (r : k) (x y : G) :\n    (f * single x r) y = f (y - x) * r :=\n  (sub_eq_add_neg y x).symm ▸ @MonoidAlgebra.mul_single_apply k (Multiplicative G) _ _ _ _ _ _\n#align mul_single_apply mul_single_apply\n\n",
 "mul_def":
 "theorem mul_def {f g : AddMonoidAlgebra k G} :\n    f * g = f.sum fun a₁ b₁ => g.sum fun a₂ b₂ => single (a₁ + a₂) (b₁ * b₂) :=\n  rfl\n#align mul_def mul_def\n\n",
 "mul_apply_right":
 "-- If we'd assumed `comm_semiring`, we could deduce this from `mul_apply_left`.\ntheorem mul_apply_right (f g : MonoidAlgebra k G) (x : G) : (f * g) x = g.sum fun a b => f (x * a⁻¹) * b :=\n  calc\n    (f * g) x = Sum g fun a b => (f * single a b) x := by rw [← Finsupp.sum_apply, ← Finsupp.mul_sum, g.sum_single]\n    _ = _ := by simp only [mul_single_apply, Finsupp.sum]\n    \n#align mul_apply_right mul_apply_right\n\n",
 "mul_apply_left":
 "theorem mul_apply_left (f g : MonoidAlgebra k G) (x : G) : (f * g) x = f.sum fun a b => b * g (a⁻¹ * x) :=\n  calc\n    (f * g) x = Sum f fun a b => (single a b * g) x := by rw [← Finsupp.sum_apply, ← Finsupp.sum_mul, f.sum_single]\n    _ = _ := by simp only [single_mul_apply, Finsupp.sum]\n    \n#align mul_apply_left mul_apply_left\n\n",
 "mul_apply_antidiagonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mul_apply_antidiagonal [Add G] (f g : AddMonoidAlgebra k G) (x : G) (s : Finset (G × G))\n    (hs : ∀ {p : G × G}, p ∈ s ↔ p.1 + p.2 = x) :\n    (f * g) x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (f p.1 * g p.2) :=\n  @MonoidAlgebra.mul_apply_antidiagonal k (Multiplicative G) _ _ _ _ _ s @hs\n#align mul_apply_antidiagonal mul_apply_antidiagonal\n\n",
 "mul_apply":
 "theorem mul_apply [DecidableEq G] [Add G] (f g : AddMonoidAlgebra k G) (x : G) :\n    (f * g) x = f.sum fun a₁ b₁ => g.sum fun a₂ b₂ => if a₁ + a₂ = x then b₁ * b₂ else 0 :=\n  @MonoidAlgebra.mul_apply k (Multiplicative G) _ _ _ _ _ _\n#align mul_apply mul_apply\n\n",
 "map_domain_one":
 "/-- Like `finsupp.map_domain_zero`, but for the `1` we define in this file -/\n@[simp]\ntheorem map_domain_one {α : Type _} {β : Type _} {α₂ : Type _} [Semiring β] [Zero α] [Zero α₂] {F : Type _}\n    [ZeroHomClass F α α₂] (f : F) :\n    (mapDomain f (1 : AddMonoidAlgebra β α) : AddMonoidAlgebra β α₂) = (1 : AddMonoidAlgebra β α₂) := by\n  simp_rw [one_def, map_domain_single, map_zero]\n#align map_domain_one map_domain_one\n\n",
 "map_domain_mul":
 "/-- Like `finsupp.map_domain_add`, but for the convolutive multiplication we define in this file -/\ntheorem map_domain_mul {α : Type _} {β : Type _} {α₂ : Type _} [Semiring β] [Add α] [Add α₂] {F : Type _}\n    [AddHomClass F α α₂] (f : F) (x y : AddMonoidAlgebra β α) :\n    (mapDomain f (x * y : AddMonoidAlgebra β α) : AddMonoidAlgebra β α₂) =\n      (mapDomain f x * mapDomain f y : AddMonoidAlgebra β α₂) :=\n  by\n  simp_rw [mul_def, map_domain_sum, map_domain_single, map_add]\n  rw [Finsupp.sum_mapDomain_index]\n  · congr\n    ext (a b)\n    rw [Finsupp.sum_mapDomain_index]\n    · simp\n    · simp [mul_add]\n  · simp\n  · simp [add_mul]\n#align map_domain_mul map_domain_mul\n\n",
 "map_domain_algebra_map":
 "theorem map_domain_algebra_map {A H F : Type _} [CommSemiring k] [Semiring A] [Algebra k A] [AddMonoid G] [AddMonoid H]\n    [AddMonoidHomClass F G H] (f : F) (r : k) :\n    mapDomain f (algebraMap k (AddMonoidAlgebra A G) r) = algebraMap k (AddMonoidAlgebra A H) r := by\n  simp only [Function.comp_apply, map_domain_single, AddMonoidAlgebra.coe_algebraMap, map_zero]\n#align map_domain_algebra_map map_domain_algebra_map\n\n",
 "linear_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem group_smul.linear_map_apply [Monoid G] [CommSemiring k] (V : Type u₃) [AddCommMonoid V] [Module k V]\n    [Module (MonoidAlgebra k G) V] [IsScalarTower k (MonoidAlgebra k G) V] (g : G) (v : V) :\n    (GroupSmul.linearMap k V g) v = («expr • » (single g (1 : k)) v : V) :=\n  rfl\n#align group_smul.linear_map_apply group_smul.linear_map_apply\n\n",
 "lift_unique'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem lift_unique' (F : «expr →ₐ[ ] » (AddMonoidAlgebra k G) k A) :\n    F = lift k G A ((F : «expr →* » (AddMonoidAlgebra k G) A).comp (of k G)) :=\n  ((lift k G A).apply_symm_apply F).symm\n#align lift_unique' lift_unique'\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Decomposition of a `k`-algebra homomorphism from `monoid_algebra k G` by\nits values on `F (single a 1)`. -/\ntheorem lift_unique (F : «expr →ₐ[ ] » (AddMonoidAlgebra k G) k A) (f : MonoidAlgebra k G) :\n    F f = f.sum fun a b => «expr • » b (F (single a 1)) := by\n  conv_lhs =>\n    rw [lift_unique' F]\n    simp [lift_apply]\n#align lift_unique lift_unique\n\n",
 "lift_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem lift_symm_apply (F : «expr →ₐ[ ] » (AddMonoidAlgebra k G) k A) (x : Multiplicative G) :\n    (lift k G A).symm F x = F (single x.to_add 1) :=\n  rfl\n#align lift_symm_apply lift_symm_apply\n\n",
 "lift_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem lift_single (F : «expr →* » (Multiplicative G) A) (a b) :\n    lift k G A F (single a b) = «expr • » b (F (Multiplicative.ofAdd a)) := by\n  rw [lift_def, lift_nc_single, Algebra.smul_def, [anonymous]]\n#align lift_single lift_single\n\n",
 "lift_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem lift_of (F : «expr →* » (Multiplicative G) A) (x : Multiplicative G) : lift k G A F (of k G x) = F x := by\n  rw [of_apply, ← lift_symm_apply, Equiv.symm_apply_apply]\n#align lift_of lift_of\n\n",
 "lift_nc_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\ntheorem lift_nc_smul {R : Type _} [AddZeroClass G] [Semiring R] (f : «expr →+* » k R)\n    (g : «expr →* » (Multiplicative G) R) (c : k) (φ : MonoidAlgebra k G) :\n    liftNC (f : «expr →+ » k R) g («expr • » c φ) = f c * liftNC (f : «expr →+ » k R) g φ :=\n  @MonoidAlgebra.liftNC_smul k (Multiplicative G) _ _ _ _ f g c φ\n#align lift_nc_smul lift_nc_smul\n\n",
 "lift_nc_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n@[simp]\ntheorem lift_nc_single (f : «expr →+ » k R) (g : Multiplicative G → R) (a : G) (b : k) :\n    liftNC f g (single a b) = f b * g (Multiplicative.ofAdd a) :=\n  liftAddHom_apply_single _ _ _\n#align lift_nc_single lift_nc_single\n\n",
 "lift_nc_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n@[simp]\ntheorem lift_nc_one {g_hom : Type _} [OneHomClass g_hom (Multiplicative G) R] (f : «expr →+* » k R) (g : g_hom) :\n    liftNC (f : «expr →+ » k R) g 1 = 1 :=\n  (MonoidAlgebra.liftNC_one f g : _)\n#align lift_nc_one lift_nc_one\n\n",
 "lift_nc_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\ntheorem lift_nc_mul {g_hom : Type _} [MulHomClass g_hom (Multiplicative G) R] (f : «expr →+* » k R) (g : g_hom)\n    (a b : AddMonoidAlgebra k G) (h_comm : ∀ {x y}, y ∈ a.support → Commute (f (b x)) (g <| Multiplicative.ofAdd y)) :\n    liftNC (f : «expr →+ » k R) g (a * b) = liftNC (f : «expr →+ » k R) g a * liftNC (f : «expr →+ » k R) g b :=\n  (MonoidAlgebra.liftNC_mul f g _ _ @h_comm : _)\n#align lift_nc_mul lift_nc_mul\n\n",
 "lift_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\ntheorem lift_def (F : «expr →* » (Multiplicative G) A) :\n    «expr⇑ » (lift k G A F) = liftNC ((algebraMap k A : «expr →+* » k A) : «expr →+ » k A) F :=\n  rfl\n#align lift_def lift_def\n\n",
 "lift_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem lift_apply' (F : «expr →* » (Multiplicative G) A) (f : MonoidAlgebra k G) :\n    lift k G A F f = f.sum fun a b => algebraMap k A b * F (Multiplicative.ofAdd a) :=\n  rfl\n#align lift_apply' lift_apply'\n\n",
 "lift_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem lift_apply (F : «expr →* » (Multiplicative G) A) (f : MonoidAlgebra k G) :\n    lift k G A F f = f.sum fun a b => «expr • » b (F (Multiplicative.ofAdd a)) := by\n  simp only [lift_apply', Algebra.smul_def]\n#align lift_apply lift_apply\n\n",
 "int_cast_def":
 "theorem int_cast_def [Ring k] [AddZeroClass G] (z : ℤ) : (z : AddMonoidAlgebra k G) = single 0 z :=\n  rfl\n#align int_cast_def int_cast_def\n\n",
 "induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem induction_on [AddMonoid G] {p : AddMonoidAlgebra k G → Prop} (f : AddMonoidAlgebra k G)\n    (hM : ∀ g, p (of k G (Multiplicative.ofAdd g))) (hadd : ∀ f g : AddMonoidAlgebra k G, p f → p g → p (f + g))\n    (hsmul : ∀ (r : k) (f), p f → p («expr • » r f)) : p f :=\n  by\n  refine' Finsupp.induction_linear f _ (fun f g hf hg => hadd f g hf hg) fun g r => _\n  · simpa using hsmul 0 (of k G (Multiplicative.ofAdd 0)) (hM 0)\n  · convert hsmul r (of k G (Multiplicative.ofAdd g)) (hM g)\n    simp only [mul_one, toAdd_ofAdd, smul_single', of_apply]\n#align induction_on induction_on\n\n",
 "equivariant_of_linear_of_comm_apply":
 "@[simp]\ntheorem equivariant_of_linear_of_comm_apply (v : V) : (equivariantOfLinearOfComm f h) v = f v :=\n  rfl\n#align equivariant_of_linear_of_comm_apply equivariant_of_linear_of_comm_apply\n\n",
 "coe_algebra_map":
 "@[simp]\ntheorem coe_algebra_map [CommSemiring R] [Semiring k] [Algebra R k] [AddMonoid G] :\n    (algebraMap R (AddMonoidAlgebra k G) : R → AddMonoidAlgebra k G) = single 0 ∘ algebraMap R k :=\n  rfl\n#align coe_algebra_map coe_algebra_map\n\n",
 "alg_hom_ext_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem alg_hom_ext_iff {φ₁ φ₂ : «expr →ₐ[ ] » (AddMonoidAlgebra k G) k A} :\n    (∀ x, φ₁ (Finsupp.single x 1) = φ₂ (Finsupp.single x 1)) ↔ φ₁ = φ₂ :=\n  ⟨fun h => algHom_ext h, by rintro rfl _ <;> rfl⟩\n#align alg_hom_ext_iff alg_hom_ext_iff\n\n",
 "alg_hom_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem alg_hom_ext' ⦃φ₁ φ₂ : «expr →ₐ[ ] » (AddMonoidAlgebra k G) k A⦄\n    (h :\n      (φ₁ : «expr →* » (AddMonoidAlgebra k G) A).comp (of k G) =\n        (φ₂ : «expr →* » (AddMonoidAlgebra k G) A).comp (of k G)) :\n    φ₁ = φ₂ :=\n  algHom_ext <| MonoidHom.congr_fun h\n#align alg_hom_ext' alg_hom_ext'\n\n",
 "alg_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- A `k`-algebra homomorphism from `monoid_algebra k G` is uniquely defined by its\nvalues on the functions `single a 1`. -/\ntheorem alg_hom_ext ⦃φ₁ φ₂ : «expr →ₐ[ ] » (AddMonoidAlgebra k G) k A⦄ (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) :\n    φ₁ = φ₂ :=\n  @MonoidAlgebra.algHom_ext k (Multiplicative G) _ _ _ _ _ _ _ h\n#align alg_hom_ext alg_hom_ext\n\n"}