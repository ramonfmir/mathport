{"support_single_mul_subset":
 "/-\nCopyright (c) 2022 Damiano Testa. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Damiano Testa\n-/\ntheorem support_single_mul_subset [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) (r : k) (a : G) :\n    (single a r * f : MonoidAlgebra k G).support ⊆ Finset.image ((· * ·) a) f.support :=\n  by\n  intro x hx\n  contrapose hx\n  have : ∀ y, a * y = x → f y = 0 := by\n    simpa only [not_and', mem_image, mem_support_iff, exists_prop, not_exists, Classical.not_not] using hx\n  simp only [mem_support_iff, mul_apply, sum_single_index, MulZeroClass.zero_mul, if_t_t, sum_zero, Classical.not_not]\n  exact\n    Finset.sum_eq_zero\n      (by\n        simp (config := { contextual := true }) only [this, mem_support_iff, MulZeroClass.mul_zero, ne.def,\n          ite_eq_right_iff, eq_self_iff_true, imp_true_iff])\n#align support_single_mul_subset support_single_mul_subset\n\n",
 "support_single_mul_eq_image":
 "theorem support_single_mul_eq_image [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) {r : k}\n    (hr : ∀ y, r * y = 0 ↔ y = 0) {x : G} (lx : IsLeftRegular x) :\n    (single x r * f : MonoidAlgebra k G).support = Finset.image ((· * ·) x) f.support :=\n  by\n  refine' subset_antisymm (support_single_mul_subset f _ _) fun y hy => _\n  obtain ⟨y, yf, rfl⟩ : ∃ a : G, a ∈ f.support ∧ x * a = y := by simpa only [Finset.mem_image, exists_prop] using hy\n  simp only [mul_apply, mem_support_iff.mp yf, hr, mem_support_iff, sum_single_index, Finsupp.sum_ite_eq', ne.def,\n    not_false_iff, if_true, MulZeroClass.zero_mul, if_t_t, sum_zero, lx.eq_iff]\n#align support_single_mul_eq_image support_single_mul_eq_image\n\n",
 "support_single_mul":
 "theorem support_single_mul [AddLeftCancelSemigroup G] (f : AddMonoidAlgebra k G) (r : k) (hr : ∀ y, r * y = 0 ↔ y = 0)\n    (x : G) : (single x r * f : AddMonoidAlgebra k G).support = f.support.map (addLeftEmbedding x) :=\n  @MonoidAlgebra.support_single_mul k (Multiplicative G) _ _ _ _ hr _\n#align support_single_mul support_single_mul\n\n",
 "support_mul_single_subset":
 "theorem support_mul_single_subset [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) (r : k) (a : G) :\n    (f * single a r).support ⊆ Finset.image (· * a) f.support :=\n  by\n  intro x hx\n  contrapose hx\n  have : ∀ y, y * a = x → f y = 0 := by\n    simpa only [not_and', mem_image, mem_support_iff, exists_prop, not_exists, Classical.not_not] using hx\n  simp only [mem_support_iff, mul_apply, sum_single_index, MulZeroClass.zero_mul, if_t_t, sum_zero, Classical.not_not]\n  exact\n    Finset.sum_eq_zero\n      (by\n        simp (config := { contextual := true }) only [this, sum_single_index, ite_eq_right_iff, eq_self_iff_true,\n          imp_true_iff, MulZeroClass.zero_mul])\n#align support_mul_single_subset support_mul_single_subset\n\n",
 "support_mul_single_eq_image":
 "theorem support_mul_single_eq_image [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) {r : k}\n    (hr : ∀ y, y * r = 0 ↔ y = 0) {x : G} (rx : IsRightRegular x) :\n    (f * single x r).support = Finset.image (· * x) f.support :=\n  by\n  refine' subset_antisymm (support_mul_single_subset f _ _) fun y hy => _\n  obtain ⟨y, yf, rfl⟩ : ∃ a : G, a ∈ f.support ∧ a * x = y := by simpa only [Finset.mem_image, exists_prop] using hy\n  simp only [mul_apply, mem_support_iff.mp yf, hr, mem_support_iff, sum_single_index, Finsupp.sum_ite_eq', ne.def,\n    not_false_iff, if_true, MulZeroClass.mul_zero, if_t_t, sum_zero, rx.eq_iff]\n#align support_mul_single_eq_image support_mul_single_eq_image\n\n",
 "support_mul_single":
 "theorem support_mul_single [AddRightCancelSemigroup G] (f : AddMonoidAlgebra k G) (r : k) (hr : ∀ y, y * r = 0 ↔ y = 0)\n    (x : G) : (f * single x r : AddMonoidAlgebra k G).support = f.support.map (addRightEmbedding x) :=\n  @MonoidAlgebra.support_mul_single k (Multiplicative G) _ _ _ _ hr _\n#align support_mul_single support_mul_single\n\n",
 "support_mul":
 "theorem support_mul [DecidableEq G] [Add G] (a b : AddMonoidAlgebra k G) :\n    (a * b).support ⊆ a.support.bUnion fun a₁ => b.support.bUnion fun a₂ => {a₁ + a₂} :=\n  @MonoidAlgebra.support_mul k (Multiplicative G) _ _ _ _ _\n#align support_mul support_mul\n\n",
 "mem_span_support'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- An element of `add_monoid_algebra k G` is in the subalgebra generated by its support, using\nunbundled inclusion. -/\ntheorem mem_span_support' (f : AddMonoidAlgebra k G) :\n    f ∈ Submodule.span k («expr '' » (of' k G) (f.support : Set G)) := by\n  rw [of', ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]\n#align mem_span_support' mem_span_support'\n\n",
 "mem_span_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- An element of `add_monoid_algebra k G` is in the submodule generated by its support. -/\ntheorem mem_span_support [AddZeroClass G] (f : AddMonoidAlgebra k G) :\n    f ∈ Submodule.span k («expr '' » (of k G) (f.support : Set G)) := by\n  rw [of, MonoidHom.coe_mk, ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]\n#align mem_span_support mem_span_support\n\n"}