{"of_right_ordered":
 "/-- If `R` is a semiring with no non-trivial zero-divisors and `A` is a right-ordered add left\ncancel semigroup, then `add_monoid_algebra R A` also contains no non-zero zero-divisors. -/\ntheorem no_zero_divisors.of_right_ordered [NoZeroDivisors R] [AddLeftCancelSemigroup A] [linear_order A]\n    [CovariantClass A A (function.swap (· + ·)) (· < ·)] : NoZeroDivisors (AddMonoidAlgebra R A) :=\n  ⟨fun f g fg => by\n    contrapose! fg\n    let fmin : A := f.support.min' (support_nonempty_iff.mpr fg.1)\n    refine' support_nonempty_iff.mp _\n    obtain ⟨a, ha, H⟩ :=\n      left.exists_add_of_mem_support_single_mul fmin\n        ((single fmin 1 * g : AddMonoidAlgebra R A).support.min'\n          (by rw [support_single_mul] <;> simp [support_nonempty_iff.mpr fg.2]))\n        (Finset.min'_mem _ _)\n    refine' ⟨fmin + a, mem_support_iff.mpr _⟩\n    rw [mul_apply_add_eq_mul_of_forall_ne _]\n    · refine' mul_ne_zero _ _\n      exacts[mem_support_iff.mp (Finset.min'_mem _ _), mem_support_iff.mp ha]\n    · rw [H]\n      rintro b c bf cg (hb | hc) <;> refine' ne_of_gt _\n      · refine' lt_of_le_of_lt (_ : _ ≤ fmin + c) _\n        · apply Finset.min'_le\n          rw [support_single_mul _ _ (fun y => by rw [one_mul] : ∀ y : R, 1 * y = 0 ↔ _)]\n          simp only [cg, Finset.mem_map, addLeftEmbedding_apply, add_right_inj, exists_prop, exists_eq_right]\n        · refine' add_lt_add_right _ _\n          exact Finset.min'_lt_of_mem_erase_min' _ _ (finset.mem_erase.mpr ⟨hb, bf⟩)\n      · refine' lt_of_lt_of_le (_ : _ < fmin + c) _\n        · apply Finset.min'_lt_of_mem_erase_min'\n          rw [← H]\n          apply Finset.mem_erase_of_ne_of_mem\n          · simpa only [ne.def, add_right_inj]\n          · rw [support_single_mul _ _ (fun y => by rw [one_mul] : ∀ y : R, 1 * y = 0 ↔ _)]\n            simpa only [Finset.mem_map, addLeftEmbedding_apply, add_right_inj, exists_prop, exists_eq_right]\n        · haveI : CovariantClass A A (function.swap (· + ·)) (· ≤ ·) := Add.to_covariantClass_right A\n          exact add_le_add_right (Finset.min'_le _ _ bf) _⟩\n#align no_zero_divisors.of_right_ordered no_zero_divisors.of_right_ordered\n\n",
 "of_left_ordered":
 "/-- If `R` is a semiring with no non-trivial zero-divisors and `A` is a left-ordered add right\ncancel semigroup, then `add_monoid_algebra R A` also contains no non-zero zero-divisors. -/\ntheorem no_zero_divisors.of_left_ordered [NoZeroDivisors R] [AddRightCancelSemigroup A] [linear_order A]\n    [CovariantClass A A (· + ·) (· < ·)] : NoZeroDivisors (AddMonoidAlgebra R A) :=\n  ⟨fun f g fg => by\n    contrapose! fg\n    let gmin : A := g.support.min' (support_nonempty_iff.mpr fg.2)\n    refine' support_nonempty_iff.mp _\n    obtain ⟨a, ha, H⟩ :=\n      right.exists_add_of_mem_support_single_mul gmin\n        ((f * single gmin 1 : AddMonoidAlgebra R A).support.min'\n          (by rw [support_mul_single] <;> simp [support_nonempty_iff.mpr fg.1]))\n        (Finset.min'_mem _ _)\n    refine' ⟨a + gmin, mem_support_iff.mpr _⟩\n    rw [mul_apply_add_eq_mul_of_forall_ne _]\n    · refine' mul_ne_zero _ _\n      exacts[mem_support_iff.mp ha, mem_support_iff.mp (Finset.min'_mem _ _)]\n    · rw [H]\n      rintro b c bf cg (hb | hc) <;> refine' ne_of_gt _\n      · refine' lt_of_lt_of_le (_ : _ < b + gmin) _\n        · apply Finset.min'_lt_of_mem_erase_min'\n          rw [← H]\n          apply Finset.mem_erase_of_ne_of_mem\n          · simpa only [ne.def, add_left_inj]\n          · rw [support_mul_single _ _ (fun y => by rw [mul_one] : ∀ y : R, y * 1 = 0 ↔ _)]\n            simpa only [Finset.mem_map, addRightEmbedding_apply, add_left_inj, exists_prop, exists_eq_right]\n        · haveI : CovariantClass A A (· + ·) (· ≤ ·) := Add.to_covariantClass_left A\n          exact add_le_add_left (Finset.min'_le _ _ cg) _\n      · refine' lt_of_le_of_lt (_ : _ ≤ b + gmin) _\n        · apply Finset.min'_le\n          rw [support_mul_single _ _ (fun y => by rw [mul_one] : ∀ y : R, y * 1 = 0 ↔ _)]\n          simp only [bf, Finset.mem_map, addRightEmbedding_apply, add_left_inj, exists_prop, exists_eq_right]\n        · refine' add_lt_add_left _ _\n          exact Finset.min'_lt_of_mem_erase_min' _ _ (finset.mem_erase.mpr ⟨hc, cg⟩)⟩\n#align no_zero_divisors.of_left_ordered no_zero_divisors.of_left_ordered\n\n",
 "mul_apply_add_eq_mul_of_forall_ne":
 "/-\nCopyright (c) 2022 Damiano Testa. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Damiano Testa\n-/\n/-- The coefficient of a monomial in a product `f * g` that can be reached in at most one way\nas a product of monomials in the supports of `f` and `g` is a product. -/\ntheorem mul_apply_add_eq_mul_of_forall_ne [Add A] {f g : AddMonoidAlgebra R A} {a0 b0 : A}\n    (h : ∀ {a b : A}, a ∈ f.support → b ∈ g.support → a ≠ a0 ∨ b ≠ b0 → a + b ≠ a0 + b0) :\n    (f * g) (a0 + b0) = f a0 * g b0 := by\n  classical\n    rw [mul_apply]\n    refine' (Finset.sum_eq_single a0 _ _).trans _\n    · exact fun b H hb => Finset.sum_eq_zero fun x H1 => if_neg (h H H1 (or.inl hb))\n    · exact fun af0 => by simp [not_mem_support_iff.mp af0]\n    · refine' (Finset.sum_eq_single b0 (fun b bg b0 => _) _).trans (if_pos rfl)\n      · by_cases af : a0 ∈ f.support\n        · exact if_neg (h af bg (or.inr b0))\n        · simp only [not_mem_support_iff.mp af, MulZeroClass.zero_mul, if_t_t]\n      · exact fun bf0 => by simp [not_mem_support_iff.mp bf0]\n#align mul_apply_add_eq_mul_of_forall_ne mul_apply_add_eq_mul_of_forall_ne\n\n",
 "exists_add_of_mem_support_single_mul":
 "theorem right.exists_add_of_mem_support_single_mul [AddRightCancelSemigroup A] {f : AddMonoidAlgebra R A} (b x : A)\n    (hx : x ∈ (f * single b 1 : AddMonoidAlgebra R A).support) : ∃ a ∈ f.support, a + b = x := by\n  rwa [support_mul_single _ _ (fun y => by rw [mul_one] : ∀ y : R, y * 1 = 0 ↔ _), Finset.mem_map] at hx\n#align right.exists_add_of_mem_support_single_mul right.exists_add_of_mem_support_single_mul\n\n"}