{"sup_support_pow_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sup_support_pow_le (degb0 : degb 0 ≤ 0) (degbm : ∀ a b, degb (a + b) ≤ degb a + degb b) (n : ℕ)\n    (f : AddMonoidAlgebra R A) : (f ^ n).support.sup degb ≤ «expr • » n (f.support.sup degb) :=\n  by\n  rw [← List.prod_replicate, ← List.sum_replicate]\n  refine' (sup_support_list_prod_le degb0 degbm _).trans_eq _\n  rw [List.map_replicate]\n#align sup_support_pow_le sup_support_pow_le\n\n",
 "sup_support_multiset_prod_le":
 "theorem sup_support_multiset_prod_le (degb0 : degb 0 ≤ 0) (degbm : ∀ a b, degb (a + b) ≤ degb a + degb b)\n    (m : Multiset (AddMonoidAlgebra R A)) :\n    m.prod.support.sup degb ≤ (m.map fun f : AddMonoidAlgebra R A => f.support.sup degb).sum :=\n  by\n  induction m using Quot.inductionOn\n  rw [Multiset.quot_mk_to_coe'', Multiset.coe_map, Multiset.coe_sum, Multiset.coe_prod]\n  exact sup_support_list_prod_le degb0 degbm m\n#align sup_support_multiset_prod_le sup_support_multiset_prod_le\n\n",
 "sup_support_mul_le":
 "theorem sup_support_mul_le {degb : A → B} (degbm : ∀ {a b}, degb (a + b) ≤ degb a + degb b)\n    (f g : AddMonoidAlgebra R A) : (f * g).support.sup degb ≤ f.support.sup degb + g.support.sup degb :=\n  by\n  refine' (Finset.sup_mono <| support_mul _ _).trans _\n  simp_rw [Finset.sup_bunionᵢ, Finset.sup_singleton]\n  refine' Finset.sup_le fun fd fds => Finset.sup_le fun gd gds => degbm.trans <| add_le_add _ _ <;>\n    exact Finset.le_sup ‹_›\n#align sup_support_mul_le sup_support_mul_le\n\n",
 "sup_support_list_prod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem sup_support_list_prod_le (degb0 : degb 0 ≤ 0) (degbm : ∀ a b, degb (a + b) ≤ degb a + degb b) :\n    ∀ l : List (AddMonoidAlgebra R A),\n      l.prod.support.sup degb ≤ (l.map fun f : AddMonoidAlgebra R A => f.support.sup degb).sum\n  | [] => by\n    rw [List.map_nil, Finset.sup_le_iff, List.prod_nil, List.sum_nil]\n    exact fun a ha => by rwa [finset.mem_singleton.mp (Finsupp.support_single_subset ha)]\n  | sym.cons' f fs => by\n    rw [List.prod_cons, list.map_cons, List.sum_cons]\n    exact (sup_support_mul_le degbm _ _).trans (add_le_add_left (sup_support_list_prod_le _) _)\n#align sup_support_list_prod_le sup_support_list_prod_le\n\n",
 "sup_support_finset_prod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sup_support_finset_prod_le (degb0 : degb 0 ≤ 0) (degbm : ∀ a b, degb (a + b) ≤ degb a + degb b) (s : Finset ι)\n    (f : ι → AddMonoidAlgebra R A) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n              (f i)).support.sup\n        degb ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        ((f i).support.sup degb) :=\n  (sup_support_multiset_prod_le degb0 degbm _).trans_eq <| congr_arg _ <| Multiset.map_map _ _ _\n#align sup_support_finset_prod_le sup_support_finset_prod_le\n\n",
 "sup_support_add_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-\nCopyright (c) 2022 Damiano Testa. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Damiano Testa\n-/\ntheorem sup_support_add_le : (f + g).support.sup degb ≤ «expr ⊔ » (f.support.sup degb) (g.support.sup degb) :=\n  (Finset.sup_mono Finsupp.support_add).trans_eq Finset.sup_union\n#align sup_support_add_le sup_support_add_le\n\n",
 "le_inf_support_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem le_inf_support_pow (degt0 : 0 ≤ degt 0) (degtm : ∀ a b, degt a + degt b ≤ degt (a + b)) (n : ℕ)\n    (f : AddMonoidAlgebra R A) : «expr • » n (f.support.inf degt) ≤ (f ^ n).support.inf degt :=\n  OrderDual.ofDual_le_ofDual.mpr <|\n    sup_support_pow_le (OrderDual.ofDual_le_ofDual.mp degt0) (fun a b => OrderDual.ofDual_le_ofDual.mp (degtm _ _)) n f\n#align le_inf_support_pow le_inf_support_pow\n\n",
 "le_inf_support_multiset_prod":
 "theorem le_inf_support_multiset_prod (degt0 : 0 ≤ degt 0) (degtm : ∀ a b, degt a + degt b ≤ degt (a + b))\n    (m : Multiset (AddMonoidAlgebra R A)) :\n    (m.map fun f : AddMonoidAlgebra R A => f.support.inf degt).sum ≤ m.prod.support.inf degt :=\n  OrderDual.ofDual_le_ofDual.mpr <|\n    sup_support_multiset_prod_le (OrderDual.ofDual_le_ofDual.mp degt0)\n      (fun a b => OrderDual.ofDual_le_ofDual.mp (degtm _ _)) m\n#align le_inf_support_multiset_prod le_inf_support_multiset_prod\n\n",
 "le_inf_support_mul":
 "theorem le_inf_support_mul {degt : A → T} (degtm : ∀ {a b}, degt a + degt b ≤ degt (a + b))\n    (f g : AddMonoidAlgebra R A) : f.support.inf degt + g.support.inf degt ≤ (f * g).support.inf degt :=\n  OrderDual.ofDual_le_ofDual.mpr <| sup_support_mul_le (fun a b => OrderDual.ofDual_le_ofDual.mp degtm) f g\n#align le_inf_support_mul le_inf_support_mul\n\n",
 "le_inf_support_list_prod":
 "theorem le_inf_support_list_prod (degt0 : 0 ≤ degt 0) (degtm : ∀ a b, degt a + degt b ≤ degt (a + b))\n    (l : List (AddMonoidAlgebra R A)) :\n    (l.map fun f : AddMonoidAlgebra R A => f.support.inf degt).sum ≤ l.prod.support.inf degt :=\n  OrderDual.ofDual_le_ofDual.mpr <|\n    sup_support_list_prod_le (OrderDual.ofDual_le_ofDual.mp degt0)\n      (fun a b => OrderDual.ofDual_le_ofDual.mp (degtm _ _)) l\n#align le_inf_support_list_prod le_inf_support_list_prod\n\n",
 "le_inf_support_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem le_inf_support_finset_prod (degt0 : 0 ≤ degt 0) (degtm : ∀ a b, degt a + degt b ≤ degt (a + b)) (s : Finset ι)\n    (f : ι → AddMonoidAlgebra R A) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        ((f i).support.inf degt) ≤\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n              (f i)).support.inf\n        degt :=\n  le_of_eq_of_le (by rw [Multiset.map_map] <;> rfl) (le_inf_support_multiset_prod degt0 degtm _)\n#align le_inf_support_finset_prod le_inf_support_finset_prod\n\n",
 "le_inf_support_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem le_inf_support_add : «expr ⊓ » (f.support.inf degt) (g.support.inf degt) ≤ (f + g).support.inf degt :=\n  sup_support_add_le (fun a : A => OrderDual.toDual (degt a)) f g\n#align le_inf_support_add le_inf_support_add\n\n"}