{"subsingleton":
 "#print IsRegular.subsingleton /-\n/-- The element `0` is regular if and only if `R` is trivial. -/\ntheorem IsRegular.subsingleton (h : IsRegular (0 : R)) : subsingleton R :=\n  h.left.subsingleton\n#align is_regular.subsingleton IsRegular.subsingleton\n-/\n\n",
 "right_of_commute":
 "#print IsLeftRegular.right_of_commute /-\ntheorem IsLeftRegular.right_of_commute {a : R} (ca : ∀ b, Commute a b) (h : IsLeftRegular a) : IsRightRegular a :=\n  fun x y xy => h <| (ca x).trans <| xy.trans <| (ca y).symm\n#align is_left_regular.right_of_commute IsLeftRegular.right_of_commute\n-/\n\n",
 "of_mul":
 "#print IsRightRegular.of_mul /-\n/-- If an element `b` becomes right-regular after multiplying it on the right by a right-regular\nelement, then `b` is right-regular. -/\n@[to_additive\n      \"If an element `b` becomes add-right-regular after adding to it on the right a\\nadd-right-regular element, then `b` is add-right-regular.\"]\ntheorem IsRightRegular.of_mul (ab : IsRightRegular (b * a)) : IsRightRegular b :=\n  by\n  refine' fun x y xy => ab (_ : x * (b * a) = y * (b * a))\n  rw [← mul_assoc, ← mul_assoc]\n  exact congr_fun (congr_arg (· * ·) xy) a\n#align is_right_regular.of_mul IsRightRegular.of_mul\n#align is_add_right_regular.of_add IsAddRightRegular.of_add\n-/\n\n",
 "not_isRightRegular_zero_iff":
 "#print not_isRightRegular_zero_iff /-\n/-- In a non-trivial `mul_zero_class`, the `0` element is not right-regular. -/\ntheorem not_isRightRegular_zero_iff : ¬IsRightRegular (0 : R) ↔ Nontrivial R :=\n  by\n  rw [nontrivial_iff, not_iff_comm, isRightRegular_zero_iff_subsingleton, subsingleton_iff]\n  push_neg\n  exact iff.rfl\n#align not_is_right_regular_zero_iff not_isRightRegular_zero_iff\n-/\n\n",
 "not_isRightRegular_zero":
 "#print not_isRightRegular_zero /-\n/-- In a non-trivial ring, the element `0` is not right-regular -- with typeclasses. -/\ntheorem not_isRightRegular_zero [nR : Nontrivial R] : ¬IsRightRegular (0 : R) :=\n  not_isRightRegular_zero_iff.mpr nR\n#align not_is_right_regular_zero not_isRightRegular_zero\n-/\n\n",
 "not_isRegular_zero":
 "#print not_isRegular_zero /-\n/-- In a non-trivial ring, the element `0` is not regular -- with typeclasses. -/\ntheorem not_isRegular_zero [Nontrivial R] : ¬IsRegular (0 : R) := fun h => IsRegular.ne_zero h rfl\n#align not_is_regular_zero not_isRegular_zero\n-/\n\n",
 "not_isLeftRegular_zero_iff":
 "#print not_isLeftRegular_zero_iff /-\n/-- In a non-trivial `mul_zero_class`, the `0` element is not left-regular. -/\ntheorem not_isLeftRegular_zero_iff : ¬IsLeftRegular (0 : R) ↔ Nontrivial R :=\n  by\n  rw [nontrivial_iff, not_iff_comm, isLeftRegular_zero_iff_subsingleton, subsingleton_iff]\n  push_neg\n  exact iff.rfl\n#align not_is_left_regular_zero_iff not_isLeftRegular_zero_iff\n-/\n\n",
 "not_isLeftRegular_zero":
 "#print not_isLeftRegular_zero /-\n/-- In a non-trivial ring, the element `0` is not left-regular -- with typeclasses. -/\ntheorem not_isLeftRegular_zero [nR : Nontrivial R] : ¬IsLeftRegular (0 : R) :=\n  not_isLeftRegular_zero_iff.mpr nR\n#align not_is_left_regular_zero not_isLeftRegular_zero\n-/\n\n",
 "ne_zero":
 "#print IsRegular.ne_zero /-\n/-- A regular element of a `nontrivial` `mul_zero_class` is non-zero. -/\ntheorem IsRegular.ne_zero [Nontrivial R] (la : IsRegular a) : a ≠ 0 :=\n  la.left.ne_zero\n#align is_regular.ne_zero IsRegular.ne_zero\n-/\n\n",
 "mul_isRightRegular_iff":
 "#print mul_isRightRegular_iff /-\n/-- An element is right-regular if and only if multiplying it on the right with a right-regular\nelement is right-regular. -/\n@[simp,\n  to_additive\n      \"An element is add-right-regular if and only if adding it on the right to a\\nadd-right-regular element is add-right-regular.\"]\ntheorem mul_isRightRegular_iff (b : R) (ha : IsRightRegular a) : IsRightRegular (b * a) ↔ IsRightRegular b :=\n  ⟨fun ab => IsRightRegular.of_mul ab, fun ab => IsRightRegular.mul ab ha⟩\n#align mul_is_right_regular_iff mul_isRightRegular_iff\n#align add_is_add_right_regular_iff add_isAddRightRegular_iff\n-/\n\n",
 "mul_isLeftRegular_iff":
 "#print mul_isLeftRegular_iff /-\n/-- An element is left-regular if and only if multiplying it on the left by a left-regular element\nis left-regular. -/\n@[simp,\n  to_additive\n      \"An element is add-left-regular if and only if adding to it on the left a\\nadd-left-regular element is add-left-regular.\"]\ntheorem mul_isLeftRegular_iff (b : R) (ha : IsLeftRegular a) : IsLeftRegular (a * b) ↔ IsLeftRegular b :=\n  ⟨fun ab => IsLeftRegular.of_mul ab, fun ab => IsLeftRegular.mul ha ab⟩\n#align mul_is_left_regular_iff mul_isLeftRegular_iff\n#align add_is_add_left_regular_iff add_isAddLeftRegular_iff\n-/\n\n",
 "mul":
 "#print IsRightRegular.mul /-\n/-- In a semigroup, the product of right-regular elements is right-regular. -/\n@[to_additive \"In an additive semigroup, the sum of add-right-regular elements is add-right-regular.\"]\ntheorem IsRightRegular.mul (rra : IsRightRegular a) (rrb : IsRightRegular b) : IsRightRegular (a * b) :=\n  show function.injective (· * (a * b)) from comp_mul_right b a ▸ rrb.comp rra\n#align is_right_regular.mul IsRightRegular.mul\n#align is_add_right_regular.add IsAddRightRegular.add\n-/\n\n",
 "isRightRegular_zero_iff_subsingleton":
 "#print isRightRegular_zero_iff_subsingleton /-\n/-- The element `0` is right-regular if and only if `R` is trivial. -/\ntheorem isRightRegular_zero_iff_subsingleton : IsRightRegular (0 : R) ↔ subsingleton R :=\n  ⟨fun h => h.subsingleton, fun H a b h => @subsingleton.elim _ H a b⟩\n#align is_right_regular_zero_iff_subsingleton isRightRegular_zero_iff_subsingleton\n-/\n\n",
 "isRightRegular_of_rightCancelSemigroup":
 "#print isRightRegular_of_rightCancelSemigroup /-\n/-- Elements of a right cancel semigroup are right regular. -/\n@[to_additive \"Elements of an add right cancel semigroup are add-right-regular\"]\ntheorem isRightRegular_of_rightCancelSemigroup [RightCancelSemigroup R] (g : R) : IsRightRegular g :=\n  mul_left_injective g\n#align is_right_regular_of_right_cancel_semigroup isRightRegular_of_rightCancelSemigroup\n#align is_add_right_regular_of_right_cancel_add_semigroup isAddRightRegular_of_addRightCancelSemigroup\n-/\n\n",
 "isRightRegular_of_mul_eq_one":
 "#print isRightRegular_of_mul_eq_one /-\n/-- An element admitting a right inverse is right-regular. -/\n@[to_additive \"An element admitting a right additive opposite is add-right-regular.\"]\ntheorem isRightRegular_of_mul_eq_one (h : a * b = 1) : IsRightRegular a :=\n  IsRightRegular.of_mul\n    (by\n      rw [h]\n      exact is_regular_one.right)\n#align is_right_regular_of_mul_eq_one isRightRegular_of_mul_eq_one\n#align is_add_right_regular_of_add_eq_zero isAddRightRegular_of_add_eq_zero\n-/\n\n",
 "isRegular_one":
 "#print isRegular_one /-\n/-- If multiplying by `1` on either side is the identity, `1` is regular. -/\n@[to_additive \"If adding `0` on either side is the identity, `0` is regular.\"]\ntheorem isRegular_one : IsRegular (1 : R) :=\n  ⟨fun a b ab => (one_mul a).symm.trans (Eq.trans ab (one_mul b)), fun a b ab =>\n    (mul_one a).symm.trans (Eq.trans ab (mul_one b))⟩\n#align is_regular_one isRegular_one\n#align is_add_regular_zero isAddRegular_zero\n-/\n\n",
 "isRegular_of_ne_zero":
 "#print isRegular_of_ne_zero /-\n/-- Non-zero elements of an integral domain are regular. -/\ntheorem isRegular_of_ne_zero (a0 : a ≠ 0) : IsRegular a :=\n  ⟨fun b c => (mul_right_inj' a0).mp, fun b c => (mul_left_inj' a0).mp⟩\n#align is_regular_of_ne_zero isRegular_of_ne_zero\n-/\n\n",
 "isRegular_of_cancelMonoid":
 "#print isRegular_of_cancelMonoid /-\n/-- Elements of a cancel monoid are regular.  Cancel semigroups do not appear to exist. -/\n@[to_additive \"Elements of an add cancel monoid are regular.  Add cancel semigroups do not appear to exist.\"]\ntheorem isRegular_of_cancelMonoid (g : R) : IsRegular g :=\n  ⟨mul_right_injective g, mul_left_injective g⟩\n#align is_regular_of_cancel_monoid isRegular_of_cancelMonoid\n#align is_add_regular_of_cancel_add_monoid isAddRegular_of_addCancelMonoid\n-/\n\n",
 "isRegular_mul_iff":
 "#print isRegular_mul_iff /-\n/-- A product is regular if and only if the factors are. -/\n@[to_additive \"A sum is add-regular if and only if the summands are.\"]\ntheorem isRegular_mul_iff : IsRegular (a * b) ↔ IsRegular a ∧ IsRegular b :=\n  by\n  refine' iff.trans _ isRegular_mul_and_mul_iff\n  refine' ⟨fun ab => ⟨ab, by rwa [mul_comm]⟩, fun rab => rab.1⟩\n#align is_regular_mul_iff isRegular_mul_iff\n#align is_add_regular_add_iff isAddRegular_add_iff\n-/\n\n",
 "isRegular_mul_and_mul_iff":
 "#print isRegular_mul_and_mul_iff /-\n/-- Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\nare regular. -/\n@[to_additive \"Two elements `a` and `b` are add-regular if and only if both sums `a + b` and `b + a`\\nare add-regular.\"]\ntheorem isRegular_mul_and_mul_iff : IsRegular (a * b) ∧ IsRegular (b * a) ↔ IsRegular a ∧ IsRegular b :=\n  by\n  refine' ⟨_, _⟩\n  · rintro ⟨ab, ba⟩\n    exact\n      ⟨⟨IsLeftRegular.of_mul ba.left, IsRightRegular.of_mul ab.right⟩,\n        ⟨IsLeftRegular.of_mul ab.left, IsRightRegular.of_mul ba.right⟩⟩\n  · rintro ⟨ha, hb⟩\n    exact\n      ⟨⟨(mul_isLeftRegular_iff _ ha.left).mpr hb.left, (mul_isRightRegular_iff _ hb.right).mpr ha.right⟩,\n        ⟨(mul_isLeftRegular_iff _ hb.left).mpr ha.left, (mul_isRightRegular_iff _ ha.right).mpr hb.right⟩⟩\n#align is_regular_mul_and_mul_iff isRegular_mul_and_mul_iff\n#align is_add_regular_add_and_add_iff isAddRegular_add_and_add_iff\n-/\n\n",
 "isRegular_iff_subsingleton":
 "#print isRegular_iff_subsingleton /-\n/-- The element `0` is regular if and only if `R` is trivial. -/\ntheorem isRegular_iff_subsingleton : IsRegular (0 : R) ↔ subsingleton R :=\n  ⟨fun h => h.left.subsingleton, fun h =>\n    ⟨isLeftRegular_zero_iff_subsingleton.mpr h, isRightRegular_zero_iff_subsingleton.mpr h⟩⟩\n#align is_regular_iff_subsingleton isRegular_iff_subsingleton\n-/\n\n",
 "isRegular_iff_ne_zero":
 "#print isRegular_iff_ne_zero /-\n/-- In a non-trivial integral domain, an element is regular iff it is non-zero. -/\ntheorem isRegular_iff_ne_zero [Nontrivial R] : IsRegular a ↔ a ≠ 0 :=\n  ⟨IsRegular.ne_zero, isRegular_of_ne_zero⟩\n#align is_regular_iff_ne_zero isRegular_iff_ne_zero\n-/\n\n",
 "isRegular_iff":
 "#print Commute.isRegular_iff /-\ntheorem Commute.isRegular_iff {a : R} (ca : ∀ b, Commute a b) : IsRegular a ↔ IsLeftRegular a :=\n  ⟨fun h => h.left, fun h => ⟨h, h.right_of_commute ca⟩⟩\n#align commute.is_regular_iff Commute.isRegular_iff\n-/\n\n",
 "isRegular":
 "#print IsUnit.isRegular /-\n/-- A unit in a monoid is regular. -/\n@[to_additive \"An additive unit in an additive monoid is add-regular.\"]\ntheorem IsUnit.isRegular (ua : IsUnit a) : IsRegular a :=\n  by\n  rcases ua with ⟨a, rfl⟩\n  exact Units.isRegular a\n#align is_unit.is_regular IsUnit.isRegular\n#align is_add_unit.is_add_regular IsAddUnit.isAddRegular\n-/\n\n",
 "isLeftRegular_zero_iff_subsingleton":
 "#print isLeftRegular_zero_iff_subsingleton /-\n/-- The element `0` is left-regular if and only if `R` is trivial. -/\ntheorem isLeftRegular_zero_iff_subsingleton : IsLeftRegular (0 : R) ↔ subsingleton R :=\n  ⟨fun h => h.subsingleton, fun H a b h => @subsingleton.elim _ H a b⟩\n#align is_left_regular_zero_iff_subsingleton isLeftRegular_zero_iff_subsingleton\n-/\n\n",
 "isLeftRegular_of_mul_eq_one":
 "#print isLeftRegular_of_mul_eq_one /-\n/-- An element admitting a left inverse is left-regular. -/\n@[to_additive \"An element admitting a left additive opposite is add-left-regular.\"]\ntheorem isLeftRegular_of_mul_eq_one (h : b * a = 1) : IsLeftRegular a :=\n  @IsLeftRegular.of_mul R _ _ _\n    (by\n      rw [h]\n      exact is_regular_one.left)\n#align is_left_regular_of_mul_eq_one isLeftRegular_of_mul_eq_one\n#align is_add_left_regular_of_add_eq_zero isAddLeftRegular_of_add_eq_zero\n-/\n\n",
 "isLeftRegular_of_leftCancelSemigroup":
 "#print isLeftRegular_of_leftCancelSemigroup /-\n/-- Elements of a left cancel semigroup are left regular. -/\n@[to_additive \"Elements of an add left cancel semigroup are add-left-regular.\"]\ntheorem isLeftRegular_of_leftCancelSemigroup [LeftCancelSemigroup R] (g : R) : IsLeftRegular g :=\n  mul_right_injective g\n#align is_left_regular_of_left_cancel_semigroup isLeftRegular_of_leftCancelSemigroup\n#align is_add_left_regular_of_left_cancel_add_semigroup isAddLeftRegular_of_addLeftCancelSemigroup\n-/\n\n",
 "isLeftRegular":
 "#print MulLECancellable.isLeftRegular /-\n/-\nCopyright (c) 2021 Damiano Testa. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Damiano Testa\n-/\n@[to_additive]\nprotected theorem MulLECancellable.isLeftRegular [partial_order R] {a : R} (ha : MulLECancellable a) :\n    IsLeftRegular a :=\n  ha.injective\n#align mul_le_cancellable.is_left_regular MulLECancellable.isLeftRegular\n#align add_le_cancellable.is_add_left_regular AddLECancellable.isAddLeftRegular\n-/\n\n",
 "and_of_mul_of_mul":
 "#print IsRegular.and_of_mul_of_mul /-\n/-- The \"most used\" implication of `mul_and_mul_iff`, with split hypotheses, instead of `∧`. -/\n@[to_additive \"The \\\"most used\\\" implication of `add_and_add_iff`, with split hypotheses,\\ninstead of `∧`.\"]\ntheorem IsRegular.and_of_mul_of_mul (ab : IsRegular (a * b)) (ba : IsRegular (b * a)) : IsRegular a ∧ IsRegular b :=\n  isRegular_mul_and_mul_iff.mp ⟨ab, ba⟩\n#align is_regular.and_of_mul_of_mul IsRegular.and_of_mul_of_mul\n#align is_add_regular.and_of_add_of_add IsAddRegular.and_of_add_of_add\n-/\n\n"}