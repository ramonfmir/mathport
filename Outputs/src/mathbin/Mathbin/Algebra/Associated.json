{"units_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n#print units_eq_one /-\ntheorem units_eq_one (u : «expr ˣ» (Associates α)) : u = 1 :=\n  Units.ext (mul_eq_one_iff.1 u.val_inv).1\n#align units_eq_one units_eq_one\n-/\n\n",
 "unit_associated_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print unit_associated_one /-\ntheorem unit_associated_one [monoid α] {u : «expr ˣ» α} : «expr ~ᵤ » (u : α) 1 :=\n  ⟨u⁻¹, Units.mul_inv u⟩\n#align unit_associated_one unit_associated_one\n-/\n\n",
 "trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print trans /-\n@[trans]\nprotected theorem trans [monoid α] : ∀ {x y z : α}, «expr ~ᵤ » x y → «expr ~ᵤ » y z → «expr ~ᵤ » x z\n  | x, _, _, ⟨u, rfl⟩, ⟨v, rfl⟩ => ⟨u * v, by rw [Units.val_mul, mul_assoc]⟩\n#align trans trans\n-/\n\n",
 "symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print symm /-\n@[symm]\nprotected theorem symm [monoid α] : ∀ {x y : α}, «expr ~ᵤ » x y → «expr ~ᵤ » y x\n  | x, _, ⟨u, rfl⟩ => ⟨u⁻¹, by rw [mul_assoc, Units.mul_inv, mul_one]⟩\n#align symm symm\n-/\n\n",
 "succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul":
 "#print succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul /-\ntheorem succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul (hp : Prime p) {a b : α} {k l : ℕ} :\n    p ^ k ∣ a → p ^ l ∣ b → p ^ (k + l + 1) ∣ a * b → p ^ (k + 1) ∣ a ∨ p ^ (l + 1) ∣ b :=\n  fun ⟨x, hx⟩ ⟨y, hy⟩ ⟨z, hz⟩ =>\n  have h : p ^ (k + l) * (x * y) = p ^ (k + l) * (p * z) := by\n    simpa [mul_comm, pow_add, hx, hy, mul_assoc, mul_left_comm] using hz\n  have hp0 : p ^ (k + l) ≠ 0 := pow_ne_zero _ hp.ne_zero\n  have hpd : p ∣ x * y := ⟨z, by rwa [mul_right_inj' hp0] at h⟩\n  (hp.dvd_or_dvd hpd).elim (fun ⟨d, hd⟩ => or.inl ⟨d, by simp [*, pow_succ, mul_comm, mul_left_comm, mul_assoc]⟩)\n    fun ⟨d, hd⟩ => or.inr ⟨d, by simp [*, pow_succ, mul_comm, mul_left_comm, mul_assoc]⟩\n#align succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul\n-/\n\n",
 "refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print refl /-\n@[refl]\nprotected theorem refl [monoid α] (x : α) : «expr ~ᵤ » x x :=\n  ⟨1, by simp⟩\n#align refl refl\n-/\n\n",
 "quotient_mk_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem quotient_mk_eq_mk [monoid α] (a : α) : «expr⟦ ⟧» a = Associates.mk a :=\n  rfl\n#align quotient_mk_eq_mk quotient_mk_eq_mk\n\n",
 "quot_mk_eq_mk":
 "theorem quot_mk_eq_mk [monoid α] (a : α) : Quot.mk Setoid.r a = Associates.mk a :=\n  rfl\n#align quot_mk_eq_mk quot_mk_eq_mk\n\n",
 "prime_pow_succ_dvd_mul":
 "#print prime_pow_succ_dvd_mul /-\ntheorem prime_pow_succ_dvd_mul {α : Type _} [cancel_comm_monoid_with_zero α] {p x y : α} (h : Prime p) {i : ℕ}\n    (hxy : p ^ (i + 1) ∣ x * y) : p ^ (i + 1) ∣ x ∨ p ∣ y :=\n  by\n  rw [or_iff_not_imp_right]\n  intro hy\n  induction' i with i ih generalizing x\n  · simp only [zero_add, pow_one] at *\n    exact (h.dvd_or_dvd hxy).resolve_right hy\n  rw [pow_succ] at hxy⊢\n  obtain ⟨x', rfl⟩ := (h.dvd_or_dvd (dvd_of_mul_right_dvd hxy)).resolve_right hy\n  rw [mul_assoc] at hxy\n  exact mul_dvd_mul_left p (ih ((mul_dvd_mul_iff_left h.ne_zero).mp hxy))\n#align prime_pow_succ_dvd_mul prime_pow_succ_dvd_mul\n-/\n\n",
 "prime_mk":
 "theorem prime_mk (p : α) : Prime (Associates.mk p) ↔ Prime p :=\n  by\n  rw [Prime, _root_.prime, forall_associated]\n  trans\n  · apply and_congr\n    rfl\n    apply and_congr\n    rfl\n    apply forall_congr'\n    intro a\n    exact forall_associated\n  apply and_congr mk_ne_zero\n  apply and_congr\n  · rw [is_unit_mk]\n  refine' forall₂_congr fun a b => _\n  rw [mk_mul_mk, mk_dvd_mk, mk_dvd_mk, mk_dvd_mk]\n#align prime_mk prime_mk\n\n",
 "prime_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.prime_iff /-\ntheorem Associated.prime_iff [comm_monoid_with_zero α] {p q : α} (h : «expr ~ᵤ » p q) : Prime p ↔ Prime q :=\n  ⟨h.prime, h.symm.prime⟩\n#align associated.prime_iff Associated.prime_iff\n-/\n\n",
 "prime_dvd_prime_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n#print prime_dvd_prime_iff_eq /-\ntheorem prime_dvd_prime_iff_eq {M : Type _} [cancel_comm_monoid_with_zero M] [unique («expr ˣ» M)] {p q : M}\n    (pp : Prime p) (qp : Prime q) : p ∣ q ↔ p = q := by rw [pp.dvd_prime_iff_associated qp, ← associated_eq_eq]\n#align prime_dvd_prime_iff_eq prime_dvd_prime_iff_eq\n-/\n\n",
 "prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.prime /-\nprotected theorem Associated.prime [comm_monoid_with_zero α] {p q : α} (h : «expr ~ᵤ » p q) (hp : Prime p) : Prime q :=\n  ⟨h.ne_zero_iff.1 hp.ne_zero,\n    let ⟨u, hu⟩ := h\n    ⟨fun ⟨v, hv⟩ => hp.not_unit ⟨v * u⁻¹, by simp [hv, hu.symm]⟩,\n      hu ▸ by\n        simp [Units.mul_right_dvd]\n        intro a b\n        exact hp.dvd_or_dvd⟩⟩\n#align associated.prime Associated.prime\n-/\n\n",
 "pow_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.pow_pow /-\ntheorem Associated.pow_pow [comm_monoid α] {a b : α} {n : ℕ} (h : «expr ~ᵤ » a b) : «expr ~ᵤ » (a ^ n) (b ^ n) :=\n  by\n  induction' n with n ih; · simp [h]\n  convert h.mul_mul ih <;> rw [pow_succ]\n#align associated.pow_pow Associated.pow_pow\n-/\n\n",
 "pow_not_prime":
 "#print pow_not_prime /-\ntheorem pow_not_prime {n : ℕ} (hn : n ≠ 1) : ¬Prime (a ^ n) := fun hp =>\n  hp.not_unit <| IsUnit.pow _ <| of_irreducible_pow hn <| hp.irreducible\n#align pow_not_prime pow_not_prime\n-/\n\n",
 "pow_injective_of_not_unit":
 "#print pow_injective_of_not_unit /-\ntheorem pow_injective_of_not_unit [cancel_comm_monoid_with_zero α] {q : α} (hq : ¬is_unit q) (hq' : q ≠ 0) :\n    function.injective fun n : ℕ => q ^ n :=\n  by\n  refine' injective_of_lt_imp_ne fun n m h => DvdNotUnit.ne ⟨pow_ne_zero n hq', q ^ (m - n), _, _⟩\n  · exact not_isUnit_of_not_isUnit_dvd hq (dvd_pow (dvd_refl _) (nat.sub_pos_of_lt h).ne')\n  · exact (pow_mul_pow_sub q h.le).symm\n#align pow_injective_of_not_unit pow_injective_of_not_unit\n-/\n\n",
 "pow_dvd_of_dvd_mul_right":
 "#print Prime.pow_dvd_of_dvd_mul_right /-\ntheorem Prime.pow_dvd_of_dvd_mul_right [cancel_comm_monoid_with_zero α] {p a b : α} (hp : Prime p) (n : ℕ) (h : ¬p ∣ b)\n    (h' : p ^ n ∣ a * b) : p ^ n ∣ a := by\n  rw [mul_comm] at h'\n  exact hp.pow_dvd_of_dvd_mul_left n h h'\n#align prime.pow_dvd_of_dvd_mul_right Prime.pow_dvd_of_dvd_mul_right\n-/\n\n",
 "pow_dvd_of_dvd_mul_left":
 "#print Prime.pow_dvd_of_dvd_mul_left /-\ntheorem Prime.pow_dvd_of_dvd_mul_left [cancel_comm_monoid_with_zero α] {p a b : α} (hp : Prime p) (n : ℕ) (h : ¬p ∣ a)\n    (h' : p ^ n ∣ a * b) : p ^ n ∣ b := by\n  induction' n with n ih\n  · rw [pow_zero]\n    exact one_dvd b\n  · obtain ⟨c, rfl⟩ := ih (dvd_trans (pow_dvd_pow p n.le_succ) h')\n    rw [pow_succ']\n    apply mul_dvd_mul_left _ ((hp.dvd_or_dvd _).resolve_left h)\n    rwa [← mul_dvd_mul_iff_left (pow_ne_zero n hp.ne_zero), ← pow_succ', mul_left_comm]\n#align prime.pow_dvd_of_dvd_mul_left Prime.pow_dvd_of_dvd_mul_left\n-/\n\n",
 "one_or_eq_of_le_of_prime":
 "theorem one_or_eq_of_le_of_prime : ∀ p m : Associates α, Prime p → m ≤ p → m = 1 ∨ m = p\n  | _, m, ⟨hp0, hp1, h⟩, ⟨d, rfl⟩ =>\n    match h m d dvd_rfl with\n    | or.inl h =>\n      by_cases (fun this : m = 0 => by simp [this]) fun this : m ≠ 0 =>\n        by\n        have : m * d ≤ m * 1 := by simpa using h\n        have : d ≤ 1 := Associates.le_of_mul_le_mul_left m d 1 ‹m ≠ 0› this\n        have : d = 1 := bot_unique this\n        simp [this]\n    | or.inr h =>\n      by_cases (fun this : d = 0 => by simp [this] at hp0 <;> contradiction) fun this : d ≠ 0 =>\n        have : d * m ≤ d * 1 := by simpa [mul_comm] using h\n        or.inl <| bot_unique <| Associates.le_of_mul_le_mul_left d m 1 ‹d ≠ 0› this\n#align one_or_eq_of_le_of_prime one_or_eq_of_le_of_prime\n\n",
 "one_le":
 "#print one_le /-\ntheorem one_le {a : Associates α} : 1 ≤ a :=\n  Dvd.intro _ (one_mul a)\n#align one_le one_le\n-/\n\n",
 "one_eq_mk_one":
 "theorem one_eq_mk_one [monoid α] : (1 : Associates α) = Associates.mk 1 :=\n  rfl\n#align one_eq_mk_one one_eq_mk_one\n\n",
 "of_pow_associated_of_prime'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.of_pow_associated_of_prime' /-\ntheorem Associated.of_pow_associated_of_prime' [cancel_comm_monoid_with_zero α] {p₁ p₂ : α} {k₁ k₂ : ℕ} (hp₁ : Prime p₁)\n    (hp₂ : Prime p₂) (hk₂ : 0 < k₂) (h : «expr ~ᵤ » (p₁ ^ k₁) (p₂ ^ k₂)) : «expr ~ᵤ » p₁ p₂ :=\n  (h.symm.of_pow_associated_of_prime hp₂ hp₁ hk₂).symm\n#align associated.of_pow_associated_of_prime' Associated.of_pow_associated_of_prime'\n-/\n\n",
 "of_pow_associated_of_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.of_pow_associated_of_prime /-\ntheorem Associated.of_pow_associated_of_prime [cancel_comm_monoid_with_zero α] {p₁ p₂ : α} {k₁ k₂ : ℕ} (hp₁ : Prime p₁)\n    (hp₂ : Prime p₂) (hk₁ : 0 < k₁) (h : «expr ~ᵤ » (p₁ ^ k₁) (p₂ ^ k₂)) : «expr ~ᵤ » p₁ p₂ :=\n  by\n  have : p₁ ∣ p₂ ^ k₂ := by\n    rw [← h.dvd_iff_dvd_right]\n    apply dvd_pow_self _ hk₁.ne'\n  rw [← hp₁.dvd_prime_iff_associated hp₂]\n  exact hp₁.dvd_of_dvd_pow this\n#align associated.of_pow_associated_of_prime Associated.of_pow_associated_of_prime\n-/\n\n",
 "of_mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.of_mul_right /-\ntheorem Associated.of_mul_right [cancel_comm_monoid_with_zero α] {a b c d : α} :\n    «expr ~ᵤ » (a * b) (c * d) → «expr ~ᵤ » b d → b ≠ 0 → «expr ~ᵤ » a c := by\n  rw [mul_comm a, mul_comm c] <;> exact Associated.of_mul_left\n#align associated.of_mul_right Associated.of_mul_right\n-/\n\n",
 "of_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.of_mul_left /-\ntheorem Associated.of_mul_left [cancel_comm_monoid_with_zero α] {a b c d : α} (h : «expr ~ᵤ » (a * b) (c * d))\n    (h₁ : «expr ~ᵤ » a c) (ha : a ≠ 0) : «expr ~ᵤ » b d :=\n  let ⟨u, hu⟩ := h\n  let ⟨v, hv⟩ := Associated.symm h₁\n  ⟨u * (v : «expr ˣ» α),\n    mul_left_cancel₀ ha\n      (by\n        rw [← hv, mul_assoc c (v : α) d, mul_left_comm c, ← hu]\n        simp [hv.symm, mul_assoc, mul_comm, mul_left_comm])⟩\n#align associated.of_mul_left Associated.of_mul_left\n-/\n\n",
 "of_irreducible_pow":
 "#print of_irreducible_pow /-\ntheorem of_irreducible_pow {α} [monoid α] {x : α} {n : ℕ} (hn : n ≠ 1) : Irreducible (x ^ n) → is_unit x :=\n  by\n  obtain hn | hn := hn.lt_or_lt\n  · simp only [nat.lt_one_iff.mp hn, is_empty.forall_iff, not_irreducible_one, pow_zero]\n  intro h\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_lt hn\n  rw [pow_succ, add_comm] at h\n  exact (or_iff_left_of_imp is_unit_pow_succ_iff.mp).mp (of_irreducible_mul h)\n#align of_irreducible_pow of_irreducible_pow\n-/\n\n",
 "of_irreducible_mul":
 "#print of_irreducible_mul /-\ntheorem of_irreducible_mul {α} [monoid α] {x y : α} : Irreducible (x * y) → is_unit x ∨ is_unit y\n  | ⟨_, h⟩ => h _ _ rfl\n#align of_irreducible_mul of_irreducible_mul\n-/\n\n",
 "not_unit":
 "#print DvdNotUnit.not_unit /-\ntheorem DvdNotUnit.not_unit [comm_monoid_with_zero α] {p q : α} (hp : DvdNotUnit p q) : ¬is_unit q :=\n  by\n  obtain ⟨-, x, hx, rfl⟩ := hp\n  exact fun hc => hx (is_unit_iff_dvd_one.mpr (dvd_of_mul_left_dvd (is_unit_iff_dvd_one.mp hc)))\n#align dvd_not_unit.not_unit DvdNotUnit.not_unit\n-/\n\n",
 "not_square":
 "#print Prime.not_square /-\ntheorem Prime.not_square (hp : Prime p) : ¬IsSquare p :=\n  hp.irreducible.not_square\n#align prime.not_square Prime.not_square\n-/\n\n",
 "not_prime_zero":
 "#print not_prime_zero /-\n@[simp]\ntheorem not_prime_zero : ¬Prime (0 : α) := fun h => h.ne_zero rfl\n#align not_prime_zero not_prime_zero\n-/\n\n",
 "not_prime_one":
 "#print not_prime_one /-\n@[simp]\ntheorem not_prime_one : ¬Prime (1 : α) := fun h => h.not_unit isUnit_one\n#align not_prime_one not_prime_one\n-/\n\n",
 "not_prime":
 "#print IsSquare.not_prime /-\ntheorem IsSquare.not_prime (ha : IsSquare a) : ¬Prime a := fun h => h.not_square ha\n#align is_square.not_prime IsSquare.not_prime\n-/\n\n",
 "not_irreducible_zero":
 "#print not_irreducible_zero /-\n@[simp]\ntheorem not_irreducible_zero [monoid_with_zero α] : ¬Irreducible (0 : α)\n  | ⟨hn0, h⟩ =>\n    have : is_unit (0 : α) ∨ is_unit (0 : α) := h 0 0 (mul_zero 0).symm\n    this.elim hn0 hn0\n#align not_irreducible_zero not_irreducible_zero\n-/\n\n",
 "not_irreducible_one":
 "#print not_irreducible_one /-\n@[simp]\ntheorem not_irreducible_one [monoid α] : ¬Irreducible (1 : α) := by simp [irreducible_iff]\n#align not_irreducible_one not_irreducible_one\n-/\n\n",
 "not_irreducible_of_not_unit_dvdNotUnit":
 "#print not_irreducible_of_not_unit_dvdNotUnit /-\ntheorem not_irreducible_of_not_unit_dvdNotUnit [comm_monoid_with_zero α] {p q : α} (hp : ¬is_unit p)\n    (h : DvdNotUnit p q) : ¬Irreducible q :=\n  mt h.is_unit_of_irreducible_right hp\n#align not_irreducible_of_not_unit_dvd_not_unit not_irreducible_of_not_unit_dvdNotUnit\n-/\n\n",
 "not_irreducible":
 "#print IsSquare.not_irreducible /-\ntheorem IsSquare.not_irreducible (ha : IsSquare a) : ¬Irreducible a := fun h => h.not_square ha\n#align is_square.not_irreducible IsSquare.not_irreducible\n-/\n\n",
 "not_dvd_one":
 "theorem not_dvd_one [comm_monoid α] {p : α} (hp : Irreducible p) : ¬p ∣ 1 :=\n  mt (isUnit_of_dvd_one _) hp.not_unit\n#align not_dvd_one not_dvd_one\n\n",
 "not_associated":
 "#print DvdNotUnit.not_associated /-\ntheorem DvdNotUnit.not_associated [cancel_comm_monoid_with_zero α] {p q : α} (h : DvdNotUnit p q) : ¬Associated p q :=\n  by\n  rintro ⟨a, rfl⟩\n  obtain ⟨hp, x, hx, hx'⟩ := h\n  rcases(mul_right_inj' hp).mp hx' with rfl\n  exact hx a.is_unit\n#align dvd_not_unit.not_associated DvdNotUnit.not_associated\n-/\n\n",
 "ne_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.ne_zero_iff /-\ntheorem Associated.ne_zero_iff [monoid_with_zero α] {a b : α} (h : «expr ~ᵤ » a b) : a ≠ 0 ↔ b ≠ 0 :=\n  not_congr h.eq_zero_iff\n#align associated.ne_zero_iff Associated.ne_zero_iff\n-/\n\n",
 "ne_zero":
 "#print Irreducible.ne_zero /-\ntheorem Irreducible.ne_zero [monoid_with_zero α] : ∀ {p : α}, Irreducible p → p ≠ 0\n  | _, hp, rfl => not_irreducible_zero hp\n#align irreducible.ne_zero Irreducible.ne_zero\n-/\n\n",
 "ne_one":
 "#print Irreducible.ne_one /-\ntheorem Irreducible.ne_one [monoid α] : ∀ {p : α}, Irreducible p → p ≠ 1\n  | _, hp, rfl => not_irreducible_one hp\n#align irreducible.ne_one Irreducible.ne_one\n-/\n\n",
 "ne":
 "#print DvdNotUnit.ne /-\ntheorem DvdNotUnit.ne [cancel_comm_monoid_with_zero α] {p q : α} (h : DvdNotUnit p q) : p ≠ q :=\n  by\n  by_contra hcontra\n  obtain ⟨hp, x, hx', hx''⟩ := h\n  conv_lhs at hx'' => rw [← hcontra, ← mul_one p]\n  rw [(mul_left_cancel₀ hp hx'').symm] at hx'\n  exact hx' isUnit_one\n#align dvd_not_unit.ne DvdNotUnit.ne\n-/\n\n",
 "mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.mul_right /-\ntheorem Associated.mul_right [comm_monoid α] {a b : α} (h : «expr ~ᵤ » a b) (c : α) : «expr ~ᵤ » (a * c) (b * c) :=\n  h.mul_mul (Associated.refl c)\n#align associated.mul_right Associated.mul_right\n-/\n\n",
 "mul_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.mul_mul /-\ntheorem Associated.mul_mul [comm_monoid α] {a₁ a₂ b₁ b₂ : α} :\n    «expr ~ᵤ » a₁ b₁ → «expr ~ᵤ » a₂ b₂ → «expr ~ᵤ » (a₁ * a₂) (b₁ * b₂)\n  | ⟨c₁, h₁⟩, ⟨c₂, h₂⟩ => ⟨c₁ * c₂, by simp [h₁.symm, h₂.symm, mul_assoc, mul_comm, mul_left_comm]⟩\n#align associated.mul_mul Associated.mul_mul\n-/\n\n",
 "mul_mono":
 "theorem mul_mono {a b c d : Associates α} (h₁ : a ≤ b) (h₂ : c ≤ d) : a * c ≤ b * d :=\n  let ⟨x, hx⟩ := h₁\n  let ⟨y, hy⟩ := h₂\n  ⟨x * y, by simp [hx, hy, mul_comm, mul_assoc, mul_left_comm]⟩\n#align mul_mono mul_mono\n\n",
 "mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.mul_left /-\ntheorem Associated.mul_left [comm_monoid α] (a : α) {b c : α} (h : «expr ~ᵤ » b c) : «expr ~ᵤ » (a * b) (a * c) :=\n  (Associated.refl a).mul_mul h\n#align associated.mul_left Associated.mul_left\n-/\n\n",
 "mul_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print mul_eq_one_iff /-\ntheorem mul_eq_one_iff {x y : Associates α} : x * y = 1 ↔ x = 1 ∧ y = 1 :=\n  iff.intro\n    (quotient.induction_on₂ x y fun a b h =>\n      have : «expr ~ᵤ » (a * b) 1 := quotient.exact h\n      ⟨quotient.sound <| associated_one_of_associated_mul_one this,\n        quotient.sound <| associated_one_of_associated_mul_one <| by rwa [mul_comm] at this⟩)\n    (by simp (config := { contextual := true }))\n#align mul_eq_one_iff mul_eq_one_iff\n-/\n\n",
 "mk_surjective":
 "theorem mk_surjective [monoid α] : function.surjective (@Associates.mk α _) :=\n  forall_associated.2 fun a => ⟨a, rfl⟩\n#align mk_surjective mk_surjective\n\n",
 "mk_pow":
 "theorem mk_pow (a : α) (n : ℕ) : Associates.mk (a ^ n) = Associates.mk a ^ n := by\n  induction n <;> simp [*, pow_succ, associates.mk_mul_mk.symm]\n#align mk_pow mk_pow\n\n",
 "mk_one":
 "@[simp]\ntheorem mk_one [monoid α] : Associates.mk (1 : α) = 1 :=\n  rfl\n#align mk_one mk_one\n\n",
 "mk_ne_zero":
 "theorem mk_ne_zero {a : α} : Associates.mk a ≠ 0 ↔ a ≠ 0 :=\n  not_congr mk_eq_zero\n#align mk_ne_zero mk_ne_zero\n\n",
 "mk_mul_mk":
 "theorem mk_mul_mk {x y : α} : Associates.mk x * Associates.mk y = Associates.mk (x * y) :=\n  rfl\n#align mk_mul_mk mk_mul_mk\n\n",
 "mk_monoid_hom_apply":
 "@[simp]\ntheorem mk_monoid_hom_apply (a : α) : Associates.mkMonoidHom a = Associates.mk a :=\n  rfl\n#align mk_monoid_hom_apply mk_monoid_hom_apply\n\n",
 "mk_le_mk_of_dvd":
 "theorem mk_le_mk_of_dvd {a b : α} : a ∣ b → Associates.mk a ≤ Associates.mk b := fun ⟨c, hc⟩ =>\n  ⟨Associates.mk c, by simp [hc] <;> rfl⟩\n#align mk_le_mk_of_dvd mk_le_mk_of_dvd\n\n",
 "mk_le_mk_iff_dvd_iff":
 "theorem mk_le_mk_iff_dvd_iff {a b : α} : Associates.mk a ≤ Associates.mk b ↔ a ∣ b :=\n  iff.intro dvd_of_mk_le_mk mk_le_mk_of_dvd\n#align mk_le_mk_iff_dvd_iff mk_le_mk_iff_dvd_iff\n\n",
 "mk_injective":
 "theorem mk_injective [monoid α] [unique (Units α)] : function.injective (@Associates.mk α _) := fun a b h =>\n  associated_iff_eq.mp (Associates.mk_eq_mk_iff_associated.mp h)\n#align mk_injective mk_injective\n\n",
 "mk_eq_zero":
 "@[simp]\ntheorem mk_eq_zero {a : α} : Associates.mk a = 0 ↔ a = 0 :=\n  ⟨fun h => (associated_zero_iff_eq_zero a).1 <| quotient.exact h, fun h => h.symm ▸ rfl⟩\n#align mk_eq_zero mk_eq_zero\n\n",
 "mk_eq_mk_iff_associated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\ntheorem mk_eq_mk_iff_associated [monoid α] {a b : α} : Associates.mk a = Associates.mk b ↔ «expr ~ᵤ » a b :=\n  iff.intro quotient.exact quot.sound\n#align mk_eq_mk_iff_associated mk_eq_mk_iff_associated\n\n",
 "mk_dvd_not_unit_mk_iff":
 "theorem mk_dvd_not_unit_mk_iff {a b : α} : DvdNotUnit (Associates.mk a) (Associates.mk b) ↔ DvdNotUnit a b :=\n  by\n  rw [DvdNotUnit, DvdNotUnit, mk_ne_zero]\n  apply and_congr_right; intro ane0\n  constructor\n  · contrapose!\n    rw [forall_associated]\n    intro h x hx hbax\n    rw [mk_mul_mk, mk_eq_mk_iff_associated] at hbax\n    cases' hbax with u hu\n    apply h (x * ↑u⁻¹)\n    · rw [is_unit_mk] at hx\n      rw [Associated.isUnit_iff]\n      apply hx\n      use u\n      simp\n    simp [← mul_assoc, ← hu]\n  · rintro ⟨x, ⟨hx, rfl⟩⟩\n    use Associates.mk x\n    simp [is_unit_mk, mk_mul_mk, hx]\n#align mk_dvd_not_unit_mk_iff mk_dvd_not_unit_mk_iff\n\n",
 "mk_dvd_mk":
 "theorem mk_dvd_mk {a b : α} : Associates.mk a ∣ Associates.mk b ↔ a ∣ b :=\n  iff.intro dvd_of_mk_le_mk mk_le_mk_of_dvd\n#align mk_dvd_mk mk_dvd_mk\n\n",
 "left_dvd_or_dvd_right_of_dvd_mul":
 "#print Prime.left_dvd_or_dvd_right_of_dvd_mul /-\ntheorem Prime.left_dvd_or_dvd_right_of_dvd_mul [cancel_comm_monoid_with_zero α] {p : α} (hp : Prime p) {a b : α} :\n    a ∣ p * b → p ∣ a ∨ a ∣ b := by\n  rintro ⟨c, hc⟩\n  rcases hp.2.2 a c (hc ▸ dvd_mul_right _ _) with (h | ⟨x, rfl⟩)\n  · exact or.inl h\n  · rw [mul_left_comm, mul_right_inj' hp.ne_zero] at hc\n    exact or.inr (hc.symm ▸ dvd_mul_right _ _)\n#align prime.left_dvd_or_dvd_right_of_dvd_mul Prime.left_dvd_or_dvd_right_of_dvd_mul\n-/\n\n",
 "le_or_le":
 "theorem prime.le_or_le {p : Associates α} (hp : Prime p) {a b : Associates α} (h : p ≤ a * b) : p ≤ a ∨ p ≤ b :=\n  hp.2.2 a b h\n#align prime.le_or_le prime.le_or_le\n\n",
 "le_one_iff":
 "theorem le_one_iff {p : Associates α} : p ≤ 1 ↔ p = 1 := by rw [← Associates.bot_eq_one, le_bot_iff]\n#align le_one_iff le_one_iff\n\n",
 "le_of_mul_le_mul_left":
 "#print le_of_mul_le_mul_left /-\ntheorem le_of_mul_le_mul_left (a b c : Associates α) (ha : a ≠ 0) : a * b ≤ a * c → b ≤ c\n  | ⟨d, hd⟩ => ⟨d, mul_left_cancel₀ ha <| by rwa [← mul_assoc]⟩\n#align le_of_mul_le_mul_left le_of_mul_le_mul_left\n-/\n\n",
 "le_mul_right":
 "#print le_mul_right /-\ntheorem le_mul_right {a b : Associates α} : a ≤ a * b :=\n  ⟨b, rfl⟩\n#align le_mul_right le_mul_right\n-/\n\n",
 "le_mul_left":
 "#print le_mul_left /-\ntheorem le_mul_left {a b : Associates α} : a ≤ b * a := by rw [mul_comm] <;> exact le_mul_right\n#align le_mul_left le_mul_left\n-/\n\n",
 "is_unit_or_is_unit":
 "theorem is_unit_or_is_unit [monoid α] {p : α} (hp : Irreducible p) {a b : α} (h : p = a * b) : is_unit a ∨ is_unit b :=\n  hp.is_unit_or_is_unit' a b h\n#align is_unit_or_is_unit is_unit_or_is_unit\n\n",
 "is_unit_of_irreducible_right":
 "theorem dvd_not_unit.is_unit_of_irreducible_right [comm_monoid_with_zero α] {p q : α} (h : DvdNotUnit p q)\n    (hq : Irreducible q) : is_unit p := by\n  obtain ⟨hp', x, hx, hx'⟩ := h\n  exact or.resolve_right ((irreducible_iff.1 hq).right p x hx') hx\n#align dvd_not_unit.is_unit_of_irreducible_right dvd_not_unit.is_unit_of_irreducible_right\n\n",
 "is_unit_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\ntheorem is_unit_mk {a : α} : is_unit (Associates.mk a) ↔ is_unit a :=\n  calc\n    is_unit (Associates.mk a) ↔ «expr ~ᵤ » a 1 := by rw [is_unit_iff_eq_one, one_eq_mk_one, mk_eq_mk_iff_associated]\n    _ ↔ is_unit a := associated_one_iff_isUnit\n    \n#align is_unit_mk is_unit_mk\n\n",
 "is_unit_iff_eq_one":
 "theorem is_unit_iff_eq_one (a : Associates α) : is_unit a ↔ a = 1 :=\n  iff.intro (fun ⟨u, h⟩ => h ▸ coe_unit_eq_one _) fun h => h.symm ▸ isUnit_one\n#align is_unit_iff_eq_one is_unit_iff_eq_one\n\n",
 "is_unit_iff_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_unit_iff_eq_bot {a : Associates α} : is_unit a ↔ a = «expr⊥» := by\n  rw [Associates.isUnit_iff_eq_one, bot_eq_one]\n#align is_unit_iff_eq_bot is_unit_iff_eq_bot\n\n",
 "isUnit_of_associated_mul":
 "#print isUnit_of_associated_mul /-\ntheorem isUnit_of_associated_mul [cancel_comm_monoid_with_zero α] {p b : α} (h : Associated (p * b) p) (hp : p ≠ 0) :\n    is_unit b := by\n  cases' h with a ha\n  refine' isUnit_of_mul_eq_one b a ((mul_right_inj' hp).mp _)\n  rwa [← mul_assoc, mul_one]\n#align is_unit_of_associated_mul isUnit_of_associated_mul\n-/\n\n",
 "isUnit_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.isUnit_iff /-\ntheorem Associated.isUnit_iff [monoid α] {a b : α} (h : «expr ~ᵤ » a b) : is_unit a ↔ is_unit b :=\n  ⟨h.is_unit, h.symm.is_unit⟩\n#align associated.is_unit_iff Associated.isUnit_iff\n-/\n\n",
 "isUnit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.isUnit /-\nprotected theorem Associated.isUnit [monoid α] {a b : α} (h : «expr ~ᵤ » a b) : is_unit a → is_unit b :=\n  let ⟨u, hu⟩ := h\n  fun ⟨v, hv⟩ => ⟨v * u, by simp [hv, hu.symm]⟩\n#align associated.is_unit Associated.isUnit\n-/\n\n",
 "irreducible_units_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n#print irreducible_units_mul /-\ntheorem irreducible_units_mul (a : «expr ˣ» α) (b : α) : Irreducible (↑a * b) ↔ Irreducible b :=\n  by\n  simp only [irreducible_iff, Units.isUnit_units_mul, and_congr_right_iff]\n  refine' fun hu => ⟨fun h A B HAB => _, fun h A B HAB => _⟩\n  · rw [← a.is_unit_units_mul]\n    apply h\n    rw [mul_assoc, ← HAB]\n  · rw [← a⁻¹.is_unit_units_mul]\n    apply h\n    rw [mul_assoc, ← HAB, Units.inv_mul_cancel_left]\n#align irreducible_units_mul irreducible_units_mul\n-/\n\n",
 "irreducible_or_factor":
 "#print irreducible_or_factor /-\ntheorem irreducible_or_factor {α} [monoid α] (x : α) (h : ¬is_unit x) :\n    Irreducible x ∨ ∃ a b, ¬is_unit a ∧ ¬is_unit b ∧ a * b = x :=\n  by\n  haveI := classical.dec\n  refine' or_iff_not_imp_right.2 fun H => _\n  simp [h, irreducible_iff] at H⊢\n  refine' fun a b h => by_contradiction fun o => _\n  simp [not_or] at o\n  exact H _ o.1 _ o.2 h.symm\n#align irreducible_or_factor irreducible_or_factor\n-/\n\n",
 "irreducible_mul_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n#print irreducible_mul_units /-\ntheorem irreducible_mul_units (a : «expr ˣ» α) (b : α) : Irreducible (b * ↑a) ↔ Irreducible b :=\n  by\n  simp only [irreducible_iff, Units.isUnit_mul_units, and_congr_right_iff]\n  refine' fun hu => ⟨fun h A B HAB => _, fun h A B HAB => _⟩\n  · rw [← Units.isUnit_mul_units B a]\n    apply h\n    rw [← mul_assoc, ← HAB]\n  · rw [← Units.isUnit_mul_units B a⁻¹]\n    apply h\n    rw [← mul_assoc, ← HAB, Units.mul_inv_cancel_right]\n#align irreducible_mul_units irreducible_mul_units\n-/\n\n",
 "irreducible_mul_isUnit":
 "#print irreducible_mul_isUnit /-\ntheorem irreducible_mul_isUnit {a b : α} (h : is_unit a) : Irreducible (b * a) ↔ Irreducible b :=\n  let ⟨a, ha⟩ := h\n  ha ▸ irreducible_mul_units a b\n#align irreducible_mul_is_unit irreducible_mul_isUnit\n-/\n\n",
 "irreducible_mul_iff":
 "#print irreducible_mul_iff /-\ntheorem irreducible_mul_iff {a b : α} : Irreducible (a * b) ↔ Irreducible a ∧ is_unit b ∨ Irreducible b ∧ is_unit a :=\n  by\n  constructor\n  · refine' fun h => Or.imp (fun h' => ⟨_, h'⟩) (fun h' => ⟨_, h'⟩) (h.is_unit_or_is_unit rfl).symm\n    · rwa [irreducible_mul_isUnit h'] at h\n    · rwa [irreducible_isUnit_mul h'] at h\n  · rintro (⟨ha, hb⟩ | ⟨hb, ha⟩)\n    · rwa [irreducible_mul_isUnit hb]\n    · rwa [irreducible_isUnit_mul ha]\n#align irreducible_mul_iff irreducible_mul_iff\n-/\n\n",
 "irreducible_mk":
 "theorem irreducible_mk (a : α) : Irreducible (Associates.mk a) ↔ Irreducible a :=\n  by\n  simp only [irreducible_iff, is_unit_mk]\n  apply and_congr iff.rfl\n  constructor\n  · rintro h x y rfl\n    simpa [is_unit_mk] using h (Associates.mk x) (Associates.mk y) rfl\n  · intro h x y\n    refine' quotient.induction_on₂ x y fun x y a_eq => _\n    rcases quotient.exact a_eq.symm with ⟨u, a_eq⟩\n    rw [mul_assoc] at a_eq\n    show is_unit (Associates.mk x) ∨ is_unit (Associates.mk y)\n    simpa [is_unit_mk] using h _ _ a_eq.symm\n#align irreducible_mk irreducible_mk\n\n",
 "irreducible_isUnit_mul":
 "#print irreducible_isUnit_mul /-\ntheorem irreducible_isUnit_mul {a b : α} (h : is_unit a) : Irreducible (a * b) ↔ Irreducible b :=\n  let ⟨a, ha⟩ := h\n  ha ▸ irreducible_units_mul a b\n#align irreducible_is_unit_mul irreducible_isUnit_mul\n-/\n\n",
 "irreducible_iff_prime_iff":
 "theorem irreducible_iff_prime_iff : (∀ a : α, Irreducible a ↔ Prime a) ↔ ∀ a : Associates α, Irreducible a ↔ Prime a :=\n  by simp_rw [forall_associated, irreducible_mk, prime_mk]\n#align irreducible_iff_prime_iff irreducible_iff_prime_iff\n\n",
 "irreducible_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.irreducible_iff /-\nprotected theorem Associated.irreducible_iff [monoid α] {p q : α} (h : «expr ~ᵤ » p q) :\n    Irreducible p ↔ Irreducible q :=\n  ⟨h.irreducible, h.symm.irreducible⟩\n#align associated.irreducible_iff Associated.irreducible_iff\n-/\n\n",
 "irreducible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.irreducible /-\nprotected theorem Associated.irreducible [monoid α] {p q : α} (h : «expr ~ᵤ » p q) (hp : Irreducible p) :\n    Irreducible q :=\n  ⟨mt h.symm.is_unit hp.1,\n    let ⟨u, hu⟩ := h\n    fun a b hab =>\n    have hpab : p = a * (b * (u⁻¹ : «expr ˣ» α)) :=\n      calc\n        p = p * u * (u⁻¹ : «expr ˣ» α) := by simp\n        _ = _ := by rw [hu] <;> simp [hab, mul_assoc]\n        \n    (hp.is_unit_or_is_unit hpab).elim or.inl fun ⟨v, hv⟩ => or.inr ⟨v * u, by simp [hv]⟩⟩\n#align associated.irreducible Associated.irreducible\n-/\n\n",
 "forall_associated":
 "theorem forall_associated [monoid α] {p : Associates α → Prop} : (∀ a, p a) ↔ ∀ a, p (Associates.mk a) :=\n  iff.intro (fun h a => h _) fun h a => Quotient.inductionOn a h\n#align forall_associated forall_associated\n\n",
 "exists_rep":
 "theorem exists_rep [monoid α] (a : Associates α) : ∃ a0 : α, Associates.mk a0 = a :=\n  quot.exists_rep a\n#align exists_rep exists_rep\n\n",
 "exists_non_zero_rep":
 "theorem exists_non_zero_rep {a : Associates α} : a ≠ 0 → ∃ a0 : α, a0 ≠ 0 ∧ Associates.mk a0 = a :=\n  Quotient.inductionOn a fun b nz => ⟨b, mt (congr_arg Quotient.mk'') nz, rfl⟩\n#align exists_non_zero_rep exists_non_zero_rep\n\n",
 "eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.eq_zero_iff /-\ntheorem Associated.eq_zero_iff [monoid_with_zero α] {a b : α} (h : «expr ~ᵤ » a b) : a = 0 ↔ b = 0 :=\n  ⟨fun ha => by\n    let ⟨u, hu⟩ := h\n    simp [hu.symm, ha], fun hb => by\n    let ⟨u, hu⟩ := h.symm\n    simp [hu.symm, hb]⟩\n#align associated.eq_zero_iff Associated.eq_zero_iff\n-/\n\n",
 "eq_of_prime_pow_eq'":
 "#print eq_of_prime_pow_eq' /-\ntheorem eq_of_prime_pow_eq' (hp₁ : Prime p₁) (hp₂ : Prime p₂) (hk₁ : 0 < k₂) (h : p₁ ^ k₁ = p₂ ^ k₂) : p₁ = p₂ :=\n  by\n  rw [← associated_iff_eq] at h⊢\n  apply h.of_pow_associated_of_prime' hp₁ hp₂ hk₁\n#align eq_of_prime_pow_eq' eq_of_prime_pow_eq'\n-/\n\n",
 "eq_of_prime_pow_eq":
 "#print eq_of_prime_pow_eq /-\ntheorem eq_of_prime_pow_eq (hp₁ : Prime p₁) (hp₂ : Prime p₂) (hk₁ : 0 < k₁) (h : p₁ ^ k₁ = p₂ ^ k₂) : p₁ = p₂ :=\n  by\n  rw [← associated_iff_eq] at h⊢\n  apply h.of_pow_associated_of_prime hp₁ hp₂ hk₁\n#align eq_of_prime_pow_eq eq_of_prime_pow_eq\n-/\n\n",
 "dvd_symm":
 "#print Irreducible.dvd_symm /-\n/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem Irreducible.dvd_symm [monoid α] {p q : α} (hp : Irreducible p) (hq : Irreducible q) : p ∣ q → q ∣ p :=\n  by\n  rintro ⟨q', rfl⟩\n  rw [is_unit.mul_right_dvd (or.resolve_left (of_irreducible_mul hq) hp.not_unit)]\n#align irreducible.dvd_symm Irreducible.dvd_symm\n-/\n\n",
 "dvd_prime_pow":
 "#print dvd_prime_pow /-\ntheorem dvd_prime_pow [cancel_comm_monoid_with_zero α] {p q : α} (hp : Prime p) (n : ℕ) :\n    q ∣ p ^ n ↔ ∃ i ≤ n, Associated q (p ^ i) :=\n  by\n  induction' n with n ih generalizing q\n  · simp [← isUnit_iff_dvd_one, associated_one_iff_isUnit]\n  refine' ⟨fun h => _, fun ⟨i, hi, hq⟩ => hq.dvd.trans (pow_dvd_pow p hi)⟩\n  rw [pow_succ] at h\n  rcases hp.left_dvd_or_dvd_right_of_dvd_mul h with (⟨q, rfl⟩ | hno)\n  · rw [mul_dvd_mul_iff_left hp.ne_zero, ih] at h\n    rcases h with ⟨i, hi, hq⟩\n    refine' ⟨i + 1, nat.succ_le_succ hi, (hq.mul_left p).trans _⟩\n    rw [pow_succ]\n  · obtain ⟨i, hi, hq⟩ := ih.mp hno\n    exact ⟨i, hi.trans n.le_succ, hq⟩\n#align dvd_prime_pow dvd_prime_pow\n-/\n\n",
 "dvd_prime_iff_associated":
 "#print Prime.dvd_prime_iff_associated /-\ntheorem Prime.dvd_prime_iff_associated [cancel_comm_monoid_with_zero α] {p q : α} (pp : Prime p) (qp : Prime q) :\n    p ∣ q ↔ Associated p q :=\n  pp.irreducible.dvd_irreducible_iff_associated qp.irreducible\n#align prime.dvd_prime_iff_associated Prime.dvd_prime_iff_associated\n-/\n\n",
 "dvd_or_dvd":
 "theorem dvd_or_dvd (hp : Prime p) {a b : α} (h : p ∣ a * b) : p ∣ a ∨ p ∣ b :=\n  hp.2.2 a b h\n#align dvd_or_dvd dvd_or_dvd\n\n",
 "dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd":
 "#print Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd /-\ntheorem Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd [cancel_comm_monoid_with_zero α] {p a b : α} {n : ℕ}\n    (hp : Prime p) (hpow : p ^ n.succ ∣ a ^ n.succ * b ^ n) (hb : ¬p ^ 2 ∣ b) : p ∣ a :=\n  by\n  -- Suppose `p ∣ b`, write `b = p * x` and `hy : a ^ n.succ * b ^ n = p ^ n.succ * y`.\n  cases' hp.dvd_or_dvd ((dvd_pow_self p (nat.succ_ne_zero n)).trans hpow) with H hbdiv\n  · exact hp.dvd_of_dvd_pow H\n  obtain ⟨x, rfl⟩ := hp.dvd_of_dvd_pow hbdiv\n  obtain ⟨y, hy⟩ := hpow\n  -- Then we can divide out a common factor of `p ^ n` from the equation `hy`.\n  have : a ^ n.succ * x ^ n = p * y :=\n    by\n    refine' mul_left_cancel₀ (pow_ne_zero n hp.ne_zero) _\n    rw [← mul_assoc _ p, ← pow_succ', ← hy, mul_pow, ← mul_assoc (a ^ n.succ), mul_comm _ (p ^ n), mul_assoc]\n  -- So `p ∣ a` (and we're done) or `p ∣ x`, which can't be the case since it implies `p^2 ∣ b`.\n  refine' hp.dvd_of_dvd_pow ((hp.dvd_or_dvd ⟨_, this⟩).resolve_right fun hdvdx => hb _)\n  obtain ⟨z, rfl⟩ := hp.dvd_of_dvd_pow hdvdx\n  rw [pow_two, ← mul_assoc]\n  exact dvd_mul_right _ _\n#align prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd\n-/\n\n",
 "dvd_of_mk_le_mk":
 "theorem dvd_of_mk_le_mk {a b : α} : Associates.mk a ≤ Associates.mk b → a ∣ b\n  | ⟨c', hc'⟩ =>\n    (Quotient.inductionOn c' fun c hc =>\n        let ⟨d, hd⟩ := (quotient.exact hc).symm\n        ⟨↑d * c,\n          calc\n            b = a * c * ↑d := hd.symm\n            _ = a * (↑d * c) := by ac_rfl\n            ⟩)\n      hc'\n#align dvd_of_mk_le_mk dvd_of_mk_le_mk\n\n",
 "dvd_of_dvd_pow":
 "theorem dvd_of_dvd_pow (hp : Prime p) {a : α} {n : ℕ} (h : p ∣ a ^ n) : p ∣ a :=\n  by\n  induction' n with n ih\n  · rw [pow_zero] at h\n    have := isUnit_of_dvd_one _ h\n    have := not_unit hp\n    contradiction\n  rw [pow_succ] at h\n  cases' dvd_or_dvd hp h with dvd_a dvd_pow\n  · assumption\n  exact ih dvd_pow\n#align dvd_of_dvd_pow dvd_of_dvd_pow\n\n",
 "dvd_not_unit_of_lt":
 "theorem dvd_not_unit_of_lt {a b : Associates α} (hlt : a < b) : DvdNotUnit a b :=\n  by\n  constructor;\n  · rintro rfl\n    apply not_lt_of_le _ hlt\n    apply dvd_zero\n  rcases hlt with ⟨⟨x, rfl⟩, ndvd⟩\n  refine' ⟨x, _, rfl⟩\n  contrapose! ndvd\n  rcases ndvd with ⟨u, rfl⟩\n  simp\n#align dvd_not_unit_of_lt dvd_not_unit_of_lt\n\n",
 "dvd_not_unit_iff_lt":
 "theorem dvd_not_unit_iff_lt {a b : Associates α} : DvdNotUnit a b ↔ a < b :=\n  dvd_and_not_dvd_iff.symm\n#align dvd_not_unit_iff_lt dvd_not_unit_iff_lt\n\n",
 "dvd_irreducible_iff_associated":
 "#print Irreducible.dvd_irreducible_iff_associated /-\ntheorem Irreducible.dvd_irreducible_iff_associated [cancel_monoid_with_zero α] {p q : α} (pp : Irreducible p)\n    (qp : Irreducible q) : p ∣ q ↔ Associated p q :=\n  ⟨Irreducible.associated_of_dvd pp qp, Associated.dvd⟩\n#align irreducible.dvd_irreducible_iff_associated Irreducible.dvd_irreducible_iff_associated\n-/\n\n",
 "dvd_iff_dvd_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.dvd_iff_dvd_right /-\ntheorem Associated.dvd_iff_dvd_right [monoid α] {a b c : α} (h : «expr ~ᵤ » b c) : a ∣ b ↔ a ∣ c :=\n  let ⟨u, hu⟩ := h\n  hu ▸ units.dvd_mul_right.symm\n#align associated.dvd_iff_dvd_right Associated.dvd_iff_dvd_right\n-/\n\n",
 "dvd_iff_dvd_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.dvd_iff_dvd_left /-\ntheorem Associated.dvd_iff_dvd_left [monoid α] {a b c : α} (h : «expr ~ᵤ » a b) : a ∣ c ↔ b ∣ c :=\n  let ⟨u, hu⟩ := h\n  hu ▸ Units.mul_right_dvd.symm\n#align associated.dvd_iff_dvd_left Associated.dvd_iff_dvd_left\n-/\n\n",
 "dvd_eq_le":
 "theorem dvd_eq_le : ((· ∣ ·) : Associates α → Associates α → Prop) = (· ≤ ·) :=\n  rfl\n#align dvd_eq_le dvd_eq_le\n\n",
 "dvd_dvd_iff_associated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print dvd_dvd_iff_associated /-\ntheorem dvd_dvd_iff_associated [cancel_monoid_with_zero α] {a b : α} : a ∣ b ∧ b ∣ a ↔ «expr ~ᵤ » a b :=\n  ⟨fun ⟨h1, h2⟩ => associated_of_dvd_dvd h1 h2, Associated.dvd_dvd⟩\n#align dvd_dvd_iff_associated dvd_dvd_iff_associated\n-/\n\n",
 "dvd_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.dvd_dvd /-\nprotected theorem Associated.dvd_dvd [monoid α] {a b : α} (h : «expr ~ᵤ » a b) : a ∣ b ∧ b ∣ a :=\n  ⟨h.dvd, h.symm.dvd⟩\n#align associated.dvd_dvd Associated.dvd_dvd\n-/\n\n",
 "dvd_comm":
 "#print Irreducible.dvd_comm /-\ntheorem Irreducible.dvd_comm [monoid α] {p q : α} (hp : Irreducible p) (hq : Irreducible q) : p ∣ q ↔ q ∣ p :=\n  ⟨hp.dvd_symm hq, hq.dvd_symm hp⟩\n#align irreducible.dvd_comm Irreducible.dvd_comm\n-/\n\n",
 "dvdNotUnit_of_dvdNotUnit_associated":
 "#print dvdNotUnit_of_dvdNotUnit_associated /-\ntheorem dvdNotUnit_of_dvdNotUnit_associated [comm_monoid_with_zero α] [nontrivial α] {p q r : α} (h : DvdNotUnit p q)\n    (h' : Associated q r) : DvdNotUnit p r :=\n  by\n  obtain ⟨u, rfl⟩ := Associated.symm h'\n  obtain ⟨hp, x, hx⟩ := h\n  refine' ⟨hp, x * ↑u⁻¹, DvdNotUnit.not_unit ⟨u⁻¹.ne_zero, x, hx.left, mul_comm _ _⟩, _⟩\n  rw [← mul_assoc, ← hx.right, mul_assoc, Units.mul_inv, mul_one]\n#align dvd_not_unit_of_dvd_not_unit_associated dvdNotUnit_of_dvdNotUnit_associated\n-/\n\n",
 "dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print Associated.dvd /-\nprotected theorem Associated.dvd [monoid α] {a b : α} : «expr ~ᵤ » a b → a ∣ b := fun ⟨u, hu⟩ => ⟨u, hu.symm⟩\n#align associated.dvd Associated.dvd\n-/\n\n",
 "comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print comm /-\nprotected theorem comm [monoid α] {x y : α} : «expr ~ᵤ » x y ↔ «expr ~ᵤ » y x :=\n  ⟨Associated.symm, Associated.symm⟩\n#align comm comm\n-/\n\n",
 "comap_prime":
 "#print comap_prime /-\ntheorem comap_prime (hinv : ∀ a, g (f a : β) = a) (hp : Prime (f p)) : Prime p :=\n  ⟨fun h => hp.1 <| by simp [h], fun h => hp.2.1 <| h.map f, fun a b h => by\n    refine'\n        (hp.2.2 (f a) (f b) <| by\n              convert map_dvd f h\n              simp).imp\n          _ _ <;>\n      · intro h\n        convert ← map_dvd g h <;> apply hinv⟩\n#align comap_prime comap_prime\n-/\n\n",
 "coe_unit_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem coe_unit_eq_one (u : «expr ˣ» (Associates α)) : (u : Associates α) = 1 := by simp\n#align coe_unit_eq_one coe_unit_eq_one\n\n",
 "bot_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print bot_eq_one /-\ntheorem bot_eq_one [monoid α] : («expr⊥» : Associates α) = 1 :=\n  rfl\n#align bot_eq_one bot_eq_one\n-/\n\n",
 "associated_zero_iff_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print associated_zero_iff_eq_zero /-\ntheorem associated_zero_iff_eq_zero [monoid_with_zero α] (a : α) : «expr ~ᵤ » a 0 ↔ a = 0 :=\n  iff.intro\n    (fun h => by\n      let ⟨u, h⟩ := h.symm\n      simpa using h.symm)\n    fun h => h ▸ Associated.refl a\n#align associated_zero_iff_eq_zero associated_zero_iff_eq_zero\n-/\n\n",
 "associated_unit_mul_right_iff":
 "#print associated_unit_mul_right_iff /-\n@[simp]\ntheorem associated_unit_mul_right_iff {β : Type _} [comm_monoid β] {a b : β} {u : Units β} :\n    Associated a (↑u * b) ↔ Associated a b :=\n  associated_isUnit_mul_right_iff u.is_unit\n#align associated_unit_mul_right_iff associated_unit_mul_right_iff\n-/\n\n",
 "associated_unit_mul_right":
 "#print associated_unit_mul_right /-\ntheorem associated_unit_mul_right {β : Type _} [comm_monoid β] (a u : β) (hu : is_unit u) : Associated a (u * a) :=\n  (associated_unit_mul_left a u hu).symm\n#align associated_unit_mul_right associated_unit_mul_right\n-/\n\n",
 "associated_unit_mul_left_iff":
 "#print associated_unit_mul_left_iff /-\n@[simp]\ntheorem associated_unit_mul_left_iff {β : Type _} [comm_monoid β] {a b : β} {u : Units β} :\n    Associated (↑u * a) b ↔ Associated a b :=\n  associated_isUnit_mul_left_iff u.is_unit\n#align associated_unit_mul_left_iff associated_unit_mul_left_iff\n-/\n\n",
 "associated_unit_mul_left":
 "#print associated_unit_mul_left /-\ntheorem associated_unit_mul_left {β : Type _} [comm_monoid β] (a u : β) (hu : is_unit u) : Associated (u * a) a :=\n  by\n  rw [mul_comm]\n  exact associated_mul_unit_left _ _ hu\n#align associated_unit_mul_left associated_unit_mul_left\n-/\n\n",
 "associated_one_of_mul_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print associated_one_of_mul_eq_one /-\ntheorem associated_one_of_mul_eq_one [comm_monoid α] {a : α} (b : α) (hab : a * b = 1) : «expr ~ᵤ » a 1 :=\n  show «expr ~ᵤ » (units.mk_of_mul_eq_one a b hab : α) 1 from unit_associated_one\n#align associated_one_of_mul_eq_one associated_one_of_mul_eq_one\n-/\n\n",
 "associated_one_of_associated_mul_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print associated_one_of_associated_mul_one /-\ntheorem associated_one_of_associated_mul_one [comm_monoid α] {a b : α} : «expr ~ᵤ » (a * b) 1 → «expr ~ᵤ » a 1\n  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h\n#align associated_one_of_associated_mul_one associated_one_of_associated_mul_one\n-/\n\n",
 "associated_one_iff_isUnit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print associated_one_iff_isUnit /-\ntheorem associated_one_iff_isUnit [monoid α] {a : α} : «expr ~ᵤ » (a : α) 1 ↔ is_unit a :=\n  iff.intro\n    (fun h =>\n      let ⟨c, h⟩ := h.symm\n      h ▸ ⟨c, (one_mul _).symm⟩)\n    fun ⟨c, h⟩ => Associated.symm ⟨c, by simp [h]⟩\n#align associated_one_iff_is_unit associated_one_iff_isUnit\n-/\n\n",
 "associated_of_dvd_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print associated_of_dvd_dvd /-\ntheorem associated_of_dvd_dvd [cancel_monoid_with_zero α] {a b : α} (hab : a ∣ b) (hba : b ∣ a) : «expr ~ᵤ » a b :=\n  by\n  rcases hab with ⟨c, rfl⟩\n  rcases hba with ⟨d, a_eq⟩\n  by_cases ha0 : a = 0\n  · simp_all\n  have hac0 : a * c ≠ 0 := by\n    intro con\n    rw [con, zero_mul] at a_eq\n    apply ha0 a_eq\n  have : a * (c * d) = a * 1 := by rw [← mul_assoc, ← a_eq, mul_one]\n  have hcd : c * d = 1 := mul_left_cancel₀ ha0 this\n  have : a * c * (d * c) = a * c * 1 := by rw [← mul_assoc, ← a_eq, mul_one]\n  have hdc : d * c = 1 := mul_left_cancel₀ hac0 this\n  exact ⟨⟨c, d, hcd, hdc⟩, rfl⟩\n#align associated_of_dvd_dvd associated_of_dvd_dvd\n-/\n\n",
 "associated_of_dvd":
 "#print Prime.associated_of_dvd /-\ntheorem Prime.associated_of_dvd [cancel_comm_monoid_with_zero α] {p q : α} (p_prime : Prime p) (q_prime : Prime q)\n    (dvd : p ∣ q) : Associated p q :=\n  p_prime.irreducible.associated_of_dvd q_prime.irreducible dvd\n#align prime.associated_of_dvd Prime.associated_of_dvd\n-/\n\n",
 "associated_mul_unit_right_iff":
 "#print associated_mul_unit_right_iff /-\n@[simp]\ntheorem associated_mul_unit_right_iff {β : Type _} [monoid β] {a b : β} {u : Units β} :\n    Associated a (b * u) ↔ Associated a b :=\n  associated_mul_isUnit_right_iff u.is_unit\n#align associated_mul_unit_right_iff associated_mul_unit_right_iff\n-/\n\n",
 "associated_mul_unit_right":
 "#print associated_mul_unit_right /-\ntheorem associated_mul_unit_right {β : Type _} [monoid β] (a u : β) (hu : is_unit u) : Associated a (a * u) :=\n  (associated_mul_unit_left a u hu).symm\n#align associated_mul_unit_right associated_mul_unit_right\n-/\n\n",
 "associated_mul_unit_left_iff":
 "#print associated_mul_unit_left_iff /-\n@[simp]\ntheorem associated_mul_unit_left_iff {β : Type _} [monoid β] {a b : β} {u : Units β} :\n    Associated (a * u) b ↔ Associated a b :=\n  associated_mul_isUnit_left_iff u.is_unit\n#align associated_mul_unit_left_iff associated_mul_unit_left_iff\n-/\n\n",
 "associated_mul_unit_left":
 "#print associated_mul_unit_left /-\ntheorem associated_mul_unit_left {β : Type _} [monoid β] (a u : β) (hu : is_unit u) : Associated (a * u) a :=\n  let ⟨u', hu⟩ := hu\n  ⟨u'⁻¹, hu ▸ Units.mul_inv_cancel_right _ _⟩\n#align associated_mul_unit_left associated_mul_unit_left\n-/\n\n",
 "associated_mul_isUnit_right_iff":
 "#print associated_mul_isUnit_right_iff /-\ntheorem associated_mul_isUnit_right_iff {β : Type _} [monoid β] {a b u : β} (hu : is_unit u) :\n    Associated a (b * u) ↔ Associated a b :=\n  Associated.comm.trans <| (associated_mul_isUnit_left_iff hu).trans Associated.comm\n#align associated_mul_is_unit_right_iff associated_mul_isUnit_right_iff\n-/\n\n",
 "associated_mul_isUnit_left_iff":
 "#print associated_mul_isUnit_left_iff /-\ntheorem associated_mul_isUnit_left_iff {β : Type _} [monoid β] {a u b : β} (hu : is_unit u) :\n    Associated (a * u) b ↔ Associated a b :=\n  ⟨trans (associated_mul_unit_right _ _ hu), trans (associated_mul_unit_left _ _ hu)⟩\n#align associated_mul_is_unit_left_iff associated_mul_isUnit_left_iff\n-/\n\n",
 "associated_map_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\ntheorem associated_map_mk {f : «expr →* » (Associates α) α} (hinv : function.right_inverse f Associates.mk) (a : α) :\n    «expr ~ᵤ » a (f (Associates.mk a)) :=\n  Associates.mk_eq_mk_iff_associated.1 (hinv (Associates.mk a)).symm\n#align associated_map_mk associated_map_mk\n\n",
 "associated_isUnit_mul_right_iff":
 "#print associated_isUnit_mul_right_iff /-\ntheorem associated_isUnit_mul_right_iff {β : Type _} [comm_monoid β] {a u b : β} (hu : is_unit u) :\n    Associated a (u * b) ↔ Associated a b :=\n  Associated.comm.trans <| (associated_isUnit_mul_left_iff hu).trans Associated.comm\n#align associated_is_unit_mul_right_iff associated_isUnit_mul_right_iff\n-/\n\n",
 "associated_isUnit_mul_left_iff":
 "#print associated_isUnit_mul_left_iff /-\ntheorem associated_isUnit_mul_left_iff {β : Type _} [comm_monoid β] {u a b : β} (hu : is_unit u) :\n    Associated (u * a) b ↔ Associated a b := by\n  rw [mul_comm]\n  exact associated_mul_isUnit_left_iff hu\n#align associated_is_unit_mul_left_iff associated_isUnit_mul_left_iff\n-/\n\n",
 "associated_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print associated_iff_eq /-\ntheorem associated_iff_eq {x y : α} : «expr ~ᵤ » x y ↔ x = y :=\n  by\n  constructor\n  · rintro ⟨c, rfl⟩\n    rw [units_eq_one c, Units.val_one, mul_one]\n  · rintro rfl\n    rfl\n#align associated_iff_eq associated_iff_eq\n-/\n\n",
 "associated_eq_eq":
 "#print associated_eq_eq /-\ntheorem associated_eq_eq : (Associated : α → α → Prop) = eq :=\n  by\n  ext\n  rw [associated_iff_eq]\n#align associated_eq_eq associated_eq_eq\n-/\n\n"}