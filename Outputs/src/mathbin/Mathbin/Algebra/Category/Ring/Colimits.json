{"quot_zero":
 "/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n-- [ROBOT VOICE]:\n-- You should pretend for now that this file was automatically generated.\n-- It follows the same template as colimits in Mon.\n/-\n`#print comm_ring` says:\n\nstructure comm_ring : Type u → Type u\nfields:\ncomm_ring.zero : Π (α : Type u) [c : comm_ring α], α\ncomm_ring.one : Π (α : Type u) [c : comm_ring α], α\ncomm_ring.neg : Π {α : Type u} [c : comm_ring α], α → α\ncomm_ring.add : Π {α : Type u} [c : comm_ring α], α → α → α\ncomm_ring.mul : Π {α : Type u} [c : comm_ring α], α → α → α\n\ncomm_ring.zero_add : ∀ {α : Type u} [c : comm_ring α] (a : α), 0 + a = a\ncomm_ring.add_zero : ∀ {α : Type u} [c : comm_ring α] (a : α), a + 0 = a\ncomm_ring.one_mul : ∀ {α : Type u} [c : comm_ring α] (a : α), 1 * a = a\ncomm_ring.mul_one : ∀ {α : Type u} [c : comm_ring α] (a : α), a * 1 = a\ncomm_ring.add_left_neg : ∀ {α : Type u} [c : comm_ring α] (a : α), -a + a = 0\ncomm_ring.add_comm : ∀ {α : Type u} [c : comm_ring α] (a b : α), a + b = b + a\ncomm_ring.mul_comm : ∀ {α : Type u} [c : comm_ring α] (a b : α), a * b = b * a\ncomm_ring.add_assoc : ∀ {α : Type u} [c : comm_ring α] (a b c_1 : α), a + b + c_1 = a + (b + c_1)\ncomm_ring.mul_assoc : ∀ {α : Type u} [c : comm_ring α] (a b c_1 : α), a * b * c_1 = a * (b * c_1)\ncomm_ring.left_distrib : ∀ {α : Type u} [c : comm_ring α] (a b c_1 : α),\n                                                            a * (b + c_1) = a * b + a * c_1\ncomm_ring.right_distrib : ∀ {α : Type u} [c : comm_ring α] (a b c_1 : α),\n                                                            (a + b) * c_1 = a * c_1 + b * c_1\n-/\n-- There's always `of`\n-- Then one generator for each operation\n-- Make it an equivalence relation:\n-- There's always a `map` relation\n-- Then one relation per operation, describing the interaction with `of`\n-- Then one relation per argument of each operation\n-- And one relation per axiom\n@[simp]\ntheorem quot_zero : Quot.mk Setoid.r zero = (0 : colimit_type F) :=\n  rfl\n#align quot_zero quot_zero\n\n",
 "quot_one":
 "@[simp]\ntheorem quot_one : Quot.mk Setoid.r one = (1 : colimit_type F) :=\n  rfl\n#align quot_one quot_one\n\n",
 "quot_neg":
 "@[simp]\ntheorem quot_neg (x) : Quot.mk Setoid.r (neg x) = (-Quot.mk Setoid.r x : colimit_type F) :=\n  rfl\n#align quot_neg quot_neg\n\n",
 "quot_mul":
 "@[simp]\ntheorem quot_mul (x y) : Quot.mk Setoid.r (mul x y) = (Quot.mk Setoid.r x * Quot.mk Setoid.r y : colimit_type F) :=\n  rfl\n#align quot_mul quot_mul\n\n",
 "quot_add":
 "@[simp]\ntheorem quot_add (x y) : Quot.mk Setoid.r (add x y) = (Quot.mk Setoid.r x + Quot.mk Setoid.r y : colimit_type F) :=\n  rfl\n#align quot_add quot_add\n\n",
 "cocone_naturality_components":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem cocone_naturality_components (j j' : J) (f : «expr ⟶ » j j') (x : F.obj j) :\n    (cocone_morphism F j') (F.map f x) = (cocone_morphism F j) x :=\n  by\n  rw [← cocone_naturality F f]\n  rfl\n#align cocone_naturality_components cocone_naturality_components\n\n",
 "cocone_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem cocone_naturality {j j' : J} (f : «expr ⟶ » j j') :\n    «expr ≫ » (F.map f) (cocone_morphism F j') = cocone_morphism F j :=\n  by\n  ext\n  apply quot.sound\n  apply Relation.Map\n#align cocone_naturality cocone_naturality\n\n"}