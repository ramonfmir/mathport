{"mk_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2021 Justus Springer. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Justus Springer\n-/\n-- avoid name collision with `_root_.max`.\n-- We use parameters here, mainly so we can have the abbreviations `M` and `M.mk` below, without\n-- passing around `F` all the time.\ntheorem M.mk_eq (x y : Σj, F.obj j)\n    (h : ∃ (k : J)(f : «expr ⟶ » x.1 k)(g : «expr ⟶ » y.1 k), F.map f x.2 = F.map g y.2) : M.mk x = M.mk y :=\n  Quot.EqvGen_sound (Types.FilteredColimit.eqvGen_quot_rel_of_rel («expr ⋙ » F (forget (ModuleCat R))) x y h)\n#align M.mk_eq M.mk_eq\n\n",
 "colimit_smul_mk_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem colimit_smul_mk_eq (r : R) (x : Σj, F.obj j) : «expr • » r (M.mk x) = M.mk ⟨x.1, «expr • » r x.2⟩ :=\n  rfl\n#align colimit_smul_mk_eq colimit_smul_mk_eq\n\n",
 "colimit_smul_aux_eq_of_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem colimit_smul_aux_eq_of_rel (r : R) (x y : Σj, F.obj j)\n    (h : Types.FilteredColimit.Rel («expr ⋙ » F (forget (ModuleCat R))) x y) :\n    colimit_smul_aux r x = colimit_smul_aux r y := by\n  apply M.mk_eq\n  obtain ⟨k, f, g, hfg⟩ := h\n  use k, f, g\n  simp only [CategoryTheory.Functor.comp_map, forget_map_eq_coe] at hfg\n  rw [LinearMap.map_smul, LinearMap.map_smul, hfg]\n#align colimit_smul_aux_eq_of_rel colimit_smul_aux_eq_of_rel\n\n"}