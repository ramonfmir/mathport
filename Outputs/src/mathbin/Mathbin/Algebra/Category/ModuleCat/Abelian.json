{"exact_iff":
 "/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel\n-/\n/- The following [invalid Lean code](https://github.com/leanprover-community/lean/issues/341)\n        might help you understand what's going on here:\n        ```\n        calc\n        M   ≃ₗ[R] f.ker.quotient  : (submodule.quot_equiv_of_eq_bot _ (ker_eq_bot_of_mono _)).symm\n        ... ≃ₗ[R] f.range         : linear_map.quot_ker_equiv_range f\n        ... ≃ₗ[R] r.range.mkq.ker : linear_equiv.of_eq _ _ (submodule.ker_mkq _).symm\n        ```\n      -/\n/- The following invalid Lean code might help you understand what's going on here:\n        ```\n        calc f.ker.subtype.range.quotient\n            ≃ₗ[R] f.ker.quotient : submodule.quot_equiv_of_eq _ _ (submodule.range_subtype _)\n        ... ≃ₗ[R] f.range        : linear_map.quot_ker_equiv_range f\n        ... ≃ₗ[R] N              : linear_equiv.of_top _ (range_eq_top_of_epi _)\n        ```\n      -/\n/- We need to put this in this weird spot because we need to know that the category of modules\n    is balanced. -/\ntheorem exact_iff : exact f g ↔ f.range = g.ker :=\n  by\n  rw [abelian.exact_iff' f g (kernel_is_limit _) (cokernel_is_colimit _)]\n  exact\n    ⟨fun h => le_antisymm (range_le_ker_iff.2 h.1) (ker_le_range_iff.2 h.2), fun h =>\n      ⟨range_le_ker_iff.1 <| le_of_eq h, ker_le_range_iff.1 <| le_of_eq h.symm⟩⟩\n#align exact_iff exact_iff\n\n"}