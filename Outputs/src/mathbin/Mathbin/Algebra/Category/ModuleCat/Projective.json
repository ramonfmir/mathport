{"projective_of_free":
 "-- We transport the corresponding result from `module.projective`.\n/-- Modules that have a basis are projective. -/\ntheorem projective_of_free {ι : Type _} (b : basis ι R M) : projective M :=\n  projective.of_iso (Module.of_self_iso _) (is_projective.iff_projective.mp (module.projective_of_basis b))\n#align projective_of_free projective_of_free\n\n",
 "iff_projective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Module.as_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Module.as_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Module.as_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Module.as_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Module.as_hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Module.as_hom -/\n/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel, Scott Morrison\n-/\n/-- The categorical notion of projective object agrees with the explicit module-theoretic notion. -/\ntheorem is_projective.iff_projective {R : Type u} [Ring R] {P : Type max u v} [add_comm_group P] [Module R P] :\n    module.projective R P ↔ projective (Module.of R P) :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · letI : module.projective R («expr↥ » (Module.of R P)) := h\n    exact ⟨fun E X f e epi => module.projective_lifting_property _ _ ((Module.epi_iff_surjective _).mp epi)⟩\n  · refine' module.projective_of_lifting_property _\n    intro E X mE mX sE sX f g s\n    haveI : epi (Module.as_hom f) := (Module.epi_iff_surjective (Module.as_hom f)).mpr s\n    letI : projective (Module.of R P) := h\n    exact\n      ⟨projective.factor_thru (Module.as_hom g) (Module.as_hom f),\n        projective.factor_thru_comp (Module.as_hom g) (Module.as_hom f)⟩\n#align is_projective.iff_projective is_projective.iff_projective\n\n"}