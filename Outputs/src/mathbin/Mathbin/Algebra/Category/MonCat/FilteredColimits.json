{"mk_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2021 Justus Springer. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Justus Springer\n-/\n-- avoid name collision with `_root_.max`.\n-- We use parameters here, mainly so we can have the abbreviations `M` and `M.mk` below, without\n-- passing around `F` all the time.\n@[to_additive]\ntheorem M.mk_eq (x y : Σj, F.obj j)\n    (h : ∃ (k : J)(f : «expr ⟶ » x.1 k)(g : «expr ⟶ » y.1 k), F.map f x.2 = F.map g y.2) : M.mk x = M.mk y :=\n  Quot.EqvGen_sound (types.filtered_colimit.eqv_gen_quot_rel_of_rel («expr ⋙ » F (forget Mon)) x y h)\n#align M.mk_eq M.mk_eq\n\n",
 "colimit_one_eq":
 "/-- The definition of the \"one\" in the colimit is independent of the chosen object of `J`.\nIn particular, this lemma allows us to \"unfold\" the definition of `colimit_one` at a custom chosen\nobject `j`.\n-/\n@[to_additive\n      \"The definition of the \\\"zero\\\" in the colimit is independent of the chosen object\\nof `J`. In particular, this lemma allows us to \\\"unfold\\\" the definition of `colimit_zero` at a\\ncustom chosen object `j`.\"]\ntheorem colimit_one_eq (j : J) : (1 : M) = M.mk ⟨j, 1⟩ :=\n  by\n  apply M.mk_eq\n  refine' ⟨max' _ j, left_to_max _ j, right_to_max _ j, _⟩\n  simp\n#align colimit_one_eq colimit_one_eq\n\n",
 "colimit_mul_mk_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Multiplication in the colimit is independent of the chosen \"maximum\" in the filtered category.\nIn particular, this lemma allows us to \"unfold\" the definition of the multiplication of `x` and `y`,\nusing a custom object `k` and morphisms `f : x.1 ⟶ k` and `g : y.1 ⟶ k`.\n-/\n@[to_additive\n      \"Addition in the colimit is independent of the chosen \\\"maximum\\\" in the filtered\\ncategory. In particular, this lemma allows us to \\\"unfold\\\" the definition of the addition of `x`\\nand `y`, using a custom object `k` and morphisms `f : x.1 ⟶ k` and `g : y.1 ⟶ k`.\"]\ntheorem colimit_mul_mk_eq (x y : Σj, F.obj j) (k : J) (f : «expr ⟶ » x.1 k) (g : «expr ⟶ » y.1 k) :\n    M.mk x * M.mk y = M.mk ⟨k, F.map f x.2 * F.map g y.2⟩ :=\n  by\n  cases' x with j₁ x; cases' y with j₂ y\n  obtain ⟨s, α, β, h₁, h₂⟩ := bowtie (left_to_max j₁ j₂) f (right_to_max j₁ j₂) g\n  apply M.mk_eq\n  use s, α, β\n  dsimp\n  simp_rw [MonoidHom.map_mul, ← comp_apply, ← F.map_comp, h₁, h₂]\n#align colimit_mul_mk_eq colimit_mul_mk_eq\n\n",
 "colimit_mul_aux_eq_of_rel_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- Multiplication in the colimit is well-defined in the right argument. -/\n@[to_additive \"Addition in the colimit is well-defined in the right argument.\"]\ntheorem colimit_mul_aux_eq_of_rel_right {x y y' : Σj, F.obj j}\n    (hyy' : types.filtered_colimit.rel («expr ⋙ » F (forget Mon)) y y') : colimit_mul_aux x y = colimit_mul_aux x y' :=\n  by\n  cases' y with j₁ y; cases' x with j₂ x; cases' y' with j₃ y'\n  obtain ⟨l, f, g, hfg⟩ := hyy'\n  simp at hfg\n  obtain ⟨s, α, β, γ, h₁, h₂, h₃⟩ :=\n    tulip (right_to_max j₂ j₁) (left_to_max j₂ j₁) (left_to_max j₂ j₃) (right_to_max j₂ j₃) f g\n  apply M.mk_eq\n  use s, α, γ\n  dsimp\n  simp_rw [MonoidHom.map_mul, ← comp_apply, ← F.map_comp, h₁, h₂, h₃, F.map_comp, comp_apply, hfg]\n#align colimit_mul_aux_eq_of_rel_right colimit_mul_aux_eq_of_rel_right\n\n",
 "colimit_mul_aux_eq_of_rel_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- Multiplication in the colimit is well-defined in the left argument. -/\n@[to_additive \"Addition in the colimit is well-defined in the left argument.\"]\ntheorem colimit_mul_aux_eq_of_rel_left {x x' y : Σj, F.obj j}\n    (hxx' : types.filtered_colimit.rel («expr ⋙ » F (forget Mon)) x x') : colimit_mul_aux x y = colimit_mul_aux x' y :=\n  by\n  cases' x with j₁ x; cases' y with j₂ y; cases' x' with j₃ x'\n  obtain ⟨l, f, g, hfg⟩ := hxx'\n  simp at hfg\n  obtain ⟨s, α, β, γ, h₁, h₂, h₃⟩ :=\n    tulip (left_to_max j₁ j₂) (right_to_max j₁ j₂) (right_to_max j₃ j₂) (left_to_max j₃ j₂) f g\n  apply M.mk_eq\n  use s, α, γ\n  dsimp\n  simp_rw [MonoidHom.map_mul, ← comp_apply, ← F.map_comp, h₁, h₂, h₃, F.map_comp, comp_apply, hfg]\n#align colimit_mul_aux_eq_of_rel_left colimit_mul_aux_eq_of_rel_left\n\n",
 "cocone_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, to_additive]\ntheorem cocone_naturality {j j' : J} (f : «expr ⟶ » j j') :\n    «expr ≫ » (F.map f) (cocone_morphism j') = cocone_morphism j :=\n  MonoidHom.coe_inj ((types.colimit_cocone («expr ⋙ » F (forget Mon))).ι.naturality f)\n#align cocone_naturality cocone_naturality\n\n"}