{"injective_of_injective_as_module":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2022 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang\n-/\ntheorem injective_of_injective_as_module [injective (⟨A⟩ : Module ℤ)] :\n    category_theory.injective (⟨A⟩ : AddCommGroup) :=\n  {\n    factors := fun X Y g f m => by\n      skip\n      let G : «expr ⟶ » (⟨X⟩ : Module ℤ) ⟨A⟩ :=\n        { g with\n          map_smul' := by\n            intros\n            rw [RingHom.id_apply, g.to_fun_eq_coe, map_zsmul] }\n      let F : «expr ⟶ » (⟨X⟩ : Module ℤ) ⟨Y⟩ :=\n        { f with\n          map_smul' := by\n            intros\n            rw [RingHom.id_apply, f.to_fun_eq_coe, map_zsmul] }\n      have : mono F := by\n        refine' ⟨fun Z α β eq1 => _⟩\n        let α' : «expr ⟶ » (AddCommGroup.of Z) X := α.to_add_monoid_hom\n        let β' : «expr ⟶ » (AddCommGroup.of Z) X := β.to_add_monoid_hom\n        have eq2 : «expr ≫ » α' f = «expr ≫ » β' f := by\n          ext\n          simp only [category_theory.comp_apply, linear_map.to_add_monoid_hom_coe]\n          simpa only [Module.coe_comp, linear_map.coe_mk, Function.comp_apply] using fun_like.congr_fun eq1 x\n        rw [cancel_mono] at eq2\n        ext\n        simpa only using fun_like.congr_fun eq2 x\n      refine' ⟨(injective.factor_thru G F).to_add_monoid_hom, _⟩\n      ext\n      convert fun_like.congr_fun (injective.comp_factor_thru G F) x }\n#align injective_of_injective_as_module injective_of_injective_as_module\n\n",
 "injective_as_module_of_injective_as_Ab":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem injective_as_module_of_injective_as_Ab [injective (⟨A⟩ : AddCommGroup)] : injective (⟨A⟩ : Module ℤ) :=\n  {\n    factors := fun X Y g f m => by\n      skip\n      let G : «expr ⟶ » (⟨X⟩ : AddCommGroup) ⟨A⟩ := g.to_add_monoid_hom\n      let F : «expr ⟶ » (⟨X⟩ : AddCommGroup) ⟨Y⟩ := f.to_add_monoid_hom\n      have : mono F := by\n        rw [mono_iff_injective]\n        intro _ _ h\n        exact ((Module.mono_iff_injective f).mp m) h\n      refine' ⟨{ injective.factor_thru G F with map_smul' := _ }, _⟩\n      · intro m x\n        rw [add_monoid_hom.to_fun_eq_coe, RingHom.id_apply]\n        induction' m using int.induction_on with n hn n hn\n        · rw [zero_smul]\n          convert map_zero _\n          convert zero_smul _ x\n        · simp only [add_smul, map_add, hn, one_smul]\n        · simp only [sub_smul, map_sub, hn, one_smul]\n      ext\n      convert fun_like.congr_fun (injective.comp_factor_thru G F) x }\n#align injective_as_module_of_injective_as_Ab injective_as_module_of_injective_as_Ab\n\n"}