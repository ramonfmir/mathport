{"mk_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2021 Justus Springer. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Justus Springer\n-/\n-- avoid name collision with `_root_.max`.\n-- We use parameters here, mainly so we can have the abbreviations `G` and `G.mk` below, without\n-- passing around `F` all the time.\n@[to_additive]\ntheorem G.mk_eq (x y : Σj, F.obj j)\n    (h : ∃ (k : J)(f : «expr ⟶ » x.1 k)(g : «expr ⟶ » y.1 k), F.map f x.2 = F.map g y.2) : G.mk x = G.mk y :=\n  Quot.EqvGen_sound (Types.FilteredColimit.eqvGen_quot_rel_of_rel («expr ⋙ » F (forget GroupCat)) x y h)\n#align G.mk_eq G.mk_eq\n\n",
 "colimit_inv_mk_eq":
 "@[simp, to_additive]\ntheorem colimit_inv_mk_eq (x : Σj, F.obj j) : (G.mk x)⁻¹ = G.mk ⟨x.1, x.2⁻¹⟩ :=\n  rfl\n#align colimit_inv_mk_eq colimit_inv_mk_eq\n\n",
 "colimit_inv_aux_eq_of_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n@[to_additive]\ntheorem colimit_inv_aux_eq_of_rel (x y : Σj, F.obj j)\n    (h : Types.FilteredColimit.Rel («expr ⋙ » F (forget GroupCat)) x y) : colimit_inv_aux x = colimit_inv_aux y :=\n  by\n  apply G.mk_eq\n  obtain ⟨k, f, g, hfg⟩ := h\n  use k, f, g\n  rw [MonoidHom.map_inv, MonoidHom.map_inv, inv_inj]\n  exact hfg\n#align colimit_inv_aux_eq_of_rel colimit_inv_aux_eq_of_rel\n\n"}