{"self_eq_mul_right":
 "#print self_eq_mul_right /-\n@[simp, to_additive]\ntheorem self_eq_mul_right : a = a * b ↔ b = 1 :=\n  eq_comm.trans mul_right_eq_self\n#align self_eq_mul_right self_eq_mul_right\n-/\n\n",
 "self_eq_mul_left":
 "#print self_eq_mul_left /-\n@[simp, to_additive]\ntheorem self_eq_mul_left : b = a * b ↔ a = 1 :=\n  eq_comm.trans mul_left_eq_self\n#align self_eq_mul_left self_eq_mul_left\n-/\n\n",
 "rightInverse_inv":
 "#print rightInverse_inv /-\n@[to_additive]\ntheorem rightInverse_inv : left_inverse (fun a : G => a⁻¹) fun a => a⁻¹ :=\n  inv_inv\n#align right_inverse_inv rightInverse_inv\n-/\n\n",
 "one_mul_eq_id":
 "#print one_mul_eq_id /-\n@[to_additive]\ntheorem one_mul_eq_id : (· * ·) (1 : M) = id :=\n  funext one_mul\n#align one_mul_eq_id one_mul_eq_id\n-/\n\n",
 "one_eq_inv":
 "#print one_eq_inv /-\n@[simp, to_additive]\ntheorem one_eq_inv : 1 = a⁻¹ ↔ a = 1 :=\n  eq_comm.trans inv_eq_one\n#align one_eq_inv one_eq_inv\n-/\n\n",
 "one_div_one_div":
 "#print one_div_one_div /-\n@[to_additive]\ntheorem one_div_one_div : 1 / (1 / a) = a := by simp\n#align one_div_one_div one_div_one_div\n-/\n\n",
 "one_div_one":
 "#print one_div_one /-\n@[to_additive]\ntheorem one_div_one : (1 : G) / 1 = 1 :=\n  div_one _\n#align one_div_one one_div_one\n-/\n\n",
 "one_div_mul_one_div_rev":
 "#print one_div_mul_one_div_rev /-\n@[to_additive]\ntheorem one_div_mul_one_div_rev : 1 / a * (1 / b) = 1 / (b * a) := by simp\n#align one_div_mul_one_div_rev one_div_mul_one_div_rev\n-/\n\n",
 "one_div_mul_one_div":
 "#print one_div_mul_one_div /-\n@[to_additive]\ntheorem one_div_mul_one_div : 1 / a * (1 / b) = 1 / (a * b) := by simp\n#align one_div_mul_one_div one_div_mul_one_div\n-/\n\n",
 "one_div_div":
 "#print one_div_div /-\n@[simp, to_additive]\ntheorem one_div_div : 1 / (a / b) = b / a := by simp\n#align one_div_div one_div_div\n-/\n\n",
 "one_div":
 "#print one_div /-\n@[simp, to_additive]\ntheorem one_div (a : G) : 1 / a = a⁻¹ :=\n  (inv_eq_one_div a).symm\n#align one_div one_div\n-/\n\n",
 "multiplicative_of_symmetric_of_is_total":
 "@[to_additive additive_of_symmetric_of_is_total]\ntheorem multiplicative_of_symmetric_of_is_total (hsymm : symmetric p) (hf_swap : ∀ {a b}, p a b → f a b * f b a = 1)\n    (hmul : ∀ {a b c}, r a b → r b c → p a b → p b c → p a c → f a c = f a b * f b c) {a b c : α} (pab : p a b)\n    (pbc : p b c) (pac : p a c) : f a c = f a b * f b c :=\n  by\n  suffices ∀ {b c}, r b c → p a b → p b c → p a c → f a c = f a b * f b c\n    by\n    obtain rbc | rcb := total_of r b c\n    · exact this rbc pab pbc pac\n    · rw [this rcb pac (hsymm pbc) pab, mul_assoc, hf_swap (hsymm pbc), mul_one]\n  intro b c rbc pab pbc pac\n  obtain rab | rba := total_of r a b\n  · exact hmul rab rbc pab pbc pac\n  rw [← one_mul (f a c), ← hf_swap pab, mul_assoc]\n  obtain rac | rca := total_of r a c\n  · rw [hmul rba rac (hsymm pab) pac pbc]\n  · rw [hmul rbc rca pbc (hsymm pac) (hsymm pab), mul_assoc, hf_swap (hsymm pac), mul_one]\n#align multiplicative_of_symmetric_of_is_total multiplicative_of_symmetric_of_is_total\n\n",
 "multiplicative_of_IsTotal":
 "#print multiplicative_of_IsTotal /-\n/-- If a binary function from a type equipped with a total relation `r` to a monoid is\n  anti-symmetric (i.e. satisfies `f a b * f b a = 1`), in order to show it is multiplicative\n  (i.e. satisfies `f a c = f a b * f b c`), we may assume `r a b` and `r b c` are satisfied.\n  We allow restricting to a subset specified by a predicate `p`. -/\n@[to_additive additive_of_IsTotal\n      \"If a binary function from a type equipped with a total relation\\n  `r` to an additive monoid is anti-symmetric (i.e. satisfies `f a b + f b a = 0`), in order to show\\n  it is additive (i.e. satisfies `f a c = f a b + f b c`), we may assume `r a b` and `r b c`\\n  are satisfied. We allow restricting to a subset specified by a predicate `p`.\"]\ntheorem multiplicative_of_IsTotal (p : α → Prop) (hswap : ∀ {a b}, p a → p b → f a b * f b a = 1)\n    (hmul : ∀ {a b c}, r a b → r b c → p a → p b → p c → f a c = f a b * f b c) {a b c : α} (pa : p a) (pb : p b)\n    (pc : p c) : f a c = f a b * f b c :=\n  by\n  apply multiplicative_of_symmetric_of_is_total (fun a b => p a ∧ p b) r f fun _ _ => And.symm\n  · simp_rw [and_imp]\n    exact @hswap\n  · exact fun a b c rab rbc pab pbc pac => hmul rab rbc pab.1 pab.2 pac.2\n  exacts[⟨pa, pb⟩, ⟨pb, pc⟩, ⟨pa, pc⟩]\n#align multiplicative_of_is_total multiplicative_of_IsTotal\n-/\n\n",
 "mul_rotate'":
 "#print mul_rotate' /-\n@[to_additive]\ntheorem mul_rotate' (a b c : G) : a * (b * c) = b * (c * a) := by simp only [mul_left_comm, mul_comm]\n#align mul_rotate' mul_rotate'\n-/\n\n",
 "mul_rotate":
 "#print mul_rotate /-\n@[to_additive]\ntheorem mul_rotate (a b c : G) : a * b * c = b * c * a := by simp only [mul_left_comm, mul_comm]\n#align mul_rotate mul_rotate\n-/\n\n",
 "mul_right_surjective":
 "#print mul_right_surjective /-\n@[to_additive]\ntheorem mul_right_surjective (a : G) : function.surjective fun x => x * a := fun x =>\n  ⟨x * a⁻¹, inv_mul_cancel_right x a⟩\n#align mul_right_surjective mul_right_surjective\n-/\n\n",
 "mul_right_eq_self":
 "#print mul_right_eq_self /-\n@[simp, to_additive]\ntheorem mul_right_eq_self : a * b = a ↔ b = 1 :=\n  calc\n    a * b = a ↔ a * b = a * 1 := by rw [mul_one]\n    _ ↔ b = 1 := mul_left_cancel_iff\n    \n#align mul_right_eq_self mul_right_eq_self\n-/\n\n",
 "mul_right_comm":
 "#print mul_right_comm /-\n@[to_additive]\ntheorem mul_right_comm : ∀ a b c : G, a * b * c = a * c * b :=\n  right_comm has_mul.mul mul_comm mul_assoc\n#align mul_right_comm mul_right_comm\n-/\n\n",
 "mul_one_eq_id":
 "#print mul_one_eq_id /-\n@[to_additive]\ntheorem mul_one_eq_id : (· * (1 : M)) = id :=\n  funext mul_one\n#align mul_one_eq_id mul_one_eq_id\n-/\n\n",
 "mul_one_div":
 "#print mul_one_div /-\n@[to_additive]\ntheorem mul_one_div (x y : G) : x * (1 / y) = x / y := by rw [div_eq_mul_inv, one_mul, div_eq_mul_inv]\n#align mul_one_div mul_one_div\n-/\n\n",
 "mul_mul_mul_comm":
 "#print mul_mul_mul_comm /-\n@[to_additive]\ntheorem mul_mul_mul_comm (a b c d : G) : a * b * (c * d) = a * c * (b * d) := by simp only [mul_left_comm, mul_assoc]\n#align mul_mul_mul_comm mul_mul_mul_comm\n-/\n\n",
 "mul_mul_inv_cancel'_right":
 "#print mul_mul_inv_cancel'_right /-\n-- This lemma is in the `simp` set under the name `mul_inv_cancel_comm_assoc`,\n-- along with the additive version `add_neg_cancel_comm_assoc`,\n-- defined  in `algebra/group/commute`\n@[to_additive]\ntheorem mul_mul_inv_cancel'_right (a b : G) : a * (b * a⁻¹) = b := by rw [← div_eq_mul_inv, mul_div_cancel'_right a b]\n#align mul_mul_inv_cancel'_right mul_mul_inv_cancel'_right\n-/\n\n",
 "mul_mul_div_cancel":
 "#print mul_mul_div_cancel /-\n@[simp, to_additive]\ntheorem mul_mul_div_cancel (a b c : G) : a * c * (b / c) = a * b := by rw [mul_assoc, mul_div_cancel'_right]\n#align mul_mul_div_cancel mul_mul_div_cancel\n-/\n\n",
 "mul_left_surjective":
 "#print mul_left_surjective /-\n@[to_additive]\ntheorem mul_left_surjective (a : G) : function.surjective ((· * ·) a) := fun x => ⟨a⁻¹ * x, mul_inv_cancel_left a x⟩\n#align mul_left_surjective mul_left_surjective\n-/\n\n",
 "mul_left_eq_self":
 "#print mul_left_eq_self /-\n@[simp, to_additive]\ntheorem mul_left_eq_self : a * b = b ↔ a = 1 :=\n  calc\n    a * b = b ↔ a * b = 1 * b := by rw [one_mul]\n    _ ↔ a = 1 := mul_right_cancel_iff\n    \n#align mul_left_eq_self mul_left_eq_self\n-/\n\n",
 "mul_left_comm":
 "#print mul_left_comm /-\n@[no_rsimp, to_additive]\ntheorem mul_left_comm : ∀ a b c : G, a * (b * c) = b * (a * c) :=\n  left_comm has_mul.mul mul_comm mul_assoc\n#align mul_left_comm mul_left_comm\n-/\n\n",
 "mul_inv_eq_one":
 "#print mul_inv_eq_one /-\n@[to_additive]\ntheorem mul_inv_eq_one : a * b⁻¹ = 1 ↔ a = b := by rw [mul_eq_one_iff_eq_inv, inv_inv]\n#align mul_inv_eq_one mul_inv_eq_one\n-/\n\n",
 "mul_inv_eq_of_eq_mul":
 "#print mul_inv_eq_of_eq_mul /-\n@[to_additive]\ntheorem mul_inv_eq_of_eq_mul (h : a = c * b) : a * b⁻¹ = c := by simp [h]\n#align mul_inv_eq_of_eq_mul mul_inv_eq_of_eq_mul\n-/\n\n",
 "mul_inv_eq_iff_eq_mul":
 "#print mul_inv_eq_iff_eq_mul /-\n@[to_additive]\ntheorem mul_inv_eq_iff_eq_mul : a * b⁻¹ = c ↔ a = c * b :=\n  ⟨fun h => by rw [← h, inv_mul_cancel_right], fun h => by rw [h, mul_inv_cancel_right]⟩\n#align mul_inv_eq_iff_eq_mul mul_inv_eq_iff_eq_mul\n-/\n\n",
 "mul_inv":
 "#print mul_inv /-\n@[to_additive neg_add]\ntheorem mul_inv : (a * b)⁻¹ = a⁻¹ * b⁻¹ := by simp\n#align mul_inv mul_inv\n-/\n\n",
 "mul_eq_one_iff_inv_eq":
 "#print mul_eq_one_iff_inv_eq /-\n@[to_additive]\ntheorem mul_eq_one_iff_inv_eq : a * b = 1 ↔ a⁻¹ = b := by rw [mul_eq_one_iff_eq_inv, eq_inv_iff_eq_inv, eq_comm]\n#align mul_eq_one_iff_inv_eq mul_eq_one_iff_inv_eq\n-/\n\n",
 "mul_eq_one_iff_eq_inv":
 "#print mul_eq_one_iff_eq_inv /-\n@[to_additive]\ntheorem mul_eq_one_iff_eq_inv : a * b = 1 ↔ a = b⁻¹ :=\n  ⟨eq_inv_of_mul_eq_one_left, fun h => by rw [h, mul_left_inv]⟩\n#align mul_eq_one_iff_eq_inv mul_eq_one_iff_eq_inv\n-/\n\n",
 "mul_eq_of_eq_mul_inv":
 "#print mul_eq_of_eq_mul_inv /-\n@[to_additive]\ntheorem mul_eq_of_eq_mul_inv (h : a = c * b⁻¹) : a * b = c := by simp [h]\n#align mul_eq_of_eq_mul_inv mul_eq_of_eq_mul_inv\n-/\n\n",
 "mul_eq_of_eq_inv_mul":
 "#print mul_eq_of_eq_inv_mul /-\n@[to_additive]\ntheorem mul_eq_of_eq_inv_mul (h : b = a⁻¹ * c) : a * b = c := by rw [h, mul_inv_cancel_left]\n#align mul_eq_of_eq_inv_mul mul_eq_of_eq_inv_mul\n-/\n\n",
 "mul_eq_of_eq_div'":
 "#print mul_eq_of_eq_div' /-\n@[to_additive]\ntheorem mul_eq_of_eq_div' (h : b = c / a) : a * b = c := by simp [h]; rw [mul_comm c, mul_inv_cancel_left]\n#align mul_eq_of_eq_div' mul_eq_of_eq_div'\n-/\n\n",
 "mul_eq_of_eq_div":
 "#print mul_eq_of_eq_div /-\n@[to_additive]\ntheorem mul_eq_of_eq_div (h : a = c / b) : a * b = c := by simp [h]\n#align mul_eq_of_eq_div mul_eq_of_eq_div\n-/\n\n",
 "mul_div_right_comm":
 "#print mul_div_right_comm /-\n@[to_additive]\ntheorem mul_div_right_comm : a * b / c = a / c * b := by simp\n#align mul_div_right_comm mul_div_right_comm\n-/\n\n",
 "mul_div_mul_right_eq_div":
 "#print mul_div_mul_right_eq_div /-\n@[simp, to_additive]\ntheorem mul_div_mul_right_eq_div (a b c : G) : a * c / (b * c) = a / b := by\n  rw [div_mul_eq_div_div_swap] <;> simp only [mul_left_inj, eq_self_iff_true, mul_div_cancel'']\n#align mul_div_mul_right_eq_div mul_div_mul_right_eq_div\n-/\n\n",
 "mul_div_mul_left_eq_div":
 "#print mul_div_mul_left_eq_div /-\n@[simp, to_additive]\ntheorem mul_div_mul_left_eq_div (a b c : G) : c * a / (c * b) = a / b := by simp\n#align mul_div_mul_left_eq_div mul_div_mul_left_eq_div\n-/\n\n",
 "mul_div_mul_comm":
 "#print mul_div_mul_comm /-\n@[to_additive]\ntheorem mul_div_mul_comm : a * b / (c * d) = a / c * (b / d) := by simp\n#align mul_div_mul_comm mul_div_mul_comm\n-/\n\n",
 "mul_div_left_comm":
 "#print mul_div_left_comm /-\n@[to_additive]\ntheorem mul_div_left_comm : a * (b / c) = b * (a / c) := by simp\n#align mul_div_left_comm mul_div_left_comm\n-/\n\n",
 "mul_div_div_cancel":
 "#print mul_div_div_cancel /-\n@[simp, to_additive]\ntheorem mul_div_div_cancel (a b c : G) : a * b / (a / c) = b * c := by rw [← div_mul, mul_div_cancel''']\n#align mul_div_div_cancel mul_div_div_cancel\n-/\n\n",
 "mul_div_cancel'_right":
 "#print mul_div_cancel'_right /-\n@[simp, to_additive]\ntheorem mul_div_cancel'_right (a b : G) : a * (b / a) = b := by rw [← mul_div_assoc, mul_div_cancel''']\n#align mul_div_cancel'_right mul_div_cancel'_right\n-/\n\n",
 "mul_div_cancel'''":
 "#print mul_div_cancel''' /-\n@[simp, to_additive add_sub_cancel']\ntheorem mul_div_cancel''' (a b : G) : a * b / a = b := by rw [div_eq_inv_mul, inv_mul_cancel_left]\n#align mul_div_cancel''' mul_div_cancel'''\n-/\n\n",
 "mul_div_cancel''":
 "#print mul_div_cancel'' /-\n@[simp, to_additive add_sub_cancel]\ntheorem mul_div_cancel'' (a b : G) : a * b / b = a := by rw [div_eq_mul_inv, mul_inv_cancel_right a b]\n#align mul_div_cancel'' mul_div_cancel''\n-/\n\n",
 "mul_div_assoc'":
 "#print mul_div_assoc' /-\n-- The attributes are out of order on purpose\n@[to_additive, field_simps]\ntheorem mul_div_assoc' (a b c : G) : a * (b / c) = a * b / c :=\n  (mul_div_assoc _ _ _).symm\n#align mul_div_assoc' mul_div_assoc'\n-/\n\n",
 "mul_div_assoc":
 "#print mul_div_assoc /-\n@[to_additive]\ntheorem mul_div_assoc (a b c : G) : a * b / c = a * (b / c) := by rw [div_eq_mul_inv, div_eq_mul_inv, mul_assoc _ _ _]\n#align mul_div_assoc mul_div_assoc\n-/\n\n",
 "mul_div":
 "#print mul_div /-\n@[to_additive]\ntheorem mul_div (a b c : G) : a * (b / c) = a * b / c := by simp only [mul_assoc, div_eq_mul_inv]\n#align mul_div mul_div\n-/\n\n",
 "mul_comm_div":
 "#print mul_comm_div /-\n@[to_additive]\ntheorem mul_comm_div : a / b * c = a * (c / b) := by simp\n#align mul_comm_div mul_comm_div\n-/\n\n",
 "leftInverse_mul_right_inv_mul":
 "#print leftInverse_mul_right_inv_mul /-\n@[to_additive]\ntheorem leftInverse_mul_right_inv_mul (c : G) : function.left_inverse (fun x => c * x) fun x => c⁻¹ * x := fun x =>\n  mul_inv_cancel_left c x\n#align left_inverse_mul_right_inv_mul leftInverse_mul_right_inv_mul\n-/\n\n",
 "leftInverse_mul_left_div":
 "#print leftInverse_mul_left_div /-\n@[to_additive]\ntheorem leftInverse_mul_left_div (c : G) : function.left_inverse (fun x => x * c) fun x => x / c := fun x =>\n  div_mul_cancel' x c\n#align left_inverse_mul_left_div leftInverse_mul_left_div\n-/\n\n",
 "leftInverse_inv_mul_mul_right":
 "#print leftInverse_inv_mul_mul_right /-\n@[to_additive]\ntheorem leftInverse_inv_mul_mul_right (c : G) : function.left_inverse (fun x => c⁻¹ * x) fun x => c * x := fun x =>\n  inv_mul_cancel_left c x\n#align left_inverse_inv_mul_mul_right leftInverse_inv_mul_mul_right\n-/\n\n",
 "leftInverse_inv":
 "#print leftInverse_inv /-\n@[to_additive]\ntheorem leftInverse_inv : left_inverse (fun a : G => a⁻¹) fun a => a⁻¹ :=\n  inv_inv\n#align left_inverse_inv leftInverse_inv\n-/\n\n",
 "leftInverse_div_mul_left":
 "#print leftInverse_div_mul_left /-\n@[to_additive]\ntheorem leftInverse_div_mul_left (c : G) : function.left_inverse (fun x => x / c) fun x => x * c := fun x =>\n  mul_div_cancel'' x c\n#align left_inverse_div_mul_left leftInverse_div_mul_left\n-/\n\n",
 "ite_one_mul":
 "#print ite_one_mul /-\n@[to_additive]\ntheorem ite_one_mul {P : Prop} [decidable P] {a b : M} : ite P 1 (a * b) = ite P 1 a * ite P 1 b := by\n  by_cases h : P <;> simp [h]\n#align ite_one_mul ite_one_mul\n-/\n\n",
 "ite_mul_one":
 "#print ite_mul_one /-\n@[to_additive]\ntheorem ite_mul_one {P : Prop} [decidable P] {a b : M} : ite P (a * b) 1 = ite P a 1 * ite P b 1 := by\n  by_cases h : P <;> simp [h]\n#align ite_mul_one ite_mul_one\n-/\n\n",
 "inv_unique":
 "#print inv_unique /-\n@[to_additive]\ntheorem inv_unique (hy : x * y = 1) (hz : x * z = 1) : y = z :=\n  left_inv_eq_right_inv (trans (mul_comm _ _) hy) hz\n#align inv_unique inv_unique\n-/\n\n",
 "inv_surjective":
 "#print inv_surjective /-\n@[simp, to_additive]\ntheorem inv_surjective : function.surjective (has_inv.inv : G → G) :=\n  inv_involutive.surjective\n#align inv_surjective inv_surjective\n-/\n\n",
 "inv_ne_one":
 "#print inv_ne_one /-\n@[to_additive]\ntheorem inv_ne_one : a⁻¹ ≠ 1 ↔ a ≠ 1 :=\n  inv_eq_one.not\n#align inv_ne_one inv_ne_one\n-/\n\n",
 "inv_mul_eq_one":
 "#print inv_mul_eq_one /-\n@[to_additive]\ntheorem inv_mul_eq_one : a⁻¹ * b = 1 ↔ a = b := by rw [mul_eq_one_iff_eq_inv, inv_inj]\n#align inv_mul_eq_one inv_mul_eq_one\n-/\n\n",
 "inv_mul_eq_of_eq_mul":
 "#print inv_mul_eq_of_eq_mul /-\n@[to_additive]\ntheorem inv_mul_eq_of_eq_mul (h : b = a * c) : a⁻¹ * b = c := by simp [h]\n#align inv_mul_eq_of_eq_mul inv_mul_eq_of_eq_mul\n-/\n\n",
 "inv_mul_eq_iff_eq_mul":
 "#print inv_mul_eq_iff_eq_mul /-\n@[to_additive]\ntheorem inv_mul_eq_iff_eq_mul : a⁻¹ * b = c ↔ b = a * c :=\n  ⟨fun h => by rw [← h, mul_inv_cancel_left], fun h => by rw [h, inv_mul_cancel_left]⟩\n#align inv_mul_eq_iff_eq_mul inv_mul_eq_iff_eq_mul\n-/\n\n",
 "inv_mul_eq_div":
 "#print inv_mul_eq_div /-\n@[to_additive]\ntheorem inv_mul_eq_div : a⁻¹ * b = b / a := by simp\n#align inv_mul_eq_div inv_mul_eq_div\n-/\n\n",
 "inv_mul'":
 "#print inv_mul' /-\n@[to_additive]\ntheorem inv_mul' : (a * b)⁻¹ = a⁻¹ / b := by simp\n#align inv_mul' inv_mul'\n-/\n\n",
 "inv_involutive":
 "#print inv_involutive /-\n@[simp, to_additive]\ntheorem inv_involutive : function.involutive (has_inv.inv : G → G) :=\n  inv_inv\n#align inv_involutive inv_involutive\n-/\n\n",
 "inv_inv_div_inv":
 "#print inv_inv_div_inv /-\n@[to_additive]\ntheorem inv_inv_div_inv : (a⁻¹ / b⁻¹)⁻¹ = a / b := by simp\n#align inv_inv_div_inv inv_inv_div_inv\n-/\n\n",
 "inv_injective":
 "#print inv_injective /-\n@[to_additive]\ntheorem inv_injective : function.injective (has_inv.inv : G → G) :=\n  inv_involutive.injective\n#align inv_injective inv_injective\n-/\n\n",
 "inv_inj":
 "#print inv_inj /-\n@[simp, to_additive]\ntheorem inv_inj {a b : G} : a⁻¹ = b⁻¹ ↔ a = b :=\n  inv_injective.eq_iff\n#align inv_inj inv_inj\n-/\n\n",
 "inv_eq_one_div":
 "#print inv_eq_one_div /-\n-- The attributes are out of order on purpose\n@[to_additive, field_simps]\ntheorem inv_eq_one_div (x : G) : x⁻¹ = 1 / x := by rw [div_eq_mul_inv, one_mul]\n#align inv_eq_one_div inv_eq_one_div\n-/\n\n",
 "inv_eq_one":
 "#print inv_eq_one /-\n@[simp, to_additive]\ntheorem inv_eq_one : a⁻¹ = 1 ↔ a = 1 :=\n  inv_injective.eq_iff' inv_one\n#align inv_eq_one inv_eq_one\n-/\n\n",
 "inv_eq_of_mul_eq_one_left":
 "#print inv_eq_of_mul_eq_one_left /-\n@[to_additive]\ntheorem inv_eq_of_mul_eq_one_left (h : a * b = 1) : b⁻¹ = a := by rw [← inv_eq_of_mul_eq_one_right h, inv_inv]\n#align inv_eq_of_mul_eq_one_left inv_eq_of_mul_eq_one_left\n-/\n\n",
 "inv_eq_iff_mul_eq_one":
 "#print inv_eq_iff_mul_eq_one /-\n@[to_additive]\ntheorem inv_eq_iff_mul_eq_one : a⁻¹ = b ↔ a * b = 1 :=\n  mul_eq_one_iff_inv_eq.symm\n#align inv_eq_iff_mul_eq_one inv_eq_iff_mul_eq_one\n-/\n\n",
 "inv_eq_iff_inv_eq":
 "#print inv_eq_iff_inv_eq /-\n@[to_additive]\ntheorem inv_eq_iff_inv_eq : a⁻¹ = b ↔ b⁻¹ = a :=\n  eq_comm.trans <| eq_inv_iff_eq_inv.trans eq_comm\n#align inv_eq_iff_inv_eq inv_eq_iff_inv_eq\n-/\n\n",
 "inv_div_left":
 "#print inv_div_left /-\n@[to_additive]\ntheorem inv_div_left : a⁻¹ / b = (b * a)⁻¹ := by simp\n#align inv_div_left inv_div_left\n-/\n\n",
 "inv_div_inv":
 "#print inv_div_inv /-\n@[simp, to_additive]\ntheorem inv_div_inv : a⁻¹ / b⁻¹ = b / a := by simp\n#align inv_div_inv inv_div_inv\n-/\n\n",
 "inv_div'":
 "#print inv_div' /-\n@[to_additive]\ntheorem inv_div' : (a / b)⁻¹ = a⁻¹ / b⁻¹ := by simp\n#align inv_div' inv_div'\n-/\n\n",
 "inv_div":
 "#print inv_div /-\n@[simp, to_additive]\ntheorem inv_div : (a / b)⁻¹ = b / a := by simp\n#align inv_div inv_div\n-/\n\n",
 "inv_comp_inv":
 "#print inv_comp_inv /-\n@[simp, to_additive]\ntheorem inv_comp_inv : has_inv.inv ∘ has_inv.inv = @id G :=\n  inv_involutive.comp_self\n#align inv_comp_inv inv_comp_inv\n-/\n\n",
 "exists_npow_eq_one_of_zpow_eq_one":
 "#print exists_npow_eq_one_of_zpow_eq_one /-\n@[to_additive]\ntheorem exists_npow_eq_one_of_zpow_eq_one {n : ℤ} (hn : n ≠ 0) {x : G} (h : x ^ n = 1) : ∃ n : ℕ, 0 < n ∧ x ^ n = 1 :=\n  by\n  cases' n with n n\n  · rw [zpow_ofNat] at h\n    refine' ⟨n, nat.pos_of_ne_zero fun n0 => hn _, h⟩\n    rw [n0]\n    rfl\n  · rw [zpow_negSucc, inv_eq_one] at h\n    refine' ⟨n + 1, n.succ_pos, h⟩\n#align exists_npow_eq_one_of_zpow_eq_one exists_npow_eq_one_of_zpow_eq_one\n-/\n\n",
 "eq_one_iff_eq_one_of_mul_eq_one":
 "#print eq_one_iff_eq_one_of_mul_eq_one /-\n@[to_additive]\ntheorem eq_one_iff_eq_one_of_mul_eq_one {a b : M} (h : a * b = 1) : a = 1 ↔ b = 1 := by\n  constructor <;>\n    · rintro rfl\n      simpa using h\n#align eq_one_iff_eq_one_of_mul_eq_one eq_one_iff_eq_one_of_mul_eq_one\n-/\n\n",
 "eq_one_div_of_mul_eq_one_right":
 "#print eq_one_div_of_mul_eq_one_right /-\n@[to_additive]\ntheorem eq_one_div_of_mul_eq_one_right (h : a * b = 1) : b = 1 / a := by rw [eq_inv_of_mul_eq_one_right h, one_div]\n#align eq_one_div_of_mul_eq_one_right eq_one_div_of_mul_eq_one_right\n-/\n\n",
 "eq_one_div_of_mul_eq_one_left":
 "#print eq_one_div_of_mul_eq_one_left /-\n@[to_additive]\ntheorem eq_one_div_of_mul_eq_one_left (h : b * a = 1) : b = 1 / a := by rw [eq_inv_of_mul_eq_one_left h, one_div]\n#align eq_one_div_of_mul_eq_one_left eq_one_div_of_mul_eq_one_left\n-/\n\n",
 "eq_of_one_div_eq_one_div":
 "#print eq_of_one_div_eq_one_div /-\n@[to_additive]\ntheorem eq_of_one_div_eq_one_div (h : 1 / a = 1 / b) : a = b := by rw [← one_div_one_div a, h, one_div_one_div]\n#align eq_of_one_div_eq_one_div eq_of_one_div_eq_one_div\n-/\n\n",
 "eq_of_div_eq_one":
 "#print eq_of_div_eq_one /-\n@[to_additive]\ntheorem eq_of_div_eq_one (h : a / b = 1) : a = b :=\n  inv_injective <| inv_eq_of_mul_eq_one_right <| by rwa [← div_eq_mul_inv]\n#align eq_of_div_eq_one eq_of_div_eq_one\n-/\n\n",
 "eq_mul_of_mul_inv_eq":
 "#print eq_mul_of_mul_inv_eq /-\n@[to_additive]\ntheorem eq_mul_of_mul_inv_eq (h : a * c⁻¹ = b) : a = b * c := by simp [h.symm]\n#align eq_mul_of_mul_inv_eq eq_mul_of_mul_inv_eq\n-/\n\n",
 "eq_mul_of_inv_mul_eq":
 "#print eq_mul_of_inv_mul_eq /-\n@[to_additive]\ntheorem eq_mul_of_inv_mul_eq (h : b⁻¹ * a = c) : a = b * c := by simp [h.symm, mul_inv_cancel_left]\n#align eq_mul_of_inv_mul_eq eq_mul_of_inv_mul_eq\n-/\n\n",
 "eq_mul_of_div_eq'":
 "#print eq_mul_of_div_eq' /-\n@[to_additive]\ntheorem eq_mul_of_div_eq' (h : a / b = c) : a = b * c := by simp [h.symm]\n#align eq_mul_of_div_eq' eq_mul_of_div_eq'\n-/\n\n",
 "eq_mul_of_div_eq":
 "#print eq_mul_of_div_eq /-\n@[to_additive]\ntheorem eq_mul_of_div_eq (h : a / c = b) : a = b * c := by simp [← h]\n#align eq_mul_of_div_eq eq_mul_of_div_eq\n-/\n\n",
 "eq_mul_inv_of_mul_eq":
 "#print eq_mul_inv_of_mul_eq /-\n@[to_additive]\ntheorem eq_mul_inv_of_mul_eq (h : a * c = b) : a = b * c⁻¹ := by simp [h.symm]\n#align eq_mul_inv_of_mul_eq eq_mul_inv_of_mul_eq\n-/\n\n",
 "eq_mul_inv_iff_mul_eq":
 "#print eq_mul_inv_iff_mul_eq /-\n@[to_additive]\ntheorem eq_mul_inv_iff_mul_eq : a = b * c⁻¹ ↔ a * c = b :=\n  ⟨fun h => by rw [h, inv_mul_cancel_right], fun h => by rw [← h, mul_inv_cancel_right]⟩\n#align eq_mul_inv_iff_mul_eq eq_mul_inv_iff_mul_eq\n-/\n\n",
 "eq_inv_of_mul_eq_one_right":
 "#print eq_inv_of_mul_eq_one_right /-\n@[to_additive]\ntheorem eq_inv_of_mul_eq_one_right (h : a * b = 1) : b = a⁻¹ :=\n  (inv_eq_of_mul_eq_one_right h).symm\n#align eq_inv_of_mul_eq_one_right eq_inv_of_mul_eq_one_right\n-/\n\n",
 "eq_inv_of_mul_eq_one_left":
 "#print eq_inv_of_mul_eq_one_left /-\n@[to_additive]\ntheorem eq_inv_of_mul_eq_one_left (h : a * b = 1) : a = b⁻¹ :=\n  (inv_eq_of_mul_eq_one_left h).symm\n#align eq_inv_of_mul_eq_one_left eq_inv_of_mul_eq_one_left\n-/\n\n",
 "eq_inv_of_eq_inv":
 "#print eq_inv_of_eq_inv /-\n@[to_additive]\ntheorem eq_inv_of_eq_inv (h : a = b⁻¹) : b = a⁻¹ := by simp [h]\n#align eq_inv_of_eq_inv eq_inv_of_eq_inv\n-/\n\n",
 "eq_inv_mul_of_mul_eq":
 "#print eq_inv_mul_of_mul_eq /-\n@[to_additive]\ntheorem eq_inv_mul_of_mul_eq (h : b * a = c) : a = b⁻¹ * c := by simp [h.symm]\n#align eq_inv_mul_of_mul_eq eq_inv_mul_of_mul_eq\n-/\n\n",
 "eq_inv_mul_iff_mul_eq":
 "#print eq_inv_mul_iff_mul_eq /-\n@[to_additive]\ntheorem eq_inv_mul_iff_mul_eq : a = b⁻¹ * c ↔ b * a = c :=\n  ⟨fun h => by rw [h, mul_inv_cancel_left], fun h => by rw [← h, inv_mul_cancel_left]⟩\n#align eq_inv_mul_iff_mul_eq eq_inv_mul_iff_mul_eq\n-/\n\n",
 "eq_inv_iff_mul_eq_one":
 "#print eq_inv_iff_mul_eq_one /-\n@[to_additive]\ntheorem eq_inv_iff_mul_eq_one : a = b⁻¹ ↔ a * b = 1 :=\n  mul_eq_one_iff_eq_inv.symm\n#align eq_inv_iff_mul_eq_one eq_inv_iff_mul_eq_one\n-/\n\n",
 "eq_inv_iff_eq_inv":
 "#print eq_inv_iff_eq_inv /-\n@[to_additive]\ntheorem eq_inv_iff_eq_inv : a = b⁻¹ ↔ b = a⁻¹ :=\n  ⟨eq_inv_of_eq_inv, eq_inv_of_eq_inv⟩\n#align eq_inv_iff_eq_inv eq_inv_iff_eq_inv\n-/\n\n",
 "eq_iff_eq_of_div_eq_div":
 "#print eq_iff_eq_of_div_eq_div /-\n@[to_additive]\ntheorem eq_iff_eq_of_div_eq_div (H : a / b = c / d) : a = b ↔ c = d := by rw [← div_eq_one, H, div_eq_one]\n#align eq_iff_eq_of_div_eq_div eq_iff_eq_of_div_eq_div\n-/\n\n",
 "eq_div_of_mul_eq''":
 "#print eq_div_of_mul_eq'' /-\n@[to_additive eq_sub_of_add_eq']\ntheorem eq_div_of_mul_eq'' (h : c * a = b) : a = b / c := by simp [h.symm]\n#align eq_div_of_mul_eq'' eq_div_of_mul_eq''\n-/\n\n",
 "eq_div_of_mul_eq'":
 "#print eq_div_of_mul_eq' /-\n@[to_additive eq_sub_of_add_eq]\ntheorem eq_div_of_mul_eq' (h : a * c = b) : a = b / c := by simp [← h]\n#align eq_div_of_mul_eq' eq_div_of_mul_eq'\n-/\n\n",
 "eq_div_iff_mul_eq''":
 "#print eq_div_iff_mul_eq'' /-\n@[to_additive eq_sub_iff_add_eq']\ntheorem eq_div_iff_mul_eq'' : a = b / c ↔ c * a = b := by rw [eq_div_iff_mul_eq', mul_comm]\n#align eq_div_iff_mul_eq'' eq_div_iff_mul_eq''\n-/\n\n",
 "eq_div_iff_mul_eq'":
 "#print eq_div_iff_mul_eq' /-\n@[to_additive eq_sub_iff_add_eq]\ntheorem eq_div_iff_mul_eq' : a = b / c ↔ a * c = b := by rw [div_eq_mul_inv, eq_mul_inv_iff_mul_eq]\n#align eq_div_iff_mul_eq' eq_div_iff_mul_eq'\n-/\n\n",
 "div_self'":
 "#print div_self' /-\n@[simp, to_additive sub_self]\ntheorem div_self' (a : G) : a / a = 1 := by rw [div_eq_mul_inv, mul_right_inv a]\n#align div_self' div_self'\n-/\n\n",
 "div_right_injective":
 "#print div_right_injective /-\n@[to_additive]\ntheorem div_right_injective : function.injective fun a => b / a := by\n  simpa only [div_eq_mul_inv] using fun a a' h => inv_injective (mul_right_injective b h)\n#align div_right_injective div_right_injective\n-/\n\n",
 "div_right_inj":
 "#print div_right_inj /-\n@[simp, to_additive]\ntheorem div_right_inj : a / b = a / c ↔ b = c :=\n  div_right_injective.eq_iff\n#align div_right_inj div_right_inj\n-/\n\n",
 "div_right_comm":
 "#print div_right_comm /-\n@[to_additive]\ntheorem div_right_comm : a / b / c = a / c / b := by simp\n#align div_right_comm div_right_comm\n-/\n\n",
 "div_one":
 "#print div_one /-\n@[simp, to_additive]\ntheorem div_one (a : G) : a / 1 = a := by simp [div_eq_mul_inv]\n#align div_one div_one\n-/\n\n",
 "div_ne_one_of_ne":
 "#print div_ne_one_of_ne /-\n@[to_additive]\ntheorem div_ne_one_of_ne : a ≠ b → a / b ≠ 1 :=\n  mt eq_of_div_eq_one\n#align div_ne_one_of_ne div_ne_one_of_ne\n-/\n\n",
 "div_ne_one":
 "#print div_ne_one /-\n@[to_additive]\ntheorem div_ne_one : a / b ≠ 1 ↔ a ≠ b :=\n  not_congr div_eq_one\n#align div_ne_one div_ne_one\n-/\n\n",
 "div_mul_mul_cancel":
 "#print div_mul_mul_cancel /-\n@[simp, to_additive]\ntheorem div_mul_mul_cancel (a b c : G) : a / c * (b * c) = a * b := by rw [mul_left_comm, div_mul_cancel', mul_comm]\n#align div_mul_mul_cancel div_mul_mul_cancel\n-/\n\n",
 "div_mul_eq_mul_div":
 "#print div_mul_eq_mul_div /-\n@[to_additive, field_simps]\ntheorem div_mul_eq_mul_div : a / b * c = a * c / b := by simp\n#align div_mul_eq_mul_div div_mul_eq_mul_div\n-/\n\n",
 "div_mul_eq_div_mul_one_div":
 "#print div_mul_eq_div_mul_one_div /-\n@[to_additive]\ntheorem div_mul_eq_div_mul_one_div : a / (b * c) = a / b * (1 / c) := by simp\n#align div_mul_eq_div_mul_one_div div_mul_eq_div_mul_one_div\n-/\n\n",
 "div_mul_eq_div_div_swap":
 "#print div_mul_eq_div_div_swap /-\n@[to_additive]\ntheorem div_mul_eq_div_div_swap : a / (b * c) = a / c / b := by simp only [mul_assoc, mul_inv_rev, div_eq_mul_inv]\n#align div_mul_eq_div_div_swap div_mul_eq_div_div_swap\n-/\n\n",
 "div_mul_eq_div_div":
 "#print div_mul_eq_div_div /-\n@[to_additive]\ntheorem div_mul_eq_div_div : a / (b * c) = a / b / c := by simp\n#align div_mul_eq_div_div div_mul_eq_div_div\n-/\n\n",
 "div_mul_div_comm":
 "#print div_mul_div_comm /-\n@[to_additive]\ntheorem div_mul_div_comm : a / b * (c / d) = a * c / (b * d) := by simp\n#align div_mul_div_comm div_mul_div_comm\n-/\n\n",
 "div_mul_div_cancel''":
 "#print div_mul_div_cancel'' /-\n@[simp, to_additive sub_add_sub_cancel']\ntheorem div_mul_div_cancel'' (a b c : G) : a / b * (c / a) = c / b := by rw [mul_comm] <;> apply div_mul_div_cancel'\n#align div_mul_div_cancel'' div_mul_div_cancel''\n-/\n\n",
 "div_mul_div_cancel'":
 "#print div_mul_div_cancel' /-\n@[simp, to_additive sub_add_sub_cancel]\ntheorem div_mul_div_cancel' (a b c : G) : a / b * (b / c) = a / c := by rw [← mul_div_assoc, div_mul_cancel']\n#align div_mul_div_cancel' div_mul_div_cancel'\n-/\n\n",
 "div_mul_comm":
 "#print div_mul_comm /-\n@[to_additive]\ntheorem div_mul_comm : a / b * c = c / b * a := by simp\n#align div_mul_comm div_mul_comm\n-/\n\n",
 "div_mul_cancel''":
 "#print div_mul_cancel'' /-\n@[simp, to_additive sub_add_cancel']\ntheorem div_mul_cancel'' (a b : G) : a / (a * b) = b⁻¹ := by rw [← inv_div, mul_div_cancel''']\n#align div_mul_cancel'' div_mul_cancel''\n-/\n\n",
 "div_mul_cancel'":
 "#print div_mul_cancel' /-\n@[simp, to_additive sub_add_cancel]\ntheorem div_mul_cancel' (a b : G) : a / b * b = a := by rw [div_eq_mul_inv, inv_mul_cancel_right a b]\n#align div_mul_cancel' div_mul_cancel'\n-/\n\n",
 "div_mul":
 "#print div_mul /-\n@[to_additive]\ntheorem div_mul : a / b * c = a / (b / c) := by simp\n#align div_mul div_mul\n-/\n\n",
 "div_left_injective":
 "#print div_left_injective /-\n@[to_additive]\ntheorem div_left_injective : function.injective fun a => a / b := by\n  simpa only [div_eq_mul_inv] using fun a a' h => mul_left_injective b⁻¹ h\n#align div_left_injective div_left_injective\n-/\n\n",
 "div_left_inj":
 "#print div_left_inj /-\n@[simp, to_additive]\ntheorem div_left_inj : b / a = c / a ↔ b = c :=\n  by\n  rw [div_eq_mul_inv, div_eq_mul_inv]\n  exact mul_left_inj _\n#align div_left_inj div_left_inj\n-/\n\n",
 "div_inv_eq_mul":
 "#print div_inv_eq_mul /-\n@[simp, to_additive]\ntheorem div_inv_eq_mul : a / b⁻¹ = a * b := by simp\n#align div_inv_eq_mul div_inv_eq_mul\n-/\n\n",
 "div_eq_self":
 "#print div_eq_self /-\n@[simp, to_additive]\ntheorem div_eq_self : a / b = a ↔ b = 1 := by rw [div_eq_mul_inv, mul_right_eq_self, inv_eq_one]\n#align div_eq_self div_eq_self\n-/\n\n",
 "div_eq_one":
 "#print div_eq_one /-\n@[to_additive]\ntheorem div_eq_one : a / b = 1 ↔ a = b :=\n  ⟨eq_of_div_eq_one, fun h => by rw [h, div_self']⟩\n#align div_eq_one div_eq_one\n-/\n\n",
 "div_eq_of_eq_mul''":
 "#print div_eq_of_eq_mul'' /-\n@[to_additive sub_eq_of_eq_add]\ntheorem div_eq_of_eq_mul'' (h : a = c * b) : a / b = c := by simp [h]\n#align div_eq_of_eq_mul'' div_eq_of_eq_mul''\n-/\n\n",
 "div_eq_of_eq_mul'":
 "#print div_eq_of_eq_mul' /-\n@[to_additive]\ntheorem div_eq_of_eq_mul' {a b c : G} (h : a = b * c) : a / b = c := by\n  rw [h, div_eq_mul_inv, mul_comm, inv_mul_cancel_left]\n#align div_eq_of_eq_mul' div_eq_of_eq_mul'\n-/\n\n",
 "div_eq_mul_one_div":
 "#print div_eq_mul_one_div /-\n@[to_additive]\ntheorem div_eq_mul_one_div (a b : G) : a / b = a * (1 / b) := by rw [div_eq_mul_inv, one_div]\n#align div_eq_mul_one_div div_eq_mul_one_div\n-/\n\n",
 "div_eq_inv_self":
 "#print div_eq_inv_self /-\n@[simp, to_additive]\ntheorem div_eq_inv_self : a / b = b⁻¹ ↔ a = 1 := by rw [div_eq_mul_inv, mul_left_eq_self]\n#align div_eq_inv_self div_eq_inv_self\n-/\n\n",
 "div_eq_inv_mul":
 "#print div_eq_inv_mul /-\n@[to_additive]\ntheorem div_eq_inv_mul : a / b = b⁻¹ * a := by simp\n#align div_eq_inv_mul div_eq_inv_mul\n-/\n\n",
 "div_eq_iff_eq_mul'":
 "#print div_eq_iff_eq_mul' /-\n@[to_additive]\ntheorem div_eq_iff_eq_mul' : a / b = c ↔ a = b * c := by rw [div_eq_iff_eq_mul, mul_comm]\n#align div_eq_iff_eq_mul' div_eq_iff_eq_mul'\n-/\n\n",
 "div_eq_iff_eq_mul":
 "#print div_eq_iff_eq_mul /-\n@[to_additive]\ntheorem div_eq_iff_eq_mul : a / b = c ↔ a = c * b := by rw [div_eq_mul_inv, mul_inv_eq_iff_eq_mul]\n#align div_eq_iff_eq_mul div_eq_iff_eq_mul\n-/\n\n",
 "div_eq_div_mul_div":
 "#print div_eq_div_mul_div /-\n@[to_additive]\ntheorem div_eq_div_mul_div (a b c : G) : a / b = c / b * (a / c) := by simp [mul_left_comm c]\n#align div_eq_div_mul_div div_eq_div_mul_div\n-/\n\n",
 "div_eq_div_iff_mul_eq_mul":
 "#print div_eq_div_iff_mul_eq_mul /-\n@[to_additive]\ntheorem div_eq_div_iff_mul_eq_mul : a / b = c / d ↔ a * d = c * b :=\n  by\n  rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, eq_comm, div_eq_iff_eq_mul']\n  simp only [mul_comm, eq_comm]\n#align div_eq_div_iff_mul_eq_mul div_eq_div_iff_mul_eq_mul\n-/\n\n",
 "div_eq_div_iff_div_eq_div":
 "#print div_eq_div_iff_div_eq_div /-\n@[to_additive]\ntheorem div_eq_div_iff_div_eq_div : a / b = c / d ↔ a / c = b / d := by\n  rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, div_eq_iff_eq_mul', mul_div_assoc]\n#align div_eq_div_iff_div_eq_div div_eq_div_iff_div_eq_div\n-/\n\n",
 "div_div_self'":
 "#print div_div_self' /-\n@[to_additive sub_sub_self]\ntheorem div_div_self' (a b : G) : a / (a / b) = b := by simpa using mul_inv_cancel_left a b\n#align div_div_self' div_div_self'\n-/\n\n",
 "div_div_eq_mul_div":
 "#print div_div_eq_mul_div /-\n-- The attributes are out of order on purpose\n@[to_additive, field_simps]\ntheorem div_div_eq_mul_div : a / (b / c) = a * c / b := by simp\n#align div_div_eq_mul_div div_div_eq_mul_div\n-/\n\n",
 "div_div_div_eq":
 "#print div_div_div_eq /-\n@[to_additive]\ntheorem div_div_div_eq : a / b / (c / d) = a * d / (b * c) := by simp\n#align div_div_div_eq div_div_div_eq\n-/\n\n",
 "div_div_div_comm":
 "#print div_div_div_comm /-\n@[to_additive]\ntheorem div_div_div_comm : a / b / (c / d) = a / c / (b / d) := by simp\n#align div_div_div_comm div_div_div_comm\n-/\n\n",
 "div_div_div_cancel_right'":
 "#print div_div_div_cancel_right' /-\n@[simp, to_additive sub_sub_sub_cancel_right]\ntheorem div_div_div_cancel_right' (a b c : G) : a / c / (b / c) = a / b := by\n  rw [← inv_div c b, div_inv_eq_mul, div_mul_div_cancel']\n#align div_div_div_cancel_right' div_div_div_cancel_right'\n-/\n\n",
 "div_div_div_cancel_left":
 "#print div_div_div_cancel_left /-\n@[simp, to_additive]\ntheorem div_div_div_cancel_left (a b c : G) : c / a / (c / b) = b / a := by\n  rw [← inv_div b c, div_inv_eq_mul, mul_comm, div_mul_div_cancel']\n#align div_div_div_cancel_left div_div_div_cancel_left\n-/\n\n",
 "div_div_cancel_left":
 "#print div_div_cancel_left /-\n@[simp, to_additive]\ntheorem div_div_cancel_left (a b : G) : a / b / a = b⁻¹ := by simp\n#align div_div_cancel_left div_div_cancel_left\n-/\n\n",
 "div_div_cancel":
 "#print div_div_cancel /-\n@[simp, to_additive]\ntheorem div_div_cancel (a b : G) : a / (a / b) = b :=\n  div_div_self' a b\n#align div_div_cancel div_div_cancel\n-/\n\n",
 "div_div":
 "#print div_div /-\n@[to_additive, field_simps]\ntheorem div_div : a / b / c = a / (b * c) := by simp\n#align div_div div_div\n-/\n\n",
 "comp_mul_right":
 "#print comp_mul_right /-\n/-- Composing two multiplications on the right by `y` and `x`\nis equal to a multiplication on the right by `y * x`.\n-/\n@[simp,\n  to_additive \"Composing two additions on the right by `y` and `x`\\nis equal to a addition on the right by `y + x`.\"]\ntheorem comp_mul_right [semigroup α] (x y : α) : (· * x) ∘ (· * y) = (· * (y * x)) :=\n  comp_assoc_right _ _ _\n#align comp_mul_right comp_mul_right\n-/\n\n",
 "comp_mul_left":
 "#print comp_mul_left /-\n/-- Composing two multiplications on the left by `y` then `x`\nis equal to a multiplication on the left by `x * y`.\n-/\n@[simp,\n  to_additive \"Composing two additions on the left by `y` then `x`\\nis equal to a addition on the left by `x + y`.\"]\ntheorem comp_mul_left [semigroup α] (x y : α) : (· * ·) x ∘ (· * ·) y = (· * ·) (x * y) :=\n  comp_assoc_left _ _ _\n#align comp_mul_left comp_mul_left\n-/\n\n",
 "comp_assoc_right":
 "/-- Composing two associative operations of `f : α → α → α` on the right\nis equal to an associative operation on the right.\n-/\ntheorem comp_assoc_right : ((fun z => f z x) ∘ fun z => f z y) = fun z => f z (f y x) :=\n  by\n  ext z\n  rw [function.comp_apply, @is_associative.assoc _ f]\n#align comp_assoc_right comp_assoc_right\n\n",
 "comp_assoc_left":
 "/-\nCopyright (c) 2014 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Leonardo de Moura, Simon Hudon, Mario Carneiro\n-/\n/-- Composing two associative operations of `f : α → α → α` on the left\nis equal to an associative operation on the left.\n-/\ntheorem comp_assoc_left : f x ∘ f y = f (f x y) := by\n  ext z\n  rw [function.comp_apply, @is_associative.assoc _ f]\n#align comp_assoc_left comp_assoc_left\n\n",
 "bit1_zero":
 "#print bit1_zero /-\n@[simp]\ntheorem bit1_zero [One M] : bit1 (0 : M) = 1 := by rw [bit1, bit0_zero, zero_add]\n#align bit1_zero bit1_zero\n-/\n\n",
 "bit1_sub":
 "theorem bit1_sub [One M] (a b : M) : bit1 (a - b) = bit1 a - bit0 b :=\n  (congr_arg (· + (1 : M)) <| bit0_sub a b : _).trans <| sub_add_eq_add_sub _ _ _\n#align bit1_sub bit1_sub\n\n",
 "bit1_add'":
 "#print bit1_add' /-\ntheorem bit1_add' [One M] (a b : M) : bit1 (a + b) = bit1 a + bit0 b := by rw [add_comm, bit1_add, add_comm]\n#align bit1_add' bit1_add'\n-/\n\n",
 "bit1_add":
 "#print bit1_add /-\ntheorem bit1_add [One M] (a b : M) : bit1 (a + b) = bit0 a + bit1 b :=\n  (congr_arg (· + (1 : M)) <| bit0_add a b : _).trans (add_assoc _ _ _)\n#align bit1_add bit1_add\n-/\n\n",
 "bit0_zero":
 "#print bit0_zero /-\n@[simp]\ntheorem bit0_zero : bit0 (0 : M) = 0 :=\n  add_zero _\n#align bit0_zero bit0_zero\n-/\n\n",
 "bit0_sub":
 "theorem bit0_sub (a b : M) : bit0 (a - b) = bit0 a - bit0 b :=\n  sub_add_sub_comm _ _ _ _\n#align bit0_sub bit0_sub\n\n",
 "bit0_neg":
 "#print bit0_neg /-\ntheorem bit0_neg [subtraction_monoid α] (a : α) : bit0 (-a) = -bit0 a :=\n  (neg_add_rev _ _).symm\n#align bit0_neg bit0_neg\n-/\n\n",
 "bit0_add":
 "#print bit0_add /-\ntheorem bit0_add (a b : M) : bit0 (a + b) = bit0 a + bit0 b :=\n  add_add_add_comm _ _ _ _\n#align bit0_add bit0_add\n-/\n\n"}