{"update_one":
 "@[simp, to_additive]\ntheorem update_one [∀ i, One (f i)] [DecidableEq I] (i : I) : update (1 : ∀ i, f i) i 1 = 1 :=\n  update_eq_self i 1\n#align update_one update_one\n\n",
 "update_mul":
 "@[to_additive]\ntheorem update_mul [∀ i, Mul (f i)] [DecidableEq I] (f₁ f₂ : ∀ i, f i) (i : I) (x₁ : f i) (x₂ : f i) :\n    update (f₁ * f₂) i (x₁ * x₂) = update f₁ i x₁ * update f₂ i x₂ :=\n  funext fun j => (apply_update₂ (fun i => (· * ·)) f₁ f₂ i x₁ x₂ j).symm\n#align update_mul update_mul\n\n",
 "update_inv":
 "@[to_additive]\ntheorem update_inv [∀ i, Inv (f i)] [DecidableEq I] (f₁ : ∀ i, f i) (i : I) (x₁ : f i) :\n    update f₁⁻¹ i x₁⁻¹ = (update f₁ i x₁)⁻¹ :=\n  funext fun j => (apply_update (fun i => has_inv.inv) f₁ i x₁ j).symm\n#align update_inv update_inv\n\n",
 "update_eq_div_mul_mulSingle":
 "#print Pi.update_eq_div_mul_mulSingle /-\n@[to_additive update_eq_sub_add_single]\ntheorem Pi.update_eq_div_mul_mulSingle [∀ i, Group <| f i] (g : ∀ i : I, f i) (x : f i) :\n    Function.update g i x = g / mulSingle i (g i) * mulSingle i x :=\n  by\n  ext j\n  rcases eq_or_ne i j with (rfl | h)\n  · simp\n  · simp [Function.update_noteq h.symm, h]\n#align pi.update_eq_div_mul_single Pi.update_eq_div_mul_mulSingle\n-/\n\n",
 "update_div":
 "@[to_additive]\ntheorem update_div [∀ i, Div (f i)] [DecidableEq I] (f₁ f₂ : ∀ i, f i) (i : I) (x₁ : f i) (x₂ : f i) :\n    update (f₁ / f₂) i (x₁ / x₂) = update f₁ i x₁ / update f₂ i x₂ :=\n  funext fun j => (apply_update₂ (fun i => (· / ·)) f₁ f₂ i x₁ x₂ j).symm\n#align update_div update_div\n\n",
 "single_mul_right_apply":
 "#print Pi.single_mul_right_apply /-\ntheorem Pi.single_mul_right_apply [∀ i, MulZeroClass <| f i] (a : f i) :\n    Pi.single i (x i * a) j = x j * Pi.single i a j :=\n  (Pi.apply_single (fun i => (· * ·) (x i)) (fun i => MulZeroClass.mul_zero _) _ _ _).symm\n#align pi.single_mul_right_apply Pi.single_mul_right_apply\n-/\n\n",
 "single_mul_right":
 "#print Pi.single_mul_right /-\ntheorem Pi.single_mul_right [∀ i, MulZeroClass <| f i] (a : f i) : Pi.single i (x i * a) = x * Pi.single i a :=\n  funext fun j => Pi.single_mul_right_apply _ _ _ _\n#align pi.single_mul_right Pi.single_mul_right\n-/\n\n",
 "single_mul_left_apply":
 "#print Pi.single_mul_left_apply /-\ntheorem Pi.single_mul_left_apply [∀ i, MulZeroClass <| f i] (a : f i) :\n    Pi.single i (a * x i) j = Pi.single i a j * x j :=\n  (Pi.apply_single (fun i => (· * x i)) (fun i => MulZeroClass.zero_mul _) _ _ _).symm\n#align pi.single_mul_left_apply Pi.single_mul_left_apply\n-/\n\n",
 "single_mul_left":
 "#print Pi.single_mul_left /-\ntheorem Pi.single_mul_left [∀ i, MulZeroClass <| f i] (a : f i) : Pi.single i (a * x i) = Pi.single i a * x :=\n  funext fun j => Pi.single_mul_left_apply _ _ _ _\n#align pi.single_mul_left Pi.single_mul_left\n-/\n\n",
 "single_mul":
 "#print Pi.single_mul /-\ntheorem Pi.single_mul [∀ i, MulZeroClass <| f i] (i : I) (x y : f i) : single i (x * y) = single i x * single i y :=\n  (MulHom.single f i).map_mul x y\n#align pi.single_mul Pi.single_mul\n-/\n\n",
 "single_div":
 "#print Pi.single_div /-\n@[to_additive]\ntheorem Pi.single_div [∀ i, Group <| f i] (i : I) (x y : f i) : mulSingle i (x / y) = mulSingle i x / mulSingle i y :=\n  (MonoidHom.single f i).map_div x y\n#align pi.single_div Pi.single_div\n#align pi.single_sub Pi.single_sub\n-/\n\n",
 "single_apply":
 "#print MonoidHom.single_apply /-\n@[simp, to_additive]\ntheorem MonoidHom.single_apply [∀ i, MulOneClass <| f i] (i : I) (x : f i) : MonoidHom.single f i x = mulSingle i x :=\n  rfl\n#align monoid_hom.single_apply MonoidHom.single_apply\n#align add_monoid_hom.single_apply AddMonoidHom.single_apply\n-/\n\n",
 "preimage_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print Set.preimage_one /-\n/-\nCopyright (c) 2018 Simon Hudon. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Simon Hudon, Patrick Massot\n-/\n-- The indexing type\n-- The family of types already equipped with instances\n@[to_additive]\ntheorem Set.preimage_one {α β : Type _} [One β] (s : Set β) [Decidable ((1 : β) ∈ s)] :\n    «expr ⁻¹' » (1 : α → β) s = if (1 : β) ∈ s then Set.univ else ∅ :=\n  Set.preimage_const 1 s\n#align set.preimage_one Set.preimage_one\n#align set.preimage_zero Set.preimage_zero\n-/\n\n",
 "piecewise_mul":
 "#print Set.piecewise_mul /-\n@[to_additive]\ntheorem Set.piecewise_mul [∀ i, Mul (f i)] (s : Set I) [∀ i, Decidable (i ∈ s)] (f₁ f₂ g₁ g₂ : ∀ i, f i) :\n    s.piecewise (f₁ * f₂) (g₁ * g₂) = s.piecewise f₁ g₁ * s.piecewise f₂ g₂ :=\n  s.piecewise_op₂ _ _ _ _ fun _ => (· * ·)\n#align set.piecewise_mul Set.piecewise_mul\n#align set.piecewise_add Set.piecewise_add\n-/\n\n",
 "piecewise_inv":
 "#print Set.piecewise_inv /-\n@[to_additive]\ntheorem Set.piecewise_inv [∀ i, Inv (f i)] (s : Set I) [∀ i, Decidable (i ∈ s)] (f₁ g₁ : ∀ i, f i) :\n    s.piecewise f₁⁻¹ g₁⁻¹ = (s.piecewise f₁ g₁)⁻¹ :=\n  s.piecewise_op f₁ g₁ fun _ x => x⁻¹\n#align set.piecewise_inv Set.piecewise_inv\n#align set.piecewise_neg Set.piecewise_neg\n-/\n\n",
 "piecewise_div":
 "#print Set.piecewise_div /-\n@[to_additive]\ntheorem Set.piecewise_div [∀ i, Div (f i)] (s : Set I) [∀ i, Decidable (i ∈ s)] (f₁ f₂ g₁ g₂ : ∀ i, f i) :\n    s.piecewise (f₁ / f₂) (g₁ / g₂) = s.piecewise f₁ g₁ / s.piecewise f₂ g₂ :=\n  s.piecewise_op₂ _ _ _ _ fun _ => (· / ·)\n#align set.piecewise_div Set.piecewise_div\n#align set.piecewise_sub Set.piecewise_sub\n-/\n\n",
 "mul_single_strict_mono":
 "@[to_additive]\ntheorem mul_single_strict_mono : StrictMono (Pi.mulSingle i : f i → ∀ i, f i) :=\n  Function.update_strictMono\n#align mul_single_strict_mono mul_single_strict_mono\n\n",
 "mul_single_mono":
 "@[to_additive]\ntheorem mul_single_mono : Monotone (Pi.mulSingle i : f i → ∀ i, f i) :=\n  Function.update_mono\n#align mul_single_mono mul_single_mono\n\n",
 "mulSingle_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print Pi.mulSingle_sup /-\n@[to_additive]\ntheorem Pi.mulSingle_sup [∀ i, SemilatticeSup (f i)] [∀ i, One (f i)] (i : I) (x y : f i) :\n    Pi.mulSingle i («expr ⊔ » x y) = «expr ⊔ » (Pi.mulSingle i x) (Pi.mulSingle i y) :=\n  Function.update_sup _ _ _ _\n#align pi.mul_single_sup Pi.mulSingle_sup\n#align pi.single_sup Pi.single_sup\n-/\n\n",
 "mulSingle_mul_mulSingle_eq_mulSingle_mul_mulSingle":
 "#print Pi.mulSingle_mul_mulSingle_eq_mulSingle_mul_mulSingle /-\n@[to_additive Pi.single_add_single_eq_single_add_single]\ntheorem Pi.mulSingle_mul_mulSingle_eq_mulSingle_mul_mulSingle {M : Type _} [CommMonoid M] {k l m n : I} {u v : M}\n    (hu : u ≠ 1) (hv : v ≠ 1) :\n    mulSingle k u * mulSingle l v = mulSingle m u * mulSingle n v ↔\n      k = m ∧ l = n ∨ u = v ∧ k = n ∧ l = m ∨ u * v = 1 ∧ k = l ∧ m = n :=\n  by\n  refine' ⟨fun h => _, _⟩\n  · have hk := congr_fun h k\n    have hl := congr_fun h l\n    have hm := (congr_fun h m).symm\n    have hn := (congr_fun h n).symm\n    simp only [mul_apply, mul_single_apply, if_pos rfl] at hk hl hm hn\n    rcases eq_or_ne k m with (rfl | hkm)\n    · refine' or.inl ⟨rfl, not_ne_iff.mp fun hln => (hv _).elim⟩\n      rcases eq_or_ne k l with (rfl | hkl)\n      · rwa [if_neg hln.symm, if_neg hln.symm, one_mul, one_mul] at hn\n      · rwa [if_neg hkl.symm, if_neg hln, one_mul, one_mul] at hl\n    · rcases eq_or_ne m n with (rfl | hmn)\n      · rcases eq_or_ne k l with (rfl | hkl)\n        · rw [if_neg hkm.symm, if_neg hkm.symm, one_mul, if_pos rfl] at hm\n          exact or.inr (or.inr ⟨hm, rfl, rfl⟩)\n        · simpa only [if_neg hkm, if_neg hkl, mul_one] using hk\n      · rw [if_neg hkm.symm, if_neg hmn, one_mul, mul_one] at hm\n        obtain rfl := (ite_ne_right_iff.mp (ne_of_eq_of_ne hm.symm hu)).1\n        rw [if_neg hkm, if_neg hkm, one_mul, mul_one] at hk\n        obtain rfl := (ite_ne_right_iff.mp (ne_of_eq_of_ne hk.symm hu)).1\n        exact or.inr (or.inl ⟨hk.trans (if_pos rfl), rfl, rfl⟩)\n  · rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl, rfl⟩ | ⟨h, rfl, rfl⟩)\n    · rfl\n    · apply mul_comm\n    · simp_rw [← Pi.mulSingle_mul, h, mul_single_one]\n#align pi.mul_single_mul_mul_single_eq_mul_single_mul_mul_single Pi.mulSingle_mul_mulSingle_eq_mulSingle_mul_mulSingle\n#align pi.single_add_single_eq_single_add_single Pi.single_add_single_eq_single_add_single\n-/\n\n",
 "mulSingle_mul":
 "#print Pi.mulSingle_mul /-\n@[to_additive]\ntheorem Pi.mulSingle_mul [∀ i, MulOneClass <| f i] (i : I) (x y : f i) :\n    mulSingle i (x * y) = mulSingle i x * mulSingle i y :=\n  (MonoidHom.single f i).map_mul x y\n#align pi.mul_single_mul Pi.mulSingle_mul\n#align pi.single_add Pi.single_add\n-/\n\n",
 "mulSingle_inv":
 "#print Pi.mulSingle_inv /-\n@[to_additive]\ntheorem Pi.mulSingle_inv [∀ i, Group <| f i] (i : I) (x : f i) : mulSingle i x⁻¹ = (mulSingle i x)⁻¹ :=\n  (MonoidHom.single f i).map_inv x\n#align pi.mul_single_inv Pi.mulSingle_inv\n#align pi.single_neg Pi.single_neg\n-/\n\n",
 "mulSingle_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print Pi.mulSingle_inf /-\n@[to_additive]\ntheorem Pi.mulSingle_inf [∀ i, SemilatticeInf (f i)] [∀ i, One (f i)] (i : I) (x y : f i) :\n    Pi.mulSingle i («expr ⊓ » x y) = «expr ⊓ » (Pi.mulSingle i x) (Pi.mulSingle i y) :=\n  Function.update_inf _ _ _ _\n#align pi.mul_single_inf Pi.mulSingle_inf\n#align pi.single_inf Pi.single_inf\n-/\n\n",
 "mulSingle_commute":
 "#print Pi.mulSingle_commute /-\n/-- The injection into a pi group at different indices commutes.\n\nFor injections of commuting elements at the same index, see `commute.map` -/\n@[to_additive\n      \"The injection into an additive pi group at different indices commutes.\\n\\nFor injections of commuting elements at the same index, see `add_commute.map`\"]\ntheorem Pi.mulSingle_commute [∀ i, MulOneClass <| f i] :\n    Pairwise fun i j => ∀ (x : f i) (y : f j), Commute (mulSingle i x) (mulSingle j y) :=\n  by\n  intro i j hij x y; ext k\n  by_cases h1 : i = k;\n  · subst h1\n    simp [hij]\n  by_cases h2 : j = k;\n  · subst h2\n    simp [hij]\n  simp [h1, h2]\n#align pi.mul_single_commute Pi.mulSingle_commute\n#align pi.single_commute Pi.single_commute\n-/\n\n",
 "mulSingle_apply_commute":
 "#print Pi.mulSingle_apply_commute /-\n/-- The injection into a pi group with the same values commutes. -/\n@[to_additive \"The injection into an additive pi group with the same values commutes.\"]\ntheorem Pi.mulSingle_apply_commute [∀ i, MulOneClass <| f i] (x : ∀ i, f i) (i j : I) :\n    Commute (mulSingle i (x i)) (mulSingle j (x j)) :=\n  by\n  obtain rfl | hij := Decidable.eq_or_ne i j\n  · rfl\n  · exact Pi.mulSingle_commute hij _ _\n#align pi.mul_single_apply_commute Pi.mulSingle_apply_commute\n#align pi.single_apply_commute Pi.single_apply_commute\n-/\n\n",
 "mulHom_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ* » -/\n#print Pi.mulHom_injective /-\n@[to_additive]\ntheorem Pi.mulHom_injective {γ : Type w} [Nonempty I] [∀ i, Mul (f i)] [Mul γ] (g : ∀ i, «expr →ₙ* » γ (f i))\n    (hg : ∀ i, function.injective (g i)) : function.injective (Pi.mulHom g) := fun x y h =>\n  let ⟨i⟩ := ‹Nonempty I›\n  hg i ((Function.funext_iff.mp h : _) i)\n#align pi.mul_hom_injective Pi.mulHom_injective\n#align pi.add_hom_injective Pi.addHom_injective\n-/\n\n",
 "monoidHom_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print Pi.monoidHom_injective /-\n@[to_additive]\ntheorem Pi.monoidHom_injective {γ : Type w} [Nonempty I] [∀ i, MulOneClass (f i)] [MulOneClass γ]\n    (g : ∀ i, «expr →* » γ (f i)) (hg : ∀ i, function.injective (g i)) : function.injective (Pi.monoidHom g) :=\n  Pi.mulHom_injective (fun i => (g i).to_mul_hom) hg\n#align pi.monoid_hom_injective Pi.monoidHom_injective\n#align pi.add_monoid_hom_injective Pi.addMonoidHom_injective\n-/\n\n",
 "const_ne_one":
 "@[to_additive]\ntheorem const_ne_one : const ι a ≠ 1 ↔ a ≠ 1 :=\n  const_eq_one.not\n#align const_ne_one const_ne_one\n\n",
 "const_eq_one":
 "@[simp, to_additive]\ntheorem const_eq_one : const ι a = 1 ↔ a = 1 :=\n  @const_inj _ _ _ _ 1\n#align const_eq_one const_eq_one\n\n",
 "coe_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ* » -/\n@[to_additive]\ntheorem coe_mul {M N} {mM : Mul M} {mN : CommSemigroup N} (f g : «expr →ₙ* » M N) :\n    (f * g : M → N) = fun x => f x * g x :=\n  rfl\n#align coe_mul coe_mul\n\n"}