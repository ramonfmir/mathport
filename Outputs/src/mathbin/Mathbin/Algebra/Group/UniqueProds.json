{"subsingleton":
 "@[to_additive]\ntheorem subsingleton (A B : Finset G) (a0 b0 : G) (h : unique_mul A B a0 b0) :\n    subsingleton { ab : G × G // ab.1 ∈ A ∧ ab.2 ∈ B ∧ ab.1 * ab.2 = a0 * b0 } :=\n  ⟨fun ⟨⟨a, b⟩, ha, hb, ab⟩ ⟨⟨a', b'⟩, ha', hb', ab'⟩ =>\n    subtype.ext <|\n      Prod.ext ((h ha hb ab).1.trans (h ha' hb' ab').1.symm) <| (h ha hb ab).2.trans (h ha' hb' ab').2.symm⟩\n#align subsingleton subsingleton\n\n",
 "set_subsingleton":
 "@[to_additive]\ntheorem set_subsingleton (A B : Finset G) (a0 b0 : G) (h : unique_mul A B a0 b0) :\n    Set.Subsingleton { ab : G × G | ab.1 ∈ A ∧ ab.2 ∈ B ∧ ab.1 * ab.2 = a0 * b0 } :=\n  by\n  rintro ⟨x1, y1⟩ (hx : x1 ∈ A ∧ y1 ∈ B ∧ x1 * y1 = a0 * b0) ⟨x2, y2⟩ (hy : x2 ∈ A ∧ y2 ∈ B ∧ x2 * y2 = a0 * b0)\n  rcases h hx.1 hx.2.1 hx.2.2 with ⟨rfl, rfl⟩\n  rcases h hy.1 hy.2.1 hy.2.2 with ⟨rfl, rfl⟩\n  rfl\n#align set_subsingleton set_subsingleton\n\n",
 "mul_hom_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ* » -/\n/-- `unique_mul` is preserved by inverse images under injective, multiplicative maps. -/\n@[to_additive \"`unique_add` is preserved by inverse images under injective, additive maps.\"]\ntheorem mul_hom_preimage (f : «expr →ₙ* » G H) (hf : function.injective f) (a0 b0 : G) {A B : Finset H}\n    (u : unique_mul A B (f a0) (f b0)) :\n    unique_mul (A.preimage f (Set.injOn_of_injective hf _)) (B.preimage f (Set.injOn_of_injective hf _)) a0 b0 :=\n  by\n  intro a b ha hb ab\n  rw [← hf.eq_iff, ← hf.eq_iff]\n  rw [← hf.eq_iff, map_mul, map_mul] at ab\n  exact u (finset.mem_preimage.mp ha) (finset.mem_preimage.mp hb) ab\n#align mul_hom_preimage mul_hom_preimage\n\n",
 "mul_hom_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/-- `unique_mul` is preserved under embeddings that are multiplicative.\n\nSee `unique_mul.mul_hom_image_iff` for a version with swapped bundling. -/\n@[to_additive\n      \"`unique_add` is preserved under embeddings that are additive.\\n\\nSee `unique_add.add_hom_image_iff` for a version with swapped bundling.\"]\ntheorem mul_hom_map_iff (f : «expr ↪ » G H) (mul : ∀ x y, f (x * y) = f x * f y) :\n    unique_mul (A.map f) (B.map f) (f a0) (f b0) ↔ unique_mul A B a0 b0 := by\n  classical convert mul_hom_image_iff ⟨f, mul⟩ f.2 <;>\n      · ext\n        simp only [Finset.mem_map, MulHom.coe_mk, Finset.mem_image]\n#align mul_hom_map_iff mul_hom_map_iff\n\n",
 "mul_hom_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ* » -/\n/-- `unique_mul` is preserved under multiplicative maps that are injective.\n\nSee `unique_mul.mul_hom_map_iff` for a version with swapped bundling. -/\n@[to_additive\n      \"`unique_add` is preserved under additive maps that are injective.\\n\\nSee `unique_add.add_hom_map_iff` for a version with swapped bundling.\"]\ntheorem mul_hom_image_iff [decidable_eq H] (f : «expr →ₙ* » G H) (hf : function.injective f) :\n    unique_mul (A.image f) (B.image f) (f a0) (f b0) ↔ unique_mul A B a0 b0 :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · intro a b ha hb ab\n    rw [← hf.eq_iff, ← hf.eq_iff]\n    rw [← hf.eq_iff, map_mul, map_mul] at ab\n    exact h (finset.mem_image.mpr ⟨_, ha, rfl⟩) (finset.mem_image.mpr ⟨_, hb, rfl⟩) ab\n  · intro a b aA bB ab\n    obtain ⟨a, ha, rfl⟩ : ∃ a' ∈ A, f a' = a := finset.mem_image.mp aA\n    obtain ⟨b, hb, rfl⟩ : ∃ b' ∈ B, f b' = b := finset.mem_image.mp bB\n    rw [hf.eq_iff, hf.eq_iff]\n    rw [← map_mul, ← map_mul, hf.eq_iff] at ab\n    exact h ha hb ab\n#align mul_hom_image_iff mul_hom_image_iff\n\n",
 "mt":
 "#print mt /-\n/-\nCopyright (c) 2022 Damiano Testa. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Damiano Testa\n-/\ntheorem mt {G} [Mul G] {A B : Finset G} {a0 b0 : G} (h : unique_mul A B a0 b0) :\n    ∀ ⦃a b⦄, a ∈ A → b ∈ B → a ≠ a0 ∨ b ≠ b0 → a * b ≠ a0 * b0 := fun _ _ ha hb k =>\n  by\n  contrapose! k\n  exact h ha hb k\n#align mt mt\n-/\n\n",
 "iff_exists_unique":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (ab «expr ∈ » [finset.product/multiset.product/set.prod/list.product](A, B)) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[to_additive]\ntheorem iff_exists_unique (aA : a0 ∈ A) (bB : b0 ∈ B) :\n    unique_mul A B a0 b0 ↔ ∃! (ab : _)(_ : ab ∈ finset.product A B), ab.1 * ab.2 = a0 * b0 :=\n  ⟨fun _ => ⟨(a0, b0), ⟨finset.mem_product.mpr ⟨aA, bB⟩, rfl, by simp⟩, by simpa⟩, fun h =>\n    h.elim2\n      (by\n        rintro ⟨x1, x2⟩ _ _ J x y hx hy l\n        rcases prod.mk.inj_iff.mp (J (a0, b0) (finset.mk_mem_product aA bB) rfl) with ⟨rfl, rfl⟩\n        exact prod.mk.inj_iff.mp (J (x, y) (finset.mk_mem_product hx hy) l))⟩\n#align iff_exists_unique iff_exists_unique\n\n",
 "exists_iff_exists_exists_unique":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (ab «expr ∈ » [finset.product/multiset.product/set.prod/list.product](A, B)) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[to_additive]\ntheorem exists_iff_exists_exists_unique :\n    (∃ a0 b0 : G, a0 ∈ A ∧ b0 ∈ B ∧ unique_mul A B a0 b0) ↔\n      ∃ g : G, ∃! (ab : _)(_ : ab ∈ finset.product A B), ab.1 * ab.2 = g :=\n  ⟨fun ⟨a0, b0, hA, hB, h⟩ => ⟨_, (iff_exists_unique hA hB).mp h⟩, fun ⟨g, h⟩ =>\n    by\n    have h' := h\n    rcases h' with ⟨⟨a, b⟩, ⟨hab, rfl, -⟩, -⟩\n    cases' finset.mem_product.mp hab with ha hb\n    exact ⟨a, b, ha, hb, (iff_exists_unique ha hb).mpr h⟩⟩\n#align exists_iff_exists_exists_unique exists_iff_exists_exists_unique\n\n",
 "eq_and_eq_of_le_of_le_of_mul_le":
 "@[to_additive]\ntheorem eq_and_eq_of_le_of_le_of_mul_le {A} [Mul A] [linear_order A] [covariant_class A A (· * ·) (· ≤ ·)]\n    [covariant_class A A (function.swap (· * ·)) (· < ·)] [contravariant_class A A (· * ·) (· ≤ ·)] {a b a0 b0 : A}\n    (ha : a0 ≤ a) (hb : b0 ≤ b) (ab : a * b ≤ a0 * b0) : a = a0 ∧ b = b0 :=\n  by\n  haveI := Mul.to_covariantClass_right A\n  have ha' : ¬a0 * b0 < a * b → ¬a0 < a := mt fun h => mul_lt_mul_of_lt_of_le h hb\n  have hb' : ¬a0 * b0 < a * b → ¬b0 < b := mt fun h => mul_lt_mul_of_le_of_lt ha h\n  push_neg  at ha' hb'\n  exact ⟨ha.antisymm' (ha' ab), hb.antisymm' (hb' ab)⟩\n#align eq_and_eq_of_le_of_le_of_mul_le eq_and_eq_of_le_of_le_of_mul_le\n\n"}