{"unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/-- Every linear map from a direct sum agrees with the one obtained by applying\nthe universal property to each of its components. -/\ntheorem to_module.unique\n    (f : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (M i)) :\n    ψ f = to_module R ι N (fun i => ψ.comp <| lof R ι M i) f :=\n  to_add_monoid.unique ψ.to_add_monoid_hom f\n#align to_module.unique to_module.unique\n\n",
 "to_module_lof":
 "/-- The map constructed using the universal property gives back the original maps when\nrestricted to each component. -/\n@[simp]\ntheorem to_module_lof (i) (x : M i) : to_module R ι N φ (lof R ι M i x) = φ i x :=\n  to_add_monoid_of (fun i => (φ i).to_add_monoid_hom) i x\n#align to_module_lof to_module_lof\n\n",
 "support_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem support_smul [∀ (i : ι) (x : M i), decidable (x ≠ 0)] (c : R)\n    (v : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (M i)) :\n    («expr • » c v).support ⊆ v.support :=\n  dfinsupp.support_smul _ _\n#align support_smul support_smul\n\n",
 "submodule_supr_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If a direct sum of submodules is internal then the submodules span the module. -/\ntheorem is_internal.submodule_supr_eq_top (h : is_internal A) : supᵢ A = «expr⊤» :=\n  by\n  rw [submodule.supr_eq_range_dfinsupp_lsum, linear_map.range_eq_top]\n  exact Function.Bijective.surjective h\n#align is_internal.submodule_supr_eq_top is_internal.submodule_supr_eq_top\n\n",
 "submodule_independent":
 "/-- If a direct sum of submodules is internal then the submodules are independent. -/\ntheorem is_internal.submodule_independent (h : is_internal A) : complete_lattice.independent A :=\n  complete_lattice.independent_of_dfinsupp_lsum_injective _ h.injective\n#align is_internal.submodule_independent is_internal.submodule_independent\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\ntheorem smul_apply (b : R)\n    (v : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (M i))\n    (i : ι) : («expr • » b v) i = «expr • » b (v i) :=\n  dfinsupp.smul_apply _ _ _\n#align smul_apply smul_apply\n\n",
 "single_eq_lof":
 "theorem single_eq_lof (i : ι) (b : M i) : dfinsupp.single i b = lof R ι M i b :=\n  rfl\n#align single_eq_lof single_eq_lof\n\n",
 "sigma_luncurry_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n@[simp]\ntheorem sigma_luncurry_apply\n    (f : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (δ i j))\n    (i : ι) (j : α i) : sigma_luncurry R f ⟨i, j⟩ = f i j :=\n  sigma_uncurry_apply f i j\n#align sigma_luncurry_apply sigma_luncurry_apply\n\n",
 "sigma_lcurry_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n@[simp]\ntheorem sigma_lcurry_apply\n    (f : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (δ i.1 i.2))\n    (i : ι) (j : α i) : sigma_lcurry R f i j = f ⟨i, j⟩ :=\n  sigma_curry_apply f i j\n#align sigma_lcurry_apply sigma_lcurry_apply\n\n",
 "of_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Scalar multiplication commutes with the inclusion of each component into the direct sum. -/\ntheorem of_smul (i : ι) (c : R) (x) : of M i («expr • » c x) = «expr • » c (of M i x) :=\n  (lof R ι M i).map_smul c x\n#align of_smul of_smul\n\n",
 "of":
 "theorem component.of (i j : ι) (b : M j) :\n    component R ι M i ((lof R ι M j) b) = if h : j = i then eq.rec_on h b else 0 :=\n  dfinsupp.single_apply\n#align component.of component.of\n\n",
 "mk_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Scalar multiplication commutes with direct sums. -/\ntheorem mk_smul (s : Finset ι) (c : R) (x) : mk M s («expr • » c x) = «expr • » c (mk M s x) :=\n  (lmk R ι M s).map_smul c x\n#align mk_smul mk_smul\n\n",
 "lof_self":
 "@[simp]\ntheorem component.lof_self (i : ι) (b : M i) : component R ι M i ((lof R ι M i) b) = b :=\n  lof_apply R i b\n#align component.lof_self component.lof_self\n\n",
 "lof_eq_of":
 "theorem lof_eq_of (i : ι) (b : M i) : lof R ι M i b = of M i b :=\n  rfl\n#align lof_eq_of lof_eq_of\n\n",
 "lof_apply":
 "@[simp]\ntheorem lof_apply (i : ι) (b : M i) : ((lof R ι M i) b) i = b :=\n  dfinsupp.single_eq_same\n#align lof_apply lof_apply\n\n",
 "linear_map_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/-- Two `linear_map`s out of a direct sum are equal if they agree on the generators.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem linear_map_ext\n    ⦃ψ ψ' :\n      «expr →ₗ[ ] »\n        (direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (M i)) R N⦄\n    (H : ∀ i, ψ.comp (lof R ι M i) = ψ'.comp (lof R ι M i)) : ψ = ψ' :=\n  dfinsupp.lhom_ext' H\n#align linear_map_ext linear_map_ext\n\n",
 "linear_equiv_fun_on_fintype_symm_single":
 "@[simp]\ntheorem linear_equiv_fun_on_fintype_symm_single [fintype ι] [decidable_eq ι] (i : ι) (m : M i) :\n    (linear_equiv_fun_on_fintype R ι M).symm (Pi.single i m) = lof R ι M i m :=\n  by\n  ext a\n  change (dfinsupp.equiv_fun_on_fintype.symm (Pi.single i m)) a = _\n  rw [dfinsupp.equiv_fun_on_fintype_symm_single i m]\n  rfl\n#align linear_equiv_fun_on_fintype_symm_single linear_equiv_fun_on_fintype_symm_single\n\n",
 "linear_equiv_fun_on_fintype_symm_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n@[simp]\ntheorem linear_equiv_fun_on_fintype_symm_coe [fintype ι]\n    (f : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (M i)) :\n    (linear_equiv_fun_on_fintype R ι M).symm f = f := by\n  ext\n  simp [linear_equiv_fun_on_fintype]\n#align linear_equiv_fun_on_fintype_symm_coe linear_equiv_fun_on_fintype_symm_coe\n\n",
 "linear_equiv_fun_on_fintype_lof":
 "@[simp]\ntheorem linear_equiv_fun_on_fintype_lof [fintype ι] [decidable_eq ι] (i : ι) (m : M i) :\n    (linear_equiv_fun_on_fintype R ι M) (lof R ι M i m) = Pi.single i m :=\n  by\n  ext a\n  change (dfinsupp.equiv_fun_on_fintype (lof R ι M i m)) a = _\n  convert _root_.congr_fun (dfinsupp.equiv_fun_on_fintype_single i m) a\n#align linear_equiv_fun_on_fintype_lof linear_equiv_fun_on_fintype_lof\n\n",
 "lequiv_congr_left_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n@[simp]\ntheorem lequiv_congr_left_apply (h : «expr ≃ » ι κ)\n    (f : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (M i))\n    (k : κ) : lequiv_congr_left R h f k = f (h.symm k) :=\n  equiv_congr_left_apply _ _ _\n#align lequiv_congr_left_apply lequiv_congr_left_apply\n\n",
 "is_internal_submodule_of_independent_of_supr_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Note that this is not generally true for `[semiring R]`; see\n`complete_lattice.independent.dfinsupp_lsum_injective` for details. -/\ntheorem is_internal_submodule_of_independent_of_supr_eq_top {A : ι → submodule R M}\n    (hi : complete_lattice.independent A) (hs : supᵢ A = «expr⊤») : is_internal A :=\n  ⟨hi.dfinsupp_lsum_injective, linear_map.range_eq_top.1 <| (submodule.supr_eq_range_dfinsupp_lsum _).symm.trans hs⟩\n#align is_internal_submodule_of_independent_of_supr_eq_top is_internal_submodule_of_independent_of_supr_eq_top\n\n",
 "is_internal_submodule_iff_is_compl":
 "/-- If a collection of submodules has just two indices, `i` and `j`, then\n`direct_sum.is_internal` is equivalent to `is_compl`. -/\ntheorem is_internal_submodule_iff_is_compl (A : ι → submodule R M) {i j : ι} (hij : i ≠ j)\n    (h : (Set.univ : set ι) = {i, j}) : is_internal A ↔ IsCompl (A i) (A j) :=\n  by\n  have : ∀ k, k = i ∨ k = j := fun k => by simpa using set.ext_iff.mp h k\n  rw [is_internal_submodule_iff_independent_and_supr_eq_top, supᵢ, ← Set.image_univ, h, Set.image_insert_eq,\n    Set.image_singleton, supₛ_pair, complete_lattice.independent_pair hij this]\n  exact ⟨fun ⟨hd, ht⟩ => ⟨hd, codisjoint_iff.mpr ht⟩, fun ⟨hd, ht⟩ => ⟨hd, ht.eq_top⟩⟩\n#align is_internal_submodule_iff_is_compl is_internal_submodule_iff_is_compl\n\n",
 "is_internal_submodule_iff_independent_and_supr_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- `iff` version of `direct_sum.is_internal_submodule_of_independent_of_supr_eq_top`,\n`direct_sum.is_internal.independent`, and `direct_sum.is_internal.supr_eq_top`.\n-/\ntheorem is_internal_submodule_iff_independent_and_supr_eq_top (A : ι → submodule R M) :\n    is_internal A ↔ complete_lattice.independent A ∧ supᵢ A = «expr⊤» :=\n  ⟨fun i => ⟨i.submodule_independent, i.submodule_supr_eq_top⟩,\n    and.rec is_internal_submodule_of_independent_of_supr_eq_top⟩\n#align is_internal_submodule_iff_independent_and_supr_eq_top is_internal_submodule_iff_independent_and_supr_eq_top\n\n",
 "is_compl":
 "/-- When indexed by only two distinct elements, `direct_sum.is_internal` implies\nthe two submodules are complementary. Over a `ring R`, this is true as an iff, as\n`direct_sum.is_internal_iff_is_compl`. -/\ntheorem is_internal.is_compl {A : ι → submodule R M} {i j : ι} (hij : i ≠ j) (h : (Set.univ : set ι) = {i, j})\n    (hi : is_internal A) : IsCompl (A i) (A j) :=\n  ⟨hi.submodule_independent.pairwise_disjoint hij,\n    codisjoint_iff.mpr <|\n      eq.symm <|\n        hi.submodule_supr_eq_top.symm.trans <| by\n          rw [← supₛ_pair, supᵢ, ← Set.image_univ, h, Set.image_insert_eq, Set.image_singleton]⟩\n#align is_internal.is_compl is_internal.is_compl\n\n",
 "ext_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\ntheorem ext_iff\n    {f g : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (M i)} :\n    f = g ↔ ∀ i, component R ι M i f = component R ι M i g :=\n  ⟨fun h _ => by rw [h], ext R⟩\n#align ext_iff ext_iff\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n@[ext]\ntheorem ext\n    {f g : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (M i)}\n    (h : ∀ i, component R ι M i f = component R ι M i g) : f = g :=\n  dfinsupp.ext h\n#align ext ext\n\n",
 "collected_basis_mem":
 "theorem is_internal.collected_basis_mem (h : is_internal A) {α : ι → Type _} (v : ∀ i, basis (α i) R (A i))\n    (a : Σi, α i) : h.collected_basis v a ∈ A a.1 := by simp\n#align is_internal.collected_basis_mem is_internal.collected_basis_mem\n\n",
 "collected_basis_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem is_internal.collected_basis_coe (h : is_internal A) {α : ι → Type _} (v : ∀ i, basis (α i) R (A i)) :\n    «expr⇑ » (h.collected_basis v) = fun a : Σi, α i => ↑(v a.1 a.2) :=\n  by\n  funext a\n  simp only [is_internal.collected_basis, to_module, coe_linear_map, [anonymous], basis.coe_of_repr,\n    basis.repr_symm_apply, dfinsupp.lsum_apply_apply, dfinsupp.map_range.linear_equiv_apply,\n    dfinsupp.map_range.linear_equiv_symm, dfinsupp.map_range_single, finsupp.total_single,\n    linear_equiv.of_bijective_apply, linear_equiv.symm_symm, linear_equiv.symm_trans_apply, one_smul,\n    sigma_finsupp_add_equiv_dfinsupp_apply, sigma_finsupp_equiv_dfinsupp_single, sigma_finsupp_lequiv_dfinsupp_apply]\n  convert dfinsupp.sum_add_hom_single (fun i => (A i).subtype.to_add_monoid_hom) a.1 (v a.1 a.2)\n#align is_internal.collected_basis_coe is_internal.collected_basis_coe\n\n",
 "coe_to_module_eq_coe_to_add_monoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/-- Coproducts in the categories of modules and additive monoids commute with the forgetful functor\nfrom modules to additive monoids. -/\ntheorem coe_to_module_eq_coe_to_add_monoid :\n    (to_module R ι N φ :\n        direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (M i) → N) =\n      to_add_monoid fun i => (φ i).to_add_monoid_hom :=\n  rfl\n#align coe_to_module_eq_coe_to_add_monoid coe_to_module_eq_coe_to_add_monoid\n\n",
 "coe_linear_map_of":
 "@[simp]\ntheorem coe_linear_map_of (i : ι) (x : A i) : direct_sum.coe_linear_map A (of (fun i => A i) i x) = x :=\n  to_add_monoid_of _ _ _\n#align coe_linear_map_of coe_linear_map_of\n\n",
 "apply_eq_component":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\ntheorem apply_eq_component\n    (f : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (M i))\n    (i : ι) : f i = component R ι M i f :=\n  rfl\n#align apply_eq_component apply_eq_component\n\n",
 "add_submonoid_independent":
 "theorem is_internal.add_submonoid_independent {M : Type _} [add_comm_monoid M] {A : ι → AddSubmonoid M}\n    (h : is_internal A) : complete_lattice.independent A :=\n  complete_lattice.independent_of_dfinsupp_sum_add_hom_injective _ h.injective\n#align is_internal.add_submonoid_independent is_internal.add_submonoid_independent\n\n",
 "add_subgroup_independent":
 "theorem is_internal.add_subgroup_independent {M : Type _} [add_comm_group M] {A : ι → add_subgroup M}\n    (h : is_internal A) : complete_lattice.independent A :=\n  complete_lattice.independent_of_dfinsupp_sum_add_hom_injective' _ h.injective\n#align is_internal.add_subgroup_independent is_internal.add_subgroup_independent\n\n"}