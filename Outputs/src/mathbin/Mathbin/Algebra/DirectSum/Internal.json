{"supr_eq_to_submodule_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- The supremum of submodules that form a graded monoid is a subalgebra, and equal to the range of\n`direct_sum.coe_alg_hom`. -/\ntheorem submodule.supr_eq_to_submodule_range [add_monoid ι] [CommSemiring S] [Semiring R] [algebra S R]\n    (A : ι → submodule S R) [set_like.graded_monoid A] :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (A i) =\n      (direct_sum.coe_alg_hom A).range.to_submodule :=\n  (submodule.supr_eq_range_dfinsupp_lsum A).trans <| SetLike.coe_injective rfl\n#align submodule.supr_eq_to_submodule_range submodule.supr_eq_to_submodule_range\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem set_like.is_homogeneous.smul [CommSemiring S] [Semiring R] [algebra S R] {A : ι → submodule S R} {s : S} {r : R}\n    (hr : set_like.is_homogeneous A r) : set_like.is_homogeneous A («expr • » s r) :=\n  let ⟨i, hi⟩ := hr\n  ⟨i, submodule.smul_mem _ _ hi⟩\n#align set_like.is_homogeneous.smul set_like.is_homogeneous.smul\n\n",
 "nat_cast_mem_graded":
 "theorem set_like.nat_cast_mem_graded [Zero ι] [AddMonoidWithOne R] [SetLike σ R] [AddSubmonoidClass σ R] (A : ι → σ)\n    [set_like.has_graded_one A] (n : ℕ) : (n : R) ∈ A 0 :=\n  by\n  induction n\n  · rw [Nat.cast_zero]\n    exact zero_mem (A 0)\n  · rw [Nat.cast_succ]\n    exact add_mem n_ih (set_like.one_mem_graded _)\n#align set_like.nat_cast_mem_graded set_like.nat_cast_mem_graded\n\n",
 "is_homogeneous_zero_submodule":
 "theorem set_like.is_homogeneous_zero_submodule [Zero ι] [Semiring S] [add_comm_monoid R] [Module S R]\n    (A : ι → submodule S R) : set_like.is_homogeneous A (0 : R) :=\n  ⟨0, submodule.zero_mem _⟩\n#align set_like.is_homogeneous_zero_submodule set_like.is_homogeneous_zero_submodule\n\n",
 "int_cast_mem_graded":
 "theorem set_like.int_cast_mem_graded [Zero ι] [AddGroupWithOne R] [SetLike σ R] [add_subgroup_class σ R] (A : ι → σ)\n    [set_like.has_graded_one A] (z : ℤ) : (z : R) ∈ A 0 :=\n  by\n  induction z\n  · rw [int.cast_of_nat]\n    exact set_like.nat_cast_mem_graded _ _\n  · rw [Int.cast_negSucc]\n    exact neg_mem (set_like.nat_cast_mem_graded _ _)\n#align set_like.int_cast_mem_graded set_like.int_cast_mem_graded\n\n",
 "coe_ring_hom_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- The canonical ring isomorphism between `⨁ i, A i` and `R`-/\n@[simp]\ntheorem coe_ring_hom_of [add_monoid ι] [set_like.graded_monoid A] (i : ι) (x : A i) :\n    (coe_ring_hom A : «expr →+* » _ R) (of (fun i => A i) i x) = x :=\n  direct_sum.to_semiring_of _ _ _ _ _\n#align coe_ring_hom_of coe_ring_hom_of\n\n",
 "coe_of_mul_apply_of_not_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\ntheorem coe_of_mul_apply_of_not_le {i : ι} (r : A i)\n    (r' : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (A i)) (n : ι)\n    (h : ¬i ≤ n) : ((of _ i r * r') n : R) = 0 := by\n  classical\n    rw [coe_mul_apply_eq_dfinsupp_sum]\n    apply (dfinsupp.sum_single_index _).trans\n    swap\n    · simp_rw [ZeroMemClass.coe_zero, zero_mul, if_t_t]\n      exact dfinsupp.sum_zero\n    · rw [dfinsupp.sum, finset.sum_ite_of_false _ _ fun x _ H => _, finset.sum_const_zero]\n      exact h ((self_le_add_right i x).trans_eq H)\n#align coe_of_mul_apply_of_not_le coe_of_mul_apply_of_not_le\n\n",
 "coe_of_mul_apply_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\ntheorem coe_of_mul_apply_of_le {i : ι} (r : A i)\n    (r' : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (A i)) (n : ι)\n    (h : i ≤ n) : ((of _ i r * r') n : R) = r * r' (n - i) :=\n  coe_of_mul_apply_aux _ _ _ fun x => by rw [eq_tsub_iff_add_eq_of_le h, add_comm]\n#align coe_of_mul_apply_of_le coe_of_mul_apply_of_le\n\n",
 "coe_of_mul_apply_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\ntheorem coe_of_mul_apply_aux [add_monoid ι] [set_like.graded_monoid A] {i : ι} (r : A i)\n    (r' : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (A i))\n    {j n : ι} (H : ∀ x : ι, i + x = n ↔ x = j) : ((of _ i r * r') n : R) = r * r' j := by\n  classical\n    rw [coe_mul_apply_eq_dfinsupp_sum]\n    apply (dfinsupp.sum_single_index _).trans\n    swap\n    · simp_rw [ZeroMemClass.coe_zero, zero_mul, if_t_t]\n      exact dfinsupp.sum_zero\n    simp_rw [dfinsupp.sum, H, finset.sum_ite_eq']\n    split_ifs\n    rfl\n    rw [dfinsupp.not_mem_support_iff.mp h, ZeroMemClass.coe_zero, mul_zero]\n#align coe_of_mul_apply_aux coe_of_mul_apply_aux\n\n",
 "coe_of_mul_apply_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\ntheorem coe_of_mul_apply_add [add_left_cancel_monoid ι] [set_like.graded_monoid A] {i : ι} (r : A i)\n    (r' : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (A i))\n    (j : ι) : ((of _ i r * r') (i + j) : R) = r * r' j :=\n  coe_of_mul_apply_aux _ _ _ fun x => ⟨fun h => add_left_cancel h, fun h => h ▸ rfl⟩\n#align coe_of_mul_apply_add coe_of_mul_apply_add\n\n",
 "coe_of_mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\ntheorem coe_of_mul_apply {i : ι} (r : A i)\n    (r' : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (A i)) (n : ι)\n    [decidable (i ≤ n)] : ((of _ i r * r') n : R) = if i ≤ n then r * r' (n - i) else 0 :=\n  by\n  split_ifs\n  exacts[coe_of_mul_apply_of_le _ _ _ n h, coe_of_mul_apply_of_not_le _ _ _ n h]\n#align coe_of_mul_apply coe_of_mul_apply\n\n",
 "coe_mul_of_apply_of_not_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\ntheorem coe_mul_of_apply_of_not_le\n    (r : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (A i)) {i : ι}\n    (r' : A i) (n : ι) (h : ¬i ≤ n) : ((r * of _ i r') n : R) = 0 := by\n  classical\n    rw [coe_mul_apply_eq_dfinsupp_sum, dfinsupp.sum_comm]\n    apply (dfinsupp.sum_single_index _).trans\n    swap\n    · simp_rw [ZeroMemClass.coe_zero, mul_zero, if_t_t]\n      exact dfinsupp.sum_zero\n    · rw [dfinsupp.sum, finset.sum_ite_of_false _ _ fun x _ H => _, finset.sum_const_zero]\n      exact h ((self_le_add_left i x).trans_eq H)\n#align coe_mul_of_apply_of_not_le coe_mul_of_apply_of_not_le\n\n",
 "coe_mul_of_apply_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/- The following two lemmas only require the same hypotheses as `eq_tsub_iff_add_eq_of_le`, but we\n  state them for `canonically_ordered_add_monoid` + the above three typeclasses for convenience. -/\ntheorem coe_mul_of_apply_of_le\n    (r : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (A i)) {i : ι}\n    (r' : A i) (n : ι) (h : i ≤ n) : ((r * of _ i r') n : R) = r (n - i) * r' :=\n  coe_mul_of_apply_aux _ _ _ fun x => (eq_tsub_iff_add_eq_of_le h).symm\n#align coe_mul_of_apply_of_le coe_mul_of_apply_of_le\n\n",
 "coe_mul_of_apply_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\ntheorem coe_mul_of_apply_aux [add_monoid ι] [set_like.graded_monoid A]\n    (r : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (A i)) {i : ι}\n    (r' : A i) {j n : ι} (H : ∀ x : ι, x + i = n ↔ x = j) : ((r * of _ i r') n : R) = r j * r' := by\n  classical\n    rw [coe_mul_apply_eq_dfinsupp_sum, dfinsupp.sum_comm]\n    apply (dfinsupp.sum_single_index _).trans\n    swap\n    · simp_rw [ZeroMemClass.coe_zero, mul_zero, if_t_t]\n      exact dfinsupp.sum_zero\n    simp_rw [dfinsupp.sum, H, finset.sum_ite_eq']\n    split_ifs\n    rfl\n    rw [dfinsupp.not_mem_support_iff.mp h, ZeroMemClass.coe_zero, zero_mul]\n#align coe_mul_of_apply_aux coe_mul_of_apply_aux\n\n",
 "coe_mul_of_apply_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\ntheorem coe_mul_of_apply_add [add_right_cancel_monoid ι] [set_like.graded_monoid A]\n    (r : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (A i)) {i : ι}\n    (r' : A i) (j : ι) : ((r * of _ i r') (j + i) : R) = r j * r' :=\n  coe_mul_of_apply_aux _ _ _ fun x => ⟨fun h => add_right_cancel h, fun h => h ▸ rfl⟩\n#align coe_mul_of_apply_add coe_mul_of_apply_add\n\n",
 "coe_mul_of_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\ntheorem coe_mul_of_apply\n    (r : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (A i)) {i : ι}\n    (r' : A i) (n : ι) [decidable (i ≤ n)] : ((r * of _ i r') n : R) = if i ≤ n then r (n - i) * r' else 0 :=\n  by\n  split_ifs\n  exacts[coe_mul_of_apply_of_le _ _ _ n h, coe_mul_of_apply_of_not_le _ _ _ n h]\n#align coe_mul_of_apply coe_mul_of_apply\n\n",
 "coe_mul_apply_eq_dfinsupp_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\ntheorem coe_mul_apply_eq_dfinsupp_sum [add_monoid ι] [set_like.graded_monoid A] [∀ (i : ι) (x : A i), decidable (x ≠ 0)]\n    (r r' : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (A i))\n    (n : ι) : ((r * r') n : R) = r.sum fun i ri => r'.sum fun j rj => if i + j = n then ri * rj else 0 :=\n  by\n  simp only [mul_eq_dfinsupp_sum, dfinsupp.sum_apply]\n  iterate 2 rw [dfinsupp.sum, add_submonoid_class.coe_finset_sum]; congr ; ext\n  dsimp only; split_ifs\n  · subst h\n    rw [of_eq_same]\n    rfl\n  · rw [of_eq_of_ne _ _ _ _ h]\n    rfl\n#align coe_mul_apply_eq_dfinsupp_sum coe_mul_apply_eq_dfinsupp_sum\n\n",
 "coe_mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem coe_mul_apply [add_monoid ι] [set_like.graded_monoid A] [∀ (i : ι) (x : A i), decidable (x ≠ 0)]\n    (r r' : direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (A i))\n    (n : ι) :\n    ((r * r') n : R) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        ((finset.product r.support r'.support).filter fun ij : ι × ι => ij.1 + ij.2 = n) (r ij.1 * r' ij.2) :=\n  by\n  rw [mul_eq_sum_support_ghas_mul, dfinsupp.finset_sum_apply, add_submonoid_class.coe_finset_sum]\n  simp_rw [coe_of_apply, ← finset.sum_filter, set_like.coe_ghas_mul]\n#align coe_mul_apply coe_mul_apply\n\n",
 "coe_galgebra_to_fun":
 "@[simp]\ntheorem set_like.coe_galgebra_to_fun [add_monoid ι] [CommSemiring S] [Semiring R] [algebra S R] (A : ι → submodule S R)\n    [set_like.graded_monoid A] (s : S) :\n    ↑(@direct_sum.galgebra.to_fun _ S (fun i => A i) _ _ _ _ _ _ _ s) = (algebra_map S R s : R) :=\n  rfl\n#align set_like.coe_galgebra_to_fun set_like.coe_galgebra_to_fun\n\n",
 "coe_alg_hom_of":
 "@[simp]\ntheorem direct_sum.coe_alg_hom_of [add_monoid ι] [CommSemiring S] [Semiring R] [algebra S R] (A : ι → submodule S R)\n    [set_like.graded_monoid A] (i : ι) (x : A i) : direct_sum.coe_alg_hom A (direct_sum.of (fun i => A i) i x) = x :=\n  direct_sum.to_semiring_of _ rfl (fun _ _ _ _ => rfl) _ _\n#align direct_sum.coe_alg_hom_of direct_sum.coe_alg_hom_of\n\n",
 "algebra_map_mem_graded":
 "/-\nCopyright (c) 2021 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser, Kevin Buzzard, Jujian Zhang\n-/\ntheorem set_like.algebra_map_mem_graded [Zero ι] [CommSemiring S] [Semiring R] [algebra S R] (A : ι → submodule S R)\n    [set_like.has_graded_one A] (s : S) : algebra_map S R s ∈ A 0 :=\n  by\n  rw [algebra.algebra_map_eq_smul_one]\n  exact (A 0).smul_mem s <| set_like.one_mem_graded _\n#align set_like.algebra_map_mem_graded set_like.algebra_map_mem_graded\n\n"}