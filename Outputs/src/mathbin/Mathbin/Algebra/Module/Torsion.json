{"torsion_torsion_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The torsion submodule of the torsion submodule (viewed as a module) is the full\ntorsion module. -/\n@[simp]\ntheorem torsion_torsion_eq_top : torsion R (torsion R M) = «expr⊤» :=\n  torsion'_torsion'_eq_top (non_zero_divisors R)\n#align torsion_torsion_eq_top torsion_torsion_eq_top\n\n",
 "torsion_of_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2022 Pierre-Alexandre Bazin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Pierre-Alexandre Bazin\n-/\n@[simp]\ntheorem torsion_of_zero : torsion_of R M (0 : M) = «expr⊤» := by simp [torsion_of]\n#align torsion_of_zero torsion_of_zero\n\n",
 "torsion_of_eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem torsion_of_eq_top_iff (m : M) : torsion_of R M m = «expr⊤» ↔ m = 0 :=\n  by\n  refine' ⟨fun h => _, fun h => by simp [h]⟩\n  rw [← one_smul R m, ← mem_torsion_of_iff m (1 : R), h]\n  exact submodule.mem_top\n#align torsion_of_eq_top_iff torsion_of_eq_top_iff\n\n",
 "torsion_of_eq_bot_iff_of_no_zero_smul_divisors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem torsion_of_eq_bot_iff_of_no_zero_smul_divisors [nontrivial R] [NoZeroSMulDivisors R M] (m : M) :\n    torsion_of R M m = «expr⊥» ↔ m ≠ 0 :=\n  by\n  refine' ⟨fun h contra => _, fun h => (submodule.eq_bot_iff _).mpr fun r hr => _⟩\n  · rw [contra, torsion_of_zero] at h\n    exact bot_ne_top.symm h\n  · rw [mem_torsion_of_iff, smul_eq_zero] at hr\n    tauto\n#align torsion_of_eq_bot_iff_of_no_zero_smul_divisors torsion_of_eq_bot_iff_of_no_zero_smul_divisors\n\n",
 "torsion_is_torsion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/-- The torsion submodule is always a torsion module. -/\ntheorem torsion_is_torsion : module.is_torsion R (torsion R M) :=\n  torsion'_is_torsion' (non_zero_divisors R)\n#align torsion_is_torsion torsion_is_torsion\n\n",
 "torsion_gc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem torsion_gc :\n    @GaloisConnection (submodule R M) («expr ᵒᵈ» (ideal R)) _ _ annihilator fun I => torsion_by_set R M <| I.of_dual :=\n  fun A I =>\n  ⟨fun h x hx => (mem_torsion_by_set_iff _ _).mpr fun ⟨a, ha⟩ => mem_annihilator.mp (h ha) x hx, fun h a ha =>\n    mem_annihilator.mpr fun x hx => (mem_torsion_by_set_iff _ _).mp (h hx) ⟨a, ha⟩⟩\n#align torsion_gc torsion_gc\n\n",
 "torsion_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- Quotienting by the torsion submodule gives a torsion-free module. -/\n@[simp]\ntheorem torsion_eq_bot : torsion R («expr ⧸ » M (torsion R M)) = «expr⊥» :=\n  eq_bot_iff.mpr fun z =>\n    Quotient.inductionOn' z fun x ⟨a, hax⟩ =>\n      by\n      rw [quotient.mk'_eq_mk, ← quotient.mk_smul, quotient.mk_eq_zero] at hax\n      rw [mem_bot, quotient.mk'_eq_mk, quotient.mk_eq_zero]\n      cases' hax with b h\n      exact ⟨b * a, (mul_smul _ _ _).trans h⟩\n#align torsion_eq_bot torsion_eq_bot\n\n",
 "torsion_by_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem torsion_by_univ : torsion_by_set R M Set.univ = «expr⊥» :=\n  by\n  rw [eq_bot_iff, ← torsion_by_one, ← torsion_by_singleton_eq]\n  exact torsion_by_set_le_torsion_by_set_of_subset fun _ _ => trivial\n#align torsion_by_univ torsion_by_univ\n\n",
 "torsion_by_torsion_by_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem torsion_by_torsion_by_eq_top : torsion_by R (torsion_by R M a) a = «expr⊤» :=\n  (is_torsion_by_iff_torsion_by_eq_top a).mp <| torsion_by_is_torsion_by a\n#align torsion_by_torsion_by_eq_top torsion_by_torsion_by_eq_top\n\n",
 "torsion_by_span_singleton_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem torsion_by_span_singleton_eq : torsion_by_set R M («expr ∙ » R a) = torsion_by R M a :=\n  (torsion_by_set_eq_torsion_by_span _).symm.trans <| torsion_by_singleton_eq _\n#align torsion_by_span_singleton_eq torsion_by_span_singleton_eq\n\n",
 "torsion_by_singleton_eq":
 "@[simp]\ntheorem torsion_by_singleton_eq : torsion_by_set R M {a} = torsion_by R M a :=\n  by\n  ext x\n  simp only [mem_torsion_by_set_iff, SetCoe.forall, subtype.coe_mk, Set.mem_singleton_iff, forall_eq,\n    mem_torsion_by_iff]\n#align torsion_by_singleton_eq torsion_by_singleton_eq\n\n",
 "torsion_by_set_torsion_by_set_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem torsion_by_set_torsion_by_set_eq_top : torsion_by_set R (torsion_by_set R M s) s = «expr⊤» :=\n  (is_torsion_by_set_iff_torsion_by_set_eq_top s).mp <| torsion_by_set_is_torsion_by_set s\n#align torsion_by_set_torsion_by_set_eq_top torsion_by_set_torsion_by_set_eq_top\n\n",
 "torsion_by_set_le_torsion_by_set_of_subset":
 "theorem torsion_by_set_le_torsion_by_set_of_subset {s t : set R} (st : s ⊆ t) :\n    torsion_by_set R M t ≤ torsion_by_set R M s :=\n  infₛ_le_infₛ fun _ ⟨a, ha, h⟩ => ⟨a, st ha, h⟩\n#align torsion_by_set_le_torsion_by_set_of_subset torsion_by_set_le_torsion_by_set_of_subset\n\n",
 "torsion_by_set_is_torsion_by_set":
 "theorem torsion_by_set_is_torsion_by_set : is_torsion_by_set R (torsion_by_set R M s) s := fun ⟨x, hx⟩ a =>\n  subtype.ext <| (mem_torsion_by_set_iff _ _).mp hx a\n#align torsion_by_set_is_torsion_by_set torsion_by_set_is_torsion_by_set\n\n",
 "torsion_by_set_is_internal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- If the `p i` are pairwise coprime, a `⨅ i, p i`-torsion module is the internal direct sum of\nits `p i`-torsion submodules.-/\ntheorem torsion_by_set_is_internal {p : ι → ideal R}\n    (hp : (S : set ι).pairwise fun i j => «expr ⊔ » (p i) (p j) = «expr⊤»)\n    (hM :\n      module.is_torsion_by_set R M\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (p i) :\n          ideal R)) :\n    direct_sum.is_internal fun i : S => torsion_by_set R M <| p i :=\n  direct_sum.is_internal_submodule_of_independent_of_supr_eq_top\n    (complete_lattice.independent_iff_sup_indep.mpr <| sup_indep_torsion_by_ideal hp)\n    ((supᵢ_subtype'' ↑S fun i => torsion_by_set R M <| p i).trans <|\n      (supr_torsion_by_ideal_eq_torsion_by_infi hp).trans <|\n        (module.is_torsion_by_set_iff_torsion_by_set_eq_top _).mp hM)\n#align torsion_by_set_is_internal torsion_by_set_is_internal\n\n",
 "torsion_by_set_eq_torsion_by_span":
 "/-- Torsion by a set is torsion by the ideal generated by it. -/\ntheorem torsion_by_set_eq_torsion_by_span : torsion_by_set R M s = torsion_by_set R M (ideal.span s) :=\n  by\n  refine' le_antisymm (fun x hx => _) (torsion_by_set_le_torsion_by_set_of_subset subset_span)\n  rw [mem_torsion_by_set_iff] at hx⊢\n  suffices ideal.span s ≤ ideal.torsion_of R M x by\n    rintro ⟨a, ha⟩\n    exact this ha\n  rw [ideal.span_le]\n  exact fun a ha => hx ⟨a, ha⟩\n#align torsion_by_set_eq_torsion_by_span torsion_by_set_eq_torsion_by_span\n\n",
 "torsion_by_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem torsion_by_one : torsion_by R M 1 = «expr⊥» :=\n  eq_bot_iff.mpr fun _ h => by\n    rw [mem_torsion_by_iff, one_smul] at h\n    exact h\n#align torsion_by_one torsion_by_one\n\n",
 "torsion_by_le_torsion_by_of_dvd":
 "theorem torsion_by_le_torsion_by_of_dvd (a b : R) (dvd : a ∣ b) : torsion_by R M a ≤ torsion_by R M b :=\n  by\n  rw [← torsion_by_span_singleton_eq, ← torsion_by_singleton_eq]\n  apply torsion_by_set_le_torsion_by_set_of_subset\n  rintro c (rfl : c = b); exact ideal.mem_span_singleton.mpr dvd\n#align torsion_by_le_torsion_by_of_dvd torsion_by_le_torsion_by_of_dvd\n\n",
 "torsion_by_is_torsion_by":
 "/-- The `a`-torsion submodule is a `a`-torsion module. -/\ntheorem torsion_by_is_torsion_by : is_torsion_by R (torsion_by R M a) a := fun _ => smul_torsion_by _ _\n#align torsion_by_is_torsion_by torsion_by_is_torsion_by\n\n",
 "torsion_by_is_internal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If the `q i` are pairwise coprime, a `∏ i, q i`-torsion module is the internal direct sum of\nits `q i`-torsion submodules.-/\ntheorem torsion_by_is_internal {q : ι → R} (hq : (S : set ι).pairwise <| «expr on » IsCoprime q)\n    (hM :\n      module.is_torsion_by R M <|\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" S (q i)) :\n    direct_sum.is_internal fun i : S => torsion_by R M <| q i :=\n  by\n  rw [← module.is_torsion_by_span_singleton_iff, ideal.submodule_span_eq, ← ideal.finset_inf_span_singleton _ _ hq,\n    finset.inf_eq_infi] at hM\n  convert\n    torsion_by_set_is_internal (fun i hi j hj ij => (ideal.sup_eq_top_iff_is_coprime (q i) _).mpr <| hq hi hj ij) hM\n  ext : 1; exact (torsion_by_span_singleton_eq _).symm\n#align torsion_by_is_internal torsion_by_is_internal\n\n",
 "torsion_by_eq_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem torsion_by_eq_span_singleton {R : Type _} [CommRing R] (a b : R) (ha : a ∈ non_zero_divisors R) :\n    torsion_by R («expr ⧸ » R («expr ∙ » R (a * b))) a = «expr ∙ » R (mk _ b) :=\n  by\n  ext x; rw [mem_torsion_by_iff, mem_span_singleton]\n  obtain ⟨x, rfl⟩ := mk_surjective x; constructor <;> intro h\n  · rw [← mk_eq_mk, ← quotient.mk_smul, quotient.mk_eq_zero, mem_span_singleton] at h\n    obtain ⟨c, h⟩ := h\n    rw [smul_eq_mul, smul_eq_mul, mul_comm, mul_assoc, mul_cancel_left_mem_non_zero_divisor ha, mul_comm] at h\n    use c\n    rw [← h, ← mk_eq_mk, ← quotient.mk_smul, smul_eq_mul, mk_eq_mk]\n  · obtain ⟨c, h⟩ := h\n    rw [← h, smul_comm, ← mk_eq_mk, ← quotient.mk_smul, (quotient.mk_eq_zero _).mpr <| mem_span_singleton_self _,\n      smul_zero]\n#align torsion_by_eq_span_singleton torsion_by_eq_span_singleton\n\n",
 "torsion'_torsion'_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem torsion'_torsion'_eq_top : torsion' R (torsion' R M S) S = «expr⊤» :=\n  (is_torsion'_iff_torsion'_eq_top S).mp <| torsion'_is_torsion' S\n#align torsion'_torsion'_eq_top torsion'_torsion'_eq_top\n\n",
 "torsion'_is_torsion'":
 "/-- The `S`-torsion submodule is a `S`-torsion module. -/\ntheorem torsion'_is_torsion' : is_torsion' (torsion' R M S) S := fun ⟨x, ⟨a, h⟩⟩ => ⟨a, subtype.ext h⟩\n#align torsion'_is_torsion' torsion'_is_torsion'\n\n",
 "supr_torsion_by_ideal_eq_torsion_by_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem supr_torsion_by_ideal_eq_torsion_by_infi :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (torsion_by_set R M <| p i) =\n      torsion_by_set R M\n        ↑(«expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (p i)) :=\n  by\n  cases' S.eq_empty_or_nonempty with h h\n  · rw [h]\n    convert supᵢ_emptyset\n    convert torsion_by_univ\n    convert top_coe\n    exact infᵢ_emptyset\n  apply le_antisymm\n  · apply supᵢ_le _\n    intro i\n    apply supᵢ_le _\n    intro is\n    apply torsion_by_set_le_torsion_by_set_of_subset\n    exact\n      (infᵢ_le\n            (fun i =>\n              «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (p i))\n            i).trans\n        (infᵢ_le _ is)\n  · intro x hx\n    rw [mem_supr_finset_iff_exists_sum]\n    obtain ⟨μ, hμ⟩ :=\n      (mem_supr_finset_iff_exists_sum _ _).mp\n        ((ideal.eq_top_iff_one _).mp <| (ideal.supr_infi_eq_top_iff_pairwise h _).mpr hp)\n    refine' ⟨fun i => ⟨«expr • » (μ i : R) x, _⟩, _⟩\n    · rw [mem_torsion_by_set_iff] at hx⊢\n      rintro ⟨a, ha⟩\n      rw [smul_smul]\n      suffices :\n        a * μ i ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (p i)\n      exact hx ⟨_, this⟩\n      rw [mem_infi]\n      intro j\n      rw [mem_infi]\n      intro hj\n      by_cases ij : j = i\n      · rw [ij]\n        exact ideal.mul_mem_right _ _ ha\n      · have := coe_mem (μ i)\n        simp only [mem_infi] at this\n        exact ideal.mul_mem_left _ _ (this j hj ij)\n    · simp_rw [coe_mk]\n      rw [← finset.sum_smul, hμ, one_smul]\n#align supr_torsion_by_ideal_eq_torsion_by_infi supr_torsion_by_ideal_eq_torsion_by_infi\n\n",
 "supr_torsion_by_eq_torsion_by_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem supr_torsion_by_eq_torsion_by_prod :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (torsion_by R M <| q i) =\n      torsion_by R M\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" S (q i)) :=\n  by\n  rw [← torsion_by_span_singleton_eq, ideal.submodule_span_eq, ← ideal.finset_inf_span_singleton _ _ hq,\n    finset.inf_eq_infi, ← supr_torsion_by_ideal_eq_torsion_by_infi]\n  · congr\n    ext : 1\n    congr\n    ext : 1\n    exact (torsion_by_span_singleton_eq _).symm\n  · exact fun i hi j hj ij => (ideal.sup_eq_top_iff_is_coprime _ _).mpr (hq hi hj ij)\n#align supr_torsion_by_eq_torsion_by_prod supr_torsion_by_eq_torsion_by_prod\n\n",
 "sup_indep_torsion_by_ideal":
 "theorem sup_indep_torsion_by_ideal : S.sup_indep fun i => torsion_by_set R M <| p i := fun T hT i hi hiT =>\n  by\n  rw [disjoint_iff, finset.sup_eq_supr,\n    supr_torsion_by_ideal_eq_torsion_by_infi fun i hi j hj ij => hp (hT hi) (hT hj) ij]\n  have := @GaloisConnection.u_inf _ _ (OrderDual.toDual _) (OrderDual.toDual _) _ _ _ _ (torsion_gc R M)\n  dsimp at this⊢\n  rw [← this, ideal.sup_infi_eq_top, top_coe, torsion_by_univ]\n  intro j hj; apply hp hi (hT hj); rintro rfl; exact hiT hj\n#align sup_indep_torsion_by_ideal sup_indep_torsion_by_ideal\n\n",
 "sup_indep_torsion_by":
 "theorem sup_indep_torsion_by : S.sup_indep fun i => torsion_by R M <| q i :=\n  by\n  convert sup_indep_torsion_by_ideal fun i hi j hj ij => (ideal.sup_eq_top_iff_is_coprime (q i) _).mpr <| hq hi hj ij\n  ext : 1; exact (torsion_by_span_singleton_eq _).symm\n#align sup_indep_torsion_by sup_indep_torsion_by\n\n",
 "smul_torsion_by":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_torsion_by (x : torsion_by R M a) : «expr • » a x = 0 :=\n  subtype.ext x.prop\n#align smul_torsion_by smul_torsion_by\n\n",
 "smul_coe_torsion_by":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_coe_torsion_by (x : torsion_by R M a) : «expr • » a (x : M) = 0 :=\n  x.prop\n#align smul_coe_torsion_by smul_coe_torsion_by\n\n",
 "quot_torsion_of_equiv_span_singleton_apply_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem quot_torsion_of_equiv_span_singleton_apply_mk (x : M) (a : R) :\n    quot_torsion_of_equiv_span_singleton R M x (submodule.quotient.mk a) =\n      «expr • » a ⟨x, submodule.mem_span_singleton_self x⟩ :=\n  rfl\n#align quot_torsion_of_equiv_span_singleton_apply_mk quot_torsion_of_equiv_span_singleton_apply_mk\n\n",
 "pow_p_order_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem pow_p_order_smul {p : R} (hM : is_torsion' M <| submonoid.powers p) (x : M)\n    [∀ n : ℕ, decidable («expr • » (p ^ n) x = 0)] : «expr • » (p ^ p_order hM x) x = 0 :=\n  nat.find_spec <| (is_torsion'_powers_iff p).mp hM x\n#align pow_p_order_smul pow_p_order_smul\n\n",
 "no_zero_smul_divisors_iff_torsion_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A module over a domain has `no_zero_smul_divisors` iff its torsion submodule is trivial. -/\ntheorem no_zero_smul_divisors_iff_torsion_eq_bot : NoZeroSMulDivisors R M ↔ torsion R M = «expr⊥» :=\n  by\n  constructor <;> intro h\n  · haveI : NoZeroSMulDivisors R M := h\n    rw [eq_bot_iff]\n    rintro x ⟨a, hax⟩\n    change «expr • » (a : R) x = 0 at hax\n    cases' eq_zero_or_eq_zero_of_smul_eq_zero hax with h0 h0\n    · exfalso\n      exact non_zero_divisors.coe_ne_zero a h0\n    · exact h0\n  ·\n    exact\n      {\n        eq_zero_or_eq_zero_of_smul_eq_zero := fun a x hax =>\n          by\n          by_cases ha : a = 0\n          · left\n            exact ha\n          · right\n            rw [← mem_bot _, ← h]\n            exact ⟨⟨a, mem_non_zero_divisors_of_ne_zero ha⟩, hax⟩ }\n#align no_zero_smul_divisors_iff_torsion_eq_bot no_zero_smul_divisors_iff_torsion_eq_bot\n\n",
 "mk_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem torsion_by.mk_smul (a b : R) (x : torsion_by R M a) :\n    «expr • » (ideal.quotient.mk («expr ∙ » R a) b) x = «expr • » b x :=\n  rfl\n#align torsion_by.mk_smul torsion_by.mk_smul\n\n",
 "mem_torsion_of_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mem_torsion_of_iff (x : M) (a : R) : a ∈ torsion_of R M x ↔ «expr • » a x = 0 :=\n  iff.rfl\n#align mem_torsion_of_iff mem_torsion_of_iff\n\n",
 "mem_torsion_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mem_torsion_iff (x : M) : x ∈ torsion R M ↔ ∃ a : non_zero_divisors R, «expr • » a x = 0 :=\n  iff.rfl\n#align mem_torsion_iff mem_torsion_iff\n\n",
 "mem_torsion_by_set_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mem_torsion_by_set_iff (x : M) : x ∈ torsion_by_set R M s ↔ ∀ a : s, «expr • » (a : R) x = 0 :=\n  by\n  refine' ⟨fun h ⟨a, ha⟩ => mem_Inf.mp h _ (Set.mem_image_of_mem _ ha), fun h => mem_Inf.mpr _⟩\n  rintro _ ⟨a, ha, rfl⟩; exact h ⟨a, ha⟩\n#align mem_torsion_by_set_iff mem_torsion_by_set_iff\n\n",
 "mem_torsion_by_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mem_torsion_by_iff (x : M) : x ∈ torsion_by R M a ↔ «expr • » a x = 0 :=\n  iff.rfl\n#align mem_torsion_by_iff mem_torsion_by_iff\n\n",
 "mem_torsion'_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mem_torsion'_iff (x : M) : x ∈ torsion' R M S ↔ ∃ a : S, «expr • » a x = 0 :=\n  iff.rfl\n#align mem_torsion'_iff mem_torsion'_iff\n\n",
 "linear_independent'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- See also `complete_lattice.independent.linear_independent` which provides the same conclusion\nbut requires the stronger hypothesis `no_zero_smul_divisors R M`. -/\ntheorem complete_lattice.independent.linear_independent' {ι R M : Type _} {v : ι → M} [Ring R] [add_comm_group M]\n    [Module R M] (hv : complete_lattice.independent fun i => «expr ∙ » R (v i))\n    (h_ne_zero : ∀ i, ideal.torsion_of R M (v i) = «expr⊥») : linear_independent R v :=\n  by\n  refine' linear_independent_iff_not_smul_mem_span.mpr fun i r hi => _\n  replace hv := complete_lattice.independent_def.mp hv i\n  simp only [supᵢ_subtype', ← submodule.span_range_eq_supr, disjoint_iff] at hv\n  have : «expr • » r (v i) ∈ «expr⊥» := by\n    rw [← hv, submodule.mem_inf]\n    refine' ⟨submodule.mem_span_singleton.mpr ⟨r, rfl⟩, _⟩\n    convert hi\n    ext\n    simp\n  rw [← submodule.mem_bot R, ← h_ne_zero i]\n  simpa using this\n#align complete_lattice.independent.linear_independent' complete_lattice.independent.linear_independent'\n\n",
 "is_torsion_iff_is_torsion_nat":
 "theorem is_torsion_iff_is_torsion_nat [add_comm_monoid M] : add_monoid.is_torsion M ↔ module.is_torsion ℕ M :=\n  by\n  refine' ⟨fun h x => _, fun h x => _⟩\n  · obtain ⟨n, h0, hn⟩ := (is_of_fin_add_order_iff_nsmul_eq_zero x).mp (h x)\n    exact ⟨⟨n, mem_non_zero_divisors_of_ne_zero <| ne_of_gt h0⟩, hn⟩\n  · rw [is_of_fin_add_order_iff_nsmul_eq_zero]\n    obtain ⟨n, hn⟩ := @h x\n    refine' ⟨n, nat.pos_of_ne_zero (non_zero_divisors.coe_ne_zero _), hn⟩\n#align is_torsion_iff_is_torsion_nat is_torsion_iff_is_torsion_nat\n\n",
 "is_torsion_iff_is_torsion_int":
 "theorem is_torsion_iff_is_torsion_int [add_comm_group M] : add_monoid.is_torsion M ↔ module.is_torsion ℤ M :=\n  by\n  refine' ⟨fun h x => _, fun h x => _⟩\n  · obtain ⟨n, h0, hn⟩ := (is_of_fin_add_order_iff_nsmul_eq_zero x).mp (h x)\n    exact ⟨⟨n, mem_non_zero_divisors_of_ne_zero <| ne_of_gt <| int.coe_nat_pos.mpr h0⟩, (coe_nat_zsmul _ _).trans hn⟩\n  · rw [is_of_fin_add_order_iff_nsmul_eq_zero]\n    obtain ⟨n, hn⟩ := @h x\n    exact exists_nsmul_eq_zero_of_zsmul_eq_zero (non_zero_divisors.coe_ne_zero n) hn\n#align is_torsion_iff_is_torsion_int is_torsion_iff_is_torsion_int\n\n",
 "is_torsion_by_span_singleton_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem is_torsion_by_span_singleton_iff : is_torsion_by_set R M («expr ∙ » R a) ↔ is_torsion_by R M a :=\n  (is_torsion_by_set_iff_is_torsion_by_span _).symm.trans <| is_torsion_by_singleton_iff _\n#align is_torsion_by_span_singleton_iff is_torsion_by_span_singleton_iff\n\n",
 "is_torsion_by_singleton_iff":
 "@[simp]\ntheorem is_torsion_by_singleton_iff : is_torsion_by_set R M {a} ↔ is_torsion_by R M a :=\n  by\n  refine' ⟨fun h x => @h _ ⟨_, Set.mem_singleton _⟩, fun h x => _⟩\n  rintro ⟨b, rfl : b = a⟩; exact @h _\n#align is_torsion_by_singleton_iff is_torsion_by_singleton_iff\n\n",
 "is_torsion_by_set_iff_torsion_by_set_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_torsion_by_set_iff_torsion_by_set_eq_top :\n    is_torsion_by_set R M s ↔ submodule.torsion_by_set R M s = «expr⊤» :=\n  ⟨fun h => eq_top_iff.mpr fun _ _ => (mem_torsion_by_set_iff _ _).mpr <| @h _, fun h x =>\n    by\n    rw [← mem_torsion_by_set_iff, h]\n    trivial⟩\n#align is_torsion_by_set_iff_torsion_by_set_eq_top is_torsion_by_set_iff_torsion_by_set_eq_top\n\n",
 "is_torsion_by_set_iff_is_torsion_by_span":
 "theorem is_torsion_by_set_iff_is_torsion_by_span : is_torsion_by_set R M s ↔ is_torsion_by_set R M (ideal.span s) := by\n  rw [is_torsion_by_set_iff_torsion_by_set_eq_top, is_torsion_by_set_iff_torsion_by_set_eq_top,\n    torsion_by_set_eq_torsion_by_span]\n#align is_torsion_by_set_iff_is_torsion_by_span is_torsion_by_set_iff_is_torsion_by_span\n\n",
 "is_torsion_by_iff_torsion_by_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A `a`-torsion module is a module whose `a`-torsion submodule is the full space. -/\ntheorem is_torsion_by_iff_torsion_by_eq_top : is_torsion_by R M a ↔ torsion_by R M a = «expr⊤» := by\n  rw [← torsion_by_singleton_eq, ← is_torsion_by_singleton_iff, is_torsion_by_set_iff_torsion_by_set_eq_top]\n#align is_torsion_by_iff_torsion_by_eq_top is_torsion_by_iff_torsion_by_eq_top\n\n",
 "is_torsion_by_ideal_of_finite_of_is_torsion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `non_zero_divisors -/\ntheorem is_torsion_by_ideal_of_finite_of_is_torsion [module.finite R M] (hM : module.is_torsion R M) :\n    ∃ I : ideal R, (I : set R) ∩ non_zero_divisors R ≠ ∅ ∧ module.is_torsion_by_set R M I :=\n  by\n  cases' (module.finite_def.mp infer_instance : («expr⊤» : submodule R M).fg) with S h\n  refine'\n    ⟨finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" S\n        (ideal.torsion_of R M x),\n      _, _⟩\n  · refine'\n      set.nonempty.ne_empty\n        ⟨_, _,\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" S\n                (@hM x).some :\n              non_zero_divisors R).2⟩\n    rw [subtype.val_eq_coe, submonoid.coe_finset_prod]\n    apply ideal.prod_mem_prod\n    exact fun x _ => (@hM x).some_spec\n  · rw [module.is_torsion_by_set_iff_torsion_by_set_eq_top, eq_top_iff, ← h, span_le]\n    intro x hx\n    apply torsion_by_set_le_torsion_by_set_of_subset\n    · apply ideal.le_of_dvd\n      exact finset.dvd_prod_of_mem _ hx\n    · rw [mem_torsion_by_set_iff]\n      rintro ⟨a, ha⟩\n      exact ha\n#align is_torsion_by_ideal_of_finite_of_is_torsion is_torsion_by_ideal_of_finite_of_is_torsion\n\n",
 "is_torsion'_powers_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_torsion'_powers_iff (p : R) :\n    is_torsion' M (submonoid.powers p) ↔ ∀ x : M, ∃ n : ℕ, «expr • » (p ^ n) x = 0 :=\n  ⟨fun h x =>\n    let ⟨⟨a, ⟨n, rfl⟩⟩, hx⟩ := @h x\n    ⟨n, hx⟩,\n    fun h x =>\n    let ⟨n, hn⟩ := h x\n    ⟨⟨_, ⟨n, rfl⟩⟩, hn⟩⟩\n#align is_torsion'_powers_iff is_torsion'_powers_iff\n\n",
 "is_torsion'_iff_torsion'_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A `S`-torsion module is a module whose `S`-torsion submodule is the full space. -/\ntheorem is_torsion'_iff_torsion'_eq_top : is_torsion' M S ↔ torsion' R M S = «expr⊤» :=\n  ⟨fun h => eq_top_iff.mpr fun _ _ => @h _, fun h x =>\n    by\n    rw [← @mem_torsion'_iff R, h]\n    trivial⟩\n#align is_torsion'_iff_torsion'_eq_top is_torsion'_iff_torsion'_eq_top\n\n",
 "exists_is_torsion_by":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem exists_is_torsion_by {p : R} (hM : is_torsion' M <| submonoid.powers p) (d : ℕ) (hd : d ≠ 0) (s : fin d → M)\n    (hs : span R (Set.range s) = «expr⊤») : ∃ j : fin d, module.is_torsion_by R M (p ^ p_order hM (s j)) :=\n  by\n  let oj := List.argmax (fun i => p_order hM <| s i) (List.finRange d)\n  have hoj : oj.is_some :=\n    option.ne_none_iff_is_some.mp fun eq_none => hd <| list.fin_range_eq_nil.mp <| list.argmax_eq_none.mp eq_none\n  use option.get hoj\n  rw [is_torsion_by_iff_torsion_by_eq_top, eq_top_iff, ← hs, submodule.span_le, Set.range_subset_iff]\n  intro i; change «expr • » _ _ = _\n  have : p_order hM (s i) ≤ p_order hM (s <| option.get hoj) :=\n    List.le_of_mem_argmax (List.mem_finRange i) (option.get_mem hoj)\n  rw [← nat.sub_add_cancel this, pow_add, mul_smul, pow_p_order_smul, smul_zero]\n#align exists_is_torsion_by exists_is_torsion_by\n\n",
 "coe_torsion_eq_annihilator_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem coe_torsion_eq_annihilator_ne_bot : (torsion R M : set M) = { x : M | («expr ∙ » R x).annihilator ≠ «expr⊥» } :=\n  by\n  ext x; simp_rw [submodule.ne_bot_iff, mem_annihilator, mem_span_singleton]\n  exact\n    ⟨fun ⟨a, hax⟩ =>\n      ⟨a, fun _ ⟨b, hb⟩ => by rw [← hb, smul_comm, ← Submonoid.smul_def, hax, smul_zero],\n        non_zero_divisors.coe_ne_zero _⟩,\n      fun ⟨a, hax, ha⟩ => ⟨⟨_, mem_non_zero_divisors_of_ne_zero ha⟩, hax x ⟨1, one_smul _ _⟩⟩⟩\n#align coe_torsion_eq_annihilator_ne_bot coe_torsion_eq_annihilator_ne_bot\n\n"}