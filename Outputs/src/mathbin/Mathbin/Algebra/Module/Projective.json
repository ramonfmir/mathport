{"projective_of_lifting_property'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n--This is in a different section because special universe restrictions are required.\n/-- A module which satisfies the universal property is projective. Note that the universe variables\nin `huniv` are somewhat restricted. -/\ntheorem projective_of_lifting_property' {R : Type u} [Semiring R] {P : Type max u v} [AddCommMonoid P] [Module R P]\n    -- If for all surjections of `R`-modules `M →ₗ N`, all maps `P →ₗ N` lift to `P →ₗ M`,\n    (huniv :\n      ∀ {M : Type max v u} {N : Type max u v} [AddCommMonoid M] [AddCommMonoid N],\n        ∀ [Module R M] [Module R N],\n          ∀ (f : «expr →ₗ[ ] » M R N) (g : «expr →ₗ[ ] » P R N),\n            function.surjective f → ∃ h : «expr →ₗ[ ] » P R M, f.comp h = g) :-- then `P` is projective.\n      Projective\n      R P :=\n  by\n  -- let `s` be the universal map `(P →₀ R) →ₗ P` coming from the identity map `P →ₗ P`.\n  obtain ⟨s, hs⟩ : ∃ s : «expr →ₗ[ ] » P R («expr →₀ » P R), (Finsupp.total P P R id).comp s = LinearMap.id :=\n    huniv (Finsupp.total P P R (id : P → P)) (LinearMap.id : «expr →ₗ[ ] » P R P) _\n  -- This `s` works.\n  · use s\n    rwa [LinearMap.ext_iff] at hs\n  · intro p\n    use Finsupp.single p 1\n    simp\n#align projective_of_lifting_property' projective_of_lifting_property'\n\n",
 "projective_of_lifting_property":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- A variant of `of_lifting_property'` when we're working over a `[ring R]`,\nwhich only requires quantifying over modules with an `add_comm_group` instance. -/\ntheorem projective_of_lifting_property {R : Type u} [Ring R] {P : Type max u v} [AddCommGroup P] [Module R P]\n    -- If for all surjections of `R`-modules `M →ₗ N`, all maps `P →ₗ N` lift to `P →ₗ M`,\n    (huniv :\n      ∀ {M : Type max v u} {N : Type max u v} [AddCommGroup M] [AddCommGroup N],\n        ∀ [Module R M] [Module R N],\n          ∀ (f : «expr →ₗ[ ] » M R N) (g : «expr →ₗ[ ] » P R N),\n            function.surjective f → ∃ h : «expr →ₗ[ ] » P R M, f.comp h = g) :-- then `P` is projective.\n      Projective\n      R P :=\n  by\n  -- We could try and prove this *using* `of_lifting_property`,\n  -- but this quickly leads to typeclass hell,\n  -- so we just prove it over again.\n  -- let `s` be the universal map `(P →₀ R) →ₗ P` coming from the identity map `P →ₗ P`.\n  obtain ⟨s, hs⟩ : ∃ s : «expr →ₗ[ ] » P R («expr →₀ » P R), (Finsupp.total P P R id).comp s = LinearMap.id :=\n    huniv (Finsupp.total P P R (id : P → P)) (LinearMap.id : «expr →ₗ[ ] » P R P) _\n  -- This `s` works.\n  · use s\n    rwa [LinearMap.ext_iff] at hs\n  · intro p\n    use Finsupp.single p 1\n    simp\n#align projective_of_lifting_property projective_of_lifting_property\n\n",
 "projective_of_basis":
 "/-- Free modules are projective. -/\ntheorem projective_of_basis {ι : Type _} (b : Basis ι R P) : Projective R P :=\n  by\n  -- need P →ₗ (P →₀ R) for definition of projective.\n  -- get it from `ι → (P →₀ R)` coming from `b`.\n  use b.constr ℕ fun i => Finsupp.single (b i) (1 : R)\n  intro m\n  simp only [b.constr_apply, mul_one, id.def, Finsupp.smul_single', Finsupp.total_single, LinearMap.map_finsupp_sum]\n  exact b.total_repr m\n#align projective_of_basis projective_of_basis\n\n",
 "projective_lifting_property":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- A projective R-module has the property that maps from it lift along surjections. -/\ntheorem projective_lifting_property [h : Projective R P] (f : «expr →ₗ[ ] » M R N) (g : «expr →ₗ[ ] » P R N)\n    (hf : function.surjective f) : ∃ h : «expr →ₗ[ ] » P R M, f.comp h = g :=\n  by\n  /-\n    Here's the first step of the proof.\n    Recall that `X →₀ R` is Lean's way of talking about the free `R`-module\n    on a type `X`. The universal property `finsupp.total` says that to a map\n    `X → N` from a type to an `R`-module, we get an associated R-module map\n    `(X →₀ R) →ₗ N`. Apply this to a (noncomputable) map `P → M` coming from the map\n    `P →ₗ N` and a random splitting of the surjection `M →ₗ N`, and we get\n    a map `φ : (P →₀ R) →ₗ M`.\n    -/\n  let φ : «expr →ₗ[ ] » («expr →₀ » P R) R M := Finsupp.total _ _ _ fun p => Function.surjInv hf (g p)\n  -- By projectivity we have a map `P →ₗ (P →₀ R)`;\n  cases' h.out with s hs\n  -- Compose to get `P →ₗ M`. This works.\n  use φ.comp s\n  ext p\n  conv_rhs => rw [← hs p]\n  simp [φ, Finsupp.total_apply, Function.surjInv_eq hf]\n#align projective_lifting_property projective_lifting_property\n\n",
 "projective_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\ntheorem projective_def' :\n    Projective R P ↔ ∃ s : «expr →ₗ[ ] » P R («expr →₀ » P R), «expr ∘ₗ » (Finsupp.total P P R id) s = id := by\n  simp_rw [projective_def, FunLike.ext_iff, function.left_inverse, coe_comp, id_coe, id.def]\n#align projective_def' projective_def'\n\n",
 "projective_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-\nCopyright (c) 2021 Kevin Buzzard. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Antoine Labelle\n-/\n/- The actual implementation we choose: `P` is projective if the natural surjection\n   from the free `R`-module on `P` to `P` splits. -/\ntheorem projective_def :\n    Projective R P ↔ ∃ s : «expr →ₗ[ ] » P R («expr →₀ » P R), function.left_inverse (Finsupp.total P P R id) s :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n#align projective_def projective_def\n\n"}