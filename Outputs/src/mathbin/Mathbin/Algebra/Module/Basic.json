{"zsmul_eq_smul_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print zsmul_eq_smul_cast /-\n/-- `zsmul` is equal to any other module structure via a cast. -/\ntheorem zsmul_eq_smul_cast (n : ℤ) (b : M) : «expr • » n b = «expr • » (n : R) b :=\n  have : (smulAddHom ℤ M).flip b = ((smulAddHom R M).flip b).comp (Int.castAddHom R) :=\n    by\n    ext\n    simp\n  AddMonoidHom.congr_fun this n\n#align zsmul_eq_smul_cast zsmul_eq_smul_cast\n-/\n\n",
 "two_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print two_smul' /-\ntheorem two_smul' : «expr • » (2 : R) x = bit0 x :=\n  two_smul R x\n#align two_smul' two_smul'\n-/\n\n",
 "two_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print two_smul /-\ntheorem two_smul : «expr • » (2 : R) x = x + x := by rw [bit0, add_smul, one_smul]\n#align two_smul two_smul\n-/\n\n",
 "two_nsmul_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print two_nsmul_eq_zero /-\n@[simp]\ntheorem two_nsmul_eq_zero {v : M} : «expr • » 2 v = 0 ↔ v = 0 :=\n  by\n  haveI := Nat.noZeroSMulDivisors R M\n  simp [smul_eq_zero]\n#align two_nsmul_eq_zero two_nsmul_eq_zero\n-/\n\n",
 "subsingleton":
 "#print Module.subsingleton /-\n/-- A module over a `subsingleton` semiring is a `subsingleton`. We cannot register this\nas an instance because Lean has no way to guess `R`. -/\nprotected theorem Module.subsingleton (R M : Type _) [Semiring R] [subsingleton R] [add_comm_monoid M] [Module R M] :\n    subsingleton M :=\n  mul_action_with_zero.subsingleton R M\n#align module.subsingleton Module.subsingleton\n-/\n\n",
 "sub_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print sub_smul /-\ntheorem sub_smul (r s : R) (y : M) : «expr • » (r - s) y = «expr • » r y - «expr • » s y := by\n  simp [add_smul, sub_eq_add_neg]\n#align sub_smul sub_smul\n-/\n\n",
 "smul_right_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n#print smul_right_injective /-\n-- `R` can still be a semiring here\ntheorem smul_right_injective [NoZeroSMulDivisors R M] {c : R} (hc : c ≠ 0) :\n    function.injective ((«expr • » · ·) c : M → M) :=\n  (injective_iff_map_eq_zero (smulAddHom R M c)).2 fun a ha => (smul_eq_zero.mp ha).resolve_left hc\n#align smul_right_injective smul_right_injective\n-/\n\n",
 "smul_right_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_right_inj /-\ntheorem smul_right_inj [NoZeroSMulDivisors R M] {c : R} (hc : c ≠ 0) {x y : M} :\n    «expr • » c x = «expr • » c y ↔ x = y :=\n  (smul_right_injective M hc).eq_iff\n#align smul_right_inj smul_right_inj\n-/\n\n",
 "smul_one_eq_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Int.smul_one_eq_coe /-\n@[simp]\ntheorem Int.smul_one_eq_coe {R : Type _} [Ring R] (m : ℤ) : «expr • » m (1 : R) = ↑m := by rw [zsmul_eq_mul, mul_one]\n#align int.smul_one_eq_coe Int.smul_one_eq_coe\n-/\n\n",
 "smul_ne_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_ne_zero_iff /-\ntheorem smul_ne_zero_iff : «expr • » c x ≠ 0 ↔ c ≠ 0 ∧ x ≠ 0 := by rw [ne.def, smul_eq_zero, not_or]\n#align smul_ne_zero_iff smul_ne_zero_iff\n-/\n\n",
 "smul_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_ne_zero /-\n-- See note [lower instance priority]\ntheorem smul_ne_zero [Zero R] [Zero M] [SMul R M] [NoZeroSMulDivisors R M] {c : R} {x : M} (hc : c ≠ 0) (hx : x ≠ 0) :\n    «expr • » c x ≠ 0 := fun h => (eq_zero_or_eq_zero_of_smul_eq_zero h).elim hc hx\n#align smul_ne_zero smul_ne_zero\n-/\n\n",
 "smul_left_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_left_injective /-\ntheorem smul_left_injective {x : M} (hx : x ≠ 0) : function.injective fun c : R => «expr • » c x := fun c d h =>\n  sub_eq_zero.mp\n    ((smul_eq_zero.mp\n          (calc\n            «expr • » (c - d) x = «expr • » c x - «expr • » d x := sub_smul c d x\n            _ = 0 := sub_eq_zero.mpr h\n            )).resolve_right\n      hx)\n#align smul_left_injective smul_left_injective\n-/\n\n",
 "smul_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_eq_zero /-\n@[simp]\ntheorem smul_eq_zero : «expr • » c x = 0 ↔ c = 0 ∨ x = 0 :=\n  ⟨eq_zero_or_eq_zero_of_smul_eq_zero, fun h => h.elim (fun h => h.symm ▸ zero_smul R x) fun h => h.symm ▸ smul_zero c⟩\n#align smul_eq_zero smul_eq_zero\n-/\n\n",
 "smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print RingHom.smul_def /-\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n@[simp]\nprotected theorem RingHom.smul_def [Semiring R] (f : «expr →+* » R R) (a : R) : «expr • » f a = f a :=\n  rfl\n#align ring_hom.smul_def RingHom.smul_def\n-/\n\n",
 "smul_add_one_sub_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_add_one_sub_smul /-\n@[simp]\ntheorem smul_add_one_sub_smul {R : Type _} [Ring R] [Module R M] {r : R} {m : M} :\n    «expr • » r m + «expr • » (1 - r) m = m := by rw [← add_smul, add_sub_cancel'_right, one_smul]\n#align smul_add_one_sub_smul smul_add_one_sub_smul\n-/\n\n",
 "smul_add_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_add_hom_apply /-\n@[simp]\ntheorem smul_add_hom_apply (r : R) (x : M) : smulAddHom R M r x = «expr • » r x :=\n  rfl\n#align smul_add_hom_apply smul_add_hom_apply\n-/\n\n",
 "self_ne_neg":
 "#print self_ne_neg /-\ntheorem self_ne_neg {v : M} : v ≠ -v ↔ v ≠ 0 :=\n  (self_eq_neg R M).not\n#align self_ne_neg self_ne_neg\n-/\n\n",
 "self_eq_neg":
 "#print self_eq_neg /-\ntheorem self_eq_neg {v : M} : v = -v ↔ v = 0 := by rw [← two_nsmul_eq_zero R M, two_smul, add_eq_zero_iff_eq_neg]\n#align self_eq_neg self_eq_neg\n-/\n\n",
 "rat_cast_smul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print rat_cast_smul_eq /-\n/-- If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\nagree on rational numbers in `R` and `S`. -/\ntheorem rat_cast_smul_eq {E : Type _} (R S : Type _) [add_comm_group E] [DivisionRing R] [DivisionRing S] [Module R E]\n    [Module S E] (r : exprℚ) (x : E) : «expr • » (r : R) x = «expr • » (r : S) x :=\n  map_rat_cast_smul (AddMonoidHom.id E) R S r x\n#align rat_cast_smul_eq rat_cast_smul_eq\n-/\n\n",
 "of_module":
 "#print CharZero.of_module /-\n/-- If `M` is an `R`-module with one and `M` has characteristic zero, then `R` has characteristic\nzero as well. Usually `M` is an `R`-algebra. -/\ntheorem CharZero.of_module (M) [AddCommMonoidWithOne M] [CharZero M] [Module R M] : CharZero R :=\n  by\n  refine' ⟨fun m n h => @Nat.cast_injective M _ _ _ _ _⟩\n  rw [← nsmul_one, ← nsmul_one, nsmul_eq_smul_cast R m (1 : M), nsmul_eq_smul_cast R n (1 : M), h]\n#align char_zero.of_module CharZero.of_module\n-/\n\n",
 "nsmul_eq_smul_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print nsmul_eq_smul_cast /-\n/-- `nsmul` is equal to any other module structure via a cast. -/\ntheorem nsmul_eq_smul_cast (n : ℕ) (b : M) : «expr • » n b = «expr • » (n : R) b :=\n  by\n  induction' n with n ih\n  · rw [Nat.cast_zero, zero_smul, zero_smul]\n  · rw [nat.succ_eq_add_one, Nat.cast_succ, add_smul, add_smul, one_smul, ih, one_smul]\n#align nsmul_eq_smul_cast nsmul_eq_smul_cast\n-/\n\n",
 "nontrivial":
 "#print Module.nontrivial /-\n/-- A semiring is `nontrivial` provided that there exists a nontrivial module over this semiring. -/\nprotected theorem Module.nontrivial (R M : Type _) [Semiring R] [nontrivial M] [add_comm_monoid M] [Module R M] :\n    nontrivial R :=\n  mul_action_with_zero.nontrivial R M\n#align module.nontrivial Module.nontrivial\n-/\n\n",
 "noZeroSMulDivisors":
 "#print Nat.noZeroSMulDivisors /-\ntheorem Nat.noZeroSMulDivisors : NoZeroSMulDivisors ℕ M :=\n  ⟨by\n    intro c x\n    rw [nsmul_eq_smul_cast R, smul_eq_zero]\n    simp⟩\n#align nat.no_zero_smul_divisors Nat.noZeroSMulDivisors\n-/\n\n",
 "neg_smul_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print neg_smul_neg /-\n@[simp]\ntheorem neg_smul_neg : «expr • » (-r) (-x) = «expr • » r x := by rw [neg_smul, smul_neg, neg_neg]\n#align neg_smul_neg neg_smul_neg\n-/\n\n",
 "neg_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Units.neg_smul /-\n@[simp]\ntheorem Units.neg_smul (u : «expr ˣ» R) (x : M) : «expr • » (-u) x = -«expr • » u x := by\n  rw [Units.smul_def, Units.val_neg, neg_smul, Units.smul_def]\n#align units.neg_smul Units.neg_smul\n-/\n\n",
 "neg_one_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print neg_one_smul /-\ntheorem neg_one_smul (x : M) : «expr • » (-1 : R) x = -x := by simp\n#align neg_one_smul neg_one_smul\n-/\n\n",
 "neg_ne_self":
 "#print neg_ne_self /-\ntheorem neg_ne_self {v : M} : -v ≠ v ↔ v ≠ 0 :=\n  (neg_eq_self R M).not\n#align neg_ne_self neg_ne_self\n-/\n\n",
 "neg_eq_self":
 "#print neg_eq_self /-\ntheorem neg_eq_self {v : M} : -v = v ↔ v = 0 := by rw [eq_comm, self_eq_neg R M]\n#align neg_eq_self neg_eq_self\n-/\n\n",
 "nat_smul_eq_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print nat_smul_eq_nsmul /-\n/-- Convert back any exotic `ℕ`-smul to the canonical instance. This should not be needed since in\nmathlib all `add_comm_monoid`s should normally have exactly one `ℕ`-module structure by design.\n-/\ntheorem nat_smul_eq_nsmul (h : Module ℕ M) (n : ℕ) (x : M) : @has_smul.smul ℕ M h.to_has_smul n x = «expr • » n x := by\n  rw [nsmul_eq_smul_cast ℕ n x, nat.cast_id]\n#align nat_smul_eq_nsmul nat_smul_eq_nsmul\n-/\n\n",
 "nat_cast_def":
 "#print AddMonoid.End.nat_cast_def /-\n/-\nCopyright (c) 2015 Nathaniel Thomas. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Nathaniel Thomas, Jeremy Avigad, Johannes Hölzl, Mario Carneiro\n-/\n-- see Note [lower instance priority]\ntheorem AddMonoid.End.nat_cast_def (n : ℕ) : (↑n : AddMonoid.End M) = DistribMulAction.toAddMonoidEnd ℕ M n :=\n  rfl\n#align add_monoid.End.nat_cast_def AddMonoid.End.nat_cast_def\n-/\n\n",
 "map_rat_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print map_rat_smul /-\ntheorem map_rat_smul [add_comm_group M] [add_comm_group M₂] [Module (exprℚ) M] [Module (exprℚ) M₂] {F : Type _}\n    [AddMonoidHomClass F M M₂] (f : F) (c : exprℚ) (x : M) : f («expr • » c x) = «expr • » c (f x) :=\n  Rat.cast_id c ▸ map_rat_cast_smul f (exprℚ) (exprℚ) c x\n#align map_rat_smul map_rat_smul\n-/\n\n",
 "map_rat_cast_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print map_rat_cast_smul /-\ntheorem map_rat_cast_smul [add_comm_group M] [add_comm_group M₂] {F : Type _} [AddMonoidHomClass F M M₂] (f : F)\n    (R S : Type _) [DivisionRing R] [DivisionRing S] [Module R M] [Module S M₂] (c : exprℚ) (x : M) :\n    f («expr • » (c : R) x) = «expr • » (c : S) (f x) := by\n  rw [Rat.cast_def, Rat.cast_def, div_eq_mul_inv, div_eq_mul_inv, mul_smul, mul_smul, map_int_cast_smul f R S,\n    map_inv_nat_cast_smul f R S]\n#align map_rat_cast_smul map_rat_cast_smul\n-/\n\n",
 "map_nat_cast_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print map_nat_cast_smul /-\ntheorem map_nat_cast_smul [add_comm_monoid M] [add_comm_monoid M₂] {F : Type _} [AddMonoidHomClass F M M₂] (f : F)\n    (R S : Type _) [Semiring R] [Semiring S] [Module R M] [Module S M₂] (x : ℕ) (a : M) :\n    f («expr • » (x : R) a) = «expr • » (x : S) (f a) := by simp only [← nsmul_eq_smul_cast, map_nsmul]\n#align map_nat_cast_smul map_nat_cast_smul\n-/\n\n",
 "map_inv_nat_cast_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print map_inv_nat_cast_smul /-\ntheorem map_inv_nat_cast_smul [add_comm_group M] [add_comm_group M₂] {F : Type _} [AddMonoidHomClass F M M₂] (f : F)\n    (R S : Type _) [DivisionRing R] [DivisionRing S] [Module R M] [Module S M₂] (n : ℕ) (x : M) :\n    f («expr • » (n⁻¹ : R) x) = «expr • » (n⁻¹ : S) (f x) := by exact_mod_cast map_inv_int_cast_smul f R S n x\n#align map_inv_nat_cast_smul map_inv_nat_cast_smul\n-/\n\n",
 "map_inv_int_cast_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print map_inv_int_cast_smul /-\ntheorem map_inv_int_cast_smul [add_comm_group M] [add_comm_group M₂] {F : Type _} [AddMonoidHomClass F M M₂] (f : F)\n    (R S : Type _) [DivisionRing R] [DivisionRing S] [Module R M] [Module S M₂] (n : ℤ) (x : M) :\n    f («expr • » (n⁻¹ : R) x) = «expr • » (n⁻¹ : S) (f x) :=\n  by\n  by_cases hR : (n : R) = 0 <;> by_cases hS : (n : S) = 0\n  · simp [hR, hS]\n  · suffices ∀ y, f y = 0 by simp [this]\n    clear x\n    intro x\n    rw [← inv_smul_smul₀ hS (f x), ← map_int_cast_smul f R S]\n    simp [hR]\n  · suffices ∀ y, f y = 0 by simp [this]\n    clear x\n    intro x\n    rw [← smul_inv_smul₀ hR x, map_int_cast_smul f R S, hS, zero_smul]\n  · rw [← inv_smul_smul₀ hS (f _), ← map_int_cast_smul f R S, smul_inv_smul₀ hR]\n#align map_inv_int_cast_smul map_inv_int_cast_smul\n-/\n\n",
 "map_int_cast_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print map_int_cast_smul /-\ntheorem map_int_cast_smul [add_comm_group M] [add_comm_group M₂] {F : Type _} [AddMonoidHomClass F M M₂] (f : F)\n    (R S : Type _) [Ring R] [Ring S] [Module R M] [Module S M₂] (x : ℤ) (a : M) :\n    f («expr • » (x : R) a) = «expr • » (x : S) (f a) := by simp only [← zsmul_eq_smul_cast, map_zsmul]\n#align map_int_cast_smul map_int_cast_smul\n-/\n\n",
 "inv_of_two_smul_add_inv_of_two_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n#print inv_of_two_smul_add_inv_of_two_smul /-\n@[simp]\ntheorem inv_of_two_smul_add_inv_of_two_smul [Invertible (2 : R)] (x : M) :\n    «expr • » ((«expr⅟») 2 : R) x + «expr • » ((«expr⅟») 2 : R) x = x :=\n  Convex.combo_self invOf_two_add_invOf_two _\n#align inv_of_two_smul_add_inv_of_two_smul inv_of_two_smul_add_inv_of_two_smul\n-/\n\n",
 "inv_nat_cast_smul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print inv_nat_cast_smul_eq /-\n/-- If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\nagree on inverses of natural numbers in `R` and `S`. -/\ntheorem inv_nat_cast_smul_eq {E : Type _} (R S : Type _) [add_comm_group E] [DivisionRing R] [DivisionRing S]\n    [Module R E] [Module S E] (n : ℕ) (x : E) : «expr • » (n⁻¹ : R) x = «expr • » (n⁻¹ : S) x :=\n  map_inv_nat_cast_smul (AddMonoidHom.id E) R S n x\n#align inv_nat_cast_smul_eq inv_nat_cast_smul_eq\n-/\n\n",
 "inv_nat_cast_smul_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print inv_nat_cast_smul_comm /-\n/-- If `E` is a vector space over a division rings `R` and has a monoid action by `α`, then that\naction commutes by scalar multiplication of inverses of natural numbers in `R`. -/\ntheorem inv_nat_cast_smul_comm {α E : Type _} (R : Type _) [add_comm_group E] [DivisionRing R] [monoid α] [Module R E]\n    [DistribMulAction α E] (n : ℕ) (s : α) (x : E) :\n    «expr • » (n⁻¹ : R) («expr • » s x) = «expr • » s («expr • » (n⁻¹ : R) x) :=\n  (map_inv_nat_cast_smul (DistribMulAction.toAddMonoidHom E s) R R n x).symm\n#align inv_nat_cast_smul_comm inv_nat_cast_smul_comm\n-/\n\n",
 "inv_int_cast_smul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print inv_int_cast_smul_eq /-\n/-- If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\nagree on inverses of integer numbers in `R` and `S`. -/\ntheorem inv_int_cast_smul_eq {E : Type _} (R S : Type _) [add_comm_group E] [DivisionRing R] [DivisionRing S]\n    [Module R E] [Module S E] (n : ℤ) (x : E) : «expr • » (n⁻¹ : R) x = «expr • » (n⁻¹ : S) x :=\n  map_inv_int_cast_smul (AddMonoidHom.id E) R S n x\n#align inv_int_cast_smul_eq inv_int_cast_smul_eq\n-/\n\n",
 "inv_int_cast_smul_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print inv_int_cast_smul_comm /-\n/-- If `E` is a vector space over a division rings `R` and has a monoid action by `α`, then that\naction commutes by scalar multiplication of inverses of integers in `R` -/\ntheorem inv_int_cast_smul_comm {α E : Type _} (R : Type _) [add_comm_group E] [DivisionRing R] [monoid α] [Module R E]\n    [DistribMulAction α E] (n : ℤ) (s : α) (x : E) :\n    «expr • » (n⁻¹ : R) («expr • » s x) = «expr • » s («expr • » (n⁻¹ : R) x) :=\n  (map_inv_int_cast_smul (DistribMulAction.toAddMonoidHom E s) R R n x).symm\n#align inv_int_cast_smul_comm inv_int_cast_smul_comm\n-/\n\n",
 "int_smul_eq_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print int_smul_eq_zsmul /-\n/-- Convert back any exotic `ℤ`-smul to the canonical instance. This should not be needed since in\nmathlib all `add_comm_group`s should normally have exactly one `ℤ`-module structure by design. -/\ntheorem int_smul_eq_zsmul (h : Module ℤ M) (n : ℤ) (x : M) : @has_smul.smul ℤ M h.to_has_smul n x = «expr • » n x := by\n  rw [zsmul_eq_smul_cast ℤ n x, Int.cast_id]\n#align int_smul_eq_zsmul int_smul_eq_zsmul\n-/\n\n",
 "int_cast_def":
 "#print AddMonoid.End.int_cast_def /-\ntheorem AddMonoid.End.int_cast_def (z : ℤ) : (↑z : AddMonoid.End M) = DistribMulAction.toAddMonoidEnd ℤ M z :=\n  rfl\n#align add_monoid.End.int_cast_def AddMonoid.End.int_cast_def\n-/\n\n",
 "ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Module.ext' /-\n-- We'll later use this to show `module ℕ M` and `module ℤ M` are subsingletons.\n/-- A variant of `module.ext` that's convenient for term-mode. -/\ntheorem Module.ext' {R : Type _} [Semiring R] {M : Type _} [add_comm_monoid M] (P Q : Module R M)\n    (w :\n      ∀ (r : R) (m : M),\n        (haveI := P\n          «expr • » r m) =\n          haveI := Q\n          «expr • » r m) :\n    P = Q := by\n  ext\n  exact w _ _\n#align module.ext' Module.ext'\n-/\n\n",
 "eq_zero_of_zero_eq_one":
 "#print Module.eq_zero_of_zero_eq_one /-\ntheorem Module.eq_zero_of_zero_eq_one (zero_eq_one : (0 : R) = 1) : x = 0 := by\n  rw [← one_smul R x, ← zero_eq_one, zero_smul]\n#align module.eq_zero_of_zero_eq_one Module.eq_zero_of_zero_eq_one\n-/\n\n",
 "combo_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.combo_self /-\ntheorem Convex.combo_self {a b : R} (h : a + b = 1) (x : M) : «expr • » a x + «expr • » b x = x := by\n  rw [← add_smul, h, one_smul]\n#align convex.combo_self Convex.combo_self\n-/\n\n",
 "combo_eq_smul_sub_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Convex.combo_eq_smul_sub_add /-\ntheorem Convex.combo_eq_smul_sub_add [Module R M] {x y : M} {a b : R} (h : a + b = 1) :\n    «expr • » a x + «expr • » b y = «expr • » b (y - x) + x :=\n  calc\n    «expr • » a x + «expr • » b y = «expr • » b y - «expr • » b x + («expr • » a x + «expr • » b x) := by abel\n    _ = «expr • » b (y - x) + x := by rw [smul_sub, Convex.combo_self h]\n    \n#align convex.combo_eq_smul_sub_add Convex.combo_eq_smul_sub_add\n-/\n\n",
 "add_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print add_smul /-\ntheorem add_smul : «expr • » (r + s) x = «expr • » r x + «expr • » s x :=\n  module.add_smul r s x\n#align add_smul add_smul\n-/\n\n"}