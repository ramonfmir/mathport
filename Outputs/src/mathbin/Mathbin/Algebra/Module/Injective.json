{"le_max":
 "theorem extension_of.le_max {c : set (extension_of i f)} (hchain : IsChain (· ≤ ·) c) (hnonempty : c.nonempty)\n    (a : extension_of i f) (ha : a ∈ c) : a ≤ extension_of.max hchain hnonempty :=\n  linear_pmap.le_Sup (IsChain.directedOn <| chain_linear_pmap_of_chain_extension_of hchain) <|\n    (Set.mem_image _ _ _).mpr ⟨a, ha, rfl⟩\n#align extension_of.le_max extension_of.le_max\n\n",
 "injective_object_of_injective_module":
 "/-\nCopyright (c) 2022 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang\n-/\ntheorem module.injective_object_of_injective_module [module.injective.{u, v} R Q] :\n    category_theory.injective.{max u v} (⟨Q⟩ : Module.{max u v} R) :=\n  {\n    factors := fun X Y g f mn =>\n      by\n      rcases module.injective.out X Y f ((Module.mono_iff_injective f).mp mn) g with ⟨h, eq1⟩\n      exact ⟨h, linear_map.ext eq1⟩ }\n#align module.injective_object_of_injective_module module.injective_object_of_injective_module\n\n",
 "injective_module_of_injective_object":
 "theorem module.injective_module_of_injective_object [category_theory.injective.{max u v} (⟨Q⟩ : Module.{max u v} R)] :\n    module.injective.{u, v} R Q :=\n  {\n    out := fun X Y ins1 ins2 ins3 ins4 f hf g => by\n      skip\n      rcases@category_theory.injective.factors (Module R) _ ⟨Q⟩ _ ⟨X⟩ ⟨Y⟩ g f\n          ((Module.mono_iff_injective _).mpr hf) with\n        ⟨h, rfl⟩\n      exact ⟨h, fun x => rfl⟩ }\n#align module.injective_module_of_injective_object module.injective_module_of_injective_object\n\n",
 "injective_iff_injective_object":
 "theorem module.injective_iff_injective_object :\n    module.injective.{u, v} R Q ↔ category_theory.injective.{max u v} (⟨Q⟩ : Module.{max u v} R) :=\n  ⟨fun h => @module.injective_object_of_injective_module R _ Q _ _ h, fun h =>\n    @module.injective_module_of_injective_object R _ Q _ _ h⟩\n#align module.injective_iff_injective_object module.injective_iff_injective_object\n\n",
 "injective":
 "/-- **Baer's criterion** for injective module : a Baer module is an injective module, i.e. if every\nlinear map from an ideal can be extended, then the module is injective.-/\nprotected theorem injective (h : module.Baer R Q) : module.injective R Q :=\n  {\n    out := fun X Y ins1 ins2 ins3 ins4 i hi f =>\n      haveI : fact (function.injective i) := ⟨hi⟩\n      ⟨{  to_fun := fun y =>\n            (extension_of_max i f).to_linear_pmap ⟨y, (extension_of_max_to_submodule_eq_top i f h).symm ▸ trivial⟩\n          map_add' := fun x y => by\n            rw [← linear_pmap.map_add]\n            congr\n          map_smul' := fun r x => by\n            rw [← linear_pmap.map_smul]\n            congr },\n        fun x => ((extension_of_max i f).is_extension x).symm⟩ }\n#align injective injective\n\n",
 "extension_to_fun_wd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem extension_of_max_adjoin.extension_to_fun_wd (h : module.Baer R Q) {y : N}\n    (x : «expr ⊔ » (extension_of_max i f).domain (submodule.span R {y})) (a : (extension_of_max i f).domain) (r : R)\n    (eq1 : ↑x = ↑a + «expr • » r y) :\n    extension_of_max_adjoin.extension_to_fun i f h x =\n      (extension_of_max i f).to_linear_pmap a + extension_of_max_adjoin.extend_ideal_to i f h y r :=\n  by\n  cases' a with a ha\n  rw [subtype.coe_mk] at eq1\n  have eq2 : (extension_of_max_adjoin.fst i x - a : N) = «expr • » (r - extension_of_max_adjoin.snd i x) y := by\n    rwa [extension_of_max_adjoin.eqn, ← sub_eq_zero, ← sub_sub_sub_eq, sub_eq_zero, ← sub_smul] at eq1\n  have eq3 :=\n    extension_of_max_adjoin.extend_ideal_to_eq i f h (r - extension_of_max_adjoin.snd i x)\n      (by rw [← eq2] <;> exact submodule.sub_mem _ (extension_of_max_adjoin.fst i x).2 ha)\n  simp only [map_sub, sub_smul, sub_eq_iff_eq_add] at eq3\n  unfold extension_of_max_adjoin.extension_to_fun\n  rw [eq3, ← add_assoc, ← (extension_of_max i f).to_linear_pmap.map_add, AddMemClass.mk_add_mk]\n  congr\n  ext\n  rw [subtype.coe_mk, add_sub, ← eq1]\n  exact eq_sub_of_add_eq (extension_of_max_adjoin.eqn _ _).symm\n#align extension_of_max_adjoin.extension_to_fun_wd extension_of_max_adjoin.extension_to_fun_wd\n\n",
 "extension_of_max_to_submodule_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem extension_of_max_to_submodule_eq_top (h : module.Baer R Q) : (extension_of_max i f).domain = «expr⊤» :=\n  by\n  refine' submodule.eq_top_iff'.mpr fun y => _\n  rw [← extension_of_max_is_max i f _ (extension_of_max_le i f h), extension_of_max_adjoin, submodule.mem_sup]\n  exact ⟨0, submodule.zero_mem _, y, submodule.mem_span_singleton_self _, zero_add _⟩\n#align extension_of_max_to_submodule_eq_top extension_of_max_to_submodule_eq_top\n\n",
 "extension_of_max_le":
 "theorem extension_of_max_le (h : module.Baer R Q) {y : N} : extension_of_max i f ≤ extension_of_max_adjoin i f h y :=\n  ⟨le_sup_left, fun x x' EQ => by\n    symm\n    change extension_of_max_adjoin.extension_to_fun i f h _ = _\n    rw [extension_of_max_adjoin.extension_to_fun_wd i f h x' x 0 (by simp [EQ]), map_zero, add_zero]⟩\n#align extension_of_max_le extension_of_max_le\n\n",
 "extension_of_max_is_max":
 "theorem extension_of_max_is_max : ∀ a : extension_of i f, extension_of_max i f ≤ a → a = extension_of_max i f :=\n  (@zorn_nonempty_partialOrder (extension_of i f) _ ⟨Inhabited.default⟩ fun c hchain hnonempty =>\n      ⟨extension_of.max hchain hnonempty, extension_of.le_max hchain hnonempty⟩).some_spec\n#align extension_of_max_is_max extension_of_max_is_max\n\n",
 "extend_ideal_to_wd'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem extension_of_max_adjoin.extend_ideal_to_wd' (h : module.Baer R Q) {y : N} (r : R) (eq1 : «expr • » r y = 0) :\n    extension_of_max_adjoin.extend_ideal_to i f h y r = 0 :=\n  by\n  rw [extension_of_max_adjoin.extend_ideal_to_is_extension i f h y r\n      (by rw [eq1] <;> exact submodule.zero_mem _ : «expr • » r y ∈ _)]\n  simp only [extension_of_max_adjoin.ideal_to, linear_map.coe_mk, eq1, subtype.coe_mk, ← ZeroMemClass.zero_def,\n    (extension_of_max i f).to_linear_pmap.map_zero]\n#align extension_of_max_adjoin.extend_ideal_to_wd' extension_of_max_adjoin.extend_ideal_to_wd'\n\n",
 "extend_ideal_to_wd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem extension_of_max_adjoin.extend_ideal_to_wd (h : module.Baer R Q) {y : N} (r r' : R)\n    (eq1 : «expr • » r y = «expr • » r' y) :\n    extension_of_max_adjoin.extend_ideal_to i f h y r = extension_of_max_adjoin.extend_ideal_to i f h y r' :=\n  by\n  rw [← sub_eq_zero, ← map_sub]\n  convert extension_of_max_adjoin.extend_ideal_to_wd' i f h (r - r') _\n  rw [sub_smul, sub_eq_zero, eq1]\n#align extension_of_max_adjoin.extend_ideal_to_wd extension_of_max_adjoin.extend_ideal_to_wd\n\n",
 "extend_ideal_to_is_extension":
 "theorem extension_of_max_adjoin.extend_ideal_to_is_extension (h : module.Baer R Q) (y : N) :\n    ∀ (x : R) (mem : x ∈ extension_of_max_adjoin.ideal i f y),\n      extension_of_max_adjoin.extend_ideal_to i f h y x = extension_of_max_adjoin.ideal_to i f y ⟨x, mem⟩ :=\n  (h (extension_of_max_adjoin.ideal i f y) (extension_of_max_adjoin.ideal_to i f y)).some_spec\n#align extension_of_max_adjoin.extend_ideal_to_is_extension extension_of_max_adjoin.extend_ideal_to_is_extension\n\n",
 "extend_ideal_to_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem extension_of_max_adjoin.extend_ideal_to_eq (h : module.Baer R Q) {y : N} (r : R)\n    (hr : «expr • » r y ∈ (extension_of_max i f).domain) :\n    extension_of_max_adjoin.extend_ideal_to i f h y r = (extension_of_max i f).to_linear_pmap ⟨«expr • » r y, hr⟩ := by\n  simp only [extension_of_max_adjoin.extend_ideal_to_is_extension i f h _ _ hr, extension_of_max_adjoin.ideal_to,\n    linear_map.coe_mk, subtype.coe_mk]\n#align extension_of_max_adjoin.extend_ideal_to_eq extension_of_max_adjoin.extend_ideal_to_eq\n\n",
 "ext_iff":
 "theorem extension_of.ext_iff {a b : extension_of i f} :\n    a = b ↔\n      ∃ domain_eq : a.domain = b.domain,\n        ∀ ⦃x : a.domain⦄ ⦃y : b.domain⦄, (x : N) = y → a.to_linear_pmap x = b.to_linear_pmap y :=\n  ⟨fun r => r ▸ ⟨rfl, fun x y h => congr_arg a.to_fun <| by exact_mod_cast h⟩, fun ⟨h1, h2⟩ => extension_of.ext h1 h2⟩\n#align extension_of.ext_iff extension_of.ext_iff\n\n",
 "ext":
 "@[ext]\ntheorem extension_of.ext {a b : extension_of i f} (domain_eq : a.domain = b.domain)\n    (to_fun_eq : ∀ ⦃x : a.domain⦄ ⦃y : b.domain⦄, (x : N) = y → a.to_linear_pmap x = b.to_linear_pmap y) : a = b :=\n  by\n  rcases a with ⟨a, a_le, e1⟩\n  rcases b with ⟨b, b_le, e2⟩\n  congr\n  exact linear_pmap.ext domain_eq to_fun_eq\n#align extension_of.ext extension_of.ext\n\n",
 "eqn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem extension_of_max_adjoin.eqn {y : N} (x : «expr ⊔ » (extension_of_max i f).domain (submodule.span R {y})) :\n    ↑x = ↑(extension_of_max_adjoin.fst i x) + «expr • » (extension_of_max_adjoin.snd i x) y :=\n  (extension_of_max_adjoin.aux1 i x).some_spec.some_spec\n#align extension_of_max_adjoin.eqn extension_of_max_adjoin.eqn\n\n",
 "chain_linear_pmap_of_chain_extension_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem chain_linear_pmap_of_chain_extension_of {c : set (extension_of i f)} (hchain : IsChain (· ≤ ·) c) :\n    IsChain (· ≤ ·) <| «expr '' » (fun x : extension_of i f => x.to_linear_pmap) c :=\n  by\n  rintro _ ⟨a, a_mem, rfl⟩ _ ⟨b, b_mem, rfl⟩ neq\n  exact hchain a_mem b_mem (ne_of_apply_ne _ neq)\n#align chain_linear_pmap_of_chain_extension_of chain_linear_pmap_of_chain_extension_of\n\n",
 "aux1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprivate theorem extension_of_max_adjoin.aux1 {y : N}\n    (x : «expr ⊔ » (extension_of_max i f).domain (submodule.span R {y})) :\n    ∃ (a : (extension_of_max i f).domain)(b : R), x.1 = a.1 + «expr • » b y :=\n  by\n  have mem1 : x.1 ∈ (_ : set _) := x.2\n  rw [submodule.coe_sup] at mem1\n  rcases mem1 with ⟨a, b, a_mem, b_mem : b ∈ (submodule.span R _ : submodule R N), eq1⟩\n  rw [submodule.mem_span_singleton] at b_mem\n  rcases b_mem with ⟨z, eq2⟩\n  exact ⟨⟨a, a_mem⟩, z, by rw [← eq1, ← eq2]⟩\n#align extension_of_max_adjoin.aux1 extension_of_max_adjoin.aux1\n\n"}