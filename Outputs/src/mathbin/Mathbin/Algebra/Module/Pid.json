{"torsion_of_eq_span_pow_p_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem _root_.ideal.torsion_of_eq_span_pow_p_order (x : M) : torsion_of R M x = span {p ^ p_order hM x} :=\n  by\n  dsimp only [p_order]\n  rw [← (torsion_of R M x).span_singleton_generator, Ideal.span_singleton_eq_span_singleton, ←\n    Associates.mk_eq_mk_iff_associated, Associates.mk_pow]\n  have prop :\n    (fun n : ℕ => «expr • » (p ^ n) x = 0) = fun n : ℕ =>\n      (Associates.mk <| generator <| torsion_of R M x) ∣ Associates.mk p ^ n :=\n    by\n    ext n\n    rw [← Associates.mk_pow, Associates.mk_dvd_mk, ← mem_iff_generator_dvd]\n    rfl\n  have := (is_torsion'_powers_iff p).mp hM x\n  rw [prop] at this\n  classical convert Associates.eq_pow_find_of_dvd_irreducible_pow ((Associates.irreducible_mk p).mpr hp) this.some_spec\n#align ideal.torsion_of_eq_span_pow_p_order ideal.torsion_of_eq_span_pow_p_order\n\n",
 "torsion_by_prime_power_decomposition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- A finitely generated `p ^ ∞`-torsion module over a PID is isomorphic to a direct sum of some\n  `R ⧸ R ∙ (p ^ e i)` for some `e i`.-/\ntheorem torsion_by_prime_power_decomposition (hN : module.is_torsion' N (Submonoid.powers p)) [h' : Module.Finite R N] :\n    ∃ (d : ℕ)(k : Fin d → ℕ),\n      Nonempty <|\n        «expr ≃ₗ[ ] » N R\n          (direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\"\n            («expr ⧸ » R («expr ∙ » R (p ^ (k i : ℕ))))) :=\n  by\n  obtain ⟨d, s, hs⟩ := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'\n  induction' d with d IH generalizing N\n  · use fun i => finZeroElim i\n    rw [Set.range_eq_empty, Submodule.span_empty] at hs\n    haveI : Unique N :=\n      ⟨⟨0⟩, fun x => by\n        rw [← mem_bot _, hs]\n        trivial⟩\n    exact ⟨0⟩\n  · have : ∀ x : N, Decidable (x = 0)\n    classical\n      infer_instance\n      obtain ⟨j, hj⟩ := exists_is_torsion_by hN d.succ d.succ_ne_zero s hs\n      let s' : Fin d → «expr ⧸ » N («expr ∙ » R (s j)) := Submodule.Quotient.mk ∘ s ∘ j.succ_above\n      obtain ⟨k, ⟨f⟩⟩ := IH _ s' _ <;> clear IH\n      · have :\n          ∀ i : Fin d, ∃ x : N, «expr • » (p ^ k i) x = 0 ∧ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 :=\n          by\n          intro i\n          let fi := f.symm.to_linear_map.comp (DirectSum.lof _ _ _ i)\n          obtain ⟨x, h0, h1⟩ := exists_smul_eq_zero_and_mk_eq hp hN hj fi\n          refine' ⟨x, h0, _⟩\n          rw [h1]\n          simp only [LinearMap.coe_comp, f.symm.coe_to_linear_map, f.apply_symm_apply]\n        refine'\n          ⟨_,\n            ⟨(((@lequiv_prod_of_right_split_exact _ _ _ _ _ _ _ _ _ _ _ _\n                              ((f.trans ULift.moduleEquiv.{u, u, v}.symm).to_linear_map.comp <| mkq _)\n                              ((DirectSum.toModule _ _ _ fun i =>\n                                    (liftQSpanSingleton.{u, u} (p ^ k i) (LinearMap.toSpanSingleton _ _ _)\n                                        (this i).some_spec.left :\n                                      «expr →ₗ[ ] » («expr ⧸ » R _) R _)).comp\n                                ulift.module_equiv.to_linear_map)\n                              («expr ∙ » R (s j)).injective_subtype _ _).symm.trans <|\n                        ((quot_torsion_of_equiv_span_singleton _ _ _).symm.trans <|\n                              quot_equiv_of_eq _ _ <| ideal.torsion_of_eq_span_pow_p_order hp hN _).prod <|\n                          ULift.moduleEquiv).trans <|\n                    (@DirectSum.lequivProdDirectSum R _ _ _\n                        (fun i => «expr ⧸ » R («expr ∙ » R (p ^ @option.rec _ (fun _ => ℕ) (p_order hN <| s j) k i))) _\n                        _).symm).trans <|\n                DirectSum.lequivCongrLeft R (finSuccEquiv d).symm⟩⟩\n        · rw [range_subtype, linear_equiv.to_linear_map_eq_coe, LinearEquiv.ker_comp, ker_mkq]\n        · rw [linear_equiv.to_linear_map_eq_coe, ← f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc, ←\n            linear_equiv.to_linear_map_eq_coe, LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ←\n            LinearMap.comp_assoc, ← LinearMap.comp_assoc]\n          suffices (f.to_linear_map.comp («expr ∙ » R (s j)).mkq).comp _ = LinearMap.id by\n            rw [← f.to_linear_map_eq_coe, this, LinearMap.id_comp]\n          ext i : 3\n          simp only [LinearMap.coe_comp, Function.comp_apply, mkq_apply]\n          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof, liftq_span_singleton_apply,\n            LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk, map_one, (this i).some_spec.right]\n      ·\n        exact\n          (mk_surjective _).forall.mpr fun x =>\n            ⟨(@hN x).some, by rw [← quotient.mk_smul, (@hN x).some_spec, quotient.mk_zero]⟩\n      · have hs' := congr_arg (Submodule.map <| mkq <| «expr ∙ » R (s j)) hs\n        rw [Submodule.map_span, Submodule.map_top, range_mkq] at hs'\n        simp only [mkq_apply] at hs'\n        simp only [s']\n        rw [Set.range_comp (_ ∘ s), Fin.range_succAbove]\n        rw [← Set.range_comp, ← Set.insert_image_compl_eq_range _ j, Function.comp_apply,\n          (quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'\n        exact hs'\n#align torsion_by_prime_power_decomposition torsion_by_prime_power_decomposition\n\n",
 "p_pow_smul_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem p_pow_smul_lift {x y : M} {k : ℕ} (hM' : module.is_torsion_by R M (p ^ p_order hM y))\n    (h : «expr • » (p ^ k) x ∈ «expr ∙ » R y) : ∃ a : R, «expr • » (p ^ k) x = «expr • » (p ^ k) («expr • » a y) :=\n  by\n  by_cases hk : k ≤ p_order hM y\n  · let f :=\n      ((«expr ∙ » R (p ^ (p_order hM y - k) * p ^ k)).quot_equiv_of_eq _ _).trans\n        (quot_torsion_of_equiv_span_singleton R M y)\n    have :\n      f.symm ⟨«expr • » (p ^ k) x, h⟩ ∈\n        «expr ∙ » R (Ideal.Quotient.mk («expr ∙ » R (p ^ (p_order hM y - k) * p ^ k)) (p ^ k)) :=\n      by\n      rw [← quotient.torsion_by_eq_span_singleton, mem_torsion_by_iff, ← f.symm.map_smul]\n      convert f.symm.map_zero\n      ext\n      rw [coe_smul_of_tower, coe_mk, coe_zero, smul_smul, ← pow_add, nat.sub_add_cancel hk, @hM' x]\n      · exact mem_nonZeroDivisors_of_ne_zero (pow_ne_zero _ hp.ne_zero)\n    rw [Submodule.mem_span_singleton] at this\n    obtain ⟨a, ha⟩ := this\n    use a\n    rw [f.eq_symm_apply, ← Ideal.Quotient.mk_eq_mk, ← quotient.mk_smul] at ha\n    dsimp only [smul_eq_mul, f, LinearEquiv.trans_apply, Submodule.quotEquivOfEq_mk,\n      quot_torsion_of_equiv_span_singleton_apply_mk] at ha\n    rw [smul_smul, mul_comm]\n    exact congr_arg coe ha.symm\n    · symm\n      convert ideal.torsion_of_eq_span_pow_p_order hp hM y\n      rw [← pow_add, nat.sub_add_cancel hk]\n  · use 0\n    rw [zero_smul, smul_zero, ← nat.sub_add_cancel (le_of_not_le hk), pow_add, mul_smul, hM', smul_zero]\n#align p_pow_smul_lift p_pow_smul_lift\n\n",
 "is_internal_prime_power_torsion_of_pid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2022 Pierre-Alexandre Bazin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Pierre-Alexandre Bazin\n-/\n/-- A finitely generated torsion module over a PID is an internal direct sum of its\n`p i ^ e i`-torsion submodules for some primes `p i` and numbers `e i`.-/\ntheorem submodule.is_internal_prime_power_torsion_of_pid [Module.Finite R M] (hM : module.is_torsion R M) :\n    DirectSum.IsInternal fun p : (factors («expr⊤» : Submodule R M).annihilator).to_finset =>\n      torsion_by R M (IsPrincipal.generator (p : Ideal R) ^ (factors («expr⊤» : Submodule R M).annihilator).count p) :=\n  by\n  convert is_internal_prime_power_torsion hM\n  ext p : 1\n  rw [← torsion_by_span_singleton_eq, Ideal.submodule_span_eq, ← Ideal.span_singleton_pow,\n    Ideal.span_singleton_generator]\n#align submodule.is_internal_prime_power_torsion_of_pid submodule.is_internal_prime_power_torsion_of_pid\n\n",
 "exists_smul_eq_zero_and_mk_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_smul_eq_zero_and_mk_eq {z : M} (hz : module.is_torsion_by R M (p ^ p_order hM z)) {k : ℕ}\n    (f : «expr →ₗ[ ] » («expr ⧸ » R («expr ∙ » R (p ^ k))) R («expr ⧸ » M («expr ∙ » R z))) :\n    ∃ x : M, «expr • » (p ^ k) x = 0 ∧ Submodule.Quotient.mk x = f 1 :=\n  by\n  have f1 := mk_surjective («expr ∙ » R z) (f 1)\n  have : «expr • » (p ^ k) f1.some ∈ «expr ∙ » R z :=\n    by\n    rw [← quotient.mk_eq_zero, mk_smul, f1.some_spec, ← f.map_smul]\n    convert f.map_zero\n    change «expr • » _ (Submodule.Quotient.mk _) = _\n    rw [← mk_smul, quotient.mk_eq_zero, Algebra.id.smul_eq_mul, mul_one]\n    exact Submodule.mem_span_singleton_self _\n  obtain ⟨a, ha⟩ := p_pow_smul_lift hp hM hz this\n  refine' ⟨f1.some - «expr • » a z, by rw [smul_sub, sub_eq_zero, ha], _⟩\n  rw [mk_sub, mk_smul, (quotient.mk_eq_zero _).mpr <| Submodule.mem_span_singleton_self _, smul_zero, sub_zero,\n    f1.some_spec]\n#align exists_smul_eq_zero_and_mk_eq exists_smul_eq_zero_and_mk_eq\n\n",
 "exists_is_internal_prime_power_torsion_of_pid":
 "/-- A finitely generated torsion module over a PID is an internal direct sum of its\n`p i ^ e i`-torsion submodules for some primes `p i` and numbers `e i`.-/\ntheorem submodule.exists_is_internal_prime_power_torsion_of_pid [Module.Finite R M] (hM : module.is_torsion R M) :\n    ∃ (ι : Type u)(_ : Fintype ι)(_ : DecidableEq ι)(p : ι → R)(h : ∀ i, Irreducible <| p i)(e : ι → ℕ),\n      DirectSum.IsInternal fun i => torsion_by R M <| p i ^ e i :=\n  by\n  refine' ⟨_, _, _, _, _, _, submodule.is_internal_prime_power_torsion_of_pid hM⟩\n  exact Finset.fintypeCoeSort _\n  · rintro ⟨p, hp⟩\n    have hP := prime_of_factor p (multiset.mem_to_finset.mp hp)\n    haveI := ideal.is_prime_of_prime hP\n    exact (is_principal.prime_generator_of_is_prime p hP.ne_zero).irreducible\n#align submodule.exists_is_internal_prime_power_torsion_of_pid submodule.exists_is_internal_prime_power_torsion_of_pid\n\n",
 "equiv_free_prod_direct_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- **Structure theorem of finitely generated modules over a PID** : A finitely generated\n  module over a PID is isomorphic to the product of a free module and a direct sum of some\n  `R ⧸ R ∙ (p i ^ e i)` where the `p i ^ e i` are prime powers.-/\ntheorem equiv_free_prod_direct_sum [h' : Module.Finite R N] :\n    ∃ (n : ℕ)(ι : Type u)(_ : Fintype ι)(p : ι → R)(h : ∀ i, Irreducible <| p i)(e : ι → ℕ),\n      Nonempty <|\n        «expr ≃ₗ[ ] » N R\n          («expr →₀ » (Fin n) R ×\n            direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\"\n              («expr ⧸ » R («expr ∙ » R (p i ^ e i)))) :=\n  by\n  haveI := isNoetherian_of_fg_of_noetherian' (module.finite_def.mp h')\n  haveI := isNoetherian_submodule' (torsion R N)\n  haveI := Module.Finite.of_surjective _ (torsion R N).mkq_surjective\n  obtain ⟨I, fI, p, hp, e, ⟨h⟩⟩ := equiv_direct_sum_of_is_torsion (@torsion_is_torsion R N _ _ _)\n  obtain ⟨n, ⟨g⟩⟩ := @Module.basisOfFiniteTypeTorsionFree' R _ _ _ («expr ⧸ » N (torsion R N)) _ _ _ _\n  haveI : Module.Projective R («expr ⧸ » N (torsion R N)) := Module.Projective.of_basis ⟨g⟩\n  obtain ⟨f, hf⟩ := Module.projective_lifting_property _ LinearMap.id (torsion R N).mkq_surjective\n  refine'\n    ⟨n, I, fI, p, hp, e,\n      ⟨(lequiv_prod_of_right_split_exact (torsion R N).injective_subtype _ hf).symm.trans <|\n          (h.prod g).trans <| LinearEquiv.prodComm R _ _⟩⟩\n  rw [range_subtype, ker_mkq]\n#align equiv_free_prod_direct_sum equiv_free_prod_direct_sum\n\n",
 "equiv_direct_sum_of_is_torsion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- A finitely generated torsion module over a PID is isomorphic to a direct sum of some\n  `R ⧸ R ∙ (p i ^ e i)` where the `p i ^ e i` are prime powers.-/\ntheorem equiv_direct_sum_of_is_torsion [h' : Module.Finite R N] (hN : module.is_torsion R N) :\n    ∃ (ι : Type u)(_ : Fintype ι)(p : ι → R)(h : ∀ i, Irreducible <| p i)(e : ι → ℕ),\n      Nonempty <|\n        «expr ≃ₗ[ ] » N R\n          (direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\"\n            («expr ⧸ » R («expr ∙ » R (p i ^ e i)))) :=\n  by\n  obtain ⟨I, fI, _, p, hp, e, h⟩ := submodule.exists_is_internal_prime_power_torsion_of_pid hN\n  haveI := fI\n  have :\n    ∀ i,\n      ∃ (d : ℕ)(k : Fin d → ℕ),\n        Nonempty <|\n          «expr ≃ₗ[ ] » (torsion_by R N (p i ^ e i)) R\n            (direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\"\n              («expr ⧸ » R («expr ∙ » R (p i ^ k j)))) :=\n    by\n    haveI := isNoetherian_of_fg_of_noetherian' (module.finite_def.mp h')\n    haveI := fun i => isNoetherian_submodule' (torsion_by R N <| p i ^ e i)\n    exact fun i =>\n      torsion_by_prime_power_decomposition (hp i)\n        ((is_torsion'_powers_iff <| p i).mpr fun x => ⟨e i, smul_torsion_by _ _⟩)\n  classical\n    refine'\n      ⟨Σi, Fin (this i).some, inferInstance, fun ⟨i, j⟩ => p i, fun ⟨i, j⟩ => hp i, fun ⟨i, j⟩ =>\n        (this i).some_spec.some j,\n        ⟨(LinearEquiv.ofBijective (DirectSum.coeLinearMap _) h).symm.trans <|\n            (Dfinsupp.mapRange.linearEquiv fun i => (this i).some_spec.some_spec.some).trans <|\n              (DirectSum.sigmaLcurryEquiv R).symm.trans\n                (Dfinsupp.mapRange.linearEquiv fun i => quot_equiv_of_eq _ _ _)⟩⟩\n    cases' i with i j\n    simp only\n#align equiv_direct_sum_of_is_torsion equiv_direct_sum_of_is_torsion\n\n"}