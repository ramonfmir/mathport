{"torsion_of_eq_span_pow_p_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem _root_.ideal.torsion_of_eq_span_pow_p_order (x : M) : torsion_of R M x = span {p ^ p_order hM x} :=\n  by\n  dsimp only [p_order]\n  rw [← (torsion_of R M x).span_singleton_generator, ideal.span_singleton_eq_span_singleton, ←\n    Associates.mk_eq_mk_iff_associated, Associates.mk_pow]\n  have prop :\n    (fun n : ℕ => «expr • » (p ^ n) x = 0) = fun n : ℕ =>\n      (Associates.mk <| generator <| torsion_of R M x) ∣ Associates.mk p ^ n :=\n    by\n    ext n\n    rw [← Associates.mk_pow, Associates.mk_dvd_mk, ← mem_iff_generator_dvd]\n    rfl\n  have := (is_torsion'_powers_iff p).mp hM x\n  rw [prop] at this\n  classical convert associates.eq_pow_find_of_dvd_irreducible_pow ((Associates.irreducible_mk p).mpr hp) this.some_spec\n#align ideal.torsion_of_eq_span_pow_p_order ideal.torsion_of_eq_span_pow_p_order\n\n",
 "torsion_by_prime_power_decomposition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- A finitely generated `p ^ ∞`-torsion module over a PID is isomorphic to a direct sum of some\n  `R ⧸ R ∙ (p ^ e i)` for some `e i`.-/\ntheorem torsion_by_prime_power_decomposition (hN : module.is_torsion' N (submonoid.powers p)) [h' : module.finite R N] :\n    ∃ (d : ℕ)(k : fin d → ℕ),\n      nonempty <|\n        «expr ≃ₗ[ ] » N R\n          (direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\"\n            («expr ⧸ » R («expr ∙ » R (p ^ (k i : ℕ))))) :=\n  by\n  obtain ⟨d, s, hs⟩ := @module.finite.exists_fin _ _ _ _ _ h'; use d; clear h'\n  induction' d with d IH generalizing N\n  · use fun i => finZeroElim i\n    rw [Set.range_eq_empty, submodule.span_empty] at hs\n    haveI : unique N :=\n      ⟨⟨0⟩, fun x => by\n        rw [← mem_bot _, hs]\n        trivial⟩\n    exact ⟨0⟩\n  · have : ∀ x : N, decidable (x = 0)\n    classical\n      infer_instance\n      obtain ⟨j, hj⟩ := exists_is_torsion_by hN d.succ d.succ_ne_zero s hs\n      let s' : fin d → «expr ⧸ » N («expr ∙ » R (s j)) := submodule.quotient.mk ∘ s ∘ j.succ_above\n      obtain ⟨k, ⟨f⟩⟩ := IH _ s' _ <;> clear IH\n      · have :\n          ∀ i : fin d, ∃ x : N, «expr • » (p ^ k i) x = 0 ∧ f (submodule.quotient.mk x) = direct_sum.lof R _ _ i 1 :=\n          by\n          intro i\n          let fi := f.symm.to_linear_map.comp (direct_sum.lof _ _ _ i)\n          obtain ⟨x, h0, h1⟩ := exists_smul_eq_zero_and_mk_eq hp hN hj fi\n          refine' ⟨x, h0, _⟩\n          rw [h1]\n          simp only [linear_map.coe_comp, f.symm.coe_to_linear_map, f.apply_symm_apply]\n        refine'\n          ⟨_,\n            ⟨(((@lequiv_prod_of_right_split_exact _ _ _ _ _ _ _ _ _ _ _ _\n                              ((f.trans ulift.module_equiv.{u, u, v}.symm).to_linear_map.comp <| mkq _)\n                              ((direct_sum.to_module _ _ _ fun i =>\n                                    (liftq_span_singleton.{u, u} (p ^ k i) (linear_map.to_span_singleton _ _ _)\n                                        (this i).some_spec.left :\n                                      «expr →ₗ[ ] » («expr ⧸ » R _) R _)).comp\n                                ulift.module_equiv.to_linear_map)\n                              («expr ∙ » R (s j)).injective_subtype _ _).symm.trans <|\n                        ((quot_torsion_of_equiv_span_singleton _ _ _).symm.trans <|\n                              quot_equiv_of_eq _ _ <| ideal.torsion_of_eq_span_pow_p_order hp hN _).prod <|\n                          ulift.module_equiv).trans <|\n                    (@direct_sum.lequiv_prod_direct_sum R _ _ _\n                        (fun i => «expr ⧸ » R («expr ∙ » R (p ^ @option.rec _ (fun _ => ℕ) (p_order hN <| s j) k i))) _\n                        _).symm).trans <|\n                direct_sum.lequiv_congr_left R (fin_succ_equiv d).symm⟩⟩\n        · rw [range_subtype, linear_equiv.to_linear_map_eq_coe, linear_equiv.ker_comp, ker_mkq]\n        · rw [linear_equiv.to_linear_map_eq_coe, ← f.comp_coe, linear_map.comp_assoc, linear_map.comp_assoc, ←\n            linear_equiv.to_linear_map_eq_coe, linear_equiv.to_linear_map_symm_comp_eq, linear_map.comp_id, ←\n            linear_map.comp_assoc, ← linear_map.comp_assoc]\n          suffices (f.to_linear_map.comp («expr ∙ » R (s j)).mkq).comp _ = linear_map.id by\n            rw [← f.to_linear_map_eq_coe, this, linear_map.id_comp]\n          ext i : 3\n          simp only [linear_map.coe_comp, Function.comp_apply, mkq_apply]\n          rw [linear_equiv.coe_to_linear_map, linear_map.id_apply, direct_sum.to_module_lof, liftq_span_singleton_apply,\n            linear_map.to_span_singleton_one, ideal.quotient.mk_eq_mk, map_one, (this i).some_spec.right]\n      ·\n        exact\n          (mk_surjective _).forall.mpr fun x =>\n            ⟨(@hN x).some, by rw [← quotient.mk_smul, (@hN x).some_spec, quotient.mk_zero]⟩\n      · have hs' := congr_arg (submodule.map <| mkq <| «expr ∙ » R (s j)) hs\n        rw [submodule.map_span, submodule.map_top, range_mkq] at hs'\n        simp only [mkq_apply] at hs'\n        simp only [s']\n        rw [Set.range_comp (_ ∘ s), Fin.range_succAbove]\n        rw [← Set.range_comp, ← Set.insert_image_compl_eq_range _ j, function.comp_apply,\n          (quotient.mk_eq_zero _).mpr (submodule.mem_span_singleton_self _), span_insert_zero] at hs'\n        exact hs'\n#align torsion_by_prime_power_decomposition torsion_by_prime_power_decomposition\n\n",
 "p_pow_smul_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem p_pow_smul_lift {x y : M} {k : ℕ} (hM' : module.is_torsion_by R M (p ^ p_order hM y))\n    (h : «expr • » (p ^ k) x ∈ «expr ∙ » R y) : ∃ a : R, «expr • » (p ^ k) x = «expr • » (p ^ k) («expr • » a y) :=\n  by\n  by_cases hk : k ≤ p_order hM y\n  · let f :=\n      ((«expr ∙ » R (p ^ (p_order hM y - k) * p ^ k)).quot_equiv_of_eq _ _).trans\n        (quot_torsion_of_equiv_span_singleton R M y)\n    have :\n      f.symm ⟨«expr • » (p ^ k) x, h⟩ ∈\n        «expr ∙ » R (ideal.quotient.mk («expr ∙ » R (p ^ (p_order hM y - k) * p ^ k)) (p ^ k)) :=\n      by\n      rw [← quotient.torsion_by_eq_span_singleton, mem_torsion_by_iff, ← f.symm.map_smul]\n      convert f.symm.map_zero\n      ext\n      rw [coe_smul_of_tower, coe_mk, coe_zero, smul_smul, ← pow_add, nat.sub_add_cancel hk, @hM' x]\n      · exact mem_non_zero_divisors_of_ne_zero (pow_ne_zero _ hp.ne_zero)\n    rw [submodule.mem_span_singleton] at this\n    obtain ⟨a, ha⟩ := this\n    use a\n    rw [f.eq_symm_apply, ← ideal.quotient.mk_eq_mk, ← quotient.mk_smul] at ha\n    dsimp only [smul_eq_mul, f, linear_equiv.trans_apply, submodule.quot_equiv_of_eq_mk,\n      quot_torsion_of_equiv_span_singleton_apply_mk] at ha\n    rw [smul_smul, mul_comm]\n    exact congr_arg coe ha.symm\n    · symm\n      convert ideal.torsion_of_eq_span_pow_p_order hp hM y\n      rw [← pow_add, nat.sub_add_cancel hk]\n  · use 0\n    rw [zero_smul, smul_zero, ← nat.sub_add_cancel (le_of_not_le hk), pow_add, mul_smul, hM', smul_zero]\n#align p_pow_smul_lift p_pow_smul_lift\n\n",
 "is_internal_prime_power_torsion_of_pid":
 "/-\nCopyright (c) 2022 Pierre-Alexandre Bazin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Pierre-Alexandre Bazin\n-/\n/-- A finitely generated torsion module over a PID is an internal direct sum of its\n`p i ^ e i`-torsion submodules for some primes `p i` and numbers `e i`.-/\ntheorem submodule.is_internal_prime_power_torsion_of_pid [module.finite R M] (hM : module.is_torsion R M) :\n    ∃ (ι : Type u)(_ : fintype ι)(_ : decidable_eq ι)(p : ι → R)(h : ∀ i, Irreducible <| p i)(e : ι → ℕ),\n      direct_sum.is_internal fun i => torsion_by R M <| p i ^ e i :=\n  by\n  obtain ⟨P, dec, hP, e, this⟩ := is_internal_prime_power_torsion hM\n  refine' ⟨P, infer_instance, dec, fun p => is_principal.generator (p : ideal R), _, e, _⟩\n  · rintro ⟨p, hp⟩\n    haveI := ideal.is_prime_of_prime (hP p hp)\n    exact (is_principal.prime_generator_of_is_prime p (hP p hp).ne_zero).irreducible\n  · convert this\n    ext p : 1\n    rw [← torsion_by_span_singleton_eq, ideal.submodule_span_eq, ← ideal.span_singleton_pow,\n      ideal.span_singleton_generator]\n#align submodule.is_internal_prime_power_torsion_of_pid submodule.is_internal_prime_power_torsion_of_pid\n\n",
 "exists_smul_eq_zero_and_mk_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_smul_eq_zero_and_mk_eq {z : M} (hz : module.is_torsion_by R M (p ^ p_order hM z)) {k : ℕ}\n    (f : «expr →ₗ[ ] » («expr ⧸ » R («expr ∙ » R (p ^ k))) R («expr ⧸ » M («expr ∙ » R z))) :\n    ∃ x : M, «expr • » (p ^ k) x = 0 ∧ submodule.quotient.mk x = f 1 :=\n  by\n  have f1 := mk_surjective («expr ∙ » R z) (f 1)\n  have : «expr • » (p ^ k) f1.some ∈ «expr ∙ » R z :=\n    by\n    rw [← quotient.mk_eq_zero, mk_smul, f1.some_spec, ← f.map_smul]\n    convert f.map_zero\n    change «expr • » _ (submodule.quotient.mk _) = _\n    rw [← mk_smul, quotient.mk_eq_zero, algebra.id.smul_eq_mul, mul_one]\n    exact submodule.mem_span_singleton_self _\n  obtain ⟨a, ha⟩ := p_pow_smul_lift hp hM hz this\n  refine' ⟨f1.some - «expr • » a z, by rw [smul_sub, sub_eq_zero, ha], _⟩\n  rw [mk_sub, mk_smul, (quotient.mk_eq_zero _).mpr <| submodule.mem_span_singleton_self _, smul_zero, sub_zero,\n    f1.some_spec]\n#align exists_smul_eq_zero_and_mk_eq exists_smul_eq_zero_and_mk_eq\n\n",
 "equiv_free_prod_direct_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- **Structure theorem of finitely generated modules over a PID** : A finitely generated\n  module over a PID is isomorphic to the product of a free module and a direct sum of some\n  `R ⧸ R ∙ (p i ^ e i)` where the `p i ^ e i` are prime powers.-/\ntheorem equiv_free_prod_direct_sum [h' : module.finite R N] :\n    ∃ (n : ℕ)(ι : Type u)(_ : fintype ι)(p : ι → R)(h : ∀ i, Irreducible <| p i)(e : ι → ℕ),\n      nonempty <|\n        «expr ≃ₗ[ ] » N R\n          («expr →₀ » (fin n) R ×\n            direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\"\n              («expr ⧸ » R («expr ∙ » R (p i ^ e i)))) :=\n  by\n  haveI := is_noetherian_of_fg_of_noetherian' (module.finite_def.mp h')\n  haveI := is_noetherian_submodule' (torsion R N)\n  haveI := module.finite.of_surjective _ (torsion R N).mkq_surjective\n  obtain ⟨I, fI, p, hp, e, ⟨h⟩⟩ := equiv_direct_sum_of_is_torsion (@torsion_is_torsion R N _ _ _)\n  obtain ⟨n, ⟨g⟩⟩ := @module.free_of_finite_type_torsion_free' R _ _ _ («expr ⧸ » N (torsion R N)) _ _ _ _\n  haveI : module.projective R («expr ⧸ » N (torsion R N)) := module.projective_of_basis ⟨g⟩\n  obtain ⟨f, hf⟩ := module.projective_lifting_property _ linear_map.id (torsion R N).mkq_surjective\n  refine'\n    ⟨n, I, fI, p, hp, e,\n      ⟨(lequiv_prod_of_right_split_exact (torsion R N).injective_subtype _ hf).symm.trans <|\n          (h.prod g).trans <| linear_equiv.prod_comm R _ _⟩⟩\n  rw [range_subtype, ker_mkq]\n#align equiv_free_prod_direct_sum equiv_free_prod_direct_sum\n\n",
 "equiv_direct_sum_of_is_torsion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- A finitely generated torsion module over a PID is isomorphic to a direct sum of some\n  `R ⧸ R ∙ (p i ^ e i)` where the `p i ^ e i` are prime powers.-/\ntheorem equiv_direct_sum_of_is_torsion [h' : module.finite R N] (hN : module.is_torsion R N) :\n    ∃ (ι : Type u)(_ : fintype ι)(p : ι → R)(h : ∀ i, Irreducible <| p i)(e : ι → ℕ),\n      nonempty <|\n        «expr ≃ₗ[ ] » N R\n          (direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\"\n            («expr ⧸ » R («expr ∙ » R (p i ^ e i)))) :=\n  by\n  obtain ⟨I, fI, _, p, hp, e, h⟩ := submodule.is_internal_prime_power_torsion_of_pid hN\n  haveI := fI\n  have :\n    ∀ i,\n      ∃ (d : ℕ)(k : fin d → ℕ),\n        nonempty <|\n          «expr ≃ₗ[ ] » (torsion_by R N (p i ^ e i)) R\n            (direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\"\n              («expr ⧸ » R («expr ∙ » R (p i ^ k j)))) :=\n    by\n    haveI := is_noetherian_of_fg_of_noetherian' (module.finite_def.mp h')\n    haveI := fun i => is_noetherian_submodule' (torsion_by R N <| p i ^ e i)\n    exact fun i =>\n      torsion_by_prime_power_decomposition (hp i)\n        ((is_torsion'_powers_iff <| p i).mpr fun x => ⟨e i, smul_torsion_by _ _⟩)\n  refine'\n    ⟨Σi, fin (this i).some, infer_instance, fun ⟨i, j⟩ => p i, fun ⟨i, j⟩ => hp i, fun ⟨i, j⟩ =>\n      (this i).some_spec.some j,\n      ⟨(linear_equiv.of_bijective (direct_sum.coe_linear_map _) h).symm.trans <|\n          (dfinsupp.map_range.linear_equiv fun i => (this i).some_spec.some_spec.some).trans <|\n            (direct_sum.sigma_lcurry_equiv R).symm.trans\n              (dfinsupp.map_range.linear_equiv fun i => quot_equiv_of_eq _ _ _)⟩⟩\n  cases' i with i j\n  simp only\n#align equiv_direct_sum_of_is_torsion equiv_direct_sum_of_is_torsion\n\n"}