{"zero_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprivate theorem zero_smul' (x : localized_module S M) : «expr • » (0 : localization S) x = 0 :=\n  by\n  induction' x using localized_module.induction_on with m s\n  rw [← localization.mk_zero s, mk_smul_mk, zero_smul, zero_mk]\n#align zero_smul' zero_smul'\n\n",
 "zero_mk":
 "@[simp]\ntheorem zero_mk (s : S) : mk (0 : M) s = 0 :=\n  mk_eq.mpr ⟨1, by rw [one_smul, smul_zero, smul_zero, one_smul]⟩\n#align zero_mk zero_mk\n\n",
 "zero_add'":
 "private theorem zero_add' (x : localized_module S M) : 0 + x = x :=\n  induction_on\n    (fun m s => by\n      rw [← zero_mk s, mk_add_mk, smul_zero, zero_add, mk_eq] <;> exact ⟨1, by rw [one_smul, mul_smul, one_smul]⟩)\n    x\n#align zero_add' zero_add'\n\n",
 "surj":
 "theorem from_localized_module.surj : function.surjective <| from_localized_module S f := fun x =>\n  let ⟨⟨m, s⟩, eq1⟩ := is_localized_module.surj S f x\n  ⟨localized_module.mk m s,\n    by\n    rw [from_localized_module_mk, module.End_algebra_map_is_unit_inv_apply_eq_iff, ← eq1]\n    rfl⟩\n#align from_localized_module.surj from_localized_module.surj\n\n",
 "smul_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprivate theorem smul_zero' (x : localization S) : «expr • » x (0 : localized_module S M) = 0 :=\n  by\n  induction' x using localization.induction_on with data\n  rcases data with ⟨r, s⟩\n  rw [← zero_mk s, mk_smul_mk, smul_zero, zero_mk, zero_mk]\n#align smul_zero' smul_zero'\n\n",
 "smul_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_injective (s : S) : function.injective fun m : M' => «expr • » s m :=\n  ((module.End_is_unit_iff _).mp (is_localized_module.map_units f s)).injective\n#align smul_injective smul_injective\n\n",
 "smul_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_inj (s : S) (m₁ m₂ : M') : «expr • » s m₁ = «expr • » s m₂ ↔ m₁ = m₂ :=\n  (smul_injective f s).eq_iff\n#align smul_inj smul_inj\n\n",
 "smul_add'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprivate theorem smul_add' (x : localization S) (y z : localized_module S M) :\n    «expr • » x (y + z) = «expr • » x y + «expr • » x z :=\n  by\n  induction' x using localization.induction_on with data\n  rcases data with ⟨r, u⟩\n  induction' y using localized_module.induction_on with m s\n  induction' z using localized_module.induction_on with n t\n  rw [mk_smul_mk, mk_smul_mk, mk_add_mk, mk_smul_mk, mk_add_mk, mk_eq]\n  use 1\n  simp only [one_smul, smul_add, ← mul_smul, Submonoid.smul_def, Submonoid.coe_mul]\n  ring_nf\n#align smul_add' smul_add'\n\n",
 "smul'_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul'_mk (r : R) (s : S) (m : M) : «expr • » r (mk m s) = mk («expr • » r m) s := by\n  erw [mk_smul_mk r m 1 s, one_mul]\n#align smul'_mk smul'_mk\n\n",
 "ring_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem ring_hom_ext (map_unit : ∀ x : S, is_unit ((algebra_map R (module.End R M'')) x)) ⦃j k : «expr →ₗ[ ] » M' R M''⦄\n    (h : j.comp f = k.comp f) : j = k :=\n  by\n  rw [← lift_unique S f (k.comp f) map_unit j h, lift_unique]\n  rfl\n#align ring_hom_ext ring_hom_ext\n\n",
 "one_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprivate theorem one_smul' (m : localized_module S M) : «expr • » (1 : localization S) m = m :=\n  by\n  induction' m using localized_module.induction_on with m s\n  rw [← localization.mk_one, mk_smul_mk, one_smul, one_mul]\n#align one_smul' one_smul'\n\n",
 "nsmul_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprivate theorem nsmul_zero' (x : localized_module S M) : «expr • » (0 : ℕ) x = 0 :=\n  localized_module.induction_on (fun _ _ => rfl) x\n#align nsmul_zero' nsmul_zero'\n\n",
 "nsmul_succ'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprivate theorem nsmul_succ' (n : ℕ) (x : localized_module S M) : «expr • » n.succ x = x + «expr • » n x :=\n  localized_module.induction_on (fun _ _ => rfl) x\n#align nsmul_succ' nsmul_succ'\n\n",
 "mul_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprivate theorem mul_smul' (x y : localization S) (m : localized_module S M) :\n    «expr • » (x * y) m = «expr • » x («expr • » y m) :=\n  by\n  induction' x using localization.induction_on with data\n  induction' y using localization.induction_on with data'\n  rcases data, data' with ⟨⟨r, s⟩, ⟨r', s'⟩⟩\n  induction' m using localized_module.induction_on with m t\n  rw [localization.mk_mul, mk_smul_mk, mk_smul_mk, mk_smul_mk, mul_smul, mul_assoc]\n#align mul_smul' mul_smul'\n\n",
 "mul_by_div_by":
 "theorem mul_by_div_by (s : S) (p : localized_module S M) :\n    algebra_map R (module.End R (localized_module S M)) s (div_by s p) = p :=\n  p.induction_on\n    (by\n      intro m t\n      simp only [localized_module.lift_on_mk, div_by_apply, module.algebra_map_End_apply, smul'_mk]\n      erw [mk_cancel_common_left s t])\n#align mul_by_div_by mul_by_div_by\n\n",
 "mk_smul_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mk_smul_mk (r : R) (m : M) (s t : S) : «expr • » (localization.mk r s) (mk m t) = mk («expr • » r m) (s * t) :=\n  by\n  unfold has_smul.smul\n  rw [localization.lift_on_mk, lift_on_mk]\n#align mk_smul_mk mk_smul_mk\n\n",
 "mk_of_algebra":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mk_of_algebra {R S S' : Type _} [CommRing R] [CommRing S] [CommRing S'] [algebra R S] [algebra R S']\n    (M : Submonoid R) (f : «expr →ₐ[ ] » S R S') (h₁ : ∀ x ∈ M, is_unit (algebra_map R S' x))\n    (h₂ : ∀ y, ∃ x : S × M, «expr • » x.2 y = f x.1) (h₃ : ∀ x, f x = 0 → ∃ m : M, «expr • » m x = 0) :\n    is_localized_module M f.to_linear_map :=\n  by\n  replace h₃ := fun x =>\n    iff.intro (h₃ x) fun ⟨⟨m, hm⟩, e⟩ =>\n      (h₁ m hm).mul_left_cancel <| by\n        rw [← algebra.smul_def]\n        simpa [Submonoid.smul_def] using f.congr_arg e\n  constructor\n  · intro x\n    rw [module.End_is_unit_iff]\n    constructor\n    · rintro a b (e : «expr • » x a = «expr • » x b)\n      simp_rw [Submonoid.smul_def, algebra.smul_def] at e\n      exact (h₁ x x.2).mul_left_cancel e\n    · intro a\n      refine' ⟨((h₁ x x.2).unit⁻¹ : _) * a, _⟩\n      change «expr • » (x : R) (_ * a) = _\n      rw [algebra.smul_def, ← mul_assoc, IsUnit.mul_val_inv, one_mul]\n  · exact h₂\n  · intros\n    dsimp\n    rw [eq_comm, ← sub_eq_zero, ← map_sub, h₃]\n    simp_rw [smul_sub, sub_eq_zero]\n#align mk_of_algebra mk_of_algebra\n\n",
 "mk_neg":
 "theorem mk_neg {M : Type _} [add_comm_group M] [Module R M] {m : M} {s : S} : mk (-m) s = -mk m s :=\n  rfl\n#align mk_neg mk_neg\n\n",
 "mk_mul_mk":
 "theorem mk_mul_mk {A : Type _} [Semiring A] [algebra R A] {a₁ a₂ : A} {s₁ s₂ : S} :\n    mk a₁ s₁ * mk a₂ s₂ = mk (a₁ * a₂) (s₁ * s₂) :=\n  rfl\n#align mk_mul_mk mk_mul_mk\n\n",
 "mk_eq_mk'":
 "theorem mk_eq_mk' (s : S) (m : M) : localized_module.mk m s = mk' (localized_module.mk_linear_map S M) m s := by\n  rw [eq_comm, mk'_eq_iff, Submonoid.smul_def, localized_module.smul'_mk, ← Submonoid.smul_def,\n    localized_module.mk_cancel, localized_module.mk_linear_map_apply]\n#align mk_eq_mk' mk_eq_mk'\n\n",
 "mk_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mk_eq {m m' : M} {s s' : S} :\n    mk m s = mk m' s' ↔ ∃ u : S, «expr • » u («expr • » s m') = «expr • » u («expr • » s' m) :=\n  quotient.eq\n#align mk_eq mk_eq\n\n",
 "mk_cancel_common_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mk_cancel_common_right (s s' : S) (m : M) : mk («expr • » s' m) (s * s') = mk m s :=\n  mk_eq.mpr ⟨1, by simp [mul_smul]⟩\n#align mk_cancel_common_right mk_cancel_common_right\n\n",
 "mk_cancel_common_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mk_cancel_common_left (s' s : S) (m : M) : mk («expr • » s' m) (s' * s) = mk m s :=\n  mk_eq.mpr\n    ⟨1, by\n      simp only [mul_smul, one_smul]\n      rw [smul_comm]⟩\n#align mk_cancel_common_left mk_cancel_common_left\n\n",
 "mk_cancel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mk_cancel (s : S) (m : M) : mk («expr • » s m) s = mk m 1 :=\n  mk_eq.mpr ⟨1, by simp⟩\n#align mk_cancel mk_cancel\n\n",
 "mk_add_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- Put everything in the same shape, sorting the terms using `simp`\ntheorem mk_add_mk {m1 m2 : M} {s1 s2 : S} : mk m1 s1 + mk m2 s2 = mk («expr • » s2 m1 + «expr • » s1 m2) (s1 * s2) :=\n  mk_eq.mpr <| ⟨1, by dsimp only <;> rw [one_smul]⟩\n#align mk_add_mk mk_add_mk\n\n",
 "mk'_zero":
 "@[simp]\ntheorem mk'_zero (s : S) : mk' f 0 s = 0 := by rw [← zero_smul R (0 : M), mk'_smul, zero_smul]\n#align mk'_zero mk'_zero\n\n",
 "mk'_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mk'_surjective : function.surjective (function.uncurry <| mk' f : M × S → M') :=\n  by\n  intro x\n  obtain ⟨⟨m, s⟩, e : «expr • » s x = f m⟩ := is_localized_module.surj S f x\n  exact ⟨⟨m, s⟩, mk'_eq_iff.mpr e.symm⟩\n#align mk'_surjective mk'_surjective\n\n",
 "mk'_sub_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mk'_sub_mk' {M M' : Type _} [add_comm_group M] [add_comm_group M'] [Module R M] [Module R M']\n    (f : «expr →ₗ[ ] » M R M') [is_localized_module S f] (m₁ m₂ : M) (s₁ s₂ : S) :\n    mk' f m₁ s₁ - mk' f m₂ s₂ = mk' f («expr • » s₂ m₁ - «expr • » s₁ m₂) (s₁ * s₂) := by\n  rw [sub_eq_add_neg, ← mk'_neg, mk'_add_mk', smul_neg, ← sub_eq_add_neg]\n#align mk'_sub_mk' mk'_sub_mk'\n\n",
 "mk'_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem mk'_sub {M M' : Type _} [add_comm_group M] [add_comm_group M'] [Module R M] [Module R M']\n    (f : «expr →ₗ[ ] » M R M') [is_localized_module S f] (m₁ m₂ : M) (s : S) :\n    mk' f (m₁ - m₂) s = mk' f m₁ s - mk' f m₂ s := by rw [sub_eq_add_neg, sub_eq_add_neg, mk'_add, mk'_neg]\n#align mk'_sub mk'_sub\n\n",
 "mk'_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mk'_smul (r : R) (m : M) (s : S) : mk' f («expr • » r m) s = «expr • » r (mk' f m s) :=\n  by\n  delta mk'\n  rw [← localized_module.smul'_mk, linear_map.map_smul]\n#align mk'_smul mk'_smul\n\n",
 "mk'_one":
 "@[simp]\ntheorem mk'_one (m : M) : mk' f m (1 : S) = f m := by\n  delta mk'\n  rw [from_localized_module_mk, module.End_algebra_map_is_unit_inv_apply_eq_iff, Submonoid.coe_one, one_smul]\n#align mk'_one mk'_one\n\n",
 "mk'_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem mk'_neg {M M' : Type _} [add_comm_group M] [add_comm_group M'] [Module R M] [Module R M']\n    (f : «expr →ₗ[ ] » M R M') [is_localized_module S f] (m : M) (s : S) : mk' f (-m) s = -mk' f m s :=\n  by\n  delta mk'\n  rw [localized_module.mk_neg, map_neg]\n#align mk'_neg mk'_neg\n\n",
 "mk'_mul_mk'_of_map_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem mk'_mul_mk'_of_map_mul {M M' : Type _} [Semiring M] [Semiring M'] [Module R M] [algebra R M']\n    (f : «expr →ₗ[ ] » M R M') (hf : ∀ m₁ m₂, f (m₁ * m₂) = f m₁ * f m₂) [is_localized_module S f] (m₁ m₂ : M)\n    (s₁ s₂ : S) : mk' f m₁ s₁ * mk' f m₂ s₂ = mk' f (m₁ * m₂) (s₁ * s₂) :=\n  by\n  symm\n  apply (module.End_algebra_map_is_unit_inv_apply_eq_iff _ _ _).mpr\n  simp_rw [Submonoid.coe_mul, ← smul_eq_mul]\n  rw [smul_smul_smul_comm, ← mk'_smul, ← mk'_smul]\n  simp_rw [← Submonoid.smul_def, mk'_cancel, smul_eq_mul, hf]\n#align mk'_mul_mk'_of_map_mul mk'_mul_mk'_of_map_mul\n\n",
 "mk'_mul_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem mk'_mul_mk' {M M' : Type _} [Semiring M] [Semiring M'] [algebra R M] [algebra R M'] (f : «expr →ₐ[ ] » M R M')\n    [is_localized_module S f.to_linear_map] (m₁ m₂ : M) (s₁ s₂ : S) :\n    mk' f.to_linear_map m₁ s₁ * mk' f.to_linear_map m₂ s₂ = mk' f.to_linear_map (m₁ * m₂) (s₁ * s₂) :=\n  mk'_mul_mk'_of_map_mul f.to_linear_map f.map_mul m₁ m₂ s₁ s₂\n#align mk'_mul_mk' mk'_mul_mk'\n\n",
 "mk'_eq_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mk'_eq_zero' {m : M} (s : S) : mk' f m s = 0 ↔ ∃ s' : S, «expr • » s' m = 0 := by\n  simp_rw [← mk'_zero f (1 : S), mk'_eq_mk'_iff, smul_zero, one_smul, eq_comm]\n#align mk'_eq_zero' mk'_eq_zero'\n\n",
 "mk'_eq_zero":
 "@[simp]\ntheorem mk'_eq_zero {m : M} (s : S) : mk' f m s = 0 ↔ f m = 0 := by rw [mk'_eq_iff, smul_zero]\n#align mk'_eq_zero mk'_eq_zero\n\n",
 "mk'_eq_mk'_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mk'_eq_mk'_iff (m₁ m₂ : M) (s₁ s₂ : S) :\n    mk' f m₁ s₁ = mk' f m₂ s₂ ↔ ∃ s : S, «expr • » s («expr • » s₁ m₂) = «expr • » s («expr • » s₂ m₁) :=\n  by\n  delta mk'\n  rw [(from_localized_module.inj S f).eq_iff, localized_module.mk_eq]\n#align mk'_eq_mk'_iff mk'_eq_mk'_iff\n\n",
 "mk'_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mk'_eq_iff {m : M} {s : S} {m' : M'} : mk' f m s = m' ↔ f m = «expr • » s m' := by\n  rw [← smul_inj f s, Submonoid.smul_def, ← mk'_smul, ← Submonoid.smul_def, mk'_cancel]\n#align mk'_eq_iff mk'_eq_iff\n\n",
 "mk'_cancel_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mk'_cancel_right (m : M) (s₁ s₂ : S) : mk' f («expr • » s₂ m) (s₁ * s₂) = mk' f m s₁ :=\n  by\n  delta mk'\n  rw [localized_module.mk_cancel_common_right]\n#align mk'_cancel_right mk'_cancel_right\n\n",
 "mk'_cancel_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mk'_cancel_left (m : M) (s₁ s₂ : S) : mk' f («expr • » s₁ m) (s₁ * s₂) = mk' f m s₂ :=\n  by\n  delta mk'\n  rw [localized_module.mk_cancel_common_left]\n#align mk'_cancel_left mk'_cancel_left\n\n",
 "mk'_cancel'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mk'_cancel' (m : M) (s : S) : «expr • » s (mk' f m s) = f m := by\n  rw [Submonoid.smul_def, ← mk'_smul, ← Submonoid.smul_def, mk'_cancel]\n#align mk'_cancel' mk'_cancel'\n\n",
 "mk'_cancel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mk'_cancel (m : M) (s : S) : mk' f («expr • » s m) s = f m :=\n  by\n  delta mk'\n  rw [localized_module.mk_cancel, ← mk'_one S f]\n  rfl\n#align mk'_cancel mk'_cancel\n\n",
 "mk'_add_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mk'_add_mk' (m₁ m₂ : M) (s₁ s₂ : S) :\n    mk' f m₁ s₁ + mk' f m₂ s₂ = mk' f («expr • » s₂ m₁ + «expr • » s₁ m₂) (s₁ * s₂) :=\n  by\n  delta mk'\n  rw [← map_add, localized_module.mk_add_mk]\n#align mk'_add_mk' mk'_add_mk'\n\n",
 "mk'_add":
 "theorem mk'_add (m₁ m₂ : M) (s : S) : mk' f (m₁ + m₂) s = mk' f m₁ s + mk' f m₂ s := by\n  rw [mk'_add_mk', ← smul_add, mk'_cancel_left]\n#align mk'_add mk'_add\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem lift_unique (g : «expr →ₗ[ ] » M R M'') (h : ∀ x : S, is_unit ((algebra_map R (module.End R M'')) x))\n    (l : «expr →ₗ[ ] » M' R M'') (hl : l.comp f = g) : lift S f g h = l :=\n  by\n  dsimp only [is_localized_module.lift]\n  rw [localized_module.lift_unique S g h (l.comp (iso S f).to_linear_map), linear_map.comp_assoc,\n    show (iso S f).to_linear_map.comp (iso S f).symm.to_linear_map = linear_map.id from _, linear_map.comp_id]\n  · rw [linear_equiv.comp_to_linear_map_symm_eq, linear_map.id_comp]\n  · rw [linear_map.comp_assoc, ← hl]\n    congr 1\n    ext x\n    erw [from_localized_module_mk, module.End_algebra_map_is_unit_inv_apply_eq_iff, one_smul]\n#align lift_unique lift_unique\n\n",
 "lift_on₂_mk":
 "theorem lift_on₂_mk {α : Type _} (f : M × S → M × S → α)\n    (wd : ∀ (p q p' q' : M × S) (h1 : p ≈ p') (h2 : q ≈ q'), f p q = f p' q') (m m' : M) (s s' : S) :\n    lift_on₂ (mk m s) (mk m' s') f wd = f ⟨m, s⟩ ⟨m', s'⟩ := by convert quotient.lift_on₂_mk f wd _ _\n#align lift_on₂_mk lift_on₂_mk\n\n",
 "lift_on_mk":
 "theorem lift_on_mk {α : Type _} {f : M × S → α} (wd : ∀ (p p' : M × S) (h1 : p ≈ p'), f p = f p') (m : M) (s : S) :\n    lift_on (mk m s) f wd = f ⟨m, s⟩ := by convert quotient.lift_on_mk f wd ⟨m, s⟩\n#align lift_on_mk lift_on_mk\n\n",
 "lift_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If `g` is a linear map `M → M''` such that all scalar multiplication by `s : S` is invertible, then\n`lift g m s = s⁻¹ • g m`.\n-/\ntheorem lift_mk (g : «expr →ₗ[ ] » M R M'') (h : ∀ x : S, is_unit ((algebra_map R (module.End R M'')) x)) (m : M)\n    (s : S) : localized_module.lift S g h (localized_module.mk m s) = (h s).unit⁻¹.1 (g m) :=\n  rfl\n#align lift_mk lift_mk\n\n",
 "lift_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem lift_comp (g : «expr →ₗ[ ] » M R M'') (h : ∀ x : S, is_unit ((algebra_map R (module.End R M'')) x)) :\n    (lift S f g h).comp f = g := by\n  dsimp only [is_localized_module.lift]\n  rw [linear_map.comp_assoc]\n  convert localized_module.lift_comp S g h\n  exact iso_symm_comp _ _\n#align lift_comp lift_comp\n\n",
 "lift'_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem lift'_smul (g : «expr →ₗ[ ] » M R M'') (h : ∀ x : S, is_unit ((algebra_map R (module.End R M'')) x)) (r : R)\n    (m) : «expr • » r (localized_module.lift' S g h m) = localized_module.lift' S g h («expr • » r m) :=\n  m.induction_on\n    (by\n      intro a b\n      rw [localized_module.lift'_mk, localized_module.smul'_mk, localized_module.lift'_mk]\n      generalize_proofs h1 h2\n      erw [← h1.unit⁻¹.1.map_smul, ← g.map_smul])\n#align lift'_smul lift'_smul\n\n",
 "lift'_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem lift'_mk (g : «expr →ₗ[ ] » M R M'') (h : ∀ x : S, is_unit ((algebra_map R (module.End R M'')) x)) (m : M)\n    (s : S) : localized_module.lift' S g h (localized_module.mk m s) = (h s).unit⁻¹.1 (g m) :=\n  rfl\n#align lift'_mk lift'_mk\n\n",
 "lift'_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem lift'_add (g : «expr →ₗ[ ] » M R M'') (h : ∀ x : S, is_unit ((algebra_map R (module.End R M'')) x)) (x y) :\n    localized_module.lift' S g h (x + y) = localized_module.lift' S g h x + localized_module.lift' S g h y :=\n  localized_module.induction_on₂\n    (by\n      intro a a' b b'\n      erw [localized_module.lift'_mk, localized_module.lift'_mk, localized_module.lift'_mk]\n      dsimp; generalize_proofs h1 h2 h3\n      erw [map_add, module.End_algebra_map_is_unit_inv_apply_eq_iff, smul_add, ← h2.unit⁻¹.1.map_smul, ←\n        h3.unit⁻¹.1.map_smul]\n      congr 1 <;> symm\n      erw [module.End_algebra_map_is_unit_inv_apply_eq_iff, mul_smul, ← map_smul]; rfl\n      erw [module.End_algebra_map_is_unit_inv_apply_eq_iff, mul_comm, mul_smul, ← map_smul]; rfl)\n    x y\n#align lift'_add lift'_add\n\n",
 "iso_symm_comp":
 "theorem iso_symm_comp : (iso S f).symm.to_linear_map.comp f = localized_module.mk_linear_map S M :=\n  by\n  ext m; rw [linear_map.comp_apply, localized_module.mk_linear_map_apply]\n  change (iso S f).symm _ = _; rw [iso_symm_apply']; exact one_smul _ _\n#align iso_symm_comp iso_symm_comp\n\n",
 "iso_symm_apply_aux":
 "theorem iso_symm_apply_aux (m : M') :\n    (iso S f).symm m =\n      localized_module.mk (is_localized_module.surj S f m).some.1 (is_localized_module.surj S f m).some.2 :=\n  by\n  generalize_proofs _ h2\n  apply_fun iso S f using linear_equiv.injective _\n  rw [linear_equiv.apply_symm_apply]\n  simp only [iso_apply, linear_map.to_fun_eq_coe, from_localized_module_mk]\n  erw [module.End_algebra_map_is_unit_inv_apply_eq_iff', h2.some_spec]\n#align iso_symm_apply_aux iso_symm_apply_aux\n\n",
 "iso_symm_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem iso_symm_apply' (m : M') (a : M) (b : S) (eq1 : «expr • » b m = f a) :\n    (iso S f).symm m = localized_module.mk a b :=\n  (iso_symm_apply_aux S f m).trans <|\n    localized_module.mk_eq.mpr <| by\n      generalize_proofs h1\n      erw [← is_localized_module.eq_iff_exists S f, f.map_smul, f.map_smul, ← h1.some_spec, ← mul_smul, mul_comm,\n        mul_smul, eq1]\n#align iso_symm_apply' iso_symm_apply'\n\n",
 "iso_apply_mk":
 "theorem iso_apply_mk (m : M) (s : S) :\n    iso S f (localized_module.mk m s) = (is_localized_module.map_units f s).unit⁻¹ (f m) :=\n  rfl\n#align iso_apply_mk iso_apply_mk\n\n",
 "is_universal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Universal property from localized module:\nIf `(M', f : M ⟶ M')` is a localized module then it satisfies the following universal property:\nFor every `R`-module `M''` which every `s : S`-scalar multiplication is invertible and for every\n`R`-linear map `g : M ⟶ M''`, there is a unique `R`-linear map `l : M' ⟶ M''` such that\n`l ∘ f = g`.\n```\nM -----f----> M'\n|           /\n|g       /\n|     /   l\nv   /\nM''\n```\n-/\ntheorem is_universal :\n    ∀ (g : «expr →ₗ[ ] » M R M'') (map_unit : ∀ x : S, is_unit ((algebra_map R (module.End R M'')) x)),\n      ∃! l : «expr →ₗ[ ] » M' R M'', l.comp f = g :=\n  fun g h => ⟨lift S f g h, lift_comp S f g h, fun l hl => (lift_unique S f g h l hl).symm⟩\n#align is_universal is_universal\n\n",
 "is_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/-\nCopyright (c) 2022 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang, Jujian Zhang\n-/\ntheorem r.is_equiv : is_equiv _ (r S M) :=\n  { refl := fun ⟨m, s⟩ => ⟨1, by rw [one_smul]⟩\n    trans := fun ⟨m1, s1⟩ ⟨m2, s2⟩ ⟨m3, s3⟩ ⟨u1, hu1⟩ ⟨u2, hu2⟩ =>\n      by\n      use u1 * u2 * s2\n      -- Put everything in the same shape, sorting the terms using `simp`\n      have hu1' := congr_arg ((«expr • » · ·) (u2 * s3)) hu1\n      have hu2' := congr_arg ((«expr • » · ·) (u1 * s1)) hu2\n      simp only [← mul_smul, smul_assoc, mul_assoc, mul_comm, mul_left_comm] at hu1' hu2'⊢\n      rw [hu2', hu1']\n    symm := fun ⟨m1, s1⟩ ⟨m2, s2⟩ ⟨u, hu⟩ => ⟨u, hu.symm⟩ }\n#align r.is_equiv r.is_equiv\n\n",
 "inj":
 "theorem from_localized_module.inj : function.injective <| from_localized_module S f := fun x y eq1 =>\n  by\n  induction' x using localized_module.induction_on with a b\n  induction' y using localized_module.induction_on with a' b'\n  simp only [from_localized_module_mk] at eq1\n  generalize_proofs h1 h2  at eq1\n  erw [module.End_algebra_map_is_unit_inv_apply_eq_iff, ← linear_map.map_smul,\n    module.End_algebra_map_is_unit_inv_apply_eq_iff'] at eq1\n  erw [localized_module.mk_eq, ← is_localized_module.eq_iff_exists S f, f.map_smul, f.map_smul, eq1]\n  rfl\n#align from_localized_module.inj from_localized_module.inj\n\n",
 "induction_on₂":
 "@[elab_as_elim]\ntheorem induction_on₂ {β : localized_module S M → localized_module S M → Prop}\n    (h : ∀ (m m' : M) (s s' : S), β (mk m s) (mk m' s')) : ∀ x y, β x y :=\n  by\n  rintro ⟨⟨m, s⟩⟩ ⟨⟨m', s'⟩⟩\n  exact h m m' s s'\n#align induction_on₂ induction_on₂\n\n",
 "induction_on":
 "@[elab_as_elim]\ntheorem induction_on {β : localized_module S M → Prop} (h : ∀ (m : M) (s : S), β (mk m s)) :\n    ∀ x : localized_module S M, β x := by\n  rintro ⟨⟨m, s⟩⟩\n  exact h m s\n#align induction_on induction_on\n\n",
 "from_localized_module_mk":
 "theorem from_localized_module_mk (m : M) (s : S) :\n    from_localized_module S f (localized_module.mk m s) = (is_localized_module.map_units f s).unit⁻¹ (f m) :=\n  rfl\n#align from_localized_module_mk from_localized_module_mk\n\n",
 "from_localized_module'_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem from_localized_module'_smul (r : R) (x : localized_module S M) :\n    «expr • » r (from_localized_module' S f x) = from_localized_module' S f («expr • » r x) :=\n  localized_module.induction_on\n    (by\n      intro a b\n      rw [from_localized_module'_mk, localized_module.smul'_mk, from_localized_module'_mk]\n      generalize_proofs h1; erw [f.map_smul, h1.unit⁻¹.1.map_smul]; rfl)\n    x\n#align from_localized_module'_smul from_localized_module'_smul\n\n",
 "from_localized_module'_mk":
 "@[simp]\ntheorem from_localized_module'_mk (m : M) (s : S) :\n    from_localized_module' S f (localized_module.mk m s) = (is_localized_module.map_units f s).unit⁻¹ (f m) :=\n  rfl\n#align from_localized_module'_mk from_localized_module'_mk\n\n",
 "from_localized_module'_add":
 "theorem from_localized_module'_add (x y : localized_module S M) :\n    from_localized_module' S f (x + y) = from_localized_module' S f x + from_localized_module' S f y :=\n  localized_module.induction_on₂\n    (by\n      intro a a' b b'\n      simp only [localized_module.mk_add_mk, from_localized_module'_mk]\n      generalize_proofs h1 h2 h3\n      erw [module.End_algebra_map_is_unit_inv_apply_eq_iff, smul_add, ← h2.unit⁻¹.1.map_smul, ← h3.unit⁻¹.1.map_smul,\n        map_add]\n      congr 1\n      all_goals erw [module.End_algebra_map_is_unit_inv_apply_eq_iff']\n      · dsimp\n        erw [mul_smul, f.map_smul]\n        rfl\n      · dsimp\n        erw [mul_comm, f.map_smul, mul_smul]\n        rfl)\n    x y\n#align from_localized_module'_add from_localized_module'_add\n\n",
 "eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem eq_zero_iff {m : M} : f m = 0 ↔ ∃ s' : S, «expr • » s' m = 0 :=\n  (mk'_eq_zero (1 : S)).symm.trans (mk'_eq_zero' f _)\n#align eq_zero_iff eq_zero_iff\n\n",
 "div_by_mul_by":
 "theorem div_by_mul_by (s : S) (p : localized_module S M) :\n    div_by s (algebra_map R (module.End R (localized_module S M)) s p) = p :=\n  p.induction_on\n    (by\n      intro m t\n      simp only [localized_module.lift_on_mk, module.algebra_map_End_apply, smul'_mk, div_by_apply]\n      erw [mk_cancel_common_left s t])\n#align div_by_mul_by div_by_mul_by\n\n",
 "bij":
 "theorem from_localized_module.bij : function.bijective <| from_localized_module S f :=\n  ⟨from_localized_module.inj _ _, from_localized_module.surj _ _⟩\n#align from_localized_module.bij from_localized_module.bij\n\n",
 "algebra_map_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem algebra_map_mk {A : Type _} [Semiring A] [algebra R A] (a : R) (s : S) :\n    algebra_map _ _ (localization.mk a s) = mk (algebra_map R A a) s :=\n  by\n  rw [algebra.algebra_map_eq_smul_one]\n  change «expr • » _ (mk _ _) = _\n  rw [mk_smul_mk, algebra.algebra_map_eq_smul_one, mul_one]\n#align algebra_map_mk algebra_map_mk\n\n",
 "add_zero'":
 "private theorem add_zero' (x : localized_module S M) : x + 0 = x :=\n  induction_on\n    (fun m s => by\n      rw [← zero_mk s, mk_add_mk, smul_zero, add_zero, mk_eq] <;> exact ⟨1, by rw [one_smul, mul_smul, one_smul]⟩)\n    x\n#align add_zero' add_zero'\n\n",
 "add_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprivate theorem add_smul' (x y : localization S) (z : localized_module S M) :\n    «expr • » (x + y) z = «expr • » x z + «expr • » y z :=\n  by\n  induction' x using localization.induction_on with datax\n  induction' y using localization.induction_on with datay\n  induction' z using localized_module.induction_on with m t\n  rcases datax, datay with ⟨⟨r, s⟩, ⟨r', s'⟩⟩\n  rw [localization.add_mk, mk_smul_mk, mk_smul_mk, mk_smul_mk, mk_add_mk, mk_eq]\n  use 1\n  simp only [one_smul, add_smul, smul_add, ← mul_smul, Submonoid.smul_def, Submonoid.coe_mul, Submonoid.coe_one]\n  rw [add_comm]\n  -- Commutativity of addition in the module is not applied by `ring`.\n  ring_nf\n#align add_smul' add_smul'\n\n",
 "add_comm'":
 "private theorem add_comm' (x y : localized_module S M) : x + y = y + x :=\n  localized_module.induction_on₂ (fun m m' s s' => by rw [mk_add_mk, mk_add_mk, add_comm, mul_comm]) x y\n#align add_comm' add_comm'\n\n",
 "add_assoc'":
 "private theorem add_assoc' (x y z : localized_module S M) : x + y + z = x + (y + z) :=\n  by\n  induction' x using localized_module.induction_on with mx sx\n  induction' y using localized_module.induction_on with my sy\n  induction' z using localized_module.induction_on with mz sz\n  simp only [mk_add_mk, smul_add]\n  refine' mk_eq.mpr ⟨1, _⟩\n  rw [one_smul, one_smul]\n  congr 1\n  · rw [mul_assoc]\n  · rw [mul_comm, add_assoc, mul_smul, mul_smul, ← mul_smul sx sz, mul_comm, mul_smul]\n#align add_assoc' add_assoc'\n\n"}