{"ι_ne_zero":
 "@[simp]\ntheorem ι_ne_zero [Nontrivial R] (x : X) : ι R x ≠ 0 :=\n  ι_ne_algebraMap x 0\n#align ι_ne_zero ι_ne_zero\n\n",
 "ι_ne_one":
 "@[simp]\ntheorem ι_ne_one [Nontrivial R] (x : X) : ι R x ≠ 1 :=\n  ι_ne_algebraMap x 1\n#align ι_ne_one ι_ne_one\n\n",
 "ι_ne_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem ι_ne_algebra_map [Nontrivial R] (x : X) (r : R) : ι R x ≠ algebraMap R _ r := fun h =>\n  by\n  let f0 : «expr →ₐ[ ] » (FreeAlgebra R X) R R := lift R 0\n  let f1 : «expr →ₐ[ ] » (FreeAlgebra R X) R R := lift R 1\n  have hf0 : f0 (ι R x) = 0 := lift_ι_apply _ _\n  have hf1 : f1 (ι R x) = 1 := lift_ι_apply _ _\n  rw [h, f0.commutes, Algebra.id.map_eq_self] at hf0\n  rw [h, f1.commutes, Algebra.id.map_eq_self] at hf1\n  exact zero_ne_one (hf0.symm.trans hf1)\n#align ι_ne_algebra_map ι_ne_algebra_map\n\n",
 "ι_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n-- this proof is copied from the approach in `free_abelian_group.of_injective`\ntheorem ι_injective [Nontrivial R] : function.injective (ι R : X → FreeAlgebra R X) := fun x y hoxy =>\n  by_contradiction <| by\n    classical exact fun hxy : x ≠ y =>\n        let f : «expr →ₐ[ ] » (FreeAlgebra R X) R R := lift R fun z => if x = z then (1 : R) else 0\n        have hfx1 : f (ι R x) = 1 := (lift_ι_apply _ _).trans <| if_pos rfl\n        have hfy1 : f (ι R y) = 1 := hoxy ▸ hfx1\n        have hfy0 : f (ι R y) = 0 := (lift_ι_apply _ _).trans <| if_neg hxy\n        one_ne_zero <| hfy1.symm.trans hfy0\n#align ι_injective ι_injective\n\n",
 "ι_inj":
 "@[simp]\ntheorem ι_inj [Nontrivial R] (x y : X) : ι R x = ι R y ↔ x = y :=\n  ι_injective.eq_iff\n#align ι_inj ι_inj\n\n",
 "ι_comp_lift":
 "@[simp]\ntheorem ι_comp_lift (f : X → A) : (lift R f : FreeAlgebra R X → A) ∘ ι R = f :=\n  by\n  ext\n  rw [ι, lift]\n  rfl\n#align ι_comp_lift ι_comp_lift\n\n",
 "quot_mk_eq_ι":
 "/-\nCopyright (c) 2020 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Adam Topaz\n-/\n-- Note: These instances are only used to simplify the notation.\n-- force `of_scalar` to be a central semiring morphism\n-- commutative additive semigroup\n-- multiplicative monoid\n-- distributivity\n-- other relations needed for semiring\n-- compatibility\n@[simp]\ntheorem quot_mk_eq_ι (m : X) : Quot.mk (FreeAlgebra.Rel R X) m = ι R m := by rw [ι]\n#align quot_mk_eq_ι quot_mk_eq_ι\n\n",
 "lift_ι_apply":
 "@[simp]\ntheorem lift_ι_apply (f : X → A) (x) : lift R f (ι R x) = f x :=\n  by\n  rw [ι, lift]\n  rfl\n#align lift_ι_apply lift_ι_apply\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem lift_unique (f : X → A) (g : «expr →ₐ[ ] » (FreeAlgebra R X) R A) :\n    (g : FreeAlgebra R X → A) ∘ ι R = f ↔ g = lift R f :=\n  by\n  rw [← (lift R).symm_apply_eq, lift]\n  rfl\n#align lift_unique lift_unique\n\n",
 "lift_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem lift_symm_apply (F : «expr →ₐ[ ] » (FreeAlgebra R X) R A) : (lift R).symm F = F ∘ ι R :=\n  by\n  rw [lift]\n  rfl\n#align lift_symm_apply lift_symm_apply\n\n",
 "lift_comp_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n-- Marking `free_algebra` irreducible makes `ring` instances inaccessible on quotients.\n-- https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/algebra.2Esemiring_to_ring.20breaks.20semimodule.20typeclass.20lookup/near/212580241\n-- For now, we avoid this by not marking it irreducible.\n@[simp]\ntheorem lift_comp_ι (g : «expr →ₐ[ ] » (FreeAlgebra R X) R A) : lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g :=\n  by\n  rw [← lift_symm_apply]\n  exact (lift R).apply_symm_apply g\n#align lift_comp_ι lift_comp_ι\n\n",
 "lift_aux_eq":
 "@[simp]\ntheorem lift_aux_eq (f : X → A) : lift_aux R f = lift R f :=\n  by\n  rw [lift]\n  rfl\n#align lift_aux_eq lift_aux_eq\n\n",
 "induction":
 "/- There is something weird in the above namespace that breaks the typeclass resolution of\n`has_coe_to_sort` below. Closing it and reopening it fixes it... -/\n/-- An induction principle for the free algebra.\n\nIf `C` holds for the `algebra_map` of `r : R` into `free_algebra R X`, the `ι` of `x : X`, and is\npreserved under addition and muliplication, then it holds for all of `free_algebra R X`.\n-/\n@[elab_as_elim]\ntheorem induction {C : FreeAlgebra R X → Prop} (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r))\n    (h_grade1 : ∀ x, C (ι R x)) (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))\n    (a : FreeAlgebra R X) : C a :=\n  by\n  -- the arguments are enough to construct a subalgebra, and a mapping into it from X\n  let s : Subalgebra R (FreeAlgebra R X) :=\n    { carrier := C\n      mul_mem' := h_mul\n      add_mem' := h_add\n      algebra_map_mem' := h_grade0 }\n  let of : X → s := Subtype.coind (ι R) h_grade1\n  -- the mapping through the subalgebra is the identity\n  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) :=\n    by\n    ext\n    simp [of, Subtype.coind]\n  -- finding a proof is finding an element of the subalgebra\n  convert Subtype.prop (lift R of a)\n  simp [AlgHom.ext_iff] at of_id\n  exact of_id a\n#align induction induction\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem hom_ext {f g : «expr →ₐ[ ] » (FreeAlgebra R X) R A}\n    (w : (f : FreeAlgebra R X → A) ∘ ι R = (g : FreeAlgebra R X → A) ∘ ι R) : f = g :=\n  by\n  rw [← lift_symm_apply, ← lift_symm_apply] at w\n  exact (lift R).symm.injective w\n#align hom_ext hom_ext\n\n",
 "algebra_map_left_inverse":
 "theorem algebra_map_left_inverse : function.left_inverse algebraMapInv (algebraMap R <| FreeAlgebra R X) := fun x => by\n  simp [algebra_map_inv]\n#align algebra_map_left_inverse algebra_map_left_inverse\n\n",
 "algebra_map_inj":
 "@[simp]\ntheorem algebra_map_inj (x y : R) : algebraMap R (FreeAlgebra R X) x = algebraMap R (FreeAlgebra R X) y ↔ x = y :=\n  algebraMap_leftInverse.injective.eq_iff\n#align algebra_map_inj algebra_map_inj\n\n",
 "algebra_map_eq_zero_iff":
 "@[simp]\ntheorem algebra_map_eq_zero_iff (x : R) : algebraMap R (FreeAlgebra R X) x = 0 ↔ x = 0 :=\n  map_eq_zero_iff (algebraMap _ _) algebraMap_leftInverse.injective\n#align algebra_map_eq_zero_iff algebra_map_eq_zero_iff\n\n",
 "algebra_map_eq_one_iff":
 "@[simp]\ntheorem algebra_map_eq_one_iff (x : R) : algebraMap R (FreeAlgebra R X) x = 1 ↔ x = 1 :=\n  map_eq_one_iff (algebraMap _ _) algebraMap_leftInverse.injective\n#align algebra_map_eq_one_iff algebra_map_eq_one_iff\n\n"}