{"support_sum_eq_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem support_sum_eq_bUnion {α : Type _} {ι : Type _} {M : Type _} [DecidableEq α] [AddCommMonoid M]\n    {g : ι → «expr →₀ » α M} (s : Finset ι) (h : ∀ i₁ i₂, i₁ ≠ i₂ → Disjoint (g i₁).support (g i₂).support) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (g i)).support =\n      s.bUnion fun i => (g i).support :=\n  by\n  classical\n    apply Finset.induction_on s\n    · simp\n    · intro i s hi\n      simp only [hi, sum_insert, not_false_iff, bUnion_insert]\n      intro hs\n      rw [Finsupp.support_add_eq, hs]\n      rw [hs, Finset.disjoint_bunionᵢ_right]\n      intro j hj\n      refine' h _ _ (ne_of_mem_of_not_mem hj hi).symm\n#align support_sum_eq_bUnion support_sum_eq_bUnion\n\n",
 "support_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem support_sum [DecidableEq β] [Zero M] [AddCommMonoid N] {f : «expr →₀ » α M} {g : α → M → «expr →₀ » β N} :\n    (f.sum g).support ⊆ f.support.bUnion fun a => (g a (f a)).support :=\n  by\n  have : ∀ c, (f.sum fun a b => g a b c) ≠ 0 → ∃ a, f a ≠ 0 ∧ ¬(g a (f a)) c = 0 := fun a₁ h =>\n    let ⟨a, ha, ne⟩ := Finset.exists_ne_zero_of_sum_ne_zero h\n    ⟨a, mem_support_iff.mp ha, ne⟩\n  simpa only [Finset.subset_iff, mem_support_iff, Finset.mem_bunionᵢ, sum_apply, exists_prop]\n#align support_sum support_sum\n\n",
 "support_finset_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem support_finset_sum [DecidableEq β] [AddCommMonoid M] {s : Finset α} {f : α → «expr →₀ » β M} :\n    (Finset.sum s f).support ⊆ s.bUnion fun x => (f x).support :=\n  by\n  rw [← Finset.sup_eq_bunionᵢ]\n  induction' s using Finset.cons_induction_on with a s ha ih\n  · rfl\n  · rw [Finset.sum_cons, Finset.sup_cons]\n    exact support_add.trans (Finset.union_subset_union (Finset.Subset.refl _) ih)\n#align support_finset_sum support_finset_sum\n\n",
 "sum_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem sum_zero [Zero M] [AddCommMonoid N] {f : «expr →₀ » α M} : (f.sum fun a b => (0 : N)) = 0 :=\n  Finset.sum_const_zero\n#align sum_zero sum_zero\n\n",
 "sum_univ_single'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n@[simp]\ntheorem sum_univ_single' [AddCommMonoid M] [Fintype α] (i : α) (m : M) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        ((single j m) i) =\n      m :=\n  by simp [single]\n#align sum_univ_single' sum_univ_single'\n\n",
 "sum_univ_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n@[simp]\ntheorem sum_univ_single [AddCommMonoid M] [Fintype α] (i : α) (m : M) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        ((single i m) j) =\n      m :=\n  by simp [single]\n#align sum_univ_single sum_univ_single\n\n",
 "sum_sum_index'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print Finsupp.sum_sum_index' /-\ntheorem Finsupp.sum_sum_index' :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x)).sum t =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s ((f x).sum t) :=\n  Finset.induction_on s rfl fun a s has ih => by simp_rw [Finset.sum_insert has, Finsupp.sum_add_index' h0 h1, ih]\n#align finsupp.sum_sum_index' Finsupp.sum_sum_index'\n-/\n\n",
 "sum_sub_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem sum_sub_index [AddCommGroup β] [AddCommGroup γ] {f g : «expr →₀ » α β} {h : α → β → γ}\n    (h_sub : ∀ a b₁ b₂, h a (b₁ - b₂) = h a b₁ - h a b₂) : (f - g).sum h = f.sum h - g.sum h :=\n  (liftAddHom fun a => AddMonoidHom.ofMapSub (h a) (h_sub a)).map_sub f g\n#align sum_sub_index sum_sub_index\n\n",
 "sum_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem sum_sub [Zero M] [AddCommGroup G] {f : «expr →₀ » α M} {h₁ h₂ : α → M → G} :\n    (f.sum fun a b => h₁ a b - h₂ a b) = f.sum h₁ - f.sum h₂ :=\n  Finset.sum_sub_distrib\n#align sum_sub sum_sub\n\n",
 "sum_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem sum_single [AddCommMonoid M] (f : «expr →₀ » α M) : f.sum single = f :=\n  AddMonoidHom.congr_fun liftAddHom_singleAddHom f\n#align sum_single sum_single\n\n",
 "sum_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print Finsupp.sum_mul /-\ntheorem Finsupp.sum_mul (b : S) (s : «expr →₀ » α R) {f : α → R → S} : s.sum f * b = s.sum fun a c => f a c * b := by\n  simp only [Finsupp.sum, Finset.sum_mul]\n#align finsupp.sum_mul Finsupp.sum_mul\n-/\n\n",
 "sum_ite_self_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem sum_ite_self_eq' [DecidableEq α] {N : Type _} [AddCommMonoid N] (f : «expr →₀ » α N) (a : α) :\n    (f.sum fun x v => ite (x = a) v 0) = f a := by\n  classical\n    convert f.sum_ite_eq' a fun x => id\n    simp [ite_eq_right_iff.2 Eq.symm]\n#align sum_ite_self_eq' sum_ite_self_eq'\n\n",
 "sum_ite_self_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem sum_ite_self_eq [DecidableEq α] {N : Type _} [AddCommMonoid N] (f : «expr →₀ » α N) (a : α) :\n    (f.sum fun x v => ite (a = x) v 0) = f a := by\n  classical\n    convert f.sum_ite_eq a fun x => id\n    simp [ite_eq_right_iff.2 Eq.symm]\n#align sum_ite_self_eq sum_ite_self_eq\n\n",
 "sum_hom_add_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n@[simp]\ntheorem sum_hom_add_index [AddZeroClass M] [AddCommMonoid N] {f g : «expr →₀ » α M} (h : α → «expr →+ » M N) :\n    ((f + g).sum fun x => h x) = (f.sum fun x => h x) + g.sum fun x => h x :=\n  sum_add_index' (fun a => (h a).map_zero) fun a => (h a).map_add\n#align sum_hom_add_index sum_hom_add_index\n\n",
 "sum_apply'":
 "#print Finsupp.sum_apply' /-\ntheorem Finsupp.sum_apply' : g.sum k x = g.sum fun i b => k i b x :=\n  Finset.sum_apply _ _ _\n#align finsupp.sum_apply' Finsupp.sum_apply'\n-/\n\n",
 "sum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem sum_apply [Zero M] [AddCommMonoid N] {f : «expr →₀ » α M} {g : α → M → «expr →₀ » β N} {a₂ : β} :\n    (f.sum g) a₂ = f.sum fun a₁ b => g a₁ b a₂ :=\n  finset_sum_apply _ _ _\n#align sum_apply sum_apply\n\n",
 "single_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem single_sum [Zero M] [AddCommMonoid N] (s : «expr →₀ » ι M) (f : ι → M → N) (a : α) :\n    single a (s.sum f) = s.sum fun d c => single a (f d c) :=\n  single_finset_sum _ _ _\n#align single_sum single_sum\n\n",
 "single_multiset_sum":
 "theorem single_multiset_sum [AddCommMonoid M] (s : Multiset M) (a : α) : single a s.sum = (s.map (single a)).sum :=\n  Multiset.induction_on s (single_zero _) fun a s ih => by\n    rw [Multiset.sum_cons, single_add, ih, Multiset.map_cons, Multiset.sum_cons]\n#align single_multiset_sum single_multiset_sum\n\n",
 "single_finset_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem single_finset_sum [AddCommMonoid M] (s : Finset ι) (f : ι → M) (a : α) :\n    single a (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f b)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (single a (f b)) :=\n  by\n  trans\n  apply single_multiset_sum\n  rw [Multiset.map_map]\n  rfl\n#align single_finset_sum single_finset_sum\n\n",
 "prod_zero_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp, to_additive]\ntheorem prod_zero_index {h : α → M → N} : (0 : «expr →₀ » α M).prod h = 1 :=\n  rfl\n#align prod_zero_index prod_zero_index\n\n",
 "prod_sum_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[to_additive]\ntheorem prod_sum_index [AddCommMonoid M] [AddCommMonoid N] [CommMonoid P] {f : «expr →₀ » α M}\n    {g : α → M → «expr →₀ » β N} {h : β → N → P} (h_zero : ∀ a, h a 0 = 1)\n    (h_add : ∀ a b₁ b₂, h a (b₁ + b₂) = h a b₁ * h a b₂) : (f.sum g).prod h = f.prod fun a b => (g a b).prod h :=\n  (prod_finset_sum_index h_zero h_add).symm\n#align prod_sum_index prod_sum_index\n\n",
 "prod_single_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_single_index {a : α} {b : M} {h : α → M → N} (h_zero : h a 0 = 1) : (single a b).prod h = h a b :=\n  calc\n    (single a b).prod h =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" {a}\n          (h x (single a b x)) :=\n      prod_of_support_subset _ support_single_subset h fun x hx => (mem_singleton.1 hx).symm ▸ h_zero\n    _ = h a b := by simp\n    \n#align prod_single_index prod_single_index\n\n",
 "prod_pow_pos_of_zero_not_mem_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- If `0 : ℕ` is not in the support of `f : ℕ →₀ ℕ` then `0 < ∏ x in f.support, x ^ (f x)`. -/\ntheorem prod_pow_pos_of_zero_not_mem_support {f : «expr →₀ » ℕ ℕ} (hf : 0 ∉ f.support) : 0 < f.prod pow :=\n  Finset.prod_pos fun a ha =>\n    pos_iff_ne_zero.mpr\n      (pow_ne_zero _ fun H => by\n        subst H\n        exact hf ha)\n#align prod_pow_pos_of_zero_not_mem_support prod_pow_pos_of_zero_not_mem_support\n\n",
 "prod_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[simp]\ntheorem prod_pow [Fintype α] (f : «expr →₀ » α ℕ) (g : α → N) :\n    (f.prod fun a b => g a ^ b) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (g a ^ f a) :=\n  f.prod_fintype _ fun a => pow_zero _\n#align prod_pow prod_pow\n\n",
 "prod_of_support_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\n@[to_additive]\ntheorem prod_of_support_subset (f : «expr →₀ » α M) {s : Finset α} (hs : f.support ⊆ s) (g : α → M → N)\n    (h : ∀ i ∈ s, g i 0 = 1) :\n    f.prod g =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g x (f x)) :=\n  Finset.prod_subset hs fun x hxs hx => h x hxs ▸ congr_arg (g x) <| not_mem_support_iff.1 hx\n#align prod_of_support_subset prod_of_support_subset\n\n",
 "prod_neg_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[to_additive]\ntheorem prod_neg_index [AddGroup G] [CommMonoid M] {g : «expr →₀ » α G} {h : α → G → M} (h0 : ∀ a, h a 0 = 1) :\n    (-g).prod h = g.prod fun a b => h a (-b) :=\n  prod_mapRange_index h0\n#align prod_neg_index prod_neg_index\n\n",
 "prod_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp, to_additive]\ntheorem prod_mul [Zero M] [CommMonoid N] {f : «expr →₀ » α M} {h₁ h₂ : α → M → N} :\n    (f.prod fun a b => h₁ a b * h₂ a b) = f.prod h₁ * f.prod h₂ :=\n  Finset.prod_mul_distrib\n#align prod_mul prod_mul\n\n",
 "prod_map_range_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[to_additive]\ntheorem prod_map_range_index {f : M → M'} {hf : f 0 = 0} {g : «expr →₀ » α M} {h : α → M' → N} (h0 : ∀ a, h a 0 = 1) :\n    (mapRange f hf g).prod h = g.prod fun a b => h a (f b) :=\n  Finset.prod_subset support_mapRange fun _ _ H => by rw [not_mem_support_iff.1 H, h0]\n#align prod_map_range_index prod_map_range_index\n\n",
 "prod_ite_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- A restatement of `prod_ite_eq` with the equality test reversed. -/\n@[simp, to_additive \"A restatement of `sum_ite_eq` with the equality test reversed.\"]\ntheorem prod_ite_eq' [DecidableEq α] (f : «expr →₀ » α M) (a : α) (b : α → M → N) :\n    (f.prod fun x v => ite (x = a) (b x v) 1) = ite (a ∈ f.support) (b a (f a)) 1 :=\n  by\n  dsimp [Finsupp.prod]\n  rw [f.support.prod_ite_eq']\n#align prod_ite_eq' prod_ite_eq'\n\n",
 "prod_ite_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp, to_additive]\ntheorem prod_ite_eq [DecidableEq α] (f : «expr →₀ » α M) (a : α) (b : α → M → N) :\n    (f.prod fun x v => ite (a = x) (b x v) 1) = ite (a ∈ f.support) (b a (f a)) 1 :=\n  by\n  dsimp [Finsupp.prod]\n  rw [f.support.prod_ite_eq]\n#align prod_ite_eq prod_ite_eq\n\n",
 "prod_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp, to_additive]\ntheorem prod_inv [Zero M] [CommGroup G] {f : «expr →₀ » α M} {h : α → M → G} :\n    (f.prod fun a b => (h a b)⁻¹) = (f.prod h)⁻¹ :=\n  (map_prod (MonoidHom.id G)⁻¹ _ _).symm\n#align prod_inv prod_inv\n\n",
 "prod_indicator_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_indicator_index [Zero M] [CommMonoid N] {s : Finset α} (f : ∀ a ∈ s, M) {h : α → M → N}\n    (h_zero : ∀ a ∈ s, h a 0 = 1) :\n    (indicator s f).prod h =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s.attach\n        (h x (f x x.2)) :=\n  by\n  rw [prod_of_support_subset _ (support_indicator_subset _ _) h h_zero, ← prod_attach]\n  refine' Finset.prod_congr rfl fun x hx => _\n  rw [indicator_of_mem]\n#align prod_indicator_index prod_indicator_index\n\n",
 "prod_hom_add_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp]\ntheorem prod_hom_add_index [AddZeroClass M] [CommMonoid N] {f g : «expr →₀ » α M}\n    (h : α → «expr →* » (Multiplicative M) N) :\n    ((f + g).prod fun a b => h a (Multiplicative.ofAdd b)) =\n      (f.prod fun a b => h a (Multiplicative.ofAdd b)) * g.prod fun a b => h a (Multiplicative.ofAdd b) :=\n  prod_add_index' (fun a => (h a).map_one) fun a => (h a).map_mul\n#align prod_hom_add_index prod_hom_add_index\n\n",
 "prod_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[to_additive]\ntheorem prod_fintype [Fintype α] (f : «expr →₀ » α M) (g : α → M → N) (h : ∀ i, g i 0 = 1) :\n    f.prod g =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (g i (f i)) :=\n  f.prod_of_support_subset (subset_univ _) g fun x _ => h x\n#align prod_fintype prod_fintype\n\n",
 "prod_finset_sum_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[to_additive]\ntheorem prod_finset_sum_index [AddCommMonoid M] [CommMonoid N] {s : Finset ι} {g : ι → «expr →₀ » α M} {h : α → M → N}\n    (h_zero : ∀ a, h a 0 = 1) (h_add : ∀ a b₁ b₂, h a (b₁ + b₂) = h a b₁ * h a b₂) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s ((g i).prod h) =\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (g i)).prod\n        h :=\n  Finset.cons_induction_on s rfl fun a s has ih => by rw [prod_cons, ih, sum_cons, prod_add_index' h_zero h_add]\n#align prod_finset_sum_index prod_finset_sum_index\n\n",
 "prod_emb_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n@[to_additive]\ntheorem prod_emb_domain [Zero M] [CommMonoid N] {v : «expr →₀ » α M} {f : «expr ↪ » α β} {g : β → M → N} :\n    (v.emb_domain f).prod g = v.prod fun a b => g (f a) b :=\n  by\n  rw [Prod, Prod, support_emb_domain, Finset.prod_map]\n  simp_rw [emb_domain_apply]\n#align prod_emb_domain prod_emb_domain\n\n",
 "prod_dvd_prod_of_subset_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem prod_dvd_prod_of_subset_of_dvd [AddCommMonoid M] [CommMonoid N] {f1 f2 : «expr →₀ » α M} {g1 g2 : α → M → N}\n    (h1 : f1.support ⊆ f2.support) (h2 : ∀ a : α, a ∈ f1.support → g1 a (f1 a) ∣ g2 a (f2 a)) :\n    f1.prod g1 ∣ f2.prod g2 := by\n  classical\n    simp only [Finsupp.prod, Finsupp.prod_mul]\n    rw [← sdiff_union_of_subset h1, prod_union sdiff_disjoint]\n    apply dvd_mul_of_dvd_right\n    apply prod_dvd_prod_of_dvd\n    exact h2\n#align prod_dvd_prod_of_subset_of_dvd prod_dvd_prod_of_subset_of_dvd\n\n",
 "prod_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[to_additive]\ntheorem prod_congr {f : «expr →₀ » α M} {g1 g2 : α → M → N} (h : ∀ x ∈ f.support, g1 x (f x) = g2 x (f x)) :\n    f.prod g1 = f.prod g2 :=\n  Finset.prod_congr rfl h\n#align prod_congr prod_congr\n\n",
 "prod_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[to_additive]\ntheorem prod_comm (f : «expr →₀ » α M) (g : «expr →₀ » β M') (h : α → M → β → M' → N) :\n    (f.prod fun x v => g.prod fun x' v' => h x v x' v') = g.prod fun x' v' => f.prod fun x v => h x v x' v' :=\n  Finset.prod_comm\n#align prod_comm prod_comm\n\n",
 "prod_add_index_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- For disjoint `f1` and `f2`, and function `g`, the product of the products of `g`\nover `f1` and `f2` equals the product of `g` over `f1 + f2` -/\n@[to_additive\n      \"For disjoint `f1` and `f2`, and function `g`, the sum of the sums of `g`\\nover `f1` and `f2` equals the sum of `g` over `f1 + f2`\"]\ntheorem prod_add_index_of_disjoint [AddCommMonoid M] {f1 f2 : «expr →₀ » α M} (hd : Disjoint f1.support f2.support)\n    {β : Type _} [CommMonoid β] (g : α → M → β) : (f1 + f2).prod g = f1.prod g * f2.prod g :=\n  by\n  have :\n    ∀ {f1 f2 : «expr →₀ » α M},\n      Disjoint f1.support f2.support →\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" f1.support\n            (g x (f1 x + f2 x)) =\n          f1.prod g :=\n    fun f1 f2 hd =>\n    Finset.prod_congr rfl fun x hx => by simp only [not_mem_support_iff.mp (disjoint_left.mp hd hx), add_zero]\n  classical simp_rw [← this hd, ← this hd.symm, add_comm (f2 _), Finsupp.prod, support_add_eq hd, prod_union hd,\n      add_apply]\n#align prod_add_index_of_disjoint prod_add_index_of_disjoint\n\n",
 "prod_add_index'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- Taking the product under `h` is an additive-to-multiplicative homomorphism of finsupps,\nif `h` is an additive-to-multiplicative homomorphism.\nThis is a more specialized version of `finsupp.prod_add_index` with simpler hypotheses. -/\n@[to_additive\n      \"Taking the sum under `h` is an additive homomorphism of finsupps,\\nif `h` is an additive homomorphism.\\nThis is a more specific version of `finsupp.sum_add_index` with simpler hypotheses.\"]\ntheorem prod_add_index' [AddZeroClass M] [CommMonoid N] {f g : «expr →₀ » α M} {h : α → M → N} (h_zero : ∀ a, h a 0 = 1)\n    (h_add : ∀ a b₁ b₂, h a (b₁ + b₂) = h a b₁ * h a b₂) : (f + g).prod h = f.prod h * g.prod h := by\n  classical exact prod_add_index (fun a ha => h_zero a) fun a ha => h_add a\n#align prod_add_index' prod_add_index'\n\n",
 "prod_add_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- Taking the product under `h` is an additive-to-multiplicative homomorphism of finsupps,\nif `h` is an additive-to-multiplicative homomorphism on the support.\nThis is a more general version of `finsupp.prod_add_index'`; the latter has simpler hypotheses. -/\n@[to_additive\n      \"Taking the product under `h` is an additive homomorphism of finsupps,\\nif `h` is an additive homomorphism on the support.\\nThis is a more general version of `finsupp.sum_add_index'`; the latter has simpler hypotheses.\"]\ntheorem prod_add_index [DecidableEq α] [AddZeroClass M] [CommMonoid N] {f g : «expr →₀ » α M} {h : α → M → N}\n    (h_zero : ∀ a ∈ f.support ∪ g.support, h a 0 = 1)\n    (h_add : ∀ a ∈ f.support ∪ g.support, ∀ (b₁ b₂), h a (b₁ + b₂) = h a b₁ * h a b₂) :\n    (f + g).prod h = f.prod h * g.prod h :=\n  by\n  rw [Finsupp.prod_of_support_subset f (subset_union_left _ g.support) h h_zero,\n    Finsupp.prod_of_support_subset g (subset_union_right f.support _) h h_zero, ← Finset.prod_mul_distrib,\n    Finsupp.prod_of_support_subset (f + g) Finsupp.support_add h h_zero]\n  exact Finset.prod_congr rfl fun x hx => by apply h_add x hx\n#align prod_add_index prod_add_index\n\n",
 "on_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If `g` maps a second argument of 0 to 1, then multiplying it over the\nresult of `on_finset` is the same as multiplying it over the original\n`finset`. -/\n@[to_additive\n      \"If `g` maps a second argument of 0 to 0, summing it over the\\nresult of `on_finset` is the same as summing it over the original\\n`finset`.\"]\ntheorem on_finset_prod {s : Finset α} {f : α → M} {g : α → M → N} (hf : ∀ a, f a ≠ 0 → a ∈ s) (hg : ∀ a, g a 0 = 1) :\n    (onFinset s f hf).prod g =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g a (f a)) :=\n  Finset.prod_subset support_onFinset_subset <| by simp (config := { contextual := true }) [*]\n#align on_finset_prod on_finset_prod\n\n",
 "multiset_sum_sum_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem multiset_sum_sum_index [AddCommMonoid M] [AddCommMonoid N] (f : Multiset («expr →₀ » α M)) (h : α → M → N)\n    (h₀ : ∀ a, h a 0 = 0) (h₁ : ∀ (a : α) (b₁ b₂ : M), h a (b₁ + b₂) = h a b₁ + h a b₂) :\n    f.sum.sum h = (f.map fun g : «expr →₀ » α M => g.sum h).sum :=\n  Multiset.induction_on f rfl fun a s ih => by\n    rw [Multiset.sum_cons, Multiset.map_cons, Multiset.sum_cons, sum_add_index' h₀ h₁, ih]\n#align multiset_sum_sum_index multiset_sum_sum_index\n\n",
 "multiset_sum_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem multiset_sum_sum [Zero M] [AddCommMonoid N] {f : «expr →₀ » α M} {h : α → M → Multiset N} :\n    Multiset.sum (f.sum h) = f.sum fun a b => Multiset.sum (h a b) :=\n  (Multiset.sumAddMonoidHom : «expr →+ » (Multiset N) N).map_sum _ f.support\n#align multiset_sum_sum multiset_sum_sum\n\n",
 "multiset_map_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem multiset_map_sum [Zero M] {f : «expr →₀ » α M} {m : β → γ} {h : α → M → Multiset β} :\n    Multiset.map m (f.sum h) = f.sum fun a b => (h a b).map m :=\n  (Multiset.mapAddMonoidHom m).map_sum _ f.support\n#align multiset_map_sum multiset_map_sum\n\n",
 "mul_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print Finsupp.mul_sum /-\ntheorem Finsupp.mul_sum (b : S) (s : «expr →₀ » α R) {f : α → R → S} : b * s.sum f = s.sum fun a c => b * f a c := by\n  simp only [Finsupp.sum, Finset.mul_sum]\n#align finsupp.mul_sum Finsupp.mul_sum\n-/\n\n",
 "mul_prod_erase'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- Generalization of `finsupp.mul_prod_erase`: if `g` maps a second argument of 0 to 1,\nthen its product over `f : α →₀ M` is the same as multiplying the value on any element\n`y : α` by the product over `erase y f`. -/\n@[to_additive\n      \" Generalization of `finsupp.add_sum_erase`: if `g` maps a second argument of 0\\nto 0, then its sum over `f : α →₀ M` is the same as adding the value on any element\\n`y : α` to the sum over `erase y f`. \"]\ntheorem mul_prod_erase' (f : «expr →₀ » α M) (y : α) (g : α → M → N) (hg : ∀ i : α, g i 0 = 1) :\n    g y (f y) * (erase y f).prod g = f.prod g := by\n  classical\n    by_cases hyf : y ∈ f.support\n    · exact Finsupp.mul_prod_erase f y g hyf\n    · rw [not_mem_support_iff.mp hyf, hg y, erase_of_not_mem_support hyf, one_mul]\n#align mul_prod_erase' mul_prod_erase'\n\n",
 "mul_prod_erase":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- Taking a product over `f : α →₀ M` is the same as multiplying the value on a single element\n`y ∈ f.support` by the product over `erase y f`. -/\n@[to_additive\n      \" Taking a sum over over `f : α →₀ M` is the same as adding the value on a\\nsingle element `y ∈ f.support` to the sum over `erase y f`. \"]\ntheorem mul_prod_erase (f : «expr →₀ » α M) (y : α) (g : α → M → N) (hyf : y ∈ f.support) :\n    g y (f y) * (erase y f).prod g = f.prod g := by\n  classical\n    rw [Finsupp.prod, Finsupp.prod, ← Finset.mul_prod_erase _ _ hyf, Finsupp.support_erase, Finset.prod_congr rfl]\n    intro h hx\n    rw [Finsupp.erase_ne (ne_of_mem_erase hx)]\n#align mul_prod_erase mul_prod_erase\n\n",
 "map_finsupp_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print RingHom.map_finsupp_sum /-\n/-- Deprecated, use `_root_.map_finsupp_sum` instead. -/\nprotected theorem RingHom.map_finsupp_sum [Zero M] [Semiring R] [Semiring S] (h : «expr →+* » R S) (f : «expr →₀ » α M)\n    (g : α → M → R) : h (f.sum g) = f.sum fun a b => h (g a b) :=\n  map_finsupp_sum h f g\n#align ring_hom.map_finsupp_sum RingHom.map_finsupp_sum\n-/\n\n",
 "map_finsupp_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print RingHom.map_finsupp_prod /-\n/-- Deprecated, use `_root_.map_finsupp_prod` instead. -/\nprotected theorem RingHom.map_finsupp_prod [Zero M] [CommSemiring R] [CommSemiring S] (h : «expr →+* » R S)\n    (f : «expr →₀ » α M) (g : α → M → R) : h (f.prod g) = f.prod fun a b => h (g a b) :=\n  map_finsupp_prod h f g\n#align ring_hom.map_finsupp_prod RingHom.map_finsupp_prod\n-/\n\n",
 "lift_add_hom_symm_apply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem lift_add_hom_symm_apply_apply [AddCommMonoid M] [AddCommMonoid N] (F : «expr →+ » («expr →₀ » α M) N) (x : α)\n    (y : M) : liftAddHom.symm F x y = F (single x y) :=\n  rfl\n#align lift_add_hom_symm_apply_apply lift_add_hom_symm_apply_apply\n\n",
 "lift_add_hom_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem lift_add_hom_symm_apply [AddCommMonoid M] [AddCommMonoid N] (F : «expr →+ » («expr →₀ » α M) N) (x : α) :\n    liftAddHom.symm F x = F.comp (singleAddHom x) :=\n  rfl\n#align lift_add_hom_symm_apply lift_add_hom_symm_apply\n\n",
 "lift_add_hom_single_add_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem lift_add_hom_single_add_hom [AddCommMonoid M] :\n    liftAddHom (singleAddHom : α → «expr →+ » M («expr →₀ » α M)) = AddMonoidHom.id _ :=\n  liftAddHom.to_equiv.apply_eq_iff_eq_symm_apply.2 rfl\n#align lift_add_hom_single_add_hom lift_add_hom_single_add_hom\n\n",
 "lift_add_hom_comp_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n@[simp]\ntheorem lift_add_hom_comp_single [AddCommMonoid M] [AddCommMonoid N] (f : α → «expr →+ » M N) (a : α) :\n    (liftAddHom f).comp (singleAddHom a) = f a :=\n  AddMonoidHom.ext fun b => liftAddHom_apply_single f a b\n#align lift_add_hom_comp_single lift_add_hom_comp_single\n\n",
 "lift_add_hom_apply_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n@[simp]\ntheorem lift_add_hom_apply_single [AddCommMonoid M] [AddCommMonoid N] (f : α → «expr →+ » M N) (a : α) (b : M) :\n    liftAddHom f (single a b) = f a b :=\n  sum_single_index (f a).map_zero\n#align lift_add_hom_apply_single lift_add_hom_apply_single\n\n",
 "lift_add_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem lift_add_hom_apply [AddCommMonoid M] [AddCommMonoid N] (F : α → «expr →+ » M N) (f : «expr →₀ » α M) :\n    liftAddHom F f = f.sum fun x => F x :=\n  rfl\n#align lift_add_hom_apply lift_add_hom_apply\n\n",
 "indicator_eq_sum_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem indicator_eq_sum_single [AddCommMonoid M] (s : Finset α) (f : ∀ a ∈ s, M) :\n    indicator s f =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.attach\n        (single x (f x x.2)) :=\n  by\n  rw [← sum_single (indicator s f), Sum, sum_subset (support_indicator_subset _ _), ← sum_attach]\n  · refine' Finset.sum_congr rfl fun x hx => _\n    rw [indicator_of_mem]\n  intro i _ hi\n  rw [not_mem_support_iff.mp hi, single_zero]\n#align indicator_eq_sum_single indicator_eq_sum_single\n\n",
 "finsupp_prod_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print SubmonoidClass.finsupp_prod_mem /-\n@[to_additive]\ntheorem SubmonoidClass.finsupp_prod_mem {S : Type _} [SetLike S N] [SubmonoidClass S N] (s : S) (f : «expr →₀ » α M)\n    (g : α → M → N) (h : ∀ c, f c ≠ 0 → g c (f c) ∈ s) : f.prod g ∈ s :=\n  prod_mem fun i hi => h _ (Finsupp.mem_support_iff.mp hi)\n#align submonoid_class.finsupp_prod_mem SubmonoidClass.finsupp_prod_mem\n#align add_submonoid_class.finsupp_sum_mem AddSubmonoidClass.finsupp_sum_mem\n-/\n\n",
 "finsupp_prod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidHom.finsupp_prod_apply /-\n@[simp, to_additive]\ntheorem MonoidHom.finsupp_prod_apply [Zero β] [Monoid N] [CommMonoid P] (f : «expr →₀ » α β)\n    (g : α → β → «expr →* » N P) (x : N) : f.prod g x = f.prod fun i fi => g i fi x :=\n  MonoidHom.finset_prod_apply _ _ _\n#align monoid_hom.finsupp_prod_apply MonoidHom.finsupp_prod_apply\n#align add_monoid_hom.finsupp_sum_apply AddMonoidHom.finsupp_sum_apply\n-/\n\n",
 "finset_sum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem finset_sum_apply [AddCommMonoid N] (S : Finset ι) (f : ι → «expr →₀ » α N) (a : α) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" S (f i)) a =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" S (f i a) :=\n  (applyAddHom a : «expr →+ » («expr →₀ » α N) _).map_sum _ _\n#align finset_sum_apply finset_sum_apply\n\n",
 "comp_lift_add_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\ntheorem comp_lift_add_hom [AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P] (g : «expr →+ » N P)\n    (f : α → «expr →+ » M N) : g.comp (liftAddHom f) = liftAddHom fun a => g.comp (f a) :=\n  liftAddHom.symm_apply_eq.1 <|\n    funext fun a => by rw [lift_add_hom_symm_apply, AddMonoidHom.comp_assoc, lift_add_hom_comp_single]\n#align comp_lift_add_hom comp_lift_add_hom\n\n",
 "coe_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_sum [Zero M] [AddCommMonoid N] (f : «expr →₀ » α M) (g : α → M → «expr →₀ » β N) :\n    «expr⇑ » (f.sum g) = f.sum fun a₁ b => g a₁ b :=\n  coe_finset_sum _ _\n#align coe_sum coe_sum\n\n",
 "coe_finsupp_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print MonoidHom.coe_finsupp_prod /-\n@[to_additive]\ntheorem MonoidHom.coe_finsupp_prod [Zero β] [Monoid N] [CommMonoid P] (f : «expr →₀ » α β)\n    (g : α → β → «expr →* » N P) : «expr⇑ » (f.prod g) = f.prod fun i fi => g i fi :=\n  MonoidHom.coe_finset_prod _ _\n#align monoid_hom.coe_finsupp_prod MonoidHom.coe_finsupp_prod\n#align add_monoid_hom.coe_finsupp_sum AddMonoidHom.coe_finsupp_sum\n-/\n\n",
 "coe_finset_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem coe_finset_sum [AddCommMonoid N] (S : Finset ι) (f : ι → «expr →₀ » α N) :\n    «expr⇑ » (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" S (f i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" S (f i) :=\n  (coeFnAddHom : «expr →+ » («expr →₀ » α N) _).map_sum _ _\n#align coe_finset_sum coe_finset_sum\n\n"}