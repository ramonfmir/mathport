{"unop_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem unop_sum [AddCommMonoid β] {s : Finset α} (f : α → «expr ᵐᵒᵖ» β) :\n    unop (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (unop (f x)) :=\n  (opAddEquiv : «expr ≃+ » β («expr ᵐᵒᵖ» β)).symm.map_sum _ _\n#align unop_sum unop_sum\n\n",
 "unop_map_list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n#print RingHom.unop_map_list_prod /-\n/-- A morphism into the opposite ring acts on the product by acting on the reversed elements.\n\nDeprecated: use `_root_.unop_map_list_prod` instead.\n-/\nprotected theorem RingHom.unop_map_list_prod [Semiring β] [Semiring γ] (f : «expr →+* » β («expr ᵐᵒᵖ» γ)) (l : List β) :\n    MulOpposite.unop (f l.prod) = (l.map (MulOpposite.unop ∘ f)).reverse.prod :=\n  unop_map_list_prod f l\n#align ring_hom.unop_map_list_prod RingHom.unop_map_list_prod\n-/\n\n",
 "to_finset_sum_count_nsmul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_finset_sum_count_nsmul_eq (s : Multiset α) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.to_finset\n        («expr • » (s.count a) {a}) =\n      s :=\n  by rw [← Finset.sum_multiset_map_count, Multiset.sum_map_singleton]\n#align to_finset_sum_count_nsmul_eq to_finset_sum_count_nsmul_eq\n\n",
 "to_finset_sum_count_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem to_finset_sum_count_eq (s : Multiset α) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.to_finset\n        (s.count a) =\n      s.card :=\n  calc\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.to_finset\n          (s.count a) =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.to_finset\n          («expr • » (s.count a) 1) :=\n      by simp only [smul_eq_mul, mul_one]\n    _ = (s.map fun _ => 1).sum := (Finset.sum_multiset_map_count _ _).symm\n    _ = s.card := by simp\n    \n#align to_finset_sum_count_eq to_finset_sum_count_eq\n\n",
 "to_finset_prod_dvd_prod":
 "theorem to_finset_prod_dvd_prod [CommMonoid α] (S : Multiset α) : S.to_finset.prod id ∣ S.prod :=\n  by\n  rw [Finset.prod_eq_multiset_prod]\n  refine' Multiset.prod_dvd_prod_of_le _\n  simp [Multiset.dedup_le S]\n#align to_finset_prod_dvd_prod to_finset_prod_dvd_prod\n\n",
 "toMul_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print toMul_sum /-\n@[simp]\ntheorem toMul_sum (s : Finset ι) (f : ι → Additive α) :\n    toMul (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (toMul (f i)) :=\n  rfl\n#align to_mul_sum toMul_sum\n-/\n\n",
 "toMul_multiset_sum":
 "#print toMul_multiset_sum /-\n@[simp]\ntheorem toMul_multiset_sum (s : Multiset (Additive α)) : toMul s.sum = (s.map toMul).prod := by simpa [to_mul, of_mul]\n#align to_mul_multiset_sum toMul_multiset_sum\n-/\n\n",
 "toMul_list_sum":
 "#print toMul_list_sum /-\n@[simp]\ntheorem toMul_list_sum (s : List (Additive α)) : toMul s.sum = (s.map toMul).prod := by simpa [to_mul, of_mul]\n#align to_mul_list_sum toMul_list_sum\n-/\n\n",
 "toAdd_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print toAdd_prod /-\n@[simp]\ntheorem toAdd_prod (s : Finset ι) (f : ι → Multiplicative α) :\n    toAdd (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (toAdd (f i)) :=\n  rfl\n#align to_add_prod toAdd_prod\n-/\n\n",
 "toAdd_multiset_sum":
 "#print toAdd_multiset_sum /-\n@[simp]\ntheorem toAdd_multiset_sum (s : Multiset (Multiplicative α)) : toAdd s.prod = (s.map toAdd).sum := by\n  simpa [to_add, of_add]\n#align to_add_multiset_sum toAdd_multiset_sum\n-/\n\n",
 "toAdd_list_sum":
 "#print toAdd_list_sum /-\n@[simp]\ntheorem toAdd_list_sum (s : List (Multiplicative α)) : toAdd s.prod = (s.map toAdd).sum := by simpa [to_add, of_add]\n#align to_add_list_sum toAdd_list_sum\n-/\n\n",
 "sup_powerset_len":
 "theorem sup_powerset_len {α : Type _} [DecidableEq α] (x : Multiset α) :\n    (Finset.sup (Finset.range (x.card + 1)) fun k => x.powerset_len k) = x.powerset :=\n  by\n  convert bind_powerset_len x\n  rw [Multiset.bind, Multiset.join, ← Finset.range_val, ← Finset.sum_eq_multiset_sum]\n  exact Eq.symm (finset_sum_eq_sup_iff_disjoint.mpr fun _ _ _ _ h => pairwise_disjoint_powerset_len x h)\n#align sup_powerset_len sup_powerset_len\n\n",
 "sum_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print Commute.sum_right /-\ntheorem Commute.sum_right [NonUnitalNonAssocSemiring β] (s : Finset α) (f : α → β) (b : β)\n    (h : ∀ i ∈ s, Commute b (f i)) :\n    Commute b\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i)) :=\n  Commute.multiset_sum_right _ _ fun b hb =>\n    by\n    obtain ⟨i, hi, rfl⟩ := multiset.mem_map.mp hb\n    exact h _ hi\n#align commute.sum_right Commute.sum_right\n-/\n\n",
 "sum_range_tsub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- A telescoping sum along `{0, ..., n-1}` of an `ℕ`-valued function\nreduces to the difference of the last and first terms\nwhen the function we are summing is monotone.\n-/\ntheorem sum_range_tsub [CanonicallyOrderedAddMonoid α] [Sub α] [OrderedSub α] [ContravariantClass α α (· + ·) (· ≤ ·)]\n    {f : ℕ → α} (h : Monotone f) (n : ℕ) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n        (f (i + 1) - f i) =\n      f n - f 0 :=\n  by\n  refine' sum_range_induction _ _ (tsub_self _) (fun n => _) _\n  have h₁ : f n ≤ f (n + 1) := h (nat.le_succ _)\n  have h₂ : f 0 ≤ f n := h (nat.zero_le _)\n  rw [tsub_add_eq_add_tsub h₂, add_tsub_cancel_of_le h₁]\n#align sum_range_tsub sum_range_tsub\n\n",
 "sum_nat_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_nat_mod (s : Finset α) (n : ℕ) (f : α → ℕ) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i) % n =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i % n) % n :=\n  (Multiset.sum_nat_mod _ _).trans <| by rw [Finset.sum, Multiset.map_map]\n#align sum_nat_mod sum_nat_mod\n\n",
 "sum_multiset_singleton":
 "@[simp]\ntheorem sum_multiset_singleton (s : Finset α) : (s.sum fun x => {x}) = s.val := by\n  simp only [sum_eq_multiset_sum, Multiset.sum_map_singleton]\n#align sum_multiset_singleton sum_multiset_singleton\n\n",
 "sum_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print Commute.sum_left /-\ntheorem Commute.sum_left [NonUnitalNonAssocSemiring β] (s : Finset α) (f : α → β) (b : β)\n    (h : ∀ i ∈ s, Commute (f i) b) :\n    Commute (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i))\n      b :=\n  (Commute.sum_right _ _ _ fun i hi => (h _ hi).symm).symm\n#align commute.sum_left Commute.sum_left\n-/\n\n",
 "sum_int_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_int_mod (s : Finset α) (n : ℤ) (f : α → ℤ) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i) % n =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i % n) % n :=\n  (Multiset.sum_int_mod _ _).trans <| by rw [Finset.sum, Multiset.map_map]\n#align sum_int_mod sum_int_mod\n\n",
 "sum_filter_count_eq_countp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_filter_count_eq_countp [DecidableEq α] (p : α → Prop) [DecidablePred p] (l : List α) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (l.to_finset.filter p) (l.count x) =\n      l.countp p :=\n  by simp [Finset.sum, sum_map_count_dedup_filter_eq_countp p l]\n#align sum_filter_count_eq_countp sum_filter_count_eq_countp\n\n",
 "sum_const_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_const_nat {m : ℕ} {f : α → ℕ} (h₁ : ∀ x ∈ s, f x = m) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x) =\n      card s * m :=\n  by\n  rw [← Nat.nsmul_eq_mul, ← sum_const]\n  apply sum_congr rfl h₁\n#align sum_const_nat sum_const_nat\n\n",
 "sum_boole":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem sum_boole {s : Finset α} {p : α → Prop} [NonAssocSemiring β] {hp : DecidablePred p} :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (if p x then (1 : β) else (0 : β)) =\n      (s.filter p).card :=\n  by\n  simp only [add_zero, mul_one, Finset.sum_const, nsmul_eq_mul, eq_self_iff_true, Finset.sum_const_zero, Finset.sum_ite]\n#align sum_boole sum_boole\n\n",
 "prod_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_zpow (f : α → β) (s : Finset α) (n : ℤ) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f a ^ n) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f a) ^ n :=\n  Multiset.prod_map_zpow\n#align prod_zpow prod_zpow\n\n",
 "prod_val":
 "@[simp, to_additive]\ntheorem prod_val [CommMonoid α] (s : Finset α) : s.1.prod = s.prod id := by rw [Finset.prod, Multiset.map_id]\n#align prod_val prod_val\n\n",
 "prod_update_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_update_of_not_mem [DecidableEq α] {s : Finset α} {i : α} (h : i ∉ s) (f : α → β) (b : β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (Function.update f i b x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  by\n  apply prod_congr rfl fun j hj => _\n  have : j ≠ i := by\n    intro eq\n    rw [Eq] at hj\n    exact h hj\n  simp [this]\n#align prod_update_of_not_mem prod_update_of_not_mem\n\n",
 "prod_update_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_update_of_mem [DecidableEq α] {s : Finset α} {i : α} (h : i ∈ s) (f : α → β) (b : β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (Function.update f i b x) =\n      b *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (s \\ singleton i) (f x) :=\n  by\n  rw [update_eq_piecewise, prod_piecewise]\n  simp [h]\n#align prod_update_of_mem prod_update_of_mem\n\n",
 "prod_unique_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_unique_nonempty {α β : Type _} [CommMonoid β] [Unique α] (s : Finset α) (f : α → β) (h : s.nonempty) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) =\n      f default :=\n  by rw [h.eq_singleton_default, Finset.prod_singleton]\n#align prod_unique_nonempty prod_unique_nonempty\n\n",
 "prod_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[to_additive]\ntheorem prod_unique {α β : Type _} [CommMonoid β] [Unique α] [Fintype α] (f : α → β) :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" (f x) =\n      f default :=\n  by rw [univ_unique, prod_singleton]\n#align prod_unique prod_unique\n\n",
 "prod_union_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_union_inter [DecidableEq α] :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s₁ ∪ s₂) (f x) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s₁ ∩ s₂)\n          (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₁ (f x) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₂ (f x) :=\n  fold_union_inter\n#align prod_union_inter prod_union_inter\n\n",
 "prod_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_union [DecidableEq α] (h : Disjoint s₁ s₂) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s₁ ∪ s₂) (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₁ (f x) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₂ (f x) :=\n  by rw [← prod_union_inter, disjoint_iff_inter_eq_empty.mp h] <;> exact (mul_one _).symm\n#align prod_union prod_union\n\n",
 "prod_to_list":
 "@[simp, to_additive]\ntheorem prod_to_list (s : Finset α) (f : α → β) : (s.to_list.map f).prod = s.prod f := by\n  rw [Finset.prod, ← Multiset.coe_prod, ← Multiset.coe_map, Finset.coe_toList]\n#align prod_to_list prod_to_list\n\n",
 "prod_to_finset":
 "@[to_additive]\ntheorem prod_to_finset {M : Type _} [DecidableEq α] [CommMonoid M] (f : α → M) :\n    ∀ {l : List α} (hl : l.nodup), l.to_finset.prod f = (l.map f).prod\n  | [], _ => by simp\n  | a :: l, hl => by\n    let ⟨not_mem, hl⟩ := List.nodup_cons.mp hl\n    simp [Finset.prod_insert (mt list.mem_to_finset.mp not_mem), prod_to_finset hl]\n#align prod_to_finset prod_to_finset\n\n",
 "prod_sum_elim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_sum_elim (s : Finset α) (t : Finset γ) (f : α → β) (g : γ → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.disj_sum t)\n        (Sum.elim f g x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (g x) :=\n  by simp\n#align prod_sum_elim prod_sum_elim\n\n",
 "prod_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_sum {α : Type _} {ι : Type _} [CommMonoid α] (f : ι → Multiset α) (s : Finset ι) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x)).prod =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x).prod :=\n  by\n  classical\n    induction' s using Finset.induction_on with a t hat ih\n    · rw [Finset.sum_empty, Finset.prod_empty, Multiset.prod_zero]\n    · rw [Finset.sum_insert hat, Finset.prod_insert hat, Multiset.prod_add, ih]\n#align prod_sum prod_sum\n\n",
 "prod_subtype_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If all elements of a `finset` satisfy the predicate `p`, a product\nover `s.subtype p` equals that product over `s`. -/\n@[to_additive\n      \"If all elements of a `finset` satisfy the predicate `p`, a sum\\nover `s.subtype p` equals that sum over `s`.\"]\ntheorem prod_subtype_of_mem (f : α → β) {p : α → Prop} [DecidablePred p] (h : ∀ x ∈ s, p x) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.subtype p)\n        (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  by simp_rw [prod_subtype_eq_prod_filter, filter_true_of_mem h]\n#align prod_subtype_of_mem prod_subtype_of_mem\n\n",
 "prod_subtype_mul_prod_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[to_additive]\ntheorem prod_subtype_mul_prod_subtype {α β : Type _} [Fintype α] [CommMonoid β] (p : α → Prop) (f : α → β)\n    [DecidablePred p] :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" (f i) *\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (f i) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (f i) :=\n  by\n  classical\n    let s := { x | p x }.to_finset\n    rw [← Finset.prod_subtype s, ← Finset.prod_subtype («expr ᶜ» s)]\n    · exact Finset.prod_mul_prod_compl _ _\n    · simp\n    · simp\n#align prod_subtype_mul_prod_subtype prod_subtype_mul_prod_subtype\n\n",
 "prod_subtype_map_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- A product of a function over a `finset` in a subtype equals a\nproduct in the main type of a function that agrees with the first\nfunction on that `finset`. -/\n@[to_additive\n      \"A sum of a function over a `finset` in a subtype equals a\\nsum in the main type of a function that agrees with the first\\nfunction on that `finset`.\"]\ntheorem prod_subtype_map_embedding {p : α → Prop} {s : Finset { x // p x }} {f : { x // p x } → β} {g : α → β}\n    (h : ∀ x : { x // p x }, x ∈ s → g x = f x) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (s.map (Function.Embedding.subtype _)) (g x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  by\n  rw [Finset.prod_map]\n  exact Finset.prod_congr rfl h\n#align prod_subtype_map_embedding prod_subtype_map_embedding\n\n",
 "prod_subtype_eq_prod_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- A product over `s.subtype p` equals one over `s.filter p`. -/\n@[simp, to_additive \"A sum over `s.subtype p` equals one over `s.filter p`.\"]\ntheorem prod_subtype_eq_prod_filter (f : α → β) {p : α → Prop} [DecidablePred p] :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.subtype p)\n        (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.filter p)\n        (f x) :=\n  by\n  conv_lhs => erw [← Prod_map (s.subtype p) (Function.Embedding.subtype _) f]\n  exact prod_congr (subtype_map _) fun x hx => rfl\n#align prod_subtype_eq_prod_filter prod_subtype_eq_prod_filter\n\n",
 "prod_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[to_additive]\ntheorem prod_subtype {p : α → Prop} {F : Fintype (Subtype p)} (s : Finset α) (h : ∀ x, x ∈ s ↔ p x) (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f a) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (f a) :=\n  by\n  have : (· ∈ s) = p := Set.ext h\n  subst p\n  rw [← prod_coe_sort]\n  congr\n#align prod_subtype prod_subtype\n\n",
 "prod_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[to_additive]\ntheorem prod_subsingleton {α β : Type _} [CommMonoid β] [subsingleton α] [Fintype α] (f : α → β) (a : α) :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" (f x) =\n      f a :=\n  by\n  haveI : Unique α := uniqueOfSubsingleton a\n  convert prod_unique f\n#align prod_subsingleton prod_subsingleton\n\n",
 "prod_subset_one_on_sdiff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_subset_one_on_sdiff [DecidableEq α] (h : s₁ ⊆ s₂) (hg : ∀ x ∈ s₂ \\ s₁, g x = 1)\n    (hfg : ∀ x ∈ s₁, f x = g x) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₁ (f i) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₂ (g i) :=\n  by\n  rw [← prod_sdiff h, prod_eq_one hg, one_mul]\n  exact prod_congr rfl hfg\n#align prod_subset_one_on_sdiff prod_subset_one_on_sdiff\n\n",
 "prod_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_subset (h : s₁ ⊆ s₂) (hf : ∀ x ∈ s₂, x ∉ s₁ → f x = 1) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₁ (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₂ (f x) :=\n  haveI := Classical.decEq α\n  prod_subset_one_on_sdiff h (by simpa) fun _ _ => rfl\n#align prod_subset prod_subset\n\n",
 "prod_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_singleton :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (singleton a)\n        (f x) =\n      f a :=\n  Eq.trans fold_singleton <| mul_one _\n#align prod_singleton prod_singleton\n\n",
 "prod_sigma'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_sigma' {σ : α → Type _} (s : Finset α) (t : ∀ a, Finset (σ a)) (f : ∀ a, σ a → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (t a)\n          (f a s)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.sigma t)\n        (f x.1 x.2) :=\n  Eq.symm <| prod_sigma s t fun x => f x.1 x.2\n#align prod_sigma' prod_sigma'\n\n",
 "prod_sigma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Product over a sigma type equals the product of fiberwise products. For rewriting\nin the reverse direction, use `finset.prod_sigma'`.  -/\n@[to_additive\n      \"Sum over a sigma type equals the sum of fiberwise sums. For rewriting\\nin the reverse direction, use `finset.sum_sigma'`\"]\ntheorem prod_sigma {σ : α → Type _} (s : Finset α) (t : ∀ a, Finset (σ a)) (f : Sigma σ → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.sigma t)\n        (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (t a)\n          (f ⟨a, s⟩)) :=\n  by simp_rw [← disj_Union_map_sigma_mk, prod_disj_Union, Prod_map, Function.Embedding.sigmaMk_apply]\n#align prod_sigma prod_sigma\n\n",
 "prod_sdiff_eq_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_sdiff_eq_div (h : s₁ ⊆ s₂) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s₂ \\ s₁) (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₂ (f x) /\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₁ (f x) :=\n  by rw [eq_div_iff_mul_eq', prod_sdiff h]\n#align prod_sdiff_eq_div prod_sdiff_eq_div\n\n",
 "prod_sdiff_div_prod_sdiff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_sdiff_div_prod_sdiff :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s₂ \\ s₁) (f x) /\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s₁ \\ s₂)\n          (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₂ (f x) /\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₁ (f x) :=\n  by simp [← Finset.prod_sdiff (@inf_le_left _ _ s₁ s₂), ← Finset.prod_sdiff (@inf_le_right _ _ s₁ s₂)]\n#align prod_sdiff_div_prod_sdiff prod_sdiff_div_prod_sdiff\n\n",
 "prod_sdiff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_sdiff [DecidableEq α] (h : s₁ ⊆ s₂) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s₂ \\ s₁) (f x) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₁ (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₂ (f x) :=\n  by rw [← prod_union sdiff_disjoint, sdiff_union_of_subset h]\n#align prod_sdiff prod_sdiff\n\n",
 "prod_range_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_range_zero (f : ℕ → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range 0) (f k) =\n      1 :=\n  by rw [range_zero, prod_empty]\n#align prod_range_zero prod_range_zero\n\n",
 "prod_range_succ_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_range_succ_comm (f : ℕ → β) (n : ℕ) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range (n + 1))\n        (f x) =\n      f n *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range n)\n          (f x) :=\n  by rw [range_succ, prod_insert not_mem_range_self]\n#align prod_range_succ_comm prod_range_succ_comm\n\n",
 "prod_range_succ'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_range_succ' (f : ℕ → β) :\n    ∀ n : ℕ,\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range (n + 1))\n          (f k) =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range n)\n            (f (k + 1)) *\n          f 0\n  | 0 => prod_range_succ _ _\n  | n + 1 => by rw [prod_range_succ _ n, mul_right_comm, ← prod_range_succ', prod_range_succ]\n#align prod_range_succ' prod_range_succ'\n\n",
 "prod_range_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_range_succ (f : ℕ → β) (n : ℕ) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range (n + 1))\n        (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range n)\n          (f x) *\n        f n :=\n  by simp only [mul_comm, prod_range_succ_comm]\n#align prod_range_succ prod_range_succ\n\n",
 "prod_range_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive sum_range_one]\ntheorem prod_range_one (f : ℕ → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range 1) (f k) =\n      f 0 :=\n  by\n  rw [range_one]\n  apply @prod_singleton β ℕ 0 f\n#align prod_range_one prod_range_one\n\n",
 "prod_range_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- For any product along `{0, ..., n - 1}` of a commutative-monoid-valued function, we can verify\nthat it's equal to a different function just by checking ratios of adjacent terms.\n\nThis is a multiplicative discrete analogue of the fundamental theorem of calculus. -/\n@[to_additive\n      \"For any sum along `{0, ..., n - 1}` of a commutative-monoid-valued function, we can\\nverify that it's equal to a different function just by checking differences of adjacent terms.\\n\\nThis is a discrete analogue of the fundamental theorem of calculus.\"]\ntheorem prod_range_induction (f s : ℕ → β) (h0 : s 0 = 1) (h : ∀ n, s (n + 1) = s n * f n) (n : ℕ) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range n)\n        (f k) =\n      s n :=\n  by\n  induction' n with k hk\n  · simp only [h0, Finset.prod_range_zero]\n  · simp only [hk, Finset.prod_range_succ, h, mul_comm]\n#align prod_range_induction prod_range_induction\n\n",
 "prod_range_div'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_range_div' {M : Type _} [CommGroup M] (f : ℕ → M) (n : ℕ) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range n)\n        (f i / f (i + 1)) =\n      f 0 / f n :=\n  by apply prod_range_induction <;> simp\n#align prod_range_div' prod_range_div'\n\n",
 "prod_range_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- A telescoping product along `{0, ..., n - 1}` of a commutative group valued function reduces to\nthe ratio of the last and first factors. -/\n@[to_additive\n      \"A telescoping sum along `{0, ..., n - 1}` of an additive commutative group valued\\nfunction reduces to the difference of the last and first terms.\"]\ntheorem prod_range_div {M : Type _} [CommGroup M] (f : ℕ → M) (n : ℕ) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range n)\n        (f (i + 1) / f i) =\n      f n / f 0 :=\n  by apply prod_range_induction <;> simp\n#align prod_range_div prod_range_div\n\n",
 "prod_range_add_div_prod_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_range_add_div_prod_range {α : Type _} [CommGroup α] (f : ℕ → α) (n m : ℕ) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range (n + m))\n          (f k) /\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range n)\n          (f k) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range m)\n        (f (n + k)) :=\n  div_eq_of_eq_mul' (prod_range_add f n m)\n#align prod_range_add_div_prod_range prod_range_add_div_prod_range\n\n",
 "prod_range_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_range_add (f : ℕ → β) (n m : ℕ) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range (n + m))\n        (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range n)\n          (f x) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range m)\n          (f (n + x)) :=\n  by\n  induction' m with m hm\n  · simp\n  · rw [nat.add_succ, prod_range_succ, hm, prod_range_succ, mul_assoc]\n#align prod_range_add prod_range_add\n\n",
 "prod_product_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- An uncurried version of `finset.prod_product_right`. -/\n@[to_additive \"An uncurried version of `finset.prod_product_right`\"]\ntheorem prod_product_right' {s : Finset γ} {t : Finset α} {f : γ → α → β} :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (finset.product s t) (f x.1 x.2) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x y)) :=\n  prod_product_right\n#align prod_product_right' prod_product_right'\n\n",
 "prod_product_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_product_right {s : Finset γ} {t : Finset α} {f : γ × α → β} :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (finset.product s t) (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (f (x, y))) :=\n  prod_finset_product_right (finset.product s t) t (fun a => s) fun p => mem_product.trans and_comm\n#align prod_product_right prod_product_right\n\n",
 "prod_product'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- An uncurried version of `finset.prod_product`. -/\n@[to_additive \"An uncurried version of `finset.sum_product`\"]\ntheorem prod_product' {s : Finset γ} {t : Finset α} {f : γ → α → β} :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (finset.product s t) (f x.1 x.2) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f x y)) :=\n  prod_product\n#align prod_product' prod_product'\n\n",
 "prod_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_product {s : Finset γ} {t : Finset α} {f : γ × α → β} :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (finset.product s t) (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t\n          (f (x, y))) :=\n  prod_finset_product (finset.product s t) s (fun a => t) fun p => mem_product\n#align prod_product prod_product\n\n",
 "prod_pow_boole":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_pow_boole [DecidableEq α] (s : Finset α) (f : α → β) (a : α) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (f x ^ ite (a = x) 1 0) =\n      ite (a ∈ s) (f a) 1 :=\n  by simp\n#align prod_pow_boole prod_pow_boole\n\n",
 "prod_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_pow (s : Finset α) (n : ℕ) (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x ^ n) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) ^ n :=\n  Multiset.prod_map_pow\n#align prod_pow prod_pow\n\n",
 "prod_piecewise":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_piecewise [DecidableEq α] (s t : Finset α) (f g : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        ((t.piecewise f g) x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s ∩ t) (f x) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s \\ t)\n          (g x) :=\n  by rw [piecewise, prod_ite, filter_mem_eq_inter, ← sdiff_eq_filter]\n#align prod_piecewise prod_piecewise\n\n",
 "prod_pi_mul_single'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_pi_mul_single' [DecidableEq α] (a : α) (x : β) (s : Finset α) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (Pi.mulSingle a x a') =\n      if a ∈ s then x else 1 :=\n  prod_dite_eq' _ _ _\n#align prod_pi_mul_single' prod_pi_mul_single'\n\n",
 "prod_pi_mul_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_pi_mul_single {β : α → Type _} [DecidableEq α] [∀ a, CommMonoid (β a)] (a : α) (f : ∀ a, β a)\n    (s : Finset α) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (Pi.mulSingle a' (f a') a) =\n      if a ∈ s then f a else 1 :=\n  prod_dite_eq _ _ _\n#align prod_pi_mul_single prod_pi_mul_single\n\n",
 "prod_partition":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/-- A product can be partitioned into a product of products, each equivalent under a setoid. -/\n@[to_additive \"A sum can be partitioned into a sum of sums, each equivalent under a setoid.\"]\ntheorem prod_partition (R : setoid α) [DecidableRel R.r] :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (s.image Quotient.mk')\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (s.filter fun y => «expr⟦ ⟧» y = xbar) (f y)) :=\n  by\n  refine' (Finset.prod_image' f fun x hx => _).symm\n  rfl\n#align prod_partition prod_partition\n\n",
 "prod_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_pair [DecidableEq α] {a b : α} (h : a ≠ b) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        ({a, b} : Finset α) (f x) =\n      f a * f b :=\n  by rw [prod_insert (not_mem_singleton.2 h), prod_singleton]\n#align prod_pair prod_pair\n\n",
 "prod_of_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_of_empty [IsEmpty α] (s : Finset α) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) = 1 := by\n  rw [eq_empty_of_is_empty s, prod_empty]\n#align prod_of_empty prod_of_empty\n\n",
 "prod_ne_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_ne_zero_iff :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) ≠ 0 ↔\n      ∀ a ∈ s, f a ≠ 0 :=\n  by\n  rw [ne, prod_eq_zero_iff]\n  push_neg\n#align prod_ne_zero_iff prod_ne_zero_iff\n\n",
 "prod_nat_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_nat_mod (s : Finset α) (n : ℕ) (f : α → ℕ) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) % n =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i % n) %\n        n :=\n  (Multiset.prod_nat_mod _ _).trans <| by rw [Finset.prod, Multiset.map_map]\n#align prod_nat_mod prod_nat_mod\n\n",
 "prod_multiset_map_count":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_multiset_map_count [DecidableEq α] (s : Multiset α) {M : Type _} [CommMonoid M] (f : α → M) :\n    (s.map f).prod =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s.to_finset\n        (f m ^ s.count m) :=\n  by\n  refine' Quot.inductionOn s fun l => _\n  simp [prod_list_map_count l f]\n#align prod_multiset_map_count prod_multiset_map_count\n\n",
 "prod_multiset_count_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_multiset_count_of_subset [DecidableEq α] [CommMonoid α] (m : Multiset α) (s : Finset α)\n    (hs : m.to_finset ⊆ s) :\n    m.prod =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (i ^ m.count i) :=\n  by\n  revert hs\n  refine' Quot.inductionOn m fun l => _\n  simp only [quot_mk_to_coe'', coe_prod, coe_count]\n  apply prod_list_count_of_subset l s\n#align prod_multiset_count_of_subset prod_multiset_count_of_subset\n\n",
 "prod_multiset_count":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_multiset_count [DecidableEq α] [CommMonoid α] (s : Multiset α) :\n    s.prod =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s.to_finset\n        (m ^ s.count m) :=\n  by\n  convert prod_multiset_map_count s id\n  rw [Multiset.map_id]\n#align prod_multiset_count prod_multiset_count\n\n",
 "prod_mul_prod_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- Multiplying the products of a function over `s` and over `sᶜ` gives the whole product.\nFor a version expressed with subtypes, see `fintype.prod_subtype_mul_prod_subtype`. -/\n@[to_additive\n      \"Adding the sums of a function over `s` and over `sᶜ` gives the whole sum.\\nFor a version expressed with subtypes, see `fintype.sum_subtype_add_sum_subtype`. \"]\ntheorem prod_mul_prod_compl [Fintype α] [DecidableEq α] (s : Finset α) (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" («expr ᶜ» s)\n          (f i) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (f i) :=\n  IsCompl.prod_mul_prod isCompl_compl f\n#align prod_mul_prod_compl prod_mul_prod_compl\n\n",
 "prod_mul_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n#print IsCompl.prod_mul_prod /-\n@[to_additive]\ntheorem IsCompl.prod_mul_prod {s t : Finset α} (h : IsCompl s t) (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (f i) :=\n  (Finset.prod_disjUnion h.disjoint).symm.trans <| by\n    classical rw [Finset.disjUnion_eq_union, ← Finset.sup_eq_union, h.sup_eq_top] <;> rfl\n#align is_compl.prod_mul_prod IsCompl.prod_mul_prod\n#align is_compl.sum_add_sum IsCompl.sum_add_sum\n-/\n\n",
 "prod_mul_distrib":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_mul_distrib :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x * g x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g x) :=\n  Eq.trans (by rw [one_mul] <;> rfl) fold_op_distrib\n#align prod_mul_distrib prod_mul_distrib\n\n",
 "prod_mk":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl\n-/\n@[simp, to_additive]\ntheorem prod_mk [CommMonoid β] (s : Multiset α) (hs : s.nodup) (f : α → β) :\n    (⟨s, hs⟩ : Finset α).prod f = (s.map f).prod :=\n  rfl\n#align prod_mk prod_mk\n\n",
 "prod_mem_multiset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_mem_multiset [DecidableEq α] (m : Multiset α) (f : { x // x ∈ m } → β) (g : α → β) (hfg : ∀ x, f x = g x) :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" m.to_finset\n        (g x) :=\n  prod_bij (fun x _ => x.1) (fun x _ => Multiset.mem_toFinset.mpr x.2) (fun _ _ => hfg _)\n    (fun _ _ _ _ h => by\n      ext\n      assumption)\n    fun y hy => ⟨⟨y, Multiset.mem_toFinset.mp hy⟩, Finset.mem_univ _, rfl⟩\n#align prod_mem_multiset prod_mem_multiset\n\n",
 "prod_list_map_count":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_list_map_count [DecidableEq α] (l : List α) {M : Type _} [CommMonoid M] (f : α → M) :\n    (l.map f).prod =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" l.to_finset\n        (f m ^ l.count m) :=\n  by\n  induction' l with a s IH; · simp only [map_nil, prod_nil, count_nil, pow_zero, prod_const_one]\n  simp only [list.map, List.prod_cons, to_finset_cons, IH]\n  by_cases has : a ∈ s.to_finset\n  · rw [insert_eq_of_mem has, ← insert_erase has, prod_insert (not_mem_erase _ _), prod_insert (not_mem_erase _ _), ←\n      mul_assoc, count_cons_self, pow_succ]\n    congr 1\n    refine' prod_congr rfl fun x hx => _\n    rw [count_cons_of_ne (ne_of_mem_erase hx)]\n  rw [prod_insert has, count_cons_self, count_eq_zero_of_not_mem (mt mem_to_finset.2 has), pow_one]\n  congr 1\n  refine' prod_congr rfl fun x hx => _\n  rw [count_cons_of_ne]\n  rintro rfl\n  exact has hx\n#align prod_list_map_count prod_list_map_count\n\n",
 "prod_list_count_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_list_count_of_subset [DecidableEq α] [CommMonoid α] (m : List α) (s : Finset α) (hs : m.to_finset ⊆ s) :\n    m.prod =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (i ^ m.count i) :=\n  by\n  rw [prod_list_count]\n  refine' prod_subset hs fun x _ hx => _\n  rw [mem_to_finset] at hx\n  rw [count_eq_zero_of_not_mem hx, pow_zero]\n#align prod_list_count_of_subset prod_list_count_of_subset\n\n",
 "prod_list_count":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_list_count [DecidableEq α] [CommMonoid α] (s : List α) :\n    s.prod =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s.to_finset\n        (m ^ s.count m) :=\n  by simpa using prod_list_map_count s id\n#align prod_list_count prod_list_count\n\n",
 "prod_ite_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- See also `finset.prod_boole`. -/\n@[to_additive \"See also `finset.sum_boole`.\"]\ntheorem prod_ite_one {f : α → Prop} [DecidablePred f] (hf : (s : Set α).pairwise_disjoint f) (a : β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (ite (f i) a 1) =\n      ite (∃ i ∈ s, f i) a 1 :=\n  by\n  split_ifs\n  · obtain ⟨i, hi, hfi⟩ := h\n    rw [prod_eq_single_of_mem _ hi, if_pos hfi]\n    exact fun j hj h => if_neg fun hfj => (hf hj hi h).le_bot ⟨hfj, hfi⟩\n  · push_neg  at h\n    rw [prod_eq_one]\n    exact fun i hi => if_neg (h i hi)\n#align prod_ite_one prod_ite_one\n\n",
 "prod_ite_of_true":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_ite_of_true {p : α → Prop} {hp : DecidablePred p} (f g : α → β) (h : ∀ x ∈ s, p x) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (if p x then f x else g x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  by\n  simp_rw [← ite_not (p _)]\n  apply prod_ite_of_false\n  simpa\n#align prod_ite_of_true prod_ite_of_true\n\n",
 "prod_ite_of_false":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_ite_of_false {p : α → Prop} {hp : DecidablePred p} (f g : α → β) (h : ∀ x ∈ s, ¬p x) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (if p x then f x else g x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g x) :=\n  by\n  rw [prod_ite]\n  simp [filter_false_of_mem h, filter_true_of_mem h]\n#align prod_ite_of_false prod_ite_of_false\n\n",
 "prod_ite_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_ite_mem [DecidableEq α] (s t : Finset α) (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (if i ∈ t then f i else 1) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s ∩ t) (f i) :=\n  by rw [← Finset.prod_filter, Finset.filter_mem_eq_inter]\n#align prod_ite_mem prod_ite_mem\n\n",
 "prod_ite_irrel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_ite_irrel (p : Prop) [Decidable p] (s : Finset α) (f g : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (if p then f x else g x) =\n      if p then\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x)\n      else finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g x) :=\n  by split_ifs with h <;> rfl\n#align prod_ite_irrel prod_ite_irrel\n\n",
 "prod_ite_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_ite_index (p : Prop) [Decidable p] (s t : Finset α) (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (if p then s else t) (f x) =\n      if p then\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x)\n      else finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f x) :=\n  apply_ite\n    (fun s => finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x))\n    _ _ _\n#align prod_ite_index prod_ite_index\n\n",
 "prod_ite_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- A product taken over a conditional whose condition is an equality test on the index and whose\nalternative is `1` has value either the term at that index or `1`.\n\nThe difference with `finset.prod_ite_eq` is that the arguments to `eq` are swapped. -/\n@[simp,\n  to_additive\n      \"A sum taken over a conditional whose condition is an equality test on the index\\nand whose alternative is `0` has value either the term at that index or `0`.\\n\\nThe difference with `finset.sum_ite_eq` is that the arguments to `eq` are swapped.\"]\ntheorem prod_ite_eq' [DecidableEq α] (s : Finset α) (a : α) (b : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (ite (x = a) (b x) 1) =\n      ite (a ∈ s) (b a) 1 :=\n  prod_dite_eq' s a fun x _ => b x\n#align prod_ite_eq' prod_ite_eq'\n\n",
 "prod_ite_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_ite_eq [DecidableEq α] (s : Finset α) (a : α) (b : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (ite (a = x) (b x) 1) =\n      ite (a ∈ s) (b a) 1 :=\n  prod_dite_eq s a fun x _ => b x\n#align prod_ite_eq prod_ite_eq\n\n",
 "prod_ite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_ite {s : Finset α} {p : α → Prop} {hp : DecidablePred p} (f g : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (if p x then f x else g x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.filter p)\n          (f x) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (s.filter fun x => ¬p x) (g x) :=\n  by simp [prod_apply_ite _ _ fun x => x]\n#align prod_ite prod_ite\n\n",
 "prod_involution":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_involution {s : Finset α} {f : α → β} :\n    ∀ (g : ∀ a ∈ s, α) (h : ∀ a ha, f a * f (g a ha) = 1) (g_ne : ∀ a ha, f a ≠ 1 → g a ha ≠ a)\n      (g_mem : ∀ a ha, g a ha ∈ s) (g_inv : ∀ a ha, g (g a ha) (g_mem a ha) = a),\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) = 1 :=\n  by\n  haveI := Classical.decEq α <;> haveI := Classical.decEq β <;>\n    exact\n      Finset.strongInductionOn s fun s ih g h g_ne g_mem g_inv =>\n        s.eq_empty_or_nonempty.elim (fun hs => hs.symm ▸ rfl) fun ⟨x, hx⟩ =>\n          have hmem : ∀ y ∈ (s.erase x).erase (g x hx), y ∈ s := fun y hy => mem_of_mem_erase (mem_of_mem_erase hy)\n          have g_inj : ∀ {x hx y hy}, g x hx = g y hy → x = y := fun x hx y hy h => by\n            rw [← g_inv x hx, ← g_inv y hy] <;> simp [h]\n          have ih' :\n            finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n                (erase (erase s x) (g x hx)) (f y) =\n              (1 : β) :=\n            ih ((s.erase x).erase (g x hx))\n              ⟨subset.trans (erase_subset _ _) (erase_subset _ _), fun h =>\n                not_mem_erase (g x hx) (s.erase x) (h (g_mem x hx))⟩\n              (fun y hy => g y (hmem y hy)) (fun y hy => h y (hmem y hy)) (fun y hy => g_ne y (hmem y hy))\n              (fun y hy =>\n                mem_erase.2\n                  ⟨fun h : g y _ = g x hx => by simpa [g_inj h] using hy,\n                    mem_erase.2\n                      ⟨fun h : g y _ = x =>\n                        by\n                        have : y = g x hx := g_inv y (hmem y hy) ▸ by simp [h]\n                        simpa [this] using hy, g_mem y (hmem y hy)⟩⟩)\n              fun y hy => g_inv y (hmem y hy)\n          if hx1 : f x = 1 then\n            ih' ▸\n              Eq.symm\n                (prod_subset hmem fun y hy hy₁ =>\n                  have : y = x ∨ y = g x hx := by simpa [hy, not_and_or, or_comm'] using hy₁\n                  this.elim (fun hy => hy.symm ▸ hx1) fun hy => h x hx ▸ hy ▸ hx1.symm ▸ (one_mul _).symm)\n          else by\n            rw [← insert_erase hx, prod_insert (not_mem_erase _ _), ←\n              insert_erase (mem_erase.2 ⟨g_ne x hx hx1, g_mem x hx⟩), prod_insert (not_mem_erase _ _), ih', mul_one,\n              h x hx]\n#align prod_involution prod_involution\n\n",
 "prod_inv_distrib":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_inv_distrib :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x)⁻¹ =\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x))⁻¹ :=\n  Multiset.prod_map_inv\n#align prod_inv_distrib prod_inv_distrib\n\n",
 "prod_inter_mul_prod_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_inter_mul_prod_diff [DecidableEq α] (s t : Finset α) (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s ∩ t) (f x) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s \\ t)\n          (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  by\n  convert(s.prod_piecewise t f f).symm\n  simp [Finset.piecewise]\n#align prod_inter_mul_prod_diff prod_inter_mul_prod_diff\n\n",
 "prod_int_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_int_mod (s : Finset α) (n : ℤ) (f : α → ℤ) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) % n =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i % n) %\n        n :=\n  (Multiset.prod_int_mod _ _).trans <| by rw [Finset.prod, Multiset.map_map]\n#align prod_int_mod prod_int_mod\n\n",
 "prod_insert_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- The product of `f` over `insert a s` is the same as the product over `s`, as long as `f a = 1`.\n-/\n@[simp, to_additive \"The sum of `f` over `insert a s` is the same as\\nthe sum over `s`, as long as `f a = 0`.\"]\ntheorem prod_insert_one [DecidableEq α] (h : f a = 1) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (insert a s)\n        (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  prod_insert_of_eq_one_if_not_mem fun _ => h\n#align prod_insert_one prod_insert_one\n\n",
 "prod_insert_of_eq_one_if_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- The product of `f` over `insert a s` is the same as\nthe product over `s`, as long as `a` is in `s` or `f a = 1`.\n-/\n@[simp,\n  to_additive\n      \"The sum of `f` over `insert a s` is the same as\\nthe sum over `s`, as long as `a` is in `s` or `f a = 0`.\"]\ntheorem prod_insert_of_eq_one_if_not_mem [DecidableEq α] (h : a ∉ s → f a = 1) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (insert a s)\n        (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  by\n  by_cases hm : a ∈ s\n  · simp_rw [insert_eq_of_mem hm]\n  · rw [prod_insert hm, h hm, one_mul]\n#align prod_insert_of_eq_one_if_not_mem prod_insert_of_eq_one_if_not_mem\n\n",
 "prod_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_insert [DecidableEq α] :\n    a ∉ s →\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (insert a s)\n          (f x) =\n        f a *\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  fold_insert\n#align prod_insert prod_insert\n\n",
 "prod_induction_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- To prove a property of a product, it suffices to prove that\nthe property is multiplicative and holds on factors.\n-/\n@[to_additive\n      \"To prove a property of a sum, it suffices to prove that\\nthe property is additive and holds on summands.\"]\ntheorem prod_induction_nonempty {M : Type _} [CommMonoid M] (f : α → M) (p : M → Prop)\n    (p_mul : ∀ a b, p a → p b → p (a * b)) (hs_nonempty : s.nonempty) (p_s : ∀ x ∈ s, p <| f x) :\n    p <| finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  Multiset.prod_induction_nonempty p p_mul (by simp [nonempty_iff_ne_empty.mp hs_nonempty])\n    (Multiset.forall_mem_map_iff.mpr p_s)\n#align prod_induction_nonempty prod_induction_nonempty\n\n",
 "prod_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- To prove a property of a product, it suffices to prove that\nthe property is multiplicative and holds on factors.\n-/\n@[to_additive\n      \"To prove a property of a sum, it suffices to prove that\\nthe property is additive and holds on summands.\"]\ntheorem prod_induction {M : Type _} [CommMonoid M] (f : α → M) (p : M → Prop) (p_mul : ∀ a b, p a → p b → p (a * b))\n    (p_one : p 1) (p_s : ∀ x ∈ s, p <| f x) :\n    p <| finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  Multiset.prod_induction _ _ p_mul p_one (Multiset.forall_mem_map_iff.mpr p_s)\n#align prod_induction prod_induction\n\n",
 "prod_image'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_image' [DecidableEq α] {s : Finset γ} {g : γ → α} (h : γ → β)\n    (eq :\n      ∀ c ∈ s,\n        f (g c) =\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (s.filter fun c' => g c' = g c) (h x)) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.image g)\n        (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (h x) :=\n  calc\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.image g)\n          (f x) =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.image g)\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (s.filter fun c' => g c' = x) (h x)) :=\n      prod_congr rfl fun x hx =>\n        let ⟨c, hcs, hc⟩ := mem_image.1 hx\n        hc ▸ Eq c hcs\n    _ = finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (h x) :=\n      prod_fiberwise_of_maps_to (fun x => mem_image_of_mem g) _\n    \n#align prod_image' prod_image'\n\n",
 "prod_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_image [DecidableEq α] {s : Finset γ} {g : γ → α} :\n    (∀ x ∈ s, ∀ y ∈ s, g x = g y → x = y) →\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.image g)\n          (f x) =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f (g x)) :=\n  fold_image\n#align prod_image prod_image\n\n",
 "prod_hom_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_hom_rel [CommMonoid γ] {r : β → γ → Prop} {f : α → β} {g : α → γ} {s : Finset α} (h₁ : r 1 1)\n    (h₂ : ∀ a b c, r b c → r (f a * b) (g a * c)) :\n    r (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x))\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g x)) :=\n  by\n  delta Finset.prod\n  apply Multiset.prod_hom_rel <;> assumption\n#align prod_hom_rel prod_hom_rel\n\n",
 "prod_flip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_flip {n : ℕ} (f : ℕ → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range (n + 1))\n        (f (n - r)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range (n + 1))\n        (f k) :=\n  by\n  induction' n with n ih\n  · rw [prod_range_one, prod_range_one]\n  · rw [prod_range_succ', prod_range_succ _ (nat.succ n)]\n    simp [← ih]\n#align prod_flip prod_flip\n\n",
 "prod_finset_product_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_finset_product_right' (r : Finset (α × γ)) (s : Finset γ) (t : γ → Finset α)\n    (h : ∀ p : α × γ, p ∈ r ↔ p.2 ∈ s ∧ p.1 ∈ t p.2) {f : α → γ → β} :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" r (f p.1 p.2) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (t c)\n          (f a c)) :=\n  prod_finset_product_right r s t h\n#align prod_finset_product_right' prod_finset_product_right'\n\n",
 "prod_finset_product_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_finset_product_right (r : Finset (α × γ)) (s : Finset γ) (t : γ → Finset α)\n    (h : ∀ p : α × γ, p ∈ r ↔ p.2 ∈ s ∧ p.1 ∈ t p.2) {f : α × γ → β} :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" r (f p) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (t c)\n          (f (a, c))) :=\n  by\n  refine' Eq.trans _ (prod_sigma s t fun p => f (p.2, p.1))\n  exact\n    prod_bij' (fun p hp => ⟨p.2, p.1⟩) (fun p => mem_sigma.mpr ∘ (h p).mp) (fun p hp => congr_arg f prod.mk.eta.symm)\n      (fun p hp => (p.2, p.1)) (fun p => (h (p.2, p.1)).mpr ∘ mem_sigma.mp) (fun p hp => prod.mk.eta) fun p hp => p.eta\n#align prod_finset_product_right prod_finset_product_right\n\n",
 "prod_finset_product'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_finset_product' (r : Finset (γ × α)) (s : Finset γ) (t : γ → Finset α)\n    (h : ∀ p : γ × α, p ∈ r ↔ p.1 ∈ s ∧ p.2 ∈ t p.1) {f : γ → α → β} :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" r (f p.1 p.2) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (t c)\n          (f c a)) :=\n  prod_finset_product r s t h\n#align prod_finset_product' prod_finset_product'\n\n",
 "prod_finset_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_finset_product (r : Finset (γ × α)) (s : Finset γ) (t : γ → Finset α)\n    (h : ∀ p : γ × α, p ∈ r ↔ p.1 ∈ s ∧ p.2 ∈ t p.1) {f : γ × α → β} :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" r (f p) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (t c)\n          (f (c, a))) :=\n  by\n  refine' Eq.trans _ (prod_sigma s t fun p => f (p.1, p.2))\n  exact\n    prod_bij' (fun p hp => ⟨p.1, p.2⟩) (fun p => mem_sigma.mpr ∘ (h p).mp) (fun p hp => congr_arg f prod.mk.eta.symm)\n      (fun p hp => (p.1, p.2)) (fun p => (h (p.1, p.2)).mpr ∘ mem_sigma.mp) (fun p hp => prod.mk.eta) fun p hp => p.eta\n#align prod_finset_product prod_finset_product\n\n",
 "prod_finset_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_finset_coe (f : α → β) (s : Finset α) :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" (f i) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) :=\n  prod_coe_sort s f\n#align prod_finset_coe prod_finset_coe\n\n",
 "prod_filter_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_filter_of_ne {p : α → Prop} [DecidablePred p] (hp : ∀ x ∈ s, f x ≠ 1 → p x) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.filter p)\n        (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  prod_subset (filter_subset _ _) fun x => by\n    classical\n      rw [not_imp_comm, mem_filter]\n      exact fun h₁ h₂ => ⟨h₁, hp _ h₁ h₂⟩\n#align prod_filter_of_ne prod_filter_of_ne\n\n",
 "prod_filter_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n-- If we use `[decidable_eq β]` here, some rewrites fail because they find a wrong `decidable`\n-- instance first; `{∀ x, decidable (f x ≠ 1)}` doesn't work with `rw ← prod_filter_ne_one`\n@[to_additive]\ntheorem prod_filter_ne_one [∀ x, Decidable (f x ≠ 1)] :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (s.filter fun x => f x ≠ 1) (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  prod_filter_of_ne fun _ _ => id\n#align prod_filter_ne_one prod_filter_ne_one\n\n",
 "prod_filter_mul_prod_filter_not":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_filter_mul_prod_filter_not (s : Finset α) (p : α → Prop) [DecidablePred p] [DecidablePred fun x => ¬p x]\n    (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.filter p)\n          (f x) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (s.filter fun x => ¬p x) (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  by\n  haveI := Classical.decEq α\n  rw [← prod_union (disjoint_filter_filter_neg _ _ p), filter_union_filter_neg_eq]\n#align prod_filter_mul_prod_filter_not prod_filter_mul_prod_filter_not\n\n",
 "prod_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_filter (p : α → Prop) [DecidablePred p] (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.filter p)\n        (f a) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (if p a then f a else 1) :=\n  calc\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.filter p)\n          (f a) =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.filter p)\n          (if p a then f a else 1) :=\n      prod_congr rfl fun a h => by rw [if_pos (mem_filter.1 h).2]\n    _ =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (if p a then f a else 1) :=\n      by\n      refine' prod_subset (filter_subset _ s) fun x hs h => _\n      rw [mem_filter, not_and] at h\n      exact if_neg (h hs)\n    \n#align prod_filter prod_filter\n\n",
 "prod_fiberwise_of_maps_to":
 "/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:132:4: warning: unsupported: rw with cfg: { occs := occurrences.pos[occurrences.pos] «expr[ ,]»([2]) } -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_fiberwise_of_maps_to [DecidableEq γ] {s : Finset α} {t : Finset γ} {g : α → γ} (h : ∀ x ∈ s, g x ∈ t)\n    (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (s.filter fun x => g x = y) (f x)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  by\n  rw [← disj_Union_filter_eq_of_maps_to h]\n  rw [prod_disj_Union]\n#align prod_fiberwise_of_maps_to prod_fiberwise_of_maps_to\n\n",
 "prod_extend_by_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_extend_by_one [DecidableEq α] (s : Finset α) (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (if i ∈ s then f i else 1) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) :=\n  prod_congr rfl fun i hi => if_pos hi\n#align prod_extend_by_one prod_extend_by_one\n\n",
 "prod_erase_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- A variant of `finset.mul_prod_erase` with the multiplication swapped. -/\n@[to_additive \"A variant of `finset.add_sum_erase` with the addition swapped.\"]\ntheorem prod_erase_mul [DecidableEq α] (s : Finset α) (f : α → β) {a : α} (h : a ∈ s) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.erase a)\n          (f x) *\n        f a =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  by rw [mul_comm, mul_prod_erase s f h]\n#align prod_erase_mul prod_erase_mul\n\n",
 "prod_erase_lt_of_one_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_erase_lt_of_one_lt {γ : Type _} [DecidableEq α] [OrderedCommMonoid γ] [CovariantClass γ γ (· * ·) (· < ·)]\n    {s : Finset α} {d : α} (hd : d ∈ s) {f : α → γ} (hdf : 1 < f d) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.erase d)\n        (f m) <\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f m) :=\n  by\n  nth_rw_rhs 1 [← Finset.insert_erase hd]\n  rw [Finset.prod_insert (Finset.not_mem_erase d s)]\n  exact lt_mul_of_one_lt_left' _ hdf\n#align prod_erase_lt_of_one_lt prod_erase_lt_of_one_lt\n\n",
 "prod_erase_eq_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_erase_eq_div {a : α} (h : a ∈ s) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.erase a)\n        (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) / f a :=\n  by rw [eq_div_iff_mul_eq', prod_erase_mul _ _ h]\n#align prod_erase_eq_div prod_erase_eq_div\n\n",
 "prod_erase":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If a function applied at a point is 1, a product is unchanged by\nremoving that point, if present, from a `finset`. -/\n@[to_additive\n      \"If a function applied at a point is 0, a sum is unchanged by\\nremoving that point, if present, from a `finset`.\"]\ntheorem prod_erase [DecidableEq α] (s : Finset α) {f : α → β} {a : α} (h : f a = 1) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.erase a)\n        (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  by\n  rw [← sdiff_singleton_eq_erase]\n  refine' prod_subset (sdiff_subset _ _) fun x hx hnx => _\n  rw [sdiff_singleton_eq_erase] at hnx\n  rwa [eq_of_mem_of_not_mem_erase hx hnx]\n#align prod_erase prod_erase\n\n",
 "prod_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- `fintype.prod_equiv` is a specialization of `finset.prod_bij` that\nautomatically fills in most arguments.\n\nSee `equiv.prod_comp` for a version without `h`.\n-/\n@[to_additive\n      \"`fintype.sum_equiv` is a specialization of `finset.sum_bij` that\\nautomatically fills in most arguments.\\n\\nSee `equiv.sum_comp` for a version without `h`.\\n\"]\ntheorem prod_equiv {α β M : Type _} [Fintype α] [Fintype β] [CommMonoid M] (e : «expr ≃ » α β) (f : α → M) (g : β → M)\n    (h : ∀ x, f x = g (e x)) :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" (f x) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (g x) :=\n  prod_bijective e e.bijective f g h\n#align prod_equiv prod_equiv\n\n",
 "prod_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_eq_zero_iff :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) = 0 ↔\n      ∃ a ∈ s, f a = 0 :=\n  by\n  classical\n    apply Finset.induction_on s\n    exact ⟨Not.elim one_ne_zero, fun ⟨_, H, _⟩ => H.elim⟩\n    intro a s ha ih\n    rw [prod_insert ha, mul_eq_zero, bex_def, exists_mem_insert, ih, ← bex_def]\n#align prod_eq_zero_iff prod_eq_zero_iff\n\n",
 "prod_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_eq_zero (ha : a ∈ s) (h : f a = 0) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) = 0 :=\n  by\n  haveI := Classical.decEq α\n  rw [← prod_erase_mul _ _ ha, h, MulZeroClass.mul_zero]\n#align prod_eq_zero prod_eq_zero\n\n",
 "prod_eq_single_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_eq_single_of_mem {s : Finset α} {f : α → β} (a : α) (h : a ∈ s) (h₀ : ∀ b ∈ s, b ≠ a → f b = 1) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) = f a :=\n  by\n  haveI := Classical.decEq α\n  calc\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" {a} (f x) :=\n      by\n      refine' (prod_subset _ _).symm\n      · intro _ H\n        rwa [mem_singleton.1 H]\n      · simpa only [mem_singleton]\n    _ = f a := prod_singleton\n    \n#align prod_eq_single_of_mem prod_eq_single_of_mem\n\n",
 "prod_eq_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_eq_single {s : Finset α} {f : α → β} (a : α) (h₀ : ∀ b ∈ s, b ≠ a → f b = 1) (h₁ : a ∉ s → f a = 1) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) = f a :=\n  haveI := Classical.decEq α\n  by_cases (fun this : a ∈ s => prod_eq_single_of_mem a this h₀) fun this : a ∉ s =>\n    (prod_congr rfl fun b hb => h₀ b hb <| by rintro rfl <;> cc).trans <| prod_const_one.trans (h₁ this).symm\n#align prod_eq_single prod_eq_single\n\n",
 "prod_eq_prod_diff_singleton_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_eq_prod_diff_singleton_mul [DecidableEq α] {s : Finset α} {i : α} (h : i ∈ s) (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s \\ {i})\n          (f x) *\n        f i :=\n  by rw [prod_eq_mul_prod_diff_singleton h, mul_comm]\n#align prod_eq_prod_diff_singleton_mul prod_eq_prod_diff_singleton_mul\n\n",
 "prod_eq_prod_compl_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print Fintype.prod_eq_prod_compl_mul /-\n@[to_additive]\ntheorem Fintype.prod_eq_prod_compl_mul [DecidableEq α] [Fintype α] (a : α) (f : α → β) :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" (f i) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" («expr ᶜ» {a})\n          (f i) *\n        f a :=\n  prod_eq_prod_diff_singleton_mul (mem_univ a) f\n#align fintype.prod_eq_prod_compl_mul Fintype.prod_eq_prod_compl_mul\n#align fintype.sum_eq_sum_compl_add Fintype.sum_eq_sum_compl_add\n-/\n\n",
 "prod_eq_pow_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive sum_eq_card_nsmul]\ntheorem prod_eq_pow_card {b : β} (hf : ∀ a ∈ s, f a = b) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f a) =\n      b ^ s.card :=\n  (prod_congr rfl hf).trans <| prod_const _\n#align prod_eq_pow_card prod_eq_pow_card\n\n",
 "prod_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_eq_one {f : α → β} {s : Finset α} (h : ∀ x ∈ s, f x = 1) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) = 1 :=\n  calc\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s 1 :=\n      Finset.prod_congr rfl h\n    _ = 1 := Finset.prod_const_one\n    \n#align prod_eq_one prod_eq_one\n\n",
 "prod_eq_multiset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_eq_multiset_prod [CommMonoid β] (s : Finset α) (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) =\n      (s.1.map f).prod :=\n  rfl\n#align prod_eq_multiset_prod prod_eq_multiset_prod\n\n",
 "prod_eq_mul_prod_diff_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_eq_mul_prod_diff_singleton [DecidableEq α] {s : Finset α} {i : α} (h : i ∈ s) (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) =\n      f i *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s \\ {i})\n          (f x) :=\n  by\n  convert(s.prod_inter_mul_prod_diff {i} f).symm\n  simp [h]\n#align prod_eq_mul_prod_diff_singleton prod_eq_mul_prod_diff_singleton\n\n",
 "prod_eq_mul_prod_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print Fintype.prod_eq_mul_prod_compl /-\n@[to_additive]\ntheorem Fintype.prod_eq_mul_prod_compl [DecidableEq α] [Fintype α] (a : α) (f : α → β) :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" (f i) =\n      f a *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" («expr ᶜ» {a})\n          (f i) :=\n  prod_eq_mul_prod_diff_singleton (mem_univ a) f\n#align fintype.prod_eq_mul_prod_compl Fintype.prod_eq_mul_prod_compl\n#align fintype.sum_eq_add_sum_compl Fintype.sum_eq_add_sum_compl\n-/\n\n",
 "prod_eq_mul_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_eq_mul_of_mem {s : Finset α} {f : α → β} (a b : α) (ha : a ∈ s) (hb : b ∈ s) (hn : a ≠ b)\n    (h₀ : ∀ c ∈ s, c ≠ a ∧ c ≠ b → f c = 1) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) =\n      f a * f b :=\n  by\n  haveI := Classical.decEq α <;> let s' := ({a, b} : Finset α)\n  have hu : s' ⊆ s := by\n    refine' insert_subset.mpr _\n    apply and.intro ha\n    apply singleton_subset_iff.mpr hb\n  have hf : ∀ c ∈ s, c ∉ s' → f c = 1 := by\n    intro c hc hcs\n    apply h₀ c hc\n    apply not_or_distrib.mp\n    intro hab\n    apply hcs\n    apply mem_insert.mpr\n    rw [mem_singleton]\n    exact hab\n  rw [← prod_subset hu hf]\n  exact Finset.prod_pair hn\n#align prod_eq_mul_of_mem prod_eq_mul_of_mem\n\n",
 "prod_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_eq_mul {s : Finset α} {f : α → β} (a b : α) (hn : a ≠ b) (h₀ : ∀ c ∈ s, c ≠ a ∧ c ≠ b → f c = 1)\n    (ha : a ∉ s → f a = 1) (hb : b ∉ s → f b = 1) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) =\n      f a * f b :=\n  by\n  haveI := Classical.decEq α <;> by_cases h₁ : a ∈ s <;> by_cases h₂ : b ∈ s\n  · exact prod_eq_mul_of_mem a b h₁ h₂ hn h₀\n  · rw [hb h₂, mul_one]\n    apply prod_eq_single_of_mem a h₁\n    exact fun c hc hca => h₀ c hc ⟨hca, ne_of_mem_of_not_mem hc h₂⟩\n  · rw [ha h₁, one_mul]\n    apply prod_eq_single_of_mem b h₂\n    exact fun c hc hcb => h₀ c hc ⟨ne_of_mem_of_not_mem hc h₁, hcb⟩\n  · rw [ha h₁, hb h₂, mul_one]\n    exact\n      trans (prod_congr rfl fun c hc => h₀ c hc ⟨ne_of_mem_of_not_mem hc h₁, ne_of_mem_of_not_mem hc h₂⟩) prod_const_one\n#align prod_eq_mul prod_eq_mul\n\n",
 "prod_eq_fold":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_eq_fold [CommMonoid β] (s : Finset α) (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) =\n      s.fold (· * ·) 1 f :=\n  rfl\n#align prod_eq_fold prod_eq_fold\n\n",
 "prod_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[to_additive]\ntheorem prod_empty {α β : Type _} [CommMonoid β] [IsEmpty α] [Fintype α] (f : α → β) :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" (f x) =\n      1 :=\n  Finset.prod_of_empty _\n#align prod_empty prod_empty\n\n",
 "prod_dvd_prod_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_dvd_prod_of_subset {ι M : Type _} [CommMonoid M] (s t : Finset ι) (f : ι → M) (h : s ⊆ t) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) ∣\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i) :=\n  Multiset.prod_dvd_prod_of_le <| Multiset.map_le_map <| by simpa\n#align prod_dvd_prod_of_subset prod_dvd_prod_of_subset\n\n",
 "prod_dvd_prod_of_dvd":
 "theorem prod_dvd_prod_of_dvd {S : Finset α} (g1 g2 : α → β) (h : ∀ a ∈ S, g1 a ∣ g2 a) : S.prod g1 ∣ S.prod g2 := by\n  classical\n    apply Finset.induction_on' S\n    · simp\n    intro a T haS _ haT IH\n    repeat' rw [Finset.prod_insert haT]\n    exact mul_dvd_mul (h a haS) IH\n#align prod_dvd_prod_of_dvd prod_dvd_prod_of_dvd\n\n",
 "prod_div_distrib":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_div_distrib :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x / g x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) /\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g x) :=\n  Multiset.prod_map_div\n#align prod_div_distrib prod_div_distrib\n\n",
 "prod_dite_of_true":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[to_additive]\ntheorem prod_dite_of_true {p : α → Prop} {hp : DecidablePred p} (h : ∀ x ∈ s, p x) (f : ∀ x : α, p x → β)\n    (g : ∀ x : α, ¬p x → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (if hx : p x then f x hx else g x hx) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (f x.val (h x.val x.property)) :=\n  prod_bij (fun x hx => ⟨x, hx⟩) (fun x hx => by simp)\n    (fun a ha => by\n      dsimp\n      rw [dif_pos])\n    (fun a₁ a₂ h₁ h₂ hh => congr_arg coe hh) fun b hb => ⟨b.1, b.2, by simp⟩\n#align prod_dite_of_true prod_dite_of_true\n\n",
 "prod_dite_of_false":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[to_additive]\ntheorem prod_dite_of_false {p : α → Prop} {hp : DecidablePred p} (h : ∀ x ∈ s, ¬p x) (f : ∀ x : α, p x → β)\n    (g : ∀ x : α, ¬p x → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (if hx : p x then f x hx else g x hx) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (g x.val (h x.val x.property)) :=\n  prod_bij (fun x hx => ⟨x, hx⟩) (fun x hx => by simp)\n    (fun a ha => by\n      dsimp\n      rw [dif_neg])\n    (fun a₁ a₂ h₁ h₂ hh => congr_arg coe hh) fun b hb => ⟨b.1, b.2, by simp⟩\n#align prod_dite_of_false prod_dite_of_false\n\n",
 "prod_dite_irrel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_dite_irrel (p : Prop) [Decidable p] (s : Finset α) (f : p → α → β) (g : ¬p → α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (if h : p then f h x else g h x) =\n      if h : p then\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f h x)\n      else\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g h x) :=\n  by split_ifs with h <;> rfl\n#align prod_dite_irrel prod_dite_irrel\n\n",
 "prod_dite_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_dite_eq' [DecidableEq α] (s : Finset α) (a : α) (b : ∀ x : α, x = a → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (if h : x = a then b x h else 1) =\n      ite (a ∈ s) (b a rfl) 1 :=\n  by\n  split_ifs with h\n  · rw [Finset.prod_eq_single a, dif_pos rfl]\n    · intros\n      rw [dif_neg]\n      cc\n    · cc\n  · rw [Finset.prod_eq_one]\n    intros\n    rw [dif_neg]\n    intro\n    cc\n#align prod_dite_eq' prod_dite_eq'\n\n",
 "prod_dite_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_dite_eq [DecidableEq α] (s : Finset α) (a : α) (b : ∀ x : α, a = x → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (if h : a = x then b x h else 1) =\n      ite (a ∈ s) (b a rfl) 1 :=\n  by\n  split_ifs with h\n  · rw [Finset.prod_eq_single a, dif_pos rfl]\n    · intros\n      rw [dif_neg]\n      cc\n    · cc\n  · rw [Finset.prod_eq_one]\n    intros\n    rw [dif_neg]\n    intro\n    cc\n#align prod_dite_eq prod_dite_eq\n\n",
 "prod_dite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_dite {s : Finset α} {p : α → Prop} {hp : DecidablePred p} (f : ∀ x : α, p x → β) (g : ∀ x : α, ¬p x → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (if hx : p x then f x hx else g x hx) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (s.filter p).attach (f x.1 (mem_filter.mp x.2).2) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (s.filter fun x => ¬p x).attach (g x.1 (mem_filter.mp x.2).2) :=\n  by simp [prod_apply_dite _ _ fun x => x]\n#align prod_dite prod_dite\n\n",
 "prod_disj_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_disj_union (h) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (s₁.disj_union s₂ h) (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₁ (f x) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s₂ (f x) :=\n  by\n  refine' Eq.trans _ (fold_disj_union h)\n  rw [one_mul]\n  rfl\n#align prod_disj_union prod_disj_union\n\n",
 "prod_disj_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_disj_sum (s : Finset α) (t : Finset γ) (f : Sum α γ → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.disj_sum t)\n        (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (f (Sum.inl x)) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t\n          (f (Sum.inr x)) :=\n  by\n  rw [← map_inl_disj_union_map_inr, prod_disj_union, Prod_map, Prod_map]\n  rfl\n#align prod_disj_sum prod_disj_sum\n\n",
 "prod_disj_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_disj_Union (s : Finset ι) (t : ι → Finset α) (h) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.disj_Union t h)\n        (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (t i)\n          (f x)) :=\n  by\n  refine' Eq.trans _ (fold_disj_Union h)\n  dsimp [Finset.prod, Multiset.prod, Multiset.fold, Finset.disjUnion, Finset.fold]\n  congr\n  exact prod_const_one.symm\n#align prod_disj_Union prod_disj_Union\n\n",
 "prod_const_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_const_one :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (1 : β) = 1 :=\n  by simp only [Finset.prod, Multiset.map_const, Multiset.prod_replicate, one_pow]\n#align prod_const_one prod_const_one\n\n",
 "prod_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_const (b : β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s b =\n      b ^ s.card :=\n  (congr_arg _ <| s.val.map_const b).trans <| Multiset.prod_replicate s.card b\n#align prod_const prod_const\n\n",
 "prod_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, to_additive]\ntheorem prod_cons (h : a ∉ s) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (cons a s h)\n        (f x) =\n      f a * finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  fold_cons h\n#align prod_cons prod_cons\n\n",
 "prod_congr_set":
 "/-- The product of a function `g` defined only on a set `s` is equal to\nthe product of a function `f` defined everywhere,\nas long as `f` and `g` agree on `s`, and `f = 1` off `s`. -/\n@[to_additive\n      \"The sum of a function `g` defined only on a set `s` is equal to\\nthe sum of a function `f` defined everywhere,\\nas long as `f` and `g` agree on `s`, and `f = 0` off `s`.\"]\ntheorem prod_congr_set {α : Type _} [CommMonoid α] {β : Type _} [Fintype β] (s : Set β) [DecidablePred (· ∈ s)]\n    (f : β → α) (g : s → α) (w : ∀ (x : β) (h : x ∈ s), f x = g ⟨x, h⟩) (w' : ∀ x : β, x ∉ s → f x = 1) :\n    Finset.univ.prod f = Finset.univ.prod g :=\n  by\n  rw [← @Finset.prod_subset _ _ s.to_finset Finset.univ f _ (by simp)]\n  · rw [Finset.prod_subtype]\n    · apply Finset.prod_congr rfl\n      exact fun ⟨x, h⟩ _ => w x h\n    · simp\n  · rintro x _ h\n    exact w' x (by simpa using h)\n#align prod_congr_set prod_congr_set\n\n",
 "prod_congr":
 "@[congr, to_additive]\ntheorem prod_congr (h : s₁ = s₂) : (∀ x ∈ s₂, f x = g x) → s₁.prod f = s₂.prod g := by rw [h] <;> exact fold_congr\n#align prod_congr prod_congr\n\n",
 "prod_compl_mul_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[to_additive]\ntheorem prod_compl_mul_prod [Fintype α] [DecidableEq α] (s : Finset α) (f : α → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" («expr ᶜ» s)\n          (f i) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (f i) :=\n  (@isCompl_compl _ s _).symm.prod_mul_prod f\n#align prod_compl_mul_prod prod_compl_mul_prod\n\n",
 "prod_comp_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Reindexing a product over a finset along an equivalence.\nSee `equiv.prod_comp` for the version where `s` and `s'` are `univ`. -/\n@[to_additive\n      \" Reindexing a sum over a finset along an equivalence.\\nSee `equiv.sum_comp` for the version where `s` and `s'` are `univ`. \"]\ntheorem equiv.prod_comp_finset {ι'} [DecidableEq ι] (e : «expr ≃ » ι ι') (f : ι' → β) {s' : Finset ι'} {s : Finset ι}\n    (h : s = s'.image e.symm) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s' (f i') =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f (e i)) :=\n  by\n  rw [h]\n  refine'\n    Finset.prod_bij' (fun i' hi' => e.symm i') (fun a ha => Finset.mem_image_of_mem _ ha)\n      (fun a ha => by simp_rw [e.apply_symm_apply]) (fun i hi => e i) (fun a ha => _) (fun a ha => e.apply_symm_apply a)\n      fun a ha => e.symm_apply_apply a\n  rcases finset.mem_image.mp ha with ⟨i', hi', rfl⟩\n  rwa [e.apply_symm_apply]\n#align equiv.prod_comp_finset equiv.prod_comp_finset\n\n",
 "prod_comp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print Equiv.Perm.prod_comp' /-\n@[to_additive]\ntheorem Equiv.Perm.prod_comp' (σ : Equiv.Perm α) (s : Finset α) (f : α → α → β) (hs : { a | σ a ≠ a } ⊆ s) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f (σ x) x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (f x (σ.symm x)) :=\n  by\n  convert σ.prod_comp s (fun x => f x (σ.symm x)) hs\n  ext\n  rw [Equiv.symm_apply_apply]\n#align equiv.perm.prod_comp' Equiv.Perm.prod_comp'\n#align equiv.perm.sum_comp' Equiv.Perm.sum_comp'\n-/\n\n",
 "prod_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- The product of the composition of functions `f` and `g`, is the product over `b ∈ s.image g` of\n`f b` to the power of the cardinality of the fibre of `b`. See also `finset.prod_image`. -/\n@[to_additive\n      \"The sum of the composition of functions `f` and `g`, is the sum over `b ∈ s.image g`\\nof `f b` times of the cardinality of the fibre of `b`. See also `finset.sum_image`.\"]\ntheorem prod_comp [DecidableEq γ] (f : γ → β) (g : α → γ) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f (g a)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.image g)\n        (f b ^ (s.filter fun a => g a = b).card) :=\n  calc\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f (g a)) =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          ((s.image g).sigma fun b : γ => s.filter fun a => g a = b) (f (g x.2)) :=\n      prod_bij (fun a ha => ⟨g a, a⟩) (by simp <;> tauto) (fun _ _ => rfl) (by simp)\n        (-- `(by finish)` closes this\n        by\n          rintro ⟨b_fst, b_snd⟩ H\n          simp only [mem_image, exists_prop, mem_filter, mem_sigma] at H\n          tauto)\n    _ =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.image g)\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (s.filter fun a => g a = b) (f (g a))) :=\n      (prod_sigma _ _ _)\n    _ =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.image g)\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (s.filter fun a => g a = b) (f b)) :=\n      (prod_congr rfl fun b hb => prod_congr rfl (by simp (config := { contextual := true })))\n    _ =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.image g)\n          (f b ^ (s.filter fun a => g a = b).card) :=\n      prod_congr rfl fun _ _ => prod_const _\n    \n#align prod_comp prod_comp\n\n",
 "prod_comm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Generalization of `finset.prod_comm` to the case when the inner `finset`s depend on the outer\nvariable. -/\n@[to_additive \"Generalization of `finset.sum_comm` to the case when the inner `finset`s depend on\\nthe outer variable.\"]\ntheorem prod_comm' {s : Finset γ} {t : γ → Finset α} {t' : Finset α} {s' : α → Finset γ}\n    (h : ∀ x y, x ∈ s ∧ y ∈ t x ↔ x ∈ s' y ∧ y ∈ t') {f : γ → α → β} :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (t x)\n          (f x y)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t'\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s' y)\n          (f x y)) :=\n  by\n  classical\n    have : ∀ z : γ × α, (z ∈ s.bUnion fun x => (t x).map <| Function.Embedding.sectr x _) ↔ z.1 ∈ s ∧ z.2 ∈ t z.1 :=\n      by\n      rintro ⟨x, y⟩\n      simp\n    exact\n      (prod_finset_product' _ _ _ this).symm.trans\n        (prod_finset_product_right' _ _ _ fun ⟨x, y⟩ => (this _).trans ((h x y).trans and_comm))\n#align prod_comm' prod_comm'\n\n",
 "prod_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_comm {s : Finset γ} {t : Finset α} {f : γ → α → β} :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f x y)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x y)) :=\n  prod_comm' fun _ _ => iff.rfl\n#align prod_comm prod_comm\n\n",
 "prod_coe_sort_eq_attach":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_coe_sort_eq_attach (f : s → β) :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" (f i) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s.attach\n        (f i) :=\n  rfl\n#align prod_coe_sort_eq_attach prod_coe_sort_eq_attach\n\n",
 "prod_coe_sort":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_coe_sort :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" (f i) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) :=\n  prod_attach\n#align prod_coe_sort prod_coe_sort\n\n",
 "prod_cancels_of_partition_cancels":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If we can partition a product into subsets that cancel out, then the whole product cancels. -/\n@[to_additive \"If we can partition a sum into subsets that cancel out, then the whole sum cancels.\"]\ntheorem prod_cancels_of_partition_cancels (R : setoid α) [DecidableRel R.r]\n    (h :\n      ∀ x ∈ s,\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (s.filter fun y => y ≈ x) (f a) =\n          1) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) = 1 :=\n  by\n  rw [prod_partition R, ← Finset.prod_eq_one]\n  intro xbar xbar_in_s\n  obtain ⟨x, x_in_s, xbar_eq_x⟩ := mem_image.mp xbar_in_s\n  rw [← xbar_eq_x, filter_congr fun y _ => @Quotient.eq' _ R y x]\n  apply h x x_in_s\n#align prod_cancels_of_partition_cancels prod_cancels_of_partition_cancels\n\n",
 "prod_boole":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_boole {s : Finset α} {p : α → Prop} [DecidablePred p] :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (ite (p i) (1 : β) (0 : β)) =\n      ite (∀ i ∈ s, p i) 1 0 :=\n  by\n  split_ifs\n  · apply prod_eq_one\n    intro i hi\n    rw [if_pos (h i hi)]\n  · push_neg  at h\n    rcases h with ⟨i, hi, hq⟩\n    apply prod_eq_zero hi\n    rw [if_neg hq]\n#align prod_boole prod_boole\n\n",
 "prod_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- `fintype.prod_bijective` is a variant of `finset.prod_bij` that accepts `function.bijective`.\n\nSee `function.bijective.prod_comp` for a version without `h`. -/\n@[to_additive\n      \"`fintype.sum_equiv` is a variant of `finset.sum_bij` that accepts\\n`function.bijective`.\\n\\nSee `function.bijective.sum_comp` for a version without `h`. \"]\ntheorem prod_bijective {α β M : Type _} [Fintype α] [Fintype β] [CommMonoid M] (e : α → β) (he : function.bijective e)\n    (f : α → M) (g : β → M) (h : ∀ x, f x = g (e x)) :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" (f x) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (g x) :=\n  prod_bij (fun x _ => e x) (fun x _ => mem_univ (e x)) (fun x _ => h x) (fun x x' _ _ h => he.injective h) fun y _ =>\n    (he.surjective y).imp fun a h => ⟨mem_univ _, h.symm⟩\n#align prod_bijective prod_bijective\n\n",
 "prod_bij_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_bij_ne_one {s : Finset α} {t : Finset γ} {f : α → β} {g : γ → β} (i : ∀ a ∈ s, f a ≠ 1 → γ)\n    (hi : ∀ a h₁ h₂, i a h₁ h₂ ∈ t) (i_inj : ∀ a₁ a₂ h₁₁ h₁₂ h₂₁ h₂₂, i a₁ h₁₁ h₁₂ = i a₂ h₂₁ h₂₂ → a₁ = a₂)\n    (i_surj : ∀ b ∈ t, g b ≠ 1 → ∃ a h₁ h₂, b = i a h₁ h₂) (h : ∀ a h₁ h₂, f a = g (i a h₁ h₂)) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (g x) :=\n  by\n  classical exact\n      calc\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) =\n            finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n              (s.filter fun x => f x ≠ 1) (f x) :=\n          prod_filter_ne_one.symm\n        _ =\n            finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n              (t.filter fun x => g x ≠ 1) (g x) :=\n          (prod_bij (fun a ha => i a (mem_filter.mp ha).1 (mem_filter.mp ha).2)\n            (fun a ha =>\n              (mem_filter.mp ha).elim fun h₁ h₂ => mem_filter.mpr ⟨hi a h₁ h₂, fun hg => h₂ (hg ▸ h a h₁ h₂)⟩)\n            (fun a ha => (mem_filter.mp ha).elim <| h a)\n            (fun a₁ a₂ ha₁ ha₂ =>\n              (mem_filter.mp ha₁).elim fun ha₁₁ ha₁₂ => (mem_filter.mp ha₂).elim fun ha₂₁ ha₂₂ => i_inj a₁ a₂ _ _ _ _)\n            fun b hb =>\n            (mem_filter.mp hb).elim fun h₁ h₂ =>\n              let ⟨a, ha₁, ha₂, Eq⟩ := i_surj b h₁ h₂\n              ⟨a, mem_filter.mpr ⟨ha₁, ha₂⟩, Eq⟩)\n        _ = finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (g x) :=\n          prod_filter_ne_one\n        \n#align prod_bij_ne_one prod_bij_ne_one\n\n",
 "prod_bij'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Reorder a product.\n\n  The difference with `prod_bij` is that the bijection is specified with an inverse, rather than\n  as a surjective injection.\n-/\n@[to_additive\n      \"\\n  Reorder a sum.\\n\\n  The difference with `sum_bij` is that the bijection is specified with an inverse, rather than\\n  as a surjective injection.\\n\"]\ntheorem prod_bij' {s : Finset α} {t : Finset γ} {f : α → β} {g : γ → β} (i : ∀ a ∈ s, γ) (hi : ∀ a ha, i a ha ∈ t)\n    (h : ∀ a ha, f a = g (i a ha)) (j : ∀ a ∈ t, α) (hj : ∀ a ha, j a ha ∈ s)\n    (left_inv : ∀ a ha, j (i a ha) (hi a ha) = a) (right_inv : ∀ a ha, i (j a ha) (hj a ha) = a) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (g x) :=\n  by\n  refine' prod_bij i hi h _ _\n  · intro a1 a2 h1 h2 eq\n    rw [← left_inv a1 h1, ← left_inv a2 h2]\n    cc\n  · intro b hb\n    use j b hb\n    use hj b hb\n    exact (right_inv b hb).symm\n#align prod_bij' prod_bij'\n\n",
 "prod_bij":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Reorder a product.\n\n  The difference with `prod_bij'` is that the bijection is specified as a surjective injection,\n  rather than by an inverse function.\n-/\n@[to_additive\n      \"\\n  Reorder a sum.\\n\\n  The difference with `sum_bij'` is that the bijection is specified as a surjective injection,\\n  rather than by an inverse function.\\n\"]\ntheorem prod_bij {s : Finset α} {t : Finset γ} {f : α → β} {g : γ → β} (i : ∀ a ∈ s, γ) (hi : ∀ a ha, i a ha ∈ t)\n    (h : ∀ a ha, f a = g (i a ha)) (i_inj : ∀ a₁ a₂ ha₁ ha₂, i a₁ ha₁ = i a₂ ha₂ → a₁ = a₂)\n    (i_surj : ∀ b ∈ t, ∃ a ha, b = i a ha) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (g x) :=\n  congr_arg Multiset.prod (Multiset.map_eq_map_of_bij_of_nodup f g s.2 t.2 i hi h i_inj i_surj)\n#align prod_bij prod_bij\n\n",
 "prod_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_bUnion [DecidableEq α] {s : Finset γ} {t : γ → Finset α} (hs : Set.PairwiseDisjoint (↑s) t) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.bUnion t)\n        (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (t x)\n          (f i)) :=\n  by rw [← disj_Union_eq_bUnion _ _ hs, prod_disj_Union]\n#align prod_bUnion prod_bUnion\n\n",
 "prod_attach":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_attach {f : α → β} :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s.attach (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  haveI := Classical.decEq α\n  calc\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s.attach\n          (f x.val) =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (s.attach.image Subtype.val) (f x) :=\n      by rw [prod_image] <;> exact fun x _ y _ => Subtype.eq\n    _ = _ := by rw [attach_image_val]\n    \n#align prod_attach prod_attach\n\n",
 "prod_apply_ite_of_true":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_apply_ite_of_true {p : α → Prop} {hp : DecidablePred p} (f g : α → γ) (k : γ → β) (h : ∀ x ∈ s, p x) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (k (if p x then f x else g x)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (k (f x)) :=\n  by\n  simp_rw [apply_ite k]\n  exact prod_ite_of_true _ _ h\n#align prod_apply_ite_of_true prod_apply_ite_of_true\n\n",
 "prod_apply_ite_of_false":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_apply_ite_of_false {p : α → Prop} {hp : DecidablePred p} (f g : α → γ) (k : γ → β) (h : ∀ x ∈ s, ¬p x) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (k (if p x then f x else g x)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (k (g x)) :=\n  by\n  simp_rw [apply_ite k]\n  exact prod_ite_of_false _ _ h\n#align prod_apply_ite_of_false prod_apply_ite_of_false\n\n",
 "prod_apply_ite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_apply_ite {s : Finset α} {p : α → Prop} {hp : DecidablePred p} (f g : α → γ) (h : γ → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (h (if p x then f x else g x)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.filter p)\n          (h (f x)) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (s.filter fun x => ¬p x) (h (g x)) :=\n  trans (prod_apply_dite _ _ _) (congr_arg₂ _ (@prod_attach _ _ _ _ (h ∘ f)) (@prod_attach _ _ _ _ (h ∘ g)))\n#align prod_apply_ite prod_apply_ite\n\n",
 "prod_apply_dite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_apply_dite {s : Finset α} {p : α → Prop} {hp : DecidablePred p} [DecidablePred fun x => ¬p x]\n    (f : ∀ x : α, p x → γ) (g : ∀ x : α, ¬p x → γ) (h : γ → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (h (if hx : p x then f x hx else g x hx)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (s.filter p).attach (h (f x.1 (mem_filter.mp x.2).2)) *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (s.filter fun x => ¬p x).attach (h (g x.1 (mem_filter.mp x.2).2)) :=\n  calc\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (h (if hx : p x then f x hx else g x hx)) =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.filter p)\n            (h (if hx : p x then f x hx else g x hx)) *\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (s.filter fun x => ¬p x) (h (if hx : p x then f x hx else g x hx)) :=\n      (prod_filter_mul_prod_filter_not s p _).symm\n    _ =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (s.filter p).attach (h (if hx : p x.1 then f x.1 hx else g x.1 hx)) *\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (s.filter fun x => ¬p x).attach (h (if hx : p x.1 then f x.1 hx else g x.1 hx)) :=\n      (congr_arg₂ _ prod_attach.symm prod_attach.symm)\n    _ =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (s.filter p).attach (h (f x.1 (mem_filter.mp x.2).2)) *\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (s.filter fun x => ¬p x).attach (h (g x.1 (mem_filter.mp x.2).2)) :=\n      congr_arg₂ _ (prod_congr rfl fun x hx => congr_arg h (dif_pos (mem_filter.mp x.2).2))\n        (prod_congr rfl fun x hx => congr_arg h (dif_neg (mem_filter.mp x.2).2))\n    \n#align prod_apply_dite prod_apply_dite\n\n",
 "prod_add_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If `f = g = h` everywhere but at `i`, where `f i = g i + h i`, then the product of `f` over `s`\n  is the sum of the products of `g` and `h`. -/\ntheorem prod_add_prod_eq [CommSemiring β] {s : Finset α} {i : α} {f g h : α → β} (hi : i ∈ s) (h1 : g i + h i = f i)\n    (h2 : ∀ j ∈ s, j ≠ i → g j = f j) (h3 : ∀ j ∈ s, j ≠ i → h j = f j) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g i) +\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (h i) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) :=\n  by\n  classical\n    simp_rw [prod_eq_mul_prod_diff_singleton hi, ← h1, right_distrib]\n    congr 2 <;> apply prod_congr rfl <;> simpa\n#align prod_add_prod_eq prod_add_prod_eq\n\n",
 "pow_eq_prod_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem pow_eq_prod_const (b : β) :\n    ∀ n,\n      b ^ n =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range n) b :=\n  by simp\n#align pow_eq_prod_const pow_eq_prod_const\n\n",
 "op_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- Moving to the opposite additive commutative monoid commutes with summing. -/\n@[simp]\ntheorem op_sum [AddCommMonoid β] {s : Finset α} (f : α → β) :\n    op (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (op (f x)) :=\n  (opAddEquiv : «expr ≃+ » β («expr ᵐᵒᵖ» β)).map_sum _ _\n#align op_sum op_sum\n\n",
 "ofMul_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print ofMul_prod /-\n@[simp]\ntheorem ofMul_prod (s : Finset ι) (f : ι → α) :\n    ofMul (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (ofMul (f i)) :=\n  rfl\n#align of_mul_prod ofMul_prod\n-/\n\n",
 "ofMul_multiset_prod":
 "#print ofMul_multiset_prod /-\n@[simp]\ntheorem ofMul_multiset_prod (s : Multiset α) : ofMul s.prod = (s.map ofMul).sum := by simpa [of_mul]\n#align of_mul_multiset_prod ofMul_multiset_prod\n-/\n\n",
 "ofMul_list_prod":
 "#print ofMul_list_prod /-\n@[simp]\ntheorem ofMul_list_prod (s : List α) : ofMul s.prod = (s.map ofMul).sum := by simpa [of_mul]\n#align of_mul_list_prod ofMul_list_prod\n-/\n\n",
 "ofAdd_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print ofAdd_sum /-\n@[simp]\ntheorem ofAdd_sum (s : Finset ι) (f : ι → α) :\n    ofAdd (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (ofAdd (f i)) :=\n  rfl\n#align of_add_sum ofAdd_sum\n-/\n\n",
 "ofAdd_multiset_prod":
 "#print ofAdd_multiset_prod /-\n@[simp]\ntheorem ofAdd_multiset_prod (s : Multiset α) : ofAdd s.sum = (s.map ofAdd).prod := by simpa [of_add]\n#align of_add_multiset_prod ofAdd_multiset_prod\n-/\n\n",
 "ofAdd_list_prod":
 "#print ofAdd_list_prod /-\n@[simp]\ntheorem ofAdd_list_prod (s : List α) : ofAdd s.sum = (s.map ofAdd).prod := by simpa [of_add]\n#align of_add_list_prod ofAdd_list_prod\n-/\n\n",
 "nonempty_of_prod_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem nonempty_of_prod_ne_one\n    (h :\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) ≠ 1) :\n    s.nonempty :=\n  s.eq_empty_or_nonempty.elim (fun H => false.elim <| h <| H.symm ▸ prod_empty) id\n#align nonempty_of_prod_ne_one nonempty_of_prod_ne_one\n\n",
 "nat_abs_sum_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print nat_abs_sum_le /-\ntheorem nat_abs_sum_le {ι : Type _} (s : Finset ι) (f : ι → ℤ) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i)).nat_abs ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i).nat_abs :=\n  by\n  classical\n    apply Finset.induction_on s\n    · simp only [Finset.sum_empty, Int.natAbs_zero]\n    · intro i s his IH\n      simp only [his, Finset.sum_insert, not_false_iff]\n      exact (Int.natAbs_add_le _ _).trans (add_le_add le_rfl IH)\n#align nat_abs_sum_le nat_abs_sum_le\n-/\n\n",
 "mul_prod_erase":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Taking a product over `s : finset α` is the same as multiplying the value on a single element\n`f a` by the product of `s.erase a`.\n\nSee `multiset.prod_map_erase` for the `multiset` version. -/\n@[to_additive\n      \"Taking a sum over `s : finset α` is the same as adding the value on a single element\\n`f a` to the sum over `s.erase a`.\\n\\nSee `multiset.sum_map_erase` for the `multiset` version.\"]\ntheorem mul_prod_erase [DecidableEq α] (s : Finset α) (f : α → β) {a : α} (h : a ∈ s) :\n    f a *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.erase a)\n          (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  by rw [← prod_insert (not_mem_erase a s), insert_erase h]\n#align mul_prod_erase mul_prod_erase\n\n",
 "mk0_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print Units.mk0_prod /-\ntheorem Units.mk0_prod [CommGroupWithZero β] (s : Finset α) (f : α → β) (h) :\n    Units.mk0\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f b)) h =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s.attach\n        (Units.mk0 (f b) fun hh => h (Finset.prod_eq_zero b.2 hh)) :=\n  by classical induction s using Finset.induction_on <;> simp [*]\n#align units.mk0_prod Units.mk0_prod\n-/\n\n",
 "mem_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mem_sum {f : α → Multiset β} (s : Finset α) (b : β) :\n    b ∈ finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x) ↔\n      ∃ a ∈ s, b ∈ f a :=\n  by\n  classical\n    refine' s.induction_on (by simp) _\n    · intro a t hi ih\n      simp [sum_insert hi, ih, or_and_right, exists_or]\n#align mem_sum mem_sum\n\n",
 "map_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print RingHom.map_sum /-\n/-- Deprecated: use `_root_.map_sum` instead. -/\nprotected theorem RingHom.map_sum [NonAssocSemiring β] [NonAssocSemiring γ] (g : «expr →+* » β γ) (f : α → β)\n    (s : Finset α) :\n    g (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (g (f x)) :=\n  map_sum g f s\n#align ring_hom.map_sum RingHom.map_sum\n-/\n\n",
 "map_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print RingHom.map_prod /-\n/-- Deprecated: use `_root_.map_prod` instead. -/\nprotected theorem RingHom.map_prod [CommSemiring β] [CommSemiring γ] (g : «expr →+* » β γ) (f : α → β) (s : Finset α) :\n    g (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g (f x)) :=\n  map_prod g f s\n#align ring_hom.map_prod RingHom.map_prod\n-/\n\n",
 "map_multiset_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print RingHom.map_multiset_sum /-\n/-- Deprecated: use `_root_.map_multiset_sum` instead. -/\nprotected theorem RingHom.map_multiset_sum [NonAssocSemiring β] [NonAssocSemiring γ] (f : «expr →+* » β γ)\n    (s : Multiset β) : f s.sum = (s.map f).sum :=\n  map_multiset_sum f s\n#align ring_hom.map_multiset_sum RingHom.map_multiset_sum\n-/\n\n",
 "map_multiset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print RingHom.map_multiset_prod /-\n/-- Deprecated: use `_root_.map_multiset_prod` instead. -/\nprotected theorem RingHom.map_multiset_prod [CommSemiring β] [CommSemiring γ] (f : «expr →+* » β γ) (s : Multiset β) :\n    f s.prod = (s.map f).prod :=\n  map_multiset_prod f s\n#align ring_hom.map_multiset_prod RingHom.map_multiset_prod\n-/\n\n",
 "map_list_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print RingHom.map_list_sum /-\n/-- Deprecated: use `_root_.map_list_sum` instead. -/\nprotected theorem RingHom.map_list_sum [NonAssocSemiring β] [NonAssocSemiring γ] (f : «expr →+* » β γ) (l : List β) :\n    f l.sum = (l.map f).sum :=\n  map_list_sum f l\n#align ring_hom.map_list_sum RingHom.map_list_sum\n-/\n\n",
 "map_list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print RingHom.map_list_prod /-\n/-- Deprecated: use `_root_.map_list_prod` instead. -/\nprotected theorem RingHom.map_list_prod [Semiring β] [Semiring γ] (f : «expr →+* » β γ) (l : List β) :\n    f l.prod = (l.map f).prod :=\n  map_list_prod f l\n#align ring_hom.map_list_prod RingHom.map_list_prod\n-/\n\n",
 "finset_sum_eq_sup_iff_disjoint":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∈ » i) -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » i) -/\ntheorem finset_sum_eq_sup_iff_disjoint {β : Type _} {i : Finset β} {f : β → Multiset α} :\n    i.sum f = i.sup f ↔ ∀ (x) (_ : x ∈ i) (y) (_ : y ∈ i), x ≠ y → Multiset.Disjoint (f x) (f y) :=\n  by\n  induction' i using Finset.cons_induction_on with z i hz hr\n  ·\n    simp only [Finset.not_mem_empty, IsEmpty.forall_iff, imp_true_iff, Finset.sum_empty, Finset.sup_empty, bot_eq_zero,\n      eq_self_iff_true]\n  · simp_rw [Finset.sum_cons hz, Finset.sup_cons, Finset.mem_cons, Multiset.sup_eq_union, forall_eq_or_imp, ne.def,\n      eq_self_iff_true, not_true, IsEmpty.forall_iff, true_and_iff, imp_and, forall_and, ← hr, @eq_comm _ z]\n    have := fun x (_ : x ∈ i) => ne_of_mem_of_not_mem H hz\n    simp (config := { contextual := true }) only [this, not_false_iff, true_imp_iff]\n    simp_rw [← disjoint_finset_sum_left, ← disjoint_finset_sum_right, disjoint_comm, ← and_assoc', and_self_iff]\n    exact add_eq_union_left_of_le (Finset.sup_le fun x hx => le_sum_of_mem (mem_map_of_mem f hx))\n#align finset_sum_eq_sup_iff_disjoint finset_sum_eq_sup_iff_disjoint\n\n",
 "finset_prod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print MonoidHom.finset_prod_apply /-\n-- See also `finset.prod_apply`, with the same conclusion\n-- but with the weaker hypothesis `f : α → β → γ`.\n@[simp, to_additive]\ntheorem MonoidHom.finset_prod_apply [MulOneClass β] [CommMonoid γ] (f : α → «expr →* » β γ) (s : Finset α) (b : β) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x)) b =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x b) :=\n  (MonoidHom.eval b).map_prod _ _\n#align monoid_hom.finset_prod_apply MonoidHom.finset_prod_apply\n#align add_monoid_hom.finset_sum_apply AddMonoidHom.finset_sum_apply\n-/\n\n",
 "exists_smul_of_dvd_count":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_smul_of_dvd_count (s : Multiset α) {k : ℕ} (h : ∀ a : α, a ∈ s → k ∣ Multiset.count a s) :\n    ∃ u : Multiset α, s = «expr • » k u :=\n  by\n  use\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.to_finset\n      («expr • » (s.count a / k) {a})\n  have h₂ :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.to_finset\n        («expr • » k («expr • » (count x s / k) ({x} : Multiset α))) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s.to_finset\n        («expr • » (count x s) {x}) :=\n    by\n    apply Finset.sum_congr rfl\n    intro x hx\n    rw [← mul_nsmul', Nat.mul_div_cancel' (h x (mem_to_finset.mp hx))]\n  rw [← Finset.sum_nsmul, h₂, to_finset_sum_count_nsmul_eq]\n#align exists_smul_of_dvd_count exists_smul_of_dvd_count\n\n",
 "exists_ne_one_of_prod_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem exists_ne_one_of_prod_ne_one\n    (h :\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) ≠ 1) :\n    ∃ a ∈ s, f a ≠ 1 := by\n  classical\n    rw [← prod_filter_ne_one] at h\n    rcases nonempty_of_prod_ne_one h with ⟨x, hx⟩\n    exact ⟨x, (mem_filter.1 hx).1, (mem_filter.1 hx).2⟩\n#align exists_ne_one_of_prod_ne_one exists_ne_one_of_prod_ne_one\n\n",
 "eventually_constant_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem eventually_constant_prod {u : ℕ → β} {N : ℕ} (hu : ∀ n ≥ N, u n = 1) {n : ℕ} (hn : N ≤ n) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range (n + 1))\n        (u k) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range (N + 1))\n        (u k) :=\n  by\n  obtain ⟨m, rfl : n = N + m⟩ := le_iff_exists_add.mp hn\n  clear hn\n  induction' m with m hm\n  · simp\n  erw [prod_range_succ, hm]\n  simp [hu, @zero_le' ℕ]\n#align eventually_constant_prod eventually_constant_prod\n\n",
 "eq_prod_range_div'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem eq_prod_range_div' {M : Type _} [CommGroup M] (f : ℕ → M) (n : ℕ) :\n    f n =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range (n + 1))\n        (if i = 0 then f 0 else f i / f (i - 1)) :=\n  by\n  conv_lhs => rw [Finset.eq_prod_range_div f]\n  simp [Finset.prod_range_succ', mul_comm]\n#align eq_prod_range_div' eq_prod_range_div'\n\n",
 "eq_prod_range_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem eq_prod_range_div {M : Type _} [CommGroup M] (f : ℕ → M) (n : ℕ) :\n    f n =\n      f 0 *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range n)\n          (f (i + 1) / f i) :=\n  by rw [prod_range_div, mul_div_cancel'_right]\n#align eq_prod_range_div eq_prod_range_div\n\n",
 "eq_one_of_prod_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If a product is 1 and the function is 1 except possibly at one\npoint, it is 1 everywhere on the `finset`. -/\n@[to_additive \"If a sum is 0 and the function is 0 except possibly at one\\npoint, it is 0 everywhere on the `finset`.\"]\ntheorem eq_one_of_prod_eq_one {s : Finset α} {f : α → β} {a : α}\n    (hp : finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) = 1)\n    (h1 : ∀ x ∈ s, x ≠ a → f x = 1) : ∀ x ∈ s, f x = 1 :=\n  by\n  intro x hx\n  classical\n    by_cases h : x = a\n    · rw [h]\n      rw [h] at hx\n      rw [← prod_subset (singleton_subset_iff.2 hx) fun t ht ha => h1 t ht (not_mem_singleton.1 ha), prod_singleton] at\n        hp\n      exact hp\n    · exact h1 x hx h\n#align eq_one_of_prod_eq_one eq_one_of_prod_eq_one\n\n",
 "eq_of_card_le_one_of_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If a product of a `finset` of size at most 1 has a given value, so\ndo the terms in that product. -/\n@[to_additive eq_of_card_le_one_of_sum_eq\n      \"If a sum of a `finset` of size at most 1 has a given\\nvalue, so do the terms in that sum.\"]\ntheorem eq_of_card_le_one_of_prod_eq {s : Finset α} (hc : s.card ≤ 1) {f : α → β} {b : β}\n    (h :\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) = b) :\n    ∀ x ∈ s, f x = b := by\n  intro x hx\n  by_cases hc0 : s.card = 0\n  · exact false.elim (card_ne_zero_of_mem hx hc0)\n  · have h1 : s.card = 1 := le_antisymm hc (Nat.one_le_of_lt (nat.pos_of_ne_zero hc0))\n    rw [card_eq_one] at h1\n    cases' h1 with x2 hx2\n    rw [hx2, mem_singleton] at hx\n    simp_rw [hx2] at h\n    rw [hx]\n    rw [prod_singleton] at h\n    exact h\n#align eq_of_card_le_one_of_prod_eq eq_of_card_le_one_of_prod_eq\n\n",
 "dvd_prod_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem dvd_prod_of_mem (f : α → β) {a : α} {s : Finset α} (ha : a ∈ s) :\n    f a ∣ finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) :=\n  by\n  classical\n    rw [Finset.prod_eq_mul_prod_diff_singleton ha]\n    exact dvd_mul_right _ _\n#align dvd_prod_of_mem dvd_prod_of_mem\n\n",
 "disjoint_sum_right":
 "theorem disjoint_sum_right {a : Multiset α} {i : Multiset (Multiset α)} :\n    Multiset.Disjoint a i.sum ↔ ∀ b ∈ i, Multiset.Disjoint a b := by simpa only [disjoint_comm] using disjoint_sum_left\n#align disjoint_sum_right disjoint_sum_right\n\n",
 "disjoint_sum_left":
 "theorem disjoint_sum_left {a : Multiset α} {i : Multiset (Multiset α)} :\n    Multiset.Disjoint i.sum a ↔ ∀ b ∈ i, Multiset.Disjoint b a :=\n  Quotient.inductionOn i fun l => by\n    rw [quot_mk_to_coe, Multiset.coe_sum]\n    exact disjoint_list_sum_left\n#align disjoint_sum_left disjoint_sum_left\n\n",
 "disjoint_list_sum_right":
 "theorem disjoint_list_sum_right {a : Multiset α} {l : List (Multiset α)} :\n    Multiset.Disjoint a l.sum ↔ ∀ b ∈ l, Multiset.Disjoint a b := by\n  simpa only [disjoint_comm] using disjoint_list_sum_left\n#align disjoint_list_sum_right disjoint_list_sum_right\n\n",
 "disjoint_list_sum_left":
 "theorem disjoint_list_sum_left {a : Multiset α} {l : List (Multiset α)} :\n    Multiset.Disjoint l.sum a ↔ ∀ b ∈ l, Multiset.Disjoint b a :=\n  by\n  induction' l with b bs ih\n  · simp only [zero_disjoint, list.not_mem_nil, IsEmpty.forall_iff, forall_const, List.sum_nil]\n  · simp_rw [List.sum_cons, disjoint_add_left, List.mem_cons, forall_eq_or_imp]\n    simp [and_congr_left_iff, iff_self_iff, ih]\n#align disjoint_list_sum_left disjoint_list_sum_left\n\n",
 "disjoint_finset_sum_right":
 "theorem disjoint_finset_sum_right {β : Type _} {i : Finset β} {f : β → Multiset α} {a : Multiset α} :\n    Multiset.Disjoint a (i.sum f) ↔ ∀ b ∈ i, Multiset.Disjoint a (f b) := by\n  simpa only [disjoint_comm] using disjoint_finset_sum_left\n#align disjoint_finset_sum_right disjoint_finset_sum_right\n\n",
 "disjoint_finset_sum_left":
 "theorem disjoint_finset_sum_left {β : Type _} {i : Finset β} {f : β → Multiset α} {a : Multiset α} :\n    Multiset.Disjoint (i.sum f) a ↔ ∀ b ∈ i, Multiset.Disjoint (f b) a :=\n  by\n  convert(@disjoint_sum_left _ a) (map f i.val)\n  simp [and_congr_left_iff, iff_self_iff]\n#align disjoint_finset_sum_left disjoint_finset_sum_left\n\n",
 "count_sum'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem count_sum' {s : Finset β} {a : α} {f : β → Multiset α} :\n    count a (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (count a (f x)) :=\n  by\n  dsimp only [Finset.sum]\n  rw [count_sum]\n#align count_sum' count_sum'\n\n",
 "coe_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print Units.coe_prod /-\n@[simp, norm_cast]\ntheorem Units.coe_prod {M : Type _} [CommMonoid M] (f : α → «expr ˣ» M) (s : Finset α) :\n    (↑(finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) : M) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) :=\n  (Units.coeHom M).map_prod _ _\n#align units.coe_prod Units.coe_prod\n-/\n\n",
 "coe_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print MonoidHom.coe_finset_prod /-\n@[to_additive]\ntheorem MonoidHom.coe_finset_prod [MulOneClass β] [CommMonoid γ] (f : α → «expr →* » β γ) (s : Finset α) :\n    «expr⇑ »\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x) :=\n  (MonoidHom.coeFn β γ).map_prod _ _\n#align monoid_hom.coe_finset_prod MonoidHom.coe_finset_prod\n#align add_monoid_hom.coe_finset_sum AddMonoidHom.coe_finset_sum\n-/\n\n",
 "cast_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp, norm_cast]\ntheorem cast_sum [AddCommGroupWithOne β] (s : Finset α) (f : α → ℤ) :\n    ↑(finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x) : ℤ) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x : β) :=\n  map_sum (castAddHom β) _ _\n#align cast_sum cast_sum\n\n",
 "cast_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, norm_cast]\ntheorem cast_prod {R : Type _} [CommRing R] (f : α → ℤ) (s : Finset α) :\n    (↑(finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) : R) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) :=\n  (Int.castRingHom R).map_prod _ _\n#align cast_prod cast_prod\n\n",
 "cast_multiset_sum":
 "@[simp, norm_cast]\ntheorem cast_multiset_sum [AddCommGroupWithOne β] (s : Multiset ℤ) : (↑s.sum : β) = (s.map coe).sum :=\n  map_multiset_sum (castAddHom β) _\n#align cast_multiset_sum cast_multiset_sum\n\n",
 "cast_multiset_prod":
 "@[simp, norm_cast]\ntheorem cast_multiset_prod {R : Type _} [CommRing R] (s : Multiset ℤ) : (↑s.prod : R) = (s.map coe).prod :=\n  map_multiset_prod (castRingHom R) _\n#align cast_multiset_prod cast_multiset_prod\n\n",
 "cast_list_sum":
 "@[simp, norm_cast]\ntheorem cast_list_sum [AddGroupWithOne β] (s : List ℤ) : (↑s.sum : β) = (s.map coe).sum :=\n  map_list_sum (castAddHom β) _\n#align cast_list_sum cast_list_sum\n\n",
 "cast_list_prod":
 "@[simp, norm_cast]\ntheorem cast_list_prod [Ring β] (s : List ℤ) : (↑s.prod : β) = (s.map coe).prod :=\n  map_list_prod (castRingHom β) _\n#align cast_list_prod cast_list_prod\n\n",
 "card_sigma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem card_sigma {σ : α → Type _} (s : Finset α) (t : ∀ a, Finset (σ a)) :\n    card (s.sigma t) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (card (t a)) :=\n  Multiset.card_sigma _ _\n#align card_sigma card_sigma\n\n",
 "card_eq_sum_ones":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem card_eq_sum_ones (s : Finset α) :\n    s.card = finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s 1 := by\n  simp\n#align card_eq_sum_ones card_eq_sum_ones\n\n",
 "card_eq_sum_card_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem card_eq_sum_card_image [DecidableEq β] (f : α → β) (s : Finset α) :\n    s.card =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (s.image f)\n        (s.filter fun x => f x = a).card :=\n  card_eq_sum_card_fiberwise fun _ => mem_image_of_mem _\n#align card_eq_sum_card_image card_eq_sum_card_image\n\n",
 "card_eq_sum_card_fiberwise":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem card_eq_sum_card_fiberwise [DecidableEq β] {f : α → β} {s : Finset α} {t : Finset β} (H : ∀ x ∈ s, f x ∈ t) :\n    s.card =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n        (s.filter fun x => f x = a).card :=\n  by simp only [card_eq_sum_ones, sum_fiberwise_of_maps_to H]\n#align card_eq_sum_card_fiberwise card_eq_sum_card_fiberwise\n\n",
 "card_disj_Union":
 "@[simp]\ntheorem card_disj_Union (s : Finset α) (t : α → Finset β) (h) : (s.disj_Union t h).card = s.sum fun i => (t i).card :=\n  Multiset.card_bind _ _\n#align card_disj_Union card_disj_Union\n\n",
 "card_bUnion_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem card_bUnion_le [DecidableEq β] {s : Finset α} {t : α → Finset β} :\n    (s.bUnion t).card ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (t a).card :=\n  haveI := Classical.decEq α\n  Finset.induction_on s (by simp) fun a s has ih =>\n    calc\n      ((insert a s).bUnion t).card ≤ (t a).card + (s.bUnion t).card := by\n        rw [bUnion_insert] <;> exact Finset.card_union_le _ _\n      _ ≤\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (insert a s)\n            (card (t a)) :=\n        by rw [sum_insert has] <;> exact add_le_add_left ih _\n      \n#align card_bUnion_le card_bUnion_le\n\n",
 "card_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem card_bUnion [DecidableEq β] {s : Finset α} {t : α → Finset β}\n    (h : ∀ x ∈ s, ∀ y ∈ s, x ≠ y → Disjoint (t x) (t y)) :\n    (s.bUnion t).card =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (card (t u)) :=\n  calc\n    (s.bUnion t).card =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (s.bUnion t)\n          1 :=\n      by simp\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (t a) 1) :=\n      (Finset.sum_bunionᵢ h)\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n          (card (t u)) :=\n      by simp\n    \n#align card_bUnion card_bUnion\n\n",
 "add_eq_union_right_of_le":
 "theorem add_eq_union_right_of_le {x y z : Multiset α} (h : z ≤ y) : x + y = x ∪ z ↔ y = z ∧ x.disjoint y := by\n  simpa only [and_comm'] using add_eq_union_left_of_le h\n#align add_eq_union_right_of_le add_eq_union_right_of_le\n\n",
 "add_eq_union_left_of_le":
 "theorem add_eq_union_left_of_le {x y z : Multiset α} (h : y ≤ x) : z + x = z ∪ y ↔ z.disjoint x ∧ x = y :=\n  by\n  rw [← add_eq_union_iff_disjoint]\n  constructor\n  · intro h0\n    rw [and_iff_right_of_imp]\n    · exact (le_of_add_le_add_left <| h0.trans_le <| union_le_add z y).antisymm h\n    · rintro rfl\n      exact h0\n  · rintro ⟨h0, rfl⟩\n    exact h0\n#align add_eq_union_left_of_le add_eq_union_left_of_le\n\n",
 "Prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print Prod_map /-\n@[simp, to_additive]\ntheorem Prod_map (s : Finset α) (e : «expr ↪ » α γ) (f : γ → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (s.map e) (f x) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f (e x)) :=\n  by rw [Finset.prod, Finset.map_val, Multiset.map_map] <;> rfl\n#align prod_map Prod_map\n-/\n\n"}