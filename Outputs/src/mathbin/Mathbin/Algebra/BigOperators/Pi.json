{"univ_sum_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n-- As we only defined `single` into `add_monoid`, we only prove the `finset.sum` version here.\ntheorem finset.univ_sum_single [fintype I] (f : ∀ i, Z i) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (Pi.single i (f i)) =\n      f :=\n  by\n  ext a\n  simp\n#align finset.univ_sum_single finset.univ_sum_single\n\n",
 "snd_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem snd_prod :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f c)).2 =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f c).2 :=\n  (MonoidHom.snd α β).map_prod f s\n#align snd_prod snd_prod\n\n",
 "prod_mk_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive prod_mk_sum]\ntheorem prod_mk_prod {α β γ : Type _} [comm_monoid α] [comm_monoid β] (s : Finset γ) (f : γ → α) (g : γ → β) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x),\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g x)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f x, g x) :=\n  haveI := classical.dec_eq γ\n  Finset.induction_on s rfl (by simp (config := { contextual := true }) [prod.ext_iff])\n#align prod_mk_prod prod_mk_prod\n\n",
 "prod_fn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- An 'unapplied' analogue of `finset.prod_apply`. -/\n@[to_additive \"An 'unapplied' analogue of `finset.sum_apply`.\"]\ntheorem finset.prod_fn {α : Type _} {β : α → Type _} {γ} [∀ a, comm_monoid (β a)] (s : Finset γ) (g : γ → ∀ a, β a) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g c) = fun a =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g c a) :=\n  funext fun a => finset.prod_apply _ _ _\n#align finset.prod_fn finset.prod_fn\n\n",
 "prod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[simp, to_additive]\ntheorem fintype.prod_apply {α : Type _} {β : α → Type _} {γ : Type _} [fintype γ] [∀ a, comm_monoid (β a)] (a : α)\n    (g : γ → ∀ a, β a) :\n    (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" (g c))\n        a =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (g c a) :=\n  finset.prod_apply a finset.univ g\n#align fintype.prod_apply fintype.prod_apply\n\n",
 "multiset_prod_apply":
 "@[to_additive]\ntheorem multiset_prod_apply {α : Type _} {β : α → Type _} [∀ a, comm_monoid (β a)] (a : α) (s : Multiset (∀ a, β a)) :\n    s.prod a = (s.map fun f : ∀ a, β a => f a).prod :=\n  (evalMonoidHom β a).map_multiset_prod _\n#align multiset_prod_apply multiset_prod_apply\n\n",
 "list_prod_apply":
 "/-\nCopyright (c) 2018 Simon Hudon. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Simon Hudon, Patrick Massot\n-/\n@[to_additive]\ntheorem list_prod_apply {α : Type _} {β : α → Type _} [∀ a, monoid (β a)] (a : α) (l : list (∀ a, β a)) :\n    l.prod a = (l.map fun f : ∀ a, β a => f a).prod :=\n  (evalMonoidHom β a).map_list_prod _\n#align list_prod_apply list_prod_apply\n\n",
 "functions_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/-- This is used as the ext lemma instead of `add_monoid_hom.functions_ext` for reasons explained in\nnote [partially-applied ext lemmas]. -/\n@[ext]\ntheorem add_monoid_hom.functions_ext' [Finite I] (M : Type _) [add_comm_monoid M] (g h : «expr →+ » (∀ i, Z i) M)\n    (H : ∀ i, g.comp (AddMonoidHom.single Z i) = h.comp (AddMonoidHom.single Z i)) : g = h :=\n  have := fun i => AddMonoidHom.congr_fun (H i)\n  -- elab without an expected type\n      g.functions_ext\n    M h this\n#align add_monoid_hom.functions_ext' add_monoid_hom.functions_ext'\n\n",
 "functions_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[ext]\ntheorem ring_hom.functions_ext [Finite I] (G : Type _) [NonAssocSemiring G] (g h : «expr →+* » (∀ i, f i) G)\n    (H : ∀ (i : I) (x : f i), g (single i x) = h (single i x)) : g = h :=\n  RingHom.coe_addMonoidHom_injective <| @add_monoid_hom.functions_ext I _ f _ _ G _ (g : «expr →+ » (∀ i, f i) G) h H\n#align ring_hom.functions_ext ring_hom.functions_ext\n\n",
 "fst_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem fst_prod :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f c)).1 =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f c).1 :=\n  (MonoidHom.fst α β).map_prod f s\n#align fst_prod fst_prod\n\n"}