{"rel_associated_iff_map_eq_map":
 "theorem rel_associated_iff_map_eq_map {p q : Multiset α} :\n    Multiset.Rel Associated p q ↔ p.map Associates.mk = q.map Associates.mk :=\n  by\n  rw [← Multiset.rel_eq, Multiset.rel_map]\n  simp only [mk_eq_mk_iff_associated]\n#align rel_associated_iff_map_eq_map rel_associated_iff_map_eq_map\n\n",
 "prod_primes_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print Finset.prod_primes_dvd /-\ntheorem Finset.prod_primes_dvd [CancelCommMonoidWithZero α] [Unique («expr ˣ» α)] {s : Finset α} (n : α)\n    (h : ∀ a ∈ s, Prime a) (div : ∀ a ∈ s, a ∣ n) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s p ∣ n := by\n  classical exact\n      Multiset.prod_primes_dvd n (by simpa only [Multiset.map_id', Finset.mem_def] using h)\n        (by simpa only [Multiset.map_id', Finset.mem_def] using div)\n        (by\n          simp only [Multiset.map_id', associated_eq_eq, Multiset.countp_eq_card_filter, ←\n            Multiset.count_eq_card_filter_eq, ← Multiset.nodup_iff_count_le_one, s.nodup])\n#align finset.prod_primes_dvd Finset.prod_primes_dvd\n-/\n\n",
 "prod_ne_zero_of_prime":
 "theorem prod_ne_zero_of_prime [CancelCommMonoidWithZero α] [Nontrivial α] (s : Multiset α) (h : ∀ x ∈ s, Prime x) :\n    s.prod ≠ 0 :=\n  Multiset.prod_ne_zero fun h0 => Prime.ne_zero (h 0 h0) rfl\n#align prod_ne_zero_of_prime prod_ne_zero_of_prime\n\n",
 "prod_mk":
 "theorem prod_mk {p : Multiset α} : (p.map Associates.mk).prod = Associates.mk p.prod :=\n  Multiset.induction_on p (by simp) fun a s ih => by simp [ih, Associates.mk_mul_mk]\n#align prod_mk prod_mk\n\n",
 "prod_le_prod":
 "theorem prod_le_prod {p q : Multiset (Associates α)} (h : p ≤ q) : p.prod ≤ q.prod :=\n  by\n  haveI := Classical.decEq (Associates α)\n  haveI := Classical.decEq α\n  suffices p.prod ≤ (p + (q - p)).prod by rwa [add_tsub_cancel_of_le h] at this\n  suffices p.prod * 1 ≤ p.prod * (q - p).prod by simpa\n  exact mul_mono (le_refl p.prod) one_le\n#align prod_le_prod prod_le_prod\n\n",
 "prod_eq_one_iff":
 "theorem prod_eq_one_iff {p : Multiset (Associates α)} : p.prod = 1 ↔ ∀ a ∈ p, (a : Associates α) = 1 :=\n  Multiset.induction_on p (by simp) (by simp (config := { contextual := true }) [mul_eq_one_iff, or_imp, forall_and])\n#align prod_eq_one_iff prod_eq_one_iff\n\n",
 "finset_prod_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem finset_prod_mk {p : Finset β} {f : β → α} :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" p\n        (Associates.mk (f i)) =\n      Associates.mk\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" p (f i)) :=\n  by rw [Finset.prod_eq_multiset_prod, ← Multiset.map_map, prod_mk, ← Finset.prod_eq_multiset_prod]\n#align finset_prod_mk finset_prod_mk\n\n",
 "exists_mem_multiset_map_dvd":
 "theorem exists_mem_multiset_map_dvd {s : Multiset β} {f : β → α} : p ∣ (s.map f).prod → ∃ a ∈ s, p ∣ f a := fun h => by\n  simpa only [exists_prop, Multiset.mem_map, exists_exists_and_eq_and] using hp.exists_mem_multiset_dvd h\n#align exists_mem_multiset_map_dvd exists_mem_multiset_map_dvd\n\n",
 "exists_mem_multiset_le_of_prime":
 "theorem exists_mem_multiset_le_of_prime {s : Multiset (Associates α)} {p : Associates α} (hp : Prime p) :\n    p ≤ s.prod → ∃ a ∈ s, p ≤ a :=\n  Multiset.induction_on s (fun ⟨d, Eq⟩ => (hp.ne_one (mul_eq_one_iff.1 Eq.symm).1).elim) fun a s ih h =>\n    have : p ≤ a * s.prod := by simpa using h\n    match Prime.le_or_le hp this with\n    | or.inl h => ⟨a, Multiset.mem_cons_self a s, h⟩\n    | or.inr h =>\n      let ⟨a, has, h⟩ := ih h\n      ⟨a, Multiset.mem_cons_of_mem has, h⟩\n#align exists_mem_multiset_le_of_prime exists_mem_multiset_le_of_prime\n\n",
 "exists_mem_multiset_dvd":
 "/-\nCopyright (c) 2018 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Jens Wagemaker, Anne Baanen\n-/\n-- the same local notation used in `algebra.associated`\ntheorem exists_mem_multiset_dvd {s : Multiset α} : p ∣ s.prod → ∃ a ∈ s, p ∣ a :=\n  Multiset.induction_on s (fun h => (hp.not_dvd_one h).elim) fun a s ih h =>\n    have : p ∣ a * s.prod := by simpa using h\n    match hp.dvd_or_dvd this with\n    | or.inl h => ⟨a, Multiset.mem_cons_self a s, h⟩\n    | or.inr h =>\n      let ⟨a, has, h⟩ := ih h\n      ⟨a, Multiset.mem_cons_of_mem has, h⟩\n#align exists_mem_multiset_dvd exists_mem_multiset_dvd\n\n",
 "exists_mem_finset_dvd":
 "theorem exists_mem_finset_dvd {s : Finset β} {f : β → α} : p ∣ s.prod f → ∃ i ∈ s, p ∣ f i :=\n  hp.exists_mem_multiset_map_dvd\n#align exists_mem_finset_dvd exists_mem_finset_dvd\n\n",
 "exists_associated_mem_of_dvd_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ᵤ » -/\n#print exists_associated_mem_of_dvd_prod /-\ntheorem exists_associated_mem_of_dvd_prod [CancelCommMonoidWithZero α] {p : α} (hp : Prime p) {s : Multiset α} :\n    (∀ r ∈ s, Prime r) → p ∣ s.prod → ∃ q ∈ s, «expr ~ᵤ » p q :=\n  Multiset.induction_on s (by simp [mt isUnit_iff_dvd_one.2 hp.not_unit]) fun a s ih hs hps =>\n    by\n    rw [Multiset.prod_cons] at hps\n    cases' hp.dvd_or_dvd hps with h h\n    · have hap := hs a (Multiset.mem_cons.2 (or.inl rfl))\n      exact ⟨a, Multiset.mem_cons_self a _, hp.associated_of_dvd hap h⟩\n    · rcases ih (fun r hr => hs _ (Multiset.mem_cons.2 (or.inr hr))) h with ⟨q, hq₁, hq₂⟩\n      exact ⟨q, Multiset.mem_cons.2 (or.inr hq₁), hq₂⟩\n#align exists_associated_mem_of_dvd_prod exists_associated_mem_of_dvd_prod\n-/\n\n",
 "dvd_finsupp_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print Prime.dvd_finsupp_prod_iff /-\ntheorem Prime.dvd_finsupp_prod_iff {f : «expr →₀ » α M} {g : α → M → ℕ} {p : ℕ} (pp : Prime p) :\n    p ∣ f.prod g ↔ ∃ a ∈ f.support, p ∣ g a (f a) :=\n  Prime.dvd_finset_prod_iff pp _\n#align prime.dvd_finsupp_prod_iff Prime.dvd_finsupp_prod_iff\n-/\n\n",
 "dvd_finset_prod_iff":
 "#print Prime.dvd_finset_prod_iff /-\ntheorem Prime.dvd_finset_prod_iff {S : Finset α} {p : M} (pp : Prime p) (g : α → M) : p ∣ S.prod g ↔ ∃ a ∈ S, p ∣ g a :=\n  ⟨pp.exists_mem_finset_dvd, fun ⟨a, ha1, ha2⟩ => dvd_trans ha2 (dvd_prod_of_mem g ha1)⟩\n#align prime.dvd_finset_prod_iff Prime.dvd_finset_prod_iff\n-/\n\n"}