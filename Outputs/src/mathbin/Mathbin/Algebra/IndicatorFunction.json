{"prod_mul_indicator_subset_of_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Consider a product of `g i (f i)` over a `finset`.  Suppose `g` is a\nfunction such as `pow`, which maps a second argument of `1` to\n`1`. Then if `f` is replaced by the corresponding multiplicative indicator\nfunction, the `finset` may be replaced by a possibly larger `finset`\nwithout changing the value of the sum. -/\n@[to_additive]\ntheorem prod_mul_indicator_subset_of_eq_one [One N] (f : α → N) (g : α → N → M) {s t : Finset α} (h : s ⊆ t)\n    (hg : ∀ a, g a 1 = 1) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g i (f i)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t\n        (g i (mulIndicator (↑s) f i)) :=\n  by\n  rw [← Finset.prod_subset h _]\n  · apply Finset.prod_congr rfl\n    intro i hi\n    congr\n    symm\n    exact mul_indicator_of_mem hi _\n  · refine' fun i hi hn => _\n    convert hg i\n    exact mul_indicator_of_not_mem hn _\n#align prod_mul_indicator_subset_of_eq_one prod_mul_indicator_subset_of_eq_one\n\n",
 "prod_mul_indicator_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Taking the product of an indicator function over a possibly larger `finset` is the same as\ntaking the original function over the original `finset`. -/\n@[to_additive\n      \"Summing an indicator function over a possibly larger `finset` is the same as summing\\nthe original function over the original `finset`.\"]\ntheorem prod_mul_indicator_subset (f : α → M) {s t : Finset α} (h : s ⊆ t) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t\n        (mulIndicator (↑s) f i) :=\n  prod_mulIndicator_subset_of_eq_one _ (fun a b => b) h fun _ => rfl\n#align prod_mul_indicator_subset prod_mul_indicator_subset\n\n",
 "prod_mul_indicator_eq_prod_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print Finset.prod_mulIndicator_eq_prod_filter /-\n@[to_additive]\ntheorem Finset.prod_mulIndicator_eq_prod_filter (s : Finset ι) (f : ι → α → M) (t : ι → Set α) (g : ι → α)\n    [DecidablePred fun i => g i ∈ t i] :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (mulIndicator (t i) (f i) (g i)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (s.filter fun i => g i ∈ t i) (f i (g i)) :=\n  by\n  refine' (Finset.prod_filter_mul_prod_filter_not s (fun i => g i ∈ t i) _).symm.trans _\n  refine' Eq.trans _ (mul_one _)\n  exact\n    congr_arg₂ (· * ·) (Finset.prod_congr rfl fun x hx => mul_indicator_of_mem (Finset.mem_filter.1 hx).2 _)\n      (Finset.prod_eq_one fun x hx => mul_indicator_of_not_mem (Finset.mem_filter.1 hx).2 _)\n#align finset.prod_mul_indicator_eq_prod_filter Finset.prod_mulIndicator_eq_prod_filter\n#align finset.sum_indicator_eq_sum_filter Finset.sum_indicator_eq_sum_filter\n-/\n\n",
 "piecewise_eq_mul_indicator":
 "/-\nCopyright (c) 2020 Zhouhang Zhou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Zhouhang Zhou\n-/\n@[simp, to_additive]\ntheorem piecewise_eq_mul_indicator [DecidablePred (· ∈ s)] : s.piecewise f 1 = s.mul_indicator f :=\n  funext fun x => @if_congr _ _ _ _ (id _) _ _ _ _ iff.rfl rfl rfl\n#align piecewise_eq_mul_indicator piecewise_eq_mul_indicator\n\n",
 "one_le_mul_indicator_apply":
 "@[to_additive indicator_apply_nonneg]\ntheorem one_le_mul_indicator_apply (h : a ∈ s → 1 ≤ f a) : 1 ≤ mulIndicator s f a :=\n  le_mulIndicator_apply h fun _ => le_rfl\n#align one_le_mul_indicator_apply one_le_mul_indicator_apply\n\n",
 "one_le_mul_indicator":
 "@[to_additive indicator_nonneg]\ntheorem one_le_mul_indicator (h : ∀ a ∈ s, 1 ≤ f a) (a : α) : 1 ≤ mulIndicator s f a :=\n  one_le_mulIndicator_apply (h a)\n#align one_le_mul_indicator one_le_mul_indicator\n\n",
 "mul_support_mul_indicator_subset":
 "@[to_additive]\ntheorem mul_support_mul_indicator_subset : mulSupport (s.mul_indicator f) ⊆ s := fun x hx =>\n  hx.imp_symm fun h => mulIndicator_of_not_mem h f\n#align mul_support_mul_indicator_subset mul_support_mul_indicator_subset\n\n",
 "mul_support_mul_indicator":
 "@[simp, to_additive]\ntheorem mul_support_mul_indicator : Function.mulSupport (s.mul_indicator f) = s ∩ Function.mulSupport f :=\n  ext fun x => by simp [Function.mem_mulSupport, mul_indicator_apply_eq_one]\n#align mul_support_mul_indicator mul_support_mul_indicator\n\n",
 "mul_indicator_univ":
 "@[simp, to_additive]\ntheorem mul_indicator_univ (f : α → M) : mulIndicator (univ : Set α) f = f :=\n  mulIndicator_eq_self.2 <| subset_univ _\n#align mul_indicator_univ mul_indicator_univ\n\n",
 "mul_indicator_union_of_not_mem_inter":
 "@[to_additive]\ntheorem mul_indicator_union_of_not_mem_inter (h : a ∉ s ∩ t) (f : α → M) :\n    mulIndicator (s ∪ t) f a = mulIndicator s f a * mulIndicator t f a := by\n  rw [← mul_indicator_union_mul_inter_apply f s t, mul_indicator_of_not_mem h, mul_one]\n#align mul_indicator_union_of_not_mem_inter mul_indicator_union_of_not_mem_inter\n\n",
 "mul_indicator_union_of_disjoint":
 "@[to_additive]\ntheorem mul_indicator_union_of_disjoint (h : Disjoint s t) (f : α → M) :\n    mulIndicator (s ∪ t) f = fun a => mulIndicator s f a * mulIndicator t f a :=\n  funext fun a => mulIndicator_union_of_not_mem_inter (fun ha => h.le_bot ha) _\n#align mul_indicator_union_of_disjoint mul_indicator_union_of_disjoint\n\n",
 "mul_indicator_union_mul_inter_apply":
 "@[to_additive]\ntheorem mul_indicator_union_mul_inter_apply (f : α → M) (s t : Set α) (a : α) :\n    mulIndicator (s ∪ t) f a * mulIndicator (s ∩ t) f a = mulIndicator s f a * mulIndicator t f a := by\n  by_cases hs : a ∈ s <;> by_cases ht : a ∈ t <;> simp [*]\n#align mul_indicator_union_mul_inter_apply mul_indicator_union_mul_inter_apply\n\n",
 "mul_indicator_union_mul_inter":
 "@[to_additive]\ntheorem mul_indicator_union_mul_inter (f : α → M) (s t : Set α) :\n    mulIndicator (s ∪ t) f * mulIndicator (s ∩ t) f = mulIndicator s f * mulIndicator t f :=\n  funext <| mulIndicator_union_mul_inter_apply f s t\n#align mul_indicator_union_mul_inter mul_indicator_union_mul_inter\n\n",
 "mul_indicator_self_mul_compl_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp, to_additive]\ntheorem mul_indicator_self_mul_compl_apply (s : Set α) (f : α → M) (a : α) :\n    mulIndicator s f a * mulIndicator («expr ᶜ» s) f a = f a :=\n  by_cases (fun ha : a ∈ s => by simp [ha]) fun ha => by simp [ha]\n#align mul_indicator_self_mul_compl_apply mul_indicator_self_mul_compl_apply\n\n",
 "mul_indicator_self_mul_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp, to_additive]\ntheorem mul_indicator_self_mul_compl (s : Set α) (f : α → M) : mulIndicator s f * mulIndicator («expr ᶜ» s) f = f :=\n  funext <| mulIndicator_self_mul_compl_apply s f\n#align mul_indicator_self_mul_compl mul_indicator_self_mul_compl\n\n",
 "mul_indicator_rel_mul_indicator":
 "@[to_additive]\ntheorem mul_indicator_rel_mul_indicator {r : M → M → Prop} (h1 : r 1 1) (ha : a ∈ s → r (f a) (g a)) :\n    r (mulIndicator s f a) (mulIndicator s g a) :=\n  by\n  simp only [mul_indicator]\n  split_ifs with has has\n  exacts[ha has, h1]\n#align mul_indicator_rel_mul_indicator mul_indicator_rel_mul_indicator\n\n",
 "mul_indicator_range_comp":
 "@[simp, to_additive]\ntheorem mul_indicator_range_comp {ι : Sort _} (f : ι → α) (g : α → M) : mulIndicator (range f) g ∘ f = g ∘ f :=\n  letI := Classical.decPred (· ∈ range f)\n  piecewise_range_comp _ _ _\n#align mul_indicator_range_comp mul_indicator_range_comp\n\n",
 "mul_indicator_preimage_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem mul_indicator_preimage_of_not_mem (s : Set α) (f : α → M) {t : Set M} (ht : (1 : M) ∉ t) :\n    «expr ⁻¹' » (mulIndicator s f) t = «expr ⁻¹' » f t ∩ s := by\n  simp [mul_indicator_preimage, Pi.one_def, Set.preimage_const_of_not_mem ht]\n#align mul_indicator_preimage_of_not_mem mul_indicator_preimage_of_not_mem\n\n",
 "mul_indicator_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem mul_indicator_preimage (s : Set α) (f : α → M) (B : Set M) :\n    «expr ⁻¹' » (mulIndicator s f) B = s.ite («expr ⁻¹' » f B) («expr ⁻¹' » 1 B) :=\n  letI := Classical.decPred (· ∈ s)\n  piecewise_preimage s f 1 B\n#align mul_indicator_preimage mul_indicator_preimage\n\n",
 "mul_indicator_one_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem mul_indicator_one_preimage (s : Set M) : «expr ⁻¹' » (t.mul_indicator 1) s ∈ ({Set.univ, ∅} : Set (Set α)) := by\n  classical\n    rw [mul_indicator_one', preimage_one]\n    split_ifs <;> simp\n#align mul_indicator_one_preimage mul_indicator_one_preimage\n\n",
 "mul_indicator_one'":
 "@[simp, to_additive]\ntheorem mul_indicator_one' {s : Set α} : s.mul_indicator (1 : α → M) = 1 :=\n  mulIndicator_one M s\n#align mul_indicator_one' mul_indicator_one'\n\n",
 "mul_indicator_one":
 "@[simp, to_additive]\ntheorem mul_indicator_one (s : Set α) : (mulIndicator s fun x => (1 : M)) = fun x => (1 : M) :=\n  mulIndicator_eq_one.2 <| by simp only [mul_support_one, empty_disjoint]\n#align mul_indicator_one mul_indicator_one\n\n",
 "mul_indicator_of_not_mem":
 "@[simp, to_additive]\ntheorem mul_indicator_of_not_mem (h : a ∉ s) (f : α → M) : mulIndicator s f a = 1 :=\n  letI := Classical.dec (a ∈ s)\n  if_neg h\n#align mul_indicator_of_not_mem mul_indicator_of_not_mem\n\n",
 "mul_indicator_of_mem":
 "@[simp, to_additive]\ntheorem mul_indicator_of_mem (h : a ∈ s) (f : α → M) : mulIndicator s f a = f a :=\n  letI := Classical.dec (a ∈ s)\n  if_pos h\n#align mul_indicator_of_mem mul_indicator_of_mem\n\n",
 "mul_indicator_mul_support":
 "@[simp, to_additive]\ntheorem mul_indicator_mul_support : mulIndicator (mulSupport f) f = f :=\n  mulIndicator_eq_self.2 Subset.rfl\n#align mul_indicator_mul_support mul_indicator_mul_support\n\n",
 "mul_indicator_mul_indicator":
 "@[to_additive]\ntheorem mul_indicator_mul_indicator (s t : Set α) (f : α → M) :\n    mulIndicator s (mulIndicator t f) = mulIndicator (s ∩ t) f :=\n  funext fun x => by\n    simp only [mul_indicator]\n    split_ifs\n    repeat' simp_all (config := { contextual := true })\n#align mul_indicator_mul_indicator mul_indicator_mul_indicator\n\n",
 "mul_indicator_mul_eq_right":
 "@[to_additive]\ntheorem mul_indicator_mul_eq_right {f g : α → M} (h : Disjoint (mulSupport f) (mulSupport g)) :\n    (mulSupport g).mul_indicator (f * g) = g :=\n  by\n  refine' (mul_indicator_congr fun x hx => _).trans mul_indicator_mul_support\n  have : f x = 1 := nmem_mul_support.1 (disjoint_right.1 h hx)\n  rw [Pi.mul_apply, this, one_mul]\n#align mul_indicator_mul_eq_right mul_indicator_mul_eq_right\n\n",
 "mul_indicator_mul_eq_left":
 "@[to_additive]\ntheorem mul_indicator_mul_eq_left {f g : α → M} (h : Disjoint (mulSupport f) (mulSupport g)) :\n    (mulSupport f).mul_indicator (f * g) = f :=\n  by\n  refine' (mul_indicator_congr fun x hx => _).trans mul_indicator_mul_support\n  have : g x = 1 := nmem_mul_support.1 (disjoint_left.1 h hx)\n  rw [Pi.mul_apply, this, mul_one]\n#align mul_indicator_mul_eq_left mul_indicator_mul_eq_left\n\n",
 "mul_indicator_mul_compl_eq_piecewise":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[to_additive]\ntheorem mul_indicator_mul_compl_eq_piecewise [DecidablePred (· ∈ s)] (f g : α → M) :\n    s.mul_indicator f * («expr ᶜ» s).mul_indicator g = s.piecewise f g :=\n  by\n  ext x\n  by_cases h : x ∈ s\n  ·\n    rw [piecewise_eq_of_mem _ _ _ h, Pi.mul_apply, Set.mulIndicator_of_mem h,\n      Set.mulIndicator_of_not_mem (Set.not_mem_compl_iff.2 h), mul_one]\n  ·\n    rw [piecewise_eq_of_not_mem _ _ _ h, Pi.mul_apply, Set.mulIndicator_of_not_mem h,\n      Set.mulIndicator_of_mem (Set.mem_compl h), one_mul]\n#align mul_indicator_mul_compl_eq_piecewise mul_indicator_mul_compl_eq_piecewise\n\n",
 "mul_indicator_mul'":
 "@[to_additive]\ntheorem mul_indicator_mul' (s : Set α) (f g : α → M) : mulIndicator s (f * g) = mulIndicator s f * mulIndicator s g :=\n  mulIndicator_mul s f g\n#align mul_indicator_mul' mul_indicator_mul'\n\n",
 "mul_indicator_mul":
 "@[to_additive]\ntheorem mul_indicator_mul (s : Set α) (f g : α → M) :\n    (mulIndicator s fun a => f a * g a) = fun a => mulIndicator s f a * mulIndicator s g a :=\n  by\n  funext\n  simp only [mul_indicator]\n  split_ifs\n  · rfl\n  rw [mul_one]\n#align mul_indicator_mul mul_indicator_mul\n\n",
 "mul_indicator_le_self'":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » s) -/\n@[to_additive]\ntheorem mul_indicator_le_self' (hf : ∀ (x) (_ : x ∉ s), 1 ≤ f x) : mulIndicator s f ≤ f :=\n  mulIndicator_le' (fun _ _ => le_rfl) hf\n#align mul_indicator_le_self' mul_indicator_le_self'\n\n",
 "mul_indicator_le_self":
 "@[to_additive]\ntheorem mul_indicator_le_self (s : Set α) (f : α → M) : mulIndicator s f ≤ f :=\n  mulIndicator_le_self' fun _ _ => one_le _\n#align mul_indicator_le_self mul_indicator_le_self\n\n",
 "mul_indicator_le_one":
 "@[to_additive]\ntheorem mul_indicator_le_one (h : ∀ a ∈ s, f a ≤ 1) (a : α) : mulIndicator s f a ≤ 1 :=\n  mulIndicator_apply_le_one (h a)\n#align mul_indicator_le_one mul_indicator_le_one\n\n",
 "mul_indicator_le_mul_indicator_of_subset":
 "@[to_additive]\ntheorem mul_indicator_le_mul_indicator_of_subset (h : s ⊆ t) (hf : ∀ a, 1 ≤ f a) (a : α) :\n    mulIndicator s f a ≤ mulIndicator t f a :=\n  mulIndicator_apply_le' (fun ha => le_mulIndicator_apply (fun _ => le_rfl) fun hat => (hat <| h ha).elim) fun ha =>\n    one_le_mulIndicator_apply fun _ => hf _\n#align mul_indicator_le_mul_indicator_of_subset mul_indicator_le_mul_indicator_of_subset\n\n",
 "mul_indicator_le_mul_indicator":
 "@[to_additive]\ntheorem mul_indicator_le_mul_indicator (h : f a ≤ g a) : mulIndicator s f a ≤ mulIndicator s g a :=\n  mulIndicator_rel_mulIndicator le_rfl fun _ => h\n#align mul_indicator_le_mul_indicator mul_indicator_le_mul_indicator\n\n",
 "mul_indicator_le'":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (a «expr ∉ » s) -/\n@[to_additive]\ntheorem mul_indicator_le' (hfg : ∀ a ∈ s, f a ≤ g a) (hg : ∀ (a) (_ : a ∉ s), 1 ≤ g a) : mulIndicator s f ≤ g :=\n  fun a => mulIndicator_apply_le' (hfg _) (hg _)\n#align mul_indicator_le' mul_indicator_le'\n\n",
 "mul_indicator_le":
 "@[to_additive]\ntheorem mul_indicator_le {s : Set α} {f g : α → M} (hfg : ∀ a ∈ s, f a ≤ g a) : mulIndicator s f ≤ g :=\n  mulIndicator_le' hfg fun _ _ => one_le _\n#align mul_indicator_le mul_indicator_le\n\n",
 "mul_indicator_inv'":
 "@[to_additive]\ntheorem mul_indicator_inv' (s : Set α) (f : α → G) : mulIndicator s f⁻¹ = (mulIndicator s f)⁻¹ :=\n  (mulIndicatorHom G s).map_inv f\n#align mul_indicator_inv' mul_indicator_inv'\n\n",
 "mul_indicator_inv":
 "@[to_additive]\ntheorem mul_indicator_inv (s : Set α) (f : α → G) :\n    (mulIndicator s fun a => (f a)⁻¹) = fun a => (mulIndicator s f a)⁻¹ :=\n  mulIndicator_inv' s f\n#align mul_indicator_inv mul_indicator_inv\n\n",
 "mul_indicator_inter_mul_support":
 "@[simp, to_additive]\ntheorem mul_indicator_inter_mul_support (s : Set α) (f : α → M) :\n    mulIndicator (s ∩ mulSupport f) f = mulIndicator s f := by\n  rw [← mul_indicator_mul_indicator, mul_indicator_mul_support]\n#align mul_indicator_inter_mul_support mul_indicator_inter_mul_support\n\n",
 "mul_indicator_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem mul_indicator_image {s : Set α} {f : β → M} {g : α → β} (hg : injective g) {x : α} :\n    mulIndicator («expr '' » g s) f (g x) = mulIndicator s (f ∘ g) x := by\n  rw [← mul_indicator_comp_right, preimage_image_eq _ hg]\n#align mul_indicator_image mul_indicator_image\n\n",
 "mul_indicator_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem mul_indicator_finset_prod (I : Finset ι) (s : Set α) (f : ι → α → M) :\n    mulIndicator s\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" I (f i)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" I\n        (mulIndicator s (f i)) :=\n  (mulIndicatorHom M s).map_prod _ _\n#align mul_indicator_finset_prod mul_indicator_finset_prod\n\n",
 "mul_indicator_finset_bUnion_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem mul_indicator_finset_bUnion_apply {ι} (I : Finset ι) (s : ι → Set α) {f : α → M}\n    (h : ∀ i ∈ I, ∀ j ∈ I, i ≠ j → Disjoint (s i) (s j)) (x : α) :\n    mulIndicator («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))\n        f x =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" I\n        (mulIndicator (s i) f x) :=\n  by rw [Set.mulIndicator_finset_bunionᵢ I s h]\n#align mul_indicator_finset_bUnion_apply mul_indicator_finset_bUnion_apply\n\n",
 "mul_indicator_finset_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem mul_indicator_finset_bUnion {ι} (I : Finset ι) (s : ι → Set α) {f : α → M} :\n    (∀ i ∈ I, ∀ j ∈ I, i ≠ j → Disjoint (s i) (s j)) →\n      mulIndicator\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) f =\n        fun a =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" I\n          (mulIndicator (s i) f a) :=\n  by\n  classical\n    refine' Finset.induction_on I _ _\n    · intro h\n      funext\n      simp\n    intro a I haI ih hI\n    funext\n    rw [Finset.prod_insert haI, Finset.set_bunionᵢ_insert, mul_indicator_union_of_not_mem_inter, ih _]\n    · intro i hi j hj hij\n      exact hI i (Finset.mem_insert_of_mem hi) j (Finset.mem_insert_of_mem hj) hij\n    simp only [not_exists, exists_prop, mem_Union, mem_inter_iff, not_and]\n    intro hx a' ha'\n    refine' disjoint_left.1 (hI a (Finset.mem_insert_self _ _) a' (Finset.mem_insert_of_mem ha') _) hx\n    exact (ne_of_mem_of_not_mem ha' haI).symm\n#align mul_indicator_finset_bUnion mul_indicator_finset_bUnion\n\n",
 "mul_indicator_eq_self_of_superset":
 "@[to_additive]\ntheorem mul_indicator_eq_self_of_superset (h1 : s.mul_indicator f = f) (h2 : s ⊆ t) : t.mul_indicator f = f :=\n  by\n  rw [mul_indicator_eq_self] at h1⊢\n  exact subset.trans h1 h2\n#align mul_indicator_eq_self_of_superset mul_indicator_eq_self_of_superset\n\n",
 "mul_indicator_eq_self":
 "@[simp, to_additive]\ntheorem mul_indicator_eq_self : s.mul_indicator f = f ↔ mulSupport f ⊆ s := by\n  simp only [funext_iff, subset_def, mem_mul_support, mul_indicator_apply_eq_self, not_imp_comm]\n#align mul_indicator_eq_self mul_indicator_eq_self\n\n",
 "mul_indicator_eq_one_or_self":
 "@[to_additive]\ntheorem mul_indicator_eq_one_or_self (s : Set α) (f : α → M) (a : α) :\n    mulIndicator s f a = 1 ∨ mulIndicator s f a = f a :=\n  by\n  by_cases h : a ∈ s\n  · exact or.inr (mul_indicator_of_mem h f)\n  · exact or.inl (mul_indicator_of_not_mem h f)\n#align mul_indicator_eq_one_or_self mul_indicator_eq_one_or_self\n\n",
 "mul_indicator_eq_one'":
 "@[simp, to_additive]\ntheorem mul_indicator_eq_one' : mulIndicator s f = 1 ↔ Disjoint (mulSupport f) s :=\n  mulIndicator_eq_one\n#align mul_indicator_eq_one' mul_indicator_eq_one'\n\n",
 "mul_indicator_eq_one":
 "@[simp, to_additive]\ntheorem mul_indicator_eq_one : (mulIndicator s f = fun x => 1) ↔ Disjoint (mulSupport f) s := by\n  simp only [funext_iff, mul_indicator_apply_eq_one, Set.disjoint_left, mem_mul_support, not_imp_not]\n#align mul_indicator_eq_one mul_indicator_eq_one\n\n",
 "mul_indicator_empty'":
 "@[to_additive]\ntheorem mul_indicator_empty' (f : α → M) : mulIndicator (∅ : Set α) f = 1 :=\n  mulIndicator_empty f\n#align mul_indicator_empty' mul_indicator_empty'\n\n",
 "mul_indicator_empty":
 "@[simp, to_additive]\ntheorem mul_indicator_empty (f : α → M) : mulIndicator (∅ : Set α) f = fun a => 1 :=\n  mulIndicator_eq_one.2 <| disjoint_empty _\n#align mul_indicator_empty mul_indicator_empty\n\n",
 "mul_indicator_div'":
 "@[to_additive]\ntheorem mul_indicator_div' (s : Set α) (f g : α → G) : mulIndicator s (f / g) = mulIndicator s f / mulIndicator s g :=\n  mulIndicator_div s f g\n#align mul_indicator_div' mul_indicator_div'\n\n",
 "mul_indicator_div":
 "@[to_additive]\ntheorem mul_indicator_div (s : Set α) (f g : α → G) :\n    (mulIndicator s fun a => f a / g a) = fun a => mulIndicator s f a / mulIndicator s g a :=\n  (mulIndicatorHom G s).map_div f g\n#align mul_indicator_div mul_indicator_div\n\n",
 "mul_indicator_diff":
 "@[to_additive indicator_diff']\ntheorem mul_indicator_diff (h : s ⊆ t) (f : α → G) : mulIndicator (t \\ s) f = mulIndicator t f * (mulIndicator s f)⁻¹ :=\n  eq_mul_inv_of_mul_eq <|\n    by\n    rw [Pi.mul_def, ← mul_indicator_union_of_disjoint, diff_union_self, union_eq_self_of_subset_right h]\n    exact disjoint_sdiff_self_left\n#align mul_indicator_diff mul_indicator_diff\n\n",
 "mul_indicator_const_preimage_eq_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[to_additive]\ntheorem mul_indicator_const_preimage_eq_union (U : Set α) (s : Set M) (a : M) [Decidable (a ∈ s)]\n    [Decidable ((1 : M) ∈ s)] :\n    «expr ⁻¹' » (U.mul_indicator fun x => a) s = (if a ∈ s then U else ∅) ∪ if (1 : M) ∈ s then «expr ᶜ» U else ∅ :=\n  by\n  rw [mul_indicator_preimage, preimage_one, preimage_const]\n  split_ifs <;> simp [← compl_eq_univ_diff]\n#align mul_indicator_const_preimage_eq_union mul_indicator_const_preimage_eq_union\n\n",
 "mul_indicator_const_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[to_additive]\ntheorem mul_indicator_const_preimage (U : Set α) (s : Set M) (a : M) :\n    «expr ⁻¹' » (U.mul_indicator fun x => a) s ∈ ({Set.univ, U, «expr ᶜ» U, ∅} : Set (Set α)) := by\n  classical\n    rw [mul_indicator_const_preimage_eq_union]\n    split_ifs <;> simp\n#align mul_indicator_const_preimage mul_indicator_const_preimage\n\n",
 "mul_indicator_congr":
 "@[to_additive]\ntheorem mul_indicator_congr (h : EqOn f g s) : mulIndicator s f = mulIndicator s g :=\n  funext fun x => by\n    simp only [mul_indicator]\n    split_ifs\n    · exact h h_1\n    rfl\n#align mul_indicator_congr mul_indicator_congr\n\n",
 "mul_indicator_compl_mul_self_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp, to_additive]\ntheorem mul_indicator_compl_mul_self_apply (s : Set α) (f : α → M) (a : α) :\n    mulIndicator («expr ᶜ» s) f a * mulIndicator s f a = f a :=\n  by_cases (fun ha : a ∈ s => by simp [ha]) fun ha => by simp [ha]\n#align mul_indicator_compl_mul_self_apply mul_indicator_compl_mul_self_apply\n\n",
 "mul_indicator_compl_mul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp, to_additive]\ntheorem mul_indicator_compl_mul_self (s : Set α) (f : α → M) : mulIndicator («expr ᶜ» s) f * mulIndicator s f = f :=\n  funext <| mulIndicator_compl_mul_self_apply s f\n#align mul_indicator_compl_mul_self mul_indicator_compl_mul_self\n\n",
 "mul_indicator_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[to_additive indicator_compl']\ntheorem mul_indicator_compl (s : Set α) (f : α → G) : mulIndicator («expr ᶜ» s) f = f * (mulIndicator s f)⁻¹ :=\n  eq_mul_inv_of_mul_eq <| s.mul_indicator_compl_mul_self f\n#align mul_indicator_compl mul_indicator_compl\n\n",
 "mul_indicator_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem mul_indicator_comp_right {s : Set α} (f : β → α) {g : α → M} {x : β} :\n    mulIndicator («expr ⁻¹' » f s) (g ∘ f) x = mulIndicator s g (f x) :=\n  by\n  simp only [mul_indicator]\n  split_ifs <;> rfl\n#align mul_indicator_comp_right mul_indicator_comp_right\n\n",
 "mul_indicator_comp_of_one":
 "@[to_additive]\ntheorem mul_indicator_comp_of_one {g : M → N} (hg : g 1 = 1) : mulIndicator s (g ∘ f) = g ∘ mulIndicator s f :=\n  by\n  funext\n  simp only [mul_indicator]\n  split_ifs <;> simp [*]\n#align mul_indicator_comp_of_one mul_indicator_comp_of_one\n\n",
 "mul_indicator_apply_ne_one":
 "@[to_additive]\ntheorem mul_indicator_apply_ne_one {a : α} : s.mul_indicator f a ≠ 1 ↔ a ∈ s ∩ mulSupport f := by\n  simp only [ne.def, mul_indicator_apply_eq_one, not_imp, mem_inter_iff, mem_mul_support]\n#align mul_indicator_apply_ne_one mul_indicator_apply_ne_one\n\n",
 "mul_indicator_apply_le_one":
 "@[to_additive]\ntheorem mul_indicator_apply_le_one (h : a ∈ s → f a ≤ 1) : mulIndicator s f a ≤ 1 :=\n  mulIndicator_apply_le' h fun _ => le_rfl\n#align mul_indicator_apply_le_one mul_indicator_apply_le_one\n\n",
 "mul_indicator_apply_le'":
 "@[to_additive]\ntheorem mul_indicator_apply_le' (hfg : a ∈ s → f a ≤ y) (hg : a ∉ s → 1 ≤ y) : mulIndicator s f a ≤ y :=\n  by\n  by_cases ha : a ∈ s\n  · simpa [ha] using hfg ha\n  · simpa [ha] using hg ha\n#align mul_indicator_apply_le' mul_indicator_apply_le'\n\n",
 "mul_indicator_apply_le":
 "@[to_additive]\ntheorem mul_indicator_apply_le {a : α} {s : Set α} {f g : α → M} (hfg : a ∈ s → f a ≤ g a) : mulIndicator s f a ≤ g a :=\n  mulIndicator_apply_le' hfg fun _ => one_le _\n#align mul_indicator_apply_le mul_indicator_apply_le\n\n",
 "mul_indicator_apply_eq_self":
 "@[simp, to_additive]\ntheorem mul_indicator_apply_eq_self : s.mul_indicator f a = f a ↔ a ∉ s → f a = 1 :=\n  letI := Classical.dec (a ∈ s)\n  ite_eq_left_iff.trans (by rw [@eq_comm _ (f a)])\n#align mul_indicator_apply_eq_self mul_indicator_apply_eq_self\n\n",
 "mul_indicator_apply_eq_one":
 "@[simp, to_additive]\ntheorem mul_indicator_apply_eq_one : mulIndicator s f a = 1 ↔ a ∈ s → f a = 1 :=\n  letI := Classical.dec (a ∈ s)\n  ite_eq_right_iff\n#align mul_indicator_apply_eq_one mul_indicator_apply_eq_one\n\n",
 "mul_indicator_apply":
 "@[to_additive]\ntheorem mul_indicator_apply (s : Set α) (f : α → M) (a : α) [Decidable (a ∈ s)] :\n    mulIndicator s f a = if a ∈ s then f a else 1 := by convert rfl\n#align mul_indicator_apply mul_indicator_apply\n\n",
 "mul_indicator_Union_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem mul_indicator_Union_apply {ι M} [CompleteLattice M] [One M] (h1 : («expr⊥» : M) = 1) (s : ι → Set α) (f : α → M)\n    (x : α) :\n    mulIndicator («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))\n        f x =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (mulIndicator (s i) f x) :=\n  by\n  by_cases hx :\n    x ∈ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)\n  · rw [mul_indicator_of_mem hx]\n    rw [mem_Union] at hx\n    refine' le_antisymm _ (supᵢ_le fun i => mul_indicator_le_self' (fun x hx => h1 ▸ bot_le) x)\n    rcases hx with ⟨i, hi⟩\n    exact le_supᵢ_of_le i (ge_of_eq <| mul_indicator_of_mem hi _)\n  · rw [mul_indicator_of_not_mem hx]\n    simp only [mem_Union, not_exists] at hx\n    simp [hx, ← h1]\n#align mul_indicator_Union_apply mul_indicator_Union_apply\n\n",
 "mem_range_mul_indicator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem mem_range_mul_indicator {r : M} {s : Set α} {f : α → M} :\n    r ∈ range (mulIndicator s f) ↔ r = 1 ∧ s ≠ univ ∨ r ∈ «expr '' » f s := by\n  simp [mul_indicator, ite_eq_iff, exists_or, eq_univ_iff_forall, and_comm', or_comm', @eq_comm _ r 1]\n#align mem_range_mul_indicator mem_range_mul_indicator\n\n",
 "mem_of_mul_indicator_ne_one":
 "/-- If a multiplicative indicator function is not equal to `1` at a point, then that point is in the\nset. -/\n@[to_additive \"If an additive indicator function is not equal to `0` at a point, then that point is\\nin the set.\"]\ntheorem mem_of_mul_indicator_ne_one (h : mulIndicator s f a ≠ 1) : a ∈ s :=\n  not_imp_comm.1 (fun hn => mulIndicator_of_not_mem hn f) h\n#align mem_of_mul_indicator_ne_one mem_of_mul_indicator_ne_one\n\n",
 "map_mulIndicator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidHom.map_mulIndicator /-\n@[to_additive]\ntheorem MonoidHom.map_mulIndicator {M N : Type _} [MulOneClass M] [MulOneClass N] (f : «expr →* » M N) (s : Set α)\n    (g : α → M) (x : α) : f (s.mul_indicator g x) = s.mul_indicator (f ∘ g) x :=\n  congr_fun (Set.mulIndicator_comp_of_one f.map_one).symm x\n#align monoid_hom.map_mul_indicator MonoidHom.map_mulIndicator\n#align add_monoid_hom.map_indicator AddMonoidHom.map_indicator\n-/\n\n",
 "le_mul_indicator_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[to_additive]\ntheorem le_mul_indicator_apply {y} (hfg : a ∈ s → y ≤ g a) (hf : a ∉ s → y ≤ 1) : y ≤ mulIndicator s g a :=\n  @mulIndicator_apply_le' α («expr ᵒᵈ» M) ‹_› _ _ _ _ _ hfg hf\n#align le_mul_indicator_apply le_mul_indicator_apply\n\n",
 "le_mul_indicator":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (a «expr ∉ » s) -/\n@[to_additive]\ntheorem le_mul_indicator (hfg : ∀ a ∈ s, f a ≤ g a) (hf : ∀ (a) (_ : a ∉ s), f a ≤ 1) : f ≤ mulIndicator s g := fun a =>\n  le_mulIndicator_apply (hfg _) (hf _)\n#align le_mul_indicator le_mul_indicator\n\n",
 "inter_indicator_one":
 "theorem inter_indicator_one {s t : Set α} : (s ∩ t).indicator (1 : _ → M) = s.indicator 1 * t.indicator 1 :=\n  funext fun _ => by simpa only [← inter_indicator_mul, Pi.mul_apply, Pi.one_apply, one_mul]\n#align inter_indicator_one inter_indicator_one\n\n",
 "inter_indicator_mul":
 "theorem inter_indicator_mul {t1 t2 : Set α} (f g : α → M) (x : α) :\n    (t1 ∩ t2).indicator (fun x => f x * g x) x = t1.indicator f x * t2.indicator g x :=\n  by\n  rw [← Set.indicator_indicator]\n  simp [indicator]\n#align inter_indicator_mul inter_indicator_mul\n\n",
 "indicator_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem indicator_smul_apply (s : Set α) (r : α → M) (f : α → A) (x : α) :\n    indicator s (fun x => «expr • » (r x) (f x)) x = «expr • » (r x) (indicator s f x) :=\n  by\n  dsimp only [indicator]\n  split_ifs\n  exacts[rfl, (smul_zero (r x)).symm]\n#align indicator_smul_apply indicator_smul_apply\n\n",
 "indicator_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem indicator_smul (s : Set α) (r : α → M) (f : α → A) :\n    (indicator s fun x : α => «expr • » (r x) (f x)) = fun x : α => «expr • » (r x) (indicator s f x) :=\n  funext <| indicator_smul_apply s r f\n#align indicator_smul indicator_smul\n\n",
 "indicator_prod_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem indicator_prod_one {s : Set α} {t : Set β} {x : α} {y : β} :\n    (finset.product s t).indicator (1 : _ → M) (x, y) = s.indicator 1 x * t.indicator 1 y := by\n  classical simp [indicator_apply, ← ite_and]\n#align indicator_prod_one indicator_prod_one\n\n",
 "indicator_one_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem indicator_one_preimage [Zero M] (U : Set α) (s : Set M) :\n    «expr ⁻¹' » (U.indicator 1) s ∈ ({Set.univ, U, «expr ᶜ» U, ∅} : Set (Set α)) :=\n  indicator_const_preimage _ _ 1\n#align indicator_one_preimage indicator_one_preimage\n\n",
 "indicator_one_inj":
 "theorem indicator_one_inj {U V : Set α} (h : indicator U (1 : α → M) = indicator V 1) : U = V :=\n  by\n  ext\n  simp_rw [← indicator_eq_one_iff_mem M, h]\n#align indicator_one_inj indicator_one_inj\n\n",
 "indicator_nonpos_le_indicator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem indicator_nonpos_le_indicator {β} [linear_order β] [Zero β] (s : Set α) (f : α → β) :\n    { x | f x ≤ 0 }.indicator f ≤ s.indicator f :=\n  @indicator_le_indicator_nonneg α («expr ᵒᵈ» β) _ _ s f\n#align indicator_nonpos_le_indicator indicator_nonpos_le_indicator\n\n",
 "indicator_mul_right":
 "theorem indicator_mul_right (s : Set α) (f g : α → M) : indicator s (fun a => f a * g a) a = f a * indicator s g a :=\n  by\n  simp only [indicator]\n  split_ifs\n  · rfl\n  rw [MulZeroClass.mul_zero]\n#align indicator_mul_right indicator_mul_right\n\n",
 "indicator_mul_left":
 "theorem indicator_mul_left (s : Set α) (f g : α → M) : indicator s (fun a => f a * g a) a = indicator s f a * g a :=\n  by\n  simp only [indicator]\n  split_ifs\n  · rfl\n  rw [MulZeroClass.zero_mul]\n#align indicator_mul_left indicator_mul_left\n\n",
 "indicator_mul":
 "theorem indicator_mul (s : Set α) (f g : α → M) :\n    (indicator s fun a => f a * g a) = fun a => indicator s f a * indicator s g a :=\n  by\n  funext\n  simp only [indicator]\n  split_ifs\n  · rfl\n  rw [MulZeroClass.mul_zero]\n#align indicator_mul indicator_mul\n\n",
 "indicator_le_indicator_nonneg":
 "theorem indicator_le_indicator_nonneg {β} [linear_order β] [Zero β] (s : Set α) (f : α → β) :\n    s.indicator f ≤ { x | 0 ≤ f x }.indicator f := by\n  intro x\n  classical\n    simp_rw [indicator_apply]\n    split_ifs\n    · exact le_rfl\n    · exact (not_le.mp h_1).le\n    · exact h_1\n    · exact le_rfl\n#align indicator_le_indicator_nonneg indicator_le_indicator_nonneg\n\n",
 "indicator_eq_zero_iff_not_mem":
 "theorem indicator_eq_zero_iff_not_mem {U : Set α} {x : α} : indicator U 1 x = (0 : M) ↔ x ∉ U := by\n  classical simp [indicator_apply, imp_false]\n#align indicator_eq_zero_iff_not_mem indicator_eq_zero_iff_not_mem\n\n",
 "indicator_eq_one_iff_mem":
 "theorem indicator_eq_one_iff_mem {U : Set α} {x : α} : indicator U 1 x = (1 : M) ↔ x ∈ U := by\n  classical simp [indicator_apply, imp_false]\n#align indicator_eq_one_iff_mem indicator_eq_one_iff_mem\n\n",
 "indicator_diff":
 "theorem indicator_diff {G : Type _} [AddGroup G] {s t : Set α} (h : s ⊆ t) (f : α → G) :\n    indicator (t \\ s) f = indicator t f - indicator s f := by rw [indicator_diff' h, sub_eq_add_neg]\n#align indicator_diff indicator_diff\n\n",
 "indicator_const_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem indicator_const_smul_apply (s : Set α) (r : M) (f : α → A) (x : α) :\n    indicator s (fun x => «expr • » r (f x)) x = «expr • » r (indicator s f x) :=\n  indicator_smul_apply s (fun x => r) f x\n#align indicator_const_smul_apply indicator_const_smul_apply\n\n",
 "indicator_const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem indicator_const_smul (s : Set α) (r : M) (f : α → A) :\n    (indicator s fun x : α => «expr • » r (f x)) = fun x : α => «expr • » r (indicator s f x) :=\n  funext <| indicator_const_smul_apply s r f\n#align indicator_const_smul indicator_const_smul\n\n",
 "indicator_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem indicator_compl {G} [AddGroup G] (s : Set α) (f : α → G) : indicator («expr ᶜ» s) f = f - indicator s f := by\n  rw [sub_eq_add_neg, indicator_compl']\n#align indicator_compl indicator_compl\n\n",
 "eq_on_mul_indicator":
 "@[to_additive]\ntheorem eq_on_mul_indicator : EqOn (mulIndicator s f) f s := fun x hx => mulIndicator_of_mem hx f\n#align eq_on_mul_indicator eq_on_mul_indicator\n\n",
 "comp_mul_indicator_const":
 "@[to_additive]\ntheorem comp_mul_indicator_const (c : M) (f : M → N) (hf : f 1 = 1) :\n    (fun x => f (s.mul_indicator (fun x => c) x)) = s.mul_indicator fun x => f c :=\n  (mulIndicator_comp_of_one hf).symm\n#align comp_mul_indicator_const comp_mul_indicator_const\n\n",
 "comp_mul_indicator":
 "@[to_additive]\ntheorem comp_mul_indicator (h : M → β) (f : α → M) {s : Set α} {x : α} [DecidablePred (· ∈ s)] :\n    h (s.mul_indicator f x) = s.piecewise (h ∘ f) (const α (h 1)) x := by\n  letI := Classical.decPred (· ∈ s) <;> convert s.apply_piecewise f (const α 1) fun _ => h\n#align comp_mul_indicator comp_mul_indicator\n\n"}