{"zero_not_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\ntheorem zero_not_mem_iff {a : A} : (0 : R) âˆ‰ (exprÏƒ) a â†” IsUnit a := by rw [zero_mem_iff, Classical.not_not]\n#align zero_not_mem_iff zero_not_mem_iff\n\n",
 "zero_mem_resolvent_set_of_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\ntheorem zero_mem_resolvent_set_of_unit (a : Â«expr Ë£Â» A) : 0 âˆˆ resolvent_set R (a : A) := by\n  simpa only [mem_resolvent_set_iff, â† not_mem_iff, zero_not_mem_iff] using a.is_unit\n#align zero_mem_resolvent_set_of_unit zero_mem_resolvent_set_of_unit\n\n",
 "zero_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\ntheorem zero_mem_iff {a : A} : (0 : R) âˆˆ (exprÏƒ) a â†” Â¬IsUnit a := by rw [mem_iff, map_zero, zero_sub, IsUnit.neg_iff]\n#align zero_mem_iff zero_mem_iff\n\n",
 "zero_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/-- Without the assumption `nontrivial A`, then `0 : A` would be invertible. -/\n@[simp]\ntheorem zero_eq [Nontrivial A] : (exprÏƒ) (0 : A) = {0} :=\n  by\n  refine' Set.Subset.antisymm _ (by simp [Algebra.algebraMap_eq_smul_one, mem_iff])\n  rw [spectrum, Set.compl_subset_comm]\n  intro k hk\n  rw [Set.mem_compl_singleton_iff] at hk\n  have : IsUnit (Â«expr â€¢ Â» (Units.mk0 k hk) (1 : A)) := IsUnit.smul (Units.mk0 k hk) isUnit_one\n  simpa [mem_resolvent_set_iff, Algebra.algebraMap_eq_smul_one]\n#align zero_eq zero_eq\n\n",
 "vadd_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr +áµ¥ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\ntheorem vadd_eq (a : A) (r : R) : Â«expr +áµ¥ Â» r ((exprÏƒ) a) = (exprÏƒ) ((Â«exprâ†‘â‚Â») r + a) :=\n  singleton_add.symm.trans <| singleton_add_eq a r\n#align vadd_eq vadd_eq\n\n",
 "units_smul_resolvent_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem units_smul_resolvent_self {r : Â«expr Ë£Â» R} {a : A} :\n    Â«expr â€¢ Â» r (resolvent a (r : R)) = resolvent (Â«expr â€¢ Â» râ»Â¹ a) (1 : R) := by\n  simpa only [Units.smul_def, Algebra.id.smul_eq_mul, Units.inv_mul] using @units_smul_resolvent _ _ _ _ _ r r a\n#align units_smul_resolvent_self units_smul_resolvent_self\n\n",
 "units_smul_resolvent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem units_smul_resolvent {r : Â«expr Ë£Â» R} {s : R} {a : A} :\n    Â«expr â€¢ Â» r (resolvent a (s : R)) = resolvent (Â«expr â€¢ Â» râ»Â¹ a) (Â«expr â€¢ Â» râ»Â¹ s : R) :=\n  by\n  by_cases h : s âˆˆ spectrum R a\n  Â· rw [mem_iff] at h\n    simp only [resolvent, Algebra.algebraMap_eq_smul_one] at *\n    rw [smul_assoc, â† smul_sub]\n    have h' : Â¬IsUnit (Â«expr â€¢ Â» râ»Â¹ (Â«expr â€¢ Â» s 1 - a)) := fun hu =>\n      h (by simpa only [smul_inv_smul] using IsUnit.smul r hu)\n    simp only [Ring.inverse_non_unit _ h, Ring.inverse_non_unit _ h', smul_zero]\n  Â· simp only [resolvent]\n    have h' : IsUnit (Â«expr â€¢ Â» r (algebraMap R A (Â«expr â€¢ Â» râ»Â¹ s)) - a) := by\n      simpa [Algebra.algebraMap_eq_smul_one, smul_assoc] using not_mem_iff.mp h\n    rw [â† h'.coe_sub_inv_smul, â† (not_mem_iff.mp h).unit_spec, Ring.inverse_unit, Ring.inverse_unit,\n      h'.coe_inv_sub_inv_smul]\n    simp only [Algebra.algebraMap_eq_smul_one, smul_assoc, smul_inv_smul]\n#align units_smul_resolvent units_smul_resolvent\n\n",
 "unit_smul_eq_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\ntheorem unit_smul_eq_smul (a : A) (r : Â«expr Ë£Â» R) : (exprÏƒ) (Â«expr â€¢ Â» r a) = Â«expr â€¢ Â» r ((exprÏƒ) a) :=\n  by\n  ext\n  have x_eq : x = Â«expr â€¢ Â» r (Â«expr â€¢ Â» râ»Â¹ x) := by simp\n  nth_rw 1 [x_eq]\n  rw [smul_mem_smul_iff]\n  constructor\n  Â· exact fun h => âŸ¨Â«expr â€¢ Â» râ»Â¹ x, âŸ¨h, by simpâŸ©âŸ©\n  Â· rintro âŸ¨_, _, x'_eqâŸ©\n    simpa [â† x'_eq]\n#align unit_smul_eq_smul unit_smul_eq_smul\n\n",
 "unit_mem_mul_iff_mem_swap_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n-- `r âˆˆ Ïƒ(a*b) â†” r âˆˆ Ïƒ(b*a)` for any `r : RË£`\ntheorem unit_mem_mul_iff_mem_swap_mul {a b : A} {r : Â«expr Ë£Â» R} : â†‘r âˆˆ (exprÏƒ) (a * b) â†” â†‘r âˆˆ (exprÏƒ) (b * a) :=\n  by\n  have hâ‚ : âˆ€ x y : A, IsUnit (1 - x * y) â†’ IsUnit (1 - y * x) :=\n    by\n    refine' fun x y h => âŸ¨âŸ¨1 - y * x, 1 + y * h.unit.inv * x, _, _âŸ©, rflâŸ©\n    calc\n      (1 - y * x) * (1 + y * (IsUnit.unit h).inv * x) = 1 - y * x + y * ((1 - x * y) * h.unit.inv) * x := by\n        noncomm_ring\n      _ = 1 := by simp only [Units.inv_eq_val_inv, IsUnit.mul_val_inv, mul_one, sub_add_cancel]\n      \n    calc\n      (1 + y * (IsUnit.unit h).inv * x) * (1 - y * x) = 1 - y * x + y * (h.unit.inv * (1 - x * y)) * x := by\n        noncomm_ring\n      _ = 1 := by simp only [Units.inv_eq_val_inv, IsUnit.val_inv_mul, mul_one, sub_add_cancel]\n      \n  simpa only [mem_iff, not_iff_not, Algebra.algebraMap_eq_smul_one, â† Units.smul_def, IsUnit.smul_sub_iff_sub_inv_smul,\n    â† smul_mul_assoc, â† mul_smul_comm râ»Â¹ b a] using iff.intro (hâ‚ (Â«expr â€¢ Â» râ»Â¹ a) b) (hâ‚ b (Â«expr â€¢ Â» râ»Â¹ a))\n#align unit_mem_mul_iff_mem_swap_mul unit_mem_mul_iff_mem_swap_mul\n\n",
 "subset_subalgebra":
 "-- it would be nice to state this for `subalgebra_class`, but we don't have such a thing yet\ntheorem subset_subalgebra {S : Subalgebra R A} (a : S) : spectrum R (a : A) âŠ† spectrum R a :=\n  compl_subset_compl.2 fun _ => IsUnit.map S.val\n#align subset_subalgebra subset_subalgebra\n\n",
 "subset_star_subalgebra":
 "-- this is why it would be nice if `subset_subalgebra` was registered for `subalgebra_class`.\ntheorem subset_star_subalgebra [StarRing R] [StarRing A] [StarModule R A] {S : StarSubalgebra R A} (a : S) :\n    spectrum R (a : A) âŠ† spectrum R a :=\n  compl_subset_compl.2 fun _ => IsUnit.map S.subtype\n#align subset_star_subalgebra subset_star_subalgebra\n\n",
 "subset_polynomial_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/-- Half of the spectral mapping theorem for polynomials. We prove it separately\nbecause it holds over any field, whereas `spectrum.map_polynomial_aeval_of_degree_pos` and\n`spectrum.map_polynomial_aeval_of_nonempty` need the field to be algebraically closed. -/\ntheorem subset_polynomial_aeval (a : A) (p : polynomial ğ•œ) :\n    Â«expr '' Â» (fun k => eval k p) ((exprÏƒ) a) âŠ† (exprÏƒ) (aeval a p) :=\n  by\n  rintro _ âŸ¨k, hk, rflâŸ©\n  let q := C (eval k p) - p\n  have hroot : is_root q k := by simp only [eval_C, eval_sub, sub_self, is_root.def]\n  rw [â† mul_div_eq_iff_is_root, â† neg_mul_neg, neg_sub] at hroot\n  have aeval_q_eq : (Â«exprâ†‘â‚Â») (eval k p) - aeval a p = aeval a q := by\n    simp only [aeval_C, AlgHom.map_sub, sub_left_inj]\n  rw [mem_iff, aeval_q_eq, â† hroot, aeval_mul]\n  have hcomm := (Commute.all (C k - X) (-(q / (X - C k)))).map (aeval a)\n  apply mt fun h => (hcomm.is_unit_mul_iff.mp h).1\n  simpa only [aeval_X, aeval_C, AlgHom.map_sub] using hk\n#align subset_polynomial_aeval subset_polynomial_aeval\n\n",
 "sub_singleton_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\ntheorem sub_singleton_eq (a : A) (r : R) : (exprÏƒ) a - {r} = (exprÏƒ) (a - (Â«exprâ†‘â‚Â») r) := by\n  simpa only [neg_sub, neg_eq] using congr_arg has_neg.neg (singleton_sub_eq a r)\n#align sub_singleton_eq sub_singleton_eq\n\n",
 "star_mem_resolvent_set_iff":
 "theorem star_mem_resolvent_set_iff {r : R} {a : A} : star r âˆˆ resolvent_set R a â†” r âˆˆ resolvent_set R (star a) := by\n  refine' âŸ¨fun h => _, fun h => _âŸ© <;>\n    simpa only [mem_resolvent_set_iff, Algebra.algebraMap_eq_smul_one, star_sub, star_smul, star_star, star_one] using\n      IsUnit.star h\n#align star_mem_resolvent_set_iff star_mem_resolvent_set_iff\n\n",
 "spectrum_apply_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\ntheorem spectrum_apply_subset (Ï† : F) (a : A) : (exprÏƒ) ((Ï† : A â†’ B) a) âŠ† (exprÏƒ) a := fun _ =>\n  mt (mem_resolvent_set_apply Ï†)\n#align spectrum_apply_subset spectrum_apply_subset\n\n",
 "smul_mem_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\ntheorem smul_mem_smul_iff {a : A} {s : R} {r : Â«expr Ë£Â» R} : Â«expr â€¢ Â» r s âˆˆ (exprÏƒ) (Â«expr â€¢ Â» r a) â†” s âˆˆ (exprÏƒ) a :=\n  by simp only [mem_iff, not_iff_not, Algebra.algebraMap_eq_smul_one, smul_assoc, â† smul_sub, isUnit_smul_iff]\n#align smul_mem_smul_iff smul_mem_smul_iff\n\n",
 "smul_eq_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/-- the assumption `(Ïƒ a).nonempty` is necessary and cannot be removed without\n    further conditions on the algebra `A` and scalar field `ğ•œ`. -/\ntheorem smul_eq_smul [Nontrivial A] (k : ğ•œ) (a : A) (ha : ((exprÏƒ) a).nonempty) :\n    (exprÏƒ) (Â«expr â€¢ Â» k a) = Â«expr â€¢ Â» k ((exprÏƒ) a) :=\n  by\n  rcases eq_or_ne k 0 with (rfl | h)\n  Â· simpa [ha, zero_smul_set]\n  Â· exact unit_smul_eq_smul a (Units.mk0 k h)\n#align smul_eq_smul smul_eq_smul\n\n",
 "singleton_sub_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\ntheorem singleton_sub_eq (a : A) (r : R) : {r} - (exprÏƒ) a = (exprÏƒ) ((Â«exprâ†‘â‚Â») r - a) := by\n  rw [sub_eq_add_neg, neg_eq, singleton_add_eq, sub_eq_add_neg]\n#align singleton_sub_eq singleton_sub_eq\n\n",
 "singleton_add_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\ntheorem singleton_add_eq (a : A) (r : R) : {r} + (exprÏƒ) a = (exprÏƒ) ((Â«exprâ†‘â‚Â») r + a) :=\n  ext fun x => by rw [singleton_add, image_add_left, mem_preimage, add_comm, add_mem_iff, map_neg, neg_neg]\n#align singleton_add_eq singleton_add_eq\n\n",
 "scalar_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n@[simp]\ntheorem scalar_eq [Nontrivial A] (k : ğ•œ) : (exprÏƒ) ((Â«exprâ†‘â‚Â») k) = {k} := by\n  rw [â† add_zero ((Â«exprâ†‘â‚Â») k), â† singleton_add_eq, zero_eq, Set.singleton_add_singleton, add_zero]\n#align scalar_eq scalar_eq\n\n",
 "resolvent_set_of_subsingleton":
 "@[simp]\ntheorem resolvent_set_of_subsingleton [subsingleton A] (a : A) : resolvent_set R a = Set.univ := by\n  simp_rw [resolvent_set, subsingleton.elim (algebraMap R A _ - a) 1, isUnit_one, Set.setOf_true]\n#align resolvent_set_of_subsingleton resolvent_set_of_subsingleton\n\n",
 "resolvent_eq":
 "theorem resolvent_eq {a : A} {r : R} (h : r âˆˆ resolvent_set R a) : resolvent a r = â†‘h.unitâ»Â¹ :=\n  Ring.inverse_unit h.unit\n#align resolvent_eq resolvent_eq\n\n",
 "preimage_units_mul_eq_swap_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\ntheorem preimage_units_mul_eq_swap_mul {a b : A} :\n    Â«expr â»Â¹' Â» (coe : Â«expr Ë£Â» R â†’ R) ((exprÏƒ) (a * b)) = Â«expr â»Â¹' Â» coe ((exprÏƒ) (b * a)) :=\n  Set.ext fun _ => unit_mem_mul_iff_mem_swap_mul\n#align preimage_units_mul_eq_swap_mul preimage_units_mul_eq_swap_mul\n\n",
 "pow_image_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/-- A specialization of `spectrum.subset_polynomial_aeval` to monic monomials for convenience. -/\ntheorem pow_image_subset (a : A) (n : â„•) : Â«expr '' Â» (fun x => x ^ n) ((exprÏƒ) a) âŠ† (exprÏƒ) (a ^ n) := by\n  simpa only [eval_pow, eval_X, aeval_X_pow] using subset_polynomial_aeval a (X ^ n : polynomial ğ•œ)\n#align pow_image_subset pow_image_subset\n\n",
 "one_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n@[simp]\ntheorem one_eq [Nontrivial A] : (exprÏƒ) (1 : A) = {1} :=\n  calc\n    (exprÏƒ) (1 : A) = (exprÏƒ) ((Â«exprâ†‘â‚Â») 1) := by rw [Algebra.algebraMap_eq_smul_one, one_smul]\n    _ = {1} := scalar_eq 1\n    \n#align one_eq one_eq\n\n",
 "of_subsingleton":
 "@[simp]\ntheorem of_subsingleton [subsingleton A] (a : A) : spectrum R a = âˆ… := by\n  rw [spectrum, resolvent_set_of_subsingleton, Set.compl_univ]\n#align of_subsingleton of_subsingleton\n\n",
 "not_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\ntheorem not_mem_iff {r : R} {a : A} : r âˆ‰ (exprÏƒ) a â†” IsUnit ((Â«exprâ†‘â‚Â») r - a) :=\n  by\n  apply not_iff_not.mp\n  simp [Set.not_not_mem, mem_iff]\n#align not_mem_iff not_mem_iff\n\n",
 "nonzero_mul_eq_swap_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\ntheorem nonzero_mul_eq_swap_mul (a b : A) : (exprÏƒ) (a * b) \\ {0} = (exprÏƒ) (b * a) \\ {0} :=\n  by\n  suffices h : âˆ€ x y : A, (exprÏƒ) (x * y) \\ {0} âŠ† (exprÏƒ) (y * x) \\ {0}\n  Â· exact Set.eq_of_subset_of_subset (h a b) (h b a)\n  Â· rintro _ _ k âŸ¨k_mem, k_neqâŸ©\n    change k with â†‘(Units.mk0 k k_neq) at k_mem\n    exact âŸ¨unit_mem_mul_iff_mem_swap_mul.mp k_mem, k_neqâŸ©\n#align nonzero_mul_eq_swap_mul nonzero_mul_eq_swap_mul\n\n",
 "nonempty_of_is_alg_closed_of_finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n-- We will use this both to show eigenvalues exist, and to prove Schur's lemma.\n/-- Every element `a` in a nontrivial finite-dimensional algebra `A`\nover an algebraically closed field `ğ•œ` has non-empty spectrum. -/\ntheorem nonempty_of_is_alg_closed_of_finite_dimensional [is_alg_closed ğ•œ] [Nontrivial A] [I : FiniteDimensional ğ•œ A]\n    (a : A) : âˆƒ k : ğ•œ, k âˆˆ (exprÏƒ) a :=\n  by\n  obtain âŸ¨p, âŸ¨h_mon, h_eval_pâŸ©âŸ© := is_integral_of_noetherian (IsNoetherian.iff_fg.2 I) a\n  have nu : Â¬IsUnit (aeval a p) := by\n    rw [â† aeval_def] at h_eval_p\n    rw [h_eval_p]\n    simp\n  rw [eq_prod_roots_of_monic_of_splits_id h_mon (is_alg_closed.splits p)] at nu\n  obtain âŸ¨k, hk, _âŸ© := exists_mem_of_not_is_unit_aeval_prod (monic.ne_zero h_mon) nu\n  exact âŸ¨k, hkâŸ©\n#align nonempty_of_is_alg_closed_of_finite_dimensional nonempty_of_is_alg_closed_of_finite_dimensional\n\n",
 "neg_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n#print neg_eq /-\ntheorem neg_eq (a : A) : -(exprÏƒ) a = (exprÏƒ) (-a) :=\n  Set.ext fun x => by simp only [mem_neg, mem_iff, map_neg, â† neg_add', IsUnit.neg_iff, sub_neg_eq_add]\n#align neg_eq neg_eq\n-/\n\n",
 "ne_zero_of_mem_of_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\ntheorem ne_zero_of_mem_of_unit {a : Â«expr Ë£Â» A} {r : R} (hr : r âˆˆ (exprÏƒ) (a : A)) : r â‰  0 := fun hn =>\n  (hn â–¸ hr) (zero_mem_resolvent_set_of_unit a)\n#align ne_zero_of_mem_of_unit ne_zero_of_mem_of_unit\n\n",
 "mem_resolvent_set_of_left_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\ntheorem mem_resolvent_set_of_left_right_inverse {r : R} {a b c : A} (hâ‚ : ((Â«exprâ†‘â‚Â») r - a) * b = 1)\n    (hâ‚‚ : c * ((Â«exprâ†‘â‚Â») r - a) = 1) : r âˆˆ resolvent_set R a :=\n  Units.isUnit âŸ¨(Â«exprâ†‘â‚Â») r - a, b, hâ‚, by rwa [â† left_inv_eq_right_inv hâ‚‚ hâ‚]âŸ©\n#align mem_resolvent_set_of_left_right_inverse mem_resolvent_set_of_left_right_inverse\n\n",
 "mem_resolvent_set_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\ntheorem mem_resolvent_set_iff {r : R} {a : A} : r âˆˆ resolvent_set R a â†” IsUnit ((Â«exprâ†‘â‚Â») r - a) :=\n  iff.rfl\n#align mem_resolvent_set_iff mem_resolvent_set_iff\n\n",
 "mem_resolvent_set_apply":
 "theorem mem_resolvent_set_apply (Ï† : F) {a : A} {r : R} (h : r âˆˆ resolvent_set R a) :\n    r âˆˆ resolvent_set R ((Ï† : A â†’ B) a) := by simpa only [map_sub, alg_hom_class.commutes] using h.map Ï†\n#align mem_resolvent_set_apply mem_resolvent_set_apply\n\n",
 "mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/-\nCopyright (c) 2021 Jireh Loreaux. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jireh Loreaux\n-/\n-- definition and basic properties\ntheorem mem_iff {r : R} {a : A} : r âˆˆ (exprÏƒ) a â†” Â¬IsUnit ((Â«exprâ†‘â‚Â») r - a) :=\n  iff.rfl\n#align mem_iff mem_iff\n\n",
 "map_star":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\nprotected theorem map_star (a : A) : (exprÏƒ) (star a) = star ((exprÏƒ) a) :=\n  by\n  ext\n  simpa only [Set.mem_star, mem_iff, not_iff_not] using star_mem_resolvent_set_iff.symm\n#align map_star map_star\n\n",
 "map_pow_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/-- A specialization of `spectrum.map_polynomial_aeval_of_nonempty` to monic monomials for\nconvenience. -/\ntheorem map_pow_of_pos [is_alg_closed ğ•œ] (a : A) {n : â„•} (hn : 0 < n) :\n    (exprÏƒ) (a ^ n) = Â«expr '' Â» (fun x => x ^ n) ((exprÏƒ) a) := by\n  simpa only [aeval_X_pow, eval_pow, eval_X] using\n    map_polynomial_aeval_of_degree_pos a (X ^ n : polynomial ğ•œ)\n      (by\n        rw_mod_cast [degree_X_pow]\n        exact hn)\n#align map_pow_of_pos map_pow_of_pos\n\n",
 "map_pow_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/-- A specialization of `spectrum.map_polynomial_aeval_of_nonempty` to monic monomials for\nconvenience. -/\ntheorem map_pow_of_nonempty [is_alg_closed ğ•œ] {a : A} (ha : ((exprÏƒ) a).nonempty) (n : â„•) :\n    (exprÏƒ) (a ^ n) = Â«expr '' Â» (fun x => x ^ n) ((exprÏƒ) a) := by\n  simpa only [aeval_X_pow, eval_pow, eval_X] using map_polynomial_aeval_of_nonempty a (X ^ n) ha\n#align map_pow_of_nonempty map_pow_of_nonempty\n\n",
 "map_polynomial_aeval_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/-- In this version of the spectral mapping theorem, we assume the spectrum\nis nonempty instead of assuming the degree of the polynomial is positive. -/\ntheorem map_polynomial_aeval_of_nonempty [is_alg_closed ğ•œ] (a : A) (p : polynomial ğ•œ) (hnon : ((exprÏƒ) a).nonempty) :\n    (exprÏƒ) (aeval a p) = Â«expr '' Â» (fun k => eval k p) ((exprÏƒ) a) :=\n  by\n  nontriviality A\n  refine' or.elim (le_or_gt (degree p) 0) (fun h => _) (map_polynomial_aeval_of_degree_pos a p)\n  Â· rw [eq_C_of_degree_le_zero h]\n    simp only [Set.image_congr, eval_C, aeval_C, scalar_eq, Set.Nonempty.image_const hnon]\n#align map_polynomial_aeval_of_nonempty map_polynomial_aeval_of_nonempty\n\n",
 "map_polynomial_aeval_of_degree_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/-- The *spectral mapping theorem* for polynomials.  Note: the assumption `degree p > 0`\nis necessary in case `Ïƒ a = âˆ…`, for then the left-hand side is `âˆ…` and the right-hand side,\nassuming `[nontrivial A]`, is `{k}` where `p = polynomial.C k`. -/\ntheorem map_polynomial_aeval_of_degree_pos [is_alg_closed ğ•œ] (a : A) (p : polynomial ğ•œ) (hdeg : 0 < degree p) :\n    (exprÏƒ) (aeval a p) = Â«expr '' Â» (fun k => eval k p) ((exprÏƒ) a) :=\n  by\n  -- handle the easy direction via `spectrum.subset_polynomial_aeval`\n  refine' Set.eq_of_subset_of_subset (fun k hk => _) (subset_polynomial_aeval a p)\n  -- write `C k - p` product of linear factors and a constant; show `C k - p â‰  0`.\n  have hprod := eq_prod_roots_of_splits_id (is_alg_closed.splits (C k - p))\n  have h_ne : C k - p â‰  0 :=\n    ne_zero_of_degree_gt (by rwa [degree_sub_eq_right_of_degree_lt (lt_of_le_of_lt degree_C_le hdeg)])\n  have lead_ne := leading_coeff_ne_zero.mpr h_ne\n  have lead_unit := (Units.map (Â«exprâ†‘â‚Â»).to_monoid_hom (Units.mk0 _ lead_ne)).is_unit\n  /- leading coefficient is a unit so product of linear factors is not a unit;\n    apply `exists_mem_of_not_is_unit_aeval_prod`. -/\n  have p_a_eq : aeval a (C k - p) = (Â«exprâ†‘â‚Â») k - aeval a p := by simp only [aeval_C, AlgHom.map_sub, sub_left_inj]\n  rw [mem_iff, â† p_a_eq, hprod, aeval_mul, ((Commute.all _ _).map (aeval a)).is_unit_mul_iff, aeval_C] at hk\n  replace hk := exists_mem_of_not_is_unit_aeval_prod h_ne (not_and.mp hk lead_unit)\n  rcases hk with âŸ¨r, r_mem, r_evâŸ©\n  exact âŸ¨r, r_mem, symm (by simpa [eval_sub, eval_C, sub_eq_zero] using r_ev)âŸ©\n#align map_polynomial_aeval_of_degree_pos map_polynomial_aeval_of_degree_pos\n\n",
 "map_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n#print map_inv /-\nprotected theorem map_inv (a : Â«expr Ë£Â» A) : ((exprÏƒ) (a : A))â»Â¹ = (exprÏƒ) (â†‘aâ»Â¹ : A) :=\n  by\n  refine' Set.eq_of_subset_of_subset (fun k hk => _) fun k hk => _\n  Â· rw [Set.mem_inv] at hk\n    have : k â‰  0 := by simpa only [inv_inv] using inv_ne_zero (ne_zero_of_mem_of_unit hk)\n    lift k to Â«expr Ë£Â» ğ•œ using is_unit_iff_ne_zero.mpr this\n    rw [â† Units.val_inv_eq_inv_val k] at hk\n    exact inv_mem_iff.mp hk\n  Â· lift k to Â«expr Ë£Â» ğ•œ using is_unit_iff_ne_zero.mpr (ne_zero_of_mem_of_unit hk)\n    simpa only [Units.val_inv_eq_inv_val] using inv_mem_iff.mp hk\n#align map_inv map_inv\n-/\n\n",
 "is_unit_resolvent":
 "/-- The resolvent is a unit when the argument is in the resolvent set. -/\ntheorem is_unit_resolvent {r : R} {a : A} : r âˆˆ resolvent_set R a â†” IsUnit (resolvent a r) :=\n  isUnit_ring_inverse.symm\n#align is_unit_resolvent is_unit_resolvent\n\n",
 "inv_mem_resolvent_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\ntheorem inv_mem_resolvent_set {r : Â«expr Ë£Â» R} {a : Â«expr Ë£Â» A} (h : (r : R) âˆˆ resolvent_set R (a : A)) :\n    (â†‘râ»Â¹ : R) âˆˆ resolvent_set R (â†‘aâ»Â¹ : A) :=\n  by\n  rw [mem_resolvent_set_iff, Algebra.algebraMap_eq_smul_one, â† Units.smul_def] at hâŠ¢\n  rw [IsUnit.smul_sub_iff_sub_inv_smul, inv_inv, IsUnit.sub_iff]\n  have hâ‚ : (a : A) * (Â«expr â€¢ Â» r (â†‘aâ»Â¹ : A) - 1) = Â«expr â€¢ Â» r 1 - a := by\n    rw [mul_sub, mul_smul_comm, a.mul_inv, mul_one]\n  have hâ‚‚ : (Â«expr â€¢ Â» r (â†‘aâ»Â¹ : A) - 1) * a = Â«expr â€¢ Â» r 1 - a := by rw [sub_mul, smul_mul_assoc, a.inv_mul, one_mul]\n  have hcomm : Commute (a : A) (Â«expr â€¢ Â» r (â†‘aâ»Â¹ : A) - 1) := by rwa [â† hâ‚‚] at hâ‚\n  exact (hcomm.is_unit_mul_iff.mp (hâ‚.symm â–¸ h)).2\n#align inv_mem_resolvent_set inv_mem_resolvent_set\n\n",
 "inv_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n#print inv_mem_iff /-\ntheorem inv_mem_iff {r : Â«expr Ë£Â» R} {a : Â«expr Ë£Â» A} : (r : R) âˆˆ (exprÏƒ) (a : A) â†” (â†‘râ»Â¹ : R) âˆˆ (exprÏƒ) (â†‘aâ»Â¹ : A) :=\n  not_iff_not.2 <| âŸ¨inv_mem_resolvent_set, inv_mem_resolvent_setâŸ©\n#align inv_mem_iff inv_mem_iff\n-/\n\n",
 "exists_mem_of_not_is_unit_aeval_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\ntheorem exists_mem_of_not_is_unit_aeval_prod [IsDomain R] {p : polynomial R} {a : A} (hp : p â‰  0)\n    (h : Â¬IsUnit (aeval a (Multiset.map (fun x : R => X - C x) p.roots).prod)) :\n    âˆƒ k : R, k âˆˆ (exprÏƒ) a âˆ§ eval k p = 0 :=\n  by\n  rw [â† Multiset.prod_toList, AlgHom.map_list_prod] at h\n  replace h := mt List.prod_isUnit h\n  simp only [not_forall, exists_prop, aeval_C, Multiset.mem_toList, List.mem_map, aeval_X, exists_exists_and_eq_and,\n    Multiset.mem_map, AlgHom.map_sub] at h\n  rcases h with âŸ¨r, r_mem, r_nuâŸ©\n  exact âŸ¨r, by rwa [mem_iff, â† IsUnit.sub_iff], by rwa [â† is_root.def, â† mem_roots hp]âŸ©\n#align exists_mem_of_not_is_unit_aeval_prod exists_mem_of_not_is_unit_aeval_prod\n\n",
 "apply_mem_spectrum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’+* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’+* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\ntheorem apply_mem_spectrum [Nontrivial R] (Ï† : F) (a : A) : Ï† a âˆˆ (exprÏƒ) a :=\n  by\n  have h : (Â«exprâ†‘â‚Â») (Ï† a) - a âˆˆ (Ï† : Â«expr â†’+* Â» A R).ker := by\n    simp only [RingHom.mem_ker, map_sub, RingHom.coe_coe, alg_hom_class.commutes, Algebra.id.map_eq_id,\n      RingHom.id_apply, sub_self]\n  simp only [spectrum.mem_iff, â† mem_nonunits_iff, coe_subset_nonunits (Ï† : Â«expr â†’+* Â» A R).ker_ne_top h]\n#align apply_mem_spectrum apply_mem_spectrum\n\n",
 "add_singleton_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\ntheorem add_singleton_eq (a : A) (r : R) : (exprÏƒ) a + {r} = (exprÏƒ) (a + (Â«exprâ†‘â‚Â») r) :=\n  add_comm {r} ((exprÏƒ) a) â–¸ add_comm (algebraMap R A r) a â–¸ singleton_add_eq a r\n#align add_singleton_eq add_singleton_eq\n\n",
 "add_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\ntheorem add_mem_iff {a : A} {r s : R} : r + s âˆˆ (exprÏƒ) a â†” r âˆˆ (exprÏƒ) (-(Â«exprâ†‘â‚Â») s + a) := by\n  simp only [mem_iff, sub_neg_eq_add, â† sub_sub, map_add]\n#align add_mem_iff add_mem_iff\n\n",
 "add_mem_add_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†‘â‚Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏƒ -/\ntheorem add_mem_add_iff {a : A} {r s : R} : r + s âˆˆ (exprÏƒ) ((Â«exprâ†‘â‚Â») s + a) â†” r âˆˆ (exprÏƒ) a := by\n  rw [add_mem_iff, neg_add_cancel_left]\n#align add_mem_add_iff add_mem_add_iff\n\n"}