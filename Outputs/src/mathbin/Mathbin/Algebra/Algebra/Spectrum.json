{"zero_not_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\ntheorem zero_not_mem_iff {a : A} : (0 : R) ∉ (exprσ) a ↔ IsUnit a := by rw [zero_mem_iff, Classical.not_not]\n#align zero_not_mem_iff zero_not_mem_iff\n\n",
 "zero_mem_resolvent_set_of_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem zero_mem_resolvent_set_of_unit (a : «expr ˣ» A) : 0 ∈ resolvent_set R (a : A) := by\n  simpa only [mem_resolvent_set_iff, ← not_mem_iff, zero_not_mem_iff] using a.is_unit\n#align zero_mem_resolvent_set_of_unit zero_mem_resolvent_set_of_unit\n\n",
 "zero_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\ntheorem zero_mem_iff {a : A} : (0 : R) ∈ (exprσ) a ↔ ¬IsUnit a := by rw [mem_iff, map_zero, zero_sub, IsUnit.neg_iff]\n#align zero_mem_iff zero_mem_iff\n\n",
 "zero_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/-- Without the assumption `nontrivial A`, then `0 : A` would be invertible. -/\n@[simp]\ntheorem zero_eq [Nontrivial A] : (exprσ) (0 : A) = {0} :=\n  by\n  refine' Set.Subset.antisymm _ (by simp [Algebra.algebraMap_eq_smul_one, mem_iff])\n  rw [spectrum, Set.compl_subset_comm]\n  intro k hk\n  rw [Set.mem_compl_singleton_iff] at hk\n  have : IsUnit («expr • » (Units.mk0 k hk) (1 : A)) := IsUnit.smul (Units.mk0 k hk) isUnit_one\n  simpa [mem_resolvent_set_iff, Algebra.algebraMap_eq_smul_one]\n#align zero_eq zero_eq\n\n",
 "vadd_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\ntheorem vadd_eq (a : A) (r : R) : «expr +ᵥ » r ((exprσ) a) = (exprσ) ((«expr↑ₐ») r + a) :=\n  singleton_add.symm.trans <| singleton_add_eq a r\n#align vadd_eq vadd_eq\n\n",
 "units_smul_resolvent_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem units_smul_resolvent_self {r : «expr ˣ» R} {a : A} :\n    «expr • » r (resolvent a (r : R)) = resolvent («expr • » r⁻¹ a) (1 : R) := by\n  simpa only [Units.smul_def, Algebra.id.smul_eq_mul, Units.inv_mul] using @units_smul_resolvent _ _ _ _ _ r r a\n#align units_smul_resolvent_self units_smul_resolvent_self\n\n",
 "units_smul_resolvent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem units_smul_resolvent {r : «expr ˣ» R} {s : R} {a : A} :\n    «expr • » r (resolvent a (s : R)) = resolvent («expr • » r⁻¹ a) («expr • » r⁻¹ s : R) :=\n  by\n  by_cases h : s ∈ spectrum R a\n  · rw [mem_iff] at h\n    simp only [resolvent, Algebra.algebraMap_eq_smul_one] at *\n    rw [smul_assoc, ← smul_sub]\n    have h' : ¬IsUnit («expr • » r⁻¹ («expr • » s 1 - a)) := fun hu =>\n      h (by simpa only [smul_inv_smul] using IsUnit.smul r hu)\n    simp only [Ring.inverse_non_unit _ h, Ring.inverse_non_unit _ h', smul_zero]\n  · simp only [resolvent]\n    have h' : IsUnit («expr • » r (algebraMap R A («expr • » r⁻¹ s)) - a) := by\n      simpa [Algebra.algebraMap_eq_smul_one, smul_assoc] using not_mem_iff.mp h\n    rw [← h'.coe_sub_inv_smul, ← (not_mem_iff.mp h).unit_spec, Ring.inverse_unit, Ring.inverse_unit,\n      h'.coe_inv_sub_inv_smul]\n    simp only [Algebra.algebraMap_eq_smul_one, smul_assoc, smul_inv_smul]\n#align units_smul_resolvent units_smul_resolvent\n\n",
 "unit_smul_eq_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\ntheorem unit_smul_eq_smul (a : A) (r : «expr ˣ» R) : (exprσ) («expr • » r a) = «expr • » r ((exprσ) a) :=\n  by\n  ext\n  have x_eq : x = «expr • » r («expr • » r⁻¹ x) := by simp\n  nth_rw 1 [x_eq]\n  rw [smul_mem_smul_iff]\n  constructor\n  · exact fun h => ⟨«expr • » r⁻¹ x, ⟨h, by simp⟩⟩\n  · rintro ⟨_, _, x'_eq⟩\n    simpa [← x'_eq]\n#align unit_smul_eq_smul unit_smul_eq_smul\n\n",
 "unit_mem_mul_iff_mem_swap_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n-- `r ∈ σ(a*b) ↔ r ∈ σ(b*a)` for any `r : Rˣ`\ntheorem unit_mem_mul_iff_mem_swap_mul {a b : A} {r : «expr ˣ» R} : ↑r ∈ (exprσ) (a * b) ↔ ↑r ∈ (exprσ) (b * a) :=\n  by\n  have h₁ : ∀ x y : A, IsUnit (1 - x * y) → IsUnit (1 - y * x) :=\n    by\n    refine' fun x y h => ⟨⟨1 - y * x, 1 + y * h.unit.inv * x, _, _⟩, rfl⟩\n    calc\n      (1 - y * x) * (1 + y * (IsUnit.unit h).inv * x) = 1 - y * x + y * ((1 - x * y) * h.unit.inv) * x := by\n        noncomm_ring\n      _ = 1 := by simp only [Units.inv_eq_val_inv, IsUnit.mul_val_inv, mul_one, sub_add_cancel]\n      \n    calc\n      (1 + y * (IsUnit.unit h).inv * x) * (1 - y * x) = 1 - y * x + y * (h.unit.inv * (1 - x * y)) * x := by\n        noncomm_ring\n      _ = 1 := by simp only [Units.inv_eq_val_inv, IsUnit.val_inv_mul, mul_one, sub_add_cancel]\n      \n  simpa only [mem_iff, not_iff_not, Algebra.algebraMap_eq_smul_one, ← Units.smul_def, IsUnit.smul_sub_iff_sub_inv_smul,\n    ← smul_mul_assoc, ← mul_smul_comm r⁻¹ b a] using iff.intro (h₁ («expr • » r⁻¹ a) b) (h₁ b («expr • » r⁻¹ a))\n#align unit_mem_mul_iff_mem_swap_mul unit_mem_mul_iff_mem_swap_mul\n\n",
 "subset_subalgebra":
 "-- it would be nice to state this for `subalgebra_class`, but we don't have such a thing yet\ntheorem subset_subalgebra {S : Subalgebra R A} (a : S) : spectrum R (a : A) ⊆ spectrum R a :=\n  compl_subset_compl.2 fun _ => IsUnit.map S.val\n#align subset_subalgebra subset_subalgebra\n\n",
 "subset_star_subalgebra":
 "-- this is why it would be nice if `subset_subalgebra` was registered for `subalgebra_class`.\ntheorem subset_star_subalgebra [StarRing R] [StarRing A] [StarModule R A] {S : StarSubalgebra R A} (a : S) :\n    spectrum R (a : A) ⊆ spectrum R a :=\n  compl_subset_compl.2 fun _ => IsUnit.map S.subtype\n#align subset_star_subalgebra subset_star_subalgebra\n\n",
 "subset_polynomial_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/-- Half of the spectral mapping theorem for polynomials. We prove it separately\nbecause it holds over any field, whereas `spectrum.map_polynomial_aeval_of_degree_pos` and\n`spectrum.map_polynomial_aeval_of_nonempty` need the field to be algebraically closed. -/\ntheorem subset_polynomial_aeval (a : A) (p : polynomial 𝕜) :\n    «expr '' » (fun k => eval k p) ((exprσ) a) ⊆ (exprσ) (aeval a p) :=\n  by\n  rintro _ ⟨k, hk, rfl⟩\n  let q := C (eval k p) - p\n  have hroot : is_root q k := by simp only [eval_C, eval_sub, sub_self, is_root.def]\n  rw [← mul_div_eq_iff_is_root, ← neg_mul_neg, neg_sub] at hroot\n  have aeval_q_eq : («expr↑ₐ») (eval k p) - aeval a p = aeval a q := by\n    simp only [aeval_C, AlgHom.map_sub, sub_left_inj]\n  rw [mem_iff, aeval_q_eq, ← hroot, aeval_mul]\n  have hcomm := (Commute.all (C k - X) (-(q / (X - C k)))).map (aeval a)\n  apply mt fun h => (hcomm.is_unit_mul_iff.mp h).1\n  simpa only [aeval_X, aeval_C, AlgHom.map_sub] using hk\n#align subset_polynomial_aeval subset_polynomial_aeval\n\n",
 "sub_singleton_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\ntheorem sub_singleton_eq (a : A) (r : R) : (exprσ) a - {r} = (exprσ) (a - («expr↑ₐ») r) := by\n  simpa only [neg_sub, neg_eq] using congr_arg has_neg.neg (singleton_sub_eq a r)\n#align sub_singleton_eq sub_singleton_eq\n\n",
 "star_mem_resolvent_set_iff":
 "theorem star_mem_resolvent_set_iff {r : R} {a : A} : star r ∈ resolvent_set R a ↔ r ∈ resolvent_set R (star a) := by\n  refine' ⟨fun h => _, fun h => _⟩ <;>\n    simpa only [mem_resolvent_set_iff, Algebra.algebraMap_eq_smul_one, star_sub, star_smul, star_star, star_one] using\n      IsUnit.star h\n#align star_mem_resolvent_set_iff star_mem_resolvent_set_iff\n\n",
 "spectrum_apply_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\ntheorem spectrum_apply_subset (φ : F) (a : A) : (exprσ) ((φ : A → B) a) ⊆ (exprσ) a := fun _ =>\n  mt (mem_resolvent_set_apply φ)\n#align spectrum_apply_subset spectrum_apply_subset\n\n",
 "smul_mem_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\ntheorem smul_mem_smul_iff {a : A} {s : R} {r : «expr ˣ» R} : «expr • » r s ∈ (exprσ) («expr • » r a) ↔ s ∈ (exprσ) a :=\n  by simp only [mem_iff, not_iff_not, Algebra.algebraMap_eq_smul_one, smul_assoc, ← smul_sub, isUnit_smul_iff]\n#align smul_mem_smul_iff smul_mem_smul_iff\n\n",
 "smul_eq_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/-- the assumption `(σ a).nonempty` is necessary and cannot be removed without\n    further conditions on the algebra `A` and scalar field `𝕜`. -/\ntheorem smul_eq_smul [Nontrivial A] (k : 𝕜) (a : A) (ha : ((exprσ) a).nonempty) :\n    (exprσ) («expr • » k a) = «expr • » k ((exprσ) a) :=\n  by\n  rcases eq_or_ne k 0 with (rfl | h)\n  · simpa [ha, zero_smul_set]\n  · exact unit_smul_eq_smul a (Units.mk0 k h)\n#align smul_eq_smul smul_eq_smul\n\n",
 "singleton_sub_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\ntheorem singleton_sub_eq (a : A) (r : R) : {r} - (exprσ) a = (exprσ) ((«expr↑ₐ») r - a) := by\n  rw [sub_eq_add_neg, neg_eq, singleton_add_eq, sub_eq_add_neg]\n#align singleton_sub_eq singleton_sub_eq\n\n",
 "singleton_add_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\ntheorem singleton_add_eq (a : A) (r : R) : {r} + (exprσ) a = (exprσ) ((«expr↑ₐ») r + a) :=\n  ext fun x => by rw [singleton_add, image_add_left, mem_preimage, add_comm, add_mem_iff, map_neg, neg_neg]\n#align singleton_add_eq singleton_add_eq\n\n",
 "scalar_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n@[simp]\ntheorem scalar_eq [Nontrivial A] (k : 𝕜) : (exprσ) ((«expr↑ₐ») k) = {k} := by\n  rw [← add_zero ((«expr↑ₐ») k), ← singleton_add_eq, zero_eq, Set.singleton_add_singleton, add_zero]\n#align scalar_eq scalar_eq\n\n",
 "resolvent_set_of_subsingleton":
 "@[simp]\ntheorem resolvent_set_of_subsingleton [subsingleton A] (a : A) : resolvent_set R a = Set.univ := by\n  simp_rw [resolvent_set, subsingleton.elim (algebraMap R A _ - a) 1, isUnit_one, Set.setOf_true]\n#align resolvent_set_of_subsingleton resolvent_set_of_subsingleton\n\n",
 "resolvent_eq":
 "theorem resolvent_eq {a : A} {r : R} (h : r ∈ resolvent_set R a) : resolvent a r = ↑h.unit⁻¹ :=\n  Ring.inverse_unit h.unit\n#align resolvent_eq resolvent_eq\n\n",
 "preimage_units_mul_eq_swap_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\ntheorem preimage_units_mul_eq_swap_mul {a b : A} :\n    «expr ⁻¹' » (coe : «expr ˣ» R → R) ((exprσ) (a * b)) = «expr ⁻¹' » coe ((exprσ) (b * a)) :=\n  Set.ext fun _ => unit_mem_mul_iff_mem_swap_mul\n#align preimage_units_mul_eq_swap_mul preimage_units_mul_eq_swap_mul\n\n",
 "pow_image_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/-- A specialization of `spectrum.subset_polynomial_aeval` to monic monomials for convenience. -/\ntheorem pow_image_subset (a : A) (n : ℕ) : «expr '' » (fun x => x ^ n) ((exprσ) a) ⊆ (exprσ) (a ^ n) := by\n  simpa only [eval_pow, eval_X, aeval_X_pow] using subset_polynomial_aeval a (X ^ n : polynomial 𝕜)\n#align pow_image_subset pow_image_subset\n\n",
 "one_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n@[simp]\ntheorem one_eq [Nontrivial A] : (exprσ) (1 : A) = {1} :=\n  calc\n    (exprσ) (1 : A) = (exprσ) ((«expr↑ₐ») 1) := by rw [Algebra.algebraMap_eq_smul_one, one_smul]\n    _ = {1} := scalar_eq 1\n    \n#align one_eq one_eq\n\n",
 "of_subsingleton":
 "@[simp]\ntheorem of_subsingleton [subsingleton A] (a : A) : spectrum R a = ∅ := by\n  rw [spectrum, resolvent_set_of_subsingleton, Set.compl_univ]\n#align of_subsingleton of_subsingleton\n\n",
 "not_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\ntheorem not_mem_iff {r : R} {a : A} : r ∉ (exprσ) a ↔ IsUnit ((«expr↑ₐ») r - a) :=\n  by\n  apply not_iff_not.mp\n  simp [Set.not_not_mem, mem_iff]\n#align not_mem_iff not_mem_iff\n\n",
 "nonzero_mul_eq_swap_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\ntheorem nonzero_mul_eq_swap_mul (a b : A) : (exprσ) (a * b) \\ {0} = (exprσ) (b * a) \\ {0} :=\n  by\n  suffices h : ∀ x y : A, (exprσ) (x * y) \\ {0} ⊆ (exprσ) (y * x) \\ {0}\n  · exact Set.eq_of_subset_of_subset (h a b) (h b a)\n  · rintro _ _ k ⟨k_mem, k_neq⟩\n    change k with ↑(Units.mk0 k k_neq) at k_mem\n    exact ⟨unit_mem_mul_iff_mem_swap_mul.mp k_mem, k_neq⟩\n#align nonzero_mul_eq_swap_mul nonzero_mul_eq_swap_mul\n\n",
 "nonempty_of_is_alg_closed_of_finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n-- We will use this both to show eigenvalues exist, and to prove Schur's lemma.\n/-- Every element `a` in a nontrivial finite-dimensional algebra `A`\nover an algebraically closed field `𝕜` has non-empty spectrum. -/\ntheorem nonempty_of_is_alg_closed_of_finite_dimensional [is_alg_closed 𝕜] [Nontrivial A] [I : FiniteDimensional 𝕜 A]\n    (a : A) : ∃ k : 𝕜, k ∈ (exprσ) a :=\n  by\n  obtain ⟨p, ⟨h_mon, h_eval_p⟩⟩ := is_integral_of_noetherian (IsNoetherian.iff_fg.2 I) a\n  have nu : ¬IsUnit (aeval a p) := by\n    rw [← aeval_def] at h_eval_p\n    rw [h_eval_p]\n    simp\n  rw [eq_prod_roots_of_monic_of_splits_id h_mon (is_alg_closed.splits p)] at nu\n  obtain ⟨k, hk, _⟩ := exists_mem_of_not_is_unit_aeval_prod (monic.ne_zero h_mon) nu\n  exact ⟨k, hk⟩\n#align nonempty_of_is_alg_closed_of_finite_dimensional nonempty_of_is_alg_closed_of_finite_dimensional\n\n",
 "neg_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n#print neg_eq /-\ntheorem neg_eq (a : A) : -(exprσ) a = (exprσ) (-a) :=\n  Set.ext fun x => by simp only [mem_neg, mem_iff, map_neg, ← neg_add', IsUnit.neg_iff, sub_neg_eq_add]\n#align neg_eq neg_eq\n-/\n\n",
 "ne_zero_of_mem_of_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\ntheorem ne_zero_of_mem_of_unit {a : «expr ˣ» A} {r : R} (hr : r ∈ (exprσ) (a : A)) : r ≠ 0 := fun hn =>\n  (hn ▸ hr) (zero_mem_resolvent_set_of_unit a)\n#align ne_zero_of_mem_of_unit ne_zero_of_mem_of_unit\n\n",
 "mem_resolvent_set_of_left_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\ntheorem mem_resolvent_set_of_left_right_inverse {r : R} {a b c : A} (h₁ : ((«expr↑ₐ») r - a) * b = 1)\n    (h₂ : c * ((«expr↑ₐ») r - a) = 1) : r ∈ resolvent_set R a :=\n  Units.isUnit ⟨(«expr↑ₐ») r - a, b, h₁, by rwa [← left_inv_eq_right_inv h₂ h₁]⟩\n#align mem_resolvent_set_of_left_right_inverse mem_resolvent_set_of_left_right_inverse\n\n",
 "mem_resolvent_set_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\ntheorem mem_resolvent_set_iff {r : R} {a : A} : r ∈ resolvent_set R a ↔ IsUnit ((«expr↑ₐ») r - a) :=\n  iff.rfl\n#align mem_resolvent_set_iff mem_resolvent_set_iff\n\n",
 "mem_resolvent_set_apply":
 "theorem mem_resolvent_set_apply (φ : F) {a : A} {r : R} (h : r ∈ resolvent_set R a) :\n    r ∈ resolvent_set R ((φ : A → B) a) := by simpa only [map_sub, alg_hom_class.commutes] using h.map φ\n#align mem_resolvent_set_apply mem_resolvent_set_apply\n\n",
 "mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/-\nCopyright (c) 2021 Jireh Loreaux. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jireh Loreaux\n-/\n-- definition and basic properties\ntheorem mem_iff {r : R} {a : A} : r ∈ (exprσ) a ↔ ¬IsUnit ((«expr↑ₐ») r - a) :=\n  iff.rfl\n#align mem_iff mem_iff\n\n",
 "map_star":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\nprotected theorem map_star (a : A) : (exprσ) (star a) = star ((exprσ) a) :=\n  by\n  ext\n  simpa only [Set.mem_star, mem_iff, not_iff_not] using star_mem_resolvent_set_iff.symm\n#align map_star map_star\n\n",
 "map_pow_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/-- A specialization of `spectrum.map_polynomial_aeval_of_nonempty` to monic monomials for\nconvenience. -/\ntheorem map_pow_of_pos [is_alg_closed 𝕜] (a : A) {n : ℕ} (hn : 0 < n) :\n    (exprσ) (a ^ n) = «expr '' » (fun x => x ^ n) ((exprσ) a) := by\n  simpa only [aeval_X_pow, eval_pow, eval_X] using\n    map_polynomial_aeval_of_degree_pos a (X ^ n : polynomial 𝕜)\n      (by\n        rw_mod_cast [degree_X_pow]\n        exact hn)\n#align map_pow_of_pos map_pow_of_pos\n\n",
 "map_pow_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/-- A specialization of `spectrum.map_polynomial_aeval_of_nonempty` to monic monomials for\nconvenience. -/\ntheorem map_pow_of_nonempty [is_alg_closed 𝕜] {a : A} (ha : ((exprσ) a).nonempty) (n : ℕ) :\n    (exprσ) (a ^ n) = «expr '' » (fun x => x ^ n) ((exprσ) a) := by\n  simpa only [aeval_X_pow, eval_pow, eval_X] using map_polynomial_aeval_of_nonempty a (X ^ n) ha\n#align map_pow_of_nonempty map_pow_of_nonempty\n\n",
 "map_polynomial_aeval_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/-- In this version of the spectral mapping theorem, we assume the spectrum\nis nonempty instead of assuming the degree of the polynomial is positive. -/\ntheorem map_polynomial_aeval_of_nonempty [is_alg_closed 𝕜] (a : A) (p : polynomial 𝕜) (hnon : ((exprσ) a).nonempty) :\n    (exprσ) (aeval a p) = «expr '' » (fun k => eval k p) ((exprσ) a) :=\n  by\n  nontriviality A\n  refine' or.elim (le_or_gt (degree p) 0) (fun h => _) (map_polynomial_aeval_of_degree_pos a p)\n  · rw [eq_C_of_degree_le_zero h]\n    simp only [Set.image_congr, eval_C, aeval_C, scalar_eq, Set.Nonempty.image_const hnon]\n#align map_polynomial_aeval_of_nonempty map_polynomial_aeval_of_nonempty\n\n",
 "map_polynomial_aeval_of_degree_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/-- The *spectral mapping theorem* for polynomials.  Note: the assumption `degree p > 0`\nis necessary in case `σ a = ∅`, for then the left-hand side is `∅` and the right-hand side,\nassuming `[nontrivial A]`, is `{k}` where `p = polynomial.C k`. -/\ntheorem map_polynomial_aeval_of_degree_pos [is_alg_closed 𝕜] (a : A) (p : polynomial 𝕜) (hdeg : 0 < degree p) :\n    (exprσ) (aeval a p) = «expr '' » (fun k => eval k p) ((exprσ) a) :=\n  by\n  -- handle the easy direction via `spectrum.subset_polynomial_aeval`\n  refine' Set.eq_of_subset_of_subset (fun k hk => _) (subset_polynomial_aeval a p)\n  -- write `C k - p` product of linear factors and a constant; show `C k - p ≠ 0`.\n  have hprod := eq_prod_roots_of_splits_id (is_alg_closed.splits (C k - p))\n  have h_ne : C k - p ≠ 0 :=\n    ne_zero_of_degree_gt (by rwa [degree_sub_eq_right_of_degree_lt (lt_of_le_of_lt degree_C_le hdeg)])\n  have lead_ne := leading_coeff_ne_zero.mpr h_ne\n  have lead_unit := (Units.map («expr↑ₐ»).to_monoid_hom (Units.mk0 _ lead_ne)).is_unit\n  /- leading coefficient is a unit so product of linear factors is not a unit;\n    apply `exists_mem_of_not_is_unit_aeval_prod`. -/\n  have p_a_eq : aeval a (C k - p) = («expr↑ₐ») k - aeval a p := by simp only [aeval_C, AlgHom.map_sub, sub_left_inj]\n  rw [mem_iff, ← p_a_eq, hprod, aeval_mul, ((Commute.all _ _).map (aeval a)).is_unit_mul_iff, aeval_C] at hk\n  replace hk := exists_mem_of_not_is_unit_aeval_prod h_ne (not_and.mp hk lead_unit)\n  rcases hk with ⟨r, r_mem, r_ev⟩\n  exact ⟨r, r_mem, symm (by simpa [eval_sub, eval_C, sub_eq_zero] using r_ev)⟩\n#align map_polynomial_aeval_of_degree_pos map_polynomial_aeval_of_degree_pos\n\n",
 "map_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n#print map_inv /-\nprotected theorem map_inv (a : «expr ˣ» A) : ((exprσ) (a : A))⁻¹ = (exprσ) (↑a⁻¹ : A) :=\n  by\n  refine' Set.eq_of_subset_of_subset (fun k hk => _) fun k hk => _\n  · rw [Set.mem_inv] at hk\n    have : k ≠ 0 := by simpa only [inv_inv] using inv_ne_zero (ne_zero_of_mem_of_unit hk)\n    lift k to «expr ˣ» 𝕜 using is_unit_iff_ne_zero.mpr this\n    rw [← Units.val_inv_eq_inv_val k] at hk\n    exact inv_mem_iff.mp hk\n  · lift k to «expr ˣ» 𝕜 using is_unit_iff_ne_zero.mpr (ne_zero_of_mem_of_unit hk)\n    simpa only [Units.val_inv_eq_inv_val] using inv_mem_iff.mp hk\n#align map_inv map_inv\n-/\n\n",
 "is_unit_resolvent":
 "/-- The resolvent is a unit when the argument is in the resolvent set. -/\ntheorem is_unit_resolvent {r : R} {a : A} : r ∈ resolvent_set R a ↔ IsUnit (resolvent a r) :=\n  isUnit_ring_inverse.symm\n#align is_unit_resolvent is_unit_resolvent\n\n",
 "inv_mem_resolvent_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem inv_mem_resolvent_set {r : «expr ˣ» R} {a : «expr ˣ» A} (h : (r : R) ∈ resolvent_set R (a : A)) :\n    (↑r⁻¹ : R) ∈ resolvent_set R (↑a⁻¹ : A) :=\n  by\n  rw [mem_resolvent_set_iff, Algebra.algebraMap_eq_smul_one, ← Units.smul_def] at h⊢\n  rw [IsUnit.smul_sub_iff_sub_inv_smul, inv_inv, IsUnit.sub_iff]\n  have h₁ : (a : A) * («expr • » r (↑a⁻¹ : A) - 1) = «expr • » r 1 - a := by\n    rw [mul_sub, mul_smul_comm, a.mul_inv, mul_one]\n  have h₂ : («expr • » r (↑a⁻¹ : A) - 1) * a = «expr • » r 1 - a := by rw [sub_mul, smul_mul_assoc, a.inv_mul, one_mul]\n  have hcomm : Commute (a : A) («expr • » r (↑a⁻¹ : A) - 1) := by rwa [← h₂] at h₁\n  exact (hcomm.is_unit_mul_iff.mp (h₁.symm ▸ h)).2\n#align inv_mem_resolvent_set inv_mem_resolvent_set\n\n",
 "inv_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n#print inv_mem_iff /-\ntheorem inv_mem_iff {r : «expr ˣ» R} {a : «expr ˣ» A} : (r : R) ∈ (exprσ) (a : A) ↔ (↑r⁻¹ : R) ∈ (exprσ) (↑a⁻¹ : A) :=\n  not_iff_not.2 <| ⟨inv_mem_resolvent_set, inv_mem_resolvent_set⟩\n#align inv_mem_iff inv_mem_iff\n-/\n\n",
 "exists_mem_of_not_is_unit_aeval_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\ntheorem exists_mem_of_not_is_unit_aeval_prod [IsDomain R] {p : polynomial R} {a : A} (hp : p ≠ 0)\n    (h : ¬IsUnit (aeval a (Multiset.map (fun x : R => X - C x) p.roots).prod)) :\n    ∃ k : R, k ∈ (exprσ) a ∧ eval k p = 0 :=\n  by\n  rw [← Multiset.prod_toList, AlgHom.map_list_prod] at h\n  replace h := mt List.prod_isUnit h\n  simp only [not_forall, exists_prop, aeval_C, Multiset.mem_toList, List.mem_map, aeval_X, exists_exists_and_eq_and,\n    Multiset.mem_map, AlgHom.map_sub] at h\n  rcases h with ⟨r, r_mem, r_nu⟩\n  exact ⟨r, by rwa [mem_iff, ← IsUnit.sub_iff], by rwa [← is_root.def, ← mem_roots hp]⟩\n#align exists_mem_of_not_is_unit_aeval_prod exists_mem_of_not_is_unit_aeval_prod\n\n",
 "apply_mem_spectrum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\ntheorem apply_mem_spectrum [Nontrivial R] (φ : F) (a : A) : φ a ∈ (exprσ) a :=\n  by\n  have h : («expr↑ₐ») (φ a) - a ∈ (φ : «expr →+* » A R).ker := by\n    simp only [RingHom.mem_ker, map_sub, RingHom.coe_coe, alg_hom_class.commutes, Algebra.id.map_eq_id,\n      RingHom.id_apply, sub_self]\n  simp only [spectrum.mem_iff, ← mem_nonunits_iff, coe_subset_nonunits (φ : «expr →+* » A R).ker_ne_top h]\n#align apply_mem_spectrum apply_mem_spectrum\n\n",
 "add_singleton_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\ntheorem add_singleton_eq (a : A) (r : R) : (exprσ) a + {r} = (exprσ) (a + («expr↑ₐ») r) :=\n  add_comm {r} ((exprσ) a) ▸ add_comm (algebraMap R A r) a ▸ singleton_add_eq a r\n#align add_singleton_eq add_singleton_eq\n\n",
 "add_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\ntheorem add_mem_iff {a : A} {r s : R} : r + s ∈ (exprσ) a ↔ r ∈ (exprσ) (-(«expr↑ₐ») s + a) := by\n  simp only [mem_iff, sub_neg_eq_add, ← sub_sub, map_add]\n#align add_mem_iff add_mem_iff\n\n",
 "add_mem_add_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↑ₐ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprσ -/\ntheorem add_mem_add_iff {a : A} {r s : R} : r + s ∈ (exprσ) ((«expr↑ₐ») s + a) ↔ r ∈ (exprσ) a := by\n  rw [add_mem_iff, neg_add_cancel_left]\n#align add_mem_add_iff add_mem_add_iff\n\n"}