{"to_alg_hom_apply":
 "theorem to_alg_hom_apply (y : S) : toAlgHom R S A y = algebraMap S A y :=\n  rfl\n#align to_alg_hom_apply to_alg_hom_apply\n\n",
 "span_smul_of_span_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem span_smul_of_span_eq_top {s : Set S} (hs : span R s = «expr⊤») (t : Set A) :\n    span R («expr • » s t) = (span S t).restrict_scalars R :=\n  le_antisymm\n    (span_le.2 fun x hx =>\n      let ⟨p, q, hps, hqt, hpqx⟩ := Set.mem_smul.1 hx\n      hpqx ▸ (span S t).smul_mem p (subset_span hqt))\n    fun p hp =>\n    span_induction hp (fun x hx => one_smul S x ▸ smul_mem_span_smul hs (subset_span hx)) (zero_mem _)\n      (fun _ _ => add_mem) fun k x hx => smul_mem_span_smul' hs hx\n#align span_smul_of_span_eq_top span_smul_of_span_eq_top\n\n",
 "span_algebra_map_image_of_tower":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem span_algebra_map_image_of_tower {S T : Type _} [CommSemiring S] [Semiring T] [Module R S] [IsScalarTower R S S]\n    [Algebra R T] [Algebra S T] [IsScalarTower R S T] (a : Set S) :\n    Submodule.span R («expr '' » (algebraMap S T) a) =\n      (Submodule.span R a).map ((Algebra.linearMap S T).restrict_scalars R) :=\n  (Submodule.span_image <| (Algebra.linearMap S T).restrict_scalars R).trans rfl\n#align span_algebra_map_image_of_tower span_algebra_map_image_of_tower\n\n",
 "span_algebra_map_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A variant of `submodule.span_image` for `algebra_map`. -/\ntheorem span_algebra_map_image (a : Set R) :\n    Submodule.span R («expr '' » (algebraMap R S) a) = (Submodule.span R a).map (Algebra.linearMap R S) :=\n  (Submodule.span_image <| Algebra.linearMap R S).trans rfl\n#align span_algebra_map_image span_algebra_map_image\n\n",
 "smul_mem_span_smul_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_mem_span_smul_of_mem {s : Set S} {t : Set A} {k : S} (hks : k ∈ span R s) {x : A} (hx : x ∈ t) :\n    «expr • » k x ∈ span R («expr • » s t) :=\n  span_induction hks (fun c hc => subset_span <| Set.mem_smul.2 ⟨c, x, hc, hx, rfl⟩)\n    (by\n      rw [zero_smul]\n      exact zero_mem _)\n    (fun c₁ c₂ ih₁ ih₂ => by\n      rw [add_smul]\n      exact add_mem ih₁ ih₂)\n    fun b c hc => by\n    rw [is_scalar_tower.smul_assoc]\n    exact smul_mem _ _ hc\n#align smul_mem_span_smul_of_mem smul_mem_span_smul_of_mem\n\n",
 "smul_mem_span_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_mem_span_smul' {s : Set S} (hs : span R s = «expr⊤») {t : Set A} {k : S} {x : A}\n    (hx : x ∈ span R («expr • » s t)) : «expr • » k x ∈ span R («expr • » s t) :=\n  span_induction hx\n    (fun x hx => by\n      let ⟨p, q, hp, hq, hpq⟩ := Set.mem_smul.1 hx\n      rw [← hpq, smul_smul]\n      exact smul_mem_span_smul_of_mem (hs.symm ▸ mem_top) hq)\n    (by\n      rw [smul_zero]\n      exact zero_mem _)\n    (fun x y ihx ihy => by\n      rw [smul_add]\n      exact add_mem ihx ihy)\n    fun c x hx => smul_comm c k x ▸ smul_mem _ _ hx\n#align smul_mem_span_smul' smul_mem_span_smul'\n\n",
 "smul_mem_span_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_mem_span_smul {s : Set S} (hs : span R s = «expr⊤») {t : Set A} {k : S} {x : A} (hx : x ∈ span R t) :\n    «expr • » k x ∈ span R («expr • » s t) :=\n  span_induction hx (fun x hx => smul_mem_span_smul_of_mem (hs.symm ▸ mem_top) hx)\n    (by\n      rw [smul_zero]\n      exact zero_mem _)\n    (fun x y ihx ihy => by\n      rw [smul_add]\n      exact add_mem ihx ihy)\n    fun c x hx => smul_comm c k x ▸ smul_mem _ _ hx\n#align smul_mem_span_smul smul_mem_span_smul\n\n",
 "restrict_scalars_span":
 "/-- If `A` is an `R`-algebra such that the induced morphism `R →+* A` is surjective, then the\n`R`-module generated by a set `X` equals the `A`-module generated by `X`. -/\ntheorem restrict_scalars_span (hsur : function.surjective (algebraMap R A)) (X : Set M) :\n    restrictScalars R (span A X) = span R X :=\n  by\n  refine' ((span_le_restrict_scalars R A X).antisymm fun m hm => _).symm\n  refine' span_induction hm subset_span (zero_mem _) (fun _ _ => add_mem) fun a m hm => _\n  obtain ⟨r, rfl⟩ := hsur a\n  simpa [algebraMap_smul] using smul_mem _ r hm\n#align restrict_scalars_span restrict_scalars_span\n\n",
 "restrict_scalars_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem restrict_scalars_injective :\n    function.injective (restrictScalars R : «expr ≃ₐ[ ] » A S B → «expr ≃ₐ[ ] » A R B) := fun f g h =>\n  AlgEquiv.ext (AlgEquiv.congr_fun h : _)\n#align restrict_scalars_injective restrict_scalars_injective\n\n",
 "restrict_scalars_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem restrict_scalars_apply (f : «expr ≃ₐ[ ] » A S B) (x : A) : f.restrict_scalars R x = f x :=\n  rfl\n#align restrict_scalars_apply restrict_scalars_apply\n\n",
 "of_algebra_map_eq'":
 "/-- See note [partially-applied ext lemmas]. -/\ntheorem of_algebra_map_eq' [Algebra R A] (h : algebraMap R A = (algebraMap S A).comp (algebraMap R S)) :\n    IsScalarTower R S A :=\n  of_algebraMap_eq <| RingHom.ext_iff.1 h\n#align of_algebra_map_eq' of_algebra_map_eq'\n\n",
 "of_algebra_map_eq":
 "theorem of_algebra_map_eq [Algebra R A] (h : ∀ x, algebraMap R A x = algebraMap S A (algebraMap R S x)) :\n    IsScalarTower R S A :=\n  ⟨fun x y z => by simp_rw [Algebra.smul_def, RingHom.map_mul, mul_assoc, h]⟩\n#align of_algebra_map_eq of_algebra_map_eq\n\n",
 "map_mem_span_algebra_map_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_mem_span_algebra_map_image {S T : Type _} [CommSemiring S] [Semiring T] [Algebra R S] [Algebra R T]\n    [Algebra S T] [IsScalarTower R S T] (x : S) (a : Set S) (hx : x ∈ Submodule.span R a) :\n    algebraMap S T x ∈ Submodule.span R («expr '' » (algebraMap S T) a) :=\n  by\n  rw [span_algebra_map_image_of_tower, mem_map]\n  exact ⟨x, hx, rfl⟩\n#align map_mem_span_algebra_map_image map_mem_span_algebra_map_image\n\n",
 "map_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n#print AlgHom.map_algebraMap /-\n@[simp]\ntheorem AlgHom.map_algebraMap (f : «expr →ₐ[ ] » A S B) (r : R) : f (algebraMap R A r) = algebraMap R B r := by\n  rw [algebraMap_apply R S A r, f.commutes, ← algebraMap_apply R S B]\n#align alg_hom.map_algebra_map AlgHom.map_algebraMap\n-/\n\n",
 "lsmul_injective":
 "theorem lsmul_injective [NoZeroSMulDivisors A M] {x : A} (hx : x ≠ 0) : function.injective (lsmul R M x) :=\n  smul_right_injective _ hx\n#align lsmul_injective lsmul_injective\n\n",
 "lsmul_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Anne Baanen\n-/\n@[simp]\ntheorem lsmul_coe (a : A) : (lsmul R M a : M → M) = («expr • » · ·) a :=\n  rfl\n#align lsmul_coe lsmul_coe\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[ext]\ntheorem algebra.ext {S : Type u} {A : Type v} [CommSemiring S] [Semiring A] (h1 h2 : Algebra S A)\n    (h :\n      ∀ (r : S) (x : A),\n        (haveI := h1\n          «expr • » r x) =\n          «expr • » r x) :\n    h1 = h2 :=\n  Algebra.algebra_ext _ _ fun r => by\n    simpa only [@Algebra.smul_def _ _ _ _ h1, @Algebra.smul_def _ _ _ _ h2, mul_one] using h r 1\n#align algebra.ext algebra.ext\n\n",
 "comp_algebra_map_of_tower":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print AlgHom.comp_algebraMap_of_tower /-\n@[simp]\ntheorem AlgHom.comp_algebraMap_of_tower (f : «expr →ₐ[ ] » A S B) :\n    (f : «expr →+* » A B).comp (algebraMap R A) = algebraMap R B :=\n  RingHom.ext f.map_algebra_map\n#align alg_hom.comp_algebra_map_of_tower AlgHom.comp_algebraMap_of_tower\n-/\n\n",
 "coe_to_alg_hom'":
 "@[simp]\ntheorem coe_to_alg_hom' : (toAlgHom R S A : S → A) = algebraMap S A :=\n  rfl\n#align coe_to_alg_hom' coe_to_alg_hom'\n\n",
 "coe_to_alg_hom":
 "@[simp]\ntheorem coe_to_alg_hom : ↑(toAlgHom R S A) = algebraMap S A :=\n  RingHom.ext fun _ => rfl\n#align coe_to_alg_hom coe_to_alg_hom\n\n",
 "coe_span_eq_span_of_surjective":
 "theorem coe_span_eq_span_of_surjective (h : function.surjective (algebraMap R A)) (s : Set M) :\n    (Submodule.span A s : Set M) = Submodule.span R s :=\n  congr_arg coe (Submodule.restrictScalars_span R A h s)\n#align coe_span_eq_span_of_surjective coe_span_eq_span_of_surjective\n\n",
 "coe_restrict_scalars'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem coe_restrict_scalars' (f : «expr ≃ₐ[ ] » A S B) : (restrictScalars R f : A → B) = f :=\n  rfl\n#align coe_restrict_scalars' coe_restrict_scalars'\n\n",
 "coe_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem coe_restrict_scalars (f : «expr ≃ₐ[ ] » A S B) : (f.restrict_scalars R : «expr ≃+* » A B) = f :=\n  rfl\n#align coe_restrict_scalars coe_restrict_scalars\n\n",
 "algebra_map_eq":
 "theorem algebra_map_eq : algebraMap R A = (algebraMap S A).comp (algebraMap R S) :=\n  RingHom.ext fun x => by simp_rw [RingHom.comp_apply, Algebra.algebraMap_eq_smul_one, smul_assoc, one_smul]\n#align algebra_map_eq algebra_map_eq\n\n",
 "algebraMap_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print algebraMap_smul /-\ntheorem algebraMap_smul (r : R) (x : M) : «expr • » (algebraMap R A r) x = «expr • » r x := by\n  rw [Algebra.algebraMap_eq_smul_one, smul_assoc, one_smul]\n#align algebra_map_smul algebraMap_smul\n-/\n\n",
 "algebraMap_apply":
 "#print algebraMap_apply /-\ntheorem algebraMap_apply (x : R) : algebraMap R A x = algebraMap S A (algebraMap R S x) := by\n  rw [algebra_map_eq R S A, RingHom.comp_apply]\n#align algebra_map_apply algebraMap_apply\n-/\n\n"}