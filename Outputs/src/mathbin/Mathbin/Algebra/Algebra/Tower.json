{"to_alg_hom_apply":
 "theorem to_alg_hom_apply (y : S) : to_alg_hom R S A y = algebra_map S A y :=\n  rfl\n#align to_alg_hom_apply to_alg_hom_apply\n\n",
 "span_smul_of_span_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem span_smul_of_span_eq_top {s : set S} (hs : span R s = «expr⊤») (t : set A) :\n    span R («expr • » s t) = (span S t).restrict_scalars R :=\n  le_antisymm\n    (span_le.2 fun x hx =>\n      let ⟨p, q, hps, hqt, hpqx⟩ := Set.mem_smul.1 hx\n      hpqx ▸ (span S t).smul_mem p (subset_span hqt))\n    fun p hp =>\n    span_induction hp (fun x hx => one_smul S x ▸ smul_mem_span_smul hs (subset_span hx)) (zero_mem _)\n      (fun _ _ => add_mem) fun k x hx => smul_mem_span_smul' hs hx\n#align span_smul_of_span_eq_top span_smul_of_span_eq_top\n\n",
 "span_restrict_scalars_eq_span_of_surjective":
 "theorem span_restrict_scalars_eq_span_of_surjective (h : function.surjective (algebra_map R A)) (s : set M) :\n    (submodule.span A s).restrict_scalars R = submodule.span R s :=\n  by\n  refine' le_antisymm (fun x hx => _) (submodule.span_subset_span _ _ _)\n  refine' submodule.span_induction hx _ _ _ _\n  · exact fun x hx => submodule.subset_span hx\n  · exact submodule.zero_mem _\n  · exact fun x y => submodule.add_mem _\n  · intro c x hx\n    obtain ⟨c', rfl⟩ := h c\n    rw [is_scalar_tower.algebra_map_smul]\n    exact submodule.smul_mem _ _ hx\n#align span_restrict_scalars_eq_span_of_surjective span_restrict_scalars_eq_span_of_surjective\n\n",
 "span_algebra_map_image_of_tower":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem span_algebra_map_image_of_tower {S T : Type _} [CommSemiring S] [Semiring T] [Module R S] [IsScalarTower R S S]\n    [algebra R T] [algebra S T] [IsScalarTower R S T] (a : set S) :\n    submodule.span R («expr '' » (algebra_map S T) a) =\n      (submodule.span R a).map ((algebra.linear_map S T).restrict_scalars R) :=\n  (submodule.span_image <| (algebra.linear_map S T).restrict_scalars R).trans rfl\n#align span_algebra_map_image_of_tower span_algebra_map_image_of_tower\n\n",
 "span_algebra_map_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A variant of `submodule.span_image` for `algebra_map`. -/\ntheorem span_algebra_map_image (a : set R) :\n    submodule.span R («expr '' » (algebra_map R S) a) = (submodule.span R a).map (algebra.linear_map R S) :=\n  (submodule.span_image <| algebra.linear_map R S).trans rfl\n#align span_algebra_map_image span_algebra_map_image\n\n",
 "smul_mem_span_smul_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_mem_span_smul_of_mem {s : set S} {t : set A} {k : S} (hks : k ∈ span R s) {x : A} (hx : x ∈ t) :\n    «expr • » k x ∈ span R («expr • » s t) :=\n  span_induction hks (fun c hc => subset_span <| Set.mem_smul.2 ⟨c, x, hc, hx, rfl⟩)\n    (by\n      rw [zero_smul]\n      exact zero_mem _)\n    (fun c₁ c₂ ih₁ ih₂ => by\n      rw [add_smul]\n      exact add_mem ih₁ ih₂)\n    fun b c hc => by\n    rw [is_scalar_tower.smul_assoc]\n    exact smul_mem _ _ hc\n#align smul_mem_span_smul_of_mem smul_mem_span_smul_of_mem\n\n",
 "smul_mem_span_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_mem_span_smul' {s : set S} (hs : span R s = «expr⊤») {t : set A} {k : S} {x : A}\n    (hx : x ∈ span R («expr • » s t)) : «expr • » k x ∈ span R («expr • » s t) :=\n  span_induction hx\n    (fun x hx => by\n      let ⟨p, q, hp, hq, hpq⟩ := Set.mem_smul.1 hx\n      rw [← hpq, smul_smul]\n      exact smul_mem_span_smul_of_mem (hs.symm ▸ mem_top) hq)\n    (by\n      rw [smul_zero]\n      exact zero_mem _)\n    (fun x y ihx ihy => by\n      rw [smul_add]\n      exact add_mem ihx ihy)\n    fun c x hx => smul_comm c k x ▸ smul_mem _ _ hx\n#align smul_mem_span_smul' smul_mem_span_smul'\n\n",
 "smul_mem_span_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_mem_span_smul {s : set S} (hs : span R s = «expr⊤») {t : set A} {k : S} {x : A} (hx : x ∈ span R t) :\n    «expr • » k x ∈ span R («expr • » s t) :=\n  span_induction hx (fun x hx => smul_mem_span_smul_of_mem (hs.symm ▸ mem_top) hx)\n    (by\n      rw [smul_zero]\n      exact zero_mem _)\n    (fun x y ihx ihy => by\n      rw [smul_add]\n      exact add_mem ihx ihy)\n    fun c x hx => smul_comm c k x ▸ smul_mem _ _ hx\n#align smul_mem_span_smul smul_mem_span_smul\n\n",
 "restrict_scalars_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem restrict_scalars_injective :\n    function.injective (restrict_scalars R : «expr ≃ₐ[ ] » A S B → «expr ≃ₐ[ ] » A R B) := fun f g h =>\n  alg_equiv.ext (alg_equiv.congr_fun h : _)\n#align restrict_scalars_injective restrict_scalars_injective\n\n",
 "restrict_scalars_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem restrict_scalars_apply (f : «expr ≃ₐ[ ] » A S B) (x : A) : f.restrict_scalars R x = f x :=\n  rfl\n#align restrict_scalars_apply restrict_scalars_apply\n\n",
 "of_algebra_map_eq'":
 "/-- See note [partially-applied ext lemmas]. -/\ntheorem of_algebra_map_eq' [algebra R A] (h : algebra_map R A = (algebra_map S A).comp (algebra_map R S)) :\n    IsScalarTower R S A :=\n  of_algebra_map_eq <| RingHom.ext_iff.1 h\n#align of_algebra_map_eq' of_algebra_map_eq'\n\n",
 "of_algebra_map_eq":
 "theorem of_algebra_map_eq [algebra R A] (h : ∀ x, algebra_map R A x = algebra_map S A (algebra_map R S x)) :\n    IsScalarTower R S A :=\n  ⟨fun x y z => by simp_rw [algebra.smul_def, RingHom.map_mul, mul_assoc, h]⟩\n#align of_algebra_map_eq of_algebra_map_eq\n\n",
 "map_mem_span_algebra_map_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_mem_span_algebra_map_image {S T : Type _} [CommSemiring S] [Semiring T] [algebra R S] [algebra R T]\n    [algebra S T] [IsScalarTower R S T] (x : S) (a : set S) (hx : x ∈ submodule.span R a) :\n    algebra_map S T x ∈ submodule.span R («expr '' » (algebra_map S T) a) :=\n  by\n  rw [span_algebra_map_image_of_tower, mem_map]\n  exact ⟨x, hx, rfl⟩\n#align map_mem_span_algebra_map_image map_mem_span_algebra_map_image\n\n",
 "map_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem _root_.alg_hom.map_algebra_map (f : «expr →ₐ[ ] » A S B) (r : R) : f (algebra_map R A r) = algebra_map R B r :=\n  by rw [algebra_map_apply R S A r, f.commutes, ← algebra_map_apply R S B]\n#align alg_hom.map_algebra_map alg_hom.map_algebra_map\n\n",
 "lsmul_injective":
 "theorem lsmul_injective [NoZeroSMulDivisors A M] {x : A} (hx : x ≠ 0) : function.injective (lsmul R M x) :=\n  smul_right_injective _ hx\n#align lsmul_injective lsmul_injective\n\n",
 "lsmul_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Anne Baanen\n-/\n@[simp]\ntheorem lsmul_coe (a : A) : (lsmul R M a : M → M) = («expr • » · ·) a :=\n  rfl\n#align lsmul_coe lsmul_coe\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[ext]\ntheorem algebra.ext {S : Type u} {A : Type v} [CommSemiring S] [Semiring A] (h1 h2 : algebra S A)\n    (h :\n      ∀ (r : S) (x : A),\n        (haveI := h1\n          «expr • » r x) =\n          «expr • » r x) :\n    h1 = h2 :=\n  algebra.algebra_ext _ _ fun r => by\n    simpa only [@algebra.smul_def _ _ _ _ h1, @algebra.smul_def _ _ _ _ h2, mul_one] using h r 1\n#align algebra.ext algebra.ext\n\n",
 "comp_algebra_map_of_tower":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem _root_.alg_hom.comp_algebra_map_of_tower (f : «expr →ₐ[ ] » A S B) :\n    (f : «expr →+* » A B).comp (algebra_map R A) = algebra_map R B :=\n  RingHom.ext f.map_algebra_map\n#align alg_hom.comp_algebra_map_of_tower alg_hom.comp_algebra_map_of_tower\n\n",
 "coe_to_alg_hom'":
 "@[simp]\ntheorem coe_to_alg_hom' : (to_alg_hom R S A : S → A) = algebra_map S A :=\n  rfl\n#align coe_to_alg_hom' coe_to_alg_hom'\n\n",
 "coe_to_alg_hom":
 "@[simp]\ntheorem coe_to_alg_hom : ↑(to_alg_hom R S A) = algebra_map S A :=\n  RingHom.ext fun _ => rfl\n#align coe_to_alg_hom coe_to_alg_hom\n\n",
 "coe_span_eq_span_of_surjective":
 "theorem coe_span_eq_span_of_surjective (h : function.surjective (algebra_map R A)) (s : set M) :\n    (submodule.span A s : set M) = submodule.span R s :=\n  congr_arg coe (algebra.span_restrict_scalars_eq_span_of_surjective h s)\n#align coe_span_eq_span_of_surjective coe_span_eq_span_of_surjective\n\n",
 "coe_restrict_scalars'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem coe_restrict_scalars' (f : «expr ≃ₐ[ ] » A S B) : (restrict_scalars R f : A → B) = f :=\n  rfl\n#align coe_restrict_scalars' coe_restrict_scalars'\n\n",
 "coe_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem coe_restrict_scalars (f : «expr ≃ₐ[ ] » A S B) : (f.restrict_scalars R : «expr ≃+* » A B) = f :=\n  rfl\n#align coe_restrict_scalars coe_restrict_scalars\n\n",
 "algebra_map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem algebra_map_smul (r : R) (x : M) : «expr • » (algebra_map R A r) x = «expr • » r x := by\n  rw [algebra.algebra_map_eq_smul_one, smul_assoc, one_smul]\n#align algebra_map_smul algebra_map_smul\n\n",
 "algebra_map_eq":
 "theorem algebra_map_eq : algebra_map R A = (algebra_map S A).comp (algebra_map R S) :=\n  RingHom.ext fun x => by simp_rw [RingHom.comp_apply, algebra.algebra_map_eq_smul_one, smul_assoc, one_smul]\n#align algebra_map_eq algebra_map_eq\n\n",
 "algebra_map_apply":
 "theorem algebra_map_apply (x : R) : algebra_map R A x = algebra_map S A (algebra_map R S x) := by\n  rw [algebra_map_eq R S A, RingHom.comp_apply]\n#align algebra_map_apply algebra_map_apply\n\n"}