{"zsmul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print zsmul_mem /-\nprotected theorem zsmul_mem {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] (S : Subalgebra R A) {x : A}\n    (hx : x ∈ S) (n : ℤ) : «expr • » n x ∈ S :=\n  zsmul_mem hx n\n#align zsmul_mem zsmul_mem\n-/\n\n",
 "zero_mem":
 "protected theorem zero_mem : (0 : A) ∈ S :=\n  zero_mem S\n#align zero_mem zero_mem\n\n",
 "val_comp_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem val_comp_cod_restrict (f : «expr →ₐ[ ] » A R B) (S : Subalgebra R B) (hf : ∀ x, f x ∈ S) :\n    S.val.comp (f.cod_restrict S hf) = f :=\n  AlgHom.ext fun _ => rfl\n#align val_comp_cod_restrict val_comp_cod_restrict\n\n",
 "val_apply":
 "theorem val_apply (x : S) : S.val x = (x : A) :=\n  rfl\n#align val_apply val_apply\n\n",
 "top_to_subsemiring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_to_subsemiring : («expr⊤» : Subalgebra R A).to_subsemiring = «expr⊤» :=\n  rfl\n#align top_to_subsemiring top_to_subsemiring\n\n",
 "top_to_subring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_to_subring {R A : Type _} [CommRing R] [Ring A] [Algebra R A] :\n    («expr⊤» : Subalgebra R A).to_subring = «expr⊤» :=\n  rfl\n#align top_to_subring top_to_subring\n\n",
 "top_to_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_to_submodule : («expr⊤» : Subalgebra R A).to_submodule = «expr⊤» :=\n  rfl\n#align top_to_submodule top_to_submodule\n\n",
 "to_subsemiring_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem to_subsemiring_subtype : S.to_subsemiring.subtype = (S.val : «expr →+* » S A) :=\n  rfl\n#align to_subsemiring_subtype to_subsemiring_subtype\n\n",
 "to_subsemiring_injective":
 "theorem to_subsemiring_injective : function.injective (to_subsemiring : Subalgebra R A → Subsemiring A) := fun S T h =>\n  ext fun x => by rw [← mem_to_subsemiring, ← mem_to_subsemiring, h]\n#align to_subsemiring_injective to_subsemiring_injective\n\n",
 "to_subsemiring_inj":
 "theorem to_subsemiring_inj {S U : Subalgebra R A} : S.to_subsemiring = U.to_subsemiring ↔ S = U :=\n  toSubsemiring_injective.eq_iff\n#align to_subsemiring_inj to_subsemiring_inj\n\n",
 "to_subsemiring_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem to_subsemiring_eq_top {S : Subalgebra R A} : S.to_subsemiring = «expr⊤» ↔ S = «expr⊤» :=\n  Subalgebra.toSubsemiring_injective.eq_iff' top_toSubsemiring\n#align to_subsemiring_eq_top to_subsemiring_eq_top\n\n",
 "to_subring_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem to_subring_subtype {R A : Type _} [CommRing R] [Ring A] [Algebra R A] (S : Subalgebra R A) :\n    S.to_subring.subtype = (S.val : «expr →+* » S A) :=\n  rfl\n#align to_subring_subtype to_subring_subtype\n\n",
 "to_subring_injective":
 "theorem to_subring_injective {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] :\n    function.injective (toSubring : Subalgebra R A → Subring A) := fun S T h =>\n  ext fun x => by rw [← mem_to_subring, ← mem_to_subring, h]\n#align to_subring_injective to_subring_injective\n\n",
 "to_subring_inj":
 "theorem to_subring_inj {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] {S U : Subalgebra R A} :\n    S.to_subring = U.to_subring ↔ S = U :=\n  toSubring_injective.eq_iff\n#align to_subring_inj to_subring_inj\n\n",
 "to_subring_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem to_subring_eq_top {R A : Type _} [CommRing R] [Ring A] [Algebra R A] {S : Subalgebra R A} :\n    S.to_subring = «expr⊤» ↔ S = «expr⊤» :=\n  Subalgebra.toSubring_injective.eq_iff' top_toSubring\n#align to_subring_eq_top to_subring_eq_top\n\n",
 "to_submodule_to_subalgebra":
 "#print Subalgebra.toSubmodule_toSubalgebra /-\n@[simp]\ntheorem Subalgebra.toSubmodule_toSubalgebra (S : Subalgebra R A) :\n    (S.to_submodule.to_subalgebra S.one_mem fun _ _ => S.mul_mem) = S :=\n  SetLike.coe_injective rfl\n#align subalgebra.to_submodule_to_subalgebra Subalgebra.toSubmodule_toSubalgebra\n-/\n\n",
 "to_submodule_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem to_submodule_eq_top {S : Subalgebra R A} : S.to_submodule = «expr⊤» ↔ S = «expr⊤» :=\n  Subalgebra.toSubmodule.injective.eq_iff' top_toSubmodule\n#align to_submodule_eq_top to_submodule_eq_top\n\n",
 "to_submodule_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem to_submodule_bot : («expr⊥» : Subalgebra R A).to_submodule = «expr ∙ » R 1 :=\n  by\n  ext x\n  simp [mem_bot, -Set.singleton_one, Submodule.mem_span_singleton, Algebra.smul_def]\n#align to_submodule_bot to_submodule_bot\n\n",
 "to_subalgebra_to_submodule":
 "@[simp]\ntheorem to_subalgebra_to_submodule (p : Submodule R A) (h_one h_mul) : (p.to_subalgebra h_one h_mul).to_submodule = p :=\n  SetLike.coe_injective rfl\n#align to_subalgebra_to_submodule to_subalgebra_to_submodule\n\n",
 "to_subalgebra_mk":
 "@[simp]\ntheorem to_subalgebra_mk (s : Set A) (h0 hadd hsmul h1 hmul) :\n    (submodule.mk s hadd h0 hsmul : Submodule R A).to_subalgebra h1 hmul =\n      subalgebra.mk s (@hmul) h1 (@hadd) h0 fun r =>\n        by\n        rw [Algebra.algebraMap_eq_smul_one]\n        exact hsmul r h1 :=\n  rfl\n#align to_subalgebra_mk to_subalgebra_mk\n\n",
 "surjective_algebra_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem surjective_algebra_map_iff : function.surjective (algebraMap R A) ↔ («expr⊤» : Subalgebra R A) = «expr⊥» :=\n  ⟨fun h =>\n    eq_bot_iff.2 fun y _ =>\n      let ⟨x, hx⟩ := h y\n      hx ▸ Subalgebra.algebraMap_mem _ _,\n    fun h y => Algebra.mem_bot.1 <| eq_bot_iff.1 h (Algebra.mem_top : y ∈ _)⟩\n#align surjective_algebra_map_iff surjective_algebra_map_iff\n\n",
 "supr_lift_of_mem":
 "theorem supr_lift_of_mem {i : ι} (x : T) (hx : (x : A) ∈ K i) : supᵢLift K dir f hf T hT x = f i ⟨x, hx⟩ := by\n  subst hT <;> exact Set.unionᵢLift_of_mem x hx\n#align supr_lift_of_mem supr_lift_of_mem\n\n",
 "supr_lift_mk":
 "@[simp]\ntheorem supr_lift_mk {i : ι} (x : K i) (hx : (x : A) ∈ T) : supᵢLift K dir f hf T hT ⟨x, hx⟩ = f i x := by\n  subst hT <;> exact Set.unionᵢLift_mk x hx\n#align supr_lift_mk supr_lift_mk\n\n",
 "supr_lift_inclusion":
 "@[simp]\ntheorem supr_lift_inclusion {i : ι} (x : K i) (h : K i ≤ T) : supᵢLift K dir f hf T hT (inclusion h x) = f i x := by\n  subst T <;> exact Set.unionᵢLift_inclusion _ _\n#align supr_lift_inclusion supr_lift_inclusion\n\n",
 "supr_lift_comp_inclusion":
 "@[simp]\ntheorem supr_lift_comp_inclusion {i : ι} (h : K i ≤ T) : (supᵢLift K dir f hf T hT).comp (inclusion h) = f i := by\n  ext <;> simp\n#align supr_lift_comp_inclusion supr_lift_comp_inclusion\n\n",
 "sum_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print sum_mem /-\nprotected theorem sum_mem {ι : Type w} {t : Finset ι} {f : ι → A} (h : ∀ x ∈ t, f x ∈ S) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f x) ∈ S :=\n  sum_mem h\n#align sum_mem sum_mem\n-/\n\n",
 "sub_mem":
 "#print sub_mem /-\nprotected theorem sub_mem {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] (S : Subalgebra R A) {x y : A}\n    (hx : x ∈ S) (hy : y ∈ S) : x - y ∈ S :=\n  sub_mem hx hy\n#align sub_mem sub_mem\n-/\n\n",
 "srange_le":
 "theorem srange_le : (algebraMap R A).srange ≤ S.to_subsemiring := fun x ⟨r, hr⟩ => hr ▸ S.algebra_map_mem r\n#align srange_le srange_le\n\n",
 "srange_algebra_map":
 "@[simp]\ntheorem srange_algebra_map {R A : Type _} [CommSemiring R] [CommSemiring A] [Algebra R A] (S : Subalgebra R A) :\n    (algebraMap S A).srange = S.to_subsemiring := by\n  rw [algebra_map_eq, Algebra.id.map_eq_id, RingHom.id_comp, ← to_subsemiring_subtype, Subsemiring.rangeS_subtype]\n#align srange_algebra_map srange_algebra_map\n\n",
 "smul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_mem {x : A} (hx : x ∈ S) (r : R) : «expr • » r x ∈ S :=\n  (Algebra.smul_def r x).symm ▸ mul_mem (S.algebra_map_mem r) hx\n#align smul_mem smul_mem\n\n",
 "smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_def [SMul A α] {S : Subalgebra R A} (g : S) (m : α) : «expr • » g m = «expr • » (g : A) m :=\n  rfl\n#align smul_def smul_def\n\n",
 "range_val":
 "theorem range_val : S.val.range = S :=\n  ext <| Set.ext_iff.1 <| S.val.coe_range.trans Subtype.range_val\n#align range_val range_val\n\n",
 "range_top_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_top_iff_surjective (f : «expr →ₐ[ ] » A R B) :\n    f.range = («expr⊤» : Subalgebra R B) ↔ function.surjective f :=\n  Algebra.eq_top_iff\n#align range_top_iff_surjective range_top_iff_surjective\n\n",
 "range_subset":
 "theorem range_subset : Set.range (algebraMap R A) ⊆ S := fun x ⟨r, hr⟩ => hr ▸ S.algebra_map_mem r\n#align range_subset range_subset\n\n",
 "range_le":
 "theorem range_le : Set.range (algebraMap R A) ≤ S :=\n  S.range_subset\n#align range_le range_le\n\n",
 "range_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem range_id : (AlgHom.id R A).range = «expr⊤» :=\n  SetLike.coe_injective Set.range_id\n#align range_id range_id\n\n",
 "range_comp_le_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem range_comp_le_range (f : «expr →ₐ[ ] » A R B) (g : «expr →ₐ[ ] » B R C) : (g.comp f).range ≤ g.range :=\n  SetLike.coe_mono (Set.range_comp_subset_range f g)\n#align range_comp_le_range range_comp_le_range\n\n",
 "range_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem range_comp (f : «expr →ₐ[ ] » A R B) (g : «expr →ₐ[ ] » B R C) : (g.comp f).range = f.range.map g :=\n  SetLike.coe_injective (Set.range_comp g f)\n#align range_comp range_comp\n\n",
 "range_algebra_map":
 "@[simp]\ntheorem range_algebra_map {R A : Type _} [CommRing R] [CommRing A] [Algebra R A] (S : Subalgebra R A) :\n    (algebraMap S A).range = S.to_subring := by\n  rw [algebra_map_eq, Algebra.id.map_eq_id, RingHom.id_comp, ← to_subring_subtype, Subring.range_subtype]\n#align range_algebra_map range_algebra_map\n\n",
 "prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem prod_top : (prod («expr⊤») («expr⊤») : Subalgebra R (A × B)) = «expr⊤» := by ext <;> simp\n#align prod_top prod_top\n\n",
 "prod_to_submodule":
 "theorem prod_to_submodule : (S.prod S₁).to_submodule = S.to_submodule.prod S₁.to_submodule :=\n  rfl\n#align prod_to_submodule prod_to_submodule\n\n",
 "prod_mono":
 "theorem prod_mono {S T : Subalgebra R A} {S₁ T₁ : Subalgebra R B} : S ≤ T → S₁ ≤ T₁ → prod S S₁ ≤ prod T T₁ :=\n  Set.prod_mono\n#align prod_mono prod_mono\n\n",
 "prod_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print prod_mem /-\nprotected theorem prod_mem {R : Type u} {A : Type v} [CommSemiring R] [CommSemiring A] [Algebra R A]\n    (S : Subalgebra R A) {ι : Type w} {t : Finset ι} {f : ι → A} (h : ∀ x ∈ t, f x ∈ S) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f x) ∈ S :=\n  prod_mem h\n#align prod_mem prod_mem\n-/\n\n",
 "prod_inf_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem prod_inf_prod {S T : Subalgebra R A} {S₁ T₁ : Subalgebra R B} :\n    «expr ⊓ » (S.prod S₁) (T.prod T₁) = («expr ⊓ » S T).prod («expr ⊓ » S₁ T₁) :=\n  SetLike.coe_injective Set.prod_inter_prod\n#align prod_inf_prod prod_inf_prod\n\n",
 "pow_mem":
 "#print pow_mem /-\nprotected theorem pow_mem {x : A} (hx : x ∈ S) (n : ℕ) : x ^ n ∈ S :=\n  pow_mem hx n\n#align pow_mem pow_mem\n-/\n\n",
 "one_mem":
 "protected theorem one_mem : (1 : A) ∈ S :=\n  one_mem S\n#align one_mem one_mem\n\n",
 "of_left_inverse_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem of_left_inverse_symm_apply {g : B → A} {f : «expr →ₐ[ ] » A R B} (h : function.left_inverse g f) (x : f.range) :\n    (ofLeftInverse h).symm x = g x :=\n  rfl\n#align of_left_inverse_symm_apply of_left_inverse_symm_apply\n\n",
 "of_left_inverse_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem of_left_inverse_apply {g : B → A} {f : «expr →ₐ[ ] » A R B} (h : function.left_inverse g f) (x : A) :\n    ↑(ofLeftInverse h x) = f x :=\n  rfl\n#align of_left_inverse_apply of_left_inverse_apply\n\n",
 "of_injective_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem of_injective_apply (f : «expr →ₐ[ ] » A R B) (hf : function.injective f) (x : A) :\n    ↑(ofInjective f hf x) = f x :=\n  rfl\n#align of_injective_apply of_injective_apply\n\n",
 "nsmul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print nsmul_mem /-\nprotected theorem nsmul_mem {x : A} (hx : x ∈ S) (n : ℕ) : «expr • » n x ∈ S :=\n  nsmul_mem hx n\n#align nsmul_mem nsmul_mem\n-/\n\n",
 "neg_mem":
 "protected theorem neg_mem {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] (S : Subalgebra R A) {x : A}\n    (hx : x ∈ S) : -x ∈ S :=\n  neg_mem hx\n#align neg_mem neg_mem\n\n",
 "multiset_sum_mem":
 "#print multiset_sum_mem /-\nprotected theorem multiset_sum_mem {m : Multiset A} (h : ∀ x ∈ m, x ∈ S) : m.sum ∈ S :=\n  multiset_sum_mem m h\n#align multiset_sum_mem multiset_sum_mem\n-/\n\n",
 "multiset_prod_mem":
 "#print multiset_prod_mem /-\nprotected theorem multiset_prod_mem {R : Type u} {A : Type v} [CommSemiring R] [CommSemiring A] [Algebra R A]\n    (S : Subalgebra R A) {m : Multiset A} (h : ∀ x ∈ m, x ∈ S) : m.prod ∈ S :=\n  multiset_prod_mem m h\n#align multiset_prod_mem multiset_prod_mem\n-/\n\n",
 "mul_mem_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem mul_mem_sup {S T : Subalgebra R A} {x y : A} (hx : x ∈ S) (hy : y ∈ T) : x * y ∈ «expr ⊔ » S T :=\n  («expr ⊔ » S T).mul_mem (mem_sup_left hx) (mem_sup_right hy)\n#align mul_mem_sup mul_mem_sup\n\n",
 "mul_mem":
 "protected theorem mul_mem {x y : A} (hx : x ∈ S) (hy : y ∈ S) : x * y ∈ S :=\n  mul_mem hx hy\n#align mul_mem mul_mem\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem mem_top {x : A} : x ∈ («expr⊤» : Subalgebra R A) :=\n  Set.mem_univ x\n#align mem_top mem_top\n\n",
 "mem_to_subsemiring":
 "@[simp]\ntheorem mem_to_subsemiring {S : Subalgebra R A} {x} : x ∈ S.to_subsemiring ↔ x ∈ S :=\n  iff.rfl\n#align mem_to_subsemiring mem_to_subsemiring\n\n",
 "mem_to_subring":
 "@[simp]\ntheorem mem_to_subring {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] {S : Subalgebra R A} {x} :\n    x ∈ S.to_subring ↔ x ∈ S :=\n  iff.rfl\n#align mem_to_subring mem_to_subring\n\n",
 "mem_to_submodule":
 "/- TODO: bundle other forgetful maps between algebraic substructures, e.g.\n  `to_subsemiring` and `to_subring` in this file. -/\n@[simp]\ntheorem mem_to_submodule {x} : x ∈ S.to_submodule ↔ x ∈ S :=\n  iff.rfl\n#align mem_to_submodule mem_to_submodule\n\n",
 "mem_to_subalgebra":
 "@[simp]\ntheorem mem_to_subalgebra {p : Submodule R A} {h_one h_mul} {x} : x ∈ p.to_subalgebra h_one h_mul ↔ x ∈ p :=\n  iff.rfl\n#align mem_to_subalgebra mem_to_subalgebra\n\n",
 "mem_sup_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem mem_sup_right {S T : Subalgebra R A} : ∀ {x : A}, x ∈ T → x ∈ «expr ⊔ » S T :=\n  show T ≤ «expr ⊔ » S T from le_sup_right\n#align mem_sup_right mem_sup_right\n\n",
 "mem_sup_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem mem_sup_left {S T : Subalgebra R A} : ∀ {x : A}, x ∈ S → x ∈ «expr ⊔ » S T :=\n  show S ≤ «expr ⊔ » S T from le_sup_left\n#align mem_sup_left mem_sup_left\n\n",
 "mem_subalgebraOfSubsemiring":
 "#print mem_subalgebraOfSubsemiring /-\n@[simp]\ntheorem mem_subalgebraOfSubsemiring {x : R} {S : Subsemiring R} : x ∈ subalgebraOfSubsemiring S ↔ x ∈ S :=\n  iff.rfl\n#align mem_subalgebra_of_subsemiring mem_subalgebraOfSubsemiring\n-/\n\n",
 "mem_subalgebraOfSubring":
 "#print mem_subalgebraOfSubring /-\n@[simp]\ntheorem mem_subalgebraOfSubring {x : R} {S : Subring R} : x ∈ subalgebraOfSubring S ↔ x ∈ S :=\n  iff.rfl\n#align mem_subalgebra_of_subring mem_subalgebraOfSubring\n-/\n\n",
 "mem_range_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem mem_range_self (φ : «expr →ₐ[ ] » A R B) (x : A) : φ x ∈ φ.range :=\n  φ.mem_range.2 ⟨x, rfl⟩\n#align mem_range_self mem_range_self\n\n",
 "mem_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem mem_range (φ : «expr →ₐ[ ] » A R B) {y : B} : y ∈ φ.range ↔ ∃ x, φ x = y :=\n  RingHom.mem_rangeS\n#align mem_range mem_range\n\n",
 "mem_prod":
 "@[simp]\ntheorem mem_prod {S : Subalgebra R A} {S₁ : Subalgebra R B} {x : A × B} : x ∈ prod S S₁ ↔ x.1 ∈ S ∧ x.2 ∈ S₁ :=\n  Set.mem_prod\n#align mem_prod mem_prod\n\n",
 "mem_of_span_eq_top_of_smul_pow_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_of_span_eq_top_of_smul_pow_mem {S : Type _} [CommRing S] [Algebra R S] (S' : Subalgebra R S) (s : Set S)\n    (l : «expr →₀ » s S) (hs : Finsupp.total s S S coe l = 1) (hs' : s ⊆ S') (hl : ∀ i, l i ∈ S') (x : S)\n    (H : ∀ r : s, ∃ n : ℕ, «expr • » (r ^ n : S) x ∈ S') : x ∈ S' :=\n  mem_of_finset_sum_eq_one_of_pow_smul_mem S' l.support coe l hs (fun x => hs' x.2) hl x H\n#align mem_of_span_eq_top_of_smul_pow_mem mem_of_span_eq_top_of_smul_pow_mem\n\n",
 "mem_of_finset_sum_eq_one_of_pow_smul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Suppose we are given `∑ i, lᵢ * sᵢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\n`lᵢ` and `sᵢ`. To check that an `x : S` falls in `S'`, we only need to show that\n`r ^ n • x ∈ M'` for some `n` for each `r : s`. -/\ntheorem mem_of_finset_sum_eq_one_of_pow_smul_mem {S : Type _} [CommRing S] [Algebra R S] (S' : Subalgebra R S)\n    {ι : Type _} (ι' : Finset ι) (s : ι → S) (l : ι → S)\n    (e :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" ι' (l i * s i) =\n        1)\n    (hs : ∀ i, s i ∈ S') (hl : ∀ i, l i ∈ S') (x : S) (H : ∀ i, ∃ n : ℕ, «expr • » (s i ^ n : S) x ∈ S') : x ∈ S' := by\n  classical\n    suffices x ∈ (Algebra.ofId S' S).range.to_submodule\n      by\n      obtain ⟨x, rfl⟩ := this\n      exact x.2\n    choose n hn using H\n    let s' : ι → S' := fun x => ⟨s x, hs x⟩\n    have : Ideal.span («expr '' » s' ι') = «expr⊤» :=\n      by\n      rw [Ideal.eq_top_iff_one, Ideal.span, Finsupp.mem_span_iff_total]\n      refine'\n        ⟨(Finsupp.ofSupportFinite (fun i : ι' => (⟨l i, hl i⟩ : S')) (Set.toFinite _)).map_domain fun i =>\n            ⟨s' i, i, i.2, rfl⟩,\n          S'.to_submodule.injective_subtype _⟩\n      rw [Finsupp.total_mapDomain, Finsupp.total_apply, Finsupp.sum_fintype, map_sum, Submodule.subtype_apply,\n        Subalgebra.coe_one]\n      · exact finset.sum_attach.trans e\n      · exact fun _ => zero_smul _ _\n    let N := ι'.sup n\n    have hs' := Ideal.span_pow_eq_top _ this N\n    apply (Algebra.ofId S' S).range.to_submodule.mem_of_span_top_of_smul_mem _ hs'\n    rintro ⟨_, _, ⟨i, hi, rfl⟩, rfl⟩\n    change «expr • » (s i ^ N) x ∈ _\n    rw [← tsub_add_cancel_of_le (show n i ≤ N from Finset.le_sup hi), pow_add, mul_smul]\n    refine' Submodule.smul_mem _ (⟨_, pow_mem (hs i) _⟩ : S') _\n    exact ⟨⟨_, hn i⟩, rfl⟩\n#align mem_of_finset_sum_eq_one_of_pow_smul_mem mem_of_finset_sum_eq_one_of_pow_smul_mem\n\n",
 "mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem mem_map {S : Subalgebra R A} {f : «expr →ₐ[ ] » A R B} {y : B} : y ∈ map f S ↔ ∃ x ∈ S, f x = y :=\n  Subsemiring.mem_map\n#align mem_map mem_map\n\n",
 "mem_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem mem_infi {ι : Sort _} {S : ι → Subalgebra R A} {x : A} :\n    x ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (S i) ↔\n      ∀ i, x ∈ S i :=\n  by simp only [infᵢ, mem_Inf, Set.forall_range_iff]\n#align mem_infi mem_infi\n\n",
 "mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem mem_inf {S T : Subalgebra R A} {x : A} : x ∈ «expr ⊓ » S T ↔ x ∈ S ∧ x ∈ T :=\n  iff.rfl\n#align mem_inf mem_inf\n\n",
 "mem_equalizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem mem_equalizer (ϕ ψ : «expr →ₐ[ ] » A R B) (x : A) : x ∈ ϕ.equalizer ψ ↔ ϕ x = ψ x :=\n  iff.rfl\n#align mem_equalizer mem_equalizer\n\n",
 "mem_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem mem_comap (S : Subalgebra R B) (f : «expr →ₐ[ ] » A R B) (x : A) : x ∈ S.comap f ↔ f x ∈ S :=\n  iff.rfl\n#align mem_comap mem_comap\n\n",
 "mem_centralizer_iff":
 "theorem mem_centralizer_iff {s : Set A} {z : A} : z ∈ centralizer R s ↔ ∀ g ∈ s, g * z = z * g :=\n  iff.rfl\n#align mem_centralizer_iff mem_centralizer_iff\n\n",
 "mem_center_iff":
 "theorem mem_center_iff {a : A} : a ∈ center R A ↔ ∀ b : A, b * a = a * b :=\n  iff.rfl\n#align mem_center_iff mem_center_iff\n\n",
 "mem_carrier":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Yury Kudryashov\n-/\n@[simp]\ntheorem mem_carrier {s : Subalgebra R A} {x : A} : x ∈ s.carrier ↔ x ∈ s :=\n  iff.rfl\n#align mem_carrier mem_carrier\n\n",
 "mem_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem mem_bot {x : A} : x ∈ («expr⊥» : Subalgebra R A) ↔ x ∈ Set.range (algebraMap R A) :=\n  suffices (ofId R A).range = («expr⊥» : Subalgebra R A)\n    by\n    rw [← this, ← SetLike.mem_coe, AlgHom.coe_range]\n    rfl\n  le_bot_iff.mp fun x hx => Subalgebra.range_le _ ((ofId R A).coe_range ▸ hx)\n#align mem_bot mem_bot\n\n",
 "mem_Inf":
 "theorem mem_Inf {S : Set (Subalgebra R A)} {x : A} : x ∈ infₛ S ↔ ∀ p ∈ S, x ∈ p := by\n  simp only [← SetLike.mem_coe, coe_Inf, Set.mem_interᵢ₂]\n#align mem_Inf mem_Inf\n\n",
 "map_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem map_top (f : «expr →ₐ[ ] » A R B) : («expr⊤» : Subalgebra R A).map f = f.range :=\n  SetLike.coe_injective Set.image_univ\n#align map_top map_top\n\n",
 "map_to_subsemiring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map_to_subsemiring {S : Subalgebra R A} {f : «expr →ₐ[ ] » A R B} :\n    (S.map f).to_subsemiring = S.to_subsemiring.map f.to_ring_hom :=\n  SetLike.coe_injective rfl\n#align map_to_subsemiring map_to_subsemiring\n\n",
 "map_to_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map_to_submodule {S : Subalgebra R A} {f : «expr →ₐ[ ] » A R B} :\n    (S.map f).to_submodule = S.to_submodule.map f.to_linear_map :=\n  SetLike.coe_injective rfl\n#align map_to_submodule map_to_submodule\n\n",
 "map_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_sup (f : «expr →ₐ[ ] » A R B) (S T : Subalgebra R A) :\n    («expr ⊔ » S T).map f = «expr ⊔ » (S.map f) (T.map f) :=\n  (Subalgebra.gc_map_comap f).l_sup\n#align map_sup map_sup\n\n",
 "map_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map_mono {S₁ S₂ : Subalgebra R A} {f : «expr →ₐ[ ] » A R B} : S₁ ≤ S₂ → S₁.map f ≤ S₂.map f :=\n  Set.image_subset f\n#align map_mono map_mono\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map_map (S : Subalgebra R A) (g : «expr →ₐ[ ] » B R C) (f : «expr →ₐ[ ] » A R B) :\n    (S.map f).map g = S.map (g.comp f) :=\n  SetLike.coe_injective <| Set.image_image _ _ _\n#align map_map map_map\n\n",
 "map_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map_le {S : Subalgebra R A} {f : «expr →ₐ[ ] » A R B} {U : Subalgebra R B} : map f S ≤ U ↔ S ≤ comap f U :=\n  Set.image_subset_iff\n#align map_le map_le\n\n",
 "map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map_injective {f : «expr →ₐ[ ] » A R B} (hf : function.injective f) : function.injective (map f) :=\n  fun S₁ S₂ ih => ext <| Set.ext_iff.1 <| Set.image_injective.2 hf <| Set.ext <| SetLike.ext_iff.mp ih\n#align map_injective map_injective\n\n",
 "map_id":
 "@[simp]\ntheorem map_id (S : Subalgebra R A) : S.map (AlgHom.id R A) = S :=\n  SetLike.coe_injective <| Set.image_id _\n#align map_id map_id\n\n",
 "map_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem map_bot (f : «expr →ₐ[ ] » A R B) : («expr⊥» : Subalgebra R A).map f = «expr⊥» :=\n  SetLike.coe_injective <| by simp only [← Set.range_comp, (· ∘ ·), Algebra.coe_bot, Subalgebra.coe_map, f.commutes]\n#align map_bot map_bot\n\n",
 "list_sum_mem":
 "#print list_sum_mem /-\nprotected theorem list_sum_mem {L : List A} (h : ∀ x ∈ L, x ∈ S) : L.sum ∈ S :=\n  list_sum_mem h\n#align list_sum_mem list_sum_mem\n-/\n\n",
 "list_prod_mem":
 "#print list_prod_mem /-\nprotected theorem list_prod_mem {L : List A} (h : ∀ x ∈ L, x ∈ S) : L.prod ∈ S :=\n  list_prod_mem h\n#align list_prod_mem list_prod_mem\n-/\n\n",
 "injective_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem injective_cod_restrict (f : «expr →ₐ[ ] » A R B) (S : Subalgebra R B) (hf : ∀ x, f x ∈ S) :\n    function.injective (f.cod_restrict S hf) ↔ function.injective f :=\n  ⟨fun H x y hxy => H <| Subtype.eq hxy, fun H x y hxy => H (congr_arg Subtype.val hxy : _)⟩\n#align injective_cod_restrict injective_cod_restrict\n\n",
 "infi_to_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem infi_to_submodule {ι : Sort _} (S : ι → Subalgebra R A) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (S i)).to_submodule =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (S i).to_submodule :=\n  SetLike.coe_injective <| by simp\n#align infi_to_submodule infi_to_submodule\n\n",
 "inf_to_subsemiring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem inf_to_subsemiring (S T : Subalgebra R A) :\n    («expr ⊓ » S T).to_subsemiring = «expr ⊓ » S.to_subsemiring T.to_subsemiring :=\n  rfl\n#align inf_to_subsemiring inf_to_subsemiring\n\n",
 "inf_to_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem inf_to_submodule (S T : Subalgebra R A) :\n    («expr ⊓ » S T).to_submodule = «expr ⊓ » S.to_submodule T.to_submodule :=\n  rfl\n#align inf_to_submodule inf_to_submodule\n\n",
 "inclusion_self":
 "@[simp]\ntheorem inclusion_self {S : Subalgebra R A} : inclusion (le_refl S) = AlgHom.id R S :=\n  AlgHom.ext fun x => Subtype.ext rfl\n#align inclusion_self inclusion_self\n\n",
 "inclusion_right":
 "theorem inclusion_right {S T : Subalgebra R A} (h : S ≤ T) (x : T) (m : (x : A) ∈ S) : inclusion h ⟨x, m⟩ = x :=\n  Subtype.ext rfl\n#align inclusion_right inclusion_right\n\n",
 "inclusion_mk":
 "@[simp]\ntheorem inclusion_mk {S T : Subalgebra R A} (h : S ≤ T) (x : A) (hx : x ∈ S) : inclusion h ⟨x, hx⟩ = ⟨x, h hx⟩ :=\n  rfl\n#align inclusion_mk inclusion_mk\n\n",
 "inclusion_injective":
 "theorem inclusion_injective {S T : Subalgebra R A} (h : S ≤ T) : function.injective (inclusion h) := fun _ _ =>\n  Subtype.ext ∘ subtype.mk.inj\n#align inclusion_injective inclusion_injective\n\n",
 "inclusion_inclusion":
 "@[simp]\ntheorem inclusion_inclusion {S T U : Subalgebra R A} (hst : S ≤ T) (htu : T ≤ U) (x : S) :\n    inclusion htu (inclusion hst x) = inclusion (le_trans hst htu) x :=\n  Subtype.ext rfl\n#align inclusion_inclusion inclusion_inclusion\n\n",
 "gc_map_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem gc_map_comap (f : «expr →ₐ[ ] » A R B) : GaloisConnection (map f) (comap f) := fun S U => map_le\n#align gc_map_comap gc_map_comap\n\n",
 "gc":
 "protected theorem gc : GaloisConnection (adjoin R : Set A → Subalgebra R A) coe := fun s S =>\n  ⟨fun H => le_trans (le_trans (Set.subset_union_right _ _) Subsemiring.subset_closure) H, fun H =>\n    show Subsemiring.closure (Set.range (algebraMap R A) ∪ s) ≤ S.to_subsemiring from\n      Subsemiring.closure_le.2 <| Set.union_subset S.range_subset H⟩\n#align gc gc\n\n",
 "ext":
 "@[ext]\ntheorem ext {S T : Subalgebra R A} (h : ∀ x : A, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n#align ext ext\n\n",
 "equiv_of_eq_trans":
 "@[simp]\ntheorem equiv_of_eq_trans (S T U : Subalgebra R A) (hST : S = T) (hTU : T = U) :\n    (equivOfEq S T hST).trans (equivOfEq T U hTU) = equivOfEq S U (trans hST hTU) :=\n  rfl\n#align equiv_of_eq_trans equiv_of_eq_trans\n\n",
 "equiv_of_eq_symm":
 "@[simp]\ntheorem equiv_of_eq_symm (S T : Subalgebra R A) (h : S = T) : (equivOfEq S T h).symm = equivOfEq T S h.symm :=\n  rfl\n#align equiv_of_eq_symm equiv_of_eq_symm\n\n",
 "equiv_of_eq_rfl":
 "@[simp]\ntheorem equiv_of_eq_rfl (S : Subalgebra R A) : equivOfEq S S rfl = AlgEquiv.refl :=\n  by\n  ext\n  rfl\n#align equiv_of_eq_rfl equiv_of_eq_rfl\n\n",
 "eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print eq_top_iff /-\ntheorem eq_top_iff {S : Subalgebra R A} : S = «expr⊤» ↔ ∀ x : A, x ∈ S :=\n  ⟨fun h x => by rw [h] <;> exact mem_top, fun h => by ext x <;> exact ⟨fun _ => mem_top, fun _ => h x⟩⟩\n#align eq_top_iff eq_top_iff\n-/\n\n",
 "copy_eq":
 "theorem copy_eq (S : Subalgebra R A) (s : Set A) (hs : s = ↑S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n#align copy_eq copy_eq\n\n",
 "comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_top (f : «expr →ₐ[ ] » A R B) : («expr⊤» : Subalgebra R B).comap f = «expr⊤» :=\n  eq_top_iff.2 fun x => mem_top\n#align comap_top comap_top\n\n",
 "coe_zero":
 "protected theorem coe_zero : ((0 : S) : A) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_val":
 "-- todo: standardize on the names these morphisms\n-- compare with submodule.subtype\n@[simp]\ntheorem coe_val : (S.val : S → A) = coe :=\n  rfl\n#align coe_val coe_val\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_top : (↑(«expr⊤» : Subalgebra R A) : Set A) = Set.univ :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_to_subsemiring":
 "@[simp]\ntheorem coe_to_subsemiring (S : Subalgebra R A) : (↑S.to_subsemiring : Set A) = S :=\n  rfl\n#align coe_to_subsemiring coe_to_subsemiring\n\n",
 "coe_to_subring":
 "@[simp]\ntheorem coe_to_subring {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] (S : Subalgebra R A) :\n    (↑S.to_subring : Set A) = S :=\n  rfl\n#align coe_to_subring coe_to_subring\n\n",
 "coe_to_submodule":
 "@[simp]\ntheorem coe_to_submodule (S : Subalgebra R A) : (↑S.to_submodule : Set A) = S :=\n  rfl\n#align coe_to_submodule coe_to_submodule\n\n",
 "coe_to_subalgebra":
 "@[simp]\ntheorem coe_to_subalgebra (p : Submodule R A) (h_one h_mul) : (p.to_subalgebra h_one h_mul : Set A) = p :=\n  rfl\n#align coe_to_subalgebra coe_to_subalgebra\n\n",
 "coe_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem coe_supr_of_directed [Nonempty ι] {S : ι → Subalgebra R A} (dir : Directed (· ≤ ·) S) :\n    ↑(supᵢ S) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S i : Set A) :=\n  let K : Subalgebra R A :=\n    { carrier := «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S i)\n      mul_mem' := fun x y hx hy =>\n        let ⟨i, hi⟩ := Set.mem_unionᵢ.1 hx\n        let ⟨j, hj⟩ := Set.mem_unionᵢ.1 hy\n        let ⟨k, hik, hjk⟩ := dir i j\n        Set.mem_unionᵢ.2 ⟨k, Subalgebra.mul_mem (S k) (hik hi) (hjk hj)⟩\n      add_mem' := fun x y hx hy =>\n        let ⟨i, hi⟩ := Set.mem_unionᵢ.1 hx\n        let ⟨j, hj⟩ := Set.mem_unionᵢ.1 hy\n        let ⟨k, hik, hjk⟩ := dir i j\n        Set.mem_unionᵢ.2 ⟨k, Subalgebra.add_mem (S k) (hik hi) (hjk hj)⟩\n      algebra_map_mem' := fun r =>\n        let i := @Nonempty.some ι inferInstance\n        Set.mem_unionᵢ.2 ⟨i, Subalgebra.algebraMap_mem _ _⟩ }\n  have : supᵢ S = K :=\n    le_antisymm (supᵢ_le fun i => Set.subset_unionᵢ (fun i => ↑(S i)) i)\n      (SetLike.coe_subset_coe.1 (Set.unionᵢ_subset fun i => SetLike.coe_subset_coe.2 (le_supᵢ _ _)))\n  this.symm ▸ rfl\n#align coe_supr_of_directed coe_supr_of_directed\n\n",
 "coe_sub":
 "protected theorem coe_sub {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] {S : Subalgebra R A} (x y : S) :\n    (↑(x - y) : A) = ↑x - ↑y :=\n  rfl\n#align coe_sub coe_sub\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, norm_cast]\ntheorem coe_smul [Semiring R'] [SMul R' R] [Module R' A] [IsScalarTower R' R A] (r : R') (x : S) :\n    (↑(«expr • » r x) : A) = «expr • » r ↑x :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem coe_range (φ : «expr →ₐ[ ] » A R B) : (φ.range : Set B) = Set.range φ :=\n  by\n  ext\n  rw [SetLike.mem_coe, mem_range]\n  rfl\n#align coe_range coe_range\n\n",
 "coe_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem coe_prod : (prod S S₁ : Set (A × B)) = finset.product S S₁ :=\n  rfl\n#align coe_prod coe_prod\n\n",
 "coe_pow":
 "protected theorem coe_pow (x : S) (n : ℕ) : (↑(x ^ n) : A) = ↑x ^ n :=\n  SubmonoidClass.coe_pow x n\n#align coe_pow coe_pow\n\n",
 "coe_one":
 "protected theorem coe_one : ((1 : S) : A) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_neg":
 "protected theorem coe_neg {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] {S : Subalgebra R A} (x : S) :\n    (↑(-x) : A) = -↑x :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_nat_mem":
 "#print coe_nat_mem /-\nprotected theorem coe_nat_mem (n : ℕ) : (n : A) ∈ S :=\n  coe_nat_mem S n\n#align coe_nat_mem coe_nat_mem\n-/\n\n",
 "coe_mul":
 "protected theorem coe_mul (x y : S) : (↑(x * y) : A) = ↑x * ↑y :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem coe_map (S : Subalgebra R A) (f : «expr →ₐ[ ] » A R B) : (S.map f : Set B) = «expr '' » f S :=\n  rfl\n#align coe_map coe_map\n\n",
 "coe_int_mem":
 "#print coe_int_mem /-\nprotected theorem coe_int_mem {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] (S : Subalgebra R A)\n    (n : ℤ) : (n : A) ∈ S :=\n  coe_int_mem S n\n#align coe_int_mem coe_int_mem\n-/\n\n",
 "coe_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast]\ntheorem coe_infi {ι : Sort _} {S : ι → Subalgebra R A} :\n    (↑(«expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (S i)) : Set A) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (S i) :=\n  by simp [infᵢ]\n#align coe_infi coe_infi\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, norm_cast]\ntheorem coe_inf (S T : Subalgebra R A) : (↑(«expr ⊓ » S T) : Set A) = S ∩ T :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_inclusion":
 "@[simp]\ntheorem coe_inclusion {S T : Subalgebra R A} (h : S ≤ T) (s : S) : (inclusion h s : A) = s :=\n  rfl\n#align coe_inclusion coe_inclusion\n\n",
 "coe_eq_zero":
 "protected theorem coe_eq_zero {x : S} : (x : A) = 0 ↔ x = 0 :=\n  ZeroMemClass.coe_eq_zero\n#align coe_eq_zero coe_eq_zero\n\n",
 "coe_eq_one":
 "protected theorem coe_eq_one {x : S} : (x : A) = 1 ↔ x = 1 :=\n  OneMemClass.coe_eq_one\n#align coe_eq_one coe_eq_one\n\n",
 "coe_copy":
 "@[simp]\ntheorem coe_copy (S : Subalgebra R A) (s : Set A) (hs : s = ↑S) : (S.copy s hs : Set A) = s :=\n  rfl\n#align coe_copy coe_copy\n\n",
 "coe_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp, norm_cast]\ntheorem coe_comap (S : Subalgebra R B) (f : «expr →ₐ[ ] » A R B) : (S.comap f : Set A) = «expr ⁻¹' » f (S : Set B) :=\n  rfl\n#align coe_comap coe_comap\n\n",
 "coe_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem coe_cod_restrict (f : «expr →ₐ[ ] » A R B) (S : Subalgebra R B) (hf : ∀ x, f x ∈ S) (x : A) :\n    ↑(f.cod_restrict S hf x) = f x :=\n  rfl\n#align coe_cod_restrict coe_cod_restrict\n\n",
 "coe_centralizer":
 "@[simp, norm_cast]\ntheorem coe_centralizer (s : Set A) : (centralizer R s : Set A) = s.centralizer :=\n  rfl\n#align coe_centralizer coe_centralizer\n\n",
 "coe_center":
 "theorem coe_center : (center R A : Set A) = Set.center A :=\n  rfl\n#align coe_center coe_center\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem coe_bot : ((«expr⊥» : Subalgebra R A) : Set A) = Set.range (algebraMap R A) := by\n  simp [Set.ext_iff, Algebra.mem_bot]\n#align coe_bot coe_bot\n\n",
 "coe_algebra_map":
 "@[simp, norm_cast]\ntheorem coe_algebra_map [CommSemiring R'] [SMul R' R] [Algebra R' A] [IsScalarTower R' R A] (r : R') :\n    ↑(algebraMap R' S r) = algebraMap R' A r :=\n  rfl\n#align coe_algebra_map coe_algebra_map\n\n",
 "coe_add":
 "protected theorem coe_add (x y : S) : (↑(x + y) : A) = ↑x + ↑y :=\n  rfl\n#align coe_add coe_add\n\n",
 "coe_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast]\ntheorem coe_Inf (S : Set (Subalgebra R A)) :\n    (↑(infₛ S) : Set A) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑s :=\n  infₛ_image\n#align coe_Inf coe_Inf\n\n",
 "centralizer_univ":
 "@[simp]\ntheorem centralizer_univ : centralizer R Set.univ = center R A :=\n  SetLike.ext' (Set.centralizer_univ A)\n#align centralizer_univ centralizer_univ\n\n",
 "centralizer_le":
 "theorem centralizer_le (s t : Set A) (h : s ⊆ t) : centralizer R t ≤ centralizer R s :=\n  Set.centralizer_subset h\n#align centralizer_le centralizer_le\n\n",
 "center_to_subsemiring":
 "@[simp]\ntheorem center_to_subsemiring : (center R A).to_subsemiring = Subsemiring.center A :=\n  rfl\n#align center_to_subsemiring center_to_subsemiring\n\n",
 "center_to_subring":
 "@[simp]\ntheorem center_to_subring (R A : Type _) [CommRing R] [Ring A] [Algebra R A] :\n    (center R A).to_subring = Subring.center A :=\n  rfl\n#align center_to_subring center_to_subring\n\n",
 "center_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem center_eq_top (A : Type _) [CommSemiring A] [Algebra R A] : center R A = «expr⊤» :=\n  SetLike.coe_injective (Set.center_eq_univ A)\n#align center_eq_top center_eq_top\n\n",
 "bijective_algebra_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem bijective_algebra_map_iff {R A : Type _} [Field R] [Semiring A] [Nontrivial A] [Algebra R A] :\n    function.bijective (algebraMap R A) ↔ («expr⊤» : Subalgebra R A) = «expr⊥» :=\n  ⟨fun h => surjective_algebraMap_iff.1 h.2, fun h => ⟨(algebraMap R A).injective, surjective_algebraMap_iff.2 h⟩⟩\n#align bijective_algebra_map_iff bijective_algebra_map_iff\n\n",
 "algebra_map_mem_centralizer":
 "#print Set.algebraMap_mem_centralizer /-\n@[simp]\ntheorem Set.algebraMap_mem_centralizer {s : Set A} (r : R) : algebraMap R A r ∈ s.centralizer := fun a h =>\n  (Algebra.commutes _ _).symm\n#align set.algebra_map_mem_centralizer Set.algebraMap_mem_centralizer\n-/\n\n",
 "algebra_map_mem_center":
 "#print Set.algebraMap_mem_center /-\ntheorem Set.algebraMap_mem_center (r : R) : algebraMap R A r ∈ Set.center A := by\n  simp [Algebra.commutes, Set.mem_center_iff]\n#align set.algebra_map_mem_center Set.algebraMap_mem_center\n-/\n\n",
 "algebra_map_mem":
 "theorem algebra_map_mem (r : R) : algebraMap R A r ∈ S :=\n  S.algebra_map_mem' r\n#align algebra_map_mem algebra_map_mem\n\n",
 "algebra_map_eq":
 "theorem algebra_map_eq {R A : Type _} [CommSemiring R] [CommSemiring A] [Semiring α] [Algebra R A] [Algebra A α]\n    (S : Subalgebra R A) : algebraMap S α = (algebraMap A α).comp S.val :=\n  rfl\n#align algebra_map_eq algebra_map_eq\n\n",
 "add_mem":
 "protected theorem add_mem {x y : A} (hx : x ∈ S) (hy : y ∈ S) : x + y ∈ S :=\n  add_mem hx hy\n#align add_mem add_mem\n\n",
 "Inf_to_subsemiring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem Inf_to_subsemiring (S : Set (Subalgebra R A)) :\n    (infₛ S).to_subsemiring = infₛ («expr '' » subalgebra.to_subsemiring S) :=\n  SetLike.coe_injective <| by simp\n#align Inf_to_subsemiring Inf_to_subsemiring\n\n",
 "Inf_to_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem Inf_to_submodule (S : Set (Subalgebra R A)) :\n    (infₛ S).to_submodule = infₛ («expr '' » Subalgebra.toSubmodule S) :=\n  SetLike.coe_injective <| by simp\n#align Inf_to_submodule Inf_to_submodule\n\n"}