{"zsmul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprotected theorem zsmul_mem {R : Type u} {A : Type v} [CommRing R] [Ring A] [algebra R A] (S : subalgebra R A) {x : A}\n    (hx : x ∈ S) (n : ℤ) : «expr • » n x ∈ S :=\n  zsmul_mem hx n\n#align zsmul_mem zsmul_mem\n\n",
 "zero_mem":
 "protected theorem zero_mem : (0 : A) ∈ S :=\n  zero_mem S\n#align zero_mem zero_mem\n\n",
 "val_comp_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem val_comp_cod_restrict (f : «expr →ₐ[ ] » A R B) (S : subalgebra R B) (hf : ∀ x, f x ∈ S) :\n    S.val.comp (f.cod_restrict S hf) = f :=\n  alg_hom.ext fun _ => rfl\n#align val_comp_cod_restrict val_comp_cod_restrict\n\n",
 "val_apply":
 "theorem val_apply (x : S) : S.val x = (x : A) :=\n  rfl\n#align val_apply val_apply\n\n",
 "top_to_subsemiring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_to_subsemiring : («expr⊤» : subalgebra R A).to_subsemiring = «expr⊤» :=\n  rfl\n#align top_to_subsemiring top_to_subsemiring\n\n",
 "top_to_subring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_to_subring {R A : Type _} [CommRing R] [Ring A] [algebra R A] :\n    («expr⊤» : subalgebra R A).to_subring = «expr⊤» :=\n  rfl\n#align top_to_subring top_to_subring\n\n",
 "top_to_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_to_submodule : («expr⊤» : subalgebra R A).to_submodule = «expr⊤» :=\n  rfl\n#align top_to_submodule top_to_submodule\n\n",
 "to_subsemiring_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem to_subsemiring_subtype : S.to_subsemiring.subtype = (S.val : «expr →+* » S A) :=\n  rfl\n#align to_subsemiring_subtype to_subsemiring_subtype\n\n",
 "to_subsemiring_injective":
 "theorem to_subsemiring_injective : function.injective (to_subsemiring : subalgebra R A → subsemiring A) := fun S T h =>\n  ext fun x => by rw [← mem_to_subsemiring, ← mem_to_subsemiring, h]\n#align to_subsemiring_injective to_subsemiring_injective\n\n",
 "to_subsemiring_inj":
 "theorem to_subsemiring_inj {S U : subalgebra R A} : S.to_subsemiring = U.to_subsemiring ↔ S = U :=\n  to_subsemiring_injective.eq_iff\n#align to_subsemiring_inj to_subsemiring_inj\n\n",
 "to_subsemiring_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem to_subsemiring_eq_top {S : subalgebra R A} : S.to_subsemiring = «expr⊤» ↔ S = «expr⊤» :=\n  subalgebra.to_subsemiring_injective.eq_iff' top_to_subsemiring\n#align to_subsemiring_eq_top to_subsemiring_eq_top\n\n",
 "to_subring_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem to_subring_subtype {R A : Type _} [CommRing R] [Ring A] [algebra R A] (S : subalgebra R A) :\n    S.to_subring.subtype = (S.val : «expr →+* » S A) :=\n  rfl\n#align to_subring_subtype to_subring_subtype\n\n",
 "to_subring_injective":
 "theorem to_subring_injective {R : Type u} {A : Type v} [CommRing R] [Ring A] [algebra R A] :\n    function.injective (to_subring : subalgebra R A → subring A) := fun S T h =>\n  ext fun x => by rw [← mem_to_subring, ← mem_to_subring, h]\n#align to_subring_injective to_subring_injective\n\n",
 "to_subring_inj":
 "theorem to_subring_inj {R : Type u} {A : Type v} [CommRing R] [Ring A] [algebra R A] {S U : subalgebra R A} :\n    S.to_subring = U.to_subring ↔ S = U :=\n  to_subring_injective.eq_iff\n#align to_subring_inj to_subring_inj\n\n",
 "to_subring_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem to_subring_eq_top {R A : Type _} [CommRing R] [Ring A] [algebra R A] {S : subalgebra R A} :\n    S.to_subring = «expr⊤» ↔ S = «expr⊤» :=\n  subalgebra.to_subring_injective.eq_iff' top_to_subring\n#align to_subring_eq_top to_subring_eq_top\n\n",
 "to_submodule_to_subalgebra":
 "@[simp]\ntheorem _root_.subalgebra.to_submodule_to_subalgebra (S : subalgebra R A) :\n    (S.to_submodule.to_subalgebra S.one_mem fun _ _ => S.mul_mem) = S :=\n  SetLike.coe_injective rfl\n#align subalgebra.to_submodule_to_subalgebra subalgebra.to_submodule_to_subalgebra\n\n",
 "to_submodule_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem to_submodule_eq_top {S : subalgebra R A} : S.to_submodule = «expr⊤» ↔ S = «expr⊤» :=\n  subalgebra.to_submodule.injective.eq_iff' top_to_submodule\n#align to_submodule_eq_top to_submodule_eq_top\n\n",
 "to_submodule_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem to_submodule_bot : («expr⊥» : subalgebra R A).to_submodule = «expr ∙ » R 1 :=\n  by\n  ext x\n  simp [mem_bot, -Set.singleton_one, submodule.mem_span_singleton, algebra.smul_def]\n#align to_submodule_bot to_submodule_bot\n\n",
 "to_subalgebra_to_submodule":
 "@[simp]\ntheorem to_subalgebra_to_submodule (p : submodule R A) (h_one h_mul) : (p.to_subalgebra h_one h_mul).to_submodule = p :=\n  SetLike.coe_injective rfl\n#align to_subalgebra_to_submodule to_subalgebra_to_submodule\n\n",
 "to_subalgebra_mk":
 "@[simp]\ntheorem to_subalgebra_mk (s : set A) (h0 hadd hsmul h1 hmul) :\n    (submodule.mk s hadd h0 hsmul : submodule R A).to_subalgebra h1 hmul =\n      subalgebra.mk s (@hmul) h1 (@hadd) h0 fun r =>\n        by\n        rw [algebra.algebra_map_eq_smul_one]\n        exact hsmul r h1 :=\n  rfl\n#align to_subalgebra_mk to_subalgebra_mk\n\n",
 "surjective_algebra_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem surjective_algebra_map_iff : function.surjective (algebra_map R A) ↔ («expr⊤» : subalgebra R A) = «expr⊥» :=\n  ⟨fun h =>\n    eq_bot_iff.2 fun y _ =>\n      let ⟨x, hx⟩ := h y\n      hx ▸ subalgebra.algebra_map_mem _ _,\n    fun h y => algebra.mem_bot.1 <| eq_bot_iff.1 h (algebra.mem_top : y ∈ _)⟩\n#align surjective_algebra_map_iff surjective_algebra_map_iff\n\n",
 "supr_lift_of_mem":
 "theorem supr_lift_of_mem {i : ι} (x : T) (hx : (x : A) ∈ K i) : supr_lift K dir f hf T hT x = f i ⟨x, hx⟩ := by\n  subst hT <;> exact Set.unionᵢLift_of_mem x hx\n#align supr_lift_of_mem supr_lift_of_mem\n\n",
 "supr_lift_mk":
 "@[simp]\ntheorem supr_lift_mk {i : ι} (x : K i) (hx : (x : A) ∈ T) : supr_lift K dir f hf T hT ⟨x, hx⟩ = f i x := by\n  subst hT <;> exact Set.unionᵢLift_mk x hx\n#align supr_lift_mk supr_lift_mk\n\n",
 "supr_lift_inclusion":
 "@[simp]\ntheorem supr_lift_inclusion {i : ι} (x : K i) (h : K i ≤ T) : supr_lift K dir f hf T hT (inclusion h x) = f i x := by\n  subst T <;> exact Set.unionᵢLift_inclusion _ _\n#align supr_lift_inclusion supr_lift_inclusion\n\n",
 "supr_lift_comp_inclusion":
 "@[simp]\ntheorem supr_lift_comp_inclusion {i : ι} (h : K i ≤ T) : (supr_lift K dir f hf T hT).comp (inclusion h) = f i := by\n  ext <;> simp\n#align supr_lift_comp_inclusion supr_lift_comp_inclusion\n\n",
 "sum_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\nprotected theorem sum_mem {ι : Type w} {t : Finset ι} {f : ι → A} (h : ∀ x ∈ t, f x ∈ S) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f x) ∈ S :=\n  sum_mem h\n#align sum_mem sum_mem\n\n",
 "sub_mem":
 "protected theorem sub_mem {R : Type u} {A : Type v} [CommRing R] [Ring A] [algebra R A] (S : subalgebra R A) {x y : A}\n    (hx : x ∈ S) (hy : y ∈ S) : x - y ∈ S :=\n  sub_mem hx hy\n#align sub_mem sub_mem\n\n",
 "srange_le":
 "theorem srange_le : (algebra_map R A).srange ≤ S.to_subsemiring := fun x ⟨r, hr⟩ => hr ▸ S.algebra_map_mem r\n#align srange_le srange_le\n\n",
 "srange_algebra_map":
 "@[simp]\ntheorem srange_algebra_map {R A : Type _} [CommSemiring R] [CommSemiring A] [algebra R A] (S : subalgebra R A) :\n    (algebra_map S A).srange = S.to_subsemiring := by\n  rw [algebra_map_eq, algebra.id.map_eq_id, RingHom.id_comp, ← to_subsemiring_subtype, subsemiring.srange_subtype]\n#align srange_algebra_map srange_algebra_map\n\n",
 "smul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_mem /-\ntheorem smul_mem {x : A} (hx : x ∈ S) (r : R) : «expr • » r x ∈ S :=\n  (algebra.smul_def r x).symm ▸ mul_mem (S.algebra_map_mem r) hx\n#align smul_mem smul_mem\n-/\n\n",
 "smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_def [SMul A α] {S : subalgebra R A} (g : S) (m : α) : «expr • » g m = «expr • » (g : A) m :=\n  rfl\n#align smul_def smul_def\n\n",
 "range_val":
 "theorem range_val : S.val.range = S :=\n  ext <| Set.ext_iff.1 <| S.val.coe_range.trans Subtype.range_val\n#align range_val range_val\n\n",
 "range_top_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_top_iff_surjective (f : «expr →ₐ[ ] » A R B) :\n    f.range = («expr⊤» : subalgebra R B) ↔ function.surjective f :=\n  algebra.eq_top_iff\n#align range_top_iff_surjective range_top_iff_surjective\n\n",
 "range_subset":
 "theorem range_subset : Set.range (algebra_map R A) ⊆ S := fun x ⟨r, hr⟩ => hr ▸ S.algebra_map_mem r\n#align range_subset range_subset\n\n",
 "range_le":
 "theorem range_le : Set.range (algebra_map R A) ≤ S :=\n  S.range_subset\n#align range_le range_le\n\n",
 "range_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem range_id : (alg_hom.id R A).range = «expr⊤» :=\n  SetLike.coe_injective Set.range_id\n#align range_id range_id\n\n",
 "range_comp_le_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem range_comp_le_range (f : «expr →ₐ[ ] » A R B) (g : «expr →ₐ[ ] » B R C) : (g.comp f).range ≤ g.range :=\n  SetLike.coe_mono (Set.range_comp_subset_range f g)\n#align range_comp_le_range range_comp_le_range\n\n",
 "range_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem range_comp (f : «expr →ₐ[ ] » A R B) (g : «expr →ₐ[ ] » B R C) : (g.comp f).range = f.range.map g :=\n  SetLike.coe_injective (Set.range_comp g f)\n#align range_comp range_comp\n\n",
 "range_algebra_map":
 "@[simp]\ntheorem range_algebra_map {R A : Type _} [CommRing R] [CommRing A] [algebra R A] (S : subalgebra R A) :\n    (algebra_map S A).range = S.to_subring := by\n  rw [algebra_map_eq, algebra.id.map_eq_id, RingHom.id_comp, ← to_subring_subtype, subring.range_subtype]\n#align range_algebra_map range_algebra_map\n\n",
 "prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem prod_top : (prod («expr⊤») («expr⊤») : subalgebra R (A × B)) = «expr⊤» := by ext <;> simp\n#align prod_top prod_top\n\n",
 "prod_to_submodule":
 "theorem prod_to_submodule : (S.prod S₁).to_submodule = S.to_submodule.prod S₁.to_submodule :=\n  rfl\n#align prod_to_submodule prod_to_submodule\n\n",
 "prod_mono":
 "theorem prod_mono {S T : subalgebra R A} {S₁ T₁ : subalgebra R B} : S ≤ T → S₁ ≤ T₁ → prod S S₁ ≤ prod T T₁ :=\n  Set.prod_mono\n#align prod_mono prod_mono\n\n",
 "prod_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\nprotected theorem prod_mem {R : Type u} {A : Type v} [CommSemiring R] [CommSemiring A] [algebra R A]\n    (S : subalgebra R A) {ι : Type w} {t : Finset ι} {f : ι → A} (h : ∀ x ∈ t, f x ∈ S) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f x) ∈ S :=\n  prod_mem h\n#align prod_mem prod_mem\n\n",
 "prod_inf_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem prod_inf_prod {S T : subalgebra R A} {S₁ T₁ : subalgebra R B} :\n    «expr ⊓ » (S.prod S₁) (T.prod T₁) = («expr ⊓ » S T).prod («expr ⊓ » S₁ T₁) :=\n  SetLike.coe_injective Set.prod_inter_prod\n#align prod_inf_prod prod_inf_prod\n\n",
 "pow_mem":
 "#print pow_mem /-\nprotected theorem pow_mem {x : A} (hx : x ∈ S) (n : ℕ) : x ^ n ∈ S :=\n  pow_mem hx n\n#align pow_mem pow_mem\n-/\n\n",
 "one_mem":
 "protected theorem one_mem : (1 : A) ∈ S :=\n  one_mem S\n#align one_mem one_mem\n\n",
 "of_left_inverse_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem of_left_inverse_symm_apply {g : B → A} {f : «expr →ₐ[ ] » A R B} (h : function.left_inverse g f) (x : f.range) :\n    (of_left_inverse h).symm x = g x :=\n  rfl\n#align of_left_inverse_symm_apply of_left_inverse_symm_apply\n\n",
 "of_left_inverse_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem of_left_inverse_apply {g : B → A} {f : «expr →ₐ[ ] » A R B} (h : function.left_inverse g f) (x : A) :\n    ↑(of_left_inverse h x) = f x :=\n  rfl\n#align of_left_inverse_apply of_left_inverse_apply\n\n",
 "of_injective_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem of_injective_apply (f : «expr →ₐ[ ] » A R B) (hf : function.injective f) (x : A) :\n    ↑(of_injective f hf x) = f x :=\n  rfl\n#align of_injective_apply of_injective_apply\n\n",
 "nsmul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprotected theorem nsmul_mem {x : A} (hx : x ∈ S) (n : ℕ) : «expr • » n x ∈ S :=\n  nsmul_mem hx n\n#align nsmul_mem nsmul_mem\n\n",
 "neg_mem":
 "protected theorem neg_mem {R : Type u} {A : Type v} [CommRing R] [Ring A] [algebra R A] (S : subalgebra R A) {x : A}\n    (hx : x ∈ S) : -x ∈ S :=\n  neg_mem hx\n#align neg_mem neg_mem\n\n",
 "multiset_sum_mem":
 "protected theorem multiset_sum_mem {m : Multiset A} (h : ∀ x ∈ m, x ∈ S) : m.sum ∈ S :=\n  multiset_sum_mem m h\n#align multiset_sum_mem multiset_sum_mem\n\n",
 "multiset_prod_mem":
 "protected theorem multiset_prod_mem {R : Type u} {A : Type v} [CommSemiring R] [CommSemiring A] [algebra R A]\n    (S : subalgebra R A) {m : Multiset A} (h : ∀ x ∈ m, x ∈ S) : m.prod ∈ S :=\n  multiset_prod_mem m h\n#align multiset_prod_mem multiset_prod_mem\n\n",
 "mul_mem_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem mul_mem_sup {S T : subalgebra R A} {x y : A} (hx : x ∈ S) (hy : y ∈ T) : x * y ∈ «expr ⊔ » S T :=\n  («expr ⊔ » S T).mul_mem (mem_sup_left hx) (mem_sup_right hy)\n#align mul_mem_sup mul_mem_sup\n\n",
 "mul_mem":
 "protected theorem mul_mem {x y : A} (hx : x ∈ S) (hy : y ∈ S) : x * y ∈ S :=\n  mul_mem hx hy\n#align mul_mem mul_mem\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem mem_top {x : A} : x ∈ («expr⊤» : subalgebra R A) :=\n  Set.mem_univ x\n#align mem_top mem_top\n\n",
 "mem_to_subsemiring":
 "@[simp]\ntheorem mem_to_subsemiring {S : subalgebra R A} {x} : x ∈ S.to_subsemiring ↔ x ∈ S :=\n  iff.rfl\n#align mem_to_subsemiring mem_to_subsemiring\n\n",
 "mem_to_subring":
 "@[simp]\ntheorem mem_to_subring {R : Type u} {A : Type v} [CommRing R] [Ring A] [algebra R A] {S : subalgebra R A} {x} :\n    x ∈ S.to_subring ↔ x ∈ S :=\n  iff.rfl\n#align mem_to_subring mem_to_subring\n\n",
 "mem_to_submodule":
 "/- TODO: bundle other forgetful maps between algebraic substructures, e.g.\n  `to_subsemiring` and `to_subring` in this file. -/\n@[simp]\ntheorem mem_to_submodule {x} : x ∈ S.to_submodule ↔ x ∈ S :=\n  iff.rfl\n#align mem_to_submodule mem_to_submodule\n\n",
 "mem_to_subalgebra":
 "@[simp]\ntheorem mem_to_subalgebra {p : submodule R A} {h_one h_mul} {x} : x ∈ p.to_subalgebra h_one h_mul ↔ x ∈ p :=\n  iff.rfl\n#align mem_to_subalgebra mem_to_subalgebra\n\n",
 "mem_sup_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem mem_sup_right {S T : subalgebra R A} : ∀ {x : A}, x ∈ T → x ∈ «expr ⊔ » S T :=\n  show T ≤ «expr ⊔ » S T from le_sup_right\n#align mem_sup_right mem_sup_right\n\n",
 "mem_sup_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem mem_sup_left {S T : subalgebra R A} : ∀ {x : A}, x ∈ S → x ∈ «expr ⊔ » S T :=\n  show S ≤ «expr ⊔ » S T from le_sup_left\n#align mem_sup_left mem_sup_left\n\n",
 "mem_subalgebra_of_subsemiring":
 "@[simp]\ntheorem mem_subalgebra_of_subsemiring {x : R} {S : subsemiring R} : x ∈ subalgebra_of_subsemiring S ↔ x ∈ S :=\n  iff.rfl\n#align mem_subalgebra_of_subsemiring mem_subalgebra_of_subsemiring\n\n",
 "mem_subalgebra_of_subring":
 "@[simp]\ntheorem mem_subalgebra_of_subring {x : R} {S : subring R} : x ∈ subalgebra_of_subring S ↔ x ∈ S :=\n  iff.rfl\n#align mem_subalgebra_of_subring mem_subalgebra_of_subring\n\n",
 "mem_range_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem mem_range_self (φ : «expr →ₐ[ ] » A R B) (x : A) : φ x ∈ φ.range :=\n  φ.mem_range.2 ⟨x, rfl⟩\n#align mem_range_self mem_range_self\n\n",
 "mem_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem mem_range (φ : «expr →ₐ[ ] » A R B) {y : B} : y ∈ φ.range ↔ ∃ x, φ x = y :=\n  ring_hom.mem_srange\n#align mem_range mem_range\n\n",
 "mem_prod":
 "@[simp]\ntheorem mem_prod {S : subalgebra R A} {S₁ : subalgebra R B} {x : A × B} : x ∈ prod S S₁ ↔ x.1 ∈ S ∧ x.2 ∈ S₁ :=\n  Set.mem_prod\n#align mem_prod mem_prod\n\n",
 "mem_of_span_eq_top_of_smul_pow_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_of_span_eq_top_of_smul_pow_mem {S : Type _} [CommRing S] [algebra R S] (S' : subalgebra R S) (s : set S)\n    (l : «expr →₀ » s S) (hs : finsupp.total s S S coe l = 1) (hs' : s ⊆ S') (hl : ∀ i, l i ∈ S') (x : S)\n    (H : ∀ r : s, ∃ n : ℕ, «expr • » (r ^ n : S) x ∈ S') : x ∈ S' :=\n  mem_of_finset_sum_eq_one_of_pow_smul_mem S' l.support coe l hs (fun x => hs' x.2) hl x H\n#align mem_of_span_eq_top_of_smul_pow_mem mem_of_span_eq_top_of_smul_pow_mem\n\n",
 "mem_of_finset_sum_eq_one_of_pow_smul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Suppose we are given `∑ i, lᵢ * sᵢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\n`lᵢ` and `sᵢ`. To check that an `x : S` falls in `S'`, we only need to show that\n`r ^ n • x ∈ M'` for some `n` for each `r : s`. -/\ntheorem mem_of_finset_sum_eq_one_of_pow_smul_mem {S : Type _} [CommRing S] [algebra R S] (S' : subalgebra R S)\n    {ι : Type _} (ι' : Finset ι) (s : ι → S) (l : ι → S)\n    (e :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" ι' (l i * s i) =\n        1)\n    (hs : ∀ i, s i ∈ S') (hl : ∀ i, l i ∈ S') (x : S) (H : ∀ i, ∃ n : ℕ, «expr • » (s i ^ n : S) x ∈ S') : x ∈ S' := by\n  classical\n    suffices x ∈ (algebra.of_id S' S).range.to_submodule\n      by\n      obtain ⟨x, rfl⟩ := this\n      exact x.2\n    choose n hn using H\n    let s' : ι → S' := fun x => ⟨s x, hs x⟩\n    have : ideal.span («expr '' » s' ι') = «expr⊤» :=\n      by\n      rw [ideal.eq_top_iff_one, ideal.span, finsupp.mem_span_iff_total]\n      refine'\n        ⟨(finsupp.of_support_finite (fun i : ι' => (⟨l i, hl i⟩ : S')) (set.to_finite _)).map_domain fun i =>\n            ⟨s' i, i, i.2, rfl⟩,\n          S'.to_submodule.injective_subtype _⟩\n      rw [finsupp.total_map_domain, finsupp.total_apply, finsupp.sum_fintype, map_sum, submodule.subtype_apply,\n        subalgebra.coe_one]\n      · exact finset.sum_attach.trans e\n      · exact fun _ => zero_smul _ _\n    let N := ι'.sup n\n    have hs' := ideal.span_pow_eq_top _ this N\n    apply (algebra.of_id S' S).range.to_submodule.mem_of_span_top_of_smul_mem _ hs'\n    rintro ⟨_, _, ⟨i, hi, rfl⟩, rfl⟩\n    change «expr • » (s i ^ N) x ∈ _\n    rw [← tsub_add_cancel_of_le (show n i ≤ N from finset.le_sup hi), pow_add, mul_smul]\n    refine' submodule.smul_mem _ (⟨_, pow_mem (hs i) _⟩ : S') _\n    exact ⟨⟨_, hn i⟩, rfl⟩\n#align mem_of_finset_sum_eq_one_of_pow_smul_mem mem_of_finset_sum_eq_one_of_pow_smul_mem\n\n",
 "mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem mem_map {S : subalgebra R A} {f : «expr →ₐ[ ] » A R B} {y : B} : y ∈ map f S ↔ ∃ x ∈ S, f x = y :=\n  subsemiring.mem_map\n#align mem_map mem_map\n\n",
 "mem_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem mem_infi {ι : Sort _} {S : ι → subalgebra R A} {x : A} :\n    x ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (S i) ↔\n      ∀ i, x ∈ S i :=\n  by simp only [infᵢ, mem_Inf, Set.forall_range_iff]\n#align mem_infi mem_infi\n\n",
 "mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem mem_inf {S T : subalgebra R A} {x : A} : x ∈ «expr ⊓ » S T ↔ x ∈ S ∧ x ∈ T :=\n  iff.rfl\n#align mem_inf mem_inf\n\n",
 "mem_equalizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem mem_equalizer (ϕ ψ : «expr →ₐ[ ] » A R B) (x : A) : x ∈ ϕ.equalizer ψ ↔ ϕ x = ψ x :=\n  iff.rfl\n#align mem_equalizer mem_equalizer\n\n",
 "mem_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem mem_comap (S : subalgebra R B) (f : «expr →ₐ[ ] » A R B) (x : A) : x ∈ S.comap f ↔ f x ∈ S :=\n  iff.rfl\n#align mem_comap mem_comap\n\n",
 "mem_centralizer_iff":
 "theorem mem_centralizer_iff {s : set A} {z : A} : z ∈ centralizer R s ↔ ∀ g ∈ s, g * z = z * g :=\n  iff.rfl\n#align mem_centralizer_iff mem_centralizer_iff\n\n",
 "mem_center_iff":
 "theorem mem_center_iff {a : A} : a ∈ center R A ↔ ∀ b : A, b * a = a * b :=\n  iff.rfl\n#align mem_center_iff mem_center_iff\n\n",
 "mem_carrier":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Yury Kudryashov\n-/\n@[simp]\ntheorem mem_carrier {s : subalgebra R A} {x : A} : x ∈ s.carrier ↔ x ∈ s :=\n  iff.rfl\n#align mem_carrier mem_carrier\n\n",
 "mem_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem mem_bot {x : A} : x ∈ («expr⊥» : subalgebra R A) ↔ x ∈ Set.range (algebra_map R A) :=\n  suffices (of_id R A).range = («expr⊥» : subalgebra R A)\n    by\n    rw [← this, ← SetLike.mem_coe, alg_hom.coe_range]\n    rfl\n  le_bot_iff.mp fun x hx => subalgebra.range_le _ ((of_id R A).coe_range ▸ hx)\n#align mem_bot mem_bot\n\n",
 "mem_Inf":
 "theorem mem_Inf {S : set (subalgebra R A)} {x : A} : x ∈ infₛ S ↔ ∀ p ∈ S, x ∈ p := by\n  simp only [← SetLike.mem_coe, coe_Inf, Set.mem_interᵢ₂]\n#align mem_Inf mem_Inf\n\n",
 "map_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem map_top (f : «expr →ₐ[ ] » A R B) : («expr⊤» : subalgebra R A).map f = f.range :=\n  SetLike.coe_injective Set.image_univ\n#align map_top map_top\n\n",
 "map_to_subsemiring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map_to_subsemiring {S : subalgebra R A} {f : «expr →ₐ[ ] » A R B} :\n    (S.map f).to_subsemiring = S.to_subsemiring.map f.to_ring_hom :=\n  SetLike.coe_injective rfl\n#align map_to_subsemiring map_to_subsemiring\n\n",
 "map_to_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map_to_submodule {S : subalgebra R A} {f : «expr →ₐ[ ] » A R B} :\n    (S.map f).to_submodule = S.to_submodule.map f.to_linear_map :=\n  SetLike.coe_injective rfl\n#align map_to_submodule map_to_submodule\n\n",
 "map_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_sup (f : «expr →ₐ[ ] » A R B) (S T : subalgebra R A) :\n    («expr ⊔ » S T).map f = «expr ⊔ » (S.map f) (T.map f) :=\n  (subalgebra.gc_map_comap f).l_sup\n#align map_sup map_sup\n\n",
 "map_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map_mono {S₁ S₂ : subalgebra R A} {f : «expr →ₐ[ ] » A R B} : S₁ ≤ S₂ → S₁.map f ≤ S₂.map f :=\n  Set.image_subset f\n#align map_mono map_mono\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map_map (S : subalgebra R A) (g : «expr →ₐ[ ] » B R C) (f : «expr →ₐ[ ] » A R B) :\n    (S.map f).map g = S.map (g.comp f) :=\n  SetLike.coe_injective <| Set.image_image _ _ _\n#align map_map map_map\n\n",
 "map_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map_le {S : subalgebra R A} {f : «expr →ₐ[ ] » A R B} {U : subalgebra R B} : map f S ≤ U ↔ S ≤ comap f U :=\n  Set.image_subset_iff\n#align map_le map_le\n\n",
 "map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem map_injective {f : «expr →ₐ[ ] » A R B} (hf : function.injective f) : function.injective (map f) :=\n  fun S₁ S₂ ih => ext <| Set.ext_iff.1 <| Set.image_injective.2 hf <| Set.ext <| SetLike.ext_iff.mp ih\n#align map_injective map_injective\n\n",
 "map_id":
 "@[simp]\ntheorem map_id (S : subalgebra R A) : S.map (alg_hom.id R A) = S :=\n  SetLike.coe_injective <| Set.image_id _\n#align map_id map_id\n\n",
 "map_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem map_bot (f : «expr →ₐ[ ] » A R B) : («expr⊥» : subalgebra R A).map f = «expr⊥» :=\n  SetLike.coe_injective <| by simp only [← Set.range_comp, (· ∘ ·), algebra.coe_bot, subalgebra.coe_map, f.commutes]\n#align map_bot map_bot\n\n",
 "list_sum_mem":
 "protected theorem list_sum_mem {L : list A} (h : ∀ x ∈ L, x ∈ S) : L.sum ∈ S :=\n  list_sum_mem h\n#align list_sum_mem list_sum_mem\n\n",
 "list_prod_mem":
 "protected theorem list_prod_mem {L : list A} (h : ∀ x ∈ L, x ∈ S) : L.prod ∈ S :=\n  list_prod_mem h\n#align list_prod_mem list_prod_mem\n\n",
 "injective_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem injective_cod_restrict (f : «expr →ₐ[ ] » A R B) (S : subalgebra R B) (hf : ∀ x, f x ∈ S) :\n    function.injective (f.cod_restrict S hf) ↔ function.injective f :=\n  ⟨fun H x y hxy => H <| subtype.eq hxy, fun H x y hxy => H (congr_arg subtype.val hxy : _)⟩\n#align injective_cod_restrict injective_cod_restrict\n\n",
 "infi_to_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem infi_to_submodule {ι : Sort _} (S : ι → subalgebra R A) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (S i)).to_submodule =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (S i).to_submodule :=\n  SetLike.coe_injective <| by simp\n#align infi_to_submodule infi_to_submodule\n\n",
 "inf_to_subsemiring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem inf_to_subsemiring (S T : subalgebra R A) :\n    («expr ⊓ » S T).to_subsemiring = «expr ⊓ » S.to_subsemiring T.to_subsemiring :=\n  rfl\n#align inf_to_subsemiring inf_to_subsemiring\n\n",
 "inf_to_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem inf_to_submodule (S T : subalgebra R A) :\n    («expr ⊓ » S T).to_submodule = «expr ⊓ » S.to_submodule T.to_submodule :=\n  rfl\n#align inf_to_submodule inf_to_submodule\n\n",
 "inclusion_self":
 "@[simp]\ntheorem inclusion_self {S : subalgebra R A} : inclusion (le_refl S) = alg_hom.id R S :=\n  alg_hom.ext fun x => subtype.ext rfl\n#align inclusion_self inclusion_self\n\n",
 "inclusion_right":
 "theorem inclusion_right {S T : subalgebra R A} (h : S ≤ T) (x : T) (m : (x : A) ∈ S) : inclusion h ⟨x, m⟩ = x :=\n  subtype.ext rfl\n#align inclusion_right inclusion_right\n\n",
 "inclusion_mk":
 "@[simp]\ntheorem inclusion_mk {S T : subalgebra R A} (h : S ≤ T) (x : A) (hx : x ∈ S) : inclusion h ⟨x, hx⟩ = ⟨x, h hx⟩ :=\n  rfl\n#align inclusion_mk inclusion_mk\n\n",
 "inclusion_injective":
 "theorem inclusion_injective {S T : subalgebra R A} (h : S ≤ T) : function.injective (inclusion h) := fun _ _ =>\n  subtype.ext ∘ subtype.mk.inj\n#align inclusion_injective inclusion_injective\n\n",
 "inclusion_inclusion":
 "@[simp]\ntheorem inclusion_inclusion {S T U : subalgebra R A} (hst : S ≤ T) (htu : T ≤ U) (x : S) :\n    inclusion htu (inclusion hst x) = inclusion (le_trans hst htu) x :=\n  subtype.ext rfl\n#align inclusion_inclusion inclusion_inclusion\n\n",
 "gc_map_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem gc_map_comap (f : «expr →ₐ[ ] » A R B) : GaloisConnection (map f) (comap f) := fun S U => map_le\n#align gc_map_comap gc_map_comap\n\n",
 "gc":
 "protected theorem gc : GaloisConnection (adjoin R : set A → subalgebra R A) coe := fun s S =>\n  ⟨fun H => le_trans (le_trans (Set.subset_union_right _ _) subsemiring.subset_closure) H, fun H =>\n    show subsemiring.closure (Set.range (algebra_map R A) ∪ s) ≤ S.to_subsemiring from\n      subsemiring.closure_le.2 <| Set.union_subset S.range_subset H⟩\n#align gc gc\n\n",
 "ext":
 "@[ext]\ntheorem ext {S T : subalgebra R A} (h : ∀ x : A, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n#align ext ext\n\n",
 "equiv_of_eq_trans":
 "@[simp]\ntheorem equiv_of_eq_trans (S T U : subalgebra R A) (hST : S = T) (hTU : T = U) :\n    (equiv_of_eq S T hST).trans (equiv_of_eq T U hTU) = equiv_of_eq S U (trans hST hTU) :=\n  rfl\n#align equiv_of_eq_trans equiv_of_eq_trans\n\n",
 "equiv_of_eq_symm":
 "@[simp]\ntheorem equiv_of_eq_symm (S T : subalgebra R A) (h : S = T) : (equiv_of_eq S T h).symm = equiv_of_eq T S h.symm :=\n  rfl\n#align equiv_of_eq_symm equiv_of_eq_symm\n\n",
 "equiv_of_eq_rfl":
 "@[simp]\ntheorem equiv_of_eq_rfl (S : subalgebra R A) : equiv_of_eq S S rfl = alg_equiv.refl :=\n  by\n  ext\n  rfl\n#align equiv_of_eq_rfl equiv_of_eq_rfl\n\n",
 "eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print eq_top_iff /-\ntheorem eq_top_iff {S : subalgebra R A} : S = «expr⊤» ↔ ∀ x : A, x ∈ S :=\n  ⟨fun h x => by rw [h] <;> exact mem_top, fun h => by ext x <;> exact ⟨fun _ => mem_top, fun _ => h x⟩⟩\n#align eq_top_iff eq_top_iff\n-/\n\n",
 "copy_eq":
 "theorem copy_eq (S : subalgebra R A) (s : set A) (hs : s = ↑S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n#align copy_eq copy_eq\n\n",
 "comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_top (f : «expr →ₐ[ ] » A R B) : («expr⊤» : subalgebra R B).comap f = «expr⊤» :=\n  eq_top_iff.2 fun x => mem_top\n#align comap_top comap_top\n\n",
 "coe_zero":
 "protected theorem coe_zero : ((0 : S) : A) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_val":
 "-- todo: standardize on the names these morphisms\n-- compare with submodule.subtype\n@[simp]\ntheorem coe_val : (S.val : S → A) = coe :=\n  rfl\n#align coe_val coe_val\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_top : (↑(«expr⊤» : subalgebra R A) : set A) = Set.univ :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_to_subsemiring":
 "@[simp]\ntheorem coe_to_subsemiring (S : subalgebra R A) : (↑S.to_subsemiring : set A) = S :=\n  rfl\n#align coe_to_subsemiring coe_to_subsemiring\n\n",
 "coe_to_subring":
 "@[simp]\ntheorem coe_to_subring {R : Type u} {A : Type v} [CommRing R] [Ring A] [algebra R A] (S : subalgebra R A) :\n    (↑S.to_subring : set A) = S :=\n  rfl\n#align coe_to_subring coe_to_subring\n\n",
 "coe_to_submodule":
 "@[simp]\ntheorem coe_to_submodule (S : subalgebra R A) : (↑S.to_submodule : set A) = S :=\n  rfl\n#align coe_to_submodule coe_to_submodule\n\n",
 "coe_to_subalgebra":
 "@[simp]\ntheorem coe_to_subalgebra (p : submodule R A) (h_one h_mul) : (p.to_subalgebra h_one h_mul : set A) = p :=\n  rfl\n#align coe_to_subalgebra coe_to_subalgebra\n\n",
 "coe_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem coe_supr_of_directed [nonempty ι] {S : ι → subalgebra R A} (dir : Directed (· ≤ ·) S) :\n    ↑(supᵢ S) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S i : set A) :=\n  let K : subalgebra R A :=\n    { carrier := «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S i)\n      mul_mem' := fun x y hx hy =>\n        let ⟨i, hi⟩ := Set.mem_unionᵢ.1 hx\n        let ⟨j, hj⟩ := Set.mem_unionᵢ.1 hy\n        let ⟨k, hik, hjk⟩ := dir i j\n        Set.mem_unionᵢ.2 ⟨k, subalgebra.mul_mem (S k) (hik hi) (hjk hj)⟩\n      add_mem' := fun x y hx hy =>\n        let ⟨i, hi⟩ := Set.mem_unionᵢ.1 hx\n        let ⟨j, hj⟩ := Set.mem_unionᵢ.1 hy\n        let ⟨k, hik, hjk⟩ := dir i j\n        Set.mem_unionᵢ.2 ⟨k, subalgebra.add_mem (S k) (hik hi) (hjk hj)⟩\n      algebra_map_mem' := fun r =>\n        let i := @nonempty.some ι infer_instance\n        Set.mem_unionᵢ.2 ⟨i, subalgebra.algebra_map_mem _ _⟩ }\n  have : supᵢ S = K :=\n    le_antisymm (supᵢ_le fun i => Set.subset_unionᵢ (fun i => ↑(S i)) i)\n      (SetLike.coe_subset_coe.1 (Set.unionᵢ_subset fun i => SetLike.coe_subset_coe.2 (le_supᵢ _ _)))\n  this.symm ▸ rfl\n#align coe_supr_of_directed coe_supr_of_directed\n\n",
 "coe_sub":
 "protected theorem coe_sub {R : Type u} {A : Type v} [CommRing R] [Ring A] [algebra R A] {S : subalgebra R A} (x y : S) :\n    (↑(x - y) : A) = ↑x - ↑y :=\n  rfl\n#align coe_sub coe_sub\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, norm_cast]\ntheorem coe_smul [Semiring R'] [SMul R' R] [Module R' A] [IsScalarTower R' R A] (r : R') (x : S) :\n    (↑(«expr • » r x) : A) = «expr • » r ↑x :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem coe_range (φ : «expr →ₐ[ ] » A R B) : (φ.range : set B) = Set.range φ :=\n  by\n  ext\n  rw [SetLike.mem_coe, mem_range]\n  rfl\n#align coe_range coe_range\n\n",
 "coe_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem coe_prod : (prod S S₁ : set (A × B)) = finset.product S S₁ :=\n  rfl\n#align coe_prod coe_prod\n\n",
 "coe_pow":
 "protected theorem coe_pow (x : S) (n : ℕ) : (↑(x ^ n) : A) = ↑x ^ n :=\n  SubmonoidClass.coe_pow x n\n#align coe_pow coe_pow\n\n",
 "coe_one":
 "protected theorem coe_one : ((1 : S) : A) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_neg":
 "protected theorem coe_neg {R : Type u} {A : Type v} [CommRing R] [Ring A] [algebra R A] {S : subalgebra R A} (x : S) :\n    (↑(-x) : A) = -↑x :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_nat_mem":
 "protected theorem coe_nat_mem (n : ℕ) : (n : A) ∈ S :=\n  coe_nat_mem S n\n#align coe_nat_mem coe_nat_mem\n\n",
 "coe_mul":
 "protected theorem coe_mul (x y : S) : (↑(x * y) : A) = ↑x * ↑y :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem coe_map (S : subalgebra R A) (f : «expr →ₐ[ ] » A R B) : (S.map f : set B) = «expr '' » f S :=\n  rfl\n#align coe_map coe_map\n\n",
 "coe_int_mem":
 "protected theorem coe_int_mem {R : Type u} {A : Type v} [CommRing R] [Ring A] [algebra R A] (S : subalgebra R A)\n    (n : ℤ) : (n : A) ∈ S :=\n  coe_int_mem S n\n#align coe_int_mem coe_int_mem\n\n",
 "coe_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast]\ntheorem coe_infi {ι : Sort _} {S : ι → subalgebra R A} :\n    (↑(«expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (S i)) : set A) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (S i) :=\n  by simp [infᵢ]\n#align coe_infi coe_infi\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, norm_cast]\ntheorem coe_inf (S T : subalgebra R A) : (↑(«expr ⊓ » S T) : set A) = S ∩ T :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_inclusion":
 "@[simp]\ntheorem coe_inclusion {S T : subalgebra R A} (h : S ≤ T) (s : S) : (inclusion h s : A) = s :=\n  rfl\n#align coe_inclusion coe_inclusion\n\n",
 "coe_eq_zero":
 "protected theorem coe_eq_zero {x : S} : (x : A) = 0 ↔ x = 0 :=\n  ZeroMemClass.coe_eq_zero\n#align coe_eq_zero coe_eq_zero\n\n",
 "coe_eq_one":
 "protected theorem coe_eq_one {x : S} : (x : A) = 1 ↔ x = 1 :=\n  OneMemClass.coe_eq_one\n#align coe_eq_one coe_eq_one\n\n",
 "coe_copy":
 "@[simp]\ntheorem coe_copy (S : subalgebra R A) (s : set A) (hs : s = ↑S) : (S.copy s hs : set A) = s :=\n  rfl\n#align coe_copy coe_copy\n\n",
 "coe_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp, norm_cast]\ntheorem coe_comap (S : subalgebra R B) (f : «expr →ₐ[ ] » A R B) : (S.comap f : set A) = «expr ⁻¹' » f (S : set B) :=\n  rfl\n#align coe_comap coe_comap\n\n",
 "coe_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem coe_cod_restrict (f : «expr →ₐ[ ] » A R B) (S : subalgebra R B) (hf : ∀ x, f x ∈ S) (x : A) :\n    ↑(f.cod_restrict S hf x) = f x :=\n  rfl\n#align coe_cod_restrict coe_cod_restrict\n\n",
 "coe_centralizer":
 "@[simp, norm_cast]\ntheorem coe_centralizer (s : set A) : (centralizer R s : set A) = s.centralizer :=\n  rfl\n#align coe_centralizer coe_centralizer\n\n",
 "coe_center":
 "theorem coe_center : (center R A : set A) = Set.center A :=\n  rfl\n#align coe_center coe_center\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem coe_bot : ((«expr⊥» : subalgebra R A) : set A) = Set.range (algebra_map R A) := by\n  simp [Set.ext_iff, algebra.mem_bot]\n#align coe_bot coe_bot\n\n",
 "coe_algebra_map":
 "@[simp, norm_cast]\ntheorem coe_algebra_map [CommSemiring R'] [SMul R' R] [algebra R' A] [IsScalarTower R' R A] (r : R') :\n    ↑(algebra_map R' S r) = algebra_map R' A r :=\n  rfl\n#align coe_algebra_map coe_algebra_map\n\n",
 "coe_add":
 "protected theorem coe_add (x y : S) : (↑(x + y) : A) = ↑x + ↑y :=\n  rfl\n#align coe_add coe_add\n\n",
 "coe_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast]\ntheorem coe_Inf (S : set (subalgebra R A)) :\n    (↑(infₛ S) : set A) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑s :=\n  infₛ_image\n#align coe_Inf coe_Inf\n\n",
 "centralizer_univ":
 "@[simp]\ntheorem centralizer_univ : centralizer R Set.univ = center R A :=\n  SetLike.ext' (Set.centralizer_univ A)\n#align centralizer_univ centralizer_univ\n\n",
 "centralizer_le":
 "theorem centralizer_le (s t : set A) (h : s ⊆ t) : centralizer R t ≤ centralizer R s :=\n  Set.centralizer_subset h\n#align centralizer_le centralizer_le\n\n",
 "center_to_subsemiring":
 "@[simp]\ntheorem center_to_subsemiring : (center R A).to_subsemiring = subsemiring.center A :=\n  rfl\n#align center_to_subsemiring center_to_subsemiring\n\n",
 "center_to_subring":
 "@[simp]\ntheorem center_to_subring (R A : Type _) [CommRing R] [Ring A] [algebra R A] :\n    (center R A).to_subring = subring.center A :=\n  rfl\n#align center_to_subring center_to_subring\n\n",
 "center_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem center_eq_top (A : Type _) [CommSemiring A] [algebra R A] : center R A = «expr⊤» :=\n  SetLike.coe_injective (Set.center_eq_univ A)\n#align center_eq_top center_eq_top\n\n",
 "bijective_algebra_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem bijective_algebra_map_iff {R A : Type _} [Field R] [Semiring A] [nontrivial A] [algebra R A] :\n    function.bijective (algebra_map R A) ↔ («expr⊤» : subalgebra R A) = «expr⊥» :=\n  ⟨fun h => surjective_algebra_map_iff.1 h.2, fun h => ⟨(algebra_map R A).injective, surjective_algebra_map_iff.2 h⟩⟩\n#align bijective_algebra_map_iff bijective_algebra_map_iff\n\n",
 "algebra_map_mem_centralizer":
 "@[simp]\ntheorem _root_.set.algebra_map_mem_centralizer {s : set A} (r : R) : algebra_map R A r ∈ s.centralizer := fun a h =>\n  (algebra.commutes _ _).symm\n#align set.algebra_map_mem_centralizer set.algebra_map_mem_centralizer\n\n",
 "algebra_map_mem_center":
 "theorem _root_.set.algebra_map_mem_center (r : R) : algebra_map R A r ∈ Set.center A := by\n  simp [algebra.commutes, Set.mem_center_iff]\n#align set.algebra_map_mem_center set.algebra_map_mem_center\n\n",
 "algebra_map_mem":
 "theorem algebra_map_mem (r : R) : algebra_map R A r ∈ S :=\n  S.algebra_map_mem' r\n#align algebra_map_mem algebra_map_mem\n\n",
 "algebra_map_eq":
 "theorem algebra_map_eq {R A : Type _} [CommSemiring R] [CommSemiring A] [Semiring α] [algebra R A] [algebra A α]\n    (S : subalgebra R A) : algebra_map S α = (algebra_map A α).comp S.val :=\n  rfl\n#align algebra_map_eq algebra_map_eq\n\n",
 "add_mem":
 "protected theorem add_mem {x y : A} (hx : x ∈ S) (hy : y ∈ S) : x + y ∈ S :=\n  add_mem hx hy\n#align add_mem add_mem\n\n",
 "Inf_to_subsemiring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem Inf_to_subsemiring (S : set (subalgebra R A)) :\n    (infₛ S).to_subsemiring = infₛ («expr '' » subalgebra.to_subsemiring S) :=\n  SetLike.coe_injective <| by simp\n#align Inf_to_subsemiring Inf_to_subsemiring\n\n",
 "Inf_to_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem Inf_to_submodule (S : set (subalgebra R A)) :\n    (infₛ S).to_submodule = infₛ («expr '' » subalgebra.to_submodule S) :=\n  SetLike.coe_injective <| by simp\n#align Inf_to_submodule Inf_to_submodule\n\n"}