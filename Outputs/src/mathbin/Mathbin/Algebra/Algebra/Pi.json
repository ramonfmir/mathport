{"const_ring_hom_eq_algebra_map":
 "-- One could also build a `Π i, R i`-algebra structure on `Π i, A i`,\n-- when each `A i` is an `R i`-algebra, although I'm not sure that it's useful.\n/-- When `R` is commutative and permits an `algebra_map`, `pi.const_ring_hom` is equal to that\nmap. -/\n@[simp]\ntheorem const_ring_hom_eq_algebra_map : constRingHom A R = algebraMap R (A → R) :=\n  rfl\n#align const_ring_hom_eq_algebra_map const_ring_hom_eq_algebra_map\n\n",
 "const_alg_hom_eq_algebra_of_id":
 "@[simp]\ntheorem const_alg_hom_eq_algebra_of_id : constAlgHom R A R = Algebra.ofId R (A → R) :=\n  rfl\n#align const_alg_hom_eq_algebra_of_id const_alg_hom_eq_algebra_of_id\n\n",
 "algebra_map_def":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Yury Kudryashov\n-/\n-- The indexing type\n-- The scalar type\n-- The family of types already equipped with instances\ntheorem algebra_map_def {r : CommSemiring R} [s : ∀ i, Semiring (f i)] [∀ i, Algebra R (f i)] (a : R) :\n    algebraMap R (∀ i, f i) a = fun i => algebraMap R (f i) a :=\n  rfl\n#align algebra_map_def algebra_map_def\n\n",
 "algebraMap_apply":
 "#print algebraMap_apply /-\n@[simp]\ntheorem algebraMap_apply {r : CommSemiring R} [s : ∀ i, Semiring (f i)] [∀ i, Algebra R (f i)] (a : R) (i : I) :\n    algebraMap R (∀ i, f i) a i = algebraMap R (f i) a :=\n  rfl\n#align algebra_map_apply algebraMap_apply\n-/\n\n",
 "Pi_congr_right_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem Pi_congr_right_trans {R ι : Type _} {A₁ A₂ A₃ : ι → Type _} [CommSemiring R] [∀ i, Semiring (A₁ i)]\n    [∀ i, Semiring (A₂ i)] [∀ i, Semiring (A₃ i)] [∀ i, Algebra R (A₁ i)] [∀ i, Algebra R (A₂ i)]\n    [∀ i, Algebra R (A₃ i)] (e₁ : ∀ i, «expr ≃ₐ[ ] » (A₁ i) R (A₂ i)) (e₂ : ∀ i, «expr ≃ₐ[ ] » (A₂ i) R (A₃ i)) :\n    (piCongrRight e₁).trans (piCongrRight e₂) = piCongrRight fun i => (e₁ i).trans (e₂ i) :=\n  rfl\n#align Pi_congr_right_trans Pi_congr_right_trans\n\n",
 "Pi_congr_right_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem Pi_congr_right_symm {R ι : Type _} {A₁ A₂ : ι → Type _} [CommSemiring R] [∀ i, Semiring (A₁ i)]\n    [∀ i, Semiring (A₂ i)] [∀ i, Algebra R (A₁ i)] [∀ i, Algebra R (A₂ i)] (e : ∀ i, «expr ≃ₐ[ ] » (A₁ i) R (A₂ i)) :\n    (piCongrRight e).symm = piCongrRight fun i => (e i).symm :=\n  rfl\n#align Pi_congr_right_symm Pi_congr_right_symm\n\n",
 "Pi_congr_right_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem Pi_congr_right_refl {R ι : Type _} {A : ι → Type _} [CommSemiring R] [∀ i, Semiring (A i)]\n    [∀ i, Algebra R (A i)] : (piCongrRight fun i => (AlgEquiv.refl : «expr ≃ₐ[ ] » (A i) R (A i))) = AlgEquiv.refl :=\n  rfl\n#align Pi_congr_right_refl Pi_congr_right_refl\n\n"}