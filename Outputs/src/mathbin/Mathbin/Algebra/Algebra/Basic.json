{"trans":
 "theorem no_zero_smul_divisors.trans (R A M : Type _) [CommRing R] [Ring A] [IsDomain A] [algebra R A] [add_comm_group M]\n    [Module R M] [Module A M] [IsScalarTower R A M] [NoZeroSMulDivisors R A] [NoZeroSMulDivisors A M] :\n    NoZeroSMulDivisors R M := by\n  refine' ⟨fun r m h => _⟩\n  rw [algebra_compatible_smul A r m] at h\n  cases' smul_eq_zero.1 h with H H\n  · have : function.injective (algebra_map R A) := no_zero_smul_divisors.iff_algebra_map_injective.1 infer_instance\n    left\n    exact (injective_iff_map_eq_zero _).1 this _ H\n  · right\n    exact H\n#align no_zero_smul_divisors.trans no_zero_smul_divisors.trans\n\n",
 "span_eq_restrict_scalars":
 "/-- If `A` is an `R`-algebra such that the induced morhpsim `R →+* A` is surjective, then the\n`R`-module generated by a set `X` equals the `A`-module generated by `X`. -/\ntheorem span_eq_restrict_scalars (X : set M) (hsur : function.surjective (algebra_map R A)) :\n    span R X = restrict_scalars R (span A X) :=\n  by\n  apply (span_le_restrict_scalars R A X).antisymm fun m hm => _\n  refine' span_induction hm subset_span (zero_mem _) (fun _ _ => add_mem) fun a m hm => _\n  obtain ⟨r, rfl⟩ := hsur a\n  simpa [algebra_map_smul] using smul_mem _ r hm\n#align span_eq_restrict_scalars span_eq_restrict_scalars\n\n",
 "smul_one_eq_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem rat.smul_one_eq_coe {A : Type _} [DivisionRing A] [algebra (exprℚ) A] (m : exprℚ) :\n    @has_smul.smul algebra.to_has_smul m (1 : A) = ↑m := by rw [algebra.smul_def, mul_one, eq_ratCast]\n#align rat.smul_one_eq_coe rat.smul_one_eq_coe\n\n",
 "smul_mul_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_mul_assoc /-\n/-- This is just a special case of the global `smul_mul_assoc` lemma that requires less typeclass\nsearch (and was here first). -/\n@[simp]\nprotected theorem smul_mul_assoc (r : R) (x y : A) : «expr • » r x * y = «expr • » r (x * y) :=\n  smul_mul_assoc r x y\n#align smul_mul_assoc smul_mul_assoc\n-/\n\n",
 "smul_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_eq_mul /-\n@[simp]\ntheorem smul_eq_mul (x y : R) : «expr • » x y = x * y :=\n  rfl\n#align smul_eq_mul smul_eq_mul\n-/\n\n",
 "smul_def''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- We keep this lemma private because it picks up the `algebra.to_has_smul` instance\nwhich we set to priority 0 shortly. See `smul_def` below for the public version. -/\nprivate theorem smul_def'' (r : R) (x : A) : «expr • » r x = algebra_map R A r * x :=\n  algebra.smul_def' r x\n#align smul_def'' smul_def''\n\n",
 "smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- see Note [lower instance priority]\n-- From now on, we don't want to use the following instance anymore.\n-- Unfortunately, leaving it in place causes deterministic timeouts later in mathlib.\ntheorem smul_def (r : R) (x : A) : «expr • » r x = algebra_map R A r * x :=\n  algebra.smul_def' r x\n#align smul_def smul_def\n\n",
 "smul_algebra_smul_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\ntheorem smul_algebra_smul_comm (r : R) (a : A) (m : M) : «expr • » a («expr • » r m) = «expr • » r («expr • » a m) :=\n  smul_comm _ _ _\n#align smul_algebra_smul_comm smul_algebra_smul_comm\n\n",
 "smul_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem _root_.smul_algebra_map {α : Type _} [monoid α] [MulDistribMulAction α A] [SMulCommClass α R A] (a : α)\n    (r : R) : «expr • » a (algebra_map R A r) = algebra_map R A r := by\n  rw [algebra_map_eq_smul_one, smul_comm a r (1 : A), smul_one]\n#align smul_algebra_map smul_algebra_map\n\n",
 "right_comm":
 "#print right_comm /-\n/-- `mul_right_comm` for `algebra`s when one element is from the base ring. -/\ntheorem right_comm (x : A) (r : R) (y : A) : x * algebra_map R A r * y = x * y * algebra_map R A r := by\n  rw [mul_assoc, commutes, ← mul_assoc]\n#align right_comm right_comm\n-/\n\n",
 "of_no_zero_smul_divisors":
 "theorem _root_.ne_zero.of_no_zero_smul_divisors (n : ℕ) [CommRing R] [ne_zero (n : R)] [Ring A] [nontrivial A]\n    [algebra R A] [NoZeroSMulDivisors R A] : ne_zero (n : A) :=\n  ne_zero.nat_of_injective <| no_zero_smul_divisors.algebra_map_injective R A\n#align ne_zero.of_no_zero_smul_divisors ne_zero.of_no_zero_smul_divisors\n\n",
 "of_algebra_map_injective":
 "/-- If `algebra_map R A` is injective and `A` has no zero divisors,\n`R`-multiples in `A` are zero only if one of the factors is zero.\n\nCannot be an instance because there is no `injective (algebra_map R A)` typeclass.\n-/\ntheorem of_algebra_map_injective [CommSemiring R] [Semiring A] [algebra R A] [no_zero_divisors A]\n    (h : function.injective (algebra_map R A)) : NoZeroSMulDivisors R A :=\n  ⟨fun c x hcx => (mul_eq_zero.mp ((smul_def c x).symm.trans hcx)).imp_left (map_eq_zero_iff (algebra_map R A) h).mp⟩\n#align of_algebra_map_injective of_algebra_map_injective\n\n",
 "mul_sub_algebra_map_pow_commutes":
 "theorem mul_sub_algebra_map_pow_commutes [Ring A] [algebra R A] (x : A) (r : R) (n : ℕ) :\n    x * (x - algebra_map R A r) ^ n = (x - algebra_map R A r) ^ n * x :=\n  by\n  induction' n with n ih\n  · simp\n  · rw [pow_succ, ← mul_assoc, mul_sub_algebra_map_commutes, mul_assoc, ih, ← mul_assoc]\n#align mul_sub_algebra_map_pow_commutes mul_sub_algebra_map_pow_commutes\n\n",
 "mul_sub_algebra_map_commutes":
 "theorem mul_sub_algebra_map_commutes [Ring A] [algebra R A] (x : A) (r : R) :\n    x * (x - algebra_map R A r) = (x - algebra_map R A r) * x := by rw [mul_sub, ← commutes, sub_mul]\n#align mul_sub_algebra_map_commutes mul_sub_algebra_map_commutes\n\n",
 "mul_smul_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print mul_smul_comm /-\n/-- This is just a special case of the global `mul_smul_comm` lemma that requires less typeclass\nsearch (and was here first). -/\n@[simp]\nprotected theorem mul_smul_comm (s : R) (x y : A) : x * «expr • » s y = «expr • » s (x * y) :=\n  by-- TODO: set up `is_scalar_tower.smul_comm_class` earlier so that we can actually prove this using\n  -- `mul_smul_comm s x y`.\n  rw [smul_def, smul_def, left_comm]\n#align mul_smul_comm mul_smul_comm\n-/\n\n",
 "mem_algebra_map_submonoid_of_mem":
 "theorem mem_algebra_map_submonoid_of_mem {S : Type _} [Semiring S] [algebra R S] {M : Submonoid R} (x : M) :\n    algebra_map R S x ∈ algebra_map_submonoid S M :=\n  Set.mem_image_of_mem (algebra_map R S) x.2\n#align mem_algebra_map_submonoid_of_mem mem_algebra_map_submonoid_of_mem\n\n",
 "map_rat_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n-- Lower the priority so that `algebra.id` is picked most of the time when working with\n-- `ℕ`-algebras. This is only an issue since `algebra.id` and `algebra_nat` are not yet defeq.\n-- TODO: fix this by adding an `of_nat` field to semirings.\n-- note that `R`, `S` could be `semiring`s but this is useless mathematically speaking -\n-- a ℚ-algebra is a ring. furthermore, this change probably slows down elaboration.\n@[simp]\ntheorem map_rat_algebra_map [Ring R] [Ring S] [algebra (exprℚ) R] [algebra (exprℚ) S] (f : «expr →+* » R S)\n    (r : exprℚ) : f (algebra_map (exprℚ) R r) = algebra_map (exprℚ) S r :=\n  RingHom.ext_iff.1 (subsingleton.elim (f.comp (algebra_map (exprℚ) R)) (algebra_map (exprℚ) S)) r\n#align map_rat_algebra_map map_rat_algebra_map\n\n",
 "map_mul_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem map_mul_algebra_map (f : «expr →ₗ[ ] » A R B) (a : A) (r : R) :\n    f (a * algebra_map R A r) = f a * algebra_map R B r := by\n  rw [← algebra.commutes, ← algebra.commutes, map_algebra_map_mul]\n#align map_mul_algebra_map map_mul_algebra_map\n\n",
 "map_eq_self":
 "theorem map_eq_self (x : R) : algebra_map R R x = x :=\n  rfl\n#align map_eq_self map_eq_self\n\n",
 "map_eq_id":
 "@[simp]\ntheorem map_eq_id : algebra_map R R = RingHom.id _ :=\n  rfl\n#align map_eq_id map_eq_id\n\n",
 "map_algebra_map_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- An alternate statement of `linear_map.map_smul` for when `algebra_map` is more convenient to\nwork with than `•`. -/\ntheorem map_algebra_map_mul (f : «expr →ₗ[ ] » A R B) (a : A) (r : R) :\n    f (algebra_map R A r * a) = algebra_map R B r * f a := by rw [← algebra.smul_def, ← algebra.smul_def, map_smul]\n#align map_algebra_map_mul map_algebra_map_mul\n\n",
 "linear_map_apply":
 "@[simp]\ntheorem linear_map_apply (r : R) : algebra.linear_map R A r = algebra_map R A r :=\n  rfl\n#align linear_map_apply linear_map_apply\n\n",
 "lift_map_eq_zero_iff":
 "@[norm_cast, simp]\ntheorem lift_map_eq_zero_iff (a : R) : (↑a : A) = 0 ↔ a = 0 :=\n  by\n  rw [show (0 : A) = ↑(0 : R) from (map_zero (algebra_map R A)).symm]\n  norm_cast\n#align lift_map_eq_zero_iff lift_map_eq_zero_iff\n\n",
 "left_comm":
 "#print left_comm /-\n/-- `mul_left_comm` for `algebra`s when one element is from the base ring. -/\ntheorem left_comm (x : A) (r : R) (y : A) : x * (algebra_map R A r * y) = algebra_map R A r * (x * y) := by\n  rw [← mul_assoc, ← commutes, mul_assoc]\n#align left_comm left_comm\n-/\n\n",
 "ker_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem linear_map.ker_restrict_scalars (f : «expr →ₗ[ ] » M S N) :\n    (f.restrict_scalars R).ker = f.ker.restrict_scalars R :=\n  rfl\n#align linear_map.ker_restrict_scalars linear_map.ker_restrict_scalars\n\n",
 "ker_algebra_map_End":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ker_algebra_map_End (K : Type u) (V : Type v) [Field K] [add_comm_group V] [Module K V] (a : K) (ha : a ≠ 0) :\n    ((algebra_map K (End K V)) a).ker = «expr⊥» :=\n  linear_map.ker_smul _ _ ha\n#align ker_algebra_map_End ker_algebra_map_End\n\n",
 "int_cast_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem int_cast_smul {k V : Type _} [CommRing k] [add_comm_group V] [Module k V] (r : ℤ) (x : V) :\n    «expr • » (r : k) x = «expr • » r x :=\n  algebra_map_smul k r x\n#align int_cast_smul int_cast_smul\n\n",
 "iff_algebra_map_injective":
 "theorem iff_algebra_map_injective [CommRing R] [Ring A] [IsDomain A] [algebra R A] :\n    NoZeroSMulDivisors R A ↔ function.injective (algebra_map R A) :=\n  ⟨@no_zero_smul_divisors.algebra_map_injective R A _ _ _ _, no_zero_smul_divisors.of_algebra_map_injective⟩\n#align iff_algebra_map_injective iff_algebra_map_injective\n\n",
 "down_algebra_map":
 "@[simp]\ntheorem _root_.ulift.down_algebra_map (r : R) : (algebra_map R (ULift A) r).down = algebra_map R A r :=\n  rfl\n#align ulift.down_algebra_map ulift.down_algebra_map\n\n",
 "commutes":
 "/-- `mul_comm` for `algebra`s when one element is from the base ring. -/\ntheorem commutes (r : R) (x : A) : algebra_map R A r * x = x * algebra_map R A r :=\n  algebra.commutes' r x\n#align commutes commutes\n\n",
 "coe_zero":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Yury Kudryashov\n-/\n-- We set this priority to 0 later in this file\n/- control priority of\n`instance [algebra R A] : has_smul R A` -/\n@[simp, norm_cast]\ntheorem coe_zero : (↑(0 : R) : A) = 0 :=\n  map_zero (algebra_map R A)\n#align coe_zero coe_zero\n\n",
 "coe_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n-- to_additive fails for some reason\n@[norm_cast]\ntheorem coe_sum {ι : Type _} {s : Finset ι} (a : ι → R) :\n    ↑(finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (a i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (↑(a i) : A) :=\n  map_sum (algebra_map R A) a s\n#align coe_sum coe_sum\n\n",
 "coe_restrict_scalars_eq_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp, norm_cast squash]\ntheorem coe_restrict_scalars_eq_coe (f : «expr →ₗ[ ] » M A N) : (f.restrict_scalars R : M → N) = f :=\n  rfl\n#align coe_restrict_scalars_eq_coe coe_restrict_scalars_eq_coe\n\n",
 "coe_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n-- direct to_additive fails because of some mix-up with polynomials\n@[norm_cast]\ntheorem coe_prod {ι : Type _} {s : Finset ι} (a : ι → R) :\n    (↑(finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (a i) : R) :\n        A) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (↑(a i) : A) :=\n  map_prod (algebra_map R A) a s\n#align coe_prod coe_prod\n\n",
 "coe_pow":
 "@[norm_cast]\ntheorem coe_pow (a : R) (n : ℕ) : (↑(a ^ n : R) : A) = ↑a ^ n :=\n  map_pow (algebra_map R A) _ _\n#align coe_pow coe_pow\n\n",
 "coe_one":
 "@[simp, norm_cast]\ntheorem coe_one : (↑(1 : R) : A) = 1 :=\n  map_one (algebra_map R A)\n#align coe_one coe_one\n\n",
 "coe_neg":
 "@[norm_cast]\ntheorem coe_neg (x : R) : (↑(-x : R) : A) = -↑x :=\n  map_neg (algebra_map R A) x\n#align coe_neg coe_neg\n\n",
 "coe_mul":
 "@[norm_cast]\ntheorem coe_mul (a b : R) : (↑(a * b : R) : A) = ↑a * ↑b :=\n  map_mul (algebra_map R A) a b\n#align coe_mul coe_mul\n\n",
 "coe_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_linear_map : «expr⇑ » (algebra.linear_map R A) = algebra_map R A :=\n  rfl\n#align coe_linear_map coe_linear_map\n\n",
 "coe_inj":
 "@[norm_cast, simp]\ntheorem coe_inj {a b : R} : (↑a : A) = ↑b ↔ a = b :=\n  ⟨fun h => (algebra_map R A).injective h, by rintro rfl <;> rfl⟩\n#align coe_inj coe_inj\n\n",
 "coe_coe_is_scalar_tower":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp, norm_cast squash]\ntheorem coe_coe_is_scalar_tower (f : «expr →ₗ[ ] » M A N) : ((f : «expr →ₗ[ ] » M R N) : M → N) = f :=\n  rfl\n#align coe_coe_is_scalar_tower coe_coe_is_scalar_tower\n\n",
 "coe_algebra_map_of_subsemiring":
 "theorem coe_algebra_map_of_subsemiring (S : subsemiring R) : (algebra_map S R : S → R) = subtype.val :=\n  rfl\n#align coe_algebra_map_of_subsemiring coe_algebra_map_of_subsemiring\n\n",
 "coe_algebra_map_of_subring":
 "theorem coe_algebra_map_of_subring {R : Type _} [CommRing R] (S : subring R) :\n    (algebra_map S R : S → R) = subtype.val :=\n  rfl\n#align coe_algebra_map_of_subring coe_algebra_map_of_subring\n\n",
 "coe_add":
 "@[norm_cast]\ntheorem coe_add (a b : R) : (↑(a + b : R) : A) = ↑a + ↑b :=\n  map_add (algebra_map R A) a b\n#align coe_add coe_add\n\n",
 "bit1_smul_one'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem bit1_smul_one' : «expr • » (bit1 r) (1 : A) = «expr • » r 2 + 1 := by simp [bit1, bit0, add_smul, smul_add]\n#align bit1_smul_one' bit1_smul_one'\n\n",
 "bit1_smul_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem bit1_smul_one : «expr • » (bit1 r) (1 : A) = bit1 («expr • » r (1 : A)) := by simp [bit1, add_smul]\n#align bit1_smul_one bit1_smul_one\n\n",
 "bit1_smul_bit1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem bit1_smul_bit1 : «expr • » (bit1 r) (bit1 a) = «expr • » r (bit0 (bit1 a)) + bit1 a :=\n  by\n  simp only [bit0, bit1, add_smul, smul_add, one_smul]\n  abel\n#align bit1_smul_bit1 bit1_smul_bit1\n\n",
 "bit1_smul_bit0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem bit1_smul_bit0 : «expr • » (bit1 r) (bit0 a) = «expr • » r (bit0 (bit0 a)) + bit0 a := by\n  simp [bit1, add_smul, smul_add]\n#align bit1_smul_bit0 bit1_smul_bit0\n\n",
 "bit0_smul_one'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem bit0_smul_one' : «expr • » (bit0 r) (1 : A) = «expr • » r 2 := by simp [bit0, add_smul, smul_add]\n#align bit0_smul_one' bit0_smul_one'\n\n",
 "bit0_smul_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem bit0_smul_one : «expr • » (bit0 r) (1 : A) = bit0 («expr • » r (1 : A)) := by simp [bit0, add_smul]\n#align bit0_smul_one bit0_smul_one\n\n",
 "bit0_smul_bit1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem bit0_smul_bit1 : «expr • » (bit0 r) (bit1 a) = «expr • » r (bit0 (bit1 a)) := by simp [bit0, add_smul, smul_add]\n#align bit0_smul_bit1 bit0_smul_bit1\n\n",
 "bit0_smul_bit0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem bit0_smul_bit0 : «expr • » (bit0 r) (bit0 a) = «expr • » r (bit0 (bit0 a)) := by simp [bit0, add_smul, smul_add]\n#align bit0_smul_bit0 bit0_smul_bit0\n\n",
 "algebra_map_to_algebra":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem ring_hom.algebra_map_to_algebra {R S} [CommSemiring R] [CommSemiring S] (i : «expr →+* » R S) :\n    @algebra_map R S _ _ i.to_algebra = i :=\n  rfl\n#align ring_hom.algebra_map_to_algebra ring_hom.algebra_map_to_algebra\n\n",
 "algebra_map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem algebra_map_smul (r : R) (m : M) : «expr • » ((algebra_map R A) r) m = «expr • » r m :=\n  (algebra_compatible_smul A r m).symm\n#align algebra_map_smul algebra_map_smul\n\n",
 "algebra_map_rat_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem algebra_map_rat_rat : algebra_map (exprℚ) (exprℚ) = RingHom.id (exprℚ) :=\n  subsingleton.elim _ _\n#align algebra_map_rat_rat algebra_map_rat_rat\n\n",
 "algebra_map_punit":
 "@[simp]\ntheorem algebra_map_punit (r : R) : algebra_map R PUnit r = PUnit.unit :=\n  rfl\n#align algebra_map_punit algebra_map_punit\n\n",
 "algebra_map_of_subsemiring_apply":
 "theorem algebra_map_of_subsemiring_apply (S : subsemiring R) (x : S) : algebra_map S R x = x :=\n  rfl\n#align algebra_map_of_subsemiring_apply algebra_map_of_subsemiring_apply\n\n",
 "algebra_map_of_subsemiring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem algebra_map_of_subsemiring (S : subsemiring R) : (algebra_map S R : «expr →+* » S R) = subsemiring.subtype S :=\n  rfl\n#align algebra_map_of_subsemiring algebra_map_of_subsemiring\n\n",
 "algebra_map_of_subring_apply":
 "theorem algebra_map_of_subring_apply {R : Type _} [CommRing R] (S : subring R) (x : S) : algebra_map S R x = x :=\n  rfl\n#align algebra_map_of_subring_apply algebra_map_of_subring_apply\n\n",
 "algebra_map_of_subring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem algebra_map_of_subring {R : Type _} [CommRing R] (S : subring R) :\n    (algebra_map S R : «expr →+* » S R) = subring.subtype S :=\n  rfl\n#align algebra_map_of_subring algebra_map_of_subring\n\n",
 "algebra_map_int_eq":
 "-- Lower the priority so that `algebra.id` is picked most of the time when working with\n-- `ℤ`-algebras. This is only an issue since `algebra.id ℤ` and `algebra_int ℤ` are not yet defeq.\n-- TODO: fix this by adding an `of_int` field to rings.\n/-- A special case of `eq_int_cast'` that happens to be true definitionally -/\n@[simp]\ntheorem algebra_map_int_eq : algebra_map ℤ R = Int.castRingHom R :=\n  rfl\n#align algebra_map_int_eq algebra_map_int_eq\n\n",
 "algebra_map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem algebra_map_injective [CommRing R] [Ring A] [nontrivial A] [algebra R A] [NoZeroSMulDivisors R A] :\n    function.injective (algebra_map R A) :=\n  suffices function.injective fun c : R => «expr • » c (1 : A)\n    by\n    convert this\n    ext\n    rw [algebra.smul_def, mul_one]\n  smul_left_injective R one_ne_zero\n#align algebra_map_injective algebra_map_injective\n\n",
 "algebra_map_eq_smul_one'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem algebra_map_eq_smul_one' : «expr⇑ » (algebra_map R A) = fun r => «expr • » r (1 : A) :=\n  funext algebra_map_eq_smul_one\n#align algebra_map_eq_smul_one' algebra_map_eq_smul_one'\n\n",
 "algebra_map_eq_smul_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem algebra_map_eq_smul_one (r : R) : algebra_map R A r = «expr • » r 1 :=\n  calc\n    algebra_map R A r = algebra_map R A r * 1 := (mul_one _).symm\n    _ = «expr • » r 1 := (algebra.smul_def r 1).symm\n    \n#align algebra_map_eq_smul_one algebra_map_eq_smul_one\n\n",
 "algebra_map_eq":
 "theorem _root_.ulift.algebra_map_eq (r : R) : algebra_map R (ULift A) r = ulift.up (algebra_map R A r) :=\n  rfl\n#align ulift.algebra_map_eq ulift.algebra_map_eq\n\n",
 "algebra_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[simp]\ntheorem algebra_map_apply (c : R) : algebra_map R («expr ᵐᵒᵖ» A) c = op (algebra_map R A c) :=\n  rfl\n#align algebra_map_apply algebra_map_apply\n\n",
 "algebra_map_End_eq_smul_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem algebra_map_End_eq_smul_id (a : R) : (algebra_map R (End R M)) a = «expr • » a linear_map.id :=\n  rfl\n#align algebra_map_End_eq_smul_id algebra_map_End_eq_smul_id\n\n",
 "algebra_map_End_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem algebra_map_End_apply (a : R) (m : M) : (algebra_map R (End R M)) a m = «expr • » a m :=\n  rfl\n#align algebra_map_End_apply algebra_map_End_apply\n\n",
 "algebra_ext":
 "-- We'll later use this to show `algebra ℤ M` is a subsingleton.\n/-- To prove two algebra structures on a fixed `[comm_semiring R] [semiring A]` agree,\nit suffices to check the `algebra_map`s agree.\n-/\n@[ext]\ntheorem algebra_ext {R : Type _} [CommSemiring R] {A : Type _} [Semiring A] (P Q : algebra R A)\n    (w :\n      ∀ r : R,\n        (haveI := P\n          algebra_map R A r) =\n          haveI := Q\n          algebra_map R A r) :\n    P = Q := by\n  rcases P with @⟨⟨P⟩⟩\n  rcases Q with @⟨⟨Q⟩⟩\n  congr\n  · funext r a\n    replace w := congr_arg (fun s => s * a) (w r)\n    simp only [← smul_def''] at w\n    apply w\n  · ext r\n    exact w r\n  · apply proof_irrel_heq\n  · apply proof_irrel_heq\n#align algebra_ext algebra_ext\n\n",
 "algebra_compatible_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- see note [lower instance priority]\n-- see note [lower instance priority]\n-- see note [lower instance priority]\ntheorem algebra_compatible_smul (r : R) (m : M) : «expr • » r m = «expr • » ((algebra_map R A) r) m := by\n  rw [← one_smul A m, ← smul_assoc, algebra.smul_def, mul_one, one_smul]\n#align algebra_compatible_smul algebra_compatible_smul\n\n",
 "End_is_unit_inv_apply_apply_of_is_unit":
 "theorem End_is_unit_inv_apply_apply_of_is_unit {f : module.End R M} (h : is_unit f) (x : M) : h.unit.inv (f x) = x :=\n  (by simp : (h.unit.inv * f) x = x)\n#align End_is_unit_inv_apply_apply_of_is_unit End_is_unit_inv_apply_apply_of_is_unit\n\n",
 "End_is_unit_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem End_is_unit_iff (f : module.End R M) : is_unit f ↔ function.bijective f :=\n  ⟨fun h =>\n    function.bijective_iff_has_inverse.mpr <|\n      ⟨h.unit.inv, ⟨End_is_unit_inv_apply_apply_of_is_unit h, End_is_unit_apply_inv_apply_of_is_unit h⟩⟩,\n    fun H =>\n    let e : «expr ≃ₗ[ ] » M R M := { f, Equiv.ofBijective f H with }\n    ⟨⟨_, e.symm, linear_map.ext e.right_inv, linear_map.ext e.left_inv⟩, rfl⟩⟩\n#align End_is_unit_iff End_is_unit_iff\n\n",
 "End_is_unit_apply_inv_apply_of_is_unit":
 "theorem End_is_unit_apply_inv_apply_of_is_unit {f : module.End R M} (h : is_unit f) (x : M) : f (h.unit.inv x) = x :=\n  show (f * h.unit.inv) x = x by simp\n#align End_is_unit_apply_inv_apply_of_is_unit End_is_unit_apply_inv_apply_of_is_unit\n\n",
 "End_algebra_map_is_unit_inv_apply_eq_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem End_algebra_map_is_unit_inv_apply_eq_iff' {x : R} (h : is_unit (algebra_map R (module.End R M) x)) (m m' : M) :\n    m' = h.unit⁻¹ m ↔ m = «expr • » x m' :=\n  { mp := fun H => ((congr_arg h.unit H).trans (End_is_unit_apply_inv_apply_of_is_unit h _)).symm\n    mpr := fun H =>\n      H.symm ▸ by\n        apply_fun h.unit using ((module.End_is_unit_iff _).mp h).injective\n        erw [End_is_unit_apply_inv_apply_of_is_unit]\n        rfl }\n#align End_algebra_map_is_unit_inv_apply_eq_iff' End_algebra_map_is_unit_inv_apply_eq_iff'\n\n",
 "End_algebra_map_is_unit_inv_apply_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem End_algebra_map_is_unit_inv_apply_eq_iff {x : R} (h : is_unit (algebra_map R (module.End R M) x)) (m m' : M) :\n    h.unit⁻¹ m = m' ↔ m = «expr • » x m' :=\n  { mp := fun H => ((congr_arg h.unit H).symm.trans (End_is_unit_apply_inv_apply_of_is_unit h _)).symm\n    mpr := fun H =>\n      H.symm ▸ by\n        apply_fun h.unit using ((module.End_is_unit_iff _).mp h).injective\n        erw [End_is_unit_apply_inv_apply_of_is_unit]\n        rfl }\n#align End_algebra_map_is_unit_inv_apply_eq_iff End_algebra_map_is_unit_inv_apply_eq_iff\n\n"}