{"to_sub_mul_action_one":
 "@[simp]\ntheorem to_sub_mul_action_one : (1 : Submodule R A).to_sub_mul_action = 1 :=\n  SetLike.ext fun x => mem_one.trans SubMulAction.mem_one'.symm\n#align to_sub_mul_action_one to_sub_mul_action_one\n\n",
 "supr_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_mul (s : ι → Submodule R A) (t : Submodule R A) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s i) * t =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s i * t) :=\n  map₂_supᵢ_left _ s t\n#align supr_mul supr_mul\n\n",
 "sup_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print sup_mul /-\ntheorem sup_mul : «expr ⊔ » M N * P = «expr ⊔ » (M * P) (N * P) :=\n  map₂_sup_left _ _ _ _\n#align sup_mul sup_mul\n-/\n\n",
 "span_pow":
 "theorem span_pow (s : Set A) : ∀ n : ℕ, span R s ^ n = span R (s ^ n)\n  | 0 => by rw [pow_zero, pow_zero, one_eq_span_one_set]\n  | n + 1 => by rw [pow_succ, pow_succ, span_pow, span_mul_span]\n#align span_pow span_pow\n\n",
 "span_mul_span":
 "theorem span_mul_span : span R S * span R T = span R (S * T) :=\n  map₂_span_span _ _ _ _\n#align span_mul_span span_mul_span\n\n",
 "smul_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_singleton (a : A) (M : Submodule R A) : «expr • » ({a} : Set A).up M = M.map (LinearMap.mulLeft R a) :=\n  by\n  conv_lhs => rw [← span_eq M]\n  change span _ _ * span _ _ = _\n  rw [span_mul_span]\n  apply le_antisymm\n  · rw [span_le]\n    rintro _ ⟨b, m, hb, hm, rfl⟩\n    rw [SetLike.mem_coe, mem_map, set.mem_singleton_iff.mp hb]\n    exact ⟨m, hm, rfl⟩\n  · rintro _ ⟨m, hm, rfl⟩\n    exact subset_span ⟨a, m, Set.mem_singleton a, hm, rfl⟩\n#align smul_singleton smul_singleton\n\n",
 "smul_le_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_le_smul {s t : SetSemiring A} {M N : Submodule R A} (h₁ : s.down ⊆ t.down) (h₂ : M ≤ N) :\n    «expr • » s M ≤ «expr • » t N :=\n  mul_le_mul (span_mono h₁) h₂\n#align smul_le_smul smul_le_smul\n\n",
 "smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_def (s : SetSemiring A) (P : Submodule R A) : «expr • » s P = span R s.down * P :=\n  rfl\n#align smul_def smul_def\n\n",
 "prod_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_span_singleton {ι : Type _} (s : Finset ι) (x : ι → A) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (span R ({x i} : Set A)) =\n      span R\n        {finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (x i)} :=\n  by rw [prod_span, Set.finset_prod_singleton]\n#align prod_span_singleton prod_span_singleton\n\n",
 "prod_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_span {ι : Type _} (s : Finset ι) (M : ι → Set A) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (Submodule.span R (M i)) =\n      Submodule.span R\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (M i)) :=\n  by\n  letI := Classical.decEq ι\n  refine' Finset.induction_on s _ _\n  · simp [one_eq_span, Set.singleton_one]\n  · intro _ _ H ih\n    rw [Finset.prod_insert H, Finset.prod_insert H, ih, span_mul_span]\n#align prod_span prod_span\n\n",
 "pow_to_add_submonoid":
 "theorem pow_to_add_submonoid {n : ℕ} (h : n ≠ 0) : (M ^ n).to_add_submonoid = M.to_add_submonoid ^ n :=\n  by\n  induction' n with n ih\n  · exact (h rfl).elim\n  · rw [pow_succ, pow_succ, mul_to_add_submonoid]\n    cases n\n    · rw [pow_zero, pow_zero, mul_one, ← mul_to_add_submonoid, mul_one]\n    · rw [ih n.succ_ne_zero]\n#align pow_to_add_submonoid pow_to_add_submonoid\n\n",
 "pow_subset_pow":
 "theorem pow_subset_pow {n : ℕ} : (↑M : Set A) ^ n ⊆ ↑(M ^ n : Submodule R A) :=\n  (pow_eq_span_pow_set M n).symm ▸ subset_span\n#align pow_subset_pow pow_subset_pow\n\n",
 "pow_mem_pow":
 "theorem pow_mem_pow {x : A} (hx : x ∈ M) (n : ℕ) : x ^ n ∈ M ^ n :=\n  pow_subset_pow _ <| Set.pow_mem_pow hx _\n#align pow_mem_pow pow_mem_pow\n\n",
 "pow_induction_on_right'":
 "/-- Dependent version of `submodule.pow_induction_on_right`. -/\n@[elab_as_elim]\nprotected theorem pow_induction_on_right' {C : ∀ (n : ℕ) (x), x ∈ M ^ n → Prop}\n    (hr : ∀ r : R, C 0 (algebraMap _ _ r) (algebraMap_mem r))\n    (hadd : ∀ x y i hx hy, C i x hx → C i y hy → C i (x + y) (add_mem ‹_› ‹_›))\n    (hmul : ∀ i x hx, C i x hx → ∀ m ∈ M, C i.succ (x * m) ((pow_succ' M i).symm ▸ mul_mem_mul hx H)) {x : A} {n : ℕ}\n    (hx : x ∈ M ^ n) : C n x hx := by\n  induction' n with n n_ih generalizing x\n  · rw [pow_zero] at hx\n    obtain ⟨r, rfl⟩ := hx\n    exact hr r\n  revert hx\n  simp_rw [pow_succ']\n  intro hx\n  exact\n    Submodule.mul_induction_on' (fun m hm x ih => hmul _ _ hm (n_ih _) _ ih)\n      (fun x hx y hy Cx Cy => hadd _ _ _ _ _ Cx Cy) hx\n#align pow_induction_on_right' pow_induction_on_right'\n\n",
 "pow_induction_on_right":
 "/-- To show a property on elements of `M ^ n` holds, it suffices to show that it holds for scalars,\nis closed under addition, and holds for `x * m` where `m ∈ M` and it holds for `x` -/\n@[elab_as_elim]\nprotected theorem pow_induction_on_right {C : A → Prop} (hr : ∀ r : R, C (algebraMap _ _ r))\n    (hadd : ∀ x y, C x → C y → C (x + y)) (hmul : ∀ x, C x → ∀ m ∈ M, C (x * m)) {x : A} {n : ℕ} (hx : x ∈ M ^ n) :\n    C x :=\n  Submodule.pow_induction_on_right' M hr (fun x y i hx hy => hadd x y) (fun i x hx => hmul _) hx\n#align pow_induction_on_right pow_induction_on_right\n\n",
 "pow_induction_on_left'":
 "/-- Dependent version of `submodule.pow_induction_on_left`. -/\n@[elab_as_elim]\nprotected theorem pow_induction_on_left' {C : ∀ (n : ℕ) (x), x ∈ M ^ n → Prop}\n    (hr : ∀ r : R, C 0 (algebraMap _ _ r) (algebraMap_mem r))\n    (hadd : ∀ x y i hx hy, C i x hx → C i y hy → C i (x + y) (add_mem ‹_› ‹_›))\n    (hmul : ∀ m ∈ M, ∀ (i x hx), C i x hx → C i.succ (m * x) (mul_mem_mul H hx)) {x : A} {n : ℕ} (hx : x ∈ M ^ n) :\n    C n x hx := by\n  induction' n with n n_ih generalizing x\n  · rw [pow_zero] at hx\n    obtain ⟨r, rfl⟩ := hx\n    exact hr r\n  exact\n    Submodule.mul_induction_on' (fun m hm x ih => hmul _ hm _ _ _ (n_ih ih))\n      (fun x hx y hy Cx Cy => hadd _ _ _ _ _ Cx Cy) hx\n#align pow_induction_on_left' pow_induction_on_left'\n\n",
 "pow_induction_on_left":
 "/-- To show a property on elements of `M ^ n` holds, it suffices to show that it holds for scalars,\nis closed under addition, and holds for `m * x` where `m ∈ M` and it holds for `x` -/\n@[elab_as_elim]\nprotected theorem pow_induction_on_left {C : A → Prop} (hr : ∀ r : R, C (algebraMap _ _ r))\n    (hadd : ∀ x y, C x → C y → C (x + y)) (hmul : ∀ m ∈ M, ∀ (x), C x → C (m * x)) {x : A} {n : ℕ} (hx : x ∈ M ^ n) :\n    C x :=\n  Submodule.pow_induction_on_left' M hr (fun x y i hx hy => hadd x y) (fun m hm i x hx => hmul _ hm _) hx\n#align pow_induction_on_left pow_induction_on_left\n\n",
 "pow_eq_span_pow_set":
 "theorem pow_eq_span_pow_set (n : ℕ) : M ^ n = span R ((M : Set A) ^ n) := by rw [← span_pow, span_eq]\n#align pow_eq_span_pow_set pow_eq_span_pow_set\n\n",
 "one_mul":
 "#print one_mul /-\n@[simp]\nprotected theorem one_mul : (1 : Submodule R A) * M = M :=\n  by\n  conv_lhs => rw [one_eq_span, ← span_eq M]\n  erw [span_mul_span, one_mul, span_eq]\n#align one_mul one_mul\n-/\n\n",
 "one_le_one_div":
 "#print one_le_one_div /-\n@[simp]\ntheorem one_le_one_div {I : Submodule R A} : 1 ≤ 1 / I ↔ I ≤ 1 :=\n  by\n  constructor; all_goals intro hI\n  · rwa [le_div_iff_mul_le, one_mul] at hI\n  · rwa [le_div_iff_mul_le, one_mul]\n#align one_le_one_div one_le_one_div\n-/\n\n",
 "one_le":
 "#print one_le /-\ntheorem one_le : (1 : Submodule R A) ≤ P ↔ (1 : A) ∈ P := by simpa only [one_eq_span, span_le, Set.singleton_subset_iff]\n#align one_le one_le\n-/\n\n",
 "one_eq_span_one_set":
 "theorem one_eq_span_one_set : (1 : Submodule R A) = span R 1 :=\n  one_eq_span\n#align one_eq_span_one_set one_eq_span_one_set\n\n",
 "one_eq_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem one_eq_span : (1 : Submodule R A) = «expr ∙ » R 1 :=\n  by\n  apply Submodule.ext\n  intro a\n  simp only [mem_one, mem_span_singleton, Algebra.smul_def, mul_one]\n#align one_eq_span one_eq_span\n\n",
 "one_eq_range":
 "theorem one_eq_range : (1 : Submodule R A) = (Algebra.linearMap R A).range :=\n  rfl\n#align one_eq_range one_eq_range\n\n",
 "mul_to_add_submonoid":
 "theorem mul_to_add_submonoid (M N : Submodule R A) :\n    (M * N).to_add_submonoid = M.to_add_submonoid * N.to_add_submonoid :=\n  by\n  dsimp [has_mul.mul]\n  simp_rw [← LinearMap.mulLeft_toAddMonoidHom R, LinearMap.mulLeft, ← map_to_add_submonoid _ N, map₂]\n  rw [supr_to_add_submonoid]\n  rfl\n#align mul_to_add_submonoid mul_to_add_submonoid\n\n",
 "mul_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem mul_supr (t : Submodule R A) (s : ι → Submodule R A) :\n    t * «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s i) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (t * s i) :=\n  map₂_supᵢ_right _ t s\n#align mul_supr mul_supr\n\n",
 "mul_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print mul_sup /-\ntheorem mul_sup : M * «expr ⊔ » N P = «expr ⊔ » (M * N) (M * P) :=\n  map₂_sup_right _ _ _ _\n#align mul_sup mul_sup\n-/\n\n",
 "mul_subset_mul":
 "theorem mul_subset_mul : (↑M : Set A) * (↑N : Set A) ⊆ (↑(M * N) : Set A) :=\n  image2_subset_map₂ (Algebra.lmul R A).to_linear_map M N\n#align mul_subset_mul mul_subset_mul\n\n",
 "mul_one_div_le_one":
 "theorem mul_one_div_le_one {I : Submodule R A} : I * (1 / I) ≤ 1 :=\n  by\n  rw [Submodule.mul_le]\n  intro m hm n hn\n  rw [Submodule.mem_div_iff_forall_mul_mem] at hn\n  rw [mul_comm]\n  exact hn m hm\n#align mul_one_div_le_one mul_one_div_le_one\n\n",
 "mul_one":
 "#print mul_one /-\n@[simp]\nprotected theorem mul_one : M * 1 = M :=\n  by\n  conv_lhs => rw [one_eq_span, ← span_eq M]\n  erw [span_mul_span, mul_one, span_eq]\n#align mul_one mul_one\n-/\n\n",
 "mul_mem_mul_rev":
 "theorem mul_mem_mul_rev (hm : m ∈ M) (hn : n ∈ N) : n * m ∈ M * N :=\n  mul_comm m n ▸ mul_mem_mul hm hn\n#align mul_mem_mul_rev mul_mem_mul_rev\n\n",
 "mul_mem_mul":
 "theorem mul_mem_mul (hm : m ∈ M) (hn : n ∈ N) : m * n ∈ M * N :=\n  apply_mem_map₂ _ hm hn\n#align mul_mem_mul mul_mem_mul\n\n",
 "mul_le_mul_right":
 "#print mul_le_mul_right /-\ntheorem mul_le_mul_right (h : N ≤ P) : M * N ≤ M * P :=\n  map₂_le_map₂_right h\n#align mul_le_mul_right mul_le_mul_right\n-/\n\n",
 "mul_le_mul_left":
 "#print mul_le_mul_left /-\ntheorem mul_le_mul_left (h : M ≤ N) : M * P ≤ N * P :=\n  map₂_le_map₂_left h\n#align mul_le_mul_left mul_le_mul_left\n-/\n\n",
 "mul_le_mul":
 "#print mul_le_mul /-\n@[mono]\ntheorem mul_le_mul (hmp : M ≤ P) (hnq : N ≤ Q) : M * N ≤ P * Q :=\n  map₂_le_map₂ hmp hnq\n#align mul_le_mul mul_le_mul\n-/\n\n",
 "mul_le":
 "theorem mul_le : M * N ≤ P ↔ ∀ m ∈ M, ∀ n ∈ N, m * n ∈ P :=\n  map₂_le\n#align mul_le mul_le\n\n",
 "mul_induction_on'":
 "/-- A dependent version of `mul_induction_on`. -/\n@[elab_as_elim]\nprotected theorem mul_induction_on' {C : ∀ r, r ∈ M * N → Prop} (hm : ∀ m ∈ M, ∀ n ∈ N, C (m * n) (mul_mem_mul ‹_› ‹_›))\n    (ha : ∀ x hx y hy, C x hx → C y hy → C (x + y) (add_mem ‹_› ‹_›)) {r : A} (hr : r ∈ M * N) : C r hr :=\n  by\n  refine' exists.elim _ fun (hr : r ∈ M * N) (hc : C r hr) => hc\n  exact\n    Submodule.mul_induction_on hr (fun x hx y hy => ⟨_, hm _ hx _ hy⟩) fun x y ⟨_, hx⟩ ⟨_, hy⟩ => ⟨_, ha _ _ _ _ hx hy⟩\n#align mul_induction_on' mul_induction_on'\n\n",
 "mul_induction_on":
 "@[elab_as_elim]\nprotected theorem mul_induction_on {C : A → Prop} {r : A} (hr : r ∈ M * N) (hm : ∀ m ∈ M, ∀ n ∈ N, C (m * n))\n    (ha : ∀ x y, C x → C y → C (x + y)) : C r :=\n  by\n  rw [← mem_to_add_submonoid, mul_to_add_submonoid] at hr\n  exact AddSubmonoid.mul_induction_on hr hm ha\n#align mul_induction_on mul_induction_on\n\n",
 "mul_eq_span_mul_set":
 "theorem mul_eq_span_mul_set (s t : Submodule R A) : s * t = span R ((s : Set A) * (t : Set A)) :=\n  map₂_eq_span_image2 _ s t\n#align mul_eq_span_mul_set mul_eq_span_mul_set\n\n",
 "mul_comm":
 "#print mul_comm /-\nprotected theorem mul_comm : M * N = N * M :=\n  le_antisymm (mul_le.2 fun r hrm s hsn => mul_mem_mul_rev hsn hrm)\n    (mul_le.2 fun r hrn s hsm => mul_mem_mul_rev hsm hrn)\n#align mul_comm mul_comm\n-/\n\n",
 "mul_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem mul_bot : M * «expr⊥» = «expr⊥» :=\n  map₂_bot_right _ _\n#align mul_bot mul_bot\n\n",
 "mem_span_singleton_mul":
 "theorem mem_span_singleton_mul {x y : A} : x ∈ span R {y} * P ↔ ∃ z ∈ P, y * z = x :=\n  by\n  simp_rw [(· * ·), map₂_span_singleton_eq_map, exists_prop]\n  rfl\n#align mem_span_singleton_mul mem_span_singleton_mul\n\n",
 "mem_span_mul_finite_of_mem_span_mul":
 "theorem mem_span_mul_finite_of_mem_span_mul {R A} [Semiring R] [AddCommMonoid A] [Mul A] [Module R A] {S : Set A}\n    {S' : Set A} {x : A} (hx : x ∈ span R (S * S')) :\n    ∃ T T' : Finset A, ↑T ⊆ S ∧ ↑T' ⊆ S' ∧ x ∈ span R (T * T' : Set A) :=\n  by\n  obtain ⟨U, h, hU⟩ := mem_span_finite_of_mem_span hx\n  obtain ⟨T, T', hS, hS', h⟩ := Finset.subset_mul h\n  use T, T', hS, hS'\n  have h' : (U : Set A) ⊆ T * T' := by assumption_mod_cast\n  have h'' := span_mono h' hU\n  assumption\n#align mem_span_mul_finite_of_mem_span_mul mem_span_mul_finite_of_mem_span_mul\n\n",
 "mem_span_mul_finite_of_mem_mul":
 "theorem mem_span_mul_finite_of_mem_mul {P Q : Submodule R A} {x : A} (hx : x ∈ P * Q) :\n    ∃ T T' : Finset A, (T : Set A) ⊆ P ∧ (T' : Set A) ⊆ Q ∧ x ∈ span R (T * T' : Set A) :=\n  Submodule.mem_span_mul_finite_of_mem_span_mul\n    (by rwa [← Submodule.span_eq P, ← Submodule.span_eq Q, Submodule.span_mul_span] at hx)\n#align mem_span_mul_finite_of_mem_mul mem_span_mul_finite_of_mem_mul\n\n",
 "mem_one'":
 "theorem mem_one' {x : A} : x ∈ (1 : SubMulAction R A) ↔ ∃ y, algebraMap R A y = x :=\n  exists_congr fun r => by rw [algebra_map_eq_smul_one]\n#align mem_one' mem_one'\n\n",
 "mem_one":
 "@[simp]\ntheorem mem_one {x : A} : x ∈ (1 : Submodule R A) ↔ ∃ y, algebraMap R A y = x :=\n  iff.rfl\n#align mem_one mem_one\n\n",
 "mem_mul_span_singleton":
 "theorem mem_mul_span_singleton {x y : A} : x ∈ P * span R {y} ↔ ∃ z ∈ P, z * y = x :=\n  by\n  simp_rw [(· * ·), map₂_span_singleton_eq_map_flip, exists_prop]\n  rfl\n#align mem_mul_span_singleton mem_mul_span_singleton\n\n",
 "mem_div_iff_smul_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_div_iff_smul_subset {x : A} {I J : Submodule R A} : x ∈ I / J ↔ «expr • » x (J : Set A) ⊆ I :=\n  ⟨fun h y ⟨y', hy', xy'_eq_y⟩ => by\n    rw [← xy'_eq_y]\n    apply h\n    assumption, fun h y hy => h (Set.smul_mem_smul_set hy)⟩\n#align mem_div_iff_smul_subset mem_div_iff_smul_subset\n\n",
 "mem_div_iff_forall_mul_mem":
 "theorem mem_div_iff_forall_mul_mem {x : A} {I J : Submodule R A} : x ∈ I / J ↔ ∀ y ∈ J, x * y ∈ I :=\n  iff.refl _\n#align mem_div_iff_forall_mul_mem mem_div_iff_forall_mul_mem\n\n",
 "map_unop_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\ntheorem map_unop_pow (n : ℕ) (M : Submodule R («expr ᵐᵒᵖ» A)) :\n    map (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)).symm : «expr →ₗ[ ] » («expr ᵐᵒᵖ» A) R A) (M ^ n) =\n      map (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)).symm : «expr →ₗ[ ] » («expr ᵐᵒᵖ» A) R A) M ^ n :=\n  by rw [← comap_equiv_eq_map_symm, ← comap_equiv_eq_map_symm, comap_op_pow]\n#align map_unop_pow map_unop_pow\n\n",
 "map_unop_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[simp]\ntheorem map_unop_one :\n    map (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)).symm : «expr →ₗ[ ] » («expr ᵐᵒᵖ» A) R A)\n        (1 : Submodule R («expr ᵐᵒᵖ» A)) =\n      1 :=\n  by rw [← comap_equiv_eq_map_symm, comap_op_one]\n#align map_unop_one map_unop_one\n\n",
 "map_unop_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\ntheorem map_unop_mul (M N : Submodule R («expr ᵐᵒᵖ» A)) :\n    map (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)).symm : «expr →ₗ[ ] » («expr ᵐᵒᵖ» A) R A) (M * N) =\n      map (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)).symm : «expr →ₗ[ ] » («expr ᵐᵒᵖ» A) R A) N *\n        map (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)).symm : «expr →ₗ[ ] » («expr ᵐᵒᵖ» A) R A) M :=\n  have :\n    function.injective (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)) : «expr →ₗ[ ] » A R («expr ᵐᵒᵖ» A)) :=\n    LinearEquiv.injective _\n  map_injective_of_injective this <| by\n    rw [← map_comp, map_op_mul, ← map_comp, ← map_comp, LinearEquiv.comp_coe, LinearEquiv.symm_trans_self,\n      LinearEquiv.refl_toLinearMap, map_id, map_id, map_id]\n#align map_unop_mul map_unop_mul\n\n",
 "map_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n#print map_pow /-\nprotected theorem map_pow {A'} [Semiring A'] [Algebra R A'] (f : «expr →ₐ[ ] » A R A') (n : ℕ) :\n    map f.to_linear_map (M ^ n) = map f.to_linear_map M ^ n :=\n  map_pow (mapHom f) M n\n#align map_pow map_pow\n-/\n\n",
 "map_op_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\ntheorem map_op_pow (n : ℕ) :\n    map (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)) : «expr →ₗ[ ] » A R («expr ᵐᵒᵖ» A)) (M ^ n) =\n      map (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)) : «expr →ₗ[ ] » A R («expr ᵐᵒᵖ» A)) M ^ n :=\n  by rw [map_equiv_eq_comap_symm, map_equiv_eq_comap_symm, comap_unop_pow]\n#align map_op_pow map_op_pow\n\n",
 "map_op_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[simp]\ntheorem map_op_one :\n    map (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)) : «expr →ₗ[ ] » A R («expr ᵐᵒᵖ» A)) (1 : Submodule R A) =\n      1 :=\n  by\n  ext\n  induction x using MulOpposite.rec'\n  simp\n#align map_op_one map_op_one\n\n",
 "map_op_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\ntheorem map_op_mul :\n    map (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)) : «expr →ₗ[ ] » A R («expr ᵐᵒᵖ» A)) (M * N) =\n      map (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)) : «expr →ₗ[ ] » A R («expr ᵐᵒᵖ» A)) N *\n        map (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)) : «expr →ₗ[ ] » A R («expr ᵐᵒᵖ» A)) M :=\n  by\n  apply le_antisymm\n  · simp_rw [map_le_iff_le_comap]\n    refine' mul_le.2 fun m hm n hn => _\n    rw [mem_comap, map_equiv_eq_comap_symm, map_equiv_eq_comap_symm]\n    show op n * op m ∈ _\n    exact mul_mem_mul hn hm\n  · refine' mul_le.2 (MulOpposite.rec' fun m hm => MulOpposite.rec' fun n hn => _)\n    rw [Submodule.mem_map_equiv] at hm hn⊢\n    exact mul_mem_mul hn hm\n#align map_op_mul map_op_mul\n\n",
 "map_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n#print map_one /-\nprotected theorem map_one {A'} [Semiring A'] [Algebra R A'] (f : «expr →ₐ[ ] » A R A') :\n    map f.to_linear_map (1 : Submodule R A) = 1 := by\n  ext\n  simp\n#align map_one map_one\n-/\n\n",
 "map_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n#print map_mul /-\nprotected theorem map_mul {A'} [Semiring A'] [Algebra R A'] (f : «expr →ₐ[ ] » A R A') :\n    map f.to_linear_map (M * N) = map f.to_linear_map M * map f.to_linear_map N :=\n  calc\n    map f.to_linear_map (M * N) =\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          ((N.map (LinearMap.mul R A i)).map f.to_linear_map) :=\n      map_supᵢ _ _\n    _ = map f.to_linear_map M * map f.to_linear_map N :=\n      by\n      apply congr_arg Sup\n      ext S\n      constructor <;> rintro ⟨y, hy⟩\n      · use f y, mem_map.mpr ⟨y.1, y.2, rfl⟩\n        refine' trans _ hy\n        ext\n        simp\n      · obtain ⟨y', hy', fy_eq⟩ := mem_map.mp y.2\n        use y', hy'\n        refine' trans _ hy\n        rw [f.to_linear_map_apply] at fy_eq\n        ext\n        simp [fy_eq]\n    \n#align map_mul map_mul\n-/\n\n",
 "map_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n#print map_div /-\n@[simp]\nprotected theorem map_div {B : Type _} [CommSemiring B] [Algebra R B] (I J : Submodule R A) (h : «expr ≃ₐ[ ] » A R B) :\n    (I / J).map h.to_linear_map = I.map h.to_linear_map / J.map h.to_linear_map :=\n  by\n  ext x\n  simp only [mem_map, mem_div_iff_forall_mul_mem]\n  constructor\n  · rintro ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩\n    exact ⟨x * y, hx _ hy, h.map_mul x y⟩\n  · rintro hx\n    refine' ⟨h.symm x, fun z hz => _, h.apply_symm_apply x⟩\n    obtain ⟨xz, xz_mem, hxz⟩ := hx (h z) ⟨z, hz, rfl⟩\n    convert xz_mem\n    apply h.injective\n    erw [h.map_mul, h.apply_symm_apply, hxz]\n#align map_div map_div\n-/\n\n",
 "le_self_mul_one_div":
 "/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:132:4: warning: unsupported: rw with cfg: { occs := occurrences.pos[occurrences.pos] «expr[ ,]»([1]) } -/\ntheorem le_self_mul_one_div {I : Submodule R A} (hI : I ≤ 1) : I ≤ I * (1 / I) :=\n  by\n  rw [← mul_one I]\n  apply mul_le_mul_right (one_le_one_div.mpr hI)\n#align le_self_mul_one_div le_self_mul_one_div\n\n",
 "le_pow_to_add_submonoid":
 "theorem le_pow_to_add_submonoid {n : ℕ} : M.to_add_submonoid ^ n ≤ (M ^ n).to_add_submonoid :=\n  by\n  obtain rfl | hn := Decidable.eq_or_ne n 0\n  · rw [pow_zero, pow_zero]\n    exact le_one_to_add_submonoid\n  · exact (pow_to_add_submonoid M hn).ge\n#align le_pow_to_add_submonoid le_pow_to_add_submonoid\n\n",
 "le_one_to_add_submonoid":
 "theorem le_one_to_add_submonoid : 1 ≤ (1 : Submodule R A).to_add_submonoid :=\n  by\n  rintro x ⟨n, rfl⟩\n  exact ⟨n, map_natCast (algebraMap R A) n⟩\n#align le_one_to_add_submonoid le_one_to_add_submonoid\n\n",
 "le_div_iff_mul_le":
 "#print le_div_iff_mul_le /-\ntheorem le_div_iff_mul_le {I J K : Submodule R A} : I ≤ J / K ↔ I * K ≤ J := by rw [le_div_iff, mul_le]\n#align le_div_iff_mul_le le_div_iff_mul_le\n-/\n\n",
 "le_div_iff":
 "#print le_div_iff /-\ntheorem le_div_iff {I J K : Submodule R A} : I ≤ J / K ↔ ∀ x ∈ I, ∀ z ∈ K, x * z ∈ J :=\n  iff.refl _\n#align le_div_iff le_div_iff\n-/\n\n",
 "comap_unop_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\ntheorem comap_unop_pow (n : ℕ) :\n    comap (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)).symm : «expr →ₗ[ ] » («expr ᵐᵒᵖ» A) R A) (M ^ n) =\n      comap (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)).symm : «expr →ₗ[ ] » («expr ᵐᵒᵖ» A) R A) M ^ n :=\n  (equivOpposite : «expr ≃+* » (Submodule R («expr ᵐᵒᵖ» A)) _).symm.map_pow (op M) n\n#align comap_unop_pow comap_unop_pow\n\n",
 "comap_unop_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[simp]\ntheorem comap_unop_one :\n    comap (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)).symm : «expr →ₗ[ ] » («expr ᵐᵒᵖ» A) R A)\n        (1 : Submodule R A) =\n      1 :=\n  by rw [← map_equiv_eq_comap_symm, map_op_one]\n#align comap_unop_one comap_unop_one\n\n",
 "comap_unop_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\ntheorem comap_unop_mul :\n    comap (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)).symm : «expr →ₗ[ ] » («expr ᵐᵒᵖ» A) R A) (M * N) =\n      comap (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)).symm : «expr →ₗ[ ] » («expr ᵐᵒᵖ» A) R A) N *\n        comap (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)).symm : «expr →ₗ[ ] » («expr ᵐᵒᵖ» A) R A) M :=\n  by simp_rw [← map_equiv_eq_comap_symm, map_op_mul]\n#align comap_unop_mul comap_unop_mul\n\n",
 "comap_op_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\ntheorem comap_op_pow (n : ℕ) (M : Submodule R («expr ᵐᵒᵖ» A)) :\n    comap (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)) : «expr →ₗ[ ] » A R («expr ᵐᵒᵖ» A)) (M ^ n) =\n      comap (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)) : «expr →ₗ[ ] » A R («expr ᵐᵒᵖ» A)) M ^ n :=\n  op_injective <| (equivOpposite : «expr ≃+* » (Submodule R («expr ᵐᵒᵖ» A)) _).map_pow M n\n#align comap_op_pow comap_op_pow\n\n",
 "comap_op_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[simp]\ntheorem comap_op_one :\n    comap (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)) : «expr →ₗ[ ] » A R («expr ᵐᵒᵖ» A))\n        (1 : Submodule R («expr ᵐᵒᵖ» A)) =\n      1 :=\n  by\n  ext\n  simp\n#align comap_op_one comap_op_one\n\n",
 "comap_op_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\ntheorem comap_op_mul (M N : Submodule R («expr ᵐᵒᵖ» A)) :\n    comap (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)) : «expr →ₗ[ ] » A R («expr ᵐᵒᵖ» A)) (M * N) =\n      comap (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)) : «expr →ₗ[ ] » A R («expr ᵐᵒᵖ» A)) N *\n        comap (↑(opLinearEquiv R : «expr ≃ₗ[ ] » A R («expr ᵐᵒᵖ» A)) : «expr →ₗ[ ] » A R («expr ᵐᵒᵖ» A)) M :=\n  by simp_rw [comap_equiv_eq_map_symm, map_unop_mul]\n#align comap_op_mul comap_op_mul\n\n",
 "bot_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem bot_mul : «expr⊥» * M = «expr⊥» :=\n  map₂_bot_left _ _\n#align bot_mul bot_mul\n\n",
 "algebra_map_mem":
 "theorem algebra_map_mem (r : R) : algebraMap R A r ∈ (1 : Submodule R A) :=\n  LinearMap.mem_range_self _ _\n#align algebra_map_mem algebra_map_mem\n\n"}