{"lie_top_eq_of_span_sup_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem lie_top_eq_of_span_sup_eq_top (N : lie_submodule R L M) :\n    (↑(«expr⁅ , ⁆» («expr⊤» : lie_ideal R L) N) : submodule R M) =\n      «expr ⊔ » ((N : submodule R M).map (to_endomorphism R L M x)) (↑(«expr⁅ , ⁆» I N) : submodule R M) :=\n  by\n  simp only [lie_ideal_oper_eq_linear_span', submodule.sup_span, mem_top, exists_prop, exists_true_left,\n    submodule.map_coe, to_endomorphism_apply_apply]\n  refine' le_antisymm (submodule.span_le.mpr _) (submodule.span_mono fun z hz => _)\n  · rintro z ⟨y, n, hn : n ∈ N, rfl⟩\n    obtain ⟨t, z, hz, rfl⟩ := exists_smul_add_of_span_sup_eq_top hxI y\n    simp only [SetLike.mem_coe, submodule.span_union, submodule.mem_sup]\n    exact\n      ⟨«expr • » t («expr⁅ , ⁆» x n), submodule.subset_span ⟨«expr • » t n, N.smul_mem' t hn, lie_smul t x n⟩,\n        «expr⁅ , ⁆» z n, submodule.subset_span ⟨z, hz, n, hn, rfl⟩, by simp⟩\n  · rcases hz with (⟨m, hm, rfl⟩ | ⟨y, hy, m, hm, rfl⟩)\n    exacts[⟨x, m, hm, rfl⟩, ⟨y, m, hm, rfl⟩]\n#align lie_top_eq_of_span_sup_eq_top lie_top_eq_of_span_sup_eq_top\n\n",
 "lcs_le_lcs_of_is_nilpotent_span_sup_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem lcs_le_lcs_of_is_nilpotent_span_sup_eq_top {n i j : ℕ} (hxn : to_endomorphism R L M x ^ n = 0)\n    (hIM : lower_central_series R L M i ≤ I.lcs M j) : lower_central_series R L M (i + n) ≤ I.lcs M (j + 1) :=\n  by\n  suffices\n    ∀ l,\n      ((«expr⊤» : lie_ideal R L).lcs M (i + l) : submodule R M) ≤\n        «expr ⊔ » ((I.lcs M j : submodule R M).map (to_endomorphism R L M x ^ l)) (I.lcs M (j + 1) : submodule R M)\n    by simpa only [bot_sup_eq, lie_ideal.incl_coe, submodule.map_zero, hxn] using this n\n  intro l\n  induction' l with l ih\n  · simp only [add_zero, lie_ideal.lcs_succ, pow_zero, linear_map.one_eq_id, submodule.map_id]\n    exact le_sup_of_le_left hIM\n  · simp only [lie_ideal.lcs_succ, i.add_succ l, lie_top_eq_of_span_sup_eq_top hxI, sup_le_iff]\n    refine' ⟨(submodule.map_mono ih).trans _, le_sup_of_le_right _⟩\n    · rw [submodule.map_sup, ← submodule.map_comp, ← linear_map.mul_eq_comp, ← pow_succ, ← I.lcs_succ]\n      exact sup_le_sup_left coe_map_to_endomorphism_le _\n    · refine' le_trans (mono_lie_right _ _ I _) (mono_lie_right _ _ I hIM)\n      exact antitone_lower_central_series R L M le_self_add\n#align lcs_le_lcs_of_is_nilpotent_span_sup_eq_top lcs_le_lcs_of_is_nilpotent_span_sup_eq_top\n\n",
 "is_nilpotent_of_is_nilpotent_span_sup_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_nilpotent_of_is_nilpotent_span_sup_eq_top (hnp : is_nilpotent <| to_endomorphism R L M x)\n    (hIM : is_nilpotent R I M) : is_nilpotent R L M :=\n  by\n  obtain ⟨n, hn⟩ := hnp\n  obtain ⟨k, hk⟩ := hIM\n  have hk' : I.lcs M k = «expr⊥» := by simp only [← coe_to_submodule_eq_iff, I.coe_lcs_eq, hk, bot_coe_submodule]\n  suffices ∀ l, lower_central_series R L M (l * n) ≤ I.lcs M l\n    by\n    use k * n\n    simpa [hk'] using this k\n  intro l\n  induction' l with l ih\n  · simp\n  · exact (l.succ_mul n).symm ▸ lcs_le_lcs_of_is_nilpotent_span_sup_eq_top hxI hn ih\n#align is_nilpotent_of_is_nilpotent_span_sup_eq_top is_nilpotent_of_is_nilpotent_span_sup_eq_top\n\n",
 "is_nilpotent_iff_forall":
 "/-- Engel's theorem. -/\ntheorem lie_algebra.is_nilpotent_iff_forall :\n    lie_algebra.is_nilpotent R L ↔ ∀ x, is_nilpotent <| lie_algebra.ad R L x :=\n  lie_module.is_nilpotent_iff_forall\n#align lie_algebra.is_nilpotent_iff_forall lie_algebra.is_nilpotent_iff_forall\n\n",
 "is_engelian_of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem lie_algebra.is_engelian_of_subsingleton [subsingleton L] : lie_algebra.is_engelian R L :=\n  by\n  intro M _i1 _i2 _i3 _i4 h\n  use 1\n  suffices («expr⊤» : lie_ideal R L) = «expr⊥» by simp [this]\n  haveI := (lie_submodule.subsingleton_iff R L L).mpr infer_instance\n  apply subsingleton.elim\n#align lie_algebra.is_engelian_of_subsingleton lie_algebra.is_engelian_of_subsingleton\n\n",
 "is_engelian_of_is_noetherian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- *Engel's theorem*.\n\nNote that this implies all traditional forms of Engel's theorem via\n`lie_module.nontrivial_max_triv_of_is_nilpotent`, `lie_module.is_nilpotent_iff_forall`,\n`lie_algebra.is_nilpotent_iff_forall`. -/\ntheorem lie_algebra.is_engelian_of_is_noetherian : lie_algebra.is_engelian R L :=\n  by\n  intro M _i1 _i2 _i3 _i4 h\n  rw [← is_nilpotent_range_to_endomorphism_iff]\n  let L' := (to_endomorphism R L M).range\n  replace h : ∀ y : L', is_nilpotent (y : module.End R M)\n  · rintro ⟨-, ⟨y, rfl⟩⟩\n    simp [h]\n  change lie_module.is_nilpotent R L' M\n  let s := { K : lie_subalgebra R L' | lie_algebra.is_engelian R K }\n  have hs : s.nonempty := ⟨«expr⊥», lie_algebra.is_engelian_of_subsingleton⟩\n  suffices «expr⊤» ∈ s by\n    rw [← is_nilpotent_of_top_iff]\n    apply this M\n    simp [lie_subalgebra.to_endomorphism_eq, h]\n  have : ∀ K ∈ s, K ≠ «expr⊤» → ∃ K' ∈ s, K < K' :=\n    by\n    rintro K (hK₁ : lie_algebra.is_engelian R K) hK₂\n    apply lie_algebra.exists_engelian_lie_subalgebra_of_lt_normalizer hK₁\n    apply lt_of_le_of_ne K.le_normalizer\n    rw [ne.def, eq_comm, K.normalizer_eq_self_iff, ← ne.def, ← lie_submodule.nontrivial_iff_ne_bot R K]\n    have : nontrivial («expr ⧸ » L' K.to_lie_submodule) :=\n      by\n      replace hK₂ : K.to_lie_submodule ≠ «expr⊤» := by\n        rwa [ne.def, ← lie_submodule.coe_to_submodule_eq_iff, K.coe_to_lie_submodule, lie_submodule.top_coe_submodule, ←\n          lie_subalgebra.top_coe_submodule, K.coe_to_submodule_eq_iff]\n      exact submodule.quotient.nontrivial_of_lt_top _ hK₂.lt_top\n    have : lie_module.is_nilpotent R K («expr ⧸ » L' K.to_lie_submodule) :=\n      by\n      refine' hK₁ _ fun x => _\n      have hx := lie_algebra.is_nilpotent_ad_of_is_nilpotent (h x)\n      exact module.End.is_nilpotent.mapq _ hx\n    exact nontrivial_max_triv_of_is_nilpotent R K («expr ⧸ » L' K.to_lie_submodule)\n  haveI _i5 : is_noetherian R L' :=\n    is_noetherian_of_surjective L _ (linear_map.range_range_restrict (to_endomorphism R L M))\n  obtain ⟨K, hK₁, hK₂⟩ :=\n    well_founded.well_founded_iff_has_max'.mp (lie_subalgebra.well_founded_of_noetherian R L') s hs\n  have hK₃ : K = «expr⊤» := by\n    by_contra contra\n    obtain ⟨K', hK'₁, hK'₂⟩ := this K hK₁ contra\n    specialize hK₂ K' hK'₁ (le_of_lt hK'₂)\n    replace hK'₂ := (ne_of_lt hK'₂).symm\n    contradiction\n  exact hK₃ ▸ hK₁\n#align lie_algebra.is_engelian_of_is_noetherian lie_algebra.is_engelian_of_is_noetherian\n\n",
 "is_engelian_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ⁅ ⁆ » -/\ntheorem lie_equiv.is_engelian_iff (e : «expr ≃ₗ⁅ ⁆ » L R L₂) :\n    lie_algebra.is_engelian.{u₁, u₂, u₄} R L ↔ lie_algebra.is_engelian.{u₁, u₃, u₄} R L₂ :=\n  ⟨e.surjective.is_engelian, e.symm.surjective.is_engelian⟩\n#align lie_equiv.is_engelian_iff lie_equiv.is_engelian_iff\n\n",
 "is_engelian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ⁅ ⁆ » -/\ntheorem function.surjective.is_engelian {f : «expr →ₗ⁅ ⁆ » L R L₂} (hf : function.surjective f)\n    (h : lie_algebra.is_engelian.{u₁, u₂, u₄} R L) : lie_algebra.is_engelian.{u₁, u₃, u₄} R L₂ :=\n  by\n  intro M _i1 _i2 _i3 _i4 h'\n  letI : lie_ring_module L M := lie_ring_module.comp_lie_hom M f\n  letI : lie_module R L M := comp_lie_hom M f\n  have hnp : ∀ x, is_nilpotent (to_endomorphism R L M x) := fun x => h' (f x)\n  have surj_id : function.surjective (linear_map.id : «expr →ₗ[ ] » M R M) := function.surjective_id\n  haveI : lie_module.is_nilpotent R L M := h M hnp\n  apply hf.lie_module_is_nilpotent surj_id\n  simp\n#align function.surjective.is_engelian function.surjective.is_engelian\n\n",
 "exists_smul_add_of_span_sup_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2022 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\ntheorem exists_smul_add_of_span_sup_eq_top (y : L) : ∃ t : R, ∃ z ∈ I, y = «expr • » t x + z :=\n  by\n  have hy : y ∈ («expr⊤» : submodule R L) := submodule.mem_top\n  simp only [← hxI, submodule.mem_sup, submodule.mem_span_singleton] at hy\n  obtain ⟨-, ⟨t, rfl⟩, z, hz, rfl⟩ := hy\n  exact ⟨t, z, hz, rfl⟩\n#align exists_smul_add_of_span_sup_eq_top exists_smul_add_of_span_sup_eq_top\n\n",
 "exists_engelian_lie_subalgebra_of_lt_normalizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ⁅ ⁆ » -/\ntheorem lie_algebra.exists_engelian_lie_subalgebra_of_lt_normalizer {K : lie_subalgebra R L}\n    (hK₁ : lie_algebra.is_engelian.{u₁, u₂, u₄} R K) (hK₂ : K < K.normalizer) :\n    ∃ (K' : lie_subalgebra R L)(hK' : lie_algebra.is_engelian.{u₁, u₂, u₄} R K'), K < K' :=\n  by\n  obtain ⟨x, hx₁, hx₂⟩ := SetLike.exists_of_lt hK₂\n  let K' : lie_subalgebra R L :=\n    { «expr ⊔ » («expr ∙ » R x) (K : submodule R L) with\n      lie_mem' := fun y z => lie_subalgebra.lie_mem_sup_of_mem_normalizer hx₁ }\n  have hxK' : x ∈ K' := submodule.mem_sup_left (submodule.subset_span (Set.mem_singleton _))\n  have hKK' : K ≤ K' := (lie_subalgebra.coe_submodule_le_coe_submodule K K').mp le_sup_right\n  have hK' : K' ≤ K.normalizer := by\n    rw [← lie_subalgebra.coe_submodule_le_coe_submodule]\n    exact sup_le ((submodule.span_singleton_le_iff_mem _ _).mpr hx₁) hK₂.le\n  refine' ⟨K', _, lt_iff_le_and_ne.mpr ⟨hKK', fun contra => hx₂ (contra.symm ▸ hxK')⟩⟩\n  intro M _i1 _i2 _i3 _i4 h\n  obtain ⟨I, hI₁ : (I : lie_subalgebra R K') = lie_subalgebra.of_le hKK'⟩ :=\n    lie_subalgebra.exists_nested_lie_ideal_of_le_normalizer hKK' hK'\n  have hI₂ : «expr ⊔ » («expr ∙ » R (⟨x, hxK'⟩ : K')) I = «expr⊤» :=\n    by\n    rw [← lie_ideal.coe_to_lie_subalgebra_to_submodule R K' I, hI₁]\n    apply submodule.map_injective_of_injective (K' : submodule R L).injective_subtype\n    simpa\n  have e : «expr ≃ₗ⁅ ⁆ » K R I :=\n    (lie_subalgebra.equiv_of_le hKK').trans (lie_equiv.of_eq _ _ ((lie_subalgebra.coe_set_eq _ _).mpr hI₁.symm))\n  have hI₃ : lie_algebra.is_engelian R I := e.is_engelian_iff.mp hK₁\n  exact lie_submodule.is_nilpotent_of_is_nilpotent_span_sup_eq_top hI₂ (h _) (hI₃ _ fun x => h x)\n#align\n  lie_algebra.exists_engelian_lie_subalgebra_of_lt_normalizer lie_algebra.exists_engelian_lie_subalgebra_of_lt_normalizer\n\n"}