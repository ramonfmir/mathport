{"trivial_lie_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/-\nCopyright (c) 2021 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\n@[simp]\ntheorem trivial_lie_zero (L : Type v) (M : Type w) [Bracket L M] [Zero M] [lie_module.is_trivial L M] (x : L) (m : M) :\n    «expr⁅ , ⁆» x m = 0 :=\n  lie_module.is_trivial.trivial x m\n#align trivial_lie_zero trivial_lie_zero\n\n",
 "trivial_lie_oper_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem lie_submodule.trivial_lie_oper_zero [lie_module.is_trivial L M] : «expr⁅ , ⁆» I N = «expr⊥» :=\n  by\n  suffices : «expr⁅ , ⁆» I N ≤ «expr⊥»; exact le_bot_iff.mp this\n  rw [lie_ideal_oper_eq_span, lie_submodule.lie_span_le]\n  rintro m ⟨x, n, h⟩; rw [trivial_lie_zero] at h; simp [← h]\n#align lie_submodule.trivial_lie_oper_zero lie_submodule.trivial_lie_oper_zero\n\n",
 "trivial_iff_le_maximal_trivial":
 "theorem trivial_iff_le_maximal_trivial (N : lie_submodule R L M) : is_trivial L N ↔ N ≤ max_triv_submodule R L M :=\n  ⟨fun h m hm x => is_trivial.dcases_on h fun h => subtype.ext_iff.mp (h x ⟨m, hm⟩), fun h =>\n    { trivial := fun x m => subtype.ext (h m.2 x) }⟩\n#align trivial_iff_le_maximal_trivial trivial_iff_le_maximal_trivial\n\n",
 "self_module_ker_eq_center":
 "@[simp]\ntheorem self_module_ker_eq_center : lie_module.ker R L L = center R L :=\n  by\n  ext y\n  simp only [lie_module.mem_max_triv_submodule, lie_module.mem_ker, ← lie_skew _ y, neg_eq_zero]\n#align self_module_ker_eq_center self_module_ker_eq_center\n\n",
 "mem_max_triv_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n@[simp]\ntheorem mem_max_triv_submodule (m : M) : m ∈ max_triv_submodule R L M ↔ ∀ x : L, «expr⁅ , ⁆» x m = 0 :=\n  iff.rfl\n#align mem_max_triv_submodule mem_max_triv_submodule\n\n",
 "mem_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n@[simp]\nprotected theorem mem_ker (x : L) : x ∈ lie_module.ker R L M ↔ ∀ m : M, «expr⁅ , ⁆» x m = 0 := by\n  simp only [lie_module.ker, lie_hom.mem_ker, linear_map.ext_iff, linear_map.zero_apply, to_endomorphism_apply_apply]\n#align mem_ker mem_ker\n\n",
 "max_triv_equiv_of_refl_eq_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ⁅ , ⁆ » -/\n@[simp]\ntheorem max_triv_equiv_of_refl_eq_refl :\n    max_triv_equiv (lie_module_equiv.refl : «expr ≃ₗ⁅ , ⁆ » M R L M) = lie_module_equiv.refl :=\n  by\n  ext\n  simp only [coe_max_triv_equiv_apply, lie_module_equiv.refl_apply]\n#align max_triv_equiv_of_refl_eq_refl max_triv_equiv_of_refl_eq_refl\n\n",
 "max_triv_equiv_of_equiv_symm_eq_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ⁅ , ⁆ » -/\n@[simp]\ntheorem max_triv_equiv_of_equiv_symm_eq_symm (e : «expr ≃ₗ⁅ , ⁆ » M R L N) :\n    (max_triv_equiv e).symm = max_triv_equiv e.symm :=\n  rfl\n#align max_triv_equiv_of_equiv_symm_eq_symm max_triv_equiv_of_equiv_symm_eq_symm\n\n",
 "lie_abelian_iff_lie_self_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem lie_submodule.lie_abelian_iff_lie_self_eq_bot : is_lie_abelian I ↔ «expr⁅ , ⁆» I I = «expr⊥» :=\n  by\n  simp only [_root_.eq_bot_iff, lie_ideal_oper_eq_span, lie_submodule.lie_span_le, lie_submodule.bot_coe,\n    Set.subset_singleton_iff, Set.mem_setOf_eq, exists_imp]\n  refine'\n    ⟨fun h z x y hz =>\n      hz.symm.trans\n        (((I : lie_subalgebra R L).coe_bracket x y).symm.trans ((coe_zero_iff_zero _ _).mpr (by apply h.trivial))),\n      fun h => ⟨fun x y => ((I : lie_subalgebra R L).coe_zero_iff_zero _).mp (h _ x y rfl)⟩⟩\n#align lie_submodule.lie_abelian_iff_lie_self_eq_bot lie_submodule.lie_abelian_iff_lie_self_eq_bot\n\n",
 "lie_abelian_iff_equiv_lie_abelian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ⁅ ⁆ » -/\ntheorem lie_abelian_iff_equiv_lie_abelian {R : Type u} {L₁ : Type v} {L₂ : Type w} [CommRing R] [lie_ring L₁]\n    [lie_ring L₂] [lie_algebra R L₁] [lie_algebra R L₂] (e : «expr ≃ₗ⁅ ⁆ » L₁ R L₂) :\n    is_lie_abelian L₁ ↔ is_lie_abelian L₂ :=\n  ⟨e.symm.injective.is_lie_abelian, e.injective.is_lie_abelian⟩\n#align lie_abelian_iff_equiv_lie_abelian lie_abelian_iff_equiv_lie_abelian\n\n",
 "le_max_triv_iff_bracket_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem le_max_triv_iff_bracket_eq_bot {N : lie_submodule R L M} :\n    N ≤ max_triv_submodule R L M ↔ «expr⁅ , ⁆» («expr⊤» : lie_ideal R L) N = «expr⊥» :=\n  by\n  refine' ⟨fun h => _, fun h m hm => _⟩\n  · rw [← le_bot_iff, ← ideal_oper_max_triv_submodule_eq_bot R L M («expr⊤»)]\n    exact lie_submodule.mono_lie_right _ _ («expr⊤») h\n  · rw [mem_max_triv_submodule]\n    rw [lie_submodule.lie_eq_bot_iff] at h\n    exact fun x => h x (lie_submodule.mem_top x) m hm\n#align le_max_triv_iff_bracket_eq_bot le_max_triv_iff_bracket_eq_bot\n\n",
 "is_trivial_iff_max_triv_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_trivial_iff_max_triv_eq_top : is_trivial L M ↔ max_triv_submodule R L M = «expr⊤» :=\n  by\n  constructor\n  · rintro ⟨h⟩\n    ext\n    simp only [mem_max_triv_submodule, h, forall_const, true_iff_iff, eq_self_iff_true]\n  · intro h\n    constructor\n    intro x m\n    revert x\n    rw [← mem_max_triv_submodule R L M, h]\n    exact lie_submodule.mem_top m\n#align is_trivial_iff_max_triv_eq_top is_trivial_iff_max_triv_eq_top\n\n",
 "is_lie_abelian_iff_center_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_lie_abelian_iff_center_eq_top : is_lie_abelian L ↔ center R L = «expr⊤» :=\n  lie_module.is_trivial_iff_max_triv_eq_top R L L\n#align is_lie_abelian_iff_center_eq_top is_lie_abelian_iff_center_eq_top\n\n",
 "is_lie_abelian_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem lie_algebra.is_lie_abelian_bot (R : Type u) (L : Type v) [CommRing R] [lie_ring L] [lie_algebra R L] :\n    is_lie_abelian («expr⊥» : lie_ideal R L) :=\n  ⟨fun ⟨x, hx⟩ _ => by convert zero_lie _⟩\n#align lie_algebra.is_lie_abelian_bot lie_algebra.is_lie_abelian_bot\n\n",
 "is_lie_abelian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ⁅ ⁆ » -/\ntheorem function.surjective.is_lie_abelian {R : Type u} {L₁ : Type v} {L₂ : Type w} [CommRing R] [lie_ring L₁]\n    [lie_ring L₂] [lie_algebra R L₁] [lie_algebra R L₂] {f : «expr →ₗ⁅ ⁆ » L₁ R L₂} (h₁ : function.surjective f)\n    (h₂ : is_lie_abelian L₁) : is_lie_abelian L₂ :=\n  {\n    trivial := fun x y => by\n      obtain ⟨u, rfl⟩ := h₁ x\n      obtain ⟨v, rfl⟩ := h₁ y\n      rw [← lie_hom.map_lie, trivial_lie_zero, lie_hom.map_zero] }\n#align function.surjective.is_lie_abelian function.surjective.is_lie_abelian\n\n",
 "ideal_oper_max_triv_submodule_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ideal_oper_max_triv_submodule_eq_bot (I : lie_ideal R L) : «expr⁅ , ⁆» I (max_triv_submodule R L M) = «expr⊥» :=\n  by\n  rw [← lie_submodule.coe_to_submodule_eq_iff, lie_submodule.lie_ideal_oper_eq_linear_span,\n    lie_submodule.bot_coe_submodule, submodule.span_eq_bot]\n  rintro m ⟨⟨x, hx⟩, ⟨⟨m, hm⟩, rfl⟩⟩\n  exact hm x\n#align ideal_oper_max_triv_submodule_eq_bot ideal_oper_max_triv_submodule_eq_bot\n\n",
 "commutative_ring_iff_abelian_lie_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] : is_commutative A (· * ·) ↔ is_lie_abelian A :=\n  by\n  have h₁ : is_commutative A (· * ·) ↔ ∀ a b : A, a * b = b * a := ⟨fun h => h.1, fun h => ⟨h⟩⟩\n  have h₂ : is_lie_abelian A ↔ ∀ a b : A, «expr⁅ , ⁆» a b = 0 := ⟨fun h => h.1, fun h => ⟨h⟩⟩\n  simp only [h₁, h₂, lie_ring.of_associative_ring_bracket, sub_eq_zero]\n#align commutative_ring_iff_abelian_lie_ring commutative_ring_iff_abelian_lie_ring\n\n",
 "coe_max_triv_linear_map_equiv_lie_module_hom_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ⁅ , ⁆ » -/\n@[simp]\ntheorem coe_max_triv_linear_map_equiv_lie_module_hom_symm (f : «expr →ₗ⁅ , ⁆ » M R L N) :\n    (max_triv_linear_map_equiv_lie_module_hom.symm f : M → N) = f :=\n  rfl\n#align coe_max_triv_linear_map_equiv_lie_module_hom_symm coe_max_triv_linear_map_equiv_lie_module_hom_symm\n\n",
 "coe_max_triv_linear_map_equiv_lie_module_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_max_triv_linear_map_equiv_lie_module_hom (f : max_triv_submodule R L («expr →ₗ[ ] » M R N)) :\n    (max_triv_linear_map_equiv_lie_module_hom f : M → N) = f :=\n  by\n  ext\n  rfl\n#align coe_max_triv_linear_map_equiv_lie_module_hom coe_max_triv_linear_map_equiv_lie_module_hom\n\n",
 "coe_max_triv_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ⁅ , ⁆ » -/\n@[norm_cast, simp]\ntheorem coe_max_triv_hom_apply (f : «expr →ₗ⁅ , ⁆ » M R L N) (m : max_triv_submodule R L M) :\n    (max_triv_hom f m : N) = f m :=\n  rfl\n#align coe_max_triv_hom_apply coe_max_triv_hom_apply\n\n",
 "coe_max_triv_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ⁅ , ⁆ » -/\n@[norm_cast, simp]\ntheorem coe_max_triv_equiv_apply (e : «expr ≃ₗ⁅ , ⁆ » M R L N) (m : max_triv_submodule R L M) :\n    (max_triv_equiv e m : N) = e ↑m :=\n  rfl\n#align coe_max_triv_equiv_apply coe_max_triv_equiv_apply\n\n",
 "coe_linear_map_max_triv_linear_map_equiv_lie_module_hom_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ⁅ , ⁆ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_linear_map_max_triv_linear_map_equiv_lie_module_hom_symm (f : «expr →ₗ⁅ , ⁆ » M R L N) :\n    (max_triv_linear_map_equiv_lie_module_hom.symm f : «expr →ₗ[ ] » M R N) = (f : «expr →ₗ[ ] » M R N) :=\n  rfl\n#align\n  coe_linear_map_max_triv_linear_map_equiv_lie_module_hom_symm coe_linear_map_max_triv_linear_map_equiv_lie_module_hom_symm\n\n",
 "coe_linear_map_max_triv_linear_map_equiv_lie_module_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_linear_map_max_triv_linear_map_equiv_lie_module_hom (f : max_triv_submodule R L («expr →ₗ[ ] » M R N)) :\n    (max_triv_linear_map_equiv_lie_module_hom f : «expr →ₗ[ ] » M R N) = (f : «expr →ₗ[ ] » M R N) :=\n  by\n  ext\n  rfl\n#align coe_linear_map_max_triv_linear_map_equiv_lie_module_hom coe_linear_map_max_triv_linear_map_equiv_lie_module_hom\n\n",
 "ad_ker_eq_self_module_ker":
 "@[simp]\ntheorem ad_ker_eq_self_module_ker : (ad R L).ker = lie_module.ker R L L :=\n  rfl\n#align ad_ker_eq_self_module_ker ad_ker_eq_self_module_ker\n\n",
 "abelian_of_le_center":
 "theorem abelian_of_le_center (I : lie_ideal R L) (h : I ≤ center R L) : is_lie_abelian I :=\n  haveI : lie_module.is_trivial L I := (lie_module.trivial_iff_le_maximal_trivial R L L I).mpr h\n  lie_ideal.is_lie_abelian_of_trivial R L I\n#align abelian_of_le_center abelian_of_le_center\n\n"}