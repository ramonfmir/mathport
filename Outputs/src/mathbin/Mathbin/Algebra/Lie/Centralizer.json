{"top_lie_le_iff_le_centralizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem top_lie_le_iff_le_centralizer (N' : lie_submodule R L M) :\n    «expr⁅ , ⁆» («expr⊤» : lie_ideal R L) N ≤ N' ↔ N ≤ N'.centralizer :=\n  by\n  rw [lie_le_iff]\n  tauto\n#align top_lie_le_iff_le_centralizer top_lie_le_iff_le_centralizer\n\n",
 "normalizer_eq_self_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem normalizer_eq_self_iff :\n    H.normalizer = H ↔ (lie_module.max_triv_submodule R H <| «expr ⧸ » L H.to_lie_submodule) = «expr⊥» :=\n  by\n  rw [lie_submodule.eq_bot_iff]\n  refine' ⟨fun h => _, fun h => le_antisymm (fun x hx => _) H.le_normalizer⟩\n  · rintro ⟨x⟩ hx\n    suffices x ∈ H by simpa\n    rw [← h, H.mem_normalizer_iff']\n    intro y hy\n    replace hx : «expr⁅ , ⁆» _ (lie_submodule.quotient.mk' _ x) = 0 := hx ⟨y, hy⟩\n    rwa [← lie_module_hom.map_lie, lie_submodule.quotient.mk_eq_zero] at hx\n  · let y := lie_submodule.quotient.mk' H.to_lie_submodule x\n    have hy : y ∈ lie_module.max_triv_submodule R H («expr ⧸ » L H.to_lie_submodule) :=\n      by\n      rintro ⟨z, hz⟩\n      rw [← lie_module_hom.map_lie, lie_submodule.quotient.mk_eq_zero, coe_bracket_of_module, submodule.coe_mk,\n        mem_to_lie_submodule]\n      exact (H.mem_normalizer_iff' x).mp hx z hz\n    simpa using h y hy\n#align normalizer_eq_self_iff normalizer_eq_self_iff\n\n",
 "monotone_centalizer":
 "@[mono]\ntheorem monotone_centalizer : monotone (centralizer : lie_submodule R L M → lie_submodule R L M) :=\n  by\n  intro N₁ N₂ h m hm\n  rw [mem_centralizer] at hm⊢\n  exact fun x => h (hm x)\n#align monotone_centalizer monotone_centalizer\n\n",
 "mem_normalizer_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem mem_normalizer_iff' (x : L) : x ∈ H.normalizer ↔ ∀ y : L, y ∈ H → «expr⁅ , ⁆» y x ∈ H :=\n  by\n  rw [subtype.forall']\n  rfl\n#align mem_normalizer_iff' mem_normalizer_iff'\n\n",
 "mem_normalizer_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem mem_normalizer_iff (x : L) : x ∈ H.normalizer ↔ ∀ y : L, y ∈ H → «expr⁅ , ⁆» x y ∈ H :=\n  by\n  rw [mem_normalizer_iff']\n  refine' forall₂_congr fun y hy => _\n  rw [← lie_skew, neg_mem_iff]\n#align mem_normalizer_iff mem_normalizer_iff\n\n",
 "mem_centralizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/-\nCopyright (c) 2022 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\n@[simp]\ntheorem mem_centralizer (m : M) : m ∈ N.centralizer ↔ ∀ x : L, «expr⁅ , ⁆» x m ∈ N :=\n  iff.rfl\n#align mem_centralizer mem_centralizer\n\n",
 "lie_mem_sup_of_mem_normalizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem lie_mem_sup_of_mem_normalizer {x y z : L} (hx : x ∈ H.normalizer) (hy : y ∈ «expr ⊔ » («expr ∙ » R x) ↑H)\n    (hz : z ∈ «expr ⊔ » («expr ∙ » R x) ↑H) : «expr⁅ , ⁆» y z ∈ «expr ⊔ » («expr ∙ » R x) ↑H :=\n  by\n  rw [submodule.mem_sup] at hy hz\n  obtain ⟨u₁, hu₁, v, hv : v ∈ H, rfl⟩ := hy\n  obtain ⟨u₂, hu₂, w, hw : w ∈ H, rfl⟩ := hz\n  obtain ⟨t, rfl⟩ := submodule.mem_span_singleton.mp hu₁\n  obtain ⟨s, rfl⟩ := submodule.mem_span_singleton.mp hu₂\n  apply submodule.mem_sup_right\n  simp only [lie_subalgebra.mem_coe_submodule, smul_lie, add_lie, zero_add, lie_add, smul_zero, lie_smul, lie_self]\n  refine' H.add_mem (H.smul_mem s _) (H.add_mem (H.smul_mem t _) (H.lie_mem hv hw))\n  exacts[(H.mem_normalizer_iff' x).mp hx v hv, (H.mem_normalizer_iff x).mp hx w hw]\n#align lie_mem_sup_of_mem_normalizer lie_mem_sup_of_mem_normalizer\n\n",
 "le_normalizer":
 "theorem le_normalizer : H ≤ H.normalizer :=\n  H.to_lie_submodule.le_centralizer\n#align le_normalizer le_normalizer\n\n",
 "le_centralizer":
 "theorem le_centralizer : N ≤ N.centralizer := by\n  intro m hm\n  rw [mem_centralizer]\n  exact fun x => N.lie_mem hm\n#align le_centralizer le_centralizer\n\n",
 "ideal_in_normalizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/-- A Lie subalgebra is an ideal of its normalizer. -/\ntheorem ideal_in_normalizer {x y : L} (hx : x ∈ H.normalizer) (hy : y ∈ H) : «expr⁅ , ⁆» x y ∈ H :=\n  by\n  rw [← lie_skew, neg_mem_iff]\n  exact hx ⟨y, hy⟩\n#align ideal_in_normalizer ideal_in_normalizer\n\n",
 "gc_top_lie_centralizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem gc_top_lie_centralizer :\n    GaloisConnection (fun N : lie_submodule R L M => «expr⁅ , ⁆» («expr⊤» : lie_ideal R L) N) centralizer :=\n  top_lie_le_iff_le_centralizer\n#align gc_top_lie_centralizer gc_top_lie_centralizer\n\n",
 "exists_nested_lie_ideal_of_le_normalizer":
 "/-- A Lie subalgebra `H` is an ideal of any Lie subalgebra `K` containing `H` and contained in the\nnormalizer of `H`. -/\ntheorem exists_nested_lie_ideal_of_le_normalizer {K : lie_subalgebra R L} (h₁ : H ≤ K) (h₂ : K ≤ H.normalizer) :\n    ∃ I : lie_ideal R K, (I : lie_subalgebra R K) = of_le h₁ :=\n  by\n  rw [exists_nested_lie_ideal_coe_eq_iff]\n  exact fun x y hx hy => ideal_in_normalizer (h₂ hx) hy\n#align exists_nested_lie_ideal_of_le_normalizer exists_nested_lie_ideal_of_le_normalizer\n\n",
 "comap_centralizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ⁅ , ⁆ » -/\n@[simp]\ntheorem comap_centralizer (f : «expr →ₗ⁅ , ⁆ » M' R L M) : N.centralizer.comap f = (N.comap f).centralizer :=\n  by\n  ext\n  simp\n#align comap_centralizer comap_centralizer\n\n",
 "coe_centralizer_eq_normalizer":
 "theorem coe_centralizer_eq_normalizer : (H.to_lie_submodule.centralizer : submodule R L) = H.normalizer :=\n  rfl\n#align coe_centralizer_eq_normalizer coe_centralizer_eq_normalizer\n\n",
 "centralizer_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem centralizer_inf : («expr ⊓ » N₁ N₂).centralizer = «expr ⊓ » N₁.centralizer N₂.centralizer :=\n  by\n  ext\n  simp [← forall_and]\n#align centralizer_inf centralizer_inf\n\n",
 "centralizer_bot_eq_max_triv_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem centralizer_bot_eq_max_triv_submodule :\n    («expr⊥» : lie_submodule R L M).centralizer = lie_module.max_triv_submodule R L M :=\n  rfl\n#align centralizer_bot_eq_max_triv_submodule centralizer_bot_eq_max_triv_submodule\n\n"}