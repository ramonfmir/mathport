{"ucs_zero":
 "@[simp]\ntheorem ucs_zero : N.ucs 0 = N :=\n  rfl\n#align ucs_zero ucs_zero\n\n",
 "ucs_succ":
 "@[simp]\ntheorem ucs_succ (k : ℕ) : N.ucs (k + 1) = (N.ucs k).normalizer :=\n  Function.iterate_succ_apply' normalizer k N\n#align ucs_succ ucs_succ\n\n",
 "ucs_mono":
 "@[mono]\ntheorem ucs_mono (k : ℕ) (h : N₁ ≤ N₂) : N₁.ucs k ≤ N₂.ucs k :=\n  by\n  induction' k with k ih; · simpa\n  simp only [ucs_succ]\n  mono\n#align ucs_mono ucs_mono\n\n",
 "ucs_le_of_normalizer_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- If a Lie module `M` contains a self-normalizing Lie submodule `N`, then all terms of the upper\ncentral series of `M` are contained in `N`.\n\nAn important instance of this situation arises from a Cartan subalgebra `H ⊆ L` with the roles of\n`L`, `M`, `N` played by `H`, `L`, `H`, respectively. -/\ntheorem ucs_le_of_normalizer_eq_self (h : N₁.normalizer = N₁) (k : ℕ) : («expr⊥» : lie_submodule R L M).ucs k ≤ N₁ :=\n  by\n  rw [← ucs_eq_self_of_normalizer_eq_self h k]\n  mono\n  simp\n#align ucs_le_of_normalizer_eq_self ucs_le_of_normalizer_eq_self\n\n",
 "ucs_eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ucs_eq_top_iff (k : ℕ) : N.ucs k = «expr⊤» ↔ lie_module.lower_central_series R L M k ≤ N :=\n  by\n  rw [eq_top_iff, ← lcs_le_iff]\n  rfl\n#align ucs_eq_top_iff ucs_eq_top_iff\n\n",
 "ucs_eq_self_of_normalizer_eq_self":
 "theorem ucs_eq_self_of_normalizer_eq_self (h : N₁.normalizer = N₁) (k : ℕ) : N₁.ucs k = N₁ :=\n  by\n  induction' k with k ih\n  · simp\n  · rwa [ucs_succ, ih]\n#align ucs_eq_self_of_normalizer_eq_self ucs_eq_self_of_normalizer_eq_self\n\n",
 "ucs_comap_incl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ucs_comap_incl (k : ℕ) :\n    ((«expr⊥» : lie_submodule R L M).ucs k).comap N.incl = («expr⊥» : lie_submodule R L N).ucs k :=\n  by\n  induction' k with k ih\n  · exact N.ker_incl\n  · simp [← ih]\n#align ucs_comap_incl ucs_comap_incl\n\n",
 "ucs_add":
 "theorem ucs_add (k l : ℕ) : N.ucs (k + l) = (N.ucs l).ucs k :=\n  Function.iterate_add_apply normalizer k l N\n#align ucs_add ucs_add\n\n",
 "trivial_iff_lower_central_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem trivial_iff_lower_central_eq_bot : is_trivial L M ↔ lower_central_series R L M 1 = «expr⊥» :=\n  by\n  constructor <;> intro h\n  · erw [eq_bot_iff, lie_submodule.lie_span_le]\n    rintro m ⟨x, n, hn⟩\n    rw [← hn, h.trivial]\n    simp\n  · rw [lie_submodule.eq_bot_iff] at h\n    apply is_trivial.mk\n    intro x m\n    apply h\n    apply lie_submodule.subset_lie_span\n    use x, m\n    rfl\n#align trivial_iff_lower_central_eq_bot trivial_iff_lower_central_eq_bot\n\n",
 "nontrivial_max_triv_of_is_nilpotent":
 "theorem nontrivial_max_triv_of_is_nilpotent [Nontrivial M] [is_nilpotent R L M] :\n    Nontrivial (max_triv_submodule R L M) :=\n  Set.nontrivial_mono (lower_central_series_last_le_max_triv R L M) (nontrivial_lower_central_series_last R L M)\n#align nontrivial_max_triv_of_is_nilpotent nontrivial_max_triv_of_is_nilpotent\n\n",
 "nontrivial_lower_central_series_last":
 "theorem nontrivial_lower_central_series_last [Nontrivial M] [is_nilpotent R L M] :\n    Nontrivial (lower_central_series_last R L M) :=\n  by\n  rw [lie_submodule.nontrivial_iff_ne_bot, lower_central_series_last]\n  cases h : nilpotency_length R L M\n  · rw [nilpotency_length_eq_zero_iff, ← not_nontrivial_iff_subsingleton] at h\n    contradiction\n  · rw [nilpotency_length_eq_succ_iff] at h\n    exact h.2\n#align nontrivial_lower_central_series_last nontrivial_lower_central_series_last\n\n",
 "non_trivial_center_of_is_nilpotent":
 "theorem lie_algebra.non_trivial_center_of_is_nilpotent [Nontrivial L] [IsNilpotent R L] : Nontrivial <| center R L :=\n  lie_module.nontrivial_max_triv_of_is_nilpotent R L L\n#align lie_algebra.non_trivial_center_of_is_nilpotent lie_algebra.non_trivial_center_of_is_nilpotent\n\n",
 "nilpotent_of_nilpotent_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- A central extension of nilpotent Lie algebras is nilpotent. -/\ntheorem lie_algebra.nilpotent_of_nilpotent_quotient {I : lie_ideal R L} (h₁ : I ≤ center R L)\n    (h₂ : IsNilpotent R («expr ⧸ » L I)) : IsNilpotent R L :=\n  by\n  suffices lie_module.is_nilpotent R L («expr ⧸ » L I) by exact lie_module.nilpotent_of_nilpotent_quotient R L L h₁ this\n  obtain ⟨k, hk⟩ := h₂\n  use k\n  simp [← lie_submodule.coe_to_submodule_eq_iff, coe_lower_central_series_ideal_quot_eq, hk]\n#align lie_algebra.nilpotent_of_nilpotent_quotient lie_algebra.nilpotent_of_nilpotent_quotient\n\n",
 "nilpotent_iff_equiv_nilpotent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ⁅ ⁆ » -/\ntheorem lie_equiv.nilpotent_iff_equiv_nilpotent (e : «expr ≃ₗ⁅ ⁆ » L R L') : IsNilpotent R L ↔ IsNilpotent R L' :=\n  by\n  constructor <;> intro h\n  · exact e.symm.injective.lie_algebra_is_nilpotent\n  · exact e.injective.lie_algebra_is_nilpotent\n#align lie_equiv.nilpotent_iff_equiv_nilpotent lie_equiv.nilpotent_iff_equiv_nilpotent\n\n",
 "nilpotent_endo_of_nilpotent_module":
 "theorem nilpotent_endo_of_nilpotent_module [hM : is_nilpotent R L M] :\n    ∃ k : ℕ, ∀ x : L, to_endomorphism R L M x ^ k = 0 :=\n  by\n  obtain ⟨k, hM⟩ := hM\n  use k\n  intro x; ext m\n  rw [LinearMap.pow_apply, LinearMap.zero_apply, ← @lie_submodule.mem_bot R L M, ← hM]\n  exact iterate_to_endomorphism_mem_lower_central_series R L M x m k\n#align nilpotent_endo_of_nilpotent_module nilpotent_endo_of_nilpotent_module\n\n",
 "nilpotent_ad_of_nilpotent_algebra":
 "theorem lie_algebra.nilpotent_ad_of_nilpotent_algebra [IsNilpotent R L] : ∃ k : ℕ, ∀ x : L, ad R L x ^ k = 0 :=\n  lie_module.nilpotent_endo_of_nilpotent_module R L L\n#align lie_algebra.nilpotent_ad_of_nilpotent_algebra lie_algebra.nilpotent_ad_of_nilpotent_algebra\n\n",
 "nilpotency_length_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem nilpotency_length_eq_zero_iff [is_nilpotent R L M] : nilpotency_length R L M = 0 ↔ subsingleton M :=\n  by\n  let s := { k | lower_central_series R L M k = «expr⊥» }\n  have hs : s.nonempty := by\n    obtain ⟨k, hk⟩ := (by infer_instance : IsNilpotent R L M)\n    exact ⟨k, hk⟩\n  change Inf s = 0 ↔ _\n  rw [← lie_submodule.subsingleton_iff R L M, ← subsingleton_iff_bot_eq_top, ← lower_central_series_zero,\n    @eq_comm (lie_submodule R L M)]\n  refine' ⟨fun h => h ▸ Nat.infₛ_mem hs, fun h => _⟩\n  rw [Nat.infₛ_eq_zero]\n  exact or.inl h\n#align nilpotency_length_eq_zero_iff nilpotency_length_eq_zero_iff\n\n",
 "nilpotency_length_eq_succ_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem nilpotency_length_eq_succ_iff (k : ℕ) :\n    nilpotency_length R L M = k + 1 ↔\n      lower_central_series R L M (k + 1) = «expr⊥» ∧ lower_central_series R L M k ≠ «expr⊥» :=\n  by\n  let s := { k | lower_central_series R L M k = «expr⊥» }\n  change Inf s = k + 1 ↔ k + 1 ∈ s ∧ k ∉ s\n  have hs : ∀ k₁ k₂, k₁ ≤ k₂ → k₁ ∈ s → k₂ ∈ s :=\n    by\n    rintro k₁ k₂ h₁₂ (h₁ : lower_central_series R L M k₁ = «expr⊥»)\n    exact eq_bot_iff.mpr (h₁ ▸ antitone_lower_central_series R L M h₁₂)\n  exact Nat.infₛ_upward_closed_eq_succ_iff hs k\n#align nilpotency_length_eq_succ_iff nilpotency_length_eq_succ_iff\n\n",
 "map_lower_central_series_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ⁅ ⁆ » -/\ntheorem lie_ideal.map_lower_central_series_le (k : ℕ) {f : «expr →ₗ⁅ ⁆ » L R L'} :\n    lie_ideal.map f (lower_central_series R L L k) ≤ lower_central_series R L' L' k :=\n  by\n  induction' k with k ih\n  · simp only [lie_module.lower_central_series_zero, le_top]\n  · simp only [lie_module.lower_central_series_succ]\n    exact le_trans (lie_ideal.map_bracket_le f) (lie_submodule.mono_lie _ _ _ _ le_top ih)\n#align lie_ideal.map_lower_central_series_le lie_ideal.map_lower_central_series_le\n\n",
 "lower_central_series_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem lower_central_series_zero : lower_central_series R L M 0 = «expr⊤» :=\n  rfl\n#align lower_central_series_zero lower_central_series_zero\n\n",
 "lower_central_series_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem lower_central_series_succ :\n    lower_central_series R L M (k + 1) = «expr⁅ , ⁆» («expr⊤» : lie_ideal R L) (lower_central_series R L M k) :=\n  («expr⊤» : lie_submodule R L M).lcs_succ k\n#align lower_central_series_succ lower_central_series_succ\n\n",
 "lower_central_series_map_eq_lcs":
 "theorem lower_central_series_map_eq_lcs : (lower_central_series R L N k).map N.incl = N.lcs k :=\n  by\n  rw [lower_central_series_eq_lcs_comap, lie_submodule.map_comap_incl, inf_eq_right]\n  apply lcs_le_self\n#align lower_central_series_map_eq_lcs lower_central_series_map_eq_lcs\n\n",
 "lower_central_series_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ⁅ ⁆ » -/\ntheorem lie_ideal.lower_central_series_map_eq (k : ℕ) {f : «expr →ₗ⁅ ⁆ » L R L'} (h : function.surjective f) :\n    lie_ideal.map f (lower_central_series R L L k) = lower_central_series R L' L' k :=\n  by\n  have h' : («expr⊤» : lie_ideal R L).map f = «expr⊤» :=\n    by\n    rw [← f.ideal_range_eq_map]\n    exact f.ideal_range_eq_top_of_surjective h\n  induction' k with k ih\n  · simp only [lie_module.lower_central_series_zero]\n    exact h'\n  · simp only [lie_module.lower_central_series_succ, lie_ideal.map_bracket_eq f h, ih, h']\n#align lie_ideal.lower_central_series_map_eq lie_ideal.lower_central_series_map_eq\n\n",
 "lower_central_series_last_le_max_triv":
 "theorem lower_central_series_last_le_max_triv : lower_central_series_last R L M ≤ max_triv_submodule R L M :=\n  by\n  rw [lower_central_series_last]\n  cases' h : nilpotency_length R L M with k\n  · exact bot_le\n  · rw [le_max_triv_iff_bracket_eq_bot]\n    rw [nilpotency_length_eq_succ_iff, lower_central_series_succ] at h\n    exact h.1\n#align lower_central_series_last_le_max_triv lower_central_series_last_le_max_triv\n\n",
 "lower_central_series_eq_lcs_comap":
 "theorem lower_central_series_eq_lcs_comap : lower_central_series R L N k = (N.lcs k).comap N.incl :=\n  by\n  induction' k with k ih\n  · simp\n  · simp only [lcs_succ, lower_central_series_succ] at ih⊢\n    have : N.lcs k ≤ N.incl.range := by\n      rw [N.range_incl]\n      apply lcs_le_self\n    rw [ih, lie_submodule.comap_bracket_eq _ _ N.incl N.ker_incl this]\n#align lower_central_series_eq_lcs_comap lower_central_series_eq_lcs_comap\n\n",
 "lie_module_lcs_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem function.surjective.lie_module_lcs_map_eq (k : ℕ) :\n    (lower_central_series R L M k : Submodule R M).map g = lower_central_series R L₂ M₂ k :=\n  by\n  induction' k with k ih\n  · simp [LinearMap.range_eq_top, hg]\n  · suffices\n      «expr '' » g { m | ∃ (x : L)(n : _), n ∈ lower_central_series R L M k ∧ «expr⁅ , ⁆» x n = m } =\n        { m | ∃ (x : L₂)(n : _), n ∈ lower_central_series R L M k ∧ «expr⁅ , ⁆» x (g n) = m }\n      by\n      simp only [← lie_submodule.mem_coe_submodule] at this\n      simp [← lie_submodule.mem_coe_submodule, ← ih, lie_submodule.lie_ideal_oper_eq_linear_span', Submodule.map_span,\n        -Submodule.span_image, this]\n    ext m₂\n    constructor\n    · rintro ⟨m, ⟨x, n, hn, rfl⟩, rfl⟩\n      exact ⟨f x, n, hn, hfg x n⟩\n    · rintro ⟨x, n, hn, rfl⟩\n      obtain ⟨y, rfl⟩ := hf x\n      exact ⟨«expr⁅ , ⁆» y n, ⟨y, n, hn, rfl⟩, (hfg y n).symm⟩\n#align function.surjective.lie_module_lcs_map_eq function.surjective.lie_module_lcs_map_eq\n\n",
 "lie_module_is_nilpotent_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ⁅ ⁆ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem equiv.lie_module_is_nilpotent_iff (f : «expr ≃ₗ⁅ ⁆ » L R L₂) (g : «expr ≃ₗ[ ] » M R M₂)\n    (hfg : ∀ x m, «expr⁅ , ⁆» (f x) (g m) = g («expr⁅ , ⁆» x m)) : IsNilpotent R L M ↔ IsNilpotent R L₂ M₂ :=\n  by\n  constructor <;> intro h\n  · have hg : surjective (g : «expr →ₗ[ ] » M R M₂) := g.surjective\n    exact f.surjective.lie_module_is_nilpotent hg hfg\n  · have hg : surjective (g.symm : «expr →ₗ[ ] » M₂ R M) := g.symm.surjective\n    refine' f.symm.surjective.lie_module_is_nilpotent hg fun x m => _\n    rw [LinearEquiv.coe_coe, LieEquiv.coe_to_lieHom, ← g.symm_apply_apply («expr⁅ , ⁆» (f.symm x) (g.symm m)), ← hfg,\n      f.apply_symm_apply, g.apply_symm_apply]\n#align equiv.lie_module_is_nilpotent_iff equiv.lie_module_is_nilpotent_iff\n\n",
 "lie_module_is_nilpotent":
 "theorem function.surjective.lie_module_is_nilpotent [IsNilpotent R L M] : IsNilpotent R L₂ M₂ :=\n  by\n  obtain ⟨k, hk⟩ := id (by infer_instance : IsNilpotent R L M)\n  use k\n  rw [← lie_submodule.coe_to_submodule_eq_iff] at hk⊢\n  simp [← hf.lie_module_lcs_map_eq hg hfg k, hk]\n#align function.surjective.lie_module_is_nilpotent function.surjective.lie_module_is_nilpotent\n\n",
 "lie_algebra_is_nilpotent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ⁅ ⁆ » -/\ntheorem function.surjective.lie_algebra_is_nilpotent [h₁ : IsNilpotent R L] {f : «expr →ₗ⁅ ⁆ » L R L'}\n    (h₂ : function.surjective f) : IsNilpotent R L' :=\n  {\n    nilpotent := by\n      obtain ⟨k, hk⟩ := id h₁\n      use k\n      rw [← lie_ideal.lower_central_series_map_eq k h₂, hk]\n      simp only [lie_ideal.map_eq_bot_iff, bot_le] }\n#align function.surjective.lie_algebra_is_nilpotent function.surjective.lie_algebra_is_nilpotent\n\n",
 "lcs_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem lcs_zero : I.lcs M 0 = «expr⊤» :=\n  rfl\n#align lcs_zero lcs_zero\n\n",
 "lcs_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem lcs_top : («expr⊤» : lie_ideal R L).lcs M k = lower_central_series R L M k :=\n  rfl\n#align lcs_top lcs_top\n\n",
 "lcs_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n@[simp]\ntheorem lcs_succ : I.lcs M (k + 1) = «expr⁅ , ⁆» I (I.lcs M k) :=\n  Function.iterate_succ_apply' (fun N => «expr⁅ , ⁆» I N) k («expr⊤»)\n#align lcs_succ lcs_succ\n\n",
 "lcs_le_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem lcs_le_self : N.lcs k ≤ N := by\n  induction' k with k ih\n  · simp\n  · simp only [lcs_succ]\n    exact (lie_submodule.mono_lie_right _ _ («expr⊤») ih).trans (N.lie_le_right («expr⊤»))\n#align lcs_le_self lcs_le_self\n\n",
 "lcs_le_iff":
 "theorem lcs_le_iff (k : ℕ) : N₁.lcs k ≤ N₂ ↔ N₁ ≤ N₂.ucs k :=\n  by\n  convert lcs_add_le_iff 0 k\n  rw [zero_add]\n#align lcs_le_iff lcs_le_iff\n\n",
 "lcs_add_le_iff":
 "theorem lcs_add_le_iff (l k : ℕ) : N₁.lcs (l + k) ≤ N₂ ↔ N₁.lcs l ≤ N₂.ucs k :=\n  by\n  revert l\n  induction' k with k ih; · simp\n  intro l\n  rw [(by abel : l + (k + 1) = l + 1 + k), ih, ucs_succ, lcs_succ, top_lie_le_iff_le_normalizer]\n#align lcs_add_le_iff lcs_add_le_iff\n\n",
 "iterate_to_endomorphism_mem_lower_central_series":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_to_endomorphism_mem_lower_central_series (x : L) (m : M) (k : ℕ) :\n    («expr ^[ ]» (to_endomorphism R L M x) k) m ∈ lower_central_series R L M k :=\n  by\n  induction' k with k ih\n  · simp only [Function.iterate_zero]\n  · simp only [lower_central_series_succ, Function.comp_apply, Function.iterate_succ', to_endomorphism_apply_apply]\n    exact lie_submodule.lie_mem_lie _ _ (lie_submodule.mem_top x) ih\n#align iterate_to_endomorphism_mem_lower_central_series iterate_to_endomorphism_mem_lower_central_series\n\n",
 "is_nilpotent_range_to_endomorphism_iff":
 "@[simp]\ntheorem is_nilpotent_range_to_endomorphism_iff : is_nilpotent R (to_endomorphism R L M).range M ↔ is_nilpotent R L M :=\n  by constructor <;> rintro ⟨k, hk⟩ <;> use k <;> rw [← lie_submodule.coe_to_submodule_eq_iff] at hk⊢ <;> simpa using hk\n#align is_nilpotent_range_to_endomorphism_iff is_nilpotent_range_to_endomorphism_iff\n\n",
 "is_nilpotent_range_ad_iff":
 "/-- Note that this result is not quite a special case of\n`lie_module.is_nilpotent_range_to_endomorphism_iff` which concerns nilpotency of the\n`(ad R L).range`-module `L`, whereas this result concerns nilpotency of the `(ad R L).range`-module\n`(ad R L).range`. -/\n@[simp]\ntheorem lie_algebra.is_nilpotent_range_ad_iff : IsNilpotent R (ad R L).range ↔ IsNilpotent R L :=\n  by\n  refine' ⟨fun h => _, _⟩\n  · have : (ad R L).ker = center R L := by simp\n    exact\n      lie_algebra.nilpotent_of_nilpotent_quotient (le_of_eq this)\n        ((ad R L).quot_ker_equiv_range.nilpotent_iff_equiv_nilpotent.mpr h)\n  · intro h\n    exact (ad R L).is_nilpotent_range\n#align lie_algebra.is_nilpotent_range_ad_iff lie_algebra.is_nilpotent_range_ad_iff\n\n",
 "is_nilpotent_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ⁅ ⁆ » -/\ntheorem lie_hom.is_nilpotent_range [IsNilpotent R L] (f : «expr →ₗ⁅ ⁆ » L R L') : IsNilpotent R f.range :=\n  f.surjective_range_restrict.lie_algebra_is_nilpotent\n#align lie_hom.is_nilpotent_range lie_hom.is_nilpotent_range\n\n",
 "is_nilpotent_of_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem lie_module.is_nilpotent_of_top_iff : IsNilpotent R («expr⊤» : LieSubalgebra R L) M ↔ IsNilpotent R L M :=\n  equiv.lie_module_is_nilpotent_iff lie_subalgebra.top_equiv (1 : «expr ≃ₗ[ ] » M R M) fun x m => rfl\n#align lie_module.is_nilpotent_of_top_iff lie_module.is_nilpotent_of_top_iff\n\n",
 "is_nilpotent_iff_exists_ucs_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem _root_.lie_module.is_nilpotent_iff_exists_ucs_eq_top :\n    lie_module.is_nilpotent R L M ↔ ∃ k, («expr⊥» : lie_submodule R L M).ucs k = «expr⊤» :=\n  by\n  rw [lie_module.is_nilpotent_iff]\n  exact exists_congr fun k => by simp [ucs_eq_top_iff]\n#align lie_module.is_nilpotent_iff_exists_ucs_eq_top lie_module.is_nilpotent_iff_exists_ucs_eq_top\n\n",
 "is_nilpotent_iff_exists_self_le_ucs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_nilpotent_iff_exists_self_le_ucs :\n    lie_module.is_nilpotent R L N ↔ ∃ k, N ≤ («expr⊥» : lie_submodule R L M).ucs k := by\n  simp_rw [lie_module.is_nilpotent_iff_exists_ucs_eq_top, ← ucs_comap_incl, comap_incl_eq_top]\n#align is_nilpotent_iff_exists_self_le_ucs is_nilpotent_iff_exists_self_le_ucs\n\n",
 "is_nilpotent_iff_exists_lcs_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem _root_.lie_submodule.is_nilpotent_iff_exists_lcs_eq_bot (N : lie_submodule R L M) :\n    lie_module.is_nilpotent R L N ↔ ∃ k, N.lcs k = «expr⊥» :=\n  by\n  rw [is_nilpotent_iff]\n  refine' exists_congr fun k => _\n  rw [N.lower_central_series_eq_lcs_comap k, lie_submodule.comap_incl_eq_bot, inf_eq_right.mpr (N.lcs_le_self k)]\n#align lie_submodule.is_nilpotent_iff_exists_lcs_eq_bot lie_submodule.is_nilpotent_iff_exists_lcs_eq_bot\n\n",
 "is_nilpotent_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- See also `lie_module.is_nilpotent_iff_exists_ucs_eq_top`. -/\ntheorem is_nilpotent_iff : is_nilpotent R L M ↔ ∃ k, lower_central_series R L M k = «expr⊥» :=\n  ⟨fun h => h.nilpotent, fun h => ⟨h⟩⟩\n#align is_nilpotent_iff is_nilpotent_iff\n\n",
 "is_nilpotent_ad_of_is_nilpotent_ad":
 "theorem lie_subalgebra.is_nilpotent_ad_of_is_nilpotent_ad {L : Type v} [LieRing L] [LieAlgebra R L]\n    (K : LieSubalgebra R L) {x : K} (h : IsNilpotent (lie_algebra.ad R L ↑x)) : IsNilpotent (lie_algebra.ad R K x) :=\n  by\n  obtain ⟨n, hn⟩ := h\n  use n\n  exact LinearMap.submodule_pow_eq_zero_of_pow_eq_zero (K.ad_comp_incl_eq x) hn\n#align lie_subalgebra.is_nilpotent_ad_of_is_nilpotent_ad lie_subalgebra.is_nilpotent_ad_of_is_nilpotent_ad\n\n",
 "is_nilpotent_ad_of_is_nilpotent":
 "theorem lie_algebra.is_nilpotent_ad_of_is_nilpotent {L : LieSubalgebra R A} {x : L} (h : IsNilpotent (x : A)) :\n    IsNilpotent (lie_algebra.ad R L x) :=\n  L.is_nilpotent_ad_of_is_nilpotent_ad <| lie_algebra.ad_nilpotent_of_nilpotent R h\n#align lie_algebra.is_nilpotent_ad_of_is_nilpotent lie_algebra.is_nilpotent_ad_of_is_nilpotent\n\n",
 "infi_max_gen_zero_eigenspace_eq_top_of_nilpotent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- See also `lie_algebra.zero_root_space_eq_top_of_nilpotent`. -/\ntheorem lie_algebra.infi_max_gen_zero_eigenspace_eq_top_of_nilpotent [IsNilpotent R L] :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((ad R L x).maximal_generalized_eigenspace 0) =\n      «expr⊤» :=\n  lie_module.infi_max_gen_zero_eigenspace_eq_top_of_nilpotent R L L\n#align lie_algebra.infi_max_gen_zero_eigenspace_eq_top_of_nilpotent lie_algebra.infi_max_gen_zero_eigenspace_eq_top_of_nilpotent\n\n",
 "gc_lcs_ucs":
 "theorem gc_lcs_ucs (k : ℕ) :\n    GaloisConnection (fun N : lie_submodule R L M => N.lcs k) fun N : lie_submodule R L M => N.ucs k := fun N₁ N₂ =>\n  lcs_le_iff k\n#align gc_lcs_ucs gc_lcs_ucs\n\n",
 "derived_series_le_lower_central_series":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem derived_series_le_lower_central_series (k : ℕ) : derivedSeries R L k ≤ lower_central_series R L L k :=\n  by\n  induction' k with k h\n  · rw [derived_series_def, derived_series_of_ideal_zero, lower_central_series_zero]\n    exact le_rfl\n  · have h' : derivedSeries R L k ≤ «expr⊤» := by simp only [le_top]\n    rw [derived_series_def, derived_series_of_ideal_succ, lower_central_series_succ]\n    exact lie_submodule.mono_lie _ _ _ _ h' h\n#align derived_series_le_lower_central_series derived_series_le_lower_central_series\n\n",
 "coe_lower_central_series_ideal_quot_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n-- TODO Generalise the below to Lie modules if / when we define morphisms, equivs of Lie modules\n-- covering a Lie algebra morphism of (possibly different) Lie algebras.\n/-- Given an ideal `I` of a Lie algebra `L`, the lower central series of `L ⧸ I` is the same\nwhether we regard `L ⧸ I` as an `L` module or an `L ⧸ I` module.\n\nTODO: This result obviously generalises but the generalisation requires the missing definition of\nmorphisms between Lie modules over different Lie algebras. -/\ntheorem coe_lower_central_series_ideal_quot_eq {I : lie_ideal R L} (k : ℕ) :\n    (lower_central_series R L («expr ⧸ » L I) k : Submodule R («expr ⧸ » L I)) =\n      lower_central_series R («expr ⧸ » L I) («expr ⧸ » L I) k :=\n  by\n  induction' k with k ih\n  · simp only [lie_submodule.top_coe_submodule, lie_module.lower_central_series_zero]\n  · simp only [lie_module.lower_central_series_succ, lie_submodule.lie_ideal_oper_eq_linear_span]\n    congr\n    ext x\n    constructor\n    · rintro ⟨⟨y, -⟩, ⟨z, hz⟩, rfl : «expr⁅ , ⁆» y z = x⟩\n      erw [← lie_submodule.mem_coe_submodule, ih, lie_submodule.mem_coe_submodule] at hz\n      exact ⟨⟨lie_submodule.quotient.mk y, lie_submodule.mem_top _⟩, ⟨z, hz⟩, rfl⟩\n    · rintro ⟨⟨⟨y⟩, -⟩, ⟨z, hz⟩, rfl : «expr⁅ , ⁆» y z = x⟩\n      erw [← lie_submodule.mem_coe_submodule, ← ih, lie_submodule.mem_coe_submodule] at hz\n      exact ⟨⟨y, lie_submodule.mem_top _⟩, ⟨z, hz⟩, rfl⟩\n#align coe_lower_central_series_ideal_quot_eq coe_lower_central_series_ideal_quot_eq\n\n",
 "coe_lower_central_series_ideal_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/-- Note that the below inequality can be strict. For example the ideal of strictly-upper-triangular\n2x2 matrices inside the Lie algebra of upper-triangular 2x2 matrices with `k = 1`. -/\ntheorem lie_module.coe_lower_central_series_ideal_le {I : lie_ideal R L} (k : ℕ) :\n    (lower_central_series R I I k : Submodule R I) ≤ lower_central_series R L I k :=\n  by\n  induction' k with k ih\n  · simp\n  · simp only [lie_module.lower_central_series_succ, lie_submodule.lie_ideal_oper_eq_linear_span]\n    apply Submodule.span_mono\n    rintro x ⟨⟨y, -⟩, ⟨z, hz⟩, rfl : «expr⁅ , ⁆» y z = x⟩\n    exact ⟨⟨y.val, lie_submodule.mem_top _⟩, ⟨z, ih hz⟩, rfl⟩\n#align lie_module.coe_lower_central_series_ideal_le lie_module.coe_lower_central_series_ideal_le\n\n",
 "coe_lcs_range_to_endomorphism_eq":
 "@[simp]\ntheorem coe_lcs_range_to_endomorphism_eq (k : ℕ) :\n    (lower_central_series R (to_endomorphism R L M).range M k : Submodule R M) = lower_central_series R L M k :=\n  by\n  induction' k with k ih\n  · simp\n  · simp only [lower_central_series_succ, lie_submodule.lie_ideal_oper_eq_linear_span', ←\n      (lower_central_series R (to_endomorphism R L M).range M k).mem_coe_submodule, ih]\n    congr\n    ext m\n    constructor\n    · rintro ⟨⟨-, ⟨y, rfl⟩⟩, -, n, hn, rfl⟩\n      exact ⟨y, lie_submodule.mem_top _, n, hn, rfl⟩\n    · rintro ⟨x, hx, n, hn, rfl⟩\n      exact ⟨⟨to_endomorphism R L M x, LieHom.mem_range_self _ x⟩, lie_submodule.mem_top _, n, hn, rfl⟩\n#align coe_lcs_range_to_endomorphism_eq coe_lcs_range_to_endomorphism_eq\n\n",
 "coe_lcs_eq":
 "theorem coe_lcs_eq : (I.lcs M k : Submodule R M) = lower_central_series R I M k :=\n  by\n  induction' k with k ih\n  · simp\n  · simp_rw [lower_central_series_succ, lcs_succ, lie_submodule.lie_ideal_oper_eq_linear_span', ←\n      (I.lcs M k).mem_coe_submodule, ih, lie_submodule.mem_coe_submodule, lie_submodule.mem_top, exists_true_left,\n      (I : LieSubalgebra R L).coe_bracket_of_module]\n    congr\n    ext m\n    constructor\n    · rintro ⟨x, hx, m, hm, rfl⟩\n      exact ⟨⟨x, hx⟩, m, hm, rfl⟩\n    · rintro ⟨⟨x, hx⟩, m, hm, rfl⟩\n      exact ⟨x, hx, m, hm, rfl⟩\n#align coe_lcs_eq coe_lcs_eq\n\n",
 "antitone_lower_central_series":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem antitone_lower_central_series : Antitone <| lower_central_series R L M :=\n  by\n  intro l k\n  induction' k with k ih generalizing l <;> intro h\n  · exact (le_zero_iff.mp h).symm ▸ le_rfl\n  · rcases Nat.of_le_succ h with (hk | hk)\n    · rw [lower_central_series_succ]\n      exact (lie_submodule.mono_lie_right _ _ («expr⊤») (ih hk)).trans (lie_submodule.lie_le_right _ _)\n    · exact hk.symm ▸ le_rfl\n#align antitone_lower_central_series antitone_lower_central_series\n\n",
 "ad_nilpotent_of_nilpotent":
 "theorem lie_algebra.ad_nilpotent_of_nilpotent {a : A} (h : IsNilpotent a) : IsNilpotent (lie_algebra.ad R A a) :=\n  by\n  rw [lie_algebra.ad_eq_lmul_left_sub_lmul_right]\n  have hl : IsNilpotent (LinearMap.mulLeft R a) := by rwa [LinearMap.isNilpotent_mulLeft_iff]\n  have hr : IsNilpotent (LinearMap.mulRight R a) := by rwa [LinearMap.isNilpotent_mulRight_iff]\n  have := @LinearMap.commute_mulLeft_right R A _ _ _ _ _ a a\n  exact this.is_nilpotent_sub hl hr\n#align lie_algebra.ad_nilpotent_of_nilpotent lie_algebra.ad_nilpotent_of_nilpotent\n\n"}