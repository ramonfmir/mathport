{"sup_lie":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n@[simp]\ntheorem sup_lie : «expr⁅ , ⁆» («expr ⊔ » I J) N = «expr ⊔ » («expr⁅ , ⁆» I N) («expr⁅ , ⁆» J N) :=\n  by\n  have h : «expr ⊔ » («expr⁅ , ⁆» I N) («expr⁅ , ⁆» J N) ≤ «expr⁅ , ⁆» («expr ⊔ » I J) N :=\n    by\n    rw [sup_le_iff]\n    constructor <;> apply mono_lie_left <;> [exact le_sup_left, exact le_sup_right]\n  suffices «expr⁅ , ⁆» («expr ⊔ » I J) N ≤ «expr ⊔ » («expr⁅ , ⁆» I N) («expr⁅ , ⁆» J N) by exact le_antisymm this h\n  clear h\n  rw [lie_ideal_oper_eq_span, lie_span_le]\n  rintro m ⟨⟨x, hx⟩, n, h⟩\n  erw [lie_submodule.mem_sup]\n  erw [lie_submodule.mem_sup] at hx\n  rcases hx with ⟨x₁, hx₁, x₂, hx₂, hx'⟩\n  use «expr⁅ , ⁆» ((⟨x₁, hx₁⟩ : I) : L) (n : N)\n  constructor\n  · apply lie_coe_mem_lie\n  use «expr⁅ , ⁆» ((⟨x₂, hx₂⟩ : J) : L) (n : N)\n  constructor\n  · apply lie_coe_mem_lie\n  simp [← h, ← hx']\n#align sup_lie sup_lie\n\n",
 "mono_lie_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem mono_lie_right (h : N ≤ N') : «expr⁅ , ⁆» I N ≤ «expr⁅ , ⁆» I N' :=\n  mono_lie _ _ _ _ (le_refl I) h\n#align mono_lie_right mono_lie_right\n\n",
 "mono_lie_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem mono_lie_left (h : I ≤ J) : «expr⁅ , ⁆» I N ≤ «expr⁅ , ⁆» J N :=\n  mono_lie _ _ _ _ h (le_refl N)\n#align mono_lie_left mono_lie_left\n\n",
 "mono_lie":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem mono_lie (h₁ : I ≤ J) (h₂ : N ≤ N') : «expr⁅ , ⁆» I N ≤ «expr⁅ , ⁆» J N' :=\n  by\n  intro m h\n  rw [lie_ideal_oper_eq_span, mem_lie_span] at h; rw [lie_ideal_oper_eq_span, mem_lie_span]\n  intro N hN; apply h; rintro m' ⟨⟨x, hx⟩, ⟨n, hn⟩, hm⟩; rw [← hm]; apply hN\n  use ⟨x, h₁ hx⟩, ⟨n, h₂ hn⟩; rfl\n#align mono_lie mono_lie\n\n",
 "map_comap_le":
 "theorem map_comap_le : map f (comap f N₂) ≤ N₂ :=\n  (N₂ : set M₂).image_preimage_subset f\n#align map_comap_le map_comap_le\n\n",
 "map_comap_incl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem map_comap_incl {I₁ I₂ : lie_ideal R L} : map I₁.incl (comap I₁.incl I₂) = «expr ⊓ » I₁ I₂ :=\n  by\n  conv_rhs => rw [← I₁.incl_ideal_range]\n  rw [← map_comap_eq]\n  exact I₁.incl_is_ideal_morphism\n#align map_comap_incl map_comap_incl\n\n",
 "map_comap_eq":
 "theorem map_comap_eq (hf : N₂ ≤ f.range) : map f (comap f N₂) = N₂ :=\n  by\n  rw [SetLike.ext'_iff]\n  exact Set.image_preimage_eq_of_subset hf\n#align map_comap_eq map_comap_eq\n\n",
 "map_comap_bracket_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem map_comap_bracket_eq {J₁ J₂ : lie_ideal R L'} (h : f.is_ideal_morphism) :\n    map f («expr⁅ , ⁆» (comap f J₁) (comap f J₂)) =\n      «expr⁅ , ⁆» («expr ⊓ » f.ideal_range J₁) («expr ⊓ » f.ideal_range J₂) :=\n  by\n  rw [← map_sup_ker_eq_map, ← comap_bracket_eq h, map_comap_eq h, inf_eq_right]\n  exact le_trans (lie_submodule.lie_le_left _ _) inf_le_left\n#align map_comap_bracket_eq map_comap_bracket_eq\n\n",
 "map_bracket_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/-- Note that the inequality can be strict; e.g., the inclusion of an Abelian subalgebra of a\nsimple algebra. -/\ntheorem map_bracket_le {I₁ I₂ : lie_ideal R L} : map f («expr⁅ , ⁆» I₁ I₂) ≤ «expr⁅ , ⁆» (map f I₁) (map f I₂) :=\n  by\n  rw [map_le_iff_le_comap]; erw [lie_submodule.lie_span_le]\n  intro x hx; obtain ⟨⟨y₁, hy₁⟩, ⟨y₂, hy₂⟩, hx⟩ := hx; rw [← hx]\n  let fy₁ : «expr↥ » (map f I₁) := ⟨f y₁, mem_map hy₁⟩\n  let fy₂ : «expr↥ » (map f I₂) := ⟨f y₂, mem_map hy₂⟩\n  change _ ∈ comap f («expr⁅ , ⁆» (map f I₁) (map f I₂))\n  simp only [submodule.coe_mk, mem_comap, lie_hom.map_lie]\n  exact lie_submodule.lie_coe_mem_lie _ _ fy₁ fy₂\n#align map_bracket_le map_bracket_le\n\n",
 "map_bracket_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem map_bracket_eq {I₁ I₂ : lie_ideal R L} (h : function.surjective f) :\n    map f («expr⁅ , ⁆» I₁ I₂) = «expr⁅ , ⁆» (map f I₁) (map f I₂) :=\n  by\n  suffices «expr⁅ , ⁆» (map f I₁) (map f I₂) ≤ map f («expr⁅ , ⁆» I₁ I₂) by exact le_antisymm (map_bracket_le f) this\n  rw [← lie_submodule.coe_submodule_le_coe_submodule, coe_map_of_surjective h,\n    lie_submodule.lie_ideal_oper_eq_linear_span, lie_submodule.lie_ideal_oper_eq_linear_span, linear_map.map_span]\n  apply submodule.span_mono\n  rintro x ⟨⟨z₁, h₁⟩, ⟨z₂, h₂⟩, rfl⟩\n  obtain ⟨y₁, rfl⟩ := mem_map_of_surjective h h₁\n  obtain ⟨y₂, rfl⟩ := mem_map_of_surjective h h₂\n  use «expr⁅ , ⁆» (y₁ : L) (y₂ : L), y₁, y₂\n  apply f.map_lie\n#align map_bracket_eq map_bracket_eq\n\n",
 "lie_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n@[simp]\ntheorem lie_sup : «expr⁅ , ⁆» I («expr ⊔ » N N') = «expr ⊔ » («expr⁅ , ⁆» I N) («expr⁅ , ⁆» I N') :=\n  by\n  have h : «expr ⊔ » («expr⁅ , ⁆» I N) («expr⁅ , ⁆» I N') ≤ «expr⁅ , ⁆» I («expr ⊔ » N N') :=\n    by\n    rw [sup_le_iff]\n    constructor <;> apply mono_lie_right <;> [exact le_sup_left, exact le_sup_right]\n  suffices «expr⁅ , ⁆» I («expr ⊔ » N N') ≤ «expr ⊔ » («expr⁅ , ⁆» I N) («expr⁅ , ⁆» I N') by exact le_antisymm this h\n  clear h\n  rw [lie_ideal_oper_eq_span, lie_span_le]\n  rintro m ⟨x, ⟨n, hn⟩, h⟩\n  erw [lie_submodule.mem_sup]\n  erw [lie_submodule.mem_sup] at hn\n  rcases hn with ⟨n₁, hn₁, n₂, hn₂, hn'⟩\n  use «expr⁅ , ⁆» (x : L) (⟨n₁, hn₁⟩ : N)\n  constructor\n  · apply lie_coe_mem_lie\n  use «expr⁅ , ⁆» (x : L) (⟨n₂, hn₂⟩ : N')\n  constructor\n  · apply lie_coe_mem_lie\n  simp [← h, ← hn']\n#align lie_sup lie_sup\n\n",
 "lie_mem_lie":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem lie_mem_lie {x : L} {m : M} (hx : x ∈ I) (hm : m ∈ N) : «expr⁅ , ⁆» x m ∈ «expr⁅ , ⁆» I N :=\n  N.lie_coe_mem_lie I ⟨x, hx⟩ ⟨m, hm⟩\n#align lie_mem_lie lie_mem_lie\n\n",
 "lie_le_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem lie_le_right : «expr⁅ , ⁆» I N ≤ N :=\n  by\n  rw [lie_ideal_oper_eq_span, lie_span_le]; rintro m ⟨x, n, hn⟩; rw [← hn]\n  exact N.lie_mem n.property\n#align lie_le_right lie_le_right\n\n",
 "lie_le_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem lie_le_left : «expr⁅ , ⁆» I J ≤ I := by\n  rw [lie_comm]\n  exact lie_le_right I J\n#align lie_le_left lie_le_left\n\n",
 "lie_le_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem lie_le_inf : «expr⁅ , ⁆» I J ≤ «expr ⊓ » I J :=\n  by\n  rw [le_inf_iff]\n  exact ⟨lie_le_left I J, lie_le_right J I⟩\n#align lie_le_inf lie_le_inf\n\n",
 "lie_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem lie_le_iff : «expr⁅ , ⁆» I N ≤ N' ↔ ∀ x ∈ I, ∀ m ∈ N, «expr⁅ , ⁆» x m ∈ N' :=\n  by\n  rw [lie_ideal_oper_eq_span, lie_submodule.lie_span_le]\n  refine' ⟨fun h x hx m hm => h ⟨⟨x, hx⟩, ⟨m, hm⟩, rfl⟩, _⟩\n  rintro h _ ⟨⟨x, hx⟩, ⟨m, hm⟩, rfl⟩\n  exact h x hx m hm\n#align lie_le_iff lie_le_iff\n\n",
 "lie_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n@[simp]\ntheorem lie_inf : «expr⁅ , ⁆» I («expr ⊓ » N N') ≤ «expr ⊓ » («expr⁅ , ⁆» I N) («expr⁅ , ⁆» I N') :=\n  by\n  rw [le_inf_iff]\n  constructor <;> apply mono_lie_right <;> [exact inf_le_left, exact inf_le_right]\n#align lie_inf lie_inf\n\n",
 "lie_ideal_oper_eq_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/-\nCopyright (c) 2021 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\ntheorem lie_ideal_oper_eq_span :\n    «expr⁅ , ⁆» I N = lie_span R L { m | ∃ (x : I)(n : N), «expr⁅ , ⁆» (x : L) (n : M) = m } :=\n  rfl\n#align lie_ideal_oper_eq_span lie_ideal_oper_eq_span\n\n",
 "lie_ideal_oper_eq_linear_span'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem lie_ideal_oper_eq_linear_span' :\n    (↑(«expr⁅ , ⁆» I N) : submodule R M) = submodule.span R { m | ∃ x ∈ I, ∃ n ∈ N, «expr⁅ , ⁆» x n = m } :=\n  by\n  rw [lie_ideal_oper_eq_linear_span]\n  congr\n  ext m\n  constructor\n  · rintro ⟨⟨x, hx⟩, ⟨n, hn⟩, rfl⟩\n    exact ⟨x, hx, n, hn, rfl⟩\n  · rintro ⟨x, hx, n, hn, rfl⟩\n    exact ⟨⟨x, hx⟩, ⟨n, hn⟩, rfl⟩\n#align lie_ideal_oper_eq_linear_span' lie_ideal_oper_eq_linear_span'\n\n",
 "lie_ideal_oper_eq_linear_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/-- See also `lie_submodule.lie_ideal_oper_eq_linear_span'` and\n`lie_submodule.lie_ideal_oper_eq_tensor_map_range`. -/\ntheorem lie_ideal_oper_eq_linear_span :\n    (↑(«expr⁅ , ⁆» I N) : submodule R M) = submodule.span R { m | ∃ (x : I)(n : N), «expr⁅ , ⁆» (x : L) (n : M) = m } :=\n  by\n  apply le_antisymm\n  · let s := { m : M | ∃ (x : «expr↥ » I)(n : «expr↥ » N), «expr⁅ , ⁆» (x : L) (n : M) = m }\n    have aux : ∀ (y : L), ∀ m' ∈ submodule.span R s, «expr⁅ , ⁆» y m' ∈ submodule.span R s :=\n      by\n      intro y m' hm'\n      apply submodule.span_induction hm'\n      · rintro m'' ⟨x, n, hm''⟩\n        rw [← hm'', leibniz_lie]\n        refine' submodule.add_mem _ _ _ <;> apply submodule.subset_span\n        · use ⟨«expr⁅ , ⁆» y ↑x, I.lie_mem x.property⟩, n\n          rfl\n        · use x, ⟨«expr⁅ , ⁆» y ↑n, N.lie_mem n.property⟩\n          rfl\n      · simp only [lie_zero, submodule.zero_mem]\n      · intro m₁ m₂ hm₁ hm₂\n        rw [lie_add]\n        exact submodule.add_mem _ hm₁ hm₂\n      · intro t m'' hm''\n        rw [lie_smul]\n        exact submodule.smul_mem _ t hm''\n    change _ ≤ ↑({ submodule.span R s with lie_mem := aux } : lie_submodule R L M)\n    rw [coe_submodule_le_coe_submodule, lie_ideal_oper_eq_span, lie_span_le]\n    exact submodule.subset_span\n  · rw [lie_ideal_oper_eq_span]\n    apply submodule_span_le_lie_span\n#align lie_ideal_oper_eq_linear_span lie_ideal_oper_eq_linear_span\n\n",
 "lie_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem lie_eq_bot_iff : «expr⁅ , ⁆» I N = «expr⊥» ↔ ∀ x ∈ I, ∀ m ∈ N, «expr⁅ , ⁆» (x : L) m = 0 :=\n  by\n  rw [lie_ideal_oper_eq_span, lie_submodule.lie_span_eq_bot_iff]\n  refine' ⟨fun h x hx m hm => h («expr⁅ , ⁆» x m) ⟨⟨x, hx⟩, ⟨m, hm⟩, rfl⟩, _⟩\n  rintro h - ⟨⟨x, hx⟩, ⟨⟨n, hn⟩, rfl⟩⟩\n  exact h x hx n hn\n#align lie_eq_bot_iff lie_eq_bot_iff\n\n",
 "lie_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem lie_comm : «expr⁅ , ⁆» I J = «expr⁅ , ⁆» J I :=\n  by\n  suffices ∀ I J : lie_ideal R L, «expr⁅ , ⁆» I J ≤ «expr⁅ , ⁆» J I by exact le_antisymm (this I J) (this J I)\n  clear I J\n  intro I J\n  rw [lie_ideal_oper_eq_span, lie_span_le]\n  rintro x ⟨y, z, h⟩\n  rw [← h]\n  rw [← lie_skew, ← lie_neg, ← lie_submodule.coe_neg]\n  apply lie_coe_mem_lie\n#align lie_comm lie_comm\n\n",
 "lie_coe_mem_lie":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem lie_coe_mem_lie (x : I) (m : N) : «expr⁅ , ⁆» (x : L) (m : M) ∈ «expr⁅ , ⁆» I N :=\n  by\n  rw [lie_ideal_oper_eq_span]\n  apply subset_lie_span\n  use x, m\n#align lie_coe_mem_lie lie_coe_mem_lie\n\n",
 "lie_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem lie_bot : «expr⁅ , ⁆» I («expr⊥» : lie_submodule R L M) = «expr⊥» :=\n  by\n  rw [eq_bot_iff]\n  apply lie_le_right\n#align lie_bot lie_bot\n\n",
 "le_comap_map":
 "theorem le_comap_map : N ≤ comap f (map f N) :=\n  (N : set M).subset_preimage_image f\n#align le_comap_map le_comap_map\n\n",
 "inf_lie":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n@[simp]\ntheorem inf_lie : «expr⁅ , ⁆» («expr ⊓ » I J) N ≤ «expr ⊓ » («expr⁅ , ⁆» I N) («expr⁅ , ⁆» J N) :=\n  by\n  rw [le_inf_iff]\n  constructor <;> apply mono_lie_left <;> [exact inf_le_left, exact inf_le_right]\n#align inf_lie inf_lie\n\n",
 "comap_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem comap_map_eq (hf : f.ker = «expr⊥») : comap f (map f N) = N :=\n  by\n  rw [SetLike.ext'_iff]\n  exact (N : set M).preimage_image_eq (f.ker_eq_bot.mp hf)\n#align comap_map_eq comap_map_eq\n\n",
 "comap_bracket_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem comap_bracket_le {J₁ J₂ : lie_ideal R L'} :\n    «expr⁅ , ⁆» (comap f J₁) (comap f J₂) ≤ comap f («expr⁅ , ⁆» J₁ J₂) :=\n  by\n  rw [← map_le_iff_le_comap]\n  exact le_trans (map_bracket_le f) (lie_submodule.mono_lie _ _ _ _ map_comap_le map_comap_le)\n#align comap_bracket_le comap_bracket_le\n\n",
 "comap_bracket_incl_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/-- This is a very useful result; it allows us to use the fact that inclusion distributes over the\nLie bracket operation on ideals, subject to the conditions shown. -/\ntheorem comap_bracket_incl_of_le {I₁ I₂ : lie_ideal R L} (h₁ : I₁ ≤ I) (h₂ : I₂ ≤ I) :\n    «expr⁅ , ⁆» (comap I.incl I₁) (comap I.incl I₂) = comap I.incl («expr⁅ , ⁆» I₁ I₂) :=\n  by\n  rw [comap_bracket_incl]\n  rw [← inf_eq_right] at h₁ h₂\n  rw [h₁, h₂]\n#align comap_bracket_incl_of_le comap_bracket_incl_of_le\n\n",
 "comap_bracket_incl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem comap_bracket_incl {I₁ I₂ : lie_ideal R L} :\n    «expr⁅ , ⁆» (comap I.incl I₁) (comap I.incl I₂) = comap I.incl («expr⁅ , ⁆» («expr ⊓ » I I₁) («expr ⊓ » I I₂)) :=\n  by\n  conv_rhs =>\n    congr\n    skip\n    rw [← I.incl_ideal_range];\n  rw [comap_bracket_eq]\n  simp only [ker_incl, sup_bot_eq]; exact I.incl_is_ideal_morphism\n#align comap_bracket_incl comap_bracket_incl\n\n",
 "comap_bracket_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem comap_bracket_eq {J₁ J₂ : lie_ideal R L'} (h : f.is_ideal_morphism) :\n    comap f («expr⁅ , ⁆» («expr ⊓ » f.ideal_range J₁) («expr ⊓ » f.ideal_range J₂)) =\n      «expr ⊔ » («expr⁅ , ⁆» (comap f J₁) (comap f J₂)) f.ker :=\n  by\n  rw [← lie_submodule.coe_to_submodule_eq_iff, comap_coe_submodule, lie_submodule.sup_coe_to_submodule,\n    f.ker_coe_submodule, ← submodule.comap_map_eq, lie_submodule.lie_ideal_oper_eq_linear_span,\n    lie_submodule.lie_ideal_oper_eq_linear_span, linear_map.map_span]\n  congr ; simp only [lie_hom.coe_to_linear_map, Set.mem_setOf_eq]; ext y\n  constructor\n  · rintro ⟨⟨x₁, hx₁⟩, ⟨x₂, hx₂⟩, hy⟩\n    rw [← hy]\n    erw [lie_submodule.mem_inf, f.mem_ideal_range_iff h] at hx₁ hx₂\n    obtain ⟨⟨z₁, hz₁⟩, hz₁'⟩ := hx₁\n    rw [← hz₁] at hz₁'\n    obtain ⟨⟨z₂, hz₂⟩, hz₂'⟩ := hx₂\n    rw [← hz₂] at hz₂'\n    use «expr⁅ , ⁆» z₁ z₂, ⟨z₁, hz₁'⟩, ⟨z₂, hz₂'⟩, rfl\n    simp only [hz₁, hz₂, submodule.coe_mk, lie_hom.map_lie]\n  · rintro ⟨x, ⟨⟨z₁, hz₁⟩, ⟨z₂, hz₂⟩, hx⟩, hy⟩\n    rw [← hy, ← hx]\n    have hz₁' : f z₁ ∈ «expr ⊓ » f.ideal_range J₁ :=\n      by\n      rw [lie_submodule.mem_inf]\n      exact ⟨f.mem_ideal_range, hz₁⟩\n    have hz₂' : f z₂ ∈ «expr ⊓ » f.ideal_range J₂ :=\n      by\n      rw [lie_submodule.mem_inf]\n      exact ⟨f.mem_ideal_range, hz₂⟩\n    use ⟨f z₁, hz₁'⟩, ⟨f z₂, hz₂'⟩\n    simp only [submodule.coe_mk, lie_hom.map_lie]\n#align comap_bracket_eq comap_bracket_eq\n\n",
 "bot_lie":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem bot_lie : «expr⁅ , ⁆» («expr⊥» : lie_ideal R L) N = «expr⊥» :=\n  by\n  suffices «expr⁅ , ⁆» («expr⊥» : lie_ideal R L) N ≤ «expr⊥» by exact le_bot_iff.mp this\n  rw [lie_ideal_oper_eq_span, lie_span_le]\n  rintro m ⟨⟨x, hx⟩, n, hn⟩\n  rw [← hn]\n  change x ∈ («expr⊥» : lie_ideal R L) at hx\n  rw [mem_bot] at hx\n  simp [hx]\n#align bot_lie bot_lie\n\n"}