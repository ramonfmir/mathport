{"ucs_eq_self_of_is_cartan_subalgebra":
 "@[simp]\ntheorem ucs_eq_self_of_is_cartan_subalgebra (H : LieSubalgebra R L) [H.is_cartan_subalgebra] (k : ℕ) :\n    H.to_lie_submodule.ucs k = H.to_lie_submodule :=\n  by\n  induction' k with k ih\n  · simp\n  · simp [ih]\n#align ucs_eq_self_of_is_cartan_subalgebra ucs_eq_self_of_is_cartan_subalgebra\n\n",
 "normalizer_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem lie_ideal.normalizer_eq_top {R : Type u} {L : Type v} [CommRing R] [LieRing L] [LieAlgebra R L]\n    (I : lie_ideal R L) : (I : LieSubalgebra R L).normalizer = «expr⊤» :=\n  by\n  ext x\n  simpa only [lie_subalgebra.mem_normalizer_iff, LieSubalgebra.mem_top, iff_true_iff] using fun y hy => I.lie_mem hy\n#align lie_ideal.normalizer_eq_top lie_ideal.normalizer_eq_top\n\n",
 "normalizer_eq_self_of_is_cartan_subalgebra":
 "/-\nCopyright (c) 2021 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\n@[simp]\ntheorem normalizer_eq_self_of_is_cartan_subalgebra (H : LieSubalgebra R L) [H.is_cartan_subalgebra] :\n    H.to_lie_submodule.normalizer = H.to_lie_submodule := by\n  rw [← lie_submodule.coe_to_submodule_eq_iff, coe_normalizer_eq_normalizer, is_cartan_subalgebra.self_normalizing,\n    coe_to_lie_submodule]\n#align normalizer_eq_self_of_is_cartan_subalgebra normalizer_eq_self_of_is_cartan_subalgebra\n\n",
 "is_cartan_subalgebra_iff_is_ucs_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_cartan_subalgebra_iff_is_ucs_limit : H.is_cartan_subalgebra ↔ H.to_lie_submodule.is_ucs_limit :=\n  by\n  constructor\n  · intro h\n    have h₁ : _root_.lie_algebra.is_nilpotent R H := by infer_instance\n    obtain ⟨k, hk⟩ := H.to_lie_submodule.is_nilpotent_iff_exists_self_le_ucs.mp h₁\n    replace hk : H.to_lie_submodule = lie_submodule.ucs k («expr⊥») :=\n      le_antisymm hk (lie_submodule.ucs_le_of_normalizer_eq_self H.normalizer_eq_self_of_is_cartan_subalgebra k)\n    refine' ⟨k, fun l hl => _⟩\n    rw [← nat.sub_add_cancel hl, lie_submodule.ucs_add, ← hk, lie_subalgebra.ucs_eq_self_of_is_cartan_subalgebra]\n  · rintro ⟨k, hk⟩\n    exact\n      { nilpotent := by\n          dsimp only [lie_algebra.is_nilpotent]\n          erw [H.to_lie_submodule.is_nilpotent_iff_exists_lcs_eq_bot]\n          use k\n          rw [_root_.eq_bot_iff, lie_submodule.lcs_le_iff, hk k (le_refl k)]\n          exact le_refl _\n        self_normalizing := by\n          have hk' := hk (k + 1) k.le_succ\n          rw [lie_submodule.ucs_succ, hk k (le_refl k)] at hk'\n          rw [← LieSubalgebra.coe_to_submodule_eq_iff, ← lie_subalgebra.coe_normalizer_eq_normalizer, hk',\n            lie_subalgebra.coe_to_lie_submodule] }\n#align is_cartan_subalgebra_iff_is_ucs_limit is_cartan_subalgebra_iff_is_ucs_limit\n\n"}