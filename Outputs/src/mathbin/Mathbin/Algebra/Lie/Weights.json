{"zero_weight_space_eq_top_of_nilpotent'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- See also the more useful form `lie_module.zero_weight_space_eq_top_of_nilpotent`. -/\n@[simp]\ntheorem zero_weight_space_eq_top_of_nilpotent' [lie_algebra.is_nilpotent R L] [is_nilpotent R L M] :\n    weight_space M (0 : L → R) = «expr⊤» :=\n  by\n  rw [← lie_submodule.coe_to_submodule_eq_iff, lie_submodule.top_coe_submodule]\n  exact infi_max_gen_zero_eigenspace_eq_top_of_nilpotent R L M\n#align zero_weight_space_eq_top_of_nilpotent' zero_weight_space_eq_top_of_nilpotent'\n\n",
 "zero_weight_space_eq_top_of_nilpotent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem zero_weight_space_eq_top_of_nilpotent [lie_algebra.is_nilpotent R L] [is_nilpotent R L M] :\n    weight_space M (0 : («expr⊤» : lie_subalgebra R L) → R) = «expr⊤» :=\n  by\n  /- We use `coe_weight_space_of_top` as a trick to circumvent the fact that we don't (yet) know\n      `is_nilpotent R (⊤ : lie_subalgebra R L) M` is equivalent to `is_nilpotent R L M`. -/\n  have h₀ : (0 : L → R) ∘ («expr⊤» : lie_subalgebra R L).incl = 0 :=\n    by\n    ext\n    rfl\n  rw [← lie_submodule.coe_to_submodule_eq_iff, lie_submodule.top_coe_submodule, ← h₀, coe_weight_space_of_top, ←\n    infi_max_gen_zero_eigenspace_eq_top_of_nilpotent R L M]\n  rfl\n#align zero_weight_space_eq_top_of_nilpotent zero_weight_space_eq_top_of_nilpotent\n\n",
 "zero_root_subalgebra_normalizer_eq_self":
 "@[simp]\ntheorem zero_root_subalgebra_normalizer_eq_self :\n    (zero_root_subalgebra R L H).normalizer = zero_root_subalgebra R L H :=\n  by\n  refine' le_antisymm _ (lie_subalgebra.le_normalizer _)\n  intro x hx\n  rw [lie_subalgebra.mem_normalizer_iff] at hx\n  rw [mem_zero_root_subalgebra]\n  rintro ⟨y, hy⟩\n  specialize hx y (le_zero_root_subalgebra R L H hy)\n  rw [mem_zero_root_subalgebra] at hx\n  obtain ⟨k, hk⟩ := hx ⟨y, hy⟩\n  rw [← lie_skew, linear_map.map_neg, neg_eq_zero] at hk\n  use k + 1\n  rw [linear_map.iterate_succ, linear_map.coe_comp, Function.comp_apply, to_endomorphism_apply_apply,\n    lie_subalgebra.coe_bracket_of_module, submodule.coe_mk, hk]\n#align zero_root_subalgebra_normalizer_eq_self zero_root_subalgebra_normalizer_eq_self\n\n",
 "zero_root_subalgebra_eq_of_is_cartan":
 "@[simp]\ntheorem zero_root_subalgebra_eq_of_is_cartan (H : lie_subalgebra R L) [H.is_cartan_subalgebra] [is_noetherian R L] :\n    zero_root_subalgebra R L H = H :=\n  by\n  refine' le_antisymm _ (le_zero_root_subalgebra R L H)\n  suffices root_space H 0 ≤ H.to_lie_submodule by exact fun x hx => this hx\n  obtain ⟨k, hk⟩ := (root_space H 0).is_nilpotent_iff_exists_self_le_ucs.mp (by infer_instance)\n  exact hk.trans (lie_submodule.ucs_le_of_centralizer_eq_self (by simp) k)\n#align zero_root_subalgebra_eq_of_is_cartan zero_root_subalgebra_eq_of_is_cartan\n\n",
 "zero_root_subalgebra_eq_iff_is_cartan":
 "theorem zero_root_subalgebra_eq_iff_is_cartan [is_noetherian R L] :\n    zero_root_subalgebra R L H = H ↔ H.is_cartan_subalgebra :=\n  ⟨is_cartan_of_zero_root_subalgebra_eq R L H, by\n    intros\n    simp⟩\n#align zero_root_subalgebra_eq_iff_is_cartan zero_root_subalgebra_eq_iff_is_cartan\n\n",
 "zero_root_space_eq_top_of_nilpotent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem zero_root_space_eq_top_of_nilpotent [h : is_nilpotent R L] :\n    root_space («expr⊤» : lie_subalgebra R L) 0 = «expr⊤» :=\n  zero_weight_space_eq_top_of_nilpotent L\n#align zero_root_space_eq_top_of_nilpotent zero_root_space_eq_top_of_nilpotent\n\n",
 "weight_vector_multiplication":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ⁅ , ⁆ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/-- See also `bourbaki1975b` Chapter VII §1.1, Proposition 2 (ii). -/\nprotected theorem weight_vector_multiplication (M₁ : Type w₁) (M₂ : Type w₂) (M₃ : Type w₃) [add_comm_group M₁]\n    [Module R M₁] [lie_ring_module L M₁] [lie_module R L M₁] [add_comm_group M₂] [Module R M₂] [lie_ring_module L M₂]\n    [lie_module R L M₂] [add_comm_group M₃] [Module R M₃] [lie_ring_module L M₃] [lie_module R L M₃]\n    (g : «expr →ₗ⁅ , ⁆ » (tensor_product M₁ R M₂) R L M₃) (χ₁ χ₂ : L → R) :\n    ((g : «expr →ₗ[ ] » (tensor_product M₁ R M₂) R M₃).comp\n          (map_incl (pre_weight_space M₁ χ₁) (pre_weight_space M₂ χ₂))).range ≤\n      pre_weight_space M₃ (χ₁ + χ₂) :=\n  by\n  -- Unpack the statement of the goal.\n  intro m₃\n  simp only [lie_module_hom.coe_to_linear_map, pi.add_apply, Function.comp_apply, mem_pre_weight_space,\n    linear_map.coe_comp, tensor_product.map_incl, exists_imp, linear_map.mem_range]\n  rintro t rfl x\n  -- Set up some notation.\n  let F : module.End R M₃ := to_endomorphism R L M₃ x - «expr • » (χ₁ x + χ₂ x) 1\n  change ∃ k, (F ^ k) (g _) = 0\n  -- The goal is linear in `t` so use induction to reduce to the case that `t` is a pure tensor.\n  apply t.induction_on\n  · use 0\n    simp only [linear_map.map_zero, lie_module_hom.map_zero]\n  swap\n  · rintro t₁ t₂ ⟨k₁, hk₁⟩ ⟨k₂, hk₂⟩\n    use max k₁ k₂\n    simp only [lie_module_hom.map_add, linear_map.map_add, linear_map.pow_map_zero_of_le (le_max_left k₁ k₂) hk₁,\n      linear_map.pow_map_zero_of_le (le_max_right k₁ k₂) hk₂, add_zero]\n  -- Now the main argument: pure tensors.\n  rintro ⟨m₁, hm₁⟩ ⟨m₂, hm₂⟩\n  change ∃ k, (F ^ k) ((g : «expr →ₗ[ ] » (tensor_product M₁ R M₂) R M₃) («expr ⊗ₜ » m₁ m₂)) = 0\n  -- Eliminate `g` from the picture.\n  let f₁ : module.End R (tensor_product M₁ R M₂) := (to_endomorphism R L M₁ x - «expr • » (χ₁ x) 1).rtensor M₂\n  let f₂ : module.End R (tensor_product M₁ R M₂) := (to_endomorphism R L M₂ x - «expr • » (χ₂ x) 1).ltensor M₁\n  have h_comm_square : «expr ∘ₗ » F ↑g = (g : «expr →ₗ[ ] » (tensor_product M₁ R M₂) R M₃).comp (f₁ + f₂) :=\n    by\n    ext (m₁ m₂)\n    simp only [← g.map_lie x («expr ⊗ₜ » m₁ m₂), add_smul, sub_tmul, tmul_sub, smul_tmul, lie_tmul_right, tmul_smul,\n      to_endomorphism_apply_apply, lie_module_hom.map_smul, linear_map.one_apply, lie_module_hom.coe_to_linear_map,\n      linear_map.smul_apply, Function.comp_apply, linear_map.coe_comp, linear_map.rtensor_tmul, lie_module_hom.map_add,\n      linear_map.add_apply, lie_module_hom.map_sub, linear_map.sub_apply, linear_map.ltensor_tmul,\n      algebra_tensor_module.curry_apply, curry_apply, linear_map.to_fun_eq_coe, linear_map.coe_restrict_scalars_eq_coe]\n    abel\n  rsuffices ⟨k, hk⟩ : ∃ k, ((f₁ + f₂) ^ k) («expr ⊗ₜ » m₁ m₂) = 0\n  · use k\n    rw [← linear_map.comp_apply, linear_map.commute_pow_left_of_commute h_comm_square, linear_map.comp_apply, hk,\n      linear_map.map_zero]\n  -- Unpack the information we have about `m₁`, `m₂`.\n  simp only [mem_pre_weight_space] at hm₁ hm₂\n  obtain ⟨k₁, hk₁⟩ := hm₁ x\n  obtain ⟨k₂, hk₂⟩ := hm₂ x\n  have hf₁ : (f₁ ^ k₁) («expr ⊗ₜ » m₁ m₂) = 0 := by\n    simp only [hk₁, zero_tmul, linear_map.rtensor_tmul, linear_map.rtensor_pow]\n  have hf₂ : (f₂ ^ k₂) («expr ⊗ₜ » m₁ m₂) = 0 := by\n    simp only [hk₂, tmul_zero, linear_map.ltensor_tmul, linear_map.ltensor_pow]\n  -- It's now just an application of the binomial theorem.\n  use k₁ + k₂ - 1\n  have hf_comm : Commute f₁ f₂ := by\n    ext (m₁ m₂)\n    simp only [linear_map.mul_apply, linear_map.rtensor_tmul, linear_map.ltensor_tmul,\n      algebra_tensor_module.curry_apply, linear_map.to_fun_eq_coe, linear_map.ltensor_tmul, curry_apply,\n      linear_map.coe_restrict_scalars_eq_coe]\n  rw [hf_comm.add_pow']\n  simp only [tensor_product.map_incl, submodule.subtype_apply, finset.sum_apply, submodule.coe_mk,\n    linear_map.coe_fn_sum, tensor_product.map_tmul, linear_map.smul_apply]\n  -- The required sum is zero because each individual term is zero.\n  apply finset.sum_eq_zero\n  rintro ⟨i, j⟩ hij\n  -- Eliminate the binomial coefficients from the picture.\n  suffices (f₁ ^ i * f₂ ^ j) («expr ⊗ₜ » m₁ m₂) = 0 by\n    rw [this]\n    apply smul_zero\n  -- Finish off with appropriate case analysis.\n  cases' Nat.le_or_le_of_add_eq_add_pred (finset.nat.mem_antidiagonal.mp hij) with hi hj\n  · rw [(hf_comm.pow_pow i j).eq, linear_map.mul_apply, linear_map.pow_map_zero_of_le hi hf₁, linear_map.map_zero]\n  · rw [linear_map.mul_apply, linear_map.pow_map_zero_of_le hj hf₂, linear_map.map_zero]\n#align weight_vector_multiplication weight_vector_multiplication\n\n",
 "to_lie_submodule_le_root_space_zero":
 "theorem to_lie_submodule_le_root_space_zero : H.to_lie_submodule ≤ root_space H 0 :=\n  by\n  intro x hx\n  simp only [lie_subalgebra.mem_to_lie_submodule] at hx\n  simp only [mem_weight_space, mem_pre_weight_space, pi.zero_apply, sub_zero, zero_smul]\n  intro y\n  obtain ⟨k, hk⟩ := (infer_instance : is_nilpotent R H)\n  use k\n  let f : module.End R H := to_endomorphism R H H y\n  let g : module.End R L := to_endomorphism R H L y\n  have hfg : g.comp (H : submodule R L).subtype = (H : submodule R L).subtype.comp f :=\n    by\n    ext z\n    simp only [to_endomorphism_apply_apply, submodule.subtype_apply, lie_subalgebra.coe_bracket_of_module,\n      lie_subalgebra.coe_bracket, Function.comp_apply, linear_map.coe_comp]\n  change (g ^ k).comp (H : submodule R L).subtype ⟨x, hx⟩ = 0\n  rw [linear_map.commute_pow_left_of_commute hfg k]\n  have h := iterate_to_endomorphism_mem_lower_central_series R H H y ⟨x, hx⟩ k\n  rw [hk, lie_submodule.mem_bot] at h\n  simp only [submodule.subtype_apply, Function.comp_apply, linear_map.pow_apply, linear_map.coe_comp,\n    submodule.coe_eq_zero]\n  exact h\n#align to_lie_submodule_le_root_space_zero to_lie_submodule_le_root_space_zero\n\n",
 "root_space_product_tmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem root_space_product_tmul (χ₁ χ₂ χ₃ : H → R) (hχ : χ₁ + χ₂ = χ₃) (x : root_space H χ₁) (y : root_space H χ₂) :\n    (root_space_product R L H χ₁ χ₂ χ₃ hχ («expr ⊗ₜ » x y) : L) = «expr⁅ , ⁆» (x : L) (y : L) := by\n  simp only [root_space_product_def, coe_root_space_weight_space_product_tmul]\n#align root_space_product_tmul root_space_product_tmul\n\n",
 "root_space_product_def":
 "@[simp]\ntheorem root_space_product_def : root_space_product R L H = root_space_weight_space_product R L H L :=\n  rfl\n#align root_space_product_def root_space_product_def\n\n",
 "root_space_comap_eq_weight_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem root_space_comap_eq_weight_space (χ : H → R) : (root_space H χ).comap H.incl' = weight_space H χ :=\n  by\n  ext x\n  let f : H → module.End R L := fun y => to_endomorphism R H L y - «expr • » (χ y) 1\n  let g : H → module.End R H := fun y => to_endomorphism R H H y - «expr • » (χ y) 1\n  suffices\n    (∀ y : H, ∃ k : ℕ, (f y ^ k).comp (H.incl : «expr →ₗ[ ] » H R L) x = 0) ↔\n      ∀ y : H, ∃ k : ℕ, (H.incl : «expr →ₗ[ ] » H R L).comp (g y ^ k) x = 0\n    by\n    simp only [lie_hom.coe_to_linear_map, lie_subalgebra.coe_incl, Function.comp_apply, linear_map.coe_comp,\n      submodule.coe_eq_zero] at this\n    simp only [mem_weight_space, mem_pre_weight_space, lie_subalgebra.coe_incl', lie_submodule.mem_comap, this]\n  have hfg : ∀ y : H, (f y).comp (H.incl : «expr →ₗ[ ] » H R L) = (H.incl : «expr →ₗ[ ] » H R L).comp (g y) :=\n    by\n    rintro ⟨y, hy⟩\n    ext ⟨z, hz⟩\n    simp only [submodule.coe_sub, to_endomorphism_apply_apply, lie_hom.coe_to_linear_map, linear_map.one_apply,\n      lie_subalgebra.coe_incl, lie_subalgebra.coe_bracket_of_module, lie_subalgebra.coe_bracket, linear_map.smul_apply,\n      Function.comp_apply, submodule.coe_smul_of_tower, linear_map.coe_comp, linear_map.sub_apply]\n  simp_rw [linear_map.commute_pow_left_of_commute (hfg _)]\n#align root_space_comap_eq_weight_space root_space_comap_eq_weight_space\n\n",
 "mem_zero_root_subalgebra":
 "theorem mem_zero_root_subalgebra (x : L) :\n    x ∈ zero_root_subalgebra R L H ↔ ∀ y : H, ∃ k : ℕ, (to_endomorphism R H L y ^ k) x = 0 := by\n  simp only [zero_root_subalgebra, mem_weight_space, mem_pre_weight_space, pi.zero_apply, sub_zero, SetLike.mem_coe,\n    zero_smul, lie_submodule.mem_coe_submodule, submodule.mem_carrier, lie_subalgebra.mem_mk_iff]\n#align mem_zero_root_subalgebra mem_zero_root_subalgebra\n\n",
 "mem_weight_space":
 "theorem mem_weight_space [lie_algebra.is_nilpotent R L] (χ : L → R) (m : M) :\n    m ∈ weight_space M χ ↔ m ∈ pre_weight_space M χ :=\n  iff.rfl\n#align mem_weight_space mem_weight_space\n\n",
 "mem_pre_weight_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2021 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\ntheorem mem_pre_weight_space (χ : L → R) (m : M) :\n    m ∈ pre_weight_space M χ ↔ ∀ x, ∃ k : ℕ, ((to_endomorphism R L M x - «expr • » (χ x) 1) ^ k) m = 0 := by\n  simp [pre_weight_space, -linear_map.pow_apply]\n#align mem_pre_weight_space mem_pre_weight_space\n\n",
 "lie_mem_weight_space_of_mem_weight_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem lie_mem_weight_space_of_mem_weight_space {χ₁ χ₂ : H → R} {x : L} {m : M} (hx : x ∈ root_space H χ₁)\n    (hm : m ∈ weight_space M χ₂) : «expr⁅ , ⁆» x m ∈ weight_space M (χ₁ + χ₂) :=\n  by\n  apply lie_module.weight_vector_multiplication H L M M ((to_module_hom R L M).restrict_lie H) χ₁ χ₂\n  simp only [lie_module_hom.coe_to_linear_map, Function.comp_apply, linear_map.coe_comp, tensor_product.map_incl,\n    linear_map.mem_range]\n  use «expr ⊗ₜ » ⟨x, hx⟩ ⟨m, hm⟩\n  simp only [submodule.subtype_apply, to_module_hom_apply, submodule.coe_mk, lie_module_hom.coe_restrict_lie,\n    tensor_product.map_tmul]\n#align lie_mem_weight_space_of_mem_weight_space lie_mem_weight_space_of_mem_weight_space\n\n",
 "lie_mem_pre_weight_space_of_mem_pre_weight_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem lie_mem_pre_weight_space_of_mem_pre_weight_space {χ₁ χ₂ : L → R} {x : L} {m : M}\n    (hx : x ∈ pre_weight_space L χ₁) (hm : m ∈ pre_weight_space M χ₂) :\n    «expr⁅ , ⁆» x m ∈ pre_weight_space M (χ₁ + χ₂) :=\n  by\n  apply lie_module.weight_vector_multiplication L L M M (to_module_hom R L M) χ₁ χ₂\n  simp only [lie_module_hom.coe_to_linear_map, Function.comp_apply, linear_map.coe_comp, tensor_product.map_incl,\n    linear_map.mem_range]\n  use «expr ⊗ₜ » ⟨x, hx⟩ ⟨m, hm⟩\n  simp only [submodule.subtype_apply, to_module_hom_apply, tensor_product.map_tmul]\n  rfl\n#align lie_mem_pre_weight_space_of_mem_pre_weight_space lie_mem_pre_weight_space_of_mem_pre_weight_space\n\n",
 "le_zero_root_subalgebra":
 "theorem le_zero_root_subalgebra : H ≤ zero_root_subalgebra R L H :=\n  by\n  rw [← lie_subalgebra.coe_submodule_le_coe_submodule, ← H.coe_to_lie_submodule, coe_zero_root_subalgebra,\n    lie_submodule.coe_submodule_le_coe_submodule]\n  exact to_lie_submodule_le_root_space_zero R L H\n#align le_zero_root_subalgebra le_zero_root_subalgebra\n\n",
 "is_weight_zero_of_nilpotent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- For a non-trivial nilpotent Lie module over a nilpotent Lie algebra, the zero character is a\nweight with respect to the `⊤` Lie subalgebra. -/\ntheorem is_weight_zero_of_nilpotent [nontrivial M] [lie_algebra.is_nilpotent R L] [is_nilpotent R L M] :\n    is_weight («expr⊤» : lie_subalgebra R L) M 0 :=\n  by\n  rw [is_weight, lie_hom.coe_zero, zero_weight_space_eq_top_of_nilpotent]\n  exact top_ne_bot\n#align is_weight_zero_of_nilpotent is_weight_zero_of_nilpotent\n\n",
 "is_nilpotent_to_endomorphism_weight_space_zero":
 "/-- A (nilpotent) Lie algebra acts nilpotently on the zero weight space of a Noetherian Lie\nmodule. -/\ntheorem is_nilpotent_to_endomorphism_weight_space_zero [lie_algebra.is_nilpotent R L] [is_noetherian R M] (x : L) :\n    _root_.is_nilpotent <| to_endomorphism R L (weight_space M (0 : L → R)) x :=\n  by\n  obtain ⟨k, hk⟩ := exists_pre_weight_space_zero_le_ker_of_is_noetherian R M x\n  use k\n  ext ⟨m, hm⟩\n  rw [linear_map.zero_apply, lie_submodule.coe_zero, submodule.coe_eq_zero, ←\n    lie_submodule.to_endomorphism_restrict_eq_to_endomorphism, linear_map.pow_restrict, ← SetLike.coe_eq_coe,\n    linear_map.restrict_apply, submodule.coe_mk, submodule.coe_zero]\n  exact hk hm\n#align is_nilpotent_to_endomorphism_weight_space_zero is_nilpotent_to_endomorphism_weight_space_zero\n\n",
 "is_cartan_of_zero_root_subalgebra_eq":
 "/-- If the zero root subalgebra of a nilpotent Lie subalgebra `H` is just `H` then `H` is a Cartan\nsubalgebra.\n\nWhen `L` is Noetherian, it follows from Engel's theorem that the converse holds. See\n`lie_algebra.zero_root_subalgebra_eq_iff_is_cartan` -/\ntheorem is_cartan_of_zero_root_subalgebra_eq (h : zero_root_subalgebra R L H = H) : H.is_cartan_subalgebra :=\n  { nilpotent := infer_instance\n    self_normalizing := by\n      rw [← h]\n      exact zero_root_subalgebra_normalizer_eq_self R L H }\n#align is_cartan_of_zero_root_subalgebra_eq is_cartan_of_zero_root_subalgebra_eq\n\n",
 "exists_pre_weight_space_zero_le_ker_of_is_noetherian":
 "theorem exists_pre_weight_space_zero_le_ker_of_is_noetherian [is_noetherian R M] (x : L) :\n    ∃ k : ℕ, pre_weight_space M (0 : L → R) ≤ (to_endomorphism R L M x ^ k).ker :=\n  by\n  use (to_endomorphism R L M x).maximal_generalized_eigenspace_index 0\n  simp only [← module.End.generalized_eigenspace_zero, pre_weight_space, pi.zero_apply, infᵢ_le, ←\n    (to_endomorphism R L M x).maximal_generalized_eigenspace_eq]\n#align exists_pre_weight_space_zero_le_ker_of_is_noetherian exists_pre_weight_space_zero_le_ker_of_is_noetherian\n\n",
 "coe_zero_root_subalgebra":
 "@[simp]\ntheorem coe_zero_root_subalgebra : (zero_root_subalgebra R L H : submodule R L) = root_space H 0 :=\n  rfl\n#align coe_zero_root_subalgebra coe_zero_root_subalgebra\n\n",
 "coe_weight_space_of_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem coe_weight_space_of_top [lie_algebra.is_nilpotent R L] (χ : L → R) :\n    (weight_space M (χ ∘ («expr⊤» : lie_subalgebra R L).incl) : submodule R M) = weight_space M χ :=\n  by\n  ext m\n  simp only [weight_space, lie_submodule.coe_to_submodule_mk, lie_subalgebra.coe_bracket_of_module, Function.comp_apply,\n    mem_pre_weight_space]\n  constructor <;> intro h x\n  · obtain ⟨k, hk⟩ := h ⟨x, Set.mem_univ x⟩\n    use k\n    exact hk\n  · obtain ⟨k, hk⟩ := h x\n    use k\n    exact hk\n#align coe_weight_space_of_top coe_weight_space_of_top\n\n",
 "coe_weight_space'":
 "@[simp]\ntheorem coe_weight_space' (χ : H → R) : (weight_space' M χ : submodule R M) = weight_space M χ :=\n  rfl\n#align coe_weight_space' coe_weight_space'\n\n",
 "coe_root_space_weight_space_product_tmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n@[simp]\ntheorem coe_root_space_weight_space_product_tmul (χ₁ χ₂ χ₃ : H → R) (hχ : χ₁ + χ₂ = χ₃) (x : root_space H χ₁)\n    (m : weight_space M χ₂) :\n    (root_space_weight_space_product R L H M χ₁ χ₂ χ₃ hχ («expr ⊗ₜ » x m) : M) = «expr⁅ , ⁆» (x : L) (m : M) := by\n  simp only [root_space_weight_space_product, root_space_weight_space_product_aux, lift_apply,\n    lie_module_hom.coe_to_linear_map, coe_lift_lie_eq_lift_coe, submodule.coe_mk, linear_map.coe_mk,\n    lie_module_hom.coe_mk]\n#align coe_root_space_weight_space_product_tmul coe_root_space_weight_space_product_tmul\n\n"}