{"so_indefinite_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem so_indefinite_equiv_apply {i : R} (hi : i * i = -1) (A : so' p q R) :\n    (so_indefinite_equiv p q R hi A : Matrix (Sum p q) (Sum p q) R) =\n      matrix.mul (matrix.mul (Pso p q R i)⁻¹ (A : Matrix (Sum p q) (Sum p q) R)) (Pso p q R i) :=\n  by erw [LieEquiv.trans_apply, LieEquiv.ofEq_apply, skew_adjoint_matrices_lie_subalgebra_equiv_apply]\n#align so_indefinite_equiv_apply so_indefinite_equiv_apply\n\n",
 "sl_non_abelian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\ntheorem sl_non_abelian [Fintype n] [Nontrivial R] (h : 1 < Fintype.card n) : ¬is_lie_abelian («expr↥ » (sl n R)) :=\n  by\n  rcases Fintype.exists_pair_of_one_lt_card h with ⟨j, i, hij⟩\n  let A := Eb R i j hij\n  let B := Eb R j i hij.symm\n  intro c\n  have c' : matrix.mul A.val B.val = matrix.mul B.val A.val :=\n    by\n    rw [← sub_eq_zero, ← sl_bracket, c.trivial]\n    rfl\n  simpa [std_basis_matrix, Matrix.mul_apply, hij] using congr_fun (congr_fun c' i) i\n#align sl_non_abelian sl_non_abelian\n\n",
 "sl_bracket":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem sl_bracket [Fintype n] (A B : sl n R) :\n    («expr⁅ , ⁆» A B).val = matrix.mul A.val B.val - matrix.mul B.val A.val :=\n  rfl\n#align sl_bracket sl_bracket\n\n",
 "mem_so":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n@[simp]\ntheorem mem_so [Fintype n] (A : Matrix n n R) : A ∈ so n R ↔ matrix.transpose A = -A :=\n  by\n  erw [mem_skew_adjoint_matrices_submodule]\n  simp only [matrix.is_skew_adjoint, matrix.is_adjoint_pair, Matrix.mul_one, Matrix.one_mul]\n#align mem_so mem_so\n\n",
 "matrix_trace_commutator_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/-\nCopyright (c) 2020 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\n@[simp]\ntheorem matrix_trace_commutator_zero [Fintype n] (X Y : Matrix n n R) : Matrix.trace («expr⁅ , ⁆» X Y) = 0 :=\n  calc\n    _ = Matrix.trace (matrix.mul X Y) - Matrix.trace (matrix.mul Y X) := trace_sub _ _\n    _ = Matrix.trace (matrix.mul X Y) - Matrix.trace (matrix.mul X Y) :=\n      (congr_arg (fun x => _ - x) (Matrix.trace_mul_comm Y X))\n    _ = 0 := sub_self _\n    \n#align matrix_trace_commutator_zero matrix_trace_commutator_zero\n\n",
 "indefinite_diagonal_transform":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem indefinite_diagonal_transform {i : R} (hi : i * i = -1) :\n    matrix.mul (matrix.mul (matrix.transpose (Pso p q R i)) (indefinite_diagonal p q R)) (Pso p q R i) = 1 :=\n  by\n  ext (x y); rcases x with ⟨⟩ <;> rcases y with ⟨⟩\n  ·-- x y : p\n      by_cases h : x = y <;>\n      simp [Pso, indefinite_diagonal, h]\n  ·-- x : p, y : q\n    simp [Pso, indefinite_diagonal]\n  ·-- x : q, y : p\n    simp [Pso, indefinite_diagonal]\n  ·-- x y : q\n      by_cases h : x = y <;>\n      simp [Pso, indefinite_diagonal, h, hi]\n#align indefinite_diagonal_transform indefinite_diagonal_transform\n\n",
 "indefinite_diagonal_assoc":
 "theorem indefinite_diagonal_assoc :\n    indefinite_diagonal (Sum Unit l) l R =\n      matrix.reindex_lie_equiv (Equiv.sumAssoc Unit l l).symm (Matrix.fromBlocks 1 0 0 (indefinite_diagonal l l R)) :=\n  by\n  ext (i j)\n  rcases i with ⟨⟨i₁ | i₂⟩ | i₃⟩ <;> rcases j with ⟨⟨j₁ | j₂⟩ | j₃⟩ <;>\n      simp only [indefinite_diagonal, Matrix.diagonal_apply, Equiv.sumAssoc_apply_inl_inl,\n        matrix.reindex_lie_equiv_apply, Matrix.submatrix_apply, Equiv.symm_symm, Matrix.reindex_apply, Sum.elim_inl,\n        if_true, eq_self_iff_true, Matrix.one_apply_eq, Matrix.fromBlocks_apply₁₁, DMatrix.zero_apply,\n        Equiv.sumAssoc_apply_inl_inr, if_false, Matrix.fromBlocks_apply₁₂, Matrix.fromBlocks_apply₂₁,\n        Matrix.fromBlocks_apply₂₂, Equiv.sumAssoc_apply_inr, Sum.elim_inr] <;>\n    congr\n#align indefinite_diagonal_assoc indefinite_diagonal_assoc\n\n",
 "S_as_blocks":
 "theorem S_as_blocks : S l R = Matrix.fromBlocks 1 0 0 (-1) :=\n  by\n  rw [← Matrix.diagonal_one, Matrix.diagonal_neg, Matrix.fromBlocks_diagonal]\n  rfl\n#align S_as_blocks S_as_blocks\n\n",
 "Pso_inv":
 "theorem Pso_inv {i : R} (hi : i * i = -1) : Pso p q R i * Pso p q R (-i) = 1 :=\n  by\n  ext (x y); rcases x with ⟨⟩ <;> rcases y with ⟨⟩\n  ·-- x y : p\n      by_cases h : x = y <;>\n      simp [Pso, indefinite_diagonal, h]\n  ·-- x : p, y : q\n    simp [Pso, indefinite_diagonal]\n  ·-- x : q, y : p\n    simp [Pso, indefinite_diagonal]\n  ·-- x y : q\n      by_cases h : x = y <;>\n      simp [Pso, indefinite_diagonal, h, hi]\n#align Pso_inv Pso_inv\n\n",
 "PD_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem PD_inv [Fintype l] [Invertible (2 : R)] :\n    PD l R * «expr • » ((«expr⅟») (2 : R)) (matrix.transpose (PD l R)) = 1 :=\n  by\n  have h : «expr • » ((«expr⅟») (2 : R)) (1 : Matrix l l R) + «expr • » ((«expr⅟») (2 : R)) 1 = 1 := by\n    rw [← smul_add, ← two_smul R _, smul_smul, invOf_mul_self, one_smul]\n  erw [Matrix.fromBlocks_transpose, Matrix.fromBlocks_smul, Matrix.mul_eq_mul, Matrix.fromBlocks_multiply]\n  simp [h]\n#align PD_inv PD_inv\n\n",
 "PB_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\ntheorem PB_inv [Invertible (2 : R)] : PB l R * Matrix.fromBlocks 1 0 0 ((«expr⅟») (PD l R)) = 1 :=\n  by\n  rw [PB, Matrix.mul_eq_mul, Matrix.fromBlocks_multiply, Matrix.mul_invOf_self]\n  simp only [Matrix.mul_zero, Matrix.mul_one, Matrix.zero_mul, zero_add, add_zero, Matrix.fromBlocks_one]\n#align PB_inv PB_inv\n\n",
 "JD_transform":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem JD_transform [Fintype l] :\n    matrix.mul (matrix.mul (matrix.transpose (PD l R)) (JD l R)) (PD l R) = «expr • » (2 : R) (S l R) :=\n  by\n  have h : matrix.mul (matrix.transpose (PD l R)) (JD l R) = Matrix.fromBlocks 1 1 1 (-1) := by\n    simp [PD, JD, Matrix.fromBlocks_transpose, Matrix.fromBlocks_multiply]\n  erw [h, S_as_blocks, Matrix.fromBlocks_multiply, Matrix.fromBlocks_smul]\n  congr <;> simp [two_smul]\n#align JD_transform JD_transform\n\n",
 "JB_transform":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem JB_transform :\n    matrix.mul (matrix.mul (matrix.transpose (PB l R)) (JB l R)) (PB l R) =\n      «expr • » (2 : R) (Matrix.fromBlocks 1 0 0 (S l R)) :=\n  by simp [PB, JB, JD_transform, Matrix.fromBlocks_transpose, Matrix.fromBlocks_multiply, Matrix.fromBlocks_smul]\n#align JB_transform JB_transform\n\n",
 "Eb_val":
 "@[simp]\ntheorem Eb_val (h : j ≠ i) : (Eb R i j h).val = Matrix.stdBasisMatrix i j 1 :=\n  rfl\n#align Eb_val Eb_val\n\n"}