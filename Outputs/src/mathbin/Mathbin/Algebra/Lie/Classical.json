{"so_indefinite_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem so_indefinite_equiv_apply {i : R} (hi : i * i = -1) (A : so' p q R) :\n    (so_indefinite_equiv p q R hi A : matrix (Sum p q) (Sum p q) R) =\n      matrix.mul (matrix.mul (Pso p q R i)⁻¹ (A : matrix (Sum p q) (Sum p q) R)) (Pso p q R i) :=\n  by erw [lie_equiv.trans_apply, lie_equiv.of_eq_apply, skew_adjoint_matrices_lie_subalgebra_equiv_apply]\n#align so_indefinite_equiv_apply so_indefinite_equiv_apply\n\n",
 "sl_non_abelian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\ntheorem sl_non_abelian [fintype n] [nontrivial R] (h : 1 < fintype.card n) : ¬is_lie_abelian («expr↥ » (sl n R)) :=\n  by\n  rcases fintype.exists_pair_of_one_lt_card h with ⟨j, i, hij⟩\n  let A := Eb R i j hij\n  let B := Eb R j i hij.symm\n  intro c\n  have c' : matrix.mul A.val B.val = matrix.mul B.val A.val :=\n    by\n    rw [← sub_eq_zero, ← sl_bracket, c.trivial]\n    rfl\n  simpa [std_basis_matrix, matrix.mul_apply, hij] using congr_fun (congr_fun c' i) i\n#align sl_non_abelian sl_non_abelian\n\n",
 "sl_bracket":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem sl_bracket [fintype n] (A B : sl n R) :\n    («expr⁅ , ⁆» A B).val = matrix.mul A.val B.val - matrix.mul B.val A.val :=\n  rfl\n#align sl_bracket sl_bracket\n\n",
 "mem_so":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n@[simp]\ntheorem mem_so [fintype n] (A : matrix n n R) : A ∈ so n R ↔ matrix.transpose A = -A :=\n  by\n  erw [mem_skew_adjoint_matrices_submodule]\n  simp only [matrix.is_skew_adjoint, matrix.is_adjoint_pair, matrix.mul_one, matrix.one_mul]\n#align mem_so mem_so\n\n",
 "matrix_trace_commutator_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/-\nCopyright (c) 2020 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\n@[simp]\ntheorem matrix_trace_commutator_zero [fintype n] (X Y : matrix n n R) : matrix.trace («expr⁅ , ⁆» X Y) = 0 :=\n  calc\n    _ = matrix.trace (matrix.mul X Y) - matrix.trace (matrix.mul Y X) := trace_sub _ _\n    _ = matrix.trace (matrix.mul X Y) - matrix.trace (matrix.mul X Y) :=\n      congr_arg (fun x => _ - x) (matrix.trace_mul_comm Y X)\n    _ = 0 := sub_self _\n    \n#align matrix_trace_commutator_zero matrix_trace_commutator_zero\n\n",
 "indefinite_diagonal_transform":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem indefinite_diagonal_transform {i : R} (hi : i * i = -1) :\n    matrix.mul (matrix.mul (matrix.transpose (Pso p q R i)) (indefinite_diagonal p q R)) (Pso p q R i) = 1 :=\n  by\n  ext (x y); rcases x with ⟨⟩ <;> rcases y with ⟨⟩\n  ·-- x y : p\n      by_cases h : x = y <;>\n      simp [Pso, indefinite_diagonal, h]\n  ·-- x : p, y : q\n    simp [Pso, indefinite_diagonal]\n  ·-- x : q, y : p\n    simp [Pso, indefinite_diagonal]\n  ·-- x y : q\n      by_cases h : x = y <;>\n      simp [Pso, indefinite_diagonal, h, hi]\n#align indefinite_diagonal_transform indefinite_diagonal_transform\n\n",
 "indefinite_diagonal_assoc":
 "theorem indefinite_diagonal_assoc :\n    indefinite_diagonal (Sum unit l) l R =\n      matrix.reindex_lie_equiv (Equiv.sumAssoc unit l l).symm (matrix.from_blocks 1 0 0 (indefinite_diagonal l l R)) :=\n  by\n  ext (i j)\n  rcases i with ⟨⟨i₁ | i₂⟩ | i₃⟩ <;> rcases j with ⟨⟨j₁ | j₂⟩ | j₃⟩ <;>\n      simp only [indefinite_diagonal, matrix.diagonal, Equiv.sumAssoc_apply_inl_inl, matrix.reindex_lie_equiv_apply,\n        matrix.submatrix_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true,\n        matrix.one_apply_eq, matrix.from_blocks_apply₁₁, dmatrix.zero_apply, Equiv.sumAssoc_apply_inl_inr, if_false,\n        matrix.from_blocks_apply₁₂, matrix.from_blocks_apply₂₁, matrix.from_blocks_apply₂₂, Equiv.sumAssoc_apply_inr,\n        sum.elim_inr] <;>\n    congr\n#align indefinite_diagonal_assoc indefinite_diagonal_assoc\n\n",
 "S_as_blocks":
 "theorem S_as_blocks : S l R = matrix.from_blocks 1 0 0 (-1) :=\n  by\n  rw [← matrix.diagonal_one, matrix.diagonal_neg, matrix.from_blocks_diagonal]\n  rfl\n#align S_as_blocks S_as_blocks\n\n",
 "Pso_inv":
 "theorem Pso_inv {i : R} (hi : i * i = -1) : Pso p q R i * Pso p q R (-i) = 1 :=\n  by\n  ext (x y); rcases x with ⟨⟩ <;> rcases y with ⟨⟩\n  ·-- x y : p\n      by_cases h : x = y <;>\n      simp [Pso, indefinite_diagonal, h]\n  ·-- x : p, y : q\n    simp [Pso, indefinite_diagonal]\n  ·-- x : q, y : p\n    simp [Pso, indefinite_diagonal]\n  ·-- x y : q\n      by_cases h : x = y <;>\n      simp [Pso, indefinite_diagonal, h, hi]\n#align Pso_inv Pso_inv\n\n",
 "PD_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem PD_inv [fintype l] [Invertible (2 : R)] :\n    PD l R * «expr • » ((«expr⅟») (2 : R)) (matrix.transpose (PD l R)) = 1 :=\n  by\n  have h : «expr • » ((«expr⅟») (2 : R)) (1 : matrix l l R) + «expr • » ((«expr⅟») (2 : R)) 1 = 1 := by\n    rw [← smul_add, ← two_smul R _, smul_smul, invOf_mul_self, one_smul]\n  erw [matrix.from_blocks_transpose, matrix.from_blocks_smul, matrix.mul_eq_mul, matrix.from_blocks_multiply]\n  simp [h]\n#align PD_inv PD_inv\n\n",
 "PB_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\ntheorem PB_inv [Invertible (2 : R)] : PB l R * matrix.from_blocks 1 0 0 ((«expr⅟») (PD l R)) = 1 :=\n  by\n  rw [PB, matrix.mul_eq_mul, matrix.from_blocks_multiply, matrix.mul_inv_of_self]\n  simp only [matrix.mul_zero, matrix.mul_one, matrix.zero_mul, zero_add, add_zero, matrix.from_blocks_one]\n#align PB_inv PB_inv\n\n",
 "JD_transform":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem JD_transform [fintype l] :\n    matrix.mul (matrix.mul (matrix.transpose (PD l R)) (JD l R)) (PD l R) = «expr • » (2 : R) (S l R) :=\n  by\n  have h : matrix.mul (matrix.transpose (PD l R)) (JD l R) = matrix.from_blocks 1 1 1 (-1) := by\n    simp [PD, JD, matrix.from_blocks_transpose, matrix.from_blocks_multiply]\n  erw [h, S_as_blocks, matrix.from_blocks_multiply, matrix.from_blocks_smul]\n  congr <;> simp [two_smul]\n#align JD_transform JD_transform\n\n",
 "JB_transform":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem JB_transform :\n    matrix.mul (matrix.mul (matrix.transpose (PB l R)) (JB l R)) (PB l R) =\n      «expr • » (2 : R) (matrix.from_blocks 1 0 0 (S l R)) :=\n  by simp [PB, JB, JD_transform, matrix.from_blocks_transpose, matrix.from_blocks_multiply, matrix.from_blocks_smul]\n#align JB_transform JB_transform\n\n",
 "Eb_val":
 "@[simp]\ntheorem Eb_val (h : j ≠ i) : (Eb R i j h).val = matrix.std_basis_matrix i j 1 :=\n  rfl\n#align Eb_val Eb_val\n\n"}