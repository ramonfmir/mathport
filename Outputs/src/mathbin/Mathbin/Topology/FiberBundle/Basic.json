{"total_space_mk_preimage_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem total_space_mk_preimage_source (b : B) :\n    «expr ⁻¹' » (totalSpaceMk b) (a.pretrivialization_at b).source = univ :=\n  by\n  apply eq_univ_of_univ_subset\n  rw [(a.pretrivialization_at b).source_eq, ← preimage_comp, function.comp]\n  simp only [total_space.proj]\n  rw [preimage_const_of_mem _]\n  exact a.mem_base_pretrivialization_at b\n#align total_space_mk_preimage_source total_space_mk_preimage_source\n\n",
 "surjective_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/-- The projection from a fiber bundle with a nonempty fiber to its base is a surjective\nmap. -/\ntheorem surjective_proj [nonempty F] : function.surjective ((exprπ) E) := fun b =>\n  let ⟨p, _, hpb⟩ := (trivialization_at F E b).proj_surj_on_base_set (mem_base_set_trivialization_at F E b)\n  ⟨p, hpb⟩\n#align surjective_proj surjective_proj\n\n",
 "quotient_map_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/-- The projection from a fiber bundle with a nonempty fiber to its base is a quotient\nmap. -/\ntheorem quotient_map_proj [nonempty F] : quotient_map ((exprπ) E) :=\n  (is_open_map_proj F E).to_quotient_map (continuous_proj F E) (surjective_proj F E)\n#align quotient_map_proj quotient_map_proj\n\n",
 "open_source'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem open_source' (i : ι) : is_open (Z.local_triv_as_local_equiv i).source :=\n  by\n  apply topological_space.generate_open.basic\n  simp only [exists_prop, mem_Union, mem_singleton_iff]\n  refine' ⟨i, lower_set.prod (Z.base_set i) univ, (Z.is_open_base_set i).prod is_open_univ, _⟩\n  ext p\n  simp only [local_triv_as_local_equiv_apply, prod_mk_mem_set_prod_eq, mem_inter_iff, and_self_iff,\n    mem_local_triv_as_local_equiv_source, and_true_iff, mem_univ, mem_preimage]\n#align open_source' open_source'\n\n",
 "mem_trivialization_at_source":
 "theorem mem_trivialization_at_source (b : B) (x : E b) : totalSpaceMk b x ∈ (a.pretrivialization_at b).source :=\n  by\n  simp only [(a.pretrivialization_at b).source_eq, mem_preimage, total_space.proj]\n  exact a.mem_base_pretrivialization_at b\n#align mem_trivialization_at_source mem_trivialization_at_source\n\n",
 "mem_triv_change_source":
 "@[simp, mfld_simps]\ntheorem mem_triv_change_source (i j : ι) (p : B × F) :\n    p ∈ (Z.triv_change i j).source ↔ p.1 ∈ Z.base_set i ∩ Z.base_set j :=\n  by\n  erw [mem_prod]\n  simp\n#align mem_triv_change_source mem_triv_change_source\n\n",
 "mem_source_at":
 "@[simp, mfld_simps]\ntheorem mem_source_at : (⟨b, a⟩ : Z.total_space) ∈ (Z.local_triv_at b).source :=\n  by\n  rw [local_triv_at, mem_local_triv_source]\n  exact Z.mem_base_set_at b\n#align mem_source_at mem_source_at\n\n",
 "mem_local_triv_target":
 "@[simp, mfld_simps]\ntheorem mem_local_triv_target (p : B × F) : p ∈ (Z.local_triv i).target ↔ p.1 ∈ (Z.local_triv i).base_set :=\n  trivialization.mem_target _\n#align mem_local_triv_target mem_local_triv_target\n\n",
 "mem_local_triv_source":
 "@[simp, mfld_simps]\ntheorem mem_local_triv_source (p : Z.total_space) : p ∈ (Z.local_triv i).source ↔ p.1 ∈ (Z.local_triv i).base_set :=\n  iff.rfl\n#align mem_local_triv_source mem_local_triv_source\n\n",
 "mem_local_triv_at_target":
 "@[simp, mfld_simps]\ntheorem mem_local_triv_at_target (p : B × F) (b : B) :\n    p ∈ (Z.local_triv_at b).target ↔ p.1 ∈ (Z.local_triv_at b).base_set :=\n  trivialization.mem_target _\n#align mem_local_triv_at_target mem_local_triv_at_target\n\n",
 "mem_local_triv_at_source":
 "@[simp, mfld_simps]\ntheorem mem_local_triv_at_source (p : Z.total_space) (b : B) :\n    p ∈ (Z.local_triv_at b).source ↔ p.1 ∈ (Z.local_triv_at b).base_set :=\n  iff.rfl\n#align mem_local_triv_at_source mem_local_triv_at_source\n\n",
 "mem_local_triv_at_base_set":
 "@[simp, mfld_simps]\ntheorem mem_local_triv_at_base_set (b : B) : b ∈ (Z.local_triv_at b).base_set :=\n  by\n  rw [local_triv_at, ← base_set_at]\n  exact Z.mem_base_set_at b\n#align mem_local_triv_at_base_set mem_local_triv_at_base_set\n\n",
 "mem_local_triv_as_local_equiv_target":
 "theorem mem_local_triv_as_local_equiv_target (p : B × F) :\n    p ∈ (Z.local_triv_as_local_equiv i).target ↔ p.1 ∈ Z.base_set i :=\n  by\n  erw [mem_prod]\n  simp only [and_true_iff, mem_univ]\n#align mem_local_triv_as_local_equiv_target mem_local_triv_as_local_equiv_target\n\n",
 "mem_local_triv_as_local_equiv_source":
 "theorem mem_local_triv_as_local_equiv_source (p : Z.total_space) :\n    p ∈ (Z.local_triv_as_local_equiv i).source ↔ p.1 ∈ Z.base_set i :=\n  iff.rfl\n#align mem_local_triv_as_local_equiv_source mem_local_triv_as_local_equiv_source\n\n",
 "map_proj_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-\nCopyright (c) 2019 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel, Floris van Doorn, Heather Macbeth\n-/\ntheorem map_proj_nhds (x : TotalSpace E) : map ((exprπ) E) ((nhds) x) = (nhds) x.proj :=\n  (trivialization_at F E x.proj).map_proj_nhds <|\n    (trivialization_at F E x.proj).mem_source.2 <| mem_base_set_trivialization_at F E x.proj\n#align map_proj_nhds map_proj_nhds\n\n",
 "local_triv_symm_apply":
 "@[simp, mfld_simps]\ntheorem local_triv_symm_apply (p : B × F) :\n    (Z.local_triv i).to_local_homeomorph.symm p = ⟨p.1, Z.coord_change i (Z.index_at p.1) p.1 p.2⟩ :=\n  rfl\n#align local_triv_symm_apply local_triv_symm_apply\n\n",
 "local_triv_at_def":
 "@[simp, mfld_simps]\ntheorem local_triv_at_def (b : B) : Z.local_triv (Z.index_at b) = Z.local_triv_at b :=\n  rfl\n#align local_triv_at_def local_triv_at_def\n\n",
 "local_triv_at_apply_mk":
 "@[simp, mfld_simps]\ntheorem local_triv_at_apply_mk (b : B) (a : F) : (Z.local_triv_at b) ⟨b, a⟩ = ⟨b, a⟩ :=\n  Z.local_triv_at_apply _\n#align local_triv_at_apply_mk local_triv_at_apply_mk\n\n",
 "local_triv_at_apply":
 "@[simp, mfld_simps]\ntheorem local_triv_at_apply (p : Z.total_space) : (Z.local_triv_at p.1) p = ⟨p.1, p.2⟩ :=\n  by\n  rw [local_triv_at, local_triv_apply, coord_change_self]\n  exact Z.mem_base_set_at p.1\n#align local_triv_at_apply local_triv_at_apply\n\n",
 "local_triv_as_local_equiv_trans":
 "/-- The composition of two local trivializations is the trivialization change Z.triv_change i j. -/\ntheorem local_triv_as_local_equiv_trans (i j : ι) :\n    (Z.local_triv_as_local_equiv i).symm.trans (Z.local_triv_as_local_equiv j) ≈ (Z.triv_change i j).to_local_equiv :=\n  by\n  constructor\n  · ext x\n    simp only [mem_local_triv_as_local_equiv_target, mfld_simps]\n    rfl\n  · rintro ⟨x, v⟩ hx\n    simp only [triv_change, local_triv_as_local_equiv, LocalEquiv.symm, true_and_iff, prod.mk.inj_iff,\n      prod_mk_mem_set_prod_eq, LocalEquiv.trans_source, mem_inter_iff, and_true_iff, mem_preimage, proj, mem_univ,\n      [anonymous], eq_self_iff_true, LocalEquiv.coe_trans, total_space.proj] at hx⊢\n    simp only [Z.coord_change_comp, hx, mem_inter_iff, and_self_iff, mem_base_set_at]\n#align local_triv_as_local_equiv_trans local_triv_as_local_equiv_trans\n\n",
 "local_triv_as_local_equiv_target":
 "@[simp, mfld_simps]\ntheorem local_triv_as_local_equiv_target : (Z.local_triv_as_local_equiv i).target = (Z.local_triv i).target :=\n  rfl\n#align local_triv_as_local_equiv_target local_triv_as_local_equiv_target\n\n",
 "local_triv_as_local_equiv_symm":
 "@[simp, mfld_simps]\ntheorem local_triv_as_local_equiv_symm : (Z.local_triv_as_local_equiv i).symm = (Z.local_triv i).to_local_equiv.symm :=\n  rfl\n#align local_triv_as_local_equiv_symm local_triv_as_local_equiv_symm\n\n",
 "local_triv_as_local_equiv_source":
 "@[simp, mfld_simps]\ntheorem local_triv_as_local_equiv_source : (Z.local_triv_as_local_equiv i).source = (Z.local_triv i).source :=\n  rfl\n#align local_triv_as_local_equiv_source local_triv_as_local_equiv_source\n\n",
 "local_triv_as_local_equiv_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, mfld_simps]\ntheorem local_triv_as_local_equiv_coe : «expr⇑ » (Z.local_triv_as_local_equiv i) = Z.local_triv i :=\n  rfl\n#align local_triv_as_local_equiv_coe local_triv_as_local_equiv_coe\n\n",
 "local_triv_as_local_equiv_apply":
 "theorem local_triv_as_local_equiv_apply (p : Z.total_space) :\n    (Z.local_triv_as_local_equiv i) p = ⟨p.1, Z.coord_change (Z.index_at p.1) i p.1 p.2⟩ :=\n  rfl\n#align local_triv_as_local_equiv_apply local_triv_as_local_equiv_apply\n\n",
 "local_triv_apply":
 "@[simp, mfld_simps]\ntheorem local_triv_apply (p : Z.total_space) : (Z.local_triv i) p = ⟨p.1, Z.coord_change (Z.index_at p.1) i p.1 p.2⟩ :=\n  rfl\n#align local_triv_apply local_triv_apply\n\n",
 "is_open_target_of_mem_pretrivialization_atlas_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_open_target_of_mem_pretrivialization_atlas_inter (e e' : pretrivialization F ((exprπ) E))\n    (he' : e' ∈ a.pretrivialization_atlas) :\n    is_open (e'.to_local_equiv.target ∩ «expr ⁻¹' » e'.to_local_equiv.symm e.source) :=\n  by\n  letI := a.total_space_topology\n  obtain ⟨u, hu1, hu2⟩ :=\n    continuous_on_iff'.mp (a.continuous_symm_of_mem_pretrivialization_atlas he') e.source (a.is_open_source e)\n  rw [inter_comm, hu2]\n  exact hu1.inter e'.open_target\n#align is_open_target_of_mem_pretrivialization_atlas_inter is_open_target_of_mem_pretrivialization_atlas_inter\n\n",
 "is_open_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem is_open_source (e : pretrivialization F ((exprπ) E)) : @is_open _ a.total_space_topology e.source :=\n  by\n  letI := a.total_space_topology\n  refine' is_open_supr_iff.mpr fun e' => _\n  refine' is_open_supr_iff.mpr fun he' => _\n  refine' is_open_coinduced.mpr (is_open_induced_iff.mpr ⟨e.target, e.open_target, _⟩)\n  rw [pretrivialization.set_symm, restrict, e.target_eq, e.source_eq, preimage_comp,\n    Subtype.preimage_coe_eq_preimage_coe_iff, e'.target_eq, prod_inter_prod, inter_univ,\n    pretrivialization.preimage_symm_proj_inter]\n#align is_open_source is_open_source\n\n",
 "is_open_map_proj":
 "/-- The projection on the base of a fiber bundle created from core is an open map -/\ntheorem is_open_map_proj : is_open_map Z.proj :=\n  is_open_map_proj F Z.fiber\n#align is_open_map_proj is_open_map_proj\n\n",
 "inducing_total_space_mk":
 "@[continuity]\ntheorem inducing_total_space_mk (b : B) : @inducing _ _ (a.fiber_topology b) a.total_space_topology (totalSpaceMk b) :=\n  by\n  letI := a.total_space_topology\n  letI := a.fiber_topology b\n  exact ⟨rfl⟩\n#align inducing_total_space_mk inducing_total_space_mk\n\n",
 "exists_trivialization_Icc_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/-- If `E` is a fiber bundle over a conditionally complete linear order,\nthen it is trivial over any closed interval. -/\ntheorem fiber_bundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B] [order_topology B]\n    [fiber_bundle F E] (a b : B) : ∃ e : trivialization F ((exprπ) E), Icc a b ⊆ e.base_set := by\n  classical\n    obtain ⟨ea, hea⟩ : ∃ ea : trivialization F ((exprπ) E), a ∈ ea.base_set :=\n      ⟨trivialization_at F E a, mem_base_set_trivialization_at F E a⟩\n    -- If `a < b`, then `[a, b] = ∅`, and the statement is trivial\n      cases' le_or_lt a b with hab hab <;>\n      [skip, exact ⟨ea, by simp [*]⟩]\n    /- Let `s` be the set of points `x ∈ [a, b]` such that `E` is trivializable over `[a, x]`.\n      We need to show that `b ∈ s`. Let `c = Sup s`. We will show that `c ∈ s` and `c = b`. -/\n    set s : set B := { x ∈ Icc a b | ∃ e : trivialization F ((exprπ) E), Icc a x ⊆ e.base_set }\n    have ha : a ∈ s := ⟨left_mem_Icc.2 hab, ea, by simp [hea]⟩\n    have sne : s.nonempty := ⟨a, ha⟩\n    have hsb : b ∈ upperBounds s := fun x hx => hx.1.2\n    have sbd : BddAbove s := ⟨b, hsb⟩\n    set c := Sup s\n    have hsc : IsLUB s c := isLUB_csupₛ sne sbd\n    have hc : c ∈ Icc a b := ⟨hsc.1 ha, hsc.2 hsb⟩\n    obtain ⟨-, ec : trivialization F ((exprπ) E), hec : Icc a c ⊆ ec.base_set⟩ : c ∈ s :=\n      by\n      cases' hc.1.eq_or_lt with heq hlt\n      · rwa [← HEq]\n      refine' ⟨hc, _⟩\n      /- In order to show that `c ∈ s`, consider a trivialization `ec` of `proj` over a neighborhood\n          of `c`. Its base set includes `(c', c]` for some `c' ∈ [a, c)`. -/\n      obtain ⟨ec, hc⟩ : ∃ ec : trivialization F ((exprπ) E), c ∈ ec.base_set :=\n        ⟨trivialization_at F E c, mem_base_set_trivialization_at F E c⟩\n      obtain ⟨c', hc', hc'e⟩ : ∃ c' ∈ Ico a c, Ioc c' c ⊆ ec.base_set :=\n        (mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1\n          (mem_nhds_within_of_mem_nhds <| is_open.mem_nhds ec.open_base_set hc)\n      /- Since `c' < c = Sup s`, there exists `d ∈ s ∩ (c', c]`. Let `ead` be a trivialization of\n          `proj` over `[a, d]`. Then we can glue `ead` and `ec` into a trivialization over `[a, c]`. -/\n      obtain ⟨d, ⟨hdab, ead, had⟩, hd⟩ : ∃ d ∈ s, d ∈ Ioc c' c := hsc.exists_between hc'.2\n      refine' ⟨ead.piecewise_le ec d (had ⟨hdab.1, le_rfl⟩) (hc'e hd), subset_ite.2 _⟩\n      refine' ⟨fun x hx => had ⟨hx.1.1, hx.2⟩, fun x hx => hc'e ⟨hd.1.trans (not_le.1 hx.2), hx.1.2⟩⟩\n    /- So, `c ∈ s`. Let `ec` be a trivialization of `proj` over `[a, c]`.  If `c = b`, then we are\n      done. Otherwise we show that `proj` can be trivialized over a larger interval `[a, d]`,\n      `d ∈ (c, b]`, hence `c` is not an upper bound of `s`. -/\n    cases' hc.2.eq_or_lt with heq hlt\n    · exact ⟨ec, HEq ▸ hec⟩\n    rsuffices ⟨d, hdcb, hd⟩ : ∃ d ∈ Ioc c b, ∃ e : trivialization F ((exprπ) E), Icc a d ⊆ e.base_set\n    · exact ((hsc.1 ⟨⟨hc.1.trans hdcb.1.le, hdcb.2⟩, hd⟩).not_lt hdcb.1).elim\n    /- Since the base set of `ec` is open, it includes `[c, d)` (hence, `[a, d)`) for some\n      `d ∈ (c, b]`. -/\n    obtain ⟨d, hdcb, hd⟩ : ∃ d ∈ Ioc c b, Ico c d ⊆ ec.base_set :=\n      (mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1\n        (mem_nhds_within_of_mem_nhds <| is_open.mem_nhds ec.open_base_set (hec ⟨hc.1, le_rfl⟩))\n    have had : Ico a d ⊆ ec.base_set := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)\n    by_cases he : Disjoint (Iio d) (Ioi c)\n    · /- If `(c, d) = ∅`, then let `ed` be a trivialization of `proj` over a neighborhood of `d`.\n          Then the disjoint union of `ec` restricted to `(-∞, d)` and `ed` restricted to `(c, ∞)` is\n          a trivialization over `[a, d]`. -/\n      obtain ⟨ed, hed⟩ : ∃ ed : trivialization F ((exprπ) E), d ∈ ed.base_set :=\n        ⟨trivialization_at F E d, mem_base_set_trivialization_at F E d⟩\n      refine'\n        ⟨d, hdcb,\n          (ec.restr_open (Iio d) is_open_Iio).disjoint_union (ed.restr_open (Ioi c) is_open_Ioi)\n            (he.mono (inter_subset_right _ _) (inter_subset_right _ _)),\n          fun x hx => _⟩\n      rcases hx.2.eq_or_lt with (rfl | hxd)\n      exacts[or.inr ⟨hed, hdcb.1⟩, or.inl ⟨had ⟨hx.1, hxd⟩, hxd⟩]\n    · /- If `(c, d)` is nonempty, then take `d' ∈ (c, d)`. Since the base set of `ec` includes\n          `[a, d)`, it includes `[a, d'] ⊆ [a, d)` as well. -/\n      rw [disjoint_left] at he\n      push_neg  at he\n      rcases he with ⟨d', hdd' : d' < d, hd'c⟩\n      exact ⟨d', ⟨hd'c, hdd'.le.trans hdcb.2⟩, ec, (Icc_subset_Ico_right hdd').trans had⟩\n#align fiber_bundle.exists_trivialization_Icc_subset fiber_bundle.exists_trivialization_Icc_subset\n\n",
 "continuous_total_space_mk":
 "@[continuity]\ntheorem continuous_total_space_mk (b : B) :\n    @continuous _ _ (a.fiber_topology b) a.total_space_topology (totalSpaceMk b) :=\n  by\n  letI := a.total_space_topology; letI := a.fiber_topology b\n  exact (a.inducing_total_space_mk b).continuous\n#align continuous_total_space_mk continuous_total_space_mk\n\n",
 "continuous_symm_of_mem_pretrivialization_atlas":
 "theorem continuous_symm_of_mem_pretrivialization_atlas (he : e ∈ a.pretrivialization_atlas) :\n    @continuous_on _ _ _ a.total_space_topology e.to_local_equiv.symm e.target :=\n  by\n  refine' id fun z H => id fun U h => preimage_nhds_within_coinduced' H e.open_target (le_def.1 (nhds_mono _) U h)\n  exact le_supᵢ₂ e he\n#align continuous_symm_of_mem_pretrivialization_atlas continuous_symm_of_mem_pretrivialization_atlas\n\n",
 "continuous_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem continuous_proj : @continuous _ _ a.total_space_topology _ ((exprπ) E) :=\n  by\n  letI := a.total_space_topology\n  letI := a.fiber_topology\n  letI := a.to_fiber_bundle\n  exact continuous_proj F E\n#align continuous_proj continuous_proj\n\n",
 "continuous_on_of_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\n/-- For a fiber bundle `E` over `B` constructed using the `fiber_prebundle` mechanism,\ncontinuity of a function `total_space E → X` on an open set `s` can be checked by precomposing at\neach point with the pretrivialization used for the construction at that point. -/\ntheorem continuous_on_of_comp_right {X : Type _} [topological_space X] {f : TotalSpace E → X} {s : set B}\n    (hs : is_open s)\n    (hf :\n      ∀ b ∈ s,\n        continuous_on (f ∘ (a.pretrivialization_at b).to_local_equiv.symm)\n          (lower_set.prod (s ∩ (a.pretrivialization_at b).base_set) (Set.univ : set F))) :\n    @continuous_on _ _ a.total_space_topology _ f («expr ⁻¹' » ((exprπ) E) s) :=\n  by\n  letI := a.total_space_topology\n  intro z hz\n  let e : trivialization F ((exprπ) E) :=\n    a.trivialization_of_mem_pretrivialization_atlas (a.pretrivialization_mem_atlas z.proj)\n  refine' (e.continuous_at_of_comp_right _ ((hf z.proj hz).continuous_at (is_open.mem_nhds _ _))).continuous_within_at\n  · exact a.mem_base_pretrivialization_at z.proj\n  · exact (hs.inter (a.pretrivialization_at z.proj).open_base_set).prod is_open_univ\n  refine' ⟨_, mem_univ _⟩\n  rw [e.coe_fst]\n  · exact ⟨hz, a.mem_base_pretrivialization_at z.proj⟩\n  · rw [e.mem_source]\n    exact a.mem_base_pretrivialization_at z.proj\n#align continuous_on_of_comp_right continuous_on_of_comp_right\n\n",
 "continuous_const_section":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If an element of `F` is invariant under all coordinate changes, then one can define a\ncorresponding section of the fiber bundle, which is continuous. This applies in particular to the\nzero section of a vector bundle. Another example (not yet defined) would be the identity\nsection of the endomorphism bundle of a vector bundle. -/\ntheorem continuous_const_section (v : F) (h : ∀ i j, ∀ x ∈ Z.base_set i ∩ Z.base_set j, Z.coord_change i j x v = v) :\n    continuous (show B → Z.total_space from fun x => ⟨x, v⟩) :=\n  by\n  apply continuous_iff_continuous_at.2 fun x => _\n  have A : Z.base_set (Z.index_at x) ∈ (nhds) x :=\n    is_open.mem_nhds (Z.is_open_base_set (Z.index_at x)) (Z.mem_base_set_at x)\n  apply ((Z.local_triv_at x).to_local_homeomorph.continuous_at_iff_continuous_at_comp_left _).2\n  · simp only [(· ∘ ·), mfld_simps]\n    apply continuous_at_id.prod\n    have : continuous_on (fun y : B => v) (Z.base_set (Z.index_at x)) := continuous_on_const\n    apply (this.congr _).continuous_at A\n    intro y hy\n    simp only [h, hy, mem_base_set_at, mfld_simps]\n  · exact A\n#align continuous_const_section continuous_const_section\n\n",
 "base_set_at":
 "@[simp, mfld_simps]\ntheorem base_set_at : Z.base_set i = (Z.local_triv i).base_set :=\n  rfl\n#align base_set_at base_set_at\n\n"}