{"trivialization_target":
 "@[simp]\ntheorem trivialization_target : (trivialization B F).target = univ :=\n  rfl\n#align trivialization_target trivialization_target\n\n",
 "trivialization_source":
 "/-\nCopyright © 2022 Nicolò Cavalleri. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Nicolò Cavalleri, Sébastien Gouëzel, Heather Macbeth, Floris van Doorn\n-/\n@[simp]\ntheorem trivialization_source : (trivialization B F).source = univ :=\n  rfl\n#align trivialization_source trivialization_source\n\n",
 "right_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem prod.right_inv {x : B × F₁ × F₂} (h : x ∈ lower_set.prod (e₁.base_set ∩ e₂.base_set) (univ : set (F₁ × F₂))) :\n    prod.to_fun' e₁ e₂ (prod.inv_fun' e₁ e₂ x) = x :=\n  by\n  obtain ⟨x, w₁, w₂⟩ := x\n  obtain ⟨⟨h₁ : x ∈ e₁.base_set, h₂ : x ∈ e₂.base_set⟩, -⟩ := h\n  simp only [prod.to_fun', prod.inv_fun', apply_mk_symm, h₁, h₂]\n#align prod.right_inv prod.right_inv\n\n",
 "prod_symm_apply":
 "theorem prod_symm_apply (x : B) (w₁ : F₁) (w₂ : F₂) :\n    (prod e₁ e₂).to_local_equiv.symm (x, w₁, w₂) = ⟨x, e₁.symm x w₁, e₂.symm x w₂⟩ :=\n  rfl\n#align prod_symm_apply prod_symm_apply\n\n",
 "left_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ᵇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ᵇ » -/\ntheorem prod.left_inv {x : TotalSpace («expr ×ᵇ » E₁ E₂)}\n    (h : x ∈ «expr ⁻¹' » (@TotalSpace.proj B («expr ×ᵇ » E₁ E₂)) (e₁.base_set ∩ e₂.base_set)) :\n    prod.inv_fun' e₁ e₂ (prod.to_fun' e₁ e₂ x) = x :=\n  by\n  obtain ⟨x, v₁, v₂⟩ := x\n  obtain ⟨h₁ : x ∈ e₁.base_set, h₂ : x ∈ e₂.base_set⟩ := h\n  simp only [prod.to_fun', prod.inv_fun', symm_apply_apply_mk, h₁, h₂]\n#align prod.left_inv prod.left_inv\n\n",
 "inducing_pullback_total_space_embedding":
 "theorem inducing_pullback_total_space_embedding (f : B' → B) : inducing (@pullbackTotalSpaceEmbedding B E B' f) :=\n  by\n  constructor\n  simp_rw [prod.topological_space, induced_inf, induced_compose, pullback.total_space.topological_space,\n    pullback_topology]\n  rfl\n#align inducing_pullback_total_space_embedding inducing_pullback_total_space_embedding\n\n",
 "inducing_diag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ᵇ » -/\n/-- The diagonal map from the total space of the fibrewise product of two fiber bundles\n`E₁`, `E₂` into `total_space E₁ × total_space E₂` is `inducing`. -/\ntheorem fiber_bundle.prod.inducing_diag :\n    inducing (fun p => (⟨p.1, p.2.1⟩, ⟨p.1, p.2.2⟩) : TotalSpace («expr ×ᵇ » E₁ E₂) → TotalSpace E₁ × TotalSpace E₂) :=\n  ⟨rfl⟩\n#align fiber_bundle.prod.inducing_diag fiber_bundle.prod.inducing_diag\n\n",
 "eq_trivialization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprπ -/\ntheorem eq_trivialization (e : _root_.trivialization F ((exprπ) (Bundle.Trivial B F)))\n    [i : mem_trivialization_atlas e] : e = trivialization B F :=\n  i.out\n#align eq_trivialization eq_trivialization\n\n",
 "continuous_total_space_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr *ᵖ » -/\ntheorem pullback.continuous_total_space_mk [∀ x, topological_space (E x)] [fiber_bundle F E] {f : B' → B} {x : B'} :\n    continuous (@totalSpaceMk _ («expr *ᵖ » f E) x) :=\n  by\n  simp only [continuous_iff_le_induced, pullback.total_space.topological_space, induced_compose, induced_inf,\n    function.comp, total_space_mk, total_space.proj, induced_const, top_inf_eq, pullback_topology]\n  exact le_of_eq (fiber_bundle.total_space_mk_inducing F E (f x)).induced\n#align pullback.continuous_total_space_mk pullback.continuous_total_space_mk\n\n",
 "continuous_to_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ᵇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ×ᵇ » -/\ntheorem prod.continuous_to_fun :\n    continuous_on (prod.to_fun' e₁ e₂)\n      («expr ⁻¹' » (@TotalSpace.proj B («expr ×ᵇ » E₁ E₂)) (e₁.base_set ∩ e₂.base_set)) :=\n  by\n  let f₁ : total_space («expr ×ᵇ » E₁ E₂) → total_space E₁ × total_space E₂ := fun p =>\n    ((⟨p.1, p.2.1⟩ : total_space E₁), (⟨p.1, p.2.2⟩ : total_space E₂))\n  let f₂ : total_space E₁ × total_space E₂ → (B × F₁) × B × F₂ := fun p => ⟨e₁ p.1, e₂ p.2⟩\n  let f₃ : (B × F₁) × B × F₂ → B × F₁ × F₂ := fun p => ⟨p.1.1, p.1.2, p.2.2⟩\n  have hf₁ : continuous f₁ := (prod.inducing_diag E₁ E₂).continuous\n  have hf₂ : continuous_on f₂ (lower_set.prod e₁.source e₂.source) :=\n    e₁.to_local_homeomorph.continuous_on.prod_map e₂.to_local_homeomorph.continuous_on\n  have hf₃ : continuous f₃ := (continuous_fst.comp continuous_fst).prod_mk (continuous_snd.prod_map continuous_snd)\n  refine' ((hf₃.comp_continuous_on hf₂).comp hf₁.continuous_on _).congr _\n  · rw [e₁.source_eq, e₂.source_eq]\n    exact maps_to_preimage _ _\n  rintro ⟨b, v₁, v₂⟩ ⟨hb₁, hb₂⟩\n  simp only [prod.to_fun', prod.mk.inj_iff, eq_self_iff_true, and_true_iff]\n  rw [e₁.coe_fst]\n  rw [e₁.source_eq, mem_preimage]\n  exact hb₁\n#align prod.continuous_to_fun prod.continuous_to_fun\n\n",
 "continuous_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr *ᵖ » -/\ntheorem pullback.continuous_proj (f : B' → B) : continuous (@TotalSpace.proj _ («expr *ᵖ » f E)) :=\n  by\n  rw [continuous_iff_le_induced, pullback.total_space.topological_space, pullback_topology]\n  exact inf_le_left\n#align pullback.continuous_proj pullback.continuous_proj\n\n",
 "continuous_lift":
 "theorem pullback.continuous_lift (f : B' → B) : continuous (@Pullback.lift B E B' f) :=\n  by\n  rw [continuous_iff_le_induced, pullback.total_space.topological_space, pullback_topology]\n  exact inf_le_right\n#align pullback.continuous_lift pullback.continuous_lift\n\n",
 "continuous_inv_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem prod.continuous_inv_fun :\n    continuous_on (prod.inv_fun' e₁ e₂) (lower_set.prod (e₁.base_set ∩ e₂.base_set) univ) :=\n  by\n  rw [(prod.inducing_diag E₁ E₂).continuous_on_iff]\n  have H₁ : continuous fun p : B × F₁ × F₂ => ((p.1, p.2.1), (p.1, p.2.2)) :=\n    (continuous_id.prod_map continuous_fst).prod_mk (continuous_id.prod_map continuous_snd)\n  refine' (e₁.continuous_on_symm.prod_map e₂.continuous_on_symm).comp H₁.continuous_on _\n  exact fun x h => ⟨⟨h.1.1, mem_univ _⟩, ⟨h.1.2, mem_univ _⟩⟩\n#align prod.continuous_inv_fun prod.continuous_inv_fun\n\n",
 "base_set_prod":
 "@[simp]\ntheorem base_set_prod : (prod e₁ e₂).base_set = e₁.base_set ∩ e₂.base_set :=\n  rfl\n#align base_set_prod base_set_prod\n\n"}