{"trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n#print trans /-\n@[trans]\ntheorem trans (h₁ : «expr ~ » x y) (h₂ : «expr ~ » y z) : «expr ~ » x z :=\n  h₁.trans h₂\n#align trans trans\n-/\n\n",
 "tendsto_lift₂_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem tendsto_lift₂_nhds_within {f : X → Y → α} {hf : ∀ a b c d, «expr ~ » a c → «expr ~ » b d → f a b = f c d}\n    {x : X} {y : Y} {s : set (separation_quotient X × separation_quotient Y)} {l : filter α} :\n    tendsto (uncurry <| lift₂ f hf) (nhds_within s (mk x, mk y)) l ↔\n      tendsto (uncurry f) (nhds_within («expr ⁻¹' » (prod.map mk mk) s) (x, y)) l :=\n  by\n  rw [nhds_within, ← map_prod_map_mk_nhds, ← filter.push_pull, comap_principal]\n  rfl\n#align tendsto_lift₂_nhds_within tendsto_lift₂_nhds_within\n\n",
 "tendsto_lift₂_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem tendsto_lift₂_nhds {f : X → Y → α} {hf : ∀ a b c d, «expr ~ » a c → «expr ~ » b d → f a b = f c d} {x : X}\n    {y : Y} {l : filter α} :\n    tendsto (uncurry <| lift₂ f hf) ((nhds) (mk x, mk y)) l ↔ tendsto (uncurry f) ((nhds) (x, y)) l :=\n  by\n  rw [← map_prod_map_mk_nhds, tendsto_map'_iff]\n  rfl\n#align tendsto_lift₂_nhds tendsto_lift₂_nhds\n\n",
 "tendsto_lift_nhds_within_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem tendsto_lift_nhds_within_mk {f : X → α} {hf : ∀ x y, «expr ~ » x y → f x = f y} {x : X}\n    {s : set (separation_quotient X)} {l : filter α} :\n    tendsto (lift f hf) (nhds_within s (mk x)) l ↔ tendsto f (nhds_within («expr ⁻¹' » mk s) x) l := by\n  simp only [← map_mk_nhds_within_preimage, tendsto_map'_iff, lift_comp_mk]\n#align tendsto_lift_nhds_within_mk tendsto_lift_nhds_within_mk\n\n",
 "tendsto_lift_nhds_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem tendsto_lift_nhds_mk {f : X → α} {hf : ∀ x y, «expr ~ » x y → f x = f y} {x : X} {l : filter α} :\n    tendsto (lift f hf) (nhds <| mk x) l ↔ tendsto f ((nhds) x) l := by\n  simp only [← map_mk_nhds, tendsto_map'_iff, lift_comp_mk]\n#align tendsto_lift_nhds_mk tendsto_lift_nhds_mk\n\n",
 "symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n#print symm /-\n@[symm]\ntheorem symm (h : «expr ~ » x y) : «expr ~ » y x :=\n  h.symm\n#align symm symm\n-/\n\n",
 "surjective_mk":
 "theorem surjective_mk : surjective (mk : X → separation_quotient X) :=\n  surjective_quot_mk _\n#align surjective_mk surjective_mk\n\n",
 "subtype_specializes_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem subtype_specializes_iff {p : X → Prop} (x y : subtype p) : «expr ⤳ » x y ↔ «expr ⤳ » (x : X) y :=\n  inducing_coe.specializes_iff.symm\n#align subtype_specializes_iff subtype_specializes_iff\n\n",
 "subtype_inseparable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\ntheorem subtype_inseparable_iff {p : X → Prop} (x y : subtype p) : «expr ~ » x y ↔ «expr ~ » (x : X) y :=\n  inducing_coe.inseparable_iff.symm\n#align subtype_inseparable_iff subtype_inseparable_iff\n\n",
 "specializes_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers\n      [(Command.docComment\n        \"/--\"\n        \"A collection of equivalent definitions of `x ⤳ y`. The public API is given by `iff` lemmas\\nbelow. -/\")]\n      []\n      []\n      []\n      []\n      [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `specializes_tfae [])\n      (Command.declSig\n       [(Term.explicitBinder \"(\" [`x `y] [\":\" `X] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `«expr ⤳ » [`x `y])\n            \",\"\n            («term_≤_» (Term.app `pure [`x]) \"≤\" (Term.app (Term.app `nhds []) [`y]))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [`s]\n             [(Term.typeSpec \":\" (Term.app `set [`X]))]\n             \",\"\n             (Term.arrow (Term.app `is_open [`s]) \"→\" (Term.arrow («term_∈_» `y \"∈\" `s) \"→\" («term_∈_» `x \"∈\" `s))))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [`s]\n             [(Term.typeSpec \":\" (Term.app `set [`X]))]\n             \",\"\n             (Term.arrow (Term.app `is_closed [`s]) \"→\" (Term.arrow («term_∈_» `x \"∈\" `s) \"→\" («term_∈_» `y \"∈\" `s))))\n            \",\"\n            («term_∈_»\n             `y\n             \"∈\"\n             (Term.app `closure [(Term.typeAscription \"(\" («term{_}» \"{\" [`x] \"}\") \":\" [(Term.app `set [`X])] \")\")]))\n            \",\"\n            («term_⊆_»\n             (Term.app `closure [(Term.typeAscription \"(\" («term{_}» \"{\" [`y] \"}\") \":\" [(Term.app `set [`X])] \")\")])\n             \"⊆\"\n             (Term.app `closure [(«term{_}» \"{\" [`x] \"}\")]))\n            \",\"\n            (Term.app `cluster_pt [`y (Term.app `pure [`x])])]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n           \";\"\n           (Tactic.exact \"exact\" (Term.proj (Term.app `pure_le_nhds [(Term.hole \"_\")]) \".\" `trans))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"3\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun [`h `s `hso `hy] [] \"=>\" (Term.app `h [(Term.app (Term.proj `hso \".\" `mem_nhds) [`hy])]))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"4\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [`h `s `hsc `hx]\n              []\n              \"=>\"\n              (Term.app\n               `of_not_not\n               [(Term.fun\n                 \"fun\"\n                 (Term.basicFun\n                  [`hy]\n                  []\n                  \"=>\"\n                  (Term.app `h [(Term.app `«expr ᶜ» [`s]) (Term.proj `hsc \".\" `is_open_compl) `hy `hx])))]))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"5\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [`h]\n              []\n              \"=>\"\n              (Term.app\n               `h\n               [(Term.hole \"_\")\n                `is_closed_closure\n                («term_<|_» `subset_closure \"<|\" (Term.app `mem_singleton [(Term.hole \"_\")]))]))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"↔\" (num \"5\"))\n           \";\"\n           (Tactic.exact \"exact\" (Term.app `is_closed_closure.closure_subset_iff.trans [`singleton_subset_iff]))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"↔\" (num \"7\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule [] `mem_closure_iff_cluster_pt) \",\" (Tactic.rwRule [] `principal_singleton)]\n               \"]\")\n              [])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.refine'\n              \"refine'\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`h]\n                []\n                \"=>\"\n                (Term.app\n                 (Term.proj (Term.proj (Term.app `nhds_basis_opens [(Term.hole \"_\")]) \".\" `ge_iff) \".\" (fieldIdx \"2\"))\n                 [(Term.hole \"_\")]))))\n             []\n             (Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `s))\n               (Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ho)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Std.Tactic.rcases\n              \"rcases\"\n              [(Tactic.casesTarget [] (Term.app (Term.proj `mem_closure_iff \".\" (fieldIdx \"1\")) [`h `s `ho `hy]))]\n              [\"with\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed\n                 [(Std.Tactic.RCases.rcasesPat.tuple\n                   \"⟨\"\n                   [(Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `z)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hxs)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                     [\":\" («term_=_» `z \"=\" `x)])]\n                   \"⟩\")])\n                [])])\n             []\n             (Tactic.exact \"exact\" (Term.app `ho.mem_nhds [`hxs]))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n          \";\"\n          (Tactic.exact \"exact\" (Term.proj (Term.app `pure_le_nhds [(Term.hole \"_\")]) \".\" `trans))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"3\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun [`h `s `hso `hy] [] \"=>\" (Term.app `h [(Term.app (Term.proj `hso \".\" `mem_nhds) [`hy])]))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"4\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [`h `s `hsc `hx]\n             []\n             \"=>\"\n             (Term.app\n              `of_not_not\n              [(Term.fun\n                \"fun\"\n                (Term.basicFun\n                 [`hy]\n                 []\n                 \"=>\"\n                 (Term.app `h [(Term.app `«expr ᶜ» [`s]) (Term.proj `hsc \".\" `is_open_compl) `hy `hx])))]))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"5\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [`h]\n             []\n             \"=>\"\n             (Term.app\n              `h\n              [(Term.hole \"_\")\n               `is_closed_closure\n               («term_<|_» `subset_closure \"<|\" (Term.app `mem_singleton [(Term.hole \"_\")]))]))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"↔\" (num \"5\"))\n          \";\"\n          (Tactic.exact \"exact\" (Term.app `is_closed_closure.closure_subset_iff.trans [`singleton_subset_iff]))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"↔\" (num \"7\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [] `mem_closure_iff_cluster_pt) \",\" (Tactic.rwRule [] `principal_singleton)]\n              \"]\")\n             [])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.refine'\n             \"refine'\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`h]\n               []\n               \"=>\"\n               (Term.app\n                (Term.proj (Term.proj (Term.app `nhds_basis_opens [(Term.hole \"_\")]) \".\" `ge_iff) \".\" (fieldIdx \"2\"))\n                [(Term.hole \"_\")]))))\n            []\n            (Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `s))\n              (Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ho)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Std.Tactic.rcases\n             \"rcases\"\n             [(Tactic.casesTarget [] (Term.app (Term.proj `mem_closure_iff \".\" (fieldIdx \"1\")) [`h `s `ho `hy]))]\n             [\"with\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.tuple\n                  \"⟨\"\n                  [(Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `z)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hxs)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                    [\":\" («term_=_» `z \"=\" `x)])]\n                  \"⟩\")])\n               [])])\n            []\n            (Tactic.exact \"exact\" (Term.app `ho.mem_nhds [`hxs]))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.refine'\n         \"refine'\"\n         (Term.fun\n          \"fun\"\n          (Term.basicFun\n           [`h]\n           []\n           \"=>\"\n           (Term.app\n            (Term.proj (Term.proj (Term.app `nhds_basis_opens [(Term.hole \"_\")]) \".\" `ge_iff) \".\" (fieldIdx \"2\"))\n            [(Term.hole \"_\")]))))\n        []\n        (Std.Tactic.rintro\n         \"rintro\"\n         [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `s))\n          (Std.Tactic.RCases.rintroPat.one\n           (Std.Tactic.RCases.rcasesPat.tuple\n            \"⟨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ho)])\n              [])]\n            \"⟩\"))]\n         [])\n        []\n        (Std.Tactic.rcases\n         \"rcases\"\n         [(Tactic.casesTarget [] (Term.app (Term.proj `mem_closure_iff \".\" (fieldIdx \"1\")) [`h `s `ho `hy]))]\n         [\"with\"\n          (Std.Tactic.RCases.rcasesPatLo\n           (Std.Tactic.RCases.rcasesPatMed\n            [(Std.Tactic.RCases.rcasesPat.tuple\n              \"⟨\"\n              [(Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `z)])\n                [])\n               \",\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hxs)])\n                [])\n               \",\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n                [\":\" («term_=_» `z \"=\" `x)])]\n              \"⟩\")])\n           [])])\n        []\n        (Tactic.exact \"exact\" (Term.app `ho.mem_nhds [`hxs]))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.app `ho.mem_nhds [`hxs]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `ho.mem_nhds [`hxs])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hxs\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `ho.mem_nhds\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rcases\n       \"rcases\"\n       [(Tactic.casesTarget [] (Term.app (Term.proj `mem_closure_iff \".\" (fieldIdx \"1\")) [`h `s `ho `hy]))]\n       [\"with\"\n        (Std.Tactic.RCases.rcasesPatLo\n         (Std.Tactic.RCases.rcasesPatMed\n          [(Std.Tactic.RCases.rcasesPat.tuple\n            \"⟨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `z)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hxs)])\n              [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `rfl)])\n              [\":\" («term_=_» `z \"=\" `x)])]\n            \"⟩\")])\n         [])])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      («term_=_» `z \"=\" `x)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))\n      `z\n[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app (Term.proj `mem_closure_iff \".\" (fieldIdx \"1\")) [`h `s `ho `hy])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hy\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `ho\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `s\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      (Term.proj `mem_closure_iff \".\" (fieldIdx \"1\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `mem_closure_iff\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rintro\n       \"rintro\"\n       [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `s))\n        (Std.Tactic.RCases.rintroPat.one\n         (Std.Tactic.RCases.rcasesPat.tuple\n          \"⟨\"\n          [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hy)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `ho)]) [])]\n          \"⟩\"))]\n       [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.refine'\n       \"refine'\"\n       (Term.fun\n        \"fun\"\n        (Term.basicFun\n         [`h]\n         []\n         \"=>\"\n         (Term.app\n          (Term.proj (Term.proj (Term.app `nhds_basis_opens [(Term.hole \"_\")]) \".\" `ge_iff) \".\" (fieldIdx \"2\"))\n          [(Term.hole \"_\")]))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun\n       \"fun\"\n       (Term.basicFun\n        [`h]\n        []\n        \"=>\"\n        (Term.app\n         (Term.proj (Term.proj (Term.app `nhds_basis_opens [(Term.hole \"_\")]) \".\" `ge_iff) \".\" (fieldIdx \"2\"))\n         [(Term.hole \"_\")])))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       (Term.proj (Term.proj (Term.app `nhds_basis_opens [(Term.hole \"_\")]) \".\" `ge_iff) \".\" (fieldIdx \"2\"))\n       [(Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      (Term.proj (Term.proj (Term.app `nhds_basis_opens [(Term.hole \"_\")]) \".\" `ge_iff) \".\" (fieldIdx \"2\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.proj (Term.app `nhds_basis_opens [(Term.hole \"_\")]) \".\" `ge_iff)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app `nhds_basis_opens [(Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `nhds_basis_opens\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `nhds_basis_opens [(Term.hole \"_\")]) \")\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\n/--\n    A collection of equivalent definitions of `x ⤳ y`. The public API is given by `iff` lemmas\n    below. -/\n  theorem\n    specializes_tfae\n    ( x y : X )\n      :\n        TFAE\n          [\n            «expr ⤳ » x y\n              ,\n              pure x ≤ nhds y\n              ,\n              ∀ s : set X , is_open s → y ∈ s → x ∈ s\n              ,\n              ∀ s : set X , is_closed s → x ∈ s → y ∈ s\n              ,\n              y ∈ closure ( { x } : set X )\n              ,\n              closure ( { y } : set X ) ⊆ closure { x }\n              ,\n              cluster_pt y pure x\n            ]\n    :=\n      by\n        tfae_have 1 → 2\n          ;\n          exact pure_le_nhds _ . trans\n          tfae_have 2 → 3\n          ;\n          exact fun h s hso hy => h hso . mem_nhds hy\n          tfae_have 3 → 4\n          ;\n          exact fun h s hsc hx => of_not_not fun hy => h «expr ᶜ» s hsc . is_open_compl hy hx\n          tfae_have 4 → 5\n          ;\n          exact fun h => h _ is_closed_closure subset_closure <| mem_singleton _\n          tfae_have 6 ↔ 5\n          ;\n          exact is_closed_closure.closure_subset_iff.trans singleton_subset_iff\n          tfae_have 5 ↔ 7\n          ;\n          · rw [ mem_closure_iff_cluster_pt , principal_singleton ]\n          tfae_have 5 → 1\n          ·\n            refine' fun h => nhds_basis_opens _ . ge_iff . 2 _\n              rintro s ⟨ hy , ho ⟩\n              rcases mem_closure_iff . 1 h s ho hy with ⟨ z , hxs , rfl : z = x ⟩\n              exact ho.mem_nhds hxs\n          tfae_finish\n#align specializes_tfae specializes_tfae\n\n",
 "specializes_rfl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes_rfl : «expr ⤳ » x x :=\n  le_rfl\n#align specializes_rfl specializes_rfl\n\n",
 "specializes_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n@[refl]\ntheorem specializes_refl (x : X) : «expr ⤳ » x x :=\n  specializes_rfl\n#align specializes_refl specializes_refl\n\n",
 "specializes_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n@[simp]\ntheorem specializes_prod {x₁ x₂ : X} {y₁ y₂ : Y} : «expr ⤳ » (x₁, y₁) (x₂, y₂) ↔ «expr ⤳ » x₁ x₂ ∧ «expr ⤳ » y₁ y₂ := by\n  simp only [specializes, nhds_prod_eq, prod_le_prod]\n#align specializes_prod specializes_prod\n\n",
 "specializes_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n@[simp]\ntheorem specializes_pi {f g : ∀ i, π i} : «expr ⤳ » f g ↔ ∀ i, «expr ⤳ » (f i) (g i) := by\n  simp only [specializes, nhds_pi, pi_le_pi]\n#align specializes_pi specializes_pi\n\n",
 "specializes_of_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes_of_nhds_within (h₁ : nhds_within s x ≤ nhds_within s y) (h₂ : x ∈ s) : «expr ⤳ » x y :=\n  specializes_iff_pure.2 <|\n    calc\n      pure x ≤ nhds_within s x := le_inf (pure_le_nhds _) (le_principal_iff.2 h₂)\n      _ ≤ nhds_within s y := h₁\n      _ ≤ (nhds) y := inf_le_left\n      \n#align specializes_of_nhds_within specializes_of_nhds_within\n\n",
 "specializes_of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes_of_eq (e : x = y) : «expr ⤳ » x y :=\n  e ▸ specializes_refl x\n#align specializes_of_eq specializes_of_eq\n\n",
 "specializes_iff_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem specializes_iff_pure : «expr ⤳ » x y ↔ pure x ≤ (nhds) y :=\n  (specializes_tfae x y).out 0 1\n#align specializes_iff_pure specializes_iff_pure\n\n",
 "specializes_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem specializes_iff_nhds : «expr ⤳ » x y ↔ (nhds) x ≤ (nhds) y :=\n  iff.rfl\n#align specializes_iff_nhds specializes_iff_nhds\n\n",
 "specializes_iff_mem_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes_iff_mem_closure : «expr ⤳ » x y ↔ y ∈ closure ({x} : set X) :=\n  (specializes_tfae x y).out 0 4\n#align specializes_iff_mem_closure specializes_iff_mem_closure\n\n",
 "specializes_iff_forall_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes_iff_forall_open : «expr ⤳ » x y ↔ ∀ s : set X, is_open s → y ∈ s → x ∈ s :=\n  (specializes_tfae x y).out 0 2\n#align specializes_iff_forall_open specializes_iff_forall_open\n\n",
 "specializes_iff_forall_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes_iff_forall_closed : «expr ⤳ » x y ↔ ∀ s : set X, is_closed s → x ∈ s → y ∈ s :=\n  (specializes_tfae x y).out 0 3\n#align specializes_iff_forall_closed specializes_iff_forall_closed\n\n",
 "specializes_iff_closure_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes_iff_closure_subset : «expr ⤳ » x y ↔ closure ({y} : set X) ⊆ closure {x} :=\n  (specializes_tfae x y).out 0 5\n#align specializes_iff_closure_subset specializes_iff_closure_subset\n\n",
 "specializes_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem inducing.specializes_iff (hf : inducing f) : «expr ⤳ » (f x) (f y) ↔ «expr ⤳ » x y := by\n  simp only [specializes_iff_mem_closure, hf.closure_eq_preimage_closure_image, image_singleton, mem_preimage]\n#align inducing.specializes_iff inducing.specializes_iff\n\n",
 "specializes'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem inseparable.specializes' (h : «expr ~ » x y) : «expr ⤳ » y x :=\n  h.ge\n#align inseparable.specializes' inseparable.specializes'\n\n",
 "specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem inseparable.specializes (h : «expr ~ » x y) : «expr ⤳ » x y :=\n  h.le\n#align inseparable.specializes inseparable.specializes\n\n",
 "specialization_monotone":
 "/-- A continuous function is monotone with respect to the specialization preorders on the domain and\nthe codomain. -/\ntheorem continuous.specialization_monotone (hf : continuous f) :\n    @monotone _ _ (specialization_preorder X) (specialization_preorder Y) f := fun x y h => h.map hf\n#align continuous.specialization_monotone continuous.specialization_monotone\n\n",
 "rfl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n#print rfl /-\ntheorem rfl : «expr ~ » x x :=\n  refl x\n#align rfl rfl\n-/\n\n",
 "refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n#print refl /-\n@[refl]\ntheorem refl (x : X) : «expr ~ » x x :=\n  eq.refl ((nhds) x)\n#align refl refl\n-/\n\n",
 "range_mk":
 "@[simp]\ntheorem range_mk : range (mk : X → separation_quotient X) = univ :=\n  surjective_mk.range_eq\n#align range_mk range_mk\n\n",
 "quotient_map_mk":
 "theorem quotient_map_mk : quotient_map (mk : X → separation_quotient X) :=\n  quotient_map_quot_mk\n#align quotient_map_mk quotient_map_mk\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\ntheorem inseparable.prod {x₁ x₂ : X} {y₁ y₂ : Y} (hx : «expr ~ » x₁ x₂) (hy : «expr ~ » y₁ y₂) :\n    «expr ~ » (x₁, y₁) (x₂, y₂) :=\n  inseparable_prod.2 ⟨hx, hy⟩\n#align inseparable.prod inseparable.prod\n\n",
 "preimage_mk_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_mk_interior : «expr ⁻¹' » mk (interior t) = interior («expr ⁻¹' » mk t) :=\n  is_open_map_mk.preimage_interior_eq_interior_preimage continuous_mk t\n#align preimage_mk_interior preimage_mk_interior\n\n",
 "preimage_mk_frontier":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_mk_frontier : «expr ⁻¹' » mk (frontier t) = frontier («expr ⁻¹' » mk t) :=\n  is_open_map_mk.preimage_frontier_eq_frontier_preimage continuous_mk t\n#align preimage_mk_frontier preimage_mk_frontier\n\n",
 "preimage_mk_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_mk_closure : «expr ⁻¹' » mk (closure t) = closure («expr ⁻¹' » mk t) :=\n  is_open_map_mk.preimage_closure_eq_closure_preimage continuous_mk t\n#align preimage_mk_closure preimage_mk_closure\n\n",
 "preimage_image_mk_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem preimage_image_mk_open (hs : is_open s) : «expr ⁻¹' » mk («expr '' » mk s) = s :=\n  by\n  refine' subset.antisymm _ (subset_preimage_image _ _)\n  rintro x ⟨y, hys, hxy⟩\n  exact ((mk_eq_mk.1 hxy).mem_open_iff hs).1 hys\n#align preimage_image_mk_open preimage_image_mk_open\n\n",
 "preimage_image_mk_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem preimage_image_mk_closed (hs : is_closed s) : «expr ⁻¹' » mk («expr '' » mk s) = s :=\n  by\n  refine' subset.antisymm _ (subset_preimage_image _ _)\n  rintro x ⟨y, hys, hxy⟩\n  exact ((mk_eq_mk.1 hxy).mem_closed_iff hs).1 hys\n#align preimage_image_mk_closed preimage_image_mk_closed\n\n",
 "of_eq":
 "#print of_eq /-\ntheorem of_eq (e : x = y) : inseparable x y :=\n  e ▸ refl x\n#align of_eq of_eq\n-/\n\n",
 "not_specializes_iff_exists_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem not_specializes_iff_exists_open : ¬«expr ⤳ » x y ↔ ∃ S : set X, is_open S ∧ y ∈ S ∧ x ∉ S :=\n  by\n  rw [specializes_iff_forall_open]\n  push_neg\n  rfl\n#align not_specializes_iff_exists_open not_specializes_iff_exists_open\n\n",
 "not_specializes_iff_exists_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem not_specializes_iff_exists_closed : ¬«expr ⤳ » x y ↔ ∃ S : set X, is_closed S ∧ x ∈ S ∧ y ∉ S :=\n  by\n  rw [specializes_iff_forall_closed]\n  push_neg\n  rfl\n#align not_specializes_iff_exists_closed not_specializes_iff_exists_closed\n\n",
 "not_specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem is_closed.not_specializes (hs : is_closed s) (hx : x ∈ s) (hy : y ∉ s) : ¬«expr ⤳ » x y := fun h =>\n  hy <| h.mem_closed hs hx\n#align is_closed.not_specializes is_closed.not_specializes\n\n",
 "not_inseparable_iff_exists_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\ntheorem not_inseparable_iff_exists_open : ¬«expr ~ » x y ↔ ∃ s : set X, is_open s ∧ Xor' (x ∈ s) (y ∈ s) := by\n  simp [inseparable_iff_forall_open, ← xor_iff_not_iff]\n#align not_inseparable_iff_exists_open not_inseparable_iff_exists_open\n\n",
 "not_inseparable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\ntheorem is_open.not_inseparable (hs : is_open s) (hx : x ∈ s) (hy : y ∉ s) : ¬«expr ~ » x y := fun h =>\n  hy <| (h.mem_open_iff hs).1 hx\n#align is_open.not_inseparable is_open.not_inseparable\n\n",
 "nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_eq (h : «expr ~ » x y) : (nhds) x = (nhds) y :=\n  h\n#align nhds_eq nhds_eq\n\n",
 "mk_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n@[simp]\ntheorem mk_eq_mk : mk x = mk y ↔ «expr ~ » x y :=\n  quotient.eq'\n#align mk_eq_mk mk_eq_mk\n\n",
 "mem_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\ntheorem mem_open_iff (h : «expr ~ » x y) (hs : is_open s) : x ∈ s ↔ y ∈ s :=\n  inseparable_iff_forall_open.1 h s hs\n#align mem_open_iff mem_open_iff\n\n",
 "mem_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes.mem_open (h : «expr ⤳ » x y) (hs : is_open s) (hy : y ∈ s) : x ∈ s :=\n  specializes_iff_forall_open.1 h s hs hy\n#align specializes.mem_open specializes.mem_open\n\n",
 "mem_closed_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\ntheorem mem_closed_iff (h : «expr ~ » x y) (hs : is_closed s) : x ∈ s ↔ y ∈ s :=\n  inseparable_iff_forall_closed.1 h s hs\n#align mem_closed_iff mem_closed_iff\n\n",
 "mem_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes.mem_closed (h : «expr ⤳ » x y) (hs : is_closed s) (hx : x ∈ s) : y ∈ s :=\n  specializes_iff_forall_closed.1 h s hs hx\n#align specializes.mem_closed specializes.mem_closed\n\n",
 "map_prod_map_mk_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem map_prod_map_mk_nhds (x : X) (y : Y) : map (prod.map mk mk) ((nhds) (x, y)) = (nhds) (mk x, mk y) := by\n  rw [nhds_prod_eq, ← prod_map_map_eq', map_mk_nhds, map_mk_nhds, nhds_prod_eq]\n#align map_prod_map_mk_nhds map_prod_map_mk_nhds\n\n",
 "map_of_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\ntheorem map_of_continuous_at (h : «expr ~ » x y) (hx : continuous_at f x) (hy : continuous_at f y) :\n    «expr ~ » (f x) (f y) :=\n  (h.specializes.map_of_continuous_at hy).antisymm (h.specializes'.map_of_continuous_at hx)\n#align map_of_continuous_at map_of_continuous_at\n\n",
 "map_mk_nhds_within_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem map_mk_nhds_within_preimage (s : set (separation_quotient X)) (x : X) :\n    map mk (nhds_within («expr ⁻¹' » mk s) x) = nhds_within s (mk x) := by\n  rw [nhds_within, ← comap_principal, filter.push_pull, nhds_within, map_mk_nhds]\n#align map_mk_nhds_within_preimage map_mk_nhds_within_preimage\n\n",
 "map_mk_nhds_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_mk_nhds_set : map mk ((nhds_set) s) = (nhds_set) («expr '' » mk s) := by\n  rw [← comap_mk_nhds_set_image, map_comap_of_surjective surjective_mk]\n#align map_mk_nhds_set map_mk_nhds_set\n\n",
 "map_mk_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem map_mk_nhds : map mk ((nhds) x) = (nhds) (mk x) := by\n  rw [← comap_mk_nhds_mk, map_comap_of_surjective surjective_mk]\n#align map_mk_nhds map_mk_nhds\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\ntheorem map (h : «expr ~ » x y) (hf : continuous f) : «expr ~ » (f x) (f y) :=\n  h.map_of_continuous_at hf.continuous_at hf.continuous_at\n#align map map\n\n",
 "lift₂_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n@[simp]\ntheorem lift₂_mk {f : X → Y → α} (hf : ∀ a b c d, «expr ~ » a c → «expr ~ » b d → f a b = f c d) (x : X) (y : Y) :\n    lift₂ f hf (mk x) (mk y) = f x y :=\n  rfl\n#align lift₂_mk lift₂_mk\n\n",
 "lift_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n@[simp]\ntheorem lift_mk {f : X → α} (hf : ∀ x y, «expr ~ » x y → f x = f y) (x : X) : lift f hf (mk x) = f x :=\n  rfl\n#align lift_mk lift_mk\n\n",
 "lift_comp_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n@[simp]\ntheorem lift_comp_mk {f : X → α} (hf : ∀ x y, «expr ~ » x y → f x = f y) : lift f hf ∘ mk = f :=\n  rfl\n#align lift_comp_mk lift_comp_mk\n\n",
 "is_open_map_mk":
 "theorem is_open_map_mk : is_open_map (mk : X → separation_quotient X) := fun s hs =>\n  quotient_map_mk.is_open_preimage.1 <| by rwa [preimage_image_mk_open hs]\n#align is_open_map_mk is_open_map_mk\n\n",
 "is_closed_map_mk":
 "theorem is_closed_map_mk : is_closed_map (mk : X → separation_quotient X) :=\n  inducing_mk.is_closed_map <| by\n    rw [range_mk]\n    exact is_closed_univ\n#align is_closed_map_mk is_closed_map_mk\n\n",
 "inseparable_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n@[simp]\ntheorem inseparable_prod {x₁ x₂ : X} {y₁ y₂ : Y} : «expr ~ » (x₁, y₁) (x₂, y₂) ↔ «expr ~ » x₁ x₂ ∧ «expr ~ » y₁ y₂ := by\n  simp only [inseparable, nhds_prod_eq, prod_inj]\n#align inseparable_prod inseparable_prod\n\n",
 "inseparable_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n@[simp]\ntheorem inseparable_pi {f g : ∀ i, π i} : «expr ~ » f g ↔ ∀ i, «expr ~ » (f i) (g i) := by\n  simp only [inseparable, nhds_pi, funext_iff, pi_inj]\n#align inseparable_pi inseparable_pi\n\n",
 "inseparable_of_nhds_within_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\ntheorem inseparable_of_nhds_within_eq (hx : x ∈ s) (hy : y ∈ s) (h : nhds_within s x = nhds_within s y) :\n    «expr ~ » x y :=\n  (specializes_of_nhds_within h.le hx).antisymm (specializes_of_nhds_within h.ge hy)\n#align inseparable_of_nhds_within_eq inseparable_of_nhds_within_eq\n\n",
 "inseparable_iff_specializes_and":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem inseparable_iff_specializes_and : «expr ~ » x y ↔ «expr ⤳ » x y ∧ «expr ⤳ » y x :=\n  le_antisymm_iff\n#align inseparable_iff_specializes_and inseparable_iff_specializes_and\n\n",
 "inseparable_iff_mem_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\ntheorem inseparable_iff_mem_closure : «expr ~ » x y ↔ x ∈ closure ({y} : set X) ∧ y ∈ closure ({x} : set X) :=\n  inseparable_iff_specializes_and.trans <| by simp only [specializes_iff_mem_closure, and_comm']\n#align inseparable_iff_mem_closure inseparable_iff_mem_closure\n\n",
 "inseparable_iff_forall_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\ntheorem inseparable_iff_forall_open : «expr ~ » x y ↔ ∀ s : set X, is_open s → (x ∈ s ↔ y ∈ s) := by\n  simp only [inseparable_iff_specializes_and, specializes_iff_forall_open, ← forall_and, ← iff_def, iff.comm]\n#align inseparable_iff_forall_open inseparable_iff_forall_open\n\n",
 "inseparable_iff_forall_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\ntheorem inseparable_iff_forall_closed : «expr ~ » x y ↔ ∀ s : set X, is_closed s → (x ∈ s ↔ y ∈ s) := by\n  simp only [inseparable_iff_specializes_and, specializes_iff_forall_closed, ← forall_and, ← iff_def]\n#align inseparable_iff_forall_closed inseparable_iff_forall_closed\n\n",
 "inseparable_iff_closure_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\ntheorem inseparable_iff_closure_eq : «expr ~ » x y ↔ closure ({x} : set X) = closure {y} := by\n  simp only [inseparable_iff_specializes_and, specializes_iff_closure_subset, ← subset_antisymm_iff, eq_comm]\n#align inseparable_iff_closure_eq inseparable_iff_closure_eq\n\n",
 "inseparable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\ntheorem inducing.inseparable_iff (hf : inducing f) : «expr ~ » (f x) (f y) ↔ «expr ~ » x y := by\n  simp only [inseparable_iff_specializes_and, hf.specializes_iff]\n#align inducing.inseparable_iff inducing.inseparable_iff\n\n",
 "inseparable_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem inseparable_def : «expr ~ » x y ↔ (nhds) x = (nhds) y :=\n  iff.rfl\n#align inseparable_def inseparable_def\n\n",
 "inducing_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem inducing_mk : inducing (mk : X → separation_quotient X) :=\n  ⟨le_antisymm (continuous_iff_le_induced.1 continuous_mk) fun s hs =>\n      ⟨«expr '' » mk s, is_open_map_mk s hs, preimage_image_mk_open hs⟩⟩\n#align inducing_mk inducing_mk\n\n",
 "image_mk_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_mk_closure : «expr '' » mk (closure s) = closure («expr '' » mk s) :=\n  (image_closure_subset_closure_image continuous_mk).antisymm <| is_closed_map_mk.closure_image_subset _\n#align image_mk_closure image_mk_closure\n\n",
 "continuous_within_at_lift₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem continuous_within_at_lift₂ {f : X → Y → Z} {hf : ∀ a b c d, «expr ~ » a c → «expr ~ » b d → f a b = f c d}\n    {s : set (separation_quotient X × separation_quotient Y)} {x : X} {y : Y} :\n    continuous_within_at (uncurry <| lift₂ f hf) s (mk x, mk y) ↔\n      continuous_within_at (uncurry f) («expr ⁻¹' » (prod.map mk mk) s) (x, y) :=\n  tendsto_lift₂_nhds_within\n#align continuous_within_at_lift₂ continuous_within_at_lift₂\n\n",
 "continuous_within_at_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem continuous_within_at_lift {f : X → Y} {hf : ∀ x y, «expr ~ » x y → f x = f y} {s : set (separation_quotient X)}\n    {x : X} : continuous_within_at (lift f hf) s (mk x) ↔ continuous_within_at f («expr ⁻¹' » mk s) x :=\n  tendsto_lift_nhds_within_mk\n#align continuous_within_at_lift continuous_within_at_lift\n\n",
 "continuous_on_lift₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem continuous_on_lift₂ {f : X → Y → Z} {hf : ∀ a b c d, «expr ~ » a c → «expr ~ » b d → f a b = f c d}\n    {s : set (separation_quotient X × separation_quotient Y)} :\n    continuous_on (uncurry <| lift₂ f hf) s ↔ continuous_on (uncurry f) («expr ⁻¹' » (prod.map mk mk) s) :=\n  by\n  simp_rw [continuous_on, (surjective_mk.prod_map surjective_mk).forall, prod.forall, prod.map,\n    continuous_within_at_lift₂]\n  rfl\n#align continuous_on_lift₂ continuous_on_lift₂\n\n",
 "continuous_on_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem continuous_on_lift {f : X → Y} {hf : ∀ x y, «expr ~ » x y → f x = f y} {s : set (separation_quotient X)} :\n    continuous_on (lift f hf) s ↔ continuous_on f («expr ⁻¹' » mk s) := by\n  simp only [continuous_on, surjective_mk.forall, continuous_within_at_lift, mem_preimage]\n#align continuous_on_lift continuous_on_lift\n\n",
 "continuous_mk":
 "theorem continuous_mk : continuous (mk : X → separation_quotient X) :=\n  continuous_quot_mk\n#align continuous_mk continuous_mk\n\n",
 "continuous_lift₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n@[simp]\ntheorem continuous_lift₂ {f : X → Y → Z} {hf : ∀ a b c d, «expr ~ » a c → «expr ~ » b d → f a b = f c d} :\n    continuous (uncurry <| lift₂ f hf) ↔ continuous (uncurry f) := by\n  simp only [continuous_iff_continuous_on_univ, continuous_on_lift₂, preimage_univ]\n#align continuous_lift₂ continuous_lift₂\n\n",
 "continuous_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n@[simp]\ntheorem continuous_lift {f : X → Y} {hf : ∀ x y, «expr ~ » x y → f x = f y} : continuous (lift f hf) ↔ continuous f :=\n  by simp only [continuous_iff_continuous_on_univ, continuous_on_lift, preimage_univ]\n#align continuous_lift continuous_lift\n\n",
 "continuous_at_lift₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n@[simp]\ntheorem continuous_at_lift₂ {f : X → Y → Z} {hf : ∀ a b c d, «expr ~ » a c → «expr ~ » b d → f a b = f c d} {x : X}\n    {y : Y} : continuous_at (uncurry <| lift₂ f hf) (mk x, mk y) ↔ continuous_at (uncurry f) (x, y) :=\n  tendsto_lift₂_nhds\n#align continuous_at_lift₂ continuous_at_lift₂\n\n",
 "continuous_at_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\n@[simp]\ntheorem continuous_at_lift {f : X → Y} {hf : ∀ x y, «expr ~ » x y → f x = f y} {x : X} :\n    continuous_at (lift f hf) (mk x) ↔ continuous_at f x :=\n  tendsto_lift_nhds_mk\n#align continuous_at_lift continuous_at_lift\n\n",
 "comap_mk_nhds_set_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n@[simp]\ntheorem comap_mk_nhds_set_image : comap mk ((nhds_set) («expr '' » mk s)) = (nhds_set) s :=\n  (inducing_mk.nhds_set_eq_comap _).symm\n#align comap_mk_nhds_set_image comap_mk_nhds_set_image\n\n",
 "comap_mk_nhds_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem comap_mk_nhds_set : comap mk ((nhds_set) t) = (nhds_set) («expr ⁻¹' » mk t) := by\n  conv_lhs => rw [← image_preimage_eq t surjective_mk, comap_mk_nhds_set_image]\n#align comap_mk_nhds_set comap_mk_nhds_set\n\n",
 "comap_mk_nhds_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem comap_mk_nhds_mk : comap mk ((nhds) (mk x)) = (nhds) x :=\n  (inducing_mk.nhds_eq_comap _).symm\n#align comap_mk_nhds_mk comap_mk_nhds_mk\n\n",
 "antisymm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~ » -/\ntheorem specializes.antisymm (h₁ : «expr ⤳ » x y) (h₂ : «expr ⤳ » y x) : «expr ~ » x y :=\n  le_antisymm h₁ h₂\n#align specializes.antisymm specializes.antisymm\n\n"}