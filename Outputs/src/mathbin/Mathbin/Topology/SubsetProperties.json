{"union":
 "theorem is_clopen.union {s t : set α} (hs : is_clopen s) (ht : is_clopen t) : is_clopen (s ∪ t) :=\n  ⟨hs.1.union ht.1, hs.2.union ht.2⟩\n#align is_clopen.union is_clopen.union\n\n",
 "tendsto_cocompact":
 "/-- A closed embedding is proper, ie, inverse images of compact sets are contained in compacts.\nMoreover, the preimage of a compact set is compact, see `closed_embedding.is_compact_preimage`. -/\ntheorem closed_embedding.tendsto_cocompact {f : α → β} (hf : closed_embedding f) :\n    tendsto f (filter.cocompact α) (filter.cocompact β) :=\n  filter.has_basis_cocompact.tendsto_right_iff.mpr fun K hK => (hf.is_compact_preimage hK).compl_mem_cocompact\n#align closed_embedding.tendsto_cocompact closed_embedding.tendsto_cocompact\n\n",
 "symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem nhds_contain_boxes.symm {s : set α} {t : set β} : nhds_contain_boxes s t → nhds_contain_boxes t s :=\n  fun H n hn hp =>\n  let ⟨u, v, uo, vo, su, tv, p⟩ :=\n    H («expr ⁻¹' » prod.swap n) (hn.preimage continuous_swap) (by rwa [← image_subset_iff, image_swap_prod])\n  ⟨v, u, vo, uo, tv, su, by rwa [← image_subset_iff, image_swap_prod] at p⟩\n#align nhds_contain_boxes.symm nhds_contain_boxes.symm\n\n",
 "subset_succ":
 "theorem subset_succ (n : ℕ) : K n ⊆ K (n + 1) :=\n  Subset.trans (K.subset_interior_succ n) interior_subset\n#align subset_succ subset_succ\n\n",
 "subset_irreducible":
 "/-- If `∅ ≠ U ⊆ S ⊆ Z` such that `U` is open and `Z` is preirreducible, then `S` is irreducible. -/\ntheorem is_preirreducible.subset_irreducible {S U Z : set α} (hZ : is_preirreducible Z) (hU : U.nonempty)\n    (hU' : is_open U) (h₁ : U ⊆ S) (h₂ : S ⊆ Z) : is_irreducible S := by\n  classical\n    obtain ⟨z, hz⟩ := hU\n    replace hZ : is_irreducible Z := ⟨⟨z, h₂ (h₁ hz)⟩, hZ⟩\n    refine' ⟨⟨z, h₁ hz⟩, _⟩\n    rintro u v hu hv ⟨x, hx, hx'⟩ ⟨y, hy, hy'⟩\n    obtain ⟨a, -, ha'⟩ := is_irreducible_iff_sInter.mp hZ {U, u, v} (by tidy) _\n    replace ha' : a ∈ U ∧ a ∈ u ∧ a ∈ v := by simpa using ha'\n    exact ⟨a, h₁ ha'.1, ha'.2⟩\n    · intro U H\n      simp only [Finset.mem_insert, Finset.mem_singleton] at H\n      rcases H with (rfl | rfl | rfl)\n      exacts[⟨z, h₂ (h₁ hz), hz⟩, ⟨x, h₂ hx, hx'⟩, ⟨y, h₂ hy, hy'⟩]\n#align is_preirreducible.subset_irreducible is_preirreducible.subset_irreducible\n\n",
 "subset_interior_succ":
 "theorem subset_interior_succ (n : ℕ) : K n ⊆ interior (K (n + 1)) :=\n  K.subset_interior_succ' n\n#align subset_interior_succ subset_interior_succ\n\n",
 "subset_interior":
 "theorem subset_interior ⦃m n : ℕ⦄ (h : m < n) : K m ⊆ interior (K n) :=\n  Subset.trans (K.subset_interior_succ m) <| interior_mono <| K.subset h\n#align subset_interior subset_interior\n\n",
 "subset_closure_inter_of_is_preirreducible_of_is_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- A nonemtpy open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem subset_closure_inter_of_is_preirreducible_of_is_open {S U : set α} (hS : is_preirreducible S) (hU : is_open U)\n    (h : (S ∩ U).nonempty) : S ⊆ closure (S ∩ U) := by\n  by_contra h'\n  obtain ⟨x, h₁, h₂, h₃⟩ :=\n    hS _ («expr ᶜ» (closure (S ∩ U))) hU (is_open_compl_iff.mpr is_closed_closure) h\n      (set.inter_compl_nonempty_iff.mpr h')\n  exact h₃ (subset_closure ⟨h₁, h₂⟩)\n#align subset_closure_inter_of_is_preirreducible_of_is_open subset_closure_inter_of_is_preirreducible_of_is_open\n\n",
 "subset":
 "@[mono]\nprotected theorem subset ⦃m n : ℕ⦄ (h : m ≤ n) : K m ⊆ K n :=\n  show K m ≤ K n from monotone_nat_of_le_succ K.subset_succ h\n#align subset subset\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem is_clopen.prod {s : set α} {t : set β} (hs : is_clopen s) (ht : is_clopen t) : is_clopen (lower_set.prod s t) :=\n  ⟨hs.1.prod ht.1, hs.2.prod ht.2⟩\n#align is_clopen.prod is_clopen.prod\n\n",
 "preirreducible_space":
 "theorem subtype.preirreducible_space {s : set α} (h : is_preirreducible s) : preirreducible_space s :=\n  {\n    is_preirreducible_univ := by\n      intro u v hu hv hsu hsv\n      rw [is_open_induced_iff] at hu hv\n      rcases hu with ⟨u, hu, rfl⟩\n      rcases hv with ⟨v, hv, rfl⟩\n      rcases hsu with ⟨⟨x, hxs⟩, hxs', hxu⟩\n      rcases hsv with ⟨⟨y, hys⟩, hys', hyv⟩\n      rcases h u v hu hv ⟨x, hxs, hxu⟩ ⟨y, hys, hyv⟩ with ⟨z, hzs, ⟨hzu, hzv⟩⟩\n      exact ⟨⟨z, hzs⟩, ⟨Set.mem_univ _, ⟨hzu, hzv⟩⟩⟩ }\n#align subtype.preirreducible_space subtype.preirreducible_space\n\n",
 "preimage_clopen_of_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem continuous_on.preimage_clopen_of_clopen {f : α → β} {s : set α} {t : set β} (hf : continuous_on f s)\n    (hs : is_clopen s) (ht : is_clopen t) : is_clopen (s ∩ «expr ⁻¹' » f t) :=\n  ⟨continuous_on.preimage_open_of_open hf hs.1 ht.1, continuous_on.preimage_closed_of_closed hf hs.2 ht.2⟩\n#align continuous_on.preimage_clopen_of_clopen continuous_on.preimage_clopen_of_clopen\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_preirreducible.preimage {Z : set α} (hZ : is_preirreducible Z) {f : β → α} (hf : open_embedding f) :\n    is_preirreducible («expr ⁻¹' » f Z) :=\n  by\n  rintro U V hU hV ⟨x, hx, hx'⟩ ⟨y, hy, hy'⟩\n  obtain ⟨_, h₁, ⟨z, h₂, rfl⟩, ⟨z', h₃, h₄⟩⟩ :=\n    hZ _ _ (hf.is_open_map _ hU) (hf.is_open_map _ hV) ⟨f x, hx, Set.mem_image_of_mem f hx'⟩\n      ⟨f y, hy, Set.mem_image_of_mem f hy'⟩\n  cases hf.inj h₄\n  exact ⟨z, h₁, h₂, h₃⟩\n#align is_preirreducible.preimage is_preirreducible.preimage\n\n",
 "open_subset":
 "theorem is_preirreducible.open_subset {Z U : set α} (hZ : is_preirreducible Z) (hU : is_open U) (hU' : U ⊆ Z) :\n    is_preirreducible U :=\n  U.eq_empty_or_nonempty.elim (fun h => h.symm ▸ is_preirreducible_empty) fun h =>\n    (hZ.subset_irreducible h hU (fun _ => id) hU').2\n#align is_preirreducible.open_subset is_preirreducible.open_subset\n\n",
 "of_countable":
 "-- see Note [lower instance priority]\ntheorem sigma_compact_space.of_countable (S : set (set α)) (Hc : S.countable) (Hcomp : ∀ s ∈ S, is_compact s)\n    (HU : ⋃₀ S = univ) : sigma_compact_space α :=\n  ⟨(exists_seq_cover_iff_countable ⟨_, is_compact_empty⟩).2 ⟨S, Hc, Hcomp, HU⟩⟩\n#align sigma_compact_space.of_countable sigma_compact_space.of_countable\n\n",
 "not_compact_space_iff":
 "theorem not_compact_space_iff : ¬compact_space α ↔ noncompact_space α :=\n  ⟨fun h₁ => ⟨fun h₂ => h₁ ⟨h₂⟩⟩, fun ⟨h₁⟩ ⟨h₂⟩ => h₁ h₂⟩\n#align not_compact_space_iff not_compact_space_iff\n\n",
 "nonempty_preirreducible_inter":
 "theorem nonempty_preirreducible_inter [preirreducible_space α] {s t : set α} :\n    is_open s → is_open t → s.nonempty → t.nonempty → (s ∩ t).nonempty := by\n  simpa only [univ_inter, univ_subset_iff] using @preirreducible_space.is_preirreducible_univ α _ _ s t\n#align nonempty_preirreducible_inter nonempty_preirreducible_inter\n\n",
 "nonempty_Inter_of_sequence_nonempty_compact_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- Cantor's intersection theorem for sequences indexed by `ℕ`:\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. -/\ntheorem is_compact.nonempty_Inter_of_sequence_nonempty_compact_closed (Z : ℕ → set α) (hZd : ∀ i, Z (i + 1) ⊆ Z i)\n    (hZn : ∀ i, (Z i).nonempty) (hZ0 : is_compact (Z 0)) (hZcl : ∀ i, is_closed (Z i)) :\n    («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i)).nonempty :=\n  have Zmono : antitone Z := antitone_nat_of_succ_le hZd\n  have hZd : Directed («expr ⊇ » · ·) Z := directed_of_sup Zmono\n  have : ∀ i, Z i ⊆ Z 0 := fun i => Zmono <| zero_le i\n  have hZc : ∀ i, is_compact (Z i) := fun i => is_compact_of_is_closed_subset hZ0 (hZcl i) (this i)\n  is_compact.nonempty_Inter_of_directed_nonempty_compact_closed Z hZd hZn hZc hZcl\n#align\n  is_compact.nonempty_Inter_of_sequence_nonempty_compact_closed is_compact.nonempty_Inter_of_sequence_nonempty_compact_closed\n\n",
 "nonempty_Inter_of_directed_nonempty_compact_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem is_compact.nonempty_Inter_of_directed_nonempty_compact_closed {ι : Type v} [hι : nonempty ι] (Z : ι → set α)\n    (hZd : Directed («expr ⊇ » · ·) Z) (hZn : ∀ i, (Z i).nonempty) (hZc : ∀ i, is_compact (Z i))\n    (hZcl : ∀ i, is_closed (Z i)) :\n    («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i)).nonempty :=\n  by\n  apply hι.elim\n  intro i₀\n  let Z' i := Z i ∩ Z i₀\n  suffices\n    («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z' i)).nonempty by\n    exact this.mono (Inter_mono fun i => inter_subset_left (Z i) (Z i₀))\n  rw [nonempty_iff_ne_empty]\n  intro H\n  obtain ⟨t, ht⟩ :\n    ∃ t : Finset ι,\n      Z i₀ ∩ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z' i) = ∅\n  exact (hZc i₀).elim_finite_subfamily_closed Z' (fun i => is_closed.inter (hZcl i) (hZcl i₀)) (by rw [H, inter_empty])\n  obtain ⟨i₁, hi₁⟩ : ∃ i₁ : ι, Z i₁ ⊆ Z i₀ ∧ ∀ i ∈ t, Z i₁ ⊆ Z' i :=\n    by\n    rcases Directed.finset_le hZd t with ⟨i, hi⟩\n    rcases hZd i i₀ with ⟨i₁, hi₁, hi₁₀⟩\n    use i₁, hi₁₀\n    intro j hj\n    exact subset_inter (subset.trans hi₁ (hi j hj)) hi₁₀\n  suffices\n    (Z i₀ ∩\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z' i)).nonempty\n    by\n    rw [nonempty_iff_ne_empty] at this\n    contradiction\n  exact (hZn i₁).mono (subset_inter hi₁.left <| subset_Inter₂ hi₁.right)\n#align\n  is_compact.nonempty_Inter_of_directed_nonempty_compact_closed is_compact.nonempty_Inter_of_directed_nonempty_compact_closed\n\n",
 "nonempty":
 "theorem is_irreducible.nonempty {s : set α} (h : is_irreducible s) : s.nonempty :=\n  h.1\n#align is_irreducible.nonempty is_irreducible.nonempty\n\n",
 "noncompact_space_of_ne_bot":
 "theorem noncompact_space_of_ne_bot (h : ne_bot (filter.cocompact α)) : noncompact_space α :=\n  ⟨fun h' => (filter.nonempty_of_mem h'.compl_mem_cocompact).ne_empty compl_univ⟩\n#align noncompact_space_of_ne_bot noncompact_space_of_ne_bot\n\n",
 "noncompact_space_iff":
 "theorem prod.noncompact_space_iff :\n    noncompact_space (α × β) ↔ noncompact_space α ∧ nonempty β ∨ nonempty α ∧ noncompact_space β := by\n  simp [← filter.cocompact_ne_bot_iff, ← filter.coprod_cocompact, filter.coprod_ne_bot_iff]\n#align prod.noncompact_space_iff prod.noncompact_space_iff\n\n",
 "noncompact_space":
 "protected theorem closed_embedding.noncompact_space [noncompact_space α] {f : α → β} (hf : closed_embedding f) :\n    noncompact_space β :=\n  noncompact_space_of_ne_bot hf.tendsto_cocompact.ne_bot\n#align closed_embedding.noncompact_space closed_embedding.noncompact_space\n\n",
 "nhds_contain_boxes_of_singleton":
 "theorem nhds_contain_boxes_of_singleton {x : α} {y : β} : nhds_contain_boxes ({x} : set α) ({y} : set β) :=\n  fun n hn hp =>\n  let ⟨u, v, uo, vo, xu, yv, hp'⟩ := is_open_prod_iff.mp hn x y (hp <| by simp)\n  ⟨u, v, uo, vo, by simpa, by simpa, hp'⟩\n#align nhds_contain_boxes_of_singleton nhds_contain_boxes_of_singleton\n\n",
 "nhds_contain_boxes_of_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem nhds_contain_boxes_of_compact {s : set α} (hs : is_compact s) (t : set β)\n    (H : ∀ x ∈ s, nhds_contain_boxes ({x} : set α) t) : nhds_contain_boxes s t := fun n hn hp =>\n  have :\n    ∀ x : s,\n      ∃ uv : set α × set β, is_open uv.1 ∧ is_open uv.2 ∧ {↑x} ⊆ uv.1 ∧ t ⊆ uv.2 ∧ lower_set.prod uv.1 uv.2 ⊆ n :=\n    fun ⟨x, hx⟩ =>\n    have : lower_set.prod ({x} : set α) t ⊆ n := Subset.trans (prod_mono (by simpa) Subset.rfl) hp\n    let ⟨ux, vx, H1⟩ := H x hx n hn this\n    ⟨⟨ux, vx⟩, H1⟩\n  let ⟨uvs, h⟩ := classical.axiom_of_choice this\n  have us_cover :\n    s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (uvs i).1 :=\n    fun x hx => subset_unionᵢ _ ⟨x, hx⟩ (by simpa using (h ⟨x, hx⟩).2.2.1)\n  let ⟨s0, s0_cover⟩ := hs.elim_finite_subcover _ (fun i => (h i).1) us_cover\n  let u := «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (uvs i).1\n  let v := «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (uvs i).2\n  have : is_open u := is_open_bUnion fun i _ => (h i).1\n  have : is_open v := is_open_bInter s0.finite_to_set fun i _ => (h i).2.1\n  have : t ⊆ v := subset_interᵢ₂ fun i _ => (h i).2.2.2.1\n  have : lower_set.prod u v ⊆ n := fun ⟨x', y'⟩ ⟨hx', hy'⟩ =>\n    have : ∃ i ∈ s0, x' ∈ (uvs i).1 := by simpa using hx'\n    let ⟨i, is0, hi⟩ := this\n    (h i).2.2.2.2 ⟨hi, (binterᵢ_subset_of_mem is0 : v ⊆ (uvs i).2) hy'⟩\n  ⟨u, v, ‹is_open u›, ‹is_open v›, s0_cover, ‹t ⊆ v›, ‹lower_set.prod u v ⊆ n›⟩\n#align nhds_contain_boxes_of_compact nhds_contain_boxes_of_compact\n\n",
 "ne_univ":
 "theorem is_compact.ne_univ [noncompact_space α] {s : set α} (hs : is_compact s) : s ≠ univ := fun h =>\n  noncompact_univ α (h ▸ hs)\n#align is_compact.ne_univ is_compact.ne_univ\n\n",
 "mem_irreducible_component":
 "theorem mem_irreducible_component {x : α} : x ∈ irreducible_component x :=\n  singleton_subset_iff.1 (irreducible_component_property x).2.1\n#align mem_irreducible_component mem_irreducible_component\n\n",
 "mem_iff_find_le":
 "theorem mem_iff_find_le {x : α} {n : ℕ} : x ∈ K n ↔ K.find x ≤ n :=\n  ⟨fun h => nat.find_min' (K.exists_mem x) h, fun h => K.subset h <| K.mem_find x⟩\n#align mem_iff_find_le mem_iff_find_le\n\n",
 "mem_find":
 "theorem mem_find (x : α) : x ∈ K (K.find x) :=\n  nat.find_spec (K.exists_mem x)\n#align mem_find mem_find\n\n",
 "mem_diff_shiftr_find":
 "theorem mem_diff_shiftr_find (x : α) : x ∈ K.shiftr (K.find x + 1) \\ K.shiftr (K.find x) :=\n  ⟨K.mem_find _, mt K.shiftr.mem_iff_find_le.1 <| by simp only [find_shiftr, not_le, nat.lt_succ_self]⟩\n#align mem_diff_shiftr_find mem_diff_shiftr_find\n\n",
 "mem_cocompact'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_cocompact' : s ∈ cocompact α ↔ ∃ t, is_compact t ∧ «expr ᶜ» s ⊆ t :=\n  mem_cocompact.trans <| exists_congr fun t => and_congr_right fun ht => compl_subset_comm\n#align mem_cocompact' mem_cocompact'\n\n",
 "mem_cocompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_cocompact : s ∈ cocompact α ↔ ∃ t, is_compact t ∧ «expr ᶜ» t ⊆ s :=\n  has_basis_cocompact.mem_iff.trans <| exists_congr fun t => exists_prop\n#align mem_cocompact mem_cocompact\n\n",
 "mem_coclosed_compact'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_coclosed_compact' : s ∈ coclosed_compact α ↔ ∃ t, is_closed t ∧ is_compact t ∧ «expr ᶜ» s ⊆ t := by\n  simp only [mem_coclosed_compact, compl_subset_comm]\n#align mem_coclosed_compact' mem_coclosed_compact'\n\n",
 "mem_coclosed_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_coclosed_compact : s ∈ coclosed_compact α ↔ ∃ t, is_closed t ∧ is_compact t ∧ «expr ᶜ» t ⊆ s := by\n  simp [has_basis_coclosed_compact.mem_iff, and_assoc']\n#align mem_coclosed_compact mem_coclosed_compact\n\n",
 "locally_compact_space_of_has_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem locally_compact_space_of_has_basis {ι : α → Type _} {p : ∀ x, ι x → Prop} {s : ∀ x, ι x → set α}\n    (h : ∀ x, ((nhds) x).has_basis (p x) (s x)) (hc : ∀ x i, p x i → is_compact (s x i)) : locally_compact_space α :=\n  ⟨fun x t ht =>\n    let ⟨i, hp, ht⟩ := (h x).mem_iff.1 ht\n    ⟨s x i, (h x).mem_of_mem hp, ht, hc x i hp⟩⟩\n#align locally_compact_space_of_has_basis locally_compact_space_of_has_basis\n\n",
 "locally_compact_space":
 "protected theorem is_open.locally_compact_space [locally_compact_space α] {s : set α} (hs : is_open s) :\n    locally_compact_space s :=\n  hs.open_embedding_subtype_coe.locally_compact_space\n#align is_open.locally_compact_space is_open.locally_compact_space\n\n",
 "local_compact_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem local_compact_nhds [locally_compact_space α] {x : α} {n : set α} (h : n ∈ (nhds) x) :\n    ∃ s ∈ (nhds) x, s ⊆ n ∧ is_compact s :=\n  locally_compact_space.local_compact_nhds _ _ h\n#align local_compact_nhds local_compact_nhds\n\n",
 "le_nhds_Lim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ultrafilter.le_nhds_Lim [compact_space α] (F : ultrafilter α) :\n    ↑F ≤ (nhds) (@Lim _ _ (F : filter α).nonempty_of_ne_bot F) :=\n  by\n  rcases is_compact_univ.ultrafilter_le_nhds F (by simp) with ⟨x, -, h⟩\n  exact le_nhds_Lim ⟨x, h⟩\n#align ultrafilter.le_nhds_Lim ultrafilter.le_nhds_Lim\n\n",
 "is_preirreducible_iff_closure":
 "theorem is_preirreducible_iff_closure {s : set α} : is_preirreducible (closure s) ↔ is_preirreducible s :=\n  forall₄_congr fun u v hu hv => by\n    iterate 3 rw [closure_inter_open_nonempty_iff]\n    exacts[hu.inter hv, hv, hu]\n#align is_preirreducible_iff_closure is_preirreducible_iff_closure\n\n",
 "is_preirreducible_iff_closed_union_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- A set is preirreducible if and only if\nfor every cover by two closed sets, it is contained in one of the two covering sets. -/\ntheorem is_preirreducible_iff_closed_union_closed {s : set α} :\n    is_preirreducible s ↔ ∀ z₁ z₂ : set α, is_closed z₁ → is_closed z₂ → s ⊆ z₁ ∪ z₂ → s ⊆ z₁ ∨ s ⊆ z₂ :=\n  by\n  constructor\n  all_goals\n    intro h t₁ t₂ ht₁ ht₂\n    specialize h («expr ᶜ» t₁) («expr ᶜ» t₂)\n    simp only [is_open_compl_iff, is_closed_compl_iff] at h\n    specialize h ht₁ ht₂\n  · contrapose!\n    simp only [not_subset]\n    rintro ⟨⟨x, hx, hx'⟩, ⟨y, hy, hy'⟩⟩\n    rcases h ⟨x, hx, hx'⟩ ⟨y, hy, hy'⟩ with ⟨z, hz, hz'⟩\n    rw [← compl_union] at hz'\n    exact ⟨z, hz, hz'⟩\n  · rintro ⟨x, hx, hx'⟩ ⟨y, hy, hy'⟩\n    rw [← compl_inter] at h\n    delta Set.Nonempty\n    rw [imp_iff_not_or] at h\n    contrapose! h\n    constructor\n    · intro z hz hz'\n      exact h z ⟨hz, hz'⟩\n    · constructor <;> intro H <;> refine' H _ ‹_› <;> assumption\n#align is_preirreducible_iff_closed_union_closed is_preirreducible_iff_closed_union_closed\n\n",
 "is_preirreducible_empty":
 "theorem is_preirreducible_empty : is_preirreducible (∅ : set α) := fun _ _ _ _ _ ⟨x, h1, h2⟩ => h1.elim\n#align is_preirreducible_empty is_preirreducible_empty\n\n",
 "is_preirreducible":
 "theorem set.subsingleton.is_preirreducible {s : set α} (hs : s.subsingleton) : is_preirreducible s :=\n  fun u v hu hv ⟨x, hxs, hxu⟩ ⟨y, hys, hyv⟩ => ⟨y, hys, hs hxs hys ▸ hxu, hyv⟩\n#align set.subsingleton.is_preirreducible set.subsingleton.is_preirreducible\n\n",
 "is_open":
 "protected theorem is_clopen.is_open (hs : is_clopen s) : is_open s :=\n  hs.1\n#align is_clopen.is_open is_clopen.is_open\n\n",
 "is_irreducible_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n-- see Note [lower instance priority]\ntheorem irreducible_space.is_irreducible_univ (α : Type u) [topological_space α] [irreducible_space α] :\n    is_irreducible («expr⊤» : set α) :=\n  ⟨by simp, preirreducible_space.is_preirreducible_univ α⟩\n#align irreducible_space.is_irreducible_univ irreducible_space.is_irreducible_univ\n\n",
 "is_irreducible_singleton":
 "theorem is_irreducible_singleton {x} : is_irreducible ({x} : set α) :=\n  ⟨singleton_nonempty x, subsingleton_singleton.is_preirreducible⟩\n#align is_irreducible_singleton is_irreducible_singleton\n\n",
 "is_irreducible_irreducible_component":
 "theorem is_irreducible_irreducible_component {x : α} : is_irreducible (irreducible_component x) :=\n  ⟨⟨x, mem_irreducible_component⟩, (irreducible_component_property x).1⟩\n#align is_irreducible_irreducible_component is_irreducible_irreducible_component\n\n",
 "is_irreducible_iff_sUnion_closed":
 "/-- A set is irreducible if and only if\nfor every cover by a finite collection of closed sets,\nit is contained in one of the members of the collection. -/\ntheorem is_irreducible_iff_sUnion_closed {s : set α} :\n    is_irreducible s ↔ ∀ (Z : Finset (set α)) (hZ : ∀ z ∈ Z, is_closed z) (H : s ⊆ ⋃₀ ↑Z), ∃ z ∈ Z, s ⊆ z :=\n  by\n  rw [is_irreducible, is_preirreducible_iff_closed_union_closed]\n  constructor <;> intro h\n  · intro Z\n    apply Finset.induction_on Z\n    · intros\n      rw [Finset.coe_empty, sUnion_empty] at H\n      rcases h.1 with ⟨x, hx⟩\n      exfalso\n      tauto\n    · intro z Z hz IH hZ H\n      cases' h.2 z (⋃₀ ↑Z) _ _ _ with h' h'\n      · exact ⟨z, Finset.mem_insert_self _ _, h'⟩\n      · rcases IH _ h' with ⟨z', hz', hsz'⟩\n        · exact ⟨z', Finset.mem_insert_of_mem hz', hsz'⟩\n        · intros\n          solve_by_elim [Finset.mem_insert_of_mem]\n      · solve_by_elim [Finset.mem_insert_self]\n      · rw [sUnion_eq_bUnion]\n        apply is_closed_bUnion (finset.finite_to_set Z)\n        · intros\n          solve_by_elim [Finset.mem_insert_of_mem]\n      · simpa using H\n  · constructor\n    · by_contra hs\n      simpa using h ∅ _ _\n      · intro z\n        simp\n      · simpa [Set.Nonempty] using hs\n    intro z₁ z₂ hz₁ hz₂ H\n    have := h {z₁, z₂} _ _\n    simp only [exists_prop, Finset.mem_insert, Finset.mem_singleton] at this\n    · rcases this with ⟨z, rfl | rfl, hz⟩ <;> tauto\n    · intro t\n      rw [Finset.mem_insert, Finset.mem_singleton]\n      rintro (rfl | rfl) <;> assumption\n    · simpa using H\n#align is_irreducible_iff_sUnion_closed is_irreducible_iff_sUnion_closed\n\n",
 "is_irreducible_iff_sInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/-- A set `s` is irreducible if and only if\nfor every finite collection of open sets all of whose members intersect `s`,\n`s` also intersects the intersection of the entire collection\n(i.e., there is an element of `s` contained in every member of the collection). -/\ntheorem is_irreducible_iff_sInter {s : set α} :\n    is_irreducible s ↔\n      ∀ (U : Finset (set α)) (hU : ∀ u ∈ U, is_open u) (H : ∀ u ∈ U, (s ∩ u).nonempty), (s ∩ «expr⋂₀ » ↑U).nonempty :=\n  by\n  constructor <;> intro h\n  · intro U\n    apply Finset.induction_on U\n    · intros\n      simpa using h.nonempty\n    · intro u U hu IH hU H\n      rw [Finset.coe_insert, sInter_insert]\n      apply h.2\n      · solve_by_elim [Finset.mem_insert_self]\n      · apply is_open_sInter (finset.finite_to_set U)\n        intros\n        solve_by_elim [Finset.mem_insert_of_mem]\n      · solve_by_elim [Finset.mem_insert_self]\n      · apply IH\n        all_goals intros ; solve_by_elim [Finset.mem_insert_of_mem]\n  · constructor\n    · simpa using h ∅ _ _ <;> intro u <;> simp\n    intro u v hu hv hu' hv'\n    simpa using h {u, v} _ _\n    all_goals\n      intro t\n      rw [Finset.mem_insert, Finset.mem_singleton]\n      rintro (rfl | rfl) <;> assumption\n#align is_irreducible_iff_sInter is_irreducible_iff_sInter\n\n",
 "is_irreducible_iff_closure":
 "theorem is_irreducible_iff_closure {s : set α} : is_irreducible (closure s) ↔ is_irreducible s :=\n  and_congr closure_nonempty_iff is_preirreducible_iff_closure\n#align is_irreducible_iff_closure is_irreducible_iff_closure\n\n",
 "is_compact_univ_pi":
 "/-- **Tychonoff's theorem** formulated using `set.pi`: product of compact sets is compact. -/\ntheorem is_compact_univ_pi {s : ∀ i, set (π i)} (h : ∀ i, is_compact (s i)) : is_compact (pi univ s) :=\n  by\n  convert is_compact_pi_infinite h\n  simp only [← mem_univ_pi, set_of_mem_eq]\n#align is_compact_univ_pi is_compact_univ_pi\n\n",
 "is_compact_univ_iff":
 "-- see Note [lower instance priority]\ntheorem is_compact_univ_iff : is_compact (univ : set α) ↔ compact_space α :=\n  ⟨fun h => ⟨h⟩, fun h => h.1⟩\n#align is_compact_univ_iff is_compact_univ_iff\n\n",
 "is_compact_univ":
 "theorem is_compact_univ [h : compact_space α] : is_compact (univ : set α) :=\n  h.is_compact_univ\n#align is_compact_univ is_compact_univ\n\n",
 "is_compact_singleton":
 "@[simp]\ntheorem is_compact_singleton {a : α} : is_compact ({a} : set α) := fun f hf hfa =>\n  ⟨a, rfl, cluster_pt.of_le_nhds' (hfa.trans <| by simpa only [principal_singleton] using pure_le_nhds a) hf⟩\n#align is_compact_singleton is_compact_singleton\n\n",
 "is_compact_range":
 "theorem is_compact_range [compact_space α] {f : α → β} (hf : continuous f) : is_compact (range f) := by\n  rw [← image_univ] <;> exact is_compact_univ.image hf\n#align is_compact_range is_compact_range\n\n",
 "is_compact_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- The preimage of a compact set under a closed embedding is a compact set. -/\ntheorem closed_embedding.is_compact_preimage {f : α → β} (hf : closed_embedding f) {K : set β} (hK : is_compact K) :\n    is_compact («expr ⁻¹' » f K) := by\n  replace hK := hK.inter_right hf.closed_range\n  rwa [← hf.to_inducing.is_compact_iff, image_preimage_eq_inter_range]\n#align closed_embedding.is_compact_preimage closed_embedding.is_compact_preimage\n\n",
 "is_compact_pi_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n-- See Note [lower instance priority]\n-- See Note [lower instance priority]\n/-- **Tychonoff's theorem**: product of compact sets is compact. -/\ntheorem is_compact_pi_infinite {s : ∀ i, set (π i)} :\n    (∀ i, is_compact (s i)) → is_compact { x : ∀ i, π i | ∀ i, x i ∈ s i } :=\n  by\n  simp only [is_compact_iff_ultrafilter_le_nhds, nhds_pi, filter.pi, exists_prop, mem_set_of_eq, le_infᵢ_iff,\n    le_principal_iff]\n  intro h f hfs\n  have : ∀ i : ι, ∃ a, a ∈ s i ∧ tendsto (fun x : ∀ i : ι, π i => x i) f ((nhds) a) :=\n    by\n    refine' fun i => h i (f.map _) (mem_map.2 _)\n    exact mem_of_superset hfs fun x hx => hx i\n  choose a ha\n  exact ⟨a, fun i => (ha i).left, fun i => (ha i).right.le_comap⟩\n#align is_compact_pi_infinite is_compact_pi_infinite\n\n",
 "is_compact_open_iff_eq_finite_Union_of_is_topological_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- If `α` has a basis consisting of compact opens, then an open set in `α` is compact open iff\n  it is a finite union of some elements in the basis -/\ntheorem is_compact_open_iff_eq_finite_Union_of_is_topological_basis (b : ι → set α)\n    (hb : is_topological_basis (Set.range b)) (hb' : ∀ i, is_compact (b i)) (U : set α) :\n    is_compact U ∧ is_open U ↔\n      ∃ s : set ι,\n        s.finite ∧\n          U = «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (b i) :=\n  by\n  classical\n    constructor\n    · rintro ⟨h₁, h₂⟩\n      obtain ⟨β, f, e, hf⟩ := hb.open_eq_Union h₂\n      choose f' hf' using hf\n      have : b ∘ f' = f := funext hf'\n      subst this\n      obtain ⟨t, ht⟩ := h₁.elim_finite_subcover (b ∘ f') (fun i => hb.is_open (Set.mem_range_self _)) (by rw [e])\n      refine' ⟨t.image f', set.finite.intro infer_instance, le_antisymm _ _⟩\n      · refine' Set.Subset.trans ht _\n        simp only [Set.unionᵢ_subset_iff, coe_coe]\n        intro i hi\n        erw [← Set.unionᵢ_subtype (fun x : ι => x ∈ t.image f') fun i => b i.1]\n        exact Set.subset_unionᵢ (fun i : t.image f' => b i) ⟨_, Finset.mem_image_of_mem _ hi⟩\n      · apply Set.unionᵢ₂_subset\n        rintro i hi\n        obtain ⟨j, hj, rfl⟩ := finset.mem_image.mp hi\n        rw [e]\n        exact Set.subset_unionᵢ (b ∘ f') j\n    · rintro ⟨s, hs, rfl⟩\n      constructor\n      · exact hs.is_compact_bUnion fun i _ => hb' i\n      · apply is_open_bUnion\n        intro i hi\n        exact hb.is_open (Set.mem_range_self _)\n#align\n  is_compact_open_iff_eq_finite_Union_of_is_topological_basis is_compact_open_iff_eq_finite_Union_of_is_topological_basis\n\n",
 "is_compact_of_is_closed_subset":
 "/-- A closed subset of a compact set is a compact set. -/\ntheorem is_compact_of_is_closed_subset (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t :=\n  inter_eq_self_of_subset_right h ▸ hs.inter_right ht\n#align is_compact_of_is_closed_subset is_compact_of_is_closed_subset\n\n",
 "is_compact_of_finite_subfamily_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- A set `s` is compact if for every family of closed sets whose intersection avoids `s`,\nthere exists a finite subfamily whose intersection avoids `s`. -/\ntheorem is_compact_of_finite_subfamily_closed\n    (h :\n      ∀ {ι : Type u} (Z : ι → set α),\n        (∀ i, is_closed (Z i)) →\n          s ∩ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i) =\n              ∅ →\n            ∃ t : Finset ι,\n              s ∩\n                  «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n                    (Z i) =\n                ∅) :\n    is_compact s := fun f hfn hfs =>\n  by_contradiction fun this : ¬∃ x ∈ s, cluster_pt x f =>\n    have hf : ∀ x ∈ s, «expr ⊓ » ((nhds) x) f = «expr⊥» := by simpa only [cluster_pt, not_exists, not_not, ne_bot_iff]\n    have : ¬∃ x ∈ s, ∀ t ∈ f.sets, x ∈ closure t := fun ⟨x, hxs, hx⟩ =>\n      by\n      have : ∅ ∈ «expr ⊓ » ((nhds) x) f := by rw [empty_mem_iff_bot, hf x hxs]\n      let ⟨t₁, ht₁, t₂, ht₂, ht⟩ := by rw [mem_inf_iff] at this <;> exact this\n      have : ∅ ∈ nhds_within t₂ x := by\n        rw [ht, inter_comm]\n        exact inter_mem_nhds_within _ ht₁\n      have : nhds_within t₂ x = «expr⊥» := by rwa [empty_mem_iff_bot] at this\n      simp only [closure_eq_cluster_pts] at hx <;> exact (hx t₂ ht₂).ne this\n    let ⟨t, ht⟩ :=\n      h (fun i : f.sets => closure i.1) (fun i => is_closed_closure)\n        (by simpa [eq_empty_iff_forall_not_mem, not_exists] )\n    have :\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (subtype.val i) ∈\n        f :=\n      t.Inter_mem_sets.2 fun i hi => i.2\n    have :\n      s ∩\n          «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n            (subtype.val i) ∈\n        f :=\n      inter_mem (le_principal_iff.1 hfs) this\n    have : ∅ ∈ f :=\n      mem_of_superset this fun x ⟨hxs, hx⟩ =>\n        let ⟨i, hit, hxi⟩ :=\n          show ∃ i ∈ t, x ∉ closure (subtype.val i)\n            by\n            rw [eq_empty_iff_forall_not_mem] at ht\n            simpa [hxs, not_forall] using ht x\n        have : x ∈ closure i.val :=\n          subset_closure\n            (by\n              rw [mem_Inter₂] at hx\n              exact hx i hit)\n        show false from hxi this\n    hfn.ne <| by rwa [empty_mem_iff_bot] at this\n#align is_compact_of_finite_subfamily_closed is_compact_of_finite_subfamily_closed\n\n",
 "is_compact_of_finite_subcover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A set `s` is compact if for every open cover of `s`, there exists a finite subcover. -/\ntheorem is_compact_of_finite_subcover\n    (h :\n      ∀ {ι : Type u} (U : ι → set α),\n        (∀ i, is_open (U i)) →\n          s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i) →\n            ∃ t : Finset ι,\n              s ⊆\n                «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i)) :\n    is_compact s :=\n  is_compact_of_finite_subfamily_closed fun ι Z hZc hsZ =>\n    let ⟨t, ht⟩ :=\n      h (fun i => «expr ᶜ» (Z i)) (fun i => is_open_compl_iff.mpr <| hZc i)\n        (by\n          simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_Union, exists_prop, mem_inter_iff,\n            not_and, iff_self_iff, mem_Inter, mem_compl_iff] using hsZ)\n    ⟨t, by\n      simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_Union, exists_prop, mem_inter_iff, not_and,\n        iff_self_iff, mem_Inter, mem_compl_iff] using ht⟩\n#align is_compact_of_finite_subcover is_compact_of_finite_subcover\n\n",
 "is_compact_insert_range_of_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto.is_compact_insert_range_of_cofinite {f : ι → α} {a} (hf : tendsto f cofinite ((nhds) a)) :\n    is_compact (insert a (range f)) := by\n  letI : topological_space ι := «expr⊥»; haveI : discrete_topology ι := ⟨rfl⟩\n  rw [← cocompact_eq_cofinite] at hf\n  exact hf.is_compact_insert_range_of_cocompact continuous_of_discrete_topology\n#align tendsto.is_compact_insert_range_of_cofinite tendsto.is_compact_insert_range_of_cofinite\n\n",
 "is_compact_insert_range_of_cocompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto.is_compact_insert_range_of_cocompact {f : α → β} {b} (hf : tendsto f (cocompact α) ((nhds) b))\n    (hfc : continuous f) : is_compact (insert b (range f)) :=\n  by\n  intro l hne hle\n  by_cases hb : cluster_pt b l\n  · exact ⟨b, or.inl rfl, hb⟩\n  simp only [cluster_pt_iff, not_forall, ← not_disjoint_iff_nonempty_inter, not_not] at hb\n  rcases hb with ⟨s, hsb, t, htl, hd⟩\n  rcases mem_cocompact.1 (hf hsb) with ⟨K, hKc, hKs⟩\n  have : «expr '' » f K ∈ l := by\n    filter_upwards [htl, le_principal_iff.1 hle] with y hyt hyf\n    rcases hyf with (rfl | ⟨x, rfl⟩)\n    exacts[(hd.le_bot ⟨mem_of_mem_nhds hsb, hyt⟩).elim,\n      mem_image_of_mem _ (not_not.1 fun hxK => hd.le_bot ⟨hKs hxK, hyt⟩)]\n  rcases hKc.image hfc (le_principal_iff.2 this) with ⟨y, hy, hyl⟩\n  exact ⟨y, or.inr <| image_subset_range _ _ hy, hyl⟩\n#align tendsto.is_compact_insert_range_of_cocompact tendsto.is_compact_insert_range_of_cocompact\n\n",
 "is_compact_insert_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto.is_compact_insert_range {f : ℕ → α} {a} (hf : tendsto f at_top ((nhds) a)) :\n    is_compact (insert a (range f)) :=\n  filter.tendsto.is_compact_insert_range_of_cofinite <| nat.cofinite_eq_at_top.symm ▸ hf\n#align tendsto.is_compact_insert_range tendsto.is_compact_insert_range\n\n",
 "is_compact_iff_ultrafilter_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_compact_iff_ultrafilter_le_nhds :\n    is_compact s ↔ ∀ f : ultrafilter α, ↑f ≤ (filter.principal) s → ∃ a ∈ s, ↑f ≤ (nhds) a :=\n  by\n  refine' (forall_ne_bot_le_iff _).trans _\n  · rintro f g hle ⟨a, has, haf⟩\n    exact ⟨a, has, haf.mono hle⟩\n  · simp only [ultrafilter.cluster_pt_iff]\n#align is_compact_iff_ultrafilter_le_nhds is_compact_iff_ultrafilter_le_nhds\n\n",
 "is_compact_iff_is_compact_univ":
 "theorem is_compact_iff_is_compact_univ {s : set α} : is_compact s ↔ is_compact (univ : set s) := by\n  rw [is_compact_iff_is_compact_in_subtype, image_univ, Subtype.range_coe] <;> rfl\n#align is_compact_iff_is_compact_univ is_compact_iff_is_compact_univ\n\n",
 "is_compact_iff_is_compact_in_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact_iff_is_compact_in_subtype {p : α → Prop} {s : set { a // p a }} :\n    is_compact s ↔ is_compact («expr '' » (coe : _ → α) s) :=\n  embedding_subtype_coe.is_compact_iff_is_compact_image\n#align is_compact_iff_is_compact_in_subtype is_compact_iff_is_compact_in_subtype\n\n",
 "is_compact_iff_is_compact_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If `f : α → β` is an `embedding` (or more generally, an `inducing` map, see\n`inducing.is_compact_iff`), then the image `f '' s` of a set `s` is compact if and only if the set\n`s` is closed. -/\ntheorem embedding.is_compact_iff_is_compact_image {f : α → β} (hf : embedding f) :\n    is_compact s ↔ is_compact («expr '' » f s) :=\n  hf.to_inducing.is_compact_iff.symm\n#align embedding.is_compact_iff_is_compact_image embedding.is_compact_iff_is_compact_image\n\n",
 "is_compact_iff_finite_subfamily_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- A set `s` is compact if and only if\nfor every family of closed sets whose intersection avoids `s`,\nthere exists a finite subfamily whose intersection avoids `s`. -/\ntheorem is_compact_iff_finite_subfamily_closed :\n    is_compact s ↔\n      ∀ {ι : Type u} (Z : ι → set α),\n        (∀ i, is_closed (Z i)) →\n          s ∩ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i) =\n              ∅ →\n            ∃ t : Finset ι,\n              s ∩\n                  «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n                    (Z i) =\n                ∅ :=\n  ⟨fun hs ι => hs.elim_finite_subfamily_closed, is_compact_of_finite_subfamily_closed⟩\n#align is_compact_iff_finite_subfamily_closed is_compact_iff_finite_subfamily_closed\n\n",
 "is_compact_iff_finite_subcover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A set `s` is compact if and only if\nfor every open cover of `s`, there exists a finite subcover. -/\ntheorem is_compact_iff_finite_subcover :\n    is_compact s ↔\n      ∀ {ι : Type u} (U : ι → set α),\n        (∀ i, is_open (U i)) →\n          s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i) →\n            ∃ t : Finset ι,\n              s ⊆\n                «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i) :=\n  ⟨fun hs ι => hs.elim_finite_subcover, is_compact_of_finite_subcover⟩\n#align is_compact_iff_finite_subcover is_compact_iff_finite_subcover\n\n",
 "is_compact_iff_finite":
 "theorem is_compact_iff_finite [discrete_topology α] {s : set α} : is_compact s ↔ s.finite :=\n  ⟨fun h => h.finite_of_discrete, fun h => h.is_compact⟩\n#align is_compact_iff_finite is_compact_iff_finite\n\n",
 "is_compact_iff_compact_space":
 "theorem is_compact_iff_compact_space {s : set α} : is_compact s ↔ compact_space s :=\n  is_compact_iff_is_compact_univ.trans ⟨fun h => ⟨h⟩, @compact_space.is_compact_univ _ _⟩\n#align is_compact_iff_compact_space is_compact_iff_compact_space\n\n",
 "is_compact_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If `f : α → β` is an `inducing` map, then the image `f '' s` of a set `s` is compact if and only\nif the set `s` is closed. -/\ntheorem inducing.is_compact_iff {f : α → β} (hf : inducing f) {s : set α} :\n    is_compact («expr '' » f s) ↔ is_compact s :=\n  by\n  refine' ⟨_, fun hs => hs.image hf.continuous⟩\n  intro hs F F_ne_bot F_le\n  obtain ⟨_, ⟨x, x_in : x ∈ s, rfl⟩, hx : cluster_pt (f x) (map f F)⟩ :=\n    hs\n      (calc\n        map f F ≤ map f ((filter.principal) s) := map_mono F_le\n        _ = (filter.principal) («expr '' » f s) := map_principal\n        )\n  use x, x_in\n  suffices (map f («expr ⊓ » ((nhds) x) F)).ne_bot by simpa [filter.map_ne_bot_iff]\n  rwa [calc\n      map f («expr ⊓ » ((nhds) x) F) = map f («expr ⊓ » (comap f <| nhds <| f x) F) := by rw [hf.nhds_eq_comap]\n      _ = «expr ⊓ » ((nhds) (f x)) (map f F) := filter.push_pull' _ _ _\n      ]\n#align inducing.is_compact_iff inducing.is_compact_iff\n\n",
 "is_compact_empty":
 "@[simp]\ntheorem is_compact_empty : is_compact (∅ : set α) := fun f hnf hsf =>\n  not.elim hnf.ne <| empty_mem_iff_bot.1 <| le_principal_iff.1 hsf\n#align is_compact_empty is_compact_empty\n\n",
 "is_compact_diagonal":
 "theorem is_compact_diagonal [compact_space α] : is_compact (diagonal α) :=\n  @range_diag α ▸ is_compact_range (continuous_id.prod_mk continuous_id)\n#align is_compact_diagonal is_compact_diagonal\n\n",
 "is_compact_compact_covering":
 "-- see Note [lower instance priority]\ntheorem is_compact_compact_covering (n : ℕ) : is_compact (compact_covering α n) :=\n  is_compact_accumulate (Classical.choose_spec sigma_compact_space.exists_compact_covering).1 n\n#align is_compact_compact_covering is_compact_compact_covering\n\n",
 "is_compact_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem finset.is_compact_bUnion (s : Finset ι) {f : ι → set α} (hf : ∀ i ∈ s, is_compact (f i)) :\n    is_compact\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  s.finite_to_set.is_compact_bUnion hf\n#align finset.is_compact_bUnion finset.is_compact_bUnion\n\n",
 "is_compact_accumulate":
 "theorem is_compact_accumulate {K : ℕ → set α} (hK : ∀ n, is_compact (K n)) (n : ℕ) : is_compact (Accumulate K n) :=\n  (finite_le_nat n).is_compact_bUnion fun k _ => hK k\n#align is_compact_accumulate is_compact_accumulate\n\n",
 "is_compact_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_compact_Union {f : ι → set α} [Finite ι] (h : ∀ i, is_compact (f i)) :\n    is_compact\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  by rw [← bUnion_univ] <;> exact finite_univ.is_compact_bUnion fun i _ => h i\n#align is_compact_Union is_compact_Union\n\n",
 "is_compact":
 "protected theorem is_compact (n : ℕ) : is_compact (K n) :=\n  K.is_compact' n\n#align is_compact is_compact\n\n",
 "is_closed_proj_of_is_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/-- If X is is_compact then pr₂ : X × Y → Y is a closed map -/\ntheorem is_closed_proj_of_is_compact {X : Type _} [topological_space X] [compact_space X] {Y : Type _}\n    [topological_space Y] : is_closed_map (prod.snd : X × Y → Y) :=\n  by\n  set πX := (prod.fst : X × Y → X)\n  set πY := (prod.snd : X × Y → Y)\n  intro C(hC : is_closed C)\n  rw [is_closed_iff_cluster_pt] at hC⊢\n  intro y(y_closure : cluster_pt y <| (filter.principal) («expr '' » πY C))\n  have : ne_bot (map πX («expr ⊓ » (comap πY ((nhds) y)) ((filter.principal) C))) :=\n    by\n    suffices ne_bot (map πY («expr ⊓ » (comap πY ((nhds) y)) ((filter.principal) C))) by simpa only [map_ne_bot_iff]\n    convert y_closure\n    calc\n      map πY («expr ⊓ » (comap πY ((nhds) y)) ((filter.principal) C)) =\n          «expr ⊓ » ((nhds) y) (map πY ((filter.principal) C)) :=\n        filter.push_pull' _ _ _\n      _ = «expr ⊓ » ((nhds) y) ((filter.principal) («expr '' » πY C)) := by rw [map_principal]\n      \n  obtain ⟨x, hx⟩ : ∃ x, cluster_pt x (map πX («expr ⊓ » (comap πY ((nhds) y)) ((filter.principal) C)))\n  exact cluster_point_of_compact _\n  refine' ⟨⟨x, y⟩, _, by simp [πY]⟩\n  apply hC\n  rw [cluster_pt, ← filter.map_ne_bot_iff πX]\n  convert hx\n  calc\n    map πX («expr ⊓ » ((nhds) (x, y)) ((filter.principal) C)) =\n        map πX («expr ⊓ » («expr ⊓ » (comap πX ((nhds) x)) (comap πY ((nhds) y))) ((filter.principal) C)) :=\n      by rw [nhds_prod_eq, filter.prod]\n    _ = map πX («expr ⊓ » («expr ⊓ » (comap πY ((nhds) y)) ((filter.principal) C)) (comap πX ((nhds) x))) := by ac_rfl\n    _ = «expr ⊓ » (map πX («expr ⊓ » (comap πY ((nhds) y)) ((filter.principal) C))) ((nhds) x) := by\n      rw [filter.push_pull]\n    _ = «expr ⊓ » ((nhds) x) (map πX («expr ⊓ » (comap πY ((nhds) y)) ((filter.principal) C))) := by rw [inf_comm]\n    \n#align is_closed_proj_of_is_compact is_closed_proj_of_is_compact\n\n",
 "is_closed_of_mem_irreducible_components":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (s «expr ∈ » irreducible_components[irreducible_components] α) -/\ntheorem is_closed_of_mem_irreducible_components (s) (_ : s ∈ irreducible_components α) : is_closed s :=\n  by\n  rw [← closure_eq_iff_is_closed, eq_comm]\n  exact subset_closure.antisymm (H.2 H.1.closure subset_closure)\n#align is_closed_of_mem_irreducible_components is_closed_of_mem_irreducible_components\n\n",
 "is_closed_irreducible_component":
 "theorem is_closed_irreducible_component {x : α} : is_closed (irreducible_component x) :=\n  is_closed_of_mem_irreducible_components _ (irreducible_component_mem_irreducible_components x)\n#align is_closed_irreducible_component is_closed_irreducible_component\n\n",
 "is_closed":
 "protected theorem is_clopen.is_closed (hs : is_clopen s) : is_closed s :=\n  hs.2\n#align is_clopen.is_closed is_clopen.is_closed\n\n",
 "is_clopen_univ":
 "@[simp]\ntheorem is_clopen_univ : is_clopen (univ : set α) :=\n  ⟨is_open_univ, is_closed_univ⟩\n#align is_clopen_univ is_clopen_univ\n\n",
 "is_clopen_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem quotient_map.is_clopen_preimage {f : α → β} (hf : quotient_map f) {s : set β} :\n    is_clopen («expr ⁻¹' » f s) ↔ is_clopen s :=\n  and_congr hf.is_open_preimage hf.is_closed_preimage\n#align quotient_map.is_clopen_preimage quotient_map.is_clopen_preimage\n\n",
 "is_clopen_inter_of_disjoint_cover_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem is_clopen_inter_of_disjoint_cover_clopen {Z a b : set α} (h : is_clopen Z) (cover : Z ⊆ a ∪ b) (ha : is_open a)\n    (hb : is_open b) (hab : Disjoint a b) : is_clopen (Z ∩ a) :=\n  by\n  refine' ⟨is_open.inter h.1 ha, _⟩\n  have : is_closed (Z ∩ «expr ᶜ» b) := is_closed.inter h.2 (is_closed_compl_iff.2 hb)\n  convert this using 1\n  refine' (inter_subset_inter_right Z hab.subset_compl_right).antisymm _\n  rintro x ⟨hx₁, hx₂⟩\n  exact ⟨hx₁, by simpa [not_mem_of_mem_compl hx₂] using cover hx₁⟩\n#align is_clopen_inter_of_disjoint_cover_clopen is_clopen_inter_of_disjoint_cover_clopen\n\n",
 "is_clopen_iff_frontier_eq_empty":
 "theorem is_clopen_iff_frontier_eq_empty {s : set α} : is_clopen s ↔ frontier s = ∅ :=\n  by\n  rw [is_clopen, ← closure_eq_iff_is_closed, ← interior_eq_iff_is_open, frontier, diff_eq_empty]\n  refine' ⟨fun h => (h.2.trans h.1.symm).subset, fun h => _⟩\n  exact ⟨interior_subset.antisymm (subset_closure.trans h), (h.trans interior_subset).antisymm subset_closure⟩\n#align is_clopen_iff_frontier_eq_empty is_clopen_iff_frontier_eq_empty\n\n",
 "is_clopen_empty":
 "@[simp]\ntheorem is_clopen_empty : is_clopen (∅ : set α) :=\n  ⟨is_open_empty, is_closed_empty⟩\n#align is_clopen_empty is_clopen_empty\n\n",
 "is_clopen_discrete":
 "@[simp]\ntheorem is_clopen_discrete [discrete_topology α] (x : set α) : is_clopen x :=\n  ⟨is_open_discrete _, is_closed_discrete _⟩\n#align is_clopen_discrete is_clopen_discrete\n\n",
 "is_clopen_compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem is_clopen_compl_iff {s : set α} : is_clopen («expr ᶜ» s) ↔ is_clopen s :=\n  ⟨fun h => compl_compl s ▸ is_clopen.compl h, is_clopen.compl⟩\n#align is_clopen_compl_iff is_clopen_compl_iff\n\n",
 "is_clopen_bUnion_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_clopen_bUnion_finset {β : Type _} {s : Finset β} {f : β → set α} (h : ∀ i ∈ s, is_clopen <| f i) :\n    is_clopen («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  is_clopen_bUnion s.finite_to_set h\n#align is_clopen_bUnion_finset is_clopen_bUnion_finset\n\n",
 "is_clopen_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_clopen_bUnion {β : Type _} {s : set β} {f : β → set α} (hs : s.finite) (h : ∀ i ∈ s, is_clopen <| f i) :\n    is_clopen («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  ⟨is_open_bUnion fun i hi => (h i hi).1, is_closed_bUnion hs fun i hi => (h i hi).2⟩\n#align is_clopen_bUnion is_clopen_bUnion\n\n",
 "is_clopen_bInter_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem is_clopen_bInter_finset {β : Type _} {s : Finset β} {f : β → set α} (h : ∀ i ∈ s, is_clopen (f i)) :\n    is_clopen («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  is_clopen_bInter s.finite_to_set h\n#align is_clopen_bInter_finset is_clopen_bInter_finset\n\n",
 "is_clopen_bInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem is_clopen_bInter {β : Type _} {s : set β} (hs : s.finite) {f : β → set α} (h : ∀ i ∈ s, is_clopen (f i)) :\n    is_clopen («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  ⟨is_open_bInter hs fun i hi => (h i hi).1, is_closed_bInter fun i hi => (h i hi).2⟩\n#align is_clopen_bInter is_clopen_bInter\n\n",
 "is_clopen_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_clopen_Union {β : Type _} [Finite β] {s : β → set α} (h : ∀ i, is_clopen (s i)) :\n    is_clopen («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  ⟨is_open_Union (forall_and.1 h).1, is_closed_Union (forall_and.1 h).2⟩\n#align is_clopen_Union is_clopen_Union\n\n",
 "is_clopen_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem is_clopen_Inter {β : Type _} [Finite β] {s : β → set α} (h : ∀ i, is_clopen (s i)) :\n    is_clopen («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)) :=\n  ⟨is_open_Inter (forall_and.1 h).1, is_closed_Inter (forall_and.1 h).2⟩\n#align is_clopen_Inter is_clopen_Inter\n\n",
 "is_bounded_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem in_compact.is_bounded_iff : @is_bounded _ (in_compact α) s ↔ ∃ t, is_compact t ∧ s ⊆ t :=\n  by\n  change «expr ᶜ» s ∈ filter.cocompact α ↔ _\n  rw [filter.mem_cocompact]\n  simp\n#align in_compact.is_bounded_iff in_compact.is_bounded_iff\n\n",
 "irreducible_space_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem irreducible_space_def (α : Type u) [topological_space α] :\n    irreducible_space α ↔ is_irreducible («expr⊤» : set α) :=\n  ⟨@irreducible_space.is_irreducible_univ α _, fun h =>\n    haveI : preirreducible_space α := ⟨h.2⟩\n    ⟨⟨h.1.some⟩⟩⟩\n#align irreducible_space_def irreducible_space_def\n\n",
 "irreducible_space":
 "theorem subtype.irreducible_space {s : set α} (h : is_irreducible s) : irreducible_space s :=\n  { is_preirreducible_univ := (subtype.preirreducible_space h.is_preirreducible).is_preirreducible_univ\n    to_nonempty := h.nonempty.to_subtype }\n#align subtype.irreducible_space subtype.irreducible_space\n\n",
 "irreducible_components_eq_maximals_closed":
 "theorem irreducible_components_eq_maximals_closed (α : Type _) [topological_space α] :\n    irreducible_components α = maximals (· ≤ ·) { s : set α | is_closed s ∧ is_irreducible s } :=\n  by\n  ext s\n  constructor\n  · intro H\n    exact ⟨⟨is_closed_of_mem_irreducible_components _ H, H.1⟩, fun x h e => H.2 h.2 e⟩\n  · intro H\n    refine' ⟨H.1.2, fun x h e => _⟩\n    have : closure x ≤ s := H.2 ⟨is_closed_closure, h.closure⟩ (e.trans subset_closure)\n    exact le_trans subset_closure this\n#align irreducible_components_eq_maximals_closed irreducible_components_eq_maximals_closed\n\n",
 "irreducible_component_property":
 "theorem irreducible_component_property (x : α) :\n    is_preirreducible (irreducible_component x) ∧\n      {x} ⊆ irreducible_component x ∧\n        ∀ u, is_preirreducible u → irreducible_component x ⊆ u → u = irreducible_component x :=\n  Classical.choose_spec (exists_preirreducible {x} is_irreducible_singleton.is_preirreducible)\n#align irreducible_component_property irreducible_component_property\n\n",
 "irreducible_component_mem_irreducible_components":
 "theorem irreducible_component_mem_irreducible_components (x : α) : irreducible_component x ∈ irreducible_components α :=\n  ⟨is_irreducible_irreducible_component, fun s h₁ h₂ => (eq_irreducible_component h₁.2 h₂).le⟩\n#align irreducible_component_mem_irreducible_components irreducible_component_mem_irreducible_components\n\n",
 "interior":
 "theorem is_preirreducible.interior {Z : set α} (hZ : is_preirreducible Z) : is_preirreducible (interior Z) :=\n  hZ.open_subset is_open_interior interior_subset\n#align is_preirreducible.interior is_preirreducible.interior\n\n",
 "inter_right":
 "/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem is_compact.inter_right (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t) :=\n  by\n  intro f hnf hstf\n  obtain ⟨a, hsa, ha⟩ : ∃ a ∈ s, cluster_pt a f := hs (le_trans hstf (le_principal_iff.2 (inter_subset_left _ _)))\n  have : a ∈ t := ht.mem_of_nhds_within_ne_bot <| ha.mono <| le_trans hstf (le_principal_iff.2 (inter_subset_right _ _))\n  exact ⟨a, ⟨hsa, this⟩, ha⟩\n#align is_compact.inter_right is_compact.inter_right\n\n",
 "inter_left":
 "/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem is_compact.inter_left (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t) :=\n  inter_comm t s ▸ ht.inter_right hs\n#align is_compact.inter_left is_compact.inter_left\n\n",
 "inter_Inter_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- To show that a compact set intersects the intersection of a family of closed sets,\n  it is sufficient to show that it intersects every finite subfamily. -/\ntheorem is_compact.inter_Inter_nonempty {s : set α} {ι : Type v} (hs : is_compact s) (Z : ι → set α)\n    (hZc : ∀ i, is_closed (Z i))\n    (hsZ :\n      ∀ t : Finset ι,\n        (s ∩\n            «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n              (Z i)).nonempty) :\n    (s ∩\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (Z i)).nonempty :=\n  by\n  simp only [nonempty_iff_ne_empty] at hsZ⊢\n  apply mt (hs.elim_finite_subfamily_closed Z hZc); push_neg; exact hsZ\n#align is_compact.inter_Inter_nonempty is_compact.inter_Inter_nonempty\n\n",
 "inter":
 "theorem is_clopen.inter {s t : set α} (hs : is_clopen s) (ht : is_clopen t) : is_clopen (s ∩ t) :=\n  ⟨hs.1.inter ht.1, hs.2.inter ht.2⟩\n#align is_clopen.inter is_clopen.inter\n\n",
 "insert":
 "theorem is_compact.insert (hs : is_compact s) (a) : is_compact (insert a s) :=\n  is_compact_singleton.union hs\n#align is_compact.insert is_compact.insert\n\n",
 "induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- If `p : set α → Prop` is stable under restriction and union, and each point `x`\n  of a compact set `s` has a neighborhood `t` within `s` such that `p t`, then `p s` holds. -/\n@[elab_as_elim]\ntheorem is_compact.induction_on {s : set α} (hs : is_compact s) {p : set α → Prop} (he : p ∅)\n    (hmono : ∀ ⦃s t⦄, s ⊆ t → p t → p s) (hunion : ∀ ⦃s t⦄, p s → p t → p (s ∪ t))\n    (hnhds : ∀ x ∈ s, ∃ t ∈ nhds_within s x, p t) : p s :=\n  by\n  let f : filter α :=\n    { sets := { t | p («expr ᶜ» t) }\n      univ_sets := by simpa\n      sets_of_superset := fun t₁ t₂ ht₁ ht => hmono (compl_subset_compl.2 ht) ht₁\n      inter_sets := fun t₁ t₂ ht₁ ht₂ => by simp [compl_inter, hunion ht₁ ht₂] }\n  have : «expr ᶜ» s ∈ f := hs.compl_mem_sets_of_nhds_within (by simpa using hnhds)\n  simpa\n#align is_compact.induction_on is_compact.induction_on\n\n",
 "image_of_continuous_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact.image_of_continuous_on {f : α → β} (hs : is_compact s) (hf : continuous_on f s) :\n    is_compact («expr '' » f s) := by\n  intro l lne ls\n  have : ne_bot («expr ⊓ » (l.comap f) ((filter.principal) s)) :=\n    comap_inf_principal_ne_bot_of_image_mem lne (le_principal_iff.1 ls)\n  obtain ⟨a, has, ha⟩ : ∃ a ∈ s, cluster_pt a («expr ⊓ » (l.comap f) ((filter.principal) s)) := @hs this inf_le_right\n  use f a, mem_image_of_mem f has\n  have : tendsto f («expr ⊓ » ((nhds) a) («expr ⊓ » (comap f l) ((filter.principal) s))) («expr ⊓ » ((nhds) (f a)) l) :=\n    by\n    convert (hf a has).inf (@tendsto_comap _ _ f l) using 1\n    rw [nhds_within]\n    ac_rfl\n  exact @tendsto.ne_bot _ this ha\n#align is_compact.image_of_continuous_on is_compact.image_of_continuous_on\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_irreducible.image {s : set α} (H : is_irreducible s) (f : α → β) (hf : continuous_on f s) :\n    is_irreducible («expr '' » f s) :=\n  ⟨H.nonempty.image _, H.is_preirreducible.image f hf⟩\n#align is_irreducible.image is_irreducible.image\n\n",
 "has_basis_cocompact":
 "theorem has_basis_cocompact : (cocompact α).has_basis is_compact compl :=\n  has_basis_binfi_principal'\n    (fun s hs t ht =>\n      ⟨s ∪ t, hs.union ht, compl_subset_compl.2 (subset_union_left s t), compl_subset_compl.2 (subset_union_right s t)⟩)\n    ⟨∅, is_compact_empty⟩\n#align has_basis_cocompact has_basis_cocompact\n\n",
 "has_basis_coclosed_compact":
 "theorem has_basis_coclosed_compact :\n    (filter.coclosed_compact α).has_basis (fun s => is_closed s ∧ is_compact s) compl :=\n  by\n  simp only [filter.coclosed_compact, infᵢ_and']\n  refine' has_basis_binfi_principal' _ ⟨∅, is_closed_empty, is_compact_empty⟩\n  rintro s ⟨hs₁, hs₂⟩ t ⟨ht₁, ht₂⟩\n  exact\n    ⟨s ∪ t,\n      ⟨⟨hs₁.union ht₁, hs₂.union ht₂⟩, compl_subset_compl.2 (subset_union_left _ _),\n        compl_subset_compl.2 (subset_union_right _ _)⟩⟩\n#align has_basis_coclosed_compact has_basis_coclosed_compact\n\n",
 "generalized_tube_lemma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/-- If `s` and `t` are compact sets and `n` is an open neighborhood of `s × t`, then there exist\nopen neighborhoods `u ⊇ s` and `v ⊇ t` such that `u × v ⊆ n`. -/\ntheorem generalized_tube_lemma {s : set α} (hs : is_compact s) {t : set β} (ht : is_compact t) {n : set (α × β)}\n    (hn : is_open n) (hp : lower_set.prod s t ⊆ n) :\n    ∃ (u : set α)(v : set β), is_open u ∧ is_open v ∧ s ⊆ u ∧ t ⊆ v ∧ lower_set.prod u v ⊆ n :=\n  have :=\n    nhds_contain_boxes_of_compact hs t fun x _ =>\n      nhds_contain_boxes.symm <| nhds_contain_boxes_of_compact ht {x} fun y _ => nhds_contain_boxes_of_singleton\n  this n hn hp\n#align generalized_tube_lemma generalized_tube_lemma\n\n",
 "finite_of_discrete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_compact.finite_of_discrete [discrete_topology α] {s : set α} (hs : is_compact s) : s.finite :=\n  by\n  have : ∀ x : α, ({x} : set α) ∈ (nhds) x := by simp [nhds_discrete]\n  rcases hs.elim_nhds_subcover (fun x => {x}) fun x hx => this x with ⟨t, hts, hst⟩\n  simp only [← t.set_bUnion_coe, bUnion_of_singleton] at hst\n  exact t.finite_to_set.subset hst\n#align is_compact.finite_of_discrete is_compact.finite_of_discrete\n\n",
 "finite_of_compact_of_discrete":
 "-- Note: We can't make this into an instance because it loops with `finite.compact_space`.\n/-- A compact discrete space is finite. -/\ntheorem finite_of_compact_of_discrete [compact_space α] [discrete_topology α] : Finite α :=\n  finite.of_finite_univ <| is_compact_univ.finite_of_discrete\n#align finite_of_compact_of_discrete finite_of_compact_of_discrete\n\n",
 "finite_of_compact":
 "/-- If `α` is a compact space, then a locally finite family of nonempty sets of `α` can have only\nfinitely many elements, `set.finite` version. -/\ntheorem locally_finite.finite_of_compact {ι : Type _} [compact_space α] {f : ι → set α} (hf : locally_finite f)\n    (hne : ∀ i, (f i).nonempty) : (univ : set ι).finite := by simpa only [hne] using hf.finite_nonempty_of_compact\n#align locally_finite.finite_of_compact locally_finite.finite_of_compact\n\n",
 "finite_nonempty_of_compact":
 "/-- If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\nmany nonempty elements. -/\ntheorem locally_finite.finite_nonempty_of_compact {ι : Type _} [compact_space α] {f : ι → set α}\n    (hf : locally_finite f) : { i | (f i).nonempty }.finite := by\n  simpa only [inter_univ] using hf.finite_nonempty_inter_compact is_compact_univ\n#align locally_finite.finite_nonempty_of_compact locally_finite.finite_nonempty_of_compact\n\n",
 "finite_nonempty_inter_compact":
 "/-- If `s` is a compact set in a topological space `α` and `f : ι → set α` is a locally finite\nfamily of sets, then `f i ∩ s` is nonempty only for a finitely many `i`. -/\ntheorem locally_finite.finite_nonempty_inter_compact {ι : Type _} {f : ι → set α} (hf : locally_finite f) {s : set α}\n    (hs : is_compact s) : { i | (f i ∩ s).nonempty }.finite :=\n  by\n  choose U hxU hUf using hf\n  rcases hs.elim_nhds_subcover U fun x _ => hxU x with ⟨t, -, hsU⟩\n  refine' (t.finite_to_set.bUnion fun x _ => hUf x).subset _\n  rintro i ⟨x, hx⟩\n  rcases mem_Union₂.1 (hsU hx.2) with ⟨c, hct, hcx⟩\n  exact mem_bUnion hct ⟨x, hx.1, hcx⟩\n#align locally_finite.finite_nonempty_inter_compact locally_finite.finite_nonempty_inter_compact\n\n",
 "finite_cover_nhds_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem finite_cover_nhds_interior [compact_space α] {U : α → set α} (hU : ∀ x, U x ∈ (nhds) x) :\n    ∃ t : Finset α,\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (interior (U x)) =\n        univ :=\n  let ⟨t, ht⟩ :=\n    is_compact_univ.elim_finite_subcover (fun x => interior (U x)) (fun x => is_open_interior) fun x _ =>\n      mem_unionᵢ.2 ⟨x, mem_interior_iff_mem_nhds.2 (hU x)⟩\n  ⟨t, univ_subset_iff.1 ht⟩\n#align finite_cover_nhds_interior finite_cover_nhds_interior\n\n",
 "finite_cover_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem finite_cover_nhds [compact_space α] {U : α → set α} (hU : ∀ x, U x ∈ (nhds) x) :\n    ∃ t : Finset α,\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U x) = univ :=\n  let ⟨t, ht⟩ := finite_cover_nhds_interior hU\n  ⟨t, univ_subset_iff.1 <| ht.symm.subset.trans <| Union₂_mono fun x hx => interior_subset⟩\n#align finite_cover_nhds finite_cover_nhds\n\n",
 "finite":
 "theorem is_compact.finite {s : set α} (hs : is_compact s) (hs' : discrete_topology s) : s.finite :=\n  finite_coe_iff.mp (@finite_of_compact_of_discrete _ _ (is_compact_iff_compact_space.mp hs) hs')\n#align is_compact.finite is_compact.finite\n\n",
 "find_shiftr":
 "@[simp]\ntheorem find_shiftr (x : α) : K.shiftr.find x = K.find x + 1 :=\n  Nat.find_comp_succ _ _ (not_mem_empty _)\n#align find_shiftr find_shiftr\n\n",
 "exists_subset_nhds_of_is_compact'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `V : ι → set α` is a decreasing family of closed compact sets then any neighborhood of\n`⋂ i, V i` contains some `V i`. We assume each `V i` is compact *and* closed because `α` is\nnot assumed to be Hausdorff. See `exists_subset_nhd_of_compact` for version assuming this. -/\ntheorem exists_subset_nhds_of_is_compact' {ι : Type _} [nonempty ι] {V : ι → set α} (hV : Directed («expr ⊇ » · ·) V)\n    (hV_cpct : ∀ i, is_compact (V i)) (hV_closed : ∀ i, is_closed (V i)) {U : set α}\n    (hU :\n      ∀ x ∈ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (V i),\n        U ∈ (nhds) x) :\n    ∃ i, V i ⊆ U := by\n  obtain ⟨W, hsubW, W_op, hWU⟩ := exists_open_set_nhds hU\n  rsuffices ⟨i, hi⟩ : ∃ i, V i ⊆ W\n  · exact ⟨i, hi.trans hWU⟩\n  by_contra' H\n  replace H : ∀ i, (V i ∩ «expr ᶜ» W).nonempty := fun i => set.inter_compl_nonempty_iff.mpr (H i)\n  have :\n    («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (V i ∩ «expr ᶜ» W)).nonempty :=\n    by\n    refine'\n      is_compact.nonempty_Inter_of_directed_nonempty_compact_closed _ (fun i j => _) H\n        (fun i => (hV_cpct i).inter_right W_op.is_closed_compl) fun i => (hV_closed i).inter W_op.is_closed_compl\n    rcases hV i j with ⟨k, hki, hkj⟩\n    refine' ⟨k, ⟨fun x => _, fun x => _⟩⟩ <;> simp only [and_imp, mem_inter_iff, mem_compl_iff] <;> tauto\n  have : ¬«expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (V i) ⊆ W :=\n    by simpa [← Inter_inter, inter_compl_nonempty_iff]\n  contradiction\n#align exists_subset_nhds_of_is_compact' exists_subset_nhds_of_is_compact'\n\n",
 "exists_subset_nhds_of_compact_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_subset_nhds_of_compact_space [compact_space α] {ι : Type _} [nonempty ι] {V : ι → set α}\n    (hV : Directed («expr ⊇ » · ·) V) (hV_closed : ∀ i, is_closed (V i)) {U : set α}\n    (hU :\n      ∀ x ∈ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (V i),\n        U ∈ (nhds) x) :\n    ∃ i, V i ⊆ U :=\n  exists_subset_nhds_of_is_compact' hV (fun i => (hV_closed i).is_compact) hV_closed hU\n#align exists_subset_nhds_of_compact_space exists_subset_nhds_of_compact_space\n\n",
 "exists_preirreducible":
 "theorem exists_preirreducible (s : set α) (H : is_preirreducible s) :\n    ∃ t : set α, is_preirreducible t ∧ s ⊆ t ∧ ∀ u, is_preirreducible u → t ⊆ u → u = t :=\n  let ⟨m, hm, hsm, hmm⟩ :=\n    zorn_subset_nonempty { t : set α | is_preirreducible t }\n      (fun c hc hcc hcn =>\n        let ⟨t, htc⟩ := hcn\n        ⟨⋃₀ c, fun u v hu hv ⟨y, hy, hyu⟩ ⟨z, hz, hzv⟩ =>\n          let ⟨p, hpc, hyp⟩ := mem_unionₛ.1 hy\n          let ⟨q, hqc, hzq⟩ := mem_unionₛ.1 hz\n          or.cases_on (hcc.total hpc hqc)\n            (fun hpq : p ⊆ q =>\n              let ⟨x, hxp, hxuv⟩ := hc hqc u v hu hv ⟨y, hpq hyp, hyu⟩ ⟨z, hzq, hzv⟩\n              ⟨x, mem_unionₛ_of_mem hxp hqc, hxuv⟩)\n            fun hqp : q ⊆ p =>\n            let ⟨x, hxp, hxuv⟩ := hc hpc u v hu hv ⟨y, hyp, hyu⟩ ⟨z, hqp hzq, hzv⟩\n            ⟨x, mem_unionₛ_of_mem hxp hpc, hxuv⟩,\n          fun x hxc => subset_unionₛ_of_mem hxc⟩)\n      s H\n  ⟨m, hm, hsm, fun u hu hmu => hmm _ hu hmu⟩\n#align exists_preirreducible exists_preirreducible\n\n",
 "exists_nhds_ne_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\ntheorem exists_nhds_ne_ne_bot (α : Type _) [topological_space α] [compact_space α] [Infinite α] :\n    ∃ z : α, (nhds_within.ne z).ne_bot := by\n  by_contra' H\n  simp_rw [not_ne_bot] at H\n  haveI := discrete_topology_iff_nhds_ne.mpr H\n  exact infinite.not_finite (finite_of_compact_of_discrete : Finite α)\n#align exists_nhds_ne_ne_bot exists_nhds_ne_ne_bot\n\n",
 "exists_nhds_ne_inf_principal_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem exists_nhds_ne_inf_principal_ne_bot {s : set α} (hs : is_compact s) (hs' : s.infinite) :\n    ∃ z ∈ s, («expr ⊓ » (nhds_within.ne z) ((filter.principal) s)).ne_bot :=\n  by\n  by_contra' H\n  simp_rw [not_ne_bot] at H\n  exact hs' (hs.finite <| discrete_topology_subtype_iff.mpr H)\n#align exists_nhds_ne_inf_principal_ne_bot exists_nhds_ne_inf_principal_ne_bot\n\n",
 "exists_minimal_nonempty_closed_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_closed.exists_minimal_nonempty_closed_subset [compact_space α] {S : set α} (hS : is_closed S)\n    (hne : S.nonempty) :\n    ∃ V : set α, V ⊆ S ∧ V.nonempty ∧ is_closed V ∧ ∀ V' : set α, V' ⊆ V → V'.nonempty → is_closed V' → V' = V :=\n  by\n  let opens := { U : set α | «expr ᶜ» S ⊆ U ∧ is_open U ∧ («expr ᶜ» U).nonempty }\n  obtain ⟨U, ⟨Uc, Uo, Ucne⟩, h⟩ :=\n    zorn_subset opens fun c hc hz => by\n      by_cases hcne : c.nonempty\n      · obtain ⟨U₀, hU₀⟩ := hcne\n        haveI : nonempty { U // U ∈ c } := ⟨⟨U₀, hU₀⟩⟩\n        obtain ⟨U₀compl, U₀opn, U₀ne⟩ := hc hU₀\n        use ⋃₀ c\n        refine' ⟨⟨_, _, _⟩, fun U hU a ha => ⟨U, hU, ha⟩⟩\n        · exact fun a ha => ⟨U₀, hU₀, U₀compl ha⟩\n        · exact is_open_sUnion fun _ h => (hc h).2.1\n        · convert_to\n            («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n                («expr ᶜ» U.1)).nonempty\n          · ext\n            simp only [not_exists, exists_prop, not_and, Set.mem_interᵢ, subtype.forall, mem_set_of_eq, mem_compl_iff,\n              mem_sUnion]\n          apply is_compact.nonempty_Inter_of_directed_nonempty_compact_closed\n          · rintro ⟨U, hU⟩ ⟨U', hU'⟩\n            obtain ⟨V, hVc, hVU, hVU'⟩ := hz.directed_on U hU U' hU'\n            exact ⟨⟨V, hVc⟩, set.compl_subset_compl.mpr hVU, set.compl_subset_compl.mpr hVU'⟩\n          · exact fun U => (hc U.2).2.2\n          · exact fun U => (is_closed_compl_iff.mpr (hc U.2).2.1).is_compact\n          · exact fun U => is_closed_compl_iff.mpr (hc U.2).2.1\n      · use «expr ᶜ» S\n        refine' ⟨⟨Set.Subset.refl _, is_open_compl_iff.mpr hS, _⟩, fun U Uc => (hcne ⟨U, Uc⟩).elim⟩\n        rw [compl_compl]\n        exact hne\n  refine' ⟨«expr ᶜ» U, set.compl_subset_comm.mp Uc, Ucne, is_closed_compl_iff.mpr Uo, _⟩\n  intro V' V'sub V'ne V'cls\n  have : «expr ᶜ» V' = U :=\n    by\n    refine' h («expr ᶜ» V') ⟨_, is_open_compl_iff.mpr V'cls, _⟩ (set.subset_compl_comm.mp V'sub)\n    exact Set.Subset.trans Uc (set.subset_compl_comm.mp V'sub)\n    simp only [compl_compl, V'ne]\n  rw [← this, compl_compl]\n#align is_closed.exists_minimal_nonempty_closed_subset is_closed.exists_minimal_nonempty_closed_subset\n\n",
 "exists_mem_compact_covering":
 "theorem exists_mem_compact_covering (x : α) : ∃ n, x ∈ compact_covering α n :=\n  unionᵢ_eq_univ_iff.mp (Union_compact_covering α) x\n#align exists_mem_compact_covering exists_mem_compact_covering\n\n",
 "exists_mem":
 "theorem exists_mem (x : α) : ∃ n, x ∈ K n :=\n  unionᵢ_eq_univ_iff.1 K.Union_eq x\n#align exists_mem exists_mem\n\n",
 "exists_compact_superset":
 "/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem exists_compact_superset [locally_compact_space α] {K : set α} (hK : is_compact K) :\n    ∃ K', is_compact K' ∧ K ⊆ interior K' :=\n  let ⟨L, hLc, hKL, _⟩ := exists_compact_between hK is_open_univ K.subset_univ\n  ⟨L, hLc, hKL⟩\n#align exists_compact_superset exists_compact_superset\n\n",
 "exists_compact_subset":
 "/-- A reformulation of the definition of locally compact space: In a locally compact space,\n  every open set containing `x` has a compact subset containing `x` in its interior. -/\ntheorem exists_compact_subset [locally_compact_space α] {x : α} {U : set α} (hU : is_open U) (hx : x ∈ U) :\n    ∃ K : set α, is_compact K ∧ x ∈ interior K ∧ K ⊆ U :=\n  by\n  rcases locally_compact_space.local_compact_nhds x U (hU.mem_nhds hx) with ⟨K, h1K, h2K, h3K⟩\n  exact ⟨K, h3K, mem_interior_iff_mem_nhds.2 h1K, h2K⟩\n#align exists_compact_subset exists_compact_subset\n\n",
 "exists_compact_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem exists_compact_mem_nhds [locally_compact_space α] (x : α) : ∃ K, is_compact K ∧ K ∈ (nhds) x :=\n  let ⟨K, hKc, hx, H⟩ := exists_compact_subset is_open_univ (mem_univ x)\n  ⟨K, hKc, mem_interior_iff_mem_nhds.1 hx⟩\n#align exists_compact_mem_nhds exists_compact_mem_nhds\n\n",
 "exists_compact_between":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- In a locally compact space, for every containement `K ⊆ U` of a compact set `K` in an open\n  set `U`, there is a compact neighborhood `L` such that `K ⊆ L ⊆ U`: equivalently, there is a\n  compact `L` such that `K ⊆ interior L` and `L ⊆ U`. -/\ntheorem exists_compact_between [hα : locally_compact_space α] {K U : set α} (hK : is_compact K) (hU : is_open U)\n    (h_KU : K ⊆ U) : ∃ L, is_compact L ∧ K ⊆ interior L ∧ L ⊆ U :=\n  by\n  choose V hVc hxV hKV using fun x : K => exists_compact_subset hU (h_KU x.2)\n  have :\n    K ⊆\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (interior (V x)) :=\n    fun x hx => mem_Union.2 ⟨⟨x, hx⟩, hxV _⟩\n  rcases hK.elim_finite_subcover _ (fun x => @is_open_interior α _ (V x)) this with ⟨t, ht⟩\n  refine' ⟨_, t.is_compact_bUnion fun x _ => hVc x, fun x hx => _, Set.unionᵢ₂_subset fun i _ => hKV i⟩\n  rcases mem_Union₂.1 (ht hx) with ⟨y, hyt, hy⟩\n  exact interior_mono (subset_bUnion_of_mem hyt) hy\n#align exists_compact_between exists_compact_between\n\n",
 "eventually_forall_of_forall_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- To show that `∀ y ∈ K, P x y` holds for `x` close enough to `x₀` when `K` is compact,\nit is sufficient to show that for all `y₀ ∈ K` there `P x y` holds for `(x, y)` close enough\nto `(x₀, y₀)`.\n-/\ntheorem is_compact.eventually_forall_of_forall_eventually {x₀ : α} {K : set β} (hK : is_compact K) {P : α → β → Prop}\n    (hP :\n      ∀ y ∈ K,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          ((nhds) (x₀, y)) (P z.1 z.2)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x₀)\n      (∀ y ∈ K, P x y) :=\n  by\n  refine' hK.induction_on _ _ _ _\n  · exact eventually_of_forall fun x y => false.elim\n  · intro s t hst ht\n    refine' ht.mono fun x h y hys => h y <| hst hys\n  · intro s t hs ht\n    filter_upwards [hs, ht]\n    rintro x h1 h2 y (hys | hyt)\n    exacts[h1 y hys, h2 y hyt]\n  · intro y hyK\n    specialize hP y hyK\n    rw [nhds_prod_eq, eventually_prod_iff] at hP\n    rcases hP with ⟨p, hp, q, hq, hpq⟩\n    exact ⟨{ y | q y }, mem_nhds_within_of_mem_nhds hq, eventually_of_mem hp @hpq⟩\n#align is_compact.eventually_forall_of_forall_eventually is_compact.eventually_forall_of_forall_eventually\n\n",
 "eq_irreducible_component":
 "theorem eq_irreducible_component {x : α} :\n    ∀ {s : set α}, is_preirreducible s → irreducible_component x ⊆ s → s = irreducible_component x :=\n  (irreducible_component_property x).2.2\n#align eq_irreducible_component eq_irreducible_component\n\n",
 "elim_nhds_subcover'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_compact.elim_nhds_subcover' (hs : is_compact s) (U : ∀ x ∈ s, set α) (hU : ∀ x ∈ s, U x ‹x ∈ s› ∈ (nhds) x) :\n    ∃ t : Finset s,\n      s ⊆\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (U (x : s) x.2) :=\n  (hs.elim_finite_subcover (fun x : s => interior (U x x.2)) (fun x => is_open_interior) fun x hx =>\n        mem_unionᵢ.2 ⟨⟨x, hx⟩, mem_interior_iff_mem_nhds.2 <| hU _ _⟩).imp\n    fun t ht => Subset.trans ht <| Union₂_mono fun _ _ => interior_subset\n#align is_compact.elim_nhds_subcover' is_compact.elim_nhds_subcover'\n\n",
 "elim_nhds_subcover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem compact_space.elim_nhds_subcover [compact_space α] (U : α → set α) (hU : ∀ x, U x ∈ (nhds) x) :\n    ∃ t : Finset α,\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U x) = «expr⊤» :=\n  by\n  obtain ⟨t, -, s⟩ := is_compact.elim_nhds_subcover is_compact_univ U fun x m => hU x\n  exact\n    ⟨t, by\n      rw [eq_top_iff]\n      exact s⟩\n#align compact_space.elim_nhds_subcover compact_space.elim_nhds_subcover\n\n",
 "elim_finite_subfamily_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- For every family of closed sets whose intersection avoids a compact set,\nthere exists a finite subfamily whose intersection avoids this compact set. -/\ntheorem is_compact.elim_finite_subfamily_closed {s : set α} {ι : Type v} (hs : is_compact s) (Z : ι → set α)\n    (hZc : ∀ i, is_closed (Z i))\n    (hsZ :\n      s ∩ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i) = ∅) :\n    ∃ t : Finset ι,\n      s ∩ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i) = ∅ :=\n  let ⟨t, ht⟩ :=\n    hs.elim_finite_subcover (fun i => «expr ᶜ» (Z i)) (fun i => (hZc i).is_open_compl)\n      (by\n        simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_Union, exists_prop, mem_inter_iff, not_and,\n          iff_self_iff, mem_Inter, mem_compl_iff] using hsZ)\n  ⟨t, by\n    simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_Union, exists_prop, mem_inter_iff, not_and,\n      iff_self_iff, mem_Inter, mem_compl_iff] using ht⟩\n#align is_compact.elim_finite_subfamily_closed is_compact.elim_finite_subfamily_closed\n\n",
 "elim_finite_subcover_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (b' «expr ⊆ » b) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem is_compact.elim_finite_subcover_image {b : set ι} {c : ι → set α} (hs : is_compact s)\n    (hc₁ : ∀ i ∈ b, is_open (c i))\n    (hc₂ : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (c i)) :\n    ∃ (b' : _)(_ : b' ⊆ b),\n      set.finite b' ∧\n        s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (c i) :=\n  by\n  rcases hs.elim_finite_subcover (fun i => c i : b → set α) _ _ with ⟨d, hd⟩ <;> [skip, simpa using hc₁,\n    simpa using hc₂]\n  refine' ⟨↑(d.image coe), _, finset.finite_to_set _, _⟩\n  · simp\n  · rwa [Finset.coe_image, bUnion_image]\n#align is_compact.elim_finite_subcover_image is_compact.elim_finite_subcover_image\n\n",
 "elim_finite_subcover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem is_compact.elim_finite_subcover {ι : Type v} (hs : is_compact s) (U : ι → set α) (hUo : ∀ i, is_open (U i))\n    (hsU : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i)) :\n    ∃ t : Finset ι,\n      s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i) :=\n  hs.elim_directed_cover _ (fun t => is_open_bUnion fun i _ => hUo i) (Union_eq_Union_finset U ▸ hsU)\n    (directed_of_sup fun t₁ t₂ h => bunionᵢ_subset_bunionᵢ_left h)\n#align is_compact.elim_finite_subcover is_compact.elim_finite_subcover\n\n",
 "elim_directed_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- For every open directed cover of a compact set, there exists a single element of the\ncover which itself includes the set. -/\ntheorem is_compact.elim_directed_cover {ι : Type v} [hι : nonempty ι] (hs : is_compact s) (U : ι → set α)\n    (hUo : ∀ i, is_open (U i))\n    (hsU : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i))\n    (hdU : Directed (· ⊆ ·) U) : ∃ i, s ⊆ U i :=\n  hι.elim fun i₀ =>\n    is_compact.induction_on hs ⟨i₀, empty_subset _⟩ (fun s₁ s₂ hs ⟨i, hi⟩ => ⟨i, Subset.trans hs hi⟩)\n      (fun s₁ s₂ ⟨i, hi⟩ ⟨j, hj⟩ =>\n        let ⟨k, hki, hkj⟩ := hdU i j\n        ⟨k, union_subset (Subset.trans hi hki) (Subset.trans hj hkj)⟩)\n      fun x hx =>\n      let ⟨i, hi⟩ := mem_unionᵢ.1 (hsU hx)\n      ⟨U i, mem_nhds_within_of_mem_nhds (is_open.mem_nhds (hUo i) hi), i, Subset.refl _⟩\n#align is_compact.elim_directed_cover is_compact.elim_directed_cover\n\n",
 "disjoint_nhds_set_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A filter `l` is disjoint with the neighborhood filter of a compact set if and only if it is\ndisjoint with the neighborhood filter of each point of this set. -/\ntheorem is_compact.disjoint_nhds_set_right {l : filter α} (hs : is_compact s) :\n    Disjoint l ((nhds_set) s) ↔ ∀ x ∈ s, Disjoint l ((nhds) x) := by\n  simpa only [disjoint_comm] using hs.disjoint_nhds_set_left\n#align is_compact.disjoint_nhds_set_right is_compact.disjoint_nhds_set_right\n\n",
 "disjoint_nhds_set_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The neighborhood filter of a compact set is disjoint with a filter `l` if and only if the\nneighborhood filter of each point of this set is disjoint with `l`. -/\ntheorem is_compact.disjoint_nhds_set_left {l : filter α} (hs : is_compact s) :\n    Disjoint ((nhds_set) s) l ↔ ∀ x ∈ s, Disjoint ((nhds) x) l :=\n  by\n  refine' ⟨fun h x hx => h.mono_left <| nhds_le_nhds_set hx, fun H => _⟩\n  choose! U hxU hUl using fun x hx => (nhds_basis_opens x).disjoint_iff_left.1 (H x hx)\n  choose hxU hUo using hxU\n  rcases hs.elim_nhds_subcover U fun x hx => (hUo x hx).mem_nhds (hxU x hx) with ⟨t, hts, hst⟩\n  refine'\n    (has_basis_nhds_set _).disjoint_iff_left.2\n      ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U x),\n        ⟨is_open_bUnion fun x hx => hUo x (hts x hx), hst⟩, _⟩\n  rw [compl_Union₂, bInter_finset_mem]\n  exact fun x hx => hUl x (hts x hx)\n#align is_compact.disjoint_nhds_set_left is_compact.disjoint_nhds_set_left\n\n",
 "diff":
 "theorem is_clopen.diff {s t : set α} (hs : is_clopen s) (ht : is_clopen t) : is_clopen (s \\ t) :=\n  hs.inter ht.compl\n#align is_clopen.diff is_clopen.diff\n\n",
 "dense":
 "/-- In a (pre)irreducible space, a nonempty open set is dense. -/\nprotected theorem is_open.dense [preirreducible_space α] {s : set α} (ho : is_open s) (hne : s.nonempty) : dense s :=\n  dense_iff_inter_open.2 fun t hto htne => nonempty_preirreducible_inter hto ho htne hne\n#align is_open.dense is_open.dense\n\n",
 "countable_univ":
 "/-- If `α` is a `σ`-compact space, then a locally finite family of nonempty sets of `α` can have\nonly countably many elements, `set.countable` version. -/\nprotected theorem locally_finite.countable_univ {ι : Type _} {f : ι → set α} (hf : locally_finite f)\n    (hne : ∀ i, (f i).nonempty) : (univ : set ι).countable :=\n  by\n  have := fun n => hf.finite_nonempty_inter_compact (is_compact_compact_covering α n)\n  refine' (countable_Union fun n => (this n).countable).mono fun i hi => _\n  rcases hne i with ⟨x, hx⟩\n  rcases Union_eq_univ_iff.1 (Union_compact_covering α) x with ⟨n, hn⟩\n  exact mem_Union.2 ⟨n, x, hx, hn⟩\n#align locally_finite.countable_univ locally_finite.countable_univ\n\n",
 "countable_cover_nhds_within_of_sigma_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- In a topological space with sigma compact topology, if `f` is a function that sends each point\n`x` of a closed set `s` to a neighborhood of `x` within `s`, then for some countable set `t ⊆ s`,\nthe neighborhoods `f x`, `x ∈ t`, cover the whole set `s`. -/\ntheorem countable_cover_nhds_within_of_sigma_compact {f : α → set α} {s : set α} (hs : is_closed s)\n    (hf : ∀ x ∈ s, f x ∈ nhds_within s x) :\n    ∃ (t : _)(_ : t ⊆ s),\n      t.countable ∧\n        s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f x) :=\n  by\n  simp only [nhds_within, mem_inf_principal] at hf\n  choose t ht hsub using fun n =>\n    ((is_compact_compact_covering α n).inter_right hs).elim_nhds_subcover _ fun x hx => hf x hx.right\n  refine'\n    ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t n : set α),\n      Union_subset fun n x hx => (ht n x hx).2, countable_Union fun n => (t n).countable_to_set, fun x hx =>\n      mem_Union₂.2 _⟩\n  rcases exists_mem_compact_covering x with ⟨n, hn⟩\n  rcases mem_Union₂.1 (hsub n ⟨hn, hx⟩) with ⟨y, hyt : y ∈ t n, hyf : x ∈ s → x ∈ f y⟩\n  exact ⟨y, mem_Union.2 ⟨n, hyt⟩, hyf hx⟩\n#align countable_cover_nhds_within_of_sigma_compact countable_cover_nhds_within_of_sigma_compact\n\n",
 "countable_cover_nhds_of_sigma_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- In a topological space with sigma compact topology, if `f` is a function that sends each\npoint `x` to a neighborhood of `x`, then for some countable set `s`, the neighborhoods `f x`,\n`x ∈ s`, cover the whole space. -/\ntheorem countable_cover_nhds_of_sigma_compact {f : α → set α} (hf : ∀ x, f x ∈ (nhds) x) :\n    ∃ s : set α,\n      s.countable ∧\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f x) = univ :=\n  by\n  simp only [← nhds_within_univ] at hf\n  rcases countable_cover_nhds_within_of_sigma_compact is_closed_univ fun x _ => hf x with ⟨s, -, hsc, hsU⟩\n  exact ⟨s, hsc, univ_subset_iff.1 hsU⟩\n#align countable_cover_nhds_of_sigma_compact countable_cover_nhds_of_sigma_compact\n\n",
 "coprod_cocompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The coproduct of the cocompact filters on two topological spaces is the cocompact filter on\ntheir product. -/\ntheorem filter.coprod_cocompact : (filter.cocompact α).coprod (filter.cocompact β) = filter.cocompact (α × β) :=\n  by\n  ext S\n  simp only [mem_coprod_iff, exists_prop, mem_comap, filter.mem_cocompact]\n  constructor\n  · rintro ⟨⟨A, ⟨t, ht, hAt⟩, hAS⟩, B, ⟨t', ht', hBt'⟩, hBS⟩\n    refine' ⟨lower_set.prod t t', ht.prod ht', _⟩\n    refine' subset.trans _ (union_subset hAS hBS)\n    rw [compl_subset_comm] at hAt hBt'⊢\n    refine' subset.trans _ (Set.prod_mono hAt hBt')\n    intro x\n    simp only [compl_union, mem_inter_iff, mem_prod, mem_preimage, mem_compl_iff]\n    tauto\n  · rintro ⟨t, ht, htS⟩\n    refine' ⟨⟨«expr ᶜ» («expr '' » prod.fst t), _, _⟩, ⟨«expr ᶜ» («expr '' » prod.snd t), _, _⟩⟩\n    · exact ⟨«expr '' » prod.fst t, ht.image continuous_fst, subset.rfl⟩\n    · rw [preimage_compl]\n      rw [compl_subset_comm] at htS⊢\n      exact subset.trans htS (subset_preimage_image prod.fst _)\n    · exact ⟨«expr '' » prod.snd t, ht.image continuous_snd, subset.rfl⟩\n    · rw [preimage_compl]\n      rw [compl_subset_comm] at htS⊢\n      exact subset.trans htS (subset_preimage_image prod.snd _)\n#align filter.coprod_cocompact filter.coprod_cocompact\n\n",
 "continuous_on_indicator_iff_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem continuous_on_indicator_iff_clopen (s U : set X) :\n    continuous_on U.bool_indicator s ↔ is_clopen («expr ⁻¹' » (coe : s → X) U) :=\n  by\n  rw [continuous_on_iff_continuous_restrict, ← continuous_bool_indicator_iff_clopen]\n  rfl\n#align continuous_on_indicator_iff_clopen continuous_on_indicator_iff_clopen\n\n",
 "continuous_bool_indicator_iff_clopen":
 "theorem continuous_bool_indicator_iff_clopen (U : set X) : continuous U.bool_indicator ↔ is_clopen U :=\n  by\n  constructor\n  · intro hc\n    rw [← U.preimage_bool_indicator_tt]\n    exact ⟨hc.is_open_preimage _ trivial, continuous_iff_is_closed.mp hc _ (is_closed_discrete _)⟩\n  · refine' fun hU => ⟨fun s hs => _⟩\n    rcases U.preimage_bool_indicator s with (h | h | h | h) <;> rw [h]\n    exacts[is_open_univ, hU.1, hU.2.is_open_compl, is_open_empty]\n#align continuous_bool_indicator_iff_clopen continuous_bool_indicator_iff_clopen\n\n",
 "compl_mem_sets_of_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- The complement to a compact set belongs to a filter `f` if each `a ∈ s` has a neighborhood `t`\nwithin `s` such that `tᶜ` belongs to `f`. -/\ntheorem is_compact.compl_mem_sets_of_nhds_within (hs : is_compact s) {f : filter α}\n    (hf : ∀ a ∈ s, ∃ t ∈ nhds_within s a, «expr ᶜ» t ∈ f) : «expr ᶜ» s ∈ f :=\n  by\n  refine' hs.compl_mem_sets fun a ha => _\n  rcases hf a ha with ⟨t, ht, hst⟩\n  replace ht := mem_inf_principal.1 ht\n  apply mem_inf_of_inter ht hst\n  rintro x ⟨h₁, h₂⟩ hs\n  exact h₂ (h₁ hs)\n#align is_compact.compl_mem_sets_of_nhds_within is_compact.compl_mem_sets_of_nhds_within\n\n",
 "compl_mem_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Yury Kudryashov\n-/\n-- compact sets\n/-- The complement to a compact set belongs to a filter `f` if it belongs to each filter\n`𝓝 a ⊓ f`, `a ∈ s`. -/\ntheorem is_compact.compl_mem_sets (hs : is_compact s) {f : filter α}\n    (hf : ∀ a ∈ s, «expr ᶜ» s ∈ «expr ⊓ » ((nhds) a) f) : «expr ᶜ» s ∈ f :=\n  by\n  contrapose! hf\n  simp only [not_mem_iff_inf_principal_compl, compl_compl, inf_assoc, ← exists_prop] at hf⊢\n  exact @hs _ hf inf_le_right\n#align is_compact.compl_mem_sets is_compact.compl_mem_sets\n\n",
 "compl_mem_cocompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem _root_.is_compact.compl_mem_cocompact (hs : is_compact s) : «expr ᶜ» s ∈ filter.cocompact α :=\n  has_basis_cocompact.mem_of_mem hs\n#align is_compact.compl_mem_cocompact is_compact.compl_mem_cocompact\n\n",
 "compl_mem_coclosed_compact_of_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem _root_.is_compact.compl_mem_coclosed_compact_of_is_closed (hs : is_compact s) (hs' : is_closed s) :\n    «expr ᶜ» s ∈ filter.coclosed_compact α :=\n  has_basis_coclosed_compact.mem_of_mem ⟨hs', hs⟩\n#align is_compact.compl_mem_coclosed_compact_of_is_closed is_compact.compl_mem_coclosed_compact_of_is_closed\n\n",
 "compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_clopen.compl {s : set α} (hs : is_clopen s) : is_clopen («expr ᶜ» s) :=\n  ⟨hs.2.is_open_compl, hs.1.is_closed_compl⟩\n#align is_clopen.compl is_clopen.compl\n\n",
 "compact_space_of_finite_subfamily_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem compact_space_of_finite_subfamily_closed\n    (h :\n      ∀ {ι : Type u} (Z : ι → set α),\n        (∀ i, is_closed (Z i)) →\n          «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i) = ∅ →\n            ∃ t : Finset ι,\n              «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i) =\n                ∅) :\n    compact_space α :=\n  {\n    is_compact_univ := by\n      apply is_compact_of_finite_subfamily_closed\n      intro ι Z; specialize h Z\n      simpa using h }\n#align compact_space_of_finite_subfamily_closed compact_space_of_finite_subfamily_closed\n\n",
 "compact_space":
 "protected theorem closed_embedding.compact_space [h : compact_space β] {f : α → β} (hf : closed_embedding f) :\n    compact_space α := by\n  contrapose! h\n  rw [not_compact_space_iff] at h⊢\n  exact hf.noncompact_space\n#align closed_embedding.compact_space closed_embedding.compact_space\n\n",
 "compact_covering_subset":
 "@[mono]\ntheorem compact_covering_subset ⦃m n : ℕ⦄ (h : m ≤ n) : compact_covering α m ⊆ compact_covering α n :=\n  monotone_accumulate h\n#align compact_covering_subset compact_covering_subset\n\n",
 "compact_basis_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem compact_basis_nhds [locally_compact_space α] (x : α) :\n    ((nhds) x).has_basis (fun s => s ∈ (nhds) x ∧ is_compact s) fun s => s :=\n  has_basis_self.2 <| by simpa only [and_comm'] using locally_compact_space.local_compact_nhds x\n#align compact_basis_nhds compact_basis_nhds\n\n",
 "comm":
 "theorem nhds_contain_boxes.comm {s : set α} {t : set β} : nhds_contain_boxes s t ↔ nhds_contain_boxes t s :=\n  iff.intro nhds_contain_boxes.symm nhds_contain_boxes.symm\n#align nhds_contain_boxes.comm nhds_contain_boxes.comm\n\n",
 "comap_cocompact_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The comap of the cocompact filter on `β` by a continuous function `f : α → β` is less than or\nequal to the cocompact filter on `α`.\nThis is a reformulation of the fact that images of compact sets are compact. -/\ntheorem filter.comap_cocompact_le {f : α → β} (hf : continuous f) : (filter.cocompact β).comap f ≤ filter.cocompact α :=\n  by\n  rw [(filter.has_basis_cocompact.comap f).le_basis_iff filter.has_basis_cocompact]\n  intro t ht\n  refine' ⟨«expr '' » f t, ht.image hf, _⟩\n  simpa using t.subset_preimage_image f\n#align filter.comap_cocompact_le filter.comap_cocompact_le\n\n",
 "cocompact_ne_bot_iff":
 "theorem filter.cocompact_ne_bot_iff : ne_bot (filter.cocompact α) ↔ noncompact_space α :=\n  ⟨noncompact_space_of_ne_bot, @filter.cocompact.filter.ne_bot _ _⟩\n#align filter.cocompact_ne_bot_iff filter.cocompact_ne_bot_iff\n\n",
 "cocompact_le_cofinite":
 "theorem cocompact_le_cofinite : cocompact α ≤ cofinite := fun s hs => compl_compl s ▸ hs.is_compact.compl_mem_cocompact\n#align cocompact_le_cofinite cocompact_le_cofinite\n\n",
 "cocompact_le_coclosed_compact":
 "theorem cocompact_le_coclosed_compact : cocompact α ≤ coclosed_compact α :=\n  infᵢ_mono fun s => le_infᵢ fun _ => le_rfl\n#align cocompact_le_coclosed_compact cocompact_le_coclosed_compact\n\n",
 "cocompact_eq_cofinite":
 "theorem cocompact_eq_cofinite (α : Type _) [topological_space α] [discrete_topology α] : cocompact α = cofinite :=\n  has_basis_cocompact.eq_of_same_basis <| by\n    convert has_basis_cofinite\n    ext s\n    exact is_compact_iff_finite\n#align cocompact_eq_cofinite cocompact_eq_cofinite\n\n",
 "cocompact_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem filter.cocompact_eq_bot [compact_space α] : filter.cocompact α = «expr⊥» :=\n  filter.has_basis_cocompact.eq_bot_iff.mpr ⟨Set.univ, is_compact_univ, Set.compl_univ⟩\n#align filter.cocompact_eq_bot filter.cocompact_eq_bot\n\n",
 "cocompact_eq":
 "@[simp]\ntheorem _root_.nat.cocompact_eq : cocompact ℕ = at_top :=\n  (cocompact_eq_cofinite ℕ).trans nat.cofinite_eq_at_top\n#align nat.cocompact_eq nat.cocompact_eq\n\n",
 "cluster_point_of_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem cluster_point_of_compact [compact_space α] (f : filter α) [ne_bot f] : ∃ x, cluster_pt x f := by\n  simpa using is_compact_univ (show f ≤ (filter.principal) univ by simp)\n#align cluster_point_of_compact cluster_point_of_compact\n\n",
 "clopen_range_sigma_mk":
 "theorem clopen_range_sigma_mk {ι : Type _} {σ : ι → Type _} [∀ i, topological_space (σ i)] {i : ι} :\n    is_clopen (Set.range (@sigma.mk ι σ i)) :=\n  ⟨open_embedding_sigma_mk.open_range, closed_embedding_sigma_mk.closed_range⟩\n#align clopen_range_sigma_mk clopen_range_sigma_mk\n\n",
 "adherence_nhdset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_compact.adherence_nhdset {f : filter α} (hs : is_compact s) (hf₂ : f ≤ (filter.principal) s)\n    (ht₁ : is_open t) (ht₂ : ∀ a ∈ s, cluster_pt a f → a ∈ t) : t ∈ f :=\n  by_cases mem_of_eq_bot fun this : «expr ⊓ » f ((filter.principal) («expr ᶜ» t)) ≠ «expr⊥» =>\n    let ⟨a, ha, (hfa : cluster_pt a <| «expr ⊓ » f ((filter.principal) («expr ᶜ» t)))⟩ :=\n      @hs ⟨this⟩ <| inf_le_of_left_le hf₂\n    have : a ∈ t := ht₂ a ha hfa.of_inf_left\n    have : «expr ᶜ» t ∩ t ∈ nhds_within («expr ᶜ» t) a := inter_mem_nhds_within _ (is_open.mem_nhds ht₁ this)\n    have A : nhds_within («expr ᶜ» t) a = «expr⊥» := empty_mem_iff_bot.1 <| compl_inter_self t ▸ this\n    have : nhds_within («expr ᶜ» t) a ≠ «expr⊥» := hfa.of_inf_right.ne\n    absurd A this\n#align is_compact.adherence_nhdset is_compact.adherence_nhdset\n\n",
 "Union_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Union_eq :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (K n) = univ :=\n  K.Union_eq'\n#align Union_eq Union_eq\n\n",
 "Union_compact_covering":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Union_compact_covering :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (compact_covering α n) =\n      univ :=\n  by\n  rw [compact_covering, Union_accumulate]\n  exact (Classical.choose_spec sigma_compact_space.exists_compact_covering).2\n#align Union_compact_covering Union_compact_covering\n\n",
 "Coprod_cocompact":
 "/-- **Tychonoff's theorem** formulated in terms of filters: `filter.cocompact` on an indexed product\ntype `Π d, κ d` the `filter.Coprod` of filters `filter.cocompact` on `κ d`. -/\ntheorem filter.Coprod_cocompact {δ : Type _} {κ : δ → Type _} [∀ d, topological_space (κ d)] :\n    (filter.Coprod fun d => filter.cocompact (κ d)) = filter.cocompact (∀ d, κ d) :=\n  by\n  refine' le_antisymm (supᵢ_le fun i => filter.comap_cocompact_le (continuous_apply i)) _\n  refine' compl_surjective.forall.2 fun s H => _\n  simp only [compl_mem_Coprod, filter.mem_cocompact, compl_subset_compl, image_subset_iff] at H⊢\n  choose K hKc htK using H\n  exact ⟨Set.pi univ K, is_compact_univ_pi hKc, fun f hf i hi => htK i hf⟩\n#align filter.Coprod_cocompact filter.Coprod_cocompact\n\n"}