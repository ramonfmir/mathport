{"unionᵢ_compactCovering":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print unionᵢ_compactCovering /-\ntheorem unionᵢ_compactCovering :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (compactCovering α n) =\n      univ :=\n  by\n  rw [compactCovering, Union_accumulate]\n  exact (Classical.choose_spec sigma_compact_space.exists_compact_covering).2\n#align Union_compact_covering unionᵢ_compactCovering\n-/\n\n",
 "union":
 "#print IsClopen.union /-\ntheorem IsClopen.union {s t : Set α} (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s ∪ t) :=\n  ⟨hs.1.union ht.1, hs.2.union ht.2⟩\n#align is_clopen.union IsClopen.union\n-/\n\n",
 "tendsto_cocompact":
 "#print ClosedEmbedding.tendsto_cocompact /-\n/-- A closed embedding is proper, ie, inverse images of compact sets are contained in compacts.\nMoreover, the preimage of a compact set is compact, see `closed_embedding.is_compact_preimage`. -/\ntheorem ClosedEmbedding.tendsto_cocompact {f : α → β} (hf : ClosedEmbedding f) :\n    Tendsto f (Filter.cocompact α) (Filter.cocompact β) :=\n  Filter.hasBasis_cocompact.tendsto_right_iff.mpr fun K hK => (hf.is_compact_preimage hK).compl_mem_cocompact\n#align closed_embedding.tendsto_cocompact ClosedEmbedding.tendsto_cocompact\n-/\n\n",
 "symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print NhdsContainBoxes.symm /-\ntheorem NhdsContainBoxes.symm {s : Set α} {t : Set β} : NhdsContainBoxes s t → NhdsContainBoxes t s := fun H n hn hp =>\n  let ⟨u, v, uo, vo, su, tv, p⟩ :=\n    H («expr ⁻¹' » Prod.swap n) (hn.preimage continuous_swap) (by rwa [← image_subset_iff, image_swap_prod])\n  ⟨v, u, vo, uo, tv, su, by rwa [← image_subset_iff, image_swap_prod] at p⟩\n#align nhds_contain_boxes.symm NhdsContainBoxes.symm\n-/\n\n",
 "subset_succ":
 "theorem subset_succ (n : ℕ) : K n ⊆ K (n + 1) :=\n  Subset.trans (K.subset_interior_succ n) interior_subset\n#align subset_succ subset_succ\n\n",
 "subset_irreducible":
 "#print IsPreirreducible.subset_irreducible /-\n/-- If `∅ ≠ U ⊆ S ⊆ Z` such that `U` is open and `Z` is preirreducible, then `S` is irreducible. -/\ntheorem IsPreirreducible.subset_irreducible {S U Z : Set α} (hZ : IsPreirreducible Z) (hU : U.nonempty) (hU' : IsOpen U)\n    (h₁ : U ⊆ S) (h₂ : S ⊆ Z) : IsIrreducible S := by\n  classical\n    obtain ⟨z, hz⟩ := hU\n    replace hZ : IsIrreducible Z := ⟨⟨z, h₂ (h₁ hz)⟩, hZ⟩\n    refine' ⟨⟨z, h₁ hz⟩, _⟩\n    rintro u v hu hv ⟨x, hx, hx'⟩ ⟨y, hy, hy'⟩\n    obtain ⟨a, -, ha'⟩ := is_irreducible_iff_sInter.mp hZ {U, u, v} (by tidy) _\n    replace ha' : a ∈ U ∧ a ∈ u ∧ a ∈ v := by simpa using ha'\n    exact ⟨a, h₁ ha'.1, ha'.2⟩\n    · intro U H\n      simp only [Finset.mem_insert, Finset.mem_singleton] at H\n      rcases H with (rfl | rfl | rfl)\n      exacts[⟨z, h₂ (h₁ hz), hz⟩, ⟨x, h₂ hx, hx'⟩, ⟨y, h₂ hy, hy'⟩]\n#align is_preirreducible.subset_irreducible IsPreirreducible.subset_irreducible\n-/\n\n",
 "subset_interior_succ":
 "theorem subset_interior_succ (n : ℕ) : K n ⊆ interior (K (n + 1)) :=\n  K.subset_interior_succ' n\n#align subset_interior_succ subset_interior_succ\n\n",
 "subset_interior":
 "theorem subset_interior ⦃m n : ℕ⦄ (h : m < n) : K m ⊆ interior (K n) :=\n  Subset.trans (K.subset_interior_succ m) <| interior_mono <| K.subset h\n#align subset_interior subset_interior\n\n",
 "subset_closure_inter_of_isPreirreducible_of_isOpen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print subset_closure_inter_of_isPreirreducible_of_isOpen /-\n/-- A nonemtpy open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem subset_closure_inter_of_isPreirreducible_of_isOpen {S U : Set α} (hS : IsPreirreducible S) (hU : IsOpen U)\n    (h : (S ∩ U).nonempty) : S ⊆ closure (S ∩ U) := by\n  by_contra h'\n  obtain ⟨x, h₁, h₂, h₃⟩ :=\n    hS _ («expr ᶜ» (closure (S ∩ U))) hU (is_open_compl_iff.mpr isClosed_closure) h\n      (set.inter_compl_nonempty_iff.mpr h')\n  exact h₃ (subset_closure ⟨h₁, h₂⟩)\n#align subset_closure_inter_of_is_preirreducible_of_is_open subset_closure_inter_of_isPreirreducible_of_isOpen\n-/\n\n",
 "subset":
 "@[mono]\nprotected theorem subset ⦃m n : ℕ⦄ (h : m ≤ n) : K m ⊆ K n :=\n  show K m ≤ K n from monotone_nat_of_le_succ K.subset_succ h\n#align subset subset\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print IsClopen.prod /-\ntheorem IsClopen.prod {s : Set α} {t : Set β} (hs : IsClopen s) (ht : IsClopen t) : IsClopen (lower_set.prod s t) :=\n  ⟨hs.1.prod ht.1, hs.2.prod ht.2⟩\n#align is_clopen.prod IsClopen.prod\n-/\n\n",
 "preirreducibleSpace":
 "#print Subtype.preirreducibleSpace /-\ntheorem Subtype.preirreducibleSpace {s : Set α} (h : IsPreirreducible s) : PreirreducibleSpace s :=\n  {\n    is_preirreducible_univ := by\n      intro u v hu hv hsu hsv\n      rw [isOpen_induced_iff] at hu hv\n      rcases hu with ⟨u, hu, rfl⟩\n      rcases hv with ⟨v, hv, rfl⟩\n      rcases hsu with ⟨⟨x, hxs⟩, hxs', hxu⟩\n      rcases hsv with ⟨⟨y, hys⟩, hys', hyv⟩\n      rcases h u v hu hv ⟨x, hxs, hxu⟩ ⟨y, hys, hyv⟩ with ⟨z, hzs, ⟨hzu, hzv⟩⟩\n      exact ⟨⟨z, hzs⟩, ⟨Set.mem_univ _, ⟨hzu, hzv⟩⟩⟩ }\n#align subtype.preirreducible_space Subtype.preirreducibleSpace\n-/\n\n",
 "preimage_clopen_of_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print ContinuousOn.preimage_clopen_of_clopen /-\ntheorem ContinuousOn.preimage_clopen_of_clopen {f : α → β} {s : Set α} {t : Set β} (hf : ContinuousOn f s)\n    (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s ∩ «expr ⁻¹' » f t) :=\n  ⟨ContinuousOn.preimage_open_of_open hf hs.1 ht.1, ContinuousOn.preimage_closed_of_closed hf hs.2 ht.2⟩\n#align continuous_on.preimage_clopen_of_clopen ContinuousOn.preimage_clopen_of_clopen\n-/\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print IsPreirreducible.preimage /-\ntheorem IsPreirreducible.preimage {Z : Set α} (hZ : IsPreirreducible Z) {f : β → α} (hf : OpenEmbedding f) :\n    IsPreirreducible («expr ⁻¹' » f Z) :=\n  by\n  rintro U V hU hV ⟨x, hx, hx'⟩ ⟨y, hy, hy'⟩\n  obtain ⟨_, h₁, ⟨z, h₂, rfl⟩, ⟨z', h₃, h₄⟩⟩ :=\n    hZ _ _ (hf.is_open_map _ hU) (hf.is_open_map _ hV) ⟨f x, hx, Set.mem_image_of_mem f hx'⟩\n      ⟨f y, hy, Set.mem_image_of_mem f hy'⟩\n  cases hf.inj h₄\n  exact ⟨z, h₁, h₂, h₃⟩\n#align is_preirreducible.preimage IsPreirreducible.preimage\n-/\n\n",
 "open_subset":
 "#print IsPreirreducible.open_subset /-\ntheorem IsPreirreducible.open_subset {Z U : Set α} (hZ : IsPreirreducible Z) (hU : IsOpen U) (hU' : U ⊆ Z) :\n    IsPreirreducible U :=\n  U.eq_empty_or_nonempty.elim (fun h => h.symm ▸ isPreirreducible_empty) fun h =>\n    (hZ.subset_irreducible h hU (fun _ => id) hU').2\n#align is_preirreducible.open_subset IsPreirreducible.open_subset\n-/\n\n",
 "of_countable":
 "#print SigmaCompactSpace.of_countable /-\n-- see Note [lower instance priority]\ntheorem SigmaCompactSpace.of_countable (S : Set (Set α)) (Hc : S.countable) (Hcomp : ∀ s ∈ S, IsCompact s)\n    (HU : ⋃₀ S = univ) : SigmaCompactSpace α :=\n  ⟨(exists_seq_cover_iff_countable ⟨_, isCompact_empty⟩).2 ⟨S, Hc, Hcomp, HU⟩⟩\n#align sigma_compact_space.of_countable SigmaCompactSpace.of_countable\n-/\n\n",
 "not_compactSpace_iff":
 "#print not_compactSpace_iff /-\ntheorem not_compactSpace_iff : ¬CompactSpace α ↔ NoncompactSpace α :=\n  ⟨fun h₁ => ⟨fun h₂ => h₁ ⟨h₂⟩⟩, fun ⟨h₁⟩ ⟨h₂⟩ => h₁ h₂⟩\n#align not_compact_space_iff not_compactSpace_iff\n-/\n\n",
 "nonempty_preirreducible_inter":
 "#print nonempty_preirreducible_inter /-\ntheorem nonempty_preirreducible_inter [PreirreducibleSpace α] {s t : Set α} :\n    IsOpen s → IsOpen t → s.nonempty → t.nonempty → (s ∩ t).nonempty := by\n  simpa only [univ_inter, univ_subset_iff] using @preirreducible_space.is_preirreducible_univ α _ _ s t\n#align nonempty_preirreducible_inter nonempty_preirreducible_inter\n-/\n\n",
 "nonempty_interᵢ_of_sequence_nonempty_compact_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print IsCompact.nonempty_interᵢ_of_sequence_nonempty_compact_closed /-\n/-- Cantor's intersection theorem for sequences indexed by `ℕ`:\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. -/\ntheorem IsCompact.nonempty_interᵢ_of_sequence_nonempty_compact_closed (Z : ℕ → Set α) (hZd : ∀ i, Z (i + 1) ⊆ Z i)\n    (hZn : ∀ i, (Z i).nonempty) (hZ0 : IsCompact (Z 0)) (hZcl : ∀ i, IsClosed (Z i)) :\n    («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i)).nonempty :=\n  have Zmono : Antitone Z := antitone_nat_of_succ_le hZd\n  have hZd : Directed («expr ⊇ » · ·) Z := directed_of_sup Zmono\n  have : ∀ i, Z i ⊆ Z 0 := fun i => Zmono <| zero_le i\n  have hZc : ∀ i, IsCompact (Z i) := fun i => isCompact_of_isClosed_subset hZ0 (hZcl i) (this i)\n  IsCompact.nonempty_interᵢ_of_directed_nonempty_compact_closed Z hZd hZn hZc hZcl\n#align is_compact.nonempty_Inter_of_sequence_nonempty_compact_closed IsCompact.nonempty_interᵢ_of_sequence_nonempty_compact_closed\n-/\n\n",
 "nonempty_interᵢ_of_directed_nonempty_compact_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print IsCompact.nonempty_interᵢ_of_directed_nonempty_compact_closed /-\n/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem IsCompact.nonempty_interᵢ_of_directed_nonempty_compact_closed {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α)\n    (hZd : Directed («expr ⊇ » · ·) Z) (hZn : ∀ i, (Z i).nonempty) (hZc : ∀ i, IsCompact (Z i))\n    (hZcl : ∀ i, IsClosed (Z i)) :\n    («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i)).nonempty :=\n  by\n  apply hι.elim\n  intro i₀\n  let Z' i := Z i ∩ Z i₀\n  suffices\n    («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z' i)).nonempty by\n    exact this.mono (Inter_mono fun i => inter_subset_left (Z i) (Z i₀))\n  rw [nonempty_iff_ne_empty]\n  intro H\n  obtain ⟨t, ht⟩ :\n    ∃ t : Finset ι,\n      Z i₀ ∩ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z' i) = ∅\n  exact (hZc i₀).elim_finite_subfamily_closed Z' (fun i => IsClosed.inter (hZcl i) (hZcl i₀)) (by rw [H, inter_empty])\n  obtain ⟨i₁, hi₁⟩ : ∃ i₁ : ι, Z i₁ ⊆ Z i₀ ∧ ∀ i ∈ t, Z i₁ ⊆ Z' i :=\n    by\n    rcases Directed.finset_le hZd t with ⟨i, hi⟩\n    rcases hZd i i₀ with ⟨i₁, hi₁, hi₁₀⟩\n    use i₁, hi₁₀\n    intro j hj\n    exact subset_inter (subset.trans hi₁ (hi j hj)) hi₁₀\n  suffices\n    (Z i₀ ∩\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z' i)).nonempty\n    by\n    rw [nonempty_iff_ne_empty] at this\n    contradiction\n  exact (hZn i₁).mono (subset_inter hi₁.left <| subset_Inter₂ hi₁.right)\n#align is_compact.nonempty_Inter_of_directed_nonempty_compact_closed IsCompact.nonempty_interᵢ_of_directed_nonempty_compact_closed\n-/\n\n",
 "nonempty":
 "#print IsIrreducible.nonempty /-\ntheorem IsIrreducible.nonempty {s : Set α} (h : IsIrreducible s) : s.nonempty :=\n  h.1\n#align is_irreducible.nonempty IsIrreducible.nonempty\n-/\n\n",
 "noncompactSpace_of_neBot":
 "#print noncompactSpace_of_neBot /-\ntheorem noncompactSpace_of_neBot (h : NeBot (Filter.cocompact α)) : NoncompactSpace α :=\n  ⟨fun h' => (Filter.nonempty_of_mem h'.compl_mem_cocompact).ne_empty compl_univ⟩\n#align noncompact_space_of_ne_bot noncompactSpace_of_neBot\n-/\n\n",
 "noncompactSpace_iff":
 "#print Prod.noncompactSpace_iff /-\ntheorem Prod.noncompactSpace_iff :\n    NoncompactSpace (α × β) ↔ NoncompactSpace α ∧ Nonempty β ∨ Nonempty α ∧ NoncompactSpace β := by\n  simp [← Filter.cocompact_neBot_iff, ← Filter.coprod_cocompact, Filter.coprod_neBot_iff]\n#align prod.noncompact_space_iff Prod.noncompactSpace_iff\n-/\n\n",
 "noncompactSpace":
 "#print ClosedEmbedding.noncompactSpace /-\nprotected theorem ClosedEmbedding.noncompactSpace [NoncompactSpace α] {f : α → β} (hf : ClosedEmbedding f) :\n    NoncompactSpace β :=\n  noncompactSpace_of_neBot hf.tendsto_cocompact.ne_bot\n#align closed_embedding.noncompact_space ClosedEmbedding.noncompactSpace\n-/\n\n",
 "nhdsContainBoxes_of_singleton":
 "#print nhdsContainBoxes_of_singleton /-\ntheorem nhdsContainBoxes_of_singleton {x : α} {y : β} : NhdsContainBoxes ({x} : Set α) ({y} : Set β) := fun n hn hp =>\n  let ⟨u, v, uo, vo, xu, yv, hp'⟩ := isOpen_prod_iff.mp hn x y (hp <| by simp)\n  ⟨u, v, uo, vo, by simpa, by simpa, hp'⟩\n#align nhds_contain_boxes_of_singleton nhdsContainBoxes_of_singleton\n-/\n\n",
 "nhdsContainBoxes_of_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print nhdsContainBoxes_of_compact /-\ntheorem nhdsContainBoxes_of_compact {s : Set α} (hs : IsCompact s) (t : Set β)\n    (H : ∀ x ∈ s, NhdsContainBoxes ({x} : Set α) t) : NhdsContainBoxes s t := fun n hn hp =>\n  have :\n    ∀ x : s, ∃ uv : Set α × Set β, IsOpen uv.1 ∧ IsOpen uv.2 ∧ {↑x} ⊆ uv.1 ∧ t ⊆ uv.2 ∧ lower_set.prod uv.1 uv.2 ⊆ n :=\n    fun ⟨x, hx⟩ =>\n    have : lower_set.prod ({x} : Set α) t ⊆ n := Subset.trans (prod_mono (by simpa) Subset.rfl) hp\n    let ⟨ux, vx, H1⟩ := H x hx n hn this\n    ⟨⟨ux, vx⟩, H1⟩\n  let ⟨uvs, h⟩ := classical.axiom_of_choice this\n  have us_cover :\n    s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (uvs i).1 :=\n    fun x hx => subset_unionᵢ _ ⟨x, hx⟩ (by simpa using (h ⟨x, hx⟩).2.2.1)\n  let ⟨s0, s0_cover⟩ := hs.elim_finite_subcover _ (fun i => (h i).1) us_cover\n  let u := «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (uvs i).1\n  let v := «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (uvs i).2\n  have : IsOpen u := isOpen_bunionᵢ fun i _ => (h i).1\n  have : IsOpen v := isOpen_binterᵢ s0.finite_to_set fun i _ => (h i).2.1\n  have : t ⊆ v := subset_interᵢ₂ fun i _ => (h i).2.2.2.1\n  have : lower_set.prod u v ⊆ n := fun ⟨x', y'⟩ ⟨hx', hy'⟩ =>\n    have : ∃ i ∈ s0, x' ∈ (uvs i).1 := by simpa using hx'\n    let ⟨i, is0, hi⟩ := this\n    (h i).2.2.2.2 ⟨hi, (binterᵢ_subset_of_mem is0 : v ⊆ (uvs i).2) hy'⟩\n  ⟨u, v, ‹IsOpen u›, ‹IsOpen v›, s0_cover, ‹t ⊆ v›, ‹lower_set.prod u v ⊆ n›⟩\n#align nhds_contain_boxes_of_compact nhdsContainBoxes_of_compact\n-/\n\n",
 "ne_univ":
 "#print IsCompact.ne_univ /-\ntheorem IsCompact.ne_univ [NoncompactSpace α] {s : Set α} (hs : IsCompact s) : s ≠ univ := fun h =>\n  noncompact_univ α (h ▸ hs)\n#align is_compact.ne_univ IsCompact.ne_univ\n-/\n\n",
 "mem_irreducibleComponent":
 "#print mem_irreducibleComponent /-\ntheorem mem_irreducibleComponent {x : α} : x ∈ irreducibleComponent x :=\n  singleton_subset_iff.1 (irreducibleComponent_property x).2.1\n#align mem_irreducible_component mem_irreducibleComponent\n-/\n\n",
 "mem_iff_find_le":
 "theorem mem_iff_find_le {x : α} {n : ℕ} : x ∈ K n ↔ K.find x ≤ n :=\n  ⟨fun h => nat.find_min' (K.exists_mem x) h, fun h => K.subset h <| K.mem_find x⟩\n#align mem_iff_find_le mem_iff_find_le\n\n",
 "mem_find":
 "theorem mem_find (x : α) : x ∈ K (K.find x) :=\n  nat.find_spec (K.exists_mem x)\n#align mem_find mem_find\n\n",
 "mem_diff_shiftr_find":
 "theorem mem_diff_shiftr_find (x : α) : x ∈ K.shiftr (K.find x + 1) \\ K.shiftr (K.find x) :=\n  ⟨K.mem_find _, mt K.shiftr.mem_iff_find_le.1 <| by simp only [find_shiftr, not_le, nat.lt_succ_self]⟩\n#align mem_diff_shiftr_find mem_diff_shiftr_find\n\n",
 "mem_cocompact'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_cocompact' : s ∈ cocompact α ↔ ∃ t, IsCompact t ∧ «expr ᶜ» s ⊆ t :=\n  mem_cocompact.trans <| exists_congr fun t => and_congr_right fun ht => compl_subset_comm\n#align mem_cocompact' mem_cocompact'\n\n",
 "mem_cocompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_cocompact : s ∈ cocompact α ↔ ∃ t, IsCompact t ∧ «expr ᶜ» t ⊆ s :=\n  hasBasis_cocompact.mem_iff.trans <| exists_congr fun t => exists_prop\n#align mem_cocompact mem_cocompact\n\n",
 "mem_coclosed_compact'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_coclosed_compact' : s ∈ coclosedCompact α ↔ ∃ t, IsClosed t ∧ IsCompact t ∧ «expr ᶜ» s ⊆ t := by\n  simp only [mem_coclosed_compact, compl_subset_comm]\n#align mem_coclosed_compact' mem_coclosed_compact'\n\n",
 "mem_coclosed_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_coclosed_compact : s ∈ coclosedCompact α ↔ ∃ t, IsClosed t ∧ IsCompact t ∧ «expr ᶜ» t ⊆ s := by\n  simp [has_basis_coclosed_compact.mem_iff, and_assoc']\n#align mem_coclosed_compact mem_coclosed_compact\n\n",
 "locallyCompactSpace_of_hasBasis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print locallyCompactSpace_of_hasBasis /-\ntheorem locallyCompactSpace_of_hasBasis {ι : α → Type _} {p : ∀ x, ι x → Prop} {s : ∀ x, ι x → Set α}\n    (h : ∀ x, ((nhds) x).has_basis (p x) (s x)) (hc : ∀ x i, p x i → IsCompact (s x i)) : LocallyCompactSpace α :=\n  ⟨fun x t ht =>\n    let ⟨i, hp, ht⟩ := (h x).mem_iff.1 ht\n    ⟨s x i, (h x).mem_of_mem hp, ht, hc x i hp⟩⟩\n#align locally_compact_space_of_has_basis locallyCompactSpace_of_hasBasis\n-/\n\n",
 "locallyCompactSpace":
 "#print IsOpen.locallyCompactSpace /-\nprotected theorem IsOpen.locallyCompactSpace [LocallyCompactSpace α] {s : Set α} (hs : IsOpen s) :\n    LocallyCompactSpace s :=\n  hs.open_embedding_subtype_coe.locally_compact_space\n#align is_open.locally_compact_space IsOpen.locallyCompactSpace\n-/\n\n",
 "local_compact_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print local_compact_nhds /-\ntheorem local_compact_nhds [LocallyCompactSpace α] {x : α} {n : Set α} (h : n ∈ (nhds) x) :\n    ∃ s ∈ (nhds) x, s ⊆ n ∧ IsCompact s :=\n  locally_compact_space.local_compact_nhds _ _ h\n#align local_compact_nhds local_compact_nhds\n-/\n\n",
 "le_nhds_lim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Ultrafilter.le_nhds_lim /-\ntheorem Ultrafilter.le_nhds_lim [CompactSpace α] (F : Ultrafilter α) :\n    ↑F ≤ (nhds) (@lim _ _ (F : Filter α).nonempty_of_ne_bot F) :=\n  by\n  rcases is_compact_univ.ultrafilter_le_nhds F (by simp) with ⟨x, -, h⟩\n  exact le_nhds_lim ⟨x, h⟩\n#align ultrafilter.le_nhds_Lim Ultrafilter.le_nhds_lim\n-/\n\n",
 "is_compact_insert_range_of_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto.is_compact_insert_range_of_cofinite {f : ι → α} {a} (hf : Tendsto f cofinite ((nhds) a)) :\n    IsCompact (insert a (range f)) := by\n  letI : TopologicalSpace ι := «expr⊥»; haveI := discreteTopology_bot ι\n  rw [← cocompact_eq_cofinite] at hf\n  exact hf.is_compact_insert_range_of_cocompact continuous_of_discreteTopology\n#align tendsto.is_compact_insert_range_of_cofinite tendsto.is_compact_insert_range_of_cofinite\n\n",
 "is_compact_insert_range_of_cocompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto.is_compact_insert_range_of_cocompact {f : α → β} {b} (hf : Tendsto f (cocompact α) ((nhds) b))\n    (hfc : Continuous f) : IsCompact (insert b (range f)) :=\n  by\n  intro l hne hle\n  by_cases hb : ClusterPt b l\n  · exact ⟨b, or.inl rfl, hb⟩\n  simp only [clusterPt_iff, not_forall, ← not_disjoint_iff_nonempty_inter, Classical.not_not] at hb\n  rcases hb with ⟨s, hsb, t, htl, hd⟩\n  rcases mem_cocompact.1 (hf hsb) with ⟨K, hKc, hKs⟩\n  have : «expr '' » f K ∈ l := by\n    filter_upwards [htl, le_principal_iff.1 hle]with y hyt hyf\n    rcases hyf with (rfl | ⟨x, rfl⟩)\n    exacts[(hd.le_bot ⟨mem_of_mem_nhds hsb, hyt⟩).elim,\n      mem_image_of_mem _ (Classical.not_not.1 fun hxK => hd.le_bot ⟨hKs hxK, hyt⟩)]\n  rcases hKc.image hfc (le_principal_iff.2 this) with ⟨y, hy, hyl⟩\n  exact ⟨y, or.inr <| image_subset_range _ _ hy, hyl⟩\n#align tendsto.is_compact_insert_range_of_cocompact tendsto.is_compact_insert_range_of_cocompact\n\n",
 "is_compact_insert_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto.is_compact_insert_range {f : ℕ → α} {a} (hf : Tendsto f atTop ((nhds) a)) :\n    IsCompact (insert a (range f)) :=\n  Filter.Tendsto.isCompact_insert_range_of_cofinite <| Nat.cofinite_eq_atTop.symm ▸ hf\n#align tendsto.is_compact_insert_range tendsto.is_compact_insert_range\n\n",
 "is_bounded_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem in_compact.is_bounded_iff : @IsBounded _ (inCompact α) s ↔ ∃ t, IsCompact t ∧ s ⊆ t :=\n  by\n  change «expr ᶜ» s ∈ Filter.cocompact α ↔ _\n  rw [Filter.mem_cocompact]\n  simp\n#align in_compact.is_bounded_iff in_compact.is_bounded_iff\n\n",
 "isPreirreducible_iff_closure":
 "#print isPreirreducible_iff_closure /-\ntheorem isPreirreducible_iff_closure {s : Set α} : IsPreirreducible (closure s) ↔ IsPreirreducible s :=\n  forall₄_congr fun u v hu hv => by\n    iterate 3 rw [closure_inter_open_nonempty_iff]\n    exacts[hu.inter hv, hv, hu]\n#align is_preirreducible_iff_closure isPreirreducible_iff_closure\n-/\n\n",
 "isPreirreducible_iff_closed_union_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print isPreirreducible_iff_closed_union_closed /-\n/-- A set is preirreducible if and only if\nfor every cover by two closed sets, it is contained in one of the two covering sets. -/\ntheorem isPreirreducible_iff_closed_union_closed {s : Set α} :\n    IsPreirreducible s ↔ ∀ z₁ z₂ : Set α, IsClosed z₁ → IsClosed z₂ → s ⊆ z₁ ∪ z₂ → s ⊆ z₁ ∨ s ⊆ z₂ :=\n  by\n  constructor\n  all_goals\n    intro h t₁ t₂ ht₁ ht₂\n    specialize h («expr ᶜ» t₁) («expr ᶜ» t₂)\n    simp only [isOpen_compl_iff, isClosed_compl_iff] at h\n    specialize h ht₁ ht₂\n  · contrapose!\n    simp only [not_subset]\n    rintro ⟨⟨x, hx, hx'⟩, ⟨y, hy, hy'⟩⟩\n    rcases h ⟨x, hx, hx'⟩ ⟨y, hy, hy'⟩ with ⟨z, hz, hz'⟩\n    rw [← compl_union] at hz'\n    exact ⟨z, hz, hz'⟩\n  · rintro ⟨x, hx, hx'⟩ ⟨y, hy, hy'⟩\n    rw [← compl_inter] at h\n    delta Set.Nonempty\n    rw [imp_iff_not_or] at h\n    contrapose! h\n    constructor\n    · intro z hz hz'\n      exact h z ⟨hz, hz'⟩\n    · constructor <;> intro H <;> refine' H _ ‹_› <;> assumption\n#align is_preirreducible_iff_closed_union_closed isPreirreducible_iff_closed_union_closed\n-/\n\n",
 "isPreirreducible_empty":
 "#print isPreirreducible_empty /-\ntheorem isPreirreducible_empty : IsPreirreducible (∅ : Set α) := fun _ _ _ _ _ ⟨x, h1, h2⟩ => h1.elim\n#align is_preirreducible_empty isPreirreducible_empty\n-/\n\n",
 "isPreirreducible":
 "#print Set.Subsingleton.isPreirreducible /-\ntheorem Set.Subsingleton.isPreirreducible {s : Set α} (hs : s.subsingleton) : IsPreirreducible s :=\n  fun u v hu hv ⟨x, hxs, hxu⟩ ⟨y, hys, hyv⟩ => ⟨y, hys, hs hxs hys ▸ hxu, hyv⟩\n#align set.subsingleton.is_preirreducible Set.Subsingleton.isPreirreducible\n-/\n\n",
 "isOpen":
 "#print IsClopen.isOpen /-\nprotected theorem IsClopen.isOpen (hs : IsClopen s) : IsOpen s :=\n  hs.1\n#align is_clopen.is_open IsClopen.isOpen\n-/\n\n",
 "isIrreducible_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print IrreducibleSpace.isIrreducible_univ /-\n-- see Note [lower instance priority]\ntheorem IrreducibleSpace.isIrreducible_univ (α : Type u) [TopologicalSpace α] [IrreducibleSpace α] :\n    IsIrreducible («expr⊤» : Set α) :=\n  ⟨by simp, preirreducible_space.is_preirreducible_univ α⟩\n#align irreducible_space.is_irreducible_univ IrreducibleSpace.isIrreducible_univ\n-/\n\n",
 "isIrreducible_singleton":
 "#print isIrreducible_singleton /-\ntheorem isIrreducible_singleton {x} : IsIrreducible ({x} : Set α) :=\n  ⟨singleton_nonempty x, subsingleton_singleton.is_preirreducible⟩\n#align is_irreducible_singleton isIrreducible_singleton\n-/\n\n",
 "isIrreducible_irreducibleComponent":
 "#print isIrreducible_irreducibleComponent /-\ntheorem isIrreducible_irreducibleComponent {x : α} : IsIrreducible (irreducibleComponent x) :=\n  ⟨⟨x, mem_irreducibleComponent⟩, (irreducibleComponent_property x).1⟩\n#align is_irreducible_irreducible_component isIrreducible_irreducibleComponent\n-/\n\n",
 "isIrreducible_iff_unionₛ_closed":
 "#print isIrreducible_iff_unionₛ_closed /-\n/-- A set is irreducible if and only if\nfor every cover by a finite collection of closed sets,\nit is contained in one of the members of the collection. -/\ntheorem isIrreducible_iff_unionₛ_closed {s : Set α} :\n    IsIrreducible s ↔ ∀ (Z : Finset (Set α)) (hZ : ∀ z ∈ Z, IsClosed z) (H : s ⊆ ⋃₀ ↑Z), ∃ z ∈ Z, s ⊆ z :=\n  by\n  rw [IsIrreducible, isPreirreducible_iff_closed_union_closed]\n  constructor <;> intro h\n  · intro Z\n    apply Finset.induction_on Z\n    · intros\n      rw [Finset.coe_empty, sUnion_empty] at H\n      rcases h.1 with ⟨x, hx⟩\n      exfalso\n      tauto\n    · intro z Z hz IH hZ H\n      cases' h.2 z (⋃₀ ↑Z) _ _ _ with h' h'\n      · exact ⟨z, Finset.mem_insert_self _ _, h'⟩\n      · rcases IH _ h' with ⟨z', hz', hsz'⟩\n        · exact ⟨z', Finset.mem_insert_of_mem hz', hsz'⟩\n        · intros\n          solve_by_elim [Finset.mem_insert_of_mem]\n      · solve_by_elim [Finset.mem_insert_self]\n      · rw [sUnion_eq_bUnion]\n        apply isClosed_bunionᵢ (Finset.finite_toSet Z)\n        · intros\n          solve_by_elim [Finset.mem_insert_of_mem]\n      · simpa using H\n  · constructor\n    · by_contra hs\n      simpa using h ∅ _ _\n      · intro z\n        simp\n      · simpa [Set.Nonempty] using hs\n    intro z₁ z₂ hz₁ hz₂ H\n    have := h {z₁, z₂} _ _\n    simp only [exists_prop, Finset.mem_insert, Finset.mem_singleton] at this\n    · rcases this with ⟨z, rfl | rfl, hz⟩ <;> tauto\n    · intro t\n      rw [Finset.mem_insert, Finset.mem_singleton]\n      rintro (rfl | rfl) <;> assumption\n    · simpa using H\n#align is_irreducible_iff_sUnion_closed isIrreducible_iff_unionₛ_closed\n-/\n\n",
 "isIrreducible_iff_interₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n#print isIrreducible_iff_interₛ /-\n/-- A set `s` is irreducible if and only if\nfor every finite collection of open sets all of whose members intersect `s`,\n`s` also intersects the intersection of the entire collection\n(i.e., there is an element of `s` contained in every member of the collection). -/\ntheorem isIrreducible_iff_interₛ {s : Set α} :\n    IsIrreducible s ↔\n      ∀ (U : Finset (Set α)) (hU : ∀ u ∈ U, IsOpen u) (H : ∀ u ∈ U, (s ∩ u).nonempty), (s ∩ «expr⋂₀ » ↑U).nonempty :=\n  by\n  constructor <;> intro h\n  · intro U\n    apply Finset.induction_on U\n    · intros\n      simpa using h.nonempty\n    · intro u U hu IH hU H\n      rw [Finset.coe_insert, sInter_insert]\n      apply h.2\n      · solve_by_elim [Finset.mem_insert_self]\n      · apply isOpen_interₛ (Finset.finite_toSet U)\n        intros\n        solve_by_elim [Finset.mem_insert_of_mem]\n      · solve_by_elim [Finset.mem_insert_self]\n      · apply IH\n        all_goals intros ; solve_by_elim [Finset.mem_insert_of_mem]\n  · constructor\n    · simpa using h ∅ _ _ <;> intro u <;> simp\n    intro u v hu hv hu' hv'\n    simpa using h {u, v} _ _\n    all_goals\n      intro t\n      rw [Finset.mem_insert, Finset.mem_singleton]\n      rintro (rfl | rfl) <;> assumption\n#align is_irreducible_iff_sInter isIrreducible_iff_interₛ\n-/\n\n",
 "isIrreducible_iff_closure":
 "#print isIrreducible_iff_closure /-\ntheorem isIrreducible_iff_closure {s : Set α} : IsIrreducible (closure s) ↔ IsIrreducible s :=\n  and_congr closure_nonempty_iff isPreirreducible_iff_closure\n#align is_irreducible_iff_closure isIrreducible_iff_closure\n-/\n\n",
 "isCompact_univ_pi":
 "#print isCompact_univ_pi /-\n/-- **Tychonoff's theorem** formulated using `set.pi`: product of compact sets is compact. -/\ntheorem isCompact_univ_pi {s : ∀ i, Set (π i)} (h : ∀ i, IsCompact (s i)) : IsCompact (pi univ s) :=\n  by\n  convert isCompact_pi_infinite h\n  simp only [← mem_univ_pi, set_of_mem_eq]\n#align is_compact_univ_pi isCompact_univ_pi\n-/\n\n",
 "isCompact_univ_iff":
 "#print isCompact_univ_iff /-\n-- see Note [lower instance priority]\ntheorem isCompact_univ_iff : IsCompact (univ : Set α) ↔ CompactSpace α :=\n  ⟨fun h => ⟨h⟩, fun h => h.1⟩\n#align is_compact_univ_iff isCompact_univ_iff\n-/\n\n",
 "isCompact_univ":
 "#print isCompact_univ /-\ntheorem isCompact_univ [h : CompactSpace α] : IsCompact (univ : Set α) :=\n  h.is_compact_univ\n#align is_compact_univ isCompact_univ\n-/\n\n",
 "isCompact_unionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isCompact_unionᵢ /-\ntheorem isCompact_unionᵢ {f : ι → Set α} [Finite ι] (h : ∀ i, IsCompact (f i)) :\n    IsCompact («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  by rw [← bUnion_univ] <;> exact finite_univ.is_compact_bUnion fun i _ => h i\n#align is_compact_Union isCompact_unionᵢ\n-/\n\n",
 "isCompact_singleton":
 "#print isCompact_singleton /-\n@[simp]\ntheorem isCompact_singleton {a : α} : IsCompact ({a} : Set α) := fun f hf hfa =>\n  ⟨a, rfl, ClusterPt.of_le_nhds' (hfa.trans <| by simpa only [principal_singleton] using pure_le_nhds a) hf⟩\n#align is_compact_singleton isCompact_singleton\n-/\n\n",
 "isCompact_range":
 "#print isCompact_range /-\ntheorem isCompact_range [CompactSpace α] {f : α → β} (hf : Continuous f) : IsCompact (range f) := by\n  rw [← image_univ] <;> exact is_compact_univ.image hf\n#align is_compact_range isCompact_range\n-/\n\n",
 "isCompact_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print ClosedEmbedding.isCompact_preimage /-\n/-- The preimage of a compact set under a closed embedding is a compact set. -/\ntheorem ClosedEmbedding.isCompact_preimage {f : α → β} (hf : ClosedEmbedding f) {K : Set β} (hK : IsCompact K) :\n    IsCompact («expr ⁻¹' » f K) := by\n  replace hK := hK.inter_right hf.closed_range\n  rwa [← hf.to_inducing.is_compact_iff, image_preimage_eq_inter_range]\n#align closed_embedding.is_compact_preimage ClosedEmbedding.isCompact_preimage\n-/\n\n",
 "isCompact_pi_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isCompact_pi_infinite /-\n-- See Note [lower instance priority]\n-- See Note [lower instance priority]\n/-- **Tychonoff's theorem**: product of compact sets is compact. -/\ntheorem isCompact_pi_infinite {s : ∀ i, Set (π i)} :\n    (∀ i, IsCompact (s i)) → IsCompact { x : ∀ i, π i | ∀ i, x i ∈ s i } :=\n  by\n  simp only [isCompact_iff_ultrafilter_le_nhds, nhds_pi, Filter.pi, exists_prop, mem_set_of_eq, le_infᵢ_iff,\n    le_principal_iff]\n  intro h f hfs\n  have : ∀ i : ι, ∃ a, a ∈ s i ∧ tendsto (fun x : ∀ i : ι, π i => x i) f ((nhds) a) :=\n    by\n    refine' fun i => h i (f.map _) (mem_map.2 _)\n    exact mem_of_superset hfs fun x hx => hx i\n  choose a ha\n  exact ⟨a, fun i => (ha i).left, fun i => (ha i).right.le_comap⟩\n#align is_compact_pi_infinite isCompact_pi_infinite\n-/\n\n",
 "isCompact_open_iff_eq_finite_unionᵢ_of_isTopologicalBasis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isCompact_open_iff_eq_finite_unionᵢ_of_isTopologicalBasis /-\n/-- If `α` has a basis consisting of compact opens, then an open set in `α` is compact open iff\n  it is a finite union of some elements in the basis -/\ntheorem isCompact_open_iff_eq_finite_unionᵢ_of_isTopologicalBasis (b : ι → Set α)\n    (hb : IsTopologicalBasis (Set.range b)) (hb' : ∀ i, IsCompact (b i)) (U : Set α) :\n    IsCompact U ∧ IsOpen U ↔\n      ∃ s : Set ι,\n        s.finite ∧\n          U = «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (b i) :=\n  by\n  classical\n    constructor\n    · rintro ⟨h₁, h₂⟩\n      obtain ⟨β, f, e, hf⟩ := hb.open_eq_Union h₂\n      choose f' hf' using hf\n      have : b ∘ f' = f := funext hf'\n      subst this\n      obtain ⟨t, ht⟩ := h₁.elim_finite_subcover (b ∘ f') (fun i => hb.is_open (Set.mem_range_self _)) (by rw [e])\n      refine' ⟨t.image f', set.finite.intro inferInstance, le_antisymm _ _⟩\n      · refine' Set.Subset.trans ht _\n        simp only [Set.unionᵢ_subset_iff, coe_coe]\n        intro i hi\n        erw [← Set.unionᵢ_subtype (fun x : ι => x ∈ t.image f') fun i => b i.1]\n        exact Set.subset_unionᵢ (fun i : t.image f' => b i) ⟨_, Finset.mem_image_of_mem _ hi⟩\n      · apply Set.unionᵢ₂_subset\n        rintro i hi\n        obtain ⟨j, hj, rfl⟩ := finset.mem_image.mp hi\n        rw [e]\n        exact Set.subset_unionᵢ (b ∘ f') j\n    · rintro ⟨s, hs, rfl⟩\n      constructor\n      · exact hs.is_compact_bUnion fun i _ => hb' i\n      · apply isOpen_bunionᵢ\n        intro i hi\n        exact hb.is_open (Set.mem_range_self _)\n#align is_compact_open_iff_eq_finite_Union_of_is_topological_basis isCompact_open_iff_eq_finite_unionᵢ_of_isTopologicalBasis\n-/\n\n",
 "isCompact_of_isClosed_subset":
 "#print isCompact_of_isClosed_subset /-\n/-- A closed subset of a compact set is a compact set. -/\ntheorem isCompact_of_isClosed_subset (hs : IsCompact s) (ht : IsClosed t) (h : t ⊆ s) : IsCompact t :=\n  inter_eq_self_of_subset_right h ▸ hs.inter_right ht\n#align is_compact_of_is_closed_subset isCompact_of_isClosed_subset\n-/\n\n",
 "isCompact_of_finite_subfamily_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print isCompact_of_finite_subfamily_closed /-\n/-- A set `s` is compact if for every family of closed sets whose intersection avoids `s`,\nthere exists a finite subfamily whose intersection avoids `s`. -/\ntheorem isCompact_of_finite_subfamily_closed\n    (h :\n      ∀ {ι : Type u} (Z : ι → Set α),\n        (∀ i, IsClosed (Z i)) →\n          s ∩ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i) =\n              ∅ →\n            ∃ t : Finset ι,\n              s ∩\n                  «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n                    (Z i) =\n                ∅) :\n    IsCompact s := fun f hfn hfs =>\n  by_contradiction fun this : ¬∃ x ∈ s, ClusterPt x f =>\n    have hf : ∀ x ∈ s, «expr ⊓ » ((nhds) x) f = «expr⊥» := by\n      simpa only [ClusterPt, not_exists, Classical.not_not, ne_bot_iff]\n    have : ¬∃ x ∈ s, ∀ t ∈ f.sets, x ∈ closure t := fun ⟨x, hxs, hx⟩ =>\n      by\n      have : ∅ ∈ «expr ⊓ » ((nhds) x) f := by rw [empty_mem_iff_bot, hf x hxs]\n      let ⟨t₁, ht₁, t₂, ht₂, ht⟩ := by rw [mem_inf_iff] at this <;> exact this\n      have : ∅ ∈ nhds_within t₂ x := by\n        rw [ht, inter_comm]\n        exact inter_mem_nhdsWithin _ ht₁\n      have : nhds_within t₂ x = «expr⊥» := by rwa [empty_mem_iff_bot] at this\n      simp only [closure_eq_cluster_pts] at hx <;> exact (hx t₂ ht₂).ne this\n    let ⟨t, ht⟩ :=\n      h (fun i : f.sets => closure i.1) (fun i => isClosed_closure)\n        (by simpa [eq_empty_iff_forall_not_mem, not_exists] )\n    have :\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Subtype.val i) ∈\n        f :=\n      t.Inter_mem_sets.2 fun i hi => i.2\n    have :\n      s ∩\n          «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n            (Subtype.val i) ∈\n        f :=\n      inter_mem (le_principal_iff.1 hfs) this\n    have : ∅ ∈ f :=\n      mem_of_superset this fun x ⟨hxs, hx⟩ =>\n        let ⟨i, hit, hxi⟩ :=\n          show ∃ i ∈ t, x ∉ closure (Subtype.val i)\n            by\n            rw [eq_empty_iff_forall_not_mem] at ht\n            simpa [hxs, not_forall] using ht x\n        have : x ∈ closure i.val :=\n          subset_closure\n            (by\n              rw [mem_Inter₂] at hx\n              exact hx i hit)\n        show False from hxi this\n    hfn.ne <| by rwa [empty_mem_iff_bot] at this\n#align is_compact_of_finite_subfamily_closed isCompact_of_finite_subfamily_closed\n-/\n\n",
 "isCompact_of_finite_subcover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isCompact_of_finite_subcover /-\n/-- A set `s` is compact if for every open cover of `s`, there exists a finite subcover. -/\ntheorem isCompact_of_finite_subcover\n    (h :\n      ∀ {ι : Type u} (U : ι → Set α),\n        (∀ i, IsOpen (U i)) →\n          s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i) →\n            ∃ t : Finset ι,\n              s ⊆\n                «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i)) :\n    IsCompact s :=\n  isCompact_of_finite_subfamily_closed fun ι Z hZc hsZ =>\n    let ⟨t, ht⟩ :=\n      h (fun i => «expr ᶜ» (Z i)) (fun i => isOpen_compl_iff.mpr <| hZc i)\n        (by\n          simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_Union, exists_prop, mem_inter_iff,\n            not_and, iff_self_iff, mem_Inter, mem_compl_iff] using hsZ)\n    ⟨t, by\n      simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_Union, exists_prop, mem_inter_iff, not_and,\n        iff_self_iff, mem_Inter, mem_compl_iff] using ht⟩\n#align is_compact_of_finite_subcover isCompact_of_finite_subcover\n-/\n\n",
 "isCompact_iff_ultrafilter_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isCompact_iff_ultrafilter_le_nhds /-\ntheorem isCompact_iff_ultrafilter_le_nhds :\n    IsCompact s ↔ ∀ f : Ultrafilter α, ↑f ≤ (filter.principal) s → ∃ a ∈ s, ↑f ≤ (nhds) a :=\n  by\n  refine' (forall_ne_bot_le_iff _).trans _\n  · rintro f g hle ⟨a, has, haf⟩\n    exact ⟨a, has, haf.mono hle⟩\n  · simp only [Ultrafilter.clusterPt_iff]\n#align is_compact_iff_ultrafilter_le_nhds isCompact_iff_ultrafilter_le_nhds\n-/\n\n",
 "isCompact_iff_isCompact_univ":
 "#print isCompact_iff_isCompact_univ /-\ntheorem isCompact_iff_isCompact_univ {s : Set α} : IsCompact s ↔ IsCompact (univ : Set s) := by\n  rw [isCompact_iff_isCompact_in_subtype, image_univ, Subtype.range_coe] <;> rfl\n#align is_compact_iff_is_compact_univ isCompact_iff_isCompact_univ\n-/\n\n",
 "isCompact_iff_isCompact_in_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isCompact_iff_isCompact_in_subtype /-\ntheorem isCompact_iff_isCompact_in_subtype {p : α → Prop} {s : Set { a // p a }} :\n    IsCompact s ↔ IsCompact («expr '' » (coe : _ → α) s) :=\n  embedding_subtype_val.is_compact_iff_is_compact_image\n#align is_compact_iff_is_compact_in_subtype isCompact_iff_isCompact_in_subtype\n-/\n\n",
 "isCompact_iff_isCompact_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Embedding.isCompact_iff_isCompact_image /-\n/-- If `f : α → β` is an `embedding` (or more generally, an `inducing` map, see\n`inducing.is_compact_iff`), then the image `f '' s` of a set `s` is compact if and only if the set\n`s` is closed. -/\ntheorem Embedding.isCompact_iff_isCompact_image {f : α → β} (hf : Embedding f) :\n    IsCompact s ↔ IsCompact («expr '' » f s) :=\n  hf.to_inducing.is_compact_iff.symm\n#align embedding.is_compact_iff_is_compact_image Embedding.isCompact_iff_isCompact_image\n-/\n\n",
 "isCompact_iff_finite_subfamily_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print isCompact_iff_finite_subfamily_closed /-\n/-- A set `s` is compact if and only if\nfor every family of closed sets whose intersection avoids `s`,\nthere exists a finite subfamily whose intersection avoids `s`. -/\ntheorem isCompact_iff_finite_subfamily_closed :\n    IsCompact s ↔\n      ∀ {ι : Type u} (Z : ι → Set α),\n        (∀ i, IsClosed (Z i)) →\n          s ∩ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i) =\n              ∅ →\n            ∃ t : Finset ι,\n              s ∩\n                  «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n                    (Z i) =\n                ∅ :=\n  ⟨fun hs ι => hs.elim_finite_subfamily_closed, isCompact_of_finite_subfamily_closed⟩\n#align is_compact_iff_finite_subfamily_closed isCompact_iff_finite_subfamily_closed\n-/\n\n",
 "isCompact_iff_finite_subcover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isCompact_iff_finite_subcover /-\n/-- A set `s` is compact if and only if\nfor every open cover of `s`, there exists a finite subcover. -/\ntheorem isCompact_iff_finite_subcover :\n    IsCompact s ↔\n      ∀ {ι : Type u} (U : ι → Set α),\n        (∀ i, IsOpen (U i)) →\n          s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i) →\n            ∃ t : Finset ι,\n              s ⊆\n                «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i) :=\n  ⟨fun hs ι => hs.elim_finite_subcover, isCompact_of_finite_subcover⟩\n#align is_compact_iff_finite_subcover isCompact_iff_finite_subcover\n-/\n\n",
 "isCompact_iff_finite":
 "#print isCompact_iff_finite /-\ntheorem isCompact_iff_finite [DiscreteTopology α] {s : Set α} : IsCompact s ↔ s.finite :=\n  ⟨fun h => h.finite_of_discrete, fun h => h.is_compact⟩\n#align is_compact_iff_finite isCompact_iff_finite\n-/\n\n",
 "isCompact_iff_compactSpace":
 "#print isCompact_iff_compactSpace /-\ntheorem isCompact_iff_compactSpace {s : Set α} : IsCompact s ↔ CompactSpace s :=\n  isCompact_iff_isCompact_univ.trans ⟨fun h => ⟨h⟩, @compact_space.is_compact_univ _ _⟩\n#align is_compact_iff_compact_space isCompact_iff_compactSpace\n-/\n\n",
 "isCompact_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Inducing.isCompact_iff /-\n/-- If `f : α → β` is an `inducing` map, then the image `f '' s` of a set `s` is compact if and only\nif the set `s` is closed. -/\ntheorem Inducing.isCompact_iff {f : α → β} (hf : Inducing f) {s : Set α} : IsCompact («expr '' » f s) ↔ IsCompact s :=\n  by\n  refine' ⟨_, fun hs => hs.image hf.continuous⟩\n  intro hs F F_ne_bot F_le\n  obtain ⟨_, ⟨x, x_in : x ∈ s, rfl⟩, hx : ClusterPt (f x) (map f F)⟩ :=\n    hs\n      (calc\n        map f F ≤ map f ((filter.principal) s) := map_mono F_le\n        _ = (filter.principal) («expr '' » f s) := map_principal\n        )\n  use x, x_in\n  suffices (map f («expr ⊓ » ((nhds) x) F)).ne_bot by simpa [Filter.map_neBot_iff]\n  rwa [calc\n      map f («expr ⊓ » ((nhds) x) F) = map f («expr ⊓ » (comap f <| nhds <| f x) F) := by rw [hf.nhds_eq_comap]\n      _ = «expr ⊓ » ((nhds) (f x)) (map f F) := Filter.push_pull' _ _ _\n      ]\n#align inducing.is_compact_iff Inducing.isCompact_iff\n-/\n\n",
 "isCompact_empty":
 "#print isCompact_empty /-\n@[simp]\ntheorem isCompact_empty : IsCompact (∅ : Set α) := fun f hnf hsf =>\n  Not.elim hnf.ne <| empty_mem_iff_bot.1 <| le_principal_iff.1 hsf\n#align is_compact_empty isCompact_empty\n-/\n\n",
 "isCompact_diagonal":
 "#print isCompact_diagonal /-\ntheorem isCompact_diagonal [CompactSpace α] : IsCompact (diagonal α) :=\n  @range_diag α ▸ isCompact_range (continuous_id.prod_mk continuous_id)\n#align is_compact_diagonal isCompact_diagonal\n-/\n\n",
 "isCompact_compactCovering":
 "#print isCompact_compactCovering /-\n-- see Note [lower instance priority]\ntheorem isCompact_compactCovering (n : ℕ) : IsCompact (compactCovering α n) :=\n  isCompact_accumulate (Classical.choose_spec sigma_compact_space.exists_compact_covering).1 n\n#align is_compact_compact_covering isCompact_compactCovering\n-/\n\n",
 "isCompact_bunionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print Finset.isCompact_bunionᵢ /-\ntheorem Finset.isCompact_bunionᵢ (s : Finset ι) {f : ι → Set α} (hf : ∀ i ∈ s, IsCompact (f i)) :\n    IsCompact («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  s.finite_to_set.is_compact_bUnion hf\n#align finset.is_compact_bUnion Finset.isCompact_bunionᵢ\n-/\n\n",
 "isCompact_accumulate":
 "#print isCompact_accumulate /-\ntheorem isCompact_accumulate {K : ℕ → Set α} (hK : ∀ n, IsCompact (K n)) (n : ℕ) : IsCompact (Accumulate K n) :=\n  (finite_le_nat n).is_compact_bUnion fun k _ => hK k\n#align is_compact_accumulate isCompact_accumulate\n-/\n\n",
 "isCompact":
 "#print IsClosed.isCompact /-\ntheorem IsClosed.isCompact [CompactSpace α] {s : Set α} (h : IsClosed s) : IsCompact s :=\n  isCompact_of_isClosed_subset isCompact_univ h (subset_univ _)\n#align is_closed.is_compact IsClosed.isCompact\n-/\n\n",
 "isClosed_of_mem_irreducibleComponents":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (s «expr ∈ » irreducible_components[irreducible_components] α) -/\n#print isClosed_of_mem_irreducibleComponents /-\ntheorem isClosed_of_mem_irreducibleComponents (s) (_ : s ∈ irreducibleComponents α) : IsClosed s :=\n  by\n  rw [← closure_eq_iff_isClosed, eq_comm]\n  exact subset_closure.antisymm (H.2 H.1.closure subset_closure)\n#align is_closed_of_mem_irreducible_components isClosed_of_mem_irreducibleComponents\n-/\n\n",
 "isClosed_irreducibleComponent":
 "#print isClosed_irreducibleComponent /-\ntheorem isClosed_irreducibleComponent {x : α} : IsClosed (irreducibleComponent x) :=\n  isClosed_of_mem_irreducibleComponents _ (irreducibleComponent_mem_irreducibleComponents x)\n#align is_closed_irreducible_component isClosed_irreducibleComponent\n-/\n\n",
 "isClosedMap_snd_of_compactSpace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print isClosedMap_snd_of_compactSpace /-\n/-- If X is is_compact then pr₂ : X × Y → Y is a closed map -/\ntheorem isClosedMap_snd_of_compactSpace {X : Type _} [TopologicalSpace X] [CompactSpace X] {Y : Type _}\n    [TopologicalSpace Y] : IsClosedMap (Prod.snd : X × Y → Y) :=\n  by\n  set πX := (Prod.fst : X × Y → X)\n  set πY := (Prod.snd : X × Y → Y)\n  intro C(hC : IsClosed C)\n  rw [isClosed_iff_clusterPt] at hC⊢\n  intro y(y_closure : ClusterPt y <| (filter.principal) («expr '' » πY C))\n  have : ne_bot (map πX («expr ⊓ » (comap πY ((nhds) y)) ((filter.principal) C))) :=\n    by\n    suffices ne_bot (map πY («expr ⊓ » (comap πY ((nhds) y)) ((filter.principal) C))) by simpa only [map_ne_bot_iff]\n    convert y_closure\n    calc\n      map πY («expr ⊓ » (comap πY ((nhds) y)) ((filter.principal) C)) =\n          «expr ⊓ » ((nhds) y) (map πY ((filter.principal) C)) :=\n        Filter.push_pull' _ _ _\n      _ = «expr ⊓ » ((nhds) y) ((filter.principal) («expr '' » πY C)) := by rw [map_principal]\n      \n  obtain ⟨x, hx⟩ : ∃ x, ClusterPt x (map πX («expr ⊓ » (comap πY ((nhds) y)) ((filter.principal) C)))\n  exact cluster_point_of_compact _\n  refine' ⟨⟨x, y⟩, _, by simp [πY]⟩\n  apply hC\n  rw [ClusterPt, ← Filter.map_neBot_iff πX]\n  convert hx\n  calc\n    map πX («expr ⊓ » ((nhds) (x, y)) ((filter.principal) C)) =\n        map πX («expr ⊓ » («expr ⊓ » (comap πX ((nhds) x)) (comap πY ((nhds) y))) ((filter.principal) C)) :=\n      by rw [nhds_prod_eq, Filter.prod]\n    _ = map πX («expr ⊓ » («expr ⊓ » (comap πY ((nhds) y)) ((filter.principal) C)) (comap πX ((nhds) x))) := by ac_rfl\n    _ = «expr ⊓ » (map πX («expr ⊓ » (comap πY ((nhds) y)) ((filter.principal) C))) ((nhds) x) := by\n      rw [Filter.push_pull]\n    _ = «expr ⊓ » ((nhds) x) (map πX («expr ⊓ » (comap πY ((nhds) y)) ((filter.principal) C))) := by rw [inf_comm]\n    \n#align is_closed_proj_of_is_compact isClosedMap_snd_of_compactSpace\n-/\n\n",
 "isClosed":
 "#print IsClopen.isClosed /-\nprotected theorem IsClopen.isClosed (hs : IsClopen s) : IsClosed s :=\n  hs.2\n#align is_clopen.is_closed IsClopen.isClosed\n-/\n\n",
 "isClopen_univ":
 "#print isClopen_univ /-\n@[simp]\ntheorem isClopen_univ : IsClopen (univ : Set α) :=\n  ⟨isOpen_univ, isClosed_univ⟩\n#align is_clopen_univ isClopen_univ\n-/\n\n",
 "isClopen_unionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isClopen_unionᵢ /-\ntheorem isClopen_unionᵢ {β : Type _} [Finite β] {s : β → Set α} (h : ∀ i, IsClopen (s i)) :\n    IsClopen («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  ⟨isOpen_unionᵢ (forall_and.1 h).1, isClosed_unionᵢ (forall_and.1 h).2⟩\n#align is_clopen_Union isClopen_unionᵢ\n-/\n\n",
 "isClopen_range_sigmaMk":
 "#print isClopen_range_sigmaMk /-\ntheorem isClopen_range_sigmaMk {ι : Type _} {σ : ι → Type _} [∀ i, TopologicalSpace (σ i)] {i : ι} :\n    IsClopen (Set.range (@sigma.mk ι σ i)) :=\n  ⟨openEmbedding_sigmaMk.open_range, closedEmbedding_sigmaMk.closed_range⟩\n#align clopen_range_sigma_mk isClopen_range_sigmaMk\n-/\n\n",
 "isClopen_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print QuotientMap.isClopen_preimage /-\nprotected theorem QuotientMap.isClopen_preimage {f : α → β} (hf : QuotientMap f) {s : Set β} :\n    IsClopen («expr ⁻¹' » f s) ↔ IsClopen s :=\n  and_congr hf.is_open_preimage hf.is_closed_preimage\n#align quotient_map.is_clopen_preimage QuotientMap.isClopen_preimage\n-/\n\n",
 "isClopen_interᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print isClopen_interᵢ /-\ntheorem isClopen_interᵢ {β : Type _} [Finite β] {s : β → Set α} (h : ∀ i, IsClopen (s i)) :\n    IsClopen («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)) :=\n  ⟨isOpen_interᵢ (forall_and.1 h).1, isClosed_interᵢ (forall_and.1 h).2⟩\n#align is_clopen_Inter isClopen_interᵢ\n-/\n\n",
 "isClopen_inter_of_disjoint_cover_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print isClopen_inter_of_disjoint_cover_clopen /-\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem isClopen_inter_of_disjoint_cover_clopen {Z a b : Set α} (h : IsClopen Z) (cover : Z ⊆ a ∪ b) (ha : IsOpen a)\n    (hb : IsOpen b) (hab : Disjoint a b) : IsClopen (Z ∩ a) :=\n  by\n  refine' ⟨IsOpen.inter h.1 ha, _⟩\n  have : IsClosed (Z ∩ «expr ᶜ» b) := IsClosed.inter h.2 (isClosed_compl_iff.2 hb)\n  convert this using 1\n  refine' (inter_subset_inter_right Z hab.subset_compl_right).antisymm _\n  rintro x ⟨hx₁, hx₂⟩\n  exact ⟨hx₁, by simpa [not_mem_of_mem_compl hx₂] using cover hx₁⟩\n#align is_clopen_inter_of_disjoint_cover_clopen isClopen_inter_of_disjoint_cover_clopen\n-/\n\n",
 "isClopen_iff_frontier_eq_empty":
 "#print isClopen_iff_frontier_eq_empty /-\ntheorem isClopen_iff_frontier_eq_empty {s : Set α} : IsClopen s ↔ frontier s = ∅ :=\n  by\n  rw [IsClopen, ← closure_eq_iff_isClosed, ← interior_eq_iff_isOpen, frontier, diff_eq_empty]\n  refine' ⟨fun h => (h.2.trans h.1.symm).subset, fun h => _⟩\n  exact ⟨interior_subset.antisymm (subset_closure.trans h), (h.trans interior_subset).antisymm subset_closure⟩\n#align is_clopen_iff_frontier_eq_empty isClopen_iff_frontier_eq_empty\n-/\n\n",
 "isClopen_empty":
 "#print isClopen_empty /-\n@[simp]\ntheorem isClopen_empty : IsClopen (∅ : Set α) :=\n  ⟨isOpen_empty, isClosed_empty⟩\n#align is_clopen_empty isClopen_empty\n-/\n\n",
 "isClopen_discrete":
 "#print isClopen_discrete /-\n@[simp]\ntheorem isClopen_discrete [DiscreteTopology α] (x : Set α) : IsClopen x :=\n  ⟨isOpen_discrete _, isClosed_discrete _⟩\n#align is_clopen_discrete isClopen_discrete\n-/\n\n",
 "isClopen_compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print isClopen_compl_iff /-\n@[simp]\ntheorem isClopen_compl_iff {s : Set α} : IsClopen («expr ᶜ» s) ↔ IsClopen s :=\n  ⟨fun h => compl_compl s ▸ IsClopen.compl h, IsClopen.compl⟩\n#align is_clopen_compl_iff isClopen_compl_iff\n-/\n\n",
 "isClopen_bunionᵢ_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isClopen_bunionᵢ_finset /-\ntheorem isClopen_bunionᵢ_finset {β : Type _} {s : Finset β} {f : β → Set α} (h : ∀ i ∈ s, IsClopen <| f i) :\n    IsClopen («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  isClopen_bunionᵢ s.finite_to_set h\n#align is_clopen_bUnion_finset isClopen_bunionᵢ_finset\n-/\n\n",
 "isClopen_bunionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isClopen_bunionᵢ /-\ntheorem isClopen_bunionᵢ {β : Type _} {s : Set β} {f : β → Set α} (hs : s.finite) (h : ∀ i ∈ s, IsClopen <| f i) :\n    IsClopen («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  ⟨isOpen_bunionᵢ fun i hi => (h i hi).1, isClosed_bunionᵢ hs fun i hi => (h i hi).2⟩\n#align is_clopen_bUnion isClopen_bunionᵢ\n-/\n\n",
 "isClopen_binterᵢ_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print isClopen_binterᵢ_finset /-\ntheorem isClopen_binterᵢ_finset {β : Type _} {s : Finset β} {f : β → Set α} (h : ∀ i ∈ s, IsClopen (f i)) :\n    IsClopen («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  isClopen_binterᵢ s.finite_to_set h\n#align is_clopen_bInter_finset isClopen_binterᵢ_finset\n-/\n\n",
 "isClopen_binterᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print isClopen_binterᵢ /-\ntheorem isClopen_binterᵢ {β : Type _} {s : Set β} (hs : s.finite) {f : β → Set α} (h : ∀ i ∈ s, IsClopen (f i)) :\n    IsClopen («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  ⟨isOpen_binterᵢ hs fun i hi => (h i hi).1, isClosed_binterᵢ fun i hi => (h i hi).2⟩\n#align is_clopen_bInter isClopen_binterᵢ\n-/\n\n",
 "irreducibleSpace_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print irreducibleSpace_def /-\ntheorem irreducibleSpace_def (α : Type u) [TopologicalSpace α] : IrreducibleSpace α ↔ IsIrreducible («expr⊤» : Set α) :=\n  ⟨@IrreducibleSpace.isIrreducible_univ α _, fun h =>\n    haveI : PreirreducibleSpace α := ⟨h.2⟩\n    ⟨⟨h.1.some⟩⟩⟩\n#align irreducible_space_def irreducibleSpace_def\n-/\n\n",
 "irreducibleSpace":
 "#print Subtype.irreducibleSpace /-\ntheorem Subtype.irreducibleSpace {s : Set α} (h : IsIrreducible s) : IrreducibleSpace s :=\n  { is_preirreducible_univ := (Subtype.preirreducibleSpace h.is_preirreducible).is_preirreducible_univ\n    to_nonempty := h.nonempty.to_subtype }\n#align subtype.irreducible_space Subtype.irreducibleSpace\n-/\n\n",
 "irreducibleComponents_eq_maximals_closed":
 "#print irreducibleComponents_eq_maximals_closed /-\ntheorem irreducibleComponents_eq_maximals_closed (α : Type _) [TopologicalSpace α] :\n    irreducibleComponents α = maximals (· ≤ ·) { s : Set α | IsClosed s ∧ IsIrreducible s } :=\n  by\n  ext s\n  constructor\n  · intro H\n    exact ⟨⟨isClosed_of_mem_irreducibleComponents _ H, H.1⟩, fun x h e => H.2 h.2 e⟩\n  · intro H\n    refine' ⟨H.1.2, fun x h e => _⟩\n    have : closure x ≤ s := H.2 ⟨isClosed_closure, h.closure⟩ (e.trans subset_closure)\n    exact le_trans subset_closure this\n#align irreducible_components_eq_maximals_closed irreducibleComponents_eq_maximals_closed\n-/\n\n",
 "irreducibleComponent_property":
 "#print irreducibleComponent_property /-\ntheorem irreducibleComponent_property (x : α) :\n    IsPreirreducible (irreducibleComponent x) ∧\n      {x} ⊆ irreducibleComponent x ∧\n        ∀ u, IsPreirreducible u → irreducibleComponent x ⊆ u → u = irreducibleComponent x :=\n  Classical.choose_spec (exists_preirreducible {x} isIrreducible_singleton.is_preirreducible)\n#align irreducible_component_property irreducibleComponent_property\n-/\n\n",
 "irreducibleComponent_mem_irreducibleComponents":
 "#print irreducibleComponent_mem_irreducibleComponents /-\ntheorem irreducibleComponent_mem_irreducibleComponents (x : α) : irreducibleComponent x ∈ irreducibleComponents α :=\n  ⟨isIrreducible_irreducibleComponent, fun s h₁ h₂ => (eq_irreducibleComponent h₁.2 h₂).le⟩\n#align irreducible_component_mem_irreducible_components irreducibleComponent_mem_irreducibleComponents\n-/\n\n",
 "interior":
 "#print IsPreirreducible.interior /-\ntheorem IsPreirreducible.interior {Z : Set α} (hZ : IsPreirreducible Z) : IsPreirreducible (interior Z) :=\n  hZ.open_subset isOpen_interior interior_subset\n#align is_preirreducible.interior IsPreirreducible.interior\n-/\n\n",
 "inter_right":
 "#print IsCompact.inter_right /-\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem IsCompact.inter_right (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s ∩ t) :=\n  by\n  intro f hnf hstf\n  obtain ⟨a, hsa, ha⟩ : ∃ a ∈ s, ClusterPt a f := hs (le_trans hstf (le_principal_iff.2 (inter_subset_left _ _)))\n  have : a ∈ t := ht.mem_of_nhds_within_ne_bot <| ha.mono <| le_trans hstf (le_principal_iff.2 (inter_subset_right _ _))\n  exact ⟨a, ⟨hsa, this⟩, ha⟩\n#align is_compact.inter_right IsCompact.inter_right\n-/\n\n",
 "inter_left":
 "#print IsCompact.inter_left /-\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem IsCompact.inter_left (ht : IsCompact t) (hs : IsClosed s) : IsCompact (s ∩ t) :=\n  inter_comm t s ▸ ht.inter_right hs\n#align is_compact.inter_left IsCompact.inter_left\n-/\n\n",
 "inter_interᵢ_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print IsCompact.inter_interᵢ_nonempty /-\n/-- To show that a compact set intersects the intersection of a family of closed sets,\n  it is sufficient to show that it intersects every finite subfamily. -/\ntheorem IsCompact.inter_interᵢ_nonempty {s : Set α} {ι : Type v} (hs : IsCompact s) (Z : ι → Set α)\n    (hZc : ∀ i, IsClosed (Z i))\n    (hsZ :\n      ∀ t : Finset ι,\n        (s ∩\n            «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n              (Z i)).nonempty) :\n    (s ∩\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (Z i)).nonempty :=\n  by\n  simp only [nonempty_iff_ne_empty] at hsZ⊢\n  apply mt (hs.elim_finite_subfamily_closed Z hZc); push_neg; exact hsZ\n#align is_compact.inter_Inter_nonempty IsCompact.inter_interᵢ_nonempty\n-/\n\n",
 "inter":
 "#print IsClopen.inter /-\ntheorem IsClopen.inter {s t : Set α} (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s ∩ t) :=\n  ⟨hs.1.inter ht.1, hs.2.inter ht.2⟩\n#align is_clopen.inter IsClopen.inter\n-/\n\n",
 "insert":
 "#print IsCompact.insert /-\ntheorem IsCompact.insert (hs : IsCompact s) (a) : IsCompact (insert a s) :=\n  isCompact_singleton.union hs\n#align is_compact.insert IsCompact.insert\n-/\n\n",
 "induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print IsCompact.induction_on /-\n/-- If `p : set α → Prop` is stable under restriction and union, and each point `x`\n  of a compact set `s` has a neighborhood `t` within `s` such that `p t`, then `p s` holds. -/\n@[elab_as_elim]\ntheorem IsCompact.induction_on {s : Set α} (hs : IsCompact s) {p : Set α → Prop} (he : p ∅)\n    (hmono : ∀ ⦃s t⦄, s ⊆ t → p t → p s) (hunion : ∀ ⦃s t⦄, p s → p t → p (s ∪ t))\n    (hnhds : ∀ x ∈ s, ∃ t ∈ nhds_within s x, p t) : p s :=\n  by\n  let f : Filter α :=\n    { sets := { t | p («expr ᶜ» t) }\n      univ_sets := by simpa\n      sets_of_superset := fun t₁ t₂ ht₁ ht => hmono (compl_subset_compl.2 ht) ht₁\n      inter_sets := fun t₁ t₂ ht₁ ht₂ => by simp [compl_inter, hunion ht₁ ht₂] }\n  have : «expr ᶜ» s ∈ f := hs.compl_mem_sets_of_nhds_within (by simpa using hnhds)\n  simpa\n#align is_compact.induction_on IsCompact.induction_on\n-/\n\n",
 "image_of_continuousOn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompact.image_of_continuousOn /-\ntheorem IsCompact.image_of_continuousOn {f : α → β} (hs : IsCompact s) (hf : ContinuousOn f s) :\n    IsCompact («expr '' » f s) := by\n  intro l lne ls\n  have : ne_bot («expr ⊓ » (l.comap f) ((filter.principal) s)) :=\n    comap_inf_principal_ne_bot_of_image_mem lne (le_principal_iff.1 ls)\n  obtain ⟨a, has, ha⟩ : ∃ a ∈ s, ClusterPt a («expr ⊓ » (l.comap f) ((filter.principal) s)) := @hs this inf_le_right\n  use f a, mem_image_of_mem f has\n  have : tendsto f («expr ⊓ » ((nhds) a) («expr ⊓ » (comap f l) ((filter.principal) s))) («expr ⊓ » ((nhds) (f a)) l) :=\n    by\n    convert(hf a has).inf (@tendsto_comap _ _ f l) using 1\n    rw [nhdsWithin]\n    ac_rfl\n  exact @tendsto.ne_bot _ this ha\n#align is_compact.image_of_continuous_on IsCompact.image_of_continuousOn\n-/\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsIrreducible.image /-\ntheorem IsIrreducible.image {s : Set α} (H : IsIrreducible s) (f : α → β) (hf : ContinuousOn f s) :\n    IsIrreducible («expr '' » f s) :=\n  ⟨H.nonempty.image _, H.is_preirreducible.image f hf⟩\n#align is_irreducible.image IsIrreducible.image\n-/\n\n",
 "has_basis_cocompact":
 "theorem has_basis_cocompact : (cocompact α).has_basis IsCompact compl :=\n  hasBasis_binfᵢ_principal'\n    (fun s hs t ht =>\n      ⟨s ∪ t, hs.union ht, compl_subset_compl.2 (subset_union_left s t), compl_subset_compl.2 (subset_union_right s t)⟩)\n    ⟨∅, isCompact_empty⟩\n#align has_basis_cocompact has_basis_cocompact\n\n",
 "has_basis_coclosed_compact":
 "theorem has_basis_coclosed_compact : (Filter.coclosedCompact α).has_basis (fun s => IsClosed s ∧ IsCompact s) compl :=\n  by\n  simp only [Filter.coclosedCompact, infᵢ_and']\n  refine' has_basis_binfi_principal' _ ⟨∅, isClosed_empty, isCompact_empty⟩\n  rintro s ⟨hs₁, hs₂⟩ t ⟨ht₁, ht₂⟩\n  exact\n    ⟨s ∪ t,\n      ⟨⟨hs₁.union ht₁, hs₂.union ht₂⟩, compl_subset_compl.2 (subset_union_left _ _),\n        compl_subset_compl.2 (subset_union_right _ _)⟩⟩\n#align has_basis_coclosed_compact has_basis_coclosed_compact\n\n",
 "generalized_tube_lemma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print generalized_tube_lemma /-\n/-- If `s` and `t` are compact sets and `n` is an open neighborhood of `s × t`, then there exist\nopen neighborhoods `u ⊇ s` and `v ⊇ t` such that `u × v ⊆ n`. -/\ntheorem generalized_tube_lemma {s : Set α} (hs : IsCompact s) {t : Set β} (ht : IsCompact t) {n : Set (α × β)}\n    (hn : IsOpen n) (hp : lower_set.prod s t ⊆ n) :\n    ∃ (u : Set α)(v : Set β), IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ lower_set.prod u v ⊆ n :=\n  have :=\n    nhdsContainBoxes_of_compact hs t fun x _ =>\n      NhdsContainBoxes.symm <| nhdsContainBoxes_of_compact ht {x} fun y _ => nhdsContainBoxes_of_singleton\n  this n hn hp\n#align generalized_tube_lemma generalized_tube_lemma\n-/\n\n",
 "finite_of_discrete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsCompact.finite_of_discrete /-\ntheorem IsCompact.finite_of_discrete [DiscreteTopology α] {s : Set α} (hs : IsCompact s) : s.finite :=\n  by\n  have : ∀ x : α, ({x} : Set α) ∈ (nhds) x := by simp [nhds_discrete]\n  rcases hs.elim_nhds_subcover (fun x => {x}) fun x hx => this x with ⟨t, hts, hst⟩\n  simp only [← t.set_bUnion_coe, bUnion_of_singleton] at hst\n  exact t.finite_to_set.subset hst\n#align is_compact.finite_of_discrete IsCompact.finite_of_discrete\n-/\n\n",
 "finite_of_compact_of_discrete":
 "#print finite_of_compact_of_discrete /-\n-- Note: We can't make this into an instance because it loops with `finite.compact_space`.\n/-- A compact discrete space is finite. -/\ntheorem finite_of_compact_of_discrete [CompactSpace α] [DiscreteTopology α] : Finite α :=\n  Finite.of_finite_univ <| isCompact_univ.finite_of_discrete\n#align finite_of_compact_of_discrete finite_of_compact_of_discrete\n-/\n\n",
 "finite_of_compact":
 "#print LocallyFinite.finite_of_compact /-\n/-- If `α` is a compact space, then a locally finite family of nonempty sets of `α` can have only\nfinitely many elements, `set.finite` version. -/\ntheorem LocallyFinite.finite_of_compact {ι : Type _} [CompactSpace α] {f : ι → Set α} (hf : LocallyFinite f)\n    (hne : ∀ i, (f i).nonempty) : (univ : Set ι).finite := by simpa only [hne] using hf.finite_nonempty_of_compact\n#align locally_finite.finite_of_compact LocallyFinite.finite_of_compact\n-/\n\n",
 "finite_nonempty_of_compact":
 "#print LocallyFinite.finite_nonempty_of_compact /-\n/-- If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\nmany nonempty elements. -/\ntheorem LocallyFinite.finite_nonempty_of_compact {ι : Type _} [CompactSpace α] {f : ι → Set α} (hf : LocallyFinite f) :\n    { i | (f i).nonempty }.finite := by simpa only [inter_univ] using hf.finite_nonempty_inter_compact isCompact_univ\n#align locally_finite.finite_nonempty_of_compact LocallyFinite.finite_nonempty_of_compact\n-/\n\n",
 "finite_nonempty_inter_compact":
 "#print LocallyFinite.finite_nonempty_inter_compact /-\n/-- If `s` is a compact set in a topological space `α` and `f : ι → set α` is a locally finite\nfamily of sets, then `f i ∩ s` is nonempty only for a finitely many `i`. -/\ntheorem LocallyFinite.finite_nonempty_inter_compact {ι : Type _} {f : ι → Set α} (hf : LocallyFinite f) {s : Set α}\n    (hs : IsCompact s) : { i | (f i ∩ s).nonempty }.finite :=\n  by\n  choose U hxU hUf using hf\n  rcases hs.elim_nhds_subcover U fun x _ => hxU x with ⟨t, -, hsU⟩\n  refine' (t.finite_to_set.bUnion fun x _ => hUf x).subset _\n  rintro i ⟨x, hx⟩\n  rcases mem_Union₂.1 (hsU hx.2) with ⟨c, hct, hcx⟩\n  exact mem_bUnion hct ⟨x, hx.1, hcx⟩\n#align locally_finite.finite_nonempty_inter_compact LocallyFinite.finite_nonempty_inter_compact\n-/\n\n",
 "finite_cover_nhds_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print finite_cover_nhds_interior /-\ntheorem finite_cover_nhds_interior [CompactSpace α] {U : α → Set α} (hU : ∀ x, U x ∈ (nhds) x) :\n    ∃ t : Finset α,\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (interior (U x)) =\n        univ :=\n  let ⟨t, ht⟩ :=\n    isCompact_univ.elim_finite_subcover (fun x => interior (U x)) (fun x => isOpen_interior) fun x _ =>\n      mem_unionᵢ.2 ⟨x, mem_interior_iff_mem_nhds.2 (hU x)⟩\n  ⟨t, univ_subset_iff.1 ht⟩\n#align finite_cover_nhds_interior finite_cover_nhds_interior\n-/\n\n",
 "finite_cover_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print finite_cover_nhds /-\ntheorem finite_cover_nhds [CompactSpace α] {U : α → Set α} (hU : ∀ x, U x ∈ (nhds) x) :\n    ∃ t : Finset α,\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U x) = univ :=\n  let ⟨t, ht⟩ := finite_cover_nhds_interior hU\n  ⟨t, univ_subset_iff.1 <| ht.symm.subset.trans <| unionᵢ₂_mono fun x hx => interior_subset⟩\n#align finite_cover_nhds finite_cover_nhds\n-/\n\n",
 "finite":
 "#print IsCompact.finite /-\ntheorem IsCompact.finite {s : Set α} (hs : IsCompact s) (hs' : DiscreteTopology s) : s.finite :=\n  finite_coe_iff.mp (@finite_of_compact_of_discrete _ _ (isCompact_iff_compactSpace.mp hs) hs')\n#align is_compact.finite IsCompact.finite\n-/\n\n",
 "find_shiftr":
 "@[simp]\ntheorem find_shiftr (x : α) : K.shiftr.find x = K.find x + 1 :=\n  Nat.find_comp_succ _ _ (not_mem_empty _)\n#align find_shiftr find_shiftr\n\n",
 "exists_subset_nhds_of_isCompact'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_subset_nhds_of_isCompact' /-\n/-- If `V : ι → set α` is a decreasing family of closed compact sets then any neighborhood of\n`⋂ i, V i` contains some `V i`. We assume each `V i` is compact *and* closed because `α` is\nnot assumed to be Hausdorff. See `exists_subset_nhd_of_compact` for version assuming this. -/\ntheorem exists_subset_nhds_of_isCompact' {ι : Type _} [Nonempty ι] {V : ι → Set α} (hV : Directed («expr ⊇ » · ·) V)\n    (hV_cpct : ∀ i, IsCompact (V i)) (hV_closed : ∀ i, IsClosed (V i)) {U : Set α}\n    (hU :\n      ∀ x ∈ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (V i),\n        U ∈ (nhds) x) :\n    ∃ i, V i ⊆ U := by\n  obtain ⟨W, hsubW, W_op, hWU⟩ := exists_open_set_nhds hU\n  rsuffices ⟨i, hi⟩ : ∃ i, V i ⊆ W\n  · exact ⟨i, hi.trans hWU⟩\n  by_contra' H\n  replace H : ∀ i, (V i ∩ «expr ᶜ» W).nonempty := fun i => set.inter_compl_nonempty_iff.mpr (H i)\n  have :\n    («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (V i ∩ «expr ᶜ» W)).nonempty :=\n    by\n    refine'\n      IsCompact.nonempty_interᵢ_of_directed_nonempty_compact_closed _ (fun i j => _) H\n        (fun i => (hV_cpct i).inter_right W_op.is_closed_compl) fun i => (hV_closed i).inter W_op.is_closed_compl\n    rcases hV i j with ⟨k, hki, hkj⟩\n    refine' ⟨k, ⟨fun x => _, fun x => _⟩⟩ <;> simp only [and_imp, mem_inter_iff, mem_compl_iff] <;> tauto\n  have : ¬«expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (V i) ⊆ W :=\n    by simpa [← Inter_inter, inter_compl_nonempty_iff]\n  contradiction\n#align exists_subset_nhds_of_is_compact' exists_subset_nhds_of_isCompact'\n-/\n\n",
 "exists_subset_nhds_of_compactSpace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_subset_nhds_of_compactSpace /-\ntheorem exists_subset_nhds_of_compactSpace [CompactSpace α] {ι : Type _} [Nonempty ι] {V : ι → Set α}\n    (hV : Directed («expr ⊇ » · ·) V) (hV_closed : ∀ i, IsClosed (V i)) {U : Set α}\n    (hU :\n      ∀ x ∈ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (V i),\n        U ∈ (nhds) x) :\n    ∃ i, V i ⊆ U :=\n  exists_subset_nhds_of_isCompact' hV (fun i => (hV_closed i).is_compact) hV_closed hU\n#align exists_subset_nhds_of_compact_space exists_subset_nhds_of_compactSpace\n-/\n\n",
 "exists_preirreducible":
 "#print exists_preirreducible /-\ntheorem exists_preirreducible (s : Set α) (H : IsPreirreducible s) :\n    ∃ t : Set α, IsPreirreducible t ∧ s ⊆ t ∧ ∀ u, IsPreirreducible u → t ⊆ u → u = t :=\n  let ⟨m, hm, hsm, hmm⟩ :=\n    zorn_subset_nonempty { t : Set α | IsPreirreducible t }\n      (fun c hc hcc hcn =>\n        let ⟨t, htc⟩ := hcn\n        ⟨⋃₀ c, fun u v hu hv ⟨y, hy, hyu⟩ ⟨z, hz, hzv⟩ =>\n          let ⟨p, hpc, hyp⟩ := mem_unionₛ.1 hy\n          let ⟨q, hqc, hzq⟩ := mem_unionₛ.1 hz\n          or.cases_on (hcc.total hpc hqc)\n            (fun hpq : p ⊆ q =>\n              let ⟨x, hxp, hxuv⟩ := hc hqc u v hu hv ⟨y, hpq hyp, hyu⟩ ⟨z, hzq, hzv⟩\n              ⟨x, mem_unionₛ_of_mem hxp hqc, hxuv⟩)\n            fun hqp : q ⊆ p =>\n            let ⟨x, hxp, hxuv⟩ := hc hpc u v hu hv ⟨y, hyp, hyu⟩ ⟨z, hqp hzq, hzv⟩\n            ⟨x, mem_unionₛ_of_mem hxp hpc, hxuv⟩,\n          fun x hxc => subset_unionₛ_of_mem hxc⟩)\n      s H\n  ⟨m, hm, hsm, fun u hu hmu => hmm _ hu hmu⟩\n#align exists_preirreducible exists_preirreducible\n-/\n\n",
 "exists_nhds_ne_neBot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n#print exists_nhds_ne_neBot /-\ntheorem exists_nhds_ne_neBot (α : Type _) [TopologicalSpace α] [CompactSpace α] [Infinite α] :\n    ∃ z : α, (nhds_within.ne z).ne_bot := by\n  by_contra' H\n  simp_rw [not_ne_bot] at H\n  haveI := discrete_topology_iff_nhds_ne.mpr H\n  exact infinite.not_finite (finite_of_compact_of_discrete : Finite α)\n#align exists_nhds_ne_ne_bot exists_nhds_ne_neBot\n-/\n\n",
 "exists_nhds_ne_inf_principal_neBot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print exists_nhds_ne_inf_principal_neBot /-\ntheorem exists_nhds_ne_inf_principal_neBot {s : Set α} (hs : IsCompact s) (hs' : s.infinite) :\n    ∃ z ∈ s, («expr ⊓ » (nhds_within.ne z) ((filter.principal) s)).ne_bot :=\n  by\n  by_contra' H\n  simp_rw [not_ne_bot] at H\n  exact hs' (hs.finite <| discrete_topology_subtype_iff.mpr H)\n#align exists_nhds_ne_inf_principal_ne_bot exists_nhds_ne_inf_principal_neBot\n-/\n\n",
 "exists_minimal_nonempty_closed_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print IsClosed.exists_minimal_nonempty_closed_subset /-\ntheorem IsClosed.exists_minimal_nonempty_closed_subset [CompactSpace α] {S : Set α} (hS : IsClosed S)\n    (hne : S.nonempty) :\n    ∃ V : Set α, V ⊆ S ∧ V.nonempty ∧ IsClosed V ∧ ∀ V' : Set α, V' ⊆ V → V'.nonempty → IsClosed V' → V' = V :=\n  by\n  let opens := { U : Set α | «expr ᶜ» S ⊆ U ∧ IsOpen U ∧ («expr ᶜ» U).nonempty }\n  obtain ⟨U, ⟨Uc, Uo, Ucne⟩, h⟩ :=\n    zorn_subset opens fun c hc hz => by\n      by_cases hcne : c.nonempty\n      · obtain ⟨U₀, hU₀⟩ := hcne\n        haveI : Nonempty { U // U ∈ c } := ⟨⟨U₀, hU₀⟩⟩\n        obtain ⟨U₀compl, U₀opn, U₀ne⟩ := hc hU₀\n        use ⋃₀ c\n        refine' ⟨⟨_, _, _⟩, fun U hU a ha => ⟨U, hU, ha⟩⟩\n        · exact fun a ha => ⟨U₀, hU₀, U₀compl ha⟩\n        · exact isOpen_unionₛ fun _ h => (hc h).2.1\n        · convert_to(«expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n                («expr ᶜ» U.1)).nonempty\n          · ext\n            simp only [not_exists, exists_prop, not_and, Set.mem_interᵢ, Subtype.forall, mem_set_of_eq, mem_compl_iff,\n              mem_sUnion]\n          apply IsCompact.nonempty_interᵢ_of_directed_nonempty_compact_closed\n          · rintro ⟨U, hU⟩ ⟨U', hU'⟩\n            obtain ⟨V, hVc, hVU, hVU'⟩ := hz.directed_on U hU U' hU'\n            exact ⟨⟨V, hVc⟩, set.compl_subset_compl.mpr hVU, set.compl_subset_compl.mpr hVU'⟩\n          · exact fun U => (hc U.2).2.2\n          · exact fun U => (is_closed_compl_iff.mpr (hc U.2).2.1).is_compact\n          · exact fun U => is_closed_compl_iff.mpr (hc U.2).2.1\n      · use «expr ᶜ» S\n        refine' ⟨⟨Set.Subset.refl _, is_open_compl_iff.mpr hS, _⟩, fun U Uc => (hcne ⟨U, Uc⟩).elim⟩\n        rw [compl_compl]\n        exact hne\n  refine' ⟨«expr ᶜ» U, set.compl_subset_comm.mp Uc, Ucne, is_closed_compl_iff.mpr Uo, _⟩\n  intro V' V'sub V'ne V'cls\n  have : «expr ᶜ» V' = U :=\n    by\n    refine' h («expr ᶜ» V') ⟨_, is_open_compl_iff.mpr V'cls, _⟩ (set.subset_compl_comm.mp V'sub)\n    exact Set.Subset.trans Uc (set.subset_compl_comm.mp V'sub)\n    simp only [compl_compl, V'ne]\n  rw [← this, compl_compl]\n#align is_closed.exists_minimal_nonempty_closed_subset IsClosed.exists_minimal_nonempty_closed_subset\n-/\n\n",
 "exists_mem_compactCovering":
 "#print exists_mem_compactCovering /-\ntheorem exists_mem_compactCovering (x : α) : ∃ n, x ∈ compactCovering α n :=\n  unionᵢ_eq_univ_iff.mp (unionᵢ_compactCovering α) x\n#align exists_mem_compact_covering exists_mem_compactCovering\n-/\n\n",
 "exists_mem":
 "theorem exists_mem (x : α) : ∃ n, x ∈ K n :=\n  unionᵢ_eq_univ_iff.1 K.Union_eq x\n#align exists_mem exists_mem\n\n",
 "exists_compact_superset":
 "#print exists_compact_superset /-\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem exists_compact_superset [LocallyCompactSpace α] {K : Set α} (hK : IsCompact K) :\n    ∃ K', IsCompact K' ∧ K ⊆ interior K' :=\n  let ⟨L, hLc, hKL, _⟩ := exists_compact_between hK isOpen_univ K.subset_univ\n  ⟨L, hLc, hKL⟩\n#align exists_compact_superset exists_compact_superset\n-/\n\n",
 "exists_compact_subset":
 "#print exists_compact_subset /-\n/-- A reformulation of the definition of locally compact space: In a locally compact space,\n  every open set containing `x` has a compact subset containing `x` in its interior. -/\ntheorem exists_compact_subset [LocallyCompactSpace α] {x : α} {U : Set α} (hU : IsOpen U) (hx : x ∈ U) :\n    ∃ K : Set α, IsCompact K ∧ x ∈ interior K ∧ K ⊆ U :=\n  by\n  rcases locally_compact_space.local_compact_nhds x U (hU.mem_nhds hx) with ⟨K, h1K, h2K, h3K⟩\n  exact ⟨K, h3K, mem_interior_iff_mem_nhds.2 h1K, h2K⟩\n#align exists_compact_subset exists_compact_subset\n-/\n\n",
 "exists_compact_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_compact_mem_nhds /-\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem exists_compact_mem_nhds [LocallyCompactSpace α] (x : α) : ∃ K, IsCompact K ∧ K ∈ (nhds) x :=\n  let ⟨K, hKc, hx, H⟩ := exists_compact_subset isOpen_univ (mem_univ x)\n  ⟨K, hKc, mem_interior_iff_mem_nhds.1 hx⟩\n#align exists_compact_mem_nhds exists_compact_mem_nhds\n-/\n\n",
 "exists_compact_between":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print exists_compact_between /-\n/-- In a locally compact space, for every containement `K ⊆ U` of a compact set `K` in an open\n  set `U`, there is a compact neighborhood `L` such that `K ⊆ L ⊆ U`: equivalently, there is a\n  compact `L` such that `K ⊆ interior L` and `L ⊆ U`. -/\ntheorem exists_compact_between [hα : LocallyCompactSpace α] {K U : Set α} (hK : IsCompact K) (hU : IsOpen U)\n    (h_KU : K ⊆ U) : ∃ L, IsCompact L ∧ K ⊆ interior L ∧ L ⊆ U :=\n  by\n  choose V hVc hxV hKV using fun x : K => exists_compact_subset hU (h_KU x.2)\n  have :\n    K ⊆\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (interior (V x)) :=\n    fun x hx => mem_Union.2 ⟨⟨x, hx⟩, hxV _⟩\n  rcases hK.elim_finite_subcover _ (fun x => @isOpen_interior α _ (V x)) this with ⟨t, ht⟩\n  refine' ⟨_, t.is_compact_bUnion fun x _ => hVc x, fun x hx => _, Set.unionᵢ₂_subset fun i _ => hKV i⟩\n  rcases mem_Union₂.1 (ht hx) with ⟨y, hyt, hy⟩\n  exact interior_mono (subset_bUnion_of_mem hyt) hy\n#align exists_compact_between exists_compact_between\n-/\n\n",
 "eventually_forall_of_forall_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsCompact.eventually_forall_of_forall_eventually /-\n/-- To show that `∀ y ∈ K, P x y` holds for `x` close enough to `x₀` when `K` is compact,\nit is sufficient to show that for all `y₀ ∈ K` there `P x y` holds for `(x, y)` close enough\nto `(x₀, y₀)`.\n-/\ntheorem IsCompact.eventually_forall_of_forall_eventually {x₀ : α} {K : Set β} (hK : IsCompact K) {P : α → β → Prop}\n    (hP :\n      ∀ y ∈ K,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          ((nhds) (x₀, y)) (P z.1 z.2)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x₀)\n      (∀ y ∈ K, P x y) :=\n  by\n  refine' hK.induction_on _ _ _ _\n  · exact eventually_of_forall fun x y => false.elim\n  · intro s t hst ht\n    refine' ht.mono fun x h y hys => h y <| hst hys\n  · intro s t hs ht\n    filter_upwards [hs, ht]\n    rintro x h1 h2 y (hys | hyt)\n    exacts[h1 y hys, h2 y hyt]\n  · intro y hyK\n    specialize hP y hyK\n    rw [nhds_prod_eq, eventually_prod_iff] at hP\n    rcases hP with ⟨p, hp, q, hq, hpq⟩\n    exact ⟨{ y | q y }, mem_nhdsWithin_of_mem_nhds hq, eventually_of_mem hp @hpq⟩\n#align is_compact.eventually_forall_of_forall_eventually IsCompact.eventually_forall_of_forall_eventually\n-/\n\n",
 "eq_irreducibleComponent":
 "#print eq_irreducibleComponent /-\ntheorem eq_irreducibleComponent {x : α} :\n    ∀ {s : Set α}, IsPreirreducible s → irreducibleComponent x ⊆ s → s = irreducibleComponent x :=\n  (irreducibleComponent_property x).2.2\n#align eq_irreducible_component eq_irreducibleComponent\n-/\n\n",
 "elim_nhds_subcover'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print IsCompact.elim_nhds_subcover' /-\ntheorem IsCompact.elim_nhds_subcover' (hs : IsCompact s) (U : ∀ x ∈ s, Set α) (hU : ∀ x ∈ s, U x ‹x ∈ s› ∈ (nhds) x) :\n    ∃ t : Finset s,\n      s ⊆\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (U (x : s) x.2) :=\n  (hs.elim_finite_subcover (fun x : s => interior (U x x.2)) (fun x => isOpen_interior) fun x hx =>\n        mem_unionᵢ.2 ⟨⟨x, hx⟩, mem_interior_iff_mem_nhds.2 <| hU _ _⟩).imp\n    fun t ht => Subset.trans ht <| unionᵢ₂_mono fun _ _ => interior_subset\n#align is_compact.elim_nhds_subcover' IsCompact.elim_nhds_subcover'\n-/\n\n",
 "elim_nhds_subcover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print CompactSpace.elim_nhds_subcover /-\ntheorem CompactSpace.elim_nhds_subcover [CompactSpace α] (U : α → Set α) (hU : ∀ x, U x ∈ (nhds) x) :\n    ∃ t : Finset α,\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U x) = «expr⊤» :=\n  by\n  obtain ⟨t, -, s⟩ := IsCompact.elim_nhds_subcover isCompact_univ U fun x m => hU x\n  exact\n    ⟨t, by\n      rw [eq_top_iff]\n      exact s⟩\n#align compact_space.elim_nhds_subcover CompactSpace.elim_nhds_subcover\n-/\n\n",
 "elim_finite_subfamily_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print IsCompact.elim_finite_subfamily_closed /-\n/-- For every family of closed sets whose intersection avoids a compact set,\nthere exists a finite subfamily whose intersection avoids this compact set. -/\ntheorem IsCompact.elim_finite_subfamily_closed {s : Set α} {ι : Type v} (hs : IsCompact s) (Z : ι → Set α)\n    (hZc : ∀ i, IsClosed (Z i))\n    (hsZ :\n      s ∩ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i) = ∅) :\n    ∃ t : Finset ι,\n      s ∩ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i) = ∅ :=\n  let ⟨t, ht⟩ :=\n    hs.elim_finite_subcover (fun i => «expr ᶜ» (Z i)) (fun i => (hZc i).is_open_compl)\n      (by\n        simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_Union, exists_prop, mem_inter_iff, not_and,\n          iff_self_iff, mem_Inter, mem_compl_iff] using hsZ)\n  ⟨t, by\n    simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_Union, exists_prop, mem_inter_iff, not_and,\n      iff_self_iff, mem_Inter, mem_compl_iff] using ht⟩\n#align is_compact.elim_finite_subfamily_closed IsCompact.elim_finite_subfamily_closed\n-/\n\n",
 "elim_finite_subcover_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (b' «expr ⊆ » b) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem IsCompact.elim_finite_subcover_image {b : Set ι} {c : ι → Set α} (hs : IsCompact s)\n    (hc₁ : ∀ i ∈ b, IsOpen (c i))\n    (hc₂ : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (c i)) :\n    ∃ (b' : _)(_ : b' ⊆ b),\n      Set.Finite b' ∧\n        s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (c i) :=\n  by\n  rcases hs.elim_finite_subcover (fun i => c i : b → Set α) _ _ with ⟨d, hd⟩ <;> [skip, simpa using hc₁,\n    simpa using hc₂]\n  refine' ⟨↑(d.image coe), _, Finset.finite_toSet _, _⟩\n  · simp\n  · rwa [Finset.coe_image, bUnion_image]\n#align is_compact.elim_finite_subcover_image IsCompact.elim_finite_subcover_imageₓ\n\n",
 "elim_finite_subcover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print IsCompact.elim_finite_subcover /-\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem IsCompact.elim_finite_subcover {ι : Type v} (hs : IsCompact s) (U : ι → Set α) (hUo : ∀ i, IsOpen (U i))\n    (hsU : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i)) :\n    ∃ t : Finset ι,\n      s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i) :=\n  hs.elim_directed_cover _ (fun t => isOpen_bunionᵢ fun i _ => hUo i) (unionᵢ_eq_unionᵢ_finset U ▸ hsU)\n    (directed_of_sup fun t₁ t₂ h => bunionᵢ_subset_bunionᵢ_left h)\n#align is_compact.elim_finite_subcover IsCompact.elim_finite_subcover\n-/\n\n",
 "elim_directed_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print IsCompact.elim_directed_cover /-\n/-- For every open directed cover of a compact set, there exists a single element of the\ncover which itself includes the set. -/\ntheorem IsCompact.elim_directed_cover {ι : Type v} [hι : Nonempty ι] (hs : IsCompact s) (U : ι → Set α)\n    (hUo : ∀ i, IsOpen (U i))\n    (hsU : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i))\n    (hdU : Directed (· ⊆ ·) U) : ∃ i, s ⊆ U i :=\n  hι.elim fun i₀ =>\n    IsCompact.induction_on hs ⟨i₀, empty_subset _⟩ (fun s₁ s₂ hs ⟨i, hi⟩ => ⟨i, Subset.trans hs hi⟩)\n      (fun s₁ s₂ ⟨i, hi⟩ ⟨j, hj⟩ =>\n        let ⟨k, hki, hkj⟩ := hdU i j\n        ⟨k, union_subset (Subset.trans hi hki) (Subset.trans hj hkj)⟩)\n      fun x hx =>\n      let ⟨i, hi⟩ := mem_unionᵢ.1 (hsU hx)\n      ⟨U i, mem_nhdsWithin_of_mem_nhds (IsOpen.mem_nhds (hUo i) hi), i, Subset.refl _⟩\n#align is_compact.elim_directed_cover IsCompact.elim_directed_cover\n-/\n\n",
 "disjoint_nhdsSet_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsCompact.disjoint_nhdsSet_right /-\n/-- A filter `l` is disjoint with the neighborhood filter of a compact set if and only if it is\ndisjoint with the neighborhood filter of each point of this set. -/\ntheorem IsCompact.disjoint_nhdsSet_right {l : Filter α} (hs : IsCompact s) :\n    Disjoint l ((nhds_set) s) ↔ ∀ x ∈ s, Disjoint l ((nhds) x) := by\n  simpa only [disjoint_comm] using hs.disjoint_nhds_set_left\n#align is_compact.disjoint_nhds_set_right IsCompact.disjoint_nhdsSet_right\n-/\n\n",
 "disjoint_nhdsSet_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsCompact.disjoint_nhdsSet_left /-\n/-- The neighborhood filter of a compact set is disjoint with a filter `l` if and only if the\nneighborhood filter of each point of this set is disjoint with `l`. -/\ntheorem IsCompact.disjoint_nhdsSet_left {l : Filter α} (hs : IsCompact s) :\n    Disjoint ((nhds_set) s) l ↔ ∀ x ∈ s, Disjoint ((nhds) x) l :=\n  by\n  refine' ⟨fun h x hx => h.mono_left <| nhds_le_nhdsSet hx, fun H => _⟩\n  choose! U hxU hUl using fun x hx => (nhds_basis_opens x).disjoint_iff_left.1 (H x hx)\n  choose hxU hUo using hxU\n  rcases hs.elim_nhds_subcover U fun x hx => (hUo x hx).mem_nhds (hxU x hx) with ⟨t, hts, hst⟩\n  refine'\n    (hasBasis_nhdsSet _).disjoint_iff_left.2\n      ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U x),\n        ⟨isOpen_bunionᵢ fun x hx => hUo x (hts x hx), hst⟩, _⟩\n  rw [compl_Union₂, bInter_finset_mem]\n  exact fun x hx => hUl x (hts x hx)\n#align is_compact.disjoint_nhds_set_left IsCompact.disjoint_nhdsSet_left\n-/\n\n",
 "diff":
 "#print IsClopen.diff /-\ntheorem IsClopen.diff {s t : Set α} (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s \\ t) :=\n  hs.inter ht.compl\n#align is_clopen.diff IsClopen.diff\n-/\n\n",
 "dense":
 "#print IsOpen.dense /-\n/-- In a (pre)irreducible space, a nonempty open set is dense. -/\nprotected theorem IsOpen.dense [PreirreducibleSpace α] {s : Set α} (ho : IsOpen s) (hne : s.nonempty) : Dense s :=\n  dense_iff_inter_open.2 fun t hto htne => nonempty_preirreducible_inter hto ho htne hne\n#align is_open.dense IsOpen.dense\n-/\n\n",
 "countable_univ":
 "#print LocallyFinite.countable_univ /-\n/-- If `α` is a `σ`-compact space, then a locally finite family of nonempty sets of `α` can have\nonly countably many elements, `set.countable` version. -/\nprotected theorem LocallyFinite.countable_univ {ι : Type _} {f : ι → Set α} (hf : LocallyFinite f)\n    (hne : ∀ i, (f i).nonempty) : (univ : Set ι).countable :=\n  by\n  have := fun n => hf.finite_nonempty_inter_compact (isCompact_compactCovering α n)\n  refine' (countable_Union fun n => (this n).countable).mono fun i hi => _\n  rcases hne i with ⟨x, hx⟩\n  rcases Union_eq_univ_iff.1 (unionᵢ_compactCovering α) x with ⟨n, hn⟩\n  exact mem_Union.2 ⟨n, x, hx, hn⟩\n#align locally_finite.countable_univ LocallyFinite.countable_univ\n-/\n\n",
 "countable_cover_nhds_of_sigma_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print countable_cover_nhds_of_sigma_compact /-\n/-- In a topological space with sigma compact topology, if `f` is a function that sends each\npoint `x` to a neighborhood of `x`, then for some countable set `s`, the neighborhoods `f x`,\n`x ∈ s`, cover the whole space. -/\ntheorem countable_cover_nhds_of_sigma_compact {f : α → Set α} (hf : ∀ x, f x ∈ (nhds) x) :\n    ∃ s : Set α,\n      s.countable ∧\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f x) = univ :=\n  by\n  simp only [← nhdsWithin_univ] at hf\n  rcases countable_cover_nhdsWithin_of_sigma_compact isClosed_univ fun x _ => hf x with ⟨s, -, hsc, hsU⟩\n  exact ⟨s, hsc, univ_subset_iff.1 hsU⟩\n#align countable_cover_nhds_of_sigma_compact countable_cover_nhds_of_sigma_compact\n-/\n\n",
 "countable_cover_nhdsWithin_of_sigma_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print countable_cover_nhdsWithin_of_sigma_compact /-\n/-- In a topological space with sigma compact topology, if `f` is a function that sends each point\n`x` of a closed set `s` to a neighborhood of `x` within `s`, then for some countable set `t ⊆ s`,\nthe neighborhoods `f x`, `x ∈ t`, cover the whole set `s`. -/\ntheorem countable_cover_nhdsWithin_of_sigma_compact {f : α → Set α} {s : Set α} (hs : IsClosed s)\n    (hf : ∀ x ∈ s, f x ∈ nhds_within s x) :\n    ∃ (t : _)(_ : t ⊆ s),\n      t.countable ∧\n        s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f x) :=\n  by\n  simp only [nhdsWithin, mem_inf_principal] at hf\n  choose t ht hsub using fun n =>\n    ((isCompact_compactCovering α n).inter_right hs).elim_nhds_subcover _ fun x hx => hf x hx.right\n  refine'\n    ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t n : Set α),\n      Union_subset fun n x hx => (ht n x hx).2, countable_Union fun n => (t n).countable_to_set, fun x hx =>\n      mem_Union₂.2 _⟩\n  rcases exists_mem_compactCovering x with ⟨n, hn⟩\n  rcases mem_Union₂.1 (hsub n ⟨hn, hx⟩) with ⟨y, hyt : y ∈ t n, hyf : x ∈ s → x ∈ f y⟩\n  exact ⟨y, mem_Union.2 ⟨n, hyt⟩, hyf hx⟩\n#align countable_cover_nhds_within_of_sigma_compact countable_cover_nhdsWithin_of_sigma_compact\n-/\n\n",
 "coprodᵢ_cocompact":
 "#print Filter.coprodᵢ_cocompact /-\n/-- **Tychonoff's theorem** formulated in terms of filters: `filter.cocompact` on an indexed product\ntype `Π d, κ d` the `filter.Coprod` of filters `filter.cocompact` on `κ d`. -/\ntheorem Filter.coprodᵢ_cocompact {δ : Type _} {κ : δ → Type _} [∀ d, TopologicalSpace (κ d)] :\n    (Filter.coprodᵢ fun d => Filter.cocompact (κ d)) = Filter.cocompact (∀ d, κ d) :=\n  by\n  refine' le_antisymm (supᵢ_le fun i => Filter.comap_cocompact_le (continuous_apply i)) _\n  refine' compl_surjective.forall.2 fun s H => _\n  simp only [compl_mem_Coprod, Filter.mem_cocompact, compl_subset_compl, image_subset_iff] at H⊢\n  choose K hKc htK using H\n  exact ⟨Set.pi univ K, isCompact_univ_pi hKc, fun f hf i hi => htK i hf⟩\n#align filter.Coprod_cocompact Filter.coprodᵢ_cocompact\n-/\n\n",
 "coprod_cocompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Filter.coprod_cocompact /-\n/-- The coproduct of the cocompact filters on two topological spaces is the cocompact filter on\ntheir product. -/\ntheorem Filter.coprod_cocompact : (Filter.cocompact α).coprod (Filter.cocompact β) = Filter.cocompact (α × β) :=\n  by\n  ext S\n  simp only [mem_coprod_iff, exists_prop, mem_comap, Filter.mem_cocompact]\n  constructor\n  · rintro ⟨⟨A, ⟨t, ht, hAt⟩, hAS⟩, B, ⟨t', ht', hBt'⟩, hBS⟩\n    refine' ⟨lower_set.prod t t', ht.prod ht', _⟩\n    refine' subset.trans _ (union_subset hAS hBS)\n    rw [compl_subset_comm] at hAt hBt'⊢\n    refine' subset.trans _ (Set.prod_mono hAt hBt')\n    intro x\n    simp only [compl_union, mem_inter_iff, mem_prod, mem_preimage, mem_compl_iff]\n    tauto\n  · rintro ⟨t, ht, htS⟩\n    refine' ⟨⟨«expr ᶜ» («expr '' » Prod.fst t), _, _⟩, ⟨«expr ᶜ» («expr '' » Prod.snd t), _, _⟩⟩\n    · exact ⟨«expr '' » Prod.fst t, ht.image continuous_fst, subset.rfl⟩\n    · rw [preimage_compl]\n      rw [compl_subset_comm] at htS⊢\n      exact subset.trans htS (subset_preimage_image Prod.fst _)\n    · exact ⟨«expr '' » Prod.snd t, ht.image continuous_snd, subset.rfl⟩\n    · rw [preimage_compl]\n      rw [compl_subset_comm] at htS⊢\n      exact subset.trans htS (subset_preimage_image Prod.snd _)\n#align filter.coprod_cocompact Filter.coprod_cocompact\n-/\n\n",
 "continuous_boolIndicator_iff_clopen":
 "#print continuous_boolIndicator_iff_clopen /-\ntheorem continuous_boolIndicator_iff_clopen (U : Set X) : Continuous U.bool_indicator ↔ IsClopen U :=\n  by\n  constructor\n  · intro hc\n    rw [← U.preimage_bool_indicator_tt]\n    exact ⟨hc.is_open_preimage _ trivial, continuous_iff_is_closed.mp hc _ (isClosed_discrete _)⟩\n  · refine' fun hU => ⟨fun s hs => _⟩\n    rcases U.preimage_bool_indicator s with (h | h | h | h) <;> rw [h]\n    exacts[isOpen_univ, hU.1, hU.2.is_open_compl, isOpen_empty]\n#align continuous_bool_indicator_iff_clopen continuous_boolIndicator_iff_clopen\n-/\n\n",
 "continuousOn_boolIndicator_iff_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print continuousOn_boolIndicator_iff_clopen /-\ntheorem continuousOn_boolIndicator_iff_clopen (s U : Set X) :\n    ContinuousOn U.bool_indicator s ↔ IsClopen («expr ⁻¹' » (coe : s → X) U) :=\n  by\n  rw [continuousOn_iff_continuous_restrict, ← continuous_boolIndicator_iff_clopen]\n  rfl\n#align continuous_on_indicator_iff_clopen continuousOn_boolIndicator_iff_clopen\n-/\n\n",
 "compl_mem_sets_of_nhdsWithin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print IsCompact.compl_mem_sets_of_nhdsWithin /-\n/-- The complement to a compact set belongs to a filter `f` if each `a ∈ s` has a neighborhood `t`\nwithin `s` such that `tᶜ` belongs to `f`. -/\ntheorem IsCompact.compl_mem_sets_of_nhdsWithin (hs : IsCompact s) {f : Filter α}\n    (hf : ∀ a ∈ s, ∃ t ∈ nhds_within s a, «expr ᶜ» t ∈ f) : «expr ᶜ» s ∈ f :=\n  by\n  refine' hs.compl_mem_sets fun a ha => _\n  rcases hf a ha with ⟨t, ht, hst⟩\n  replace ht := mem_inf_principal.1 ht\n  apply mem_inf_of_inter ht hst\n  rintro x ⟨h₁, h₂⟩ hs\n  exact h₂ (h₁ hs)\n#align is_compact.compl_mem_sets_of_nhds_within IsCompact.compl_mem_sets_of_nhdsWithin\n-/\n\n",
 "compl_mem_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print IsCompact.compl_mem_sets /-\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Yury Kudryashov\n-/\n-- compact sets\n/-- The complement to a compact set belongs to a filter `f` if it belongs to each filter\n`𝓝 a ⊓ f`, `a ∈ s`. -/\ntheorem IsCompact.compl_mem_sets (hs : IsCompact s) {f : Filter α} (hf : ∀ a ∈ s, «expr ᶜ» s ∈ «expr ⊓ » ((nhds) a) f) :\n    «expr ᶜ» s ∈ f := by\n  contrapose! hf\n  simp only [not_mem_iff_inf_principal_compl, compl_compl, inf_assoc, ← exists_prop] at hf⊢\n  exact @hs _ hf inf_le_right\n#align is_compact.compl_mem_sets IsCompact.compl_mem_sets\n-/\n\n",
 "compl_mem_cocompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print IsCompact.compl_mem_cocompact /-\ntheorem IsCompact.compl_mem_cocompact (hs : IsCompact s) : «expr ᶜ» s ∈ Filter.cocompact α :=\n  hasBasis_cocompact.mem_of_mem hs\n#align is_compact.compl_mem_cocompact IsCompact.compl_mem_cocompact\n-/\n\n",
 "compl_mem_coclosed_compact_of_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print IsCompact.compl_mem_coclosedCompact_of_isClosed /-\ntheorem IsCompact.compl_mem_coclosedCompact_of_isClosed (hs : IsCompact s) (hs' : IsClosed s) :\n    «expr ᶜ» s ∈ Filter.coclosedCompact α :=\n  hasBasis_coclosedCompact.mem_of_mem ⟨hs', hs⟩\n#align is_compact.compl_mem_coclosed_compact_of_is_closed IsCompact.compl_mem_coclosedCompact_of_isClosed\n-/\n\n",
 "compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print IsClopen.compl /-\ntheorem IsClopen.compl {s : Set α} (hs : IsClopen s) : IsClopen («expr ᶜ» s) :=\n  ⟨hs.2.is_open_compl, hs.1.is_closed_compl⟩\n#align is_clopen.compl IsClopen.compl\n-/\n\n",
 "compact_basis_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print compact_basis_nhds /-\ntheorem compact_basis_nhds [LocallyCompactSpace α] (x : α) :\n    ((nhds) x).has_basis (fun s => s ∈ (nhds) x ∧ IsCompact s) fun s => s :=\n  hasBasis_self.2 <| by simpa only [and_comm'] using locally_compact_space.local_compact_nhds x\n#align compact_basis_nhds compact_basis_nhds\n-/\n\n",
 "compactSpace_of_finite_subfamily_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print compactSpace_of_finite_subfamily_closed /-\ntheorem compactSpace_of_finite_subfamily_closed\n    (h :\n      ∀ {ι : Type u} (Z : ι → Set α),\n        (∀ i, IsClosed (Z i)) →\n          «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i) = ∅ →\n            ∃ t : Finset ι,\n              «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Z i) =\n                ∅) :\n    CompactSpace α :=\n  {\n    is_compact_univ := by\n      apply isCompact_of_finite_subfamily_closed\n      intro ι Z; specialize h Z\n      simpa using h }\n#align compact_space_of_finite_subfamily_closed compactSpace_of_finite_subfamily_closed\n-/\n\n",
 "compactSpace":
 "#print ClosedEmbedding.compactSpace /-\nprotected theorem ClosedEmbedding.compactSpace [h : CompactSpace β] {f : α → β} (hf : ClosedEmbedding f) :\n    CompactSpace α := by\n  contrapose! h\n  rw [not_compactSpace_iff] at h⊢\n  exact hf.noncompact_space\n#align closed_embedding.compact_space ClosedEmbedding.compactSpace\n-/\n\n",
 "compactCovering_subset":
 "#print compactCovering_subset /-\n@[mono]\ntheorem compactCovering_subset ⦃m n : ℕ⦄ (h : m ≤ n) : compactCovering α m ⊆ compactCovering α n :=\n  monotone_accumulate h\n#align compact_covering_subset compactCovering_subset\n-/\n\n",
 "comm":
 "#print NhdsContainBoxes.comm /-\ntheorem NhdsContainBoxes.comm {s : Set α} {t : Set β} : NhdsContainBoxes s t ↔ NhdsContainBoxes t s :=\n  iff.intro NhdsContainBoxes.symm NhdsContainBoxes.symm\n#align nhds_contain_boxes.comm NhdsContainBoxes.comm\n-/\n\n",
 "comap_cocompact_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Filter.comap_cocompact_le /-\n/-- The comap of the cocompact filter on `β` by a continuous function `f : α → β` is less than or\nequal to the cocompact filter on `α`.\nThis is a reformulation of the fact that images of compact sets are compact. -/\ntheorem Filter.comap_cocompact_le {f : α → β} (hf : Continuous f) : (Filter.cocompact β).comap f ≤ Filter.cocompact α :=\n  by\n  rw [(filter.has_basis_cocompact.comap f).le_basis_iff Filter.hasBasis_cocompact]\n  intro t ht\n  refine' ⟨«expr '' » f t, ht.image hf, _⟩\n  simpa using t.subset_preimage_image f\n#align filter.comap_cocompact_le Filter.comap_cocompact_le\n-/\n\n",
 "cocompact_neBot_iff":
 "#print Filter.cocompact_neBot_iff /-\ntheorem Filter.cocompact_neBot_iff : NeBot (Filter.cocompact α) ↔ NoncompactSpace α :=\n  ⟨noncompactSpace_of_neBot, @filter.cocompact.filter.ne_bot _ _⟩\n#align filter.cocompact_ne_bot_iff Filter.cocompact_neBot_iff\n-/\n\n",
 "cocompact_le_cofinite":
 "theorem cocompact_le_cofinite : cocompact α ≤ cofinite := fun s hs => compl_compl s ▸ hs.is_compact.compl_mem_cocompact\n#align cocompact_le_cofinite cocompact_le_cofinite\n\n",
 "cocompact_le_coclosed_compact":
 "theorem cocompact_le_coclosed_compact : cocompact α ≤ coclosedCompact α :=\n  infᵢ_mono fun s => le_infᵢ fun _ => le_rfl\n#align cocompact_le_coclosed_compact cocompact_le_coclosed_compact\n\n",
 "cocompact_eq_cofinite":
 "theorem cocompact_eq_cofinite (α : Type _) [TopologicalSpace α] [DiscreteTopology α] : cocompact α = cofinite :=\n  hasBasis_cocompact.eq_of_same_basis <| by\n    convert has_basis_cofinite\n    ext s\n    exact isCompact_iff_finite\n#align cocompact_eq_cofinite cocompact_eq_cofinite\n\n",
 "cocompact_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Filter.cocompact_eq_bot /-\n@[simp]\ntheorem Filter.cocompact_eq_bot [CompactSpace α] : Filter.cocompact α = «expr⊥» :=\n  Filter.hasBasis_cocompact.eq_bot_iff.mpr ⟨Set.univ, isCompact_univ, Set.compl_univ⟩\n#align filter.cocompact_eq_bot Filter.cocompact_eq_bot\n-/\n\n",
 "cocompact_eq":
 "#print Nat.cocompact_eq /-\n@[simp]\ntheorem Nat.cocompact_eq : cocompact ℕ = atTop :=\n  (cocompact_eq_cofinite ℕ).trans Nat.cofinite_eq_atTop\n#align nat.cocompact_eq Nat.cocompact_eq\n-/\n\n",
 "cluster_point_of_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print cluster_point_of_compact /-\ntheorem cluster_point_of_compact [CompactSpace α] (f : Filter α) [NeBot f] : ∃ x, ClusterPt x f := by\n  simpa using isCompact_univ (show f ≤ (filter.principal) univ by simp)\n#align cluster_point_of_compact cluster_point_of_compact\n-/\n\n",
 "adherence_nhdset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print IsCompact.adherence_nhdset /-\ntheorem IsCompact.adherence_nhdset {f : Filter α} (hs : IsCompact s) (hf₂ : f ≤ (filter.principal) s) (ht₁ : IsOpen t)\n    (ht₂ : ∀ a ∈ s, ClusterPt a f → a ∈ t) : t ∈ f :=\n  by_cases mem_of_eq_bot fun this : «expr ⊓ » f ((filter.principal) («expr ᶜ» t)) ≠ «expr⊥» =>\n    let ⟨a, ha, (hfa : ClusterPt a <| «expr ⊓ » f ((filter.principal) («expr ᶜ» t)))⟩ :=\n      @hs ⟨this⟩ <| inf_le_of_left_le hf₂\n    have : a ∈ t := ht₂ a ha hfa.of_inf_left\n    have : «expr ᶜ» t ∩ t ∈ nhds_within («expr ᶜ» t) a := inter_mem_nhdsWithin _ (IsOpen.mem_nhds ht₁ this)\n    have A : nhds_within («expr ᶜ» t) a = «expr⊥» := empty_mem_iff_bot.1 <| compl_inter_self t ▸ this\n    have : nhds_within («expr ᶜ» t) a ≠ «expr⊥» := hfa.of_inf_right.ne\n    absurd A this\n#align is_compact.adherence_nhdset IsCompact.adherence_nhdset\n-/\n\n",
 "Union_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Union_eq :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (K n) = univ :=\n  K.Union_eq'\n#align Union_eq Union_eq\n\n",
 "IsCompact":
 "#print IsCompact /-\nprotected theorem IsCompact (n : ℕ) : IsCompact (K n) :=\n  K.is_compact' n\n#align is_compact IsCompact\n-/\n\n"}