{"tendsto_approx_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_approx_at_top (c : CU X) (x : X) : Tendsto (fun n => c.approx n x) atTop (nhds <| c.lim x) :=\n  tendsto_atTop_csupᵢ (c.approx_mono x) ⟨1, fun x ⟨n, hn⟩ => hn ▸ c.approx_le_one _ _⟩\n#align tendsto_approx_at_top tendsto_approx_at_top\n\n",
 "subset_right_C":
 "theorem subset_right_C (c : CU X) : c.C ⊆ c.right.C :=\n  Subset.trans c.left.subset c.left_U_subset_right_C\n#align subset_right_C subset_right_C\n\n",
 "lim_of_nmem_U":
 "theorem lim_of_nmem_U (c : CU X) (x : X) (h : x ∉ c.U) : c.lim x = 1 := by\n  simp only [CU.lim, approx_of_nmem_U c _ h, csupᵢ_const]\n#align lim_of_nmem_U lim_of_nmem_U\n\n",
 "lim_of_mem_C":
 "theorem lim_of_mem_C (c : CU X) (x : X) (h : x ∈ c.C) : c.lim x = 0 := by\n  simp only [CU.lim, approx_of_mem_C, h, csupᵢ_const]\n#align lim_of_mem_C lim_of_mem_C\n\n",
 "lim_nonneg":
 "theorem lim_nonneg (c : CU X) (x : X) : 0 ≤ c.lim x :=\n  (c.approx_nonneg 0 x).trans (c.approx_le_lim x 0)\n#align lim_nonneg lim_nonneg\n\n",
 "lim_mem_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem lim_mem_Icc (c : CU X) (x : X) : c.lim x ∈ Icc (0 : exprℝ) 1 :=\n  ⟨c.lim_nonneg x, c.lim_le_one x⟩\n#align lim_mem_Icc lim_mem_Icc\n\n",
 "lim_le_one":
 "theorem lim_le_one (c : CU X) (x : X) : c.lim x ≤ 1 :=\n  csupᵢ_le fun n => c.approx_le_one _ _\n#align lim_le_one lim_le_one\n\n",
 "lim_eq_midpoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem lim_eq_midpoint (c : CU X) (x : X) : c.lim x = midpoint (exprℝ) (c.left.lim x) (c.right.lim x) :=\n  by\n  refine' tendsto_nhds_unique (c.tendsto_approx_at_top x) ((tendsto_add_at_top_iff_nat 1).1 _)\n  simp only [approx]\n  exact (c.left.tendsto_approx_at_top x).midpoint (c.right.tendsto_approx_at_top x)\n#align lim_eq_midpoint lim_eq_midpoint\n\n",
 "left_U_subset_right_C":
 "/-\nCopyright (c) 2021 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov\n-/\ntheorem left_U_subset_right_C (c : CU X) : c.left.U ⊆ c.right.C :=\n  subset_closure\n#align left_U_subset_right_C left_U_subset_right_C\n\n",
 "left_U_subset":
 "theorem left_U_subset (c : CU X) : c.left.U ⊆ c.U :=\n  Subset.trans c.left_U_subset_right_C c.right.subset\n#align left_U_subset left_U_subset\n\n",
 "exists_continuous_zero_one_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print exists_continuous_zero_one_of_closed /-\n/-- Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`,\nthen there exists a continuous function `f : X → ℝ` such that\n\n* `f` equals zero on `s`;\n* `f` equals one on `t`;\n* `0 ≤ f x ≤ 1` for all `x`.\n-/\ntheorem exists_continuous_zero_one_of_closed {s t : Set X} (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t) :\n    ∃ f : «exprC( , )» X (exprℝ), EqOn f 0 s ∧ EqOn f 1 t ∧ ∀ x, f x ∈ Icc (0 : exprℝ) 1 :=\n  by\n  -- The actual proof is in the code above. Here we just repack it into the expected format.\n  set c : Urysohns.CU X := ⟨s, «expr ᶜ» t, hs, ht.is_open_compl, disjoint_left.1 hd⟩\n  exact ⟨⟨c.lim, c.continuous_lim⟩, c.lim_of_mem_C, fun x hx => c.lim_of_nmem_U _ fun h => h hx, c.lim_mem_Icc⟩\n#align exists_continuous_zero_one_of_closed exists_continuous_zero_one_of_closed\n-/\n\n",
 "continuous_lim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Continuity of `urysohns.CU.lim`. See module docstring for a sketch of the proofs. -/\ntheorem continuous_lim (c : CU X) : Continuous c.lim :=\n  by\n  obtain ⟨h0, h1234, h1⟩ : 0 < (2⁻¹ : exprℝ) ∧ (2⁻¹ : exprℝ) < 3 / 4 ∧ (3 / 4 : exprℝ) < 1 := by norm_num\n  refine'\n    continuous_iff_continuousAt.2 fun x =>\n      (Metric.nhds_basis_closedBall_pow (h0.trans h1234) h1).tendsto_right_iff.2 fun n _ => _\n  simp only [Metric.mem_closedBall]\n  induction' n with n ihn generalizing c\n  · refine' eventually_of_forall fun y => _\n    rw [pow_zero]\n    exact Real.dist_le_of_mem_Icc_01 (c.lim_mem_Icc _) (c.lim_mem_Icc _)\n  · by_cases hxl : x ∈ c.left.U\n    · filter_upwards [IsOpen.mem_nhds c.left.open_U hxl, ihn c.left]with _ hyl hyd\n      rw [pow_succ, c.lim_eq_midpoint, c.lim_eq_midpoint, c.right.lim_of_mem_C _ (c.left_U_subset_right_C hyl),\n        c.right.lim_of_mem_C _ (c.left_U_subset_right_C hxl)]\n      refine' (dist_midpoint_midpoint_le _ _ _ _).trans _\n      rw [dist_self, add_zero, div_eq_inv_mul]\n      exact mul_le_mul h1234.le hyd dist_nonneg (h0.trans h1234).le\n    · replace hxl : x ∈ «expr ᶜ» c.left.right.C\n      exact compl_subset_compl.2 c.left.right.subset hxl\n      filter_upwards [IsOpen.mem_nhds (isOpen_compl_iff.2 c.left.right.closed_C) hxl, ihn c.left.right,\n        ihn c.right]with y hyl hydl hydr\n      replace hxl : x ∉ c.left.left.U\n      exact compl_subset_compl.2 c.left.left_U_subset_right_C hxl\n      replace hyl : y ∉ c.left.left.U\n      exact compl_subset_compl.2 c.left.left_U_subset_right_C hyl\n      simp only [pow_succ, c.lim_eq_midpoint, c.left.lim_eq_midpoint, c.left.left.lim_of_nmem_U _ hxl,\n        c.left.left.lim_of_nmem_U _ hyl]\n      refine' (dist_midpoint_midpoint_le _ _ _ _).trans _\n      refine' (div_le_div_of_le_of_nonneg (add_le_add_right (dist_midpoint_midpoint_le _ _ _ _) _) zero_le_two).trans _\n      rw [dist_self, zero_add]\n      refine'\n        (div_le_div_of_le_of_nonneg (add_le_add (div_le_div_of_le_of_nonneg hydl zero_le_two) hydr)\n              zero_le_two).trans_eq\n          _\n      generalize (3 / 4 : exprℝ) ^ n = r\n      field_simp [two_ne_zero' (exprℝ)]\n      ring\n#align continuous_lim continuous_lim\n\n",
 "bdd_above_range_approx":
 "theorem bdd_above_range_approx (c : CU X) (x : X) : BddAbove (range fun n => c.approx n x) :=\n  ⟨1, fun y ⟨n, hn⟩ => hn ▸ c.approx_le_one n x⟩\n#align bdd_above_range_approx bdd_above_range_approx\n\n",
 "approx_of_nmem_U":
 "theorem approx_of_nmem_U (c : CU X) (n : ℕ) {x : X} (hx : x ∉ c.U) : c.approx n x = 1 :=\n  by\n  induction' n with n ihn generalizing c\n  · exact indicator_of_mem hx _\n  · simp only [approx]\n    rw [ihn, ihn, midpoint_self]\n    exacts[hx, fun hU => hx <| c.left_U_subset hU]\n#align approx_of_nmem_U approx_of_nmem_U\n\n",
 "approx_of_mem_C":
 "theorem approx_of_mem_C (c : CU X) (n : ℕ) {x : X} (hx : x ∈ c.C) : c.approx n x = 0 :=\n  by\n  induction' n with n ihn generalizing c\n  · exact indicator_of_not_mem (fun hU => hU <| c.subset hx) _\n  · simp only [approx]\n    rw [ihn, ihn, midpoint_self]\n    exacts[c.subset_right_C hx, hx]\n#align approx_of_mem_C approx_of_mem_C\n\n",
 "approx_nonneg":
 "theorem approx_nonneg (c : CU X) (n : ℕ) (x : X) : 0 ≤ c.approx n x :=\n  by\n  induction' n with n ihn generalizing c\n  · exact indicator_nonneg (fun _ _ => zero_le_one) _\n  · simp only [approx, midpoint_eq_smul_add, invOf_eq_inv]\n    refine' mul_nonneg (inv_nonneg.2 zero_le_two) (add_nonneg _ _) <;> apply ihn\n#align approx_nonneg approx_nonneg\n\n",
 "approx_mono":
 "theorem approx_mono (c : CU X) (x : X) : Monotone fun n => c.approx n x :=\n  monotone_nat_of_le_succ fun n => c.approx_le_succ n x\n#align approx_mono approx_mono\n\n",
 "approx_mem_Icc_right_left":
 "theorem approx_mem_Icc_right_left (c : CU X) (n : ℕ) (x : X) :\n    c.approx n x ∈ Icc (c.right.approx n x) (c.left.approx n x) :=\n  by\n  induction' n with n ihn generalizing c\n  · exact ⟨le_rfl, indicator_le_indicator_of_subset (compl_subset_compl.2 c.left_U_subset) (fun _ => zero_le_one) _⟩\n  · simp only [approx, mem_Icc]\n    refine' ⟨midpoint_le_midpoint _ (ihn _).1, midpoint_le_midpoint (ihn _).2 _⟩ <;> apply approx_le_approx_of_U_sub_C\n    exacts[subset_closure, subset_closure]\n#align approx_mem_Icc_right_left approx_mem_Icc_right_left\n\n",
 "approx_le_succ":
 "theorem approx_le_succ (c : CU X) (n : ℕ) (x : X) : c.approx n x ≤ c.approx (n + 1) x :=\n  by\n  induction' n with n ihn generalizing c\n  · simp only [approx, right_U, right_le_midpoint]\n    exact (approx_mem_Icc_right_left c 0 x).2\n  · rw [approx, approx]\n    exact midpoint_le_midpoint (ihn _) (ihn _)\n#align approx_le_succ approx_le_succ\n\n",
 "approx_le_one":
 "theorem approx_le_one (c : CU X) (n : ℕ) (x : X) : c.approx n x ≤ 1 :=\n  by\n  induction' n with n ihn generalizing c\n  · exact indicator_apply_le' (fun _ => le_rfl) fun _ => zero_le_one\n  · simp only [approx, midpoint_eq_smul_add, invOf_eq_inv, smul_eq_mul, ← div_eq_inv_mul]\n    refine' Iff.mpr (div_le_one zero_lt_two) (add_le_add _ _) <;> apply ihn\n#align approx_le_one approx_le_one\n\n",
 "approx_le_lim":
 "theorem approx_le_lim (c : CU X) (x : X) (n : ℕ) : c.approx n x ≤ c.lim x :=\n  le_csupᵢ (c.bdd_above_range_approx x) _\n#align approx_le_lim approx_le_lim\n\n",
 "approx_le_approx_of_U_sub_C":
 "theorem approx_le_approx_of_U_sub_C {c₁ c₂ : CU X} (h : c₁.U ⊆ c₂.C) (n₁ n₂ : ℕ) (x : X) :\n    c₂.approx n₂ x ≤ c₁.approx n₁ x := by\n  by_cases hx : x ∈ c₁.U\n  ·\n    calc\n      approx n₂ c₂ x = 0 := approx_of_mem_C _ _ (h hx)\n      _ ≤ approx n₁ c₁ x := approx_nonneg _ _ _\n      \n  ·\n    calc\n      approx n₂ c₂ x ≤ 1 := approx_le_one _ _ _\n      _ = approx n₁ c₁ x := (approx_of_nmem_U _ _ hx).symm\n      \n#align approx_le_approx_of_U_sub_C approx_le_approx_of_U_sub_C\n\n"}