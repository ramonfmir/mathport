{"projective":
 "#print StoneCech.projective /-\n/-\nCopyright (c) 2021 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\ntheorem StoneCech.projective [DiscreteTopology X] : CompactT2.Projective (StoneCech X) :=\n  by\n  intro Y Z _tsY _tsZ _csY _t2Y _csZ _csZ f g hf hg g_sur\n  let s : Z → Y := fun z => Classical.choose <| g_sur z\n  have hs : g ∘ s = id := funext fun z => Classical.choose_spec (g_sur z)\n  let t := s ∘ f ∘ stoneCechUnit\n  have ht : Continuous t := continuous_of_discreteTopology\n  let h : StoneCech X → Y := stoneCechExtend ht\n  have hh : Continuous h := continuous_stoneCechExtend ht\n  refine' ⟨h, hh, dense_range_stone_cech_unit.equalizer (hg.comp hh) hf _⟩\n  rw [comp.assoc, stoneCechExtend_extends ht, ← comp.assoc, hs, comp.left_id]\n#align stone_cech.projective StoneCech.projective\n-/\n\n",
 "extremallyDisconnected":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print CompactT2.Projective.extremallyDisconnected /-\nprotected theorem CompactT2.Projective.extremallyDisconnected [CompactSpace X] [T2Space X]\n    (h : CompactT2.Projective X) : ExtremallyDisconnected X :=\n  by\n  refine' { open_closure := fun U hU => _ }\n  let Z₁ : Set (X × Bool) := lower_set.prod («expr ᶜ» U) {tt}\n  let Z₂ : Set (X × Bool) := lower_set.prod (closure U) {ff}\n  let Z : Set (X × Bool) := Z₁ ∪ Z₂\n  have hZ₁₂ : Disjoint Z₁ Z₂ := disjoint_left.2 fun x hx₁ hx₂ => by cases hx₁.2.symm.trans hx₂.2\n  have hZ₁ : IsClosed Z₁ := hU.is_closed_compl.prod (t1_space.t1 _)\n  have hZ₂ : IsClosed Z₂ := is_closed_closure.prod (t1_space.t1 ff)\n  have hZ : IsClosed Z := hZ₁.union hZ₂\n  let f : Z → X := Prod.fst ∘ Subtype.val\n  have f_cont : Continuous f := continuous_fst.comp continuous_subtype_val\n  have f_sur : surjective f := by\n    intro x\n    by_cases hx : x ∈ U\n    · exact ⟨⟨(x, ff), or.inr ⟨subset_closure hx, Set.mem_singleton _⟩⟩, rfl⟩\n    · exact ⟨⟨(x, tt), or.inl ⟨hx, Set.mem_singleton _⟩⟩, rfl⟩\n  haveI : CompactSpace Z := is_compact_iff_compact_space.mp hZ.is_compact\n  obtain ⟨g, hg, g_sec⟩ := h continuous_id f_cont f_sur\n  let φ := coe ∘ g\n  have hφ : Continuous φ := continuous_subtype_val.comp hg\n  have hφ₁ : ∀ x, (φ x).1 = x := congr_fun g_sec\n  suffices closure U = «expr ⁻¹' » φ Z₂\n    by\n    rw [this, Set.preimage_comp, ← isClosed_compl_iff, ← preimage_compl, ← preimage_subtype_coe_eq_compl subset.rfl]\n    · exact hZ₁.preimage hφ\n    · rw [hZ₁₂.inter_eq, inter_empty]\n  refine' (closure_minimal _ <| hZ₂.preimage hφ).antisymm fun x hx => _\n  · rintro x hx\n    have : φ x ∈ Z₁ ∪ Z₂ := (g x).2\n    simpa [hx, hφ₁] using this\n  · rw [← hφ₁ x]\n    exact hx.1\n#align compact_t2.projective.extremally_disconnected CompactT2.Projective.extremallyDisconnected\n-/\n\n"}