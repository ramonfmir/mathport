{"union":
 "protected theorem union {s' t'} (h : e.is_image s t) (h' : e.is_image s' t') : e.is_image (s ∪ s') (t ∪ t') :=\n  fun x hx => or_congr (h hx) (h' hx)\n#align union union\n\n",
 "trans_to_local_homeomorph":
 "@[simp, mfld_simps]\ntheorem trans_to_local_homeomorph :\n    (e.trans e').to_local_homeomorph = e.to_local_homeomorph.trans e'.to_local_homeomorph :=\n  LocalHomeomorph.eq_of_localEquiv_eq <| Equiv.trans_toLocalEquiv _ _\n#align trans_to_local_homeomorph trans_to_local_homeomorph\n\n",
 "trans_to_local_equiv":
 "@[simp, mfld_simps]\ntheorem trans_to_local_equiv : (e.trans e').to_local_equiv = e.to_local_equiv.trans e'.to_local_equiv :=\n  rfl\n#align trans_to_local_equiv trans_to_local_equiv\n\n",
 "trans_target''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem trans_target'' : (e.trans e').target = «expr '' » e' (e'.source ∩ e.target) :=\n  trans_source'' e'.symm e.symm\n#align trans_target'' trans_target''\n\n",
 "trans_target'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem trans_target' : (e.trans e').target = e'.target ∩ «expr ⁻¹' » e'.symm (e'.source ∩ e.target) :=\n  trans_source' e'.symm e.symm\n#align trans_target' trans_target'\n\n",
 "trans_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem trans_target : (e.trans e').target = e'.target ∩ «expr ⁻¹' » e'.symm e.target :=\n  rfl\n#align trans_target trans_target\n\n",
 "trans_symm_self":
 "theorem trans_symm_self : e.symm.trans e ≈ LocalHomeomorph.ofSet e.target e.open_target :=\n  e.symm.trans_self_symm\n#align trans_symm_self trans_symm_self\n\n",
 "trans_symm_eq_symm_trans_symm":
 "theorem trans_symm_eq_symm_trans_symm : (e.trans e').symm = e'.symm.trans e.symm := by cases e <;> cases e' <;> rfl\n#align trans_symm_eq_symm_trans_symm trans_symm_eq_symm_trans_symm\n\n",
 "trans_source''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem trans_source'' : (e.trans e').source = «expr '' » e.symm (e.target ∩ e'.source) :=\n  LocalEquiv.trans_source'' e.to_local_equiv e'.to_local_equiv\n#align trans_source'' trans_source''\n\n",
 "trans_source'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem trans_source' : (e.trans e').source = e.source ∩ «expr ⁻¹' » e (e.target ∩ e'.source) :=\n  LocalEquiv.trans_source' e.to_local_equiv e'.to_local_equiv\n#align trans_source' trans_source'\n\n",
 "trans_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- This could be considered as a simp lemma, but there are many situations where it makes something\nsimple into something more complicated. -/\ntheorem trans_source : (e.trans e').source = e.source ∩ «expr ⁻¹' » e e'.source :=\n  LocalEquiv.trans_source e.to_local_equiv e'.to_local_equiv\n#align trans_source trans_source\n\n",
 "trans_self_symm":
 "/-- Composition of a local homeomorphism and its inverse is equivalent to the restriction of the\nidentity to the source -/\ntheorem trans_self_symm : e.trans e.symm ≈ LocalHomeomorph.ofSet e.source e.open_source :=\n  LocalEquiv.trans_self_symm _\n#align trans_self_symm trans_self_symm\n\n",
 "trans_refl":
 "@[simp, mfld_simps]\ntheorem trans_refl : e.trans (LocalHomeomorph.refl β) = e :=\n  eq_of_localEquiv_eq <| LocalEquiv.trans_refl e.to_local_equiv\n#align trans_refl trans_refl\n\n",
 "trans_of_set'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem trans_of_set' {s : Set β} (hs : IsOpen s) : e.trans (ofSet s hs) = e.restr (e.source ∩ «expr ⁻¹' » e s) := by\n  rw [trans_of_set, restr_source_inter]\n#align trans_of_set' trans_of_set'\n\n",
 "trans_of_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem trans_of_set {s : Set β} (hs : IsOpen s) : e.trans (ofSet s hs) = e.restr («expr ⁻¹' » e s) :=\n  (LocalHomeomorph.ext _ _ (fun x => rfl) fun x => rfl) <| by\n    simp [LocalEquiv.trans_source, (e.preimage_interior _).symm, hs.interior_eq]\n#align trans_of_set trans_of_set\n\n",
 "trans_local_homeomorph_eq_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₜ » -/\n#print Homeomorph.transLocalHomeomorph_eq_trans /-\ntheorem Homeomorph.transLocalHomeomorph_eq_trans (e : «expr ≃ₜ » α β) :\n    e.trans_local_homeomorph e' = e.to_local_homeomorph.trans e' :=\n  toLocalEquiv_injective <| Equiv.transLocalEquiv_eq_trans _ _\n#align homeomorph.trans_local_homeomorph_eq_trans Homeomorph.transLocalHomeomorph_eq_trans\n-/\n\n",
 "trans_equiv_eq_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₜ » -/\ntheorem trans_equiv_eq_trans (e' : «expr ≃ₜ » β γ) : e.trans_homeomorph e' = e.trans e'.to_local_homeomorph :=\n  toLocalEquiv_injective <| LocalEquiv.transEquiv_eq_trans _ _\n#align trans_equiv_eq_trans trans_equiv_eq_trans\n\n",
 "trans_assoc":
 "theorem trans_assoc (e'' : LocalHomeomorph γ δ) : (e.trans e').trans e'' = e.trans (e'.trans e'') :=\n  eq_of_localEquiv_eq <| LocalEquiv.trans_assoc e.to_local_equiv e'.to_local_equiv e''.to_local_equiv\n#align trans_assoc trans_assoc\n\n",
 "trans_apply":
 "theorem trans_apply {x : α} : (e.trans e') x = e' (e x) :=\n  rfl\n#align trans_apply trans_apply\n\n",
 "trans'":
 "/-- Composition of local homeomorphisms respects equivalence -/\ntheorem eq_on_source.trans' {e e' : LocalHomeomorph α β} {f f' : LocalHomeomorph β γ} (he : e ≈ e') (hf : f ≈ f') :\n    e.trans f ≈ e'.trans f' :=\n  LocalEquiv.EqOnSource.trans' he hf\n#align eq_on_source.trans' eq_on_source.trans'\n\n",
 "to_open_embedding":
 "/-- A local homeomorphism whose source is all of `α` defines an open embedding of `α` into `β`.  The\nconverse is also true; see `open_embedding.to_local_homeomorph`. -/\ntheorem to_open_embedding (h : e.source = Set.univ) : OpenEmbedding e :=\n  by\n  apply openEmbedding_of_continuous_injective_open\n  · apply continuous_iff_continuous_on_univ.mpr\n    rw [← h]\n    exact e.continuous_to_fun\n  · apply set.injective_iff_inj_on_univ.mpr\n    rw [← h]\n    exact e.inj_on\n  · intro U hU\n    simpa only [h, subset_univ, mfld_simps] using e.image_open_of_open hU\n#align to_open_embedding to_open_embedding\n\n",
 "to_local_equiv_injective":
 "theorem to_local_equiv_injective : injective (to_local_equiv : LocalHomeomorph α β → LocalEquiv α β)\n  | ⟨e, h₁, h₂, h₃, h₄⟩, ⟨e', h₁', h₂', h₃', h₄'⟩, rfl => rfl\n#align to_local_equiv_injective to_local_equiv_injective\n\n",
 "to_local_equiv":
 "theorem to_local_equiv (h : e.is_image s t) : e.to_local_equiv.is_image s t :=\n  h\n#align to_local_equiv to_local_equiv\n\n",
 "to_fun_eq_coe":
 "/- Register a few simp lemmas to make sure that `simp` puts the application of a local\nhomeomorphism in its normal form, i.e., in terms of its coercion to a function. -/\n@[simp, mfld_simps]\ntheorem to_fun_eq_coe (e : LocalHomeomorph α β) : e.to_fun = e :=\n  rfl\n#align to_fun_eq_coe to_fun_eq_coe\n\n",
 "tendsto_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_symm {x} (hx : x ∈ e.source) : Tendsto e.symm ((nhds) (e x)) ((nhds) x) := by\n  simpa only [ContinuousAt, e.left_inv hx] using e.continuous_at_symm (e.map_source hx)\n#align tendsto_symm tendsto_symm\n\n",
 "target_inter_inv_preimage_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem target_inter_inv_preimage_preimage (s : Set β) :\n    e.target ∩ «expr ⁻¹' » e.symm («expr ⁻¹' » e s) = e.target ∩ s :=\n  e.symm.source_inter_preimage_inv_preimage _\n#align target_inter_inv_preimage_preimage target_inter_inv_preimage_preimage\n\n",
 "target_eq":
 "/-- Two equivalent local homeomorphisms have the same target -/\ntheorem eq_on_source.target_eq {e e' : LocalHomeomorph α β} (h : e ≈ e') : e.target = e'.target :=\n  h.symm'.1\n#align eq_on_source.target_eq eq_on_source.target_eq\n\n",
 "symm_to_local_homeomorph":
 "@[simp, mfld_simps]\ntheorem symm_to_local_homeomorph : e.symm.to_local_homeomorph = e.to_local_homeomorph.symm :=\n  rfl\n#align symm_to_local_homeomorph symm_to_local_homeomorph\n\n",
 "symm_to_local_equiv":
 "@[simp, mfld_simps]\ntheorem symm_to_local_equiv : e.symm.to_local_equiv = e.to_local_equiv.symm :=\n  rfl\n#align symm_to_local_equiv symm_to_local_equiv\n\n",
 "symm_target":
 "theorem symm_target : e.symm.target = e.source :=\n  rfl\n#align symm_target symm_target\n\n",
 "symm_symm":
 "@[simp, mfld_simps]\ntheorem symm_symm : e.symm.symm = e :=\n  eq_of_localEquiv_eq <| by simp\n#align symm_symm symm_symm\n\n",
 "symm_source":
 "-- The following lemmas are already simp via local_equiv\ntheorem symm_source : e.symm.source = e.target :=\n  rfl\n#align symm_source symm_source\n\n",
 "symm_piecewise":
 "@[simp]\ntheorem symm_piecewise (e e' : LocalHomeomorph α β) {s : Set α} {t : Set β} [∀ x, Decidable (x ∈ s)]\n    [∀ y, Decidable (y ∈ t)] (H : e.is_image s t) (H' : e'.is_image s t)\n    (Hs : e.source ∩ frontier s = e'.source ∩ frontier s) (Heq : EqOn e e' (e.source ∩ frontier s)) :\n    (e.piecewise e' s t H H' Hs Heq).symm =\n      e.symm.piecewise e'.symm t s H.symm H'.symm (H.frontier.inter_eq_of_inter_eq_of_eq_on H'.frontier Hs Heq)\n        (H.frontier.symm_eq_on_of_inter_eq_of_eq_on Hs Heq) :=\n  rfl\n#align symm_piecewise symm_piecewise\n\n",
 "symm_maps_to":
 "theorem symm_maps_to (h : e.is_image s t) : MapsTo e.symm (e.target ∩ t) (e.source ∩ s) :=\n  h.symm.maps_to\n#align symm_maps_to symm_maps_to\n\n",
 "symm_map_nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem symm_map_nhds_eq {x} (hx : x ∈ e.source) : map e.symm ((nhds) (e x)) = (nhds) x :=\n  (e.symm.map_nhds_eq <| e.map_source hx).trans <| by rw [e.left_inv hx]\n#align symm_map_nhds_eq symm_map_nhds_eq\n\n",
 "symm_image_target_inter_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem symm_image_target_inter_eq (s : Set β) :\n    «expr '' » e.symm (e.target ∩ s) = e.source ∩ «expr ⁻¹' » e (e.target ∩ s) :=\n  e.symm.image_source_inter_eq _\n#align symm_image_target_inter_eq symm_image_target_inter_eq\n\n",
 "symm_image_target_eq_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem symm_image_target_eq_source (e : LocalHomeomorph α β) : «expr '' » e.symm e.target = e.source :=\n  e.symm.image_source_eq_target\n#align symm_image_target_eq_source symm_image_target_eq_source\n\n",
 "symm_image_eq_source_inter_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem symm_image_eq_source_inter_preimage {s : Set β} (h : s ⊆ e.target) :\n    «expr '' » e.symm s = e.source ∩ «expr ⁻¹' » e s :=\n  e.symm.image_eq_target_inter_inv_preimage h\n#align symm_image_eq_source_inter_preimage symm_image_eq_source_inter_preimage\n\n",
 "symm_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem symm_image_eq (h : e.is_image s t) : «expr '' » e.symm (e.target ∩ t) = e.source ∩ s :=\n  h.symm.image_eq\n#align symm_image_eq symm_image_eq\n\n",
 "symm_iff":
 "@[simp]\ntheorem symm_iff : e.symm.is_image t s ↔ e.is_image s t :=\n  ⟨fun h => h.symm, fun h => h.symm⟩\n#align symm_iff symm_iff\n\n",
 "symm_eq_on_target":
 "/-- Two equivalent local homeomorphisms have coinciding `inv_fun` on the target -/\ntheorem eq_on_source.symm_eq_on_target {e e' : LocalHomeomorph α β} (h : e ≈ e') : EqOn e.symm e'.symm e.target :=\n  h.symm'.2\n#align eq_on_source.symm_eq_on_target eq_on_source.symm_eq_on_target\n\n",
 "symm_eq_on_of_inter_eq_of_eq_on":
 "theorem symm_eq_on_of_inter_eq_of_eq_on {e' : LocalHomeomorph α β} (h : e.is_image s t)\n    (hs : e.source ∩ s = e'.source ∩ s) (Heq : EqOn e e' (e.source ∩ s)) : EqOn e.symm e'.symm (e.target ∩ t) :=\n  h.to_local_equiv.symm_eq_on_of_inter_eq_of_eq_on hs Heq\n#align symm_eq_on_of_inter_eq_of_eq_on symm_eq_on_of_inter_eq_of_eq_on\n\n",
 "symm_apply_mem_iff":
 "theorem symm_apply_mem_iff (h : e.is_image s t) (hy : y ∈ e.target) : e.symm y ∈ s ↔ y ∈ t :=\n  h.symm hy\n#align symm_apply_mem_iff symm_apply_mem_iff\n\n",
 "symm'":
 "/-- If two local homeomorphisms are equivalent, so are their inverses -/\ntheorem eq_on_source.symm' {e e' : LocalHomeomorph α β} (h : e ≈ e') : e.symm ≈ e'.symm :=\n  LocalEquiv.EqOnSource.symm' h\n#align eq_on_source.symm' eq_on_source.symm'\n\n",
 "symm":
 "#print symm /-\nprotected theorem symm (h : e.is_image s t) : e.symm.is_image t s :=\n  h.to_local_equiv.symm\n#align symm symm\n-/\n\n",
 "surj_on":
 "protected theorem surj_on : SurjOn e e.source e.target :=\n  e.bij_on.surj_on\n#align surj_on surj_on\n\n",
 "subtype_restr_symm_trans_subtype_restr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- This lemma characterizes the transition functions of an open subset in terms of the transition\nfunctions of the original space. -/\ntheorem subtype_restr_symm_trans_subtype_restr (f f' : LocalHomeomorph α β) :\n    (f.subtype_restr s).symm.trans (f'.subtype_restr s) ≈ (f.symm.trans f').restr (f.target ∩ «expr ⁻¹' » f.symm s) :=\n  by\n  simp only [subtype_restr_def, trans_symm_eq_symm_trans_symm]\n  have openness₁ : IsOpen (f.target ∩ «expr ⁻¹' » f.symm s) := f.preimage_open_of_open_symm s.2\n  rw [← of_set_trans _ openness₁, ← trans_assoc, ← trans_assoc]\n  refine' eq_on_source.trans' _ (eq_on_source_refl _)\n  -- f' has been eliminated !!!\n  have sets_identity : f.symm.source ∩ (f.target ∩ «expr ⁻¹' » f.symm s) = f.symm.source ∩ «expr ⁻¹' » f.symm s := by\n    mfld_set_tac\n  have openness₂ : IsOpen (s : Set α) := s.2\n  rw [of_set_trans', sets_identity, ← trans_of_set' _ openness₂, trans_assoc]\n  refine' eq_on_source.trans' (eq_on_source_refl _) _\n  -- f has been eliminated !!!\n  refine' setoid.trans (trans_symm_self s.local_homeomorph_subtype_coe) _\n  simp only [mfld_simps]\n#align subtype_restr_symm_trans_subtype_restr subtype_restr_symm_trans_subtype_restr\n\n",
 "subtype_restr_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp, mfld_simps]\ntheorem subtype_restr_source : (e.subtype_restr s).source = «expr ⁻¹' » coe e.source := by\n  simp only [subtype_restr_def, mfld_simps]\n#align subtype_restr_source subtype_restr_source\n\n",
 "subtype_restr_def":
 "theorem subtype_restr_def : e.subtype_restr s = s.local_homeomorph_subtype_coe.trans e :=\n  rfl\n#align subtype_restr_def subtype_restr_def\n\n",
 "subtype_restr_coe":
 "@[simp, mfld_simps]\ntheorem subtype_restr_coe : ((e.subtype_restr s : LocalHomeomorph s β) : s → β) = Set.restrict ↑s (e : α → β) :=\n  rfl\n#align subtype_restr_coe subtype_restr_coe\n\n",
 "source_preimage_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem source_preimage_target : e.source ⊆ «expr ⁻¹' » e e.target :=\n  e.maps_to\n#align source_preimage_target source_preimage_target\n\n",
 "source_inter_preimage_target_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem source_inter_preimage_target_inter (s : Set β) :\n    e.source ∩ «expr ⁻¹' » e (e.target ∩ s) = e.source ∩ «expr ⁻¹' » e s :=\n  e.to_local_equiv.source_inter_preimage_target_inter s\n#align source_inter_preimage_target_inter source_inter_preimage_target_inter\n\n",
 "source_inter_preimage_inv_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem source_inter_preimage_inv_preimage (s : Set α) :\n    e.source ∩ «expr ⁻¹' » e («expr ⁻¹' » e.symm s) = e.source ∩ s :=\n  e.to_local_equiv.source_inter_preimage_inv_preimage s\n#align source_inter_preimage_inv_preimage source_inter_preimage_inv_preimage\n\n",
 "source_eq":
 "/-- Two equivalent local homeomorphisms have the same source -/\ntheorem eq_on_source.source_eq {e e' : LocalHomeomorph α β} (h : e ≈ e') : e.source = e'.source :=\n  h.1\n#align eq_on_source.source_eq eq_on_source.source_eq\n\n",
 "second_countable_topology_source":
 "theorem second_countable_topology_source [SecondCountableTopology β] (e : LocalHomeomorph α β) :\n    SecondCountableTopology e.source :=\n  e.to_homeomorph_source_target.second_countable_topology\n#align second_countable_topology_source second_countable_topology_source\n\n",
 "right_inv_on":
 "protected theorem right_inv_on : RightInvOn e.symm e e.target := fun x => e.right_inv\n#align right_inv_on right_inv_on\n\n",
 "right_inv":
 "@[simp, mfld_simps]\ntheorem right_inv {x : β} (h : x ∈ e.target) : e (e.symm x) = x :=\n  e.right_inv' h\n#align right_inv right_inv\n\n",
 "restr_univ":
 "@[simp, mfld_simps]\ntheorem restr_univ {e : LocalHomeomorph α β} : e.restr univ = e :=\n  restr_eq_of_source_subset (subset_univ _)\n#align restr_univ restr_univ\n\n",
 "restr_trans":
 "theorem restr_trans (s : Set α) : (e.restr s).trans e' = (e.trans e').restr s :=\n  eq_of_localEquiv_eq <| LocalEquiv.restr_trans e.to_local_equiv e'.to_local_equiv (interior s)\n#align restr_trans restr_trans\n\n",
 "restr_to_local_equiv'":
 "theorem restr_to_local_equiv' (s : Set α) (hs : IsOpen s) : (e.restr s).to_local_equiv = e.to_local_equiv.restr s := by\n  rw [e.restr_to_local_equiv, hs.interior_eq]\n#align restr_to_local_equiv' restr_to_local_equiv'\n\n",
 "restr_to_local_equiv":
 "@[simp, mfld_simps]\ntheorem restr_to_local_equiv (s : Set α) : (e.restr s).to_local_equiv = e.to_local_equiv.restr (interior s) :=\n  rfl\n#align restr_to_local_equiv restr_to_local_equiv\n\n",
 "restr_source_inter":
 "theorem restr_source_inter (s : Set α) : e.restr (e.source ∩ s) = e.restr s :=\n  by\n  refine' LocalHomeomorph.ext _ _ (fun x => rfl) (fun x => rfl) _\n  simp [e.open_source.interior_eq, ← inter_assoc]\n#align restr_source_inter restr_source_inter\n\n",
 "restr_source'":
 "theorem restr_source' (s : Set α) (hs : IsOpen s) : (e.restr s).source = e.source ∩ s := by\n  rw [e.restr_source, hs.interior_eq]\n#align restr_source' restr_source'\n\n",
 "restr_open_to_local_equiv":
 "@[simp, mfld_simps]\ntheorem restr_open_to_local_equiv (s : Set α) (hs : IsOpen s) :\n    (e.restr_open s hs).to_local_equiv = e.to_local_equiv.restr s :=\n  rfl\n#align restr_open_to_local_equiv restr_open_to_local_equiv\n\n",
 "restr_open_source":
 "-- Already simp via local_equiv\ntheorem restr_open_source (s : Set α) (hs : IsOpen s) : (e.restr_open s hs).source = e.source ∩ s :=\n  rfl\n#align restr_open_source restr_open_source\n\n",
 "restr_eq_on_source":
 "theorem set.eq_on.restr_eq_on_source {e e' : LocalHomeomorph α β} (h : EqOn e e' (e.source ∩ e'.source)) :\n    e.restr e'.source ≈ e'.restr e.source := by\n  constructor\n  · rw [e'.restr_source' _ e.open_source]\n    rw [e.restr_source' _ e'.open_source]\n    exact Set.inter_comm _ _\n  · rw [e.restr_source' _ e'.open_source]\n    refine' (eq_on.trans _ h).trans _ <;> simp only [mfld_simps]\n#align set.eq_on.restr_eq_on_source set.eq_on.restr_eq_on_source\n\n",
 "restr_eq_of_source_subset":
 "theorem restr_eq_of_source_subset {e : LocalHomeomorph α β} {s : Set α} (h : e.source ⊆ s) : e.restr s = e :=\n  by\n  apply eq_of_local_equiv_eq\n  rw [restr_to_local_equiv]\n  apply LocalEquiv.restr_eq_of_source_subset\n  exact interior_maximal h e.open_source\n#align restr_eq_of_source_subset restr_eq_of_source_subset\n\n",
 "restr":
 "/-- Restriction of local homeomorphisms respects equivalence -/\ntheorem eq_on_source.restr {e e' : LocalHomeomorph α β} (he : e ≈ e') (s : Set α) : e.restr s ≈ e'.restr s :=\n  LocalEquiv.EqOnSource.restr he _\n#align eq_on_source.restr eq_on_source.restr\n\n",
 "replace_equiv_eq_self":
 "theorem replace_equiv_eq_self (e : LocalHomeomorph α β) (e' : LocalEquiv α β) (h : e.to_local_equiv = e') :\n    e.replace_equiv e' h = e := by\n  cases e\n  subst e'\n  rfl\n#align replace_equiv_eq_self replace_equiv_eq_self\n\n",
 "refl_trans":
 "@[simp, mfld_simps]\ntheorem refl_trans : (LocalHomeomorph.refl α).trans e = e :=\n  eq_of_localEquiv_eq <| LocalEquiv.refl_trans e.to_local_equiv\n#align refl_trans refl_trans\n\n",
 "refl_to_local_homeomorph":
 "/- Register as simp lemmas that the fields of a local homeomorphism built from a homeomorphism\ncorrespond to the fields of the original homeomorphism. -/\n@[simp, mfld_simps]\ntheorem refl_to_local_homeomorph : (Homeomorph.refl α).to_local_homeomorph = LocalHomeomorph.refl α :=\n  rfl\n#align refl_to_local_homeomorph refl_to_local_homeomorph\n\n",
 "refl_symm":
 "@[simp, mfld_simps]\ntheorem refl_symm : (LocalHomeomorph.refl α).symm = LocalHomeomorph.refl α :=\n  rfl\n#align refl_symm refl_symm\n\n",
 "refl_prod_refl":
 "@[simp]\ntheorem refl_prod_refl {α β : Type _} [TopologicalSpace α] [TopologicalSpace β] :\n    (LocalHomeomorph.refl α).prod (LocalHomeomorph.refl β) = LocalHomeomorph.refl (α × β) :=\n  by\n  ext1 ⟨x, y⟩\n  · rfl\n  · rintro ⟨x, y⟩\n    rfl\n  exact univ_prod_univ\n#align refl_prod_refl refl_prod_refl\n\n",
 "refl_local_equiv":
 "@[simp, mfld_simps]\ntheorem refl_local_equiv : (LocalHomeomorph.refl α).to_local_equiv = LocalEquiv.refl α :=\n  rfl\n#align refl_local_equiv refl_local_equiv\n\n",
 "prod_trans":
 "@[simp, mfld_simps]\ntheorem prod_trans {η : Type _} {ε : Type _} [TopologicalSpace η] [TopologicalSpace ε] (e : LocalHomeomorph α β)\n    (f : LocalHomeomorph β γ) (e' : LocalHomeomorph δ η) (f' : LocalHomeomorph η ε) :\n    (e.prod e').trans (f.prod f') = (e.trans f).prod (e'.trans f') :=\n  LocalHomeomorph.eq_of_localEquiv_eq <| by\n    dsimp only [trans_to_local_equiv, prod_to_local_equiv] <;> apply LocalEquiv.prod_trans\n#align prod_trans prod_trans\n\n",
 "prod_symm":
 "@[simp, mfld_simps]\ntheorem prod_symm (e : LocalHomeomorph α β) (e' : LocalHomeomorph γ δ) : (e.prod e').symm = e.symm.prod e'.symm :=\n  rfl\n#align prod_symm prod_symm\n\n",
 "prod_eq_prod_of_nonempty'":
 "theorem prod_eq_prod_of_nonempty' {e₁ e₁' : LocalHomeomorph α β} {e₂ e₂' : LocalHomeomorph γ δ}\n    (h : (e₁'.prod e₂').source.nonempty) : e₁.prod e₂ = e₁'.prod e₂' ↔ e₁ = e₁' ∧ e₂ = e₂' := by\n  rw [eq_comm, prod_eq_prod_of_nonempty h, eq_comm, @eq_comm _ e₂']\n#align prod_eq_prod_of_nonempty' prod_eq_prod_of_nonempty'\n\n",
 "prod_eq_prod_of_nonempty":
 "theorem prod_eq_prod_of_nonempty {e₁ e₁' : LocalHomeomorph α β} {e₂ e₂' : LocalHomeomorph γ δ}\n    (h : (e₁.prod e₂).source.nonempty) : e₁.prod e₂ = e₁'.prod e₂' ↔ e₁ = e₁' ∧ e₂ = e₂' :=\n  by\n  obtain ⟨⟨x, y⟩, -⟩ := id h\n  haveI : Nonempty α := ⟨x⟩\n  haveI : Nonempty β := ⟨e₁ x⟩\n  haveI : Nonempty γ := ⟨y⟩\n  haveI : Nonempty δ := ⟨e₂ y⟩\n  simp_rw [LocalHomeomorph.ext_iff, prod_apply, prod_symm_apply, prod_source, Prod.ext_iff,\n    Set.prod_eq_prod_iff_of_nonempty h, forall_and, Prod.forall, forall_const, forall_forall_const, and_assoc',\n    and_left_comm]\n#align prod_eq_prod_of_nonempty prod_eq_prod_of_nonempty\n\n",
 "preimage_open_of_open_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_open_of_open_symm {s : Set α} (hs : IsOpen s) : IsOpen (e.target ∩ «expr ⁻¹' » e.symm s) :=\n  e.symm.continuous_on.preimage_open_of_open e.open_target hs\n#align preimage_open_of_open_symm preimage_open_of_open_symm\n\n",
 "preimage_open_of_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_open_of_open {s : Set β} (hs : IsOpen s) : IsOpen (e.source ∩ «expr ⁻¹' » e s) :=\n  e.continuous_on.preimage_open_of_open e.open_source hs\n#align preimage_open_of_open preimage_open_of_open\n\n",
 "preimage_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- Preimage of interior or interior of preimage coincide for local homeomorphisms, when restricted\nto the source. -/\ntheorem preimage_interior (s : Set β) : e.source ∩ «expr ⁻¹' » e (interior s) = e.source ∩ interior («expr ⁻¹' » e s) :=\n  (IsImage.of_preimage_eq rfl).interior.preimage_eq\n#align preimage_interior preimage_interior\n\n",
 "preimage_frontier":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_frontier (s : Set β) : e.source ∩ «expr ⁻¹' » e (frontier s) = e.source ∩ frontier («expr ⁻¹' » e s) :=\n  (IsImage.of_preimage_eq rfl).frontier.preimage_eq\n#align preimage_frontier preimage_frontier\n\n",
 "preimage_eventually_eq_target_inter_preimage_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- This lemma is useful in the manifold library in the case that `e` is a chart. It states that\n  locally around `e x` the set `e.symm ⁻¹' s` is the same as the set intersected with the target\n  of `e` and some other neighborhood of `f x` (which will be the source of a chart on `γ`).  -/\ntheorem preimage_eventually_eq_target_inter_preimage_inter {e : LocalHomeomorph α β} {s : Set α} {t : Set γ} {x : α}\n    {f : α → γ} (hf : ContinuousWithinAt f s x) (hxe : x ∈ e.source) (ht : t ∈ (nhds) (f x)) :\n    «expr =ᶠ[ ] » («expr ⁻¹' » e.symm s) ((nhds) (e x)) (e.target ∩ «expr ⁻¹' » e.symm (s ∩ «expr ⁻¹' » f t) : Set β) :=\n  by\n  rw [eventually_eq_set, e.eventually_nhds _ hxe]\n  filter_upwards [e.open_source.mem_nhds hxe, mem_nhds_within_iff_eventually.mp (hf.preimage_mem_nhds_within ht)]\n  intro y hy hyu\n  simp_rw [mem_inter_iff, mem_preimage, mem_inter_iff, e.maps_to hy, true_and_iff, iff_self_and, e.left_inv hy,\n    iff_true_intro hyu]\n#align preimage_eventually_eq_target_inter_preimage_inter preimage_eventually_eq_target_inter_preimage_inter\n\n",
 "preimage_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_closure (s : Set β) : e.source ∩ «expr ⁻¹' » e (closure s) = e.source ∩ closure («expr ⁻¹' » e s) :=\n  (IsImage.of_preimage_eq rfl).closure.preimage_eq\n#align preimage_closure preimage_closure\n\n",
 "of_symm_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem of_symm_image_eq (h : «expr '' » e.symm (e.target ∩ t) = e.source ∩ s) : e.is_image s t :=\n  LocalEquiv.IsImage.of_symm_image_eq h\n#align of_symm_image_eq of_symm_image_eq\n\n",
 "of_set_univ_eq_refl":
 "@[simp, mfld_simps]\ntheorem of_set_univ_eq_refl : ofSet univ isOpen_univ = LocalHomeomorph.refl α := by ext <;> simp\n#align of_set_univ_eq_refl of_set_univ_eq_refl\n\n",
 "of_set_trans_of_set":
 "@[simp, mfld_simps]\ntheorem of_set_trans_of_set {s : Set α} (hs : IsOpen s) {s' : Set α} (hs' : IsOpen s') :\n    (ofSet s hs).trans (ofSet s' hs') = ofSet (s ∩ s') (IsOpen.inter hs hs') :=\n  by\n  rw [(of_set s hs).trans_of_set hs']\n  ext <;> simp [hs'.interior_eq]\n#align of_set_trans_of_set of_set_trans_of_set\n\n",
 "of_set_trans'":
 "theorem of_set_trans' {s : Set α} (hs : IsOpen s) : (ofSet s hs).trans e = e.restr (e.source ∩ s) := by\n  rw [of_set_trans, restr_source_inter]\n#align of_set_trans' of_set_trans'\n\n",
 "of_set_trans":
 "theorem of_set_trans {s : Set α} (hs : IsOpen s) : (ofSet s hs).trans e = e.restr s :=\n  (LocalHomeomorph.ext _ _ (fun x => rfl) fun x => rfl) <| by simp [LocalEquiv.trans_source, hs.interior_eq, inter_comm]\n#align of_set_trans of_set_trans\n\n",
 "of_set_to_local_equiv":
 "@[simp, mfld_simps]\ntheorem of_set_to_local_equiv : (ofSet s hs).to_local_equiv = LocalEquiv.ofSet s :=\n  rfl\n#align of_set_to_local_equiv of_set_to_local_equiv\n\n",
 "of_set_symm":
 "@[simp, mfld_simps]\ntheorem of_set_symm : (ofSet s hs).symm = ofSet s hs :=\n  rfl\n#align of_set_symm of_set_symm\n\n",
 "of_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem of_image_eq (h : «expr '' » e (e.source ∩ s) = e.target ∩ t) : e.is_image s t :=\n  LocalEquiv.IsImage.of_image_eq h\n#align of_image_eq of_image_eq\n\n",
 "nhds_within_target_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem nhds_within_target_inter {x} (hx : x ∈ e.target) (s : Set β) : nhds_within (e.target ∩ s) x = nhds_within s x :=\n  e.symm.nhds_within_source_inter hx s\n#align nhds_within_target_inter nhds_within_target_inter\n\n",
 "nhds_within_source_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem nhds_within_source_inter {x} (hx : x ∈ e.source) (s : Set α) : nhds_within (e.source ∩ s) x = nhds_within s x :=\n  nhdsWithin_inter_of_mem (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds e.open_source hx)\n#align nhds_within_source_inter nhds_within_source_inter\n\n",
 "mk_coe_symm":
 "@[simp, mfld_simps]\ntheorem mk_coe_symm (e : LocalEquiv α β) (a b c d) : ((local_homeomorph.mk e a b c d).symm : β → α) = e.symm :=\n  rfl\n#align mk_coe_symm mk_coe_symm\n\n",
 "mk_coe":
 "@[simp, mfld_simps]\ntheorem mk_coe (e : LocalEquiv α β) (a b c d) : (local_homeomorph.mk e a b c d : α → β) = e :=\n  rfl\n#align mk_coe mk_coe\n\n",
 "maps_to":
 "protected theorem maps_to (h : e.is_image s t) : MapsTo e (e.source ∩ s) (e.target ∩ t) :=\n  h.to_local_equiv.maps_to\n#align maps_to maps_to\n\n",
 "map_target":
 "@[simp, mfld_simps]\ntheorem map_target {x : β} (h : x ∈ e.target) : e.symm x ∈ e.source :=\n  e.map_target' h\n#align map_target map_target\n\n",
 "map_source":
 "@[simp, mfld_simps]\ntheorem map_source {x : α} (h : x ∈ e.source) : e x ∈ e.target :=\n  e.map_source' h\n#align map_source map_source\n\n",
 "map_nhds_within_preimage_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem map_nhds_within_preimage_eq (e : LocalHomeomorph α β) {x} (hx : x ∈ e.source) (s : Set β) :\n    map e (nhds_within («expr ⁻¹' » e s) x) = nhds_within s (e x) := by\n  rw [e.map_nhds_within_eq hx, e.image_source_inter_eq', e.target_inter_inv_preimage_preimage,\n    e.nhds_within_target_inter (e.map_source hx)]\n#align map_nhds_within_preimage_eq map_nhds_within_preimage_eq\n\n",
 "map_nhds_within_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem map_nhds_within_eq (h : e.is_image s t) (hx : x ∈ e.source) : map e (nhds_within s x) = nhds_within t (e x) :=\n  by rw [e.map_nhds_within_eq hx, h.image_eq, e.nhds_within_target_inter (e.map_source hx)]\n#align map_nhds_within_eq map_nhds_within_eq\n\n",
 "map_nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem map_nhds_eq {x} (hx : x ∈ e.source) : map e ((nhds) x) = (nhds) (e x) :=\n  le_antisymm (e.continuous_at hx) <| le_map_of_right_inverse (e.eventually_right_inverse' hx) (e.tendsto_symm hx)\n#align map_nhds_eq map_nhds_eq\n\n",
 "local_homeomorph_subtype_coe_target":
 "@[simp, mfld_simps]\ntheorem local_homeomorph_subtype_coe_target : s.local_homeomorph_subtype_coe.target = s :=\n  by\n  simp only [local_homeomorph_subtype_coe, Subtype.range_coe_subtype, mfld_simps]\n  rfl\n#align local_homeomorph_subtype_coe_target local_homeomorph_subtype_coe_target\n\n",
 "local_homeomorph_subtype_coe_source":
 "@[simp, mfld_simps]\ntheorem local_homeomorph_subtype_coe_source : s.local_homeomorph_subtype_coe.source = Set.univ :=\n  rfl\n#align local_homeomorph_subtype_coe_source local_homeomorph_subtype_coe_source\n\n",
 "local_homeomorph_subtype_coe_coe":
 "@[simp, mfld_simps]\ntheorem local_homeomorph_subtype_coe_coe : (s.local_homeomorph_subtype_coe : s → α) = coe :=\n  rfl\n#align local_homeomorph_subtype_coe_coe local_homeomorph_subtype_coe_coe\n\n",
 "left_inv_on_piecewise":
 "theorem left_inv_on_piecewise {e' : LocalHomeomorph α β} [∀ i, Decidable (i ∈ s)] [∀ i, Decidable (i ∈ t)]\n    (h : e.is_image s t) (h' : e'.is_image s t) :\n    LeftInvOn (t.piecewise e.symm e'.symm) (s.piecewise e e') (s.ite e.source e'.source) :=\n  h.to_local_equiv.left_inv_on_piecewise h'\n#align left_inv_on_piecewise left_inv_on_piecewise\n\n",
 "left_inv_on":
 "protected theorem left_inv_on : LeftInvOn e.symm e e.source := fun x => e.left_inv\n#align left_inv_on left_inv_on\n\n",
 "left_inv":
 "@[simp, mfld_simps]\ntheorem left_inv {x : α} (h : x ∈ e.source) : e.symm (e x) = x :=\n  e.left_inv' h\n#align left_inv left_inv\n\n",
 "is_open_iff":
 "theorem is_open_iff (h : e.is_image s t) : IsOpen (e.source ∩ s) ↔ IsOpen (e.target ∩ t) :=\n  ⟨fun hs => h.symm_preimage_eq' ▸ e.symm.preimage_open_of_open hs, fun hs =>\n    h.preimage_eq' ▸ e.preimage_open_of_open hs⟩\n#align is_open_iff is_open_iff\n\n",
 "is_image_source_target_of_disjoint":
 "theorem is_image_source_target_of_disjoint (e' : LocalHomeomorph α β) (hs : Disjoint e.source e'.source)\n    (ht : Disjoint e.target e'.target) : e.is_image e'.source e'.target :=\n  e.to_local_equiv.is_image_source_target_of_disjoint e'.to_local_equiv hs ht\n#align is_image_source_target_of_disjoint is_image_source_target_of_disjoint\n\n",
 "is_image_source_target":
 "theorem is_image_source_target : e.is_image e.source e.target :=\n  e.to_local_equiv.is_image_source_target\n#align is_image_source_target is_image_source_target\n\n",
 "inv_on":
 "protected theorem inv_on : InvOn e.symm e e.source e.target :=\n  ⟨e.left_inv_on, e.right_inv_on⟩\n#align inv_on inv_on\n\n",
 "inv_image_trans_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem inv_image_trans_target : «expr '' » e'.symm (e.trans e').target = e'.source ∩ e.target :=\n  image_trans_source e'.symm e.symm\n#align inv_image_trans_target inv_image_trans_target\n\n",
 "inv_fun_eq_coe":
 "@[simp, mfld_simps]\ntheorem inv_fun_eq_coe (e : LocalHomeomorph α β) : e.inv_fun = e.symm :=\n  rfl\n#align inv_fun_eq_coe inv_fun_eq_coe\n\n",
 "interior":
 "#print interior /-\nprotected theorem interior (h : e.is_image s t) : e.is_image (interior s) (interior t) := by\n  simpa only [closure_compl, compl_compl] using h.compl.closure.compl\n#align interior interior\n-/\n\n",
 "inter_eq_of_inter_eq_of_eq_on":
 "theorem inter_eq_of_inter_eq_of_eq_on {e' : LocalHomeomorph α β} (h : e.is_image s t) (h' : e'.is_image s t)\n    (hs : e.source ∩ s = e'.source ∩ s) (Heq : EqOn e e' (e.source ∩ s)) : e.target ∩ t = e'.target ∩ t :=\n  h.to_local_equiv.inter_eq_of_inter_eq_of_eq_on h' hs Heq\n#align inter_eq_of_inter_eq_of_eq_on inter_eq_of_inter_eq_of_eq_on\n\n",
 "inter":
 "protected theorem inter {s' t'} (h : e.is_image s t) (h' : e.is_image s' t') : e.is_image (s ∩ s') (t ∩ t') :=\n  fun x hx => and_congr (h hx) (h' hx)\n#align inter inter\n\n",
 "inj_on":
 "protected theorem inj_on : InjOn e e.source :=\n  e.left_inv_on.inj_on\n#align inj_on inj_on\n\n",
 "image_trans_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_trans_source : «expr '' » e (e.trans e').source = e.target ∩ e'.source :=\n  LocalEquiv.image_trans_source e.to_local_equiv e'.to_local_equiv\n#align image_trans_source image_trans_source\n\n",
 "image_source_inter_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem image_source_inter_eq' (s : Set α) : «expr '' » e (e.source ∩ s) = e.target ∩ «expr ⁻¹' » e.symm s :=\n  e.to_local_equiv.image_source_inter_eq' s\n#align image_source_inter_eq' image_source_inter_eq'\n\n",
 "image_source_inter_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem image_source_inter_eq (s : Set α) :\n    «expr '' » e (e.source ∩ s) = e.target ∩ «expr ⁻¹' » e.symm (e.source ∩ s) :=\n  e.to_local_equiv.image_source_inter_eq s\n#align image_source_inter_eq image_source_inter_eq\n\n",
 "image_source_eq_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_source_eq_target (e : LocalHomeomorph α β) : «expr '' » e e.source = e.target :=\n  e.to_local_equiv.image_source_eq_target\n#align image_source_eq_target image_source_eq_target\n\n",
 "image_open_of_open'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image of the restriction of an open set to the source is open. -/\ntheorem image_open_of_open' {s : Set α} (hs : IsOpen s) : IsOpen («expr '' » e (e.source ∩ s)) :=\n  image_open_of_open _ (IsOpen.inter e.open_source hs) (inter_subset_left _ _)\n#align image_open_of_open' image_open_of_open'\n\n",
 "image_open_of_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image of an open set in the source is open. -/\ntheorem image_open_of_open {s : Set α} (hs : IsOpen s) (h : s ⊆ e.source) : IsOpen («expr '' » e s) :=\n  by\n  have : «expr '' » e s = e.target ∩ «expr ⁻¹' » e.symm s := e.to_local_equiv.image_eq_target_inter_inv_preimage h\n  rw [this]\n  exact e.continuous_on_symm.preimage_open_of_open e.open_target hs\n#align image_open_of_open image_open_of_open\n\n",
 "image_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem image_mem_nhds {x} (hx : x ∈ e.source) {s : Set α} (hs : s ∈ (nhds) x) : «expr '' » e s ∈ (nhds) (e x) :=\n  e.map_nhds_eq hx ▸ Filter.image_mem_map hs\n#align image_mem_nhds image_mem_nhds\n\n",
 "image_eq_target_inter_inv_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem image_eq_target_inter_inv_preimage {s : Set α} (h : s ⊆ e.source) :\n    «expr '' » e s = e.target ∩ «expr ⁻¹' » e.symm s :=\n  e.to_local_equiv.image_eq_target_inter_inv_preimage h\n#align image_eq_target_inter_inv_preimage image_eq_target_inter_inv_preimage\n\n",
 "image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_eq (h : e.is_image s t) : «expr '' » e (e.source ∩ s) = e.target ∩ t :=\n  h.to_local_equiv.image_eq\n#align image_eq image_eq\n\n",
 "iff_symm_preimage_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem iff_symm_preimage_eq' : e.is_image s t ↔ e.target ∩ «expr ⁻¹' » e.symm (e.source ∩ s) = e.target ∩ t := by\n  rw [iff_symm_preimage_eq, ← image_source_inter_eq, ← image_source_inter_eq']\n#align iff_symm_preimage_eq' iff_symm_preimage_eq'\n\n",
 "iff_symm_preimage_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem iff_symm_preimage_eq : e.is_image s t ↔ e.target ∩ «expr ⁻¹' » e.symm s = e.target ∩ t :=\n  symm_iff.symm.trans iff_preimage_eq\n#align iff_symm_preimage_eq iff_symm_preimage_eq\n\n",
 "iff_preimage_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem iff_preimage_eq' : e.is_image s t ↔ e.source ∩ «expr ⁻¹' » e (e.target ∩ t) = e.source ∩ s :=\n  symm_iff.symm.trans iff_symm_preimage_eq'\n#align iff_preimage_eq' iff_preimage_eq'\n\n",
 "iff_preimage_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem iff_preimage_eq : e.is_image s t ↔ e.source ∩ «expr ⁻¹' » e t = e.source ∩ s :=\n  LocalEquiv.IsImage.iff_preimage_eq\n#align iff_preimage_eq iff_preimage_eq\n\n",
 "frontier":
 "#print frontier /-\nprotected theorem frontier (h : e.is_image s t) : e.is_image (frontier s) (frontier t) :=\n  h.closure.diff h.interior\n#align frontier frontier\n-/\n\n",
 "ext_iff":
 "protected theorem ext_iff {e e' : LocalHomeomorph α β} :\n    e = e' ↔ (∀ x, e x = e' x) ∧ (∀ x, e.symm x = e'.symm x) ∧ e.source = e'.source :=\n  ⟨by\n    rintro rfl\n    exact ⟨fun x => rfl, fun x => rfl, rfl⟩, fun h => e.ext e' h.1 h.2.1 h.2.2⟩\n#align ext_iff ext_iff\n\n",
 "ext":
 "/-- Two local homeomorphisms are equal when they have equal `to_fun`, `inv_fun` and `source`.\nIt is not sufficient to have equal `to_fun` and `source`, as this only determines `inv_fun` on\nthe target. This would only be true for a weaker notion of equality, arguably the right one,\ncalled `eq_on_source`. -/\n@[ext]\nprotected theorem ext (e' : LocalHomeomorph α β) (h : ∀ x, e x = e' x) (hinv : ∀ x, e.symm x = e'.symm x)\n    (hs : e.source = e'.source) : e = e' :=\n  eq_of_localEquiv_eq (LocalEquiv.ext h hinv hs)\n#align ext ext\n\n",
 "eventually_right_inverse'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_right_inverse' (e : LocalHomeomorph α β) {x} (hx : x ∈ e.source) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((nhds) (e x)) (e (e.symm y) = y) :=\n  e.eventually_right_inverse (e.map_source hx)\n#align eventually_right_inverse' eventually_right_inverse'\n\n",
 "eventually_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_right_inverse (e : LocalHomeomorph α β) {x} (hx : x ∈ e.target) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n      (e (e.symm y) = y) :=\n  (e.open_target.eventually_mem hx).mono e.right_inv'\n#align eventually_right_inverse eventually_right_inverse\n\n",
 "eventually_nhds_within'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem eventually_nhds_within' (e : LocalHomeomorph α β) {x : α} (p : α → Prop) {s : Set α} (hx : x ∈ e.source) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (nhds_within («expr ⁻¹' » e.symm s) (e x)) (p (e.symm y)) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (nhds_within s x) (p x) :=\n  by\n  rw [e.eventually_nhds_within _ hx]\n  refine'\n    eventually_congr ((eventually_nhdsWithin_of_eventually_nhds <| e.eventually_left_inverse hx).mono fun y hy => _)\n  rw [hy]\n#align eventually_nhds_within' eventually_nhds_within'\n\n",
 "eventually_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem eventually_nhds_within (e : LocalHomeomorph α β) {x : α} (p : β → Prop) {s : Set α} (hx : x ∈ e.source) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (nhds_within («expr ⁻¹' » e.symm s) (e x)) (p y) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (nhds_within s x) (p (e x)) :=\n  by\n  refine' iff.trans _ eventually_map\n  rw [e.map_nhds_within_eq hx, e.image_source_inter_eq', e.nhds_within_target_inter (e.maps_to hx)]\n#align eventually_nhds_within eventually_nhds_within\n\n",
 "eventually_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_nhds' (e : LocalHomeomorph α β) {x : α} (p : α → Prop) (hx : x ∈ e.source) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        ((nhds) (e x)) (p (e.symm y)) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n        (p x) :=\n  by\n  rw [e.eventually_nhds _ hx]\n  refine' eventually_congr ((e.eventually_left_inverse hx).mono fun y hy => _)\n  rw [hy]\n#align eventually_nhds' eventually_nhds'\n\n",
 "eventually_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_nhds (e : LocalHomeomorph α β) {x : α} (p : β → Prop) (hx : x ∈ e.source) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        ((nhds) (e x)) (p y) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n        (p (e x)) :=\n  iff.trans (by rw [e.map_nhds_eq hx]) eventually_map\n#align eventually_nhds eventually_nhds\n\n",
 "eventually_ne_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\ntheorem eventually_ne_nhds_within (e : LocalHomeomorph α β) {x} (hx : x ∈ e.source) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.ne x) (e x' ≠ e x) :=\n  eventually_nhdsWithin_iff.2 <|\n    (e.eventually_left_inverse hx).mono fun x' hx' => mt fun h => by rw [mem_singleton_iff, ← e.left_inv hx, ← h, hx']\n#align eventually_ne_nhds_within eventually_ne_nhds_within\n\n",
 "eventually_left_inverse'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_left_inverse' (e : LocalHomeomorph α β) {x} (hx : x ∈ e.target) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((nhds) (e.symm x)) (e.symm (e y) = y) :=\n  e.eventually_left_inverse (e.map_target hx)\n#align eventually_left_inverse' eventually_left_inverse'\n\n",
 "eventually_left_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_left_inverse (e : LocalHomeomorph α β) {x} (hx : x ∈ e.source) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n      (e.symm (e y) = y) :=\n  (e.open_source.eventually_mem hx).mono e.left_inv'\n#align eventually_left_inverse eventually_left_inverse\n\n",
 "eq_symm_apply":
 "theorem eq_symm_apply {x : α} {y : β} (hx : x ∈ e.source) (hy : y ∈ e.target) : x = e.symm y ↔ e x = y :=\n  e.to_local_equiv.eq_symm_apply hx hy\n#align eq_symm_apply eq_symm_apply\n\n",
 "eq_on_source_refl":
 "theorem eq_on_source_refl : e ≈ e :=\n  setoid.refl _\n#align eq_on_source_refl eq_on_source_refl\n\n",
 "eq_on_source_iff":
 "theorem eq_on_source_iff (e e' : LocalHomeomorph α β) :\n    EqOnSource e e' ↔ LocalEquiv.EqOnSource e.to_local_equiv e'.to_local_equiv :=\n  iff.rfl\n#align eq_on_source_iff eq_on_source_iff\n\n",
 "eq_on":
 "/-- Two equivalent local homeomorphisms have coinciding `to_fun` on the source -/\ntheorem eq_on_source.eq_on {e e' : LocalHomeomorph α β} (h : e ≈ e') : EqOn e e' e.source :=\n  h.2\n#align eq_on_source.eq_on eq_on_source.eq_on\n\n",
 "eq_of_local_equiv_eq":
 "theorem eq_of_local_equiv_eq {e e' : LocalHomeomorph α β} (h : e.to_local_equiv = e'.to_local_equiv) : e = e' :=\n  by\n  cases e\n  cases e'\n  cases h\n  rfl\n#align eq_of_local_equiv_eq eq_of_local_equiv_eq\n\n",
 "eq_of_eq_on_source_univ":
 "theorem eq_of_eq_on_source_univ {e e' : LocalHomeomorph α β} (h : e ≈ e') (s : e.source = univ) (t : e.target = univ) :\n    e = e' :=\n  eq_of_localEquiv_eq <| LocalEquiv.eq_of_eq_on_source_univ _ _ h s t\n#align eq_of_eq_on_source_univ eq_of_eq_on_source_univ\n\n",
 "diff":
 "protected theorem diff {s' t'} (h : e.is_image s t) (h' : e.is_image s' t') : e.is_image (s \\ s') (t \\ t') :=\n  h.inter h'.compl\n#align diff diff\n\n",
 "continuous_within_at_iff_continuous_within_at_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- Continuity within a set at a point can be read under right composition with a local\nhomeomorphism, if the point is in its target -/\ntheorem continuous_within_at_iff_continuous_within_at_comp_right {f : β → γ} {s : Set β} {x : β} (h : x ∈ e.target) :\n    ContinuousWithinAt f s x ↔ ContinuousWithinAt (f ∘ e) («expr ⁻¹' » e s) (e.symm x) := by\n  simp_rw [ContinuousWithinAt, ← @tendsto_map'_iff _ _ _ _ e, e.map_nhds_within_preimage_eq (e.map_target h), (· ∘ ·),\n    e.right_inv h]\n#align continuous_within_at_iff_continuous_within_at_comp_right continuous_within_at_iff_continuous_within_at_comp_right\n\n",
 "continuous_within_at_iff_continuous_within_at_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- Continuity within a set at a point can be read under left composition with a local\nhomeomorphism if a neighborhood of the initial point is sent to the source of the local\nhomeomorphism-/\ntheorem continuous_within_at_iff_continuous_within_at_comp_left {f : γ → α} {s : Set γ} {x : γ} (hx : f x ∈ e.source)\n    (h : «expr ⁻¹' » f e.source ∈ nhds_within s x) : ContinuousWithinAt f s x ↔ ContinuousWithinAt (e ∘ f) s x :=\n  by\n  refine' ⟨(e.continuous_at hx).comp_continuous_within_at, fun fe_cont => _⟩\n  rw [← continuousWithinAt_inter' h] at fe_cont⊢\n  have : ContinuousWithinAt (e.symm ∘ e ∘ f) (s ∩ «expr ⁻¹' » f e.source) x :=\n    haveI : ContinuousWithinAt e.symm univ (e (f x)) := (e.continuous_at_symm (e.map_source hx)).continuous_within_at\n    ContinuousWithinAt.comp this fe_cont (subset_univ _)\n  exact this.congr (fun y hy => by simp [e.left_inv hy.2]) (by simp [e.left_inv hx])\n#align continuous_within_at_iff_continuous_within_at_comp_left continuous_within_at_iff_continuous_within_at_comp_left\n\n",
 "continuous_on_symm":
 "theorem continuous_on_symm : ContinuousOn e.symm e.target :=\n  e.continuous_inv_fun\n#align continuous_on_symm continuous_on_symm\n\n",
 "continuous_on_iff_continuous_on_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the right is continuous on the corresponding set. -/\ntheorem continuous_on_iff_continuous_on_comp_right {f : β → γ} {s : Set β} (h : s ⊆ e.target) :\n    ContinuousOn f s ↔ ContinuousOn (f ∘ e) (e.source ∩ «expr ⁻¹' » e s) :=\n  by\n  simp only [← e.symm_image_eq_source_inter_preimage h, ContinuousOn, ball_image_iff]\n  refine' forall₂_congr fun x hx => _\n  rw [e.continuous_within_at_iff_continuous_within_at_comp_right (h hx), e.symm_image_eq_source_inter_preimage h,\n    inter_comm, continuousWithinAt_inter]\n  exact IsOpen.mem_nhds e.open_source (e.map_target (h hx))\n#align continuous_on_iff_continuous_on_comp_right continuous_on_iff_continuous_on_comp_right\n\n",
 "continuous_on_iff_continuous_on_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the left is continuous on the corresponding set. -/\ntheorem continuous_on_iff_continuous_on_comp_left {f : γ → α} {s : Set γ} (h : s ⊆ «expr ⁻¹' » f e.source) :\n    ContinuousOn f s ↔ ContinuousOn (e ∘ f) s :=\n  forall₂_congr fun x hx =>\n    e.continuous_within_at_iff_continuous_within_at_comp_left (h hx) (mem_of_superset self_mem_nhdsWithin h)\n#align continuous_on_iff_continuous_on_comp_left continuous_on_iff_continuous_on_comp_left\n\n",
 "continuous_iff_continuous_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- A function is continuous if and only if its composition with a local homeomorphism\non the left is continuous and its image is contained in the source. -/\ntheorem continuous_iff_continuous_comp_left {f : γ → α} (h : «expr ⁻¹' » f e.source = univ) :\n    Continuous f ↔ Continuous (e ∘ f) :=\n  by\n  simp only [continuous_iff_continuousOn_univ]\n  exact e.continuous_on_iff_continuous_on_comp_left (Eq.symm h).subset\n#align continuous_iff_continuous_comp_left continuous_iff_continuous_comp_left\n\n",
 "continuous_at_symm":
 "/-- A local homeomorphism inverse is continuous at any point of its target -/\ntheorem continuous_at_symm {x : β} (h : x ∈ e.target) : ContinuousAt e.symm x :=\n  e.symm.continuous_at h\n#align continuous_at_symm continuous_at_symm\n\n",
 "continuous_at_iff_continuous_at_comp_right":
 "/-- Continuity at a point can be read under right composition with a local homeomorphism, if the\npoint is in its target -/\ntheorem continuous_at_iff_continuous_at_comp_right {f : β → γ} {x : β} (h : x ∈ e.target) :\n    ContinuousAt f x ↔ ContinuousAt (f ∘ e) (e.symm x) := by\n  rw [← continuousWithinAt_univ, e.continuous_within_at_iff_continuous_within_at_comp_right h, preimage_univ,\n    continuousWithinAt_univ]\n#align continuous_at_iff_continuous_at_comp_right continuous_at_iff_continuous_at_comp_right\n\n",
 "continuous_at_iff_continuous_at_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Continuity at a point can be read under left composition with a local homeomorphism if a\nneighborhood of the initial point is sent to the source of the local homeomorphism-/\ntheorem continuous_at_iff_continuous_at_comp_left {f : γ → α} {x : γ} (h : «expr ⁻¹' » f e.source ∈ (nhds) x) :\n    ContinuousAt f x ↔ ContinuousAt (e ∘ f) x :=\n  by\n  have hx : f x ∈ e.source := (mem_of_mem_nhds h : _)\n  have h' : «expr ⁻¹' » f e.source ∈ nhds_within univ x := by rwa [nhdsWithin_univ]\n  rw [← continuousWithinAt_univ, ← continuousWithinAt_univ,\n    e.continuous_within_at_iff_continuous_within_at_comp_left hx h']\n#align continuous_at_iff_continuous_at_comp_left continuous_at_iff_continuous_at_comp_left\n\n",
 "continuous_at_iff":
 "theorem continuous_at_iff {f : α → β} {g : β → γ} (hf : OpenEmbedding f) {x : α} :\n    ContinuousAt (g ∘ f) x ↔ ContinuousAt g (f x) :=\n  by\n  haveI : Nonempty α := ⟨x⟩\n  convert((hf.to_local_homeomorph f).continuous_at_iff_continuous_at_comp_right _).symm\n  · apply (LocalHomeomorph.left_inv _ _).symm\n    simp\n  · simp\n#align continuous_at_iff continuous_at_iff\n\n",
 "compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\nprotected theorem compl (h : e.is_image s t) : e.is_image («expr ᶜ» s) («expr ᶜ» t) := fun x hx => not_congr (h hx)\n#align compl compl\n\n",
 "coe_trans_symm":
 "@[simp, mfld_simps]\ntheorem coe_trans_symm : ((e.trans e').symm : γ → α) = e.symm ∘ e'.symm :=\n  rfl\n#align coe_trans_symm coe_trans_symm\n\n",
 "coe_trans":
 "@[simp, mfld_simps]\ntheorem coe_trans : (e.trans e' : α → γ) = e' ∘ e :=\n  rfl\n#align coe_trans coe_trans\n\n",
 "coe_coe_symm":
 "@[simp, mfld_simps]\ntheorem coe_coe_symm : (e.to_local_equiv.symm : β → α) = e.symm :=\n  rfl\n#align coe_coe_symm coe_coe_symm\n\n",
 "coe_coe":
 "@[simp, mfld_simps]\ntheorem coe_coe : (e.to_local_equiv : α → β) = e :=\n  rfl\n#align coe_coe coe_coe\n\n",
 "closure":
 "#print closure /-\nprotected theorem closure (h : e.is_image s t) : e.is_image (closure s) (closure t) := fun x hx => by\n  simp only [mem_closure_iff_nhdsWithin_neBot, ← h.map_nhds_within_eq hx, map_ne_bot_iff]\n#align closure closure\n-/\n\n",
 "bij_on":
 "protected theorem bij_on : BijOn e e.source e.target :=\n  e.inv_on.bij_on e.maps_to e.symm_maps_to\n#align bij_on bij_on\n\n",
 "apply_mem_iff":
 "theorem apply_mem_iff (h : e.is_image s t) (hx : x ∈ e.source) : e x ∈ t ↔ x ∈ s :=\n  h hx\n#align apply_mem_iff apply_mem_iff\n\n",
 "ContinuousOn":
 "#print ContinuousOn /-\n/-\nCopyright (c) 2019 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\nprotected theorem ContinuousOn : ContinuousOn e e.source :=\n  e.continuous_to_fun\n#align continuous_on ContinuousOn\n-/\n\n",
 "ContinuousAt":
 "#print ContinuousAt /-\n/-- A local homeomorphism is continuous at any point of its source -/\nprotected theorem ContinuousAt {x : α} (h : x ∈ e.source) : ContinuousAt e x :=\n  (e.continuous_on x h).continuous_at (e.open_source.mem_nhds h)\n#align continuous_at ContinuousAt\n-/\n\n"}