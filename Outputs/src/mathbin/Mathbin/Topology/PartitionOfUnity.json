{"to_pou_fun_zero_of_zero":
 "theorem to_pou_fun_zero_of_zero {i : ι} {x : X} (h : f i x = 0) : f.to_pou_fun i x = 0 := by\n  rw [to_pou_fun, h, zero_mul]\n#align to_pou_fun_zero_of_zero to_pou_fun_zero_of_zero\n\n",
 "to_pou_fun_eq_mul_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem to_pou_fun_eq_mul_prod (i : ι) (x : X) (t : Finset ι) (ht : ∀ j, well_ordering_rel j i → f j x ≠ 0 → j ∈ t) :\n    f.to_pou_fun i x =\n      f i x *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (t.filter fun j => well_ordering_rel j i) (1 - f j x) :=\n  by\n  refine' congr_arg _ (finprod_cond_eq_prod_of_cond_iff _ fun j hj => _)\n  rw [ne.def, sub_eq_self] at hj\n  rw [Finset.mem_filter, iff.comm, and_iff_right_iff_imp]\n  exact flip (ht j) hj\n#align to_pou_fun_eq_mul_prod to_pou_fun_eq_mul_prod\n\n",
 "to_partition_of_unity_zero_of_zero":
 "theorem to_partition_of_unity_zero_of_zero {i : ι} {x : X} (h : f i x = 0) : f.to_partition_of_unity i x = 0 :=\n  f.to_pou_fun_zero_of_zero h\n#align to_partition_of_unity_zero_of_zero to_partition_of_unity_zero_of_zero\n\n",
 "to_partition_of_unity_eq_mul_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem to_partition_of_unity_eq_mul_prod (i : ι) (x : X) (t : Finset ι)\n    (ht : ∀ j, well_ordering_rel j i → f j x ≠ 0 → j ∈ t) :\n    f.to_partition_of_unity i x =\n      f i x *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (t.filter fun j => well_ordering_rel j i) (1 - f j x) :=\n  f.to_pou_fun_eq_mul_prod i x t ht\n#align to_partition_of_unity_eq_mul_prod to_partition_of_unity_eq_mul_prod\n\n",
 "to_partition_of_unity_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\ntheorem to_partition_of_unity_apply (i : ι) (x : X) :\n    f.to_partition_of_unity i x =\n      f i x * finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (1 - f j x) :=\n  rfl\n#align to_partition_of_unity_apply to_partition_of_unity_apply\n\n",
 "to_partition_of_unity":
 "theorem is_subordinate.to_partition_of_unity {f : bump_covering ι X s} {U : ι → set X} (h : f.is_subordinate U) :\n    f.to_partition_of_unity.is_subordinate U := fun i =>\n  Subset.trans (closure_mono <| f.support_to_partition_of_unity_subset i) (h i)\n#align is_subordinate.to_partition_of_unity is_subordinate.to_partition_of_unity\n\n",
 "support_to_pou_fun_subset":
 "theorem support_to_pou_fun_subset (i : ι) : support (f.to_pou_fun i) ⊆ support (f i) := fun x =>\n  mt <| f.to_pou_fun_zero_of_zero\n#align support_to_pou_fun_subset support_to_pou_fun_subset\n\n",
 "support_to_partition_of_unity_subset":
 "theorem support_to_partition_of_unity_subset (i : ι) : support (f.to_partition_of_unity i) ⊆ support (f i) :=\n  f.support_to_pou_fun_subset i\n#align support_to_partition_of_unity_subset support_to_partition_of_unity_subset\n\n",
 "sum_to_pou_fun_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finsum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\ntheorem sum_to_pou_fun_eq (x : X) :\n    finsum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum\" (f.to_pou_fun i x) =\n      1 - finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (1 - f i x) :=\n  by\n  set s := (f.point_finite x).to_finset\n  have hs : (s : set ι) = { i | f i x ≠ 0 } := finite.coe_to_finset _\n  have A : (support fun i => to_pou_fun f i x) ⊆ s := by\n    rw [hs]\n    exact fun i hi => f.support_to_pou_fun_subset i hi\n  have B : (mul_support fun i => 1 - f i x) ⊆ s :=\n    by\n    rw [hs, mul_support_one_sub]\n    exact fun i => id\n  letI : linear_order ι := linear_order_of_STO well_ordering_rel\n  rw [finsum_eq_sum_of_support_subset _ A, finprod_eq_prod_of_mul_support_subset _ B, finset.prod_one_sub_ordered,\n    sub_sub_cancel]\n  refine' finset.sum_congr rfl fun i hi => _\n  convert f.to_pou_fun_eq_mul_prod _ _ _ fun j hji hj => _\n  rwa [finite.mem_to_finset]\n#align sum_to_pou_fun_eq sum_to_pou_fun_eq\n\n",
 "sum_to_partition_of_unity_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finsum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\ntheorem sum_to_partition_of_unity_eq (x : X) :\n    finsum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum\"\n        (f.to_partition_of_unity i x) =\n      1 - finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (1 - f i x) :=\n  f.sum_to_pou_fun_eq x\n#align sum_to_partition_of_unity_eq sum_to_partition_of_unity_eq\n\n",
 "sum_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finsum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum -/\ntheorem sum_nonneg (x : X) :\n    0 ≤ finsum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum\" (f i x) :=\n  finsum_nonneg fun i => f.nonneg i x\n#align sum_nonneg sum_nonneg\n\n",
 "sum_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finsum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum -/\ntheorem sum_le_one (x : X) :\n    finsum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum\" (f i x) ≤ 1 :=\n  f.sum_le_one' x\n#align sum_le_one sum_le_one\n\n",
 "sum_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finsum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum -/\ntheorem sum_eq_one {x : X} (hx : x ∈ s) :\n    finsum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum\" (f i x) = 1 :=\n  f.sum_eq_one' x hx\n#align sum_eq_one sum_eq_one\n\n",
 "point_finite":
 "protected theorem point_finite (x : X) : { i | f i x ≠ 0 }.finite :=\n  f.locally_finite.point_finite x\n#align point_finite point_finite\n\n",
 "nonneg":
 "theorem nonneg (i : ι) (x : X) : 0 ≤ f i x :=\n  f.nonneg' i x\n#align nonneg nonneg\n\n",
 "mono":
 "theorem is_subordinate.mono {f : bump_covering ι X s} {U V : ι → set X} (hU : f.is_subordinate U)\n    (hV : ∀ i, U i ⊆ V i) : f.is_subordinate V := fun i => Subset.trans (hU i) (hV i)\n#align is_subordinate.mono is_subordinate.mono\n\n",
 "locally_finite_tsupport":
 "theorem locally_finite_tsupport : locally_finite fun i => tsupport (f i) :=\n  f.locally_finite.closure\n#align locally_finite_tsupport locally_finite_tsupport\n\n",
 "locally_finite":
 "protected theorem locally_finite : locally_finite fun i => support (f i) :=\n  f.locally_finite'\n#align locally_finite locally_finite\n\n",
 "le_one":
 "theorem le_one (i : ι) (x : X) : f i x ≤ 1 :=\n  f.le_one' i x\n#align le_one le_one\n\n",
 "ind_apply":
 "theorem ind_apply (x : X) (hx : x ∈ s) : f (f.ind x hx) x = 1 :=\n  (f.eventually_eq_one x hx).eq_of_nhds\n#align ind_apply ind_apply\n\n",
 "exists_pos":
 "/-- If `f` is a partition of unity on `s`, then for every `x ∈ s` there exists an index `i` such\nthat `0 < f i x`. -/\ntheorem exists_pos {x : X} (hx : x ∈ s) : ∃ i, 0 < f i x :=\n  by\n  have H := f.sum_eq_one hx\n  contrapose! H\n  simpa only [fun i => (H i).antisymm (f.nonneg i x), finsum_zero] using zero_ne_one\n#align exists_pos exists_pos\n\n",
 "exists_is_subordinate_of_prop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\n`s`, then there exists a `bump_covering ι X s` that is subordinate to `U`. This version assumes that\n`p : (X → ℝ) → Prop` is a predicate that satisfies Urysohn's lemma, and provides a\n`bump_covering` such that each function of the covering satisfies `p`. -/\ntheorem exists_is_subordinate_of_prop [normal_space X] [paracompact_space X] (p : (X → exprℝ) → Prop)\n    (h01 :\n      ∀ s t,\n        is_closed s →\n          is_closed t →\n            Disjoint s t → ∃ f : «exprC( , )» X (exprℝ), p f ∧ EqOn f 0 s ∧ EqOn f 1 t ∧ ∀ x, f x ∈ Icc (0 : exprℝ) 1)\n    (hs : is_closed s) (U : ι → set X) (ho : ∀ i, is_open (U i))\n    (hU : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i)) :\n    ∃ f : bump_covering ι X s, (∀ i, p (f i)) ∧ f.is_subordinate U :=\n  by\n  rcases precise_refinement_set hs _ ho hU with ⟨V, hVo, hsV, hVf, hVU⟩\n  rcases exists_is_subordinate_of_locally_finite_of_prop p h01 hs V hVo hVf hsV with ⟨f, hfp, hf⟩\n  exact ⟨f, hfp, hf.mono hVU⟩\n#align exists_is_subordinate_of_prop exists_is_subordinate_of_prop\n\n",
 "exists_is_subordinate_of_locally_finite_of_prop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- If `X` is a normal topological space and `U i`, `i : ι`, is a locally finite open covering of a\nclosed set `s`, then there exists a `bump_covering ι X s` that is subordinate to `U`. If `X` is a\nparacompact space, then the assumption `hf : locally_finite U` can be omitted, see\n`bump_covering.exists_is_subordinate`. This version assumes that `p : (X → ℝ) → Prop` is a predicate\nthat satisfies Urysohn's lemma, and provides a `bump_covering` such that each function of the\ncovering satisfies `p`. -/\ntheorem exists_is_subordinate_of_locally_finite_of_prop [normal_space X] (p : (X → exprℝ) → Prop)\n    (h01 :\n      ∀ s t,\n        is_closed s →\n          is_closed t →\n            Disjoint s t → ∃ f : «exprC( , )» X (exprℝ), p f ∧ EqOn f 0 s ∧ EqOn f 1 t ∧ ∀ x, f x ∈ Icc (0 : exprℝ) 1)\n    (hs : is_closed s) (U : ι → set X) (ho : ∀ i, is_open (U i)) (hf : locally_finite U)\n    (hU : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i)) :\n    ∃ f : bump_covering ι X s, (∀ i, p (f i)) ∧ f.is_subordinate U :=\n  by\n  rcases exists_subset_Union_closure_subset hs ho (fun x _ => hf.point_finite x) hU with ⟨V, hsV, hVo, hVU⟩\n  have hVU' : ∀ i, V i ⊆ U i := fun i => subset.trans subset_closure (hVU i)\n  rcases exists_subset_Union_closure_subset hs hVo (fun x _ => (hf.subset hVU').point_finite x) hsV with\n    ⟨W, hsW, hWo, hWV⟩\n  choose f hfp hf0 hf1 hf01 using fun i =>\n    h01 _ _ (is_closed_compl_iff.2 <| hVo i) is_closed_closure (disjoint_right.2 fun x hx => not_not.2 (hWV i hx))\n  have hsupp : ∀ i, support (f i) ⊆ V i := fun i => support_subset_iff'.2 (hf0 i)\n  refine'\n    ⟨⟨f, hf.subset fun i => subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1, fun i x => (hf01 i x).2,\n        fun x hx => _⟩,\n      hfp, fun i => subset.trans (closure_mono (hsupp i)) (hVU i)⟩\n  rcases mem_Union.1 (hsW hx) with ⟨i, hi⟩\n  exact ⟨i, ((hf1 i).mono subset_closure).eventually_eq_of_mem ((hWo i).mem_nhds hi)⟩\n#align exists_is_subordinate_of_locally_finite_of_prop exists_is_subordinate_of_locally_finite_of_prop\n\n",
 "exists_is_subordinate_of_locally_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- If `X` is a normal topological space and `U` is a locally finite open covering of a closed set\n`s`, then there exists a `partition_of_unity ι X s` that is subordinate to `U`. If `X` is a\nparacompact space, then the assumption `hf : locally_finite U` can be omitted, see\n`bump_covering.exists_is_subordinate`. -/\ntheorem exists_is_subordinate_of_locally_finite [normal_space X] (hs : is_closed s) (U : ι → set X)\n    (ho : ∀ i, is_open (U i)) (hf : locally_finite U)\n    (hU : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i)) :\n    ∃ f : partition_of_unity ι X s, f.is_subordinate U :=\n  let ⟨f, hf⟩ := bump_covering.exists_is_subordinate_of_locally_finite hs U ho hf hU\n  ⟨f.to_partition_of_unity, hf.to_partition_of_unity⟩\n#align exists_is_subordinate_of_locally_finite exists_is_subordinate_of_locally_finite\n\n",
 "exists_is_subordinate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\n`s`, then there exists a `partition_of_unity ι X s` that is subordinate to `U`. -/\ntheorem exists_is_subordinate [normal_space X] [paracompact_space X] (hs : is_closed s) (U : ι → set X)\n    (ho : ∀ i, is_open (U i))\n    (hU : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i)) :\n    ∃ f : partition_of_unity ι X s, f.is_subordinate U :=\n  let ⟨f, hf⟩ := bump_covering.exists_is_subordinate hs U ho hU\n  ⟨f.to_partition_of_unity, hf.to_partition_of_unity⟩\n#align exists_is_subordinate exists_is_subordinate\n\n",
 "exists_finset_to_pou_fun_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem exists_finset_to_pou_fun_eventually_eq (i : ι) (x : X) :\n    ∃ t : Finset ι,\n      «expr =ᶠ[ ] » (f.to_pou_fun i) ((nhds) x)\n        (f i *\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (t.filter fun j => well_ordering_rel j i) (1 - f j)) :=\n  by\n  rcases f.locally_finite x with ⟨U, hU, hf⟩\n  use hf.to_finset\n  filter_upwards [hU] with y hyU\n  simp only [pi.mul_apply, finset.prod_apply]\n  apply to_pou_fun_eq_mul_prod\n  intro j hji hj\n  exact hf.mem_to_finset.2 ⟨y, ⟨hj, hyU⟩⟩\n#align exists_finset_to_pou_fun_eventually_eq exists_finset_to_pou_fun_eventually_eq\n\n",
 "exists_finset_to_partition_of_unity_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem exists_finset_to_partition_of_unity_eventually_eq (i : ι) (x : X) :\n    ∃ t : Finset ι,\n      «expr =ᶠ[ ] » (f.to_partition_of_unity i) ((nhds) x)\n        (f i *\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (t.filter fun j => well_ordering_rel j i) (1 - f j)) :=\n  f.exists_finset_to_pou_fun_eventually_eq i x\n#align exists_finset_to_partition_of_unity_eventually_eq exists_finset_to_partition_of_unity_eventually_eq\n\n",
 "exists_finset_nhd_support_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem exists_finset_nhd_support_subset {U : ι → set X} (hso : f.is_subordinate U) (ho : ∀ i, is_open (U i)) (x : X) :\n    ∃ (is : Finset ι)(n : set X)(hn₁ : n ∈ (nhds) x)(hn₂ :\n      n ⊆ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (U i)),\n      ∀ z ∈ n, (support fun i => f i z) ⊆ is :=\n  f.locally_finite.exists_finset_nhd_support_subset hso ho x\n#align exists_finset_nhd_support_subset exists_finset_nhd_support_subset\n\n",
 "eventually_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_eq_one (x : X) (hx : x ∈ s) : «expr =ᶠ[ ] » (f (f.ind x hx)) ((nhds) x) 1 :=\n  (f.eventually_eq_one' x hx).some_spec\n#align eventually_eq_one eventually_eq_one\n\n",
 "continuous_to_pou_fun":
 "theorem continuous_to_pou_fun (i : ι) : continuous (f.to_pou_fun i) :=\n  by\n  refine' (f i).continuous.mul <| continuous_finprod_cond (fun j _ => continuous_const.sub (f j).continuous) _\n  simp only [mul_support_one_sub]\n  exact f.locally_finite\n#align continuous_to_pou_fun continuous_to_pou_fun\n\n",
 "continuous_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `f` is a partition of unity on `s : set X` and `g : X → E` is continuous at every point of\nthe topological support of some `f i`, then `λ x, f i x • g x` is continuous on the whole space. -/\ntheorem continuous_smul {g : X → E} {i : ι} (hg : ∀ x ∈ tsupport (f i), continuous_at g x) :\n    continuous fun x => «expr • » (f i x) (g x) :=\n  continuous_of_tsupport fun x hx => ((f i).continuous_at x).smul <| hg x <| tsupport_smul_subset_left _ _ hx\n#align continuous_smul continuous_smul\n\n",
 "continuous_finsum_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finsum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `f` is a partition of unity that is subordinate to a family of open sets `U i` and\n`g : ι → X → E` is a family of functions such that each `g i` is continuous on `U i`, then the sum\n`λ x, ∑ᶠ i, f i x • g i x` is a continuous function. -/\ntheorem is_subordinate.continuous_finsum_smul [has_continuous_add E] {U : ι → set X} (ho : ∀ i, is_open (U i))\n    (hf : f.is_subordinate U) {g : ι → X → E} (hg : ∀ i, continuous_on (g i) (U i)) :\n    continuous fun x =>\n      finsum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum\"\n        («expr • » (f i x) (g i x)) :=\n  f.continuous_finsum_smul fun i x hx => (hg i).continuous_at <| (ho i).mem_nhds <| hf i hx\n#align is_subordinate.continuous_finsum_smul is_subordinate.continuous_finsum_smul\n\n",
 "coe_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_single (i : ι) (s : set X) : «expr⇑ » (bump_covering.single i s) = Pi.single i 1 :=\n  rfl\n#align coe_single coe_single\n\n"}