{"uniform_continuous_inf_nndist_pt":
 "/-- The minimal distance to a set (as `ℝ≥0`) is uniformly continuous in point -/\ntheorem uniform_continuous_inf_nndist_pt (s : Set α) : UniformContinuous fun x => infNndist x s :=\n  (lipschitz_infNndist_pt s).uniform_continuous\n#align uniform_continuous_inf_nndist_pt uniform_continuous_inf_nndist_pt\n\n",
 "uniform_continuous_inf_dist_pt":
 "/-- The minimal distance to a set is uniformly continuous in point -/\ntheorem uniform_continuous_inf_dist_pt : UniformContinuous fun x => infDist x s :=\n  (lipschitz_infDist_pt s).uniform_continuous\n#align uniform_continuous_inf_dist_pt uniform_continuous_inf_dist_pt\n\n",
 "thickening_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem thickening_union (δ : exprℝ) (s t : Set α) : thickening δ (s ∪ t) = thickening δ s ∪ thickening δ t := by\n  simp_rw [thickening, inf_edist_union, inf_eq_min, min_lt_iff, set_of_or]\n#align thickening_union thickening_union\n\n",
 "thickening_thickening_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- For the equality, see `thickening_thickening`. -/\n@[simp]\ntheorem thickening_thickening_subset (ε δ : exprℝ) (s : Set α) : thickening ε (thickening δ s) ⊆ thickening (ε + δ) s :=\n  by\n  obtain hε | hε := le_total ε 0\n  · simp only [thickening_of_nonpos hε, empty_subset]\n  obtain hδ | hδ := le_total δ 0\n  · simp only [thickening_of_nonpos hδ, thickening_empty, empty_subset]\n  intro x\n  simp_rw [mem_thickening_iff_exists_edist_lt, ENNReal.ofReal_add hε hδ]\n  exact fun ⟨y, ⟨z, hz, hy⟩, hx⟩ => ⟨z, hz, (edist_triangle _ _ _).trans_lt <| ENNReal.add_lt_add hx hy⟩\n#align thickening_thickening_subset thickening_thickening_subset\n\n",
 "thickening_subset_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The (open) thickening `thickening δ E` with a fixed thickening radius `δ` is\nan increasing function of the subset `E`. -/\ntheorem thickening_subset_of_subset (δ : exprℝ) {E₁ E₂ : Set α} (h : E₁ ⊆ E₂) : thickening δ E₁ ⊆ thickening δ E₂ :=\n  fun _ hx => lt_of_le_of_lt (infEdist_anti h) hx\n#align thickening_subset_of_subset thickening_subset_of_subset\n\n",
 "thickening_subset_interior_cthickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem thickening_subset_interior_cthickening (δ : exprℝ) (E : Set α) : thickening δ E ⊆ interior (cthickening δ E) :=\n  (subset_interior_iff_isOpen.mpr isOpen_thickening).trans (interior_mono (thickening_subset_cthickening δ E))\n#align thickening_subset_interior_cthickening thickening_subset_interior_cthickening\n\n",
 "thickening_subset_cthickening_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem thickening_subset_cthickening_of_le {δ₁ δ₂ : exprℝ} (hle : δ₁ ≤ δ₂) (E : Set α) :\n    thickening δ₁ E ⊆ cthickening δ₂ E :=\n  (thickening_subset_cthickening δ₁ E).trans (cthickening_mono hle E)\n#align thickening_subset_cthickening_of_le thickening_subset_cthickening_of_le\n\n",
 "thickening_subset_cthickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The open thickening `thickening δ E` is contained in the closed thickening `cthickening δ E`\nwith the same radius. -/\ntheorem thickening_subset_cthickening (δ : exprℝ) (E : Set α) : thickening δ E ⊆ cthickening δ E :=\n  by\n  intro x hx\n  rw [thickening, mem_set_of_eq] at hx\n  exact hx.le\n#align thickening_subset_cthickening thickening_subset_cthickening\n\n",
 "thickening_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem thickening_singleton (δ : exprℝ) (x : X) : thickening δ ({x} : Set X) = ball x δ :=\n  by\n  ext\n  simp [mem_thickening_iff]\n#align thickening_singleton thickening_singleton\n\n",
 "thickening_of_nonpos":
 "theorem thickening_of_nonpos (hδ : δ ≤ 0) (s : Set α) : thickening δ s = ∅ :=\n  eq_empty_of_forall_not_mem fun x => ((ENNReal.ofReal_of_nonpos hδ).trans_le bot_le).not_lt\n#align thickening_of_nonpos thickening_of_nonpos\n\n",
 "thickening_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The (open) thickening `thickening δ E` of a fixed subset `E` is an increasing function of the\nthickening radius `δ`. -/\ntheorem thickening_mono {δ₁ δ₂ : exprℝ} (hle : δ₁ ≤ δ₂) (E : Set α) : thickening δ₁ E ⊆ thickening δ₂ E :=\n  preimage_mono (Iio_subset_Iio (ENNReal.ofReal_le_ofReal hle))\n#align thickening_mono thickening_mono\n\n",
 "thickening_mem_nhds_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\ntheorem thickening_mem_nhds_set (E : Set α) {δ : exprℝ} (hδ : 0 < δ) : thickening δ E ∈ (nhds_set) E :=\n  isOpen_thickening.mem_nhds_set.2 <| self_subset_thickening hδ E\n#align thickening_mem_nhds_set thickening_mem_nhds_set\n\n",
 "thickening_eq_preimage_inf_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- The (open) thickening equals the preimage of an open interval under `inf_edist`. -/\ntheorem thickening_eq_preimage_inf_edist (δ : exprℝ) (E : Set α) :\n    thickening δ E = «expr ⁻¹' » (fun x => infEdist x E) (Iio (ENNReal.ofReal δ)) :=\n  rfl\n#align thickening_eq_preimage_inf_edist thickening_eq_preimage_inf_edist\n\n",
 "thickening_eq_bUnion_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- The (open) `δ`-thickening `thickening δ E` of a subset `E` in a metric space equals the\nunion of balls of radius `δ` centered at points of `E`. -/\ntheorem thickening_eq_bUnion_ball {δ : exprℝ} {E : Set X} :\n    thickening δ E =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (ball x δ) :=\n  by\n  ext x\n  rw [mem_Union₂]\n  exact mem_thickening_iff\n#align thickening_eq_bUnion_ball thickening_eq_bUnion_ball\n\n",
 "thickening_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The (open) thickening of the empty set is empty. -/\n@[simp]\ntheorem thickening_empty (δ : exprℝ) : thickening δ (∅ : Set α) = ∅ := by\n  simp only [thickening, set_of_false, inf_edist_empty, not_top_lt]\n#align thickening_empty thickening_empty\n\n",
 "thickening_cthickening_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- For the equality, see `thickening_cthickening`. -/\n@[simp]\ntheorem thickening_cthickening_subset (ε : exprℝ) (hδ : 0 ≤ δ) (s : Set α) :\n    thickening ε (cthickening δ s) ⊆ thickening (ε + δ) s :=\n  by\n  obtain hε | hε := le_total ε 0\n  · simp only [thickening_of_nonpos hε, empty_subset]\n  intro x\n  simp_rw [mem_thickening_iff_exists_edist_lt, mem_cthickening_iff, ← inf_edist_lt_iff, ENNReal.ofReal_add hε hδ]\n  rintro ⟨y, hy, hxy⟩\n  exact\n    inf_edist_le_edist_add_inf_edist.trans_lt\n      (ENNReal.add_lt_add_of_lt_of_le (hy.trans_lt ENNReal.ofReal_lt_top).ne hxy hy)\n#align thickening_cthickening_subset thickening_cthickening_subset\n\n",
 "thickening_closure":
 "@[simp]\ntheorem thickening_closure : thickening δ (closure s) = thickening δ s := by simp_rw [thickening, inf_edist_closure]\n#align thickening_closure thickening_closure\n\n",
 "thickening_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem thickening_Union (δ : exprℝ) (f : ι → Set α) :\n    thickening δ\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (thickening δ (f i)) :=\n  by simp_rw [thickening, inf_edist_Union, infᵢ_lt_iff, set_of_exists]\n#align thickening_Union thickening_Union\n\n",
 "thickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem bounded.thickening {δ : exprℝ} {E : Set X} (h : Bounded E) : Bounded (thickening δ E) :=\n  by\n  refine' bounded_iff_mem_bounded.2 fun x hx => _\n  rcases h.subset_ball x with ⟨R, hR⟩\n  refine' (bounded_iff_subset_ball x).2 ⟨R + δ, _⟩\n  intro y hy\n  rcases mem_thickening_iff.1 hy with ⟨z, zE, hz⟩\n  calc\n    dist y x ≤ dist z x + dist y z := by\n      rw [add_comm]\n      exact dist_triangle _ _ _\n    _ ≤ R + δ := add_le_add (hR zE) hz.le\n    \n#align bounded.thickening bounded.thickening\n\n",
 "self_subset_thickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A set is contained in its own (open) thickening. -/\ntheorem self_subset_thickening {δ : exprℝ} (δ_pos : 0 < δ) (E : Set α) : E ⊆ thickening δ E :=\n  (@subset_closure _ _ E).trans (closure_subset_thickening δ_pos E)\n#align self_subset_thickening self_subset_thickening\n\n",
 "self_subset_cthickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A set is contained in its own closed thickening. -/\ntheorem self_subset_cthickening {δ : exprℝ} (E : Set α) : E ⊆ cthickening δ E :=\n  subset_closure.trans (closure_subset_cthickening δ E)\n#align self_subset_cthickening self_subset_cthickening\n\n",
 "not_mem_of_dist_lt_inf_dist":
 "theorem not_mem_of_dist_lt_inf_dist (h : dist x y < infDist x s) : y ∉ s := fun hy =>\n  h.not_le <| infDist_le_dist_of_mem hy\n#align not_mem_of_dist_lt_inf_dist not_mem_of_dist_lt_inf_dist\n\n",
 "not_mem_iff_inf_dist_pos":
 "#print IsClosed.not_mem_iff_infDist_pos /-\n/-- Given a closed set `s`, a point belongs to `s` iff its infimum distance to this set vanishes -/\ntheorem IsClosed.not_mem_iff_infDist_pos (h : IsClosed s) (hs : s.nonempty) : x ∉ s ↔ 0 < infDist x s :=\n  by\n  rw [← not_iff_not]\n  push_neg\n  simp [h.mem_iff_inf_dist_zero hs, le_antisymm_iff, inf_dist_nonneg]\n#align is_closed.not_mem_iff_inf_dist_pos IsClosed.not_mem_iff_infDist_pos\n-/\n\n",
 "nonempty_of_Hausdorff_edist_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If a set is at finite Hausdorff edistance of a nonempty set, it is nonempty -/\ntheorem nonempty_of_Hausdorff_edist_ne_top (hs : s.nonempty) (fin : hausdorffEdist s t ≠ «expr⊤») : t.nonempty :=\n  t.eq_empty_or_nonempty.elim (fun ht => (Fin <| ht.symm ▸ hausdorffEdist_empty hs).elim) id\n#align nonempty_of_Hausdorff_edist_ne_top nonempty_of_Hausdorff_edist_ne_top\n\n",
 "mem_thickening_iff_inf_edist_lt":
 "--section\ntheorem mem_thickening_iff_inf_edist_lt : x ∈ thickening δ s ↔ infEdist x s < ENNReal.ofReal δ :=\n  iff.rfl\n#align mem_thickening_iff_inf_edist_lt mem_thickening_iff_inf_edist_lt\n\n",
 "mem_thickening_iff_exists_edist_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mem_thickening_iff_exists_edist_lt {δ : exprℝ} (E : Set α) (x : α) :\n    x ∈ thickening δ E ↔ ∃ z ∈ E, edist x z < ENNReal.ofReal δ :=\n  infEdist_lt_iff\n#align mem_thickening_iff_exists_edist_lt mem_thickening_iff_exists_edist_lt\n\n",
 "mem_thickening_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- A point in a metric space belongs to the (open) `δ`-thickening of a subset `E` if and only if\nit is at distance less than `δ` from some point of `E`. -/\ntheorem mem_thickening_iff {E : Set X} {x : X} : x ∈ thickening δ E ↔ ∃ z ∈ E, dist x z < δ :=\n  by\n  have key_iff : ∀ z : X, edist x z < ENNReal.ofReal δ ↔ dist x z < δ :=\n    by\n    intro z\n    rw [dist_edist]\n    have d_lt_top : edist x z < ennreal.top := by simp only [edist_dist, ENNReal.ofReal_lt_top]\n    have key := @ENNReal.ofReal_lt_ofReal_iff_of_nonneg (edist x z).to_real δ ENNReal.toReal_nonneg\n    rwa [ENNReal.ofReal_toReal d_lt_top.ne] at key\n  simp_rw [mem_thickening_iff_exists_edist_lt, key_iff]\n#align mem_thickening_iff mem_thickening_iff\n\n",
 "mem_iff_inf_edist_zero_of_closed":
 "/-- Given a closed set `s`, a point belongs to `s` iff its infimum edistance to this set vanishes -/\ntheorem mem_iff_inf_edist_zero_of_closed (h : IsClosed s) : x ∈ s ↔ infEdist x s = 0 :=\n  by\n  convert← mem_closure_iff_inf_edist_zero\n  exact h.closure_eq\n#align mem_iff_inf_edist_zero_of_closed mem_iff_inf_edist_zero_of_closed\n\n",
 "mem_iff_inf_dist_zero":
 "#print IsClosed.mem_iff_infDist_zero /-\n/-- Given a closed set `s`, a point belongs to `s` iff its infimum distance to this set vanishes -/\ntheorem IsClosed.mem_iff_infDist_zero (h : IsClosed s) (hs : s.nonempty) : x ∈ s ↔ infDist x s = 0 := by\n  rw [← mem_closure_iff_inf_dist_zero hs, h.closure_eq]\n#align is_closed.mem_iff_inf_dist_zero IsClosed.mem_iff_infDist_zero\n-/\n\n",
 "mem_cthickening_of_edist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mem_cthickening_of_edist_le (x y : α) (δ : exprℝ) (E : Set α) (h : y ∈ E) (h' : edist x y ≤ ENNReal.ofReal δ) :\n    x ∈ cthickening δ E :=\n  (infEdist_le_edist_of_mem h).trans h'\n#align mem_cthickening_of_edist_le mem_cthickening_of_edist_le\n\n",
 "mem_cthickening_of_dist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mem_cthickening_of_dist_le {α : Type _} [PseudoMetricSpace α] (x y : α) (δ : exprℝ) (E : Set α) (h : y ∈ E)\n    (h' : dist x y ≤ δ) : x ∈ cthickening δ E :=\n  by\n  apply mem_cthickening_of_edist_le x y δ E h\n  rw [edist_dist]\n  exact ENNReal.ofReal_le_ofReal h'\n#align mem_cthickening_of_dist_le mem_cthickening_of_dist_le\n\n",
 "mem_cthickening_iff":
 "--section\n@[simp]\ntheorem mem_cthickening_iff : x ∈ cthickening δ s ↔ infEdist x s ≤ ENNReal.ofReal δ :=\n  iff.rfl\n#align mem_cthickening_iff mem_cthickening_iff\n\n",
 "mem_closure_iff_inf_edist_zero":
 "/-- A point belongs to the closure of `s` iff its infimum edistance to this set vanishes -/\ntheorem mem_closure_iff_inf_edist_zero : x ∈ closure s ↔ infEdist x s = 0 :=\n  ⟨fun h => by\n    rw [← inf_edist_closure]\n    exact inf_edist_zero_of_mem h, fun h => EMetric.mem_closure_iff.2 fun ε εpos => infEdist_lt_iff.mp <| by rwa [h]⟩\n#align mem_closure_iff_inf_edist_zero mem_closure_iff_inf_edist_zero\n\n",
 "mem_closure_iff_inf_dist_zero":
 "/-- A point belongs to the closure of `s` iff its infimum distance to this set vanishes -/\ntheorem mem_closure_iff_inf_dist_zero (h : s.nonempty) : x ∈ closure s ↔ infDist x s = 0 := by\n  simp [mem_closure_iff_inf_edist_zero, inf_dist, ENNReal.toReal_eq_zero_iff, inf_edist_ne_top h]\n#align mem_closure_iff_inf_dist_zero mem_closure_iff_inf_dist_zero\n\n",
 "lipschitz_inf_nndist_pt":
 "/-- The minimal distance to a set (as `ℝ≥0`) is Lipschitz in point with constant 1 -/\ntheorem lipschitz_inf_nndist_pt (s : Set α) : LipschitzWith 1 fun x => infNndist x s :=\n  LipschitzWith.of_le_add fun x y => infDist_le_infDist_add_dist\n#align lipschitz_inf_nndist_pt lipschitz_inf_nndist_pt\n\n",
 "lipschitz_inf_dist_pt":
 "/-- The minimal distance to a set is Lipschitz in point with constant 1 -/\ntheorem lipschitz_inf_dist_pt : LipschitzWith 1 fun x => infDist x s :=\n  LipschitzWith.of_le_add fun x y => infDist_le_infDist_add_dist\n#align lipschitz_inf_dist_pt lipschitz_inf_dist_pt\n\n",
 "le_inf_edist":
 "theorem le_inf_edist {d} : d ≤ infEdist x s ↔ ∀ y ∈ s, d ≤ edist x y := by simp only [inf_edist, le_infᵢ_iff]\n#align le_inf_edist le_inf_edist\n\n",
 "is_open_thickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The (open) thickening is an open set. -/\ntheorem is_open_thickening {δ : exprℝ} {E : Set α} : IsOpen (thickening δ E) :=\n  continuous.is_open_preimage continuous_infEdist _ isOpen_Iio\n#align is_open_thickening is_open_thickening\n\n",
 "is_closed_cthickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The closed thickening is a closed set. -/\ntheorem is_closed_cthickening {δ : exprℝ} {E : Set α} : IsClosed (cthickening δ E) :=\n  IsClosed.preimage continuous_infEdist isClosed_Iic\n#align is_closed_cthickening is_closed_cthickening\n\n",
 "inf_edist_zero_of_mem":
 "/-- If a point `x` belongs to `s`, then its edist to `s` vanishes -/\ntheorem inf_edist_zero_of_mem (h : x ∈ s) : infEdist x s = 0 :=\n  nonpos_iff_eq_zero.1 <| @edist_self _ _ x ▸ infEdist_le_edist_of_mem h\n#align inf_edist_zero_of_mem inf_edist_zero_of_mem\n\n",
 "inf_edist_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- The edist to a union is the minimum of the edists -/\n@[simp]\ntheorem inf_edist_union : infEdist x (s ∪ t) = «expr ⊓ » (infEdist x s) (infEdist x t) :=\n  infᵢ_union\n#align inf_edist_union inf_edist_union\n\n",
 "inf_edist_singleton":
 "/-- The edist to a singleton is the edistance to the single point of this singleton -/\n@[simp]\ntheorem inf_edist_singleton : infEdist x {y} = edist x y :=\n  infᵢ_singleton\n#align inf_edist_singleton inf_edist_singleton\n\n",
 "inf_edist_pos_iff_not_mem_closure":
 "/-- The infimum edistance of a point to a set is positive if and only if the point is not in the\nclosure of the set. -/\ntheorem inf_edist_pos_iff_not_mem_closure {x : α} {E : Set α} : 0 < infEdist x E ↔ x ∉ closure E := by\n  rw [mem_closure_iff_inf_edist_zero, pos_iff_ne_zero]\n#align inf_edist_pos_iff_not_mem_closure inf_edist_pos_iff_not_mem_closure\n\n",
 "inf_edist_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- In a metric space, the minimal edistance to a nonempty set is finite -/\ntheorem inf_edist_ne_top (h : s.nonempty) : infEdist x s ≠ «expr⊤» :=\n  by\n  rcases h with ⟨y, hy⟩\n  apply lt_top_iff_ne_top.1\n  calc\n    inf_edist x s ≤ edist x y := inf_edist_le_edist_of_mem hy\n    _ < «expr⊤» := lt_top_iff_ne_top.2 (edist_ne_top _ _)\n    \n#align inf_edist_ne_top inf_edist_ne_top\n\n",
 "inf_edist_lt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- The edist to a set is `< r` iff there exists a point in the set at edistance `< r` -/\ntheorem inf_edist_lt_iff {r : ennreal} : infEdist x s < r ↔ ∃ y ∈ s, edist x y < r := by\n  simp_rw [inf_edist, infᵢ_lt_iff]\n#align inf_edist_lt_iff inf_edist_lt_iff\n\n",
 "inf_edist_le_inf_edist_thickening_add":
 "/-- For the equality, see `inf_edist_thickening`. -/\ntheorem inf_edist_le_inf_edist_thickening_add : infEdist x s ≤ infEdist x (thickening δ s) + ENNReal.ofReal δ :=\n  infEdist_le_infEdist_cthickening_add.trans <| add_le_add_right (infEdist_anti <| thickening_subset_cthickening _ _) _\n#align inf_edist_le_inf_edist_thickening_add inf_edist_le_inf_edist_thickening_add\n\n",
 "inf_edist_le_inf_edist_cthickening_add":
 "/-- For the equality, see `inf_edist_cthickening`. -/\ntheorem inf_edist_le_inf_edist_cthickening_add : infEdist x s ≤ infEdist x (cthickening δ s) + ENNReal.ofReal δ :=\n  by\n  refine' le_of_forall_lt' fun r h => _\n  simp_rw [← lt_tsub_iff_right, inf_edist_lt_iff, mem_cthickening_iff] at h\n  obtain ⟨y, hy, hxy⟩ := h\n  exact\n    inf_edist_le_edist_add_inf_edist.trans_lt\n      ((ENNReal.add_lt_add_of_lt_of_le (hy.trans_lt ENNReal.ofReal_lt_top).ne hxy hy).trans_le\n        (tsub_add_cancel_of_le <| le_self_add.trans (lt_tsub_iff_left.1 hxy).le).le)\n#align inf_edist_le_inf_edist_cthickening_add inf_edist_le_inf_edist_cthickening_add\n\n",
 "inf_edist_le_inf_edist_add_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- The edist of `x` to `s` is bounded by the sum of the edist of `y` to `s` and\nthe edist from `x` to `y` -/\ntheorem inf_edist_le_inf_edist_add_edist : infEdist x s ≤ infEdist y s + edist x y :=\n  calc\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (edist x z) ≤\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (edist y z + edist x y) :=\n      infᵢ₂_mono fun z hz => (edist_triangle _ _ _).trans_eq (add_comm _ _)\n    _ =\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (edist y z) +\n          edist x y :=\n      by simp only [ENNReal.infᵢ_add]\n    \n#align inf_edist_le_inf_edist_add_edist inf_edist_le_inf_edist_add_edist\n\n",
 "inf_edist_le_inf_edist_add_Hausdorff_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- The distance from `x` to `s` or `t` is controlled in terms of the Hausdorff distance\nbetween `s` and `t` -/\ntheorem inf_edist_le_inf_edist_add_Hausdorff_edist : infEdist x t ≤ infEdist x s + hausdorffEdist s t :=\n  ENNReal.le_of_forall_pos_le_add fun ε εpos h =>\n    by\n    have ε0 : (ε / 2 : ennreal) ≠ 0 := by simpa [pos_iff_ne_zero] using εpos\n    have : inf_edist x s < inf_edist x s + ε / 2 := ENNReal.lt_add_right (ENNReal.add_lt_top.1 h).1.ne ε0\n    rcases inf_edist_lt_iff.mp this with ⟨y, ys, dxy⟩\n    -- y : α,  ys : y ∈ s,  dxy : edist x y < inf_edist x s + ↑ε / 2\n    have : Hausdorff_edist s t < Hausdorff_edist s t + ε / 2 := ENNReal.lt_add_right (ENNReal.add_lt_top.1 h).2.ne ε0\n    rcases exists_edist_lt_of_Hausdorff_edist_lt ys this with ⟨z, zt, dyz⟩\n    -- z : α,  zt : z ∈ t,  dyz : edist y z < Hausdorff_edist s t + ↑ε / 2\n    calc\n      inf_edist x t ≤ edist x z := inf_edist_le_edist_of_mem zt\n      _ ≤ edist x y + edist y z := (edist_triangle _ _ _)\n      _ ≤ inf_edist x s + ε / 2 + (Hausdorff_edist s t + ε / 2) := (add_le_add dxy.le dyz.le)\n      _ = inf_edist x s + Hausdorff_edist s t + ε := by simp [ENNReal.add_halves, add_comm, add_left_comm]\n      \n#align inf_edist_le_inf_edist_add_Hausdorff_edist inf_edist_le_inf_edist_add_Hausdorff_edist\n\n",
 "inf_edist_le_edist_of_mem":
 "/-- The edist to a set is bounded above by the edist to any of its points -/\ntheorem inf_edist_le_edist_of_mem (h : y ∈ s) : infEdist x s ≤ edist x y :=\n  infᵢ₂_le _ h\n#align inf_edist_le_edist_of_mem inf_edist_le_edist_of_mem\n\n",
 "inf_edist_le_edist_add_inf_edist":
 "theorem inf_edist_le_edist_add_inf_edist : infEdist x s ≤ edist x y + infEdist y s :=\n  by\n  rw [add_comm]\n  exact inf_edist_le_inf_edist_add_edist\n#align inf_edist_le_edist_add_inf_edist inf_edist_le_edist_add_inf_edist\n\n",
 "inf_edist_le_Hausdorff_edist_of_mem":
 "/-- The distance to a set is controlled by the Hausdorff distance -/\ntheorem inf_edist_le_Hausdorff_edist_of_mem (h : x ∈ s) : infEdist x t ≤ hausdorffEdist s t :=\n  by\n  rw [Hausdorff_edist_def]\n  refine' le_trans _ le_sup_left\n  exact le_supᵢ₂ x h\n#align inf_edist_le_Hausdorff_edist_of_mem inf_edist_le_Hausdorff_edist_of_mem\n\n",
 "inf_edist_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The infimum edistance is invariant under isometries -/\ntheorem inf_edist_image (hΦ : Isometry Φ) : infEdist (Φ x) («expr '' » Φ t) = infEdist x t := by\n  simp only [inf_edist, infᵢ_image, hΦ.edist_eq]\n#align inf_edist_image inf_edist_image\n\n",
 "inf_edist_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-\nCopyright (c) 2019 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n@[simp]\ntheorem inf_edist_empty : infEdist x ∅ = ennreal.top :=\n  infᵢ_emptyset\n#align inf_edist_empty inf_edist_empty\n\n",
 "inf_edist_closure_pos_iff_not_mem_closure":
 "theorem inf_edist_closure_pos_iff_not_mem_closure {x : α} {E : Set α} : 0 < infEdist x (closure E) ↔ x ∉ closure E := by\n  rw [inf_edist_closure, inf_edist_pos_iff_not_mem_closure]\n#align inf_edist_closure_pos_iff_not_mem_closure inf_edist_closure_pos_iff_not_mem_closure\n\n",
 "inf_edist_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- The edist to a set and to its closure coincide -/\ntheorem inf_edist_closure : infEdist x (closure s) = infEdist x s :=\n  by\n  refine' le_antisymm (inf_edist_anti subset_closure) _\n  refine' ENNReal.le_of_forall_pos_le_add fun ε εpos h => _\n  have ε0 : 0 < (ε / 2 : ennreal) := by simpa [pos_iff_ne_zero] using εpos\n  have : inf_edist x (closure s) < inf_edist x (closure s) + ε / 2 := ENNReal.lt_add_right h.ne ε0.ne'\n  rcases inf_edist_lt_iff.mp this with ⟨y, ycs, hy⟩\n  -- y : α,  ycs : y ∈ closure s,  hy : edist x y < inf_edist x (closure s) + ↑ε / 2\n  rcases EMetric.mem_closure_iff.1 ycs (ε / 2) ε0 with ⟨z, zs, dyz⟩\n  -- z : α,  zs : z ∈ s,  dyz : edist y z < ↑ε / 2\n  calc\n    inf_edist x s ≤ edist x z := inf_edist_le_edist_of_mem zs\n    _ ≤ edist x y + edist y z := (edist_triangle _ _ _)\n    _ ≤ inf_edist x (closure s) + ε / 2 + ε / 2 := (add_le_add (le_of_lt hy) (le_of_lt dyz))\n    _ = inf_edist x (closure s) + ↑ε := by rw [add_assoc, ENNReal.add_halves]\n    \n#align inf_edist_closure inf_edist_closure\n\n",
 "inf_edist_anti":
 "/-- The edist is antitone with respect to inclusion. -/\ntheorem inf_edist_anti (h : s ⊆ t) : infEdist x t ≤ infEdist x s :=\n  infᵢ_le_infᵢ_of_subset h\n#align inf_edist_anti inf_edist_anti\n\n",
 "inf_edist_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem inf_edist_Union (f : ι → Set α) (x : α) :\n    infEdist x («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (infEdist x (f i)) :=\n  infᵢ_unionᵢ f _\n#align inf_edist_Union inf_edist_Union\n\n",
 "inf_dist_zero_of_mem_closure":
 "/-- If a point belongs to the closure of `s`, then its infimum distance to `s` equals zero.\nThe converse is true provided that `s` is nonempty, see `mem_closure_iff_inf_dist_zero`. -/\ntheorem inf_dist_zero_of_mem_closure (hx : x ∈ closure s) : infDist x s = 0 :=\n  by\n  rw [← inf_dist_eq_closure]\n  exact inf_dist_zero_of_mem hx\n#align inf_dist_zero_of_mem_closure inf_dist_zero_of_mem_closure\n\n",
 "inf_dist_zero_of_mem":
 "/-- The minimal distance of a point to a set containing it vanishes -/\ntheorem inf_dist_zero_of_mem (h : x ∈ s) : infDist x s = 0 := by simp [inf_edist_zero_of_mem h, inf_dist]\n#align inf_dist_zero_of_mem inf_dist_zero_of_mem\n\n",
 "inf_dist_singleton":
 "/-- The minimal distance to a singleton is the distance to the unique point in this singleton -/\n@[simp]\ntheorem inf_dist_singleton : infDist x {y} = dist x y := by simp [inf_dist, inf_edist, dist_edist]\n#align inf_dist_singleton inf_dist_singleton\n\n",
 "inf_dist_nonneg":
 "-- section\n--namespace\n/-- the minimal distance is always nonnegative -/\ntheorem inf_dist_nonneg : 0 ≤ infDist x s := by simp [inf_dist]\n#align inf_dist_nonneg inf_dist_nonneg\n\n",
 "inf_dist_lt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The minimal distance to a set is `< r` iff there exists a point in this set at distance `< r` -/\ntheorem inf_dist_lt_iff {r : exprℝ} (hs : s.nonempty) : infDist x s < r ↔ ∃ y ∈ s, dist x y < r := by\n  simp_rw [inf_dist, ← ENNReal.lt_ofReal_iff_toReal_lt (inf_edist_ne_top hs), inf_edist_lt_iff,\n    ENNReal.lt_ofReal_iff_toReal_lt (edist_ne_top _ _), ← dist_edist]\n#align inf_dist_lt_iff inf_dist_lt_iff\n\n",
 "inf_dist_le_inf_dist_of_subset":
 "/-- The minimal distance is monotonous with respect to inclusion -/\ntheorem inf_dist_le_inf_dist_of_subset (h : s ⊆ t) (hs : s.nonempty) : infDist x t ≤ infDist x s :=\n  by\n  have ht : t.nonempty := hs.mono h\n  rw [inf_dist, inf_dist, ENNReal.toReal_le_toReal (inf_edist_ne_top ht) (inf_edist_ne_top hs)]\n  exact inf_edist_anti h\n#align inf_dist_le_inf_dist_of_subset inf_dist_le_inf_dist_of_subset\n\n",
 "inf_dist_le_inf_dist_add_dist":
 "/-- The minimal distance from `x` to `s` is bounded by the distance from `y` to `s`, modulo\nthe distance between `x` and `y` -/\ntheorem inf_dist_le_inf_dist_add_dist : infDist x s ≤ infDist y s + dist x y :=\n  by\n  cases' s.eq_empty_or_nonempty with hs hs\n  · simp [hs, dist_nonneg]\n  · rw [inf_dist, inf_dist, dist_edist, ← ENNReal.toReal_add (inf_edist_ne_top hs) (edist_ne_top _ _),\n      ENNReal.toReal_le_toReal (inf_edist_ne_top hs)]\n    · exact inf_edist_le_inf_edist_add_edist\n    · simp [ENNReal.add_eq_top, inf_edist_ne_top hs, edist_ne_top]\n#align inf_dist_le_inf_dist_add_dist inf_dist_le_inf_dist_add_dist\n\n",
 "inf_dist_le_inf_dist_add_Hausdorff_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The infimum distance to `s` and `t` are the same, up to the Hausdorff distance\nbetween `s` and `t` -/\ntheorem inf_dist_le_inf_dist_add_Hausdorff_dist (fin : hausdorffEdist s t ≠ «expr⊤») :\n    infDist x t ≤ infDist x s + hausdorffDist s t :=\n  by\n  rcases empty_or_nonempty_of_Hausdorff_edist_ne_top Fin with (⟨hs, ht⟩ | ⟨hs, ht⟩)\n  · simp only [hs, ht, Hausdorff_dist_empty, inf_dist_empty, zero_add]\n  rw [inf_dist, inf_dist, Hausdorff_dist, ← ENNReal.toReal_add (inf_edist_ne_top hs) Fin,\n    ENNReal.toReal_le_toReal (inf_edist_ne_top ht)]\n  · exact inf_edist_le_inf_edist_add_Hausdorff_edist\n  · exact ENNReal.add_ne_top.2 ⟨inf_edist_ne_top hs, Fin⟩\n#align inf_dist_le_inf_dist_add_Hausdorff_dist inf_dist_le_inf_dist_add_Hausdorff_dist\n\n",
 "inf_dist_le_dist_of_mem":
 "/-- The minimal distance to a set is bounded by the distance to any point in this set -/\ntheorem inf_dist_le_dist_of_mem (h : y ∈ s) : infDist x s ≤ dist x y :=\n  by\n  rw [dist_edist, inf_dist, ENNReal.toReal_le_toReal (inf_edist_ne_top ⟨_, h⟩) (edist_ne_top _ _)]\n  exact inf_edist_le_edist_of_mem h\n#align inf_dist_le_dist_of_mem inf_dist_le_dist_of_mem\n\n",
 "inf_dist_le_Hausdorff_dist_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The distance to a set is controlled by the Hausdorff distance -/\ntheorem inf_dist_le_Hausdorff_dist_of_mem (hx : x ∈ s) (fin : hausdorffEdist s t ≠ «expr⊤») :\n    infDist x t ≤ hausdorffDist s t :=\n  by\n  have ht : t.nonempty := nonempty_of_Hausdorff_edist_ne_top ⟨x, hx⟩ Fin\n  rw [Hausdorff_dist, inf_dist, ENNReal.toReal_le_toReal (inf_edist_ne_top ht) Fin]\n  exact inf_edist_le_Hausdorff_edist_of_mem hx\n#align inf_dist_le_Hausdorff_dist_of_mem inf_dist_le_Hausdorff_dist_of_mem\n\n",
 "inf_dist_inter_closed_ball_of_mem":
 "theorem inf_dist_inter_closed_ball_of_mem (h : y ∈ s) : infDist x (s ∩ closedBall x (dist y x)) = infDist x s :=\n  by\n  replace h : y ∈ s ∩ closed_ball x (dist y x) := ⟨h, mem_closed_ball.2 le_rfl⟩\n  refine' le_antisymm _ (inf_dist_le_inf_dist_of_subset (inter_subset_left _ _) ⟨y, h⟩)\n  refine' not_lt.1 fun hlt => _\n  rcases(inf_dist_lt_iff ⟨y, h.1⟩).mp hlt with ⟨z, hzs, hz⟩\n  cases' le_or_lt (dist z x) (dist y x) with hle hlt\n  · exact hz.not_le (inf_dist_le_dist_of_mem ⟨hzs, hle⟩)\n  · rw [dist_comm z, dist_comm y] at hlt\n    exact (hlt.trans hz).not_le (inf_dist_le_dist_of_mem h)\n#align inf_dist_inter_closed_ball_of_mem inf_dist_inter_closed_ball_of_mem\n\n",
 "inf_dist_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The infimum distance is invariant under isometries -/\ntheorem inf_dist_image (hΦ : Isometry Φ) : infDist (Φ x) («expr '' » Φ t) = infDist x t := by\n  simp [inf_dist, inf_edist_image hΦ]\n#align inf_dist_image inf_dist_image\n\n",
 "inf_dist_eq_closure":
 "/-- The minimal distance to a set and its closure coincide -/\ntheorem inf_dist_eq_closure : infDist x (closure s) = infDist x s := by simp [inf_dist, inf_edist_closure]\n#align inf_dist_eq_closure inf_dist_eq_closure\n\n",
 "inf_dist_empty":
 "/-- the minimal distance to the empty set is 0 (if you want to have the more reasonable\nvalue ∞ instead, use `inf_edist`, which takes values in ℝ≥0∞) -/\n@[simp]\ntheorem inf_dist_empty : infDist x ∅ = 0 := by simp [inf_dist]\n#align inf_dist_empty inf_dist_empty\n\n",
 "has_basis_nhds_set_thickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem has_basis_nhds_set_thickening {K : Set α} (hK : IsCompact K) :\n    ((nhds_set) K).has_basis (fun δ : exprℝ => 0 < δ) fun δ => thickening δ K :=\n  (hasBasis_nhdsSet K).to_has_basis' (fun U hU => hK.exists_thickening_subset_open hU.1 hU.2) fun _ =>\n    thickening_mem_nhdsSet K\n#align has_basis_nhds_set_thickening has_basis_nhds_set_thickening\n\n",
 "has_basis_nhds_set_cthickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem has_basis_nhds_set_cthickening {K : Set α} (hK : IsCompact K) :\n    ((nhds_set) K).has_basis (fun δ : exprℝ => 0 < δ) fun δ => cthickening δ K :=\n  (hasBasis_nhdsSet K).to_has_basis' (fun U hU => hK.exists_cthickening_subset_open hU.1 hU.2) fun _ =>\n    cthickening_mem_nhdsSet K\n#align has_basis_nhds_set_cthickening has_basis_nhds_set_cthickening\n\n",
 "frontier_thickening_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The frontier of the (open) thickening of a set is contained in an `inf_edist` level set. -/\ntheorem frontier_thickening_subset (E : Set α) {δ : exprℝ} :\n    frontier (thickening δ E) ⊆ { x : α | infEdist x E = ENNReal.ofReal δ } :=\n  frontier_lt_subset_eq continuous_infEdist continuous_const\n#align frontier_thickening_subset frontier_thickening_subset\n\n",
 "frontier_thickening_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem frontier_thickening_disjoint (A : Set α) :\n    Pairwise («expr on » Disjoint fun r : exprℝ => frontier (thickening r A)) :=\n  by\n  refine' (pairwise_disjoint_on _).2 fun r₁ r₂ hr => _\n  cases' le_total r₁ 0 with h₁ h₁\n  · simp [thickening_of_nonpos h₁]\n  refine'\n    ((disjoint_singleton.2 fun h => hr.ne _).preimage _).mono (frontier_thickening_subset _)\n      (frontier_thickening_subset _)\n  apply_fun ENNReal.toReal  at h\n  rwa [ENNReal.toReal_ofReal h₁, ENNReal.toReal_ofReal (h₁.trans hr.le)] at h\n#align frontier_thickening_disjoint frontier_thickening_disjoint\n\n",
 "frontier_cthickening_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The frontier of the closed thickening of a set is contained in an `inf_edist` level set. -/\ntheorem frontier_cthickening_subset (E : Set α) {δ : exprℝ} :\n    frontier (cthickening δ E) ⊆ { x : α | infEdist x E = ENNReal.ofReal δ } :=\n  frontier_le_subset_eq continuous_infEdist continuous_const\n#align frontier_cthickening_subset frontier_cthickening_subset\n\n",
 "frontier_cthickening_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem frontier_cthickening_disjoint (A : Set α) :\n    Pairwise («expr on » Disjoint fun r : nnreal => frontier (cthickening r A)) := fun r₁ r₂ hr =>\n  ((disjoint_singleton.2 <| by simpa).preimage _).mono (frontier_cthickening_subset _) (frontier_cthickening_subset _)\n#align frontier_cthickening_disjoint frontier_cthickening_disjoint\n\n",
 "exists_thickenings":
 "#print Disjoint.exists_thickenings /-\ntheorem Disjoint.exists_thickenings (hst : Disjoint s t) (hs : IsCompact s) (ht : IsClosed t) :\n    ∃ δ, 0 < δ ∧ Disjoint (thickening δ s) (thickening δ t) :=\n  by\n  obtain ⟨r, hr, h⟩ := exists_pos_forall_lt_edist hs ht hst\n  refine' ⟨r / 2, half_pos (NNReal.coe_pos.2 hr), _⟩\n  rw [disjoint_iff_inf_le]\n  rintro z ⟨hzs, hzt⟩\n  rw [mem_thickening_iff_exists_edist_lt] at hzs hzt\n  rw [← NNReal.coe_two, ← NNReal.coe_div, ENNReal.ofReal_coe_nnreal] at hzs hzt\n  obtain ⟨x, hx, hzx⟩ := hzs\n  obtain ⟨y, hy, hzy⟩ := hzt\n  refine' (h x hx y hy).not_le _\n  calc\n    edist x y ≤ edist z x + edist z y := edist_triangle_left _ _ _\n    _ ≤ ↑(r / 2) + ↑(r / 2) := (add_le_add hzx.le hzy.le)\n    _ = r := by rw [← ENNReal.coe_add, add_halves]\n    \n#align disjoint.exists_thickenings Disjoint.exists_thickenings\n-/\n\n",
 "exists_thickening_subset_open":
 "#print IsCompact.exists_thickening_subset_open /-\ntheorem IsCompact.exists_thickening_subset_open (hs : IsCompact s) (ht : IsOpen t) (hst : s ⊆ t) :\n    ∃ δ, 0 < δ ∧ thickening δ s ⊆ t :=\n  let ⟨δ, h₀, hδ⟩ := hs.exists_cthickening_subset_open ht hst\n  ⟨δ, h₀, (thickening_subset_cthickening _ _).trans hδ⟩\n#align is_compact.exists_thickening_subset_open IsCompact.exists_thickening_subset_open\n-/\n\n",
 "exists_real_pos_lt_inf_edist_of_not_mem_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem exists_real_pos_lt_inf_edist_of_not_mem_closure {x : α} {E : Set α} (h : x ∉ closure E) :\n    ∃ ε : exprℝ, 0 < ε ∧ ENNReal.ofReal ε < infEdist x E :=\n  by\n  rw [← inf_edist_pos_iff_not_mem_closure, ENNReal.lt_iff_exists_real_btwn] at h\n  rcases h with ⟨ε, ⟨_, ⟨ε_pos, ε_lt⟩⟩⟩\n  exact ⟨ε, ⟨ennreal.of_real_pos.mp ε_pos, ε_lt⟩⟩\n#align exists_real_pos_lt_inf_edist_of_not_mem_closure exists_real_pos_lt_inf_edist_of_not_mem_closure\n\n",
 "exists_pos_forall_lt_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem exists_pos_forall_lt_edist (hs : IsCompact s) (ht : IsClosed t) (hst : Disjoint s t) :\n    ∃ r : nnreal, 0 < r ∧ ∀ x ∈ s, ∀ y ∈ t, (r : ennreal) < edist x y :=\n  by\n  rcases s.eq_empty_or_nonempty with (rfl | hne)\n  · use 1\n    simp\n  obtain ⟨x, hx, h⟩ : ∃ x ∈ s, ∀ y ∈ s, inf_edist x t ≤ inf_edist y t :=\n    hs.exists_forall_le hne continuous_inf_edist.continuous_on\n  have : 0 < inf_edist x t := pos_iff_ne_zero.2 fun H => hst.le_bot ⟨hx, (mem_iff_inf_edist_zero_of_closed ht).mpr H⟩\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 this with ⟨r, h₀, hr⟩\n  exact ⟨r, ennreal.coe_pos.mp h₀, fun y hy z hz => hr.trans_le <| le_inf_edist.1 (h y hy) z hz⟩\n#align exists_pos_forall_lt_edist exists_pos_forall_lt_edist\n\n",
 "exists_mem_closure_inf_dist_eq_dist":
 "theorem exists_mem_closure_inf_dist_eq_dist [ProperSpace α] (hne : s.nonempty) (x : α) :\n    ∃ y ∈ closure s, infDist x s = dist x y := by\n  simpa only [inf_dist_eq_closure] using is_closed_closure.exists_inf_dist_eq_dist hne.closure x\n#align exists_mem_closure_inf_dist_eq_dist exists_mem_closure_inf_dist_eq_dist\n\n",
 "exists_inf_edist_eq_edist":
 "#print IsCompact.exists_infEdist_eq_edist /-\ntheorem IsCompact.exists_infEdist_eq_edist (hs : IsCompact s) (hne : s.nonempty) (x : α) :\n    ∃ y ∈ s, infEdist x s = edist x y :=\n  by\n  have A : Continuous fun y => edist x y := continuous_const.edist continuous_id\n  obtain ⟨y, ys, hy⟩ : ∃ y ∈ s, ∀ z, z ∈ s → edist x y ≤ edist x z := hs.exists_forall_le hne A.continuous_on\n  exact ⟨y, ys, le_antisymm (inf_edist_le_edist_of_mem ys) (by rwa [le_inf_edist])⟩\n#align is_compact.exists_inf_edist_eq_edist IsCompact.exists_infEdist_eq_edist\n-/\n\n",
 "exists_inf_dist_eq_dist":
 "#print IsClosed.exists_infDist_eq_dist /-\ntheorem IsClosed.exists_infDist_eq_dist [ProperSpace α] (h : IsClosed s) (hne : s.nonempty) (x : α) :\n    ∃ y ∈ s, infDist x s = dist x y := by\n  rcases hne with ⟨z, hz⟩\n  rw [← inf_dist_inter_closed_ball_of_mem hz]\n  set t := s ∩ closed_ball x (dist z x)\n  have htc : IsCompact t := (is_compact_closed_ball x (dist z x)).inter_left h\n  have htne : t.nonempty := ⟨z, hz, mem_closed_ball.2 le_rfl⟩\n  obtain ⟨y, ⟨hys, hyx⟩, hyd⟩ : ∃ y ∈ t, inf_dist x t = dist x y := htc.exists_inf_dist_eq_dist htne x\n  exact ⟨y, hys, hyd⟩\n#align is_closed.exists_inf_dist_eq_dist IsClosed.exists_infDist_eq_dist\n-/\n\n",
 "exists_edist_lt_of_Hausdorff_edist_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If the Hausdorff distance is `<r`, then any point in one of the sets has\na corresponding point at distance `<r` in the other set -/\ntheorem exists_edist_lt_of_Hausdorff_edist_lt {r : ennreal} (h : x ∈ s) (H : hausdorffEdist s t < r) :\n    ∃ y ∈ t, edist x y < r :=\n  infEdist_lt_iff.mp <|\n    calc\n      infEdist x t ≤ hausdorffEdist s t := infEdist_le_hausdorffEdist_of_mem h\n      _ < r := H\n      \n#align exists_edist_lt_of_Hausdorff_edist_lt exists_edist_lt_of_Hausdorff_edist_lt\n\n",
 "exists_dist_lt_of_Hausdorff_dist_lt'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If the Hausdorff distance is `<r`, then any point in one of the sets is at distance\n`<r` of a point in the other set -/\ntheorem exists_dist_lt_of_Hausdorff_dist_lt' {r : exprℝ} (h : y ∈ t) (H : hausdorffDist s t < r)\n    (fin : hausdorffEdist s t ≠ «expr⊤») : ∃ x ∈ s, dist x y < r :=\n  by\n  rw [Hausdorff_dist_comm] at H\n  rw [Hausdorff_edist_comm] at fin\n  simpa [dist_comm] using exists_dist_lt_of_Hausdorff_dist_lt h H Fin\n#align exists_dist_lt_of_Hausdorff_dist_lt' exists_dist_lt_of_Hausdorff_dist_lt'\n\n",
 "exists_dist_lt_of_Hausdorff_dist_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If the Hausdorff distance is `<r`, then any point in one of the sets is at distance\n`<r` of a point in the other set -/\ntheorem exists_dist_lt_of_Hausdorff_dist_lt {r : exprℝ} (h : x ∈ s) (H : hausdorffDist s t < r)\n    (fin : hausdorffEdist s t ≠ «expr⊤») : ∃ y ∈ t, dist x y < r :=\n  by\n  have r0 : 0 < r := lt_of_le_of_lt Hausdorff_dist_nonneg H\n  have : Hausdorff_edist s t < ENNReal.ofReal r := by\n    rwa [Hausdorff_dist, ← ENNReal.toReal_ofReal (le_of_lt r0), ENNReal.toReal_lt_toReal Fin ENNReal.ofReal_ne_top] at H\n  rcases exists_edist_lt_of_Hausdorff_edist_lt h this with ⟨y, hy, yr⟩\n  rw [edist_dist, ENNReal.ofReal_lt_ofReal_iff r0] at yr\n  exact ⟨y, hy, yr⟩\n#align exists_dist_lt_of_Hausdorff_dist_lt exists_dist_lt_of_Hausdorff_dist_lt\n\n",
 "exists_cthickenings":
 "#print Disjoint.exists_cthickenings /-\ntheorem Disjoint.exists_cthickenings (hst : Disjoint s t) (hs : IsCompact s) (ht : IsClosed t) :\n    ∃ δ, 0 < δ ∧ Disjoint (cthickening δ s) (cthickening δ t) :=\n  by\n  obtain ⟨δ, hδ, h⟩ := hst.exists_thickenings hs ht\n  refine' ⟨δ / 2, half_pos hδ, h.mono _ _⟩ <;> exact cthickening_subset_thickening' hδ (half_lt_self hδ) _\n#align disjoint.exists_cthickenings Disjoint.exists_cthickenings\n-/\n\n",
 "exists_cthickening_subset_open":
 "#print IsCompact.exists_cthickening_subset_open /-\ntheorem IsCompact.exists_cthickening_subset_open (hs : IsCompact s) (ht : IsOpen t) (hst : s ⊆ t) :\n    ∃ δ, 0 < δ ∧ cthickening δ s ⊆ t :=\n  (hst.disjoint_compl_right.exists_cthickenings hs ht.is_closed_compl).imp fun δ h =>\n    ⟨h.1, disjoint_compl_right_iff_subset.1 <| h.2.mono_right <| self_subset_cthickening _⟩\n#align is_compact.exists_cthickening_subset_open IsCompact.exists_cthickening_subset_open\n-/\n\n",
 "exists_Union_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print IsOpen.exists_unionᵢ_isClosed /-\ntheorem IsOpen.exists_unionᵢ_isClosed {U : Set α} (hU : IsOpen U) :\n    ∃ F : ℕ → Set α,\n      (∀ n, IsClosed (F n)) ∧\n        (∀ n, F n ⊆ U) ∧\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (F n) = U ∧\n            Monotone F :=\n  by\n  obtain ⟨a, a_pos, a_lt_one⟩ : ∃ a : ennreal, 0 < a ∧ a < 1 := exists_between zero_lt_one\n  let F := fun n : ℕ => «expr ⁻¹' » (fun x => inf_edist x («expr ᶜ» U)) (Ici (a ^ n))\n  have F_subset : ∀ n, F n ⊆ U := by\n    intro n x hx\n    have : inf_edist x («expr ᶜ» U) ≠ 0 := ((ENNReal.pow_pos a_pos _).trans_le hx).ne'\n    contrapose! this\n    exact inf_edist_zero_of_mem this\n  refine' ⟨F, fun n => IsClosed.preimage continuous_inf_edist isClosed_Ici, F_subset, _, _⟩\n  show Monotone F\n  · intro m n hmn x hx\n    simp only [mem_Ici, mem_preimage] at hx⊢\n    apply le_trans (pow_le_pow_of_le_one' a_lt_one.le hmn) hx\n  show «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (F n) = U\n  · refine' subset.antisymm (by simp only [Union_subset_iff, F_subset, forall_const]) fun x hx => _\n    have : ¬x ∈ «expr ᶜ» U := by simpa using hx\n    rw [mem_iff_inf_edist_zero_of_closed hU.is_closed_compl] at this\n    have B : 0 < inf_edist x («expr ᶜ» U) := by simpa [pos_iff_ne_zero] using this\n    have : Filter.Tendsto (fun n => a ^ n) at_top ((nhds) 0) := ENNReal.tendsto_pow_atTop_nhds_0_of_lt_1 a_lt_one\n    rcases((tendsto_order.1 this).2 _ B).exists with ⟨n, hn⟩\n    simp only [mem_Union, mem_Ici, mem_preimage]\n    exact ⟨n, hn.le⟩\n#align is_open.exists_Union_is_closed IsOpen.exists_unionᵢ_isClosed\n-/\n\n",
 "empty_or_nonempty_of_Hausdorff_edist_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem empty_or_nonempty_of_Hausdorff_edist_ne_top (fin : hausdorffEdist s t ≠ «expr⊤») :\n    s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty :=\n  by\n  cases' s.eq_empty_or_nonempty with hs hs\n  · cases' t.eq_empty_or_nonempty with ht ht\n    · exact or.inl ⟨hs, ht⟩\n    · rw [Hausdorff_edist_comm] at fin\n      exact or.inr ⟨nonempty_of_Hausdorff_edist_ne_top ht Fin, ht⟩\n  · exact or.inr ⟨hs, nonempty_of_Hausdorff_edist_ne_top hs Fin⟩\n#align empty_or_nonempty_of_Hausdorff_edist_ne_top empty_or_nonempty_of_Hausdorff_edist_ne_top\n\n",
 "edist_le_inf_edist_add_ediam":
 "theorem edist_le_inf_edist_add_ediam (hy : y ∈ s) : edist x y ≤ infEdist x s + diam s :=\n  by\n  simp_rw [inf_edist, ENNReal.infᵢ_add]\n  refine' le_infᵢ fun i => le_infᵢ fun hi => _\n  calc\n    edist x y ≤ edist x i + edist i y := edist_triangle _ _ _\n    _ ≤ edist x i + diam s := add_le_add le_rfl (edist_le_diam_of_mem hi hy)\n    \n#align edist_le_inf_edist_add_ediam edist_le_inf_edist_add_ediam\n\n",
 "ediam_thickening_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem ediam_thickening_le (ε : nnreal) : EMetric.diam (thickening ε s) ≤ EMetric.diam s + 2 * ε :=\n  (EMetric.diam_mono <| thickening_subset_cthickening _ _).trans <| ediam_cthickening_le _\n#align ediam_thickening_le ediam_thickening_le\n\n",
 "ediam_cthickening_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem ediam_cthickening_le (ε : nnreal) : EMetric.diam (cthickening ε s) ≤ EMetric.diam s + 2 * ε :=\n  by\n  refine' diam_le fun x hx y hy => ENNReal.le_of_forall_pos_le_add fun δ hδ _ => _\n  rw [mem_cthickening_iff, ENNReal.ofReal_coe_nnreal] at hx hy\n  have hε : (ε : ennreal) < ε + ↑(δ / 2) := ENNReal.coe_lt_coe.2 (lt_add_of_pos_right _ <| half_pos hδ)\n  rw [ENNReal.coe_div two_ne_zero, ENNReal.coe_two] at hε\n  replace hx := hx.trans_lt hε\n  replace hy := hy.trans_lt hε\n  rw [inf_edist_lt_iff] at hx hy\n  obtain ⟨x', hx', hxx'⟩ := hx\n  obtain ⟨y', hy', hyy'⟩ := hy\n  refine'\n    (edist_triangle_right _ _ _).trans\n      ((add_le_add hxx'.le <|\n            (edist_triangle _ _ _).trans <| add_le_add hyy'.le <| edist_le_diam_of_mem hy' hx').trans_eq\n        _)\n  -- Now we're done, but `ring` won't do it because we're on `ennreal` :(\n  rw [← add_assoc, ← two_mul, mul_add, ENNReal.mul_div_cancel' two_ne_zero ENNReal.two_ne_top]\n  abel\n#align ediam_cthickening_le ediam_cthickening_le\n\n",
 "dist_le_inf_dist_add_diam":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem dist_le_inf_dist_add_diam (hs : Bounded s) (hy : y ∈ s) : dist x y ≤ infDist x s + diam s :=\n  by\n  have A : inf_edist x s ≠ ennreal.top := inf_edist_ne_top ⟨y, hy⟩\n  have B : EMetric.diam s ≠ ennreal.top := hs.ediam_ne_top\n  rw [inf_dist, diam, ← ENNReal.toReal_add A B, dist_edist]\n  apply (ENNReal.toReal_le_toReal _ _).2\n  · exact edist_le_inf_edist_add_ediam hy\n  · rw [edist_dist]\n    exact ENNReal.ofReal_ne_top\n  · exact ENNReal.add_ne_top.2 ⟨A, B⟩\n#align dist_le_inf_dist_add_diam dist_le_inf_dist_add_diam\n\n",
 "disjoint_closed_ball_of_lt_inf_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem disjoint_closed_ball_of_lt_inf_edist {r : ennreal} (h : r < infEdist x s) : Disjoint (closedBall x r) s :=\n  by\n  rw [disjoint_left]\n  intro y hy h'y\n  apply lt_irrefl (inf_edist x s)\n  calc\n    inf_edist x s ≤ edist x y := inf_edist_le_edist_of_mem h'y\n    _ ≤ r := by rwa [mem_closed_ball, edist_comm] at hy\n    _ < inf_edist x s := h\n    \n#align disjoint_closed_ball_of_lt_inf_edist disjoint_closed_ball_of_lt_inf_edist\n\n",
 "disjoint_closed_ball_of_lt_inf_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem disjoint_closed_ball_of_lt_inf_dist {r : exprℝ} (h : r < infDist x s) : Disjoint (closedBall x r) s :=\n  disjoint_ball_infDist.mono_left <| closedBall_subset_ball h\n#align disjoint_closed_ball_of_lt_inf_dist disjoint_closed_ball_of_lt_inf_dist\n\n",
 "disjoint_ball_inf_dist":
 "theorem disjoint_ball_inf_dist : Disjoint (ball x (infDist x s)) s :=\n  disjoint_left.2 fun y hy =>\n    not_mem_of_dist_lt_infDist <|\n      calc\n        dist x y = dist y x := dist_comm _ _\n        _ < infDist x s := hy\n        \n#align disjoint_ball_inf_dist disjoint_ball_inf_dist\n\n",
 "diam_thickening_le":
 "theorem diam_thickening_le {α : Type _} [PseudoMetricSpace α] (s : Set α) (hε : 0 ≤ ε) :\n    diam (thickening ε s) ≤ diam s + 2 * ε := by\n  by_cases hs : bounded s\n  · exact (diam_mono (thickening_subset_cthickening _ _) hs.cthickening).trans (diam_cthickening_le _ hε)\n  obtain rfl | hε := hε.eq_or_lt\n  · simp [thickening_of_nonpos, diam_nonneg]\n  · rw [diam_eq_zero_of_unbounded (mt (bounded.mono <| self_subset_thickening hε _) hs)]\n    positivity\n#align diam_thickening_le diam_thickening_le\n\n",
 "diam_cthickening_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem diam_cthickening_le {α : Type _} [PseudoMetricSpace α] (s : Set α) (hε : 0 ≤ ε) :\n    diam (cthickening ε s) ≤ diam s + 2 * ε :=\n  by\n  by_cases hs : bounded (cthickening ε s)\n  · replace hs := hs.mono (self_subset_cthickening _)\n    lift ε to nnreal using hε\n    have : (2 : ennreal) * ε ≠ «expr⊤» := by simp [ENNReal.mul_eq_top]\n    refine' (ENNReal.toReal_mono (ENNReal.add_ne_top.2 ⟨hs.ediam_ne_top, this⟩) <| ediam_cthickening_le ε).trans_eq _\n    simp [ENNReal.toReal_add hs.ediam_ne_top this, diam]\n  · rw [diam_eq_zero_of_unbounded hs]\n    positivity\n#align diam_cthickening_le diam_cthickening_le\n\n",
 "cthickening_zero":
 "/-- The closed thickening with radius zero is the closure of the set. -/\n@[simp]\ntheorem cthickening_zero (E : Set α) : cthickening 0 E = closure E :=\n  cthickening_of_nonpos le_rfl E\n#align cthickening_zero cthickening_zero\n\n",
 "cthickening_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem cthickening_union (δ : exprℝ) (s t : Set α) : cthickening δ (s ∪ t) = cthickening δ s ∪ cthickening δ t := by\n  simp_rw [cthickening, inf_edist_union, inf_eq_min, min_le_iff, set_of_or]\n#align cthickening_union cthickening_union\n\n",
 "cthickening_thickening_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- For the equality, see `cthickening_thickening`. -/\n@[simp]\ntheorem cthickening_thickening_subset (hε : 0 ≤ ε) (δ : exprℝ) (s : Set α) :\n    cthickening ε (thickening δ s) ⊆ cthickening (ε + δ) s :=\n  by\n  obtain hδ | hδ := le_total δ 0\n  · simp only [thickening_of_nonpos hδ, cthickening_empty, empty_subset]\n  intro x\n  simp_rw [mem_cthickening_iff, ENNReal.ofReal_add hε hδ]\n  exact fun hx => inf_edist_le_inf_edist_thickening_add.trans (add_le_add_right hx _)\n#align cthickening_thickening_subset cthickening_thickening_subset\n\n",
 "cthickening_subset_thickening'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The closed thickening `cthickening δ₁ E` is contained in the open thickening `thickening δ₂ E`\nif the radius of the latter is positive and larger. -/\ntheorem cthickening_subset_thickening' {δ₁ δ₂ : exprℝ} (δ₂_pos : 0 < δ₂) (hlt : δ₁ < δ₂) (E : Set α) :\n    cthickening δ₁ E ⊆ thickening δ₂ E := fun _ hx => lt_of_le_of_lt hx ((ENNReal.ofReal_lt_ofReal_iff δ₂_pos).mpr hlt)\n#align cthickening_subset_thickening' cthickening_subset_thickening'\n\n",
 "cthickening_subset_thickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cthickening_subset_thickening {δ₁ : nnreal} {δ₂ : exprℝ} (hlt : (δ₁ : exprℝ) < δ₂) (E : Set α) :\n    cthickening δ₁ E ⊆ thickening δ₂ E := fun _ hx =>\n  lt_of_le_of_lt hx ((ENNReal.ofReal_lt_ofReal_iff (lt_of_le_of_lt δ₁.prop hlt)).mpr hlt)\n#align cthickening_subset_thickening cthickening_subset_thickening\n\n",
 "cthickening_subset_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The closed thickening `cthickening δ E` with a fixed thickening radius `δ` is\nan increasing function of the subset `E`. -/\ntheorem cthickening_subset_of_subset (δ : exprℝ) {E₁ E₂ : Set α} (h : E₁ ⊆ E₂) : cthickening δ E₁ ⊆ cthickening δ E₂ :=\n  fun _ hx => le_trans (infEdist_anti h) hx\n#align cthickening_subset_of_subset cthickening_subset_of_subset\n\n",
 "cthickening_subset_Union_closed_ball_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem cthickening_subset_Union_closed_ball_of_lt {α : Type _} [PseudoMetricSpace α] (E : Set α) {δ δ' : exprℝ}\n    (hδ₀ : 0 < δ') (hδδ' : δ < δ') :\n    cthickening δ E ⊆\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (closedBall x δ') :=\n  by\n  refine' (cthickening_subset_thickening' hδ₀ hδδ' E).trans fun x hx => _\n  obtain ⟨y, hy₁, hy₂⟩ := mem_thickening_iff.mp hx\n  exact mem_Union₂.mpr ⟨y, hy₁, hy₂.le⟩\n#align cthickening_subset_Union_closed_ball_of_lt cthickening_subset_Union_closed_ball_of_lt\n\n",
 "cthickening_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem cthickening_singleton {α : Type _} [PseudoMetricSpace α] (x : α) {δ : exprℝ} (hδ : 0 ≤ δ) :\n    cthickening δ ({x} : Set α) = closedBall x δ := by\n  ext y\n  simp [cthickening, edist_dist, ENNReal.ofReal_le_ofReal_iff hδ]\n#align cthickening_singleton cthickening_singleton\n\n",
 "cthickening_of_nonpos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cthickening_of_nonpos {δ : exprℝ} (hδ : δ ≤ 0) (E : Set α) : cthickening δ E = closure E :=\n  by\n  ext x\n  simp [mem_closure_iff_inf_edist_zero, cthickening, ENNReal.ofReal_eq_zero.2 hδ]\n#align cthickening_of_nonpos cthickening_of_nonpos\n\n",
 "cthickening_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The closed thickening `cthickening δ E` of a fixed subset `E` is an increasing function of\nthe thickening radius `δ`. -/\ntheorem cthickening_mono {δ₁ δ₂ : exprℝ} (hle : δ₁ ≤ δ₂) (E : Set α) : cthickening δ₁ E ⊆ cthickening δ₂ E :=\n  preimage_mono (Iic_subset_Iic.mpr (ENNReal.ofReal_le_ofReal hle))\n#align cthickening_mono cthickening_mono\n\n",
 "cthickening_mem_nhds_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\ntheorem cthickening_mem_nhds_set (E : Set α) {δ : exprℝ} (hδ : 0 < δ) : cthickening δ E ∈ (nhds_set) E :=\n  mem_of_superset (thickening_mem_nhdsSet E hδ) (thickening_subset_cthickening _ _)\n#align cthickening_mem_nhds_set cthickening_mem_nhds_set\n\n",
 "cthickening_max_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cthickening_max_zero (δ : exprℝ) (E : Set α) : cthickening (max 0 δ) E = cthickening δ E := by\n  cases le_total δ 0 <;> simp [cthickening_of_nonpos, *]\n#align cthickening_max_zero cthickening_max_zero\n\n",
 "cthickening_eq_preimage_inf_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem cthickening_eq_preimage_inf_edist (δ : exprℝ) (E : Set α) :\n    cthickening δ E = «expr ⁻¹' » (fun x => infEdist x E) (Iic (ENNReal.ofReal δ)) :=\n  rfl\n#align cthickening_eq_preimage_inf_edist cthickening_eq_preimage_inf_edist\n\n",
 "cthickening_eq_bUnion_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print IsClosed.cthickening_eq_bunionᵢ_closedBall /-\ntheorem IsClosed.cthickening_eq_bunionᵢ_closedBall {α : Type _} [PseudoMetricSpace α] [ProperSpace α] {E : Set α}\n    (hE : IsClosed E) (hδ : 0 ≤ δ) :\n    cthickening δ E =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (closedBall x δ) :=\n  by rw [cthickening_eq_bUnion_closed_ball E hδ, hE.closure_eq]\n#align is_closed.cthickening_eq_bUnion_closed_ball IsClosed.cthickening_eq_bunionᵢ_closedBall\n-/\n\n",
 "cthickening_eq_Inter_thickening''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem cthickening_eq_Inter_thickening'' (δ : exprℝ) (E : Set α) :\n    cthickening δ E =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (thickening ε E) :=\n  by\n  rw [← cthickening_max_zero, cthickening_eq_Inter_thickening]\n  exact le_max_left _ _\n#align cthickening_eq_Inter_thickening'' cthickening_eq_Inter_thickening''\n\n",
 "cthickening_eq_Inter_thickening'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem cthickening_eq_Inter_thickening' {δ : exprℝ} (δ_nn : 0 ≤ δ) (s : Set (exprℝ)) (hsδ : s ⊆ Ioi δ)\n    (hs : ∀ ε, δ < ε → (s ∩ Ioc δ ε).nonempty) (E : Set α) :\n    cthickening δ E =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (thickening ε E) :=\n  by\n  refine' (subset_Inter₂ fun ε hε => _).antisymm _\n  · obtain ⟨ε', hsε', hε'⟩ := hs ε (hsδ hε)\n    have ss := cthickening_subset_thickening' (lt_of_le_of_lt δ_nn hε'.1) hε'.1 E\n    exact ss.trans (thickening_mono hε'.2 E)\n  · rw [cthickening_eq_Inter_cthickening' s hsδ hs E]\n    exact Inter₂_mono fun ε hε => thickening_subset_cthickening ε E\n#align cthickening_eq_Inter_thickening' cthickening_eq_Inter_thickening'\n\n",
 "cthickening_eq_Inter_thickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem cthickening_eq_Inter_thickening {δ : exprℝ} (δ_nn : 0 ≤ δ) (E : Set α) :\n    cthickening δ E =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (thickening ε E) :=\n  by\n  apply cthickening_eq_Inter_thickening' δ_nn (Ioi δ) rfl.subset\n  simp_rw [inter_eq_right_iff_subset.mpr Ioc_subset_Ioi_self]\n  exact fun _ hε => nonempty_Ioc.mpr hε\n#align cthickening_eq_Inter_thickening cthickening_eq_Inter_thickening\n\n",
 "cthickening_eq_Inter_cthickening'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem cthickening_eq_Inter_cthickening' {δ : exprℝ} (s : Set (exprℝ)) (hsδ : s ⊆ Ioi δ)\n    (hs : ∀ ε, δ < ε → (s ∩ Ioc δ ε).nonempty) (E : Set α) :\n    cthickening δ E =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (cthickening ε E) :=\n  by\n  apply subset.antisymm\n  · exact subset_Inter₂ fun _ hε => cthickening_mono (le_of_lt (hsδ hε)) E\n  · unfold thickening cthickening\n    intro x hx\n    simp only [mem_Inter, mem_set_of_eq] at *\n    apply ENNReal.le_of_forall_pos_le_add\n    intro η η_pos _\n    rcases hs (δ + η) (lt_add_of_pos_right _ (nnreal.coe_pos.mpr η_pos)) with ⟨ε, ⟨hsε, hε⟩⟩\n    apply ((hx ε hsε).trans (ENNReal.ofReal_le_ofReal hε.2)).trans\n    rw [ENNReal.coe_nnreal_eq η]\n    exact ENNReal.ofReal_add_le\n#align cthickening_eq_Inter_cthickening' cthickening_eq_Inter_cthickening'\n\n",
 "cthickening_eq_Inter_cthickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem cthickening_eq_Inter_cthickening {δ : exprℝ} (E : Set α) :\n    cthickening δ E =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (cthickening ε E) :=\n  by\n  apply cthickening_eq_Inter_cthickening' (Ioi δ) rfl.subset\n  simp_rw [inter_eq_right_iff_subset.mpr Ioc_subset_Ioi_self]\n  exact fun _ hε => nonempty_Ioc.mpr hε\n#align cthickening_eq_Inter_cthickening cthickening_eq_Inter_cthickening\n\n",
 "cthickening_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The closed thickening of the empty set is empty. -/\n@[simp]\ntheorem cthickening_empty (δ : exprℝ) : cthickening δ (∅ : Set α) = ∅ := by\n  simp only [cthickening, ENNReal.ofReal_ne_top, set_of_false, inf_edist_empty, top_le_iff]\n#align cthickening_empty cthickening_empty\n\n",
 "cthickening_cthickening_subset":
 "/-- For the equality, see `cthickening_cthickening`. -/\n@[simp]\ntheorem cthickening_cthickening_subset (hε : 0 ≤ ε) (hδ : 0 ≤ δ) (s : Set α) :\n    cthickening ε (cthickening δ s) ⊆ cthickening (ε + δ) s :=\n  by\n  intro x\n  simp_rw [mem_cthickening_iff, ENNReal.ofReal_add hε hδ]\n  exact fun hx => inf_edist_le_inf_edist_cthickening_add.trans (add_le_add_right hx _)\n#align cthickening_cthickening_subset cthickening_cthickening_subset\n\n",
 "cthickening_closure":
 "@[simp]\ntheorem cthickening_closure : cthickening δ (closure s) = cthickening δ s := by simp_rw [cthickening, inf_edist_closure]\n#align cthickening_closure cthickening_closure\n\n",
 "cthickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem bounded.cthickening {α : Type _} [PseudoMetricSpace α] {δ : exprℝ} {E : Set α} (h : Bounded E) :\n    Bounded (cthickening δ E) :=\n  by\n  have : bounded (thickening (max (δ + 1) 1) E) := h.thickening\n  apply bounded.mono _ this\n  exact\n    cthickening_subset_thickening' (zero_lt_one.trans_le (le_max_right _ _)) ((lt_add_one _).trans_le (le_max_left _ _))\n      _\n#align bounded.cthickening bounded.cthickening\n\n",
 "continuous_inf_nndist_pt":
 "/-- The minimal distance to a set (as `ℝ≥0`) is continuous in point -/\ntheorem continuous_inf_nndist_pt (s : Set α) : Continuous fun x => infNndist x s :=\n  (uniformContinuous_infNndist_pt s).continuous\n#align continuous_inf_nndist_pt continuous_inf_nndist_pt\n\n",
 "continuous_inf_edist":
 "/-- The edist to a set depends continuously on the point -/\n@[continuity]\ntheorem continuous_inf_edist : Continuous fun x => infEdist x s :=\n  continuous_of_le_add_edist 1 (by simp) <| by simp only [one_mul, inf_edist_le_inf_edist_add_edist, forall₂_true_iff]\n#align continuous_inf_edist continuous_inf_edist\n\n",
 "continuous_inf_dist_pt":
 "/-- The minimal distance to a set is continuous in point -/\n@[continuity]\ntheorem continuous_inf_dist_pt : Continuous fun x => infDist x s :=\n  (uniformContinuous_infDist_pt s).continuous\n#align continuous_inf_dist_pt continuous_inf_dist_pt\n\n",
 "coe_inf_nndist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem coe_inf_nndist : (infNndist x s : exprℝ) = infDist x s :=\n  rfl\n#align coe_inf_nndist coe_inf_nndist\n\n",
 "closure_thickening_subset_cthickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem closure_thickening_subset_cthickening (δ : exprℝ) (E : Set α) : closure (thickening δ E) ⊆ cthickening δ E :=\n  (closure_mono (thickening_subset_cthickening δ E)).trans isClosed_cthickening.closure_subset\n#align closure_thickening_subset_cthickening closure_thickening_subset_cthickening\n\n",
 "closure_subset_thickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The (open) thickening of a set contains the closure of the set. -/\ntheorem closure_subset_thickening {δ : exprℝ} (δ_pos : 0 < δ) (E : Set α) : closure E ⊆ thickening δ E :=\n  by\n  rw [← cthickening_zero]\n  exact cthickening_subset_thickening' δ_pos δ_pos E\n#align closure_subset_thickening closure_subset_thickening\n\n",
 "closure_subset_cthickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The closed thickening of a set contains the closure of the set. -/\ntheorem closure_subset_cthickening (δ : exprℝ) (E : Set α) : closure E ⊆ cthickening δ E :=\n  by\n  rw [← cthickening_of_nonpos (min_le_right δ 0)]\n  exact cthickening_mono (min_le_left δ 0) E\n#align closure_subset_cthickening closure_subset_cthickening\n\n",
 "closure_eq_Inter_thickening'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- The closure of a set equals the intersection of its open thickenings of positive radii\naccumulating at zero. -/\ntheorem closure_eq_Inter_thickening' (E : Set α) (s : Set (exprℝ)) (hs₀ : s ⊆ Ioi 0)\n    (hs : ∀ ε, 0 < ε → (s ∩ Ioc 0 ε).nonempty) :\n    closure E =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (thickening δ E) :=\n  by\n  rw [← cthickening_zero]\n  apply cthickening_eq_Inter_thickening' le_rfl _ hs₀ hs\n#align closure_eq_Inter_thickening' closure_eq_Inter_thickening'\n\n",
 "closure_eq_Inter_thickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- The closure of a set equals the intersection of its (open) thickenings of positive radii. -/\ntheorem closure_eq_Inter_thickening (E : Set α) :\n    closure E =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (thickening δ E) :=\n  by\n  rw [← cthickening_zero]\n  exact cthickening_eq_Inter_thickening rfl.ge E\n#align closure_eq_Inter_thickening closure_eq_Inter_thickening\n\n",
 "closure_eq_Inter_cthickening'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- The closure of a set equals the intersection of its closed thickenings of positive radii\naccumulating at zero. -/\ntheorem closure_eq_Inter_cthickening' (E : Set α) (s : Set (exprℝ)) (hs : ∀ ε, 0 < ε → (s ∩ Ioc 0 ε).nonempty) :\n    closure E =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (cthickening δ E) :=\n  by\n  by_cases hs₀ : s ⊆ Ioi 0\n  · rw [← cthickening_zero]\n    apply cthickening_eq_Inter_cthickening' _ hs₀ hs\n  obtain ⟨δ, hδs, δ_nonpos⟩ := not_subset.mp hs₀\n  rw [Set.mem_Ioi, not_lt] at δ_nonpos\n  apply subset.antisymm\n  · exact subset_Inter₂ fun ε _ => closure_subset_cthickening ε E\n  · rw [← cthickening_of_nonpos δ_nonpos E]\n    exact bInter_subset_of_mem hδs\n#align closure_eq_Inter_cthickening' closure_eq_Inter_cthickening'\n\n",
 "closure_eq_Inter_cthickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- The closure of a set equals the intersection of its closed thickenings of positive radii. -/\ntheorem closure_eq_Inter_cthickening (E : Set α) :\n    closure E =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (cthickening δ E) :=\n  by\n  rw [← cthickening_zero]\n  exact cthickening_eq_Inter_cthickening E\n#align closure_eq_Inter_cthickening closure_eq_Inter_cthickening\n\n",
 "closed_ball_subset_cthickening_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem closed_ball_subset_cthickening_singleton {α : Type _} [PseudoMetricSpace α] (x : α) (δ : exprℝ) :\n    closedBall x δ ⊆ cthickening δ ({x} : Set α) :=\n  by\n  rcases lt_or_le δ 0 with (hδ | hδ)\n  · simp only [closed_ball_eq_empty.mpr hδ, empty_subset]\n  · simp only [cthickening_singleton x hδ]\n#align closed_ball_subset_cthickening_singleton closed_ball_subset_cthickening_singleton\n\n",
 "closed_ball_subset_cthickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The closed ball of radius `δ` centered at a point of `E` is included in the closed\nthickening of `E`. -/\ntheorem closed_ball_subset_cthickening {α : Type _} [PseudoMetricSpace α] {x : α} {E : Set α} (hx : x ∈ E) (δ : exprℝ) :\n    closedBall x δ ⊆ cthickening δ E :=\n  by\n  refine' (closed_ball_subset_cthickening_singleton _ _).trans (cthickening_subset_of_subset _ _)\n  simpa using hx\n#align closed_ball_subset_cthickening closed_ball_subset_cthickening\n\n",
 "ball_subset_thickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem ball_subset_thickening {x : X} {E : Set X} (hx : x ∈ E) (δ : exprℝ) : ball x δ ⊆ thickening δ E :=\n  Subset.trans (by simp) (thickening_subset_of_subset δ <| singleton_subset_iff.mpr hx)\n#align ball_subset_thickening ball_subset_thickening\n\n",
 "ball_inf_dist_subset_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem ball_inf_dist_subset_compl : ball x (infDist x s) ⊆ «expr ᶜ» s :=\n  disjoint_ball_infDist.subset_compl_right\n#align ball_inf_dist_subset_compl ball_inf_dist_subset_compl\n\n",
 "ball_inf_dist_compl_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem ball_inf_dist_compl_subset : ball x (infDist x («expr ᶜ» s)) ⊆ s :=\n  ball_infDist_subset_compl.trans (compl_compl s).subset\n#align ball_inf_dist_compl_subset ball_inf_dist_compl_subset\n\n",
 "Hausdorff_edist_zero_iff_eq_of_closed":
 "/-- Two closed sets are at zero Hausdorff edistance if and only if they coincide -/\ntheorem Hausdorff_edist_zero_iff_eq_of_closed (hs : IsClosed s) (ht : IsClosed t) : hausdorffEdist s t = 0 ↔ s = t := by\n  rw [Hausdorff_edist_zero_iff_closure_eq_closure, hs.closure_eq, ht.closure_eq]\n#align Hausdorff_edist_zero_iff_eq_of_closed Hausdorff_edist_zero_iff_eq_of_closed\n\n",
 "Hausdorff_edist_zero_iff_closure_eq_closure":
 "/-- Two sets are at zero Hausdorff edistance if and only if they have the same closure -/\ntheorem Hausdorff_edist_zero_iff_closure_eq_closure : hausdorffEdist s t = 0 ↔ closure s = closure t :=\n  calc\n    hausdorffEdist s t = 0 ↔ s ⊆ closure t ∧ t ⊆ closure s := by\n      simp only [Hausdorff_edist_def, ENNReal.sup_eq_zero, ENNReal.supᵢ_eq_zero, ← mem_closure_iff_inf_edist_zero,\n        subset_def]\n    _ ↔ closure s = closure t :=\n      ⟨fun h => Subset.antisymm (closure_minimal h.1 isClosed_closure) (closure_minimal h.2 isClosed_closure), fun h =>\n        ⟨h ▸ subset_closure, h.symm ▸ subset_closure⟩⟩\n    \n#align Hausdorff_edist_zero_iff_closure_eq_closure Hausdorff_edist_zero_iff_closure_eq_closure\n\n",
 "Hausdorff_edist_triangle":
 "/-- The Hausdorff distance satisfies the triangular inequality -/\ntheorem Hausdorff_edist_triangle : hausdorffEdist s u ≤ hausdorffEdist s t + hausdorffEdist t u :=\n  by\n  rw [Hausdorff_edist_def]\n  simp only [sup_le_iff, supᵢ_le_iff]\n  constructor\n  show ∀ x ∈ s, inf_edist x u ≤ Hausdorff_edist s t + Hausdorff_edist t u;\n  exact fun x xs =>\n    calc\n      inf_edist x u ≤ inf_edist x t + Hausdorff_edist t u := inf_edist_le_inf_edist_add_Hausdorff_edist\n      _ ≤ Hausdorff_edist s t + Hausdorff_edist t u := add_le_add_right (inf_edist_le_Hausdorff_edist_of_mem xs) _\n      \n  show ∀ x ∈ u, inf_edist x s ≤ Hausdorff_edist s t + Hausdorff_edist t u;\n  exact fun x xu =>\n    calc\n      inf_edist x s ≤ inf_edist x t + Hausdorff_edist t s := inf_edist_le_inf_edist_add_Hausdorff_edist\n      _ ≤ Hausdorff_edist u t + Hausdorff_edist t s := (add_le_add_right (inf_edist_le_Hausdorff_edist_of_mem xu) _)\n      _ = Hausdorff_edist s t + Hausdorff_edist t u := by simp [Hausdorff_edist_comm, add_comm]\n      \n#align Hausdorff_edist_triangle Hausdorff_edist_triangle\n\n",
 "Hausdorff_edist_self_closure":
 "/-- The Hausdorff edistance between a set and its closure vanishes -/\n@[simp]\ntheorem Hausdorff_edist_self_closure : hausdorffEdist s (closure s) = 0 := by\n  rw [Hausdorff_edist_zero_iff_closure_eq_closure, closure_closure]\n#align Hausdorff_edist_self_closure Hausdorff_edist_self_closure\n\n",
 "Hausdorff_edist_self":
 "/-- The Hausdorff edistance of a set to itself vanishes -/\n@[simp]\ntheorem Hausdorff_edist_self : hausdorffEdist s s = 0 :=\n  by\n  simp only [Hausdorff_edist_def, sup_idem, ENNReal.supᵢ_eq_zero]\n  exact fun x hx => inf_edist_zero_of_mem hx\n#align Hausdorff_edist_self Hausdorff_edist_self\n\n",
 "Hausdorff_edist_ne_top_of_nonempty_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem Hausdorff_edist_ne_top_of_nonempty_of_bounded (hs : s.nonempty) (ht : t.nonempty) (bs : Bounded s)\n    (bt : Bounded t) : hausdorffEdist s t ≠ «expr⊤» :=\n  by\n  rcases hs with ⟨cs, hcs⟩\n  rcases ht with ⟨ct, hct⟩\n  rcases(bounded_iff_subset_ball ct).1 bs with ⟨rs, hrs⟩\n  rcases(bounded_iff_subset_ball cs).1 bt with ⟨rt, hrt⟩\n  have : Hausdorff_edist s t ≤ ENNReal.ofReal (max rs rt) :=\n    by\n    apply Hausdorff_edist_le_of_mem_edist\n    · intro x xs\n      exists ct, hct\n      have : dist x ct ≤ max rs rt := le_trans (hrs xs) (le_max_left _ _)\n      rwa [edist_dist, ENNReal.ofReal_le_ofReal_iff]\n      exact le_trans dist_nonneg this\n    · intro x xt\n      exists cs, hcs\n      have : dist x cs ≤ max rs rt := le_trans (hrt xt) (le_max_right _ _)\n      rwa [edist_dist, ENNReal.ofReal_le_ofReal_iff]\n      exact le_trans dist_nonneg this\n  exact ne_top_of_le_ne_top ENNReal.ofReal_ne_top this\n#align Hausdorff_edist_ne_top_of_nonempty_of_bounded Hausdorff_edist_ne_top_of_nonempty_of_bounded\n\n",
 "Hausdorff_edist_le_of_mem_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- Bounding the Hausdorff edistance by exhibiting, for any point in each set,\nanother point in the other set at controlled distance -/\ntheorem Hausdorff_edist_le_of_mem_edist {r : ennreal} (H1 : ∀ x ∈ s, ∃ y ∈ t, edist x y ≤ r)\n    (H2 : ∀ x ∈ t, ∃ y ∈ s, edist x y ≤ r) : hausdorffEdist s t ≤ r :=\n  by\n  refine' Hausdorff_edist_le_of_inf_edist _ _\n  · intro x xs\n    rcases H1 x xs with ⟨y, yt, hy⟩\n    exact le_trans (inf_edist_le_edist_of_mem yt) hy\n  · intro x xt\n    rcases H2 x xt with ⟨y, ys, hy⟩\n    exact le_trans (inf_edist_le_edist_of_mem ys) hy\n#align Hausdorff_edist_le_of_mem_edist Hausdorff_edist_le_of_mem_edist\n\n",
 "Hausdorff_edist_le_of_inf_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- Bounding the Hausdorff edistance by bounding the edistance of any point\nin each set to the other set -/\ntheorem Hausdorff_edist_le_of_inf_edist {r : ennreal} (H1 : ∀ x ∈ s, infEdist x t ≤ r)\n    (H2 : ∀ x ∈ t, infEdist x s ≤ r) : hausdorffEdist s t ≤ r :=\n  by\n  simp only [Hausdorff_edist, sup_le_iff, supᵢ_le_iff]\n  exact ⟨H1, H2⟩\n#align Hausdorff_edist_le_of_inf_edist Hausdorff_edist_le_of_inf_edist\n\n",
 "Hausdorff_edist_le_ediam":
 "/-- The Hausdorff distance is controlled by the diameter of the union -/\ntheorem Hausdorff_edist_le_ediam (hs : s.nonempty) (ht : t.nonempty) : hausdorffEdist s t ≤ diam (s ∪ t) :=\n  by\n  rcases hs with ⟨x, xs⟩\n  rcases ht with ⟨y, yt⟩\n  refine' Hausdorff_edist_le_of_mem_edist _ _\n  · intro z hz\n    exact ⟨y, yt, edist_le_diam_of_mem (subset_union_left _ _ hz) (subset_union_right _ _ yt)⟩\n  · intro z hz\n    exact ⟨x, xs, edist_le_diam_of_mem (subset_union_right _ _ hz) (subset_union_left _ _ xs)⟩\n#align Hausdorff_edist_le_ediam Hausdorff_edist_le_ediam\n\n",
 "Hausdorff_edist_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The Hausdorff edistance is invariant under eisometries -/\ntheorem Hausdorff_edist_image (h : Isometry Φ) :\n    hausdorffEdist («expr '' » Φ s) («expr '' » Φ t) = hausdorffEdist s t := by\n  simp only [Hausdorff_edist_def, supᵢ_image, inf_edist_image h]\n#align Hausdorff_edist_image Hausdorff_edist_image\n\n",
 "Hausdorff_edist_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/-- The Haudorff edistance to the empty set is infinite -/\ntheorem Hausdorff_edist_empty (ne : s.nonempty) : hausdorffEdist s ∅ = ennreal.top :=\n  by\n  rcases ne with ⟨x, xs⟩\n  have : inf_edist x ∅ ≤ Hausdorff_edist s ∅ := inf_edist_le_Hausdorff_edist_of_mem xs\n  simpa using this\n#align Hausdorff_edist_empty Hausdorff_edist_empty\n\n",
 "Hausdorff_edist_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n--section\ntheorem Hausdorff_edist_def {α : Type u} [PseudoEMetricSpace α] (s t : Set α) :\n    hausdorffEdist s t =\n      «expr ⊔ »\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (infEdist x t))\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (infEdist y s)) :=\n  by rw [Hausdorff_edist]\n#align Hausdorff_edist_def Hausdorff_edist_def\n\n",
 "Hausdorff_edist_comm":
 "/-- The Haudorff edistances of `s` to `t` and of `t` to `s` coincide -/\ntheorem Hausdorff_edist_comm : hausdorffEdist s t = hausdorffEdist t s := by unfold Hausdorff_edist <;> apply sup_comm\n#align Hausdorff_edist_comm Hausdorff_edist_comm\n\n",
 "Hausdorff_edist_closure₂":
 "/-- Replacing a set by its closure does not change the Hausdorff edistance. -/\n@[simp]\ntheorem Hausdorff_edist_closure₂ : hausdorffEdist s (closure t) = hausdorffEdist s t := by\n  simp [@Hausdorff_edist_comm _ _ s _]\n#align Hausdorff_edist_closure₂ Hausdorff_edist_closure₂\n\n",
 "Hausdorff_edist_closure₁":
 "/-- Replacing a set by its closure does not change the Hausdorff edistance. -/\n@[simp]\ntheorem Hausdorff_edist_closure₁ : hausdorffEdist (closure s) t = hausdorffEdist s t :=\n  by\n  refine' le_antisymm _ _\n  ·\n    calc\n      _ ≤ Hausdorff_edist (closure s) s + Hausdorff_edist s t := Hausdorff_edist_triangle\n      _ = Hausdorff_edist s t := by simp [Hausdorff_edist_comm]\n      \n  ·\n    calc\n      _ ≤ Hausdorff_edist s (closure s) + Hausdorff_edist (closure s) t := Hausdorff_edist_triangle\n      _ = Hausdorff_edist (closure s) t := by simp\n      \n#align Hausdorff_edist_closure₁ Hausdorff_edist_closure₁\n\n",
 "Hausdorff_edist_closure":
 "/-- The Hausdorff edistance between sets or their closures is the same -/\n@[simp]\ntheorem Hausdorff_edist_closure : hausdorffEdist (closure s) (closure t) = hausdorffEdist s t := by simp\n#align Hausdorff_edist_closure Hausdorff_edist_closure\n\n",
 "Hausdorff_dist_zero_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print IsClosed.hausdorffDist_zero_iff_eq /-\n/-- Two closed sets are at zero Hausdorff distance if and only if they coincide -/\ntheorem IsClosed.hausdorffDist_zero_iff_eq (hs : IsClosed s) (ht : IsClosed t) (fin : hausdorffEdist s t ≠ «expr⊤») :\n    hausdorffDist s t = 0 ↔ s = t := by\n  simp [← Hausdorff_edist_zero_iff_eq_of_closed hs ht, Hausdorff_dist, ENNReal.toReal_eq_zero_iff, Fin]\n#align is_closed.Hausdorff_dist_zero_iff_eq IsClosed.hausdorffDist_zero_iff_eq\n-/\n\n",
 "Hausdorff_dist_zero_iff_closure_eq_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Two sets are at zero Hausdorff distance if and only if they have the same closures -/\ntheorem Hausdorff_dist_zero_iff_closure_eq_closure (fin : hausdorffEdist s t ≠ «expr⊤») :\n    hausdorffDist s t = 0 ↔ closure s = closure t := by\n  simp [Hausdorff_edist_zero_iff_closure_eq_closure.symm, Hausdorff_dist, ENNReal.toReal_eq_zero_iff, Fin]\n#align Hausdorff_dist_zero_iff_closure_eq_closure Hausdorff_dist_zero_iff_closure_eq_closure\n\n",
 "Hausdorff_dist_triangle'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The Hausdorff distance satisfies the triangular inequality -/\ntheorem Hausdorff_dist_triangle' (fin : hausdorffEdist t u ≠ «expr⊤») :\n    hausdorffDist s u ≤ hausdorffDist s t + hausdorffDist t u :=\n  by\n  rw [Hausdorff_edist_comm] at fin\n  have I : Hausdorff_dist u s ≤ Hausdorff_dist u t + Hausdorff_dist t s := Hausdorff_dist_triangle Fin\n  simpa [add_comm, Hausdorff_dist_comm] using I\n#align Hausdorff_dist_triangle' Hausdorff_dist_triangle'\n\n",
 "Hausdorff_dist_triangle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The Hausdorff distance satisfies the triangular inequality -/\ntheorem Hausdorff_dist_triangle (fin : hausdorffEdist s t ≠ «expr⊤») :\n    hausdorffDist s u ≤ hausdorffDist s t + hausdorffDist t u :=\n  by\n  by_cases Hausdorff_edist s u = «expr⊤»\n  ·\n    calc\n      Hausdorff_dist s u = 0 + 0 := by simp [Hausdorff_dist, h]\n      _ ≤ Hausdorff_dist s t + Hausdorff_dist t u := add_le_add Hausdorff_dist_nonneg Hausdorff_dist_nonneg\n      \n  · have Dtu : Hausdorff_edist t u < «expr⊤» :=\n      calc\n        Hausdorff_edist t u ≤ Hausdorff_edist t s + Hausdorff_edist s u := Hausdorff_edist_triangle\n        _ = Hausdorff_edist s t + Hausdorff_edist s u := by simp [Hausdorff_edist_comm]\n        _ < «expr⊤» := lt_top_iff_ne_top.mpr <| ennreal.add_ne_top.mpr ⟨Fin, h⟩\n        \n    rw [Hausdorff_dist, Hausdorff_dist, Hausdorff_dist, ← ENNReal.toReal_add Fin Dtu.ne, ENNReal.toReal_le_toReal h]\n    · exact Hausdorff_edist_triangle\n    · simp [ENNReal.add_eq_top, lt_top_iff_ne_top.1 Dtu, Fin]\n#align Hausdorff_dist_triangle Hausdorff_dist_triangle\n\n",
 "Hausdorff_dist_self_zero":
 "/-- The Hausdorff distance between a set and itself is zero -/\n@[simp]\ntheorem Hausdorff_dist_self_zero : hausdorffDist s s = 0 := by simp [Hausdorff_dist]\n#align Hausdorff_dist_self_zero Hausdorff_dist_self_zero\n\n",
 "Hausdorff_dist_self_closure":
 "/-- The Hausdorff distance between a set and its closure vanish -/\n@[simp]\ntheorem Hausdorff_dist_self_closure : hausdorffDist s (closure s) = 0 := by simp [Hausdorff_dist]\n#align Hausdorff_dist_self_closure Hausdorff_dist_self_closure\n\n",
 "Hausdorff_dist_nonneg":
 "/-- The Hausdorff distance is nonnegative -/\ntheorem Hausdorff_dist_nonneg : 0 ≤ hausdorffDist s t := by simp [Hausdorff_dist]\n#align Hausdorff_dist_nonneg Hausdorff_dist_nonneg\n\n",
 "Hausdorff_dist_le_of_mem_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Bounding the Hausdorff distance by exhibiting, for any point in each set,\nanother point in the other set at controlled distance -/\ntheorem Hausdorff_dist_le_of_mem_dist {r : exprℝ} (hr : 0 ≤ r) (H1 : ∀ x ∈ s, ∃ y ∈ t, dist x y ≤ r)\n    (H2 : ∀ x ∈ t, ∃ y ∈ s, dist x y ≤ r) : hausdorffDist s t ≤ r :=\n  by\n  apply Hausdorff_dist_le_of_inf_dist hr\n  · intro x xs\n    rcases H1 x xs with ⟨y, yt, hy⟩\n    exact le_trans (inf_dist_le_dist_of_mem yt) hy\n  · intro x xt\n    rcases H2 x xt with ⟨y, ys, hy⟩\n    exact le_trans (inf_dist_le_dist_of_mem ys) hy\n#align Hausdorff_dist_le_of_mem_dist Hausdorff_dist_le_of_mem_dist\n\n",
 "Hausdorff_dist_le_of_inf_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Bounding the Hausdorff distance by bounding the distance of any point\nin each set to the other set -/\ntheorem Hausdorff_dist_le_of_inf_dist {r : exprℝ} (hr : 0 ≤ r) (H1 : ∀ x ∈ s, infDist x t ≤ r)\n    (H2 : ∀ x ∈ t, infDist x s ≤ r) : hausdorffDist s t ≤ r :=\n  by\n  by_cases h1 : Hausdorff_edist s t = «expr⊤»\n  · rwa [Hausdorff_dist, h1, ENNReal.top_toReal]\n  cases' s.eq_empty_or_nonempty with hs hs\n  · rwa [hs, Hausdorff_dist_empty']\n  cases' t.eq_empty_or_nonempty with ht ht\n  · rwa [ht, Hausdorff_dist_empty]\n  have : Hausdorff_edist s t ≤ ENNReal.ofReal r :=\n    by\n    apply Hausdorff_edist_le_of_inf_edist _ _\n    · intro x hx\n      have I := H1 x hx\n      rwa [inf_dist, ← ENNReal.toReal_ofReal hr,\n        ENNReal.toReal_le_toReal (inf_edist_ne_top ht) ENNReal.ofReal_ne_top] at I\n    · intro x hx\n      have I := H2 x hx\n      rwa [inf_dist, ← ENNReal.toReal_ofReal hr,\n        ENNReal.toReal_le_toReal (inf_edist_ne_top hs) ENNReal.ofReal_ne_top] at I\n  rwa [Hausdorff_dist, ← ENNReal.toReal_ofReal hr, ENNReal.toReal_le_toReal h1 ENNReal.ofReal_ne_top]\n#align Hausdorff_dist_le_of_inf_dist Hausdorff_dist_le_of_inf_dist\n\n",
 "Hausdorff_dist_le_diam":
 "/-- The Hausdorff distance is controlled by the diameter of the union -/\ntheorem Hausdorff_dist_le_diam (hs : s.nonempty) (bs : Bounded s) (ht : t.nonempty) (bt : Bounded t) :\n    hausdorffDist s t ≤ diam (s ∪ t) := by\n  rcases hs with ⟨x, xs⟩\n  rcases ht with ⟨y, yt⟩\n  refine' Hausdorff_dist_le_of_mem_dist diam_nonneg _ _\n  ·\n    exact fun z hz =>\n      ⟨y, yt, dist_le_diam_of_mem (bounded_union.2 ⟨bs, bt⟩) (subset_union_left _ _ hz) (subset_union_right _ _ yt)⟩\n  ·\n    exact fun z hz =>\n      ⟨x, xs, dist_le_diam_of_mem (bounded_union.2 ⟨bs, bt⟩) (subset_union_right _ _ hz) (subset_union_left _ _ xs)⟩\n#align Hausdorff_dist_le_diam Hausdorff_dist_le_diam\n\n",
 "Hausdorff_dist_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The Hausdorff distance is invariant under isometries -/\ntheorem Hausdorff_dist_image (h : Isometry Φ) : hausdorffDist («expr '' » Φ s) («expr '' » Φ t) = hausdorffDist s t :=\n  by simp [Hausdorff_dist, Hausdorff_edist_image h]\n#align Hausdorff_dist_image Hausdorff_dist_image\n\n",
 "Hausdorff_dist_empty'":
 "/-- The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable\nvalue ∞ instead, use `Hausdorff_edist`, which takes values in ℝ≥0∞) -/\n@[simp]\ntheorem Hausdorff_dist_empty' : hausdorffDist ∅ s = 0 := by simp [Hausdorff_dist_comm]\n#align Hausdorff_dist_empty' Hausdorff_dist_empty'\n\n",
 "Hausdorff_dist_empty":
 "/-- The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable\nvalue ∞ instead, use `Hausdorff_edist`, which takes values in ℝ≥0∞) -/\n@[simp]\ntheorem Hausdorff_dist_empty : hausdorffDist s ∅ = 0 :=\n  by\n  cases' s.eq_empty_or_nonempty with h h\n  · simp [h]\n  · simp [Hausdorff_dist, Hausdorff_edist_empty h]\n#align Hausdorff_dist_empty Hausdorff_dist_empty\n\n",
 "Hausdorff_dist_comm":
 "/-- The Hausdorff distance from `s` to `t` and from `t` to `s` coincide -/\ntheorem Hausdorff_dist_comm : hausdorffDist s t = hausdorffDist t s := by simp [Hausdorff_dist, Hausdorff_edist_comm]\n#align Hausdorff_dist_comm Hausdorff_dist_comm\n\n",
 "Hausdorff_dist_closure₂":
 "/-- Replacing a set by its closure does not change the Hausdorff distance. -/\n@[simp]\ntheorem Hausdorff_dist_closure₂ : hausdorffDist s (closure t) = hausdorffDist s t := by simp [Hausdorff_dist]\n#align Hausdorff_dist_closure₂ Hausdorff_dist_closure₂\n\n",
 "Hausdorff_dist_closure₁":
 "/-- Replacing a set by its closure does not change the Hausdorff distance. -/\n@[simp]\ntheorem Hausdorff_dist_closure₁ : hausdorffDist (closure s) t = hausdorffDist s t := by simp [Hausdorff_dist]\n#align Hausdorff_dist_closure₁ Hausdorff_dist_closure₁\n\n",
 "Hausdorff_dist_closure":
 "/-- The Hausdorff distance between two sets and their closures coincide -/\n@[simp]\ntheorem Hausdorff_dist_closure : hausdorffDist (closure s) (closure t) = hausdorffDist s t := by simp [Hausdorff_dist]\n#align Hausdorff_dist_closure Hausdorff_dist_closure\n\n"}