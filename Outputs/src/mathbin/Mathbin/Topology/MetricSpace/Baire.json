{"nonempty_interior_of_Union_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- One of the most useful consequences of Baire theorem: if a countable union of closed sets\ncovers the space, then one of the sets has nonempty interior. -/\ntheorem nonempty_interior_of_Union_of_closed [nonempty α] [Encodable β] {f : β → set α} (hc : ∀ s, is_closed (f s))\n    (hU :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f s) = univ) :\n    ∃ s, (interior <| f s).nonempty := by simpa using (dense_Union_interior_of_closed hc hU).nonempty\n#align nonempty_interior_of_Union_of_closed nonempty_interior_of_Union_of_closed\n\n",
 "mem_residual":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/-- A set is residual (comeagre) if and only if it includes a dense `Gδ` set. -/\ntheorem mem_residual {s : set α} : s ∈ residual α ↔ ∃ (t : _)(_ : t ⊆ s), is_Gδ t ∧ dense t :=\n  (@eventually_residual α _ _ fun x => x ∈ s).trans <|\n    exists_congr fun t => by rw [exists_prop, and_comm' (t ⊆ s), subset_def, and_assoc']\n#align mem_residual mem_residual\n\n",
 "inter_of_Gδ":
 "/-- Baire theorem: the intersection of two dense Gδ sets is dense. -/\ntheorem dense.inter_of_Gδ {s t : set α} (hs : is_Gδ s) (ht : is_Gδ t) (hsc : dense s) (htc : dense t) : dense (s ∩ t) :=\n  by\n  rw [inter_eq_Inter]\n  apply dense_Inter_of_Gδ <;> simp [bool.forall_bool, *]\n#align dense.inter_of_Gδ dense.inter_of_Gδ\n\n",
 "eventually_residual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- A property holds on a residual (comeagre) set if and only if it holds on some dense `Gδ` set. -/\ntheorem eventually_residual {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" (residual α)\n        (p x) ↔\n      ∃ t : set α, is_Gδ t ∧ dense t ∧ ∀ x ∈ t, p x :=\n  calc\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" (residual α)\n          (p x) ↔\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            ((filter.principal) t))\n          (p x) :=\n      by simp only [residual, infᵢ_and]\n    _ ↔\n        ∃ (t : set α)(ht : is_Gδ t ∧ dense t),\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n            ((filter.principal) t) (p x) :=\n      mem_binfi_of_directed\n        (fun t₁ h₁ t₂ h₂ => ⟨t₁ ∩ t₂, ⟨h₁.1.inter h₂.1, dense.inter_of_Gδ h₁.1 h₂.1 h₁.2 h₂.2⟩, by simp⟩)\n        ⟨univ, is_Gδ_univ, dense_univ⟩\n    _ ↔ _ := by simp [and_assoc']\n    \n#align eventually_residual eventually_residual\n\n",
 "dense_sUnion_interior_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with `⋃₀`. -/\ntheorem dense_sUnion_interior_of_closed {S : set (set α)} (hc : ∀ s ∈ S, is_closed s) (hS : S.countable)\n    (hU : ⋃₀ S = univ) :\n    dense\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (interior s)) :=\n  is_Gδ_univ.dense_sUnion_interior_of_closed dense_univ hS hc hU.ge\n#align dense_sUnion_interior_of_closed dense_sUnion_interior_of_closed\n\n",
 "dense_sInter_of_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/\ntheorem dense_sInter_of_open {S : set (set α)} (ho : ∀ s ∈ S, is_open s) (hS : S.countable) (hd : ∀ s ∈ S, dense s) :\n    dense («expr⋂₀ » S) := by\n  cases' S.eq_empty_or_nonempty with h h\n  · simp [h]\n  · rcases hS.exists_eq_range h with ⟨f, hf⟩\n    have F : ∀ n, f n ∈ S := fun n => by rw [hf] <;> exact mem_range_self _\n    rw [hf, sInter_range]\n    exact dense_Inter_of_open_nat (fun n => ho _ (F n)) fun n => hd _ (F n)\n#align dense_sInter_of_open dense_sInter_of_open\n\n",
 "dense_sInter_of_Gδ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/-- Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with ⋂₀. -/\ntheorem dense_sInter_of_Gδ {S : set (set α)} (ho : ∀ s ∈ S, is_Gδ s) (hS : S.countable) (hd : ∀ s ∈ S, dense s) :\n    dense («expr⋂₀ » S) :=\n  by\n  -- the result follows from the result for a countable intersection of dense open sets,\n  -- by rewriting each set as a countable intersection of open sets, which are of course dense.\n  choose T hTo hTc hsT using ho\n  have :\n    «expr⋂₀ » S =\n      «expr⋂₀ »\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (T s ‹_›)) :=\n    by-- := (sInter_bUnion (λs hs, (hT s hs).2.2)).symm,\n    simp only [sInter_Union, (hsT _ _).symm, ← sInter_eq_bInter]\n  rw [this]\n  refine' dense_sInter_of_open _ (hS.bUnion hTc) _ <;> simp only [mem_Union] <;> rintro t ⟨s, hs, tTs⟩\n  show is_open t\n  exact hTo s hs t tTs\n  show dense t\n  · intro x\n    have := hd s hs x\n    rw [hsT s hs] at this\n    exact closure_mono (sInter_subset_of_mem tTs) this\n#align dense_sInter_of_Gδ dense_sInter_of_Gδ\n\n",
 "dense_of_mem_residual":
 "theorem dense_of_mem_residual {s : set α} (hs : s ∈ residual α) : dense s :=\n  let ⟨t, hts, _, hd⟩ := mem_residual.1 hs\n  hd.mono hts\n#align dense_of_mem_residual dense_of_mem_residual\n\n",
 "dense_bUnion_interior_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is a countable set in any type. -/\ntheorem dense_bUnion_interior_of_closed {S : set β} {f : β → set α} (hc : ∀ s ∈ S, is_closed (f s)) (hS : S.countable)\n    (hU :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f s) = univ) :\n    dense\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (interior (f s))) :=\n  is_Gδ_univ.dense_bUnion_interior_of_closed dense_univ hS hc hU.ge\n#align dense_bUnion_interior_of_closed dense_bUnion_interior_of_closed\n\n",
 "dense_bInter_of_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem dense_bInter_of_open {S : set β} {f : β → set α} (ho : ∀ s ∈ S, is_open (f s)) (hS : S.countable)\n    (hd : ∀ s ∈ S, dense (f s)) :\n    dense («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f s)) :=\n  by\n  rw [← sInter_image]\n  apply dense_sInter_of_open\n  · rwa [ball_image_iff]\n  · exact hS.image _\n  · rwa [ball_image_iff]\n#align dense_bInter_of_open dense_bInter_of_open\n\n",
 "dense_bInter_of_Gδ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem dense_bInter_of_Gδ {S : set β} {f : ∀ x ∈ S, set α} (ho : ∀ s ∈ S, is_Gδ (f s ‹_›)) (hS : S.countable)\n    (hd : ∀ s ∈ S, dense (f s ‹_›)) :\n    dense («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f s ‹_›)) :=\n  by\n  rw [bInter_eq_Inter]\n  haveI := hS.to_encodable\n  exact dense_Inter_of_Gδ (fun s => ho s s.2) fun s => hd s s.2\n#align dense_bInter_of_Gδ dense_bInter_of_Gδ\n\n",
 "dense_Union_interior_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is an encodable type. -/\ntheorem dense_Union_interior_of_closed [Encodable β] {f : β → set α} (hc : ∀ s, is_closed (f s))\n    (hU :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f s) = univ) :\n    dense\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (interior (f s))) :=\n  is_Gδ_univ.dense_Union_interior_of_closed dense_univ hc hU.ge\n#align dense_Union_interior_of_closed dense_Union_interior_of_closed\n\n",
 "dense_Inter_of_open_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-\nCopyright (c) 2019 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n/- Translate the density assumption into two functions `center` and `radius` associating\n  to any n, x, δ, δpos a center and a positive radius such that\n  `closed_ball center radius` is included both in `f n` and in `closed_ball x δ`.\n  We can also require `radius ≤ (1/2)^(n+1)`, to ensure we get a Cauchy sequence later. -/\n/- `ε` is positive. We have to find a point in the ball of radius `ε` around `x` belonging to all\n  `f n`. For this, we construct inductively a sequence `F n = (c n, r n)` such that the closed ball\n  `closed_ball (c n) (r n)` is included in the previous ball and in `f n`, and such that\n  `r n` is small enough to ensure that `c n` is a Cauchy sequence. Then `c n` converges to a\n  limit which belongs to all the `f n`. -/\n-- as the sequence `c n` is Cauchy in a complete space, it converges to a limit `y`.\n-- this point `y` will be the desired point. We will check that it belongs to all\n-- `f n` and to `ball x ε`.\n/- To prove that an intersection of open dense subsets is dense, prove that its intersection\n  with any open neighbourhood `U` is dense. Define recursively a decreasing sequence `K` of\n  compact neighbourhoods: start with some compact neighbourhood inside `U`, then at each step,\n  take its interior, intersect with `f n`, then choose a compact neighbourhood inside the\n  intersection.-/\n-- This is a decreasing sequence of positive compacts contained in suitable open sets `f n`.\n-- Prove that ̀`⋂ n : ℕ, K n` is inside `U ∩ ⋂ n : ℕ, (f n)`. \n/- Prove that `⋂ n : ℕ, K n` is not empty, as an intersection of a decreasing sequence\n  of nonempty compact subsets.-/\n/-- Definition of a Baire space. -/\ntheorem dense_Inter_of_open_nat {f : ℕ → set α} (ho : ∀ n, is_open (f n)) (hd : ∀ n, dense (f n)) :\n    dense («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f n)) :=\n  baire_space.baire_property f ho hd\n#align dense_Inter_of_open_nat dense_Inter_of_open_nat\n\n",
 "dense_Inter_of_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is an encodable type. -/\ntheorem dense_Inter_of_open [Encodable β] {f : β → set α} (ho : ∀ s, is_open (f s)) (hd : ∀ s, dense (f s)) :\n    dense («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f s)) :=\n  by\n  rw [← sInter_range]\n  apply dense_sInter_of_open\n  · rwa [forall_range_iff]\n  · exact countable_range _\n  · rwa [forall_range_iff]\n#align dense_Inter_of_open dense_Inter_of_open\n\n",
 "dense_Inter_of_Gδ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with\nan index set which is an encodable type. -/\ntheorem dense_Inter_of_Gδ [Encodable β] {f : β → set α} (ho : ∀ s, is_Gδ (f s)) (hd : ∀ s, dense (f s)) :\n    dense («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f s)) :=\n  by\n  rw [← sInter_range]\n  exact dense_sInter_of_Gδ (forall_range_iff.2 ‹_›) (countable_range _) (forall_range_iff.2 ‹_›)\n#align dense_Inter_of_Gδ dense_Inter_of_Gδ\n\n"}