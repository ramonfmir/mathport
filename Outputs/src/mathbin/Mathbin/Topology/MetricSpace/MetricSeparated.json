{"union_right_iff":
 "@[simp]\ntheorem union_right_iff {t'} : is_metric_separated s (t ∪ t') ↔ is_metric_separated s t ∧ is_metric_separated s t' :=\n  comm.trans <| union_left_iff.trans <| and_congr comm comm\n#align union_right_iff union_right_iff\n\n",
 "union_right":
 "theorem union_right {t'} (h : is_metric_separated s t) (h' : is_metric_separated s t') :\n    is_metric_separated s (t ∪ t') :=\n  (h.symm.union_left h'.symm).symm\n#align union_right union_right\n\n",
 "union_left_iff":
 "@[simp]\ntheorem union_left_iff {s'} : is_metric_separated (s ∪ s') t ↔ is_metric_separated s t ∧ is_metric_separated s' t :=\n  ⟨fun h => ⟨h.mono_left (subset_union_left _ _), h.mono_left (subset_union_right _ _)⟩, fun h => h.1.union_left h.2⟩\n#align union_left_iff union_left_iff\n\n",
 "union_left":
 "theorem union_left {s'} (h : is_metric_separated s t) (h' : is_metric_separated s' t) :\n    is_metric_separated (s ∪ s') t :=\n  by\n  rcases h, h' with ⟨⟨r, r0, hr⟩, ⟨r', r0', hr'⟩⟩\n  refine' ⟨min r r', _, fun x hx y hy => hx.elim _ _⟩\n  · rw [← pos_iff_ne_zero] at r0 r0'⊢\n    exact lt_min r0 r0'\n  · exact fun hx => (min_le_left _ _).trans (hr _ hx _ hy)\n  · exact fun hx => (min_le_right _ _).trans (hr' _ hx _ hy)\n#align union_left union_left\n\n",
 "symm":
 "#print symm /-\n/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\n@[symm]\ntheorem symm (h : is_metric_separated s t) : is_metric_separated t s :=\n  let ⟨r, r0, hr⟩ := h\n  ⟨r, r0, fun y hy x hx => edist_comm x y ▸ hr x hx y hy⟩\n#align symm symm\n-/\n\n",
 "subset_compl_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem subset_compl_right (h : is_metric_separated s t) : s ⊆ «expr ᶜ» t := fun x hs ht => h.disjoint.le_bot ⟨hs, ht⟩\n#align subset_compl_right subset_compl_right\n\n",
 "mono_right":
 "theorem mono_right {t'} (h' : is_metric_separated s t') (ht : t ⊆ t') : is_metric_separated s t :=\n  h'.mono Subset.rfl ht\n#align mono_right mono_right\n\n",
 "mono_left":
 "theorem mono_left {s'} (h' : is_metric_separated s' t) (hs : s ⊆ s') : is_metric_separated s t :=\n  h'.mono hs Subset.rfl\n#align mono_left mono_left\n\n",
 "mono":
 "@[mono]\ntheorem mono {s' t'} (hs : s ⊆ s') (ht : t ⊆ t') : is_metric_separated s' t' → is_metric_separated s t :=\n  fun ⟨r, r0, hr⟩ => ⟨r, r0, fun x hx y hy => hr x (hs hx) y (ht hy)⟩\n#align mono mono\n\n",
 "finset_Union_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem finset_Union_right_iff {ι : Type _} {I : Finset ι} {s : set X} {t : ι → set X} :\n    is_metric_separated s\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i)) ↔\n      ∀ i ∈ I, is_metric_separated s (t i) :=\n  finite_Union_right_iff I.finite_to_set\n#align finset_Union_right_iff finset_Union_right_iff\n\n",
 "finset_Union_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem finset_Union_left_iff {ι : Type _} {I : Finset ι} {s : ι → set X} {t : set X} :\n    is_metric_separated\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) t ↔\n      ∀ i ∈ I, is_metric_separated (s i) t :=\n  finite_Union_left_iff I.finite_to_set\n#align finset_Union_left_iff finset_Union_left_iff\n\n",
 "finite_Union_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem finite_Union_right_iff {ι : Type _} {I : set ι} (hI : I.finite) {s : set X} {t : ι → set X} :\n    is_metric_separated s\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i)) ↔\n      ∀ i ∈ I, is_metric_separated s (t i) :=\n  by simpa only [@comm _ _ s] using finite_Union_left_iff hI\n#align finite_Union_right_iff finite_Union_right_iff\n\n",
 "finite_Union_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem finite_Union_left_iff {ι : Type _} {I : set ι} (hI : I.finite) {s : ι → set X} {t : set X} :\n    is_metric_separated\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) t ↔\n      ∀ i ∈ I, is_metric_separated (s i) t :=\n  by\n  refine' finite.induction_on hI (by simp) fun i I hi _ hI => _\n  rw [bUnion_insert, ball_insert_iff, union_left_iff, hI]\n#align finite_Union_left_iff finite_Union_left_iff\n\n",
 "empty_right":
 "@[simp]\ntheorem empty_right (s : set X) : is_metric_separated s ∅ :=\n  (empty_left s).symm\n#align empty_right empty_right\n\n",
 "empty_left":
 "@[simp]\ntheorem empty_left (s : set X) : is_metric_separated ∅ s :=\n  ⟨1, ennreal.zero_lt_one.ne', fun x => false.elim⟩\n#align empty_left empty_left\n\n",
 "comm":
 "#print comm /-\ntheorem comm : is_metric_separated s t ↔ is_metric_separated t s :=\n  ⟨symm, symm⟩\n#align comm comm\n-/\n\n",
 "Disjoint":
 "#print Disjoint /-\nprotected theorem Disjoint (h : is_metric_separated s t) : Disjoint s t :=\n  let ⟨r, r0, hr⟩ := h\n  Set.disjoint_left.mpr fun x hx1 hx2 => r0 <| by simpa using hr x hx1 x hx2\n#align disjoint Disjoint\n-/\n\n"}