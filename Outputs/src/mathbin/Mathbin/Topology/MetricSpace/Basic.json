{"zero_eq_nndist":
 "@[simp]\ntheorem zero_eq_nndist {x y : γ} : 0 = nndist x y ↔ x = y := by\n  simp only [← nnreal.eq_iff, ← dist_nndist, imp_self, nnreal.coe_zero, zero_eq_dist]\n#align zero_eq_nndist zero_eq_nndist\n\n",
 "zero_eq_dist":
 "@[simp]\ntheorem zero_eq_dist {x y : γ} : 0 = dist x y ↔ x = y := by rw [eq_comm, dist_eq_zero]\n#align zero_eq_dist zero_eq_dist\n\n",
 "union":
 "/-- The union of two bounded sets is bounded. -/\ntheorem bounded.union (hs : bounded s) (ht : bounded t) : bounded (s ∪ t) :=\n  by\n  refine' bounded_iff_mem_bounded.2 fun x _ => _\n  rw [bounded_iff_subset_ball x] at hs ht⊢\n  rcases hs with ⟨Cs, hCs⟩; rcases ht with ⟨Ct, hCt⟩\n  exact\n    ⟨max Cs Ct,\n      union_subset (subset.trans hCs <| closed_ball_subset_closed_ball <| le_max_left _ _)\n        (subset.trans hCt <| closed_ball_subset_closed_ball <| le_max_right _ _)⟩\n#align bounded.union bounded.union\n\n",
 "uniformity_eq_comap_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem metric.uniformity_eq_comap_nhds_zero :\n    (uniformity) α = comap (fun p : α × α => dist p.1 p.2) ((nhds) (0 : exprℝ)) :=\n  by\n  ext s\n  simp [mem_uniformity_dist, (nhds_basis_ball.comap _).mem_iff, subset_def, real.dist_0_eq_abs]\n#align metric.uniformity_eq_comap_nhds_zero metric.uniformity_eq_comap_nhds_zero\n\n",
 "uniformity_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem metric.uniformity_edist :\n    (uniformity) α =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) { p : α × α | edist p.1 p.2 < ε }) :=\n  pseudo_metric.uniformity_basis_edist.eq_binfi\n#align metric.uniformity_edist metric.uniformity_edist\n\n",
 "uniformity_basis_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-Instantiate a pseudometric space as a pseudoemetric space. Before we can state the instance,\nwe need to show that the uniform structure coming from the edistance and the\ndistance coincide. -/\n/-- Expressing the uniformity in terms of `edist` -/\nprotected theorem pseudo_metric.uniformity_basis_edist :\n    ((uniformity) α).has_basis (fun ε : ennreal => 0 < ε) fun ε => { p | edist p.1 p.2 < ε } :=\n  ⟨by\n    intro t\n    refine' mem_uniformity_dist.trans ⟨_, _⟩ <;> rintro ⟨ε, ε0, Hε⟩\n    · use ennreal.of_real ε, ennreal.of_real_pos.2 ε0\n      rintro ⟨a, b⟩\n      simp only [edist_dist, ennreal.of_real_lt_of_real_iff ε0]\n      exact Hε\n    · rcases ennreal.lt_iff_exists_real_btwn.1 ε0 with ⟨ε', _, ε0', hε⟩\n      rw [ennreal.of_real_pos] at ε0'\n      refine' ⟨ε', ε0', fun a b h => Hε (lt_trans _ hε)⟩\n      rwa [edist_dist, ennreal.of_real_lt_of_real_iff ε0']⟩\n#align pseudo_metric.uniformity_basis_edist pseudo_metric.uniformity_basis_edist\n\n",
 "uniformity_basis_dist_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_basis_dist_pow {r : exprℝ} (h0 : 0 < r) (h1 : r < 1) :\n    ((uniformity) α).has_basis (fun n : ℕ => true) fun n : ℕ => { p : α × α | dist p.1 p.2 < r ^ n } :=\n  metric.mk_uniformity_basis (fun n hn => pow_pos h0 _) fun ε ε0 =>\n    let ⟨n, hn⟩ := exists_pow_lt_of_lt_one ε0 h1\n    ⟨n, trivial, hn.le⟩\n#align uniformity_basis_dist_pow uniformity_basis_dist_pow\n\n",
 "uniformity_basis_dist_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem uniformity_basis_dist_lt {R : exprℝ} (hR : 0 < R) :\n    ((uniformity) α).has_basis (fun r : exprℝ => 0 < r ∧ r < R) fun r => { p : α × α | dist p.1 p.2 < r } :=\n  metric.mk_uniformity_basis (fun r => And.left) fun r hr =>\n    ⟨min r (R / 2), ⟨lt_min hr (half_pos hR), min_lt_iff.2 <| or.inr (half_lt_self hR)⟩, min_le_left _ _⟩\n#align uniformity_basis_dist_lt uniformity_basis_dist_lt\n\n",
 "uniformity_basis_dist_le_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_basis_dist_le_pow {r : exprℝ} (h0 : 0 < r) (h1 : r < 1) :\n    ((uniformity) α).has_basis (fun n : ℕ => true) fun n : ℕ => { p : α × α | dist p.1 p.2 ≤ r ^ n } :=\n  metric.mk_uniformity_basis_le (fun n hn => pow_pos h0 _) fun ε ε0 =>\n    let ⟨n, hn⟩ := exists_pow_lt_of_lt_one ε0 h1\n    ⟨n, trivial, hn.le⟩\n#align uniformity_basis_dist_le_pow uniformity_basis_dist_le_pow\n\n",
 "uniformity_basis_dist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Contant size closed neighborhoods of the diagonal form a basis\nof the uniformity filter. -/\ntheorem uniformity_basis_dist_le :\n    ((uniformity) α).has_basis (fun ε : exprℝ => 0 < ε) fun ε => { p : α × α | dist p.1 p.2 ≤ ε } :=\n  metric.mk_uniformity_basis_le (fun _ => id) fun ε ε₀ => ⟨ε, ε₀, le_refl ε⟩\n#align uniformity_basis_dist_le uniformity_basis_dist_le\n\n",
 "uniformity_basis_dist_inv_nat_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_basis_dist_inv_nat_succ :\n    ((uniformity) α).has_basis (fun _ => true) fun n : ℕ => { p : α × α | dist p.1 p.2 < 1 / (↑n + 1) } :=\n  metric.mk_uniformity_basis (fun n _ => div_pos zero_lt_one <| nat.cast_add_one_pos n) fun ε ε0 =>\n    (exists_nat_one_div_lt ε0).imp fun n hn => ⟨trivial, le_of_lt hn⟩\n#align uniformity_basis_dist_inv_nat_succ uniformity_basis_dist_inv_nat_succ\n\n",
 "uniformity_basis_dist_inv_nat_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_basis_dist_inv_nat_pos :\n    ((uniformity) α).has_basis (fun n : ℕ => 0 < n) fun n : ℕ => { p : α × α | dist p.1 p.2 < 1 / ↑n } :=\n  metric.mk_uniformity_basis (fun n hn => div_pos zero_lt_one <| nat.cast_pos.2 hn) fun ε ε0 =>\n    let ⟨n, hn⟩ := exists_nat_one_div_lt ε0\n    ⟨n + 1, nat.succ_pos n, by exact_mod_cast hn.le⟩\n#align uniformity_basis_dist_inv_nat_pos uniformity_basis_dist_inv_nat_pos\n\n",
 "uniformity_basis_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem uniformity_basis_dist :\n    ((uniformity) α).has_basis (fun ε : exprℝ => 0 < ε) fun ε => { p : α × α | dist p.1 p.2 < ε } :=\n  by\n  rw [← pseudo_metric_space.uniformity_dist.symm]\n  refine' has_basis_binfi_principal _ nonempty_Ioi\n  exact fun r (hr : 0 < r) p (hp : 0 < p) =>\n    ⟨min r p, lt_min hr hp, fun x (hx : dist _ _ < _) => lt_of_lt_of_le hx (min_le_left r p),\n      fun x (hx : dist _ _ < _) => lt_of_lt_of_le hx (min_le_right r p)⟩\n#align uniformity_basis_dist uniformity_basis_dist\n\n",
 "uniform_embedding_iff'":
 "/-- A map between metric spaces is a uniform embedding if and only if the distance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y` and conversely. -/\ntheorem uniform_embedding_iff' [metric_space β] {f : γ → β} :\n    uniform_embedding f ↔\n      (∀ ε > 0, ∃ δ > 0, ∀ {a b : γ}, dist a b < δ → dist (f a) (f b) < ε) ∧\n        ∀ δ > 0, ∃ ε > 0, ∀ {a b : γ}, dist (f a) (f b) < ε → dist a b < δ :=\n  by\n  constructor\n  · intro h\n    exact ⟨uniform_continuous_iff.1 (uniform_embedding_iff.1 h).2.1, (uniform_embedding_iff.1 h).2.2⟩\n  · rintro ⟨h₁, h₂⟩\n    refine' uniform_embedding_iff.2 ⟨_, uniform_continuous_iff.2 h₁, h₂⟩\n    intro x y hxy\n    have : dist x y ≤ 0 := by\n      refine' le_of_forall_lt' fun δ δpos => _\n      rcases h₂ δ δpos with ⟨ε, εpos, hε⟩\n      have : dist (f x) (f y) < ε := by simpa [hxy]\n      exact hε this\n    simpa using this\n#align uniform_embedding_iff' uniform_embedding_iff'\n\n",
 "uniform_embedding_iff":
 "theorem uniform_embedding_iff [pseudo_metric_space β] {f : α → β} :\n    uniform_embedding f ↔\n      function.injective f ∧\n        uniform_continuous f ∧ ∀ δ > 0, ∃ ε > 0, ∀ {a b : α}, dist (f a) (f b) < ε → dist a b < δ :=\n  uniform_embedding_def'.trans <|\n    and_congr iff.rfl <|\n      and_congr iff.rfl\n        ⟨fun H δ δ0 =>\n          let ⟨t, tu, ht⟩ := H _ (dist_mem_uniformity δ0)\n          let ⟨ε, ε0, hε⟩ := mem_uniformity_dist.1 tu\n          ⟨ε, ε0, fun a b h => ht _ _ (hε h)⟩,\n          fun H s su =>\n          let ⟨δ, δ0, hδ⟩ := mem_uniformity_dist.1 su\n          let ⟨ε, ε0, hε⟩ := H _ δ0\n          ⟨_, dist_mem_uniformity ε0, fun a b h => hδ (hε h)⟩⟩\n#align uniform_embedding_iff uniform_embedding_iff\n\n",
 "uniform_embedding_bot_of_pairwise_le_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- If `f : β → α` sends any two distinct points to points at distance at least `ε > 0`, then\n`f` is a uniform embedding with respect to the discrete uniformity on `β`. -/\ntheorem uniform_embedding_bot_of_pairwise_le_dist {β : Type _} {ε : exprℝ} (hε : 0 < ε) {f : β → α}\n    (hf : Pairwise fun x y => ε ≤ dist (f x) (f y)) : @uniform_embedding _ _ («expr⊥») (by infer_instance) f :=\n  uniform_embedding_of_spaced_out (dist_mem_uniformity hε) <| by simpa using hf\n#align uniform_embedding_bot_of_pairwise_le_dist uniform_embedding_bot_of_pairwise_le_dist\n\n",
 "uniform_continuous_on_iff_le":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x y «expr ∈ » s) -/\ntheorem uniform_continuous_on_iff_le [pseudo_metric_space β] {f : α → β} {s : set α} :\n    uniform_continuous_on f s ↔\n      ∀ ε > 0, ∃ δ > 0, ∀ (x) (_ : x ∈ s) (y) (_ : y ∈ s), dist x y ≤ δ → dist (f x) (f y) ≤ ε :=\n  metric.uniformity_basis_dist_le.uniform_continuous_on_iff metric.uniformity_basis_dist_le\n#align uniform_continuous_on_iff_le uniform_continuous_on_iff_le\n\n",
 "uniform_continuous_on_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x y «expr ∈ » s) -/\ntheorem uniform_continuous_on_iff [pseudo_metric_space β] {f : α → β} {s : set α} :\n    uniform_continuous_on f s ↔\n      ∀ ε > 0, ∃ δ > 0, ∀ (x) (_ : x ∈ s) (y) (_ : y ∈ s), dist x y < δ → dist (f x) (f y) < ε :=\n  metric.uniformity_basis_dist.uniform_continuous_on_iff metric.uniformity_basis_dist\n#align uniform_continuous_on_iff uniform_continuous_on_iff\n\n",
 "uniform_continuous_nndist":
 "theorem uniform_continuous_nndist : uniform_continuous fun p : α × α => nndist p.1 p.2 :=\n  uniform_continuous_dist.subtype_mk _\n#align uniform_continuous_nndist uniform_continuous_nndist\n\n",
 "uniform_continuous_iff":
 "theorem uniform_continuous_iff [pseudo_metric_space β] {f : α → β} :\n    uniform_continuous f ↔ ∀ ε > 0, ∃ δ > 0, ∀ {a b : α}, dist a b < δ → dist (f a) (f b) < ε :=\n  uniformity_basis_dist.uniform_continuous_iff uniformity_basis_dist\n#align uniform_continuous_iff uniform_continuous_iff\n\n",
 "uniform_continuous_dist":
 "theorem uniform_continuous_dist : uniform_continuous fun p : α × α => dist p.1 p.2 :=\n  metric.uniform_continuous_iff.2 fun ε ε0 =>\n    ⟨ε / 2, half_pos ε0, by\n      suffices\n      · intro p q h\n        cases' p with p₁ p₂\n        cases' q with q₁ q₂\n        cases' max_lt_iff.1 h with h₁ h₂\n        clear h\n        dsimp at h₁ h₂⊢\n        rw [real.dist_eq]\n        refine' abs_sub_lt_iff.2 ⟨_, _⟩\n        · revert p₁ p₂ q₁ q₂ h₁ h₂\n          exact this\n        · apply this <;> rwa [dist_comm]\n      intro p₁ p₂ q₁ q₂ h₁ h₂\n      have :=\n        add_lt_add (abs_sub_lt_iff.1 (lt_of_le_of_lt (abs_dist_sub_le p₁ q₁ p₂) h₁)).1\n          (abs_sub_lt_iff.1 (lt_of_le_of_lt (abs_dist_sub_le p₂ q₂ q₁) h₂)).1\n      rwa [add_halves, dist_comm p₂, sub_add_sub_cancel, dist_comm q₂] at this⟩\n#align uniform_continuous_dist uniform_continuous_dist\n\n",
 "uniform_cauchy_seq_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n-- see Note [nolint_ge]\n/-- In a pseudometric space, unifom Cauchy sequences are characterized by the fact that, eventually,\nthe distance between all its elements is uniformly, arbitrarily small -/\n@[nolint ge_or_gt]\ntheorem metric.uniform_cauchy_seq_on_iff {γ : Type _} {F : β → γ → α} {s : set γ} :\n    uniform_cauchy_seq_on F at_top s ↔\n      ∀ ε : exprℝ, ε > 0 → ∃ N : β, ∀ m : β, m ≥ N → ∀ n : β, n ≥ N → ∀ x : γ, x ∈ s → dist (F m x) (F n x) < ε :=\n  by\n  constructor\n  · intro h ε hε\n    let u := { a : α × α | dist a.fst a.snd < ε }\n    have hu : u ∈ (uniformity) α := metric.mem_uniformity_dist.mpr ⟨ε, hε, fun a b => by simp⟩\n    rw [← @filter.eventually_at_top_prod_self' _ _ _ fun m => ∀ x : γ, x ∈ s → dist (F m.fst x) (F m.snd x) < ε]\n    specialize h u hu\n    rw [prod_at_top_at_top_eq] at h\n    exact h.mono fun n h x hx => set.mem_set_of_eq.mp (h x hx)\n  · intro h u hu\n    rcases metric.mem_uniformity_dist.mp hu with ⟨ε, hε, hab⟩\n    rcases h ε hε with ⟨N, hN⟩\n    rw [prod_at_top_at_top_eq, eventually_at_top]\n    use (N, N)\n    intro b hb x hx\n    rcases hb with ⟨hbl, hbr⟩\n    exact hab (hN b.fst hbl.ge b.snd hbr.ge x hx)\n#align metric.uniform_cauchy_seq_on_iff metric.uniform_cauchy_seq_on_iff\n\n",
 "totally_bounded_of_finite_discretization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A pseudometric space is totally bounded if one can reconstruct up to any ε>0 any element of the\nspace from finitely many data. -/\ntheorem totally_bounded_of_finite_discretization {s : set α}\n    (H : ∀ ε > (0 : exprℝ), ∃ (β : Type u)(_ : fintype β)(F : s → β), ∀ x y, F x = F y → dist (x : α) y < ε) :\n    totally_bounded s := by\n  cases' s.eq_empty_or_nonempty with hs hs\n  · rw [hs]\n    exact totally_bounded_empty\n  rcases hs with ⟨x0, hx0⟩\n  haveI : inhabited s := ⟨⟨x0, hx0⟩⟩\n  refine' totally_bounded_iff.2 fun ε ε0 => _\n  rcases H ε ε0 with ⟨β, fβ, F, hF⟩\n  skip\n  let Finv := function.inv_fun F\n  refine' ⟨range (subtype.val ∘ Finv), finite_range _, fun x xs => _⟩\n  let x' := Finv (F ⟨x, xs⟩)\n  have : F x' = F ⟨x, xs⟩ := Function.invFun_eq ⟨⟨x, xs⟩, rfl⟩\n  simp only [Set.mem_unionᵢ, Set.mem_range]\n  exact ⟨_, ⟨F ⟨x, xs⟩, rfl⟩, hF _ _ this.symm⟩\n#align totally_bounded_of_finite_discretization totally_bounded_of_finite_discretization\n\n",
 "totally_bounded_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem totally_bounded_iff {s : set α} :\n    totally_bounded s ↔\n      ∀ ε > 0,\n        ∃ t : set α,\n          t.finite ∧\n            s ⊆\n              «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                (ball y ε) :=\n  ⟨fun H ε ε0 => H _ (dist_mem_uniformity ε0), fun H r ru =>\n    let ⟨ε, ε0, hε⟩ := mem_uniformity_dist.1 ru\n    let ⟨t, ft, h⟩ := H ε ε0\n    ⟨t, ft, h.trans <| Union₂_mono fun y yt z => hε⟩⟩\n#align totally_bounded_iff totally_bounded_iff\n\n",
 "totally_bounded_Ioo":
 "theorem totally_bounded_Ioo (a b : α) : totally_bounded (Ioo a b) :=\n  totally_bounded_subset Ioo_subset_Icc_self (totally_bounded_Icc a b)\n#align totally_bounded_Ioo totally_bounded_Ioo\n\n",
 "totally_bounded_Ioc":
 "theorem totally_bounded_Ioc (a b : α) : totally_bounded (Ioc a b) :=\n  totally_bounded_subset Ioc_subset_Icc_self (totally_bounded_Icc a b)\n#align totally_bounded_Ioc totally_bounded_Ioc\n\n",
 "totally_bounded_Ico":
 "theorem totally_bounded_Ico (a b : α) : totally_bounded (Ico a b) :=\n  totally_bounded_subset Ico_subset_Icc_self (totally_bounded_Icc a b)\n#align totally_bounded_Ico totally_bounded_Ico\n\n",
 "totally_bounded_Icc":
 "theorem totally_bounded_Icc (a b : α) : totally_bounded (Icc a b) :=\n  is_compact_Icc.totally_bounded\n#align totally_bounded_Icc totally_bounded_Icc\n\n",
 "tendsto_uniformly_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- Expressing uniform convergence on a set using `dist`. -/\ntheorem tendsto_uniformly_on_iff {ι : Type _} {F : ι → β → α} {f : β → α} {p : filter ι} {s : set β} :\n    tendsto_uniformly_on F f p s ↔\n      ∀ ε > 0,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n          (∀ x ∈ s, dist (f x) (F n x) < ε) :=\n  by\n  refine' ⟨fun H ε hε => H _ (dist_mem_uniformity hε), fun H u hu => _⟩\n  rcases mem_uniformity_dist.1 hu with ⟨ε, εpos, hε⟩\n  exact (H ε εpos).mono fun n hs x hx => hε (hs x hx)\n#align tendsto_uniformly_on_iff tendsto_uniformly_on_iff\n\n",
 "tendsto_uniformly_on_filter_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/-- Expressing uniform convergence using `dist` -/\ntheorem tendsto_uniformly_on_filter_iff {ι : Type _} {F : ι → β → α} {f : β → α} {p : filter ι} {p' : filter β} :\n    tendsto_uniformly_on_filter F f p p' ↔\n      ∀ ε > 0,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          (filter.prod p p') (dist (f n.snd) (F n.fst n.snd) < ε) :=\n  by\n  refine' ⟨fun H ε hε => H _ (dist_mem_uniformity hε), fun H u hu => _⟩\n  rcases mem_uniformity_dist.1 hu with ⟨ε, εpos, hε⟩\n  refine' (H ε εpos).mono fun n hn => hε hn\n#align tendsto_uniformly_on_filter_iff tendsto_uniformly_on_filter_iff\n\n",
 "tendsto_uniformly_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- Expressing uniform convergence using `dist`. -/\ntheorem tendsto_uniformly_iff {ι : Type _} {F : ι → β → α} {f : β → α} {p : filter ι} :\n    tendsto_uniformly F f p ↔\n      ∀ ε > 0,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n          (∀ x, dist (f x) (F n x) < ε) :=\n  by\n  rw [← tendsto_uniformly_on_univ, tendsto_uniformly_on_iff]\n  simp\n#align tendsto_uniformly_iff tendsto_uniformly_iff\n\n",
 "tendsto_uniformity_iff_dist_tendsto_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_uniformity_iff_dist_tendsto_zero {ι : Type _} {f : ι → α × α} {p : filter ι} :\n    tendsto f p ((uniformity) α) ↔ tendsto (fun x => dist (f x).1 (f x).2) p ((nhds) 0) := by\n  rw [metric.uniformity_eq_comap_nhds_zero, tendsto_comap_iff]\n#align tendsto_uniformity_iff_dist_tendsto_zero tendsto_uniformity_iff_dist_tendsto_zero\n\n",
 "tendsto_nhds_within_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem tendsto_nhds_within_nhds_within [pseudo_metric_space β] {t : set β} {f : α → β} {a b} :\n    tendsto f (nhds_within s a) (nhds_within t b) ↔\n      ∀ ε > 0, ∃ δ > 0, ∀ {x : α}, x ∈ s → dist x a < δ → f x ∈ t ∧ dist (f x) b < ε :=\n  (nhds_within_basis_ball.tendsto_iff nhds_within_basis_ball).trans <|\n    forall₂_congr fun ε hε => exists₂_congr fun δ hδ => forall_congr' fun x => by simp <;> itauto\n#align tendsto_nhds_within_nhds_within tendsto_nhds_within_nhds_within\n\n",
 "tendsto_nhds_within_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_nhds_within_nhds [pseudo_metric_space β] {f : α → β} {a b} :\n    tendsto f (nhds_within s a) ((nhds) b) ↔ ∀ ε > 0, ∃ δ > 0, ∀ {x : α}, x ∈ s → dist x a < δ → dist (f x) b < ε :=\n  by\n  rw [← nhds_within_univ b, tendsto_nhds_within_nhds_within]\n  simp only [mem_univ, true_and_iff]\n#align tendsto_nhds_within_nhds tendsto_nhds_within_nhds\n\n",
 "tendsto_nhds_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_nhds_nhds [pseudo_metric_space β] {f : α → β} {a b} :\n    tendsto f ((nhds) a) ((nhds) b) ↔ ∀ ε > 0, ∃ δ > 0, ∀ {x : α}, dist x a < δ → dist (f x) b < ε :=\n  nhds_basis_ball.tendsto_iff nhds_basis_ball\n#align tendsto_nhds_nhds tendsto_nhds_nhds\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_nhds {f : filter β} {u : β → α} {a : α} :\n    tendsto u f ((nhds) a) ↔\n      ∀ ε > 0,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n          (dist (u x) a < ε) :=\n  nhds_basis_ball.tendsto_right_iff\n#align tendsto_nhds tendsto_nhds\n\n",
 "tendsto_locally_uniformly_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- Expressing locally uniform convergence on a set using `dist`. -/\ntheorem tendsto_locally_uniformly_on_iff {ι : Type _} [topological_space β] {F : ι → β → α} {f : β → α} {p : filter ι}\n    {s : set β} :\n    tendsto_locally_uniformly_on F f p s ↔\n      ∀ ε > 0,\n        ∀ x ∈ s,\n          ∃ t ∈ nhds_within s x,\n            «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n              (∀ y ∈ t, dist (f y) (F n y) < ε) :=\n  by\n  refine' ⟨fun H ε hε => H _ (dist_mem_uniformity hε), fun H u hu x hx => _⟩\n  rcases mem_uniformity_dist.1 hu with ⟨ε, εpos, hε⟩\n  rcases H ε εpos x hx with ⟨t, ht, Ht⟩\n  exact ⟨t, ht, Ht.mono fun n hs x hx => hε (hs x hx)⟩\n#align tendsto_locally_uniformly_on_iff tendsto_locally_uniformly_on_iff\n\n",
 "tendsto_locally_uniformly_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- Expressing locally uniform convergence using `dist`. -/\ntheorem tendsto_locally_uniformly_iff {ι : Type _} [topological_space β] {F : ι → β → α} {f : β → α} {p : filter ι} :\n    tendsto_locally_uniformly F f p ↔\n      ∀ ε > 0,\n        ∀ x : β,\n          ∃ t ∈ (nhds) x,\n            «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n              (∀ y ∈ t, dist (f y) (F n y) < ε) :=\n  by\n  simp only [← tendsto_locally_uniformly_on_univ, tendsto_locally_uniformly_on_iff, nhds_within_univ, mem_univ,\n    forall_const, exists_prop]\n#align tendsto_locally_uniformly_iff tendsto_locally_uniformly_iff\n\n",
 "tendsto_iff_of_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_iff_of_dist {ι : Type _} {f₁ f₂ : ι → α} {p : filter ι} {a : α}\n    (h : tendsto (fun x => dist (f₁ x) (f₂ x)) p ((nhds) 0)) : tendsto f₁ p ((nhds) a) ↔ tendsto f₂ p ((nhds) a) :=\n  uniform.tendsto_congr <| tendsto_uniformity_iff_dist_tendsto_zero.2 h\n#align tendsto_iff_of_dist tendsto_iff_of_dist\n\n",
 "tendsto_iff_dist_tendsto_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_iff_dist_tendsto_zero {f : β → α} {x : filter β} {a : α} :\n    tendsto f x ((nhds) a) ↔ tendsto (fun b => dist (f b) a) x ((nhds) 0) := by\n  rw [← nhds_comap_dist a, tendsto_comap_iff]\n#align tendsto_iff_dist_tendsto_zero tendsto_iff_dist_tendsto_zero\n\n",
 "tendsto_dist_right_cocompact_at_top":
 "-- see Note [lower instance priority]\n-- We already have `sigma_compact_space_of_locally_compact_second_countable`, so we don't\n-- add an instance for `sigma_compact_space`.\ntheorem tendsto_dist_right_cocompact_at_top [proper_space α] (x : α) :\n    tendsto (fun y => dist y x) (cocompact α) at_top :=\n  (has_basis_cocompact.tendsto_iff at_top_basis).2 fun r hr =>\n    ⟨closed_ball x r, is_compact_closed_ball x r, fun y hy => (not_le.1 <| mt mem_closed_ball.2 hy).le⟩\n#align tendsto_dist_right_cocompact_at_top tendsto_dist_right_cocompact_at_top\n\n",
 "tendsto_dist_left_cocompact_at_top":
 "theorem tendsto_dist_left_cocompact_at_top [proper_space α] (x : α) : tendsto (dist x) (cocompact α) at_top := by\n  simpa only [dist_comm] using tendsto_dist_right_cocompact_at_top x\n#align tendsto_dist_left_cocompact_at_top tendsto_dist_left_cocompact_at_top\n\n",
 "tendsto_cocompact_of_tendsto_dist_comp_at_top":
 "theorem tendsto_cocompact_of_tendsto_dist_comp_at_top {f : β → α} {l : filter β} (x : α)\n    (h : tendsto (fun y => dist (f y) x) l at_top) : tendsto f l (cocompact α) :=\n  by\n  refine' tendsto.mono_right _ (comap_dist_right_at_top_le_cocompact x)\n  rwa [tendsto_comap_iff]\n#align tendsto_cocompact_of_tendsto_dist_comp_at_top tendsto_cocompact_of_tendsto_dist_comp_at_top\n\n",
 "tendsto_at_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A variant of `tendsto_at_top` that\nuses `∃ N, ∀ n > N, ...` rather than `∃ N, ∀ n ≥ N, ...`\n-/\ntheorem tendsto_at_top' [nonempty β] [SemilatticeSup β] [NoMaxOrder β] {u : β → α} {a : α} :\n    tendsto u at_top ((nhds) a) ↔ ∀ ε > 0, ∃ N, ∀ n > N, dist (u n) a < ε :=\n  (at_top_basis_Ioi.tendsto_iff nhds_basis_ball).trans <|\n    by\n    simp only [exists_prop, true_and_iff]\n    rfl\n#align tendsto_at_top' tendsto_at_top'\n\n",
 "tendsto_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_at_top [nonempty β] [SemilatticeSup β] {u : β → α} {a : α} :\n    tendsto u at_top ((nhds) a) ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, dist (u n) a < ε :=\n  (at_top_basis.tendsto_iff nhds_basis_ball).trans <|\n    by\n    simp only [exists_prop, true_and_iff]\n    rfl\n#align tendsto_at_top tendsto_at_top\n\n",
 "swap_dist":
 "theorem swap_dist : function.swap (@dist α _) = dist := by funext x y <;> exact dist_comm _ _\n#align swap_dist swap_dist\n\n",
 "subsingleton_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem subsingleton_sphere (x : γ) {r : exprℝ} (hr : r ≤ 0) : (sphere x r).subsingleton :=\n  (subsingleton_closed_ball x hr).anti sphere_subset_closed_ball\n#align subsingleton_sphere subsingleton_sphere\n\n",
 "subsingleton_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem subsingleton_closed_ball (x : γ) {r : exprℝ} (hr : r ≤ 0) : (closed_ball x r).subsingleton :=\n  by\n  rcases hr.lt_or_eq with (hr | rfl)\n  · rw [closed_ball_eq_empty.2 hr]\n    exact subsingleton_empty\n  · rw [closed_ball_zero]\n    exact subsingleton_singleton\n#align subsingleton_closed_ball subsingleton_closed_ball\n\n",
 "subset_ball_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem bounded.subset_ball_lt (h : bounded s) (a : exprℝ) (c : α) : ∃ r, a < r ∧ s ⊆ closed_ball c r :=\n  by\n  rcases h.subset_ball c with ⟨r, hr⟩\n  refine' ⟨max r (a + 1), lt_of_lt_of_le (by linarith) (le_max_right _ _), _⟩\n  exact subset.trans hr (closed_ball_subset_closed_ball (le_max_left _ _))\n#align bounded.subset_ball_lt bounded.subset_ball_lt\n\n",
 "subset_ball":
 "theorem bounded.subset_ball (h : bounded s) (c : α) : ∃ r, s ⊆ closed_ball c r :=\n  (bounded_iff_subset_ball c).1 h\n#align bounded.subset_ball bounded.subset_ball\n\n",
 "squeeze_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Special case of the sandwich theorem; see `tendsto_of_tendsto_of_tendsto_of_le_of_le'` for the\ngeneral case. -/\ntheorem squeeze_zero' {α} {f g : α → exprℝ} {t₀ : filter α}\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" t₀\n        (0 ≤ f t))\n    (hft :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" t₀\n        (f t ≤ g t))\n    (g0 : tendsto g t₀ (nhds 0)) : tendsto f t₀ ((nhds) 0) :=\n  tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds g0 hf hft\n#align squeeze_zero' squeeze_zero'\n\n",
 "squeeze_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Special case of the sandwich theorem; see `tendsto_of_tendsto_of_tendsto_of_le_of_le`\nand  `tendsto_of_tendsto_of_tendsto_of_le_of_le'` for the general case. -/\ntheorem squeeze_zero {α} {f g : α → exprℝ} {t₀ : filter α} (hf : ∀ t, 0 ≤ f t) (hft : ∀ t, f t ≤ g t)\n    (g0 : tendsto g t₀ ((nhds) 0)) : tendsto f t₀ ((nhds) 0) :=\n  squeeze_zero' (eventually_of_forall hf) (eventually_of_forall hft) g0\n#align squeeze_zero squeeze_zero\n\n",
 "sphere_zero":
 "@[simp]\ntheorem sphere_zero : sphere x 0 = {x} :=\n  Set.ext fun y => dist_eq_zero\n#align sphere_zero sphere_zero\n\n",
 "sphere_union_ball":
 "@[simp]\ntheorem sphere_union_ball : sphere x ε ∪ ball x ε = closed_ball x ε := by rw [union_comm, ball_union_sphere]\n#align sphere_union_ball sphere_union_ball\n\n",
 "sphere_subset_closed_ball":
 "theorem sphere_subset_closed_ball : sphere x ε ⊆ closed_ball x ε := fun y => le_of_eq\n#align sphere_subset_closed_ball sphere_subset_closed_ball\n\n",
 "sphere_is_empty_of_subsingleton":
 "theorem sphere_is_empty_of_subsingleton [subsingleton α] (hε : ε ≠ 0) : is_empty (sphere x ε) := by\n  simp only [sphere_eq_empty_of_subsingleton hε, set.has_emptyc.emptyc.is_empty α]\n#align sphere_is_empty_of_subsingleton sphere_is_empty_of_subsingleton\n\n",
 "sphere_eq_empty_of_subsingleton":
 "theorem sphere_eq_empty_of_subsingleton [subsingleton α] (hε : ε ≠ 0) : sphere x ε = ∅ :=\n  Set.eq_empty_iff_forall_not_mem.mpr fun y hy => ne_of_mem_sphere hy hε (subsingleton.elim _ _)\n#align sphere_eq_empty_of_subsingleton sphere_eq_empty_of_subsingleton\n\n",
 "sphere_disjoint_ball":
 "theorem sphere_disjoint_ball : Disjoint (sphere x ε) (ball x ε) :=\n  Set.disjoint_left.mpr fun y hy₁ hy₂ => absurd hy₁ <| ne_of_lt hy₂\n#align sphere_disjoint_ball sphere_disjoint_ball\n\n",
 "separable_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a set `s` is separable, then the corresponding subtype is separable in a metric space.\nThis is not obvious, as the countable set whose closure covers `s` does not need in general to\nbe contained in `s`. -/\ntheorem _root_.topological_space.is_separable.separable_space {s : set α} (hs : is_separable s) : separable_space s :=\n  by\n  classical\n    rcases eq_empty_or_nonempty s with (rfl | ⟨⟨x₀, x₀s⟩⟩)\n    · infer_instance\n    rcases hs with ⟨c, hc, h'c⟩\n    haveI : Encodable c := hc.to_encodable\n    obtain ⟨u, -, u_pos, u_lim⟩ : ∃ u : ℕ → exprℝ, strict_anti u ∧ (∀ n : ℕ, 0 < u n) ∧ tendsto u at_top ((nhds) 0) :=\n      exists_seq_strict_anti_tendsto (0 : exprℝ)\n    let f : c × ℕ → α := fun p => if h : (metric.ball (p.1 : α) (u p.2) ∩ s).nonempty then h.some else x₀\n    have fs : ∀ p, f p ∈ s := by\n      rintro ⟨y, n⟩\n      by_cases h : (ball (y : α) (u n) ∩ s).nonempty\n      · simpa only [f, h, dif_pos] using h.some_spec.2\n      · simpa only [f, h, not_false_iff, dif_neg]\n    let g : c × ℕ → s := fun p => ⟨f p, fs p⟩\n    apply separable_space_of_dense_range g\n    apply metric.dense_range_iff.2\n    rintro ⟨x, xs⟩ r (rpos : 0 < r)\n    obtain ⟨n, hn⟩ : ∃ n, u n < r / 2 := ((tendsto_order.1 u_lim).2 _ (half_pos rpos)).exists\n    obtain ⟨z, zc, hz⟩ : ∃ z ∈ c, dist x z < u n := metric.mem_closure_iff.1 (h'c xs) _ (u_pos n)\n    refine' ⟨(⟨z, zc⟩, n), _⟩\n    change dist x (f (⟨z, zc⟩, n)) < r\n    have A : (metric.ball z (u n) ∩ s).nonempty := ⟨x, hz, xs⟩\n    dsimp [f]\n    simp only [A, dif_pos]\n    calc\n      dist x A.some ≤ dist x z + dist z A.some := dist_triangle _ _ _\n      _ < r / 2 + r / 2 := add_lt_add (hz.trans hn) ((metric.mem_ball'.1 A.some_spec.1).trans hn)\n      _ = r := add_halves _\n      \n#align topological_space.is_separable.separable_space topological_space.is_separable.separable_space\n\n",
 "second_countable_of_countable_discretization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- we construct the instance from the emetric space instance to avoid checking again that the\n  uniformity is the same as the product uniformity, but we register nevertheless a nice formula\n  for the distance -/\n/-- A metric space is second countable if one can reconstruct up to any `ε>0` any element of the\nspace from countably many data. -/\ntheorem second_countable_of_countable_discretization {α : Type u} [metric_space α]\n    (H : ∀ ε > (0 : exprℝ), ∃ (β : Type _)(_ : Encodable β)(F : α → β), ∀ x y, F x = F y → dist x y ≤ ε) :\n    second_countable_topology α :=\n  by\n  cases' (univ : set α).eq_empty_or_nonempty with hs hs\n  · haveI : compact_space α := ⟨by rw [hs] <;> exact is_compact_empty⟩\n    · infer_instance\n  rcases hs with ⟨x0, hx0⟩\n  letI : inhabited α := ⟨x0⟩\n  refine' second_countable_of_almost_dense_set fun ε ε0 => _\n  rcases H ε ε0 with ⟨β, fβ, F, hF⟩\n  skip\n  let Finv := function.inv_fun F\n  refine' ⟨range Finv, ⟨countable_range _, fun x => _⟩⟩\n  let x' := Finv (F x)\n  have : F x' = F x := Function.invFun_eq ⟨x, rfl⟩\n  exact ⟨x', mem_range_self _, hF _ _ this.symm⟩\n#align second_countable_of_countable_discretization second_countable_of_countable_discretization\n\n",
 "second_countable_of_almost_dense_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A pseudometric space is second countable if, for every `ε > 0`, there is a countable set which\nis `ε`-dense. -/\ntheorem second_countable_of_almost_dense_set\n    (H : ∀ ε > (0 : exprℝ), ∃ s : set α, s.countable ∧ ∀ x, ∃ y ∈ s, dist x y ≤ ε) : second_countable_topology α :=\n  by\n  refine' emetric.second_countable_of_almost_dense_set fun ε ε0 => _\n  rcases ennreal.lt_iff_exists_nnreal_btwn.1 ε0 with ⟨ε', ε'0, ε'ε⟩\n  choose s hsc y hys hyx using H ε' (by exact_mod_cast ε'0)\n  refine' ⟨s, hsc, Union₂_eq_univ_iff.2 fun x => ⟨y x, hys _, le_trans _ ε'ε.le⟩⟩\n  exact_mod_cast hyx x\n#align second_countable_of_almost_dense_set second_countable_of_almost_dense_set\n\n",
 "replace_uniformity_eq":
 "theorem metric_space.replace_uniformity_eq {γ} [U : uniform_space γ] (m : metric_space γ)\n    (H : @uniformity _ U = @uniformity _ pseudo_emetric_space.to_uniform_space) : m.replace_uniformity H = m :=\n  by\n  ext\n  rfl\n#align metric_space.replace_uniformity_eq metric_space.replace_uniformity_eq\n\n",
 "replace_topology_eq":
 "theorem metric_space.replace_topology_eq {γ} [U : topological_space γ] (m : metric_space γ)\n    (H : U = m.to_pseudo_metric_space.to_uniform_space.to_topological_space) : m.replace_topology H = m :=\n  by\n  ext\n  rfl\n#align metric_space.replace_topology_eq metric_space.replace_topology_eq\n\n",
 "replace_bornology_eq":
 "theorem metric_space.replace_bornology_eq {α} [m : metric_space α] [B : bornology α]\n    (H : ∀ s, @is_bounded _ B s ↔ @is_bounded _ pseudo_metric_space.to_bornology s) :\n    metric_space.replace_bornology _ H = m := by\n  ext\n  rfl\n#align metric_space.replace_bornology_eq metric_space.replace_bornology_eq\n\n",
 "pseudo_metric_quot_dist_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem pseudo_metric_quot_dist_eq {α : Type u} [pseudo_metric_space α] (p q : α) :\n    dist («expr⟦ ⟧» p) («expr⟦ ⟧» q) = dist p q :=\n  rfl\n#align pseudo_metric_quot_dist_eq pseudo_metric_quot_dist_eq\n\n",
 "proper_space_of_compact_closed_ball_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If all closed balls of large enough radius are compact, then the space is proper. Especially\nuseful when the lower bound for the radius is 0. -/\ntheorem proper_space_of_compact_closed_ball_of_le (R : exprℝ) (h : ∀ x : α, ∀ r, R ≤ r → is_compact (closed_ball x r)) :\n    proper_space α :=\n  ⟨by\n    intro x r\n    by_cases hr : R ≤ r\n    · exact h x r hr\n    · have : closed_ball x r = closed_ball x R ∩ closed_ball x r :=\n        by\n        symm\n        apply inter_eq_self_of_subset_right\n        exact closed_ball_subset_closed_ball (le_of_lt (not_le.1 hr))\n      rw [this]\n      exact (h x R le_rfl).inter_right is_closed_ball⟩\n#align proper_space_of_compact_closed_ball_of_le proper_space_of_compact_closed_ball_of_le\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\nprotected theorem bounded.prod [pseudo_metric_space β] {s : set α} {t : set β} (hs : bounded s) (ht : bounded t) :\n    bounded (lower_set.prod s t) :=\n  by\n  refine' bounded_iff_mem_bounded.mpr fun x hx => _\n  rcases hs.subset_ball x.1 with ⟨rs, hrs⟩\n  rcases ht.subset_ball x.2 with ⟨rt, hrt⟩\n  suffices : lower_set.prod s t ⊆ closed_ball x (max rs rt)\n  exact bounded_closed_ball.mono this\n  rw [← @prod.mk.eta _ _ x, ← closed_ball_prod_same]\n  exact\n    prod_mono (hrs.trans <| closed_ball_subset_closed_ball <| le_max_left _ _)\n      (hrt.trans <| closed_ball_subset_closed_ball <| le_max_right _ _)\n#align bounded.prod bounded.prod\n\n",
 "pos_of_mem_ball":
 "theorem pos_of_mem_ball (hy : y ∈ ball x ε) : 0 < ε :=\n  dist_nonneg.trans_lt hy\n#align pos_of_mem_ball pos_of_mem_ball\n\n",
 "nonempty_closed_ball":
 "@[simp]\ntheorem nonempty_closed_ball : (closed_ball x ε).nonempty ↔ 0 ≤ ε :=\n  ⟨fun ⟨x, hx⟩ => dist_nonneg.trans hx, fun h => ⟨x, mem_closed_ball_self h⟩⟩\n#align nonempty_closed_ball nonempty_closed_ball\n\n",
 "nonempty_ball":
 "@[simp]\ntheorem nonempty_ball : (ball x ε).nonempty ↔ 0 < ε :=\n  ⟨fun ⟨x, hx⟩ => pos_of_mem_ball hx, fun h => ⟨x, mem_ball_self h⟩⟩\n#align nonempty_ball nonempty_ball\n\n",
 "nonempty_Inter_of_nonempty_bInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- In a complete space, if a family of closed sets with diameter tending to `0` is such that each\nfinite intersection is nonempty, then the total intersection is also nonempty. -/\ntheorem nonempty_Inter_of_nonempty_bInter [complete_space α] {s : ℕ → set α} (hs : ∀ n, is_closed (s n))\n    (h's : ∀ n, bounded (s n))\n    (h :\n      ∀ N,\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n            (s n)).nonempty)\n    (h' : tendsto (fun n => diam (s n)) at_top ((nhds) 0)) :\n    («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s n)).nonempty :=\n  (hs 0).is_complete.nonempty_Inter_of_nonempty_bInter hs h's h h'\n#align nonempty_Inter_of_nonempty_bInter nonempty_Inter_of_nonempty_bInter\n\n",
 "nndist_zero_eq_val'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n@[simp]\ntheorem nnreal.nndist_zero_eq_val' (z : nnreal) : nndist z 0 = z :=\n  by\n  rw [nndist_comm]\n  exact nnreal.nndist_zero_eq_val z\n#align nnreal.nndist_zero_eq_val' nnreal.nndist_zero_eq_val'\n\n",
 "nndist_zero_eq_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n@[simp]\ntheorem nnreal.nndist_zero_eq_val (z : nnreal) : nndist 0 z = z := by\n  simp only [nnreal.nndist_eq, max_eq_right, tsub_zero, zero_tsub, zero_le']\n#align nnreal.nndist_zero_eq_val nnreal.nndist_zero_eq_val\n\n",
 "nndist_up_up":
 "@[simp]\ntheorem ulift.nndist_up_up (x y : β) : nndist (ulift.up x) (ulift.up y) = nndist x y :=\n  rfl\n#align ulift.nndist_up_up ulift.nndist_up_up\n\n",
 "nndist_unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[simp, to_additive]\ntheorem nndist_unop (x y : «expr ᵐᵒᵖ» α) : nndist (unop x) (unop y) = nndist x y :=\n  rfl\n#align nndist_unop nndist_unop\n\n",
 "nndist_triangle_right":
 "theorem nndist_triangle_right (x y z : α) : nndist x y ≤ nndist x z + nndist y z :=\n  dist_triangle_right _ _ _\n#align nndist_triangle_right nndist_triangle_right\n\n",
 "nndist_triangle_left":
 "theorem nndist_triangle_left (x y z : α) : nndist x y ≤ nndist z x + nndist z y :=\n  dist_triangle_left _ _ _\n#align nndist_triangle_left nndist_triangle_left\n\n",
 "nndist_triangle":
 "/-- Triangle inequality for the nonnegative distance-/\ntheorem nndist_triangle (x y z : α) : nndist x z ≤ nndist x y + nndist y z :=\n  dist_triangle _ _ _\n#align nndist_triangle nndist_triangle\n\n",
 "nndist_to_mul":
 "@[simp]\ntheorem nndist_to_mul (a b : Additive X) : nndist (toMul a) (toMul b) = nndist a b :=\n  rfl\n#align nndist_to_mul nndist_to_mul\n\n",
 "nndist_to_dual":
 "@[simp]\ntheorem nndist_to_dual (a b : X) : nndist (toDual a) (toDual b) = nndist a b :=\n  rfl\n#align nndist_to_dual nndist_to_dual\n\n",
 "nndist_to_add":
 "@[simp]\ntheorem nndist_to_add (a b : Multiplicative X) : nndist (toAdd a) (toAdd b) = nndist a b :=\n  rfl\n#align nndist_to_add nndist_to_add\n\n",
 "nndist_self":
 "/-- `nndist x x` vanishes-/\n@[simp]\ntheorem nndist_self (a : α) : nndist a a = 0 :=\n  (nnreal.coe_eq_zero _).1 (dist_self a)\n#align nndist_self nndist_self\n\n",
 "nndist_pi_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem nndist_pi_le_iff {f g : ∀ b, π b} {r : nnreal} : nndist f g ≤ r ↔ ∀ b, nndist (f b) (g b) ≤ r := by\n  simp [nndist_pi_def]\n#align nndist_pi_le_iff nndist_pi_le_iff\n\n",
 "nndist_pi_def":
 "/- we construct the instance from the pseudoemetric space instance to avoid checking again that\n  the uniformity is the same as the product uniformity, but we register nevertheless a nice formula\n  for the distance -/\ntheorem nndist_pi_def (f g : ∀ b, π b) : nndist f g = sup univ fun b => nndist (f b) (g b) :=\n  nnreal.eq rfl\n#align nndist_pi_def nndist_pi_def\n\n",
 "nndist_pi_const_le":
 "theorem nndist_pi_const_le (a b : α) : (nndist (fun _ : β => a) fun _ => b) ≤ nndist a b :=\n  nndist_pi_le_iff.2 fun _ => le_rfl\n#align nndist_pi_const_le nndist_pi_const_le\n\n",
 "nndist_pi_const":
 "@[simp]\ntheorem nndist_pi_const [nonempty β] (a b : α) : (nndist (fun x : β => a) fun _ => b) = nndist a b :=\n  nnreal.eq <| dist_pi_const a b\n#align nndist_pi_const nndist_pi_const\n\n",
 "nndist_op":
 "@[simp, to_additive]\ntheorem nndist_op (x y : α) : nndist (op x) (op y) = nndist x y :=\n  rfl\n#align nndist_op nndist_op\n\n",
 "nndist_of_mul":
 "@[simp]\ntheorem nndist_of_mul (a b : X) : nndist (ofMul a) (ofMul b) = nndist a b :=\n  rfl\n#align nndist_of_mul nndist_of_mul\n\n",
 "nndist_of_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem nndist_of_dual (a b : «expr ᵒᵈ» X) : nndist (ofDual a) (ofDual b) = nndist a b :=\n  rfl\n#align nndist_of_dual nndist_of_dual\n\n",
 "nndist_of_add":
 "@[simp]\ntheorem nndist_of_add (a b : X) : nndist (ofAdd a) (ofAdd b) = nndist a b :=\n  rfl\n#align nndist_of_add nndist_of_add\n\n",
 "nndist_le_pi_nndist":
 "theorem nndist_le_pi_nndist (f g : ∀ b, π b) (b : β) : nndist (f b) (g b) ≤ nndist f g :=\n  by\n  rw [nndist_pi_def]\n  exact finset.le_sup (finset.mem_univ b)\n#align nndist_le_pi_nndist nndist_le_pi_nndist\n\n",
 "nndist_insert_nth_insert_nth":
 "@[simp]\ntheorem fin.nndist_insert_nth_insert_nth {n : ℕ} {α : fin (n + 1) → Type _} [∀ i, pseudo_metric_space (α i)]\n    (i : fin (n + 1)) (x y : α i) (f g : ∀ j, α (i.succ_above j)) :\n    nndist (i.insert_nth x f) (i.insert_nth y g) = max (nndist x y) (nndist f g) :=\n  eq_of_forall_ge_iff fun c => by simp [nndist_pi_le_iff, i.forall_iff_succ_above]\n#align fin.nndist_insert_nth_insert_nth fin.nndist_insert_nth_insert_nth\n\n",
 "nndist_eq_zero":
 "/-- Characterize the equality of points with the vanishing of the nonnegative distance-/\n@[simp]\ntheorem nndist_eq_zero {x y : γ} : nndist x y = 0 ↔ x = y := by\n  simp only [← nnreal.eq_iff, ← dist_nndist, imp_self, nnreal.coe_zero, dist_eq_zero]\n#align nndist_eq_zero nndist_eq_zero\n\n",
 "nndist_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.nndist_eq' (x y : exprℝ) : nndist x y = real.nnabs (y - x) :=\n  nndist_comm _ _\n#align real.nndist_eq' real.nndist_eq'\n\n",
 "nndist_eq":
 "theorem ulift.nndist_eq (x y : ULift β) : nndist x y = nndist x.down y.down :=\n  rfl\n#align ulift.nndist_eq ulift.nndist_eq\n\n",
 "nndist_edist":
 "-- see Note [lower instance priority]\n/-- Express `nndist` in terms of `edist`-/\ntheorem nndist_edist (x y : α) : nndist x y = (edist x y).to_nnreal := by\n  simp [nndist, edist_dist, real.to_nnreal, max_eq_left dist_nonneg, ennreal.of_real]\n#align nndist_edist nndist_edist\n\n",
 "nndist_dist":
 "/-- Express `nndist` in terms of `dist`-/\ntheorem nndist_dist (x y : α) : nndist x y = real.to_nnreal (dist x y) := by rw [dist_nndist, real.to_nnreal_coe]\n#align nndist_dist nndist_dist\n\n",
 "nndist_comm":
 "theorem nndist_comm (x y : α) : nndist x y = nndist y x := by\n  simpa only [dist_nndist, nnreal.coe_eq] using dist_comm x y\n#align nndist_comm nndist_comm\n\n",
 "nndist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.nndist {f g : β → α} {x : filter β} {a b : α} (hf : tendsto f x ((nhds) a))\n    (hg : tendsto g x ((nhds) b)) : tendsto (fun x => nndist (f x) (g x)) x ((nhds) (nndist a b)) :=\n  (continuous_nndist.tendsto (a, b)).comp (hf.prod_mk_nhds hg)\n#align filter.tendsto.nndist filter.tendsto.nndist\n\n",
 "nhds_within_basis_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem nhds_within_basis_ball {s : set α} :\n    (nhds_within s x).has_basis (fun ε : exprℝ => 0 < ε) fun ε => ball x ε ∩ s :=\n  nhds_within_has_basis nhds_basis_ball s\n#align nhds_within_basis_ball nhds_within_basis_ball\n\n",
 "nhds_comap_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_comap_dist (a : α) : (((nhds) (0 : exprℝ)).comap fun a' => dist a' a) = (nhds) a := by\n  simp only [@nhds_eq_comap_uniformity α, metric.uniformity_eq_comap_nhds_zero, comap_comap, (· ∘ ·), dist_comm]\n#align nhds_comap_dist nhds_comap_dist\n\n",
 "nhds_basis_closed_ball_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_closed_ball_pow {r : exprℝ} (h0 : 0 < r) (h1 : r < 1) :\n    ((nhds) x).has_basis (fun n => true) fun n : ℕ => closed_ball x (r ^ n) :=\n  nhds_basis_uniformity (uniformity_basis_dist_le_pow h0 h1)\n#align nhds_basis_closed_ball_pow nhds_basis_closed_ball_pow\n\n",
 "nhds_basis_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem nhds_basis_closed_ball : ((nhds) x).has_basis (fun ε : exprℝ => 0 < ε) (closed_ball x) :=\n  nhds_basis_uniformity uniformity_basis_dist_le\n#align nhds_basis_closed_ball nhds_basis_closed_ball\n\n",
 "nhds_basis_ball_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_ball_pow {r : exprℝ} (h0 : 0 < r) (h1 : r < 1) :\n    ((nhds) x).has_basis (fun n => true) fun n : ℕ => ball x (r ^ n) :=\n  nhds_basis_uniformity (uniformity_basis_dist_pow h0 h1)\n#align nhds_basis_ball_pow nhds_basis_ball_pow\n\n",
 "nhds_basis_ball_inv_nat_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_ball_inv_nat_succ : ((nhds) x).has_basis (fun _ => true) fun n : ℕ => ball x (1 / (↑n + 1)) :=\n  nhds_basis_uniformity uniformity_basis_dist_inv_nat_succ\n#align nhds_basis_ball_inv_nat_succ nhds_basis_ball_inv_nat_succ\n\n",
 "nhds_basis_ball_inv_nat_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_ball_inv_nat_pos : ((nhds) x).has_basis (fun n => 0 < n) fun n : ℕ => ball x (1 / ↑n) :=\n  nhds_basis_uniformity uniformity_basis_dist_inv_nat_pos\n#align nhds_basis_ball_inv_nat_pos nhds_basis_ball_inv_nat_pos\n\n",
 "nhds_basis_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem nhds_basis_ball : ((nhds) x).has_basis (fun ε : exprℝ => 0 < ε) (ball x) :=\n  nhds_basis_uniformity uniformity_basis_dist\n#align nhds_basis_ball nhds_basis_ball\n\n",
 "ne_of_mem_sphere":
 "theorem ne_of_mem_sphere (h : y ∈ sphere x ε) (hε : ε ≠ 0) : y ≠ x :=\n  by\n  contrapose! hε\n  symm\n  simpa [hε] using h\n#align ne_of_mem_sphere ne_of_mem_sphere\n\n",
 "mono":
 "/-- Subsets of a bounded set are also bounded -/\ntheorem bounded.mono (incl : s ⊆ t) : bounded t → bounded s :=\n  Exists.imp fun C hC x hx y hy => hC x (incl hx) y (incl hy)\n#align bounded.mono bounded.mono\n\n",
 "mk_uniformity_basis_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Given `f : β → ℝ`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then closed neighborhoods of the diagonal of sizes `{f i | p i}`\nform a basis of `𝓤 α`.\n\nCurrently we have only one specific basis `uniformity_basis_dist_le` based on this constructor.\nMore can be easily added if needed in the future. -/\nprotected theorem mk_uniformity_basis_le {β : Type _} {p : β → Prop} {f : β → exprℝ} (hf₀ : ∀ x, p x → 0 < f x)\n    (hf : ∀ ε, 0 < ε → ∃ (x : _)(hx : p x), f x ≤ ε) :\n    ((uniformity) α).has_basis p fun x => { p : α × α | dist p.1 p.2 ≤ f x } :=\n  by\n  refine' ⟨fun s => uniformity_basis_dist.mem_iff.trans _⟩\n  constructor\n  · rintro ⟨ε, ε₀, hε⟩\n    rcases exists_between ε₀ with ⟨ε', hε'⟩\n    rcases hf ε' hε'.1 with ⟨i, hi, H⟩\n    exact ⟨i, hi, fun x (hx : _ ≤ _) => hε <| lt_of_le_of_lt (le_trans hx H) hε'.2⟩\n  · exact fun ⟨i, hi, H⟩ => ⟨f i, hf₀ i hi, fun x (hx : _ < _) => H (le_of_lt hx)⟩\n#align mk_uniformity_basis_le mk_uniformity_basis_le\n\n",
 "mk_uniformity_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Given `f : β → ℝ`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then `f i`-neighborhoods of the diagonal form a basis of `𝓤 α`.\n\nFor specific bases see `uniformity_basis_dist`, `uniformity_basis_dist_inv_nat_succ`,\nand `uniformity_basis_dist_inv_nat_pos`. -/\nprotected theorem mk_uniformity_basis {β : Type _} {p : β → Prop} {f : β → exprℝ} (hf₀ : ∀ i, p i → 0 < f i)\n    (hf : ∀ ⦃ε⦄, 0 < ε → ∃ (i : _)(hi : p i), f i ≤ ε) :\n    ((uniformity) α).has_basis p fun i => { p : α × α | dist p.1 p.2 < f i } :=\n  by\n  refine' ⟨fun s => uniformity_basis_dist.mem_iff.trans _⟩\n  constructor\n  · rintro ⟨ε, ε₀, hε⟩\n    obtain ⟨i, hi, H⟩ : ∃ (i : _)(hi : p i), f i ≤ ε\n    exact hf ε₀\n    exact ⟨i, hi, fun x (hx : _ < _) => hε <| lt_of_lt_of_le hx H⟩\n  · exact fun ⟨i, hi, H⟩ => ⟨f i, hf₀ i hi, H⟩\n#align mk_uniformity_basis mk_uniformity_basis\n\n",
 "mem_uniformity_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem mem_uniformity_dist {s : set (α × α)} : s ∈ (uniformity) α ↔ ∃ ε > 0, ∀ {a b : α}, dist a b < ε → (a, b) ∈ s :=\n  uniformity_basis_dist.mem_uniformity_iff\n#align mem_uniformity_dist mem_uniformity_dist\n\n",
 "mem_sphere_comm":
 "theorem mem_sphere_comm : x ∈ sphere y ε ↔ y ∈ sphere x ε := by rw [mem_sphere', mem_sphere]\n#align mem_sphere_comm mem_sphere_comm\n\n",
 "mem_sphere'":
 "theorem mem_sphere' : y ∈ sphere x ε ↔ dist x y = ε := by rw [dist_comm, mem_sphere]\n#align mem_sphere' mem_sphere'\n\n",
 "mem_sphere":
 "@[simp]\ntheorem mem_sphere : y ∈ sphere x ε ↔ dist y x = ε :=\n  iff.rfl\n#align mem_sphere mem_sphere\n\n",
 "mem_of_closed'":
 "theorem mem_of_closed' {s : set α} (hs : is_closed s) {a : α} : a ∈ s ↔ ∀ ε > 0, ∃ b ∈ s, dist a b < ε := by\n  simpa only [hs.closure_eq] using @mem_closure_iff _ _ s a\n#align mem_of_closed' mem_of_closed'\n\n",
 "mem_nhds_within_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem mem_nhds_within_iff {t : set α} : s ∈ nhds_within t x ↔ ∃ ε > 0, ball x ε ∩ t ⊆ s :=\n  nhds_within_basis_ball.mem_iff\n#align mem_nhds_within_iff mem_nhds_within_iff\n\n",
 "mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_nhds_iff : s ∈ (nhds) x ↔ ∃ ε > 0, ball x ε ⊆ s :=\n  nhds_basis_ball.mem_iff\n#align mem_nhds_iff mem_nhds_iff\n\n",
 "mem_closure_range_iff_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mem_closure_range_iff_nat {e : β → α} {a : α} :\n    a ∈ closure (range e) ↔ ∀ n : ℕ, ∃ k : β, dist a (e k) < 1 / ((n : exprℝ) + 1) :=\n  (mem_closure_iff_nhds_basis nhds_basis_ball_inv_nat_succ).trans <| by\n    simp only [mem_ball, dist_comm, exists_range_iff, forall_const]\n#align mem_closure_range_iff_nat mem_closure_range_iff_nat\n\n",
 "mem_closure_range_iff":
 "theorem mem_closure_range_iff {e : β → α} {a : α} : a ∈ closure (range e) ↔ ∀ ε > 0, ∃ k : β, dist a (e k) < ε := by\n  simp only [mem_closure_iff, exists_range_iff]\n#align mem_closure_range_iff mem_closure_range_iff\n\n",
 "mem_closure_iff":
 "/-- ε-characterization of the closure in pseudometric spaces-/\ntheorem mem_closure_iff {s : set α} {a : α} : a ∈ closure s ↔ ∀ ε > 0, ∃ b ∈ s, dist a b < ε :=\n  (mem_closure_iff_nhds_basis nhds_basis_ball).trans <| by simp only [mem_ball, dist_comm]\n#align mem_closure_iff mem_closure_iff\n\n",
 "mem_closed_ball_self":
 "theorem mem_closed_ball_self (h : 0 ≤ ε) : x ∈ closed_ball x ε :=\n  show dist x x ≤ ε by rw [dist_self] <;> assumption\n#align mem_closed_ball_self mem_closed_ball_self\n\n",
 "mem_closed_ball_comm":
 "theorem mem_closed_ball_comm : x ∈ closed_ball y ε ↔ y ∈ closed_ball x ε := by rw [mem_closed_ball', mem_closed_ball]\n#align mem_closed_ball_comm mem_closed_ball_comm\n\n",
 "mem_closed_ball'":
 "theorem mem_closed_ball' : y ∈ closed_ball x ε ↔ dist x y ≤ ε := by rw [dist_comm, mem_closed_ball]\n#align mem_closed_ball' mem_closed_ball'\n\n",
 "mem_closed_ball":
 "@[simp]\ntheorem mem_closed_ball : y ∈ closed_ball x ε ↔ dist y x ≤ ε :=\n  iff.rfl\n#align mem_closed_ball mem_closed_ball\n\n",
 "mem_ball_self":
 "theorem mem_ball_self (h : 0 < ε) : x ∈ ball x ε :=\n  show dist x x < ε by rw [dist_self] <;> assumption\n#align mem_ball_self mem_ball_self\n\n",
 "mem_ball_comm":
 "theorem mem_ball_comm : x ∈ ball y ε ↔ y ∈ ball x ε := by rw [mem_ball', mem_ball]\n#align mem_ball_comm mem_ball_comm\n\n",
 "mem_ball'":
 "theorem mem_ball' : y ∈ ball x ε ↔ dist x y < ε := by rw [dist_comm, mem_ball]\n#align mem_ball' mem_ball'\n\n",
 "mem_ball":
 "-- instantiate pseudometric space as a topology\n@[simp]\ntheorem mem_ball : y ∈ ball x ε ↔ dist y x < ε :=\n  iff.rfl\n#align mem_ball mem_ball\n\n",
 "lebesgue_number_lemma_of_metric_sUnion":
 "theorem lebesgue_number_lemma_of_metric_sUnion {s : set α} {c : set (set α)} (hs : is_compact s)\n    (hc₁ : ∀ t ∈ c, is_open t) (hc₂ : s ⊆ ⋃₀ c) : ∃ δ > 0, ∀ x ∈ s, ∃ t ∈ c, ball x δ ⊆ t := by\n  rw [sUnion_eq_Union] at hc₂ <;> simpa using lebesgue_number_lemma_of_metric hs (by simpa) hc₂\n#align lebesgue_number_lemma_of_metric_sUnion lebesgue_number_lemma_of_metric_sUnion\n\n",
 "lebesgue_number_lemma_of_metric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem lebesgue_number_lemma_of_metric {s : set α} {ι} {c : ι → set α} (hs : is_compact s) (hc₁ : ∀ i, is_open (c i))\n    (hc₂ : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (c i)) :\n    ∃ δ > 0, ∀ x ∈ s, ∃ i, ball x δ ⊆ c i :=\n  let ⟨n, en, hn⟩ := lebesgue_number_lemma hs hc₁ hc₂\n  let ⟨δ, δ0, hδ⟩ := mem_uniformity_dist.1 en\n  ⟨δ, δ0, fun x hx =>\n    let ⟨i, hi⟩ := hn x hx\n    ⟨i, fun y hy => hi (hδ (mem_ball'.mp hy))⟩⟩\n#align lebesgue_number_lemma_of_metric lebesgue_number_lemma_of_metric\n\n",
 "le_add_nndist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem nnreal.le_add_nndist (a b : nnreal) : a ≤ b + nndist a b :=\n  by\n  suffices (a : exprℝ) ≤ (b : exprℝ) + dist a b by exact nnreal.coe_le_coe.mp this\n  linarith [le_of_abs_le (by rfl : abs (a - b : exprℝ) ≤ dist a b)]\n#align nnreal.le_add_nndist nnreal.le_add_nndist\n\n",
 "is_separable_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem _root_.embedding.is_separable_preimage {f : β → α} [topological_space β] (hf : embedding f)\n    {s : set α} (hs : is_separable s) : is_separable («expr ⁻¹' » f s) :=\n  hf.to_inducing.is_separable_preimage hs\n#align embedding.is_separable_preimage embedding.is_separable_preimage\n\n",
 "is_separable_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If a map is continuous on a separable set `s`, then the image of `s` is also separable. -/\ntheorem _root_.continuous_on.is_separable_image [topological_space β] {f : α → β} {s : set α} (hf : continuous_on f s)\n    (hs : is_separable s) : is_separable («expr '' » f s) :=\n  by\n  rw [show «expr '' » f s = «expr '' » (s.restrict f) univ by ext <;> simp]\n  exact (is_separable_univ_iff.2 hs.separable_space).image (continuous_on_iff_continuous_restrict.1 hf)\n#align continuous_on.is_separable_image continuous_on.is_separable_image\n\n",
 "is_separable":
 "theorem is_compact.is_separable {s : set α} (hs : is_compact s) : is_separable s :=\n  haveI : compact_space s := is_compact_iff_compact_space.mp hs\n  is_separable_of_separable_space_subtype s\n#align is_compact.is_separable is_compact.is_separable\n\n",
 "is_open_singleton_iff":
 "theorem is_open_singleton_iff {α : Type _} [pseudo_metric_space α] {x : α} :\n    is_open ({x} : set α) ↔ ∃ ε > 0, ∀ y, dist y x < ε → y = x := by simp [is_open_iff, subset_singleton_iff, mem_ball]\n#align is_open_singleton_iff is_open_singleton_iff\n\n",
 "is_open_iff":
 "theorem is_open_iff : is_open s ↔ ∀ x ∈ s, ∃ ε > 0, ball x ε ⊆ s := by simp only [is_open_iff_mem_nhds, mem_nhds_iff]\n#align is_open_iff is_open_iff\n\n",
 "is_open_ball":
 "theorem is_open_ball : is_open (ball x ε) :=\n  is_open_iff.2 fun y => exists_ball_subset_ball\n#align is_open_ball is_open_ball\n\n",
 "is_compact_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- In a proper pseudometric space, all spheres are compact. -/\ntheorem is_compact_sphere {α : Type _} [pseudo_metric_space α] [proper_space α] (x : α) (r : exprℝ) :\n    is_compact (sphere x r) :=\n  is_compact_of_is_closed_subset (is_compact_closed_ball x r) is_closed_sphere sphere_subset_closed_ball\n#align is_compact_sphere is_compact_sphere\n\n",
 "is_compact_of_is_closed_bounded":
 "/-- The **Heine–Borel theorem**: In a proper space, a closed bounded set is compact. -/\ntheorem is_compact_of_is_closed_bounded [proper_space α] (hc : is_closed s) (hb : bounded s) : is_compact s :=\n  by\n  rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)\n  · exact is_compact_empty\n  · rcases hb.subset_ball x with ⟨r, hr⟩\n    exact is_compact_of_is_closed_subset (is_compact_closed_ball x r) hc hr\n#align is_compact_of_is_closed_bounded is_compact_of_is_closed_bounded\n\n",
 "is_compact_iff_is_closed_bounded":
 "/-- The **Heine–Borel theorem**:\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem is_compact_iff_is_closed_bounded [t2_space α] [proper_space α] : is_compact s ↔ is_closed s ∧ bounded s :=\n  ⟨fun h => ⟨h.is_closed, h.bounded⟩, fun h => is_compact_of_is_closed_bounded h.1 h.2⟩\n#align is_compact_iff_is_closed_bounded is_compact_iff_is_closed_bounded\n\n",
 "is_compact_closure":
 "/-- The **Heine–Borel theorem**: In a proper space, the closure of a bounded set is compact. -/\ntheorem bounded.is_compact_closure [proper_space α] (h : bounded s) : is_compact (closure s) :=\n  is_compact_of_is_closed_bounded is_closed_closure h.closure\n#align bounded.is_compact_closure bounded.is_compact_closure\n\n",
 "is_closed_sphere":
 "theorem is_closed_sphere : is_closed (sphere x ε) :=\n  is_closed_eq (continuous_id.dist continuous_const) continuous_const\n#align is_closed_sphere is_closed_sphere\n\n",
 "is_closed_of_pairwise_le_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\ntheorem is_closed_of_pairwise_le_dist {s : set γ} {ε : exprℝ} (hε : 0 < ε) (hs : s.pairwise fun x y => ε ≤ dist x y) :\n    is_closed s :=\n  is_closed_of_spaced_out (dist_mem_uniformity hε) <| by simpa using hs\n#align is_closed_of_pairwise_le_dist is_closed_of_pairwise_le_dist\n\n",
 "is_closed_ball":
 "theorem is_closed_ball : is_closed (closed_ball x ε) :=\n  is_closed_le (continuous_id.dist continuous_const) continuous_const\n#align is_closed_ball is_closed_ball\n\n",
 "is_bounded_iff_nndist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem is_bounded_iff_nndist {s : set α} : is_bounded s ↔ ∃ C : nnreal, ∀ ⦃x⦄, x ∈ s → ∀ ⦃y⦄, y ∈ s → nndist x y ≤ C :=\n  by\n  simp only [is_bounded_iff_exists_ge 0, nnreal.exists, ← nnreal.coe_le_coe, ← dist_nndist, nnreal.coe_mk, exists_prop]\n#align is_bounded_iff_nndist is_bounded_iff_nndist\n\n",
 "is_bounded_iff_exists_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_bounded_iff_exists_ge {s : set α} (c : exprℝ) :\n    is_bounded s ↔ ∃ C, c ≤ C ∧ ∀ ⦃x⦄, x ∈ s → ∀ ⦃y⦄, y ∈ s → dist x y ≤ C :=\n  ⟨fun h => ((eventually_ge_at_top c).and (is_bounded_iff_eventually.1 h)).exists, fun h =>\n    is_bounded_iff.2 <| h.imp fun _ => And.right⟩\n#align is_bounded_iff_exists_ge is_bounded_iff_exists_ge\n\n",
 "is_bounded_iff_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem is_bounded_iff_eventually {s : set α} :\n    is_bounded s ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (∀ ⦃x⦄, x ∈ s → ∀ ⦃y⦄, y ∈ s → dist x y ≤ C) :=\n  is_bounded_iff.trans\n    ⟨fun ⟨C, h⟩ => eventually_at_top.2 ⟨C, fun C' hC' x hx y hy => (h hx hy).trans hC'⟩, eventually.exists⟩\n#align is_bounded_iff_eventually is_bounded_iff_eventually\n\n",
 "is_bounded_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_bounded_iff {s : set α} : is_bounded s ↔ ∃ C : exprℝ, ∀ ⦃x⦄, x ∈ s → ∀ ⦃y⦄, y ∈ s → dist x y ≤ C := by\n  rw [is_bounded_def, ← filter.mem_sets, (@pseudo_metric_space.cobounded_sets α _).out, mem_set_of_eq, compl_compl]\n#align is_bounded_iff is_bounded_iff\n\n",
 "inseparable_iff":
 "theorem metric.inseparable_iff {x y : α} : inseparable x y ↔ dist x y = 0 := by\n  rw [emetric.inseparable_iff, edist_nndist, dist_nndist, ennreal.coe_eq_zero, nnreal.coe_eq_zero]\n#align metric.inseparable_iff metric.inseparable_iff\n\n",
 "frontier_closed_ball_subset_sphere":
 "theorem frontier_closed_ball_subset_sphere : frontier (closed_ball x ε) ⊆ sphere x ε :=\n  frontier_le_subset_eq (continuous_id.dist continuous_const) continuous_const\n#align frontier_closed_ball_subset_sphere frontier_closed_ball_subset_sphere\n\n",
 "frontier_ball_subset_sphere":
 "theorem frontier_ball_subset_sphere : frontier (ball x ε) ⊆ sphere x ε :=\n  frontier_lt_subset_eq (continuous_id.dist continuous_const) continuous_const\n#align frontier_ball_subset_sphere frontier_ball_subset_sphere\n\n",
 "forall_of_forall_mem_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/-- If a property holds for all points in closed balls of arbitrarily large radii, then it holds for\nall points. -/\ntheorem forall_of_forall_mem_closed_ball (p : α → Prop) (x : α)\n    (H :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n        (∀ y ∈ closed_ball x R, p y))\n    (y : α) : p y :=\n  by\n  obtain ⟨R, hR, h⟩ : ∃ (R : exprℝ)(H : dist y x ≤ R), ∀ z : α, z ∈ closed_ball x R → p z :=\n    frequently_iff.1 H (Ici_mem_at_top (dist y x))\n  exact h _ hR\n#align forall_of_forall_mem_closed_ball forall_of_forall_mem_closed_ball\n\n",
 "forall_of_forall_mem_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/-- If a property holds for all points in balls of arbitrarily large radii, then it holds for all\npoints. -/\ntheorem forall_of_forall_mem_ball (p : α → Prop) (x : α)\n    (H :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n        (∀ y ∈ ball x R, p y))\n    (y : α) : p y :=\n  by\n  obtain ⟨R, hR, h⟩ : ∃ (R : exprℝ)(H : dist y x < R), ∀ z : α, z ∈ ball x R → p z :=\n    frequently_iff.1 H (Ioi_mem_at_top (dist y x))\n  exact h _ hR\n#align forall_of_forall_mem_ball forall_of_forall_mem_ball\n\n",
 "finite_cover_balls_of_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- Any compact set in a pseudometric space can be covered by finitely many balls of a given\npositive radius -/\ntheorem finite_cover_balls_of_compact {α : Type u} [pseudo_metric_space α] {s : set α} (hs : is_compact s) {e : exprℝ}\n    (he : 0 < e) :\n    ∃ (t : _)(_ : t ⊆ s),\n      set.finite t ∧\n        s ⊆\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (ball x e) :=\n  by\n  apply hs.elim_finite_subcover_image\n  · simp [is_open_ball]\n  · intro x xs\n    simp\n    exact ⟨x, ⟨xs, by simpa⟩⟩\n#align finite_cover_balls_of_compact finite_cover_balls_of_compact\n\n",
 "finite_approx_of_totally_bounded":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem finite_approx_of_totally_bounded {s : set α} (hs : totally_bounded s) :\n    ∀ ε > 0,\n      ∃ (t : _)(_ : t ⊆ s),\n        set.finite t ∧\n          s ⊆\n            «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n              (ball y ε) :=\n  by\n  intro ε ε_pos\n  rw [totally_bounded_iff_subset] at hs\n  exact hs _ (dist_mem_uniformity ε_pos)\n#align finite_approx_of_totally_bounded finite_approx_of_totally_bounded\n\n",
 "ext":
 "/-- Two metric space structures with the same distance coincide. -/\n@[ext]\ntheorem metric_space.ext {α : Type _} {m m' : metric_space α} (h : m.to_has_dist = m'.to_has_dist) : m = m' :=\n  by\n  have h' : m.to_pseudo_metric_space = m'.to_pseudo_metric_space := pseudo_metric_space.ext h\n  rcases m with ⟨⟩\n  rcases m' with ⟨⟩\n  dsimp at h'\n  subst h'\n#align metric_space.ext metric_space.ext\n\n",
 "exists_pos_lt_subset_ball":
 "-- A compact pseudometric space is proper \n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n/- We want to show that the Cauchy filter `f` is converging. It suffices to find a closed\n  ball (therefore compact by properness) where it is nontrivial. -/\n/-- If a nonempty ball in a proper space includes a closed set `s`, then there exists a nonempty\nball with the same center and a strictly smaller radius that includes `s`. -/\ntheorem exists_pos_lt_subset_ball (hr : 0 < r) (hs : is_closed s) (h : s ⊆ ball x r) : ∃ r' ∈ Ioo 0 r, s ⊆ ball x r' :=\n  by\n  rcases eq_empty_or_nonempty s with (rfl | hne)\n  · exact ⟨r / 2, ⟨half_pos hr, half_lt_self hr⟩, empty_subset _⟩\n  have : is_compact s :=\n    is_compact_of_is_closed_subset (is_compact_closed_ball x r) hs (subset.trans h ball_subset_closed_ball)\n  obtain ⟨y, hys, hy⟩ : ∃ y ∈ s, s ⊆ closed_ball x (dist y x)\n  exact this.exists_forall_ge hne (continuous_id.dist continuous_const).continuous_on\n  have hyr : dist y x < r := h hys\n  rcases exists_between hyr with ⟨r', hyr', hrr'⟩\n  exact ⟨r', ⟨dist_nonneg.trans_lt hyr', hrr'⟩, subset.trans hy <| closed_ball_subset_ball hyr'⟩\n#align exists_pos_lt_subset_ball exists_pos_lt_subset_ball\n\n",
 "exists_lt_subset_ball":
 "/-- If a ball in a proper space includes a closed set `s`, then there exists a ball with the same\ncenter and a strictly smaller radius that includes `s`. -/\ntheorem exists_lt_subset_ball (hs : is_closed s) (h : s ⊆ ball x r) : ∃ r' < r, s ⊆ ball x r' :=\n  by\n  cases' le_or_lt r 0 with hr hr\n  · rw [ball_eq_empty.2 hr, subset_empty_iff] at h\n    subst s\n    exact (exists_lt r).imp fun r' hr' => ⟨hr', empty_subset _⟩\n  · exact (exists_pos_lt_subset_ball hr hs h).imp fun r' hr' => ⟨hr'.fst.2, hr'.snd⟩\n#align exists_lt_subset_ball exists_lt_subset_ball\n\n",
 "exists_lt_mem_ball_of_mem_ball":
 "/-- If a point belongs to an open ball, then there is a strictly smaller radius whose ball also\ncontains it.\n\nSee also `exists_lt_subset_ball`. -/\ntheorem exists_lt_mem_ball_of_mem_ball (h : x ∈ ball y ε) : ∃ ε' < ε, x ∈ ball y ε' :=\n  by\n  simp only [mem_ball] at h⊢\n  exact ⟨(ε + dist x y) / 2, by linarith, by linarith⟩\n#align exists_lt_mem_ball_of_mem_ball exists_lt_mem_ball_of_mem_ball\n\n",
 "exists_local_min_mem_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem exists_local_min_mem_ball [proper_space α] [topological_space β] [ConditionallyCompleteLinearOrder β]\n    [order_topology β] {f : α → β} {a z : α} {r : exprℝ} (hf : continuous_on f (closed_ball a r))\n    (hz : z ∈ closed_ball a r) (hf1 : ∀ z' ∈ sphere a r, f z < f z') : ∃ z ∈ ball a r, is_local_min f z :=\n  by\n  simp_rw [← closed_ball_diff_ball] at hf1\n  exact (is_compact_closed_ball a r).exists_local_min_mem_open ball_subset_closed_ball hf hz hf1 is_open_ball\n#align exists_local_min_mem_ball exists_local_min_mem_ball\n\n",
 "exists_is_open_bounded_image_of_is_compact_of_forall_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If a function is continuous at every point of a compact set `k`, then it is bounded on\nsome open neighborhood of `k`. -/\ntheorem exists_is_open_bounded_image_of_is_compact_of_forall_continuous_at [topological_space β] {k : set β} {f : β → α}\n    (hk : is_compact k) (hf : ∀ x ∈ k, continuous_at f x) : ∃ t, k ⊆ t ∧ is_open t ∧ bounded («expr '' » f t) :=\n  by\n  simp_rw [← continuous_within_at_univ] at hf\n  simpa only [inter_univ] using exists_is_open_bounded_image_inter_of_is_compact_of_forall_continuous_within_at hk hf\n#align\n  exists_is_open_bounded_image_of_is_compact_of_forall_continuous_at exists_is_open_bounded_image_of_is_compact_of_forall_continuous_at\n\n",
 "exists_is_open_bounded_image_of_is_compact_of_continuous_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If a function is continuous on a neighborhood of a compact set `k`, then it is bounded on\nsome open neighborhood of `k`. -/\ntheorem exists_is_open_bounded_image_of_is_compact_of_continuous_on [topological_space β] {k s : set β} {f : β → α}\n    (hk : is_compact k) (hs : is_open s) (hks : k ⊆ s) (hf : continuous_on f s) :\n    ∃ t, k ⊆ t ∧ is_open t ∧ bounded («expr '' » f t) :=\n  exists_is_open_bounded_image_of_is_compact_of_forall_continuous_at hk fun x hx =>\n    hf.continuous_at (hs.mem_nhds (hks hx))\n#align\n  exists_is_open_bounded_image_of_is_compact_of_continuous_on exists_is_open_bounded_image_of_is_compact_of_continuous_on\n\n",
 "exists_is_open_bounded_image_inter_of_is_compact_of_forall_continuous_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If a function is continuous within a set `s` at every point of a compact set `k`, then it is\nbounded on some open neighborhood of `k` in `s`. -/\ntheorem exists_is_open_bounded_image_inter_of_is_compact_of_forall_continuous_within_at [topological_space β]\n    {k s : set β} {f : β → α} (hk : is_compact k) (hf : ∀ x ∈ k, continuous_within_at f s x) :\n    ∃ t, k ⊆ t ∧ is_open t ∧ bounded («expr '' » f (t ∩ s)) :=\n  by\n  apply hk.induction_on\n  · exact ⟨∅, subset.refl _, is_open_empty, by simp only [image_empty, bounded_empty, empty_inter]⟩\n  · rintro s s' hss' ⟨t, s't, t_open, t_bounded⟩\n    exact ⟨t, hss'.trans s't, t_open, t_bounded⟩\n  · rintro s s' ⟨t, st, t_open, t_bounded⟩ ⟨t', s't', t'_open, t'_bounded⟩\n    refine' ⟨t ∪ t', union_subset_union st s't', t_open.union t'_open, _⟩\n    rw [union_inter_distrib_right, image_union]\n    exact t_bounded.union t'_bounded\n  · intro x hx\n    have A : ball (f x) 1 ∈ (nhds) (f x) := ball_mem_nhds _ zero_lt_one\n    have B : «expr ⁻¹' » f (ball (f x) 1) ∈ nhds_within s x := hf x hx A\n    obtain ⟨u, u_open, xu, uf⟩ : ∃ u : set β, is_open u ∧ x ∈ u ∧ u ∩ s ⊆ «expr ⁻¹' » f (ball (f x) 1)\n    exact _root_.mem_nhds_within.1 B\n    refine' ⟨u, _, u, subset.refl _, u_open, _⟩\n    · apply nhds_within_le_nhds\n      exact u_open.mem_nhds xu\n    · apply bounded.mono (image_subset _ uf)\n      exact bounded_ball.mono (image_preimage_subset _ _)\n#align\n  exists_is_open_bounded_image_inter_of_is_compact_of_forall_continuous_within_at exists_is_open_bounded_image_inter_of_is_compact_of_forall_continuous_within_at\n\n",
 "exists_is_open_bounded_image_inter_of_is_compact_of_continuous_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If a function is continuous on a set `s` containing a compact set `k`, then it is bounded on\nsome open neighborhood of `k` in `s`. -/\ntheorem exists_is_open_bounded_image_inter_of_is_compact_of_continuous_on [topological_space β] {k s : set β}\n    {f : β → α} (hk : is_compact k) (hks : k ⊆ s) (hf : continuous_on f s) :\n    ∃ t, k ⊆ t ∧ is_open t ∧ bounded («expr '' » f (t ∩ s)) :=\n  exists_is_open_bounded_image_inter_of_is_compact_of_forall_continuous_within_at hk fun x hx => hf x (hks hx)\n#align\n  exists_is_open_bounded_image_inter_of_is_compact_of_continuous_on exists_is_open_bounded_image_inter_of_is_compact_of_continuous_on\n\n",
 "exists_dist_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem _root_.dense_range.exists_dist_lt {β : Type _} {f : β → α} (hf : dense_range f) (x : α) {ε : exprℝ}\n    (hε : 0 < ε) : ∃ y, dist x (f y) < ε :=\n  exists_range_iff.1 (hf.exists_dist_lt x hε)\n#align dense_range.exists_dist_lt dense_range.exists_dist_lt\n\n",
 "exists_closed_ball_inter_eq_singleton_of_discrete":
 "/-- Given a point `x` in a discrete subset `s` of a pseudometric space, there is a closed ball\nof positive radius centered at `x` and intersecting `s` only at `x`. -/\ntheorem exists_closed_ball_inter_eq_singleton_of_discrete [discrete_topology s] {x : α} (hx : x ∈ s) :\n    ∃ ε > 0, metric.closed_ball x ε ∩ s = {x} :=\n  nhds_basis_closed_ball.exists_inter_eq_singleton_of_mem_discrete hx\n#align exists_closed_ball_inter_eq_singleton_of_discrete exists_closed_ball_inter_eq_singleton_of_discrete\n\n",
 "exists_ball_subset_ball":
 "theorem exists_ball_subset_ball (h : y ∈ ball x ε) : ∃ ε' > 0, ball y ε' ⊆ ball x ε :=\n  ⟨_, sub_pos.2 h, ball_subset <| by rw [sub_sub_self]⟩\n#align exists_ball_subset_ball exists_ball_subset_ball\n\n",
 "exists_ball_inter_eq_singleton_of_mem_discrete":
 "/-- Given a point `x` in a discrete subset `s` of a pseudometric space, there is an open ball\ncentered at `x` and intersecting `s` only at `x`. -/\ntheorem exists_ball_inter_eq_singleton_of_mem_discrete [discrete_topology s] {x : α} (hx : x ∈ s) :\n    ∃ ε > 0, metric.ball x ε ∩ s = {x} :=\n  nhds_basis_ball.exists_inter_eq_singleton_of_mem_discrete hx\n#align exists_ball_inter_eq_singleton_of_mem_discrete exists_ball_inter_eq_singleton_of_mem_discrete\n\n",
 "eventually_prod_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- A version of `filter.eventually_prod_iff` where the second filter consists of neighborhoods\nin a pseudo-metric space.-/\ntheorem eventually_prod_nhds_iff {f : filter ι} {x₀ : α} {p : ι × α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (filter.prod f ((nhds) x₀)) (p x) ↔\n      ∃ (pa : ι → Prop)(ha :\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n          (pa i)),\n        ∃ ε > 0, ∀ {i}, pa i → ∀ {x}, dist x x₀ < ε → p (i, x) :=\n  by\n  simp_rw [eventually_prod_iff, metric.eventually_nhds_iff]\n  refine' exists_congr fun q => exists_congr fun hq => _\n  constructor\n  · rintro ⟨r, ⟨ε, hε, hεr⟩, hp⟩\n    exact ⟨ε, hε, fun i hi x hx => hp hi <| hεr hx⟩\n  · rintro ⟨ε, hε, hp⟩\n    exact ⟨fun x => dist x x₀ < ε, ⟨ε, hε, fun y => id⟩, @hp⟩\n#align eventually_prod_nhds_iff eventually_prod_nhds_iff\n\n",
 "eventually_nhds_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- A version of `filter.eventually_prod_iff` where the first filter consists of neighborhoods\nin a pseudo-metric space.-/\ntheorem eventually_nhds_prod_iff {ι α} [pseudo_metric_space α] {f : filter ι} {x₀ : α} {p : α × ι → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (filter.prod ((nhds) x₀) f) (p x) ↔\n      ∃ ε > (0 : exprℝ),\n        ∃ (pa : ι → Prop)(ha :\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n            (pa i)),\n          ∀ {x}, dist x x₀ < ε → ∀ {i}, pa i → p (x, i) :=\n  by\n  rw [eventually_swap_iff, metric.eventually_prod_nhds_iff]\n  constructor <;>\n    · rintro ⟨a1, a2, a3, a4, a5⟩\n      refine' ⟨a3, a4, a1, a2, fun b1 b2 b3 b4 => a5 b4 b2⟩\n#align eventually_nhds_prod_iff eventually_nhds_prod_iff\n\n",
 "eventually_nhds_iff_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_nhds_iff_ball {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n        (p y) ↔\n      ∃ ε > 0, ∀ y ∈ ball x ε, p y :=\n  mem_nhds_iff\n#align eventually_nhds_iff_ball eventually_nhds_iff_ball\n\n",
 "eventually_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_nhds_iff {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n        (p y) ↔\n      ∃ ε > 0, ∀ ⦃y⦄, dist y x < ε → p y :=\n  mem_nhds_iff\n#align eventually_nhds_iff eventually_nhds_iff\n\n",
 "eventually_closed_ball_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If `u` is a neighborhood of `x`, then for small enough `r`, the closed ball\n`closed_ball x r` is contained in `u`. -/\ntheorem eventually_closed_ball_subset {x : α} {u : set α} (hu : u ∈ (nhds) x) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((nhds) (0 : exprℝ)) (closed_ball x r ⊆ u) :=\n  by\n  obtain ⟨ε, εpos, hε⟩ : ∃ (ε : _)(hε : 0 < ε), closed_ball x ε ⊆ u := nhds_basis_closed_ball.mem_iff.1 hu\n  have : Iic ε ∈ (nhds) (0 : exprℝ) := Iic_mem_nhds εpos\n  filter_upwards [this] with _ hr using subset.trans (closed_ball_subset_closed_ball hr) hε\n#align eventually_closed_ball_subset eventually_closed_ball_subset\n\n",
 "eq_of_nndist_eq_zero":
 "/-- Deduce the equality of points with the vanishing of the nonnegative distance-/\ntheorem eq_of_nndist_eq_zero {x y : γ} : nndist x y = 0 → x = y := by\n  simp only [← nnreal.eq_iff, ← dist_nndist, imp_self, nnreal.coe_zero, dist_eq_zero]\n#align eq_of_nndist_eq_zero eq_of_nndist_eq_zero\n\n",
 "eq_of_forall_dist_le":
 "theorem eq_of_forall_dist_le {x y : γ} (h : ∀ ε > 0, dist x y ≤ ε) : x = y :=\n  eq_of_dist_eq_zero (eq_of_le_of_forall_le_of_dense dist_nonneg h)\n#align eq_of_forall_dist_le eq_of_forall_dist_le\n\n",
 "eq_of_dist_eq_zero":
 "theorem eq_of_dist_eq_zero {x y : γ} : dist x y = 0 → x = y :=\n  metric_space.eq_of_dist_eq_zero\n#align eq_of_dist_eq_zero eq_of_dist_eq_zero\n\n",
 "emetric_closed_ball_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-- Closed balls defined using the distance or the edistance coincide -/\n@[simp]\ntheorem metric.emetric_closed_ball_nnreal {x : α} {ε : nnreal} : emetric.closed_ball x ε = closed_ball x ε :=\n  by\n  convert metric.emetric_closed_ball ε.2\n  simp\n#align metric.emetric_closed_ball_nnreal metric.emetric_closed_ball_nnreal\n\n",
 "emetric_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Closed balls defined using the distance or the edistance coincide -/\ntheorem metric.emetric_closed_ball {x : α} {ε : exprℝ} (h : 0 ≤ ε) :\n    emetric.closed_ball x (ennreal.of_real ε) = closed_ball x ε := by\n  ext y <;> simp [edist_dist] <;> rw [ennreal.of_real_le_of_real_iff h]\n#align metric.emetric_closed_ball metric.emetric_closed_ball\n\n",
 "emetric_ball_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem metric.emetric_ball_top (x : α) : emetric.ball x («expr⊤») = univ :=\n  eq_univ_of_forall fun y => edist_lt_top _ _\n#align metric.emetric_ball_top metric.emetric_ball_top\n\n",
 "emetric_ball_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-- Balls defined using the distance or the edistance coincide -/\n@[simp]\ntheorem metric.emetric_ball_nnreal {x : α} {ε : nnreal} : emetric.ball x ε = ball x ε :=\n  by\n  convert metric.emetric_ball\n  simp\n#align metric.emetric_ball_nnreal metric.emetric_ball_nnreal\n\n",
 "emetric_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Balls defined using the distance or the edistance coincide -/\n@[simp]\ntheorem metric.emetric_ball {x : α} {ε : exprℝ} : emetric.ball x (ennreal.of_real ε) = ball x ε :=\n  by\n  ext y\n  simp only [emetric.mem_ball, mem_ball, edist_dist]\n  exact ennreal.of_real_lt_of_real_iff_of_nonneg dist_nonneg\n#align metric.emetric_ball metric.emetric_ball\n\n",
 "edist_nndist":
 "/-- Express `edist` in terms of `nndist`-/\ntheorem edist_nndist (x y : α) : edist x y = ↑(nndist x y) := by\n  simpa only [edist_dist, ennreal.of_real_eq_coe_nnreal dist_nonneg]\n#align edist_nndist edist_nndist\n\n",
 "edist_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- In a pseudometric space, the extended distance is always finite-/\ntheorem edist_ne_top (x y : α) : edist x y ≠ «expr⊤» :=\n  (edist_lt_top x y).ne\n#align edist_ne_top edist_ne_top\n\n",
 "edist_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- In a pseudometric space, the extended distance is always finite-/\ntheorem edist_lt_top {α : Type _} [pseudo_metric_space α] (x y : α) : edist x y < «expr⊤» :=\n  (edist_dist x y).symm ▸ ennreal.of_real_lt_top\n#align edist_lt_top edist_lt_top\n\n",
 "edist_lt_of_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem edist_lt_of_real {x y : α} {r : exprℝ} : edist x y < ennreal.of_real r ↔ dist x y < r := by\n  rw [edist_dist, ennreal.of_real_lt_of_real_iff_of_nonneg dist_nonneg]\n#align edist_lt_of_real edist_lt_of_real\n\n",
 "edist_lt_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n@[simp, norm_cast]\ntheorem edist_lt_coe {x y : α} {c : nnreal} : edist x y < c ↔ nndist x y < c := by rw [edist_nndist, ennreal.coe_lt_coe]\n#align edist_lt_coe edist_lt_coe\n\n",
 "edist_le_of_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem edist_le_of_real {x y : α} {r : exprℝ} (hr : 0 ≤ r) : edist x y ≤ ennreal.of_real r ↔ dist x y ≤ r := by\n  rw [edist_dist, ennreal.of_real_le_of_real_iff hr]\n#align edist_le_of_real edist_le_of_real\n\n",
 "edist_le_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n@[simp, norm_cast]\ntheorem edist_le_coe {x y : α} {c : nnreal} : edist x y ≤ c ↔ nndist x y ≤ c := by rw [edist_nndist, ennreal.coe_le_coe]\n#align edist_le_coe edist_le_coe\n\n",
 "edist_dist":
 "theorem edist_dist (x y : α) : edist x y = ennreal.of_real (dist x y) :=\n  pseudo_metric_space.edist_dist x y\n#align edist_dist edist_dist\n\n",
 "ediam_univ_of_noncompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem ediam_univ_of_noncompact [proper_space α] [noncompact_space α] : emetric.diam (univ : set α) = ennreal.top :=\n  ediam_univ_eq_top_iff_noncompact.mpr ‹_›\n#align ediam_univ_of_noncompact ediam_univ_of_noncompact\n\n",
 "ediam_univ_eq_top_iff_noncompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem ediam_univ_eq_top_iff_noncompact [proper_space α] :\n    emetric.diam (univ : set α) = ennreal.top ↔ noncompact_space α := by\n  rw [← not_compact_space_iff, compact_space_iff_bounded_univ, bounded_iff_ediam_ne_top, not_not]\n#align ediam_univ_eq_top_iff_noncompact ediam_univ_eq_top_iff_noncompact\n\n",
 "ediam_of_unbounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem ediam_of_unbounded (h : ¬bounded s) : emetric.diam s = ennreal.top := by\n  rwa [bounded_iff_ediam_ne_top, not_not] at h\n#align ediam_of_unbounded ediam_of_unbounded\n\n",
 "ediam_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem bounded.ediam_ne_top (h : bounded s) : emetric.diam s ≠ «expr⊤» :=\n  bounded_iff_ediam_ne_top.1 h\n#align bounded.ediam_ne_top bounded.ediam_ne_top\n\n",
 "ediam_le_of_forall_dist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If the distance between any two points in a set is bounded by some constant `C`,\nthen `ennreal.of_real C`  bounds the emetric diameter of this set. -/\ntheorem ediam_le_of_forall_dist_le {C : exprℝ} (h : ∀ x ∈ s, ∀ y ∈ s, dist x y ≤ C) :\n    emetric.diam s ≤ ennreal.of_real C :=\n  emetric.diam_le fun x hx y hy => (edist_dist x y).symm ▸ ennreal.of_real_le_of_real (h x hx y hy)\n#align ediam_le_of_forall_dist_le ediam_le_of_forall_dist_le\n\n",
 "eball_top_eq_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n-- see Note [lower instance priority]\n/-- In a pseudometric space, an open ball of infinite radius is the whole space -/\ntheorem metric.eball_top_eq_univ (x : α) : emetric.ball x (ennreal.top) = Set.univ :=\n  Set.eq_univ_iff_forall.mpr fun y => edist_lt_top y x\n#align metric.eball_top_eq_univ metric.eball_top_eq_univ\n\n",
 "dist_up_up":
 "@[simp]\ntheorem ulift.dist_up_up (x y : β) : dist (ulift.up x) (ulift.up y) = dist x y :=\n  rfl\n#align ulift.dist_up_up ulift.dist_up_up\n\n",
 "dist_unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[simp, to_additive]\ntheorem dist_unop (x y : «expr ᵐᵒᵖ» α) : dist (unop x) (unop y) = dist x y :=\n  rfl\n#align dist_unop dist_unop\n\n",
 "dist_triangle_right":
 "theorem dist_triangle_right (x y z : α) : dist x y ≤ dist x z + dist y z := by rw [dist_comm y] <;> apply dist_triangle\n#align dist_triangle_right dist_triangle_right\n\n",
 "dist_triangle_left":
 "theorem dist_triangle_left (x y z : α) : dist x y ≤ dist z x + dist z y := by rw [dist_comm z] <;> apply dist_triangle\n#align dist_triangle_left dist_triangle_left\n\n",
 "dist_triangle4_right":
 "theorem dist_triangle4_right (x₁ y₁ x₂ y₂ : α) : dist x₁ y₁ ≤ dist x₁ x₂ + dist y₁ y₂ + dist x₂ y₂ :=\n  by\n  rw [add_right_comm, dist_comm y₁]\n  apply dist_triangle4\n#align dist_triangle4_right dist_triangle4_right\n\n",
 "dist_triangle4_left":
 "theorem dist_triangle4_left (x₁ y₁ x₂ y₂ : α) : dist x₂ y₂ ≤ dist x₁ y₁ + (dist x₁ x₂ + dist y₁ y₂) :=\n  by\n  rw [add_left_comm, dist_comm x₁, ← add_assoc]\n  apply dist_triangle4\n#align dist_triangle4_left dist_triangle4_left\n\n",
 "dist_triangle4":
 "theorem dist_triangle4 (x y z w : α) : dist x w ≤ dist x y + dist y z + dist z w :=\n  calc\n    dist x w ≤ dist x z + dist z w := dist_triangle x z w\n    _ ≤ dist x y + dist y z + dist z w := add_le_add_right (dist_triangle x y z) _\n    \n#align dist_triangle4 dist_triangle4\n\n",
 "dist_triangle":
 "theorem dist_triangle (x y z : α) : dist x z ≤ dist x y + dist y z :=\n  pseudo_metric_space.dist_triangle x y z\n#align dist_triangle dist_triangle\n\n",
 "dist_to_mul":
 "@[simp]\ntheorem dist_to_mul (a b : Additive X) : dist (toMul a) (toMul b) = dist a b :=\n  rfl\n#align dist_to_mul dist_to_mul\n\n",
 "dist_to_dual":
 "@[simp]\ntheorem dist_to_dual (a b : X) : dist (toDual a) (toDual b) = dist a b :=\n  rfl\n#align dist_to_dual dist_to_dual\n\n",
 "dist_to_add":
 "@[simp]\ntheorem dist_to_add (a b : Multiplicative X) : dist (toAdd a) (toAdd b) = dist a b :=\n  rfl\n#align dist_to_add dist_to_add\n\n",
 "dist_self":
 "-- see Note [lower instance priority]\n@[simp]\ntheorem dist_self (x : α) : dist x x = 0 :=\n  pseudo_metric_space.dist_self x\n#align dist_self dist_self\n\n",
 "dist_right_le_of_mem_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.dist_right_le_of_mem_uIcc {x y z : exprℝ} (h : y ∈ uIcc x z) : dist y z ≤ dist x z := by\n  simpa only [dist_comm _ z] using abs_sub_right_of_mem_uIcc h\n#align real.dist_right_le_of_mem_uIcc real.dist_right_le_of_mem_uIcc\n\n",
 "dist_prod_same_right":
 "@[simp]\ntheorem dist_prod_same_right {x₁ x₂ : α} {y : β} : dist (x₁, y) (x₂, y) = dist x₁ x₂ := by\n  simp [prod.dist_eq, dist_nonneg]\n#align dist_prod_same_right dist_prod_same_right\n\n",
 "dist_prod_same_left":
 "@[simp]\ntheorem dist_prod_same_left {x : α} {y₁ y₂ : β} : dist (x, y₁) (x, y₂) = dist y₁ y₂ := by\n  simp [prod.dist_eq, dist_nonneg]\n#align dist_prod_same_left dist_prod_same_left\n\n",
 "dist_pos":
 "@[simp]\ntheorem dist_pos {x y : γ} : 0 < dist x y ↔ x ≠ y := by simpa only [not_le] using not_congr dist_le_zero\n#align dist_pos dist_pos\n\n",
 "dist_pi_lt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem dist_pi_lt_iff {f g : ∀ b, π b} {r : exprℝ} (hr : 0 < r) : dist f g < r ↔ ∀ b, dist (f b) (g b) < r :=\n  by\n  lift r to nnreal using hr.le\n  simp [dist_pi_def, finset.sup_lt_iff (show «expr⊥» < r from hr)]\n#align dist_pi_lt_iff dist_pi_lt_iff\n\n",
 "dist_pi_le_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem dist_pi_le_iff' [nonempty β] {f g : ∀ b, π b} {r : exprℝ} : dist f g ≤ r ↔ ∀ b, dist (f b) (g b) ≤ r :=\n  by\n  by_cases hr : 0 ≤ r\n  · exact dist_pi_le_iff hr\n  ·\n    exact\n      iff_of_false (fun h => hr <| dist_nonneg.trans h) fun h => hr <| dist_nonneg.trans <| h <| classical.arbitrary _\n#align dist_pi_le_iff' dist_pi_le_iff'\n\n",
 "dist_pi_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem dist_pi_le_iff {f g : ∀ b, π b} {r : exprℝ} (hr : 0 ≤ r) : dist f g ≤ r ↔ ∀ b, dist (f b) (g b) ≤ r :=\n  by\n  lift r to nnreal using hr\n  exact nndist_pi_le_iff\n#align dist_pi_le_iff dist_pi_le_iff\n\n",
 "dist_pi_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem dist_pi_def (f g : ∀ b, π b) : dist f g = (sup univ fun b => nndist (f b) (g b) : nnreal) :=\n  rfl\n#align dist_pi_def dist_pi_def\n\n",
 "dist_pi_const_le":
 "theorem dist_pi_const_le (a b : α) : (dist (fun _ : β => a) fun _ => b) ≤ dist a b :=\n  (dist_pi_le_iff dist_nonneg).2 fun _ => le_rfl\n#align dist_pi_const_le dist_pi_const_le\n\n",
 "dist_pi_const":
 "@[simp]\ntheorem dist_pi_const [nonempty β] (a b : α) : (dist (fun x : β => a) fun _ => b) = dist a b := by\n  simpa only [dist_edist] using congr_arg ennreal.to_real (edist_pi_const a b)\n#align dist_pi_const dist_pi_const\n\n",
 "dist_op":
 "@[simp, to_additive]\ntheorem dist_op (x y : α) : dist (op x) (op y) = dist x y :=\n  rfl\n#align dist_op dist_op\n\n",
 "dist_of_mul":
 "@[simp]\ntheorem dist_of_mul (a b : X) : dist (ofMul a) (ofMul b) = dist a b :=\n  rfl\n#align dist_of_mul dist_of_mul\n\n",
 "dist_of_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem dist_of_dual (a b : «expr ᵒᵈ» X) : dist (ofDual a) (ofDual b) = dist a b :=\n  rfl\n#align dist_of_dual dist_of_dual\n\n",
 "dist_of_add":
 "@[simp]\ntheorem dist_of_add (a b : X) : dist (ofAdd a) (ofAdd b) = dist a b :=\n  rfl\n#align dist_of_add dist_of_add\n\n",
 "dist_nonneg'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n-- the uniform structure and the emetric space structure are embedded in the metric space structure\n-- to avoid instance diamond issues. See Note [forgetful inheritance].\n/-- This is an internal lemma used inside the default of `pseudo_metric_space.edist`. -/\nprivate theorem pseudo_metric_space.dist_nonneg' {α} {x y : α} (dist : α → α → exprℝ)\n    (dist_self : ∀ x : α, dist x x = 0) (dist_comm : ∀ x y : α, dist x y = dist y x)\n    (dist_triangle : ∀ x y z : α, dist x z ≤ dist x y + dist y z) : 0 ≤ dist x y :=\n  have : 2 * dist x y ≥ 0 :=\n    calc\n      2 * dist x y = dist x y + dist y x := by rw [dist_comm x y, two_mul]\n      _ ≥ 0 := by rw [← dist_self x] <;> apply dist_triangle\n      \n  nonneg_of_mul_nonneg_right this zero_lt_two\n#align pseudo_metric_space.dist_nonneg' pseudo_metric_space.dist_nonneg'\n\n",
 "dist_nonneg":
 "theorem dist_nonneg {x y : α} : 0 ≤ dist x y :=\n  pseudo_metric_space.dist_nonneg' dist dist_self dist_comm dist_triangle\n#align dist_nonneg dist_nonneg\n\n",
 "dist_nndist":
 "/-- Express `dist` in terms of `nndist`-/\ntheorem dist_nndist (x y : α) : dist x y = ↑(nndist x y) :=\n  rfl\n#align dist_nndist dist_nndist\n\n",
 "dist_ne_zero":
 "theorem dist_ne_zero {x y : γ} : dist x y ≠ 0 ↔ x ≠ y := by simpa only [not_iff_not] using dist_eq_zero\n#align dist_ne_zero dist_ne_zero\n\n",
 "dist_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- A constant size neighborhood of the diagonal is an entourage. -/\ntheorem dist_mem_uniformity {ε : exprℝ} (ε0 : 0 < ε) : { p : α × α | dist p.1 p.2 < ε } ∈ (uniformity) α :=\n  mem_uniformity_dist.2 ⟨ε, ε0, fun a b => id⟩\n#align dist_mem_uniformity dist_mem_uniformity\n\n",
 "dist_lt_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n@[simp, norm_cast]\ntheorem dist_lt_coe {x y : α} {c : nnreal} : dist x y < c ↔ nndist x y < c :=\n  iff.rfl\n#align dist_lt_coe dist_lt_coe\n\n",
 "dist_lt_add_of_nonempty_closed_ball_inter_ball":
 "theorem dist_lt_add_of_nonempty_closed_ball_inter_ball (h : (closed_ball x ε₁ ∩ ball y ε₂).nonempty) :\n    dist x y < ε₁ + ε₂ :=\n  let ⟨z, hz⟩ := h\n  calc\n    dist x y ≤ dist z x + dist z y := dist_triangle_left _ _ _\n    _ < ε₁ + ε₂ := add_lt_add_of_le_of_lt hz.1 hz.2\n    \n#align dist_lt_add_of_nonempty_closed_ball_inter_ball dist_lt_add_of_nonempty_closed_ball_inter_ball\n\n",
 "dist_lt_add_of_nonempty_ball_inter_closed_ball":
 "theorem dist_lt_add_of_nonempty_ball_inter_closed_ball (h : (ball x ε₁ ∩ closed_ball y ε₂).nonempty) :\n    dist x y < ε₁ + ε₂ := by\n  rw [inter_comm] at h\n  rw [add_comm, dist_comm]\n  exact dist_lt_add_of_nonempty_closed_ball_inter_ball h\n#align dist_lt_add_of_nonempty_ball_inter_closed_ball dist_lt_add_of_nonempty_ball_inter_closed_ball\n\n",
 "dist_lt_add_of_nonempty_ball_inter_ball":
 "theorem dist_lt_add_of_nonempty_ball_inter_ball (h : (ball x ε₁ ∩ ball y ε₂).nonempty) : dist x y < ε₁ + ε₂ :=\n  dist_lt_add_of_nonempty_closed_ball_inter_ball <| h.mono (inter_subset_inter ball_subset_closed_ball Subset.rfl)\n#align dist_lt_add_of_nonempty_ball_inter_ball dist_lt_add_of_nonempty_ball_inter_ball\n\n",
 "dist_left_le_of_mem_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.dist_left_le_of_mem_uIcc {x y z : exprℝ} (h : y ∈ uIcc x z) : dist x y ≤ dist x z := by\n  simpa only [dist_comm x] using abs_sub_left_of_mem_uIcc h\n#align real.dist_left_le_of_mem_uIcc real.dist_left_le_of_mem_uIcc\n\n",
 "dist_le_zero":
 "@[simp]\ntheorem dist_le_zero {x y : γ} : dist x y ≤ 0 ↔ x = y := by\n  simpa [le_antisymm_iff, dist_nonneg] using @dist_eq_zero _ _ x y\n#align dist_le_zero dist_le_zero\n\n",
 "dist_le_range_sum_of_dist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- A version of `dist_le_range_sum_dist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem dist_le_range_sum_of_dist_le {f : ℕ → α} (n : ℕ) {d : ℕ → exprℝ}\n    (hd : ∀ {k}, k < n → dist (f k) (f (k + 1)) ≤ d k) :\n    dist (f 0) (f n) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (d i) :=\n  nat.Ico_zero_eq_range ▸ dist_le_Ico_sum_of_dist_le (zero_le n) fun _ _ => hd\n#align dist_le_range_sum_of_dist_le dist_le_range_sum_of_dist_le\n\n",
 "dist_le_range_sum_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The triangle (polygon) inequality for sequences of points; `finset.range` version. -/\ntheorem dist_le_range_sum_dist (f : ℕ → α) (n : ℕ) :\n    dist (f 0) (f n) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (dist (f i) (f (i + 1))) :=\n  nat.Ico_zero_eq_range ▸ dist_le_Ico_sum_dist f (nat.zero_le n)\n#align dist_le_range_sum_dist dist_le_range_sum_dist\n\n",
 "dist_le_pi_dist":
 "theorem dist_le_pi_dist (f g : ∀ b, π b) (b : β) : dist (f b) (g b) ≤ dist f g := by\n  simp only [dist_nndist, nnreal.coe_le_coe, nndist_le_pi_nndist f g b]\n#align dist_le_pi_dist dist_le_pi_dist\n\n",
 "dist_le_of_mem_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.dist_le_of_mem_uIcc {x y x' y' : exprℝ} (hx : x ∈ uIcc x' y') (hy : y ∈ uIcc x' y') :\n    dist x y ≤ dist x' y' :=\n  abs_sub_le_of_uIcc_subset_uIcc <| uIcc_subset_uIcc (by rwa [uIcc_comm]) (by rwa [uIcc_comm])\n#align real.dist_le_of_mem_uIcc real.dist_le_of_mem_uIcc\n\n",
 "dist_le_of_mem_pi_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.dist_le_of_mem_pi_Icc {x y x' y' : β → exprℝ} (hx : x ∈ Icc x' y') (hy : y ∈ Icc x' y') :\n    dist x y ≤ dist x' y' :=\n  by\n  refine' (dist_pi_le_iff dist_nonneg).2 fun b => (real.dist_le_of_mem_uIcc _ _).trans (dist_le_pi_dist _ _ b) <;>\n    refine' Icc_subset_uIcc _\n  exacts[⟨hx.1 _, hx.2 _⟩, ⟨hy.1 _, hy.2 _⟩]\n#align real.dist_le_of_mem_pi_Icc real.dist_le_of_mem_pi_Icc\n\n",
 "dist_le_of_mem_Icc_01":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.dist_le_of_mem_Icc_01 {x y : exprℝ} (hx : x ∈ Icc (0 : exprℝ) 1) (hy : y ∈ Icc (0 : exprℝ) 1) :\n    dist x y ≤ 1 := by simpa only [sub_zero] using real.dist_le_of_mem_Icc hx hy\n#align real.dist_le_of_mem_Icc_01 real.dist_le_of_mem_Icc_01\n\n",
 "dist_le_of_mem_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.dist_le_of_mem_Icc {x y x' y' : exprℝ} (hx : x ∈ Icc x' y') (hy : y ∈ Icc x' y') : dist x y ≤ y' - x' := by\n  simpa only [real.dist_eq, abs_of_nonpos (sub_nonpos.2 <| hx.1.trans hx.2), neg_sub] using\n    real.dist_le_of_mem_uIcc (Icc_subset_uIcc hx) (Icc_subset_uIcc hy)\n#align real.dist_le_of_mem_Icc real.dist_le_of_mem_Icc\n\n",
 "dist_le_diam_of_mem'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The distance between two points in a set is controlled by the diameter of the set. -/\ntheorem dist_le_diam_of_mem' (h : emetric.diam s ≠ «expr⊤») (hx : x ∈ s) (hy : y ∈ s) : dist x y ≤ diam s :=\n  by\n  rw [diam, dist_edist]\n  rw [ennreal.to_real_le_to_real (edist_ne_top _ _) h]\n  exact emetric.edist_le_diam_of_mem hx hy\n#align dist_le_diam_of_mem' dist_le_diam_of_mem'\n\n",
 "dist_le_diam_of_mem":
 "/-- The distance between two points in a set is controlled by the diameter of the set. -/\ntheorem dist_le_diam_of_mem (h : bounded s) (hx : x ∈ s) (hy : y ∈ s) : dist x y ≤ diam s :=\n  dist_le_diam_of_mem' h.ediam_ne_top hx hy\n#align dist_le_diam_of_mem dist_le_diam_of_mem\n\n",
 "dist_le_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n@[simp, norm_cast]\ntheorem dist_le_coe {x y : α} {c : nnreal} : dist x y ≤ c ↔ nndist x y ≤ c :=\n  iff.rfl\n#align dist_le_coe dist_le_coe\n\n",
 "dist_le_add_of_nonempty_closed_ball_inter_closed_ball":
 "theorem dist_le_add_of_nonempty_closed_ball_inter_closed_ball (h : (closed_ball x ε₁ ∩ closed_ball y ε₂).nonempty) :\n    dist x y ≤ ε₁ + ε₂ :=\n  let ⟨z, hz⟩ := h\n  calc\n    dist x y ≤ dist z x + dist z y := dist_triangle_left _ _ _\n    _ ≤ ε₁ + ε₂ := add_le_add hz.1 hz.2\n    \n#align dist_le_add_of_nonempty_closed_ball_inter_closed_ball dist_le_add_of_nonempty_closed_ball_inter_closed_ball\n\n",
 "dist_le_Ico_sum_of_dist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- A version of `dist_le_Ico_sum_dist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem dist_le_Ico_sum_of_dist_le {f : ℕ → α} {m n} (hmn : m ≤ n) {d : ℕ → exprℝ}\n    (hd : ∀ {k}, m ≤ k → k < n → dist (f k) (f (k + 1)) ≤ d k) :\n    dist (f m) (f n) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (finset.Ico m n)\n        (d i) :=\n  le_trans (dist_le_Ico_sum_dist f hmn) <|\n    finset.sum_le_sum fun k hk => hd (finset.mem_Ico.1 hk).1 (finset.mem_Ico.1 hk).2\n#align dist_le_Ico_sum_of_dist_le dist_le_Ico_sum_of_dist_le\n\n",
 "dist_le_Ico_sum_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The triangle (polygon) inequality for sequences of points; `finset.Ico` version. -/\ntheorem dist_le_Ico_sum_dist (f : ℕ → α) {m n} (h : m ≤ n) :\n    dist (f m) (f n) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (finset.Ico m n)\n        (dist (f i) (f (i + 1))) :=\n  by\n  revert n\n  apply Nat.le_induction\n  · simp only [finset.sum_empty, finset.Ico_self, dist_self]\n  · intro n hn hrec\n    calc\n      dist (f m) (f (n + 1)) ≤ dist (f m) (f n) + dist _ _ := dist_triangle _ _ _\n      _ ≤\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (finset.Ico m n) _ +\n            _ :=\n        add_le_add hrec le_rfl\n      _ =\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (finset.Ico m (n + 1)) _ :=\n        by rw [nat.Ico_succ_right_eq_insert_Ico hn, finset.sum_insert, add_comm] <;> simp\n      \n#align dist_le_Ico_sum_dist dist_le_Ico_sum_dist\n\n",
 "dist_insert_nth_insert_nth":
 "@[simp]\ntheorem fin.dist_insert_nth_insert_nth {n : ℕ} {α : fin (n + 1) → Type _} [∀ i, pseudo_metric_space (α i)]\n    (i : fin (n + 1)) (x y : α i) (f g : ∀ j, α (i.succ_above j)) :\n    dist (i.insert_nth x f) (i.insert_nth y g) = max (dist x y) (dist f g) := by\n  simp only [dist_nndist, fin.nndist_insert_nth_insert_nth, nnreal.coe_max]\n#align fin.dist_insert_nth_insert_nth fin.dist_insert_nth_insert_nth\n\n",
 "dist_eq_zero":
 "@[simp]\ntheorem dist_eq_zero {x y : γ} : dist x y = 0 ↔ x = y :=\n  iff.intro eq_of_dist_eq_zero fun this : x = y => this ▸ dist_self _\n#align dist_eq_zero dist_eq_zero\n\n",
 "dist_eq":
 "theorem prod.dist_eq {x y : α × β} : dist x y = max (dist x.1 y.1) (dist x.2 y.2) :=\n  rfl\n#align prod.dist_eq prod.dist_eq\n\n",
 "dist_edist":
 "/-- Express `dist` in terms of `edist`-/\ntheorem dist_edist (x y : α) : dist x y = (edist x y).to_real := by rw [edist_dist, ennreal.to_real_of_real dist_nonneg]\n#align dist_edist dist_edist\n\n",
 "dist_comm":
 "theorem dist_comm (x y : α) : dist x y = dist y x :=\n  pseudo_metric_space.dist_comm x y\n#align dist_comm dist_comm\n\n",
 "dist_0_eq_abs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.dist_0_eq_abs (x : exprℝ) : dist x 0 = |x| := by simp [real.dist_eq]\n#align real.dist_0_eq_abs real.dist_0_eq_abs\n\n",
 "dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.dist {f g : β → α} {x : filter β} {a b : α} (hf : tendsto f x ((nhds) a))\n    (hg : tendsto g x ((nhds) b)) : tendsto (fun x => dist (f x) (g x)) x ((nhds) (dist a b)) :=\n  (continuous_dist.tendsto (a, b)).comp (hf.prod_mk_nhds hg)\n#align filter.tendsto.dist filter.tendsto.dist\n\n",
 "diam_univ_of_noncompact":
 "@[simp]\ntheorem diam_univ_of_noncompact [proper_space α] [noncompact_space α] : diam (univ : set α) = 0 := by simp [diam]\n#align diam_univ_of_noncompact diam_univ_of_noncompact\n\n",
 "diam_union'":
 "/-- If two sets intersect, the diameter of the union is bounded by the sum of the diameters. -/\ntheorem diam_union' {t : set α} (h : (s ∩ t).nonempty) : diam (s ∪ t) ≤ diam s + diam t :=\n  by\n  rcases h with ⟨x, ⟨xs, xt⟩⟩\n  simpa using diam_union xs xt\n#align diam_union' diam_union'\n\n",
 "diam_union":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr add_nonneg, \",\", expr diam_nonneg, \",\", expr dist_nonneg, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error -/\n/-- The diameter of a union is controlled by the sum of the diameters, and the distance between\nany two points in each of the sets. This lemma is true without any side condition, since it is\nobviously true if `s ∪ t` is unbounded. -/\ntheorem diam_union {t : set α} (xs : x ∈ s) (yt : y ∈ t) : diam (s ∪ t) ≤ diam s + dist x y + diam t :=\n  by\n  by_cases H : bounded (s ∪ t)\n  · have hs : bounded s := H.mono (subset_union_left _ _)\n    have ht : bounded t := H.mono (subset_union_right _ _)\n    rw [bounded_iff_ediam_ne_top] at H hs ht\n    rw [dist_edist, diam, diam, diam, ← ennreal.to_real_add, ← ennreal.to_real_add, ennreal.to_real_le_to_real] <;>\n          repeat' apply ennreal.add_ne_top.2 <;> constructor <;>\n        try assumption <;>\n      try apply edist_ne_top\n    exact emetric.diam_union xs yt\n  · rw [diam_eq_zero_of_unbounded H]\n    trace\n      \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\\\"[\\\", expr add_nonneg, \\\",\\\", expr diam_nonneg, \\\",\\\", expr dist_nonneg, \\\"]\\\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error\"\n#align diam_union diam_union\n\n",
 "diam_triple":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr ne_of_lt, \",\", expr edist_lt_top, \",\", expr max_lt, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error -/\n-- Does not work as a simp-lemma, since {x, y, z} reduces to (insert z (insert y {x}))\ntheorem diam_triple : metric.diam ({x, y, z} : set α) = max (max (dist x y) (dist x z)) (dist y z) :=\n  by\n  simp only [metric.diam, emetric.diam_triple, dist_edist]\n  rw [ennreal.to_real_max, ennreal.to_real_max] <;>\n    trace\n      \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\\\"[\\\", expr ne_of_lt, \\\",\\\", expr edist_lt_top, \\\",\\\", expr max_lt, \\\"]\\\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error\"\n#align diam_triple diam_triple\n\n",
 "diam_subsingleton":
 "theorem diam_subsingleton (hs : s.subsingleton) : diam s = 0 := by\n  simp only [diam, emetric.diam_subsingleton hs, ennreal.zero_to_real]\n#align diam_subsingleton diam_subsingleton\n\n",
 "diam_singleton":
 "/-- A singleton has zero diameter -/\n@[simp]\ntheorem diam_singleton : diam ({x} : set α) = 0 :=\n  diam_subsingleton subsingleton_singleton\n#align diam_singleton diam_singleton\n\n",
 "diam_pair":
 "-- Does not work as a simp-lemma, since {x, y} reduces to (insert y {x})\ntheorem diam_pair : diam ({x, y} : set α) = dist x y := by simp only [diam, emetric.diam_pair, dist_edist]\n#align diam_pair diam_pair\n\n",
 "diam_nonneg":
 "/-- The diameter of a set is always nonnegative -/\ntheorem diam_nonneg : 0 ≤ diam s :=\n  ennreal.to_real_nonneg\n#align diam_nonneg diam_nonneg\n\n",
 "diam_mono":
 "/-- If `s ⊆ t`, then the diameter of `s` is bounded by that of `t`, provided `t` is bounded. -/\ntheorem diam_mono {s t : set α} (h : s ⊆ t) (ht : bounded t) : diam s ≤ diam t :=\n  by\n  unfold diam\n  rw [ennreal.to_real_le_to_real (bounded.mono h ht).ediam_ne_top ht.ediam_ne_top]\n  exact emetric.diam_mono h\n#align diam_mono diam_mono\n\n",
 "diam_le_of_subset_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem diam_le_of_subset_closed_ball {r : exprℝ} (hr : 0 ≤ r) (h : s ⊆ closed_ball x r) : diam s ≤ 2 * r :=\n  diam_le_of_forall_dist_le (mul_nonneg zero_le_two hr) fun a ha b hb =>\n    calc\n      dist a b ≤ dist a x + dist b x := dist_triangle_right _ _ _\n      _ ≤ r + r := add_le_add (h ha) (h hb)\n      _ = 2 * r := by simp [mul_two, mul_comm]\n      \n#align diam_le_of_subset_closed_ball diam_le_of_subset_closed_ball\n\n",
 "diam_le_of_forall_dist_le_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If the distance between any two points in a nonempty set is bounded by some constant,\nthis constant bounds the diameter. -/\ntheorem diam_le_of_forall_dist_le_of_nonempty (hs : s.nonempty) {C : exprℝ} (h : ∀ x ∈ s, ∀ y ∈ s, dist x y ≤ C) :\n    diam s ≤ C :=\n  have h₀ : 0 ≤ C :=\n    let ⟨x, hx⟩ := hs\n    le_trans dist_nonneg (h x hx x hx)\n  diam_le_of_forall_dist_le h₀ h\n#align diam_le_of_forall_dist_le_of_nonempty diam_le_of_forall_dist_le_of_nonempty\n\n",
 "diam_le_of_forall_dist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If the distance between any two points in a set is bounded by some non-negative constant,\nthis constant bounds the diameter. -/\ntheorem diam_le_of_forall_dist_le {C : exprℝ} (h₀ : 0 ≤ C) (h : ∀ x ∈ s, ∀ y ∈ s, dist x y ≤ C) : diam s ≤ C :=\n  ennreal.to_real_le_of_le_of_real h₀ (ediam_le_of_forall_dist_le h)\n#align diam_le_of_forall_dist_le diam_le_of_forall_dist_le\n\n",
 "diam_eq_zero_of_unbounded":
 "/-- An unbounded set has zero diameter. If you would prefer to get the value ∞, use `emetric.diam`.\nThis lemma makes it possible to avoid side conditions in some situations -/\ntheorem diam_eq_zero_of_unbounded (h : ¬bounded s) : diam s = 0 := by\n  rw [diam, ediam_of_unbounded h, ennreal.top_to_real]\n#align diam_eq_zero_of_unbounded diam_eq_zero_of_unbounded\n\n",
 "diam_empty":
 "/-- The empty set has zero diameter -/\n@[simp]\ntheorem diam_empty : diam (∅ : set α) = 0 :=\n  diam_subsingleton subsingleton_empty\n#align diam_empty diam_empty\n\n",
 "diam_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The diameter of a closed ball of radius `r` is at most `2 r`. -/\ntheorem diam_closed_ball {r : exprℝ} (h : 0 ≤ r) : diam (closed_ball x r) ≤ 2 * r :=\n  diam_le_of_subset_closed_ball h Subset.rfl\n#align diam_closed_ball diam_closed_ball\n\n",
 "diam_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The diameter of a ball of radius `r` is at most `2 r`. -/\ntheorem diam_ball {r : exprℝ} (h : 0 ≤ r) : diam (ball x r) ≤ 2 * r :=\n  diam_le_of_subset_closed_ball h ball_subset_closed_ball\n#align diam_ball diam_ball\n\n",
 "dense_range_iff":
 "theorem dense_range_iff {f : β → α} : dense_range f ↔ ∀ x, ∀ r > 0, ∃ y, dist x (f y) < r :=\n  forall_congr' fun x => by simp only [mem_closure_iff, exists_range_iff]\n#align dense_range_iff dense_range_iff\n\n",
 "dense_iff":
 "theorem dense_iff {s : set α} : dense s ↔ ∀ x, ∀ r > 0, (ball x r ∩ s).nonempty :=\n  forall_congr' fun x => by simp only [mem_closure_iff, Set.Nonempty, exists_prop, mem_inter_iff, mem_ball', and_comm']\n#align dense_iff dense_iff\n\n",
 "controlled_of_uniform_embedding":
 "/-- If a map between pseudometric spaces is a uniform embedding then the distance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y`. -/\ntheorem controlled_of_uniform_embedding [pseudo_metric_space β] {f : α → β} :\n    uniform_embedding f →\n      (∀ ε > 0, ∃ δ > 0, ∀ {a b : α}, dist a b < δ → dist (f a) (f b) < ε) ∧\n        ∀ δ > 0, ∃ ε > 0, ∀ {a b : α}, dist (f a) (f b) < ε → dist a b < δ :=\n  by\n  intro h\n  exact ⟨uniform_continuous_iff.1 (uniform_embedding_iff.1 h).2.1, (uniform_embedding_iff.1 h).2.2⟩\n#align controlled_of_uniform_embedding controlled_of_uniform_embedding\n\n",
 "continuous_within_at_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem continuous_within_at_iff' [topological_space β] {f : β → α} {b : β} {s : set β} :\n    continuous_within_at f s b ↔\n      ∀ ε > 0,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          (nhds_within s b) (dist (f x) (f b) < ε) :=\n  by rw [continuous_within_at, tendsto_nhds]\n#align continuous_within_at_iff' continuous_within_at_iff'\n\n",
 "continuous_within_at_iff":
 "theorem continuous_within_at_iff [pseudo_metric_space β] {f : α → β} {a : α} {s : set α} :\n    continuous_within_at f s a ↔ ∀ ε > 0, ∃ δ > 0, ∀ {x : α}, x ∈ s → dist x a < δ → dist (f x) (f a) < ε := by\n  rw [continuous_within_at, tendsto_nhds_within_nhds]\n#align continuous_within_at_iff continuous_within_at_iff\n\n",
 "continuous_on_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem continuous_on_iff' [topological_space β] {f : β → α} {s : set β} :\n    continuous_on f s ↔\n      ∀ b ∈ s,\n        ∀ ε > 0,\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n            (nhds_within s b) (dist (f x) (f b) < ε) :=\n  by simp [continuous_on, continuous_within_at_iff']\n#align continuous_on_iff' continuous_on_iff'\n\n",
 "continuous_on_iff":
 "theorem continuous_on_iff [pseudo_metric_space β] {f : α → β} {s : set α} :\n    continuous_on f s ↔ ∀ b ∈ s, ∀ ε > 0, ∃ δ > 0, ∀ a ∈ s, dist a b < δ → dist (f a) (f b) < ε := by\n  simp [continuous_on, continuous_within_at_iff]\n#align continuous_on_iff continuous_on_iff\n\n",
 "continuous_nndist":
 "theorem continuous_nndist : continuous fun p : α × α => nndist p.1 p.2 :=\n  uniform_continuous_nndist.continuous\n#align continuous_nndist continuous_nndist\n\n",
 "continuous_iff_continuous_dist":
 "theorem continuous_iff_continuous_dist [topological_space β] {f : β → α} :\n    continuous f ↔ continuous fun x : β × β => dist (f x.1) (f x.2) :=\n  ⟨fun h => (h.comp continuous_fst).dist (h.comp continuous_snd), fun h =>\n    continuous_iff_continuous_at.2 fun x =>\n      tendsto_iff_dist_tendsto_zero.2 <| (h.comp (continuous_id.prod_mk continuous_const)).tendsto' _ _ <| dist_self _⟩\n#align continuous_iff_continuous_dist continuous_iff_continuous_dist\n\n",
 "continuous_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_iff' [topological_space β] {f : β → α} :\n    continuous f ↔\n      ∀ (a),\n        ∀ ε > 0,\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n            ((nhds) a) (dist (f x) (f a) < ε) :=\n  continuous_iff_continuous_at.trans <| forall_congr' fun b => tendsto_nhds\n#align continuous_iff' continuous_iff'\n\n",
 "continuous_iff":
 "theorem continuous_iff [pseudo_metric_space β] {f : α → β} :\n    continuous f ↔ ∀ (b), ∀ ε > 0, ∃ δ > 0, ∀ a, dist a b < δ → dist (f a) (f b) < ε :=\n  continuous_iff_continuous_at.trans <| forall_congr' fun b => tendsto_nhds_nhds\n#align continuous_iff continuous_iff\n\n",
 "continuous_dist":
 "@[continuity]\ntheorem continuous_dist : continuous fun p : α × α => dist p.1 p.2 :=\n  uniform_continuous_dist.continuous\n#align continuous_dist continuous_dist\n\n",
 "continuous_at_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_at_iff' [topological_space β] {f : β → α} {b : β} :\n    continuous_at f b ↔\n      ∀ ε > 0,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          ((nhds) b) (dist (f x) (f b) < ε) :=\n  by rw [continuous_at, tendsto_nhds]\n#align continuous_at_iff' continuous_at_iff'\n\n",
 "continuous_at_iff":
 "theorem continuous_at_iff [pseudo_metric_space β] {f : α → β} {a : α} :\n    continuous_at f a ↔ ∀ ε > 0, ∃ δ > 0, ∀ {x : α}, dist x a < δ → dist (f x) (f a) < ε := by\n  rw [continuous_at, tendsto_nhds_nhds]\n#align continuous_at_iff continuous_at_iff\n\n",
 "congr_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.congr_dist {ι : Type _} {f₁ f₂ : ι → α} {p : filter ι} {a : α} (h₁ : tendsto f₁ p ((nhds) a))\n    (h : tendsto (fun x => dist (f₁ x) (f₂ x)) p ((nhds) 0)) : tendsto f₂ p ((nhds) a) :=\n  h₁.congr_uniformity <| tendsto_uniformity_iff_dist_tendsto_zero.2 h\n#align filter.tendsto.congr_dist filter.tendsto.congr_dist\n\n",
 "complete_of_convergent_controlled_sequences":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A very useful criterion to show that a space is complete is to show that all sequences\nwhich satisfy a bound of the form `dist (u n) (u m) < B N` for all `n m ≥ N` are\nconverging. This is often applied for `B N = 2^{-N}`, i.e., with a very fast convergence to\n`0`, which makes it possible to use arguments of converging series, while this is impossible\nto do in general for arbitrary Cauchy sequences. -/\ntheorem metric.complete_of_convergent_controlled_sequences (B : ℕ → real) (hB : ∀ n, 0 < B n)\n    (H : ∀ u : ℕ → α, (∀ N n m : ℕ, N ≤ n → N ≤ m → dist (u n) (u m) < B N) → ∃ x, tendsto u at_top ((nhds) x)) :\n    complete_space α :=\n  uniform_space.complete_of_convergent_controlled_sequences (fun n => { p : α × α | dist p.1 p.2 < B n })\n    (fun n => dist_mem_uniformity <| hB n) H\n#align metric.complete_of_convergent_controlled_sequences metric.complete_of_convergent_controlled_sequences\n\n",
 "complete_of_cauchy_seq_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem metric.complete_of_cauchy_seq_tendsto :\n    (∀ u : ℕ → α, cauchy_seq u → ∃ a, tendsto u at_top ((nhds) a)) → complete_space α :=\n  emetric.complete_of_cauchy_seq_tendsto\n#align metric.complete_of_cauchy_seq_tendsto metric.complete_of_cauchy_seq_tendsto\n\n",
 "compact_space_iff_bounded_univ":
 "theorem compact_space_iff_bounded_univ [proper_space α] : compact_space α ↔ bounded (univ : set α) :=\n  ⟨@bounded_of_compact_space α _ _, fun hb => ⟨is_compact_of_is_closed_bounded is_closed_univ hb⟩⟩\n#align compact_space_iff_bounded_univ compact_space_iff_bounded_univ\n\n",
 "comap_dist_right_at_top_le_cocompact":
 "theorem comap_dist_right_at_top_le_cocompact (x : α) : comap (fun y => dist y x) at_top ≤ cocompact α :=\n  by\n  refine' filter.has_basis_cocompact.ge_iff.2 fun s hs => mem_comap.2 _\n  rcases hs.bounded.subset_ball x with ⟨r, hr⟩\n  exact ⟨Ioi r, Ioi_mem_at_top r, fun y hy hys => (mem_closed_ball.1 <| hr hys).not_lt hy⟩\n#align comap_dist_right_at_top_le_cocompact comap_dist_right_at_top_le_cocompact\n\n",
 "comap_dist_right_at_top_eq_cocompact":
 "theorem comap_dist_right_at_top_eq_cocompact [proper_space α] (x : α) :\n    comap (fun y => dist y x) at_top = cocompact α :=\n  (comap_dist_right_at_top_le_cocompact x).antisymm <| (tendsto_dist_right_cocompact_at_top x).le_comap\n#align comap_dist_right_at_top_eq_cocompact comap_dist_right_at_top_eq_cocompact\n\n",
 "comap_dist_left_at_top_le_cocompact":
 "theorem comap_dist_left_at_top_le_cocompact (x : α) : comap (dist x) at_top ≤ cocompact α := by\n  simpa only [dist_comm _ x] using comap_dist_right_at_top_le_cocompact x\n#align comap_dist_left_at_top_le_cocompact comap_dist_left_at_top_le_cocompact\n\n",
 "comap_dist_left_at_top_eq_cocompact":
 "theorem comap_dist_left_at_top_eq_cocompact [proper_space α] (x : α) : comap (dist x) at_top = cocompact α :=\n  (comap_dist_left_at_top_le_cocompact x).antisymm <| (tendsto_dist_left_cocompact_at_top x).le_comap\n#align comap_dist_left_at_top_eq_cocompact comap_dist_left_at_top_eq_cocompact\n\n",
 "coe_nnreal_ennreal_nndist":
 "@[simp, norm_cast]\ntheorem coe_nnreal_ennreal_nndist (x y : α) : ↑(nndist x y) = edist x y :=\n  (edist_nndist x y).symm\n#align coe_nnreal_ennreal_nndist coe_nnreal_ennreal_nndist\n\n",
 "coe_nndist":
 "@[simp, norm_cast]\ntheorem coe_nndist (x y : α) : ↑(nndist x y) = dist x y :=\n  (dist_nndist x y).symm\n#align coe_nndist coe_nndist\n\n",
 "closure_closed_ball":
 "@[simp]\ntheorem closure_closed_ball : closure (closed_ball x ε) = closed_ball x ε :=\n  is_closed_ball.closure_eq\n#align closure_closed_ball closure_closed_ball\n\n",
 "closure_ball_subset_closed_ball":
 "theorem closure_ball_subset_closed_ball : closure (ball x ε) ⊆ closed_ball x ε :=\n  closure_minimal ball_subset_closed_ball is_closed_ball\n#align closure_ball_subset_closed_ball closure_ball_subset_closed_ball\n\n",
 "closed_embedding_of_pairwise_le_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem closed_embedding_of_pairwise_le_dist {α : Type _} [topological_space α] [discrete_topology α] {ε : exprℝ}\n    (hε : 0 < ε) {f : α → γ} (hf : Pairwise fun x y => ε ≤ dist (f x) (f y)) : closed_embedding f :=\n  closed_embedding_of_spaced_out (dist_mem_uniformity hε) <| by simpa using hf\n#align closed_embedding_of_pairwise_le_dist closed_embedding_of_pairwise_le_dist\n\n",
 "closed_ball_zero'":
 "theorem closed_ball_zero' (x : α) : closed_ball x 0 = closure {x} :=\n  Subset.antisymm (fun y hy => mem_closure_iff.2 fun ε ε0 => ⟨x, mem_singleton x, (mem_closed_ball.1 hy).trans_lt ε0⟩)\n    (closure_minimal (singleton_subset_iff.2 (dist_self x).le) is_closed_ball)\n#align closed_ball_zero' closed_ball_zero'\n\n",
 "closed_ball_zero":
 "@[simp]\ntheorem closed_ball_zero : closed_ball x 0 = {x} :=\n  Set.ext fun y => dist_le_zero\n#align closed_ball_zero closed_ball_zero\n\n",
 "closed_ball_subset_closed_ball'":
 "theorem closed_ball_subset_closed_ball' (h : ε₁ + dist x y ≤ ε₂) : closed_ball x ε₁ ⊆ closed_ball y ε₂ := fun z hz =>\n  calc\n    dist z y ≤ dist z x + dist x y := dist_triangle _ _ _\n    _ ≤ ε₁ + dist x y := add_le_add_right hz _\n    _ ≤ ε₂ := h\n    \n#align closed_ball_subset_closed_ball' closed_ball_subset_closed_ball'\n\n",
 "closed_ball_subset_closed_ball":
 "theorem closed_ball_subset_closed_ball (h : ε₁ ≤ ε₂) : closed_ball x ε₁ ⊆ closed_ball x ε₂ := fun y (yx : _ ≤ ε₁) =>\n  le_trans yx h\n#align closed_ball_subset_closed_ball closed_ball_subset_closed_ball\n\n",
 "closed_ball_subset_ball'":
 "theorem closed_ball_subset_ball' (h : ε₁ + dist x y < ε₂) : closed_ball x ε₁ ⊆ ball y ε₂ := fun z hz =>\n  calc\n    dist z y ≤ dist z x + dist x y := dist_triangle _ _ _\n    _ ≤ ε₁ + dist x y := add_le_add_right hz _\n    _ < ε₂ := h\n    \n#align closed_ball_subset_ball' closed_ball_subset_ball'\n\n",
 "closed_ball_subset_ball":
 "theorem closed_ball_subset_ball (h : ε₁ < ε₂) : closed_ball x ε₁ ⊆ ball x ε₂ := fun y (yh : dist y x ≤ ε₁) =>\n  lt_of_le_of_lt yh h\n#align closed_ball_subset_ball closed_ball_subset_ball\n\n",
 "closed_ball_prod_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem closed_ball_prod_same (x : α) (y : β) (r : exprℝ) :\n    lower_set.prod (closed_ball x r) (closed_ball y r) = closed_ball (x, y) r :=\n  ext fun z => by simp [prod.dist_eq]\n#align closed_ball_prod_same closed_ball_prod_same\n\n",
 "closed_ball_pi'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A closed ball in a product space is a product of closed balls. See also `metric.closed_ball_pi`\nfor a version assuming `0 ≤ r` instead of `nonempty β`. -/\ntheorem closed_ball_pi' [nonempty β] (x : ∀ b, π b) (r : exprℝ) :\n    closed_ball x r = Set.pi univ fun b => closed_ball (x b) r :=\n  (le_or_lt 0 r).elim (closed_ball_pi x) fun hr => by simp [closed_ball_eq_empty.2 hr]\n#align closed_ball_pi' closed_ball_pi'\n\n",
 "closed_ball_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A closed ball in a product space is a product of closed balls. See also `metric.closed_ball_pi'`\nfor a version assuming `nonempty β` instead of `0 ≤ r`. -/\ntheorem closed_ball_pi (x : ∀ b, π b) {r : exprℝ} (hr : 0 ≤ r) :\n    closed_ball x r = Set.pi univ fun b => closed_ball (x b) r :=\n  by\n  ext p\n  simp [dist_pi_le_iff hr]\n#align closed_ball_pi closed_ball_pi\n\n",
 "closed_ball_mem_nhds_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem closed_ball_mem_nhds_of_mem {x c : α} {ε : exprℝ} (h : x ∈ ball c ε) : closed_ball c ε ∈ (nhds) x :=\n  mem_of_superset (is_open_ball.mem_nhds h) ball_subset_closed_ball\n#align closed_ball_mem_nhds_of_mem closed_ball_mem_nhds_of_mem\n\n",
 "closed_ball_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem closed_ball_mem_nhds (x : α) {ε : exprℝ} (ε0 : 0 < ε) : closed_ball x ε ∈ (nhds) x :=\n  mem_of_superset (ball_mem_nhds x ε0) ball_subset_closed_ball\n#align closed_ball_mem_nhds closed_ball_mem_nhds\n\n",
 "closed_ball_eq_empty":
 "@[simp]\ntheorem closed_ball_eq_empty : closed_ball x ε = ∅ ↔ ε < 0 := by\n  rw [← not_nonempty_iff_eq_empty, nonempty_closed_ball, not_le]\n#align closed_ball_eq_empty closed_ball_eq_empty\n\n",
 "closed_ball_eq_bInter_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem closed_ball_eq_bInter_ball :\n    closed_ball x ε =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (ball x δ) :=\n  by ext y <;> rw [mem_closed_ball, ← forall_lt_iff_le', mem_Inter₂] <;> rfl\n#align closed_ball_eq_bInter_ball closed_ball_eq_bInter_ball\n\n",
 "closed_ball_eq_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.closed_ball_eq_Icc {x r : exprℝ} : closed_ball x r = Icc (x - r) (x + r) := by\n  ext y <;> rw [mem_closed_ball, dist_comm, real.dist_eq, abs_sub_le_iff, mem_Icc, ← sub_le_iff_le_add', sub_le_comm]\n#align real.closed_ball_eq_Icc real.closed_ball_eq_Icc\n\n",
 "closed_ball_disjoint_closed_ball":
 "theorem closed_ball_disjoint_closed_ball (h : δ + ε < dist x y) : Disjoint (closed_ball x δ) (closed_ball y ε) :=\n  Set.disjoint_left.mpr fun a ha1 ha2 => h.not_le <| (dist_triangle_left _ _ _).trans <| add_le_add ha1 ha2\n#align closed_ball_disjoint_closed_ball closed_ball_disjoint_closed_ball\n\n",
 "closed_ball_disjoint_ball":
 "theorem closed_ball_disjoint_ball (h : δ + ε ≤ dist x y) : Disjoint (closed_ball x δ) (ball y ε) :=\n  Set.disjoint_left.mpr fun a ha1 ha2 => (h.trans <| dist_triangle_left _ _ _).not_lt <| add_lt_add_of_le_of_lt ha1 ha2\n#align closed_ball_disjoint_ball closed_ball_disjoint_ball\n\n",
 "closed_ball_diff_sphere":
 "@[simp]\ntheorem closed_ball_diff_sphere : closed_ball x ε \\ sphere x ε = ball x ε := by\n  rw [← ball_union_sphere, Set.union_diff_cancel_right sphere_disjoint_ball.symm.le_bot]\n#align closed_ball_diff_sphere closed_ball_diff_sphere\n\n",
 "closed_ball_diff_ball":
 "@[simp]\ntheorem closed_ball_diff_ball : closed_ball x ε \\ ball x ε = sphere x ε := by\n  rw [← ball_union_sphere, Set.union_diff_cancel_left sphere_disjoint_ball.symm.le_bot]\n#align closed_ball_diff_ball closed_ball_diff_ball\n\n",
 "cauchy_seq_of_le_tendsto_0'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If the distance between `s n` and `s m`, `n ≤ m` is bounded above by `b n`\nand `b` converges to zero, then `s` is a Cauchy sequence.  -/\ntheorem cauchy_seq_of_le_tendsto_0' {s : β → α} (b : β → exprℝ) (h : ∀ n m : β, n ≤ m → dist (s n) (s m) ≤ b n)\n    (h₀ : tendsto b at_top ((nhds) 0)) : cauchy_seq s :=\n  metric.cauchy_seq_iff'.2 fun ε ε0 =>\n    (h₀.eventually (gt_mem_nhds ε0)).exists.imp fun N hN n hn =>\n      calc\n        dist (s n) (s N) = dist (s N) (s n) := dist_comm _ _\n        _ ≤ b N := h _ _ hn\n        _ < ε := hN\n        \n#align cauchy_seq_of_le_tendsto_0' cauchy_seq_of_le_tendsto_0'\n\n",
 "cauchy_seq_of_le_tendsto_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If the distance between `s n` and `s m`, `n, m ≥ N` is bounded above by `b N`\nand `b` converges to zero, then `s` is a Cauchy sequence.  -/\ntheorem cauchy_seq_of_le_tendsto_0 {s : β → α} (b : β → exprℝ) (h : ∀ n m N : β, N ≤ n → N ≤ m → dist (s n) (s m) ≤ b N)\n    (h₀ : tendsto b at_top ((nhds) 0)) : cauchy_seq s :=\n  cauchy_seq_of_le_tendsto_0' b (fun n m hnm => h _ _ _ le_rfl hnm) h₀\n#align cauchy_seq_of_le_tendsto_0 cauchy_seq_of_le_tendsto_0\n\n",
 "cauchy_seq_iff_tendsto_dist_at_top_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cauchy_seq_iff_tendsto_dist_at_top_0 [nonempty β] [SemilatticeSup β] {u : β → α} :\n    cauchy_seq u ↔ tendsto (fun n : β × β => dist (u n.1) (u n.2)) at_top ((nhds) 0) := by\n  rw [cauchy_seq_iff_tendsto, metric.uniformity_eq_comap_nhds_zero, tendsto_comap_iff, prod.map_def]\n#align cauchy_seq_iff_tendsto_dist_at_top_0 cauchy_seq_iff_tendsto_dist_at_top_0\n\n",
 "cauchy_seq_iff_le_tendsto_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Yet another metric characterization of Cauchy sequences on integers. This one is often the\nmost efficient. -/\ntheorem cauchy_seq_iff_le_tendsto_0 {s : ℕ → α} :\n    cauchy_seq s ↔\n      ∃ b : ℕ → exprℝ,\n        (∀ n, 0 ≤ b n) ∧ (∀ n m N : ℕ, N ≤ n → N ≤ m → dist (s n) (s m) ≤ b N) ∧ tendsto b at_top ((nhds) 0) :=\n  ⟨fun hs =>\n    by\n    /- `s` is a Cauchy sequence. The sequence `b` will be constructed by taking\n      the supremum of the distances between `s n` and `s m` for `n m ≥ N`.\n      First, we prove that all these distances are bounded, as otherwise the Sup\n      would not make sense. -/\n    let S N := «expr '' » (fun p : ℕ × ℕ => dist (s p.1) (s p.2)) { p | p.1 ≥ N ∧ p.2 ≥ N }\n    have hS : ∀ N, ∃ x, ∀ y ∈ S N, y ≤ x :=\n      by\n      rcases cauchy_seq_bdd hs with ⟨R, R0, hR⟩\n      refine' fun N => ⟨R, _⟩\n      rintro _ ⟨⟨m, n⟩, _, rfl⟩\n      exact le_of_lt (hR m n)\n    have bdd : BddAbove (range fun p : ℕ × ℕ => dist (s p.1) (s p.2)) :=\n      by\n      rcases cauchy_seq_bdd hs with ⟨R, R0, hR⟩\n      use R\n      rintro _ ⟨⟨m, n⟩, rfl⟩\n      exact le_of_lt (hR m n)\n    -- Prove that it bounds the distances of points in the Cauchy sequence\n    have ub : ∀ m n N, N ≤ m → N ≤ n → dist (s m) (s n) ≤ Sup (S N) := fun m n N hm hn =>\n      le_csupₛ (hS N) ⟨⟨_, _⟩, ⟨hm, hn⟩, rfl⟩\n    have S0m : ∀ n, (0 : exprℝ) ∈ S n := fun n => ⟨⟨n, n⟩, ⟨le_rfl, le_rfl⟩, dist_self _⟩\n    have S0 := fun n => le_csupₛ (hS n) (S0m n)\n    -- Prove that it tends to `0`, by using the Cauchy property of `s`\n    refine' ⟨fun N => Sup (S N), S0, ub, metric.tendsto_at_top.2 fun ε ε0 => _⟩\n    refine' (metric.cauchy_seq_iff.1 hs (ε / 2) (half_pos ε0)).imp fun N hN n hn => _\n    rw [real.dist_0_eq_abs, abs_of_nonneg (S0 n)]\n    refine' lt_of_le_of_lt (csupₛ_le ⟨_, S0m _⟩ _) (half_lt_self ε0)\n    rintro _ ⟨⟨m', n'⟩, ⟨hm', hn'⟩, rfl⟩\n    exact le_of_lt (hN _ (le_trans hn hm') _ (le_trans hn hn')), fun ⟨b, _, b_bound, b_lim⟩ =>\n    cauchy_seq_of_le_tendsto_0 b b_bound b_lim⟩\n#align cauchy_seq_iff_le_tendsto_0 cauchy_seq_iff_le_tendsto_0\n\n",
 "cauchy_seq_iff'":
 "/-- A variation around the pseudometric characterization of Cauchy sequences -/\ntheorem metric.cauchy_seq_iff' {u : β → α} : cauchy_seq u ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, dist (u n) (u N) < ε :=\n  uniformity_basis_dist.cauchy_seq_iff'\n#align metric.cauchy_seq_iff' metric.cauchy_seq_iff'\n\n",
 "cauchy_seq_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (m n «expr ≥ » N) -/\n-- see Note [nolint_ge]\n/-- In a pseudometric space, Cauchy sequences are characterized by the fact that, eventually,\nthe distance between its elements is arbitrarily small -/\n@[nolint ge_or_gt]\ntheorem metric.cauchy_seq_iff {u : β → α} :\n    cauchy_seq u ↔ ∀ ε > 0, ∃ N, ∀ (m) (_ : m ≥ N) (n) (_ : n ≥ N), dist (u m) (u n) < ε :=\n  uniformity_basis_dist.cauchy_seq_iff\n#align metric.cauchy_seq_iff metric.cauchy_seq_iff\n\n",
 "cauchy_seq_bdd":
 "/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem cauchy_seq_bdd {u : ℕ → α} (hu : cauchy_seq u) : ∃ R > 0, ∀ m n, dist (u m) (u n) < R :=\n  by\n  rcases metric.cauchy_seq_iff'.1 hu 1 zero_lt_one with ⟨N, hN⟩\n  rsuffices ⟨R, R0, H⟩ : ∃ R > 0, ∀ n, dist (u n) (u N) < R\n  · exact ⟨_, add_pos R0 R0, fun m n => lt_of_le_of_lt (dist_triangle_right _ _ _) (add_lt_add (H m) (H n))⟩\n  let R := finset.sup (Finset.range N) fun n => nndist (u n) (u N)\n  refine' ⟨↑R + 1, add_pos_of_nonneg_of_pos R.2 zero_lt_one, fun n => _⟩\n  cases le_or_lt N n\n  · exact lt_of_lt_of_le (hN _ h) (le_add_of_nonneg_left R.2)\n  · have : _ ≤ R := finset.le_sup (Finset.mem_range.2 h)\n    exact lt_of_le_of_lt this (lt_add_of_pos_right _ zero_lt_one)\n#align cauchy_seq_bdd cauchy_seq_bdd\n\n",
 "cauchy_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x y «expr ∈ » t) -/\nprotected theorem cauchy_iff {f : filter α} :\n    cauchy f ↔ ne_bot f ∧ ∀ ε > 0, ∃ t ∈ f, ∀ (x) (_ : x ∈ t) (y) (_ : y ∈ t), dist x y < ε :=\n  uniformity_basis_dist.cauchy_iff\n#align cauchy_iff cauchy_iff\n\n",
 "bounded_union":
 "/-- The union of two sets is bounded iff each of the sets is bounded. -/\n@[simp]\ntheorem bounded_union : bounded (s ∪ t) ↔ bounded s ∧ bounded t :=\n  ⟨fun h => ⟨h.mono (by simp), h.mono (by simp)⟩, fun h => h.1.union h.2⟩\n#align bounded_union bounded_union\n\n",
 "bounded_sphere":
 "/-- Spheres are bounded -/\ntheorem bounded_sphere : bounded (sphere x r) :=\n  bounded_closed_ball.mono sphere_subset_closed_ball\n#align bounded_sphere bounded_sphere\n\n",
 "bounded_singleton":
 "/-- A singleton is bounded -/\ntheorem bounded_singleton {x : α} : bounded ({x} : set α) :=\n  bounded_of_finite <| finite_singleton _\n#align bounded_singleton bounded_singleton\n\n",
 "bounded_range_of_tendsto_cofinite_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem bounded_range_of_tendsto_cofinite_uniformity {f : β → α}\n    (hf : tendsto (prod.map f f) (filter.prod cofinite cofinite) ((uniformity) α)) : bounded (range f) :=\n  by\n  rcases(has_basis_cofinite.prod_self.tendsto_iff uniformity_basis_dist).1 hf 1 zero_lt_one with ⟨s, hsf, hs1⟩\n  rw [← image_univ, ← union_compl_self s, image_union, bounded_union]\n  use (hsf.image f).bounded, 1\n  rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩\n  exact le_of_lt (hs1 (x, y) ⟨hx, hy⟩)\n#align bounded_range_of_tendsto_cofinite_uniformity bounded_range_of_tendsto_cofinite_uniformity\n\n",
 "bounded_range_of_tendsto_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem bounded_range_of_tendsto_cofinite {f : β → α} {a : α} (hf : tendsto f cofinite ((nhds) a)) :\n    bounded (range f) :=\n  bounded_range_of_tendsto_cofinite_uniformity <|\n    (hf.prod_map hf).mono_right <| nhds_prod_eq.symm.trans_le (nhds_le_uniformity a)\n#align bounded_range_of_tendsto_cofinite bounded_range_of_tendsto_cofinite\n\n",
 "bounded_range_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem bounded_range_of_tendsto (u : ℕ → α) {x : α} (hu : tendsto u at_top ((nhds) x)) : bounded (range u) :=\n  hu.cauchy_seq.bounded_range\n#align bounded_range_of_tendsto bounded_range_of_tendsto\n\n",
 "bounded_range_of_cauchy_map_cofinite":
 "theorem bounded_range_of_cauchy_map_cofinite {f : β → α} (hf : cauchy (map f cofinite)) : bounded (range f) :=\n  bounded_range_of_tendsto_cofinite_uniformity <| (cauchy_map_iff.1 hf).2\n#align bounded_range_of_cauchy_map_cofinite bounded_range_of_cauchy_map_cofinite\n\n",
 "bounded_range_iff":
 "/-- Characterization of the boundedness of the range of a function -/\ntheorem bounded_range_iff {f : β → α} : bounded (range f) ↔ ∃ C, ∀ x y, dist (f x) (f y) ≤ C :=\n  exists_congr fun C => ⟨fun H x y => H _ ⟨x, rfl⟩ _ ⟨y, rfl⟩, by rintro H _ ⟨x, rfl⟩ _ ⟨y, rfl⟩ <;> exact H x y⟩\n#align bounded_range_iff bounded_range_iff\n\n",
 "bounded_range":
 "theorem _root_.cauchy_seq.bounded_range {f : ℕ → α} (hf : cauchy_seq f) : bounded (range f) :=\n  bounded_range_of_cauchy_map_cofinite <| by rwa [nat.cofinite_eq_at_top]\n#align cauchy_seq.bounded_range cauchy_seq.bounded_range\n\n",
 "bounded_of_finite":
 "/-- A finite set is bounded -/\ntheorem bounded_of_finite {s : set α} (h : s.finite) : bounded s :=\n  h.is_compact.bounded\n#align bounded_of_finite bounded_of_finite\n\n",
 "bounded_of_compact_space":
 "/-- In a compact space, all sets are bounded -/\ntheorem bounded_of_compact_space [compact_space α] : bounded s :=\n  is_compact_univ.bounded.mono (subset_univ _)\n#align bounded_of_compact_space bounded_of_compact_space\n\n",
 "bounded_of_bdd_above_of_bdd_below":
 "/-- In a pseudo metric space with a conditionally complete linear order such that the order and the\n    metric structure give the same topology, any order-bounded set is metric-bounded. -/\ntheorem bounded_of_bdd_above_of_bdd_below {s : set α} (h₁ : BddAbove s) (h₂ : BddBelow s) : bounded s :=\n  let ⟨u, hu⟩ := h₁\n  let ⟨l, hl⟩ := h₂\n  bounded.mono (fun x hx => mem_Icc.mpr ⟨hl hx, hu hx⟩) (bounded_Icc l u)\n#align bounded_of_bdd_above_of_bdd_below bounded_of_bdd_above_of_bdd_below\n\n",
 "bounded_iff_subset_ball":
 "/-- Given a point, a bounded subset is included in some ball around this point -/\ntheorem bounded_iff_subset_ball (c : α) : bounded s ↔ ∃ r, s ⊆ closed_ball c r :=\n  by\n  constructor <;> rintro ⟨C, hC⟩\n  · cases' s.eq_empty_or_nonempty with h h\n    · subst s\n      exact ⟨0, by simp⟩\n    · rcases h with ⟨x, hx⟩\n      exact\n        ⟨C + dist x c, fun y hy =>\n          calc\n            dist y c ≤ dist y x + dist x c := dist_triangle _ _ _\n            _ ≤ C + dist x c := add_le_add_right (hC y hy x hx) _\n            ⟩\n  · exact bounded_closed_ball.mono hC\n#align bounded_iff_subset_ball bounded_iff_subset_ball\n\n",
 "bounded_iff_mem_bounded":
 "theorem bounded_iff_mem_bounded : bounded s ↔ ∀ x ∈ s, bounded s :=\n  ⟨fun h _ _ => h, fun H => s.eq_empty_or_nonempty.elim (fun hs => hs.symm ▸ bounded_empty) fun ⟨x, hx⟩ => H x hx⟩\n#align bounded_iff_mem_bounded bounded_iff_mem_bounded\n\n",
 "bounded_iff_is_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem bounded_iff_is_bounded (s : set α) : bounded s ↔ is_bounded s :=\n  by\n  change bounded s ↔ «expr ᶜ» s ∈ (cobounded α).sets\n  simp [pseudo_metric_space.cobounded_sets, metric.bounded]\n#align bounded_iff_is_bounded bounded_iff_is_bounded\n\n",
 "bounded_iff_ediam_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Characterize the boundedness of a set in terms of the finiteness of its emetric.diameter. -/\ntheorem bounded_iff_ediam_ne_top : bounded s ↔ emetric.diam s ≠ «expr⊤» :=\n  iff.intro (fun ⟨C, hC⟩ => ne_top_of_le_ne_top ennreal.of_real_ne_top <| ediam_le_of_forall_dist_le hC) fun h =>\n    ⟨diam s, fun x hx y hy => dist_le_diam_of_mem' h hx hy⟩\n#align bounded_iff_ediam_ne_top bounded_iff_ediam_ne_top\n\n",
 "bounded_iff_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2015, 2017 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Robert Y. Lewis, Johannes Hölzl, Mario Carneiro, Sébastien Gouëzel\n-/\n/-- This is an internal lemma used to construct a bornology from a metric in `bornology.of_dist`. -/\nprivate theorem bounded_iff_aux {α : Type _} (dist : α → α → exprℝ) (dist_comm : ∀ x y : α, dist x y = dist y x)\n    (dist_triangle : ∀ x y z : α, dist x z ≤ dist x y + dist y z) (s : set α) (a : α) :\n    (∃ c, ∀ ⦃x⦄, x ∈ s → ∀ ⦃y⦄, y ∈ s → dist x y ≤ c) ↔ ∃ r, ∀ ⦃x⦄, x ∈ s → dist x a ≤ r :=\n  by\n  constructor <;> rintro ⟨C, hC⟩\n  · rcases s.eq_empty_or_nonempty with (rfl | ⟨x, hx⟩)\n    · exact ⟨0, by simp⟩\n    · exact ⟨C + dist x a, fun y hy => (dist_triangle y x a).trans (add_le_add_right (hC hy hx) _)⟩\n  ·\n    exact\n      ⟨C + C, fun x hx y hy =>\n        (dist_triangle x a y).trans\n          (add_le_add (hC hx)\n            (by\n              rw [dist_comm]\n              exact hC hy))⟩\n#align bounded_iff_aux bounded_iff_aux\n\n",
 "bounded_empty":
 "@[simp]\ntheorem bounded_empty : bounded (∅ : set α) :=\n  ⟨0, by simp⟩\n#align bounded_empty bounded_empty\n\n",
 "bounded_closure_of_bounded":
 "theorem bounded_closure_of_bounded (h : bounded s) : bounded (closure s) :=\n  let ⟨C, h⟩ := h\n  ⟨C, fun a ha b hb => (is_closed_le' C).closure_subset <| map_mem_closure₂ continuous_dist ha hb h⟩\n#align bounded_closure_of_bounded bounded_closure_of_bounded\n\n",
 "bounded_closure_iff":
 "@[simp]\ntheorem bounded_closure_iff : bounded (closure s) ↔ bounded s :=\n  ⟨fun h => h.mono subset_closure, fun h => h.closure⟩\n#align bounded_closure_iff bounded_closure_iff\n\n",
 "bounded_closed_ball":
 "/-- Closed balls are bounded -/\ntheorem bounded_closed_ball : bounded (closed_ball x r) :=\n  ⟨r + r, fun y hy z hz => by\n    simp only [mem_closed_ball] at *\n    calc\n      dist y z ≤ dist y x + dist z x := dist_triangle_right _ _ _\n      _ ≤ r + r := add_le_add hy hz\n      ⟩\n#align bounded_closed_ball bounded_closed_ball\n\n",
 "bounded_ball":
 "/-- Open balls are bounded -/\ntheorem bounded_ball : bounded (ball x r) :=\n  bounded_closed_ball.mono ball_subset_closed_ball\n#align bounded_ball bounded_ball\n\n",
 "bounded_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A finite union of bounded sets is bounded -/\ntheorem bounded_bUnion {I : set β} {s : β → set α} (H : I.finite) :\n    bounded («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) ↔\n      ∀ i ∈ I, bounded (s i) :=\n  finite.induction_on H (by simp) fun x I _ _ IH => by simp [or_imp, forall_and, IH]\n#align bounded_bUnion bounded_bUnion\n\n",
 "bounded_Ioo":
 "theorem bounded_Ioo (a b : α) : bounded (Ioo a b) :=\n  (totally_bounded_Ioo a b).bounded\n#align bounded_Ioo bounded_Ioo\n\n",
 "bounded_Ioc":
 "theorem bounded_Ioc (a b : α) : bounded (Ioc a b) :=\n  (totally_bounded_Ioc a b).bounded\n#align bounded_Ioc bounded_Ioc\n\n",
 "bounded_Ico":
 "theorem bounded_Ico (a b : α) : bounded (Ico a b) :=\n  (totally_bounded_Ico a b).bounded\n#align bounded_Ico bounded_Ico\n\n",
 "bounded_Icc":
 "theorem bounded_Icc (a b : α) : bounded (Icc a b) :=\n  (totally_bounded_Icc a b).bounded\n#align bounded_Icc bounded_Icc\n\n",
 "bounded":
 "/-- A compact set is bounded -/\ntheorem _root_.is_compact.bounded {s : set α} (h : is_compact s) : bounded s :=\n  -- A compact set is totally bounded, thus bounded\n      h.totally_bounded.bounded\n#align is_compact.bounded is_compact.bounded\n\n",
 "ball_zero":
 "@[simp]\ntheorem ball_zero : ball x 0 = ∅ := by rw [ball_eq_empty]\n#align ball_zero ball_zero\n\n",
 "ball_union_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem ball_union_sphere : ball x ε ∪ sphere x ε = closed_ball x ε :=\n  Set.ext fun y => (@le_iff_lt_or_eq (exprℝ) _ _ _).symm\n#align ball_union_sphere ball_union_sphere\n\n",
 "ball_subset_interior_closed_ball":
 "theorem ball_subset_interior_closed_ball : ball x ε ⊆ interior (closed_ball x ε) :=\n  interior_maximal ball_subset_closed_ball is_open_ball\n#align ball_subset_interior_closed_ball ball_subset_interior_closed_ball\n\n",
 "ball_subset_closed_ball":
 "theorem ball_subset_closed_ball : ball x ε ⊆ closed_ball x ε := fun y (hy : _ < _) => le_of_lt hy\n#align ball_subset_closed_ball ball_subset_closed_ball\n\n",
 "ball_subset_ball'":
 "theorem ball_subset_ball' (h : ε₁ + dist x y ≤ ε₂) : ball x ε₁ ⊆ ball y ε₂ := fun z hz =>\n  calc\n    dist z y ≤ dist z x + dist x y := dist_triangle _ _ _\n    _ < ε₁ + dist x y := add_lt_add_right hz _\n    _ ≤ ε₂ := h\n    \n#align ball_subset_ball' ball_subset_ball'\n\n",
 "ball_subset_ball":
 "theorem ball_subset_ball (h : ε₁ ≤ ε₂) : ball x ε₁ ⊆ ball x ε₂ := fun y (yx : _ < ε₁) => lt_of_lt_of_le yx h\n#align ball_subset_ball ball_subset_ball\n\n",
 "ball_subset":
 "theorem ball_subset (h : dist x y ≤ ε₂ - ε₁) : ball x ε₁ ⊆ ball y ε₂ := fun z zx => by\n  rw [← add_sub_cancel'_right ε₁ ε₂] <;> exact lt_of_le_of_lt (dist_triangle z x y) (add_lt_add_of_lt_of_le zx h)\n#align ball_subset ball_subset\n\n",
 "ball_prod_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem ball_prod_same (x : α) (y : β) (r : exprℝ) : lower_set.prod (ball x r) (ball y r) = ball (x, y) r :=\n  ext fun z => by simp [prod.dist_eq]\n#align ball_prod_same ball_prod_same\n\n",
 "ball_pi'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- An open ball in a product space is a product of open balls. See also `metric.ball_pi`\nfor a version assuming `0 < r` instead of `nonempty β`. -/\ntheorem ball_pi' [nonempty β] (x : ∀ b, π b) (r : exprℝ) : ball x r = Set.pi univ fun b => ball (x b) r :=\n  (lt_or_le 0 r).elim (ball_pi x) fun hr => by simp [ball_eq_empty.2 hr]\n#align ball_pi' ball_pi'\n\n",
 "ball_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- An open ball in a product space is a product of open balls. See also `metric.ball_pi'`\nfor a version assuming `nonempty β` instead of `0 < r`. -/\ntheorem ball_pi (x : ∀ b, π b) {r : exprℝ} (hr : 0 < r) : ball x r = Set.pi univ fun b => ball (x b) r :=\n  by\n  ext p\n  simp [dist_pi_lt_iff hr]\n#align ball_pi ball_pi\n\n",
 "ball_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ball_mem_nhds (x : α) {ε : exprℝ} (ε0 : 0 < ε) : ball x ε ∈ (nhds) x :=\n  is_open_ball.mem_nhds (mem_ball_self ε0)\n#align ball_mem_nhds ball_mem_nhds\n\n",
 "ball_half_subset":
 "theorem ball_half_subset (y) (h : y ∈ ball x (ε / 2)) : ball y (ε / 2) ⊆ ball x ε :=\n  ball_subset <| by rw [sub_self_div_two] <;> exact le_of_lt h\n#align ball_half_subset ball_half_subset\n\n",
 "ball_eq_empty":
 "@[simp]\ntheorem ball_eq_empty : ball x ε = ∅ ↔ ε ≤ 0 := by rw [← not_nonempty_iff_eq_empty, nonempty_ball, not_lt]\n#align ball_eq_empty ball_eq_empty\n\n",
 "ball_eq_ball'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem ball_eq_ball' (ε : exprℝ) (x : α) : uniform_space.ball x { p | dist p.1 p.2 < ε } = metric.ball x ε :=\n  by\n  ext\n  simp [dist_comm, uniform_space.ball]\n#align ball_eq_ball' ball_eq_ball'\n\n",
 "ball_eq_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem ball_eq_ball (ε : exprℝ) (x : α) : uniform_space.ball x { p | dist p.2 p.1 < ε } = metric.ball x ε :=\n  rfl\n#align ball_eq_ball ball_eq_ball\n\n",
 "ball_eq_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.ball_eq_Ioo (x r : exprℝ) : ball x r = Ioo (x - r) (x + r) :=\n  Set.ext fun y => by rw [mem_ball, dist_comm, real.dist_eq, abs_sub_lt_iff, mem_Ioo, ← sub_lt_iff_lt_add', sub_lt_comm]\n#align real.ball_eq_Ioo real.ball_eq_Ioo\n\n",
 "ball_disjoint_closed_ball":
 "theorem ball_disjoint_closed_ball (h : δ + ε ≤ dist x y) : Disjoint (ball x δ) (closed_ball y ε) :=\n  (closed_ball_disjoint_ball <| by rwa [add_comm, dist_comm]).symm\n#align ball_disjoint_closed_ball ball_disjoint_closed_ball\n\n",
 "ball_disjoint_ball":
 "theorem ball_disjoint_ball (h : δ + ε ≤ dist x y) : Disjoint (ball x δ) (ball y ε) :=\n  (closed_ball_disjoint_ball h).mono_left ball_subset_closed_ball\n#align ball_disjoint_ball ball_disjoint_ball\n\n",
 "abs_dist_sub_le":
 "theorem abs_dist_sub_le (x y z : α) : |dist x z - dist y z| ≤ dist x y :=\n  abs_sub_le_iff.2 ⟨sub_le_iff_le_add.2 (dist_triangle _ _ _), sub_le_iff_le_add.2 (dist_triangle_left _ _ _)⟩\n#align abs_dist_sub_le abs_dist_sub_le\n\n",
 "abs_dist":
 "@[simp]\ntheorem abs_dist {a b : α} : |dist a b| = dist a b :=\n  abs_of_nonneg dist_nonneg\n#align abs_dist abs_dist\n\n",
 "Union_inter_closed_ball_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Union_inter_closed_ball_nat (s : set α) (x : α) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (s ∩ closed_ball x n) =\n      s :=\n  by rw [← inter_Union, Union_closed_ball_nat, inter_univ]\n#align Union_inter_closed_ball_nat Union_inter_closed_ball_nat\n\n",
 "Union_closed_ball_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem Union_closed_ball_nat (x : α) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (closed_ball x n) =\n      univ :=\n  unionᵢ_eq_univ_iff.2 fun y => exists_nat_ge (dist y x)\n#align Union_closed_ball_nat Union_closed_ball_nat\n\n",
 "Union_ball_nat_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem Union_ball_nat_succ (x : α) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (ball x (n + 1)) =\n      univ :=\n  unionᵢ_eq_univ_iff.2 fun y => (exists_nat_gt (dist y x)).imp fun n hn => hn.trans (lt_add_one _)\n#align Union_ball_nat_succ Union_ball_nat_succ\n\n",
 "Union_ball_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem Union_ball_nat (x : α) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (ball x n) = univ :=\n  unionᵢ_eq_univ_iff.2 fun y => exists_nat_gt (dist y x)\n#align Union_ball_nat Union_ball_nat\n\n",
 "Ioo_eq_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.Ioo_eq_ball (x y : exprℝ) : Ioo x y = ball ((x + y) / 2) ((y - x) / 2) := by\n  rw [real.ball_eq_Ioo, ← sub_div, add_comm, ← sub_add, add_sub_cancel', add_self_div_two, ← add_div, add_assoc,\n    add_sub_cancel'_right, add_self_div_two]\n#align real.Ioo_eq_ball real.Ioo_eq_ball\n\n",
 "Icc_eq_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.Icc_eq_closed_ball (x y : exprℝ) : Icc x y = closed_ball ((x + y) / 2) ((y - x) / 2) := by\n  rw [real.closed_ball_eq_Icc, ← sub_div, add_comm, ← sub_add, add_sub_cancel', add_self_div_two, ← add_div, add_assoc,\n    add_sub_cancel'_right, add_self_div_two]\n#align real.Icc_eq_closed_ball real.Icc_eq_closed_ball\n\n"}