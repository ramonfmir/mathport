{"update_mem_cylinder":
 "theorem update_mem_cylinder (x : ∀ n, E n) (n : ℕ) (y : E n) : update x n y ∈ cylinder x n :=\n  mem_cylinder_iff.2 fun i hi => by simp [hi.ne]\n#align update_mem_cylinder update_mem_cylinder\n\n",
 "shortest_prefix_diff_pos":
 "theorem shortest_prefix_diff_pos {s : set (∀ n, E n)} (hs : is_closed s) (hne : s.nonempty) {x : ∀ n, E n}\n    (hx : x ∉ s) : 0 < shortest_prefix_diff x s :=\n  by\n  rcases hne with ⟨y, hy⟩\n  exact (zero_le _).trans_lt (first_diff_lt_shortest_prefix_diff hs hx hy)\n#align shortest_prefix_diff_pos shortest_prefix_diff_pos\n\n",
 "self_mem_cylinder":
 "theorem self_mem_cylinder (x : ∀ n, E n) (n : ℕ) : x ∈ cylinder x n := by simp\n#align self_mem_cylinder self_mem_cylinder\n\n",
 "min_first_diff_le":
 "theorem min_first_diff_le (x y z : ∀ n, E n) (h : x ≠ z) : min (first_diff x y) (first_diff y z) ≤ first_diff x z :=\n  by\n  by_contra' H\n  have : x (first_diff x z) = z (first_diff x z) :=\n    calc\n      x (first_diff x z) = y (first_diff x z) := apply_eq_of_lt_first_diff (H.trans_le (min_le_left _ _))\n      _ = z (first_diff x z) := apply_eq_of_lt_first_diff (H.trans_le (min_le_right _ _))\n      \n  exact (apply_first_diff_ne h this).elim\n#align min_first_diff_le min_first_diff_le\n\n",
 "min_dist_le_dist_pi":
 "theorem min_dist_le_dist_pi (x y : ∀ i, F i) (i : ι) : min ((1 / 2) ^ encode i) (dist (x i) (y i)) ≤ dist x y :=\n  le_tsum (dist_summable x y) i fun j hj => le_min (by simp) dist_nonneg\n#align min_dist_le_dist_pi min_dist_le_dist_pi\n\n",
 "mem_cylinder_iff_le_first_diff":
 "theorem mem_cylinder_iff_le_first_diff {x y : ∀ n, E n} (hne : x ≠ y) (i : ℕ) : x ∈ cylinder y i ↔ i ≤ first_diff x y :=\n  by\n  constructor\n  · intro h\n    by_contra'\n    exact apply_first_diff_ne hne (h _ this)\n  · intro hi j hj\n    exact apply_eq_of_lt_first_diff (hj.trans_le hi)\n#align mem_cylinder_iff_le_first_diff mem_cylinder_iff_le_first_diff\n\n",
 "mem_cylinder_iff_eq":
 "theorem mem_cylinder_iff_eq {x y : ∀ n, E n} {n : ℕ} : y ∈ cylinder x n ↔ cylinder y n = cylinder x n :=\n  by\n  constructor\n  · intro hy\n    apply subset.antisymm\n    · intro z hz i hi\n      rw [← hy i hi]\n      exact hz i hi\n    · intro z hz i hi\n      rw [hy i hi]\n      exact hz i hi\n  · intro h\n    rw [← h]\n    exact self_mem_cylinder _ _\n#align mem_cylinder_iff_eq mem_cylinder_iff_eq\n\n",
 "mem_cylinder_iff_dist_le":
 "theorem mem_cylinder_iff_dist_le {x y : ∀ n, E n} {n : ℕ} : y ∈ cylinder x n ↔ dist y x ≤ (1 / 2) ^ n :=\n  by\n  rcases eq_or_ne y x with (rfl | hne)\n  · simp [pi_nat.dist_self]\n  suffices (∀ i : ℕ, i < n → y i = x i) ↔ n ≤ first_diff y x by simpa [dist_eq_of_ne hne]\n  constructor\n  · intro hy\n    by_contra' H\n    exact apply_first_diff_ne hne (hy _ H)\n  · intro h i hi\n    exact apply_eq_of_lt_first_diff (hi.trans_le h)\n#align mem_cylinder_iff_dist_le mem_cylinder_iff_dist_le\n\n",
 "mem_cylinder_iff":
 "@[simp]\ntheorem mem_cylinder_iff {x y : ∀ n, E n} {n : ℕ} : y ∈ cylinder x n ↔ ∀ i, i < n → y i = x i :=\n  iff.rfl\n#align mem_cylinder_iff mem_cylinder_iff\n\n",
 "mem_cylinder_first_diff":
 "theorem mem_cylinder_first_diff (x y : ∀ n, E n) : x ∈ cylinder y (first_diff x y) := fun i hi =>\n  apply_eq_of_lt_first_diff hi\n#align mem_cylinder_first_diff mem_cylinder_first_diff\n\n",
 "mem_cylinder_comm":
 "theorem mem_cylinder_comm (x y : ∀ n, E n) (n : ℕ) : y ∈ cylinder x n ↔ x ∈ cylinder y n := by\n  simp [mem_cylinder_iff_eq, eq_comm]\n#align mem_cylinder_comm mem_cylinder_comm\n\n",
 "lipschitz_with_one_iff_forall_dist_image_le_of_mem_cylinder":
 "/-- A function to a pseudo-metric-space is `1`-Lipschitz if and only if points in the same cylinder\nof length `n` are sent to points within distance `(1/2)^n`.\nNot expressed using `lipschitz_with` as we don't have a metric space structure -/\ntheorem lipschitz_with_one_iff_forall_dist_image_le_of_mem_cylinder {α : Type _} [pseudo_metric_space α]\n    {f : (∀ n, E n) → α} :\n    (∀ x y : ∀ n, E n, dist (f x) (f y) ≤ dist x y) ↔ ∀ x y n, y ∈ cylinder x n → dist (f x) (f y) ≤ (1 / 2) ^ n :=\n  by\n  constructor\n  · intro H x y n hxy\n    apply (H x y).trans\n    rw [pi_nat.dist_comm]\n    exact mem_cylinder_iff_dist_le.1 hxy\n  · intro H x y\n    rcases eq_or_ne x y with (rfl | hne)\n    · simp [pi_nat.dist_nonneg]\n    rw [dist_eq_of_ne hne]\n    apply H x y (first_diff x y)\n    rw [first_diff_comm]\n    exact mem_cylinder_first_diff _ _\n#align\n  lipschitz_with_one_iff_forall_dist_image_le_of_mem_cylinder lipschitz_with_one_iff_forall_dist_image_le_of_mem_cylinder\n\n",
 "is_topological_basis_cylinders":
 "theorem is_topological_basis_cylinders :\n    is_topological_basis { s : set (∀ n, E n) | ∃ (x : ∀ n, E n)(n : ℕ), s = cylinder x n } :=\n  by\n  apply is_topological_basis_of_open_of_nhds\n  · rintro u ⟨x, n, rfl⟩\n    rw [cylinder_eq_pi]\n    exact is_open_set_pi (Finset.range n).finite_to_set fun a ha => is_open_discrete _\n  · intro x u hx u_open\n    obtain ⟨v, ⟨U, F, hUF, rfl⟩, xU, Uu⟩ :\n      ∃ (v : set (∀ i : ℕ, E i))(H :\n        v ∈\n          { S : set (∀ i : ℕ, E i) |\n            ∃ (U : ∀ i : ℕ, set (E i))(F : Finset ℕ),\n              (∀ i : ℕ, i ∈ F → U i ∈ { s : set (E i) | is_open s }) ∧ S = (F : set ℕ).pi U }),\n        x ∈ v ∧ v ⊆ u :=\n      (is_topological_basis_pi fun n : ℕ => is_topological_basis_opens).exists_subset_of_mem_open hx u_open\n    rcases finset.bdd_above F with ⟨n, hn⟩\n    refine' ⟨cylinder x (n + 1), ⟨x, n + 1, rfl⟩, self_mem_cylinder _ _, subset.trans _ Uu⟩\n    intro y hy\n    suffices ∀ i : ℕ, i ∈ F → y i ∈ U i by simpa\n    intro i hi\n    have : y i = x i := mem_cylinder_iff.1 hy i ((hn hi).trans_lt (lt_add_one n))\n    rw [this]\n    simp only [Set.mem_pi, Finset.mem_coe] at xU\n    exact xU i hi\n#align is_topological_basis_cylinders is_topological_basis_cylinders\n\n",
 "is_open_iff_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_open_iff_dist (s : set (∀ n, E n)) : is_open s ↔ ∀ x ∈ s, ∃ ε > 0, ∀ y, dist x y < ε → y ∈ s :=\n  by\n  constructor\n  · intro hs x hx\n    obtain ⟨v, ⟨y, n, rfl⟩, h'x, h's⟩ :\n      ∃ (v : set (∀ n : ℕ, E n))(H : v ∈ { s | ∃ (x : ∀ n : ℕ, E n)(n : ℕ), s = cylinder x n }), x ∈ v ∧ v ⊆ s :=\n      (is_topological_basis_cylinders E).exists_subset_of_mem_open hx hs\n    rw [← mem_cylinder_iff_eq.1 h'x] at h's\n    exact ⟨(1 / 2 : exprℝ) ^ n, by simp, fun y hy => h's fun i hi => (apply_eq_of_dist_lt hy hi.le).symm⟩\n  · intro h\n    apply (is_topological_basis_cylinders E).is_open_iff.2 fun x hx => _\n    rcases h x hx with ⟨ε, εpos, hε⟩\n    obtain ⟨n, hn⟩ : ∃ n : ℕ, (1 / 2 : exprℝ) ^ n < ε := exists_pow_lt_of_lt_one εpos one_half_lt_one\n    refine' ⟨cylinder x n, ⟨x, n, rfl⟩, self_mem_cylinder x n, fun y hy => hε y _⟩\n    rw [pi_nat.dist_comm]\n    exact (mem_cylinder_iff_dist_le.1 hy).trans_lt hn\n#align is_open_iff_dist is_open_iff_dist\n\n",
 "inter_cylinder_longest_prefix_nonempty":
 "theorem inter_cylinder_longest_prefix_nonempty {s : set (∀ n, E n)} (hs : is_closed s) (hne : s.nonempty)\n    (x : ∀ n, E n) : (s ∩ cylinder x (longest_prefix x s)).nonempty :=\n  by\n  by_cases hx : x ∈ s\n  · exact ⟨x, hx, self_mem_cylinder _ _⟩\n  have A := exists_disjoint_cylinder hs hx\n  have B : longest_prefix x s < shortest_prefix_diff x s := nat.pred_lt (shortest_prefix_diff_pos hs hne hx).ne'\n  rw [longest_prefix, shortest_prefix_diff, dif_pos A] at B⊢\n  obtain ⟨y, ys, hy⟩ : ∃ y : ∀ n : ℕ, E n, y ∈ s ∧ x ∈ cylinder y (nat.find A - 1) :=\n    by\n    have := nat.find_min A B\n    push_neg  at this\n    simp_rw [not_disjoint_iff, mem_cylinder_comm] at this\n    exact this\n  refine' ⟨y, ys, _⟩\n  rw [mem_cylinder_iff_eq] at hy⊢\n  rw [hy]\n#align inter_cylinder_longest_prefix_nonempty inter_cylinder_longest_prefix_nonempty\n\n",
 "first_diff_lt_shortest_prefix_diff":
 "theorem first_diff_lt_shortest_prefix_diff {s : set (∀ n, E n)} (hs : is_closed s) {x y : ∀ n, E n} (hx : x ∉ s)\n    (hy : y ∈ s) : first_diff x y < shortest_prefix_diff x s :=\n  by\n  have A := exists_disjoint_cylinder hs hx\n  rw [shortest_prefix_diff, dif_pos A]\n  have B := nat.find_spec A\n  contrapose! B\n  rw [not_disjoint_iff_nonempty_inter]\n  refine' ⟨y, hy, _⟩\n  rw [mem_cylinder_comm]\n  exact cylinder_anti y B (mem_cylinder_first_diff x y)\n#align first_diff_lt_shortest_prefix_diff first_diff_lt_shortest_prefix_diff\n\n",
 "first_diff_le_longest_prefix":
 "theorem first_diff_le_longest_prefix {s : set (∀ n, E n)} (hs : is_closed s) {x y : ∀ n, E n} (hx : x ∉ s)\n    (hy : y ∈ s) : first_diff x y ≤ longest_prefix x s :=\n  by\n  rw [longest_prefix, le_tsub_iff_right]\n  · exact first_diff_lt_shortest_prefix_diff hs hx hy\n  · exact shortest_prefix_diff_pos hs ⟨y, hy⟩ hx\n#align first_diff_le_longest_prefix first_diff_le_longest_prefix\n\n",
 "first_diff_comm":
 "theorem first_diff_comm (x y : ∀ n, E n) : first_diff x y = first_diff y x :=\n  by\n  rcases eq_or_ne x y with (rfl | hxy); · rfl\n  rcases lt_trichotomy (first_diff x y) (first_diff y x) with (h | h | h)\n  · exact (apply_first_diff_ne hxy (apply_eq_of_lt_first_diff h).symm).elim\n  · exact h\n  · exact (apply_first_diff_ne hxy.symm (apply_eq_of_lt_first_diff h).symm).elim\n#align first_diff_comm first_diff_comm\n\n",
 "exists_retraction_subtype_of_is_closed":
 "theorem exists_retraction_subtype_of_is_closed {s : set (∀ n, E n)} (hs : is_closed s) (hne : s.nonempty) :\n    ∃ f : (∀ n, E n) → s, (∀ x : s, f x = x) ∧ surjective f ∧ continuous f :=\n  by\n  obtain ⟨f, fs, f_range, f_cont⟩ : ∃ f : (∀ n, E n) → ∀ n, E n, (∀ x ∈ s, f x = x) ∧ range f = s ∧ continuous f :=\n    exists_retraction_of_is_closed hs hne\n  have A : ∀ x, f x ∈ s := by simp [← f_range]\n  have B : ∀ x : s, cod_restrict f s A x = x := by\n    intro x\n    apply subtype.coe_injective.eq_iff.1\n    simpa only using fs x.val x.property\n  exact ⟨cod_restrict f s A, B, fun x => ⟨x, B x⟩, f_cont.subtype_mk _⟩\n#align exists_retraction_subtype_of_is_closed exists_retraction_subtype_of_is_closed\n\n",
 "exists_retraction_of_is_closed":
 "/-- Given a closed nonempty subset `s` of `Π (n : ℕ), E n`, there exists a retraction onto this\nset, i.e., a continuous map with range equal to `s`, equal to the identity on `s`. -/\ntheorem exists_retraction_of_is_closed {s : set (∀ n, E n)} (hs : is_closed s) (hne : s.nonempty) :\n    ∃ f : (∀ n, E n) → ∀ n, E n, (∀ x ∈ s, f x = x) ∧ range f = s ∧ continuous f :=\n  by\n  rcases exists_lipschitz_retraction_of_is_closed hs hne with ⟨f, fs, frange, hf⟩\n  exact ⟨f, fs, frange, hf.continuous⟩\n#align exists_retraction_of_is_closed exists_retraction_of_is_closed\n\n",
 "exists_nat_nat_continuous_surjective_of_complete_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- Any nonempty complete second countable metric space is the continuous image of the\nfundamental space `ℕ → ℕ`. For a version of this theorem in the context of Polish spaces, see\n`exists_nat_nat_continuous_surjective_of_polish_space`. -/\ntheorem exists_nat_nat_continuous_surjective_of_complete_space (α : Type _) [metric_space α] [complete_space α]\n    [second_countable_topology α] [nonempty α] : ∃ f : (ℕ → ℕ) → α, continuous f ∧ surjective f :=\n  by\n  /- First, we define a surjective map from a closed subset `s` of `ℕ → ℕ`. Then, we compose\n    this map with a retraction of `ℕ → ℕ` onto `s` to obtain the desired map.\n    Let us consider a dense sequence `u` in `α`. Then `s` is the set of sequences `xₙ` such that the\n    balls `closed_ball (u xₙ) (1/2^n)` have a nonempty intersection. This set is closed, and we define\n    `f x` there to be the unique point in the intersection. This function is continuous and surjective\n    by design. -/\n  letI : metric_space (ℕ → ℕ) := pi_nat.metric_space_nat_nat\n  have I0 : (0 : exprℝ) < 1 / 2 := by norm_num\n  have I1 : (1 / 2 : exprℝ) < 1 := by norm_num\n  rcases exists_dense_seq α with ⟨u, hu⟩\n  let s : set (ℕ → ℕ) :=\n    { x |\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (closed_ball (u (x n)) ((1 / 2) ^ n))).nonempty }\n  let g : s → α := fun x => x.2.some\n  have A : ∀ (x : s) (n : ℕ), dist (g x) (u ((x : ℕ → ℕ) n)) ≤ (1 / 2) ^ n := fun x n =>\n    (mem_Inter.1 x.2.some_mem n : _)\n  have g_cont : continuous g := by\n    apply continuous_iff_continuous_at.2 fun y => _\n    apply continuous_at_of_locally_lipschitz zero_lt_one 4 fun x hxy => _\n    rcases eq_or_ne x y with (rfl | hne)\n    · simp\n    have hne' : x.1 ≠ y.1 := subtype.coe_injective.ne hne\n    have dist' : dist x y = dist x.1 y.1 := rfl\n    let n := first_diff x.1 y.1 - 1\n    have diff_pos : 0 < first_diff x.1 y.1 := by\n      by_contra' h\n      apply apply_first_diff_ne hne'\n      rw [le_zero_iff.1 h]\n      apply apply_eq_of_dist_lt _ le_rfl\n      rw [pow_zero]\n      exact hxy\n    have hn : first_diff x.1 y.1 = n + 1 := (nat.succ_pred_eq_of_pos diff_pos).symm\n    rw [dist', dist_eq_of_ne hne', hn]\n    have B : x.1 n = y.1 n := mem_cylinder_first_diff x.1 y.1 n (nat.pred_lt diff_pos.ne')\n    calc\n      dist (g x) (g y) ≤ dist (g x) (u (x.1 n)) + dist (g y) (u (x.1 n)) := dist_triangle_right _ _ _\n      _ = dist (g x) (u (x.1 n)) + dist (g y) (u (y.1 n)) := by rw [← B]\n      _ ≤ (1 / 2) ^ n + (1 / 2) ^ n := add_le_add (A x n) (A y n)\n      _ = 4 * (1 / 2) ^ (n + 1) := by ring\n      \n  have g_surj : surjective g := by\n    intro y\n    have : ∀ n : ℕ, ∃ j, y ∈ closed_ball (u j) ((1 / 2) ^ n) :=\n      by\n      intro n\n      rcases hu.exists_dist_lt y (by simp : (0 : exprℝ) < (1 / 2) ^ n) with ⟨j, hj⟩\n      exact ⟨j, hj.le⟩\n    choose x hx using this\n    have I :\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (closed_ball (u (x n)) ((1 / 2) ^ n))).nonempty :=\n      ⟨y, mem_Inter.2 hx⟩\n    refine' ⟨⟨x, I⟩, _⟩\n    refine' dist_le_zero.1 _\n    have J : ∀ n : ℕ, dist (g ⟨x, I⟩) y ≤ (1 / 2) ^ n + (1 / 2) ^ n := fun n =>\n      calc\n        dist (g ⟨x, I⟩) y ≤ dist (g ⟨x, I⟩) (u (x n)) + dist y (u (x n)) := dist_triangle_right _ _ _\n        _ ≤ (1 / 2) ^ n + (1 / 2) ^ n := add_le_add (A ⟨x, I⟩ n) (hx n)\n        \n    have L : tendsto (fun n : ℕ => (1 / 2 : exprℝ) ^ n + (1 / 2) ^ n) at_top ((nhds) (0 + 0)) :=\n      (tendsto_pow_at_top_nhds_0_of_lt_1 I0.le I1).add (tendsto_pow_at_top_nhds_0_of_lt_1 I0.le I1)\n    rw [add_zero] at L\n    exact ge_of_tendsto' L J\n  have s_closed : is_closed s := by\n    refine' is_closed_iff_cluster_pt.mpr _\n    intro x hx\n    have L : tendsto (fun n : ℕ => diam (closed_ball (u (x n)) ((1 / 2) ^ n))) at_top ((nhds) 0) :=\n      by\n      have : tendsto (fun n : ℕ => (2 : exprℝ) * (1 / 2) ^ n) at_top ((nhds) (2 * 0)) :=\n        (tendsto_pow_at_top_nhds_0_of_lt_1 I0.le I1).const_mul _\n      rw [mul_zero] at this\n      exact squeeze_zero (fun n => diam_nonneg) (fun n => diam_closed_ball (pow_nonneg I0.le _)) this\n    refine' nonempty_Inter_of_nonempty_bInter (fun n => is_closed_ball) (fun n => bounded_closed_ball) _ L\n    intro N\n    obtain ⟨y, hxy, ys⟩ : ∃ y, y ∈ ball x ((1 / 2) ^ N) ∩ s :=\n      cluster_pt_principal_iff.1 hx _ (ball_mem_nhds x (pow_pos I0 N))\n    have E :\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (closed_ball (u (x n)) ((1 / 2) ^ n)) =\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (closed_ball (u (y n)) ((1 / 2) ^ n)) :=\n      by\n      congr\n      ext1 n\n      congr\n      ext1 hn\n      have : x n = y n := apply_eq_of_dist_lt (mem_ball'.1 hxy) hn\n      rw [this]\n    rw [E]\n    apply nonempty.mono _ ys\n    apply Inter_subset_Inter₂\n  obtain ⟨f, -, f_surj, f_cont⟩ : ∃ f : (ℕ → ℕ) → s, (∀ x : s, f x = x) ∧ surjective f ∧ continuous f :=\n    by\n    apply exists_retraction_subtype_of_is_closed s_closed\n    simpa only [nonempty_coe_sort] using g_surj.nonempty\n  exact ⟨g ∘ f, g_cont.comp f_cont, g_surj.comp f_surj⟩\n#align exists_nat_nat_continuous_surjective_of_complete_space exists_nat_nat_continuous_surjective_of_complete_space\n\n",
 "exists_lipschitz_retraction_of_is_closed":
 "/-- Given a closed nonempty subset `s` of `Π (n : ℕ), E n`, there exists a Lipschitz retraction\nonto this set, i.e., a Lipschitz map with range equal to `s`, equal to the identity on `s`. -/\ntheorem exists_lipschitz_retraction_of_is_closed {s : set (∀ n, E n)} (hs : is_closed s) (hne : s.nonempty) :\n    ∃ f : (∀ n, E n) → ∀ n, E n, (∀ x ∈ s, f x = x) ∧ range f = s ∧ lipschitz_with 1 f :=\n  by\n  /- The map `f` is defined as follows. For `x ∈ s`, let `f x = x`. Otherwise, consider the longest\n    prefix `w` that `x` shares with an element of `s`, and let `f x = z_w` where `z_w` is an element\n    of `s` starting with `w`. All the desired properties are clear, except the fact that `f`\n    is `1`-Lipschitz: if two points `x, y` belong to a common cylinder of length `n`, one should show\n    that their images also belong to a common cylinder of length `n`. This is a case analysis:\n    * if both `x, y ∈ s`, then this is clear.\n    * if `x ∈ s` but `y ∉ s`, then the longest prefix `w` of `y` shared by an element of `s` is of\n    length at least `n` (because of `x`), and then `f y` starts with `w` and therefore stays in the\n    same length `n` cylinder.\n    * if `x ∉ s`, `y ∉ s`, let `w` be the longest prefix of `x` shared by an element of `s`. If its\n    length is `< n`, then it is also the longest prefix of `y`, and we get `f x = f y = z_w`.\n    Otherwise, `f x` remains in the same `n`-cylinder as `x`. Similarly for `y`. Finally, `f x` and\n    `f y` are again in the same `n`-cylinder, as desired. -/\n  set f := fun x => if x ∈ s then x else (inter_cylinder_longest_prefix_nonempty hs hne x).some with hf\n  have fs : ∀ x ∈ s, f x = x := fun x xs => by simp [xs]\n  refine' ⟨f, fs, _, _⟩\n  -- check that the range of `f` is `s`.\n  · apply subset.antisymm\n    · rintro x ⟨y, rfl⟩\n      by_cases hy : y ∈ s\n      · rwa [fs y hy]\n      simpa [hf, if_neg hy] using (inter_cylinder_longest_prefix_nonempty hs hne y).some_spec.1\n    · intro x hx\n      rw [← fs x hx]\n      exact mem_range_self _\n  -- check that `f` is `1`-Lipschitz, by a case analysis.\n  · apply lipschitz_with.mk_one fun x y => _\n    -- exclude the trivial cases where `x = y`, or `f x = f y`.\n    rcases eq_or_ne x y with (rfl | hxy)\n    · simp\n    rcases eq_or_ne (f x) (f y) with (h' | hfxfy)\n    · simp [h', dist_nonneg]\n    have I2 : cylinder x (first_diff x y) = cylinder y (first_diff x y) :=\n      by\n      rw [← mem_cylinder_iff_eq]\n      apply mem_cylinder_first_diff\n    suffices first_diff x y ≤ first_diff (f x) (f y) by simpa [dist_eq_of_ne hxy, dist_eq_of_ne hfxfy]\n    -- case where `x ∈ s`\n    by_cases xs : x ∈ s\n    · rw [fs x xs] at hfxfy⊢\n      -- case where `y ∈ s`, trivial\n      by_cases ys : y ∈ s\n      · rw [fs y ys]\n      -- case where `y ∉ s`\n      have A : (s ∩ cylinder y (longest_prefix y s)).nonempty := inter_cylinder_longest_prefix_nonempty hs hne y\n      have fy : f y = A.some := by simp_rw [hf, if_neg ys]\n      have I : cylinder A.some (first_diff x y) = cylinder y (first_diff x y) :=\n        by\n        rw [← mem_cylinder_iff_eq, first_diff_comm]\n        apply cylinder_anti y _ A.some_spec.2\n        exact first_diff_le_longest_prefix hs ys xs\n      rwa [← fy, ← I2, ← mem_cylinder_iff_eq, mem_cylinder_iff_le_first_diff hfxfy.symm, first_diff_comm _ x] at I\n    -- case where `x ∉ s`\n    · by_cases ys : y ∈ s\n      -- case where `y ∈ s` (similar to the above)\n      · have A : (s ∩ cylinder x (longest_prefix x s)).nonempty := inter_cylinder_longest_prefix_nonempty hs hne x\n        have fx : f x = A.some := by simp_rw [hf, if_neg xs]\n        have I : cylinder A.some (first_diff x y) = cylinder x (first_diff x y) :=\n          by\n          rw [← mem_cylinder_iff_eq]\n          apply cylinder_anti x _ A.some_spec.2\n          apply first_diff_le_longest_prefix hs xs ys\n        rw [fs y ys] at hfxfy⊢\n        rwa [← fx, I2, ← mem_cylinder_iff_eq, mem_cylinder_iff_le_first_diff hfxfy] at I\n      -- case where `y ∉ s`\n      · have Ax : (s ∩ cylinder x (longest_prefix x s)).nonempty := inter_cylinder_longest_prefix_nonempty hs hne x\n        have fx : f x = Ax.some := by simp_rw [hf, if_neg xs]\n        have Ay : (s ∩ cylinder y (longest_prefix y s)).nonempty := inter_cylinder_longest_prefix_nonempty hs hne y\n        have fy : f y = Ay.some := by simp_rw [hf, if_neg ys]\n        -- case where the common prefix to `x` and `s`, or `y` and `s`, is shorter than the\n        -- common part to `x` and `y` -- then `f x = f y`.\n        by_cases H : longest_prefix x s < first_diff x y ∨ longest_prefix y s < first_diff x y\n        · have : cylinder x (longest_prefix x s) = cylinder y (longest_prefix y s) :=\n            by\n            cases H\n            · exact cylinder_longest_prefix_eq_of_longest_prefix_lt_first_diff hs hne H xs ys\n            · symm\n              rw [first_diff_comm] at H\n              exact cylinder_longest_prefix_eq_of_longest_prefix_lt_first_diff hs hne H ys xs\n          rw [fx, fy] at hfxfy\n          apply (hfxfy _).elim\n          congr\n        -- case where the common prefix to `x` and `s` is long, as well as the common prefix to\n        -- `y` and `s`. Then all points remain in the same cylinders.\n        · push_neg  at H\n          have I1 : cylinder Ax.some (first_diff x y) = cylinder x (first_diff x y) :=\n            by\n            rw [← mem_cylinder_iff_eq]\n            exact cylinder_anti x H.1 Ax.some_spec.2\n          have I3 : cylinder y (first_diff x y) = cylinder Ay.some (first_diff x y) :=\n            by\n            rw [eq_comm, ← mem_cylinder_iff_eq]\n            exact cylinder_anti y H.2 Ay.some_spec.2\n          have : cylinder Ax.some (first_diff x y) = cylinder Ay.some (first_diff x y) := by rw [I1, I2, I3]\n          rw [← fx, ← fy, ← mem_cylinder_iff_eq, mem_cylinder_iff_le_first_diff hfxfy] at this\n          exact this\n#align exists_lipschitz_retraction_of_is_closed exists_lipschitz_retraction_of_is_closed\n\n",
 "exists_disjoint_cylinder":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem exists_disjoint_cylinder {s : set (∀ n, E n)} (hs : is_closed s) {x : ∀ n, E n} (hx : x ∉ s) :\n    ∃ n, Disjoint s (cylinder x n) :=\n  by\n  rcases eq_empty_or_nonempty s with (rfl | hne)\n  · exact ⟨0, by simp⟩\n  have A : 0 < inf_dist x s := (hs.not_mem_iff_inf_dist_pos hne).1 hx\n  obtain ⟨n, hn⟩ : ∃ n, (1 / 2 : exprℝ) ^ n < inf_dist x s := exists_pow_lt_of_lt_one A one_half_lt_one\n  refine' ⟨n, _⟩\n  apply disjoint_left.2 fun y ys hy => _\n  apply lt_irrefl (inf_dist x s)\n  calc\n    inf_dist x s ≤ dist x y := inf_dist_le_dist_of_mem ys\n    _ ≤ (1 / 2) ^ n := by\n      rw [mem_cylinder_comm] at hy\n      exact mem_cylinder_iff_dist_le.1 hy\n    _ < inf_dist x s := hn\n    \n#align exists_disjoint_cylinder exists_disjoint_cylinder\n\n",
 "eq_of_dist_eq_zero":
 "protected theorem eq_of_dist_eq_zero (x y : ∀ n, E n) (hxy : dist x y = 0) : x = y :=\n  by\n  rcases eq_or_ne x y with (rfl | h); · rfl\n  simp [dist_eq_of_ne h] at hxy\n  exact (two_ne_zero (pow_eq_zero hxy)).elim\n#align eq_of_dist_eq_zero eq_of_dist_eq_zero\n\n",
 "dist_triangle_nonarch":
 "theorem dist_triangle_nonarch (x y z : ∀ n, E n) : dist x z ≤ max (dist x y) (dist y z) :=\n  by\n  rcases eq_or_ne x z with (rfl | hxz)\n  · simp [pi_nat.dist_self x, pi_nat.dist_nonneg]\n  rcases eq_or_ne x y with (rfl | hxy)\n  · simp\n  rcases eq_or_ne y z with (rfl | hyz)\n  · simp\n  simp only [dist_eq_of_ne, hxz, hxy, hyz, inv_le_inv, one_div, inv_pow, zero_lt_bit0, ne.def, not_false_iff,\n    le_max_iff, zero_lt_one, pow_le_pow_iff, one_lt_two, pow_pos, min_le_iff.1 (min_first_diff_le x y z hxz)]\n#align dist_triangle_nonarch dist_triangle_nonarch\n\n",
 "dist_triangle":
 "protected theorem dist_triangle (x y z : ∀ n, E n) : dist x z ≤ dist x y + dist y z :=\n  calc\n    dist x z ≤ max (dist x y) (dist y z) := dist_triangle_nonarch x y z\n    _ ≤ dist x y + dist y z := max_le_add_of_nonneg (pi_nat.dist_nonneg _ _) (pi_nat.dist_nonneg _ _)\n    \n#align dist_triangle dist_triangle\n\n",
 "dist_summable":
 "theorem dist_summable (x y : ∀ i, F i) : summable fun i : ι => min ((1 / 2) ^ encode i) (dist (x i) (y i)) :=\n  by\n  refine' summable_of_nonneg_of_le (fun i => _) (fun i => min_le_left _ _) summable_geometric_two_encode\n  exact le_min (pow_nonneg (by norm_num) _) dist_nonneg\n#align dist_summable dist_summable\n\n",
 "dist_self":
 "protected theorem dist_self (x : ∀ n, E n) : dist x x = 0 := by simp [dist]\n#align dist_self dist_self\n\n",
 "dist_nonneg":
 "protected theorem dist_nonneg (x y : ∀ n, E n) : 0 ≤ dist x y :=\n  by\n  rcases eq_or_ne x y with (rfl | h)\n  · simp [dist]\n  · simp [dist, h]\n#align dist_nonneg dist_nonneg\n\n",
 "dist_le_dist_pi_of_dist_lt":
 "theorem dist_le_dist_pi_of_dist_lt {x y : ∀ i, F i} {i : ι} (h : dist x y < (1 / 2) ^ encode i) :\n    dist (x i) (y i) ≤ dist x y := by\n  simpa only [not_le.2 h, false_or_iff] using min_le_iff.1 (min_dist_le_dist_pi x y i)\n#align dist_le_dist_pi_of_dist_lt dist_le_dist_pi_of_dist_lt\n\n",
 "dist_eq_tsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem dist_eq_tsum (x y : ∀ i, F i) :\n    dist x y =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (min ((1 / 2) ^ encode i) (dist (x i) (y i))) :=\n  rfl\n#align dist_eq_tsum dist_eq_tsum\n\n",
 "dist_eq_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem dist_eq_of_ne {x y : ∀ n, E n} (h : x ≠ y) : dist x y = (1 / 2 : exprℝ) ^ first_diff x y := by simp [dist, h]\n#align dist_eq_of_ne dist_eq_of_ne\n\n",
 "dist_comm":
 "protected theorem dist_comm (x y : ∀ n, E n) : dist x y = dist y x := by simp [dist, @eq_comm _ x y, first_diff_comm]\n#align dist_comm dist_comm\n\n",
 "disjoint_cylinder_of_longest_prefix_lt":
 "theorem disjoint_cylinder_of_longest_prefix_lt {s : set (∀ n, E n)} (hs : is_closed s) {x : ∀ n, E n} (hx : x ∉ s)\n    {n : ℕ} (hn : longest_prefix x s < n) : Disjoint s (cylinder x n) :=\n  by\n  rcases eq_empty_or_nonempty s with (h's | hne); · simp [h's]\n  contrapose! hn\n  rcases not_disjoint_iff_nonempty_inter.1 hn with ⟨y, ys, hy⟩\n  apply le_trans _ (first_diff_le_longest_prefix hs hx ys)\n  apply (mem_cylinder_iff_le_first_diff (ne_of_mem_of_not_mem ys hx).symm _).1\n  rwa [mem_cylinder_comm]\n#align disjoint_cylinder_of_longest_prefix_lt disjoint_cylinder_of_longest_prefix_lt\n\n",
 "cylinder_zero":
 "@[simp]\ntheorem cylinder_zero (x : ∀ n, E n) : cylinder x 0 = univ := by simp [cylinder_eq_pi]\n#align cylinder_zero cylinder_zero\n\n",
 "cylinder_longest_prefix_eq_of_longest_prefix_lt_first_diff":
 "/-- If two points `x, y` coincide up to length `n`, and the longest common prefix of `x` with `s`\nis strictly shorter than `n`, then the longest common prefix of `y` with `s` is the same, and both\ncylinders of this length based at `x` and `y` coincide. -/\ntheorem cylinder_longest_prefix_eq_of_longest_prefix_lt_first_diff {x y : ∀ n, E n} {s : set (∀ n, E n)}\n    (hs : is_closed s) (hne : s.nonempty) (H : longest_prefix x s < first_diff x y) (xs : x ∉ s) (ys : y ∉ s) :\n    cylinder x (longest_prefix x s) = cylinder y (longest_prefix y s) :=\n  by\n  have l_eq : longest_prefix y s = longest_prefix x s :=\n    by\n    rcases lt_trichotomy (longest_prefix y s) (longest_prefix x s) with (L | L | L)\n    · have Ax : (s ∩ cylinder x (longest_prefix x s)).nonempty := inter_cylinder_longest_prefix_nonempty hs hne x\n      have Z := disjoint_cylinder_of_longest_prefix_lt hs ys L\n      rw [first_diff_comm] at H\n      rw [cylinder_eq_cylinder_of_le_first_diff _ _ H.le] at Z\n      exact (Ax.not_disjoint Z).elim\n    · exact L\n    · have Ay : (s ∩ cylinder y (longest_prefix y s)).nonempty := inter_cylinder_longest_prefix_nonempty hs hne y\n      have A'y : (s ∩ cylinder y (longest_prefix x s).succ).nonempty :=\n        Ay.mono (inter_subset_inter_right s (cylinder_anti _ L))\n      have Z := disjoint_cylinder_of_longest_prefix_lt hs xs (nat.lt_succ_self _)\n      rw [cylinder_eq_cylinder_of_le_first_diff _ _ H] at Z\n      exact (A'y.not_disjoint Z).elim\n  rw [l_eq, ← mem_cylinder_iff_eq]\n  exact cylinder_anti y H.le (mem_cylinder_first_diff x y)\n#align\n  cylinder_longest_prefix_eq_of_longest_prefix_lt_first_diff cylinder_longest_prefix_eq_of_longest_prefix_lt_first_diff\n\n",
 "cylinder_eq_pi":
 "theorem cylinder_eq_pi (x : ∀ n, E n) (n : ℕ) : cylinder x n = Set.pi (Finset.range n : set ℕ) fun i : ℕ => {x i} :=\n  by\n  ext y\n  simp [cylinder]\n#align cylinder_eq_pi cylinder_eq_pi\n\n",
 "cylinder_eq_cylinder_of_le_first_diff":
 "theorem cylinder_eq_cylinder_of_le_first_diff (x y : ∀ n, E n) {n : ℕ} (hn : n ≤ first_diff x y) :\n    cylinder x n = cylinder y n := by\n  rw [← mem_cylinder_iff_eq]\n  intro i hi\n  exact apply_eq_of_lt_first_diff (hi.trans_le hn)\n#align cylinder_eq_cylinder_of_le_first_diff cylinder_eq_cylinder_of_le_first_diff\n\n",
 "cylinder_anti":
 "theorem cylinder_anti (x : ∀ n, E n) {m n : ℕ} (h : m ≤ n) : cylinder x n ⊆ cylinder x m := fun y hy i hi =>\n  hy i (hi.trans_le h)\n#align cylinder_anti cylinder_anti\n\n",
 "complete_space":
 "protected theorem complete_space : complete_space (∀ n, E n) :=\n  by\n  refine' metric.complete_of_convergent_controlled_sequences (fun n => (1 / 2) ^ n) (by simp) _\n  intro u hu\n  refine' ⟨fun n => u n n, tendsto_pi_nhds.2 fun i => _⟩\n  refine' tendsto_const_nhds.congr' _\n  filter_upwards [filter.Ici_mem_at_top i] with n hn\n  exact apply_eq_of_dist_lt (hu i i n le_rfl hn) le_rfl\n#align complete_space complete_space\n\n",
 "apply_first_diff_ne":
 "/-\nCopyright (c) 2022 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\ntheorem apply_first_diff_ne {x y : ∀ n, E n} (h : x ≠ y) : x (first_diff x y) ≠ y (first_diff x y) :=\n  by\n  rw [first_diff, dif_pos h]\n  exact nat.find_spec (ne_iff.1 h)\n#align apply_first_diff_ne apply_first_diff_ne\n\n",
 "apply_eq_of_lt_first_diff":
 "theorem apply_eq_of_lt_first_diff {x y : ∀ n, E n} {n : ℕ} (hn : n < first_diff x y) : x n = y n :=\n  by\n  rw [first_diff] at hn\n  split_ifs  at hn\n  · convert nat.find_min (ne_iff.1 h) hn\n    simp\n  · exact (not_lt_zero' hn).elim\n#align apply_eq_of_lt_first_diff apply_eq_of_lt_first_diff\n\n",
 "apply_eq_of_dist_lt":
 "theorem apply_eq_of_dist_lt {x y : ∀ n, E n} {n : ℕ} (h : dist x y < (1 / 2) ^ n) {i : ℕ} (hi : i ≤ n) : x i = y i :=\n  by\n  rcases eq_or_ne x y with (rfl | hne)\n  · rfl\n  have : n < first_diff x y := by simpa [dist_eq_of_ne hne, inv_lt_inv, pow_lt_pow_iff, one_lt_two] using h\n  exact apply_eq_of_lt_first_diff (hi.trans_lt this)\n#align apply_eq_of_dist_lt apply_eq_of_dist_lt\n\n",
 "Union_cylinder_update":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Union_cylinder_update (x : ∀ n, E n) (n : ℕ) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (cylinder (update x n k) (n + 1)) =\n      cylinder x n :=\n  by\n  ext y\n  simp only [mem_cylinder_iff, mem_Union]\n  constructor\n  · rintro ⟨k, hk⟩ i hi\n    simpa [hi.ne] using hk i (nat.lt_succ_of_lt hi)\n  · intro H\n    refine' ⟨y n, fun i hi => _⟩\n    rcases Nat.lt_succ_iff_lt_or_eq.1 hi with (h'i | rfl)\n    · simp [H i h'i, h'i.ne]\n    · simp\n#align Union_cylinder_update Union_cylinder_update\n\n"}