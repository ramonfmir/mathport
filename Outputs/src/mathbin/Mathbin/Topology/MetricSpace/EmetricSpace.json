{"zero_eq_edist":
 "@[simp]\ntheorem zero_eq_edist {x y : Î³} : 0 = edist x y â†” x = y :=\n  iff.intro (fun h => eq_of_edist_eq_zero h.symm) fun this : x = y => this â–¸ (edist_self _).symm\n#align zero_eq_edist zero_eq_edist\n\n",
 "uniformity_pseudoedist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/-- Reformulation of the uniform structure in terms of the extended distance -/\ntheorem uniformity_pseudoedist :\n    (uniformity) Î± =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) { p : Î± Ã— Î± | edist p.1 p.2 < Îµ }) :=\n  pseudo_emetric_space.uniformity_edist\n#align uniformity_pseudoedist uniformity_pseudoedist\n\n",
 "uniformity_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n-- see Note [lower instance priority]\n/-- Reformulation of the uniform structure in terms of the extended distance -/\ntheorem uniformity_edist :\n    (uniformity) Î³ =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) { p : Î³ Ã— Î³ | edist p.1 p.2 < Îµ }) :=\n  pseudo_emetric_space.uniformity_edist\n#align uniformity_edist uniformity_edist\n\n",
 "uniformity_dist_of_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/-\nCopyright (c) 2015, 2017 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Robert Y. Lewis, Johannes HÃ¶lzl, Mario Carneiro, SÃ©bastien GouÃ«zel\n-/\n/-- Characterizing uniformities associated to a (generalized) distance function `D`\nin terms of the elements of the uniformity. -/\ntheorem uniformity_dist_of_mem_uniformity [linear_order Î²] {U : filter (Î± Ã— Î±)} (z : Î²) (D : Î± â†’ Î± â†’ Î²)\n    (H : âˆ€ s, s âˆˆ U â†” âˆƒ Îµ > z, âˆ€ {a b : Î±}, D a b < Îµ â†’ (a, b) âˆˆ s) :\n    U =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) { p : Î± Ã— Î± | D p.1 p.2 < Îµ }) :=\n  le_antisymm (le_infáµ¢ fun Îµ => le_infáµ¢ fun Îµ0 => le_principal_iff.2 <| (H _).2 âŸ¨Îµ, Îµ0, fun a b => idâŸ©) fun r ur =>\n    let âŸ¨Îµ, Îµ0, hâŸ© := (H _).1 ur\n    mem_infi_of_mem Îµ <| mem_infi_of_mem Îµ0 <| mem_principal.2 fun âŸ¨a, bâŸ© => h\n#align uniformity_dist_of_mem_uniformity uniformity_dist_of_mem_uniformity\n\n",
 "uniformity_basis_edist_nnreal_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem uniformity_basis_edist_nnreal_le :\n    ((uniformity) Î±).has_basis (fun Îµ : nnreal => 0 < Îµ) fun Îµ => { p : Î± Ã— Î± | edist p.1 p.2 â‰¤ Îµ } :=\n  emetric.mk_uniformity_basis_le (fun _ => ennreal.coe_pos.2) fun Îµ Îµâ‚€ =>\n    let âŸ¨Î´, hÎ´âŸ© := ennreal.lt_iff_exists_nnreal_btwn.1 Îµâ‚€\n    âŸ¨Î´, ennreal.coe_pos.1 hÎ´.1, le_of_lt hÎ´.2âŸ©\n#align uniformity_basis_edist_nnreal_le uniformity_basis_edist_nnreal_le\n\n",
 "uniformity_basis_edist_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem uniformity_basis_edist_nnreal :\n    ((uniformity) Î±).has_basis (fun Îµ : nnreal => 0 < Îµ) fun Îµ => { p : Î± Ã— Î± | edist p.1 p.2 < Îµ } :=\n  emetric.mk_uniformity_basis (fun _ => ennreal.coe_pos.2) fun Îµ Îµâ‚€ =>\n    let âŸ¨Î´, hÎ´âŸ© := ennreal.lt_iff_exists_nnreal_btwn.1 Îµâ‚€\n    âŸ¨Î´, ennreal.coe_pos.1 hÎ´.1, le_of_lt hÎ´.2âŸ©\n#align uniformity_basis_edist_nnreal uniformity_basis_edist_nnreal\n\n",
 "uniformity_basis_edist_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem uniformity_basis_edist_le' (Îµ' : ennreal) (hÎµ' : 0 < Îµ') :\n    ((uniformity) Î±).has_basis (fun Îµ : ennreal => Îµ âˆˆ Ioo 0 Îµ') fun Îµ => { p : Î± Ã— Î± | edist p.1 p.2 â‰¤ Îµ } :=\n  emetric.mk_uniformity_basis_le (fun _ => And.left) fun Îµ Îµâ‚€ =>\n    let âŸ¨Î´, hÎ´âŸ© := exists_between hÎµ'\n    âŸ¨min Îµ Î´, âŸ¨lt_min Îµâ‚€ hÎ´.1, lt_of_le_of_lt (min_le_right _ _) hÎ´.2âŸ©, min_le_left _ _âŸ©\n#align uniformity_basis_edist_le' uniformity_basis_edist_le'\n\n",
 "uniformity_basis_edist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem uniformity_basis_edist_le :\n    ((uniformity) Î±).has_basis (fun Îµ : ennreal => 0 < Îµ) fun Îµ => { p : Î± Ã— Î± | edist p.1 p.2 â‰¤ Îµ } :=\n  emetric.mk_uniformity_basis_le (fun _ => id) fun Îµ Îµâ‚€ => âŸ¨Îµ, Îµâ‚€, le_refl ÎµâŸ©\n#align uniformity_basis_edist_le uniformity_basis_edist_le\n\n",
 "uniformity_basis_edist_inv_two_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_basis_edist_inv_two_pow :\n    ((uniformity) Î±).has_basis (fun _ => true) fun n : â„• => { p : Î± Ã— Î± | edist p.1 p.2 < 2â»Â¹ ^ n } :=\n  emetric.mk_uniformity_basis (fun n _ => ennreal.pow_pos (ennreal.inv_pos.2 ennreal.two_ne_top) _) fun Îµ Îµâ‚€ =>\n    let âŸ¨n, hnâŸ© := ennreal.exists_inv_two_pow_lt (ne_of_gt Îµâ‚€)\n    âŸ¨n, trivial, le_of_lt hnâŸ©\n#align uniformity_basis_edist_inv_two_pow uniformity_basis_edist_inv_two_pow\n\n",
 "uniformity_basis_edist_inv_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_basis_edist_inv_nat :\n    ((uniformity) Î±).has_basis (fun _ => true) fun n : â„• => { p : Î± Ã— Î± | edist p.1 p.2 < (â†‘n)â»Â¹ } :=\n  emetric.mk_uniformity_basis (fun n _ => ennreal.inv_pos.2 <| ennreal.nat_ne_top n) fun Îµ Îµâ‚€ =>\n    let âŸ¨n, hnâŸ© := ennreal.exists_inv_nat_lt (ne_of_gt Îµâ‚€)\n    âŸ¨n, trivial, le_of_lt hnâŸ©\n#align uniformity_basis_edist_inv_nat uniformity_basis_edist_inv_nat\n\n",
 "uniformity_basis_edist'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem uniformity_basis_edist' (Îµ' : ennreal) (hÎµ' : 0 < Îµ') :\n    ((uniformity) Î±).has_basis (fun Îµ : ennreal => Îµ âˆˆ Ioo 0 Îµ') fun Îµ => { p : Î± Ã— Î± | edist p.1 p.2 < Îµ } :=\n  emetric.mk_uniformity_basis (fun _ => And.left) fun Îµ Îµâ‚€ =>\n    let âŸ¨Î´, hÎ´âŸ© := exists_between hÎµ'\n    âŸ¨min Îµ Î´, âŸ¨lt_min Îµâ‚€ hÎ´.1, lt_of_le_of_lt (min_le_right _ _) hÎ´.2âŸ©, min_le_left _ _âŸ©\n#align uniformity_basis_edist' uniformity_basis_edist'\n\n",
 "uniformity_basis_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem uniformity_basis_edist :\n    ((uniformity) Î±).has_basis (fun Îµ : ennreal => 0 < Îµ) fun Îµ => { p : Î± Ã— Î± | edist p.1 p.2 < Îµ } :=\n  (@uniformity_pseudoedist Î± _).symm â–¸\n    has_basis_binfi_principal\n      (fun r hr p hp =>\n        âŸ¨min r p, lt_min hr hp, fun x hx => lt_of_lt_of_le hx (min_le_left _ _), fun x hx =>\n          lt_of_lt_of_le hx (min_le_right _ _)âŸ©)\n      âŸ¨1, ennreal.zero_lt_oneâŸ©\n#align uniformity_basis_edist uniformity_basis_edist\n\n",
 "uniform_embedding_iff'":
 "/-- A map between emetric spaces is a uniform embedding if and only if the edistance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y` and conversely. -/\ntheorem uniform_embedding_iff' [emetric_space Î²] {f : Î³ â†’ Î²} :\n    uniform_embedding f â†”\n      (âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ {a b : Î³}, edist a b < Î´ â†’ edist (f a) (f b) < Îµ) âˆ§\n        âˆ€ Î´ > 0, âˆƒ Îµ > 0, âˆ€ {a b : Î³}, edist (f a) (f b) < Îµ â†’ edist a b < Î´ :=\n  by\n  constructor\n  Â· intro h\n    exact âŸ¨emetric.uniform_continuous_iff.1 (uniform_embedding_iff.1 h).2.1, (uniform_embedding_iff.1 h).2.2âŸ©\n  Â· rintro âŸ¨hâ‚, hâ‚‚âŸ©\n    refine' uniform_embedding_iff.2 âŸ¨_, emetric.uniform_continuous_iff.2 hâ‚, hâ‚‚âŸ©\n    intro x y hxy\n    have : edist x y â‰¤ 0 := by\n      refine' le_of_forall_lt' fun Î´ Î´pos => _\n      rcases hâ‚‚ Î´ Î´pos with âŸ¨Îµ, Îµpos, hÎµâŸ©\n      have : edist (f x) (f y) < Îµ := by simpa [hxy]\n      exact hÎµ this\n    simpa using this\n#align uniform_embedding_iff' uniform_embedding_iff'\n\n",
 "uniform_embedding_iff":
 "/-- Îµ-Î´ characterization of uniform embeddings on pseudoemetric spaces -/\ntheorem uniform_embedding_iff [pseudo_emetric_space Î²] {f : Î± â†’ Î²} :\n    uniform_embedding f â†”\n      function.injective f âˆ§\n        uniform_continuous f âˆ§ âˆ€ Î´ > 0, âˆƒ Îµ > 0, âˆ€ {a b : Î±}, edist (f a) (f b) < Îµ â†’ edist a b < Î´ :=\n  uniform_embedding_def'.trans <|\n    and_congr iff.rfl <|\n      and_congr iff.rfl\n        âŸ¨fun H Î´ Î´0 =>\n          let âŸ¨t, tu, htâŸ© := H _ (edist_mem_uniformity Î´0)\n          let âŸ¨Îµ, Îµ0, hÎµâŸ© := mem_uniformity_edist.1 tu\n          âŸ¨Îµ, Îµ0, fun a b h => ht _ _ (hÎµ h)âŸ©,\n          fun H s su =>\n          let âŸ¨Î´, Î´0, hÎ´âŸ© := mem_uniformity_edist.1 su\n          let âŸ¨Îµ, Îµ0, hÎµâŸ© := H _ Î´0\n          âŸ¨_, edist_mem_uniformity Îµ0, fun a b h => hÎ´ (hÎµ h)âŸ©âŸ©\n#align uniform_embedding_iff uniform_embedding_iff\n\n",
 "uniform_continuous_on_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection {a b Â«expr âˆˆ Â» s} -/\n/-- Îµ-Î´ characterization of uniform continuity on a set for pseudoemetric spaces -/\ntheorem uniform_continuous_on_iff [pseudo_emetric_space Î²] {f : Î± â†’ Î²} {s : set Î±} :\n    uniform_continuous_on f s â†”\n      âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ {a} {_ : a âˆˆ s} {b} {_ : b âˆˆ s}, edist a b < Î´ â†’ edist (f a) (f b) < Îµ :=\n  uniformity_basis_edist.uniform_continuous_on_iff uniformity_basis_edist\n#align uniform_continuous_on_iff uniform_continuous_on_iff\n\n",
 "uniform_continuous_iff":
 "/-- Îµ-Î´ characterization of uniform continuity on pseudoemetric spaces -/\ntheorem uniform_continuous_iff [pseudo_emetric_space Î²] {f : Î± â†’ Î²} :\n    uniform_continuous f â†” âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ {a b : Î±}, edist a b < Î´ â†’ edist (f a) (f b) < Îµ :=\n  uniformity_basis_edist.uniform_continuous_iff uniformity_basis_edist\n#align uniform_continuous_iff uniform_continuous_iff\n\n",
 "totally_bounded_iff'":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem totally_bounded_iff' {s : set Î±} :\n    totally_bounded s â†”\n      âˆ€ Îµ > 0,\n        âˆƒ (t : _)(_ : t âŠ† s),\n          set.finite t âˆ§\n            s âŠ†\n              Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n                (ball y Îµ) :=\n  âŸ¨fun H Îµ Îµ0 => (totally_bounded_iff_subset.1 H) _ (edist_mem_uniformity Îµ0), fun H r ru =>\n    let âŸ¨Îµ, Îµ0, hÎµâŸ© := mem_uniformity_edist.1 ru\n    let âŸ¨t, _, ft, hâŸ© := H Îµ Îµ0\n    âŸ¨t, ft, h.trans <| Unionâ‚‚_mono fun y yt z => hÎµâŸ©âŸ©\n#align totally_bounded_iff' totally_bounded_iff'\n\n",
 "totally_bounded_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem totally_bounded_iff {s : set Î±} :\n    totally_bounded s â†”\n      âˆ€ Îµ > 0,\n        âˆƒ t : set Î±,\n          t.finite âˆ§\n            s âŠ†\n              Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n                (ball y Îµ) :=\n  âŸ¨fun H Îµ Îµ0 => H _ (edist_mem_uniformity Îµ0), fun H r ru =>\n    let âŸ¨Îµ, Îµ0, hÎµâŸ© := mem_uniformity_edist.1 ru\n    let âŸ¨t, ft, hâŸ© := H Îµ Îµ0\n    âŸ¨t, ft, h.trans <| Unionâ‚‚_mono fun y yt z => hÎµâŸ©âŸ©\n#align totally_bounded_iff totally_bounded_iff\n\n",
 "tendsto_uniformly_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/-- Expressing uniform convergence on a set using `edist`. -/\ntheorem tendsto_uniformly_on_iff {Î¹ : Type _} {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} {s : set Î²} :\n    tendsto_uniformly_on F f p s â†”\n      âˆ€ Îµ > 0,\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" p\n          (âˆ€ x âˆˆ s, edist (f x) (F n x) < Îµ) :=\n  by\n  refine' âŸ¨fun H Îµ hÎµ => H _ (edist_mem_uniformity hÎµ), fun H u hu => _âŸ©\n  rcases mem_uniformity_edist.1 hu with âŸ¨Îµ, Îµpos, hÎµâŸ©\n  exact (H Îµ Îµpos).mono fun n hs x hx => hÎµ (hs x hx)\n#align tendsto_uniformly_on_iff tendsto_uniformly_on_iff\n\n",
 "tendsto_uniformly_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/-- Expressing uniform convergence using `edist`. -/\ntheorem tendsto_uniformly_iff {Î¹ : Type _} {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} :\n    tendsto_uniformly F f p â†”\n      âˆ€ Îµ > 0,\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" p\n          (âˆ€ x, edist (f x) (F n x) < Îµ) :=\n  by simp only [â† tendsto_uniformly_on_univ, tendsto_uniformly_on_iff, mem_univ, forall_const]\n#align tendsto_uniformly_iff tendsto_uniformly_iff\n\n",
 "tendsto_nhds_within_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem tendsto_nhds_within_nhds_within {t : set Î²} {a b} :\n    tendsto f (nhds_within s a) (nhds_within t b) â†”\n      âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ edist x a < Î´ â†’ f x âˆˆ t âˆ§ edist (f x) b < Îµ :=\n  (nhds_within_basis_eball.tendsto_iff nhds_within_basis_eball).trans <|\n    forallâ‚‚_congr fun Îµ hÎµ => existsâ‚‚_congr fun Î´ hÎ´ => forall_congr' fun x => by simp <;> itauto\n#align tendsto_nhds_within_nhds_within tendsto_nhds_within_nhds_within\n\n",
 "tendsto_nhds_within_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_nhds_within_nhds {a b} :\n    tendsto f (nhds_within s a) ((nhds) b) â†” âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ {x : Î±}, x âˆˆ s â†’ edist x a < Î´ â†’ edist (f x) b < Îµ :=\n  by\n  rw [â† nhds_within_univ b, tendsto_nhds_within_nhds_within]\n  simp only [mem_univ, true_and_iff]\n#align tendsto_nhds_within_nhds tendsto_nhds_within_nhds\n\n",
 "tendsto_nhds_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_nhds_nhds {a b} :\n    tendsto f ((nhds) a) ((nhds) b) â†” âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ â¦ƒxâ¦„, edist x a < Î´ â†’ edist (f x) b < Îµ :=\n  nhds_basis_eball.tendsto_iff nhds_basis_eball\n#align tendsto_nhds_nhds tendsto_nhds_nhds\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\ntheorem tendsto_nhds {f : filter Î²} {u : Î² â†’ Î±} {a : Î±} :\n    tendsto u f ((nhds) a) â†”\n      âˆ€ Îµ > 0,\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" f\n          (edist (u x) a < Îµ) :=\n  nhds_basis_eball.tendsto_right_iff\n#align tendsto_nhds tendsto_nhds\n\n",
 "tendsto_locally_uniformly_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/-- Expressing locally uniform convergence on a set using `edist`. -/\ntheorem tendsto_locally_uniformly_on_iff {Î¹ : Type _} [topological_space Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹}\n    {s : set Î²} :\n    tendsto_locally_uniformly_on F f p s â†”\n      âˆ€ Îµ > 0,\n        âˆ€ x âˆˆ s,\n          âˆƒ t âˆˆ nhds_within s x,\n            Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" p\n              (âˆ€ y âˆˆ t, edist (f y) (F n y) < Îµ) :=\n  by\n  refine' âŸ¨fun H Îµ hÎµ => H _ (edist_mem_uniformity hÎµ), fun H u hu x hx => _âŸ©\n  rcases mem_uniformity_edist.1 hu with âŸ¨Îµ, Îµpos, hÎµâŸ©\n  rcases H Îµ Îµpos x hx with âŸ¨t, ht, HtâŸ©\n  exact âŸ¨t, ht, Ht.mono fun n hs x hx => hÎµ (hs x hx)âŸ©\n#align tendsto_locally_uniformly_on_iff tendsto_locally_uniformly_on_iff\n\n",
 "tendsto_locally_uniformly_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/-- Expressing locally uniform convergence using `edist`. -/\ntheorem tendsto_locally_uniformly_iff {Î¹ : Type _} [topological_space Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} :\n    tendsto_locally_uniformly F f p â†”\n      âˆ€ Îµ > 0,\n        âˆ€ x : Î²,\n          âˆƒ t âˆˆ (nhds) x,\n            Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" p\n              (âˆ€ y âˆˆ t, edist (f y) (F n y) < Îµ) :=\n  by\n  simp only [â† tendsto_locally_uniformly_on_univ, tendsto_locally_uniformly_on_iff, mem_univ, forall_const, exists_prop,\n    nhds_within_univ]\n#align tendsto_locally_uniformly_iff tendsto_locally_uniformly_iff\n\n",
 "tendsto_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_at_top [nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} {a : Î±} :\n    tendsto u at_top ((nhds) a) â†” âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, edist (u n) a < Îµ :=\n  (at_top_basis.tendsto_iff nhds_basis_eball).trans <| by simp only [exists_prop, true_and_iff, mem_Ici, mem_ball]\n#align tendsto_at_top tendsto_at_top\n\n",
 "subset_countable_closure_of_compact":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set.  -/\ntheorem subset_countable_closure_of_compact {s : set Î±} (hs : is_compact s) :\n    âˆƒ (t : _)(_ : t âŠ† s), t.countable âˆ§ s âŠ† closure t :=\n  by\n  refine' subset_countable_closure_of_almost_dense_set s fun Îµ hÎµ => _\n  rcases totally_bounded_iff'.1 hs.totally_bounded Îµ hÎµ with âŸ¨t, hts, htf, hstâŸ©\n  exact âŸ¨t, htf.countable, subset.trans hst <| Unionâ‚‚_mono fun _ _ => ball_subset_closed_ballâŸ©\n#align subset_countable_closure_of_compact subset_countable_closure_of_compact\n\n",
 "subset_countable_closure_of_almost_dense_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\n/-- For a set `s` in a pseudo emetric space, if for every `Îµ > 0` there exists a countable\nset that is `Îµ`-dense in `s`, then there exists a countable subset `t âŠ† s` that is dense in `s`. -/\ntheorem subset_countable_closure_of_almost_dense_set (s : set Î±)\n    (hs :\n      âˆ€ Îµ > 0,\n        âˆƒ t : set Î±,\n          t.countable âˆ§\n            s âŠ†\n              Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n                (closed_ball x Îµ)) :\n    âˆƒ (t : _)(_ : t âŠ† s), t.countable âˆ§ s âŠ† closure t :=\n  by\n  rcases s.eq_empty_or_nonempty with (rfl | âŸ¨xâ‚€, hxâ‚€âŸ©)\n  Â· exact âŸ¨âˆ…, empty_subset _, countable_empty, empty_subset _âŸ©\n  choose! T hTc hsT using fun n : â„• => hs nâ»Â¹ (by simp)\n  have : âˆ€ r x, âˆƒ y âˆˆ s, closed_ball x r âˆ© s âŠ† closed_ball y (r * 2) :=\n    by\n    intro r x\n    rcases(closed_ball x r âˆ© s).eq_empty_or_nonempty with (he | âŸ¨y, hxy, hysâŸ©)\n    Â· refine' âŸ¨xâ‚€, hxâ‚€, _âŸ©\n      rw [he]\n      exact empty_subset _\n    Â· refine' âŸ¨y, hys, fun z hz => _âŸ©\n      calc\n        edist z y â‰¤ edist z x + edist y x := edist_triangle_right _ _ _\n        _ â‰¤ r + r := add_le_add hz.1 hxy\n        _ = r * 2 := (mul_two r).symm\n        \n  choose f hfs hf\n  refine'\n    âŸ¨Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n        (Â«expr '' Â» (f nâ»Â¹) (T n)),\n      Union_subset fun n => image_subset_iff.2 fun z hz => hfs _ _, countable_Union fun n => (hTc n).image _, _âŸ©\n  refine' fun x hx => mem_closure_iff.2 fun Îµ Îµ0 => _\n  rcases ennreal.exists_inv_nat_lt (ennreal.half_pos Îµ0.lt.ne').ne' with âŸ¨n, hnâŸ©\n  rcases mem_Unionâ‚‚.1 (hsT n hx) with âŸ¨y, hyn, hyxâŸ©\n  refine' âŸ¨f nâ»Â¹ y, mem_Union.2 âŸ¨n, mem_image_of_mem _ hynâŸ©, _âŸ©\n  calc\n    edist x (f nâ»Â¹ y) â‰¤ nâ»Â¹ * 2 := hf _ _ âŸ¨hyx, hxâŸ©\n    _ < Îµ := ennreal.mul_lt_of_lt_div hn\n    \n#align subset_countable_closure_of_almost_dense_set subset_countable_closure_of_almost_dense_set\n\n",
 "second_countable_of_sigma_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/-- A sigma compact pseudo emetric space has second countable topology. This is not an instance\nto avoid a loop with `sigma_compact_space_of_locally_compact_second_countable`.  -/\ntheorem second_countable_of_sigma_compact [sigma_compact_space Î±] : second_countable_topology Î± :=\n  by\n  suffices separable_space Î± by exact uniform_space.second_countable_of_separable Î±\n  choose T hTsub hTc hsubT using fun n => subset_countable_closure_of_compact (is_compact_compact_covering Î± n)\n  refine'\n    âŸ¨âŸ¨Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (T n),\n        countable_Union hTc, fun x => _âŸ©âŸ©\n  rcases Union_eq_univ_iff.1 (Union_compact_covering Î±) x with âŸ¨n, hnâŸ©\n  exact closure_mono (subset_Union _ n) (hsubT _ hn)\n#align second_countable_of_sigma_compact second_countable_of_sigma_compact\n\n",
 "second_countable_of_almost_dense_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem second_countable_of_almost_dense_set\n    (hs :\n      âˆ€ Îµ > 0,\n        âˆƒ t : set Î±,\n          t.countable âˆ§\n            Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n                (closed_ball x Îµ) =\n              univ) :\n    second_countable_topology Î± :=\n  by\n  suffices separable_space Î± by exact uniform_space.second_countable_of_separable Î±\n  rcases subset_countable_closure_of_almost_dense_set (univ : set Î±) fun Îµ Îµ0 => _ with âŸ¨t, -, htc, htâŸ©\n  Â· exact âŸ¨âŸ¨t, htc, fun x => ht (mem_univ x)âŸ©âŸ©\n  Â· rcases hs Îµ Îµ0 with âŸ¨t, htc, htâŸ©\n    exact âŸ¨t, htc, univ_subset_iff.2 htâŸ©\n#align second_countable_of_almost_dense_set second_countable_of_almost_dense_set\n\n",
 "pos_of_mem_ball":
 "theorem pos_of_mem_ball (hy : y âˆˆ ball x Îµ) : 0 < Îµ :=\n  lt_of_le_of_lt (zero_le _) hy\n#align pos_of_mem_ball pos_of_mem_ball\n\n",
 "ord_connected_set_of_closed_ball_subset":
 "theorem ord_connected_set_of_closed_ball_subset (x : Î±) (s : set Î±) : OrdConnected { r | closed_ball x r âŠ† s } :=\n  âŸ¨fun râ‚ hrâ‚ râ‚‚ hrâ‚‚ r hr => (closed_ball_subset_closed_ball hr.2).trans hrâ‚‚âŸ©\n#align ord_connected_set_of_closed_ball_subset ord_connected_set_of_closed_ball_subset\n\n",
 "ord_connected_set_of_ball_subset":
 "theorem ord_connected_set_of_ball_subset (x : Î±) (s : set Î±) : OrdConnected { r | ball x r âŠ† s } :=\n  âŸ¨fun râ‚ hrâ‚ râ‚‚ hrâ‚‚ r hr => (ball_subset_ball hr.2).trans hrâ‚‚âŸ©\n#align ord_connected_set_of_ball_subset ord_connected_set_of_ball_subset\n\n",
 "nhds_within_basis_eball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem nhds_within_basis_eball : (nhds_within s x).has_basis (fun Îµ : ennreal => 0 < Îµ) fun Îµ => ball x Îµ âˆ© s :=\n  nhds_within_has_basis nhds_basis_eball s\n#align nhds_within_basis_eball nhds_within_basis_eball\n\n",
 "nhds_within_basis_closed_eball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem nhds_within_basis_closed_eball :\n    (nhds_within s x).has_basis (fun Îµ : ennreal => 0 < Îµ) fun Îµ => closed_ball x Îµ âˆ© s :=\n  nhds_within_has_basis nhds_basis_closed_eball s\n#align nhds_within_basis_closed_eball nhds_within_basis_closed_eball\n\n",
 "nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_eq :\n    (nhds) x =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) (ball x Îµ)) :=\n  nhds_basis_eball.eq_binfi\n#align nhds_eq nhds_eq\n\n",
 "nhds_basis_eball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem nhds_basis_eball : ((nhds) x).has_basis (fun Îµ : ennreal => 0 < Îµ) (ball x) :=\n  nhds_basis_uniformity uniformity_basis_edist\n#align nhds_basis_eball nhds_basis_eball\n\n",
 "nhds_basis_closed_eball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem nhds_basis_closed_eball : ((nhds) x).has_basis (fun Îµ : ennreal => 0 < Îµ) (closed_ball x) :=\n  nhds_basis_uniformity uniformity_basis_edist_le\n#align nhds_basis_closed_eball nhds_basis_closed_eball\n\n",
 "mk_uniformity_basis_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Given `f : Î² â†’ â„â‰¥0âˆ`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then closed `f i`-neighborhoods of the diagonal form a basis of `ğ“¤ Î±`.\n\nFor specific bases see `uniformity_basis_edist_le` and `uniformity_basis_edist_le'`. -/\nprotected theorem emetric.mk_uniformity_basis_le {Î² : Type _} {p : Î² â†’ Prop} {f : Î² â†’ ennreal}\n    (hfâ‚€ : âˆ€ x, p x â†’ 0 < f x) (hf : âˆ€ Îµ, 0 < Îµ â†’ âˆƒ (x : _)(hx : p x), f x â‰¤ Îµ) :\n    ((uniformity) Î±).has_basis p fun x => { p : Î± Ã— Î± | edist p.1 p.2 â‰¤ f x } :=\n  by\n  refine' âŸ¨fun s => uniformity_basis_edist.mem_iff.trans _âŸ©\n  constructor\n  Â· rintro âŸ¨Îµ, Îµâ‚€, hÎµâŸ©\n    rcases exists_between Îµâ‚€ with âŸ¨Îµ', hÎµ'âŸ©\n    rcases hf Îµ' hÎµ'.1 with âŸ¨i, hi, HâŸ©\n    exact âŸ¨i, hi, fun x hx => hÎµ <| lt_of_le_of_lt (le_trans hx H) hÎµ'.2âŸ©\n  Â· exact fun âŸ¨i, hi, HâŸ© => âŸ¨f i, hfâ‚€ i hi, fun x hx => H (le_of_lt hx)âŸ©\n#align emetric.mk_uniformity_basis_le emetric.mk_uniformity_basis_le\n\n",
 "mk_uniformity_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Given `f : Î² â†’ â„â‰¥0âˆ`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then `f i`-neighborhoods of the diagonal form a basis of `ğ“¤ Î±`.\n\nFor specific bases see `uniformity_basis_edist`, `uniformity_basis_edist'`,\n`uniformity_basis_edist_nnreal`, and `uniformity_basis_edist_inv_nat`. -/\nprotected theorem emetric.mk_uniformity_basis {Î² : Type _} {p : Î² â†’ Prop} {f : Î² â†’ ennreal} (hfâ‚€ : âˆ€ x, p x â†’ 0 < f x)\n    (hf : âˆ€ Îµ, 0 < Îµ â†’ âˆƒ (x : _)(hx : p x), f x â‰¤ Îµ) :\n    ((uniformity) Î±).has_basis p fun x => { p : Î± Ã— Î± | edist p.1 p.2 < f x } :=\n  by\n  refine' âŸ¨fun s => uniformity_basis_edist.mem_iff.trans _âŸ©\n  constructor\n  Â· rintro âŸ¨Îµ, Îµâ‚€, hÎµâŸ©\n    rcases hf Îµ Îµâ‚€ with âŸ¨i, hi, HâŸ©\n    exact âŸ¨i, hi, fun x hx => hÎµ <| lt_of_lt_of_le hx HâŸ©\n  Â· exact fun âŸ¨i, hi, HâŸ© => âŸ¨f i, hfâ‚€ i hi, HâŸ©\n#align emetric.mk_uniformity_basis emetric.mk_uniformity_basis\n\n",
 "mem_uniformity_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Characterization of the elements of the uniformity in terms of the extended distance -/\ntheorem mem_uniformity_edist {s : set (Î± Ã— Î±)} :\n    s âˆˆ (uniformity) Î± â†” âˆƒ Îµ > 0, âˆ€ {a b : Î±}, edist a b < Îµ â†’ (a, b) âˆˆ s :=\n  uniformity_basis_edist.mem_uniformity_iff\n#align mem_uniformity_edist mem_uniformity_edist\n\n",
 "mem_nhds_within_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem mem_nhds_within_iff : s âˆˆ nhds_within t x â†” âˆƒ Îµ > 0, ball x Îµ âˆ© t âŠ† s :=\n  nhds_within_basis_eball.mem_iff\n#align mem_nhds_within_iff mem_nhds_within_iff\n\n",
 "mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_nhds_iff : s âˆˆ (nhds) x â†” âˆƒ Îµ > 0, ball x Îµ âŠ† s :=\n  nhds_basis_eball.mem_iff\n#align mem_nhds_iff mem_nhds_iff\n\n",
 "mem_closure_iff":
 "/-- Îµ-characterization of the closure in pseudoemetric spaces -/\ntheorem mem_closure_iff : x âˆˆ closure s â†” âˆ€ Îµ > 0, âˆƒ y âˆˆ s, edist x y < Îµ :=\n  (mem_closure_iff_nhds_basis nhds_basis_eball).trans <| by simp only [mem_ball, edist_comm x]\n#align mem_closure_iff mem_closure_iff\n\n",
 "mem_closed_ball_self":
 "theorem mem_closed_ball_self : x âˆˆ closed_ball x Îµ :=\n  show edist x x â‰¤ Îµ by rw [edist_self] <;> exact bot_le\n#align mem_closed_ball_self mem_closed_ball_self\n\n",
 "mem_closed_ball_comm":
 "theorem mem_closed_ball_comm : x âˆˆ closed_ball y Îµ â†” y âˆˆ closed_ball x Îµ := by rw [mem_closed_ball', mem_closed_ball]\n#align mem_closed_ball_comm mem_closed_ball_comm\n\n",
 "mem_closed_ball'":
 "theorem mem_closed_ball' : y âˆˆ closed_ball x Îµ â†” edist x y â‰¤ Îµ := by rw [edist_comm, mem_closed_ball]\n#align mem_closed_ball' mem_closed_ball'\n\n",
 "mem_closed_ball":
 "@[simp]\ntheorem mem_closed_ball : y âˆˆ closed_ball x Îµ â†” edist y x â‰¤ Îµ :=\n  iff.rfl\n#align mem_closed_ball mem_closed_ball\n\n",
 "mem_ball_self":
 "theorem mem_ball_self (h : 0 < Îµ) : x âˆˆ ball x Îµ :=\n  show edist x x < Îµ by rw [edist_self] <;> assumption\n#align mem_ball_self mem_ball_self\n\n",
 "mem_ball_comm":
 "theorem mem_ball_comm : x âˆˆ ball y Îµ â†” y âˆˆ ball x Îµ := by rw [mem_ball', mem_ball]\n#align mem_ball_comm mem_ball_comm\n\n",
 "mem_ball'":
 "theorem mem_ball' : y âˆˆ ball x Îµ â†” edist x y < Îµ := by rw [edist_comm, mem_ball]\n#align mem_ball' mem_ball'\n\n",
 "mem_ball":
 "@[simp]\ntheorem mem_ball : y âˆˆ ball x Îµ â†” edist y x < Îµ :=\n  iff.rfl\n#align mem_ball mem_ball\n\n",
 "is_open_iff":
 "theorem is_open_iff : is_open s â†” âˆ€ x âˆˆ s, âˆƒ Îµ > 0, ball x Îµ âŠ† s := by simp [is_open_iff_nhds, mem_nhds_iff]\n#align is_open_iff is_open_iff\n\n",
 "is_open_ball":
 "theorem is_open_ball : is_open (ball x Îµ) :=\n  is_open_iff.2 fun y => exists_ball_subset_ball\n#align is_open_ball is_open_ball\n\n",
 "is_closed_ball_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_closed_ball_top : is_closed (ball x (Â«exprâŠ¤Â»)) :=\n  is_open_compl_iff.1 <|\n    is_open_iff.2 fun y hy =>\n      âŸ¨Â«exprâŠ¤Â», ennreal.coe_lt_top,\n        (ball_disjoint <| by\n            rw [ennreal.top_add]\n            exact le_of_not_lt hy).subset_compl_rightâŸ©\n#align is_closed_ball_top is_closed_ball_top\n\n",
 "inseparable_iff":
 "theorem inseparable_iff : inseparable x y â†” edist x y = 0 := by\n  simp [inseparable_iff_mem_closure, mem_closure_iff, edist_comm, forall_lt_iff_le']\n#align inseparable_iff inseparable_iff\n\n",
 "exists_ball_subset_ball":
 "theorem exists_ball_subset_ball (h : y âˆˆ ball x Îµ) : âˆƒ Îµ' > 0, ball y Îµ' âŠ† ball x Îµ :=\n  by\n  have : 0 < Îµ - edist y x := by simpa using h\n  refine' âŸ¨Îµ - edist y x, this, ball_subset _ (ne_top_of_lt h)âŸ©\n  exact (add_tsub_cancel_of_le (mem_ball.mp h).le).le\n#align exists_ball_subset_ball exists_ball_subset_ball\n\n",
 "eq_of_forall_edist_le":
 "/-- Two points coincide if their distance is `< Îµ` for all positive Îµ -/\ntheorem eq_of_forall_edist_le {x y : Î³} (h : âˆ€ Îµ > 0, edist x y â‰¤ Îµ) : x = y :=\n  eq_of_edist_eq_zero (eq_of_le_of_forall_le_of_dense bot_le h)\n#align eq_of_forall_edist_le eq_of_forall_edist_le\n\n",
 "edist_up_up":
 "@[simp]\ntheorem ulift.edist_up_up (x y : Î±) : edist (ulift.up x) (ulift.up y) = edist x y :=\n  rfl\n#align ulift.edist_up_up ulift.edist_up_up\n\n",
 "edist_unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµáµ’áµ–Â» -/\n@[to_additive]\ntheorem edist_unop (x y : Â«expr áµáµ’áµ–Â» Î±) : edist (unop x) (unop y) = edist x y :=\n  rfl\n#align edist_unop edist_unop\n\n",
 "edist_triangle_right":
 "theorem edist_triangle_right (x y z : Î±) : edist x y â‰¤ edist x z + edist y z := by\n  rw [edist_comm y] <;> apply edist_triangle\n#align edist_triangle_right edist_triangle_right\n\n",
 "edist_triangle_left":
 "-- the uniform structure is embedded in the emetric space structure\n-- to avoid instance diamond issues. See Note [forgetful inheritance].\n/- Pseudoemetric spaces are less common than metric spaces. Therefore, we work in a dedicated\nnamespace, while notions associated to metric spaces are mostly in the root namespace. -/\n/-- Triangle inequality for the extended distance -/\ntheorem edist_triangle_left (x y z : Î±) : edist x y â‰¤ edist z x + edist z y := by\n  rw [edist_comm z] <;> apply edist_triangle\n#align edist_triangle_left edist_triangle_left\n\n",
 "edist_triangle4":
 "theorem edist_triangle4 (x y z t : Î±) : edist x t â‰¤ edist x y + edist y z + edist z t :=\n  calc\n    edist x t â‰¤ edist x z + edist z t := edist_triangle x z t\n    _ â‰¤ edist x y + edist y z + edist z t := add_le_add_right (edist_triangle x y z) _\n    \n#align edist_triangle4 edist_triangle4\n\n",
 "edist_to_mul":
 "@[simp]\ntheorem edist_to_mul (a b : Additive X) : edist (toMul a) (toMul b) = edist a b :=\n  rfl\n#align edist_to_mul edist_to_mul\n\n",
 "edist_to_dual":
 "@[simp]\ntheorem edist_to_dual (a b : X) : edist (toDual a) (toDual b) = edist a b :=\n  rfl\n#align edist_to_dual edist_to_dual\n\n",
 "edist_to_add":
 "@[simp]\ntheorem edist_to_add (a b : Multiplicative X) : edist (toAdd a) (toAdd b) = edist a b :=\n  rfl\n#align edist_to_add edist_to_add\n\n",
 "edist_pos":
 "@[simp]\ntheorem edist_pos {x y : Î³} : 0 < edist x y â†” x â‰  y := by simp [â† not_le]\n#align edist_pos edist_pos\n\n",
 "edist_pi_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem edist_pi_le_iff [âˆ€ b, pseudo_emetric_space (Ï€ b)] {f g : âˆ€ b, Ï€ b} {d : ennreal} :\n    edist f g â‰¤ d â†” âˆ€ b, edist (f b) (g b) â‰¤ d :=\n  finset.sup_le_iff.trans <| by simp only [finset.mem_univ, forall_const]\n#align edist_pi_le_iff edist_pi_le_iff\n\n",
 "edist_pi_def":
 "theorem edist_pi_def [âˆ€ b, pseudo_emetric_space (Ï€ b)] (f g : âˆ€ b, Ï€ b) :\n    edist f g = finset.sup univ fun b => edist (f b) (g b) :=\n  rfl\n#align edist_pi_def edist_pi_def\n\n",
 "edist_pi_const_le":
 "theorem edist_pi_const_le (a b : Î±) : (edist (fun _ : Î² => a) fun _ => b) â‰¤ edist a b :=\n  edist_pi_le_iff.2 fun _ => le_rfl\n#align edist_pi_const_le edist_pi_const_le\n\n",
 "edist_pi_const":
 "@[simp]\ntheorem edist_pi_const [nonempty Î²] (a b : Î±) : (edist (fun x : Î² => a) fun _ => b) = edist a b :=\n  finset.sup_const univ_nonempty (edist a b)\n#align edist_pi_const edist_pi_const\n\n",
 "edist_op":
 "@[to_additive]\ntheorem edist_op (x y : Î±) : edist (op x) (op y) = edist x y :=\n  rfl\n#align edist_op edist_op\n\n",
 "edist_of_mul":
 "@[simp]\ntheorem edist_of_mul (a b : X) : edist (ofMul a) (ofMul b) = edist a b :=\n  rfl\n#align edist_of_mul edist_of_mul\n\n",
 "edist_of_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\n@[simp]\ntheorem edist_of_dual (a b : Â«expr áµ’áµˆÂ» X) : edist (ofDual a) (ofDual b) = edist a b :=\n  rfl\n#align edist_of_dual edist_of_dual\n\n",
 "edist_of_add":
 "@[simp]\ntheorem edist_of_add (a b : X) : edist (ofAdd a) (ofAdd b) = edist a b :=\n  rfl\n#align edist_of_add edist_of_add\n\n",
 "edist_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Fixed size neighborhoods of the diagonal belong to the uniform structure -/\ntheorem edist_mem_uniformity {Îµ : ennreal} (Îµ0 : 0 < Îµ) : { p : Î± Ã— Î± | edist p.1 p.2 < Îµ } âˆˆ (uniformity) Î± :=\n  mem_uniformity_edist.2 âŸ¨Îµ, Îµ0, fun a b => idâŸ©\n#align edist_mem_uniformity edist_mem_uniformity\n\n",
 "edist_le_zero":
 "theorem edist_le_zero {x y : Î³} : edist x y â‰¤ 0 â†” x = y :=\n  nonpos_iff_eq_zero.trans edist_eq_zero\n#align edist_le_zero edist_le_zero\n\n",
 "edist_le_range_sum_of_edist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- A version of `edist_le_range_sum_edist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem edist_le_range_sum_of_edist_le {f : â„• â†’ Î±} (n : â„•) {d : â„• â†’ ennreal}\n    (hd : âˆ€ {k}, k < n â†’ edist (f k) (f (k + 1)) â‰¤ d k) :\n    edist (f 0) (f n) â‰¤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (d i) :=\n  nat.Ico_zero_eq_range â–¸ edist_le_Ico_sum_of_edist_le (zero_le n) fun _ _ => hd\n#align edist_le_range_sum_of_edist_le edist_le_range_sum_of_edist_le\n\n",
 "edist_le_range_sum_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The triangle (polygon) inequality for sequences of points; `finset.range` version. -/\ntheorem edist_le_range_sum_edist (f : â„• â†’ Î±) (n : â„•) :\n    edist (f 0) (f n) â‰¤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (edist (f i) (f (i + 1))) :=\n  nat.Ico_zero_eq_range â–¸ edist_le_Ico_sum_edist f (nat.zero_le n)\n#align edist_le_range_sum_edist edist_le_range_sum_edist\n\n",
 "edist_le_pi_edist":
 "theorem edist_le_pi_edist [âˆ€ b, pseudo_emetric_space (Ï€ b)] (f g : âˆ€ b, Ï€ b) (b : Î²) : edist (f b) (g b) â‰¤ edist f g :=\n  finset.le_sup (finset.mem_univ b)\n#align edist_le_pi_edist edist_le_pi_edist\n\n",
 "edist_le_of_diam_le":
 "theorem edist_le_of_diam_le {d} (hx : x âˆˆ s) (hy : y âˆˆ s) (hd : diam s â‰¤ d) : edist x y â‰¤ d :=\n  diam_le_iff.1 hd x hx y hy\n#align edist_le_of_diam_le edist_le_of_diam_le\n\n",
 "edist_le_diam_of_mem":
 "/-- If two points belong to some set, their edistance is bounded by the diameter of the set -/\ntheorem edist_le_diam_of_mem (hx : x âˆˆ s) (hy : y âˆˆ s) : edist x y â‰¤ diam s :=\n  edist_le_of_diam_le hx hy le_rfl\n#align edist_le_diam_of_mem edist_le_diam_of_mem\n\n",
 "edist_le_Ico_sum_of_edist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- A version of `edist_le_Ico_sum_edist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem edist_le_Ico_sum_of_edist_le {f : â„• â†’ Î±} {m n} (hmn : m â‰¤ n) {d : â„• â†’ ennreal}\n    (hd : âˆ€ {k}, m â‰¤ k â†’ k < n â†’ edist (f k) (f (k + 1)) â‰¤ d k) :\n    edist (f m) (f n) â‰¤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (finset.Ico m n)\n        (d i) :=\n  le_trans (edist_le_Ico_sum_edist f hmn) <|\n    finset.sum_le_sum fun k hk => hd (finset.mem_Ico.1 hk).1 (finset.mem_Ico.1 hk).2\n#align edist_le_Ico_sum_of_edist_le edist_le_Ico_sum_of_edist_le\n\n",
 "edist_le_Ico_sum_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- The triangle (polygon) inequality for sequences of points; `finset.Ico` version. -/\ntheorem edist_le_Ico_sum_edist (f : â„• â†’ Î±) {m n} (h : m â‰¤ n) :\n    edist (f m) (f n) â‰¤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (finset.Ico m n)\n        (edist (f i) (f (i + 1))) :=\n  by\n  revert n\n  refine' Nat.le_induction _ _\n  Â· simp only [finset.sum_empty, finset.Ico_self, edist_self]\n    -- TODO: Why doesn't Lean close this goal automatically? `exact le_rfl` fails too.\n    exact le_refl (0 : ennreal)\n  Â· intro n hn hrec\n    calc\n      edist (f m) (f (n + 1)) â‰¤ edist (f m) (f n) + edist (f n) (f (n + 1)) := edist_triangle _ _ _\n      _ â‰¤\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (finset.Ico m n) _ +\n            _ :=\n        add_le_add hrec le_rfl\n      _ =\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (finset.Ico m (n + 1)) _ :=\n        by rw [nat.Ico_succ_right_eq_insert_Ico hn, finset.sum_insert, add_comm] <;> simp\n      \n#align edist_le_Ico_sum_edist edist_le_Ico_sum_edist\n\n",
 "edist_eq_zero":
 "--namespace\n/-- Characterize the equality of points by the vanishing of their extended distance -/\n@[simp]\ntheorem edist_eq_zero {x y : Î³} : edist x y = 0 â†” x = y :=\n  iff.intro eq_of_edist_eq_zero fun this : x = y => this â–¸ edist_self _\n#align edist_eq_zero edist_eq_zero\n\n",
 "edist_eq":
 "theorem prod.edist_eq [pseudo_emetric_space Î²] (x y : Î± Ã— Î²) : edist x y = max (edist x.1 y.1) (edist x.2 y.2) :=\n  rfl\n#align prod.edist_eq prod.edist_eq\n\n",
 "edist_congr_right":
 "theorem edist_congr_right {x y z : Î±} (h : edist x y = 0) : edist x z = edist y z :=\n  by\n  apply le_antisymm\n  Â· rw [â† zero_add (edist y z), â† h]\n    apply edist_triangle\n  Â· rw [edist_comm] at h\n    rw [â† zero_add (edist x z), â† h]\n    apply edist_triangle\n#align edist_congr_right edist_congr_right\n\n",
 "edist_congr_left":
 "theorem edist_congr_left {x y z : Î±} (h : edist x y = 0) : edist z x = edist z y :=\n  by\n  rw [edist_comm z x, edist_comm z y]\n  apply edist_congr_right h\n#align edist_congr_left edist_congr_left\n\n",
 "diam_union'":
 "theorem diam_union' {t : set Î±} (h : (s âˆ© t).nonempty) : diam (s âˆª t) â‰¤ diam s + diam t :=\n  by\n  let âŸ¨x, âŸ¨xs, xtâŸ©âŸ© := h\n  simpa using diam_union xs xt\n#align diam_union' diam_union'\n\n",
 "diam_union":
 "/-- The diameter of a union is controlled by the diameter of the sets, and the edistance\nbetween two points in the sets. -/\ntheorem diam_union {t : set Î±} (xs : x âˆˆ s) (yt : y âˆˆ t) : diam (s âˆª t) â‰¤ diam s + edist x y + diam t :=\n  by\n  have A : âˆ€ a âˆˆ s, âˆ€ b âˆˆ t, edist a b â‰¤ diam s + edist x y + diam t := fun a ha b hb =>\n    calc\n      edist a b â‰¤ edist a x + edist x y + edist y b := edist_triangle4 _ _ _ _\n      _ â‰¤ diam s + edist x y + diam t :=\n        add_le_add (add_le_add (edist_le_diam_of_mem ha xs) le_rfl) (edist_le_diam_of_mem yt hb)\n      \n  refine' diam_le fun a ha b hb => _\n  cases' (mem_union _ _ _).1 ha with h'a h'a <;> cases' (mem_union _ _ _).1 hb with h'b h'b\n  Â·\n    calc\n      edist a b â‰¤ diam s := edist_le_diam_of_mem h'a h'b\n      _ â‰¤ diam s + (edist x y + diam t) := le_self_add\n      _ = diam s + edist x y + diam t := (add_assoc _ _ _).symm\n      \n  Â· exact A a h'a b h'b\n  Â· have Z := A b h'b a h'a\n    rwa [edist_comm] at Z\n  Â·\n    calc\n      edist a b â‰¤ diam t := edist_le_diam_of_mem h'a h'b\n      _ â‰¤ diam s + edist x y + diam t := le_add_self\n      \n#align diam_union diam_union\n\n",
 "diam_triple":
 "theorem diam_triple : diam ({x, y, z} : set Î±) = max (max (edist x y) (edist x z)) (edist y z) := by\n  simp only [diam_insert, supáµ¢_insert, supáµ¢_singleton, diam_singleton, ennreal.max_zero_right, ennreal.sup_eq_max]\n#align diam_triple diam_triple\n\n",
 "diam_subsingleton":
 "/-- The diameter of a subsingleton vanishes. -/\ntheorem diam_subsingleton (hs : s.subsingleton) : diam s = 0 :=\n  nonpos_iff_eq_zero.1 <| diam_le fun x hx y hy => (hs hx hy).symm â–¸ edist_self y â–¸ le_rfl\n#align diam_subsingleton diam_subsingleton\n\n",
 "diam_singleton":
 "/-- The diameter of a singleton vanishes -/\n@[simp]\ntheorem diam_singleton : diam ({x} : set Î±) = 0 :=\n  diam_subsingleton subsingleton_singleton\n#align diam_singleton diam_singleton\n\n",
 "diam_pos_iff":
 "theorem diam_pos_iff : 0 < diam s â†” âˆƒ x âˆˆ s, âˆƒ y âˆˆ s, x â‰  y := by\n  simp only [pos_iff_ne_zero, ne.def, diam_eq_zero_iff, Set.Subsingleton, not_forall]\n#align diam_pos_iff diam_pos_iff\n\n",
 "diam_pi_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem diam_pi_le_of_le {Ï€ : Î² â†’ Type _} [fintype Î²] [âˆ€ b, pseudo_emetric_space (Ï€ b)] {s : âˆ€ b : Î², set (Ï€ b)}\n    {c : ennreal} (h : âˆ€ b, diam (s b) â‰¤ c) : diam (Set.pi univ s) â‰¤ c :=\n  by\n  apply diam_le fun x hx y hy => edist_pi_le_iff.mpr _\n  rw [mem_univ_pi] at hx hy\n  exact fun b => diam_le_iff.1 (h b) (x b) (hx b) (y b) (hy b)\n#align diam_pi_le_of_le diam_pi_le_of_le\n\n",
 "diam_pair":
 "theorem diam_pair : diam ({x, y} : set Î±) = edist x y := by\n  simp only [supáµ¢_singleton, diam_insert, diam_singleton, ennreal.max_zero_right]\n#align diam_pair diam_pair\n\n",
 "diam_mono":
 "/-- The diameter is monotonous with respect to inclusion -/\ntheorem diam_mono {s t : set Î±} (h : s âŠ† t) : diam s â‰¤ diam t :=\n  diam_le fun x hx y hy => edist_le_diam_of_mem (h hx) (h hy)\n#align diam_mono diam_mono\n\n",
 "diam_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem diam_le_iff {d : ennreal} : diam s â‰¤ d â†” âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, edist x y â‰¤ d := by simp only [diam, supáµ¢_le_iff]\n#align diam_le_iff diam_le_iff\n\n",
 "diam_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If the distance between any two points in a set is bounded by some constant, this constant\nbounds the diameter. -/\ntheorem diam_le {d : ennreal} (h : âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, edist x y â‰¤ d) : diam s â‰¤ d :=\n  diam_le_iff.2 h\n#align diam_le diam_le\n\n",
 "diam_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\ntheorem diam_insert :\n    diam (insert x s) =\n      max (Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" (edist x y))\n        (diam s) :=\n  eq_of_forall_ge_iff fun d => by\n    simp only [diam_le_iff, ball_insert_iff, edist_self, edist_comm x, max_le_iff, supáµ¢_le_iff, zero_le, true_and_iff,\n      forall_and, and_self_iff, â† and_assoc']\n#align diam_insert diam_insert\n\n",
 "diam_image_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem diam_image_le_iff {d : ennreal} {f : Î² â†’ Î±} {s : set Î²} :\n    diam (Â«expr '' Â» f s) â‰¤ d â†” âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, edist (f x) (f y) â‰¤ d := by simp only [diam_le_iff, ball_image_iff]\n#align diam_image_le_iff diam_image_le_iff\n\n",
 "diam_eq_zero_iff":
 "theorem diam_eq_zero_iff : diam s = 0 â†” s.subsingleton :=\n  âŸ¨fun h x hx y hy => edist_le_zero.1 <| h â–¸ edist_le_diam_of_mem hx hy, diam_subsingletonâŸ©\n#align diam_eq_zero_iff diam_eq_zero_iff\n\n",
 "diam_empty":
 "/-- The diameter of the empty set vanishes -/\n@[simp]\ntheorem diam_empty : diam (âˆ… : set Î±) = 0 :=\n  diam_subsingleton subsingleton_empty\n#align diam_empty diam_empty\n\n",
 "diam_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem diam_closed_ball {r : ennreal} : diam (closed_ball x r) â‰¤ 2 * r :=\n  diam_le fun a ha b hb =>\n    calc\n      edist a b â‰¤ edist a x + edist b x := edist_triangle_right _ _ _\n      _ â‰¤ r + r := add_le_add ha hb\n      _ = 2 * r := (two_mul r).symm\n      \n#align diam_closed_ball diam_closed_ball\n\n",
 "diam_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem diam_ball {r : ennreal} : diam (ball x r) â‰¤ 2 * r :=\n  le_trans (diam_mono ball_subset_closed_ball) diam_closed_ball\n#align diam_ball diam_ball\n\n",
 "diam_Union_mem_option":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\ntheorem diam_Union_mem_option {Î¹ : Type _} (o : option Î¹) (s : Î¹ â†’ set Î±) :\n    diam (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (s i)) =\n      Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" (diam (s i)) :=\n  by cases o <;> simp\n#align diam_Union_mem_option diam_Union_mem_option\n\n",
 "countable_closure_of_compact":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem countable_closure_of_compact {s : set Î³} (hs : is_compact s) :\n    âˆƒ (t : _)(_ : t âŠ† s), t.countable âˆ§ s = closure t :=\n  by\n  rcases subset_countable_closure_of_compact hs with âŸ¨t, hts, htc, hsubâŸ©\n  exact âŸ¨t, hts, htc, subset.antisymm hsub (closure_minimal hts hs.is_closed)âŸ©\n#align countable_closure_of_compact countable_closure_of_compact\n\n",
 "controlled_of_uniform_embedding":
 "/-- If a map between pseudoemetric spaces is a uniform embedding then the edistance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y`. -/\ntheorem controlled_of_uniform_embedding [pseudo_emetric_space Î²] {f : Î± â†’ Î²} :\n    uniform_embedding f â†’\n      (âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ {a b : Î±}, edist a b < Î´ â†’ edist (f a) (f b) < Îµ) âˆ§\n        âˆ€ Î´ > 0, âˆƒ Îµ > 0, âˆ€ {a b : Î±}, edist (f a) (f b) < Îµ â†’ edist a b < Î´ :=\n  by\n  intro h\n  exact âŸ¨uniform_continuous_iff.1 (uniform_embedding_iff.1 h).2.1, (uniform_embedding_iff.1 h).2.2âŸ©\n#align controlled_of_uniform_embedding controlled_of_uniform_embedding\n\n",
 "complete_of_convergent_controlled_sequences":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A very useful criterion to show that a space is complete is to show that all sequences\nwhich satisfy a bound of the form `edist (u n) (u m) < B N` for all `n m â‰¥ N` are\nconverging. This is often applied for `B N = 2^{-N}`, i.e., with a very fast convergence to\n`0`, which makes it possible to use arguments of converging series, while this is impossible\nto do in general for arbitrary Cauchy sequences. -/\ntheorem complete_of_convergent_controlled_sequences (B : â„• â†’ ennreal) (hB : âˆ€ n, 0 < B n)\n    (H : âˆ€ u : â„• â†’ Î±, (âˆ€ N n m : â„•, N â‰¤ n â†’ N â‰¤ m â†’ edist (u n) (u m) < B N) â†’ âˆƒ x, tendsto u at_top ((nhds) x)) :\n    complete_space Î± :=\n  uniform_space.complete_of_convergent_controlled_sequences (fun n => { p : Î± Ã— Î± | edist p.1 p.2 < B n })\n    (fun n => edist_mem_uniformity <| hB n) H\n#align complete_of_convergent_controlled_sequences complete_of_convergent_controlled_sequences\n\n",
 "complete_of_cauchy_seq_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A sequentially complete pseudoemetric space is complete. -/\ntheorem complete_of_cauchy_seq_tendsto :\n    (âˆ€ u : â„• â†’ Î±, cauchy_seq u â†’ âˆƒ a, tendsto u at_top ((nhds) a)) â†’ complete_space Î± :=\n  uniform_space.complete_of_cauchy_seq_tendsto\n#align complete_of_cauchy_seq_tendsto complete_of_cauchy_seq_tendsto\n\n",
 "closed_ball_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem closed_ball_top (x : Î±) : closed_ball x (ennreal.top) = univ :=\n  eq_univ_of_forall fun y => le_top\n#align closed_ball_top closed_ball_top\n\n",
 "closed_ball_subset_closed_ball":
 "theorem closed_ball_subset_closed_ball (h : Îµâ‚ â‰¤ Îµâ‚‚) : closed_ball x Îµâ‚ âŠ† closed_ball x Îµâ‚‚ := fun y (yx : _ â‰¤ Îµâ‚) =>\n  le_trans yx h\n#align closed_ball_subset_closed_ball closed_ball_subset_closed_ball\n\n",
 "closed_ball_prod_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem closed_ball_prod_same [pseudo_emetric_space Î²] (x : Î±) (y : Î²) (r : ennreal) :\n    lower_set.prod (closed_ball x r) (closed_ball y r) = closed_ball (x, y) r :=\n  ext fun z => max_le_iff.symm\n#align closed_ball_prod_same closed_ball_prod_same\n\n",
 "closed_ball_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem closed_ball_mem_nhds (x : Î±) {Îµ : ennreal} (Îµ0 : 0 < Îµ) : closed_ball x Îµ âˆˆ (nhds) x :=\n  mem_of_superset (ball_mem_nhds x Îµ0) ball_subset_closed_ball\n#align closed_ball_mem_nhds closed_ball_mem_nhds\n\n",
 "cauchy_seq_iff_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-- A variation of the emetric characterization of Cauchy sequences that deals with\n`â„â‰¥0` upper bounds. -/\ntheorem cauchy_seq_iff_nnreal [nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} :\n    cauchy_seq u â†” âˆ€ Îµ : nnreal, 0 < Îµ â†’ âˆƒ N, âˆ€ n, N â‰¤ n â†’ edist (u n) (u N) < Îµ :=\n  uniformity_basis_edist_nnreal.cauchy_seq_iff'\n#align cauchy_seq_iff_nnreal cauchy_seq_iff_nnreal\n\n",
 "cauchy_seq_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- A variation around the emetric characterization of Cauchy sequences -/\ntheorem cauchy_seq_iff' [nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} :\n    cauchy_seq u â†” âˆ€ Îµ > (0 : ennreal), âˆƒ N, âˆ€ n â‰¥ N, edist (u n) (u N) < Îµ :=\n  uniformity_basis_edist.cauchy_seq_iff'\n#align cauchy_seq_iff' cauchy_seq_iff'\n\n",
 "cauchy_seq_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (m n Â«expr â‰¥ Â» N) -/\n-- see Note [nolint_ge]\n/-- In a pseudoemetric space, Cauchy sequences are characterized by the fact that, eventually,\nthe pseudoedistance between its elements is arbitrarily small -/\n@[nolint ge_or_gt]\ntheorem cauchy_seq_iff [nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} :\n    cauchy_seq u â†” âˆ€ Îµ > 0, âˆƒ N, âˆ€ (m) (_ : m â‰¥ N) (n) (_ : n â‰¥ N), edist (u m) (u n) < Îµ :=\n  uniformity_basis_edist.cauchy_seq_iff\n#align cauchy_seq_iff cauchy_seq_iff\n\n",
 "cauchy_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x y Â«expr âˆˆ Â» t) -/\n/-- Îµ-Î´ characterization of Cauchy sequences on pseudoemetric spaces -/\nprotected theorem cauchy_iff {f : filter Î±} :\n    cauchy f â†” f â‰  Â«exprâŠ¥Â» âˆ§ âˆ€ Îµ > 0, âˆƒ t âˆˆ f, âˆ€ (x) (_ : x âˆˆ t) (y) (_ : y âˆˆ t), edist x y < Îµ := by\n  rw [â† ne_bot_iff] <;> exact uniformity_basis_edist.cauchy_iff\n#align cauchy_iff cauchy_iff\n\n",
 "ball_zero":
 "@[simp]\ntheorem ball_zero : ball x 0 = âˆ… := by rw [emetric.ball_eq_empty_iff]\n#align ball_zero ball_zero\n\n",
 "ball_subset_closed_ball":
 "theorem ball_subset_closed_ball : ball x Îµ âŠ† closed_ball x Îµ := fun y hy => le_of_lt hy\n#align ball_subset_closed_ball ball_subset_closed_ball\n\n",
 "ball_subset_ball":
 "theorem ball_subset_ball (h : Îµâ‚ â‰¤ Îµâ‚‚) : ball x Îµâ‚ âŠ† ball x Îµâ‚‚ := fun y (yx : _ < Îµâ‚) => lt_of_lt_of_le yx h\n#align ball_subset_ball ball_subset_ball\n\n",
 "ball_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem ball_subset (h : edist x y + Îµâ‚ â‰¤ Îµâ‚‚) (h' : edist x y â‰  ennreal.top) : ball x Îµâ‚ âŠ† ball y Îµâ‚‚ := fun z zx =>\n  calc\n    edist z y â‰¤ edist z x + edist x y := edist_triangle _ _ _\n    _ = edist x y + edist z x := add_comm _ _\n    _ < edist x y + Îµâ‚ := ennreal.add_lt_add_left h' zx\n    _ â‰¤ Îµâ‚‚ := h\n    \n#align ball_subset ball_subset\n\n",
 "ball_prod_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem ball_prod_same [pseudo_emetric_space Î²] (x : Î±) (y : Î²) (r : ennreal) :\n    lower_set.prod (ball x r) (ball y r) = ball (x, y) r :=\n  ext fun z => max_lt_iff.symm\n#align ball_prod_same ball_prod_same\n\n",
 "ball_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ball_mem_nhds (x : Î±) {Îµ : ennreal} (Îµ0 : 0 < Îµ) : ball x Îµ âˆˆ (nhds) x :=\n  is_open_ball.mem_nhds (mem_ball_self Îµ0)\n#align ball_mem_nhds ball_mem_nhds\n\n",
 "ball_eq_empty_iff":
 "theorem ball_eq_empty_iff : ball x Îµ = âˆ… â†” Îµ = 0 :=\n  eq_empty_iff_forall_not_mem.trans\n    âŸ¨fun h => le_bot_iff.1 (le_of_not_gt fun Îµ0 => h _ (mem_ball_self Îµ0)), fun Îµ0 y h =>\n      not_lt_of_le (le_of_eq Îµ0) (pos_of_mem_ball h)âŸ©\n#align ball_eq_empty_iff ball_eq_empty_iff\n\n",
 "ball_disjoint":
 "theorem ball_disjoint (h : Îµâ‚ + Îµâ‚‚ â‰¤ edist x y) : Disjoint (ball x Îµâ‚) (ball y Îµâ‚‚) :=\n  Set.disjoint_left.mpr fun z hâ‚ hâ‚‚ => (edist_triangle_left x y z).not_lt <| (ennreal.add_lt_add hâ‚ hâ‚‚).trans_le h\n#align ball_disjoint ball_disjoint\n\n"}