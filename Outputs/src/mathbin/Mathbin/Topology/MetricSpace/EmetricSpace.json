{"zero_eq_edist":
 "#print zero_eq_edist /-\n@[simp]\ntheorem zero_eq_edist {x y : Î³} : 0 = edist x y â†” x = y :=\n  iff.intro (fun h => eq_of_edist_eq_zero h.symm) fun this : x = y => this â–¸ (edist_self _).symm\n#align zero_eq_edist zero_eq_edist\n-/\n\n",
 "uniformity_pseudoedist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print uniformity_pseudoedist /-\n/-- Reformulation of the uniform structure in terms of the extended distance -/\ntheorem uniformity_pseudoedist :\n    (uniformity) Î± =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) { p : Î± Ã— Î± | edist p.1 p.2 < Îµ }) :=\n  pseudo_emetric_space.uniformity_edist\n#align uniformity_pseudoedist uniformity_pseudoedist\n-/\n\n",
 "uniformity_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print uniformity_edist /-\n/-- Reformulation of the uniform structure in terms of the extended distance -/\ntheorem uniformity_edist :\n    (uniformity) Î³ =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) { p : Î³ Ã— Î³ | edist p.1 p.2 < Îµ }) :=\n  pseudo_emetric_space.uniformity_edist\n#align uniformity_edist uniformity_edist\n-/\n\n",
 "uniformity_dist_of_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print uniformity_dist_of_mem_uniformity /-\n/-\nCopyright (c) 2015, 2017 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Robert Y. Lewis, Johannes HÃ¶lzl, Mario Carneiro, SÃ©bastien GouÃ«zel\n-/\n/-- Characterizing uniformities associated to a (generalized) distance function `D`\nin terms of the elements of the uniformity. -/\ntheorem uniformity_dist_of_mem_uniformity [linear_order Î²] {U : Filter (Î± Ã— Î±)} (z : Î²) (D : Î± â†’ Î± â†’ Î²)\n    (H : âˆ€ s, s âˆˆ U â†” âˆƒ Îµ > z, âˆ€ {a b : Î±}, D a b < Îµ â†’ (a, b) âˆˆ s) :\n    U =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) { p : Î± Ã— Î± | D p.1 p.2 < Îµ }) :=\n  HasBasis.eq_binfáµ¢ âŸ¨fun s => by simp only [H, subset_def, Prod.forall, mem_set_of]âŸ©\n#align uniformity_dist_of_mem_uniformity uniformity_dist_of_mem_uniformity\n-/\n\n",
 "uniformity_basis_edist_nnreal_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print uniformity_basis_edist_nnreal_le /-\ntheorem uniformity_basis_edist_nnreal_le :\n    ((uniformity) Î±).has_basis (fun Îµ : nnreal => 0 < Îµ) fun Îµ => { p : Î± Ã— Î± | edist p.1 p.2 â‰¤ Îµ } :=\n  EMetric.mk_uniformity_basis_le (fun _ => ENNReal.coe_pos.2) fun Îµ Îµâ‚€ =>\n    let âŸ¨Î´, hÎ´âŸ© := ENNReal.lt_iff_exists_nnreal_btwn.1 Îµâ‚€\n    âŸ¨Î´, ENNReal.coe_pos.1 hÎ´.1, le_of_lt hÎ´.2âŸ©\n#align uniformity_basis_edist_nnreal_le uniformity_basis_edist_nnreal_le\n-/\n\n",
 "uniformity_basis_edist_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print uniformity_basis_edist_nnreal /-\ntheorem uniformity_basis_edist_nnreal :\n    ((uniformity) Î±).has_basis (fun Îµ : nnreal => 0 < Îµ) fun Îµ => { p : Î± Ã— Î± | edist p.1 p.2 < Îµ } :=\n  EMetric.mk_uniformity_basis (fun _ => ENNReal.coe_pos.2) fun Îµ Îµâ‚€ =>\n    let âŸ¨Î´, hÎ´âŸ© := ENNReal.lt_iff_exists_nnreal_btwn.1 Îµâ‚€\n    âŸ¨Î´, ENNReal.coe_pos.1 hÎ´.1, le_of_lt hÎ´.2âŸ©\n#align uniformity_basis_edist_nnreal uniformity_basis_edist_nnreal\n-/\n\n",
 "uniformity_basis_edist_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n#print uniformity_basis_edist_le' /-\ntheorem uniformity_basis_edist_le' (Îµ' : ennreal) (hÎµ' : 0 < Îµ') :\n    ((uniformity) Î±).has_basis (fun Îµ : ennreal => Îµ âˆˆ Ioo 0 Îµ') fun Îµ => { p : Î± Ã— Î± | edist p.1 p.2 â‰¤ Îµ } :=\n  EMetric.mk_uniformity_basis_le (fun _ => And.left) fun Îµ Îµâ‚€ =>\n    let âŸ¨Î´, hÎ´âŸ© := exists_between hÎµ'\n    âŸ¨min Îµ Î´, âŸ¨lt_min Îµâ‚€ hÎ´.1, lt_of_le_of_lt (min_le_right _ _) hÎ´.2âŸ©, min_le_left _ _âŸ©\n#align uniformity_basis_edist_le' uniformity_basis_edist_le'\n-/\n\n",
 "uniformity_basis_edist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n#print uniformity_basis_edist_le /-\ntheorem uniformity_basis_edist_le :\n    ((uniformity) Î±).has_basis (fun Îµ : ennreal => 0 < Îµ) fun Îµ => { p : Î± Ã— Î± | edist p.1 p.2 â‰¤ Îµ } :=\n  EMetric.mk_uniformity_basis_le (fun _ => id) fun Îµ Îµâ‚€ => âŸ¨Îµ, Îµâ‚€, le_refl ÎµâŸ©\n#align uniformity_basis_edist_le uniformity_basis_edist_le\n-/\n\n",
 "uniformity_basis_edist_inv_two_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_basis_edist_inv_two_pow /-\ntheorem uniformity_basis_edist_inv_two_pow :\n    ((uniformity) Î±).has_basis (fun _ => True) fun n : â„• => { p : Î± Ã— Î± | edist p.1 p.2 < 2â»Â¹ ^ n } :=\n  EMetric.mk_uniformity_basis (fun n _ => ENNReal.pow_pos (ENNReal.inv_pos.2 ENNReal.two_ne_top) _) fun Îµ Îµâ‚€ =>\n    let âŸ¨n, hnâŸ© := ENNReal.exists_inv_two_pow_lt (ne_of_gt Îµâ‚€)\n    âŸ¨n, trivial, le_of_lt hnâŸ©\n#align uniformity_basis_edist_inv_two_pow uniformity_basis_edist_inv_two_pow\n-/\n\n",
 "uniformity_basis_edist_inv_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_basis_edist_inv_nat /-\ntheorem uniformity_basis_edist_inv_nat :\n    ((uniformity) Î±).has_basis (fun _ => True) fun n : â„• => { p : Î± Ã— Î± | edist p.1 p.2 < (â†‘n)â»Â¹ } :=\n  EMetric.mk_uniformity_basis (fun n _ => ENNReal.inv_pos.2 <| ENNReal.nat_ne_top n) fun Îµ Îµâ‚€ =>\n    let âŸ¨n, hnâŸ© := ENNReal.exists_inv_nat_lt (ne_of_gt Îµâ‚€)\n    âŸ¨n, trivial, le_of_lt hnâŸ©\n#align uniformity_basis_edist_inv_nat uniformity_basis_edist_inv_nat\n-/\n\n",
 "uniformity_basis_edist'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n#print uniformity_basis_edist' /-\ntheorem uniformity_basis_edist' (Îµ' : ennreal) (hÎµ' : 0 < Îµ') :\n    ((uniformity) Î±).has_basis (fun Îµ : ennreal => Îµ âˆˆ Ioo 0 Îµ') fun Îµ => { p : Î± Ã— Î± | edist p.1 p.2 < Îµ } :=\n  EMetric.mk_uniformity_basis (fun _ => And.left) fun Îµ Îµâ‚€ =>\n    let âŸ¨Î´, hÎ´âŸ© := exists_between hÎµ'\n    âŸ¨min Îµ Î´, âŸ¨lt_min Îµâ‚€ hÎ´.1, lt_of_le_of_lt (min_le_right _ _) hÎ´.2âŸ©, min_le_left _ _âŸ©\n#align uniformity_basis_edist' uniformity_basis_edist'\n-/\n\n",
 "uniformity_basis_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n#print uniformity_basis_edist /-\ntheorem uniformity_basis_edist :\n    ((uniformity) Î±).has_basis (fun Îµ : ennreal => 0 < Îµ) fun Îµ => { p : Î± Ã— Î± | edist p.1 p.2 < Îµ } :=\n  (@uniformSpace_edist Î± _).symm â–¸ UniformSpace.hasBasis_ofFun âŸ¨1, one_posâŸ© _ _ _ _ _\n#align uniformity_basis_edist uniformity_basis_edist\n-/\n\n",
 "uniform_continuous_on_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection {a b Â«expr âˆˆ Â» s} -/\n/-- Îµ-Î´ characterization of uniform continuity on a set for pseudoemetric spaces -/\ntheorem uniform_continuous_on_iff [PseudoEMetricSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} :\n    UniformContinuousOn f s â†”\n      âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ {a} {_ : a âˆˆ s} {b} {_ : b âˆˆ s}, edist a b < Î´ â†’ edist (f a) (f b) < Îµ :=\n  uniformity_basis_edist.uniform_continuous_on_iff uniformity_basis_edist\n#align uniform_continuous_on_iff uniform_continuous_on_iff\n\n",
 "uniformSpace_edist":
 "#print uniformSpace_edist /-\ntheorem uniformSpace_edist :\n    â€¹PseudoEMetricSpace Î±â€º.to_uniform_space = uniformSpaceOfEDist edist edist_self edist_comm edist_triangle :=\n  uniformSpace_eq uniformity_pseudoedist\n#align uniform_space_edist uniformSpace_edist\n-/\n\n",
 "uniformEmbedding_iff'":
 "#print EMetric.uniformEmbedding_iff' /-\n-- see Note [lower instance priority]\n/-- A map between emetric spaces is a uniform embedding if and only if the edistance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y` and conversely. -/\ntheorem EMetric.uniformEmbedding_iff' [EMetricSpace Î²] {f : Î³ â†’ Î²} :\n    UniformEmbedding f â†”\n      (âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ {a b : Î³}, edist a b < Î´ â†’ edist (f a) (f b) < Îµ) âˆ§\n        âˆ€ Î´ > 0, âˆƒ Îµ > 0, âˆ€ {a b : Î³}, edist (f a) (f b) < Îµ â†’ edist a b < Î´ :=\n  by\n  simp only [uniformEmbedding_iff_uniformInducing, uniformity_basis_edist.uniform_inducing_iff uniformity_basis_edist,\n    exists_prop]\n  rfl\n#align emetric.uniform_embedding_iff' EMetric.uniformEmbedding_iff'\n-/\n\n",
 "uniformEmbedding_iff":
 "#print uniformEmbedding_iff /-\n/-- Îµ-Î´ characterization of uniform embeddings on pseudoemetric spaces -/\ntheorem uniformEmbedding_iff [PseudoEMetricSpace Î²] {f : Î± â†’ Î²} :\n    UniformEmbedding f â†”\n      function.injective f âˆ§\n        UniformContinuous f âˆ§ âˆ€ Î´ > 0, âˆƒ Îµ > 0, âˆ€ {a b : Î±}, edist (f a) (f b) < Îµ â†’ edist a b < Î´ :=\n  by\n  simp only [uniformity_basis_edist.uniform_embedding_iff uniformity_basis_edist, exists_prop]\n  rfl\n#align uniform_embedding_iff uniformEmbedding_iff\n-/\n\n",
 "uniformContinuous_iff":
 "#print uniformContinuous_iff /-\n/-- Îµ-Î´ characterization of uniform continuity on pseudoemetric spaces -/\ntheorem uniformContinuous_iff [PseudoEMetricSpace Î²] {f : Î± â†’ Î²} :\n    UniformContinuous f â†” âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ {a b : Î±}, edist a b < Î´ â†’ edist (f a) (f b) < Îµ :=\n  uniformity_basis_edist.uniform_continuous_iff uniformity_basis_edist\n#align uniform_continuous_iff uniformContinuous_iff\n-/\n\n",
 "totally_bounded_iff'":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem totally_bounded_iff' {s : Set Î±} :\n    TotallyBounded s â†”\n      âˆ€ Îµ > 0,\n        âˆƒ (t : _)(_ : t âŠ† s),\n          Set.Finite t âˆ§\n            s âŠ†\n              Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n                (ball y Îµ) :=\n  âŸ¨fun H Îµ Îµ0 => (totallyBounded_iff_subset.1 H) _ (edist_mem_uniformity Îµ0), fun H r ru =>\n    let âŸ¨Îµ, Îµ0, hÎµâŸ© := mem_uniformity_edist.1 ru\n    let âŸ¨t, _, ft, hâŸ© := H Îµ Îµ0\n    âŸ¨t, ft, h.trans <| unionáµ¢â‚‚_mono fun y yt z => hÎµâŸ©âŸ©\n#align totally_bounded_iff' totally_bounded_iff'\n\n",
 "totally_bounded_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem totally_bounded_iff {s : Set Î±} :\n    TotallyBounded s â†”\n      âˆ€ Îµ > 0,\n        âˆƒ t : Set Î±,\n          t.finite âˆ§\n            s âŠ†\n              Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n                (ball y Îµ) :=\n  âŸ¨fun H Îµ Îµ0 => H _ (edist_mem_uniformity Îµ0), fun H r ru =>\n    let âŸ¨Îµ, Îµ0, hÎµâŸ© := mem_uniformity_edist.1 ru\n    let âŸ¨t, ft, hâŸ© := H Îµ Îµ0\n    âŸ¨t, ft, h.trans <| unionáµ¢â‚‚_mono fun y yt z => hÎµâŸ©âŸ©\n#align totally_bounded_iff totally_bounded_iff\n\n",
 "tendsto_uniformly_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/-- Expressing uniform convergence on a set using `edist`. -/\ntheorem tendsto_uniformly_on_iff {Î¹ : Type _} {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : Filter Î¹} {s : Set Î²} :\n    TendstoUniformlyOn F f p s â†”\n      âˆ€ Îµ > 0,\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" p\n          (âˆ€ x âˆˆ s, edist (f x) (F n x) < Îµ) :=\n  by\n  refine' âŸ¨fun H Îµ hÎµ => H _ (edist_mem_uniformity hÎµ), fun H u hu => _âŸ©\n  rcases mem_uniformity_edist.1 hu with âŸ¨Îµ, Îµpos, hÎµâŸ©\n  exact (H Îµ Îµpos).mono fun n hs x hx => hÎµ (hs x hx)\n#align tendsto_uniformly_on_iff tendsto_uniformly_on_iff\n\n",
 "tendsto_uniformly_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/-- Expressing uniform convergence using `edist`. -/\ntheorem tendsto_uniformly_iff {Î¹ : Type _} {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : Filter Î¹} :\n    TendstoUniformly F f p â†”\n      âˆ€ Îµ > 0,\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" p\n          (âˆ€ x, edist (f x) (F n x) < Îµ) :=\n  by simp only [â† tendstoUniformlyOn_univ, tendsto_uniformly_on_iff, mem_univ, forall_const]\n#align tendsto_uniformly_iff tendsto_uniformly_iff\n\n",
 "tendsto_nhds_within_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem tendsto_nhds_within_nhds_within {t : Set Î²} {a b} :\n    Tendsto f (nhds_within s a) (nhds_within t b) â†”\n      âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ edist x a < Î´ â†’ f x âˆˆ t âˆ§ edist (f x) b < Îµ :=\n  (nhdsWithin_basis_eball.tendsto_iff nhdsWithin_basis_eball).trans <|\n    forallâ‚‚_congr fun Îµ hÎµ => existsâ‚‚_congr fun Î´ hÎ´ => forall_congr' fun x => by simp <;> itauto\n#align tendsto_nhds_within_nhds_within tendsto_nhds_within_nhds_within\n\n",
 "tendsto_nhds_within_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_nhds_within_nhds {a b} :\n    Tendsto f (nhds_within s a) ((nhds) b) â†” âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ {x : Î±}, x âˆˆ s â†’ edist x a < Î´ â†’ edist (f x) b < Îµ :=\n  by\n  rw [â† nhdsWithin_univ b, tendsto_nhds_within_nhds_within]\n  simp only [mem_univ, true_and_iff]\n#align tendsto_nhds_within_nhds tendsto_nhds_within_nhds\n\n",
 "tendsto_nhds_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_nhds_nhds {a b} :\n    Tendsto f ((nhds) a) ((nhds) b) â†” âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ â¦ƒxâ¦„, edist x a < Î´ â†’ edist (f x) b < Îµ :=\n  nhds_basis_eball.tendsto_iff nhds_basis_eball\n#align tendsto_nhds_nhds tendsto_nhds_nhds\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n#print tendsto_nhds /-\ntheorem tendsto_nhds {f : Filter Î²} {u : Î² â†’ Î±} {a : Î±} :\n    Tendsto u f ((nhds) a) â†”\n      âˆ€ Îµ > 0,\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" f\n          (edist (u x) a < Îµ) :=\n  nhds_basis_eball.tendsto_right_iff\n#align tendsto_nhds tendsto_nhds\n-/\n\n",
 "tendsto_locally_uniformly_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/-- Expressing locally uniform convergence on a set using `edist`. -/\ntheorem tendsto_locally_uniformly_on_iff {Î¹ : Type _} [TopologicalSpace Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : Filter Î¹}\n    {s : Set Î²} :\n    TendstoLocallyUniformlyOn F f p s â†”\n      âˆ€ Îµ > 0,\n        âˆ€ x âˆˆ s,\n          âˆƒ t âˆˆ nhds_within s x,\n            Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" p\n              (âˆ€ y âˆˆ t, edist (f y) (F n y) < Îµ) :=\n  by\n  refine' âŸ¨fun H Îµ hÎµ => H _ (edist_mem_uniformity hÎµ), fun H u hu x hx => _âŸ©\n  rcases mem_uniformity_edist.1 hu with âŸ¨Îµ, Îµpos, hÎµâŸ©\n  rcases H Îµ Îµpos x hx with âŸ¨t, ht, HtâŸ©\n  exact âŸ¨t, ht, Ht.mono fun n hs x hx => hÎµ (hs x hx)âŸ©\n#align tendsto_locally_uniformly_on_iff tendsto_locally_uniformly_on_iff\n\n",
 "tendsto_locally_uniformly_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/-- Expressing locally uniform convergence using `edist`. -/\ntheorem tendsto_locally_uniformly_iff {Î¹ : Type _} [TopologicalSpace Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : Filter Î¹} :\n    TendstoLocallyUniformly F f p â†”\n      âˆ€ Îµ > 0,\n        âˆ€ x : Î²,\n          âˆƒ t âˆˆ (nhds) x,\n            Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" p\n              (âˆ€ y âˆˆ t, edist (f y) (F n y) < Îµ) :=\n  by\n  simp only [â† tendstoLocallyUniformlyOn_univ, tendsto_locally_uniformly_on_iff, mem_univ, forall_const, exists_prop,\n    nhdsWithin_univ]\n#align tendsto_locally_uniformly_iff tendsto_locally_uniformly_iff\n\n",
 "tendsto_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_at_top [Nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} {a : Î±} :\n    Tendsto u atTop ((nhds) a) â†” âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, edist (u n) a < Îµ :=\n  (atTop_basis.tendsto_iff nhds_basis_eball).trans <| by simp only [exists_prop, true_and_iff, mem_Ici, mem_ball]\n#align tendsto_at_top tendsto_at_top\n\n",
 "subset_countable_closure_of_compact":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set.  -/\ntheorem subset_countable_closure_of_compact {s : Set Î±} (hs : IsCompact s) :\n    âˆƒ (t : _)(_ : t âŠ† s), t.countable âˆ§ s âŠ† closure t :=\n  by\n  refine' subset_countable_closure_of_almost_dense_set s fun Îµ hÎµ => _\n  rcases totally_bounded_iff'.1 hs.totally_bounded Îµ hÎµ with âŸ¨t, hts, htf, hstâŸ©\n  exact âŸ¨t, htf.countable, subset.trans hst <| Unionâ‚‚_mono fun _ _ => ball_subset_closed_ballâŸ©\n#align subset_countable_closure_of_compact subset_countable_closure_of_compact\n\n",
 "subset_countable_closure_of_almost_dense_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\n/-- For a set `s` in a pseudo emetric space, if for every `Îµ > 0` there exists a countable\nset that is `Îµ`-dense in `s`, then there exists a countable subset `t âŠ† s` that is dense in `s`. -/\ntheorem subset_countable_closure_of_almost_dense_set (s : Set Î±)\n    (hs :\n      âˆ€ Îµ > 0,\n        âˆƒ t : Set Î±,\n          t.countable âˆ§\n            s âŠ†\n              Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n                (closedBall x Îµ)) :\n    âˆƒ (t : _)(_ : t âŠ† s), t.countable âˆ§ s âŠ† closure t :=\n  by\n  rcases s.eq_empty_or_nonempty with (rfl | âŸ¨xâ‚€, hxâ‚€âŸ©)\n  Â· exact âŸ¨âˆ…, empty_subset _, countable_empty, empty_subset _âŸ©\n  choose! T hTc hsT using fun n : â„• => hs nâ»Â¹ (by simp)\n  have : âˆ€ r x, âˆƒ y âˆˆ s, closed_ball x r âˆ© s âŠ† closed_ball y (r * 2) :=\n    by\n    intro r x\n    rcases(closed_ball x r âˆ© s).eq_empty_or_nonempty with (he | âŸ¨y, hxy, hysâŸ©)\n    Â· refine' âŸ¨xâ‚€, hxâ‚€, _âŸ©\n      rw [he]\n      exact empty_subset _\n    Â· refine' âŸ¨y, hys, fun z hz => _âŸ©\n      calc\n        edist z y â‰¤ edist z x + edist y x := edist_triangle_right _ _ _\n        _ â‰¤ r + r := (add_le_add hz.1 hxy)\n        _ = r * 2 := (mul_two r).symm\n        \n  choose f hfs hf\n  refine'\n    âŸ¨Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n        (Â«expr '' Â» (f nâ»Â¹) (T n)),\n      Union_subset fun n => image_subset_iff.2 fun z hz => hfs _ _, countable_Union fun n => (hTc n).image _, _âŸ©\n  refine' fun x hx => mem_closure_iff.2 fun Îµ Îµ0 => _\n  rcases ENNReal.exists_inv_nat_lt (ENNReal.half_pos Îµ0.lt.ne').ne' with âŸ¨n, hnâŸ©\n  rcases mem_Unionâ‚‚.1 (hsT n hx) with âŸ¨y, hyn, hyxâŸ©\n  refine' âŸ¨f nâ»Â¹ y, mem_Union.2 âŸ¨n, mem_image_of_mem _ hynâŸ©, _âŸ©\n  calc\n    edist x (f nâ»Â¹ y) â‰¤ nâ»Â¹ * 2 := hf _ _ âŸ¨hyx, hxâŸ©\n    _ < Îµ := ENNReal.mul_lt_of_lt_div hn\n    \n#align subset_countable_closure_of_almost_dense_set subset_countable_closure_of_almost_dense_set\n\n",
 "second_countable_of_sigma_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/-- A sigma compact pseudo emetric space has second countable topology. This is not an instance\nto avoid a loop with `sigma_compact_space_of_locally_compact_second_countable`.  -/\ntheorem second_countable_of_sigma_compact [SigmaCompactSpace Î±] : SecondCountableTopology Î± :=\n  by\n  suffices separable_space Î± by exact UniformSpace.secondCountable_of_separable Î±\n  choose T hTsub hTc hsubT using fun n => subset_countable_closure_of_compact (isCompact_compactCovering Î± n)\n  refine'\n    âŸ¨âŸ¨Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (T n),\n        countable_Union hTc, fun x => _âŸ©âŸ©\n  rcases Union_eq_univ_iff.1 (unionáµ¢_compactCovering Î±) x with âŸ¨n, hnâŸ©\n  exact closure_mono (subset_Union _ n) (hsubT _ hn)\n#align second_countable_of_sigma_compact second_countable_of_sigma_compact\n\n",
 "second_countable_of_almost_dense_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem second_countable_of_almost_dense_set\n    (hs :\n      âˆ€ Îµ > 0,\n        âˆƒ t : Set Î±,\n          t.countable âˆ§\n            Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n                (closedBall x Îµ) =\n              univ) :\n    SecondCountableTopology Î± :=\n  by\n  suffices separable_space Î± by exact UniformSpace.secondCountable_of_separable Î±\n  rcases subset_countable_closure_of_almost_dense_set (univ : Set Î±) fun Îµ Îµ0 => _ with âŸ¨t, -, htc, htâŸ©\n  Â· exact âŸ¨âŸ¨t, htc, fun x => ht (mem_univ x)âŸ©âŸ©\n  Â· rcases hs Îµ Îµ0 with âŸ¨t, htc, htâŸ©\n    exact âŸ¨t, htc, univ_subset_iff.2 htâŸ©\n#align second_countable_of_almost_dense_set second_countable_of_almost_dense_set\n\n",
 "pos_of_mem_ball":
 "theorem pos_of_mem_ball (hy : y âˆˆ ball x Îµ) : 0 < Îµ :=\n  lt_of_le_of_lt (zero_le _) hy\n#align pos_of_mem_ball pos_of_mem_ball\n\n",
 "ord_connected_set_of_closed_ball_subset":
 "theorem ord_connected_set_of_closed_ball_subset (x : Î±) (s : Set Î±) : OrdConnected { r | closedBall x r âŠ† s } :=\n  âŸ¨fun râ‚ hrâ‚ râ‚‚ hrâ‚‚ r hr => (closedBall_subset_closedBall hr.2).trans hrâ‚‚âŸ©\n#align ord_connected_set_of_closed_ball_subset ord_connected_set_of_closed_ball_subset\n\n",
 "ord_connected_set_of_ball_subset":
 "theorem ord_connected_set_of_ball_subset (x : Î±) (s : Set Î±) : OrdConnected { r | ball x r âŠ† s } :=\n  âŸ¨fun râ‚ hrâ‚ râ‚‚ hrâ‚‚ r hr => (ball_subset_ball hr.2).trans hrâ‚‚âŸ©\n#align ord_connected_set_of_ball_subset ord_connected_set_of_ball_subset\n\n",
 "nhds_within_basis_eball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem nhds_within_basis_eball : (nhds_within s x).has_basis (fun Îµ : ennreal => 0 < Îµ) fun Îµ => ball x Îµ âˆ© s :=\n  nhdsWithin_hasBasis nhds_basis_eball s\n#align nhds_within_basis_eball nhds_within_basis_eball\n\n",
 "nhds_within_basis_closed_eball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem nhds_within_basis_closed_eball :\n    (nhds_within s x).has_basis (fun Îµ : ennreal => 0 < Îµ) fun Îµ => closedBall x Îµ âˆ© s :=\n  nhdsWithin_hasBasis nhds_basis_closed_eball s\n#align nhds_within_basis_closed_eball nhds_within_basis_closed_eball\n\n",
 "nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_eq :\n    (nhds) x =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) (ball x Îµ)) :=\n  nhds_basis_eball.eq_binfi\n#align nhds_eq nhds_eq\n\n",
 "nhds_basis_eball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem nhds_basis_eball : ((nhds) x).has_basis (fun Îµ : ennreal => 0 < Îµ) (ball x) :=\n  nhds_basis_uniformity uniformity_basis_edist\n#align nhds_basis_eball nhds_basis_eball\n\n",
 "nhds_basis_closed_eball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem nhds_basis_closed_eball : ((nhds) x).has_basis (fun Îµ : ennreal => 0 < Îµ) (closedBall x) :=\n  nhds_basis_uniformity uniformity_basis_edist_le\n#align nhds_basis_closed_eball nhds_basis_closed_eball\n\n",
 "mk_uniformity_basis_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print EMetric.mk_uniformity_basis_le /-\n/-- Given `f : Î² â†’ â„â‰¥0âˆ`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then closed `f i`-neighborhoods of the diagonal form a basis of `ğ“¤ Î±`.\n\nFor specific bases see `uniformity_basis_edist_le` and `uniformity_basis_edist_le'`. -/\nprotected theorem EMetric.mk_uniformity_basis_le {Î² : Type _} {p : Î² â†’ Prop} {f : Î² â†’ ennreal}\n    (hfâ‚€ : âˆ€ x, p x â†’ 0 < f x) (hf : âˆ€ Îµ, 0 < Îµ â†’ âˆƒ (x : _)(hx : p x), f x â‰¤ Îµ) :\n    ((uniformity) Î±).has_basis p fun x => { p : Î± Ã— Î± | edist p.1 p.2 â‰¤ f x } :=\n  by\n  refine' âŸ¨fun s => uniformity_basis_edist.mem_iff.trans _âŸ©\n  constructor\n  Â· rintro âŸ¨Îµ, Îµâ‚€, hÎµâŸ©\n    rcases exists_between Îµâ‚€ with âŸ¨Îµ', hÎµ'âŸ©\n    rcases hf Îµ' hÎµ'.1 with âŸ¨i, hi, HâŸ©\n    exact âŸ¨i, hi, fun x hx => hÎµ <| lt_of_le_of_lt (le_trans hx H) hÎµ'.2âŸ©\n  Â· exact fun âŸ¨i, hi, HâŸ© => âŸ¨f i, hfâ‚€ i hi, fun x hx => H (le_of_lt hx)âŸ©\n#align emetric.mk_uniformity_basis_le EMetric.mk_uniformity_basis_le\n-/\n\n",
 "mk_uniformity_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print EMetric.mk_uniformity_basis /-\n/-- Given `f : Î² â†’ â„â‰¥0âˆ`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then `f i`-neighborhoods of the diagonal form a basis of `ğ“¤ Î±`.\n\nFor specific bases see `uniformity_basis_edist`, `uniformity_basis_edist'`,\n`uniformity_basis_edist_nnreal`, and `uniformity_basis_edist_inv_nat`. -/\nprotected theorem EMetric.mk_uniformity_basis {Î² : Type _} {p : Î² â†’ Prop} {f : Î² â†’ ennreal} (hfâ‚€ : âˆ€ x, p x â†’ 0 < f x)\n    (hf : âˆ€ Îµ, 0 < Îµ â†’ âˆƒ (x : _)(hx : p x), f x â‰¤ Îµ) :\n    ((uniformity) Î±).has_basis p fun x => { p : Î± Ã— Î± | edist p.1 p.2 < f x } :=\n  by\n  refine' âŸ¨fun s => uniformity_basis_edist.mem_iff.trans _âŸ©\n  constructor\n  Â· rintro âŸ¨Îµ, Îµâ‚€, hÎµâŸ©\n    rcases hf Îµ Îµâ‚€ with âŸ¨i, hi, HâŸ©\n    exact âŸ¨i, hi, fun x hx => hÎµ <| lt_of_lt_of_le hx HâŸ©\n  Â· exact fun âŸ¨i, hi, HâŸ© => âŸ¨f i, hfâ‚€ i hi, HâŸ©\n#align emetric.mk_uniformity_basis EMetric.mk_uniformity_basis\n-/\n\n",
 "mem_uniformity_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print mem_uniformity_edist /-\n/-- Characterization of the elements of the uniformity in terms of the extended distance -/\ntheorem mem_uniformity_edist {s : Set (Î± Ã— Î±)} :\n    s âˆˆ (uniformity) Î± â†” âˆƒ Îµ > 0, âˆ€ {a b : Î±}, edist a b < Îµ â†’ (a, b) âˆˆ s :=\n  uniformity_basis_edist.mem_uniformity_iff\n#align mem_uniformity_edist mem_uniformity_edist\n-/\n\n",
 "mem_nhds_within_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem mem_nhds_within_iff : s âˆˆ nhds_within t x â†” âˆƒ Îµ > 0, ball x Îµ âˆ© t âŠ† s :=\n  nhdsWithin_basis_eball.mem_iff\n#align mem_nhds_within_iff mem_nhds_within_iff\n\n",
 "mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_nhds_iff : s âˆˆ (nhds) x â†” âˆƒ Îµ > 0, ball x Îµ âŠ† s :=\n  nhds_basis_eball.mem_iff\n#align mem_nhds_iff mem_nhds_iffâ‚“\n\n",
 "mem_closure_iff":
 "#print mem_closure_iff /-\n/-- Îµ-characterization of the closure in pseudoemetric spaces -/\ntheorem mem_closure_iff : x âˆˆ closure s â†” âˆ€ Îµ > 0, âˆƒ y âˆˆ s, edist x y < Îµ :=\n  (mem_closure_iff_nhds_basis nhds_basis_eball).trans <| by simp only [mem_ball, edist_comm x]\n#align mem_closure_iff mem_closure_iff\n-/\n\n",
 "mem_closed_ball_self":
 "theorem mem_closed_ball_self : x âˆˆ closedBall x Îµ :=\n  show edist x x â‰¤ Îµ by rw [edist_self] <;> exact bot_le\n#align mem_closed_ball_self mem_closed_ball_self\n\n",
 "mem_closed_ball_comm":
 "theorem mem_closed_ball_comm : x âˆˆ closedBall y Îµ â†” y âˆˆ closedBall x Îµ := by rw [mem_closed_ball', mem_closed_ball]\n#align mem_closed_ball_comm mem_closed_ball_comm\n\n",
 "mem_closed_ball'":
 "theorem mem_closed_ball' : y âˆˆ closedBall x Îµ â†” edist x y â‰¤ Îµ := by rw [edist_comm, mem_closed_ball]\n#align mem_closed_ball' mem_closed_ball'\n\n",
 "mem_closed_ball":
 "@[simp]\ntheorem mem_closed_ball : y âˆˆ closedBall x Îµ â†” edist y x â‰¤ Îµ :=\n  iff.rfl\n#align mem_closed_ball mem_closed_ball\n\n",
 "mem_ball_self":
 "theorem mem_ball_self (h : 0 < Îµ) : x âˆˆ ball x Îµ :=\n  show edist x x < Îµ by rw [edist_self] <;> assumption\n#align mem_ball_self mem_ball_self\n\n",
 "mem_ball_comm":
 "theorem mem_ball_comm : x âˆˆ ball y Îµ â†” y âˆˆ ball x Îµ := by rw [mem_ball', mem_ball]\n#align mem_ball_comm mem_ball_comm\n\n",
 "mem_ball'":
 "theorem mem_ball' : y âˆˆ ball x Îµ â†” edist x y < Îµ := by rw [edist_comm, mem_ball]\n#align mem_ball' mem_ball'\n\n",
 "mem_ball":
 "@[simp]\ntheorem mem_ball : y âˆˆ ball x Îµ â†” edist y x < Îµ :=\n  iff.rfl\n#align mem_ball mem_ball\n\n",
 "is_open_iff":
 "theorem is_open_iff : IsOpen s â†” âˆ€ x âˆˆ s, âˆƒ Îµ > 0, ball x Îµ âŠ† s := by simp [isOpen_iff_nhds, mem_nhds_iff]\n#align is_open_iff is_open_iff\n\n",
 "is_open_ball":
 "theorem is_open_ball : IsOpen (ball x Îµ) :=\n  isOpen_iff.2 fun y => exists_ball_subset_ball\n#align is_open_ball is_open_ball\n\n",
 "is_closed_ball_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_closed_ball_top : IsClosed (ball x (Â«exprâŠ¤Â»)) :=\n  isOpen_compl_iff.1 <|\n    isOpen_iff.2 fun y hy =>\n      âŸ¨Â«exprâŠ¤Â», ENNReal.coe_lt_top,\n        (ball_disjoint <| by\n            rw [top_add]\n            exact le_of_not_lt hy).subset_compl_rightâŸ©\n#align is_closed_ball_top is_closed_ball_top\n\n",
 "inseparable_iff":
 "theorem inseparable_iff : Inseparable x y â†” edist x y = 0 := by\n  simp [inseparable_iff_mem_closure, mem_closure_iff, edist_comm, forall_lt_iff_le']\n#align inseparable_iff inseparable_iff\n\n",
 "exists_ball_subset_ball":
 "theorem exists_ball_subset_ball (h : y âˆˆ ball x Îµ) : âˆƒ Îµ' > 0, ball y Îµ' âŠ† ball x Îµ :=\n  by\n  have : 0 < Îµ - edist y x := by simpa using h\n  refine' âŸ¨Îµ - edist y x, this, ball_subset _ (ne_top_of_lt h)âŸ©\n  exact (add_tsub_cancel_of_le (mem_ball.mp h).le).le\n#align exists_ball_subset_ball exists_ball_subset_ball\n\n",
 "eq_of_forall_edist_le":
 "#print eq_of_forall_edist_le /-\n/-- Two points coincide if their distance is `< Îµ` for all positive Îµ -/\ntheorem eq_of_forall_edist_le {x y : Î³} (h : âˆ€ Îµ > 0, edist x y â‰¤ Îµ) : x = y :=\n  eq_of_edist_eq_zero (eq_of_le_of_forall_le_of_dense bot_le h)\n#align eq_of_forall_edist_le eq_of_forall_edist_le\n-/\n\n",
 "edist_up_up":
 "#print ULift.edist_up_up /-\n@[simp]\ntheorem ULift.edist_up_up (x y : Î±) : edist (ULift.up x) (ULift.up y) = edist x y :=\n  rfl\n#align ulift.edist_up_up ULift.edist_up_up\n-/\n\n",
 "edist_unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµáµ’áµ–Â» -/\n@[to_additive]\ntheorem edist_unop (x y : Â«expr áµáµ’áµ–Â» Î±) : edist (unop x) (unop y) = edist x y :=\n  rfl\n#align edist_unop edist_unop\n\n",
 "edist_triangle_right":
 "#print edist_triangle_right /-\ntheorem edist_triangle_right (x y z : Î±) : edist x y â‰¤ edist x z + edist y z := by\n  rw [edist_comm y] <;> apply edist_triangle\n#align edist_triangle_right edist_triangle_right\n-/\n\n",
 "edist_triangle_left":
 "#print edist_triangle_left /-\n-- the uniform structure is embedded in the emetric space structure\n-- to avoid instance diamond issues. See Note [forgetful inheritance].\n/- Pseudoemetric spaces are less common than metric spaces. Therefore, we work in a dedicated\nnamespace, while notions associated to metric spaces are mostly in the root namespace. -/\n/-- Triangle inequality for the extended distance -/\ntheorem edist_triangle_left (x y z : Î±) : edist x y â‰¤ edist z x + edist z y := by\n  rw [edist_comm z] <;> apply edist_triangle\n#align edist_triangle_left edist_triangle_left\n-/\n\n",
 "edist_triangle4":
 "#print edist_triangle4 /-\ntheorem edist_triangle4 (x y z t : Î±) : edist x t â‰¤ edist x y + edist y z + edist z t :=\n  calc\n    edist x t â‰¤ edist x z + edist z t := edist_triangle x z t\n    _ â‰¤ edist x y + edist y z + edist z t := add_le_add_right (edist_triangle x y z) _\n    \n#align edist_triangle4 edist_triangle4\n-/\n\n",
 "edist_toMul":
 "#print edist_toMul /-\n@[simp]\ntheorem edist_toMul (a b : Additive X) : edist (toMul a) (toMul b) = edist a b :=\n  rfl\n#align edist_to_mul edist_toMul\n-/\n\n",
 "edist_toDual":
 "#print edist_toDual /-\n@[simp]\ntheorem edist_toDual (a b : X) : edist (toDual a) (toDual b) = edist a b :=\n  rfl\n#align edist_to_dual edist_toDual\n-/\n\n",
 "edist_toAdd":
 "#print edist_toAdd /-\n@[simp]\ntheorem edist_toAdd (a b : Multiplicative X) : edist (toAdd a) (toAdd b) = edist a b :=\n  rfl\n#align edist_to_add edist_toAdd\n-/\n\n",
 "edist_pos":
 "#print edist_pos /-\n@[simp]\ntheorem edist_pos {x y : Î³} : 0 < edist x y â†” x â‰  y := by simp [â† not_le]\n#align edist_pos edist_pos\n-/\n\n",
 "edist_pi_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n#print edist_pi_le_iff /-\ntheorem edist_pi_le_iff [âˆ€ b, PseudoEMetricSpace (Ï€ b)] {f g : âˆ€ b, Ï€ b} {d : ennreal} :\n    edist f g â‰¤ d â†” âˆ€ b, edist (f b) (g b) â‰¤ d :=\n  Finset.sup_le_iff.trans <| by simp only [Finset.mem_univ, forall_const]\n#align edist_pi_le_iff edist_pi_le_iff\n-/\n\n",
 "edist_pi_def":
 "#print edist_pi_def /-\ntheorem edist_pi_def [âˆ€ b, PseudoEMetricSpace (Ï€ b)] (f g : âˆ€ b, Ï€ b) :\n    edist f g = Finset.sup univ fun b => edist (f b) (g b) :=\n  rfl\n#align edist_pi_def edist_pi_def\n-/\n\n",
 "edist_pi_const_le":
 "#print edist_pi_const_le /-\ntheorem edist_pi_const_le (a b : Î±) : (edist (fun _ : Î² => a) fun _ => b) â‰¤ edist a b :=\n  edist_pi_le_iff.2 fun _ => le_rfl\n#align edist_pi_const_le edist_pi_const_le\n-/\n\n",
 "edist_pi_const":
 "#print edist_pi_const /-\n@[simp]\ntheorem edist_pi_const [Nonempty Î²] (a b : Î±) : (edist (fun x : Î² => a) fun _ => b) = edist a b :=\n  Finset.sup_const univ_nonempty (edist a b)\n#align edist_pi_const edist_pi_const\n-/\n\n",
 "edist_op":
 "@[to_additive]\ntheorem edist_op (x y : Î±) : edist (op x) (op y) = edist x y :=\n  rfl\n#align edist_op edist_op\n\n",
 "edist_ofMul":
 "#print edist_ofMul /-\n@[simp]\ntheorem edist_ofMul (a b : X) : edist (ofMul a) (ofMul b) = edist a b :=\n  rfl\n#align edist_of_mul edist_ofMul\n-/\n\n",
 "edist_ofDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\n#print edist_ofDual /-\n@[simp]\ntheorem edist_ofDual (a b : Â«expr áµ’áµˆÂ» X) : edist (ofDual a) (ofDual b) = edist a b :=\n  rfl\n#align edist_of_dual edist_ofDual\n-/\n\n",
 "edist_ofAdd":
 "#print edist_ofAdd /-\n@[simp]\ntheorem edist_ofAdd (a b : X) : edist (ofAdd a) (ofAdd b) = edist a b :=\n  rfl\n#align edist_of_add edist_ofAdd\n-/\n\n",
 "edist_mk":
 "#print UniformSpace.SeparationQuotient.edist_mk /-\n@[simp]\ntheorem UniformSpace.SeparationQuotient.edist_mk [PseudoEMetricSpace X] (x y : X) :\n    @edist (UniformSpace.SeparationQuotient X) _ (Quot.mk _ x) (Quot.mk _ y) = edist x y :=\n  rfl\n#align uniform_space.separation_quotient.edist_mk UniformSpace.SeparationQuotient.edist_mk\n-/\n\n",
 "edist_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print edist_mem_uniformity /-\n/-- Fixed size neighborhoods of the diagonal belong to the uniform structure -/\ntheorem edist_mem_uniformity {Îµ : ennreal} (Îµ0 : 0 < Îµ) : { p : Î± Ã— Î± | edist p.1 p.2 < Îµ } âˆˆ (uniformity) Î± :=\n  mem_uniformity_edist.2 âŸ¨Îµ, Îµ0, fun a b => idâŸ©\n#align edist_mem_uniformity edist_mem_uniformity\n-/\n\n",
 "edist_le_zero":
 "#print edist_le_zero /-\ntheorem edist_le_zero {x y : Î³} : edist x y â‰¤ 0 â†” x = y :=\n  nonpos_iff_eq_zero.trans edist_eq_zero\n#align edist_le_zero edist_le_zero\n-/\n\n",
 "edist_le_range_sum_of_edist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print edist_le_range_sum_of_edist_le /-\n/-- A version of `edist_le_range_sum_edist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem edist_le_range_sum_of_edist_le {f : â„• â†’ Î±} (n : â„•) {d : â„• â†’ ennreal}\n    (hd : âˆ€ {k}, k < n â†’ edist (f k) (f (k + 1)) â‰¤ d k) :\n    edist (f 0) (f n) â‰¤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (d i) :=\n  Nat.Ico_zero_eq_range â–¸ edist_le_Ico_sum_of_edist_le (zero_le n) fun _ _ => hd\n#align edist_le_range_sum_of_edist_le edist_le_range_sum_of_edist_le\n-/\n\n",
 "edist_le_range_sum_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print edist_le_range_sum_edist /-\n/-- The triangle (polygon) inequality for sequences of points; `finset.range` version. -/\ntheorem edist_le_range_sum_edist (f : â„• â†’ Î±) (n : â„•) :\n    edist (f 0) (f n) â‰¤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (edist (f i) (f (i + 1))) :=\n  Nat.Ico_zero_eq_range â–¸ edist_le_Ico_sum_edist f (nat.zero_le n)\n#align edist_le_range_sum_edist edist_le_range_sum_edist\n-/\n\n",
 "edist_le_pi_edist":
 "#print edist_le_pi_edist /-\ntheorem edist_le_pi_edist [âˆ€ b, PseudoEMetricSpace (Ï€ b)] (f g : âˆ€ b, Ï€ b) (b : Î²) : edist (f b) (g b) â‰¤ edist f g :=\n  Finset.le_sup (Finset.mem_univ b)\n#align edist_le_pi_edist edist_le_pi_edist\n-/\n\n",
 "edist_le_of_diam_le":
 "theorem edist_le_of_diam_le {d} (hx : x âˆˆ s) (hy : y âˆˆ s) (hd : diam s â‰¤ d) : edist x y â‰¤ d :=\n  diam_le_iff.1 hd x hx y hy\n#align edist_le_of_diam_le edist_le_of_diam_le\n\n",
 "edist_le_diam_of_mem":
 "/-- If two points belong to some set, their edistance is bounded by the diameter of the set -/\ntheorem edist_le_diam_of_mem (hx : x âˆˆ s) (hy : y âˆˆ s) : edist x y â‰¤ diam s :=\n  edist_le_of_diam_le hx hy le_rfl\n#align edist_le_diam_of_mem edist_le_diam_of_mem\n\n",
 "edist_le_Ico_sum_of_edist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print edist_le_Ico_sum_of_edist_le /-\n/-- A version of `edist_le_Ico_sum_edist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem edist_le_Ico_sum_of_edist_le {f : â„• â†’ Î±} {m n} (hmn : m â‰¤ n) {d : â„• â†’ ennreal}\n    (hd : âˆ€ {k}, m â‰¤ k â†’ k < n â†’ edist (f k) (f (k + 1)) â‰¤ d k) :\n    edist (f m) (f n) â‰¤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.Ico m n)\n        (d i) :=\n  le_trans (edist_le_Ico_sum_edist f hmn) <|\n    Finset.sum_le_sum fun k hk => hd (Finset.mem_Ico.1 hk).1 (Finset.mem_Ico.1 hk).2\n#align edist_le_Ico_sum_of_edist_le edist_le_Ico_sum_of_edist_le\n-/\n\n",
 "edist_le_Ico_sum_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print edist_le_Ico_sum_edist /-\n/-- The triangle (polygon) inequality for sequences of points; `finset.Ico` version. -/\ntheorem edist_le_Ico_sum_edist (f : â„• â†’ Î±) {m n} (h : m â‰¤ n) :\n    edist (f m) (f n) â‰¤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.Ico m n)\n        (edist (f i) (f (i + 1))) :=\n  by\n  revert n\n  refine' Nat.le_induction _ _\n  Â· simp only [Finset.sum_empty, Finset.Ico_self, edist_self]\n    -- TODO: Why doesn't Lean close this goal automatically? `exact le_rfl` fails too.\n    exact le_refl (0 : ennreal)\n  Â· intro n hn hrec\n    calc\n      edist (f m) (f (n + 1)) â‰¤ edist (f m) (f n) + edist (f n) (f (n + 1)) := edist_triangle _ _ _\n      _ â‰¤\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Finset.Ico m n) _ +\n            _ :=\n        (add_le_add hrec le_rfl)\n      _ =\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Finset.Ico m (n + 1)) _ :=\n        by rw [Nat.Ico_succ_right_eq_insert_Ico hn, Finset.sum_insert, add_comm] <;> simp\n      \n#align edist_le_Ico_sum_edist edist_le_Ico_sum_edist\n-/\n\n",
 "edist_eq_zero":
 "#print edist_eq_zero /-\n--namespace\n/-- Characterize the equality of points by the vanishing of their extended distance -/\n@[simp]\ntheorem edist_eq_zero {x y : Î³} : edist x y = 0 â†” x = y :=\n  iff.intro eq_of_edist_eq_zero fun this : x = y => this â–¸ edist_self _\n#align edist_eq_zero edist_eq_zero\n-/\n\n",
 "edist_eq":
 "#print Prod.edist_eq /-\ntheorem Prod.edist_eq [PseudoEMetricSpace Î²] (x y : Î± Ã— Î²) : edist x y = max (edist x.1 y.1) (edist x.2 y.2) :=\n  rfl\n#align prod.edist_eq Prod.edist_eq\n-/\n\n",
 "edist_congr_right":
 "#print edist_congr_right /-\ntheorem edist_congr_right {x y z : Î±} (h : edist x y = 0) : edist x z = edist y z :=\n  by\n  apply le_antisymm\n  Â· rw [â† zero_add (edist y z), â† h]\n    apply edist_triangle\n  Â· rw [edist_comm] at h\n    rw [â† zero_add (edist x z), â† h]\n    apply edist_triangle\n#align edist_congr_right edist_congr_right\n-/\n\n",
 "edist_congr_left":
 "#print edist_congr_left /-\ntheorem edist_congr_left {x y z : Î±} (h : edist x y = 0) : edist z x = edist z y :=\n  by\n  rw [edist_comm z x, edist_comm z y]\n  apply edist_congr_right h\n#align edist_congr_left edist_congr_left\n-/\n\n",
 "diam_union'":
 "theorem diam_union' {t : Set Î±} (h : (s âˆ© t).nonempty) : diam (s âˆª t) â‰¤ diam s + diam t :=\n  by\n  let âŸ¨x, âŸ¨xs, xtâŸ©âŸ© := h\n  simpa using diam_union xs xt\n#align diam_union' diam_union'\n\n",
 "diam_union":
 "/-- The diameter of a union is controlled by the diameter of the sets, and the edistance\nbetween two points in the sets. -/\ntheorem diam_union {t : Set Î±} (xs : x âˆˆ s) (yt : y âˆˆ t) : diam (s âˆª t) â‰¤ diam s + edist x y + diam t :=\n  by\n  have A : âˆ€ a âˆˆ s, âˆ€ b âˆˆ t, edist a b â‰¤ diam s + edist x y + diam t := fun a ha b hb =>\n    calc\n      edist a b â‰¤ edist a x + edist x y + edist y b := edist_triangle4 _ _ _ _\n      _ â‰¤ diam s + edist x y + diam t :=\n        add_le_add (add_le_add (edist_le_diam_of_mem ha xs) le_rfl) (edist_le_diam_of_mem yt hb)\n      \n  refine' diam_le fun a ha b hb => _\n  cases' (mem_union _ _ _).1 ha with h'a h'a <;> cases' (mem_union _ _ _).1 hb with h'b h'b\n  Â·\n    calc\n      edist a b â‰¤ diam s := edist_le_diam_of_mem h'a h'b\n      _ â‰¤ diam s + (edist x y + diam t) := le_self_add\n      _ = diam s + edist x y + diam t := (add_assoc _ _ _).symm\n      \n  Â· exact A a h'a b h'b\n  Â· have Z := A b h'b a h'a\n    rwa [edist_comm] at Z\n  Â·\n    calc\n      edist a b â‰¤ diam t := edist_le_diam_of_mem h'a h'b\n      _ â‰¤ diam s + edist x y + diam t := le_add_self\n      \n#align diam_union diam_union\n\n",
 "diam_triple":
 "theorem diam_triple : diam ({x, y, z} : Set Î±) = max (max (edist x y) (edist x z)) (edist y z) := by\n  simp only [diam_insert, supáµ¢_insert, supáµ¢_singleton, diam_singleton, ENNReal.max_zero_right, ENNReal.sup_eq_max]\n#align diam_triple diam_triple\n\n",
 "diam_subsingleton":
 "/-- The diameter of a subsingleton vanishes. -/\ntheorem diam_subsingleton (hs : s.subsingleton) : diam s = 0 :=\n  nonpos_iff_eq_zero.1 <| diam_le fun x hx y hy => (hs hx hy).symm â–¸ edist_self y â–¸ le_rfl\n#align diam_subsingleton diam_subsingleton\n\n",
 "diam_singleton":
 "/-- The diameter of a singleton vanishes -/\n@[simp]\ntheorem diam_singleton : diam ({x} : Set Î±) = 0 :=\n  diam_subsingleton subsingleton_singleton\n#align diam_singleton diam_singleton\n\n",
 "diam_pos_iff":
 "theorem diam_pos_iff : 0 < diam s â†” âˆƒ x âˆˆ s, âˆƒ y âˆˆ s, x â‰  y := by\n  simp only [pos_iff_ne_zero, ne.def, diam_eq_zero_iff, Set.Subsingleton, not_forall]\n#align diam_pos_iff diam_pos_iff\n\n",
 "diam_pi_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem diam_pi_le_of_le {Ï€ : Î² â†’ Type _} [Fintype Î²] [âˆ€ b, PseudoEMetricSpace (Ï€ b)] {s : âˆ€ b : Î², Set (Ï€ b)}\n    {c : ennreal} (h : âˆ€ b, diam (s b) â‰¤ c) : diam (Set.pi univ s) â‰¤ c :=\n  by\n  apply diam_le fun x hx y hy => edist_pi_le_iff.mpr _\n  rw [mem_univ_pi] at hx hy\n  exact fun b => diam_le_iff.1 (h b) (x b) (hx b) (y b) (hy b)\n#align diam_pi_le_of_le diam_pi_le_of_le\n\n",
 "diam_pair":
 "theorem diam_pair : diam ({x, y} : Set Î±) = edist x y := by\n  simp only [supáµ¢_singleton, diam_insert, diam_singleton, ENNReal.max_zero_right]\n#align diam_pair diam_pair\n\n",
 "diam_mono":
 "/-- The diameter is monotonous with respect to inclusion -/\ntheorem diam_mono {s t : Set Î±} (h : s âŠ† t) : diam s â‰¤ diam t :=\n  diam_le fun x hx y hy => edist_le_diam_of_mem (h hx) (h hy)\n#align diam_mono diam_mono\n\n",
 "diam_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem diam_le_iff {d : ennreal} : diam s â‰¤ d â†” âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, edist x y â‰¤ d := by simp only [diam, supáµ¢_le_iff]\n#align diam_le_iff diam_le_iff\n\n",
 "diam_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If the distance between any two points in a set is bounded by some constant, this constant\nbounds the diameter. -/\ntheorem diam_le {d : ennreal} (h : âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, edist x y â‰¤ d) : diam s â‰¤ d :=\n  diam_le_iff.2 h\n#align diam_le diam_le\n\n",
 "diam_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\ntheorem diam_insert :\n    diam (insert x s) =\n      max (Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" (edist x y))\n        (diam s) :=\n  eq_of_forall_ge_iff fun d => by\n    simp only [diam_le_iff, ball_insert_iff, edist_self, edist_comm x, max_le_iff, supáµ¢_le_iff, zero_le, true_and_iff,\n      forall_and, and_self_iff, â† and_assoc']\n#align diam_insert diam_insert\n\n",
 "diam_image_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem diam_image_le_iff {d : ennreal} {f : Î² â†’ Î±} {s : Set Î²} :\n    diam (Â«expr '' Â» f s) â‰¤ d â†” âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, edist (f x) (f y) â‰¤ d := by simp only [diam_le_iff, ball_image_iff]\n#align diam_image_le_iff diam_image_le_iff\n\n",
 "diam_eq_zero_iff":
 "theorem diam_eq_zero_iff : diam s = 0 â†” s.subsingleton :=\n  âŸ¨fun h x hx y hy => edist_le_zero.1 <| h â–¸ edist_le_diam_of_mem hx hy, diam_subsingletonâŸ©\n#align diam_eq_zero_iff diam_eq_zero_iff\n\n",
 "diam_empty":
 "/-- The diameter of the empty set vanishes -/\n@[simp]\ntheorem diam_empty : diam (âˆ… : Set Î±) = 0 :=\n  diam_subsingleton subsingleton_empty\n#align diam_empty diam_empty\n\n",
 "diam_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem diam_closed_ball {r : ennreal} : diam (closedBall x r) â‰¤ 2 * r :=\n  diam_le fun a ha b hb =>\n    calc\n      edist a b â‰¤ edist a x + edist b x := edist_triangle_right _ _ _\n      _ â‰¤ r + r := (add_le_add ha hb)\n      _ = 2 * r := (two_mul r).symm\n      \n#align diam_closed_ball diam_closed_ball\n\n",
 "diam_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem diam_ball {r : ennreal} : diam (ball x r) â‰¤ 2 * r :=\n  le_trans (diam_mono ball_subset_closedBall) diam_closedBall\n#align diam_ball diam_ball\n\n",
 "diam_Union_mem_option":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\ntheorem diam_Union_mem_option {Î¹ : Type _} (o : Option Î¹) (s : Î¹ â†’ Set Î±) :\n    diam (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (s i)) =\n      Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" (diam (s i)) :=\n  by cases o <;> simp\n#align diam_Union_mem_option diam_Union_mem_option\n\n",
 "countable_closure_of_compact":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem countable_closure_of_compact {s : Set Î³} (hs : IsCompact s) :\n    âˆƒ (t : _)(_ : t âŠ† s), t.countable âˆ§ s = closure t :=\n  by\n  rcases subset_countable_closure_of_compact hs with âŸ¨t, hts, htc, hsubâŸ©\n  exact âŸ¨t, hts, htc, subset.antisymm hsub (closure_minimal hts hs.is_closed)âŸ©\n#align countable_closure_of_compact countable_closure_of_compact\n\n",
 "controlled_of_uniform_embedding":
 "/-- If a map between pseudoemetric spaces is a uniform embedding then the edistance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y`. -/\ntheorem controlled_of_uniform_embedding [PseudoEMetricSpace Î²] {f : Î± â†’ Î²} :\n    UniformEmbedding f â†’\n      (âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ {a b : Î±}, edist a b < Î´ â†’ edist (f a) (f b) < Îµ) âˆ§\n        âˆ€ Î´ > 0, âˆƒ Îµ > 0, âˆ€ {a b : Î±}, edist (f a) (f b) < Îµ â†’ edist a b < Î´ :=\n  fun h => âŸ¨uniformContinuous_iff.1 (uniformEmbedding_iff.1 h).2.1, (uniformEmbedding_iff.1 h).2.2âŸ©\n#align controlled_of_uniform_embedding controlled_of_uniform_embedding\n\n",
 "complete_of_convergent_controlled_sequences":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A very useful criterion to show that a space is complete is to show that all sequences\nwhich satisfy a bound of the form `edist (u n) (u m) < B N` for all `n m â‰¥ N` are\nconverging. This is often applied for `B N = 2^{-N}`, i.e., with a very fast convergence to\n`0`, which makes it possible to use arguments of converging series, while this is impossible\nto do in general for arbitrary Cauchy sequences. -/\ntheorem complete_of_convergent_controlled_sequences (B : â„• â†’ ennreal) (hB : âˆ€ n, 0 < B n)\n    (H : âˆ€ u : â„• â†’ Î±, (âˆ€ N n m : â„•, N â‰¤ n â†’ N â‰¤ m â†’ edist (u n) (u m) < B N) â†’ âˆƒ x, Tendsto u atTop ((nhds) x)) :\n    CompleteSpace Î± :=\n  UniformSpace.complete_of_convergent_controlled_sequences (fun n => { p : Î± Ã— Î± | edist p.1 p.2 < B n })\n    (fun n => edist_mem_uniformity <| hB n) H\n#align complete_of_convergent_controlled_sequences complete_of_convergent_controlled_sequences\n\n",
 "complete_of_cauchy_seq_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A sequentially complete pseudoemetric space is complete. -/\ntheorem complete_of_cauchy_seq_tendsto :\n    (âˆ€ u : â„• â†’ Î±, CauchySeq u â†’ âˆƒ a, Tendsto u atTop ((nhds) a)) â†’ CompleteSpace Î± :=\n  UniformSpace.complete_of_cauchySeq_tendsto\n#align complete_of_cauchy_seq_tendsto complete_of_cauchy_seq_tendsto\n\n",
 "closed_ball_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem closed_ball_top (x : Î±) : closedBall x (ennreal.top) = univ :=\n  eq_univ_of_forall fun y => le_top\n#align closed_ball_top closed_ball_top\n\n",
 "closed_ball_subset_closed_ball":
 "theorem closed_ball_subset_closed_ball (h : Îµâ‚ â‰¤ Îµâ‚‚) : closedBall x Îµâ‚ âŠ† closedBall x Îµâ‚‚ := fun y (yx : _ â‰¤ Îµâ‚) =>\n  le_trans yx h\n#align closed_ball_subset_closed_ball closed_ball_subset_closed_ball\n\n",
 "closed_ball_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem closed_ball_mem_nhds (x : Î±) {Îµ : ennreal} (Îµ0 : 0 < Îµ) : closedBall x Îµ âˆˆ (nhds) x :=\n  mem_of_superset (ball_mem_nhds x Îµ0) ball_subset_closedBall\n#align closed_ball_mem_nhds closed_ball_mem_nhds\n\n",
 "closedBall_prod_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print closedBall_prod_same /-\ntheorem closedBall_prod_same [PseudoEMetricSpace Î²] (x : Î±) (y : Î²) (r : ennreal) :\n    lower_set.prod (closedBall x r) (closedBall y r) = closedBall (x, y) r :=\n  ext fun z => max_le_iff.symm\n#align closed_ball_prod_same closedBall_prod_same\n-/\n\n",
 "cauchy_seq_iff_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-- A variation of the emetric characterization of Cauchy sequences that deals with\n`â„â‰¥0` upper bounds. -/\ntheorem cauchy_seq_iff_nnreal [Nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} :\n    CauchySeq u â†” âˆ€ Îµ : nnreal, 0 < Îµ â†’ âˆƒ N, âˆ€ n, N â‰¤ n â†’ edist (u n) (u N) < Îµ :=\n  uniformity_basis_edist_nnreal.cauchy_seq_iff'\n#align cauchy_seq_iff_nnreal cauchy_seq_iff_nnreal\n\n",
 "cauchy_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y Â«expr âˆˆ Â» t) -/\n#print cauchy_iff /-\n/-- Îµ-Î´ characterization of Cauchy sequences on pseudoemetric spaces -/\nprotected theorem cauchy_iff {f : Filter Î±} :\n    Cauchy f â†” f â‰  Â«exprâŠ¥Â» âˆ§ âˆ€ Îµ > 0, âˆƒ t âˆˆ f, âˆ€ (x) (_ : x âˆˆ t) (y) (_ : y âˆˆ t), edist x y < Îµ := by\n  rw [â† ne_bot_iff] <;> exact uniformity_basis_edist.cauchy_iff\n#align cauchy_iff cauchy_iff\n-/\n\n",
 "cauchySeq_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n#print cauchySeq_iff' /-\n/-- A variation around the emetric characterization of Cauchy sequences -/\ntheorem cauchySeq_iff' [Nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} :\n    CauchySeq u â†” âˆ€ Îµ > (0 : ennreal), âˆƒ N, âˆ€ n â‰¥ N, edist (u n) (u N) < Îµ :=\n  uniformity_basis_edist.cauchy_seq_iff'\n#align cauchy_seq_iff' cauchySeq_iff'\n-/\n\n",
 "cauchySeq_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (m n Â«expr â‰¥ Â» N) -/\n#print cauchySeq_iff /-\n-- see Note [nolint_ge]\n/-- In a pseudoemetric space, Cauchy sequences are characterized by the fact that, eventually,\nthe pseudoedistance between its elements is arbitrarily small -/\n@[nolint ge_or_gt]\ntheorem cauchySeq_iff [Nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} :\n    CauchySeq u â†” âˆ€ Îµ > 0, âˆƒ N, âˆ€ (m) (_ : m â‰¥ N) (n) (_ : n â‰¥ N), edist (u m) (u n) < Îµ :=\n  uniformity_basis_edist.cauchy_seq_iff\n#align cauchy_seq_iff cauchySeq_iff\n-/\n\n",
 "ball_zero":
 "@[simp]\ntheorem ball_zero : ball x 0 = âˆ… := by rw [EMetric.ball_eq_empty_iff]\n#align ball_zero ball_zero\n\n",
 "ball_subset_closed_ball":
 "theorem ball_subset_closed_ball : ball x Îµ âŠ† closedBall x Îµ := fun y hy => le_of_lt hy\n#align ball_subset_closed_ball ball_subset_closed_ball\n\n",
 "ball_subset_ball":
 "theorem ball_subset_ball (h : Îµâ‚ â‰¤ Îµâ‚‚) : ball x Îµâ‚ âŠ† ball x Îµâ‚‚ := fun y (yx : _ < Îµâ‚) => lt_of_lt_of_le yx h\n#align ball_subset_ball ball_subset_ball\n\n",
 "ball_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem ball_subset (h : edist x y + Îµâ‚ â‰¤ Îµâ‚‚) (h' : edist x y â‰  ennreal.top) : ball x Îµâ‚ âŠ† ball y Îµâ‚‚ := fun z zx =>\n  calc\n    edist z y â‰¤ edist z x + edist x y := edist_triangle _ _ _\n    _ = edist x y + edist z x := (add_comm _ _)\n    _ < edist x y + Îµâ‚ := (ENNReal.add_lt_add_left h' zx)\n    _ â‰¤ Îµâ‚‚ := h\n    \n#align ball_subset ball_subset\n\n",
 "ball_prod_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print ball_prod_same /-\ntheorem ball_prod_same [PseudoEMetricSpace Î²] (x : Î±) (y : Î²) (r : ennreal) :\n    lower_set.prod (ball x r) (ball y r) = ball (x, y) r :=\n  ext fun z => max_lt_iff.symm\n#align ball_prod_same ball_prod_same\n-/\n\n",
 "ball_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ball_mem_nhds (x : Î±) {Îµ : ennreal} (Îµ0 : 0 < Îµ) : ball x Îµ âˆˆ (nhds) x :=\n  isOpen_ball.mem_nhds (mem_ball_self Îµ0)\n#align ball_mem_nhds ball_mem_nhds\n\n",
 "ball_eq_empty_iff":
 "theorem ball_eq_empty_iff : ball x Îµ = âˆ… â†” Îµ = 0 :=\n  eq_empty_iff_forall_not_mem.trans\n    âŸ¨fun h => le_bot_iff.1 (le_of_not_gt fun Îµ0 => h _ (mem_ball_self Îµ0)), fun Îµ0 y h =>\n      not_lt_of_le (le_of_eq Îµ0) (pos_of_mem_ball h)âŸ©\n#align ball_eq_empty_iff ball_eq_empty_iff\n\n",
 "ball_disjoint":
 "theorem ball_disjoint (h : Îµâ‚ + Îµâ‚‚ â‰¤ edist x y) : Disjoint (ball x Îµâ‚) (ball y Îµâ‚‚) :=\n  Set.disjoint_left.mpr fun z hâ‚ hâ‚‚ => (edist_triangle_left x y z).not_lt <| (ENNReal.add_lt_add hâ‚ hâ‚‚).trans_le h\n#align ball_disjoint ball_disjoint\n\n"}