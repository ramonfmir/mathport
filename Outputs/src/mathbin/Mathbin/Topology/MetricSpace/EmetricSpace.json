{"zero_eq_edist":
 "#print zero_eq_edist /-\n@[simp]\ntheorem zero_eq_edist {x y : γ} : 0 = edist x y ↔ x = y :=\n  iff.intro (fun h => eq_of_edist_eq_zero h.symm) fun this : x = y => this ▸ (edist_self _).symm\n#align zero_eq_edist zero_eq_edist\n-/\n\n",
 "uniformity_pseudoedist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print uniformity_pseudoedist /-\n/-- Reformulation of the uniform structure in terms of the extended distance -/\ntheorem uniformity_pseudoedist :\n    (uniformity) α =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) { p : α × α | edist p.1 p.2 < ε }) :=\n  pseudo_emetric_space.uniformity_edist\n#align uniformity_pseudoedist uniformity_pseudoedist\n-/\n\n",
 "uniformity_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print uniformity_edist /-\n/-- Reformulation of the uniform structure in terms of the extended distance -/\ntheorem uniformity_edist :\n    (uniformity) γ =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) { p : γ × γ | edist p.1 p.2 < ε }) :=\n  pseudo_emetric_space.uniformity_edist\n#align uniformity_edist uniformity_edist\n-/\n\n",
 "uniformity_dist_of_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print uniformity_dist_of_mem_uniformity /-\n/-\nCopyright (c) 2015, 2017 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Robert Y. Lewis, Johannes Hölzl, Mario Carneiro, Sébastien Gouëzel\n-/\n/-- Characterizing uniformities associated to a (generalized) distance function `D`\nin terms of the elements of the uniformity. -/\ntheorem uniformity_dist_of_mem_uniformity [linear_order β] {U : Filter (α × α)} (z : β) (D : α → α → β)\n    (H : ∀ s, s ∈ U ↔ ∃ ε > z, ∀ {a b : α}, D a b < ε → (a, b) ∈ s) :\n    U =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) { p : α × α | D p.1 p.2 < ε }) :=\n  HasBasis.eq_binfᵢ ⟨fun s => by simp only [H, subset_def, Prod.forall, mem_set_of]⟩\n#align uniformity_dist_of_mem_uniformity uniformity_dist_of_mem_uniformity\n-/\n\n",
 "uniformity_basis_edist_nnreal_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print uniformity_basis_edist_nnreal_le /-\ntheorem uniformity_basis_edist_nnreal_le :\n    ((uniformity) α).has_basis (fun ε : nnreal => 0 < ε) fun ε => { p : α × α | edist p.1 p.2 ≤ ε } :=\n  EMetric.mk_uniformity_basis_le (fun _ => ENNReal.coe_pos.2) fun ε ε₀ =>\n    let ⟨δ, hδ⟩ := ENNReal.lt_iff_exists_nnreal_btwn.1 ε₀\n    ⟨δ, ENNReal.coe_pos.1 hδ.1, le_of_lt hδ.2⟩\n#align uniformity_basis_edist_nnreal_le uniformity_basis_edist_nnreal_le\n-/\n\n",
 "uniformity_basis_edist_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print uniformity_basis_edist_nnreal /-\ntheorem uniformity_basis_edist_nnreal :\n    ((uniformity) α).has_basis (fun ε : nnreal => 0 < ε) fun ε => { p : α × α | edist p.1 p.2 < ε } :=\n  EMetric.mk_uniformity_basis (fun _ => ENNReal.coe_pos.2) fun ε ε₀ =>\n    let ⟨δ, hδ⟩ := ENNReal.lt_iff_exists_nnreal_btwn.1 ε₀\n    ⟨δ, ENNReal.coe_pos.1 hδ.1, le_of_lt hδ.2⟩\n#align uniformity_basis_edist_nnreal uniformity_basis_edist_nnreal\n-/\n\n",
 "uniformity_basis_edist_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n#print uniformity_basis_edist_le' /-\ntheorem uniformity_basis_edist_le' (ε' : ennreal) (hε' : 0 < ε') :\n    ((uniformity) α).has_basis (fun ε : ennreal => ε ∈ Ioo 0 ε') fun ε => { p : α × α | edist p.1 p.2 ≤ ε } :=\n  EMetric.mk_uniformity_basis_le (fun _ => And.left) fun ε ε₀ =>\n    let ⟨δ, hδ⟩ := exists_between hε'\n    ⟨min ε δ, ⟨lt_min ε₀ hδ.1, lt_of_le_of_lt (min_le_right _ _) hδ.2⟩, min_le_left _ _⟩\n#align uniformity_basis_edist_le' uniformity_basis_edist_le'\n-/\n\n",
 "uniformity_basis_edist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n#print uniformity_basis_edist_le /-\ntheorem uniformity_basis_edist_le :\n    ((uniformity) α).has_basis (fun ε : ennreal => 0 < ε) fun ε => { p : α × α | edist p.1 p.2 ≤ ε } :=\n  EMetric.mk_uniformity_basis_le (fun _ => id) fun ε ε₀ => ⟨ε, ε₀, le_refl ε⟩\n#align uniformity_basis_edist_le uniformity_basis_edist_le\n-/\n\n",
 "uniformity_basis_edist_inv_two_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_basis_edist_inv_two_pow /-\ntheorem uniformity_basis_edist_inv_two_pow :\n    ((uniformity) α).has_basis (fun _ => True) fun n : ℕ => { p : α × α | edist p.1 p.2 < 2⁻¹ ^ n } :=\n  EMetric.mk_uniformity_basis (fun n _ => ENNReal.pow_pos (ENNReal.inv_pos.2 ENNReal.two_ne_top) _) fun ε ε₀ =>\n    let ⟨n, hn⟩ := ENNReal.exists_inv_two_pow_lt (ne_of_gt ε₀)\n    ⟨n, trivial, le_of_lt hn⟩\n#align uniformity_basis_edist_inv_two_pow uniformity_basis_edist_inv_two_pow\n-/\n\n",
 "uniformity_basis_edist_inv_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_basis_edist_inv_nat /-\ntheorem uniformity_basis_edist_inv_nat :\n    ((uniformity) α).has_basis (fun _ => True) fun n : ℕ => { p : α × α | edist p.1 p.2 < (↑n)⁻¹ } :=\n  EMetric.mk_uniformity_basis (fun n _ => ENNReal.inv_pos.2 <| ENNReal.nat_ne_top n) fun ε ε₀ =>\n    let ⟨n, hn⟩ := ENNReal.exists_inv_nat_lt (ne_of_gt ε₀)\n    ⟨n, trivial, le_of_lt hn⟩\n#align uniformity_basis_edist_inv_nat uniformity_basis_edist_inv_nat\n-/\n\n",
 "uniformity_basis_edist'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n#print uniformity_basis_edist' /-\ntheorem uniformity_basis_edist' (ε' : ennreal) (hε' : 0 < ε') :\n    ((uniformity) α).has_basis (fun ε : ennreal => ε ∈ Ioo 0 ε') fun ε => { p : α × α | edist p.1 p.2 < ε } :=\n  EMetric.mk_uniformity_basis (fun _ => And.left) fun ε ε₀ =>\n    let ⟨δ, hδ⟩ := exists_between hε'\n    ⟨min ε δ, ⟨lt_min ε₀ hδ.1, lt_of_le_of_lt (min_le_right _ _) hδ.2⟩, min_le_left _ _⟩\n#align uniformity_basis_edist' uniformity_basis_edist'\n-/\n\n",
 "uniformity_basis_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n#print uniformity_basis_edist /-\ntheorem uniformity_basis_edist :\n    ((uniformity) α).has_basis (fun ε : ennreal => 0 < ε) fun ε => { p : α × α | edist p.1 p.2 < ε } :=\n  (@uniformSpace_edist α _).symm ▸ UniformSpace.hasBasis_ofFun ⟨1, one_pos⟩ _ _ _ _ _\n#align uniformity_basis_edist uniformity_basis_edist\n-/\n\n",
 "uniform_continuous_on_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection {a b «expr ∈ » s} -/\n/-- ε-δ characterization of uniform continuity on a set for pseudoemetric spaces -/\ntheorem uniform_continuous_on_iff [PseudoEMetricSpace β] {f : α → β} {s : Set α} :\n    UniformContinuousOn f s ↔\n      ∀ ε > 0, ∃ δ > 0, ∀ {a} {_ : a ∈ s} {b} {_ : b ∈ s}, edist a b < δ → edist (f a) (f b) < ε :=\n  uniformity_basis_edist.uniform_continuous_on_iff uniformity_basis_edist\n#align uniform_continuous_on_iff uniform_continuous_on_iff\n\n",
 "uniformSpace_edist":
 "#print uniformSpace_edist /-\ntheorem uniformSpace_edist :\n    ‹PseudoEMetricSpace α›.to_uniform_space = uniformSpaceOfEDist edist edist_self edist_comm edist_triangle :=\n  uniformSpace_eq uniformity_pseudoedist\n#align uniform_space_edist uniformSpace_edist\n-/\n\n",
 "uniformEmbedding_iff'":
 "#print EMetric.uniformEmbedding_iff' /-\n-- see Note [lower instance priority]\n/-- A map between emetric spaces is a uniform embedding if and only if the edistance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y` and conversely. -/\ntheorem EMetric.uniformEmbedding_iff' [EMetricSpace β] {f : γ → β} :\n    UniformEmbedding f ↔\n      (∀ ε > 0, ∃ δ > 0, ∀ {a b : γ}, edist a b < δ → edist (f a) (f b) < ε) ∧\n        ∀ δ > 0, ∃ ε > 0, ∀ {a b : γ}, edist (f a) (f b) < ε → edist a b < δ :=\n  by\n  simp only [uniformEmbedding_iff_uniformInducing, uniformity_basis_edist.uniform_inducing_iff uniformity_basis_edist,\n    exists_prop]\n  rfl\n#align emetric.uniform_embedding_iff' EMetric.uniformEmbedding_iff'\n-/\n\n",
 "uniformEmbedding_iff":
 "#print uniformEmbedding_iff /-\n/-- ε-δ characterization of uniform embeddings on pseudoemetric spaces -/\ntheorem uniformEmbedding_iff [PseudoEMetricSpace β] {f : α → β} :\n    UniformEmbedding f ↔\n      function.injective f ∧\n        UniformContinuous f ∧ ∀ δ > 0, ∃ ε > 0, ∀ {a b : α}, edist (f a) (f b) < ε → edist a b < δ :=\n  by\n  simp only [uniformity_basis_edist.uniform_embedding_iff uniformity_basis_edist, exists_prop]\n  rfl\n#align uniform_embedding_iff uniformEmbedding_iff\n-/\n\n",
 "uniformContinuous_iff":
 "#print uniformContinuous_iff /-\n/-- ε-δ characterization of uniform continuity on pseudoemetric spaces -/\ntheorem uniformContinuous_iff [PseudoEMetricSpace β] {f : α → β} :\n    UniformContinuous f ↔ ∀ ε > 0, ∃ δ > 0, ∀ {a b : α}, edist a b < δ → edist (f a) (f b) < ε :=\n  uniformity_basis_edist.uniform_continuous_iff uniformity_basis_edist\n#align uniform_continuous_iff uniformContinuous_iff\n-/\n\n",
 "totally_bounded_iff'":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem totally_bounded_iff' {s : Set α} :\n    TotallyBounded s ↔\n      ∀ ε > 0,\n        ∃ (t : _)(_ : t ⊆ s),\n          Set.Finite t ∧\n            s ⊆\n              «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                (ball y ε) :=\n  ⟨fun H ε ε0 => (totallyBounded_iff_subset.1 H) _ (edist_mem_uniformity ε0), fun H r ru =>\n    let ⟨ε, ε0, hε⟩ := mem_uniformity_edist.1 ru\n    let ⟨t, _, ft, h⟩ := H ε ε0\n    ⟨t, ft, h.trans <| unionᵢ₂_mono fun y yt z => hε⟩⟩\n#align totally_bounded_iff' totally_bounded_iff'\n\n",
 "totally_bounded_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem totally_bounded_iff {s : Set α} :\n    TotallyBounded s ↔\n      ∀ ε > 0,\n        ∃ t : Set α,\n          t.finite ∧\n            s ⊆\n              «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                (ball y ε) :=\n  ⟨fun H ε ε0 => H _ (edist_mem_uniformity ε0), fun H r ru =>\n    let ⟨ε, ε0, hε⟩ := mem_uniformity_edist.1 ru\n    let ⟨t, ft, h⟩ := H ε ε0\n    ⟨t, ft, h.trans <| unionᵢ₂_mono fun y yt z => hε⟩⟩\n#align totally_bounded_iff totally_bounded_iff\n\n",
 "tendsto_uniformly_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- Expressing uniform convergence on a set using `edist`. -/\ntheorem tendsto_uniformly_on_iff {ι : Type _} {F : ι → β → α} {f : β → α} {p : Filter ι} {s : Set β} :\n    TendstoUniformlyOn F f p s ↔\n      ∀ ε > 0,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n          (∀ x ∈ s, edist (f x) (F n x) < ε) :=\n  by\n  refine' ⟨fun H ε hε => H _ (edist_mem_uniformity hε), fun H u hu => _⟩\n  rcases mem_uniformity_edist.1 hu with ⟨ε, εpos, hε⟩\n  exact (H ε εpos).mono fun n hs x hx => hε (hs x hx)\n#align tendsto_uniformly_on_iff tendsto_uniformly_on_iff\n\n",
 "tendsto_uniformly_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- Expressing uniform convergence using `edist`. -/\ntheorem tendsto_uniformly_iff {ι : Type _} {F : ι → β → α} {f : β → α} {p : Filter ι} :\n    TendstoUniformly F f p ↔\n      ∀ ε > 0,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n          (∀ x, edist (f x) (F n x) < ε) :=\n  by simp only [← tendstoUniformlyOn_univ, tendsto_uniformly_on_iff, mem_univ, forall_const]\n#align tendsto_uniformly_iff tendsto_uniformly_iff\n\n",
 "tendsto_nhds_within_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem tendsto_nhds_within_nhds_within {t : Set β} {a b} :\n    Tendsto f (nhds_within s a) (nhds_within t b) ↔\n      ∀ ε > 0, ∃ δ > 0, ∀ ⦃x⦄, x ∈ s → edist x a < δ → f x ∈ t ∧ edist (f x) b < ε :=\n  (nhdsWithin_basis_eball.tendsto_iff nhdsWithin_basis_eball).trans <|\n    forall₂_congr fun ε hε => exists₂_congr fun δ hδ => forall_congr' fun x => by simp <;> itauto\n#align tendsto_nhds_within_nhds_within tendsto_nhds_within_nhds_within\n\n",
 "tendsto_nhds_within_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_nhds_within_nhds {a b} :\n    Tendsto f (nhds_within s a) ((nhds) b) ↔ ∀ ε > 0, ∃ δ > 0, ∀ {x : α}, x ∈ s → edist x a < δ → edist (f x) b < ε :=\n  by\n  rw [← nhdsWithin_univ b, tendsto_nhds_within_nhds_within]\n  simp only [mem_univ, true_and_iff]\n#align tendsto_nhds_within_nhds tendsto_nhds_within_nhds\n\n",
 "tendsto_nhds_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_nhds_nhds {a b} :\n    Tendsto f ((nhds) a) ((nhds) b) ↔ ∀ ε > 0, ∃ δ > 0, ∀ ⦃x⦄, edist x a < δ → edist (f x) b < ε :=\n  nhds_basis_eball.tendsto_iff nhds_basis_eball\n#align tendsto_nhds_nhds tendsto_nhds_nhds\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n#print tendsto_nhds /-\ntheorem tendsto_nhds {f : Filter β} {u : β → α} {a : α} :\n    Tendsto u f ((nhds) a) ↔\n      ∀ ε > 0,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" f\n          (edist (u x) a < ε) :=\n  nhds_basis_eball.tendsto_right_iff\n#align tendsto_nhds tendsto_nhds\n-/\n\n",
 "tendsto_locally_uniformly_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- Expressing locally uniform convergence on a set using `edist`. -/\ntheorem tendsto_locally_uniformly_on_iff {ι : Type _} [TopologicalSpace β] {F : ι → β → α} {f : β → α} {p : Filter ι}\n    {s : Set β} :\n    TendstoLocallyUniformlyOn F f p s ↔\n      ∀ ε > 0,\n        ∀ x ∈ s,\n          ∃ t ∈ nhds_within s x,\n            «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n              (∀ y ∈ t, edist (f y) (F n y) < ε) :=\n  by\n  refine' ⟨fun H ε hε => H _ (edist_mem_uniformity hε), fun H u hu x hx => _⟩\n  rcases mem_uniformity_edist.1 hu with ⟨ε, εpos, hε⟩\n  rcases H ε εpos x hx with ⟨t, ht, Ht⟩\n  exact ⟨t, ht, Ht.mono fun n hs x hx => hε (hs x hx)⟩\n#align tendsto_locally_uniformly_on_iff tendsto_locally_uniformly_on_iff\n\n",
 "tendsto_locally_uniformly_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- Expressing locally uniform convergence using `edist`. -/\ntheorem tendsto_locally_uniformly_iff {ι : Type _} [TopologicalSpace β] {F : ι → β → α} {f : β → α} {p : Filter ι} :\n    TendstoLocallyUniformly F f p ↔\n      ∀ ε > 0,\n        ∀ x : β,\n          ∃ t ∈ (nhds) x,\n            «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n              (∀ y ∈ t, edist (f y) (F n y) < ε) :=\n  by\n  simp only [← tendstoLocallyUniformlyOn_univ, tendsto_locally_uniformly_on_iff, mem_univ, forall_const, exists_prop,\n    nhdsWithin_univ]\n#align tendsto_locally_uniformly_iff tendsto_locally_uniformly_iff\n\n",
 "tendsto_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_at_top [Nonempty β] [SemilatticeSup β] {u : β → α} {a : α} :\n    Tendsto u atTop ((nhds) a) ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, edist (u n) a < ε :=\n  (atTop_basis.tendsto_iff nhds_basis_eball).trans <| by simp only [exists_prop, true_and_iff, mem_Ici, mem_ball]\n#align tendsto_at_top tendsto_at_top\n\n",
 "subset_countable_closure_of_compact":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set.  -/\ntheorem subset_countable_closure_of_compact {s : Set α} (hs : IsCompact s) :\n    ∃ (t : _)(_ : t ⊆ s), t.countable ∧ s ⊆ closure t :=\n  by\n  refine' subset_countable_closure_of_almost_dense_set s fun ε hε => _\n  rcases totally_bounded_iff'.1 hs.totally_bounded ε hε with ⟨t, hts, htf, hst⟩\n  exact ⟨t, htf.countable, subset.trans hst <| Union₂_mono fun _ _ => ball_subset_closed_ball⟩\n#align subset_countable_closure_of_compact subset_countable_closure_of_compact\n\n",
 "subset_countable_closure_of_almost_dense_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/-- For a set `s` in a pseudo emetric space, if for every `ε > 0` there exists a countable\nset that is `ε`-dense in `s`, then there exists a countable subset `t ⊆ s` that is dense in `s`. -/\ntheorem subset_countable_closure_of_almost_dense_set (s : Set α)\n    (hs :\n      ∀ ε > 0,\n        ∃ t : Set α,\n          t.countable ∧\n            s ⊆\n              «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                (closedBall x ε)) :\n    ∃ (t : _)(_ : t ⊆ s), t.countable ∧ s ⊆ closure t :=\n  by\n  rcases s.eq_empty_or_nonempty with (rfl | ⟨x₀, hx₀⟩)\n  · exact ⟨∅, empty_subset _, countable_empty, empty_subset _⟩\n  choose! T hTc hsT using fun n : ℕ => hs n⁻¹ (by simp)\n  have : ∀ r x, ∃ y ∈ s, closed_ball x r ∩ s ⊆ closed_ball y (r * 2) :=\n    by\n    intro r x\n    rcases(closed_ball x r ∩ s).eq_empty_or_nonempty with (he | ⟨y, hxy, hys⟩)\n    · refine' ⟨x₀, hx₀, _⟩\n      rw [he]\n      exact empty_subset _\n    · refine' ⟨y, hys, fun z hz => _⟩\n      calc\n        edist z y ≤ edist z x + edist y x := edist_triangle_right _ _ _\n        _ ≤ r + r := (add_le_add hz.1 hxy)\n        _ = r * 2 := (mul_two r).symm\n        \n  choose f hfs hf\n  refine'\n    ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr '' » (f n⁻¹) (T n)),\n      Union_subset fun n => image_subset_iff.2 fun z hz => hfs _ _, countable_Union fun n => (hTc n).image _, _⟩\n  refine' fun x hx => mem_closure_iff.2 fun ε ε0 => _\n  rcases ENNReal.exists_inv_nat_lt (ENNReal.half_pos ε0.lt.ne').ne' with ⟨n, hn⟩\n  rcases mem_Union₂.1 (hsT n hx) with ⟨y, hyn, hyx⟩\n  refine' ⟨f n⁻¹ y, mem_Union.2 ⟨n, mem_image_of_mem _ hyn⟩, _⟩\n  calc\n    edist x (f n⁻¹ y) ≤ n⁻¹ * 2 := hf _ _ ⟨hyx, hx⟩\n    _ < ε := ENNReal.mul_lt_of_lt_div hn\n    \n#align subset_countable_closure_of_almost_dense_set subset_countable_closure_of_almost_dense_set\n\n",
 "second_countable_of_sigma_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A sigma compact pseudo emetric space has second countable topology. This is not an instance\nto avoid a loop with `sigma_compact_space_of_locally_compact_second_countable`.  -/\ntheorem second_countable_of_sigma_compact [SigmaCompactSpace α] : SecondCountableTopology α :=\n  by\n  suffices separable_space α by exact UniformSpace.secondCountable_of_separable α\n  choose T hTsub hTc hsubT using fun n => subset_countable_closure_of_compact (isCompact_compactCovering α n)\n  refine'\n    ⟨⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (T n),\n        countable_Union hTc, fun x => _⟩⟩\n  rcases Union_eq_univ_iff.1 (unionᵢ_compactCovering α) x with ⟨n, hn⟩\n  exact closure_mono (subset_Union _ n) (hsubT _ hn)\n#align second_countable_of_sigma_compact second_countable_of_sigma_compact\n\n",
 "second_countable_of_almost_dense_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem second_countable_of_almost_dense_set\n    (hs :\n      ∀ ε > 0,\n        ∃ t : Set α,\n          t.countable ∧\n            «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                (closedBall x ε) =\n              univ) :\n    SecondCountableTopology α :=\n  by\n  suffices separable_space α by exact UniformSpace.secondCountable_of_separable α\n  rcases subset_countable_closure_of_almost_dense_set (univ : Set α) fun ε ε0 => _ with ⟨t, -, htc, ht⟩\n  · exact ⟨⟨t, htc, fun x => ht (mem_univ x)⟩⟩\n  · rcases hs ε ε0 with ⟨t, htc, ht⟩\n    exact ⟨t, htc, univ_subset_iff.2 ht⟩\n#align second_countable_of_almost_dense_set second_countable_of_almost_dense_set\n\n",
 "pos_of_mem_ball":
 "theorem pos_of_mem_ball (hy : y ∈ ball x ε) : 0 < ε :=\n  lt_of_le_of_lt (zero_le _) hy\n#align pos_of_mem_ball pos_of_mem_ball\n\n",
 "ord_connected_set_of_closed_ball_subset":
 "theorem ord_connected_set_of_closed_ball_subset (x : α) (s : Set α) : OrdConnected { r | closedBall x r ⊆ s } :=\n  ⟨fun r₁ hr₁ r₂ hr₂ r hr => (closedBall_subset_closedBall hr.2).trans hr₂⟩\n#align ord_connected_set_of_closed_ball_subset ord_connected_set_of_closed_ball_subset\n\n",
 "ord_connected_set_of_ball_subset":
 "theorem ord_connected_set_of_ball_subset (x : α) (s : Set α) : OrdConnected { r | ball x r ⊆ s } :=\n  ⟨fun r₁ hr₁ r₂ hr₂ r hr => (ball_subset_ball hr.2).trans hr₂⟩\n#align ord_connected_set_of_ball_subset ord_connected_set_of_ball_subset\n\n",
 "nhds_within_basis_eball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem nhds_within_basis_eball : (nhds_within s x).has_basis (fun ε : ennreal => 0 < ε) fun ε => ball x ε ∩ s :=\n  nhdsWithin_hasBasis nhds_basis_eball s\n#align nhds_within_basis_eball nhds_within_basis_eball\n\n",
 "nhds_within_basis_closed_eball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem nhds_within_basis_closed_eball :\n    (nhds_within s x).has_basis (fun ε : ennreal => 0 < ε) fun ε => closedBall x ε ∩ s :=\n  nhdsWithin_hasBasis nhds_basis_closed_eball s\n#align nhds_within_basis_closed_eball nhds_within_basis_closed_eball\n\n",
 "nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_eq :\n    (nhds) x =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (ball x ε)) :=\n  nhds_basis_eball.eq_binfi\n#align nhds_eq nhds_eq\n\n",
 "nhds_basis_eball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem nhds_basis_eball : ((nhds) x).has_basis (fun ε : ennreal => 0 < ε) (ball x) :=\n  nhds_basis_uniformity uniformity_basis_edist\n#align nhds_basis_eball nhds_basis_eball\n\n",
 "nhds_basis_closed_eball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem nhds_basis_closed_eball : ((nhds) x).has_basis (fun ε : ennreal => 0 < ε) (closedBall x) :=\n  nhds_basis_uniformity uniformity_basis_edist_le\n#align nhds_basis_closed_eball nhds_basis_closed_eball\n\n",
 "mk_uniformity_basis_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print EMetric.mk_uniformity_basis_le /-\n/-- Given `f : β → ℝ≥0∞`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then closed `f i`-neighborhoods of the diagonal form a basis of `𝓤 α`.\n\nFor specific bases see `uniformity_basis_edist_le` and `uniformity_basis_edist_le'`. -/\nprotected theorem EMetric.mk_uniformity_basis_le {β : Type _} {p : β → Prop} {f : β → ennreal}\n    (hf₀ : ∀ x, p x → 0 < f x) (hf : ∀ ε, 0 < ε → ∃ (x : _)(hx : p x), f x ≤ ε) :\n    ((uniformity) α).has_basis p fun x => { p : α × α | edist p.1 p.2 ≤ f x } :=\n  by\n  refine' ⟨fun s => uniformity_basis_edist.mem_iff.trans _⟩\n  constructor\n  · rintro ⟨ε, ε₀, hε⟩\n    rcases exists_between ε₀ with ⟨ε', hε'⟩\n    rcases hf ε' hε'.1 with ⟨i, hi, H⟩\n    exact ⟨i, hi, fun x hx => hε <| lt_of_le_of_lt (le_trans hx H) hε'.2⟩\n  · exact fun ⟨i, hi, H⟩ => ⟨f i, hf₀ i hi, fun x hx => H (le_of_lt hx)⟩\n#align emetric.mk_uniformity_basis_le EMetric.mk_uniformity_basis_le\n-/\n\n",
 "mk_uniformity_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print EMetric.mk_uniformity_basis /-\n/-- Given `f : β → ℝ≥0∞`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then `f i`-neighborhoods of the diagonal form a basis of `𝓤 α`.\n\nFor specific bases see `uniformity_basis_edist`, `uniformity_basis_edist'`,\n`uniformity_basis_edist_nnreal`, and `uniformity_basis_edist_inv_nat`. -/\nprotected theorem EMetric.mk_uniformity_basis {β : Type _} {p : β → Prop} {f : β → ennreal} (hf₀ : ∀ x, p x → 0 < f x)\n    (hf : ∀ ε, 0 < ε → ∃ (x : _)(hx : p x), f x ≤ ε) :\n    ((uniformity) α).has_basis p fun x => { p : α × α | edist p.1 p.2 < f x } :=\n  by\n  refine' ⟨fun s => uniformity_basis_edist.mem_iff.trans _⟩\n  constructor\n  · rintro ⟨ε, ε₀, hε⟩\n    rcases hf ε ε₀ with ⟨i, hi, H⟩\n    exact ⟨i, hi, fun x hx => hε <| lt_of_lt_of_le hx H⟩\n  · exact fun ⟨i, hi, H⟩ => ⟨f i, hf₀ i hi, H⟩\n#align emetric.mk_uniformity_basis EMetric.mk_uniformity_basis\n-/\n\n",
 "mem_uniformity_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print mem_uniformity_edist /-\n/-- Characterization of the elements of the uniformity in terms of the extended distance -/\ntheorem mem_uniformity_edist {s : Set (α × α)} :\n    s ∈ (uniformity) α ↔ ∃ ε > 0, ∀ {a b : α}, edist a b < ε → (a, b) ∈ s :=\n  uniformity_basis_edist.mem_uniformity_iff\n#align mem_uniformity_edist mem_uniformity_edist\n-/\n\n",
 "mem_nhds_within_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem mem_nhds_within_iff : s ∈ nhds_within t x ↔ ∃ ε > 0, ball x ε ∩ t ⊆ s :=\n  nhdsWithin_basis_eball.mem_iff\n#align mem_nhds_within_iff mem_nhds_within_iff\n\n",
 "mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_nhds_iff : s ∈ (nhds) x ↔ ∃ ε > 0, ball x ε ⊆ s :=\n  nhds_basis_eball.mem_iff\n#align mem_nhds_iff mem_nhds_iffₓ\n\n",
 "mem_closure_iff":
 "#print mem_closure_iff /-\n/-- ε-characterization of the closure in pseudoemetric spaces -/\ntheorem mem_closure_iff : x ∈ closure s ↔ ∀ ε > 0, ∃ y ∈ s, edist x y < ε :=\n  (mem_closure_iff_nhds_basis nhds_basis_eball).trans <| by simp only [mem_ball, edist_comm x]\n#align mem_closure_iff mem_closure_iff\n-/\n\n",
 "mem_closed_ball_self":
 "theorem mem_closed_ball_self : x ∈ closedBall x ε :=\n  show edist x x ≤ ε by rw [edist_self] <;> exact bot_le\n#align mem_closed_ball_self mem_closed_ball_self\n\n",
 "mem_closed_ball_comm":
 "theorem mem_closed_ball_comm : x ∈ closedBall y ε ↔ y ∈ closedBall x ε := by rw [mem_closed_ball', mem_closed_ball]\n#align mem_closed_ball_comm mem_closed_ball_comm\n\n",
 "mem_closed_ball'":
 "theorem mem_closed_ball' : y ∈ closedBall x ε ↔ edist x y ≤ ε := by rw [edist_comm, mem_closed_ball]\n#align mem_closed_ball' mem_closed_ball'\n\n",
 "mem_closed_ball":
 "@[simp]\ntheorem mem_closed_ball : y ∈ closedBall x ε ↔ edist y x ≤ ε :=\n  iff.rfl\n#align mem_closed_ball mem_closed_ball\n\n",
 "mem_ball_self":
 "theorem mem_ball_self (h : 0 < ε) : x ∈ ball x ε :=\n  show edist x x < ε by rw [edist_self] <;> assumption\n#align mem_ball_self mem_ball_self\n\n",
 "mem_ball_comm":
 "theorem mem_ball_comm : x ∈ ball y ε ↔ y ∈ ball x ε := by rw [mem_ball', mem_ball]\n#align mem_ball_comm mem_ball_comm\n\n",
 "mem_ball'":
 "theorem mem_ball' : y ∈ ball x ε ↔ edist x y < ε := by rw [edist_comm, mem_ball]\n#align mem_ball' mem_ball'\n\n",
 "mem_ball":
 "@[simp]\ntheorem mem_ball : y ∈ ball x ε ↔ edist y x < ε :=\n  iff.rfl\n#align mem_ball mem_ball\n\n",
 "is_open_iff":
 "theorem is_open_iff : IsOpen s ↔ ∀ x ∈ s, ∃ ε > 0, ball x ε ⊆ s := by simp [isOpen_iff_nhds, mem_nhds_iff]\n#align is_open_iff is_open_iff\n\n",
 "is_open_ball":
 "theorem is_open_ball : IsOpen (ball x ε) :=\n  isOpen_iff.2 fun y => exists_ball_subset_ball\n#align is_open_ball is_open_ball\n\n",
 "is_closed_ball_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_closed_ball_top : IsClosed (ball x («expr⊤»)) :=\n  isOpen_compl_iff.1 <|\n    isOpen_iff.2 fun y hy =>\n      ⟨«expr⊤», ENNReal.coe_lt_top,\n        (ball_disjoint <| by\n            rw [top_add]\n            exact le_of_not_lt hy).subset_compl_right⟩\n#align is_closed_ball_top is_closed_ball_top\n\n",
 "inseparable_iff":
 "theorem inseparable_iff : Inseparable x y ↔ edist x y = 0 := by\n  simp [inseparable_iff_mem_closure, mem_closure_iff, edist_comm, forall_lt_iff_le']\n#align inseparable_iff inseparable_iff\n\n",
 "exists_ball_subset_ball":
 "theorem exists_ball_subset_ball (h : y ∈ ball x ε) : ∃ ε' > 0, ball y ε' ⊆ ball x ε :=\n  by\n  have : 0 < ε - edist y x := by simpa using h\n  refine' ⟨ε - edist y x, this, ball_subset _ (ne_top_of_lt h)⟩\n  exact (add_tsub_cancel_of_le (mem_ball.mp h).le).le\n#align exists_ball_subset_ball exists_ball_subset_ball\n\n",
 "eq_of_forall_edist_le":
 "#print eq_of_forall_edist_le /-\n/-- Two points coincide if their distance is `< ε` for all positive ε -/\ntheorem eq_of_forall_edist_le {x y : γ} (h : ∀ ε > 0, edist x y ≤ ε) : x = y :=\n  eq_of_edist_eq_zero (eq_of_le_of_forall_le_of_dense bot_le h)\n#align eq_of_forall_edist_le eq_of_forall_edist_le\n-/\n\n",
 "edist_up_up":
 "#print ULift.edist_up_up /-\n@[simp]\ntheorem ULift.edist_up_up (x y : α) : edist (ULift.up x) (ULift.up y) = edist x y :=\n  rfl\n#align ulift.edist_up_up ULift.edist_up_up\n-/\n\n",
 "edist_unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[to_additive]\ntheorem edist_unop (x y : «expr ᵐᵒᵖ» α) : edist (unop x) (unop y) = edist x y :=\n  rfl\n#align edist_unop edist_unop\n\n",
 "edist_triangle_right":
 "#print edist_triangle_right /-\ntheorem edist_triangle_right (x y z : α) : edist x y ≤ edist x z + edist y z := by\n  rw [edist_comm y] <;> apply edist_triangle\n#align edist_triangle_right edist_triangle_right\n-/\n\n",
 "edist_triangle_left":
 "#print edist_triangle_left /-\n-- the uniform structure is embedded in the emetric space structure\n-- to avoid instance diamond issues. See Note [forgetful inheritance].\n/- Pseudoemetric spaces are less common than metric spaces. Therefore, we work in a dedicated\nnamespace, while notions associated to metric spaces are mostly in the root namespace. -/\n/-- Triangle inequality for the extended distance -/\ntheorem edist_triangle_left (x y z : α) : edist x y ≤ edist z x + edist z y := by\n  rw [edist_comm z] <;> apply edist_triangle\n#align edist_triangle_left edist_triangle_left\n-/\n\n",
 "edist_triangle4":
 "#print edist_triangle4 /-\ntheorem edist_triangle4 (x y z t : α) : edist x t ≤ edist x y + edist y z + edist z t :=\n  calc\n    edist x t ≤ edist x z + edist z t := edist_triangle x z t\n    _ ≤ edist x y + edist y z + edist z t := add_le_add_right (edist_triangle x y z) _\n    \n#align edist_triangle4 edist_triangle4\n-/\n\n",
 "edist_toMul":
 "#print edist_toMul /-\n@[simp]\ntheorem edist_toMul (a b : Additive X) : edist (toMul a) (toMul b) = edist a b :=\n  rfl\n#align edist_to_mul edist_toMul\n-/\n\n",
 "edist_toDual":
 "#print edist_toDual /-\n@[simp]\ntheorem edist_toDual (a b : X) : edist (toDual a) (toDual b) = edist a b :=\n  rfl\n#align edist_to_dual edist_toDual\n-/\n\n",
 "edist_toAdd":
 "#print edist_toAdd /-\n@[simp]\ntheorem edist_toAdd (a b : Multiplicative X) : edist (toAdd a) (toAdd b) = edist a b :=\n  rfl\n#align edist_to_add edist_toAdd\n-/\n\n",
 "edist_pos":
 "#print edist_pos /-\n@[simp]\ntheorem edist_pos {x y : γ} : 0 < edist x y ↔ x ≠ y := by simp [← not_le]\n#align edist_pos edist_pos\n-/\n\n",
 "edist_pi_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n#print edist_pi_le_iff /-\ntheorem edist_pi_le_iff [∀ b, PseudoEMetricSpace (π b)] {f g : ∀ b, π b} {d : ennreal} :\n    edist f g ≤ d ↔ ∀ b, edist (f b) (g b) ≤ d :=\n  Finset.sup_le_iff.trans <| by simp only [Finset.mem_univ, forall_const]\n#align edist_pi_le_iff edist_pi_le_iff\n-/\n\n",
 "edist_pi_def":
 "#print edist_pi_def /-\ntheorem edist_pi_def [∀ b, PseudoEMetricSpace (π b)] (f g : ∀ b, π b) :\n    edist f g = Finset.sup univ fun b => edist (f b) (g b) :=\n  rfl\n#align edist_pi_def edist_pi_def\n-/\n\n",
 "edist_pi_const_le":
 "#print edist_pi_const_le /-\ntheorem edist_pi_const_le (a b : α) : (edist (fun _ : β => a) fun _ => b) ≤ edist a b :=\n  edist_pi_le_iff.2 fun _ => le_rfl\n#align edist_pi_const_le edist_pi_const_le\n-/\n\n",
 "edist_pi_const":
 "#print edist_pi_const /-\n@[simp]\ntheorem edist_pi_const [Nonempty β] (a b : α) : (edist (fun x : β => a) fun _ => b) = edist a b :=\n  Finset.sup_const univ_nonempty (edist a b)\n#align edist_pi_const edist_pi_const\n-/\n\n",
 "edist_op":
 "@[to_additive]\ntheorem edist_op (x y : α) : edist (op x) (op y) = edist x y :=\n  rfl\n#align edist_op edist_op\n\n",
 "edist_ofMul":
 "#print edist_ofMul /-\n@[simp]\ntheorem edist_ofMul (a b : X) : edist (ofMul a) (ofMul b) = edist a b :=\n  rfl\n#align edist_of_mul edist_ofMul\n-/\n\n",
 "edist_ofDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print edist_ofDual /-\n@[simp]\ntheorem edist_ofDual (a b : «expr ᵒᵈ» X) : edist (ofDual a) (ofDual b) = edist a b :=\n  rfl\n#align edist_of_dual edist_ofDual\n-/\n\n",
 "edist_ofAdd":
 "#print edist_ofAdd /-\n@[simp]\ntheorem edist_ofAdd (a b : X) : edist (ofAdd a) (ofAdd b) = edist a b :=\n  rfl\n#align edist_of_add edist_ofAdd\n-/\n\n",
 "edist_mk":
 "#print UniformSpace.SeparationQuotient.edist_mk /-\n@[simp]\ntheorem UniformSpace.SeparationQuotient.edist_mk [PseudoEMetricSpace X] (x y : X) :\n    @edist (UniformSpace.SeparationQuotient X) _ (Quot.mk _ x) (Quot.mk _ y) = edist x y :=\n  rfl\n#align uniform_space.separation_quotient.edist_mk UniformSpace.SeparationQuotient.edist_mk\n-/\n\n",
 "edist_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print edist_mem_uniformity /-\n/-- Fixed size neighborhoods of the diagonal belong to the uniform structure -/\ntheorem edist_mem_uniformity {ε : ennreal} (ε0 : 0 < ε) : { p : α × α | edist p.1 p.2 < ε } ∈ (uniformity) α :=\n  mem_uniformity_edist.2 ⟨ε, ε0, fun a b => id⟩\n#align edist_mem_uniformity edist_mem_uniformity\n-/\n\n",
 "edist_le_zero":
 "#print edist_le_zero /-\ntheorem edist_le_zero {x y : γ} : edist x y ≤ 0 ↔ x = y :=\n  nonpos_iff_eq_zero.trans edist_eq_zero\n#align edist_le_zero edist_le_zero\n-/\n\n",
 "edist_le_range_sum_of_edist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print edist_le_range_sum_of_edist_le /-\n/-- A version of `edist_le_range_sum_edist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem edist_le_range_sum_of_edist_le {f : ℕ → α} (n : ℕ) {d : ℕ → ennreal}\n    (hd : ∀ {k}, k < n → edist (f k) (f (k + 1)) ≤ d k) :\n    edist (f 0) (f n) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (d i) :=\n  Nat.Ico_zero_eq_range ▸ edist_le_Ico_sum_of_edist_le (zero_le n) fun _ _ => hd\n#align edist_le_range_sum_of_edist_le edist_le_range_sum_of_edist_le\n-/\n\n",
 "edist_le_range_sum_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print edist_le_range_sum_edist /-\n/-- The triangle (polygon) inequality for sequences of points; `finset.range` version. -/\ntheorem edist_le_range_sum_edist (f : ℕ → α) (n : ℕ) :\n    edist (f 0) (f n) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (edist (f i) (f (i + 1))) :=\n  Nat.Ico_zero_eq_range ▸ edist_le_Ico_sum_edist f (nat.zero_le n)\n#align edist_le_range_sum_edist edist_le_range_sum_edist\n-/\n\n",
 "edist_le_pi_edist":
 "#print edist_le_pi_edist /-\ntheorem edist_le_pi_edist [∀ b, PseudoEMetricSpace (π b)] (f g : ∀ b, π b) (b : β) : edist (f b) (g b) ≤ edist f g :=\n  Finset.le_sup (Finset.mem_univ b)\n#align edist_le_pi_edist edist_le_pi_edist\n-/\n\n",
 "edist_le_of_diam_le":
 "theorem edist_le_of_diam_le {d} (hx : x ∈ s) (hy : y ∈ s) (hd : diam s ≤ d) : edist x y ≤ d :=\n  diam_le_iff.1 hd x hx y hy\n#align edist_le_of_diam_le edist_le_of_diam_le\n\n",
 "edist_le_diam_of_mem":
 "/-- If two points belong to some set, their edistance is bounded by the diameter of the set -/\ntheorem edist_le_diam_of_mem (hx : x ∈ s) (hy : y ∈ s) : edist x y ≤ diam s :=\n  edist_le_of_diam_le hx hy le_rfl\n#align edist_le_diam_of_mem edist_le_diam_of_mem\n\n",
 "edist_le_Ico_sum_of_edist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print edist_le_Ico_sum_of_edist_le /-\n/-- A version of `edist_le_Ico_sum_edist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem edist_le_Ico_sum_of_edist_le {f : ℕ → α} {m n} (hmn : m ≤ n) {d : ℕ → ennreal}\n    (hd : ∀ {k}, m ≤ k → k < n → edist (f k) (f (k + 1)) ≤ d k) :\n    edist (f m) (f n) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.Ico m n)\n        (d i) :=\n  le_trans (edist_le_Ico_sum_edist f hmn) <|\n    Finset.sum_le_sum fun k hk => hd (Finset.mem_Ico.1 hk).1 (Finset.mem_Ico.1 hk).2\n#align edist_le_Ico_sum_of_edist_le edist_le_Ico_sum_of_edist_le\n-/\n\n",
 "edist_le_Ico_sum_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print edist_le_Ico_sum_edist /-\n/-- The triangle (polygon) inequality for sequences of points; `finset.Ico` version. -/\ntheorem edist_le_Ico_sum_edist (f : ℕ → α) {m n} (h : m ≤ n) :\n    edist (f m) (f n) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.Ico m n)\n        (edist (f i) (f (i + 1))) :=\n  by\n  revert n\n  refine' Nat.le_induction _ _\n  · simp only [Finset.sum_empty, Finset.Ico_self, edist_self]\n    -- TODO: Why doesn't Lean close this goal automatically? `exact le_rfl` fails too.\n    exact le_refl (0 : ennreal)\n  · intro n hn hrec\n    calc\n      edist (f m) (f (n + 1)) ≤ edist (f m) (f n) + edist (f n) (f (n + 1)) := edist_triangle _ _ _\n      _ ≤\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Finset.Ico m n) _ +\n            _ :=\n        (add_le_add hrec le_rfl)\n      _ =\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Finset.Ico m (n + 1)) _ :=\n        by rw [Nat.Ico_succ_right_eq_insert_Ico hn, Finset.sum_insert, add_comm] <;> simp\n      \n#align edist_le_Ico_sum_edist edist_le_Ico_sum_edist\n-/\n\n",
 "edist_eq_zero":
 "#print edist_eq_zero /-\n--namespace\n/-- Characterize the equality of points by the vanishing of their extended distance -/\n@[simp]\ntheorem edist_eq_zero {x y : γ} : edist x y = 0 ↔ x = y :=\n  iff.intro eq_of_edist_eq_zero fun this : x = y => this ▸ edist_self _\n#align edist_eq_zero edist_eq_zero\n-/\n\n",
 "edist_eq":
 "#print Prod.edist_eq /-\ntheorem Prod.edist_eq [PseudoEMetricSpace β] (x y : α × β) : edist x y = max (edist x.1 y.1) (edist x.2 y.2) :=\n  rfl\n#align prod.edist_eq Prod.edist_eq\n-/\n\n",
 "edist_congr_right":
 "#print edist_congr_right /-\ntheorem edist_congr_right {x y z : α} (h : edist x y = 0) : edist x z = edist y z :=\n  by\n  apply le_antisymm\n  · rw [← zero_add (edist y z), ← h]\n    apply edist_triangle\n  · rw [edist_comm] at h\n    rw [← zero_add (edist x z), ← h]\n    apply edist_triangle\n#align edist_congr_right edist_congr_right\n-/\n\n",
 "edist_congr_left":
 "#print edist_congr_left /-\ntheorem edist_congr_left {x y z : α} (h : edist x y = 0) : edist z x = edist z y :=\n  by\n  rw [edist_comm z x, edist_comm z y]\n  apply edist_congr_right h\n#align edist_congr_left edist_congr_left\n-/\n\n",
 "diam_union'":
 "theorem diam_union' {t : Set α} (h : (s ∩ t).nonempty) : diam (s ∪ t) ≤ diam s + diam t :=\n  by\n  let ⟨x, ⟨xs, xt⟩⟩ := h\n  simpa using diam_union xs xt\n#align diam_union' diam_union'\n\n",
 "diam_union":
 "/-- The diameter of a union is controlled by the diameter of the sets, and the edistance\nbetween two points in the sets. -/\ntheorem diam_union {t : Set α} (xs : x ∈ s) (yt : y ∈ t) : diam (s ∪ t) ≤ diam s + edist x y + diam t :=\n  by\n  have A : ∀ a ∈ s, ∀ b ∈ t, edist a b ≤ diam s + edist x y + diam t := fun a ha b hb =>\n    calc\n      edist a b ≤ edist a x + edist x y + edist y b := edist_triangle4 _ _ _ _\n      _ ≤ diam s + edist x y + diam t :=\n        add_le_add (add_le_add (edist_le_diam_of_mem ha xs) le_rfl) (edist_le_diam_of_mem yt hb)\n      \n  refine' diam_le fun a ha b hb => _\n  cases' (mem_union _ _ _).1 ha with h'a h'a <;> cases' (mem_union _ _ _).1 hb with h'b h'b\n  ·\n    calc\n      edist a b ≤ diam s := edist_le_diam_of_mem h'a h'b\n      _ ≤ diam s + (edist x y + diam t) := le_self_add\n      _ = diam s + edist x y + diam t := (add_assoc _ _ _).symm\n      \n  · exact A a h'a b h'b\n  · have Z := A b h'b a h'a\n    rwa [edist_comm] at Z\n  ·\n    calc\n      edist a b ≤ diam t := edist_le_diam_of_mem h'a h'b\n      _ ≤ diam s + edist x y + diam t := le_add_self\n      \n#align diam_union diam_union\n\n",
 "diam_triple":
 "theorem diam_triple : diam ({x, y, z} : Set α) = max (max (edist x y) (edist x z)) (edist y z) := by\n  simp only [diam_insert, supᵢ_insert, supᵢ_singleton, diam_singleton, ENNReal.max_zero_right, ENNReal.sup_eq_max]\n#align diam_triple diam_triple\n\n",
 "diam_subsingleton":
 "/-- The diameter of a subsingleton vanishes. -/\ntheorem diam_subsingleton (hs : s.subsingleton) : diam s = 0 :=\n  nonpos_iff_eq_zero.1 <| diam_le fun x hx y hy => (hs hx hy).symm ▸ edist_self y ▸ le_rfl\n#align diam_subsingleton diam_subsingleton\n\n",
 "diam_singleton":
 "/-- The diameter of a singleton vanishes -/\n@[simp]\ntheorem diam_singleton : diam ({x} : Set α) = 0 :=\n  diam_subsingleton subsingleton_singleton\n#align diam_singleton diam_singleton\n\n",
 "diam_pos_iff":
 "theorem diam_pos_iff : 0 < diam s ↔ ∃ x ∈ s, ∃ y ∈ s, x ≠ y := by\n  simp only [pos_iff_ne_zero, ne.def, diam_eq_zero_iff, Set.Subsingleton, not_forall]\n#align diam_pos_iff diam_pos_iff\n\n",
 "diam_pi_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem diam_pi_le_of_le {π : β → Type _} [Fintype β] [∀ b, PseudoEMetricSpace (π b)] {s : ∀ b : β, Set (π b)}\n    {c : ennreal} (h : ∀ b, diam (s b) ≤ c) : diam (Set.pi univ s) ≤ c :=\n  by\n  apply diam_le fun x hx y hy => edist_pi_le_iff.mpr _\n  rw [mem_univ_pi] at hx hy\n  exact fun b => diam_le_iff.1 (h b) (x b) (hx b) (y b) (hy b)\n#align diam_pi_le_of_le diam_pi_le_of_le\n\n",
 "diam_pair":
 "theorem diam_pair : diam ({x, y} : Set α) = edist x y := by\n  simp only [supᵢ_singleton, diam_insert, diam_singleton, ENNReal.max_zero_right]\n#align diam_pair diam_pair\n\n",
 "diam_mono":
 "/-- The diameter is monotonous with respect to inclusion -/\ntheorem diam_mono {s t : Set α} (h : s ⊆ t) : diam s ≤ diam t :=\n  diam_le fun x hx y hy => edist_le_diam_of_mem (h hx) (h hy)\n#align diam_mono diam_mono\n\n",
 "diam_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem diam_le_iff {d : ennreal} : diam s ≤ d ↔ ∀ x ∈ s, ∀ y ∈ s, edist x y ≤ d := by simp only [diam, supᵢ_le_iff]\n#align diam_le_iff diam_le_iff\n\n",
 "diam_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/-- If the distance between any two points in a set is bounded by some constant, this constant\nbounds the diameter. -/\ntheorem diam_le {d : ennreal} (h : ∀ x ∈ s, ∀ y ∈ s, edist x y ≤ d) : diam s ≤ d :=\n  diam_le_iff.2 h\n#align diam_le diam_le\n\n",
 "diam_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem diam_insert :\n    diam (insert x s) =\n      max («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (edist x y))\n        (diam s) :=\n  eq_of_forall_ge_iff fun d => by\n    simp only [diam_le_iff, ball_insert_iff, edist_self, edist_comm x, max_le_iff, supᵢ_le_iff, zero_le, true_and_iff,\n      forall_and, and_self_iff, ← and_assoc']\n#align diam_insert diam_insert\n\n",
 "diam_image_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem diam_image_le_iff {d : ennreal} {f : β → α} {s : Set β} :\n    diam («expr '' » f s) ≤ d ↔ ∀ x ∈ s, ∀ y ∈ s, edist (f x) (f y) ≤ d := by simp only [diam_le_iff, ball_image_iff]\n#align diam_image_le_iff diam_image_le_iff\n\n",
 "diam_eq_zero_iff":
 "theorem diam_eq_zero_iff : diam s = 0 ↔ s.subsingleton :=\n  ⟨fun h x hx y hy => edist_le_zero.1 <| h ▸ edist_le_diam_of_mem hx hy, diam_subsingleton⟩\n#align diam_eq_zero_iff diam_eq_zero_iff\n\n",
 "diam_empty":
 "/-- The diameter of the empty set vanishes -/\n@[simp]\ntheorem diam_empty : diam (∅ : Set α) = 0 :=\n  diam_subsingleton subsingleton_empty\n#align diam_empty diam_empty\n\n",
 "diam_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem diam_closed_ball {r : ennreal} : diam (closedBall x r) ≤ 2 * r :=\n  diam_le fun a ha b hb =>\n    calc\n      edist a b ≤ edist a x + edist b x := edist_triangle_right _ _ _\n      _ ≤ r + r := (add_le_add ha hb)\n      _ = 2 * r := (two_mul r).symm\n      \n#align diam_closed_ball diam_closed_ball\n\n",
 "diam_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem diam_ball {r : ennreal} : diam (ball x r) ≤ 2 * r :=\n  le_trans (diam_mono ball_subset_closedBall) diam_closedBall\n#align diam_ball diam_ball\n\n",
 "diam_Union_mem_option":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem diam_Union_mem_option {ι : Type _} (o : Option ι) (s : ι → Set α) :\n    diam («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (diam (s i)) :=\n  by cases o <;> simp\n#align diam_Union_mem_option diam_Union_mem_option\n\n",
 "countable_closure_of_compact":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem countable_closure_of_compact {s : Set γ} (hs : IsCompact s) :\n    ∃ (t : _)(_ : t ⊆ s), t.countable ∧ s = closure t :=\n  by\n  rcases subset_countable_closure_of_compact hs with ⟨t, hts, htc, hsub⟩\n  exact ⟨t, hts, htc, subset.antisymm hsub (closure_minimal hts hs.is_closed)⟩\n#align countable_closure_of_compact countable_closure_of_compact\n\n",
 "controlled_of_uniform_embedding":
 "/-- If a map between pseudoemetric spaces is a uniform embedding then the edistance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y`. -/\ntheorem controlled_of_uniform_embedding [PseudoEMetricSpace β] {f : α → β} :\n    UniformEmbedding f →\n      (∀ ε > 0, ∃ δ > 0, ∀ {a b : α}, edist a b < δ → edist (f a) (f b) < ε) ∧\n        ∀ δ > 0, ∃ ε > 0, ∀ {a b : α}, edist (f a) (f b) < ε → edist a b < δ :=\n  fun h => ⟨uniformContinuous_iff.1 (uniformEmbedding_iff.1 h).2.1, (uniformEmbedding_iff.1 h).2.2⟩\n#align controlled_of_uniform_embedding controlled_of_uniform_embedding\n\n",
 "complete_of_convergent_controlled_sequences":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A very useful criterion to show that a space is complete is to show that all sequences\nwhich satisfy a bound of the form `edist (u n) (u m) < B N` for all `n m ≥ N` are\nconverging. This is often applied for `B N = 2^{-N}`, i.e., with a very fast convergence to\n`0`, which makes it possible to use arguments of converging series, while this is impossible\nto do in general for arbitrary Cauchy sequences. -/\ntheorem complete_of_convergent_controlled_sequences (B : ℕ → ennreal) (hB : ∀ n, 0 < B n)\n    (H : ∀ u : ℕ → α, (∀ N n m : ℕ, N ≤ n → N ≤ m → edist (u n) (u m) < B N) → ∃ x, Tendsto u atTop ((nhds) x)) :\n    CompleteSpace α :=\n  UniformSpace.complete_of_convergent_controlled_sequences (fun n => { p : α × α | edist p.1 p.2 < B n })\n    (fun n => edist_mem_uniformity <| hB n) H\n#align complete_of_convergent_controlled_sequences complete_of_convergent_controlled_sequences\n\n",
 "complete_of_cauchy_seq_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A sequentially complete pseudoemetric space is complete. -/\ntheorem complete_of_cauchy_seq_tendsto :\n    (∀ u : ℕ → α, CauchySeq u → ∃ a, Tendsto u atTop ((nhds) a)) → CompleteSpace α :=\n  UniformSpace.complete_of_cauchySeq_tendsto\n#align complete_of_cauchy_seq_tendsto complete_of_cauchy_seq_tendsto\n\n",
 "closed_ball_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n@[simp]\ntheorem closed_ball_top (x : α) : closedBall x (ennreal.top) = univ :=\n  eq_univ_of_forall fun y => le_top\n#align closed_ball_top closed_ball_top\n\n",
 "closed_ball_subset_closed_ball":
 "theorem closed_ball_subset_closed_ball (h : ε₁ ≤ ε₂) : closedBall x ε₁ ⊆ closedBall x ε₂ := fun y (yx : _ ≤ ε₁) =>\n  le_trans yx h\n#align closed_ball_subset_closed_ball closed_ball_subset_closed_ball\n\n",
 "closed_ball_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem closed_ball_mem_nhds (x : α) {ε : ennreal} (ε0 : 0 < ε) : closedBall x ε ∈ (nhds) x :=\n  mem_of_superset (ball_mem_nhds x ε0) ball_subset_closedBall\n#align closed_ball_mem_nhds closed_ball_mem_nhds\n\n",
 "closedBall_prod_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print closedBall_prod_same /-\ntheorem closedBall_prod_same [PseudoEMetricSpace β] (x : α) (y : β) (r : ennreal) :\n    lower_set.prod (closedBall x r) (closedBall y r) = closedBall (x, y) r :=\n  ext fun z => max_le_iff.symm\n#align closed_ball_prod_same closedBall_prod_same\n-/\n\n",
 "cauchy_seq_iff_nnreal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-- A variation of the emetric characterization of Cauchy sequences that deals with\n`ℝ≥0` upper bounds. -/\ntheorem cauchy_seq_iff_nnreal [Nonempty β] [SemilatticeSup β] {u : β → α} :\n    CauchySeq u ↔ ∀ ε : nnreal, 0 < ε → ∃ N, ∀ n, N ≤ n → edist (u n) (u N) < ε :=\n  uniformity_basis_edist_nnreal.cauchy_seq_iff'\n#align cauchy_seq_iff_nnreal cauchy_seq_iff_nnreal\n\n",
 "cauchy_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » t) -/\n#print cauchy_iff /-\n/-- ε-δ characterization of Cauchy sequences on pseudoemetric spaces -/\nprotected theorem cauchy_iff {f : Filter α} :\n    Cauchy f ↔ f ≠ «expr⊥» ∧ ∀ ε > 0, ∃ t ∈ f, ∀ (x) (_ : x ∈ t) (y) (_ : y ∈ t), edist x y < ε := by\n  rw [← ne_bot_iff] <;> exact uniformity_basis_edist.cauchy_iff\n#align cauchy_iff cauchy_iff\n-/\n\n",
 "cauchySeq_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n#print cauchySeq_iff' /-\n/-- A variation around the emetric characterization of Cauchy sequences -/\ntheorem cauchySeq_iff' [Nonempty β] [SemilatticeSup β] {u : β → α} :\n    CauchySeq u ↔ ∀ ε > (0 : ennreal), ∃ N, ∀ n ≥ N, edist (u n) (u N) < ε :=\n  uniformity_basis_edist.cauchy_seq_iff'\n#align cauchy_seq_iff' cauchySeq_iff'\n-/\n\n",
 "cauchySeq_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (m n «expr ≥ » N) -/\n#print cauchySeq_iff /-\n-- see Note [nolint_ge]\n/-- In a pseudoemetric space, Cauchy sequences are characterized by the fact that, eventually,\nthe pseudoedistance between its elements is arbitrarily small -/\n@[nolint ge_or_gt]\ntheorem cauchySeq_iff [Nonempty β] [SemilatticeSup β] {u : β → α} :\n    CauchySeq u ↔ ∀ ε > 0, ∃ N, ∀ (m) (_ : m ≥ N) (n) (_ : n ≥ N), edist (u m) (u n) < ε :=\n  uniformity_basis_edist.cauchy_seq_iff\n#align cauchy_seq_iff cauchySeq_iff\n-/\n\n",
 "ball_zero":
 "@[simp]\ntheorem ball_zero : ball x 0 = ∅ := by rw [EMetric.ball_eq_empty_iff]\n#align ball_zero ball_zero\n\n",
 "ball_subset_closed_ball":
 "theorem ball_subset_closed_ball : ball x ε ⊆ closedBall x ε := fun y hy => le_of_lt hy\n#align ball_subset_closed_ball ball_subset_closed_ball\n\n",
 "ball_subset_ball":
 "theorem ball_subset_ball (h : ε₁ ≤ ε₂) : ball x ε₁ ⊆ ball x ε₂ := fun y (yx : _ < ε₁) => lt_of_lt_of_le yx h\n#align ball_subset_ball ball_subset_ball\n\n",
 "ball_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem ball_subset (h : edist x y + ε₁ ≤ ε₂) (h' : edist x y ≠ ennreal.top) : ball x ε₁ ⊆ ball y ε₂ := fun z zx =>\n  calc\n    edist z y ≤ edist z x + edist x y := edist_triangle _ _ _\n    _ = edist x y + edist z x := (add_comm _ _)\n    _ < edist x y + ε₁ := (ENNReal.add_lt_add_left h' zx)\n    _ ≤ ε₂ := h\n    \n#align ball_subset ball_subset\n\n",
 "ball_prod_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print ball_prod_same /-\ntheorem ball_prod_same [PseudoEMetricSpace β] (x : α) (y : β) (r : ennreal) :\n    lower_set.prod (ball x r) (ball y r) = ball (x, y) r :=\n  ext fun z => max_lt_iff.symm\n#align ball_prod_same ball_prod_same\n-/\n\n",
 "ball_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ball_mem_nhds (x : α) {ε : ennreal} (ε0 : 0 < ε) : ball x ε ∈ (nhds) x :=\n  isOpen_ball.mem_nhds (mem_ball_self ε0)\n#align ball_mem_nhds ball_mem_nhds\n\n",
 "ball_eq_empty_iff":
 "theorem ball_eq_empty_iff : ball x ε = ∅ ↔ ε = 0 :=\n  eq_empty_iff_forall_not_mem.trans\n    ⟨fun h => le_bot_iff.1 (le_of_not_gt fun ε0 => h _ (mem_ball_self ε0)), fun ε0 y h =>\n      not_lt_of_le (le_of_eq ε0) (pos_of_mem_ball h)⟩\n#align ball_eq_empty_iff ball_eq_empty_iff\n\n",
 "ball_disjoint":
 "theorem ball_disjoint (h : ε₁ + ε₂ ≤ edist x y) : Disjoint (ball x ε₁) (ball y ε₂) :=\n  Set.disjoint_left.mpr fun z h₁ h₂ => (edist_triangle_left x y z).not_lt <| (ENNReal.add_lt_add h₁ h₂).trans_le h\n#align ball_disjoint ball_disjoint\n\n"}