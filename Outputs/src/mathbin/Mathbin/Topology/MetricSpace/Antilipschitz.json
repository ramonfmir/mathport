{"to_right_inverse":
 "theorem to_right_inverse (hf : AntilipschitzWith K f) {g : β → α} (hg : function.right_inverse g f) :\n    LipschitzWith K g := by\n  intro x y\n  have := hf (g x) (g y)\n  rwa [hg x, hg y] at this\n#align to_right_inverse to_right_inverse\n\n",
 "to_right_inv_on'":
 "theorem to_right_inv_on' {s : Set α} (hf : AntilipschitzWith K (s.restrict f)) {g : β → α} {t : Set β}\n    (g_maps : MapsTo g t s) (g_inv : RightInvOn g f t) : LipschitzWith K (t.restrict g) := fun x y => by\n  simpa only [restrict_apply, g_inv x.mem, g_inv y.mem, Subtype.edist_eq, Subtype.coe_mk] using\n    hf ⟨g x, g_maps x.mem⟩ ⟨g y, g_maps y.mem⟩\n#align to_right_inv_on' to_right_inv_on'\n\n",
 "to_right_inv_on":
 "theorem to_right_inv_on (hf : AntilipschitzWith K f) {g : β → α} {t : Set β} (h : RightInvOn g f t) :\n    LipschitzWith K (t.restrict g) :=\n  (hf.restrict univ).to_right_inv_on' (mapsTo_univ g t) h\n#align to_right_inv_on to_right_inv_on\n\n",
 "to_rightInverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print LipschitzWith.to_rightInverse /-\ntheorem LipschitzWith.to_rightInverse [PseudoEMetricSpace α] [PseudoEMetricSpace β] {K : nnreal} {f : α → β}\n    (hf : LipschitzWith K f) {g : β → α} (hg : function.right_inverse g f) : AntilipschitzWith K g := fun x y => by\n  simpa only [hg _] using hf (g x) (g y)\n#align lipschitz_with.to_right_inverse LipschitzWith.to_rightInverse\n-/\n\n",
 "tendsto_cobounded":
 "theorem tendsto_cobounded (hf : AntilipschitzWith K f) : Tendsto f (cobounded α) (cobounded β) :=\n  compl_surjective.forall.2 fun s (hs : IsBounded s) =>\n    Metric.isBounded_iff.2 <| hf.bounded_preimage <| Metric.isBounded_iff.1 hs\n#align tendsto_cobounded tendsto_cobounded\n\n",
 "subtype_coe":
 "theorem subtype_coe (s : Set α) : AntilipschitzWith 1 (coe : s → α) :=\n  AntilipschitzWith.id.restrict s\n#align subtype_coe subtype_coe\n\n",
 "subsingleton":
 "/-- If `f : α → β` is `0`-antilipschitz, then `α` is a `subsingleton`. -/\nprotected theorem subsingleton {α β} [EMetricSpace α] [PseudoEMetricSpace β] {f : α → β} (h : AntilipschitzWith 0 f) :\n    subsingleton α :=\n  ⟨fun x y => edist_le_zero.1 <| (h x y).trans_eq <| MulZeroClass.zero_mul _⟩\n#align subsingleton subsingleton\n\n",
 "restrict":
 "theorem restrict (hf : AntilipschitzWith K f) (s : Set α) : AntilipschitzWith K (s.restrict f) := fun x y => hf x y\n#align restrict restrict\n\n",
 "properSpace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₜ » -/\n#print LipschitzWith.properSpace /-\n/-- The preimage of a proper space under a Lipschitz homeomorphism is proper. -/\n@[protected]\ntheorem LipschitzWith.properSpace [PseudoMetricSpace α] [MetricSpace β] [ProperSpace β] {K : nnreal}\n    {f : «expr ≃ₜ » α β} (hK : LipschitzWith K f) : ProperSpace α :=\n  (hK.to_right_inverse f.right_inv).proper_space f.symm.continuous f.symm.surjective\n#align lipschitz_with.proper_space LipschitzWith.properSpace\n-/\n\n",
 "of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem of_subsingleton [subsingleton α] {K : nnreal} : AntilipschitzWith K f := fun x y => by\n  simp only [subsingleton.elim x y, edist_self, zero_le]\n#align of_subsingleton of_subsingleton\n\n",
 "mul_le_nndist":
 "theorem mul_le_nndist (hf : AntilipschitzWith K f) (x y : α) : K⁻¹ * nndist x y ≤ nndist (f x) (f y) := by\n  simpa only [div_eq_inv_mul] using NNReal.div_le_of_le_mul' (hf.le_mul_nndist x y)\n#align mul_le_nndist mul_le_nndist\n\n",
 "mul_le_edist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem mul_le_edist (hf : AntilipschitzWith K f) (x y : α) : (K⁻¹ * edist x y : ennreal) ≤ edist (f x) (f y) :=\n  by\n  rw [mul_comm, ← div_eq_mul_inv]\n  exact ENNReal.div_le_of_le_mul' (hf x y)\n#align mul_le_edist mul_le_edist\n\n",
 "mul_le_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mul_le_dist (hf : AntilipschitzWith K f) (x y : α) : (K⁻¹ * dist x y : exprℝ) ≤ dist (f x) (f y) := by\n  exact_mod_cast hf.mul_le_nndist x y\n#align mul_le_dist mul_le_dist\n\n",
 "le_mul_ediam_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem le_mul_ediam_image (hf : AntilipschitzWith K f) (s : Set α) : diam s ≤ K * diam («expr '' » f s) :=\n  (diam_mono (subset_preimage_image _ _)).trans (hf.ediam_preimage_le («expr '' » f s))\n#align le_mul_ediam_image le_mul_ediam_image\n\n",
 "is_complete_range":
 "theorem is_complete_range [CompleteSpace α] (hf : AntilipschitzWith K f) (hfc : UniformContinuous f) :\n    IsComplete (range f) :=\n  (hf.uniform_inducing hfc).is_complete_range\n#align is_complete_range is_complete_range\n\n",
 "is_closed_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem is_closed_range {α β : Type _} [PseudoEMetricSpace α] [EMetricSpace β] [CompleteSpace α] {f : α → β}\n    {K : nnreal} (hf : AntilipschitzWith K f) (hfc : UniformContinuous f) : IsClosed (range f) :=\n  (hf.is_complete_range hfc).is_closed\n#align is_closed_range is_closed_range\n\n",
 "injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n-- uses neither `f` nor `hf`\nprotected theorem injective {α : Type _} {β : Type _} [EMetricSpace α] [PseudoEMetricSpace β] {K : nnreal} {f : α → β}\n    (hf : AntilipschitzWith K f) : function.injective f := fun x y h => by\n  simpa only [h, edist_self, MulZeroClass.mul_zero, edist_le_zero] using hf x y\n#align injective injective\n\n",
 "id":
 "#print id /-\nprotected theorem id : AntilipschitzWith 1 (id : α → α) := fun x y => by\n  simp only [ENNReal.coe_one, one_mul, id, le_refl]\n#align id id\n-/\n\n",
 "edist_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print AntilipschitzWith.edist_ne_top /-\ntheorem AntilipschitzWith.edist_ne_top [PseudoEMetricSpace α] [PseudoMetricSpace β] {K : nnreal} {f : α → β}\n    (h : AntilipschitzWith K f) (x y : α) : edist x y ≠ «expr⊤» :=\n  (h.edist_lt_top x y).ne\n#align antilipschitz_with.edist_ne_top AntilipschitzWith.edist_ne_top\n-/\n\n",
 "edist_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print AntilipschitzWith.edist_lt_top /-\n/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\ntheorem AntilipschitzWith.edist_lt_top [PseudoEMetricSpace α] [PseudoMetricSpace β] {K : nnreal} {f : α → β}\n    (h : AntilipschitzWith K f) (x y : α) : edist x y < «expr⊤» :=\n  (h x y).trans_lt <| ENNReal.mul_lt_top ENNReal.coe_ne_top (edist_ne_top _ _)\n#align antilipschitz_with.edist_lt_top AntilipschitzWith.edist_lt_top\n-/\n\n",
 "ediam_preimage_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem ediam_preimage_le (hf : AntilipschitzWith K f) (s : Set β) : diam («expr ⁻¹' » f s) ≤ K * diam s :=\n  diam_le fun x hx y hy => (hf x y).trans <| mul_le_mul_left' (edist_le_diam_of_mem hx hy) K\n#align ediam_preimage_le ediam_preimage_le\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem comp {Kg : nnreal} {g : β → γ} (hg : AntilipschitzWith Kg g) {Kf : nnreal} {f : α → β}\n    (hf : AntilipschitzWith Kf f) : AntilipschitzWith (Kf * Kg) (g ∘ f) := fun x y =>\n  calc\n    edist x y ≤ Kf * edist (f x) (f y) := hf x y\n    _ ≤ Kf * (Kg * edist (g (f x)) (g (f y))) := (ENNReal.mul_left_mono (hg _ _))\n    _ = _ := by rw [ENNReal.coe_mul, mul_assoc]\n    \n#align comp comp\n\n",
 "comap_uniformity_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem comap_uniformity_le (hf : AntilipschitzWith K f) : ((uniformity) β).comap (prod.map f f) ≤ (uniformity) α :=\n  by\n  refine' ((uniformity_basis_edist.comap _).le_basis_iff uniformity_basis_edist).2 fun ε h₀ => _\n  refine' ⟨K⁻¹ * ε, ENNReal.mul_pos (ENNReal.inv_ne_zero.2 ENNReal.coe_ne_top) h₀.ne', _⟩\n  refine' fun x hx => (hf x.1 x.2).trans_lt _\n  rw [mul_comm, ← div_eq_mul_inv] at hx\n  rw [mul_comm]\n  exact ENNReal.mul_lt_of_lt_div hx\n#align comap_uniformity_le comap_uniformity_le\n\n",
 "cod_restrict":
 "theorem cod_restrict (hf : AntilipschitzWith K f) {s : Set β} (hs : ∀ x, f x ∈ s) :\n    AntilipschitzWith K (s.cod_restrict f hs) := fun x y => hf x y\n#align cod_restrict cod_restrict\n\n",
 "bounded_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem bounded_preimage (hf : AntilipschitzWith K f) {s : Set β} (hs : Bounded s) : Bounded («expr ⁻¹' » f s) :=\n  exists.intro (K * diam s) fun x hx y hy =>\n    calc\n      dist x y ≤ K * dist (f x) (f y) := hf.le_mul_dist x y\n      _ ≤ K * diam s := mul_le_mul_of_nonneg_left (dist_le_diam_of_mem hs hx hy) K.2\n      \n#align bounded_preimage bounded_preimage\n\n",
 "antilipschitzWith_iff_le_mul_nndist":
 "#print antilipschitzWith_iff_le_mul_nndist /-\ntheorem antilipschitzWith_iff_le_mul_nndist : AntilipschitzWith K f ↔ ∀ x y, nndist x y ≤ K * nndist (f x) (f y) :=\n  by\n  simp only [AntilipschitzWith, edist_nndist]\n  norm_cast\n#align antilipschitz_with_iff_le_mul_nndist antilipschitzWith_iff_le_mul_nndist\n-/\n\n",
 "antilipschitzWith_iff_le_mul_dist":
 "#print antilipschitzWith_iff_le_mul_dist /-\ntheorem antilipschitzWith_iff_le_mul_dist : AntilipschitzWith K f ↔ ∀ x y, dist x y ≤ K * dist (f x) (f y) :=\n  by\n  simp only [antilipschitzWith_iff_le_mul_nndist, dist_nndist]\n  norm_cast\n#align antilipschitz_with_iff_le_mul_dist antilipschitzWith_iff_le_mul_dist\n-/\n\n",
 "UniformInducing":
 "#print UniformInducing /-\nprotected theorem UniformInducing (hf : AntilipschitzWith K f) (hfc : UniformContinuous f) : UniformInducing f :=\n  ⟨le_antisymm hf.comap_uniformity_le hfc.le_comap⟩\n#align uniform_inducing UniformInducing\n-/\n\n",
 "UniformEmbedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print UniformEmbedding /-\nprotected theorem UniformEmbedding {α : Type _} {β : Type _} [EMetricSpace α] [PseudoEMetricSpace β] {K : nnreal}\n    {f : α → β} (hf : AntilipschitzWith K f) (hfc : UniformContinuous f) : UniformEmbedding f :=\n  ⟨hf.uniform_inducing hfc, hf.injective⟩\n#align uniform_embedding UniformEmbedding\n-/\n\n",
 "ProperSpace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print ProperSpace /-\n/-- The image of a proper space under an expanding onto map is proper. -/\nprotected theorem ProperSpace {α : Type _} [MetricSpace α] {K : nnreal} {f : α → β} [ProperSpace α]\n    (hK : AntilipschitzWith K f) (f_cont : Continuous f) (hf : function.surjective f) : ProperSpace β :=\n  by\n  apply properSpace_of_compact_closedBall_of_le 0 fun x₀ r hr => _\n  let K := «expr ⁻¹' » f (closed_ball x₀ r)\n  have A : IsClosed K := is_closed_ball.preimage f_cont\n  have B : bounded K := hK.bounded_preimage bounded_closed_ball\n  have : IsCompact K := is_compact_iff_is_closed_bounded.2 ⟨A, B⟩\n  convert this.image f_cont\n  exact (hf.image_preimage _).symm\n#align proper_space ProperSpace\n-/\n\n",
 "ClosedEmbedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print ClosedEmbedding /-\ntheorem ClosedEmbedding {α : Type _} {β : Type _} [EMetricSpace α] [EMetricSpace β] {K : nnreal} {f : α → β}\n    [CompleteSpace α] (hf : AntilipschitzWith K f) (hfc : UniformContinuous f) : ClosedEmbedding f :=\n  { (hf.uniform_embedding hfc).embedding with closed_range := hf.is_closed_range hfc }\n#align closed_embedding ClosedEmbedding\n-/\n\n"}