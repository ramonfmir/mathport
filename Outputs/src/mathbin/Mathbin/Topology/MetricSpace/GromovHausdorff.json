{"to_GH_space_rep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\ntheorem GH_space.to_GH_space_rep (p : GH_space) : to_GH_space p.rep = p :=\n  by\n  change to_GH_space (Quot.out p : nonempty_compacts (exprℓ_infty_ℝ)) = p\n  rw [← eq_to_GH_space]\n  exact Quot.out_eq p\n#align GH_space.to_GH_space_rep GH_space.to_GH_space_rep\n\n",
 "to_GH_space_lipschitz":
 "theorem to_GH_space_lipschitz : LipschitzWith 1 (nonempty_compacts.to_GH_space : NonemptyCompacts X → GH_space) :=\n  LipschitzWith.mk_one GH_dist_le_nonempty_compacts_dist\n#align to_GH_space_lipschitz to_GH_space_lipschitz\n\n",
 "to_GH_space_eq_to_GH_space_iff_isometry_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵢ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵢ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵢ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵢ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵢ » -/\n/-- Two nonempty compact spaces have the same image in `GH_space` if and only if they are\nisometric. -/\ntheorem to_GH_space_eq_to_GH_space_iff_isometry_equiv {X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X]\n    {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] :\n    to_GH_space X = to_GH_space Y ↔ Nonempty («expr ≃ᵢ » X Y) :=\n  ⟨by\n    simp only [to_GH_space, Quotient.eq']\n    rintro ⟨e⟩\n    have I :\n      «expr ≃ᵢ » (nonempty_compacts.Kuratowski_embedding X) (nonempty_compacts.Kuratowski_embedding Y) =\n        «expr ≃ᵢ » (range (Kuratowski_embedding X)) (range (Kuratowski_embedding Y)) :=\n      by\n      dsimp only [nonempty_compacts.Kuratowski_embedding]\n      rfl\n    have f := (Kuratowski_embedding.isometry X).isometry_equiv_on_range\n    have g := (Kuratowski_embedding.isometry Y).isometry_equiv_on_range.symm\n    exact ⟨f.trans <| (cast I e).trans g⟩, by\n    rintro ⟨e⟩\n    simp only [to_GH_space, Quotient.eq']\n    have f := (Kuratowski_embedding.isometry X).isometry_equiv_on_range.symm\n    have g := (Kuratowski_embedding.isometry Y).isometry_equiv_on_range\n    have I :\n      «expr ≃ᵢ » (range (Kuratowski_embedding X)) (range (Kuratowski_embedding Y)) =\n        «expr ≃ᵢ » (nonempty_compacts.Kuratowski_embedding X) (nonempty_compacts.Kuratowski_embedding Y) :=\n      by\n      dsimp only [nonempty_compacts.Kuratowski_embedding]\n      rfl\n    exact ⟨cast I ((f.trans e).trans g)⟩⟩\n#align to_GH_space_eq_to_GH_space_iff_isometry_equiv to_GH_space_eq_to_GH_space_iff_isometry_equiv\n\n",
 "to_GH_space_continuous":
 "theorem to_GH_space_continuous : Continuous (nonempty_compacts.to_GH_space : NonemptyCompacts X → GH_space) :=\n  to_GH_space_lipschitz.continuous\n#align to_GH_space_continuous to_GH_space_continuous\n\n",
 "is_equivalence_isometry_rel":
 "/-\nCopyright (c) 2019 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n/- In this section, we define the Gromov-Hausdorff space, denoted `GH_space` as the quotient\nof nonempty compact subsets of `ℓ^∞(ℝ)` by identifying isometric sets.\nUsing the Kuratwoski embedding, we get a canonical map `to_GH_space` mapping any nonempty\ncompact type to `GH_space`. -/\n/-- This is indeed an equivalence relation -/\nprivate theorem is_equivalence_isometry_rel : equivalence isometry_rel :=\n  ⟨fun x => ⟨IsometryEquiv.refl _⟩, fun x y ⟨e⟩ => ⟨e.symm⟩, fun x y z ⟨e⟩ ⟨f⟩ => ⟨e.trans f⟩⟩\n#align is_equivalence_isometry_rel is_equivalence_isometry_rel\n\n",
 "eq_to_GH_space_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵢ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵢ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\ntheorem eq_to_GH_space_iff {X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X]\n    {p : NonemptyCompacts (exprℓ_infty_ℝ)} :\n    «expr⟦ ⟧» p = to_GH_space X ↔ ∃ Ψ : X → exprℓ_infty_ℝ, Isometry Ψ ∧ range Ψ = p :=\n  by\n  simp only [to_GH_space, Quotient.eq']\n  refine' ⟨fun h => _, _⟩\n  · rcases setoid.symm h with ⟨e⟩\n    have f := (Kuratowski_embedding.isometry X).isometry_equiv_on_range.trans e\n    use fun x => f x, isometry_subtype_coe.comp f.isometry\n    rw [range_comp, f.range_eq_univ, Set.image_univ, Subtype.range_coe]\n    rfl\n  · rintro ⟨Ψ, ⟨isomΨ, rangeΨ⟩⟩\n    have f := ((Kuratowski_embedding.isometry X).isometry_equiv_on_range.symm.trans isomΨ.isometry_equiv_on_range).symm\n    have E :\n      «expr ≃ᵢ » (range Ψ) (nonempty_compacts.Kuratowski_embedding X) = «expr ≃ᵢ » p (range (Kuratowski_embedding X)) :=\n      by\n      dsimp only [nonempty_compacts.Kuratowski_embedding]\n      rw [rangeΨ] <;> rfl\n    exact ⟨cast E f⟩\n#align eq_to_GH_space_iff eq_to_GH_space_iff\n\n",
 "eq_to_GH_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem eq_to_GH_space {p : NonemptyCompacts (exprℓ_infty_ℝ)} : «expr⟦ ⟧» p = to_GH_space p :=\n  eq_to_GH_space_iff.2 ⟨fun x => x, isometry_subtype_coe, Subtype.range_coe⟩\n#align eq_to_GH_space eq_to_GH_space\n\n",
 "dist_GH_dist":
 "theorem dist_GH_dist (p q : GH_space) : dist p q = GH_dist p.rep q.rep := by\n  rw [GH_dist, p.to_GH_space_rep, q.to_GH_space_rep]\n#align dist_GH_dist dist_GH_dist\n\n",
 "TotallyBounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print TotallyBounded /-\n--section\n-- for each `p`, `s p` is a finite `ε`-dense subset of `p` (or rather the metric space\n-- `p.rep` representing `p`)\n-- cardinality of the nice finite subset `s p` of `p.rep`, called `N p`\n-- equiv from `s p`, a nice finite subset of `p.rep`, to `fin (N p)`, called `E p`\n-- A function `F` associating to `p : GH_space` the data of all distances between points\n-- in the `ε`-dense set `s p`.\n/- As the target space of F is countable, it suffices to show that two points\n  `p` and `q` with `F p = F q` are at distance `≤ δ`.\n  For this, we construct a map `Φ` from `s p ⊆ p.rep` (representing `p`)\n  to `q.rep` (representing `q`) which is almost an isometry on `s p`, and\n  with image `s q`. For this, we compose the identification of `s p` with `fin (N p)`\n  and the inverse of the identification of `s q` with `fin (N q)`. Together with\n  the fact that `N p = N q`, this constructs `Ψ` between `s p` and `s q`, and then\n  composing with the canonical inclusion we get `Φ`. -/\n-- Use the almost isometry `Φ` to show that `p.rep` and `q.rep`\n-- are within controlled Gromov-Hausdorff distance.\n-- by construction, `s p` is `ε`-dense\n-- by construction, `s q` is `ε`-dense, and it is the range of `Φ`\n/- the distance between `x` and `y` is encoded in `F p`, and the distance between\n      `Φ x` and `Φ y` (two points of `s q`) is encoded in `F q`, all this up to `ε`.\n      As `F p = F q`, the distances are almost equal. -/\n-- introduce `i`, that codes both `x` and `Φ x` in `fin (N p) = fin (N q)`\n-- introduce `j`, that codes both `y` and `Φ y` in `fin (N p) = fin (N q)`\n-- Express `dist x y` in terms of `F p`\n-- Express `dist (Φ x) (Φ y)` in terms of `F q`\n-- use the equality between `F p` and `F q` to deduce that the distances have equal\n-- integer parts\n-- we want to `subst hpq` where `hpq : F p = F q`, except that `subst` only works\n-- with a constant, so replace `F q` (and everything that depends on it) by a constant `f`\n-- then `subst`\n-- deduce that the distances coincide up to `ε`, by a straightforward computation\n-- that should be automated\n/-- Compactness criterion: a closed set of compact metric spaces is compact if the spaces have\na uniformly bounded diameter, and for all `ε` the number of balls of radius `ε` required\nto cover the spaces is uniformly bounded. This is an equivalence, but we only prove the\ninteresting direction that these conditions imply compactness. -/\ntheorem TotallyBounded {t : Set GH_space} {C : exprℝ} {u : ℕ → exprℝ} {K : ℕ → ℕ} (ulim : Tendsto u atTop ((nhds) 0))\n    (hdiam : ∀ p ∈ t, diam (univ : Set (GH_space.rep p)) ≤ C)\n    (hcov :\n      ∀ p ∈ t,\n        ∀ n : ℕ,\n          ∃ s : Set (GH_space.rep p),\n            Cardinal.mk s ≤ K n ∧\n              univ ⊆\n                «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                  (ball x (u n))) :\n    TotallyBounded t :=\n  by\n  /- Let `δ>0`, and `ε = δ/5`. For each `p`, we construct a finite subset `s p` of `p`, which\n    is `ε`-dense and has cardinality at most `K n`. Encoding the mutual distances of points in `s p`,\n    up to `ε`, we will get a map `F` associating to `p` finitely many data, and making it possible to\n    reconstruct `p` up to `ε`. This is enough to prove total boundedness. -/\n  refine' Metric.totallyBounded_of_finite_discretization fun δ δpos => _\n  let ε := 1 / 5 * δ\n  have εpos : 0 < ε := mul_pos (by norm_num) δpos\n  -- choose `n` for which `u n < ε`\n  rcases Metric.tendsto_atTop.1 ulim ε εpos with ⟨n, hn⟩\n  have u_le_ε : u n ≤ ε := by\n    have := hn n le_rfl\n    simp only [Real.dist_eq, add_zero, sub_eq_add_neg, neg_zero] at this\n    exact le_of_lt (lt_of_le_of_lt (le_abs_self _) this)\n  -- construct a finite subset `s p` of `p` which is `ε`-dense and has cardinal `≤ K n`\n  have :\n    ∀ p : GH_space,\n      ∃ s : Set p.rep,\n        ∃ N ≤ K n,\n          ∃ E : Equiv s (Fin N),\n            p ∈ t →\n              univ ⊆\n                «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                  (ball x (u n)) :=\n    by\n    intro p\n    by_cases hp : p ∉ t\n    · have : Nonempty (Equiv (∅ : Set p.rep) (Fin 0)) :=\n        by\n        rw [← Fintype.card_eq]\n        simp only [empty_card', Fintype.card_fin]\n      use ∅, 0, bot_le, choice this\n    · rcases hcov _ (Set.not_not_mem.1 hp) n with ⟨s, ⟨scard, scover⟩⟩\n      rcases Cardinal.lt_aleph0.1 (lt_of_le_of_lt scard (Cardinal.nat_lt_aleph0 _)) with ⟨N, hN⟩\n      rw [hN, Cardinal.natCast_le] at scard\n      have : Cardinal.mk s = Cardinal.mk (Fin N) := by rw [hN, Cardinal.mk_fin]\n      cases' quotient.exact this with E\n      use s, N, scard, E\n      simp only [scover, imp_true_iff]\n  choose s N hN E hs using this\n  -- Define a function `F` taking values in a finite type and associating to `p` enough data\n  -- to reconstruct it up to `ε`, namely the (discretized) distances between elements of `s p`.\n  let M := «expr⌊ ⌋₊» (ε⁻¹ * max C 0)\n  let F : GH_space → Σk : Fin (K n).succ, Fin k → Fin k → Fin M.succ := fun p =>\n    ⟨⟨N p, lt_of_le_of_lt (hN p) (nat.lt_succ_self _)⟩, fun a b =>\n      ⟨min M («expr⌊ ⌋₊» (ε⁻¹ * dist ((E p).symm a) ((E p).symm b))), (min_le_left _ _).trans_lt (nat.lt_succ_self _)⟩⟩\n  refine' ⟨_, _, fun p => F p, _⟩\n  infer_instance\n  -- It remains to show that if `F p = F q`, then `p` and `q` are `ε`-close\n  rintro ⟨p, pt⟩ ⟨q, qt⟩ hpq\n  have Npq : N p = N q := Fin.ext_iff.1 (Sigma.mk.inj_iff.1 hpq).1\n  let Ψ : s p → s q := fun x => (E q).symm (Fin.cast Npq ((E p) x))\n  let Φ : s p → q.rep := fun x => Ψ x\n  have main : GH_dist p.rep q.rep ≤ ε + ε / 2 + ε :=\n    by\n    -- to prove the main inequality, argue that `s p` is `ε`-dense in `p`, and `s q` is `ε`-dense\n    -- in `q`, and `s p` and `s q` are almost isometric. Then closeness follows\n    -- from `GH_dist_le_of_approx_subsets`\n    refine' GH_dist_le_of_approx_subsets Φ _ _ _\n    show ∀ x : p.rep, ∃ (y : p.rep)(H : y ∈ s p), dist x y ≤ ε\n    · -- by construction, `s p` is `ε`-dense\n      intro x\n      have :\n        x ∈\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (ball y (u n)) :=\n        (hs p pt) (mem_univ _)\n      rcases mem_Union₂.1 this with ⟨y, ys, hy⟩\n      exact ⟨y, ys, le_trans (le_of_lt hy) u_le_ε⟩\n    show ∀ x : q.rep, ∃ z : s p, dist x (Φ z) ≤ ε\n    · -- by construction, `s q` is `ε`-dense, and it is the range of `Φ`\n      intro x\n      have :\n        x ∈\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (ball y (u n)) :=\n        (hs q qt) (mem_univ _)\n      rcases mem_Union₂.1 this with ⟨y, ys, hy⟩\n      let i : ℕ := E q ⟨y, ys⟩\n      let hi := ((E q) ⟨y, ys⟩).2\n      have ihi_eq : (⟨i, hi⟩ : Fin (N q)) = (E q) ⟨y, ys⟩ := by rw [Fin.ext_iff, Fin.val_mk]\n      have hiq : i < N q := hi\n      have hip : i < N p := by rwa [Npq.symm] at hiq\n      let z := (E p).symm ⟨i, hip⟩\n      use z\n      have C1 : (E p) z = ⟨i, hip⟩ := (E p).apply_symm_apply ⟨i, hip⟩\n      have C2 : Fin.cast Npq ⟨i, hip⟩ = ⟨i, hi⟩ := rfl\n      have C3 : (E q).symm ⟨i, hi⟩ = ⟨y, ys⟩ := by\n        rw [ihi_eq]\n        exact (E q).symm_apply_apply ⟨y, ys⟩\n      have : Φ z = y := by\n        simp only [Φ, Ψ]\n        rw [C1, C2, C3]\n        rfl\n      rw [this]\n      exact le_trans (le_of_lt hy) u_le_ε\n    show ∀ x y : s p, |dist x y - dist (Φ x) (Φ y)| ≤ ε\n    · /- the distance between `x` and `y` is encoded in `F p`, and the distance between\n            `Φ x` and `Φ y` (two points of `s q`) is encoded in `F q`, all this up to `ε`.\n            As `F p = F q`, the distances are almost equal. -/\n      intro x y\n      have : dist (Φ x) (Φ y) = dist (Ψ x) (Ψ y) := rfl\n      rw [this]\n      -- introduce `i`, that codes both `x` and `Φ x` in `fin (N p) = fin (N q)`\n      let i : ℕ := E p x\n      have hip : i < N p := ((E p) x).2\n      have hiq : i < N q := by rwa [Npq] at hip\n      have i' : i = (E q) (Ψ x) := by simp only [Equiv.apply_symm_apply, Fin.coe_cast]\n      -- introduce `j`, that codes both `y` and `Φ y` in `fin (N p) = fin (N q)`\n      let j : ℕ := E p y\n      have hjp : j < N p := ((E p) y).2\n      have hjq : j < N q := by rwa [Npq] at hjp\n      have j' : j = (E q) (Ψ y) := by simp only [Equiv.apply_symm_apply, Fin.coe_cast]\n      -- Express `dist x y` in terms of `F p`\n      have Ap : ((F p).2 ⟨i, hip⟩ ⟨j, hjp⟩).1 = «expr⌊ ⌋₊» (ε⁻¹ * dist x y) :=\n        calc\n          ((F p).2 ⟨i, hip⟩ ⟨j, hjp⟩).1 = ((F p).2 ((E p) x) ((E p) y)).1 := by congr <;> apply Fin.ext_iff.2 <;> rfl\n          _ = min M («expr⌊ ⌋₊» (ε⁻¹ * dist x y)) := by simp only [F, (E p).symm_apply_apply]\n          _ = «expr⌊ ⌋₊» (ε⁻¹ * dist x y) := by\n            refine' min_eq_right (Nat.floor_mono _)\n            refine' mul_le_mul_of_nonneg_left (le_trans _ (le_max_left _ _)) (inv_pos.2 εpos).le\n            change dist (x : p.rep) y ≤ C\n            refine' le_trans (dist_le_diam_of_mem is_compact_univ.bounded (mem_univ _) (mem_univ _)) _\n            exact hdiam p pt\n          \n      -- Express `dist (Φ x) (Φ y)` in terms of `F q`\n      have Aq : ((F q).2 ⟨i, hiq⟩ ⟨j, hjq⟩).1 = «expr⌊ ⌋₊» (ε⁻¹ * dist (Ψ x) (Ψ y)) :=\n        calc\n          ((F q).2 ⟨i, hiq⟩ ⟨j, hjq⟩).1 = ((F q).2 ((E q) (Ψ x)) ((E q) (Ψ y))).1 := by\n            congr <;> apply Fin.ext_iff.2 <;> [exact i', exact j']\n          _ = min M («expr⌊ ⌋₊» (ε⁻¹ * dist (Ψ x) (Ψ y))) := by simp only [F, (E q).symm_apply_apply]\n          _ = «expr⌊ ⌋₊» (ε⁻¹ * dist (Ψ x) (Ψ y)) :=\n            by\n            refine' min_eq_right (Nat.floor_mono _)\n            refine' mul_le_mul_of_nonneg_left (le_trans _ (le_max_left _ _)) (inv_pos.2 εpos).le\n            change dist (Ψ x : q.rep) (Ψ y) ≤ C\n            refine' le_trans (dist_le_diam_of_mem is_compact_univ.bounded (mem_univ _) (mem_univ _)) _\n            exact hdiam q qt\n          \n      -- use the equality between `F p` and `F q` to deduce that the distances have equal\n      -- integer parts\n      have : ((F p).2 ⟨i, hip⟩ ⟨j, hjp⟩).1 = ((F q).2 ⟨i, hiq⟩ ⟨j, hjq⟩).1 :=\n        by\n        -- we want to `subst hpq` where `hpq : F p = F q`, except that `subst` only works\n        -- with a constant, so replace `F q` (and everything that depends on it) by a constant `f`\n        -- then `subst`\n        revert hiq hjq\n        change N q with (F q).1\n        generalize F q = f at hpq⊢\n        subst hpq\n        intros\n        rfl\n      have : «expr⌊ ⌋» (ε⁻¹ * dist x y) = «expr⌊ ⌋» (ε⁻¹ * dist (Ψ x) (Ψ y)) :=\n        by\n        rw [Ap, Aq] at this\n        have D : 0 ≤ «expr⌊ ⌋» (ε⁻¹ * dist x y) := floor_nonneg.2 (mul_nonneg (le_of_lt (inv_pos.2 εpos)) dist_nonneg)\n        have D' : 0 ≤ «expr⌊ ⌋» (ε⁻¹ * dist (Ψ x) (Ψ y)) :=\n          floor_nonneg.2 (mul_nonneg (le_of_lt (inv_pos.2 εpos)) dist_nonneg)\n        rw [← Int.toNat_of_nonneg D, ← Int.toNat_of_nonneg D', Int.floor_toNat, Int.floor_toNat, this]\n      -- deduce that the distances coincide up to `ε`, by a straightforward computation\n      -- that should be automated\n      have I :=\n        calc\n          |ε⁻¹| * |dist x y - dist (Ψ x) (Ψ y)| = |ε⁻¹ * (dist x y - dist (Ψ x) (Ψ y))| := (abs_mul _ _).symm\n          _ = |ε⁻¹ * dist x y - ε⁻¹ * dist (Ψ x) (Ψ y)| := by\n            congr\n            ring\n          _ ≤ 1 := le_of_lt (abs_sub_lt_one_of_floor_eq_floor this)\n          \n      calc\n        |dist x y - dist (Ψ x) (Ψ y)| = ε * ε⁻¹ * |dist x y - dist (Ψ x) (Ψ y)| := by\n          rw [mul_inv_cancel (ne_of_gt εpos), one_mul]\n        _ = ε * (|ε⁻¹| * |dist x y - dist (Ψ x) (Ψ y)|) := by rw [abs_of_nonneg (le_of_lt (inv_pos.2 εpos)), mul_assoc]\n        _ ≤ ε * 1 := (mul_le_mul_of_nonneg_left I (le_of_lt εpos))\n        _ = ε := mul_one _\n        \n  calc\n    dist p q = GH_dist p.rep q.rep := dist_GH_dist p q\n    _ ≤ ε + ε / 2 + ε := main\n    _ = δ / 2 := by\n      simp only [ε, one_div]\n      ring\n    _ < δ := half_lt_self δpos\n    \n#align totally_bounded TotallyBounded\n-/\n\n",
 "Hausdorff_dist_optimal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/-- The optimal coupling constructed above realizes exactly the Gromov-Hausdorff distance,\nessentially by design. -/\ntheorem Hausdorff_dist_optimal {X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X] {Y : Type v} [MetricSpace Y]\n    [CompactSpace Y] [Nonempty Y] :\n    hausdorffDist (range (optimal_GH_injl X Y)) (range (optimal_GH_injr X Y)) = GH_dist X Y :=\n  by\n  inhabit X\n  inhabit Y\n  /- we only need to check the inequality `≤`, as the other one follows from the previous lemma.\n       As the Gromov-Hausdorff distance is an infimum, we need to check that the Hausdorff distance\n       in the optimal coupling is smaller than the Hausdorff distance of any coupling.\n       First, we check this for couplings which already have small Hausdorff distance: in this\n       case, the induced \"distance\" on `X ⊕ Y` belongs to the candidates family introduced in the\n       definition of the optimal coupling, and the conclusion follows from the optimality\n       of the optimal coupling within this family.\n    -/\n  have A :\n    ∀ p q : nonempty_compacts (exprℓ_infty_ℝ),\n      «expr⟦ ⟧» p = to_GH_space X →\n        «expr⟦ ⟧» q = to_GH_space Y →\n          Hausdorff_dist (p : Set (exprℓ_infty_ℝ)) q < diam (univ : Set X) + 1 + diam (univ : Set Y) →\n            Hausdorff_dist (range (optimal_GH_injl X Y)) (range (optimal_GH_injr X Y)) ≤\n              Hausdorff_dist (p : Set (exprℓ_infty_ℝ)) q :=\n    by\n    intro p q hp hq bound\n    rcases eq_to_GH_space_iff.1 hp with ⟨Φ, ⟨Φisom, Φrange⟩⟩\n    rcases eq_to_GH_space_iff.1 hq with ⟨Ψ, ⟨Ψisom, Ψrange⟩⟩\n    have I : diam (range Φ ∪ range Ψ) ≤ 2 * diam (univ : Set X) + 1 + 2 * diam (univ : Set Y) :=\n      by\n      rcases exists_mem_of_nonempty X with ⟨xX, _⟩\n      have : ∃ y ∈ range Ψ, dist (Φ xX) y < diam (univ : Set X) + 1 + diam (univ : Set Y) :=\n        by\n        rw [Ψrange]\n        have : Φ xX ∈ ↑p := Φrange.subst (mem_range_self _)\n        exact\n          exists_dist_lt_of_Hausdorff_dist_lt this bound\n            (Hausdorff_edist_ne_top_of_nonempty_of_bounded p.nonempty q.nonempty p.is_compact.bounded\n              q.is_compact.bounded)\n      rcases this with ⟨y, hy, dy⟩\n      rcases mem_range.1 hy with ⟨z, hzy⟩\n      rw [← hzy] at dy\n      have DΦ : diam (range Φ) = diam (univ : Set X) := Φisom.diam_range\n      have DΨ : diam (range Ψ) = diam (univ : Set Y) := Ψisom.diam_range\n      calc\n        diam (range Φ ∪ range Ψ) ≤ diam (range Φ) + dist (Φ xX) (Ψ z) + diam (range Ψ) :=\n          diam_union (mem_range_self _) (mem_range_self _)\n        _ ≤ diam (univ : Set X) + (diam (univ : Set X) + 1 + diam (univ : Set Y)) + diam (univ : Set Y) :=\n          by\n          rw [DΦ, DΨ]\n          apply add_le_add (add_le_add le_rfl (le_of_lt dy)) le_rfl\n        _ = 2 * diam (univ : Set X) + 1 + 2 * diam (univ : Set Y) := by ring\n        \n    let f : Sum X Y → exprℓ_infty_ℝ := fun x =>\n      match x with\n      | inl y => Φ y\n      | inr z => Ψ z\n    let F : Sum X Y × Sum X Y → exprℝ := fun p => dist (f p.1) (f p.2)\n    -- check that the induced \"distance\" is a candidate\n    have Fgood : F ∈ candidates X Y :=\n      by\n      simp only [candidates, forall_const, and_true_iff, add_comm, eq_self_iff_true, dist_eq_zero, and_self_iff,\n        Set.mem_setOf_eq]\n      repeat' constructor\n      ·\n        exact fun x y =>\n          calc\n            F (inl x, inl y) = dist (Φ x) (Φ y) := rfl\n            _ = dist x y := Φisom.dist_eq x y\n            \n      ·\n        exact fun x y =>\n          calc\n            F (inr x, inr y) = dist (Ψ x) (Ψ y) := rfl\n            _ = dist x y := Ψisom.dist_eq x y\n            \n      · exact fun x y => dist_comm _ _\n      · exact fun x y z => dist_triangle _ _ _\n      ·\n        exact fun x y =>\n          calc\n            F (x, y) ≤ diam (range Φ ∪ range Ψ) :=\n              by\n              have A : ∀ z : Sum X Y, f z ∈ range Φ ∪ range Ψ :=\n                by\n                intro z\n                cases z\n                · apply mem_union_left\n                  apply mem_range_self\n                · apply mem_union_right\n                  apply mem_range_self\n              refine' dist_le_diam_of_mem _ (A _) (A _)\n              rw [Φrange, Ψrange]\n              exact («expr ⊔ » p q).is_compact.bounded\n            _ ≤ 2 * diam (univ : Set X) + 1 + 2 * diam (univ : Set Y) := I\n            \n    let Fb := candidates_b_of_candidates F Fgood\n    have : Hausdorff_dist (range (optimal_GH_injl X Y)) (range (optimal_GH_injr X Y)) ≤ HD Fb :=\n      Hausdorff_dist_optimal_le_HD _ _ (candidates_b_of_candidates_mem F Fgood)\n    refine' le_trans this (le_of_forall_le_of_dense fun r hr => _)\n    have I1 :\n      ∀ x : X,\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (Fb (inl x, inr y)) ≤\n          r :=\n      by\n      intro x\n      have : f (inl x) ∈ ↑p := Φrange.subst (mem_range_self _)\n      rcases exists_dist_lt_of_Hausdorff_dist_lt this hr\n          (Hausdorff_edist_ne_top_of_nonempty_of_bounded p.nonempty q.nonempty p.is_compact.bounded\n            q.is_compact.bounded) with\n        ⟨z, zq, hz⟩\n      have : z ∈ range Ψ := by rwa [← Ψrange] at zq\n      rcases mem_range.1 this with ⟨y, hy⟩\n      calc\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n              (Fb (inl x, inr y)) ≤\n            Fb (inl x, inr y) :=\n          cinfᵢ_le (by simpa only [add_zero] using HD_below_aux1 0) y\n        _ = dist (Φ x) (Ψ y) := rfl\n        _ = dist (f (inl x)) z := by rw [hy]\n        _ ≤ r := le_of_lt hz\n        \n    have I2 :\n      ∀ y : Y,\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (Fb (inl x, inr y)) ≤\n          r :=\n      by\n      intro y\n      have : f (inr y) ∈ ↑q := Ψrange.subst (mem_range_self _)\n      rcases exists_dist_lt_of_Hausdorff_dist_lt' this hr\n          (Hausdorff_edist_ne_top_of_nonempty_of_bounded p.nonempty q.nonempty p.is_compact.bounded\n            q.is_compact.bounded) with\n        ⟨z, zq, hz⟩\n      have : z ∈ range Φ := by rwa [← Φrange] at zq\n      rcases mem_range.1 this with ⟨x, hx⟩\n      calc\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n              (Fb (inl x, inr y)) ≤\n            Fb (inl x, inr y) :=\n          cinfᵢ_le (by simpa only [add_zero] using HD_below_aux2 0) x\n        _ = dist (Φ x) (Ψ y) := rfl\n        _ = dist z (f (inr y)) := by rw [hx]\n        _ ≤ r := le_of_lt hz\n        \n    simp only [HD, csupᵢ_le I1, csupᵢ_le I2, max_le_iff, and_self_iff]\n  /- Get the same inequality for any coupling. If the coupling is quite good, the desired\n    inequality has been proved above. If it is bad, then the inequality is obvious. -/\n  have B :\n    ∀ p q : nonempty_compacts (exprℓ_infty_ℝ),\n      «expr⟦ ⟧» p = to_GH_space X →\n        «expr⟦ ⟧» q = to_GH_space Y →\n          Hausdorff_dist (range (optimal_GH_injl X Y)) (range (optimal_GH_injr X Y)) ≤\n            Hausdorff_dist (p : Set (exprℓ_infty_ℝ)) q :=\n    by\n    intro p q hp hq\n    by_cases h : Hausdorff_dist (p : Set (exprℓ_infty_ℝ)) q < diam (univ : Set X) + 1 + diam (univ : Set Y)\n    · exact A p q hp hq h\n    ·\n      calc\n        Hausdorff_dist (range (optimal_GH_injl X Y)) (range (optimal_GH_injr X Y)) ≤ HD (candidates_b_dist X Y) :=\n          Hausdorff_dist_optimal_le_HD _ _ candidates_b_dist_mem_candidates_b\n        _ ≤ diam (univ : Set X) + 1 + diam (univ : Set Y) := HD_candidates_b_dist_le\n        _ ≤ Hausdorff_dist (p : Set (exprℓ_infty_ℝ)) q := not_lt.1 h\n        \n  refine' le_antisymm _ _\n  · apply le_cinfₛ\n    · refine' (Set.Nonempty.prod _ _).image _ <;> exact ⟨_, rfl⟩\n    · rintro b ⟨⟨p, q⟩, ⟨hp, hq⟩, rfl⟩\n      exact B p q hp hq\n  · exact GH_dist_le_Hausdorff_dist (isometry_optimal_GH_injl X Y) (isometry_optimal_GH_injr X Y)\n#align Hausdorff_dist_optimal Hausdorff_dist_optimal\n\n",
 "GH_dist_le_of_approx_subsets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- In this section, we show that if two metric spaces are isometric up to `ε₂`, then their\nGromov-Hausdorff distance is bounded by `ε₂ / 2`. More generally, if there are subsets which are\n`ε₁`-dense and `ε₃`-dense in two spaces, and isometric up to `ε₂`, then the Gromov-Hausdorff\ndistance between the spaces is bounded by `ε₁ + ε₂/2 + ε₃`. For this, we construct a suitable\ncoupling between the two spaces, by gluing them (approximately) along the two matching subsets. -/\n-- we want to ignore these instances in the following theorem\n/-- If there are subsets which are `ε₁`-dense and `ε₃`-dense in two spaces, and\nisometric up to `ε₂`, then the Gromov-Hausdorff distance between the spaces is bounded by\n`ε₁ + ε₂/2 + ε₃`. -/\ntheorem GH_dist_le_of_approx_subsets {s : Set X} (Φ : s → Y) {ε₁ ε₂ ε₃ : exprℝ} (hs : ∀ x : X, ∃ y ∈ s, dist x y ≤ ε₁)\n    (hs' : ∀ x : Y, ∃ y : s, dist x (Φ y) ≤ ε₃) (H : ∀ x y : s, |dist x y - dist (Φ x) (Φ y)| ≤ ε₂) :\n    GH_dist X Y ≤ ε₁ + ε₂ / 2 + ε₃ :=\n  by\n  refine' le_of_forall_pos_le_add fun δ δ0 => _\n  rcases exists_mem_of_nonempty X with ⟨xX, _⟩\n  rcases hs xX with ⟨xs, hxs, Dxs⟩\n  have sne : s.nonempty := ⟨xs, hxs⟩\n  letI : Nonempty s := sne.to_subtype\n  have : 0 ≤ ε₂ := le_trans (abs_nonneg _) (H ⟨xs, hxs⟩ ⟨xs, hxs⟩)\n  have : ∀ p q : s, |dist p q - dist (Φ p) (Φ q)| ≤ 2 * (ε₂ / 2 + δ) := fun p q =>\n    calc\n      |dist p q - dist (Φ p) (Φ q)| ≤ ε₂ := H p q\n      _ ≤ 2 * (ε₂ / 2 + δ) := by linarith\n      \n  -- glue `X` and `Y` along the almost matching subsets\n  letI : MetricSpace (Sum X Y) :=\n    glue_metric_approx (fun x : s => (x : X)) (fun x => Φ x) (ε₂ / 2 + δ) (by linarith) this\n  let Fl := @Sum.inl X Y\n  let Fr := @Sum.inr X Y\n  have Il : Isometry Fl := Isometry.of_dist_eq fun x y => rfl\n  have Ir : Isometry Fr := Isometry.of_dist_eq fun x y => rfl\n  /- The proof goes as follows : the `GH_dist` is bounded by the Hausdorff distance of the images\n    in the coupling, which is bounded (using the triangular inequality) by the sum of the Hausdorff\n    distances of `X` and `s` (in the coupling or, equivalently in the original space), of `s` and\n    `Φ s`, and of `Φ s` and `Y` (in the coupling or, equivalently, in the original space). The first\n    term is bounded by `ε₁`, by `ε₁`-density. The third one is bounded by `ε₃`. And the middle one is\n    bounded by `ε₂/2` as in the coupling the points `x` and `Φ x` are at distance `ε₂/2` by\n    construction of the coupling (in fact `ε₂/2 + δ` where `δ` is an arbitrarily small positive\n    constant where positivity is used to ensure that the coupling is really a metric space and not a\n    premetric space on `X ⊕ Y`). -/\n  have : GH_dist X Y ≤ Hausdorff_dist (range Fl) (range Fr) := GH_dist_le_Hausdorff_dist Il Ir\n  have :\n    Hausdorff_dist (range Fl) (range Fr) ≤\n      Hausdorff_dist (range Fl) («expr '' » Fl s) + Hausdorff_dist («expr '' » Fl s) (range Fr) :=\n    haveI B : bounded (range Fl) := (isCompact_range Il.continuous).bounded\n    Hausdorff_dist_triangle\n      (Hausdorff_edist_ne_top_of_nonempty_of_bounded (range_nonempty _) (sne.image _) B\n        (B.mono (image_subset_range _ _)))\n  have :\n    Hausdorff_dist («expr '' » Fl s) (range Fr) ≤\n      Hausdorff_dist («expr '' » Fl s) («expr '' » Fr (range Φ)) +\n        Hausdorff_dist («expr '' » Fr (range Φ)) (range Fr) :=\n    haveI B : bounded (range Fr) := (isCompact_range Ir.continuous).bounded\n    Hausdorff_dist_triangle'\n      (Hausdorff_edist_ne_top_of_nonempty_of_bounded ((range_nonempty _).image _) (range_nonempty _)\n        (bounded.mono (image_subset_range _ _) B) B)\n  have : Hausdorff_dist (range Fl) («expr '' » Fl s) ≤ ε₁ :=\n    by\n    rw [← image_univ, Hausdorff_dist_image Il]\n    have : 0 ≤ ε₁ := le_trans dist_nonneg Dxs\n    refine'\n      Hausdorff_dist_le_of_mem_dist this (fun x hx => hs x) fun x hx => ⟨x, mem_univ _, by simpa only [dist_self] ⟩\n  have : Hausdorff_dist («expr '' » Fl s) («expr '' » Fr (range Φ)) ≤ ε₂ / 2 + δ :=\n    by\n    refine' Hausdorff_dist_le_of_mem_dist (by linarith) _ _\n    · intro x' hx'\n      rcases(Set.mem_image _ _ _).1 hx' with ⟨x, ⟨x_in_s, xx'⟩⟩\n      rw [← xx']\n      use Fr (Φ ⟨x, x_in_s⟩), mem_image_of_mem Fr (mem_range_self _)\n      exact le_of_eq (glue_dist_glued_points (fun x : s => (x : X)) Φ (ε₂ / 2 + δ) ⟨x, x_in_s⟩)\n    · intro x' hx'\n      rcases(Set.mem_image _ _ _).1 hx' with ⟨y, ⟨y_in_s', yx'⟩⟩\n      rcases mem_range.1 y_in_s' with ⟨x, xy⟩\n      use Fl x, mem_image_of_mem _ x.2\n      rw [← yx', ← xy, dist_comm]\n      exact le_of_eq (glue_dist_glued_points (@Subtype.val X s) Φ (ε₂ / 2 + δ) x)\n  have : Hausdorff_dist («expr '' » Fr (range Φ)) (range Fr) ≤ ε₃ :=\n    by\n    rw [← @image_univ _ _ Fr, Hausdorff_dist_image Ir]\n    rcases exists_mem_of_nonempty Y with ⟨xY, _⟩\n    rcases hs' xY with ⟨xs', Dxs'⟩\n    have : 0 ≤ ε₃ := le_trans dist_nonneg Dxs'\n    refine' Hausdorff_dist_le_of_mem_dist this (fun x hx => ⟨x, mem_univ _, by simpa only [dist_self] ⟩) fun x _ => _\n    rcases hs' x with ⟨y, Dy⟩\n    exact ⟨Φ y, mem_range_self _, Dy⟩\n  linarith\n#align GH_dist_le_of_approx_subsets GH_dist_le_of_approx_subsets\n\n",
 "GH_dist_le_nonempty_compacts_dist":
 "/- To show that two spaces at zero distance are isometric, we argue that the distance\n    is realized by some coupling. In this coupling, the two spaces are at zero Hausdorff distance,\n    i.e., they coincide. Therefore, the original spaces are isometric. -/\n/- To show the triangular inequality between `X`, `Y` and `Z`, realize an optimal coupling\n    between `X` and `Y` in a space `γ1`, and an optimal coupling between `Y` and `Z` in a space\n    `γ2`. Then, glue these metric spaces along `Y`. We get a new space `γ` in which `X` and `Y` are\n    optimally coupled, as well as `Y` and `Z`. Apply the triangle inequality for the Hausdorff\n    distance in `γ` to conclude. -/\n--section\ntheorem GH_dist_le_nonempty_compacts_dist (p q : NonemptyCompacts X) : dist p.to_GH_space q.to_GH_space ≤ dist p q :=\n  by\n  have ha : Isometry (coe : p → X) := isometry_subtype_coe\n  have hb : Isometry (coe : q → X) := isometry_subtype_coe\n  have A : dist p q = Hausdorff_dist (p : Set X) q := rfl\n  have I : ↑p = range (coe : p → X) := subtype.range_coe_subtype.symm\n  have J : ↑q = range (coe : q → X) := subtype.range_coe_subtype.symm\n  rw [A, I, J]\n  exact GH_dist_le_Hausdorff_dist ha hb\n#align GH_dist_le_nonempty_compacts_dist GH_dist_le_nonempty_compacts_dist\n\n",
 "GH_dist_le_Hausdorff_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/-- The Gromov-Hausdorff distance between two spaces is bounded by the Hausdorff distance\nof isometric copies of the spaces, in any metric space. -/\ntheorem GH_dist_le_Hausdorff_dist {X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X] {Y : Type v}\n    [MetricSpace Y] [CompactSpace Y] [Nonempty Y] {γ : Type w} [MetricSpace γ] {Φ : X → γ} {Ψ : Y → γ} (ha : Isometry Φ)\n    (hb : Isometry Ψ) : GH_dist X Y ≤ hausdorffDist (range Φ) (range Ψ) :=\n  by\n  /- For the proof, we want to embed `γ` in `ℓ^∞(ℝ)`, to say that the Hausdorff distance is realized\n    in `ℓ^∞(ℝ)` and therefore bounded below by the Gromov-Hausdorff-distance. However, `γ` is not\n    separable in general. We restrict to the union of the images of `X` and `Y` in `γ`, which is\n    separable and therefore embeddable in `ℓ^∞(ℝ)`. -/\n  rcases exists_mem_of_nonempty X with ⟨xX, _⟩\n  let s : Set γ := range Φ ∪ range Ψ\n  let Φ' : X → Subtype s := fun y => ⟨Φ y, mem_union_left _ (mem_range_self _)⟩\n  let Ψ' : Y → Subtype s := fun y => ⟨Ψ y, mem_union_right _ (mem_range_self _)⟩\n  have IΦ' : Isometry Φ' := fun x y => ha x y\n  have IΨ' : Isometry Ψ' := fun x y => hb x y\n  have : IsCompact s := (isCompact_range ha.continuous).union (isCompact_range hb.continuous)\n  letI : MetricSpace (Subtype s) := by infer_instance\n  haveI : CompactSpace (Subtype s) := ⟨isCompact_iff_isCompact_univ.1 ‹IsCompact s›⟩\n  haveI : Nonempty (Subtype s) := ⟨Φ' xX⟩\n  have ΦΦ' : Φ = Subtype.val ∘ Φ' := by\n    funext\n    rfl\n  have ΨΨ' : Ψ = Subtype.val ∘ Ψ' := by\n    funext\n    rfl\n  have : Hausdorff_dist (range Φ) (range Ψ) = Hausdorff_dist (range Φ') (range Ψ') :=\n    by\n    rw [ΦΦ', ΨΨ', range_comp, range_comp]\n    exact Hausdorff_dist_image isometry_subtype_coe\n  rw [this]\n  -- Embed `s` in `ℓ^∞(ℝ)` through its Kuratowski embedding\n  let F := Kuratowski_embedding (Subtype s)\n  have : Hausdorff_dist («expr '' » F (range Φ')) («expr '' » F (range Ψ')) = Hausdorff_dist (range Φ') (range Ψ') :=\n    Hausdorff_dist_image (Kuratowski_embedding.isometry _)\n  rw [← this]\n  -- Let `A` and `B` be the images of `X` and `Y` under this embedding. They are in `ℓ^∞(ℝ)`, and\n  -- their Hausdorff distance is the same as in the original space.\n  let A : nonempty_compacts (exprℓ_infty_ℝ) :=\n    ⟨⟨«expr '' » F (range Φ'), (isCompact_range IΦ'.continuous).image (Kuratowski_embedding.isometry _).continuous⟩,\n      (range_nonempty _).image _⟩\n  let B : nonempty_compacts (exprℓ_infty_ℝ) :=\n    ⟨⟨«expr '' » F (range Ψ'), (isCompact_range IΨ'.continuous).image (Kuratowski_embedding.isometry _).continuous⟩,\n      (range_nonempty _).image _⟩\n  have AX : «expr⟦ ⟧» A = to_GH_space X := by\n    rw [eq_to_GH_space_iff]\n    exact ⟨fun x => F (Φ' x), (Kuratowski_embedding.isometry _).comp IΦ', range_comp _ _⟩\n  have BY : «expr⟦ ⟧» B = to_GH_space Y := by\n    rw [eq_to_GH_space_iff]\n    exact ⟨fun x => F (Ψ' x), (Kuratowski_embedding.isometry _).comp IΨ', range_comp _ _⟩\n  refine' cinfₛ_le ⟨0, _⟩ _\n  · simp only [lowerBounds, mem_image, mem_prod, mem_set_of_eq, Prod.exists, and_imp, forall_exists_index]\n    intro t _ _ _ _ ht\n    rw [← ht]\n    exact Hausdorff_dist_nonneg\n  apply (mem_image _ _ _).2\n  exists (⟨A, B⟩ : nonempty_compacts (exprℓ_infty_ℝ) × nonempty_compacts (exprℓ_infty_ℝ))\n  simp [AX, BY]\n#align GH_dist_le_Hausdorff_dist GH_dist_le_Hausdorff_dist\n\n",
 "GH_dist_eq_Hausdorff_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℓ_infty_ℝ -/\n/-- The Gromov-Hausdorff distance can also be realized by a coupling in `ℓ^∞(ℝ)`, by embedding\nthe optimal coupling through its Kuratowski embedding. -/\ntheorem GH_dist_eq_Hausdorff_dist (X : Type u) [MetricSpace X] [CompactSpace X] [Nonempty X] (Y : Type v)\n    [MetricSpace Y] [CompactSpace Y] [Nonempty Y] :\n    ∃ Φ : X → exprℓ_infty_ℝ,\n      ∃ Ψ : Y → exprℓ_infty_ℝ, Isometry Φ ∧ Isometry Ψ ∧ GH_dist X Y = hausdorffDist (range Φ) (range Ψ) :=\n  by\n  let F := Kuratowski_embedding (optimal_GH_coupling X Y)\n  let Φ := F ∘ optimal_GH_injl X Y\n  let Ψ := F ∘ optimal_GH_injr X Y\n  refine' ⟨Φ, Ψ, _, _, _⟩\n  · exact (Kuratowski_embedding.isometry _).comp (isometry_optimal_GH_injl X Y)\n  · exact (Kuratowski_embedding.isometry _).comp (isometry_optimal_GH_injr X Y)\n  · rw [← image_univ, ← image_univ, image_comp F, image_univ, image_comp F (optimal_GH_injr X Y), image_univ, ←\n      Hausdorff_dist_optimal]\n    exact (Hausdorff_dist_image (Kuratowski_embedding.isometry _)).symm\n#align GH_dist_eq_Hausdorff_dist GH_dist_eq_Hausdorff_dist\n\n"}