{"to_inductive_limit_isometry":
 "/-- The map `to_inductive_limit n` mapping `X n` to the inductive limit is an isometry. -/\ntheorem to_inductive_limit_isometry (I : ∀ n, Isometry (f n)) (n : ℕ) : Isometry (toInductiveLimit I n) :=\n  Isometry.of_dist_eq fun x y => by\n    change inductive_limit_dist f ⟨n, x⟩ ⟨n, y⟩ = dist x y\n    rw [inductive_limit_dist_eq_dist I ⟨n, x⟩ ⟨n, y⟩ n (le_refl n) (le_refl n), le_rec_on_self, le_rec_on_self]\n#align to_inductive_limit_isometry to_inductive_limit_isometry\n\n",
 "to_inductive_limit_commute":
 "/-- The maps `to_inductive_limit n` are compatible with the maps `f n`. -/\ntheorem to_inductive_limit_commute (I : ∀ n, Isometry (f n)) (n : ℕ) :\n    toInductiveLimit I n.succ ∘ f n = toInductiveLimit I n :=\n  by\n  letI := inductive_premetric I\n  funext\n  simp only [comp, to_inductive_limit]\n  refine' UniformSpace.SeparationQuotient.mk_eq_mk.2 (Metric.inseparable_iff.2 _)\n  show inductive_limit_dist f ⟨n.succ, f n x⟩ ⟨n, x⟩ = 0\n  · rw [inductive_limit_dist_eq_dist I ⟨n.succ, f n x⟩ ⟨n, x⟩ n.succ, le_rec_on_self, le_rec_on_succ, le_rec_on_self,\n      dist_self]\n    exact le_rfl\n    exact le_rfl\n    exact le_succ _\n#align to_inductive_limit_commute to_inductive_limit_commute\n\n",
 "to_glue_r_isometry":
 "theorem to_glue_r_isometry (hΦ : Isometry Φ) (hΨ : Isometry Ψ) : Isometry (toGlueR hΦ hΨ) :=\n  Isometry.of_dist_eq fun _ _ => rfl\n#align to_glue_r_isometry to_glue_r_isometry\n\n",
 "to_glue_l_isometry":
 "theorem to_glue_l_isometry (hΦ : Isometry Φ) (hΨ : Isometry Ψ) : Isometry (toGlueL hΦ hΨ) :=\n  Isometry.of_dist_eq fun _ _ => rfl\n#align to_glue_l_isometry to_glue_l_isometry\n\n",
 "to_glue_commute":
 "-- Exact gluing of two metric spaces along isometric subsets.\ntheorem to_glue_commute (hΦ : Isometry Φ) (hΨ : Isometry Ψ) : toGlueL hΦ hΨ ∘ Φ = toGlueR hΦ hΨ ∘ Ψ :=\n  by\n  letI i : PseudoMetricSpace (Sum X Y) := glue_premetric hΦ hΨ\n  letI := i.to_uniform_space\n  funext\n  simp only [comp, to_glue_l, to_glue_r]\n  refine' UniformSpace.SeparationQuotient.mk_eq_mk.2 (Metric.inseparable_iff.2 _)\n  exact glue_dist_glued_points Φ Ψ 0 x\n#align to_glue_commute to_glue_commute\n\n",
 "one_le_dist_of_ne":
 "theorem one_le_dist_of_ne {i j : ι} (h : i ≠ j) (x : E i) (y : E j) : 1 ≤ dist (⟨i, x⟩ : Σk, E k) ⟨j, y⟩ :=\n  by\n  rw [sigma.dist_ne h x y]\n  linarith [@dist_nonneg _ _ x (Nonempty.some ⟨x⟩), @dist_nonneg _ _ (Nonempty.some ⟨y⟩) y]\n#align one_le_dist_of_ne one_le_dist_of_ne\n\n",
 "one_dist_le'":
 "theorem sum.one_dist_le' {x : X} {y : Y} : 1 ≤ Sum.dist (inr y) (inl x) := by\n  rw [sum.dist_comm] <;> exact sum.one_dist_le\n#align sum.one_dist_le' sum.one_dist_le'\n\n",
 "one_dist_le":
 "theorem sum.one_dist_le {x : X} {y : Y} : 1 ≤ Sum.dist (inl x) (inr y) :=\n  le_trans (le_add_of_nonneg_right dist_nonneg) <| add_le_add_right (le_add_of_nonneg_left dist_nonneg) _\n#align sum.one_dist_le sum.one_dist_le\n\n",
 "mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\nprivate theorem sum.mem_uniformity (s : Set (Sum X Y × Sum X Y)) :\n    s ∈ (uniformity) (Sum X Y) ↔ ∃ ε > 0, ∀ a b, Sum.dist a b < ε → (a, b) ∈ s :=\n  by\n  constructor\n  · rintro ⟨hsX, hsY⟩\n    rcases mem_uniformity_dist.1 hsX with ⟨εX, εX0, hX⟩\n    rcases mem_uniformity_dist.1 hsY with ⟨εY, εY0, hY⟩\n    refine' ⟨min (min εX εY) 1, lt_min (lt_min εX0 εY0) zero_lt_one, _⟩\n    rintro (a | a) (b | b) h\n    · exact hX (lt_of_lt_of_le h (le_trans (min_le_left _ _) (min_le_left _ _)))\n    · cases not_le_of_lt (lt_of_lt_of_le h (min_le_right _ _)) sum.one_dist_le\n    · cases not_le_of_lt (lt_of_lt_of_le h (min_le_right _ _)) sum.one_dist_le'\n    · exact hY (lt_of_lt_of_le h (le_trans (min_le_left _ _) (min_le_right _ _)))\n  · rintro ⟨ε, ε0, H⟩\n    constructor <;> rw [Filter.mem_sets, Filter.mem_map, mem_uniformity_dist] <;> exact ⟨ε, ε0, fun x y h => H _ _ h⟩\n#align sum.mem_uniformity sum.mem_uniformity\n\n",
 "isometry_mk":
 "/-- The injection of a space in a disjoint union is an isometry -/\ntheorem isometry_mk (i : ι) : Isometry (sigma.mk i : E i → Σk, E k) :=\n  Isometry.of_dist_eq fun x y => by simp\n#align isometry_mk isometry_mk\n\n",
 "isometry_inr":
 "/-- The right injection of a space in a disjoint union is an isometry -/\ntheorem isometry_inr : Isometry (Sum.inr : Y → Sum X Y) :=\n  Isometry.of_dist_eq fun x y => rfl\n#align isometry_inr isometry_inr\n\n",
 "isometry_inl":
 "/-- The left injection of a space in a disjoint union is an isometry -/\ntheorem isometry_inl : Isometry (Sum.inl : X → Sum X Y) :=\n  Isometry.of_dist_eq fun x y => rfl\n#align isometry_inl isometry_inl\n\n",
 "is_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprotected theorem is_open_iff (s : Set (Σi, E i)) : IsOpen s ↔ ∀ x ∈ s, ∃ ε > 0, ∀ y, dist x y < ε → y ∈ s :=\n  by\n  constructor\n  · rintro hs ⟨i, x⟩ hx\n    obtain ⟨ε, εpos, hε⟩ : ∃ (ε : exprℝ)(H : ε > 0), ball x ε ⊆ «expr ⁻¹' » (sigma.mk i) s :=\n      Metric.isOpen_iff.1 (isOpen_sigma_iff.1 hs i) x hx\n    refine' ⟨min ε 1, lt_min εpos zero_lt_one, _⟩\n    rintro ⟨j, y⟩ hy\n    rcases eq_or_ne i j with (rfl | hij)\n    · simp only [sigma.dist_same, lt_min_iff] at hy\n      exact hε (mem_ball'.2 hy.1)\n    · apply (lt_irrefl (1 : exprℝ) _).elim\n      calc\n        1 ≤ sigma.dist ⟨i, x⟩ ⟨j, y⟩ := sigma.one_le_dist_of_ne hij _ _\n        _ < 1 := hy.trans_le (min_le_right _ _)\n        \n  · intro H\n    apply isOpen_sigma_iff.2 fun i => _\n    apply Metric.isOpen_iff.2 fun x hx => _\n    obtain ⟨ε, εpos, hε⟩ : ∃ (ε : exprℝ)(H : ε > 0), ∀ y, dist (⟨i, x⟩ : Σj, E j) y < ε → y ∈ s := H ⟨i, x⟩ hx\n    refine' ⟨ε, εpos, fun y hy => _⟩\n    apply hε ⟨i, y⟩\n    rw [sigma.dist_same]\n    exact mem_ball'.1 hy\n#align is_open_iff is_open_iff\n\n",
 "inductive_limit_dist_eq_dist":
 "--section\n/- In this section, we define the inductive limit of\n     f 0        f 1        f 2        f 3\nX 0 -----> X 1 -----> X 2 -----> X 3 -----> ...\nwhere the X n are metric spaces and f n isometric embeddings. We do it by defining a premetric\nspace structure on Σ n, X n, where the predistance dist x y is obtained by pushing x and y in a\ncommon X k using composition by the f n, and taking the distance there. This does not depend on\nthe choice of k as the f n are isometries. The metric space associated to this premetric space\nis the desired inductive limit.-/\n/-- The predistance on the disjoint union `Σ n, X n` can be computed in any `X k` for large\nenough `k`. -/\ntheorem inductive_limit_dist_eq_dist (I : ∀ n, Isometry (f n)) (x y : Σn, X n) (m : ℕ) :\n    ∀ hx : x.1 ≤ m, ∀ hy : y.1 ≤ m, inductiveLimitDist f x y = dist (leRecOn hx f x.2 : X m) (leRecOn hy f y.2 : X m) :=\n  by\n  induction' m with m hm\n  · intro hx hy\n    have A : max x.1 y.1 = 0 := by\n      rw [nonpos_iff_eq_zero.1 hx, nonpos_iff_eq_zero.1 hy]\n      simp\n    unfold inductive_limit_dist\n    congr <;> simp only [A]\n  · intro hx hy\n    by_cases h : max x.1 y.1 = m.succ\n    · unfold inductive_limit_dist\n      congr <;> simp only [h]\n    · have : max x.1 y.1 ≤ succ m := by simp [hx, hy]\n      have : max x.1 y.1 ≤ m := by simpa [h] using of_le_succ this\n      have xm : x.1 ≤ m := le_trans (le_max_left _ _) this\n      have ym : y.1 ≤ m := le_trans (le_max_right _ _) this\n      rw [le_rec_on_succ xm, le_rec_on_succ ym, (I m).dist_eq]\n      exact hm xm ym\n#align inductive_limit_dist_eq_dist inductive_limit_dist_eq_dist\n\n",
 "glue_eq_of_dist_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprivate theorem glue_eq_of_dist_eq_zero (Φ : Z → X) (Ψ : Z → Y) (ε : exprℝ) (ε0 : 0 < ε) :\n    ∀ p q : Sum X Y, glueDist Φ Ψ ε p q = 0 → p = q\n  | inl x, inl y, h => by rw [eq_of_dist_eq_zero h]\n  | inl x, inr y, h =>\n    by\n    have :\n      0 ≤\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (dist x (Φ p) + dist y (Ψ p)) :=\n      le_cinfᵢ fun p => by simpa using add_le_add (@dist_nonneg _ _ x _) (@dist_nonneg _ _ y _)\n    have : 0 + ε ≤ glue_dist Φ Ψ ε (inl x) (inr y) := add_le_add this (le_refl ε)\n    exfalso\n    linarith\n  | inr x, inl y, h =>\n    by\n    have :\n      0 ≤\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (dist y (Φ p) + dist x (Ψ p)) :=\n      le_cinfᵢ fun p => by simpa [add_comm] using add_le_add (@dist_nonneg _ _ x _) (@dist_nonneg _ _ y _)\n    have : 0 + ε ≤ glue_dist Φ Ψ ε (inr x) (inl y) := add_le_add this (le_refl ε)\n    exfalso\n    linarith\n  | inr x, inr y, h => by rw [eq_of_dist_eq_zero h]\n#align glue_eq_of_dist_eq_zero glue_eq_of_dist_eq_zero\n\n",
 "glue_dist_triangle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprivate theorem glue_dist_triangle (Φ : Z → X) (Ψ : Z → Y) (ε : exprℝ)\n    (H : ∀ p q, |dist (Φ p) (Φ q) - dist (Ψ p) (Ψ q)| ≤ 2 * ε) :\n    ∀ x y z, glueDist Φ Ψ ε x z ≤ glueDist Φ Ψ ε x y + glueDist Φ Ψ ε y z\n  | inl x, inl y, inl z => dist_triangle _ _ _\n  | inr x, inr y, inr z => dist_triangle _ _ _\n  | inr x, inl y, inl z =>\n    by\n    have B : ∀ a b, BddBelow (range fun p : Z => dist a (Φ p) + dist b (Ψ p)) := fun a b =>\n      ⟨0, forall_range_iff.2 fun p => add_nonneg dist_nonneg dist_nonneg⟩\n    unfold glue_dist\n    have :\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (dist z (Φ p) + dist x (Ψ p)) ≤\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (dist y (Φ p) + dist x (Ψ p)) +\n          dist y z :=\n      by\n      have :\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n              (dist y (Φ p) + dist x (Ψ p)) +\n            dist y z =\n          infᵢ ((fun t => t + dist y z) ∘ fun p => dist y (Φ p) + dist x (Ψ p)) :=\n        by\n        refine' Monotone.map_cinfᵢ_of_continuousAt (continuous_at_id.add continuousAt_const) _ (B _ _)\n        intro x y hx\n        simpa\n      rw [this, comp]\n      refine' cinfᵢ_mono (B _ _) fun p => _\n      calc\n        dist z (Φ p) + dist x (Ψ p) ≤ dist y z + dist y (Φ p) + dist x (Ψ p) :=\n          add_le_add (dist_triangle_left _ _ _) le_rfl\n        _ = dist y (Φ p) + dist x (Ψ p) + dist y z := by ring\n        \n    linarith\n  | inr x, inr y, inl z =>\n    by\n    have B : ∀ a b, BddBelow (range fun p : Z => dist a (Φ p) + dist b (Ψ p)) := fun a b =>\n      ⟨0, forall_range_iff.2 fun p => add_nonneg dist_nonneg dist_nonneg⟩\n    unfold glue_dist\n    have :\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (dist z (Φ p) + dist x (Ψ p)) ≤\n        dist x y +\n          «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (dist z (Φ p) + dist y (Ψ p)) :=\n      by\n      have :\n        dist x y +\n            «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n              (dist z (Φ p) + dist y (Ψ p)) =\n          infᵢ ((fun t => dist x y + t) ∘ fun p => dist z (Φ p) + dist y (Ψ p)) :=\n        by\n        refine' Monotone.map_cinfᵢ_of_continuousAt (continuous_at_const.add continuousAt_id) _ (B _ _)\n        intro x y hx\n        simpa\n      rw [this, comp]\n      refine' cinfᵢ_mono (B _ _) fun p => _\n      calc\n        dist z (Φ p) + dist x (Ψ p) ≤ dist z (Φ p) + (dist x y + dist y (Ψ p)) :=\n          add_le_add le_rfl (dist_triangle _ _ _)\n        _ = dist x y + (dist z (Φ p) + dist y (Ψ p)) := by ring\n        \n    linarith\n  | inl x, inl y, inr z =>\n    by\n    have B : ∀ a b, BddBelow (range fun p : Z => dist a (Φ p) + dist b (Ψ p)) := fun a b =>\n      ⟨0, forall_range_iff.2 fun p => add_nonneg dist_nonneg dist_nonneg⟩\n    unfold glue_dist\n    have :\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (dist x (Φ p) + dist z (Ψ p)) ≤\n        dist x y +\n          «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (dist y (Φ p) + dist z (Ψ p)) :=\n      by\n      have :\n        dist x y +\n            «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n              (dist y (Φ p) + dist z (Ψ p)) =\n          infᵢ ((fun t => dist x y + t) ∘ fun p => dist y (Φ p) + dist z (Ψ p)) :=\n        by\n        refine' Monotone.map_cinfᵢ_of_continuousAt (continuous_at_const.add continuousAt_id) _ (B _ _)\n        intro x y hx\n        simpa\n      rw [this, comp]\n      refine' cinfᵢ_mono (B _ _) fun p => _\n      calc\n        dist x (Φ p) + dist z (Ψ p) ≤ dist x y + dist y (Φ p) + dist z (Ψ p) := add_le_add (dist_triangle _ _ _) le_rfl\n        _ = dist x y + (dist y (Φ p) + dist z (Ψ p)) := by ring\n        \n    linarith\n  | inl x, inr y, inr z =>\n    by\n    have B : ∀ a b, BddBelow (range fun p : Z => dist a (Φ p) + dist b (Ψ p)) := fun a b =>\n      ⟨0, forall_range_iff.2 fun p => add_nonneg dist_nonneg dist_nonneg⟩\n    unfold glue_dist\n    have :\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (dist x (Φ p) + dist z (Ψ p)) ≤\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (dist x (Φ p) + dist y (Ψ p)) +\n          dist y z :=\n      by\n      have :\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n              (dist x (Φ p) + dist y (Ψ p)) +\n            dist y z =\n          infᵢ ((fun t => t + dist y z) ∘ fun p => dist x (Φ p) + dist y (Ψ p)) :=\n        by\n        refine' Monotone.map_cinfᵢ_of_continuousAt (continuous_at_id.add continuousAt_const) _ (B _ _)\n        intro x y hx\n        simpa\n      rw [this, comp]\n      refine' cinfᵢ_mono (B _ _) fun p => _\n      calc\n        dist x (Φ p) + dist z (Ψ p) ≤ dist x (Φ p) + (dist y z + dist y (Ψ p)) :=\n          add_le_add le_rfl (dist_triangle_left _ _ _)\n        _ = dist x (Φ p) + dist y (Ψ p) + dist y z := by ring\n        \n    linarith\n  | inl x, inr y, inl z =>\n    le_of_forall_pos_le_add fun δ δpos =>\n      by\n      obtain ⟨p, hp⟩ :\n        ∃ p,\n          dist x (Φ p) + dist y (Ψ p) <\n            «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n                (dist x (Φ p) + dist y (Ψ p)) +\n              δ / 2\n      exact exists_lt_of_cinfᵢ_lt (by linarith)\n      obtain ⟨q, hq⟩ :\n        ∃ q,\n          dist z (Φ q) + dist y (Ψ q) <\n            «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n                (dist z (Φ p) + dist y (Ψ p)) +\n              δ / 2\n      exact exists_lt_of_cinfᵢ_lt (by linarith)\n      have : dist (Φ p) (Φ q) ≤ dist (Ψ p) (Ψ q) + 2 * ε :=\n        by\n        have := le_trans (le_abs_self _) (H p q)\n        · linarith\n      calc\n        dist x z ≤ dist x (Φ p) + dist (Φ p) (Φ q) + dist (Φ q) z := dist_triangle4 _ _ _ _\n        _ ≤ dist x (Φ p) + dist (Ψ p) (Ψ q) + dist z (Φ q) + 2 * ε := by rw [dist_comm z] <;> linarith\n        _ ≤ dist x (Φ p) + (dist y (Ψ p) + dist y (Ψ q)) + dist z (Φ q) + 2 * ε :=\n          (add_le_add (add_le_add (add_le_add le_rfl (dist_triangle_left _ _ _)) le_rfl) le_rfl)\n        _ ≤\n            «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n                    (dist x (Φ p) + dist y (Ψ p)) +\n                  ε +\n                («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n                    (dist z (Φ p) + dist y (Ψ p)) +\n                  ε) +\n              δ :=\n          by linarith\n        \n  | inr x, inl y, inr z =>\n    le_of_forall_pos_le_add fun δ δpos =>\n      by\n      obtain ⟨p, hp⟩ :\n        ∃ p,\n          dist y (Φ p) + dist x (Ψ p) <\n            «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n                (dist y (Φ p) + dist x (Ψ p)) +\n              δ / 2\n      exact exists_lt_of_cinfᵢ_lt (by linarith)\n      obtain ⟨q, hq⟩ :\n        ∃ q,\n          dist y (Φ q) + dist z (Ψ q) <\n            «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n                (dist y (Φ p) + dist z (Ψ p)) +\n              δ / 2\n      exact exists_lt_of_cinfᵢ_lt (by linarith)\n      have : dist (Ψ p) (Ψ q) ≤ dist (Φ p) (Φ q) + 2 * ε :=\n        by\n        have := le_trans (neg_le_abs_self _) (H p q)\n        · linarith\n      calc\n        dist x z ≤ dist x (Ψ p) + dist (Ψ p) (Ψ q) + dist (Ψ q) z := dist_triangle4 _ _ _ _\n        _ ≤ dist x (Ψ p) + dist (Φ p) (Φ q) + dist z (Ψ q) + 2 * ε := by rw [dist_comm z] <;> linarith\n        _ ≤ dist x (Ψ p) + (dist y (Φ p) + dist y (Φ q)) + dist z (Ψ q) + 2 * ε :=\n          (add_le_add (add_le_add (add_le_add le_rfl (dist_triangle_left _ _ _)) le_rfl) le_rfl)\n        _ ≤\n            «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n                    (dist y (Φ p) + dist x (Ψ p)) +\n                  ε +\n                («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n                    (dist y (Φ p) + dist z (Ψ p)) +\n                  ε) +\n              δ :=\n          by linarith\n        \n#align glue_dist_triangle glue_dist_triangle\n\n",
 "glue_dist_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2019 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\nprivate theorem glue_dist_self (Φ : Z → X) (Ψ : Z → Y) (ε : exprℝ) : ∀ x, glueDist Φ Ψ ε x x = 0\n  | inl x => dist_self _\n  | inr x => dist_self _\n#align glue_dist_self glue_dist_self\n\n",
 "glue_dist_glued_points":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem glue_dist_glued_points [Nonempty Z] (Φ : Z → X) (Ψ : Z → Y) (ε : exprℝ) (p : Z) :\n    glueDist Φ Ψ ε (inl (Φ p)) (inr (Ψ p)) = ε :=\n  by\n  have :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (dist (Φ p) (Φ q) + dist (Ψ p) (Ψ q)) =\n      0 :=\n    by\n    have A : ∀ q, 0 ≤ dist (Φ p) (Φ q) + dist (Ψ p) (Ψ q) := fun q => by\n      rw [← add_zero (0 : exprℝ)] <;> exact add_le_add dist_nonneg dist_nonneg\n    refine' le_antisymm _ (le_cinfᵢ A)\n    have : 0 = dist (Φ p) (Φ p) + dist (Ψ p) (Ψ p) := by simp\n    rw [this]\n    exact cinfᵢ_le ⟨0, forall_range_iff.2 A⟩ p\n  rw [glue_dist, this, zero_add]\n#align glue_dist_glued_points glue_dist_glued_points\n\n",
 "glue_dist_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprivate theorem glue_dist_comm (Φ : Z → X) (Ψ : Z → Y) (ε : exprℝ) : ∀ x y, glueDist Φ Ψ ε x y = glueDist Φ Ψ ε y x\n  | inl x, inl y => dist_comm _ _\n  | inr x, inr y => dist_comm _ _\n  | inl x, inr y => rfl\n  | inr x, inl y => rfl\n#align glue_dist_comm glue_dist_comm\n\n",
 "fst_eq_of_dist_lt_one":
 "theorem fst_eq_of_dist_lt_one (x y : Σi, E i) (h : dist x y < 1) : x.1 = y.1 :=\n  by\n  cases x; cases y\n  contrapose! h\n  apply one_le_dist_of_ne h\n#align fst_eq_of_dist_lt_one fst_eq_of_dist_lt_one\n\n",
 "dist_triangle":
 "#print dist_triangle /-\nprotected theorem dist_triangle (x y z : Σi, E i) : dist x z ≤ dist x y + dist y z :=\n  by\n  rcases x with ⟨i, x⟩; rcases y with ⟨j, y⟩; rcases z with ⟨k, z⟩\n  rcases eq_or_ne i k with (rfl | hik)\n  · rcases eq_or_ne i j with (rfl | hij)\n    · simpa using dist_triangle x y z\n    · simp only [hij, hij.symm, sigma.dist_same, sigma.dist_ne, ne.def, not_false_iff]\n      calc\n        dist x z ≤ dist x (Nonempty.some ⟨x⟩) + 0 + 0 + (0 + 0 + dist (Nonempty.some ⟨z⟩) z) := by\n          simpa only [zero_add, add_zero] using dist_triangle _ _ _\n        _ ≤ _ := by apply_rules [add_le_add, le_rfl, dist_nonneg, zero_le_one]\n        \n  · rcases eq_or_ne i j with (rfl | hij)\n    · simp only [hik, sigma.dist_ne, ne.def, not_false_iff, sigma.dist_same]\n      calc\n        dist x (Nonempty.some ⟨x⟩) + 1 + dist (Nonempty.some ⟨z⟩) z ≤\n            dist x y + dist y (Nonempty.some ⟨y⟩) + 1 + dist (Nonempty.some ⟨z⟩) z :=\n          by apply_rules [add_le_add, le_rfl, dist_triangle]\n        _ = _ := by abel\n        \n    · rcases eq_or_ne j k with (rfl | hjk)\n      · simp only [hij, sigma.dist_ne, ne.def, not_false_iff, sigma.dist_same]\n        calc\n          dist x (Nonempty.some ⟨x⟩) + 1 + dist (Nonempty.some ⟨z⟩) z ≤\n              dist x (Nonempty.some ⟨x⟩) + 1 + (dist (Nonempty.some ⟨z⟩) y + dist y z) :=\n            by apply_rules [add_le_add, le_rfl, dist_triangle]\n          _ = _ := by abel\n          \n      · simp only [hik, hij, hjk, sigma.dist_ne, ne.def, not_false_iff]\n        calc\n          dist x (Nonempty.some ⟨x⟩) + 1 + dist (Nonempty.some ⟨z⟩) z =\n              dist x (Nonempty.some ⟨x⟩) + 1 + 0 + (0 + 0 + dist (Nonempty.some ⟨z⟩) z) :=\n            by simp only [add_zero, zero_add]\n          _ ≤ _ := by apply_rules [add_le_add, zero_le_one, dist_nonneg, le_rfl]\n          \n#align dist_triangle dist_triangle\n-/\n\n",
 "dist_same":
 "/- Copy of the previous paragraph, but for arbitrary disjoint unions instead of the disjoint union\nof two spaces. I.e., work with sigma types instead of sum types. -/\n@[simp]\ntheorem dist_same (i : ι) (x : E i) (y : E i) : dist (⟨i, x⟩ : Σj, E j) ⟨i, y⟩ = dist x y := by\n  simp [has_dist.dist, sigma.dist]\n#align dist_same dist_same\n\n",
 "dist_ne":
 "@[simp]\ntheorem dist_ne {i j : ι} (h : i ≠ j) (x : E i) (y : E j) :\n    dist (⟨i, x⟩ : Σk, E k) ⟨j, y⟩ = dist x (Nonempty.some ⟨x⟩) + 1 + dist (Nonempty.some ⟨y⟩) y := by\n  simp [has_dist.dist, sigma.dist, h]\n#align dist_ne dist_ne\n\n",
 "dist_eq_glue_dist":
 "/- A particular case of the previous construction is when one uses basepoints in `X` and `Y` and one\nglues only along the basepoints, putting them at distance 1. We give a direct definition of\nthe distance, without infi, as it is easier to use in applications, and show that it is equal to\nthe gluing distance defined above to take advantage of the lemmas we have already proved. -/\ntheorem sum.dist_eq_glue_dist {p q : Sum X Y} (x : X) (y : Y) :\n    Sum.dist p q = glueDist (fun _ : Unit => Nonempty.some ⟨x⟩) (fun _ : Unit => Nonempty.some ⟨y⟩) 1 p q := by\n  cases p <;> cases q <;> first |rfl|simp [sum.dist, glue_dist, dist_comm, add_comm, add_left_comm]\n#align sum.dist_eq_glue_dist sum.dist_eq_glue_dist\n\n",
 "dist_eq":
 "theorem sum.dist_eq {x y : Sum X Y} : dist x y = Sum.dist x y :=\n  rfl\n#align sum.dist_eq sum.dist_eq\n\n",
 "dist_comm":
 "private theorem sum.dist_comm (x y : Sum X Y) : Sum.dist x y = Sum.dist y x := by\n  cases x <;> cases y <;> simp only [sum.dist, dist_comm, add_comm, add_left_comm]\n#align sum.dist_comm sum.dist_comm\n\n",
 "CompleteSpace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print CompleteSpace /-\n/-- A disjoint union of complete metric spaces is complete. -/\nprotected theorem CompleteSpace [∀ i, CompleteSpace (E i)] : CompleteSpace (Σi, E i) :=\n  by\n  set s : ι → Set (Σi, E i) := fun i => «expr ⁻¹' » Sigma.fst {i}\n  set U := { p : (Σk, E k) × Σk, E k | dist p.1 p.2 < 1 }\n  have hc : ∀ i, IsComplete (s i) := by\n    intro i\n    simp only [s, ← range_sigma_mk]\n    exact (isometry_mk i).uniform_inducing.is_complete_range\n  have hd : ∀ (i j), ∀ x ∈ s i, ∀ y ∈ s j, (x, y) ∈ U → i = j := fun i j x hx y hy hxy =>\n    (Eq.symm hx).trans ((fst_eq_of_dist_lt_one _ _ hxy).trans hy)\n  refine' completeSpace_of_isComplete_univ _\n  convert isComplete_unionᵢ_separated hc (dist_mem_uniformity zero_lt_one) hd\n  simp [s, ← preimage_Union]\n#align complete_space CompleteSpace\n-/\n\n"}