{"optimal_GH_dist_mem_candidates_b":
 "private theorem optimal_GH_dist_mem_candidates_b : optimal_GH_dist X Y ∈ candidates_b X Y := by\n  cases Classical.choose_spec (exists_minimizer X Y) <;> assumption\n#align optimal_GH_dist_mem_candidates_b optimal_GH_dist_mem_candidates_b\n\n",
 "one_le_max_var":
 "/-\nCopyright (c) 2019 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n/- This section shows that the Gromov-Hausdorff distance\nis realized. For this, we consider candidate distances on the disjoint union\n`X ⊕ Y` of two compact nonempty metric spaces, almost realizing the Gromov-Hausdorff\ndistance, and show that they form a compact family by applying Arzela-Ascoli\ntheorem. The existence of a minimizer follows. -/\nprivate theorem one_le_max_var : 1 ≤ max_var X Y :=\n  calc\n    (1 : Real) = 2 * 0 + 1 + 2 * 0 := by simp\n    _ ≤ 2 * diam (univ : Set X) + 1 + 2 * diam (univ : Set Y) := by\n      apply_rules [add_le_add, mul_le_mul_of_nonneg_left, diam_nonneg] <;> norm_num\n    \n#align one_le_max_var one_le_max_var\n\n",
 "max_var_bound":
 "--section\nprivate theorem max_var_bound : dist x y ≤ max_var X Y :=\n  calc\n    dist x y ≤ diam (univ : Set (Sum X Y)) := dist_le_diam_of_mem bounded_of_compactSpace (mem_univ _) (mem_univ _)\n    _ = diam (range inl ∪ range inr : Set (Sum X Y)) := by rw [range_inl_union_range_inr]\n    _ ≤ diam (range inl : Set (Sum X Y)) + dist (inl default) (inr default) + diam (range inr : Set (Sum X Y)) :=\n      (diam_union (mem_range_self _) (mem_range_self _))\n    _ = diam (univ : Set X) + (dist default default + 1 + dist default default) + diam (univ : Set Y) :=\n      by\n      rw [isometry_inl.diam_range, isometry_inr.diam_range]\n      rfl\n    _ = 1 * diam (univ : Set X) + 1 + 1 * diam (univ : Set Y) := by simp\n    _ ≤ 2 * diam (univ : Set X) + 1 + 2 * diam (univ : Set Y) :=\n      by\n      apply_rules [add_le_add, mul_le_mul_of_nonneg_right, diam_nonneg, le_refl]\n      norm_num; norm_num\n    \n#align max_var_bound max_var_bound\n\n",
 "isometry_optimal_GH_injr":
 "/-- The injection of `Y` in the optimal coupling between `X` and `Y` is an isometry. -/\ntheorem isometry_optimal_GH_injr : Isometry (optimal_GH_injr X Y) :=\n  Isometry.of_dist_eq fun x y => candidates_dist_inr (optimal_GH_dist_mem_candidates_b X Y) _ _\n#align isometry_optimal_GH_injr isometry_optimal_GH_injr\n\n",
 "isometry_optimal_GH_injl":
 "/-- The injection of `X` in the optimal coupling between `X` and `Y` is an isometry. -/\ntheorem isometry_optimal_GH_injl : Isometry (optimal_GH_injl X Y) :=\n  Isometry.of_dist_eq fun x y => candidates_dist_inl (optimal_GH_dist_mem_candidates_b X Y) _ _\n#align isometry_optimal_GH_injl isometry_optimal_GH_injl\n\n",
 "is_compact_candidates_b":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Compactness of candidates (in bounded_continuous_functions) follows. -/\nprivate theorem is_compact_candidates_b : IsCompact (candidates_b X Y) :=\n  by\n  refine' arzela_ascoli₂ (Icc 0 (max_var X Y)) is_compact_Icc (candidates_b X Y) closed_candidates_b _ _\n  · rintro f ⟨x1, x2⟩ hf\n    simp only [Set.mem_Icc]\n    exact ⟨candidates_nonneg hf, candidates_le_max_var hf⟩\n  · refine' equicontinuous_of_continuity_modulus (fun t => 2 * max_var X Y * t) _ _ _\n    · have : tendsto (fun t : exprℝ => 2 * (max_var X Y : exprℝ) * t) ((nhds) 0) ((nhds) (2 * max_var X Y * 0)) :=\n        tendsto_const_nhds.mul tendsto_id\n      simpa using this\n    · rintro x y ⟨f, hf⟩\n      exact (candidates_lipschitz hf).dist_le_mul _ _\n#align is_compact_candidates_b is_compact_candidates_b\n\n",
 "exists_minimizer":
 "--section\n/- Now that we have proved that the set of candidates is compact, and that HD is continuous,\nwe can finally select a candidate minimizing HD. This will be the candidate realizing the\noptimal coupling. -/\nprivate theorem exists_minimizer : ∃ f ∈ candidates_b X Y, ∀ g ∈ candidates_b X Y, HD f ≤ HD g :=\n  is_compact_candidates_b.exists_forall_le candidates_b_nonempty HD_continuous.continuous_on\n#align exists_minimizer exists_minimizer\n\n",
 "dist_mem_candidates":
 "/-- The distance on `X ⊕ Y` is a candidate -/\nprivate theorem dist_mem_candidates : (fun p : Sum X Y × Sum X Y => dist p.1 p.2) ∈ candidates X Y :=\n  by\n  simp only [candidates, dist_comm, forall_const, and_true_iff, add_comm, eq_self_iff_true, and_self_iff, Sum.forall,\n    Set.mem_setOf_eq, dist_self]\n  repeat'\n    first\n      |constructor|exact fun a y z => dist_triangle_left _ _ _|exact fun x y => by rfl|exact fun x y => max_var_bound\n#align dist_mem_candidates dist_mem_candidates\n\n",
 "closed_candidates_b":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- To apply Arzela-Ascoli, we need to check that the set of candidates is closed and\nequicontinuous. Equicontinuity follows from the Lipschitz control, we check closedness. -/\nprivate theorem closed_candidates_b : IsClosed (candidates_b X Y) :=\n  by\n  have I1 : ∀ x y, IsClosed { f : Cb X Y | f (inl x, inl y) = dist x y } := fun x y =>\n    isClosed_eq continuous_eval_const continuous_const\n  have I2 : ∀ x y, IsClosed { f : Cb X Y | f (inr x, inr y) = dist x y } := fun x y =>\n    isClosed_eq continuous_eval_const continuous_const\n  have I3 : ∀ x y, IsClosed { f : Cb X Y | f (x, y) = f (y, x) } := fun x y =>\n    isClosed_eq continuous_eval_const continuous_eval_const\n  have I4 : ∀ x y z, IsClosed { f : Cb X Y | f (x, z) ≤ f (x, y) + f (y, z) } := fun x y z =>\n    isClosed_le continuous_eval_const (continuous_eval_const.add continuous_eval_const)\n  have I5 : ∀ x, IsClosed { f : Cb X Y | f (x, x) = 0 } := fun x => isClosed_eq continuous_eval_const continuous_const\n  have I6 : ∀ x y, IsClosed { f : Cb X Y | f (x, y) ≤ max_var X Y } := fun x y =>\n    isClosed_le continuous_eval_const continuous_const\n  have :\n    candidates_b X Y =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n                  { f : Cb X Y | f (@inl X Y x, @inl X Y y) = dist x y } ∩\n                «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n                  { f : Cb X Y | f (@inr X Y x, @inr X Y y) = dist x y } ∩\n              «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n                { f : Cb X Y | f (x, y) = f (y, x) } ∩\n            «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n              { f : Cb X Y | f (x, z) ≤ f (x, y) + f (y, z) } ∩\n          «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n            { f : Cb X Y | f (x, x) = 0 } ∩\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          { f : Cb X Y | f (x, y) ≤ max_var X Y } :=\n    by\n    ext\n    simp only [candidates_b, candidates, mem_inter_iff, mem_Inter, mem_set_of_eq]\n  rw [this]\n  repeat'\n    first\n      |apply\n        IsClosed.inter _\n          _|apply\n        isClosed_interᵢ _|apply I1 _ _|apply I2 _ _|apply I3 _ _|apply I4 _ _ _|apply I5 _|apply I6 _ _|intro x\n#align closed_candidates_b closed_candidates_b\n\n",
 "candidates_triangle":
 "private theorem candidates_triangle (fA : f ∈ candidates X Y) : f (x, z) ≤ f (x, y) + f (y, z) :=\n  fA.1.1.2 x y z\n#align candidates_triangle candidates_triangle\n\n",
 "candidates_symm":
 "private theorem candidates_symm (fA : f ∈ candidates X Y) : f (x, y) = f (y, x) :=\n  fA.1.1.1.2 x y\n#align candidates_symm candidates_symm\n\n",
 "candidates_refl":
 "private theorem candidates_refl (fA : f ∈ candidates X Y) : f (x, x) = 0 :=\n  fA.1.2 x\n#align candidates_refl candidates_refl\n\n",
 "candidates_nonneg":
 "private theorem candidates_nonneg (fA : f ∈ candidates X Y) : 0 ≤ f (x, y) :=\n  by\n  have : 0 ≤ 2 * f (x, y) :=\n    calc\n      0 = f (x, x) := (candidates_refl fA).symm\n      _ ≤ f (x, y) + f (y, x) := (candidates_triangle fA)\n      _ = f (x, y) + f (x, y) := by rw [candidates_symm fA]\n      _ = 2 * f (x, y) := by ring\n      \n  · linarith\n#align candidates_nonneg candidates_nonneg\n\n",
 "candidates_lipschitz_aux":
 "/-- Technical lemma to prove that candidates are Lipschitz -/\nprivate theorem candidates_lipschitz_aux (fA : f ∈ candidates X Y) :\n    f (x, y) - f (z, t) ≤ 2 * max_var X Y * dist (x, y) (z, t) :=\n  calc\n    f (x, y) - f (z, t) ≤ f (x, t) + f (t, y) - f (z, t) := sub_le_sub_right (candidates_triangle fA) _\n    _ ≤ f (x, z) + f (z, t) + f (t, y) - f (z, t) := (sub_le_sub_right (add_le_add_right (candidates_triangle fA) _) _)\n    _ = f (x, z) + f (t, y) := by simp [sub_eq_add_neg, add_assoc]\n    _ ≤ max_var X Y * dist x z + max_var X Y * dist t y :=\n      (add_le_add (candidates_dist_bound fA) (candidates_dist_bound fA))\n    _ ≤ max_var X Y * max (dist x z) (dist t y) + max_var X Y * max (dist x z) (dist t y) :=\n      by\n      apply add_le_add\n      apply mul_le_mul_of_nonneg_left (le_max_left (dist x z) (dist t y)) (zero_le_one.trans (one_le_max_var X Y))\n      apply mul_le_mul_of_nonneg_left (le_max_right (dist x z) (dist t y)) (zero_le_one.trans (one_le_max_var X Y))\n    _ = 2 * max_var X Y * max (dist x z) (dist y t) :=\n      by\n      simp [dist_comm]\n      ring\n    _ = 2 * max_var X Y * dist (x, y) (z, t) := by rfl\n    \n#align candidates_lipschitz_aux candidates_lipschitz_aux\n\n",
 "candidates_lipschitz":
 "/-- Candidates are Lipschitz -/\nprivate theorem candidates_lipschitz (fA : f ∈ candidates X Y) : LipschitzWith (2 * max_var X Y) f :=\n  by\n  apply LipschitzWith.of_dist_le_mul\n  rintro ⟨x, y⟩ ⟨z, t⟩\n  rw [Real.dist_eq, abs_sub_le_iff]\n  use candidates_lipschitz_aux fA\n  rw [dist_comm]\n  exact candidates_lipschitz_aux fA\n#align candidates_lipschitz candidates_lipschitz\n\n",
 "candidates_le_max_var":
 "private theorem candidates_le_max_var (fA : f ∈ candidates X Y) : f (x, y) ≤ max_var X Y :=\n  fA.2 x y\n#align candidates_le_max_var candidates_le_max_var\n\n",
 "candidates_dist_inr":
 "private theorem candidates_dist_inr (fA : f ∈ candidates X Y) (x y : Y) : f (inr x, inr y) = dist x y :=\n  fA.1.1.1.1.2 x y\n#align candidates_dist_inr candidates_dist_inr\n\n",
 "candidates_dist_inl":
 "private theorem candidates_dist_inl (fA : f ∈ candidates X Y) (x y : X) : f (inl x, inl y) = dist x y :=\n  fA.1.1.1.1.1 x y\n#align candidates_dist_inl candidates_dist_inl\n\n",
 "candidates_dist_bound":
 "/-- candidates are bounded by `max_var X Y` -/\nprivate theorem candidates_dist_bound (fA : f ∈ candidates X Y) : ∀ {x y : Sum X Y}, f (x, y) ≤ max_var X Y * dist x y\n  | inl x, inl y =>\n    calc\n      f (inl x, inl y) = dist x y := candidates_dist_inl fA x y\n      _ = dist (inl x) (inl y) := by\n        rw [@sum.dist_eq X Y]\n        rfl\n      _ = 1 * dist (inl x) (inl y) := by simp\n      _ ≤ max_var X Y * dist (inl x) (inl y) := mul_le_mul_of_nonneg_right (one_le_max_var X Y) dist_nonneg\n      \n  | inl x, inr y =>\n    calc\n      f (inl x, inr y) ≤ max_var X Y := candidates_le_max_var fA\n      _ = max_var X Y * 1 := by simp\n      _ ≤ max_var X Y * dist (inl x) (inr y) :=\n        mul_le_mul_of_nonneg_left Sum.one_le_dist_inl_inr (le_trans zero_le_one (one_le_max_var X Y))\n      \n  | inr x, inl y =>\n    calc\n      f (inr x, inl y) ≤ max_var X Y := candidates_le_max_var fA\n      _ = max_var X Y * 1 := by simp\n      _ ≤ max_var X Y * dist (inl x) (inr y) :=\n        mul_le_mul_of_nonneg_left Sum.one_le_dist_inl_inr (le_trans zero_le_one (one_le_max_var X Y))\n      \n  | inr x, inr y =>\n    calc\n      f (inr x, inr y) = dist x y := candidates_dist_inr fA x y\n      _ = dist (inr x) (inr y) := by\n        rw [@sum.dist_eq X Y]\n        rfl\n      _ = 1 * dist (inr x) (inr y) := by simp\n      _ ≤ max_var X Y * dist (inr x) (inr y) := mul_le_mul_of_nonneg_right (one_le_max_var X Y) dist_nonneg\n      \n#align candidates_dist_bound candidates_dist_bound\n\n",
 "candidates_b_of_candidates_mem":
 "theorem candidates_b_of_candidates_mem (f : prod_space_fun X Y) (fA : f ∈ candidates X Y) :\n    candidates_b_of_candidates f fA ∈ candidates_b X Y :=\n  fA\n#align candidates_b_of_candidates_mem candidates_b_of_candidates_mem\n\n",
 "candidates_b_nonempty":
 "private theorem candidates_b_nonempty : (candidates_b X Y).nonempty :=\n  ⟨_, candidates_b_dist_mem_candidates_b⟩\n#align candidates_b_nonempty candidates_b_nonempty\n\n",
 "candidates_b_dist_mem_candidates_b":
 "theorem candidates_b_dist_mem_candidates_b : candidates_b_dist X Y ∈ candidates_b X Y :=\n  candidates_b_of_candidates_mem _ _\n#align candidates_b_dist_mem_candidates_b candidates_b_dist_mem_candidates_b\n\n",
 "Hausdorff_dist_optimal_le_HD":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- For any candidate `f`, `HD(f)` is larger than or equal to the Hausdorff distance in the\noptimal coupling. This follows from the fact that HD of the optimal candidate is exactly\nthe Hausdorff distance in the optimal coupling, although we only prove here the inequality\nwe need. -/\ntheorem Hausdorff_dist_optimal_le_HD {f} (h : f ∈ candidates_b X Y) :\n    hausdorffDist (range (optimal_GH_injl X Y)) (range (optimal_GH_injr X Y)) ≤ HD f :=\n  by\n  refine' le_trans (le_of_forall_le_of_dense fun r hr => _) (HD_optimal_GH_dist_le X Y f h)\n  have A : ∀ x ∈ range (optimal_GH_injl X Y), ∃ y ∈ range (optimal_GH_injr X Y), dist x y ≤ r :=\n    by\n    rintro _ ⟨z, rfl⟩\n    have I1 :\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (optimal_GH_dist X Y (inl x, inr y))) <\n        r :=\n      lt_of_le_of_lt (le_max_left _ _) hr\n    have I2 :\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (optimal_GH_dist X Y (inl z, inr y)) ≤\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (optimal_GH_dist X Y (inl x, inr y))) :=\n      le_csupₛ (by simpa using HD_bound_aux1 _ 0) (mem_range_self _)\n    have I :\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (optimal_GH_dist X Y (inl z, inr y)) <\n        r :=\n      lt_of_le_of_lt I2 I1\n    rcases exists_lt_of_cinfₛ_lt (range_nonempty _) I with ⟨r', ⟨z', rfl⟩, hr'⟩\n    exact ⟨optimal_GH_injr X Y z', mem_range_self _, le_of_lt hr'⟩\n  refine' Hausdorff_dist_le_of_mem_dist _ A _\n  · inhabit X\n    rcases A _ (mem_range_self default) with ⟨y, -, hy⟩\n    exact le_trans dist_nonneg hy\n  · rintro _ ⟨z, rfl⟩\n    have I1 :\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (optimal_GH_dist X Y (inl x, inr y))) <\n        r :=\n      lt_of_le_of_lt (le_max_right _ _) hr\n    have I2 :\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (optimal_GH_dist X Y (inl x, inr z)) ≤\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (optimal_GH_dist X Y (inl x, inr y))) :=\n      le_csupₛ (by simpa using HD_bound_aux2 _ 0) (mem_range_self _)\n    have I :\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (optimal_GH_dist X Y (inl x, inr z)) <\n        r :=\n      lt_of_le_of_lt I2 I1\n    rcases exists_lt_of_cinfₛ_lt (range_nonempty _) I with ⟨r', ⟨z', rfl⟩, hr'⟩\n    refine' ⟨optimal_GH_injl X Y z', mem_range_self _, le_of_lt _⟩\n    rwa [dist_comm]\n#align Hausdorff_dist_optimal_le_HD Hausdorff_dist_optimal_le_HD\n\n",
 "HD_optimal_GH_dist_le":
 "private theorem HD_optimal_GH_dist_le (g : Cb X Y) (hg : g ∈ candidates_b X Y) : HD (optimal_GH_dist X Y) ≤ HD g :=\n  let ⟨Z1, Z2⟩ := Classical.choose_spec (exists_minimizer X Y)\n  Z2 g hg\n#align HD_optimal_GH_dist_le HD_optimal_GH_dist_le\n\n",
 "HD_lipschitz_aux3":
 "private theorem HD_lipschitz_aux3 (f g : Cb X Y) : HD f ≤ HD g + dist f g :=\n  max_le (le_trans (HD_lipschitz_aux1 f g) (add_le_add_right (le_max_left _ _) _))\n    (le_trans (HD_lipschitz_aux2 f g) (add_le_add_right (le_max_right _ _) _))\n#align HD_lipschitz_aux3 HD_lipschitz_aux3\n\n",
 "HD_lipschitz_aux2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\nprivate theorem HD_lipschitz_aux2 (f g : Cb X Y) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (f (inl x, inr y))) ≤\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (g (inl x, inr y))) +\n        dist f g :=\n  by\n  rcases(Real.bounded_iff_bddBelow_bddAbove.1 g.bounded_range).1 with ⟨cg, hcg⟩\n  have Hcg : ∀ x, cg ≤ g x := fun x => hcg (mem_range_self x)\n  rcases(Real.bounded_iff_bddBelow_bddAbove.1 f.bounded_range).1 with ⟨cf, hcf⟩\n  have Hcf : ∀ x, cf ≤ f x := fun x => hcf (mem_range_self x)\n  -- prove the inequality but with `dist f g` inside, by using inequalities comparing\n  -- supr to supr and infi to infi\n  have Z :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (f (inl x, inr y))) ≤\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (g (inl x, inr y) + dist f g)) :=\n    csupᵢ_mono (HD_bound_aux2 _ (dist f g)) fun y =>\n      cinfᵢ_mono ⟨cf, forall_range_iff.2 fun i => Hcf _⟩ fun y => coe_le_coe_add_dist\n  -- move the `dist f g` out of the infimum and the supremum, arguing that continuous monotone maps\n  -- (here the addition of `dist f g`) preserve infimum and supremum\n  have E1 :\n    ∀ y,\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (g (inl x, inr y)) +\n          dist f g =\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (g (inl x, inr y) + dist f g) :=\n    by\n    intro y\n    refine' Monotone.map_cinfᵢ_of_continuousAt (continuous_at_id.add continuousAt_const) _ _\n    · intro x y hx\n      simpa\n    · show BddBelow (range fun x : X => g (inl x, inr y))\n      exact ⟨cg, forall_range_iff.2 fun i => Hcg _⟩\n  have E2 :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (g (inl x, inr y))) +\n        dist f g =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (g (inl x, inr y)) +\n          dist f g) :=\n    by\n    refine' Monotone.map_csupᵢ_of_continuousAt (continuous_at_id.add continuousAt_const) _ _\n    · intro x y hx\n      simpa\n    · simpa using HD_bound_aux2 _ 0\n  -- deduce the result from the above two steps\n  simpa [E2, E1]\n#align HD_lipschitz_aux2 HD_lipschitz_aux2\n\n",
 "HD_lipschitz_aux1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- To check that HD is continuous, we check that it is Lipschitz. As HD is a max, we\nprove separately inequalities controlling the two terms (relying too heavily on copy-paste...) -/\nprivate theorem HD_lipschitz_aux1 (f g : Cb X Y) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (f (inl x, inr y))) ≤\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (g (inl x, inr y))) +\n        dist f g :=\n  by\n  rcases(Real.bounded_iff_bddBelow_bddAbove.1 g.bounded_range).1 with ⟨cg, hcg⟩\n  have Hcg : ∀ x, cg ≤ g x := fun x => hcg (mem_range_self x)\n  rcases(Real.bounded_iff_bddBelow_bddAbove.1 f.bounded_range).1 with ⟨cf, hcf⟩\n  have Hcf : ∀ x, cf ≤ f x := fun x => hcf (mem_range_self x)\n  -- prove the inequality but with `dist f g` inside, by using inequalities comparing\n  -- supr to supr and infi to infi\n  have Z :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (f (inl x, inr y))) ≤\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (g (inl x, inr y) + dist f g)) :=\n    csupᵢ_mono (HD_bound_aux1 _ (dist f g)) fun x =>\n      cinfᵢ_mono ⟨cf, forall_range_iff.2 fun i => Hcf _⟩ fun y => coe_le_coe_add_dist\n  -- move the `dist f g` out of the infimum and the supremum, arguing that continuous monotone maps\n  -- (here the addition of `dist f g`) preserve infimum and supremum\n  have E1 :\n    ∀ x,\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (g (inl x, inr y)) +\n          dist f g =\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (g (inl x, inr y) + dist f g) :=\n    by\n    intro x\n    refine' Monotone.map_cinfᵢ_of_continuousAt (continuous_at_id.add continuousAt_const) _ _\n    · intro x y hx\n      simpa\n    · show BddBelow (range fun y : Y => g (inl x, inr y))\n      exact ⟨cg, forall_range_iff.2 fun i => Hcg _⟩\n  have E2 :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (g (inl x, inr y))) +\n        dist f g =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            (g (inl x, inr y)) +\n          dist f g) :=\n    by\n    refine' Monotone.map_csupᵢ_of_continuousAt (continuous_at_id.add continuousAt_const) _ _\n    · intro x y hx\n      simpa\n    · simpa using HD_bound_aux1 _ 0\n  -- deduce the result from the above two steps\n  simpa [E2, E1, Function.comp]\n#align HD_lipschitz_aux1 HD_lipschitz_aux1\n\n",
 "HD_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Conclude that HD, being Lipschitz, is continuous -/\nprivate theorem HD_continuous : Continuous (HD : Cb X Y → exprℝ) :=\n  LipschitzWith.continuous (LipschitzWith.of_le_add HD_lipschitz_aux3)\n#align HD_continuous HD_continuous\n\n",
 "HD_candidates_b_dist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Explicit bound on `HD (dist)`. This means that when looking for minimizers it will\nbe sufficient to look for functions with `HD(f)` bounded by this bound. -/\ntheorem HD_candidates_b_dist_le : HD (candidates_b_dist X Y) ≤ diam (univ : Set X) + 1 + diam (univ : Set Y) :=\n  by\n  refine' max_le (csupᵢ_le fun x => _) (csupᵢ_le fun y => _)\n  · have A :\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (candidates_b_dist X Y (inl x, inr y)) ≤\n        candidates_b_dist X Y (inl x, inr default) :=\n      cinfᵢ_le (by simpa using HD_below_aux1 0) default\n    have B : dist (inl x) (inr default) ≤ diam (univ : Set X) + 1 + diam (univ : Set Y) :=\n      calc\n        dist (inl x) (inr (default : Y)) = dist x (default : X) + 1 + dist default default := rfl\n        _ ≤ diam (univ : Set X) + 1 + diam (univ : Set Y) :=\n          by\n          apply add_le_add (add_le_add _ le_rfl)\n          exact dist_le_diam_of_mem bounded_of_compact_space (mem_univ _) (mem_univ _)\n          any_goals exact OrderedAddCommMonoid.to_covariantClass_left (exprℝ)\n          any_goals exact OrderedAddCommMonoid.to_covariantClass_right (exprℝ)\n          exact dist_le_diam_of_mem bounded_of_compact_space (mem_univ _) (mem_univ _)\n        \n    exact le_trans A B\n  · have A :\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (candidates_b_dist X Y (inl x, inr y)) ≤\n        candidates_b_dist X Y (inl default, inr y) :=\n      cinfᵢ_le (by simpa using HD_below_aux2 0) default\n    have B : dist (inl default) (inr y) ≤ diam (univ : Set X) + 1 + diam (univ : Set Y) :=\n      calc\n        dist (inl (default : X)) (inr y) = dist default default + 1 + dist default y := rfl\n        _ ≤ diam (univ : Set X) + 1 + diam (univ : Set Y) :=\n          by\n          apply add_le_add (add_le_add _ le_rfl)\n          exact dist_le_diam_of_mem bounded_of_compact_space (mem_univ _) (mem_univ _)\n          any_goals exact OrderedAddCommMonoid.to_covariantClass_left (exprℝ)\n          any_goals exact OrderedAddCommMonoid.to_covariantClass_right (exprℝ)\n          exact dist_le_diam_of_mem bounded_of_compact_space (mem_univ _) (mem_univ _)\n        \n    exact le_trans A B\n#align HD_candidates_b_dist_le HD_candidates_b_dist_le\n\n",
 "HD_bound_aux2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\nprivate theorem HD_bound_aux2 (f : Cb X Y) (C : exprℝ) :\n    BddAbove\n      (range fun y : Y =>\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (f (inl x, inr y) + C)) :=\n  by\n  rcases(Real.bounded_iff_bddBelow_bddAbove.1 f.bounded_range).2 with ⟨Cf, hCf⟩\n  refine' ⟨Cf + C, forall_range_iff.2 fun y => _⟩\n  calc\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (f (inl x, inr y) + C) ≤\n        f (inl default, inr y) + C :=\n      cinfᵢ_le (HD_below_aux2 C) default\n    _ ≤ Cf + C := add_le_add ((fun x => hCf (mem_range_self x)) _) le_rfl\n    \n#align HD_bound_aux2 HD_bound_aux2\n\n",
 "HD_bound_aux1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\nprivate theorem HD_bound_aux1 (f : Cb X Y) (C : exprℝ) :\n    BddAbove\n      (range fun x : X =>\n        «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (f (inl x, inr y) + C)) :=\n  by\n  rcases(Real.bounded_iff_bddBelow_bddAbove.1 f.bounded_range).2 with ⟨Cf, hCf⟩\n  refine' ⟨Cf + C, forall_range_iff.2 fun x => _⟩\n  calc\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (f (inl x, inr y) + C) ≤\n        f (inl x, inr default) + C :=\n      cinfᵢ_le (HD_below_aux1 C) default\n    _ ≤ Cf + C := add_le_add ((fun x => hCf (mem_range_self x)) _) le_rfl\n    \n#align HD_bound_aux1 HD_bound_aux1\n\n",
 "HD_below_aux2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem HD_below_aux2 {f : Cb X Y} (C : exprℝ) {y : Y} : BddBelow (range fun x : X => f (inl x, inr y) + C) :=\n  let ⟨cf, hcf⟩ := (Real.bounded_iff_bddBelow_bddAbove.1 f.bounded_range).1\n  ⟨cf + C, forall_range_iff.2 fun i => add_le_add_right ((fun x => hcf (mem_range_self x)) _) _⟩\n#align HD_below_aux2 HD_below_aux2\n\n",
 "HD_below_aux1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- We will show that HD is continuous on bounded_continuous_functions, to deduce that its\nminimum on the compact set candidates_b is attained. Since it is defined in terms of\ninfimum and supremum on `ℝ`, which is only conditionnally complete, we will need all the time\nto check that the defining sets are bounded below or above. This is done in the next few\ntechnical lemmas -/\ntheorem HD_below_aux1 {f : Cb X Y} (C : exprℝ) {x : X} : BddBelow (range fun y : Y => f (inl x, inr y) + C) :=\n  let ⟨cf, hcf⟩ := (Real.bounded_iff_bddBelow_bddAbove.1 f.bounded_range).1\n  ⟨cf + C, forall_range_iff.2 fun i => add_le_add_right ((fun x => hcf (mem_range_self x)) _) _⟩\n#align HD_below_aux1 HD_below_aux1\n\n"}