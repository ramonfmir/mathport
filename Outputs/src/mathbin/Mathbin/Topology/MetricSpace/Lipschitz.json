{"weaken":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\nprotected theorem weaken (hf : LipschitzWith K f) {K' : nnreal} (h : K ≤ K') : LipschitzWith K' f := fun x y =>\n  le_trans (hf x y) <| ENNReal.mul_right_mono (ENNReal.coe_le_coe.2 h)\n#align weaken weaken\n\n",
 "uncurry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\nprotected theorem uncurry {f : α → β → γ} {Kα Kβ : nnreal} (hα : ∀ b, LipschitzWith Kα fun a => f a b)\n    (hβ : ∀ a, LipschitzWith Kβ (f a)) : LipschitzWith (Kα + Kβ) (function.uncurry f) :=\n  by\n  rintro ⟨a₁, b₁⟩ ⟨a₂, b₂⟩\n  simp only [function.uncurry, ENNReal.coe_add, add_mul]\n  apply le_trans (edist_triangle _ (f a₂ b₁) _)\n  exact\n    add_le_add (le_trans (hα _ _ _) <| ENNReal.mul_left_mono <| le_max_left _ _)\n      (le_trans (hβ _ _ _) <| ENNReal.mul_left_mono <| le_max_right _ _)\n#align uncurry uncurry\n\n",
 "subtype_val":
 "protected theorem subtype_val (s : Set α) : LipschitzWith 1 (Subtype.val : s → α) :=\n  LipschitzWith.of_edist_le fun x y => le_rfl\n#align subtype_val subtype_val\n\n",
 "subtype_mk":
 "theorem subtype_mk (hf : LipschitzWith K f) {p : β → Prop} (hp : ∀ x, p (f x)) :\n    LipschitzWith K (fun x => ⟨f x, hp x⟩ : α → { y // p y }) :=\n  hf\n#align subtype_mk subtype_mk\n\n",
 "subtype_coe":
 "protected theorem subtype_coe (s : Set α) : LipschitzWith 1 (coe : s → α) :=\n  LipschitzWith.subtype_val s\n#align subtype_coe subtype_coe\n\n",
 "right_of_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem bounded.right_of_prod (h : Bounded (lower_set.prod s t)) (hs : s.nonempty) : Bounded t := by\n  simpa only [snd_image_prod hs t] using (@LipschitzWith.prod_snd α β _ _).bounded_image h\n#align bounded.right_of_prod bounded.right_of_prod\n\n",
 "restrict":
 "protected theorem restrict (hf : LipschitzWith K f) (s : Set α) : LipschitzWith K (s.restrict f) := fun x y => hf x y\n#align restrict restrict\n\n",
 "proj_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprotected theorem proj_Icc {a b : exprℝ} (h : a ≤ b) : LipschitzWith 1 (projIcc a b h) :=\n  ((LipschitzWith.id.const_min _).const_max _).subtype_mk _\n#align proj_Icc proj_Icc\n\n",
 "prod_snd":
 "protected theorem prod_snd : LipschitzWith 1 (@Prod.snd α β) :=\n  LipschitzWith.of_edist_le fun x y => le_max_right _ _\n#align prod_snd prod_snd\n\n",
 "prod_mk_right":
 "protected theorem prod_mk_right (b : β) : LipschitzWith 1 fun a : α => (a, b) := by\n  simpa only [max_eq_left zero_le_one] using lipschitz_with.id.prod (LipschitzWith.const b)\n#align prod_mk_right prod_mk_right\n\n",
 "prod_mk_left":
 "protected theorem prod_mk_left (a : α) : LipschitzWith 1 (prod.mk a : β → α × β) := by\n  simpa only [max_eq_right zero_le_one] using (LipschitzWith.const a).prod LipschitzWith.id\n#align prod_mk_left prod_mk_left\n\n",
 "prod_fst":
 "protected theorem prod_fst : LipschitzWith 1 (@Prod.fst α β) :=\n  LipschitzWith.of_edist_le fun x y => le_max_left _ _\n#align prod_fst prod_fst\n\n",
 "pow":
 "protected theorem pow {f : Function.End α} {K} (h : LipschitzWith K f) :\n    ∀ n : ℕ, LipschitzWith (K ^ n) (f ^ n : Function.End α)\n  | 0 => by simpa only [pow_zero] using LipschitzWith.id\n  | n + 1 => by\n    rw [pow_succ, pow_succ]\n    exact h.mul (pow n)\n#align pow pow\n\n",
 "of_le_add_mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- For functions to `ℝ`, it suffices to prove `f x ≤ f y + K * dist x y`; this version\ndoesn't assume `0≤K`. -/\nprotected theorem of_le_add_mul' {f : α → exprℝ} (K : exprℝ) (h : ∀ x ∈ s, ∀ y ∈ s, f x ≤ f y + K * dist x y) :\n    LipschitzOnWith (Real.toNNReal K) f s :=\n  have I : ∀ x ∈ s, ∀ y ∈ s, f x - f y ≤ K * dist x y := fun x hx y hy => sub_le_iff_le_add'.2 (h x hx y hy)\n  LipschitzOnWith.of_dist_le' fun x hx y hy => abs_sub_le_iff.2 ⟨I x hx y hy, dist_comm y x ▸ I y hy x hx⟩\n#align of_le_add_mul' of_le_add_mul'\n\n",
 "of_le_add_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-- For functions to `ℝ`, it suffices to prove `f x ≤ f y + K * dist x y`; this version\nassumes `0≤K`. -/\nprotected theorem of_le_add_mul {f : α → exprℝ} (K : nnreal) (h : ∀ x ∈ s, ∀ y ∈ s, f x ≤ f y + K * dist x y) :\n    LipschitzOnWith K f s := by simpa only [Real.toNNReal_coe] using LipschitzOnWith.of_le_add_mul' K h\n#align of_le_add_mul of_le_add_mul\n\n",
 "of_le_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprotected theorem of_le_add {f : α → exprℝ} (h : ∀ x ∈ s, ∀ y ∈ s, f x ≤ f y + dist x y) : LipschitzOnWith 1 f s :=\n  LipschitzOnWith.of_le_add_mul 1 <| by simpa only [NNReal.coe_one, one_mul]\n#align of_le_add of_le_add\n\n",
 "of_edist_le":
 "protected theorem of_edist_le (h : ∀ x y, edist (f x) (f y) ≤ edist x y) : LipschitzWith 1 f := fun x y => by\n  simp only [ENNReal.coe_one, one_mul, h]\n#align of_edist_le of_edist_le\n\n",
 "of_dist_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprotected theorem of_dist_le' {K : exprℝ} (h : ∀ x ∈ s, ∀ y ∈ s, dist (f x) (f y) ≤ K * dist x y) :\n    LipschitzOnWith (Real.toNNReal K) f s :=\n  of_dist_le_mul fun x hx y hy =>\n    le_trans (h x hx y hy) <| mul_le_mul_of_nonneg_right (Real.le_coe_toNNReal K) dist_nonneg\n#align of_dist_le' of_dist_le'\n\n",
 "nndist_le":
 "theorem nndist_le (hf : LipschitzWith K f) (x y : α) : nndist (f x) (f y) ≤ K * nndist x y :=\n  hf.dist_le_mul x y\n#align nndist_le nndist_le\n\n",
 "mul_edist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem mul_edist_le (h : LipschitzWith K f) (x y : α) : (K⁻¹ : ennreal) * edist (f x) (f y) ≤ edist x y :=\n  by\n  rw [mul_comm, ← div_eq_mul_inv]\n  exact ENNReal.div_le_of_le_mul' (h x y)\n#align mul_edist_le mul_edist_le\n\n",
 "mul":
 "protected theorem mul {f g : Function.End α} {Kf Kg} (hf : LipschitzWith Kf f) (hg : LipschitzWith Kg g) :\n    LipschitzWith (Kf * Kg) (f * g : Function.End α) :=\n  hf.comp hg\n#align mul mul\n\n",
 "mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print LipschitzOnWith.mono /-\ntheorem LipschitzOnWith.mono [PseudoEMetricSpace α] [PseudoEMetricSpace β] {K : nnreal} {s t : Set α} {f : α → β}\n    (hf : LipschitzOnWith K f t) (h : s ⊆ t) : LipschitzOnWith K f s := fun x x_in y y_in => hf (h x_in) (h y_in)\n#align lipschitz_on_with.mono LipschitzOnWith.mono\n-/\n\n",
 "mk_one":
 "protected theorem mk_one (h : ∀ x ∈ s, ∀ y ∈ s, dist (f x) (f y) ≤ dist x y) : LipschitzOnWith 1 f s :=\n  of_dist_le_mul <| by simpa only [NNReal.coe_one, one_mul] using h\n#align mk_one mk_one\n\n",
 "min_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem min_const (hf : LipschitzWith Kf f) (a : exprℝ) : LipschitzWith Kf fun x => min (f x) a := by\n  simpa only [max_eq_left (zero_le Kf)] using hf.min (LipschitzWith.const a)\n#align min_const min_const\n\n",
 "min":
 "protected theorem min (hf : LipschitzWith Kf f) (hg : LipschitzWith Kg g) :\n    LipschitzWith (max Kf Kg) fun x => min (f x) (g x) := by\n  simpa only [(· ∘ ·), one_mul] using lipschitz_with_min.comp (hf.prod hg)\n#align min min\n\n",
 "max_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem max_const (hf : LipschitzWith Kf f) (a : exprℝ) : LipschitzWith Kf fun x => max (f x) a := by\n  simpa only [max_eq_left (zero_le Kf)] using hf.max (LipschitzWith.const a)\n#align max_const max_const\n\n",
 "max":
 "protected theorem max (hf : LipschitzWith Kf f) (hg : LipschitzWith Kg g) :\n    LipschitzWith (max Kf Kg) fun x => max (f x) (g x) := by\n  simpa only [(· ∘ ·), one_mul] using lipschitz_with_max.comp (hf.prod hg)\n#align max max\n\n",
 "maps_to_emetric_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem maps_to_emetric_closed_ball (h : LipschitzWith K f) (x : α) (r : ennreal) :\n    MapsTo f (closedBall x r) (closedBall (f x) (K * r)) := fun y hy => h.edist_le_mul_of_le hy\n#align maps_to_emetric_closed_ball maps_to_emetric_closed_ball\n\n",
 "maps_to_emetric_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem maps_to_emetric_ball (h : LipschitzWith K f) (hK : K ≠ 0) (x : α) (r : ennreal) :\n    MapsTo f (ball x r) (ball (f x) (K * r)) := fun y hy => h.edist_lt_mul_of_lt hK hy\n#align maps_to_emetric_ball maps_to_emetric_ball\n\n",
 "maps_to_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem maps_to_closed_ball (hf : LipschitzWith K f) (x : α) (r : exprℝ) :\n    MapsTo f (Metric.closedBall x r) (Metric.closedBall (f x) (K * r)) := fun y hy => hf.dist_le_mul_of_le hy\n#align maps_to_closed_ball maps_to_closed_ball\n\n",
 "maps_to_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem maps_to_ball (hf : LipschitzWith K f) (hK : K ≠ 0) (x : α) (r : exprℝ) :\n    MapsTo f (Metric.ball x r) (Metric.ball (f x) (K * r)) := fun y hy => hf.dist_lt_mul_of_lt hK hy\n#align maps_to_ball maps_to_ball\n\n",
 "list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-- The product of a list of Lipschitz continuous endomorphisms is a Lipschitz continuous\nendomorphism. -/\nprotected theorem list_prod (f : ι → Function.End α) (K : ι → nnreal) (h : ∀ i, LipschitzWith (K i) (f i)) :\n    ∀ l : List ι, LipschitzWith (l.map K).prod (l.map f).prod\n  | [] => by simpa using LipschitzWith.id\n  | sym.cons' i l => by\n    simp only [list.map_cons, List.prod_cons]\n    exact (h i).mul (list_prod l)\n#align list_prod list_prod\n\n",
 "lipschitz_with_min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print lipschitzWith_min /-\ntheorem lipschitzWith_min : LipschitzWith 1 fun p : exprℝ × exprℝ => min p.1 p.2 :=\n  LipschitzWith.of_le_add fun p₁ p₂ => sub_le_iff_le_add'.1 <| (le_abs_self _).trans (abs_min_sub_min_le_max _ _ _ _)\n#align lipschitz_with_min lipschitzWith_min\n-/\n\n",
 "lipschitz_with_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print lipschitzWith_max /-\ntheorem lipschitzWith_max : LipschitzWith 1 fun p : exprℝ × exprℝ => max p.1 p.2 :=\n  LipschitzWith.of_le_add fun p₁ p₂ => sub_le_iff_le_add'.1 <| (le_abs_self _).trans (abs_max_sub_max_le_max _ _ _ _)\n#align lipschitz_with_max lipschitzWith_max\n-/\n\n",
 "lipschitz_on_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print lipschitz_on_univ /-\n@[simp]\ntheorem lipschitz_on_univ [PseudoEMetricSpace α] [PseudoEMetricSpace β] {K : nnreal} {f : α → β} :\n    LipschitzOnWith K f univ ↔ LipschitzWith K f := by simp [LipschitzOnWith, LipschitzWith]\n#align lipschitz_on_univ lipschitz_on_univ\n-/\n\n",
 "lipschitzWith_iff_dist_le_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print lipschitzWith_iff_dist_le_mul /-\n/-\nCopyright (c) 2018 Rohan Mitta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Rohan Mitta, Kevin Buzzard, Alistair Tucker, Johannes Hölzl, Yury Kudryashov\n-/\ntheorem lipschitzWith_iff_dist_le_mul [PseudoMetricSpace α] [PseudoMetricSpace β] {K : nnreal} {f : α → β} :\n    LipschitzWith K f ↔ ∀ x y, dist (f x) (f y) ≤ K * dist x y :=\n  by\n  simp only [LipschitzWith, edist_nndist, dist_nndist]\n  norm_cast\n#align lipschitz_with_iff_dist_le_mul lipschitzWith_iff_dist_le_mul\n-/\n\n",
 "lipschitzOnWith_iff_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print MapsTo.lipschitzOnWith_iff_restrict /-\ntheorem MapsTo.lipschitzOnWith_iff_restrict [PseudoEMetricSpace α] [PseudoEMetricSpace β] {K : nnreal} {f : α → β}\n    {s : Set α} {t : Set β} (h : MapsTo f s t) : LipschitzOnWith K f s ↔ LipschitzWith K (h.restrict f s t) :=\n  lipschitzOnWith_iff_restrict\n#align maps_to.lipschitz_on_with_iff_restrict MapsTo.lipschitzOnWith_iff_restrict\n-/\n\n",
 "lipschitzOnWith_iff_dist_le_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print lipschitzOnWith_iff_dist_le_mul /-\ntheorem lipschitzOnWith_iff_dist_le_mul [PseudoMetricSpace α] [PseudoMetricSpace β] {K : nnreal} {s : Set α}\n    {f : α → β} : LipschitzOnWith K f s ↔ ∀ x ∈ s, ∀ y ∈ s, dist (f x) (f y) ≤ K * dist x y :=\n  by\n  simp only [LipschitzOnWith, edist_nndist, dist_nndist]\n  norm_cast\n#align lipschitz_on_with_iff_dist_le_mul lipschitzOnWith_iff_dist_le_mul\n-/\n\n",
 "lipschitzOnWith_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print lipschitzOnWith_empty /-\n@[simp]\ntheorem lipschitzOnWith_empty [PseudoEMetricSpace α] [PseudoEMetricSpace β] (K : nnreal) (f : α → β) :\n    LipschitzOnWith K f ∅ := fun x x_in y y_in => false.elim x_in\n#align lipschitz_on_with_empty lipschitzOnWith_empty\n-/\n\n",
 "left_of_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem bounded.left_of_prod (h : Bounded (lower_set.prod s t)) (ht : t.nonempty) : Bounded s := by\n  simpa only [fst_image_prod s ht] using (@LipschitzWith.prod_fst α β _ _).bounded_image h\n#align bounded.left_of_prod bounded.left_of_prod\n\n",
 "le_add_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\nprotected theorem le_add_mul {f : α → exprℝ} {K : nnreal} (h : LipschitzOnWith K f s) {x : α} (hx : x ∈ s) {y : α}\n    (hy : y ∈ s) : f x ≤ f y + K * dist x y :=\n  sub_le_iff_le_add'.1 <| le_trans (le_abs_self _) <| h.dist_le_mul x hx y hy\n#align le_add_mul le_add_mul\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\nprotected theorem iterate {f : α → α} (hf : LipschitzWith K f) : ∀ n, LipschitzWith (K ^ n) («expr ^[ ]» f n)\n  | 0 => by simpa only [pow_zero] using LipschitzWith.id\n  | n + 1 => by rw [pow_succ'] <;> exact (iterate n).comp hf\n#align iterate iterate\n\n",
 "iff_le_add_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\nprotected theorem iff_le_add_mul {f : α → exprℝ} {K : nnreal} :\n    LipschitzOnWith K f s ↔ ∀ x ∈ s, ∀ y ∈ s, f x ≤ f y + K * dist x y :=\n  ⟨LipschitzOnWith.le_add_mul, LipschitzOnWith.of_le_add_mul K⟩\n#align iff_le_add_mul iff_le_add_mul\n\n",
 "id":
 "#print id /-\nprotected theorem id : LipschitzWith 1 (@id α) :=\n  LipschitzWith.of_edist_le fun x y => le_rfl\n#align id id\n-/\n\n",
 "extend_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print LipschitzOnWith.extend_real /-\n/-- A function `f : α → ℝ` which is `K`-Lipschitz on a subset `s` admits a `K`-Lipschitz extension\nto the whole space. -/\ntheorem LipschitzOnWith.extend_real [PseudoMetricSpace α] {f : α → exprℝ} {s : Set α} {K : nnreal}\n    (hf : LipschitzOnWith K f s) : ∃ g : α → exprℝ, LipschitzWith K g ∧ EqOn f g s :=\n  by\n  /- An extension is given by `g y = Inf {f x + K * dist y x | x ∈ s}`. Taking `x = y`, one has\n    `g y ≤ f y` for `y ∈ s`, and the other inequality holds because `f` is `K`-Lipschitz, so that it\n    can not counterbalance the growth of `K * dist y x`. One readily checks from the formula that the\n    extended function is also `K`-Lipschitz. -/\n  rcases eq_empty_or_nonempty s with (rfl | hs)\n  · exact ⟨fun x => 0, (LipschitzWith.const _).weaken (zero_le _), eq_on_empty _ _⟩\n  have : Nonempty s := by simp only [hs, nonempty_coe_sort]\n  let g := fun y : α => infᵢ fun x : s => f x + K * dist y x\n  have B : ∀ y : α, BddBelow (range fun x : s => f x + K * dist y x) :=\n    by\n    intro y\n    rcases hs with ⟨z, hz⟩\n    refine' ⟨f z - K * dist y z, _⟩\n    rintro w ⟨t, rfl⟩\n    dsimp\n    rw [sub_le_iff_le_add, add_assoc, ← mul_add, add_comm (dist y t)]\n    calc\n      f z ≤ f t + K * dist z t := hf.le_add_mul hz t.2\n      _ ≤ f t + K * (dist y z + dist y t) :=\n        add_le_add_left (mul_le_mul_of_nonneg_left (dist_triangle_left _ _ _) K.2) _\n      \n  have E : eq_on f g s := by\n    intro x hx\n    refine' le_antisymm (le_cinfᵢ fun y => hf.le_add_mul hx y.2) _\n    simpa only [add_zero, Subtype.coe_mk, MulZeroClass.mul_zero, dist_self] using cinfᵢ_le (B x) ⟨x, hx⟩\n  refine' ⟨g, LipschitzWith.of_le_add_mul K fun x y => _, E⟩\n  rw [← sub_le_iff_le_add]\n  refine' le_cinfᵢ fun z => _\n  rw [sub_le_iff_le_add]\n  calc\n    g x ≤ f z + K * dist x z := cinfᵢ_le (B x) _\n    _ ≤ f z + K * dist y z + K * dist x y :=\n      by\n      rw [add_assoc, ← mul_add, add_comm (dist y z)]\n      exact add_le_add_left (mul_le_mul_of_nonneg_left (dist_triangle _ _ _) K.2) _\n    \n#align lipschitz_on_with.extend_real LipschitzOnWith.extend_real\n-/\n\n",
 "extend_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print LipschitzOnWith.extend_pi /-\n/-- A function `f : α → (ι → ℝ)` which is `K`-Lipschitz on a subset `s` admits a `K`-Lipschitz\nextension to the whole space.\nTODO: state the same result (with the same proof) for the space `ℓ^∞ (ι, ℝ)` over a possibly\ninfinite type `ι`. -/\ntheorem LipschitzOnWith.extend_pi [PseudoMetricSpace α] [Fintype ι] {f : α → ι → exprℝ} {s : Set α} {K : nnreal}\n    (hf : LipschitzOnWith K f s) : ∃ g : α → ι → exprℝ, LipschitzWith K g ∧ EqOn f g s :=\n  by\n  have : ∀ i, ∃ g : α → exprℝ, LipschitzWith K g ∧ eq_on (fun x => f x i) g s :=\n    by\n    intro i\n    have : LipschitzOnWith K (fun x : α => f x i) s :=\n      by\n      apply LipschitzOnWith.of_dist_le_mul fun x hx y hy => _\n      exact (dist_le_pi_dist _ _ i).trans (hf.dist_le_mul x hx y hy)\n    exact this.extend_real\n  choose g hg using this\n  refine' ⟨fun x i => g i x, LipschitzWith.of_dist_le_mul fun x y => _, _⟩\n  · exact (dist_pi_le_iff (mul_nonneg K.2 dist_nonneg)).2 fun i => (hg i).1.dist_le_mul x y\n  · intro x hx\n    ext1 i\n    exact (hg i).2 hx\n#align lipschitz_on_with.extend_pi LipschitzOnWith.extend_pi\n-/\n\n",
 "eval":
 "protected theorem eval {α : ι → Type u} [∀ i, PseudoEMetricSpace (α i)] [Fintype ι] (i : ι) :\n    LipschitzWith 1 (Function.eval i : (∀ i, α i) → α i) :=\n  LipschitzWith.of_edist_le fun f g => by convert edist_le_pi_edist f g i\n#align eval eval\n\n",
 "edist_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print edist_lt_top /-\ntheorem edist_lt_top (hf : LipschitzWith K f) {x y : α} (h : edist x y ≠ «expr⊤») : edist (f x) (f y) < «expr⊤» :=\n  (hf x y).trans_lt <| ENNReal.mul_lt_top ENNReal.coe_ne_top h\n#align edist_lt_top edist_lt_top\n-/\n\n",
 "edist_lt_of_edist_lt_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem edist_lt_of_edist_lt_div (hf : LipschitzOnWith K f s) {x y : α} (hx : x ∈ s) (hy : y ∈ s) {d : ennreal}\n    (hd : edist x y < d / K) : edist (f x) (f y) < d :=\n  (lipschitzOnWith_iff_restrict.mp hf).edist_lt_of_edist_lt_div <| show edist (⟨x, hx⟩ : s) ⟨y, hy⟩ < d / K from hd\n#align edist_lt_of_edist_lt_div edist_lt_of_edist_lt_div\n\n",
 "edist_lt_mul_of_lt":
 "theorem edist_lt_mul_of_lt (h : LipschitzWith K f) (hK : K ≠ 0) (hr : edist x y < r) : edist (f x) (f y) < K * r :=\n  (h x y).trans_lt <| (ENNReal.mul_lt_mul_left (ENNReal.coe_ne_zero.2 hK) ENNReal.coe_ne_top).2 hr\n#align edist_lt_mul_of_lt edist_lt_mul_of_lt\n\n",
 "edist_le_mul_of_le":
 "theorem edist_le_mul_of_le (h : LipschitzWith K f) (hr : edist x y ≤ r) : edist (f x) (f y) ≤ K * r :=\n  (h x y).trans <| ENNReal.mul_left_mono hr\n#align edist_le_mul_of_le edist_le_mul_of_le\n\n",
 "edist_le_mul":
 "theorem edist_le_mul (h : LipschitzWith K f) (x y : α) : edist (f x) (f y) ≤ K * edist x y :=\n  h x y\n#align edist_le_mul edist_le_mul\n\n",
 "edist_iterate_succ_le_geometric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem edist_iterate_succ_le_geometric {f : α → α} (hf : LipschitzWith K f) (x n) :\n    edist ((«expr ^[ ]» f n) x) ((«expr ^[ ]» f (n + 1)) x) ≤ edist x (f x) * K ^ n :=\n  by\n  rw [iterate_succ, mul_comm]\n  simpa only [ENNReal.coe_pow] using (hf.iterate n) x (f x)\n#align edist_iterate_succ_le_geometric edist_iterate_succ_le_geometric\n\n",
 "ediam_image_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem ediam_image_le (hf : LipschitzWith K f) (s : Set α) : EMetric.diam («expr '' » f s) ≤ K * EMetric.diam s :=\n  by\n  apply EMetric.diam_le\n  rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩\n  exact hf.edist_le_mul_of_le (EMetric.edist_le_diam_of_mem hx hy)\n#align ediam_image_le ediam_image_le\n\n",
 "dist_right":
 "protected theorem dist_right (x : α) : LipschitzWith 1 (dist x) :=\n  LipschitzWith.of_le_add fun y z => dist_triangle_right _ _ _\n#align dist_right dist_right\n\n",
 "dist_lt_mul_of_lt":
 "theorem dist_lt_mul_of_lt (hf : LipschitzWith K f) (hK : K ≠ 0) (hr : dist x y < r) : dist (f x) (f y) < K * r :=\n  (hf.dist_le_mul x y).trans_lt <| (mul_lt_mul_left <| NNReal.coe_pos.2 hK.bot_lt).2 hr\n#align dist_lt_mul_of_lt dist_lt_mul_of_lt\n\n",
 "dist_left":
 "protected theorem dist_left (y : α) : LipschitzWith 1 fun x => dist x y :=\n  LipschitzWith.of_le_add fun x z => by\n    rw [add_comm]\n    apply dist_triangle\n#align dist_left dist_left\n\n",
 "dist_le_mul_of_le":
 "theorem dist_le_mul_of_le (hf : LipschitzWith K f) (hr : dist x y ≤ r) : dist (f x) (f y) ≤ K * r :=\n  (hf.dist_le_mul x y).trans <| mul_le_mul_of_nonneg_left hr K.coe_nonneg\n#align dist_le_mul_of_le dist_le_mul_of_le\n\n",
 "dist_iterate_succ_le_geometric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem dist_iterate_succ_le_geometric {f : α → α} (hf : LipschitzWith K f) (x n) :\n    dist ((«expr ^[ ]» f n) x) ((«expr ^[ ]» f (n + 1)) x) ≤ dist x (f x) * K ^ n :=\n  by\n  rw [iterate_succ, mul_comm]\n  simpa only [NNReal.coe_pow] using (hf.iterate n).dist_le_mul x (f x)\n#align dist_iterate_succ_le_geometric dist_iterate_succ_le_geometric\n\n",
 "dist":
 "protected theorem dist : LipschitzWith 2 (function.uncurry <| @dist α _) :=\n  LipschitzWith.uncurry LipschitzWith.dist_left LipschitzWith.dist_right\n#align dist dist\n\n",
 "diam_image_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem diam_image_le (hf : LipschitzWith K f) (s : Set α) (hs : Metric.Bounded s) :\n    Metric.diam («expr '' » f s) ≤ K * Metric.diam s :=\n  Metric.diam_le_of_forall_dist_le (mul_nonneg K.coe_nonneg Metric.diam_nonneg) <|\n    ball_image_iff.2 fun x hx =>\n      ball_image_iff.2 fun y hy => hf.dist_le_mul_of_le <| Metric.dist_le_diam_of_mem hs hx hy\n#align diam_image_le diam_image_le\n\n",
 "continuous_prod_of_continuous_lipschitz":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print continuous_prod_of_continuous_lipschitz /-\n/-- Consider a function `f : α × β → γ`. Suppose that it is continuous on each “vertical section”\n`{a} × univ`, `a : α`, and is Lipschitz continuous on each “horizontal section”\n`univ × {b}`, `b : β` with the same Lipschitz constant `K`. Then it is continuous.\n\nThe actual statement uses (Lipschitz) continuity of `λ y, f (a, y)` and `λ x, f (x, b)` instead\nof continuity of `f` on subsets of the product space. -/\ntheorem continuous_prod_of_continuous_lipschitz [PseudoEMetricSpace α] [TopologicalSpace β] [PseudoEMetricSpace γ]\n    (f : α × β → γ) (K : nnreal) (ha : ∀ a, Continuous fun y => f (a, y))\n    (hb : ∀ b, LipschitzWith K fun x => f (x, b)) : Continuous f :=\n  by\n  simp only [continuous_iff_continuousOn_univ, ← univ_prod_univ, ← lipschitz_on_univ] at *\n  exact continuousOn_prod_of_continuousOn_lipschitz_on f K (fun a _ => ha a) fun b _ => hb b\n#align continuous_prod_of_continuous_lipschitz continuous_prod_of_continuous_lipschitz\n-/\n\n",
 "continuousOn_prod_of_continuousOn_lipschitz_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print continuousOn_prod_of_continuousOn_lipschitz_on /-\n/-- Consider a function `f : α × β → γ`. Suppose that it is continuous on each “vertical fiber”\n`{a} × t`, `a ∈ s`, and is Lipschitz continuous on each “horizontal fiber” `s × {b}`, `b ∈ t`\nwith the same Lipschitz constant `K`. Then it is continuous on `s × t`.\n\nThe actual statement uses (Lipschitz) continuity of `λ y, f (a, y)` and `λ x, f (x, b)` instead\nof continuity of `f` on subsets of the product space. -/\ntheorem continuousOn_prod_of_continuousOn_lipschitz_on [PseudoEMetricSpace α] [TopologicalSpace β]\n    [PseudoEMetricSpace γ] (f : α × β → γ) {s : Set α} {t : Set β} (K : nnreal)\n    (ha : ∀ a ∈ s, ContinuousOn (fun y => f (a, y)) t) (hb : ∀ b ∈ t, LipschitzOnWith K (fun x => f (x, b)) s) :\n    ContinuousOn f (lower_set.prod s t) :=\n  by\n  rintro ⟨x, y⟩ ⟨hx : x ∈ s, hy : y ∈ t⟩\n  refine' EMetric.tendsto_nhds.2 fun ε (ε0 : 0 < ε) => _\n  replace ε0 : 0 < ε / 2 := ENNReal.half_pos (ne_of_gt ε0)\n  have εK : 0 < ε / 2 / K := ENNReal.div_pos_iff.2 ⟨ε0.ne', ENNReal.coe_ne_top⟩\n  have A : s ∩ EMetric.ball x (ε / 2 / K) ∈ nhds_within s x := inter_mem_nhdsWithin _ (EMetric.ball_mem_nhds _ εK)\n  have B : { b : β | b ∈ t ∧ edist (f (x, b)) (f (x, y)) < ε / 2 } ∈ nhds_within t y :=\n    inter_mem self_mem_nhdsWithin (ha x hx y hy (EMetric.ball_mem_nhds _ ε0))\n  filter_upwards [nhdsWithin_prod A B]\n  rintro ⟨a, b⟩ ⟨⟨has : a ∈ s, hax : edist a x < ε / 2 / K⟩, hbt : b ∈ t, hby : edist (f (x, b)) (f (x, y)) < ε / 2⟩\n  calc\n    edist (f (a, b)) (f (x, y)) ≤ edist (f (a, b)) (f (x, b)) + edist (f (x, b)) (f (x, y)) := edist_triangle _ _ _\n    _ < ε / 2 + ε / 2 := (ENNReal.add_lt_add ((hb _ hbt).edist_lt_of_edist_lt_div has hx hax) hby)\n    _ = ε := ENNReal.add_halves ε\n    \n#align continuous_on_prod_of_continuous_on_lipschitz_on continuousOn_prod_of_continuousOn_lipschitz_on\n-/\n\n",
 "continuousAt_of_locally_lipschitz":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print continuousAt_of_locally_lipschitz /-\n/-- If a function is locally Lipschitz around a point, then it is continuous at this point. -/\ntheorem continuousAt_of_locally_lipschitz [PseudoMetricSpace α] [PseudoMetricSpace β] {f : α → β} {x : α} {r : exprℝ}\n    (hr : 0 < r) (K : exprℝ) (h : ∀ y, dist y x < r → dist (f y) (f x) ≤ K * dist y x) : ContinuousAt f x :=\n  by\n  -- We use `h` to squeeze `dist (f y) (f x)` between `0` and `K * dist y x`\n  refine'\n    tendsto_iff_dist_tendsto_zero.2\n      (squeeze_zero' (eventually_of_forall fun _ => dist_nonneg) (mem_of_superset (ball_mem_nhds _ hr) h) _)\n  -- Then show that `K * dist y x` tends to zero as `y → x`\n  refine' (continuous_const.mul (continuous_id.dist continuous_const)).tendsto' _ _ _\n  simp\n#align continuous_at_of_locally_lipschitz continuousAt_of_locally_lipschitz\n-/\n\n",
 "const_min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem const_min (hf : LipschitzWith Kf f) (a : exprℝ) : LipschitzWith Kf fun x => min a (f x) := by\n  simpa only [min_comm] using hf.min_const a\n#align const_min const_min\n\n",
 "const_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem const_max (hf : LipschitzWith Kf f) (a : exprℝ) : LipschitzWith Kf fun x => max a (f x) := by\n  simpa only [max_comm] using hf.max_const a\n#align const_max const_max\n\n",
 "const":
 "protected theorem const (b : β) : LipschitzWith 0 fun a : α => b := fun x y => by simp only [edist_self, zero_le]\n#align const const\n\n",
 "comp_lipschitz_on_with":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem comp_lipschitz_on_with {Kf Kg : nnreal} {f : β → γ} {g : α → β} {s : Set α} (hf : LipschitzWith Kf f)\n    (hg : LipschitzOnWith Kg g s) : LipschitzOnWith (Kf * Kg) (f ∘ g) s :=\n  lipschitzOnWith_iff_restrict.mpr <| hf.comp hg.to_restrict\n#align comp_lipschitz_on_with comp_lipschitz_on_with\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\nprotected theorem comp {g : β → γ} {t : Set β} {Kg : nnreal} (hg : LipschitzOnWith Kg g t) (hf : LipschitzOnWith K f s)\n    (hmaps : MapsTo f s t) : LipschitzOnWith (Kg * K) (g ∘ f) s :=\n  lipschitzOnWith_iff_restrict.mpr <| hg.to_restrict.comp (hf.to_restrict_maps_to hmaps)\n#align comp comp\n\n",
 "comap_cobounded_le":
 "theorem comap_cobounded_le (hf : LipschitzWith K f) : comap f (Bornology.cobounded β) ≤ Bornology.cobounded α :=\n  (hf.to_locally_bounded_map f).2\n#align comap_cobounded_le comap_cobounded_le\n\n",
 "coe_to_locally_bounded_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_to_locally_bounded_map (hf : LipschitzWith K f) : «expr⇑ » (hf.to_locally_bounded_map f) = f :=\n  rfl\n#align coe_to_locally_bounded_map coe_to_locally_bounded_map\n\n",
 "bounded_prod_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem bounded_prod_of_nonempty (hs : s.nonempty) (ht : t.nonempty) :\n    Bounded (lower_set.prod s t) ↔ Bounded s ∧ Bounded t :=\n  ⟨fun h => ⟨h.left_of_prod ht, h.right_of_prod hs⟩, fun h => h.1.prod h.2⟩\n#align bounded_prod_of_nonempty bounded_prod_of_nonempty\n\n",
 "bounded_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem bounded_prod : Bounded (lower_set.prod s t) ↔ s = ∅ ∨ t = ∅ ∨ Bounded s ∧ Bounded t :=\n  by\n  rcases s.eq_empty_or_nonempty with (rfl | hs); · simp\n  rcases t.eq_empty_or_nonempty with (rfl | ht); · simp\n  simp only [bounded_prod_of_nonempty hs ht, hs.ne_empty, ht.ne_empty, false_or_iff]\n#align bounded_prod bounded_prod\n\n",
 "bounded_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem bounded_image (hf : LipschitzWith K f) {s : Set α} (hs : Metric.Bounded s) : Metric.Bounded («expr '' » f s) :=\n  Metric.bounded_iff_ediam_ne_top.2 <|\n    ne_top_of_le_ne_top (ENNReal.mul_ne_top ENNReal.coe_ne_top hs.ediam_ne_top) (hf.ediam_image_le s)\n#align bounded_image bounded_image\n\n",
 "UniformContinuousOn":
 "#print UniformContinuousOn /-\nprotected theorem UniformContinuousOn (hf : LipschitzOnWith K f s) : UniformContinuousOn f s :=\n  uniformContinuousOn_iff_restrict.mpr (lipschitzOnWith_iff_restrict.mp hf).uniform_continuous\n#align uniform_continuous_on UniformContinuousOn\n-/\n\n",
 "UniformContinuous":
 "#print UniformContinuous /-\n/-- A Lipschitz function is uniformly continuous -/\nprotected theorem UniformContinuous (hf : LipschitzWith K f) : UniformContinuous f :=\n  by\n  refine' EMetric.uniformContinuous_iff.2 fun ε εpos => _\n  use ε / K, ENNReal.div_pos_iff.2 ⟨ne_of_gt εpos, ENNReal.coe_ne_top⟩\n  exact fun x y => hf.edist_lt_of_edist_lt_div\n#align uniform_continuous UniformContinuous\n-/\n\n",
 "Prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n#print Prod /-\nprotected theorem Prod {f : α → β} {Kf : nnreal} (hf : LipschitzWith Kf f) {g : α → γ} {Kg : nnreal}\n    (hg : LipschitzWith Kg g) : LipschitzWith (max Kf Kg) fun x => (f x, g x) :=\n  by\n  intro x y\n  rw [ennreal.coe_mono.map_max, Prod.edist_eq, ENNReal.max_mul]\n  exact max_le_max (hf x y) (hg x y)\n#align prod Prod\n-/\n\n",
 "LipschitzOnWith":
 "#print LipschitzOnWith /-\nprotected theorem LipschitzOnWith (h : LipschitzWith K f) (s : Set α) : LipschitzOnWith K f s := fun x _ y _ => h x y\n#align lipschitz_on_with LipschitzOnWith\n-/\n\n",
 "ContinuousOn":
 "#print ContinuousOn /-\nprotected theorem ContinuousOn (hf : LipschitzOnWith K f s) : ContinuousOn f s :=\n  hf.uniform_continuous_on.continuous_on\n#align continuous_on ContinuousOn\n-/\n\n",
 "Continuous":
 "#print Continuous /-\n/-- A Lipschitz function is continuous -/\nprotected theorem Continuous (hf : LipschitzWith K f) : Continuous f :=\n  hf.uniform_continuous.continuous\n#align continuous Continuous\n-/\n\n"}