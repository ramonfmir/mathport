{"polish_space_induced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/-- Pulling back a Polish topology under an equiv gives again a Polish topology. -/\ntheorem _root_.equiv.polish_space_induced [t : topological_space β] [polish_space β] (f : «expr ≃ » α β) :\n    @polish_space α (t.induced f) :=\n  letI : topological_space α := t.induced f\n  (f.to_homeomorph_of_inducing ⟨rfl⟩).closed_embedding.polish_space\n#align equiv.polish_space_induced equiv.polish_space_induced\n\n",
 "polish_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- An open subset of a Polish space is also Polish. -/\ntheorem _root_.is_open.polish_space {α : Type _} [topological_space α] [polish_space α] {s : set α} (hs : is_open s) :\n    polish_space s := by\n  rcases eq_empty_or_nonempty («expr ᶜ» s) with (h's | h's)\n  · simp at h's\n    apply is_closed.polish_space\n    rw [h's]\n    exact is_closed_univ\n  · letI := upgrade_polish_space α\n    haveI : complete_space (complete_copy s) := complete_space_complete_copy hs h's\n    haveI : second_countable_topology (complete_copy s) :=\n      (complete_copy_id_homeo hs h's).embedding.second_countable_topology\n    exact (complete_copy_id_homeo hs h's).symm.closed_embedding.polish_space\n#align is_open.polish_space is_open.polish_space\n\n",
 "is_clopenable":
 "theorem _root_.is_open.is_clopenable [topological_space α] [polish_space α] {s : set α} (hs : is_open s) :\n    is_clopenable s := by simpa using hs.is_closed_compl.is_clopenable.compl\n#align is_open.is_clopenable is_open.is_clopenable\n\n",
 "exists_polish_space_forall_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- Given a Polish space, and countably many finer Polish topologies, there exists another Polish\ntopology which is finer than all of them. -/\ntheorem exists_polish_space_forall_le {ι : Type _} [countable ι] [t : topological_space α] [p : polish_space α]\n    (m : ι → topological_space α) (hm : ∀ n, m n ≤ t) (h'm : ∀ n, @polish_space α (m n)) :\n    ∃ t' : topological_space α, (∀ n, t' ≤ m n) ∧ t' ≤ t ∧ @polish_space α t' :=\n  by\n  rcases isEmpty_or_nonempty ι with (hι | hι)\n  · exact ⟨t, fun i => (is_empty.elim hι i : _), le_rfl, p⟩\n  inhabit ι\n  /- Consider the product of infinitely many copies of `α`, each endowed with the topology `m n`.\n    This is a Polish space, as a product of Polish spaces. Pulling back this topology under the\n    diagonal embedding of `α`, one gets a Polish topology which is finer than all the `m n`. -/\n  letI : ∀ n : ι, topological_space (aux_copy α n) := fun n => m n\n  haveI : ∀ n : ι, polish_space (aux_copy α n) := fun n => h'm n\n  letI T : topological_space (∀ n : ι, aux_copy α n) := by infer_instance\n  let f : α → ∀ n : ι, aux_copy α n := fun x n => x\n  -- show that the induced topology is finer than all the `m n`.\n  have T_le_m : ∀ n, T.induced f ≤ m n := by\n    intro n s hs\n    refine' ⟨Set.pi ({n} : set ι) fun i => s, _, _⟩\n    · apply is_open_set_pi (finite_singleton _)\n      intro a ha\n      rw [mem_singleton_iff.1 ha]\n      exact hs\n    · ext x\n      simp only [singleton_pi, mem_preimage]\n  refine' ⟨T.induced f, fun n => T_le_m n, (T_le_m default).trans (hm default), _⟩\n  -- show that the new topology is Polish, as the pullback of a Polish topology under a closed\n  -- embedding.\n  have A :\n    range f =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        { x | x n = x default } :=\n    by\n    ext x\n    constructor\n    · rintro ⟨y, rfl⟩\n      exact mem_Inter.2 fun n => by simp only [mem_set_of_eq]\n    · intro hx\n      refine' ⟨x default, _⟩\n      ext1 n\n      symm\n      exact (mem_Inter.1 hx n : _)\n  have f_closed : is_closed (range f) := by\n    rw [A]\n    apply is_closed_Inter fun n => _\n    have C : ∀ i : ι, continuous fun x : ∀ n, aux_copy α n => (id (x i) : α) :=\n      by\n      intro i\n      apply continuous.comp _ (continuous_apply i)\n      apply continuous_def.2 fun s hs => _\n      exact hm i s hs\n    apply is_closed_eq (C n) (C default)\n  have K : @_root_.embedding _ _ (T.induced f) T f :=\n    by\n    apply function.injective.embedding_induced\n    intro x y hxy\n    have : f x default = f y default := by rw [hxy]\n    exact this\n  have L : @closed_embedding _ _ (T.induced f) T f := by\n    constructor\n    · exact K\n    · exact f_closed\n  exact @closed_embedding.polish_space _ _ (T.induced f) T (by infer_instance) _ L\n#align exists_polish_space_forall_le exists_polish_space_forall_le\n\n",
 "exists_nat_nat_continuous_surjective":
 "/-- Any nonempty Polish space is the continuous image of the fundamental space `ℕ → ℕ`. -/\ntheorem exists_nat_nat_continuous_surjective (α : Type _) [topological_space α] [polish_space α] [nonempty α] :\n    ∃ f : (ℕ → ℕ) → α, continuous f ∧ surjective f :=\n  letI := upgrade_polish_space α\n  exists_nat_nat_continuous_surjective_of_complete_space α\n#align exists_nat_nat_continuous_surjective exists_nat_nat_continuous_surjective\n\n",
 "dist_le_dist_complete_copy":
 "theorem dist_le_dist_complete_copy (x y : complete_copy s) : dist x.1 y.1 ≤ dist x y :=\n  (le_add_iff_nonneg_right _).2 (abs_nonneg _)\n#align dist_le_dist_complete_copy dist_le_dist_complete_copy\n\n",
 "dist_complete_copy_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem dist_complete_copy_eq (x y : complete_copy s) :\n    dist x y = dist x.1 y.1 + abs (1 / inf_dist x.1 («expr ᶜ» s) - 1 / inf_dist y.1 («expr ᶜ» s)) :=\n  rfl\n#align dist_complete_copy_eq dist_complete_copy_eq\n\n",
 "complete_space_complete_copy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem complete_space_complete_copy [complete_space α] (hs : is_open s) (h's : («expr ᶜ» s).nonempty) :\n    complete_space (complete_copy s) :=\n  by\n  refine' metric.complete_of_convergent_controlled_sequences (fun n => (1 / 2) ^ n) (by simp) _\n  intro u hu\n  have A : cauchy_seq fun n => (u n).1 :=\n    by\n    apply cauchy_seq_of_le_tendsto_0 (fun n : ℕ => (1 / 2) ^ n) (fun n m N hNn hNm => _) _\n    · exact (dist_le_dist_complete_copy (u n) (u m)).trans (hu N n m hNn hNm).le\n    · exact tendsto_pow_at_top_nhds_0_of_lt_1 (by norm_num) (by norm_num)\n  obtain ⟨x, xlim⟩ : ∃ x, tendsto (fun n => (u n).1) at_top ((nhds) x) :=\n    haveI : nonempty α := ⟨(u 0).1⟩\n    ⟨_, A.tendsto_lim⟩\n  suffices xs : x ∈ s\n  · refine' ⟨⟨x, xs⟩, _⟩\n    have L : tendsto (fun n => (id ⟨(u n).1, (u n).2⟩ : s)) at_top ((nhds) ⟨x, xs⟩) :=\n      by\n      apply embedding_subtype_coe.tendsto_nhds_iff.2\n      exact xlim\n    convert ((complete_copy_id_homeo hs h's).symm.continuous.tendsto _).comp L\n    ext1 n\n    simp [complete_copy_id_homeo]\n  obtain ⟨C, hC⟩ : ∃ C, ∀ n, 1 / inf_dist (u n).1 («expr ᶜ» s) < C :=\n    by\n    refine' ⟨(1 / 2) ^ 0 + dist (1 / inf_dist (u 0).1 («expr ᶜ» s)) 0, fun n => _⟩\n    calc\n      1 / inf_dist (u n).val («expr ᶜ» s) ≤ dist (1 / inf_dist (u n).val («expr ᶜ» s)) 0 :=\n        by\n        rw [real.dist_0_eq_abs]\n        exact le_abs_self _\n      _ ≤\n          dist (1 / inf_dist (u n).1 («expr ᶜ» s)) (1 / inf_dist (u 0).1 («expr ᶜ» s)) +\n            dist (1 / inf_dist (u 0).1 («expr ᶜ» s)) 0 :=\n        dist_triangle _ _ _\n      _ ≤\n          dist (u n).1 (u 0).1 + dist (1 / inf_dist (u n).1 («expr ᶜ» s)) (1 / inf_dist (u 0).1 («expr ᶜ» s)) +\n            dist (1 / inf_dist (u 0).1 («expr ᶜ» s)) 0 :=\n        add_le_add (le_add_of_nonneg_left dist_nonneg) le_rfl\n      _ = dist (u n) (u 0) + dist (1 / inf_dist (u 0).1 («expr ᶜ» s)) 0 := rfl\n      _ < (1 / 2) ^ 0 + dist (1 / inf_dist (u 0).1 («expr ᶜ» s)) 0 := add_lt_add_right (hu 0 n 0 (zero_le _) le_rfl) _\n      \n  have Cpos : 0 < C := by\n    apply lt_of_le_of_lt _ (hC 0)\n    simp [inf_dist_nonneg]\n  have I : ∀ n, 1 / C ≤ inf_dist (u n).1 («expr ᶜ» s) := by\n    intro n\n    have : 0 < inf_dist (u n).val («expr ᶜ» s) :=\n      by\n      apply (hs.is_closed_compl.not_mem_iff_inf_dist_pos h's).1\n      simp\n    rw [div_le_iff' Cpos]\n    exact (div_le_iff this).1 (hC n).le\n  have I' : 1 / C ≤ inf_dist x («expr ᶜ» s) :=\n    haveI : tendsto (fun n => inf_dist (u n).1 («expr ᶜ» s)) at_top ((nhds) (inf_dist x («expr ᶜ» s))) :=\n      ((continuous_inf_dist_pt («expr ᶜ» s)).tendsto x).comp xlim\n    ge_of_tendsto' this I\n  suffices x ∉ «expr ᶜ» s by simpa\n  apply (hs.is_closed_compl.not_mem_iff_inf_dist_pos h's).2 (lt_of_lt_of_le _ I')\n  simp [Cpos]\n#align complete_space_complete_copy complete_space_complete_copy\n\n",
 "complete_polish_space_metric":
 "/-\nCopyright (c) 2022 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\ntheorem complete_polish_space_metric (α : Type _) [ht : topological_space α] [h : polish_space α] :\n    @complete_space α (polish_space_metric α).to_uniform_space :=\n  by\n  convert h.complete.some_spec.2\n  exact metric_space.replace_topology_eq _ _\n#align complete_polish_space_metric complete_polish_space_metric\n\n",
 "compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_clopenable.compl [topological_space α] {s : set α} (hs : is_clopenable s) : is_clopenable («expr ᶜ» s) :=\n  by\n  rcases hs with ⟨t, t_le, t_polish, h, h'⟩\n  exact ⟨t, t_le, t_polish, @is_open.is_closed_compl α t s h', @is_closed.is_open_compl α t s h⟩\n#align is_clopenable.compl is_clopenable.compl\n\n",
 "Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_clopenable.Union [t : topological_space α] [polish_space α] {s : ℕ → set α} (hs : ∀ n, is_clopenable (s n)) :\n    is_clopenable\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) :=\n  by\n  choose m mt m_polish m_closed m_open using hs\n  obtain ⟨t', t'm, -, t'_polish⟩ : ∃ t' : topological_space α, (∀ n : ℕ, t' ≤ m n) ∧ t' ≤ t ∧ @polish_space α t' :=\n    exists_polish_space_forall_le m mt m_polish\n  have A :\n    @is_open α t'\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) :=\n    by\n    apply is_open_Union\n    intro n\n    apply t'm n\n    exact m_open n\n  obtain ⟨t'', t''_le, t''_polish, h1, h2⟩ :\n    ∃ t'' : topological_space α,\n      t'' ≤ t' ∧\n        @polish_space α t'' ∧\n          @is_closed α t''\n              («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) ∧\n            @is_open α t''\n              («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) :=\n    @is_open.is_clopenable α t' t'_polish _ A\n  exact ⟨t'', t''_le.trans ((t'm 0).trans (mt 0)), t''_polish, h1, h2⟩\n#align is_clopenable.Union is_clopenable.Union\n\n"}