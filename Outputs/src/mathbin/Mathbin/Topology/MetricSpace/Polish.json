{"polish_space_induced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n#print Equiv.polishSpace_induced /-\n/-- Pulling back a Polish topology under an equiv gives again a Polish topology. -/\ntheorem Equiv.polishSpace_induced [t : TopologicalSpace β] [PolishSpace β] (f : «expr ≃ » α β) :\n    @PolishSpace α (t.induced f) :=\n  letI : TopologicalSpace α := t.induced f\n  (f.to_homeomorph_of_inducing ⟨rfl⟩).closed_embedding.polish_space\n#align equiv.polish_space_induced Equiv.polishSpace_induced\n-/\n\n",
 "polish_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print IsOpen.polishSpace /-\n/-- An open subset of a Polish space is also Polish. -/\ntheorem IsOpen.polishSpace {α : Type _} [TopologicalSpace α] [PolishSpace α] {s : Set α} (hs : IsOpen s) :\n    PolishSpace s := by\n  rcases eq_empty_or_nonempty («expr ᶜ» s) with (h's | h's)\n  · simp at h's\n    apply IsClosed.polishSpace\n    rw [h's]\n    exact isClosed_univ\n  · letI := upgradePolishSpace α\n    haveI : CompleteSpace (complete_copy s) := complete_space_complete_copy hs h's\n    haveI : second_countable_topology (complete_copy s) :=\n      (complete_copy_id_homeo hs h's).embedding.second_countable_topology\n    exact (complete_copy_id_homeo hs h's).symm.closed_embedding.polish_space\n#align is_open.polish_space IsOpen.polishSpace\n-/\n\n",
 "is_clopenable":
 "#print IsOpen.isClopenable /-\ntheorem IsOpen.isClopenable [TopologicalSpace α] [PolishSpace α] {s : Set α} (hs : IsOpen s) : IsClopenable s := by\n  simpa using hs.is_closed_compl.is_clopenable.compl\n#align is_open.is_clopenable IsOpen.isClopenable\n-/\n\n",
 "exists_polish_space_forall_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- Given a Polish space, and countably many finer Polish topologies, there exists another Polish\ntopology which is finer than all of them. -/\ntheorem exists_polish_space_forall_le {ι : Type _} [Countable ι] [t : TopologicalSpace α] [p : PolishSpace α]\n    (m : ι → TopologicalSpace α) (hm : ∀ n, m n ≤ t) (h'm : ∀ n, @PolishSpace α (m n)) :\n    ∃ t' : TopologicalSpace α, (∀ n, t' ≤ m n) ∧ t' ≤ t ∧ @PolishSpace α t' :=\n  by\n  rcases isEmpty_or_nonempty ι with (hι | hι)\n  · exact ⟨t, fun i => (IsEmpty.elim hι i : _), le_rfl, p⟩\n  inhabit ι\n  /- Consider the product of infinitely many copies of `α`, each endowed with the topology `m n`.\n    This is a Polish space, as a product of Polish spaces. Pulling back this topology under the\n    diagonal embedding of `α`, one gets a Polish topology which is finer than all the `m n`. -/\n  letI : ∀ n : ι, TopologicalSpace (aux_copy α n) := fun n => m n\n  haveI : ∀ n : ι, PolishSpace (aux_copy α n) := fun n => h'm n\n  letI T : TopologicalSpace (∀ n : ι, aux_copy α n) := by infer_instance\n  let f : α → ∀ n : ι, aux_copy α n := fun x n => x\n  -- show that the induced topology is finer than all the `m n`.\n  have T_le_m : ∀ n, T.induced f ≤ m n := by\n    intro n s hs\n    refine' ⟨Set.pi ({n} : Set ι) fun i => s, _, _⟩\n    · apply isOpen_set_pi (finite_singleton _)\n      intro a ha\n      rw [mem_singleton_iff.1 ha]\n      exact hs\n    · ext x\n      simp only [singleton_pi, mem_preimage]\n  refine' ⟨T.induced f, fun n => T_le_m n, (T_le_m default).trans (hm default), _⟩\n  -- show that the new topology is Polish, as the pullback of a Polish topology under a closed\n  -- embedding.\n  have A :\n    range f =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        { x | x n = x default } :=\n    by\n    ext x\n    constructor\n    · rintro ⟨y, rfl⟩\n      exact mem_Inter.2 fun n => by simp only [mem_set_of_eq]\n    · intro hx\n      refine' ⟨x default, _⟩\n      ext1 n\n      symm\n      exact (mem_Inter.1 hx n : _)\n  have f_closed : IsClosed (range f) := by\n    rw [A]\n    apply isClosed_interᵢ fun n => _\n    have C : ∀ i : ι, Continuous fun x : ∀ n, aux_copy α n => (id (x i) : α) :=\n      by\n      intro i\n      apply Continuous.comp _ (continuous_apply i)\n      apply continuous_def.2 fun s hs => _\n      exact hm i s hs\n    apply isClosed_eq (C n) (C default)\n  have K : @_root_.embedding _ _ (T.induced f) T f :=\n    by\n    apply Function.Injective.embedding_induced\n    intro x y hxy\n    have : f x default = f y default := by rw [hxy]\n    exact this\n  have L : @ClosedEmbedding _ _ (T.induced f) T f := by\n    constructor\n    · exact K\n    · exact f_closed\n  exact @ClosedEmbedding.polishSpace _ _ (T.induced f) T (by infer_instance) _ L\n#align exists_polish_space_forall_le exists_polish_space_forall_le\n\n",
 "exists_nat_nat_continuous_surjective":
 "/-- Any nonempty Polish space is the continuous image of the fundamental space `ℕ → ℕ`. -/\ntheorem exists_nat_nat_continuous_surjective (α : Type _) [TopologicalSpace α] [PolishSpace α] [Nonempty α] :\n    ∃ f : (ℕ → ℕ) → α, Continuous f ∧ surjective f :=\n  letI := upgradePolishSpace α\n  exists_nat_nat_continuous_surjective_of_completeSpace α\n#align exists_nat_nat_continuous_surjective exists_nat_nat_continuous_surjective\n\n",
 "dist_le_dist_complete_copy":
 "theorem dist_le_dist_complete_copy (x y : TopologicalSpace.Opens.CompleteCopy s) : dist x.1 y.1 ≤ dist x y :=\n  (le_add_iff_nonneg_right _).2 (abs_nonneg _)\n#align dist_le_dist_complete_copy dist_le_dist_complete_copy\n\n",
 "dist_complete_copy_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem dist_complete_copy_eq (x y : TopologicalSpace.Opens.CompleteCopy s) :\n    dist x y = dist x.1 y.1 + abs (1 / infDist x.1 («expr ᶜ» s) - 1 / infDist y.1 («expr ᶜ» s)) :=\n  rfl\n#align dist_complete_copy_eq dist_complete_copy_eq\n\n",
 "complete_space_complete_copy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem complete_space_complete_copy [CompleteSpace α] (hs : IsOpen s) (h's : («expr ᶜ» s).nonempty) :\n    CompleteSpace (TopologicalSpace.Opens.CompleteCopy s) :=\n  by\n  refine' Metric.complete_of_convergent_controlled_sequences (fun n => (1 / 2) ^ n) (by simp) _\n  intro u hu\n  have A : CauchySeq fun n => (u n).1 :=\n    by\n    apply cauchySeq_of_le_tendsto_0 (fun n : ℕ => (1 / 2) ^ n) (fun n m N hNn hNm => _) _\n    · exact (dist_le_dist_complete_copy (u n) (u m)).trans (hu N n m hNn hNm).le\n    · exact tendsto_pow_atTop_nhds_0_of_lt_1 (by norm_num) (by norm_num)\n  obtain ⟨x, xlim⟩ : ∃ x, tendsto (fun n => (u n).1) at_top ((nhds) x) :=\n    haveI : Nonempty α := ⟨(u 0).1⟩\n    ⟨_, A.tendsto_lim⟩\n  suffices xs : x ∈ s\n  · refine' ⟨⟨x, xs⟩, _⟩\n    have L : tendsto (fun n => (id ⟨(u n).1, (u n).2⟩ : s)) at_top ((nhds) ⟨x, xs⟩) :=\n      by\n      apply embedding_subtype_coe.tendsto_nhds_iff.2\n      exact xlim\n    convert((complete_copy_id_homeo hs h's).symm.continuous.tendsto _).comp L\n    ext1 n\n    simp [complete_copy_id_homeo]\n  obtain ⟨C, hC⟩ : ∃ C, ∀ n, 1 / inf_dist (u n).1 («expr ᶜ» s) < C :=\n    by\n    refine' ⟨(1 / 2) ^ 0 + dist (1 / inf_dist (u 0).1 («expr ᶜ» s)) 0, fun n => _⟩\n    calc\n      1 / inf_dist (u n).val («expr ᶜ» s) ≤ dist (1 / inf_dist (u n).val («expr ᶜ» s)) 0 :=\n        by\n        rw [Real.dist_0_eq_abs]\n        exact le_abs_self _\n      _ ≤\n          dist (1 / inf_dist (u n).1 («expr ᶜ» s)) (1 / inf_dist (u 0).1 («expr ᶜ» s)) +\n            dist (1 / inf_dist (u 0).1 («expr ᶜ» s)) 0 :=\n        (dist_triangle _ _ _)\n      _ ≤\n          dist (u n).1 (u 0).1 + dist (1 / inf_dist (u n).1 («expr ᶜ» s)) (1 / inf_dist (u 0).1 («expr ᶜ» s)) +\n            dist (1 / inf_dist (u 0).1 («expr ᶜ» s)) 0 :=\n        (add_le_add (le_add_of_nonneg_left dist_nonneg) le_rfl)\n      _ = dist (u n) (u 0) + dist (1 / inf_dist (u 0).1 («expr ᶜ» s)) 0 := rfl\n      _ < (1 / 2) ^ 0 + dist (1 / inf_dist (u 0).1 («expr ᶜ» s)) 0 := add_lt_add_right (hu 0 n 0 (zero_le _) le_rfl) _\n      \n  have Cpos : 0 < C := by\n    apply lt_of_le_of_lt _ (hC 0)\n    simp [inf_dist_nonneg]\n  have I : ∀ n, 1 / C ≤ inf_dist (u n).1 («expr ᶜ» s) := by\n    intro n\n    have : 0 < inf_dist (u n).val («expr ᶜ» s) :=\n      by\n      apply (hs.is_closed_compl.not_mem_iff_inf_dist_pos h's).1\n      simp\n    rw [div_le_iff' Cpos]\n    exact (div_le_iff this).1 (hC n).le\n  have I' : 1 / C ≤ inf_dist x («expr ᶜ» s) :=\n    haveI : tendsto (fun n => inf_dist (u n).1 («expr ᶜ» s)) at_top ((nhds) (inf_dist x («expr ᶜ» s))) :=\n      ((continuous_inf_dist_pt («expr ᶜ» s)).tendsto x).comp xlim\n    ge_of_tendsto' this I\n  suffices x ∉ «expr ᶜ» s by simpa\n  apply (hs.is_closed_compl.not_mem_iff_inf_dist_pos h's).2 (lt_of_lt_of_le _ I')\n  simp [Cpos]\n#align complete_space_complete_copy complete_space_complete_copy\n\n",
 "complete_polishSpaceMetric":
 "#print complete_polishSpaceMetric /-\n/-\nCopyright (c) 2022 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\ntheorem complete_polishSpaceMetric (α : Type _) [ht : TopologicalSpace α] [h : PolishSpace α] :\n    @CompleteSpace α (polishSpaceMetric α).to_uniform_space :=\n  by\n  convert h.complete.some_spec.2\n  exact MetricSpace.replaceTopology_eq _ _\n#align complete_polish_space_metric complete_polishSpaceMetric\n-/\n\n",
 "compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_clopenable.compl [TopologicalSpace α] {s : Set α} (hs : IsClopenable s) : IsClopenable («expr ᶜ» s) :=\n  by\n  rcases hs with ⟨t, t_le, t_polish, h, h'⟩\n  exact ⟨t, t_le, t_polish, @IsOpen.isClosed_compl α t s h', @is_closed.is_open_compl α t s h⟩\n#align is_clopenable.compl is_clopenable.compl\n\n",
 "Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_closed_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_clopenable.Union [t : TopologicalSpace α] [PolishSpace α] {s : ℕ → Set α} (hs : ∀ n, IsClopenable (s n)) :\n    IsClopenable\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) :=\n  by\n  choose m mt m_polish m_closed m_open using hs\n  obtain ⟨t', t'm, -, t'_polish⟩ : ∃ t' : TopologicalSpace α, (∀ n : ℕ, t' ≤ m n) ∧ t' ≤ t ∧ @PolishSpace α t' :=\n    exists_polish_space_forall_le m mt m_polish\n  have A :\n    (is_open_of t')\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) :=\n    by\n    apply isOpen_unionᵢ\n    intro n\n    apply t'm n\n    exact m_open n\n  obtain ⟨t'', t''_le, t''_polish, h1, h2⟩ :\n    ∃ t'' : TopologicalSpace α,\n      t'' ≤ t' ∧\n        @PolishSpace α t'' ∧\n          (is_closed_of t'')\n              («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) ∧\n            (is_open_of t'')\n              («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) :=\n    @IsOpen.isClopenable α t' t'_polish _ A\n  exact ⟨t'', t''_le.trans ((t'm 0).trans (mt 0)), t''_polish, h1, h2⟩\n#align is_clopenable.Union is_clopenable.Union\n\n"}