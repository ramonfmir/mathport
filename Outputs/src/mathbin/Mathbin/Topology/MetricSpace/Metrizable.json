{"pseudo_metrizable_space":
 "/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\n/-- Given an inducing map of a topological space into a pseudo metrizable space, the source space\nis also pseudo metrizable. -/\ntheorem _root_.inducing.pseudo_metrizable_space [pseudo_metrizable_space Y] {f : X → Y} (hf : Inducing f) :\n    pseudo_metrizable_space X :=\n  letI : PseudoMetricSpace Y := pseudo_metrizable_space_pseudo_metric Y\n  ⟨⟨hf.comap_pseudo_metric_space, rfl⟩⟩\n#align inducing.pseudo_metrizable_space inducing.pseudo_metrizable_space\n\n",
 "metrizable_space_of_t3_second_countable":
 "/-- *Urysohn's metrization theorem* (Tychonoff's version): a T₃ topological space with second\ncountable topology `X` is metrizable, i.e., there exists a metric space structure that generates the\nsame topology. -/\ntheorem metrizable_space_of_t3_second_countable : metrizable_space X :=\n  let ⟨f, hf⟩ := exists_embedding_l_infty X\n  hf.metrizable_space\n#align metrizable_space_of_t3_second_countable metrizable_space_of_t3_second_countable\n\n",
 "metrizable_space":
 "/-- Given an embedding of a topological space into a metrizable space, the source space is also\nmetrizable. -/\ntheorem _root_.embedding.metrizable_space [metrizable_space Y] {f : X → Y} (hf : Embedding f) : metrizable_space X :=\n  letI : MetricSpace Y := metrizable_space_metric Y\n  ⟨⟨hf.comap_metric_space f, rfl⟩⟩\n#align embedding.metrizable_space embedding.metrizable_space\n\n",
 "exists_embedding_l_infty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A T₃ topological space with second countable topology can be embedded into `l^∞ = ℕ →ᵇ ℝ`.\n-/\ntheorem exists_embedding_l_infty : ∃ f : X → bounded_continuous_function ℕ (exprℝ), Embedding f :=\n  by\n  haveI : NormalSpace X := normalSpaceOfT3SecondCountable X\n  -- Choose a countable basis, and consider the set `s` of pairs of set `(U, V)` such that `U ∈ B`,\n  -- `V ∈ B`, and `closure U ⊆ V`.\n  rcases exists_countable_basis X with ⟨B, hBc, -, hB⟩\n  set s : Set (Set X × Set X) := { UV ∈ lower_set.prod B B | closure UV.1 ⊆ UV.2 }\n  -- `s` is a countable set.\n  haveI : Encodable s := ((hBc.prod hBc).mono (inter_subset_left _ _)).to_encodable\n  -- We don't have the space of bounded (possibly discontinuous) functions, so we equip `s`\n  -- with the discrete topology and deal with `s →ᵇ ℝ` instead.\n  letI : TopologicalSpace s := «expr⊥»\n  haveI : DiscreteTopology s := ⟨rfl⟩\n  rsuffices ⟨f, hf⟩ : ∃ f : X → bounded_continuous_function s (exprℝ), Embedding f\n  ·\n    exact\n      ⟨fun x => (f x).extend (Encodable.encode' s) 0,\n        (bounded_continuous_function.isometry_extend (Encodable.encode' s)\n                (0 : bounded_continuous_function ℕ (exprℝ))).embedding.comp\n          hf⟩\n  have hd : ∀ UV : s, Disjoint (closure UV.1.1) («expr ᶜ» UV.1.2) := fun UV =>\n    disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)\n  -- Choose a sequence of `εₙ > 0`, `n : s`, that is bounded above by `1` and tends to zero\n  -- along the `cofinite` filter.\n  obtain ⟨ε, ε01, hε⟩ : ∃ ε : s → exprℝ, (∀ UV, ε UV ∈ Ioc (0 : exprℝ) 1) ∧ tendsto ε cofinite ((nhds) 0) :=\n    by\n    rcases posSumOfEncodable zero_lt_one s with ⟨ε, ε0, c, hεc, hc1⟩\n    refine' ⟨ε, fun UV => ⟨ε0 UV, _⟩, hεc.summable.tendsto_cofinite_zero⟩\n    exact (le_hasSum hεc UV fun _ _ => (ε0 _).le).trans hc1\n  /- For each `UV = (U, V) ∈ s` we use Urysohn's lemma to choose a function `f UV` that is equal to\n    zero on `U` and is equal to `ε UV` on the complement to `V`. -/\n  have :\n    ∀ UV : s,\n      ∃ f : «exprC( , )» X (exprℝ),\n        eq_on f 0 UV.1.1 ∧ eq_on f (fun _ => ε UV) («expr ᶜ» UV.1.2) ∧ ∀ x, f x ∈ Icc 0 (ε UV) :=\n    by\n    intro UV\n    rcases exists_continuous_zero_one_of_closed isClosed_closure (hB.is_open UV.2.1.2).is_closed_compl (hd UV) with\n      ⟨f, hf₀, hf₁, hf01⟩\n    exact\n      ⟨«expr • » (ε UV) f, fun x hx => by simp [hf₀ (subset_closure hx)], fun x hx => by simp [hf₁ hx], fun x =>\n        ⟨mul_nonneg (ε01 _).1.le (hf01 _).1, mul_le_of_le_one_right (ε01 _).1.le (hf01 _).2⟩⟩\n  choose f hf0 hfε hf0ε\n  have hf01 : ∀ UV x, f UV x ∈ Icc (0 : exprℝ) 1 := fun UV x => Icc_subset_Icc_right (ε01 _).2 (hf0ε _ _)\n  -- The embedding is given by `F x UV = f UV x`.\n  set F : X → bounded_continuous_function s (exprℝ) := fun x =>\n    ⟨⟨fun UV => f UV x, continuous_of_discreteTopology⟩, 1, fun UV₁ UV₂ =>\n      Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)⟩\n  have hF : ∀ x UV, F x UV = f UV x := fun _ _ => rfl\n  refine' ⟨F, Embedding.mk' _ (fun x y hxy => _) fun x => le_antisymm _ _⟩\n  · /- First we prove that `F` is injective. Indeed, if `F x = F y` and `x ≠ y`, then we can find\n        `(U, V) ∈ s` such that `x ∈ U` and `y ∉ V`, hence `F x UV = 0 ≠ ε UV = F y UV`. -/\n    refine' Classical.not_not.1 fun Hne => _\n    -- `by_contra Hne` timeouts\n    rcases hB.mem_nhds_iff.1 (is_open_ne.mem_nhds Hne) with ⟨V, hVB, hxV, hVy⟩\n    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ⟨U, hUB, hxU, hUV⟩\n    set UV : «expr↥ » s := ⟨(U, V), ⟨hUB, hVB⟩, hUV⟩\n    apply (ε01 UV).1.ne\n    calc\n      (0 : exprℝ) = F x UV := (hf0 UV hxU).symm\n      _ = F y UV := by rw [hxy]\n      _ = ε UV := hfε UV fun h : y ∈ V => hVy h rfl\n      \n  · /- Now we prove that each neighborhood `V` of `x : X` include a preimage of a neighborhood of\n        `F x` under `F`. Without loss of generality, `V` belongs to `B`. Choose `U ∈ B` such that\n        `x ∈ V` and `closure V ⊆ U`. Then the preimage of the `(ε (U, V))`-neighborhood of `F x`\n        is included by `V`. -/\n    refine' ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_has_basis).2 _\n    rintro V ⟨hVB, hxV⟩\n    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ⟨U, hUB, hxU, hUV⟩\n    set UV : «expr↥ » s := ⟨(U, V), ⟨hUB, hVB⟩, hUV⟩\n    refine' ⟨ε UV, (ε01 UV).1, fun y (hy : dist (F y) (F x) < ε UV) => _⟩\n    replace hy : dist (F y UV) (F x UV) < ε UV\n    exact (bounded_continuous_function.dist_coe_le_dist _).trans_lt hy\n    contrapose! hy\n    rw [hF, hF, hfε UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]\n    exact le_abs_self _\n  · /- Finally, we prove that `F` is continuous. Given `δ > 0`, consider the set `T` of `(U, V) ∈ s`\n        such that `ε (U, V) ≥ δ`. Since `ε` tends to zero, `T` is finite. Since each `f` is continuous,\n        we can choose a neighborhood such that `dist (F y (U, V)) (F x (U, V)) ≤ δ` for any\n        `(U, V) ∈ T`. For `(U, V) ∉ T`, the same inequality is true because both `F y (U, V)` and\n        `F x (U, V)` belong to the interval `[0, ε (U, V)]`. -/\n    refine' (nhds_basis_closed_ball.comap _).ge_iff.2 fun δ δ0 => _\n    have h_fin : { UV : s | δ ≤ ε UV }.finite := by simpa only [← not_lt] using hε (gt_mem_nhds δ0)\n    have :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n        (∀ UV, δ ≤ ε UV → dist (F y UV) (F x UV) ≤ δ) :=\n      by\n      refine' (eventually_all_finite h_fin).2 fun UV hUV => _\n      exact (f UV).continuous.tendsto x (closed_ball_mem_nhds _ δ0)\n    refine' this.mono fun y hy => (bounded_continuous_function.dist_le δ0.le).2 fun UV => _\n    cases' le_total δ (ε UV) with hle hle\n    exacts[hy _ hle, (Real.dist_le_of_mem_Icc (hf0ε _ _) (hf0ε _ _)).trans (by rwa [sub_zero])]\n#align exists_embedding_l_infty exists_embedding_l_infty\n\n"}