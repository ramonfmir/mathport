{"metrizable_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñù -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- If `X` is a uniform space with countably generated uniformity filter, there exists a\n`pseudo_metric_space` structure compatible with the `uniform_space` structure. Use\n`uniform_space.pseudo_metric_space` or `uniform_space.metric_space` instead. -/\nprotected theorem uniform_space.metrizable_uniformity (X : Type _) [uniform_space X]\n    [is_countably_generated ((uniformity) X)] : ‚àÉ I : pseudo_metric_space X, I.to_uniform_space = ‚Äπ_‚Ä∫ := by\n  classical\n    /- Choose a fast decreasing antitone basis `U : ‚Ñï ‚Üí set (X √ó X)` of the uniformity filter `ùì§ X`.\n      Define `d x y : ‚Ñù‚â•0` to be `(1 / 2) ^ n`, where `n` is the minimal index of `U n` that separates\n      `x` and `y`: `(x, y) ‚àâ U n`, or `0` if `x` is not separated from `y`. This function satisfies the\n      assumptions of `pseudo_metric_space.of_prenndist` and\n      `pseudo_metric_space.le_two_mul_dist_of_prenndist`, hence the distance given by the former pseudo\n      metric space structure is Lipschitz equivalent to the `d`. Thus the uniformities generated by\n      `d` and `dist` are equal. Since the former uniformity is equal to `ùì§ X`, the latter is equal to\n      `ùì§ X` as well. -/\n    obtain ‚ü®U, hU_symm, hU_comp, hB‚ü© :\n      ‚àÉ U : ‚Ñï ‚Üí set (X √ó X),\n        (‚àÄ n, symmetric_rel (U n)) ‚àß\n          (‚àÄ ‚¶Ém n‚¶Ñ, m < n ‚Üí uniformity.comp_rel (U n) (uniformity.comp_rel (U n) (U n)) ‚äÜ U m) ‚àß\n            ((uniformity) X).has_antitone_basis U :=\n      by\n      rcases uniform_space.has_seq_basis X with ‚ü®V, hB, hV_symm‚ü©\n      rcases hB.subbasis_with_rel fun m =>\n          hB.tendsto_small_sets.eventually (eventually_uniformity_iterate_comp_subset (hB.mem m) 2) with\n        ‚ü®œÜ, hœÜ_mono, hœÜ_comp, hœÜB‚ü©\n      exact ‚ü®V ‚àò œÜ, fun n => hV_symm _, hœÜ_comp, hœÜB‚ü©\n    letI := uniform_space.separation_setoid X\n    set d : X ‚Üí X ‚Üí nnreal := fun x y => if h : ‚àÉ n, (x, y) ‚àâ U n then (1 / 2) ^ nat.find h else 0\n    have hd‚ÇÄ : ‚àÄ {x y}, d x y = 0 ‚Üî x ‚âà y := by\n      intro x y\n      dsimp only [d]\n      refine' iff.trans _ hB.to_has_basis.mem_separation_rel.symm\n      simp only [true_imp_iff]\n      split_ifs with h\n      ¬∑ rw [‚Üê not_forall] at h\n        simp [h, pow_eq_zero_iff']\n      ¬∑ simpa only [not_exists, not_not, eq_self_iff_true, true_iff_iff] using h\n    have hd_symm : ‚àÄ x y, d x y = d y x := by\n      intro x y\n      dsimp only [d]\n      simp only [@symmetric_rel.mk_mem_comm _ _ (hU_symm _) x y]\n    have hr : (1 / 2 : nnreal) ‚àà Ioo (0 : nnreal) 1 := ‚ü®nnreal.half_pos one_pos, nnreal.half_lt_self one_ne_zero‚ü©\n    letI I := pseudo_metric_space.of_prenndist d (fun x => hd‚ÇÄ.2 (setoid.refl _)) hd_symm\n    have hdist_le : ‚àÄ x y, dist x y ‚â§ d x y := pseudo_metric_space.dist_of_prenndist_le _ _ _\n    have hle_d : ‚àÄ {x y : X} {n : ‚Ñï}, (1 / 2) ^ n ‚â§ d x y ‚Üî (x, y) ‚àâ U n :=\n      by\n      intro x y n\n      simp only [d]\n      split_ifs with h\n      ¬∑ rw [(strictAnti_pow hr.1 hr.2).le_iff_le, Nat.find_le_iff]\n        exact ‚ü®fun ‚ü®m, hmn, hm‚ü© hn => hm (hB.antitone hmn hn), fun h => ‚ü®n, le_rfl, h‚ü©‚ü©\n      ¬∑ push_neg  at h\n        simp only [h, not_true, (pow_pos hr.1 _).not_le]\n    have hd_le : ‚àÄ x y, ‚Üë(d x y) ‚â§ 2 * dist x y :=\n      by\n      refine' pseudo_metric_space.le_two_mul_dist_of_prenndist _ _ _ fun x‚ÇÅ x‚ÇÇ x‚ÇÉ x‚ÇÑ => _\n      by_cases H : ‚àÉ n, (x‚ÇÅ, x‚ÇÑ) ‚àâ U n\n      ¬∑ refine' (dif_pos H).trans_le _\n        rw [‚Üê nnreal.div_le_iff' two_ne_zero, ‚Üê mul_one_div (_ ^ _), ‚Üê pow_succ']\n        simp only [le_max_iff, hle_d, ‚Üê not_and_or]\n        rintro ‚ü®h‚ÇÅ‚ÇÇ, h‚ÇÇ‚ÇÉ, h‚ÇÉ‚ÇÑ‚ü©\n        refine' nat.find_spec H (hU_comp (lt_add_one <| nat.find H) _)\n        exact ‚ü®x‚ÇÇ, h‚ÇÅ‚ÇÇ, x‚ÇÉ, h‚ÇÇ‚ÇÉ, h‚ÇÉ‚ÇÑ‚ü©\n      ¬∑ exact (dif_neg H).trans_le (zero_le _)\n    refine' ‚ü®I, uniform_space_eq <| (uniformity_basis_dist_pow hr.1 hr.2).ext hB.to_has_basis _ _‚ü©\n    ¬∑ refine' fun n hn => ‚ü®n, hn, fun x hx => (hdist_le _ _).trans_lt _‚ü©\n      rwa [‚Üê nnreal.coe_pow, nnreal.coe_lt_coe, ‚Üê not_le, hle_d, not_not, prod.mk.eta]\n    ¬∑ refine' fun n hn => ‚ü®n + 1, trivial, fun x hx => _‚ü©\n      rw [mem_set_of_eq] at hx\n      contrapose! hx\n      refine' le_trans _ ((div_le_iff' (zero_lt_two' (expr‚Ñù))).2 (hd_le x.1 x.2))\n      rwa [‚Üê nnreal.coe_two, ‚Üê nnreal.coe_div, ‚Üê nnreal.coe_pow, nnreal.coe_le_coe, pow_succ', mul_one_div,\n        nnreal.div_le_iff two_ne_zero, div_mul_cancel _ (two_ne_zero' (nnreal)), hle_d, prod.mk.eta]\n#align uniform_space.metrizable_uniformity uniform_space.metrizable_uniformity\n\n",
 "metrizable_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- A T‚ÇÄ uniform space with countably generated `ùì§ X` is metrizable. This is not an instance to\navoid loops. -/\ntheorem uniform_space.metrizable_space [uniform_space X] [is_countably_generated ((uniformity) X)] [t0_space X] :\n    topological_space.metrizable_space X :=\n  by\n  letI := uniform_space.metric_space X\n  infer_instance\n#align uniform_space.metrizable_space uniform_space.metrizable_space\n\n",
 "le_two_mul_dist_of_prenndist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-- Consider a function `d : X ‚Üí X ‚Üí ‚Ñù‚â•0` such that `d x x = 0` and `d x y = d y x` for all `x`,\n`y`. Let `dist` be the largest pseudometric distance such that `dist x y ‚â§ d x y`, see\n`pseudo_metric_space.of_prenndist`. Suppose that `d` satisfies the following triangle-like\ninequality: `d x‚ÇÅ x‚ÇÑ ‚â§ 2 * max (d x‚ÇÅ x‚ÇÇ, d x‚ÇÇ x‚ÇÉ, d x‚ÇÉ x‚ÇÑ)`. Then `d x y ‚â§ 2 * dist x y` for all\n`x`, `y`. -/\ntheorem le_two_mul_dist_of_prenndist (d : X ‚Üí X ‚Üí nnreal) (dist_self : ‚àÄ x, d x x = 0)\n    (dist_comm : ‚àÄ x y, d x y = d y x) (hd : ‚àÄ x‚ÇÅ x‚ÇÇ x‚ÇÉ x‚ÇÑ, d x‚ÇÅ x‚ÇÑ ‚â§ 2 * max (d x‚ÇÅ x‚ÇÇ) (max (d x‚ÇÇ x‚ÇÉ) (d x‚ÇÉ x‚ÇÑ)))\n    (x y : X) :\n    ‚Üë(d x y) ‚â§\n      2 * @dist X (@pseudo_metric_space.to_has_dist X (pseudo_metric_space.of_prenndist d dist_self dist_comm)) x y :=\n  by\n  /- We need to show that `d x y` is at most twice the sum `L` of `d x·µ¢ x·µ¢‚Çä‚ÇÅ` over a path\n    `x‚ÇÄ=x, ..., x‚Çô=y`. We prove it by induction on the length `n` of the sequence. Find an edge that\n    splits the path into two parts of almost equal length: both `d x‚ÇÄ x‚ÇÅ + ... + d x‚Çñ‚Çã‚ÇÅ x‚Çñ` and\n    `d x‚Çñ‚Çä‚ÇÅ x‚Çñ‚Çä‚ÇÇ + ... + d x‚Çô‚Çã‚ÇÅ x‚Çô` are less than or equal to `L / 2`.\n    Then `d x‚ÇÄ x‚Çñ ‚â§ L`, `d x‚Çñ x‚Çñ‚Çä‚ÇÅ ‚â§ L`, and `d x‚Çñ‚Çä‚ÇÅ x‚Çô ‚â§ L`, thus `d x‚ÇÄ x‚Çô ‚â§ 2 * L`. -/\n  rw [dist_of_prenndist, ‚Üê nnreal.coe_two, ‚Üê nnreal.coe_mul, nnreal.mul_infi, nnreal.coe_le_coe]\n  refine' le_cinf·µ¢ fun l => _\n  have hd‚ÇÄ_trans : transitive fun x y => d x y = 0 :=\n    by\n    intro a b c hab hbc\n    rw [‚Üê nonpos_iff_eq_zero]\n    simpa only [*, max_eq_right, mul_zero] using hd a b c c\n  haveI : is_trans X fun x y => d x y = 0 := ‚ü®hd‚ÇÄ_trans‚ü©\n  induction' hn : length l using nat.strong_induction_on with n ihn generalizing x y l\n  simp only at ihn\n  subst n\n  set L := zip_with d (sym.cons' x l) (l ++ [y])\n  have hL_len : length L = length l + 1 := by simp\n  cases' eq_or_ne (d x y) 0 with hd‚ÇÄ hd‚ÇÄ\n  ¬∑ simp only [hd‚ÇÄ, zero_le]\n  rsuffices ‚ü®z, z', hxz, hzz', hz'y‚ü© : ‚àÉ z z' : X, d x z ‚â§ L.sum ‚àß d z z' ‚â§ L.sum ‚àß d z' y ‚â§ L.sum\n  ¬∑ exact (hd x z z' y).trans (mul_le_mul_left' (max_le hxz (max_le hzz' hz'y)) _)\n  set s : set ‚Ñï := { m : ‚Ñï | 2 * (take m L).sum ‚â§ L.sum }\n  have hs‚ÇÄ : 0 ‚àà s := by simp [s]\n  have hsne : s.nonempty := ‚ü®0, hs‚ÇÄ‚ü©\n  obtain ‚ü®M, hMl, hMs‚ü© : ‚àÉ M ‚â§ length l, IsGreatest s M :=\n    by\n    have hs_ub : length l ‚àà upperBounds s := by\n      intro m hm\n      rw [‚Üê not_lt, Nat.lt_iff_add_one_le, ‚Üê hL_len]\n      intro hLm\n      rw [mem_set_of_eq, take_all_of_le hLm, two_mul, add_le_iff_nonpos_left, nonpos_iff_eq_zero, sum_eq_zero_iff, ‚Üê\n          all‚ÇÇ_iff_forall, all‚ÇÇ_zip_with, ‚Üê chain_append_singleton_iff_forall‚ÇÇ] at hm <;>\n        [skip, ¬∑ simp]\n      exact hd‚ÇÄ (hm.rel (mem_append.2 <| or.inr <| mem_singleton_self _))\n    have hs_bdd : BddAbove s := ‚ü®length l, hs_ub‚ü©\n    exact ‚ü®Sup s, csup‚Çõ_le hsne hs_ub, ‚ü®nat.Sup_mem hsne hs_bdd, fun k => le_csup‚Çõ hs_bdd‚ü©‚ü©\n  have hM_lt : M < length L := by rwa [hL_len, Nat.lt_succ_iff]\n  have hM_ltx : M < length (sym.cons' x l) := lt_length_left_of_zip_with hM_lt\n  have hM_lty : M < length (l ++ [y]) := lt_length_right_of_zip_with hM_lt\n  refine' ‚ü®(sym.cons' x l).nth_le M hM_ltx, (l ++ [y]).nth_le M hM_lty, _, _, _‚ü©\n  ¬∑ cases M\n    ¬∑ simp [dist_self]\n    rw [Nat.succ_le_iff] at hMl\n    have hMl' : length (take M l) = M := (length_take _ _).trans (min_eq_left hMl.le)\n    simp only [nth_le]\n    refine' (ihn _ hMl _ _ _ hMl').trans _\n    convert hMs.1.out\n    rw [zip_with_distrib_take, take, take_succ, nth_append hMl, nth_le_nth hMl, ‚Üê option.coe_def, option.to_list_some,\n      take_append_of_le_length hMl.le]\n    rfl\n  ¬∑ refine' single_le_sum (fun x hx => zero_le x) _ (mem_iff_nth_le.2 ‚ü®M, hM_lt, _‚ü©)\n    apply nth_le_zip_with\n  ¬∑ rcases hMl.eq_or_lt with (rfl | hMl)\n    ¬∑ simp only [nth_le_append_right le_rfl, sub_self, nth_le_singleton, dist_self, zero_le]\n    rw [nth_le_append _ hMl]\n    have hlen : length (drop (M + 1) l) = length l - (M + 1) := length_drop _ _\n    have hlen_lt : length l - (M + 1) < length l := nat.sub_lt_of_pos_le _ _ M.succ_pos hMl\n    refine' (ihn _ hlen_lt _ y _ hlen).trans _\n    rw [cons_nth_le_drop_succ]\n    have hMs' : L.sum ‚â§ 2 * (L.take (M + 1)).sum := not_lt.1 fun h => (hMs.2 h.le).not_lt M.lt_succ_self\n    rw [‚Üê sum_take_add_sum_drop L (M + 1), two_mul, add_le_add_iff_left, ‚Üê add_le_add_iff_right, sum_take_add_sum_drop,\n      ‚Üê two_mul] at hMs'\n    convert hMs'\n    rwa [zip_with_distrib_drop, drop, drop_append_of_le_length]\n#align le_two_mul_dist_of_prenndist le_two_mul_dist_of_prenndist\n\n",
 "dist_of_prenndist_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem dist_of_prenndist_le (d : X ‚Üí X ‚Üí nnreal) (dist_self : ‚àÄ x, d x x = 0) (dist_comm : ‚àÄ x y, d x y = d y x)\n    (x y : X) :\n    @dist X (@pseudo_metric_space.to_has_dist X (pseudo_metric_space.of_prenndist d dist_self dist_comm)) x y ‚â§ d x y :=\n  nnreal.coe_le_coe.2 <| (cinf·µ¢_le (OrderBot.bddBelow _) []).trans_eq <| by simp\n#align dist_of_prenndist_le dist_of_prenndist_le\n\n",
 "dist_of_prenndist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ö , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\ntheorem dist_of_prenndist (d : X ‚Üí X ‚Üí nnreal) (dist_self : ‚àÄ x, d x x = 0) (dist_comm : ‚àÄ x y, d x y = d y x)\n    (x y : X) :\n    @dist X (@pseudo_metric_space.to_has_dist X (pseudo_metric_space.of_prenndist d dist_self dist_comm)) x y =\n      ‚Üë(¬´expr‚®Ö , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª\"\n            ((sym.cons' x l).zip_with d (l ++ [y])).sum :\n          nnreal) :=\n  rfl\n#align dist_of_prenndist dist_of_prenndist\n\n"}