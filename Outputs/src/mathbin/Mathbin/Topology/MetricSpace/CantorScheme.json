{"map_of_vanishing_diam":
 "/-- A scheme on a complete space with vanishing diameter\nsuch that each set contains the closure of its children\ninduces a total map. -/\ntheorem closure_antitone.map_of_vanishing_diam [CompleteSpace α] (hdiam : VanishingDiam A) (hanti : ClosureAntitone A)\n    (hnonempty : ∀ l, (A l).nonempty) : (inducedMap A).1 = univ :=\n  by\n  rw [eq_univ_iff_forall]\n  intro x\n  choose u hu using fun n => hnonempty (res x n)\n  have umem : ∀ n m : ℕ, n ≤ m → u m ∈ A (res x n) :=\n    by\n    have : Antitone fun n : ℕ => A (res x n) :=\n      by\n      refine' antitone_nat_of_succ_le _\n      intro n\n      apply hanti.antitone\n    intro n m hnm\n    exact this hnm (hu _)\n  have : CauchySeq u := by\n    rw [Metric.cauchySeq_iff]\n    intro ε ε_pos\n    cases' hdiam.dist_lt _ ε_pos x with n hn\n    use n\n    intro m₀ hm₀ m₁ hm₁\n    apply hn <;> apply umem <;> assumption\n  cases' cauchySeq_tendsto_of_complete this with y hy\n  use y\n  rw [mem_Inter]\n  intro n\n  apply hanti _ (x n)\n  apply mem_closure_of_tendsto hy\n  rw [eventually_at_top]\n  exact ⟨n.succ, umem _⟩\n#align closure_antitone.map_of_vanishing_diam closure_antitone.map_of_vanishing_diam\n\n",
 "map_mem":
 "/-\nCopyright (c) 2023 Felix Weilacher. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Felix Weilacher\n-/\n/-- If `x` is in the domain of the induced map of a scheme `A`,\nits image under this map is in each set along the corresponding branch. -/\ntheorem map_mem (x : (inducedMap A).1) (n : ℕ) : (inducedMap A).2 x ∈ A (res x n) :=\n  by\n  have := x.property.some_mem\n  rw [mem_Inter] at this\n  exact this n\n#align map_mem map_mem\n\n",
 "map_injective":
 "/-- A scheme where the children of each set are pairwise disjoint induces an injective map. -/\ntheorem disjoint.map_injective (hA : CantorScheme.Disjoint A) : injective (inducedMap A).2 :=\n  by\n  rintro ⟨x, hx⟩ ⟨y, hy⟩ hxy\n  refine' Subtype.coe_injective (res_injective _)\n  dsimp\n  ext n : 1\n  induction' n with n ih; · simp\n  simp only [res_succ]\n  refine' ⟨_, ih⟩\n  contrapose hA\n  simp only [CantorScheme.Disjoint, _root_.pairwise, ne.def, not_forall, exists_prop]\n  refine' ⟨res x n, _, _, hA, _⟩\n  rw [not_disjoint_iff]\n  refine' ⟨([anonymous] A).2 ⟨x, hx⟩, _, _⟩\n  · rw [← res_succ]\n    apply map_mem\n  rw [hxy, ih, ← res_succ]\n  apply map_mem\n#align disjoint.map_injective disjoint.map_injective\n\n",
 "map_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- A scheme with vanishing diameter along each branch induces a continuous map. -/\ntheorem vanishing_diam.map_continuous [TopologicalSpace β] [DiscreteTopology β] (hA : VanishingDiam A) :\n    Continuous (inducedMap A).2 := by\n  rw [Metric.continuous_iff']\n  rintro ⟨x, hx⟩ ε ε_pos\n  cases' hA.dist_lt _ ε_pos x with n hn\n  rw [_root_.eventually_nhds_iff]\n  refine' ⟨«expr ⁻¹' » coe (cylinder x n), _, _, by simp⟩\n  · rintro ⟨y, hy⟩ hyx\n    rw [mem_preimage, Subtype.coe_mk, cylinder_eq_res, mem_set_of] at hyx\n    apply hn\n    · rw [← hyx]\n      apply map_mem\n    apply map_mem\n  apply continuous_subtype_coe.is_open_preimage\n  apply is_open_cylinder\n#align vanishing_diam.map_continuous vanishing_diam.map_continuous\n\n",
 "dist_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (y z «expr ∈ » A (res[pi_nat.res] x n)) -/\ntheorem vanishing_diam.dist_lt (hA : VanishingDiam A) (ε : exprℝ) (ε_pos : 0 < ε) (x : ℕ → β) :\n    ∃ n : ℕ, ∀ (y) (_ : y ∈ A (res x n)) (z) (_ : z ∈ A (res x n)), dist y z < ε :=\n  by\n  specialize hA x\n  rw [ENNReal.tendsto_atTop_zero] at hA\n  cases'\n    hA (ENNReal.ofReal (ε / 2))\n      (by\n        simp only [gt_iff_lt, ENNReal.ofReal_pos]\n        linarith) with\n    n hn\n  use n\n  intro y hy z hz\n  rw [← ENNReal.ofReal_lt_ofReal_iff ε_pos, ← edist_dist]\n  apply lt_of_le_of_lt (EMetric.edist_le_diam_of_mem hy hz)\n  apply lt_of_le_of_lt (hn _ (le_refl _))\n  rw [ENNReal.ofReal_lt_ofReal_iff ε_pos]\n  linarith\n#align vanishing_diam.dist_lt vanishing_diam.dist_lt\n\n",
 "closure_antitone":
 "protected theorem antitone.closure_antitone [TopologicalSpace α] (hanti : CantorScheme.Antitone A)\n    (hclosed : ∀ l, IsClosed (A l)) : ClosureAntitone A := fun l a => (hclosed _).closure_eq.subset.trans (hanti _ _)\n#align antitone.closure_antitone antitone.closure_antitone\n\n",
 "antitone":
 "protected theorem closure_antitone.antitone [TopologicalSpace α] (hA : ClosureAntitone A) : CantorScheme.Antitone A :=\n  fun l a => subset_closure.trans (hA l a)\n#align closure_antitone.antitone closure_antitone.antitone\n\n"}