{"totallyBounded":
 "#print IsSeqCompact.totallyBounded /-\n/-- A sequentially compact set in a uniform space is totally bounded. -/\nprotected theorem IsSeqCompact.totallyBounded (h : IsSeqCompact s) : TotallyBounded s :=\n  by\n  intro V V_in\n  unfold IsSeqCompact at h\n  contrapose! h\n  obtain ⟨u, u_in, hu⟩ : ∃ u : ℕ → X, (∀ n, u n ∈ s) ∧ ∀ n m, m < n → u m ∉ ball (u n) V :=\n    by\n    simp only [not_subset, mem_Union₂, not_exists, exists_prop] at h\n    simpa only [forall_and, ball_image_iff, not_and] using seq_of_forall_finite_exists h\n  refine' ⟨u, u_in, fun x x_in φ hφ huφ => _⟩\n  obtain ⟨N, hN⟩ : ∃ N, ∀ p q, p ≥ N → q ≥ N → (u (φ p), u (φ q)) ∈ V\n  exact huφ.cauchy_seq.mem_entourage V_in\n  exact hu (φ <| N + 1) (φ N) (hφ <| lt_add_one N) (hN (N + 1) N N.le_succ le_rfl)\n#align is_seq_compact.totally_bounded IsSeqCompact.totallyBounded\n-/\n\n",
 "tendsto_subseq_of_frequently_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_subseq_of_frequently_bounded /-\n/-- A version of **Bolzano-Weistrass**: in a proper metric space (eg. $ℝ^n$),\nevery bounded sequence has a converging subsequence. This version assumes only\nthat the sequence is frequently in some bounded set. -/\ntheorem tendsto_subseq_of_frequently_bounded (hs : Bounded s) {x : ℕ → X}\n    (hx :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n        (x n ∈ s)) :\n    ∃ a ∈ closure s, ∃ φ : ℕ → ℕ, StrictMono φ ∧ Tendsto (x ∘ φ) atTop ((nhds) a) :=\n  have hcs : IsSeqCompact (closure s) := hs.is_compact_closure.is_seq_compact\n  have hu' :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n      (x n ∈ closure s) :=\n    hx.mono fun n hn => subset_closure hn\n  hcs.subseq_of_frequently_in hu'\n#align tendsto_subseq_of_frequently_bounded tendsto_subseq_of_frequently_bounded\n-/\n\n",
 "tendsto_subseq_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_subseq_of_bounded /-\n/-- A version of Bolzano-Weistrass: in a proper metric space (eg. $ℝ^n$),\nevery bounded sequence has a converging subsequence. -/\ntheorem tendsto_subseq_of_bounded (hs : Bounded s) {x : ℕ → X} (hx : ∀ n, x n ∈ s) :\n    ∃ a ∈ closure s, ∃ φ : ℕ → ℕ, StrictMono φ ∧ Tendsto (x ∘ φ) atTop ((nhds) a) :=\n  tendsto_subseq_of_frequently_bounded hs <| frequently_of_forall hx\n#align tendsto_subseq_of_bounded tendsto_subseq_of_bounded\n-/\n\n",
 "tendsto_subseq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsCompact.tendsto_subseq' /-\ntheorem IsCompact.tendsto_subseq' {s : Set X} {x : ℕ → X} (hs : IsCompact s)\n    (hx :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n        (x n ∈ s)) :\n    ∃ a ∈ s, ∃ φ : ℕ → ℕ, StrictMono φ ∧ Tendsto (x ∘ φ) atTop ((nhds) a) :=\n  hs.is_seq_compact.subseq_of_frequently_in hx\n#align is_compact.tendsto_subseq' IsCompact.tendsto_subseq'\n-/\n\n",
 "tendsto_subseq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print CompactSpace.tendsto_subseq /-\n-- see Note [lower instance priority]\ntheorem CompactSpace.tendsto_subseq [CompactSpace X] (x : ℕ → X) :\n    ∃ (a : _)(φ : ℕ → ℕ), StrictMono φ ∧ Tendsto (x ∘ φ) atTop ((nhds) a) :=\n  SeqCompactSpace.tendsto_subseq x\n#align compact_space.tendsto_subseq CompactSpace.tendsto_subseq\n-/\n\n",
 "tendsto_nhds_iff_seq_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_nhds_iff_seq_tendsto /-\n/-- If the domain of a function `f : α → β` is a Fréchet-Urysohn space, then convergence\nis equivalent to sequential convergence. See also `filter.tendsto_iff_seq_tendsto` for a version\nthat works for any pair of filters assuming that the filter in the domain is countably generated.\n\nThis property is equivalent to the definition of `frechet_urysohn_space`, see\n`frechet_urysohn_space.of_seq_tendsto_imp_tendsto`. -/\ntheorem tendsto_nhds_iff_seq_tendsto [FrechetUrysohnSpace X] {f : X → Y} {a : X} {b : Y} :\n    Tendsto f ((nhds) a) ((nhds) b) ↔ ∀ u : ℕ → X, Tendsto u atTop ((nhds) a) → Tendsto (f ∘ u) atTop ((nhds) b) :=\n  by\n  refine' ⟨fun hf u hu => hf.comp hu, fun h => ((nhds_basis_closeds _).tendsto_iff (nhds_basis_closeds _)).2 _⟩\n  rintro s ⟨hbs, hsc⟩\n  refine' ⟨closure («expr ⁻¹' » f s), ⟨mt _ hbs, isClosed_closure⟩, fun x => mt fun hx => subset_closure hx⟩\n  rw [← seqClosure_eq_closure]\n  rintro ⟨u, hus, hu⟩\n  exact hsc.mem_of_tendsto (h u hu) (eventually_of_forall hus)\n#align tendsto_nhds_iff_seq_tendsto tendsto_nhds_iff_seq_tendsto\n-/\n\n",
 "subset_seqClosure":
 "#print subset_seqClosure /-\n/-\nCopyright (c) 2018 Jan-David Salchow. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jan-David Salchow, Patrick Massot, Yury Kudryashov\n-/\ntheorem subset_seqClosure {s : Set X} : s ⊆ seqClosure s := fun p hp => ⟨const ℕ p, fun _ => hp, tendsto_const_nhds⟩\n#align subset_seq_closure subset_seqClosure\n-/\n\n",
 "subseq_of_frequently_in":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsSeqCompact.subseq_of_frequently_in /-\ntheorem IsSeqCompact.subseq_of_frequently_in {s : Set X} (hs : IsSeqCompact s) {x : ℕ → X}\n    (hx :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n        (x n ∈ s)) :\n    ∃ a ∈ s, ∃ φ : ℕ → ℕ, StrictMono φ ∧ Tendsto (x ∘ φ) atTop ((nhds) a) :=\n  let ⟨ψ, hψ, huψ⟩ := extraction_of_frequently_atTop hx\n  let ⟨a, a_in, φ, hφ, h⟩ := hs huψ\n  ⟨a, a_in, ψ ∘ φ, hψ.comp hφ, h⟩\n#align is_seq_compact.subseq_of_frequently_in IsSeqCompact.subseq_of_frequently_in\n-/\n\n",
 "sequentialSpace":
 "#print QuotientMap.sequentialSpace /-\ntheorem QuotientMap.sequentialSpace [SequentialSpace X] {f : X → Y} (hf : QuotientMap f) : SequentialSpace Y :=\n  ⟨fun s hs => hf.is_closed_preimage.mp <| (hs.preimage <| hf.continuous.seq_continuous).is_closed⟩\n#align quotient_map.sequential_space QuotientMap.sequentialSpace\n-/\n\n",
 "seqContinuous":
 "#print Continuous.seqContinuous /-\n-- A continuous function is sequentially continuous.\nprotected theorem Continuous.seqContinuous {f : X → Y} (hf : Continuous f) : SeqContinuous f := fun x p hx =>\n  (hf.tendsto p).comp hx\n#align continuous.seq_continuous Continuous.seqContinuous\n-/\n\n",
 "seqClosure_subset_closure":
 "#print seqClosure_subset_closure /-\n/-- The sequential closure of a set is contained in the closure of that set.\nThe converse is not true. -/\ntheorem seqClosure_subset_closure {s : Set X} : seqClosure s ⊆ closure s := fun p ⟨x, xM, xp⟩ =>\n  mem_closure_of_tendsto xp (univ_mem' xM)\n#align seq_closure_subset_closure seqClosure_subset_closure\n-/\n\n",
 "seqClosure_eq_closure":
 "#print seqClosure_eq_closure /-\ntheorem seqClosure_eq_closure [FrechetUrysohnSpace X] (s : Set X) : seqClosure s = closure s :=\n  seqClosure_subset_closure.antisymm <| frechet_urysohn_space.closure_subset_seq_closure s\n#align seq_closure_eq_closure seqClosure_eq_closure\n-/\n\n",
 "seqClosure_eq":
 "#print IsSeqClosed.seqClosure_eq /-\n/-- The sequential closure of a sequentially closed set is the set itself. -/\ntheorem IsSeqClosed.seqClosure_eq {s : Set X} (hs : IsSeqClosed s) : seqClosure s = s :=\n  Subset.antisymm (fun p ⟨x, hx, hp⟩ => hs hx hp) subset_seqClosure\n#align is_seq_closed.seq_closure_eq IsSeqClosed.seqClosure_eq\n-/\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print IsSeqClosed.preimage /-\n/-- The preimage of a sequentially closed set under a sequentially continuous map is sequentially\nclosed. -/\ntheorem IsSeqClosed.preimage {f : X → Y} {s : Set Y} (hs : IsSeqClosed s) (hf : SeqContinuous f) :\n    IsSeqClosed («expr ⁻¹' » f s) := fun x p hx hp => hs hx (hf hp)\n#align is_seq_closed.preimage IsSeqClosed.preimage\n-/\n\n",
 "of_seq_tendsto_imp_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto /-\n/-- An alternative construction for `frechet_urysohn_space`: if sequential convergence implies\nconvergence, then the space is a Fréchet-Urysohn space. -/\ntheorem FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto\n    (h :\n      ∀ (f : X → Prop) (a : X),\n        (∀ u : ℕ → X, Tendsto u atTop ((nhds) a) → Tendsto (f ∘ u) atTop ((nhds) (f a))) → ContinuousAt f a) :\n    FrechetUrysohnSpace X := by\n  refine' ⟨fun s x hcx => _⟩\n  specialize h (· ∉ s) x\n  by_cases hx : x ∈ s; · exact subset_seqClosure hx\n  simp_rw [(· ∘ ·), ContinuousAt, hx, not_false_iff, nhds_true, tendsto_pure, eq_true_iff, ← mem_compl_iff,\n    eventually_mem_set, ← mem_interior_iff_mem_nhds, interior_compl] at h\n  rw [mem_compl_iff, imp_not_comm] at h\n  simp only [not_forall, not_eventually, mem_compl_iff, Classical.not_not] at h\n  rcases h hcx with ⟨u, hux, hus⟩\n  rcases extraction_of_frequently_at_top hus with ⟨φ, φ_mono, hφ⟩\n  exact ⟨u ∘ φ, hφ, hux.comp φ_mono.tendsto_at_top⟩\n#align frechet_urysohn_space.of_seq_tendsto_imp_tendsto FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto\n-/\n\n",
 "mem_closure_iff_seq_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_seq_limit /-\n/-- In a Fréchet-Urysohn space, a point belongs to the closure of a set iff it is a limit\nof a sequence taking values in this set. -/\ntheorem mem_closure_iff_seq_limit [FrechetUrysohnSpace X] {s : Set X} {a : X} :\n    a ∈ closure s ↔ ∃ x : ℕ → X, (∀ n : ℕ, x n ∈ s) ∧ Tendsto x atTop ((nhds) a) :=\n  by\n  rw [← seqClosure_eq_closure]\n  rfl\n#align mem_closure_iff_seq_limit mem_closure_iff_seq_limit\n-/\n\n",
 "lebesgue_number_lemma_of_metric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print SeqCompact.lebesgue_number_lemma_of_metric /-\ntheorem SeqCompact.lebesgue_number_lemma_of_metric {ι : Sort _} {c : ι → Set X} {s : Set X} (hs : IsSeqCompact s)\n    (hc₁ : ∀ i, IsOpen (c i))\n    (hc₂ : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (c i)) :\n    ∃ δ > 0, ∀ a ∈ s, ∃ i, ball a δ ⊆ c i :=\n  lebesgue_number_lemma_of_metric hs.is_compact hc₁ hc₂\n#align seq_compact.lebesgue_number_lemma_of_metric SeqCompact.lebesgue_number_lemma_of_metric\n-/\n\n",
 "isSeqCompact":
 "#print IsCompact.isSeqCompact /-\nprotected theorem IsCompact.isSeqCompact {s : Set X} (hs : IsCompact s) : IsSeqCompact s := fun x x_in =>\n  let ⟨a, a_in, ha⟩ := hs (tendsto_principal.mpr (eventually_of_forall x_in))\n  ⟨a, a_in, tendsto_subseq ha⟩\n#align is_compact.is_seq_compact IsCompact.isSeqCompact\n-/\n\n",
 "isSeqClosed_of_seqClosure_eq":
 "#print isSeqClosed_of_seqClosure_eq /-\n/-- If a set is equal to its sequential closure, then it is sequentially closed. -/\ntheorem isSeqClosed_of_seqClosure_eq {s : Set X} (hs : seqClosure s = s) : IsSeqClosed s := fun x p hxs hxp =>\n  hs ▸ ⟨x, hxs, hxp⟩\n#align is_seq_closed_of_seq_closure_eq isSeqClosed_of_seqClosure_eq\n-/\n\n",
 "isSeqClosed_iff_isClosed":
 "#print isSeqClosed_iff_isClosed /-\n/-- In a sequential space, a set is closed iff it's sequentially closed. -/\ntheorem isSeqClosed_iff_isClosed [SequentialSpace X] {M : Set X} : IsSeqClosed M ↔ IsClosed M :=\n  ⟨IsSeqClosed.isClosed, IsClosed.isSeqClosed⟩\n#align is_seq_closed_iff_is_closed isSeqClosed_iff_isClosed\n-/\n\n",
 "isSeqClosed_iff":
 "#print isSeqClosed_iff /-\n/-- A set is sequentially closed iff it is equal to its sequential closure. -/\ntheorem isSeqClosed_iff {s : Set X} : IsSeqClosed s ↔ seqClosure s = s :=\n  ⟨IsSeqClosed.seqClosure_eq, isSeqClosed_of_seqClosure_eq⟩\n#align is_seq_closed_iff isSeqClosed_iff\n-/\n\n",
 "isSeqClosed":
 "#print IsClosed.isSeqClosed /-\n/-- A set is sequentially closed if it is closed. -/\nprotected theorem IsClosed.isSeqClosed {s : Set X} (hc : IsClosed s) : IsSeqClosed s := fun u x hu hx =>\n  hc.mem_of_tendsto hx (eventually_of_forall hu)\n#align is_closed.is_seq_closed IsClosed.isSeqClosed\n-/\n\n",
 "isComplete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print IsSeqCompact.isComplete /-\n/-- A sequentially compact set in a uniform set with countably generated uniformity filter\nis complete. -/\nprotected theorem IsSeqCompact.isComplete (hs : IsSeqCompact s) : IsComplete s :=\n  by\n  intro l hl hls\n  haveI := hl.1\n  rcases exists_antitone_basis ((uniformity) X) with ⟨V, hV⟩\n  choose W hW hWV using fun n => comp_mem_uniformity_sets (hV.mem n)\n  have hWV' : ∀ n, W n ⊆ V n := fun n ⟨x, y⟩ hx => @hWV n (x, y) ⟨x, refl_mem_uniformity <| hW _, hx⟩\n  obtain ⟨t, ht_anti, htl, htW, hts⟩ :\n    ∃ t : ℕ → Set X, Antitone t ∧ (∀ n, t n ∈ l) ∧ (∀ n, lower_set.prod (t n) (t n) ⊆ W n) ∧ ∀ n, t n ⊆ s :=\n    by\n    have : ∀ n, ∃ t ∈ l, lower_set.prod t t ⊆ W n ∧ t ⊆ s :=\n      by\n      rw [le_principal_iff] at hls\n      have : ∀ n, W n ∩ lower_set.prod s s ∈ filter.prod l l := fun n => inter_mem (hl.2 (hW n)) (prod_mem_prod hls hls)\n      simpa only [l.basis_sets.prod_self.mem_iff, true_imp_iff, subset_inter_iff, prod_self_subset_prod_self,\n        and_assoc] using this\n    choose t htl htW hts\n    have :\n      ∀ n,\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (t k) ⊆ t n :=\n      fun n => Inter₂_subset _ le_rfl\n    exact\n      ⟨fun n => «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (t k),\n        fun m n h => bInter_subset_bInter_left fun k (hk : k ≤ m) => hk.trans h, fun n =>\n        (bInter_mem (finite_le_nat n)).2 fun k hk => htl k, fun n => (prod_mono (this n) (this n)).trans (htW n),\n        fun n => (this n).trans (hts n)⟩\n  choose u hu using fun n => Filter.nonempty_of_mem (htl n)\n  have huc : CauchySeq u :=\n    hV.to_has_basis.cauchy_seq_iff.2 fun N hN =>\n      ⟨N, fun m hm n hn => hWV' _ <| @htW N (_, _) ⟨ht_anti hm (hu _), ht_anti hn (hu _)⟩⟩\n  rcases hs.exists_tendsto (fun n => hts n (hu n)) huc with ⟨x, hxs, hx⟩\n  refine' ⟨x, hxs, (nhds_basis_uniformity' hV.to_has_basis).ge_iff.2 fun N hN => _⟩\n  obtain ⟨n, hNn, hn⟩ : ∃ n, N ≤ n ∧ u n ∈ ball x (W N)\n  exact ((eventually_ge_at_top N).and (hx <| ball_mem_nhds x (hW N))).exists\n  refine' mem_of_superset (htl n) fun y hy => hWV N ⟨u n, _, htW N ⟨_, _⟩⟩\n  exacts[hn, ht_anti hNn (hu n), ht_anti hNn hy]\n#align is_seq_compact.is_complete IsSeqCompact.isComplete\n-/\n\n",
 "isCompact_iff_isSeqCompact":
 "#print UniformSpace.isCompact_iff_isSeqCompact /-\n/-- A version of Bolzano-Weistrass: in a uniform space with countably generated uniformity filter\n(e.g., in a metric space), a set is compact if and only if it is sequentially compact. -/\nprotected theorem UniformSpace.isCompact_iff_isSeqCompact : IsCompact s ↔ IsSeqCompact s :=\n  ⟨fun H => H.is_seq_compact, fun H => H.is_compact⟩\n#align uniform_space.is_compact_iff_is_seq_compact UniformSpace.isCompact_iff_isSeqCompact\n-/\n\n",
 "isCompact":
 "#print IsSeqCompact.isCompact /-\n/-- If `𝓤 β` is countably generated, then any sequentially compact set is compact. -/\nprotected theorem IsSeqCompact.isCompact (hs : IsSeqCompact s) : IsCompact s :=\n  isCompact_iff_totallyBounded_isComplete.2 ⟨hs.totally_bounded, hs.is_complete⟩\n#align is_seq_compact.is_compact IsSeqCompact.isCompact\n-/\n\n",
 "isClosed":
 "#print IsSeqClosed.isClosed /-\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n/-- In a sequential space, a sequentially closed set is closed. -/\nprotected theorem IsSeqClosed.isClosed [SequentialSpace X] {s : Set X} (hs : IsSeqClosed s) : IsClosed s :=\n  sequential_space.is_closed_of_seq s hs\n#align is_seq_closed.is_closed IsSeqClosed.isClosed\n-/\n\n",
 "exists_tendsto_of_frequently_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsSeqCompact.exists_tendsto_of_frequently_mem /-\ntheorem IsSeqCompact.exists_tendsto_of_frequently_mem (hs : IsSeqCompact s) {u : ℕ → X}\n    (hu :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n        (u n ∈ s))\n    (huc : CauchySeq u) : ∃ x ∈ s, Tendsto u atTop ((nhds) x) :=\n  let ⟨x, hxs, φ, φ_mono, hx⟩ := hs.subseq_of_frequently_in hu\n  ⟨x, hxs, tendsto_nhds_of_cauchySeq_of_subseq huc φ_mono.tendsto_at_top hx⟩\n#align is_seq_compact.exists_tendsto_of_frequently_mem IsSeqCompact.exists_tendsto_of_frequently_mem\n-/\n\n",
 "exists_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsSeqCompact.exists_tendsto /-\ntheorem IsSeqCompact.exists_tendsto (hs : IsSeqCompact s) {u : ℕ → X} (hu : ∀ n, u n ∈ s) (huc : CauchySeq u) :\n    ∃ x ∈ s, Tendsto u atTop ((nhds) x) :=\n  hs.exists_tendsto_of_frequently_mem (frequently_of_forall hu) huc\n#align is_seq_compact.exists_tendsto IsSeqCompact.exists_tendsto\n-/\n\n",
 "continuous_iff_seqContinuous":
 "#print continuous_iff_seqContinuous /-\n/-- If the domain of a function is a sequential space, then continuity of this function is\nequivalent to its sequential continuity. -/\ntheorem continuous_iff_seqContinuous [SequentialSpace X] {f : X → Y} : Continuous f ↔ SeqContinuous f :=\n  ⟨Continuous.seqContinuous, SeqContinuous.continuous⟩\n#align continuous_iff_seq_continuous continuous_iff_seqContinuous\n-/\n\n",
 "continuous":
 "#print SeqContinuous.continuous /-\n/-- A sequentially continuous function defined on a sequential space is continuous. -/\nprotected theorem SeqContinuous.continuous [SequentialSpace X] {f : X → Y} (hf : SeqContinuous f) : Continuous f :=\n  continuous_iff_isClosed.mpr fun s hs => (hs.is_seq_closed.preimage hf).is_closed\n#align seq_continuous.continuous SeqContinuous.continuous\n-/\n\n",
 "compactSpace_iff_seqCompactSpace":
 "#print UniformSpace.compactSpace_iff_seqCompactSpace /-\ntheorem UniformSpace.compactSpace_iff_seqCompactSpace : CompactSpace X ↔ SeqCompactSpace X := by\n  simp only [← isCompact_univ_iff, seqCompactSpace_iff, UniformSpace.isCompact_iff_isSeqCompact]\n#align uniform_space.compact_space_iff_seq_compact_space UniformSpace.compactSpace_iff_seqCompactSpace\n-/\n\n"}