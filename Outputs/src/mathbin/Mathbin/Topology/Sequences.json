{"totally_bounded":
 "/-- A sequentially compact set in a uniform space is totally bounded. -/\nprotected theorem is_seq_compact.totally_bounded (h : is_seq_compact s) : totally_bounded s :=\n  by\n  intro V V_in\n  unfold is_seq_compact at h\n  contrapose! h\n  obtain âŸ¨u, u_in, huâŸ© : âˆƒ u : â„• â†’ X, (âˆ€ n, u n âˆˆ s) âˆ§ âˆ€ n m, m < n â†’ u m âˆ‰ ball (u n) V :=\n    by\n    simp only [not_subset, mem_Unionâ‚‚, not_exists, exists_prop] at h\n    simpa only [forall_and, ball_image_iff, not_and] using seq_of_forall_finite_exists h\n  refine' âŸ¨u, u_in, fun x x_in Ï† hÏ† huÏ† => _âŸ©\n  obtain âŸ¨N, hNâŸ© : âˆƒ N, âˆ€ p q, p â‰¥ N â†’ q â‰¥ N â†’ (u (Ï† p), u (Ï† q)) âˆˆ V\n  exact huÏ†.cauchy_seq.mem_entourage V_in\n  exact hu (Ï† <| N + 1) (Ï† N) (hÏ† <| lt_add_one N) (hN (N + 1) N N.le_succ le_rfl)\n#align is_seq_compact.totally_bounded is_seq_compact.totally_bounded\n\n",
 "tendsto_subseq_of_frequently_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A version of **Bolzano-Weistrass**: in a proper metric space (eg. $â„^n$),\nevery bounded sequence has a converging subsequence. This version assumes only\nthat the sequence is frequently in some bounded set. -/\ntheorem tendsto_subseq_of_frequently_bounded (hs : bounded s) {x : â„• â†’ X}\n    (hx :\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" at_top\n        (x n âˆˆ s)) :\n    âˆƒ a âˆˆ closure s, âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ tendsto (x âˆ˜ Ï†) at_top ((nhds) a) :=\n  have hcs : is_seq_compact (closure s) := hs.is_compact_closure.is_seq_compact\n  have hu' :\n    Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" at_top\n      (x n âˆˆ closure s) :=\n    hx.mono fun n hn => subset_closure hn\n  hcs.subseq_of_frequently_in hu'\n#align tendsto_subseq_of_frequently_bounded tendsto_subseq_of_frequently_bounded\n\n",
 "tendsto_subseq_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A version of Bolzano-Weistrass: in a proper metric space (eg. $â„^n$),\nevery bounded sequence has a converging subsequence. -/\ntheorem tendsto_subseq_of_bounded (hs : bounded s) {x : â„• â†’ X} (hx : âˆ€ n, x n âˆˆ s) :\n    âˆƒ a âˆˆ closure s, âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ tendsto (x âˆ˜ Ï†) at_top ((nhds) a) :=\n  tendsto_subseq_of_frequently_bounded hs <| frequently_of_forall hx\n#align tendsto_subseq_of_bounded tendsto_subseq_of_bounded\n\n",
 "tendsto_subseq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_compact.tendsto_subseq' {s : set X} {x : â„• â†’ X} (hs : is_compact s)\n    (hx :\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" at_top\n        (x n âˆˆ s)) :\n    âˆƒ a âˆˆ s, âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ tendsto (x âˆ˜ Ï†) at_top ((nhds) a) :=\n  hs.is_seq_compact.subseq_of_frequently_in hx\n#align is_compact.tendsto_subseq' is_compact.tendsto_subseq'\n\n",
 "tendsto_subseq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n-- see Note [lower instance priority]\ntheorem compact_space.tendsto_subseq [compact_space X] (x : â„• â†’ X) :\n    âˆƒ (a : _)(Ï† : â„• â†’ â„•), strict_mono Ï† âˆ§ tendsto (x âˆ˜ Ï†) at_top ((nhds) a) :=\n  seq_compact_space.tendsto_subseq x\n#align compact_space.tendsto_subseq compact_space.tendsto_subseq\n\n",
 "tendsto_nhds_iff_seq_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If the domain of a function `f : Î± â†’ Î²` is a FrÃ©chet-Urysohn space, then convergence\nis equivalent to sequential convergence. See also `filter.tendsto_iff_seq_tendsto` for a version\nthat works for any pair of filters assuming that the filter in the domain is countably generated.\n\nThis property is equivalent to the definition of `frechet_urysohn_space`, see\n`frechet_urysohn_space.of_seq_tendsto_imp_tendsto`. -/\ntheorem tendsto_nhds_iff_seq_tendsto [frechet_urysohn_space X] {f : X â†’ Y} {a : X} {b : Y} :\n    tendsto f ((nhds) a) ((nhds) b) â†” âˆ€ u : â„• â†’ X, tendsto u at_top ((nhds) a) â†’ tendsto (f âˆ˜ u) at_top ((nhds) b) :=\n  by\n  refine' âŸ¨fun hf u hu => hf.comp hu, fun h => ((nhds_basis_closeds _).tendsto_iff (nhds_basis_closeds _)).2 _âŸ©\n  rintro s âŸ¨hbs, hscâŸ©\n  refine' âŸ¨closure (Â«expr â»Â¹' Â» f s), âŸ¨mt _ hbs, is_closed_closureâŸ©, fun x => mt fun hx => subset_closure hxâŸ©\n  rw [â† seq_closure_eq_closure]\n  rintro âŸ¨u, hus, huâŸ©\n  exact hsc.mem_of_tendsto (h u hu) (eventually_of_forall hus)\n#align tendsto_nhds_iff_seq_tendsto tendsto_nhds_iff_seq_tendsto\n\n",
 "subset_seq_closure":
 "/-\nCopyright (c) 2018 Jan-David Salchow. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jan-David Salchow, Patrick Massot, Yury Kudryashov\n-/\ntheorem subset_seq_closure {s : set X} : s âŠ† seq_closure s := fun p hp => âŸ¨const â„• p, fun _ => hp, tendsto_const_nhdsâŸ©\n#align subset_seq_closure subset_seq_closure\n\n",
 "subseq_of_frequently_in":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_seq_compact.subseq_of_frequently_in {s : set X} (hs : is_seq_compact s) {x : â„• â†’ X}\n    (hx :\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" at_top\n        (x n âˆˆ s)) :\n    âˆƒ a âˆˆ s, âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ tendsto (x âˆ˜ Ï†) at_top ((nhds) a) :=\n  let âŸ¨Ïˆ, hÏˆ, huÏˆâŸ© := extraction_of_frequently_at_top hx\n  let âŸ¨a, a_in, Ï†, hÏ†, hâŸ© := hs huÏˆ\n  âŸ¨a, a_in, Ïˆ âˆ˜ Ï†, hÏˆ.comp hÏ†, hâŸ©\n#align is_seq_compact.subseq_of_frequently_in is_seq_compact.subseq_of_frequently_in\n\n",
 "sequential_space":
 "theorem quotient_map.sequential_space [sequential_space X] {f : X â†’ Y} (hf : quotient_map f) : sequential_space Y :=\n  âŸ¨fun s hs => hf.is_closed_preimage.mp <| (hs.preimage <| hf.continuous.seq_continuous).is_closedâŸ©\n#align quotient_map.sequential_space quotient_map.sequential_space\n\n",
 "seq_continuous":
 "-- A continuous function is sequentially continuous.\nprotected theorem continuous.seq_continuous {f : X â†’ Y} (hf : continuous f) : seq_continuous f := fun x p hx =>\n  (hf.tendsto p).comp hx\n#align continuous.seq_continuous continuous.seq_continuous\n\n",
 "seq_closure_subset_closure":
 "/-- The sequential closure of a set is contained in the closure of that set.\nThe converse is not true. -/\ntheorem seq_closure_subset_closure {s : set X} : seq_closure s âŠ† closure s := fun p âŸ¨x, xM, xpâŸ© =>\n  mem_closure_of_tendsto xp (univ_mem' xM)\n#align seq_closure_subset_closure seq_closure_subset_closure\n\n",
 "seq_closure_eq_closure":
 "theorem seq_closure_eq_closure [frechet_urysohn_space X] (s : set X) : seq_closure s = closure s :=\n  seq_closure_subset_closure.antisymm <| frechet_urysohn_space.closure_subset_seq_closure s\n#align seq_closure_eq_closure seq_closure_eq_closure\n\n",
 "seq_closure_eq":
 "/-- The sequential closure of a sequentially closed set is the set itself. -/\ntheorem is_seq_closed.seq_closure_eq {s : set X} (hs : is_seq_closed s) : seq_closure s = s :=\n  Subset.antisymm (fun p âŸ¨x, hx, hpâŸ© => hs hx hp) subset_seq_closure\n#align is_seq_closed.seq_closure_eq is_seq_closed.seq_closure_eq\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- The preimage of a sequentially closed set under a sequentially continuous map is sequentially\nclosed. -/\ntheorem is_seq_closed.preimage {f : X â†’ Y} {s : set Y} (hs : is_seq_closed s) (hf : seq_continuous f) :\n    is_seq_closed (Â«expr â»Â¹' Â» f s) := fun x p hx hp => hs hx (hf hp)\n#align is_seq_closed.preimage is_seq_closed.preimage\n\n",
 "of_seq_tendsto_imp_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- An alternative construction for `frechet_urysohn_space`: if sequential convergence implies\nconvergence, then the space is a FrÃ©chet-Urysohn space. -/\ntheorem frechet_urysohn_space.of_seq_tendsto_imp_tendsto\n    (h :\n      âˆ€ (f : X â†’ Prop) (a : X),\n        (âˆ€ u : â„• â†’ X, tendsto u at_top ((nhds) a) â†’ tendsto (f âˆ˜ u) at_top ((nhds) (f a))) â†’ continuous_at f a) :\n    frechet_urysohn_space X := by\n  refine' âŸ¨fun s x hcx => _âŸ©\n  specialize h (Â· âˆ‰ s) x\n  by_cases hx : x âˆˆ s; Â· exact subset_seq_closure hx\n  simp_rw [(Â· âˆ˜ Â·), continuous_at, hx, not_false_iff, nhds_true, tendsto_pure, eq_true_iff, â† mem_compl_iff,\n    eventually_mem_set, â† mem_interior_iff_mem_nhds, interior_compl] at h\n  rw [mem_compl_iff, imp_not_comm] at h\n  simp only [not_forall, not_eventually, mem_compl_iff, not_not] at h\n  rcases h hcx with âŸ¨u, hux, husâŸ©\n  rcases extraction_of_frequently_at_top hus with âŸ¨Ï†, Ï†_mono, hÏ†âŸ©\n  exact âŸ¨u âˆ˜ Ï†, hÏ†, hux.comp Ï†_mono.tendsto_at_topâŸ©\n#align frechet_urysohn_space.of_seq_tendsto_imp_tendsto frechet_urysohn_space.of_seq_tendsto_imp_tendsto\n\n",
 "mem_closure_iff_seq_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a FrÃ©chet-Urysohn space, a point belongs to the closure of a set iff it is a limit\nof a sequence taking values in this set. -/\ntheorem mem_closure_iff_seq_limit [frechet_urysohn_space X] {s : set X} {a : X} :\n    a âˆˆ closure s â†” âˆƒ x : â„• â†’ X, (âˆ€ n : â„•, x n âˆˆ s) âˆ§ tendsto x at_top ((nhds) a) :=\n  by\n  rw [â† seq_closure_eq_closure]\n  rfl\n#align mem_closure_iff_seq_limit mem_closure_iff_seq_limit\n\n",
 "lebesgue_number_lemma_of_metric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem seq_compact.lebesgue_number_lemma_of_metric {Î¹ : Sort _} {c : Î¹ â†’ set X} {s : set X} (hs : is_seq_compact s)\n    (hcâ‚ : âˆ€ i, is_open (c i))\n    (hcâ‚‚ : s âŠ† Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (c i)) :\n    âˆƒ Î´ > 0, âˆ€ a âˆˆ s, âˆƒ i, ball a Î´ âŠ† c i :=\n  lebesgue_number_lemma_of_metric hs.is_compact hcâ‚ hcâ‚‚\n#align seq_compact.lebesgue_number_lemma_of_metric seq_compact.lebesgue_number_lemma_of_metric\n\n",
 "is_seq_compact":
 "protected theorem is_compact.is_seq_compact {s : set X} (hs : is_compact s) : is_seq_compact s := fun x x_in =>\n  let âŸ¨a, a_in, haâŸ© := hs (tendsto_principal.mpr (eventually_of_forall x_in))\n  âŸ¨a, a_in, tendsto_subseq haâŸ©\n#align is_compact.is_seq_compact is_compact.is_seq_compact\n\n",
 "is_seq_closed_of_seq_closure_eq":
 "/-- If a set is equal to its sequential closure, then it is sequentially closed. -/\ntheorem is_seq_closed_of_seq_closure_eq {s : set X} (hs : seq_closure s = s) : is_seq_closed s := fun x p hxs hxp =>\n  hs â–¸ âŸ¨x, hxs, hxpâŸ©\n#align is_seq_closed_of_seq_closure_eq is_seq_closed_of_seq_closure_eq\n\n",
 "is_seq_closed_iff_is_closed":
 "/-- In a sequential space, a set is closed iff it's sequentially closed. -/\ntheorem is_seq_closed_iff_is_closed [sequential_space X] {M : set X} : is_seq_closed M â†” is_closed M :=\n  âŸ¨is_seq_closed.is_closed, is_closed.is_seq_closedâŸ©\n#align is_seq_closed_iff_is_closed is_seq_closed_iff_is_closed\n\n",
 "is_seq_closed_iff":
 "/-- A set is sequentially closed iff it is equal to its sequential closure. -/\ntheorem is_seq_closed_iff {s : set X} : is_seq_closed s â†” seq_closure s = s :=\n  âŸ¨is_seq_closed.seq_closure_eq, is_seq_closed_of_seq_closure_eqâŸ©\n#align is_seq_closed_iff is_seq_closed_iff\n\n",
 "is_seq_closed":
 "/-- A set is sequentially closed if it is closed. -/\nprotected theorem is_closed.is_seq_closed {s : set X} (hc : is_closed s) : is_seq_closed s := fun u x hu hx =>\n  hc.mem_of_tendsto hx (eventually_of_forall hu)\n#align is_closed.is_seq_closed is_closed.is_seq_closed\n\n",
 "is_complete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/-- A sequentially compact set in a uniform set with countably generated uniformity filter\nis complete. -/\nprotected theorem is_seq_compact.is_complete (hs : is_seq_compact s) : is_complete s :=\n  by\n  intro l hl hls\n  haveI := hl.1\n  rcases exists_antitone_basis ((uniformity) X) with âŸ¨V, hVâŸ©\n  choose W hW hWV using fun n => comp_mem_uniformity_sets (hV.mem n)\n  have hWV' : âˆ€ n, W n âŠ† V n := fun n âŸ¨x, yâŸ© hx => @hWV n (x, y) âŸ¨x, refl_mem_uniformity <| hW _, hxâŸ©\n  obtain âŸ¨t, ht_anti, htl, htW, htsâŸ© :\n    âˆƒ t : â„• â†’ set X, antitone t âˆ§ (âˆ€ n, t n âˆˆ l) âˆ§ (âˆ€ n, lower_set.prod (t n) (t n) âŠ† W n) âˆ§ âˆ€ n, t n âŠ† s :=\n    by\n    have : âˆ€ n, âˆƒ t âˆˆ l, lower_set.prod t t âŠ† W n âˆ§ t âŠ† s :=\n      by\n      rw [le_principal_iff] at hls\n      have : âˆ€ n, W n âˆ© lower_set.prod s s âˆˆ filter.prod l l := fun n => inter_mem (hl.2 (hW n)) (prod_mem_prod hls hls)\n      simpa only [l.basis_sets.prod_self.mem_iff, true_imp_iff, subset_inter_iff, prod_self_subset_prod_self,\n        and_assoc] using this\n    choose t htl htW hts\n    have :\n      âˆ€ n,\n        Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (t k) âŠ† t n :=\n      fun n => Interâ‚‚_subset _ le_rfl\n    exact\n      âŸ¨fun n => Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (t k),\n        fun m n h => bInter_subset_bInter_left fun k (hk : k â‰¤ m) => hk.trans h, fun n =>\n        (bInter_mem (finite_le_nat n)).2 fun k hk => htl k, fun n => (prod_mono (this n) (this n)).trans (htW n),\n        fun n => (this n).trans (hts n)âŸ©\n  choose u hu using fun n => filter.nonempty_of_mem (htl n)\n  have huc : cauchy_seq u :=\n    hV.to_has_basis.cauchy_seq_iff.2 fun N hN =>\n      âŸ¨N, fun m hm n hn => hWV' _ <| @htW N (_, _) âŸ¨ht_anti hm (hu _), ht_anti hn (hu _)âŸ©âŸ©\n  rcases hs.exists_tendsto (fun n => hts n (hu n)) huc with âŸ¨x, hxs, hxâŸ©\n  refine' âŸ¨x, hxs, (nhds_basis_uniformity' hV.to_has_basis).ge_iff.2 fun N hN => _âŸ©\n  obtain âŸ¨n, hNn, hnâŸ© : âˆƒ n, N â‰¤ n âˆ§ u n âˆˆ ball x (W N)\n  exact ((eventually_ge_at_top N).and (hx <| ball_mem_nhds x (hW N))).exists\n  refine' mem_of_superset (htl n) fun y hy => hWV N âŸ¨u n, _, htW N âŸ¨_, _âŸ©âŸ©\n  exacts[hn, ht_anti hNn (hu n), ht_anti hNn hy]\n#align is_seq_compact.is_complete is_seq_compact.is_complete\n\n",
 "is_compact_iff_is_seq_compact":
 "/-- A version of Bolzano-Weistrass: in a uniform space with countably generated uniformity filter\n(e.g., in a metric space), a set is compact if and only if it is sequentially compact. -/\nprotected theorem uniform_space.is_compact_iff_is_seq_compact : is_compact s â†” is_seq_compact s :=\n  âŸ¨fun H => H.is_seq_compact, fun H => H.is_compactâŸ©\n#align uniform_space.is_compact_iff_is_seq_compact uniform_space.is_compact_iff_is_seq_compact\n\n",
 "is_compact":
 "/-- If `ğ“¤ Î²` is countably generated, then any sequentially compact set is compact. -/\nprotected theorem is_seq_compact.is_compact (hs : is_seq_compact s) : is_compact s :=\n  is_compact_iff_totally_bounded_is_complete.2 âŸ¨hs.totally_bounded, hs.is_completeâŸ©\n#align is_seq_compact.is_compact is_seq_compact.is_compact\n\n",
 "is_closed":
 "-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n/-- In a sequential space, a sequentially closed set is closed. -/\nprotected theorem is_seq_closed.is_closed [sequential_space X] {s : set X} (hs : is_seq_closed s) : is_closed s :=\n  sequential_space.is_closed_of_seq s hs\n#align is_seq_closed.is_closed is_seq_closed.is_closed\n\n",
 "exists_tendsto_of_frequently_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_seq_compact.exists_tendsto_of_frequently_mem (hs : is_seq_compact s) {u : â„• â†’ X}\n    (hu :\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" at_top\n        (u n âˆˆ s))\n    (huc : cauchy_seq u) : âˆƒ x âˆˆ s, tendsto u at_top ((nhds) x) :=\n  let âŸ¨x, hxs, Ï†, Ï†_mono, hxâŸ© := hs.subseq_of_frequently_in hu\n  âŸ¨x, hxs, tendsto_nhds_of_cauchy_seq_of_subseq huc Ï†_mono.tendsto_at_top hxâŸ©\n#align is_seq_compact.exists_tendsto_of_frequently_mem is_seq_compact.exists_tendsto_of_frequently_mem\n\n",
 "exists_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_seq_compact.exists_tendsto (hs : is_seq_compact s) {u : â„• â†’ X} (hu : âˆ€ n, u n âˆˆ s) (huc : cauchy_seq u) :\n    âˆƒ x âˆˆ s, tendsto u at_top ((nhds) x) :=\n  hs.exists_tendsto_of_frequently_mem (frequently_of_forall hu) huc\n#align is_seq_compact.exists_tendsto is_seq_compact.exists_tendsto\n\n",
 "continuous_iff_seq_continuous":
 "/-- If the domain of a function is a sequential space, then continuity of this function is\nequivalent to its sequential continuity. -/\ntheorem continuous_iff_seq_continuous [sequential_space X] {f : X â†’ Y} : continuous f â†” seq_continuous f :=\n  âŸ¨continuous.seq_continuous, seq_continuous.continuousâŸ©\n#align continuous_iff_seq_continuous continuous_iff_seq_continuous\n\n",
 "continuous":
 "/-- A sequentially continuous function defined on a sequential space is continuous. -/\nprotected theorem seq_continuous.continuous [sequential_space X] {f : X â†’ Y} (hf : seq_continuous f) : continuous f :=\n  continuous_iff_is_closed.mpr fun s hs => (hs.is_seq_closed.preimage hf).is_closed\n#align seq_continuous.continuous seq_continuous.continuous\n\n",
 "compact_space_iff_seq_compact_space":
 "theorem uniform_space.compact_space_iff_seq_compact_space : compact_space X â†” seq_compact_space X := by\n  simp only [â† is_compact_univ_iff, seq_compact_space_iff, uniform_space.is_compact_iff_is_seq_compact]\n#align uniform_space.compact_space_iff_seq_compact_space uniform_space.compact_space_iff_seq_compact_space\n\n"}