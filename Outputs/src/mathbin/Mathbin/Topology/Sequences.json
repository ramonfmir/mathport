{"totally_bounded":
 "/-- A sequentially compact set in a uniform space is totally bounded. -/\nprotected theorem is_seq_compact.totally_bounded (h : is_seq_compact s) : totally_bounded s :=\n  by\n  intro V V_in\n  unfold is_seq_compact at h\n  contrapose! h\n  obtain ⟨u, u_in, hu⟩ : ∃ u : ℕ → X, (∀ n, u n ∈ s) ∧ ∀ n m, m < n → u m ∉ ball (u n) V :=\n    by\n    simp only [not_subset, mem_Union₂, not_exists, exists_prop] at h\n    simpa only [forall_and, ball_image_iff, not_and] using seq_of_forall_finite_exists h\n  refine' ⟨u, u_in, fun x x_in φ hφ huφ => _⟩\n  obtain ⟨N, hN⟩ : ∃ N, ∀ p q, p ≥ N → q ≥ N → (u (φ p), u (φ q)) ∈ V\n  exact huφ.cauchy_seq.mem_entourage V_in\n  exact hu (φ <| N + 1) (φ N) (hφ <| lt_add_one N) (hN (N + 1) N N.le_succ le_rfl)\n#align is_seq_compact.totally_bounded is_seq_compact.totally_bounded\n\n",
 "tendsto_subseq_of_frequently_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A version of **Bolzano-Weistrass**: in a proper metric space (eg. $ℝ^n$),\nevery bounded sequence has a converging subsequence. This version assumes only\nthat the sequence is frequently in some bounded set. -/\ntheorem tendsto_subseq_of_frequently_bounded (hs : bounded s) {x : ℕ → X}\n    (hx :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n        (x n ∈ s)) :\n    ∃ a ∈ closure s, ∃ φ : ℕ → ℕ, strict_mono φ ∧ tendsto (x ∘ φ) at_top ((nhds) a) :=\n  have hcs : is_seq_compact (closure s) := hs.is_compact_closure.is_seq_compact\n  have hu' :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n      (x n ∈ closure s) :=\n    hx.mono fun n hn => subset_closure hn\n  hcs.subseq_of_frequently_in hu'\n#align tendsto_subseq_of_frequently_bounded tendsto_subseq_of_frequently_bounded\n\n",
 "tendsto_subseq_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A version of Bolzano-Weistrass: in a proper metric space (eg. $ℝ^n$),\nevery bounded sequence has a converging subsequence. -/\ntheorem tendsto_subseq_of_bounded (hs : bounded s) {x : ℕ → X} (hx : ∀ n, x n ∈ s) :\n    ∃ a ∈ closure s, ∃ φ : ℕ → ℕ, strict_mono φ ∧ tendsto (x ∘ φ) at_top ((nhds) a) :=\n  tendsto_subseq_of_frequently_bounded hs <| frequently_of_forall hx\n#align tendsto_subseq_of_bounded tendsto_subseq_of_bounded\n\n",
 "tendsto_subseq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_compact.tendsto_subseq' {s : set X} {x : ℕ → X} (hs : is_compact s)\n    (hx :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n        (x n ∈ s)) :\n    ∃ a ∈ s, ∃ φ : ℕ → ℕ, strict_mono φ ∧ tendsto (x ∘ φ) at_top ((nhds) a) :=\n  hs.is_seq_compact.subseq_of_frequently_in hx\n#align is_compact.tendsto_subseq' is_compact.tendsto_subseq'\n\n",
 "tendsto_subseq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n-- see Note [lower instance priority]\ntheorem compact_space.tendsto_subseq [compact_space X] (x : ℕ → X) :\n    ∃ (a : _)(φ : ℕ → ℕ), strict_mono φ ∧ tendsto (x ∘ φ) at_top ((nhds) a) :=\n  seq_compact_space.tendsto_subseq x\n#align compact_space.tendsto_subseq compact_space.tendsto_subseq\n\n",
 "tendsto_nhds_iff_seq_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If the domain of a function `f : α → β` is a Fréchet-Urysohn space, then convergence\nis equivalent to sequential convergence. See also `filter.tendsto_iff_seq_tendsto` for a version\nthat works for any pair of filters assuming that the filter in the domain is countably generated.\n\nThis property is equivalent to the definition of `frechet_urysohn_space`, see\n`frechet_urysohn_space.of_seq_tendsto_imp_tendsto`. -/\ntheorem tendsto_nhds_iff_seq_tendsto [frechet_urysohn_space X] {f : X → Y} {a : X} {b : Y} :\n    tendsto f ((nhds) a) ((nhds) b) ↔ ∀ u : ℕ → X, tendsto u at_top ((nhds) a) → tendsto (f ∘ u) at_top ((nhds) b) :=\n  by\n  refine' ⟨fun hf u hu => hf.comp hu, fun h => ((nhds_basis_closeds _).tendsto_iff (nhds_basis_closeds _)).2 _⟩\n  rintro s ⟨hbs, hsc⟩\n  refine' ⟨closure («expr ⁻¹' » f s), ⟨mt _ hbs, is_closed_closure⟩, fun x => mt fun hx => subset_closure hx⟩\n  rw [← seq_closure_eq_closure]\n  rintro ⟨u, hus, hu⟩\n  exact hsc.mem_of_tendsto (h u hu) (eventually_of_forall hus)\n#align tendsto_nhds_iff_seq_tendsto tendsto_nhds_iff_seq_tendsto\n\n",
 "subset_seq_closure":
 "/-\nCopyright (c) 2018 Jan-David Salchow. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jan-David Salchow, Patrick Massot, Yury Kudryashov\n-/\ntheorem subset_seq_closure {s : set X} : s ⊆ seq_closure s := fun p hp => ⟨const ℕ p, fun _ => hp, tendsto_const_nhds⟩\n#align subset_seq_closure subset_seq_closure\n\n",
 "subseq_of_frequently_in":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_seq_compact.subseq_of_frequently_in {s : set X} (hs : is_seq_compact s) {x : ℕ → X}\n    (hx :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n        (x n ∈ s)) :\n    ∃ a ∈ s, ∃ φ : ℕ → ℕ, strict_mono φ ∧ tendsto (x ∘ φ) at_top ((nhds) a) :=\n  let ⟨ψ, hψ, huψ⟩ := extraction_of_frequently_at_top hx\n  let ⟨a, a_in, φ, hφ, h⟩ := hs huψ\n  ⟨a, a_in, ψ ∘ φ, hψ.comp hφ, h⟩\n#align is_seq_compact.subseq_of_frequently_in is_seq_compact.subseq_of_frequently_in\n\n",
 "sequential_space":
 "theorem quotient_map.sequential_space [sequential_space X] {f : X → Y} (hf : quotient_map f) : sequential_space Y :=\n  ⟨fun s hs => hf.is_closed_preimage.mp <| (hs.preimage <| hf.continuous.seq_continuous).is_closed⟩\n#align quotient_map.sequential_space quotient_map.sequential_space\n\n",
 "seq_continuous":
 "-- A continuous function is sequentially continuous.\nprotected theorem continuous.seq_continuous {f : X → Y} (hf : continuous f) : seq_continuous f := fun x p hx =>\n  (hf.tendsto p).comp hx\n#align continuous.seq_continuous continuous.seq_continuous\n\n",
 "seq_closure_subset_closure":
 "/-- The sequential closure of a set is contained in the closure of that set.\nThe converse is not true. -/\ntheorem seq_closure_subset_closure {s : set X} : seq_closure s ⊆ closure s := fun p ⟨x, xM, xp⟩ =>\n  mem_closure_of_tendsto xp (univ_mem' xM)\n#align seq_closure_subset_closure seq_closure_subset_closure\n\n",
 "seq_closure_eq_closure":
 "theorem seq_closure_eq_closure [frechet_urysohn_space X] (s : set X) : seq_closure s = closure s :=\n  seq_closure_subset_closure.antisymm <| frechet_urysohn_space.closure_subset_seq_closure s\n#align seq_closure_eq_closure seq_closure_eq_closure\n\n",
 "seq_closure_eq":
 "/-- The sequential closure of a sequentially closed set is the set itself. -/\ntheorem is_seq_closed.seq_closure_eq {s : set X} (hs : is_seq_closed s) : seq_closure s = s :=\n  Subset.antisymm (fun p ⟨x, hx, hp⟩ => hs hx hp) subset_seq_closure\n#align is_seq_closed.seq_closure_eq is_seq_closed.seq_closure_eq\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- The preimage of a sequentially closed set under a sequentially continuous map is sequentially\nclosed. -/\ntheorem is_seq_closed.preimage {f : X → Y} {s : set Y} (hs : is_seq_closed s) (hf : seq_continuous f) :\n    is_seq_closed («expr ⁻¹' » f s) := fun x p hx hp => hs hx (hf hp)\n#align is_seq_closed.preimage is_seq_closed.preimage\n\n",
 "of_seq_tendsto_imp_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- An alternative construction for `frechet_urysohn_space`: if sequential convergence implies\nconvergence, then the space is a Fréchet-Urysohn space. -/\ntheorem frechet_urysohn_space.of_seq_tendsto_imp_tendsto\n    (h :\n      ∀ (f : X → Prop) (a : X),\n        (∀ u : ℕ → X, tendsto u at_top ((nhds) a) → tendsto (f ∘ u) at_top ((nhds) (f a))) → continuous_at f a) :\n    frechet_urysohn_space X := by\n  refine' ⟨fun s x hcx => _⟩\n  specialize h (· ∉ s) x\n  by_cases hx : x ∈ s; · exact subset_seq_closure hx\n  simp_rw [(· ∘ ·), continuous_at, hx, not_false_iff, nhds_true, tendsto_pure, eq_true_iff, ← mem_compl_iff,\n    eventually_mem_set, ← mem_interior_iff_mem_nhds, interior_compl] at h\n  rw [mem_compl_iff, imp_not_comm] at h\n  simp only [not_forall, not_eventually, mem_compl_iff, not_not] at h\n  rcases h hcx with ⟨u, hux, hus⟩\n  rcases extraction_of_frequently_at_top hus with ⟨φ, φ_mono, hφ⟩\n  exact ⟨u ∘ φ, hφ, hux.comp φ_mono.tendsto_at_top⟩\n#align frechet_urysohn_space.of_seq_tendsto_imp_tendsto frechet_urysohn_space.of_seq_tendsto_imp_tendsto\n\n",
 "mem_closure_iff_seq_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a Fréchet-Urysohn space, a point belongs to the closure of a set iff it is a limit\nof a sequence taking values in this set. -/\ntheorem mem_closure_iff_seq_limit [frechet_urysohn_space X] {s : set X} {a : X} :\n    a ∈ closure s ↔ ∃ x : ℕ → X, (∀ n : ℕ, x n ∈ s) ∧ tendsto x at_top ((nhds) a) :=\n  by\n  rw [← seq_closure_eq_closure]\n  rfl\n#align mem_closure_iff_seq_limit mem_closure_iff_seq_limit\n\n",
 "lebesgue_number_lemma_of_metric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem seq_compact.lebesgue_number_lemma_of_metric {ι : Sort _} {c : ι → set X} {s : set X} (hs : is_seq_compact s)\n    (hc₁ : ∀ i, is_open (c i))\n    (hc₂ : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (c i)) :\n    ∃ δ > 0, ∀ a ∈ s, ∃ i, ball a δ ⊆ c i :=\n  lebesgue_number_lemma_of_metric hs.is_compact hc₁ hc₂\n#align seq_compact.lebesgue_number_lemma_of_metric seq_compact.lebesgue_number_lemma_of_metric\n\n",
 "is_seq_compact":
 "protected theorem is_compact.is_seq_compact {s : set X} (hs : is_compact s) : is_seq_compact s := fun x x_in =>\n  let ⟨a, a_in, ha⟩ := hs (tendsto_principal.mpr (eventually_of_forall x_in))\n  ⟨a, a_in, tendsto_subseq ha⟩\n#align is_compact.is_seq_compact is_compact.is_seq_compact\n\n",
 "is_seq_closed_of_seq_closure_eq":
 "/-- If a set is equal to its sequential closure, then it is sequentially closed. -/\ntheorem is_seq_closed_of_seq_closure_eq {s : set X} (hs : seq_closure s = s) : is_seq_closed s := fun x p hxs hxp =>\n  hs ▸ ⟨x, hxs, hxp⟩\n#align is_seq_closed_of_seq_closure_eq is_seq_closed_of_seq_closure_eq\n\n",
 "is_seq_closed_iff_is_closed":
 "/-- In a sequential space, a set is closed iff it's sequentially closed. -/\ntheorem is_seq_closed_iff_is_closed [sequential_space X] {M : set X} : is_seq_closed M ↔ is_closed M :=\n  ⟨is_seq_closed.is_closed, is_closed.is_seq_closed⟩\n#align is_seq_closed_iff_is_closed is_seq_closed_iff_is_closed\n\n",
 "is_seq_closed_iff":
 "/-- A set is sequentially closed iff it is equal to its sequential closure. -/\ntheorem is_seq_closed_iff {s : set X} : is_seq_closed s ↔ seq_closure s = s :=\n  ⟨is_seq_closed.seq_closure_eq, is_seq_closed_of_seq_closure_eq⟩\n#align is_seq_closed_iff is_seq_closed_iff\n\n",
 "is_seq_closed":
 "/-- A set is sequentially closed if it is closed. -/\nprotected theorem is_closed.is_seq_closed {s : set X} (hc : is_closed s) : is_seq_closed s := fun u x hu hx =>\n  hc.mem_of_tendsto hx (eventually_of_forall hu)\n#align is_closed.is_seq_closed is_closed.is_seq_closed\n\n",
 "is_complete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- A sequentially compact set in a uniform set with countably generated uniformity filter\nis complete. -/\nprotected theorem is_seq_compact.is_complete (hs : is_seq_compact s) : is_complete s :=\n  by\n  intro l hl hls\n  haveI := hl.1\n  rcases exists_antitone_basis ((uniformity) X) with ⟨V, hV⟩\n  choose W hW hWV using fun n => comp_mem_uniformity_sets (hV.mem n)\n  have hWV' : ∀ n, W n ⊆ V n := fun n ⟨x, y⟩ hx => @hWV n (x, y) ⟨x, refl_mem_uniformity <| hW _, hx⟩\n  obtain ⟨t, ht_anti, htl, htW, hts⟩ :\n    ∃ t : ℕ → set X, antitone t ∧ (∀ n, t n ∈ l) ∧ (∀ n, lower_set.prod (t n) (t n) ⊆ W n) ∧ ∀ n, t n ⊆ s :=\n    by\n    have : ∀ n, ∃ t ∈ l, lower_set.prod t t ⊆ W n ∧ t ⊆ s :=\n      by\n      rw [le_principal_iff] at hls\n      have : ∀ n, W n ∩ lower_set.prod s s ∈ filter.prod l l := fun n => inter_mem (hl.2 (hW n)) (prod_mem_prod hls hls)\n      simpa only [l.basis_sets.prod_self.mem_iff, true_imp_iff, subset_inter_iff, prod_self_subset_prod_self,\n        and_assoc] using this\n    choose t htl htW hts\n    have :\n      ∀ n,\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (t k) ⊆ t n :=\n      fun n => Inter₂_subset _ le_rfl\n    exact\n      ⟨fun n => «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (t k),\n        fun m n h => bInter_subset_bInter_left fun k (hk : k ≤ m) => hk.trans h, fun n =>\n        (bInter_mem (finite_le_nat n)).2 fun k hk => htl k, fun n => (prod_mono (this n) (this n)).trans (htW n),\n        fun n => (this n).trans (hts n)⟩\n  choose u hu using fun n => filter.nonempty_of_mem (htl n)\n  have huc : cauchy_seq u :=\n    hV.to_has_basis.cauchy_seq_iff.2 fun N hN =>\n      ⟨N, fun m hm n hn => hWV' _ <| @htW N (_, _) ⟨ht_anti hm (hu _), ht_anti hn (hu _)⟩⟩\n  rcases hs.exists_tendsto (fun n => hts n (hu n)) huc with ⟨x, hxs, hx⟩\n  refine' ⟨x, hxs, (nhds_basis_uniformity' hV.to_has_basis).ge_iff.2 fun N hN => _⟩\n  obtain ⟨n, hNn, hn⟩ : ∃ n, N ≤ n ∧ u n ∈ ball x (W N)\n  exact ((eventually_ge_at_top N).and (hx <| ball_mem_nhds x (hW N))).exists\n  refine' mem_of_superset (htl n) fun y hy => hWV N ⟨u n, _, htW N ⟨_, _⟩⟩\n  exacts[hn, ht_anti hNn (hu n), ht_anti hNn hy]\n#align is_seq_compact.is_complete is_seq_compact.is_complete\n\n",
 "is_compact_iff_is_seq_compact":
 "/-- A version of Bolzano-Weistrass: in a uniform space with countably generated uniformity filter\n(e.g., in a metric space), a set is compact if and only if it is sequentially compact. -/\nprotected theorem uniform_space.is_compact_iff_is_seq_compact : is_compact s ↔ is_seq_compact s :=\n  ⟨fun H => H.is_seq_compact, fun H => H.is_compact⟩\n#align uniform_space.is_compact_iff_is_seq_compact uniform_space.is_compact_iff_is_seq_compact\n\n",
 "is_compact":
 "/-- If `𝓤 β` is countably generated, then any sequentially compact set is compact. -/\nprotected theorem is_seq_compact.is_compact (hs : is_seq_compact s) : is_compact s :=\n  is_compact_iff_totally_bounded_is_complete.2 ⟨hs.totally_bounded, hs.is_complete⟩\n#align is_seq_compact.is_compact is_seq_compact.is_compact\n\n",
 "is_closed":
 "-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n/-- In a sequential space, a sequentially closed set is closed. -/\nprotected theorem is_seq_closed.is_closed [sequential_space X] {s : set X} (hs : is_seq_closed s) : is_closed s :=\n  sequential_space.is_closed_of_seq s hs\n#align is_seq_closed.is_closed is_seq_closed.is_closed\n\n",
 "exists_tendsto_of_frequently_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_seq_compact.exists_tendsto_of_frequently_mem (hs : is_seq_compact s) {u : ℕ → X}\n    (hu :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n        (u n ∈ s))\n    (huc : cauchy_seq u) : ∃ x ∈ s, tendsto u at_top ((nhds) x) :=\n  let ⟨x, hxs, φ, φ_mono, hx⟩ := hs.subseq_of_frequently_in hu\n  ⟨x, hxs, tendsto_nhds_of_cauchy_seq_of_subseq huc φ_mono.tendsto_at_top hx⟩\n#align is_seq_compact.exists_tendsto_of_frequently_mem is_seq_compact.exists_tendsto_of_frequently_mem\n\n",
 "exists_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_seq_compact.exists_tendsto (hs : is_seq_compact s) {u : ℕ → X} (hu : ∀ n, u n ∈ s) (huc : cauchy_seq u) :\n    ∃ x ∈ s, tendsto u at_top ((nhds) x) :=\n  hs.exists_tendsto_of_frequently_mem (frequently_of_forall hu) huc\n#align is_seq_compact.exists_tendsto is_seq_compact.exists_tendsto\n\n",
 "continuous_iff_seq_continuous":
 "/-- If the domain of a function is a sequential space, then continuity of this function is\nequivalent to its sequential continuity. -/\ntheorem continuous_iff_seq_continuous [sequential_space X] {f : X → Y} : continuous f ↔ seq_continuous f :=\n  ⟨continuous.seq_continuous, seq_continuous.continuous⟩\n#align continuous_iff_seq_continuous continuous_iff_seq_continuous\n\n",
 "continuous":
 "/-- A sequentially continuous function defined on a sequential space is continuous. -/\nprotected theorem seq_continuous.continuous [sequential_space X] {f : X → Y} (hf : seq_continuous f) : continuous f :=\n  continuous_iff_is_closed.mpr fun s hs => (hs.is_seq_closed.preimage hf).is_closed\n#align seq_continuous.continuous seq_continuous.continuous\n\n",
 "compact_space_iff_seq_compact_space":
 "theorem uniform_space.compact_space_iff_seq_compact_space : compact_space X ↔ seq_compact_space X := by\n  simp only [← is_compact_univ_iff, seq_compact_space_iff, uniform_space.is_compact_iff_is_seq_compact]\n#align uniform_space.compact_space_iff_seq_compact_space uniform_space.compact_space_iff_seq_compact_space\n\n"}