{"totallyBounded":
 "#print IsSeqCompact.totallyBounded /-\n/-- A sequentially compact set in a uniform space is totally bounded. -/\nprotected theorem IsSeqCompact.totallyBounded (h : IsSeqCompact s) : TotallyBounded s :=\n  by\n  intro V V_in\n  unfold IsSeqCompact at h\n  contrapose! h\n  obtain ‚ü®u, u_in, hu‚ü© : ‚àÉ u : ‚Ñï ‚Üí X, (‚àÄ n, u n ‚àà s) ‚àß ‚àÄ n m, m < n ‚Üí u m ‚àâ ball (u n) V :=\n    by\n    simp only [not_subset, mem_Union‚ÇÇ, not_exists, exists_prop] at h\n    simpa only [forall_and, ball_image_iff, not_and] using seq_of_forall_finite_exists h\n  refine' ‚ü®u, u_in, fun x x_in œÜ hœÜ huœÜ => _‚ü©\n  obtain ‚ü®N, hN‚ü© : ‚àÉ N, ‚àÄ p q, p ‚â• N ‚Üí q ‚â• N ‚Üí (u (œÜ p), u (œÜ q)) ‚àà V\n  exact huœÜ.cauchy_seq.mem_entourage V_in\n  exact hu (œÜ <| N + 1) (œÜ N) (hœÜ <| lt_add_one N) (hN (N + 1) N N.le_succ le_rfl)\n#align is_seq_compact.totally_bounded IsSeqCompact.totallyBounded\n-/\n\n",
 "tendsto_subseq_of_frequently_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÉ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÉ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÉ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÉ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_subseq_of_frequently_bounded /-\n/-- A version of **Bolzano-Weistrass**: in a proper metric space (eg. $‚Ñù^n$),\nevery bounded sequence has a converging subsequence. This version assumes only\nthat the sequence is frequently in some bounded set. -/\ntheorem tendsto_subseq_of_frequently_bounded (hs : Bounded s) {x : ‚Ñï ‚Üí X}\n    (hx :\n      ¬´expr‚àÉ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÉ·∂† in , ¬ª\" atTop\n        (x n ‚àà s)) :\n    ‚àÉ a ‚àà closure s, ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß Tendsto (x ‚àò œÜ) atTop ((nhds) a) :=\n  have hcs : IsSeqCompact (closure s) := hs.is_compact_closure.is_seq_compact\n  have hu' :\n    ¬´expr‚àÉ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÉ·∂† in , ¬ª\" atTop\n      (x n ‚àà closure s) :=\n    hx.mono fun n hn => subset_closure hn\n  hcs.subseq_of_frequently_in hu'\n#align tendsto_subseq_of_frequently_bounded tendsto_subseq_of_frequently_bounded\n-/\n\n",
 "tendsto_subseq_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_subseq_of_bounded /-\n/-- A version of Bolzano-Weistrass: in a proper metric space (eg. $‚Ñù^n$),\nevery bounded sequence has a converging subsequence. -/\ntheorem tendsto_subseq_of_bounded (hs : Bounded s) {x : ‚Ñï ‚Üí X} (hx : ‚àÄ n, x n ‚àà s) :\n    ‚àÉ a ‚àà closure s, ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß Tendsto (x ‚àò œÜ) atTop ((nhds) a) :=\n  tendsto_subseq_of_frequently_bounded hs <| frequently_of_forall hx\n#align tendsto_subseq_of_bounded tendsto_subseq_of_bounded\n-/\n\n",
 "tendsto_subseq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÉ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÉ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsCompact.tendsto_subseq' /-\ntheorem IsCompact.tendsto_subseq' {s : Set X} {x : ‚Ñï ‚Üí X} (hs : IsCompact s)\n    (hx :\n      ¬´expr‚àÉ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÉ·∂† in , ¬ª\" atTop\n        (x n ‚àà s)) :\n    ‚àÉ a ‚àà s, ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß Tendsto (x ‚àò œÜ) atTop ((nhds) a) :=\n  hs.is_seq_compact.subseq_of_frequently_in hx\n#align is_compact.tendsto_subseq' IsCompact.tendsto_subseq'\n-/\n\n",
 "tendsto_subseq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print CompactSpace.tendsto_subseq /-\n-- see Note [lower instance priority]\ntheorem CompactSpace.tendsto_subseq [CompactSpace X] (x : ‚Ñï ‚Üí X) :\n    ‚àÉ (a : _)(œÜ : ‚Ñï ‚Üí ‚Ñï), StrictMono œÜ ‚àß Tendsto (x ‚àò œÜ) atTop ((nhds) a) :=\n  SeqCompactSpace.tendsto_subseq x\n#align compact_space.tendsto_subseq CompactSpace.tendsto_subseq\n-/\n\n",
 "tendsto_nhds_iff_seq_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_nhds_iff_seq_tendsto /-\n/-- If the domain of a function `f : Œ± ‚Üí Œ≤` is a Fr√©chet-Urysohn space, then convergence\nis equivalent to sequential convergence. See also `filter.tendsto_iff_seq_tendsto` for a version\nthat works for any pair of filters assuming that the filter in the domain is countably generated.\n\nThis property is equivalent to the definition of `frechet_urysohn_space`, see\n`frechet_urysohn_space.of_seq_tendsto_imp_tendsto`. -/\ntheorem tendsto_nhds_iff_seq_tendsto [FrechetUrysohnSpace X] {f : X ‚Üí Y} {a : X} {b : Y} :\n    Tendsto f ((nhds) a) ((nhds) b) ‚Üî ‚àÄ u : ‚Ñï ‚Üí X, Tendsto u atTop ((nhds) a) ‚Üí Tendsto (f ‚àò u) atTop ((nhds) b) :=\n  by\n  refine' ‚ü®fun hf u hu => hf.comp hu, fun h => ((nhds_basis_closeds _).tendsto_iff (nhds_basis_closeds _)).2 _‚ü©\n  rintro s ‚ü®hbs, hsc‚ü©\n  refine' ‚ü®closure (¬´expr ‚Åª¬π' ¬ª f s), ‚ü®mt _ hbs, isClosed_closure‚ü©, fun x => mt fun hx => subset_closure hx‚ü©\n  rw [‚Üê seqClosure_eq_closure]\n  rintro ‚ü®u, hus, hu‚ü©\n  exact hsc.mem_of_tendsto (h u hu) (eventually_of_forall hus)\n#align tendsto_nhds_iff_seq_tendsto tendsto_nhds_iff_seq_tendsto\n-/\n\n",
 "subset_seqClosure":
 "#print subset_seqClosure /-\n/-\nCopyright (c) 2018 Jan-David Salchow. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jan-David Salchow, Patrick Massot, Yury Kudryashov\n-/\ntheorem subset_seqClosure {s : Set X} : s ‚äÜ seqClosure s := fun p hp => ‚ü®const ‚Ñï p, fun _ => hp, tendsto_const_nhds‚ü©\n#align subset_seq_closure subset_seqClosure\n-/\n\n",
 "subseq_of_frequently_in":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÉ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÉ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsSeqCompact.subseq_of_frequently_in /-\ntheorem IsSeqCompact.subseq_of_frequently_in {s : Set X} (hs : IsSeqCompact s) {x : ‚Ñï ‚Üí X}\n    (hx :\n      ¬´expr‚àÉ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÉ·∂† in , ¬ª\" atTop\n        (x n ‚àà s)) :\n    ‚àÉ a ‚àà s, ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß Tendsto (x ‚àò œÜ) atTop ((nhds) a) :=\n  let ‚ü®œà, hœà, huœà‚ü© := extraction_of_frequently_atTop hx\n  let ‚ü®a, a_in, œÜ, hœÜ, h‚ü© := hs huœà\n  ‚ü®a, a_in, œà ‚àò œÜ, hœà.comp hœÜ, h‚ü©\n#align is_seq_compact.subseq_of_frequently_in IsSeqCompact.subseq_of_frequently_in\n-/\n\n",
 "sequentialSpace":
 "#print QuotientMap.sequentialSpace /-\ntheorem QuotientMap.sequentialSpace [SequentialSpace X] {f : X ‚Üí Y} (hf : QuotientMap f) : SequentialSpace Y :=\n  ‚ü®fun s hs => hf.is_closed_preimage.mp <| (hs.preimage <| hf.continuous.seq_continuous).is_closed‚ü©\n#align quotient_map.sequential_space QuotientMap.sequentialSpace\n-/\n\n",
 "seqContinuous":
 "#print Continuous.seqContinuous /-\n-- A continuous function is sequentially continuous.\nprotected theorem Continuous.seqContinuous {f : X ‚Üí Y} (hf : Continuous f) : SeqContinuous f := fun x p hx =>\n  (hf.tendsto p).comp hx\n#align continuous.seq_continuous Continuous.seqContinuous\n-/\n\n",
 "seqClosure_subset_closure":
 "#print seqClosure_subset_closure /-\n/-- The sequential closure of a set is contained in the closure of that set.\nThe converse is not true. -/\ntheorem seqClosure_subset_closure {s : Set X} : seqClosure s ‚äÜ closure s := fun p ‚ü®x, xM, xp‚ü© =>\n  mem_closure_of_tendsto xp (univ_mem' xM)\n#align seq_closure_subset_closure seqClosure_subset_closure\n-/\n\n",
 "seqClosure_eq_closure":
 "#print seqClosure_eq_closure /-\ntheorem seqClosure_eq_closure [FrechetUrysohnSpace X] (s : Set X) : seqClosure s = closure s :=\n  seqClosure_subset_closure.antisymm <| frechet_urysohn_space.closure_subset_seq_closure s\n#align seq_closure_eq_closure seqClosure_eq_closure\n-/\n\n",
 "seqClosure_eq":
 "#print IsSeqClosed.seqClosure_eq /-\n/-- The sequential closure of a sequentially closed set is the set itself. -/\ntheorem IsSeqClosed.seqClosure_eq {s : Set X} (hs : IsSeqClosed s) : seqClosure s = s :=\n  Subset.antisymm (fun p ‚ü®x, hx, hp‚ü© => hs hx hp) subset_seqClosure\n#align is_seq_closed.seq_closure_eq IsSeqClosed.seqClosure_eq\n-/\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n#print IsSeqClosed.preimage /-\n/-- The preimage of a sequentially closed set under a sequentially continuous map is sequentially\nclosed. -/\ntheorem IsSeqClosed.preimage {f : X ‚Üí Y} {s : Set Y} (hs : IsSeqClosed s) (hf : SeqContinuous f) :\n    IsSeqClosed (¬´expr ‚Åª¬π' ¬ª f s) := fun x p hx hp => hs hx (hf hp)\n#align is_seq_closed.preimage IsSeqClosed.preimage\n-/\n\n",
 "of_seq_tendsto_imp_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto /-\n/-- An alternative construction for `frechet_urysohn_space`: if sequential convergence implies\nconvergence, then the space is a Fr√©chet-Urysohn space. -/\ntheorem FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto\n    (h :\n      ‚àÄ (f : X ‚Üí Prop) (a : X),\n        (‚àÄ u : ‚Ñï ‚Üí X, Tendsto u atTop ((nhds) a) ‚Üí Tendsto (f ‚àò u) atTop ((nhds) (f a))) ‚Üí ContinuousAt f a) :\n    FrechetUrysohnSpace X := by\n  refine' ‚ü®fun s x hcx => _‚ü©\n  specialize h (¬∑ ‚àâ s) x\n  by_cases hx : x ‚àà s; ¬∑ exact subset_seqClosure hx\n  simp_rw [(¬∑ ‚àò ¬∑), ContinuousAt, hx, not_false_iff, nhds_true, tendsto_pure, eq_true_iff, ‚Üê mem_compl_iff,\n    eventually_mem_set, ‚Üê mem_interior_iff_mem_nhds, interior_compl] at h\n  rw [mem_compl_iff, imp_not_comm] at h\n  simp only [not_forall, not_eventually, mem_compl_iff, Classical.not_not] at h\n  rcases h hcx with ‚ü®u, hux, hus‚ü©\n  rcases extraction_of_frequently_at_top hus with ‚ü®œÜ, œÜ_mono, hœÜ‚ü©\n  exact ‚ü®u ‚àò œÜ, hœÜ, hux.comp œÜ_mono.tendsto_at_top‚ü©\n#align frechet_urysohn_space.of_seq_tendsto_imp_tendsto FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto\n-/\n\n",
 "mem_closure_iff_seq_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_seq_limit /-\n/-- In a Fr√©chet-Urysohn space, a point belongs to the closure of a set iff it is a limit\nof a sequence taking values in this set. -/\ntheorem mem_closure_iff_seq_limit [FrechetUrysohnSpace X] {s : Set X} {a : X} :\n    a ‚àà closure s ‚Üî ‚àÉ x : ‚Ñï ‚Üí X, (‚àÄ n : ‚Ñï, x n ‚àà s) ‚àß Tendsto x atTop ((nhds) a) :=\n  by\n  rw [‚Üê seqClosure_eq_closure]\n  rfl\n#align mem_closure_iff_seq_limit mem_closure_iff_seq_limit\n-/\n\n",
 "lebesgue_number_lemma_of_metric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n#print SeqCompact.lebesgue_number_lemma_of_metric /-\ntheorem SeqCompact.lebesgue_number_lemma_of_metric {Œπ : Sort _} {c : Œπ ‚Üí Set X} {s : Set X} (hs : IsSeqCompact s)\n    (hc‚ÇÅ : ‚àÄ i, IsOpen (c i))\n    (hc‚ÇÇ : s ‚äÜ ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (c i)) :\n    ‚àÉ Œ¥ > 0, ‚àÄ a ‚àà s, ‚àÉ i, ball a Œ¥ ‚äÜ c i :=\n  lebesgue_number_lemma_of_metric hs.is_compact hc‚ÇÅ hc‚ÇÇ\n#align seq_compact.lebesgue_number_lemma_of_metric SeqCompact.lebesgue_number_lemma_of_metric\n-/\n\n",
 "isSeqCompact":
 "#print IsCompact.isSeqCompact /-\nprotected theorem IsCompact.isSeqCompact {s : Set X} (hs : IsCompact s) : IsSeqCompact s := fun x x_in =>\n  let ‚ü®a, a_in, ha‚ü© := hs (tendsto_principal.mpr (eventually_of_forall x_in))\n  ‚ü®a, a_in, tendsto_subseq ha‚ü©\n#align is_compact.is_seq_compact IsCompact.isSeqCompact\n-/\n\n",
 "isSeqClosed_of_seqClosure_eq":
 "#print isSeqClosed_of_seqClosure_eq /-\n/-- If a set is equal to its sequential closure, then it is sequentially closed. -/\ntheorem isSeqClosed_of_seqClosure_eq {s : Set X} (hs : seqClosure s = s) : IsSeqClosed s := fun x p hxs hxp =>\n  hs ‚ñ∏ ‚ü®x, hxs, hxp‚ü©\n#align is_seq_closed_of_seq_closure_eq isSeqClosed_of_seqClosure_eq\n-/\n\n",
 "isSeqClosed_iff_isClosed":
 "#print isSeqClosed_iff_isClosed /-\n/-- In a sequential space, a set is closed iff it's sequentially closed. -/\ntheorem isSeqClosed_iff_isClosed [SequentialSpace X] {M : Set X} : IsSeqClosed M ‚Üî IsClosed M :=\n  ‚ü®IsSeqClosed.isClosed, IsClosed.isSeqClosed‚ü©\n#align is_seq_closed_iff_is_closed isSeqClosed_iff_isClosed\n-/\n\n",
 "isSeqClosed_iff":
 "#print isSeqClosed_iff /-\n/-- A set is sequentially closed iff it is equal to its sequential closure. -/\ntheorem isSeqClosed_iff {s : Set X} : IsSeqClosed s ‚Üî seqClosure s = s :=\n  ‚ü®IsSeqClosed.seqClosure_eq, isSeqClosed_of_seqClosure_eq‚ü©\n#align is_seq_closed_iff isSeqClosed_iff\n-/\n\n",
 "isSeqClosed":
 "#print IsClosed.isSeqClosed /-\n/-- A set is sequentially closed if it is closed. -/\nprotected theorem IsClosed.isSeqClosed {s : Set X} (hc : IsClosed s) : IsSeqClosed s := fun u x hu hx =>\n  hc.mem_of_tendsto hx (eventually_of_forall hu)\n#align is_closed.is_seq_closed IsClosed.isSeqClosed\n-/\n\n",
 "isComplete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÇ , ¬ª -/\n#print IsSeqCompact.isComplete /-\n/-- A sequentially compact set in a uniform set with countably generated uniformity filter\nis complete. -/\nprotected theorem IsSeqCompact.isComplete (hs : IsSeqCompact s) : IsComplete s :=\n  by\n  intro l hl hls\n  haveI := hl.1\n  rcases exists_antitone_basis ((uniformity) X) with ‚ü®V, hV‚ü©\n  choose W hW hWV using fun n => comp_mem_uniformity_sets (hV.mem n)\n  have hWV' : ‚àÄ n, W n ‚äÜ V n := fun n ‚ü®x, y‚ü© hx => @hWV n (x, y) ‚ü®x, refl_mem_uniformity <| hW _, hx‚ü©\n  obtain ‚ü®t, ht_anti, htl, htW, hts‚ü© :\n    ‚àÉ t : ‚Ñï ‚Üí Set X, Antitone t ‚àß (‚àÄ n, t n ‚àà l) ‚àß (‚àÄ n, lower_set.prod (t n) (t n) ‚äÜ W n) ‚àß ‚àÄ n, t n ‚äÜ s :=\n    by\n    have : ‚àÄ n, ‚àÉ t ‚àà l, lower_set.prod t t ‚äÜ W n ‚àß t ‚äÜ s :=\n      by\n      rw [le_principal_iff] at hls\n      have : ‚àÄ n, W n ‚à© lower_set.prod s s ‚àà filter.prod l l := fun n => inter_mem (hl.2 (hW n)) (prod_mem_prod hls hls)\n      simpa only [l.basis_sets.prod_self.mem_iff, true_imp_iff, subset_inter_iff, prod_self_subset_prod_self,\n        and_assoc] using this\n    choose t htl htW hts\n    have :\n      ‚àÄ n,\n        ¬´expr‚ãÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÇ , ¬ª\" (t k) ‚äÜ t n :=\n      fun n => Inter‚ÇÇ_subset _ le_rfl\n    exact\n      ‚ü®fun n => ¬´expr‚ãÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÇ , ¬ª\" (t k),\n        fun m n h => bInter_subset_bInter_left fun k (hk : k ‚â§ m) => hk.trans h, fun n =>\n        (bInter_mem (finite_le_nat n)).2 fun k hk => htl k, fun n => (prod_mono (this n) (this n)).trans (htW n),\n        fun n => (this n).trans (hts n)‚ü©\n  choose u hu using fun n => Filter.nonempty_of_mem (htl n)\n  have huc : CauchySeq u :=\n    hV.to_has_basis.cauchy_seq_iff.2 fun N hN =>\n      ‚ü®N, fun m hm n hn => hWV' _ <| @htW N (_, _) ‚ü®ht_anti hm (hu _), ht_anti hn (hu _)‚ü©‚ü©\n  rcases hs.exists_tendsto (fun n => hts n (hu n)) huc with ‚ü®x, hxs, hx‚ü©\n  refine' ‚ü®x, hxs, (nhds_basis_uniformity' hV.to_has_basis).ge_iff.2 fun N hN => _‚ü©\n  obtain ‚ü®n, hNn, hn‚ü© : ‚àÉ n, N ‚â§ n ‚àß u n ‚àà ball x (W N)\n  exact ((eventually_ge_at_top N).and (hx <| ball_mem_nhds x (hW N))).exists\n  refine' mem_of_superset (htl n) fun y hy => hWV N ‚ü®u n, _, htW N ‚ü®_, _‚ü©‚ü©\n  exacts[hn, ht_anti hNn (hu n), ht_anti hNn hy]\n#align is_seq_compact.is_complete IsSeqCompact.isComplete\n-/\n\n",
 "isCompact_iff_isSeqCompact":
 "#print UniformSpace.isCompact_iff_isSeqCompact /-\n/-- A version of Bolzano-Weistrass: in a uniform space with countably generated uniformity filter\n(e.g., in a metric space), a set is compact if and only if it is sequentially compact. -/\nprotected theorem UniformSpace.isCompact_iff_isSeqCompact : IsCompact s ‚Üî IsSeqCompact s :=\n  ‚ü®fun H => H.is_seq_compact, fun H => H.is_compact‚ü©\n#align uniform_space.is_compact_iff_is_seq_compact UniformSpace.isCompact_iff_isSeqCompact\n-/\n\n",
 "isCompact":
 "#print IsSeqCompact.isCompact /-\n/-- If `ùì§ Œ≤` is countably generated, then any sequentially compact set is compact. -/\nprotected theorem IsSeqCompact.isCompact (hs : IsSeqCompact s) : IsCompact s :=\n  isCompact_iff_totallyBounded_isComplete.2 ‚ü®hs.totally_bounded, hs.is_complete‚ü©\n#align is_seq_compact.is_compact IsSeqCompact.isCompact\n-/\n\n",
 "isClosed":
 "#print IsSeqClosed.isClosed /-\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\n/-- In a sequential space, a sequentially closed set is closed. -/\nprotected theorem IsSeqClosed.isClosed [SequentialSpace X] {s : Set X} (hs : IsSeqClosed s) : IsClosed s :=\n  sequential_space.is_closed_of_seq s hs\n#align is_seq_closed.is_closed IsSeqClosed.isClosed\n-/\n\n",
 "exists_tendsto_of_frequently_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÉ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÉ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsSeqCompact.exists_tendsto_of_frequently_mem /-\ntheorem IsSeqCompact.exists_tendsto_of_frequently_mem (hs : IsSeqCompact s) {u : ‚Ñï ‚Üí X}\n    (hu :\n      ¬´expr‚àÉ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÉ·∂† in , ¬ª\" atTop\n        (u n ‚àà s))\n    (huc : CauchySeq u) : ‚àÉ x ‚àà s, Tendsto u atTop ((nhds) x) :=\n  let ‚ü®x, hxs, œÜ, œÜ_mono, hx‚ü© := hs.subseq_of_frequently_in hu\n  ‚ü®x, hxs, tendsto_nhds_of_cauchySeq_of_subseq huc œÜ_mono.tendsto_at_top hx‚ü©\n#align is_seq_compact.exists_tendsto_of_frequently_mem IsSeqCompact.exists_tendsto_of_frequently_mem\n-/\n\n",
 "exists_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsSeqCompact.exists_tendsto /-\ntheorem IsSeqCompact.exists_tendsto (hs : IsSeqCompact s) {u : ‚Ñï ‚Üí X} (hu : ‚àÄ n, u n ‚àà s) (huc : CauchySeq u) :\n    ‚àÉ x ‚àà s, Tendsto u atTop ((nhds) x) :=\n  hs.exists_tendsto_of_frequently_mem (frequently_of_forall hu) huc\n#align is_seq_compact.exists_tendsto IsSeqCompact.exists_tendsto\n-/\n\n",
 "continuous_iff_seqContinuous":
 "#print continuous_iff_seqContinuous /-\n/-- If the domain of a function is a sequential space, then continuity of this function is\nequivalent to its sequential continuity. -/\ntheorem continuous_iff_seqContinuous [SequentialSpace X] {f : X ‚Üí Y} : Continuous f ‚Üî SeqContinuous f :=\n  ‚ü®Continuous.seqContinuous, SeqContinuous.continuous‚ü©\n#align continuous_iff_seq_continuous continuous_iff_seqContinuous\n-/\n\n",
 "continuous":
 "#print SeqContinuous.continuous /-\n/-- A sequentially continuous function defined on a sequential space is continuous. -/\nprotected theorem SeqContinuous.continuous [SequentialSpace X] {f : X ‚Üí Y} (hf : SeqContinuous f) : Continuous f :=\n  continuous_iff_isClosed.mpr fun s hs => (hs.is_seq_closed.preimage hf).is_closed\n#align seq_continuous.continuous SeqContinuous.continuous\n-/\n\n",
 "compactSpace_iff_seqCompactSpace":
 "#print UniformSpace.compactSpace_iff_seqCompactSpace /-\ntheorem UniformSpace.compactSpace_iff_seqCompactSpace : CompactSpace X ‚Üî SeqCompactSpace X := by\n  simp only [‚Üê isCompact_univ_iff, seqCompactSpace_iff, UniformSpace.isCompact_iff_isSeqCompact]\n#align uniform_space.compact_space_iff_seq_compact_space UniformSpace.compactSpace_iff_seqCompactSpace\n-/\n\n"}