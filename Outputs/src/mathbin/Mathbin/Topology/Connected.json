{"unionₛ_directed":
 "#print IsPreconnected.unionₛ_directed /-\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem IsPreconnected.unionₛ_directed {S : Set (Set α)} (K : DirectedOn (· ⊆ ·) S) (H : ∀ s ∈ S, IsPreconnected s) :\n    IsPreconnected (⋃₀ S) :=\n  by\n  rintro u v hu hv Huv ⟨a, ⟨s, hsS, has⟩, hau⟩ ⟨b, ⟨t, htS, hbt⟩, hbv⟩\n  obtain ⟨r, hrS, hsr, htr⟩ : ∃ r ∈ S, s ⊆ r ∧ t ⊆ r := K s hsS t htS\n  have Hnuv : (r ∩ (u ∩ v)).nonempty :=\n    H _ hrS u v hu hv ((subset_sUnion_of_mem hrS).trans Huv) ⟨a, hsr has, hau⟩ ⟨b, htr hbt, hbv⟩\n  have Kruv : r ∩ (u ∩ v) ⊆ ⋃₀ S ∩ (u ∩ v) := inter_subset_inter_left _ (subset_sUnion_of_mem hrS)\n  exact Hnuv.mono Kruv\n#align is_preconnected.sUnion_directed IsPreconnected.unionₛ_directed\n-/\n\n",
 "unionᵢ_of_reflTransGen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print IsConnected.unionᵢ_of_reflTransGen /-\ntheorem IsConnected.unionᵢ_of_reflTransGen {ι : Type _} [Nonempty ι] {s : ι → Set α} (H : ∀ i, IsConnected (s i))\n    (K : ∀ i j, ReflTransGen (fun i j : ι => (s i ∩ s j).nonempty) i j) :\n    IsConnected\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) :=\n  ⟨nonempty_unionᵢ.2 <| Nonempty.elim ‹_› fun i : ι => ⟨i, (H _).nonempty⟩,\n    IsPreconnected.unionᵢ_of_reflTransGen (fun i => (H i).is_preconnected) K⟩\n#align is_connected.Union_of_refl_trans_gen IsConnected.unionᵢ_of_reflTransGen\n-/\n\n",
 "unionᵢ_of_chain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print IsConnected.unionᵢ_of_chain /-\n/-- The Union of connected sets indexed by a type with an archimedean successor (like `ℕ` or `ℤ`)\n  such that any two neighboring sets meet is connected. -/\ntheorem IsConnected.unionᵢ_of_chain [Nonempty β] {s : β → Set α} (H : ∀ n, IsConnected (s n))\n    (K : ∀ n, (s n ∩ s (succ n)).nonempty) :\n    IsConnected\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) :=\n  IsConnected.unionᵢ_of_reflTransGen H fun i j =>\n    reflTransGen_of_succ _ (fun i _ => K i) fun i _ =>\n      by\n      rw [inter_comm]\n      exact K i\n#align is_connected.Union_of_chain IsConnected.unionᵢ_of_chain\n-/\n\n",
 "union'":
 "#print IsPreconnected.union' /-\ntheorem IsPreconnected.union' {s t : Set α} (H : (s ∩ t).nonempty) (hs : IsPreconnected s) (ht : IsPreconnected t) :\n    IsPreconnected (s ∪ t) := by\n  rcases H with ⟨x, hxs, hxt⟩\n  exact hs.union x hxs hxt ht\n#align is_preconnected.union' IsPreconnected.union'\n-/\n\n",
 "union":
 "#print IsConnected.union /-\ntheorem IsConnected.union {s t : Set α} (H : (s ∩ t).nonempty) (Hs : IsConnected s) (Ht : IsConnected t) :\n    IsConnected (s ∪ t) := by\n  rcases H with ⟨x, hx⟩\n  refine' ⟨⟨x, mem_union_left t (mem_of_mem_inter_left hx)⟩, _⟩\n  exact\n    IsPreconnected.union x (mem_of_mem_inter_left hx) (mem_of_mem_inter_right hx) Hs.is_preconnected Ht.is_preconnected\n#align is_connected.union IsConnected.union\n-/\n\n",
 "totallyDisconnectedSpace_iff_connectedComponent_subsingleton":
 "#print totallyDisconnectedSpace_iff_connectedComponent_subsingleton /-\n/-- A space is totally disconnected iff its connected components are subsingletons. -/\ntheorem totallyDisconnectedSpace_iff_connectedComponent_subsingleton :\n    TotallyDisconnectedSpace α ↔ ∀ x : α, (connectedComponent x).subsingleton :=\n  by\n  constructor\n  · intro h x\n    apply h.1\n    · exact subset_univ _\n    exact isPreconnected_connectedComponent\n  intro h; constructor\n  intro s s_sub hs\n  rcases eq_empty_or_nonempty s with (rfl | ⟨x, x_in⟩)\n  · exact subsingleton_empty\n  · exact (h x).anti (hs.subset_connected_component x_in)\n#align totally_disconnected_space_iff_connected_component_subsingleton totallyDisconnectedSpace_iff_connectedComponent_subsingleton\n-/\n\n",
 "totallyDisconnectedSpace_iff_connectedComponent_singleton":
 "#print totallyDisconnectedSpace_iff_connectedComponent_singleton /-\n/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem totallyDisconnectedSpace_iff_connectedComponent_singleton :\n    TotallyDisconnectedSpace α ↔ ∀ x : α, connectedComponent x = {x} :=\n  by\n  rw [totallyDisconnectedSpace_iff_connectedComponent_subsingleton]\n  apply forall_congr' fun x => _\n  rw [subsingleton_iff_singleton]\n  exact mem_connectedComponent\n#align totally_disconnected_space_iff_connected_component_singleton totallyDisconnectedSpace_iff_connectedComponent_singleton\n-/\n\n",
 "surjective_coe":
 "theorem surjective_coe : surjective (coe : α → ConnectedComponents α) :=\n  surjective_quot_mk _\n#align surjective_coe surjective_coe\n\n",
 "subsingleton":
 "#print IsPreconnected.subsingleton /-\ntheorem IsPreconnected.subsingleton [TotallyDisconnectedSpace α] {s : Set α} (h : IsPreconnected s) : s.subsingleton :=\n  totally_disconnected_space.is_totally_disconnected_univ s (subset_univ s) h\n#align is_preconnected.subsingleton IsPreconnected.subsingleton\n-/\n\n",
 "subset_right_of_subset_union":
 "#print IsPreconnected.subset_right_of_subset_union /-\ntheorem IsPreconnected.subset_right_of_subset_union (hu : IsOpen u) (hv : IsOpen v) (huv : Disjoint u v)\n    (hsuv : s ⊆ u ∪ v) (hsv : (s ∩ v).nonempty) (hs : IsPreconnected s) : s ⊆ v :=\n  hs.subset_left_of_subset_union hv hu huv.symm (union_comm u v ▸ hsuv) hsv\n#align is_preconnected.subset_right_of_subset_union IsPreconnected.subset_right_of_subset_union\n-/\n\n",
 "subset_or_subset":
 "#print IsPreconnected.subset_or_subset /-\ntheorem IsPreconnected.subset_or_subset (hu : IsOpen u) (hv : IsOpen v) (huv : Disjoint u v) (hsuv : s ⊆ u ∪ v)\n    (hs : IsPreconnected s) : s ⊆ u ∨ s ⊆ v :=\n  by\n  specialize hs u v hu hv hsuv\n  obtain hsu | hsu := (s ∩ u).eq_empty_or_nonempty\n  · exact or.inr ((Set.disjoint_iff_inter_eq_empty.2 hsu).subset_right_of_subset_union hsuv)\n  · replace hs := mt (hs hsu)\n    simp_rw [Set.not_nonempty_iff_eq_empty, ← Set.disjoint_iff_inter_eq_empty, disjoint_iff_inter_eq_empty.1 huv] at hs\n    exact or.inl ((hs s.disjoint_empty).subset_left_of_subset_union hsuv)\n#align is_preconnected.subset_or_subset IsPreconnected.subset_or_subset\n-/\n\n",
 "subset_of_closure_inter_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print IsPreconnected.subset_of_closure_inter_subset /-\n/-- If a preconnected set `s` intersects an open set `u`, and limit points of `u` inside `s` are\ncontained in `u`, then the whole set `s` is contained in `u`. -/\ntheorem IsPreconnected.subset_of_closure_inter_subset (hs : IsPreconnected s) (hu : IsOpen u) (h'u : (s ∩ u).nonempty)\n    (h : closure u ∩ s ⊆ u) : s ⊆ u :=\n  by\n  have A : s ⊆ u ∪ «expr ᶜ» (closure u) := by\n    intro x hx\n    by_cases xu : x ∈ u\n    · exact or.inl xu\n    · right\n      intro h'x\n      exact xu (h (mem_inter h'x hx))\n  apply hs.subset_left_of_subset_union hu is_closed_closure.is_open_compl _ A h'u\n  exact disjoint_compl_right.mono_right (compl_subset_compl.2 subset_closure)\n#align is_preconnected.subset_of_closure_inter_subset IsPreconnected.subset_of_closure_inter_subset\n-/\n\n",
 "subset_left_of_subset_union":
 "#print IsPreconnected.subset_left_of_subset_union /-\ntheorem IsPreconnected.subset_left_of_subset_union (hu : IsOpen u) (hv : IsOpen v) (huv : Disjoint u v)\n    (hsuv : s ⊆ u ∪ v) (hsu : (s ∩ u).nonempty) (hs : IsPreconnected s) : s ⊆ u :=\n  Disjoint.subset_left_of_subset_union hsuv\n    (by\n      by_contra hsv\n      rw [not_disjoint_iff_nonempty_inter] at hsv\n      obtain ⟨x, _, hx⟩ := hs u v hu hv hsuv hsu hsv\n      exact Set.disjoint_iff.1 huv hx)\n#align is_preconnected.subset_left_of_subset_union IsPreconnected.subset_left_of_subset_union\n-/\n\n",
 "subset_connectedComponentIn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print IsPreconnected.subset_connectedComponentIn /-\ntheorem IsPreconnected.subset_connectedComponentIn {x : α} {F : Set α} (hs : IsPreconnected s) (hxs : x ∈ s)\n    (hsF : s ⊆ F) : s ⊆ connectedComponentIn F x :=\n  by\n  have : IsPreconnected («expr ⁻¹' » (coe : F → α) s) :=\n    by\n    refine' embedding_subtype_coe.to_inducing.is_preconnected_image.mp _\n    rwa [Subtype.image_preimage_coe, inter_eq_left_iff_subset.mpr hsF]\n  have h2xs : (⟨x, hsF hxs⟩ : F) ∈ «expr ⁻¹' » coe s :=\n    by\n    rw [mem_preimage]\n    exact hxs\n  have := this.subset_connected_component h2xs\n  rw [connectedComponentIn_eq_image (hsF hxs)]\n  refine' subset.trans _ (image_subset _ this)\n  rw [Subtype.image_preimage_coe, inter_eq_left_iff_subset.mpr hsF]\n#align is_preconnected.subset_connected_component_in IsPreconnected.subset_connectedComponentIn\n-/\n\n",
 "subset_connectedComponent":
 "#print IsConnected.subset_connectedComponent /-\ntheorem IsConnected.subset_connectedComponent {x : α} {s : Set α} (H1 : IsConnected s) (H2 : x ∈ s) :\n    s ⊆ connectedComponent x :=\n  H1.2.subset_connected_component H2\n#align is_connected.subset_connected_component IsConnected.subset_connectedComponent\n-/\n\n",
 "subset_closure":
 "#print IsConnected.subset_closure /-\ntheorem IsConnected.subset_closure {s : Set α} {t : Set α} (H : IsConnected s) (Kst : s ⊆ t) (Ktcs : t ⊆ closure s) :\n    IsConnected t :=\n  let hsne := H.left\n  let ht := Kst\n  let htne := Nonempty.mono ht hsne\n  ⟨Nonempty.mono Kst H.left, IsPreconnected.subset_closure H.right Kst Ktcs⟩\n#align is_connected.subset_closure IsConnected.subset_closure\n-/\n\n",
 "subset_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print IsPreconnected.subset_clopen /-\n/-- Preconnected sets are either contained in or disjoint to any given clopen set. -/\ntheorem IsPreconnected.subset_clopen {s t : Set α} (hs : IsPreconnected s) (ht : IsClopen t) (hne : (s ∩ t).nonempty) :\n    s ⊆ t := by\n  by_contra h\n  have : (s ∩ «expr ᶜ» t).nonempty := inter_compl_nonempty_iff.2 h\n  obtain ⟨x, -, hx, hx'⟩ : (s ∩ (t ∩ «expr ᶜ» t)).nonempty\n  exact hs t («expr ᶜ» t) ht.is_open ht.compl.is_open (fun x hx => em _) hne this\n  exact hx' hx\n#align is_preconnected.subset_clopen IsPreconnected.subset_clopen\n-/\n\n",
 "range_coe":
 "@[simp]\ntheorem range_coe : range (coe : α → ConnectedComponents α) = univ :=\n  surjective_coe.range_eq\n#align range_coe range_coe\n\n",
 "quotient_map_coe":
 "theorem quotient_map_coe : QuotientMap (coe : α → ConnectedComponents α) :=\n  quotientMap_quot_mk\n#align quotient_map_coe quotient_map_coe\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print IsConnected.prod /-\ntheorem IsConnected.prod [TopologicalSpace β] {s : Set α} {t : Set β} (hs : IsConnected s) (ht : IsConnected t) :\n    IsConnected (lower_set.prod s t) :=\n  ⟨hs.1.prod ht.1, hs.2.prod ht.2⟩\n#align is_connected.prod IsConnected.prod\n-/\n\n",
 "preimage_of_open_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print IsPreconnected.preimage_of_open_map /-\n/- TODO: The following lemmas about connection of preimages hold more generally for strict maps\n(the quotient and subspace topologies of the image agree) whose fibers are preconnected. -/\ntheorem IsPreconnected.preimage_of_open_map [TopologicalSpace β] {s : Set β} (hs : IsPreconnected s) {f : α → β}\n    (hinj : function.injective f) (hf : IsOpenMap f) (hsf : s ⊆ range f) : IsPreconnected («expr ⁻¹' » f s) :=\n  fun u v hu hv hsuv hsu hsv =>\n  by\n  obtain ⟨b, hbs, hbu, hbv⟩ := hs («expr '' » f u) («expr '' » f v) (hf u hu) (hf v hv) _ _ _\n  obtain ⟨a, rfl⟩ := hsf hbs\n  rw [hinj.mem_set_image] at hbu hbv\n  exact ⟨a, hbs, hbu, hbv⟩\n  · have := image_subset f hsuv\n    rwa [Set.image_preimage_eq_of_subset hsf, image_union] at this\n  · obtain ⟨x, hx1, hx2⟩ := hsu\n    exact ⟨f x, hx1, x, hx2, rfl⟩\n  · obtain ⟨y, hy1, hy2⟩ := hsv\n    exact ⟨f y, hy1, y, hy2, rfl⟩\n#align is_preconnected.preimage_of_open_map IsPreconnected.preimage_of_open_map\n-/\n\n",
 "preimage_of_openMap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print IsConnected.preimage_of_openMap /-\ntheorem IsConnected.preimage_of_openMap [TopologicalSpace β] {s : Set β} (hs : IsConnected s) {f : α → β}\n    (hinj : function.injective f) (hf : IsOpenMap f) (hsf : s ⊆ range f) : IsConnected («expr ⁻¹' » f s) :=\n  ⟨hs.nonempty.preimage' hsf, hs.is_preconnected.preimage_of_open_map hinj hf hsf⟩\n#align is_connected.preimage_of_open_map IsConnected.preimage_of_openMap\n-/\n\n",
 "preimage_of_closed_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print IsPreconnected.preimage_of_closed_map /-\ntheorem IsPreconnected.preimage_of_closed_map [TopologicalSpace β] {s : Set β} (hs : IsPreconnected s) {f : α → β}\n    (hinj : function.injective f) (hf : IsClosedMap f) (hsf : s ⊆ range f) : IsPreconnected («expr ⁻¹' » f s) :=\n  isPreconnected_closed_iff.2 fun u v hu hv hsuv hsu hsv =>\n    by\n    obtain ⟨b, hbs, hbu, hbv⟩ :=\n      isPreconnected_closed_iff.1 hs («expr '' » f u) («expr '' » f v) (hf u hu) (hf v hv) _ _ _\n    obtain ⟨a, rfl⟩ := hsf hbs\n    rw [hinj.mem_set_image] at hbu hbv\n    exact ⟨a, hbs, hbu, hbv⟩\n    · have := image_subset f hsuv\n      rwa [Set.image_preimage_eq_of_subset hsf, image_union] at this\n    · obtain ⟨x, hx1, hx2⟩ := hsu\n      exact ⟨f x, hx1, x, hx2, rfl⟩\n    · obtain ⟨y, hy1, hy2⟩ := hsv\n      exact ⟨f y, hy1, y, hy2, rfl⟩\n#align is_preconnected.preimage_of_closed_map IsPreconnected.preimage_of_closed_map\n-/\n\n",
 "preimage_of_closedMap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print IsConnected.preimage_of_closedMap /-\ntheorem IsConnected.preimage_of_closedMap [TopologicalSpace β] {s : Set β} (hs : IsConnected s) {f : α → β}\n    (hinj : function.injective f) (hf : IsClosedMap f) (hsf : s ⊆ range f) : IsConnected («expr ⁻¹' » f s) :=\n  ⟨hs.nonempty.preimage' hsf, hs.is_preconnected.preimage_of_closed_map hinj hf hsf⟩\n#align is_connected.preimage_of_closed_map IsConnected.preimage_of_closedMap\n-/\n\n",
 "preimage_connectedComponent_connected":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print preimage_connectedComponent_connected /-\n/-- The preimage of a connected component is preconnected if the function has connected fibers\nand a subset is closed iff the preimage is. -/\ntheorem preimage_connectedComponent_connected [TopologicalSpace β] {f : α → β}\n    (connected_fibers : ∀ t : β, IsConnected («expr ⁻¹' » f {t}))\n    (hcl : ∀ T : Set β, IsClosed T ↔ IsClosed («expr ⁻¹' » f T)) (t : β) :\n    IsConnected («expr ⁻¹' » f (connectedComponent t)) :=\n  by\n  -- The following proof is essentially https://stacks.math.columbia.edu/tag/0377\n  -- although the statement is slightly different\n  have hf : surjective f := surjective.of_comp fun t : β => (connected_fibers t).1\n  constructor\n  · cases' hf t with s hs\n    use s\n    rw [mem_preimage, hs]\n    exact mem_connectedComponent\n  have hT : IsClosed («expr ⁻¹' » f (connectedComponent t)) :=\n    (hcl (connectedComponent t)).1 isClosed_connectedComponent\n  -- To show it's preconnected we decompose (f ⁻¹' connected_component t) as a subset of two\n  -- closed disjoint sets in α. We want to show that it's a subset of either.\n  rw [isPreconnected_iff_subset_of_fully_disjoint_closed hT]\n  intro u v hu hv huv uv_disj\n  -- To do this we decompose connected_component t into T₁ and T₂\n  -- we will show that connected_component t is a subset of either and hence\n  -- (f ⁻¹' connected_component t) is a subset of u or v\n  let T₁ := { t' ∈ connectedComponent t | «expr ⁻¹' » f {t'} ⊆ u }\n  let T₂ := { t' ∈ connectedComponent t | «expr ⁻¹' » f {t'} ⊆ v }\n  have fiber_decomp : ∀ t' ∈ connectedComponent t, «expr ⁻¹' » f {t'} ⊆ u ∨ «expr ⁻¹' » f {t'} ⊆ v :=\n    by\n    intro t' ht'\n    apply isPreconnected_iff_subset_of_disjoint_closed.1 (connected_fibers t').2 u v hu hv\n    · exact subset.trans (hf.preimage_subset_preimage_iff.2 (singleton_subset_iff.2 ht')) huv\n    rw [uv_disj.inter_eq, inter_empty]\n  have T₁_u : «expr ⁻¹' » f T₁ = «expr ⁻¹' » f (connectedComponent t) ∩ u :=\n    by\n    apply eq_of_subset_of_subset\n    · rw [← bUnion_preimage_singleton]\n      refine' Union₂_subset fun t' ht' => subset_inter _ ht'.2\n      rw [hf.preimage_subset_preimage_iff, singleton_subset_iff]\n      exact ht'.1\n    rintro a ⟨hat, hau⟩\n    constructor\n    · exact mem_preimage.1 hat\n    dsimp only\n    cases fiber_decomp (f a) (mem_preimage.1 hat)\n    · exact h\n    · cases (nonempty_of_mem <| mem_inter hau <| h rfl).not_disjoint uv_disj\n  -- This proof is exactly the same as the above (modulo some symmetry)\n  have T₂_v : «expr ⁻¹' » f T₂ = «expr ⁻¹' » f (connectedComponent t) ∩ v :=\n    by\n    apply eq_of_subset_of_subset\n    · rw [← bUnion_preimage_singleton]\n      refine' Union₂_subset fun t' ht' => subset_inter _ ht'.2\n      rw [hf.preimage_subset_preimage_iff, singleton_subset_iff]\n      exact ht'.1\n    rintro a ⟨hat, hav⟩\n    constructor\n    · exact mem_preimage.1 hat\n    dsimp only\n    cases fiber_decomp (f a) (mem_preimage.1 hat)\n    · cases (nonempty_of_mem (mem_inter (h rfl) hav)).not_disjoint uv_disj\n    · exact h\n  -- Now we show T₁, T₂ are closed, cover connected_component t and are disjoint.\n  have hT₁ : IsClosed T₁ := (hcl T₁).2 (T₁_u.symm ▸ IsClosed.inter hT hu)\n  have hT₂ : IsClosed T₂ := (hcl T₂).2 (T₂_v.symm ▸ IsClosed.inter hT hv)\n  have T_decomp : connectedComponent t ⊆ T₁ ∪ T₂ := by\n    intro t' ht'\n    rw [mem_union t' T₁ T₂]\n    cases' fiber_decomp t' ht' with htu htv\n    · left\n      exact ⟨ht', htu⟩\n    right\n    exact ⟨ht', htv⟩\n  have T_disjoint : Disjoint T₁ T₂ := by\n    refine' Disjoint.of_preimage hf _\n    rw [T₁_u, T₂_v, disjoint_iff_inter_eq_empty, ← inter_inter_distrib_left, uv_disj.inter_eq, inter_empty]\n  -- Now we do cases on whether (connected_component t) is a subset of T₁ or T₂ to show\n  -- that the preimage is a subset of u or v.\n  cases\n    (isPreconnected_iff_subset_of_fully_disjoint_closed isClosed_connectedComponent).1 isPreconnected_connectedComponent\n      T₁ T₂ hT₁ hT₂ T_decomp T_disjoint\n  · left\n    rw [subset.antisymm_iff] at T₁_u\n    suffices «expr ⁻¹' » f (connectedComponent t) ⊆ «expr ⁻¹' » f T₁ by\n      exact subset.trans (subset.trans this T₁_u.1) (inter_subset_right _ _)\n    exact preimage_mono h\n  right\n  rw [subset.antisymm_iff] at T₂_v\n  suffices «expr ⁻¹' » f (connectedComponent t) ⊆ «expr ⁻¹' » f T₂ by\n    exact subset.trans (subset.trans this T₂_v.1) (inter_subset_right _ _)\n  exact preimage_mono h\n#align preimage_connected_component_connected preimage_connectedComponent_connected\n-/\n\n",
 "preimage_connectedComponent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print QuotientMap.preimage_connectedComponent /-\ntheorem QuotientMap.preimage_connectedComponent [TopologicalSpace β] {f : α → β} (hf : QuotientMap f)\n    (h_fibers : ∀ y : β, IsConnected («expr ⁻¹' » f {y})) (a : α) :\n    «expr ⁻¹' » f (connectedComponent (f a)) = connectedComponent a :=\n  ((preimage_connectedComponent_connected h_fibers (fun _ => hf.is_closed_preimage.symm) _).subset_connected_component\n        mem_connectedComponent).antisymm\n    (hf.continuous.maps_to_connected_component a)\n#align quotient_map.preimage_connected_component QuotientMap.preimage_connectedComponent\n-/\n\n",
 "preconnectedSpace_of_forall_constant":
 "#print preconnectedSpace_of_forall_constant /-\n/-- A `preconnected_space` version of `is_preconnected_of_forall_constant` -/\ntheorem preconnectedSpace_of_forall_constant (hs : ∀ f : α → Bool, Continuous f → ∀ x y, f x = f y) :\n    PreconnectedSpace α :=\n  ⟨isPreconnected_of_forall_constant fun f hf x hx y hy => hs f (continuous_iff_continuousOn_univ.mpr hf) x y⟩\n#align preconnected_space_of_forall_constant preconnectedSpace_of_forall_constant\n-/\n\n",
 "preconnectedSpace_iff_connectedComponent":
 "#print preconnectedSpace_iff_connectedComponent /-\ntheorem preconnectedSpace_iff_connectedComponent : PreconnectedSpace α ↔ ∀ x : α, connectedComponent x = univ :=\n  by\n  constructor\n  · intro h x\n    exact eq_univ_of_univ_subset <| is_preconnected_univ.subset_connected_component (mem_univ x)\n  · intro h\n    cases' isEmpty_or_nonempty α with hα hα\n    ·\n      exact\n        ⟨by\n          rw [univ_eq_empty_iff.mpr hα]\n          exact isPreconnected_empty⟩\n    ·\n      exact\n        ⟨by\n          rw [← h (Classical.choice hα)]\n          exact isPreconnected_connectedComponent⟩\n#align preconnected_space_iff_connected_component preconnectedSpace_iff_connectedComponent\n-/\n\n",
 "preconnectedSpace":
 "#print Subtype.preconnectedSpace /-\ntheorem Subtype.preconnectedSpace {s : Set α} (h : IsPreconnected s) : PreconnectedSpace s :=\n  {\n    is_preconnected_univ := by\n      rwa [← embedding_subtype_coe.to_inducing.is_preconnected_image, image_univ, Subtype.range_coe] }\n#align subtype.preconnected_space Subtype.preconnectedSpace\n-/\n\n",
 "nonempty_inter":
 "#print nonempty_inter /-\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\ntheorem nonempty_inter [PreconnectedSpace α] {s t : Set α} :\n    IsOpen s → IsOpen t → s ∪ t = univ → s.nonempty → t.nonempty → (s ∩ t).nonempty := by\n  simpa only [univ_inter, univ_subset_iff] using @preconnected_space.is_preconnected_univ α _ _ s t\n#align nonempty_inter nonempty_inter\n-/\n\n",
 "nonempty_frontier_iff":
 "#print nonempty_frontier_iff /-\ntheorem nonempty_frontier_iff [PreconnectedSpace α] {s : Set α} : (frontier s).nonempty ↔ s.nonempty ∧ s ≠ univ := by\n  simp only [nonempty_iff_ne_empty, ne.def, frontier_eq_empty_iff, not_or]\n#align nonempty_frontier_iff nonempty_frontier_iff\n-/\n\n",
 "nonempty":
 "#print IsConnected.nonempty /-\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Yury Kudryashov\n-/\ntheorem IsConnected.nonempty {s : Set α} (h : IsConnected s) : s.nonempty :=\n  h.1\n#align is_connected.nonempty IsConnected.nonempty\n-/\n\n",
 "mem_connectedComponentIn":
 "#print mem_connectedComponentIn /-\ntheorem mem_connectedComponentIn {x : α} {F : Set α} (hx : x ∈ F) : x ∈ connectedComponentIn F x := by\n  simp [connectedComponentIn_eq_image hx, mem_connectedComponent, hx]\n#align mem_connected_component_in mem_connectedComponentIn\n-/\n\n",
 "mem_connectedComponent":
 "#print mem_connectedComponent /-\ntheorem mem_connectedComponent {x : α} : x ∈ connectedComponent x :=\n  mem_unionₛ_of_mem (mem_singleton x) ⟨isConnected_singleton.is_preconnected, mem_singleton x⟩\n#align mem_connected_component mem_connectedComponent\n-/\n\n",
 "mapsTo_connectedComponent":
 "#print Continuous.mapsTo_connectedComponent /-\ntheorem Continuous.mapsTo_connectedComponent [TopologicalSpace β] {f : α → β} (h : Continuous f) (a : α) :\n    MapsTo f (connectedComponent a) (connectedComponent (f a)) :=\n  mapsTo'.2 <| h.image_connected_component_subset a\n#align continuous.maps_to_connected_component Continuous.mapsTo_connectedComponent\n-/\n\n",
 "locallyConnectedSpace_of_connected_bases":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print locallyConnectedSpace_of_connected_bases /-\ntheorem locallyConnectedSpace_of_connected_bases {ι : Type _} (b : α → ι → Set α) (p : α → ι → Prop)\n    (hbasis : ∀ x, ((nhds) x).has_basis (p x) (b x)) (hconnected : ∀ x i, p x i → IsPreconnected (b x i)) :\n    LocallyConnectedSpace α := by\n  rw [locallyConnectedSpace_iff_connected_basis]\n  exact fun x =>\n    (hbasis x).to_has_basis (fun i hi => ⟨b x i, ⟨(hbasis x).mem_of_mem hi, hconnected x i hi⟩, subset_rfl⟩) fun s hs =>\n      ⟨(hbasis x).index s hs.1, ⟨(hbasis x).property_index hs.1, (hbasis x).set_index_subset hs.1⟩⟩\n#align locally_connected_space_of_connected_bases locallyConnectedSpace_of_connected_bases\n-/\n\n",
 "locallyConnectedSpace_iff_open_connected_subsets":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr ∀ x, (_ : exprProp())]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (V «expr ⊆ » U) -/\n#print locallyConnectedSpace_iff_open_connected_subsets /-\ntheorem locallyConnectedSpace_iff_open_connected_subsets :\n    LocallyConnectedSpace α ↔ ∀ (x : α), ∀ U ∈ (nhds) x, ∃ (V : _)(_ : V ⊆ U), IsOpen V ∧ x ∈ V ∧ IsConnected V :=\n  by\n  rw [locallyConnectedSpace_iff_open_connected_basis]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr ∀ x, (_ : exprProp())]]\"\n  constructor\n  · intro h U hU\n    rcases h.mem_iff.mp hU with ⟨V, hV, hVU⟩\n    exact ⟨V, hVU, hV⟩\n  ·\n    exact fun h =>\n      ⟨fun U =>\n        ⟨fun hU =>\n          let ⟨V, hVU, hV⟩ := h U hU\n          ⟨V, hV, hVU⟩,\n          fun ⟨V, ⟨hV, hxV, _⟩, hVU⟩ => mem_nhds_iff.mpr ⟨V, hVU, hV, hxV⟩⟩⟩\n#align locally_connected_space_iff_open_connected_subsets locallyConnectedSpace_iff_open_connected_subsets\n-/\n\n",
 "locallyConnectedSpace_iff_open_connected_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print locallyConnectedSpace_iff_open_connected_basis /-\ntheorem locallyConnectedSpace_iff_open_connected_basis :\n    LocallyConnectedSpace α ↔ ∀ x, ((nhds) x).has_basis (fun s : Set α => IsOpen s ∧ x ∈ s ∧ IsConnected s) id :=\n  ⟨@locally_connected_space.open_connected_basis _ _, locally_connected_space.mk⟩\n#align locally_connected_space_iff_open_connected_basis locallyConnectedSpace_iff_open_connected_basis\n-/\n\n",
 "locallyConnectedSpace_iff_connected_subsets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print locallyConnectedSpace_iff_connected_subsets /-\ntheorem locallyConnectedSpace_iff_connected_subsets :\n    LocallyConnectedSpace α ↔ ∀ (x : α), ∀ U ∈ (nhds) x, ∃ V ∈ (nhds) x, IsPreconnected V ∧ V ⊆ U :=\n  by\n  constructor\n  · rw [locallyConnectedSpace_iff_open_connected_subsets]\n    intro h x U hxU\n    rcases h x U hxU with ⟨V, hVU, hV₁, hxV, hV₂⟩\n    exact ⟨V, hV₁.mem_nhds hxV, hV₂.is_preconnected, hVU⟩\n  · rw [locallyConnectedSpace_iff_connectedComponentIn_open]\n    refine' fun h U hU x hxU => is_open_iff_mem_nhds.mpr fun y hy => _\n    rw [connectedComponentIn_eq hy]\n    rcases h y U (hU.mem_nhds <| (connectedComponentIn_subset _ _) hy) with ⟨V, hVy, hV, hVU⟩\n    exact Filter.mem_of_superset hVy (hV.subset_connected_component_in (mem_of_mem_nhds hVy) hVU)\n#align locally_connected_space_iff_connected_subsets locallyConnectedSpace_iff_connected_subsets\n-/\n\n",
 "locallyConnectedSpace_iff_connected_basis":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr ∀ x, (_ : exprProp())]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print locallyConnectedSpace_iff_connected_basis /-\ntheorem locallyConnectedSpace_iff_connected_basis :\n    LocallyConnectedSpace α ↔ ∀ x, ((nhds) x).has_basis (fun s : Set α => s ∈ (nhds) x ∧ IsPreconnected s) id :=\n  by\n  rw [locallyConnectedSpace_iff_connected_subsets]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr ∀ x, (_ : exprProp())]]\"\n  exact filter.has_basis_self.symm\n#align locally_connected_space_iff_connected_basis locallyConnectedSpace_iff_connected_basis\n-/\n\n",
 "locallyConnectedSpace_iff_connectedComponentIn_open":
 "#print locallyConnectedSpace_iff_connectedComponentIn_open /-\ntheorem locallyConnectedSpace_iff_connectedComponentIn_open :\n    LocallyConnectedSpace α ↔ ∀ F : Set α, IsOpen F → ∀ x ∈ F, IsOpen (connectedComponentIn F x) :=\n  by\n  constructor\n  · intro h\n    exact fun F hF x _ => hF.connected_component_in\n  · intro h\n    rw [locallyConnectedSpace_iff_open_connected_subsets]\n    refine' fun x U hU =>\n        ⟨connectedComponentIn (interior U) x, (connectedComponentIn_subset _ _).trans interior_subset,\n          h _ isOpen_interior x _, mem_connectedComponentIn _, is_connected_connected_component_in_iff.mpr _⟩ <;>\n      exact mem_interior_iff_mem_nhds.mpr hU\n#align locally_connected_space_iff_connected_component_in_open locallyConnectedSpace_iff_connectedComponentIn_open\n-/\n\n",
 "isTotallySeparated_singleton":
 "#print isTotallySeparated_singleton /-\ntheorem isTotallySeparated_singleton {x} : IsTotallySeparated ({x} : Set α) := fun p hp q hq hpq =>\n  (hpq <| (eq_of_mem_singleton hp).symm ▸ (eq_of_mem_singleton hq).symm).elim\n#align is_totally_separated_singleton isTotallySeparated_singleton\n-/\n\n",
 "isTotallySeparated_empty":
 "#print isTotallySeparated_empty /-\ntheorem isTotallySeparated_empty : IsTotallySeparated (∅ : Set α) := fun x => false.elim\n#align is_totally_separated_empty isTotallySeparated_empty\n-/\n\n",
 "isTotallyDisconnected_singleton":
 "#print isTotallyDisconnected_singleton /-\ntheorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set α) := fun _ ht _ =>\n  subsingleton_singleton.anti ht\n#align is_totally_disconnected_singleton isTotallyDisconnected_singleton\n-/\n\n",
 "isTotallyDisconnected_of_totallyDisconnectedSpace":
 "#print isTotallyDisconnected_of_totallyDisconnectedSpace /-\ntheorem isTotallyDisconnected_of_totallyDisconnectedSpace [TotallyDisconnectedSpace α] (s : Set α) :\n    IsTotallyDisconnected s := fun t hts ht =>\n  totally_disconnected_space.is_totally_disconnected_univ _ t.subset_univ ht\n#align is_totally_disconnected_of_totally_disconnected_space isTotallyDisconnected_of_totallyDisconnectedSpace\n-/\n\n",
 "isTotallyDisconnected_of_isTotallySeparated":
 "#print isTotallyDisconnected_of_isTotallySeparated /-\ntheorem isTotallyDisconnected_of_isTotallySeparated {s : Set α} (H : IsTotallySeparated s) : IsTotallyDisconnected s :=\n  by\n  intro t hts ht x x_in y y_in\n  by_contra h\n  obtain ⟨u : Set α, v : Set α, hu : IsOpen u, hv : IsOpen v, hxu : x ∈ u, hyv : y ∈ v, hs : s ⊆ u ∪ v, huv⟩ :=\n    H x (hts x_in) y (hts y_in) h\n  refine' (ht _ _ hu hv (hts.trans hs) ⟨x, x_in, hxu⟩ ⟨y, y_in, hyv⟩).ne_empty _\n  rw [huv.inter_eq, inter_empty]\n#align is_totally_disconnected_of_is_totally_separated isTotallyDisconnected_of_isTotallySeparated\n-/\n\n",
 "isTotallyDisconnected_of_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isTotallyDisconnected_of_image /-\ntheorem isTotallyDisconnected_of_image [TopologicalSpace β] {f : α → β} (hf : ContinuousOn f s) (hf' : injective f)\n    (h : IsTotallyDisconnected («expr '' » f s)) : IsTotallyDisconnected s := fun t hts ht x x_in y y_in =>\n  hf' <| h _ (image_subset f hts) (ht.image f <| hf.mono hts) (mem_image_of_mem f x_in) (mem_image_of_mem f y_in)\n#align is_totally_disconnected_of_image isTotallyDisconnected_of_image\n-/\n\n",
 "isTotallyDisconnected_of_clopen_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print isTotallyDisconnected_of_clopen_set /-\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\n  is some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem isTotallyDisconnected_of_clopen_set {X : Type _} [TopologicalSpace X]\n    (hX : ∀ {x y : X} (h_diff : x ≠ y), ∃ (U : Set X)(h_clopen : IsClopen U), x ∈ U ∧ y ∉ U) :\n    IsTotallyDisconnected (Set.univ : Set X) := by\n  rintro S - hS\n  unfold Set.Subsingleton\n  by_contra' h_contra\n  rcases h_contra with ⟨x, hx, y, hy, hxy⟩\n  obtain ⟨U, h_clopen, hxU, hyU⟩ := hX hxy\n  specialize hS U («expr ᶜ» U) h_clopen.1 h_clopen.compl.1 (fun a ha => em (a ∈ U)) ⟨x, hx, hxU⟩ ⟨y, hy, hyU⟩\n  rw [inter_compl_self, Set.inter_empty] at hS\n  exact Set.not_nonempty_empty hS\n#align is_totally_disconnected_of_clopen_set isTotallyDisconnected_of_clopen_set\n-/\n\n",
 "isTotallyDisconnected_empty":
 "#print isTotallyDisconnected_empty /-\ntheorem isTotallyDisconnected_empty : IsTotallyDisconnected (∅ : Set α) := fun _ ht _ _ x_in _ _ => (ht x_in).elim\n#align is_totally_disconnected_empty isTotallyDisconnected_empty\n-/\n\n",
 "isTotallyDisconnected":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Embedding.isTotallyDisconnected /-\ntheorem Embedding.isTotallyDisconnected [TopologicalSpace β] {f : α → β} (hf : Embedding f) {s : Set α}\n    (h : IsTotallyDisconnected («expr '' » f s)) : IsTotallyDisconnected s :=\n  isTotallyDisconnected_of_image hf.continuous.continuous_on hf.inj h\n#align embedding.is_totally_disconnected Embedding.isTotallyDisconnected\n-/\n\n",
 "isPreconnected_univ_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isPreconnected_univ_pi /-\ntheorem isPreconnected_univ_pi [∀ i, TopologicalSpace (π i)] {s : ∀ i, Set (π i)} (hs : ∀ i, IsPreconnected (s i)) :\n    IsPreconnected (pi univ s) := by\n  rintro u v uo vo hsuv ⟨f, hfs, hfu⟩ ⟨g, hgs, hgv⟩\n  rcases exists_finset_piecewise_mem_of_mem_nhds (uo.mem_nhds hfu) g with ⟨I, hI⟩\n  induction' I using Finset.induction_on with i I hi ihI\n  · refine' ⟨g, hgs, ⟨_, hgv⟩⟩\n    simpa using hI\n  · rw [Finset.piecewise_insert] at hI\n    have := I.piecewise_mem_set_pi hfs hgs\n    refine' (hsuv this).elim ihI fun h => _\n    set S := «expr '' » (update (I.piecewise f g) i) (s i)\n    have hsub : S ⊆ pi univ s := by\n      refine' image_subset_iff.2 fun z hz => _\n      rwa [update_preimage_univ_pi]\n      exact fun j hj => this j trivial\n    have hconn : IsPreconnected S := (hs i).image _ (continuous_const.update i continuous_id).continuous_on\n    have hSu : (S ∩ u).nonempty := ⟨_, mem_image_of_mem _ (hfs _ trivial), hI⟩\n    have hSv : (S ∩ v).nonempty := ⟨_, ⟨_, this _ trivial, update_eq_self _ _⟩, h⟩\n    refine' (hconn u v uo vo (hsub.trans hsuv) hSu hSv).mono _\n    exact inter_subset_inter_left _ hsub\n#align is_preconnected_univ_pi isPreconnected_univ_pi\n-/\n\n",
 "isPreconnected_unionₛ":
 "#print isPreconnected_unionₛ /-\n/-- A union of a family of preconnected sets with a common point is preconnected as well. -/\ntheorem isPreconnected_unionₛ (x : α) (c : Set (Set α)) (H1 : ∀ s ∈ c, x ∈ s) (H2 : ∀ s ∈ c, IsPreconnected s) :\n    IsPreconnected (⋃₀ c) := by\n  apply isPreconnected_of_forall x\n  rintro y ⟨s, sc, ys⟩\n  exact ⟨s, subset_sUnion_of_mem sc, H1 s sc, ys, H2 s sc⟩\n#align is_preconnected_sUnion isPreconnected_unionₛ\n-/\n\n",
 "isPreconnected_unionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isPreconnected_unionᵢ /-\ntheorem isPreconnected_unionᵢ {ι : Sort _} {s : ι → Set α}\n    (h₁ :\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)).nonempty)\n    (h₂ : ∀ i, IsPreconnected (s i)) :\n    IsPreconnected\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  exists.elim h₁ fun f hf => isPreconnected_unionₛ f _ hf (forall_range_iff.2 h₂)\n#align is_preconnected_Union isPreconnected_unionᵢ\n-/\n\n",
 "isPreconnected_singleton":
 "#print isPreconnected_singleton /-\ntheorem isPreconnected_singleton {x} : IsPreconnected ({x} : Set α) :=\n  isConnected_singleton.is_preconnected\n#align is_preconnected_singleton isPreconnected_singleton\n-/\n\n",
 "isPreconnected_range":
 "#print isPreconnected_range /-\ntheorem isPreconnected_range [TopologicalSpace β] [PreconnectedSpace α] {f : α → β} (h : Continuous f) :\n    IsPreconnected (range f) :=\n  @image_univ _ _ f ▸ is_preconnected_univ.image _ h.continuous_on\n#align is_preconnected_range isPreconnected_range\n-/\n\n",
 "isPreconnected_of_forall_pair":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » s) -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n#print isPreconnected_of_forall_pair /-\n/-- If any two points of a set are contained in a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem isPreconnected_of_forall_pair {s : Set α}\n    (H : ∀ (x) (_ : x ∈ s) (y) (_ : y ∈ s), ∃ (t : _)(_ : t ⊆ s), x ∈ t ∧ y ∈ t ∧ IsPreconnected t) :\n    IsPreconnected s := by\n  rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)\n  exacts[isPreconnected_empty, isPreconnected_of_forall x fun y => H x hx y]\n#align is_preconnected_of_forall_pair isPreconnected_of_forall_pair\n-/\n\n",
 "isPreconnected_of_forall_constant":
 "#print isPreconnected_of_forall_constant /-\n/-- If every map to `bool` (a discrete two-element space), that is\ncontinuous on a set `s`, is constant on s, then s is preconnected -/\ntheorem isPreconnected_of_forall_constant {s : Set α}\n    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s :=\n  by\n  unfold IsPreconnected\n  by_contra'\n  rcases this with ⟨u, v, u_op, v_op, hsuv, ⟨x, x_in_s, x_in_u⟩, ⟨y, y_in_s, y_in_v⟩, H⟩\n  rw [not_nonempty_iff_eq_empty] at H\n  have hy : y ∉ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y ⟨y_in_s, ⟨y_in_u, y_in_v⟩⟩\n  have : ContinuousOn u.bool_indicator s :=\n    by\n    apply (continuousOn_boolIndicator_iff_clopen _ _).mpr ⟨_, _⟩\n    · exact continuous_subtype_coe.is_open_preimage u u_op\n    · rw [preimage_subtype_coe_eq_compl hsuv H]\n      exact (continuous_subtype_coe.is_open_preimage v v_op).is_closed_compl\n  simpa [(u.mem_iff_bool_indicator _).mp x_in_u, (u.not_mem_iff_bool_indicator _).mp hy] using\n    hs _ this x x_in_s y y_in_s\n#align is_preconnected_of_forall_constant isPreconnected_of_forall_constant\n-/\n\n",
 "isPreconnected_of_forall":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n#print isPreconnected_of_forall /-\n/-- If any point of a set is joined to a fixed point by a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem isPreconnected_of_forall {s : Set α} (x : α)\n    (H : ∀ y ∈ s, ∃ (t : _)(_ : t ⊆ s), x ∈ t ∧ y ∈ t ∧ IsPreconnected t) : IsPreconnected s :=\n  by\n  rintro u v hu hv hs ⟨z, zs, zu⟩ ⟨y, ys, yv⟩\n  have xs : x ∈ s := by\n    rcases H y ys with ⟨t, ts, xt, yt, ht⟩\n    exact ts xt\n  wlog xu : x ∈ u\n  · rw [inter_comm u v]\n    rw [union_comm] at hs\n    exact this x H v u hv hu hs y ys yv z zs zu xs ((hs xs).resolve_right xu)\n  rcases H y ys with ⟨t, ts, xt, yt, ht⟩\n  have := ht u v hu hv (subset.trans ts hs) ⟨x, xt, xu⟩ ⟨y, yt, yv⟩\n  exact this.imp fun z hz => ⟨ts hz.1, hz.2⟩\n#align is_preconnected_of_forall isPreconnected_of_forall\n-/\n\n",
 "isPreconnected_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Inducing.isPreconnected_image /-\ntheorem Inducing.isPreconnected_image [TopologicalSpace β] {s : Set α} {f : α → β} (hf : Inducing f) :\n    IsPreconnected («expr '' » f s) ↔ IsPreconnected s :=\n  by\n  refine' ⟨fun h => _, fun h => h.image _ hf.continuous.continuous_on⟩\n  rintro u v hu' hv' huv ⟨x, hxs, hxu⟩ ⟨y, hys, hyv⟩\n  rcases hf.is_open_iff.1 hu' with ⟨u, hu, rfl⟩\n  rcases hf.is_open_iff.1 hv' with ⟨v, hv, rfl⟩\n  replace huv : «expr '' » f s ⊆ u ∪ v; · rwa [image_subset_iff]\n  rcases h u v hu hv huv ⟨f x, mem_image_of_mem _ hxs, hxu⟩ ⟨f y, mem_image_of_mem _ hys, hyv⟩ with\n    ⟨_, ⟨z, hzs, rfl⟩, hzuv⟩\n  exact ⟨z, hzs, hzuv⟩\n#align inducing.is_preconnected_image Inducing.isPreconnected_image\n-/\n\n",
 "isPreconnected_iff_subset_of_fully_disjoint_closed":
 "#print isPreconnected_iff_subset_of_fully_disjoint_closed /-\n/-- A closed set `s` is preconnected if and only if\nfor every cover by two closed sets that are disjoint,\nit is contained in one of the two covering sets. -/\ntheorem isPreconnected_iff_subset_of_fully_disjoint_closed {s : Set α} (hs : IsClosed s) :\n    IsPreconnected s ↔\n      ∀ (u v : Set α) (hu : IsClosed u) (hv : IsClosed v) (hss : s ⊆ u ∪ v) (huv : Disjoint u v), s ⊆ u ∨ s ⊆ v :=\n  by\n  constructor\n  · intro h u v hu hv hss huv\n    apply isPreconnected_iff_subset_of_disjoint_closed.1 h u v hu hv hss\n    rw [huv.inter_eq, inter_empty]\n  intro H\n  rw [isPreconnected_iff_subset_of_disjoint_closed]\n  intro u v hu hv hss huv\n  have H1 := H (u ∩ s) (v ∩ s)\n  rw [subset_inter_iff, subset_inter_iff] at H1\n  simp only [subset.refl, and_true_iff] at H1\n  apply H1 (IsClosed.inter hu hs) (IsClosed.inter hv hs)\n  · rw [← inter_distrib_right]\n    exact subset_inter hss subset.rfl\n  · rwa [disjoint_iff_inter_eq_empty, ← inter_inter_distrib_right, inter_comm]\n#align is_preconnected_iff_subset_of_fully_disjoint_closed isPreconnected_iff_subset_of_fully_disjoint_closed\n-/\n\n",
 "isPreconnected_iff_subset_of_disjoint_closed":
 "#print isPreconnected_iff_subset_of_disjoint_closed /-\n/-- A set `s` is preconnected if and only if\nfor every cover by two closed sets that are disjoint on `s`,\nit is contained in one of the two covering sets. -/\ntheorem isPreconnected_iff_subset_of_disjoint_closed :\n    IsPreconnected s ↔\n      ∀ (u v : Set α) (hu : IsClosed u) (hv : IsClosed v) (hs : s ⊆ u ∪ v) (huv : s ∩ (u ∩ v) = ∅), s ⊆ u ∨ s ⊆ v :=\n  by\n  constructor <;> intro h\n  · intro u v hu hv hs huv\n    rw [isPreconnected_closed_iff] at h\n    specialize h u v hu hv hs\n    contrapose! huv\n    rw [← nonempty_iff_ne_empty]\n    simp [not_subset] at huv\n    rcases huv with ⟨⟨x, hxs, hxu⟩, ⟨y, hys, hyv⟩⟩\n    have hxv : x ∈ v := or_iff_not_imp_left.mp (hs hxs) hxu\n    have hyu : y ∈ u := or_iff_not_imp_right.mp (hs hys) hyv\n    exact h ⟨y, hys, hyu⟩ ⟨x, hxs, hxv⟩\n  · rw [isPreconnected_closed_iff]\n    intro u v hu hv hs hsu hsv\n    rw [nonempty_iff_ne_empty]\n    intro H\n    specialize h u v hu hv hs H\n    contrapose H\n    apply nonempty.ne_empty\n    cases h\n    · rcases hsv with ⟨x, hxs, hxv⟩\n      exact ⟨x, hxs, ⟨h hxs, hxv⟩⟩\n    · rcases hsu with ⟨x, hxs, hxu⟩\n      exact ⟨x, hxs, ⟨hxu, h hxs⟩⟩\n#align is_preconnected_iff_subset_of_disjoint_closed isPreconnected_iff_subset_of_disjoint_closed\n-/\n\n",
 "isPreconnected_iff_subset_of_disjoint":
 "#print isPreconnected_iff_subset_of_disjoint /-\n/-- A set `s` is preconnected if and only if\nfor every cover by two open sets that are disjoint on `s`,\nit is contained in one of the two covering sets. -/\ntheorem isPreconnected_iff_subset_of_disjoint {s : Set α} :\n    IsPreconnected s ↔\n      ∀ (u v : Set α) (hu : IsOpen u) (hv : IsOpen v) (hs : s ⊆ u ∪ v) (huv : s ∩ (u ∩ v) = ∅), s ⊆ u ∨ s ⊆ v :=\n  by\n  constructor <;> intro h\n  · intro u v hu hv hs huv\n    specialize h u v hu hv hs\n    contrapose! huv\n    rw [← nonempty_iff_ne_empty]\n    simp [not_subset] at huv\n    rcases huv with ⟨⟨x, hxs, hxu⟩, ⟨y, hys, hyv⟩⟩\n    have hxv : x ∈ v := or_iff_not_imp_left.mp (hs hxs) hxu\n    have hyu : y ∈ u := or_iff_not_imp_right.mp (hs hys) hyv\n    exact h ⟨y, hys, hyu⟩ ⟨x, hxs, hxv⟩\n  · intro u v hu hv hs hsu hsv\n    rw [nonempty_iff_ne_empty]\n    intro H\n    specialize h u v hu hv hs H\n    contrapose H\n    apply nonempty.ne_empty\n    cases h\n    · rcases hsv with ⟨x, hxs, hxv⟩\n      exact ⟨x, hxs, ⟨h hxs, hxv⟩⟩\n    · rcases hsu with ⟨x, hxs, hxu⟩\n      exact ⟨x, hxs, ⟨hxu, h hxs⟩⟩\n#align is_preconnected_iff_subset_of_disjoint isPreconnected_iff_subset_of_disjoint\n-/\n\n",
 "isPreconnected_iff_preconnectedSpace":
 "#print isPreconnected_iff_preconnectedSpace /-\ntheorem isPreconnected_iff_preconnectedSpace {s : Set α} : IsPreconnected s ↔ PreconnectedSpace s :=\n  ⟨Subtype.preconnectedSpace, by\n    intro\n    simpa using is_preconnected_univ.image (coe : s → α) continuous_subtype_coe.continuous_on⟩\n#align is_preconnected_iff_preconnected_space isPreconnected_iff_preconnectedSpace\n-/\n\n",
 "isPreconnected_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Sum.isPreconnected_iff /-\ntheorem Sum.isPreconnected_iff [TopologicalSpace β] {s : Set (Sum α β)} :\n    IsPreconnected s ↔\n      (∃ t, IsPreconnected t ∧ s = «expr '' » Sum.inl t) ∨ ∃ t, IsPreconnected t ∧ s = «expr '' » Sum.inr t :=\n  by\n  refine' ⟨fun hs => _, _⟩\n  · obtain rfl | h := s.eq_empty_or_nonempty\n    · exact or.inl ⟨∅, isPreconnected_empty, (Set.image_empty _).symm⟩\n    obtain ⟨t, ht, rfl⟩ | ⟨t, ht, rfl⟩ := Sum.isConnected_iff.1 ⟨h, hs⟩\n    · exact or.inl ⟨t, ht.is_preconnected, rfl⟩\n    · exact or.inr ⟨t, ht.is_preconnected, rfl⟩\n  · rintro (⟨t, ht, rfl⟩ | ⟨t, ht, rfl⟩)\n    · exact ht.image _ continuous_inl.continuous_on\n    · exact ht.image _ continuous_inr.continuous_on\n#align sum.is_preconnected_iff Sum.isPreconnected_iff\n-/\n\n",
 "isPreconnected_empty":
 "#print isPreconnected_empty /-\ntheorem isPreconnected_empty : IsPreconnected (∅ : Set α) :=\n  isPreirreducible_empty.is_preconnected\n#align is_preconnected_empty isPreconnected_empty\n-/\n\n",
 "isPreconnected_connectedComponentIn":
 "#print isPreconnected_connectedComponentIn /-\ntheorem isPreconnected_connectedComponentIn {x : α} {F : Set α} : IsPreconnected (connectedComponentIn F x) :=\n  by\n  rw [connectedComponentIn]; split_ifs\n  · exact embedding_subtype_coe.to_inducing.is_preconnected_image.mpr isPreconnected_connectedComponent\n  · exact isPreconnected_empty\n#align is_preconnected_connected_component_in isPreconnected_connectedComponentIn\n-/\n\n",
 "isPreconnected_connectedComponent":
 "#print isPreconnected_connectedComponent /-\ntheorem isPreconnected_connectedComponent {x : α} : IsPreconnected (connectedComponent x) :=\n  isPreconnected_unionₛ x _ (fun _ => And.right) fun _ => And.left\n#align is_preconnected_connected_component isPreconnected_connectedComponent\n-/\n\n",
 "isPreconnected_closed_iff":
 "#print isPreconnected_closed_iff /-\ntheorem isPreconnected_closed_iff {s : Set α} :\n    IsPreconnected s ↔\n      ∀ t t', IsClosed t → IsClosed t' → s ⊆ t ∪ t' → (s ∩ t).nonempty → (s ∩ t').nonempty → (s ∩ (t ∩ t')).nonempty :=\n  ⟨by\n    rintro h t t' ht ht' htt' ⟨x, xs, xt⟩ ⟨y, ys, yt'⟩\n    rw [← not_disjoint_iff_nonempty_inter, ← subset_compl_iff_disjoint_right, compl_inter]\n    intro h'\n    have xt' : x ∉ t' := (h' xs).resolve_left (absurd xt)\n    have yt : y ∉ t := (h' ys).resolve_right (absurd yt')\n    have := h _ _ ht.is_open_compl ht'.is_open_compl h' ⟨y, ys, yt⟩ ⟨x, xs, xt'⟩\n    rw [← compl_union] at this\n    exact this.ne_empty htt'.disjoint_compl_right.inter_eq,\n    by\n    rintro h u v hu hv huv ⟨x, xs, xu⟩ ⟨y, ys, yv⟩\n    rw [← not_disjoint_iff_nonempty_inter, ← subset_compl_iff_disjoint_right, compl_inter]\n    intro h'\n    have xv : x ∉ v := (h' xs).elim (absurd xu) id\n    have yu : y ∉ u := (h' ys).elim id (absurd yv)\n    have := h _ _ hu.is_closed_compl hv.is_closed_compl h' ⟨y, ys, yu⟩ ⟨x, xs, xv⟩\n    rw [← compl_union] at this\n    exact this.ne_empty huv.disjoint_compl_right.inter_eq⟩\n#align is_preconnected_closed_iff isPreconnected_closed_iff\n-/\n\n",
 "isPreconnected":
 "#print Set.Subsingleton.isPreconnected /-\ntheorem Set.Subsingleton.isPreconnected {s : Set α} (hs : s.subsingleton) : IsPreconnected s :=\n  hs.induction_on isPreconnected_empty fun x => isPreconnected_singleton\n#align set.subsingleton.is_preconnected Set.Subsingleton.isPreconnected\n-/\n\n",
 "isOpen_connectedComponent":
 "#print isOpen_connectedComponent /-\ntheorem isOpen_connectedComponent [LocallyConnectedSpace α] {x : α} : IsOpen (connectedComponent x) :=\n  by\n  rw [← connectedComponentIn_univ]\n  exact is_open_univ.connected_component_in\n#align is_open_connected_component isOpen_connectedComponent\n-/\n\n",
 "isConnected_univ_pi":
 "#print isConnected_univ_pi /-\n@[simp]\ntheorem isConnected_univ_pi [∀ i, TopologicalSpace (π i)] {s : ∀ i, Set (π i)} :\n    IsConnected (pi univ s) ↔ ∀ i, IsConnected (s i) :=\n  by\n  simp only [IsConnected, ← univ_pi_nonempty_iff, forall_and, and_congr_right_iff]\n  refine' fun hne => ⟨fun hc i => _, isPreconnected_univ_pi⟩\n  rw [← eval_image_univ_pi hne]\n  exact hc.image _ (continuous_apply _).continuous_on\n#align is_connected_univ_pi isConnected_univ_pi\n-/\n\n",
 "isConnected_univ":
 "#print isConnected_univ /-\n-- see Note [lower instance priority]\ntheorem isConnected_univ [ConnectedSpace α] : IsConnected (univ : Set α) :=\n  ⟨univ_nonempty, is_preconnected_univ⟩\n#align is_connected_univ isConnected_univ\n-/\n\n",
 "isConnected_singleton":
 "#print isConnected_singleton /-\ntheorem isConnected_singleton {x} : IsConnected ({x} : Set α) :=\n  isIrreducible_singleton.is_connected\n#align is_connected_singleton isConnected_singleton\n-/\n\n",
 "isConnected_range":
 "#print isConnected_range /-\ntheorem isConnected_range [TopologicalSpace β] [ConnectedSpace α] {f : α → β} (h : Continuous f) :\n    IsConnected (range f) :=\n  ⟨range_nonempty f, isPreconnected_range h⟩\n#align is_connected_range isConnected_range\n-/\n\n",
 "isConnected_iff_unionₛ_disjoint_open":
 "#print isConnected_iff_unionₛ_disjoint_open /-\n/-- A set `s` is connected if and only if\nfor every cover by a finite collection of open sets that are pairwise disjoint on `s`,\nit is contained in one of the members of the collection. -/\ntheorem isConnected_iff_unionₛ_disjoint_open {s : Set α} :\n    IsConnected s ↔\n      ∀ (U : Finset (Set α)) (H : ∀ u v : Set α, u ∈ U → v ∈ U → (s ∩ (u ∩ v)).nonempty → u = v)\n        (hU : ∀ u ∈ U, IsOpen u) (hs : s ⊆ ⋃₀ ↑U), ∃ u ∈ U, s ⊆ u :=\n  by\n  rw [IsConnected, isPreconnected_iff_subset_of_disjoint]\n  constructor <;> intro h\n  · intro U\n    apply Finset.induction_on U\n    · rcases h.left with ⟨⟩\n      suffices s ⊆ ∅ → False by simpa\n      intro\n      solve_by_elim\n    · intro u U hu IH hs hU H\n      rw [Finset.coe_insert, sUnion_insert] at H\n      cases' h.2 u (⋃₀ ↑U) _ _ H _ with hsu hsU\n      · exact ⟨u, Finset.mem_insert_self _ _, hsu⟩\n      · rcases IH _ _ hsU with ⟨v, hvU, hsv⟩\n        · exact ⟨v, Finset.mem_insert_of_mem hvU, hsv⟩\n        · intros\n          apply hs <;> solve_by_elim [Finset.mem_insert_of_mem]\n        · intros\n          solve_by_elim [Finset.mem_insert_of_mem]\n      · solve_by_elim [Finset.mem_insert_self]\n      · apply isOpen_unionₛ\n        intros\n        solve_by_elim [Finset.mem_insert_of_mem]\n      · apply eq_empty_of_subset_empty\n        rintro x ⟨hxs, hxu, hxU⟩\n        rw [mem_sUnion] at hxU\n        rcases hxU with ⟨v, hvU, hxv⟩\n        rcases hs u v (Finset.mem_insert_self _ _) (Finset.mem_insert_of_mem hvU) _ with rfl\n        · contradiction\n        · exact ⟨x, hxs, hxu, hxv⟩\n  · constructor\n    · rw [nonempty_iff_ne_empty]\n      by_contra hs\n      subst hs\n      simpa using h ∅ _ _ _ <;> simp\n    intro u v hu hv hs hsuv\n    rcases h {u, v} _ _ _ with ⟨t, ht, ht'⟩\n    · rw [Finset.mem_insert, Finset.mem_singleton] at ht\n      rcases ht with (rfl | rfl) <;> tauto\n    · intro t₁ t₂ ht₁ ht₂ hst\n      rw [nonempty_iff_ne_empty] at hst\n      rw [Finset.mem_insert, Finset.mem_singleton] at ht₁ ht₂\n      rcases ht₁ with (rfl | rfl) <;> rcases ht₂ with (rfl | rfl)\n      all_goals first |rfl|contradiction|skip\n      rw [inter_comm t₁] at hst\n      contradiction\n    · intro t\n      rw [Finset.mem_insert, Finset.mem_singleton]\n      rintro (rfl | rfl) <;> assumption\n    · simpa using hs\n#align is_connected_iff_sUnion_disjoint_open isConnected_iff_unionₛ_disjoint_open\n-/\n\n",
 "isConnected_iff_connectedSpace":
 "#print isConnected_iff_connectedSpace /-\ntheorem isConnected_iff_connectedSpace {s : Set α} : IsConnected s ↔ ConnectedSpace s :=\n  ⟨Subtype.connectedSpace, fun h => ⟨nonempty_subtype.mp h.2, isPreconnected_iff_preconnectedSpace.mpr h.1⟩⟩\n#align is_connected_iff_connected_space isConnected_iff_connectedSpace\n-/\n\n",
 "isConnected_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Sum.isConnected_iff /-\ntheorem Sum.isConnected_iff [TopologicalSpace β] {s : Set (Sum α β)} :\n    IsConnected s ↔ (∃ t, IsConnected t ∧ s = «expr '' » Sum.inl t) ∨ ∃ t, IsConnected t ∧ s = «expr '' » Sum.inr t :=\n  by\n  refine' ⟨fun hs => _, _⟩\n  · let u : Set (Sum α β) := range Sum.inl\n    let v : Set (Sum α β) := range Sum.inr\n    have hu : IsOpen u := isOpen_range_inl\n    obtain ⟨x | x, hx⟩ := hs.nonempty\n    · have h : s ⊆ range Sum.inl :=\n        IsPreconnected.subset_left_of_subset_union isOpen_range_inl isOpen_range_inr\n          is_compl_range_inl_range_inr.disjoint (by simp) ⟨Sum.inl x, hx, x, rfl⟩ hs.2\n      refine' or.inl ⟨«expr ⁻¹' » Sum.inl s, _, _⟩\n      · exact hs.preimage_of_open_map Sum.inl_injective open_embedding_inl.is_open_map h\n      · exact (Set.image_preimage_eq_of_subset h).symm\n    · have h : s ⊆ range Sum.inr :=\n        IsPreconnected.subset_right_of_subset_union isOpen_range_inl isOpen_range_inr\n          is_compl_range_inl_range_inr.disjoint (by simp) ⟨Sum.inr x, hx, x, rfl⟩ hs.2\n      refine' or.inr ⟨«expr ⁻¹' » Sum.inr s, _, _⟩\n      · exact hs.preimage_of_open_map Sum.inr_injective open_embedding_inr.is_open_map h\n      · exact (Set.image_preimage_eq_of_subset h).symm\n  · rintro (⟨t, ht, rfl⟩ | ⟨t, ht, rfl⟩)\n    · exact ht.image _ continuous_inl.continuous_on\n    · exact ht.image _ continuous_inr.continuous_on\n#align sum.is_connected_iff Sum.isConnected_iff\n-/\n\n",
 "isConnected_connectedComponentIn_iff":
 "#print isConnected_connectedComponentIn_iff /-\ntheorem isConnected_connectedComponentIn_iff {x : α} {F : Set α} : IsConnected (connectedComponentIn F x) ↔ x ∈ F := by\n  simp_rw [← connectedComponentIn_nonempty_iff, IsConnected, isPreconnected_connectedComponentIn, and_true_iff]\n#align is_connected_connected_component_in_iff isConnected_connectedComponentIn_iff\n-/\n\n",
 "isConnected_connectedComponent":
 "#print isConnected_connectedComponent /-\ntheorem isConnected_connectedComponent {x : α} : IsConnected (connectedComponent x) :=\n  ⟨⟨x, mem_connectedComponent⟩, isPreconnected_connectedComponent⟩\n#align is_connected_connected_component isConnected_connectedComponent\n-/\n\n",
 "isConnected":
 "#print IsIrreducible.isConnected /-\ntheorem IsIrreducible.isConnected {s : Set α} (H : IsIrreducible s) : IsConnected s :=\n  ⟨H.nonempty, H.is_preirreducible.is_preconnected⟩\n#align is_irreducible.is_connected IsIrreducible.isConnected\n-/\n\n",
 "isClosed_connectedComponent":
 "#print isClosed_connectedComponent /-\ntheorem isClosed_connectedComponent {x : α} : IsClosed (connectedComponent x) :=\n  closure_subset_iff_isClosed.1 <|\n    isConnected_connectedComponent.closure.subset_connected_component <| subset_closure mem_connectedComponent\n#align is_closed_connected_component isClosed_connectedComponent\n-/\n\n",
 "isClopen_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print isClopen_iff /-\ntheorem isClopen_iff [PreconnectedSpace α] {s : Set α} : IsClopen s ↔ s = ∅ ∨ s = univ :=\n  ⟨fun hs =>\n    by_contradiction fun h =>\n      have h1 : s ≠ ∅ ∧ «expr ᶜ» s ≠ ∅ :=\n        ⟨mt or.inl h, mt (fun h2 => or.inr <| (by rw [← compl_compl s, h2, compl_empty] : s = univ)) h⟩\n      let ⟨_, h2, h3⟩ :=\n        nonempty_inter hs.1 hs.2.is_open_compl (union_compl_self s) (nonempty_iff_ne_empty.2 h1.1)\n          (nonempty_iff_ne_empty.2 h1.2)\n      h3 h2,\n    by rintro (rfl | rfl) <;> [exact isClopen_empty, exact isClopen_univ]⟩\n#align is_clopen_iff isClopen_iff\n-/\n\n",
 "isClopen_connectedComponent":
 "#print isClopen_connectedComponent /-\ntheorem isClopen_connectedComponent [LocallyConnectedSpace α] {x : α} : IsClopen (connectedComponent x) :=\n  ⟨isOpen_connectedComponent, isClosed_connectedComponent⟩\n#align is_clopen_connected_component isClopen_connectedComponent\n-/\n\n",
 "irreducibleComponent_subset_connectedComponent":
 "#print irreducibleComponent_subset_connectedComponent /-\ntheorem irreducibleComponent_subset_connectedComponent {x : α} : irreducibleComponent x ⊆ connectedComponent x :=\n  isIrreducible_irreducibleComponent.is_connected.subset_connected_component mem_irreducibleComponent\n#align irreducible_component_subset_connected_component irreducibleComponent_subset_connectedComponent\n-/\n\n",
 "image_eq_of_connectedComponent_eq":
 "#print Continuous.image_eq_of_connectedComponent_eq /-\ntheorem Continuous.image_eq_of_connectedComponent_eq (h : Continuous f) (a b : α)\n    (hab : connectedComponent a = connectedComponent b) : f a = f b :=\n  singleton_eq_singleton_iff.1 <|\n    h.image_connected_component_eq_singleton a ▸ h.image_connected_component_eq_singleton b ▸ hab ▸ rfl\n#align continuous.image_eq_of_connected_component_eq Continuous.image_eq_of_connectedComponent_eq\n-/\n\n",
 "image_connectedComponent_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Continuous.image_connectedComponent_subset /-\ntheorem Continuous.image_connectedComponent_subset [TopologicalSpace β] {f : α → β} (h : Continuous f) (a : α) :\n    «expr '' » f (connectedComponent a) ⊆ connectedComponent (f a) :=\n  (isConnected_connectedComponent.image f h.continuous_on).subset_connected_component\n    ((mem_image f (connectedComponent a) (f a)).2 ⟨a, mem_connectedComponent, rfl⟩)\n#align continuous.image_connected_component_subset Continuous.image_connectedComponent_subset\n-/\n\n",
 "image_connectedComponent_eq_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Continuous.image_connectedComponent_eq_singleton /-\n/-- The image of a connected component in a totally disconnected space is a singleton. -/\n@[simp]\ntheorem Continuous.image_connectedComponent_eq_singleton {β : Type _} [TopologicalSpace β] [TotallyDisconnectedSpace β]\n    {f : α → β} (h : Continuous f) (a : α) : «expr '' » f (connectedComponent a) = {f a} :=\n  (Set.subsingleton_iff_singleton <| mem_image_of_mem f mem_connectedComponent).mp\n    (isPreconnected_connectedComponent.image f h.continuous_on).subsingleton\n#align continuous.image_connected_component_eq_singleton Continuous.image_connectedComponent_eq_singleton\n-/\n\n",
 "image_connectedComponent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print QuotientMap.image_connectedComponent /-\ntheorem QuotientMap.image_connectedComponent [TopologicalSpace β] {f : α → β} (hf : QuotientMap f)\n    (h_fibers : ∀ y : β, IsConnected («expr ⁻¹' » f {y})) (a : α) :\n    «expr '' » f (connectedComponent a) = connectedComponent (f a) := by\n  rw [← hf.preimage_connected_component h_fibers, image_preimage_eq _ hf.surjective]\n#align quotient_map.image_connected_component QuotientMap.image_connectedComponent\n-/\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsConnected.image /-\ntheorem IsConnected.image [TopologicalSpace β] {s : Set α} (H : IsConnected s) (f : α → β) (hf : ContinuousOn f s) :\n    IsConnected («expr '' » f s) :=\n  ⟨nonempty_image_iff.mpr H.nonempty, H.is_preconnected.image f hf⟩\n#align is_connected.image IsConnected.image\n-/\n\n",
 "frontier_eq_empty_iff":
 "#print frontier_eq_empty_iff /-\ntheorem frontier_eq_empty_iff [PreconnectedSpace α] {s : Set α} : frontier s = ∅ ↔ s = ∅ ∨ s = univ :=\n  isClopen_iff_frontier_eq_empty.symm.trans isClopen_iff\n#align frontier_eq_empty_iff frontier_eq_empty_iff\n-/\n\n",
 "exists_clopen_of_totally_separated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print exists_clopen_of_totally_separated /-\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\ntheorem exists_clopen_of_totally_separated {α : Type _} [TopologicalSpace α] [TotallySeparatedSpace α] {x y : α}\n    (hxy : x ≠ y) : ∃ (U : Set α)(hU : IsClopen U), x ∈ U ∧ y ∈ «expr ᶜ» U :=\n  by\n  obtain ⟨U, V, hU, hV, Ux, Vy, f, disj⟩ :=\n    totally_separated_space.is_totally_separated_univ α x (Set.mem_univ x) y (Set.mem_univ y) hxy\n  have clopen_U := isClopen_inter_of_disjoint_cover_clopen isClopen_univ f hU hV disj\n  rw [univ_inter _] at clopen_U\n  rw [← Set.subset_compl_iff_disjoint_right, subset_compl_comm] at disj\n  exact ⟨U, clopen_U, Ux, disj Vy⟩\n#align exists_clopen_of_totally_separated exists_clopen_of_totally_separated\n-/\n\n",
 "eq_univ":
 "#print IsClopen.eq_univ /-\ntheorem IsClopen.eq_univ [PreconnectedSpace α] {s : Set α} (h' : IsClopen s) (h : s.nonempty) : s = univ :=\n  (isClopen_iff.mp h').resolve_left h.ne_empty\n#align is_clopen.eq_univ IsClopen.eq_univ\n-/\n\n",
 "disjoint_or_subset_of_clopen":
 "#print disjoint_or_subset_of_clopen /-\n/-- Preconnected sets are either contained in or disjoint to any given clopen set. -/\ntheorem disjoint_or_subset_of_clopen {s t : Set α} (hs : IsPreconnected s) (ht : IsClopen t) : Disjoint s t ∨ s ⊆ t :=\n  (disjoint_or_nonempty_inter s t).imp_right <| hs.subset_clopen ht\n#align disjoint_or_subset_of_clopen disjoint_or_subset_of_clopen\n-/\n\n",
 "continuous_coe":
 "@[continuity]\ntheorem continuous_coe : Continuous (coe : α → ConnectedComponents α) :=\n  quotientMap_coe.continuous\n#align continuous_coe continuous_coe\n\n",
 "constant_of_mapsTo":
 "#print IsPreconnected.constant_of_mapsTo /-\n/-- Refinement of `is_preconnected.constant` only assuming the map factors through a\ndiscrete subset of the target. -/\ntheorem IsPreconnected.constant_of_mapsTo [TopologicalSpace β] {S : Set α} (hS : IsPreconnected S) {T : Set β}\n    [DiscreteTopology T] {f : α → β} (hc : ContinuousOn f S) (hTm : MapsTo f S T) {x y : α} (hx : x ∈ S) (hy : y ∈ S) :\n    f x = f y := by\n  let F : S → T := fun x : S => ⟨f x.val, hTm x.property⟩\n  suffices F ⟨x, hx⟩ = F ⟨y, hy⟩ by\n    rw [← Subtype.coe_inj] at this\n    exact this\n  exact\n    (is_preconnected_iff_preconnected_space.mp hS).constant\n      (continuous_induced_rng.mpr <| continuous_on_iff_continuous_restrict.mp hc)\n#align is_preconnected.constant_of_maps_to IsPreconnected.constant_of_mapsTo\n-/\n\n",
 "constant":
 "#print PreconnectedSpace.constant /-\n/-- A `preconnected_space` version of `is_preconnected.constant` -/\ntheorem PreconnectedSpace.constant {Y : Type _} [TopologicalSpace Y] [DiscreteTopology Y] (hp : PreconnectedSpace α)\n    {f : α → Y} (hf : Continuous f) {x y : α} : f x = f y :=\n  IsPreconnected.constant hp.is_preconnected_univ (Continuous.continuousOn hf) trivial trivial\n#align preconnected_space.constant PreconnectedSpace.constant\n-/\n\n",
 "connectedSpace_iff_connectedComponent":
 "#print connectedSpace_iff_connectedComponent /-\ntheorem connectedSpace_iff_connectedComponent : ConnectedSpace α ↔ ∃ x : α, connectedComponent x = univ :=\n  by\n  constructor\n  · rintro ⟨⟨x⟩⟩\n    exact ⟨x, eq_univ_of_univ_subset <| is_preconnected_univ.subset_connected_component (mem_univ x)⟩\n  · rintro ⟨x, h⟩\n    haveI : PreconnectedSpace α :=\n      ⟨by\n        rw [← h]\n        exact isPreconnected_connectedComponent⟩\n    exact ⟨⟨x⟩⟩\n#align connected_space_iff_connected_component connectedSpace_iff_connectedComponent\n-/\n\n",
 "connectedSpace":
 "#print Subtype.connectedSpace /-\ntheorem Subtype.connectedSpace {s : Set α} (h : IsConnected s) : ConnectedSpace s :=\n  { to_preconnected_space := Subtype.preconnectedSpace h.is_preconnected\n    to_nonempty := h.nonempty.to_subtype }\n#align subtype.connected_space Subtype.connectedSpace\n-/\n\n",
 "connectedComponents_preimage_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print connectedComponents_preimage_singleton /-\n/-- The preimage of a singleton in `connected_components` is the connected component\nof an element in the equivalence class. -/\ntheorem connectedComponents_preimage_singleton {x : α} :\n    «expr ⁻¹' » coe ({x} : Set (ConnectedComponents α)) = connectedComponent x :=\n  by\n  ext y\n  simp [ConnectedComponents.coe_eq_coe']\n#align connected_components_preimage_singleton connectedComponents_preimage_singleton\n-/\n\n",
 "connectedComponents_preimage_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print connectedComponents_preimage_image /-\n/-- The preimage of the image of a set under the quotient map to `connected_components α`\nis the union of the connected components of the elements in it. -/\ntheorem connectedComponents_preimage_image (U : Set α) :\n    «expr ⁻¹' » coe («expr '' » coe U : Set (ConnectedComponents α)) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (connectedComponent x) :=\n  by simp only [connectedComponents_preimage_singleton, preimage_Union₂, image_eq_Union]\n#align connected_components_preimage_image connectedComponents_preimage_image\n-/\n\n",
 "connectedComponents_lift_unique'":
 "#print connectedComponents_lift_unique' /-\ntheorem connectedComponents_lift_unique' {β : Sort _} {g₁ g₂ : ConnectedComponents α → β}\n    (hg : g₁ ∘ (coe : α → ConnectedComponents α) = g₂ ∘ coe) : g₁ = g₂ :=\n  ConnectedComponents.surjective_coe.injective_comp_right hg\n#align connected_components_lift_unique' connectedComponents_lift_unique'\n-/\n\n",
 "connectedComponentsMap_continuous":
 "#print Continuous.connectedComponentsMap_continuous /-\ntheorem Continuous.connectedComponentsMap_continuous {β : Type _} [TopologicalSpace β] {f : α → β} (h : Continuous f) :\n    Continuous h.connected_components_map :=\n  Continuous.connectedComponentsLift_continuous (continuous_quotient_mk'.comp h)\n#align continuous.connected_components_map_continuous Continuous.connectedComponentsMap_continuous\n-/\n\n",
 "connectedComponentsLift_unique":
 "#print Continuous.connectedComponentsLift_unique /-\ntheorem Continuous.connectedComponentsLift_unique (h : Continuous f) (g : ConnectedComponents α → β)\n    (hg : g ∘ coe = f) : g = h.connected_components_lift :=\n  connectedComponents_lift_unique' <| hg.trans h.connected_components_lift_comp_coe.symm\n#align continuous.connected_components_lift_unique Continuous.connectedComponentsLift_unique\n-/\n\n",
 "connectedComponentsLift_continuous":
 "#print Continuous.connectedComponentsLift_continuous /-\n@[continuity]\ntheorem Continuous.connectedComponentsLift_continuous (h : Continuous f) : Continuous h.connected_components_lift :=\n  h.quotient_lift_on' h.image_eq_of_connected_component_eq\n#align continuous.connected_components_lift_continuous Continuous.connectedComponentsLift_continuous\n-/\n\n",
 "connectedComponentsLift_comp_coe":
 "#print Continuous.connectedComponentsLift_comp_coe /-\n@[simp]\ntheorem Continuous.connectedComponentsLift_comp_coe (h : Continuous f) : h.connected_components_lift ∘ coe = f :=\n  rfl\n#align continuous.connected_components_lift_comp_coe Continuous.connectedComponentsLift_comp_coe\n-/\n\n",
 "connectedComponentsLift_apply_coe":
 "#print Continuous.connectedComponentsLift_apply_coe /-\n@[simp]\ntheorem Continuous.connectedComponentsLift_apply_coe (h : Continuous f) (x : α) : h.connected_components_lift x = f x :=\n  rfl\n#align continuous.connected_components_lift_apply_coe Continuous.connectedComponentsLift_apply_coe\n-/\n\n",
 "connectedComponent_subset_interᵢ_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print connectedComponent_subset_interᵢ_clopen /-\n/-- The connected component of a point is always a subset of the intersection of all its clopen\nneighbourhoods. -/\ntheorem connectedComponent_subset_interᵢ_clopen {x : α} :\n    connectedComponent x ⊆\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" Z :=\n  subset_interᵢ fun Z => Z.2.1.connected_component_subset Z.2.2\n#align connected_component_subset_Inter_clopen connectedComponent_subset_interᵢ_clopen\n-/\n\n",
 "connectedComponent_subset":
 "#print IsClopen.connectedComponent_subset /-\ntheorem IsClopen.connectedComponent_subset {x} (hs : IsClopen s) (hx : x ∈ s) : connectedComponent x ⊆ s :=\n  isPreconnected_connectedComponent.subset_clopen hs ⟨x, mem_connectedComponent, hx⟩\n#align is_clopen.connected_component_subset IsClopen.connectedComponent_subset\n-/\n\n",
 "connectedComponent_nonempty":
 "#print connectedComponent_nonempty /-\ntheorem connectedComponent_nonempty {x : α} : (connectedComponent x).nonempty :=\n  ⟨x, mem_connectedComponent⟩\n#align connected_component_nonempty connectedComponent_nonempty\n-/\n\n",
 "connectedComponent_eq_univ":
 "#print PreconnectedSpace.connectedComponent_eq_univ /-\n@[simp]\ntheorem PreconnectedSpace.connectedComponent_eq_univ {X : Type _} [TopologicalSpace X] [h : PreconnectedSpace X]\n    (x : X) : connectedComponent x = univ :=\n  preconnectedSpace_iff_connectedComponent.mp h x\n#align preconnected_space.connected_component_eq_univ PreconnectedSpace.connectedComponent_eq_univ\n-/\n\n",
 "connectedComponent_eq_singleton":
 "#print connectedComponent_eq_singleton /-\n@[simp]\ntheorem connectedComponent_eq_singleton [TotallyDisconnectedSpace α] (x : α) : connectedComponent x = {x} :=\n  totallyDisconnectedSpace_iff_connectedComponent_singleton.1 ‹_› x\n#align connected_component_eq_singleton connectedComponent_eq_singleton\n-/\n\n",
 "connectedComponent_eq_iff_mem":
 "#print connectedComponent_eq_iff_mem /-\ntheorem connectedComponent_eq_iff_mem {x y : α} :\n    connectedComponent x = connectedComponent y ↔ x ∈ connectedComponent y :=\n  ⟨fun h => h ▸ mem_connectedComponent, fun h => (connectedComponent_eq h).symm⟩\n#align connected_component_eq_iff_mem connectedComponent_eq_iff_mem\n-/\n\n",
 "connectedComponent_eq":
 "#print connectedComponent_eq /-\ntheorem connectedComponent_eq {x y : α} (h : y ∈ connectedComponent x) : connectedComponent x = connectedComponent y :=\n  eq_of_subset_of_subset (isConnected_connectedComponent.subset_connected_component h)\n    (isConnected_connectedComponent.subset_connected_component\n      (Set.mem_of_mem_of_subset mem_connectedComponent (isConnected_connectedComponent.subset_connected_component h)))\n#align connected_component_eq connectedComponent_eq\n-/\n\n",
 "connectedComponent_disjoint":
 "#print connectedComponent_disjoint /-\ntheorem connectedComponent_disjoint {x y : α} (h : connectedComponent x ≠ connectedComponent y) :\n    Disjoint (connectedComponent x) (connectedComponent y) :=\n  Set.disjoint_left.2 fun a h1 h2 => h ((connectedComponent_eq h1).trans (connectedComponent_eq h2).symm)\n#align connected_component_disjoint connectedComponent_disjoint\n-/\n\n",
 "connectedComponentIn_univ":
 "#print connectedComponentIn_univ /-\ntheorem connectedComponentIn_univ (x : α) : connectedComponentIn univ x = connectedComponent x :=\n  subset_antisymm (isPreconnected_connectedComponentIn.subset_connected_component <| mem_connectedComponentIn trivial)\n    (isPreconnected_connectedComponent.subset_connected_component_in mem_connectedComponent <| subset_univ _)\n#align connected_component_in_univ connectedComponentIn_univ\n-/\n\n",
 "connectedComponentIn_subset":
 "#print connectedComponentIn_subset /-\ntheorem connectedComponentIn_subset (F : Set α) (x : α) : connectedComponentIn F x ⊆ F :=\n  by\n  rw [connectedComponentIn]\n  split_ifs <;> simp\n#align connected_component_in_subset connectedComponentIn_subset\n-/\n\n",
 "connectedComponentIn_nonempty_iff":
 "#print connectedComponentIn_nonempty_iff /-\ntheorem connectedComponentIn_nonempty_iff {x : α} {F : Set α} : (connectedComponentIn F x).nonempty ↔ x ∈ F :=\n  by\n  rw [connectedComponentIn]\n  split_ifs <;> simp [connectedComponent_nonempty, h]\n#align connected_component_in_nonempty_iff connectedComponentIn_nonempty_iff\n-/\n\n",
 "connectedComponentIn_mono":
 "#print connectedComponentIn_mono /-\n@[mono]\ntheorem connectedComponentIn_mono (x : α) {F G : Set α} (h : F ⊆ G) :\n    connectedComponentIn F x ⊆ connectedComponentIn G x :=\n  by\n  by_cases hx : x ∈ F\n  · rw [connectedComponentIn_eq_image hx, connectedComponentIn_eq_image (h hx), ←\n      show (coe : G → α) ∘ inclusion h = coe by ext <;> rfl, image_comp]\n    exact image_subset coe ((continuous_inclusion h).image_connected_component_subset ⟨x, hx⟩)\n  · rw [connectedComponentIn_eq_empty hx]\n    exact Set.empty_subset _\n#align connected_component_in_mono connectedComponentIn_mono\n-/\n\n",
 "connectedComponentIn_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print connectedComponentIn_mem_nhds /-\ntheorem connectedComponentIn_mem_nhds [LocallyConnectedSpace α] {F : Set α} {x : α} (h : F ∈ (nhds) x) :\n    connectedComponentIn F x ∈ (nhds) x :=\n  by\n  rw [(locally_connected_space.open_connected_basis x).mem_iff] at h\n  rcases h with ⟨s, ⟨h1s, hxs, h2s⟩, hsF⟩\n  exact mem_nhds_iff.mpr ⟨s, h2s.is_preconnected.subset_connected_component_in hxs hsF, h1s, hxs⟩\n#align connected_component_in_mem_nhds connectedComponentIn_mem_nhds\n-/\n\n",
 "connectedComponentIn_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print connectedComponentIn_eq_image /-\ntheorem connectedComponentIn_eq_image {F : Set α} {x : α} (h : x ∈ F) :\n    connectedComponentIn F x = «expr '' » coe (connectedComponent (⟨x, h⟩ : F)) :=\n  dif_pos h\n#align connected_component_in_eq_image connectedComponentIn_eq_image\n-/\n\n",
 "connectedComponentIn_eq_empty":
 "#print connectedComponentIn_eq_empty /-\ntheorem connectedComponentIn_eq_empty {F : Set α} {x : α} (h : x ∉ F) : connectedComponentIn F x = ∅ :=\n  dif_neg h\n#align connected_component_in_eq_empty connectedComponentIn_eq_empty\n-/\n\n",
 "connectedComponentIn_eq":
 "#print connectedComponentIn_eq /-\ntheorem connectedComponentIn_eq {x y : α} {F : Set α} (h : y ∈ connectedComponentIn F x) :\n    connectedComponentIn F x = connectedComponentIn F y :=\n  by\n  have hx : x ∈ F := connected_component_in_nonempty_iff.mp ⟨y, h⟩\n  simp_rw [connectedComponentIn_eq_image hx] at h⊢\n  obtain ⟨⟨y, hy⟩, h2y, rfl⟩ := h\n  simp_rw [Subtype.coe_mk, connectedComponentIn_eq_image hy, connectedComponent_eq h2y]\n#align connected_component_in_eq connectedComponentIn_eq\n-/\n\n",
 "connectedComponentIn":
 "#print IsOpen.connectedComponentIn /-\ntheorem IsOpen.connectedComponentIn [LocallyConnectedSpace α] {F : Set α} {x : α} (hF : IsOpen F) :\n    IsOpen (connectedComponentIn F x) := by\n  rw [isOpen_iff_mem_nhds]\n  intro y hy\n  rw [connectedComponentIn_eq hy]\n  exact connectedComponentIn_mem_nhds (is_open_iff_mem_nhds.mp hF y <| connectedComponentIn_subset F x hy)\n#align is_open.connected_component_in IsOpen.connectedComponentIn\n-/\n\n",
 "coe_ne_coe":
 "theorem coe_ne_coe {x y : α} : (x : ConnectedComponents α) ≠ y ↔ connectedComponent x ≠ connectedComponent y :=\n  not_congr coe_eq_coe\n#align coe_ne_coe coe_ne_coe\n\n",
 "coe_eq_coe'":
 "theorem coe_eq_coe' {x y : α} : (x : ConnectedComponents α) = y ↔ x ∈ connectedComponent y :=\n  coe_eq_coe.trans connectedComponent_eq_iff_mem\n#align coe_eq_coe' coe_eq_coe'\n\n",
 "coe_eq_coe":
 "@[simp]\ntheorem coe_eq_coe {x y : α} : (x : ConnectedComponents α) = y ↔ connectedComponent x = connectedComponent y :=\n  Quotient.eq''\n#align coe_eq_coe coe_eq_coe\n\n",
 "closure":
 "#print IsConnected.closure /-\ntheorem IsConnected.closure {s : Set α} (H : IsConnected s) : IsConnected (closure s) :=\n  IsConnected.subset_closure H subset_closure <| Subset.refl <| closure s\n#align is_connected.closure IsConnected.closure\n-/\n\n",
 "bunionᵢ_of_reflTransGen":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (i j «expr ∈ » t) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print IsConnected.bunionᵢ_of_reflTransGen /-\n/-- The bUnion of a family of preconnected sets is preconnected if the graph determined by\nwhether two sets intersect is preconnected. -/\ntheorem IsConnected.bunionᵢ_of_reflTransGen {ι : Type _} {t : Set ι} {s : ι → Set α} (ht : t.nonempty)\n    (H : ∀ i ∈ t, IsConnected (s i))\n    (K : ∀ (i) (_ : i ∈ t) (j) (_ : j ∈ t), ReflTransGen (fun i j : ι => (s i ∩ s j).nonempty ∧ i ∈ t) i j) :\n    IsConnected\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) :=\n  ⟨nonempty_bunionᵢ.2 <| ⟨ht.some, ht.some_mem, (H _ ht.some_mem).nonempty⟩,\n    IsPreconnected.bunionᵢ_of_reflTransGen (fun i hi => (H i hi).is_preconnected) K⟩\n#align is_connected.bUnion_of_refl_trans_gen IsConnected.bunionᵢ_of_reflTransGen\n-/\n\n",
 "bunionᵢ_of_chain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print IsConnected.bunionᵢ_of_chain /-\n/-- The Union of connected sets indexed by a subset of a type with an archimedean successor\n  (like `ℕ` or `ℤ`) such that any two neighboring sets meet is preconnected. -/\ntheorem IsConnected.bunionᵢ_of_chain {s : β → Set α} {t : Set β} (hnt : t.nonempty) (ht : OrdConnected t)\n    (H : ∀ n ∈ t, IsConnected (s n)) (K : ∀ n : β, n ∈ t → succ n ∈ t → (s n ∩ s (succ n)).nonempty) :\n    IsConnected\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) :=\n  ⟨nonempty_bunionᵢ.2 <| ⟨hnt.some, hnt.some_mem, (H _ hnt.some_mem).nonempty⟩,\n    IsPreconnected.bunionᵢ_of_chain ht (fun i hi => (H i hi).is_preconnected) K⟩\n#align is_connected.bUnion_of_chain IsConnected.bunionᵢ_of_chain\n-/\n\n",
 "bunionᵢ_connectedComponent_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print IsClopen.bunionᵢ_connectedComponent_eq /-\n/-- A clopen set is the union of its connected components. -/\ntheorem IsClopen.bunionᵢ_connectedComponent_eq {Z : Set α} (h : IsClopen Z) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (connectedComponent x) =\n      Z :=\n  Subset.antisymm (unionᵢ₂_subset fun x => h.connected_component_subset) fun x hx =>\n    mem_unionᵢ₂_of_mem hx mem_connectedComponent\n#align is_clopen.bUnion_connected_component_eq IsClopen.bunionᵢ_connectedComponent_eq\n-/\n\n"}