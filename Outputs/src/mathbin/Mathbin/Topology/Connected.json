{"union'":
 "theorem is_preconnected.union' {s t : set α} (H : (s ∩ t).nonempty) (hs : is_preconnected s) (ht : is_preconnected t) :\n    is_preconnected (s ∪ t) := by\n  rcases H with ⟨x, hxs, hxt⟩\n  exact hs.union x hxs hxt ht\n#align is_preconnected.union' is_preconnected.union'\n\n",
 "union":
 "theorem is_connected.union {s t : set α} (H : (s ∩ t).nonempty) (Hs : is_connected s) (Ht : is_connected t) :\n    is_connected (s ∪ t) := by\n  rcases H with ⟨x, hx⟩\n  refine' ⟨⟨x, mem_union_left t (mem_of_mem_inter_left hx)⟩, _⟩\n  exact\n    is_preconnected.union x (mem_of_mem_inter_left hx) (mem_of_mem_inter_right hx) Hs.is_preconnected Ht.is_preconnected\n#align is_connected.union is_connected.union\n\n",
 "totally_disconnected_space_iff_connected_component_subsingleton":
 "/-- A space is totally disconnected iff its connected components are subsingletons. -/\ntheorem totally_disconnected_space_iff_connected_component_subsingleton :\n    totally_disconnected_space α ↔ ∀ x : α, (connected_component x).subsingleton :=\n  by\n  constructor\n  · intro h x\n    apply h.1\n    · exact subset_univ _\n    exact is_preconnected_connected_component\n  intro h; constructor\n  intro s s_sub hs\n  rcases eq_empty_or_nonempty s with (rfl | ⟨x, x_in⟩)\n  · exact subsingleton_empty\n  · exact (h x).anti (hs.subset_connected_component x_in)\n#align\n  totally_disconnected_space_iff_connected_component_subsingleton totally_disconnected_space_iff_connected_component_subsingleton\n\n",
 "totally_disconnected_space_iff_connected_component_singleton":
 "/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem totally_disconnected_space_iff_connected_component_singleton :\n    totally_disconnected_space α ↔ ∀ x : α, connected_component x = {x} :=\n  by\n  rw [totally_disconnected_space_iff_connected_component_subsingleton]\n  apply forall_congr' fun x => _\n  rw [subsingleton_iff_singleton]\n  exact mem_connected_component\n#align\n  totally_disconnected_space_iff_connected_component_singleton totally_disconnected_space_iff_connected_component_singleton\n\n",
 "surjective_coe":
 "theorem surjective_coe : surjective (coe : α → connected_components α) :=\n  surjective_quot_mk _\n#align surjective_coe surjective_coe\n\n",
 "subsingleton":
 "theorem is_preconnected.subsingleton [totally_disconnected_space α] {s : set α} (h : is_preconnected s) :\n    s.subsingleton :=\n  totally_disconnected_space.is_totally_disconnected_univ s (subset_univ s) h\n#align is_preconnected.subsingleton is_preconnected.subsingleton\n\n",
 "subset_right_of_subset_union":
 "theorem is_preconnected.subset_right_of_subset_union (hu : is_open u) (hv : is_open v) (huv : Disjoint u v)\n    (hsuv : s ⊆ u ∪ v) (hsv : (s ∩ v).nonempty) (hs : is_preconnected s) : s ⊆ v :=\n  hs.subset_left_of_subset_union hv hu huv.symm (union_comm u v ▸ hsuv) hsv\n#align is_preconnected.subset_right_of_subset_union is_preconnected.subset_right_of_subset_union\n\n",
 "subset_or_subset":
 "theorem is_preconnected.subset_or_subset (hu : is_open u) (hv : is_open v) (huv : Disjoint u v) (hsuv : s ⊆ u ∪ v)\n    (hs : is_preconnected s) : s ⊆ u ∨ s ⊆ v :=\n  by\n  specialize hs u v hu hv hsuv\n  obtain hsu | hsu := (s ∩ u).eq_empty_or_nonempty\n  · exact or.inr ((Set.disjoint_iff_inter_eq_empty.2 hsu).subset_right_of_subset_union hsuv)\n  · replace hs := mt (hs hsu)\n    simp_rw [Set.not_nonempty_iff_eq_empty, ← Set.disjoint_iff_inter_eq_empty, disjoint_iff_inter_eq_empty.1 huv] at hs\n    exact or.inl ((hs s.disjoint_empty).subset_left_of_subset_union hsuv)\n#align is_preconnected.subset_or_subset is_preconnected.subset_or_subset\n\n",
 "subset_of_closure_inter_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- If a preconnected set `s` intersects an open set `u`, and limit points of `u` inside `s` are\ncontained in `u`, then the whole set `s` is contained in `u`. -/\ntheorem is_preconnected.subset_of_closure_inter_subset (hs : is_preconnected s) (hu : is_open u)\n    (h'u : (s ∩ u).nonempty) (h : closure u ∩ s ⊆ u) : s ⊆ u :=\n  by\n  have A : s ⊆ u ∪ «expr ᶜ» (closure u) := by\n    intro x hx\n    by_cases xu : x ∈ u\n    · exact or.inl xu\n    · right\n      intro h'x\n      exact xu (h (mem_inter h'x hx))\n  apply hs.subset_left_of_subset_union hu is_closed_closure.is_open_compl _ A h'u\n  exact disjoint_compl_right.mono_right (compl_subset_compl.2 subset_closure)\n#align is_preconnected.subset_of_closure_inter_subset is_preconnected.subset_of_closure_inter_subset\n\n",
 "subset_left_of_subset_union":
 "theorem is_preconnected.subset_left_of_subset_union (hu : is_open u) (hv : is_open v) (huv : Disjoint u v)\n    (hsuv : s ⊆ u ∪ v) (hsu : (s ∩ u).nonempty) (hs : is_preconnected s) : s ⊆ u :=\n  Disjoint.subset_left_of_subset_union hsuv\n    (by\n      by_contra hsv\n      rw [not_disjoint_iff_nonempty_inter] at hsv\n      obtain ⟨x, _, hx⟩ := hs u v hu hv hsuv hsu hsv\n      exact Set.disjoint_iff.1 huv hx)\n#align is_preconnected.subset_left_of_subset_union is_preconnected.subset_left_of_subset_union\n\n",
 "subset_connected_component_in":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_preconnected.subset_connected_component_in {x : α} {F : set α} (hs : is_preconnected s) (hxs : x ∈ s)\n    (hsF : s ⊆ F) : s ⊆ connected_component_in F x :=\n  by\n  have : is_preconnected («expr ⁻¹' » (coe : F → α) s) :=\n    by\n    refine' embedding_subtype_coe.to_inducing.is_preconnected_image.mp _\n    rwa [Subtype.image_preimage_coe, inter_eq_left_iff_subset.mpr hsF]\n  have h2xs : (⟨x, hsF hxs⟩ : F) ∈ «expr ⁻¹' » coe s :=\n    by\n    rw [mem_preimage]\n    exact hxs\n  have := this.subset_connected_component h2xs\n  rw [connected_component_in_eq_image (hsF hxs)]\n  refine' subset.trans _ (image_subset _ this)\n  rw [Subtype.image_preimage_coe, inter_eq_left_iff_subset.mpr hsF]\n#align is_preconnected.subset_connected_component_in is_preconnected.subset_connected_component_in\n\n",
 "subset_connected_component":
 "theorem is_connected.subset_connected_component {x : α} {s : set α} (H1 : is_connected s) (H2 : x ∈ s) :\n    s ⊆ connected_component x :=\n  H1.2.subset_connected_component H2\n#align is_connected.subset_connected_component is_connected.subset_connected_component\n\n",
 "subset_closure":
 "theorem is_connected.subset_closure {s : set α} {t : set α} (H : is_connected s) (Kst : s ⊆ t) (Ktcs : t ⊆ closure s) :\n    is_connected t :=\n  let hsne := H.left\n  let ht := Kst\n  let htne := Nonempty.mono ht hsne\n  ⟨Nonempty.mono Kst H.left, is_preconnected.subset_closure H.right Kst Ktcs⟩\n#align is_connected.subset_closure is_connected.subset_closure\n\n",
 "subset_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- Preconnected sets are either contained in or disjoint to any given clopen set. -/\ntheorem is_preconnected.subset_clopen {s t : set α} (hs : is_preconnected s) (ht : is_clopen t)\n    (hne : (s ∩ t).nonempty) : s ⊆ t := by\n  by_contra h\n  have : (s ∩ «expr ᶜ» t).nonempty := inter_compl_nonempty_iff.2 h\n  obtain ⟨x, -, hx, hx'⟩ : (s ∩ (t ∩ «expr ᶜ» t)).nonempty\n  exact hs t («expr ᶜ» t) ht.is_open ht.compl.is_open (fun x hx => em _) hne this\n  exact hx' hx\n#align is_preconnected.subset_clopen is_preconnected.subset_clopen\n\n",
 "sUnion_directed":
 "/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem is_preconnected.sUnion_directed {S : set (set α)} (K : DirectedOn (· ⊆ ·) S) (H : ∀ s ∈ S, is_preconnected s) :\n    is_preconnected (⋃₀ S) :=\n  by\n  rintro u v hu hv Huv ⟨a, ⟨s, hsS, has⟩, hau⟩ ⟨b, ⟨t, htS, hbt⟩, hbv⟩\n  obtain ⟨r, hrS, hsr, htr⟩ : ∃ r ∈ S, s ⊆ r ∧ t ⊆ r := K s hsS t htS\n  have Hnuv : (r ∩ (u ∩ v)).nonempty :=\n    H _ hrS u v hu hv ((subset_sUnion_of_mem hrS).trans Huv) ⟨a, hsr has, hau⟩ ⟨b, htr hbt, hbv⟩\n  have Kruv : r ∩ (u ∩ v) ⊆ ⋃₀ S ∩ (u ∩ v) := inter_subset_inter_left _ (subset_sUnion_of_mem hrS)\n  exact Hnuv.mono Kruv\n#align is_preconnected.sUnion_directed is_preconnected.sUnion_directed\n\n",
 "range_coe":
 "@[simp]\ntheorem range_coe : range (coe : α → connected_components α) = univ :=\n  surjective_coe.range_eq\n#align range_coe range_coe\n\n",
 "quotient_map_coe":
 "theorem quotient_map_coe : quotient_map (coe : α → connected_components α) :=\n  quotient_map_quot_mk\n#align quotient_map_coe quotient_map_coe\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem is_connected.prod [topological_space β] {s : set α} {t : set β} (hs : is_connected s) (ht : is_connected t) :\n    is_connected (lower_set.prod s t) :=\n  ⟨hs.1.prod ht.1, hs.2.prod ht.2⟩\n#align is_connected.prod is_connected.prod\n\n",
 "preimage_of_open_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_connected.preimage_of_open_map [topological_space β] {s : set β} (hs : is_connected s) {f : α → β}\n    (hinj : function.injective f) (hf : is_open_map f) (hsf : s ⊆ range f) : is_connected («expr ⁻¹' » f s) :=\n  ⟨hs.nonempty.preimage' hsf, hs.is_preconnected.preimage_of_open_map hinj hf hsf⟩\n#align is_connected.preimage_of_open_map is_connected.preimage_of_open_map\n\n",
 "preimage_of_closed_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_connected.preimage_of_closed_map [topological_space β] {s : set β} (hs : is_connected s) {f : α → β}\n    (hinj : function.injective f) (hf : is_closed_map f) (hsf : s ⊆ range f) : is_connected («expr ⁻¹' » f s) :=\n  ⟨hs.nonempty.preimage' hsf, hs.is_preconnected.preimage_of_closed_map hinj hf hsf⟩\n#align is_connected.preimage_of_closed_map is_connected.preimage_of_closed_map\n\n",
 "preimage_connected_component_connected":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- The preimage of a connected component is preconnected if the function has connected fibers\nand a subset is closed iff the preimage is. -/\ntheorem preimage_connected_component_connected [topological_space β] {f : α → β}\n    (connected_fibers : ∀ t : β, is_connected («expr ⁻¹' » f {t}))\n    (hcl : ∀ T : set β, is_closed T ↔ is_closed («expr ⁻¹' » f T)) (t : β) :\n    is_connected («expr ⁻¹' » f (connected_component t)) :=\n  by\n  -- The following proof is essentially https://stacks.math.columbia.edu/tag/0377\n  -- although the statement is slightly different\n  have hf : surjective f := surjective.of_comp fun t : β => (connected_fibers t).1\n  constructor\n  · cases' hf t with s hs\n    use s\n    rw [mem_preimage, hs]\n    exact mem_connected_component\n  have hT : is_closed («expr ⁻¹' » f (connected_component t)) :=\n    (hcl (connected_component t)).1 is_closed_connected_component\n  -- To show it's preconnected we decompose (f ⁻¹' connected_component t) as a subset of two\n  -- closed disjoint sets in α. We want to show that it's a subset of either.\n  rw [is_preconnected_iff_subset_of_fully_disjoint_closed hT]\n  intro u v hu hv huv uv_disj\n  -- To do this we decompose connected_component t into T₁ and T₂\n  -- we will show that connected_component t is a subset of either and hence\n  -- (f ⁻¹' connected_component t) is a subset of u or v\n  let T₁ := { t' ∈ connected_component t | «expr ⁻¹' » f {t'} ⊆ u }\n  let T₂ := { t' ∈ connected_component t | «expr ⁻¹' » f {t'} ⊆ v }\n  have fiber_decomp : ∀ t' ∈ connected_component t, «expr ⁻¹' » f {t'} ⊆ u ∨ «expr ⁻¹' » f {t'} ⊆ v :=\n    by\n    intro t' ht'\n    apply is_preconnected_iff_subset_of_disjoint_closed.1 (connected_fibers t').2 u v hu hv\n    · exact subset.trans (hf.preimage_subset_preimage_iff.2 (singleton_subset_iff.2 ht')) huv\n    rw [uv_disj.inter_eq, inter_empty]\n  have T₁_u : «expr ⁻¹' » f T₁ = «expr ⁻¹' » f (connected_component t) ∩ u :=\n    by\n    apply eq_of_subset_of_subset\n    · rw [← bUnion_preimage_singleton]\n      refine' Union₂_subset fun t' ht' => subset_inter _ ht'.2\n      rw [hf.preimage_subset_preimage_iff, singleton_subset_iff]\n      exact ht'.1\n    rintro a ⟨hat, hau⟩\n    constructor\n    · exact mem_preimage.1 hat\n    dsimp only\n    cases fiber_decomp (f a) (mem_preimage.1 hat)\n    · exact h\n    · cases (nonempty_of_mem <| mem_inter hau <| h rfl).not_disjoint uv_disj\n  -- This proof is exactly the same as the above (modulo some symmetry)\n  have T₂_v : «expr ⁻¹' » f T₂ = «expr ⁻¹' » f (connected_component t) ∩ v :=\n    by\n    apply eq_of_subset_of_subset\n    · rw [← bUnion_preimage_singleton]\n      refine' Union₂_subset fun t' ht' => subset_inter _ ht'.2\n      rw [hf.preimage_subset_preimage_iff, singleton_subset_iff]\n      exact ht'.1\n    rintro a ⟨hat, hav⟩\n    constructor\n    · exact mem_preimage.1 hat\n    dsimp only\n    cases fiber_decomp (f a) (mem_preimage.1 hat)\n    · cases (nonempty_of_mem (mem_inter (h rfl) hav)).not_disjoint uv_disj\n    · exact h\n  -- Now we show T₁, T₂ are closed, cover connected_component t and are disjoint.\n  have hT₁ : is_closed T₁ := (hcl T₁).2 (T₁_u.symm ▸ is_closed.inter hT hu)\n  have hT₂ : is_closed T₂ := (hcl T₂).2 (T₂_v.symm ▸ is_closed.inter hT hv)\n  have T_decomp : connected_component t ⊆ T₁ ∪ T₂ := by\n    intro t' ht'\n    rw [mem_union t' T₁ T₂]\n    cases' fiber_decomp t' ht' with htu htv\n    · left\n      exact ⟨ht', htu⟩\n    right\n    exact ⟨ht', htv⟩\n  have T_disjoint : Disjoint T₁ T₂ := by\n    refine' Disjoint.of_preimage hf _\n    rw [T₁_u, T₂_v, disjoint_iff_inter_eq_empty, ← inter_inter_distrib_left, uv_disj.inter_eq, inter_empty]\n  -- Now we do cases on whether (connected_component t) is a subset of T₁ or T₂ to show\n  -- that the preimage is a subset of u or v.\n  cases\n    (is_preconnected_iff_subset_of_fully_disjoint_closed is_closed_connected_component).1\n      is_preconnected_connected_component T₁ T₂ hT₁ hT₂ T_decomp T_disjoint\n  · left\n    rw [subset.antisymm_iff] at T₁_u\n    suffices «expr ⁻¹' » f (connected_component t) ⊆ «expr ⁻¹' » f T₁ by\n      exact subset.trans (subset.trans this T₁_u.1) (inter_subset_right _ _)\n    exact preimage_mono h\n  right\n  rw [subset.antisymm_iff] at T₂_v\n  suffices «expr ⁻¹' » f (connected_component t) ⊆ «expr ⁻¹' » f T₂ by\n    exact subset.trans (subset.trans this T₂_v.1) (inter_subset_right _ _)\n  exact preimage_mono h\n#align preimage_connected_component_connected preimage_connected_component_connected\n\n",
 "preimage_connected_component":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem quotient_map.preimage_connected_component [topological_space β] {f : α → β} (hf : quotient_map f)\n    (h_fibers : ∀ y : β, is_connected («expr ⁻¹' » f {y})) (a : α) :\n    «expr ⁻¹' » f (connected_component (f a)) = connected_component a :=\n  ((preimage_connected_component_connected h_fibers (fun _ => hf.is_closed_preimage.symm) _).subset_connected_component\n        mem_connected_component).antisymm\n    (hf.continuous.maps_to_connected_component a)\n#align quotient_map.preimage_connected_component quotient_map.preimage_connected_component\n\n",
 "preconnected_space_of_forall_constant":
 "/-- A `preconnected_space` version of `is_preconnected_of_forall_constant` -/\ntheorem preconnected_space_of_forall_constant (hs : ∀ f : α → bool, continuous f → ∀ x y, f x = f y) :\n    preconnected_space α :=\n  ⟨is_preconnected_of_forall_constant fun f hf x hx y hy => hs f (continuous_iff_continuous_on_univ.mpr hf) x y⟩\n#align preconnected_space_of_forall_constant preconnected_space_of_forall_constant\n\n",
 "preconnected_space_iff_connected_component":
 "theorem preconnected_space_iff_connected_component : preconnected_space α ↔ ∀ x : α, connected_component x = univ :=\n  by\n  constructor\n  · intro h x\n    exact eq_univ_of_univ_subset <| is_preconnected_univ.subset_connected_component (mem_univ x)\n  · intro h\n    cases' isEmpty_or_nonempty α with hα hα\n    ·\n      exact\n        ⟨by\n          rw [univ_eq_empty_iff.mpr hα]\n          exact is_preconnected_empty⟩\n    ·\n      exact\n        ⟨by\n          rw [← h (classical.choice hα)]\n          exact is_preconnected_connected_component⟩\n#align preconnected_space_iff_connected_component preconnected_space_iff_connected_component\n\n",
 "preconnected_space":
 "theorem subtype.preconnected_space {s : set α} (h : is_preconnected s) : preconnected_space s :=\n  {\n    is_preconnected_univ := by\n      rwa [← embedding_subtype_coe.to_inducing.is_preconnected_image, image_univ, Subtype.range_coe] }\n#align subtype.preconnected_space subtype.preconnected_space\n\n",
 "nonempty_inter":
 "-- see Note [lower instance priority]\n-- see Note [lower instance priority]\ntheorem nonempty_inter [preconnected_space α] {s t : set α} :\n    is_open s → is_open t → s ∪ t = univ → s.nonempty → t.nonempty → (s ∩ t).nonempty := by\n  simpa only [univ_inter, univ_subset_iff] using @preconnected_space.is_preconnected_univ α _ _ s t\n#align nonempty_inter nonempty_inter\n\n",
 "nonempty_frontier_iff":
 "theorem nonempty_frontier_iff [preconnected_space α] {s : set α} : (frontier s).nonempty ↔ s.nonempty ∧ s ≠ univ := by\n  simp only [nonempty_iff_ne_empty, ne.def, frontier_eq_empty_iff, not_or]\n#align nonempty_frontier_iff nonempty_frontier_iff\n\n",
 "nonempty":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Yury Kudryashov\n-/\ntheorem is_connected.nonempty {s : set α} (h : is_connected s) : s.nonempty :=\n  h.1\n#align is_connected.nonempty is_connected.nonempty\n\n",
 "mem_connected_component_in":
 "theorem mem_connected_component_in {x : α} {F : set α} (hx : x ∈ F) : x ∈ connected_component_in F x := by\n  simp [connected_component_in_eq_image hx, mem_connected_component, hx]\n#align mem_connected_component_in mem_connected_component_in\n\n",
 "mem_connected_component":
 "theorem mem_connected_component {x : α} : x ∈ connected_component x :=\n  mem_unionₛ_of_mem (mem_singleton x) ⟨is_connected_singleton.is_preconnected, mem_singleton x⟩\n#align mem_connected_component mem_connected_component\n\n",
 "maps_to_connected_component":
 "theorem continuous.maps_to_connected_component [topological_space β] {f : α → β} (h : continuous f) (a : α) :\n    MapsTo f (connected_component a) (connected_component (f a)) :=\n  mapsTo'.2 <| h.image_connected_component_subset a\n#align continuous.maps_to_connected_component continuous.maps_to_connected_component\n\n",
 "locally_connected_space_of_connected_bases":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem locally_connected_space_of_connected_bases {ι : Type _} (b : α → ι → set α) (p : α → ι → Prop)\n    (hbasis : ∀ x, ((nhds) x).has_basis (p x) (b x)) (hconnected : ∀ x i, p x i → is_preconnected (b x i)) :\n    locally_connected_space α := by\n  rw [locally_connected_space_iff_connected_basis]\n  exact fun x =>\n    (hbasis x).to_has_basis (fun i hi => ⟨b x i, ⟨(hbasis x).mem_of_mem hi, hconnected x i hi⟩, subset_rfl⟩) fun s hs =>\n      ⟨(hbasis x).index s hs.1, ⟨(hbasis x).property_index hs.1, (hbasis x).set_index_subset hs.1⟩⟩\n#align locally_connected_space_of_connected_bases locally_connected_space_of_connected_bases\n\n",
 "locally_connected_space_iff_open_connected_subsets":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr ∀ x, (_ : exprProp())]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (V «expr ⊆ » U) -/\ntheorem locally_connected_space_iff_open_connected_subsets :\n    locally_connected_space α ↔ ∀ (x : α), ∀ U ∈ (nhds) x, ∃ (V : _)(_ : V ⊆ U), is_open V ∧ x ∈ V ∧ is_connected V :=\n  by\n  rw [locally_connected_space_iff_open_connected_basis]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr ∀ x, (_ : exprProp())]]\"\n  constructor\n  · intro h U hU\n    rcases h.mem_iff.mp hU with ⟨V, hV, hVU⟩\n    exact ⟨V, hVU, hV⟩\n  ·\n    exact fun h =>\n      ⟨fun U =>\n        ⟨fun hU =>\n          let ⟨V, hVU, hV⟩ := h U hU\n          ⟨V, hV, hVU⟩,\n          fun ⟨V, ⟨hV, hxV, _⟩, hVU⟩ => mem_nhds_iff.mpr ⟨V, hVU, hV, hxV⟩⟩⟩\n#align locally_connected_space_iff_open_connected_subsets locally_connected_space_iff_open_connected_subsets\n\n",
 "locally_connected_space_iff_open_connected_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem locally_connected_space_iff_open_connected_basis :\n    locally_connected_space α ↔ ∀ x, ((nhds) x).has_basis (fun s : set α => is_open s ∧ x ∈ s ∧ is_connected s) id :=\n  ⟨@locally_connected_space.open_connected_basis _ _, locally_connected_space.mk⟩\n#align locally_connected_space_iff_open_connected_basis locally_connected_space_iff_open_connected_basis\n\n",
 "locally_connected_space_iff_connected_subsets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem locally_connected_space_iff_connected_subsets :\n    locally_connected_space α ↔ ∀ (x : α), ∀ U ∈ (nhds) x, ∃ V ∈ (nhds) x, is_preconnected V ∧ V ⊆ U :=\n  by\n  constructor\n  · rw [locally_connected_space_iff_open_connected_subsets]\n    intro h x U hxU\n    rcases h x U hxU with ⟨V, hVU, hV₁, hxV, hV₂⟩\n    exact ⟨V, hV₁.mem_nhds hxV, hV₂.is_preconnected, hVU⟩\n  · rw [locally_connected_space_iff_connected_component_in_open]\n    refine' fun h U hU x hxU => is_open_iff_mem_nhds.mpr fun y hy => _\n    rw [connected_component_in_eq hy]\n    rcases h y U (hU.mem_nhds <| (connected_component_in_subset _ _) hy) with ⟨V, hVy, hV, hVU⟩\n    exact filter.mem_of_superset hVy (hV.subset_connected_component_in (mem_of_mem_nhds hVy) hVU)\n#align locally_connected_space_iff_connected_subsets locally_connected_space_iff_connected_subsets\n\n",
 "locally_connected_space_iff_connected_component_in_open":
 "theorem locally_connected_space_iff_connected_component_in_open :\n    locally_connected_space α ↔ ∀ F : set α, is_open F → ∀ x ∈ F, is_open (connected_component_in F x) :=\n  by\n  constructor\n  · intro h\n    exact fun F hF x _ => hF.connected_component_in\n  · intro h\n    rw [locally_connected_space_iff_open_connected_subsets]\n    refine' fun x U hU =>\n        ⟨connected_component_in (interior U) x, (connected_component_in_subset _ _).trans interior_subset,\n          h _ is_open_interior x _, mem_connected_component_in _, is_connected_connected_component_in_iff.mpr _⟩ <;>\n      exact mem_interior_iff_mem_nhds.mpr hU\n#align locally_connected_space_iff_connected_component_in_open locally_connected_space_iff_connected_component_in_open\n\n",
 "locally_connected_space_iff_connected_basis":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr ∀ x, (_ : exprProp())]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem locally_connected_space_iff_connected_basis :\n    locally_connected_space α ↔ ∀ x, ((nhds) x).has_basis (fun s : set α => s ∈ (nhds) x ∧ is_preconnected s) id :=\n  by\n  rw [locally_connected_space_iff_connected_subsets]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr ∀ x, (_ : exprProp())]]\"\n  exact filter.has_basis_self.symm\n#align locally_connected_space_iff_connected_basis locally_connected_space_iff_connected_basis\n\n",
 "is_totally_separated_singleton":
 "theorem is_totally_separated_singleton {x} : is_totally_separated ({x} : set α) := fun p hp q hq hpq =>\n  (hpq <| (eq_of_mem_singleton hp).symm ▸ (eq_of_mem_singleton hq).symm).elim\n#align is_totally_separated_singleton is_totally_separated_singleton\n\n",
 "is_totally_separated_empty":
 "theorem is_totally_separated_empty : is_totally_separated (∅ : set α) := fun x => false.elim\n#align is_totally_separated_empty is_totally_separated_empty\n\n",
 "is_totally_disconnected_singleton":
 "theorem is_totally_disconnected_singleton {x} : is_totally_disconnected ({x} : set α) := fun _ ht _ =>\n  subsingleton_singleton.anti ht\n#align is_totally_disconnected_singleton is_totally_disconnected_singleton\n\n",
 "is_totally_disconnected_of_totally_disconnected_space":
 "theorem is_totally_disconnected_of_totally_disconnected_space [totally_disconnected_space α] (s : set α) :\n    is_totally_disconnected s := fun t hts ht =>\n  totally_disconnected_space.is_totally_disconnected_univ _ t.subset_univ ht\n#align is_totally_disconnected_of_totally_disconnected_space is_totally_disconnected_of_totally_disconnected_space\n\n",
 "is_totally_disconnected_of_is_totally_separated":
 "theorem is_totally_disconnected_of_is_totally_separated {s : set α} (H : is_totally_separated s) :\n    is_totally_disconnected s := by\n  intro t hts ht x x_in y y_in\n  by_contra h\n  obtain ⟨u : set α, v : set α, hu : is_open u, hv : is_open v, hxu : x ∈ u, hyv : y ∈ v, hs : s ⊆ u ∪ v, huv⟩ :=\n    H x (hts x_in) y (hts y_in) h\n  refine' (ht _ _ hu hv (hts.trans hs) ⟨x, x_in, hxu⟩ ⟨y, y_in, hyv⟩).ne_empty _\n  rw [huv.inter_eq, inter_empty]\n#align is_totally_disconnected_of_is_totally_separated is_totally_disconnected_of_is_totally_separated\n\n",
 "is_totally_disconnected_of_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_totally_disconnected_of_image [topological_space β] {f : α → β} (hf : continuous_on f s) (hf' : injective f)\n    (h : is_totally_disconnected («expr '' » f s)) : is_totally_disconnected s := fun t hts ht x x_in y y_in =>\n  hf' <| h _ (image_subset f hts) (ht.image f <| hf.mono hts) (mem_image_of_mem f x_in) (mem_image_of_mem f y_in)\n#align is_totally_disconnected_of_image is_totally_disconnected_of_image\n\n",
 "is_totally_disconnected_of_clopen_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\n  is some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem is_totally_disconnected_of_clopen_set {X : Type _} [topological_space X]\n    (hX : ∀ {x y : X} (h_diff : x ≠ y), ∃ (U : set X)(h_clopen : is_clopen U), x ∈ U ∧ y ∉ U) :\n    is_totally_disconnected (Set.univ : set X) := by\n  rintro S - hS\n  unfold Set.Subsingleton\n  by_contra' h_contra\n  rcases h_contra with ⟨x, hx, y, hy, hxy⟩\n  obtain ⟨U, h_clopen, hxU, hyU⟩ := hX hxy\n  specialize hS U («expr ᶜ» U) h_clopen.1 h_clopen.compl.1 (fun a ha => em (a ∈ U)) ⟨x, hx, hxU⟩ ⟨y, hy, hyU⟩\n  rw [inter_compl_self, Set.inter_empty] at hS\n  exact Set.not_nonempty_empty hS\n#align is_totally_disconnected_of_clopen_set is_totally_disconnected_of_clopen_set\n\n",
 "is_totally_disconnected_empty":
 "theorem is_totally_disconnected_empty : is_totally_disconnected (∅ : set α) := fun _ ht _ _ x_in _ _ => (ht x_in).elim\n#align is_totally_disconnected_empty is_totally_disconnected_empty\n\n",
 "is_totally_disconnected":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem embedding.is_totally_disconnected [topological_space β] {f : α → β} (hf : embedding f) {s : set α}\n    (h : is_totally_disconnected («expr '' » f s)) : is_totally_disconnected s :=\n  is_totally_disconnected_of_image hf.continuous.continuous_on hf.inj h\n#align embedding.is_totally_disconnected embedding.is_totally_disconnected\n\n",
 "is_preconnected_univ_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_preconnected_univ_pi [∀ i, topological_space (π i)] {s : ∀ i, set (π i)} (hs : ∀ i, is_preconnected (s i)) :\n    is_preconnected (pi univ s) := by\n  rintro u v uo vo hsuv ⟨f, hfs, hfu⟩ ⟨g, hgs, hgv⟩\n  rcases exists_finset_piecewise_mem_of_mem_nhds (uo.mem_nhds hfu) g with ⟨I, hI⟩\n  induction' I using Finset.induction_on with i I hi ihI\n  · refine' ⟨g, hgs, ⟨_, hgv⟩⟩\n    simpa using hI\n  · rw [Finset.piecewise_insert] at hI\n    have := I.piecewise_mem_set_pi hfs hgs\n    refine' (hsuv this).elim ihI fun h => _\n    set S := «expr '' » (update (I.piecewise f g) i) (s i)\n    have hsub : S ⊆ pi univ s := by\n      refine' image_subset_iff.2 fun z hz => _\n      rwa [update_preimage_univ_pi]\n      exact fun j hj => this j trivial\n    have hconn : is_preconnected S := (hs i).image _ (continuous_const.update i continuous_id).continuous_on\n    have hSu : (S ∩ u).nonempty := ⟨_, mem_image_of_mem _ (hfs _ trivial), hI⟩\n    have hSv : (S ∩ v).nonempty := ⟨_, ⟨_, this _ trivial, update_eq_self _ _⟩, h⟩\n    refine' (hconn u v uo vo (hsub.trans hsuv) hSu hSv).mono _\n    exact inter_subset_inter_left _ hsub\n#align is_preconnected_univ_pi is_preconnected_univ_pi\n\n",
 "is_preconnected_singleton":
 "theorem is_preconnected_singleton {x} : is_preconnected ({x} : set α) :=\n  is_connected_singleton.is_preconnected\n#align is_preconnected_singleton is_preconnected_singleton\n\n",
 "is_preconnected_sUnion":
 "/-- A union of a family of preconnected sets with a common point is preconnected as well. -/\ntheorem is_preconnected_sUnion (x : α) (c : set (set α)) (H1 : ∀ s ∈ c, x ∈ s) (H2 : ∀ s ∈ c, is_preconnected s) :\n    is_preconnected (⋃₀ c) := by\n  apply is_preconnected_of_forall x\n  rintro y ⟨s, sc, ys⟩\n  exact ⟨s, subset_sUnion_of_mem sc, H1 s sc, ys, H2 s sc⟩\n#align is_preconnected_sUnion is_preconnected_sUnion\n\n",
 "is_preconnected_range":
 "theorem is_preconnected_range [topological_space β] [preconnected_space α] {f : α → β} (h : continuous f) :\n    is_preconnected (range f) :=\n  @image_univ _ _ f ▸ is_preconnected_univ.image _ h.continuous_on\n#align is_preconnected_range is_preconnected_range\n\n",
 "is_preconnected_of_forall_pair":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x y «expr ∈ » s) -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/-- If any two points of a set are contained in a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem is_preconnected_of_forall_pair {s : set α}\n    (H : ∀ (x) (_ : x ∈ s) (y) (_ : y ∈ s), ∃ (t : _)(_ : t ⊆ s), x ∈ t ∧ y ∈ t ∧ is_preconnected t) :\n    is_preconnected s := by\n  rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)\n  exacts[is_preconnected_empty, is_preconnected_of_forall x fun y => H x hx y]\n#align is_preconnected_of_forall_pair is_preconnected_of_forall_pair\n\n",
 "is_preconnected_of_forall_constant":
 "/-- If every map to `bool` (a discrete two-element space), that is\ncontinuous on a set `s`, is constant on s, then s is preconnected -/\ntheorem is_preconnected_of_forall_constant {s : set α}\n    (hs : ∀ f : α → bool, continuous_on f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : is_preconnected s :=\n  by\n  unfold is_preconnected\n  by_contra'\n  rcases this with ⟨u, v, u_op, v_op, hsuv, ⟨x, x_in_s, x_in_u⟩, ⟨y, y_in_s, y_in_v⟩, H⟩\n  rw [not_nonempty_iff_eq_empty] at H\n  have hy : y ∉ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y ⟨y_in_s, ⟨y_in_u, y_in_v⟩⟩\n  have : continuous_on u.bool_indicator s :=\n    by\n    apply (continuous_on_indicator_iff_clopen _ _).mpr ⟨_, _⟩\n    · exact continuous_subtype_coe.is_open_preimage u u_op\n    · rw [preimage_subtype_coe_eq_compl hsuv H]\n      exact (continuous_subtype_coe.is_open_preimage v v_op).is_closed_compl\n  simpa [(u.mem_iff_bool_indicator _).mp x_in_u, (u.not_mem_iff_bool_indicator _).mp hy] using\n    hs _ this x x_in_s y y_in_s\n#align is_preconnected_of_forall_constant is_preconnected_of_forall_constant\n\n",
 "is_preconnected_of_forall":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/-- If any point of a set is joined to a fixed point by a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem is_preconnected_of_forall {s : set α} (x : α)\n    (H : ∀ y ∈ s, ∃ (t : _)(_ : t ⊆ s), x ∈ t ∧ y ∈ t ∧ is_preconnected t) : is_preconnected s :=\n  by\n  rintro u v hu hv hs ⟨z, zs, zu⟩ ⟨y, ys, yv⟩\n  have xs : x ∈ s := by\n    rcases H y ys with ⟨t, ts, xt, yt, ht⟩\n    exact ts xt\n  wlog xu : x ∈ u := hs xs using u v y z, v u z y\n  rcases H y ys with ⟨t, ts, xt, yt, ht⟩\n  have := ht u v hu hv (subset.trans ts hs) ⟨x, xt, xu⟩ ⟨y, yt, yv⟩\n  exact this.imp fun z hz => ⟨ts hz.1, hz.2⟩\n#align is_preconnected_of_forall is_preconnected_of_forall\n\n",
 "is_preconnected_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem inducing.is_preconnected_image [topological_space β] {s : set α} {f : α → β} (hf : inducing f) :\n    is_preconnected («expr '' » f s) ↔ is_preconnected s :=\n  by\n  refine' ⟨fun h => _, fun h => h.image _ hf.continuous.continuous_on⟩\n  rintro u v hu' hv' huv ⟨x, hxs, hxu⟩ ⟨y, hys, hyv⟩\n  rcases hf.is_open_iff.1 hu' with ⟨u, hu, rfl⟩\n  rcases hf.is_open_iff.1 hv' with ⟨v, hv, rfl⟩\n  replace huv : «expr '' » f s ⊆ u ∪ v; · rwa [image_subset_iff]\n  rcases h u v hu hv huv ⟨f x, mem_image_of_mem _ hxs, hxu⟩ ⟨f y, mem_image_of_mem _ hys, hyv⟩ with\n    ⟨_, ⟨z, hzs, rfl⟩, hzuv⟩\n  exact ⟨z, hzs, hzuv⟩\n#align inducing.is_preconnected_image inducing.is_preconnected_image\n\n",
 "is_preconnected_iff_subset_of_fully_disjoint_closed":
 "/-- A closed set `s` is preconnected if and only if\nfor every cover by two closed sets that are disjoint,\nit is contained in one of the two covering sets. -/\ntheorem is_preconnected_iff_subset_of_fully_disjoint_closed {s : set α} (hs : is_closed s) :\n    is_preconnected s ↔\n      ∀ (u v : set α) (hu : is_closed u) (hv : is_closed v) (hss : s ⊆ u ∪ v) (huv : Disjoint u v), s ⊆ u ∨ s ⊆ v :=\n  by\n  constructor\n  · intro h u v hu hv hss huv\n    apply is_preconnected_iff_subset_of_disjoint_closed.1 h u v hu hv hss\n    rw [huv.inter_eq, inter_empty]\n  intro H\n  rw [is_preconnected_iff_subset_of_disjoint_closed]\n  intro u v hu hv hss huv\n  have H1 := H (u ∩ s) (v ∩ s)\n  rw [subset_inter_iff, subset_inter_iff] at H1\n  simp only [subset.refl, and_true_iff] at H1\n  apply H1 (is_closed.inter hu hs) (is_closed.inter hv hs)\n  · rw [← inter_distrib_right]\n    exact subset_inter hss subset.rfl\n  · rwa [disjoint_iff_inter_eq_empty, ← inter_inter_distrib_right, inter_comm]\n#align is_preconnected_iff_subset_of_fully_disjoint_closed is_preconnected_iff_subset_of_fully_disjoint_closed\n\n",
 "is_preconnected_iff_subset_of_disjoint_closed":
 "/-- A set `s` is preconnected if and only if\nfor every cover by two closed sets that are disjoint on `s`,\nit is contained in one of the two covering sets. -/\ntheorem is_preconnected_iff_subset_of_disjoint_closed :\n    is_preconnected s ↔\n      ∀ (u v : set α) (hu : is_closed u) (hv : is_closed v) (hs : s ⊆ u ∪ v) (huv : s ∩ (u ∩ v) = ∅), s ⊆ u ∨ s ⊆ v :=\n  by\n  constructor <;> intro h\n  · intro u v hu hv hs huv\n    rw [is_preconnected_closed_iff] at h\n    specialize h u v hu hv hs\n    contrapose! huv\n    rw [← nonempty_iff_ne_empty]\n    simp [not_subset] at huv\n    rcases huv with ⟨⟨x, hxs, hxu⟩, ⟨y, hys, hyv⟩⟩\n    have hxv : x ∈ v := or_iff_not_imp_left.mp (hs hxs) hxu\n    have hyu : y ∈ u := or_iff_not_imp_right.mp (hs hys) hyv\n    exact h ⟨y, hys, hyu⟩ ⟨x, hxs, hxv⟩\n  · rw [is_preconnected_closed_iff]\n    intro u v hu hv hs hsu hsv\n    rw [nonempty_iff_ne_empty]\n    intro H\n    specialize h u v hu hv hs H\n    contrapose H\n    apply nonempty.ne_empty\n    cases h\n    · rcases hsv with ⟨x, hxs, hxv⟩\n      exact ⟨x, hxs, ⟨h hxs, hxv⟩⟩\n    · rcases hsu with ⟨x, hxs, hxu⟩\n      exact ⟨x, hxs, ⟨hxu, h hxs⟩⟩\n#align is_preconnected_iff_subset_of_disjoint_closed is_preconnected_iff_subset_of_disjoint_closed\n\n",
 "is_preconnected_iff_subset_of_disjoint":
 "/-- A set `s` is preconnected if and only if\nfor every cover by two open sets that are disjoint on `s`,\nit is contained in one of the two covering sets. -/\ntheorem is_preconnected_iff_subset_of_disjoint {s : set α} :\n    is_preconnected s ↔\n      ∀ (u v : set α) (hu : is_open u) (hv : is_open v) (hs : s ⊆ u ∪ v) (huv : s ∩ (u ∩ v) = ∅), s ⊆ u ∨ s ⊆ v :=\n  by\n  constructor <;> intro h\n  · intro u v hu hv hs huv\n    specialize h u v hu hv hs\n    contrapose! huv\n    rw [← nonempty_iff_ne_empty]\n    simp [not_subset] at huv\n    rcases huv with ⟨⟨x, hxs, hxu⟩, ⟨y, hys, hyv⟩⟩\n    have hxv : x ∈ v := or_iff_not_imp_left.mp (hs hxs) hxu\n    have hyu : y ∈ u := or_iff_not_imp_right.mp (hs hys) hyv\n    exact h ⟨y, hys, hyu⟩ ⟨x, hxs, hxv⟩\n  · intro u v hu hv hs hsu hsv\n    rw [nonempty_iff_ne_empty]\n    intro H\n    specialize h u v hu hv hs H\n    contrapose H\n    apply nonempty.ne_empty\n    cases h\n    · rcases hsv with ⟨x, hxs, hxv⟩\n      exact ⟨x, hxs, ⟨h hxs, hxv⟩⟩\n    · rcases hsu with ⟨x, hxs, hxu⟩\n      exact ⟨x, hxs, ⟨hxu, h hxs⟩⟩\n#align is_preconnected_iff_subset_of_disjoint is_preconnected_iff_subset_of_disjoint\n\n",
 "is_preconnected_iff_preconnected_space":
 "theorem is_preconnected_iff_preconnected_space {s : set α} : is_preconnected s ↔ preconnected_space s :=\n  ⟨subtype.preconnected_space, by\n    intro\n    simpa using is_preconnected_univ.image (coe : s → α) continuous_subtype_coe.continuous_on⟩\n#align is_preconnected_iff_preconnected_space is_preconnected_iff_preconnected_space\n\n",
 "is_preconnected_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem sum.is_preconnected_iff [topological_space β] {s : set (Sum α β)} :\n    is_preconnected s ↔\n      (∃ t, is_preconnected t ∧ s = «expr '' » sum.inl t) ∨ ∃ t, is_preconnected t ∧ s = «expr '' » sum.inr t :=\n  by\n  refine' ⟨fun hs => _, _⟩\n  · obtain rfl | h := s.eq_empty_or_nonempty\n    · exact or.inl ⟨∅, is_preconnected_empty, (Set.image_empty _).symm⟩\n    obtain ⟨t, ht, rfl⟩ | ⟨t, ht, rfl⟩ := sum.is_connected_iff.1 ⟨h, hs⟩\n    · exact or.inl ⟨t, ht.is_preconnected, rfl⟩\n    · exact or.inr ⟨t, ht.is_preconnected, rfl⟩\n  · rintro (⟨t, ht, rfl⟩ | ⟨t, ht, rfl⟩)\n    · exact ht.image _ continuous_inl.continuous_on\n    · exact ht.image _ continuous_inr.continuous_on\n#align sum.is_preconnected_iff sum.is_preconnected_iff\n\n",
 "is_preconnected_empty":
 "theorem is_preconnected_empty : is_preconnected (∅ : set α) :=\n  is_preirreducible_empty.is_preconnected\n#align is_preconnected_empty is_preconnected_empty\n\n",
 "is_preconnected_connected_component_in":
 "theorem is_preconnected_connected_component_in {x : α} {F : set α} : is_preconnected (connected_component_in F x) :=\n  by\n  rw [connected_component_in]; split_ifs\n  · exact embedding_subtype_coe.to_inducing.is_preconnected_image.mpr is_preconnected_connected_component\n  · exact is_preconnected_empty\n#align is_preconnected_connected_component_in is_preconnected_connected_component_in\n\n",
 "is_preconnected_connected_component":
 "theorem is_preconnected_connected_component {x : α} : is_preconnected (connected_component x) :=\n  is_preconnected_sUnion x _ (fun _ => And.right) fun _ => And.left\n#align is_preconnected_connected_component is_preconnected_connected_component\n\n",
 "is_preconnected_closed_iff":
 "theorem is_preconnected_closed_iff {s : set α} :\n    is_preconnected s ↔\n      ∀ t t',\n        is_closed t → is_closed t' → s ⊆ t ∪ t' → (s ∩ t).nonempty → (s ∩ t').nonempty → (s ∩ (t ∩ t')).nonempty :=\n  ⟨by\n    rintro h t t' ht ht' htt' ⟨x, xs, xt⟩ ⟨y, ys, yt'⟩\n    rw [← not_disjoint_iff_nonempty_inter, ← subset_compl_iff_disjoint_right, compl_inter]\n    intro h'\n    have xt' : x ∉ t' := (h' xs).resolve_left (absurd xt)\n    have yt : y ∉ t := (h' ys).resolve_right (absurd yt')\n    have := h _ _ ht.is_open_compl ht'.is_open_compl h' ⟨y, ys, yt⟩ ⟨x, xs, xt'⟩\n    rw [← compl_union] at this\n    exact this.ne_empty htt'.disjoint_compl_right.inter_eq,\n    by\n    rintro h u v hu hv huv ⟨x, xs, xu⟩ ⟨y, ys, yv⟩\n    rw [← not_disjoint_iff_nonempty_inter, ← subset_compl_iff_disjoint_right, compl_inter]\n    intro h'\n    have xv : x ∉ v := (h' xs).elim (absurd xu) id\n    have yu : y ∉ u := (h' ys).elim id (absurd yv)\n    have := h _ _ hu.is_closed_compl hv.is_closed_compl h' ⟨y, ys, yu⟩ ⟨x, xs, xv⟩\n    rw [← compl_union] at this\n    exact this.ne_empty huv.disjoint_compl_right.inter_eq⟩\n#align is_preconnected_closed_iff is_preconnected_closed_iff\n\n",
 "is_preconnected_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_preconnected_Union {ι : Sort _} {s : ι → set α}\n    (h₁ :\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)).nonempty)\n    (h₂ : ∀ i, is_preconnected (s i)) :\n    is_preconnected\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  exists.elim h₁ fun f hf => is_preconnected_sUnion f _ hf (forall_range_iff.2 h₂)\n#align is_preconnected_Union is_preconnected_Union\n\n",
 "is_preconnected":
 "theorem set.subsingleton.is_preconnected {s : set α} (hs : s.subsingleton) : is_preconnected s :=\n  hs.induction_on is_preconnected_empty fun x => is_preconnected_singleton\n#align set.subsingleton.is_preconnected set.subsingleton.is_preconnected\n\n",
 "is_open_connected_component":
 "theorem is_open_connected_component [locally_connected_space α] {x : α} : is_open (connected_component x) :=\n  by\n  rw [← connected_component_in_univ]\n  exact is_open_univ.connected_component_in\n#align is_open_connected_component is_open_connected_component\n\n",
 "is_connected_univ_pi":
 "@[simp]\ntheorem is_connected_univ_pi [∀ i, topological_space (π i)] {s : ∀ i, set (π i)} :\n    is_connected (pi univ s) ↔ ∀ i, is_connected (s i) :=\n  by\n  simp only [is_connected, ← univ_pi_nonempty_iff, forall_and, and_congr_right_iff]\n  refine' fun hne => ⟨fun hc i => _, is_preconnected_univ_pi⟩\n  rw [← eval_image_univ_pi hne]\n  exact hc.image _ (continuous_apply _).continuous_on\n#align is_connected_univ_pi is_connected_univ_pi\n\n",
 "is_connected_univ":
 "-- see Note [lower instance priority]\ntheorem is_connected_univ [connected_space α] : is_connected (univ : set α) :=\n  ⟨univ_nonempty, is_preconnected_univ⟩\n#align is_connected_univ is_connected_univ\n\n",
 "is_connected_singleton":
 "theorem is_connected_singleton {x} : is_connected ({x} : set α) :=\n  is_irreducible_singleton.is_connected\n#align is_connected_singleton is_connected_singleton\n\n",
 "is_connected_range":
 "theorem is_connected_range [topological_space β] [connected_space α] {f : α → β} (h : continuous f) :\n    is_connected (range f) :=\n  ⟨range_nonempty f, is_preconnected_range h⟩\n#align is_connected_range is_connected_range\n\n",
 "is_connected_iff_sUnion_disjoint_open":
 "/-- A set `s` is connected if and only if\nfor every cover by a finite collection of open sets that are pairwise disjoint on `s`,\nit is contained in one of the members of the collection. -/\ntheorem is_connected_iff_sUnion_disjoint_open {s : set α} :\n    is_connected s ↔\n      ∀ (U : Finset (set α)) (H : ∀ u v : set α, u ∈ U → v ∈ U → (s ∩ (u ∩ v)).nonempty → u = v)\n        (hU : ∀ u ∈ U, is_open u) (hs : s ⊆ ⋃₀ ↑U), ∃ u ∈ U, s ⊆ u :=\n  by\n  rw [is_connected, is_preconnected_iff_subset_of_disjoint]\n  constructor <;> intro h\n  · intro U\n    apply Finset.induction_on U\n    · rcases h.left with ⟨⟩\n      suffices s ⊆ ∅ → false by simpa\n      intro\n      solve_by_elim\n    · intro u U hu IH hs hU H\n      rw [Finset.coe_insert, sUnion_insert] at H\n      cases' h.2 u (⋃₀ ↑U) _ _ H _ with hsu hsU\n      · exact ⟨u, Finset.mem_insert_self _ _, hsu⟩\n      · rcases IH _ _ hsU with ⟨v, hvU, hsv⟩\n        · exact ⟨v, Finset.mem_insert_of_mem hvU, hsv⟩\n        · intros\n          apply hs <;> solve_by_elim [Finset.mem_insert_of_mem]\n        · intros\n          solve_by_elim [Finset.mem_insert_of_mem]\n      · solve_by_elim [Finset.mem_insert_self]\n      · apply is_open_sUnion\n        intros\n        solve_by_elim [Finset.mem_insert_of_mem]\n      · apply eq_empty_of_subset_empty\n        rintro x ⟨hxs, hxu, hxU⟩\n        rw [mem_sUnion] at hxU\n        rcases hxU with ⟨v, hvU, hxv⟩\n        rcases hs u v (Finset.mem_insert_self _ _) (Finset.mem_insert_of_mem hvU) _ with rfl\n        · contradiction\n        · exact ⟨x, hxs, hxu, hxv⟩\n  · constructor\n    · rw [nonempty_iff_ne_empty]\n      by_contra hs\n      subst hs\n      simpa using h ∅ _ _ _ <;> simp\n    intro u v hu hv hs hsuv\n    rcases h {u, v} _ _ _ with ⟨t, ht, ht'⟩\n    · rw [Finset.mem_insert, Finset.mem_singleton] at ht\n      rcases ht with (rfl | rfl) <;> tauto\n    · intro t₁ t₂ ht₁ ht₂ hst\n      rw [nonempty_iff_ne_empty] at hst\n      rw [Finset.mem_insert, Finset.mem_singleton] at ht₁ ht₂\n      rcases ht₁ with (rfl | rfl) <;> rcases ht₂ with (rfl | rfl)\n      all_goals first |rfl|contradiction|skip\n      rw [inter_comm t₁] at hst\n      contradiction\n    · intro t\n      rw [Finset.mem_insert, Finset.mem_singleton]\n      rintro (rfl | rfl) <;> assumption\n    · simpa using hs\n#align is_connected_iff_sUnion_disjoint_open is_connected_iff_sUnion_disjoint_open\n\n",
 "is_connected_iff_connected_space":
 "theorem is_connected_iff_connected_space {s : set α} : is_connected s ↔ connected_space s :=\n  ⟨subtype.connected_space, fun h => ⟨nonempty_subtype.mp h.2, is_preconnected_iff_preconnected_space.mpr h.1⟩⟩\n#align is_connected_iff_connected_space is_connected_iff_connected_space\n\n",
 "is_connected_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem sum.is_connected_iff [topological_space β] {s : set (Sum α β)} :\n    is_connected s ↔\n      (∃ t, is_connected t ∧ s = «expr '' » sum.inl t) ∨ ∃ t, is_connected t ∧ s = «expr '' » sum.inr t :=\n  by\n  refine' ⟨fun hs => _, _⟩\n  · let u : set (Sum α β) := range sum.inl\n    let v : set (Sum α β) := range sum.inr\n    have hu : is_open u := is_open_range_inl\n    obtain ⟨x | x, hx⟩ := hs.nonempty\n    · have h : s ⊆ range sum.inl :=\n        is_preconnected.subset_left_of_subset_union is_open_range_inl is_open_range_inr\n          is_compl_range_inl_range_inr.disjoint (by simp) ⟨sum.inl x, hx, x, rfl⟩ hs.2\n      refine' or.inl ⟨«expr ⁻¹' » sum.inl s, _, _⟩\n      · exact hs.preimage_of_open_map sum.inl_injective open_embedding_inl.is_open_map h\n      · exact (Set.image_preimage_eq_of_subset h).symm\n    · have h : s ⊆ range sum.inr :=\n        is_preconnected.subset_right_of_subset_union is_open_range_inl is_open_range_inr\n          is_compl_range_inl_range_inr.disjoint (by simp) ⟨sum.inr x, hx, x, rfl⟩ hs.2\n      refine' or.inr ⟨«expr ⁻¹' » sum.inr s, _, _⟩\n      · exact hs.preimage_of_open_map sum.inr_injective open_embedding_inr.is_open_map h\n      · exact (Set.image_preimage_eq_of_subset h).symm\n  · rintro (⟨t, ht, rfl⟩ | ⟨t, ht, rfl⟩)\n    · exact ht.image _ continuous_inl.continuous_on\n    · exact ht.image _ continuous_inr.continuous_on\n#align sum.is_connected_iff sum.is_connected_iff\n\n",
 "is_connected_connected_component_in_iff":
 "theorem is_connected_connected_component_in_iff {x : α} {F : set α} :\n    is_connected (connected_component_in F x) ↔ x ∈ F := by\n  simp_rw [← connected_component_in_nonempty_iff, is_connected, is_preconnected_connected_component_in, and_true_iff]\n#align is_connected_connected_component_in_iff is_connected_connected_component_in_iff\n\n",
 "is_connected_connected_component":
 "theorem is_connected_connected_component {x : α} : is_connected (connected_component x) :=\n  ⟨⟨x, mem_connected_component⟩, is_preconnected_connected_component⟩\n#align is_connected_connected_component is_connected_connected_component\n\n",
 "is_connected":
 "theorem is_irreducible.is_connected {s : set α} (H : is_irreducible s) : is_connected s :=\n  ⟨H.nonempty, H.is_preirreducible.is_preconnected⟩\n#align is_irreducible.is_connected is_irreducible.is_connected\n\n",
 "is_closed_connected_component":
 "theorem is_closed_connected_component {x : α} : is_closed (connected_component x) :=\n  closure_subset_iff_is_closed.1 <|\n    is_connected_connected_component.closure.subset_connected_component <| subset_closure mem_connected_component\n#align is_closed_connected_component is_closed_connected_component\n\n",
 "is_clopen_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_clopen_iff [preconnected_space α] {s : set α} : is_clopen s ↔ s = ∅ ∨ s = univ :=\n  ⟨fun hs =>\n    by_contradiction fun h =>\n      have h1 : s ≠ ∅ ∧ «expr ᶜ» s ≠ ∅ :=\n        ⟨mt or.inl h, mt (fun h2 => or.inr <| (by rw [← compl_compl s, h2, compl_empty] : s = univ)) h⟩\n      let ⟨_, h2, h3⟩ :=\n        nonempty_inter hs.1 hs.2.is_open_compl (union_compl_self s) (nonempty_iff_ne_empty.2 h1.1)\n          (nonempty_iff_ne_empty.2 h1.2)\n      h3 h2,\n    by rintro (rfl | rfl) <;> [exact is_clopen_empty, exact is_clopen_univ]⟩\n#align is_clopen_iff is_clopen_iff\n\n",
 "is_clopen_connected_component":
 "theorem is_clopen_connected_component [locally_connected_space α] {x : α} : is_clopen (connected_component x) :=\n  ⟨is_open_connected_component, is_closed_connected_component⟩\n#align is_clopen_connected_component is_clopen_connected_component\n\n",
 "irreducible_component_subset_connected_component":
 "theorem irreducible_component_subset_connected_component {x : α} : irreducible_component x ⊆ connected_component x :=\n  is_irreducible_irreducible_component.is_connected.subset_connected_component mem_irreducible_component\n#align irreducible_component_subset_connected_component irreducible_component_subset_connected_component\n\n",
 "image_eq_of_connected_component_eq":
 "theorem continuous.image_eq_of_connected_component_eq (h : continuous f) (a b : α)\n    (hab : connected_component a = connected_component b) : f a = f b :=\n  singleton_eq_singleton_iff.1 <|\n    h.image_connected_component_eq_singleton a ▸ h.image_connected_component_eq_singleton b ▸ hab ▸ rfl\n#align continuous.image_eq_of_connected_component_eq continuous.image_eq_of_connected_component_eq\n\n",
 "image_connected_component_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem continuous.image_connected_component_subset [topological_space β] {f : α → β} (h : continuous f) (a : α) :\n    «expr '' » f (connected_component a) ⊆ connected_component (f a) :=\n  (is_connected_connected_component.image f h.continuous_on).subset_connected_component\n    ((mem_image f (connected_component a) (f a)).2 ⟨a, mem_connected_component, rfl⟩)\n#align continuous.image_connected_component_subset continuous.image_connected_component_subset\n\n",
 "image_connected_component_eq_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image of a connected component in a totally disconnected space is a singleton. -/\n@[simp]\ntheorem continuous.image_connected_component_eq_singleton {β : Type _} [topological_space β]\n    [totally_disconnected_space β] {f : α → β} (h : continuous f) (a : α) :\n    «expr '' » f (connected_component a) = {f a} :=\n  (Set.subsingleton_iff_singleton <| mem_image_of_mem f mem_connected_component).mp\n    (is_preconnected_connected_component.image f h.continuous_on).subsingleton\n#align continuous.image_connected_component_eq_singleton continuous.image_connected_component_eq_singleton\n\n",
 "image_connected_component":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem quotient_map.image_connected_component [topological_space β] {f : α → β} (hf : quotient_map f)\n    (h_fibers : ∀ y : β, is_connected («expr ⁻¹' » f {y})) (a : α) :\n    «expr '' » f (connected_component a) = connected_component (f a) := by\n  rw [← hf.preimage_connected_component h_fibers, image_preimage_eq _ hf.surjective]\n#align quotient_map.image_connected_component quotient_map.image_connected_component\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_connected.image [topological_space β] {s : set α} (H : is_connected s) (f : α → β) (hf : continuous_on f s) :\n    is_connected («expr '' » f s) :=\n  ⟨nonempty_image_iff.mpr H.nonempty, H.is_preconnected.image f hf⟩\n#align is_connected.image is_connected.image\n\n",
 "frontier_eq_empty_iff":
 "theorem frontier_eq_empty_iff [preconnected_space α] {s : set α} : frontier s = ∅ ↔ s = ∅ ∨ s = univ :=\n  is_clopen_iff_frontier_eq_empty.symm.trans is_clopen_iff\n#align frontier_eq_empty_iff frontier_eq_empty_iff\n\n",
 "exists_clopen_of_totally_separated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n-- see Note [lower instance priority]\n-- see Note [lower instance priority]\ntheorem exists_clopen_of_totally_separated {α : Type _} [topological_space α] [totally_separated_space α] {x y : α}\n    (hxy : x ≠ y) : ∃ (U : set α)(hU : is_clopen U), x ∈ U ∧ y ∈ «expr ᶜ» U :=\n  by\n  obtain ⟨U, V, hU, hV, Ux, Vy, f, disj⟩ :=\n    totally_separated_space.is_totally_separated_univ α x (Set.mem_univ x) y (Set.mem_univ y) hxy\n  have clopen_U := is_clopen_inter_of_disjoint_cover_clopen is_clopen_univ f hU hV disj\n  rw [univ_inter _] at clopen_U\n  rw [← Set.subset_compl_iff_disjoint_right, subset_compl_comm] at disj\n  exact ⟨U, clopen_U, Ux, disj Vy⟩\n#align exists_clopen_of_totally_separated exists_clopen_of_totally_separated\n\n",
 "eq_univ":
 "theorem is_clopen.eq_univ [preconnected_space α] {s : set α} (h' : is_clopen s) (h : s.nonempty) : s = univ :=\n  (is_clopen_iff.mp h').resolve_left h.ne_empty\n#align is_clopen.eq_univ is_clopen.eq_univ\n\n",
 "disjoint_or_subset_of_clopen":
 "/-- Preconnected sets are either contained in or disjoint to any given clopen set. -/\ntheorem disjoint_or_subset_of_clopen {s t : set α} (hs : is_preconnected s) (ht : is_clopen t) : Disjoint s t ∨ s ⊆ t :=\n  (disjoint_or_nonempty_inter s t).imp_right <| hs.subset_clopen ht\n#align disjoint_or_subset_of_clopen disjoint_or_subset_of_clopen\n\n",
 "continuous_coe":
 "@[continuity]\ntheorem continuous_coe : continuous (coe : α → connected_components α) :=\n  quotient_map_coe.continuous\n#align continuous_coe continuous_coe\n\n",
 "constant_of_maps_to":
 "/-- Refinement of `is_preconnected.constant` only assuming the map factors through a\ndiscrete subset of the target. -/\ntheorem is_preconnected.constant_of_maps_to [topological_space β] {S : set α} (hS : is_preconnected S) {T : set β}\n    [discrete_topology T] {f : α → β} (hc : continuous_on f S) (hTm : MapsTo f S T) {x y : α} (hx : x ∈ S)\n    (hy : y ∈ S) : f x = f y := by\n  let F : S → T := fun x : S => ⟨f x.val, hTm x.property⟩\n  suffices F ⟨x, hx⟩ = F ⟨y, hy⟩ by\n    rw [← subtype.coe_inj] at this\n    exact this\n  exact\n    (is_preconnected_iff_preconnected_space.mp hS).constant\n      (continuous_induced_rng.mpr <| continuous_on_iff_continuous_restrict.mp hc)\n#align is_preconnected.constant_of_maps_to is_preconnected.constant_of_maps_to\n\n",
 "constant":
 "/-- A `preconnected_space` version of `is_preconnected.constant` -/\ntheorem preconnected_space.constant {Y : Type _} [topological_space Y] [discrete_topology Y] (hp : preconnected_space α)\n    {f : α → Y} (hf : continuous f) {x y : α} : f x = f y :=\n  is_preconnected.constant hp.is_preconnected_univ (continuous.continuous_on hf) trivial trivial\n#align preconnected_space.constant preconnected_space.constant\n\n",
 "connected_space_iff_connected_component":
 "theorem connected_space_iff_connected_component : connected_space α ↔ ∃ x : α, connected_component x = univ :=\n  by\n  constructor\n  · rintro ⟨⟨x⟩⟩\n    exact ⟨x, eq_univ_of_univ_subset <| is_preconnected_univ.subset_connected_component (mem_univ x)⟩\n  · rintro ⟨x, h⟩\n    haveI : preconnected_space α :=\n      ⟨by\n        rw [← h]\n        exact is_preconnected_connected_component⟩\n    exact ⟨⟨x⟩⟩\n#align connected_space_iff_connected_component connected_space_iff_connected_component\n\n",
 "connected_space":
 "theorem subtype.connected_space {s : set α} (h : is_connected s) : connected_space s :=\n  { to_preconnected_space := subtype.preconnected_space h.is_preconnected\n    to_nonempty := h.nonempty.to_subtype }\n#align subtype.connected_space subtype.connected_space\n\n",
 "connected_components_preimage_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- The preimage of a singleton in `connected_components` is the connected component\nof an element in the equivalence class. -/\ntheorem connected_components_preimage_singleton {x : α} :\n    «expr ⁻¹' » coe ({x} : set (connected_components α)) = connected_component x :=\n  by\n  ext y\n  simp [connected_components.coe_eq_coe']\n#align connected_components_preimage_singleton connected_components_preimage_singleton\n\n",
 "connected_components_preimage_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- The preimage of the image of a set under the quotient map to `connected_components α`\nis the union of the connected components of the elements in it. -/\ntheorem connected_components_preimage_image (U : set α) :\n    «expr ⁻¹' » coe («expr '' » coe U : set (connected_components α)) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (connected_component x) :=\n  by simp only [connected_components_preimage_singleton, preimage_Union₂, image_eq_Union]\n#align connected_components_preimage_image connected_components_preimage_image\n\n",
 "connected_components_map_continuous":
 "theorem continuous.connected_components_map_continuous {β : Type _} [topological_space β] {f : α → β}\n    (h : continuous f) : continuous h.connected_components_map :=\n  continuous.connected_components_lift_continuous (continuous_quotient_mk.comp h)\n#align continuous.connected_components_map_continuous continuous.connected_components_map_continuous\n\n",
 "connected_components_lift_unique'":
 "theorem connected_components_lift_unique' {β : Sort _} {g₁ g₂ : connected_components α → β}\n    (hg : g₁ ∘ (coe : α → connected_components α) = g₂ ∘ coe) : g₁ = g₂ :=\n  connected_components.surjective_coe.injective_comp_right hg\n#align connected_components_lift_unique' connected_components_lift_unique'\n\n",
 "connected_components_lift_unique":
 "theorem continuous.connected_components_lift_unique (h : continuous f) (g : connected_components α → β)\n    (hg : g ∘ coe = f) : g = h.connected_components_lift :=\n  connected_components_lift_unique' <| hg.trans h.connected_components_lift_comp_coe.symm\n#align continuous.connected_components_lift_unique continuous.connected_components_lift_unique\n\n",
 "connected_components_lift_continuous":
 "@[continuity]\ntheorem continuous.connected_components_lift_continuous (h : continuous f) : continuous h.connected_components_lift :=\n  h.quotient_lift_on' h.image_eq_of_connected_component_eq\n#align continuous.connected_components_lift_continuous continuous.connected_components_lift_continuous\n\n",
 "connected_components_lift_comp_coe":
 "@[simp]\ntheorem continuous.connected_components_lift_comp_coe (h : continuous f) : h.connected_components_lift ∘ coe = f :=\n  rfl\n#align continuous.connected_components_lift_comp_coe continuous.connected_components_lift_comp_coe\n\n",
 "connected_components_lift_apply_coe":
 "@[simp]\ntheorem continuous.connected_components_lift_apply_coe (h : continuous f) (x : α) :\n    h.connected_components_lift x = f x :=\n  rfl\n#align continuous.connected_components_lift_apply_coe continuous.connected_components_lift_apply_coe\n\n",
 "connected_component_subset_Inter_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- The connected component of a point is always a subset of the intersection of all its clopen\nneighbourhoods. -/\ntheorem connected_component_subset_Inter_clopen {x : α} :\n    connected_component x ⊆\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" Z :=\n  subset_Inter fun Z => Z.2.1.connected_component_subset Z.2.2\n#align connected_component_subset_Inter_clopen connected_component_subset_Inter_clopen\n\n",
 "connected_component_subset":
 "theorem is_clopen.connected_component_subset {x} (hs : is_clopen s) (hx : x ∈ s) : connected_component x ⊆ s :=\n  is_preconnected_connected_component.subset_clopen hs ⟨x, mem_connected_component, hx⟩\n#align is_clopen.connected_component_subset is_clopen.connected_component_subset\n\n",
 "connected_component_nonempty":
 "theorem connected_component_nonempty {x : α} : (connected_component x).nonempty :=\n  ⟨x, mem_connected_component⟩\n#align connected_component_nonempty connected_component_nonempty\n\n",
 "connected_component_in_univ":
 "theorem connected_component_in_univ (x : α) : connected_component_in univ x = connected_component x :=\n  subset_antisymm\n    (is_preconnected_connected_component_in.subset_connected_component <| mem_connected_component_in trivial)\n    (is_preconnected_connected_component.subset_connected_component_in mem_connected_component <| subset_univ _)\n#align connected_component_in_univ connected_component_in_univ\n\n",
 "connected_component_in_subset":
 "theorem connected_component_in_subset (F : set α) (x : α) : connected_component_in F x ⊆ F :=\n  by\n  rw [connected_component_in]\n  split_ifs <;> simp\n#align connected_component_in_subset connected_component_in_subset\n\n",
 "connected_component_in_nonempty_iff":
 "theorem connected_component_in_nonempty_iff {x : α} {F : set α} : (connected_component_in F x).nonempty ↔ x ∈ F :=\n  by\n  rw [connected_component_in]\n  split_ifs <;> simp [connected_component_nonempty, h]\n#align connected_component_in_nonempty_iff connected_component_in_nonempty_iff\n\n",
 "connected_component_in_mono":
 "@[mono]\ntheorem connected_component_in_mono (x : α) {F G : set α} (h : F ⊆ G) :\n    connected_component_in F x ⊆ connected_component_in G x :=\n  by\n  by_cases hx : x ∈ F\n  · rw [connected_component_in_eq_image hx, connected_component_in_eq_image (h hx), ←\n      show (coe : G → α) ∘ inclusion h = coe by ext <;> rfl, image_comp]\n    exact image_subset coe ((continuous_inclusion h).image_connected_component_subset ⟨x, hx⟩)\n  · rw [connected_component_in_eq_empty hx]\n    exact Set.empty_subset _\n#align connected_component_in_mono connected_component_in_mono\n\n",
 "connected_component_in_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem connected_component_in_mem_nhds [locally_connected_space α] {F : set α} {x : α} (h : F ∈ (nhds) x) :\n    connected_component_in F x ∈ (nhds) x :=\n  by\n  rw [(locally_connected_space.open_connected_basis x).mem_iff] at h\n  rcases h with ⟨s, ⟨h1s, hxs, h2s⟩, hsF⟩\n  exact mem_nhds_iff.mpr ⟨s, h2s.is_preconnected.subset_connected_component_in hxs hsF, h1s, hxs⟩\n#align connected_component_in_mem_nhds connected_component_in_mem_nhds\n\n",
 "connected_component_in_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem connected_component_in_eq_image {F : set α} {x : α} (h : x ∈ F) :\n    connected_component_in F x = «expr '' » coe (connected_component (⟨x, h⟩ : F)) :=\n  dif_pos h\n#align connected_component_in_eq_image connected_component_in_eq_image\n\n",
 "connected_component_in_eq_empty":
 "theorem connected_component_in_eq_empty {F : set α} {x : α} (h : x ∉ F) : connected_component_in F x = ∅ :=\n  dif_neg h\n#align connected_component_in_eq_empty connected_component_in_eq_empty\n\n",
 "connected_component_in_eq":
 "theorem connected_component_in_eq {x y : α} {F : set α} (h : y ∈ connected_component_in F x) :\n    connected_component_in F x = connected_component_in F y :=\n  by\n  have hx : x ∈ F := connected_component_in_nonempty_iff.mp ⟨y, h⟩\n  simp_rw [connected_component_in_eq_image hx] at h⊢\n  obtain ⟨⟨y, hy⟩, h2y, rfl⟩ := h\n  simp_rw [subtype.coe_mk, connected_component_in_eq_image hy, connected_component_eq h2y]\n#align connected_component_in_eq connected_component_in_eq\n\n",
 "connected_component_in":
 "theorem is_open.connected_component_in [locally_connected_space α] {F : set α} {x : α} (hF : is_open F) :\n    is_open (connected_component_in F x) := by\n  rw [is_open_iff_mem_nhds]\n  intro y hy\n  rw [connected_component_in_eq hy]\n  exact connected_component_in_mem_nhds (is_open_iff_mem_nhds.mp hF y <| connected_component_in_subset F x hy)\n#align is_open.connected_component_in is_open.connected_component_in\n\n",
 "connected_component_eq_univ":
 "@[simp]\ntheorem preconnected_space.connected_component_eq_univ {X : Type _} [topological_space X] [h : preconnected_space X]\n    (x : X) : connected_component x = univ :=\n  preconnected_space_iff_connected_component.mp h x\n#align preconnected_space.connected_component_eq_univ preconnected_space.connected_component_eq_univ\n\n",
 "connected_component_eq":
 "theorem connected_component_eq {x y : α} (h : y ∈ connected_component x) :\n    connected_component x = connected_component y :=\n  eq_of_subset_of_subset (is_connected_connected_component.subset_connected_component h)\n    (is_connected_connected_component.subset_connected_component\n      (Set.mem_of_mem_of_subset mem_connected_component\n        (is_connected_connected_component.subset_connected_component h)))\n#align connected_component_eq connected_component_eq\n\n",
 "connected_component_disjoint":
 "theorem connected_component_disjoint {x y : α} (h : connected_component x ≠ connected_component y) :\n    Disjoint (connected_component x) (connected_component y) :=\n  Set.disjoint_left.2 fun a h1 h2 => h ((connected_component_eq h1).trans (connected_component_eq h2).symm)\n#align connected_component_disjoint connected_component_disjoint\n\n",
 "coe_ne_coe":
 "theorem coe_ne_coe {x y : α} : (x : connected_components α) ≠ y ↔ connected_component x ≠ connected_component y :=\n  not_congr coe_eq_coe\n#align coe_ne_coe coe_ne_coe\n\n",
 "coe_eq_coe'":
 "theorem coe_eq_coe' {x y : α} : (x : connected_components α) = y ↔ x ∈ connected_component y :=\n  coe_eq_coe.trans ⟨fun h => h ▸ mem_connected_component, fun h => (connected_component_eq h).symm⟩\n#align coe_eq_coe' coe_eq_coe'\n\n",
 "coe_eq_coe":
 "@[simp]\ntheorem coe_eq_coe {x y : α} : (x : connected_components α) = y ↔ connected_component x = connected_component y :=\n  quotient.eq'\n#align coe_eq_coe coe_eq_coe\n\n",
 "closure":
 "theorem is_connected.closure {s : set α} (H : is_connected s) : is_connected (closure s) :=\n  is_connected.subset_closure H subset_closure <| subset.refl <| closure s\n#align is_connected.closure is_connected.closure\n\n",
 "bUnion_of_refl_trans_gen":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (i j «expr ∈ » t) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- The bUnion of a family of preconnected sets is preconnected if the graph determined by\nwhether two sets intersect is preconnected. -/\ntheorem is_connected.bUnion_of_refl_trans_gen {ι : Type _} {t : set ι} {s : ι → set α} (ht : t.nonempty)\n    (H : ∀ i ∈ t, is_connected (s i))\n    (K : ∀ (i) (_ : i ∈ t) (j) (_ : j ∈ t), refl_trans_gen (fun i j : ι => (s i ∩ s j).nonempty ∧ i ∈ t) i j) :\n    is_connected\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) :=\n  ⟨nonempty_bunionᵢ.2 <| ⟨ht.some, ht.some_mem, (H _ ht.some_mem).nonempty⟩,\n    is_preconnected.bUnion_of_refl_trans_gen (fun i hi => (H i hi).is_preconnected) K⟩\n#align is_connected.bUnion_of_refl_trans_gen is_connected.bUnion_of_refl_trans_gen\n\n",
 "bUnion_of_chain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- The Union of connected sets indexed by a subset of a type with an archimedean successor\n  (like `ℕ` or `ℤ`) such that any two neighboring sets meet is preconnected. -/\ntheorem is_connected.bUnion_of_chain {s : β → set α} {t : set β} (hnt : t.nonempty) (ht : OrdConnected t)\n    (H : ∀ n ∈ t, is_connected (s n)) (K : ∀ n : β, n ∈ t → succ n ∈ t → (s n ∩ s (succ n)).nonempty) :\n    is_connected\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) :=\n  ⟨nonempty_bunionᵢ.2 <| ⟨hnt.some, hnt.some_mem, (H _ hnt.some_mem).nonempty⟩,\n    is_preconnected.bUnion_of_chain ht (fun i hi => (H i hi).is_preconnected) K⟩\n#align is_connected.bUnion_of_chain is_connected.bUnion_of_chain\n\n",
 "bUnion_connected_component_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A clopen set is the union of its connected components. -/\ntheorem is_clopen.bUnion_connected_component_eq {Z : set α} (h : is_clopen Z) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (connected_component x) =\n      Z :=\n  Subset.antisymm (Union₂_subset fun x => h.connected_component_subset) fun x hx =>\n    mem_unionᵢ₂_of_mem hx mem_connected_component\n#align is_clopen.bUnion_connected_component_eq is_clopen.bUnion_connected_component_eq\n\n",
 "Union_of_refl_trans_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_connected.Union_of_refl_trans_gen {ι : Type _} [nonempty ι] {s : ι → set α} (H : ∀ i, is_connected (s i))\n    (K : ∀ i j, refl_trans_gen (fun i j : ι => (s i ∩ s j).nonempty) i j) :\n    is_connected\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) :=\n  ⟨nonempty_unionᵢ.2 <| nonempty.elim ‹_› fun i : ι => ⟨i, (H _).nonempty⟩,\n    is_preconnected.Union_of_refl_trans_gen (fun i => (H i).is_preconnected) K⟩\n#align is_connected.Union_of_refl_trans_gen is_connected.Union_of_refl_trans_gen\n\n",
 "Union_of_chain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- The Union of connected sets indexed by a type with an archimedean successor (like `ℕ` or `ℤ`)\n  such that any two neighboring sets meet is connected. -/\ntheorem is_connected.Union_of_chain [nonempty β] {s : β → set α} (H : ∀ n, is_connected (s n))\n    (K : ∀ n, (s n ∩ s (succ n)).nonempty) :\n    is_connected\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n)) :=\n  is_connected.Union_of_refl_trans_gen H fun i j =>\n    reflTransGen_of_succ _ (fun i _ => K i) fun i _ =>\n      by\n      rw [inter_comm]\n      exact K i\n#align is_connected.Union_of_chain is_connected.Union_of_chain\n\n"}