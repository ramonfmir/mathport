{"subset_cl":
 "private theorem subset_cl {X : Compactum} (A : Set X) : A ⊆ cl A := fun a ha => ⟨X.incl a, ha, by simp⟩\n#align subset_cl subset_cl\n\n",
 "str_incl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprβ -/\n/-\nCopyright (c) 2020 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Adam Topaz\n-/\n-- Basic instances\n@[simp]\ntheorem str_incl (X : Compactum) (x : X) : X.str (X.incl x) = x :=\n  by\n  change («expr ≫ » ((exprβ).η.app _) X.a) _ = _\n  rw [monad.algebra.unit]\n  rfl\n#align str_incl str_incl\n\n",
 "str_hom_commute":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem str_hom_commute (X Y : Compactum) (f : «expr ⟶ » X Y) (xs : Ultrafilter X) : f (X.str xs) = Y.str (map f xs) :=\n  by\n  change («expr ≫ » X.a f.f) _ = _\n  rw [← f.h]\n  rfl\n#align str_hom_commute str_hom_commute\n\n",
 "str_eq_of_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (S1 S2 «expr ∈ » T0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem str_eq_of_le_nhds {X : Compactum} (F : Ultrafilter X) (x : X) : ↑F ≤ (nhds) x → X.str F = x :=\n  by\n  -- Notation to be used in this proof.\n  let fsu := Finset (Set (Ultrafilter X))\n  let ssu := Set (Set (Ultrafilter X))\n  let ι : fsu → ssu := coe\n  let T0 : ssu := { S | ∃ A ∈ F, S = basic A }\n  let AA := «expr ⁻¹' » X.str {x}\n  let T1 := insert AA T0\n  let T2 := finite_inter_closure T1\n  intro cond\n  -- If F contains a closed set A, then x is contained in A.\n  have claim1 : ∀ A : Set X, IsClosed A → A ∈ F → x ∈ A :=\n    by\n    intro A hA h\n    by_contra H\n    rw [le_nhds_iff] at cond\n    specialize cond («expr ᶜ» A) H hA.is_open_compl\n    rw [Ultrafilter.mem_coe, Ultrafilter.compl_mem_iff_not_mem] at cond\n    contradiction\n  -- If A ∈ F, then x ∈ cl A.\n  have claim2 : ∀ A : Set X, A ∈ F → x ∈ cl A := by\n    intro A hA\n    exact claim1 (cl A) (is_closed_cl A) (mem_of_superset hA (subset_cl A))\n  -- T0 is closed under intersections.\n  have claim3 : ∀ (S1) (_ : S1 ∈ T0) (S2) (_ : S2 ∈ T0), S1 ∩ S2 ∈ T0 :=\n    by\n    rintro S1 ⟨S1, hS1, rfl⟩ S2 ⟨S2, hS2, rfl⟩\n    exact ⟨S1 ∩ S2, inter_mem hS1 hS2, by simp [basic_inter]⟩\n  -- For every S ∈ T0, the intersection AA ∩ S is nonempty.\n  have claim4 : ∀ S ∈ T0, (AA ∩ S).nonempty := by\n    rintro S ⟨S, hS, rfl⟩\n    rcases claim2 _ hS with ⟨G, hG, hG2⟩\n    exact ⟨G, hG2, hG⟩\n  -- Every element of T0 is nonempty.\n  have claim5 : ∀ S ∈ T0, Set.Nonempty S := by\n    rintro S ⟨S, hS, rfl⟩\n    exact ⟨F, hS⟩\n  -- Every element of T2 is nonempty.\n  have claim6 : ∀ S ∈ T2, Set.Nonempty S :=\n    by\n    suffices ∀ S ∈ T2, S ∈ T0 ∨ ∃ Q ∈ T0, S = AA ∩ Q by\n      intro S hS\n      cases' this _ hS with h h\n      · exact claim5 S h\n      · rcases h with ⟨Q, hQ, rfl⟩\n        exact claim4 Q hQ\n    intro S hS\n    apply finite_inter_closure_insert\n    · constructor\n      · use Set.univ\n        refine' ⟨filter.univ_sets _, _⟩\n        ext\n        refine' ⟨_, by tauto⟩\n        · intro\n          apply filter.univ_sets\n      · exact claim3\n    · exact hS\n  -- It suffices to show that the intersection of any finite subset of T1 is nonempty.\n  suffices ∀ F : fsu, ↑F ⊆ T1 → («expr⋂₀ » (ι F)).nonempty\n    by\n    obtain ⟨G, h1⟩ := Ultrafilter.exists_ultrafilter_of_finite_inter_nonempty _ this\n    have c1 : X.join G = F := Ultrafilter.coe_le_coe.1 fun P hP => h1 (or.inr ⟨P, hP, rfl⟩)\n    have c2 : G.map X.str = X.incl x :=\n      by\n      refine' Ultrafilter.coe_le_coe.1 fun P hP => _\n      apply mem_of_superset (h1 (or.inl rfl))\n      rintro x ⟨rfl⟩\n      exact hP\n    simp [← c1, c2]\n  -- Finish...\n  intro T hT\n  refine' claim6 _ (finite_inter_mem (finite_inter_closure_has_finite_inter _) _ _)\n  intro t ht\n  exact finite_inter_closure.basic (@hT t ht)\n#align str_eq_of_le_nhds str_eq_of_le_nhds\n\n",
 "le_nhds_of_str_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem le_nhds_of_str_eq {X : Compactum} (F : Ultrafilter X) (x : X) : X.str F = x → ↑F ≤ (nhds) x := fun h =>\n  le_nhds_iff.mpr fun s hx hs => hs _ <| by rwa [h]\n#align le_nhds_of_str_eq le_nhds_of_str_eq\n\n",
 "join_distrib":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprβ -/\n@[simp]\ntheorem join_distrib (X : Compactum) (uux : Ultrafilter (Ultrafilter X)) : X.str (X.join uux) = X.str (map X.str uux) :=\n  by\n  change («expr ≫ » ((exprβ).μ.app _) X.a) _ = _\n  rw [monad.algebra.assoc]\n  rfl\n#align join_distrib join_distrib\n\n",
 "is_closed_iff":
 "theorem is_closed_iff {X : Compactum} (S : Set X) : IsClosed S ↔ ∀ F : Ultrafilter X, S ∈ F → X.str F ∈ S :=\n  by\n  rw [← isOpen_compl_iff]\n  constructor\n  · intro cond F h\n    by_contra c\n    specialize cond F c\n    rw [compl_mem_iff_not_mem] at cond\n    contradiction\n  · intro h1 F h2\n    specialize h1 F\n    cases F.mem_or_compl_mem S\n    exacts[absurd (h1 h) h2, h]\n#align is_closed_iff is_closed_iff\n\n",
 "is_closed_cl":
 "theorem is_closed_cl {X : Compactum} (A : Set X) : IsClosed (cl A) :=\n  by\n  rw [is_closed_iff]\n  intro F hF\n  exact cl_cl _ ⟨F, hF, rfl⟩\n#align is_closed_cl is_closed_cl\n\n",
 "faithful":
 "/-- The functor Compactum_to_CompHaus is faithful. -/\ntheorem faithful : Faithful Compactum_to_CompHaus :=\n  { }\n#align faithful faithful\n\n",
 "ess_surj":
 "/-- The functor Compactum_to_CompHaus is essentially surjective. -/\ntheorem ess_surj : EssSurj Compactum_to_CompHaus :=\n  { mem_ess_image := fun X => ⟨Compactum.of_topological_space X, ⟨iso_of_topological_space⟩⟩ }\n#align ess_surj ess_surj\n\n",
 "continuous_of_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Any morphism of compacta is continuous. -/\ntheorem continuous_of_hom {X Y : Compactum} (f : «expr ⟶ » X Y) : Continuous f :=\n  by\n  rw [continuous_iff_ultrafilter]\n  intro x _ h\n  rw [tendsto, ← coe_map]\n  apply le_nhds_of_str_eq\n  rw [← str_hom_commute, str_eq_of_le_nhds _ x h]\n#align continuous_of_hom continuous_of_hom\n\n",
 "cl_eq_closure":
 "theorem cl_eq_closure {X : Compactum} (A : Set X) : cl A = closure A :=\n  by\n  ext\n  rw [mem_closure_iff_ultrafilter]\n  constructor\n  · rintro ⟨F, h1, h2⟩\n    exact ⟨F, h1, le_nhds_of_str_eq _ _ h2⟩\n  · rintro ⟨F, h1, h2⟩\n    exact ⟨F, h1, str_eq_of_le_nhds _ _ h2⟩\n#align cl_eq_closure cl_eq_closure\n\n",
 "cl_cl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (B C «expr ∈ » C0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\nprivate theorem cl_cl {X : Compactum} (A : Set X) : cl (cl A) ⊆ cl A :=\n  by\n  rintro _ ⟨F, hF, rfl⟩\n  -- Notation to be used in this proof.\n  let fsu := Finset (Set (Ultrafilter X))\n  let ssu := Set (Set (Ultrafilter X))\n  let ι : fsu → ssu := coe\n  let C0 : ssu := { Z | ∃ B ∈ F, «expr ⁻¹' » X.str B = Z }\n  let AA := { G : Ultrafilter X | A ∈ G }\n  let C1 := insert AA C0\n  let C2 := finite_inter_closure C1\n  -- C0 is closed under intersections.\n  have claim1 : ∀ (B) (_ : B ∈ C0) (C) (_ : C ∈ C0), B ∩ C ∈ C0 :=\n    by\n    rintro B ⟨Q, hQ, rfl⟩ C ⟨R, hR, rfl⟩\n    use Q ∩ R\n    simp only [and_true_iff, eq_self_iff_true, Set.preimage_inter, subtype.val_eq_coe]\n    exact inter_sets _ hQ hR\n  -- All sets in C0 are nonempty.\n  have claim2 : ∀ B ∈ C0, Set.Nonempty B := by\n    rintro B ⟨Q, hQ, rfl⟩\n    obtain ⟨q⟩ := Filter.nonempty_of_mem hQ\n    use X.incl q\n    simpa\n  -- The intersection of AA with every set in C0 is nonempty.\n  have claim3 : ∀ B ∈ C0, (AA ∩ B).nonempty := by\n    rintro B ⟨Q, hQ, rfl⟩\n    have : (Q ∩ cl A).nonempty := Filter.nonempty_of_mem (inter_mem hQ hF)\n    rcases this with ⟨q, hq1, P, hq2, hq3⟩\n    refine' ⟨P, hq2, _⟩\n    rw [← hq3] at hq1\n    simpa\n  -- Suffices to show that the intersection of any finite subcollection of C1 is nonempty.\n  suffices ∀ T : fsu, ι T ⊆ C1 → («expr⋂₀ » (ι T)).nonempty\n    by\n    obtain ⟨G, h1⟩ := exists_ultrafilter_of_finite_inter_nonempty _ this\n    use X.join G\n    have : G.map X.str = F := Ultrafilter.coe_le_coe.1 fun S hS => h1 (or.inr ⟨S, hS, rfl⟩)\n    rw [join_distrib, this]\n    exact ⟨h1 (or.inl rfl), rfl⟩\n  -- C2 is closed under finite intersections (by construction!).\n  have claim4 := finite_inter_closure_has_finite_inter C1\n  -- C0 is closed under finite intersections by claim1.\n  have claim5 : FiniteInter C0 := ⟨⟨_, univ_mem, Set.preimage_univ⟩, claim1⟩\n  -- Every element of C2 is nonempty.\n  have claim6 : ∀ P ∈ C2, (P : Set (Ultrafilter X)).nonempty :=\n    by\n    suffices ∀ P ∈ C2, P ∈ C0 ∨ ∃ Q ∈ C0, P = AA ∩ Q by\n      intro P hP\n      cases this P hP\n      · exact claim2 _ h\n      · rcases h with ⟨Q, hQ, rfl⟩\n        exact claim3 _ hQ\n    intro P hP\n    exact claim5.finite_inter_closure_insert _ hP\n  intro T hT\n  -- Suffices to show that the intersection of the T's is contained in C2.\n  suffices «expr⋂₀ » (ι T) ∈ C2 by exact claim6 _ this\n  -- Finish\n  apply claim4.finite_inter_mem\n  intro t ht\n  exact finite_inter_closure.basic (@hT t ht)\n#align cl_cl cl_cl\n\n",
 "basic_inter":
 "private theorem basic_inter {X : Compactum} (A B : Set X) : basic (A ∩ B) = basic A ∩ basic B :=\n  by\n  ext G\n  constructor\n  · intro hG\n    constructor <;> filter_upwards [hG]with _\n    exacts[And.left, And.right]\n  · rintro ⟨h1, h2⟩\n    exact inter_mem h1 h2\n#align basic_inter basic_inter\n\n",
 "Lim_eq_str":
 "-- All the hard work above boils down to this t2_space instance.\n/-- The structure map of a compactum actually computes limits. -/\ntheorem Lim_eq_str {X : Compactum} (F : Ultrafilter X) : F.Lim = X.str F :=\n  by\n  rw [Ultrafilter.lim_eq_iff_le_nhds, le_nhds_iff]\n  tauto\n#align Lim_eq_str Lim_eq_str\n\n"}