{"mono_iff_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mono_iff_injective {X Y : CompHaus.{u}} (f : «expr ⟶ » X Y) : Mono f ↔ function.injective f :=\n  by\n  constructor\n  · intro hf x₁ x₂ h\n    let g₁ : «expr ⟶ » (of PUnit) X := ⟨fun _ => x₁, continuous_of_discrete_topology⟩\n    let g₂ : «expr ⟶ » (of PUnit) X := ⟨fun _ => x₂, continuous_of_discrete_topology⟩\n    have : «expr ≫ » g₁ f = «expr ≫ » g₂ f := by\n      ext\n      exact h\n    rw [cancel_mono] at this\n    apply_fun fun e => e PUnit.unit  at this\n    exact this\n  · rw [← category_theory.mono_iff_injective]\n    apply (forget CompHaus).mono_of_mono_map\n#align mono_iff_injective mono_iff_injective\n\n",
 "is_iso_of_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem is_iso_of_bijective {X Y : CompHaus.{u}} (f : «expr ⟶ » X Y) (bij : function.bijective f) : IsIso f :=\n  by\n  let E := Equiv.ofBijective _ bij\n  have hE : continuous E.symm := by\n    rw [continuous_iff_is_closed]\n    intro S hS\n    rw [← E.image_eq_preimage]\n    exact is_closed_map f S hS\n  refine' ⟨⟨⟨E.symm, hE⟩, _, _⟩⟩\n  · ext x\n    apply E.symm_apply_apply\n  · ext x\n    apply E.apply_symm_apply\n#align is_iso_of_bijective is_iso_of_bijective\n\n",
 "is_closed_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem is_closed_map {X Y : CompHaus.{u}} (f : «expr ⟶ » X Y) : is_closed_map f := fun C hC =>\n  (hC.is_compact.image f.continuous).is_closed\n#align is_closed_map is_closed_map\n\n",
 "epi_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem epi_iff_surjective {X Y : CompHaus.{u}} (f : «expr ⟶ » X Y) : Epi f ↔ function.surjective f :=\n  by\n  constructor\n  · contrapose!\n    rintro ⟨y, hy⟩ hf\n    let C := Set.range f\n    have hC : is_closed C := (is_compact_range f.continuous).is_closed\n    let D := {y}\n    have hD : is_closed D := is_closed_singleton\n    have hCD : Disjoint C D := by\n      rw [Set.disjoint_singleton_right]\n      rintro ⟨y', hy'⟩\n      exact hy y' hy'\n    haveI : normal_space («expr↥ » Y.to_Top) := normal_of_compact_t2\n    obtain ⟨φ, hφ0, hφ1, hφ01⟩ := exists_continuous_zero_one_of_closed hC hD hCD\n    haveI : compact_space (ULift.{u} <| Set.Icc (0 : exprℝ) 1) := homeomorph.ulift.symm.compact_space\n    haveI : t2_space (ULift.{u} <| Set.Icc (0 : exprℝ) 1) := homeomorph.ulift.symm.t2_space\n    let Z := of (ULift.{u} <| Set.Icc (0 : exprℝ) 1)\n    let g : «expr ⟶ » Y Z :=\n      ⟨fun y' => ⟨⟨φ y', hφ01 y'⟩⟩, continuous_ulift_up.comp (φ.continuous.subtype_mk fun y' => hφ01 y')⟩\n    let h : «expr ⟶ » Y Z := ⟨fun _ => ⟨⟨0, set.left_mem_Icc.mpr zero_le_one⟩⟩, continuous_const⟩\n    have H : h = g := by\n      rw [← cancel_epi f]\n      ext x\n      dsimp\n      simp only [comp_apply, continuous_map.coe_mk, subtype.coe_mk, hφ0 (Set.mem_range_self x), pi.zero_apply]\n    apply_fun fun e => (e y).down  at H\n    dsimp at H\n    simp only [subtype.mk_eq_mk, hφ1 (Set.mem_singleton y), pi.one_apply] at H\n    exact zero_ne_one H\n  · rw [← category_theory.epi_iff_surjective]\n    apply (forget CompHaus).epi_of_epi_map\n#align epi_iff_surjective epi_iff_surjective\n\n",
 "coe_to_Top":
 "/-\nCopyright (c) 2020 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Adam Topaz, Bhavik Mehta\n-/\n@[simp]\ntheorem coe_to_Top {X : CompHaus} : (X.to_Top : Type _) = X :=\n  rfl\n#align coe_to_Top coe_to_Top\n\n",
 "coe_of":
 "@[simp]\ntheorem coe_of : (CompHaus.of X : Type _) = X :=\n  rfl\n#align coe_of coe_of\n\n",
 "Top_to_CompHaus_obj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\ntheorem Top_to_CompHaus_obj (X : Top) : «expr↥ » (Top_to_CompHaus.obj X) = stone_cech X :=\n  rfl\n#align Top_to_CompHaus_obj Top_to_CompHaus_obj\n\n"}