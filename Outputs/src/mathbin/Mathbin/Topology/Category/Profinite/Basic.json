{"to_compHausToTopCat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n#print Profinite.to_compHausToTopCat /-\n@[simp]\ntheorem Profinite.to_compHausToTopCat : «expr ⋙ » profiniteToCompHaus compHausToTop = Profinite.toTopCat :=\n  rfl\n#align Profinite.to_CompHaus_to_Top Profinite.to_compHausToTopCat\n-/\n\n",
 "toProfinite_obj'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n#print CompHaus.toProfinite_obj' /-\n-- Without explicit universe annotations here, Lean introduces two universe variables and\n-- unhelpfully defines a function `CompHaus.{max u₁ u₂} → Profinite.{max u₁ u₂}`.\ntheorem CompHaus.toProfinite_obj' (X : CompHaus) : «expr↥ » (CompHaus.toProfinite.obj X) = ConnectedComponents X :=\n  rfl\n#align CompHaus.to_Profinite_obj' CompHaus.toProfinite_obj'\n-/\n\n",
 "mono_iff_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem mono_iff_injective {X Y : Profinite.{u}} (f : «expr ⟶ » X Y) : Mono f ↔ function.injective f :=\n  by\n  constructor\n  · intro h\n    haveI : limits.preserves_limits profiniteToCompHaus := inferInstance\n    haveI : mono (Profinite_to_CompHaus.map f) := inferInstance\n    rwa [← CompHaus.mono_iff_injective]\n  · rw [← CategoryTheory.mono_iff_injective]\n    apply (forget Profinite).mono_of_mono_map\n#align mono_iff_injective mono_iff_injective\n\n",
 "is_iso_of_bijective":
 "/-- Any continuous bijection of profinite spaces induces an isomorphism. -/\ntheorem is_iso_of_bijective (bij : function.bijective f) : IsIso f :=\n  haveI := CompHaus.isIso_of_bijective (Profinite_to_CompHaus.map f) bij\n  is_iso_of_fully_faithful profiniteToCompHaus _\n#align is_iso_of_bijective is_iso_of_bijective\n\n",
 "epi_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem epi_iff_surjective {X Y : Profinite.{u}} (f : «expr ⟶ » X Y) : Epi f ↔ function.surjective f :=\n  by\n  constructor\n  · contrapose!\n    rintro ⟨y, hy⟩ hf\n    skip\n    let C := Set.range f\n    have hC : IsClosed C := (isCompact_range f.continuous).is_closed\n    let U := «expr ᶜ» C\n    have hyU : y ∈ U := by\n      refine' Set.mem_compl _\n      rintro ⟨y', hy'⟩\n      exact hy y' hy'\n    have hUy : U ∈ (nhds) y := hC.compl_mem_nhds hyU\n    obtain ⟨V, hV, hyV, hVU⟩ := is_topological_basis_clopen.mem_nhds_iff.mp hUy\n    classical\n      let Z := of (ULift.{u} <| Fin 2)\n      let g : «expr ⟶ » Y Z := ⟨(LocallyConstant.ofClopen hV).map ULift.up, LocallyConstant.continuous _⟩\n      let h : «expr ⟶ » Y Z := ⟨fun _ => ⟨1⟩, continuous_const⟩\n      have H : h = g := by\n        rw [← cancel_epi f]\n        ext x\n        dsimp [LocallyConstant.ofClopen]\n        rw [if_neg]\n        · rfl\n        refine' mt (fun α => hVU α) _\n        simp only [Set.mem_range_self, not_true, not_false_iff, Set.mem_compl_iff]\n      apply_fun fun e => (e y).down  at H\n      dsimp [LocallyConstant.ofClopen] at H\n      rw [if_pos hyV] at H\n      exact top_ne_bot H\n  · rw [← CategoryTheory.epi_iff_surjective]\n    apply (forget Profinite).epi_of_epi_map\n#align epi_iff_surjective epi_iff_surjective\n\n",
 "discreteTopology":
 "#print FintypeCat.discreteTopology /-\n@[local instance]\ntheorem FintypeCat.discreteTopology (A : FintypeCat) : DiscreteTopology A :=\n  ⟨rfl⟩\n#align Fintype.discrete_topology FintypeCat.discreteTopology\n-/\n\n",
 "coe_to_CompHaus":
 "/-\nCopyright (c) 2020 Kevin Buzzard. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Calle Sönne\n-/\n-- We check that we automatically infer that Profinite sets are compact and Hausdorff.\n@[simp]\ntheorem coe_to_CompHaus {X : Profinite} : (X.to_CompHaus : Type _) = X :=\n  rfl\n#align coe_to_CompHaus coe_to_CompHaus\n\n",
 "coe_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem coe_id (X : Profinite) : ((«expr𝟙») X : X → X) = id :=\n  rfl\n#align coe_id coe_id\n\n",
 "coe_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem coe_comp {X Y Z : Profinite} (f : «expr ⟶ » X Y) (g : «expr ⟶ » Y Z) : («expr ≫ » f g : X → Z) = g ∘ f :=\n  rfl\n#align coe_comp coe_comp\n\n",
 "IsClosedMap":
 "#print IsClosedMap /-\n-- TODO the following construction of limits could be generalised\n-- to allow diagrams in lower universes.\n/-- Any morphism of profinite spaces is a closed map. -/\ntheorem IsClosedMap : IsClosedMap f :=\n  CompHaus.isClosedMap _\n#align is_closed_map IsClosedMap\n-/\n\n"}