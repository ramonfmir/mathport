{"to_compHausToTopCat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n#print Profinite.to_compHausToTopCat /-\n@[simp]\ntheorem Profinite.to_compHausToTopCat : Â«expr â‹™ Â» profiniteToCompHaus compHausToTop = Profinite.toTopCat :=\n  rfl\n#align Profinite.to_CompHaus_to_Top Profinite.to_compHausToTopCat\n-/\n\n",
 "toProfinite_obj'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†¥ Â» -/\n#print CompHaus.toProfinite_obj' /-\n-- Without explicit universe annotations here, Lean introduces two universe variables and\n-- unhelpfully defines a function `CompHaus.{max uâ‚ uâ‚‚} â†’ Profinite.{max uâ‚ uâ‚‚}`.\ntheorem CompHaus.toProfinite_obj' (X : CompHaus) : Â«exprâ†¥ Â» (CompHaus.toProfinite.obj X) = ConnectedComponents X :=\n  rfl\n#align CompHaus.to_Profinite_obj' CompHaus.toProfinite_obj'\n-/\n\n",
 "mono_iff_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem mono_iff_injective {X Y : Profinite.{u}} (f : Â«expr âŸ¶ Â» X Y) : Mono f â†” function.injective f :=\n  by\n  constructor\n  Â· intro h\n    haveI : limits.preserves_limits profiniteToCompHaus := inferInstance\n    haveI : mono (Profinite_to_CompHaus.map f) := inferInstance\n    rwa [â† CompHaus.mono_iff_injective]\n  Â· rw [â† CategoryTheory.mono_iff_injective]\n    apply (forget Profinite).mono_of_mono_map\n#align mono_iff_injective mono_iff_injective\n\n",
 "is_iso_of_bijective":
 "/-- Any continuous bijection of profinite spaces induces an isomorphism. -/\ntheorem is_iso_of_bijective (bij : function.bijective f) : IsIso f :=\n  haveI := CompHaus.isIso_of_bijective (Profinite_to_CompHaus.map f) bij\n  is_iso_of_fully_faithful profiniteToCompHaus _\n#align is_iso_of_bijective is_iso_of_bijective\n\n",
 "epi_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem epi_iff_surjective {X Y : Profinite.{u}} (f : Â«expr âŸ¶ Â» X Y) : Epi f â†” function.surjective f :=\n  by\n  constructor\n  Â· contrapose!\n    rintro âŸ¨y, hyâŸ© hf\n    skip\n    let C := Set.range f\n    have hC : IsClosed C := (isCompact_range f.continuous).is_closed\n    let U := Â«expr á¶œÂ» C\n    have hyU : y âˆˆ U := by\n      refine' Set.mem_compl _\n      rintro âŸ¨y', hy'âŸ©\n      exact hy y' hy'\n    have hUy : U âˆˆ (nhds) y := hC.compl_mem_nhds hyU\n    obtain âŸ¨V, hV, hyV, hVUâŸ© := is_topological_basis_clopen.mem_nhds_iff.mp hUy\n    classical\n      let Z := of (ULift.{u} <| Fin 2)\n      let g : Â«expr âŸ¶ Â» Y Z := âŸ¨(LocallyConstant.ofClopen hV).map ULift.up, LocallyConstant.continuous _âŸ©\n      let h : Â«expr âŸ¶ Â» Y Z := âŸ¨fun _ => âŸ¨1âŸ©, continuous_constâŸ©\n      have H : h = g := by\n        rw [â† cancel_epi f]\n        ext x\n        dsimp [LocallyConstant.ofClopen]\n        rw [if_neg]\n        Â· rfl\n        refine' mt (fun Î± => hVU Î±) _\n        simp only [Set.mem_range_self, not_true, not_false_iff, Set.mem_compl_iff]\n      apply_fun fun e => (e y).down  at H\n      dsimp [LocallyConstant.ofClopen] at H\n      rw [if_pos hyV] at H\n      exact top_ne_bot H\n  Â· rw [â† CategoryTheory.epi_iff_surjective]\n    apply (forget Profinite).epi_of_epi_map\n#align epi_iff_surjective epi_iff_surjective\n\n",
 "discreteTopology":
 "#print FintypeCat.discreteTopology /-\n@[local instance]\ntheorem FintypeCat.discreteTopology (A : FintypeCat) : DiscreteTopology A :=\n  âŸ¨rflâŸ©\n#align Fintype.discrete_topology FintypeCat.discreteTopology\n-/\n\n",
 "coe_to_CompHaus":
 "/-\nCopyright (c) 2020 Kevin Buzzard. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Calle SÃ¶nne\n-/\n-- We check that we automatically infer that Profinite sets are compact and Hausdorff.\n@[simp]\ntheorem coe_to_CompHaus {X : Profinite} : (X.to_CompHaus : Type _) = X :=\n  rfl\n#align coe_to_CompHaus coe_to_CompHaus\n\n",
 "coe_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem coe_id (X : Profinite) : ((Â«exprğŸ™Â») X : X â†’ X) = id :=\n  rfl\n#align coe_id coe_id\n\n",
 "coe_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem coe_comp {X Y Z : Profinite} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) : (Â«expr â‰« Â» f g : X â†’ Z) = g âˆ˜ f :=\n  rfl\n#align coe_comp coe_comp\n\n",
 "IsClosedMap":
 "#print IsClosedMap /-\n-- TODO the following construction of limits could be generalised\n-- to allow diagrams in lower universes.\n/-- Any morphism of profinite spaces is a closed map. -/\ntheorem IsClosedMap : IsClosedMap f :=\n  CompHaus.isClosedMap _\n#align is_closed_map IsClosedMap\n-/\n\n"}