{"exists_locally_constant_finite_nonempty":
 "theorem exists_locally_constant_finite_nonempty {α : Type _} [Finite α] [nonempty α] (f : locally_constant C.X α) :\n    ∃ (j : J)(g : locally_constant (F.obj j) α), f = g.comap (C.π.app _) :=\n  by\n  inhabit α\n  obtain ⟨j, gg, h⟩ := exists_locally_constant_finite_aux _ hC f\n  let ι : α → α → fin 2 := fun a b => if a = b then 0 else 1\n  let σ : (α → fin 2) → α := fun f => if h : ∃ a : α, ι a = f then h.some else Inhabited.default _\n  refine' ⟨j, gg.map σ, _⟩\n  ext\n  rw [locally_constant.coe_comap _ _ (C.π.app j).continuous]\n  dsimp [σ]\n  have h1 : ι (f x) = gg (C.π.app j x) :=\n    by\n    change f.map (fun a b => if a = b then (0 : fin 2) else 1) x = _\n    rw [h, locally_constant.coe_comap _ _ (C.π.app j).continuous]\n  have h2 : ∃ a : α, ι a = gg (C.π.app j x) := ⟨f x, h1⟩\n  rw [dif_pos h2]\n  apply_fun ι\n  · rw [h2.some_spec]\n    exact h1\n  · intro a b hh\n    apply_fun fun e => e a  at hh\n    dsimp [ι] at hh\n    rw [if_pos rfl] at hh\n    split_ifs  at hh with hh1 hh1\n    · exact hh1.symm\n    · exact false.elim (bot_ne_top hh)\n#align exists_locally_constant_finite_nonempty exists_locally_constant_finite_nonempty\n\n",
 "exists_locally_constant_finite_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem exists_locally_constant_finite_aux {α : Type _} [Finite α] (f : locally_constant C.X α) :\n    ∃ (j : J)(g : locally_constant (F.obj j) (α → fin 2)),\n      (f.map fun a b => if a = b then (0 : fin 2) else 1) = g.comap (C.π.app _) :=\n  by\n  cases nonempty_fintype α\n  let ι : α → α → fin 2 := fun x y => if x = y then 0 else 1\n  let ff := (f.map ι).flip\n  have hff := fun a : α => exists_locally_constant_fin_two _ hC (ff a)\n  choose j g h using hff\n  let G : Finset J := finset.univ.image j\n  obtain ⟨j0, hj0⟩ := is_cofiltered.inf_objs_exists G\n  have hj : ∀ a, j a ∈ G := by\n    intro a\n    simp [G]\n  let fs : ∀ a : α, «expr ⟶ » j0 (j a) := fun a => (hj0 (hj a)).some\n  let gg : α → locally_constant (F.obj j0) (fin 2) := fun a => (g a).comap (F.map (fs _))\n  let ggg := locally_constant.unflip gg\n  refine' ⟨j0, ggg, _⟩\n  have : f.map ι = locally_constant.unflip (f.map ι).flip := by simp\n  rw [this]\n  clear this\n  have :\n    locally_constant.comap (C.π.app j0) ggg = locally_constant.unflip (locally_constant.comap (C.π.app j0) ggg).flip :=\n    by simp\n  rw [this]\n  clear this\n  congr 1\n  ext1 a\n  change ff a = _\n  rw [h]\n  dsimp [ggg, gg]\n  ext1\n  repeat'\n    rw [locally_constant.coe_comap]\n    dsimp [locally_constant.flip, locally_constant.unflip]\n  · congr 1\n    change _ = («expr ≫ » (C.π.app j0) (F.map (fs a))) x\n    rw [C.w]\n  all_goals continuity\n#align exists_locally_constant_finite_aux exists_locally_constant_finite_aux\n\n",
 "exists_locally_constant_fin_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem exists_locally_constant_fin_two (f : locally_constant C.X (fin 2)) :\n    ∃ (j : J)(g : locally_constant (F.obj j) (fin 2)), f = g.comap (C.π.app _) :=\n  by\n  let U := «expr ⁻¹' » f {0}\n  have hU : is_clopen U := f.is_locally_constant.is_clopen_fiber _\n  obtain ⟨j, V, hV, h⟩ := exists_clopen_of_cofiltered C hC hU\n  use j, locally_constant.of_clopen hV\n  apply locally_constant.locally_constant_eq_of_fiber_zero_eq\n  rw [locally_constant.coe_comap _ _ (C.π.app j).continuous]\n  conv_rhs => rw [Set.preimage_comp]\n  rw [locally_constant.of_clopen_fiber_zero hV, ← h]\n#align exists_locally_constant_fin_two exists_locally_constant_fin_two\n\n",
 "exists_locally_constant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/-- Any locally constant function from a cofiltered limit of profinite sets factors through\none of the components. -/\ntheorem exists_locally_constant {α : Type _} (f : locally_constant C.X α) :\n    ∃ (j : J)(g : locally_constant (F.obj j) α), f = g.comap (C.π.app _) :=\n  by\n  let S := f.discrete_quotient\n  let ff : S → α := f.lift\n  cases isEmpty_or_nonempty S\n  · suffices ∃ j, is_empty (F.obj j) by\n      refine' this.imp fun j hj => _\n      refine' ⟨⟨hj.elim, fun A => _⟩, _⟩\n      · convert is_open_empty\n        exact @Set.eq_empty_of_isEmpty _ hj _\n      · ext x\n        exact hj.elim' (C.π.app j x)\n    simp only [← not_nonempty_iff, ← not_forall]\n    intro h\n    haveI : ∀ j : J, nonempty ((«expr ⋙ » F Profinite.to_Top).obj j) := h\n    haveI : ∀ j : J, t2_space ((«expr ⋙ » F Profinite.to_Top).obj j) := fun j => (infer_instance : t2_space (F.obj j))\n    haveI : ∀ j : J, compact_space ((«expr ⋙ » F Profinite.to_Top).obj j) := fun j =>\n      (infer_instance : compact_space (F.obj j))\n    have cond := Top.nonempty_limit_cone_of_compact_t2_cofiltered_system («expr ⋙ » F Profinite.to_Top)\n    suffices : nonempty C.X\n    exact is_empty.false (S.proj this.some)\n    let D := Profinite.to_Top.map_cone C\n    have hD : is_limit D := is_limit_of_preserves Profinite.to_Top hC\n    have CD := (hD.cone_point_unique_up_to_iso (Top.limit_cone_is_limit.{u} _)).inv\n    exact cond.map CD\n  · let f' : locally_constant C.X S := ⟨S.proj, S.proj_is_locally_constant⟩\n    obtain ⟨j, g', hj⟩ := exists_locally_constant_finite_nonempty _ hC f'\n    refine' ⟨j, ⟨ff ∘ g', g'.is_locally_constant.comp _⟩, _⟩\n    ext1 t\n    apply_fun fun e => e t  at hj\n    rw [locally_constant.coe_comap _ _ (C.π.app j).continuous] at hj⊢\n    dsimp at hj⊢\n    rw [← hj]\n    rfl\n#align exists_locally_constant exists_locally_constant\n\n",
 "exists_clopen_of_cofiltered":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-\nCopyright (c) 2021 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Adam Topaz\n-/\n/-- If `X` is a cofiltered limit of profinite sets, then any clopen subset of `X` arises from\na clopen set in one of the terms in the limit.\n-/\ntheorem exists_clopen_of_cofiltered {U : set C.X} (hU : is_clopen U) :\n    ∃ (j : J)(V : set (F.obj j))(hV : is_clopen V), U = «expr ⁻¹' » (C.π.app j) V :=\n  by\n  -- First, we have the topological basis of the cofiltered limit obtained by pulling back\n  -- clopen sets from the factors in the limit. By continuity, all such sets are again clopen.\n  have hB :=\n    Top.is_topological_basis_cofiltered_limit.{u} («expr ⋙ » F Profinite.to_Top) (Profinite.to_Top.map_cone C)\n      (is_limit_of_preserves _ hC) (fun j => { W | is_clopen W }) _ (fun i => is_clopen_univ)\n      (fun i U1 U2 hU1 hU2 => hU1.inter hU2) _\n  rotate_left\n  · intro i\n    change topological_space.is_topological_basis { W : set (F.obj i) | is_clopen W }\n    apply is_topological_basis_clopen\n  · rintro i j f V (hV : is_clopen _)\n    refine' ⟨hV.1.preimage _, hV.2.preimage _⟩ <;> continuity\n  -- Using this, since `U` is open, we can write `U` as a union of clopen sets all of which\n  -- are preimages of clopens from the factors in the limit.\n  obtain ⟨S, hS, h⟩ := hB.open_eq_sUnion hU.1\n  clear hB\n  let j : S → J := fun s => (hS s.2).some\n  let V : ∀ s : S, set (F.obj (j s)) := fun s => (hS s.2).some_spec.some\n  have hV : ∀ s : S, is_clopen (V s) ∧ s.1 = «expr ⁻¹' » (C.π.app (j s)) (V s) := fun s => (hS s.2).some_spec.some_spec\n  -- Since `U` is also closed, hence compact, it is covered by finitely many of the\n  -- clopens constructed in the previous step.\n  have := hU.2.is_compact.elim_finite_subcover (fun s : S => «expr ⁻¹' » (C.π.app (j s)) (V s)) _ _\n  rotate_left\n  · intro s\n    refine' (hV s).1.1.preimage _\n    continuity\n  · dsimp only\n    rw [h]\n    rintro x ⟨T, hT, hx⟩\n    refine' ⟨_, ⟨⟨T, hT⟩, rfl⟩, _⟩\n    dsimp only\n    rwa [← (hV ⟨T, hT⟩).2]\n  -- We thus obtain a finite set `G : finset J` and a clopen set of `F.obj j` for each\n  -- `j ∈ G` such that `U` is the union of the preimages of these clopen sets.\n  obtain ⟨G, hG⟩ := this\n  -- Since `J` is cofiltered, we can find a single `j0` dominating all the `j ∈ G`.\n  -- Pulling back all of the sets from the previous step to `F.obj j0` and taking a union,\n  -- we obtain a clopen set in `F.obj j0` which works.\n  obtain ⟨j0, hj0⟩ := is_cofiltered.inf_objs_exists (G.image j)\n  let f : ∀ (s : S) (hs : s ∈ G), «expr ⟶ » j0 (j s) := fun s hs => (hj0 (finset.mem_image.mpr ⟨s, hs, rfl⟩)).some\n  let W : S → set (F.obj j0) := fun s => if hs : s ∈ G then «expr ⁻¹' » (F.map (f s hs)) (V s) else Set.univ\n  -- Conclude, using the `j0` and the clopen set of `F.obj j0` obtained above.\n  refine'\n    ⟨j0, «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (W s), _, _⟩\n  · apply is_clopen_bUnion_finset\n    intro s hs\n    dsimp only [W]\n    rw [dif_pos hs]\n    refine' ⟨(hV s).1.1.preimage _, (hV s).1.2.preimage _⟩ <;> continuity\n  · ext x\n    constructor\n    · intro hx\n      simp_rw [Set.preimage_unionᵢ, Set.mem_unionᵢ]\n      obtain ⟨_, ⟨s, rfl⟩, _, ⟨hs, rfl⟩, hh⟩ := hG hx\n      refine' ⟨s, hs, _⟩\n      dsimp only [W] at hh⊢\n      rwa [dif_pos hs, ← Set.preimage_comp, ← Profinite.coe_comp, C.w]\n    · intro hx\n      simp_rw [Set.preimage_unionᵢ, Set.mem_unionᵢ] at hx\n      obtain ⟨s, hs, hx⟩ := hx\n      rw [h]\n      refine' ⟨s.1, s.2, _⟩\n      rw [(hV s).2]\n      dsimp only [W] at hx\n      rwa [dif_pos hs, ← Set.preimage_comp, ← Profinite.coe_comp, C.w] at hx\n#align exists_clopen_of_cofiltered exists_clopen_of_cofiltered\n\n"}