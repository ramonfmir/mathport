{"to_Profinite_obj'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†¥ Â» -/\n-- Without explicit universe annotations here, Lean introduces two universe variables and\n-- unhelpfully defines a function `CompHaus.{max uâ‚ uâ‚‚} â†’ Profinite.{max uâ‚ uâ‚‚}`.\ntheorem CompHaus.to_Profinite_obj' (X : CompHaus) : Â«exprâ†¥ Â» (CompHaus.to_Profinite.obj X) = connected_components X :=\n  rfl\n#align CompHaus.to_Profinite_obj' CompHaus.to_Profinite_obj'\n\n",
 "to_CompHaus_to_Top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n@[simp]\ntheorem Profinite.to_CompHaus_to_Top : Â«expr â‹™ Â» Profinite_to_CompHaus CompHaus_to_Top = Profinite.to_Top :=\n  rfl\n#align Profinite.to_CompHaus_to_Top Profinite.to_CompHaus_to_Top\n\n",
 "mono_iff_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem mono_iff_injective {X Y : Profinite.{u}} (f : Â«expr âŸ¶ Â» X Y) : Mono f â†” function.injective f :=\n  by\n  constructor\n  Â· intro h\n    haveI : limits.preserves_limits Profinite_to_CompHaus := infer_instance\n    haveI : mono (Profinite_to_CompHaus.map f) := infer_instance\n    rwa [â† CompHaus.mono_iff_injective]\n  Â· rw [â† category_theory.mono_iff_injective]\n    apply (forget Profinite).mono_of_mono_map\n#align mono_iff_injective mono_iff_injective\n\n",
 "is_iso_of_bijective":
 "/-- Any continuous bijection of profinite spaces induces an isomorphism. -/\ntheorem is_iso_of_bijective (bij : function.bijective f) : IsIso f :=\n  haveI := CompHaus.is_iso_of_bijective (Profinite_to_CompHaus.map f) bij\n  is_iso_of_fully_faithful Profinite_to_CompHaus _\n#align is_iso_of_bijective is_iso_of_bijective\n\n",
 "is_closed_map":
 "-- TODO the following construction of limits could be generalised\n-- to allow diagrams in lower universes.\n/-- Any morphism of profinite spaces is a closed map. -/\ntheorem is_closed_map : is_closed_map f :=\n  CompHaus.is_closed_map _\n#align is_closed_map is_closed_map\n\n",
 "epi_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem epi_iff_surjective {X Y : Profinite.{u}} (f : Â«expr âŸ¶ Â» X Y) : Epi f â†” function.surjective f :=\n  by\n  constructor\n  Â· contrapose!\n    rintro âŸ¨y, hyâŸ© hf\n    let C := Set.range f\n    have hC : is_closed C := (is_compact_range f.continuous).is_closed\n    let U := Â«expr á¶œÂ» C\n    have hU : is_open U := is_open_compl_iff.mpr hC\n    have hyU : y âˆˆ U := by\n      refine' Set.mem_compl _\n      rintro âŸ¨y', hy'âŸ©\n      exact hy y' hy'\n    have hUy : U âˆˆ nhds y := hU.mem_nhds hyU\n    obtain âŸ¨V, hV, hyV, hVUâŸ© := is_topological_basis_clopen.mem_nhds_iff.mp hUy\n    classical\n      letI : topological_space (ULift.{u} <| fin 2) := Â«exprâŠ¥Â»\n      let Z := of (ULift.{u} <| fin 2)\n      let g : Â«expr âŸ¶ Â» Y Z := âŸ¨(locally_constant.of_clopen hV).map ulift.up, locally_constant.continuous _âŸ©\n      let h : Â«expr âŸ¶ Â» Y Z := âŸ¨fun _ => âŸ¨1âŸ©, continuous_constâŸ©\n      have H : h = g := by\n        rw [â† cancel_epi f]\n        ext x\n        dsimp [locally_constant.of_clopen]\n        rw [if_neg]\n        Â· rfl\n        refine' mt (fun Î± => hVU Î±) _\n        simp only [Set.mem_range_self, not_true, not_false_iff, Set.mem_compl_iff]\n      apply_fun fun e => (e y).down  at H\n      dsimp [locally_constant.of_clopen] at H\n      rw [if_pos hyV] at H\n      exact top_ne_bot H\n  Â· rw [â† category_theory.epi_iff_surjective]\n    apply (forget Profinite).epi_of_epi_map\n#align epi_iff_surjective epi_iff_surjective\n\n",
 "coe_to_CompHaus":
 "/-\nCopyright (c) 2020 Kevin Buzzard. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Calle SÃ¶nne\n-/\n-- We check that we automatically infer that Profinite sets are compact and Hausdorff.\n@[simp]\ntheorem coe_to_CompHaus {X : Profinite} : (X.to_CompHaus : Type _) = X :=\n  rfl\n#align coe_to_CompHaus coe_to_CompHaus\n\n",
 "coe_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n@[simp]\ntheorem coe_id (X : Profinite) : ((Â«exprğŸ™Â») X : X â†’ X) = id :=\n  rfl\n#align coe_id coe_id\n\n",
 "coe_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem coe_comp {X Y Z : Profinite} (f : Â«expr âŸ¶ Â» X Y) (g : Â«expr âŸ¶ Â» Y Z) : (Â«expr â‰« Â» f g : X â†’ Z) = g âˆ˜ f :=\n  rfl\n#align coe_comp coe_comp\n\n"}