{"is_topological_basis_cofiltered_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-\nCopyright (c) 2017 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Scott Morrison, Mario Carneiro, Andrew Yang\n-/\n/-- Given a *compatible* collection of topological bases for the factors in a cofiltered limit\nwhich contain `set.univ` and are closed under intersections, the induced *naive* collection\nof sets in the limit is, in fact, a topological basis.\n-/\ntheorem is_topological_basis_cofiltered_limit (T : ∀ j, Set (Set (F.obj j))) (hT : ∀ j, IsTopologicalBasis (T j))\n    (univ : ∀ i : J, Set.univ ∈ T i) (inter : ∀ (i) (U1 U2 : Set (F.obj i)), U1 ∈ T i → U2 ∈ T i → U1 ∩ U2 ∈ T i)\n    (compat : ∀ (i j : J) (f : «expr ⟶ » i j) (V : Set (F.obj j)) (hV : V ∈ T j), «expr ⁻¹' » (F.map f) V ∈ T i) :\n    IsTopologicalBasis { U : Set C.X | ∃ (j : _)(V : Set (F.obj j)), V ∈ T j ∧ U = «expr ⁻¹' » (C.π.app j) V } := by\n  classical\n    -- The limit cone for `F` whose topology is defined as an infimum.\n    let D := limit_cone_infi F\n    -- The isomorphism between the cone point of `C` and the cone point of `D`.\n    let E : «expr ≅ » C.X D.X := hC.cone_point_unique_up_to_iso (limit_cone_infi_is_limit _)\n    have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing\n    -- Reduce to the assertion of the theorem with `D` instead of `C`.\n    suffices\n      is_topological_basis { U : Set D.X | ∃ (j : _)(V : Set (F.obj j)), V ∈ T j ∧ U = «expr ⁻¹' » (D.π.app j) V }\n      by\n      convert this.inducing hE\n      ext U0\n      constructor\n      · rintro ⟨j, V, hV, rfl⟩\n        refine' ⟨«expr ⁻¹' » (D.π.app j) V, ⟨j, V, hV, rfl⟩, rfl⟩\n      · rintro ⟨W, ⟨j, V, hV, rfl⟩, rfl⟩\n        refine' ⟨j, V, hV, rfl⟩\n    -- Using `D`, we can apply the characterization of the topological basis of a\n    -- topology defined as an infimum...\n    convert isTopologicalBasis_infᵢ hT fun j (x : D.X) => D.π.app j x\n    ext U0\n    constructor\n    · rintro ⟨j, V, hV, rfl⟩\n      let U : ∀ i, Set (F.obj i) := fun i =>\n        if h : i = j then by\n          rw [h]\n          exact V\n        else Set.univ\n      refine' ⟨U, {j}, _, _⟩\n      · rintro i h\n        rw [Finset.mem_singleton] at h\n        dsimp [U]\n        rw [dif_pos h]\n        subst h\n        exact hV\n      · dsimp [U]\n        simp\n    · rintro ⟨U, G, h1, h2⟩\n      obtain ⟨j, hj⟩ := is_cofiltered.inf_objs_exists G\n      let g : ∀ (e) (he : e ∈ G), «expr ⟶ » j e := fun _ he => (hj he).some\n      let Vs : J → Set (F.obj j) := fun e => if h : e ∈ G then «expr ⁻¹' » (F.map (g e h)) (U e) else Set.univ\n      let V : Set (F.obj j) :=\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Vs e)\n      refine' ⟨j, V, _, _⟩\n      · -- An intermediate claim used to apply induction along `G : finset J` later on.\n        have :\n          ∀ (S : Set (Set (F.obj j))) (E : Finset J) (P : J → Set (F.obj j)) (univ : Set.univ ∈ S)\n            (inter : ∀ A B : Set (F.obj j), A ∈ S → B ∈ S → A ∩ B ∈ S) (cond : ∀ (e : J) (he : e ∈ E), P e ∈ S),\n            «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (P e) ∈ S :=\n          by\n          intro S E\n          apply E.induction_on\n          · intro P he hh\n            simpa\n          · intro a E ha hh1 hh2 hh3 hh4 hh5\n            rw [Finset.set_binterᵢ_insert]\n            refine' hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 _)\n            intro e he\n            exact hh5 e (Finset.mem_insert_of_mem he)\n        -- use the intermediate claim to finish off the goal using `univ` and `inter`.\n        refine' this _ _ _ (univ _) (inter _) _\n        intro e he\n        dsimp [Vs]\n        rw [dif_pos he]\n        exact compat j e (g e he) (U e) (h1 e he)\n      · -- conclude...\n        rw [h2]\n        dsimp [V]\n        rw [Set.preimage_interᵢ]\n        congr 1\n        ext1 e\n        rw [Set.preimage_interᵢ]\n        congr 1\n        ext1 he\n        dsimp [Vs]\n        rw [dif_pos he, ← Set.preimage_comp]\n        congr 1\n        change _ = «expr⇑ » («expr ≫ » (D.π.app j) (F.map (g e he)))\n        rw [D.w]\n#align is_topological_basis_cofiltered_limit is_topological_basis_cofiltered_limit\n\n"}