{"nonempty_limit_cone_of_compact_t2_cofiltered_system":
 "/-- Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces.\n-/\ntheorem nonempty_limit_cone_of_compact_t2_cofiltered_system [IsCofilteredOrEmpty J] [∀ j : J, Nonempty (F.obj j)]\n    [∀ j : J, CompactSpace (F.obj j)] [∀ j : J, T2Space (F.obj j)] : Nonempty (TopCat.limitCone.{u} F).X := by\n  classical\n    obtain ⟨u, hu⟩ :=\n      IsCompact.nonempty_interᵢ_of_directed_nonempty_compact_closed (fun G => partial_sections F _)\n        (partial_sections.directed F) (fun G => partial_sections.nonempty F _)\n        (fun G => IsClosed.isCompact (partial_sections.closed F _)) fun G => partial_sections.closed F _\n    use u\n    intro X Y f\n    let G : finite_diagram J :=\n      ⟨{X, Y},\n        {⟨X, Y, by simp only [true_or_iff, eq_self_iff_true, Finset.mem_insert], by\n            simp only [eq_self_iff_true, or_true_iff, Finset.mem_insert, Finset.mem_singleton], f⟩}⟩\n    exact hu _ ⟨G, rfl⟩ (Finset.mem_singleton_self _)\n#align nonempty_limit_cone_of_compact_t2_cofiltered_system nonempty_limit_cone_of_compact_t2_cofiltered_system\n\n",
 "nonempty":
 "/-\nCopyright (c) 2017 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Scott Morrison, Mario Carneiro, Andrew Yang\n-/\ntheorem partial_sections.nonempty [IsCofilteredOrEmpty J] [h : ∀ j : J, Nonempty (F.obj j)] {G : Finset J}\n    (H : Finset (finite_diagram_arrow G)) : (partialSections F H).nonempty := by\n  classical\n    cases isEmpty_or_nonempty J\n    · exact ⟨isEmptyElim, fun j => IsEmpty.elim' inferInstance j.1⟩\n    haveI : is_cofiltered J := ⟨⟩\n    use fun j : J =>\n      if hj : j ∈ G then F.map (is_cofiltered.inf_to G H hj) (h (is_cofiltered.inf G H)).some else (h _).some\n    rintro ⟨X, Y, hX, hY, f⟩ hf\n    dsimp only\n    rwa [dif_pos hX, dif_pos hY, ← comp_app, ← F.map_comp, @is_cofiltered.inf_to_commutes _ _ _ G H]\n#align partial_sections.nonempty partial_sections.nonempty\n\n",
 "directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem partial_sections.directed : Directed superset fun G : finite_diagram J => partialSections F G.2 := by\n  classical\n    intro A B\n    let ιA : finite_diagram_arrow A.1 → finite_diagram_arrow («expr ⊔ » A.1 B.1) := fun f =>\n      ⟨f.1, f.2.1, Finset.mem_union_left _ f.2.2.1, Finset.mem_union_left _ f.2.2.2.1, f.2.2.2.2⟩\n    let ιB : finite_diagram_arrow B.1 → finite_diagram_arrow («expr ⊔ » A.1 B.1) := fun f =>\n      ⟨f.1, f.2.1, Finset.mem_union_right _ f.2.2.1, Finset.mem_union_right _ f.2.2.2.1, f.2.2.2.2⟩\n    refine' ⟨⟨«expr ⊔ » A.1 B.1, «expr ⊔ » (A.2.image ιA) (B.2.image ιB)⟩, _, _⟩\n    · rintro u hu f hf\n      have : ιA f ∈ «expr ⊔ » (A.2.image ιA) (B.2.image ιB) :=\n        by\n        apply Finset.mem_union_left\n        rw [Finset.mem_image]\n        refine' ⟨f, hf, rfl⟩\n      exact hu this\n    · rintro u hu f hf\n      have : ιB f ∈ «expr ⊔ » (A.2.image ιA) (B.2.image ιB) :=\n        by\n        apply Finset.mem_union_right\n        rw [Finset.mem_image]\n        refine' ⟨f, hf, rfl⟩\n      exact hu this\n#align partial_sections.directed partial_sections.directed\n\n",
 "closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem partial_sections.closed [∀ j : J, T2Space (F.obj j)] {G : Finset J} (H : Finset (finite_diagram_arrow G)) :\n    IsClosed (partialSections F H) :=\n  by\n  have :\n    partial_sections F H =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        { u | F.map f.2.2.2.2 (u f.1) = u f.2.1 } :=\n    by\n    ext1\n    simp only [Set.mem_interᵢ, Set.mem_setOf_eq]\n    rfl\n  rw [this]\n  apply isClosed_binterᵢ\n  intro f hf\n  apply isClosed_eq\n  continuity\n#align partial_sections.closed partial_sections.closed\n\n"}