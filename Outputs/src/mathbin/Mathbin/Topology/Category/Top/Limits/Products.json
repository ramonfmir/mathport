{"sigma_iso_sigma_inv_apply":
 "@[simp]\ntheorem sigma_iso_sigma_inv_apply {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) (x : α i) :\n    (sigmaIsoSigma α).inv ⟨i, x⟩ = (Sigma.ι α i : _) x :=\n  by\n  rw [← sigma_iso_sigma_hom_ι_apply, ← comp_app]\n  simp\n#align sigma_iso_sigma_inv_apply sigma_iso_sigma_inv_apply\n\n",
 "sigma_iso_sigma_hom_ι_apply":
 "@[simp]\ntheorem sigma_iso_sigma_hom_ι_apply {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) (x : α i) :\n    (sigmaIsoSigma α).hom ((Sigma.ι α i : _) x) = sigma.mk i x :=\n  ConcreteCategory.congr_hom (sigmaIsoSigma_hom_ι α i) x\n#align sigma_iso_sigma_hom_ι_apply sigma_iso_sigma_hom_ι_apply\n\n",
 "sigma_iso_sigma_hom_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem sigma_iso_sigma_hom_ι {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) :\n    «expr ≫ » (Sigma.ι α i) (sigmaIsoSigma α).hom = sigmaι α i := by simp [sigma_iso_sigma]\n#align sigma_iso_sigma_hom_ι sigma_iso_sigma_hom_ι\n\n",
 "range_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\ntheorem range_prod_map {W X Y Z : TopCat.{u}} (f : «expr ⟶ » W Y) (g : «expr ⟶ » X Z) :\n    Set.range (Limits.prod.map f g) =\n      «expr ⁻¹' » (Limits.prod.fst : «expr ⟶ » («expr ⨯ » Y Z) _) (Set.range f) ∩\n        «expr ⁻¹' » (Limits.prod.snd : «expr ⟶ » («expr ⨯ » Y Z) _) (Set.range g) :=\n  by\n  ext\n  constructor\n  · rintro ⟨y, rfl⟩\n    simp only [Set.mem_preimage, Set.mem_range, Set.mem_inter_iff, ← comp_apply]\n    simp only [limits.prod.map_fst, limits.prod.map_snd, exists_apply_eq_apply, comp_apply, and_self_iff]\n  · rintro ⟨⟨x₁, hx₁⟩, ⟨x₂, hx₂⟩⟩\n    use (prod_iso_prod W X).inv (x₁, x₂)\n    apply concrete.limit_ext\n    rintro ⟨⟨⟩⟩\n    · simp only [← comp_apply, category.assoc]\n      erw [limits.prod.map_fst]\n      simp [hx₁]\n    · simp only [← comp_apply, category.assoc]\n      erw [limits.prod.map_snd]\n      simp [hx₂]\n#align range_prod_map range_prod_map\n\n",
 "prod_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\ntheorem prod_topology {X Y : TopCat} :\n    («expr ⨯ » X Y).topological_space =\n      «expr ⊓ » (induced (Limits.prod.fst : «expr ⟶ » («expr ⨯ » X Y) _) X.topological_space)\n        (induced (Limits.prod.snd : «expr ⟶ » («expr ⨯ » X Y) _) Y.topological_space) :=\n  by\n  let homeo := homeo_of_iso (prod_iso_prod X Y)\n  refine' homeo.inducing.induced.trans _\n  change induced homeo («expr ⊓ » _ _) = _\n  simpa [induced_compose]\n#align prod_topology prod_topology\n\n",
 "prod_iso_prod_inv_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1, elementwise]\ntheorem prod_iso_prod_inv_snd (X Y : TopCat.{u}) : «expr ≫ » (prodIsoProd X Y).inv Limits.prod.snd = prodSnd := by\n  simp [iso.inv_comp_eq]\n#align prod_iso_prod_inv_snd prod_iso_prod_inv_snd\n\n",
 "prod_iso_prod_inv_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1, elementwise]\ntheorem prod_iso_prod_inv_fst (X Y : TopCat.{u}) : «expr ≫ » (prodIsoProd X Y).inv Limits.prod.fst = prodFst := by\n  simp [iso.inv_comp_eq]\n#align prod_iso_prod_inv_fst prod_iso_prod_inv_fst\n\n",
 "prod_iso_prod_hom_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod_iso_prod_hom_snd (X Y : TopCat.{u}) : «expr ≫ » (prodIsoProd X Y).hom prodSnd = Limits.prod.snd := by\n  simpa [← iso.eq_inv_comp, prod_iso_prod]\n#align prod_iso_prod_hom_snd prod_iso_prod_hom_snd\n\n",
 "prod_iso_prod_hom_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod_iso_prod_hom_fst (X Y : TopCat.{u}) : «expr ≫ » (prodIsoProd X Y).hom prodFst = Limits.prod.fst := by\n  simpa [← iso.eq_inv_comp, prod_iso_prod]\n#align prod_iso_prod_hom_fst prod_iso_prod_hom_fst\n\n",
 "prod_iso_prod_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n@[simp]\ntheorem prod_iso_prod_hom_apply {X Y : TopCat.{u}} (x : «expr ⨯ » X Y) :\n    (prodIsoProd X Y).hom x =\n      ((Limits.prod.fst : «expr ⟶ » («expr ⨯ » X Y) _) x, (Limits.prod.snd : «expr ⟶ » («expr ⨯ » X Y) _) x) :=\n  by\n  ext\n  · exact concrete_category.congr_hom (prod_iso_prod_hom_fst X Y) x\n  · exact concrete_category.congr_hom (prod_iso_prod_hom_snd X Y) x\n#align prod_iso_prod_hom_apply prod_iso_prod_hom_apply\n\n",
 "pi_iso_pi_inv_π_apply":
 "@[simp]\ntheorem pi_iso_pi_inv_π_apply {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) (x : ∀ i, α i) :\n    (Pi.π α i : _) ((piIsoPi α).inv x) = x i :=\n  ConcreteCategory.congr_hom (piIsoPi_inv_π α i) x\n#align pi_iso_pi_inv_π_apply pi_iso_pi_inv_π_apply\n\n",
 "pi_iso_pi_inv_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2017 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Scott Morrison, Mario Carneiro, Andrew Yang\n-/\n@[simp, reassoc.1]\ntheorem pi_iso_pi_inv_π {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) :\n    «expr ≫ » (piIsoPi α).inv (Pi.π α i) = piπ α i := by simp [pi_iso_pi]\n#align pi_iso_pi_inv_π pi_iso_pi_inv_π\n\n",
 "pi_iso_pi_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∏ » -/\n@[simp]\ntheorem pi_iso_pi_hom_apply {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) (x : «expr∏ » α) :\n    (piIsoPi α).hom x i = (Pi.π α i : _) x := by\n  have := pi_iso_pi_inv_π α i\n  rw [iso.inv_comp_eq] at this\n  exact concrete_category.congr_hom this x\n#align pi_iso_pi_hom_apply pi_iso_pi_hom_apply\n\n",
 "limit_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem limit_topology (F : «expr ⥤ » J TopCat.{max v u}) :\n    (limit F).topological_space =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((F.obj j).topological_space.induced (limit.π F j)) :=\n  induced_of_isLimit _ (limit.isLimit F)\n#align limit_topology limit_topology\n\n",
 "inducing_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem inducing_prod_map {W X Y Z : TopCat} {f : «expr ⟶ » W X} {g : «expr ⟶ » Y Z} (hf : Inducing f)\n    (hg : Inducing g) : Inducing (Limits.prod.map f g) :=\n  by\n  constructor\n  simp only [prod_topology, induced_compose, ← coe_comp, limits.prod.map_fst, limits.prod.map_snd, induced_inf]\n  simp only [coe_comp]\n  rw [← @induced_compose _ _ _ _ _ f, ← @induced_compose _ _ _ _ _ g, ← hf.induced, ← hg.induced]\n#align inducing_prod_map inducing_prod_map\n\n",
 "induced_of_is_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem induced_of_is_limit {F : «expr ⥤ » J TopCat.{max v u}} (C : Cone F) (hC : IsLimit C) :\n    C.X.topological_space =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((F.obj j).topological_space.induced (C.π.app j)) :=\n  by\n  let homeo := homeo_of_iso (hC.cone_point_unique_up_to_iso (limit_cone_infi_is_limit F))\n  refine' homeo.inducing.induced.trans _\n  change\n    induced homeo («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" _) =\n      _\n  simpa [induced_infᵢ, induced_compose]\n#align induced_of_is_limit induced_of_is_limit\n\n",
 "embedding_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem embedding_prod_map {W X Y Z : TopCat} {f : «expr ⟶ » W X} {g : «expr ⟶ » Y Z} (hf : Embedding f)\n    (hg : Embedding g) : Embedding (Limits.prod.map f g) :=\n  ⟨inducing_prod_map hf.to_inducing hg.to_inducing,\n    by\n    haveI := (TopCat.mono_iff_injective _).mpr hf.inj\n    haveI := (TopCat.mono_iff_injective _).mpr hg.inj\n    exact (TopCat.mono_iff_injective _).mp inferInstance⟩\n#align embedding_prod_map embedding_prod_map\n\n",
 "binary_cofan_is_colimit_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem binary_cofan_is_colimit_iff {X Y : TopCat} (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) ↔ OpenEmbedding c.inl ∧ OpenEmbedding c.inr ∧ IsCompl (Set.range c.inl) (Set.range c.inr) :=\n  by\n  classical\n    constructor\n    · rintro ⟨h⟩\n      rw [←\n        show _ = c.inl from h.comp_cocone_point_unique_up_to_iso_inv (binary_cofan_is_colimit X Y) ⟨walking_pair.left⟩,\n        ←\n        show _ = c.inr from h.comp_cocone_point_unique_up_to_iso_inv (binary_cofan_is_colimit X Y) ⟨walking_pair.right⟩]\n      dsimp\n      refine'\n        ⟨(homeo_of_iso <| h.cocone_point_unique_up_to_iso (binary_cofan_is_colimit X Y)).symm.open_embedding.comp\n            openEmbedding_inl,\n          (homeo_of_iso <| h.cocone_point_unique_up_to_iso (binary_cofan_is_colimit X Y)).symm.open_embedding.comp\n            openEmbedding_inr,\n          _⟩\n      erw [Set.range_comp, ← eq_compl_iff_isCompl, Set.range_comp _ Sum.inr, ←\n        Set.image_compl_eq\n          (homeo_of_iso <| h.cocone_point_unique_up_to_iso (binary_cofan_is_colimit X Y)).symm.bijective]\n      congr 1\n      exact set.compl_range_inr.symm\n    · rintro ⟨h₁, h₂, h₃⟩\n      have : ∀ x, x ∈ Set.range c.inl ∨ x ∈ Set.range c.inr :=\n        by\n        rw [eq_compl_iff_is_compl.mpr h₃.symm]\n        exact fun _ => or_not\n      refine' ⟨binary_cofan.is_colimit.mk _ _ _ _ _⟩\n      · intro T f g\n        refine' continuous_map.mk _ _\n        ·\n          exact fun x =>\n            if h : x ∈ Set.range c.inl then f ((Equiv.ofInjective _ h₁.inj).symm ⟨x, h⟩)\n            else g ((Equiv.ofInjective _ h₂.inj).symm ⟨x, (this x).resolve_left h⟩)\n        rw [continuous_iff_continuousAt]\n        intro x\n        by_cases x ∈ Set.range c.inl\n        · revert h x\n          apply (IsOpen.continuousOn_iff _).mp\n          · rw [continuousOn_iff_continuous_restrict]\n            convert_to Continuous (f ∘ (Homeomorph.ofEmbedding _ h₁.to_embedding).symm)\n            · ext ⟨x, hx⟩\n              exact dif_pos hx\n            continuity\n          · exact h₁.open_range\n        · revert h x\n          apply (IsOpen.continuousOn_iff _).mp\n          · rw [continuousOn_iff_continuous_restrict]\n            have : ∀ a, a ∉ Set.range c.inl → a ∈ Set.range c.inr :=\n              by\n              rintro a (h : a ∈ «expr ᶜ» (Set.range c.inl))\n              rwa [eq_compl_iff_is_compl.mpr h₃.symm]\n            convert_to Continuous (g ∘ (Homeomorph.ofEmbedding _ h₂.to_embedding).symm ∘ Subtype.map _ this)\n            · ext ⟨x, hx⟩\n              exact dif_neg hx\n            continuity\n            rw [embedding_subtype_coe.to_inducing.continuous_iff]\n            exact continuous_subtype_val\n          · change IsOpen («expr ᶜ» (Set.range c.inl))\n            rw [← eq_compl_iff_is_compl.mpr h₃.symm]\n            exact h₂.open_range\n      · intro T f g\n        ext x\n        refine' (dif_pos _).trans _\n        · exact ⟨x, rfl⟩\n        · rw [Equiv.ofInjective_symm_apply]\n      · intro T f g\n        ext x\n        refine' (dif_neg _).trans _\n        · rintro ⟨y, e⟩\n          have : c.inr x ∈ «expr ⊓ » (Set.range c.inl) (Set.range c.inr) := ⟨⟨_, e⟩, ⟨_, rfl⟩⟩\n          rwa [disjoint_iff.mp h₃.1] at this\n        · exact congr_arg g (Equiv.ofInjective_symm_apply _ _)\n      · rintro T _ _ m rfl rfl\n        ext x\n        change m x = dite _ _ _\n        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ ⟨_, _⟩).symm\n#align binary_cofan_is_colimit_iff binary_cofan_is_colimit_iff\n\n"}