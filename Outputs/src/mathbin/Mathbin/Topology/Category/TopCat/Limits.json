{"snd_open_embedding_of_left_open_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem snd_open_embedding_of_left_open_embedding {X Y S : Top} {f : Â«expr âŸ¶ Â» X S} (H : open_embedding f)\n    (g : Â«expr âŸ¶ Â» Y S) : open_embedding (Â«exprâ‡‘ Â» (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) Y)) :=\n  by\n  convert\n    (homeo_of_iso (as_iso (pullback.snd : Â«expr âŸ¶ Â» (pullback ((Â«exprğŸ™Â») S) g) _))).open_embedding.comp\n      (pullback_map_open_embedding_of_open_embeddings f g ((Â«exprğŸ™Â») _) g H (homeo_of_iso (iso.refl _)).open_embedding\n        ((Â«exprğŸ™Â») _) rfl (by simp))\n  erw [â† coe_comp]\n  simp\n#align snd_open_embedding_of_left_open_embedding snd_open_embedding_of_left_open_embedding\n\n",
 "snd_iso_of_left_embedding_range_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚œ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem snd_iso_of_left_embedding_range_subset {X Y S : Top} {f : Â«expr âŸ¶ Â» X S} (hf : embedding f) (g : Â«expr âŸ¶ Â» Y S)\n    (H : Set.range g âŠ† Set.range f) : IsIso (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) Y) :=\n  by\n  let this : Â«expr â‰ƒâ‚œ Â» (pullback f g : Top) Y :=\n    (homeomorph.of_embedding _ (snd_embedding_of_left_embedding hf g)).trans\n      { to_fun := coe\n        inv_fun := fun x =>\n          âŸ¨x, by\n            rw [pullback_snd_range]\n            exact âŸ¨_, (H (Set.mem_range_self x)).some_specâŸ©âŸ©\n        left_inv := fun âŸ¨_, _âŸ© => rfl\n        right_inv := fun x => rfl }\n  convert is_iso.of_iso (iso_of_homeo this)\n  ext\n  rfl\n#align snd_iso_of_left_embedding_range_subset snd_iso_of_left_embedding_range_subset\n\n",
 "snd_embedding_of_left_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem snd_embedding_of_left_embedding {X Y S : Top} {f : Â«expr âŸ¶ Â» X S} (H : embedding f) (g : Â«expr âŸ¶ Â» Y S) :\n    embedding (Â«exprâ‡‘ Â» (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) Y)) :=\n  by\n  convert\n    (homeo_of_iso (as_iso (pullback.snd : Â«expr âŸ¶ Â» (pullback ((Â«exprğŸ™Â») S) g) _))).embedding.comp\n      (pullback_map_embedding_of_embeddings f g ((Â«exprğŸ™Â») _) g H (homeo_of_iso (iso.refl _)).embedding ((Â«exprğŸ™Â») _)\n        rfl (by simp))\n  erw [â† coe_comp]\n  simp\n#align snd_embedding_of_left_embedding snd_embedding_of_left_embedding\n\n",
 "sigma_iso_sigma_inv_apply":
 "@[simp]\ntheorem sigma_iso_sigma_inv_apply {Î¹ : Type v} (Î± : Î¹ â†’ Top.{max v u}) (i : Î¹) (x : Î± i) :\n    (sigma_iso_sigma Î±).inv âŸ¨i, xâŸ© = (sigma.Î¹ Î± i : _) x :=\n  by\n  rw [â† sigma_iso_sigma_hom_Î¹_apply, â† comp_app]\n  simp\n#align sigma_iso_sigma_inv_apply sigma_iso_sigma_inv_apply\n\n",
 "sigma_iso_sigma_hom_Î¹_apply":
 "@[simp]\ntheorem sigma_iso_sigma_hom_Î¹_apply {Î¹ : Type v} (Î± : Î¹ â†’ Top.{max v u}) (i : Î¹) (x : Î± i) :\n    (sigma_iso_sigma Î±).hom ((sigma.Î¹ Î± i : _) x) = sigma.mk i x :=\n  concrete_category.congr_hom (sigma_iso_sigma_hom_Î¹ Î± i) x\n#align sigma_iso_sigma_hom_Î¹_apply sigma_iso_sigma_hom_Î¹_apply\n\n",
 "sigma_iso_sigma_hom_Î¹":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem sigma_iso_sigma_hom_Î¹ {Î¹ : Type v} (Î± : Î¹ â†’ Top.{max v u}) (i : Î¹) :\n    Â«expr â‰« Â» (sigma.Î¹ Î± i) (sigma_iso_sigma Î±).hom = sigma_Î¹ Î± i := by simp [sigma_iso_sigma]\n#align sigma_iso_sigma_hom_Î¹ sigma_iso_sigma_hom_Î¹\n\n",
 "range_pullback_to_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem range_pullback_to_prod {X Y Z : Top} (f : Â«expr âŸ¶ Â» X Z) (g : Â«expr âŸ¶ Â» Y Z) :\n    Set.range (prod.lift pullback.fst pullback.snd : Â«expr âŸ¶ Â» (pullback f g) (Â«expr â¨¯ Â» X Y)) =\n      { x | (Â«expr â‰« Â» limits.prod.fst f) x = (Â«expr â‰« Â» limits.prod.snd g) x } :=\n  by\n  ext x\n  constructor\n  Â· rintro âŸ¨y, rflâŸ©\n    simp only [â† comp_apply, Set.mem_setOf_eq]\n    congr 1\n    simp [pullback.condition]\n  Â· intro h\n    use (pullback_iso_prod_subtype f g).inv âŸ¨âŸ¨_, _âŸ©, hâŸ©\n    apply concrete.limit_ext\n    rintro âŸ¨âŸ¨âŸ©âŸ© <;> simp\n#align range_pullback_to_prod range_pullback_to_prod\n\n",
 "range_pullback_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If the map `S âŸ¶ T` is mono, then there is a description of the image of `W Ã—â‚› X âŸ¶ Y Ã—â‚œ Z`. -/\ntheorem range_pullback_map {W X Y Z S T : Top} (fâ‚ : Â«expr âŸ¶ Â» W S) (fâ‚‚ : Â«expr âŸ¶ Â» X S) (gâ‚ : Â«expr âŸ¶ Â» Y T)\n    (gâ‚‚ : Â«expr âŸ¶ Â» Z T) (iâ‚ : Â«expr âŸ¶ Â» W Y) (iâ‚‚ : Â«expr âŸ¶ Â» X Z) (iâ‚ƒ : Â«expr âŸ¶ Â» S T) [Hâ‚ƒ : Mono iâ‚ƒ]\n    (eqâ‚ : Â«expr â‰« Â» fâ‚ iâ‚ƒ = Â«expr â‰« Â» iâ‚ gâ‚) (eqâ‚‚ : Â«expr â‰« Â» fâ‚‚ iâ‚ƒ = Â«expr â‰« Â» iâ‚‚ gâ‚‚) :\n    Set.range (pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚) =\n      Â«expr â»Â¹' Â» (pullback.fst : Â«expr âŸ¶ Â» (pullback gâ‚ gâ‚‚) _) (Set.range iâ‚) âˆ©\n        Â«expr â»Â¹' Â» (pullback.snd : Â«expr âŸ¶ Â» (pullback gâ‚ gâ‚‚) _) (Set.range iâ‚‚) :=\n  by\n  ext\n  constructor\n  Â· rintro âŸ¨y, rflâŸ©\n    simp\n  rintro âŸ¨âŸ¨xâ‚, hxâ‚âŸ©, âŸ¨xâ‚‚, hxâ‚‚âŸ©âŸ©\n  have : fâ‚ xâ‚ = fâ‚‚ xâ‚‚ := by\n    apply (Top.mono_iff_injective _).mp Hâ‚ƒ\n    simp only [â† comp_apply, eqâ‚, eqâ‚‚]\n    simp only [comp_apply, hxâ‚, hxâ‚‚]\n    simp only [â† comp_apply, pullback.condition]\n  use (pullback_iso_prod_subtype fâ‚ fâ‚‚).inv âŸ¨âŸ¨xâ‚, xâ‚‚âŸ©, thisâŸ©\n  apply concrete.limit_ext\n  rintro (_ | _ | _)\n  Â· simp only [Top.comp_app, limit.lift_Ï€_apply, category.assoc, pullback_cone.mk_Ï€_app_one, hxâ‚,\n      pullback_iso_prod_subtype_inv_fst_apply, subtype.coe_mk]\n    simp only [â† comp_apply]\n    congr\n    apply limit.w _ walking_cospan.hom.inl\n  Â· simp [hxâ‚]\n  Â· simp [hxâ‚‚]\n#align range_pullback_map range_pullback_map\n\n",
 "range_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\ntheorem range_prod_map {W X Y Z : Top.{u}} (f : Â«expr âŸ¶ Â» W Y) (g : Â«expr âŸ¶ Â» X Z) :\n    Set.range (limits.prod.map f g) =\n      Â«expr â»Â¹' Â» (limits.prod.fst : Â«expr âŸ¶ Â» (Â«expr â¨¯ Â» Y Z) _) (Set.range f) âˆ©\n        Â«expr â»Â¹' Â» (limits.prod.snd : Â«expr âŸ¶ Â» (Â«expr â¨¯ Â» Y Z) _) (Set.range g) :=\n  by\n  ext\n  constructor\n  Â· rintro âŸ¨y, rflâŸ©\n    simp only [Set.mem_preimage, Set.mem_range, Set.mem_inter_iff, â† comp_apply]\n    simp only [limits.prod.map_fst, limits.prod.map_snd, exists_apply_eq_apply, comp_apply, and_self_iff]\n  Â· rintro âŸ¨âŸ¨xâ‚, hxâ‚âŸ©, âŸ¨xâ‚‚, hxâ‚‚âŸ©âŸ©\n    use (prod_iso_prod W X).inv (xâ‚, xâ‚‚)\n    apply concrete.limit_ext\n    rintro âŸ¨âŸ¨âŸ©âŸ©\n    Â· simp only [â† comp_apply, category.assoc]\n      erw [limits.prod.map_fst]\n      simp [hxâ‚]\n    Â· simp only [â† comp_apply, category.assoc]\n      erw [limits.prod.map_snd]\n      simp [hxâ‚‚]\n#align range_prod_map range_prod_map\n\n",
 "pullback_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem pullback_topology {X Y Z : Top.{u}} (f : Â«expr âŸ¶ Â» X Z) (g : Â«expr âŸ¶ Â» Y Z) :\n    (pullback f g).topological_space =\n      Â«expr âŠ“ Â» (induced (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) _) X.topological_space)\n        (induced (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _) Y.topological_space) :=\n  by\n  let homeo := homeo_of_iso (pullback_iso_prod_subtype f g)\n  refine' homeo.inducing.induced.trans _\n  change induced homeo (induced _ (Â«expr âŠ“ Â» _ _)) = _\n  simpa [induced_compose]\n#align pullback_topology pullback_topology\n\n",
 "pullback_snd_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem pullback_snd_range {X Y S : Top} (f : Â«expr âŸ¶ Â» X S) (g : Â«expr âŸ¶ Â» Y S) :\n    Set.range (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _) = { y : Y | âˆƒ x : X, f x = g y } :=\n  by\n  ext y\n  constructor\n  Â· rintro âŸ¨x, rflâŸ©\n    use (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) _) x\n    exact concrete_category.congr_hom pullback.condition x\n  Â· rintro âŸ¨x, eqâŸ©\n    use (Top.pullback_iso_prod_subtype f g).inv âŸ¨âŸ¨x, yâŸ©, eqâŸ©\n    simp\n#align pullback_snd_range pullback_snd_range\n\n",
 "pullback_snd_image_fst_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem pullback_snd_image_fst_preimage (f : Â«expr âŸ¶ Â» X Z) (g : Â«expr âŸ¶ Â» Y Z) (U : set X) :\n    Â«expr '' Â» (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _) (Â«expr â»Â¹' Â» (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) _) U) =\n      Â«expr â»Â¹' Â» g (Â«expr '' Â» f U) :=\n  by\n  ext x\n  constructor\n  Â· rintro âŸ¨y, hy, rflâŸ©\n    exact âŸ¨(pullback.fst : Â«expr âŸ¶ Â» (pullback f g) _) y, hy, concrete_category.congr_hom pullback.condition yâŸ©\n  Â· rintro âŸ¨y, hy, eqâŸ©\n    exact âŸ¨(Top.pullback_iso_prod_subtype f g).inv âŸ¨âŸ¨_, _âŸ©, eqâŸ©, by simpa, by simpâŸ©\n#align pullback_snd_image_fst_preimage pullback_snd_image_fst_preimage\n\n",
 "pullback_map_open_embedding_of_open_embeddings":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- If there is a diagram where the morphisms `W âŸ¶ Y` and `X âŸ¶ Z` are open embeddings, and `S âŸ¶ T`\nis mono, then the induced morphism `W Ã—â‚› X âŸ¶ Y Ã—â‚œ Z` is also an open embedding.\n  W  âŸ¶  Y\n    â†˜      â†˜\n      S  âŸ¶  T\n    â†—       â†—\n  X  âŸ¶  Z\n-/\ntheorem pullback_map_open_embedding_of_open_embeddings {W X Y Z S T : Top} (fâ‚ : Â«expr âŸ¶ Â» W S) (fâ‚‚ : Â«expr âŸ¶ Â» X S)\n    (gâ‚ : Â«expr âŸ¶ Â» Y T) (gâ‚‚ : Â«expr âŸ¶ Â» Z T) {iâ‚ : Â«expr âŸ¶ Â» W Y} {iâ‚‚ : Â«expr âŸ¶ Â» X Z} (Hâ‚ : open_embedding iâ‚)\n    (Hâ‚‚ : open_embedding iâ‚‚) (iâ‚ƒ : Â«expr âŸ¶ Â» S T) [Hâ‚ƒ : Mono iâ‚ƒ] (eqâ‚ : Â«expr â‰« Â» fâ‚ iâ‚ƒ = Â«expr â‰« Â» iâ‚ gâ‚)\n    (eqâ‚‚ : Â«expr â‰« Â» fâ‚‚ iâ‚ƒ = Â«expr â‰« Â» iâ‚‚ gâ‚‚) : open_embedding (pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚) :=\n  by\n  constructor\n  Â· apply pullback_map_embedding_of_embeddings fâ‚ fâ‚‚ gâ‚ gâ‚‚ Hâ‚.to_embedding Hâ‚‚.to_embedding iâ‚ƒ eqâ‚ eqâ‚‚\n  Â· rw [range_pullback_map]\n    apply is_open.inter <;> apply continuous.is_open_preimage\n    continuity\n    exacts[Hâ‚.open_range, Hâ‚‚.open_range]\n#align pullback_map_open_embedding_of_open_embeddings pullback_map_open_embedding_of_open_embeddings\n\n",
 "pullback_map_embedding_of_embeddings":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- If there is a diagram where the morphisms `W âŸ¶ Y` and `X âŸ¶ Z` are embeddings,\nthen the induced morphism `W Ã—â‚› X âŸ¶ Y Ã—â‚œ Z` is also an embedding.\n\n  W  âŸ¶  Y\n    â†˜      â†˜\n      S  âŸ¶  T\n    â†—      â†—\n  X  âŸ¶  Z\n-/\ntheorem pullback_map_embedding_of_embeddings {W X Y Z S T : Top} (fâ‚ : Â«expr âŸ¶ Â» W S) (fâ‚‚ : Â«expr âŸ¶ Â» X S)\n    (gâ‚ : Â«expr âŸ¶ Â» Y T) (gâ‚‚ : Â«expr âŸ¶ Â» Z T) {iâ‚ : Â«expr âŸ¶ Â» W Y} {iâ‚‚ : Â«expr âŸ¶ Â» X Z} (Hâ‚ : embedding iâ‚)\n    (Hâ‚‚ : embedding iâ‚‚) (iâ‚ƒ : Â«expr âŸ¶ Â» S T) (eqâ‚ : Â«expr â‰« Â» fâ‚ iâ‚ƒ = Â«expr â‰« Â» iâ‚ gâ‚)\n    (eqâ‚‚ : Â«expr â‰« Â» fâ‚‚ iâ‚ƒ = Â«expr â‰« Â» iâ‚‚ gâ‚‚) : embedding (pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚) :=\n  by\n  refine'\n    embedding_of_embedding_compose (continuous_map.continuous_to_fun _)\n      (show continuous (prod.lift pullback.fst pullback.snd : Â«expr âŸ¶ Â» (pullback gâ‚ gâ‚‚) (Â«expr â¨¯ Â» Y Z)) from\n        continuous_map.continuous_to_fun _)\n      _\n  suffices\n    embedding (Â«expr â‰« Â» (prod.lift pullback.fst pullback.snd) (limits.prod.map iâ‚ iâ‚‚) : Â«expr âŸ¶ Â» (pullback fâ‚ fâ‚‚) _)\n    by simpa [â† coe_comp] using this\n  rw [coe_comp]\n  refine' embedding.comp (embedding_prod_map Hâ‚ Hâ‚‚) (embedding_pullback_to_prod _ _)\n#align pullback_map_embedding_of_embeddings pullback_map_embedding_of_embeddings\n\n",
 "pullback_iso_prod_subtype_inv_snd_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem pullback_iso_prod_subtype_inv_snd_apply (f : Â«expr âŸ¶ Â» X Z) (g : Â«expr âŸ¶ Â» Y Z)\n    (x : { p : X Ã— Y // f p.1 = g p.2 }) :\n    (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _) ((pullback_iso_prod_subtype f g).inv x) = (x : X Ã— Y).snd :=\n  concrete_category.congr_hom (pullback_iso_prod_subtype_inv_snd f g) x\n#align pullback_iso_prod_subtype_inv_snd_apply pullback_iso_prod_subtype_inv_snd_apply\n\n",
 "pullback_iso_prod_subtype_inv_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem pullback_iso_prod_subtype_inv_snd (f : Â«expr âŸ¶ Â» X Z) (g : Â«expr âŸ¶ Â» Y Z) :\n    Â«expr â‰« Â» (pullback_iso_prod_subtype f g).inv pullback.snd = pullback_snd f g := by\n  simpa [pullback_iso_prod_subtype]\n#align pullback_iso_prod_subtype_inv_snd pullback_iso_prod_subtype_inv_snd\n\n",
 "pullback_iso_prod_subtype_inv_fst_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem pullback_iso_prod_subtype_inv_fst_apply (f : Â«expr âŸ¶ Â» X Z) (g : Â«expr âŸ¶ Â» Y Z)\n    (x : { p : X Ã— Y // f p.1 = g p.2 }) :\n    (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) _) ((pullback_iso_prod_subtype f g).inv x) = (x : X Ã— Y).fst :=\n  concrete_category.congr_hom (pullback_iso_prod_subtype_inv_fst f g) x\n#align pullback_iso_prod_subtype_inv_fst_apply pullback_iso_prod_subtype_inv_fst_apply\n\n",
 "pullback_iso_prod_subtype_inv_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem pullback_iso_prod_subtype_inv_fst (f : Â«expr âŸ¶ Â» X Z) (g : Â«expr âŸ¶ Â» Y Z) :\n    Â«expr â‰« Â» (pullback_iso_prod_subtype f g).inv pullback.fst = pullback_fst f g := by\n  simpa [pullback_iso_prod_subtype]\n#align pullback_iso_prod_subtype_inv_fst pullback_iso_prod_subtype_inv_fst\n\n",
 "pullback_iso_prod_subtype_hom_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem pullback_iso_prod_subtype_hom_snd (f : Â«expr âŸ¶ Â» X Z) (g : Â«expr âŸ¶ Â» Y Z) :\n    Â«expr â‰« Â» (pullback_iso_prod_subtype f g).hom (pullback_snd f g) = pullback.snd := by\n  rw [â† iso.eq_inv_comp, pullback_iso_prod_subtype_inv_snd]\n#align pullback_iso_prod_subtype_hom_snd pullback_iso_prod_subtype_hom_snd\n\n",
 "pullback_iso_prod_subtype_hom_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem pullback_iso_prod_subtype_hom_fst (f : Â«expr âŸ¶ Â» X Z) (g : Â«expr âŸ¶ Â» Y Z) :\n    Â«expr â‰« Â» (pullback_iso_prod_subtype f g).hom (pullback_fst f g) = pullback.fst := by\n  rw [â† iso.eq_inv_comp, pullback_iso_prod_subtype_inv_fst]\n#align pullback_iso_prod_subtype_hom_fst pullback_iso_prod_subtype_hom_fst\n\n",
 "pullback_iso_prod_subtype_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem pullback_iso_prod_subtype_hom_apply {f : Â«expr âŸ¶ Â» X Z} {g : Â«expr âŸ¶ Â» Y Z} (x : pullback f g) :\n    (pullback_iso_prod_subtype f g).hom x =\n      âŸ¨âŸ¨(pullback.fst : Â«expr âŸ¶ Â» (pullback f g) _) x, (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _) xâŸ©, by\n        simpa using concrete_category.congr_hom pullback.condition xâŸ© :=\n  by\n  ext\n  exacts[concrete_category.congr_hom (pullback_iso_prod_subtype_hom_fst f g) x,\n    concrete_category.congr_hom (pullback_iso_prod_subtype_hom_snd f g) x]\n#align pullback_iso_prod_subtype_hom_apply pullback_iso_prod_subtype_hom_apply\n\n",
 "pullback_fst_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem pullback_fst_range {X Y S : Top} (f : Â«expr âŸ¶ Â» X S) (g : Â«expr âŸ¶ Â» Y S) :\n    Set.range (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) _) = { x : X | âˆƒ y : Y, f x = g y } :=\n  by\n  ext x\n  constructor\n  Â· rintro âŸ¨y, rflâŸ©\n    use (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _) y\n    exact concrete_category.congr_hom pullback.condition y\n  Â· rintro âŸ¨y, eqâŸ©\n    use (Top.pullback_iso_prod_subtype f g).inv âŸ¨âŸ¨x, yâŸ©, eqâŸ©\n    simp\n#align pullback_fst_range pullback_fst_range\n\n",
 "pullback_fst_image_snd_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem pullback_fst_image_snd_preimage (f : Â«expr âŸ¶ Â» X Z) (g : Â«expr âŸ¶ Â» Y Z) (U : set Y) :\n    Â«expr '' Â» (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) _) (Â«expr â»Â¹' Â» (pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _) U) =\n      Â«expr â»Â¹' Â» f (Â«expr '' Â» g U) :=\n  by\n  ext x\n  constructor\n  Â· rintro âŸ¨y, hy, rflâŸ©\n    exact âŸ¨(pullback.snd : Â«expr âŸ¶ Â» (pullback f g) _) y, hy, (concrete_category.congr_hom pullback.condition y).symmâŸ©\n  Â· rintro âŸ¨y, hy, eqâŸ©\n    exact âŸ¨(Top.pullback_iso_prod_subtype f g).inv âŸ¨âŸ¨_, _âŸ©, eq.symmâŸ©, by simpa, by simpâŸ©\n#align pullback_fst_image_snd_preimage pullback_fst_image_snd_preimage\n\n",
 "prod_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\ntheorem prod_topology {X Y : Top} :\n    (Â«expr â¨¯ Â» X Y).topological_space =\n      Â«expr âŠ“ Â» (induced (limits.prod.fst : Â«expr âŸ¶ Â» (Â«expr â¨¯ Â» X Y) _) X.topological_space)\n        (induced (limits.prod.snd : Â«expr âŸ¶ Â» (Â«expr â¨¯ Â» X Y) _) Y.topological_space) :=\n  by\n  let homeo := homeo_of_iso (prod_iso_prod X Y)\n  refine' homeo.inducing.induced.trans _\n  change induced homeo (Â«expr âŠ“ Â» _ _) = _\n  simpa [induced_compose]\n#align prod_topology prod_topology\n\n",
 "prod_iso_prod_inv_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1, elementwise]\ntheorem prod_iso_prod_inv_snd (X Y : Top.{u}) : Â«expr â‰« Â» (prod_iso_prod X Y).inv limits.prod.snd = prod_snd := by\n  simp [iso.inv_comp_eq]\n#align prod_iso_prod_inv_snd prod_iso_prod_inv_snd\n\n",
 "prod_iso_prod_inv_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1, elementwise]\ntheorem prod_iso_prod_inv_fst (X Y : Top.{u}) : Â«expr â‰« Â» (prod_iso_prod X Y).inv limits.prod.fst = prod_fst := by\n  simp [iso.inv_comp_eq]\n#align prod_iso_prod_inv_fst prod_iso_prod_inv_fst\n\n",
 "prod_iso_prod_hom_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem prod_iso_prod_hom_snd (X Y : Top.{u}) : Â«expr â‰« Â» (prod_iso_prod X Y).hom prod_snd = limits.prod.snd := by\n  simpa [â† iso.eq_inv_comp, prod_iso_prod]\n#align prod_iso_prod_hom_snd prod_iso_prod_hom_snd\n\n",
 "prod_iso_prod_hom_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem prod_iso_prod_hom_fst (X Y : Top.{u}) : Â«expr â‰« Â» (prod_iso_prod X Y).hom prod_fst = limits.prod.fst := by\n  simpa [â† iso.eq_inv_comp, prod_iso_prod]\n#align prod_iso_prod_hom_fst prod_iso_prod_hom_fst\n\n",
 "prod_iso_prod_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\n@[simp]\ntheorem prod_iso_prod_hom_apply {X Y : Top.{u}} (x : Â«expr â¨¯ Â» X Y) :\n    (prod_iso_prod X Y).hom x =\n      ((limits.prod.fst : Â«expr âŸ¶ Â» (Â«expr â¨¯ Â» X Y) _) x, (limits.prod.snd : Â«expr âŸ¶ Â» (Â«expr â¨¯ Â» X Y) _) x) :=\n  by\n  ext\n  Â· exact concrete_category.congr_hom (prod_iso_prod_hom_fst X Y) x\n  Â· exact concrete_category.congr_hom (prod_iso_prod_hom_snd X Y) x\n#align prod_iso_prod_hom_apply prod_iso_prod_hom_apply\n\n",
 "pi_iso_pi_inv_Ï€_apply":
 "@[simp]\ntheorem pi_iso_pi_inv_Ï€_apply {Î¹ : Type v} (Î± : Î¹ â†’ Top.{max v u}) (i : Î¹) (x : âˆ€ i, Î± i) :\n    (pi.Ï€ Î± i : _) ((pi_iso_pi Î±).inv x) = x i :=\n  concrete_category.congr_hom (pi_iso_pi_inv_Ï€ Î± i) x\n#align pi_iso_pi_inv_Ï€_apply pi_iso_pi_inv_Ï€_apply\n\n",
 "pi_iso_pi_inv_Ï€":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-\nCopyright (c) 2017 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Scott Morrison, Mario Carneiro, Andrew Yang\n-/\n@[simp, reassoc.1]\ntheorem pi_iso_pi_inv_Ï€ {Î¹ : Type v} (Î± : Î¹ â†’ Top.{max v u}) (i : Î¹) :\n    Â«expr â‰« Â» (pi_iso_pi Î±).inv (pi.Ï€ Î± i) = pi_Ï€ Î± i := by simp [pi_iso_pi]\n#align pi_iso_pi_inv_Ï€ pi_iso_pi_inv_Ï€\n\n",
 "pi_iso_pi_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ Â» -/\n@[simp]\ntheorem pi_iso_pi_hom_apply {Î¹ : Type v} (Î± : Î¹ â†’ Top.{max v u}) (i : Î¹) (x : Â«exprâˆ Â» Î±) :\n    (pi_iso_pi Î±).hom x i = (pi.Ï€ Î± i : _) x :=\n  by\n  have := pi_iso_pi_inv_Ï€ Î± i\n  rw [iso.inv_comp_eq] at this\n  exact concrete_category.congr_hom this x\n#align pi_iso_pi_hom_apply pi_iso_pi_hom_apply\n\n",
 "open_embedding_of_pullback_open_embeddings":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- If `X âŸ¶ S`, `Y âŸ¶ S` are open embeddings, then so is `X Ã—â‚› Y âŸ¶ S`. -/\ntheorem open_embedding_of_pullback_open_embeddings {X Y S : Top} {f : Â«expr âŸ¶ Â» X S} {g : Â«expr âŸ¶ Â» Y S}\n    (Hâ‚ : open_embedding f) (Hâ‚‚ : open_embedding g) : open_embedding (limit.Ï€ (cospan f g) walking_cospan.one) :=\n  by\n  convert Hâ‚‚.comp (snd_open_embedding_of_left_open_embedding Hâ‚ g)\n  erw [â† coe_comp]\n  congr\n  exact (limit.w _ walking_cospan.hom.inr).symm\n#align open_embedding_of_pullback_open_embeddings open_embedding_of_pullback_open_embeddings\n\n",
 "nonempty_sections_of_fintype_inverse_system":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµ–Â» -/\n/-- The inverse limit of nonempty finite types is nonempty.\n\nSee `nonempty_sections_of_fintype_cofiltered_system` for a generalization to cofiltered limits.\nThat version applies in almost all cases, and the only difference is that this version\nallows `J` to be empty.\n\nThis may be regarded as a generalization of KÅ‘nig's lemma.\nTo specialize: given a locally finite connected graph, take `Jáµ’áµ–` to be `â„•` and\n`F j` to be length-`j` paths that start from an arbitrary fixed vertex.\nElements of `F.sections` can be read off as infinite rays in the graph. -/\ntheorem nonempty_sections_of_fintype_inverse_system {J : Type u} [preorder J] [IsDirected J (Â· â‰¤ Â·)]\n    (F : Â«expr â¥¤ Â» (Â«expr áµ’áµ–Â» J) (Type v)) [âˆ€ j : Â«expr áµ’áµ–Â» J, fintype (F.obj j)]\n    [âˆ€ j : Â«expr áµ’áµ–Â» J, nonempty (F.obj j)] : F.sections.nonempty :=\n  by\n  cases isEmpty_or_nonempty J\n  Â· haveI : is_empty (Â«expr áµ’áµ–Â» J) := âŸ¨fun j => is_empty_elim j.unopâŸ©\n    -- TODO: this should be a global instance\n    exact âŸ¨is_empty_elim, is_empty_elimâŸ©\n  Â· exact nonempty_sections_of_fintype_cofiltered_system _\n#align nonempty_sections_of_fintype_inverse_system nonempty_sections_of_fintype_inverse_system\n\n",
 "nonempty_sections_of_fintype_cofiltered_system":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-- The cofiltered limit of nonempty finite types is nonempty.\n\nSee `nonempty_sections_of_fintype_inverse_system` for a specialization to inverse limits. -/\ntheorem nonempty_sections_of_fintype_cofiltered_system {J : Type u} [Category.{w} J] [is_cofiltered J]\n    (F : Â«expr â¥¤ Â» J (Type v)) [âˆ€ j : J, fintype (F.obj j)] [âˆ€ j : J, nonempty (F.obj j)] : F.sections.nonempty :=\n  by\n  -- Step 1: lift everything to the `max u v w` universe.\n  let J' : Type max w v u := as_small.{max w v} J\n  let down : Â«expr â¥¤ Â» J' J := as_small.down\n  let F' : Â«expr â¥¤ Â» J' (Type max u v w) := Â«expr â‹™ Â» down (Â«expr â‹™ Â» F ulift_functor.{max u w, v})\n  haveI : âˆ€ i, nonempty (F'.obj i) := fun i => âŸ¨âŸ¨classical.arbitrary (F.obj (down.obj i))âŸ©âŸ©\n  haveI : âˆ€ i, fintype (F'.obj i) := fun i => fintype.of_equiv (F.obj (down.obj i)) equiv.ulift.symm\n  -- Step 2: apply the bootstrap theorem\n  obtain âŸ¨u, huâŸ© := nonempty_sections_of_fintype_cofiltered_system.init F'\n  -- Step 3: interpret the results\n  use fun j => (u âŸ¨jâŸ©).down\n  intro j j' f\n  have h := @hu (âŸ¨jâŸ© : J') (âŸ¨j'âŸ© : J') (ulift.up f)\n  simp only [as_small.down, functor.comp_map, ulift_functor_map, functor.op_map] at h\n  simp_rw [â† h]\n  rfl\n#align nonempty_sections_of_fintype_cofiltered_system nonempty_sections_of_fintype_cofiltered_system\n\n",
 "nonempty_limit_cone_of_compact_t2_cofiltered_system":
 "/-- Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces.\n-/\ntheorem nonempty_limit_cone_of_compact_t2_cofiltered_system [is_cofiltered J] [âˆ€ j : J, nonempty (F.obj j)]\n    [âˆ€ j : J, compact_space (F.obj j)] [âˆ€ j : J, t2_space (F.obj j)] : nonempty (Top.limit_cone.{u} F).X := by\n  classical\n    obtain âŸ¨u, huâŸ© :=\n      is_compact.nonempty_Inter_of_directed_nonempty_compact_closed (fun G => partial_sections F _)\n        (partial_sections.directed F) (fun G => partial_sections.nonempty F _)\n        (fun G => is_closed.is_compact (partial_sections.closed F _)) fun G => partial_sections.closed F _\n    use u\n    intro X Y f\n    let G : finite_diagram J :=\n      âŸ¨{X, Y},\n        {âŸ¨X, Y, by simp only [true_or_iff, eq_self_iff_true, Finset.mem_insert], by\n            simp only [eq_self_iff_true, or_true_iff, Finset.mem_insert, Finset.mem_singleton], fâŸ©}âŸ©\n    exact hu _ âŸ¨G, rflâŸ© (Finset.mem_singleton_self _)\n#align nonempty_limit_cone_of_compact_t2_cofiltered_system nonempty_limit_cone_of_compact_t2_cofiltered_system\n\n",
 "nonempty":
 "theorem partial_sections.nonempty [is_cofiltered J] [h : âˆ€ j : J, nonempty (F.obj j)] {G : Finset J}\n    (H : Finset (finite_diagram_arrow G)) : (partial_sections F H).nonempty := by\n  classical\n    use fun j : J =>\n      if hj : j âˆˆ G then F.map (is_cofiltered.inf_to G H hj) (h (is_cofiltered.inf G H)).some else (h _).some\n    rintro âŸ¨X, Y, hX, hY, fâŸ© hf\n    dsimp only\n    rwa [dif_pos hX, dif_pos hY, â† comp_app, â† F.map_comp, @is_cofiltered.inf_to_commutes _ _ _ G H]\n#align partial_sections.nonempty partial_sections.nonempty\n\n",
 "limit_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\ntheorem limit_topology (F : Â«expr â¥¤ Â» J Top.{max v u}) :\n    (limit F).topological_space =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((F.obj j).topological_space.induced (limit.Ï€ F j)) :=\n  induced_of_is_limit _ (limit.is_limit F)\n#align limit_topology limit_topology\n\n",
 "is_topological_basis_cofiltered_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- Given a *compatible* collection of topological bases for the factors in a cofiltered limit\nwhich contain `set.univ` and are closed under intersections, the induced *naive* collection\nof sets in the limit is, in fact, a topological basis.\n-/\ntheorem is_topological_basis_cofiltered_limit (T : âˆ€ j, set (set (F.obj j))) (hT : âˆ€ j, is_topological_basis (T j))\n    (univ : âˆ€ i : J, Set.univ âˆˆ T i) (inter : âˆ€ (i) (U1 U2 : set (F.obj i)), U1 âˆˆ T i â†’ U2 âˆˆ T i â†’ U1 âˆ© U2 âˆˆ T i)\n    (compat : âˆ€ (i j : J) (f : Â«expr âŸ¶ Â» i j) (V : set (F.obj j)) (hV : V âˆˆ T j), Â«expr â»Â¹' Â» (F.map f) V âˆˆ T i) :\n    is_topological_basis { U : set C.X | âˆƒ (j : _)(V : set (F.obj j)), V âˆˆ T j âˆ§ U = Â«expr â»Â¹' Â» (C.Ï€.app j) V } := by\n  classical\n    -- The limit cone for `F` whose topology is defined as an infimum.\n    let D := limit_cone_infi F\n    -- The isomorphism between the cone point of `C` and the cone point of `D`.\n    let E : Â«expr â‰… Â» C.X D.X := hC.cone_point_unique_up_to_iso (limit_cone_infi_is_limit _)\n    have hE : inducing E.hom := (Top.homeo_of_iso E).inducing\n    -- Reduce to the assertion of the theorem with `D` instead of `C`.\n    suffices\n      is_topological_basis { U : set D.X | âˆƒ (j : _)(V : set (F.obj j)), V âˆˆ T j âˆ§ U = Â«expr â»Â¹' Â» (D.Ï€.app j) V }\n      by\n      convert this.inducing hE\n      ext U0\n      constructor\n      Â· rintro âŸ¨j, V, hV, rflâŸ©\n        refine' âŸ¨Â«expr â»Â¹' Â» (D.Ï€.app j) V, âŸ¨j, V, hV, rflâŸ©, rflâŸ©\n      Â· rintro âŸ¨W, âŸ¨j, V, hV, rflâŸ©, rflâŸ©\n        refine' âŸ¨j, V, hV, rflâŸ©\n    -- Using `D`, we can apply the characterization of the topological basis of a\n    -- topology defined as an infimum...\n    convert is_topological_basis_infi hT fun j (x : D.X) => D.Ï€.app j x\n    ext U0\n    constructor\n    Â· rintro âŸ¨j, V, hV, rflâŸ©\n      let U : âˆ€ i, set (F.obj i) := fun i =>\n        if h : i = j then by\n          rw [h]\n          exact V\n        else Set.univ\n      refine' âŸ¨U, {j}, _, _âŸ©\n      Â· rintro i h\n        rw [Finset.mem_singleton] at h\n        dsimp [U]\n        rw [dif_pos h]\n        subst h\n        exact hV\n      Â· dsimp [U]\n        simp\n    Â· rintro âŸ¨U, G, h1, h2âŸ©\n      obtain âŸ¨j, hjâŸ© := is_cofiltered.inf_objs_exists G\n      let g : âˆ€ (e) (he : e âˆˆ G), Â«expr âŸ¶ Â» j e := fun _ he => (hj he).some\n      let Vs : J â†’ set (F.obj j) := fun e => if h : e âˆˆ G then Â«expr â»Â¹' Â» (F.map (g e h)) (U e) else Set.univ\n      let V : set (F.obj j) :=\n        Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (Vs e)\n      refine' âŸ¨j, V, _, _âŸ©\n      Â· -- An intermediate claim used to apply induction along `G : finset J` later on.\n        have :\n          âˆ€ (S : set (set (F.obj j))) (E : Finset J) (P : J â†’ set (F.obj j)) (univ : Set.univ âˆˆ S)\n            (inter : âˆ€ A B : set (F.obj j), A âˆˆ S â†’ B âˆˆ S â†’ A âˆ© B âˆˆ S) (cond : âˆ€ (e : J) (he : e âˆˆ E), P e âˆˆ S),\n            Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (P e) âˆˆ S :=\n          by\n          intro S E\n          apply E.induction_on\n          Â· intro P he hh\n            simpa\n          Â· intro a E ha hh1 hh2 hh3 hh4 hh5\n            rw [finset.set_bInter_insert]\n            refine' hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 _)\n            intro e he\n            exact hh5 e (Finset.mem_insert_of_mem he)\n        -- use the intermediate claim to finish off the goal using `univ` and `inter`.\n        refine' this _ _ _ (univ _) (inter _) _\n        intro e he\n        dsimp [Vs]\n        rw [dif_pos he]\n        exact compat j e (g e he) (U e) (h1 e he)\n      Â· -- conclude...\n        rw [h2]\n        dsimp [V]\n        rw [Set.preimage_interáµ¢]\n        congr 1\n        ext1 e\n        rw [Set.preimage_interáµ¢]\n        congr 1\n        ext1 he\n        dsimp [Vs]\n        rw [dif_pos he, â† Set.preimage_comp]\n        congr 1\n        change _ = Â«exprâ‡‘ Â» (Â«expr â‰« Â» (D.Ï€.app j) (F.map (g e he)))\n        rw [D.w]\n#align is_topological_basis_cofiltered_limit is_topological_basis_cofiltered_limit\n\n",
 "init":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/-- This bootstraps `nonempty_sections_of_fintype_inverse_system`. In this version,\nthe `F` functor is between categories of the same universe, and it is an easy\ncorollary to `Top.nonempty_limit_cone_of_compact_t2_inverse_system`. -/\ntheorem nonempty_sections_of_fintype_cofiltered_system.init {J : Type u} [SmallCategory J] [is_cofiltered J]\n    (F : Â«expr â¥¤ Â» J (Type u)) [hf : âˆ€ j : J, fintype (F.obj j)] [hne : âˆ€ j : J, nonempty (F.obj j)] :\n    F.sections.nonempty := by\n  let F' : Â«expr â¥¤ Â» J Top := Â«expr â‹™ Â» F Top.discrete\n  haveI : âˆ€ j : J, fintype (F'.obj j) := hf\n  haveI : âˆ€ j : J, nonempty (F'.obj j) := hne\n  obtain âŸ¨âŸ¨u, huâŸ©âŸ© := Top.nonempty_limit_cone_of_compact_t2_cofiltered_system F'\n  exact âŸ¨u, fun _ _ f => hu fâŸ©\n#align nonempty_sections_of_fintype_cofiltered_system.init nonempty_sections_of_fintype_cofiltered_system.init\n\n",
 "inducing_pullback_to_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\ntheorem inducing_pullback_to_prod {X Y Z : Top} (f : Â«expr âŸ¶ Â» X Z) (g : Â«expr âŸ¶ Â» Y Z) :\n    inducing (Â«exprâ‡‘ Â» (prod.lift pullback.fst pullback.snd : Â«expr âŸ¶ Â» (pullback f g) (Â«expr â¨¯ Â» X Y))) :=\n  âŸ¨by simp [prod_topology, pullback_topology, induced_compose, â† coe_comp]âŸ©\n#align inducing_pullback_to_prod inducing_pullback_to_prod\n\n",
 "inducing_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem inducing_prod_map {W X Y Z : Top} {f : Â«expr âŸ¶ Â» W X} {g : Â«expr âŸ¶ Â» Y Z} (hf : inducing f) (hg : inducing g) :\n    inducing (limits.prod.map f g) := by\n  constructor\n  simp only [prod_topology, induced_compose, â† coe_comp, limits.prod.map_fst, limits.prod.map_snd, induced_inf]\n  simp only [coe_comp]\n  rw [â† @induced_compose _ _ _ _ _ f, â† @induced_compose _ _ _ _ _ g, â† hf.induced, â† hg.induced]\n#align inducing_prod_map inducing_prod_map\n\n",
 "induced_of_is_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\ntheorem induced_of_is_limit {F : Â«expr â¥¤ Â» J Top.{max v u}} (C : cone F) (hC : is_limit C) :\n    C.X.topological_space =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((F.obj j).topological_space.induced (C.Ï€.app j)) :=\n  by\n  let homeo := homeo_of_iso (hC.cone_point_unique_up_to_iso (limit_cone_infi_is_limit F))\n  refine' homeo.inducing.induced.trans _\n  change\n    induced homeo (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" _) =\n      _\n  simpa [induced_infi, induced_compose]\n#align induced_of_is_limit induced_of_is_limit\n\n",
 "fst_open_embedding_of_right_open_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem fst_open_embedding_of_right_open_embedding {X Y S : Top} (f : Â«expr âŸ¶ Â» X S) {g : Â«expr âŸ¶ Â» Y S}\n    (H : open_embedding g) : open_embedding (Â«exprâ‡‘ Â» (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) X)) :=\n  by\n  convert\n    (homeo_of_iso (as_iso (pullback.fst : Â«expr âŸ¶ Â» (pullback f ((Â«exprğŸ™Â») S)) _))).open_embedding.comp\n      (pullback_map_open_embedding_of_open_embeddings f g f ((Â«exprğŸ™Â») _) (homeo_of_iso (iso.refl _)).open_embedding H\n        ((Â«exprğŸ™Â») _) rfl (by simp))\n  erw [â† coe_comp]\n  simp\n#align fst_open_embedding_of_right_open_embedding fst_open_embedding_of_right_open_embedding\n\n",
 "fst_iso_of_right_embedding_range_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚œ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem fst_iso_of_right_embedding_range_subset {X Y S : Top} (f : Â«expr âŸ¶ Â» X S) {g : Â«expr âŸ¶ Â» Y S} (hg : embedding g)\n    (H : Set.range f âŠ† Set.range g) : IsIso (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) X) :=\n  by\n  let this : Â«expr â‰ƒâ‚œ Â» (pullback f g : Top) X :=\n    (homeomorph.of_embedding _ (fst_embedding_of_right_embedding f hg)).trans\n      { to_fun := coe\n        inv_fun := fun x =>\n          âŸ¨x, by\n            rw [pullback_fst_range]\n            exact âŸ¨_, (H (Set.mem_range_self x)).some_spec.symmâŸ©âŸ©\n        left_inv := fun âŸ¨_, _âŸ© => rfl\n        right_inv := fun x => rfl }\n  convert is_iso.of_iso (iso_of_homeo this)\n  ext\n  rfl\n#align fst_iso_of_right_embedding_range_subset fst_iso_of_right_embedding_range_subset\n\n",
 "fst_embedding_of_right_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem fst_embedding_of_right_embedding {X Y S : Top} (f : Â«expr âŸ¶ Â» X S) {g : Â«expr âŸ¶ Â» Y S} (H : embedding g) :\n    embedding (Â«exprâ‡‘ Â» (pullback.fst : Â«expr âŸ¶ Â» (pullback f g) X)) :=\n  by\n  convert\n    (homeo_of_iso (as_iso (pullback.fst : Â«expr âŸ¶ Â» (pullback f ((Â«exprğŸ™Â») S)) _))).embedding.comp\n      (pullback_map_embedding_of_embeddings f g f ((Â«exprğŸ™Â») _) (homeo_of_iso (iso.refl _)).embedding H ((Â«exprğŸ™Â») _)\n        rfl (by simp))\n  erw [â† coe_comp]\n  simp\n#align fst_embedding_of_right_embedding fst_embedding_of_right_embedding\n\n",
 "embedding_pullback_to_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¨¯ Â» -/\ntheorem embedding_pullback_to_prod {X Y Z : Top} (f : Â«expr âŸ¶ Â» X Z) (g : Â«expr âŸ¶ Â» Y Z) :\n    embedding (Â«exprâ‡‘ Â» (prod.lift pullback.fst pullback.snd : Â«expr âŸ¶ Â» (pullback f g) (Â«expr â¨¯ Â» X Y))) :=\n  âŸ¨inducing_pullback_to_prod f g, (Top.mono_iff_injective _).mp infer_instanceâŸ©\n#align embedding_pullback_to_prod embedding_pullback_to_prod\n\n",
 "embedding_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem embedding_prod_map {W X Y Z : Top} {f : Â«expr âŸ¶ Â» W X} {g : Â«expr âŸ¶ Â» Y Z} (hf : embedding f)\n    (hg : embedding g) : embedding (limits.prod.map f g) :=\n  âŸ¨inducing_prod_map hf.to_inducing hg.to_inducing,\n    by\n    haveI := (Top.mono_iff_injective _).mpr hf.inj\n    haveI := (Top.mono_iff_injective _).mpr hg.inj\n    exact (Top.mono_iff_injective _).mp infer_instanceâŸ©\n#align embedding_prod_map embedding_prod_map\n\n",
 "embedding_of_pullback_embeddings":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem embedding_of_pullback_embeddings {X Y S : Top} {f : Â«expr âŸ¶ Â» X S} {g : Â«expr âŸ¶ Â» Y S} (Hâ‚ : embedding f)\n    (Hâ‚‚ : embedding g) : embedding (limit.Ï€ (cospan f g) walking_cospan.one) :=\n  by\n  convert Hâ‚‚.comp (snd_embedding_of_left_embedding Hâ‚ g)\n  erw [â† coe_comp]\n  congr\n  exact (limit.w _ walking_cospan.hom.inr).symm\n#align embedding_of_pullback_embeddings embedding_of_pullback_embeddings\n\n",
 "directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\ntheorem partial_sections.directed : Directed superset fun G : finite_diagram J => partial_sections F G.2 := by\n  classical\n    intro A B\n    let Î¹A : finite_diagram_arrow A.1 â†’ finite_diagram_arrow (Â«expr âŠ” Â» A.1 B.1) := fun f =>\n      âŸ¨f.1, f.2.1, Finset.mem_union_left _ f.2.2.1, Finset.mem_union_left _ f.2.2.2.1, f.2.2.2.2âŸ©\n    let Î¹B : finite_diagram_arrow B.1 â†’ finite_diagram_arrow (Â«expr âŠ” Â» A.1 B.1) := fun f =>\n      âŸ¨f.1, f.2.1, Finset.mem_union_right _ f.2.2.1, Finset.mem_union_right _ f.2.2.2.1, f.2.2.2.2âŸ©\n    refine' âŸ¨âŸ¨Â«expr âŠ” Â» A.1 B.1, Â«expr âŠ” Â» (A.2.image Î¹A) (B.2.image Î¹B)âŸ©, _, _âŸ©\n    Â· rintro u hu f hf\n      have : Î¹A f âˆˆ Â«expr âŠ” Â» (A.2.image Î¹A) (B.2.image Î¹B) :=\n        by\n        apply Finset.mem_union_left\n        rw [Finset.mem_image]\n        refine' âŸ¨f, hf, rflâŸ©\n      exact hu this\n    Â· rintro u hu f hf\n      have : Î¹B f âˆˆ Â«expr âŠ” Â» (A.2.image Î¹A) (B.2.image Î¹B) :=\n        by\n        apply Finset.mem_union_right\n        rw [Finset.mem_image]\n        refine' âŸ¨f, hf, rflâŸ©\n      exact hu this\n#align partial_sections.directed partial_sections.directed\n\n",
 "colimit_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\ntheorem colimit_topology (F : Â«expr â¥¤ Â» J Top.{max v u}) :\n    (colimit F).topological_space =\n      Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n        ((F.obj j).topological_space.coinduced (colimit.Î¹ F j)) :=\n  coinduced_of_is_colimit _ (colimit.is_colimit F)\n#align colimit_topology colimit_topology\n\n",
 "colimit_is_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem colimit_is_open_iff (F : Â«expr â¥¤ Â» J Top.{max v u}) (U : set ((colimit F : _) : Type max v u)) :\n    is_open U â†” âˆ€ j, is_open (Â«expr â»Â¹' Â» (colimit.Î¹ F j) U) :=\n  by\n  conv_lhs => rw [colimit_topology F]\n  exact is_open_supr_iff\n#align colimit_is_open_iff colimit_is_open_iff\n\n",
 "coinduced_of_is_colimit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n--TODO: Add analogous constructions for `pushout`.\ntheorem coinduced_of_is_colimit {F : Â«expr â¥¤ Â» J Top.{max v u}} (c : cocone F) (hc : is_colimit c) :\n    c.X.topological_space =\n      Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n        ((F.obj j).topological_space.coinduced (c.Î¹.app j)) :=\n  by\n  let homeo := homeo_of_iso (hc.cocone_point_unique_up_to_iso (colimit_cocone_is_colimit F))\n  ext\n  refine' homeo.symm.is_open_preimage.symm.trans (iff.trans _ is_open_supr_iff.symm)\n  exact is_open_supr_iff\n#align coinduced_of_is_colimit coinduced_of_is_colimit\n\n",
 "coequalizer_is_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem coequalizer_is_open_iff (F : Â«expr â¥¤ Â» walking_parallel_pair Top.{u}) (U : set ((colimit F : _) : Type u)) :\n    is_open U â†” is_open (Â«expr â»Â¹' Â» (colimit.Î¹ F walking_parallel_pair.one) U) :=\n  by\n  rw [colimit_is_open_iff.{u}]\n  constructor\n  Â· intro H\n    exact H _\n  Â· intro H j\n    cases j\n    Â· rw [â† colimit.w F walking_parallel_pair_hom.left]\n      exact (F.map walking_parallel_pair_hom.left).continuous_to_fun.is_open_preimage _ H\n    Â· exact H\n#align coequalizer_is_open_iff coequalizer_is_open_iff\n\n",
 "closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem partial_sections.closed [âˆ€ j : J, t2_space (F.obj j)] {G : Finset J} (H : Finset (finite_diagram_arrow G)) :\n    is_closed (partial_sections F H) :=\n  by\n  have :\n    partial_sections F H =\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\"\n        { u | F.map f.2.2.2.2 (u f.1) = u f.2.1 } :=\n    by\n    ext1\n    simp only [Set.mem_interáµ¢, Set.mem_setOf_eq]\n    rfl\n  rw [this]\n  apply is_closed_bInter\n  intro f hf\n  apply is_closed_eq\n  continuity\n#align partial_sections.closed partial_sections.closed\n\n",
 "binary_cofan_is_colimit_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem binary_cofan_is_colimit_iff {X Y : Top} (c : binary_cofan X Y) :\n    nonempty (is_colimit c) â†”\n      open_embedding c.inl âˆ§ open_embedding c.inr âˆ§ IsCompl (Set.range c.inl) (Set.range c.inr) :=\n  by\n  classical\n    constructor\n    Â· rintro âŸ¨hâŸ©\n      rw [â†\n        show _ = c.inl from h.comp_cocone_point_unique_up_to_iso_inv (binary_cofan_is_colimit X Y) âŸ¨walking_pair.leftâŸ©,\n        â†\n        show _ = c.inr from h.comp_cocone_point_unique_up_to_iso_inv (binary_cofan_is_colimit X Y) âŸ¨walking_pair.rightâŸ©]\n      dsimp\n      refine'\n        âŸ¨(homeo_of_iso <| h.cocone_point_unique_up_to_iso (binary_cofan_is_colimit X Y)).symm.open_embedding.comp\n            open_embedding_inl,\n          (homeo_of_iso <| h.cocone_point_unique_up_to_iso (binary_cofan_is_colimit X Y)).symm.open_embedding.comp\n            open_embedding_inr,\n          _âŸ©\n      erw [Set.range_comp, â† eq_compl_iff_isCompl, Set.range_comp _ sum.inr, â†\n        Set.image_compl_eq\n          (homeo_of_iso <| h.cocone_point_unique_up_to_iso (binary_cofan_is_colimit X Y)).symm.bijective]\n      congr 1\n      exact set.compl_range_inr.symm\n    Â· rintro âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ©\n      have : âˆ€ x, x âˆˆ Set.range c.inl âˆ¨ x âˆˆ Set.range c.inr :=\n        by\n        rw [eq_compl_iff_is_compl.mpr hâ‚ƒ.symm]\n        exact fun _ => or_not\n      refine' âŸ¨binary_cofan.is_colimit.mk _ _ _ _ _âŸ©\n      Â· intro T f g\n        refine' continuous_map.mk _ _\n        Â·\n          exact fun x =>\n            if h : x âˆˆ Set.range c.inl then f ((Equiv.ofInjective _ hâ‚.inj).symm âŸ¨x, hâŸ©)\n            else g ((Equiv.ofInjective _ hâ‚‚.inj).symm âŸ¨x, (this x).resolve_left hâŸ©)\n        rw [continuous_iff_continuous_at]\n        intro x\n        by_cases x âˆˆ Set.range c.inl\n        Â· revert h x\n          apply (is_open.continuous_on_iff _).mp\n          Â· rw [continuous_on_iff_continuous_restrict]\n            convert_to continuous (f âˆ˜ (homeomorph.of_embedding _ hâ‚.to_embedding).symm)\n            Â· ext âŸ¨x, hxâŸ©\n              exact dif_pos hx\n            continuity\n          Â· exact hâ‚.open_range\n        Â· revert h x\n          apply (is_open.continuous_on_iff _).mp\n          Â· rw [continuous_on_iff_continuous_restrict]\n            have : âˆ€ a, a âˆ‰ Set.range c.inl â†’ a âˆˆ Set.range c.inr :=\n              by\n              rintro a (h : a âˆˆ Â«expr á¶œÂ» (Set.range c.inl))\n              rwa [eq_compl_iff_is_compl.mpr hâ‚ƒ.symm]\n            convert_to continuous (g âˆ˜ (homeomorph.of_embedding _ hâ‚‚.to_embedding).symm âˆ˜ subtype.map _ this)\n            Â· ext âŸ¨x, hxâŸ©\n              exact dif_neg hx\n            continuity\n            rw [embedding_subtype_coe.to_inducing.continuous_iff]\n            exact continuous_subtype_coe\n          Â· change is_open (Â«expr á¶œÂ» (Set.range c.inl))\n            rw [â† eq_compl_iff_is_compl.mpr hâ‚ƒ.symm]\n            exact hâ‚‚.open_range\n      Â· intro T f g\n        ext x\n        refine' (dif_pos _).trans _\n        Â· exact âŸ¨x, rflâŸ©\n        Â· rw [Equiv.ofInjective_symm_apply]\n      Â· intro T f g\n        ext x\n        refine' (dif_neg _).trans _\n        Â· rintro âŸ¨y, eâŸ©\n          have : c.inr x âˆˆ Â«expr âŠ“ Â» (Set.range c.inl) (Set.range c.inr) := âŸ¨âŸ¨_, eâŸ©, âŸ¨_, rflâŸ©âŸ©\n          rwa [disjoint_iff.mp hâ‚ƒ.1] at this\n        Â· exact congr_arg g (Equiv.ofInjective_symm_apply _ _)\n      Â· rintro T _ _ m rfl rfl\n        ext x\n        change m x = dite _ _ _\n        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ âŸ¨_, _âŸ©).symm\n#align binary_cofan_is_colimit_iff binary_cofan_is_colimit_iff\n\n"}