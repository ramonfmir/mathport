{"snd_open_embedding_of_left_open_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem snd_open_embedding_of_left_open_embedding {X Y S : Top} {f : «expr ⟶ » X S} (H : open_embedding f)\n    (g : «expr ⟶ » Y S) : open_embedding («expr⇑ » (pullback.snd : «expr ⟶ » (pullback f g) Y)) :=\n  by\n  convert\n    (homeo_of_iso (as_iso (pullback.snd : «expr ⟶ » (pullback ((«expr𝟙») S) g) _))).open_embedding.comp\n      (pullback_map_open_embedding_of_open_embeddings f g ((«expr𝟙») _) g H (homeo_of_iso (iso.refl _)).open_embedding\n        ((«expr𝟙») _) rfl (by simp))\n  erw [← coe_comp]\n  simp\n#align snd_open_embedding_of_left_open_embedding snd_open_embedding_of_left_open_embedding\n\n",
 "snd_iso_of_left_embedding_range_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem snd_iso_of_left_embedding_range_subset {X Y S : Top} {f : «expr ⟶ » X S} (hf : embedding f) (g : «expr ⟶ » Y S)\n    (H : Set.range g ⊆ Set.range f) : IsIso (pullback.snd : «expr ⟶ » (pullback f g) Y) :=\n  by\n  let this : «expr ≃ₜ » (pullback f g : Top) Y :=\n    (homeomorph.of_embedding _ (snd_embedding_of_left_embedding hf g)).trans\n      { to_fun := coe\n        inv_fun := fun x =>\n          ⟨x, by\n            rw [pullback_snd_range]\n            exact ⟨_, (H (Set.mem_range_self x)).some_spec⟩⟩\n        left_inv := fun ⟨_, _⟩ => rfl\n        right_inv := fun x => rfl }\n  convert is_iso.of_iso (iso_of_homeo this)\n  ext\n  rfl\n#align snd_iso_of_left_embedding_range_subset snd_iso_of_left_embedding_range_subset\n\n",
 "snd_embedding_of_left_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem snd_embedding_of_left_embedding {X Y S : Top} {f : «expr ⟶ » X S} (H : embedding f) (g : «expr ⟶ » Y S) :\n    embedding («expr⇑ » (pullback.snd : «expr ⟶ » (pullback f g) Y)) :=\n  by\n  convert\n    (homeo_of_iso (as_iso (pullback.snd : «expr ⟶ » (pullback ((«expr𝟙») S) g) _))).embedding.comp\n      (pullback_map_embedding_of_embeddings f g ((«expr𝟙») _) g H (homeo_of_iso (iso.refl _)).embedding ((«expr𝟙») _)\n        rfl (by simp))\n  erw [← coe_comp]\n  simp\n#align snd_embedding_of_left_embedding snd_embedding_of_left_embedding\n\n",
 "sigma_iso_sigma_inv_apply":
 "@[simp]\ntheorem sigma_iso_sigma_inv_apply {ι : Type v} (α : ι → Top.{max v u}) (i : ι) (x : α i) :\n    (sigma_iso_sigma α).inv ⟨i, x⟩ = (sigma.ι α i : _) x :=\n  by\n  rw [← sigma_iso_sigma_hom_ι_apply, ← comp_app]\n  simp\n#align sigma_iso_sigma_inv_apply sigma_iso_sigma_inv_apply\n\n",
 "sigma_iso_sigma_hom_ι_apply":
 "@[simp]\ntheorem sigma_iso_sigma_hom_ι_apply {ι : Type v} (α : ι → Top.{max v u}) (i : ι) (x : α i) :\n    (sigma_iso_sigma α).hom ((sigma.ι α i : _) x) = sigma.mk i x :=\n  concrete_category.congr_hom (sigma_iso_sigma_hom_ι α i) x\n#align sigma_iso_sigma_hom_ι_apply sigma_iso_sigma_hom_ι_apply\n\n",
 "sigma_iso_sigma_hom_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem sigma_iso_sigma_hom_ι {ι : Type v} (α : ι → Top.{max v u}) (i : ι) :\n    «expr ≫ » (sigma.ι α i) (sigma_iso_sigma α).hom = sigma_ι α i := by simp [sigma_iso_sigma]\n#align sigma_iso_sigma_hom_ι sigma_iso_sigma_hom_ι\n\n",
 "range_pullback_to_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem range_pullback_to_prod {X Y Z : Top} (f : «expr ⟶ » X Z) (g : «expr ⟶ » Y Z) :\n    Set.range (prod.lift pullback.fst pullback.snd : «expr ⟶ » (pullback f g) («expr ⨯ » X Y)) =\n      { x | («expr ≫ » limits.prod.fst f) x = («expr ≫ » limits.prod.snd g) x } :=\n  by\n  ext x\n  constructor\n  · rintro ⟨y, rfl⟩\n    simp only [← comp_apply, Set.mem_setOf_eq]\n    congr 1\n    simp [pullback.condition]\n  · intro h\n    use (pullback_iso_prod_subtype f g).inv ⟨⟨_, _⟩, h⟩\n    apply concrete.limit_ext\n    rintro ⟨⟨⟩⟩ <;> simp\n#align range_pullback_to_prod range_pullback_to_prod\n\n",
 "range_pullback_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If the map `S ⟶ T` is mono, then there is a description of the image of `W ×ₛ X ⟶ Y ×ₜ Z`. -/\ntheorem range_pullback_map {W X Y Z S T : Top} (f₁ : «expr ⟶ » W S) (f₂ : «expr ⟶ » X S) (g₁ : «expr ⟶ » Y T)\n    (g₂ : «expr ⟶ » Z T) (i₁ : «expr ⟶ » W Y) (i₂ : «expr ⟶ » X Z) (i₃ : «expr ⟶ » S T) [H₃ : Mono i₃]\n    (eq₁ : «expr ≫ » f₁ i₃ = «expr ≫ » i₁ g₁) (eq₂ : «expr ≫ » f₂ i₃ = «expr ≫ » i₂ g₂) :\n    Set.range (pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂) =\n      «expr ⁻¹' » (pullback.fst : «expr ⟶ » (pullback g₁ g₂) _) (Set.range i₁) ∩\n        «expr ⁻¹' » (pullback.snd : «expr ⟶ » (pullback g₁ g₂) _) (Set.range i₂) :=\n  by\n  ext\n  constructor\n  · rintro ⟨y, rfl⟩\n    simp\n  rintro ⟨⟨x₁, hx₁⟩, ⟨x₂, hx₂⟩⟩\n  have : f₁ x₁ = f₂ x₂ := by\n    apply (Top.mono_iff_injective _).mp H₃\n    simp only [← comp_apply, eq₁, eq₂]\n    simp only [comp_apply, hx₁, hx₂]\n    simp only [← comp_apply, pullback.condition]\n  use (pullback_iso_prod_subtype f₁ f₂).inv ⟨⟨x₁, x₂⟩, this⟩\n  apply concrete.limit_ext\n  rintro (_ | _ | _)\n  · simp only [Top.comp_app, limit.lift_π_apply, category.assoc, pullback_cone.mk_π_app_one, hx₁,\n      pullback_iso_prod_subtype_inv_fst_apply, subtype.coe_mk]\n    simp only [← comp_apply]\n    congr\n    apply limit.w _ walking_cospan.hom.inl\n  · simp [hx₁]\n  · simp [hx₂]\n#align range_pullback_map range_pullback_map\n\n",
 "range_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\ntheorem range_prod_map {W X Y Z : Top.{u}} (f : «expr ⟶ » W Y) (g : «expr ⟶ » X Z) :\n    Set.range (limits.prod.map f g) =\n      «expr ⁻¹' » (limits.prod.fst : «expr ⟶ » («expr ⨯ » Y Z) _) (Set.range f) ∩\n        «expr ⁻¹' » (limits.prod.snd : «expr ⟶ » («expr ⨯ » Y Z) _) (Set.range g) :=\n  by\n  ext\n  constructor\n  · rintro ⟨y, rfl⟩\n    simp only [Set.mem_preimage, Set.mem_range, Set.mem_inter_iff, ← comp_apply]\n    simp only [limits.prod.map_fst, limits.prod.map_snd, exists_apply_eq_apply, comp_apply, and_self_iff]\n  · rintro ⟨⟨x₁, hx₁⟩, ⟨x₂, hx₂⟩⟩\n    use (prod_iso_prod W X).inv (x₁, x₂)\n    apply concrete.limit_ext\n    rintro ⟨⟨⟩⟩\n    · simp only [← comp_apply, category.assoc]\n      erw [limits.prod.map_fst]\n      simp [hx₁]\n    · simp only [← comp_apply, category.assoc]\n      erw [limits.prod.map_snd]\n      simp [hx₂]\n#align range_prod_map range_prod_map\n\n",
 "pullback_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem pullback_topology {X Y Z : Top.{u}} (f : «expr ⟶ » X Z) (g : «expr ⟶ » Y Z) :\n    (pullback f g).topological_space =\n      «expr ⊓ » (induced (pullback.fst : «expr ⟶ » (pullback f g) _) X.topological_space)\n        (induced (pullback.snd : «expr ⟶ » (pullback f g) _) Y.topological_space) :=\n  by\n  let homeo := homeo_of_iso (pullback_iso_prod_subtype f g)\n  refine' homeo.inducing.induced.trans _\n  change induced homeo (induced _ («expr ⊓ » _ _)) = _\n  simpa [induced_compose]\n#align pullback_topology pullback_topology\n\n",
 "pullback_snd_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem pullback_snd_range {X Y S : Top} (f : «expr ⟶ » X S) (g : «expr ⟶ » Y S) :\n    Set.range (pullback.snd : «expr ⟶ » (pullback f g) _) = { y : Y | ∃ x : X, f x = g y } :=\n  by\n  ext y\n  constructor\n  · rintro ⟨x, rfl⟩\n    use (pullback.fst : «expr ⟶ » (pullback f g) _) x\n    exact concrete_category.congr_hom pullback.condition x\n  · rintro ⟨x, eq⟩\n    use (Top.pullback_iso_prod_subtype f g).inv ⟨⟨x, y⟩, eq⟩\n    simp\n#align pullback_snd_range pullback_snd_range\n\n",
 "pullback_snd_image_fst_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem pullback_snd_image_fst_preimage (f : «expr ⟶ » X Z) (g : «expr ⟶ » Y Z) (U : set X) :\n    «expr '' » (pullback.snd : «expr ⟶ » (pullback f g) _) («expr ⁻¹' » (pullback.fst : «expr ⟶ » (pullback f g) _) U) =\n      «expr ⁻¹' » g («expr '' » f U) :=\n  by\n  ext x\n  constructor\n  · rintro ⟨y, hy, rfl⟩\n    exact ⟨(pullback.fst : «expr ⟶ » (pullback f g) _) y, hy, concrete_category.congr_hom pullback.condition y⟩\n  · rintro ⟨y, hy, eq⟩\n    exact ⟨(Top.pullback_iso_prod_subtype f g).inv ⟨⟨_, _⟩, eq⟩, by simpa, by simp⟩\n#align pullback_snd_image_fst_preimage pullback_snd_image_fst_preimage\n\n",
 "pullback_map_open_embedding_of_open_embeddings":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If there is a diagram where the morphisms `W ⟶ Y` and `X ⟶ Z` are open embeddings, and `S ⟶ T`\nis mono, then the induced morphism `W ×ₛ X ⟶ Y ×ₜ Z` is also an open embedding.\n  W  ⟶  Y\n    ↘      ↘\n      S  ⟶  T\n    ↗       ↗\n  X  ⟶  Z\n-/\ntheorem pullback_map_open_embedding_of_open_embeddings {W X Y Z S T : Top} (f₁ : «expr ⟶ » W S) (f₂ : «expr ⟶ » X S)\n    (g₁ : «expr ⟶ » Y T) (g₂ : «expr ⟶ » Z T) {i₁ : «expr ⟶ » W Y} {i₂ : «expr ⟶ » X Z} (H₁ : open_embedding i₁)\n    (H₂ : open_embedding i₂) (i₃ : «expr ⟶ » S T) [H₃ : Mono i₃] (eq₁ : «expr ≫ » f₁ i₃ = «expr ≫ » i₁ g₁)\n    (eq₂ : «expr ≫ » f₂ i₃ = «expr ≫ » i₂ g₂) : open_embedding (pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂) :=\n  by\n  constructor\n  · apply pullback_map_embedding_of_embeddings f₁ f₂ g₁ g₂ H₁.to_embedding H₂.to_embedding i₃ eq₁ eq₂\n  · rw [range_pullback_map]\n    apply is_open.inter <;> apply continuous.is_open_preimage\n    continuity\n    exacts[H₁.open_range, H₂.open_range]\n#align pullback_map_open_embedding_of_open_embeddings pullback_map_open_embedding_of_open_embeddings\n\n",
 "pullback_map_embedding_of_embeddings":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- If there is a diagram where the morphisms `W ⟶ Y` and `X ⟶ Z` are embeddings,\nthen the induced morphism `W ×ₛ X ⟶ Y ×ₜ Z` is also an embedding.\n\n  W  ⟶  Y\n    ↘      ↘\n      S  ⟶  T\n    ↗      ↗\n  X  ⟶  Z\n-/\ntheorem pullback_map_embedding_of_embeddings {W X Y Z S T : Top} (f₁ : «expr ⟶ » W S) (f₂ : «expr ⟶ » X S)\n    (g₁ : «expr ⟶ » Y T) (g₂ : «expr ⟶ » Z T) {i₁ : «expr ⟶ » W Y} {i₂ : «expr ⟶ » X Z} (H₁ : embedding i₁)\n    (H₂ : embedding i₂) (i₃ : «expr ⟶ » S T) (eq₁ : «expr ≫ » f₁ i₃ = «expr ≫ » i₁ g₁)\n    (eq₂ : «expr ≫ » f₂ i₃ = «expr ≫ » i₂ g₂) : embedding (pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂) :=\n  by\n  refine'\n    embedding_of_embedding_compose (continuous_map.continuous_to_fun _)\n      (show continuous (prod.lift pullback.fst pullback.snd : «expr ⟶ » (pullback g₁ g₂) («expr ⨯ » Y Z)) from\n        continuous_map.continuous_to_fun _)\n      _\n  suffices\n    embedding («expr ≫ » (prod.lift pullback.fst pullback.snd) (limits.prod.map i₁ i₂) : «expr ⟶ » (pullback f₁ f₂) _)\n    by simpa [← coe_comp] using this\n  rw [coe_comp]\n  refine' embedding.comp (embedding_prod_map H₁ H₂) (embedding_pullback_to_prod _ _)\n#align pullback_map_embedding_of_embeddings pullback_map_embedding_of_embeddings\n\n",
 "pullback_iso_prod_subtype_inv_snd_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem pullback_iso_prod_subtype_inv_snd_apply (f : «expr ⟶ » X Z) (g : «expr ⟶ » Y Z)\n    (x : { p : X × Y // f p.1 = g p.2 }) :\n    (pullback.snd : «expr ⟶ » (pullback f g) _) ((pullback_iso_prod_subtype f g).inv x) = (x : X × Y).snd :=\n  concrete_category.congr_hom (pullback_iso_prod_subtype_inv_snd f g) x\n#align pullback_iso_prod_subtype_inv_snd_apply pullback_iso_prod_subtype_inv_snd_apply\n\n",
 "pullback_iso_prod_subtype_inv_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem pullback_iso_prod_subtype_inv_snd (f : «expr ⟶ » X Z) (g : «expr ⟶ » Y Z) :\n    «expr ≫ » (pullback_iso_prod_subtype f g).inv pullback.snd = pullback_snd f g := by\n  simpa [pullback_iso_prod_subtype]\n#align pullback_iso_prod_subtype_inv_snd pullback_iso_prod_subtype_inv_snd\n\n",
 "pullback_iso_prod_subtype_inv_fst_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem pullback_iso_prod_subtype_inv_fst_apply (f : «expr ⟶ » X Z) (g : «expr ⟶ » Y Z)\n    (x : { p : X × Y // f p.1 = g p.2 }) :\n    (pullback.fst : «expr ⟶ » (pullback f g) _) ((pullback_iso_prod_subtype f g).inv x) = (x : X × Y).fst :=\n  concrete_category.congr_hom (pullback_iso_prod_subtype_inv_fst f g) x\n#align pullback_iso_prod_subtype_inv_fst_apply pullback_iso_prod_subtype_inv_fst_apply\n\n",
 "pullback_iso_prod_subtype_inv_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem pullback_iso_prod_subtype_inv_fst (f : «expr ⟶ » X Z) (g : «expr ⟶ » Y Z) :\n    «expr ≫ » (pullback_iso_prod_subtype f g).inv pullback.fst = pullback_fst f g := by\n  simpa [pullback_iso_prod_subtype]\n#align pullback_iso_prod_subtype_inv_fst pullback_iso_prod_subtype_inv_fst\n\n",
 "pullback_iso_prod_subtype_hom_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem pullback_iso_prod_subtype_hom_snd (f : «expr ⟶ » X Z) (g : «expr ⟶ » Y Z) :\n    «expr ≫ » (pullback_iso_prod_subtype f g).hom (pullback_snd f g) = pullback.snd := by\n  rw [← iso.eq_inv_comp, pullback_iso_prod_subtype_inv_snd]\n#align pullback_iso_prod_subtype_hom_snd pullback_iso_prod_subtype_hom_snd\n\n",
 "pullback_iso_prod_subtype_hom_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem pullback_iso_prod_subtype_hom_fst (f : «expr ⟶ » X Z) (g : «expr ⟶ » Y Z) :\n    «expr ≫ » (pullback_iso_prod_subtype f g).hom (pullback_fst f g) = pullback.fst := by\n  rw [← iso.eq_inv_comp, pullback_iso_prod_subtype_inv_fst]\n#align pullback_iso_prod_subtype_hom_fst pullback_iso_prod_subtype_hom_fst\n\n",
 "pullback_iso_prod_subtype_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem pullback_iso_prod_subtype_hom_apply {f : «expr ⟶ » X Z} {g : «expr ⟶ » Y Z} (x : pullback f g) :\n    (pullback_iso_prod_subtype f g).hom x =\n      ⟨⟨(pullback.fst : «expr ⟶ » (pullback f g) _) x, (pullback.snd : «expr ⟶ » (pullback f g) _) x⟩, by\n        simpa using concrete_category.congr_hom pullback.condition x⟩ :=\n  by\n  ext\n  exacts[concrete_category.congr_hom (pullback_iso_prod_subtype_hom_fst f g) x,\n    concrete_category.congr_hom (pullback_iso_prod_subtype_hom_snd f g) x]\n#align pullback_iso_prod_subtype_hom_apply pullback_iso_prod_subtype_hom_apply\n\n",
 "pullback_fst_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem pullback_fst_range {X Y S : Top} (f : «expr ⟶ » X S) (g : «expr ⟶ » Y S) :\n    Set.range (pullback.fst : «expr ⟶ » (pullback f g) _) = { x : X | ∃ y : Y, f x = g y } :=\n  by\n  ext x\n  constructor\n  · rintro ⟨y, rfl⟩\n    use (pullback.snd : «expr ⟶ » (pullback f g) _) y\n    exact concrete_category.congr_hom pullback.condition y\n  · rintro ⟨y, eq⟩\n    use (Top.pullback_iso_prod_subtype f g).inv ⟨⟨x, y⟩, eq⟩\n    simp\n#align pullback_fst_range pullback_fst_range\n\n",
 "pullback_fst_image_snd_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem pullback_fst_image_snd_preimage (f : «expr ⟶ » X Z) (g : «expr ⟶ » Y Z) (U : set Y) :\n    «expr '' » (pullback.fst : «expr ⟶ » (pullback f g) _) («expr ⁻¹' » (pullback.snd : «expr ⟶ » (pullback f g) _) U) =\n      «expr ⁻¹' » f («expr '' » g U) :=\n  by\n  ext x\n  constructor\n  · rintro ⟨y, hy, rfl⟩\n    exact ⟨(pullback.snd : «expr ⟶ » (pullback f g) _) y, hy, (concrete_category.congr_hom pullback.condition y).symm⟩\n  · rintro ⟨y, hy, eq⟩\n    exact ⟨(Top.pullback_iso_prod_subtype f g).inv ⟨⟨_, _⟩, eq.symm⟩, by simpa, by simp⟩\n#align pullback_fst_image_snd_preimage pullback_fst_image_snd_preimage\n\n",
 "prod_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\ntheorem prod_topology {X Y : Top} :\n    («expr ⨯ » X Y).topological_space =\n      «expr ⊓ » (induced (limits.prod.fst : «expr ⟶ » («expr ⨯ » X Y) _) X.topological_space)\n        (induced (limits.prod.snd : «expr ⟶ » («expr ⨯ » X Y) _) Y.topological_space) :=\n  by\n  let homeo := homeo_of_iso (prod_iso_prod X Y)\n  refine' homeo.inducing.induced.trans _\n  change induced homeo («expr ⊓ » _ _) = _\n  simpa [induced_compose]\n#align prod_topology prod_topology\n\n",
 "prod_iso_prod_inv_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1, elementwise]\ntheorem prod_iso_prod_inv_snd (X Y : Top.{u}) : «expr ≫ » (prod_iso_prod X Y).inv limits.prod.snd = prod_snd := by\n  simp [iso.inv_comp_eq]\n#align prod_iso_prod_inv_snd prod_iso_prod_inv_snd\n\n",
 "prod_iso_prod_inv_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1, elementwise]\ntheorem prod_iso_prod_inv_fst (X Y : Top.{u}) : «expr ≫ » (prod_iso_prod X Y).inv limits.prod.fst = prod_fst := by\n  simp [iso.inv_comp_eq]\n#align prod_iso_prod_inv_fst prod_iso_prod_inv_fst\n\n",
 "prod_iso_prod_hom_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod_iso_prod_hom_snd (X Y : Top.{u}) : «expr ≫ » (prod_iso_prod X Y).hom prod_snd = limits.prod.snd := by\n  simpa [← iso.eq_inv_comp, prod_iso_prod]\n#align prod_iso_prod_hom_snd prod_iso_prod_hom_snd\n\n",
 "prod_iso_prod_hom_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem prod_iso_prod_hom_fst (X Y : Top.{u}) : «expr ≫ » (prod_iso_prod X Y).hom prod_fst = limits.prod.fst := by\n  simpa [← iso.eq_inv_comp, prod_iso_prod]\n#align prod_iso_prod_hom_fst prod_iso_prod_hom_fst\n\n",
 "prod_iso_prod_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\n@[simp]\ntheorem prod_iso_prod_hom_apply {X Y : Top.{u}} (x : «expr ⨯ » X Y) :\n    (prod_iso_prod X Y).hom x =\n      ((limits.prod.fst : «expr ⟶ » («expr ⨯ » X Y) _) x, (limits.prod.snd : «expr ⟶ » («expr ⨯ » X Y) _) x) :=\n  by\n  ext\n  · exact concrete_category.congr_hom (prod_iso_prod_hom_fst X Y) x\n  · exact concrete_category.congr_hom (prod_iso_prod_hom_snd X Y) x\n#align prod_iso_prod_hom_apply prod_iso_prod_hom_apply\n\n",
 "pi_iso_pi_inv_π_apply":
 "@[simp]\ntheorem pi_iso_pi_inv_π_apply {ι : Type v} (α : ι → Top.{max v u}) (i : ι) (x : ∀ i, α i) :\n    (pi.π α i : _) ((pi_iso_pi α).inv x) = x i :=\n  concrete_category.congr_hom (pi_iso_pi_inv_π α i) x\n#align pi_iso_pi_inv_π_apply pi_iso_pi_inv_π_apply\n\n",
 "pi_iso_pi_inv_π":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2017 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Scott Morrison, Mario Carneiro, Andrew Yang\n-/\n@[simp, reassoc.1]\ntheorem pi_iso_pi_inv_π {ι : Type v} (α : ι → Top.{max v u}) (i : ι) :\n    «expr ≫ » (pi_iso_pi α).inv (pi.π α i) = pi_π α i := by simp [pi_iso_pi]\n#align pi_iso_pi_inv_π pi_iso_pi_inv_π\n\n",
 "pi_iso_pi_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∏ » -/\n@[simp]\ntheorem pi_iso_pi_hom_apply {ι : Type v} (α : ι → Top.{max v u}) (i : ι) (x : «expr∏ » α) :\n    (pi_iso_pi α).hom x i = (pi.π α i : _) x :=\n  by\n  have := pi_iso_pi_inv_π α i\n  rw [iso.inv_comp_eq] at this\n  exact concrete_category.congr_hom this x\n#align pi_iso_pi_hom_apply pi_iso_pi_hom_apply\n\n",
 "open_embedding_of_pullback_open_embeddings":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If `X ⟶ S`, `Y ⟶ S` are open embeddings, then so is `X ×ₛ Y ⟶ S`. -/\ntheorem open_embedding_of_pullback_open_embeddings {X Y S : Top} {f : «expr ⟶ » X S} {g : «expr ⟶ » Y S}\n    (H₁ : open_embedding f) (H₂ : open_embedding g) : open_embedding (limit.π (cospan f g) walking_cospan.one) :=\n  by\n  convert H₂.comp (snd_open_embedding_of_left_open_embedding H₁ g)\n  erw [← coe_comp]\n  congr\n  exact (limit.w _ walking_cospan.hom.inr).symm\n#align open_embedding_of_pullback_open_embeddings open_embedding_of_pullback_open_embeddings\n\n",
 "nonempty_sections_of_fintype_inverse_system":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/-- The inverse limit of nonempty finite types is nonempty.\n\nSee `nonempty_sections_of_fintype_cofiltered_system` for a generalization to cofiltered limits.\nThat version applies in almost all cases, and the only difference is that this version\nallows `J` to be empty.\n\nThis may be regarded as a generalization of Kőnig's lemma.\nTo specialize: given a locally finite connected graph, take `Jᵒᵖ` to be `ℕ` and\n`F j` to be length-`j` paths that start from an arbitrary fixed vertex.\nElements of `F.sections` can be read off as infinite rays in the graph. -/\ntheorem nonempty_sections_of_fintype_inverse_system {J : Type u} [preorder J] [IsDirected J (· ≤ ·)]\n    (F : «expr ⥤ » («expr ᵒᵖ» J) (Type v)) [∀ j : «expr ᵒᵖ» J, fintype (F.obj j)]\n    [∀ j : «expr ᵒᵖ» J, nonempty (F.obj j)] : F.sections.nonempty :=\n  by\n  cases isEmpty_or_nonempty J\n  · haveI : is_empty («expr ᵒᵖ» J) := ⟨fun j => is_empty_elim j.unop⟩\n    -- TODO: this should be a global instance\n    exact ⟨is_empty_elim, is_empty_elim⟩\n  · exact nonempty_sections_of_fintype_cofiltered_system _\n#align nonempty_sections_of_fintype_inverse_system nonempty_sections_of_fintype_inverse_system\n\n",
 "nonempty_sections_of_fintype_cofiltered_system":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- The cofiltered limit of nonempty finite types is nonempty.\n\nSee `nonempty_sections_of_fintype_inverse_system` for a specialization to inverse limits. -/\ntheorem nonempty_sections_of_fintype_cofiltered_system {J : Type u} [Category.{w} J] [is_cofiltered J]\n    (F : «expr ⥤ » J (Type v)) [∀ j : J, fintype (F.obj j)] [∀ j : J, nonempty (F.obj j)] : F.sections.nonempty :=\n  by\n  -- Step 1: lift everything to the `max u v w` universe.\n  let J' : Type max w v u := as_small.{max w v} J\n  let down : «expr ⥤ » J' J := as_small.down\n  let F' : «expr ⥤ » J' (Type max u v w) := «expr ⋙ » down («expr ⋙ » F ulift_functor.{max u w, v})\n  haveI : ∀ i, nonempty (F'.obj i) := fun i => ⟨⟨classical.arbitrary (F.obj (down.obj i))⟩⟩\n  haveI : ∀ i, fintype (F'.obj i) := fun i => fintype.of_equiv (F.obj (down.obj i)) equiv.ulift.symm\n  -- Step 2: apply the bootstrap theorem\n  obtain ⟨u, hu⟩ := nonempty_sections_of_fintype_cofiltered_system.init F'\n  -- Step 3: interpret the results\n  use fun j => (u ⟨j⟩).down\n  intro j j' f\n  have h := @hu (⟨j⟩ : J') (⟨j'⟩ : J') (ulift.up f)\n  simp only [as_small.down, functor.comp_map, ulift_functor_map, functor.op_map] at h\n  simp_rw [← h]\n  rfl\n#align nonempty_sections_of_fintype_cofiltered_system nonempty_sections_of_fintype_cofiltered_system\n\n",
 "nonempty_limit_cone_of_compact_t2_cofiltered_system":
 "/-- Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces.\n-/\ntheorem nonempty_limit_cone_of_compact_t2_cofiltered_system [is_cofiltered J] [∀ j : J, nonempty (F.obj j)]\n    [∀ j : J, compact_space (F.obj j)] [∀ j : J, t2_space (F.obj j)] : nonempty (Top.limit_cone.{u} F).X := by\n  classical\n    obtain ⟨u, hu⟩ :=\n      is_compact.nonempty_Inter_of_directed_nonempty_compact_closed (fun G => partial_sections F _)\n        (partial_sections.directed F) (fun G => partial_sections.nonempty F _)\n        (fun G => is_closed.is_compact (partial_sections.closed F _)) fun G => partial_sections.closed F _\n    use u\n    intro X Y f\n    let G : finite_diagram J :=\n      ⟨{X, Y},\n        {⟨X, Y, by simp only [true_or_iff, eq_self_iff_true, Finset.mem_insert], by\n            simp only [eq_self_iff_true, or_true_iff, Finset.mem_insert, Finset.mem_singleton], f⟩}⟩\n    exact hu _ ⟨G, rfl⟩ (Finset.mem_singleton_self _)\n#align nonempty_limit_cone_of_compact_t2_cofiltered_system nonempty_limit_cone_of_compact_t2_cofiltered_system\n\n",
 "nonempty":
 "theorem partial_sections.nonempty [is_cofiltered J] [h : ∀ j : J, nonempty (F.obj j)] {G : Finset J}\n    (H : Finset (finite_diagram_arrow G)) : (partial_sections F H).nonempty := by\n  classical\n    use fun j : J =>\n      if hj : j ∈ G then F.map (is_cofiltered.inf_to G H hj) (h (is_cofiltered.inf G H)).some else (h _).some\n    rintro ⟨X, Y, hX, hY, f⟩ hf\n    dsimp only\n    rwa [dif_pos hX, dif_pos hY, ← comp_app, ← F.map_comp, @is_cofiltered.inf_to_commutes _ _ _ G H]\n#align partial_sections.nonempty partial_sections.nonempty\n\n",
 "limit_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem limit_topology (F : «expr ⥤ » J Top.{max v u}) :\n    (limit F).topological_space =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((F.obj j).topological_space.induced (limit.π F j)) :=\n  induced_of_is_limit _ (limit.is_limit F)\n#align limit_topology limit_topology\n\n",
 "is_topological_basis_cofiltered_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- Given a *compatible* collection of topological bases for the factors in a cofiltered limit\nwhich contain `set.univ` and are closed under intersections, the induced *naive* collection\nof sets in the limit is, in fact, a topological basis.\n-/\ntheorem is_topological_basis_cofiltered_limit (T : ∀ j, set (set (F.obj j))) (hT : ∀ j, is_topological_basis (T j))\n    (univ : ∀ i : J, Set.univ ∈ T i) (inter : ∀ (i) (U1 U2 : set (F.obj i)), U1 ∈ T i → U2 ∈ T i → U1 ∩ U2 ∈ T i)\n    (compat : ∀ (i j : J) (f : «expr ⟶ » i j) (V : set (F.obj j)) (hV : V ∈ T j), «expr ⁻¹' » (F.map f) V ∈ T i) :\n    is_topological_basis { U : set C.X | ∃ (j : _)(V : set (F.obj j)), V ∈ T j ∧ U = «expr ⁻¹' » (C.π.app j) V } := by\n  classical\n    -- The limit cone for `F` whose topology is defined as an infimum.\n    let D := limit_cone_infi F\n    -- The isomorphism between the cone point of `C` and the cone point of `D`.\n    let E : «expr ≅ » C.X D.X := hC.cone_point_unique_up_to_iso (limit_cone_infi_is_limit _)\n    have hE : inducing E.hom := (Top.homeo_of_iso E).inducing\n    -- Reduce to the assertion of the theorem with `D` instead of `C`.\n    suffices\n      is_topological_basis { U : set D.X | ∃ (j : _)(V : set (F.obj j)), V ∈ T j ∧ U = «expr ⁻¹' » (D.π.app j) V }\n      by\n      convert this.inducing hE\n      ext U0\n      constructor\n      · rintro ⟨j, V, hV, rfl⟩\n        refine' ⟨«expr ⁻¹' » (D.π.app j) V, ⟨j, V, hV, rfl⟩, rfl⟩\n      · rintro ⟨W, ⟨j, V, hV, rfl⟩, rfl⟩\n        refine' ⟨j, V, hV, rfl⟩\n    -- Using `D`, we can apply the characterization of the topological basis of a\n    -- topology defined as an infimum...\n    convert is_topological_basis_infi hT fun j (x : D.X) => D.π.app j x\n    ext U0\n    constructor\n    · rintro ⟨j, V, hV, rfl⟩\n      let U : ∀ i, set (F.obj i) := fun i =>\n        if h : i = j then by\n          rw [h]\n          exact V\n        else Set.univ\n      refine' ⟨U, {j}, _, _⟩\n      · rintro i h\n        rw [Finset.mem_singleton] at h\n        dsimp [U]\n        rw [dif_pos h]\n        subst h\n        exact hV\n      · dsimp [U]\n        simp\n    · rintro ⟨U, G, h1, h2⟩\n      obtain ⟨j, hj⟩ := is_cofiltered.inf_objs_exists G\n      let g : ∀ (e) (he : e ∈ G), «expr ⟶ » j e := fun _ he => (hj he).some\n      let Vs : J → set (F.obj j) := fun e => if h : e ∈ G then «expr ⁻¹' » (F.map (g e h)) (U e) else Set.univ\n      let V : set (F.obj j) :=\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Vs e)\n      refine' ⟨j, V, _, _⟩\n      · -- An intermediate claim used to apply induction along `G : finset J` later on.\n        have :\n          ∀ (S : set (set (F.obj j))) (E : Finset J) (P : J → set (F.obj j)) (univ : Set.univ ∈ S)\n            (inter : ∀ A B : set (F.obj j), A ∈ S → B ∈ S → A ∩ B ∈ S) (cond : ∀ (e : J) (he : e ∈ E), P e ∈ S),\n            «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (P e) ∈ S :=\n          by\n          intro S E\n          apply E.induction_on\n          · intro P he hh\n            simpa\n          · intro a E ha hh1 hh2 hh3 hh4 hh5\n            rw [finset.set_bInter_insert]\n            refine' hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 _)\n            intro e he\n            exact hh5 e (Finset.mem_insert_of_mem he)\n        -- use the intermediate claim to finish off the goal using `univ` and `inter`.\n        refine' this _ _ _ (univ _) (inter _) _\n        intro e he\n        dsimp [Vs]\n        rw [dif_pos he]\n        exact compat j e (g e he) (U e) (h1 e he)\n      · -- conclude...\n        rw [h2]\n        dsimp [V]\n        rw [Set.preimage_interᵢ]\n        congr 1\n        ext1 e\n        rw [Set.preimage_interᵢ]\n        congr 1\n        ext1 he\n        dsimp [Vs]\n        rw [dif_pos he, ← Set.preimage_comp]\n        congr 1\n        change _ = «expr⇑ » («expr ≫ » (D.π.app j) (F.map (g e he)))\n        rw [D.w]\n#align is_topological_basis_cofiltered_limit is_topological_basis_cofiltered_limit\n\n",
 "init":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/-- This bootstraps `nonempty_sections_of_fintype_inverse_system`. In this version,\nthe `F` functor is between categories of the same universe, and it is an easy\ncorollary to `Top.nonempty_limit_cone_of_compact_t2_inverse_system`. -/\ntheorem nonempty_sections_of_fintype_cofiltered_system.init {J : Type u} [SmallCategory J] [is_cofiltered J]\n    (F : «expr ⥤ » J (Type u)) [hf : ∀ j : J, fintype (F.obj j)] [hne : ∀ j : J, nonempty (F.obj j)] :\n    F.sections.nonempty := by\n  let F' : «expr ⥤ » J Top := «expr ⋙ » F Top.discrete\n  haveI : ∀ j : J, fintype (F'.obj j) := hf\n  haveI : ∀ j : J, nonempty (F'.obj j) := hne\n  obtain ⟨⟨u, hu⟩⟩ := Top.nonempty_limit_cone_of_compact_t2_cofiltered_system F'\n  exact ⟨u, fun _ _ f => hu f⟩\n#align nonempty_sections_of_fintype_cofiltered_system.init nonempty_sections_of_fintype_cofiltered_system.init\n\n",
 "inducing_pullback_to_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\ntheorem inducing_pullback_to_prod {X Y Z : Top} (f : «expr ⟶ » X Z) (g : «expr ⟶ » Y Z) :\n    inducing («expr⇑ » (prod.lift pullback.fst pullback.snd : «expr ⟶ » (pullback f g) («expr ⨯ » X Y))) :=\n  ⟨by simp [prod_topology, pullback_topology, induced_compose, ← coe_comp]⟩\n#align inducing_pullback_to_prod inducing_pullback_to_prod\n\n",
 "inducing_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem inducing_prod_map {W X Y Z : Top} {f : «expr ⟶ » W X} {g : «expr ⟶ » Y Z} (hf : inducing f) (hg : inducing g) :\n    inducing (limits.prod.map f g) := by\n  constructor\n  simp only [prod_topology, induced_compose, ← coe_comp, limits.prod.map_fst, limits.prod.map_snd, induced_inf]\n  simp only [coe_comp]\n  rw [← @induced_compose _ _ _ _ _ f, ← @induced_compose _ _ _ _ _ g, ← hf.induced, ← hg.induced]\n#align inducing_prod_map inducing_prod_map\n\n",
 "induced_of_is_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem induced_of_is_limit {F : «expr ⥤ » J Top.{max v u}} (C : cone F) (hC : is_limit C) :\n    C.X.topological_space =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((F.obj j).topological_space.induced (C.π.app j)) :=\n  by\n  let homeo := homeo_of_iso (hC.cone_point_unique_up_to_iso (limit_cone_infi_is_limit F))\n  refine' homeo.inducing.induced.trans _\n  change\n    induced homeo («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" _) =\n      _\n  simpa [induced_infi, induced_compose]\n#align induced_of_is_limit induced_of_is_limit\n\n",
 "fst_open_embedding_of_right_open_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem fst_open_embedding_of_right_open_embedding {X Y S : Top} (f : «expr ⟶ » X S) {g : «expr ⟶ » Y S}\n    (H : open_embedding g) : open_embedding («expr⇑ » (pullback.fst : «expr ⟶ » (pullback f g) X)) :=\n  by\n  convert\n    (homeo_of_iso (as_iso (pullback.fst : «expr ⟶ » (pullback f ((«expr𝟙») S)) _))).open_embedding.comp\n      (pullback_map_open_embedding_of_open_embeddings f g f ((«expr𝟙») _) (homeo_of_iso (iso.refl _)).open_embedding H\n        ((«expr𝟙») _) rfl (by simp))\n  erw [← coe_comp]\n  simp\n#align fst_open_embedding_of_right_open_embedding fst_open_embedding_of_right_open_embedding\n\n",
 "fst_iso_of_right_embedding_range_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem fst_iso_of_right_embedding_range_subset {X Y S : Top} (f : «expr ⟶ » X S) {g : «expr ⟶ » Y S} (hg : embedding g)\n    (H : Set.range f ⊆ Set.range g) : IsIso (pullback.fst : «expr ⟶ » (pullback f g) X) :=\n  by\n  let this : «expr ≃ₜ » (pullback f g : Top) X :=\n    (homeomorph.of_embedding _ (fst_embedding_of_right_embedding f hg)).trans\n      { to_fun := coe\n        inv_fun := fun x =>\n          ⟨x, by\n            rw [pullback_fst_range]\n            exact ⟨_, (H (Set.mem_range_self x)).some_spec.symm⟩⟩\n        left_inv := fun ⟨_, _⟩ => rfl\n        right_inv := fun x => rfl }\n  convert is_iso.of_iso (iso_of_homeo this)\n  ext\n  rfl\n#align fst_iso_of_right_embedding_range_subset fst_iso_of_right_embedding_range_subset\n\n",
 "fst_embedding_of_right_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem fst_embedding_of_right_embedding {X Y S : Top} (f : «expr ⟶ » X S) {g : «expr ⟶ » Y S} (H : embedding g) :\n    embedding («expr⇑ » (pullback.fst : «expr ⟶ » (pullback f g) X)) :=\n  by\n  convert\n    (homeo_of_iso (as_iso (pullback.fst : «expr ⟶ » (pullback f ((«expr𝟙») S)) _))).embedding.comp\n      (pullback_map_embedding_of_embeddings f g f ((«expr𝟙») _) (homeo_of_iso (iso.refl _)).embedding H ((«expr𝟙») _)\n        rfl (by simp))\n  erw [← coe_comp]\n  simp\n#align fst_embedding_of_right_embedding fst_embedding_of_right_embedding\n\n",
 "embedding_pullback_to_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⨯ » -/\ntheorem embedding_pullback_to_prod {X Y Z : Top} (f : «expr ⟶ » X Z) (g : «expr ⟶ » Y Z) :\n    embedding («expr⇑ » (prod.lift pullback.fst pullback.snd : «expr ⟶ » (pullback f g) («expr ⨯ » X Y))) :=\n  ⟨inducing_pullback_to_prod f g, (Top.mono_iff_injective _).mp infer_instance⟩\n#align embedding_pullback_to_prod embedding_pullback_to_prod\n\n",
 "embedding_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem embedding_prod_map {W X Y Z : Top} {f : «expr ⟶ » W X} {g : «expr ⟶ » Y Z} (hf : embedding f)\n    (hg : embedding g) : embedding (limits.prod.map f g) :=\n  ⟨inducing_prod_map hf.to_inducing hg.to_inducing,\n    by\n    haveI := (Top.mono_iff_injective _).mpr hf.inj\n    haveI := (Top.mono_iff_injective _).mpr hg.inj\n    exact (Top.mono_iff_injective _).mp infer_instance⟩\n#align embedding_prod_map embedding_prod_map\n\n",
 "embedding_of_pullback_embeddings":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem embedding_of_pullback_embeddings {X Y S : Top} {f : «expr ⟶ » X S} {g : «expr ⟶ » Y S} (H₁ : embedding f)\n    (H₂ : embedding g) : embedding (limit.π (cospan f g) walking_cospan.one) :=\n  by\n  convert H₂.comp (snd_embedding_of_left_embedding H₁ g)\n  erw [← coe_comp]\n  congr\n  exact (limit.w _ walking_cospan.hom.inr).symm\n#align embedding_of_pullback_embeddings embedding_of_pullback_embeddings\n\n",
 "directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem partial_sections.directed : Directed superset fun G : finite_diagram J => partial_sections F G.2 := by\n  classical\n    intro A B\n    let ιA : finite_diagram_arrow A.1 → finite_diagram_arrow («expr ⊔ » A.1 B.1) := fun f =>\n      ⟨f.1, f.2.1, Finset.mem_union_left _ f.2.2.1, Finset.mem_union_left _ f.2.2.2.1, f.2.2.2.2⟩\n    let ιB : finite_diagram_arrow B.1 → finite_diagram_arrow («expr ⊔ » A.1 B.1) := fun f =>\n      ⟨f.1, f.2.1, Finset.mem_union_right _ f.2.2.1, Finset.mem_union_right _ f.2.2.2.1, f.2.2.2.2⟩\n    refine' ⟨⟨«expr ⊔ » A.1 B.1, «expr ⊔ » (A.2.image ιA) (B.2.image ιB)⟩, _, _⟩\n    · rintro u hu f hf\n      have : ιA f ∈ «expr ⊔ » (A.2.image ιA) (B.2.image ιB) :=\n        by\n        apply Finset.mem_union_left\n        rw [Finset.mem_image]\n        refine' ⟨f, hf, rfl⟩\n      exact hu this\n    · rintro u hu f hf\n      have : ιB f ∈ «expr ⊔ » (A.2.image ιA) (B.2.image ιB) :=\n        by\n        apply Finset.mem_union_right\n        rw [Finset.mem_image]\n        refine' ⟨f, hf, rfl⟩\n      exact hu this\n#align partial_sections.directed partial_sections.directed\n\n",
 "colimit_topology":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem colimit_topology (F : «expr ⥤ » J Top.{max v u}) :\n    (colimit F).topological_space =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        ((F.obj j).topological_space.coinduced (colimit.ι F j)) :=\n  coinduced_of_is_colimit _ (colimit.is_colimit F)\n#align colimit_topology colimit_topology\n\n",
 "colimit_is_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem colimit_is_open_iff (F : «expr ⥤ » J Top.{max v u}) (U : set ((colimit F : _) : Type max v u)) :\n    is_open U ↔ ∀ j, is_open («expr ⁻¹' » (colimit.ι F j) U) :=\n  by\n  conv_lhs => rw [colimit_topology F]\n  exact is_open_supr_iff\n#align colimit_is_open_iff colimit_is_open_iff\n\n",
 "coinduced_of_is_colimit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n--TODO: Add analogous constructions for `pushout`.\ntheorem coinduced_of_is_colimit {F : «expr ⥤ » J Top.{max v u}} (c : cocone F) (hc : is_colimit c) :\n    c.X.topological_space =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        ((F.obj j).topological_space.coinduced (c.ι.app j)) :=\n  by\n  let homeo := homeo_of_iso (hc.cocone_point_unique_up_to_iso (colimit_cocone_is_colimit F))\n  ext\n  refine' homeo.symm.is_open_preimage.symm.trans (iff.trans _ is_open_supr_iff.symm)\n  exact is_open_supr_iff\n#align coinduced_of_is_colimit coinduced_of_is_colimit\n\n",
 "coequalizer_is_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem coequalizer_is_open_iff (F : «expr ⥤ » walking_parallel_pair Top.{u}) (U : set ((colimit F : _) : Type u)) :\n    is_open U ↔ is_open («expr ⁻¹' » (colimit.ι F walking_parallel_pair.one) U) :=\n  by\n  rw [colimit_is_open_iff.{u}]\n  constructor\n  · intro H\n    exact H _\n  · intro H j\n    cases j\n    · rw [← colimit.w F walking_parallel_pair_hom.left]\n      exact (F.map walking_parallel_pair_hom.left).continuous_to_fun.is_open_preimage _ H\n    · exact H\n#align coequalizer_is_open_iff coequalizer_is_open_iff\n\n",
 "closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem partial_sections.closed [∀ j : J, t2_space (F.obj j)] {G : Finset J} (H : Finset (finite_diagram_arrow G)) :\n    is_closed (partial_sections F H) :=\n  by\n  have :\n    partial_sections F H =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        { u | F.map f.2.2.2.2 (u f.1) = u f.2.1 } :=\n    by\n    ext1\n    simp only [Set.mem_interᵢ, Set.mem_setOf_eq]\n    rfl\n  rw [this]\n  apply is_closed_bInter\n  intro f hf\n  apply is_closed_eq\n  continuity\n#align partial_sections.closed partial_sections.closed\n\n",
 "binary_cofan_is_colimit_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem binary_cofan_is_colimit_iff {X Y : Top} (c : binary_cofan X Y) :\n    nonempty (is_colimit c) ↔\n      open_embedding c.inl ∧ open_embedding c.inr ∧ IsCompl (Set.range c.inl) (Set.range c.inr) :=\n  by\n  classical\n    constructor\n    · rintro ⟨h⟩\n      rw [←\n        show _ = c.inl from h.comp_cocone_point_unique_up_to_iso_inv (binary_cofan_is_colimit X Y) ⟨walking_pair.left⟩,\n        ←\n        show _ = c.inr from h.comp_cocone_point_unique_up_to_iso_inv (binary_cofan_is_colimit X Y) ⟨walking_pair.right⟩]\n      dsimp\n      refine'\n        ⟨(homeo_of_iso <| h.cocone_point_unique_up_to_iso (binary_cofan_is_colimit X Y)).symm.open_embedding.comp\n            open_embedding_inl,\n          (homeo_of_iso <| h.cocone_point_unique_up_to_iso (binary_cofan_is_colimit X Y)).symm.open_embedding.comp\n            open_embedding_inr,\n          _⟩\n      erw [Set.range_comp, ← eq_compl_iff_isCompl, Set.range_comp _ sum.inr, ←\n        Set.image_compl_eq\n          (homeo_of_iso <| h.cocone_point_unique_up_to_iso (binary_cofan_is_colimit X Y)).symm.bijective]\n      congr 1\n      exact set.compl_range_inr.symm\n    · rintro ⟨h₁, h₂, h₃⟩\n      have : ∀ x, x ∈ Set.range c.inl ∨ x ∈ Set.range c.inr :=\n        by\n        rw [eq_compl_iff_is_compl.mpr h₃.symm]\n        exact fun _ => or_not\n      refine' ⟨binary_cofan.is_colimit.mk _ _ _ _ _⟩\n      · intro T f g\n        refine' continuous_map.mk _ _\n        ·\n          exact fun x =>\n            if h : x ∈ Set.range c.inl then f ((Equiv.ofInjective _ h₁.inj).symm ⟨x, h⟩)\n            else g ((Equiv.ofInjective _ h₂.inj).symm ⟨x, (this x).resolve_left h⟩)\n        rw [continuous_iff_continuous_at]\n        intro x\n        by_cases x ∈ Set.range c.inl\n        · revert h x\n          apply (is_open.continuous_on_iff _).mp\n          · rw [continuous_on_iff_continuous_restrict]\n            convert_to continuous (f ∘ (homeomorph.of_embedding _ h₁.to_embedding).symm)\n            · ext ⟨x, hx⟩\n              exact dif_pos hx\n            continuity\n          · exact h₁.open_range\n        · revert h x\n          apply (is_open.continuous_on_iff _).mp\n          · rw [continuous_on_iff_continuous_restrict]\n            have : ∀ a, a ∉ Set.range c.inl → a ∈ Set.range c.inr :=\n              by\n              rintro a (h : a ∈ «expr ᶜ» (Set.range c.inl))\n              rwa [eq_compl_iff_is_compl.mpr h₃.symm]\n            convert_to continuous (g ∘ (homeomorph.of_embedding _ h₂.to_embedding).symm ∘ subtype.map _ this)\n            · ext ⟨x, hx⟩\n              exact dif_neg hx\n            continuity\n            rw [embedding_subtype_coe.to_inducing.continuous_iff]\n            exact continuous_subtype_coe\n          · change is_open («expr ᶜ» (Set.range c.inl))\n            rw [← eq_compl_iff_is_compl.mpr h₃.symm]\n            exact h₂.open_range\n      · intro T f g\n        ext x\n        refine' (dif_pos _).trans _\n        · exact ⟨x, rfl⟩\n        · rw [Equiv.ofInjective_symm_apply]\n      · intro T f g\n        ext x\n        refine' (dif_neg _).trans _\n        · rintro ⟨y, e⟩\n          have : c.inr x ∈ «expr ⊓ » (Set.range c.inl) (Set.range c.inr) := ⟨⟨_, e⟩, ⟨_, rfl⟩⟩\n          rwa [disjoint_iff.mp h₃.1] at this\n        · exact congr_arg g (Equiv.ofInjective_symm_apply _ _)\n      · rintro T _ _ m rfl rfl\n        ext x\n        change m x = dite _ _ _\n        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ ⟨_, _⟩).symm\n#align binary_cofan_is_colimit_iff binary_cofan_is_colimit_iff\n\n"}