{"range":
 "theorem noetherian_space.range [noetherian_space α] (f : α → β) (hf : continuous f) : noetherian_space (Set.range f) :=\n  noetherian_space_of_surjective (Set.codRestrict f _ Set.mem_range_self) (by continuity) fun ⟨a, b, h⟩ =>\n    ⟨b, subtype.ext h⟩\n#align noetherian_space.range noetherian_space.range\n\n",
 "noetherian_univ_iff":
 "@[simp]\ntheorem noetherian_univ_iff : noetherian_space (Set.univ : set α) ↔ noetherian_space α :=\n  noetherian_space_iff_of_homeomorph (homeomorph.set.univ α)\n#align noetherian_univ_iff noetherian_univ_iff\n\n",
 "noetherian_space_tfae":
 "/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `noetherian_space_tfae [])\n      (Command.declSig\n       []\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `noetherian_space [`α])\n            \",\"\n            (Term.app\n             `well_founded\n             [(Term.fun\n               \"fun\"\n               (Term.basicFun [`s `t] [(Term.typeSpec \":\" (Term.app `closeds [`α]))] \"=>\" («term_<_» `s \"<\" `t)))])\n            \",\"\n            (Term.forall \"∀\" [`s] [(Term.typeSpec \":\" (Term.app `set [`α]))] \",\" (Term.app `is_compact [`s]))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [`s]\n             [(Term.typeSpec \":\" (Term.app `opens [`α]))]\n             \",\"\n             (Term.app `is_compact [(Term.typeAscription \"(\" `s \":\" [(Term.app `set [`α])] \")\")]))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.refine'\n              \"refine'\"\n              (Term.app\n               (Term.proj (Term.app `noetherian_space_iff [(Term.hole \"_\")]) \".\" `trans)\n               [(Term.app\n                 `Surjective.wellFounded_iff\n                 [(Term.proj `opens.compl_bijective \".\" (fieldIdx \"2\")) (Term.hole \"_\")])]))\n             []\n             (Tactic.exact\n              \"exact\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`s `t]\n                []\n                \"=>\"\n                (Term.proj (Term.proj (Term.app `OrderIso.compl [(Term.app `set [`α])]) \".\" `lt_iff_lt) \".\" `symm))))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact \"exact\" (Term.app `noetherian_space_iff_opens [`α]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`H `s])\n             []\n             (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `is_compact_iff_compact_space)] \"]\") [])\n             []\n             (Tactic.skip \"skip\")\n             []\n             (Tactic.tacticInfer_instance \"infer_instance\")])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact \"exact\" (Term.fun \"fun\" (Term.basicFun [`H `s] [] \"=>\" (Term.app `H [`s]))))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.refine'\n             \"refine'\"\n             (Term.app\n              (Term.proj (Term.app `noetherian_space_iff [(Term.hole \"_\")]) \".\" `trans)\n              [(Term.app\n                `Surjective.wellFounded_iff\n                [(Term.proj `opens.compl_bijective \".\" (fieldIdx \"2\")) (Term.hole \"_\")])]))\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`s `t]\n               []\n               \"=>\"\n               (Term.proj (Term.proj (Term.app `OrderIso.compl [(Term.app `set [`α])]) \".\" `lt_iff_lt) \".\" `symm))))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact \"exact\" (Term.app `noetherian_space_iff_opens [`α]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H `s])\n            []\n            (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `is_compact_iff_compact_space)] \"]\") [])\n            []\n            (Tactic.skip \"skip\")\n            []\n            (Tactic.tacticInfer_instance \"infer_instance\")])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact \"exact\" (Term.fun \"fun\" (Term.basicFun [`H `s] [] \"=>\" (Term.app `H [`s]))))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.exact \"exact\" (Term.fun \"fun\" (Term.basicFun [`H `s] [] \"=>\" (Term.app `H [`s]))))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.fun \"fun\" (Term.basicFun [`H `s] [] \"=>\" (Term.app `H [`s]))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun \"fun\" (Term.basicFun [`H `s] [] \"=>\" (Term.app `H [`s])))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `H [`s])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `s\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `s\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"4\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  noetherian_space_tfae\n  :\n    TFAE\n      [\n        noetherian_space α\n          ,\n          well_founded fun s t : closeds α => s < t\n          ,\n          ∀ s : set α , is_compact s\n          ,\n          ∀ s : opens α , is_compact ( s : set α )\n        ]\n  :=\n    by\n      tfae_have 1 ↔ 2\n        ·\n          refine' noetherian_space_iff _ . trans Surjective.wellFounded_iff opens.compl_bijective . 2 _\n            exact fun s t => OrderIso.compl set α . lt_iff_lt . symm\n        tfae_have 1 ↔ 4\n        · exact noetherian_space_iff_opens α\n        tfae_have 1 → 3\n        · intro H s rw [ is_compact_iff_compact_space ] skip infer_instance\n        tfae_have 3 → 4\n        · exact fun H s => H s\n        tfae_finish\n#align noetherian_space_tfae noetherian_space_tfae\n\n",
 "noetherian_space_set_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\ntheorem noetherian_space_set_iff (s : set α) : noetherian_space s ↔ ∀ (t) (_ : t ⊆ s), is_compact t :=\n  by\n  rw [(noetherian_space_tfae s).out 0 2]\n  constructor\n  · intro H t ht\n    have := embedding_subtype_coe.is_compact_iff_is_compact_image.mp (H («expr ⁻¹' » coe t))\n    simpa [set.inter_eq_left_iff_subset.mpr ht] using this\n  · intro H t\n    refine' embedding_subtype_coe.is_compact_iff_is_compact_image.mpr (H («expr '' » coe t) _)\n    simp\n#align noetherian_space_set_iff noetherian_space_set_iff\n\n",
 "noetherian_space_of_surjective":
 "theorem noetherian_space_of_surjective [noetherian_space α] (f : α → β) (hf : continuous f)\n    (hf' : function.surjective f) : noetherian_space β :=\n  by\n  rw [noetherian_space_iff_opens]\n  intro s\n  obtain ⟨t, e⟩ := set.image_surjective.mpr hf' s\n  exact e ▸ (noetherian_space.is_compact t).image hf\n#align noetherian_space_of_surjective noetherian_space_of_surjective\n\n",
 "noetherian_space_iff_opens":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem noetherian_space_iff_opens : noetherian_space α ↔ ∀ s : opens α, is_compact (s : set α) :=\n  by\n  rw [noetherian_space_iff, complete_lattice.well_founded_iff_is_Sup_finite_compact,\n    complete_lattice.is_Sup_finite_compact_iff_all_elements_compact]\n  exact forall_congr' opens.is_compact_element_iff\n#align noetherian_space_iff_opens noetherian_space_iff_opens\n\n",
 "noetherian_space_iff_of_homeomorph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₜ » -/\ntheorem noetherian_space_iff_of_homeomorph (f : «expr ≃ₜ » α β) : noetherian_space α ↔ noetherian_space β :=\n  ⟨fun h => @noetherian_space_of_surjective _ _ h f f.continuous f.surjective, fun h =>\n    @noetherian_space_of_surjective _ _ h f.symm f.symm.continuous f.symm.surjective⟩\n#align noetherian_space_iff_of_homeomorph noetherian_space_iff_of_homeomorph\n\n",
 "is_compact":
 "theorem noetherian_space.is_compact [h : noetherian_space α] (s : set α) : is_compact s :=\n  let H := (noetherian_space_tfae α).out 0 2\n  H.mp h s\n#align noetherian_space.is_compact noetherian_space.is_compact\n\n",
 "finite_irreducible_components":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem noetherian_space.finite_irreducible_components [noetherian_space α] : (irreducible_components α).finite := by\n  classical\n    obtain ⟨S, hS₁, hS₂⟩ := noetherian_space.exists_finset_irreducible («expr⊤» : closeds α)\n    suffices irreducible_components α ⊆ «expr '' » coe (S : set <| closeds α) by\n      exact set.finite.subset ((set.finite.intro infer_instance).image _) this\n    intro K hK\n    obtain ⟨z, hz, hz'⟩ : ∃ (z : set α)(H : z ∈ Finset.image coe S), K ⊆ z :=\n      by\n      convert is_irreducible_iff_sUnion_closed.mp hK.1 (S.image coe) _ _\n      · simp only [Finset.mem_image, exists_prop, forall_exists_index, and_imp]\n        rintro _ z hz rfl\n        exact z.2\n      · exact (Set.subset_univ _).trans ((congr_arg coe hS₂).trans <| by simp).subset\n    obtain ⟨s, hs, e⟩ := finset.mem_image.mp hz\n    rw [← e] at hz'\n    refine' ⟨s, hs, _⟩\n    symm\n    suffices K ≤ s by exact this.antisymm (hK.2 (hS₁ ⟨s, hs⟩) this)\n    simpa\n#align noetherian_space.finite_irreducible_components noetherian_space.finite_irreducible_components\n\n",
 "finite":
 "/-- Spaces that are both Noetherian and Hausdorff is finite. -/\ntheorem noetherian_space.finite [noetherian_space α] [t2_space α] : Finite α :=\n  by\n  letI : fintype α := set.fintype_of_finite_univ (noetherian_space.is_compact Set.univ).finite_of_discrete\n  infer_instance\n#align noetherian_space.finite noetherian_space.finite\n\n",
 "exists_finset_irreducible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem noetherian_space.exists_finset_irreducible [noetherian_space α] (s : closeds α) :\n    ∃ S : Finset (closeds α), (∀ k : S, is_irreducible (k : set α)) ∧ s = S.sup id := by\n  classical\n    have := ((noetherian_space_tfae α).out 0 1).mp infer_instance\n    apply well_founded.induction this s\n    clear s\n    intro s H\n    by_cases h₁ : is_preirreducible s.1\n    cases h₂ : s.1.eq_empty_or_nonempty\n    · use ∅\n      refine' ⟨fun k => k.2.elim, _⟩\n      rw [finset.sup_empty]\n      ext1\n      exact h\n    · use {s}\n      simp only [coe_coe, finset.sup_singleton, id.def, eq_self_iff_true, and_true_iff]\n      rintro ⟨k, hk⟩\n      cases finset.mem_singleton.mp hk\n      exact ⟨h, h₁⟩\n    · rw [is_preirreducible_iff_closed_union_closed] at h₁\n      push_neg  at h₁\n      obtain ⟨z₁, z₂, hz₁, hz₂, h, hz₁', hz₂'⟩ := h₁\n      obtain ⟨S₁, hS₁, hS₁'⟩ := H («expr ⊓ » s ⟨z₁, hz₁⟩) (inf_lt_left.2 hz₁')\n      obtain ⟨S₂, hS₂, hS₂'⟩ := H («expr ⊓ » s ⟨z₂, hz₂⟩) (inf_lt_left.2 hz₂')\n      refine' ⟨S₁ ∪ S₂, fun k => _, _⟩\n      · cases' finset.mem_union.mp k.2 with h' h'\n        exacts[hS₁ ⟨k, h'⟩, hS₂ ⟨k, h'⟩]\n      · rwa [finset.sup_union, ← hS₁', ← hS₂', ← inf_sup_left, left_eq_inf]\n#align noetherian_space.exists_finset_irreducible noetherian_space.exists_finset_irreducible\n\n",
 "discrete":
 "-- This is not an instance since it makes a loop with `t2_space_discrete`.\ntheorem noetherian_space.discrete [noetherian_space α] [t2_space α] : discrete_topology α :=\n  ⟨eq_bot_iff.mpr fun U _ => is_closed_compl_iff.mp (noetherian_space.is_compact _).is_closed⟩\n#align noetherian_space.discrete noetherian_space.discrete\n\n",
 "Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem noetherian_space.Union {ι : Type _} (f : ι → set α) [Finite ι] [hf : ∀ i, noetherian_space (f i)] :\n    noetherian_space\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  by\n  cases nonempty_fintype ι\n  simp_rw [noetherian_space_set_iff] at hf⊢\n  intro t ht\n  rw [← set.inter_eq_left_iff_subset.mpr ht, Set.inter_unionᵢ]\n  exact is_compact_Union fun i => hf i _ (Set.inter_subset_right _ _)\n#align noetherian_space.Union noetherian_space.Union\n\n"}