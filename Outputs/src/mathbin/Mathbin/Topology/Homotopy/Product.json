{"proj_right_prod":
 "@[simp]\ntheorem proj_right_prod : proj_right (prod q₁ q₂) = q₂ :=\n  by\n  apply quotient.induction_on₂ q₁ q₂\n  intro p₁ p₂\n  unfold proj_right\n  rw [prod_lift, ← path.homotopic.map_lift]\n  congr ; ext; rfl\n#align proj_right_prod proj_right_prod\n\n",
 "proj_pi":
 "/-- Lemmas showing projection is the inverse of pi -/\n@[simp]\ntheorem proj_pi (i : ι) (paths : ∀ i, path.homotopic.quotient (as i) (bs i)) : proj i (pi paths) = paths i :=\n  by\n  apply quotient.induction_on_pi paths\n  intro ; unfold proj\n  rw [pi_lift, ← path.homotopic.map_lift]\n  congr ; ext; rfl\n#align proj_pi proj_pi\n\n",
 "proj_left_prod":
 "/-- Lemmas showing projection is the inverse of product -/\n@[simp]\ntheorem proj_left_prod : proj_left (prod q₁ q₂) = q₁ :=\n  by\n  apply quotient.induction_on₂ q₁ q₂\n  intro p₁ p₂\n  unfold proj_left\n  rw [prod_lift, ← path.homotopic.map_lift]\n  congr ; ext; rfl\n#align proj_left_prod proj_left_prod\n\n",
 "prod_proj_left_proj_right":
 "@[simp]\ntheorem prod_proj_left_proj_right (p : path.homotopic.quotient (a₁, b₁) (a₂, b₂)) :\n    prod (proj_left p) (proj_right p) = p := by\n  apply Quotient.inductionOn p\n  intro p'\n  unfold proj_left; unfold proj_right\n  simp only [← path.homotopic.map_lift, prod_lift]\n  congr ; ext <;> rfl\n#align prod_proj_left_proj_right prod_proj_left_proj_right\n\n",
 "prod_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem prod_lift : prod («expr⟦ ⟧» p₁) («expr⟦ ⟧» p₂) = «expr⟦ ⟧» (p₁.prod p₂) :=\n  rfl\n#align prod_lift prod_lift\n\n",
 "pi_proj":
 "@[simp]\ntheorem pi_proj (p : path.homotopic.quotient as bs) : (pi fun i => proj i p) = p :=\n  by\n  apply Quotient.inductionOn p\n  intro ; unfold proj\n  simp_rw [← path.homotopic.map_lift]\n  rw [pi_lift]\n  congr ; ext; rfl\n#align pi_proj pi_proj\n\n",
 "pi_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/-\nCopyright (c) 2021 Praneeth Kolichala. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Praneeth Kolichala\n-/\ntheorem pi_lift (γ : ∀ i, path (as i) (bs i)) : (path.homotopic.pi fun i => «expr⟦ ⟧» (γ i)) = «expr⟦ ⟧» (path.pi γ) :=\n  by\n  unfold pi\n  simp\n#align pi_lift pi_lift\n\n",
 "comp_prod_eq_prod_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⬝ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⬝ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⬝ » -/\n/-- Products commute with path composition.\n    This is `trans_prod_eq_prod_trans` descended to the quotient.-/\ntheorem comp_prod_eq_prod_comp : «expr ⬝ » (prod q₁ q₂) (prod r₁ r₂) = prod («expr ⬝ » q₁ r₁) («expr ⬝ » q₂ r₂) :=\n  by\n  apply quotient.induction_on₂ q₁ q₂\n  apply quotient.induction_on₂ r₁ r₂\n  intros\n  simp only [prod_lift, ← path.homotopic.comp_lift, path.trans_prod_eq_prod_trans]\n#align comp_prod_eq_prod_comp comp_prod_eq_prod_comp\n\n",
 "comp_pi_eq_pi_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⬝ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⬝ » -/\n/-- Composition and products commute.\n  This is `path.trans_pi_eq_pi_trans` descended to path homotopy classes -/\ntheorem comp_pi_eq_pi_comp (γ₀ : ∀ i, path.homotopic.quotient (as i) (bs i))\n    (γ₁ : ∀ i, path.homotopic.quotient (bs i) (cs i)) :\n    «expr ⬝ » (pi γ₀) (pi γ₁) = pi fun i => «expr ⬝ » (γ₀ i) (γ₁ i) :=\n  by\n  apply quotient.induction_on_pi γ₁\n  apply quotient.induction_on_pi γ₀\n  intros\n  simp only [pi_lift]\n  rw [← path.homotopic.comp_lift, path.trans_pi_eq_pi_trans, ← pi_lift]\n  rfl\n#align comp_pi_eq_pi_comp comp_pi_eq_pi_comp\n\n"}