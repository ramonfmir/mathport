{"unflip_flip":
 "@[simp]\ntheorem unflip_flip {X α β : Type _} [fintype α] [topological_space X] (f : locally_constant X (α → β)) :\n    unflip f.flip = f := by\n  ext\n  rfl\n#align unflip_flip unflip_flip\n\n",
 "to_fun_eq_coe":
 "@[simp]\ntheorem to_fun_eq_coe (f : locally_constant X Y) : f.to_fun = f :=\n  rfl\n#align to_fun_eq_coe to_fun_eq_coe\n\n",
 "to_continuous_map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem to_continuous_map_injective :\n    function.injective (to_continuous_map : locally_constant X Y → «exprC( , )» X Y) := fun _ _ h =>\n  ext (continuous_map.congr_fun h)\n#align to_continuous_map_injective to_continuous_map_injective\n\n",
 "to_continuous_map_eq_coe":
 "@[simp]\ntheorem to_continuous_map_eq_coe : f.to_continuous_map = f :=\n  rfl\n#align to_continuous_map_eq_coe to_continuous_map_eq_coe\n\n",
 "tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [(Command.protected \"protected\")] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `tfae [])\n      (Command.declSig\n       [(Term.explicitBinder \"(\" [`f] [\":\" (Term.arrow `X \"→\" `Y)] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `is_locally_constant [`f])\n            \",\"\n            (Term.forall\n             \"∀\"\n             [`x]\n             []\n             \",\"\n             (Term.app\n              `«expr∀ᶠ in , »\n              [(str \"\\\"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\\\"\")\n               (Term.app (Term.app `nhds []) [`x])\n               («term_=_» (Term.app `f [`x']) \"=\" (Term.app `f [`x]))]))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [`x]\n             []\n             \",\"\n             (Term.app\n              `is_open\n              [(Set.«term{_|_}»\n                \"{\"\n                (Std.ExtendedBinder.extBinder (Lean.binderIdent `x') [])\n                \"|\"\n                («term_=_» (Term.app `f [`x']) \"=\" (Term.app `f [`x]))\n                \"}\")]))\n            \",\"\n            (Term.forall \"∀\" [`y] [] \",\" (Term.app `is_open [(Term.app `«expr ⁻¹' » [`f («term{_}» \"{\" [`y] \"}\")])]))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [`x]\n             []\n             \",\"\n             («term∃_,_»\n              \"∃\"\n              (Lean.explicitBinders\n               [(Lean.bracketedExplicitBinders \"(\" [(Lean.binderIdent `U)] \":\" (Term.app `set [`X]) \")\")\n                (Lean.bracketedExplicitBinders \"(\" [(Lean.binderIdent `hU)] \":\" (Term.app `is_open [`U]) \")\")\n                (Lean.bracketedExplicitBinders \"(\" [(Lean.binderIdent `hx)] \":\" («term_∈_» `x \"∈\" `U) \")\")])\n              \",\"\n              (Std.ExtendedBinder.«term∀__,_»\n               \"∀\"\n               (Lean.binderIdent `x')\n               («binderTerm∈_» \"∈\" `U)\n               \",\"\n               («term_=_» (Term.app `f [`x']) \"=\" (Term.app `f [`x])))))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.fun \"fun\" (Term.basicFun [`h `y] [] \"=>\" (Term.app `h [(«term{_}» \"{\" [`y] \"}\")]))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"3\"))\n           \";\"\n           (Tactic.exact \"exact\" (Term.fun \"fun\" (Term.basicFun [`h `x] [] \"=>\" (Term.app `h [(Term.app `f [`x])]))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.fun \"fun\" (Term.basicFun [`h `x] [] \"=>\" (Term.app `is_open.mem_nhds [(Term.app `h [`x]) `rfl]))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"5\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`h `x])\n             []\n             (Std.Tactic.rcases\n              \"rcases\"\n              [(Tactic.casesTarget [] (Term.app (Term.proj `mem_nhds_iff \".\" (fieldIdx \"1\")) [(Term.app `h [`x])]))]\n              [\"with\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed\n                 [(Std.Tactic.RCases.rcasesPat.tuple\n                   \"⟨\"\n                   [(Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `eq)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])\n                     [])]\n                   \"⟩\")])\n                [])])\n             []\n             (Tactic.exact \"exact\" (Term.anonymousCtor \"⟨\" [`U \",\" `hU \",\" `hx \",\" `eq] \"⟩\"))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`h `s])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.app\n               (Term.proj `is_open_iff_forall_mem_open \".\" (fieldIdx \"2\"))\n               [(Term.fun \"fun\" (Term.basicFun [`x `hx] [] \"=>\" (Term.hole \"_\")))]))\n             []\n             (Std.Tactic.rcases\n              \"rcases\"\n              [(Tactic.casesTarget [] (Term.app `h [`x]))]\n              [\"with\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed\n                 [(Std.Tactic.RCases.rcasesPat.tuple\n                   \"⟨\"\n                   [(Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hxU)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `eq)])\n                     [])]\n                   \"⟩\")])\n                [])])\n             []\n             (Tactic.exact\n              \"exact\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [`U\n                \",\"\n                (Term.fun\n                 \"fun\"\n                 (Term.basicFun\n                  [`x' `hx']\n                  []\n                  \"=>\"\n                  («term_<|_»\n                   (Term.proj `mem_preimage \".\" (fieldIdx \"2\"))\n                   \"<|\"\n                   (Term.subst (Term.proj (Term.app `eq [`x' `hx']) \".\" `symm) \"▸\" [`hx]))))\n                \",\"\n                `hU\n                \",\"\n                `hxU]\n               \"⟩\"))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.fun \"fun\" (Term.basicFun [`h `y] [] \"=>\" (Term.app `h [(«term{_}» \"{\" [`y] \"}\")]))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"3\"))\n          \";\"\n          (Tactic.exact \"exact\" (Term.fun \"fun\" (Term.basicFun [`h `x] [] \"=>\" (Term.app `h [(Term.app `f [`x])]))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"2\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.fun \"fun\" (Term.basicFun [`h `x] [] \"=>\" (Term.app `is_open.mem_nhds [(Term.app `h [`x]) `rfl]))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"5\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`h `x])\n            []\n            (Std.Tactic.rcases\n             \"rcases\"\n             [(Tactic.casesTarget [] (Term.app (Term.proj `mem_nhds_iff \".\" (fieldIdx \"1\")) [(Term.app `h [`x])]))]\n             [\"with\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.tuple\n                  \"⟨\"\n                  [(Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `eq)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hx)])\n                    [])]\n                  \"⟩\")])\n               [])])\n            []\n            (Tactic.exact \"exact\" (Term.anonymousCtor \"⟨\" [`U \",\" `hU \",\" `hx \",\" `eq] \"⟩\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`h `s])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.app\n              (Term.proj `is_open_iff_forall_mem_open \".\" (fieldIdx \"2\"))\n              [(Term.fun \"fun\" (Term.basicFun [`x `hx] [] \"=>\" (Term.hole \"_\")))]))\n            []\n            (Std.Tactic.rcases\n             \"rcases\"\n             [(Tactic.casesTarget [] (Term.app `h [`x]))]\n             [\"with\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.tuple\n                  \"⟨\"\n                  [(Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hxU)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `eq)])\n                    [])]\n                  \"⟩\")])\n               [])])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [`U\n               \",\"\n               (Term.fun\n                \"fun\"\n                (Term.basicFun\n                 [`x' `hx']\n                 []\n                 \"=>\"\n                 («term_<|_»\n                  (Term.proj `mem_preimage \".\" (fieldIdx \"2\"))\n                  \"<|\"\n                  (Term.subst (Term.proj (Term.app `eq [`x' `hx']) \".\" `symm) \"▸\" [`hx]))))\n               \",\"\n               `hU\n               \",\"\n               `hxU]\n              \"⟩\"))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.intro \"intro\" [`h `s])\n        []\n        (Tactic.refine'\n         \"refine'\"\n         (Term.app\n          (Term.proj `is_open_iff_forall_mem_open \".\" (fieldIdx \"2\"))\n          [(Term.fun \"fun\" (Term.basicFun [`x `hx] [] \"=>\" (Term.hole \"_\")))]))\n        []\n        (Std.Tactic.rcases\n         \"rcases\"\n         [(Tactic.casesTarget [] (Term.app `h [`x]))]\n         [\"with\"\n          (Std.Tactic.RCases.rcasesPatLo\n           (Std.Tactic.RCases.rcasesPatMed\n            [(Std.Tactic.RCases.rcasesPat.tuple\n              \"⟨\"\n              [(Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                [])\n               \",\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                [])\n               \",\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hxU)])\n                [])\n               \",\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `eq)])\n                [])]\n              \"⟩\")])\n           [])])\n        []\n        (Tactic.exact\n         \"exact\"\n         (Term.anonymousCtor\n          \"⟨\"\n          [`U\n           \",\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [`x' `hx']\n             []\n             \"=>\"\n             («term_<|_»\n              (Term.proj `mem_preimage \".\" (fieldIdx \"2\"))\n              \"<|\"\n              (Term.subst (Term.proj (Term.app `eq [`x' `hx']) \".\" `symm) \"▸\" [`hx]))))\n           \",\"\n           `hU\n           \",\"\n           `hxU]\n          \"⟩\"))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact\n       \"exact\"\n       (Term.anonymousCtor\n        \"⟨\"\n        [`U\n         \",\"\n         (Term.fun\n          \"fun\"\n          (Term.basicFun\n           [`x' `hx']\n           []\n           \"=>\"\n           («term_<|_»\n            (Term.proj `mem_preimage \".\" (fieldIdx \"2\"))\n            \"<|\"\n            (Term.subst (Term.proj (Term.app `eq [`x' `hx']) \".\" `symm) \"▸\" [`hx]))))\n         \",\"\n         `hU\n         \",\"\n         `hxU]\n        \"⟩\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor\n       \"⟨\"\n       [`U\n        \",\"\n        (Term.fun\n         \"fun\"\n         (Term.basicFun\n          [`x' `hx']\n          []\n          \"=>\"\n          («term_<|_»\n           (Term.proj `mem_preimage \".\" (fieldIdx \"2\"))\n           \"<|\"\n           (Term.subst (Term.proj (Term.app `eq [`x' `hx']) \".\" `symm) \"▸\" [`hx]))))\n        \",\"\n        `hU\n        \",\"\n        `hxU]\n       \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hxU\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hU\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun\n       \"fun\"\n       (Term.basicFun\n        [`x' `hx']\n        []\n        \"=>\"\n        («term_<|_»\n         (Term.proj `mem_preimage \".\" (fieldIdx \"2\"))\n         \"<|\"\n         (Term.subst (Term.proj (Term.app `eq [`x' `hx']) \".\" `symm) \"▸\" [`hx]))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      («term_<|_»\n       (Term.proj `mem_preimage \".\" (fieldIdx \"2\"))\n       \"<|\"\n       (Term.subst (Term.proj (Term.app `eq [`x' `hx']) \".\" `symm) \"▸\" [`hx]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.subst (Term.proj (Term.app `eq [`x' `hx']) \".\" `symm) \"▸\" [`hx])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hx\n[PrettyPrinter.parenthesize] ...precedences are 75 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 75, term))\n      (Term.proj (Term.app `eq [`x' `hx']) \".\" `symm)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app `eq [`x' `hx'])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hx'\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `x'\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `eq\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `eq [`x' `hx']) \")\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 75, term)\n[PrettyPrinter.parenthesize] ...precedences are 10 >? 75, (some 75, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 10, term))\n      (Term.proj `mem_preimage \".\" (fieldIdx \"2\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `mem_preimage\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 10, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 10, (some 10, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hx'\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `x'\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `U\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rcases\n       \"rcases\"\n       [(Tactic.casesTarget [] (Term.app `h [`x]))]\n       [\"with\"\n        (Std.Tactic.RCases.rcasesPatLo\n         (Std.Tactic.RCases.rcasesPatMed\n          [(Std.Tactic.RCases.rcasesPat.tuple\n            \"⟨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hxU)])\n              [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `eq)])\n              [])]\n            \"⟩\")])\n         [])])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `h [`x])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.refine'\n       \"refine'\"\n       (Term.app\n        (Term.proj `is_open_iff_forall_mem_open \".\" (fieldIdx \"2\"))\n        [(Term.fun \"fun\" (Term.basicFun [`x `hx] [] \"=>\" (Term.hole \"_\")))]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       (Term.proj `is_open_iff_forall_mem_open \".\" (fieldIdx \"2\"))\n       [(Term.fun \"fun\" (Term.basicFun [`x `hx] [] \"=>\" (Term.hole \"_\")))])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun \"fun\" (Term.basicFun [`x `hx] [] \"=>\" (Term.hole \"_\")))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hx\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      (Term.proj `is_open_iff_forall_mem_open \".\" (fieldIdx \"2\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `is_open_iff_forall_mem_open\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`h `s])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `s\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\nprotected\n  theorem\n    tfae\n    ( f : X → Y )\n      :\n        TFAE\n          [\n            is_locally_constant f\n              ,\n              ∀\n                x\n                ,\n                «expr∀ᶠ in , »\n                  \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n                    nhds x\n                    f x' = f x\n              ,\n              ∀ x , is_open { x' | f x' = f x }\n              ,\n              ∀ y , is_open «expr ⁻¹' » f { y }\n              ,\n              ∀ x , ∃ ( U : set X ) ( hU : is_open U ) ( hx : x ∈ U ) , ∀ x' ∈ U , f x' = f x\n            ]\n    :=\n      by\n        tfae_have 1 → 4\n          ;\n          exact fun h y => h { y }\n          tfae_have 4 → 3\n          ;\n          exact fun h x => h f x\n          tfae_have 3 → 2\n          ;\n          exact fun h x => is_open.mem_nhds h x rfl\n          tfae_have 2 → 5\n          · intro h x rcases mem_nhds_iff . 1 h x with ⟨ U , eq , hU , hx ⟩ exact ⟨ U , hU , hx , eq ⟩\n          tfae_have 5 → 1\n          ·\n            intro h s\n              refine' is_open_iff_forall_mem_open . 2 fun x hx => _\n              rcases h x with ⟨ U , hU , hxU , eq ⟩\n              exact ⟨ U , fun x' hx' => mem_preimage . 2 <| eq x' hx' . symm ▸ hx , hU , hxU ⟩\n          tfae_finish\n#align tfae tfae\n\n",
 "range_finite":
 "theorem range_finite [compact_space X] (f : locally_constant X Y) : (Set.range f).finite :=\n  f.is_locally_constant.range_finite\n#align range_finite range_finite\n\n",
 "prod_mk":
 "theorem prod_mk {Y'} {f : X → Y} {f' : X → Y'} (hf : is_locally_constant f) (hf' : is_locally_constant f') :\n    is_locally_constant fun x => (f x, f' x) :=\n  (iff_eventually_eq _).2 fun x =>\n    (hf.eventually_eq x).mp <| (hf'.eventually_eq x).mono fun x' hf' hf => Prod.ext hf hf'\n#align prod_mk prod_mk\n\n",
 "one":
 "@[to_additive]\ntheorem one [One Y] : is_locally_constant (1 : X → Y) :=\n  const 1\n#align one one\n\n",
 "of_discrete":
 "@[nontriviality]\ntheorem of_discrete [discrete_topology X] (f : X → Y) : is_locally_constant f := fun s => is_open_discrete _\n#align of_discrete of_discrete\n\n",
 "of_constant_on_preconnected_clopens":
 "theorem of_constant_on_preconnected_clopens [locally_connected_space X] {f : X → Y}\n    (h : ∀ U : set X, is_preconnected U → is_clopen U → ∀ x ∈ U, ∀ y ∈ U, f y = f x) : is_locally_constant f :=\n  of_constant_on_connected_components fun x =>\n    h (connected_component x) is_preconnected_connected_component is_clopen_connected_component x\n      mem_connected_component\n#align of_constant_on_preconnected_clopens of_constant_on_preconnected_clopens\n\n",
 "of_constant_on_connected_components":
 "theorem of_constant_on_connected_components [locally_connected_space X] {f : X → Y}\n    (h : ∀ x, ∀ y ∈ connected_component x, f y = f x) : is_locally_constant f :=\n  by\n  rw [iff_exists_open]\n  exact fun x => ⟨connected_component x, is_open_connected_component, mem_connected_component, h x⟩\n#align of_constant_on_connected_components of_constant_on_connected_components\n\n",
 "of_constant":
 "theorem of_constant (f : X → Y) (h : ∀ x y, f x = f y) : is_locally_constant f :=\n  (iff_eventually_eq f).2 fun x => eventually_of_forall fun x' => h _ _\n#align of_constant of_constant\n\n",
 "of_clopen_fiber_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem of_clopen_fiber_zero {X : Type _} [topological_space X] {U : set X} [∀ x, decidable (x ∈ U)]\n    (hU : is_clopen U) : «expr ⁻¹' » (of_clopen hU) ({0} : set (fin 2)) = U :=\n  by\n  ext\n  simp only [of_clopen, mem_singleton_iff, Fin.one_eq_zero_iff, coe_mk, mem_preimage, ite_eq_left_iff,\n    Nat.succ_succ_ne_one]\n  tauto\n#align of_clopen_fiber_zero of_clopen_fiber_zero\n\n",
 "of_clopen_fiber_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem of_clopen_fiber_one {X : Type _} [topological_space X] {U : set X} [∀ x, decidable (x ∈ U)] (hU : is_clopen U) :\n    «expr ⁻¹' » (of_clopen hU) ({1} : set (fin 2)) = «expr ᶜ» U :=\n  by\n  ext\n  simp only [of_clopen, mem_singleton_iff, coe_mk, Fin.zero_eq_one_iff, mem_preimage, ite_eq_right_iff, mem_compl_iff,\n    Nat.succ_succ_ne_one]\n  tauto\n#align of_clopen_fiber_one of_clopen_fiber_one\n\n",
 "mul_indicator_of_not_mem":
 "@[to_additive]\ntheorem mul_indicator_of_not_mem (hU : is_clopen U) (h : a ∉ U) : f.mul_indicator hU a = 1 :=\n  by\n  rw [mul_indicator_apply]\n  apply set.mul_indicator_of_not_mem h\n#align mul_indicator_of_not_mem mul_indicator_of_not_mem\n\n",
 "mul_indicator_of_mem":
 "@[to_additive]\ntheorem mul_indicator_of_mem (hU : is_clopen U) (h : a ∈ U) : f.mul_indicator hU a = f a :=\n  by\n  rw [mul_indicator_apply]\n  apply set.mul_indicator_of_mem h\n#align mul_indicator_of_mem mul_indicator_of_mem\n\n",
 "mul_indicator_apply_eq_if":
 "@[to_additive]\ntheorem mul_indicator_apply_eq_if (hU : is_clopen U) : mul_indicator f hU a = if a ∈ U then f a else 1 :=\n  set.mul_indicator_apply U f a\n#align mul_indicator_apply_eq_if mul_indicator_apply_eq_if\n\n",
 "mul":
 "@[to_additive]\ntheorem mul [Mul Y] ⦃f g : X → Y⦄ (hf : is_locally_constant f) (hg : is_locally_constant g) :\n    is_locally_constant (f * g) :=\n  hf.comp₂ hg (· * ·)\n#align mul mul\n\n",
 "map_id":
 "@[simp]\ntheorem map_id : @map X Y Y _ id = id := by\n  ext\n  rfl\n#align map_id map_id\n\n",
 "map_comp":
 "@[simp]\ntheorem map_comp {Y₁ Y₂ Y₃ : Type _} (g : Y₂ → Y₃) (f : Y₁ → Y₂) : @map X _ _ _ g ∘ map f = map (g ∘ f) :=\n  by\n  ext\n  rfl\n#align map_comp map_comp\n\n",
 "map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem map_apply (f : Y → Z) (g : locally_constant X Y) : «expr⇑ » (map f g) = f ∘ g :=\n  rfl\n#align map_apply map_apply\n\n",
 "locally_constant_eq_of_fiber_zero_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem locally_constant_eq_of_fiber_zero_eq {X : Type _} [topological_space X] (f g : locally_constant X (fin 2))\n    (h : «expr ⁻¹' » f ({0} : set (fin 2)) = «expr ⁻¹' » g {0}) : f = g :=\n  by\n  simp only [Set.ext_iff, mem_singleton_iff, mem_preimage] at h\n  ext1 x\n  exact Fin.fin_two_eq_of_eq_zero_iff (h x)\n#align locally_constant_eq_of_fiber_zero_eq locally_constant_eq_of_fiber_zero_eq\n\n",
 "is_open_fiber":
 "theorem is_open_fiber {f : X → Y} (hf : is_locally_constant f) (y : Y) : is_open { x | f x = y } :=\n  hf {y}\n#align is_open_fiber is_open_fiber\n\n",
 "is_closed_fiber":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_closed_fiber {f : X → Y} (hf : is_locally_constant f) (y : Y) : is_closed { x | f x = y } :=\n  ⟨hf («expr ᶜ» {y})⟩\n#align is_closed_fiber is_closed_fiber\n\n",
 "is_clopen_fiber":
 "theorem is_clopen_fiber {f : X → Y} (hf : is_locally_constant f) (y : Y) : is_clopen { x | f x = y } :=\n  ⟨is_open_fiber hf _, is_closed_fiber hf _⟩\n#align is_clopen_fiber is_clopen_fiber\n\n",
 "inv":
 "@[to_additive]\ntheorem inv [Inv Y] ⦃f : X → Y⦄ (hf : is_locally_constant f) : is_locally_constant f⁻¹ :=\n  hf.comp fun x => x⁻¹\n#align inv inv\n\n",
 "iff_is_const":
 "theorem iff_is_const [preconnected_space X] {f : X → Y} : is_locally_constant f ↔ ∀ x y, f x = f y :=\n  ⟨fun h x y => h.apply_eq_of_is_preconnected is_preconnected_univ trivial trivial, of_constant _⟩\n#align iff_is_const iff_is_const\n\n",
 "iff_exists_open":
 "theorem iff_exists_open (f : X → Y) :\n    is_locally_constant f ↔ ∀ x, ∃ (U : set X)(hU : is_open U)(hx : x ∈ U), ∀ x' ∈ U, f x' = f x :=\n  (is_locally_constant.tfae f).out 0 4\n#align iff_exists_open iff_exists_open\n\n",
 "iff_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem iff_eventually_eq (f : X → Y) :\n    is_locally_constant f ↔\n      ∀ x,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          ((nhds) x) (f y = f x) :=\n  (is_locally_constant.tfae f).out 0 1\n#align iff_eventually_eq iff_eventually_eq\n\n",
 "iff_continuous_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem iff_continuous_bot (f : X → Y) : is_locally_constant f ↔ @continuous X Y _ («expr⊥») f :=\n  iff_continuous f\n#align iff_continuous_bot iff_continuous_bot\n\n",
 "iff_continuous":
 "theorem iff_continuous {_ : topological_space Y} [discrete_topology Y] (f : X → Y) :\n    is_locally_constant f ↔ continuous f :=\n  ⟨is_locally_constant.continuous, fun h s => h.is_open_preimage s (is_open_discrete _)⟩\n#align iff_continuous iff_continuous\n\n",
 "flip_unflip":
 "@[simp]\ntheorem flip_unflip {X α β : Type _} [fintype α] [topological_space X] (f : α → locally_constant X β) :\n    (unflip f).flip = f := by\n  ext\n  rfl\n#align flip_unflip flip_unflip\n\n",
 "ext_iff":
 "theorem ext_iff {f g : locally_constant X Y} : f = g ↔ ∀ x, f x = g x :=\n  ⟨fun h x => h ▸ rfl, fun h => ext h⟩\n#align ext_iff ext_iff\n\n",
 "ext":
 "@[ext]\ntheorem ext ⦃f g : locally_constant X Y⦄ (h : ∀ x, f x = g x) : f = g :=\n  coe_injective (funext h)\n#align ext ext\n\n",
 "exists_open":
 "theorem exists_open {f : X → Y} (hf : is_locally_constant f) (x : X) :\n    ∃ (U : set X)(hU : is_open U)(hx : x ∈ U), ∀ x' ∈ U, f x' = f x :=\n  (iff_exists_open f).1 hf x\n#align exists_open exists_open\n\n",
 "exists_eq_const":
 "theorem exists_eq_const [preconnected_space X] [nonempty Y] (f : locally_constant X Y) : ∃ y, f = const X y :=\n  by\n  rcases classical.em (nonempty X) with (⟨⟨x⟩⟩ | hX)\n  · exact ⟨f x, f.eq_const x⟩\n  · exact ⟨classical.arbitrary Y, ext fun x => (hX ⟨x⟩).elim⟩\n#align exists_eq_const exists_eq_const\n\n",
 "eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\nprotected theorem eventually_eq {f : X → Y} (hf : is_locally_constant f) (x : X) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n      (f y = f x) :=\n  (iff_eventually_eq f).1 hf x\n#align eventually_eq eventually_eq\n\n",
 "eq_const":
 "theorem eq_const [preconnected_space X] (f : locally_constant X Y) (x : X) : f = const X (f x) :=\n  ext fun y => apply_eq_of_preconnected_space f _ _\n#align eq_const eq_const\n\n",
 "div":
 "@[to_additive]\ntheorem div [Div Y] ⦃f g : X → Y⦄ (hf : is_locally_constant f) (hg : is_locally_constant g) :\n    is_locally_constant (f / g) :=\n  hf.comp₂ hg (· / ·)\n#align div div\n\n",
 "desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If a composition of a function `f` followed by an injection `g` is locally\nconstant, then the locally constant property descends to `f`. -/\ntheorem desc {α β : Type _} (f : X → α) (g : α → β) (h : is_locally_constant (g ∘ f)) (inj : function.injective g) :\n    is_locally_constant f := by\n  rw [(is_locally_constant.tfae f).out 0 3]\n  intro a\n  have : «expr ⁻¹' » f {a} = «expr ⁻¹' » (g ∘ f) {g a} := by\n    ext x\n    simp only [mem_singleton_iff, Function.comp_apply, mem_preimage]\n    exact ⟨fun h => by rw [h], fun h => inj h⟩\n  rw [this]\n  apply h\n#align desc desc\n\n",
 "continuous":
 "protected theorem continuous : continuous f :=\n  f.is_locally_constant.continuous\n#align continuous continuous\n\n",
 "const":
 "theorem const (y : Y) : is_locally_constant (function.const X y) :=\n  of_constant _ fun _ _ => rfl\n#align const const\n\n",
 "congr_fun":
 "#print congr_fun /-\ntheorem congr_fun {f g : locally_constant X Y} (h : f = g) (x : X) : f x = g x :=\n  congr_arg (fun h : locally_constant X Y => h x) h\n#align congr_fun congr_fun\n-/\n\n",
 "congr_arg":
 "#print congr_arg /-\ntheorem congr_arg (f : locally_constant X Y) {x y : X} (h : x = y) : f x = f y :=\n  congr_arg (fun x : X => f x) h\n#align congr_arg congr_arg\n-/\n\n",
 "comp₂":
 "theorem comp₂ {Y₁ Y₂ Z : Type _} {f : X → Y₁} {g : X → Y₂} (hf : is_locally_constant f) (hg : is_locally_constant g)\n    (h : Y₁ → Y₂ → Z) : is_locally_constant fun x => h (f x) (g x) :=\n  (hf.prod_mk hg).comp fun x : Y₁ × Y₂ => h x.1 x.2\n#align comp₂ comp₂\n\n",
 "comp_continuous":
 "theorem comp_continuous [topological_space Y] {g : Y → Z} {f : X → Y} (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g ∘ f) := fun s => by\n  rw [Set.preimage_comp]\n  exact hf.is_open_preimage _ (hg _)\n#align comp_continuous comp_continuous\n\n",
 "comp":
 "theorem comp {f : X → Y} (hf : is_locally_constant f) (g : Y → Z) : is_locally_constant (g ∘ f) := fun s =>\n  by\n  rw [Set.preimage_comp]\n  exact hf _\n#align comp comp\n\n",
 "comap_id":
 "@[simp]\ntheorem comap_id : @comap X X Z _ _ id = id := by\n  ext\n  simp only [continuous_id, id.def, function.comp.right_id, coe_comap]\n#align comap_id comap_id\n\n",
 "comap_const":
 "theorem comap_const (f : X → Y) (y : Y) (h : ∀ x, f x = y) :\n    (comap f : locally_constant Y Z → locally_constant X Z) = fun g => ⟨fun x => g y, is_locally_constant.const _⟩ :=\n  by\n  ext; rw [coe_comap]\n  · simp only [h, coe_mk, Function.comp_apply]\n  · rw [show f = fun x => y by ext <;> apply h]\n    exact continuous_const\n#align comap_const comap_const\n\n",
 "comap_comp":
 "theorem comap_comp [topological_space Z] (f : X → Y) (g : Y → Z) (hf : continuous f) (hg : continuous g) :\n    @comap _ _ α _ _ f ∘ comap g = comap (g ∘ f) := by\n  ext\n  simp only [hf, hg, hg.comp hf, coe_comap]\n#align comap_comp comap_comp\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_mk (f : X → Y) (h) : «expr⇑ » (⟨f, h⟩ : locally_constant X Y) = f :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "coe_injective":
 "theorem coe_injective : @function.injective (locally_constant X Y) (X → Y) coe_fn\n  | ⟨f, hf⟩, ⟨g, hg⟩, h => by\n    have : f = g := h\n    subst f\n#align coe_injective coe_injective\n\n",
 "coe_inj":
 "@[simp, norm_cast]\ntheorem coe_inj {f g : locally_constant X Y} : (f : X → Y) = g ↔ f = g :=\n  coe_injective.eq_iff\n#align coe_inj coe_inj\n\n",
 "coe_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_desc {X α β : Type _} [topological_space X] (f : X → α) (g : α → β) (h : locally_constant X β)\n    (cond : g ∘ f = h) (inj : function.injective g) : «expr⇑ » (desc f h cond inj) = f :=\n  rfl\n#align coe_desc coe_desc\n\n",
 "coe_continuous_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp]\ntheorem coe_continuous_map : ((f : «exprC( , )» X Y) : X → Y) = (f : X → Y) :=\n  rfl\n#align coe_continuous_map coe_continuous_map\n\n",
 "coe_const":
 "@[simp]\ntheorem coe_const (y : Y) : (const X y : X → Y) = function.const X y :=\n  rfl\n#align coe_const coe_const\n\n",
 "coe_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_comap (f : X → Y) (g : locally_constant Y Z) (hf : continuous f) : «expr⇑ » (comap f g) = g ∘ f :=\n  by\n  rw [comap, dif_pos hf]\n  rfl\n#align coe_comap coe_comap\n\n",
 "apply_eq_of_preconnected_space":
 "theorem apply_eq_of_preconnected_space [preconnected_space X] (f : locally_constant X Y) (x y : X) : f x = f y :=\n  f.is_locally_constant.apply_eq_of_is_preconnected is_preconnected_univ trivial trivial\n#align apply_eq_of_preconnected_space apply_eq_of_preconnected_space\n\n",
 "apply_eq_of_is_preconnected":
 "theorem apply_eq_of_is_preconnected (f : locally_constant X Y) {s : set X} (hs : is_preconnected s) {x y : X}\n    (hx : x ∈ s) (hy : y ∈ s) : f x = f y :=\n  f.is_locally_constant.apply_eq_of_is_preconnected hs hx hy\n#align apply_eq_of_is_preconnected apply_eq_of_is_preconnected\n\n"}