{"tsupport_smul_subset_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print tsupport_smul_subset_left /-\ntheorem tsupport_smul_subset_left {M α} [TopologicalSpace X] [Zero M] [Zero α] [SMulWithZero M α] (f : X → M)\n    (g : X → α) : (tsupport fun x => «expr • » (f x) (g x)) ⊆ tsupport f :=\n  closure_mono <| support_smul_subset_left f g\n#align tsupport_smul_subset_left tsupport_smul_subset_left\n-/\n\n",
 "tsupport_mul_subset_right":
 "#print tsupport_mul_subset_right /-\ntheorem tsupport_mul_subset_right {α : Type _} [MulZeroClass α] {f g : X → α} :\n    (tsupport fun x => f x * g x) ⊆ tsupport g :=\n  closure_mono (support_mul_subset_right _ _)\n#align tsupport_mul_subset_right tsupport_mul_subset_right\n-/\n\n",
 "tsupport_mul_subset_left":
 "#print tsupport_mul_subset_left /-\ntheorem tsupport_mul_subset_left {α : Type _} [MulZeroClass α] {f g : X → α} :\n    (tsupport fun x => f x * g x) ⊆ tsupport f :=\n  closure_mono (support_mul_subset_left _ _)\n#align tsupport_mul_subset_left tsupport_mul_subset_left\n-/\n\n",
 "subset_mulTSupport":
 "#print subset_mulTSupport /-\n/-\nCopyright (c) 2022 Floris van Doorn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Floris van Doorn, Patrick Massot\n-/\n@[to_additive]\ntheorem subset_mulTSupport (f : X → α) : mulSupport f ⊆ mulTSupport f :=\n  subset_closure\n#align subset_mul_tsupport subset_mulTSupport\n#align subset_tsupport subset_tsupport\n-/\n\n",
 "smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print HasCompactSupport.smul_right /-\ntheorem HasCompactSupport.smul_right (hf : HasCompactSupport f) : HasCompactSupport («expr • » f f') :=\n  by\n  rw [hasCompactSupport_iff_eventuallyEq] at hf⊢\n  refine' hf.mono fun x hx => by simp_rw [Pi.smul_apply', hx, Pi.zero_apply, zero_smul]\n#align has_compact_support.smul_right HasCompactSupport.smul_right\n-/\n\n",
 "smul_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print HasCompactSupport.smul_left' /-\ntheorem HasCompactSupport.smul_left' (hf : HasCompactSupport f') : HasCompactSupport («expr • » f f') :=\n  by\n  rw [hasCompactSupport_iff_eventuallyEq] at hf⊢\n  refine' hf.mono fun x hx => by simp_rw [Pi.smul_apply', hx, Pi.zero_apply, smul_zero]\n#align has_compact_support.smul_left' HasCompactSupport.smul_left'\n-/\n\n",
 "smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print HasCompactSupport.smul_left /-\n-- `by apply` speeds up elaboration\ntheorem HasCompactSupport.smul_left (hf : HasCompactSupport f') : HasCompactSupport («expr • » f f') :=\n  by\n  rw [hasCompactSupport_iff_eventuallyEq] at hf⊢\n  refine' hf.mono fun x hx => by simp_rw [Pi.smul_apply', hx, Pi.zero_apply, smul_zero]\n#align has_compact_support.smul_left HasCompactSupport.smul_left\n-/\n\n",
 "range_subset_insert_image_mulTSupport":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print range_subset_insert_image_mulTSupport /-\n@[to_additive]\ntheorem range_subset_insert_image_mulTSupport (f : X → α) : range f ⊆ insert 1 («expr '' » f (mulTSupport f)) :=\n  (range_subset_insert_image_mulSupport f).trans <| insert_subset_insert <| image_subset _ subset_closure\n#align range_subset_insert_image_mul_tsupport range_subset_insert_image_mulTSupport\n#align range_subset_insert_image_tsupport range_subset_insert_image_tsupport\n-/\n\n",
 "range_eq_image_mulTSupport_or":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print range_eq_image_mulTSupport_or /-\n@[to_additive]\ntheorem range_eq_image_mulTSupport_or (f : X → α) :\n    range f = «expr '' » f (mulTSupport f) ∨ range f = insert 1 («expr '' » f (mulTSupport f)) :=\n  (wcovby_insert _ _).eq_or_eq (image_subset_range _ _) (range_subset_insert_image_mulTSupport f)\n#align range_eq_image_mul_tsupport_or range_eq_image_mulTSupport_or\n#align range_eq_image_tsupport_or range_eq_image_tsupport_or\n-/\n\n",
 "not_mem_mulTSupport_iff_eventuallyEq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print not_mem_mulTSupport_iff_eventuallyEq /-\n@[to_additive]\ntheorem not_mem_mulTSupport_iff_eventuallyEq : x ∉ mulTSupport f ↔ «expr =ᶠ[ ] » f ((nhds) x) 1 := by\n  simp_rw [mulTSupport, mem_closure_iff_nhds, not_forall, not_nonempty_iff_eq_empty, ← disjoint_iff_inter_eq_empty,\n    disjoint_mul_support_iff, eventually_eq_iff_exists_mem]\n#align not_mem_mul_tsupport_iff_eventually_eq not_mem_mulTSupport_iff_eventuallyEq\n#align not_mem_tsupport_iff_eventually_eq not_mem_tsupport_iff_eventuallyEq\n-/\n\n",
 "mul_right":
 "#print HasCompactSupport.mul_right /-\ntheorem HasCompactSupport.mul_right (hf : HasCompactSupport f) : HasCompactSupport (f * f') :=\n  by\n  rw [hasCompactSupport_iff_eventuallyEq] at hf⊢\n  refine' hf.mono fun x hx => by simp_rw [Pi.mul_apply, hx, Pi.zero_apply, MulZeroClass.zero_mul]\n#align has_compact_support.mul_right HasCompactSupport.mul_right\n-/\n\n",
 "mul_left":
 "#print HasCompactSupport.mul_left /-\ntheorem HasCompactSupport.mul_left (hf : HasCompactSupport f') : HasCompactSupport (f * f') :=\n  by\n  rw [hasCompactSupport_iff_eventuallyEq] at hf⊢\n  refine' hf.mono fun x hx => by simp_rw [Pi.mul_apply, hx, Pi.zero_apply, MulZeroClass.mul_zero]\n#align has_compact_support.mul_left HasCompactSupport.mul_left\n-/\n\n",
 "mulTSupport_eq_empty_iff":
 "#print mulTSupport_eq_empty_iff /-\n@[to_additive]\ntheorem mulTSupport_eq_empty_iff {f : X → α} : mulTSupport f = ∅ ↔ f = 1 := by\n  rw [mulTSupport, closure_empty_iff, mul_support_eq_empty_iff]\n#align mul_tsupport_eq_empty_iff mulTSupport_eq_empty_iff\n#align tsupport_eq_empty_iff tsupport_eq_empty_iff\n-/\n\n",
 "mul":
 "#print HasCompactMulSupport.mul /-\n@[to_additive]\ntheorem HasCompactMulSupport.mul (hf : HasCompactMulSupport f) (hf' : HasCompactMulSupport f') :\n    HasCompactMulSupport (f * f') := by apply hf.comp₂_left hf' (mul_one 1)\n#align has_compact_mul_support.mul HasCompactMulSupport.mul\n#align has_compact_support.add HasCompactSupport.add\n-/\n\n",
 "mono'":
 "#print HasCompactMulSupport.mono' /-\n@[to_additive]\ntheorem HasCompactMulSupport.mono' {f' : α → γ} (hf : HasCompactMulSupport f) (hff' : mulSupport f' ⊆ mulTSupport f) :\n    HasCompactMulSupport f' :=\n  isCompact_of_isClosed_subset hf isClosed_closure <| closure_minimal hff' isClosed_closure\n#align has_compact_mul_support.mono' HasCompactMulSupport.mono'\n#align has_compact_support.mono' HasCompactSupport.mono'\n-/\n\n",
 "mono":
 "#print HasCompactMulSupport.mono /-\n@[to_additive]\ntheorem HasCompactMulSupport.mono {f' : α → γ} (hf : HasCompactMulSupport f) (hff' : mulSupport f' ⊆ mulSupport f) :\n    HasCompactMulSupport f' :=\n  hf.mono' <| hff'.trans subset_closure\n#align has_compact_mul_support.mono HasCompactMulSupport.mono\n#align has_compact_support.mono HasCompactSupport.mono\n-/\n\n",
 "isCompact_range":
 "#print HasCompactMulSupport.isCompact_range /-\n@[to_additive]\ntheorem HasCompactMulSupport.isCompact_range [TopologicalSpace β] (h : HasCompactMulSupport f) (hf : Continuous f) :\n    IsCompact (range f) := by\n  cases' range_eq_image_mulTSupport_or f with h2 h2 <;> rw [h2]\n  exacts[h.image hf, (h.image hf).insert 1]\n#align has_compact_mul_support.is_compact_range HasCompactMulSupport.isCompact_range\n#align has_compact_support.is_compact_range HasCompactSupport.isCompact_range\n-/\n\n",
 "isCompact":
 "#print HasCompactMulSupport.isCompact /-\n@[to_additive]\ntheorem HasCompactMulSupport.isCompact (hf : HasCompactMulSupport f) : IsCompact (mulTSupport f) :=\n  hf\n#align has_compact_mul_support.is_compact HasCompactMulSupport.isCompact\n#align has_compact_support.is_compact HasCompactSupport.isCompact\n-/\n\n",
 "isClosed_mulTSupport":
 "#print isClosed_mulTSupport /-\n@[to_additive]\ntheorem isClosed_mulTSupport (f : X → α) : IsClosed (mulTSupport f) :=\n  isClosed_closure\n#align is_closed_mul_tsupport isClosed_mulTSupport\n#align is_closed_tsupport isClosed_tsupport\n-/\n\n",
 "intro":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » K) -/\n#print HasCompactMulSupport.intro /-\n@[to_additive]\ntheorem HasCompactMulSupport.intro [T2Space α] {K : Set α} (hK : IsCompact K) (hfK : ∀ (x) (_ : x ∉ K), f x = 1) :\n    HasCompactMulSupport f :=\n  exists_compact_iff_hasCompactMulSupport.mp ⟨K, hK, hfK⟩\n#align has_compact_mul_support.intro HasCompactMulSupport.intro\n#align has_compact_support.intro HasCompactSupport.intro\n-/\n\n",
 "image_eq_one_of_nmem_mulTSupport":
 "#print image_eq_one_of_nmem_mulTSupport /-\n@[to_additive]\ntheorem image_eq_one_of_nmem_mulTSupport {f : X → α} {x : X} (hx : x ∉ mulTSupport f) : f x = 1 :=\n  mulSupport_subset_iff'.mp (subset_mulTSupport f) x hx\n#align image_eq_one_of_nmem_mul_tsupport image_eq_one_of_nmem_mulTSupport\n#align image_eq_zero_of_nmem_tsupport image_eq_zero_of_nmem_tsupport\n-/\n\n",
 "hasCompactMulSupport_iff_eventuallyEq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n#print hasCompactMulSupport_iff_eventuallyEq /-\n@[to_additive]\ntheorem hasCompactMulSupport_iff_eventuallyEq : HasCompactMulSupport f ↔ «expr =ᶠ[ ] » f (coclosedCompact α) 1 :=\n  ⟨fun h =>\n    mem_coclosedCompact.mpr\n      ⟨mulTSupport f, isClosed_mulTSupport _, h, fun x => not_imp_comm.mpr fun hx => subset_mulTSupport f hx⟩,\n    fun h =>\n    let ⟨C, hC⟩ := mem_coclosed_compact'.mp h\n    isCompact_of_isClosed_subset hC.2.1 (isClosed_mulTSupport _) (closure_minimal hC.2.2 hC.1)⟩\n#align has_compact_mul_support_iff_eventually_eq hasCompactMulSupport_iff_eventuallyEq\n#align has_compact_support_iff_eventually_eq hasCompactSupport_iff_eventuallyEq\n-/\n\n",
 "hasCompactMulSupport_def":
 "#print hasCompactMulSupport_def /-\n@[to_additive]\ntheorem hasCompactMulSupport_def : HasCompactMulSupport f ↔ IsCompact (closure (mulSupport f)) := by rfl\n#align has_compact_mul_support_def hasCompactMulSupport_def\n#align has_compact_support_def hasCompactSupport_def\n-/\n\n",
 "hasCompactMulSupport_comp_left":
 "#print hasCompactMulSupport_comp_left /-\n@[to_additive]\ntheorem hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :\n    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by\n  simp_rw [hasCompactMulSupport_def, mul_support_comp_eq g (@hg) f]\n#align has_compact_mul_support_comp_left hasCompactMulSupport_comp_left\n#align has_compact_support_comp_left hasCompactSupport_comp_left\n-/\n\n",
 "exists_finset_nhd_mul_support_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- If a family of functions `f` has locally-finite multiplicative support, subordinate to a family\nof open sets, then for any point we can find a neighbourhood on which only finitely-many members of\n`f` are not equal to 1. -/\n@[to_additive\n      \" If a family of functions `f` has locally-finite support, subordinate to a family of open sets,\\nthen for any point we can find a neighbourhood on which only finitely-many members of `f` are\\nnon-zero. \"]\ntheorem exists_finset_nhd_mul_support_subset {f : ι → X → R} (hlf : LocallyFinite fun i => mulSupport (f i))\n    (hso : ∀ i, mulTSupport (f i) ⊆ U i) (ho : ∀ i, IsOpen (U i)) (x : X) :\n    ∃ (is : Finset ι)(n : Set X)(hn₁ : n ∈ (nhds) x)(hn₂ :\n      n ⊆ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (U i)),\n      ∀ z ∈ n, (mulSupport fun i => f i z) ⊆ is :=\n  by\n  obtain ⟨n, hn, hnf⟩ := hlf x\n  classical\n    let is := hnf.to_finset.filter fun i => x ∈ U i\n    let js := hnf.to_finset.filter fun j => x ∉ U j\n    refine'\n      ⟨is,\n        n ∩\n            «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n              («expr ᶜ» (mulTSupport (f j))) ∩\n          «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (U i),\n        inter_mem (inter_mem hn _) _, inter_subset_right _ _, fun z hz => _⟩\n    ·\n      exact\n        (bInter_finset_mem js).mpr fun j hj =>\n          IsClosed.compl_mem_nhds (isClosed_mulTSupport _) (Set.not_mem_subset (hso j) (finset.mem_filter.mp hj).2)\n    · exact (bInter_finset_mem is).mpr fun i hi => (ho i).mem_nhds (finset.mem_filter.mp hi).2\n    · have hzn : z ∈ n := by\n        rw [inter_assoc] at hz\n        exact mem_of_mem_inter_left hz\n      replace hz := mem_of_mem_inter_right (mem_of_mem_inter_left hz)\n      simp only [Finset.mem_filter, finite.mem_to_finset, mem_set_of_eq, mem_Inter, and_imp] at hz\n      suffices (mul_support fun i => f i z) ⊆ hnf.to_finset\n        by\n        refine' hnf.to_finset.subset_coe_filter_of_subset_forall _ this fun i hi => _\n        specialize hz i ⟨z, ⟨hi, hzn⟩⟩\n        contrapose hz\n        simp [hz, subset_mulTSupport (f i) hi]\n      intro i hi\n      simp only [finite.coe_to_finset, mem_set_of_eq]\n      exact ⟨z, ⟨hi, hzn⟩⟩\n#align exists_finset_nhd_mul_support_subset exists_finset_nhd_mul_support_subset\n\n",
 "exists_compact_iff_hasCompactMulSupport":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » K) -/\n#print exists_compact_iff_hasCompactMulSupport /-\n@[to_additive]\ntheorem exists_compact_iff_hasCompactMulSupport [T2Space α] :\n    (∃ K : Set α, IsCompact K ∧ ∀ (x) (_ : x ∉ K), f x = 1) ↔ HasCompactMulSupport f := by\n  simp_rw [← nmem_mul_support, ← mem_compl_iff, ← subset_def, compl_subset_compl, hasCompactMulSupport_def,\n    exists_compact_superset_iff]\n#align exists_compact_iff_has_compact_mul_support exists_compact_iff_hasCompactMulSupport\n#align exists_compact_iff_has_compact_support exists_compact_iff_hasCompactSupport\n-/\n\n",
 "continuous_of_mulTSupport":
 "#print continuous_of_mulTSupport /-\n@[to_additive]\ntheorem continuous_of_mulTSupport [TopologicalSpace β] {f : α → β} (hf : ∀ x ∈ mulTSupport f, ContinuousAt f x) :\n    Continuous f :=\n  continuous_iff_continuousAt.2 fun x =>\n    (em _).elim (hf x) fun hx =>\n      (@continuousAt_const _ _ _ _ _ 1).congr (not_mem_mulTSupport_iff_eventuallyEq.mp hx).symm\n#align continuous_of_mul_tsupport continuous_of_mulTSupport\n#align continuous_of_tsupport continuous_of_tsupport\n-/\n\n",
 "comp₂_left":
 "#print HasCompactMulSupport.comp₂_left /-\n@[to_additive]\ntheorem HasCompactMulSupport.comp₂_left (hf : HasCompactMulSupport f) (hf₂ : HasCompactMulSupport f₂) (hm : m 1 1 = 1) :\n    HasCompactMulSupport fun x => m (f x) (f₂ x) :=\n  by\n  rw [hasCompactMulSupport_iff_eventuallyEq] at hf hf₂⊢\n  filter_upwards [hf, hf₂]using fun x hx hx₂ => by simp_rw [hx, hx₂, Pi.one_apply, hm]\n#align has_compact_mul_support.comp₂_left HasCompactMulSupport.comp₂_left\n#align has_compact_support.comp₂_left HasCompactSupport.comp₂_left\n-/\n\n",
 "comp_left":
 "#print HasCompactMulSupport.comp_left /-\n@[to_additive]\ntheorem HasCompactMulSupport.comp_left (hf : HasCompactMulSupport f) (hg : g 1 = 1) : HasCompactMulSupport (g ∘ f) :=\n  hf.mono <| mulSupport_comp_subset hg f\n#align has_compact_mul_support.comp_left HasCompactMulSupport.comp_left\n#align has_compact_support.comp_left HasCompactSupport.comp_left\n-/\n\n",
 "comp_closedEmbedding":
 "#print HasCompactMulSupport.comp_closedEmbedding /-\n@[to_additive]\ntheorem HasCompactMulSupport.comp_closedEmbedding (hf : HasCompactMulSupport f) {g : α' → α} (hg : ClosedEmbedding g) :\n    HasCompactMulSupport (f ∘ g) :=\n  by\n  rw [hasCompactMulSupport_def, Function.mulSupport_comp_eq_preimage]\n  refine' isCompact_of_isClosed_subset (hg.is_compact_preimage hf) isClosed_closure _\n  rw [hg.to_embedding.closure_eq_preimage_closure_image]\n  exact preimage_mono (closure_mono <| image_preimage_subset _ _)\n#align has_compact_mul_support.comp_closed_embedding HasCompactMulSupport.comp_closedEmbedding\n#align has_compact_support.comp_closed_embedding HasCompactSupport.comp_closedEmbedding\n-/\n\n"}