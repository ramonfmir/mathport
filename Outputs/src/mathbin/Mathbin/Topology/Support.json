{"tsupport_smul_subset_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem tsupport_smul_subset_left {M α} [topological_space X] [Zero M] [Zero α] [SMulWithZero M α] (f : X → M)\n    (g : X → α) : (tsupport fun x => «expr • » (f x) (g x)) ⊆ tsupport f :=\n  closure_mono <| support_smul_subset_left f g\n#align tsupport_smul_subset_left tsupport_smul_subset_left\n\n",
 "tsupport_mul_subset_right":
 "theorem tsupport_mul_subset_right {α : Type _} [mul_zero_class α] {f g : X → α} :\n    (tsupport fun x => f x * g x) ⊆ tsupport g :=\n  closure_mono (support_mul_subset_right _ _)\n#align tsupport_mul_subset_right tsupport_mul_subset_right\n\n",
 "tsupport_mul_subset_left":
 "theorem tsupport_mul_subset_left {α : Type _} [mul_zero_class α] {f g : X → α} :\n    (tsupport fun x => f x * g x) ⊆ tsupport f :=\n  closure_mono (support_mul_subset_left _ _)\n#align tsupport_mul_subset_left tsupport_mul_subset_left\n\n",
 "subset_mul_tsupport":
 "/-\nCopyright (c) 2022 Floris van Doorn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Floris van Doorn, Patrick Massot\n-/\n@[to_additive]\ntheorem subset_mul_tsupport (f : X → α) : mul_support f ⊆ mul_tsupport f :=\n  subset_closure\n#align subset_mul_tsupport subset_mul_tsupport\n\n",
 "smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem has_compact_support.smul_right (hf : has_compact_support f) : has_compact_support («expr • » f f') :=\n  by\n  rw [has_compact_support_iff_eventually_eq] at hf⊢\n  refine' hf.mono fun x hx => by simp_rw [Pi.smul_apply', hx, pi.zero_apply, zero_smul]\n#align has_compact_support.smul_right has_compact_support.smul_right\n\n",
 "smul_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem has_compact_support.smul_left' (hf : has_compact_support f') : has_compact_support («expr • » f f') :=\n  by\n  rw [has_compact_support_iff_eventually_eq] at hf⊢\n  refine' hf.mono fun x hx => by simp_rw [Pi.smul_apply', hx, pi.zero_apply, smul_zero]\n#align has_compact_support.smul_left' has_compact_support.smul_left'\n\n",
 "smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- `by apply` speeds up elaboration\ntheorem has_compact_support.smul_left (hf : has_compact_support f') : has_compact_support («expr • » f f') :=\n  by\n  rw [has_compact_support_iff_eventually_eq] at hf⊢\n  refine' hf.mono fun x hx => by simp_rw [Pi.smul_apply', hx, pi.zero_apply, smul_zero]\n#align has_compact_support.smul_left has_compact_support.smul_left\n\n",
 "range_subset_insert_image_mul_tsupport":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem range_subset_insert_image_mul_tsupport (f : X → α) : range f ⊆ insert 1 («expr '' » f (mul_tsupport f)) :=\n  (range_subset_insert_image_mul_support f).trans <| insert_subset_insert <| image_subset _ subset_closure\n#align range_subset_insert_image_mul_tsupport range_subset_insert_image_mul_tsupport\n\n",
 "range_eq_image_mul_tsupport_or":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem range_eq_image_mul_tsupport_or (f : X → α) :\n    range f = «expr '' » f (mul_tsupport f) ∨ range f = insert 1 («expr '' » f (mul_tsupport f)) :=\n  (wcovby_insert _ _).eq_or_eq (image_subset_range _ _) (range_subset_insert_image_mul_tsupport f)\n#align range_eq_image_mul_tsupport_or range_eq_image_mul_tsupport_or\n\n",
 "not_mem_mul_tsupport_iff_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem not_mem_mul_tsupport_iff_eventually_eq : x ∉ mul_tsupport f ↔ «expr =ᶠ[ ] » f ((nhds) x) 1 := by\n  simp_rw [mul_tsupport, mem_closure_iff_nhds, not_forall, not_nonempty_iff_eq_empty, ← disjoint_iff_inter_eq_empty,\n    disjoint_mul_support_iff, eventually_eq_iff_exists_mem]\n#align not_mem_mul_tsupport_iff_eventually_eq not_mem_mul_tsupport_iff_eventually_eq\n\n",
 "mul_tsupport_eq_empty_iff":
 "@[to_additive]\ntheorem mul_tsupport_eq_empty_iff {f : X → α} : mul_tsupport f = ∅ ↔ f = 1 := by\n  rw [mul_tsupport, closure_empty_iff, mul_support_eq_empty_iff]\n#align mul_tsupport_eq_empty_iff mul_tsupport_eq_empty_iff\n\n",
 "mul_right":
 "theorem has_compact_support.mul_right (hf : has_compact_support f) : has_compact_support (f * f') :=\n  by\n  rw [has_compact_support_iff_eventually_eq] at hf⊢\n  refine' hf.mono fun x hx => by simp_rw [pi.mul_apply, hx, pi.zero_apply, zero_mul]\n#align has_compact_support.mul_right has_compact_support.mul_right\n\n",
 "mul_left":
 "theorem has_compact_support.mul_left (hf : has_compact_support f') : has_compact_support (f * f') :=\n  by\n  rw [has_compact_support_iff_eventually_eq] at hf⊢\n  refine' hf.mono fun x hx => by simp_rw [pi.mul_apply, hx, pi.zero_apply, mul_zero]\n#align has_compact_support.mul_left has_compact_support.mul_left\n\n",
 "mul":
 "@[to_additive]\ntheorem has_compact_mul_support.mul (hf : has_compact_mul_support f) (hf' : has_compact_mul_support f') :\n    has_compact_mul_support (f * f') := by apply hf.comp₂_left hf' (mul_one 1)\n#align has_compact_mul_support.mul has_compact_mul_support.mul\n\n",
 "mono'":
 "@[to_additive]\ntheorem has_compact_mul_support.mono' {f' : α → γ} (hf : has_compact_mul_support f)\n    (hff' : mul_support f' ⊆ mul_tsupport f) : has_compact_mul_support f' :=\n  is_compact_of_is_closed_subset hf is_closed_closure <| closure_minimal hff' is_closed_closure\n#align has_compact_mul_support.mono' has_compact_mul_support.mono'\n\n",
 "mono":
 "@[to_additive]\ntheorem has_compact_mul_support.mono {f' : α → γ} (hf : has_compact_mul_support f)\n    (hff' : mul_support f' ⊆ mul_support f) : has_compact_mul_support f' :=\n  hf.mono' <| hff'.trans subset_closure\n#align has_compact_mul_support.mono has_compact_mul_support.mono\n\n",
 "is_compact_range":
 "@[to_additive]\ntheorem has_compact_mul_support.is_compact_range [topological_space β] (h : has_compact_mul_support f)\n    (hf : continuous f) : is_compact (range f) :=\n  by\n  cases' range_eq_image_mul_tsupport_or f with h2 h2 <;> rw [h2]\n  exacts[h.image hf, (h.image hf).insert 1]\n#align has_compact_mul_support.is_compact_range has_compact_mul_support.is_compact_range\n\n",
 "is_compact":
 "@[to_additive]\ntheorem has_compact_mul_support.is_compact (hf : has_compact_mul_support f) : is_compact (mul_tsupport f) :=\n  hf\n#align has_compact_mul_support.is_compact has_compact_mul_support.is_compact\n\n",
 "is_closed_mul_tsupport":
 "@[to_additive]\ntheorem is_closed_mul_tsupport (f : X → α) : is_closed (mul_tsupport f) :=\n  is_closed_closure\n#align is_closed_mul_tsupport is_closed_mul_tsupport\n\n",
 "intro":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x «expr ∉ » K) -/\n@[to_additive]\ntheorem has_compact_mul_support.intro [t2_space α] {K : set α} (hK : is_compact K) (hfK : ∀ (x) (_ : x ∉ K), f x = 1) :\n    has_compact_mul_support f :=\n  exists_compact_iff_has_compact_mul_support.mp ⟨K, hK, hfK⟩\n#align has_compact_mul_support.intro has_compact_mul_support.intro\n\n",
 "image_eq_one_of_nmem_mul_tsupport":
 "@[to_additive]\ntheorem image_eq_one_of_nmem_mul_tsupport {f : X → α} {x : X} (hx : x ∉ mul_tsupport f) : f x = 1 :=\n  mul_support_subset_iff'.mp (subset_mul_tsupport f) x hx\n#align image_eq_one_of_nmem_mul_tsupport image_eq_one_of_nmem_mul_tsupport\n\n",
 "has_compact_mul_support_iff_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n@[to_additive]\ntheorem has_compact_mul_support_iff_eventually_eq :\n    has_compact_mul_support f ↔ «expr =ᶠ[ ] » f (coclosed_compact α) 1 :=\n  ⟨fun h =>\n    mem_coclosed_compact.mpr\n      ⟨mul_tsupport f, is_closed_mul_tsupport _, h, fun x => not_imp_comm.mpr fun hx => subset_mul_tsupport f hx⟩,\n    fun h =>\n    let ⟨C, hC⟩ := mem_coclosed_compact'.mp h\n    is_compact_of_is_closed_subset hC.2.1 (is_closed_mul_tsupport _) (closure_minimal hC.2.2 hC.1)⟩\n#align has_compact_mul_support_iff_eventually_eq has_compact_mul_support_iff_eventually_eq\n\n",
 "has_compact_mul_support_def":
 "@[to_additive]\ntheorem has_compact_mul_support_def : has_compact_mul_support f ↔ is_compact (closure (mul_support f)) := by rfl\n#align has_compact_mul_support_def has_compact_mul_support_def\n\n",
 "has_compact_mul_support_comp_left":
 "@[to_additive]\ntheorem has_compact_mul_support_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :\n    has_compact_mul_support (g ∘ f) ↔ has_compact_mul_support f := by\n  simp_rw [has_compact_mul_support_def, mul_support_comp_eq g (@hg) f]\n#align has_compact_mul_support_comp_left has_compact_mul_support_comp_left\n\n",
 "exists_finset_nhd_mul_support_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- If a family of functions `f` has locally-finite multiplicative support, subordinate to a family\nof open sets, then for any point we can find a neighbourhood on which only finitely-many members of\n`f` are not equal to 1. -/\n@[to_additive\n      \" If a family of functions `f` has locally-finite support, subordinate to a family of open sets,\\nthen for any point we can find a neighbourhood on which only finitely-many members of `f` are\\nnon-zero. \"]\ntheorem exists_finset_nhd_mul_support_subset {f : ι → X → R} (hlf : locally_finite fun i => mul_support (f i))\n    (hso : ∀ i, mul_tsupport (f i) ⊆ U i) (ho : ∀ i, is_open (U i)) (x : X) :\n    ∃ (is : Finset ι)(n : set X)(hn₁ : n ∈ (nhds) x)(hn₂ :\n      n ⊆ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (U i)),\n      ∀ z ∈ n, (mul_support fun i => f i z) ⊆ is :=\n  by\n  obtain ⟨n, hn, hnf⟩ := hlf x\n  classical\n    let is := hnf.to_finset.filter fun i => x ∈ U i\n    let js := hnf.to_finset.filter fun j => x ∉ U j\n    refine'\n      ⟨is,\n        n ∩\n            «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n              («expr ᶜ» (mul_tsupport (f j))) ∩\n          «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (U i),\n        inter_mem (inter_mem hn _) _, inter_subset_right _ _, fun z hz => _⟩\n    ·\n      exact\n        (bInter_finset_mem js).mpr fun j hj =>\n          is_closed.compl_mem_nhds (is_closed_mul_tsupport _) (Set.not_mem_subset (hso j) (finset.mem_filter.mp hj).2)\n    · exact (bInter_finset_mem is).mpr fun i hi => (ho i).mem_nhds (finset.mem_filter.mp hi).2\n    · have hzn : z ∈ n := by\n        rw [inter_assoc] at hz\n        exact mem_of_mem_inter_left hz\n      replace hz := mem_of_mem_inter_right (mem_of_mem_inter_left hz)\n      simp only [Finset.mem_filter, finite.mem_to_finset, mem_set_of_eq, mem_Inter, and_imp] at hz\n      suffices (mul_support fun i => f i z) ⊆ hnf.to_finset\n        by\n        refine' hnf.to_finset.subset_coe_filter_of_subset_forall _ this fun i hi => _\n        specialize hz i ⟨z, ⟨hi, hzn⟩⟩\n        contrapose hz\n        simp [hz, subset_mul_tsupport (f i) hi]\n      intro i hi\n      simp only [finite.coe_to_finset, mem_set_of_eq]\n      exact ⟨z, ⟨hi, hzn⟩⟩\n#align exists_finset_nhd_mul_support_subset exists_finset_nhd_mul_support_subset\n\n",
 "exists_compact_iff_has_compact_mul_support":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x «expr ∉ » K) -/\n@[to_additive]\ntheorem exists_compact_iff_has_compact_mul_support [t2_space α] :\n    (∃ K : set α, is_compact K ∧ ∀ (x) (_ : x ∉ K), f x = 1) ↔ has_compact_mul_support f := by\n  simp_rw [← nmem_mul_support, ← mem_compl_iff, ← subset_def, compl_subset_compl, has_compact_mul_support_def,\n    exists_compact_superset_iff]\n#align exists_compact_iff_has_compact_mul_support exists_compact_iff_has_compact_mul_support\n\n",
 "continuous_of_mul_tsupport":
 "@[to_additive]\ntheorem continuous_of_mul_tsupport [topological_space β] {f : α → β} (hf : ∀ x ∈ mul_tsupport f, continuous_at f x) :\n    continuous f :=\n  continuous_iff_continuous_at.2 fun x =>\n    (em _).elim (hf x) fun hx =>\n      (@continuous_at_const _ _ _ _ _ 1).congr (not_mem_mul_tsupport_iff_eventually_eq.mp hx).symm\n#align continuous_of_mul_tsupport continuous_of_mul_tsupport\n\n",
 "comp₂_left":
 "@[to_additive]\ntheorem has_compact_mul_support.comp₂_left (hf : has_compact_mul_support f) (hf₂ : has_compact_mul_support f₂)\n    (hm : m 1 1 = 1) : has_compact_mul_support fun x => m (f x) (f₂ x) :=\n  by\n  rw [has_compact_mul_support_iff_eventually_eq] at hf hf₂⊢\n  filter_upwards [hf, hf₂] using fun x hx hx₂ => by simp_rw [hx, hx₂, pi.one_apply, hm]\n#align has_compact_mul_support.comp₂_left has_compact_mul_support.comp₂_left\n\n",
 "comp_left":
 "@[to_additive]\ntheorem has_compact_mul_support.comp_left (hf : has_compact_mul_support f) (hg : g 1 = 1) :\n    has_compact_mul_support (g ∘ f) :=\n  hf.mono <| mul_support_comp_subset hg f\n#align has_compact_mul_support.comp_left has_compact_mul_support.comp_left\n\n",
 "comp_closed_embedding":
 "@[to_additive]\ntheorem has_compact_mul_support.comp_closed_embedding (hf : has_compact_mul_support f) {g : α' → α}\n    (hg : closed_embedding g) : has_compact_mul_support (f ∘ g) :=\n  by\n  rw [has_compact_mul_support_def, function.mul_support_comp_eq_preimage]\n  refine' is_compact_of_is_closed_subset (hg.is_compact_preimage hf) is_closed_closure _\n  rw [hg.to_embedding.closure_eq_preimage_closure_image]\n  exact preimage_mono (closure_mono <| image_preimage_subset _ _)\n#align has_compact_mul_support.comp_closed_embedding has_compact_mul_support.comp_closed_embedding\n\n"}