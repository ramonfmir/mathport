{"zero_apply":
 "@[simp]\ntheorem zero_apply (m : ∀ i, M₁ i) : (0 : ContinuousMultilinearMap R M₁ M₂) m = 0 :=\n  rfl\n#align zero_apply zero_apply\n\n",
 "to_multilinear_map_zero":
 "@[simp]\ntheorem to_multilinear_map_zero : (0 : ContinuousMultilinearMap R M₁ M₂).to_multilinear_map = 0 :=\n  rfl\n#align to_multilinear_map_zero to_multilinear_map_zero\n\n",
 "to_multilinear_map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_multilinear_map_smul (c : R') (f : ContinuousMultilinearMap A M₁ M₂) :\n    («expr • » c f).to_multilinear_map = «expr • » c f.to_multilinear_map :=\n  rfl\n#align to_multilinear_map_smul to_multilinear_map_smul\n\n",
 "to_multilinear_map_injective":
 "/-\nCopyright (c) 2020 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\ntheorem to_multilinear_map_injective :\n    function.injective\n      (continuous_multilinear_map.to_multilinear_map : ContinuousMultilinearMap R M₁ M₂ → MultilinearMap R M₁ M₂)\n  | ⟨f, hf⟩, ⟨g, hg⟩, rfl => rfl\n#align to_multilinear_map_injective to_multilinear_map_injective\n\n",
 "to_multilinear_map_add":
 "@[simp]\ntheorem to_multilinear_map_add (f g : ContinuousMultilinearMap R M₁ M₂) :\n    (f + g).to_multilinear_map = f.to_multilinear_map + g.to_multilinear_map :=\n  rfl\n#align to_multilinear_map_add to_multilinear_map_add\n\n",
 "sum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem sum_apply {α : Type _} (f : α → ContinuousMultilinearMap R M₁ M₂) (m : ∀ i, M₁ i) {s : Finset α} :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f a)) m =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f a m) :=\n  (applyAddHom m).map_sum f s\n#align sum_apply sum_apply\n\n",
 "sub_apply":
 "@[simp]\ntheorem sub_apply (m : ∀ i, M₁ i) : (f - f') m = f m - f' m :=\n  rfl\n#align sub_apply sub_apply\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_apply (f : ContinuousMultilinearMap A M₁ M₂) (c : R') (m : ∀ i, M₁ i) :\n    («expr • » c f) m = «expr • » c (f m) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "prod_apply":
 "@[simp]\ntheorem prod_apply (f : ContinuousMultilinearMap R M₁ M₂) (g : ContinuousMultilinearMap R M₁ M₃) (m : ∀ i, M₁ i) :\n    (f.prod g) m = (f m, g m) :=\n  rfl\n#align prod_apply prod_apply\n\n",
 "pi_apply":
 "theorem pi_apply {ι' : Type _} {M' : ι' → Type _} [∀ i, AddCommMonoid (M' i)] [∀ i, TopologicalSpace (M' i)]\n    [∀ i, Module R (M' i)] (f : ∀ i, ContinuousMultilinearMap R M₁ (M' i)) (m : ∀ i, M₁ i) (j : ι') :\n    pi f m j = f j m :=\n  rfl\n#align pi_apply pi_apply\n\n",
 "neg_apply":
 "@[simp]\ntheorem neg_apply (m : ∀ i, M₁ i) : (-f) m = -f m :=\n  rfl\n#align neg_apply neg_apply\n\n",
 "mk_pi_algebra_fin_apply":
 "@[simp]\ntheorem mk_pi_algebra_fin_apply (m : Fin n → A) :\n    ContinuousMultilinearMap.mkPiAlgebraFin R n A m = (List.ofFn m).prod :=\n  rfl\n#align mk_pi_algebra_fin_apply mk_pi_algebra_fin_apply\n\n",
 "mk_pi_algebra_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[simp]\ntheorem mk_pi_algebra_apply (m : ι → A) :\n    ContinuousMultilinearMap.mkPiAlgebra R ι A m =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (m i) :=\n  rfl\n#align mk_pi_algebra_apply mk_pi_algebra_apply\n\n",
 "map_zero":
 "#print map_zero /-\n@[simp]\ntheorem map_zero [Nonempty ι] : f 0 = 0 :=\n  f.to_multilinear_map.map_zero\n#align map_zero map_zero\n-/\n\n",
 "map_sum_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- If `f` is continuous multilinear, then `f (Σ_{j₁ ∈ A₁} g₁ j₁, ..., Σ_{jₙ ∈ Aₙ} gₙ jₙ)` is the\nsum of `f (g₁ (r 1), ..., gₙ (r n))` where `r` ranges over all functions with `r 1 ∈ A₁`, ...,\n`r n ∈ Aₙ`. This follows from multilinearity by expanding successively with respect to each\ncoordinate. -/\ntheorem map_sum_finset [DecidableEq ι] :\n    (f fun i =>\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (A i) (g i j)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (piFinset A)\n        (f fun i => g i (r i)) :=\n  f.to_multilinear_map.map_sum_finset _ _\n#align map_sum_finset map_sum_finset\n\n",
 "map_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n#print map_sum /-\n/-- If `f` is continuous multilinear, then `f (Σ_{j₁} g₁ j₁, ..., Σ_{jₙ} gₙ jₙ)` is the sum of\n`f (g₁ (r 1), ..., gₙ (r n))` where `r` ranges over all functions `r`. This follows from\nmultilinearity by expanding successively with respect to each coordinate. -/\ntheorem map_sum [DecidableEq ι] [∀ i, Fintype (α i)] :\n    (f fun i =>\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (g i j)) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (f fun i => g i (r i)) :=\n  f.to_multilinear_map.map_sum _\n#align map_sum map_sum\n-/\n\n",
 "map_sub":
 "#print map_sub /-\n@[simp]\ntheorem map_sub [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (x y : M₁ i) :\n    f (update m i (x - y)) = f (update m i x) - f (update m i y) :=\n  f.to_multilinear_map.map_sub _ _ _ _\n#align map_sub map_sub\n-/\n\n",
 "map_smul_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- Multiplicativity of a continuous multilinear map along all coordinates at the same time,\nwriting `f (λ i, c i • m i)` as `(∏ i, c i) • f m`. -/\ntheorem map_smul_univ [Fintype ι] (c : ι → R) (m : ∀ i, M₁ i) :\n    (f fun i => «expr • » (c i) (m i)) =\n      «expr • »\n        (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (c i))\n        (f m) :=\n  f.to_multilinear_map.map_smul_univ _ _\n#align map_smul_univ map_smul_univ\n\n",
 "map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem map_smul [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (c : R) (x : M₁ i) :\n    f (update m i («expr • » c x)) = «expr • » c (f (update m i x)) :=\n  f.map_smul' m i c x\n#align map_smul map_smul\n\n",
 "map_piecewise_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem map_piecewise_smul [DecidableEq ι] (c : ι → R) (m : ∀ i, M₁ i) (s : Finset ι) :\n    f (s.piecewise (fun i => «expr • » (c i) (m i)) m) =\n      «expr • »\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (c i))\n        (f m) :=\n  f.to_multilinear_map.map_piecewise_smul _ _ _\n#align map_piecewise_smul map_piecewise_smul\n\n",
 "map_piecewise_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem map_piecewise_add [DecidableEq ι] (m m' : ∀ i, M₁ i) (t : Finset ι) :\n    f (t.piecewise (m + m') m') =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t.powerset\n        (f (s.piecewise m m')) :=\n  f.to_multilinear_map.map_piecewise_add _ _ _\n#align map_piecewise_add map_piecewise_add\n\n",
 "map_coord_zero":
 "theorem map_coord_zero {m : ∀ i, M₁ i} (i : ι) (h : m i = 0) : f m = 0 :=\n  f.to_multilinear_map.map_coord_zero i h\n#align map_coord_zero map_coord_zero\n\n",
 "map_add_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- Additivity of a continuous multilinear map along all coordinates at the same time,\nwriting `f (m + m')` as the sum  of `f (s.piecewise m m')` over all sets `s`. -/\ntheorem map_add_univ [DecidableEq ι] [Fintype ι] (m m' : ∀ i, M₁ i) :\n    f (m + m') =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (f (s.piecewise m m')) :=\n  f.to_multilinear_map.map_add_univ _ _\n#align map_add_univ map_add_univ\n\n",
 "map_add":
 "#print map_add /-\n@[simp]\ntheorem map_add [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (x y : M₁ i) :\n    f (update m i (x + y)) = f (update m i x) + f (update m i y) :=\n  f.map_add' m i x y\n#align map_add map_add\n-/\n\n",
 "ext_iff":
 "theorem ext_iff {f f' : ContinuousMultilinearMap R M₁ M₂} : f = f' ↔ ∀ x, f x = f' x := by\n  rw [← to_multilinear_map_injective.eq_iff, MultilinearMap.ext_iff] <;> rfl\n#align ext_iff ext_iff\n\n",
 "ext":
 "@[ext]\ntheorem ext {f f' : ContinuousMultilinearMap R M₁ M₂} (H : ∀ x, f x = f' x) : f = f' :=\n  FunLike.ext _ _ H\n#align ext ext\n\n",
 "cons_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- In the specific case of continuous multilinear maps on spaces indexed by `fin (n+1)`, where one\ncan build an element of `Π(i : fin (n+1)), M i` using `cons`, one can express directly the\nmultiplicativity of a multilinear map along the first variable. -/\ntheorem cons_smul (f : ContinuousMultilinearMap R M M₂) (m : ∀ i : Fin n, M i.succ) (c : R) (x : M 0) :\n    f (cons («expr • » c x) m) = «expr • » c (f (cons x m)) :=\n  f.to_multilinear_map.cons_smul m c x\n#align cons_smul cons_smul\n\n",
 "cons_add":
 "/-- In the specific case of continuous multilinear maps on spaces indexed by `fin (n+1)`, where one\ncan build an element of `Π(i : fin (n+1)), M i` using `cons`, one can express directly the\nadditivity of a multilinear map along the first variable. -/\ntheorem cons_add (f : ContinuousMultilinearMap R M M₂) (m : ∀ i : Fin n, M i.succ) (x y : M 0) :\n    f (cons (x + y) m) = f (cons x m) + f (cons y m) :=\n  f.to_multilinear_map.cons_add m x y\n#align cons_add cons_add\n\n",
 "comp_continuous_multilinear_map_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n#print ContinuousLinearMap.compContinuousMultilinearMap_coe /-\n@[simp]\ntheorem ContinuousLinearMap.compContinuousMultilinearMap_coe (g : «expr →L[ ] » M₂ R M₃)\n    (f : ContinuousMultilinearMap R M₁ M₂) :\n    (g.comp_continuous_multilinear_map f : (∀ i, M₁ i) → M₃) = (g : M₂ → M₃) ∘ (f : (∀ i, M₁ i) → M₂) :=\n  by\n  ext m\n  rfl\n#align continuous_linear_map.comp_continuous_multilinear_map_coe ContinuousLinearMap.compContinuousMultilinearMap_coe\n-/\n\n",
 "comp_continuous_linear_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem comp_continuous_linear_map_apply (g : ContinuousMultilinearMap R M₁' M₄)\n    (f : ∀ i : ι, «expr →L[ ] » (M₁ i) R (M₁' i)) (m : ∀ i, M₁ i) :\n    g.comp_continuous_linear_map f m = g fun i => f i <| m i :=\n  rfl\n#align comp_continuous_linear_map_apply comp_continuous_linear_map_apply\n\n",
 "coe_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_restrict_scalars (f : ContinuousMultilinearMap A M₁ M₂) : «expr⇑ » (f.restrict_scalars R) = f :=\n  rfl\n#align coe_restrict_scalars coe_restrict_scalars\n\n",
 "coe_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_pi {ι' : Type _} {M' : ι' → Type _} [∀ i, AddCommMonoid (M' i)] [∀ i, TopologicalSpace (M' i)]\n    [∀ i, Module R (M' i)] (f : ∀ i, ContinuousMultilinearMap R M₁ (M' i)) : «expr⇑ » (pi f) = fun m j => f j m :=\n  rfl\n#align coe_pi coe_pi\n\n",
 "coe_continuous":
 "@[continuity]\ntheorem coe_continuous : Continuous (f : (∀ i, M₁ i) → M₂) :=\n  f.cont\n#align coe_continuous coe_continuous\n\n",
 "coe_coe":
 "@[simp]\ntheorem coe_coe : (f.to_multilinear_map : (∀ i, M₁ i) → M₂) = f :=\n  rfl\n#align coe_coe coe_coe\n\n",
 "add_apply":
 "@[simp]\ntheorem add_apply (m : ∀ i, M₁ i) : (f + f') m = f m + f' m :=\n  rfl\n#align add_apply add_apply\n\n"}