{"le_is_closable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/-- If `g` has a closable extension `f`, then `g` itself is closable. -/\ntheorem is_closable.le_is_closable {f g : «expr →ₗ.[ ] » E R F} (hf : f.is_closable) (hfg : g ≤ f) : g.is_closable :=\n  by\n  cases' hf with f' hf\n  have : g.graph.topological_closure ≤ f'.graph := by\n    rw [← hf]\n    exact submodule.topological_closure_mono (le_graph_of_le hfg)\n  refine' ⟨g.graph.topological_closure.to_linear_pmap _, _⟩\n  · intro x hx hx'\n    cases x\n    exact f'.graph_fst_eq_zero_snd (this hx) hx'\n  rw [submodule.to_linear_pmap_graph_eq]\n#align is_closable.le_is_closable is_closable.le_is_closable\n\n",
 "le_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/-- A `linear_pmap` is contained in its closure. -/\ntheorem le_closure (f : «expr →ₗ.[ ] » E R F) : f ≤ f.closure :=\n  by\n  by_cases hf : f.is_closable\n  · refine' le_of_le_graph _\n    rw [← hf.graph_closure_eq_closure_graph]\n    exact (graph f).le_topological_closure\n  rw [closure_def' hf]\n#align le_closure le_closure\n\n",
 "is_closable_iff_exists_closed_extension":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem is_closable_iff_exists_closed_extension {f : «expr →ₗ.[ ] » E R F} :\n    f.is_closable ↔ ∃ (g : «expr →ₗ.[ ] » E R F)(hg : g.is_closed), f ≤ g :=\n  ⟨fun h => ⟨f.closure, h.closure_is_closed, f.le_closure⟩, fun ⟨_, hg, h⟩ => hg.is_closable.le_is_closable h⟩\n#align is_closable_iff_exists_closed_extension is_closable_iff_exists_closed_extension\n\n",
 "is_closable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/-\nCopyright (c) 2022 Moritz Doll. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Moritz Doll\n-/\n/-- A closed operator is trivially closable. -/\ntheorem is_closed.is_closable {f : «expr →ₗ.[ ] » E R F} (hf : f.is_closed) : f.is_closable :=\n  ⟨f, hf.submodule_topological_closure_eq⟩\n#align is_closed.is_closable is_closed.is_closable\n\n",
 "has_core_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem has_core_def {f : «expr →ₗ.[ ] » E R F} {S : submodule R E} (h : f.has_core S) :\n    (f.dom_restrict S).closure = f :=\n  h.2\n#align has_core_def has_core_def\n\n",
 "graph_closure_eq_closure_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/-- The closure (as a submodule) of the graph is equal to the graph of the closure\n  (as a `linear_pmap`). -/\ntheorem is_closable.graph_closure_eq_closure_graph {f : «expr →ₗ.[ ] » E R F} (hf : f.is_closable) :\n    f.graph.topological_closure = f.closure.graph :=\n  by\n  rw [closure_def hf]\n  exact hf.some_spec\n#align is_closable.graph_closure_eq_closure_graph is_closable.graph_closure_eq_closure_graph\n\n",
 "exists_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/-- The closure is unique. -/\ntheorem is_closable.exists_unique {f : «expr →ₗ.[ ] » E R F} (hf : f.is_closable) :\n    ∃! f' : «expr →ₗ.[ ] » E R F, f.graph.topological_closure = f'.graph :=\n  by\n  refine' exists_unique_of_exists_of_unique hf fun _ _ hy₁ hy₂ => eq_of_eq_graph _\n  rw [← hy₁, ← hy₂]\n#align is_closable.exists_unique is_closable.exists_unique\n\n",
 "closure_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem is_closable.closure_mono {f g : «expr →ₗ.[ ] » E R F} (hg : g.is_closable) (h : f ≤ g) :\n    f.closure ≤ g.closure := by\n  refine' le_of_le_graph _\n  rw [← (hg.le_is_closable h).graph_closure_eq_closure_graph]\n  rw [← hg.graph_closure_eq_closure_graph]\n  exact submodule.topological_closure_mono (le_graph_of_le h)\n#align is_closable.closure_mono is_closable.closure_mono\n\n",
 "closure_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/-- If `f` is closable, then the closure is closed. -/\ntheorem is_closable.closure_is_closed {f : «expr →ₗ.[ ] » E R F} (hf : f.is_closable) : f.closure.is_closed :=\n  by\n  rw [is_closed, ← hf.graph_closure_eq_closure_graph]\n  exact f.graph.is_closed_topological_closure\n#align is_closable.closure_is_closed is_closable.closure_is_closed\n\n",
 "closure_is_closable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/-- If `f` is closable, then the closure is closable. -/\ntheorem is_closable.closure_is_closable {f : «expr →ₗ.[ ] » E R F} (hf : f.is_closable) : f.closure.is_closable :=\n  hf.closure_is_closed.is_closable\n#align is_closable.closure_is_closable is_closable.closure_is_closable\n\n",
 "closure_has_core":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/-- For every unbounded operator `f` the submodule `f.domain` is a core of its closure.\n\nNote that we don't require that `f` is closable, due to the definition of the closure. -/\ntheorem closure_has_core (f : «expr →ₗ.[ ] » E R F) : f.closure.has_core f.domain :=\n  by\n  refine' ⟨f.le_closure.1, _⟩\n  congr\n  ext\n  · simp only [dom_restrict_domain, submodule.mem_inf, and_iff_left_iff_imp]\n    intro hx\n    exact f.le_closure.1 hx\n  intro x y hxy\n  let z : f.closure.domain := ⟨y.1, f.le_closure.1 y.2⟩\n  have hyz : (y : E) = z := by simp\n  rw [f.le_closure.2 hyz]\n  exact dom_restrict_apply (hxy.trans hyz)\n#align closure_has_core closure_has_core\n\n",
 "closure_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem closure_def' {f : «expr →ₗ.[ ] » E R F} (hf : ¬f.is_closable) : f.closure = f := by simp [closure, hf]\n#align closure_def' closure_def'\n\n",
 "closure_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem closure_def {f : «expr →ₗ.[ ] » E R F} (hf : f.is_closable) : f.closure = hf.some := by simp [closure, hf]\n#align closure_def closure_def\n\n"}