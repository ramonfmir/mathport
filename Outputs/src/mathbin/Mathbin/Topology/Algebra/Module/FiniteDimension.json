{"unique_topology_of_t2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-\nCopyright (c) 2022 Anatole Dedecker. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: SÃ©bastien GouÃ«zel, Anatole Dedecker\n-/\n/-- If `ğ•œ` is a nontrivially normed field, any T2 topology on `ğ•œ` which makes it a topological\nvector space over itself (with the norm topology) is *equal* to the norm topology. -/\ntheorem unique_topology_of_t2 {t : TopologicalSpace ğ•œ} (hâ‚ : @TopologicalAddGroup ğ•œ t _)\n    (hâ‚‚ : @ContinuousSMul ğ•œ ğ•œ _ hnorm.to_uniform_space.to_topological_space t) (hâ‚ƒ : @T2Space ğ•œ t) :\n    t = hnorm.to_uniform_space.to_topological_space :=\n  by\n  -- Let `ğ“£â‚€` denote the topology on `ğ•œ` induced by the norm, and `ğ“£` be any T2 vector\n  -- topology on `ğ•œ`. To show that `ğ“£â‚€ = ğ“£`, it suffices to show that they have the same\n  -- neighborhoods of 0.\n  refine' TopologicalAddGroup.ext hâ‚ inferInstance (le_antisymm _ _)\n  Â· -- To show `ğ“£ â‰¤ ğ“£â‚€`, we have to show that closed balls are `ğ“£`-neighborhoods of 0.\n    rw [metric.nhds_basis_closed_ball.ge_iff]\n    -- Let `Îµ > 0`. Since `ğ•œ` is nontrivially normed, we have `0 < â€–Î¾â‚€â€– < Îµ` for some `Î¾â‚€ : ğ•œ`.\n    intro Îµ hÎµ\n    rcases NormedField.exists_norm_lt ğ•œ hÎµ with âŸ¨Î¾â‚€, hÎ¾â‚€, hÎ¾â‚€ÎµâŸ©\n    -- Since `Î¾â‚€ â‰  0` and `ğ“£` is T2, we know that `{Î¾â‚€}á¶œ` is a `ğ“£`-neighborhood of 0.\n    have : Â«expr á¶œÂ» {Î¾â‚€} âˆˆ @nhds ğ•œ t 0 :=\n      IsOpen.mem_nhds isOpen_compl_singleton (ne.symm <| norm_ne_zero_iff.mp hÎ¾â‚€.ne.symm)\n    -- Thus, its balanced core `ğ“‘` is too. Let's show that the closed ball of radius `Îµ` contains\n    -- `ğ“‘`, which will imply that the closed ball is indeed a `ğ“£`-neighborhood of 0.\n    have : balancedCore ğ•œ (Â«expr á¶œÂ» {Î¾â‚€}) âˆˆ @nhds ğ•œ t 0 := balancedCore_mem_nhds_zero this\n    refine' mem_of_superset this fun Î¾ hÎ¾ => _\n    -- Let `Î¾ âˆˆ ğ“‘`. We want to show `â€–Î¾â€– < Îµ`. If `Î¾ = 0`, this is trivial.\n    by_cases hÎ¾0 : Î¾ = 0\n    Â· rw [hÎ¾0]\n      exact Metric.mem_closedBall_self hÎµ.le\n    Â· rw [mem_closedBall_zero_iff]\n      -- Now suppose `Î¾ â‰  0`. By contradiction, let's assume `Îµ < â€–Î¾â€–`, and show that\n      -- `Î¾â‚€ âˆˆ ğ“‘ âŠ† {Î¾â‚€}á¶œ`, which is a contradiction.\n      by_contra' h\n      suffices Â«expr â€¢ Â» (Î¾â‚€ * Î¾â»Â¹) Î¾ âˆˆ balancedCore ğ•œ (Â«expr á¶œÂ» {Î¾â‚€})\n        by\n        rw [smul_eq_mul ğ•œ, mul_assoc, inv_mul_cancel hÎ¾0, mul_one] at this\n        exact not_mem_compl_iff.mpr (mem_singleton Î¾â‚€) ((balancedCore_subset _) this)\n      -- For that, we use that `ğ“‘` is balanced : since `â€–Î¾â‚€â€– < Îµ < â€–Î¾â€–`, we have `â€–Î¾â‚€ / Î¾â€– â‰¤ 1`,\n      -- hence `Î¾â‚€ = (Î¾â‚€ / Î¾) â€¢ Î¾ âˆˆ ğ“‘` because `Î¾ âˆˆ ğ“‘`.\n      refine' (balancedCore_balanced _).smul_mem _ hÎ¾\n      rw [norm_mul, norm_inv, mul_inv_le_iff (norm_pos_iff.mpr hÎ¾0), mul_one]\n      exact (hÎ¾â‚€Îµ.trans h).le\n  Â·-- Finally, to show `ğ“£â‚€ â‰¤ ğ“£`, we simply argue that `id = (Î» x, x â€¢ 1)` is continuous from\n    -- `(ğ•œ, ğ“£â‚€)` to `(ğ•œ, ğ“£)` because `(â€¢) : (ğ•œ, ğ“£â‚€) Ã— (ğ•œ, ğ“£) â†’ (ğ•œ, ğ“£)` is continuous.\n    calc\n      @nhds ğ•œ hnorm.to_uniform_space.to_topological_space 0 =\n          map id (@nhds ğ•œ hnorm.to_uniform_space.to_topological_space 0) :=\n        map_id.symm\n      _ = map (fun x => Â«expr â€¢ Â» (id x) 1) (@nhds ğ•œ hnorm.to_uniform_space.to_topological_space 0) := by\n        conv_rhs =>\n            congr\n            ext\n            rw [smul_eq_mul, mul_one] <;>\n          rfl\n      _ â‰¤ @nhds ğ•œ t (Â«expr â€¢ Â» (0 : ğ•œ) 1) :=\n        (@tendsto.smul_const _ _ _ hnorm.to_uniform_space.to_topological_space t _ _ _ _ _ tendsto_id (1 : ğ•œ))\n      _ = @nhds ğ•œ t 0 := by rw [zero_smul]\n      \n#align unique_topology_of_t2 unique_topology_of_t2\n\n",
 "to_linear_equiv_to_continuous_linear_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n@[simp]\ntheorem to_linear_equiv_to_continuous_linear_equiv_symm (e : Â«expr â‰ƒâ‚—[ ] Â» E ğ•œ F) :\n    e.to_continuous_linear_equiv.symm.to_linear_equiv = e.symm :=\n  by\n  ext x\n  rfl\n#align to_linear_equiv_to_continuous_linear_equiv_symm to_linear_equiv_to_continuous_linear_equiv_symm\n\n",
 "to_linear_equiv_to_continuous_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n@[simp]\ntheorem to_linear_equiv_to_continuous_linear_equiv (e : Â«expr â‰ƒâ‚—[ ] Â» E ğ•œ F) :\n    e.to_continuous_linear_equiv.to_linear_equiv = e := by\n  ext x\n  rfl\n#align to_linear_equiv_to_continuous_linear_equiv to_linear_equiv_to_continuous_linear_equiv\n\n",
 "to_lin_fin_two_prod_to_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem _root_.matrix.to_lin_fin_two_prod_to_continuous_linear_map (a b c d : ğ•œ) :\n    (Matrix.toLin (Basis.finTwoProd ğ•œ) (Basis.finTwoProd ğ•œ) !![a, b; c, d]).to_continuous_linear_map =\n      (Â«expr â€¢ Â» a (ContinuousLinearMap.fst ğ•œ ğ•œ ğ•œ) + Â«expr â€¢ Â» b (ContinuousLinearMap.snd ğ•œ ğ•œ ğ•œ)).prod\n        (Â«expr â€¢ Â» c (ContinuousLinearMap.fst ğ•œ ğ•œ ğ•œ) + Â«expr â€¢ Â» d (ContinuousLinearMap.snd ğ•œ ğ•œ ğ•œ)) :=\n  ContinuousLinearMap.ext <| Matrix.toLin_finTwoProd_apply _ _ _ _\n#align matrix.to_lin_fin_two_prod_to_continuous_linear_map matrix.to_lin_fin_two_prod_to_continuous_linear_map\n\n",
 "to_continuous_linear_equiv_of_det_ne_zero_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n@[simp]\ntheorem to_continuous_linear_equiv_of_det_ne_zero_apply (f : Â«expr â†’L[ ] Â» E ğ•œ E) (hf : f.det â‰  0) (x : E) :\n    f.to_continuous_linear_equiv_of_det_ne_zero hf x = f x :=\n  rfl\n#align to_continuous_linear_equiv_of_det_ne_zero_apply to_continuous_linear_equiv_of_det_ne_zero_apply\n\n",
 "range_to_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem range_to_continuous_linear_map (f : Â«expr â†’â‚—[ ] Â» E ğ•œ F') : range f.to_continuous_linear_map = range f :=\n  rfl\n#align range_to_continuous_linear_map range_to_continuous_linear_map\n\n",
 "nonempty_continuous_linear_equiv_of_finrank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- Two finite-dimensional topological vector spaces over a complete normed field are continuously\nlinearly equivalent if they have the same (finite) dimension. -/\ntheorem finite_dimensional.nonempty_continuous_linear_equiv_of_finrank_eq (cond : finrank ğ•œ E = finrank ğ•œ F) :\n    Nonempty (Â«expr â‰ƒL[ ] Â» E ğ•œ F) :=\n  (nonempty_linearEquiv_of_finrank_eq cond).map linear_equiv.to_continuous_linear_equiv\n#align finite_dimensional.nonempty_continuous_linear_equiv_of_finrank_eq finite_dimensional.nonempty_continuous_linear_equiv_of_finrank_eq\n\n",
 "nonempty_continuous_linear_equiv_iff_finrank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/-- Two finite-dimensional topological vector spaces over a complete normed field are continuously\nlinearly equivalent if and only if they have the same (finite) dimension. -/\ntheorem finite_dimensional.nonempty_continuous_linear_equiv_iff_finrank_eq :\n    Nonempty (Â«expr â‰ƒL[ ] Â» E ğ•œ F) â†” finrank ğ•œ E = finrank ğ•œ F :=\n  âŸ¨fun âŸ¨hâŸ© => h.to_linear_equiv.finrank_eq, fun h =>\n    finite_dimensional.nonempty_continuous_linear_equiv_of_finrank_eq hâŸ©\n#align finite_dimensional.nonempty_continuous_linear_equiv_iff_finrank_eq finite_dimensional.nonempty_continuous_linear_equiv_iff_finrank_eq\n\n",
 "ker_to_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem ker_to_continuous_linear_map (f : Â«expr â†’â‚—[ ] Â» E ğ•œ F') : ker f.to_continuous_linear_map = ker f :=\n  rfl\n#align ker_to_continuous_linear_map ker_to_continuous_linear_map\n\n",
 "is_open_map_of_finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- A surjective linear map `f` with finite dimensional codomain is an open map. -/\ntheorem is_open_map_of_finite_dimensional (f : Â«expr â†’â‚—[ ] Â» F ğ•œ E) (hf : function.surjective f) : IsOpenMap f :=\n  by\n  rcases f.exists_right_inverse_of_surjective (LinearMap.range_eq_top.2 hf) with âŸ¨g, hgâŸ©\n  refine' IsOpenMap.of_sections fun x => âŸ¨fun y => g (y - f x) + x, _, _, fun y => _âŸ©\n  Â·\n    exact\n      ((g.continuous_of_finite_dimensional.comp <| continuous_id.sub continuous_const).add\n          continuous_const).continuous_at\n  Â· rw [sub_self, map_zero, zero_add]\n  Â· simp only [map_sub, map_add, â† comp_apply f g, hg, id_apply, sub_add_cancel]\n#align is_open_map_of_finite_dimensional is_open_map_of_finite_dimensional\n\n",
 "det_to_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem det_to_continuous_linear_map (f : Â«expr â†’â‚—[ ] Â» E ğ•œ E) : f.to_continuous_linear_map.det = f.det :=\n  rfl\n#align det_to_continuous_linear_map det_to_continuous_linear_map\n\n",
 "continuous_of_nonzero_on_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- Over a nontrivially normed field, any linear form which is nonzero on a nonempty open set is\n    automatically continuous. -/\ntheorem linear_map.continuous_of_nonzero_on_open (l : Â«expr â†’â‚—[ ] Â» E ğ•œ ğ•œ) (s : Set E) (hsâ‚ : IsOpen s)\n    (hsâ‚‚ : s.nonempty) (hsâ‚ƒ : âˆ€ x âˆˆ s, l x â‰  0) : Continuous l :=\n  by\n  refine' l.continuous_of_is_closed_ker (l.is_closed_or_dense_ker.resolve_right fun hl => _)\n  rcases hsâ‚‚ with âŸ¨x, hxâŸ©\n  have : x âˆˆ interior (Â«expr á¶œÂ» (l.ker : Set E)) :=\n    by\n    rw [mem_interior_iff_mem_nhds]\n    exact mem_of_superset (hsâ‚.mem_nhds hx) hsâ‚ƒ\n  rwa [hl.interior_compl] at this\n#align linear_map.continuous_of_nonzero_on_open linear_map.continuous_of_nonzero_on_open\n\n",
 "continuous_of_is_closed_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â§¸ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- Any linear form on a topological vector space over a nontrivially normed field is continuous if\n    its kernel is closed. -/\ntheorem linear_map.continuous_of_is_closed_ker (l : Â«expr â†’â‚—[ ] Â» E ğ•œ ğ•œ) (hl : IsClosed (l.ker : Set E)) :\n    Continuous l :=\n  by\n  -- `l` is either constant or surjective. If it is constant, the result is trivial.\n  by_cases H : finrank ğ•œ l.range = 0\n  Â· rw [finrank_eq_zero, LinearMap.range_eq_bot] at H\n    rw [H]\n    exact continuous_zero\n  Â· -- In the case where `l` is surjective, we factor it as `Ï† : (E â§¸ l.ker) â‰ƒâ‚—[ğ•œ] ğ•œ`. Note that\n    -- `E â§¸ l.ker` is T2 since `l.ker` is closed.\n    have : finrank ğ•œ l.range = 1 := le_antisymm (finrank_self ğ•œ â–¸ l.range.finrank_le) (zero_lt_iff.mpr H)\n    have hi : function.injective (l.ker.liftq l (le_refl _)) :=\n      by\n      rw [â† LinearMap.ker_eq_bot]\n      exact Submodule.ker_liftQ_eq_bot _ _ _ (le_refl _)\n    have hs : function.surjective (l.ker.liftq l (le_refl _)) :=\n      by\n      rw [â† LinearMap.range_eq_top, Submodule.range_liftQ]\n      exact eq_top_of_finrank_eq ((finrank_self ğ•œ).symm â–¸ this)\n    let Ï† : Â«expr â‰ƒâ‚—[ ] Â» (Â«expr â§¸ Â» E l.ker) ğ•œ ğ•œ := LinearEquiv.ofBijective (l.ker.liftq l (le_refl _)) âŸ¨hi, hsâŸ©\n    have hlÏ† : (l : E â†’ ğ•œ) = Ï† âˆ˜ l.ker.mkq := by ext <;> rfl\n    -- Since the quotient map `E â†’â‚—[ğ•œ] (E â§¸ l.ker)` is continuous, the continuity of `l` will follow\n    -- form the continuity of `Ï†`.\n    suffices Continuous Ï†.to_equiv by\n      rw [hlÏ†]\n      exact this.comp continuous_quot_mk\n    -- The pullback by `Ï†.symm` of the quotient topology is a T2 topology on `ğ•œ`, because `Ï†.symm`\n    -- is injective. Since `Ï†.symm` is linear, it is also a vector space topology.\n    -- Hence, we know that it is equal to the topology induced by the norm.\n    have : induced Ï†.to_equiv.symm inferInstance = hnorm.to_uniform_space.to_topological_space :=\n      by\n      refine'\n        unique_topology_of_t2 (topologicalAddGroup_induced Ï†.symm.to_linear_map)\n          (continuousSMul_induced Ï†.symm.to_linear_map) _\n      rw [t2_space_iff]\n      exact fun x y hxy =>\n        @separated_by_continuous _ _ (induced _ _) _ _ _ continuous_induced_dom _ _ (Ï†.to_equiv.symm.injective.ne hxy)\n    -- Finally, the pullback by `Ï†.symm` is exactly the pushforward by `Ï†`, so we have to prove\n    -- that `Ï†` is continuous when `ğ•œ` is endowed with the pushforward by `Ï†` of the quotient\n    -- topology, which is trivial by definition of the pushforward.\n    rw [this.symm, Equiv.induced_symm]\n    exact continuous_coinduced_rng\n#align linear_map.continuous_of_is_closed_ker linear_map.continuous_of_is_closed_ker\n\n",
 "continuous_of_finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- Any linear map on a finite dimensional space over a complete field is continuous. -/\ntheorem linear_map.continuous_of_finite_dimensional [T2Space E] [FiniteDimensional ğ•œ E] (f : Â«expr â†’â‚—[ ] Â» E ğ•œ F') :\n    Continuous f :=\n  by\n  -- for the proof, go to a model vector space `b â†’ ğ•œ` thanks to `continuous_equiv_fun_basis`, and\n  -- argue that all linear maps there are continuous.\n  let b := Basis.ofVectorSpace ğ•œ E\n  have A : Continuous b.equiv_fun := continuous_equiv_fun_basis_aux b\n  have B : Continuous (f.comp (b.equiv_fun.symm : Â«expr â†’â‚—[ ] Â» (Basis.ofVectorSpaceIndex ğ•œ E â†’ ğ•œ) ğ•œ E)) :=\n    LinearMap.continuous_on_pi _\n  have : Continuous (f.comp (b.equiv_fun.symm : Â«expr â†’â‚—[ ] Â» (Basis.ofVectorSpaceIndex ğ•œ E â†’ ğ•œ) ğ•œ E) âˆ˜ b.equiv_fun) :=\n    B.comp A\n  convert this\n  ext x\n  dsimp\n  rw [Basis.equivFun_symm_apply, Basis.sum_repr]\n#align linear_map.continuous_of_finite_dimensional linear_map.continuous_of_finite_dimensional\n\n",
 "continuous_iff_is_closed_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- Any linear form on a topological vector space over a nontrivially normed field is continuous if\n    and only if its kernel is closed. -/\ntheorem linear_map.continuous_iff_is_closed_ker (l : Â«expr â†’â‚—[ ] Â» E ğ•œ ğ•œ) : Continuous l â†” IsClosed (l.ker : Set E) :=\n  âŸ¨fun h => isClosed_singleton.preimage h, l.continuous_of_is_closed_kerâŸ©\n#align linear_map.continuous_iff_is_closed_ker linear_map.continuous_iff_is_closed_ker\n\n",
 "continuous_equiv_fun_basis_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- This version imposes `Î¹` and `E` to live in the same universe, so you should instead use\n`continuous_equiv_fun_basis` which gives the same result without universe restrictions. -/\nprivate theorem continuous_equiv_fun_basis_aux [ht2 : T2Space E] {Î¹ : Type v} [Fintype Î¹] (Î¾ : Basis Î¹ ğ•œ E) :\n    Continuous Î¾.equiv_fun :=\n  by\n  letI : UniformSpace E := TopologicalAddGroup.toUniformSpace E\n  letI : UniformAddGroup E := comm_topologicalAddGroup_is_uniform\n  letI : SeparatedSpace E := separated_iff_t2.mpr ht2\n  induction' hn : Fintype.card Î¹ with n IH generalizing Î¹ E\n  Â· rw [Fintype.card_eq_zero_iff] at hn\n    exact continuous_of_const fun x y => funext hn.elim\n  Â· haveI : FiniteDimensional ğ•œ E := of_fintype_basis Î¾\n    -- first step: thanks to the induction hypothesis, any n-dimensional subspace is equivalent\n    -- to a standard space of dimension n, hence it is complete and therefore closed.\n    have Hâ‚ : âˆ€ s : Submodule ğ•œ E, finrank ğ•œ s = n â†’ IsClosed (s : Set E) :=\n      by\n      intro s s_dim\n      letI : UniformAddGroup s := s.to_add_subgroup.uniform_add_group\n      let b := Basis.ofVectorSpace ğ•œ s\n      have U : UniformEmbedding b.equiv_fun.symm.to_equiv :=\n        by\n        have : Fintype.card (Basis.ofVectorSpaceIndex ğ•œ s) = n :=\n          by\n          rw [â† s_dim]\n          exact (finrank_eq_card_basis b).symm\n        have : Continuous b.equiv_fun := IH b this\n        exact b.equiv_fun.symm.uniform_embedding b.equiv_fun.symm.to_linear_map.continuous_on_pi this\n      have : IsComplete (s : Set E) :=\n        completeSpace_coe_iff_isComplete.1 ((completeSpace_congr U).1 (by infer_instance))\n      exact this.is_closed\n    -- second step: any linear form is continuous, as its kernel is closed by the first step\n    have Hâ‚‚ : âˆ€ f : Â«expr â†’â‚—[ ] Â» E ğ•œ ğ•œ, Continuous f := by\n      intro f\n      by_cases H : finrank ğ•œ f.range = 0\n      Â· rw [finrank_eq_zero, LinearMap.range_eq_bot] at H\n        rw [H]\n        exact continuous_zero\n      Â· have : finrank ğ•œ f.ker = n := by\n          have Z := f.finrank_range_add_finrank_ker\n          rw [finrank_eq_card_basis Î¾, hn] at Z\n          have : finrank ğ•œ f.range = 1 := le_antisymm (finrank_self ğ•œ â–¸ f.range.finrank_le) (zero_lt_iff.mpr H)\n          rw [this, add_comm, nat.add_one] at Z\n          exact nat.succ.inj Z\n        have : IsClosed (f.ker : Set E) := Hâ‚ _ this\n        exact linear_map.continuous_of_is_closed_ker f this\n    rw [continuous_pi_iff]\n    intro i\n    change Continuous (Î¾.coord i)\n    exact Hâ‚‚ (Î¾.coord i)\n#align continuous_equiv_fun_basis_aux continuous_equiv_fun_basis_aux\n\n",
 "continuous_equiv_fun_basis":
 "/-- In finite dimensions over a non-discrete complete normed field, the canonical identification\n(in terms of a basis) with `ğ•œ^n` (endowed with the product topology) is continuous.\nThis is the key fact wich makes all linear maps from a T2 finite dimensional TVS over such a field\ncontinuous (see `linear_map.continuous_of_finite_dimensional`), which in turn implies that all\nnorms are equivalent in finite dimensions. -/\ntheorem continuous_equiv_fun_basis [T2Space E] {Î¹ : Type _} [Fintype Î¹] (Î¾ : Basis Î¹ ğ•œ E) : Continuous Î¾.equiv_fun :=\n  haveI : FiniteDimensional ğ•œ E := of_fintype_basis Î¾\n  Î¾.equiv_fun.to_linear_map.continuous_of_finite_dimensional\n#align continuous_equiv_fun_basis continuous_equiv_fun_basis\n\n",
 "constrL_basis":
 "@[simp]\ntheorem constrL_basis (v : Basis Î¹ ğ•œ E) (f : Î¹ â†’ F) (i : Î¹) : (v.constrL f) (v i) = f i :=\n  v.constr_basis ğ•œ _ _\n#align constrL_basis constrL_basis\n\n",
 "constrL_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[simp]\ntheorem constrL_apply (v : Basis Î¹ ğ•œ E) (f : Î¹ â†’ F) (e : E) :\n    (v.constrL f) e =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (Â«expr â€¢ Â» (v.equiv_fun e i) (f i)) :=\n  v.constr_apply_fintype ğ•œ _ _\n#align constrL_apply constrL_apply\n\n",
 "coe_to_continuous_linear_map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n@[simp]\ntheorem coe_to_continuous_linear_map_symm :\n    Â«exprâ‡‘ Â» (to_continuous_linear_map : Â«expr â‰ƒâ‚—[ ] Â» (Â«expr â†’â‚—[ ] Â» E ğ•œ F') ğ•œ (Â«expr â†’L[ ] Â» E ğ•œ F')).symm = coe :=\n  rfl\n#align coe_to_continuous_linear_map_symm coe_to_continuous_linear_map_symm\n\n",
 "coe_to_continuous_linear_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n@[simp]\ntheorem coe_to_continuous_linear_map' (f : Â«expr â†’â‚—[ ] Â» E ğ•œ F') : Â«exprâ‡‘ Â» f.to_continuous_linear_map = f :=\n  rfl\n#align coe_to_continuous_linear_map' coe_to_continuous_linear_map'\n\n",
 "coe_to_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem coe_to_continuous_linear_map (f : Â«expr â†’â‚—[ ] Â» E ğ•œ F') :\n    (f.to_continuous_linear_map : Â«expr â†’â‚—[ ] Â» E ğ•œ F') = f :=\n  rfl\n#align coe_to_continuous_linear_map coe_to_continuous_linear_map\n\n",
 "coe_to_continuous_linear_equiv_symm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n@[simp]\ntheorem coe_to_continuous_linear_equiv_symm' (e : Â«expr â‰ƒâ‚—[ ] Â» E ğ•œ F) :\n    (e.to_continuous_linear_equiv.symm : F â†’ E) = e.symm :=\n  rfl\n#align coe_to_continuous_linear_equiv_symm' coe_to_continuous_linear_equiv_symm'\n\n",
 "coe_to_continuous_linear_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem coe_to_continuous_linear_equiv_symm (e : Â«expr â‰ƒâ‚—[ ] Â» E ğ•œ F) :\n    (e.to_continuous_linear_equiv.symm : Â«expr â†’â‚—[ ] Â» F ğ•œ E) = e.symm :=\n  rfl\n#align coe_to_continuous_linear_equiv_symm coe_to_continuous_linear_equiv_symm\n\n",
 "coe_to_continuous_linear_equiv_of_det_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n@[simp]\ntheorem coe_to_continuous_linear_equiv_of_det_ne_zero (f : Â«expr â†’L[ ] Â» E ğ•œ E) (hf : f.det â‰  0) :\n    (f.to_continuous_linear_equiv_of_det_ne_zero hf : Â«expr â†’L[ ] Â» E ğ•œ E) = f :=\n  by\n  ext x\n  rfl\n#align coe_to_continuous_linear_equiv_of_det_ne_zero coe_to_continuous_linear_equiv_of_det_ne_zero\n\n",
 "coe_to_continuous_linear_equiv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n@[simp]\ntheorem coe_to_continuous_linear_equiv' (e : Â«expr â‰ƒâ‚—[ ] Â» E ğ•œ F) : (e.to_continuous_linear_equiv : E â†’ F) = e :=\n  rfl\n#align coe_to_continuous_linear_equiv' coe_to_continuous_linear_equiv'\n\n",
 "coe_to_continuous_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem coe_to_continuous_linear_equiv (e : Â«expr â‰ƒâ‚—[ ] Â» E ğ•œ F) :\n    (e.to_continuous_linear_equiv : Â«expr â†’â‚—[ ] Â» E ğ•œ F) = e :=\n  rfl\n#align coe_to_continuous_linear_equiv coe_to_continuous_linear_equiv\n\n",
 "coe_constrL":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp, norm_cast]\ntheorem coe_constrL (v : Basis Î¹ ğ•œ E) (f : Î¹ â†’ F) : (v.constrL f : Â«expr â†’â‚—[ ] Â» E ğ•œ F) = v.constr ğ•œ f :=\n  rfl\n#align coe_constrL coe_constrL\n\n"}