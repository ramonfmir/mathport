{"unique_topology_of_t2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `𝕜` is a nontrivially normed field, any T2 topology on `𝕜` which makes it a topological\nvector space over itself (with the norm topology) is *equal* to the norm topology. -/\ntheorem unique_topology_of_t2 {t : topological_space 𝕜} (h₁ : @topological_add_group 𝕜 t _)\n    (h₂ : @has_continuous_smul 𝕜 𝕜 _ hnorm.to_uniform_space.to_topological_space t) (h₃ : @t2_space 𝕜 t) :\n    t = hnorm.to_uniform_space.to_topological_space :=\n  by\n  -- Let `𝓣₀` denote the topology on `𝕜` induced by the norm, and `𝓣` be any T2 vector\n  -- topology on `𝕜`. To show that `𝓣₀ = 𝓣`, it suffices to show that they have the same\n  -- neighborhoods of 0.\n  refine' topological_add_group.ext h₁ infer_instance (le_antisymm _ _)\n  · -- To show `𝓣 ≤ 𝓣₀`, we have to show that closed balls are `𝓣`-neighborhoods of 0.\n    rw [metric.nhds_basis_closed_ball.ge_iff]\n    -- Let `ε > 0`. Since `𝕜` is nontrivially normed, we have `0 < ‖ξ₀‖ < ε` for some `ξ₀ : 𝕜`.\n    intro ε hε\n    rcases normed_field.exists_norm_lt 𝕜 hε with ⟨ξ₀, hξ₀, hξ₀ε⟩\n    -- Since `ξ₀ ≠ 0` and `𝓣` is T2, we know that `{ξ₀}ᶜ` is a `𝓣`-neighborhood of 0.\n    have : «expr ᶜ» {ξ₀} ∈ @nhds 𝕜 t 0 :=\n      is_open.mem_nhds is_open_compl_singleton (ne.symm <| norm_ne_zero_iff.mp hξ₀.ne.symm)\n    -- Thus, its balanced core `𝓑` is too. Let's show that the closed ball of radius `ε` contains\n    -- `𝓑`, which will imply that the closed ball is indeed a `𝓣`-neighborhood of 0.\n    have : balanced_core 𝕜 («expr ᶜ» {ξ₀}) ∈ @nhds 𝕜 t 0 := balanced_core_mem_nhds_zero this\n    refine' mem_of_superset this fun ξ hξ => _\n    -- Let `ξ ∈ 𝓑`. We want to show `‖ξ‖ < ε`. If `ξ = 0`, this is trivial.\n    by_cases hξ0 : ξ = 0\n    · rw [hξ0]\n      exact metric.mem_closed_ball_self hε.le\n    · rw [mem_closed_ball_zero_iff]\n      -- Now suppose `ξ ≠ 0`. By contradiction, let's assume `ε < ‖ξ‖`, and show that\n      -- `ξ₀ ∈ 𝓑 ⊆ {ξ₀}ᶜ`, which is a contradiction.\n      by_contra' h\n      suffices «expr • » (ξ₀ * ξ⁻¹) ξ ∈ balanced_core 𝕜 («expr ᶜ» {ξ₀})\n        by\n        rw [smul_eq_mul 𝕜, mul_assoc, inv_mul_cancel hξ0, mul_one] at this\n        exact not_mem_compl_iff.mpr (mem_singleton ξ₀) ((balanced_core_subset _) this)\n      -- For that, we use that `𝓑` is balanced : since `‖ξ₀‖ < ε < ‖ξ‖`, we have `‖ξ₀ / ξ‖ ≤ 1`,\n      -- hence `ξ₀ = (ξ₀ / ξ) • ξ ∈ 𝓑` because `ξ ∈ 𝓑`.\n      refine' (balanced_core_balanced _).smul_mem _ hξ\n      rw [norm_mul, norm_inv, mul_inv_le_iff (norm_pos_iff.mpr hξ0), mul_one]\n      exact (hξ₀ε.trans h).le\n  ·-- Finally, to show `𝓣₀ ≤ 𝓣`, we simply argue that `id = (λ x, x • 1)` is continuous from\n    -- `(𝕜, 𝓣₀)` to `(𝕜, 𝓣)` because `(•) : (𝕜, 𝓣₀) × (𝕜, 𝓣) → (𝕜, 𝓣)` is continuous.\n    calc\n      @nhds 𝕜 hnorm.to_uniform_space.to_topological_space 0 =\n          map id (@nhds 𝕜 hnorm.to_uniform_space.to_topological_space 0) :=\n        map_id.symm\n      _ = map (fun x => «expr • » (id x) 1) (@nhds 𝕜 hnorm.to_uniform_space.to_topological_space 0) := by\n        conv_rhs =>\n            congr\n            ext\n            rw [smul_eq_mul, mul_one] <;>\n          rfl\n      _ ≤ @nhds 𝕜 t («expr • » (0 : 𝕜) 1) :=\n        @tendsto.smul_const _ _ _ hnorm.to_uniform_space.to_topological_space t _ _ _ _ _ tendsto_id (1 : 𝕜)\n      _ = @nhds 𝕜 t 0 := by rw [zero_smul]\n      \n#align unique_topology_of_t2 unique_topology_of_t2\n\n",
 "to_linear_equiv_to_continuous_linear_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem to_linear_equiv_to_continuous_linear_equiv_symm (e : «expr ≃ₗ[ ] » E 𝕜 F) :\n    e.to_continuous_linear_equiv.symm.to_linear_equiv = e.symm :=\n  by\n  ext x\n  rfl\n#align to_linear_equiv_to_continuous_linear_equiv_symm to_linear_equiv_to_continuous_linear_equiv_symm\n\n",
 "to_linear_equiv_to_continuous_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem to_linear_equiv_to_continuous_linear_equiv (e : «expr ≃ₗ[ ] » E 𝕜 F) :\n    e.to_continuous_linear_equiv.to_linear_equiv = e := by\n  ext x\n  rfl\n#align to_linear_equiv_to_continuous_linear_equiv to_linear_equiv_to_continuous_linear_equiv\n\n",
 "to_lin_fin_two_prod_to_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr!![ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem _root_.matrix.to_lin_fin_two_prod_to_continuous_linear_map (a b c d : 𝕜) :\n    (matrix.to_lin (basis.fin_two_prod 𝕜) (basis.fin_two_prod 𝕜)\n          («expr!![ »\n            \"./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation\")).to_continuous_linear_map =\n      («expr • » a (continuous_linear_map.fst 𝕜 𝕜 𝕜) + «expr • » b (continuous_linear_map.snd 𝕜 𝕜 𝕜)).prod\n        («expr • » c (continuous_linear_map.fst 𝕜 𝕜 𝕜) + «expr • » d (continuous_linear_map.snd 𝕜 𝕜 𝕜)) :=\n  continuous_linear_map.ext <| matrix.to_lin_fin_two_prod_apply _ _ _ _\n#align matrix.to_lin_fin_two_prod_to_continuous_linear_map matrix.to_lin_fin_two_prod_to_continuous_linear_map\n\n",
 "to_continuous_linear_equiv_of_det_ne_zero_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem to_continuous_linear_equiv_of_det_ne_zero_apply (f : «expr →L[ ] » E 𝕜 E) (hf : f.det ≠ 0) (x : E) :\n    f.to_continuous_linear_equiv_of_det_ne_zero hf x = f x :=\n  rfl\n#align to_continuous_linear_equiv_of_det_ne_zero_apply to_continuous_linear_equiv_of_det_ne_zero_apply\n\n",
 "range_to_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem range_to_continuous_linear_map (f : «expr →ₗ[ ] » E 𝕜 F') : range f.to_continuous_linear_map = range f :=\n  rfl\n#align range_to_continuous_linear_map range_to_continuous_linear_map\n\n",
 "ker_to_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem ker_to_continuous_linear_map (f : «expr →ₗ[ ] » E 𝕜 F') : ker f.to_continuous_linear_map = ker f :=\n  rfl\n#align ker_to_continuous_linear_map ker_to_continuous_linear_map\n\n",
 "is_open_map_of_finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- A surjective linear map `f` with finite dimensional codomain is an open map. -/\ntheorem is_open_map_of_finite_dimensional (f : «expr →ₗ[ ] » F 𝕜 E) (hf : function.surjective f) : is_open_map f :=\n  by\n  rcases f.exists_right_inverse_of_surjective (linear_map.range_eq_top.2 hf) with ⟨g, hg⟩\n  refine' is_open_map.of_sections fun x => ⟨fun y => g (y - f x) + x, _, _, fun y => _⟩\n  ·\n    exact\n      ((g.continuous_of_finite_dimensional.comp <| continuous_id.sub continuous_const).add\n          continuous_const).continuous_at\n  · rw [sub_self, map_zero, zero_add]\n  · simp only [map_sub, map_add, ← comp_apply f g, hg, id_apply, sub_add_cancel]\n#align is_open_map_of_finite_dimensional is_open_map_of_finite_dimensional\n\n",
 "det_to_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem det_to_continuous_linear_map (f : «expr →ₗ[ ] » E 𝕜 E) : f.to_continuous_linear_map.det = f.det :=\n  rfl\n#align det_to_continuous_linear_map det_to_continuous_linear_map\n\n",
 "continuous_on_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-\nCopyright (c) 2022 Anatole Dedecker. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel, Anatole Dedecker\n-/\n/-- A linear map on `ι → 𝕜` (where `ι` is finite) is continuous -/\ntheorem linear_map.continuous_on_pi (f : «expr →ₗ[ ] » (ι → 𝕜) 𝕜 F) : continuous f :=\n  by\n  cases nonempty_fintype ι\n  classical\n    -- for the proof, write `f` in the standard basis, and use that each coordinate is a continuous\n    -- function.\n    have :\n      (f : (ι → 𝕜) → F) = fun x =>\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          («expr • » (x i) (f fun j => if i = j then 1 else 0)) :=\n      by\n      ext x\n      exact f.pi_apply_eq_sum_univ x\n    rw [this]\n    refine' continuous_finset_sum _ fun i hi => _\n    exact (continuous_apply i).smul continuous_const\n#align linear_map.continuous_on_pi linear_map.continuous_on_pi\n\n",
 "continuous_of_nonzero_on_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Over a nontrivially normed field, any linear form which is nonzero on a nonempty open set is\n    automatically continuous. -/\ntheorem linear_map.continuous_of_nonzero_on_open (l : «expr →ₗ[ ] » E 𝕜 𝕜) (s : set E) (hs₁ : is_open s)\n    (hs₂ : s.nonempty) (hs₃ : ∀ x ∈ s, l x ≠ 0) : continuous l :=\n  by\n  refine' l.continuous_of_is_closed_ker (l.is_closed_or_dense_ker.resolve_right fun hl => _)\n  rcases hs₂ with ⟨x, hx⟩\n  have : x ∈ interior («expr ᶜ» (l.ker : set E)) :=\n    by\n    rw [mem_interior_iff_mem_nhds]\n    exact mem_of_superset (hs₁.mem_nhds hx) hs₃\n  rwa [hl.interior_compl] at this\n#align linear_map.continuous_of_nonzero_on_open linear_map.continuous_of_nonzero_on_open\n\n",
 "continuous_of_is_closed_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Any linear form on a topological vector space over a nontrivially normed field is continuous if\n    its kernel is closed. -/\ntheorem linear_map.continuous_of_is_closed_ker (l : «expr →ₗ[ ] » E 𝕜 𝕜) (hl : is_closed (l.ker : set E)) :\n    continuous l :=\n  by\n  -- `l` is either constant or surjective. If it is constant, the result is trivial.\n  by_cases H : finrank 𝕜 l.range = 0\n  · rw [finrank_eq_zero, linear_map.range_eq_bot] at H\n    rw [H]\n    exact continuous_zero\n  · -- In the case where `l` is surjective, we factor it as `φ : (E ⧸ l.ker) ≃ₗ[𝕜] 𝕜`. Note that\n    -- `E ⧸ l.ker` is T2 since `l.ker` is closed.\n    have : finrank 𝕜 l.range = 1 := le_antisymm (finrank_self 𝕜 ▸ l.range.finrank_le) (zero_lt_iff.mpr H)\n    have hi : function.injective (l.ker.liftq l (le_refl _)) :=\n      by\n      rw [← linear_map.ker_eq_bot]\n      exact submodule.ker_liftq_eq_bot _ _ _ (le_refl _)\n    have hs : function.surjective (l.ker.liftq l (le_refl _)) :=\n      by\n      rw [← linear_map.range_eq_top, submodule.range_liftq]\n      exact eq_top_of_finrank_eq ((finrank_self 𝕜).symm ▸ this)\n    let φ : «expr ≃ₗ[ ] » («expr ⧸ » E l.ker) 𝕜 𝕜 := linear_equiv.of_bijective (l.ker.liftq l (le_refl _)) ⟨hi, hs⟩\n    have hlφ : (l : E → 𝕜) = φ ∘ l.ker.mkq := by ext <;> rfl\n    -- Since the quotient map `E →ₗ[𝕜] (E ⧸ l.ker)` is continuous, the continuity of `l` will follow\n    -- form the continuity of `φ`.\n    suffices continuous φ.to_equiv by\n      rw [hlφ]\n      exact this.comp continuous_quot_mk\n    -- The pullback by `φ.symm` of the quotient topology is a T2 topology on `𝕜`, because `φ.symm`\n    -- is injective. Since `φ.symm` is linear, it is also a vector space topology.\n    -- Hence, we know that it is equal to the topology induced by the norm.\n    have : induced φ.to_equiv.symm infer_instance = hnorm.to_uniform_space.to_topological_space :=\n      by\n      refine'\n        unique_topology_of_t2 (topological_add_group_induced φ.symm.to_linear_map)\n          (has_continuous_smul_induced φ.symm.to_linear_map) _\n      rw [t2_space_iff]\n      exact fun x y hxy =>\n        @separated_by_continuous _ _ (induced _ _) _ _ _ continuous_induced_dom _ _ (φ.to_equiv.symm.injective.ne hxy)\n    -- Finally, the pullback by `φ.symm` is exactly the pushforward by `φ`, so we have to prove\n    -- that `φ` is continuous when `𝕜` is endowed with the pushforward by `φ` of the quotient\n    -- topology, which is trivial by definition of the pushforward.\n    rw [this.symm, equiv.induced_symm]\n    exact continuous_coinduced_rng\n#align linear_map.continuous_of_is_closed_ker linear_map.continuous_of_is_closed_ker\n\n",
 "continuous_of_finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Any linear map on a finite dimensional space over a complete field is continuous. -/\ntheorem linear_map.continuous_of_finite_dimensional [t2_space E] [finite_dimensional 𝕜 E] (f : «expr →ₗ[ ] » E 𝕜 F') :\n    continuous f :=\n  by\n  -- for the proof, go to a model vector space `b → 𝕜` thanks to `continuous_equiv_fun_basis`, and\n  -- argue that all linear maps there are continuous.\n  let b := basis.of_vector_space 𝕜 E\n  have A : continuous b.equiv_fun := continuous_equiv_fun_basis_aux b\n  have B : continuous (f.comp (b.equiv_fun.symm : «expr →ₗ[ ] » (basis.of_vector_space_index 𝕜 E → 𝕜) 𝕜 E)) :=\n    linear_map.continuous_on_pi _\n  have :\n    continuous (f.comp (b.equiv_fun.symm : «expr →ₗ[ ] » (basis.of_vector_space_index 𝕜 E → 𝕜) 𝕜 E) ∘ b.equiv_fun) :=\n    B.comp A\n  convert this\n  ext x\n  dsimp\n  rw [basis.equiv_fun_symm_apply, basis.sum_repr]\n#align linear_map.continuous_of_finite_dimensional linear_map.continuous_of_finite_dimensional\n\n",
 "continuous_iff_is_closed_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Any linear form on a topological vector space over a nontrivially normed field is continuous if\n    and only if its kernel is closed. -/\ntheorem linear_map.continuous_iff_is_closed_ker (l : «expr →ₗ[ ] » E 𝕜 𝕜) : continuous l ↔ is_closed (l.ker : set E) :=\n  ⟨fun h => is_closed_singleton.preimage h, l.continuous_of_is_closed_ker⟩\n#align linear_map.continuous_iff_is_closed_ker linear_map.continuous_iff_is_closed_ker\n\n",
 "continuous_equiv_fun_basis_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- This version imposes `ι` and `E` to live in the same universe, so you should instead use\n`continuous_equiv_fun_basis` which gives the same result without universe restrictions. -/\nprivate theorem continuous_equiv_fun_basis_aux [ht2 : t2_space E] {ι : Type v} [fintype ι] (ξ : basis ι 𝕜 E) :\n    continuous ξ.equiv_fun :=\n  by\n  letI : uniform_space E := topological_add_group.to_uniform_space E\n  letI : uniform_add_group E := topological_add_comm_group_is_uniform\n  letI : separated_space E := separated_iff_t2.mpr ht2\n  induction' hn : fintype.card ι with n IH generalizing ι E\n  · rw [fintype.card_eq_zero_iff] at hn\n    exact continuous_of_const fun x y => funext hn.elim\n  · haveI : finite_dimensional 𝕜 E := of_fintype_basis ξ\n    -- first step: thanks to the induction hypothesis, any n-dimensional subspace is equivalent\n    -- to a standard space of dimension n, hence it is complete and therefore closed.\n    have H₁ : ∀ s : submodule 𝕜 E, finrank 𝕜 s = n → is_closed (s : set E) :=\n      by\n      intro s s_dim\n      letI : uniform_add_group s := s.to_add_subgroup.uniform_add_group\n      let b := basis.of_vector_space 𝕜 s\n      have U : uniform_embedding b.equiv_fun.symm.to_equiv :=\n        by\n        have : fintype.card (basis.of_vector_space_index 𝕜 s) = n :=\n          by\n          rw [← s_dim]\n          exact (finrank_eq_card_basis b).symm\n        have : continuous b.equiv_fun := IH b this\n        exact b.equiv_fun.symm.uniform_embedding b.equiv_fun.symm.to_linear_map.continuous_on_pi this\n      have : is_complete (s : set E) :=\n        complete_space_coe_iff_is_complete.1 ((complete_space_congr U).1 (by infer_instance))\n      exact this.is_closed\n    -- second step: any linear form is continuous, as its kernel is closed by the first step\n    have H₂ : ∀ f : «expr →ₗ[ ] » E 𝕜 𝕜, continuous f := by\n      intro f\n      by_cases H : finrank 𝕜 f.range = 0\n      · rw [finrank_eq_zero, linear_map.range_eq_bot] at H\n        rw [H]\n        exact continuous_zero\n      · have : finrank 𝕜 f.ker = n := by\n          have Z := f.finrank_range_add_finrank_ker\n          rw [finrank_eq_card_basis ξ, hn] at Z\n          have : finrank 𝕜 f.range = 1 := le_antisymm (finrank_self 𝕜 ▸ f.range.finrank_le) (zero_lt_iff.mpr H)\n          rw [this, add_comm, nat.add_one] at Z\n          exact nat.succ.inj Z\n        have : is_closed (f.ker : set E) := H₁ _ this\n        exact linear_map.continuous_of_is_closed_ker f this\n    rw [continuous_pi_iff]\n    intro i\n    change continuous (ξ.coord i)\n    exact H₂ (ξ.coord i)\n#align continuous_equiv_fun_basis_aux continuous_equiv_fun_basis_aux\n\n",
 "continuous_equiv_fun_basis":
 "/-- In finite dimensions over a non-discrete complete normed field, the canonical identification\n(in terms of a basis) with `𝕜^n` (endowed with the product topology) is continuous.\nThis is the key fact wich makes all linear maps from a T2 finite dimensional TVS over such a field\ncontinuous (see `linear_map.continuous_of_finite_dimensional`), which in turn implies that all\nnorms are equivalent in finite dimensions. -/\ntheorem continuous_equiv_fun_basis [t2_space E] {ι : Type _} [fintype ι] (ξ : basis ι 𝕜 E) : continuous ξ.equiv_fun :=\n  haveI : finite_dimensional 𝕜 E := of_fintype_basis ξ\n  ξ.equiv_fun.to_linear_map.continuous_of_finite_dimensional\n#align continuous_equiv_fun_basis continuous_equiv_fun_basis\n\n",
 "coe_to_continuous_linear_map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem coe_to_continuous_linear_map_symm :\n    «expr⇑ » (to_continuous_linear_map : «expr ≃ₗ[ ] » («expr →ₗ[ ] » E 𝕜 F') 𝕜 («expr →L[ ] » E 𝕜 F')).symm = coe :=\n  rfl\n#align coe_to_continuous_linear_map_symm coe_to_continuous_linear_map_symm\n\n",
 "coe_to_continuous_linear_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_to_continuous_linear_map' (f : «expr →ₗ[ ] » E 𝕜 F') : «expr⇑ » f.to_continuous_linear_map = f :=\n  rfl\n#align coe_to_continuous_linear_map' coe_to_continuous_linear_map'\n\n",
 "coe_to_continuous_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_to_continuous_linear_map (f : «expr →ₗ[ ] » E 𝕜 F') :\n    (f.to_continuous_linear_map : «expr →ₗ[ ] » E 𝕜 F') = f :=\n  rfl\n#align coe_to_continuous_linear_map coe_to_continuous_linear_map\n\n",
 "coe_to_continuous_linear_equiv_symm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem coe_to_continuous_linear_equiv_symm' (e : «expr ≃ₗ[ ] » E 𝕜 F) :\n    (e.to_continuous_linear_equiv.symm : F → E) = e.symm :=\n  rfl\n#align coe_to_continuous_linear_equiv_symm' coe_to_continuous_linear_equiv_symm'\n\n",
 "coe_to_continuous_linear_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_to_continuous_linear_equiv_symm (e : «expr ≃ₗ[ ] » E 𝕜 F) :\n    (e.to_continuous_linear_equiv.symm : «expr →ₗ[ ] » F 𝕜 E) = e.symm :=\n  rfl\n#align coe_to_continuous_linear_equiv_symm coe_to_continuous_linear_equiv_symm\n\n",
 "coe_to_continuous_linear_equiv_of_det_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem coe_to_continuous_linear_equiv_of_det_ne_zero (f : «expr →L[ ] » E 𝕜 E) (hf : f.det ≠ 0) :\n    (f.to_continuous_linear_equiv_of_det_ne_zero hf : «expr →L[ ] » E 𝕜 E) = f :=\n  by\n  ext x\n  rfl\n#align coe_to_continuous_linear_equiv_of_det_ne_zero coe_to_continuous_linear_equiv_of_det_ne_zero\n\n",
 "coe_to_continuous_linear_equiv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem coe_to_continuous_linear_equiv' (e : «expr ≃ₗ[ ] » E 𝕜 F) : (e.to_continuous_linear_equiv : E → F) = e :=\n  rfl\n#align coe_to_continuous_linear_equiv' coe_to_continuous_linear_equiv'\n\n",
 "coe_to_continuous_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_to_continuous_linear_equiv (e : «expr ≃ₗ[ ] » E 𝕜 F) :\n    (e.to_continuous_linear_equiv : «expr →ₗ[ ] » E 𝕜 F) = e :=\n  rfl\n#align coe_to_continuous_linear_equiv coe_to_continuous_linear_equiv\n\n"}