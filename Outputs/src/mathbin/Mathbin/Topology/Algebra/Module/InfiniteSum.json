{"tsum_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem continuous_linear_equiv.tsum_eq_iff [t2_space M] [t2_space M₂] {f : ι → M} (e : «expr ≃SL[ ] » M σ M₂)\n    {y : M₂} :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (e (f z)) = y ↔\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (f z) =\n        e.symm y :=\n  by\n  by_cases hf : summable f\n  ·\n    exact\n      ⟨fun h => (e.has_sum.mp ((e.summable.mpr hf).has_sum_iff.mpr h)).tsum_eq, fun h =>\n        (e.has_sum.mpr (hf.has_sum_iff.mpr h)).tsum_eq⟩\n  · have hf' : ¬summable fun z => e (f z) := fun h => hf (e.summable.mp h)\n    rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hf']\n    exact\n      ⟨by\n        rintro rfl\n        simp, fun H => by simpa using congr_arg (fun z => e z) H⟩\n#align continuous_linear_equiv.tsum_eq_iff continuous_linear_equiv.tsum_eq_iff\n\n",
 "summable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\nprotected theorem continuous_linear_equiv.summable {f : ι → M} (e : «expr ≃SL[ ] » M σ M₂) :\n    (summable fun b : ι => e (f b)) ↔ summable f :=\n  ⟨fun hf => (e.has_sum.1 hf.has_sum).summable, (e : «expr →SL[ ] » M σ M₂).summable⟩\n#align continuous_linear_equiv.summable continuous_linear_equiv.summable\n\n",
 "map_tsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\nprotected theorem continuous_linear_equiv.map_tsum [t2_space M] [t2_space M₂] {f : ι → M} (e : «expr ≃SL[ ] » M σ M₂) :\n    e («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (f z)) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (e (f z)) :=\n  by\n  refine' symm (e.tsum_eq_iff.mpr _)\n  rw [e.symm_apply_apply _]\n#align continuous_linear_equiv.map_tsum continuous_linear_equiv.map_tsum\n\n",
 "has_sum'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/-- Applying a continuous linear map commutes with taking an (infinite) sum. -/\nprotected theorem continuous_linear_equiv.has_sum' {f : ι → M} (e : «expr ≃SL[ ] » M σ M₂) {x : M} :\n    has_sum (fun b : ι => e (f b)) (e x) ↔ has_sum f x := by rw [e.has_sum, continuous_linear_equiv.symm_apply_apply]\n#align continuous_linear_equiv.has_sum' continuous_linear_equiv.has_sum'\n\n",
 "has_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/-- Applying a continuous linear map commutes with taking an (infinite) sum. -/\nprotected theorem continuous_linear_equiv.has_sum {f : ι → M} (e : «expr ≃SL[ ] » M σ M₂) {y : M₂} :\n    has_sum (fun b : ι => e (f b)) y ↔ has_sum f (e.symm y) :=\n  ⟨fun h => by simpa only [e.symm.coe_coe, e.symm_apply_apply] using h.mapL (e.symm : «expr →SL[ ] » M₂ σ' M), fun h =>\n    by simpa only [e.coe_coe, e.apply_symm_apply] using (e : «expr →SL[ ] » M σ M₂).has_sum h⟩\n#align continuous_linear_equiv.has_sum continuous_linear_equiv.has_sum\n\n"}