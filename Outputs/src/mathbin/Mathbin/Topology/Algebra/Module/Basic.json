{"zero_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem zero_comp (f : «expr →SL[ ] » M₁ σ₁₂ M₂) : (0 : «expr →SL[ ] » M₂ σ₂₃ M₃).comp f = 0 :=\n  by\n  ext\n  simp\n#align zero_comp zero_comp\n\n",
 "zero_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem zero_apply (x : M₁) : (0 : «expr →SL[ ] » M₁ σ₁₂ M₂) x = 0 :=\n  rfl\n#align zero_apply zero_apply\n\n",
 "units_equiv_aut_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n@[simp]\ntheorem units_equiv_aut_symm_apply (e : «expr ≃L[ ] » R R R) : ↑((unitsEquivAut R).symm e) = e 1 :=\n  rfl\n#align units_equiv_aut_symm_apply units_equiv_aut_symm_apply\n\n",
 "units_equiv_aut_apply_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[simp]\ntheorem units_equiv_aut_apply_symm (u : «expr ˣ» R) (x : R) : (unitsEquivAut R u).symm x = x * ↑u⁻¹ :=\n  rfl\n#align units_equiv_aut_apply_symm units_equiv_aut_apply_symm\n\n",
 "units_equiv_aut_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[simp]\ntheorem units_equiv_aut_apply (u : «expr ˣ» R) (x : R) : unitsEquivAut R u x = x * u :=\n  rfl\n#align units_equiv_aut_apply units_equiv_aut_apply\n\n",
 "units_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem units_equiv_apply (f : «expr ˣ» («expr →L[ ] » M R M)) (x : M) : unitsEquiv R M f x = f x :=\n  rfl\n#align units_equiv_apply units_equiv_apply\n\n",
 "uniform_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\n#print LinearEquiv.uniformEmbedding /-\nprotected theorem LinearEquiv.uniformEmbedding {E₁ E₂ : Type _} [UniformSpace E₁] [UniformSpace E₂] [AddCommGroup E₁]\n    [AddCommGroup E₂] [Module R₁ E₁] [Module R₂ E₂] [UniformAddGroup E₁] [UniformAddGroup E₂]\n    (e : «expr ≃ₛₗ[ ] » E₁ σ₁₂ E₂) (h₁ : Continuous e) (h₂ : Continuous e.symm) : UniformEmbedding e :=\n  ContinuousLinearEquiv.uniformEmbedding\n    ({ e with\n        continuous_to_fun := h₁\n        continuous_inv_fun := h₂ } :\n      «expr ≃SL[ ] » E₁ σ₁₂ E₂)\n#align linear_equiv.uniform_embedding LinearEquiv.uniformEmbedding\n-/\n\n",
 "trans_to_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n@[simp]\ntheorem trans_to_linear_equiv (e₁ : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (e₂ : «expr ≃SL[ ] » M₂ σ₂₃ M₃) :\n    (e₁.trans e₂).to_linear_equiv = e₁.to_linear_equiv.trans e₂.to_linear_equiv :=\n  by\n  ext\n  rfl\n#align trans_to_linear_equiv trans_to_linear_equiv\n\n",
 "trans_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n@[simp]\ntheorem trans_apply (e₁ : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (e₂ : «expr ≃SL[ ] » M₂ σ₂₃ M₃) (c : M₁) :\n    (e₁.trans e₂) c = e₂ (e₁ c) :=\n  rfl\n#align trans_apply trans_apply\n\n",
 "topological_closure_map_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print DenseRange.topologicalClosure_map_submodule /-\n/-- Under a dense continuous linear map, a submodule whose `topological_closure` is `⊤` is sent to\nanother such submodule.  That is, the image of a dense set under a map with dense range is dense.\n-/\ntheorem DenseRange.topologicalClosure_map_submodule [RingHomSurjective σ₁₂] [TopologicalSpace R₁] [TopologicalSpace R₂]\n    [ContinuousSMul R₁ M₁] [ContinuousAdd M₁] [ContinuousSMul R₂ M₂] [ContinuousAdd M₂] {f : «expr →SL[ ] » M₁ σ₁₂ M₂}\n    (hf' : DenseRange f) {s : Submodule R₁ M₁} (hs : s.topological_closure = «expr⊤») :\n    (s.map (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂)).topological_closure = «expr⊤» :=\n  by\n  rw [SetLike.ext'_iff] at hs⊢\n  simp only [Submodule.topologicalClosure_coe, Submodule.top_coe, ← dense_iff_closure_eq] at hs⊢\n  exact hf'.dense_image f.continuous hs\n#align dense_range.topological_closure_map_submodule DenseRange.topologicalClosure_map_submodule\n-/\n\n",
 "topological_closure_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n#print Submodule.topologicalClosure_map /-\n/-- Under a continuous linear map, the image of the `topological_closure` of a submodule is\ncontained in the `topological_closure` of its image. -/\ntheorem Submodule.topologicalClosure_map [RingHomSurjective σ₁₂] [TopologicalSpace R₁] [TopologicalSpace R₂]\n    [ContinuousSMul R₁ M₁] [ContinuousAdd M₁] [ContinuousSMul R₂ M₂] [ContinuousAdd M₂] (f : «expr →SL[ ] » M₁ σ₁₂ M₂)\n    (s : Submodule R₁ M₁) :\n    s.topological_closure.map (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) ≤\n      (s.map (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂)).topological_closure :=\n  image_closure_subset_closure_image f.continuous\n#align submodule.topological_closure_map Submodule.topologicalClosure_map\n-/\n\n",
 "topologicalClosure_mono":
 "#print Submodule.topologicalClosure_mono /-\ntheorem Submodule.topologicalClosure_mono {s : Submodule R M} {t : Submodule R M} (h : s ≤ t) :\n    s.topological_closure ≤ t.topological_closure :=\n  s.topological_closure_minimal (h.trans t.le_topological_closure) t.is_closed_topological_closure\n#align submodule.topological_closure_mono Submodule.topologicalClosure_mono\n-/\n\n",
 "topologicalClosure_minimal":
 "#print Submodule.topologicalClosure_minimal /-\ntheorem Submodule.topologicalClosure_minimal (s : Submodule R M) {t : Submodule R M} (h : s ≤ t)\n    (ht : IsClosed (t : Set M)) : s.topological_closure ≤ t :=\n  closure_minimal h ht\n#align submodule.topological_closure_minimal Submodule.topologicalClosure_minimal\n-/\n\n",
 "topologicalClosure_coe":
 "#print Submodule.topologicalClosure_coe /-\n@[simp]\ntheorem Submodule.topologicalClosure_coe (s : Submodule R M) : (s.topological_closure : Set M) = closure (s : Set M) :=\n  rfl\n#align submodule.topological_closure_coe Submodule.topologicalClosure_coe\n-/\n\n",
 "to_ring_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘L » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘L » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- The function `continuous_linear_equiv.inverse` can be written in terms of `ring.inverse` for the\nring of self-maps of the domain. -/\ntheorem to_ring_inverse (e : «expr ≃L[ ] » M R M₂) (f : «expr →L[ ] » M R M₂) :\n    inverse f = «expr ∘L » (Ring.inverse ((e.symm : «expr →L[ ] » M₂ R M).comp f)) ↑e.symm :=\n  by\n  by_cases h₁ : ∃ e' : «expr ≃L[ ] » M R M₂, ↑e' = f\n  · obtain ⟨e', he'⟩ := h₁\n    rw [← he']\n    change _ = «expr ∘L » (Ring.inverse ↑(e'.trans e.symm)) ↑e.symm\n    ext\n    simp\n  · suffices ¬IsUnit ((e.symm : «expr →L[ ] » M₂ R M).comp f) by simp [this, h₁]\n    contrapose! h₁\n    rcases h₁ with ⟨F, hF⟩\n    use (ContinuousLinearEquiv.unitsEquiv _ _ F).trans e\n    ext\n    dsimp\n    rw [coe_fn_coe_base' F, hF]\n    simp\n#align to_ring_inverse to_ring_inverse\n\n",
 "to_linear_map_eq_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n-- make the coercion the preferred form\n@[simp]\ntheorem to_linear_map_eq_coe (f : «expr →SL[ ] » M₁ σ₁₂ M₂) : f.to_linear_map = f :=\n  rfl\n#align to_linear_map_eq_coe to_linear_map_eq_coe\n\n",
 "to_linear_equiv_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\ntheorem to_linear_equiv_injective :\n    function.injective (to_linear_equiv : «expr ≃SL[ ] » M₁ σ₁₂ M₂ → «expr ≃ₛₗ[ ] » M₁ σ₁₂ M₂)\n  | ⟨e, _, _⟩, ⟨e', _, _⟩, rfl => rfl\n#align to_linear_equiv_injective to_linear_equiv_injective\n\n",
 "symm_trans_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n@[simp]\ntheorem symm_trans_apply (e₁ : «expr ≃SL[ ] » M₂ σ₂₁ M₁) (e₂ : «expr ≃SL[ ] » M₃ σ₃₂ M₂) (c : M₁) :\n    (e₂.trans e₁).symm c = e₂.symm (e₁.symm c) :=\n  rfl\n#align symm_trans_apply symm_trans_apply\n\n",
 "symm_to_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n@[simp]\ntheorem symm_to_linear_equiv (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) : e.symm.to_linear_equiv = e.to_linear_equiv.symm :=\n  by\n  ext\n  rfl\n#align symm_to_linear_equiv symm_to_linear_equiv\n\n",
 "symm_to_homeomorph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n@[simp]\ntheorem symm_to_homeomorph (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) : e.to_homeomorph.symm = e.symm.to_homeomorph :=\n  rfl\n#align symm_to_homeomorph symm_to_homeomorph\n\n",
 "symm_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\ntheorem symm_symm_apply (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (x : M₁) : e.symm.symm x = e x :=\n  rfl\n#align symm_symm_apply symm_symm_apply\n\n",
 "symm_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n@[simp]\ntheorem symm_symm (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) : e.symm.symm = e :=\n  by\n  ext x\n  rfl\n#align symm_symm symm_symm\n\n",
 "symm_preimage_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\nprotected theorem symm_preimage_preimage (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (s : Set M₂) :\n    «expr ⁻¹' » e.symm («expr ⁻¹' » e s) = s :=\n  e.to_linear_equiv.to_equiv.symm_preimage_preimage s\n#align symm_preimage_preimage symm_preimage_preimage\n\n",
 "symm_map_nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem symm_map_nhds_eq (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (x : M₁) : map e.symm ((nhds) (e x)) = (nhds) x :=\n  e.to_homeomorph.symm_map_nhds_eq x\n#align symm_map_nhds_eq symm_map_nhds_eq\n\n",
 "symm_image_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem symm_image_image (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (s : Set M₁) : «expr '' » e.symm («expr '' » e s) = s :=\n  e.to_linear_equiv.to_equiv.symm_image_image s\n#align symm_image_image symm_image_image\n\n",
 "symm_equiv_of_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem symm_equiv_of_inverse (f₁ : «expr →SL[ ] » M₁ σ₁₂ M₂) (f₂ h₁ h₂) :\n    (equivOfInverse f₁ f₂ h₁ h₂).symm = equivOfInverse f₂ f₁ h₂ h₁ :=\n  rfl\n#align symm_equiv_of_inverse symm_equiv_of_inverse\n\n",
 "symm_comp_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n@[simp]\ntheorem symm_comp_self (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) : (e.symm : M₂ → M₁) ∘ (e : M₁ → M₂) = id :=\n  by\n  ext x\n  exact symm_apply_apply e x\n#align symm_comp_self symm_comp_self\n\n",
 "symm_apply_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\ntheorem symm_apply_eq (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) {x y} : e.symm x = y ↔ x = e y :=\n  e.to_linear_equiv.symm_apply_eq\n#align symm_apply_eq symm_apply_eq\n\n",
 "symm_apply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n@[simp]\ntheorem symm_apply_apply (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (b : M₁) : e.symm (e b) = b :=\n  e.1.left_inv b\n#align symm_apply_apply symm_apply_apply\n\n",
 "surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\nprotected theorem surjective (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) : function.surjective e :=\n  e.to_linear_equiv.to_equiv.surjective\n#align surjective surjective\n\n",
 "sum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_apply {ι : Type _} (t : Finset ι) (f : ι → «expr →SL[ ] » M₁ σ₁₂ M₂) (b : M₁) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f d)) b =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f d b) :=\n  by simp only [coe_sum', Finset.sum_apply]\n#align sum_apply sum_apply\n\n",
 "subtypeL_apply":
 "#print Submodule.subtypeL_apply /-\n@[simp, norm_cast]\ntheorem Submodule.subtypeL_apply (p : Submodule R₁ M₁) (x : p) : p.subtypeL x = x :=\n  rfl\n#align submodule.subtypeL_apply Submodule.subtypeL_apply\n-/\n\n",
 "submodule_topologicalClosure_eq":
 "#print IsClosed.submodule_topologicalClosure_eq /-\n/-- The topological closure of a closed submodule `s` is equal to `s`. -/\ntheorem IsClosed.submodule_topologicalClosure_eq {s : Submodule R M} (hs : IsClosed (s : Set M)) :\n    s.topological_closure = s :=\n  le_antisymm (s.topological_closure_minimal rfl.le hs) s.le_topological_closure\n#align is_closed.submodule_topological_closure_eq IsClosed.submodule_topologicalClosure_eq\n-/\n\n",
 "sub_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem sub_comp [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] [TopologicalAddGroup M₃] (g₁ g₂ : «expr →SL[ ] » M₂ σ₂₃ M₃)\n    (f : «expr →SL[ ] » M σ₁₂ M₂) : (g₁ - g₂).comp f = g₁.comp f - g₂.comp f :=\n  by\n  ext\n  simp\n#align sub_comp sub_comp\n\n",
 "sub_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem sub_apply' (f g : «expr →SL[ ] » M σ₁₂ M₂) (x : M) : ((f : «expr →ₛₗ[ ] » M σ₁₂ M₂) - g) x = f x - g x :=\n  rfl\n#align sub_apply' sub_apply'\n\n",
 "sub_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem sub_apply (f g : «expr →SL[ ] » M σ₁₂ M₂) (x : M) : (f - g) x = f x - g x :=\n  rfl\n#align sub_apply sub_apply\n\n",
 "snd_equiv_of_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem snd_equiv_of_right_inverse (f₁ : «expr →L[ ] » M R M₂) (f₂ : «expr →L[ ] » M₂ R M)\n    (h : function.right_inverse f₂ f₁) (x : M) : ((equivOfRightInverse f₁ f₂ h x).2 : M) = x - f₂ (f₁ x) :=\n  rfl\n#align snd_equiv_of_right_inverse snd_equiv_of_right_inverse\n\n",
 "snd_comp_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem snd_comp_prod [Module R₁ M₂] [Module R₁ M₃] (f : «expr →L[ ] » M₁ R₁ M₂) (g : «expr →L[ ] » M₁ R₁ M₃) :\n    (snd R₁ M₂ M₃).comp (f.prod g) = g :=\n  ext fun x => rfl\n#align snd_comp_prod snd_comp_prod\n\n",
 "smul_right_one_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem smul_right_one_pow [TopologicalSpace R] [TopologicalRing R] (c : R) (n : ℕ) :\n    smulRight (1 : «expr →L[ ] » R R R) c ^ n = smulRight (1 : «expr →L[ ] » R R R) (c ^ n) :=\n  by\n  induction' n with n ihn\n  · ext\n    simp\n  · rw [pow_succ, ihn, mul_def, smul_right_comp, smul_eq_mul, pow_succ']\n#align smul_right_one_pow smul_right_one_pow\n\n",
 "smul_right_one_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem smul_right_one_one (c : «expr →L[ ] » R₁ R₁ M₂) : smulRight (1 : «expr →L[ ] » R₁ R₁ R₁) (c 1) = c := by\n  ext <;> simp [← ContinuousLinearMap.map_smul_of_tower]\n#align smul_right_one_one smul_right_one_one\n\n",
 "smul_right_one_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem smul_right_one_eq_iff {f f' : M₂} :\n    smulRight (1 : «expr →L[ ] » R₁ R₁ R₁) f = smulRight (1 : «expr →L[ ] » R₁ R₁ R₁) f' ↔ f = f' := by\n  simp only [ext_ring_iff, smul_right_apply, one_apply, one_smul]\n#align smul_right_one_eq_iff smul_right_one_eq_iff\n\n",
 "smul_right_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_right_comp [ContinuousMul R₁] {x : M₂} {c : R₁} :\n    (smulRight (1 : «expr →L[ ] » R₁ R₁ R₁) x).comp (smulRight (1 : «expr →L[ ] » R₁ R₁ R₁) c) =\n      smulRight (1 : «expr →L[ ] » R₁ R₁ R₁) («expr • » c x) :=\n  by\n  ext\n  simp [mul_smul]\n#align smul_right_comp smul_right_comp\n\n",
 "smul_right_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_right_apply {c : «expr →L[ ] » M₁ R S} {f : M₂} {x : M₁} :\n    (smulRight c f : M₁ → M₂) x = «expr • » (c x) f :=\n  rfl\n#align smul_right_apply smul_right_apply\n\n",
 "smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\nprotected theorem smul_def (f : «expr →L[ ] » M₁ R₁ M₁) (a : M₁) : «expr • » f a = f a :=\n  rfl\n#align smul_def smul_def\n\n",
 "smul_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- The M's are used for semilinear maps, and the N's for plain linear maps\n@[simp]\ntheorem smul_comp (c : S₃) (h : «expr →SL[ ] » M₂ σ₂₃ M₃) (f : «expr →SL[ ] » M σ₁₂ M₂) :\n    («expr • » c h).comp f = «expr • » c (h.comp f) :=\n  rfl\n#align smul_comp smul_comp\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_apply (c : S₂) (f : «expr →SL[ ] » M₁ σ₁₂ M₂) (x : M₁) : («expr • » c f) x = «expr • » c (f x) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "skew_prod_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem skew_prod_symm_apply (e : «expr ≃L[ ] » M R M₂) (e' : «expr ≃L[ ] » M₃ R M₄) (f : «expr →L[ ] » M R M₄) (x) :\n    (e.skew_prod e' f).symm x = (e.symm x.1, e'.symm (x.2 - f (e.symm x.1))) :=\n  rfl\n#align skew_prod_symm_apply skew_prod_symm_apply\n\n",
 "skew_prod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem skew_prod_apply (e : «expr ≃L[ ] » M R M₂) (e' : «expr ≃L[ ] » M₃ R M₄) (f : «expr →L[ ] » M R M₄) (x) :\n    e.skew_prod e' f x = (e x.1, e' x.2 + f x.1) :=\n  rfl\n#align skew_prod_apply skew_prod_apply\n\n",
 "self_comp_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n@[simp]\ntheorem self_comp_symm (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) : (e : M₁ → M₂) ∘ (e.symm : M₂ → M₁) = id :=\n  by\n  ext x\n  exact apply_symm_apply e x\n#align self_comp_symm self_comp_symm\n\n",
 "ring_inverse_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem ring_inverse_equiv (e : «expr ≃L[ ] » M R M) : Ring.inverse ↑e = inverse (e : «expr →L[ ] » M R M) :=\n  by\n  suffices Ring.inverse ((ContinuousLinearEquiv.unitsEquiv _ _).symm e : «expr →L[ ] » M R M) = inverse ↑e by\n    convert this\n  simp\n  rfl\n#align ring_inverse_equiv ring_inverse_equiv\n\n",
 "ring_inverse_eq_map_inverse":
 "theorem ring_inverse_eq_map_inverse : Ring.inverse = @inverse R M M _ _ _ _ _ _ _ :=\n  by\n  ext\n  simp [to_ring_inverse (ContinuousLinearEquiv.refl R M)]\n#align ring_inverse_eq_map_inverse ring_inverse_eq_map_inverse\n\n",
 "restrict_scalars_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem restrict_scalars_zero : (0 : «expr →L[ ] » M A M₂).restrict_scalars R = 0 :=\n  rfl\n#align restrict_scalars_zero restrict_scalars_zero\n\n",
 "restrict_scalars_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem restrict_scalars_smul (c : S) (f : «expr →L[ ] » M A M₂) :\n    («expr • » c f).restrict_scalars R = «expr • » c (f.restrict_scalars R) :=\n  rfl\n#align restrict_scalars_smul restrict_scalars_smul\n\n",
 "restrict_scalars_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem restrict_scalars_neg (f : «expr →L[ ] » M A M₂) : (-f).restrict_scalars R = -f.restrict_scalars R :=\n  rfl\n#align restrict_scalars_neg restrict_scalars_neg\n\n",
 "restrict_scalars_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem restrict_scalars_add (f g : «expr →L[ ] » M A M₂) :\n    (f + g).restrict_scalars R = f.restrict_scalars R + g.restrict_scalars R :=\n  rfl\n#align restrict_scalars_add restrict_scalars_add\n\n",
 "refl_symm":
 "@[simp]\ntheorem refl_symm : (ContinuousLinearEquiv.refl R₁ M₁).symm = ContinuousLinearEquiv.refl R₁ M₁ :=\n  rfl\n#align refl_symm refl_symm\n\n",
 "range_subtypeL":
 "#print Submodule.range_subtypeL /-\n@[simp]\ntheorem Submodule.range_subtypeL (p : Submodule R₁ M₁) : range p.subtypeL = p :=\n  Submodule.range_subtype _\n#align submodule.range_subtypeL Submodule.range_subtypeL\n-/\n\n",
 "range_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_prod_eq {f : «expr →L[ ] » M R M₂} {g : «expr →L[ ] » M R M₃} (h : «expr ⊔ » (ker f) (ker g) = «expr⊤») :\n    range (f.prod g) = (range f).prod (range g) :=\n  LinearMap.range_prod_eq h\n#align range_prod_eq range_prod_eq\n\n",
 "range_coprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem range_coprod [Module R₁ M₂] [Module R₁ M₃] [ContinuousAdd M₃] (f₁ : «expr →L[ ] » M₁ R₁ M₃)\n    (f₂ : «expr →L[ ] » M₂ R₁ M₃) : range (f₁.coprod f₂) = «expr ⊔ » (range f₁) (range f₂) :=\n  LinearMap.range_coprod _ _\n#align range_coprod range_coprod\n\n",
 "punctured_nhds_neBot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n#print Module.punctured_nhds_neBot /-\n/-- Let `R` be a topological ring such that zero is not an isolated point (e.g., a nontrivially\nnormed field, see `normed_field.punctured_nhds_ne_bot`). Let `M` be a nontrivial module over `R`\nsuch that `c • x = 0` implies `c = 0 ∨ x = 0`. Then `M` has no isolated points. We formulate this\nusing `ne_bot (𝓝[≠] x)`.\n\nThis lemma is not an instance because Lean would need to find `[has_continuous_smul ?m_1 M]` with\nunknown `?m_1`. We register this as an instance for `R = ℝ` in `real.punctured_nhds_module_ne_bot`.\nOne can also use `haveI := module.punctured_nhds_ne_bot R M` in a proof.\n-/\ntheorem Module.punctured_nhds_neBot [Nontrivial M] [NeBot (nhds_within.ne (0 : R))] [NoZeroSMulDivisors R M] (x : M) :\n    NeBot (nhds_within.ne x) := by\n  rcases exists_ne (0 : M) with ⟨y, hy⟩\n  suffices : tendsto (fun c : R => x + «expr • » c y) (nhds_within.ne 0) (nhds_within.ne x); exact this.ne_bot\n  refine' tendsto.inf _ (tendsto_principal_principal.2 <| _)\n  · convert tendsto_const_nhds.add ((@tendsto_id R _).smul_const y)\n    rw [zero_smul, add_zero]\n  · intro c hc\n    simpa [hy] using hc\n#align module.punctured_nhds_ne_bot Module.punctured_nhds_neBot\n-/\n\n",
 "proj_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem proj_pi (f : ∀ i, «expr →L[ ] » M₂ R (φ i)) (i : ι) : (proj i).comp (pi f) = f i :=\n  ext fun c => rfl\n#align proj_pi proj_pi\n\n",
 "proj_ker_of_right_inverse_comp_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem proj_ker_of_right_inverse_comp_inv [TopologicalAddGroup M] (f₁ : «expr →SL[ ] » M σ₁₂ M₂)\n    (f₂ : «expr →SL[ ] » M₂ σ₂₁ M) (h : function.right_inverse f₂ f₁) (y : M₂) :\n    f₁.proj_ker_of_right_inverse f₂ h (f₂ y) = 0 :=\n  Subtype.ext_iff_val.2 <| by simp [h y]\n#align proj_ker_of_right_inverse_comp_inv proj_ker_of_right_inverse_comp_inv\n\n",
 "proj_ker_of_right_inverse_apply_idem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem proj_ker_of_right_inverse_apply_idem [TopologicalAddGroup M] (f₁ : «expr →SL[ ] » M σ₁₂ M₂)\n    (f₂ : «expr →SL[ ] » M₂ σ₂₁ M) (h : function.right_inverse f₂ f₁) (x : LinearMap.ker f₁) :\n    f₁.proj_ker_of_right_inverse f₂ h x = x :=\n  Subtype.ext_iff_val.2 <| by simp\n#align proj_ker_of_right_inverse_apply_idem proj_ker_of_right_inverse_apply_idem\n\n",
 "proj_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem proj_apply (i : ι) (b : ∀ i, φ i) : (proj i : «expr →L[ ] » (∀ i, φ i) R (φ i)) b = b i :=\n  rfl\n#align proj_apply proj_apply\n\n",
 "prod_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\ntheorem prod_symm [Module R₁ M₂] [Module R₁ M₃] [Module R₁ M₄] (e : «expr ≃L[ ] » M₁ R₁ M₂)\n    (e' : «expr ≃L[ ] » M₃ R₁ M₄) : (e.prod e').symm = e.symm.prod e'.symm :=\n  rfl\n#align prod_symm prod_symm\n\n",
 "prod_ext_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n-- The M's are used for semilinear maps, and the N's for plain linear maps\ntheorem prod_ext_iff {f g : «expr →L[ ] » (M × N₂) R N₃} :\n    f = g ↔ f.comp (inl _ _ _) = g.comp (inl _ _ _) ∧ f.comp (inr _ _ _) = g.comp (inr _ _ _) :=\n  by\n  simp only [← coe_inj, LinearMap.prod_ext_iff]\n  rfl\n#align prod_ext_iff prod_ext_iff\n\n",
 "prod_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[ext]\ntheorem prod_ext {f g : «expr →L[ ] » (M × N₂) R N₃} (hl : f.comp (inl _ _ _) = g.comp (inl _ _ _))\n    (hr : f.comp (inr _ _ _) = g.comp (inr _ _ _)) : f = g :=\n  prod_ext_iff.2 ⟨hl, hr⟩\n#align prod_ext prod_ext\n\n",
 "prod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n@[simp, norm_cast]\ntheorem prod_apply [Module R₁ M₂] [Module R₁ M₃] [Module R₁ M₄] (e : «expr ≃L[ ] » M₁ R₁ M₂)\n    (e' : «expr ≃L[ ] » M₃ R₁ M₄) (x) : e.prod e' x = (e x.1, e' x.2) :=\n  rfl\n#align prod_apply prod_apply\n\n",
 "preimage_symm_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\nprotected theorem preimage_symm_preimage (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (s : Set M₁) :\n    «expr ⁻¹' » e («expr ⁻¹' » e.symm s) = s :=\n  e.symm.symm_preimage_preimage s\n#align preimage_symm_preimage preimage_symm_preimage\n\n",
 "preimage_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_closure (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (s : Set M₂) :\n    «expr ⁻¹' » e (closure s) = closure («expr ⁻¹' » e s) :=\n  e.to_homeomorph.preimage_closure s\n#align preimage_closure preimage_closure\n\n",
 "pi_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem pi_zero : pi (fun i => 0 : ∀ i, «expr →L[ ] » M R (φ i)) = 0 :=\n  ext fun _ => rfl\n#align pi_zero pi_zero\n\n",
 "pi_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem pi_eq_zero (f : ∀ i, «expr →L[ ] » M R (φ i)) : pi f = 0 ↔ ∀ i, f i = 0 :=\n  by\n  simp only [ext_iff, pi_apply, Function.funext_iff]\n  exact forall_swap\n#align pi_eq_zero pi_eq_zero\n\n",
 "pi_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem pi_comp (f : ∀ i, «expr →L[ ] » M R (φ i)) (g : «expr →L[ ] » M₂ R M) :\n    (pi f).comp g = pi fun i => (f i).comp g :=\n  rfl\n#align pi_comp pi_comp\n\n",
 "pi_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem pi_apply (f : ∀ i, «expr →L[ ] » M R (φ i)) (c : M) (i : ι) : pi f c i = f i c :=\n  rfl\n#align pi_apply pi_apply\n\n",
 "one_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem one_def : (1 : «expr →L[ ] » M₁ R₁ M₁) = id R₁ M₁ :=\n  rfl\n#align one_def one_def\n\n",
 "one_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem one_apply (x : M₁) : (1 : «expr →L[ ] » M₁ R₁ M₁) x = x :=\n  rfl\n#align one_apply one_apply\n\n",
 "of_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ContinuousSMul.of_nhds_zero /-\n/-\nCopyright (c) 2019 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jan-David Salchow, Sébastien Gouëzel, Jean Lo, Yury Kudryashov, Frédéric Dupuis,\n  Heather Macbeth\n-/\ntheorem ContinuousSMul.of_nhds_zero [TopologicalRing R] [TopologicalAddGroup M]\n    (hmul : Tendsto (fun p : R × M => «expr • » p.1 p.2) (filter.prod ((nhds) 0) ((nhds) 0)) ((nhds) 0))\n    (hmulleft : ∀ m : M, Tendsto (fun a : R => «expr • » a m) ((nhds) 0) ((nhds) 0))\n    (hmulright : ∀ a : R, Tendsto (fun m : M => «expr • » a m) ((nhds) 0) ((nhds) 0)) : ContinuousSMul R M :=\n  ⟨by\n    rw [continuous_iff_continuousAt]\n    rintro ⟨a₀, m₀⟩\n    have key :\n      ∀ p : R × M,\n        «expr • » p.1 p.2 =\n          «expr • » a₀ m₀ + («expr • » (p.1 - a₀) m₀ + «expr • » a₀ (p.2 - m₀) + «expr • » (p.1 - a₀) (p.2 - m₀)) :=\n      by\n      rintro ⟨a, m⟩\n      simp [sub_smul, smul_sub]\n      abel\n    rw [funext key]\n    clear key\n    refine' tendsto_const_nhds.add (tendsto.add (tendsto.add _ _) _)\n    · rw [sub_self, zero_smul]\n      apply (hmulleft m₀).comp\n      rw [show (fun p : R × M => p.1 - a₀) = (fun a => a - a₀) ∘ Prod.fst\n          by\n          ext\n          rfl,\n        nhds_prod_eq]\n      have : tendsto (fun a => a - a₀) ((nhds) a₀) ((nhds) 0) :=\n        by\n        rw [← sub_self a₀]\n        exact tendsto_id.sub tendsto_const_nhds\n      exact this.comp tendsto_fst\n    · rw [sub_self, smul_zero]\n      apply (hmulright a₀).comp\n      rw [show (fun p : R × M => p.2 - m₀) = (fun m => m - m₀) ∘ Prod.snd\n          by\n          ext\n          rfl,\n        nhds_prod_eq]\n      have : tendsto (fun m => m - m₀) ((nhds) m₀) ((nhds) 0) :=\n        by\n        rw [← sub_self m₀]\n        exact tendsto_id.sub tendsto_const_nhds\n      exact this.comp tendsto_snd\n    · rw [sub_self, zero_smul, nhds_prod_eq,\n        show\n          (fun p : R × M => «expr • » (p.fst - a₀) (p.snd - m₀)) =\n            (fun p : R × M => «expr • » p.1 p.2) ∘ prod.map (fun a => a - a₀) fun m => m - m₀\n          by\n          ext\n          rfl]\n      apply hmul.comp (tendsto.prod_map _ _) <;>\n        · rw [← sub_self]\n          exact tendsto_id.sub tendsto_const_nhds⟩\n#align has_continuous_smul.of_nhds_zero ContinuousSMul.of_nhds_zero\n-/\n\n",
 "neg_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem neg_comp [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] [TopologicalAddGroup M₃] (g : «expr →SL[ ] » M₂ σ₂₃ M₃)\n    (f : «expr →SL[ ] » M σ₁₂ M₂) : (-g).comp f = -g.comp f :=\n  by\n  ext\n  simp\n#align neg_comp neg_comp\n\n",
 "neg_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem neg_apply (f : «expr →SL[ ] » M σ₁₂ M₂) (x : M) : (-f) x = -f x :=\n  rfl\n#align neg_apply neg_apply\n\n",
 "mul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem mul_def (f g : «expr →L[ ] » M₁ R₁ M₁) : f * g = f.comp g :=\n  rfl\n#align mul_def mul_def\n\n",
 "mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem mul_apply (f g : «expr →L[ ] » M₁ R₁ M₁) (x : M₁) : (f * g) x = f (g x) :=\n  rfl\n#align mul_apply mul_apply\n\n",
 "map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n#print map_zero /-\n-- Make some straightforward lemmas available to `simp`.\n@[simp]\ntheorem map_zero (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) : e (0 : M₁) = 0 :=\n  (e : «expr →SL[ ] » M₁ σ₁₂ M₂).map_zero\n#align map_zero map_zero\n-/\n\n",
 "map_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print map_sum /-\nprotected theorem map_sum {ι : Type _} (f : «expr →SL[ ] » M₁ σ₁₂ M₂) (s : Finset ι) (g : ι → M₁) :\n    f (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (g i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f (g i)) :=\n  f.to_linear_map.map_sum\n#align map_sum map_sum\n-/\n\n",
 "map_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n#print map_sub /-\n@[simp]\ntheorem map_sub (e : «expr ≃SL[ ] » M σ₁₂ M₂) (x y : M) : e (x - y) = e x - e y :=\n  (e : «expr →SL[ ] » M σ₁₂ M₂).map_sub x y\n#align map_sub map_sub\n-/\n\n",
 "map_smulₛₗ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem map_smulₛₗ (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (c : R₁) (x : M₁) : e («expr • » c x) = «expr • » (σ₁₂ c) (e x) :=\n  (e : «expr →SL[ ] » M₁ σ₁₂ M₂).map_smulₛₗ c x\n#align map_smulₛₗ map_smulₛₗ\n\n",
 "map_smul_of_tower":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem map_smul_of_tower {R S : Type _} [Semiring S] [SMul R M₁] [Module S M₁] [SMul R M₂] [Module S M₂]\n    [LinearMap.CompatibleSMul M₁ M₂ R S] (f : «expr →L[ ] » M₁ S M₂) (c : R) (x : M₁) :\n    f («expr • » c x) = «expr • » c (f x) :=\n  linear_map.compatible_smul.map_smul f c x\n#align map_smul_of_tower map_smul_of_tower\n\n",
 "map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem map_smul [Module R₁ M₂] (e : «expr ≃L[ ] » M₁ R₁ M₂) (c : R₁) (x : M₁) :\n    e («expr • » c x) = «expr • » c (e x) :=\n  (e : «expr →L[ ] » M₁ R₁ M₂).map_smul c x\n#align map_smul map_smul\n\n",
 "map_nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem map_nhds_eq (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (x : M₁) : map e ((nhds) x) = (nhds) (e x) :=\n  e.to_homeomorph.map_nhds_eq x\n#align map_nhds_eq map_nhds_eq\n\n",
 "map_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n#print map_neg /-\n@[simp]\ntheorem map_neg (e : «expr ≃SL[ ] » M σ₁₂ M₂) (x : M) : e (-x) = -e x :=\n  (e : «expr →SL[ ] » M σ₁₂ M₂).map_neg x\n#align map_neg map_neg\n-/\n\n",
 "map_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n#print map_eq_zero_iff /-\n@[simp]\ntheorem map_eq_zero_iff (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) {x : M₁} : e x = 0 ↔ x = 0 :=\n  e.to_linear_equiv.map_eq_zero_iff\n#align map_eq_zero_iff map_eq_zero_iff\n-/\n\n",
 "map_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n#print map_add /-\n@[simp]\ntheorem map_add (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (x y : M₁) : e (x + y) = e x + e y :=\n  (e : «expr →SL[ ] » M₁ σ₁₂ M₂).map_add x y\n#align map_add map_add\n-/\n\n",
 "le_topologicalClosure":
 "#print Submodule.le_topologicalClosure /-\ntheorem Submodule.le_topologicalClosure (s : Submodule R M) : s ≤ s.topological_closure :=\n  subset_closure\n#align submodule.le_topological_closure Submodule.le_topologicalClosure\n-/\n\n",
 "ker_subtypeL":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Submodule.ker_subtypeL /-\n@[simp]\ntheorem Submodule.ker_subtypeL (p : Submodule R₁ M₁) : ker p.subtypeL = «expr⊥» :=\n  Submodule.ker_subtype _\n#align submodule.ker_subtypeL Submodule.ker_subtypeL\n-/\n\n",
 "ker_prod_ker_le_ker_coprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem ker_prod_ker_le_ker_coprod [ContinuousAdd M₃] (f : «expr →L[ ] » M R M₃) (g : «expr →L[ ] » M₂ R M₃) :\n    (LinearMap.ker f).prod (LinearMap.ker g) ≤ LinearMap.ker (f.coprod g) :=\n  LinearMap.ker_prod_ker_le_ker_coprod f.to_linear_map g.to_linear_map\n#align ker_prod_ker_le_ker_coprod ker_prod_ker_le_ker_coprod\n\n",
 "ker_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem ker_prod [Module R₁ M₂] [Module R₁ M₃] (f : «expr →L[ ] » M₁ R₁ M₂) (g : «expr →L[ ] » M₁ R₁ M₃) :\n    ker (f.prod g) = «expr ⊓ » (ker f) (ker g) :=\n  LinearMap.ker_prod f g\n#align ker_prod ker_prod\n\n",
 "ker_coprod_of_disjoint_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem ker_coprod_of_disjoint_range [ContinuousAdd M₃] (f : «expr →L[ ] » M R M₃) (g : «expr →L[ ] » M₂ R M₃)\n    (hd : Disjoint (range f) (range g)) : LinearMap.ker (f.coprod g) = (LinearMap.ker f).prod (LinearMap.ker g) :=\n  LinearMap.ker_coprod_of_disjoint_range f.to_linear_map g.to_linear_map hd\n#align ker_coprod_of_disjoint_range ker_coprod_of_disjoint_range\n\n",
 "ker_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem ker_cod_restrict (f : «expr →SL[ ] » M₁ σ₁₂ M₂) (p : Submodule R₂ M₂) (h : ∀ x, f x ∈ p) :\n    ker (f.cod_restrict p h) = ker f :=\n  (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂).ker_cod_restrict p h\n#align ker_cod_restrict ker_cod_restrict\n\n",
 "is_open_map_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- A nonzero continuous linear functional is open. -/\nprotected theorem is_open_map_of_ne_zero [TopologicalSpace R] [DivisionRing R] [ContinuousSub R] [AddCommGroup M]\n    [TopologicalSpace M] [ContinuousAdd M] [Module R M] [ContinuousSMul R M] (f : «expr →L[ ] » M R R) (hf : f ≠ 0) :\n    IsOpenMap f :=\n  let ⟨x, hx⟩ := exists_ne_zero hf\n  IsOpenMap.of_sections fun y =>\n    ⟨fun a => y + «expr • » (a - f y) («expr • » (f x)⁻¹ x), Continuous.continuousAt <| by continuity, by simp, fun a =>\n      by simp [hx]⟩\n#align is_open_map_of_ne_zero is_open_map_of_ne_zero\n\n",
 "is_open_map_mkq":
 "theorem is_open_map_mkq [TopologicalAddGroup M] : IsOpenMap S.mkq :=\n  QuotientAddGroup.isOpenMap_coe S.to_add_subgroup\n#align is_open_map_mkq is_open_map_mkq\n\n",
 "is_complete_ker":
 "theorem is_complete_ker {M' : Type _} [UniformSpace M'] [CompleteSpace M'] [AddCommMonoid M'] [Module R₁ M']\n    [T1Space M₂] [ContinuousSemilinearMapClass F σ₁₂ M' M₂] (f : F) : IsComplete (ker f : Set M') :=\n  (isClosed_ker f).is_complete\n#align is_complete_ker is_complete_ker\n\n",
 "is_closed_ker":
 "theorem is_closed_ker [T1Space M₂] [ContinuousSemilinearMapClass F σ₁₂ M₁ M₂] (f : F) : IsClosed (ker f : Set M₁) :=\n  continuous_iff_isClosed.1 (map_continuous f) _ isClosed_singleton\n#align is_closed_ker is_closed_ker\n\n",
 "is_closed_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem is_closed_image (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) {s : Set M₁} : IsClosed («expr '' » e s) ↔ IsClosed s :=\n  e.to_homeomorph.is_closed_image\n#align is_closed_image is_closed_image\n\n",
 "is_closed":
 "protected theorem closed_complemented.is_closed [TopologicalAddGroup M] [T1Space M] {p : Submodule R M}\n    (h : ClosedComplemented p) : IsClosed (p : Set M) :=\n  by\n  rcases h with ⟨f, hf⟩\n  have : ker (id R M - p.subtypeL.comp f) = p := LinearMap.ker_id_sub_eq_of_proj hf\n  exact this ▸ is_closed_ker _\n#align closed_complemented.is_closed closed_complemented.is_closed\n\n",
 "isClosed_topologicalClosure":
 "#print Submodule.isClosed_topologicalClosure /-\ntheorem Submodule.isClosed_topologicalClosure (s : Submodule R M) : IsClosed (s.topological_closure : Set M) := by\n  convert isClosed_closure\n#align submodule.is_closed_topological_closure Submodule.isClosed_topologicalClosure\n-/\n\n",
 "isClosed_setOf_map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- `σ`, `R` and `S` become metavariables, but they are all outparams so it's OK\n-- `σ'` becomes a metavariable, but it's OK since it's an outparam\ntheorem isClosed_setOf_map_smul : IsClosed { f : M₁ → M₂ | ∀ c x, f («expr • » c x) = «expr • » (σ c) (f x) } :=\n  by\n  simp only [Set.setOf_forall]\n  exact\n    isClosed_interᵢ fun c =>\n      isClosed_interᵢ fun x => isClosed_eq (continuous_apply _) ((continuous_apply _).const_smul _)\n#align is_closed_set_of_map_smul isClosed_setOf_map_smulₓ\n\n",
 "isClosed_range_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n#print LinearMap.isClosed_range_coe /-\ntheorem LinearMap.isClosed_range_coe : IsClosed (Set.range (coe_fn : «expr →ₛₗ[ ] » M₁ σ M₂ → M₁ → M₂)) :=\n  isClosed_of_closure_subset fun f hf => ⟨linearMapOfMemClosureRangeCoe f hf, rfl⟩\n#align linear_map.is_closed_range_coe LinearMap.isClosed_range_coe\n-/\n\n",
 "isClosed_or_dense_of_isCoatom":
 "#print Submodule.isClosed_or_dense_of_isCoatom /-\n/-- A maximal proper subspace of a topological module (i.e a `submodule` satisfying `is_coatom`)\nis either closed or dense. -/\ntheorem Submodule.isClosed_or_dense_of_isCoatom (s : Submodule R M) (hs : IsCoatom s) :\n    IsClosed (s : Set M) ∨ Dense (s : Set M) :=\n  (hs.le_iff.mp s.le_topological_closure).swap.imp (isClosed_of_closure_subset ∘ Eq.le)\n    Submodule.dense_iff_topologicalClosure_eq_top.mpr\n#align submodule.is_closed_or_dense_of_is_coatom Submodule.isClosed_or_dense_of_isCoatom\n-/\n\n",
 "inverse_non_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/-- By definition, if `f` is not invertible then `inverse f = 0`. -/\n@[simp]\ntheorem inverse_non_equiv (f : «expr →L[ ] » M R M₂) (h : ¬∃ e' : «expr ≃L[ ] » M R M₂, ↑e' = f) : inverse f = 0 :=\n  dif_neg h\n#align inverse_non_equiv inverse_non_equiv\n\n",
 "inverse_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- By definition, if `f` is invertible then `inverse f = f.symm`. -/\n@[simp]\ntheorem inverse_equiv (e : «expr ≃L[ ] » M R M₂) : inverse (e : «expr →L[ ] » M R M₂) = e.symm :=\n  by\n  have h : ∃ e' : «expr ≃L[ ] » M R M₂, (e' : «expr →L[ ] » M R M₂) = ↑e := ⟨e, rfl⟩\n  simp only [inverse, dif_pos h]\n  congr\n  exact_mod_cast Classical.choose_spec h\n#align inverse_equiv inverse_equiv\n\n",
 "inr_apply":
 "@[simp]\ntheorem inr_apply [Module R₁ M₂] (x : M₂) : inr R₁ M₁ M₂ x = (0, x) :=\n  rfl\n#align inr_apply inr_apply\n\n",
 "inl_apply":
 "@[simp]\ntheorem inl_apply [Module R₁ M₂] (x : M₁) : inl R₁ M₁ M₂ x = (x, 0) :=\n  rfl\n#align inl_apply inl_apply\n\n",
 "injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\nprotected theorem injective (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) : function.injective e :=\n  e.to_linear_equiv.to_equiv.injective\n#align injective injective\n\n",
 "infi_ker_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem infi_ker_proj :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (ker (proj i : «expr →L[ ] » (∀ i, φ i) R (φ i))) :\n        Submodule R (∀ i, φ i)) =\n      «expr⊥» :=\n  LinearMap.infᵢ_ker_proj\n#align infi_ker_proj infi_ker_proj\n\n",
 "image_symm_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem image_symm_image (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (s : Set M₂) : «expr '' » e («expr '' » e.symm s) = s :=\n  e.symm.symm_image_image s\n#align image_symm_image image_symm_image\n\n",
 "image_symm_eq_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem image_symm_eq_preimage (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (s : Set M₂) :\n    «expr '' » e.symm s = «expr ⁻¹' » e s := by rw [e.symm.image_eq_preimage, e.symm_symm]\n#align image_symm_eq_preimage image_symm_eq_preimage\n\n",
 "image_eq_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem image_eq_preimage (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (s : Set M₁) :\n    «expr '' » e s = «expr ⁻¹' » e.symm s :=\n  e.to_linear_equiv.to_equiv.image_eq_preimage s\n#align image_eq_preimage image_eq_preimage\n\n",
 "image_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_closure (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (s : Set M₁) :\n    «expr '' » e (closure s) = closure («expr '' » e s) :=\n  e.to_homeomorph.image_closure s\n#align image_closure image_closure\n\n",
 "id_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem id_comp (f : «expr →SL[ ] » M₁ σ₁₂ M₂) : (id R₂ M₂).comp f = f :=\n  ext fun x => rfl\n#align id_comp id_comp\n\n",
 "id_apply":
 "theorem id_apply (x : M₁) : id R₁ M₁ x = x :=\n  rfl\n#align id_apply id_apply\n\n",
 "has_closed_complement":
 "theorem closed_complemented.has_closed_complement {p : Submodule R M} [T1Space p] (h : ClosedComplemented p) :\n    ∃ (q : Submodule R M)(hq : IsClosed (q : Set M)), IsCompl p q :=\n  exists.elim h fun f hf => ⟨ker f, f.is_closed_ker, LinearMap.isCompl_of_proj hf⟩\n#align closed_complemented.has_closed_complement closed_complemented.has_closed_complement\n\n",
 "fst_prod_snd":
 "@[simp]\ntheorem fst_prod_snd [Module R₁ M₂] : (fst R₁ M₁ M₂).prod (snd R₁ M₁ M₂) = id R₁ (M₁ × M₂) :=\n  ext fun ⟨x, y⟩ => rfl\n#align fst_prod_snd fst_prod_snd\n\n",
 "fst_equiv_of_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem fst_equiv_of_right_inverse (f₁ : «expr →L[ ] » M R M₂) (f₂ : «expr →L[ ] » M₂ R M)\n    (h : function.right_inverse f₂ f₁) (x : M) : (equivOfRightInverse f₁ f₂ h x).1 = f₁ x :=\n  rfl\n#align fst_equiv_of_right_inverse fst_equiv_of_right_inverse\n\n",
 "fst_comp_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem fst_comp_prod [Module R₁ M₂] [Module R₁ M₃] (f : «expr →L[ ] » M₁ R₁ M₂) (g : «expr →L[ ] » M₁ R₁ M₃) :\n    (fst R₁ M₂ M₃).comp (f.prod g) = f :=\n  ext fun x => rfl\n#align fst_comp_prod fst_comp_prod\n\n",
 "ext₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/-- An extensionality lemma for `R ≃L[R] M`. -/\ntheorem ext₁ [TopologicalSpace R₁] {f g : «expr ≃L[ ] » R₁ R₁ M₁} (h : f 1 = g 1) : f = g :=\n  ext <| funext fun x => mul_one x ▸ by rw [← smul_eq_mul, map_smul, h, map_smul]\n#align ext₁ ext₁\n\n",
 "ext_ring_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem ext_ring_iff [TopologicalSpace R₁] {f g : «expr →L[ ] » R₁ R₁ M₁} : f = g ↔ f 1 = g 1 :=\n  ⟨fun h => h ▸ rfl, ext_ring⟩\n#align ext_ring_iff ext_ring_iff\n\n",
 "ext_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[ext]\ntheorem ext_ring [TopologicalSpace R₁] {f g : «expr →L[ ] » R₁ R₁ M₁} (h : f 1 = g 1) : f = g :=\n  coe_inj.1 <| LinearMap.ext_ring h\n#align ext_ring ext_ring\n\n",
 "ext_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/-- If the submodule generated by a set `s` is dense in the ambient module, then two continuous\nlinear maps equal on `s` are equal. -/\ntheorem ext_on [T2Space M₂] {s : Set M₁} (hs : Dense (Submodule.span R₁ s : Set M₁)) {f g : «expr →SL[ ] » M₁ σ₁₂ M₂}\n    (h : Set.EqOn f g s) : f = g :=\n  ext fun x => eqOn_closure_span h (hs x)\n#align ext_on ext_on\n\n",
 "ext_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem ext_iff {f g : «expr →SL[ ] » M₁ σ₁₂ M₂} : f = g ↔ ∀ x, f x = g x :=\n  FunLike.ext_iff\n#align ext_iff ext_iff\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n@[ext]\ntheorem ext {f g : «expr ≃SL[ ] » M₁ σ₁₂ M₂} (h : (f : M₁ → M₂) = g) : f = g :=\n  toLinearEquiv_injective <| LinearEquiv.ext <| congr_fun h\n#align ext ext\n\n",
 "exists_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem exists_ne_zero {f : «expr →SL[ ] » M₁ σ₁₂ M₂} (hf : f ≠ 0) : ∃ x, f x ≠ 0 :=\n  by\n  by_contra' h\n  exact hf (ContinuousLinearMap.ext h)\n#align exists_ne_zero exists_ne_zero\n\n",
 "equiv_of_right_inverse_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem equiv_of_right_inverse_symm_apply (f₁ : «expr →L[ ] » M R M₂) (f₂ : «expr →L[ ] » M₂ R M)\n    (h : function.right_inverse f₂ f₁) (y : M₂ × ker f₁) : (equivOfRightInverse f₁ f₂ h).symm y = f₂ y.1 + y.2 :=\n  rfl\n#align equiv_of_right_inverse_symm_apply equiv_of_right_inverse_symm_apply\n\n",
 "equiv_of_inverse_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem equiv_of_inverse_apply (f₁ : «expr →SL[ ] » M₁ σ₁₂ M₂) (f₂ h₁ h₂ x) : equivOfInverse f₁ f₂ h₁ h₂ x = f₁ x :=\n  rfl\n#align equiv_of_inverse_apply equiv_of_inverse_apply\n\n",
 "eq_top_of_nonempty_interior'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Submodule.eq_top_of_nonempty_interior' /-\n/-- If `M` is a topological module over `R` and `0` is a limit of invertible elements of `R`, then\n`⊤` is the only submodule of `M` with a nonempty interior.\nThis is the case, e.g., if `R` is a nontrivially normed field. -/\ntheorem Submodule.eq_top_of_nonempty_interior' [NeBot (nhds_within { x : R | IsUnit x } 0)] (s : Submodule R M)\n    (hs : (interior (s : Set M)).nonempty) : s = «expr⊤» :=\n  by\n  rcases hs with ⟨y, hy⟩\n  refine' Submodule.eq_top_iff'.2 fun x => _\n  rw [mem_interior_iff_mem_nhds] at hy\n  have :\n    tendsto (fun c : R => y + «expr • » c x) (nhds_within { x : R | IsUnit x } 0) ((nhds) (y + «expr • » (0 : R) x)) :=\n    tendsto_const_nhds.add ((tendsto_nhdsWithin_of_tendsto_nhds tendsto_id).smul tendsto_const_nhds)\n  rw [zero_smul, add_zero] at this\n  obtain ⟨_, hu : y + «expr • » _ _ ∈ s, u, rfl⟩ :=\n    nonempty_of_mem (inter_mem (mem_map.1 (this hy)) self_mem_nhdsWithin)\n  have hy' : y ∈ ↑s := mem_of_mem_nhds hy\n  rwa [s.add_mem_iff_right hy', ← Units.smul_def, s.smul_mem_iff' u] at hu\n#align submodule.eq_top_of_nonempty_interior' Submodule.eq_top_of_nonempty_interior'\n-/\n\n",
 "eq_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\ntheorem eq_symm_apply (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) {x y} : y = e.symm x ↔ e y = x :=\n  e.to_linear_equiv.eq_symm_apply\n#align eq_symm_apply eq_symm_apply\n\n",
 "eq_on_closure_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/-- If two continuous linear maps are equal on a set `s`, then they are equal on the closure\nof the `submodule.span` of this set. -/\ntheorem eq_on_closure_span [T2Space M₂] {s : Set M₁} {f g : «expr →SL[ ] » M₁ σ₁₂ M₂} (h : Set.EqOn f g s) :\n    Set.EqOn f g (closure (Submodule.span R₁ s : Set M₁)) :=\n  (LinearMap.eqOn_span' h).closure f.continuous g.continuous\n#align eq_on_closure_span eq_on_closure_span\n\n",
 "dense_iff_topologicalClosure_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Submodule.dense_iff_topologicalClosure_eq_top /-\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem Submodule.dense_iff_topologicalClosure_eq_top {s : Submodule R M} :\n    Dense (s : Set M) ↔ s.topological_closure = «expr⊤» :=\n  by\n  rw [← SetLike.coe_set_eq, dense_iff_closure_eq]\n  simp\n#align submodule.dense_iff_topological_closure_eq_top Submodule.dense_iff_topologicalClosure_eq_top\n-/\n\n",
 "default_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem default_def : (default : «expr →SL[ ] » M₁ σ₁₂ M₂) = 0 :=\n  rfl\n#align default_def default_def\n\n",
 "copy_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem copy_eq (f : «expr →SL[ ] » M₁ σ₁₂ M₂) (f' : M₁ → M₂) (h : f' = «expr⇑ » f) : f.copy f' h = f :=\n  FunLike.ext' h\n#align copy_eq copy_eq\n\n",
 "coprod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem coprod_apply [Module R₁ M₂] [Module R₁ M₃] [ContinuousAdd M₃] (f₁ : «expr →L[ ] » M₁ R₁ M₃)\n    (f₂ : «expr →L[ ] » M₂ R₁ M₃) (x) : f₁.coprod f₂ x = f₁ x.1 + f₂ x.2 :=\n  rfl\n#align coprod_apply coprod_apply\n\n",
 "continuous_on_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.continuous_on_pi /-\ntheorem LinearMap.continuous_on_pi {ι : Type _} {R : Type _} {M : Type _} [Finite ι] [Semiring R] [TopologicalSpace R]\n    [AddCommMonoid M] [Module R M] [TopologicalSpace M] [ContinuousAdd M] [ContinuousSMul R M]\n    (f : «expr →ₗ[ ] » (ι → R) R M) : Continuous f :=\n  by\n  cases nonempty_fintype ι\n  classical\n    -- for the proof, write `f` in the standard basis, and use that each coordinate is a continuous\n    -- function.\n    have :\n      (f : (ι → R) → M) = fun x =>\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          («expr • » (x i) (f fun j => if i = j then 1 else 0)) :=\n      by\n      ext x\n      exact f.pi_apply_eq_sum_univ x\n    rw [this]\n    refine' continuous_finset_sum _ fun i hi => _\n    exact (continuous_apply i).smul continuous_const\n#align linear_map.continuous_on_pi LinearMap.continuous_on_pi\n-/\n\n",
 "continuousSMul_induced":
 "#print continuousSMul_induced /-\ntheorem continuousSMul_induced : @ContinuousSMul R M₁ _ u (t.induced f) :=\n  {\n    continuous_smul := by\n      letI : TopologicalSpace M₁ := t.induced f\n      refine' continuous_induced_rng.2 _\n      simp_rw [Function.comp, f.map_smul]\n      refine' continuous_fst.smul (continuous_induced_dom.comp continuous_snd) }\n#align has_continuous_smul_induced continuousSMul_induced\n-/\n\n",
 "comp_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem comp_zero (g : «expr →SL[ ] » M₂ σ₂₃ M₃) : g.comp (0 : «expr →SL[ ] » M₁ σ₁₂ M₂) = 0 :=\n  by\n  ext\n  simp\n#align comp_zero comp_zero\n\n",
 "comp_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem comp_sub [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] [TopologicalAddGroup M₂] [TopologicalAddGroup M₃]\n    (g : «expr →SL[ ] » M₂ σ₂₃ M₃) (f₁ f₂ : «expr →SL[ ] » M σ₁₂ M₂) : g.comp (f₁ - f₂) = g.comp f₁ - g.comp f₂ :=\n  by\n  ext\n  simp\n#align comp_sub comp_sub\n\n",
 "comp_smulₛₗ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem comp_smulₛₗ [SMulCommClass R₂ R₂ M₂] [SMulCommClass R₃ R₃ M₃] [ContinuousConstSMul R₂ M₂]\n    [ContinuousConstSMul R₃ M₃] (h : «expr →SL[ ] » M₂ σ₂₃ M₃) (c : R₂) (f : «expr →SL[ ] » M σ₁₂ M₂) :\n    h.comp («expr • » c f) = «expr • » (σ₂₃ c) (h.comp f) :=\n  by\n  ext x\n  simp only [coe_smul', coe_comp', Function.comp_apply, Pi.smul_apply, ContinuousLinearMap.map_smulₛₗ]\n#align comp_smulₛₗ comp_smulₛₗ\n\n",
 "comp_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem comp_smul [LinearMap.CompatibleSMul N₂ N₃ S R] (hₗ : «expr →L[ ] » N₂ R N₃) (c : S)\n    (fₗ : «expr →L[ ] » M R N₂) : hₗ.comp («expr • » c fₗ) = «expr • » c (hₗ.comp fₗ) :=\n  by\n  ext x\n  exact hₗ.map_smul_of_tower c (fₗ x)\n#align comp_smul comp_smul\n\n",
 "comp_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem comp_neg [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] [TopologicalAddGroup M₂] [TopologicalAddGroup M₃]\n    (g : «expr →SL[ ] » M₂ σ₂₃ M₃) (f : «expr →SL[ ] » M σ₁₂ M₂) : g.comp (-f) = -g.comp f :=\n  by\n  ext\n  simp\n#align comp_neg comp_neg\n\n",
 "comp_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem comp_id (f : «expr →SL[ ] » M₁ σ₁₂ M₂) : f.comp (id R₁ M₁) = f :=\n  ext fun x => rfl\n#align comp_id comp_id\n\n",
 "comp_continuous_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\ntheorem comp_continuous_on_iff {α : Type _} [TopologicalSpace α] (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) {f : α → M₁}\n    {s : Set α} : ContinuousOn (e ∘ f) s ↔ ContinuousOn f s :=\n  e.to_homeomorph.comp_continuous_on_iff _ _\n#align comp_continuous_on_iff comp_continuous_on_iff\n\n",
 "comp_continuous_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\ntheorem comp_continuous_iff {α : Type _} [TopologicalSpace α] (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) {f : α → M₁} :\n    Continuous (e ∘ f) ↔ Continuous f :=\n  e.to_homeomorph.comp_continuous_iff\n#align comp_continuous_iff comp_continuous_iff\n\n",
 "comp_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp, norm_cast]\ntheorem comp_coe (f : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (f' : «expr ≃SL[ ] » M₂ σ₂₃ M₃) :\n    (f' : «expr →SL[ ] » M₂ σ₂₃ M₃).comp (f : «expr →SL[ ] » M₁ σ₁₂ M₂) = (f.trans f' : «expr →SL[ ] » M₁ σ₁₃ M₃) :=\n  rfl\n#align comp_coe comp_coe\n\n",
 "comp_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem comp_assoc {R₄ : Type _} [Semiring R₄] [Module R₄ M₄] {σ₁₄ : «expr →+* » R₁ R₄} {σ₂₄ : «expr →+* » R₂ R₄}\n    {σ₃₄ : «expr →+* » R₃ R₄} [RingHomCompTriple σ₁₃ σ₃₄ σ₁₄] [RingHomCompTriple σ₂₃ σ₃₄ σ₂₄]\n    [RingHomCompTriple σ₁₂ σ₂₄ σ₁₄] (h : «expr →SL[ ] » M₃ σ₃₄ M₄) (g : «expr →SL[ ] » M₂ σ₂₃ M₃)\n    (f : «expr →SL[ ] » M₁ σ₁₂ M₂) : (h.comp g).comp f = h.comp (g.comp f) :=\n  rfl\n#align comp_assoc comp_assoc\n\n",
 "comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem comp_apply (g : «expr →SL[ ] » M₂ σ₂₃ M₃) (f : «expr →SL[ ] » M₁ σ₁₂ M₂) (x : M₁) : (g.comp f) x = g (f x) :=\n  rfl\n#align comp_apply comp_apply\n\n",
 "comp_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem comp_add [ContinuousAdd M₂] [ContinuousAdd M₃] (g : «expr →SL[ ] » M₂ σ₂₃ M₃)\n    (f₁ f₂ : «expr →SL[ ] » M₁ σ₁₂ M₂) : g.comp (f₁ + f₂) = g.comp f₁ + g.comp f₂ :=\n  by\n  ext\n  simp\n#align comp_add comp_add\n\n",
 "coe_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- no simp attribute on the next line as simp does not always simplify `0 x` to `0`\nwhen `0` is the zero function, while it does for the zero continuous linear map,\nand this is the most important property we care about. -/\n@[norm_cast]\ntheorem coe_zero' : «expr⇑ » (0 : «expr →SL[ ] » M₁ σ₁₂ M₂) = 0 :=\n  rfl\n#align coe_zero' coe_zero'\n\n",
 "coe_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp, norm_cast]\ntheorem coe_zero : ((0 : «expr →SL[ ] » M₁ σ₁₂ M₂) : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_to_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_to_linear_equiv (f : «expr ≃SL[ ] » M₁ σ₁₂ M₂) : «expr⇑ » f.to_linear_equiv = f :=\n  rfl\n#align coe_to_linear_equiv coe_to_linear_equiv\n\n",
 "coe_to_homeomorph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_to_homeomorph (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) : «expr⇑ » e.to_homeomorph = e :=\n  rfl\n#align coe_to_homeomorph coe_to_homeomorph\n\n",
 "coe_symm_comp_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem coe_symm_comp_coe (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) :\n    (e.symm : «expr →SL[ ] » M₂ σ₂₁ M₁).comp (e : «expr →SL[ ] » M₁ σ₁₂ M₂) = ContinuousLinearMap.id R₁ M₁ :=\n  ContinuousLinearMap.ext e.symm_apply_apply\n#align coe_symm_comp_coe coe_symm_comp_coe\n\n",
 "coe_sum'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp, norm_cast]\ntheorem coe_sum' {ι : Type _} (t : Finset ι) (f : ι → «expr →SL[ ] » M₁ σ₁₂ M₂) :\n    «expr⇑ » (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f d)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f d) :=\n  by simp only [← coe_coe, coe_sum, LinearMap.coeFn_sum]\n#align coe_sum' coe_sum'\n\n",
 "coe_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp, norm_cast]\ntheorem coe_sum {ι : Type _} (t : Finset ι) (f : ι → «expr →SL[ ] » M₁ σ₁₂ M₂) :\n    ↑(finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f d)) =\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f d) :\n        «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) :=\n  (add_monoid_hom.mk (coe : «expr →SL[ ] » M₁ σ₁₂ M₂ → «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) rfl fun _ _ => rfl).map_sum _ _\n#align coe_sum coe_sum\n\n",
 "coe_subtypeL'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print Submodule.coe_subtypeL' /-\n@[simp]\ntheorem Submodule.coe_subtypeL' (p : Submodule R₁ M₁) : «expr⇑ » p.subtypeL = p.subtype :=\n  rfl\n#align submodule.coe_subtypeL' Submodule.coe_subtypeL'\n-/\n\n",
 "coe_subtypeL":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print Submodule.coe_subtypeL /-\n@[simp, norm_cast]\ntheorem Submodule.coe_subtypeL (p : Submodule R₁ M₁) : (p.subtypeL : «expr →ₗ[ ] » p R₁ M₁) = p.subtype :=\n  rfl\n#align submodule.coe_subtypeL Submodule.coe_subtypeL\n-/\n\n",
 "coe_sub'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_sub' (f g : «expr →SL[ ] » M σ₁₂ M₂) : «expr⇑ » (f - g) = f - g :=\n  rfl\n#align coe_sub' coe_sub'\n\n",
 "coe_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp, norm_cast]\ntheorem coe_sub (f g : «expr →SL[ ] » M σ₁₂ M₂) : (↑(f - g) : «expr →ₛₗ[ ] » M σ₁₂ M₂) = f - g :=\n  rfl\n#align coe_sub coe_sub\n\n",
 "coe_snd'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_snd' [Module R₁ M₂] : «expr⇑ » (snd R₁ M₁ M₂) = Prod.snd :=\n  rfl\n#align coe_snd' coe_snd'\n\n",
 "coe_snd":
 "@[simp, norm_cast]\ntheorem coe_snd [Module R₁ M₂] : ↑(snd R₁ M₁ M₂) = LinearMap.snd R₁ M₁ M₂ :=\n  rfl\n#align coe_snd coe_snd\n\n",
 "coe_smul_rightₗ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem coe_smul_rightₗ (c : «expr →L[ ] » M R S) :\n    «expr⇑ » (smulRightₗ c : «expr →ₗ[ ] » M₂ T («expr →L[ ] » M R M₂)) = c.smul_right :=\n  rfl\n#align coe_smul_rightₗ coe_smul_rightₗ\n\n",
 "coe_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, norm_cast]\ntheorem coe_smul' (c : S₂) (f : «expr →SL[ ] » M₁ σ₁₂ M₂) : «expr⇑ » («expr • » c f) = «expr • » c f :=\n  rfl\n#align coe_smul' coe_smul'\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, norm_cast]\ntheorem coe_smul (c : S₂) (f : «expr →SL[ ] » M₁ σ₁₂ M₂) :\n    (↑(«expr • » c f) : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) = «expr • » c f :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_restrict_scalarsₗ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_restrict_scalarsₗ : «expr⇑ » (restrictScalarsₗ A M M₂ R S) = restrictScalars R :=\n  rfl\n#align coe_restrict_scalarsₗ coe_restrict_scalarsₗ\n\n",
 "coe_restrict_scalars'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_restrict_scalars' (f : «expr →L[ ] » M A M₂) : «expr⇑ » (f.restrict_scalars R) = f :=\n  rfl\n#align coe_restrict_scalars' coe_restrict_scalars'\n\n",
 "coe_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp, norm_cast]\ntheorem coe_restrict_scalars (f : «expr →L[ ] » M A M₂) :\n    (f.restrict_scalars R : «expr →ₗ[ ] » M R M₂) = (f : «expr →ₗ[ ] » M A M₂).restrict_scalars R :=\n  rfl\n#align coe_restrict_scalars coe_restrict_scalars\n\n",
 "coe_refl'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_refl' : «expr⇑ » (ContinuousLinearEquiv.refl R₁ M₁) = id :=\n  rfl\n#align coe_refl' coe_refl'\n\n",
 "coe_refl":
 "@[simp, norm_cast]\ntheorem coe_refl : ↑(ContinuousLinearEquiv.refl R₁ M₁) = ContinuousLinearMap.id R₁ M₁ :=\n  rfl\n#align coe_refl coe_refl\n\n",
 "coe_proj_ker_of_right_inverse_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem coe_proj_ker_of_right_inverse_apply [TopologicalAddGroup M] (f₁ : «expr →SL[ ] » M σ₁₂ M₂)\n    (f₂ : «expr →SL[ ] » M₂ σ₂₁ M) (h : function.right_inverse f₂ f₁) (x : M) :\n    (f₁.proj_ker_of_right_inverse f₂ h x : M) = x - f₂ (f₁ x) :=\n  rfl\n#align coe_proj_ker_of_right_inverse_apply coe_proj_ker_of_right_inverse_apply\n\n",
 "coe_prod_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_prod_map' [Module R₁ M₂] [Module R₁ M₃] [Module R₁ M₄] (f₁ : «expr →L[ ] » M₁ R₁ M₂)\n    (f₂ : «expr →L[ ] » M₃ R₁ M₄) : «expr⇑ » (f₁.prod_map f₂) = prod.map f₁ f₂ :=\n  rfl\n#align coe_prod_map' coe_prod_map'\n\n",
 "coe_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp, norm_cast]\ntheorem coe_prod_map [Module R₁ M₂] [Module R₁ M₃] [Module R₁ M₄] (f₁ : «expr →L[ ] » M₁ R₁ M₂)\n    (f₂ : «expr →L[ ] » M₃ R₁ M₄) :\n    ↑(f₁.prod_map f₂) = (f₁ : «expr →ₗ[ ] » M₁ R₁ M₂).prod_map (f₂ : «expr →ₗ[ ] » M₃ R₁ M₄) :=\n  rfl\n#align coe_prod_map coe_prod_map\n\n",
 "coe_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp, norm_cast]\ntheorem coe_prod [Module R₁ M₂] [Module R₁ M₃] [Module R₁ M₄] (e : «expr ≃L[ ] » M₁ R₁ M₂)\n    (e' : «expr ≃L[ ] » M₃ R₁ M₄) :\n    (e.prod e' : «expr →L[ ] » (M₁ × M₃) R₁ (M₂ × M₄)) =\n      (e : «expr →L[ ] » M₁ R₁ M₂).prod_map (e' : «expr →L[ ] » M₃ R₁ M₄) :=\n  rfl\n#align coe_prod coe_prod\n\n",
 "coe_pi'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_pi' (f : ∀ i, «expr →L[ ] » M R (φ i)) : «expr⇑ » (pi f) = fun c i => f i c :=\n  rfl\n#align coe_pi' coe_pi'\n\n",
 "coe_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_pi (f : ∀ i, «expr →L[ ] » M R (φ i)) : (pi f : «expr →ₗ[ ] » M R (∀ i, φ i)) = LinearMap.pi fun i => f i :=\n  rfl\n#align coe_pi coe_pi\n\n",
 "coe_neg'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[norm_cast]\ntheorem coe_neg' (f : «expr →SL[ ] » M σ₁₂ M₂) : «expr⇑ » (-f) = -f :=\n  rfl\n#align coe_neg' coe_neg'\n\n",
 "coe_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp, norm_cast]\ntheorem coe_neg (f : «expr →SL[ ] » M σ₁₂ M₂) : (↑(-f) : «expr →ₛₗ[ ] » M σ₁₂ M₂) = -f :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_mul (f g : «expr →L[ ] » M₁ R₁ M₁) : «expr⇑ » (f * g) = f ∘ g :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem coe_mk' (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) (h) : (mk f h : M₁ → M₂) = f :=\n  rfl\n#align coe_mk' coe_mk'\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n-- see Note [function coercion]\n@[simp]\ntheorem coe_mk (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) (h) : (mk f h : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) = f :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "coe_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp, norm_cast]\ntheorem coe_inr [Module R₁ M₂] : (inr R₁ M₁ M₂ : «expr →ₗ[ ] » M₂ R₁ (M₁ × M₂)) = LinearMap.inr R₁ M₁ M₂ :=\n  rfl\n#align coe_inr coe_inr\n\n",
 "coe_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp, norm_cast]\ntheorem coe_inl [Module R₁ M₂] : (inl R₁ M₁ M₂ : «expr →ₗ[ ] » M₁ R₁ (M₁ × M₂)) = LinearMap.inl R₁ M₁ M₂ :=\n  rfl\n#align coe_inl coe_inl\n\n",
 "coe_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem coe_injective : function.injective (coe : «expr ≃SL[ ] » M₁ σ₁₂ M₂ → «expr →SL[ ] » M₁ σ₁₂ M₂) := fun e e' h =>\n  ext <| funext <| ContinuousLinearMap.ext_iff.1 h\n#align coe_injective coe_injective\n\n",
 "coe_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp, norm_cast]\ntheorem coe_inj {e e' : «expr ≃SL[ ] » M₁ σ₁₂ M₂} : (e : «expr →SL[ ] » M₁ σ₁₂ M₂) = e' ↔ e = e' :=\n  coe_injective.eq_iff\n#align coe_inj coe_inj\n\n",
 "coe_id'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_id' : «expr⇑ » (id R₁ M₁) = id :=\n  rfl\n#align coe_id' coe_id'\n\n",
 "coe_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp, norm_cast]\ntheorem coe_id : (id R₁ M₁ : «expr →ₗ[ ] » M₁ R₁ M₁) = LinearMap.id :=\n  rfl\n#align coe_id coe_id\n\n",
 "coe_fun_unique_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_fun_unique_symm : «expr⇑ » (funUnique ι R M).symm = Function.const ι :=\n  rfl\n#align coe_fun_unique_symm coe_fun_unique_symm\n\n",
 "coe_fun_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_fun_unique : «expr⇑ » (funUnique ι R M) = Function.eval default :=\n  rfl\n#align coe_fun_unique coe_fun_unique\n\n",
 "coe_fst'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_fst' [Module R₁ M₂] : «expr⇑ » (fst R₁ M₁ M₂) = Prod.fst :=\n  rfl\n#align coe_fst' coe_fst'\n\n",
 "coe_fst":
 "@[simp, norm_cast]\ntheorem coe_fst [Module R₁ M₂] : ↑(fst R₁ M₁ M₂) = LinearMap.fst R₁ M₁ M₂ :=\n  rfl\n#align coe_fst coe_fst\n\n",
 "coe_fn_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem coe_fn_injective : @function.injective («expr →SL[ ] » M₁ σ₁₂ M₂) (M₁ → M₂) coe_fn :=\n  FunLike.coe_injective\n#align coe_fn_injective coe_fn_injective\n\n",
 "coe_eq_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp, norm_cast]\ntheorem coe_eq_id {f : «expr →L[ ] » M₁ R₁ M₁} : (f : «expr →ₗ[ ] » M₁ R₁ M₁) = LinearMap.id ↔ f = id _ _ := by\n  rw [← coe_id, coe_inj]\n#align coe_eq_id coe_eq_id\n\n",
 "coe_def_rev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n-- see Note [function coercion]\n@[simp]\ntheorem coe_def_rev (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) : e.to_continuous_linear_map = e :=\n  rfl\n#align coe_def_rev coe_def_rev\n\n",
 "coe_copy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_copy (f : «expr →SL[ ] » M₁ σ₁₂ M₂) (f' : M₁ → M₂) (h : f' = «expr⇑ » f) : «expr⇑ » (f.copy f' h) = f' :=\n  rfl\n#align coe_copy coe_copy\n\n",
 "coe_coprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[norm_cast, simp]\ntheorem coe_coprod [Module R₁ M₂] [Module R₁ M₃] [ContinuousAdd M₃] (f₁ : «expr →L[ ] » M₁ R₁ M₃)\n    (f₂ : «expr →L[ ] » M₂ R₁ M₃) : (f₁.coprod f₂ : «expr →ₗ[ ] » (M₁ × M₂) R₁ M₃) = LinearMap.coprod f₁ f₂ :=\n  rfl\n#align coe_coprod coe_coprod\n\n",
 "coe_comp_coe_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem coe_comp_coe_symm (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) :\n    (e : «expr →SL[ ] » M₁ σ₁₂ M₂).comp (e.symm : «expr →SL[ ] » M₂ σ₂₁ M₁) = ContinuousLinearMap.id R₂ M₂ :=\n  ContinuousLinearMap.ext e.apply_symm_apply\n#align coe_comp_coe_symm coe_comp_coe_symm\n\n",
 "coe_comp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_comp' (h : «expr →SL[ ] » M₂ σ₂₃ M₃) (f : «expr →SL[ ] » M₁ σ₁₂ M₂) : «expr⇑ » (h.comp f) = h ∘ f :=\n  rfl\n#align coe_comp' coe_comp'\n\n",
 "coe_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp, norm_cast]\ntheorem coe_comp (h : «expr →SL[ ] » M₂ σ₂₃ M₃) (f : «expr →SL[ ] » M₁ σ₁₂ M₂) :\n    (h.comp f : «expr →ₛₗ[ ] » M₁ σ₁₃ M₃) = (h : «expr →ₛₗ[ ] » M₂ σ₂₃ M₃).comp (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) :=\n  rfl\n#align coe_comp coe_comp\n\n",
 "coe_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp, norm_cast]\ntheorem coe_coe (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) : «expr⇑ » (e : «expr →SL[ ] » M₁ σ₁₂ M₂) = e :=\n  rfl\n#align coe_coe coe_coe\n\n",
 "coe_cod_restrict_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem coe_cod_restrict_apply (f : «expr →SL[ ] » M₁ σ₁₂ M₂) (p : Submodule R₂ M₂) (h : ∀ x, f x ∈ p) (x) :\n    (f.cod_restrict p h x : M₂) = f x :=\n  rfl\n#align coe_cod_restrict_apply coe_cod_restrict_apply\n\n",
 "coe_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[norm_cast]\ntheorem coe_cod_restrict (f : «expr →SL[ ] » M₁ σ₁₂ M₂) (p : Submodule R₂ M₂) (h : ∀ x, f x ∈ p) :\n    (f.cod_restrict p h : «expr →ₛₗ[ ] » M₁ σ₁₂ p) = (f : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂).cod_restrict p h :=\n  rfl\n#align coe_cod_restrict coe_cod_restrict\n\n",
 "coe_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\ntheorem coe_apply (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (b : M₁) : (e : «expr →SL[ ] » M₁ σ₁₂ M₂) b = e b :=\n  rfl\n#align coe_apply coe_apply\n\n",
 "coe_add'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[norm_cast]\ntheorem coe_add' (f g : «expr →SL[ ] » M₁ σ₁₂ M₂) : «expr⇑ » (f + g) = f + g :=\n  rfl\n#align coe_add' coe_add'\n\n",
 "coe_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp, norm_cast]\ntheorem coe_add (f g : «expr →SL[ ] » M₁ σ₁₂ M₂) : (↑(f + g) : «expr →ₛₗ[ ] » M₁ σ₁₂ M₂) = f + g :=\n  rfl\n#align coe_add coe_add\n\n",
 "closure_smul_self_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem submodule.closure_smul_self_subset (s : Submodule R M) :\n    «expr '' » (fun p : R × M => «expr • » p.1 p.2) (lower_set.prod Set.univ (closure s)) ⊆ closure s :=\n  calc\n    «expr '' » (fun p : R × M => «expr • » p.1 p.2) (lower_set.prod Set.univ (closure s)) =\n        «expr '' » (fun p : R × M => «expr • » p.1 p.2) (closure (lower_set.prod Set.univ s)) :=\n      by simp [closure_prod_eq]\n    _ ⊆ closure («expr '' » (fun p : R × M => «expr • » p.1 p.2) (lower_set.prod Set.univ s)) :=\n      (image_closure_subset_closure_image continuous_smul)\n    _ = closure s := by\n      congr\n      ext x\n      refine' ⟨_, fun hx => ⟨⟨1, x⟩, ⟨Set.mem_univ _, hx⟩, one_smul R _⟩⟩\n      rintro ⟨⟨c, y⟩, ⟨hc, hy⟩, rfl⟩\n      simp [s.smul_mem c hy]\n    \n#align submodule.closure_smul_self_subset submodule.closure_smul_self_subset\n\n",
 "closure_smul_self_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem submodule.closure_smul_self_eq (s : Submodule R M) :\n    «expr '' » (fun p : R × M => «expr • » p.1 p.2) (lower_set.prod Set.univ (closure s)) = closure s :=\n  s.closure_smul_self_subset.antisymm fun x hx => ⟨⟨1, x⟩, ⟨Set.mem_univ _, hx⟩, one_smul R _⟩\n#align submodule.closure_smul_self_eq submodule.closure_smul_self_eq\n\n",
 "closed_complemented_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem closed_complemented_top : ClosedComplemented («expr⊤» : Submodule R M) :=\n  ⟨(id R M).cod_restrict («expr⊤») fun x => trivial, fun x => Subtype.ext_iff_val.2 <| by simp⟩\n#align closed_complemented_top closed_complemented_top\n\n",
 "closed_complemented_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem closed_complemented_bot : ClosedComplemented («expr⊥» : Submodule R M) :=\n  ⟨0, fun x => by simp only [zero_apply, eq_zero_of_bot_submodule x]⟩\n#align closed_complemented_bot closed_complemented_bot\n\n",
 "closedComplemented_ker_of_rightInverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n#print ContinuousLinearMap.closedComplemented_ker_of_rightInverse /-\ntheorem ContinuousLinearMap.closedComplemented_ker_of_rightInverse {R : Type _} [Ring R] {M : Type _}\n    [TopologicalSpace M] [AddCommGroup M] {M₂ : Type _} [TopologicalSpace M₂] [AddCommGroup M₂] [Module R M]\n    [Module R M₂] [TopologicalAddGroup M] (f₁ : «expr →L[ ] » M R M₂) (f₂ : «expr →L[ ] » M₂ R M)\n    (h : function.right_inverse f₂ f₁) : (ker f₁).closed_complemented :=\n  ⟨f₁.proj_ker_of_right_inverse f₂ h, f₁.proj_ker_of_right_inverse_apply_idem f₂ h⟩\n#align continuous_linear_map.closed_complemented_ker_of_right_inverse ContinuousLinearMap.closedComplemented_ker_of_rightInverse\n-/\n\n",
 "bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\nprotected theorem bijective (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) : function.bijective e :=\n  e.to_linear_equiv.to_equiv.bijective\n#align bijective bijective\n\n",
 "apply_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n@[simp]\ntheorem apply_symm_apply (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) (c : M₂) : e (e.symm c) = c :=\n  e.1.right_inv c\n#align apply_symm_apply apply_symm_apply\n\n",
 "add_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem add_comp [ContinuousAdd M₃] (g₁ g₂ : «expr →SL[ ] » M₂ σ₂₃ M₃) (f : «expr →SL[ ] » M₁ σ₁₂ M₂) :\n    (g₁ + g₂).comp f = g₁.comp f + g₂.comp f := by\n  ext\n  simp\n#align add_comp add_comp\n\n",
 "add_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n@[simp]\ntheorem add_apply (f g : «expr →SL[ ] » M₁ σ₁₂ M₂) (x : M₁) : (f + g) x = f x + g x :=\n  rfl\n#align add_apply add_apply\n\n",
 "UniformEmbedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n#print UniformEmbedding /-\nprotected theorem UniformEmbedding {E₁ E₂ : Type _} [UniformSpace E₁] [UniformSpace E₂] [AddCommGroup E₁]\n    [AddCommGroup E₂] [Module R₁ E₁] [Module R₂ E₂] [UniformAddGroup E₁] [UniformAddGroup E₂]\n    (e : «expr ≃SL[ ] » E₁ σ₁₂ E₂) : UniformEmbedding e :=\n  e.to_linear_equiv.to_equiv.uniform_embedding e.to_continuous_linear_map.uniform_continuous\n    e.symm.to_continuous_linear_map.uniform_continuous\n#align uniform_embedding UniformEmbedding\n-/\n\n",
 "UniformContinuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →SL[ ] » -/\n#print UniformContinuous /-\nprotected theorem UniformContinuous {E₁ E₂ : Type _} [UniformSpace E₁] [UniformSpace E₂] [AddCommGroup E₁]\n    [AddCommGroup E₂] [Module R₁ E₁] [Module R₂ E₂] [UniformAddGroup E₁] [UniformAddGroup E₂]\n    (f : «expr →SL[ ] » E₁ σ₁₂ E₂) : UniformContinuous f :=\n  uniformContinuous_addMonoidHom_of_continuous f.continuous\n#align uniform_continuous UniformContinuous\n-/\n\n",
 "ContinuousWithinAt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n#print ContinuousWithinAt /-\nprotected theorem ContinuousWithinAt (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) {s : Set M₁} {x : M₁} :\n    ContinuousWithinAt (e : M₁ → M₂) s x :=\n  e.continuous.continuous_within_at\n#align continuous_within_at ContinuousWithinAt\n-/\n\n",
 "ContinuousOn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n#print ContinuousOn /-\nprotected theorem ContinuousOn (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) {s : Set M₁} : ContinuousOn (e : M₁ → M₂) s :=\n  e.continuous.continuous_on\n#align continuous_on ContinuousOn\n-/\n\n",
 "ContinuousAt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n#print ContinuousAt /-\nprotected theorem ContinuousAt (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) {x : M₁} : ContinuousAt (e : M₁ → M₂) x :=\n  e.continuous.continuous_at\n#align continuous_at ContinuousAt\n-/\n\n",
 "Continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃SL[ ] » -/\n#print Continuous /-\n@[continuity]\nprotected theorem Continuous (e : «expr ≃SL[ ] » M₁ σ₁₂ M₂) : Continuous (e : M₁ → M₂) :=\n  e.continuous_to_fun\n#align continuous Continuous\n-/\n\n"}