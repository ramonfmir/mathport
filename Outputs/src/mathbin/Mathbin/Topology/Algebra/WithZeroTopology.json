{"tendsto_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (γ₀ «expr ≠ » 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_zero :\n    Tendsto f l ((nhds) (0 : Γ₀)) ↔\n      ∀ (γ₀) (_ : γ₀ ≠ 0),\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n          (f x < γ₀) :=\n  by simp [nhds_zero]\n#align tendsto_zero tendsto_zero\n\n",
 "tendsto_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_units {γ₀ : «expr ˣ» Γ₀} :\n    Tendsto f l ((nhds) (γ₀ : Γ₀)) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (f x = γ₀) :=\n  tendsto_of_ne_zero γ₀.ne_zero\n#align tendsto_units tendsto_units\n\n",
 "tendsto_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_of_ne_zero {γ : Γ₀} (h : γ ≠ 0) :\n    Tendsto f l ((nhds) γ) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (f x = γ) :=\n  by rw [nhds_of_ne_zero h, tendsto_pure]\n#align tendsto_of_ne_zero tendsto_of_ne_zero\n\n",
 "singleton_mem_nhds_of_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `γ` is an invertible element of a linearly ordered group with zero element adjoined, then\n`{γ}` is a neighbourhood of `γ`. -/\ntheorem singleton_mem_nhds_of_units (γ : «expr ˣ» Γ₀) : ({γ} : Set Γ₀) ∈ (nhds) (γ : Γ₀) := by simp\n#align singleton_mem_nhds_of_units singleton_mem_nhds_of_units\n\n",
 "singleton_mem_nhds_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `γ` is a nonzero element of a linearly ordered group with zero element adjoined, then `{γ}`\nis a neighbourhood of `γ`. -/\ntheorem singleton_mem_nhds_of_ne_zero (h : γ ≠ 0) : ({γ} : Set Γ₀) ∈ (nhds) (γ : Γ₀) := by simp [h]\n#align singleton_mem_nhds_of_ne_zero singleton_mem_nhds_of_ne_zero\n\n",
 "nhds_zero_of_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `γ` is an invertible element of a linearly ordered group with zero element adjoined, then\n`Iio (γ : Γ₀)` is a neighbourhood of `0`. -/\ntheorem nhds_zero_of_units (γ : «expr ˣ» Γ₀) : Iio ↑γ ∈ (nhds) (0 : Γ₀) :=\n  Iio_mem_nhds_zero γ.ne_zero\n#align nhds_zero_of_units nhds_zero_of_units\n\n",
 "nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_zero :\n    (nhds) (0 : Γ₀) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (Iio γ)) :=\n  by rw [nhds_eq_update, update_same]\n#align nhds_zero nhds_zero\n\n",
 "nhds_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The neighbourhood filter of a nonzero element consists of all sets containing that\nelement. -/\n@[simp]\ntheorem nhds_of_ne_zero {γ : Γ₀} (h₀ : γ ≠ 0) : (nhds) γ = pure γ := by rw [nhds_eq_update, update_noteq h₀]\n#align nhds_of_ne_zero nhds_of_ne_zero\n\n",
 "nhds_eq_update":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/-\nCopyright (c) 2021 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot\n-/\ntheorem nhds_eq_update :\n    (nhds : Γ₀ → Filter Γ₀) =\n      update pure 0\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          ((filter.principal) (Iio γ))) :=\n  funext <| nhds_mkOfNhds_single <| le_infᵢ₂ fun γ h₀ => le_principal_iff.2 <| zero_lt_iff.2 h₀\n#align nhds_eq_update nhds_eq_update\n\n",
 "nhds_coe_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The neighbourhood filter of an invertible element consists of all sets containing that\nelement. -/\ntheorem nhds_coe_units (γ : «expr ˣ» Γ₀) : (nhds) (γ : Γ₀) = pure (γ : Γ₀) :=\n  nhds_of_ne_zero γ.ne_zero\n#align nhds_coe_units nhds_coe_units\n\n",
 "is_open_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (γ «expr ≠ » 0) -/\ntheorem is_open_iff {s : Set Γ₀} : IsOpen s ↔ (0 : Γ₀) ∉ s ∨ ∃ (γ : _)(_ : γ ≠ 0), Iio γ ⊆ s :=\n  by\n  rw [isOpen_iff_mem_nhds, ← and_forall_ne (0 : Γ₀)]\n  simp (config := { contextual := true }) [nhds_of_ne_zero, imp_iff_not_or, has_basis_nhds_zero.mem_iff]\n#align is_open_iff is_open_iff\n\n",
 "is_closed_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (γ «expr ≠ » 0) -/\ntheorem is_closed_iff {s : Set Γ₀} : IsClosed s ↔ (0 : Γ₀) ∈ s ∨ ∃ (γ : _)(_ : γ ≠ 0), s ⊆ Ici γ := by\n  simp only [← isOpen_compl_iff, is_open_iff, mem_compl_iff, Classical.not_not, ← compl_Ici, compl_subset_compl]\n#align is_closed_iff is_closed_iff\n\n",
 "isOpen_Iio":
 "#print isOpen_Iio /-\ntheorem isOpen_Iio {a : Γ₀} : IsOpen (Iio a) :=\n  isOpen_iff.mpr <| imp_iff_not_or.mp fun ha => ⟨a, ne_of_gt ha, Subset.rfl⟩\n#align is_open_Iio isOpen_Iio\n-/\n\n",
 "has_basis_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a linearly ordered group with zero element adjoined, `U` is a neighbourhood of `0` if and\nonly if there exists a nonzero element `γ₀` such that `Iio γ₀ ⊆ U`. -/\ntheorem has_basis_nhds_zero : ((nhds) (0 : Γ₀)).has_basis (fun γ : Γ₀ => γ ≠ 0) Iio :=\n  by\n  rw [nhds_zero]\n  refine' has_basis_binfi_principal _ ⟨1, one_ne_zero⟩\n  exact directedOn_iff_directed.2 (directed_of_inf fun a b hab => Iio_subset_Iio hab)\n#align has_basis_nhds_zero has_basis_nhds_zero\n\n",
 "has_basis_nhds_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_basis_nhds_units (γ : «expr ˣ» Γ₀) : HasBasis ((nhds) (γ : Γ₀)) (fun i : Unit => True) fun i => {γ} :=\n  hasBasis_nhds_of_ne_zero γ.ne_zero\n#align has_basis_nhds_units has_basis_nhds_units\n\n",
 "has_basis_nhds_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_basis_nhds_of_ne_zero {x : Γ₀} (h : x ≠ 0) : HasBasis ((nhds) x) (fun i : Unit => True) fun i => {x} :=\n  by\n  rw [nhds_of_ne_zero h]\n  exact has_basis_pure _\n#align has_basis_nhds_of_ne_zero has_basis_nhds_of_ne_zero\n\n",
 "T3Space":
 "#print T3Space /-\n/-- The topology on a linearly ordered group with zero element adjoined is T₃. -/\ntheorem T3Space : T3Space Γ₀ :=\n  {\n    to_regular_space :=\n      RegularSpace.ofLift'_closure fun γ => by\n        rcases ne_or_eq γ 0 with (h₀ | rfl)\n        · rw [nhds_of_ne_zero h₀, lift'_pure (monotone_closure Γ₀), closure_singleton, principal_singleton]\n        · exact has_basis_nhds_zero.lift'_closure_eq_self fun x hx => is_closed_iff.2 <| or.inl <| zero_lt_iff.2 hx }\n#align t3_space T3Space\n-/\n\n",
 "OrderClosedTopology":
 "#print OrderClosedTopology /-\n/-- The topology on a linearly ordered group with zero element adjoined is compatible with the order\nstructure: the set `{p : Γ₀ × Γ₀ | p.1 ≤ p.2}` is closed. -/\nprotected theorem OrderClosedTopology : OrderClosedTopology Γ₀ :=\n  {\n    is_closed_le' := by\n      simp only [← isOpen_compl_iff, compl_set_of, not_le, isOpen_iff_mem_nhds]\n      rintro ⟨a, b⟩ (hab : b < a)\n      rw [nhds_prod_eq, nhds_of_ne_zero (zero_le'.trans_lt hab).ne', pure_prod]\n      exact Iio_mem_nhds hab }\n#align order_closed_topology OrderClosedTopology\n-/\n\n",
 "Iio_mem_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem Iio_mem_nhds_zero (hγ : γ ≠ 0) : Iio γ ∈ (nhds) (0 : Γ₀) :=\n  hasBasis_nhds_zero.mem_of_mem hγ\n#align Iio_mem_nhds_zero Iio_mem_nhds_zero\n\n",
 "Iio_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Iio_mem_nhds /-\ntheorem Iio_mem_nhds (h : γ₁ < γ₂) : Iio γ₂ ∈ (nhds) γ₁ := by\n  rcases eq_or_ne γ₁ 0 with (rfl | h₀) <;> simp [*, h.ne', Iio_mem_nhds_zero]\n#align Iio_mem_nhds Iio_mem_nhds\n-/\n\n",
 "HasContinuousInv₀":
 "#print HasContinuousInv₀ /-\nprotected theorem HasContinuousInv₀ : HasContinuousInv₀ Γ₀ :=\n  ⟨fun γ h => by\n    rw [ContinuousAt, nhds_of_ne_zero h]\n    exact pure_le_nhds γ⁻¹⟩\n#align has_continuous_inv₀ HasContinuousInv₀\n-/\n\n",
 "ContinuousMul":
 "#print ContinuousMul /-\n/-- The topology on a linearly ordered group with zero element adjoined makes it a topological\nmonoid. -/\nprotected theorem ContinuousMul : ContinuousMul Γ₀ :=\n  ⟨by\n    rw [continuous_iff_continuousAt]\n    rintro ⟨x, y⟩\n    wlog hle : x ≤ y generalizing x y\n    · have := tendsto.comp (this y x (le_of_not_le hle)) (continuous_swap.tendsto (x, y))\n      simpa only [mul_comm, Function.comp, Prod.swap]\n    rcases eq_or_ne x 0 with (rfl | hx) <;> [rcases eq_or_ne y 0 with (rfl | hy), skip]\n    · rw [ContinuousAt, MulZeroClass.zero_mul]\n      refine'\n        ((has_basis_nhds_zero.prod_nhds has_basis_nhds_zero).tendsto_iff has_basis_nhds_zero).2 fun γ hγ =>\n          ⟨(γ, 1), ⟨hγ, one_ne_zero⟩, _⟩\n      rintro ⟨x, y⟩ ⟨hx : x < γ, hy : y < 1⟩\n      exact (mul_lt_mul₀ hx hy).trans_eq (mul_one γ)\n    · rw [ContinuousAt, MulZeroClass.zero_mul, nhds_prod_eq, nhds_of_ne_zero hy, prod_pure, tendsto_map'_iff]\n      refine' (has_basis_nhds_zero.tendsto_iff has_basis_nhds_zero).2 fun γ hγ => _\n      refine' ⟨γ / y, div_ne_zero hγ hy, fun x hx => _⟩\n      calc\n        x * y < γ / y * y := mul_lt_right₀ _ hx hy\n        _ = γ := div_mul_cancel _ hy\n        \n    · have hy : y ≠ 0 := ((zero_lt_iff.mpr hx).trans_le hle).ne'\n      rw [ContinuousAt, nhds_prod_eq, nhds_of_ne_zero hx, nhds_of_ne_zero hy, prod_pure_pure]\n      exact pure_le_nhds (x * y)⟩\n#align has_continuous_mul ContinuousMul\n-/\n\n"}