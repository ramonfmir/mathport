{"smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_right (m₀ : M) {U : set M} (hU : U ∈ B) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((nhds) (0 : R)) («expr • » x m₀ ∈ U) :=\n  B.smul_right' m₀ hU\n#align smul_right smul_right\n\n",
 "smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_left (x₀ : R) {U : set M} (hU : U ∈ B) : ∃ V ∈ B, V ⊆ «expr ⁻¹' » (fun x => «expr • » x₀ x) U :=\n  B.smul_left' x₀ hU\n#align smul_left smul_left\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul {U : set M} (hU : U ∈ B) : ∃ V ∈ (nhds) (0 : R), ∃ W ∈ B, «expr • » V W ⊆ U :=\n  B.smul' hU\n#align smul smul\n\n",
 "prod_subset_self":
 "@[to_additive]\ntheorem prod_subset_self (B : group_filter_basis G) {U : set G} (h : U ∈ B) : U ⊆ U * U := fun x x_in =>\n  ⟨1, x, one h, x_in, one_mul x⟩\n#align prod_subset_self prod_subset_self\n\n",
 "one":
 "/-\nCopyright (c) 2021 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot\n-/\n@[to_additive]\ntheorem one {U : set G} : U ∈ B → (1 : G) ∈ U :=\n  group_filter_basis.one'\n#align one one\n\n",
 "of_basis_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A topological add group whith a basis of `𝓝 0` satisfying the axioms of `module_filter_basis`\nis a topological module.\n\nThis lemma is mathematically useless because one could obtain such a result by applying\n`module_filter_basis.has_continuous_smul` and use the fact that group topologies are characterized\nby their neighborhoods of 0 to obtain the `has_continuous_smul` on the pre-existing topology.\n\nBut it turns out it's just easier to get it as a biproduct of the proof, so this is just a free\nquality-of-life improvement. -/\ntheorem _root_.has_continuous_smul.of_basis_zero {ι : Type _} [topological_ring R] [topological_space M]\n    [topological_add_group M] {p : ι → Prop} {b : ι → set M} (h : has_basis ((nhds) 0) p b)\n    (hsmul : ∀ {i}, p i → ∃ V ∈ (nhds) (0 : R), ∃ (j : _)(hj : p j), «expr • » V (b j) ⊆ b i)\n    (hsmul_left : ∀ (x₀ : R) {i}, p i → ∃ (j : _)(hj : p j), b j ⊆ «expr ⁻¹' » (fun x => «expr • » x₀ x) (b i))\n    (hsmul_right :\n      ∀ (m₀ : M) {i},\n        p i →\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n            ((nhds) (0 : R)) («expr • » x m₀ ∈ b i)) :\n    has_continuous_smul R M := by\n  apply has_continuous_smul.of_nhds_zero\n  · rw [h.tendsto_right_iff]\n    intro i hi\n    rcases hsmul hi with ⟨V, V_in, j, hj, hVj⟩\n    apply mem_of_superset (prod_mem_prod V_in <| h.mem_of_mem hj)\n    rintro ⟨v, w⟩ ⟨v_in : v ∈ V, w_in : w ∈ b j⟩\n    exact hVj (Set.smul_mem_smul v_in w_in)\n  · intro m₀\n    rw [h.tendsto_right_iff]\n    intro i hi\n    exact hsmul_right m₀ hi\n  · intro x₀\n    rw [h.tendsto_right_iff]\n    intro i hi\n    rcases hsmul_left x₀ hi with ⟨j, hj, hji⟩\n    exact mem_of_superset (h.mem_of_mem hj) hji\n#align has_continuous_smul.of_basis_zero has_continuous_smul.of_basis_zero\n\n",
 "nhds_one_has_basis":
 "@[to_additive]\ntheorem nhds_one_has_basis (B : group_filter_basis G) : has_basis (@nhds G B.topology 1) (fun V : set G => V ∈ B) id :=\n  by\n  rw [B.nhds_one_eq]\n  exact B.to_filter_basis.has_basis\n#align nhds_one_has_basis nhds_one_has_basis\n\n",
 "nhds_one_eq":
 "@[to_additive]\ntheorem nhds_one_eq (B : group_filter_basis G) : @nhds G B.topology (1 : G) = B.to_filter_basis.filter :=\n  by\n  rw [B.nhds_eq]\n  simp only [N, one_mul]\n  exact map_id\n#align nhds_one_eq nhds_one_eq\n\n",
 "nhds_has_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem nhds_has_basis (B : group_filter_basis G) (x₀ : G) :\n    has_basis (@nhds G B.topology x₀) (fun V : set G => V ∈ B) fun V => «expr '' » (fun y => x₀ * y) V :=\n  by\n  rw [B.nhds_eq]\n  apply B.has_basis\n#align nhds_has_basis nhds_has_basis\n\n",
 "nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem nhds_eq (B : group_filter_basis G) {x₀ : G} : @nhds G B.topology x₀ = B.N x₀ :=\n  by\n  rw [topological_space.nhds_mk_of_nhds]\n  · intro x U U_in\n    rw [(B.has_basis x).mem_iff] at U_in\n    rcases U_in with ⟨V, V_in, H⟩\n    simpa [mem_pure] using H (mem_image_of_mem _ (group_filter_basis.one V_in))\n  · intro x U U_in\n    rw [(B.has_basis x).mem_iff] at U_in\n    rcases U_in with ⟨V, V_in, H⟩\n    rcases group_filter_basis.mul V_in with ⟨W, W_in, hW⟩\n    use «expr '' » (fun y => x * y) W, image_mem_map (filter_basis.mem_filter_of_mem _ W_in)\n    constructor\n    · rw [image_subset_iff] at H⊢\n      exact ((B.prod_subset_self W_in).trans hW).trans H\n    · rintro y ⟨t, tW, rfl⟩\n      rw [(B.has_basis _).mem_iff]\n      use W, W_in\n      apply subset.trans _ H\n      clear H\n      rintro z ⟨w, wW, rfl⟩\n      exact ⟨t * w, hW (mul_mem_mul tW wW), by simp [mul_assoc]⟩\n#align nhds_eq nhds_eq\n\n",
 "mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mul_right (x₀ : R) {U : set R} (hU : U ∈ B) : ∃ V ∈ B, V ⊆ «expr ⁻¹' » (fun x => x * x₀) U :=\n  mul_right' x₀ hU\n#align mul_right mul_right\n\n",
 "mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mul_left (x₀ : R) {U : set R} (hU : U ∈ B) : ∃ V ∈ B, V ⊆ «expr ⁻¹' » (fun x => x₀ * x) U :=\n  mul_left' x₀ hU\n#align mul_left mul_left\n\n",
 "mul":
 "-- See note [lower instance priority]\ntheorem mul {U : set R} (hU : U ∈ B) : ∃ V ∈ B, V * V ⊆ U :=\n  mul' hU\n#align mul mul\n\n",
 "mem_nhds_one":
 "@[to_additive]\ntheorem mem_nhds_one (B : group_filter_basis G) {U : set G} (hU : U ∈ B) : U ∈ @nhds G B.topology 1 :=\n  by\n  rw [B.nhds_one_has_basis.mem_iff]\n  exact ⟨U, hU, rfl.subset⟩\n#align mem_nhds_one mem_nhds_one\n\n",
 "inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem inv {U : set G} : U ∈ B → ∃ V ∈ B, V ⊆ «expr ⁻¹' » (fun x => x⁻¹) U :=\n  group_filter_basis.inv'\n#align inv inv\n\n",
 "has_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\nprotected theorem has_basis (B : group_filter_basis G) (x : G) :\n    has_basis (B.N x) (fun V : set G => V ∈ B) fun V => «expr '' » (fun y => x * y) V :=\n  has_basis.map (fun y => x * y) to_filter_basis.has_basis\n#align has_basis has_basis\n\n",
 "conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem conj : ∀ x₀, ∀ {U}, U ∈ B → ∃ V ∈ B, V ⊆ «expr ⁻¹' » (fun x => x₀ * x * x₀⁻¹) U :=\n  group_filter_basis.conj'\n#align conj conj\n\n",
 "N_one":
 "@[simp, to_additive]\ntheorem N_one (B : group_filter_basis G) : B.N 1 = B.to_filter_basis.filter := by simp only [N, one_mul, map_id']\n#align N_one N_one\n\n"}