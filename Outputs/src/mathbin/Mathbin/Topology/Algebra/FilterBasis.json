{"smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem smul_right (mâ‚€ : M) {U : set M} (hU : U âˆˆ B) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      ((nhds) (0 : R)) (Â«expr â€¢ Â» x mâ‚€ âˆˆ U) :=\n  B.smul_right' mâ‚€ hU\n#align smul_right smul_right\n\n",
 "smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem smul_left (xâ‚€ : R) {U : set M} (hU : U âˆˆ B) : âˆƒ V âˆˆ B, V âŠ† Â«expr â»Â¹' Â» (fun x => Â«expr â€¢ Â» xâ‚€ x) U :=\n  B.smul_left' xâ‚€ hU\n#align smul_left smul_left\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem smul {U : set M} (hU : U âˆˆ B) : âˆƒ V âˆˆ (nhds) (0 : R), âˆƒ W âˆˆ B, Â«expr â€¢ Â» V W âŠ† U :=\n  B.smul' hU\n#align smul smul\n\n",
 "prod_subset_self":
 "@[to_additive]\ntheorem prod_subset_self (B : group_filter_basis G) {U : set G} (h : U âˆˆ B) : U âŠ† U * U := fun x x_in =>\n  âŸ¨1, x, one h, x_in, one_mul xâŸ©\n#align prod_subset_self prod_subset_self\n\n",
 "one":
 "/-\nCopyright (c) 2021 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot\n-/\n@[to_additive]\ntheorem one {U : set G} : U âˆˆ B â†’ (1 : G) âˆˆ U :=\n  group_filter_basis.one'\n#align one one\n\n",
 "of_basis_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- A topological add group whith a basis of `ğ“ 0` satisfying the axioms of `module_filter_basis`\nis a topological module.\n\nThis lemma is mathematically useless because one could obtain such a result by applying\n`module_filter_basis.has_continuous_smul` and use the fact that group topologies are characterized\nby their neighborhoods of 0 to obtain the `has_continuous_smul` on the pre-existing topology.\n\nBut it turns out it's just easier to get it as a biproduct of the proof, so this is just a free\nquality-of-life improvement. -/\ntheorem _root_.has_continuous_smul.of_basis_zero {Î¹ : Type _} [topological_ring R] [topological_space M]\n    [topological_add_group M] {p : Î¹ â†’ Prop} {b : Î¹ â†’ set M} (h : has_basis ((nhds) 0) p b)\n    (hsmul : âˆ€ {i}, p i â†’ âˆƒ V âˆˆ (nhds) (0 : R), âˆƒ (j : _)(hj : p j), Â«expr â€¢ Â» V (b j) âŠ† b i)\n    (hsmul_left : âˆ€ (xâ‚€ : R) {i}, p i â†’ âˆƒ (j : _)(hj : p j), b j âŠ† Â«expr â»Â¹' Â» (fun x => Â«expr â€¢ Â» xâ‚€ x) (b i))\n    (hsmul_right :\n      âˆ€ (mâ‚€ : M) {i},\n        p i â†’\n          Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n            ((nhds) (0 : R)) (Â«expr â€¢ Â» x mâ‚€ âˆˆ b i)) :\n    has_continuous_smul R M := by\n  apply has_continuous_smul.of_nhds_zero\n  Â· rw [h.tendsto_right_iff]\n    intro i hi\n    rcases hsmul hi with âŸ¨V, V_in, j, hj, hVjâŸ©\n    apply mem_of_superset (prod_mem_prod V_in <| h.mem_of_mem hj)\n    rintro âŸ¨v, wâŸ© âŸ¨v_in : v âˆˆ V, w_in : w âˆˆ b jâŸ©\n    exact hVj (Set.smul_mem_smul v_in w_in)\n  Â· intro mâ‚€\n    rw [h.tendsto_right_iff]\n    intro i hi\n    exact hsmul_right mâ‚€ hi\n  Â· intro xâ‚€\n    rw [h.tendsto_right_iff]\n    intro i hi\n    rcases hsmul_left xâ‚€ hi with âŸ¨j, hj, hjiâŸ©\n    exact mem_of_superset (h.mem_of_mem hj) hji\n#align has_continuous_smul.of_basis_zero has_continuous_smul.of_basis_zero\n\n",
 "nhds_one_has_basis":
 "@[to_additive]\ntheorem nhds_one_has_basis (B : group_filter_basis G) : has_basis (@nhds G B.topology 1) (fun V : set G => V âˆˆ B) id :=\n  by\n  rw [B.nhds_one_eq]\n  exact B.to_filter_basis.has_basis\n#align nhds_one_has_basis nhds_one_has_basis\n\n",
 "nhds_one_eq":
 "@[to_additive]\ntheorem nhds_one_eq (B : group_filter_basis G) : @nhds G B.topology (1 : G) = B.to_filter_basis.filter :=\n  by\n  rw [B.nhds_eq]\n  simp only [N, one_mul]\n  exact map_id\n#align nhds_one_eq nhds_one_eq\n\n",
 "nhds_has_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[to_additive]\ntheorem nhds_has_basis (B : group_filter_basis G) (xâ‚€ : G) :\n    has_basis (@nhds G B.topology xâ‚€) (fun V : set G => V âˆˆ B) fun V => Â«expr '' Â» (fun y => xâ‚€ * y) V :=\n  by\n  rw [B.nhds_eq]\n  apply B.has_basis\n#align nhds_has_basis nhds_has_basis\n\n",
 "nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[to_additive]\ntheorem nhds_eq (B : group_filter_basis G) {xâ‚€ : G} : @nhds G B.topology xâ‚€ = B.N xâ‚€ :=\n  by\n  rw [topological_space.nhds_mk_of_nhds]\n  Â· intro x U U_in\n    rw [(B.has_basis x).mem_iff] at U_in\n    rcases U_in with âŸ¨V, V_in, HâŸ©\n    simpa [mem_pure] using H (mem_image_of_mem _ (group_filter_basis.one V_in))\n  Â· intro x U U_in\n    rw [(B.has_basis x).mem_iff] at U_in\n    rcases U_in with âŸ¨V, V_in, HâŸ©\n    rcases group_filter_basis.mul V_in with âŸ¨W, W_in, hWâŸ©\n    use Â«expr '' Â» (fun y => x * y) W, image_mem_map (filter_basis.mem_filter_of_mem _ W_in)\n    constructor\n    Â· rw [image_subset_iff] at HâŠ¢\n      exact ((B.prod_subset_self W_in).trans hW).trans H\n    Â· rintro y âŸ¨t, tW, rflâŸ©\n      rw [(B.has_basis _).mem_iff]\n      use W, W_in\n      apply subset.trans _ H\n      clear H\n      rintro z âŸ¨w, wW, rflâŸ©\n      exact âŸ¨t * w, hW (mul_mem_mul tW wW), by simp [mul_assoc]âŸ©\n#align nhds_eq nhds_eq\n\n",
 "mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem mul_right (xâ‚€ : R) {U : set R} (hU : U âˆˆ B) : âˆƒ V âˆˆ B, V âŠ† Â«expr â»Â¹' Â» (fun x => x * xâ‚€) U :=\n  mul_right' xâ‚€ hU\n#align mul_right mul_right\n\n",
 "mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem mul_left (xâ‚€ : R) {U : set R} (hU : U âˆˆ B) : âˆƒ V âˆˆ B, V âŠ† Â«expr â»Â¹' Â» (fun x => xâ‚€ * x) U :=\n  mul_left' xâ‚€ hU\n#align mul_left mul_left\n\n",
 "mul":
 "-- See note [lower instance priority]\ntheorem mul {U : set R} (hU : U âˆˆ B) : âˆƒ V âˆˆ B, V * V âŠ† U :=\n  mul' hU\n#align mul mul\n\n",
 "mem_nhds_one":
 "@[to_additive]\ntheorem mem_nhds_one (B : group_filter_basis G) {U : set G} (hU : U âˆˆ B) : U âˆˆ @nhds G B.topology 1 :=\n  by\n  rw [B.nhds_one_has_basis.mem_iff]\n  exact âŸ¨U, hU, rfl.subsetâŸ©\n#align mem_nhds_one mem_nhds_one\n\n",
 "inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[to_additive]\ntheorem inv {U : set G} : U âˆˆ B â†’ âˆƒ V âˆˆ B, V âŠ† Â«expr â»Â¹' Â» (fun x => xâ»Â¹) U :=\n  group_filter_basis.inv'\n#align inv inv\n\n",
 "has_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[to_additive]\nprotected theorem has_basis (B : group_filter_basis G) (x : G) :\n    has_basis (B.N x) (fun V : set G => V âˆˆ B) fun V => Â«expr '' Â» (fun y => x * y) V :=\n  has_basis.map (fun y => x * y) to_filter_basis.has_basis\n#align has_basis has_basis\n\n",
 "conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[to_additive]\ntheorem conj : âˆ€ xâ‚€, âˆ€ {U}, U âˆˆ B â†’ âˆƒ V âˆˆ B, V âŠ† Â«expr â»Â¹' Â» (fun x => xâ‚€ * x * xâ‚€â»Â¹) U :=\n  group_filter_basis.conj'\n#align conj conj\n\n",
 "N_one":
 "@[simp, to_additive]\ntheorem N_one (B : group_filter_basis G) : B.N 1 = B.to_filter_basis.filter := by simp only [N, one_mul, map_id']\n#align N_one N_one\n\n"}