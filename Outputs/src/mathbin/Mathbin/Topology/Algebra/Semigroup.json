{"exists_idempotent_of_compact_t2_of_continuous_mul_left":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (m m' «expr ∈ » N) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n#print exists_idempotent_of_compact_t2_of_continuous_mul_left /-\n/-\nCopyright (c) 2021 David Wärn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: David Wärn\n-/\n/-- Any nonempty compact Hausdorff semigroup where right-multiplication is continuous contains\nan idempotent, i.e. an `m` such that `m * m = m`. -/\n@[to_additive\n      \"Any nonempty compact Hausdorff additive semigroup where right-addition is continuous\\ncontains an idempotent, i.e. an `m` such that `m + m = m`\"]\ntheorem exists_idempotent_of_compact_t2_of_continuous_mul_left {M} [Nonempty M] [Semigroup M] [TopologicalSpace M]\n    [CompactSpace M] [T2Space M] (continuous_mul_left : ∀ r : M, Continuous (· * r)) : ∃ m : M, m * m = m :=\n  by\n  /- We apply Zorn's lemma to the poset of nonempty closed subsemigroups of `M`. It will turn out that\n  any minimal element is `{m}` for an idempotent `m : M`. -/\n  let S : Set (Set M) := { N | IsClosed N ∧ N.nonempty ∧ ∀ (m) (_ : m ∈ N) (m') (_ : m' ∈ N), m * m' ∈ N }\n  rsuffices ⟨N, ⟨N_closed, ⟨m, hm⟩, N_mul⟩, N_minimal⟩ : ∃ N ∈ S, ∀ N' ∈ S, N' ⊆ N → N' = N\n  · use m\n    /- We now have an element `m : M` of a minimal subsemigroup `N`, and want to show `m + m = m`.\n    We first show that every element of `N` is of the form `m' + m`.-/\n    have scaling_eq_self : «expr '' » (· * m) N = N :=\n      by\n      apply N_minimal\n      · refine' ⟨(continuous_mul_left m).is_closed_map _ N_closed, ⟨_, ⟨m, hm, rfl⟩⟩, _⟩\n        rintro _ ⟨m'', hm'', rfl⟩ _ ⟨m', hm', rfl⟩\n        refine' ⟨m'' * m * m', N_mul _ (N_mul _ hm'' _ hm) _ hm', mul_assoc _ _ _⟩\n      · rintro _ ⟨m', hm', rfl⟩\n        exact N_mul _ hm' _ hm\n    /- In particular, this means that `m' * m = m` for some `m'`. We now use minimality again to show\n    that this holds for all `m' ∈ N`. -/\n    have absorbing_eq_self : N ∩ { m' | m' * m = m } = N :=\n      by\n      apply N_minimal\n      · refine' ⟨N_closed.inter ((t1_space.t1 m).preimage (continuous_mul_left m)), _, _⟩\n        · rwa [← scaling_eq_self] at hm\n        · rintro m'' ⟨mem'', eq'' : _ = m⟩ m' ⟨mem', eq' : _ = m⟩\n          refine' ⟨N_mul _ mem'' _ mem', _⟩\n          rw [Set.mem_setOf_eq, mul_assoc, eq', eq'']\n      apply Set.inter_subset_left\n    -- Thus `m * m = m` as desired.\n    rw [← absorbing_eq_self] at hm\n    exact hm.2\n  refine' zorn_superset _ fun c hcs hc => _\n  refine'\n    ⟨«expr⋂₀ » c, ⟨isClosed_interₛ fun t ht => (hcs ht).1, _, fun m hm m' hm' => _⟩, fun s hs =>\n      Set.interₛ_subset_of_mem hs⟩\n  · obtain rfl | hcnemp := c.eq_empty_or_nonempty\n    · rw [Set.interₛ_empty]\n      apply Set.univ_nonempty\n    convert@IsCompact.nonempty_interᵢ_of_directed_nonempty_compact_closed _ _ _ hcnemp.coe_sort (coe : c → Set M) _ _ _\n        _\n    · simp only [Subtype.range_coe_subtype, Set.setOf_mem_eq]\n    · refine' DirectedOn.directed_val (IsChain.directedOn hc.symm)\n    exacts[fun i => (hcs i.prop).2.1, fun i => (hcs i.prop).1.is_compact, fun i => (hcs i.prop).1]\n  · rw [Set.mem_interₛ]\n    exact fun t ht => (hcs ht).2.2 m (set.mem_sInter.mp hm t ht) m' (set.mem_sInter.mp hm' t ht)\n#align exists_idempotent_of_compact_t2_of_continuous_mul_left exists_idempotent_of_compact_t2_of_continuous_mul_left\n#align exists_idempotent_of_compact_t2_of_continuous_add_left exists_idempotent_of_compact_t2_of_continuous_add_left\n-/\n\n",
 "exists_idempotent_in_compact_subsemigroup":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » s) -/\n#print exists_idempotent_in_compact_subsemigroup /-\n/-- A version of `exists_idempotent_of_compact_t2_of_continuous_mul_left` where the idempotent lies\nin some specified nonempty compact subsemigroup. -/\n@[to_additive exists_idempotent_in_compact_add_subsemigroup\n      \"A version of\\n`exists_idempotent_of_compact_t2_of_continuous_add_left` where the idempotent lies in some specified\\nnonempty compact additive subsemigroup.\"]\ntheorem exists_idempotent_in_compact_subsemigroup {M} [Semigroup M] [TopologicalSpace M] [T2Space M]\n    (continuous_mul_left : ∀ r : M, Continuous (· * r)) (s : Set M) (snemp : s.nonempty) (s_compact : IsCompact s)\n    (s_add : ∀ (x) (_ : x ∈ s) (y) (_ : y ∈ s), x * y ∈ s) : ∃ m ∈ s, m * m = m :=\n  by\n  let M' := { m // m ∈ s }\n  letI : Semigroup M' :=\n    { mul := fun p q => ⟨p.1 * q.1, s_add _ p.2 _ q.2⟩\n      mul_assoc := fun p q r => Subtype.eq (mul_assoc _ _ _) }\n  haveI : CompactSpace M' := is_compact_iff_compact_space.mp s_compact\n  haveI : Nonempty M' := nonempty_subtype.mpr snemp\n  have : ∀ p : M', Continuous (· * p) := fun p => ((continuous_mul_left p.1).comp continuous_subtype_val).subtype_mk _\n  obtain ⟨⟨m, hm⟩, idem⟩ := exists_idempotent_of_compact_t2_of_continuous_mul_left this\n  exact ⟨m, hm, subtype.ext_iff.mp idem⟩\n#align exists_idempotent_in_compact_subsemigroup exists_idempotent_in_compact_subsemigroup\n#align exists_idempotent_in_compact_add_subsemigroup exists_idempotent_in_compact_add_subsemigroup\n-/\n\n"}