{"has_continuous_smul_submodule_of_image_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n/-- Let `E` be a TVS, `ğ”– : set (set Î±)` and `H` a submodule of `Î± â†’áµ¤[ğ”–] E`. If the image of any\n`S âˆˆ ğ”–` by any `u âˆˆ H` is bounded (in the sense of `bornology.is_vonN_bounded`), then `H`,\nequipped with the topology of `ğ”–`-convergence, is a TVS.\n\nIf you have a hard time using this lemma, try the one above instead. -/\ntheorem uniform_on_fun.has_continuous_smul_submodule_of_image_bounded (hğ”–â‚ : ğ”–.nonempty) (hğ”–â‚‚ : DirectedOn (Â· âŠ† Â·) ğ”–)\n    (H : submodule ğ•œ (Â«expr â†’áµ¤[ ] Â» Î± ğ”– E)) (h : âˆ€ u âˆˆ H, âˆ€ s âˆˆ ğ”–, bornology.is_vonN_bounded ğ•œ (Â«expr '' Â» u s)) :\n    @has_continuous_smul ğ•œ H _ _ ((uniform_on_fun.topological_space Î± E ğ”–).induced (coe : H â†’ Â«expr â†’áµ¤[ ] Â» Î± ğ”– E)) :=\n  haveI : topological_add_group H :=\n    topological_add_group_induced (linear_map.id.dom_restrict H : Â«expr â†’â‚—[ ] Â» H ğ•œ (Î± â†’ E))\n  uniform_on_fun.has_continuous_smul_induced_of_image_bounded ğ•œ Î± E H hğ”–â‚ hğ”–â‚‚\n    (linear_map.id.dom_restrict H : Â«expr â†’â‚—[ ] Â» H ğ•œ (Î± â†’ E)) inducing_coe fun âŸ¨u, huâŸ© => h u hu\n#align\n  uniform_on_fun.has_continuous_smul_submodule_of_image_bounded uniform_on_fun.has_continuous_smul_submodule_of_image_bounded\n\n",
 "has_continuous_smul_induced_of_image_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- Let `E` be a TVS, `ğ”– : set (set Î±)` and `H` a submodule of `Î± â†’áµ¤[ğ”–] E`. If the image of any\n`S âˆˆ ğ”–` by any `u âˆˆ H` is bounded (in the sense of `bornology.is_vonN_bounded`), then `H`,\nequipped with the topology of `ğ”–`-convergence, is a TVS.\n\nFor convenience, we don't literally ask for `H : submodule (Î± â†’áµ¤[ğ”–] E)`. Instead, we prove the\nresult for any vector space `H` equipped with a linear inducing to `Î± â†’áµ¤[ğ”–] E`, which is often\neasier to use. We also state the `submodule` version as\n`uniform_on_fun.has_continuous_smul_submodule_of_image_bounded`. -/\ntheorem uniform_on_fun.has_continuous_smul_induced_of_image_bounded (hğ”–â‚ : ğ”–.nonempty) (hğ”–â‚‚ : DirectedOn (Â· âŠ† Â·) ğ”–)\n    (Ï† : hom) (hÏ† : inducing Ï†) (h : âˆ€ u : H, âˆ€ s âˆˆ ğ”–, bornology.is_vonN_bounded ğ•œ (Â«expr '' Â» (Ï† u : Î± â†’ E) s)) :\n    has_continuous_smul ğ•œ H :=\n  by\n  have : topological_add_group H := by\n    rw [hÏ†.induced]\n    exact topological_add_group_induced Ï†\n  have : ((nhds) 0 : filter H).has_basis _ _ :=\n    by\n    rw [hÏ†.induced, nhds_induced, map_zero]\n    exact (uniform_on_fun.has_basis_nhds_zero ğ”– hğ”–â‚ hğ”–â‚‚).comap Ï†\n  refine' has_continuous_smul.of_basis_zero this _ _ _\n  Â· rintro âŸ¨S, VâŸ© âŸ¨hS, hVâŸ©\n    have : tendsto (fun kx : ğ•œ Ã— E => Â«expr â€¢ Â» kx.1 kx.2) ((nhds) (0, 0)) (nhds <| Â«expr â€¢ Â» (0 : ğ•œ) 0) :=\n      continuous_smul.tendsto (0 : ğ•œ Ã— E)\n    rw [zero_smul, nhds_prod_eq] at this\n    have := this hV\n    rw [mem_map, mem_prod_iff] at this\n    rcases this with âŸ¨U, hU, W, hW, hUWâŸ©\n    refine' âŸ¨U, hU, âŸ¨S, WâŸ©, âŸ¨hS, hWâŸ©, _âŸ©\n    rw [Set.smul_subset_iff]\n    intro a ha u hu x hx\n    rw [smul_hom_class.map_smul]\n    exact hUW (âŸ¨ha, hu x hxâŸ© : (a, Ï† u x) âˆˆ lower_set.prod U W)\n  Â· rintro a âŸ¨S, VâŸ© âŸ¨hS, hVâŸ©\n    have : tendsto (fun x : E => Â«expr â€¢ Â» a x) ((nhds) 0) (nhds <| Â«expr â€¢ Â» a 0) := tendsto_id.const_smul a\n    rw [smul_zero] at this\n    refine' âŸ¨âŸ¨S, Â«expr â»Â¹' Â» ((Â«expr â€¢ Â» Â· Â·) a) VâŸ©, âŸ¨hS, this hVâŸ©, fun f hf x hx => _âŸ©\n    rw [smul_hom_class.map_smul]\n    exact hf x hx\n  Â· rintro u âŸ¨S, VâŸ© âŸ¨hS, hVâŸ©\n    rcases h u S hS hV with âŸ¨r, hrpos, hrâŸ©\n    rw [metric.eventually_nhds_iff_ball]\n    refine' âŸ¨râ»Â¹, inv_pos.mpr hrpos, fun a ha x hx => _âŸ©\n    by_cases ha0 : a = 0\n    Â· rw [ha0]\n      simp [mem_of_mem_nhds hV]\n    Â· rw [mem_ball_zero_iff] at ha\n      rw [smul_hom_class.map_smul, pi.smul_apply]\n      have : Ï† u x âˆˆ Â«expr â€¢ Â» aâ»Â¹ V :=\n        by\n        have ha0 : 0 < Â«exprâ€– â€–Â» a := norm_pos_iff.mpr ha0\n        refine' (hr aâ»Â¹ _) (Set.mem_image_of_mem (Ï† u) hx)\n        rw [norm_inv, le_inv hrpos ha0]\n        exact ha.le\n      rwa [Set.mem_inv_smul_set_iffâ‚€ ha0] at this\n#align\n  uniform_on_fun.has_continuous_smul_induced_of_image_bounded uniform_on_fun.has_continuous_smul_induced_of_image_bounded\n\n",
 "has_basis_nhds_one_of_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n-- Since `(/) : G Ã— G â†’ G` is uniformly continuous,\n-- `uniform_on_fun.postcomp_uniform_continuous` tells us that\n-- `((/) âˆ˜ â€”) : (Î± â†’áµ¤[ğ”–] G Ã— G) â†’ (Î± â†’áµ¤[ğ”–] G)` is uniformly continuous too. By precomposing with\n-- `uniform_on_fun.uniform_equiv_prod_arrow`, this gives that\n-- `(/) : (Î± â†’áµ¤[ğ”–] G) Ã— (Î± â†’áµ¤[ğ”–] G) â†’ (Î± â†’áµ¤[ğ”–] G)` is also uniformly continuous\n@[to_additive]\nprotected theorem uniform_on_fun.has_basis_nhds_one_of_basis (ğ”– : set <| set Î±) (hğ”–â‚ : ğ”–.nonempty)\n    (hğ”–â‚‚ : DirectedOn (Â· âŠ† Â·) ğ”–) {p : Î¹ â†’ Prop} {b : Î¹ â†’ set G} (h : ((nhds) 1 : filter G).has_basis p b) :\n    ((nhds) 1 : filter (Â«expr â†’áµ¤[ ] Â» Î± ğ”– G)).has_basis (fun Si : set Î± Ã— Î¹ => Si.1 âˆˆ ğ”– âˆ§ p Si.2) fun Si =>\n      { f : Â«expr â†’áµ¤[ ] Â» Î± ğ”– G | âˆ€ x âˆˆ Si.1, f x âˆˆ b Si.2 } :=\n  by\n  have := h.comap fun p : G Ã— G => p.1 / p.2\n  rw [â† uniformity_eq_comap_nhds_one_swapped] at this\n  convert uniform_on_fun.has_basis_nhds_of_basis Î± _ ğ”– 1 hğ”–â‚ hğ”–â‚‚ this\n  ext (i f)\n  simp [uniform_on_fun.gen]\n#align uniform_on_fun.has_basis_nhds_one_of_basis uniform_on_fun.has_basis_nhds_one_of_basis\n\n",
 "has_basis_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n@[to_additive]\nprotected theorem uniform_on_fun.has_basis_nhds_one (ğ”– : set <| set Î±) (hğ”–â‚ : ğ”–.nonempty) (hğ”–â‚‚ : DirectedOn (Â· âŠ† Â·) ğ”–) :\n    ((nhds) 1 : filter (Â«expr â†’áµ¤[ ] Â» Î± ğ”– G)).has_basis\n      (fun SV : set Î± Ã— set G => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ((nhds) 1 : filter G)) fun SV =>\n      { f : Â«expr â†’áµ¤[ ] Â» Î± ğ”– G | âˆ€ x âˆˆ SV.1, f x âˆˆ SV.2 } :=\n  uniform_on_fun.has_basis_nhds_one_of_basis ğ”– hğ”–â‚ hğ”–â‚‚ (basis_sets _)\n#align uniform_on_fun.has_basis_nhds_one uniform_on_fun.has_basis_nhds_one\n\n"}