{"has_continuous_smul_submodule_of_image_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n/-- Let `E` be a TVS, `𝔖 : set (set α)` and `H` a submodule of `α →ᵤ[𝔖] E`. If the image of any\n`S ∈ 𝔖` by any `u ∈ H` is bounded (in the sense of `bornology.is_vonN_bounded`), then `H`,\nequipped with the topology of `𝔖`-convergence, is a TVS.\n\nIf you have a hard time using this lemma, try the one above instead. -/\ntheorem uniform_on_fun.has_continuous_smul_submodule_of_image_bounded (h𝔖₁ : 𝔖.nonempty) (h𝔖₂ : DirectedOn (· ⊆ ·) 𝔖)\n    (H : submodule 𝕜 («expr →ᵤ[ ] » α 𝔖 E)) (h : ∀ u ∈ H, ∀ s ∈ 𝔖, bornology.is_vonN_bounded 𝕜 («expr '' » u s)) :\n    @has_continuous_smul 𝕜 H _ _ ((uniform_on_fun.topological_space α E 𝔖).induced (coe : H → «expr →ᵤ[ ] » α 𝔖 E)) :=\n  haveI : topological_add_group H :=\n    topological_add_group_induced (linear_map.id.dom_restrict H : «expr →ₗ[ ] » H 𝕜 (α → E))\n  uniform_on_fun.has_continuous_smul_induced_of_image_bounded 𝕜 α E H h𝔖₁ h𝔖₂\n    (linear_map.id.dom_restrict H : «expr →ₗ[ ] » H 𝕜 (α → E)) inducing_coe fun ⟨u, hu⟩ => h u hu\n#align\n  uniform_on_fun.has_continuous_smul_submodule_of_image_bounded uniform_on_fun.has_continuous_smul_submodule_of_image_bounded\n\n",
 "has_continuous_smul_induced_of_image_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- Let `E` be a TVS, `𝔖 : set (set α)` and `H` a submodule of `α →ᵤ[𝔖] E`. If the image of any\n`S ∈ 𝔖` by any `u ∈ H` is bounded (in the sense of `bornology.is_vonN_bounded`), then `H`,\nequipped with the topology of `𝔖`-convergence, is a TVS.\n\nFor convenience, we don't literally ask for `H : submodule (α →ᵤ[𝔖] E)`. Instead, we prove the\nresult for any vector space `H` equipped with a linear inducing to `α →ᵤ[𝔖] E`, which is often\neasier to use. We also state the `submodule` version as\n`uniform_on_fun.has_continuous_smul_submodule_of_image_bounded`. -/\ntheorem uniform_on_fun.has_continuous_smul_induced_of_image_bounded (h𝔖₁ : 𝔖.nonempty) (h𝔖₂ : DirectedOn (· ⊆ ·) 𝔖)\n    (φ : hom) (hφ : inducing φ) (h : ∀ u : H, ∀ s ∈ 𝔖, bornology.is_vonN_bounded 𝕜 («expr '' » (φ u : α → E) s)) :\n    has_continuous_smul 𝕜 H :=\n  by\n  have : topological_add_group H := by\n    rw [hφ.induced]\n    exact topological_add_group_induced φ\n  have : ((nhds) 0 : filter H).has_basis _ _ :=\n    by\n    rw [hφ.induced, nhds_induced, map_zero]\n    exact (uniform_on_fun.has_basis_nhds_zero 𝔖 h𝔖₁ h𝔖₂).comap φ\n  refine' has_continuous_smul.of_basis_zero this _ _ _\n  · rintro ⟨S, V⟩ ⟨hS, hV⟩\n    have : tendsto (fun kx : 𝕜 × E => «expr • » kx.1 kx.2) ((nhds) (0, 0)) (nhds <| «expr • » (0 : 𝕜) 0) :=\n      continuous_smul.tendsto (0 : 𝕜 × E)\n    rw [zero_smul, nhds_prod_eq] at this\n    have := this hV\n    rw [mem_map, mem_prod_iff] at this\n    rcases this with ⟨U, hU, W, hW, hUW⟩\n    refine' ⟨U, hU, ⟨S, W⟩, ⟨hS, hW⟩, _⟩\n    rw [Set.smul_subset_iff]\n    intro a ha u hu x hx\n    rw [smul_hom_class.map_smul]\n    exact hUW (⟨ha, hu x hx⟩ : (a, φ u x) ∈ lower_set.prod U W)\n  · rintro a ⟨S, V⟩ ⟨hS, hV⟩\n    have : tendsto (fun x : E => «expr • » a x) ((nhds) 0) (nhds <| «expr • » a 0) := tendsto_id.const_smul a\n    rw [smul_zero] at this\n    refine' ⟨⟨S, «expr ⁻¹' » ((«expr • » · ·) a) V⟩, ⟨hS, this hV⟩, fun f hf x hx => _⟩\n    rw [smul_hom_class.map_smul]\n    exact hf x hx\n  · rintro u ⟨S, V⟩ ⟨hS, hV⟩\n    rcases h u S hS hV with ⟨r, hrpos, hr⟩\n    rw [metric.eventually_nhds_iff_ball]\n    refine' ⟨r⁻¹, inv_pos.mpr hrpos, fun a ha x hx => _⟩\n    by_cases ha0 : a = 0\n    · rw [ha0]\n      simp [mem_of_mem_nhds hV]\n    · rw [mem_ball_zero_iff] at ha\n      rw [smul_hom_class.map_smul, pi.smul_apply]\n      have : φ u x ∈ «expr • » a⁻¹ V :=\n        by\n        have ha0 : 0 < «expr‖ ‖» a := norm_pos_iff.mpr ha0\n        refine' (hr a⁻¹ _) (Set.mem_image_of_mem (φ u) hx)\n        rw [norm_inv, le_inv hrpos ha0]\n        exact ha.le\n      rwa [Set.mem_inv_smul_set_iff₀ ha0] at this\n#align\n  uniform_on_fun.has_continuous_smul_induced_of_image_bounded uniform_on_fun.has_continuous_smul_induced_of_image_bounded\n\n",
 "has_basis_nhds_one_of_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n-- Since `(/) : G × G → G` is uniformly continuous,\n-- `uniform_on_fun.postcomp_uniform_continuous` tells us that\n-- `((/) ∘ —) : (α →ᵤ[𝔖] G × G) → (α →ᵤ[𝔖] G)` is uniformly continuous too. By precomposing with\n-- `uniform_on_fun.uniform_equiv_prod_arrow`, this gives that\n-- `(/) : (α →ᵤ[𝔖] G) × (α →ᵤ[𝔖] G) → (α →ᵤ[𝔖] G)` is also uniformly continuous\n@[to_additive]\nprotected theorem uniform_on_fun.has_basis_nhds_one_of_basis (𝔖 : set <| set α) (h𝔖₁ : 𝔖.nonempty)\n    (h𝔖₂ : DirectedOn (· ⊆ ·) 𝔖) {p : ι → Prop} {b : ι → set G} (h : ((nhds) 1 : filter G).has_basis p b) :\n    ((nhds) 1 : filter («expr →ᵤ[ ] » α 𝔖 G)).has_basis (fun Si : set α × ι => Si.1 ∈ 𝔖 ∧ p Si.2) fun Si =>\n      { f : «expr →ᵤ[ ] » α 𝔖 G | ∀ x ∈ Si.1, f x ∈ b Si.2 } :=\n  by\n  have := h.comap fun p : G × G => p.1 / p.2\n  rw [← uniformity_eq_comap_nhds_one_swapped] at this\n  convert uniform_on_fun.has_basis_nhds_of_basis α _ 𝔖 1 h𝔖₁ h𝔖₂ this\n  ext (i f)\n  simp [uniform_on_fun.gen]\n#align uniform_on_fun.has_basis_nhds_one_of_basis uniform_on_fun.has_basis_nhds_one_of_basis\n\n",
 "has_basis_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n@[to_additive]\nprotected theorem uniform_on_fun.has_basis_nhds_one (𝔖 : set <| set α) (h𝔖₁ : 𝔖.nonempty) (h𝔖₂ : DirectedOn (· ⊆ ·) 𝔖) :\n    ((nhds) 1 : filter («expr →ᵤ[ ] » α 𝔖 G)).has_basis\n      (fun SV : set α × set G => SV.1 ∈ 𝔖 ∧ SV.2 ∈ ((nhds) 1 : filter G)) fun SV =>\n      { f : «expr →ᵤ[ ] » α 𝔖 G | ∀ x ∈ SV.1, f x ∈ SV.2 } :=\n  uniform_on_fun.has_basis_nhds_one_of_basis 𝔖 h𝔖₁ h𝔖₂ (basis_sets _)\n#align uniform_on_fun.has_basis_nhds_one uniform_on_fun.has_basis_nhds_one\n\n"}