{"to_continuous_map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[to_additive]\ntheorem to_continuous_map_injective : injective (to_continuous_map : _ → «exprC( , )» A B) := fun f g h =>\n  ext <| by convert fun_like.ext_iff.1 h\n#align to_continuous_map_injective to_continuous_map_injective\n\n",
 "map_one":
 "#print map_one /-\n@[simp]\ntheorem map_one : map (one A B) = one (pontryagin_dual B) (pontryagin_dual A) :=\n  ext fun x => ext fun y => map_one x\n#align map_one map_one\n-/\n\n",
 "map_mul":
 "#print map_mul /-\n@[simp]\ntheorem map_mul (f g : continuous_monoid_hom A E) : map (f * g) = map f * map g :=\n  ext fun x => ext fun y => map_mul x (f y) (g y)\n#align map_mul map_mul\n-/\n\n",
 "map_comp":
 "@[simp]\ntheorem map_comp (g : continuous_monoid_hom B C) (f : continuous_monoid_hom A B) :\n    map (comp g f) = comp (map f) (map g) :=\n  ext fun x => ext fun y => rfl\n#align map_comp map_comp\n\n",
 "map_apply":
 "@[simp]\ntheorem map_apply (f : continuous_monoid_hom A B) (x : pontryagin_dual B) (y : A) : map f x y = x (f y) :=\n  rfl\n#align map_apply map_apply\n\n",
 "inducing_to_continuous_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[to_additive]\ntheorem inducing_to_continuous_map : inducing (to_continuous_map : continuous_monoid_hom A B → «exprC( , )» A B) :=\n  ⟨rfl⟩\n#align inducing_to_continuous_map inducing_to_continuous_map\n\n",
 "ext":
 "/-\nCopyright (c) 2022 Thomas Browning. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning\n-/\n-- See note [lower instance priority]\n@[to_additive, ext]\ntheorem ext {f g : continuous_monoid_hom A B} (h : ∀ x, f x = g x) : f = g :=\n  fun_like.ext _ _ h\n#align ext ext\n\n",
 "embedding_to_continuous_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[to_additive]\ntheorem embedding_to_continuous_map : embedding (to_continuous_map : continuous_monoid_hom A B → «exprC( , )» A B) :=\n  ⟨inducing_to_continuous_map A B, to_continuous_map_injective⟩\n#align embedding_to_continuous_map embedding_to_continuous_map\n\n",
 "continuous_of_continuous_uncurry":
 "@[to_additive]\ntheorem continuous_of_continuous_uncurry {A : Type _} [topological_space A] (f : A → continuous_monoid_hom B C)\n    (h : continuous (function.uncurry fun x y => f x y)) : continuous f :=\n  (inducing_to_continuous_map _ _).continuous_iff.mpr (continuous_map.continuous_of_continuous_uncurry _ h)\n#align continuous_of_continuous_uncurry continuous_of_continuous_uncurry\n\n",
 "continuous_comp_right":
 "@[to_additive]\ntheorem continuous_comp_right (f : continuous_monoid_hom B C) :\n    continuous fun g : continuous_monoid_hom A B => f.comp g :=\n  (inducing_to_continuous_map A C).continuous_iff.2 <|\n    f.to_continuous_map.continuous_comp.comp (inducing_to_continuous_map A B).continuous\n#align continuous_comp_right continuous_comp_right\n\n",
 "continuous_comp_left":
 "@[to_additive]\ntheorem continuous_comp_left (f : continuous_monoid_hom A B) :\n    continuous fun g : continuous_monoid_hom B C => g.comp f :=\n  (inducing_to_continuous_map A C).continuous_iff.2 <|\n    f.to_continuous_map.continuous_comp_left.comp (inducing_to_continuous_map B C).continuous\n#align continuous_comp_left continuous_comp_left\n\n",
 "continuous_comp":
 "@[to_additive]\ntheorem continuous_comp [locally_compact_space B] :\n    continuous fun f : continuous_monoid_hom A B × continuous_monoid_hom B C => f.2.comp f.1 :=\n  (inducing_to_continuous_map A C).continuous_iff.2 <|\n    continuous_map.continuous_comp'.comp\n      ((inducing_to_continuous_map A B).prod_mk (inducing_to_continuous_map B C)).continuous\n#align continuous_comp continuous_comp\n\n",
 "closed_embedding_to_continuous_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[to_additive]\ntheorem closed_embedding_to_continuous_map [has_continuous_mul B] [t2_space B] :\n    closed_embedding (to_continuous_map : continuous_monoid_hom A B → «exprC( , )» A B) :=\n  ⟨embedding_to_continuous_map A B,\n    ⟨by\n      suffices\n        Set.range (to_continuous_map : continuous_monoid_hom A B → «exprC( , )» A B) =\n          «expr ᶜ»\n            ({ f | «expr '' » f {1} ⊆ «expr ᶜ» {1} } ∪\n              «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                ({ f | «expr '' » f {x} ⊆ U } ∩ { f | «expr '' » f {y} ⊆ V } ∩ { f | «expr '' » f {x * y} ⊆ W }))\n        by\n        rw [this, compl_compl]\n        refine' (continuous_map.is_open_gen is_compact_singleton is_open_compl_singleton).union _\n        repeat' apply is_open_Union; intro\n        repeat' apply is_open.inter\n        all_goals apply continuous_map.is_open_gen is_compact_singleton; assumption\n      simp_rw [Set.compl_union, Set.compl_unionᵢ, Set.image_singleton, Set.singleton_subset_iff, Set.ext_iff,\n        Set.mem_inter_iff, Set.mem_interᵢ, Set.mem_compl_iff]\n      refine' fun f => ⟨_, _⟩\n      · rintro ⟨f, rfl⟩\n        exact\n          ⟨fun h => h (map_one f), fun x y U V W hU hV hW h ⟨⟨hfU, hfV⟩, hfW⟩ =>\n            h.le_bot ⟨Set.mul_mem_mul hfU hfV, (congr_arg (· ∈ W) (map_mul f x y)).mp hfW⟩⟩\n      · rintro ⟨hf1, hf2⟩\n        suffices ∀ x y, f (x * y) = f x * f y by\n          refine'\n            ⟨({ f with\n                  map_one' := of_not_not hf1\n                  map_mul' := this } :\n                continuous_monoid_hom A B),\n              continuous_map.ext fun _ => rfl⟩\n        intro x y\n        contrapose! hf2\n        obtain ⟨UV, W, hUV, hW, hfUV, hfW, h⟩ := t2_separation hf2.symm\n        have hB := @continuous_mul B _ _ _\n        obtain ⟨U, V, hU, hV, hfU, hfV, h'⟩ := is_open_prod_iff.mp (hUV.preimage hB) (f x) (f y) hfUV\n        refine' ⟨x, y, U, V, W, hU, hV, hW, h.mono_left _, ⟨hfU, hfV⟩, hfW⟩\n        rintro _ ⟨x, y, hx : (x, y).1 ∈ U, hy : (x, y).2 ∈ V, rfl⟩\n        exact h' ⟨hx, hy⟩⟩⟩\n#align closed_embedding_to_continuous_map closed_embedding_to_continuous_map\n\n"}