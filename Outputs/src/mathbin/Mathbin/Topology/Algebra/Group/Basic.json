{"zpow":
 "#print ContinuousOn.zpow /-\n@[to_additive ContinuousOn.zsmul]\ntheorem ContinuousOn.zpow {f : α → G} {s : Set α} (hf : ContinuousOn f s) (z : ℤ) : ContinuousOn (fun x => f x ^ z) s :=\n  fun x hx => (hf x hx).zpow z\n#align continuous_on.zpow ContinuousOn.zpow\n#align continuous_on.zsmul ContinuousOn.zsmul\n-/\n\n",
 "topologicalGroup_infₛ":
 "#print topologicalGroup_infₛ /-\n@[to_additive]\ntheorem topologicalGroup_infₛ {ts : Set (TopologicalSpace G)} (h : ∀ t ∈ ts, @TopologicalGroup G t _) :\n    @TopologicalGroup G (infₛ ts) _ :=\n  { to_has_continuous_inv :=\n      @continuousInv_infₛ _ _ _ fun t ht => @topological_group.to_has_continuous_inv G t _ <| h t ht\n    to_has_continuous_mul :=\n      @continuousMul_infₛ _ _ _ fun t ht => @topological_group.to_has_continuous_mul G t _ <| h t ht }\n#align topological_group_Inf topologicalGroup_infₛ\n#align topological_add_group_Inf topologicalAddGroup_infₛ\n-/\n\n",
 "topologicalGroup_infᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print topologicalGroup_infᵢ /-\n@[to_additive]\ntheorem topologicalGroup_infᵢ {ts' : ι → TopologicalSpace G} (h' : ∀ i, @TopologicalGroup G (ts' i) _) :\n    @TopologicalGroup G\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (ts' i)) _ :=\n  by\n  rw [← infₛ_range]\n  exact topologicalGroup_infₛ (set.forall_range_iff.mpr h')\n#align topological_group_infi topologicalGroup_infᵢ\n#align topological_add_group_infi topologicalAddGroup_infᵢ\n-/\n\n",
 "topologicalGroup_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print topologicalGroup_inf /-\n@[to_additive]\ntheorem topologicalGroup_inf {t₁ t₂ : TopologicalSpace G} (h₁ : @TopologicalGroup G t₁ _)\n    (h₂ : @TopologicalGroup G t₂ _) : @TopologicalGroup G («expr ⊓ » t₁ t₂) _ :=\n  by\n  rw [inf_eq_infᵢ]\n  refine' topologicalGroup_infᵢ fun b => _\n  cases b <;> assumption\n#align topological_group_inf topologicalGroup_inf\n#align topological_add_group_inf topologicalAddGroup_inf\n-/\n\n",
 "topologicalGroup_induced":
 "#print topologicalGroup_induced /-\n@[to_additive]\nprotected theorem topologicalGroup_induced {F : Type _} [Group H] [MonoidHomClass F H G] (f : F) :\n    @TopologicalGroup H (induced f ‹_›) _ :=\n  letI := induced f ‹_›\n  Inducing.topologicalGroup f ⟨rfl⟩\n#align topological_group_induced topologicalGroup_induced\n#align topological_add_group_induced topologicalAddGroup_induced\n-/\n\n",
 "topologicalGroup":
 "#print Inducing.topologicalGroup /-\n@[to_additive]\nprotected theorem Inducing.topologicalGroup {F : Type _} [Group H] [TopologicalSpace H] [MonoidHomClass F H G] (f : F)\n    (hf : Inducing f) : TopologicalGroup H :=\n  { to_has_continuous_mul := hf.has_continuous_mul _\n    to_has_continuous_inv := hf.has_continuous_inv (map_inv f) }\n#align inducing.topological_group Inducing.topologicalGroup\n#align inducing.topological_add_group Inducing.topologicalAddGroup\n-/\n\n",
 "topologicalClosure_minimal":
 "#print Subgroup.topologicalClosure_minimal /-\n@[to_additive]\ntheorem Subgroup.topologicalClosure_minimal (s : Subgroup G) {t : Subgroup G} (h : s ≤ t) (ht : IsClosed (t : Set G)) :\n    s.topological_closure ≤ t :=\n  closure_minimal h ht\n#align subgroup.topological_closure_minimal Subgroup.topologicalClosure_minimal\n#align add_subgroup.topological_closure_minimal AddSubgroup.topologicalClosure_minimal\n-/\n\n",
 "topologicalClosure_map_subgroup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print DenseRange.topologicalClosure_map_subgroup /-\n@[to_additive]\ntheorem DenseRange.topologicalClosure_map_subgroup [Group H] [TopologicalSpace H] [TopologicalGroup H]\n    {f : «expr →* » G H} (hf : Continuous f) (hf' : DenseRange f) {s : Subgroup G}\n    (hs : s.topological_closure = «expr⊤») : (s.map f).topological_closure = «expr⊤» :=\n  by\n  rw [SetLike.ext'_iff] at hs⊢\n  simp only [Subgroup.topologicalClosure_coe, Subgroup.coe_top, ← dense_iff_closure_eq] at hs⊢\n  exact hf'.dense_image hf hs\n#align dense_range.topological_closure_map_subgroup DenseRange.topologicalClosure_map_subgroup\n#align dense_range.topological_closure_map_add_subgroup DenseRange.topologicalClosure_map_addSubgroup\n-/\n\n",
 "topologicalClosure_coe":
 "#print Subgroup.topologicalClosure_coe /-\n@[simp, to_additive]\ntheorem Subgroup.topologicalClosure_coe {s : Subgroup G} : (s.topological_closure : Set G) = closure s :=\n  rfl\n#align subgroup.topological_closure_coe Subgroup.topologicalClosure_coe\n#align add_subgroup.topological_closure_coe AddSubgroup.topologicalClosure_coe\n-/\n\n",
 "to_topological_space_le":
 "@[simp, to_additive]\ntheorem to_topological_space_le {x y : GroupTopology α} : x.to_topological_space ≤ y.to_topological_space ↔ x ≤ y :=\n  iff.rfl\n#align to_topological_space_le to_topological_space_le\n\n",
 "to_topological_space_injective":
 "@[to_additive]\ntheorem to_topological_space_injective :\n    function.injective (to_topological_space : GroupTopology α → TopologicalSpace α) := fun f g h =>\n  by\n  cases f\n  cases g\n  congr\n#align to_topological_space_injective to_topological_space_injective\n\n",
 "toTopologicalSpace_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print toTopologicalSpace_top /-\n@[simp, to_additive]\ntheorem toTopologicalSpace_top : («expr⊤» : GroupTopology α).to_topological_space = «expr⊤» :=\n  rfl\n#align to_topological_space_top toTopologicalSpace_top\n-/\n\n",
 "toTopologicalSpace_infₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print toTopologicalSpace_infₛ /-\n@[simp, to_additive]\ntheorem toTopologicalSpace_infₛ (s : Set (GroupTopology α)) :\n    (infₛ s).to_topological_space = infₛ («expr '' » to_topological_space s) :=\n  rfl\n#align to_topological_space_Inf toTopologicalSpace_infₛ\n-/\n\n",
 "toTopologicalSpace_infᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print toTopologicalSpace_infᵢ /-\n@[simp, to_additive]\ntheorem toTopologicalSpace_infᵢ {ι} (s : ι → GroupTopology α) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (s i)).to_topological_space =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (s i).to_topological_space :=\n  congr_arg infₛ (range_comp _ _).symm\n#align to_topological_space_infi toTopologicalSpace_infᵢ\n-/\n\n",
 "toTopologicalSpace_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print toTopologicalSpace_inf /-\n@[simp, to_additive]\ntheorem toTopologicalSpace_inf (x y : GroupTopology α) :\n    («expr ⊓ » x y).to_topological_space = «expr ⊓ » x.to_topological_space y.to_topological_space :=\n  rfl\n#align to_topological_space_inf toTopologicalSpace_inf\n-/\n\n",
 "toTopologicalSpace_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print toTopologicalSpace_bot /-\n@[simp, to_additive]\ntheorem toTopologicalSpace_bot : («expr⊥» : GroupTopology α).to_topological_space = «expr⊥» :=\n  rfl\n#align to_topological_space_bot toTopologicalSpace_bot\n-/\n\n",
 "tendsto_inv_nhdsWithin_Ioi_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n#print tendsto_inv_nhdsWithin_Ioi_inv /-\n@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Ioi_inv {a : H} : Tendsto has_inv.inv (nhds_within.gt a⁻¹) (nhds_within.lt a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhdsWithin_Ioi _ _ _ _ a⁻¹\n#align tendsto_inv_nhds_within_Ioi_inv tendsto_inv_nhdsWithin_Ioi_inv\n#align tendsto_neg_nhds_within_Ioi_neg tendsto_neg_nhdsWithin_Ioi_neg\n-/\n\n",
 "tendsto_inv_nhdsWithin_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n#print tendsto_inv_nhdsWithin_Ioi /-\n@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Ioi {a : H} : Tendsto has_inv.inv (nhds_within.gt a) (nhds_within.lt a⁻¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n#align tendsto_inv_nhds_within_Ioi tendsto_inv_nhdsWithin_Ioi\n#align tendsto_neg_nhds_within_Ioi tendsto_neg_nhdsWithin_Ioi\n-/\n\n",
 "tendsto_inv_nhdsWithin_Iio_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n#print tendsto_inv_nhdsWithin_Iio_inv /-\n@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Iio_inv {a : H} : Tendsto has_inv.inv (nhds_within.lt a⁻¹) (nhds_within.gt a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhdsWithin_Iio _ _ _ _ a⁻¹\n#align tendsto_inv_nhds_within_Iio_inv tendsto_inv_nhdsWithin_Iio_inv\n#align tendsto_neg_nhds_within_Iio_neg tendsto_neg_nhdsWithin_Iio_neg\n-/\n\n",
 "tendsto_inv_nhdsWithin_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n#print tendsto_inv_nhdsWithin_Iio /-\n@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Iio {a : H} : Tendsto has_inv.inv (nhds_within.lt a) (nhds_within.gt a⁻¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n#align tendsto_inv_nhds_within_Iio tendsto_inv_nhdsWithin_Iio\n#align tendsto_neg_nhds_within_Iio tendsto_neg_nhdsWithin_Iio\n-/\n\n",
 "tendsto_inv_nhdsWithin_Iic_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n#print tendsto_inv_nhdsWithin_Iic_inv /-\n@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Iic_inv {a : H} : Tendsto has_inv.inv (nhds_within.le a⁻¹) (nhds_within.ge a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhdsWithin_Iic _ _ _ _ a⁻¹\n#align tendsto_inv_nhds_within_Iic_inv tendsto_inv_nhdsWithin_Iic_inv\n#align tendsto_neg_nhds_within_Iic_neg tendsto_neg_nhdsWithin_Iic_neg\n-/\n\n",
 "tendsto_inv_nhdsWithin_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n#print tendsto_inv_nhdsWithin_Iic /-\n@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Iic {a : H} : Tendsto has_inv.inv (nhds_within.le a) (nhds_within.ge a⁻¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n#align tendsto_inv_nhds_within_Iic tendsto_inv_nhdsWithin_Iic\n#align tendsto_neg_nhds_within_Iic tendsto_neg_nhdsWithin_Iic\n-/\n\n",
 "tendsto_inv_nhdsWithin_Ici_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n#print tendsto_inv_nhdsWithin_Ici_inv /-\n@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Ici_inv {a : H} : Tendsto has_inv.inv (nhds_within.ge a⁻¹) (nhds_within.le a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhdsWithin_Ici _ _ _ _ a⁻¹\n#align tendsto_inv_nhds_within_Ici_inv tendsto_inv_nhdsWithin_Ici_inv\n#align tendsto_neg_nhds_within_Ici_neg tendsto_neg_nhdsWithin_Ici_neg\n-/\n\n",
 "tendsto_inv_nhdsWithin_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n#print tendsto_inv_nhdsWithin_Ici /-\n@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Ici {a : H} : Tendsto has_inv.inv (nhds_within.ge a) (nhds_within.le a⁻¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n#align tendsto_inv_nhds_within_Ici tendsto_inv_nhdsWithin_Ici\n#align tendsto_neg_nhds_within_Ici tendsto_neg_nhdsWithin_Ici\n-/\n\n",
 "tendsto_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_inv /-\n@[to_additive]\ntheorem tendsto_inv (a : G) : Tendsto has_inv.inv ((nhds) a) ((nhds) a⁻¹) :=\n  continuousAt_inv\n#align tendsto_inv tendsto_inv\n#align tendsto_neg tendsto_neg\n-/\n\n",
 "tendsto_div_nhds_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_div_nhds_one_iff /-\n@[to_additive]\ntheorem tendsto_div_nhds_one_iff {α : Type _} {l : Filter α} {x : G} {u : α → G} :\n    Tendsto (fun n => u n / x) l ((nhds) 1) ↔ Tendsto u l ((nhds) x) :=\n  haveI A : tendsto (fun n : α => x) l ((nhds) x) := tendsto_const_nhds\n  ⟨fun h => by simpa using h.mul A, fun h => by simpa using h.div' A⟩\n#align tendsto_div_nhds_one_iff tendsto_div_nhds_one_iff\n#align tendsto_sub_nhds_zero_iff tendsto_sub_nhds_zero_iff\n-/\n\n",
 "t3Space":
 "#print TopologicalGroup.t3Space /-\n@[to_additive]\ntheorem TopologicalGroup.t3Space [T0Space G] : T3Space G :=\n  ⟨⟩\n#align topological_group.t3_space TopologicalGroup.t3Space\n#align topological_add_group.t3_space TopologicalAddGroup.t3Space\n-/\n\n",
 "t2Space":
 "#print TopologicalGroup.t2Space /-\n@[to_additive]\ntheorem TopologicalGroup.t2Space [T0Space G] : T2Space G :=\n  by\n  haveI := TopologicalGroup.t3Space G\n  infer_instance\n#align topological_group.t2_space TopologicalGroup.t2Space\n#align topological_add_group.t2_space TopologicalAddGroup.t2Space\n-/\n\n",
 "t1Space":
 "#print TopologicalGroup.t1Space /-\n@[to_additive]\ntheorem TopologicalGroup.t1Space (h : @IsClosed G _ {1}) : T1Space G :=\n  ⟨fun x => by\n    convert isClosedMap_mul_right x _ h\n    simp⟩\n#align topological_group.t1_space TopologicalGroup.t1Space\n#align topological_add_group.t1_space TopologicalAddGroup.t1Space\n-/\n\n",
 "subset_interior_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print subset_interior_smul_right /-\n@[to_additive]\ntheorem subset_interior_smul_right : «expr • » s (interior t) ⊆ interior («expr • » s t) :=\n  interior_maximal (Set.smul_subset_smul_left interior_subset) isOpen_interior.smul_left\n#align subset_interior_smul_right subset_interior_smul_right\n#align subset_interior_vadd_right subset_interior_vadd_right\n-/\n\n",
 "subset_interior_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print subset_interior_smul /-\n@[to_additive]\ntheorem subset_interior_smul : «expr • » (interior s) (interior t) ⊆ interior («expr • » s t) :=\n  (Set.smul_subset_smul_right interior_subset).trans subset_interior_smul_right\n#align subset_interior_smul subset_interior_smul\n#align subset_interior_vadd subset_interior_vadd\n-/\n\n",
 "subset_interior_mul_right":
 "#print subset_interior_mul_right /-\n@[to_additive]\ntheorem subset_interior_mul_right : s * interior t ⊆ interior (s * t) :=\n  subset_interior_smul_right\n#align subset_interior_mul_right subset_interior_mul_right\n#align subset_interior_add_right subset_interior_add_right\n-/\n\n",
 "subset_interior_mul_left":
 "#print subset_interior_mul_left /-\n@[to_additive]\ntheorem subset_interior_mul_left : interior s * t ⊆ interior (s * t) :=\n  interior_maximal (Set.mul_subset_mul_right interior_subset) isOpen_interior.mul_right\n#align subset_interior_mul_left subset_interior_mul_left\n#align subset_interior_add_left subset_interior_add_left\n-/\n\n",
 "subset_interior_mul'":
 "#print subset_interior_mul' /-\n@[to_additive]\ntheorem subset_interior_mul' : interior s * interior t ⊆ interior (s * t) :=\n  (Set.mul_subset_mul_left interior_subset).trans subset_interior_mul_left\n#align subset_interior_mul' subset_interior_mul'\n#align subset_interior_add' subset_interior_add'\n-/\n\n",
 "subset_interior_mul":
 "#print subset_interior_mul /-\n@[to_additive]\ntheorem subset_interior_mul : interior s * interior t ⊆ interior (s * t) :=\n  subset_interior_smul\n#align subset_interior_mul subset_interior_mul\n#align subset_interior_add subset_interior_add\n-/\n\n",
 "subset_interior_div_right":
 "#print subset_interior_div_right /-\n@[to_additive]\ntheorem subset_interior_div_right : s / interior t ⊆ interior (s / t) :=\n  interior_maximal (div_subset_div_left interior_subset) isOpen_interior.div_left\n#align subset_interior_div_right subset_interior_div_right\n#align subset_interior_sub_right subset_interior_sub_right\n-/\n\n",
 "subset_interior_div_left":
 "#print subset_interior_div_left /-\n@[to_additive]\ntheorem subset_interior_div_left : interior s / t ⊆ interior (s / t) :=\n  interior_maximal (div_subset_div_right interior_subset) isOpen_interior.div_right\n#align subset_interior_div_left subset_interior_div_left\n#align subset_interior_sub_left subset_interior_sub_left\n-/\n\n",
 "subset_interior_div":
 "#print subset_interior_div /-\n@[to_additive]\ntheorem subset_interior_div : interior s / interior t ⊆ interior (s / t) :=\n  (div_subset_div_left interior_subset).trans subset_interior_div_left\n#align subset_interior_div subset_interior_div\n#align subset_interior_sub subset_interior_sub\n-/\n\n",
 "smul_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_mem_nhds /-\n@[to_additive]\ntheorem smul_mem_nhds (a : α) {x : β} (ht : t ∈ (nhds) x) : «expr • » a t ∈ (nhds) («expr • » a x) :=\n  by\n  rcases mem_nhds_iff.1 ht with ⟨u, ut, u_open, hu⟩\n  exact mem_nhds_iff.2 ⟨«expr • » a u, smul_set_mono ut, u_open.smul a, smul_mem_smul_set hu⟩\n#align smul_mem_nhds smul_mem_nhds\n#align vadd_mem_nhds vadd_mem_nhds\n-/\n\n",
 "smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print IsOpen.smul_left /-\n@[to_additive]\ntheorem IsOpen.smul_left (ht : IsOpen t) : IsOpen («expr • » s t) :=\n  by\n  rw [← bUnion_smul_set]\n  exact isOpen_bunionᵢ fun a _ => ht.smul _\n#align is_open.smul_left IsOpen.smul_left\n#align is_open.vadd_left IsOpen.vadd_left\n-/\n\n",
 "singleton_mul_mem_nhds_of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print singleton_mul_mem_nhds_of_nhds_one /-\n@[to_additive]\ntheorem singleton_mul_mem_nhds_of_nhds_one (a : α) (h : s ∈ (nhds) (1 : α)) : {a} * s ∈ (nhds) a := by\n  simpa only [mul_one] using singleton_mul_mem_nhds a h\n#align singleton_mul_mem_nhds_of_nhds_one singleton_mul_mem_nhds_of_nhds_one\n#align singleton_add_mem_nhds_of_nhds_zero singleton_add_mem_nhds_of_nhds_zero\n-/\n\n",
 "singleton_mul_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print singleton_mul_mem_nhds /-\n@[to_additive]\ntheorem singleton_mul_mem_nhds (a : α) {b : α} (h : s ∈ (nhds) b) : {a} * s ∈ (nhds) (a * b) :=\n  by\n  have := smul_mem_nhds a h\n  rwa [← singleton_smul] at this\n#align singleton_mul_mem_nhds singleton_mul_mem_nhds\n#align singleton_add_mem_nhds singleton_add_mem_nhds\n-/\n\n",
 "shearMulRight_symm_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print Homeomorph.shearMulRight_symm_coe /-\n@[simp, to_additive]\ntheorem Homeomorph.shearMulRight_symm_coe :\n    «expr⇑ » (Homeomorph.shearMulRight G).symm = fun z : G × G => (z.1, z.1⁻¹ * z.2) :=\n  rfl\n#align homeomorph.shear_mul_right_symm_coe Homeomorph.shearMulRight_symm_coe\n#align homeomorph.shear_add_right_symm_coe Homeomorph.shearAddRight_symm_coe\n-/\n\n",
 "shearMulRight_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print Homeomorph.shearMulRight_coe /-\n@[simp, to_additive]\ntheorem Homeomorph.shearMulRight_coe : «expr⇑ » (Homeomorph.shearMulRight G) = fun z : G × G => (z.1, z.1 * z.2) :=\n  rfl\n#align homeomorph.shear_mul_right_coe Homeomorph.shearMulRight_coe\n#align homeomorph.shear_add_right_coe Homeomorph.shearAddRight_coe\n-/\n\n",
 "rightCoset":
 "#print IsClosed.rightCoset /-\n@[to_additive IsClosed.right_addCoset]\ntheorem IsClosed.rightCoset {U : Set G} (h : IsClosed U) (x : G) : IsClosed (rightCoset U x) :=\n  isClosedMap_mul_right x _ h\n#align is_closed.right_coset IsClosed.rightCoset\n#align is_closed.right_add_coset IsClosed.right_addCoset\n-/\n\n",
 "properlyDiscontinuousSMul_opposite_of_tendsto_cofinite":
 "#print Subgroup.properlyDiscontinuousSMul_opposite_of_tendsto_cofinite /-\n/-- A subgroup `S` of a topological group `G` acts on `G` properly discontinuously on the right, if\nit is discrete in the sense that `S ∩ K` is finite for all compact `K`. (See also\n`discrete_topology`.)\n\nIf `G` is Hausdorff, this can be combined with `t2_space_of_properly_discontinuous_smul_of_t2_space`\nto show that the quotient group `G ⧸ S` is Hausdorff. -/\n@[to_additive\n      \"A subgroup `S` of an additive topological group `G` acts on `G` properly\\ndiscontinuously on the right, if it is discrete in the sense that `S ∩ K` is finite for all compact\\n`K`. (See also `discrete_topology`.)\\n\\nIf `G` is Hausdorff, this can be combined with `t2_space_of_properly_discontinuous_vadd_of_t2_space`\\nto show that the quotient group `G ⧸ S` is Hausdorff.\"]\ntheorem Subgroup.properlyDiscontinuousSMul_opposite_of_tendsto_cofinite (S : Subgroup G)\n    (hS : Tendsto S.subtype cofinite (cocompact G)) : ProperlyDiscontinuousSMul S.opposite G :=\n  {\n    finite_disjoint_inter_image := by\n      intro K L hK hL\n      have : Continuous fun p : G × G => (p.1⁻¹, p.2) := continuous_inv.prod_map continuous_id\n      have H : Set.Finite _ := hS ((hK.prod hL).image (continuous_mul.comp this)).compl_mem_cocompact\n      rw [preimage_compl, compl_compl] at H\n      convert H\n      ext x\n      simpa only [image_smul, mem_image, Prod.exists] using Set.op_smul_inter_ne_empty_iff }\n#align subgroup.properly_discontinuous_smul_opposite_of_tendsto_cofinite Subgroup.properlyDiscontinuousSMul_opposite_of_tendsto_cofinite\n#align add_subgroup.properly_discontinuous_vadd_opposite_of_tendsto_cofinite AddSubgroup.properlyDiscontinuousVAdd_opposite_of_tendsto_cofinite\n-/\n\n",
 "properlyDiscontinuousSMul_of_tendsto_cofinite":
 "#print Subgroup.properlyDiscontinuousSMul_of_tendsto_cofinite /-\n/-- A subgroup `S` of a topological group `G` acts on `G` properly discontinuously on the left, if\nit is discrete in the sense that `S ∩ K` is finite for all compact `K`. (See also\n`discrete_topology`.) -/\n@[to_additive\n      \"A subgroup `S` of an additive topological group `G` acts on `G` properly\\ndiscontinuously on the left, if it is discrete in the sense that `S ∩ K` is finite for all compact\\n`K`. (See also `discrete_topology`.\"]\ntheorem Subgroup.properlyDiscontinuousSMul_of_tendsto_cofinite (S : Subgroup G)\n    (hS : Tendsto S.subtype cofinite (cocompact G)) : ProperlyDiscontinuousSMul S G :=\n  {\n    finite_disjoint_inter_image := by\n      intro K L hK hL\n      have H : Set.Finite _ := hS ((hL.prod hK).image continuous_div').compl_mem_cocompact\n      rw [preimage_compl, compl_compl] at H\n      convert H\n      ext x\n      simpa only [image_smul, mem_image, Prod.exists] using Set.smul_inter_ne_empty_iff' }\n#align subgroup.properly_discontinuous_smul_of_tendsto_cofinite Subgroup.properlyDiscontinuousSMul_of_tendsto_cofinite\n#align add_subgroup.properly_discontinuous_vadd_of_tendsto_cofinite AddSubgroup.properlyDiscontinuousVAdd_of_tendsto_cofinite\n-/\n\n",
 "of_nhds_one'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print TopologicalGroup.of_nhds_one' /-\n@[to_additive]\ntheorem TopologicalGroup.of_nhds_one' {G : Type u} [Group G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((· * ·) : G → G → G)) (filter.prod ((nhds) 1) ((nhds) 1)) ((nhds) 1))\n    (hinv : Tendsto (fun x : G => x⁻¹) ((nhds) 1) ((nhds) 1))\n    (hleft : ∀ x₀ : G, (nhds) x₀ = map (fun x => x₀ * x) ((nhds) 1))\n    (hright : ∀ x₀ : G, (nhds) x₀ = map (fun x => x * x₀) ((nhds) 1)) : TopologicalGroup G :=\n  { to_has_continuous_mul := ContinuousMul.of_nhds_one hmul hleft hright\n    to_has_continuous_inv :=\n      ContinuousInv.of_nhds_one hinv hleft fun x₀ =>\n        le_of_eq\n          (by\n            rw [show (fun x => x₀ * x * x₀⁻¹) = (fun x => x * x₀⁻¹) ∘ fun x => x₀ * x from rfl, ← map_map, ← hleft,\n              hright, map_map]\n            simp [(· ∘ ·)]) }\n#align topological_group.of_nhds_one' TopologicalGroup.of_nhds_one'\n#align topological_add_group.of_nhds_zero' TopologicalAddGroup.of_nhds_zero'\n-/\n\n",
 "of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print TopologicalGroup.of_nhds_one /-\n@[to_additive]\ntheorem TopologicalGroup.of_nhds_one {G : Type u} [Group G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((· * ·) : G → G → G)) (filter.prod ((nhds) 1) ((nhds) 1)) ((nhds) 1))\n    (hinv : Tendsto (fun x : G => x⁻¹) ((nhds) 1) ((nhds) 1))\n    (hleft : ∀ x₀ : G, (nhds) x₀ = map (fun x => x₀ * x) ((nhds) 1))\n    (hconj : ∀ x₀ : G, Tendsto (fun x => x₀ * x * x₀⁻¹) ((nhds) 1) ((nhds) 1)) : TopologicalGroup G :=\n  by\n  refine' TopologicalGroup.of_nhds_one' hmul hinv hleft fun x₀ => _\n  replace hconj : ∀ x₀ : G, map (fun x => x₀ * x * x₀⁻¹) ((nhds) 1) = (nhds) 1\n  exact fun x₀ =>\n    map_eq_of_inverse (fun x => x₀⁻¹ * x * x₀⁻¹⁻¹)\n      (by\n        ext\n        simp [mul_assoc])\n      (hconj _) (hconj _)\n  rw [← hconj x₀]\n  simpa [(· ∘ ·)] using hleft _\n#align topological_group.of_nhds_one TopologicalGroup.of_nhds_one\n#align topological_add_group.of_nhds_zero TopologicalAddGroup.of_nhds_zero\n-/\n\n",
 "of_comm_of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print TopologicalGroup.of_comm_of_nhds_one /-\n@[to_additive]\ntheorem TopologicalGroup.of_comm_of_nhds_one {G : Type u} [CommGroup G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((· * ·) : G → G → G)) (filter.prod ((nhds) 1) ((nhds) 1)) ((nhds) 1))\n    (hinv : Tendsto (fun x : G => x⁻¹) ((nhds) 1) ((nhds) 1))\n    (hleft : ∀ x₀ : G, (nhds) x₀ = map (fun x => x₀ * x) ((nhds) 1)) : TopologicalGroup G :=\n  TopologicalGroup.of_nhds_one hmul hinv hleft (by simpa using tendsto_id)\n#align topological_group.of_comm_of_nhds_one TopologicalGroup.of_comm_of_nhds_one\n#align topological_add_group.of_comm_of_nhds_zero TopologicalAddGroup.of_comm_of_nhds_zero\n-/\n\n",
 "nhds_translation_mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_translation_mul_inv /-\n@[to_additive]\ntheorem nhds_translation_mul_inv (x : G) : comap (fun y : G => y * x⁻¹) ((nhds) 1) = (nhds) x :=\n  ((Homeomorph.mulRight x⁻¹).comap_nhds_eq 1).trans <| show (nhds) (1 * x⁻¹⁻¹) = (nhds) x by simp\n#align nhds_translation_mul_inv nhds_translation_mul_inv\n#align nhds_translation_add_neg nhds_translation_add_neg\n-/\n\n",
 "nhds_translation_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_translation_div /-\n@[to_additive]\ntheorem nhds_translation_div (x : G) : comap (· / x) ((nhds) 1) = (nhds) x := by\n  simpa only [div_eq_mul_inv] using nhds_translation_mul_inv x\n#align nhds_translation_div nhds_translation_div\n#align nhds_translation_sub nhds_translation_sub\n-/\n\n",
 "nhds_one_symm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_one_symm' /-\n@[to_additive]\ntheorem nhds_one_symm' : map has_inv.inv ((nhds) (1 : G)) = (nhds) (1 : G) :=\n  ((Homeomorph.inv G).map_nhds_eq _).trans (congr_arg nhds inv_one)\n#align nhds_one_symm' nhds_one_symm'\n#align nhds_zero_symm' nhds_zero_symm'\n-/\n\n",
 "nhds_one_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_one_symm /-\n@[to_additive]\ntheorem nhds_one_symm : comap has_inv.inv ((nhds) (1 : G)) = (nhds) (1 : G) :=\n  ((Homeomorph.inv G).comap_nhds_eq _).trans (congr_arg nhds inv_one)\n#align nhds_one_symm nhds_one_symm\n#align nhds_zero_symm nhds_zero_symm\n-/\n\n",
 "nhds_of_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.HasBasis.nhds_of_one /-\n@[to_additive]\ntheorem Filter.HasBasis.nhds_of_one {ι : Sort _} {p : ι → Prop} {s : ι → Set G}\n    (hb : HasBasis ((nhds) 1 : Filter G) p s) (x : G) : HasBasis ((nhds) x) p fun i => { y | y / x ∈ s i } :=\n  by\n  rw [← nhds_translation_mul_inv]\n  simp_rw [div_eq_mul_inv]\n  exact hb.comap _\n#align filter.has_basis.nhds_of_one Filter.HasBasis.nhds_of_one\n#align filter.has_basis.nhds_of_zero Filter.HasBasis.nhds_of_zero\n-/\n\n",
 "nhds_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_mul /-\n@[to_additive]\ntheorem nhds_mul (x y : G) : (nhds) (x * y) = (nhds) x * (nhds) y :=\n  calc\n    (nhds) (x * y) = map ((· * ·) x) (map (fun a => a * y) ((nhds) 1 * (nhds) 1)) := by simp\n    _ = map₂ (fun a b => x * (a * b * y)) ((nhds) 1) ((nhds) 1) := by rw [← map₂_mul, map_map₂, map_map₂]\n    _ = map₂ (fun a b => x * a * (b * y)) ((nhds) 1) ((nhds) 1) := by simp only [mul_assoc]\n    _ = (nhds) x * (nhds) y := by\n      rw [← map_mul_left_nhds_one x, ← map_mul_right_nhds_one y, ← map₂_mul, map₂_map_left, map₂_map_right]\n    \n#align nhds_mul nhds_mul\n#align nhds_add nhds_add\n-/\n\n",
 "nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print QuotientGroup.nhds_eq /-\n/-- Neighborhoods in the quotient are precisely the map of neighborhoods in the prequotient. -/\n@[to_additive \"Neighborhoods in the quotient are precisely the map of neighborhoods in\\nthe prequotient.\"]\ntheorem QuotientGroup.nhds_eq (x : G) : (nhds) (x : «expr ⧸ » G N) = map coe ((nhds) x) :=\n  le_antisymm ((QuotientGroup.isOpenMap_coe N).nhds_le x) continuous_quot_mk.continuous_at\n#align quotient_group.nhds_eq QuotientGroup.nhds_eq\n#align quotient_add_group.nhds_eq QuotientAddGroup.nhds_eq\n-/\n\n",
 "mul_singleton_mem_nhds_of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mul_singleton_mem_nhds_of_nhds_one /-\n@[to_additive]\ntheorem mul_singleton_mem_nhds_of_nhds_one (a : α) (h : s ∈ (nhds) (1 : α)) : s * {a} ∈ (nhds) a := by\n  simpa only [one_mul] using mul_singleton_mem_nhds a h\n#align mul_singleton_mem_nhds_of_nhds_one mul_singleton_mem_nhds_of_nhds_one\n#align add_singleton_mem_nhds_of_nhds_zero add_singleton_mem_nhds_of_nhds_zero\n-/\n\n",
 "mul_singleton_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mul_singleton_mem_nhds /-\n@[to_additive]\ntheorem mul_singleton_mem_nhds (a : α) {b : α} (h : s ∈ (nhds) b) : s * {a} ∈ (nhds) (b * a) :=\n  by\n  simp only [← bUnion_op_smul_set, mem_singleton_iff, Union_Union_eq_left]\n  exact smul_mem_nhds _ h\n#align mul_singleton_mem_nhds mul_singleton_mem_nhds\n#align add_singleton_mem_nhds add_singleton_mem_nhds\n-/\n\n",
 "mul_right":
 "#print IsOpen.mul_right /-\n@[to_additive]\ntheorem IsOpen.mul_right (hs : IsOpen s) : IsOpen (s * t) :=\n  by\n  rw [← bUnion_op_smul_set]\n  exact isOpen_bunionᵢ fun a _ => hs.smul _\n#align is_open.mul_right IsOpen.mul_right\n#align is_open.add_right IsOpen.add_right\n-/\n\n",
 "mul_mem_connectedComponent_one":
 "#print mul_mem_connectedComponent_one /-\n@[to_additive]\ntheorem mul_mem_connectedComponent_one {G : Type _} [TopologicalSpace G] [MulOneClass G] [ContinuousMul G] {g h : G}\n    (hg : g ∈ connectedComponent (1 : G)) (hh : h ∈ connectedComponent (1 : G)) : g * h ∈ connectedComponent (1 : G) :=\n  by\n  rw [connectedComponent_eq hg]\n  have hmul : g ∈ connectedComponent (g * h) :=\n    by\n    apply Continuous.image_connectedComponent_subset (continuous_mul_left g)\n    rw [← connectedComponent_eq hh]\n    exact ⟨(1 : G), mem_connectedComponent, by simp only [mul_one]⟩\n  simpa [← connectedComponent_eq hmul] using mem_connectedComponent\n#align mul_mem_connected_component_one mul_mem_connectedComponent_one\n#align add_mem_connected_component_zero add_mem_connectedComponent_zero\n-/\n\n",
 "mul_left":
 "#print IsOpen.mul_left /-\n@[to_additive]\ntheorem IsOpen.mul_left : IsOpen t → IsOpen (s * t) :=\n  IsOpen.smul_left\n#align is_open.mul_left IsOpen.mul_left\n#align is_open.add_left IsOpen.add_left\n-/\n\n",
 "mul_closure":
 "#print IsOpen.mul_closure /-\n@[to_additive]\ntheorem IsOpen.mul_closure (hs : IsOpen s) (t : Set α) : s * closure t = s * t :=\n  by\n  refine' (mul_subset_iff.2 fun a ha b hb => _).antisymm (mul_subset_mul_left subset_closure)\n  rw [mem_closure_iff] at hb\n  have hbU : b ∈ s⁻¹ * {a * b} := ⟨a⁻¹, a * b, Set.inv_mem_inv.2 ha, rfl, inv_mul_cancel_left _ _⟩\n  obtain ⟨_, ⟨c, d, hc, rfl : d = _, rfl⟩, hcs⟩ := hb _ hs.inv.mul_right hbU\n  exact ⟨c⁻¹, _, hc, hcs, inv_mul_cancel_left _ _⟩\n#align is_open.mul_closure IsOpen.mul_closure\n#align is_open.add_closure IsOpen.add_closure\n-/\n\n",
 "mulRight_symm":
 "#print Homeomorph.mulRight_symm /-\n@[to_additive]\ntheorem Homeomorph.mulRight_symm (a : G) : (Homeomorph.mulRight a).symm = Homeomorph.mulRight a⁻¹ :=\n  by\n  ext\n  rfl\n#align homeomorph.mul_right_symm Homeomorph.mulRight_symm\n#align homeomorph.add_right_symm Homeomorph.addRight_symm\n-/\n\n",
 "mulLeft_symm":
 "#print Homeomorph.mulLeft_symm /-\n@[to_additive]\ntheorem Homeomorph.mulLeft_symm (a : G) : (Homeomorph.mulLeft a).symm = Homeomorph.mulLeft a⁻¹ :=\n  by\n  ext\n  rfl\n#align homeomorph.mul_left_symm Homeomorph.mulLeft_symm\n#align homeomorph.add_left_symm Homeomorph.addLeft_symm\n-/\n\n",
 "mem_closure_iff_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_nhds_one /-\n@[to_additive]\ntheorem mem_closure_iff_nhds_one {x : G} {s : Set G} :\n    x ∈ closure s ↔ ∀ U ∈ ((nhds) 1 : Filter G), ∃ y ∈ s, y / x ∈ U :=\n  by\n  rw [mem_closure_iff_nhds_basis (((nhds) 1 : Filter G).basis_sets.nhds_of_one x)]\n  rfl\n#align mem_closure_iff_nhds_one mem_closure_iff_nhds_one\n#align mem_closure_iff_nhds_zero mem_closure_iff_nhds_zero\n-/\n\n",
 "map_mul_right_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print map_mul_right_nhds_one /-\n@[to_additive]\ntheorem map_mul_right_nhds_one (x : G) : map (fun y => y * x) ((nhds) 1) = (nhds) x := by simp\n#align map_mul_right_nhds_one map_mul_right_nhds_one\n#align map_add_right_nhds_zero map_add_right_nhds_zero\n-/\n\n",
 "map_mul_right_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print map_mul_right_nhds /-\n@[simp, to_additive]\ntheorem map_mul_right_nhds (x y : G) : map (fun z => z * x) ((nhds) y) = (nhds) (y * x) :=\n  (Homeomorph.mulRight x).map_nhds_eq y\n#align map_mul_right_nhds map_mul_right_nhds\n#align map_add_right_nhds map_add_right_nhds\n-/\n\n",
 "map_mul_left_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print map_mul_left_nhds_one /-\n@[to_additive]\ntheorem map_mul_left_nhds_one (x : G) : map ((· * ·) x) ((nhds) 1) = (nhds) x := by simp\n#align map_mul_left_nhds_one map_mul_left_nhds_one\n#align map_add_left_nhds_zero map_add_left_nhds_zero\n-/\n\n",
 "map_mul_left_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print map_mul_left_nhds /-\n@[simp, to_additive]\ntheorem map_mul_left_nhds (x y : G) : map ((· * ·) x) ((nhds) y) = (nhds) (x * y) :=\n  (Homeomorph.mulLeft x).map_nhds_eq y\n#align map_mul_left_nhds map_mul_left_nhds\n#align map_add_left_nhds map_add_left_nhds\n-/\n\n",
 "local_isCompact_isClosed_nhds_of_group":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print local_isCompact_isClosed_nhds_of_group /-\n/-- In a locally compact group, any neighborhood of the identity contains a compact closed\nneighborhood of the identity, even without separation assumptions on the space. -/\n@[to_additive\n      \"In a locally compact additive group, any neighborhood of the identity contains a\\ncompact closed neighborhood of the identity, even without separation assumptions on the space.\"]\ntheorem local_isCompact_isClosed_nhds_of_group [LocallyCompactSpace G] {U : Set G} (hU : U ∈ (nhds) (1 : G)) :\n    ∃ K : Set G, IsCompact K ∧ IsClosed K ∧ K ⊆ U ∧ (1 : G) ∈ interior K :=\n  by\n  obtain ⟨L, Lint, LU, Lcomp⟩ : ∃ (L : Set G)(H : L ∈ (nhds) (1 : G)), L ⊆ U ∧ IsCompact L\n  exact local_compact_nhds hU\n  obtain ⟨V, Vnhds, hV⟩ : ∃ V ∈ (nhds) (1 : G), ∀ v ∈ V, ∀ w ∈ V, v * w ∈ L :=\n    by\n    have : «expr ⁻¹' » (fun p : G × G => p.1 * p.2) L ∈ (nhds) ((1, 1) : G × G) :=\n      by\n      refine' continuous_at_fst.mul continuousAt_snd _\n      simpa only [mul_one] using Lint\n    simpa only [div_eq_mul_inv, nhds_prod_eq, mem_prod_self_iff, prod_subset_iff, mem_preimage]\n  have VL : closure V ⊆ L :=\n    calc\n      closure V = {(1 : G)} * closure V := by simp only [singleton_mul, one_mul, image_id']\n      _ ⊆ interior V * closure V :=\n        (mul_subset_mul_right (by simpa only [singleton_subset_iff] using mem_interior_iff_mem_nhds.2 Vnhds))\n      _ = interior V * V := (is_open_interior.mul_closure _)\n      _ ⊆ V * V := (mul_subset_mul_right interior_subset)\n      _ ⊆ L := by\n        rintro x ⟨y, z, yv, zv, rfl⟩\n        exact hV _ yv _ zv\n      \n  exact\n    ⟨closure V, isCompact_of_isClosed_subset Lcomp isClosed_closure VL, isClosed_closure, VL.trans LU,\n      interior_mono subset_closure (mem_interior_iff_mem_nhds.2 Vnhds)⟩\n#align local_is_compact_is_closed_nhds_of_group local_isCompact_isClosed_nhds_of_group\n#align local_is_compact_is_closed_nhds_of_add_group local_isCompact_isClosed_nhds_of_addGroup\n-/\n\n",
 "leftCoset":
 "#print IsClosed.leftCoset /-\n@[to_additive IsClosed.left_addCoset]\ntheorem IsClosed.leftCoset {U : Set G} (h : IsClosed U) (x : G) : IsClosed (leftCoset x U) :=\n  isClosedMap_mul_left x _ h\n#align is_closed.left_coset IsClosed.leftCoset\n#align is_closed.left_add_coset IsClosed.left_addCoset\n-/\n\n",
 "le_topologicalClosure":
 "#print Subgroup.le_topologicalClosure /-\n@[to_additive]\ntheorem Subgroup.le_topologicalClosure (s : Subgroup G) : s ≤ s.topological_closure :=\n  subset_closure\n#align subgroup.le_topological_closure Subgroup.le_topologicalClosure\n#align add_subgroup.le_topological_closure AddSubgroup.le_topologicalClosure\n-/\n\n",
 "is_normal_topologicalClosure":
 "#print Subgroup.is_normal_topologicalClosure /-\n/-- The topological closure of a normal subgroup is normal.-/\n@[to_additive \"The topological closure of a normal additive subgroup is normal.\"]\ntheorem Subgroup.is_normal_topologicalClosure {G : Type _} [TopologicalSpace G] [Group G] [TopologicalGroup G]\n    (N : Subgroup G) [N.normal] : (Subgroup.topologicalClosure N).normal :=\n  {\n    conj_mem := fun n hn g => by\n      apply map_mem_closure (TopologicalGroup.continuous_conj g) hn\n      exact fun m hm => subgroup.normal.conj_mem inferInstance m hm g }\n#align subgroup.is_normal_topological_closure Subgroup.is_normal_topologicalClosure\n#align add_subgroup.is_normal_topological_closure AddSubgroup.is_normal_topologicalClosure\n-/\n\n",
 "isOpenMap_mul_right":
 "#print isOpenMap_mul_right /-\n@[to_additive]\ntheorem isOpenMap_mul_right (a : G) : IsOpenMap fun x => x * a :=\n  (Homeomorph.mulRight a).is_open_map\n#align is_open_map_mul_right isOpenMap_mul_right\n#align is_open_map_add_right isOpenMap_add_right\n-/\n\n",
 "isOpenMap_mul_left":
 "#print isOpenMap_mul_left /-\n@[to_additive]\ntheorem isOpenMap_mul_left (a : G) : IsOpenMap fun x => a * x :=\n  (Homeomorph.mulLeft a).is_open_map\n#align is_open_map_mul_left isOpenMap_mul_left\n#align is_open_map_add_left isOpenMap_add_left\n-/\n\n",
 "isOpenMap_inv":
 "#print isOpenMap_inv /-\n@[to_additive]\ntheorem isOpenMap_inv : IsOpenMap (has_inv.inv : G → G) :=\n  (Homeomorph.inv _).is_open_map\n#align is_open_map_inv isOpenMap_inv\n#align is_open_map_neg isOpenMap_neg\n-/\n\n",
 "isOpenMap_div_right":
 "#print isOpenMap_div_right /-\n@[to_additive]\ntheorem isOpenMap_div_right (a : G) : IsOpenMap fun x => x / a :=\n  (Homeomorph.divRight a).is_open_map\n#align is_open_map_div_right isOpenMap_div_right\n#align is_open_map_sub_right isOpenMap_sub_right\n-/\n\n",
 "isOpenMap_div_left":
 "#print isOpenMap_div_left /-\n@[to_additive]\ntheorem isOpenMap_div_left (a : G) : IsOpenMap ((· / ·) a) :=\n  (Homeomorph.divLeft _).is_open_map\n#align is_open_map_div_left isOpenMap_div_left\n#align is_open_map_sub_left isOpenMap_sub_left\n-/\n\n",
 "isOpenMap_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print QuotientGroup.isOpenMap_coe /-\n@[to_additive]\ntheorem QuotientGroup.isOpenMap_coe : IsOpenMap (coe : G → «expr ⧸ » G N) :=\n  by\n  intro s s_op\n  change IsOpen («expr ⁻¹' » (coe : G → «expr ⧸ » G N) («expr '' » coe s))\n  rw [QuotientGroup.preimage_image_mk N s]\n  exact isOpen_unionᵢ fun n => (continuous_mul_right _).is_open_preimage s s_op\n#align quotient_group.is_open_map_coe QuotientGroup.isOpenMap_coe\n#align quotient_add_group.is_open_map_coe QuotientAddGroup.isOpenMap_coe\n-/\n\n",
 "isClosed_topologicalClosure":
 "#print Subgroup.isClosed_topologicalClosure /-\n@[to_additive]\ntheorem Subgroup.isClosed_topologicalClosure (s : Subgroup G) : IsClosed (s.topological_closure : Set G) := by\n  convert isClosed_closure\n#align subgroup.is_closed_topological_closure Subgroup.isClosed_topologicalClosure\n#align add_subgroup.is_closed_topological_closure AddSubgroup.isClosed_topologicalClosure\n-/\n\n",
 "isClosed_setOf_map_inv":
 "#print isClosed_setOf_map_inv /-\n@[to_additive]\ntheorem isClosed_setOf_map_inv [Inv G₁] [Inv G₂] [ContinuousInv G₂] : IsClosed { f : G₁ → G₂ | ∀ x, f x⁻¹ = (f x)⁻¹ } :=\n  by\n  simp only [set_of_forall]\n  refine' isClosed_interᵢ fun i => isClosed_eq (continuous_apply _) (continuous_apply _).inv\n#align is_closed_set_of_map_inv isClosed_setOf_map_inv\n#align is_closed_set_of_map_neg isClosed_setOf_map_neg\n-/\n\n",
 "isClosedMap_mul_right":
 "#print isClosedMap_mul_right /-\n@[to_additive]\ntheorem isClosedMap_mul_right (a : G) : IsClosedMap fun x => x * a :=\n  (Homeomorph.mulRight a).is_closed_map\n#align is_closed_map_mul_right isClosedMap_mul_right\n#align is_closed_map_add_right isClosedMap_add_right\n-/\n\n",
 "isClosedMap_mul_left":
 "#print isClosedMap_mul_left /-\n@[to_additive]\ntheorem isClosedMap_mul_left (a : G) : IsClosedMap fun x => a * x :=\n  (Homeomorph.mulLeft a).is_closed_map\n#align is_closed_map_mul_left isClosedMap_mul_left\n#align is_closed_map_add_left isClosedMap_add_left\n-/\n\n",
 "isClosedMap_inv":
 "#print isClosedMap_inv /-\n@[to_additive]\ntheorem isClosedMap_inv : IsClosedMap (has_inv.inv : G → G) :=\n  (Homeomorph.inv _).is_closed_map\n#align is_closed_map_inv isClosedMap_inv\n#align is_closed_map_neg isClosedMap_neg\n-/\n\n",
 "isClosedMap_div_right":
 "#print isClosedMap_div_right /-\n@[to_additive]\ntheorem isClosedMap_div_right (a : G) : IsClosedMap fun x => x / a :=\n  (Homeomorph.divRight a).is_closed_map\n#align is_closed_map_div_right isClosedMap_div_right\n#align is_closed_map_sub_right isClosedMap_sub_right\n-/\n\n",
 "isClosedMap_div_left":
 "#print isClosedMap_div_left /-\n@[to_additive]\ntheorem isClosedMap_div_left (a : G) : IsClosedMap ((· / ·) a) :=\n  (Homeomorph.divLeft _).is_closed_map\n#align is_closed_map_div_left isClosedMap_div_left\n#align is_closed_map_sub_left isClosedMap_sub_left\n-/\n\n",
 "inv_mem_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print inv_mem_nhds_one /-\n@[to_additive]\ntheorem inv_mem_nhds_one {S : Set G} (hS : S ∈ ((nhds) 1 : Filter G)) : S⁻¹ ∈ (nhds) (1 : G) := by\n  rwa [← nhds_one_symm'] at hS\n#align inv_mem_nhds_one inv_mem_nhds_one\n#align neg_mem_nhds_zero neg_mem_nhds_zero\n-/\n\n",
 "inv_mem_connectedComponent_one":
 "#print inv_mem_connectedComponent_one /-\n@[to_additive]\ntheorem inv_mem_connectedComponent_one {G : Type _} [TopologicalSpace G] [Group G] [TopologicalGroup G] {g : G}\n    (hg : g ∈ connectedComponent (1 : G)) : g⁻¹ ∈ connectedComponent (1 : G) :=\n  by\n  rw [← inv_one]\n  exact Continuous.image_connectedComponent_subset continuous_inv _ ((Set.mem_image _ _ _).mp ⟨g, hg, rfl⟩)\n#align inv_mem_connected_component_one inv_mem_connectedComponent_one\n#align neg_mem_connected_component_zero neg_mem_connectedComponent_zero\n-/\n\n",
 "inv_closure":
 "#print inv_closure /-\n@[to_additive]\ntheorem inv_closure : ∀ s : Set G, (closure s)⁻¹ = closure s⁻¹ :=\n  (Homeomorph.inv G).preimage_closure\n#align inv_closure inv_closure\n#align neg_closure neg_closure\n-/\n\n",
 "inv":
 "#print IsClosed.inv /-\n@[to_additive]\ntheorem IsClosed.inv (hs : IsClosed s) : IsClosed s⁻¹ :=\n  hs.preimage continuous_inv\n#align is_closed.inv IsClosed.inv\n#align is_closed.neg IsClosed.neg\n-/\n\n",
 "ext_iff":
 "#print TopologicalGroup.ext_iff /-\n@[to_additive]\ntheorem TopologicalGroup.ext_iff {G : Type _} [Group G] {t t' : TopologicalSpace G} (tg : @TopologicalGroup G t _)\n    (tg' : @TopologicalGroup G t' _) : t = t' ↔ @nhds G t 1 = @nhds G t' 1 :=\n  ⟨fun h => h ▸ rfl, tg.ext tg'⟩\n#align topological_group.ext_iff TopologicalGroup.ext_iff\n#align topological_add_group.ext_iff TopologicalAddGroup.ext_iff\n-/\n\n",
 "ext'":
 "@[ext, to_additive]\ntheorem ext' {f g : GroupTopology α} (h : f.is_open = g.is_open) : f = g :=\n  toTopologicalSpace_injective <| topologicalSpace_eq h\n#align ext' ext'\n\n",
 "ext":
 "#print TopologicalGroup.ext /-\n@[to_additive]\ntheorem TopologicalGroup.ext {G : Type _} [Group G] {t t' : TopologicalSpace G} (tg : @TopologicalGroup G t _)\n    (tg' : @TopologicalGroup G t' _) (h : @nhds G t 1 = @nhds G t' 1) : t = t' :=\n  eq_of_nhds_eq_nhds fun x => by rw [← @nhds_translation_mul_inv G t _ _ x, ← @nhds_translation_mul_inv G t' _ _ x, ← h]\n#align topological_group.ext TopologicalGroup.ext\n#align topological_add_group.ext TopologicalAddGroup.ext\n-/\n\n",
 "exists_nhds_split_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_nhds_split_inv /-\n@[to_additive exists_nhds_half_neg]\ntheorem exists_nhds_split_inv {s : Set G} (hs : s ∈ (nhds) (1 : G)) :\n    ∃ V ∈ (nhds) (1 : G), ∀ v ∈ V, ∀ w ∈ V, v / w ∈ s :=\n  by\n  have : «expr ⁻¹' » (fun p : G × G => p.1 * p.2⁻¹) s ∈ (nhds) ((1, 1) : G × G) :=\n    continuousAt_fst.mul continuousAt_snd.inv (by simpa)\n  simpa only [div_eq_mul_inv, nhds_prod_eq, mem_prod_self_iff, prod_subset_iff, mem_preimage] using this\n#align exists_nhds_split_inv exists_nhds_split_inv\n#align exists_nhds_half_neg exists_nhds_half_neg\n-/\n\n",
 "exists_disjoint_smul_of_isCompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print exists_disjoint_smul_of_isCompact /-\n/-- Given two compact sets in a noncompact topological group, there is a translate of the second\none that is disjoint from the first one. -/\n@[to_additive\n      \"Given two compact sets in a noncompact additive topological group, there is a\\ntranslate of the second one that is disjoint from the first one.\"]\ntheorem exists_disjoint_smul_of_isCompact [NoncompactSpace G] {K L : Set G} (hK : IsCompact K) (hL : IsCompact L) :\n    ∃ g : G, Disjoint K («expr • » g L) :=\n  by\n  have A : ¬K * L⁻¹ = univ := (hK.mul hL.inv).ne_univ\n  obtain ⟨g, hg⟩ : ∃ g, g ∉ K * L⁻¹ := by\n    contrapose! A\n    exact eq_univ_iff_forall.2 A\n  refine' ⟨g, _⟩\n  apply disjoint_left.2 fun a ha h'a => hg _\n  rcases h'a with ⟨b, bL, rfl⟩\n  refine' ⟨g * b, b⁻¹, ha, by simpa only [Set.mem_inv, inv_inv] using bL, _⟩\n  simp only [smul_eq_mul, mul_inv_cancel_right]\n#align exists_disjoint_smul_of_is_compact exists_disjoint_smul_of_isCompact\n#align exists_disjoint_vadd_of_is_compact exists_disjoint_vadd_of_isCompact\n-/\n\n",
 "exists_antitone_basis_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print TopologicalGroup.exists_antitone_basis_nhds_one /-\n/-- Any first countable topological group has an antitone neighborhood basis `u : ℕ → set G` for\nwhich `(u (n + 1)) ^ 2 ⊆ u n`. The existence of such a neighborhood basis is a key tool for\n`quotient_group.complete_space` -/\n@[to_additive\n      \"Any first countable topological additive group has an antitone neighborhood basis\\n`u : ℕ → set G` for which `u (n + 1) + u (n + 1) ⊆ u n`. The existence of such a neighborhood basis\\nis a key tool for `quotient_add_group.complete_space`\"]\ntheorem TopologicalGroup.exists_antitone_basis_nhds_one :\n    ∃ u : ℕ → Set G, ((nhds) 1).has_antitone_basis u ∧ ∀ n, u (n + 1) * u (n + 1) ⊆ u n :=\n  by\n  rcases((nhds) (1 : G)).exists_antitone_basis with ⟨u, hu, u_anti⟩\n  have := ((hu.prod_nhds hu).tendsto_iff hu).mp (by simpa only [mul_one] using continuous_mul.tendsto ((1, 1) : G × G))\n  simp only [and_self_iff, mem_prod, and_imp, Prod.forall, exists_true_left, Prod.exists, forall_true_left] at this\n  have event_mul :\n    ∀ n : ℕ,\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (u m * u m ⊆ u n) :=\n    by\n    intro n\n    rcases this n with ⟨j, k, h⟩\n    refine' at_top_basis.eventually_iff.mpr ⟨max j k, true.intro, fun m hm => _⟩\n    rintro - ⟨a, b, ha, hb, rfl⟩\n    exact h a b (u_anti ((le_max_left _ _).trans hm) ha) (u_anti ((le_max_right _ _).trans hm) hb)\n  obtain ⟨φ, -, hφ, φ_anti_basis⟩ := has_antitone_basis.subbasis_with_rel ⟨hu, u_anti⟩ event_mul\n  exact ⟨u ∘ φ, φ_anti_basis, fun n => hφ n.lt_succ_self⟩\n#align topological_group.exists_antitone_basis_nhds_one TopologicalGroup.exists_antitone_basis_nhds_one\n#align topological_add_group.exists_antitone_basis_nhds_zero TopologicalAddGroup.exists_antitone_basis_nhds_zero\n-/\n\n",
 "div_right":
 "#print IsOpen.div_right /-\n@[to_additive]\ntheorem IsOpen.div_right (hs : IsOpen s) : IsOpen (s / t) :=\n  by\n  rw [← Union_div_right_image]\n  exact isOpen_bunionᵢ fun a ha => isOpenMap_div_right a s hs\n#align is_open.div_right IsOpen.div_right\n#align is_open.sub_right IsOpen.sub_right\n-/\n\n",
 "div_left":
 "#print IsOpen.div_left /-\n@[to_additive]\ntheorem IsOpen.div_left (ht : IsOpen t) : IsOpen (s / t) :=\n  by\n  rw [← Union_div_left_image]\n  exact isOpen_bunionᵢ fun a ha => isOpenMap_div_left a t ht\n#align is_open.div_left IsOpen.div_left\n#align is_open.sub_left IsOpen.sub_left\n-/\n\n",
 "div_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.div_const' /-\n@[to_additive sub_const]\ntheorem Filter.Tendsto.div_const' {c : G} {f : α → G} {l : Filter α} (h : Tendsto f l ((nhds) c)) (b : G) :\n    Tendsto (fun k : α => f k / b) l ((nhds) (c / b)) :=\n  h.div' tendsto_const_nhds\n#align filter.tendsto.div_const' Filter.Tendsto.div_const'\n#align filter.tendsto.sub_const Filter.Tendsto.sub_const\n-/\n\n",
 "div_closure":
 "#print IsOpen.div_closure /-\n@[to_additive]\ntheorem IsOpen.div_closure (hs : IsOpen s) (t : Set α) : s / closure t = s / t := by\n  simp_rw [div_eq_mul_inv, inv_closure, hs.mul_closure]\n#align is_open.div_closure IsOpen.div_closure\n#align is_open.sub_closure IsOpen.sub_closure\n-/\n\n",
 "div'":
 "#print ContinuousOn.div' /-\n@[to_additive sub]\ntheorem ContinuousOn.div' (hf : ContinuousOn f s) (hg : ContinuousOn g s) : ContinuousOn (fun x => f x / g x) s :=\n  fun x hx => (hf x hx).div' (hg x hx)\n#align continuous_on.div' ContinuousOn.div'\n#align continuous_on.sub ContinuousOn.sub\n-/\n\n",
 "discreteTopology_of_open_singleton_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print discreteTopology_of_open_singleton_one /-\n@[to_additive]\ntheorem discreteTopology_of_open_singleton_one (h : IsOpen ({1} : Set G)) : DiscreteTopology G :=\n  by\n  rw [← singletons_open_iff_discrete]\n  intro g\n  suffices {g} = «expr ⁻¹' » (fun x : G => g⁻¹ * x) {1} by\n    rw [this]\n    exact (continuous_mul_left g⁻¹).is_open_preimage _ h\n  simp only [mul_one, Set.preimage_mul_left_singleton, eq_self_iff_true, inv_inv, Set.singleton_eq_singleton_iff]\n#align discrete_topology_of_open_singleton_one discreteTopology_of_open_singleton_one\n#align discrete_topology_of_open_singleton_zero discreteTopology_of_open_singleton_zero\n-/\n\n",
 "discreteTopology_iff_open_singleton_one":
 "#print discreteTopology_iff_open_singleton_one /-\n@[to_additive]\ntheorem discreteTopology_iff_open_singleton_one : DiscreteTopology G ↔ IsOpen ({1} : Set G) :=\n  ⟨fun h => forall_open_iff_discrete.mpr h {1}, discreteTopology_of_open_singleton_one⟩\n#align discrete_topology_iff_open_singleton_one discreteTopology_iff_open_singleton_one\n#align discrete_topology_iff_open_singleton_zero discreteTopology_iff_open_singleton_zero\n-/\n\n",
 "continuous_zpow":
 "#print continuous_zpow /-\n@[continuity, to_additive]\ntheorem continuous_zpow : ∀ z : ℤ, Continuous fun a : G => a ^ z\n  | int.of_nat n => by simpa using continuous_pow n\n  | -[n+1] => by simpa using (continuous_pow (n + 1)).inv\n#align continuous_zpow continuous_zpow\n#align continuous_zsmul continuous_zsmul\n-/\n\n",
 "continuous_smul₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print QuotientGroup.continuous_smul₁ /-\n@[to_additive]\ntheorem QuotientGroup.continuous_smul₁ (x : «expr ⧸ » G Γ) : Continuous fun g : G => «expr • » g x :=\n  by\n  induction x using QuotientGroup.induction_on\n  exact continuous_quotient_mk.comp (continuous_mul_right x)\n#align quotient_group.continuous_smul₁ QuotientGroup.continuous_smul₁\n#align quotient_add_group.continuous_smul₁ QuotientAddGroup.continuous_smul₁\n-/\n\n",
 "continuous_of_continuousAt_one":
 "#print continuous_of_continuousAt_one /-\n/-- A monoid homomorphism (a bundled morphism of a type that implements `monoid_hom_class`) from a\ntopological group to a topological monoid is continuous provided that it is continuous at one. See\nalso `uniform_continuous_of_continuous_at_one`. -/\n@[to_additive\n      \"An additive monoid homomorphism (a bundled morphism of a type that implements\\n`add_monoid_hom_class`) from an additive topological group to an additive topological monoid is\\ncontinuous provided that it is continuous at zero. See also\\n`uniform_continuous_of_continuous_at_zero`.\"]\ntheorem continuous_of_continuousAt_one {M hom : Type _} [MulOneClass M] [TopologicalSpace M] [ContinuousMul M]\n    [MonoidHomClass hom G M] (f : hom) (hf : ContinuousAt f 1) : Continuous f :=\n  continuous_iff_continuousAt.2 fun x => by\n    simpa only [ContinuousAt, ← map_mul_left_nhds_one x, tendsto_map'_iff, (· ∘ ·), map_mul, map_one, mul_one] using\n      hf.tendsto.const_mul (f x)\n#align continuous_of_continuous_at_one continuous_of_continuousAt_one\n#align continuous_of_continuous_at_zero continuous_of_continuousAt_zero\n-/\n\n",
 "continuous_mul'":
 "/-- A version of the global `continuous_mul` suitable for dot notation. -/\n@[to_additive \"A version of the global `continuous_add` suitable for dot notation.\"]\ntheorem continuous_mul' (g : GroupTopology α) :\n    haveI := g.to_topological_space\n    Continuous fun p : α × α => p.1 * p.2 :=\n  by\n  letI := g.to_topological_space\n  haveI := g.to_topological_group\n  exact continuous_mul\n#align continuous_mul' continuous_mul'\n\n",
 "continuous_inv'":
 "/-- A version of the global `continuous_inv` suitable for dot notation. -/\n@[to_additive \"A version of the global `continuous_neg` suitable for dot notation.\"]\ntheorem continuous_inv' (g : GroupTopology α) :\n    haveI := g.to_topological_space\n    Continuous (has_inv.inv : α → α) :=\n  by\n  letI := g.to_topological_space\n  haveI := g.to_topological_group\n  exact continuous_inv\n#align continuous_inv' continuous_inv'\n\n",
 "continuous_div_right'":
 "#print continuous_div_right' /-\n@[to_additive continuous_sub_right]\ntheorem continuous_div_right' (a : G) : Continuous fun b : G => b / a :=\n  continuous_id.div' continuous_const\n#align continuous_div_right' continuous_div_right'\n#align continuous_sub_right continuous_sub_right\n-/\n\n",
 "continuous_div_left'":
 "#print continuous_div_left' /-\n@[to_additive continuous_sub_left]\ntheorem continuous_div_left' (a : G) : Continuous fun b : G => a / b :=\n  continuous_const.div' continuous_id\n#align continuous_div_left' continuous_div_left'\n#align continuous_sub_left continuous_sub_left\n-/\n\n",
 "continuous_conj_prod":
 "#print TopologicalGroup.continuous_conj_prod /-\n/-- Conjugation is jointly continuous on `G × G` when both `mul` and `inv` are continuous. -/\n@[to_additive \"Conjugation is jointly continuous on `G × G` when both `mul` and `inv` are\\ncontinuous.\"]\ntheorem TopologicalGroup.continuous_conj_prod [ContinuousInv G] : Continuous fun g : G × G => g.fst * g.snd * g.fst⁻¹ :=\n  continuous_mul.mul (continuous_inv.comp continuous_fst)\n#align topological_group.continuous_conj_prod TopologicalGroup.continuous_conj_prod\n#align topological_add_group.continuous_conj_sum TopologicalAddGroup.continuous_conj_sum\n-/\n\n",
 "continuous_conj'":
 "#print TopologicalGroup.continuous_conj' /-\n/-- Conjugation acting on fixed element of the group is continuous when both `mul` and\n`inv` are continuous. -/\n@[to_additive\n      \"Conjugation acting on fixed element of the additive group is continuous when both\\n  `add` and `neg` are continuous.\"]\ntheorem TopologicalGroup.continuous_conj' [ContinuousInv G] (h : G) : Continuous fun g : G => g * h * g⁻¹ :=\n  (continuous_mul_right h).mul continuous_inv\n#align topological_group.continuous_conj' TopologicalGroup.continuous_conj'\n#align topological_add_group.continuous_conj' TopologicalAddGroup.continuous_conj'\n-/\n\n",
 "continuous_conj":
 "#print TopologicalGroup.continuous_conj /-\n/-- Conjugation by a fixed element is continuous when `mul` is continuous. -/\n@[to_additive \"Conjugation by a fixed element is continuous when `add` is continuous.\"]\ntheorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G => g * h * g⁻¹ :=\n  (continuous_mul_right g⁻¹).comp (continuous_mul_left g)\n#align topological_group.continuous_conj TopologicalGroup.continuous_conj\n#align topological_add_group.continuous_conj TopologicalAddGroup.continuous_conj\n-/\n\n",
 "continuousWithinAt_inv":
 "#print continuousWithinAt_inv /-\n@[to_additive]\ntheorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt has_inv.inv s x :=\n  continuous_inv.continuous_within_at\n#align continuous_within_at_inv continuousWithinAt_inv\n#align continuous_within_at_neg continuousWithinAt_neg\n-/\n\n",
 "continuousOn_zpow":
 "#print continuousOn_zpow /-\n@[to_additive]\ntheorem continuousOn_zpow {s : Set G} (z : ℤ) : ContinuousOn (fun x => x ^ z) s :=\n  (continuous_zpow z).continuous_on\n#align continuous_on_zpow continuousOn_zpow\n#align continuous_on_zsmul continuousOn_zsmul\n-/\n\n",
 "continuousOn_inv":
 "#print continuousOn_inv /-\n@[to_additive]\ntheorem continuousOn_inv {s : Set G} : ContinuousOn has_inv.inv s :=\n  continuous_inv.continuous_on\n#align continuous_on_inv continuousOn_inv\n#align continuous_on_neg continuousOn_neg\n-/\n\n",
 "continuousInv_infₛ":
 "#print continuousInv_infₛ /-\n@[to_additive]\ntheorem continuousInv_infₛ {ts : Set (TopologicalSpace G)} (h : ∀ t ∈ ts, @ContinuousInv G t _) :\n    @ContinuousInv G (infₛ ts) _ :=\n  {\n    continuous_inv :=\n      continuous_infₛ_rng.2 fun t ht => continuous_infₛ_dom ht (@has_continuous_inv.continuous_inv G t _ (h t ht)) }\n#align has_continuous_inv_Inf continuousInv_infₛ\n#align has_continuous_neg_Inf continuousNeg_infₛ\n-/\n\n",
 "continuousInv_infᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print continuousInv_infᵢ /-\n@[to_additive]\ntheorem continuousInv_infᵢ {ts' : ι' → TopologicalSpace G} (h' : ∀ i, @ContinuousInv G (ts' i) _) :\n    @ContinuousInv G\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (ts' i)) _ :=\n  by\n  rw [← infₛ_range]\n  exact continuousInv_infₛ (set.forall_range_iff.mpr h')\n#align has_continuous_inv_infi continuousInv_infᵢ\n#align has_continuous_neg_infi continuousNeg_infᵢ\n-/\n\n",
 "continuousInv_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print continuousInv_inf /-\n@[to_additive]\ntheorem continuousInv_inf {t₁ t₂ : TopologicalSpace G} (h₁ : @ContinuousInv G t₁ _) (h₂ : @ContinuousInv G t₂ _) :\n    @ContinuousInv G («expr ⊓ » t₁ t₂) _ := by\n  rw [inf_eq_infᵢ]\n  refine' continuousInv_infᵢ fun b => _\n  cases b <;> assumption\n#align has_continuous_inv_inf continuousInv_inf\n#align has_continuous_neg_inf continuousNeg_inf\n-/\n\n",
 "continuousInv":
 "#print Inducing.continuousInv /-\n@[to_additive]\ntheorem Inducing.continuousInv {G H : Type _} [Inv G] [Inv H] [TopologicalSpace G] [TopologicalSpace H]\n    [ContinuousInv H] {f : G → H} (hf : Inducing f) (hf_inv : ∀ x, f x⁻¹ = (f x)⁻¹) : ContinuousInv G :=\n  ⟨hf.continuous_iff.2 <| by simpa only [(· ∘ ·), hf_inv] using hf.continuous.inv⟩\n#align inducing.has_continuous_inv Inducing.continuousInv\n#align inducing.has_continuous_neg Inducing.continuousNeg\n-/\n\n",
 "continuousAt_zpow":
 "#print continuousAt_zpow /-\n@[to_additive]\ntheorem continuousAt_zpow (x : G) (z : ℤ) : ContinuousAt (fun x => x ^ z) x :=\n  (continuous_zpow z).continuous_at\n#align continuous_at_zpow continuousAt_zpow\n#align continuous_at_zsmul continuousAt_zsmul\n-/\n\n",
 "continuousAt_inv":
 "#print continuousAt_inv /-\n@[to_additive]\ntheorem continuousAt_inv {x : G} : ContinuousAt has_inv.inv x :=\n  continuous_inv.continuous_at\n#align continuous_at_inv continuousAt_inv\n#align continuous_at_neg continuousAt_neg\n-/\n\n",
 "const_div'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.const_div' /-\n@[to_additive const_sub]\ntheorem Filter.Tendsto.const_div' (b : G) {c : G} {f : α → G} {l : Filter α} (h : Tendsto f l ((nhds) c)) :\n    Tendsto (fun k : α => b / f k) l ((nhds) (b / c)) :=\n  tendsto_const_nhds.div' h\n#align filter.tendsto.const_div' Filter.Tendsto.const_div'\n#align filter.tendsto.const_sub Filter.Tendsto.const_sub\n-/\n\n",
 "compact_open_separated_mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print compact_open_separated_mul_right /-\n/-- Given a compact set `K` inside an open set `U`, there is a open neighborhood `V` of `1`\n  such that `K * V ⊆ U`. -/\n@[to_additive\n      \"Given a compact set `K` inside an open set `U`, there is a open neighborhood `V` of\\n`0` such that `K + V ⊆ U`.\"]\ntheorem compact_open_separated_mul_right {K U : Set G} (hK : IsCompact K) (hU : IsOpen U) (hKU : K ⊆ U) :\n    ∃ V ∈ (nhds) (1 : G), K * V ⊆ U := by\n  apply hK.induction_on\n  · exact ⟨univ, by simp⟩\n  · rintro s t hst ⟨V, hV, hV'⟩\n    exact ⟨V, hV, (mul_subset_mul_right hst).trans hV'⟩\n  · rintro s t ⟨V, V_in, hV'⟩ ⟨W, W_in, hW'⟩\n    use V ∩ W, inter_mem V_in W_in\n    rw [union_mul]\n    exact\n      union_subset ((mul_subset_mul_left (V.inter_subset_left W)).trans hV')\n        ((mul_subset_mul_left (V.inter_subset_right W)).trans hW')\n  · intro x hx\n    have := tendsto_mul (show U ∈ (nhds) (x * 1) by simpa using hU.mem_nhds (hKU hx))\n    rw [nhds_prod_eq, mem_map, mem_prod_iff] at this\n    rcases this with ⟨t, ht, s, hs, h⟩\n    rw [← image_subset_iff, image_mul_prod] at h\n    exact ⟨t, mem_nhdsWithin_of_mem_nhds ht, s, hs, h⟩\n#align compact_open_separated_mul_right compact_open_separated_mul_right\n#align compact_open_separated_add_right compact_open_separated_add_right\n-/\n\n",
 "compact_open_separated_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print compact_open_separated_mul_left /-\n/-- Given a compact set `K` inside an open set `U`, there is a open neighborhood `V` of `1`\n  such that `V * K ⊆ U`. -/\n@[to_additive\n      \"Given a compact set `K` inside an open set `U`, there is a open neighborhood `V` of\\n`0` such that `V + K ⊆ U`.\"]\ntheorem compact_open_separated_mul_left {K U : Set G} (hK : IsCompact K) (hU : IsOpen U) (hKU : K ⊆ U) :\n    ∃ V ∈ (nhds) (1 : G), V * K ⊆ U :=\n  by\n  rcases compact_open_separated_mul_right (hK.image continuous_op) (op_homeomorph.is_open_map U hU)\n      (image_subset op hKU) with\n    ⟨V, hV : V ∈ (nhds) (op (1 : G)), hV' : «expr '' » op K * V ⊆ «expr '' » op U⟩\n  refine' ⟨«expr ⁻¹' » op V, continuous_op.continuous_at hV, _⟩\n  rwa [← image_preimage_eq V op_surjective, ← image_op_mul, image_subset_iff, preimage_image_eq _ op_injective] at hV'\n#align compact_open_separated_mul_left compact_open_separated_mul_left\n#align compact_open_separated_add_left compact_open_separated_add_left\n-/\n\n",
 "compact_covered_by_mul_left_translates":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print compact_covered_by_mul_left_translates /-\n/-- A compact set is covered by finitely many left multiplicative translates of a set\n  with non-empty interior. -/\n@[to_additive \"A compact set is covered by finitely many left additive translates of a set\\n  with non-empty interior.\"]\ntheorem compact_covered_by_mul_left_translates {K V : Set G} (hK : IsCompact K) (hV : (interior V).nonempty) :\n    ∃ t : Finset G,\n      K ⊆\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr ⁻¹' » (fun h => g * h) V) :=\n  by\n  obtain ⟨t, ht⟩ :\n    ∃ t : Finset G,\n      K ⊆\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (interior («expr ⁻¹' » ((· * ·) x) V)) :=\n    by\n    refine' hK.elim_finite_subcover (fun x => interior <| «expr ⁻¹' » ((· * ·) x) V) (fun x => isOpen_interior) _\n    cases' hV with g₀ hg₀\n    refine' fun g hg => mem_Union.2 ⟨g₀ * g⁻¹, _⟩\n    refine' preimage_interior_subset_interior_preimage (continuous_const.mul continuous_id) _\n    rwa [mem_preimage, inv_mul_cancel_right]\n  exact ⟨t, subset.trans ht <| Union₂_mono fun g hg => interior_subset⟩\n#align compact_covered_by_mul_left_translates compact_covered_by_mul_left_translates\n#align compact_covered_by_add_left_translates compact_covered_by_add_left_translates\n-/\n\n",
 "coinduced_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprcont -/\n@[to_additive]\ntheorem coinduced_continuous {α β : Type _} [t : TopologicalSpace α] [Group β] (f : α → β) :\n    (exprcont) t (coinduced f).to_topological_space f :=\n  by\n  rw [continuous_infₛ_rng]\n  rintro _ ⟨t', ht', rfl⟩\n  exact continuous_iff_coinduced_le.2 ht'\n#align coinduced_continuous coinduced_continuous\n\n",
 "coe_mulRight":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print Homeomorph.coe_mulRight /-\n@[simp, to_additive]\ntheorem Homeomorph.coe_mulRight (a : G) : «expr⇑ » (Homeomorph.mulRight a) = fun g => g * a :=\n  rfl\n#align homeomorph.coe_mul_right Homeomorph.coe_mulRight\n#align homeomorph.coe_add_right Homeomorph.coe_addRight\n-/\n\n",
 "coe_mulLeft":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print Homeomorph.coe_mulLeft /-\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Patrick Massot\n-/\n@[simp, to_additive]\ntheorem Homeomorph.coe_mulLeft (a : G) : «expr⇑ » (Homeomorph.mulLeft a) = (· * ·) a :=\n  rfl\n#align homeomorph.coe_mul_left Homeomorph.coe_mulLeft\n#align homeomorph.coe_add_left Homeomorph.coe_addLeft\n-/\n\n",
 "closure_mul":
 "#print IsOpen.closure_mul /-\n@[to_additive]\ntheorem IsOpen.closure_mul (ht : IsOpen t) (s : Set α) : closure s * t = s * t := by\n  rw [← inv_inv (closure s * t), mul_inv_rev, inv_closure, ht.inv.mul_closure, mul_inv_rev, inv_inv, inv_inv]\n#align is_open.closure_mul IsOpen.closure_mul\n#align is_open.closure_add IsOpen.closure_add\n-/\n\n",
 "closure_div":
 "#print IsOpen.closure_div /-\n@[to_additive]\ntheorem IsOpen.closure_div (ht : IsOpen t) (s : Set α) : closure s / t = s / t := by\n  simp_rw [div_eq_mul_inv, ht.inv.closure_mul]\n#align is_open.closure_div IsOpen.closure_div\n#align is_open.closure_sub IsOpen.closure_sub\n-/\n\n"}