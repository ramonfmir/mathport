{"zpow":
 "@[to_additive continuous_on.zsmul]\ntheorem continuous_on.zpow {f : α → G} {s : set α} (hf : continuous_on f s) (z : ℤ) :\n    continuous_on (fun x => f x ^ z) s := fun x hx => (hf x hx).zpow z\n#align continuous_on.zpow continuous_on.zpow\n\n",
 "topological_group_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[to_additive]\ntheorem topological_group_infi {ts' : ι → topological_space G} (h' : ∀ i, @topological_group G (ts' i) _) :\n    @topological_group G\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (ts' i)) _ :=\n  by\n  rw [← infₛ_range]\n  exact topological_group_Inf (set.forall_range_iff.mpr h')\n#align topological_group_infi topological_group_infi\n\n",
 "topological_group_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem topological_group_inf {t₁ t₂ : topological_space G} (h₁ : @topological_group G t₁ _)\n    (h₂ : @topological_group G t₂ _) : @topological_group G («expr ⊓ » t₁ t₂) _ :=\n  by\n  rw [inf_eq_infᵢ]\n  refine' topological_group_infi fun b => _\n  cases b <;> assumption\n#align topological_group_inf topological_group_inf\n\n",
 "topological_group_induced":
 "@[to_additive]\nprotected theorem topological_group_induced {F : Type _} [group H] [MonoidHomClass F H G] (f : F) :\n    @topological_group H (induced f ‹_›) _ :=\n  letI := induced f ‹_›\n  inducing.topological_group f ⟨rfl⟩\n#align topological_group_induced topological_group_induced\n\n",
 "topological_group_Inf":
 "@[to_additive]\ntheorem topological_group_Inf {ts : set (topological_space G)} (h : ∀ t ∈ ts, @topological_group G t _) :\n    @topological_group G (infₛ ts) _ :=\n  { to_has_continuous_inv :=\n      @has_continuous_inv_Inf _ _ _ fun t ht => @topological_group.to_has_continuous_inv G t _ <| h t ht\n    to_has_continuous_mul :=\n      @has_continuous_mul_Inf _ _ _ fun t ht => @topological_group.to_has_continuous_mul G t _ <| h t ht }\n#align topological_group_Inf topological_group_Inf\n\n",
 "topological_group":
 "@[to_additive]\nprotected theorem inducing.topological_group {F : Type _} [group H] [topological_space H] [MonoidHomClass F H G] (f : F)\n    (hf : inducing f) : topological_group H :=\n  { to_has_continuous_mul := hf.has_continuous_mul _\n    to_has_continuous_inv := hf.has_continuous_inv (map_inv f) }\n#align inducing.topological_group inducing.topological_group\n\n",
 "topological_closure_minimal":
 "@[to_additive]\ntheorem subgroup.topological_closure_minimal (s : subgroup G) {t : subgroup G} (h : s ≤ t)\n    (ht : is_closed (t : set G)) : s.topological_closure ≤ t :=\n  closure_minimal h ht\n#align subgroup.topological_closure_minimal subgroup.topological_closure_minimal\n\n",
 "topological_closure_map_subgroup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem dense_range.topological_closure_map_subgroup [group H] [topological_space H] [topological_group H]\n    {f : «expr →* » G H} (hf : continuous f) (hf' : dense_range f) {s : subgroup G}\n    (hs : s.topological_closure = «expr⊤») : (s.map f).topological_closure = «expr⊤» :=\n  by\n  rw [SetLike.ext'_iff] at hs⊢\n  simp only [subgroup.topological_closure_coe, subgroup.coe_top, ← dense_iff_closure_eq] at hs⊢\n  exact hf'.dense_image hf hs\n#align dense_range.topological_closure_map_subgroup dense_range.topological_closure_map_subgroup\n\n",
 "topological_closure_coe":
 "@[simp, to_additive]\ntheorem subgroup.topological_closure_coe {s : subgroup G} : (s.topological_closure : set G) = closure s :=\n  rfl\n#align subgroup.topological_closure_coe subgroup.topological_closure_coe\n\n",
 "to_topological_space_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem to_topological_space_top : («expr⊤» : group_topology α).to_topological_space = «expr⊤» :=\n  rfl\n#align to_topological_space_top to_topological_space_top\n\n",
 "to_topological_space_le":
 "@[simp, to_additive]\ntheorem to_topological_space_le {x y : group_topology α} : x.to_topological_space ≤ y.to_topological_space ↔ x ≤ y :=\n  iff.rfl\n#align to_topological_space_le to_topological_space_le\n\n",
 "to_topological_space_injective":
 "@[to_additive]\ntheorem to_topological_space_injective :\n    function.injective (to_topological_space : group_topology α → topological_space α) := fun f g h =>\n  by\n  cases f\n  cases g\n  congr\n#align to_topological_space_injective to_topological_space_injective\n\n",
 "to_topological_space_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp, to_additive]\ntheorem to_topological_space_infi {ι} (s : ι → group_topology α) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (s i)).to_topological_space =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (s i).to_topological_space :=\n  congr_arg infₛ (range_comp _ _).symm\n#align to_topological_space_infi to_topological_space_infi\n\n",
 "to_topological_space_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, to_additive]\ntheorem to_topological_space_inf (x y : group_topology α) :\n    («expr ⊓ » x y).to_topological_space = «expr ⊓ » x.to_topological_space y.to_topological_space :=\n  rfl\n#align to_topological_space_inf to_topological_space_inf\n\n",
 "to_topological_space_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem to_topological_space_bot : («expr⊥» : group_topology α).to_topological_space = «expr⊥» :=\n  rfl\n#align to_topological_space_bot to_topological_space_bot\n\n",
 "to_topological_space_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp, to_additive]\ntheorem to_topological_space_Inf (s : set (group_topology α)) :\n    (infₛ s).to_topological_space = infₛ («expr '' » to_topological_space s) :=\n  rfl\n#align to_topological_space_Inf to_topological_space_Inf\n\n",
 "tendsto_inv_nhds_within_Ioi_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n@[to_additive]\ntheorem tendsto_inv_nhds_within_Ioi_inv {a : H} : tendsto has_inv.inv (nhds_within.gt a⁻¹) (nhds_within.lt a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhds_within_Ioi _ _ _ _ a⁻¹\n#align tendsto_inv_nhds_within_Ioi_inv tendsto_inv_nhds_within_Ioi_inv\n\n",
 "tendsto_inv_nhds_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n@[to_additive]\ntheorem tendsto_inv_nhds_within_Ioi {a : H} : tendsto has_inv.inv (nhds_within.gt a) (nhds_within.lt a⁻¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n#align tendsto_inv_nhds_within_Ioi tendsto_inv_nhds_within_Ioi\n\n",
 "tendsto_inv_nhds_within_Iio_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n@[to_additive]\ntheorem tendsto_inv_nhds_within_Iio_inv {a : H} : tendsto has_inv.inv (nhds_within.lt a⁻¹) (nhds_within.gt a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhds_within_Iio _ _ _ _ a⁻¹\n#align tendsto_inv_nhds_within_Iio_inv tendsto_inv_nhds_within_Iio_inv\n\n",
 "tendsto_inv_nhds_within_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n@[to_additive]\ntheorem tendsto_inv_nhds_within_Iio {a : H} : tendsto has_inv.inv (nhds_within.lt a) (nhds_within.gt a⁻¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n#align tendsto_inv_nhds_within_Iio tendsto_inv_nhds_within_Iio\n\n",
 "tendsto_inv_nhds_within_Iic_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n@[to_additive]\ntheorem tendsto_inv_nhds_within_Iic_inv {a : H} : tendsto has_inv.inv (nhds_within.le a⁻¹) (nhds_within.ge a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhds_within_Iic _ _ _ _ a⁻¹\n#align tendsto_inv_nhds_within_Iic_inv tendsto_inv_nhds_within_Iic_inv\n\n",
 "tendsto_inv_nhds_within_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n@[to_additive]\ntheorem tendsto_inv_nhds_within_Iic {a : H} : tendsto has_inv.inv (nhds_within.le a) (nhds_within.ge a⁻¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n#align tendsto_inv_nhds_within_Iic tendsto_inv_nhds_within_Iic\n\n",
 "tendsto_inv_nhds_within_Ici_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n@[to_additive]\ntheorem tendsto_inv_nhds_within_Ici_inv {a : H} : tendsto has_inv.inv (nhds_within.ge a⁻¹) (nhds_within.le a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhds_within_Ici _ _ _ _ a⁻¹\n#align tendsto_inv_nhds_within_Ici_inv tendsto_inv_nhds_within_Ici_inv\n\n",
 "tendsto_inv_nhds_within_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n@[to_additive]\ntheorem tendsto_inv_nhds_within_Ici {a : H} : tendsto has_inv.inv (nhds_within.ge a) (nhds_within.le a⁻¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n#align tendsto_inv_nhds_within_Ici tendsto_inv_nhds_within_Ici\n\n",
 "tendsto_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem tendsto_inv (a : G) : tendsto has_inv.inv ((nhds) a) ((nhds) a⁻¹) :=\n  continuous_at_inv\n#align tendsto_inv tendsto_inv\n\n",
 "tendsto_div_nhds_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem tendsto_div_nhds_one_iff {α : Type _} {l : filter α} {x : G} {u : α → G} :\n    tendsto (fun n => u n / x) l ((nhds) 1) ↔ tendsto u l ((nhds) x) :=\n  haveI A : tendsto (fun n : α => x) l ((nhds) x) := tendsto_const_nhds\n  ⟨fun h => by simpa using h.mul A, fun h => by simpa using h.div' A⟩\n#align tendsto_div_nhds_one_iff tendsto_div_nhds_one_iff\n\n",
 "t3_space":
 "@[to_additive]\ntheorem topological_group.t3_space [t1_space G] : t3_space G :=\n  ⟨⟩\n#align topological_group.t3_space topological_group.t3_space\n\n",
 "t2_space":
 "@[to_additive]\ntheorem topological_group.t2_space [t1_space G] : t2_space G :=\n  by\n  haveI := topological_group.t3_space G\n  infer_instance\n#align topological_group.t2_space topological_group.t2_space\n\n",
 "t1_space":
 "@[to_additive]\ntheorem topological_group.t1_space (h : @is_closed G _ {1}) : t1_space G :=\n  ⟨fun x => by\n    convert is_closed_map_mul_right x _ h\n    simp⟩\n#align topological_group.t1_space topological_group.t1_space\n\n",
 "subset_interior_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem subset_interior_smul_right : «expr • » s (interior t) ⊆ interior («expr • » s t) :=\n  interior_maximal (Set.smul_subset_smul_left interior_subset) is_open_interior.smul_left\n#align subset_interior_smul_right subset_interior_smul_right\n\n",
 "subset_interior_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem subset_interior_smul : «expr • » (interior s) (interior t) ⊆ interior («expr • » s t) :=\n  (Set.smul_subset_smul_right interior_subset).trans subset_interior_smul_right\n#align subset_interior_smul subset_interior_smul\n\n",
 "subset_interior_mul_right":
 "@[to_additive]\ntheorem subset_interior_mul_right : s * interior t ⊆ interior (s * t) :=\n  subset_interior_smul_right\n#align subset_interior_mul_right subset_interior_mul_right\n\n",
 "subset_interior_mul_left":
 "@[to_additive]\ntheorem subset_interior_mul_left : interior s * t ⊆ interior (s * t) :=\n  interior_maximal (Set.mul_subset_mul_right interior_subset) is_open_interior.mul_right\n#align subset_interior_mul_left subset_interior_mul_left\n\n",
 "subset_interior_mul'":
 "@[to_additive]\ntheorem subset_interior_mul' : interior s * interior t ⊆ interior (s * t) :=\n  (Set.mul_subset_mul_left interior_subset).trans subset_interior_mul_left\n#align subset_interior_mul' subset_interior_mul'\n\n",
 "subset_interior_mul":
 "@[to_additive]\ntheorem subset_interior_mul : interior s * interior t ⊆ interior (s * t) :=\n  subset_interior_smul\n#align subset_interior_mul subset_interior_mul\n\n",
 "subset_interior_div_right":
 "@[to_additive]\ntheorem subset_interior_div_right : s / interior t ⊆ interior (s / t) :=\n  interior_maximal (div_subset_div_left interior_subset) is_open_interior.div_left\n#align subset_interior_div_right subset_interior_div_right\n\n",
 "subset_interior_div_left":
 "@[to_additive]\ntheorem subset_interior_div_left : interior s / t ⊆ interior (s / t) :=\n  interior_maximal (div_subset_div_right interior_subset) is_open_interior.div_right\n#align subset_interior_div_left subset_interior_div_left\n\n",
 "subset_interior_div":
 "@[to_additive]\ntheorem subset_interior_div : interior s / interior t ⊆ interior (s / t) :=\n  (div_subset_div_left interior_subset).trans subset_interior_div_left\n#align subset_interior_div subset_interior_div\n\n",
 "smul_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_mem_nhds (a : α) {x : β} (ht : t ∈ (nhds) x) : «expr • » a t ∈ (nhds) («expr • » a x) :=\n  by\n  rcases mem_nhds_iff.1 ht with ⟨u, ut, u_open, hu⟩\n  exact mem_nhds_iff.2 ⟨«expr • » a u, smul_set_mono ut, u_open.smul a, smul_mem_smul_set hu⟩\n#align smul_mem_nhds smul_mem_nhds\n\n",
 "smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem is_open.smul_left (ht : is_open t) : is_open («expr • » s t) :=\n  by\n  rw [← bUnion_smul_set]\n  exact is_open_bUnion fun a _ => ht.smul _\n#align is_open.smul_left is_open.smul_left\n\n",
 "singleton_mul_mem_nhds_of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem singleton_mul_mem_nhds_of_nhds_one (a : α) (h : s ∈ (nhds) (1 : α)) : {a} * s ∈ (nhds) a := by\n  simpa only [mul_one] using singleton_mul_mem_nhds a h\n#align singleton_mul_mem_nhds_of_nhds_one singleton_mul_mem_nhds_of_nhds_one\n\n",
 "singleton_mul_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem singleton_mul_mem_nhds (a : α) {b : α} (h : s ∈ (nhds) b) : {a} * s ∈ (nhds) (a * b) :=\n  by\n  have := smul_mem_nhds a h\n  rwa [← singleton_smul] at this\n#align singleton_mul_mem_nhds singleton_mul_mem_nhds\n\n",
 "shear_mul_right_symm_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, to_additive]\ntheorem homeomorph.shear_mul_right_symm_coe :\n    «expr⇑ » (homeomorph.shear_mul_right G).symm = fun z : G × G => (z.1, z.1⁻¹ * z.2) :=\n  rfl\n#align homeomorph.shear_mul_right_symm_coe homeomorph.shear_mul_right_symm_coe\n\n",
 "shear_mul_right_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, to_additive]\ntheorem homeomorph.shear_mul_right_coe : «expr⇑ » (homeomorph.shear_mul_right G) = fun z : G × G => (z.1, z.1 * z.2) :=\n  rfl\n#align homeomorph.shear_mul_right_coe homeomorph.shear_mul_right_coe\n\n",
 "right_coset":
 "@[to_additive is_closed.right_add_coset]\ntheorem is_closed.right_coset {U : set G} (h : is_closed U) (x : G) : is_closed (right_coset U x) :=\n  is_closed_map_mul_right x _ h\n#align is_closed.right_coset is_closed.right_coset\n\n",
 "properly_discontinuous_smul_opposite_of_tendsto_cofinite":
 "/-- A subgroup `S` of a topological group `G` acts on `G` properly discontinuously on the right, if\nit is discrete in the sense that `S ∩ K` is finite for all compact `K`. (See also\n`discrete_topology`.)\n\nIf `G` is Hausdorff, this can be combined with `t2_space_of_properly_discontinuous_smul_of_t2_space`\nto show that the quotient group `G ⧸ S` is Hausdorff. -/\n@[to_additive\n      \"A subgroup `S` of an additive topological group `G` acts on `G` properly\\ndiscontinuously on the right, if it is discrete in the sense that `S ∩ K` is finite for all compact\\n`K`. (See also `discrete_topology`.)\\n\\nIf `G` is Hausdorff, this can be combined with `t2_space_of_properly_discontinuous_vadd_of_t2_space`\\nto show that the quotient group `G ⧸ S` is Hausdorff.\"]\ntheorem subgroup.properly_discontinuous_smul_opposite_of_tendsto_cofinite (S : subgroup G)\n    (hS : tendsto S.subtype cofinite (cocompact G)) : properly_discontinuous_smul S.opposite G :=\n  {\n    finite_disjoint_inter_image := by\n      intro K L hK hL\n      have : continuous fun p : G × G => (p.1⁻¹, p.2) := continuous_inv.prod_map continuous_id\n      have H : set.finite _ := hS ((hK.prod hL).image (continuous_mul.comp this)).compl_mem_cocompact\n      rw [preimage_compl, compl_compl] at H\n      convert H\n      ext x\n      simpa only [image_smul, mem_image, prod.exists] using Set.op_smul_inter_ne_empty_iff }\n#align\n  subgroup.properly_discontinuous_smul_opposite_of_tendsto_cofinite subgroup.properly_discontinuous_smul_opposite_of_tendsto_cofinite\n\n",
 "properly_discontinuous_smul_of_tendsto_cofinite":
 "/-- A subgroup `S` of a topological group `G` acts on `G` properly discontinuously on the left, if\nit is discrete in the sense that `S ∩ K` is finite for all compact `K`. (See also\n`discrete_topology`.) -/\n@[to_additive\n      \"A subgroup `S` of an additive topological group `G` acts on `G` properly\\ndiscontinuously on the left, if it is discrete in the sense that `S ∩ K` is finite for all compact\\n`K`. (See also `discrete_topology`.\"]\ntheorem subgroup.properly_discontinuous_smul_of_tendsto_cofinite (S : subgroup G)\n    (hS : tendsto S.subtype cofinite (cocompact G)) : properly_discontinuous_smul S G :=\n  {\n    finite_disjoint_inter_image := by\n      intro K L hK hL\n      have H : set.finite _ := hS ((hL.prod hK).image continuous_div').compl_mem_cocompact\n      rw [preimage_compl, compl_compl] at H\n      convert H\n      ext x\n      simpa only [image_smul, mem_image, prod.exists] using Set.smul_inter_ne_empty_iff' }\n#align subgroup.properly_discontinuous_smul_of_tendsto_cofinite subgroup.properly_discontinuous_smul_of_tendsto_cofinite\n\n",
 "of_nhds_one'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem topological_group.of_nhds_one' {G : Type u} [group G] [topological_space G]\n    (hmul : tendsto (uncurry ((· * ·) : G → G → G)) (filter.prod ((nhds) 1) ((nhds) 1)) ((nhds) 1))\n    (hinv : tendsto (fun x : G => x⁻¹) ((nhds) 1) ((nhds) 1))\n    (hleft : ∀ x₀ : G, (nhds) x₀ = map (fun x => x₀ * x) ((nhds) 1))\n    (hright : ∀ x₀ : G, (nhds) x₀ = map (fun x => x * x₀) ((nhds) 1)) : topological_group G :=\n  by\n  refine'\n    { continuous_mul := (has_continuous_mul.of_nhds_one hmul hleft hright).continuous_mul\n      continuous_inv := topological_group.of_nhds_aux hinv hleft _ }\n  intro x₀\n  suffices map (fun x : G => x₀ * x * x₀⁻¹) ((nhds) 1) = (nhds) 1 by simp [this, le_refl]\n  rw [show (fun x => x₀ * x * x₀⁻¹) = (fun x => x₀ * x) ∘ fun x => x * x₀⁻¹\n      by\n      ext\n      simp [mul_assoc],\n    ← filter.map_map, ← hright, hleft x₀⁻¹, filter.map_map]\n  convert map_id\n  ext\n  simp\n#align topological_group.of_nhds_one' topological_group.of_nhds_one'\n\n",
 "of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem topological_group.of_nhds_one {G : Type u} [group G] [topological_space G]\n    (hmul : tendsto (uncurry ((· * ·) : G → G → G)) (filter.prod ((nhds) 1) ((nhds) 1)) ((nhds) 1))\n    (hinv : tendsto (fun x : G => x⁻¹) ((nhds) 1) ((nhds) 1))\n    (hleft : ∀ x₀ : G, (nhds) x₀ = map (fun x => x₀ * x) ((nhds) 1))\n    (hconj : ∀ x₀ : G, tendsto (fun x => x₀ * x * x₀⁻¹) ((nhds) 1) ((nhds) 1)) : topological_group G :=\n  { continuous_mul := by\n      rw [continuous_iff_continuous_at]\n      rintro ⟨x₀, y₀⟩\n      have key :\n        (fun p : G × G => x₀ * p.1 * (y₀ * p.2)) =\n          (fun x => x₀ * y₀ * x) ∘ uncurry (· * ·) ∘ prod.map (fun x => y₀⁻¹ * x * y₀) id :=\n        by\n        ext\n        simp [uncurry, prod.map, mul_assoc]\n      specialize hconj y₀⁻¹\n      rw [inv_inv] at hconj\n      calc\n        map (fun p : G × G => p.1 * p.2) ((nhds) (x₀, y₀)) =\n            map (fun p : G × G => p.1 * p.2) (filter.prod ((nhds) x₀) ((nhds) y₀)) :=\n          by rw [nhds_prod_eq]\n        _ = map (fun p : G × G => x₀ * p.1 * (y₀ * p.2)) (filter.prod ((nhds) 1) ((nhds) 1)) := by\n          rw [hleft x₀, hleft y₀, prod_map_map_eq, filter.map_map]\n        _ =\n            map (((fun x => x₀ * y₀ * x) ∘ uncurry (· * ·)) ∘ prod.map (fun x => y₀⁻¹ * x * y₀) id)\n              (filter.prod ((nhds) 1) ((nhds) 1)) :=\n          by rw [key]\n        _ =\n            map ((fun x => x₀ * y₀ * x) ∘ uncurry (· * ·))\n              (filter.prod ((map fun x => y₀⁻¹ * x * y₀) <| (nhds) 1) ((nhds) 1)) :=\n          by rw [← filter.map_map, ← prod_map_map_eq', map_id]\n        _ ≤ map ((fun x => x₀ * y₀ * x) ∘ uncurry (· * ·)) (filter.prod ((nhds) 1) ((nhds) 1)) :=\n          map_mono (filter.prod_mono hconj <| le_rfl)\n        _ = map (fun x => x₀ * y₀ * x) (map (uncurry (· * ·)) (filter.prod ((nhds) 1) ((nhds) 1))) := by\n          rw [filter.map_map]\n        _ ≤ map (fun x => x₀ * y₀ * x) ((nhds) 1) := map_mono hmul\n        _ = (nhds) (x₀ * y₀) := (hleft _).symm\n        \n    continuous_inv := topological_group.of_nhds_aux hinv hleft hconj }\n#align topological_group.of_nhds_one topological_group.of_nhds_one\n\n",
 "of_nhds_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem topological_group.of_nhds_aux {G : Type _} [group G] [topological_space G]\n    (hinv : tendsto (fun x : G => x⁻¹) ((nhds) 1) ((nhds) 1))\n    (hleft : ∀ x₀ : G, (nhds) x₀ = map (fun x : G => x₀ * x) ((nhds) 1))\n    (hconj : ∀ x₀ : G, map (fun x : G => x₀ * x * x₀⁻¹) ((nhds) 1) ≤ (nhds) 1) : continuous fun x : G => x⁻¹ :=\n  by\n  rw [continuous_iff_continuous_at]\n  rintro x₀\n  have key : (fun x => (x₀ * x)⁻¹) = (fun x => x₀⁻¹ * x) ∘ (fun x => x₀ * x * x₀⁻¹) ∘ fun x => x⁻¹ := by\n    ext <;> simp [mul_assoc]\n  calc\n    map (fun x => x⁻¹) ((nhds) x₀) = map (fun x => x⁻¹) ((map fun x => x₀ * x) <| (nhds) 1) := by rw [hleft]\n    _ = map (fun x => (x₀ * x)⁻¹) ((nhds) 1) := by rw [filter.map_map]\n    _ = map (((fun x => x₀⁻¹ * x) ∘ fun x => x₀ * x * x₀⁻¹) ∘ fun x => x⁻¹) ((nhds) 1) := by rw [key]\n    _ = map ((fun x => x₀⁻¹ * x) ∘ fun x => x₀ * x * x₀⁻¹) _ := by rw [← filter.map_map]\n    _ ≤ map ((fun x => x₀⁻¹ * x) ∘ fun x => x₀ * x * x₀⁻¹) ((nhds) 1) := map_mono hinv\n    _ = map (fun x => x₀⁻¹ * x) (map (fun x => x₀ * x * x₀⁻¹) ((nhds) 1)) := filter.map_map\n    _ ≤ map (fun x => x₀⁻¹ * x) ((nhds) 1) := map_mono (hconj x₀)\n    _ = (nhds) x₀⁻¹ := (hleft _).symm\n    \n#align topological_group.of_nhds_aux topological_group.of_nhds_aux\n\n",
 "of_comm_of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem topological_group.of_comm_of_nhds_one {G : Type u} [comm_group G] [topological_space G]\n    (hmul : tendsto (uncurry ((· * ·) : G → G → G)) (filter.prod ((nhds) 1) ((nhds) 1)) ((nhds) 1))\n    (hinv : tendsto (fun x : G => x⁻¹) ((nhds) 1) ((nhds) 1))\n    (hleft : ∀ x₀ : G, (nhds) x₀ = map (fun x => x₀ * x) ((nhds) 1)) : topological_group G :=\n  topological_group.of_nhds_one hmul hinv hleft (by simpa using tendsto_id)\n#align topological_group.of_comm_of_nhds_one topological_group.of_comm_of_nhds_one\n\n",
 "nhds_translation_mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem nhds_translation_mul_inv (x : G) : comap (fun y : G => y * x⁻¹) ((nhds) 1) = (nhds) x :=\n  ((homeomorph.mul_right x⁻¹).comap_nhds_eq 1).trans <| show (nhds) (1 * x⁻¹⁻¹) = (nhds) x by simp\n#align nhds_translation_mul_inv nhds_translation_mul_inv\n\n",
 "nhds_translation_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem nhds_translation_div (x : G) : comap (· / x) ((nhds) 1) = (nhds) x := by\n  simpa only [div_eq_mul_inv] using nhds_translation_mul_inv x\n#align nhds_translation_div nhds_translation_div\n\n",
 "nhds_one_symm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem nhds_one_symm' : map has_inv.inv ((nhds) (1 : G)) = (nhds) (1 : G) :=\n  ((homeomorph.inv G).map_nhds_eq _).trans (congr_arg nhds inv_one)\n#align nhds_one_symm' nhds_one_symm'\n\n",
 "nhds_one_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem nhds_one_symm : comap has_inv.inv ((nhds) (1 : G)) = (nhds) (1 : G) :=\n  ((homeomorph.inv G).comap_nhds_eq _).trans (congr_arg nhds inv_one)\n#align nhds_one_symm nhds_one_symm\n\n",
 "nhds_of_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem filter.has_basis.nhds_of_one {ι : Sort _} {p : ι → Prop} {s : ι → set G}\n    (hb : has_basis ((nhds) 1 : filter G) p s) (x : G) : has_basis ((nhds) x) p fun i => { y | y / x ∈ s i } :=\n  by\n  rw [← nhds_translation_mul_inv]\n  simp_rw [div_eq_mul_inv]\n  exact hb.comap _\n#align filter.has_basis.nhds_of_one filter.has_basis.nhds_of_one\n\n",
 "nhds_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem nhds_mul (x y : G) : (nhds) (x * y) = (nhds) x * (nhds) y :=\n  calc\n    (nhds) (x * y) = map ((· * ·) x) (map (fun a => a * y) ((nhds) 1 * (nhds) 1)) := by simp\n    _ = map₂ (fun a b => x * (a * b * y)) ((nhds) 1) ((nhds) 1) := by rw [← map₂_mul, map_map₂, map_map₂]\n    _ = map₂ (fun a b => x * a * (b * y)) ((nhds) 1) ((nhds) 1) := by simp only [mul_assoc]\n    _ = (nhds) x * (nhds) y := by\n      rw [← map_mul_left_nhds_one x, ← map_mul_right_nhds_one y, ← map₂_mul, map₂_map_left, map₂_map_right]\n    \n#align nhds_mul nhds_mul\n\n",
 "nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Neighborhoods in the quotient are precisely the map of neighborhoods in the prequotient. -/\n@[to_additive \"Neighborhoods in the quotient are precisely the map of neighborhoods in\\nthe prequotient.\"]\ntheorem quotient_group.nhds_eq (x : G) : (nhds) (x : «expr ⧸ » G N) = map coe ((nhds) x) :=\n  le_antisymm ((quotient_group.is_open_map_coe N).nhds_le x) continuous_quot_mk.continuous_at\n#align quotient_group.nhds_eq quotient_group.nhds_eq\n\n",
 "mul_singleton_mem_nhds_of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem mul_singleton_mem_nhds_of_nhds_one (a : α) (h : s ∈ (nhds) (1 : α)) : s * {a} ∈ (nhds) a := by\n  simpa only [one_mul] using mul_singleton_mem_nhds a h\n#align mul_singleton_mem_nhds_of_nhds_one mul_singleton_mem_nhds_of_nhds_one\n\n",
 "mul_singleton_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem mul_singleton_mem_nhds (a : α) {b : α} (h : s ∈ (nhds) b) : s * {a} ∈ (nhds) (b * a) :=\n  by\n  simp only [← bUnion_op_smul_set, mem_singleton_iff, Union_Union_eq_left]\n  exact smul_mem_nhds _ h\n#align mul_singleton_mem_nhds mul_singleton_mem_nhds\n\n",
 "mul_right_symm":
 "@[to_additive]\ntheorem homeomorph.mul_right_symm (a : G) : (homeomorph.mul_right a).symm = homeomorph.mul_right a⁻¹ :=\n  by\n  ext\n  rfl\n#align homeomorph.mul_right_symm homeomorph.mul_right_symm\n\n",
 "mul_right":
 "@[to_additive]\ntheorem is_open.mul_right (hs : is_open s) : is_open (s * t) :=\n  by\n  rw [← bUnion_op_smul_set]\n  exact is_open_bUnion fun a _ => hs.smul _\n#align is_open.mul_right is_open.mul_right\n\n",
 "mul_mem_connected_component_one":
 "@[to_additive]\ntheorem mul_mem_connected_component_one {G : Type _} [topological_space G] [mul_one_class G] [has_continuous_mul G]\n    {g h : G} (hg : g ∈ connected_component (1 : G)) (hh : h ∈ connected_component (1 : G)) :\n    g * h ∈ connected_component (1 : G) := by\n  rw [connected_component_eq hg]\n  have hmul : g ∈ connected_component (g * h) :=\n    by\n    apply continuous.image_connected_component_subset (continuous_mul_left g)\n    rw [← connected_component_eq hh]\n    exact ⟨(1 : G), mem_connected_component, by simp only [mul_one]⟩\n  simpa [← connected_component_eq hmul] using mem_connected_component\n#align mul_mem_connected_component_one mul_mem_connected_component_one\n\n",
 "mul_left_symm":
 "@[to_additive]\ntheorem homeomorph.mul_left_symm (a : G) : (homeomorph.mul_left a).symm = homeomorph.mul_left a⁻¹ :=\n  by\n  ext\n  rfl\n#align homeomorph.mul_left_symm homeomorph.mul_left_symm\n\n",
 "mul_left":
 "@[to_additive]\ntheorem is_open.mul_left : is_open t → is_open (s * t) :=\n  is_open.smul_left\n#align is_open.mul_left is_open.mul_left\n\n",
 "mul_closure":
 "@[to_additive]\ntheorem is_open.mul_closure (hs : is_open s) (t : set α) : s * closure t = s * t :=\n  by\n  refine' (mul_subset_iff.2 fun a ha b hb => _).antisymm (mul_subset_mul_left subset_closure)\n  rw [mem_closure_iff] at hb\n  have hbU : b ∈ s⁻¹ * {a * b} := ⟨a⁻¹, a * b, Set.inv_mem_inv.2 ha, rfl, inv_mul_cancel_left _ _⟩\n  obtain ⟨_, ⟨c, d, hc, rfl : d = _, rfl⟩, hcs⟩ := hb _ hs.inv.mul_right hbU\n  exact ⟨c⁻¹, _, hc, hcs, inv_mul_cancel_left _ _⟩\n#align is_open.mul_closure is_open.mul_closure\n\n",
 "mem_closure_iff_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem mem_closure_iff_nhds_one {x : G} {s : set G} :\n    x ∈ closure s ↔ ∀ U ∈ ((nhds) 1 : filter G), ∃ y ∈ s, y / x ∈ U :=\n  by\n  rw [mem_closure_iff_nhds_basis (((nhds) 1 : filter G).basis_sets.nhds_of_one x)]\n  rfl\n#align mem_closure_iff_nhds_one mem_closure_iff_nhds_one\n\n",
 "map_mul_right_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem map_mul_right_nhds_one (x : G) : map (fun y => y * x) ((nhds) 1) = (nhds) x := by simp\n#align map_mul_right_nhds_one map_mul_right_nhds_one\n\n",
 "map_mul_right_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp, to_additive]\ntheorem map_mul_right_nhds (x y : G) : map (fun z => z * x) ((nhds) y) = (nhds) (y * x) :=\n  (homeomorph.mul_right x).map_nhds_eq y\n#align map_mul_right_nhds map_mul_right_nhds\n\n",
 "map_mul_left_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem map_mul_left_nhds_one (x : G) : map ((· * ·) x) ((nhds) 1) = (nhds) x := by simp\n#align map_mul_left_nhds_one map_mul_left_nhds_one\n\n",
 "map_mul_left_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp, to_additive]\ntheorem map_mul_left_nhds (x y : G) : map ((· * ·) x) ((nhds) y) = (nhds) (x * y) :=\n  (homeomorph.mul_left x).map_nhds_eq y\n#align map_mul_left_nhds map_mul_left_nhds\n\n",
 "local_is_compact_is_closed_nhds_of_group":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a locally compact group, any neighborhood of the identity contains a compact closed\nneighborhood of the identity, even without separation assumptions on the space. -/\n@[to_additive\n      \"In a locally compact additive group, any neighborhood of the identity contains a\\ncompact closed neighborhood of the identity, even without separation assumptions on the space.\"]\ntheorem local_is_compact_is_closed_nhds_of_group [locally_compact_space G] {U : set G} (hU : U ∈ (nhds) (1 : G)) :\n    ∃ K : set G, is_compact K ∧ is_closed K ∧ K ⊆ U ∧ (1 : G) ∈ interior K :=\n  by\n  obtain ⟨L, Lint, LU, Lcomp⟩ : ∃ (L : set G)(H : L ∈ (nhds) (1 : G)), L ⊆ U ∧ is_compact L\n  exact local_compact_nhds hU\n  obtain ⟨V, Vnhds, hV⟩ : ∃ V ∈ (nhds) (1 : G), ∀ v ∈ V, ∀ w ∈ V, v * w ∈ L :=\n    by\n    have : «expr ⁻¹' » (fun p : G × G => p.1 * p.2) L ∈ (nhds) ((1, 1) : G × G) :=\n      by\n      refine' continuous_at_fst.mul continuous_at_snd _\n      simpa only [mul_one] using Lint\n    simpa only [div_eq_mul_inv, nhds_prod_eq, mem_prod_self_iff, prod_subset_iff, mem_preimage]\n  have VL : closure V ⊆ L :=\n    calc\n      closure V = {(1 : G)} * closure V := by simp only [singleton_mul, one_mul, image_id']\n      _ ⊆ interior V * closure V :=\n        mul_subset_mul_right (by simpa only [singleton_subset_iff] using mem_interior_iff_mem_nhds.2 Vnhds)\n      _ = interior V * V := is_open_interior.mul_closure _\n      _ ⊆ V * V := mul_subset_mul_right interior_subset\n      _ ⊆ L := by\n        rintro x ⟨y, z, yv, zv, rfl⟩\n        exact hV _ yv _ zv\n      \n  exact\n    ⟨closure V, is_compact_of_is_closed_subset Lcomp is_closed_closure VL, is_closed_closure, VL.trans LU,\n      interior_mono subset_closure (mem_interior_iff_mem_nhds.2 Vnhds)⟩\n#align local_is_compact_is_closed_nhds_of_group local_is_compact_is_closed_nhds_of_group\n\n",
 "left_coset":
 "@[to_additive is_closed.left_add_coset]\ntheorem is_closed.left_coset {U : set G} (h : is_closed U) (x : G) : is_closed (left_coset x U) :=\n  is_closed_map_mul_left x _ h\n#align is_closed.left_coset is_closed.left_coset\n\n",
 "le_topological_closure":
 "@[to_additive]\ntheorem subgroup.le_topological_closure (s : subgroup G) : s ≤ s.topological_closure :=\n  subset_closure\n#align subgroup.le_topological_closure subgroup.le_topological_closure\n\n",
 "is_open_map_mul_right":
 "@[to_additive]\ntheorem is_open_map_mul_right (a : G) : is_open_map fun x => x * a :=\n  (homeomorph.mul_right a).is_open_map\n#align is_open_map_mul_right is_open_map_mul_right\n\n",
 "is_open_map_mul_left":
 "@[to_additive]\ntheorem is_open_map_mul_left (a : G) : is_open_map fun x => a * x :=\n  (homeomorph.mul_left a).is_open_map\n#align is_open_map_mul_left is_open_map_mul_left\n\n",
 "is_open_map_inv":
 "@[to_additive]\ntheorem is_open_map_inv : is_open_map (has_inv.inv : G → G) :=\n  (homeomorph.inv _).is_open_map\n#align is_open_map_inv is_open_map_inv\n\n",
 "is_open_map_div_right":
 "@[to_additive]\ntheorem is_open_map_div_right (a : G) : is_open_map fun x => x / a :=\n  (homeomorph.div_right a).is_open_map\n#align is_open_map_div_right is_open_map_div_right\n\n",
 "is_open_map_div_left":
 "@[to_additive]\ntheorem is_open_map_div_left (a : G) : is_open_map ((· / ·) a) :=\n  (homeomorph.div_left _).is_open_map\n#align is_open_map_div_left is_open_map_div_left\n\n",
 "is_open_map_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem quotient_group.is_open_map_coe : is_open_map (coe : G → «expr ⧸ » G N) :=\n  by\n  intro s s_op\n  change is_open («expr ⁻¹' » (coe : G → «expr ⧸ » G N) («expr '' » coe s))\n  rw [quotient_group.preimage_image_coe N s]\n  exact is_open_Union fun n => (continuous_mul_right _).is_open_preimage s s_op\n#align quotient_group.is_open_map_coe quotient_group.is_open_map_coe\n\n",
 "is_normal_topological_closure":
 "/-- The topological closure of a normal subgroup is normal.-/\n@[to_additive \"The topological closure of a normal additive subgroup is normal.\"]\ntheorem subgroup.is_normal_topological_closure {G : Type _} [topological_space G] [group G] [topological_group G]\n    (N : subgroup G) [N.normal] : (subgroup.topological_closure N).normal :=\n  {\n    conj_mem := fun n hn g => by\n      apply map_mem_closure (topological_group.continuous_conj g) hn\n      exact fun m hm => subgroup.normal.conj_mem infer_instance m hm g }\n#align subgroup.is_normal_topological_closure subgroup.is_normal_topological_closure\n\n",
 "is_closed_topological_closure":
 "@[to_additive]\ntheorem subgroup.is_closed_topological_closure (s : subgroup G) : is_closed (s.topological_closure : set G) := by\n  convert is_closed_closure\n#align subgroup.is_closed_topological_closure subgroup.is_closed_topological_closure\n\n",
 "is_closed_set_of_map_inv":
 "@[to_additive]\ntheorem is_closed_set_of_map_inv [Inv G₁] [Inv G₂] [has_continuous_inv G₂] :\n    is_closed { f : G₁ → G₂ | ∀ x, f x⁻¹ = (f x)⁻¹ } :=\n  by\n  simp only [set_of_forall]\n  refine' is_closed_Inter fun i => is_closed_eq (continuous_apply _) (continuous_apply _).inv\n#align is_closed_set_of_map_inv is_closed_set_of_map_inv\n\n",
 "is_closed_map_mul_right":
 "@[to_additive]\ntheorem is_closed_map_mul_right (a : G) : is_closed_map fun x => x * a :=\n  (homeomorph.mul_right a).is_closed_map\n#align is_closed_map_mul_right is_closed_map_mul_right\n\n",
 "is_closed_map_mul_left":
 "@[to_additive]\ntheorem is_closed_map_mul_left (a : G) : is_closed_map fun x => a * x :=\n  (homeomorph.mul_left a).is_closed_map\n#align is_closed_map_mul_left is_closed_map_mul_left\n\n",
 "is_closed_map_inv":
 "@[to_additive]\ntheorem is_closed_map_inv : is_closed_map (has_inv.inv : G → G) :=\n  (homeomorph.inv _).is_closed_map\n#align is_closed_map_inv is_closed_map_inv\n\n",
 "is_closed_map_div_right":
 "@[to_additive]\ntheorem is_closed_map_div_right (a : G) : is_closed_map fun x => x / a :=\n  (homeomorph.div_right a).is_closed_map\n#align is_closed_map_div_right is_closed_map_div_right\n\n",
 "is_closed_map_div_left":
 "@[to_additive]\ntheorem is_closed_map_div_left (a : G) : is_closed_map ((· / ·) a) :=\n  (homeomorph.div_left _).is_closed_map\n#align is_closed_map_div_left is_closed_map_div_left\n\n",
 "inv_mem_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem inv_mem_nhds_one {S : set G} (hS : S ∈ ((nhds) 1 : filter G)) : S⁻¹ ∈ (nhds) (1 : G) := by\n  rwa [← nhds_one_symm'] at hS\n#align inv_mem_nhds_one inv_mem_nhds_one\n\n",
 "inv_mem_connected_component_one":
 "@[to_additive]\ntheorem inv_mem_connected_component_one {G : Type _} [topological_space G] [group G] [topological_group G] {g : G}\n    (hg : g ∈ connected_component (1 : G)) : g⁻¹ ∈ connected_component (1 : G) :=\n  by\n  rw [← inv_one]\n  exact continuous.image_connected_component_subset continuous_inv _ ((Set.mem_image _ _ _).mp ⟨g, hg, rfl⟩)\n#align inv_mem_connected_component_one inv_mem_connected_component_one\n\n",
 "inv_closure":
 "@[to_additive]\ntheorem inv_closure : ∀ s : set G, (closure s)⁻¹ = closure s⁻¹ :=\n  (homeomorph.inv G).preimage_closure\n#align inv_closure inv_closure\n\n",
 "inv":
 "@[to_additive]\ntheorem is_closed.inv (hs : is_closed s) : is_closed s⁻¹ :=\n  hs.preimage continuous_inv\n#align is_closed.inv is_closed.inv\n\n",
 "has_continuous_inv_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[to_additive]\ntheorem has_continuous_inv_infi {ts' : ι' → topological_space G} (h' : ∀ i, @has_continuous_inv G (ts' i) _) :\n    @has_continuous_inv G\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (ts' i)) _ :=\n  by\n  rw [← infₛ_range]\n  exact has_continuous_inv_Inf (set.forall_range_iff.mpr h')\n#align has_continuous_inv_infi has_continuous_inv_infi\n\n",
 "has_continuous_inv_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem has_continuous_inv_inf {t₁ t₂ : topological_space G} (h₁ : @has_continuous_inv G t₁ _)\n    (h₂ : @has_continuous_inv G t₂ _) : @has_continuous_inv G («expr ⊓ » t₁ t₂) _ :=\n  by\n  rw [inf_eq_infᵢ]\n  refine' has_continuous_inv_infi fun b => _\n  cases b <;> assumption\n#align has_continuous_inv_inf has_continuous_inv_inf\n\n",
 "has_continuous_inv_Inf":
 "@[to_additive]\ntheorem has_continuous_inv_Inf {ts : set (topological_space G)} (h : ∀ t ∈ ts, @has_continuous_inv G t _) :\n    @has_continuous_inv G (infₛ ts) _ :=\n  {\n    continuous_inv :=\n      continuous_Inf_rng.2 fun t ht => continuous_Inf_dom ht (@has_continuous_inv.continuous_inv G t _ (h t ht)) }\n#align has_continuous_inv_Inf has_continuous_inv_Inf\n\n",
 "has_continuous_inv":
 "@[to_additive]\ntheorem inducing.has_continuous_inv {G H : Type _} [Inv G] [Inv H] [topological_space G] [topological_space H]\n    [has_continuous_inv H] {f : G → H} (hf : inducing f) (hf_inv : ∀ x, f x⁻¹ = (f x)⁻¹) : has_continuous_inv G :=\n  ⟨hf.continuous_iff.2 <| by simpa only [(· ∘ ·), hf_inv] using hf.continuous.inv⟩\n#align inducing.has_continuous_inv inducing.has_continuous_inv\n\n",
 "ext_iff":
 "@[to_additive]\ntheorem topological_group.ext_iff {G : Type _} [group G] {t t' : topological_space G} (tg : @topological_group G t _)\n    (tg' : @topological_group G t' _) : t = t' ↔ @nhds G t 1 = @nhds G t' 1 :=\n  ⟨fun h => h ▸ rfl, tg.ext tg'⟩\n#align topological_group.ext_iff topological_group.ext_iff\n\n",
 "ext'":
 "@[ext, to_additive]\ntheorem ext' {f g : group_topology α} (h : f.is_open = g.is_open) : f = g :=\n  to_topological_space_injective <| topological_space_eq h\n#align ext' ext'\n\n",
 "ext":
 "@[to_additive]\ntheorem topological_group.ext {G : Type _} [group G] {t t' : topological_space G} (tg : @topological_group G t _)\n    (tg' : @topological_group G t' _) (h : @nhds G t 1 = @nhds G t' 1) : t = t' :=\n  eq_of_nhds_eq_nhds fun x => by rw [← @nhds_translation_mul_inv G t _ _ x, ← @nhds_translation_mul_inv G t' _ _ x, ← h]\n#align topological_group.ext topological_group.ext\n\n",
 "exists_nhds_split_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive exists_nhds_half_neg]\ntheorem exists_nhds_split_inv {s : set G} (hs : s ∈ (nhds) (1 : G)) :\n    ∃ V ∈ (nhds) (1 : G), ∀ v ∈ V, ∀ w ∈ V, v / w ∈ s :=\n  by\n  have : «expr ⁻¹' » (fun p : G × G => p.1 * p.2⁻¹) s ∈ (nhds) ((1, 1) : G × G) :=\n    continuous_at_fst.mul continuous_at_snd.inv (by simpa)\n  simpa only [div_eq_mul_inv, nhds_prod_eq, mem_prod_self_iff, prod_subset_iff, mem_preimage] using this\n#align exists_nhds_split_inv exists_nhds_split_inv\n\n",
 "exists_disjoint_smul_of_is_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Given two compact sets in a noncompact topological group, there is a translate of the second\none that is disjoint from the first one. -/\n@[to_additive\n      \"Given two compact sets in a noncompact additive topological group, there is a\\ntranslate of the second one that is disjoint from the first one.\"]\ntheorem exists_disjoint_smul_of_is_compact [noncompact_space G] {K L : set G} (hK : is_compact K) (hL : is_compact L) :\n    ∃ g : G, Disjoint K («expr • » g L) :=\n  by\n  have A : ¬K * L⁻¹ = univ := (hK.mul hL.inv).ne_univ\n  obtain ⟨g, hg⟩ : ∃ g, g ∉ K * L⁻¹ := by\n    contrapose! A\n    exact eq_univ_iff_forall.2 A\n  refine' ⟨g, _⟩\n  apply disjoint_left.2 fun a ha h'a => hg _\n  rcases h'a with ⟨b, bL, rfl⟩\n  refine' ⟨g * b, b⁻¹, ha, by simpa only [Set.mem_inv, inv_inv] using bL, _⟩\n  simp only [smul_eq_mul, mul_inv_cancel_right]\n#align exists_disjoint_smul_of_is_compact exists_disjoint_smul_of_is_compact\n\n",
 "exists_antitone_basis_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Any first countable topological group has an antitone neighborhood basis `u : ℕ → set G` for\nwhich `(u (n + 1)) ^ 2 ⊆ u n`. The existence of such a neighborhood basis is a key tool for\n`quotient_group.complete_space` -/\n@[to_additive\n      \"Any first countable topological additive group has an antitone neighborhood basis\\n`u : ℕ → set G` for which `u (n + 1) + u (n + 1) ⊆ u n`. The existence of such a neighborhood basis\\nis a key tool for `quotient_add_group.complete_space`\"]\ntheorem topological_group.exists_antitone_basis_nhds_one :\n    ∃ u : ℕ → set G, ((nhds) 1).has_antitone_basis u ∧ ∀ n, u (n + 1) * u (n + 1) ⊆ u n :=\n  by\n  rcases((nhds) (1 : G)).exists_antitone_basis with ⟨u, hu, u_anti⟩\n  have := ((hu.prod_nhds hu).tendsto_iff hu).mp (by simpa only [mul_one] using continuous_mul.tendsto ((1, 1) : G × G))\n  simp only [and_self_iff, mem_prod, and_imp, prod.forall, exists_true_left, prod.exists, forall_true_left] at this\n  have event_mul :\n    ∀ n : ℕ,\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (u m * u m ⊆ u n) :=\n    by\n    intro n\n    rcases this n with ⟨j, k, h⟩\n    refine' at_top_basis.eventually_iff.mpr ⟨max j k, true.intro, fun m hm => _⟩\n    rintro - ⟨a, b, ha, hb, rfl⟩\n    exact h a b (u_anti ((le_max_left _ _).trans hm) ha) (u_anti ((le_max_right _ _).trans hm) hb)\n  obtain ⟨φ, -, hφ, φ_anti_basis⟩ := has_antitone_basis.subbasis_with_rel ⟨hu, u_anti⟩ event_mul\n  exact ⟨u ∘ φ, φ_anti_basis, fun n => hφ n.lt_succ_self⟩\n#align topological_group.exists_antitone_basis_nhds_one topological_group.exists_antitone_basis_nhds_one\n\n",
 "div_right":
 "@[to_additive]\ntheorem is_open.div_right (hs : is_open s) : is_open (s / t) :=\n  by\n  rw [← Union_div_right_image]\n  exact is_open_bUnion fun a ha => is_open_map_div_right a s hs\n#align is_open.div_right is_open.div_right\n\n",
 "div_left":
 "@[to_additive]\ntheorem is_open.div_left (ht : is_open t) : is_open (s / t) :=\n  by\n  rw [← Union_div_left_image]\n  exact is_open_bUnion fun a ha => is_open_map_div_left a t ht\n#align is_open.div_left is_open.div_left\n\n",
 "div_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive sub_const]\ntheorem filter.tendsto.div_const' (b : G) {c : G} {f : α → G} {l : filter α} (h : tendsto f l ((nhds) c)) :\n    tendsto (fun k : α => f k / b) l ((nhds) (c / b)) :=\n  h.div' tendsto_const_nhds\n#align filter.tendsto.div_const' filter.tendsto.div_const'\n\n",
 "div_closure":
 "@[to_additive]\ntheorem is_open.div_closure (hs : is_open s) (t : set α) : s / closure t = s / t := by\n  simp_rw [div_eq_mul_inv, inv_closure, hs.mul_closure]\n#align is_open.div_closure is_open.div_closure\n\n",
 "div'":
 "@[to_additive sub]\ntheorem continuous_on.div' (hf : continuous_on f s) (hg : continuous_on g s) : continuous_on (fun x => f x / g x) s :=\n  fun x hx => (hf x hx).div' (hg x hx)\n#align continuous_on.div' continuous_on.div'\n\n",
 "discrete_topology_of_open_singleton_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem discrete_topology_of_open_singleton_one (h : is_open ({1} : set G)) : discrete_topology G :=\n  by\n  rw [← singletons_open_iff_discrete]\n  intro g\n  suffices {g} = «expr ⁻¹' » (fun x : G => g⁻¹ * x) {1} by\n    rw [this]\n    exact (continuous_mul_left g⁻¹).is_open_preimage _ h\n  simp only [mul_one, Set.preimage_mul_left_singleton, eq_self_iff_true, inv_inv, Set.singleton_eq_singleton_iff]\n#align discrete_topology_of_open_singleton_one discrete_topology_of_open_singleton_one\n\n",
 "discrete_topology_iff_open_singleton_one":
 "@[to_additive]\ntheorem discrete_topology_iff_open_singleton_one : discrete_topology G ↔ is_open ({1} : set G) :=\n  ⟨fun h => forall_open_iff_discrete.mpr h {1}, discrete_topology_of_open_singleton_one⟩\n#align discrete_topology_iff_open_singleton_one discrete_topology_iff_open_singleton_one\n\n",
 "continuous_zpow":
 "@[continuity, to_additive]\ntheorem continuous_zpow : ∀ z : ℤ, continuous fun a : G => a ^ z\n  | int.of_nat n => by simpa using continuous_pow n\n  | -[n+1] => by simpa using (continuous_pow (n + 1)).inv\n#align continuous_zpow continuous_zpow\n\n",
 "continuous_within_at_inv":
 "@[to_additive]\ntheorem continuous_within_at_inv {s : set G} {x : G} : continuous_within_at has_inv.inv s x :=\n  continuous_inv.continuous_within_at\n#align continuous_within_at_inv continuous_within_at_inv\n\n",
 "continuous_smul₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem quotient_group.continuous_smul₁ (x : «expr ⧸ » G Γ) : continuous fun g : G => «expr • » g x :=\n  by\n  induction x using quotient_group.induction_on\n  exact continuous_quotient_mk.comp (continuous_mul_right x)\n#align quotient_group.continuous_smul₁ quotient_group.continuous_smul₁\n\n",
 "continuous_on_zpow":
 "@[to_additive]\ntheorem continuous_on_zpow {s : set G} (z : ℤ) : continuous_on (fun x => x ^ z) s :=\n  (continuous_zpow z).continuous_on\n#align continuous_on_zpow continuous_on_zpow\n\n",
 "continuous_on_inv":
 "@[to_additive]\ntheorem continuous_on_inv {s : set G} : continuous_on has_inv.inv s :=\n  continuous_inv.continuous_on\n#align continuous_on_inv continuous_on_inv\n\n",
 "continuous_of_continuous_at_one":
 "/-- A monoid homomorphism (a bundled morphism of a type that implements `monoid_hom_class`) from a\ntopological group to a topological monoid is continuous provided that it is continuous at one. See\nalso `uniform_continuous_of_continuous_at_one`. -/\n@[to_additive\n      \"An additive monoid homomorphism (a bundled morphism of a type that implements\\n`add_monoid_hom_class`) from an additive topological group to an additive topological monoid is\\ncontinuous provided that it is continuous at zero. See also\\n`uniform_continuous_of_continuous_at_zero`.\"]\ntheorem continuous_of_continuous_at_one {M hom : Type _} [mul_one_class M] [topological_space M] [has_continuous_mul M]\n    [MonoidHomClass hom G M] (f : hom) (hf : continuous_at f 1) : continuous f :=\n  continuous_iff_continuous_at.2 fun x => by\n    simpa only [continuous_at, ← map_mul_left_nhds_one x, tendsto_map'_iff, (· ∘ ·), map_mul, map_one, mul_one] using\n      hf.tendsto.const_mul (f x)\n#align continuous_of_continuous_at_one continuous_of_continuous_at_one\n\n",
 "continuous_mul'":
 "/-- A version of the global `continuous_mul` suitable for dot notation. -/\n@[to_additive \"A version of the global `continuous_add` suitable for dot notation.\"]\ntheorem continuous_mul' (g : group_topology α) :\n    haveI := g.to_topological_space\n    continuous fun p : α × α => p.1 * p.2 :=\n  by\n  letI := g.to_topological_space\n  haveI := g.to_topological_group\n  exact continuous_mul\n#align continuous_mul' continuous_mul'\n\n",
 "continuous_inv'":
 "/-- A version of the global `continuous_inv` suitable for dot notation. -/\n@[to_additive \"A version of the global `continuous_neg` suitable for dot notation.\"]\ntheorem continuous_inv' (g : group_topology α) :\n    haveI := g.to_topological_space\n    continuous (has_inv.inv : α → α) :=\n  by\n  letI := g.to_topological_space\n  haveI := g.to_topological_group\n  exact continuous_inv\n#align continuous_inv' continuous_inv'\n\n",
 "continuous_div_right'":
 "@[to_additive continuous_sub_right]\ntheorem continuous_div_right' (a : G) : continuous fun b : G => b / a :=\n  continuous_id.div' continuous_const\n#align continuous_div_right' continuous_div_right'\n\n",
 "continuous_div_left'":
 "@[to_additive continuous_sub_left]\ntheorem continuous_div_left' (a : G) : continuous fun b : G => a / b :=\n  continuous_const.div' continuous_id\n#align continuous_div_left' continuous_div_left'\n\n",
 "continuous_conj_prod":
 "/-- Conjugation is jointly continuous on `G × G` when both `mul` and `inv` are continuous. -/\n@[to_additive \"Conjugation is jointly continuous on `G × G` when both `mul` and `inv` are\\ncontinuous.\"]\ntheorem topological_group.continuous_conj_prod [has_continuous_inv G] :\n    continuous fun g : G × G => g.fst * g.snd * g.fst⁻¹ :=\n  continuous_mul.mul (continuous_inv.comp continuous_fst)\n#align topological_group.continuous_conj_prod topological_group.continuous_conj_prod\n\n",
 "continuous_conj'":
 "/-- Conjugation acting on fixed element of the group is continuous when both `mul` and\n`inv` are continuous. -/\n@[to_additive\n      \"Conjugation acting on fixed element of the additive group is continuous when both\\n  `add` and `neg` are continuous.\"]\ntheorem topological_group.continuous_conj' [has_continuous_inv G] (h : G) : continuous fun g : G => g * h * g⁻¹ :=\n  (continuous_mul_right h).mul continuous_inv\n#align topological_group.continuous_conj' topological_group.continuous_conj'\n\n",
 "continuous_conj":
 "/-- Conjugation by a fixed element is continuous when `mul` is continuous. -/\n@[to_additive \"Conjugation by a fixed element is continuous when `add` is continuous.\"]\ntheorem topological_group.continuous_conj (g : G) : continuous fun h : G => g * h * g⁻¹ :=\n  (continuous_mul_right g⁻¹).comp (continuous_mul_left g)\n#align topological_group.continuous_conj topological_group.continuous_conj\n\n",
 "continuous_at_zpow":
 "@[to_additive]\ntheorem continuous_at_zpow (x : G) (z : ℤ) : continuous_at (fun x => x ^ z) x :=\n  (continuous_zpow z).continuous_at\n#align continuous_at_zpow continuous_at_zpow\n\n",
 "continuous_at_inv":
 "@[to_additive]\ntheorem continuous_at_inv {x : G} : continuous_at has_inv.inv x :=\n  continuous_inv.continuous_at\n#align continuous_at_inv continuous_at_inv\n\n",
 "const_div'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive const_sub]\ntheorem filter.tendsto.const_div' (b : G) {c : G} {f : α → G} {l : filter α} (h : tendsto f l ((nhds) c)) :\n    tendsto (fun k : α => b / f k) l ((nhds) (b / c)) :=\n  tendsto_const_nhds.div' h\n#align filter.tendsto.const_div' filter.tendsto.const_div'\n\n",
 "compact_open_separated_mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Given a compact set `K` inside an open set `U`, there is a open neighborhood `V` of `1`\n  such that `K * V ⊆ U`. -/\n@[to_additive\n      \"Given a compact set `K` inside an open set `U`, there is a open neighborhood `V` of\\n`0` such that `K + V ⊆ U`.\"]\ntheorem compact_open_separated_mul_right {K U : set G} (hK : is_compact K) (hU : is_open U) (hKU : K ⊆ U) :\n    ∃ V ∈ (nhds) (1 : G), K * V ⊆ U := by\n  apply hK.induction_on\n  · exact ⟨univ, by simp⟩\n  · rintro s t hst ⟨V, hV, hV'⟩\n    exact ⟨V, hV, (mul_subset_mul_right hst).trans hV'⟩\n  · rintro s t ⟨V, V_in, hV'⟩ ⟨W, W_in, hW'⟩\n    use V ∩ W, inter_mem V_in W_in\n    rw [union_mul]\n    exact\n      union_subset ((mul_subset_mul_left (V.inter_subset_left W)).trans hV')\n        ((mul_subset_mul_left (V.inter_subset_right W)).trans hW')\n  · intro x hx\n    have := tendsto_mul (show U ∈ (nhds) (x * 1) by simpa using hU.mem_nhds (hKU hx))\n    rw [nhds_prod_eq, mem_map, mem_prod_iff] at this\n    rcases this with ⟨t, ht, s, hs, h⟩\n    rw [← image_subset_iff, image_mul_prod] at h\n    exact ⟨t, mem_nhds_within_of_mem_nhds ht, s, hs, h⟩\n#align compact_open_separated_mul_right compact_open_separated_mul_right\n\n",
 "compact_open_separated_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Given a compact set `K` inside an open set `U`, there is a open neighborhood `V` of `1`\n  such that `V * K ⊆ U`. -/\n@[to_additive\n      \"Given a compact set `K` inside an open set `U`, there is a open neighborhood `V` of\\n`0` such that `V + K ⊆ U`.\"]\ntheorem compact_open_separated_mul_left {K U : set G} (hK : is_compact K) (hU : is_open U) (hKU : K ⊆ U) :\n    ∃ V ∈ (nhds) (1 : G), V * K ⊆ U :=\n  by\n  rcases compact_open_separated_mul_right (hK.image continuous_op) (op_homeomorph.is_open_map U hU)\n      (image_subset op hKU) with\n    ⟨V, hV : V ∈ (nhds) (op (1 : G)), hV' : «expr '' » op K * V ⊆ «expr '' » op U⟩\n  refine' ⟨«expr ⁻¹' » op V, continuous_op.continuous_at hV, _⟩\n  rwa [← image_preimage_eq V op_surjective, ← image_op_mul, image_subset_iff, preimage_image_eq _ op_injective] at hV'\n#align compact_open_separated_mul_left compact_open_separated_mul_left\n\n",
 "compact_covered_by_mul_left_translates":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- A compact set is covered by finitely many left multiplicative translates of a set\n  with non-empty interior. -/\n@[to_additive \"A compact set is covered by finitely many left additive translates of a set\\n  with non-empty interior.\"]\ntheorem compact_covered_by_mul_left_translates {K V : set G} (hK : is_compact K) (hV : (interior V).nonempty) :\n    ∃ t : Finset G,\n      K ⊆\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr ⁻¹' » (fun h => g * h) V) :=\n  by\n  obtain ⟨t, ht⟩ :\n    ∃ t : Finset G,\n      K ⊆\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (interior («expr ⁻¹' » ((· * ·) x) V)) :=\n    by\n    refine' hK.elim_finite_subcover (fun x => interior <| «expr ⁻¹' » ((· * ·) x) V) (fun x => is_open_interior) _\n    cases' hV with g₀ hg₀\n    refine' fun g hg => mem_Union.2 ⟨g₀ * g⁻¹, _⟩\n    refine' preimage_interior_subset_interior_preimage (continuous_const.mul continuous_id) _\n    rwa [mem_preimage, inv_mul_cancel_right]\n  exact ⟨t, subset.trans ht <| Union₂_mono fun g hg => interior_subset⟩\n#align compact_covered_by_mul_left_translates compact_covered_by_mul_left_translates\n\n",
 "coinduced_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprcont -/\n@[to_additive]\ntheorem coinduced_continuous {α β : Type _} [t : topological_space α] [group β] (f : α → β) :\n    (exprcont) t (coinduced f).to_topological_space f :=\n  by\n  rw [continuous_Inf_rng]\n  rintro _ ⟨t', ht', rfl⟩\n  exact continuous_iff_coinduced_le.2 ht'\n#align coinduced_continuous coinduced_continuous\n\n",
 "coe_mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, to_additive]\ntheorem homeomorph.coe_mul_right (a : G) : «expr⇑ » (homeomorph.mul_right a) = fun g => g * a :=\n  rfl\n#align homeomorph.coe_mul_right homeomorph.coe_mul_right\n\n",
 "coe_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Patrick Massot\n-/\n@[simp, to_additive]\ntheorem homeomorph.coe_mul_left (a : G) : «expr⇑ » (homeomorph.mul_left a) = (· * ·) a :=\n  rfl\n#align homeomorph.coe_mul_left homeomorph.coe_mul_left\n\n",
 "closure_mul":
 "@[to_additive]\ntheorem is_open.closure_mul (ht : is_open t) (s : set α) : closure s * t = s * t := by\n  rw [← inv_inv (closure s * t), mul_inv_rev, inv_closure, ht.inv.mul_closure, mul_inv_rev, inv_inv, inv_inv]\n#align is_open.closure_mul is_open.closure_mul\n\n",
 "closure_div":
 "@[to_additive]\ntheorem is_open.closure_div (ht : is_open t) (s : set α) : closure s / t = s / t := by\n  simp_rw [div_eq_mul_inv, ht.inv.closure_mul]\n#align is_open.closure_div is_open.closure_div\n\n"}