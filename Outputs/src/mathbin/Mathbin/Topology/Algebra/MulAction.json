{"smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Filter.Tendsto.smul_const /-\n@[to_additive]\ntheorem Filter.Tendsto.smul_const {f : α → M} {l : Filter α} {c : M} (hf : Tendsto f l ((nhds) c)) (a : X) :\n    Tendsto (fun x => «expr • » (f x) a) l ((nhds) («expr • » c a)) :=\n  hf.smul tendsto_const_nhds\n#align filter.tendsto.smul_const Filter.Tendsto.smul_const\n#align filter.tendsto.vadd_const Filter.Tendsto.vadd_const\n-/\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Continuous.smul /-\n@[continuity, to_additive]\ntheorem Continuous.smul (hf : Continuous f) (hg : Continuous g) : Continuous fun x => «expr • » (f x) (g x) :=\n  continuous_smul.comp (hf.prod_mk hg)\n#align continuous.smul Continuous.smul\n#align continuous.vadd Continuous.vadd\n-/\n\n",
 "continuousSMul_infₛ":
 "#print continuousSMul_infₛ /-\n@[to_additive]\ntheorem continuousSMul_infₛ {ts : Set (TopologicalSpace X)} (h : ∀ t ∈ ts, @ContinuousSMul M X _ _ t) :\n    @ContinuousSMul M X _ _ (infₛ ts) :=\n  {\n    continuous_smul := by\n      rw [← @infₛ_singleton _ _ ‹TopologicalSpace M›]\n      exact\n        continuous_infₛ_rng.2 fun t ht =>\n          continuous_infₛ_dom₂ (Eq.refl _) ht (@has_continuous_smul.continuous_smul _ _ _ _ t (h t ht)) }\n#align has_continuous_smul_Inf continuousSMul_infₛ\n#align has_continuous_vadd_Inf continuousVAdd_infₛ\n-/\n\n",
 "continuousSMul_infᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print continuousSMul_infᵢ /-\n@[to_additive]\ntheorem continuousSMul_infᵢ {ts' : ι → TopologicalSpace X} (h : ∀ i, @ContinuousSMul M X _ _ (ts' i)) :\n    @ContinuousSMul M X _ _\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (ts' i)) :=\n  continuousSMul_infₛ <| Set.forall_range_iff.mpr h\n#align has_continuous_smul_infi continuousSMul_infᵢ\n#align has_continuous_vadd_infi continuousVAdd_infᵢ\n-/\n\n",
 "continuousSMul_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print continuousSMul_inf /-\n@[to_additive]\ntheorem continuousSMul_inf {t₁ t₂ : TopologicalSpace X} [@ContinuousSMul M X _ _ t₁] [@ContinuousSMul M X _ _ t₂] :\n    @ContinuousSMul M X _ _ («expr ⊓ » t₁ t₂) := by\n  rw [inf_eq_infᵢ]\n  refine' continuousSMul_infᵢ fun b => _\n  cases b <;> assumption\n#align has_continuous_smul_inf continuousSMul_inf\n#align has_continuous_vadd_inf continuousVAdd_inf\n-/\n\n",
 "connectedSpace":
 "#print AddTorsor.connectedSpace /-\n/-- An `add_torsor` for a connected space is a connected space. This is not an instance because\nit loops for a group as a torsor over itself. -/\nprotected theorem AddTorsor.connectedSpace : ConnectedSpace P :=\n  { is_preconnected_univ :=\n      by\n      convert is_preconnected_univ.image (Equiv.vaddConst (Classical.arbitrary P) : G → P)\n          (continuous_id.vadd continuous_const).continuous_on\n      rw [Set.image_univ, Equiv.range_eq_univ]\n    to_nonempty := inferInstance }\n#align add_torsor.connected_space AddTorsor.connectedSpace\n-/\n\n"}