{"smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem filter.tendsto.smul_const {f : α → M} {l : filter α} {c : M} (hf : tendsto f l ((nhds) c)) (a : X) :\n    tendsto (fun x => «expr • » (f x) a) l ((nhds) («expr • » c a)) :=\n  hf.smul tendsto_const_nhds\n#align filter.tendsto.smul_const filter.tendsto.smul_const\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[continuity, to_additive]\ntheorem continuous.smul (hf : continuous f) (hg : continuous g) : continuous fun x => «expr • » (f x) (g x) :=\n  continuous_smul.comp (hf.prod_mk hg)\n#align continuous.smul continuous.smul\n\n",
 "has_continuous_smul_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[to_additive]\ntheorem has_continuous_smul_infi {ts' : ι → topological_space X} (h : ∀ i, @has_continuous_smul M X _ _ (ts' i)) :\n    @has_continuous_smul M X _ _\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (ts' i)) :=\n  has_continuous_smul_Inf <| Set.forall_range_iff.mpr h\n#align has_continuous_smul_infi has_continuous_smul_infi\n\n",
 "has_continuous_smul_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem has_continuous_smul_inf {t₁ t₂ : topological_space X} [@has_continuous_smul M X _ _ t₁]\n    [@has_continuous_smul M X _ _ t₂] : @has_continuous_smul M X _ _ («expr ⊓ » t₁ t₂) :=\n  by\n  rw [inf_eq_infᵢ]\n  refine' has_continuous_smul_infi fun b => _\n  cases b <;> assumption\n#align has_continuous_smul_inf has_continuous_smul_inf\n\n",
 "has_continuous_smul_Inf":
 "@[to_additive]\ntheorem has_continuous_smul_Inf {ts : set (topological_space X)} (h : ∀ t ∈ ts, @has_continuous_smul M X _ _ t) :\n    @has_continuous_smul M X _ _ (infₛ ts) :=\n  {\n    continuous_smul := by\n      rw [← @infₛ_singleton _ _ ‹topological_space M›]\n      exact\n        continuous_Inf_rng.2 fun t ht =>\n          continuous_Inf_dom₂ (eq.refl _) ht (@has_continuous_smul.continuous_smul _ _ _ _ t (h t ht)) }\n#align has_continuous_smul_Inf has_continuous_smul_Inf\n\n",
 "connected_space":
 "/-- An `add_torsor` for a connected space is a connected space. This is not an instance because\nit loops for a group as a torsor over itself. -/\nprotected theorem add_torsor.connected_space : connected_space P :=\n  { is_preconnected_univ :=\n      by\n      convert\n        is_preconnected_univ.image (equiv.vadd_const (classical.arbitrary P) : G → P)\n          (continuous_id.vadd continuous_const).continuous_on\n      rw [Set.image_univ, Equiv.range_eq_univ]\n    to_nonempty := infer_instance }\n#align add_torsor.connected_space add_torsor.connected_space\n\n"}