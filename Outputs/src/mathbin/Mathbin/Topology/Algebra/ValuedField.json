{"inversion_estimate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-\nCopyright (c) 2021 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot\n-/\n-- The following is the main technical lemma ensuring that inversion is continuous\n-- in the topology induced by a valuation on a division ring (ie the next instance)\n-- and the fact that a valued field is completable\n-- [BouAC, VI.5.1 Lemme 1]\ntheorem valuation.inversion_estimate {x y : K} {γ : «expr ˣ» Γ₀} (y_ne : y ≠ 0)\n    (h : v (x - y) < min (γ * (v y * v y)) (v y)) : v (x⁻¹ - y⁻¹) < γ :=\n  by\n  have hyp1 : v (x - y) < γ * (v y * v y) := lt_of_lt_of_le h (min_le_left _ _)\n  have hyp1' : v (x - y) * (v y * v y)⁻¹ < γ := mul_inv_lt_of_lt_mul₀ hyp1\n  have hyp2 : v (x - y) < v y := lt_of_lt_of_le h (min_le_right _ _)\n  have key : v x = v y := valuation.map_eq_of_sub_lt v hyp2\n  have x_ne : x ≠ 0 := by\n    intro h\n    apply y_ne\n    rw [h, v.map_zero] at key\n    exact v.zero_iff.1 key.symm\n  have decomp : x⁻¹ - y⁻¹ = x⁻¹ * (y - x) * y⁻¹ := by\n    rw [mul_sub_left_distrib, sub_mul, mul_assoc, show y * y⁻¹ = 1 from mul_inv_cancel y_ne,\n      show x⁻¹ * x = 1 from inv_mul_cancel x_ne, mul_one, one_mul]\n  calc\n    v (x⁻¹ - y⁻¹) = v (x⁻¹ * (y - x) * y⁻¹) := by rw [decomp]\n    _ = v x⁻¹ * (v <| y - x) * v y⁻¹ := by repeat' rw [valuation.map_mul]\n    _ = (v x)⁻¹ * (v <| y - x) * (v y)⁻¹ := by rw [map_inv₀, map_inv₀]\n    _ = (v <| y - x) * (v y * v y)⁻¹ := by rw [mul_assoc, mul_comm, key, mul_assoc, mul_inv_rev]\n    _ = (v <| y - x) * (v y * v y)⁻¹ := rfl\n    _ = (v <| x - y) * (v y * v y)⁻¹ := by rw [valuation.map_sub_swap]\n    _ < γ := hyp1'\n    \n#align valuation.inversion_estimate valuation.inversion_estimate\n\n",
 "extension_extends":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n@[simp, norm_cast]\ntheorem extension_extends (x : K) : extension (x : (exprhat) K) = v x :=\n  by\n  refine' completion.dense_inducing_coe.extend_eq_of_tendsto _\n  rw [← completion.dense_inducing_coe.nhds_eq_comap]\n  exact valued.continuous_valuation.continuous_at\n#align extension_extends extension_extends\n\n",
 "continuous_valuation":
 "theorem valued.continuous_valuation [valued K Γ₀] : continuous (v : K → Γ₀) :=\n  by\n  rw [continuous_iff_continuous_at]\n  intro x\n  rcases eq_or_ne x 0 with (rfl | h)\n  · rw [continuous_at, map_zero, linear_ordered_comm_group_with_zero.tendsto_zero]\n    intro γ hγ\n    rw [filter.eventually, valued.mem_nhds_zero]\n    use Units.mk0 γ hγ, subset.rfl\n  · have v_ne : (v x : Γ₀) ≠ 0 := (valuation.ne_zero_iff _).mpr h\n    rw [continuous_at, linear_ordered_comm_group_with_zero.tendsto_of_ne_zero v_ne]\n    apply valued.loc_const v_ne\n#align valued.continuous_valuation valued.continuous_valuation\n\n",
 "continuous_extension":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x y «expr ∈ » V') -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\ntheorem continuous_extension : continuous (valued.extension : (exprhat) K → Γ₀) :=\n  by\n  refine' completion.dense_inducing_coe.continuous_extend _\n  intro x₀\n  rcases eq_or_ne x₀ 0 with (rfl | h)\n  · refine' ⟨0, _⟩\n    erw [← completion.dense_inducing_coe.to_inducing.nhds_eq_comap]\n    exact valued.continuous_valuation.tendsto' 0 0 (map_zero v)\n  · have preimage_one : «expr ⁻¹' » v {(1 : Γ₀)} ∈ (nhds) (1 : K) :=\n      by\n      have : (v (1 : K) : Γ₀) ≠ 0 := by\n        rw [valuation.map_one]\n        exact zero_ne_one.symm\n      convert valued.loc_const this\n      ext x\n      rw [valuation.map_one, mem_preimage, mem_singleton_iff, mem_set_of_eq]\n    obtain ⟨V, V_in, hV⟩ : ∃ V ∈ (nhds) (1 : (exprhat) K), ∀ x : K, (x : (exprhat) K) ∈ V → (v x : Γ₀) = 1 := by\n      rwa [completion.dense_inducing_coe.nhds_eq_comap, mem_comap] at preimage_one\n    have : ∃ V' ∈ (nhds) (1 : (exprhat) K), (0 : (exprhat) K) ∉ V' ∧ ∀ (x) (_ : x ∈ V') (y) (_ : y ∈ V'), x * y⁻¹ ∈ V :=\n      by\n      have : tendsto (fun p : (exprhat) K × (exprhat) K => p.1 * p.2⁻¹) (((nhds) 1).prod ((nhds) 1)) ((nhds) 1) :=\n        by\n        rw [← nhds_prod_eq]\n        conv =>\n          congr\n          skip\n          skip\n          rw [← one_mul (1 : (exprhat) K)]\n        refine' tendsto.mul continuous_fst.continuous_at (tendsto.comp _ continuous_snd.continuous_at)\n        convert continuous_at_inv₀ (zero_ne_one.symm : 1 ≠ (0 : (exprhat) K))\n        exact inv_one.symm\n      rcases tendsto_prod_self_iff.mp this V V_in with ⟨U, U_in, hU⟩\n      let hatKstar := («expr ᶜ» {0} : set <| (exprhat) K)\n      have : hatKstar ∈ (nhds) (1 : (exprhat) K) := compl_singleton_mem_nhds zero_ne_one.symm\n      use U ∩ hatKstar, filter.inter_mem U_in this\n      constructor\n      · rintro ⟨h, h'⟩\n        rw [mem_compl_singleton_iff] at h'\n        exact h' rfl\n      · rintro x ⟨hx, _⟩ y ⟨hy, _⟩\n        apply hU <;> assumption\n    rcases this with ⟨V', V'_in, zeroV', hV'⟩\n    have nhds_right : «expr '' » (fun x => x * x₀) V' ∈ (nhds) x₀ :=\n      by\n      have l : function.left_inverse (fun x : (exprhat) K => x * x₀⁻¹) fun x : (exprhat) K => x * x₀ :=\n        by\n        intro x\n        simp only [mul_assoc, mul_inv_cancel h, mul_one]\n      have r : function.right_inverse (fun x : (exprhat) K => x * x₀⁻¹) fun x : (exprhat) K => x * x₀ :=\n        by\n        intro x\n        simp only [mul_assoc, inv_mul_cancel h, mul_one]\n      have c : continuous fun x : (exprhat) K => x * x₀⁻¹ := continuous_id.mul continuous_const\n      rw [image_eq_preimage_of_inverse l r]\n      rw [← mul_inv_cancel h] at V'_in\n      exact c.continuous_at V'_in\n    have : ∃ z₀ : K, ∃ y₀ ∈ V', coe z₀ = y₀ * x₀ ∧ z₀ ≠ 0 :=\n      by\n      rcases completion.dense_range_coe.mem_nhds nhds_right with ⟨z₀, y₀, y₀_in, H : y₀ * x₀ = z₀⟩\n      refine' ⟨z₀, y₀, y₀_in, ⟨H.symm, _⟩⟩\n      rintro rfl\n      exact mul_ne_zero (ne_of_mem_of_not_mem y₀_in zeroV') h H\n    rcases this with ⟨z₀, y₀, y₀_in, hz₀, z₀_ne⟩\n    have vz₀_ne : (v z₀ : Γ₀) ≠ 0 := by rwa [valuation.ne_zero_iff]\n    refine' ⟨v z₀, _⟩\n    rw [linear_ordered_comm_group_with_zero.tendsto_of_ne_zero vz₀_ne, eventually_comap]\n    filter_upwards [nhds_right] with x x_in a ha\n    rcases x_in with ⟨y, y_in, rfl⟩\n    have : (v (a * z₀⁻¹) : Γ₀) = 1 := by\n      apply hV\n      have : ((z₀⁻¹ : K) : (exprhat) K) = z₀⁻¹ := map_inv₀ (completion.coe_ring_hom : «expr →+* » K ((exprhat) K)) z₀\n      rw [completion.coe_mul, this, ha, hz₀, mul_inv, mul_comm y₀⁻¹, ← mul_assoc, mul_assoc y, mul_inv_cancel h,\n        mul_one]\n      solve_by_elim\n    calc\n      v a = v (a * z₀⁻¹ * z₀) := by rw [mul_assoc, inv_mul_cancel z₀_ne, mul_one]\n      _ = v (a * z₀⁻¹) * v z₀ := valuation.map_mul _ _ _\n      _ = v z₀ := by rw [this, one_mul]\n      \n#align continuous_extension continuous_extension\n\n",
 "closure_coe_completion_v_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprhat -/\n-- Bourbaki CA VI §5 no.3 Proposition 5 (d)\ntheorem closure_coe_completion_v_lt {γ : «expr ˣ» Γ₀} :\n    closure («expr '' » coe { x : K | v x < (γ : Γ₀) }) = { x : (exprhat) K | extension_valuation x < (γ : Γ₀) } :=\n  by\n  ext x\n  let γ₀ := extension_valuation x\n  suffices γ₀ ≠ 0 → (x ∈ closure («expr '' » coe { x : K | v x < (γ : Γ₀) }) ↔ γ₀ < (γ : Γ₀))\n    by\n    cases eq_or_ne γ₀ 0\n    · simp only [h, (valuation.zero_iff _).mp h, mem_set_of_eq, valuation.map_zero, Units.zero_lt, iff_true_iff]\n      apply subset_closure\n      exact ⟨0, by simpa only [mem_set_of_eq, valuation.map_zero, Units.zero_lt, true_and_iff] ⟩\n    · exact this h\n  intro h\n  have hγ₀ : «expr ⁻¹' » extension {γ₀} ∈ (nhds) x :=\n    continuous_extension.continuous_at.preimage_mem_nhds\n      (linear_ordered_comm_group_with_zero.singleton_mem_nhds_of_ne_zero h)\n  rw [mem_closure_iff_nhds']\n  refine' ⟨fun hx => _, fun hx s hs => _⟩\n  · obtain ⟨⟨-, y, hy₁ : v y < (γ : Γ₀), rfl⟩, hy₂⟩ := hx _ hγ₀\n    replace hy₂ : v y = γ₀\n    · simpa using hy₂\n    rwa [← hy₂]\n  · obtain ⟨y, hy₁, hy₂ : ↑y ∈ s⟩ := completion.dense_range_coe.mem_nhds (inter_mem hγ₀ hs)\n    replace hy₁ : v y = γ₀\n    · simpa using hy₁\n    rw [← hy₁] at hx\n    exact ⟨⟨y, ⟨y, hx, rfl⟩⟩, hy₂⟩\n#align closure_coe_completion_v_lt closure_coe_completion_v_lt\n\n"}