{"tendsto_zpow_at_top_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_zpow_at_top_zero {n : ℤ} (hn : n < 0) : tendsto (fun x : α => x ^ n) at_top ((nhds) 0) :=\n  by\n  lift -n to ℕ using le_of_lt (neg_pos.mpr hn) with N\n  rw [← neg_pos, ← h, nat.cast_pos] at hn\n  simpa only [h, neg_neg] using tendsto_pow_neg_at_top hn.ne'\n#align tendsto_zpow_at_top_zero tendsto_zpow_at_top_zero\n\n",
 "tendsto_pow_neg_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The function `x^(-n)` tends to `0` at `+∞` for any positive natural `n`.\nA version for positive real powers exists as `tendsto_rpow_neg_at_top`. -/\ntheorem tendsto_pow_neg_at_top {n : ℕ} (hn : n ≠ 0) : tendsto (fun x : α => x ^ (-(n : ℤ))) at_top ((nhds) 0) := by\n  simpa only [zpow_neg, zpow_ofNat] using (@tendsto_pow_at_top α _ _ hn).inv_tendsto_at_top\n#align tendsto_pow_neg_at_top tendsto_pow_neg_at_top\n\n",
 "tendsto_inv_zero_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/-- The function `x ↦ x⁻¹` tends to `+∞` on the right of `0`. -/\ntheorem tendsto_inv_zero_at_top : tendsto (fun x : α => x⁻¹) (nhds_within.gt (0 : α)) at_top :=\n  by\n  refine' (at_top_basis' 1).tendsto_right_iff.2 fun b hb => _\n  have hb' : 0 < b := by positivity\n  filter_upwards [Ioc_mem_nhds_within_Ioi ⟨le_rfl, inv_pos.2 hb'⟩] with x hx using(le_inv hx.1 hb').1 hx.2\n#align tendsto_inv_zero_at_top tendsto_inv_zero_at_top\n\n",
 "tendsto_inv_at_top_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/-- The function `r ↦ r⁻¹` tends to `0` on the right as `r → +∞`. -/\ntheorem tendsto_inv_at_top_zero' : tendsto (fun r : α => r⁻¹) at_top (nhds_within.gt (0 : α)) :=\n  by\n  refine' (has_basis.tendsto_iff at_top_basis ⟨fun s => mem_nhds_within_Ioi_iff_exists_Ioc_subset⟩).2 _\n  refine' fun b hb => ⟨b⁻¹, trivial, fun x hx => _⟩\n  have : 0 < x := lt_of_lt_of_le (inv_pos.2 hb) hx\n  exact ⟨inv_pos.2 this, (inv_le this hb).2 hx⟩\n#align tendsto_inv_at_top_zero' tendsto_inv_at_top_zero'\n\n",
 "tendsto_inv_at_top_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_inv_at_top_zero : tendsto (fun r : α => r⁻¹) at_top ((nhds) 0) :=\n  tendsto_inv_at_top_zero'.mono_right inf_le_left\n#align tendsto_inv_at_top_zero tendsto_inv_at_top_zero\n\n",
 "tendsto_const_mul_zpow_at_top_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_const_mul_zpow_at_top_zero {n : ℤ} {c : α} (hn : n < 0) :\n    tendsto (fun x => c * x ^ n) at_top ((nhds) 0) :=\n  mul_zero c ▸ filter.tendsto.const_mul c (tendsto_zpow_at_top_zero hn)\n#align tendsto_const_mul_zpow_at_top_zero tendsto_const_mul_zpow_at_top_zero\n\n",
 "tendsto_const_mul_zpow_at_top_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_const_mul_zpow_at_top_nhds_iff {n : ℤ} {c d : α} (hc : c ≠ 0) :\n    tendsto (fun x : α => c * x ^ n) at_top ((nhds) d) ↔ n = 0 ∧ c = d ∨ n < 0 ∧ d = 0 :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · by_cases hn : 0 ≤ n\n    · lift n to ℕ using hn\n      simp only [zpow_ofNat] at h\n      rw [tendsto_const_mul_pow_nhds_iff hc, ← Int.coe_nat_eq_zero] at h\n      exact or.inl h\n    · rw [not_le] at hn\n      refine' or.inr ⟨hn, tendsto_nhds_unique h (tendsto_const_mul_zpow_at_top_zero hn)⟩\n  · cases h\n    · simp only [h.left, h.right, zpow_zero, mul_one]\n      exact tendsto_const_nhds\n    · exact h.2.symm ▸ tendsto_const_mul_zpow_at_top_zero h.1\n#align tendsto_const_mul_zpow_at_top_nhds_iff tendsto_const_mul_zpow_at_top_nhds_iff\n\n",
 "tendsto_const_mul_pow_nhds_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_const_mul_pow_nhds_iff' {n : ℕ} {c d : α} :\n    tendsto (fun x : α => c * x ^ n) at_top ((nhds) d) ↔ (c = 0 ∨ n = 0) ∧ c = d :=\n  by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp [tendsto_const_nhds_iff]\n  rcases lt_trichotomy c 0 with (hc | rfl | hc)\n  · have := tendsto_const_mul_pow_at_bot_iff.2 ⟨hn, hc⟩\n    simp [not_tendsto_nhds_of_tendsto_at_bot this, hc.ne, hn]\n  · simp [tendsto_const_nhds_iff]\n  · have := tendsto_const_mul_pow_at_top_iff.2 ⟨hn, hc⟩\n    simp [not_tendsto_nhds_of_tendsto_at_top this, hc.ne', hn]\n#align tendsto_const_mul_pow_nhds_iff' tendsto_const_mul_pow_nhds_iff'\n\n",
 "tendsto_const_mul_pow_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_const_mul_pow_nhds_iff {n : ℕ} {c d : α} (hc : c ≠ 0) :\n    tendsto (fun x : α => c * x ^ n) at_top ((nhds) d) ↔ n = 0 ∧ c = d := by simp [tendsto_const_mul_pow_nhds_iff', hc]\n#align tendsto_const_mul_pow_nhds_iff tendsto_const_mul_pow_nhds_iff\n\n",
 "nhds_within_pos_comap_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n-- TODO: With a different proof, this could be possibly generalised to only require a\n-- `linear_ordered_semifield` instance, which would also remove the need for the\n-- `nnreal` instance of `has_continuous_inv₀`.\n-- see Note [lower instance priority]\ntheorem nhds_within_pos_comap_mul_left {x : α} (hx : 0 < x) :\n    comap (fun ε => x * ε) (nhds_within.gt 0) = nhds_within.gt 0 :=\n  by\n  suffices ∀ {x : α} (hx : 0 < x), nhds_within.gt 0 ≤ comap (fun ε => x * ε) (nhds_within.gt 0)\n    by\n    refine' le_antisymm _ (this hx)\n    have hr : nhds_within.gt (0 : α) = ((nhds_within.gt (0 : α)).comap fun ε => x⁻¹ * ε).comap fun ε => x * ε := by\n      simp [comap_comap, inv_mul_cancel hx.ne.symm, comap_id, one_mul_eq_id]\n    conv_rhs => rw [hr]\n    rw [comap_le_comap_iff (by convert univ_mem <;> exact (mul_left_surjective₀ hx.ne.symm).range_eq)]\n    exact this (inv_pos.mpr hx)\n  intro x hx\n  convert nhds_within_le_comap (continuous_mul_left x).continuous_within_at\n  · exact (mul_zero _).symm\n  · rw [image_const_mul_Ioi_zero hx]\n#align nhds_within_pos_comap_mul_left nhds_within_pos_comap_mul_left\n\n",
 "nhds_eq_map_mul_right_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_eq_map_mul_right_nhds_one {x₀ : α} (hx₀ : x₀ ≠ 0) : (nhds) x₀ = map (fun x => x * x₀) ((nhds) 1) := by\n  simp_rw [mul_comm _ x₀, nhds_eq_map_mul_left_nhds_one hx₀]\n#align nhds_eq_map_mul_right_nhds_one nhds_eq_map_mul_right_nhds_one\n\n",
 "nhds_eq_map_mul_left_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_eq_map_mul_left_nhds_one {x₀ : α} (hx₀ : x₀ ≠ 0) : (nhds) x₀ = map (fun x => x₀ * x) ((nhds) 1) :=\n  by\n  have hx₀' : 0 < |x₀| := abs_pos.2 hx₀\n  refine' filter.ext fun t => _\n  simp only [exists_prop, set_of_subset_set_of, (nhds_basis_abs_sub_lt x₀).mem_iff,\n    (nhds_basis_abs_sub_lt (1 : α)).mem_iff, filter.mem_map']\n  refine' ⟨fun h => _, fun h => _⟩\n  · obtain ⟨i, hi, hit⟩ := h\n    refine' ⟨i / |x₀|, div_pos hi (abs_pos.2 hx₀), fun x hx => hit _⟩\n    calc\n      |x₀ * x - x₀| = |x₀ * (x - 1)| := congr_arg abs (by ring_nf)\n      _ = |x₀| * |x - 1| := abs_mul x₀ (x - 1)\n      _ < |x₀| * (i / |x₀|) := mul_lt_mul' le_rfl hx (by positivity) (abs_pos.2 hx₀)\n      _ = |x₀| * i / |x₀| := by ring\n      _ = i := mul_div_cancel_left i fun h => hx₀ (abs_eq_zero.1 h)\n      \n  · obtain ⟨i, hi, hit⟩ := h\n    refine' ⟨i * |x₀|, mul_pos hi (abs_pos.2 hx₀), fun x hx => _⟩\n    have : |x / x₀ - 1| < i\n    calc\n      |x / x₀ - 1| = |x / x₀ - x₀ / x₀| := by rw [div_self hx₀]\n      _ = |(x - x₀) / x₀| := congr_arg abs (sub_div x x₀ x₀).symm\n      _ = |x - x₀| / |x₀| := abs_div (x - x₀) x₀\n      _ < i * |x₀| / |x₀| := div_lt_div_of_lt (abs_pos.2 hx₀) hx\n      _ = i := by rw [← mul_div_assoc', div_self (ne_of_lt <| abs_pos.2 hx₀).symm, mul_one]\n      \n    specialize hit (x / x₀) this\n    rwa [mul_div_assoc', mul_div_cancel_left x hx₀] at hit\n#align nhds_eq_map_mul_left_nhds_one nhds_eq_map_mul_left_nhds_one\n\n",
 "neg_mul_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and\n`g` tends to `at_top` then `f * g` tends to `at_bot`. -/\ntheorem filter.tendsto.neg_mul_at_top {C : α} (hC : C < 0) (hf : tendsto f l ((nhds) C)) (hg : tendsto g l at_top) :\n    tendsto (fun x => f x * g x) l at_bot := by simpa only [mul_comm] using hg.at_top_mul_neg hC hf\n#align filter.tendsto.neg_mul_at_top filter.tendsto.neg_mul_at_top\n\n",
 "neg_mul_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and\n`g` tends to `at_bot` then `f * g` tends to `at_top`. -/\ntheorem filter.tendsto.neg_mul_at_bot {C : α} (hC : C < 0) (hf : tendsto f l ((nhds) C)) (hg : tendsto g l at_bot) :\n    tendsto (fun x => f x * g x) l at_top := by simpa only [mul_comm] using hg.at_bot_mul_neg hC hf\n#align filter.tendsto.neg_mul_at_bot filter.tendsto.neg_mul_at_bot\n\n",
 "mul_tendsto_nhds_zero_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-\nCopyright (c) 2022 Benjamin Davidson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Benjamin Davidson, Devon Tuma, Eric Rodriguez, Oliver Nash\n-/\ntheorem mul_tendsto_nhds_zero_right (x : α) :\n    tendsto (uncurry ((· * ·) : α → α → α)) (filter.prod ((nhds) 0) ((nhds) x)) <| (nhds) 0 :=\n  by\n  have hx : 0 < 2 * (1 + |x|) := by positivity\n  rw [((nhds_basis_zero_abs_sub_lt α).prod <| nhds_basis_abs_sub_lt x).tendsto_iff (nhds_basis_zero_abs_sub_lt α)]\n  refine' fun ε ε_pos => ⟨(ε / (2 * (1 + |x|)), 1), ⟨div_pos ε_pos hx, zero_lt_one⟩, _⟩\n  suffices ∀ a b : α, |a| < ε / (2 * (1 + |x|)) → |b - x| < 1 → |a| * |b| < ε by\n    simpa only [and_imp, prod.forall, mem_prod, ← abs_mul]\n  intro a b h h'\n  refine' lt_of_le_of_lt (mul_le_mul_of_nonneg_left _ (abs_nonneg a)) ((lt_div_iff hx).1 h)\n  calc\n    |b| = |b - x + x| := by rw [sub_add_cancel b x]\n    _ ≤ |b - x| + |x| := abs_add (b - x) x\n    _ ≤ 2 * (1 + |x|) := by linarith\n    \n#align mul_tendsto_nhds_zero_right mul_tendsto_nhds_zero_right\n\n",
 "mul_tendsto_nhds_zero_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mul_tendsto_nhds_zero_left (x : α) :\n    tendsto (uncurry ((· * ·) : α → α → α)) (filter.prod ((nhds) x) ((nhds) 0)) <| (nhds) 0 :=\n  by\n  intro s hs\n  have := mul_tendsto_nhds_zero_right x hs\n  rw [filter.mem_map, mem_prod_iff] at this⊢\n  obtain ⟨U, hU, V, hV, h⟩ := this\n  exact\n    ⟨V, hV, U, hU, fun y hy =>\n      (mul_comm y.2 y.1 ▸ h (⟨hy.2, hy.1⟩ : prod.mk y.2 y.1 ∈ lower_set.prod U V) : y.1 * y.2 ∈ s)⟩\n#align mul_tendsto_nhds_zero_left mul_tendsto_nhds_zero_left\n\n",
 "mul_tendsto_nhds_one_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mul_tendsto_nhds_one_nhds_one :\n    tendsto (uncurry ((· * ·) : α → α → α)) (filter.prod ((nhds) 1) ((nhds) 1)) <| (nhds) 1 :=\n  by\n  rw [((nhds_basis_Ioo_pos (1 : α)).prod <| nhds_basis_Ioo_pos (1 : α)).tendsto_iff\n      (nhds_basis_Ioo_pos_of_pos (zero_lt_one : (0 : α) < 1))]\n  intro ε hε\n  have hε' : 0 ≤ 1 - ε / 4 := by linarith\n  have ε_pos : 0 < ε / 4 := by linarith\n  have ε_pos' : 0 < ε / 2 := by linarith\n  simp only [and_imp, prod.forall, mem_Ioo, function.uncurry_apply_pair, mem_prod, prod.exists]\n  refine' ⟨ε / 4, ε / 4, ⟨ε_pos, ε_pos⟩, fun a b ha ha' hb hb' => _⟩\n  have ha0 : 0 ≤ a := le_trans hε' (le_of_lt ha)\n  have hb0 : 0 ≤ b := le_trans hε' (le_of_lt hb)\n  refine' ⟨lt_of_le_of_lt _ (mul_lt_mul'' ha hb hε' hε'), lt_of_lt_of_le (mul_lt_mul'' ha' hb' ha0 hb0) _⟩\n  ·\n    calc\n      1 - ε = 1 - ε / 2 - ε / 2 := by ring_nf\n      _ ≤ 1 - ε / 2 - ε / 2 + ε / 2 * (ε / 2) := le_add_of_nonneg_right (by positivity)\n      _ = (1 - ε / 2) * (1 - ε / 2) := by ring_nf\n      _ ≤ (1 - ε / 4) * (1 - ε / 4) := mul_le_mul (by linarith) (by linarith) (by linarith) hε'\n      \n  ·\n    calc\n      (1 + ε / 4) * (1 + ε / 4) = 1 + ε / 2 + ε / 4 * (ε / 4) := by ring_nf\n      _ = 1 + ε / 2 + ε * ε / 16 := by ring_nf\n      _ ≤ 1 + ε / 2 + ε / 2 :=\n        add_le_add_left\n          (div_le_div (le_of_lt hε.1) (le_trans ((mul_le_mul_left hε.1).2 hε.2) (le_of_eq <| mul_one ε)) zero_lt_two\n            (by linarith))\n          (1 + ε / 2)\n      _ ≤ 1 + ε := by ring_nf\n      \n#align mul_tendsto_nhds_one_nhds_one mul_tendsto_nhds_one_nhds_one\n\n",
 "mul_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and\n`g` tends to `at_top` then `f * g` tends to `at_top`. -/\ntheorem filter.tendsto.mul_at_top {C : α} (hC : 0 < C) (hf : tendsto f l ((nhds) C)) (hg : tendsto g l at_top) :\n    tendsto (fun x => f x * g x) l at_top := by simpa only [mul_comm] using hg.at_top_mul hC hf\n#align filter.tendsto.mul_at_top filter.tendsto.mul_at_top\n\n",
 "mul_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and\n`g` tends to `at_bot` then `f * g` tends to `at_bot`. -/\ntheorem filter.tendsto.mul_at_bot {C : α} (hC : 0 < C) (hf : tendsto f l ((nhds) C)) (hg : tendsto g l at_bot) :\n    tendsto (fun x => f x * g x) l at_bot := by simpa only [mul_comm] using hg.at_bot_mul hC hf\n#align filter.tendsto.mul_at_bot filter.tendsto.mul_at_bot\n\n",
 "inv_tendsto_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem filter.tendsto.inv_tendsto_zero (h : tendsto f l (nhds_within.gt 0)) : tendsto f⁻¹ l at_top :=\n  tendsto_inv_zero_at_top.comp h\n#align filter.tendsto.inv_tendsto_zero filter.tendsto.inv_tendsto_zero\n\n",
 "inv_tendsto_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.inv_tendsto_at_top (h : tendsto f l at_top) : tendsto f⁻¹ l ((nhds) 0) :=\n  tendsto_inv_at_top_zero.comp h\n#align filter.tendsto.inv_tendsto_at_top filter.tendsto.inv_tendsto_at_top\n\n",
 "eventually_nhds_within_pos_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem eventually_nhds_within_pos_mul_left {x : α} (hx : 0 < x) {p : α → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (nhds_within.gt 0) (p ε)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.gt 0) (p (x * ε)) :=\n  by\n  convert h.comap fun ε => x * ε\n  exact (nhds_within_pos_comap_mul_left hx).symm\n#align eventually_nhds_within_pos_mul_left eventually_nhds_within_pos_mul_left\n\n",
 "div_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.div_at_top [has_continuous_mul α] {f g : β → α} {l : filter β} {a : α}\n    (h : tendsto f l ((nhds) a)) (hg : tendsto g l at_top) : tendsto (fun x => f x / g x) l ((nhds) 0) :=\n  by\n  simp only [div_eq_mul_inv]\n  exact mul_zero a ▸ h.mul (tendsto_inv_at_top_zero.comp hg)\n#align filter.tendsto.div_at_top filter.tendsto.div_at_top\n\n",
 "at_top_mul_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a linearly ordered field with the order topology, if `f` tends to `at_top` and `g` tends to\na negative constant `C` then `f * g` tends to `at_bot`. -/\ntheorem filter.tendsto.at_top_mul_neg {C : α} (hC : C < 0) (hf : tendsto f l at_top) (hg : tendsto g l ((nhds) C)) :\n    tendsto (fun x => f x * g x) l at_bot := by\n  simpa only [(· ∘ ·), neg_mul_eq_mul_neg, neg_neg] using\n    tendsto_neg_at_top_at_bot.comp (hf.at_top_mul (neg_pos.2 hC) hg.neg)\n#align filter.tendsto.at_top_mul_neg filter.tendsto.at_top_mul_neg\n\n",
 "at_top_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n-- see Note [lower instance priority]\n/-- In a linearly ordered field with the order topology, if `f` tends to `at_top` and `g` tends to\na positive constant `C` then `f * g` tends to `at_top`. -/\ntheorem filter.tendsto.at_top_mul {C : α} (hC : 0 < C) (hf : tendsto f l at_top) (hg : tendsto g l ((nhds) C)) :\n    tendsto (fun x => f x * g x) l at_top :=\n  by\n  refine' tendsto_at_top_mono' _ _ (hf.at_top_mul_const (half_pos hC))\n  filter_upwards [hg.eventually (lt_mem_nhds (half_lt_self hC)),\n    hf.eventually (eventually_ge_at_top 0)] with x hg hf using mul_le_mul_of_nonneg_left hg.le hf\n#align filter.tendsto.at_top_mul filter.tendsto.at_top_mul\n\n",
 "at_bot_mul_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a linearly ordered field with the order topology, if `f` tends to `at_bot` and `g` tends to\na negative constant `C` then `f * g` tends to `at_top`. -/\ntheorem filter.tendsto.at_bot_mul_neg {C : α} (hC : C < 0) (hf : tendsto f l at_bot) (hg : tendsto g l ((nhds) C)) :\n    tendsto (fun x => f x * g x) l at_top := by\n  simpa [(· ∘ ·)] using tendsto_neg_at_bot_at_top.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul_neg hC hg)\n#align filter.tendsto.at_bot_mul_neg filter.tendsto.at_bot_mul_neg\n\n",
 "at_bot_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a linearly ordered field with the order topology, if `f` tends to `at_bot` and `g` tends to\na positive constant `C` then `f * g` tends to `at_bot`. -/\ntheorem filter.tendsto.at_bot_mul {C : α} (hC : 0 < C) (hf : tendsto f l at_bot) (hg : tendsto g l ((nhds) C)) :\n    tendsto (fun x => f x * g x) l at_bot := by\n  simpa [(· ∘ ·)] using tendsto_neg_at_top_at_bot.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul hC hg)\n#align filter.tendsto.at_bot_mul filter.tendsto.at_bot_mul\n\n"}