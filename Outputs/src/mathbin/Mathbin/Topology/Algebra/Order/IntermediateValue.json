{"surjective'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print Continuous.surjective' /-\n/-- A continuous function which tendsto `at_bot` `at_top` and to `at_top` `at_bot` is surjective. -/\ntheorem Continuous.surjective' {f : α → δ} (hf : Continuous f) (h_top : Tendsto f atBot atTop)\n    (h_bot : Tendsto f atTop atBot) : function.surjective f :=\n  @Continuous.surjective («expr ᵒᵈ» α) _ _ _ _ _ _ _ _ _ hf h_top h_bot\n#align continuous.surjective' Continuous.surjective'\n-/\n\n",
 "surjective":
 "#print Continuous.surjective /-\n/-- A continuous function which tendsto `at_top` `at_top` and to `at_bot` `at_bot` is surjective. -/\ntheorem Continuous.surjective {f : α → δ} (hf : Continuous f) (h_top : Tendsto f atTop atTop)\n    (h_bot : Tendsto f atBot atBot) : function.surjective f := fun p =>\n  mem_range_of_exists_le_of_exists_ge hf (h_bot.eventually (eventually_le_atBot p)).exists\n    (h_top.eventually (eventually_ge_atTop p)).exists\n#align continuous.surjective Continuous.surjective\n-/\n\n",
 "surjOn_uIcc":
 "#print ContinuousOn.surjOn_uIcc /-\n/-- **Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\n`b` are two points of this set, then `f` sends `s` to a superset of `[f x, f y]`. -/\ntheorem ContinuousOn.surjOn_uIcc {s : Set α} [hs : OrdConnected s] {f : α → δ} (hf : ContinuousOn f s) {a b : α}\n    (ha : a ∈ s) (hb : b ∈ s) : SurjOn f s (uIcc (f a) (f b)) := by\n  cases' le_total (f a) (f b) with hab hab <;> simp [hf.surj_on_Icc, *]\n#align continuous_on.surj_on_uIcc ContinuousOn.surjOn_uIcc\n-/\n\n",
 "surjOn_of_tendsto'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print ContinuousOn.surjOn_of_tendsto' /-\n/-- If a function `f : α → β` is continuous on a nonempty interval `s`, its restriction to `s`\ntends to `at_top : filter β` along `at_bot : filter ↥s` and tends to `at_bot : filter β` along\n`at_top : filter ↥s`, then the restriction of `f` to `s` is surjective. We formulate the\nconclusion as `surj_on f s univ`. -/\ntheorem ContinuousOn.surjOn_of_tendsto' {f : α → δ} {s : Set α} [OrdConnected s] (hs : s.nonempty)\n    (hf : ContinuousOn f s) (hbot : Tendsto (fun x : s => f x) atBot atTop)\n    (htop : Tendsto (fun x : s => f x) atTop atBot) : SurjOn f s univ :=\n  @ContinuousOn.surjOn_of_tendsto α _ _ _ _ («expr ᵒᵈ» δ) _ _ _ _ _ _ hs hf hbot htop\n#align continuous_on.surj_on_of_tendsto' ContinuousOn.surjOn_of_tendsto'\n-/\n\n",
 "surjOn_of_tendsto":
 "#print ContinuousOn.surjOn_of_tendsto /-\n/-- If a function `f : α → β` is continuous on a nonempty interval `s`, its restriction to `s`\ntends to `at_bot : filter β` along `at_bot : filter ↥s` and tends to `at_top : filter β` along\n`at_top : filter ↥s`, then the restriction of `f` to `s` is surjective. We formulate the\nconclusion as `surj_on f s univ`. -/\ntheorem ContinuousOn.surjOn_of_tendsto {f : α → δ} {s : Set α} [OrdConnected s] (hs : s.nonempty)\n    (hf : ContinuousOn f s) (hbot : Tendsto (fun x : s => f x) atBot atBot)\n    (htop : Tendsto (fun x : s => f x) atTop atTop) : SurjOn f s univ :=\n  haveI := Classical.inhabited_of_nonempty hs.to_subtype\n  surj_on_iff_surjective.2 <| (continuousOn_iff_continuous_restrict.1 hf).surjective htop hbot\n#align continuous_on.surj_on_of_tendsto ContinuousOn.surjOn_of_tendsto\n-/\n\n",
 "surjOn_Icc":
 "#print ContinuousOn.surjOn_Icc /-\n/-- **Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\n`b` are two points of this set, then `f` sends `s` to a superset of `Icc (f x) (f y)`. -/\ntheorem ContinuousOn.surjOn_Icc {s : Set α} [hs : OrdConnected s] {f : α → δ} (hf : ContinuousOn f s) {a b : α}\n    (ha : a ∈ s) (hb : b ∈ s) : SurjOn f s (Icc (f a) (f b)) :=\n  hs.is_preconnected.intermediate_value ha hb hf\n#align continuous_on.surj_on_Icc ContinuousOn.surjOn_Icc\n-/\n\n",
 "setOf_isPreconnected_subset_of_ordered":
 "#print setOf_isPreconnected_subset_of_ordered /-\n/-- A preconnected set is either one of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`,\n`Iic`, `Iio`, or `univ`, or `∅`. The converse statement requires `α` to be densely ordered. Though\none can represent `∅` as `(Inf s, Inf s)`, we include it into the list of possible cases to improve\nreadability. -/\ntheorem setOf_isPreconnected_subset_of_ordered :\n    { s : Set α | IsPreconnected s } ⊆-- bounded intervals\n                range\n                (uncurry Icc) ∪\n              range (uncurry Ico) ∪\n            range (uncurry Ioc) ∪\n          range (uncurry Ioo) ∪\n        (-- unbounded intervals and `univ`\n                  range\n                  Ici ∪\n                range Ioi ∪\n              range Iic ∪\n            range Iio ∪\n          {univ, ∅}) :=\n  by\n  intro s hs\n  rcases hs.mem_intervals with (hs | hs | hs | hs | hs | hs | hs | hs | hs | hs)\n  · exact or.inl <| or.inl <| or.inl <| or.inl ⟨(Inf s, Sup s), hs.symm⟩\n  · exact or.inl <| or.inl <| or.inl <| or.inr ⟨(Inf s, Sup s), hs.symm⟩\n  · exact or.inl <| or.inl <| or.inr ⟨(Inf s, Sup s), hs.symm⟩\n  · exact or.inl <| or.inr ⟨(Inf s, Sup s), hs.symm⟩\n  · exact or.inr <| or.inl <| or.inl <| or.inl <| or.inl ⟨Inf s, hs.symm⟩\n  · exact or.inr <| or.inl <| or.inl <| or.inl <| or.inr ⟨Inf s, hs.symm⟩\n  · exact or.inr <| or.inl <| or.inl <| or.inr ⟨Sup s, hs.symm⟩\n  · exact or.inr <| or.inl <| or.inr ⟨Sup s, hs.symm⟩\n  · exact or.inr <| or.inr <| or.inl hs\n  · exact or.inr <| or.inr <| or.inr hs\n#align set_of_is_preconnected_subset_of_ordered setOf_isPreconnected_subset_of_ordered\n-/\n\n",
 "setOf_isPreconnected_eq_of_ordered":
 "#print setOf_isPreconnected_eq_of_ordered /-\n/-- In a dense conditionally complete linear order, the set of preconnected sets is exactly\nthe set of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`, `Iic`, `Iio`, `(-∞, +∞)`,\nor `∅`. Though one can represent `∅` as `(Inf s, Inf s)`, we include it into the list of\npossible cases to improve readability. -/\ntheorem setOf_isPreconnected_eq_of_ordered :\n    { s : Set α | IsPreconnected s } =-- bounded intervals\n                range\n                (uncurry Icc) ∪\n              range (uncurry Ico) ∪\n            range (uncurry Ioc) ∪\n          range (uncurry Ioo) ∪\n        (-- unbounded intervals and `univ`\n                  range\n                  Ici ∪\n                range Ioi ∪\n              range Iic ∪\n            range Iio ∪\n          {univ, ∅}) :=\n  by\n  refine' subset.antisymm setOf_isPreconnected_subset_of_ordered _\n  simp only [subset_def, -mem_range, forall_range_iff, uncurry, or_imp, forall_and, mem_union, mem_set_of_eq, insert_eq,\n    mem_singleton_iff, forall_eq, forall_true_iff, and_true_iff, isPreconnected_Icc, isPreconnected_Ico,\n    isPreconnected_Ioc, isPreconnected_Ioo, isPreconnected_Ioi, isPreconnected_Iio, isPreconnected_Ici,\n    isPreconnected_Iic, is_preconnected_univ, isPreconnected_empty]\n#align set_of_is_preconnected_eq_of_ordered setOf_isPreconnected_eq_of_ordered\n-/\n\n",
 "ordConnected":
 "#print IsPreconnected.ordConnected /-\ntheorem IsPreconnected.ordConnected {s : Set α} (h : IsPreconnected s) : OrdConnected s :=\n  ⟨fun x hx y hy => h.Icc_subset hx hy⟩\n#align is_preconnected.ord_connected IsPreconnected.ordConnected\n-/\n\n",
 "mem_range_of_exists_le_of_exists_ge":
 "#print mem_range_of_exists_le_of_exists_ge /-\n/-- **Intermediate Value Theorem** for continuous functions on connected spaces. -/\ntheorem mem_range_of_exists_le_of_exists_ge [PreconnectedSpace X] {c : α} {f : X → α} (hf : Continuous f)\n    (h₁ : ∃ a, f a ≤ c) (h₂ : ∃ b, c ≤ f b) : c ∈ range f :=\n  let ⟨a, ha⟩ := h₁\n  let ⟨b, hb⟩ := h₂\n  intermediate_value_univ a b hf ⟨ha, hb⟩\n#align mem_range_of_exists_le_of_exists_ge mem_range_of_exists_le_of_exists_ge\n-/\n\n",
 "mem_of_ge_of_forall_exists_gt":
 "#print IsClosed.mem_of_ge_of_forall_exists_gt /-\n/-- A \"continuous induction principle\" for a closed interval: if a set `s` meets `[a, b]`\non a closed subset, contains `a`, and the set `s ∩ [a, b)` has no maximal point, then `b ∈ s`. -/\ntheorem IsClosed.mem_of_ge_of_forall_exists_gt {a b : α} {s : Set α} (hs : IsClosed (s ∩ Icc a b)) (ha : a ∈ s)\n    (hab : a ≤ b) (hgt : ∀ x ∈ s ∩ Ico a b, (s ∩ Ioc x b).nonempty) : b ∈ s :=\n  by\n  let S := s ∩ Icc a b\n  replace ha : a ∈ S\n  exact ⟨ha, left_mem_Icc.2 hab⟩\n  have Sbd : BddAbove S := ⟨b, fun z hz => hz.2.2⟩\n  let c := Sup (s ∩ Icc a b)\n  have c_mem : c ∈ S := hs.cSup_mem ⟨_, ha⟩ Sbd\n  have c_le : c ≤ b := csupₛ_le ⟨_, ha⟩ fun x hx => hx.2.2\n  cases' eq_or_lt_of_le c_le with hc hc\n  exact hc ▸ c_mem.1\n  exfalso\n  rcases hgt c ⟨c_mem.1, c_mem.2.1, hc⟩ with ⟨x, xs, cx, xb⟩\n  exact not_lt_of_le (le_csupₛ Sbd ⟨xs, le_trans (le_csupₛ Sbd ha) (le_of_lt cx), xb⟩) cx\n#align is_closed.mem_of_ge_of_forall_exists_gt IsClosed.mem_of_ge_of_forall_exists_gt\n-/\n\n",
 "mem_intervals":
 "#print IsPreconnected.mem_intervals /-\n/-- A preconnected set in a conditionally complete linear order is either one of the intervals\n`[Inf s, Sup s]`, `[Inf s, Sup s)`, `(Inf s, Sup s]`, `(Inf s, Sup s)`, `[Inf s, +∞)`,\n`(Inf s, +∞)`, `(-∞, Sup s]`, `(-∞, Sup s)`, `(-∞, +∞)`, or `∅`. The converse statement requires\n`α` to be densely ordererd. -/\ntheorem IsPreconnected.mem_intervals {s : Set α} (hs : IsPreconnected s) :\n    s ∈\n      ({Icc (infₛ s) (supₛ s), Ico (infₛ s) (supₛ s), Ioc (infₛ s) (supₛ s), Ioo (infₛ s) (supₛ s), Ici (infₛ s),\n          Ioi (infₛ s), Iic (supₛ s), Iio (supₛ s), univ, ∅} :\n        Set (Set α)) :=\n  by\n  rcases s.eq_empty_or_nonempty with (rfl | hne)\n  · apply_rules [or.inr, mem_singleton]\n  have hs' : IsConnected s := ⟨hne, hs⟩\n  by_cases hb : BddBelow s <;> by_cases ha : BddAbove s\n  · rcases mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset (hs'.Ioo_cInf_cSup_subset hb ha) (subset_Icc_cinfₛ_csupₛ hb ha) with\n      (hs | hs | hs | hs)\n    · exact or.inl hs\n    · exact or.inr <| or.inl hs\n    · exact or.inr <| or.inr <| or.inl hs\n    · exact or.inr <| or.inr <| or.inr <| or.inl hs\n  · refine' or.inr <| or.inr <| or.inr <| or.inr _\n    cases' mem_Ici_Ioi_of_subset_of_subset (hs.Ioi_cInf_subset hb ha) fun x hx => cinfₛ_le hb hx with hs hs\n    · exact or.inl hs\n    · exact or.inr (or.inl hs)\n  · iterate 6 apply or.inr\n    cases' mem_Iic_Iio_of_subset_of_subset (hs.Iio_cSup_subset hb ha) fun x hx => le_csupₛ ha hx with hs hs\n    · exact or.inl hs\n    · exact or.inr (or.inl hs)\n  · iterate 8 apply or.inr\n    exact or.inl (hs.eq_univ_of_unbounded hb ha)\n#align is_preconnected.mem_intervals IsPreconnected.mem_intervals\n-/\n\n",
 "isPreconnected_uIcc":
 "#print isPreconnected_uIcc /-\ntheorem isPreconnected_uIcc : IsPreconnected (uIcc a b) :=\n  isPreconnected_Icc\n#align is_preconnected_uIcc isPreconnected_uIcc\n-/\n\n",
 "isPreconnected_iff_ordConnected":
 "#print isPreconnected_iff_ordConnected /-\ntheorem isPreconnected_iff_ordConnected {s : Set α} : IsPreconnected s ↔ OrdConnected s :=\n  ⟨IsPreconnected.ordConnected, Set.OrdConnected.isPreconnected⟩\n#align is_preconnected_iff_ord_connected isPreconnected_iff_ordConnected\n-/\n\n",
 "isPreconnected_Ioo":
 "#print isPreconnected_Ioo /-\ntheorem isPreconnected_Ioo : IsPreconnected (Ioo a b) :=\n  ordConnected_Ioo.is_preconnected\n#align is_preconnected_Ioo isPreconnected_Ioo\n-/\n\n",
 "isPreconnected_Ioi":
 "#print isPreconnected_Ioi /-\ntheorem isPreconnected_Ioi : IsPreconnected (Ioi a) :=\n  ordConnected_Ioi.is_preconnected\n#align is_preconnected_Ioi isPreconnected_Ioi\n-/\n\n",
 "isPreconnected_Ioc":
 "#print isPreconnected_Ioc /-\ntheorem isPreconnected_Ioc : IsPreconnected (Ioc a b) :=\n  ordConnected_Ioc.is_preconnected\n#align is_preconnected_Ioc isPreconnected_Ioc\n-/\n\n",
 "isPreconnected_Iio":
 "#print isPreconnected_Iio /-\ntheorem isPreconnected_Iio : IsPreconnected (Iio a) :=\n  ordConnected_Iio.is_preconnected\n#align is_preconnected_Iio isPreconnected_Iio\n-/\n\n",
 "isPreconnected_Iic":
 "#print isPreconnected_Iic /-\ntheorem isPreconnected_Iic : IsPreconnected (Iic a) :=\n  ordConnected_Iic.is_preconnected\n#align is_preconnected_Iic isPreconnected_Iic\n-/\n\n",
 "isPreconnected_Ico":
 "#print isPreconnected_Ico /-\ntheorem isPreconnected_Ico : IsPreconnected (Ico a b) :=\n  ordConnected_Ico.is_preconnected\n#align is_preconnected_Ico isPreconnected_Ico\n-/\n\n",
 "isPreconnected_Ici":
 "#print isPreconnected_Ici /-\ntheorem isPreconnected_Ici : IsPreconnected (Ici a) :=\n  ordConnected_Ici.is_preconnected\n#align is_preconnected_Ici isPreconnected_Ici\n-/\n\n",
 "isPreconnected_Icc_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print isPreconnected_Icc_aux /-\ntheorem isPreconnected_Icc_aux (x y : α) (s t : Set α) (hxy : x ≤ y) (hs : IsClosed s) (ht : IsClosed t)\n    (hab : Icc a b ⊆ s ∪ t) (hx : x ∈ Icc a b ∩ s) (hy : y ∈ Icc a b ∩ t) : (Icc a b ∩ (s ∩ t)).nonempty :=\n  by\n  have xyab : Icc x y ⊆ Icc a b := Icc_subset_Icc hx.1.1 hy.1.2\n  by_contra hst\n  suffices : Icc x y ⊆ s\n  exact hst ⟨y, xyab <| right_mem_Icc.2 hxy, this <| right_mem_Icc.2 hxy, hy.2⟩\n  apply (IsClosed.inter hs isClosed_Icc).Icc_subset_of_forall_mem_nhds_within hx.2\n  rintro z ⟨zs, hz⟩\n  have zt : z ∈ «expr ᶜ» t := fun zt => hst ⟨z, xyab <| Ico_subset_Icc_self hz, zs, zt⟩\n  have : «expr ᶜ» t ∩ Ioc z y ∈ nhds_within.gt z :=\n    by\n    rw [← nhdsWithin_Ioc_eq_nhdsWithin_Ioi hz.2]\n    exact mem_nhdsWithin.2 ⟨«expr ᶜ» t, ht.is_open_compl, zt, subset.refl _⟩\n  apply mem_of_superset this\n  have : Ioc z y ⊆ s ∪ t := fun w hw => hab (xyab ⟨le_trans hz.1 (le_of_lt hw.1), hw.2⟩)\n  exact fun w ⟨wt, wzy⟩ => (this wzy).elim id fun h => (wt h).elim\n#align is_preconnected_Icc_aux isPreconnected_Icc_aux\n-/\n\n",
 "isPreconnected_Icc":
 "#print isPreconnected_Icc /-\n/-- A closed interval in a densely ordered conditionally complete linear order is preconnected. -/\ntheorem isPreconnected_Icc : IsPreconnected (Icc a b) :=\n  isPreconnected_closed_iff.2\n    (by\n      rintro s t hs ht hab ⟨x, hx⟩ ⟨y, hy⟩\n      -- This used to use `wlog`, but it was causing timeouts.\n      cases le_total x y\n      · exact isPreconnected_Icc_aux x y s t h hs ht hab hx hy\n      · rw [inter_comm s t]\n        rw [union_comm s t] at hab\n        exact isPreconnected_Icc_aux y x t s h ht hs hab hy hx)\n#align is_preconnected_Icc isPreconnected_Icc\n-/\n\n",
 "isPreconnected":
 "#print Set.OrdConnected.isPreconnected /-\ntheorem Set.OrdConnected.isPreconnected {s : Set α} (h : s.ord_connected) : IsPreconnected s :=\n  isPreconnected_of_forall_pair fun x hx y hy =>\n    ⟨uIcc x y, h.uIcc_subset hx hy, left_mem_uIcc, right_mem_uIcc, isPreconnected_uIcc⟩\n#align set.ord_connected.is_preconnected Set.OrdConnected.isPreconnected\n-/\n\n",
 "isConnected_Ioo":
 "#print isConnected_Ioo /-\ntheorem isConnected_Ioo (h : a < b) : IsConnected (Ioo a b) :=\n  ⟨nonempty_Ioo.2 h, isPreconnected_Ioo⟩\n#align is_connected_Ioo isConnected_Ioo\n-/\n\n",
 "isConnected_Ioi":
 "#print isConnected_Ioi /-\ntheorem isConnected_Ioi [NoMaxOrder α] : IsConnected (Ioi a) :=\n  ⟨nonempty_Ioi, isPreconnected_Ioi⟩\n#align is_connected_Ioi isConnected_Ioi\n-/\n\n",
 "isConnected_Ioc":
 "#print isConnected_Ioc /-\ntheorem isConnected_Ioc (h : a < b) : IsConnected (Ioc a b) :=\n  ⟨nonempty_Ioc.2 h, isPreconnected_Ioc⟩\n#align is_connected_Ioc isConnected_Ioc\n-/\n\n",
 "isConnected_Iio":
 "#print isConnected_Iio /-\ntheorem isConnected_Iio [NoMinOrder α] : IsConnected (Iio a) :=\n  ⟨nonempty_Iio, isPreconnected_Iio⟩\n#align is_connected_Iio isConnected_Iio\n-/\n\n",
 "isConnected_Iic":
 "#print isConnected_Iic /-\ntheorem isConnected_Iic : IsConnected (Iic a) :=\n  ⟨nonempty_Iic, isPreconnected_Iic⟩\n#align is_connected_Iic isConnected_Iic\n-/\n\n",
 "isConnected_Ico":
 "#print isConnected_Ico /-\ntheorem isConnected_Ico (h : a < b) : IsConnected (Ico a b) :=\n  ⟨nonempty_Ico.2 h, isPreconnected_Ico⟩\n#align is_connected_Ico isConnected_Ico\n-/\n\n",
 "isConnected_Ici":
 "#print isConnected_Ici /-\ntheorem isConnected_Ici : IsConnected (Ici a) :=\n  ⟨nonempty_Ici, isPreconnected_Ici⟩\n#align is_connected_Ici isConnected_Ici\n-/\n\n",
 "isConnected_Icc":
 "#print isConnected_Icc /-\ntheorem isConnected_Icc (h : a ≤ b) : IsConnected (Icc a b) :=\n  ⟨nonempty_Icc.2 h, isPreconnected_Icc⟩\n#align is_connected_Icc isConnected_Icc\n-/\n\n",
 "intermediate_value₂_eventually₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n#print IsPreconnected.intermediate_value₂_eventually₂ /-\ntheorem IsPreconnected.intermediate_value₂_eventually₂ {s : Set X} (hs : IsPreconnected s) {l₁ l₂ : Filter X} [NeBot l₁]\n    [NeBot l₂] (hl₁ : l₁ ≤ (filter.principal) s) (hl₂ : l₂ ≤ (filter.principal) s) {f g : X → α} (hf : ContinuousOn f s)\n    (hg : ContinuousOn g s) (he₁ : «expr ≤ᶠ[ ] » f l₁ g) (he₂ : «expr ≤ᶠ[ ] » g l₂ f) : ∃ x ∈ s, f x = g x :=\n  by\n  rw [continuousOn_iff_continuous_restrict] at hf hg\n  obtain ⟨b, h⟩ :=\n    @intermediate_value_univ₂_eventually₂ _ _ _ _ _ _ (Subtype.preconnectedSpace hs) _ _\n      (comap_coe_ne_bot_of_le_principal hl₁) (comap_coe_ne_bot_of_le_principal hl₂) _ _ hf hg (he₁.comap _)\n      (he₂.comap _)\n  exact ⟨b, b.prop, h⟩\n#align is_preconnected.intermediate_value₂_eventually₂ IsPreconnected.intermediate_value₂_eventually₂\n-/\n\n",
 "intermediate_value₂_eventually₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n#print IsPreconnected.intermediate_value₂_eventually₁ /-\ntheorem IsPreconnected.intermediate_value₂_eventually₁ {s : Set X} (hs : IsPreconnected s) {a : X} {l : Filter X}\n    (ha : a ∈ s) [NeBot l] (hl : l ≤ (filter.principal) s) {f g : X → α} (hf : ContinuousOn f s) (hg : ContinuousOn g s)\n    (ha' : f a ≤ g a) (he : «expr ≤ᶠ[ ] » g l f) : ∃ x ∈ s, f x = g x :=\n  by\n  rw [continuousOn_iff_continuous_restrict] at hf hg\n  obtain ⟨b, h⟩ :=\n    @intermediate_value_univ₂_eventually₁ _ _ _ _ _ _ (Subtype.preconnectedSpace hs) ⟨a, ha⟩ _\n      (comap_coe_ne_bot_of_le_principal hl) _ _ hf hg ha' (he.comap _)\n  exact ⟨b, b.prop, h⟩\n#align is_preconnected.intermediate_value₂_eventually₁ IsPreconnected.intermediate_value₂_eventually₁\n-/\n\n",
 "intermediate_value₂":
 "#print IsPreconnected.intermediate_value₂ /-\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b ∈ s` we have `f a ≤ g a` and `g b ≤ f b`,\nthen for some `x ∈ s` we have `f x = g x`. -/\ntheorem IsPreconnected.intermediate_value₂ {s : Set X} (hs : IsPreconnected s) {a b : X} (ha : a ∈ s) (hb : b ∈ s)\n    {f g : X → α} (hf : ContinuousOn f s) (hg : ContinuousOn g s) (ha' : f a ≤ g a) (hb' : g b ≤ f b) :\n    ∃ x ∈ s, f x = g x :=\n  let ⟨x, hx⟩ :=\n    @intermediate_value_univ₂ s α _ _ _ _ (Subtype.preconnectedSpace hs) ⟨a, ha⟩ ⟨b, hb⟩ _ _\n      (continuousOn_iff_continuous_restrict.1 hf) (continuousOn_iff_continuous_restrict.1 hg) ha' hb'\n  ⟨x, x.2, hx⟩\n#align is_preconnected.intermediate_value₂ IsPreconnected.intermediate_value₂\n-/\n\n",
 "intermediate_value_univ₂_eventually₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n#print intermediate_value_univ₂_eventually₂ /-\ntheorem intermediate_value_univ₂_eventually₂ [PreconnectedSpace X] {l₁ l₂ : Filter X} [NeBot l₁] [NeBot l₂]\n    {f g : X → α} (hf : Continuous f) (hg : Continuous g) (he₁ : «expr ≤ᶠ[ ] » f l₁ g) (he₂ : «expr ≤ᶠ[ ] » g l₂ f) :\n    ∃ x, f x = g x :=\n  let ⟨c₁, hc₁⟩ := he₁.frequently.exists\n  let ⟨c₂, hc₂⟩ := he₂.frequently.exists\n  intermediate_value_univ₂ hf hg hc₁ hc₂\n#align intermediate_value_univ₂_eventually₂ intermediate_value_univ₂_eventually₂\n-/\n\n",
 "intermediate_value_univ₂_eventually₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n#print intermediate_value_univ₂_eventually₁ /-\ntheorem intermediate_value_univ₂_eventually₁ [PreconnectedSpace X] {a : X} {l : Filter X} [NeBot l] {f g : X → α}\n    (hf : Continuous f) (hg : Continuous g) (ha : f a ≤ g a) (he : «expr ≤ᶠ[ ] » g l f) : ∃ x, f x = g x :=\n  let ⟨c, hc⟩ := he.frequently.exists\n  intermediate_value_univ₂ hf hg ha hc\n#align intermediate_value_univ₂_eventually₁ intermediate_value_univ₂_eventually₁\n-/\n\n",
 "intermediate_value_univ₂":
 "#print intermediate_value_univ₂ /-\n/-\nCopyright (c) 2021 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov, Alistair Tucker\n-/\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem intermediate_value_univ₂ [PreconnectedSpace X] {a b : X} {f g : X → α} (hf : Continuous f) (hg : Continuous g)\n    (ha : f a ≤ g a) (hb : g b ≤ f b) : ∃ x, f x = g x :=\n  by\n  obtain ⟨x, h, hfg, hgf⟩ : (univ ∩ { x | f x ≤ g x ∧ g x ≤ f x }).nonempty\n  exact\n    isPreconnected_closed_iff.1 preconnected_space.is_preconnected_univ _ _ (isClosed_le hf hg) (isClosed_le hg hf)\n      (fun x hx => le_total _ _) ⟨a, trivial, ha⟩ ⟨b, trivial, hb⟩\n  exact ⟨x, le_antisymm hfg hgf⟩\n#align intermediate_value_univ₂ intermediate_value_univ₂\n-/\n\n",
 "intermediate_value_univ":
 "#print intermediate_value_univ /-\n/-- **Intermediate Value Theorem** for continuous functions on connected spaces. -/\ntheorem intermediate_value_univ [PreconnectedSpace X] (a b : X) {f : X → α} (hf : Continuous f) :\n    Icc (f a) (f b) ⊆ range f := fun x hx => intermediate_value_univ₂ hf continuous_const hx.1 hx.2\n#align intermediate_value_univ intermediate_value_univ\n-/\n\n",
 "intermediate_value_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print intermediate_value_uIcc /-\n/-- **Intermediate Value Theorem** for continuous functions on closed intervals, unordered case. -/\ntheorem intermediate_value_uIcc {a b : α} {f : α → δ} (hf : ContinuousOn f (uIcc a b)) :\n    uIcc (f a) (f b) ⊆ «expr '' » f (uIcc a b) := by\n  cases le_total (f a) (f b) <;> simp [*, is_preconnected_uIcc.intermediate_value]\n#align intermediate_value_uIcc intermediate_value_uIcc\n-/\n\n",
 "intermediate_value_Ioo'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print intermediate_value_Ioo' /-\ntheorem intermediate_value_Ioo' {a b : α} (hab : a ≤ b) {f : α → δ} (hf : ContinuousOn f (Icc a b)) :\n    Ioo (f b) (f a) ⊆ «expr '' » f (Ioo a b) :=\n  or.elim (eq_or_lt_of_le hab) (fun he y h => absurd h.1 (not_lt_of_lt (he ▸ h.2))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ioo _ _ _ _ _ _ _ isPreconnected_Ioo _ _ (right_nhdsWithin_Ioo_neBot hlt)\n      (left_nhdsWithin_Ioo_neBot hlt) inf_le_right inf_le_right _ (hf.mono Ioo_subset_Icc_self) _ _\n      ((hf.continuous_within_at ⟨hab, refl b⟩).mono Ioo_subset_Icc_self)\n      ((hf.continuous_within_at ⟨refl a, hab⟩).mono Ioo_subset_Icc_self)\n#align intermediate_value_Ioo' intermediate_value_Ioo'\n-/\n\n",
 "intermediate_value_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print intermediate_value_Ioo /-\ntheorem intermediate_value_Ioo {a b : α} (hab : a ≤ b) {f : α → δ} (hf : ContinuousOn f (Icc a b)) :\n    Ioo (f a) (f b) ⊆ «expr '' » f (Ioo a b) :=\n  or.elim (eq_or_lt_of_le hab) (fun he y h => absurd h.2 (not_lt_of_lt (he ▸ h.1))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ioo _ _ _ _ _ _ _ isPreconnected_Ioo _ _ (left_nhdsWithin_Ioo_neBot hlt)\n      (right_nhdsWithin_Ioo_neBot hlt) inf_le_right inf_le_right _ (hf.mono Ioo_subset_Icc_self) _ _\n      ((hf.continuous_within_at ⟨refl a, hab⟩).mono Ioo_subset_Icc_self)\n      ((hf.continuous_within_at ⟨hab, refl b⟩).mono Ioo_subset_Icc_self)\n#align intermediate_value_Ioo intermediate_value_Ioo\n-/\n\n",
 "intermediate_value_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsPreconnected.intermediate_value_Ioi /-\ntheorem IsPreconnected.intermediate_value_Ioi {s : Set X} (hs : IsPreconnected s) {l₁ l₂ : Filter X} [NeBot l₁]\n    [NeBot l₂] (hl₁ : l₁ ≤ (filter.principal) s) (hl₂ : l₂ ≤ (filter.principal) s) {f : X → α} (hf : ContinuousOn f s)\n    {v : α} (ht₁ : Tendsto f l₁ ((nhds) v)) (ht₂ : Tendsto f l₂ atTop) : Ioi v ⊆ «expr '' » f s := fun y h =>\n  bex_def.1 <|\n    hs.intermediate_value₂_eventually₂ hl₁ hl₂ hf continuousOn_const (eventually_le_of_tendsto_lt h ht₁)\n      (tendsto_atTop.1 ht₂ y)\n#align is_preconnected.intermediate_value_Ioi IsPreconnected.intermediate_value_Ioi\n-/\n\n",
 "intermediate_value_Ioc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print intermediate_value_Ioc' /-\ntheorem intermediate_value_Ioc' {a b : α} (hab : a ≤ b) {f : α → δ} (hf : ContinuousOn f (Icc a b)) :\n    Ico (f b) (f a) ⊆ «expr '' » f (Ioc a b) :=\n  or.elim (eq_or_lt_of_le hab) (fun he y h => absurd h.1 (not_le_of_lt (he ▸ h.2))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ico _ _ _ _ _ _ _ isPreconnected_Ioc _ _ ⟨hlt, refl b⟩\n      (left_nhdsWithin_Ioc_neBot hlt) inf_le_right _ (hf.mono Ioc_subset_Icc_self) _\n      ((hf.continuous_within_at ⟨refl a, hab⟩).mono Ioc_subset_Icc_self)\n#align intermediate_value_Ioc' intermediate_value_Ioc'\n-/\n\n",
 "intermediate_value_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print intermediate_value_Ioc /-\ntheorem intermediate_value_Ioc {a b : α} (hab : a ≤ b) {f : α → δ} (hf : ContinuousOn f (Icc a b)) :\n    Ioc (f a) (f b) ⊆ «expr '' » f (Ioc a b) :=\n  or.elim (eq_or_lt_of_le hab) (fun he y h => absurd h.2 (not_le_of_lt (he ▸ h.1))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ioc _ _ _ _ _ _ _ isPreconnected_Ioc _ _ ⟨hlt, refl b⟩\n      (left_nhdsWithin_Ioc_neBot hlt) inf_le_right _ (hf.mono Ioc_subset_Icc_self) _\n      ((hf.continuous_within_at ⟨refl a, hab⟩).mono Ioc_subset_Icc_self)\n#align intermediate_value_Ioc intermediate_value_Ioc\n-/\n\n",
 "intermediate_value_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsPreconnected.intermediate_value_Iio /-\ntheorem IsPreconnected.intermediate_value_Iio {s : Set X} (hs : IsPreconnected s) {l₁ l₂ : Filter X} [NeBot l₁]\n    [NeBot l₂] (hl₁ : l₁ ≤ (filter.principal) s) (hl₂ : l₂ ≤ (filter.principal) s) {f : X → α} (hf : ContinuousOn f s)\n    {v : α} (ht₁ : Tendsto f l₁ atBot) (ht₂ : Tendsto f l₂ ((nhds) v)) : Iio v ⊆ «expr '' » f s := fun y h =>\n  bex_def.1 <|\n    hs.intermediate_value₂_eventually₂ hl₁ hl₂ hf continuousOn_const (tendsto_atBot.1 ht₁ y)\n      (eventually_ge_of_tendsto_gt h ht₂)\n#align is_preconnected.intermediate_value_Iio IsPreconnected.intermediate_value_Iio\n-/\n\n",
 "intermediate_value_Iii":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsPreconnected.intermediate_value_Iii /-\ntheorem IsPreconnected.intermediate_value_Iii {s : Set X} (hs : IsPreconnected s) {l₁ l₂ : Filter X} [NeBot l₁]\n    [NeBot l₂] (hl₁ : l₁ ≤ (filter.principal) s) (hl₂ : l₂ ≤ (filter.principal) s) {f : X → α} (hf : ContinuousOn f s)\n    (ht₁ : Tendsto f l₁ atBot) (ht₂ : Tendsto f l₂ atTop) : univ ⊆ «expr '' » f s := fun y h =>\n  bex_def.1 <|\n    hs.intermediate_value₂_eventually₂ hl₁ hl₂ hf continuousOn_const (tendsto_atBot.1 ht₁ y) (tendsto_atTop.1 ht₂ y)\n#align is_preconnected.intermediate_value_Iii IsPreconnected.intermediate_value_Iii\n-/\n\n",
 "intermediate_value_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsPreconnected.intermediate_value_Iic /-\ntheorem IsPreconnected.intermediate_value_Iic {s : Set X} (hs : IsPreconnected s) {a : X} {l : Filter X} (ha : a ∈ s)\n    [NeBot l] (hl : l ≤ (filter.principal) s) {f : X → α} (hf : ContinuousOn f s) (ht : Tendsto f l atBot) :\n    Iic (f a) ⊆ «expr '' » f s := fun y h =>\n  bex_def.1 <|\n    (BEx.imp_right fun x _ => Eq.symm) <|\n      hs.intermediate_value₂_eventually₁ ha hl continuousOn_const hf h (tendsto_atBot.1 ht y)\n#align is_preconnected.intermediate_value_Iic IsPreconnected.intermediate_value_Iic\n-/\n\n",
 "intermediate_value_Ico'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print intermediate_value_Ico' /-\ntheorem intermediate_value_Ico' {a b : α} (hab : a ≤ b) {f : α → δ} (hf : ContinuousOn f (Icc a b)) :\n    Ioc (f b) (f a) ⊆ «expr '' » f (Ico a b) :=\n  or.elim (eq_or_lt_of_le hab) (fun he y h => absurd h.1 (not_lt_of_le (he ▸ h.2))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ioc _ _ _ _ _ _ _ isPreconnected_Ico _ _ ⟨refl a, hlt⟩\n      (right_nhdsWithin_Ico_neBot hlt) inf_le_right _ (hf.mono Ico_subset_Icc_self) _\n      ((hf.continuous_within_at ⟨hab, refl b⟩).mono Ico_subset_Icc_self)\n#align intermediate_value_Ico' intermediate_value_Ico'\n-/\n\n",
 "intermediate_value_Ico":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print intermediate_value_Ico /-\ntheorem intermediate_value_Ico {a b : α} (hab : a ≤ b) {f : α → δ} (hf : ContinuousOn f (Icc a b)) :\n    Ico (f a) (f b) ⊆ «expr '' » f (Ico a b) :=\n  or.elim (eq_or_lt_of_le hab) (fun he y h => absurd h.2 (not_lt_of_le (he ▸ h.1))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ico _ _ _ _ _ _ _ isPreconnected_Ico _ _ ⟨refl a, hlt⟩\n      (right_nhdsWithin_Ico_neBot hlt) inf_le_right _ (hf.mono Ico_subset_Icc_self) _\n      ((hf.continuous_within_at ⟨hab, refl b⟩).mono Ico_subset_Icc_self)\n#align intermediate_value_Ico intermediate_value_Ico\n-/\n\n",
 "intermediate_value_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsPreconnected.intermediate_value_Ici /-\ntheorem IsPreconnected.intermediate_value_Ici {s : Set X} (hs : IsPreconnected s) {a : X} {l : Filter X} (ha : a ∈ s)\n    [NeBot l] (hl : l ≤ (filter.principal) s) {f : X → α} (hf : ContinuousOn f s) (ht : Tendsto f l atTop) :\n    Ici (f a) ⊆ «expr '' » f s := fun y h =>\n  bex_def.1 <| hs.intermediate_value₂_eventually₁ ha hl hf continuousOn_const h (tendsto_atTop.1 ht y)\n#align is_preconnected.intermediate_value_Ici IsPreconnected.intermediate_value_Ici\n-/\n\n",
 "intermediate_value_Icc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print intermediate_value_Icc' /-\n/-- **Intermediate Value Theorem** for continuous functions on closed intervals, case\n`f a ≥ t ≥ f b`.-/\ntheorem intermediate_value_Icc' {a b : α} (hab : a ≤ b) {f : α → δ} (hf : ContinuousOn f (Icc a b)) :\n    Icc (f b) (f a) ⊆ «expr '' » f (Icc a b) :=\n  isPreconnected_Icc.intermediate_value (right_mem_Icc.2 hab) (left_mem_Icc.2 hab) hf\n#align intermediate_value_Icc' intermediate_value_Icc'\n-/\n\n",
 "intermediate_value_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print intermediate_value_Icc /-\n/-- **Intermediate Value Theorem** for continuous functions on closed intervals, case\n`f a ≤ t ≤ f b`.-/\ntheorem intermediate_value_Icc {a b : α} (hab : a ≤ b) {f : α → δ} (hf : ContinuousOn f (Icc a b)) :\n    Icc (f a) (f b) ⊆ «expr '' » f (Icc a b) :=\n  isPreconnected_Icc.intermediate_value (left_mem_Icc.2 hab) (right_mem_Icc.2 hab) hf\n#align intermediate_value_Icc intermediate_value_Icc\n-/\n\n",
 "intermediate_value":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsPreconnected.intermediate_value /-\n/-- **Intermediate Value Theorem** for continuous functions on connected sets. -/\ntheorem IsPreconnected.intermediate_value {s : Set X} (hs : IsPreconnected s) {a b : X} (ha : a ∈ s) (hb : b ∈ s)\n    {f : X → α} (hf : ContinuousOn f s) : Icc (f a) (f b) ⊆ «expr '' » f s := fun x hx =>\n  mem_image_iff_bex.2 <| hs.intermediate_value₂ ha hb hf continuousOn_const hx.1 hx.2\n#align is_preconnected.intermediate_value IsPreconnected.intermediate_value\n-/\n\n",
 "eq_univ_of_unbounded":
 "#print IsPreconnected.eq_univ_of_unbounded /-\n/-- If preconnected set in a linear order space is unbounded below and above, then it is the whole\nspace. -/\ntheorem IsPreconnected.eq_univ_of_unbounded {s : Set α} (hs : IsPreconnected s) (hb : ¬BddBelow s) (ha : ¬BddAbove s) :\n    s = univ := by\n  refine' eq_univ_of_forall fun x => _\n  obtain ⟨y, ys, hy⟩ : ∃ y ∈ s, y < x := not_bddBelow_iff.1 hb x\n  obtain ⟨z, zs, hz⟩ : ∃ z ∈ s, x < z := not_bddAbove_iff.1 ha x\n  exact hs.Icc_subset ys zs ⟨le_of_lt hy, le_of_lt hz⟩\n#align is_preconnected.eq_univ_of_unbounded IsPreconnected.eq_univ_of_unbounded\n-/\n\n",
 "eq_Icc_cinfₛ_csupₛ_of_connected_bdd_closed":
 "#print eq_Icc_cinfₛ_csupₛ_of_connected_bdd_closed /-\ntheorem eq_Icc_cinfₛ_csupₛ_of_connected_bdd_closed {s : Set α} (hc : IsConnected s) (hb : BddBelow s) (ha : BddAbove s)\n    (hcl : IsClosed s) : s = Icc (infₛ s) (supₛ s) :=\n  Subset.antisymm (subset_Icc_cinfₛ_csupₛ hb ha) <|\n    hc.Icc_subset (hcl.cInf_mem hc.nonempty hb) (hcl.cSup_mem hc.nonempty ha)\n#align eq_Icc_cInf_cSup_of_connected_bdd_closed eq_Icc_cinfₛ_csupₛ_of_connected_bdd_closed\n-/\n\n",
 "Ioo_cinfₛ_csupₛ_subset":
 "#print IsConnected.Ioo_cinfₛ_csupₛ_subset /-\n/-- A bounded connected subset of a conditionally complete linear order includes the open interval\n`(Inf s, Sup s)`. -/\ntheorem IsConnected.Ioo_cinfₛ_csupₛ_subset {s : Set α} (hs : IsConnected s) (hb : BddBelow s) (ha : BddAbove s) :\n    Ioo (infₛ s) (supₛ s) ⊆ s := fun x hx =>\n  let ⟨y, ys, hy⟩ := (isGLB_lt_iff (isGLB_cinfₛ hs.nonempty hb)).1 hx.1\n  let ⟨z, zs, hz⟩ := (lt_isLUB_iff (isLUB_csupₛ hs.nonempty ha)).1 hx.2\n  hs.Icc_subset ys zs ⟨le_of_lt hy, le_of_lt hz⟩\n#align is_connected.Ioo_cInf_cSup_subset IsConnected.Ioo_cinfₛ_csupₛ_subset\n-/\n\n",
 "Ioi_cinfₛ_subset":
 "#print IsPreconnected.Ioi_cinfₛ_subset /-\ntheorem IsPreconnected.Ioi_cinfₛ_subset {s : Set α} (hs : IsPreconnected s) (hb : BddBelow s) (ha : ¬BddAbove s) :\n    Ioi (infₛ s) ⊆ s := by\n  have sne : s.nonempty := @nonempty_of_not_bddAbove α _ s ⟨Inf ∅⟩ ha\n  intro x hx\n  obtain ⟨y, ys, hy⟩ : ∃ y ∈ s, y < x := (isGLB_lt_iff (isGLB_cinfₛ sne hb)).1 hx\n  obtain ⟨z, zs, hz⟩ : ∃ z ∈ s, x < z := not_bddAbove_iff.1 ha x\n  exact hs.Icc_subset ys zs ⟨le_of_lt hy, le_of_lt hz⟩\n#align is_preconnected.Ioi_cInf_subset IsPreconnected.Ioi_cinfₛ_subset\n-/\n\n",
 "Iio_csupₛ_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print IsPreconnected.Iio_csupₛ_subset /-\ntheorem IsPreconnected.Iio_csupₛ_subset {s : Set α} (hs : IsPreconnected s) (hb : ¬BddBelow s) (ha : BddAbove s) :\n    Iio (supₛ s) ⊆ s :=\n  @IsPreconnected.Ioi_cinfₛ_subset («expr ᵒᵈ» α) _ _ _ s hs ha hb\n#align is_preconnected.Iio_cSup_subset IsPreconnected.Iio_csupₛ_subset\n-/\n\n",
 "Icc_subset_of_forall_mem_nhdsWithin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n#print IsClosed.Icc_subset_of_forall_mem_nhdsWithin /-\n/-- A \"continuous induction principle\" for a closed interval: if a set `s` meets `[a, b]`\non a closed subset, contains `a`, and for any `x ∈ s ∩ [a, b)` the set `s` includes some open\nneighborhood of `x` within `(x, +∞)`, then `[a, b] ⊆ s`. -/\ntheorem IsClosed.Icc_subset_of_forall_mem_nhdsWithin {a b : α} {s : Set α} (hs : IsClosed (s ∩ Icc a b)) (ha : a ∈ s)\n    (hgt : ∀ x ∈ s ∩ Ico a b, s ∈ nhds_within.gt x) : Icc a b ⊆ s :=\n  by\n  apply hs.Icc_subset_of_forall_exists_gt ha\n  rintro x ⟨hxs, hxab⟩ y hyxb\n  have : s ∩ Ioc x y ∈ nhds_within.gt x := inter_mem (hgt x ⟨hxs, hxab⟩) (Ioc_mem_nhdsWithin_Ioi ⟨le_rfl, hyxb⟩)\n  exact (nhdsWithin_Ioi_self_neBot' ⟨b, hxab.2⟩).nonempty_of_mem this\n#align is_closed.Icc_subset_of_forall_mem_nhds_within IsClosed.Icc_subset_of_forall_mem_nhdsWithin\n-/\n\n",
 "Icc_subset_of_forall_exists_gt":
 "#print IsClosed.Icc_subset_of_forall_exists_gt /-\n/-- A \"continuous induction principle\" for a closed interval: if a set `s` meets `[a, b]`\non a closed subset, contains `a`, and for any `a ≤ x < y ≤ b`, `x ∈ s`, the set `s ∩ (x, y]`\nis not empty, then `[a, b] ⊆ s`. -/\ntheorem IsClosed.Icc_subset_of_forall_exists_gt {a b : α} {s : Set α} (hs : IsClosed (s ∩ Icc a b)) (ha : a ∈ s)\n    (hgt : ∀ x ∈ s ∩ Ico a b, ∀ y ∈ Ioi x, (s ∩ Ioc x y).nonempty) : Icc a b ⊆ s :=\n  by\n  intro y hy\n  have : IsClosed (s ∩ Icc a y) :=\n    by\n    suffices s ∩ Icc a y = s ∩ Icc a b ∩ Icc a y by\n      rw [this]\n      exact IsClosed.inter hs isClosed_Icc\n    rw [inter_assoc]\n    congr\n    exact (inter_eq_self_of_subset_right <| Icc_subset_Icc_right hy.2).symm\n  exact\n    IsClosed.mem_of_ge_of_forall_exists_gt this ha hy.1 fun x hx =>\n      hgt x ⟨hx.1, Ico_subset_Ico_right hy.2 hx.2⟩ y hx.2.2\n#align is_closed.Icc_subset_of_forall_exists_gt IsClosed.Icc_subset_of_forall_exists_gt\n-/\n\n",
 "Icc_subset":
 "#print IsConnected.Icc_subset /-\n/-- If a preconnected set contains endpoints of an interval, then it includes the whole interval. -/\ntheorem IsConnected.Icc_subset {s : Set α} (hs : IsConnected s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) : Icc a b ⊆ s :=\n  hs.2.Icc_subset ha hb\n#align is_connected.Icc_subset IsConnected.Icc_subset\n-/\n\n"}