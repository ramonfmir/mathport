{"lt_Inf_iff_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact.lt_Inf_iff_of_continuous {α β : Type _} [ConditionallyCompleteLinearOrder α] [topological_space α]\n    [order_topology α] [topological_space β] {f : β → α} {K : set β} (hK : is_compact K) (h0K : K.nonempty)\n    (hf : continuous_on f K) (y : α) : y < infₛ («expr '' » f K) ↔ ∀ x ∈ K, y < f x :=\n  @is_compact.Sup_lt_iff_of_continuous («expr ᵒᵈ» α) β _ _ _ _ _ _ hK h0K hf y\n#align is_compact.lt_Inf_iff_of_continuous is_compact.lt_Inf_iff_of_continuous\n\n",
 "le_Sup_image_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem le_Sup_image_Icc (h : continuous_on f <| Icc a b) (hc : c ∈ Icc a b) : f c ≤ supₛ («expr '' » f (Icc a b)) :=\n  by\n  rw [h.image_Icc (nonempty_Icc.mp (Set.nonempty_of_mem hc))]\n  exact\n    le_csupₛ bddAbove_Icc\n      (mem_Icc.mpr\n        ⟨cinfₛ_le (is_compact_Icc.bdd_below_image h) ⟨c, hc, rfl⟩,\n          le_csupₛ (is_compact_Icc.bdd_above_image h) ⟨c, hc, rfl⟩⟩)\n#align le_Sup_image_Icc le_Sup_image_Icc\n\n",
 "is_lub_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem is_compact.is_lub_Sup {s : set α} (hs : is_compact s) (ne_s : s.nonempty) : IsLUB s (supₛ s) :=\n  @is_compact.is_glb_Inf («expr ᵒᵈ» α) _ _ _ _ hs ne_s\n#align is_compact.is_lub_Sup is_compact.is_lub_Sup\n\n",
 "is_least_Inf":
 "theorem is_compact.is_least_Inf {s : set α} (hs : is_compact s) (ne_s : s.nonempty) : IsLeast s (infₛ s) :=\n  ⟨hs.Inf_mem ne_s, (hs.is_glb_Inf ne_s).1⟩\n#align is_compact.is_least_Inf is_compact.is_least_Inf\n\n",
 "is_greatest_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem is_compact.is_greatest_Sup {s : set α} (hs : is_compact s) (ne_s : s.nonempty) : IsGreatest s (supₛ s) :=\n  @is_compact.is_least_Inf («expr ᵒᵈ» α) _ _ _ _ hs ne_s\n#align is_compact.is_greatest_Sup is_compact.is_greatest_Sup\n\n",
 "is_glb_Inf":
 "theorem is_compact.is_glb_Inf {s : set α} (hs : is_compact s) (ne_s : s.nonempty) : IsGLB s (infₛ s) :=\n  isGLB_cinfₛ ne_s hs.bdd_below\n#align is_compact.is_glb_Inf is_compact.is_glb_Inf\n\n",
 "is_compact_uIcc":
 "/-\nCopyright (c) 2021 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Yury Kudryashov\n-/\n/-- An unordered closed interval is compact. -/\ntheorem is_compact_uIcc {α : Type _} [linear_order α] [topological_space α] [compact_Icc_space α] {a b : α} :\n    is_compact (uIcc a b) :=\n  is_compact_Icc\n#align is_compact_uIcc is_compact_uIcc\n\n",
 "image_uIcc_eq_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\ntheorem image_uIcc_eq_Icc (h : continuous_on f <| set.uIcc a b) :\n    «expr '' » f (set.uIcc a b) = Icc (infₛ («expr '' » f (set.uIcc a b))) (supₛ («expr '' » f (set.uIcc a b))) :=\n  by\n  cases' le_total a b with h2 h2\n  · simp_rw [uIcc_of_le h2] at h⊢\n    exact h.image_Icc h2\n  · simp_rw [uIcc_of_ge h2] at h⊢\n    exact h.image_Icc h2\n#align image_uIcc_eq_Icc image_uIcc_eq_Icc\n\n",
 "image_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\ntheorem image_uIcc (h : continuous_on f <| set.uIcc a b) :\n    «expr '' » f (set.uIcc a b) = set.uIcc (infₛ («expr '' » f (set.uIcc a b))) (supₛ («expr '' » f (set.uIcc a b))) :=\n  by\n  refine' h.image_uIcc_eq_Icc.trans (uIcc_of_le _).symm\n  refine' cinfₛ_le_csupₛ _ _ (nonempty_uIcc.image _) <;> rw [h.image_uIcc_eq_Icc]\n  exacts[bddBelow_Icc, bddAbove_Icc]\n#align image_uIcc image_uIcc\n\n",
 "image_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_Icc (hab : a ≤ b) (h : continuous_on f <| Icc a b) :\n    «expr '' » f (Icc a b) = Icc (Inf <| «expr '' » f (Icc a b)) (Sup <| «expr '' » f (Icc a b)) :=\n  eq_Icc_of_connected_compact ⟨(nonempty_Icc.2 hab).image f, is_preconnected_Icc.image f h⟩\n    (is_compact_Icc.image_of_continuous_on h)\n#align image_Icc image_Icc\n\n",
 "exists_local_min_on_mem_subset":
 "theorem is_compact.exists_local_min_on_mem_subset {f : β → α} {s t : set β} {z : β} (ht : is_compact t)\n    (hf : continuous_on f t) (hz : z ∈ t) (hfz : ∀ z' ∈ t \\ s, f z < f z') : ∃ x ∈ s, is_local_min_on f t x :=\n  by\n  obtain ⟨x, hx, hfx⟩ : ∃ x ∈ t, ∀ y ∈ t, f x ≤ f y := ht.exists_forall_le ⟨z, hz⟩ hf\n  have key : ∀ ⦃y⦄, y ∈ t → (∀ z' ∈ t \\ s, f y < f z') → y ∈ s := fun y hy hfy => by\n    by_contra <;> simpa using hfy y ((mem_diff y).mpr ⟨hy, h⟩)\n  have h1 : ∀ z' ∈ t \\ s, f x < f z' := fun z' hz' => (hfx z hz).trans_lt (hfz z' hz')\n  have h2 : x ∈ s := key hx h1\n  refine' ⟨x, h2, eventually_nhds_within_of_forall hfx⟩\n#align is_compact.exists_local_min_on_mem_subset is_compact.exists_local_min_on_mem_subset\n\n",
 "exists_local_min_mem_open":
 "theorem is_compact.exists_local_min_mem_open {f : β → α} {s t : set β} {z : β} (ht : is_compact t) (hst : s ⊆ t)\n    (hf : continuous_on f t) (hz : z ∈ t) (hfz : ∀ z' ∈ t \\ s, f z < f z') (hs : is_open s) :\n    ∃ x ∈ s, is_local_min f x :=\n  by\n  obtain ⟨x, hx, hfx⟩ := ht.exists_local_min_on_mem_subset hf hz hfz\n  exact ⟨x, hx, hfx.is_local_min (filter.mem_of_superset (hs.mem_nhds hx) hst)⟩\n#align is_compact.exists_local_min_mem_open is_compact.exists_local_min_mem_open\n\n",
 "exists_is_lub":
 "theorem is_compact.exists_is_lub {s : set α} (hs : is_compact s) (ne_s : s.nonempty) : ∃ x ∈ s, IsLUB s x :=\n  ⟨_, hs.Sup_mem ne_s, hs.is_lub_Sup ne_s⟩\n#align is_compact.exists_is_lub is_compact.exists_is_lub\n\n",
 "exists_is_least":
 "theorem is_compact.exists_is_least {s : set α} (hs : is_compact s) (ne_s : s.nonempty) : ∃ x, IsLeast s x :=\n  ⟨_, hs.is_least_Inf ne_s⟩\n#align is_compact.exists_is_least is_compact.exists_is_least\n\n",
 "exists_is_greatest":
 "theorem is_compact.exists_is_greatest {s : set α} (hs : is_compact s) (ne_s : s.nonempty) : ∃ x, IsGreatest s x :=\n  ⟨_, hs.is_greatest_Sup ne_s⟩\n#align is_compact.exists_is_greatest is_compact.exists_is_greatest\n\n",
 "exists_is_glb":
 "theorem is_compact.exists_is_glb {s : set α} (hs : is_compact s) (ne_s : s.nonempty) : ∃ x ∈ s, IsGLB s x :=\n  ⟨_, hs.Inf_mem ne_s, hs.is_glb_Inf ne_s⟩\n#align is_compact.exists_is_glb is_compact.exists_is_glb\n\n",
 "exists_forall_le_of_has_compact_mul_support":
 "/-- A continuous function with compact support has a global minimum. -/\n@[to_additive \"A continuous function with compact support has a global minimum.\"]\ntheorem continuous.exists_forall_le_of_has_compact_mul_support [nonempty β] [One α] {f : β → α} (hf : continuous f)\n    (h : has_compact_mul_support f) : ∃ x : β, ∀ y : β, f x ≤ f y :=\n  by\n  obtain ⟨_, ⟨x, rfl⟩, hx⟩ := (h.is_compact_range hf).exists_is_least (range_nonempty _)\n  rw [mem_lowerBounds, forall_range_iff] at hx\n  exact ⟨x, hx⟩\n#align continuous.exists_forall_le_of_has_compact_mul_support continuous.exists_forall_le_of_has_compact_mul_support\n\n",
 "exists_forall_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- The **extreme value theorem**: if a continuous function `f` is larger than a value in its range\naway from compact sets, then it has a global minimum. -/\ntheorem _root_.continuous.exists_forall_le' {f : β → α} (hf : continuous f) (x₀ : β)\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (cocompact β) (f x₀ ≤ f x)) :\n    ∃ x : β, ∀ y : β, f x ≤ f y :=\n  let ⟨x, _, hx⟩ :=\n    hf.continuous_on.exists_forall_le' is_closed_univ (mem_univ x₀) (by rwa [principal_univ, inf_top_eq])\n  ⟨x, fun y => hx y (mem_univ y)⟩\n#align continuous.exists_forall_le' continuous.exists_forall_le'\n\n",
 "exists_forall_le":
 "/-- The **extreme value theorem**: if a continuous function `f` tends to infinity away from compact\nsets, then it has a global minimum. -/\ntheorem _root_.continuous.exists_forall_le [nonempty β] {f : β → α} (hf : continuous f)\n    (hlim : tendsto f (cocompact β) at_top) : ∃ x, ∀ y, f x ≤ f y :=\n  by\n  inhabit β\n  exact hf.exists_forall_le' default (hlim.eventually <| eventually_ge_at_top _)\n#align continuous.exists_forall_le continuous.exists_forall_le\n\n",
 "exists_forall_ge_of_has_compact_mul_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- A continuous function with compact support has a global maximum. -/\n@[to_additive \"A continuous function with compact support has a global maximum.\"]\ntheorem continuous.exists_forall_ge_of_has_compact_mul_support [nonempty β] [One α] {f : β → α} (hf : continuous f)\n    (h : has_compact_mul_support f) : ∃ x : β, ∀ y : β, f y ≤ f x :=\n  @continuous.exists_forall_le_of_has_compact_mul_support («expr ᵒᵈ» α) _ _ _ _ _ _ _ _ hf h\n#align continuous.exists_forall_ge_of_has_compact_mul_support continuous.exists_forall_ge_of_has_compact_mul_support\n\n",
 "exists_forall_ge'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- The **extreme value theorem**: if a continuous function `f` is smaller than a value in its range\naway from compact sets, then it has a global maximum. -/\ntheorem _root_.continuous.exists_forall_ge' {f : β → α} (hf : continuous f) (x₀ : β)\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (cocompact β) (f x ≤ f x₀)) :\n    ∃ x : β, ∀ y : β, f y ≤ f x :=\n  @continuous.exists_forall_le' («expr ᵒᵈ» α) _ _ _ _ _ _ hf x₀ h\n#align continuous.exists_forall_ge' continuous.exists_forall_ge'\n\n",
 "exists_forall_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- The **extreme value theorem**: if a continuous function `f` tends to negative infinity away from\ncompact sets, then it has a global maximum. -/\ntheorem continuous.exists_forall_ge [nonempty β] {f : β → α} (hf : continuous f)\n    (hlim : tendsto f (cocompact β) at_bot) : ∃ x, ∀ y, f y ≤ f x :=\n  @continuous.exists_forall_le («expr ᵒᵈ» α) _ _ _ _ _ _ _ hf hlim\n#align continuous.exists_forall_ge continuous.exists_forall_ge\n\n",
 "exists_Sup_image_eq_and_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact.exists_Sup_image_eq_and_ge {s : set β} (hs : is_compact s) (ne_s : s.nonempty) {f : β → α}\n    (hf : continuous_on f s) : ∃ x ∈ s, supₛ («expr '' » f s) = f x ∧ ∀ y ∈ s, f y ≤ f x :=\n  @is_compact.exists_Inf_image_eq_and_le («expr ᵒᵈ» α) _ _ _ _ _ _ hs ne_s _ hf\n#align is_compact.exists_Sup_image_eq_and_ge is_compact.exists_Sup_image_eq_and_ge\n\n",
 "exists_Sup_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact.exists_Sup_image_eq :\n    ∀ {s : set β},\n      is_compact s → s.nonempty → ∀ {f : β → α}, continuous_on f s → ∃ x ∈ s, supₛ («expr '' » f s) = f x :=\n  @is_compact.exists_Inf_image_eq («expr ᵒᵈ» α) _ _ _ _ _\n#align is_compact.exists_Sup_image_eq is_compact.exists_Sup_image_eq\n\n",
 "exists_Inf_image_eq_and_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact.exists_Inf_image_eq_and_le {s : set β} (hs : is_compact s) (ne_s : s.nonempty) {f : β → α}\n    (hf : continuous_on f s) : ∃ x ∈ s, infₛ («expr '' » f s) = f x ∧ ∀ y ∈ s, f x ≤ f y :=\n  let ⟨x, hxs, hx⟩ := (hs.image_of_continuous_on hf).Inf_mem (ne_s.image f)\n  ⟨x, hxs, hx.symm, fun y hy =>\n    hx.trans_le <| cinfₛ_le (hs.image_of_continuous_on hf).bdd_below <| mem_image_of_mem f hy⟩\n#align is_compact.exists_Inf_image_eq_and_le is_compact.exists_Inf_image_eq_and_le\n\n",
 "exists_Inf_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact.exists_Inf_image_eq {s : set β} (hs : is_compact s) (ne_s : s.nonempty) {f : β → α}\n    (hf : continuous_on f s) : ∃ x ∈ s, infₛ («expr '' » f s) = f x :=\n  let ⟨x, hxs, hx, _⟩ := hs.exists_Inf_image_eq_and_le ne_s hf\n  ⟨x, hxs, hx⟩\n#align is_compact.exists_Inf_image_eq is_compact.exists_Inf_image_eq\n\n",
 "eq_Icc_of_connected_compact":
 "theorem eq_Icc_of_connected_compact {s : set α} (h₁ : is_connected s) (h₂ : is_compact s) : s = Icc (infₛ s) (supₛ s) :=\n  eq_Icc_cInf_cSup_of_connected_bdd_closed h₁ h₂.bdd_below h₂.bdd_above h₂.is_closed\n#align eq_Icc_of_connected_compact eq_Icc_of_connected_compact\n\n",
 "continuous_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact.continuous_Sup {f : γ → β → α} {K : set β} (hK : is_compact K) (hf : continuous (uncurry f)) :\n    continuous fun x => supₛ («expr '' » (f x) K) :=\n  by\n  rcases eq_empty_or_nonempty K with (rfl | h0K)\n  · simp_rw [image_empty]\n    exact continuous_const\n  rw [continuous_iff_continuous_at]\n  intro x\n  obtain ⟨y, hyK, h2y, hy⟩ :=\n    hK.exists_Sup_image_eq_and_ge h0K\n      (show continuous fun y => f x y from hf.comp <| continuous.prod.mk x).continuous_on\n  rw [continuous_at, h2y, tendsto_order]\n  have :=\n    tendsto_order.mp ((show continuous fun x => f x y from hf.comp <| continuous_id.prod_mk continuous_const).tendsto x)\n  refine' ⟨fun z hz => _, fun z hz => _⟩\n  · refine' (this.1 z hz).mono fun x' hx' => hx'.trans_le <| le_csupₛ _ <| mem_image_of_mem (f x') hyK\n    exact hK.bdd_above_image (hf.comp <| continuous.prod.mk x').continuous_on\n  · have h : lower_set.prod ({x} : set γ) K ⊆ «expr ⁻¹' » (uncurry f) (Iio z) :=\n      by\n      rintro ⟨x', y'⟩ ⟨hx', hy'⟩\n      cases hx'\n      exact (hy y' hy').trans_lt hz\n    obtain ⟨u, v, hu, hv, hxu, hKv, huv⟩ := generalized_tube_lemma is_compact_singleton hK (is_open_Iio.preimage hf) h\n    refine' eventually_of_mem (hu.mem_nhds (singleton_subset_iff.mp hxu)) fun x' hx' => _\n    rw [hK.Sup_lt_iff_of_continuous h0K (show continuous (f x') from hf.comp <| continuous.prod.mk x').continuous_on]\n    exact fun y' hy' => huv (mk_mem_prod hx' (hKv hy'))\n#align is_compact.continuous_Sup is_compact.continuous_Sup\n\n",
 "continuous_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact.continuous_Inf {f : γ → β → α} {K : set β} (hK : is_compact K) (hf : continuous (uncurry f)) :\n    continuous fun x => infₛ («expr '' » (f x) K) :=\n  @is_compact.continuous_Sup («expr ᵒᵈ» α) β γ _ _ _ _ _ _ _ hK hf\n#align is_compact.continuous_Inf is_compact.continuous_Inf\n\n",
 "Sup_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem is_compact.Sup_mem {s : set α} (hs : is_compact s) (ne_s : s.nonempty) : supₛ s ∈ s :=\n  @is_compact.Inf_mem («expr ᵒᵈ» α) _ _ _ _ hs ne_s\n#align is_compact.Sup_mem is_compact.Sup_mem\n\n",
 "Sup_lt_iff_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_compact.Sup_lt_iff_of_continuous {f : β → α} {K : set β} (hK : is_compact K) (h0K : K.nonempty)\n    (hf : continuous_on f K) (y : α) : supₛ («expr '' » f K) < y ↔ ∀ x ∈ K, f x < y :=\n  by\n  refine' ⟨fun h x hx => (le_csupₛ (hK.bdd_above_image hf) <| mem_image_of_mem f hx).trans_lt h, fun h => _⟩\n  obtain ⟨x, hx, h2x⟩ := hK.exists_forall_ge h0K hf\n  refine' (csupₛ_le (h0K.image f) _).trans_lt (h x hx)\n  rintro _ ⟨x', hx', rfl⟩; exact h2x x' hx'\n#align is_compact.Sup_lt_iff_of_continuous is_compact.Sup_lt_iff_of_continuous\n\n",
 "Inf_mem":
 "-- See note [lower instance priority]\ntheorem is_compact.Inf_mem {s : set α} (hs : is_compact s) (ne_s : s.nonempty) : infₛ s ∈ s :=\n  hs.is_closed.cInf_mem ne_s hs.bdd_below\n#align is_compact.Inf_mem is_compact.Inf_mem\n\n",
 "Inf_image_Icc_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem Inf_image_Icc_le (h : continuous_on f <| Icc a b) (hc : c ∈ Icc a b) : infₛ («expr '' » f (Icc a b)) ≤ f c :=\n  by\n  rw [h.image_Icc (nonempty_Icc.mp (Set.nonempty_of_mem hc))]\n  exact\n    cinfₛ_le bddBelow_Icc\n      (mem_Icc.mpr\n        ⟨cinfₛ_le (is_compact_Icc.bdd_below_image h) ⟨c, hc, rfl⟩,\n          le_csupₛ (is_compact_Icc.bdd_above_image h) ⟨c, hc, rfl⟩⟩)\n#align Inf_image_Icc_le Inf_image_Icc_le\n\n"}