{"supₛ_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print IsCompact.supₛ_mem /-\ntheorem IsCompact.supₛ_mem {s : Set α} (hs : IsCompact s) (ne_s : s.nonempty) : supₛ s ∈ s :=\n  @IsCompact.infₛ_mem («expr ᵒᵈ» α) _ _ _ _ hs ne_s\n#align is_compact.Sup_mem IsCompact.supₛ_mem\n-/\n\n",
 "supₛ_lt_iff_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompact.supₛ_lt_iff_of_continuous /-\ntheorem IsCompact.supₛ_lt_iff_of_continuous {f : β → α} {K : Set β} (hK : IsCompact K) (h0K : K.nonempty)\n    (hf : ContinuousOn f K) (y : α) : supₛ («expr '' » f K) < y ↔ ∀ x ∈ K, f x < y :=\n  by\n  refine' ⟨fun h x hx => (le_csupₛ (hK.bdd_above_image hf) <| mem_image_of_mem f hx).trans_lt h, fun h => _⟩\n  obtain ⟨x, hx, h2x⟩ := hK.exists_forall_ge h0K hf\n  refine' (csupₛ_le (h0K.image f) _).trans_lt (h x hx)\n  rintro _ ⟨x', hx', rfl⟩; exact h2x x' hx'\n#align is_compact.Sup_lt_iff_of_continuous IsCompact.supₛ_lt_iff_of_continuous\n-/\n\n",
 "lt_infₛ_iff_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompact.lt_infₛ_iff_of_continuous /-\ntheorem IsCompact.lt_infₛ_iff_of_continuous {α β : Type _} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [TopologicalSpace β] {f : β → α} {K : Set β} (hK : IsCompact K) (h0K : K.nonempty)\n    (hf : ContinuousOn f K) (y : α) : y < infₛ («expr '' » f K) ↔ ∀ x ∈ K, y < f x :=\n  @IsCompact.supₛ_lt_iff_of_continuous («expr ᵒᵈ» α) β _ _ _ _ _ _ hK h0K hf y\n#align is_compact.lt_Inf_iff_of_continuous IsCompact.lt_infₛ_iff_of_continuous\n-/\n\n",
 "le_Sup_image_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem le_Sup_image_Icc (h : ContinuousOn f <| Icc a b) (hc : c ∈ Icc a b) : f c ≤ supₛ («expr '' » f (Icc a b)) :=\n  by\n  rw [h.image_Icc (nonempty_Icc.mp (Set.nonempty_of_mem hc))]\n  exact\n    le_csupₛ bddAbove_Icc\n      (mem_Icc.mpr\n        ⟨cinfₛ_le (is_compact_Icc.bdd_below_image h) ⟨c, hc, rfl⟩,\n          le_csupₛ (is_compact_Icc.bdd_above_image h) ⟨c, hc, rfl⟩⟩)\n#align le_Sup_image_Icc le_Sup_image_Icc\n\n",
 "isLeast_infₛ":
 "#print IsCompact.isLeast_infₛ /-\ntheorem IsCompact.isLeast_infₛ {s : Set α} (hs : IsCompact s) (ne_s : s.nonempty) : IsLeast s (infₛ s) :=\n  ⟨hs.Inf_mem ne_s, (hs.is_glb_Inf ne_s).1⟩\n#align is_compact.is_least_Inf IsCompact.isLeast_infₛ\n-/\n\n",
 "isLUB_supₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print IsCompact.isLUB_supₛ /-\ntheorem IsCompact.isLUB_supₛ {s : Set α} (hs : IsCompact s) (ne_s : s.nonempty) : IsLUB s (supₛ s) :=\n  @IsCompact.isGLB_infₛ («expr ᵒᵈ» α) _ _ _ _ hs ne_s\n#align is_compact.is_lub_Sup IsCompact.isLUB_supₛ\n-/\n\n",
 "isGreatest_supₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print IsCompact.isGreatest_supₛ /-\ntheorem IsCompact.isGreatest_supₛ {s : Set α} (hs : IsCompact s) (ne_s : s.nonempty) : IsGreatest s (supₛ s) :=\n  @IsCompact.isLeast_infₛ («expr ᵒᵈ» α) _ _ _ _ hs ne_s\n#align is_compact.is_greatest_Sup IsCompact.isGreatest_supₛ\n-/\n\n",
 "isGLB_infₛ":
 "#print IsCompact.isGLB_infₛ /-\ntheorem IsCompact.isGLB_infₛ {s : Set α} (hs : IsCompact s) (ne_s : s.nonempty) : IsGLB s (infₛ s) :=\n  isGLB_cinfₛ ne_s hs.bdd_below\n#align is_compact.is_glb_Inf IsCompact.isGLB_infₛ\n-/\n\n",
 "isCompact_uIcc":
 "#print isCompact_uIcc /-\n/-\nCopyright (c) 2021 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Yury Kudryashov\n-/\n/-- An unordered closed interval is compact. -/\ntheorem isCompact_uIcc {α : Type _} [linear_order α] [TopologicalSpace α] [CompactIccSpace α] {a b : α} :\n    IsCompact (uIcc a b) :=\n  is_compact_Icc\n#align is_compact_uIcc isCompact_uIcc\n-/\n\n",
 "infₛ_mem":
 "#print IsCompact.infₛ_mem /-\n-- See note [lower instance priority]\ntheorem IsCompact.infₛ_mem {s : Set α} (hs : IsCompact s) (ne_s : s.nonempty) : infₛ s ∈ s :=\n  hs.is_closed.cInf_mem ne_s hs.bdd_below\n#align is_compact.Inf_mem IsCompact.infₛ_mem\n-/\n\n",
 "image_uIcc_eq_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\ntheorem image_uIcc_eq_Icc (h : ContinuousOn f <| set.uIcc a b) :\n    «expr '' » f (set.uIcc a b) = Icc (infₛ («expr '' » f (set.uIcc a b))) (supₛ («expr '' » f (set.uIcc a b))) :=\n  by\n  cases' le_total a b with h2 h2\n  · simp_rw [uIcc_of_le h2] at h⊢\n    exact h.image_Icc h2\n  · simp_rw [uIcc_of_ge h2] at h⊢\n    exact h.image_Icc h2\n#align image_uIcc_eq_Icc image_uIcc_eq_Icc\n\n",
 "image_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\ntheorem image_uIcc (h : ContinuousOn f <| set.uIcc a b) :\n    «expr '' » f (set.uIcc a b) = set.uIcc (infₛ («expr '' » f (set.uIcc a b))) (supₛ («expr '' » f (set.uIcc a b))) :=\n  by\n  refine' h.image_uIcc_eq_Icc.trans (uIcc_of_le _).symm\n  refine' cinfₛ_le_csupₛ _ _ (nonempty_uIcc.image _) <;> rw [h.image_uIcc_eq_Icc]\n  exacts[bddBelow_Icc, bddAbove_Icc]\n#align image_uIcc image_uIcc\n\n",
 "image_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_Icc (hab : a ≤ b) (h : ContinuousOn f <| Icc a b) :\n    «expr '' » f (Icc a b) = Icc (infₛ <| «expr '' » f (Icc a b)) (supₛ <| «expr '' » f (Icc a b)) :=\n  eq_Icc_of_connected_compact ⟨(nonempty_Icc.2 hab).image f, isPreconnected_Icc.image f h⟩\n    (is_compact_Icc.image_of_continuous_on h)\n#align image_Icc image_Icc\n\n",
 "exists_supₛ_image_eq_and_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompact.exists_supₛ_image_eq_and_ge /-\ntheorem IsCompact.exists_supₛ_image_eq_and_ge {s : Set β} (hs : IsCompact s) (ne_s : s.nonempty) {f : β → α}\n    (hf : ContinuousOn f s) : ∃ x ∈ s, supₛ («expr '' » f s) = f x ∧ ∀ y ∈ s, f y ≤ f x :=\n  @IsCompact.exists_infₛ_image_eq_and_le («expr ᵒᵈ» α) _ _ _ _ _ _ hs ne_s _ hf\n#align is_compact.exists_Sup_image_eq_and_ge IsCompact.exists_supₛ_image_eq_and_ge\n-/\n\n",
 "exists_supₛ_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompact.exists_supₛ_image_eq /-\ntheorem IsCompact.exists_supₛ_image_eq :\n    ∀ {s : Set β}, IsCompact s → s.nonempty → ∀ {f : β → α}, ContinuousOn f s → ∃ x ∈ s, supₛ («expr '' » f s) = f x :=\n  @IsCompact.exists_infₛ_image_eq («expr ᵒᵈ» α) _ _ _ _ _\n#align is_compact.exists_Sup_image_eq IsCompact.exists_supₛ_image_eq\n-/\n\n",
 "exists_local_min_mem_open":
 "#print IsCompact.exists_local_min_mem_open /-\ntheorem IsCompact.exists_local_min_mem_open {f : β → α} {s t : Set β} {z : β} (ht : IsCompact t) (hst : s ⊆ t)\n    (hf : ContinuousOn f t) (hz : z ∈ t) (hfz : ∀ z' ∈ t \\ s, f z < f z') (hs : IsOpen s) : ∃ x ∈ s, IsLocalMin f x :=\n  by\n  obtain ⟨x, hx, hfx⟩ := ht.exists_local_min_on_mem_subset hf hz hfz\n  exact ⟨x, hx, hfx.is_local_min (Filter.mem_of_superset (hs.mem_nhds hx) hst)⟩\n#align is_compact.exists_local_min_mem_open IsCompact.exists_local_min_mem_open\n-/\n\n",
 "exists_isLocalMinOn_mem_subset":
 "#print IsCompact.exists_isLocalMinOn_mem_subset /-\ntheorem IsCompact.exists_isLocalMinOn_mem_subset {f : β → α} {s t : Set β} {z : β} (ht : IsCompact t)\n    (hf : ContinuousOn f t) (hz : z ∈ t) (hfz : ∀ z' ∈ t \\ s, f z < f z') : ∃ x ∈ s, IsLocalMinOn f t x :=\n  by\n  obtain ⟨x, hx, hfx⟩ : ∃ x ∈ t, ∀ y ∈ t, f x ≤ f y := ht.exists_forall_le ⟨z, hz⟩ hf\n  have key : ∀ ⦃y⦄, y ∈ t → (∀ z' ∈ t \\ s, f y < f z') → y ∈ s := fun y hy hfy => by\n    by_contra <;> simpa using hfy y ((mem_diff y).mpr ⟨hy, h⟩)\n  have h1 : ∀ z' ∈ t \\ s, f x < f z' := fun z' hz' => (hfx z hz).trans_lt (hfz z' hz')\n  have h2 : x ∈ s := key hx h1\n  refine' ⟨x, h2, eventually_nhdsWithin_of_forall hfx⟩\n#align is_compact.exists_local_min_on_mem_subset IsCompact.exists_isLocalMinOn_mem_subset\n-/\n\n",
 "exists_isLeast":
 "#print IsCompact.exists_isLeast /-\ntheorem IsCompact.exists_isLeast {s : Set α} (hs : IsCompact s) (ne_s : s.nonempty) : ∃ x, IsLeast s x :=\n  ⟨_, hs.is_least_Inf ne_s⟩\n#align is_compact.exists_is_least IsCompact.exists_isLeast\n-/\n\n",
 "exists_isLUB":
 "#print IsCompact.exists_isLUB /-\ntheorem IsCompact.exists_isLUB {s : Set α} (hs : IsCompact s) (ne_s : s.nonempty) : ∃ x ∈ s, IsLUB s x :=\n  ⟨_, hs.Sup_mem ne_s, hs.is_lub_Sup ne_s⟩\n#align is_compact.exists_is_lub IsCompact.exists_isLUB\n-/\n\n",
 "exists_isGreatest":
 "#print IsCompact.exists_isGreatest /-\ntheorem IsCompact.exists_isGreatest {s : Set α} (hs : IsCompact s) (ne_s : s.nonempty) : ∃ x, IsGreatest s x :=\n  ⟨_, hs.is_greatest_Sup ne_s⟩\n#align is_compact.exists_is_greatest IsCompact.exists_isGreatest\n-/\n\n",
 "exists_isGLB":
 "#print IsCompact.exists_isGLB /-\ntheorem IsCompact.exists_isGLB {s : Set α} (hs : IsCompact s) (ne_s : s.nonempty) : ∃ x ∈ s, IsGLB s x :=\n  ⟨_, hs.Inf_mem ne_s, hs.is_glb_Inf ne_s⟩\n#align is_compact.exists_is_glb IsCompact.exists_isGLB\n-/\n\n",
 "exists_infₛ_image_eq_and_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompact.exists_infₛ_image_eq_and_le /-\ntheorem IsCompact.exists_infₛ_image_eq_and_le {s : Set β} (hs : IsCompact s) (ne_s : s.nonempty) {f : β → α}\n    (hf : ContinuousOn f s) : ∃ x ∈ s, infₛ («expr '' » f s) = f x ∧ ∀ y ∈ s, f x ≤ f y :=\n  let ⟨x, hxs, hx⟩ := (hs.image_of_continuous_on hf).Inf_mem (ne_s.image f)\n  ⟨x, hxs, hx.symm, fun y hy =>\n    hx.trans_le <| cinfₛ_le (hs.image_of_continuous_on hf).bdd_below <| mem_image_of_mem f hy⟩\n#align is_compact.exists_Inf_image_eq_and_le IsCompact.exists_infₛ_image_eq_and_le\n-/\n\n",
 "exists_infₛ_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompact.exists_infₛ_image_eq /-\ntheorem IsCompact.exists_infₛ_image_eq {s : Set β} (hs : IsCompact s) (ne_s : s.nonempty) {f : β → α}\n    (hf : ContinuousOn f s) : ∃ x ∈ s, infₛ («expr '' » f s) = f x :=\n  let ⟨x, hxs, hx, _⟩ := hs.exists_Inf_image_eq_and_le ne_s hf\n  ⟨x, hxs, hx⟩\n#align is_compact.exists_Inf_image_eq IsCompact.exists_infₛ_image_eq\n-/\n\n",
 "exists_forall_le_of_hasCompactMulSupport":
 "#print Continuous.exists_forall_le_of_hasCompactMulSupport /-\n/-- A continuous function with compact support has a global minimum. -/\n@[to_additive \"A continuous function with compact support has a global minimum.\"]\ntheorem Continuous.exists_forall_le_of_hasCompactMulSupport [Nonempty β] [One α] {f : β → α} (hf : Continuous f)\n    (h : HasCompactMulSupport f) : ∃ x : β, ∀ y : β, f x ≤ f y :=\n  by\n  obtain ⟨_, ⟨x, rfl⟩, hx⟩ := (h.is_compact_range hf).exists_is_least (range_nonempty _)\n  rw [mem_lowerBounds, forall_range_iff] at hx\n  exact ⟨x, hx⟩\n#align continuous.exists_forall_le_of_has_compact_mul_support Continuous.exists_forall_le_of_hasCompactMulSupport\n#align continuous.exists_forall_le_of_has_compact_support Continuous.exists_forall_le_of_hasCompactSupport\n-/\n\n",
 "exists_forall_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n#print Continuous.exists_forall_le' /-\n/-- The **extreme value theorem**: if a continuous function `f` is larger than a value in its range\naway from compact sets, then it has a global minimum. -/\ntheorem Continuous.exists_forall_le' {f : β → α} (hf : Continuous f) (x₀ : β)\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (cocompact β) (f x₀ ≤ f x)) :\n    ∃ x : β, ∀ y : β, f x ≤ f y :=\n  let ⟨x, _, hx⟩ := hf.continuous_on.exists_forall_le' isClosed_univ (mem_univ x₀) (by rwa [principal_univ, inf_top_eq])\n  ⟨x, fun y => hx y (mem_univ y)⟩\n#align continuous.exists_forall_le' Continuous.exists_forall_le'\n-/\n\n",
 "exists_forall_le":
 "#print Continuous.exists_forall_le /-\n/-- The **extreme value theorem**: if a continuous function `f` tends to infinity away from compact\nsets, then it has a global minimum. -/\ntheorem Continuous.exists_forall_le [Nonempty β] {f : β → α} (hf : Continuous f)\n    (hlim : Tendsto f (cocompact β) atTop) : ∃ x, ∀ y, f x ≤ f y :=\n  by\n  inhabit β\n  exact hf.exists_forall_le' default (hlim.eventually <| eventually_ge_at_top _)\n#align continuous.exists_forall_le Continuous.exists_forall_le\n-/\n\n",
 "exists_forall_ge_of_hasCompactMulSupport":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print Continuous.exists_forall_ge_of_hasCompactMulSupport /-\n/-- A continuous function with compact support has a global maximum. -/\n@[to_additive \"A continuous function with compact support has a global maximum.\"]\ntheorem Continuous.exists_forall_ge_of_hasCompactMulSupport [Nonempty β] [One α] {f : β → α} (hf : Continuous f)\n    (h : HasCompactMulSupport f) : ∃ x : β, ∀ y : β, f y ≤ f x :=\n  @Continuous.exists_forall_le_of_hasCompactMulSupport («expr ᵒᵈ» α) _ _ _ _ _ _ _ _ hf h\n#align continuous.exists_forall_ge_of_has_compact_mul_support Continuous.exists_forall_ge_of_hasCompactMulSupport\n#align continuous.exists_forall_ge_of_has_compact_support Continuous.exists_forall_ge_of_hasCompactSupport\n-/\n\n",
 "exists_forall_ge'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n#print Continuous.exists_forall_ge' /-\n/-- The **extreme value theorem**: if a continuous function `f` is smaller than a value in its range\naway from compact sets, then it has a global maximum. -/\ntheorem Continuous.exists_forall_ge' {f : β → α} (hf : Continuous f) (x₀ : β)\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (cocompact β) (f x ≤ f x₀)) :\n    ∃ x : β, ∀ y : β, f y ≤ f x :=\n  @Continuous.exists_forall_le' («expr ᵒᵈ» α) _ _ _ _ _ _ hf x₀ h\n#align continuous.exists_forall_ge' Continuous.exists_forall_ge'\n-/\n\n",
 "exists_forall_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print Continuous.exists_forall_ge /-\n/-- The **extreme value theorem**: if a continuous function `f` tends to negative infinity away from\ncompact sets, then it has a global maximum. -/\ntheorem Continuous.exists_forall_ge [Nonempty β] {f : β → α} (hf : Continuous f)\n    (hlim : Tendsto f (cocompact β) atBot) : ∃ x, ∀ y, f y ≤ f x :=\n  @Continuous.exists_forall_le («expr ᵒᵈ» α) _ _ _ _ _ _ _ hf hlim\n#align continuous.exists_forall_ge Continuous.exists_forall_ge\n-/\n\n",
 "eq_Icc_of_connected_compact":
 "#print eq_Icc_of_connected_compact /-\ntheorem eq_Icc_of_connected_compact {s : Set α} (h₁ : IsConnected s) (h₂ : IsCompact s) : s = Icc (infₛ s) (supₛ s) :=\n  eq_Icc_cinfₛ_csupₛ_of_connected_bdd_closed h₁ h₂.bdd_below h₂.bdd_above h₂.is_closed\n#align eq_Icc_of_connected_compact eq_Icc_of_connected_compact\n-/\n\n",
 "continuous_supₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompact.continuous_supₛ /-\ntheorem IsCompact.continuous_supₛ {f : γ → β → α} {K : Set β} (hK : IsCompact K) (hf : Continuous (uncurry f)) :\n    Continuous fun x => supₛ («expr '' » (f x) K) :=\n  by\n  rcases eq_empty_or_nonempty K with (rfl | h0K)\n  · simp_rw [image_empty]\n    exact continuous_const\n  rw [continuous_iff_continuousAt]\n  intro x\n  obtain ⟨y, hyK, h2y, hy⟩ :=\n    hK.exists_Sup_image_eq_and_ge h0K\n      (show Continuous fun y => f x y from hf.comp <| Continuous.Prod.mk x).continuous_on\n  rw [ContinuousAt, h2y, tendsto_order]\n  have :=\n    tendsto_order.mp ((show Continuous fun x => f x y from hf.comp <| continuous_id.prod_mk continuous_const).tendsto x)\n  refine' ⟨fun z hz => _, fun z hz => _⟩\n  · refine' (this.1 z hz).mono fun x' hx' => hx'.trans_le <| le_csupₛ _ <| mem_image_of_mem (f x') hyK\n    exact hK.bdd_above_image (hf.comp <| Continuous.Prod.mk x').continuous_on\n  · have h : lower_set.prod ({x} : Set γ) K ⊆ «expr ⁻¹' » (uncurry f) (Iio z) :=\n      by\n      rintro ⟨x', y'⟩ ⟨hx', hy'⟩\n      cases hx'\n      exact (hy y' hy').trans_lt hz\n    obtain ⟨u, v, hu, hv, hxu, hKv, huv⟩ := generalized_tube_lemma isCompact_singleton hK (is_open_Iio.preimage hf) h\n    refine' eventually_of_mem (hu.mem_nhds (singleton_subset_iff.mp hxu)) fun x' hx' => _\n    rw [hK.Sup_lt_iff_of_continuous h0K (show Continuous (f x') from hf.comp <| Continuous.Prod.mk x').continuous_on]\n    exact fun y' hy' => huv (mk_mem_prod hx' (hKv hy'))\n#align is_compact.continuous_Sup IsCompact.continuous_supₛ\n-/\n\n",
 "continuous_infₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print IsCompact.continuous_infₛ /-\ntheorem IsCompact.continuous_infₛ {f : γ → β → α} {K : Set β} (hK : IsCompact K) (hf : Continuous (uncurry f)) :\n    Continuous fun x => infₛ («expr '' » (f x) K) :=\n  @IsCompact.continuous_supₛ («expr ᵒᵈ» α) β γ _ _ _ _ _ _ _ hK hf\n#align is_compact.continuous_Inf IsCompact.continuous_infₛ\n-/\n\n",
 "Inf_image_Icc_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem Inf_image_Icc_le (h : ContinuousOn f <| Icc a b) (hc : c ∈ Icc a b) : infₛ («expr '' » f (Icc a b)) ≤ f c :=\n  by\n  rw [h.image_Icc (nonempty_Icc.mp (Set.nonempty_of_mem hc))]\n  exact\n    cinfₛ_le bddBelow_Icc\n      (mem_Icc.mpr\n        ⟨cinfₛ_le (is_compact_Icc.bdd_below_image h) ⟨c, hc, rfl⟩,\n          le_csupₛ (is_compact_Icc.bdd_above_image h) ⟨c, hc, rfl⟩⟩)\n#align Inf_image_Icc_le Inf_image_Icc_le\n\n"}