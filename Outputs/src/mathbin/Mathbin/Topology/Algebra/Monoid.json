{"units_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print Continuous.units_map /-\n@[to_additive]\ntheorem Continuous.units_map [Monoid M] [Monoid N] [TopologicalSpace M] [TopologicalSpace N] (f : «expr →* » M N)\n    (hf : Continuous f) : Continuous (Units.map f) :=\n  Units.continuous_iff.2 ⟨hf.comp Units.continuous_val, hf.comp Units.continuous_coe_inv⟩\n#align continuous.units_map Continuous.units_map\n#align continuous.add_units_map Continuous.addUnits_map\n-/\n\n",
 "topologicalClosure_minimal":
 "#print Submonoid.topologicalClosure_minimal /-\n@[to_additive]\ntheorem Submonoid.topologicalClosure_minimal (s : Submonoid M) {t : Submonoid M} (h : s ≤ t)\n    (ht : IsClosed (t : Set M)) : s.topological_closure ≤ t :=\n  closure_minimal h ht\n#align submonoid.topological_closure_minimal Submonoid.topologicalClosure_minimal\n#align add_submonoid.topological_closure_minimal AddSubmonoid.topologicalClosure_minimal\n-/\n\n",
 "top_closure_mul_self_subset":
 "#print Submonoid.top_closure_mul_self_subset /-\n@[to_additive]\ntheorem Submonoid.top_closure_mul_self_subset (s : Submonoid M) : closure (s : Set M) * closure s ⊆ closure s :=\n  image2_subset_iff.2 fun x hx y hy => map_mem_closure₂ continuous_mul hx hy fun a ha b hb => s.mul_mem ha hb\n#align submonoid.top_closure_mul_self_subset Submonoid.top_closure_mul_self_subset\n#align add_submonoid.top_closure_add_self_subset AddSubmonoid.top_closure_add_self_subset\n-/\n\n",
 "top_closure_mul_self_eq":
 "#print Submonoid.top_closure_mul_self_eq /-\n@[to_additive]\ntheorem Submonoid.top_closure_mul_self_eq (s : Submonoid M) : closure (s : Set M) * closure s = closure s :=\n  Subset.antisymm s.top_closure_mul_self_subset fun x hx => ⟨x, 1, hx, subset_closure s.one_mem, mul_one _⟩\n#align submonoid.top_closure_mul_self_eq Submonoid.top_closure_mul_self_eq\n#align add_submonoid.top_closure_add_self_eq AddSubmonoid.top_closure_add_self_eq\n-/\n\n",
 "tendsto_multiset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_multiset_prod /-\n@[to_additive]\ntheorem tendsto_multiset_prod {f : ι → α → M} {x : Filter α} {a : ι → M} (s : Multiset ι) :\n    (∀ i ∈ s, Tendsto (f i) x ((nhds) (a i))) →\n      Tendsto (fun b => (s.map fun c => f c b).prod) x ((nhds) (s.map a).prod) :=\n  by\n  rcases s with ⟨l⟩\n  simpa using tendsto_list_prod l\n#align tendsto_multiset_prod tendsto_multiset_prod\n#align tendsto_multiset_sum tendsto_multiset_sum\n-/\n\n",
 "tendsto_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_mul /-\n@[to_additive]\ntheorem tendsto_mul {a b : M} : Tendsto (fun p : M × M => p.fst * p.snd) ((nhds) (a, b)) ((nhds) (a * b)) :=\n  continuous_iff_continuousAt.mp has_continuous_mul.continuous_mul (a, b)\n#align tendsto_mul tendsto_mul\n#align tendsto_add tendsto_add\n-/\n\n",
 "tendsto_list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_list_prod /-\n@[to_additive]\ntheorem tendsto_list_prod {f : ι → α → M} {x : Filter α} {a : ι → M} :\n    ∀ l : List ι,\n      (∀ i ∈ l, Tendsto (f i) x ((nhds) (a i))) →\n        Tendsto (fun b => (l.map fun c => f c b).prod) x ((nhds) (l.map a).prod)\n  | [], _ => by simp [tendsto_const_nhds]\n  | sym.cons' f l, h => by\n    simp only [list.map_cons, List.prod_cons]\n    exact (h f (list.mem_cons_self _ _)).mul (tendsto_list_prod l fun c hc => h c (list.mem_cons_of_mem _ hc))\n#align tendsto_list_prod tendsto_list_prod\n#align tendsto_list_sum tendsto_list_sum\n-/\n\n",
 "tendsto_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print tendsto_finset_prod /-\n@[to_additive]\ntheorem tendsto_finset_prod {f : ι → α → M} {x : Filter α} {a : ι → M} (s : Finset ι) :\n    (∀ i ∈ s, Tendsto (f i) x ((nhds) (a i))) →\n      Tendsto\n        (fun b =>\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f c b))\n        x\n        ((nhds)\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n            (a c))) :=\n  tendsto_multiset_prod _\n#align tendsto_finset_prod tendsto_finset_prod\n#align tendsto_finset_sum tendsto_finset_sum\n-/\n\n",
 "tendsto_cocompact_mul_right":
 "#print Filter.tendsto_cocompact_mul_right /-\n/-- Right-multiplication by a right-invertible element of a topological monoid is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_right {a b : M} (ha : a * b = 1) :\n    Filter.Tendsto (fun x : M => x * a) (Filter.cocompact M) (Filter.cocompact M) :=\n  by\n  refine' Filter.Tendsto.of_tendsto_comp _ (Filter.comap_cocompact_le (continuous_mul_right b))\n  convert Filter.tendsto_id\n  ext x\n  simp [ha]\n#align filter.tendsto_cocompact_mul_right Filter.tendsto_cocompact_mul_right\n-/\n\n",
 "tendsto_cocompact_mul_left":
 "#print Filter.tendsto_cocompact_mul_left /-\n/-- Left-multiplication by a left-invertible element of a topological monoid is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_left {a b : M} (ha : b * a = 1) :\n    Filter.Tendsto (fun x : M => a * x) (Filter.cocompact M) (Filter.cocompact M) :=\n  by\n  refine' Filter.Tendsto.of_tendsto_comp _ (Filter.comap_cocompact_le (continuous_mul_left b))\n  convert Filter.tendsto_id\n  ext x\n  simp [ha]\n#align filter.tendsto_cocompact_mul_left Filter.tendsto_cocompact_mul_left\n-/\n\n",
 "pow":
 "#print ContinuousOn.pow /-\n@[to_additive ContinuousOn.nsmul]\ntheorem ContinuousOn.pow {f : X → M} {s : Set X} (hf : ContinuousOn f s) (n : ℕ) : ContinuousOn (fun x => f x ^ n) s :=\n  fun x hx => (hf x hx).pow n\n#align continuous_on.pow ContinuousOn.pow\n#align continuous_on.nsmul ContinuousOn.nsmul\n-/\n\n",
 "of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ContinuousMul.of_nhds_one /-\n@[to_additive]\ntheorem ContinuousMul.of_nhds_one {M : Type u} [Monoid M] [TopologicalSpace M]\n    (hmul : Tendsto (uncurry ((· * ·) : M → M → M)) (filter.prod ((nhds) 1) ((nhds) 1)) <| (nhds) 1)\n    (hleft : ∀ x₀ : M, (nhds) x₀ = map (fun x => x₀ * x) ((nhds) 1))\n    (hright : ∀ x₀ : M, (nhds) x₀ = map (fun x => x * x₀) ((nhds) 1)) : ContinuousMul M :=\n  ⟨by\n    rw [continuous_iff_continuousAt]\n    rintro ⟨x₀, y₀⟩\n    have key : (fun p : M × M => x₀ * p.1 * (p.2 * y₀)) = ((fun x => x₀ * x) ∘ fun x => x * y₀) ∘ uncurry (· * ·) :=\n      by\n      ext p\n      simp [uncurry, mul_assoc]\n    have key₂ : ((fun x => x₀ * x) ∘ fun x => y₀ * x) = fun x => x₀ * y₀ * x :=\n      by\n      ext x\n      simp\n    calc\n      map (uncurry (· * ·)) ((nhds) (x₀, y₀)) = map (uncurry (· * ·)) (filter.prod ((nhds) x₀) ((nhds) y₀)) := by\n        rw [nhds_prod_eq]\n      _ = map (fun p : M × M => x₀ * p.1 * (p.2 * y₀)) (filter.prod ((nhds) 1) ((nhds) 1)) := by\n        rw [uncurry, hleft x₀, hright y₀, prod_map_map_eq, Filter.map_map]\n      _ = map ((fun x => x₀ * x) ∘ fun x => x * y₀) (map (uncurry (· * ·)) (filter.prod ((nhds) 1) ((nhds) 1))) := by\n        rw [key, ← Filter.map_map]\n      _ ≤ map ((fun x : M => x₀ * x) ∘ fun x => x * y₀) ((nhds) 1) := (map_mono hmul)\n      _ = (nhds) (x₀ * y₀) := by rw [← Filter.map_map, ← hright, hleft y₀, Filter.map_map, key₂, ← hleft]\n      ⟩\n#align has_continuous_mul.of_nhds_one ContinuousMul.of_nhds_one\n#align has_continuous_add.of_nhds_zero ContinuousAdd.of_nhds_zero\n-/\n\n",
 "nhds_one_mul_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_one_mul_nhds /-\n@[simp, to_additive]\ntheorem nhds_one_mul_nhds {M} [MulOneClass M] [TopologicalSpace M] [ContinuousMul M] (a : M) :\n    (nhds) (1 : M) * (nhds) a = (nhds) a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (one_mul a)).antisymm <| le_mul_of_one_le_left' <| pure_le_nhds 1\n#align nhds_one_mul_nhds nhds_one_mul_nhds\n#align nhds_zero_add_nhds nhds_zero_add_nhds\n-/\n\n",
 "nhds_mul_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_mul_nhds_one /-\n@[simp, to_additive]\ntheorem nhds_mul_nhds_one {M} [MulOneClass M] [TopologicalSpace M] [ContinuousMul M] (a : M) :\n    (nhds) a * (nhds) 1 = (nhds) a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (mul_one a)).antisymm <| le_mul_of_one_le_right' <| pure_le_nhds 1\n#align nhds_mul_nhds_one nhds_mul_nhds_one\n#align nhds_add_nhds_zero nhds_add_nhds_zero\n-/\n\n",
 "mul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n#print Filter.TendstoNhdsWithinIio.mul_const /-\ntheorem Filter.TendstoNhdsWithinIio.mul_const [MulPosStrictMono 𝕜] [MulPosReflectLT 𝕜]\n    (h : Tendsto f l (nhds_within.lt c)) : Tendsto (fun a => f a * b) l (nhds_within.lt (c * b)) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ ((tendsto_nhds_of_tendsto_nhdsWithin h).mul_const b) <|\n    (tendsto_nhdsWithin_iff.mp h).2.mono fun j => (mul_lt_mul_right hb).mpr\n#align filter.tendsto_nhds_within_Iio.mul_const Filter.TendstoNhdsWithinIio.mul_const\n-/\n\n",
 "mul":
 "#print IsCompact.mul /-\n@[to_additive]\ntheorem IsCompact.mul {s t : Set M} (hs : IsCompact s) (ht : IsCompact t) : IsCompact (s * t) :=\n  by\n  rw [← image_mul_prod]\n  exact (hs.prod ht).image continuous_mul\n#align is_compact.mul IsCompact.mul\n#align is_compact.add IsCompact.add\n-/\n\n",
 "mem_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Submonoid.mem_nhds_one /-\n@[to_additive]\ntheorem Submonoid.mem_nhds_one (S : Submonoid M) (oS : IsOpen (S : Set M)) : (S : Set M) ∈ (nhds) (1 : M) :=\n  IsOpen.mem_nhds oS S.one_mem\n#align submonoid.mem_nhds_one Submonoid.mem_nhds_one\n#align add_submonoid.mem_nhds_zero AddSubmonoid.mem_nhds_zero\n-/\n\n",
 "le_topologicalClosure":
 "#print Submonoid.le_topologicalClosure /-\n@[to_additive]\ntheorem Submonoid.le_topologicalClosure (s : Submonoid M) : s ≤ s.topological_closure :=\n  subset_closure\n#align submonoid.le_topological_closure Submonoid.le_topologicalClosure\n#align add_submonoid.le_topological_closure AddSubmonoid.le_topologicalClosure\n-/\n\n",
 "le_nhds_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print le_nhds_mul /-\n@[to_additive]\ntheorem le_nhds_mul (a b : M) : (nhds) a * (nhds) b ≤ (nhds) (a * b) :=\n  by\n  rw [← map₂_mul, ← map_uncurry_prod, ← nhds_prod_eq]\n  exact continuous_mul.tendsto _\n#align le_nhds_mul le_nhds_mul\n#align le_nhds_add le_nhds_add\n-/\n\n",
 "isClosed_topologicalClosure":
 "#print Submonoid.isClosed_topologicalClosure /-\n@[to_additive]\ntheorem Submonoid.isClosed_topologicalClosure (s : Submonoid M) : IsClosed (s.topological_closure : Set M) := by\n  convert isClosed_closure\n#align submonoid.is_closed_topological_closure Submonoid.isClosed_topologicalClosure\n#align add_submonoid.is_closed_topological_closure AddSubmonoid.isClosed_topologicalClosure\n-/\n\n",
 "isClosed_setOf_map_one":
 "#print isClosed_setOf_map_one /-\n@[to_additive]\ntheorem isClosed_setOf_map_one [One M₁] [One M₂] : IsClosed { f : M₁ → M₂ | f 1 = 1 } :=\n  isClosed_eq (continuous_apply 1) continuous_const\n#align is_closed_set_of_map_one isClosed_setOf_map_one\n#align is_closed_set_of_map_zero isClosed_setOf_map_zero\n-/\n\n",
 "isClosed_setOf_map_mul":
 "#print isClosed_setOf_map_mul /-\n@[to_additive]\ntheorem isClosed_setOf_map_mul [Mul M₁] [Mul M₂] [ContinuousMul M₂] :\n    IsClosed { f : M₁ → M₂ | ∀ x y, f (x * y) = f x * f y } :=\n  by\n  simp only [set_of_forall]\n  exact\n    isClosed_interᵢ fun x =>\n      isClosed_interᵢ fun y => isClosed_eq (continuous_apply _) ((continuous_apply _).mul (continuous_apply _))\n#align is_closed_set_of_map_mul isClosed_setOf_map_mul\n#align is_closed_set_of_map_add isClosed_setOf_map_add\n-/\n\n",
 "isClosed_range_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidHom.isClosed_range_coe /-\n@[to_additive]\ntheorem MonoidHom.isClosed_range_coe : IsClosed (range (coe_fn : «expr →* » M₁ M₂ → M₁ → M₂)) :=\n  isClosed_of_closure_subset fun f hf => ⟨monoidHomOfMemClosureRangeCoe f hf, rfl⟩\n#align monoid_hom.is_closed_range_coe MonoidHom.isClosed_range_coe\n#align add_monoid_hom.is_closed_range_coe AddMonoidHom.isClosed_range_coe\n-/\n\n",
 "finprod_eventually_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print finprod_eventually_eq_prod /-\n@[to_additive]\ntheorem finprod_eventually_eq_prod {M : Type _} [CommMonoid M] {f : ι → X → M}\n    (hf : LocallyFinite fun i => mulSupport (f i)) (x : X) :\n    ∃ s : Finset ι,\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n        (finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (f i y) =\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n            (f i y)) :=\n  let ⟨I, hI⟩ := hf.exists_finset_mul_support x\n  ⟨I, hI.mono fun y hy => finprod_eq_prod_of_mulSupport_subset _ fun i hi => hy hi⟩\n#align finprod_eventually_eq_prod finprod_eventually_eq_prod\n#align finsum_eventually_eq_sum finsum_eventually_eq_sum\n-/\n\n",
 "exists_open_nhds_one_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_open_nhds_one_split /-\n@[to_additive exists_open_nhds_zero_half]\ntheorem exists_open_nhds_one_split {s : Set M} (hs : s ∈ (nhds) (1 : M)) :\n    ∃ V : Set M, IsOpen V ∧ (1 : M) ∈ V ∧ ∀ v ∈ V, ∀ w ∈ V, v * w ∈ s :=\n  by\n  have : «expr ⁻¹' » (fun a : M × M => a.1 * a.2) s ∈ (nhds) ((1, 1) : M × M) :=\n    tendsto_mul (by simpa only [one_mul] using hs)\n  simpa only [prod_subset_iff] using exists_nhds_square this\n#align exists_open_nhds_one_split exists_open_nhds_one_split\n#align exists_open_nhds_zero_half exists_open_nhds_zero_half\n-/\n\n",
 "exists_open_nhds_one_mul_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_open_nhds_one_mul_subset /-\n/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `VV ⊆ U`. -/\n@[to_additive \"Given a open neighborhood `U` of `0` there is a open neighborhood `V` of `0`\\n  such that `V + V ⊆ U`.\"]\ntheorem exists_open_nhds_one_mul_subset {U : Set M} (hU : U ∈ (nhds) (1 : M)) :\n    ∃ V : Set M, IsOpen V ∧ (1 : M) ∈ V ∧ V * V ⊆ U :=\n  by\n  rcases exists_open_nhds_one_split hU with ⟨V, Vo, V1, hV⟩\n  use V, Vo, V1\n  rintro _ ⟨x, y, hx, hy, rfl⟩\n  exact hV _ hx _ hy\n#align exists_open_nhds_one_mul_subset exists_open_nhds_one_mul_subset\n#align exists_open_nhds_zero_add_subset exists_open_nhds_zero_add_subset\n-/\n\n",
 "exists_nhds_one_split4":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_nhds_one_split4 /-\n@[to_additive exists_nhds_zero_quarter]\ntheorem exists_nhds_one_split4 {u : Set M} (hu : u ∈ (nhds) (1 : M)) :\n    ∃ V ∈ (nhds) (1 : M), ∀ {v w s t}, v ∈ V → w ∈ V → s ∈ V → t ∈ V → v * w * s * t ∈ u :=\n  by\n  rcases exists_nhds_one_split hu with ⟨W, W1, h⟩\n  rcases exists_nhds_one_split W1 with ⟨V, V1, h'⟩\n  use V, V1\n  intro v w s t v_in w_in s_in t_in\n  simpa only [mul_assoc] using h _ (h' v v_in w w_in) _ (h' s s_in t t_in)\n#align exists_nhds_one_split4 exists_nhds_one_split4\n#align exists_nhds_zero_quarter exists_nhds_zero_quarter\n-/\n\n",
 "exists_nhds_one_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_nhds_one_split /-\n@[to_additive exists_nhds_zero_half]\ntheorem exists_nhds_one_split {s : Set M} (hs : s ∈ (nhds) (1 : M)) :\n    ∃ V ∈ (nhds) (1 : M), ∀ v ∈ V, ∀ w ∈ V, v * w ∈ s :=\n  let ⟨V, Vo, V1, hV⟩ := exists_open_nhds_one_split hs\n  ⟨V, IsOpen.mem_nhds Vo V1, hV⟩\n#align exists_nhds_one_split exists_nhds_one_split\n#align exists_nhds_zero_half exists_nhds_zero_half\n-/\n\n",
 "exists_finset_mulSupport":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print LocallyFinite.exists_finset_mulSupport /-\n@[to_additive]\ntheorem LocallyFinite.exists_finset_mulSupport {M : Type _} [CommMonoid M] {f : ι → X → M}\n    (hf : LocallyFinite fun i => mulSupport <| f i) (x₀ : X) :\n    ∃ I : Finset ι,\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        ((nhds) x₀) ((mulSupport fun i => f i x) ⊆ I) :=\n  by\n  rcases hf x₀ with ⟨U, hxU, hUf⟩\n  refine' ⟨hUf.to_finset, mem_of_superset hxU fun y hy i hi => _⟩\n  rw [hUf.coe_to_finset]\n  exact ⟨y, hi, hy⟩\n#align locally_finite.exists_finset_mul_support LocallyFinite.exists_finset_mulSupport\n#align locally_finite.exists_finset_support LocallyFinite.exists_finset_support\n-/\n\n",
 "eventuallyEq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print eventuallyEq_prod /-\n@[to_additive]\ntheorem eventuallyEq_prod {X M : Type _} [CommMonoid M] {s : Finset ι} {l : Filter X} {f g : ι → X → M}\n    (hs : ∀ i ∈ s, «expr =ᶠ[ ] » (f i) l (g i)) :\n    «expr =ᶠ[ ] »\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) l\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g i)) :=\n  by\n  replace hs :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (∀ i ∈ s, f i x = g i x)\n  · rwa [eventually_all_finset]\n  filter_upwards [hs]with x hx\n  simp only [Finset.prod_apply, Finset.prod_congr rfl hx]\n#align eventually_eq_prod eventuallyEq_prod\n#align eventually_eq_sum eventuallyEq_sum\n-/\n\n",
 "continuous_pow":
 "#print continuous_pow /-\n@[continuity, to_additive]\ntheorem continuous_pow : ∀ n : ℕ, Continuous fun a : M => a ^ n\n  | 0 => by simpa using continuous_const\n  | k + 1 => by\n    simp only [pow_succ]\n    exact continuous_id.mul (continuous_pow _)\n#align continuous_pow continuous_pow\n#align continuous_nsmul continuous_nsmul\n-/\n\n",
 "continuous_one":
 "#print continuous_one /-\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\n@[to_additive]\ntheorem continuous_one [TopologicalSpace M] [One M] : Continuous (1 : X → M) :=\n  @continuous_const _ _ _ _ 1\n#align continuous_one continuous_one\n#align continuous_zero continuous_zero\n-/\n\n",
 "continuous_multiset_prod":
 "#print continuous_multiset_prod /-\n@[continuity, to_additive]\ntheorem continuous_multiset_prod {f : ι → X → M} (s : Multiset ι) :\n    (∀ i ∈ s, Continuous (f i)) → Continuous fun a => (s.map fun i => f i a).prod :=\n  by\n  rcases s with ⟨l⟩\n  simpa using continuous_list_prod l\n#align continuous_multiset_prod continuous_multiset_prod\n#align continuous_multiset_sum continuous_multiset_sum\n-/\n\n",
 "continuous_mul_right":
 "#print continuous_mul_right /-\n@[to_additive]\ntheorem continuous_mul_right (a : M) : Continuous fun b : M => b * a :=\n  continuous_id.mul continuous_const\n#align continuous_mul_right continuous_mul_right\n#align continuous_add_right continuous_add_right\n-/\n\n",
 "continuous_mul_left":
 "#print continuous_mul_left /-\n@[to_additive]\ntheorem continuous_mul_left (a : M) : Continuous fun b : M => a * b :=\n  continuous_const.mul continuous_id\n#align continuous_mul_left continuous_mul_left\n#align continuous_add_left continuous_add_left\n-/\n\n",
 "continuous_mul":
 "#print continuous_mul /-\n@[to_additive]\ntheorem continuous_mul : Continuous fun p : M × M => p.1 * p.2 :=\n  has_continuous_mul.continuous_mul\n#align continuous_mul continuous_mul\n#align continuous_add continuous_add\n-/\n\n",
 "continuous_list_prod":
 "#print continuous_list_prod /-\n@[to_additive]\ntheorem continuous_list_prod {f : ι → X → M} (l : List ι) (h : ∀ i ∈ l, Continuous (f i)) :\n    Continuous fun a => (l.map fun i => f i a).prod :=\n  continuous_iff_continuousAt.2 fun x => tendsto_list_prod l fun c hc => continuous_iff_continuousAt.1 (h c hc) x\n#align continuous_list_prod continuous_list_prod\n#align continuous_list_sum continuous_list_sum\n-/\n\n",
 "continuous_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print continuous_finset_prod /-\n@[continuity, to_additive]\ntheorem continuous_finset_prod {f : ι → X → M} (s : Finset ι) :\n    (∀ i ∈ s, Continuous (f i)) →\n      Continuous fun a =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a) :=\n  continuous_multiset_prod _\n#align continuous_finset_prod continuous_finset_prod\n#align continuous_finset_sum continuous_finset_sum\n-/\n\n",
 "continuous_finprod_cond":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\n#print continuous_finprod_cond /-\n@[to_additive]\ntheorem continuous_finprod_cond {f : ι → X → M} {p : ι → Prop} (hc : ∀ i, p i → Continuous (f i))\n    (hf : LocallyFinite fun i => mulSupport (f i)) :\n    Continuous fun x =>\n      finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (f i x) :=\n  by\n  simp only [← finprod_subtype_eq_finprod_cond]\n  exact continuous_finprod (fun i => hc i i.2) (hf.comp_injective Subtype.coe_injective)\n#align continuous_finprod_cond continuous_finprod_cond\n#align continuous_finsum_cond continuous_finsum_cond\n-/\n\n",
 "continuous_finprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\n#print continuous_finprod /-\n@[to_additive]\ntheorem continuous_finprod {f : ι → X → M} (hc : ∀ i, Continuous (f i)) (hf : LocallyFinite fun i => mulSupport (f i)) :\n    Continuous fun x =>\n      finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (f i x) :=\n  by\n  refine' continuous_iff_continuousAt.2 fun x => _\n  rcases finprod_eventually_eq_prod hf x with ⟨s, hs⟩\n  refine' ContinuousAt.congr _ (eventually_eq.symm hs)\n  exact tendsto_finset_prod _ fun i hi => (hc i).continuous_at\n#align continuous_finprod continuous_finprod\n#align continuous_finsum continuous_finsum\n-/\n\n",
 "continuousOn_pow":
 "#print continuousOn_pow /-\n@[to_additive]\ntheorem continuousOn_pow {s : Set M} (n : ℕ) : ContinuousOn (fun x => x ^ n) s :=\n  (continuous_pow n).continuous_on\n#align continuous_on_pow continuousOn_pow\n#align continuous_on_nsmul continuousOn_nsmul\n-/\n\n",
 "continuousOn_multiset_prod":
 "#print continuousOn_multiset_prod /-\n@[to_additive]\ntheorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :\n    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t :=\n  by\n  rcases s with ⟨l⟩\n  simpa using continuousOn_list_prod l\n#align continuous_on_multiset_prod continuousOn_multiset_prod\n#align continuous_on_multiset_sum continuousOn_multiset_sum\n-/\n\n",
 "continuousOn_list_prod":
 "#print continuousOn_list_prod /-\n@[to_additive]\ntheorem continuousOn_list_prod {f : ι → X → M} (l : List ι) {t : Set X} (h : ∀ i ∈ l, ContinuousOn (f i) t) :\n    ContinuousOn (fun a => (l.map fun i => f i a).prod) t :=\n  by\n  intro x hx\n  rw [continuousWithinAt_iff_continuousAt_restrict _ hx]\n  refine' tendsto_list_prod _ fun i hi => _\n  specialize h i hi x hx\n  rw [continuousWithinAt_iff_continuousAt_restrict _ hx] at h\n  exact h\n#align continuous_on_list_prod continuousOn_list_prod\n#align continuous_on_list_sum continuousOn_list_sum\n-/\n\n",
 "continuousOn_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print continuousOn_finset_prod /-\n@[to_additive]\ntheorem continuousOn_finset_prod {f : ι → X → M} (s : Finset ι) {t : Set X} :\n    (∀ i ∈ s, ContinuousOn (f i) t) →\n      ContinuousOn\n        (fun a =>\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a))\n        t :=\n  continuousOn_multiset_prod _\n#align continuous_on_finset_prod continuousOn_finset_prod\n#align continuous_on_finset_sum continuousOn_finset_sum\n-/\n\n",
 "continuousMul_of_comm_of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print continuousMul_of_comm_of_nhds_one /-\n@[to_additive]\ntheorem continuousMul_of_comm_of_nhds_one (M : Type u) [CommMonoid M] [TopologicalSpace M]\n    (hmul : Tendsto (uncurry ((· * ·) : M → M → M)) (filter.prod ((nhds) 1) ((nhds) 1)) ((nhds) 1))\n    (hleft : ∀ x₀ : M, (nhds) x₀ = map (fun x => x₀ * x) ((nhds) 1)) : ContinuousMul M :=\n  by\n  apply ContinuousMul.of_nhds_one hmul hleft\n  intro x₀\n  simp_rw [mul_comm, hleft x₀]\n#align has_continuous_mul_of_comm_of_nhds_one continuousMul_of_comm_of_nhds_one\n#align has_continuous_add_of_comm_of_nhds_zero continuousAdd_of_comm_of_nhds_zero\n-/\n\n",
 "continuousMul_infₛ":
 "#print continuousMul_infₛ /-\n@[to_additive]\ntheorem continuousMul_infₛ {ts : Set (TopologicalSpace M)} (h : ∀ t ∈ ts, @ContinuousMul M t _) :\n    @ContinuousMul M (infₛ ts) _ :=\n  {\n    continuous_mul :=\n      continuous_infₛ_rng.2 fun t ht => continuous_infₛ_dom₂ ht ht (@has_continuous_mul.continuous_mul M t _ (h t ht)) }\n#align has_continuous_mul_Inf continuousMul_infₛ\n#align has_continuous_add_Inf continuousAdd_infₛ\n-/\n\n",
 "continuousMul_infᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print continuousMul_infᵢ /-\n@[to_additive]\ntheorem continuousMul_infᵢ {ts : ι' → TopologicalSpace M} (h' : ∀ i, @ContinuousMul M (ts i) _) :\n    @ContinuousMul M\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (ts i)) _ :=\n  by\n  rw [← infₛ_range]\n  exact continuousMul_infₛ (set.forall_range_iff.mpr h')\n#align has_continuous_mul_infi continuousMul_infᵢ\n#align has_continuous_add_infi continuousAdd_infᵢ\n-/\n\n",
 "continuousMul_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print continuousMul_inf /-\n@[to_additive]\ntheorem continuousMul_inf {t₁ t₂ : TopologicalSpace M} (h₁ : @ContinuousMul M t₁ _) (h₂ : @ContinuousMul M t₂ _) :\n    @ContinuousMul M («expr ⊓ » t₁ t₂) _ := by\n  rw [inf_eq_infᵢ]\n  refine' continuousMul_infᵢ fun b => _\n  cases b <;> assumption\n#align has_continuous_mul_inf continuousMul_inf\n#align has_continuous_add_inf continuousAdd_inf\n-/\n\n",
 "continuousMul_induced":
 "#print continuousMul_induced /-\n@[to_additive]\ntheorem continuousMul_induced {M N F : Type _} [Mul M] [Mul N] [MulHomClass F M N] [TopologicalSpace N]\n    [ContinuousMul N] (f : F) : @ContinuousMul M (induced f ‹_›) _ :=\n  letI := induced f ‹_›\n  Inducing.continuousMul f ⟨rfl⟩\n#align has_continuous_mul_induced continuousMul_induced\n#align has_continuous_add_induced continuousAdd_induced\n-/\n\n",
 "continuousMul":
 "#print Inducing.continuousMul /-\n@[to_additive]\ntheorem Inducing.continuousMul {M N F : Type _} [Mul M] [Mul N] [MulHomClass F M N] [TopologicalSpace M]\n    [TopologicalSpace N] [ContinuousMul N] (f : F) (hf : Inducing f) : ContinuousMul M :=\n  ⟨hf.continuous_iff.2 <| by simpa only [(· ∘ ·), map_mul f] using hf.continuous.fst'.mul hf.continuous.snd'⟩\n#align inducing.has_continuous_mul Inducing.continuousMul\n#align inducing.has_continuous_add Inducing.continuousAdd\n-/\n\n",
 "continuousAt_pow":
 "#print continuousAt_pow /-\n@[to_additive]\ntheorem continuousAt_pow (x : M) (n : ℕ) : ContinuousAt (fun x => x ^ n) x :=\n  (continuous_pow n).continuous_at\n#align continuous_at_pow continuousAt_pow\n#align continuous_at_nsmul continuousAt_nsmul\n-/\n\n",
 "const_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n#print Filter.TendstoNhdsWithinIio.const_mul /-\ntheorem Filter.TendstoNhdsWithinIio.const_mul [PosMulStrictMono 𝕜] [PosMulReflectLT 𝕜]\n    (h : Tendsto f l (nhds_within.lt c)) : Tendsto (fun a => b * f a) l (nhds_within.lt (b * c)) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ ((tendsto_nhds_of_tendsto_nhdsWithin h).const_mul b) <|\n    (tendsto_nhdsWithin_iff.mp h).2.mono fun j => (mul_lt_mul_left hb).mpr\n#align filter.tendsto_nhds_within_Iio.const_mul Filter.TendstoNhdsWithinIio.const_mul\n-/\n\n",
 "coe_mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[to_additive, simp]\ntheorem coe_mul_right (x : X) : «expr⇑ » (ContinuousMap.mulRight x) = fun y => y * x :=\n  rfl\n#align coe_mul_right coe_mul_right\n\n",
 "coe_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[to_additive, simp]\ntheorem coe_mul_left (x : X) : «expr⇑ » (ContinuousMap.mulLeft x) = fun y => x * y :=\n  rfl\n#align coe_mul_left coe_mul_left\n\n"}