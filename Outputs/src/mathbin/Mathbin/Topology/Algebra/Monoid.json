{"units_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Üí* ¬ª -/\n#print Continuous.units_map /-\n@[to_additive]\ntheorem Continuous.units_map [Monoid M] [Monoid N] [TopologicalSpace M] [TopologicalSpace N] (f : ¬´expr ‚Üí* ¬ª M N)\n    (hf : Continuous f) : Continuous (Units.map f) :=\n  Units.continuous_iff.2 ‚ü®hf.comp Units.continuous_val, hf.comp Units.continuous_coe_inv‚ü©\n#align continuous.units_map Continuous.units_map\n#align continuous.add_units_map Continuous.addUnits_map\n-/\n\n",
 "topologicalClosure_minimal":
 "#print Submonoid.topologicalClosure_minimal /-\n@[to_additive]\ntheorem Submonoid.topologicalClosure_minimal (s : Submonoid M) {t : Submonoid M} (h : s ‚â§ t)\n    (ht : IsClosed (t : Set M)) : s.topological_closure ‚â§ t :=\n  closure_minimal h ht\n#align submonoid.topological_closure_minimal Submonoid.topologicalClosure_minimal\n#align add_submonoid.topological_closure_minimal AddSubmonoid.topologicalClosure_minimal\n-/\n\n",
 "top_closure_mul_self_subset":
 "#print Submonoid.top_closure_mul_self_subset /-\n@[to_additive]\ntheorem Submonoid.top_closure_mul_self_subset (s : Submonoid M) : closure (s : Set M) * closure s ‚äÜ closure s :=\n  image2_subset_iff.2 fun x hx y hy => map_mem_closure‚ÇÇ continuous_mul hx hy fun a ha b hb => s.mul_mem ha hb\n#align submonoid.top_closure_mul_self_subset Submonoid.top_closure_mul_self_subset\n#align add_submonoid.top_closure_add_self_subset AddSubmonoid.top_closure_add_self_subset\n-/\n\n",
 "top_closure_mul_self_eq":
 "#print Submonoid.top_closure_mul_self_eq /-\n@[to_additive]\ntheorem Submonoid.top_closure_mul_self_eq (s : Submonoid M) : closure (s : Set M) * closure s = closure s :=\n  Subset.antisymm s.top_closure_mul_self_subset fun x hx => ‚ü®x, 1, hx, subset_closure s.one_mem, mul_one _‚ü©\n#align submonoid.top_closure_mul_self_eq Submonoid.top_closure_mul_self_eq\n#align add_submonoid.top_closure_add_self_eq AddSubmonoid.top_closure_add_self_eq\n-/\n\n",
 "tendsto_multiset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_multiset_prod /-\n@[to_additive]\ntheorem tendsto_multiset_prod {f : Œπ ‚Üí Œ± ‚Üí M} {x : Filter Œ±} {a : Œπ ‚Üí M} (s : Multiset Œπ) :\n    (‚àÄ i ‚àà s, Tendsto (f i) x ((nhds) (a i))) ‚Üí\n      Tendsto (fun b => (s.map fun c => f c b).prod) x ((nhds) (s.map a).prod) :=\n  by\n  rcases s with ‚ü®l‚ü©\n  simpa using tendsto_list_prod l\n#align tendsto_multiset_prod tendsto_multiset_prod\n#align tendsto_multiset_sum tendsto_multiset_sum\n-/\n\n",
 "tendsto_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_mul /-\n@[to_additive]\ntheorem tendsto_mul {a b : M} : Tendsto (fun p : M √ó M => p.fst * p.snd) ((nhds) (a, b)) ((nhds) (a * b)) :=\n  continuous_iff_continuousAt.mp has_continuous_mul.continuous_mul (a, b)\n#align tendsto_mul tendsto_mul\n#align tendsto_add tendsto_add\n-/\n\n",
 "tendsto_list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_list_prod /-\n@[to_additive]\ntheorem tendsto_list_prod {f : Œπ ‚Üí Œ± ‚Üí M} {x : Filter Œ±} {a : Œπ ‚Üí M} :\n    ‚àÄ l : List Œπ,\n      (‚àÄ i ‚àà l, Tendsto (f i) x ((nhds) (a i))) ‚Üí\n        Tendsto (fun b => (l.map fun c => f c b).prod) x ((nhds) (l.map a).prod)\n  | [], _ => by simp [tendsto_const_nhds]\n  | sym.cons' f l, h => by\n    simp only [list.map_cons, List.prod_cons]\n    exact (h f (list.mem_cons_self _ _)).mul (tendsto_list_prod l fun c hc => h c (list.mem_cons_of_mem _ hc))\n#align tendsto_list_prod tendsto_list_prod\n#align tendsto_list_sum tendsto_list_sum\n-/\n\n",
 "tendsto_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print tendsto_finset_prod /-\n@[to_additive]\ntheorem tendsto_finset_prod {f : Œπ ‚Üí Œ± ‚Üí M} {x : Filter Œ±} {a : Œπ ‚Üí M} (s : Finset Œπ) :\n    (‚àÄ i ‚àà s, Tendsto (f i) x ((nhds) (a i))) ‚Üí\n      Tendsto\n        (fun b =>\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f c b))\n        x\n        ((nhds)\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n            (a c))) :=\n  tendsto_multiset_prod _\n#align tendsto_finset_prod tendsto_finset_prod\n#align tendsto_finset_sum tendsto_finset_sum\n-/\n\n",
 "tendsto_cocompact_mul_right":
 "#print Filter.tendsto_cocompact_mul_right /-\n/-- Right-multiplication by a right-invertible element of a topological monoid is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_right {a b : M} (ha : a * b = 1) :\n    Filter.Tendsto (fun x : M => x * a) (Filter.cocompact M) (Filter.cocompact M) :=\n  by\n  refine' Filter.Tendsto.of_tendsto_comp _ (Filter.comap_cocompact_le (continuous_mul_right b))\n  convert Filter.tendsto_id\n  ext x\n  simp [ha]\n#align filter.tendsto_cocompact_mul_right Filter.tendsto_cocompact_mul_right\n-/\n\n",
 "tendsto_cocompact_mul_left":
 "#print Filter.tendsto_cocompact_mul_left /-\n/-- Left-multiplication by a left-invertible element of a topological monoid is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_left {a b : M} (ha : b * a = 1) :\n    Filter.Tendsto (fun x : M => a * x) (Filter.cocompact M) (Filter.cocompact M) :=\n  by\n  refine' Filter.Tendsto.of_tendsto_comp _ (Filter.comap_cocompact_le (continuous_mul_left b))\n  convert Filter.tendsto_id\n  ext x\n  simp [ha]\n#align filter.tendsto_cocompact_mul_left Filter.tendsto_cocompact_mul_left\n-/\n\n",
 "pow":
 "#print ContinuousOn.pow /-\n@[to_additive ContinuousOn.nsmul]\ntheorem ContinuousOn.pow {f : X ‚Üí M} {s : Set X} (hf : ContinuousOn f s) (n : ‚Ñï) : ContinuousOn (fun x => f x ^ n) s :=\n  fun x hx => (hf x hx).pow n\n#align continuous_on.pow ContinuousOn.pow\n#align continuous_on.nsmul ContinuousOn.nsmul\n-/\n\n",
 "of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ContinuousMul.of_nhds_one /-\n@[to_additive]\ntheorem ContinuousMul.of_nhds_one {M : Type u} [Monoid M] [TopologicalSpace M]\n    (hmul : Tendsto (uncurry ((¬∑ * ¬∑) : M ‚Üí M ‚Üí M)) (filter.prod ((nhds) 1) ((nhds) 1)) <| (nhds) 1)\n    (hleft : ‚àÄ x‚ÇÄ : M, (nhds) x‚ÇÄ = map (fun x => x‚ÇÄ * x) ((nhds) 1))\n    (hright : ‚àÄ x‚ÇÄ : M, (nhds) x‚ÇÄ = map (fun x => x * x‚ÇÄ) ((nhds) 1)) : ContinuousMul M :=\n  ‚ü®by\n    rw [continuous_iff_continuousAt]\n    rintro ‚ü®x‚ÇÄ, y‚ÇÄ‚ü©\n    have key : (fun p : M √ó M => x‚ÇÄ * p.1 * (p.2 * y‚ÇÄ)) = ((fun x => x‚ÇÄ * x) ‚àò fun x => x * y‚ÇÄ) ‚àò uncurry (¬∑ * ¬∑) :=\n      by\n      ext p\n      simp [uncurry, mul_assoc]\n    have key‚ÇÇ : ((fun x => x‚ÇÄ * x) ‚àò fun x => y‚ÇÄ * x) = fun x => x‚ÇÄ * y‚ÇÄ * x :=\n      by\n      ext x\n      simp\n    calc\n      map (uncurry (¬∑ * ¬∑)) ((nhds) (x‚ÇÄ, y‚ÇÄ)) = map (uncurry (¬∑ * ¬∑)) (filter.prod ((nhds) x‚ÇÄ) ((nhds) y‚ÇÄ)) := by\n        rw [nhds_prod_eq]\n      _ = map (fun p : M √ó M => x‚ÇÄ * p.1 * (p.2 * y‚ÇÄ)) (filter.prod ((nhds) 1) ((nhds) 1)) := by\n        rw [uncurry, hleft x‚ÇÄ, hright y‚ÇÄ, prod_map_map_eq, Filter.map_map]\n      _ = map ((fun x => x‚ÇÄ * x) ‚àò fun x => x * y‚ÇÄ) (map (uncurry (¬∑ * ¬∑)) (filter.prod ((nhds) 1) ((nhds) 1))) := by\n        rw [key, ‚Üê Filter.map_map]\n      _ ‚â§ map ((fun x : M => x‚ÇÄ * x) ‚àò fun x => x * y‚ÇÄ) ((nhds) 1) := (map_mono hmul)\n      _ = (nhds) (x‚ÇÄ * y‚ÇÄ) := by rw [‚Üê Filter.map_map, ‚Üê hright, hleft y‚ÇÄ, Filter.map_map, key‚ÇÇ, ‚Üê hleft]\n      ‚ü©\n#align has_continuous_mul.of_nhds_one ContinuousMul.of_nhds_one\n#align has_continuous_add.of_nhds_zero ContinuousAdd.of_nhds_zero\n-/\n\n",
 "nhds_one_mul_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_one_mul_nhds /-\n@[simp, to_additive]\ntheorem nhds_one_mul_nhds {M} [MulOneClass M] [TopologicalSpace M] [ContinuousMul M] (a : M) :\n    (nhds) (1 : M) * (nhds) a = (nhds) a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (one_mul a)).antisymm <| le_mul_of_one_le_left' <| pure_le_nhds 1\n#align nhds_one_mul_nhds nhds_one_mul_nhds\n#align nhds_zero_add_nhds nhds_zero_add_nhds\n-/\n\n",
 "nhds_mul_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_mul_nhds_one /-\n@[simp, to_additive]\ntheorem nhds_mul_nhds_one {M} [MulOneClass M] [TopologicalSpace M] [ContinuousMul M] (a : M) :\n    (nhds) a * (nhds) 1 = (nhds) a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (mul_one a)).antisymm <| le_mul_of_one_le_right' <| pure_le_nhds 1\n#align nhds_mul_nhds_one nhds_mul_nhds_one\n#align nhds_add_nhds_zero nhds_add_nhds_zero\n-/\n\n",
 "mul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n#print Filter.TendstoNhdsWithinIio.mul_const /-\ntheorem Filter.TendstoNhdsWithinIio.mul_const [MulPosStrictMono ùïú] [MulPosReflectLT ùïú]\n    (h : Tendsto f l (nhds_within.lt c)) : Tendsto (fun a => f a * b) l (nhds_within.lt (c * b)) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ ((tendsto_nhds_of_tendsto_nhdsWithin h).mul_const b) <|\n    (tendsto_nhdsWithin_iff.mp h).2.mono fun j => (mul_lt_mul_right hb).mpr\n#align filter.tendsto_nhds_within_Iio.mul_const Filter.TendstoNhdsWithinIio.mul_const\n-/\n\n",
 "mul":
 "#print IsCompact.mul /-\n@[to_additive]\ntheorem IsCompact.mul {s t : Set M} (hs : IsCompact s) (ht : IsCompact t) : IsCompact (s * t) :=\n  by\n  rw [‚Üê image_mul_prod]\n  exact (hs.prod ht).image continuous_mul\n#align is_compact.mul IsCompact.mul\n#align is_compact.add IsCompact.add\n-/\n\n",
 "mem_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Submonoid.mem_nhds_one /-\n@[to_additive]\ntheorem Submonoid.mem_nhds_one (S : Submonoid M) (oS : IsOpen (S : Set M)) : (S : Set M) ‚àà (nhds) (1 : M) :=\n  IsOpen.mem_nhds oS S.one_mem\n#align submonoid.mem_nhds_one Submonoid.mem_nhds_one\n#align add_submonoid.mem_nhds_zero AddSubmonoid.mem_nhds_zero\n-/\n\n",
 "le_topologicalClosure":
 "#print Submonoid.le_topologicalClosure /-\n@[to_additive]\ntheorem Submonoid.le_topologicalClosure (s : Submonoid M) : s ‚â§ s.topological_closure :=\n  subset_closure\n#align submonoid.le_topological_closure Submonoid.le_topologicalClosure\n#align add_submonoid.le_topological_closure AddSubmonoid.le_topologicalClosure\n-/\n\n",
 "le_nhds_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print le_nhds_mul /-\n@[to_additive]\ntheorem le_nhds_mul (a b : M) : (nhds) a * (nhds) b ‚â§ (nhds) (a * b) :=\n  by\n  rw [‚Üê map‚ÇÇ_mul, ‚Üê map_uncurry_prod, ‚Üê nhds_prod_eq]\n  exact continuous_mul.tendsto _\n#align le_nhds_mul le_nhds_mul\n#align le_nhds_add le_nhds_add\n-/\n\n",
 "isClosed_topologicalClosure":
 "#print Submonoid.isClosed_topologicalClosure /-\n@[to_additive]\ntheorem Submonoid.isClosed_topologicalClosure (s : Submonoid M) : IsClosed (s.topological_closure : Set M) := by\n  convert isClosed_closure\n#align submonoid.is_closed_topological_closure Submonoid.isClosed_topologicalClosure\n#align add_submonoid.is_closed_topological_closure AddSubmonoid.isClosed_topologicalClosure\n-/\n\n",
 "isClosed_setOf_map_one":
 "#print isClosed_setOf_map_one /-\n@[to_additive]\ntheorem isClosed_setOf_map_one [One M‚ÇÅ] [One M‚ÇÇ] : IsClosed { f : M‚ÇÅ ‚Üí M‚ÇÇ | f 1 = 1 } :=\n  isClosed_eq (continuous_apply 1) continuous_const\n#align is_closed_set_of_map_one isClosed_setOf_map_one\n#align is_closed_set_of_map_zero isClosed_setOf_map_zero\n-/\n\n",
 "isClosed_setOf_map_mul":
 "#print isClosed_setOf_map_mul /-\n@[to_additive]\ntheorem isClosed_setOf_map_mul [Mul M‚ÇÅ] [Mul M‚ÇÇ] [ContinuousMul M‚ÇÇ] :\n    IsClosed { f : M‚ÇÅ ‚Üí M‚ÇÇ | ‚àÄ x y, f (x * y) = f x * f y } :=\n  by\n  simp only [set_of_forall]\n  exact\n    isClosed_inter·µ¢ fun x =>\n      isClosed_inter·µ¢ fun y => isClosed_eq (continuous_apply _) ((continuous_apply _).mul (continuous_apply _))\n#align is_closed_set_of_map_mul isClosed_setOf_map_mul\n#align is_closed_set_of_map_add isClosed_setOf_map_add\n-/\n\n",
 "isClosed_range_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Üí* ¬ª -/\n#print MonoidHom.isClosed_range_coe /-\n@[to_additive]\ntheorem MonoidHom.isClosed_range_coe : IsClosed (range (coe_fn : ¬´expr ‚Üí* ¬ª M‚ÇÅ M‚ÇÇ ‚Üí M‚ÇÅ ‚Üí M‚ÇÇ)) :=\n  isClosed_of_closure_subset fun f hf => ‚ü®monoidHomOfMemClosureRangeCoe f hf, rfl‚ü©\n#align monoid_hom.is_closed_range_coe MonoidHom.isClosed_range_coe\n#align add_monoid_hom.is_closed_range_coe AddMonoidHom.isClosed_range_coe\n-/\n\n",
 "finprod_eventually_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print finprod_eventually_eq_prod /-\n@[to_additive]\ntheorem finprod_eventually_eq_prod {M : Type _} [CommMonoid M] {f : Œπ ‚Üí X ‚Üí M}\n    (hf : LocallyFinite fun i => mulSupport (f i)) (x : X) :\n    ‚àÉ s : Finset Œπ,\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" ((nhds) x)\n        (finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (f i y) =\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n            (f i y)) :=\n  let ‚ü®I, hI‚ü© := hf.exists_finset_mul_support x\n  ‚ü®I, hI.mono fun y hy => finprod_eq_prod_of_mulSupport_subset _ fun i hi => hy hi‚ü©\n#align finprod_eventually_eq_prod finprod_eventually_eq_prod\n#align finsum_eventually_eq_sum finsum_eventually_eq_sum\n-/\n\n",
 "exists_open_nhds_one_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_open_nhds_one_split /-\n@[to_additive exists_open_nhds_zero_half]\ntheorem exists_open_nhds_one_split {s : Set M} (hs : s ‚àà (nhds) (1 : M)) :\n    ‚àÉ V : Set M, IsOpen V ‚àß (1 : M) ‚àà V ‚àß ‚àÄ v ‚àà V, ‚àÄ w ‚àà V, v * w ‚àà s :=\n  by\n  have : ¬´expr ‚Åª¬π' ¬ª (fun a : M √ó M => a.1 * a.2) s ‚àà (nhds) ((1, 1) : M √ó M) :=\n    tendsto_mul (by simpa only [one_mul] using hs)\n  simpa only [prod_subset_iff] using exists_nhds_square this\n#align exists_open_nhds_one_split exists_open_nhds_one_split\n#align exists_open_nhds_zero_half exists_open_nhds_zero_half\n-/\n\n",
 "exists_open_nhds_one_mul_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_open_nhds_one_mul_subset /-\n/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `VV ‚äÜ U`. -/\n@[to_additive \"Given a open neighborhood `U` of `0` there is a open neighborhood `V` of `0`\\n  such that `V + V ‚äÜ U`.\"]\ntheorem exists_open_nhds_one_mul_subset {U : Set M} (hU : U ‚àà (nhds) (1 : M)) :\n    ‚àÉ V : Set M, IsOpen V ‚àß (1 : M) ‚àà V ‚àß V * V ‚äÜ U :=\n  by\n  rcases exists_open_nhds_one_split hU with ‚ü®V, Vo, V1, hV‚ü©\n  use V, Vo, V1\n  rintro _ ‚ü®x, y, hx, hy, rfl‚ü©\n  exact hV _ hx _ hy\n#align exists_open_nhds_one_mul_subset exists_open_nhds_one_mul_subset\n#align exists_open_nhds_zero_add_subset exists_open_nhds_zero_add_subset\n-/\n\n",
 "exists_nhds_one_split4":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_nhds_one_split4 /-\n@[to_additive exists_nhds_zero_quarter]\ntheorem exists_nhds_one_split4 {u : Set M} (hu : u ‚àà (nhds) (1 : M)) :\n    ‚àÉ V ‚àà (nhds) (1 : M), ‚àÄ {v w s t}, v ‚àà V ‚Üí w ‚àà V ‚Üí s ‚àà V ‚Üí t ‚àà V ‚Üí v * w * s * t ‚àà u :=\n  by\n  rcases exists_nhds_one_split hu with ‚ü®W, W1, h‚ü©\n  rcases exists_nhds_one_split W1 with ‚ü®V, V1, h'‚ü©\n  use V, V1\n  intro v w s t v_in w_in s_in t_in\n  simpa only [mul_assoc] using h _ (h' v v_in w w_in) _ (h' s s_in t t_in)\n#align exists_nhds_one_split4 exists_nhds_one_split4\n#align exists_nhds_zero_quarter exists_nhds_zero_quarter\n-/\n\n",
 "exists_nhds_one_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_nhds_one_split /-\n@[to_additive exists_nhds_zero_half]\ntheorem exists_nhds_one_split {s : Set M} (hs : s ‚àà (nhds) (1 : M)) :\n    ‚àÉ V ‚àà (nhds) (1 : M), ‚àÄ v ‚àà V, ‚àÄ w ‚àà V, v * w ‚àà s :=\n  let ‚ü®V, Vo, V1, hV‚ü© := exists_open_nhds_one_split hs\n  ‚ü®V, IsOpen.mem_nhds Vo V1, hV‚ü©\n#align exists_nhds_one_split exists_nhds_one_split\n#align exists_nhds_zero_half exists_nhds_zero_half\n-/\n\n",
 "exists_finset_mulSupport":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print LocallyFinite.exists_finset_mulSupport /-\n@[to_additive]\ntheorem LocallyFinite.exists_finset_mulSupport {M : Type _} [CommMonoid M] {f : Œπ ‚Üí X ‚Üí M}\n    (hf : LocallyFinite fun i => mulSupport <| f i) (x‚ÇÄ : X) :\n    ‚àÉ I : Finset Œπ,\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n        ((nhds) x‚ÇÄ) ((mulSupport fun i => f i x) ‚äÜ I) :=\n  by\n  rcases hf x‚ÇÄ with ‚ü®U, hxU, hUf‚ü©\n  refine' ‚ü®hUf.to_finset, mem_of_superset hxU fun y hy i hi => _‚ü©\n  rw [hUf.coe_to_finset]\n  exact ‚ü®y, hi, hy‚ü©\n#align locally_finite.exists_finset_mul_support LocallyFinite.exists_finset_mulSupport\n#align locally_finite.exists_finset_support LocallyFinite.exists_finset_support\n-/\n\n",
 "eventuallyEq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr =·∂†[ ] ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr =·∂†[ ] ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print eventuallyEq_prod /-\n@[to_additive]\ntheorem eventuallyEq_prod {X M : Type _} [CommMonoid M] {s : Finset Œπ} {l : Filter X} {f g : Œπ ‚Üí X ‚Üí M}\n    (hs : ‚àÄ i ‚àà s, ¬´expr =·∂†[ ] ¬ª (f i) l (g i)) :\n    ¬´expr =·∂†[ ] ¬ª\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) l\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g i)) :=\n  by\n  replace hs :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" l\n      (‚àÄ i ‚àà s, f i x = g i x)\n  ¬∑ rwa [eventually_all_finset]\n  filter_upwards [hs]with x hx\n  simp only [Finset.prod_apply, Finset.prod_congr rfl hx]\n#align eventually_eq_prod eventuallyEq_prod\n#align eventually_eq_sum eventuallyEq_sum\n-/\n\n",
 "continuous_pow":
 "#print continuous_pow /-\n@[continuity, to_additive]\ntheorem continuous_pow : ‚àÄ n : ‚Ñï, Continuous fun a : M => a ^ n\n  | 0 => by simpa using continuous_const\n  | k + 1 => by\n    simp only [pow_succ]\n    exact continuous_id.mul (continuous_pow _)\n#align continuous_pow continuous_pow\n#align continuous_nsmul continuous_nsmul\n-/\n\n",
 "continuous_one":
 "#print continuous_one /-\n/-\nCopyright (c) 2017 Johannes H√∂lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes H√∂lzl, Mario Carneiro\n-/\n@[to_additive]\ntheorem continuous_one [TopologicalSpace M] [One M] : Continuous (1 : X ‚Üí M) :=\n  @continuous_const _ _ _ _ 1\n#align continuous_one continuous_one\n#align continuous_zero continuous_zero\n-/\n\n",
 "continuous_multiset_prod":
 "#print continuous_multiset_prod /-\n@[continuity, to_additive]\ntheorem continuous_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) :\n    (‚àÄ i ‚àà s, Continuous (f i)) ‚Üí Continuous fun a => (s.map fun i => f i a).prod :=\n  by\n  rcases s with ‚ü®l‚ü©\n  simpa using continuous_list_prod l\n#align continuous_multiset_prod continuous_multiset_prod\n#align continuous_multiset_sum continuous_multiset_sum\n-/\n\n",
 "continuous_mul_right":
 "#print continuous_mul_right /-\n@[to_additive]\ntheorem continuous_mul_right (a : M) : Continuous fun b : M => b * a :=\n  continuous_id.mul continuous_const\n#align continuous_mul_right continuous_mul_right\n#align continuous_add_right continuous_add_right\n-/\n\n",
 "continuous_mul_left":
 "#print continuous_mul_left /-\n@[to_additive]\ntheorem continuous_mul_left (a : M) : Continuous fun b : M => a * b :=\n  continuous_const.mul continuous_id\n#align continuous_mul_left continuous_mul_left\n#align continuous_add_left continuous_add_left\n-/\n\n",
 "continuous_mul":
 "#print continuous_mul /-\n@[to_additive]\ntheorem continuous_mul : Continuous fun p : M √ó M => p.1 * p.2 :=\n  has_continuous_mul.continuous_mul\n#align continuous_mul continuous_mul\n#align continuous_add continuous_add\n-/\n\n",
 "continuous_list_prod":
 "#print continuous_list_prod /-\n@[to_additive]\ntheorem continuous_list_prod {f : Œπ ‚Üí X ‚Üí M} (l : List Œπ) (h : ‚àÄ i ‚àà l, Continuous (f i)) :\n    Continuous fun a => (l.map fun i => f i a).prod :=\n  continuous_iff_continuousAt.2 fun x => tendsto_list_prod l fun c hc => continuous_iff_continuousAt.1 (h c hc) x\n#align continuous_list_prod continuous_list_prod\n#align continuous_list_sum continuous_list_sum\n-/\n\n",
 "continuous_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print continuous_finset_prod /-\n@[continuity, to_additive]\ntheorem continuous_finset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Finset Œπ) :\n    (‚àÄ i ‚àà s, Continuous (f i)) ‚Üí\n      Continuous fun a =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a) :=\n  continuous_multiset_prod _\n#align continuous_finset_prod continuous_finset_prod\n#align continuous_finset_sum continuous_finset_sum\n-/\n\n",
 "continuous_finprod_cond":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\n#print continuous_finprod_cond /-\n@[to_additive]\ntheorem continuous_finprod_cond {f : Œπ ‚Üí X ‚Üí M} {p : Œπ ‚Üí Prop} (hc : ‚àÄ i, p i ‚Üí Continuous (f i))\n    (hf : LocallyFinite fun i => mulSupport (f i)) :\n    Continuous fun x =>\n      finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (f i x) :=\n  by\n  simp only [‚Üê finprod_subtype_eq_finprod_cond]\n  exact continuous_finprod (fun i => hc i i.2) (hf.comp_injective Subtype.coe_injective)\n#align continuous_finprod_cond continuous_finprod_cond\n#align continuous_finsum_cond continuous_finsum_cond\n-/\n\n",
 "continuous_finprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\n#print continuous_finprod /-\n@[to_additive]\ntheorem continuous_finprod {f : Œπ ‚Üí X ‚Üí M} (hc : ‚àÄ i, Continuous (f i)) (hf : LocallyFinite fun i => mulSupport (f i)) :\n    Continuous fun x =>\n      finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (f i x) :=\n  by\n  refine' continuous_iff_continuousAt.2 fun x => _\n  rcases finprod_eventually_eq_prod hf x with ‚ü®s, hs‚ü©\n  refine' ContinuousAt.congr _ (eventually_eq.symm hs)\n  exact tendsto_finset_prod _ fun i hi => (hc i).continuous_at\n#align continuous_finprod continuous_finprod\n#align continuous_finsum continuous_finsum\n-/\n\n",
 "continuousOn_pow":
 "#print continuousOn_pow /-\n@[to_additive]\ntheorem continuousOn_pow {s : Set M} (n : ‚Ñï) : ContinuousOn (fun x => x ^ n) s :=\n  (continuous_pow n).continuous_on\n#align continuous_on_pow continuousOn_pow\n#align continuous_on_nsmul continuousOn_nsmul\n-/\n\n",
 "continuousOn_multiset_prod":
 "#print continuousOn_multiset_prod /-\n@[to_additive]\ntheorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :\n    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t :=\n  by\n  rcases s with ‚ü®l‚ü©\n  simpa using continuousOn_list_prod l\n#align continuous_on_multiset_prod continuousOn_multiset_prod\n#align continuous_on_multiset_sum continuousOn_multiset_sum\n-/\n\n",
 "continuousOn_list_prod":
 "#print continuousOn_list_prod /-\n@[to_additive]\ntheorem continuousOn_list_prod {f : Œπ ‚Üí X ‚Üí M} (l : List Œπ) {t : Set X} (h : ‚àÄ i ‚àà l, ContinuousOn (f i) t) :\n    ContinuousOn (fun a => (l.map fun i => f i a).prod) t :=\n  by\n  intro x hx\n  rw [continuousWithinAt_iff_continuousAt_restrict _ hx]\n  refine' tendsto_list_prod _ fun i hi => _\n  specialize h i hi x hx\n  rw [continuousWithinAt_iff_continuousAt_restrict _ hx] at h\n  exact h\n#align continuous_on_list_prod continuousOn_list_prod\n#align continuous_on_list_sum continuousOn_list_sum\n-/\n\n",
 "continuousOn_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print continuousOn_finset_prod /-\n@[to_additive]\ntheorem continuousOn_finset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Finset Œπ) {t : Set X} :\n    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí\n      ContinuousOn\n        (fun a =>\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a))\n        t :=\n  continuousOn_multiset_prod _\n#align continuous_on_finset_prod continuousOn_finset_prod\n#align continuous_on_finset_sum continuousOn_finset_sum\n-/\n\n",
 "continuousMul_of_comm_of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print continuousMul_of_comm_of_nhds_one /-\n@[to_additive]\ntheorem continuousMul_of_comm_of_nhds_one (M : Type u) [CommMonoid M] [TopologicalSpace M]\n    (hmul : Tendsto (uncurry ((¬∑ * ¬∑) : M ‚Üí M ‚Üí M)) (filter.prod ((nhds) 1) ((nhds) 1)) ((nhds) 1))\n    (hleft : ‚àÄ x‚ÇÄ : M, (nhds) x‚ÇÄ = map (fun x => x‚ÇÄ * x) ((nhds) 1)) : ContinuousMul M :=\n  by\n  apply ContinuousMul.of_nhds_one hmul hleft\n  intro x‚ÇÄ\n  simp_rw [mul_comm, hleft x‚ÇÄ]\n#align has_continuous_mul_of_comm_of_nhds_one continuousMul_of_comm_of_nhds_one\n#align has_continuous_add_of_comm_of_nhds_zero continuousAdd_of_comm_of_nhds_zero\n-/\n\n",
 "continuousMul_inf‚Çõ":
 "#print continuousMul_inf‚Çõ /-\n@[to_additive]\ntheorem continuousMul_inf‚Çõ {ts : Set (TopologicalSpace M)} (h : ‚àÄ t ‚àà ts, @ContinuousMul M t _) :\n    @ContinuousMul M (inf‚Çõ ts) _ :=\n  {\n    continuous_mul :=\n      continuous_inf‚Çõ_rng.2 fun t ht => continuous_inf‚Çõ_dom‚ÇÇ ht ht (@has_continuous_mul.continuous_mul M t _ (h t ht)) }\n#align has_continuous_mul_Inf continuousMul_inf‚Çõ\n#align has_continuous_add_Inf continuousAdd_inf‚Çõ\n-/\n\n",
 "continuousMul_inf·µ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ö , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª -/\n#print continuousMul_inf·µ¢ /-\n@[to_additive]\ntheorem continuousMul_inf·µ¢ {ts : Œπ' ‚Üí TopologicalSpace M} (h' : ‚àÄ i, @ContinuousMul M (ts i) _) :\n    @ContinuousMul M\n      (¬´expr‚®Ö , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª\" (ts i)) _ :=\n  by\n  rw [‚Üê inf‚Çõ_range]\n  exact continuousMul_inf‚Çõ (set.forall_range_iff.mpr h')\n#align has_continuous_mul_infi continuousMul_inf·µ¢\n#align has_continuous_add_infi continuousAdd_inf·µ¢\n-/\n\n",
 "continuousMul_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n#print continuousMul_inf /-\n@[to_additive]\ntheorem continuousMul_inf {t‚ÇÅ t‚ÇÇ : TopologicalSpace M} (h‚ÇÅ : @ContinuousMul M t‚ÇÅ _) (h‚ÇÇ : @ContinuousMul M t‚ÇÇ _) :\n    @ContinuousMul M (¬´expr ‚äì ¬ª t‚ÇÅ t‚ÇÇ) _ := by\n  rw [inf_eq_inf·µ¢]\n  refine' continuousMul_inf·µ¢ fun b => _\n  cases b <;> assumption\n#align has_continuous_mul_inf continuousMul_inf\n#align has_continuous_add_inf continuousAdd_inf\n-/\n\n",
 "continuousMul_induced":
 "#print continuousMul_induced /-\n@[to_additive]\ntheorem continuousMul_induced {M N F : Type _} [Mul M] [Mul N] [MulHomClass F M N] [TopologicalSpace N]\n    [ContinuousMul N] (f : F) : @ContinuousMul M (induced f ‚Äπ_‚Ä∫) _ :=\n  letI := induced f ‚Äπ_‚Ä∫\n  Inducing.continuousMul f ‚ü®rfl‚ü©\n#align has_continuous_mul_induced continuousMul_induced\n#align has_continuous_add_induced continuousAdd_induced\n-/\n\n",
 "continuousMul":
 "#print Inducing.continuousMul /-\n@[to_additive]\ntheorem Inducing.continuousMul {M N F : Type _} [Mul M] [Mul N] [MulHomClass F M N] [TopologicalSpace M]\n    [TopologicalSpace N] [ContinuousMul N] (f : F) (hf : Inducing f) : ContinuousMul M :=\n  ‚ü®hf.continuous_iff.2 <| by simpa only [(¬∑ ‚àò ¬∑), map_mul f] using hf.continuous.fst'.mul hf.continuous.snd'‚ü©\n#align inducing.has_continuous_mul Inducing.continuousMul\n#align inducing.has_continuous_add Inducing.continuousAdd\n-/\n\n",
 "continuousAt_pow":
 "#print continuousAt_pow /-\n@[to_additive]\ntheorem continuousAt_pow (x : M) (n : ‚Ñï) : ContinuousAt (fun x => x ^ n) x :=\n  (continuous_pow n).continuous_at\n#align continuous_at_pow continuousAt_pow\n#align continuous_at_nsmul continuousAt_nsmul\n-/\n\n",
 "const_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n#print Filter.TendstoNhdsWithinIio.const_mul /-\ntheorem Filter.TendstoNhdsWithinIio.const_mul [PosMulStrictMono ùïú] [PosMulReflectLT ùïú]\n    (h : Tendsto f l (nhds_within.lt c)) : Tendsto (fun a => b * f a) l (nhds_within.lt (b * c)) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ ((tendsto_nhds_of_tendsto_nhdsWithin h).const_mul b) <|\n    (tendsto_nhdsWithin_iff.mp h).2.mono fun j => (mul_lt_mul_left hb).mpr\n#align filter.tendsto_nhds_within_Iio.const_mul Filter.TendstoNhdsWithinIio.const_mul\n-/\n\n",
 "coe_mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚áë ¬ª -/\n@[to_additive, simp]\ntheorem coe_mul_right (x : X) : ¬´expr‚áë ¬ª (ContinuousMap.mulRight x) = fun y => y * x :=\n  rfl\n#align coe_mul_right coe_mul_right\n\n",
 "coe_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚áë ¬ª -/\n@[to_additive, simp]\ntheorem coe_mul_left (x : X) : ¬´expr‚áë ¬ª (ContinuousMap.mulLeft x) = fun y => x * y :=\n  rfl\n#align coe_mul_left coe_mul_left\n\n"}