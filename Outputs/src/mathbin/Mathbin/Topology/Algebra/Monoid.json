{"units_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Üí* ¬ª -/\n@[to_additive]\ntheorem continuous.units_map [monoid M] [monoid N] [topological_space M] [topological_space N] (f : ¬´expr ‚Üí* ¬ª M N)\n    (hf : continuous f) : continuous (Units.map f) :=\n  units.continuous_iff.2 ‚ü®hf.comp units.continuous_coe, hf.comp units.continuous_coe_inv‚ü©\n#align continuous.units_map continuous.units_map\n\n",
 "topological_closure_minimal":
 "@[to_additive]\ntheorem submonoid.topological_closure_minimal (s : Submonoid M) {t : Submonoid M} (h : s ‚â§ t)\n    (ht : is_closed (t : set M)) : s.topological_closure ‚â§ t :=\n  closure_minimal h ht\n#align submonoid.topological_closure_minimal submonoid.topological_closure_minimal\n\n",
 "top_closure_mul_self_subset":
 "@[to_additive]\ntheorem submonoid.top_closure_mul_self_subset (s : Submonoid M) : closure (s : set M) * closure s ‚äÜ closure s :=\n  image2_subset_iff.2 fun x hx y hy => map_mem_closure‚ÇÇ continuous_mul hx hy fun a ha b hb => s.mul_mem ha hb\n#align submonoid.top_closure_mul_self_subset submonoid.top_closure_mul_self_subset\n\n",
 "top_closure_mul_self_eq":
 "@[to_additive]\ntheorem submonoid.top_closure_mul_self_eq (s : Submonoid M) : closure (s : set M) * closure s = closure s :=\n  Subset.antisymm s.top_closure_mul_self_subset fun x hx => ‚ü®x, 1, hx, subset_closure s.one_mem, mul_one _‚ü©\n#align submonoid.top_closure_mul_self_eq submonoid.top_closure_mul_self_eq\n\n",
 "tendsto_multiset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem tendsto_multiset_prod {f : Œπ ‚Üí Œ± ‚Üí M} {x : filter Œ±} {a : Œπ ‚Üí M} (s : Multiset Œπ) :\n    (‚àÄ i ‚àà s, tendsto (f i) x ((nhds) (a i))) ‚Üí\n      tendsto (fun b => (s.map fun c => f c b).prod) x ((nhds) (s.map a).prod) :=\n  by\n  rcases s with ‚ü®l‚ü©\n  simpa using tendsto_list_prod l\n#align tendsto_multiset_prod tendsto_multiset_prod\n\n",
 "tendsto_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem tendsto_mul {a b : M} : tendsto (fun p : M √ó M => p.fst * p.snd) ((nhds) (a, b)) ((nhds) (a * b)) :=\n  continuous_iff_continuous_at.mp has_continuous_mul.continuous_mul (a, b)\n#align tendsto_mul tendsto_mul\n\n",
 "tendsto_list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem tendsto_list_prod {f : Œπ ‚Üí Œ± ‚Üí M} {x : filter Œ±} {a : Œπ ‚Üí M} :\n    ‚àÄ l : list Œπ,\n      (‚àÄ i ‚àà l, tendsto (f i) x ((nhds) (a i))) ‚Üí\n        tendsto (fun b => (l.map fun c => f c b).prod) x ((nhds) (l.map a).prod)\n  | [], _ => by simp [tendsto_const_nhds]\n  | sym.cons' f l, h => by\n    simp only [list.map_cons, List.prod_cons]\n    exact (h f (list.mem_cons_self _ _)).mul (tendsto_list_prod l fun c hc => h c (list.mem_cons_of_mem _ hc))\n#align tendsto_list_prod tendsto_list_prod\n\n",
 "tendsto_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem tendsto_finset_prod {f : Œπ ‚Üí Œ± ‚Üí M} {x : filter Œ±} {a : Œπ ‚Üí M} (s : Finset Œπ) :\n    (‚àÄ i ‚àà s, tendsto (f i) x ((nhds) (a i))) ‚Üí\n      tendsto\n        (fun b =>\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f c b))\n        x\n        ((nhds)\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n            (a c))) :=\n  tendsto_multiset_prod _\n#align tendsto_finset_prod tendsto_finset_prod\n\n",
 "tendsto_cocompact_mul_right":
 "/-- Right-multiplication by a right-invertible element of a topological monoid is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem filter.tendsto_cocompact_mul_right {a b : M} (ha : a * b = 1) :\n    filter.tendsto (fun x : M => x * a) (filter.cocompact M) (filter.cocompact M) :=\n  by\n  refine' filter.tendsto.of_tendsto_comp _ (filter.comap_cocompact_le (continuous_mul_right b))\n  convert filter.tendsto_id\n  ext x\n  simp [ha]\n#align filter.tendsto_cocompact_mul_right filter.tendsto_cocompact_mul_right\n\n",
 "tendsto_cocompact_mul_left":
 "/-- Left-multiplication by a left-invertible element of a topological monoid is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem filter.tendsto_cocompact_mul_left {a b : M} (ha : b * a = 1) :\n    filter.tendsto (fun x : M => a * x) (filter.cocompact M) (filter.cocompact M) :=\n  by\n  refine' filter.tendsto.of_tendsto_comp _ (filter.comap_cocompact_le (continuous_mul_left b))\n  convert filter.tendsto_id\n  ext x\n  simp [ha]\n#align filter.tendsto_cocompact_mul_left filter.tendsto_cocompact_mul_left\n\n",
 "pow":
 "@[to_additive continuous_on.nsmul]\ntheorem continuous_on.pow {f : X ‚Üí M} {s : set X} (hf : continuous_on f s) (n : ‚Ñï) :\n    continuous_on (fun x => f x ^ n) s := fun x hx => (hf x hx).pow n\n#align continuous_on.pow continuous_on.pow\n\n",
 "of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem has_continuous_mul.of_nhds_one {M : Type u} [monoid M] [topological_space M]\n    (hmul : tendsto (uncurry ((¬∑ * ¬∑) : M ‚Üí M ‚Üí M)) (filter.prod ((nhds) 1) ((nhds) 1)) <| (nhds) 1)\n    (hleft : ‚àÄ x‚ÇÄ : M, (nhds) x‚ÇÄ = map (fun x => x‚ÇÄ * x) ((nhds) 1))\n    (hright : ‚àÄ x‚ÇÄ : M, (nhds) x‚ÇÄ = map (fun x => x * x‚ÇÄ) ((nhds) 1)) : has_continuous_mul M :=\n  ‚ü®by\n    rw [continuous_iff_continuous_at]\n    rintro ‚ü®x‚ÇÄ, y‚ÇÄ‚ü©\n    have key : (fun p : M √ó M => x‚ÇÄ * p.1 * (p.2 * y‚ÇÄ)) = ((fun x => x‚ÇÄ * x) ‚àò fun x => x * y‚ÇÄ) ‚àò uncurry (¬∑ * ¬∑) :=\n      by\n      ext p\n      simp [uncurry, mul_assoc]\n    have key‚ÇÇ : ((fun x => x‚ÇÄ * x) ‚àò fun x => y‚ÇÄ * x) = fun x => x‚ÇÄ * y‚ÇÄ * x :=\n      by\n      ext x\n      simp\n    calc\n      map (uncurry (¬∑ * ¬∑)) ((nhds) (x‚ÇÄ, y‚ÇÄ)) = map (uncurry (¬∑ * ¬∑)) (filter.prod ((nhds) x‚ÇÄ) ((nhds) y‚ÇÄ)) := by\n        rw [nhds_prod_eq]\n      _ = map (fun p : M √ó M => x‚ÇÄ * p.1 * (p.2 * y‚ÇÄ)) (filter.prod ((nhds) 1) ((nhds) 1)) := by\n        rw [uncurry, hleft x‚ÇÄ, hright y‚ÇÄ, prod_map_map_eq, filter.map_map]\n      _ = map ((fun x => x‚ÇÄ * x) ‚àò fun x => x * y‚ÇÄ) (map (uncurry (¬∑ * ¬∑)) (filter.prod ((nhds) 1) ((nhds) 1))) := by\n        rw [key, ‚Üê filter.map_map]\n      _ ‚â§ map ((fun x : M => x‚ÇÄ * x) ‚àò fun x => x * y‚ÇÄ) ((nhds) 1) := map_mono hmul\n      _ = (nhds) (x‚ÇÄ * y‚ÇÄ) := by rw [‚Üê filter.map_map, ‚Üê hright, hleft y‚ÇÄ, filter.map_map, key‚ÇÇ, ‚Üê hleft]\n      ‚ü©\n#align has_continuous_mul.of_nhds_one has_continuous_mul.of_nhds_one\n\n",
 "nhds_one_mul_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp, to_additive]\ntheorem nhds_one_mul_nhds {M} [mul_one_class M] [topological_space M] [has_continuous_mul M] (a : M) :\n    (nhds) (1 : M) * (nhds) a = (nhds) a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (one_mul a)).antisymm <| le_mul_of_one_le_left' <| pure_le_nhds 1\n#align nhds_one_mul_nhds nhds_one_mul_nhds\n\n",
 "nhds_mul_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp, to_additive]\ntheorem nhds_mul_nhds_one {M} [mul_one_class M] [topological_space M] [has_continuous_mul M] (a : M) :\n    (nhds) a * (nhds) 1 = (nhds) a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (mul_one a)).antisymm <| le_mul_of_one_le_right' <| pure_le_nhds 1\n#align nhds_mul_nhds_one nhds_mul_nhds_one\n\n",
 "mul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem filter.tendsto_nhds_within_Iio.mul_const [mul_pos_strict_mono ùïú] [MulPosReflectLT ùïú]\n    (h : tendsto f l (nhds_within.lt c)) : tendsto (fun a => f a * b) l (nhds_within.lt (c * b)) :=\n  tendsto_nhds_within_of_tendsto_nhds_of_eventually_within _ ((tendsto_nhds_of_tendsto_nhds_within h).mul_const b) <|\n    (tendsto_nhds_within_iff.mp h).2.mono fun j => (mul_lt_mul_right hb).mpr\n#align filter.tendsto_nhds_within_Iio.mul_const filter.tendsto_nhds_within_Iio.mul_const\n\n",
 "mul":
 "@[to_additive]\ntheorem is_compact.mul {s t : set M} (hs : is_compact s) (ht : is_compact t) : is_compact (s * t) :=\n  by\n  rw [‚Üê image_mul_prod]\n  exact (hs.prod ht).image continuous_mul\n#align is_compact.mul is_compact.mul\n\n",
 "mem_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem submonoid.mem_nhds_one (S : Submonoid M) (oS : is_open (S : set M)) : (S : set M) ‚àà (nhds) (1 : M) :=\n  is_open.mem_nhds oS S.one_mem\n#align submonoid.mem_nhds_one submonoid.mem_nhds_one\n\n",
 "le_topological_closure":
 "@[to_additive]\ntheorem submonoid.le_topological_closure (s : Submonoid M) : s ‚â§ s.topological_closure :=\n  subset_closure\n#align submonoid.le_topological_closure submonoid.le_topological_closure\n\n",
 "le_nhds_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem le_nhds_mul (a b : M) : (nhds) a * (nhds) b ‚â§ (nhds) (a * b) :=\n  by\n  rw [‚Üê map‚ÇÇ_mul, ‚Üê map_uncurry_prod, ‚Üê nhds_prod_eq]\n  exact continuous_mul.tendsto _\n#align le_nhds_mul le_nhds_mul\n\n",
 "is_closed_topological_closure":
 "@[to_additive]\ntheorem submonoid.is_closed_topological_closure (s : Submonoid M) : is_closed (s.topological_closure : set M) := by\n  convert is_closed_closure\n#align submonoid.is_closed_topological_closure submonoid.is_closed_topological_closure\n\n",
 "is_closed_set_of_map_one":
 "@[to_additive]\ntheorem is_closed_set_of_map_one [One M‚ÇÅ] [One M‚ÇÇ] : is_closed { f : M‚ÇÅ ‚Üí M‚ÇÇ | f 1 = 1 } :=\n  is_closed_eq (continuous_apply 1) continuous_const\n#align is_closed_set_of_map_one is_closed_set_of_map_one\n\n",
 "is_closed_set_of_map_mul":
 "@[to_additive]\ntheorem is_closed_set_of_map_mul [Mul M‚ÇÅ] [Mul M‚ÇÇ] [has_continuous_mul M‚ÇÇ] :\n    is_closed { f : M‚ÇÅ ‚Üí M‚ÇÇ | ‚àÄ x y, f (x * y) = f x * f y } :=\n  by\n  simp only [set_of_forall]\n  exact\n    is_closed_Inter fun x =>\n      is_closed_Inter fun y => is_closed_eq (continuous_apply _) ((continuous_apply _).mul (continuous_apply _))\n#align is_closed_set_of_map_mul is_closed_set_of_map_mul\n\n",
 "is_closed_range_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Üí* ¬ª -/\n@[to_additive]\ntheorem monoid_hom.is_closed_range_coe : is_closed (range (coe_fn : ¬´expr ‚Üí* ¬ª M‚ÇÅ M‚ÇÇ ‚Üí M‚ÇÅ ‚Üí M‚ÇÇ)) :=\n  is_closed_of_closure_subset fun f hf => ‚ü®monoid_hom_of_mem_closure_range_coe f hf, rfl‚ü©\n#align monoid_hom.is_closed_range_coe monoid_hom.is_closed_range_coe\n\n",
 "has_continuous_mul_of_comm_of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem has_continuous_mul_of_comm_of_nhds_one (M : Type u) [comm_monoid M] [topological_space M]\n    (hmul : tendsto (uncurry ((¬∑ * ¬∑) : M ‚Üí M ‚Üí M)) (filter.prod ((nhds) 1) ((nhds) 1)) ((nhds) 1))\n    (hleft : ‚àÄ x‚ÇÄ : M, (nhds) x‚ÇÄ = map (fun x => x‚ÇÄ * x) ((nhds) 1)) : has_continuous_mul M :=\n  by\n  apply has_continuous_mul.of_nhds_one hmul hleft\n  intro x‚ÇÄ\n  simp_rw [mul_comm, hleft x‚ÇÄ]\n#align has_continuous_mul_of_comm_of_nhds_one has_continuous_mul_of_comm_of_nhds_one\n\n",
 "has_continuous_mul_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ö , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª -/\n@[to_additive]\ntheorem has_continuous_mul_infi {ts : Œπ' ‚Üí topological_space M} (h' : ‚àÄ i, @has_continuous_mul M (ts i) _) :\n    @has_continuous_mul M\n      (¬´expr‚®Ö , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª\" (ts i)) _ :=\n  by\n  rw [‚Üê inf‚Çõ_range]\n  exact has_continuous_mul_Inf (set.forall_range_iff.mpr h')\n#align has_continuous_mul_infi has_continuous_mul_infi\n\n",
 "has_continuous_mul_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n@[to_additive]\ntheorem has_continuous_mul_inf {t‚ÇÅ t‚ÇÇ : topological_space M} (h‚ÇÅ : @has_continuous_mul M t‚ÇÅ _)\n    (h‚ÇÇ : @has_continuous_mul M t‚ÇÇ _) : @has_continuous_mul M (¬´expr ‚äì ¬ª t‚ÇÅ t‚ÇÇ) _ :=\n  by\n  rw [inf_eq_inf·µ¢]\n  refine' has_continuous_mul_infi fun b => _\n  cases b <;> assumption\n#align has_continuous_mul_inf has_continuous_mul_inf\n\n",
 "has_continuous_mul_induced":
 "@[to_additive]\ntheorem has_continuous_mul_induced {M N F : Type _} [Mul M] [Mul N] [MulHomClass F M N] [topological_space N]\n    [has_continuous_mul N] (f : F) : @has_continuous_mul M (induced f ‚Äπ_‚Ä∫) _ :=\n  letI := induced f ‚Äπ_‚Ä∫\n  inducing.has_continuous_mul f ‚ü®rfl‚ü©\n#align has_continuous_mul_induced has_continuous_mul_induced\n\n",
 "has_continuous_mul_Inf":
 "@[to_additive]\ntheorem has_continuous_mul_Inf {ts : set (topological_space M)} (h : ‚àÄ t ‚àà ts, @has_continuous_mul M t _) :\n    @has_continuous_mul M (inf‚Çõ ts) _ :=\n  {\n    continuous_mul :=\n      continuous_Inf_rng.2 fun t ht => continuous_Inf_dom‚ÇÇ ht ht (@has_continuous_mul.continuous_mul M t _ (h t ht)) }\n#align has_continuous_mul_Inf has_continuous_mul_Inf\n\n",
 "has_continuous_mul":
 "@[to_additive]\ntheorem inducing.has_continuous_mul {M N F : Type _} [Mul M] [Mul N] [MulHomClass F M N] [topological_space M]\n    [topological_space N] [has_continuous_mul N] (f : F) (hf : inducing f) : has_continuous_mul M :=\n  ‚ü®hf.continuous_iff.2 <| by simpa only [(¬∑ ‚àò ¬∑), map_mul f] using hf.continuous.fst'.mul hf.continuous.snd'‚ü©\n#align inducing.has_continuous_mul inducing.has_continuous_mul\n\n",
 "finprod_eventually_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem finprod_eventually_eq_prod {M : Type _} [comm_monoid M] {f : Œπ ‚Üí X ‚Üí M}\n    (hf : locally_finite fun i => mul_support (f i)) (x : X) :\n    ‚àÉ s : Finset Œπ,\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" ((nhds) x)\n        (finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (f i y) =\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n            (f i y)) :=\n  let ‚ü®I, hI‚ü© := hf.exists_finset_mul_support x\n  ‚ü®I, hI.mono fun y hy => finprod_eq_prod_of_mul_support_subset _ fun i hi => hy hi‚ü©\n#align finprod_eventually_eq_prod finprod_eventually_eq_prod\n\n",
 "exists_open_nhds_one_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive exists_open_nhds_zero_half]\ntheorem exists_open_nhds_one_split {s : set M} (hs : s ‚àà (nhds) (1 : M)) :\n    ‚àÉ V : set M, is_open V ‚àß (1 : M) ‚àà V ‚àß ‚àÄ v ‚àà V, ‚àÄ w ‚àà V, v * w ‚àà s :=\n  by\n  have : ¬´expr ‚Åª¬π' ¬ª (fun a : M √ó M => a.1 * a.2) s ‚àà (nhds) ((1, 1) : M √ó M) :=\n    tendsto_mul (by simpa only [one_mul] using hs)\n  simpa only [prod_subset_iff] using exists_nhds_square this\n#align exists_open_nhds_one_split exists_open_nhds_one_split\n\n",
 "exists_open_nhds_one_mul_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `VV ‚äÜ U`. -/\n@[to_additive \"Given a open neighborhood `U` of `0` there is a open neighborhood `V` of `0`\\n  such that `V + V ‚äÜ U`.\"]\ntheorem exists_open_nhds_one_mul_subset {U : set M} (hU : U ‚àà (nhds) (1 : M)) :\n    ‚àÉ V : set M, is_open V ‚àß (1 : M) ‚àà V ‚àß V * V ‚äÜ U :=\n  by\n  rcases exists_open_nhds_one_split hU with ‚ü®V, Vo, V1, hV‚ü©\n  use V, Vo, V1\n  rintro _ ‚ü®x, y, hx, hy, rfl‚ü©\n  exact hV _ hx _ hy\n#align exists_open_nhds_one_mul_subset exists_open_nhds_one_mul_subset\n\n",
 "exists_nhds_one_split4":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive exists_nhds_zero_quarter]\ntheorem exists_nhds_one_split4 {u : set M} (hu : u ‚àà (nhds) (1 : M)) :\n    ‚àÉ V ‚àà (nhds) (1 : M), ‚àÄ {v w s t}, v ‚àà V ‚Üí w ‚àà V ‚Üí s ‚àà V ‚Üí t ‚àà V ‚Üí v * w * s * t ‚àà u :=\n  by\n  rcases exists_nhds_one_split hu with ‚ü®W, W1, h‚ü©\n  rcases exists_nhds_one_split W1 with ‚ü®V, V1, h'‚ü©\n  use V, V1\n  intro v w s t v_in w_in s_in t_in\n  simpa only [mul_assoc] using h _ (h' v v_in w w_in) _ (h' s s_in t t_in)\n#align exists_nhds_one_split4 exists_nhds_one_split4\n\n",
 "exists_nhds_one_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive exists_nhds_zero_half]\ntheorem exists_nhds_one_split {s : set M} (hs : s ‚àà (nhds) (1 : M)) :\n    ‚àÉ V ‚àà (nhds) (1 : M), ‚àÄ v ‚àà V, ‚àÄ w ‚àà V, v * w ‚àà s :=\n  let ‚ü®V, Vo, V1, hV‚ü© := exists_open_nhds_one_split hs\n  ‚ü®V, is_open.mem_nhds Vo V1, hV‚ü©\n#align exists_nhds_one_split exists_nhds_one_split\n\n",
 "exists_finset_mul_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem locally_finite.exists_finset_mul_support {M : Type _} [comm_monoid M] {f : Œπ ‚Üí X ‚Üí M}\n    (hf : locally_finite fun i => mul_support <| f i) (x‚ÇÄ : X) :\n    ‚àÉ I : Finset Œπ,\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n        ((nhds) x‚ÇÄ) ((mul_support fun i => f i x) ‚äÜ I) :=\n  by\n  rcases hf x‚ÇÄ with ‚ü®U, hxU, hUf‚ü©\n  refine' ‚ü®hUf.to_finset, mem_of_superset hxU fun y hy i hi => _‚ü©\n  rw [hUf.coe_to_finset]\n  exact ‚ü®y, hi, hy‚ü©\n#align locally_finite.exists_finset_mul_support locally_finite.exists_finset_mul_support\n\n",
 "eventually_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr =·∂†[ ] ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr =·∂†[ ] ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem eventually_eq_prod {X M : Type _} [comm_monoid M] {s : Finset Œπ} {l : filter X} {f g : Œπ ‚Üí X ‚Üí M}\n    (hs : ‚àÄ i ‚àà s, ¬´expr =·∂†[ ] ¬ª (f i) l (g i)) :\n    ¬´expr =·∂†[ ] ¬ª\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) l\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g i)) :=\n  by\n  replace hs :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" l\n      (‚àÄ i ‚àà s, f i x = g i x)\n  ¬∑ rwa [eventually_all_finset]\n  filter_upwards [hs] with x hx\n  simp only [finset.prod_apply, finset.prod_congr rfl hx]\n#align eventually_eq_prod eventually_eq_prod\n\n",
 "continuous_pow":
 "@[continuity, to_additive]\ntheorem continuous_pow : ‚àÄ n : ‚Ñï, continuous fun a : M => a ^ n\n  | 0 => by simpa using continuous_const\n  | k + 1 => by\n    simp only [pow_succ]\n    exact continuous_id.mul (continuous_pow _)\n#align continuous_pow continuous_pow\n\n",
 "continuous_one":
 "/-\nCopyright (c) 2017 Johannes H√∂lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes H√∂lzl, Mario Carneiro\n-/\n@[to_additive]\ntheorem continuous_one [topological_space M] [One M] : continuous (1 : X ‚Üí M) :=\n  @continuous_const _ _ _ _ 1\n#align continuous_one continuous_one\n\n",
 "continuous_on_pow":
 "@[to_additive]\ntheorem continuous_on_pow {s : set M} (n : ‚Ñï) : continuous_on (fun x => x ^ n) s :=\n  (continuous_pow n).continuous_on\n#align continuous_on_pow continuous_on_pow\n\n",
 "continuous_on_multiset_prod":
 "@[to_additive]\ntheorem continuous_on_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : set X} :\n    (‚àÄ i ‚àà s, continuous_on (f i) t) ‚Üí continuous_on (fun a => (s.map fun i => f i a).prod) t :=\n  by\n  rcases s with ‚ü®l‚ü©\n  simpa using continuous_on_list_prod l\n#align continuous_on_multiset_prod continuous_on_multiset_prod\n\n",
 "continuous_on_list_prod":
 "@[to_additive]\ntheorem continuous_on_list_prod {f : Œπ ‚Üí X ‚Üí M} (l : list Œπ) {t : set X} (h : ‚àÄ i ‚àà l, continuous_on (f i) t) :\n    continuous_on (fun a => (l.map fun i => f i a).prod) t :=\n  by\n  intro x hx\n  rw [continuous_within_at_iff_continuous_at_restrict _ hx]\n  refine' tendsto_list_prod _ fun i hi => _\n  specialize h i hi x hx\n  rw [continuous_within_at_iff_continuous_at_restrict _ hx] at h\n  exact h\n#align continuous_on_list_prod continuous_on_list_prod\n\n",
 "continuous_on_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem continuous_on_finset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Finset Œπ) {t : set X} :\n    (‚àÄ i ‚àà s, continuous_on (f i) t) ‚Üí\n      continuous_on\n        (fun a =>\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a))\n        t :=\n  continuous_on_multiset_prod _\n#align continuous_on_finset_prod continuous_on_finset_prod\n\n",
 "continuous_multiset_prod":
 "@[continuity, to_additive]\ntheorem continuous_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) :\n    (‚àÄ i ‚àà s, continuous (f i)) ‚Üí continuous fun a => (s.map fun i => f i a).prod :=\n  by\n  rcases s with ‚ü®l‚ü©\n  simpa using continuous_list_prod l\n#align continuous_multiset_prod continuous_multiset_prod\n\n",
 "continuous_mul_right":
 "@[to_additive]\ntheorem continuous_mul_right (a : M) : continuous fun b : M => b * a :=\n  continuous_id.mul continuous_const\n#align continuous_mul_right continuous_mul_right\n\n",
 "continuous_mul_left":
 "@[to_additive]\ntheorem continuous_mul_left (a : M) : continuous fun b : M => a * b :=\n  continuous_const.mul continuous_id\n#align continuous_mul_left continuous_mul_left\n\n",
 "continuous_mul":
 "@[to_additive]\ntheorem continuous_mul : continuous fun p : M √ó M => p.1 * p.2 :=\n  has_continuous_mul.continuous_mul\n#align continuous_mul continuous_mul\n\n",
 "continuous_list_prod":
 "@[to_additive]\ntheorem continuous_list_prod {f : Œπ ‚Üí X ‚Üí M} (l : list Œπ) (h : ‚àÄ i ‚àà l, continuous (f i)) :\n    continuous fun a => (l.map fun i => f i a).prod :=\n  continuous_iff_continuous_at.2 fun x => tendsto_list_prod l fun c hc => continuous_iff_continuous_at.1 (h c hc) x\n#align continuous_list_prod continuous_list_prod\n\n",
 "continuous_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[continuity, to_additive]\ntheorem continuous_finset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Finset Œπ) :\n    (‚àÄ i ‚àà s, continuous (f i)) ‚Üí\n      continuous fun a =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a) :=\n  continuous_multiset_prod _\n#align continuous_finset_prod continuous_finset_prod\n\n",
 "continuous_finprod_cond":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\n@[to_additive]\ntheorem continuous_finprod_cond {f : Œπ ‚Üí X ‚Üí M} {p : Œπ ‚Üí Prop} (hc : ‚àÄ i, p i ‚Üí continuous (f i))\n    (hf : locally_finite fun i => mul_support (f i)) :\n    continuous fun x =>\n      finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (f i x) :=\n  by\n  simp only [‚Üê finprod_subtype_eq_finprod_cond]\n  exact continuous_finprod (fun i => hc i i.2) (hf.comp_injective subtype.coe_injective)\n#align continuous_finprod_cond continuous_finprod_cond\n\n",
 "continuous_finprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\n@[to_additive]\ntheorem continuous_finprod {f : Œπ ‚Üí X ‚Üí M} (hc : ‚àÄ i, continuous (f i))\n    (hf : locally_finite fun i => mul_support (f i)) :\n    continuous fun x =>\n      finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (f i x) :=\n  by\n  refine' continuous_iff_continuous_at.2 fun x => _\n  rcases finprod_eventually_eq_prod hf x with ‚ü®s, hs‚ü©\n  refine' continuous_at.congr _ (eventually_eq.symm hs)\n  exact tendsto_finset_prod _ fun i hi => (hc i).continuous_at\n#align continuous_finprod continuous_finprod\n\n",
 "continuous_at_pow":
 "@[to_additive]\ntheorem continuous_at_pow (x : M) (n : ‚Ñï) : continuous_at (fun x => x ^ n) x :=\n  (continuous_pow n).continuous_at\n#align continuous_at_pow continuous_at_pow\n\n",
 "const_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem filter.tendsto_nhds_within_Iio.const_mul [pos_mul_strict_mono ùïú] [PosMulReflectLT ùïú]\n    (h : tendsto f l (nhds_within.lt c)) : tendsto (fun a => b * f a) l (nhds_within.lt (b * c)) :=\n  tendsto_nhds_within_of_tendsto_nhds_of_eventually_within _ ((tendsto_nhds_of_tendsto_nhds_within h).const_mul b) <|\n    (tendsto_nhds_within_iff.mp h).2.mono fun j => (mul_lt_mul_left hb).mpr\n#align filter.tendsto_nhds_within_Iio.const_mul filter.tendsto_nhds_within_Iio.const_mul\n\n"}