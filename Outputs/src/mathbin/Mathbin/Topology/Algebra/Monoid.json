{"units_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem continuous.units_map [monoid M] [monoid N] [topological_space M] [topological_space N] (f : «expr →* » M N)\n    (hf : continuous f) : continuous (Units.map f) :=\n  units.continuous_iff.2 ⟨hf.comp units.continuous_coe, hf.comp units.continuous_coe_inv⟩\n#align continuous.units_map continuous.units_map\n\n",
 "topological_closure_minimal":
 "@[to_additive]\ntheorem submonoid.topological_closure_minimal (s : Submonoid M) {t : Submonoid M} (h : s ≤ t)\n    (ht : is_closed (t : set M)) : s.topological_closure ≤ t :=\n  closure_minimal h ht\n#align submonoid.topological_closure_minimal submonoid.topological_closure_minimal\n\n",
 "top_closure_mul_self_subset":
 "@[to_additive]\ntheorem submonoid.top_closure_mul_self_subset (s : Submonoid M) : closure (s : set M) * closure s ⊆ closure s :=\n  image2_subset_iff.2 fun x hx y hy => map_mem_closure₂ continuous_mul hx hy fun a ha b hb => s.mul_mem ha hb\n#align submonoid.top_closure_mul_self_subset submonoid.top_closure_mul_self_subset\n\n",
 "top_closure_mul_self_eq":
 "@[to_additive]\ntheorem submonoid.top_closure_mul_self_eq (s : Submonoid M) : closure (s : set M) * closure s = closure s :=\n  Subset.antisymm s.top_closure_mul_self_subset fun x hx => ⟨x, 1, hx, subset_closure s.one_mem, mul_one _⟩\n#align submonoid.top_closure_mul_self_eq submonoid.top_closure_mul_self_eq\n\n",
 "tendsto_multiset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem tendsto_multiset_prod {f : ι → α → M} {x : filter α} {a : ι → M} (s : Multiset ι) :\n    (∀ i ∈ s, tendsto (f i) x ((nhds) (a i))) →\n      tendsto (fun b => (s.map fun c => f c b).prod) x ((nhds) (s.map a).prod) :=\n  by\n  rcases s with ⟨l⟩\n  simpa using tendsto_list_prod l\n#align tendsto_multiset_prod tendsto_multiset_prod\n\n",
 "tendsto_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem tendsto_mul {a b : M} : tendsto (fun p : M × M => p.fst * p.snd) ((nhds) (a, b)) ((nhds) (a * b)) :=\n  continuous_iff_continuous_at.mp has_continuous_mul.continuous_mul (a, b)\n#align tendsto_mul tendsto_mul\n\n",
 "tendsto_list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem tendsto_list_prod {f : ι → α → M} {x : filter α} {a : ι → M} :\n    ∀ l : list ι,\n      (∀ i ∈ l, tendsto (f i) x ((nhds) (a i))) →\n        tendsto (fun b => (l.map fun c => f c b).prod) x ((nhds) (l.map a).prod)\n  | [], _ => by simp [tendsto_const_nhds]\n  | sym.cons' f l, h => by\n    simp only [list.map_cons, List.prod_cons]\n    exact (h f (list.mem_cons_self _ _)).mul (tendsto_list_prod l fun c hc => h c (list.mem_cons_of_mem _ hc))\n#align tendsto_list_prod tendsto_list_prod\n\n",
 "tendsto_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem tendsto_finset_prod {f : ι → α → M} {x : filter α} {a : ι → M} (s : Finset ι) :\n    (∀ i ∈ s, tendsto (f i) x ((nhds) (a i))) →\n      tendsto\n        (fun b =>\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f c b))\n        x\n        ((nhds)\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n            (a c))) :=\n  tendsto_multiset_prod _\n#align tendsto_finset_prod tendsto_finset_prod\n\n",
 "tendsto_cocompact_mul_right":
 "/-- Right-multiplication by a right-invertible element of a topological monoid is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem filter.tendsto_cocompact_mul_right {a b : M} (ha : a * b = 1) :\n    filter.tendsto (fun x : M => x * a) (filter.cocompact M) (filter.cocompact M) :=\n  by\n  refine' filter.tendsto.of_tendsto_comp _ (filter.comap_cocompact_le (continuous_mul_right b))\n  convert filter.tendsto_id\n  ext x\n  simp [ha]\n#align filter.tendsto_cocompact_mul_right filter.tendsto_cocompact_mul_right\n\n",
 "tendsto_cocompact_mul_left":
 "/-- Left-multiplication by a left-invertible element of a topological monoid is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem filter.tendsto_cocompact_mul_left {a b : M} (ha : b * a = 1) :\n    filter.tendsto (fun x : M => a * x) (filter.cocompact M) (filter.cocompact M) :=\n  by\n  refine' filter.tendsto.of_tendsto_comp _ (filter.comap_cocompact_le (continuous_mul_left b))\n  convert filter.tendsto_id\n  ext x\n  simp [ha]\n#align filter.tendsto_cocompact_mul_left filter.tendsto_cocompact_mul_left\n\n",
 "pow":
 "@[to_additive continuous_on.nsmul]\ntheorem continuous_on.pow {f : X → M} {s : set X} (hf : continuous_on f s) (n : ℕ) :\n    continuous_on (fun x => f x ^ n) s := fun x hx => (hf x hx).pow n\n#align continuous_on.pow continuous_on.pow\n\n",
 "of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem has_continuous_mul.of_nhds_one {M : Type u} [monoid M] [topological_space M]\n    (hmul : tendsto (uncurry ((· * ·) : M → M → M)) (filter.prod ((nhds) 1) ((nhds) 1)) <| (nhds) 1)\n    (hleft : ∀ x₀ : M, (nhds) x₀ = map (fun x => x₀ * x) ((nhds) 1))\n    (hright : ∀ x₀ : M, (nhds) x₀ = map (fun x => x * x₀) ((nhds) 1)) : has_continuous_mul M :=\n  ⟨by\n    rw [continuous_iff_continuous_at]\n    rintro ⟨x₀, y₀⟩\n    have key : (fun p : M × M => x₀ * p.1 * (p.2 * y₀)) = ((fun x => x₀ * x) ∘ fun x => x * y₀) ∘ uncurry (· * ·) :=\n      by\n      ext p\n      simp [uncurry, mul_assoc]\n    have key₂ : ((fun x => x₀ * x) ∘ fun x => y₀ * x) = fun x => x₀ * y₀ * x :=\n      by\n      ext x\n      simp\n    calc\n      map (uncurry (· * ·)) ((nhds) (x₀, y₀)) = map (uncurry (· * ·)) (filter.prod ((nhds) x₀) ((nhds) y₀)) := by\n        rw [nhds_prod_eq]\n      _ = map (fun p : M × M => x₀ * p.1 * (p.2 * y₀)) (filter.prod ((nhds) 1) ((nhds) 1)) := by\n        rw [uncurry, hleft x₀, hright y₀, prod_map_map_eq, filter.map_map]\n      _ = map ((fun x => x₀ * x) ∘ fun x => x * y₀) (map (uncurry (· * ·)) (filter.prod ((nhds) 1) ((nhds) 1))) := by\n        rw [key, ← filter.map_map]\n      _ ≤ map ((fun x : M => x₀ * x) ∘ fun x => x * y₀) ((nhds) 1) := map_mono hmul\n      _ = (nhds) (x₀ * y₀) := by rw [← filter.map_map, ← hright, hleft y₀, filter.map_map, key₂, ← hleft]\n      ⟩\n#align has_continuous_mul.of_nhds_one has_continuous_mul.of_nhds_one\n\n",
 "nhds_one_mul_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp, to_additive]\ntheorem nhds_one_mul_nhds {M} [mul_one_class M] [topological_space M] [has_continuous_mul M] (a : M) :\n    (nhds) (1 : M) * (nhds) a = (nhds) a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (one_mul a)).antisymm <| le_mul_of_one_le_left' <| pure_le_nhds 1\n#align nhds_one_mul_nhds nhds_one_mul_nhds\n\n",
 "nhds_mul_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp, to_additive]\ntheorem nhds_mul_nhds_one {M} [mul_one_class M] [topological_space M] [has_continuous_mul M] (a : M) :\n    (nhds) a * (nhds) 1 = (nhds) a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (mul_one a)).antisymm <| le_mul_of_one_le_right' <| pure_le_nhds 1\n#align nhds_mul_nhds_one nhds_mul_nhds_one\n\n",
 "mul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem filter.tendsto_nhds_within_Iio.mul_const [mul_pos_strict_mono 𝕜] [MulPosReflectLT 𝕜]\n    (h : tendsto f l (nhds_within.lt c)) : tendsto (fun a => f a * b) l (nhds_within.lt (c * b)) :=\n  tendsto_nhds_within_of_tendsto_nhds_of_eventually_within _ ((tendsto_nhds_of_tendsto_nhds_within h).mul_const b) <|\n    (tendsto_nhds_within_iff.mp h).2.mono fun j => (mul_lt_mul_right hb).mpr\n#align filter.tendsto_nhds_within_Iio.mul_const filter.tendsto_nhds_within_Iio.mul_const\n\n",
 "mul":
 "@[to_additive]\ntheorem is_compact.mul {s t : set M} (hs : is_compact s) (ht : is_compact t) : is_compact (s * t) :=\n  by\n  rw [← image_mul_prod]\n  exact (hs.prod ht).image continuous_mul\n#align is_compact.mul is_compact.mul\n\n",
 "mem_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem submonoid.mem_nhds_one (S : Submonoid M) (oS : is_open (S : set M)) : (S : set M) ∈ (nhds) (1 : M) :=\n  is_open.mem_nhds oS S.one_mem\n#align submonoid.mem_nhds_one submonoid.mem_nhds_one\n\n",
 "le_topological_closure":
 "@[to_additive]\ntheorem submonoid.le_topological_closure (s : Submonoid M) : s ≤ s.topological_closure :=\n  subset_closure\n#align submonoid.le_topological_closure submonoid.le_topological_closure\n\n",
 "le_nhds_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem le_nhds_mul (a b : M) : (nhds) a * (nhds) b ≤ (nhds) (a * b) :=\n  by\n  rw [← map₂_mul, ← map_uncurry_prod, ← nhds_prod_eq]\n  exact continuous_mul.tendsto _\n#align le_nhds_mul le_nhds_mul\n\n",
 "is_closed_topological_closure":
 "@[to_additive]\ntheorem submonoid.is_closed_topological_closure (s : Submonoid M) : is_closed (s.topological_closure : set M) := by\n  convert is_closed_closure\n#align submonoid.is_closed_topological_closure submonoid.is_closed_topological_closure\n\n",
 "is_closed_set_of_map_one":
 "@[to_additive]\ntheorem is_closed_set_of_map_one [One M₁] [One M₂] : is_closed { f : M₁ → M₂ | f 1 = 1 } :=\n  is_closed_eq (continuous_apply 1) continuous_const\n#align is_closed_set_of_map_one is_closed_set_of_map_one\n\n",
 "is_closed_set_of_map_mul":
 "@[to_additive]\ntheorem is_closed_set_of_map_mul [Mul M₁] [Mul M₂] [has_continuous_mul M₂] :\n    is_closed { f : M₁ → M₂ | ∀ x y, f (x * y) = f x * f y } :=\n  by\n  simp only [set_of_forall]\n  exact\n    is_closed_Inter fun x =>\n      is_closed_Inter fun y => is_closed_eq (continuous_apply _) ((continuous_apply _).mul (continuous_apply _))\n#align is_closed_set_of_map_mul is_closed_set_of_map_mul\n\n",
 "is_closed_range_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem monoid_hom.is_closed_range_coe : is_closed (range (coe_fn : «expr →* » M₁ M₂ → M₁ → M₂)) :=\n  is_closed_of_closure_subset fun f hf => ⟨monoid_hom_of_mem_closure_range_coe f hf, rfl⟩\n#align monoid_hom.is_closed_range_coe monoid_hom.is_closed_range_coe\n\n",
 "has_continuous_mul_of_comm_of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem has_continuous_mul_of_comm_of_nhds_one (M : Type u) [comm_monoid M] [topological_space M]\n    (hmul : tendsto (uncurry ((· * ·) : M → M → M)) (filter.prod ((nhds) 1) ((nhds) 1)) ((nhds) 1))\n    (hleft : ∀ x₀ : M, (nhds) x₀ = map (fun x => x₀ * x) ((nhds) 1)) : has_continuous_mul M :=\n  by\n  apply has_continuous_mul.of_nhds_one hmul hleft\n  intro x₀\n  simp_rw [mul_comm, hleft x₀]\n#align has_continuous_mul_of_comm_of_nhds_one has_continuous_mul_of_comm_of_nhds_one\n\n",
 "has_continuous_mul_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[to_additive]\ntheorem has_continuous_mul_infi {ts : ι' → topological_space M} (h' : ∀ i, @has_continuous_mul M (ts i) _) :\n    @has_continuous_mul M\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (ts i)) _ :=\n  by\n  rw [← infₛ_range]\n  exact has_continuous_mul_Inf (set.forall_range_iff.mpr h')\n#align has_continuous_mul_infi has_continuous_mul_infi\n\n",
 "has_continuous_mul_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem has_continuous_mul_inf {t₁ t₂ : topological_space M} (h₁ : @has_continuous_mul M t₁ _)\n    (h₂ : @has_continuous_mul M t₂ _) : @has_continuous_mul M («expr ⊓ » t₁ t₂) _ :=\n  by\n  rw [inf_eq_infᵢ]\n  refine' has_continuous_mul_infi fun b => _\n  cases b <;> assumption\n#align has_continuous_mul_inf has_continuous_mul_inf\n\n",
 "has_continuous_mul_induced":
 "@[to_additive]\ntheorem has_continuous_mul_induced {M N F : Type _} [Mul M] [Mul N] [MulHomClass F M N] [topological_space N]\n    [has_continuous_mul N] (f : F) : @has_continuous_mul M (induced f ‹_›) _ :=\n  letI := induced f ‹_›\n  inducing.has_continuous_mul f ⟨rfl⟩\n#align has_continuous_mul_induced has_continuous_mul_induced\n\n",
 "has_continuous_mul_Inf":
 "@[to_additive]\ntheorem has_continuous_mul_Inf {ts : set (topological_space M)} (h : ∀ t ∈ ts, @has_continuous_mul M t _) :\n    @has_continuous_mul M (infₛ ts) _ :=\n  {\n    continuous_mul :=\n      continuous_Inf_rng.2 fun t ht => continuous_Inf_dom₂ ht ht (@has_continuous_mul.continuous_mul M t _ (h t ht)) }\n#align has_continuous_mul_Inf has_continuous_mul_Inf\n\n",
 "has_continuous_mul":
 "@[to_additive]\ntheorem inducing.has_continuous_mul {M N F : Type _} [Mul M] [Mul N] [MulHomClass F M N] [topological_space M]\n    [topological_space N] [has_continuous_mul N] (f : F) (hf : inducing f) : has_continuous_mul M :=\n  ⟨hf.continuous_iff.2 <| by simpa only [(· ∘ ·), map_mul f] using hf.continuous.fst'.mul hf.continuous.snd'⟩\n#align inducing.has_continuous_mul inducing.has_continuous_mul\n\n",
 "finprod_eventually_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem finprod_eventually_eq_prod {M : Type _} [comm_monoid M] {f : ι → X → M}\n    (hf : locally_finite fun i => mul_support (f i)) (x : X) :\n    ∃ s : Finset ι,\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n        (finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (f i y) =\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n            (f i y)) :=\n  let ⟨I, hI⟩ := hf.exists_finset_mul_support x\n  ⟨I, hI.mono fun y hy => finprod_eq_prod_of_mul_support_subset _ fun i hi => hy hi⟩\n#align finprod_eventually_eq_prod finprod_eventually_eq_prod\n\n",
 "exists_open_nhds_one_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive exists_open_nhds_zero_half]\ntheorem exists_open_nhds_one_split {s : set M} (hs : s ∈ (nhds) (1 : M)) :\n    ∃ V : set M, is_open V ∧ (1 : M) ∈ V ∧ ∀ v ∈ V, ∀ w ∈ V, v * w ∈ s :=\n  by\n  have : «expr ⁻¹' » (fun a : M × M => a.1 * a.2) s ∈ (nhds) ((1, 1) : M × M) :=\n    tendsto_mul (by simpa only [one_mul] using hs)\n  simpa only [prod_subset_iff] using exists_nhds_square this\n#align exists_open_nhds_one_split exists_open_nhds_one_split\n\n",
 "exists_open_nhds_one_mul_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `VV ⊆ U`. -/\n@[to_additive \"Given a open neighborhood `U` of `0` there is a open neighborhood `V` of `0`\\n  such that `V + V ⊆ U`.\"]\ntheorem exists_open_nhds_one_mul_subset {U : set M} (hU : U ∈ (nhds) (1 : M)) :\n    ∃ V : set M, is_open V ∧ (1 : M) ∈ V ∧ V * V ⊆ U :=\n  by\n  rcases exists_open_nhds_one_split hU with ⟨V, Vo, V1, hV⟩\n  use V, Vo, V1\n  rintro _ ⟨x, y, hx, hy, rfl⟩\n  exact hV _ hx _ hy\n#align exists_open_nhds_one_mul_subset exists_open_nhds_one_mul_subset\n\n",
 "exists_nhds_one_split4":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive exists_nhds_zero_quarter]\ntheorem exists_nhds_one_split4 {u : set M} (hu : u ∈ (nhds) (1 : M)) :\n    ∃ V ∈ (nhds) (1 : M), ∀ {v w s t}, v ∈ V → w ∈ V → s ∈ V → t ∈ V → v * w * s * t ∈ u :=\n  by\n  rcases exists_nhds_one_split hu with ⟨W, W1, h⟩\n  rcases exists_nhds_one_split W1 with ⟨V, V1, h'⟩\n  use V, V1\n  intro v w s t v_in w_in s_in t_in\n  simpa only [mul_assoc] using h _ (h' v v_in w w_in) _ (h' s s_in t t_in)\n#align exists_nhds_one_split4 exists_nhds_one_split4\n\n",
 "exists_nhds_one_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive exists_nhds_zero_half]\ntheorem exists_nhds_one_split {s : set M} (hs : s ∈ (nhds) (1 : M)) :\n    ∃ V ∈ (nhds) (1 : M), ∀ v ∈ V, ∀ w ∈ V, v * w ∈ s :=\n  let ⟨V, Vo, V1, hV⟩ := exists_open_nhds_one_split hs\n  ⟨V, is_open.mem_nhds Vo V1, hV⟩\n#align exists_nhds_one_split exists_nhds_one_split\n\n",
 "exists_finset_mul_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem locally_finite.exists_finset_mul_support {M : Type _} [comm_monoid M] {f : ι → X → M}\n    (hf : locally_finite fun i => mul_support <| f i) (x₀ : X) :\n    ∃ I : Finset ι,\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        ((nhds) x₀) ((mul_support fun i => f i x) ⊆ I) :=\n  by\n  rcases hf x₀ with ⟨U, hxU, hUf⟩\n  refine' ⟨hUf.to_finset, mem_of_superset hxU fun y hy i hi => _⟩\n  rw [hUf.coe_to_finset]\n  exact ⟨y, hi, hy⟩\n#align locally_finite.exists_finset_mul_support locally_finite.exists_finset_mul_support\n\n",
 "eventually_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem eventually_eq_prod {X M : Type _} [comm_monoid M] {s : Finset ι} {l : filter X} {f g : ι → X → M}\n    (hs : ∀ i ∈ s, «expr =ᶠ[ ] » (f i) l (g i)) :\n    «expr =ᶠ[ ] »\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) l\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g i)) :=\n  by\n  replace hs :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (∀ i ∈ s, f i x = g i x)\n  · rwa [eventually_all_finset]\n  filter_upwards [hs] with x hx\n  simp only [finset.prod_apply, finset.prod_congr rfl hx]\n#align eventually_eq_prod eventually_eq_prod\n\n",
 "continuous_pow":
 "@[continuity, to_additive]\ntheorem continuous_pow : ∀ n : ℕ, continuous fun a : M => a ^ n\n  | 0 => by simpa using continuous_const\n  | k + 1 => by\n    simp only [pow_succ]\n    exact continuous_id.mul (continuous_pow _)\n#align continuous_pow continuous_pow\n\n",
 "continuous_one":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\n@[to_additive]\ntheorem continuous_one [topological_space M] [One M] : continuous (1 : X → M) :=\n  @continuous_const _ _ _ _ 1\n#align continuous_one continuous_one\n\n",
 "continuous_on_pow":
 "@[to_additive]\ntheorem continuous_on_pow {s : set M} (n : ℕ) : continuous_on (fun x => x ^ n) s :=\n  (continuous_pow n).continuous_on\n#align continuous_on_pow continuous_on_pow\n\n",
 "continuous_on_multiset_prod":
 "@[to_additive]\ntheorem continuous_on_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : set X} :\n    (∀ i ∈ s, continuous_on (f i) t) → continuous_on (fun a => (s.map fun i => f i a).prod) t :=\n  by\n  rcases s with ⟨l⟩\n  simpa using continuous_on_list_prod l\n#align continuous_on_multiset_prod continuous_on_multiset_prod\n\n",
 "continuous_on_list_prod":
 "@[to_additive]\ntheorem continuous_on_list_prod {f : ι → X → M} (l : list ι) {t : set X} (h : ∀ i ∈ l, continuous_on (f i) t) :\n    continuous_on (fun a => (l.map fun i => f i a).prod) t :=\n  by\n  intro x hx\n  rw [continuous_within_at_iff_continuous_at_restrict _ hx]\n  refine' tendsto_list_prod _ fun i hi => _\n  specialize h i hi x hx\n  rw [continuous_within_at_iff_continuous_at_restrict _ hx] at h\n  exact h\n#align continuous_on_list_prod continuous_on_list_prod\n\n",
 "continuous_on_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem continuous_on_finset_prod {f : ι → X → M} (s : Finset ι) {t : set X} :\n    (∀ i ∈ s, continuous_on (f i) t) →\n      continuous_on\n        (fun a =>\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a))\n        t :=\n  continuous_on_multiset_prod _\n#align continuous_on_finset_prod continuous_on_finset_prod\n\n",
 "continuous_multiset_prod":
 "@[continuity, to_additive]\ntheorem continuous_multiset_prod {f : ι → X → M} (s : Multiset ι) :\n    (∀ i ∈ s, continuous (f i)) → continuous fun a => (s.map fun i => f i a).prod :=\n  by\n  rcases s with ⟨l⟩\n  simpa using continuous_list_prod l\n#align continuous_multiset_prod continuous_multiset_prod\n\n",
 "continuous_mul_right":
 "@[to_additive]\ntheorem continuous_mul_right (a : M) : continuous fun b : M => b * a :=\n  continuous_id.mul continuous_const\n#align continuous_mul_right continuous_mul_right\n\n",
 "continuous_mul_left":
 "@[to_additive]\ntheorem continuous_mul_left (a : M) : continuous fun b : M => a * b :=\n  continuous_const.mul continuous_id\n#align continuous_mul_left continuous_mul_left\n\n",
 "continuous_mul":
 "@[to_additive]\ntheorem continuous_mul : continuous fun p : M × M => p.1 * p.2 :=\n  has_continuous_mul.continuous_mul\n#align continuous_mul continuous_mul\n\n",
 "continuous_list_prod":
 "@[to_additive]\ntheorem continuous_list_prod {f : ι → X → M} (l : list ι) (h : ∀ i ∈ l, continuous (f i)) :\n    continuous fun a => (l.map fun i => f i a).prod :=\n  continuous_iff_continuous_at.2 fun x => tendsto_list_prod l fun c hc => continuous_iff_continuous_at.1 (h c hc) x\n#align continuous_list_prod continuous_list_prod\n\n",
 "continuous_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[continuity, to_additive]\ntheorem continuous_finset_prod {f : ι → X → M} (s : Finset ι) :\n    (∀ i ∈ s, continuous (f i)) →\n      continuous fun a =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a) :=\n  continuous_multiset_prod _\n#align continuous_finset_prod continuous_finset_prod\n\n",
 "continuous_finprod_cond":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\n@[to_additive]\ntheorem continuous_finprod_cond {f : ι → X → M} {p : ι → Prop} (hc : ∀ i, p i → continuous (f i))\n    (hf : locally_finite fun i => mul_support (f i)) :\n    continuous fun x =>\n      finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (f i x) :=\n  by\n  simp only [← finprod_subtype_eq_finprod_cond]\n  exact continuous_finprod (fun i => hc i i.2) (hf.comp_injective subtype.coe_injective)\n#align continuous_finprod_cond continuous_finprod_cond\n\n",
 "continuous_finprod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finprod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod -/\n@[to_additive]\ntheorem continuous_finprod {f : ι → X → M} (hc : ∀ i, continuous (f i))\n    (hf : locally_finite fun i => mul_support (f i)) :\n    continuous fun x =>\n      finprod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finprod\" (f i x) :=\n  by\n  refine' continuous_iff_continuous_at.2 fun x => _\n  rcases finprod_eventually_eq_prod hf x with ⟨s, hs⟩\n  refine' continuous_at.congr _ (eventually_eq.symm hs)\n  exact tendsto_finset_prod _ fun i hi => (hc i).continuous_at\n#align continuous_finprod continuous_finprod\n\n",
 "continuous_at_pow":
 "@[to_additive]\ntheorem continuous_at_pow (x : M) (n : ℕ) : continuous_at (fun x => x ^ n) x :=\n  (continuous_pow n).continuous_at\n#align continuous_at_pow continuous_at_pow\n\n",
 "const_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem filter.tendsto_nhds_within_Iio.const_mul [pos_mul_strict_mono 𝕜] [PosMulReflectLT 𝕜]\n    (h : tendsto f l (nhds_within.lt c)) : tendsto (fun a => b * f a) l (nhds_within.lt (b * c)) :=\n  tendsto_nhds_within_of_tendsto_nhds_of_eventually_within _ ((tendsto_nhds_of_tendsto_nhds_within h).const_mul b) <|\n    (tendsto_nhds_within_iff.mp h).2.mono fun j => (mul_lt_mul_left hb).mpr\n#align filter.tendsto_nhds_within_Iio.const_mul filter.tendsto_nhds_within_Iio.const_mul\n\n"}