{"units_topology_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-\nCopyright (c) 2021 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Scott Morrison\n-/\ntheorem units_topology_eq [induced_units R] : ‹topological_space («expr ˣ» R)› = induced (coe : «expr ˣ» R → R) ‹_› :=\n  induced_units.top_eq\n#align units_topology_eq units_topology_eq\n\n",
 "units_top_group":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem units_top_group : topological_group («expr ˣ» K) :=\n  { topological_ring.top_monoid_units K with\n    continuous_inv := by\n      rw [continuous_iff_continuous_at]\n      intro x\n      rw [continuous_at, nhds_induced, nhds_induced, tendsto_iff_comap, ←\n        function.semiconj.filter_comap Units.val_inv_eq_inv_val _]\n      apply comap_mono\n      rw [← tendsto_iff_comap, Units.val_inv_eq_inv_val]\n      exact continuous_at_inv₀ x.ne_zero }\n#align units_top_group units_top_group\n\n",
 "units_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem units_embedding [induced_units R] : embedding (coe : «expr ˣ» R → R) :=\n  { induced := units_topology_eq R\n    inj := fun x y h => Units.ext h }\n#align units_embedding units_embedding\n\n",
 "topological_closure_minimal":
 "theorem subfield.topological_closure_minimal (s : subfield α) {t : subfield α} (h : s ≤ t)\n    (ht : is_closed (t : set α)) : s.topological_closure ≤ t :=\n  closure_minimal h ht\n#align subfield.topological_closure_minimal subfield.topological_closure_minimal\n\n",
 "tendsto_cocompact_mul_right₀":
 "/-- Right-multiplication by a nonzero element of a topological division ring is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem filter.tendsto_cocompact_mul_right₀ [has_continuous_mul K] {a : K} (ha : a ≠ 0) :\n    filter.tendsto (fun x : K => x * a) (filter.cocompact K) (filter.cocompact K) :=\n  filter.tendsto_cocompact_mul_right (mul_inv_cancel ha)\n#align filter.tendsto_cocompact_mul_right₀ filter.tendsto_cocompact_mul_right₀\n\n",
 "tendsto_cocompact_mul_left₀":
 "/-- Left-multiplication by a nonzero element of a topological division ring is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem filter.tendsto_cocompact_mul_left₀ [has_continuous_mul K] {a : K} (ha : a ≠ 0) :\n    filter.tendsto (fun x : K => a * x) (filter.cocompact K) (filter.cocompact K) :=\n  filter.tendsto_cocompact_mul_left (inv_mul_cancel ha)\n#align filter.tendsto_cocompact_mul_left₀ filter.tendsto_cocompact_mul_left₀\n\n",
 "le_topological_closure":
 "theorem subfield.le_topological_closure (s : subfield α) : s ≤ s.topological_closure :=\n  subset_closure\n#align subfield.le_topological_closure subfield.le_topological_closure\n\n",
 "is_closed_topological_closure":
 "theorem subfield.is_closed_topological_closure (s : subfield α) : is_closed (s.topological_closure : set α) :=\n  is_closed_closure\n#align subfield.is_closed_topological_closure subfield.is_closed_topological_closure\n\n",
 "inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_local_min.inv {f : α → β} {a : α} (h1 : is_local_min f a)\n    (h2 :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (0 < f z)) :\n    is_local_max f⁻¹ a := by filter_upwards [h1, h2] with z h3 h4 using(inv_le_inv h4 h2.self_of_nhds).mpr h3\n#align is_local_min.inv is_local_min.inv\n\n",
 "eq_or_eq_neg_of_sq_eq":
 "/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then either `f = g` or `f = -g` on\n`S`. -/\ntheorem is_preconnected.eq_or_eq_neg_of_sq_eq [Field 𝕜] [has_continuous_inv₀ 𝕜] [has_continuous_mul 𝕜]\n    (hS : is_preconnected S) (hf : continuous_on f S) (hg : continuous_on g S) (hsq : EqOn (f ^ 2) (g ^ 2) S)\n    (hg_ne : ∀ {x : α}, x ∈ S → g x ≠ 0) : EqOn f g S ∨ EqOn f (-g) S :=\n  by\n  rcases hS.eq_one_or_eq_neg_one_of_sq_eq (hf.div hg fun z hz => hg_ne hz) fun x hx => _ with (h | h)\n  · refine' or.inl fun x hx => _\n    rw [← div_eq_one_iff_eq (hg_ne hx)]\n    exact h hx\n  · refine' or.inr fun x hx => _\n    specialize h hx\n    rwa [pi.div_apply, pi.neg_apply, pi.one_apply, div_eq_iff (hg_ne hx), neg_one_mul] at h\n  · rw [pi.one_apply, div_pow, pi.div_apply, hsq hx, div_self]\n    exact pow_ne_zero _ (hg_ne hx)\n#align is_preconnected.eq_or_eq_neg_of_sq_eq is_preconnected.eq_or_eq_neg_of_sq_eq\n\n",
 "eq_one_or_eq_neg_one_of_sq_eq":
 "/-- If `f` is a function `α → 𝕜` which is continuous on a preconnected set `S`, and\n`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. -/\ntheorem is_preconnected.eq_one_or_eq_neg_one_of_sq_eq [Ring 𝕜] [no_zero_divisors 𝕜] (hS : is_preconnected S)\n    (hf : continuous_on f S) (hsq : EqOn (f ^ 2) 1 S) : EqOn f 1 S ∨ EqOn f (-1) S :=\n  by\n  simp_rw [eq_on, pi.one_apply, pi.pow_apply, sq_eq_one_iff] at hsq\n  -- First deal with crazy case where `S` is empty.\n  by_cases hSe : ∀ x : α, x ∉ S\n  · left\n    intro x hx\n    exfalso\n    exact hSe x hx\n  push_neg  at hSe\n  choose y hy using hSe\n  suffices ∀ x : α, x ∈ S → f x = f y by\n    rcases hsq hy with ⟨⟩\n    · left\n      intro z hz\n      rw [pi.one_apply z, ← h]\n      exact this z hz\n    · right\n      intro z hz\n      rw [pi.neg_apply, pi.one_apply, ← h]\n      exact this z hz\n  refine' fun x hx => hS.constant_of_maps_to hf (fun z hz => _) hx hy\n  show f z ∈ ({-1, 1} : set 𝕜)\n  · exact mem_insert_iff.mpr (hsq hz).symm\n  exact discrete_of_t1_of_finite\n#align is_preconnected.eq_one_or_eq_neg_one_of_sq_eq is_preconnected.eq_one_or_eq_neg_one_of_sq_eq\n\n",
 "eq_of_sq_eq":
 "/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem is_preconnected.eq_of_sq_eq [Field 𝕜] [has_continuous_inv₀ 𝕜] [has_continuous_mul 𝕜] (hS : is_preconnected S)\n    (hf : continuous_on f S) (hg : continuous_on g S) (hsq : EqOn (f ^ 2) (g ^ 2) S)\n    (hg_ne : ∀ {x : α}, x ∈ S → g x ≠ 0) {y : α} (hy : y ∈ S) (hy' : f y = g y) : EqOn f g S := fun x hx =>\n  by\n  rcases hS.eq_or_eq_neg_of_sq_eq hf hg @hsq @hg_ne with (h | h)\n  · exact h hx\n  · rw [h hy, eq_comm, ← sub_eq_zero, sub_eq_add_neg, pi.neg_apply, neg_neg, ← mul_two, mul_eq_zero] at hy'\n    cases hy'\n    -- need to handle case of `char 𝕜 = 2` separately\n    · exfalso\n      exact hg_ne hy hy'\n    · rw [h hx, pi.neg_apply, eq_comm, ← sub_eq_zero, sub_eq_add_neg, neg_neg, ← mul_two, hy', mul_zero]\n#align is_preconnected.eq_of_sq_eq is_preconnected.eq_of_sq_eq\n\n",
 "continuous_units_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem continuous_units_inv : continuous fun x : «expr ˣ» K => (↑x⁻¹ : K) :=\n  (topological_ring.induced_units.continuous_coe K).comp continuous_inv\n#align continuous_units_inv continuous_units_inv\n\n",
 "continuous_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem induced_units.continuous_coe [induced_units R] : continuous (coe : «expr ˣ» R → R) :=\n  (units_topology_eq R).symm ▸ continuous_induced_dom\n#align induced_units.continuous_coe induced_units.continuous_coe\n\n"}