{"topologicalClosure_minimal":
 "#print Subfield.topologicalClosure_minimal /-\ntheorem Subfield.topologicalClosure_minimal (s : Subfield Î±) {t : Subfield Î±} (h : s â‰¤ t) (ht : IsClosed (t : Set Î±)) :\n    s.topological_closure â‰¤ t :=\n  closure_minimal h ht\n#align subfield.topological_closure_minimal Subfield.topologicalClosure_minimal\n-/\n\n",
 "tendsto_cocompact_mul_rightâ‚€":
 "#print Filter.tendsto_cocompact_mul_rightâ‚€ /-\n/-- Right-multiplication by a nonzero element of a topological division ring is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_rightâ‚€ [ContinuousMul K] {a : K} (ha : a â‰  0) :\n    Filter.Tendsto (fun x : K => x * a) (Filter.cocompact K) (Filter.cocompact K) :=\n  Filter.tendsto_cocompact_mul_right (mul_inv_cancel ha)\n#align filter.tendsto_cocompact_mul_rightâ‚€ Filter.tendsto_cocompact_mul_rightâ‚€\n-/\n\n",
 "tendsto_cocompact_mul_leftâ‚€":
 "#print Filter.tendsto_cocompact_mul_leftâ‚€ /-\n/-\nCopyright (c) 2021 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Scott Morrison\n-/\n/-- Left-multiplication by a nonzero element of a topological division ring is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_leftâ‚€ [ContinuousMul K] {a : K} (ha : a â‰  0) :\n    Filter.Tendsto (fun x : K => a * x) (Filter.cocompact K) (Filter.cocompact K) :=\n  Filter.tendsto_cocompact_mul_left (inv_mul_cancel ha)\n#align filter.tendsto_cocompact_mul_leftâ‚€ Filter.tendsto_cocompact_mul_leftâ‚€\n-/\n\n",
 "le_topologicalClosure":
 "#print Subfield.le_topologicalClosure /-\ntheorem Subfield.le_topologicalClosure (s : Subfield Î±) : s â‰¤ s.topological_closure :=\n  subset_closure\n#align subfield.le_topological_closure Subfield.le_topologicalClosure\n-/\n\n",
 "isClosed_topologicalClosure":
 "#print Subfield.isClosed_topologicalClosure /-\ntheorem Subfield.isClosed_topologicalClosure (s : Subfield Î±) : IsClosed (s.topological_closure : Set Î±) :=\n  isClosed_closure\n#align subfield.is_closed_topological_closure Subfield.isClosed_topologicalClosure\n-/\n\n",
 "inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsLocalMin.inv /-\ntheorem IsLocalMin.inv {f : Î± â†’ Î²} {a : Î±} (h1 : IsLocalMin f a)\n    (h2 :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (0 < f z)) :\n    IsLocalMax fâ»Â¹ a := by filter_upwards [h1, h2]with z h3 h4 using(inv_le_inv h4 h2.self_of_nhds).mpr h3\n#align is_local_min.inv IsLocalMin.inv\n-/\n\n",
 "eq_or_eq_neg_of_sq_eq":
 "#print IsPreconnected.eq_or_eq_neg_of_sq_eq /-\n/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then either `f = g` or `f = -g` on\n`S`. -/\ntheorem IsPreconnected.eq_or_eq_neg_of_sq_eq [Field ğ•œ] [HasContinuousInvâ‚€ ğ•œ] [ContinuousMul ğ•œ] (hS : IsPreconnected S)\n    (hf : ContinuousOn f S) (hg : ContinuousOn g S) (hsq : EqOn (f ^ 2) (g ^ 2) S)\n    (hg_ne : âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) : EqOn f g S âˆ¨ EqOn f (-g) S :=\n  by\n  rcases hS.eq_one_or_eq_neg_one_of_sq_eq (hf.div hg fun z hz => hg_ne hz) fun x hx => _ with (h | h)\n  Â· refine' or.inl fun x hx => _\n    rw [â† div_eq_one_iff_eq (hg_ne hx)]\n    exact h hx\n  Â· refine' or.inr fun x hx => _\n    specialize h hx\n    rwa [Pi.div_apply, Pi.neg_apply, Pi.one_apply, div_eq_iff (hg_ne hx), neg_one_mul] at h\n  Â· rw [Pi.one_apply, div_pow, Pi.div_apply, hsq hx, div_self]\n    exact pow_ne_zero _ (hg_ne hx)\n#align is_preconnected.eq_or_eq_neg_of_sq_eq IsPreconnected.eq_or_eq_neg_of_sq_eq\n-/\n\n",
 "eq_one_or_eq_neg_one_of_sq_eq":
 "#print IsPreconnected.eq_one_or_eq_neg_one_of_sq_eq /-\n/-- If `f` is a function `Î± â†’ ğ•œ` which is continuous on a preconnected set `S`, and\n`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. -/\ntheorem IsPreconnected.eq_one_or_eq_neg_one_of_sq_eq [Ring ğ•œ] [NoZeroDivisors ğ•œ] (hS : IsPreconnected S)\n    (hf : ContinuousOn f S) (hsq : EqOn (f ^ 2) 1 S) : EqOn f 1 S âˆ¨ EqOn f (-1) S :=\n  by\n  simp_rw [eq_on, Pi.one_apply, Pi.pow_apply, sq_eq_one_iff] at hsq\n  -- First deal with crazy case where `S` is empty.\n  by_cases hSe : âˆ€ x : Î±, x âˆ‰ S\n  Â· left\n    intro x hx\n    exfalso\n    exact hSe x hx\n  push_neg  at hSe\n  choose y hy using hSe\n  suffices âˆ€ x : Î±, x âˆˆ S â†’ f x = f y by\n    rcases hsq hy with âŸ¨âŸ©\n    Â· left\n      intro z hz\n      rw [Pi.one_apply z, â† h]\n      exact this z hz\n    Â· right\n      intro z hz\n      rw [Pi.neg_apply, Pi.one_apply, â† h]\n      exact this z hz\n  refine' fun x hx => hS.constant_of_maps_to hf (fun z hz => _) hx hy\n  show f z âˆˆ ({-1, 1} : Set ğ•œ)\n  Â· exact mem_insert_iff.mpr (hsq hz).symm\n  exact discrete_of_t1_of_finite\n#align is_preconnected.eq_one_or_eq_neg_one_of_sq_eq IsPreconnected.eq_one_or_eq_neg_one_of_sq_eq\n-/\n\n",
 "eq_of_sq_eq":
 "#print IsPreconnected.eq_of_sq_eq /-\n/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem IsPreconnected.eq_of_sq_eq [Field ğ•œ] [HasContinuousInvâ‚€ ğ•œ] [ContinuousMul ğ•œ] (hS : IsPreconnected S)\n    (hf : ContinuousOn f S) (hg : ContinuousOn g S) (hsq : EqOn (f ^ 2) (g ^ 2) S) (hg_ne : âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0)\n    {y : Î±} (hy : y âˆˆ S) (hy' : f y = g y) : EqOn f g S := fun x hx =>\n  by\n  rcases hS.eq_or_eq_neg_of_sq_eq hf hg @hsq @hg_ne with (h | h)\n  Â· exact h hx\n  Â· rw [h hy, eq_comm, â† sub_eq_zero, sub_eq_add_neg, Pi.neg_apply, neg_neg, â† mul_two, mul_eq_zero] at hy'\n    cases hy'\n    -- need to handle case of `char ğ•œ = 2` separately\n    Â· exfalso\n      exact hg_ne hy hy'\n    Â· rw [h hx, Pi.neg_apply, eq_comm, â† sub_eq_zero, sub_eq_add_neg, neg_neg, â† mul_two, hy', MulZeroClass.mul_zero]\n#align is_preconnected.eq_of_sq_eq IsPreconnected.eq_of_sq_eq\n-/\n\n"}