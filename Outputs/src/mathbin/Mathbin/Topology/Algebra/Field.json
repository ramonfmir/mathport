{"topologicalClosure_minimal":
 "#print Subfield.topologicalClosure_minimal /-\ntheorem Subfield.topologicalClosure_minimal (s : Subfield α) {t : Subfield α} (h : s ≤ t) (ht : IsClosed (t : Set α)) :\n    s.topological_closure ≤ t :=\n  closure_minimal h ht\n#align subfield.topological_closure_minimal Subfield.topologicalClosure_minimal\n-/\n\n",
 "tendsto_cocompact_mul_right₀":
 "#print Filter.tendsto_cocompact_mul_right₀ /-\n/-- Right-multiplication by a nonzero element of a topological division ring is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_right₀ [ContinuousMul K] {a : K} (ha : a ≠ 0) :\n    Filter.Tendsto (fun x : K => x * a) (Filter.cocompact K) (Filter.cocompact K) :=\n  Filter.tendsto_cocompact_mul_right (mul_inv_cancel ha)\n#align filter.tendsto_cocompact_mul_right₀ Filter.tendsto_cocompact_mul_right₀\n-/\n\n",
 "tendsto_cocompact_mul_left₀":
 "#print Filter.tendsto_cocompact_mul_left₀ /-\n/-\nCopyright (c) 2021 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Scott Morrison\n-/\n/-- Left-multiplication by a nonzero element of a topological division ring is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_left₀ [ContinuousMul K] {a : K} (ha : a ≠ 0) :\n    Filter.Tendsto (fun x : K => a * x) (Filter.cocompact K) (Filter.cocompact K) :=\n  Filter.tendsto_cocompact_mul_left (inv_mul_cancel ha)\n#align filter.tendsto_cocompact_mul_left₀ Filter.tendsto_cocompact_mul_left₀\n-/\n\n",
 "le_topologicalClosure":
 "#print Subfield.le_topologicalClosure /-\ntheorem Subfield.le_topologicalClosure (s : Subfield α) : s ≤ s.topological_closure :=\n  subset_closure\n#align subfield.le_topological_closure Subfield.le_topologicalClosure\n-/\n\n",
 "isClosed_topologicalClosure":
 "#print Subfield.isClosed_topologicalClosure /-\ntheorem Subfield.isClosed_topologicalClosure (s : Subfield α) : IsClosed (s.topological_closure : Set α) :=\n  isClosed_closure\n#align subfield.is_closed_topological_closure Subfield.isClosed_topologicalClosure\n-/\n\n",
 "inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsLocalMin.inv /-\ntheorem IsLocalMin.inv {f : α → β} {a : α} (h1 : IsLocalMin f a)\n    (h2 :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (0 < f z)) :\n    IsLocalMax f⁻¹ a := by filter_upwards [h1, h2]with z h3 h4 using(inv_le_inv h4 h2.self_of_nhds).mpr h3\n#align is_local_min.inv IsLocalMin.inv\n-/\n\n",
 "eq_or_eq_neg_of_sq_eq":
 "#print IsPreconnected.eq_or_eq_neg_of_sq_eq /-\n/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then either `f = g` or `f = -g` on\n`S`. -/\ntheorem IsPreconnected.eq_or_eq_neg_of_sq_eq [Field 𝕜] [HasContinuousInv₀ 𝕜] [ContinuousMul 𝕜] (hS : IsPreconnected S)\n    (hf : ContinuousOn f S) (hg : ContinuousOn g S) (hsq : EqOn (f ^ 2) (g ^ 2) S)\n    (hg_ne : ∀ {x : α}, x ∈ S → g x ≠ 0) : EqOn f g S ∨ EqOn f (-g) S :=\n  by\n  rcases hS.eq_one_or_eq_neg_one_of_sq_eq (hf.div hg fun z hz => hg_ne hz) fun x hx => _ with (h | h)\n  · refine' or.inl fun x hx => _\n    rw [← div_eq_one_iff_eq (hg_ne hx)]\n    exact h hx\n  · refine' or.inr fun x hx => _\n    specialize h hx\n    rwa [Pi.div_apply, Pi.neg_apply, Pi.one_apply, div_eq_iff (hg_ne hx), neg_one_mul] at h\n  · rw [Pi.one_apply, div_pow, Pi.div_apply, hsq hx, div_self]\n    exact pow_ne_zero _ (hg_ne hx)\n#align is_preconnected.eq_or_eq_neg_of_sq_eq IsPreconnected.eq_or_eq_neg_of_sq_eq\n-/\n\n",
 "eq_one_or_eq_neg_one_of_sq_eq":
 "#print IsPreconnected.eq_one_or_eq_neg_one_of_sq_eq /-\n/-- If `f` is a function `α → 𝕜` which is continuous on a preconnected set `S`, and\n`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. -/\ntheorem IsPreconnected.eq_one_or_eq_neg_one_of_sq_eq [Ring 𝕜] [NoZeroDivisors 𝕜] (hS : IsPreconnected S)\n    (hf : ContinuousOn f S) (hsq : EqOn (f ^ 2) 1 S) : EqOn f 1 S ∨ EqOn f (-1) S :=\n  by\n  simp_rw [eq_on, Pi.one_apply, Pi.pow_apply, sq_eq_one_iff] at hsq\n  -- First deal with crazy case where `S` is empty.\n  by_cases hSe : ∀ x : α, x ∉ S\n  · left\n    intro x hx\n    exfalso\n    exact hSe x hx\n  push_neg  at hSe\n  choose y hy using hSe\n  suffices ∀ x : α, x ∈ S → f x = f y by\n    rcases hsq hy with ⟨⟩\n    · left\n      intro z hz\n      rw [Pi.one_apply z, ← h]\n      exact this z hz\n    · right\n      intro z hz\n      rw [Pi.neg_apply, Pi.one_apply, ← h]\n      exact this z hz\n  refine' fun x hx => hS.constant_of_maps_to hf (fun z hz => _) hx hy\n  show f z ∈ ({-1, 1} : Set 𝕜)\n  · exact mem_insert_iff.mpr (hsq hz).symm\n  exact discrete_of_t1_of_finite\n#align is_preconnected.eq_one_or_eq_neg_one_of_sq_eq IsPreconnected.eq_one_or_eq_neg_one_of_sq_eq\n-/\n\n",
 "eq_of_sq_eq":
 "#print IsPreconnected.eq_of_sq_eq /-\n/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem IsPreconnected.eq_of_sq_eq [Field 𝕜] [HasContinuousInv₀ 𝕜] [ContinuousMul 𝕜] (hS : IsPreconnected S)\n    (hf : ContinuousOn f S) (hg : ContinuousOn g S) (hsq : EqOn (f ^ 2) (g ^ 2) S) (hg_ne : ∀ {x : α}, x ∈ S → g x ≠ 0)\n    {y : α} (hy : y ∈ S) (hy' : f y = g y) : EqOn f g S := fun x hx =>\n  by\n  rcases hS.eq_or_eq_neg_of_sq_eq hf hg @hsq @hg_ne with (h | h)\n  · exact h hx\n  · rw [h hy, eq_comm, ← sub_eq_zero, sub_eq_add_neg, Pi.neg_apply, neg_neg, ← mul_two, mul_eq_zero] at hy'\n    cases hy'\n    -- need to handle case of `char 𝕜 = 2` separately\n    · exfalso\n      exact hg_ne hy hy'\n    · rw [h hx, Pi.neg_apply, eq_comm, ← sub_eq_zero, sub_eq_add_neg, neg_neg, ← mul_two, hy', MulZeroClass.mul_zero]\n#align is_preconnected.eq_of_sq_eq IsPreconnected.eq_of_sq_eq\n-/\n\n"}