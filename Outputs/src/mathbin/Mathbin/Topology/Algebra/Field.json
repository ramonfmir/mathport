{"units_topology_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/-\nCopyright (c) 2021 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Scott Morrison\n-/\ntheorem units_topology_eq [induced_units R] : â€¹topological_space (Â«expr Ë£Â» R)â€º = induced (coe : Â«expr Ë£Â» R â†’ R) â€¹_â€º :=\n  induced_units.top_eq\n#align units_topology_eq units_topology_eq\n\n",
 "units_top_group":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\ntheorem units_top_group : topological_group (Â«expr Ë£Â» K) :=\n  { topological_ring.top_monoid_units K with\n    continuous_inv := by\n      rw [continuous_iff_continuous_at]\n      intro x\n      rw [continuous_at, nhds_induced, nhds_induced, tendsto_iff_comap, â†\n        function.semiconj.filter_comap Units.val_inv_eq_inv_val _]\n      apply comap_mono\n      rw [â† tendsto_iff_comap, Units.val_inv_eq_inv_val]\n      exact continuous_at_invâ‚€ x.ne_zero }\n#align units_top_group units_top_group\n\n",
 "units_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\ntheorem units_embedding [induced_units R] : embedding (coe : Â«expr Ë£Â» R â†’ R) :=\n  { induced := units_topology_eq R\n    inj := fun x y h => Units.ext h }\n#align units_embedding units_embedding\n\n",
 "topological_closure_minimal":
 "theorem subfield.topological_closure_minimal (s : subfield Î±) {t : subfield Î±} (h : s â‰¤ t)\n    (ht : is_closed (t : set Î±)) : s.topological_closure â‰¤ t :=\n  closure_minimal h ht\n#align subfield.topological_closure_minimal subfield.topological_closure_minimal\n\n",
 "tendsto_cocompact_mul_rightâ‚€":
 "/-- Right-multiplication by a nonzero element of a topological division ring is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem filter.tendsto_cocompact_mul_rightâ‚€ [has_continuous_mul K] {a : K} (ha : a â‰  0) :\n    filter.tendsto (fun x : K => x * a) (filter.cocompact K) (filter.cocompact K) :=\n  filter.tendsto_cocompact_mul_right (mul_inv_cancel ha)\n#align filter.tendsto_cocompact_mul_rightâ‚€ filter.tendsto_cocompact_mul_rightâ‚€\n\n",
 "tendsto_cocompact_mul_leftâ‚€":
 "/-- Left-multiplication by a nonzero element of a topological division ring is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem filter.tendsto_cocompact_mul_leftâ‚€ [has_continuous_mul K] {a : K} (ha : a â‰  0) :\n    filter.tendsto (fun x : K => a * x) (filter.cocompact K) (filter.cocompact K) :=\n  filter.tendsto_cocompact_mul_left (inv_mul_cancel ha)\n#align filter.tendsto_cocompact_mul_leftâ‚€ filter.tendsto_cocompact_mul_leftâ‚€\n\n",
 "le_topological_closure":
 "theorem subfield.le_topological_closure (s : subfield Î±) : s â‰¤ s.topological_closure :=\n  subset_closure\n#align subfield.le_topological_closure subfield.le_topological_closure\n\n",
 "is_closed_topological_closure":
 "theorem subfield.is_closed_topological_closure (s : subfield Î±) : is_closed (s.topological_closure : set Î±) :=\n  is_closed_closure\n#align subfield.is_closed_topological_closure subfield.is_closed_topological_closure\n\n",
 "inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_local_min.inv {f : Î± â†’ Î²} {a : Î±} (h1 : is_local_min f a)\n    (h2 :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (0 < f z)) :\n    is_local_max fâ»Â¹ a := by filter_upwards [h1, h2] with z h3 h4 using(inv_le_inv h4 h2.self_of_nhds).mpr h3\n#align is_local_min.inv is_local_min.inv\n\n",
 "eq_or_eq_neg_of_sq_eq":
 "/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then either `f = g` or `f = -g` on\n`S`. -/\ntheorem is_preconnected.eq_or_eq_neg_of_sq_eq [Field ğ•œ] [has_continuous_invâ‚€ ğ•œ] [has_continuous_mul ğ•œ]\n    (hS : is_preconnected S) (hf : continuous_on f S) (hg : continuous_on g S) (hsq : EqOn (f ^ 2) (g ^ 2) S)\n    (hg_ne : âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) : EqOn f g S âˆ¨ EqOn f (-g) S :=\n  by\n  rcases hS.eq_one_or_eq_neg_one_of_sq_eq (hf.div hg fun z hz => hg_ne hz) fun x hx => _ with (h | h)\n  Â· refine' or.inl fun x hx => _\n    rw [â† div_eq_one_iff_eq (hg_ne hx)]\n    exact h hx\n  Â· refine' or.inr fun x hx => _\n    specialize h hx\n    rwa [pi.div_apply, pi.neg_apply, pi.one_apply, div_eq_iff (hg_ne hx), neg_one_mul] at h\n  Â· rw [pi.one_apply, div_pow, pi.div_apply, hsq hx, div_self]\n    exact pow_ne_zero _ (hg_ne hx)\n#align is_preconnected.eq_or_eq_neg_of_sq_eq is_preconnected.eq_or_eq_neg_of_sq_eq\n\n",
 "eq_one_or_eq_neg_one_of_sq_eq":
 "/-- If `f` is a function `Î± â†’ ğ•œ` which is continuous on a preconnected set `S`, and\n`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. -/\ntheorem is_preconnected.eq_one_or_eq_neg_one_of_sq_eq [Ring ğ•œ] [no_zero_divisors ğ•œ] (hS : is_preconnected S)\n    (hf : continuous_on f S) (hsq : EqOn (f ^ 2) 1 S) : EqOn f 1 S âˆ¨ EqOn f (-1) S :=\n  by\n  simp_rw [eq_on, pi.one_apply, pi.pow_apply, sq_eq_one_iff] at hsq\n  -- First deal with crazy case where `S` is empty.\n  by_cases hSe : âˆ€ x : Î±, x âˆ‰ S\n  Â· left\n    intro x hx\n    exfalso\n    exact hSe x hx\n  push_neg  at hSe\n  choose y hy using hSe\n  suffices âˆ€ x : Î±, x âˆˆ S â†’ f x = f y by\n    rcases hsq hy with âŸ¨âŸ©\n    Â· left\n      intro z hz\n      rw [pi.one_apply z, â† h]\n      exact this z hz\n    Â· right\n      intro z hz\n      rw [pi.neg_apply, pi.one_apply, â† h]\n      exact this z hz\n  refine' fun x hx => hS.constant_of_maps_to hf (fun z hz => _) hx hy\n  show f z âˆˆ ({-1, 1} : set ğ•œ)\n  Â· exact mem_insert_iff.mpr (hsq hz).symm\n  exact discrete_of_t1_of_finite\n#align is_preconnected.eq_one_or_eq_neg_one_of_sq_eq is_preconnected.eq_one_or_eq_neg_one_of_sq_eq\n\n",
 "eq_of_sq_eq":
 "/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem is_preconnected.eq_of_sq_eq [Field ğ•œ] [has_continuous_invâ‚€ ğ•œ] [has_continuous_mul ğ•œ] (hS : is_preconnected S)\n    (hf : continuous_on f S) (hg : continuous_on g S) (hsq : EqOn (f ^ 2) (g ^ 2) S)\n    (hg_ne : âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) {y : Î±} (hy : y âˆˆ S) (hy' : f y = g y) : EqOn f g S := fun x hx =>\n  by\n  rcases hS.eq_or_eq_neg_of_sq_eq hf hg @hsq @hg_ne with (h | h)\n  Â· exact h hx\n  Â· rw [h hy, eq_comm, â† sub_eq_zero, sub_eq_add_neg, pi.neg_apply, neg_neg, â† mul_two, mul_eq_zero] at hy'\n    cases hy'\n    -- need to handle case of `char ğ•œ = 2` separately\n    Â· exfalso\n      exact hg_ne hy hy'\n    Â· rw [h hx, pi.neg_apply, eq_comm, â† sub_eq_zero, sub_eq_add_neg, neg_neg, â† mul_two, hy', mul_zero]\n#align is_preconnected.eq_of_sq_eq is_preconnected.eq_of_sq_eq\n\n",
 "continuous_units_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\ntheorem continuous_units_inv : continuous fun x : Â«expr Ë£Â» K => (â†‘xâ»Â¹ : K) :=\n  (topological_ring.induced_units.continuous_coe K).comp continuous_inv\n#align continuous_units_inv continuous_units_inv\n\n",
 "continuous_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\ntheorem induced_units.continuous_coe [induced_units R] : continuous (coe : Â«expr Ë£Â» R â†’ R) :=\n  (units_topology_eq R).symm â–¸ continuous_induced_dom\n#align induced_units.continuous_coe induced_units.continuous_coe\n\n"}