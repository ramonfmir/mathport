{"ring_sep_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ring_sep_rel (α) [CommRing α] [uniform_space α] [uniform_add_group α] [topological_ring α] :\n    separation_setoid α = submodule.quotient_rel (ideal.closure («expr⊥»)) :=\n  setoid.ext fun x y => (add_group_separation_rel x y).trans <| iff.trans (by rfl) (submodule.quotient_rel_r_def _).symm\n#align ring_sep_rel ring_sep_rel\n\n",
 "ring_sep_quot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ring_sep_quot (α : Type u) [r : CommRing α] [uniform_space α] [uniform_add_group α] [topological_ring α] :\n    quotient (separation_setoid α) = «expr ⧸ » α («expr⊥» : ideal α).closure := by rw [@ring_sep_rel α r] <;> rfl\n#align ring_sep_quot ring_sep_quot\n\n",
 "mul":
 "theorem continuous.mul {β : Type _} [topological_space β] {f g : β → completion α} (hf : continuous f)\n    (hg : continuous g) : continuous fun b => f b * g b :=\n  continuous_mul.comp (hf.prod_mk hg : _)\n#align continuous.mul continuous.mul\n\n",
 "map_smul_eq_mul_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n-- helping the elaborator\n@[simp]\ntheorem map_smul_eq_mul_coe (r : R) : completion.map ((«expr • » · ·) r) = (· * ·) (algebra_map R A r : completion A) :=\n  by\n  ext x\n  refine' completion.induction_on x _ fun a => _\n  · exact is_closed_eq completion.continuous_map (continuous_mul_left _)\n  · rw [map_coe (uniform_continuous_const_smul r) a, algebra.smul_def, coe_mul]\n#align map_smul_eq_mul_coe map_smul_eq_mul_coe\n\n",
 "continuous_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\ntheorem continuous_mul : continuous fun p : completion α × completion α => p.1 * p.2 :=\n  by\n  let m := (AddMonoidHom.mul : «expr →+ » α («expr →+ » α α)).compr₂ to_compl\n  have : continuous fun p : α × α => m p.1 p.2 := (continuous_coe α).comp continuous_mul\n  have di : dense_inducing (to_compl : α → completion α) := dense_inducing_coe\n  convert di.extend_Z_bilin di this\n  ext ⟨x, y⟩\n  rfl\n#align continuous_mul continuous_mul\n\n",
 "continuous_coe_ring_hom":
 "theorem continuous_coe_ring_hom : continuous (coe_ring_hom : α → completion α) :=\n  continuous_coe α\n#align continuous_coe_ring_hom continuous_coe_ring_hom\n\n",
 "coe_one":
 "/-\nCopyright (c) 2018 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Johannes Hölzl\n-/\n@[norm_cast]\ntheorem coe_one : ((1 : α) : completion α) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_mul":
 "@[norm_cast]\ntheorem coe_mul (a b : α) : ((a * b : α) : completion α) = a * b :=\n  ((dense_inducing_coe.prod dense_inducing_coe).extend_eq ((continuous_coe α).comp (@continuous_mul α _ _ _))\n      (a, b)).symm\n#align coe_mul coe_mul\n\n",
 "algebra_map_def":
 "theorem algebra_map_def (r : R) : algebra_map R (completion A) r = (algebra_map R A r : completion A) :=\n  rfl\n#align algebra_map_def algebra_map_def\n\n"}