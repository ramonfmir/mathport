{"tendsto_norm_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem tendsto_norm_at_top (p : polynomial R) (h : 0 < degree p) {l : filter α} {z : α → R}\n    (hz : tendsto (fun x => «expr‖ ‖» (z x)) l at_top) : tendsto (fun x => «expr‖ ‖» (p.eval (z x))) l at_top :=\n  p.tendsto_abv_at_top norm h hz\n#align tendsto_norm_at_top tendsto_norm_at_top\n\n",
 "tendsto_abv_eval₂_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem tendsto_abv_eval₂_at_top {R S k α : Type _} [Semiring R] [Ring S] [LinearOrderedField k] (f : «expr →+* » R S)\n    (abv : S → k) [IsAbsoluteValue abv] (p : polynomial R) (hd : 0 < degree p) (hf : f p.leading_coeff ≠ 0)\n    {l : filter α} {z : α → S} (hz : tendsto (abv ∘ z) l at_top) : tendsto (fun x => abv (p.eval₂ f (z x))) l at_top :=\n  by\n  revert hf; refine' degree_pos_induction_on p hd _ _ _ <;> clear hd p\n  · rintro c - hc\n    rw [leading_coeff_mul_X, leading_coeff_C] at hc\n    simpa [abv_mul abv] using hz.const_mul_at_top ((abv_pos abv).2 hc)\n  · intro p hpd ihp hf\n    rw [leading_coeff_mul_X] at hf\n    simpa [abv_mul abv] using (ihp hf).at_top_mul_at_top hz\n  · intro p a hd ihp hf\n    rw [add_comm, leading_coeff_add_of_degree_lt (degree_C_le.trans_lt hd)] at hf\n    refine' tendsto_at_top_of_add_const_right (abv (-f a)) _\n    refine' tendsto_at_top_mono (fun _ => abv_add abv _ _) _\n    simpa using ihp hf\n#align tendsto_abv_eval₂_at_top tendsto_abv_eval₂_at_top\n\n",
 "tendsto_abv_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem tendsto_abv_at_top {R k α : Type _} [Ring R] [LinearOrderedField k] (abv : R → k) [IsAbsoluteValue abv]\n    (p : polynomial R) (h : 0 < degree p) {l : filter α} {z : α → R} (hz : tendsto (abv ∘ z) l at_top) :\n    tendsto (fun x => abv (p.eval (z x))) l at_top :=\n  tendsto_abv_eval₂_at_top _ _ _ h (mt leading_coeff_eq_zero.1 <| ne_zero_of_degree_gt h) hz\n#align tendsto_abv_at_top tendsto_abv_at_top\n\n",
 "tendsto_abv_aeval_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem tendsto_abv_aeval_at_top {R A k α : Type _} [CommSemiring R] [Ring A] [algebra R A] [LinearOrderedField k]\n    (abv : A → k) [IsAbsoluteValue abv] (p : polynomial R) (hd : 0 < degree p)\n    (h₀ : algebra_map R A p.leading_coeff ≠ 0) {l : filter α} {z : α → A} (hz : tendsto (abv ∘ z) l at_top) :\n    tendsto (fun x => abv (aeval (z x) p)) l at_top :=\n  tendsto_abv_eval₂_at_top _ abv p hd h₀ hz\n#align tendsto_abv_aeval_at_top tendsto_abv_aeval_at_top\n\n",
 "exists_forall_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem exists_forall_norm_le [proper_space R] (p : polynomial R) :\n    ∃ x, ∀ y, «expr‖ ‖» (p.eval x) ≤ «expr‖ ‖» (p.eval y) :=\n  if hp0 : 0 < degree p then\n    p.continuous.norm.exists_forall_le <| p.tendsto_norm_at_top hp0 tendsto_norm_cocompact_at_top\n  else ⟨p.coeff 0, by rw [eq_C_of_degree_le_zero (le_of_not_gt hp0)] <;> simp⟩\n#align exists_forall_norm_le exists_forall_norm_le\n\n",
 "eq_one_of_roots_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem eq_one_of_roots_le {p : polynomial F} {f : «expr →+* » F K} {B : exprℝ} (hB : B < 0) (h1 : p.monic)\n    (h2 : splits f p) (h3 : ∀ z ∈ (map f p).roots, «expr‖ ‖» z ≤ B) : p = 1 :=\n  h1.nat_degree_eq_zero_iff_eq_one.mp\n    (by\n      contrapose! hB\n      rw [← h1.nat_degree_map f, nat_degree_eq_card_roots' h2] at hB\n      obtain ⟨z, hz⟩ := card_pos_iff_exists_mem.mp (zero_lt_iff.mpr hB)\n      exact le_trans (norm_nonneg _) (h3 z hz))\n#align eq_one_of_roots_le eq_one_of_roots_le\n\n",
 "continuous_within_at_aeval":
 "protected theorem continuous_within_at_aeval {s a} : continuous_within_at (fun x : A => aeval x p) s a :=\n  p.continuous_aeval.continuous_within_at\n#align continuous_within_at_aeval continuous_within_at_aeval\n\n",
 "continuous_within_at":
 "protected theorem continuous_within_at {s a} : continuous_within_at (fun x => p.eval x) s a :=\n  p.continuous.continuous_within_at\n#align continuous_within_at continuous_within_at\n\n",
 "continuous_on_aeval":
 "protected theorem continuous_on_aeval {s} : continuous_on (fun x : A => aeval x p) s :=\n  p.continuous_aeval.continuous_on\n#align continuous_on_aeval continuous_on_aeval\n\n",
 "continuous_on":
 "protected theorem continuous_on {s} : continuous_on (fun x => p.eval x) s :=\n  p.continuous.continuous_on\n#align continuous_on continuous_on\n\n",
 "continuous_eval₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-\nCopyright (c) 2018 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis\n-/\n@[continuity]\nprotected theorem continuous_eval₂ [Semiring S] (p : polynomial S) (f : «expr →+* » S R) :\n    continuous fun x => p.eval₂ f x := by\n  simp only [eval₂_eq_sum, finsupp.sum]\n  exact continuous_finset_sum _ fun c hc => continuous_const.mul (continuous_pow _)\n#align continuous_eval₂ continuous_eval₂\n\n",
 "continuous_at_aeval":
 "protected theorem continuous_at_aeval {a : A} : continuous_at (fun x : A => aeval x p) a :=\n  p.continuous_aeval.continuous_at\n#align continuous_at_aeval continuous_at_aeval\n\n",
 "continuous_at":
 "protected theorem continuous_at {a : R} : continuous_at (fun x => p.eval x) a :=\n  p.continuous.continuous_at\n#align continuous_at continuous_at\n\n",
 "continuous_aeval":
 "@[continuity]\nprotected theorem continuous_aeval : continuous fun x : A => aeval x p :=\n  p.continuous_eval₂ _\n#align continuous_aeval continuous_aeval\n\n",
 "continuous":
 "@[continuity]\nprotected theorem continuous : continuous fun x => p.eval x :=\n  p.continuous_eval₂ _\n#align continuous continuous\n\n",
 "coeff_le_of_roots_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem coeff_le_of_roots_le {p : polynomial F} {f : «expr →+* » F K} {B : exprℝ} (i : ℕ) (h1 : p.monic)\n    (h2 : splits f p) (h3 : ∀ z ∈ (map f p).roots, «expr‖ ‖» z ≤ B) :\n    «expr‖ ‖» ((map f p).coeff i) ≤ B ^ (p.nat_degree - i) * p.nat_degree.choose i :=\n  by\n  obtain hB | hB := lt_or_le B 0\n  · rw [eq_one_of_roots_le hB h1 h2 h3, polynomial.map_one, nat_degree_one, zero_tsub, pow_zero, one_mul, coeff_one]\n    split_ifs <;> norm_num [h]\n  rw [← h1.nat_degree_map f]\n  obtain hi | hi := lt_or_le (map f p).nat_degree i\n  · rw [coeff_eq_zero_of_nat_degree_lt hi, norm_zero]\n    positivity\n  rw [coeff_eq_esymm_roots_of_splits ((splits_id_iff_splits f).2 h2) hi, (h1.map _).leading_coeff, one_mul, norm_mul,\n    norm_pow, norm_neg, norm_one, one_pow, one_mul]\n  apply ((norm_multiset_sum_le _).trans <| sum_le_card_nsmul _ _ fun r hr => _).trans\n  ·\n    rw [Multiset.map_map, card_map, card_powerset_len, ← nat_degree_eq_card_roots' h2, Nat.choose_symm hi, mul_comm,\n      nsmul_eq_mul]\n  simp_rw [Multiset.mem_map] at hr\n  obtain ⟨_, ⟨s, hs, rfl⟩, rfl⟩ := hr\n  rw [mem_powerset_len] at hs\n  lift B to nnreal using hB\n  rw [← coe_nnnorm, ← nnreal.coe_pow, nnreal.coe_le_coe, ← nnnorm_hom_apply, ← MonoidHom.coe_coe,\n    MonoidHom.map_multiset_prod]\n  refine' (prod_le_pow_card _ B fun x hx => _).trans_eq (by rw [card_map, hs.2])\n  obtain ⟨z, hz, rfl⟩ := Multiset.mem_map.1 hx\n  exact h3 z (mem_of_le hs.1 hz)\n#align coeff_le_of_roots_le coeff_le_of_roots_le\n\n",
 "coeff_bdd_of_roots_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The coefficients of the monic polynomials of bounded degree with bounded roots are\nuniformely bounded. -/\ntheorem coeff_bdd_of_roots_le {B : exprℝ} {d : ℕ} (f : «expr →+* » F K) {p : polynomial F} (h1 : p.monic)\n    (h2 : splits f p) (h3 : p.nat_degree ≤ d) (h4 : ∀ z ∈ (map f p).roots, «expr‖ ‖» z ≤ B) (i : ℕ) :\n    «expr‖ ‖» ((map f p).coeff i) ≤ max B 1 ^ d * d.choose (d / 2) :=\n  by\n  obtain hB | hB := le_or_lt 0 B\n  · apply (coeff_le_of_roots_le i h1 h2 h4).trans\n    calc\n      _ ≤ max B 1 ^ (p.nat_degree - i) * p.nat_degree.choose i :=\n        mul_le_mul_of_nonneg_right (pow_le_pow_of_le_left hB (le_max_left _ _) _) _\n      _ ≤ max B 1 ^ d * p.nat_degree.choose i :=\n        mul_le_mul_of_nonneg_right ((pow_mono (le_max_right _ _)) (le_trans (nat.sub_le _ _) h3)) _\n      _ ≤ max B 1 ^ d * d.choose (d / 2) :=\n        mul_le_mul_of_nonneg_left (nat.cast_le.mpr ((i.choose_mono h3).trans (i.choose_le_middle d))) _\n      \n    all_goals positivity\n  · rw [eq_one_of_roots_le hB h1 h2 h4, polynomial.map_one, coeff_one]\n    refine' trans _ (one_le_mul_of_one_le_of_one_le (one_le_pow_of_one_le (le_max_right B 1) d) _)\n    · split_ifs <;> norm_num\n    · exact_mod_cast nat.succ_le_iff.mpr (Nat.choose_pos (d.div_le_self 2))\n#align coeff_bdd_of_roots_le coeff_bdd_of_roots_le\n\n"}