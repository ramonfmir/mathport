{"nonarchimedean":
 "theorem nonarchimedean (I : Ideal R) : @NonarchimedeanRing R _ I.adic_topology :=\n  I.adic_basis.to_ring_subgroups_basis.nonarchimedean\n#align nonarchimedean nonarchimedean\n\n",
 "is_ideal_adic_pow":
 "#print is_ideal_adic_pow /-\ntheorem is_ideal_adic_pow {J : Ideal R} (h : IsAdic J) {n : ℕ} (hn : 0 < n) : IsAdic (J ^ n) :=\n  by\n  rw [isAdic_iff] at h⊢\n  constructor\n  · intro m\n    rw [← pow_mul]\n    apply h.left\n  · intro V hV\n    cases' h.right V hV with m hm\n    use m\n    refine' Set.Subset.trans _ hm\n    cases n\n    · exfalso\n      exact nat.not_succ_le_zero 0 hn\n    rw [← pow_mul, nat.succ_mul]\n    apply Ideal.pow_le_pow\n    apply nat.le_add_left\n#align is_ideal_adic_pow is_ideal_adic_pow\n-/\n\n",
 "is_bot_adic_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print is_bot_adic_iff /-\ntheorem is_bot_adic_iff {A : Type _} [CommRing A] [TopologicalSpace A] [TopologicalRing A] :\n    IsAdic («expr⊥» : Ideal A) ↔ DiscreteTopology A :=\n  by\n  rw [isAdic_iff]\n  constructor\n  · rintro ⟨h, h'⟩\n    rw [discreteTopology_iff_open_singleton_zero]\n    simpa using h 1\n  · intros\n    constructor\n    · simp\n    · intro U U_nhds\n      use 1\n      simp [mem_of_mem_nhds U_nhds]\n#align is_bot_adic_iff is_bot_adic_iff\n-/\n\n",
 "isAdic_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isAdic_iff /-\n/-- A topological ring is `J`-adic if and only if it admits the powers of `J` as a basis of\nopen neighborhoods of zero. -/\ntheorem isAdic_iff [top : TopologicalSpace R] [TopologicalRing R] {J : Ideal R} :\n    IsAdic J ↔\n      (∀ n : ℕ, IsOpen ((J ^ n : Ideal R) : Set R)) ∧ ∀ s ∈ (nhds) (0 : R), ∃ n : ℕ, ((J ^ n : Ideal R) : Set R) ⊆ s :=\n  by\n  constructor\n  · intro H\n    change _ = _ at H\n    rw [H]\n    letI := J.adic_topology\n    constructor\n    · intro n\n      exact (J.open_add_subgroup n).is_open'\n    · intro s hs\n      simpa using J.has_basis_nhds_zero_adic.mem_iff.mp hs\n  · rintro ⟨H₁, H₂⟩\n    apply TopologicalAddGroup.ext\n    · apply @TopologicalRing.to_topologicalAddGroup\n    · apply (RingSubgroupsBasis.toRingFilterBasis _).to_add_group_filter_basis.is_topological_add_group\n    · ext s\n      letI := Ideal.adic_basis J\n      rw [J.has_basis_nhds_zero_adic.mem_iff]\n      constructor <;> intro H\n      · rcases H₂ s H with ⟨n, h⟩\n        use n, trivial, h\n      · rcases H with ⟨n, -, hn⟩\n        rw [mem_nhds_iff]\n        refine' ⟨_, hn, H₁ n, (J ^ n).zero_mem⟩\n#align is_adic_iff isAdic_iff\n-/\n\n",
 "has_basis_nhds_zero_adic":
 "/-- For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. -/\ntheorem has_basis_nhds_zero_adic (I : Ideal R) :\n    HasBasis (@nhds R I.adic_topology (0 : R)) (fun n : ℕ => True) fun n => ((I ^ n : Ideal R) : Set R) :=\n  ⟨by\n    intro U\n    rw [I.ring_filter_basis.to_add_group_filter_basis.nhds_zero_has_basis.mem_iff]\n    constructor\n    · rintro ⟨-, ⟨i, rfl⟩, h⟩\n      replace h : ↑(I ^ i) ⊆ U := by simpa using h\n      use i, trivial, h\n    · rintro ⟨i, -, h⟩\n      exact ⟨(I ^ i : Ideal R), ⟨i, by simp⟩, h⟩⟩\n#align has_basis_nhds_zero_adic has_basis_nhds_zero_adic\n\n",
 "has_basis_nhds_adic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem has_basis_nhds_adic (I : Ideal R) (x : R) :\n    HasBasis (@nhds R I.adic_topology x) (fun n : ℕ => True) fun n => «expr '' » (fun y => x + y) (I ^ n : Ideal R) :=\n  by\n  letI := I.adic_topology\n  have := I.has_basis_nhds_zero_adic.map fun y => x + y\n  rwa [map_add_left_nhds_zero x] at this\n#align has_basis_nhds_adic has_basis_nhds_adic\n\n",
 "adic_module_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem adic_module_basis :\n    I.ring_filter_basis.submodules_basis fun n : ℕ => «expr • » (I ^ n) («expr⊤» : Submodule R M) :=\n  { inter := fun i j =>\n      ⟨max i j,\n        le_inf_iff.mpr\n          ⟨smul_mono_left <| pow_le_pow (le_max_left i j), smul_mono_left <| pow_le_pow (le_max_right i j)⟩⟩\n    smul := fun m i =>\n      ⟨(«expr • » (I ^ i) («expr⊤») : Ideal R), ⟨i, rfl⟩, fun a a_in =>\n        by\n        replace a_in : a ∈ I ^ i := by simpa [(I ^ i).mul_top] using a_in\n        exact smul_mem_smul a_in mem_top⟩ }\n#align adic_module_basis adic_module_basis\n\n",
 "adic_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2021 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot\n-/\ntheorem adic_basis (I : Ideal R) : SubmodulesRingBasis fun n : ℕ => («expr • » (I ^ n) («expr⊤») : Ideal R) :=\n  { inter := by\n      suffices ∀ i j : ℕ, ∃ k, I ^ k ≤ I ^ i ∧ I ^ k ≤ I ^ j by simpa\n      intro i j\n      exact ⟨max i j, pow_le_pow (le_max_left i j), pow_le_pow (le_max_right i j)⟩\n    left_mul := by\n      suffices ∀ (a : R) (i : ℕ), ∃ j : ℕ, «expr • » a (I ^ j) ≤ I ^ i by simpa\n      intro r n\n      use n\n      rintro a ⟨x, hx, rfl⟩\n      exact (I ^ n).smul_mem r hx\n    mul := by\n      suffices ∀ i : ℕ, ∃ j : ℕ, ↑(I ^ j) * ↑(I ^ j) ⊆ ↑(I ^ i) by simpa\n      intro n\n      use n\n      rintro a ⟨x, b, hx, hb, rfl⟩\n      exact (I ^ n).smul_mem x hb }\n#align adic_basis adic_basis\n\n"}