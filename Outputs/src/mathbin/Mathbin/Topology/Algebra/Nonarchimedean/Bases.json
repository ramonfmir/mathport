{"to_ring_subgroups_basis":
 "theorem to_ring_subgroups_basis (hB : SubmodulesRingBasis B) : RingSubgroupsBasis fun i => (B i).to_add_subgroup :=\n  by\n  apply RingSubgroupsBasis.of_comm (fun i => (B i).to_add_subgroup) hB.inter hB.mul\n  intro a i\n  rcases hB.left_mul a i with ⟨j, hj⟩\n  use j\n  rintro b (b_in : b ∈ B j)\n  exact hj ⟨b, b_in, rfl⟩\n#align to_ring_subgroups_basis to_ring_subgroups_basis\n\n",
 "toSubmodulesBasis":
 "#print SubmodulesRingBasis.toSubmodulesBasis /-\n/-\nIn this section, we check that, in a `R`-algebra `A` over a ring equipped with a topology,\na basis of `R`-submodules which is compatible with the topology on `R` is also a submodule basis\nin the sense of `R`-modules (forgetting about the ring structure on `A`) and those two points of\nview definitionaly gives the same topology on `A`.\n-/\ntheorem SubmodulesRingBasis.toSubmodulesBasis : SubmodulesBasis B :=\n  { inter := hB.inter\n    smul := hsmul }\n#align submodules_ring_basis.to_submodules_basis SubmodulesRingBasis.toSubmodulesBasis\n-/\n\n",
 "submodulesBasisIsBasis":
 "#print RingFilterBasis.submodulesBasisIsBasis /-\ntheorem RingFilterBasis.submodulesBasisIsBasis (BR : RingFilterBasis R) {B : ι → Submodule R M}\n    (hB : BR.submodules_basis B) : @SubmodulesBasis ι R _ M _ _ BR.topology B :=\n  { inter := hB.inter\n    smul := by\n      letI := BR.topology\n      intro m i\n      rcases hB.smul m i with ⟨V, V_in, hV⟩\n      exact mem_of_superset (BR.to_add_group_filter_basis.mem_nhds_zero V_in) hV }\n#align ring_filter_basis.submodules_basis_is_basis RingFilterBasis.submodulesBasisIsBasis\n-/\n\n",
 "of_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-\nCopyright (c) 2021 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot\n-/\ntheorem of_comm {A ι : Type _} [CommRing A] (B : ι → AddSubgroup A) (inter : ∀ i j, ∃ k, B k ≤ «expr ⊓ » (B i) (B j))\n    (mul : ∀ i, ∃ j, (B j : Set A) * B j ⊆ B i)\n    (left_mul : ∀ x : A, ∀ i, ∃ j, (B j : Set A) ⊆ «expr ⁻¹' » (fun y : A => x * y) (B i)) : RingSubgroupsBasis B :=\n  { inter\n    mul\n    left_mul\n    right_mul := by\n      intro x i\n      cases' leftMul x i with j hj\n      use j\n      simpa [mul_comm] using hj }\n#align of_comm of_comm\n\n",
 "nonarchimedean":
 "-- see Note [nonarchimedean non instances]\ntheorem nonarchimedean (hB : SubmodulesBasis B) : @NonarchimedeanAddGroup M _ hB.topology :=\n  by\n  letI := hB.topology\n  constructor\n  intro U hU\n  obtain ⟨-, ⟨i, rfl⟩, hi : (B i : Set M) ⊆ U⟩ :=\n    hB.to_module_filter_basis.to_add_group_filter_basis.nhds_zero_has_basis.mem_iff.mp hU\n  exact ⟨hB.open_add_subgroup i, hi⟩\n#align nonarchimedean nonarchimedean\n\n",
 "mem_add_group_filter_basis_iff":
 "theorem mem_add_group_filter_basis_iff {V : Set A} :\n    V ∈ hB.to_ring_filter_basis.to_add_group_filter_basis ↔ ∃ i, V = B i :=\n  iff.rfl\n#align mem_add_group_filter_basis_iff mem_add_group_filter_basis_iff\n\n",
 "mem_add_group_filter_basis":
 "theorem mem_add_group_filter_basis (i) : (B i : Set A) ∈ hB.to_ring_filter_basis.to_add_group_filter_basis :=\n  ⟨i, rfl⟩\n#align mem_add_group_filter_basis mem_add_group_filter_basis\n\n",
 "has_basis_nhds_zero":
 "theorem has_basis_nhds_zero : HasBasis (@nhds A hB.topology 0) (fun _ => True) fun i => B i :=\n  ⟨by\n    intro s\n    rw [hB.to_ring_filter_basis.to_add_group_filter_basis.nhds_zero_has_basis.mem_iff]\n    constructor\n    · rintro ⟨-, ⟨i, rfl⟩, hi⟩\n      exact ⟨i, trivial, hi⟩\n    · rintro ⟨i, -, hi⟩\n      exact ⟨B i, ⟨i, rfl⟩, hi⟩⟩\n#align has_basis_nhds_zero has_basis_nhds_zero\n\n",
 "has_basis_nhds":
 "theorem has_basis_nhds (a : A) : HasBasis (@nhds A hB.topology a) (fun _ => True) fun i => { b | b - a ∈ B i } :=\n  ⟨by\n    intro s\n    rw [(hB.to_ring_filter_basis.to_add_group_filter_basis.nhds_has_basis a).mem_iff]\n    simp only [exists_prop, exists_true_left]\n    constructor\n    · rintro ⟨-, ⟨i, rfl⟩, hi⟩\n      use i\n      convert hi\n      ext b\n      constructor\n      · intro h\n        use b - a, h\n        abel\n      · rintro ⟨c, hc, rfl⟩\n        simpa using hc\n    · rintro ⟨i, hi⟩\n      use B i, i, rfl\n      rw [image_subset_iff]\n      rintro b b_in\n      apply hi\n      simpa using b_in⟩\n#align has_basis_nhds has_basis_nhds\n\n"}