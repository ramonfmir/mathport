{"topological_closure_minimal":
 "theorem subring.topological_closure_minimal (s : subring α) {t : subring α} (h : s ≤ t) (ht : is_closed (t : set α)) :\n    s.topological_closure ≤ t :=\n  closure_minimal h ht\n#align subring.topological_closure_minimal subring.topological_closure_minimal\n\n",
 "topological_closure_coe":
 "-- See note [lower instance priority]\n@[simp]\ntheorem subsemiring.topological_closure_coe (s : subsemiring α) :\n    (s.topological_closure : set α) = closure (s : set α) :=\n  rfl\n#align subsemiring.topological_closure_coe subsemiring.topological_closure_coe\n\n",
 "to_topological_ring":
 "/-- If `R` is a ring which is a topological semiring, then it is automatically a topological\nring. This exists so that one can place a topological ring structure on `R` without explicitly\nproving `continuous_neg`. -/\ntheorem topological_semiring.to_topological_ring [topological_space α] [NonAssocRing α] (h : topological_semiring α) :\n    topological_ring α :=\n  { h,\n    (haveI := h.to_has_continuous_mul\n      topological_semiring.has_continuous_neg_of_mul :\n      has_continuous_neg α) with }\n#align topological_semiring.to_topological_ring topological_semiring.to_topological_ring\n\n",
 "quotient_map_coe_coe":
 "theorem quotient_ring.quotient_map_coe_coe : quotient_map fun p : α × α => (mk N p.1, mk N p.2) :=\n  is_open_map.to_quotient_map ((quotient_ring.is_open_map_coe N).prod (quotient_ring.is_open_map_coe N))\n    ((continuous_quot_mk.comp continuous_fst).prod_mk (continuous_quot_mk.comp continuous_snd))\n    (by rintro ⟨⟨x⟩, ⟨y⟩⟩ <;> exact ⟨(x, y), rfl⟩)\n#align quotient_ring.quotient_map_coe_coe quotient_ring.quotient_map_coe_coe\n\n",
 "of_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem topological_ring.of_nhds_zero\n    (hadd : tendsto (uncurry ((· + ·) : R → R → R)) (filter.prod ((nhds) 0) ((nhds) 0)) <| (nhds) 0)\n    (hneg : tendsto (fun x => -x : R → R) ((nhds) 0) ((nhds) 0))\n    (hmul : tendsto (uncurry ((· * ·) : R → R → R)) (filter.prod ((nhds) 0) ((nhds) 0)) <| (nhds) 0)\n    (hmul_left : ∀ x₀ : R, tendsto (fun x : R => x₀ * x) ((nhds) 0) <| (nhds) 0)\n    (hmul_right : ∀ x₀ : R, tendsto (fun x : R => x * x₀) ((nhds) 0) <| (nhds) 0)\n    (hleft : ∀ x₀ : R, (nhds) x₀ = map (fun x => x₀ + x) ((nhds) 0)) : topological_ring R :=\n  haveI := topological_add_group.of_comm_of_nhds_zero hadd hneg hleft\n  topological_ring.of_add_group_of_nhds_zero hmul hmul_left hmul_right\n#align topological_ring.of_nhds_zero topological_ring.of_nhds_zero\n\n",
 "of_add_group_of_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem topological_ring.of_add_group_of_nhds_zero [topological_add_group R]\n    (hmul : tendsto (uncurry ((· * ·) : R → R → R)) (filter.prod ((nhds) 0) ((nhds) 0)) <| (nhds) 0)\n    (hmul_left : ∀ x₀ : R, tendsto (fun x : R => x₀ * x) ((nhds) 0) <| (nhds) 0)\n    (hmul_right : ∀ x₀ : R, tendsto (fun x : R => x * x₀) ((nhds) 0) <| (nhds) 0) : topological_ring R :=\n  by\n  refine' { ‹topological_add_group R› with .. }\n  have hleft : ∀ x₀ : R, (nhds) x₀ = map (fun x => x₀ + x) ((nhds) 0) := by simp\n  have hadd : tendsto (uncurry ((· + ·) : R → R → R)) (filter.prod ((nhds) 0) ((nhds) 0)) ((nhds) 0) :=\n    by\n    rw [← nhds_prod_eq]\n    convert continuous_add.tendsto ((0 : R), (0 : R))\n    rw [zero_add]\n  rw [continuous_iff_continuous_at]\n  rintro ⟨x₀, y₀⟩\n  rw [continuous_at, nhds_prod_eq, hleft x₀, hleft y₀, hleft (x₀ * y₀), filter.prod_map_map_eq, tendsto_map'_iff]\n  suffices\n    tendsto\n      ((fun x : R => x + x₀ * y₀) ∘ (fun p : R × R => p.1 + p.2) ∘ fun p : R × R => (p.1 * y₀ + x₀ * p.2, p.1 * p.2))\n      (filter.prod ((nhds) 0) ((nhds) 0)) ((map fun x : R => x + x₀ * y₀) <| (nhds) 0)\n    by\n    convert this using 1\n    · ext\n      simp only [comp_app, mul_add, add_mul]\n      abel\n    · simp only [add_comm]\n  refine' tendsto_map.comp (hadd.comp (tendsto.prod_mk _ hmul))\n  exact hadd.comp (((hmul_right y₀).comp tendsto_fst).prod_mk ((hmul_left x₀).comp tendsto_snd))\n#align topological_ring.of_add_group_of_nhds_zero topological_ring.of_add_group_of_nhds_zero\n\n",
 "mul_right_continuous":
 "/-- In a topological semiring, the right-multiplication `add_monoid_hom` is continuous. -/\ntheorem mul_right_continuous (x : α) : continuous (AddMonoidHom.mulRight x) :=\n  continuous_id.mul continuous_const\n#align mul_right_continuous mul_right_continuous\n\n",
 "mul_left_continuous":
 "/-- In a topological semiring, the left-multiplication `add_monoid_hom` is continuous. -/\ntheorem mul_left_continuous (x : α) : continuous (AddMonoidHom.mulLeft x) :=\n  continuous_const.mul continuous_id\n#align mul_left_continuous mul_left_continuous\n\n",
 "le_topological_closure":
 "theorem subring.le_topological_closure (s : subring α) : s ≤ s.topological_closure :=\n  subset_closure\n#align subring.le_topological_closure subring.le_topological_closure\n\n",
 "is_open_map_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n-- note for the reader: in the following, `mk` is `ideal.quotient.mk`, the canonical map `R → R/I`.\ntheorem quotient_ring.is_open_map_coe : is_open_map (mk N) :=\n  by\n  intro s s_op\n  change is_open («expr ⁻¹' » (mk N) («expr '' » (mk N) s))\n  rw [quotient_ring_saturate]\n  exact is_open_Union fun ⟨n, _⟩ => is_open_map_add_left n s s_op\n#align quotient_ring.is_open_map_coe quotient_ring.is_open_map_coe\n\n",
 "is_closed_topological_closure":
 "theorem subring.is_closed_topological_closure (s : subring α) : is_closed (s.topological_closure : set α) := by\n  convert is_closed_closure\n#align subring.is_closed_topological_closure subring.is_closed_topological_closure\n\n",
 "has_continuous_neg_of_mul":
 "/-\nCopyright (c) 2018 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Johannes Hölzl\n-/\n/-- If `R` is a ring with a continuous multiplication, then negation is continuous as well since it\nis just multiplication with `-1`. -/\ntheorem topological_semiring.has_continuous_neg_of_mul [topological_space α] [NonAssocRing α] [has_continuous_mul α] :\n    has_continuous_neg α :=\n  { continuous_neg := by simpa using (continuous_const.mul continuous_id : continuous fun x : α => -1 * x) }\n#align topological_semiring.has_continuous_neg_of_mul topological_semiring.has_continuous_neg_of_mul\n\n",
 "ext'":
 "@[ext]\ntheorem ext' {f g : ring_topology α} (h : f.is_open = g.is_open) : f = g :=\n  by\n  ext\n  rw [h]\n#align ext' ext'\n\n",
 "coinduced_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprcont -/\ntheorem coinduced_continuous {α β : Type _} [t : topological_space α] [Ring β] (f : α → β) :\n    (exprcont) t (coinduced f).to_topological_space f :=\n  by\n  rw [continuous_iff_coinduced_le]\n  refine' le_infₛ _\n  rintro _ ⟨t', ht', rfl⟩\n  exact ht'\n#align coinduced_continuous coinduced_continuous\n\n",
 "coe_closure":
 "@[simp]\ntheorem ideal.coe_closure (S : ideal α) : (S.closure : set α) = closure S :=\n  rfl\n#align ideal.coe_closure ideal.coe_closure\n\n",
 "closure_eq_of_is_closed":
 "@[simp]\ntheorem ideal.closure_eq_of_is_closed (S : ideal α) [hS : is_closed (S : set α)] : S.closure = S :=\n  ideal.ext <| Set.ext_iff.mp hS.closure_eq\n#align ideal.closure_eq_of_is_closed ideal.closure_eq_of_is_closed\n\n"}