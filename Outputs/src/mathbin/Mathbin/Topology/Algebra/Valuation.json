{"to_uniform_space_eq":
 "theorem to_uniform_space_eq :\n    to_uniform_space = @topological_add_group.to_uniform_space R _ v.subgroups_basis.topology _ :=\n  uniform_space_eq ((has_basis_uniformity R Γ₀).eq_of_same_basis <| v.subgroups_basis.has_basis_nhds_zero.comap _)\n#align to_uniform_space_eq to_uniform_space_eq\n\n",
 "subgroups_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-\nCopyright (c) 2021 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot\n-/\n/-- The basis of open subgroups for the topology on a ring determined by a valuation. -/\ntheorem subgroups_basis : ring_subgroups_basis fun γ : «expr ˣ» Γ₀ => (v.lt_add_subgroup γ : add_subgroup R) :=\n  { inter := by\n      rintro γ₀ γ₁\n      use min γ₀ γ₁\n      simp [valuation.lt_add_subgroup] <;> tauto\n    mul := by\n      rintro γ\n      cases' exists_square_le γ with γ₀ h\n      use γ₀\n      rintro - ⟨r, s, r_in, s_in, rfl⟩\n      calc\n        (v (r * s) : Γ₀) = v r * v s := valuation.map_mul _ _ _\n        _ < γ₀ * γ₀ := mul_lt_mul₀ r_in s_in\n        _ ≤ γ := by exact_mod_cast h\n        \n    left_mul := by\n      rintro x γ\n      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ⟨γx, Hx⟩)\n      · use (1 : «expr ˣ» Γ₀)\n        rintro y (y_in : (v y : Γ₀) < 1)\n        change v (x * y) < _\n        rw [valuation.map_mul, Hx, zero_mul]\n        exact Units.zero_lt γ\n      · simp only [image_subset_iff, set_of_subset_set_of, preimage_set_of_eq, valuation.map_mul]\n        use γx⁻¹ * γ\n        rintro y (vy_lt : v y < ↑(γx⁻¹ * γ))\n        change (v (x * y) : Γ₀) < γ\n        rw [valuation.map_mul, Hx, mul_comm]\n        rw [Units.val_mul, mul_comm] at vy_lt\n        simpa using mul_inv_lt_of_lt_mul₀ vy_lt\n    right_mul := by\n      rintro x γ\n      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ⟨γx, Hx⟩)\n      · use 1\n        rintro y (y_in : (v y : Γ₀) < 1)\n        change v (y * x) < _\n        rw [valuation.map_mul, Hx, mul_zero]\n        exact Units.zero_lt γ\n      · use γx⁻¹ * γ\n        rintro y (vy_lt : v y < ↑(γx⁻¹ * γ))\n        change (v (y * x) : Γ₀) < γ\n        rw [valuation.map_mul, Hx]\n        rw [Units.val_mul, mul_comm] at vy_lt\n        simpa using mul_inv_lt_of_lt_mul₀ vy_lt }\n#align subgroups_basis subgroups_basis\n\n",
 "mem_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem mem_nhds_zero {s : set R} : s ∈ (nhds) (0 : R) ↔ ∃ γ : «expr ˣ» Γ₀, { x | v x < (γ : Γ₀) } ⊆ s := by\n  simp only [mem_nhds, sub_zero]\n#align mem_nhds_zero mem_nhds_zero\n\n",
 "mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem mem_nhds {s : set R} {x : R} : s ∈ (nhds) x ↔ ∃ γ : «expr ˣ» Γ₀, { y | (v (y - x) : Γ₀) < γ } ⊆ s := by\n  simp only [← nhds_translation_add_neg x, ← sub_eq_add_neg, preimage_set_of_eq, exists_true_left,\n    ((has_basis_nhds_zero R Γ₀).comap fun y => y - x).mem_iff]\n#align mem_nhds mem_nhds\n\n",
 "loc_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ (nhds) x :=\n  by\n  rw [mem_nhds]\n  rcases units.exists_iff_ne_zero.mpr h with ⟨γ, hx⟩\n  use γ\n  rw [hx]\n  intro y y_in\n  exact valuation.map_eq_of_sub_lt _ y_in\n#align loc_const loc_const\n\n",
 "has_basis_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem has_basis_uniformity :\n    ((uniformity) R).has_basis (fun _ => true) fun γ : «expr ˣ» Γ₀ => { p : R × R | v (p.2 - p.1) < (γ : Γ₀) } :=\n  by\n  rw [uniformity_eq_comap_nhds_zero]\n  exact (has_basis_nhds_zero R Γ₀).comap _\n#align has_basis_uniformity has_basis_uniformity\n\n",
 "has_basis_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem has_basis_nhds_zero :\n    ((nhds) (0 : R)).has_basis (fun _ => true) fun γ : «expr ˣ» Γ₀ => { x | v x < (γ : Γ₀) } := by\n  simp [filter.has_basis_iff, is_topological_valuation]\n#align has_basis_nhds_zero has_basis_nhds_zero\n\n",
 "cauchy_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x y «expr ∈ » M) -/\ntheorem cauchy_iff {F : filter R} :\n    cauchy F ↔ F.ne_bot ∧ ∀ γ : «expr ˣ» Γ₀, ∃ M ∈ F, ∀ (x) (_ : x ∈ M) (y) (_ : y ∈ M), (v (y - x) : Γ₀) < γ :=\n  by\n  rw [to_uniform_space_eq, add_group_filter_basis.cauchy_iff]\n  apply and_congr iff.rfl\n  simp_rw [valued.v.subgroups_basis.mem_add_group_filter_basis_iff]\n  constructor\n  · intro h γ\n    exact h _ (valued.v.subgroups_basis.mem_add_group_filter_basis _)\n  · rintro h - ⟨γ, rfl⟩\n    exact h γ\n#align cauchy_iff cauchy_iff\n\n"}