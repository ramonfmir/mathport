{"zpow_const":
 "@[to_additive uniform_continuous.const_zsmul]\ntheorem uniform_continuous.zpow_const [uniform_space β] {f : β → α} (hf : uniform_continuous f) :\n    ∀ n : ℤ, uniform_continuous fun x => f x ^ n\n  | (n : ℕ) => by\n    simp_rw [zpow_ofNat]\n    exact hf.pow_const _\n  | -[n+1] => by\n    simp_rw [zpow_negSucc]\n    exact (hf.pow_const _).inv\n#align uniform_continuous.zpow_const uniform_continuous.zpow_const\n\n",
 "uniformity_translate_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n@[to_additive]\ntheorem uniformity_translate_mul (a : α) :\n    (((uniformity) α).map fun x : α × α => (x.1 * a, x.2 * a)) = (uniformity) α :=\n  le_antisymm (uniform_continuous_id.mul uniform_continuous_const)\n    (calc\n      (uniformity) α =\n          (((uniformity) α).map fun x : α × α => (x.1 * a⁻¹, x.2 * a⁻¹)).map fun x : α × α => (x.1 * a, x.2 * a) :=\n        by simp [filter.map_map, (· ∘ ·)] <;> exact filter.map_id.symm\n      _ ≤ ((uniformity) α).map fun x : α × α => (x.1 * a, x.2 * a) :=\n        filter.map_mono (uniform_continuous_id.mul uniform_continuous_const)\n      )\n#align uniformity_translate_mul uniformity_translate_mul\n\n",
 "uniformity_of_nhds_one_swapped":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n@[to_additive]\ntheorem filter.has_basis.uniformity_of_nhds_one_swapped {ι} {p : ι → Prop} {U : ι → set α}\n    (h : ((nhds) (1 : α)).has_basis p U) : ((uniformity) α).has_basis p fun i => { x : α × α | x.1 / x.2 ∈ U i } :=\n  by\n  rw [uniformity_eq_comap_nhds_one_swapped]\n  exact h.comap _\n#align filter.has_basis.uniformity_of_nhds_one_swapped filter.has_basis.uniformity_of_nhds_one_swapped\n\n",
 "uniformity_of_nhds_one_inv_mul_swapped":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n@[to_additive]\ntheorem filter.has_basis.uniformity_of_nhds_one_inv_mul_swapped {ι} {p : ι → Prop} {U : ι → set α}\n    (h : ((nhds) (1 : α)).has_basis p U) : ((uniformity) α).has_basis p fun i => { x : α × α | x.2⁻¹ * x.1 ∈ U i } :=\n  by\n  rw [uniformity_eq_comap_inv_mul_nhds_one_swapped]\n  exact h.comap _\n#align filter.has_basis.uniformity_of_nhds_one_inv_mul_swapped filter.has_basis.uniformity_of_nhds_one_inv_mul_swapped\n\n",
 "uniformity_of_nhds_one_inv_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n@[to_additive]\ntheorem filter.has_basis.uniformity_of_nhds_one_inv_mul {ι} {p : ι → Prop} {U : ι → set α}\n    (h : ((nhds) (1 : α)).has_basis p U) : ((uniformity) α).has_basis p fun i => { x : α × α | x.1⁻¹ * x.2 ∈ U i } :=\n  by\n  rw [uniformity_eq_comap_inv_mul_nhds_one]\n  exact h.comap _\n#align filter.has_basis.uniformity_of_nhds_one_inv_mul filter.has_basis.uniformity_of_nhds_one_inv_mul\n\n",
 "uniformity_of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n@[to_additive]\ntheorem filter.has_basis.uniformity_of_nhds_one {ι} {p : ι → Prop} {U : ι → set α}\n    (h : ((nhds) (1 : α)).has_basis p U) : ((uniformity) α).has_basis p fun i => { x : α × α | x.2 / x.1 ∈ U i } :=\n  by\n  rw [uniformity_eq_comap_nhds_one]\n  exact h.comap _\n#align filter.has_basis.uniformity_of_nhds_one filter.has_basis.uniformity_of_nhds_one\n\n",
 "uniformity_eq_comap_nhds_one_swapped":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem uniformity_eq_comap_nhds_one_swapped : (uniformity) α = comap (fun x : α × α => x.1 / x.2) ((nhds) (1 : α)) :=\n  by\n  rw [← comap_swap_uniformity, uniformity_eq_comap_nhds_one, comap_comap, (· ∘ ·)]\n  rfl\n#align uniformity_eq_comap_nhds_one_swapped uniformity_eq_comap_nhds_one_swapped\n\n",
 "uniformity_eq_comap_nhds_one'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem uniformity_eq_comap_nhds_one' : (uniformity) G = comap (fun p : G × G => p.2 / p.1) ((nhds) (1 : G)) :=\n  rfl\n#align uniformity_eq_comap_nhds_one' uniformity_eq_comap_nhds_one'\n\n",
 "uniformity_eq_comap_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem uniformity_eq_comap_nhds_one : (uniformity) α = comap (fun x : α × α => x.2 / x.1) ((nhds) (1 : α)) :=\n  by\n  rw [nhds_eq_comap_uniformity, filter.comap_comap]\n  refine' le_antisymm (filter.map_le_iff_le_comap.1 _) _\n  · intro s hs\n    rcases mem_uniformity_of_uniform_continuous_invariant uniform_continuous_div hs with ⟨t, ht, hts⟩\n    refine' mem_map.2 (mem_of_superset ht _)\n    rintro ⟨a, b⟩\n    simpa [subset_def] using hts a b a\n  · intro s hs\n    rcases mem_uniformity_of_uniform_continuous_invariant uniform_continuous_mul hs with ⟨t, ht, hts⟩\n    refine' ⟨_, ht, _⟩\n    rintro ⟨a, b⟩\n    simpa [subset_def] using hts 1 (b / a) a\n#align uniformity_eq_comap_nhds_one uniformity_eq_comap_nhds_one\n\n",
 "uniformity_eq_comap_inv_mul_nhds_one_swapped":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem uniformity_eq_comap_inv_mul_nhds_one_swapped :\n    (uniformity) α = comap (fun x : α × α => x.2⁻¹ * x.1) ((nhds) (1 : α)) :=\n  by\n  rw [← comap_swap_uniformity, uniformity_eq_comap_inv_mul_nhds_one, comap_comap, (· ∘ ·)]\n  rfl\n#align uniformity_eq_comap_inv_mul_nhds_one_swapped uniformity_eq_comap_inv_mul_nhds_one_swapped\n\n",
 "uniformity_eq_comap_inv_mul_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem uniformity_eq_comap_inv_mul_nhds_one : (uniformity) α = comap (fun x : α × α => x.1⁻¹ * x.2) ((nhds) (1 : α)) :=\n  by\n  rw [← comap_uniformity_mul_opposite, uniformity_eq_comap_nhds_one, ← op_one, ← comap_unop_nhds, comap_comap,\n    comap_comap]\n  simp [(· ∘ ·)]\n#align uniformity_eq_comap_inv_mul_nhds_one uniformity_eq_comap_inv_mul_nhds_one\n\n",
 "uniformity_countably_generated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n@[to_additive]\ntheorem uniform_group.uniformity_countably_generated [((nhds) (1 : α)).is_countably_generated] :\n    ((uniformity) α).is_countably_generated :=\n  by\n  rw [uniformity_eq_comap_nhds_one]\n  exact filter.comap.is_countably_generated _ _\n#align uniform_group.uniformity_countably_generated uniform_group.uniformity_countably_generated\n\n",
 "uniform_group_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[to_additive]\ntheorem uniform_group_infi {ι : Sort _} {us' : ι → uniform_space β} (h' : ∀ i, @uniform_group β (us' i) _) :\n    @uniform_group β\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (us' i)) _ :=\n  by\n  rw [← infₛ_range]\n  exact uniform_group_Inf (set.forall_range_iff.mpr h')\n#align uniform_group_infi uniform_group_infi\n\n",
 "uniform_group_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem uniform_group_inf {u₁ u₂ : uniform_space β} (h₁ : @uniform_group β u₁ _) (h₂ : @uniform_group β u₂ _) :\n    @uniform_group β («expr ⊓ » u₁ u₂) _ := by\n  rw [inf_eq_infᵢ]\n  refine' uniform_group_infi fun b => _\n  cases b <;> assumption\n#align uniform_group_inf uniform_group_inf\n\n",
 "uniform_group_comap":
 "@[to_additive]\ntheorem uniform_group_comap {γ : Type _} [group γ] {u : uniform_space γ} [uniform_group γ] {F : Type _}\n    [MonoidHomClass F β γ] (f : F) : @uniform_group β (u.comap f) _ :=\n  {\n    uniform_continuous_div := by\n      letI : uniform_space β := u.comap f\n      refine' uniform_continuous_comap' _\n      simp_rw [function.comp, map_div]\n      change uniform_continuous ((fun p : γ × γ => p.1 / p.2) ∘ prod.map f f)\n      exact uniform_continuous_div.comp (uniform_continuous_comap.prod_map uniform_continuous_comap) }\n#align uniform_group_comap uniform_group_comap\n\n",
 "uniform_group_Inf":
 "@[to_additive]\ntheorem uniform_group_Inf {us : set (uniform_space β)} (h : ∀ u ∈ us, @uniform_group β u _) :\n    @uniform_group β (infₛ us) _ :=\n  {\n    uniform_continuous_div :=\n      uniform_continuous_Inf_rng fun u hu =>\n        uniform_continuous_Inf_dom₂ hu hu (@uniform_group.uniform_continuous_div β u _ (h u hu)) }\n#align uniform_group_Inf uniform_group_Inf\n\n",
 "uniform_embedding_translate_mul":
 "/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:132:4: warning: unsupported: rw with cfg: { occs := occurrences.pos[occurrences.pos] «expr[ ,]»([1]) } -/\n@[to_additive]\ntheorem uniform_embedding_translate_mul (a : α) : uniform_embedding fun x : α => x * a :=\n  { comap_uniformity := by\n      rw [← uniformity_translate_mul a, comap_map]\n      rintro ⟨p₁, p₂⟩ ⟨q₁, q₂⟩\n      simp (config := { contextual := true }) [prod.eq_iff_fst_eq_snd_eq]\n    inj := mul_left_injective a }\n#align uniform_embedding_translate_mul uniform_embedding_translate_mul\n\n",
 "uniform_continuous_zpow_const":
 "@[to_additive uniform_continuous_const_zsmul]\ntheorem uniform_continuous_zpow_const (n : ℤ) : uniform_continuous fun x : α => x ^ n :=\n  uniform_continuous_id.zpow_const n\n#align uniform_continuous_zpow_const uniform_continuous_zpow_const\n\n",
 "uniform_continuous_pow_const":
 "@[to_additive uniform_continuous_const_nsmul]\ntheorem uniform_continuous_pow_const (n : ℕ) : uniform_continuous fun x : α => x ^ n :=\n  uniform_continuous_id.pow_const n\n#align uniform_continuous_pow_const uniform_continuous_pow_const\n\n",
 "uniform_continuous_of_tendsto_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem uniform_continuous_of_tendsto_one {hom : Type _} [uniform_space β] [group β] [uniform_group β]\n    [MonoidHomClass hom α β] {f : hom} (h : tendsto f ((nhds) 1) ((nhds) 1)) : uniform_continuous f :=\n  by\n  have : ((fun x : β × β => x.2 / x.1) ∘ fun x : α × α => (f x.1, f x.2)) = fun x : α × α => f (x.2 / x.1) := by\n    simp only [map_div]\n  rw [uniform_continuous, uniformity_eq_comap_nhds_one α, uniformity_eq_comap_nhds_one β, tendsto_comap_iff, this]\n  exact tendsto.comp h tendsto_comap\n#align uniform_continuous_of_tendsto_one uniform_continuous_of_tendsto_one\n\n",
 "uniform_continuous_of_continuous_at_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem monoid_hom.uniform_continuous_of_continuous_at_one [uniform_space β] [group β] [uniform_group β]\n    (f : «expr →* » α β) (hf : continuous_at f 1) : uniform_continuous f :=\n  uniform_continuous_of_continuous_at_one f hf\n#align monoid_hom.uniform_continuous_of_continuous_at_one monoid_hom.uniform_continuous_of_continuous_at_one\n\n",
 "uniform_continuous_mul":
 "@[to_additive]\ntheorem uniform_continuous_mul : uniform_continuous fun p : α × α => p.1 * p.2 :=\n  uniform_continuous_fst.mul uniform_continuous_snd\n#align uniform_continuous_mul uniform_continuous_mul\n\n",
 "uniform_continuous_monoid_hom_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem uniform_continuous_monoid_hom_of_continuous {hom : Type _} [uniform_space β] [group β] [uniform_group β]\n    [MonoidHomClass hom α β] {f : hom} (h : continuous f) : uniform_continuous f :=\n  uniform_continuous_of_tendsto_one <|\n    suffices tendsto f ((nhds) 1) ((nhds) (f 1)) by rwa [map_one] at this\n    h.tendsto 1\n#align uniform_continuous_monoid_hom_of_continuous uniform_continuous_monoid_hom_of_continuous\n\n",
 "uniform_continuous_inv":
 "@[to_additive]\ntheorem uniform_continuous_inv : uniform_continuous fun x : α => x⁻¹ :=\n  uniform_continuous_id.inv\n#align uniform_continuous_inv uniform_continuous_inv\n\n",
 "uniform_continuous_iff_open_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- A homomorphism from a uniform group to a discrete uniform group is continuous if and only if\nits kernel is open. -/\n@[to_additive\n      \"A homomorphism from a uniform additive group to a discrete uniform additive group is\\ncontinuous if and only if its kernel is open.\"]\ntheorem uniform_group.uniform_continuous_iff_open_ker {hom : Type _} [uniform_space β] [discrete_topology β] [group β]\n    [uniform_group β] [MonoidHomClass hom α β] {f : hom} :\n    uniform_continuous f ↔ is_open ((f : «expr →* » α β).ker : set α) :=\n  by\n  refine' ⟨fun hf => _, fun hf => _⟩\n  · apply (is_open_discrete ({1} : set β)).preimage (uniform_continuous.continuous hf)\n  · apply uniform_continuous_of_continuous_at_one\n    rw [continuous_at, nhds_discrete β, map_one, tendsto_pure]\n    exact hf.mem_nhds (map_one f)\n#align uniform_group.uniform_continuous_iff_open_ker uniform_group.uniform_continuous_iff_open_ker\n\n",
 "uniform_continuous_div":
 "@[to_additive]\ntheorem uniform_continuous_div : uniform_continuous fun p : α × α => p.1 / p.2 :=\n  uniform_group.uniform_continuous_div\n#align uniform_continuous_div uniform_continuous_div\n\n",
 "totally_bounded_iff_subset_finite_Union_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem totally_bounded_iff_subset_finite_Union_nhds_one {s : set α} :\n    totally_bounded s ↔\n      ∀ U ∈ (nhds) (1 : α),\n        ∃ t : set α,\n          t.finite ∧\n            s ⊆\n              «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                («expr • » y U) :=\n  ((nhds) (1 : α)).basis_sets.uniformity_of_nhds_one_inv_mul_swapped.totally_bounded_iff.trans <| by\n    simp [← preimage_smul_inv, preimage]\n#align totally_bounded_iff_subset_finite_Union_nhds_one totally_bounded_iff_subset_finite_Union_nhds_one\n\n",
 "topological_group_is_uniform_of_compact_space":
 "@[to_additive]\ntheorem topological_group_is_uniform_of_compact_space [compact_space G] : uniform_group G :=\n  ⟨by\n    apply compact_space.uniform_continuous_of_continuous\n    exact continuous_div'⟩\n#align topological_group_is_uniform_of_compact_space topological_group_is_uniform_of_compact_space\n\n",
 "topological_comm_group_is_uniform":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem topological_comm_group_is_uniform : uniform_group G :=\n  by\n  have :\n    tendsto ((fun p : G × G => p.1 / p.2) ∘ fun p : (G × G) × G × G => (p.1.2 / p.1.1, p.2.2 / p.2.1))\n      (comap (fun p : (G × G) × G × G => (p.1.2 / p.1.1, p.2.2 / p.2.1)) (((nhds) 1).prod ((nhds) 1)))\n      ((nhds) (1 / 1)) :=\n    (tendsto_fst.div' tendsto_snd).comp tendsto_comap\n  constructor\n  rw [uniform_continuous, uniformity_prod_eq_prod, tendsto_map'_iff, uniformity_eq_comap_nhds_one' G, tendsto_comap_iff,\n    prod_comap_comap_eq]\n  simpa [(· ∘ ·), div_eq_mul_inv, mul_comm, mul_left_comm] using this\n#align topological_comm_group_is_uniform topological_comm_group_is_uniform\n\n",
 "to_uniform_space_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n@[to_additive]\ntheorem uniform_group.to_uniform_space_eq {G : Type _} [u : uniform_space G] [group G] [uniform_group G] :\n    topological_group.to_uniform_space G = u := by\n  ext : 1\n  show @uniformity G (topological_group.to_uniform_space G) = (uniformity) G\n  rw [uniformity_eq_comap_nhds_one' G, uniformity_eq_comap_nhds_one G]\n#align uniform_group.to_uniform_space_eq uniform_group.to_uniform_space_eq\n\n",
 "tendsto_uniformly_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[to_additive]\ntheorem topological_group.tendsto_uniformly_on_iff {ι α : Type _} (F : ι → α → G) (f : α → G) (p : filter ι)\n    (s : set α) :\n    @tendsto_uniformly_on α G ι (topological_group.to_uniform_space G) F f p s ↔\n      ∀ u ∈ (nhds) (1 : G),\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n          (∀ a ∈ s, F i a / f a ∈ u) :=\n  ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩, fun h v ⟨u, hu, hv⟩ =>\n    mem_of_superset (h u hu) fun i hi a ha => hv (hi a ha)⟩\n#align topological_group.tendsto_uniformly_on_iff topological_group.tendsto_uniformly_on_iff\n\n",
 "tendsto_uniformly_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[to_additive]\ntheorem topological_group.tendsto_uniformly_iff {ι α : Type _} (F : ι → α → G) (f : α → G) (p : filter ι) :\n    @tendsto_uniformly α G ι (topological_group.to_uniform_space G) F f p ↔\n      ∀ u ∈ (nhds) (1 : G),\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n          (∀ a, F i a / f a ∈ u) :=\n  ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩, fun h v ⟨u, hu, hv⟩ => mem_of_superset (h u hu) fun i hi a => hv (hi a)⟩\n#align topological_group.tendsto_uniformly_iff topological_group.tendsto_uniformly_iff\n\n",
 "tendsto_locally_uniformly_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[to_additive]\ntheorem topological_group.tendsto_locally_uniformly_on_iff {ι α : Type _} [topological_space α] (F : ι → α → G)\n    (f : α → G) (p : filter ι) (s : set α) :\n    @tendsto_locally_uniformly_on α G ι (topological_group.to_uniform_space G) _ F f p s ↔\n      ∀ u ∈ (nhds) (1 : G),\n        ∀ x ∈ s,\n          ∃ t ∈ nhds_within s x,\n            «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n              (∀ a ∈ t, F i a / f a ∈ u) :=\n  ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩, fun h v ⟨u, hu, hv⟩ x =>\n    (Exists.imp fun a => Exists.imp fun ha hp => mem_of_superset hp fun i hi a ha => hv (hi a ha)) ∘ h u hu x⟩\n#align topological_group.tendsto_locally_uniformly_on_iff topological_group.tendsto_locally_uniformly_on_iff\n\n",
 "tendsto_locally_uniformly_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[to_additive]\ntheorem topological_group.tendsto_locally_uniformly_iff {ι α : Type _} [topological_space α] (F : ι → α → G) (f : α → G)\n    (p : filter ι) :\n    @tendsto_locally_uniformly α G ι (topological_group.to_uniform_space G) _ F f p ↔\n      ∀ u ∈ (nhds) (1 : G),\n        ∀ (x : α),\n          ∃ t ∈ (nhds) x,\n            «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n              (∀ a ∈ t, F i a / f a ∈ u) :=\n  ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩, fun h v ⟨u, hu, hv⟩ x =>\n    Exists.imp (fun a => Exists.imp fun ha hp => mem_of_superset hp fun i hi a ha => hv (hi a ha)) (h u hu x)⟩\n#align topological_group.tendsto_locally_uniformly_iff topological_group.tendsto_locally_uniformly_iff\n\n",
 "tendsto_div_comap_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n-- β is a dense subgroup of α, inclusion is denoted by e\n@[to_additive]\ntheorem tendsto_div_comap_self (x₀ : α) :\n    tendsto (fun t : β × β => t.2 / t.1) ((comap fun p : β × β => (e p.1, e p.2)) <| (nhds) (x₀, x₀)) ((nhds) 1) :=\n  by\n  have comm : ((fun x : α × α => x.2 / x.1) ∘ fun t : β × β => (e t.1, e t.2)) = e ∘ fun t : β × β => t.2 / t.1 :=\n    by\n    ext t\n    change e t.2 / e t.1 = e (t.2 / t.1)\n    rwa [← map_div e t.2 t.1]\n  have lim : tendsto (fun x : α × α => x.2 / x.1) ((nhds) (x₀, x₀)) ((nhds) (e 1)) := by\n    simpa using (continuous_div'.comp (@continuous_swap α α _ _)).tendsto (x₀, x₀)\n  simpa using de.tendsto_comap_nhds_nhds lim comm\n#align tendsto_div_comap_self tendsto_div_comap_self\n\n",
 "t2_space_of_one_sep":
 "@[to_additive]\ntheorem topological_group.t2_space_of_one_sep (H : ∀ x : G, x ≠ 1 → ∃ U ∈ nhds (1 : G), x ∉ U) : t2_space G :=\n  by\n  rw [topological_group.t2_space_iff_one_closed, ← is_open_compl_iff, is_open_iff_mem_nhds]\n  intro x x_not\n  have : x ≠ 1 := mem_compl_singleton_iff.mp x_not\n  rcases H x this with ⟨U, U_in, xU⟩\n  rw [← nhds_one_symm G] at U_in\n  rcases U_in with ⟨W, W_in, UW⟩\n  rw [← nhds_translation_mul_inv]\n  use W, W_in\n  rw [subset_compl_comm]\n  suffices x⁻¹ ∉ W by simpa\n  exact fun h => xU (UW h)\n#align topological_group.t2_space_of_one_sep topological_group.t2_space_of_one_sep\n\n",
 "t2_space_iff_one_closed":
 "@[to_additive]\ntheorem topological_group.t2_space_iff_one_closed : t2_space G ↔ is_closed ({1} : set G) :=\n  by\n  haveI : uniform_group G := topological_comm_group_is_uniform\n  rw [← separated_iff_t2, separated_space_iff, ← closure_eq_iff_is_closed]\n  constructor <;> intro h\n  · apply subset.antisymm\n    · intro x x_in\n      have := group_separation_rel x 1\n      rw [div_one] at this\n      rw [← this, h] at x_in\n      change x = 1 at x_in\n      simp [x_in]\n    · exact subset_closure\n  · ext p\n    cases' p with x y\n    rw [group_separation_rel x, h, mem_singleton_iff, div_eq_one]\n    rfl\n#align topological_group.t2_space_iff_one_closed topological_group.t2_space_iff_one_closed\n\n",
 "pow_const":
 "@[to_additive uniform_continuous.const_nsmul]\ntheorem uniform_continuous.pow_const [uniform_space β] {f : β → α} (hf : uniform_continuous f) :\n    ∀ n : ℕ, uniform_continuous fun x => f x ^ n\n  | 0 => by\n    simp_rw [pow_zero]\n    exact uniform_continuous_const\n  | n + 1 => by\n    simp_rw [pow_succ]\n    exact hf.mul (uniform_continuous.pow_const n)\n#align uniform_continuous.pow_const uniform_continuous.pow_const\n\n",
 "mul_const":
 "@[to_additive]\ntheorem cauchy_seq.mul_const {ι : Type _} [SemilatticeSup ι] {u : ι → α} {x : α} (hu : cauchy_seq u) :\n    cauchy_seq fun n => u n * x :=\n  (uniform_continuous_id.mul uniform_continuous_const).comp_cauchy_seq hu\n#align cauchy_seq.mul_const cauchy_seq.mul_const\n\n",
 "mul":
 "@[to_additive]\ntheorem uniform_cauchy_seq_on.mul (hf : uniform_cauchy_seq_on f l s) (hf' : uniform_cauchy_seq_on f' l s) :\n    uniform_cauchy_seq_on (f * f') l s := fun u hu => by\n  simpa using (uniform_continuous_mul.comp_uniform_cauchy_seq_on (hf.prod' hf')) u hu\n#align uniform_cauchy_seq_on.mul uniform_cauchy_seq_on.mul\n\n",
 "mk'":
 "/-\nCopyright (c) 2018 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Johannes Hölzl\n-/\n@[to_additive]\ntheorem uniform_group.mk' {α} [uniform_space α] [group α] (h₁ : uniform_continuous fun p : α × α => p.1 * p.2)\n    (h₂ : uniform_continuous fun p : α => p⁻¹) : uniform_group α :=\n  ⟨by simpa only [div_eq_mul_inv] using h₁.comp (uniform_continuous_fst.prod_mk (h₂.comp uniform_continuous_snd))⟩\n#align uniform_group.mk' uniform_group.mk'\n\n",
 "inv":
 "@[to_additive]\ntheorem cauchy_seq.inv {ι : Type _} [SemilatticeSup ι] {u : ι → α} (h : cauchy_seq u) : cauchy_seq u⁻¹ :=\n  uniform_continuous_inv.comp_cauchy_seq h\n#align cauchy_seq.inv cauchy_seq.inv\n\n",
 "group_separation_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n@[to_additive]\ntheorem group_separation_rel (x y : α) : (x, y) ∈ separation_rel α ↔ x / y ∈ closure ({1} : set α) :=\n  have : embedding fun a => a * (y / x) := (uniform_embedding_translate_mul (y / x)).embedding\n  show (x, y) ∈ «expr⋂₀ » ((uniformity) α).sets ↔ x / y ∈ closure ({1} : set α)\n    by\n    rw [this.closure_eq_preimage_closure_image, uniformity_eq_comap_nhds_one α, sInter_comap_sets]\n    simp [mem_closure_iff_nhds, inter_singleton_nonempty, sub_eq_add_neg, add_assoc]\n#align group_separation_rel group_separation_rel\n\n",
 "extend_Z_bilin_key":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x x' «expr ∈ » U₁) -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (y y' «expr ∈ » V₁) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x x' «expr ∈ » U) -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (y y' «expr ∈ » V) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\nprivate theorem extend_Z_bilin_key (x₀ : α) (y₀ : γ) :\n    ∃ U ∈ comap e ((nhds) x₀),\n      ∃ V ∈ comap f ((nhds) y₀),\n        ∀ (x) (_ : x ∈ U) (x') (_ : x' ∈ U),\n          ∀ (y) (_ : y ∈ V) (y') (_ : y' ∈ V), (exprΦ) (x', y') - (exprΦ) (x, y) ∈ W' :=\n  by\n  let Nx := (nhds) x₀\n  let Ny := (nhds) y₀\n  let dp := dense_inducing.prod de df\n  let ee := fun u : β × β => (e u.1, e u.2)\n  let ff := fun u : δ × δ => (f u.1, f u.2)\n  have lim_φ : filter.tendsto (exprΦ) ((nhds) (0, 0)) ((nhds) 0) := by simpa using hφ.tendsto (0, 0)\n  have lim_φ_sub_sub :\n    tendsto (fun p : (β × β) × δ × δ => (exprΦ) (p.1.2 - p.1.1, p.2.2 - p.2.1))\n      (filter.prod (comap ee <| (nhds) (x₀, x₀)) (comap ff <| (nhds) (y₀, y₀))) ((nhds) 0) :=\n    by\n    have lim_sub_sub :\n      tendsto (fun p : (β × β) × δ × δ => (p.1.2 - p.1.1, p.2.2 - p.2.1))\n        (filter.prod (comap ee ((nhds) (x₀, x₀))) (comap ff ((nhds) (y₀, y₀)))) (filter.prod ((nhds) 0) ((nhds) 0)) :=\n      by\n      have := filter.prod_mono (tendsto_sub_comap_self de x₀) (tendsto_sub_comap_self df y₀)\n      rwa [prod_map_map_eq] at this\n    rw [← nhds_prod_eq] at lim_sub_sub\n    exact tendsto.comp lim_φ lim_sub_sub\n  rcases exists_nhds_zero_quarter W'_nhd with ⟨W, W_nhd, W4⟩\n  have :\n    ∃ U₁ ∈ comap e ((nhds) x₀),\n      ∃ V₁ ∈ comap f ((nhds) y₀),\n        ∀ (x) (_ : x ∈ U₁) (x') (_ : x' ∈ U₁), ∀ (y) (_ : y ∈ V₁) (y') (_ : y' ∈ V₁), (exprΦ) (x' - x, y' - y) ∈ W :=\n    by\n    have := tendsto_prod_iff.1 lim_φ_sub_sub W W_nhd\n    repeat' rw [nhds_prod_eq, ← prod_comap_comap_eq] at this\n    rcases this with ⟨U, U_in, V, V_in, H⟩\n    rw [mem_prod_same_iff] at U_in V_in\n    rcases U_in with ⟨U₁, U₁_in, HU₁⟩\n    rcases V_in with ⟨V₁, V₁_in, HV₁⟩\n    exists U₁, U₁_in, V₁, V₁_in\n    intro x x_in x' x'_in y y_in y' y'_in\n    exact H _ _ (HU₁ (mk_mem_prod x_in x'_in)) (HV₁ (mk_mem_prod y_in y'_in))\n  rcases this with ⟨U₁, U₁_nhd, V₁, V₁_nhd, H⟩\n  obtain ⟨x₁, x₁_in⟩ : U₁.nonempty := (de.comap_nhds_ne_bot _).nonempty_of_mem U₁_nhd\n  obtain ⟨y₁, y₁_in⟩ : V₁.nonempty := (df.comap_nhds_ne_bot _).nonempty_of_mem V₁_nhd\n  have cont_flip : continuous fun p : δ × β => φ.flip p.1 p.2 :=\n    by\n    show continuous (exprΦ ∘ prod.swap)\n    exact hφ.comp continuous_swap\n  rcases extend_Z_bilin_aux de df hφ W_nhd x₀ y₁ with ⟨U₂, U₂_nhd, HU⟩\n  rcases extend_Z_bilin_aux df de cont_flip W_nhd y₀ x₁ with ⟨V₂, V₂_nhd, HV⟩\n  exists U₁ ∩ U₂, inter_mem U₁_nhd U₂_nhd, V₁ ∩ V₂, inter_mem V₁_nhd V₂_nhd\n  rintro x ⟨xU₁, xU₂⟩ x' ⟨x'U₁, x'U₂⟩ y ⟨yV₁, yV₂⟩ y' ⟨y'V₁, y'V₂⟩\n  have key_formula : φ x' y' - φ x y = φ (x' - x) y₁ + φ (x' - x) (y' - y₁) + φ x₁ (y' - y) + φ (x - x₁) (y' - y) :=\n    by\n    simp\n    abel\n  rw [key_formula]\n  have h₁ := HU x xU₂ x' x'U₂\n  have h₂ := H x xU₁ x' x'U₁ y₁ y₁_in y' y'V₁\n  have h₃ := HV y yV₂ y' y'V₂\n  have h₄ := H x₁ x₁_in x xU₁ y yV₁ y' y'V₁\n  exact W4 h₁ h₂ h₃ h₄\n#align extend_Z_bilin_key extend_Z_bilin_key\n\n",
 "extend_Z_bilin_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x x' «expr ∈ » U₂) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n-- β is a dense subgroup of α, inclusion is denoted by e\n-- δ is a dense subgroup of γ, inclusion is denoted by f\nprivate theorem extend_Z_bilin_aux (x₀ : α) (y₁ : δ) :\n    ∃ U₂ ∈ comap e ((nhds) x₀), ∀ (x) (_ : x ∈ U₂) (x') (_ : x' ∈ U₂), (exprΦ) (x' - x, y₁) ∈ W' :=\n  by\n  let Nx := (nhds) x₀\n  let ee := fun u : β × β => (e u.1, e u.2)\n  have lim1 : tendsto (fun a : β × β => (a.2 - a.1, y₁)) (filter.prod (comap e Nx) (comap e Nx)) ((nhds) (0, y₁)) :=\n    by\n    have :=\n      tendsto.prod_mk (tendsto_sub_comap_self de x₀)\n        (tendsto_const_nhds : tendsto (fun p : β × β => y₁) (comap ee <| (nhds) (x₀, x₀)) ((nhds) y₁))\n    rw [nhds_prod_eq, prod_comap_comap_eq, ← nhds_prod_eq]\n    exact (this : _)\n  have lim2 : tendsto (exprΦ) ((nhds) (0, y₁)) ((nhds) 0) := by simpa using hφ.tendsto (0, y₁)\n  have lim := lim2.comp lim1\n  rw [tendsto_prod_self_iff] at lim\n  simp_rw [ball_mem_comm]\n  exact lim W' W'_nhd\n#align extend_Z_bilin_aux extend_Z_bilin_aux\n\n",
 "extend_Z_bilin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/-- Bourbaki GT III.6.5 Theorem I:\nℤ-bilinear continuous maps from dense images into a complete Hausdorff group extend by continuity.\nNote: Bourbaki assumes that α and β are also complete Hausdorff, but this is not necessary. -/\ntheorem extend_Z_bilin : continuous (extend (de.prod df) (exprΦ)) :=\n  by\n  refine' continuous_extend_of_cauchy _ _\n  rintro ⟨x₀, y₀⟩\n  constructor\n  · apply ne_bot.map\n    apply comap_ne_bot\n    intro U h\n    rcases mem_closure_iff_nhds.1 ((de.prod df).dense (x₀, y₀)) U h with ⟨x, x_in, ⟨z, z_x⟩⟩\n    exists z\n    cc\n  · suffices\n      map (fun p : (β × δ) × β × δ => (exprΦ) p.2 - (exprΦ) p.1)\n          (comap (fun p : (β × δ) × β × δ => ((e p.1.1, f p.1.2), (e p.2.1, f p.2.2)))\n            (filter.prod ((nhds) (x₀, y₀)) ((nhds) (x₀, y₀)))) ≤\n        (nhds) 0\n      by\n      rwa [uniformity_eq_comap_nhds_zero G, prod_map_map_eq, ← map_le_iff_le_comap, filter.map_map, prod_comap_comap_eq]\n    intro W' W'_nhd\n    have key := extend_Z_bilin_key de df hφ W'_nhd x₀ y₀\n    rcases key with ⟨U, U_nhd, V, V_nhd, h⟩\n    rw [mem_comap] at U_nhd\n    rcases U_nhd with ⟨U', U'_nhd, U'_sub⟩\n    rw [mem_comap] at V_nhd\n    rcases V_nhd with ⟨V', V'_nhd, V'_sub⟩\n    rw [mem_map, mem_comap, nhds_prod_eq]\n    exists lower_set.prod (lower_set.prod U' V') (lower_set.prod U' V')\n    rw [mem_prod_same_iff]\n    simp only [exists_prop]\n    constructor\n    · change U' ∈ (nhds) x₀ at U'_nhd\n      change V' ∈ (nhds) y₀ at V'_nhd\n      have := prod_mem_prod U'_nhd V'_nhd\n      tauto\n    · intro p h'\n      simp only [Set.mem_preimage, Set.prod_mk_mem_set_prod_eq] at h'\n      rcases p with ⟨⟨x, y⟩, ⟨x', y'⟩⟩\n      apply h <;> tauto\n#align extend_Z_bilin extend_Z_bilin\n\n",
 "ext_iff":
 "@[to_additive]\ntheorem uniform_group.ext_iff {G : Type _} [group G] {u v : uniform_space G} (hu : @uniform_group G u _)\n    (hv : @uniform_group G v _) : u = v ↔ @nhds _ u.to_topological_space 1 = @nhds _ v.to_topological_space 1 :=\n  ⟨fun h => h ▸ rfl, hu.ext hv⟩\n#align uniform_group.ext_iff uniform_group.ext_iff\n\n",
 "ext":
 "@[to_additive]\ntheorem uniform_group.ext {G : Type _} [group G] {u v : uniform_space G} (hu : @uniform_group G u _)\n    (hv : @uniform_group G v _) (h : @nhds _ u.to_topological_space 1 = @nhds _ v.to_topological_space 1) : u = v :=\n  by\n  refine' uniform_space_eq _\n  change @uniformity _ u = @uniformity _ v\n  rw [@uniformity_eq_comap_nhds_one _ u _ hu, @uniformity_eq_comap_nhds_one _ v _ hv, h]\n#align uniform_group.ext uniform_group.ext\n\n",
 "div":
 "@[to_additive]\ntheorem uniform_cauchy_seq_on.div (hf : uniform_cauchy_seq_on f l s) (hf' : uniform_cauchy_seq_on f' l s) :\n    uniform_cauchy_seq_on (f / f') l s := fun u hu => by\n  simpa using (uniform_continuous_div.comp_uniform_cauchy_seq_on (hf.prod' hf')) u hu\n#align uniform_cauchy_seq_on.div uniform_cauchy_seq_on.div\n\n",
 "const_mul":
 "@[to_additive]\ntheorem cauchy_seq.const_mul {ι : Type _} [SemilatticeSup ι] {u : ι → α} {x : α} (hu : cauchy_seq u) :\n    cauchy_seq fun n => x * u n :=\n  (uniform_continuous_const.mul uniform_continuous_id).comp_cauchy_seq hu\n#align cauchy_seq.const_mul cauchy_seq.const_mul\n\n"}