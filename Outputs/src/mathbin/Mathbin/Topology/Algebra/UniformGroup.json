{"zpow_const":
 "#print UniformContinuous.zpow_const /-\n@[to_additive UniformContinuous.const_zsmul]\ntheorem UniformContinuous.zpow_const [UniformSpace β] {f : β → α} (hf : UniformContinuous f) :\n    ∀ n : ℤ, UniformContinuous fun x => f x ^ n\n  | (n : ℕ) => by\n    simp_rw [zpow_ofNat]\n    exact hf.pow_const _\n  | -[n+1] => by\n    simp_rw [zpow_negSucc]\n    exact (hf.pow_const _).inv\n#align uniform_continuous.zpow_const UniformContinuous.zpow_const\n#align uniform_continuous.const_zsmul UniformContinuous.const_zsmul\n-/\n\n",
 "uniformity_translate_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_translate_mul /-\n@[to_additive]\ntheorem uniformity_translate_mul (a : α) :\n    (((uniformity) α).map fun x : α × α => (x.1 * a, x.2 * a)) = (uniformity) α :=\n  le_antisymm (uniformContinuous_id.mul uniformContinuous_const)\n    (calc\n      (uniformity) α =\n          (((uniformity) α).map fun x : α × α => (x.1 * a⁻¹, x.2 * a⁻¹)).map fun x : α × α => (x.1 * a, x.2 * a) :=\n        by simp [Filter.map_map, (· ∘ ·)] <;> exact filter.map_id.symm\n      _ ≤ ((uniformity) α).map fun x : α × α => (x.1 * a, x.2 * a) :=\n        Filter.map_mono (uniformContinuous_id.mul uniformContinuous_const)\n      )\n#align uniformity_translate_mul uniformity_translate_mul\n#align uniformity_translate_add uniformity_translate_add\n-/\n\n",
 "uniformity_of_nhds_one_swapped":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.uniformity_of_nhds_one_swapped /-\n@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one_swapped {ι} {p : ι → Prop} {U : ι → Set α}\n    (h : ((nhds) (1 : α)).has_basis p U) : ((uniformity) α).has_basis p fun i => { x : α × α | x.1 / x.2 ∈ U i } :=\n  by\n  rw [uniformity_eq_comap_nhds_one_swapped]\n  exact h.comap _\n#align filter.has_basis.uniformity_of_nhds_one_swapped Filter.HasBasis.uniformity_of_nhds_one_swapped\n#align filter.has_basis.uniformity_of_nhds_zero_swapped Filter.HasBasis.uniformity_of_nhds_zero_swapped\n-/\n\n",
 "uniformity_of_nhds_one_inv_mul_swapped":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.uniformity_of_nhds_one_inv_mul_swapped /-\n@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one_inv_mul_swapped {ι} {p : ι → Prop} {U : ι → Set α}\n    (h : ((nhds) (1 : α)).has_basis p U) : ((uniformity) α).has_basis p fun i => { x : α × α | x.2⁻¹ * x.1 ∈ U i } :=\n  by\n  rw [uniformity_eq_comap_inv_mul_nhds_one_swapped]\n  exact h.comap _\n#align filter.has_basis.uniformity_of_nhds_one_inv_mul_swapped Filter.HasBasis.uniformity_of_nhds_one_inv_mul_swapped\n#align filter.has_basis.uniformity_of_nhds_zero_neg_add_swapped Filter.HasBasis.uniformity_of_nhds_zero_neg_add_swapped\n-/\n\n",
 "uniformity_of_nhds_one_inv_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.uniformity_of_nhds_one_inv_mul /-\n@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one_inv_mul {ι} {p : ι → Prop} {U : ι → Set α}\n    (h : ((nhds) (1 : α)).has_basis p U) : ((uniformity) α).has_basis p fun i => { x : α × α | x.1⁻¹ * x.2 ∈ U i } :=\n  by\n  rw [uniformity_eq_comap_inv_mul_nhds_one]\n  exact h.comap _\n#align filter.has_basis.uniformity_of_nhds_one_inv_mul Filter.HasBasis.uniformity_of_nhds_one_inv_mul\n#align filter.has_basis.uniformity_of_nhds_zero_neg_add Filter.HasBasis.uniformity_of_nhds_zero_neg_add\n-/\n\n",
 "uniformity_of_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.uniformity_of_nhds_one /-\n@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one {ι} {p : ι → Prop} {U : ι → Set α} (h : ((nhds) (1 : α)).has_basis p U) :\n    ((uniformity) α).has_basis p fun i => { x : α × α | x.2 / x.1 ∈ U i } :=\n  by\n  rw [uniformity_eq_comap_nhds_one]\n  exact h.comap _\n#align filter.has_basis.uniformity_of_nhds_one Filter.HasBasis.uniformity_of_nhds_one\n#align filter.has_basis.uniformity_of_nhds_zero Filter.HasBasis.uniformity_of_nhds_zero\n-/\n\n",
 "uniformity_eq_comap_nhds_one_swapped":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print uniformity_eq_comap_nhds_one_swapped /-\n@[to_additive]\ntheorem uniformity_eq_comap_nhds_one_swapped : (uniformity) α = comap (fun x : α × α => x.1 / x.2) ((nhds) (1 : α)) :=\n  by\n  rw [← comap_swap_uniformity, uniformity_eq_comap_nhds_one, comap_comap, (· ∘ ·)]\n  rfl\n#align uniformity_eq_comap_nhds_one_swapped uniformity_eq_comap_nhds_one_swapped\n#align uniformity_eq_comap_nhds_zero_swapped uniformity_eq_comap_nhds_zero_swapped\n-/\n\n",
 "uniformity_eq_comap_nhds_one'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print uniformity_eq_comap_nhds_one' /-\n@[to_additive]\ntheorem uniformity_eq_comap_nhds_one' : (uniformity) G = comap (fun p : G × G => p.2 / p.1) ((nhds) (1 : G)) :=\n  rfl\n#align uniformity_eq_comap_nhds_one' uniformity_eq_comap_nhds_one'\n#align uniformity_eq_comap_nhds_zero' uniformity_eq_comap_nhds_zero'\n-/\n\n",
 "uniformity_eq_comap_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print uniformity_eq_comap_nhds_one /-\n@[to_additive]\ntheorem uniformity_eq_comap_nhds_one : (uniformity) α = comap (fun x : α × α => x.2 / x.1) ((nhds) (1 : α)) :=\n  by\n  rw [nhds_eq_comap_uniformity, Filter.comap_comap]\n  refine' le_antisymm (Filter.map_le_iff_le_comap.1 _) _\n  · intro s hs\n    rcases mem_uniformity_of_uniformContinuous_invariant uniformContinuous_div hs with ⟨t, ht, hts⟩\n    refine' mem_map.2 (mem_of_superset ht _)\n    rintro ⟨a, b⟩\n    simpa [subset_def] using hts a b a\n  · intro s hs\n    rcases mem_uniformity_of_uniformContinuous_invariant uniformContinuous_mul hs with ⟨t, ht, hts⟩\n    refine' ⟨_, ht, _⟩\n    rintro ⟨a, b⟩\n    simpa [subset_def] using hts 1 (b / a) a\n#align uniformity_eq_comap_nhds_one uniformity_eq_comap_nhds_one\n#align uniformity_eq_comap_nhds_zero uniformity_eq_comap_nhds_zero\n-/\n\n",
 "uniformity_eq_comap_inv_mul_nhds_one_swapped":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print uniformity_eq_comap_inv_mul_nhds_one_swapped /-\n@[to_additive]\ntheorem uniformity_eq_comap_inv_mul_nhds_one_swapped :\n    (uniformity) α = comap (fun x : α × α => x.2⁻¹ * x.1) ((nhds) (1 : α)) :=\n  by\n  rw [← comap_swap_uniformity, uniformity_eq_comap_inv_mul_nhds_one, comap_comap, (· ∘ ·)]\n  rfl\n#align uniformity_eq_comap_inv_mul_nhds_one_swapped uniformity_eq_comap_inv_mul_nhds_one_swapped\n#align uniformity_eq_comap_neg_add_nhds_zero_swapped uniformity_eq_comap_neg_add_nhds_zero_swapped\n-/\n\n",
 "uniformity_eq_comap_inv_mul_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print uniformity_eq_comap_inv_mul_nhds_one /-\n@[to_additive]\ntheorem uniformity_eq_comap_inv_mul_nhds_one : (uniformity) α = comap (fun x : α × α => x.1⁻¹ * x.2) ((nhds) (1 : α)) :=\n  by\n  rw [← comap_uniformity_mulOpposite, uniformity_eq_comap_nhds_one, ← op_one, ← comap_unop_nhds, comap_comap,\n    comap_comap]\n  simp [(· ∘ ·)]\n#align uniformity_eq_comap_inv_mul_nhds_one uniformity_eq_comap_inv_mul_nhds_one\n#align uniformity_eq_comap_neg_add_nhds_zero uniformity_eq_comap_neg_add_nhds_zero\n-/\n\n",
 "uniformity_countably_generated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print UniformGroup.uniformity_countably_generated /-\n@[to_additive]\ntheorem UniformGroup.uniformity_countably_generated [((nhds) (1 : α)).is_countably_generated] :\n    ((uniformity) α).is_countably_generated :=\n  by\n  rw [uniformity_eq_comap_nhds_one]\n  exact Filter.comap.isCountablyGenerated _ _\n#align uniform_group.uniformity_countably_generated UniformGroup.uniformity_countably_generated\n#align uniform_add_group.uniformity_countably_generated UniformAddGroup.uniformity_countably_generated\n-/\n\n",
 "uniformGroup_infₛ":
 "#print uniformGroup_infₛ /-\n@[to_additive]\ntheorem uniformGroup_infₛ {us : Set (UniformSpace β)} (h : ∀ u ∈ us, @UniformGroup β u _) :\n    @UniformGroup β (infₛ us) _ :=\n  {\n    uniform_continuous_div :=\n      uniformContinuous_infₛ_rng fun u hu =>\n        uniformContinuous_infₛ_dom₂ hu hu (@uniform_group.uniform_continuous_div β u _ (h u hu)) }\n#align uniform_group_Inf uniformGroup_infₛ\n#align uniform_add_group_Inf uniformAddGroup_infₛ\n-/\n\n",
 "uniformGroup_infᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print uniformGroup_infᵢ /-\n@[to_additive]\ntheorem uniformGroup_infᵢ {ι : Sort _} {us' : ι → UniformSpace β} (h' : ∀ i, @UniformGroup β (us' i) _) :\n    @UniformGroup β\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (us' i)) _ :=\n  by\n  rw [← infₛ_range]\n  exact uniformGroup_infₛ (set.forall_range_iff.mpr h')\n#align uniform_group_infi uniformGroup_infᵢ\n#align uniform_add_group_infi uniformAddGroup_infᵢ\n-/\n\n",
 "uniformGroup_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print uniformGroup_inf /-\n@[to_additive]\ntheorem uniformGroup_inf {u₁ u₂ : UniformSpace β} (h₁ : @UniformGroup β u₁ _) (h₂ : @UniformGroup β u₂ _) :\n    @UniformGroup β («expr ⊓ » u₁ u₂) _ := by\n  rw [inf_eq_infᵢ]\n  refine' uniformGroup_infᵢ fun b => _\n  cases b <;> assumption\n#align uniform_group_inf uniformGroup_inf\n#align uniform_add_group_inf uniformAddGroup_inf\n-/\n\n",
 "uniformGroup_comap":
 "#print uniformGroup_comap /-\n@[to_additive]\ntheorem uniformGroup_comap {γ : Type _} [Group γ] {u : UniformSpace γ} [UniformGroup γ] {F : Type _}\n    [MonoidHomClass F β γ] (f : F) : @UniformGroup β (u.comap f) _ :=\n  {\n    uniform_continuous_div := by\n      letI : UniformSpace β := u.comap f\n      refine' uniformContinuous_comap' _\n      simp_rw [Function.comp, map_div]\n      change UniformContinuous ((fun p : γ × γ => p.1 / p.2) ∘ prod.map f f)\n      exact uniform_continuous_div.comp (uniform_continuous_comap.prod_map uniformContinuous_comap) }\n#align uniform_group_comap uniformGroup_comap\n#align uniform_add_group_comap uniformAddGroup_comap\n-/\n\n",
 "uniformEmbedding_translate_mul":
 "/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:132:4: warning: unsupported: rw with cfg: { occs := occurrences.pos[occurrences.pos] «expr[ ,]»([1]) } -/\n#print uniformEmbedding_translate_mul /-\n@[to_additive]\ntheorem uniformEmbedding_translate_mul (a : α) : UniformEmbedding fun x : α => x * a :=\n  { comap_uniformity := by\n      rw [← uniformity_translate_mul a, comap_map]\n      rintro ⟨p₁, p₂⟩ ⟨q₁, q₂⟩\n      simp (config := { contextual := true }) [Prod.eq_iff_fst_eq_snd_eq]\n    inj := mul_left_injective a }\n#align uniform_embedding_translate_mul uniformEmbedding_translate_mul\n#align uniform_embedding_translate_add uniformEmbedding_translate_add\n-/\n\n",
 "uniformContinuous_zpow_const":
 "#print uniformContinuous_zpow_const /-\n@[to_additive uniformContinuous_const_zsmul]\ntheorem uniformContinuous_zpow_const (n : ℤ) : UniformContinuous fun x : α => x ^ n :=\n  uniformContinuous_id.zpow_const n\n#align uniform_continuous_zpow_const uniformContinuous_zpow_const\n#align uniform_continuous_const_zsmul uniformContinuous_const_zsmul\n-/\n\n",
 "uniformContinuous_pow_const":
 "#print uniformContinuous_pow_const /-\n@[to_additive uniformContinuous_const_nsmul]\ntheorem uniformContinuous_pow_const (n : ℕ) : UniformContinuous fun x : α => x ^ n :=\n  uniformContinuous_id.pow_const n\n#align uniform_continuous_pow_const uniformContinuous_pow_const\n#align uniform_continuous_const_nsmul uniformContinuous_const_nsmul\n-/\n\n",
 "uniformContinuous_of_tendsto_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print uniformContinuous_of_tendsto_one /-\n@[to_additive]\ntheorem uniformContinuous_of_tendsto_one {hom : Type _} [UniformSpace β] [Group β] [UniformGroup β]\n    [MonoidHomClass hom α β] {f : hom} (h : Tendsto f ((nhds) 1) ((nhds) 1)) : UniformContinuous f :=\n  by\n  have : ((fun x : β × β => x.2 / x.1) ∘ fun x : α × α => (f x.1, f x.2)) = fun x : α × α => f (x.2 / x.1) := by\n    simp only [map_div]\n  rw [UniformContinuous, uniformity_eq_comap_nhds_one α, uniformity_eq_comap_nhds_one β, tendsto_comap_iff, this]\n  exact tendsto.comp h tendsto_comap\n#align uniform_continuous_of_tendsto_one uniformContinuous_of_tendsto_one\n#align uniform_continuous_of_tendsto_zero uniformContinuous_of_tendsto_zero\n-/\n\n",
 "uniformContinuous_of_continuousAt_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidHom.uniformContinuous_of_continuousAt_one /-\n@[to_additive]\ntheorem MonoidHom.uniformContinuous_of_continuousAt_one [UniformSpace β] [Group β] [UniformGroup β] (f : «expr →* » α β)\n    (hf : ContinuousAt f 1) : UniformContinuous f :=\n  uniformContinuous_of_continuousAt_one f hf\n#align monoid_hom.uniform_continuous_of_continuous_at_one MonoidHom.uniformContinuous_of_continuousAt_one\n#align add_monoid_hom.uniform_continuous_of_continuous_at_zero AddMonoidHom.uniformContinuous_of_continuousAt_zero\n-/\n\n",
 "uniformContinuous_mul":
 "#print uniformContinuous_mul /-\n@[to_additive]\ntheorem uniformContinuous_mul : UniformContinuous fun p : α × α => p.1 * p.2 :=\n  uniformContinuous_fst.mul uniformContinuous_snd\n#align uniform_continuous_mul uniformContinuous_mul\n#align uniform_continuous_add uniformContinuous_add\n-/\n\n",
 "uniformContinuous_monoidHom_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print uniformContinuous_monoidHom_of_continuous /-\n@[to_additive]\ntheorem uniformContinuous_monoidHom_of_continuous {hom : Type _} [UniformSpace β] [Group β] [UniformGroup β]\n    [MonoidHomClass hom α β] {f : hom} (h : Continuous f) : UniformContinuous f :=\n  uniformContinuous_of_tendsto_one <|\n    suffices Tendsto f ((nhds) 1) ((nhds) (f 1)) by rwa [map_one] at this\n    h.tendsto 1\n#align uniform_continuous_monoid_hom_of_continuous uniformContinuous_monoidHom_of_continuous\n#align uniform_continuous_add_monoid_hom_of_continuous uniformContinuous_addMonoidHom_of_continuous\n-/\n\n",
 "uniformContinuous_inv":
 "#print uniformContinuous_inv /-\n@[to_additive]\ntheorem uniformContinuous_inv : UniformContinuous fun x : α => x⁻¹ :=\n  uniformContinuous_id.inv\n#align uniform_continuous_inv uniformContinuous_inv\n#align uniform_continuous_neg uniformContinuous_neg\n-/\n\n",
 "uniformContinuous_iff_open_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print UniformGroup.uniformContinuous_iff_open_ker /-\n/-- A homomorphism from a uniform group to a discrete uniform group is continuous if and only if\nits kernel is open. -/\n@[to_additive\n      \"A homomorphism from a uniform additive group to a discrete uniform additive group is\\ncontinuous if and only if its kernel is open.\"]\ntheorem UniformGroup.uniformContinuous_iff_open_ker {hom : Type _} [UniformSpace β] [DiscreteTopology β] [Group β]\n    [UniformGroup β] [MonoidHomClass hom α β] {f : hom} :\n    UniformContinuous f ↔ IsOpen ((f : «expr →* » α β).ker : Set α) :=\n  by\n  refine' ⟨fun hf => _, fun hf => _⟩\n  · apply (isOpen_discrete ({1} : Set β)).preimage (UniformContinuous.continuous hf)\n  · apply uniformContinuous_of_continuousAt_one\n    rw [ContinuousAt, nhds_discrete β, map_one, tendsto_pure]\n    exact hf.mem_nhds (map_one f)\n#align uniform_group.uniform_continuous_iff_open_ker UniformGroup.uniformContinuous_iff_open_ker\n#align uniform_add_group.uniform_continuous_iff_open_ker UniformAddGroup.uniformContinuous_iff_open_ker\n-/\n\n",
 "uniformContinuous_div":
 "#print uniformContinuous_div /-\n@[to_additive]\ntheorem uniformContinuous_div : UniformContinuous fun p : α × α => p.1 / p.2 :=\n  uniform_group.uniform_continuous_div\n#align uniform_continuous_div uniformContinuous_div\n#align uniform_continuous_sub uniformContinuous_sub\n-/\n\n",
 "totallyBounded_iff_subset_finite_unionᵢ_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print totallyBounded_iff_subset_finite_unionᵢ_nhds_one /-\n@[to_additive]\ntheorem totallyBounded_iff_subset_finite_unionᵢ_nhds_one {s : Set α} :\n    TotallyBounded s ↔\n      ∀ U ∈ (nhds) (1 : α),\n        ∃ t : Set α,\n          t.finite ∧\n            s ⊆\n              «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                («expr • » y U) :=\n  ((nhds) (1 : α)).basis_sets.uniformity_of_nhds_one_inv_mul_swapped.totally_bounded_iff.trans <| by\n    simp [← preimage_smul_inv, preimage]\n#align totally_bounded_iff_subset_finite_Union_nhds_one totallyBounded_iff_subset_finite_unionᵢ_nhds_one\n#align totally_bounded_iff_subset_finite_Union_nhds_zero totallyBounded_iff_subset_finite_unionᵢ_nhds_zero\n-/\n\n",
 "topologicalGroup_is_uniform_of_compactSpace":
 "#print topologicalGroup_is_uniform_of_compactSpace /-\n@[to_additive]\ntheorem topologicalGroup_is_uniform_of_compactSpace [CompactSpace G] : UniformGroup G :=\n  ⟨by\n    apply CompactSpace.uniformContinuous_of_continuous\n    exact continuous_div'⟩\n#align topological_group_is_uniform_of_compact_space topologicalGroup_is_uniform_of_compactSpace\n#align topological_add_group_is_uniform_of_compact_space topologicalAddGroup_is_uniform_of_compactSpace\n-/\n\n",
 "toUniformSpace_eq":
 "#print UniformGroup.toUniformSpace_eq /-\n@[to_additive]\ntheorem UniformGroup.toUniformSpace_eq {G : Type _} [u : UniformSpace G] [Group G] [UniformGroup G] :\n    TopologicalGroup.toUniformSpace G = u := by\n  ext : 1\n  rw [uniformity_eq_comap_nhds_one' G, uniformity_eq_comap_nhds_one G]\n#align uniform_group.to_uniform_space_eq UniformGroup.toUniformSpace_eq\n#align uniform_add_group.to_uniform_space_eq UniformAddGroup.toUniformSpace_eq\n-/\n\n",
 "tendsto_div_comap_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_div_comap_self /-\n-- β is a dense subgroup of α, inclusion is denoted by e\n@[to_additive]\ntheorem tendsto_div_comap_self (x₀ : α) :\n    Tendsto (fun t : β × β => t.2 / t.1) ((comap fun p : β × β => (e p.1, e p.2)) <| (nhds) (x₀, x₀)) ((nhds) 1) :=\n  by\n  have comm : ((fun x : α × α => x.2 / x.1) ∘ fun t : β × β => (e t.1, e t.2)) = e ∘ fun t : β × β => t.2 / t.1 :=\n    by\n    ext t\n    change e t.2 / e t.1 = e (t.2 / t.1)\n    rwa [← map_div e t.2 t.1]\n  have lim : tendsto (fun x : α × α => x.2 / x.1) ((nhds) (x₀, x₀)) ((nhds) (e 1)) := by\n    simpa using (continuous_div'.comp (@continuous_swap α α _ _)).tendsto (x₀, x₀)\n  simpa using de.tendsto_comap_nhds_nhds limUnder comm\n#align tendsto_div_comap_self tendsto_div_comap_self\n#align tendsto_sub_comap_self tendsto_sub_comap_self\n-/\n\n",
 "tendstoUniformly_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n#print TopologicalGroup.tendstoUniformly_iff /-\n@[to_additive]\ntheorem TopologicalGroup.tendstoUniformly_iff {ι α : Type _} (F : ι → α → G) (f : α → G) (p : Filter ι) :\n    @TendstoUniformly α G ι (TopologicalGroup.toUniformSpace G) F f p ↔\n      ∀ u ∈ (nhds) (1 : G),\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n          (∀ a, F i a / f a ∈ u) :=\n  ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩, fun h v ⟨u, hu, hv⟩ => mem_of_superset (h u hu) fun i hi a => hv (hi a)⟩\n#align topological_group.tendsto_uniformly_iff TopologicalGroup.tendstoUniformly_iff\n#align topological_add_group.tendsto_uniformly_iff TopologicalAddGroup.tendstoUniformly_iff\n-/\n\n",
 "tendstoUniformlyOn_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n#print TopologicalGroup.tendstoUniformlyOn_iff /-\n@[to_additive]\ntheorem TopologicalGroup.tendstoUniformlyOn_iff {ι α : Type _} (F : ι → α → G) (f : α → G) (p : Filter ι) (s : Set α) :\n    @TendstoUniformlyOn α G ι (TopologicalGroup.toUniformSpace G) F f p s ↔\n      ∀ u ∈ (nhds) (1 : G),\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n          (∀ a ∈ s, F i a / f a ∈ u) :=\n  ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩, fun h v ⟨u, hu, hv⟩ =>\n    mem_of_superset (h u hu) fun i hi a ha => hv (hi a ha)⟩\n#align topological_group.tendsto_uniformly_on_iff TopologicalGroup.tendstoUniformlyOn_iff\n#align topological_add_group.tendsto_uniformly_on_iff TopologicalAddGroup.tendstoUniformlyOn_iff\n-/\n\n",
 "tendstoLocallyUniformly_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n#print TopologicalGroup.tendstoLocallyUniformly_iff /-\n@[to_additive]\ntheorem TopologicalGroup.tendstoLocallyUniformly_iff {ι α : Type _} [TopologicalSpace α] (F : ι → α → G) (f : α → G)\n    (p : Filter ι) :\n    @TendstoLocallyUniformly α G ι (TopologicalGroup.toUniformSpace G) _ F f p ↔\n      ∀ u ∈ (nhds) (1 : G),\n        ∀ (x : α),\n          ∃ t ∈ (nhds) x,\n            «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n              (∀ a ∈ t, F i a / f a ∈ u) :=\n  ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩, fun h v ⟨u, hu, hv⟩ x =>\n    Exists.imp (fun a => Exists.imp fun ha hp => mem_of_superset hp fun i hi a ha => hv (hi a ha)) (h u hu x)⟩\n#align topological_group.tendsto_locally_uniformly_iff TopologicalGroup.tendstoLocallyUniformly_iff\n#align topological_add_group.tendsto_locally_uniformly_iff TopologicalAddGroup.tendstoLocallyUniformly_iff\n-/\n\n",
 "tendstoLocallyUniformlyOn_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n#print TopologicalGroup.tendstoLocallyUniformlyOn_iff /-\n@[to_additive]\ntheorem TopologicalGroup.tendstoLocallyUniformlyOn_iff {ι α : Type _} [TopologicalSpace α] (F : ι → α → G) (f : α → G)\n    (p : Filter ι) (s : Set α) :\n    @TendstoLocallyUniformlyOn α G ι (TopologicalGroup.toUniformSpace G) _ F f p s ↔\n      ∀ u ∈ (nhds) (1 : G),\n        ∀ x ∈ s,\n          ∃ t ∈ nhds_within s x,\n            «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" p\n              (∀ a ∈ t, F i a / f a ∈ u) :=\n  ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩, fun h v ⟨u, hu, hv⟩ x =>\n    (Exists.imp fun a => Exists.imp fun ha hp => mem_of_superset hp fun i hi a ha => hv (hi a ha)) ∘ h u hu x⟩\n#align topological_group.tendsto_locally_uniformly_on_iff TopologicalGroup.tendstoLocallyUniformlyOn_iff\n#align topological_add_group.tendsto_locally_uniformly_on_iff TopologicalAddGroup.tendstoLocallyUniformlyOn_iff\n-/\n\n",
 "t2Space_of_one_sep":
 "#print TopologicalGroup.t2Space_of_one_sep /-\n@[to_additive]\ntheorem TopologicalGroup.t2Space_of_one_sep (H : ∀ x : G, x ≠ 1 → ∃ U ∈ nhds (1 : G), x ∉ U) : T2Space G :=\n  by\n  rw [TopologicalGroup.t2Space_iff_one_closed, ← isOpen_compl_iff, isOpen_iff_mem_nhds]\n  intro x x_not\n  have : x ≠ 1 := mem_compl_singleton_iff.mp x_not\n  rcases H x this with ⟨U, U_in, xU⟩\n  rw [← nhds_one_symm G] at U_in\n  rcases U_in with ⟨W, W_in, UW⟩\n  rw [← nhds_translation_mul_inv]\n  use W, W_in\n  rw [subset_compl_comm]\n  suffices x⁻¹ ∉ W by simpa\n  exact fun h => xU (UW h)\n#align topological_group.t2_space_of_one_sep TopologicalGroup.t2Space_of_one_sep\n#align topological_add_group.t2_space_of_zero_sep TopologicalAddGroup.t2Space_of_zero_sep\n-/\n\n",
 "t2Space_iff_one_closed":
 "#print TopologicalGroup.t2Space_iff_one_closed /-\n@[to_additive]\ntheorem TopologicalGroup.t2Space_iff_one_closed : T2Space G ↔ IsClosed ({1} : Set G) :=\n  by\n  haveI : UniformGroup G := comm_topologicalGroup_is_uniform\n  rw [← separated_iff_t2, separatedSpace_iff, ← closure_eq_iff_isClosed]\n  constructor <;> intro h\n  · apply subset.antisymm\n    · intro x x_in\n      have := group_separationRel x 1\n      rw [div_one] at this\n      rw [← this, h] at x_in\n      change x = 1 at x_in\n      simp [x_in]\n    · exact subset_closure\n  · ext p\n    cases' p with x y\n    rw [group_separationRel x, h, mem_singleton_iff, div_eq_one]\n    rfl\n#align topological_group.t2_space_iff_one_closed TopologicalGroup.t2Space_iff_one_closed\n#align topological_add_group.t2_space_iff_zero_closed TopologicalAddGroup.t2Space_iff_zero_closed\n-/\n\n",
 "pow_const":
 "#print UniformContinuous.pow_const /-\n@[to_additive UniformContinuous.const_nsmul]\ntheorem UniformContinuous.pow_const [UniformSpace β] {f : β → α} (hf : UniformContinuous f) :\n    ∀ n : ℕ, UniformContinuous fun x => f x ^ n\n  | 0 => by\n    simp_rw [pow_zero]\n    exact uniformContinuous_const\n  | n + 1 => by\n    simp_rw [pow_succ]\n    exact hf.mul (UniformContinuous.pow_const n)\n#align uniform_continuous.pow_const UniformContinuous.pow_const\n#align uniform_continuous.const_nsmul UniformContinuous.const_nsmul\n-/\n\n",
 "mul_const":
 "#print CauchySeq.mul_const /-\n@[to_additive]\ntheorem CauchySeq.mul_const {ι : Type _} [SemilatticeSup ι] {u : ι → α} {x : α} (hu : CauchySeq u) :\n    CauchySeq fun n => u n * x :=\n  (uniformContinuous_id.mul uniformContinuous_const).comp_cauchy_seq hu\n#align cauchy_seq.mul_const CauchySeq.mul_const\n#align cauchy_seq.add_const CauchySeq.add_const\n-/\n\n",
 "mul":
 "#print UniformCauchySeqOn.mul /-\n@[to_additive]\ntheorem UniformCauchySeqOn.mul (hf : UniformCauchySeqOn f l s) (hf' : UniformCauchySeqOn f' l s) :\n    UniformCauchySeqOn (f * f') l s := fun u hu => by\n  simpa using (uniform_continuous_mul.comp_uniform_cauchy_seq_on (hf.prod' hf')) u hu\n#align uniform_cauchy_seq_on.mul UniformCauchySeqOn.mul\n#align uniform_cauchy_seq_on.add UniformCauchySeqOn.add\n-/\n\n",
 "mk'":
 "#print UniformGroup.mk' /-\n/-\nCopyright (c) 2018 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Johannes Hölzl\n-/\n@[to_additive]\ntheorem UniformGroup.mk' {α} [UniformSpace α] [Group α] (h₁ : UniformContinuous fun p : α × α => p.1 * p.2)\n    (h₂ : UniformContinuous fun p : α => p⁻¹) : UniformGroup α :=\n  ⟨by simpa only [div_eq_mul_inv] using h₁.comp (uniform_continuous_fst.prod_mk (h₂.comp uniformContinuous_snd))⟩\n#align uniform_group.mk' UniformGroup.mk'\n#align uniform_add_group.mk' UniformAddGroup.mk'\n-/\n\n",
 "inv":
 "#print CauchySeq.inv /-\n@[to_additive]\ntheorem CauchySeq.inv {ι : Type _} [SemilatticeSup ι] {u : ι → α} (h : CauchySeq u) : CauchySeq u⁻¹ :=\n  uniformContinuous_inv.comp_cauchy_seq h\n#align cauchy_seq.inv CauchySeq.inv\n#align cauchy_seq.neg CauchySeq.neg\n-/\n\n",
 "group_separationRel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print group_separationRel /-\n@[to_additive]\ntheorem group_separationRel (x y : α) : (x, y) ∈ separationRel α ↔ x / y ∈ closure ({1} : Set α) :=\n  have : Embedding fun a => a * (y / x) := (uniformEmbedding_translate_mul (y / x)).embedding\n  show (x, y) ∈ «expr⋂₀ » ((uniformity) α).sets ↔ x / y ∈ closure ({1} : Set α)\n    by\n    rw [this.closure_eq_preimage_closure_image, uniformity_eq_comap_nhds_one α, sInter_comap_sets]\n    simp [mem_closure_iff_nhds, inter_singleton_nonempty, sub_eq_add_neg, add_assoc]\n#align group_separation_rel group_separationRel\n#align add_group_separation_rel addGroup_separationRel\n-/\n\n",
 "extend_Z_bilin_key":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x x' «expr ∈ » U₁) -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (y y' «expr ∈ » V₁) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x x' «expr ∈ » U) -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (y y' «expr ∈ » V) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\nprivate theorem extend_Z_bilin_key (x₀ : α) (y₀ : γ) :\n    ∃ U ∈ comap e ((nhds) x₀),\n      ∃ V ∈ comap f ((nhds) y₀),\n        ∀ (x) (_ : x ∈ U) (x') (_ : x' ∈ U),\n          ∀ (y) (_ : y ∈ V) (y') (_ : y' ∈ V), (exprΦ) (x', y') - (exprΦ) (x, y) ∈ W' :=\n  by\n  let Nx := (nhds) x₀\n  let Ny := (nhds) y₀\n  let dp := DenseInducing.prod de df\n  let ee := fun u : β × β => (e u.1, e u.2)\n  let ff := fun u : δ × δ => (f u.1, f u.2)\n  have lim_φ : Filter.Tendsto (exprΦ) ((nhds) (0, 0)) ((nhds) 0) := by simpa using hφ.tendsto (0, 0)\n  have lim_φ_sub_sub :\n    tendsto (fun p : (β × β) × δ × δ => (exprΦ) (p.1.2 - p.1.1, p.2.2 - p.2.1))\n      (filter.prod (comap ee <| (nhds) (x₀, x₀)) (comap ff <| (nhds) (y₀, y₀))) ((nhds) 0) :=\n    by\n    have lim_sub_sub :\n      tendsto (fun p : (β × β) × δ × δ => (p.1.2 - p.1.1, p.2.2 - p.2.1))\n        (filter.prod (comap ee ((nhds) (x₀, x₀))) (comap ff ((nhds) (y₀, y₀)))) (filter.prod ((nhds) 0) ((nhds) 0)) :=\n      by\n      have := Filter.prod_mono (tendsto_sub_comap_self de x₀) (tendsto_sub_comap_self df y₀)\n      rwa [prod_map_map_eq] at this\n    rw [← nhds_prod_eq] at lim_sub_sub\n    exact tendsto.comp lim_φ lim_sub_sub\n  rcases exists_nhds_zero_quarter W'_nhd with ⟨W, W_nhd, W4⟩\n  have :\n    ∃ U₁ ∈ comap e ((nhds) x₀),\n      ∃ V₁ ∈ comap f ((nhds) y₀),\n        ∀ (x) (_ : x ∈ U₁) (x') (_ : x' ∈ U₁), ∀ (y) (_ : y ∈ V₁) (y') (_ : y' ∈ V₁), (exprΦ) (x' - x, y' - y) ∈ W :=\n    by\n    have := tendsto_prod_iff.1 lim_φ_sub_sub W W_nhd\n    repeat' rw [nhds_prod_eq, ← prod_comap_comap_eq] at this\n    rcases this with ⟨U, U_in, V, V_in, H⟩\n    rw [mem_prod_same_iff] at U_in V_in\n    rcases U_in with ⟨U₁, U₁_in, HU₁⟩\n    rcases V_in with ⟨V₁, V₁_in, HV₁⟩\n    exists U₁, U₁_in, V₁, V₁_in\n    intro x x_in x' x'_in y y_in y' y'_in\n    exact H _ _ (HU₁ (mk_mem_prod x_in x'_in)) (HV₁ (mk_mem_prod y_in y'_in))\n  rcases this with ⟨U₁, U₁_nhd, V₁, V₁_nhd, H⟩\n  obtain ⟨x₁, x₁_in⟩ : U₁.nonempty := (de.comap_nhds_ne_bot _).nonempty_of_mem U₁_nhd\n  obtain ⟨y₁, y₁_in⟩ : V₁.nonempty := (df.comap_nhds_ne_bot _).nonempty_of_mem V₁_nhd\n  have cont_flip : Continuous fun p : δ × β => φ.flip p.1 p.2 :=\n    by\n    show Continuous (exprΦ ∘ Prod.swap)\n    exact hφ.comp continuous_swap\n  rcases extend_Z_bilin_aux de df hφ W_nhd x₀ y₁ with ⟨U₂, U₂_nhd, HU⟩\n  rcases extend_Z_bilin_aux df de cont_flip W_nhd y₀ x₁ with ⟨V₂, V₂_nhd, HV⟩\n  exists U₁ ∩ U₂, inter_mem U₁_nhd U₂_nhd, V₁ ∩ V₂, inter_mem V₁_nhd V₂_nhd\n  rintro x ⟨xU₁, xU₂⟩ x' ⟨x'U₁, x'U₂⟩ y ⟨yV₁, yV₂⟩ y' ⟨y'V₁, y'V₂⟩\n  have key_formula : φ x' y' - φ x y = φ (x' - x) y₁ + φ (x' - x) (y' - y₁) + φ x₁ (y' - y) + φ (x - x₁) (y' - y) :=\n    by\n    simp\n    abel\n  rw [key_formula]\n  have h₁ := HU x xU₂ x' x'U₂\n  have h₂ := H x xU₁ x' x'U₁ y₁ y₁_in y' y'V₁\n  have h₃ := HV y yV₂ y' y'V₂\n  have h₄ := H x₁ x₁_in x xU₁ y yV₁ y' y'V₁\n  exact W4 h₁ h₂ h₃ h₄\n#align extend_Z_bilin_key extend_Z_bilin_key\n\n",
 "extend_Z_bilin_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x x' «expr ∈ » U₂) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n-- β is a dense subgroup of α, inclusion is denoted by e\n-- δ is a dense subgroup of γ, inclusion is denoted by f\nprivate theorem extend_Z_bilin_aux (x₀ : α) (y₁ : δ) :\n    ∃ U₂ ∈ comap e ((nhds) x₀), ∀ (x) (_ : x ∈ U₂) (x') (_ : x' ∈ U₂), (exprΦ) (x' - x, y₁) ∈ W' :=\n  by\n  let Nx := (nhds) x₀\n  let ee := fun u : β × β => (e u.1, e u.2)\n  have lim1 : tendsto (fun a : β × β => (a.2 - a.1, y₁)) (filter.prod (comap e Nx) (comap e Nx)) ((nhds) (0, y₁)) :=\n    by\n    have :=\n      tendsto.prod_mk (tendsto_sub_comap_self de x₀)\n        (tendsto_const_nhds : tendsto (fun p : β × β => y₁) (comap ee <| (nhds) (x₀, x₀)) ((nhds) y₁))\n    rw [nhds_prod_eq, prod_comap_comap_eq, ← nhds_prod_eq]\n    exact (this : _)\n  have lim2 : tendsto (exprΦ) ((nhds) (0, y₁)) ((nhds) 0) := by simpa using hφ.tendsto (0, y₁)\n  have lim := lim2.comp lim1\n  rw [tendsto_prod_self_iff] at lim\n  simp_rw [ball_mem_comm]\n  exact limUnder W' W'_nhd\n#align extend_Z_bilin_aux extend_Z_bilin_aux\n\n",
 "extend_Z_bilin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprΦ -/\n/-- Bourbaki GT III.6.5 Theorem I:\nℤ-bilinear continuous maps from dense images into a complete Hausdorff group extend by continuity.\nNote: Bourbaki assumes that α and β are also complete Hausdorff, but this is not necessary. -/\ntheorem extend_Z_bilin : Continuous (extend (de.prod df) (exprΦ)) :=\n  by\n  refine' continuous_extend_of_cauchy _ _\n  rintro ⟨x₀, y₀⟩\n  constructor\n  · apply ne_bot.map\n    apply comap_ne_bot\n    intro U h\n    rcases mem_closure_iff_nhds.1 ((de.prod df).dense (x₀, y₀)) U h with ⟨x, x_in, ⟨z, z_x⟩⟩\n    exists z\n    cc\n  · suffices\n      map (fun p : (β × δ) × β × δ => (exprΦ) p.2 - (exprΦ) p.1)\n          (comap (fun p : (β × δ) × β × δ => ((e p.1.1, f p.1.2), (e p.2.1, f p.2.2)))\n            (filter.prod ((nhds) (x₀, y₀)) ((nhds) (x₀, y₀)))) ≤\n        (nhds) 0\n      by\n      rwa [uniformity_eq_comap_nhds_zero G, prod_map_map_eq, ← map_le_iff_le_comap, Filter.map_map, prod_comap_comap_eq]\n    intro W' W'_nhd\n    have key := extend_Z_bilin_key de df hφ W'_nhd x₀ y₀\n    rcases key with ⟨U, U_nhd, V, V_nhd, h⟩\n    rw [mem_comap] at U_nhd\n    rcases U_nhd with ⟨U', U'_nhd, U'_sub⟩\n    rw [mem_comap] at V_nhd\n    rcases V_nhd with ⟨V', V'_nhd, V'_sub⟩\n    rw [mem_map, mem_comap, nhds_prod_eq]\n    exists lower_set.prod (lower_set.prod U' V') (lower_set.prod U' V')\n    rw [mem_prod_same_iff]\n    simp only [exists_prop]\n    constructor\n    · change U' ∈ (nhds) x₀ at U'_nhd\n      change V' ∈ (nhds) y₀ at V'_nhd\n      have := prod_mem_prod U'_nhd V'_nhd\n      tauto\n    · intro p h'\n      simp only [Set.mem_preimage, Set.prod_mk_mem_set_prod_eq] at h'\n      rcases p with ⟨⟨x, y⟩, ⟨x', y'⟩⟩\n      apply h <;> tauto\n#align extend_Z_bilin extend_Z_bilin\n\n",
 "ext_iff":
 "#print UniformGroup.ext_iff /-\n@[to_additive]\ntheorem UniformGroup.ext_iff {G : Type _} [Group G] {u v : UniformSpace G} (hu : @UniformGroup G u _)\n    (hv : @UniformGroup G v _) : u = v ↔ @nhds _ u.to_topological_space 1 = @nhds _ v.to_topological_space 1 :=\n  ⟨fun h => h ▸ rfl, hu.ext hv⟩\n#align uniform_group.ext_iff UniformGroup.ext_iff\n#align uniform_add_group.ext_iff UniformAddGroup.ext_iff\n-/\n\n",
 "ext":
 "#print UniformGroup.ext /-\n@[to_additive]\ntheorem UniformGroup.ext {G : Type _} [Group G] {u v : UniformSpace G} (hu : @UniformGroup G u _)\n    (hv : @UniformGroup G v _) (h : @nhds _ u.to_topological_space 1 = @nhds _ v.to_topological_space 1) : u = v :=\n  uniformSpace_eq <| by rw [@uniformity_eq_comap_nhds_one _ u _ hu, @uniformity_eq_comap_nhds_one _ v _ hv, h]\n#align uniform_group.ext UniformGroup.ext\n#align uniform_add_group.ext UniformAddGroup.ext\n-/\n\n",
 "div":
 "#print UniformCauchySeqOn.div /-\n@[to_additive]\ntheorem UniformCauchySeqOn.div (hf : UniformCauchySeqOn f l s) (hf' : UniformCauchySeqOn f' l s) :\n    UniformCauchySeqOn (f / f') l s := fun u hu => by\n  simpa using (uniform_continuous_div.comp_uniform_cauchy_seq_on (hf.prod' hf')) u hu\n#align uniform_cauchy_seq_on.div UniformCauchySeqOn.div\n#align uniform_cauchy_seq_on.sub UniformCauchySeqOn.sub\n-/\n\n",
 "const_mul":
 "#print CauchySeq.const_mul /-\n@[to_additive]\ntheorem CauchySeq.const_mul {ι : Type _} [SemilatticeSup ι] {u : ι → α} {x : α} (hu : CauchySeq u) :\n    CauchySeq fun n => x * u n :=\n  (uniformContinuous_const.mul uniformContinuous_id).comp_cauchy_seq hu\n#align cauchy_seq.const_mul CauchySeq.const_mul\n#align cauchy_seq.const_add CauchySeq.const_add\n-/\n\n",
 "comm_topologicalGroup_is_uniform":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print comm_topologicalGroup_is_uniform /-\n@[to_additive]\ntheorem comm_topologicalGroup_is_uniform : UniformGroup G :=\n  by\n  have :\n    Tendsto ((fun p : G × G => p.1 / p.2) ∘ fun p : (G × G) × G × G => (p.1.2 / p.1.1, p.2.2 / p.2.1))\n      (comap (fun p : (G × G) × G × G => (p.1.2 / p.1.1, p.2.2 / p.2.1)) (((nhds) 1).prod ((nhds) 1)))\n      ((nhds) (1 / 1)) :=\n    (tendsto_fst.div' tendsto_snd).comp tendsto_comap\n  constructor\n  rw [UniformContinuous, uniformity_prod_eq_prod, tendsto_map'_iff, uniformity_eq_comap_nhds_one' G, tendsto_comap_iff,\n    prod_comap_comap_eq]\n  simpa [(· ∘ ·), div_eq_mul_inv, mul_comm, mul_left_comm] using this\n#align topological_comm_group_is_uniform comm_topologicalGroup_is_uniform\n#align topological_add_comm_group_is_uniform comm_topologicalAddGroup_is_uniform\n-/\n\n"}