{"tendsto_const_smul_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_const_smul_iff₀ /-\ntheorem tendsto_const_smul_iff₀ {f : β → α} {l : Filter β} {a : α} {c : G₀} (hc : c ≠ 0) :\n    Tendsto (fun x => «expr • » c (f x)) l (nhds <| «expr • » c a) ↔ Tendsto f l ((nhds) a) :=\n  tendsto_const_smul_iff (Units.mk0 c hc)\n#align tendsto_const_smul_iff₀ tendsto_const_smul_iff₀\n-/\n\n",
 "tendsto_const_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_const_smul_iff /-\ntheorem tendsto_const_smul_iff {f : β → α} {l : Filter β} {a : α} {c : M} (hc : IsUnit c) :\n    Tendsto (fun x => «expr • » c (f x)) l (nhds <| «expr • » c a) ↔ Tendsto f l ((nhds) a) :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ tendsto_const_smul_iff u\n#align tendsto_const_smul_iff tendsto_const_smul_iff\n-/\n\n",
 "smul₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print IsClosed.smul₀ /-\ntheorem IsClosed.smul₀ {𝕜 M : Type _} [DivisionRing 𝕜] [AddCommMonoid M] [TopologicalSpace M] [T1Space M] [Module 𝕜 M]\n    [ContinuousConstSMul 𝕜 M] (c : 𝕜) {s : Set M} (hs : IsClosed s) : IsClosed («expr • » c s) :=\n  isClosedMap_smul₀ c s hs\n#align is_closed.smul₀ IsClosed.smul₀\n-/\n\n",
 "smul_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print IsClosed.smul_of_ne_zero /-\ntheorem IsClosed.smul_of_ne_zero {c : G₀} {s : Set α} (hs : IsClosed s) (hc : c ≠ 0) : IsClosed («expr • » c s) :=\n  isClosedMap_smul_of_ne_zero hc s hs\n#align is_closed.smul_of_ne_zero IsClosed.smul_of_ne_zero\n-/\n\n",
 "smul_closure_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_closure_subset /-\n@[to_additive]\ntheorem smul_closure_subset (c : M) (s : Set α) : «expr • » c (closure s) ⊆ closure («expr • » c s) :=\n  ((Set.mapsTo_image _ _).closure <| continuous_id.const_smul c).image_subset\n#align smul_closure_subset smul_closure_subset\n#align vadd_closure_subset vadd_closure_subset\n-/\n\n",
 "smul_closure_orbit_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_closure_orbit_subset /-\n@[to_additive]\ntheorem smul_closure_orbit_subset (c : M) (x : α) :\n    «expr • » c (closure (MulAction.orbit M x)) ⊆ closure (MulAction.orbit M x) :=\n  (smul_closure_subset c _).trans <| closure_mono <| MulAction.smul_orbit_subset _ _\n#align smul_closure_orbit_subset smul_closure_orbit_subset\n#align vadd_closure_orbit_subset vadd_closure_orbit_subset\n-/\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Dense.smul /-\n@[to_additive]\ntheorem Dense.smul (c : G) {s : Set α} (hs : Dense s) : Dense («expr • » c s) := by\n  rw [dense_iff_closure_eq] at hs⊢ <;> rw [closure_smul, hs, smul_set_univ]\n#align dense.smul Dense.smul\n#align dense.vadd Dense.vadd\n-/\n\n",
 "set_smul_mem_nhds_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print set_smul_mem_nhds_zero_iff /-\ntheorem set_smul_mem_nhds_zero_iff {s : Set α} {c : G₀} (hc : c ≠ 0) :\n    «expr • » c s ∈ (nhds) (0 : α) ↔ s ∈ (nhds) (0 : α) :=\n  by\n  refine' iff.trans _ (set_smul_mem_nhds_smul_iff hc)\n  rw [smul_zero]\n#align set_smul_mem_nhds_zero_iff set_smul_mem_nhds_zero_iff\n-/\n\n",
 "set_smul_mem_nhds_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print set_smul_mem_nhds_smul_iff /-\ntheorem set_smul_mem_nhds_smul_iff {c : G₀} {s : Set α} {x : α} (hc : c ≠ 0) :\n    «expr • » c s ∈ (nhds) («expr • » c x : α) ↔ s ∈ (nhds) x :=\n  by\n  refine' ⟨fun h => _, fun h => set_smul_mem_nhds_smul h hc⟩\n  rw [← inv_smul_smul₀ hc x, ← inv_smul_smul₀ hc s]\n  exact set_smul_mem_nhds_smul h (inv_ne_zero hc)\n#align set_smul_mem_nhds_smul_iff set_smul_mem_nhds_smul_iff\n-/\n\n",
 "set_smul_mem_nhds_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print set_smul_mem_nhds_smul /-\n/-- Scalar multiplication preserves neighborhoods. -/\ntheorem set_smul_mem_nhds_smul {c : G₀} {s : Set α} {x : α} (hs : s ∈ (nhds) x) (hc : c ≠ 0) :\n    «expr • » c s ∈ (nhds) («expr • » c x : α) :=\n  by\n  rw [mem_nhds_iff] at hs⊢\n  obtain ⟨U, hs', hU, hU'⟩ := hs\n  exact ⟨«expr • » c U, Set.smul_set_mono hs', hU.smul₀ hc, Set.smul_mem_smul_set hU'⟩\n#align set_smul_mem_nhds_smul set_smul_mem_nhds_smul\n-/\n\n",
 "secondCountableTopology":
 "#print ContinuousConstSMul.secondCountableTopology /-\n/-- The quotient of a second countable space by a group action is second countable. -/\n@[to_additive \"The quotient of a second countable space by an additive group action is second\\ncountable.\"]\ntheorem ContinuousConstSMul.secondCountableTopology [SecondCountableTopology T] [ContinuousConstSMul Γ T] :\n    SecondCountableTopology (quotient (MulAction.orbitRel Γ T)) :=\n  TopologicalSpace.Quotient.secondCountableTopology isOpenMap_quotient_mk'_mul\n#align has_continuous_const_smul.second_countable_topology ContinuousConstSMul.secondCountableTopology\n#align has_continuous_const_vadd.second_countable_topology ContinuousConstVAdd.secondCountableTopology\n-/\n\n",
 "isOpenMap_smul₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print isOpenMap_smul₀ /-\ntheorem isOpenMap_smul₀ {c : G₀} (hc : c ≠ 0) : IsOpenMap fun x : α => «expr • » c x :=\n  (Homeomorph.smulOfNeZero c hc).is_open_map\n#align is_open_map_smul₀ isOpenMap_smul₀\n-/\n\n",
 "isOpenMap_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print isOpenMap_smul /-\ntheorem isOpenMap_smul (hc : IsUnit c) : IsOpenMap fun x : α => «expr • » c x :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ isOpenMap_smul u\n#align is_open_map_smul isOpenMap_smul\n-/\n\n",
 "isOpenMap_quotient_mk'_mul":
 "#print isOpenMap_quotient_mk'_mul /-\n/-- The quotient map by a group action is open, i.e. the quotient by a group action is an open\n  quotient. -/\n@[to_additive \"The quotient map by a group action is open, i.e. the quotient by a group\\naction is an open quotient. \"]\ntheorem isOpenMap_quotient_mk'_mul [ContinuousConstSMul Γ T] :\n    IsOpenMap (Quotient.mk' : T → quotient (MulAction.orbitRel Γ T)) :=\n  by\n  intro U hU\n  rw [isOpen_coinduced, MulAction.quotient_preimage_image_eq_union_mul U]\n  exact isOpen_unionᵢ fun γ => (Homeomorph.smul γ).is_open_map U hU\n#align is_open_map_quotient_mk_mul isOpenMap_quotient_mk'_mul\n#align is_open_map_quotient_mk_add isOpenMap_quotient_mk'_add\n-/\n\n",
 "isClosedMap_smul₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print isClosedMap_smul₀ /-\n/-- `smul` is a closed map in the second argument.\n\nThe lemma that `smul` is a closed map in the first argument (for a normed space over a complete\nnormed field) is `is_closed_map_smul_left` in `analysis.normed_space.finite_dimension`. -/\ntheorem isClosedMap_smul₀ {𝕜 M : Type _} [DivisionRing 𝕜] [AddCommMonoid M] [TopologicalSpace M] [T1Space M]\n    [Module 𝕜 M] [ContinuousConstSMul 𝕜 M] (c : 𝕜) : IsClosedMap fun x : M => «expr • » c x :=\n  by\n  rcases eq_or_ne c 0 with (rfl | hne)\n  · simp only [zero_smul]\n    exact isClosedMap_const\n  · exact (Homeomorph.smulOfNeZero c hne).is_closed_map\n#align is_closed_map_smul₀ isClosedMap_smul₀\n-/\n\n",
 "isClosedMap_smul_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print isClosedMap_smul_of_ne_zero /-\n/-- `smul` is a closed map in the second argument.\n\nThe lemma that `smul` is a closed map in the first argument (for a normed space over a complete\nnormed field) is `is_closed_map_smul_left` in `analysis.normed_space.finite_dimension`. -/\ntheorem isClosedMap_smul_of_ne_zero {c : G₀} (hc : c ≠ 0) : IsClosedMap fun x : α => «expr • » c x :=\n  (Homeomorph.smulOfNeZero c hc).is_closed_map\n#align is_closed_map_smul_of_ne_zero isClosedMap_smul_of_ne_zero\n-/\n\n",
 "isClosedMap_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print isClosedMap_smul /-\ntheorem isClosedMap_smul (hc : IsUnit c) : IsClosedMap fun x : α => «expr • » c x :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ isClosedMap_smul u\n#align is_closed_map_smul isClosedMap_smul\n-/\n\n",
 "interior_smul₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print interior_smul₀ /-\ntheorem interior_smul₀ {c : G₀} (hc : c ≠ 0) (s : Set α) : interior («expr • » c s) = «expr • » c (interior s) :=\n  ((Homeomorph.smulOfNeZero c hc).image_interior s).symm\n#align interior_smul₀ interior_smul₀\n-/\n\n",
 "interior_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print interior_smul /-\n@[to_additive]\ntheorem interior_smul (c : G) (s : Set α) : interior («expr • » c s) = «expr • » c (interior s) :=\n  ((Homeomorph.smul c).image_interior s).symm\n#align interior_smul interior_smul\n#align interior_vadd interior_vadd\n-/\n\n",
 "continuous_const_smul_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print continuous_const_smul_iff₀ /-\ntheorem continuous_const_smul_iff₀ (hc : c ≠ 0) : (Continuous fun x => «expr • » c (f x)) ↔ Continuous f :=\n  continuous_const_smul_iff (Units.mk0 c hc)\n#align continuous_const_smul_iff₀ continuous_const_smul_iff₀\n-/\n\n",
 "continuous_const_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print continuous_const_smul_iff /-\ntheorem continuous_const_smul_iff (hc : IsUnit c) : (Continuous fun x => «expr • » c (f x)) ↔ Continuous f :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ continuous_const_smul_iff u\n#align continuous_const_smul_iff continuous_const_smul_iff\n-/\n\n",
 "continuousWithinAt_const_smul_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print continuousWithinAt_const_smul_iff₀ /-\ntheorem continuousWithinAt_const_smul_iff₀ (hc : c ≠ 0) :\n    ContinuousWithinAt (fun x => «expr • » c (f x)) s b ↔ ContinuousWithinAt f s b :=\n  tendsto_const_smul_iff (Units.mk0 c hc)\n#align continuous_within_at_const_smul_iff₀ continuousWithinAt_const_smul_iff₀\n-/\n\n",
 "continuousWithinAt_const_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print continuousWithinAt_const_smul_iff /-\ntheorem continuousWithinAt_const_smul_iff (hc : IsUnit c) :\n    ContinuousWithinAt (fun x => «expr • » c (f x)) s b ↔ ContinuousWithinAt f s b :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ continuousWithinAt_const_smul_iff u\n#align continuous_within_at_const_smul_iff continuousWithinAt_const_smul_iff\n-/\n\n",
 "continuousOn_const_smul_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print continuousOn_const_smul_iff₀ /-\ntheorem continuousOn_const_smul_iff₀ (hc : c ≠ 0) : ContinuousOn (fun x => «expr • » c (f x)) s ↔ ContinuousOn f s :=\n  continuousOn_const_smul_iff (Units.mk0 c hc)\n#align continuous_on_const_smul_iff₀ continuousOn_const_smul_iff₀\n-/\n\n",
 "continuousOn_const_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print continuousOn_const_smul_iff /-\ntheorem continuousOn_const_smul_iff (hc : IsUnit c) : ContinuousOn (fun x => «expr • » c (f x)) s ↔ ContinuousOn f s :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ continuousOn_const_smul_iff u\n#align continuous_on_const_smul_iff continuousOn_const_smul_iff\n-/\n\n",
 "continuousAt_const_smul_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print continuousAt_const_smul_iff₀ /-\ntheorem continuousAt_const_smul_iff₀ (hc : c ≠ 0) : ContinuousAt (fun x => «expr • » c (f x)) b ↔ ContinuousAt f b :=\n  continuousAt_const_smul_iff (Units.mk0 c hc)\n#align continuous_at_const_smul_iff₀ continuousAt_const_smul_iff₀\n-/\n\n",
 "continuousAt_const_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print continuousAt_const_smul_iff /-\ntheorem continuousAt_const_smul_iff (hc : IsUnit c) : ContinuousAt (fun x => «expr • » c (f x)) b ↔ ContinuousAt f b :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ continuousAt_const_smul_iff u\n#align continuous_at_const_smul_iff continuousAt_const_smul_iff\n-/\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Continuous.const_smul /-\n@[continuity, to_additive]\ntheorem Continuous.const_smul (hg : Continuous g) (c : M) : Continuous fun x => «expr • » c (g x) :=\n  (continuous_const_smul _).comp hg\n#align continuous.const_smul Continuous.const_smul\n#align continuous.const_vadd Continuous.const_vadd\n-/\n\n",
 "comp_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print HasCompactSupport.comp_smul /-\ntheorem HasCompactSupport.comp_smul {β : Type _} [Zero β] {f : α → β} (h : HasCompactSupport f) {c : G₀} (hc : c ≠ 0) :\n    HasCompactSupport fun x => f («expr • » c x) :=\n  h.comp_homeomorph (Homeomorph.smulOfNeZero c hc)\n#align has_compact_support.comp_smul HasCompactSupport.comp_smul\n-/\n\n",
 "closure_smul₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print closure_smul₀ /-\ntheorem closure_smul₀ {E} [Zero E] [MulActionWithZero G₀ E] [TopologicalSpace E] [T1Space E] [ContinuousConstSMul G₀ E]\n    (c : G₀) (s : Set E) : closure («expr • » c s) = «expr • » c (closure s) :=\n  by\n  rcases eq_or_ne c 0 with (rfl | hc)\n  · rcases eq_empty_or_nonempty s with (rfl | hs)\n    · simp\n    · rw [zero_smul_set hs, zero_smul_set hs.closure]\n      exact closure_singleton\n  · exact ((Homeomorph.smulOfNeZero c hc).image_closure s).symm\n#align closure_smul₀ closure_smul₀\n-/\n\n",
 "closure_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print closure_smul /-\n@[to_additive]\ntheorem closure_smul (c : G) (s : Set α) : closure («expr • » c s) = «expr • » c (closure s) :=\n  ((Homeomorph.smul c).image_closure s).symm\n#align closure_smul closure_smul\n#align closure_vadd closure_vadd\n-/\n\n"}