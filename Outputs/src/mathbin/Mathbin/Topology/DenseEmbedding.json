{"to_embedding":
 "theorem to_embedding : embedding e :=\n  { induced := de.induced\n    inj := de.inj }\n#align to_embedding to_embedding\n\n",
 "tendsto_comap_nhds_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- ```\n γ -f→ α\ng↓     ↓e\n δ -h→ β\n```\n-/\ntheorem tendsto_comap_nhds_nhds {d : δ} {a : α} (di : dense_inducing i) (H : tendsto h ((nhds) d) ((nhds) (i a)))\n    (comm : h ∘ g = i ∘ f) : tendsto f (comap g ((nhds) d)) ((nhds) a) :=\n  by\n  have lim1 : map g (comap g ((nhds) d)) ≤ (nhds) d := map_comap_le\n  replace lim1 : map h (map g (comap g ((nhds) d))) ≤ map h ((nhds) d) := map_mono lim1\n  rw [filter.map_map, comm, ← filter.map_map, map_le_iff_le_comap] at lim1\n  have lim2 : comap i (map h ((nhds) d)) ≤ comap i ((nhds) (i a)) := comap_mono H\n  rw [← di.nhds_eq_comap] at lim2\n  exact le_trans lim1 lim2\n#align tendsto_comap_nhds_nhds tendsto_comap_nhds_nhds\n\n",
 "subtype":
 "protected theorem subtype (p : α → Prop) : dense_embedding (subtype_emb p e) :=\n  { dense :=\n      dense_iff_closure_eq.2 <| by\n        ext ⟨x, hx⟩\n        rw [image_eq_range] at hx\n        simpa [closure_subtype, ← range_comp, (· ∘ ·)]\n    inj := (de.inj.comp subtype.coe_injective).cod_restrict _\n    induced :=\n      (induced_iff_nhds_eq _).2 fun ⟨x, hx⟩ => by\n        simp [subtype_emb, nhds_subtype_eq_comap, de.to_inducing.nhds_eq_comap, comap_comap, (· ∘ ·)] }\n#align subtype subtype\n\n",
 "separable_space":
 "/-- If the domain of a `dense_embedding` is a separable space, then so is its codomain. -/\nprotected theorem separable_space [separable_space α] : separable_space β :=\n  de.to_dense_inducing.separable_space\n#align separable_space separable_space\n\n",
 "preconnected_space":
 "protected theorem preconnected_space [preconnected_space α] (di : dense_inducing i) : preconnected_space β :=\n  di.dense.preconnected_space di.continuous\n#align preconnected_space preconnected_space\n\n",
 "nhds_within_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\nprotected theorem nhds_within_ne_bot (di : dense_inducing i) (b : β) : ne_bot (nhds_within (range i) b) :=\n  di.dense.nhds_within_ne_bot b\n#align nhds_within_ne_bot nhds_within_ne_bot\n\n",
 "nhds_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-\nCopyright (c) 2019 Reid Barton. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Patrick Massot\n-/\ntheorem nhds_eq_comap (di : dense_inducing i) : ∀ a : α, (nhds) a = comap i (nhds <| i a) :=\n  di.to_inducing.nhds_eq_comap\n#align nhds_eq_comap nhds_eq_comap\n\n",
 "mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem dense_embedding.mk' [topological_space α] [topological_space β] (e : α → β) (c : continuous e)\n    (dense : dense_range e) (inj : function.injective e)\n    (H : ∀ (a : α), ∀ s ∈ (nhds) a, ∃ t ∈ (nhds) (e a), ∀ b, e b ∈ t → b ∈ s) : dense_embedding e :=\n  { dense_inducing.mk' e c dense H with inj }\n#align dense_embedding.mk' dense_embedding.mk'\n\n",
 "is_closed_property3":
 "theorem is_closed_property3 [topological_space β] {e : α → β} {p : β → β → β → Prop} (he : dense_range e)\n    (hp : is_closed { q : β × β × β | p q.1 q.2.1 q.2.2 }) (h : ∀ a₁ a₂ a₃, p (e a₁) (e a₂) (e a₃)) :\n    ∀ b₁ b₂ b₃, p b₁ b₂ b₃ :=\n  have : ∀ q : β × β × β, p q.1 q.2.1 q.2.2 := is_closed_property (he.prod_map <| he.prod_map he) hp fun _ => h _ _ _\n  fun b₁ b₂ b₃ => this ⟨b₁, b₂, b₃⟩\n#align is_closed_property3 is_closed_property3\n\n",
 "is_closed_property2":
 "theorem is_closed_property2 [topological_space β] {e : α → β} {p : β → β → Prop} (he : dense_range e)\n    (hp : is_closed { q : β × β | p q.1 q.2 }) (h : ∀ a₁ a₂, p (e a₁) (e a₂)) : ∀ b₁ b₂, p b₁ b₂ :=\n  have : ∀ q : β × β, p q.1 q.2 := is_closed_property (he.prod_map he) hp fun _ => h _ _\n  fun b₁ b₂ => this ⟨b₁, b₂⟩\n#align is_closed_property2 is_closed_property2\n\n",
 "is_closed_property":
 "theorem is_closed_property [topological_space β] {e : α → β} {p : β → Prop} (he : dense_range e)\n    (hp : is_closed { x | p x }) (h : ∀ a, p (e a)) : ∀ b, p b :=\n  have : univ ⊆ { b | p b } :=\n    calc\n      univ = closure (range e) := he.closure_range.symm\n      _ ⊆ closure { b | p b } := closure_mono <| range_subset_iff.mpr h\n      _ = _ := hp.closure_eq\n      \n  fun b => this trivial\n#align is_closed_property is_closed_property\n\n",
 "interior_compact_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- If `i : α → β` is a dense embedding with dense complement of the range, then any compact set in\n`α` has empty interior. -/\ntheorem interior_compact_eq_empty [t2_space β] (di : dense_inducing i) (hd : dense («expr ᶜ» (range i))) {s : set α}\n    (hs : is_compact s) : interior s = ∅ :=\n  by\n  refine' eq_empty_iff_forall_not_mem.2 fun x hx => _\n  rw [mem_interior_iff_mem_nhds] at hx\n  have := di.closure_image_mem_nhds hx\n  rw [(hs.image di.continuous).is_closed.closure_eq] at this\n  rcases hd.inter_nhds_nonempty this with ⟨y, hyi, hys⟩\n  exact hyi (image_subset_range _ _ hys)\n#align interior_compact_eq_empty interior_compact_eq_empty\n\n",
 "inj_iff":
 "theorem inj_iff {x y} : e x = e y ↔ x = y :=\n  de.inj.eq_iff\n#align inj_iff inj_iff\n\n",
 "induction_on₃":
 "@[elab_as_elim]\ntheorem dense_range.induction_on₃ [topological_space β] {e : α → β} {p : β → β → β → Prop} (he : dense_range e)\n    (hp : is_closed { q : β × β × β | p q.1 q.2.1 q.2.2 }) (h : ∀ a₁ a₂ a₃, p (e a₁) (e a₂) (e a₃)) (b₁ b₂ b₃ : β) :\n    p b₁ b₂ b₃ :=\n  is_closed_property3 he hp h _ _ _\n#align dense_range.induction_on₃ dense_range.induction_on₃\n\n",
 "induction_on₂":
 "@[elab_as_elim]\ntheorem dense_range.induction_on₂ [topological_space β] {e : α → β} {p : β → β → Prop} (he : dense_range e)\n    (hp : is_closed { q : β × β | p q.1 q.2 }) (h : ∀ a₁ a₂, p (e a₁) (e a₂)) (b₁ b₂ : β) : p b₁ b₂ :=\n  is_closed_property2 he hp h _ _\n#align dense_range.induction_on₂ dense_range.induction_on₂\n\n",
 "induction_on":
 "@[elab_as_elim]\ntheorem dense_range.induction_on [topological_space β] {e : α → β} (he : dense_range e) {p : β → Prop} (b₀ : β)\n    (hp : is_closed { b | p b }) (ih : ∀ a : α, p <| e a) : p b₀ :=\n  is_closed_property he hp ih b₀\n#align dense_range.induction_on dense_range.induction_on\n\n",
 "has_basis_of_dense_inducing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n-- Bourbaki GT III §3 no.4 Proposition 7 (generalised to any dense-inducing map to a T₃ space)\ntheorem filter.has_basis.has_basis_of_dense_inducing [topological_space α] [topological_space β] [t3_space β]\n    {ι : Type _} {s : ι → set α} {p : ι → Prop} {x : α} (h : ((nhds) x).has_basis p s) {f : α → β}\n    (hf : dense_inducing f) : ((nhds) (f x)).has_basis p fun i => closure <| «expr '' » f (s i) :=\n  by\n  rw [filter.has_basis_iff] at h⊢\n  intro T\n  refine' ⟨fun hT => _, fun hT => _⟩\n  · obtain ⟨T', hT₁, hT₂, hT₃⟩ := exists_mem_nhds_is_closed_subset hT\n    have hT₄ : «expr ⁻¹' » f T' ∈ (nhds) x :=\n      by\n      rw [hf.to_inducing.nhds_eq_comap x]\n      exact ⟨T', hT₁, subset.rfl⟩\n    obtain ⟨i, hi, hi'⟩ := (h _).mp hT₄\n    exact\n      ⟨i, hi,\n        (closure_mono (image_subset f hi')).trans\n          (subset.trans (closure_minimal (image_subset_iff.mpr subset.rfl) hT₂) hT₃)⟩\n  · obtain ⟨i, hi, hi'⟩ := hT\n    suffices closure («expr '' » f (s i)) ∈ (nhds) (f x) by filter_upwards [this] using hi'\n    replace h := (h (s i)).mpr ⟨i, hi, subset.rfl⟩\n    exact hf.closure_image_mem_nhds h\n#align filter.has_basis.has_basis_of_dense_inducing filter.has_basis.has_basis_of_dense_inducing\n\n",
 "extend_unique_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem extend_unique_at [t2_space γ] {b : β} {f : α → γ} {g : β → γ} (di : dense_inducing i)\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        (comap i ((nhds) b)) (g (i x) = f x))\n    (hg : continuous_at g b) : di.extend f b = g b :=\n  by\n  refine' di.extend_eq_of_tendsto fun s hs => mem_map.2 _\n  suffices :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (comap i ((nhds) b)) (g (i x) ∈ s)\n  exact hf.mp (this.mono fun x hgx hfx => hfx ▸ hgx)\n  clear hf f\n  refine' eventually_comap.2 ((hg.eventually hs).mono _)\n  rintro _ hxs x rfl\n  exact hxs\n#align extend_unique_at extend_unique_at\n\n",
 "extend_unique":
 "theorem extend_unique [t2_space γ] {f : α → γ} {g : β → γ} (di : dense_inducing i) (hf : ∀ x, g (i x) = f x)\n    (hg : continuous g) : di.extend f = g :=\n  funext fun b => extend_unique_at di (eventually_of_forall hf) hg.continuous_at\n#align extend_unique extend_unique\n\n",
 "extend_eq_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem extend_eq_of_tendsto [t2_space γ] {b : β} {c : γ} {f : α → γ} (hf : tendsto f (comap i ((nhds) b)) ((nhds) c)) :\n    di.extend f b = c :=\n  haveI := di.comap_nhds_ne_bot\n  hf.lim_eq\n#align extend_eq_of_tendsto extend_eq_of_tendsto\n\n",
 "extend_eq_at'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem extend_eq_at' [t2_space γ] {f : α → γ} {a : α} (c : γ) (hf : tendsto f ((nhds) a) ((nhds) c)) :\n    di.extend f (i a) = f a :=\n  di.extend_eq_at (continuous_at_of_tendsto_nhds hf)\n#align extend_eq_at' extend_eq_at'\n\n",
 "extend_eq_at":
 "theorem extend_eq_at [t2_space γ] {f : α → γ} {a : α} (hf : continuous_at f a) : di.extend f (i a) = f a :=\n  extend_eq_of_tendsto _ <| di.nhds_eq_comap a ▸ hf\n#align extend_eq_at extend_eq_at\n\n",
 "extend_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Variation of `extend_eq` where we ask that `f` has a limit along `comap i (𝓝 b)` for each\n`b : β`. This is a strictly stronger assumption than continuity of `f`, but in a lot of cases\nyou'd have to prove it anyway to use `continuous_extend`, so this avoids doing the work twice. -/\ntheorem extend_eq' [t2_space γ] {f : α → γ} (di : dense_inducing i)\n    (hf : ∀ b, ∃ c, tendsto f (comap i ((nhds) b)) ((nhds) c)) (a : α) : di.extend f (i a) = f a :=\n  by\n  rcases hf (i a) with ⟨b, hb⟩\n  refine' di.extend_eq_at' b _\n  rwa [← di.to_inducing.nhds_eq_comap] at hb\n#align extend_eq' extend_eq'\n\n",
 "extend_eq":
 "theorem extend_eq [t2_space γ] {f : α → γ} (hf : continuous f) (a : α) : di.extend f (i a) = f a :=\n  di.extend_eq_at hf.continuous_at\n#align extend_eq extend_eq\n\n",
 "equalizer":
 "/-- Two continuous functions to a t2-space that agree on the dense range of a function are equal. -/\ntheorem dense_range.equalizer (hfd : dense_range f) {g h : β → γ} (hg : continuous g) (hh : continuous h)\n    (H : g ∘ f = h ∘ f) : g = h :=\n  funext fun y => hfd.induction_on y (is_closed_eq hg hh) <| congr_fun H\n#align dense_range.equalizer dense_range.equalizer\n\n",
 "dense_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem dense_image {s : set α} : dense («expr '' » e s) ↔ dense s :=\n  de.to_dense_inducing.dense_image\n#align dense_image dense_image\n\n",
 "dense_embedding_id":
 "theorem dense_embedding_id {α : Type _} [topological_space α] : dense_embedding (id : α → α) :=\n  { embedding_id with dense := dense_range_id }\n#align dense_embedding_id dense_embedding_id\n\n",
 "dense_embedding_coe":
 "theorem dense.dense_embedding_coe [topological_space α] {s : set α} (hs : dense s) : dense_embedding (coe : s → α) :=\n  { embedding_subtype_coe with dense := hs.dense_range_coe }\n#align dense.dense_embedding_coe dense.dense_embedding_coe\n\n",
 "continuous_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_extend [t3_space γ] {f : α → γ} (di : dense_inducing i)\n    (hf : ∀ b, ∃ c, tendsto f (comap i ((nhds) b)) ((nhds) c)) : continuous (di.extend f) :=\n  continuous_iff_continuous_at.mpr fun b => di.continuous_at_extend <| univ_mem' hf\n#align continuous_extend continuous_extend\n\n",
 "continuous_at_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_at_extend [t3_space γ] {b : β} {f : α → γ} (di : dense_inducing i)\n    (hf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) b)\n        (∃ c, tendsto f (comap i <| (nhds) x) ((nhds) c))) :\n    continuous_at (di.extend f) b := by\n  set φ := di.extend f\n  haveI := di.comap_nhds_ne_bot\n  suffices ∀ V' ∈ (nhds) (φ b), is_closed V' → «expr ⁻¹' » φ V' ∈ (nhds) b by\n    simpa [continuous_at, (closed_nhds_basis _).tendsto_right_iff]\n  intro V' V'_in V'_closed\n  set V₁ := { x | tendsto f (comap i <| (nhds) x) (nhds <| φ x) }\n  have V₁_in : V₁ ∈ (nhds) b := by\n    filter_upwards [hf]\n    rintro x ⟨c, hc⟩\n    dsimp [V₁, φ]\n    rwa [di.extend_eq_of_tendsto hc]\n  obtain ⟨V₂, V₂_in, V₂_op, hV₂⟩ : ∃ V₂ ∈ (nhds) b, is_open V₂ ∧ ∀ x ∈ «expr ⁻¹' » i V₂, f x ∈ V' := by\n    simpa [and_assoc'] using\n      ((nhds_basis_opens' b).comap i).tendsto_left_iff.mp (mem_of_mem_nhds V₁_in : b ∈ V₁) V' V'_in\n  suffices ∀ x ∈ V₁ ∩ V₂, φ x ∈ V' by filter_upwards [inter_mem V₁_in V₂_in] using this\n  rintro x ⟨x_in₁, x_in₂⟩\n  have hV₂x : V₂ ∈ (nhds) x := is_open.mem_nhds V₂_op x_in₂\n  apply V'_closed.mem_of_tendsto x_in₁\n  use V₂\n  tauto\n#align continuous_at_extend continuous_at_extend\n\n",
 "continuous":
 "protected theorem continuous (di : dense_inducing i) : continuous i :=\n  di.to_inducing.continuous\n#align continuous continuous\n\n",
 "comap_nhds_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem comap_nhds_ne_bot (di : dense_inducing i) (b : β) : ne_bot (comap i ((nhds) b)) :=\n  comap_ne_bot fun s hs =>\n    let ⟨_, ⟨ha, a, rfl⟩⟩ := mem_closure_iff_nhds.1 (di.dense b) s hs\n    ⟨a, ha⟩\n#align comap_nhds_ne_bot comap_nhds_ne_bot\n\n",
 "closure_range":
 "theorem closure_range : closure (range i) = univ :=\n  di.dense.closure_range\n#align closure_range closure_range\n\n",
 "closure_image_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem closure_image_mem_nhds {s : set α} {a : α} (di : dense_inducing i) (hs : s ∈ (nhds) a) :\n    closure («expr '' » i s) ∈ (nhds) (i a) :=\n  by\n  rw [di.nhds_eq_comap a, ((nhds_basis_opens _).comap _).mem_iff] at hs\n  rcases hs with ⟨U, ⟨haU, hUo⟩, sub : «expr ⁻¹' » i U ⊆ s⟩\n  refine' mem_of_superset (hUo.mem_nhds haU) _\n  calc\n    U ⊆ closure («expr '' » i («expr ⁻¹' » i U)) := di.dense.subset_closure_image_preimage_of_is_open hUo\n    _ ⊆ closure («expr '' » i s) := closure_mono (image_subset i sub)\n    \n#align closure_image_mem_nhds closure_image_mem_nhds\n\n",
 "Prod":
 "#print Prod /-\n/-- The product of two dense embeddings is a dense embedding. -/\nprotected theorem Prod {e₁ : α → β} {e₂ : γ → δ} (de₁ : dense_embedding e₁) (de₂ : dense_embedding e₂) :\n    dense_embedding fun p : α × γ => (e₁ p.1, e₂ p.2) :=\n  { dense_inducing.prod de₁.to_dense_inducing de₂.to_dense_inducing with\n    inj := fun ⟨x₁, x₂⟩ ⟨y₁, y₂⟩ => by simp <;> exact fun h₁ h₂ => ⟨de₁.inj h₁, de₂.inj h₂⟩ }\n#align prod Prod\n-/\n\n"}