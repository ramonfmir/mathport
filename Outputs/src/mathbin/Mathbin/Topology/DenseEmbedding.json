{"to_embedding":
 "theorem to_embedding : Embedding e :=\n  { induced := de.induced\n    inj := de.inj }\n#align to_embedding to_embedding\n\n",
 "tendsto_comap_nhds_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- ```\n Œ≥ -f‚Üí Œ±\ng‚Üì     ‚Üìe\n Œ¥ -h‚Üí Œ≤\n```\n-/\ntheorem tendsto_comap_nhds_nhds {d : Œ¥} {a : Œ±} (di : DenseInducing i) (H : Tendsto h ((nhds) d) ((nhds) (i a)))\n    (comm : h ‚àò g = i ‚àò f) : Tendsto f (comap g ((nhds) d)) ((nhds) a) :=\n  by\n  have lim1 : map g (comap g ((nhds) d)) ‚â§ (nhds) d := map_comap_le\n  replace lim1 : map h (map g (comap g ((nhds) d))) ‚â§ map h ((nhds) d) := map_mono lim1\n  rw [Filter.map_map, comm, ‚Üê Filter.map_map, map_le_iff_le_comap] at lim1\n  have lim2 : comap i (map h ((nhds) d)) ‚â§ comap i ((nhds) (i a)) := comap_mono H\n  rw [‚Üê di.nhds_eq_comap] at lim2\n  exact le_trans lim1 lim2\n#align tendsto_comap_nhds_nhds tendsto_comap_nhds_nhds\n\n",
 "separable_space":
 "/-- If the domain of a `dense_embedding` is a separable space, then so is its codomain. -/\nprotected theorem separable_space [SeparableSpace Œ±] : SeparableSpace Œ≤ :=\n  de.to_dense_inducing.separable_space\n#align separable_space separable_space\n\n",
 "nhds_within_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\nprotected theorem nhds_within_ne_bot (di : DenseInducing i) (b : Œ≤) : NeBot (nhds_within (range i) b) :=\n  di.dense.nhds_within_ne_bot b\n#align nhds_within_ne_bot nhds_within_ne_bot\n\n",
 "nhds_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-\nCopyright (c) 2019 Reid Barton. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes H√∂lzl, Mario Carneiro, Patrick Massot\n-/\ntheorem nhds_eq_comap (di : DenseInducing i) : ‚àÄ a : Œ±, (nhds) a = comap i (nhds <| i a) :=\n  di.to_inducing.nhds_eq_comap\n#align nhds_eq_comap nhds_eq_comap\n\n",
 "mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print DenseEmbedding.mk' /-\ntheorem DenseEmbedding.mk' [TopologicalSpace Œ±] [TopologicalSpace Œ≤] (e : Œ± ‚Üí Œ≤) (c : Continuous e)\n    (dense : DenseRange e) (inj : function.injective e)\n    (H : ‚àÄ (a : Œ±), ‚àÄ s ‚àà (nhds) a, ‚àÉ t ‚àà (nhds) (e a), ‚àÄ b, e b ‚àà t ‚Üí b ‚àà s) : DenseEmbedding e :=\n  { DenseInducing.mk' e c Dense H with inj }\n#align dense_embedding.mk' DenseEmbedding.mk'\n-/\n\n",
 "isClosed_property3":
 "#print isClosed_property3 /-\ntheorem isClosed_property3 [TopologicalSpace Œ≤] {e : Œ± ‚Üí Œ≤} {p : Œ≤ ‚Üí Œ≤ ‚Üí Œ≤ ‚Üí Prop} (he : DenseRange e)\n    (hp : IsClosed { q : Œ≤ √ó Œ≤ √ó Œ≤ | p q.1 q.2.1 q.2.2 }) (h : ‚àÄ a‚ÇÅ a‚ÇÇ a‚ÇÉ, p (e a‚ÇÅ) (e a‚ÇÇ) (e a‚ÇÉ)) :\n    ‚àÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ, p b‚ÇÅ b‚ÇÇ b‚ÇÉ :=\n  have : ‚àÄ q : Œ≤ √ó Œ≤ √ó Œ≤, p q.1 q.2.1 q.2.2 := isClosed_property (he.prod_map <| he.prod_map he) hp fun _ => h _ _ _\n  fun b‚ÇÅ b‚ÇÇ b‚ÇÉ => this ‚ü®b‚ÇÅ, b‚ÇÇ, b‚ÇÉ‚ü©\n#align is_closed_property3 isClosed_property3\n-/\n\n",
 "isClosed_property2":
 "#print isClosed_property2 /-\ntheorem isClosed_property2 [TopologicalSpace Œ≤] {e : Œ± ‚Üí Œ≤} {p : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (he : DenseRange e)\n    (hp : IsClosed { q : Œ≤ √ó Œ≤ | p q.1 q.2 }) (h : ‚àÄ a‚ÇÅ a‚ÇÇ, p (e a‚ÇÅ) (e a‚ÇÇ)) : ‚àÄ b‚ÇÅ b‚ÇÇ, p b‚ÇÅ b‚ÇÇ :=\n  have : ‚àÄ q : Œ≤ √ó Œ≤, p q.1 q.2 := isClosed_property (he.prod_map he) hp fun _ => h _ _\n  fun b‚ÇÅ b‚ÇÇ => this ‚ü®b‚ÇÅ, b‚ÇÇ‚ü©\n#align is_closed_property2 isClosed_property2\n-/\n\n",
 "isClosed_property":
 "#print isClosed_property /-\ntheorem isClosed_property [TopologicalSpace Œ≤] {e : Œ± ‚Üí Œ≤} {p : Œ≤ ‚Üí Prop} (he : DenseRange e)\n    (hp : IsClosed { x | p x }) (h : ‚àÄ a, p (e a)) : ‚àÄ b, p b :=\n  have : univ ‚äÜ { b | p b } :=\n    calc\n      univ = closure (range e) := he.closure_range.symm\n      _ ‚äÜ closure { b | p b } := (closure_mono <| range_subset_iff.mpr h)\n      _ = _ := hp.closure_eq\n      \n  fun b => this trivial\n#align is_closed_property isClosed_property\n-/\n\n",
 "interior_compact_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/-- If `i : Œ± ‚Üí Œ≤` is a dense embedding with dense complement of the range, then any compact set in\n`Œ±` has empty interior. -/\ntheorem interior_compact_eq_empty [T2Space Œ≤] (di : DenseInducing i) (hd : Dense (¬´expr ·∂ú¬ª (range i))) {s : Set Œ±}\n    (hs : IsCompact s) : interior s = ‚àÖ :=\n  by\n  refine' eq_empty_iff_forall_not_mem.2 fun x hx => _\n  rw [mem_interior_iff_mem_nhds] at hx\n  have := di.closure_image_mem_nhds hx\n  rw [(hs.image di.continuous).is_closed.closure_eq] at this\n  rcases hd.inter_nhds_nonempty this with ‚ü®y, hyi, hys‚ü©\n  exact hyi (image_subset_range _ _ hys)\n#align interior_compact_eq_empty interior_compact_eq_empty\n\n",
 "inj_iff":
 "theorem inj_iff {x y} : e x = e y ‚Üî x = y :=\n  de.inj.eq_iff\n#align inj_iff inj_iff\n\n",
 "induction_on‚ÇÉ":
 "#print DenseRange.induction_on‚ÇÉ /-\n@[elab_as_elim]\ntheorem DenseRange.induction_on‚ÇÉ [TopologicalSpace Œ≤] {e : Œ± ‚Üí Œ≤} {p : Œ≤ ‚Üí Œ≤ ‚Üí Œ≤ ‚Üí Prop} (he : DenseRange e)\n    (hp : IsClosed { q : Œ≤ √ó Œ≤ √ó Œ≤ | p q.1 q.2.1 q.2.2 }) (h : ‚àÄ a‚ÇÅ a‚ÇÇ a‚ÇÉ, p (e a‚ÇÅ) (e a‚ÇÇ) (e a‚ÇÉ)) (b‚ÇÅ b‚ÇÇ b‚ÇÉ : Œ≤) :\n    p b‚ÇÅ b‚ÇÇ b‚ÇÉ :=\n  isClosed_property3 he hp h _ _ _\n#align dense_range.induction_on‚ÇÉ DenseRange.induction_on‚ÇÉ\n-/\n\n",
 "induction_on‚ÇÇ":
 "#print DenseRange.induction_on‚ÇÇ /-\n@[elab_as_elim]\ntheorem DenseRange.induction_on‚ÇÇ [TopologicalSpace Œ≤] {e : Œ± ‚Üí Œ≤} {p : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (he : DenseRange e)\n    (hp : IsClosed { q : Œ≤ √ó Œ≤ | p q.1 q.2 }) (h : ‚àÄ a‚ÇÅ a‚ÇÇ, p (e a‚ÇÅ) (e a‚ÇÇ)) (b‚ÇÅ b‚ÇÇ : Œ≤) : p b‚ÇÅ b‚ÇÇ :=\n  isClosed_property2 he hp h _ _\n#align dense_range.induction_on‚ÇÇ DenseRange.induction_on‚ÇÇ\n-/\n\n",
 "induction_on":
 "#print DenseRange.induction_on /-\n@[elab_as_elim]\ntheorem DenseRange.induction_on [TopologicalSpace Œ≤] {e : Œ± ‚Üí Œ≤} (he : DenseRange e) {p : Œ≤ ‚Üí Prop} (b‚ÇÄ : Œ≤)\n    (hp : IsClosed { b | p b }) (ih : ‚àÄ a : Œ±, p <| e a) : p b‚ÇÄ :=\n  isClosed_property he hp ih b‚ÇÄ\n#align dense_range.induction_on DenseRange.induction_on\n-/\n\n",
 "hasBasis_of_denseInducing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n#print Filter.HasBasis.hasBasis_of_denseInducing /-\n-- Bourbaki GT III ¬ß3 no.4 Proposition 7 (generalised to any dense-inducing map to a T‚ÇÉ space)\ntheorem Filter.HasBasis.hasBasis_of_denseInducing [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [T3Space Œ≤] {Œπ : Type _}\n    {s : Œπ ‚Üí Set Œ±} {p : Œπ ‚Üí Prop} {x : Œ±} (h : ((nhds) x).has_basis p s) {f : Œ± ‚Üí Œ≤} (hf : DenseInducing f) :\n    ((nhds) (f x)).has_basis p fun i => closure <| ¬´expr '' ¬ª f (s i) :=\n  by\n  rw [Filter.hasBasis_iff] at h‚ä¢\n  intro T\n  refine' ‚ü®fun hT => _, fun hT => _‚ü©\n  ¬∑ obtain ‚ü®T', hT‚ÇÅ, hT‚ÇÇ, hT‚ÇÉ‚ü© := exists_mem_nhds_isClosed_subset hT\n    have hT‚ÇÑ : ¬´expr ‚Åª¬π' ¬ª f T' ‚àà (nhds) x :=\n      by\n      rw [hf.to_inducing.nhds_eq_comap x]\n      exact ‚ü®T', hT‚ÇÅ, subset.rfl‚ü©\n    obtain ‚ü®i, hi, hi'‚ü© := (h _).mp hT‚ÇÑ\n    exact\n      ‚ü®i, hi,\n        (closure_mono (image_subset f hi')).trans\n          (subset.trans (closure_minimal (image_subset_iff.mpr subset.rfl) hT‚ÇÇ) hT‚ÇÉ)‚ü©\n  ¬∑ obtain ‚ü®i, hi, hi'‚ü© := hT\n    suffices closure (¬´expr '' ¬ª f (s i)) ‚àà (nhds) (f x) by filter_upwards [this]using hi'\n    replace h := (h (s i)).mpr ‚ü®i, hi, subset.rfl‚ü©\n    exact hf.closure_image_mem_nhds h\n#align filter.has_basis.has_basis_of_dense_inducing Filter.HasBasis.hasBasis_of_denseInducing\n-/\n\n",
 "extend_unique_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem extend_unique_at [T2Space Œ≥] {b : Œ≤} {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≥} (di : DenseInducing i)\n    (hf :\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n        (comap i ((nhds) b)) (g (i x) = f x))\n    (hg : ContinuousAt g b) : di.extend f b = g b :=\n  by\n  refine' di.extend_eq_of_tendsto fun s hs => mem_map.2 _\n  suffices :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n      (comap i ((nhds) b)) (g (i x) ‚àà s)\n  exact hf.mp (this.mono fun x hgx hfx => hfx ‚ñ∏ hgx)\n  clear hf f\n  refine' eventually_comap.2 ((hg.eventually hs).mono _)\n  rintro _ hxs x rfl\n  exact hxs\n#align extend_unique_at extend_unique_at\n\n",
 "extend_unique":
 "theorem extend_unique [T2Space Œ≥] {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≥} (di : DenseInducing i) (hf : ‚àÄ x, g (i x) = f x)\n    (hg : Continuous g) : di.extend f = g :=\n  funext fun b => extend_unique_at di (eventually_of_forall hf) hg.continuous_at\n#align extend_unique extend_unique\n\n",
 "extend_eq_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem extend_eq_of_tendsto [T2Space Œ≥] {b : Œ≤} {c : Œ≥} {f : Œ± ‚Üí Œ≥} (hf : Tendsto f (comap i ((nhds) b)) ((nhds) c)) :\n    di.extend f b = c :=\n  haveI := di.comap_nhds_ne_bot\n  hf.lim_eq\n#align extend_eq_of_tendsto extend_eq_of_tendsto\n\n",
 "extend_eq_at'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem extend_eq_at' [T2Space Œ≥] {f : Œ± ‚Üí Œ≥} {a : Œ±} (c : Œ≥) (hf : Tendsto f ((nhds) a) ((nhds) c)) :\n    di.extend f (i a) = f a :=\n  di.extend_eq_at (continuousAt_of_tendsto_nhds hf)\n#align extend_eq_at' extend_eq_at'\n\n",
 "extend_eq_at":
 "theorem extend_eq_at [T2Space Œ≥] {f : Œ± ‚Üí Œ≥} {a : Œ±} (hf : ContinuousAt f a) : di.extend f (i a) = f a :=\n  extend_eq_of_tendsto _ <| di.nhds_eq_comap a ‚ñ∏ hf\n#align extend_eq_at extend_eq_at\n\n",
 "extend_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Variation of `extend_eq` where we ask that `f` has a limit along `comap i (ùìù b)` for each\n`b : Œ≤`. This is a strictly stronger assumption than continuity of `f`, but in a lot of cases\nyou'd have to prove it anyway to use `continuous_extend`, so this avoids doing the work twice. -/\ntheorem extend_eq' [T2Space Œ≥] {f : Œ± ‚Üí Œ≥} (di : DenseInducing i)\n    (hf : ‚àÄ b, ‚àÉ c, Tendsto f (comap i ((nhds) b)) ((nhds) c)) (a : Œ±) : di.extend f (i a) = f a :=\n  by\n  rcases hf (i a) with ‚ü®b, hb‚ü©\n  refine' di.extend_eq_at' b _\n  rwa [‚Üê di.to_inducing.nhds_eq_comap] at hb\n#align extend_eq' extend_eq'\n\n",
 "extend_eq":
 "theorem extend_eq [T2Space Œ≥] {f : Œ± ‚Üí Œ≥} (hf : Continuous f) (a : Œ±) : di.extend f (i a) = f a :=\n  di.extend_eq_at hf.continuous_at\n#align extend_eq extend_eq\n\n",
 "equalizer":
 "#print DenseRange.equalizer /-\n/-- Two continuous functions to a t2-space that agree on the dense range of a function are equal. -/\ntheorem DenseRange.equalizer (hfd : DenseRange f) {g h : Œ≤ ‚Üí Œ≥} (hg : Continuous g) (hh : Continuous h)\n    (H : g ‚àò f = h ‚àò f) : g = h :=\n  funext fun y => hfd.induction_on y (isClosed_eq hg hh) <| congr_fun H\n#align dense_range.equalizer DenseRange.equalizer\n-/\n\n",
 "dense_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\ntheorem dense_image {s : Set Œ±} : Dense (¬´expr '' ¬ª e s) ‚Üî Dense s :=\n  de.to_dense_inducing.dense_image\n#align dense_image dense_image\n\n",
 "denseEmbedding_val":
 "#print Dense.denseEmbedding_val /-\ntheorem Dense.denseEmbedding_val [TopologicalSpace Œ±] {s : Set Œ±} (hs : Dense s) : DenseEmbedding (coe : s ‚Üí Œ±) :=\n  { embedding_subtype_val with dense := hs.dense_range_coe }\n#align dense.dense_embedding_coe Dense.denseEmbedding_val\n-/\n\n",
 "denseEmbedding_id":
 "#print denseEmbedding_id /-\ntheorem denseEmbedding_id {Œ± : Type _} [TopologicalSpace Œ±] : DenseEmbedding (id : Œ± ‚Üí Œ±) :=\n  { embedding_id with dense := denseRange_id }\n#align dense_embedding_id denseEmbedding_id\n-/\n\n",
 "continuous_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_extend [T3Space Œ≥] {f : Œ± ‚Üí Œ≥} (di : DenseInducing i)\n    (hf : ‚àÄ b, ‚àÉ c, Tendsto f (comap i ((nhds) b)) ((nhds) c)) : Continuous (di.extend f) :=\n  continuous_iff_continuousAt.mpr fun b => di.continuous_at_extend <| univ_mem' hf\n#align continuous_extend continuous_extend\n\n",
 "continuous_at_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_at_extend [T3Space Œ≥] {b : Œ≤} {f : Œ± ‚Üí Œ≥} (di : DenseInducing i)\n    (hf :\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" ((nhds) b)\n        (‚àÉ c, Tendsto f (comap i <| (nhds) x) ((nhds) c))) :\n    ContinuousAt (di.extend f) b := by\n  set œÜ := di.extend f\n  haveI := di.comap_nhds_ne_bot\n  suffices ‚àÄ V' ‚àà (nhds) (œÜ b), IsClosed V' ‚Üí ¬´expr ‚Åª¬π' ¬ª œÜ V' ‚àà (nhds) b by\n    simpa [ContinuousAt, (closed_nhds_basis _).tendsto_right_iff]\n  intro V' V'_in V'_closed\n  set V‚ÇÅ := { x | tendsto f (comap i <| (nhds) x) (nhds <| œÜ x) }\n  have V‚ÇÅ_in : V‚ÇÅ ‚àà (nhds) b := by\n    filter_upwards [hf]\n    rintro x ‚ü®c, hc‚ü©\n    dsimp [V‚ÇÅ, œÜ]\n    rwa [di.extend_eq_of_tendsto hc]\n  obtain ‚ü®V‚ÇÇ, V‚ÇÇ_in, V‚ÇÇ_op, hV‚ÇÇ‚ü© : ‚àÉ V‚ÇÇ ‚àà (nhds) b, IsOpen V‚ÇÇ ‚àß ‚àÄ x ‚àà ¬´expr ‚Åª¬π' ¬ª i V‚ÇÇ, f x ‚àà V' := by\n    simpa [and_assoc'] using\n      ((nhds_basis_opens' b).comap i).tendsto_left_iff.mp (mem_of_mem_nhds V‚ÇÅ_in : b ‚àà V‚ÇÅ) V' V'_in\n  suffices ‚àÄ x ‚àà V‚ÇÅ ‚à© V‚ÇÇ, œÜ x ‚àà V' by filter_upwards [inter_mem V‚ÇÅ_in V‚ÇÇ_in]using this\n  rintro x ‚ü®x_in‚ÇÅ, x_in‚ÇÇ‚ü©\n  have hV‚ÇÇx : V‚ÇÇ ‚àà (nhds) x := IsOpen.mem_nhds V‚ÇÇ_op x_in‚ÇÇ\n  apply V'_closed.mem_of_tendsto x_in‚ÇÅ\n  use V‚ÇÇ\n  tauto\n#align continuous_at_extend continuous_at_extend\n\n",
 "comap_nhds_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem comap_nhds_ne_bot (di : DenseInducing i) (b : Œ≤) : NeBot (comap i ((nhds) b)) :=\n  comap_neBot fun s hs =>\n    let ‚ü®_, ‚ü®ha, a, rfl‚ü©‚ü© := mem_closure_iff_nhds.1 (di.dense b) s hs\n    ‚ü®a, ha‚ü©\n#align comap_nhds_ne_bot comap_nhds_ne_bot\n\n",
 "closure_range":
 "theorem closure_range : closure (range i) = univ :=\n  di.dense.closure_range\n#align closure_range closure_range\n\n",
 "closure_image_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem closure_image_mem_nhds {s : Set Œ±} {a : Œ±} (di : DenseInducing i) (hs : s ‚àà (nhds) a) :\n    closure (¬´expr '' ¬ª i s) ‚àà (nhds) (i a) :=\n  by\n  rw [di.nhds_eq_comap a, ((nhds_basis_opens _).comap _).mem_iff] at hs\n  rcases hs with ‚ü®U, ‚ü®haU, hUo‚ü©, sub : ¬´expr ‚Åª¬π' ¬ª i U ‚äÜ s‚ü©\n  refine' mem_of_superset (hUo.mem_nhds haU) _\n  calc\n    U ‚äÜ closure (¬´expr '' ¬ª i (¬´expr ‚Åª¬π' ¬ª i U)) := di.dense.subset_closure_image_preimage_of_is_open hUo\n    _ ‚äÜ closure (¬´expr '' ¬ª i s) := closure_mono (image_subset i sub)\n    \n#align closure_image_mem_nhds closure_image_mem_nhds\n\n",
 "Subtype":
 "#print Subtype /-\nprotected theorem Subtype (p : Œ± ‚Üí Prop) : DenseEmbedding (subtypeEmb p e) :=\n  { dense :=\n      dense_iff_closure_eq.2 <| by\n        ext ‚ü®x, hx‚ü©\n        rw [image_eq_range] at hx\n        simpa [closure_subtype, ‚Üê range_comp, (¬∑ ‚àò ¬∑)]\n    inj := (de.inj.comp Subtype.coe_injective).cod_restrict _\n    induced :=\n      (induced_iff_nhds_eq _).2 fun ‚ü®x, hx‚ü© => by\n        simp [subtype_emb, nhds_subtype_eq_comap, de.to_inducing.nhds_eq_comap, comap_comap, (¬∑ ‚àò ¬∑)] }\n#align subtype Subtype\n-/\n\n",
 "Prod":
 "#print Prod /-\n/-- The product of two dense embeddings is a dense embedding. -/\nprotected theorem Prod {e‚ÇÅ : Œ± ‚Üí Œ≤} {e‚ÇÇ : Œ≥ ‚Üí Œ¥} (de‚ÇÅ : DenseEmbedding e‚ÇÅ) (de‚ÇÇ : DenseEmbedding e‚ÇÇ) :\n    DenseEmbedding fun p : Œ± √ó Œ≥ => (e‚ÇÅ p.1, e‚ÇÇ p.2) :=\n  { DenseInducing.prod de‚ÇÅ.to_dense_inducing de‚ÇÇ.to_dense_inducing with\n    inj := fun ‚ü®x‚ÇÅ, x‚ÇÇ‚ü© ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© => by simp <;> exact fun h‚ÇÅ h‚ÇÇ => ‚ü®de‚ÇÅ.inj h‚ÇÅ, de‚ÇÇ.inj h‚ÇÇ‚ü© }\n#align prod Prod\n-/\n\n",
 "PreconnectedSpace":
 "#print PreconnectedSpace /-\nprotected theorem PreconnectedSpace [PreconnectedSpace Œ±] (di : DenseInducing i) : PreconnectedSpace Œ≤ :=\n  di.dense.preconnected_space di.continuous\n#align preconnected_space PreconnectedSpace\n-/\n\n",
 "Continuous":
 "#print Continuous /-\nprotected theorem Continuous (di : DenseInducing i) : Continuous i :=\n  di.to_inducing.continuous\n#align continuous Continuous\n-/\n\n"}