{"unique":
 "theorem tendsto_locally_uniformly_on.unique [p.ne_bot] [t2_space Œ≤] {g : Œ± ‚Üí Œ≤}\n    (hf : tendsto_locally_uniformly_on F f p s) (hg : tendsto_locally_uniformly_on F g p s) : s.eq_on f g := fun a ha =>\n  tendsto_nhds_unique (hf.tendsto_at ha) (hg.tendsto_at ha)\n#align tendsto_locally_uniformly_on.unique tendsto_locally_uniformly_on.unique\n\n",
 "union":
 "theorem tendsto_locally_uniformly_on.union {s‚ÇÅ s‚ÇÇ : set Œ±} (hs‚ÇÅ : is_open s‚ÇÅ) (hs‚ÇÇ : is_open s‚ÇÇ)\n    (h‚ÇÅ : tendsto_locally_uniformly_on F f p s‚ÇÅ) (h‚ÇÇ : tendsto_locally_uniformly_on F f p s‚ÇÇ) :\n    tendsto_locally_uniformly_on F f p (s‚ÇÅ ‚à™ s‚ÇÇ) :=\n  by\n  rw [‚Üê sUnion_pair]\n  refine' tendsto_locally_uniformly_on_sUnion _ _ _ <;> simp [*]\n#align tendsto_locally_uniformly_on.union tendsto_locally_uniformly_on.union\n\n",
 "uniform_cauchy_seq_on_iff_uniform_cauchy_seq_on_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem uniform_cauchy_seq_on_iff_uniform_cauchy_seq_on_filter :\n    uniform_cauchy_seq_on F p s ‚Üî uniform_cauchy_seq_on_filter F p ((filter.principal) s) :=\n  by\n  simp only [uniform_cauchy_seq_on, uniform_cauchy_seq_on_filter]\n  refine' forall‚ÇÇ_congr fun u hu => _\n  rw [eventually_prod_principal_iff]\n#align uniform_cauchy_seq_on_iff_uniform_cauchy_seq_on_filter uniform_cauchy_seq_on_iff_uniform_cauchy_seq_on_filter\n\n",
 "uniform_cauchy_seq_on_filter":
 "/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem tendsto_uniformly_on_filter.uniform_cauchy_seq_on_filter (hF : tendsto_uniformly_on_filter F f p p') :\n    uniform_cauchy_seq_on_filter F p p' := by\n  intro u hu\n  rcases comp_symm_of_uniformity hu with ‚ü®t, ht, htsymm, htmem‚ü©\n  have := tendsto_swap4_prod.eventually ((hF t ht).prod_mk (hF t ht))\n  apply this.diag_of_prod_right.mono\n  simp only [and_imp, prod.forall]\n  intro n1 n2 x hl hr\n  exact Set.mem_of_mem_of_subset (prod_mk_mem_comp_rel (htsymm hl) hr) htmem\n#align tendsto_uniformly_on_filter.uniform_cauchy_seq_on_filter tendsto_uniformly_on_filter.uniform_cauchy_seq_on_filter\n\n",
 "uniform_cauchy_seq_on":
 "/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem tendsto_uniformly_on.uniform_cauchy_seq_on (hF : tendsto_uniformly_on F f p s) : uniform_cauchy_seq_on F p s :=\n  uniform_cauchy_seq_on_iff_uniform_cauchy_seq_on_filter.mpr hF.tendsto_uniformly_on_filter.uniform_cauchy_seq_on_filter\n#align tendsto_uniformly_on.uniform_cauchy_seq_on tendsto_uniformly_on.uniform_cauchy_seq_on\n\n",
 "tendsto_uniformly_on_univ":
 "theorem tendsto_uniformly_on_univ : tendsto_uniformly_on F f p univ ‚Üî tendsto_uniformly F f p := by\n  simp [tendsto_uniformly_on, tendsto_uniformly]\n#align tendsto_uniformly_on_univ tendsto_uniformly_on_univ\n\n",
 "tendsto_uniformly_on_singleton_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Uniform convergence on a singleton is equivalent to regular convergence -/\ntheorem tendsto_uniformly_on_singleton_iff_tendsto :\n    tendsto_uniformly_on F f p {x} ‚Üî tendsto (fun n : Œπ => F n x) p ((nhds) (f x)) :=\n  by\n  simp_rw [tendsto_uniformly_on_iff_tendsto, uniform.tendsto_nhds_right, tendsto_def]\n  exact forall‚ÇÇ_congr fun u hu => by simp [mem_prod_principal, preimage]\n#align tendsto_uniformly_on_singleton_iff_tendsto tendsto_uniformly_on_singleton_iff_tendsto\n\n",
 "tendsto_uniformly_on_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem uniform_cauchy_seq_on.tendsto_uniformly_on_of_tendsto [ne_bot p] (hF : uniform_cauchy_seq_on F p s)\n    (hF' : ‚àÄ x : Œ±, x ‚àà s ‚Üí tendsto (fun n => F n x) p ((nhds) (f x))) : tendsto_uniformly_on F f p s :=\n  tendsto_uniformly_on_iff_tendsto_uniformly_on_filter.mpr\n    (hF.uniform_cauchy_seq_on_filter.tendsto_uniformly_on_filter_of_tendsto hF')\n#align uniform_cauchy_seq_on.tendsto_uniformly_on_of_tendsto uniform_cauchy_seq_on.tendsto_uniformly_on_of_tendsto\n\n",
 "tendsto_uniformly_on_of_seq_tendsto_uniformly_on":
 "theorem tendsto_uniformly_on_of_seq_tendsto_uniformly_on {l : filter Œπ} [l.is_countably_generated]\n    (h : ‚àÄ u : ‚Ñï ‚Üí Œπ, tendsto u at_top l ‚Üí tendsto_uniformly_on (fun n => F (u n)) f at_top s) :\n    tendsto_uniformly_on F f l s :=\n  by\n  rw [tendsto_uniformly_on_iff_tendsto, tendsto_iff_seq_tendsto]\n  intro u hu\n  rw [tendsto_prod_iff'] at hu\n  specialize h (fun n => (u n).fst) hu.1\n  rw [tendsto_uniformly_on_iff_tendsto] at h\n  have :\n    (fun q : Œπ √ó Œ± => (f q.snd, F q.fst q.snd)) ‚àò u =\n      (fun q : ‚Ñï √ó Œ± => (f q.snd, F ((fun n : ‚Ñï => (u n).fst) q.fst) q.snd)) ‚àò fun n => (n, (u n).snd) :=\n    by\n    ext1 n\n    simp\n  rw [this]\n  refine' tendsto.comp h _\n  rw [tendsto_prod_iff']\n  exact ‚ü®tendsto_id, hu.2‚ü©\n#align tendsto_uniformly_on_of_seq_tendsto_uniformly_on tendsto_uniformly_on_of_seq_tendsto_uniformly_on\n\n",
 "tendsto_uniformly_on_iff_tendsto_uniformly_on_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem tendsto_uniformly_on_iff_tendsto_uniformly_on_filter :\n    tendsto_uniformly_on F f p s ‚Üî tendsto_uniformly_on_filter F f p ((filter.principal) s) :=\n  by\n  simp only [tendsto_uniformly_on, tendsto_uniformly_on_filter]\n  apply forall‚ÇÇ_congr\n  simp_rw [eventually_prod_principal_iff]\n  simp\n#align tendsto_uniformly_on_iff_tendsto_uniformly_on_filter tendsto_uniformly_on_iff_tendsto_uniformly_on_filter\n\n",
 "tendsto_uniformly_on_iff_tendsto_uniformly_comp_coe":
 "theorem tendsto_uniformly_on_iff_tendsto_uniformly_comp_coe :\n    tendsto_uniformly_on F f p s ‚Üî tendsto_uniformly (fun i (x : s) => F i x) (f ‚àò coe) p :=\n  by\n  apply forall‚ÇÇ_congr\n  intro u hu\n  simp\n#align tendsto_uniformly_on_iff_tendsto_uniformly_comp_coe tendsto_uniformly_on_iff_tendsto_uniformly_comp_coe\n\n",
 "tendsto_uniformly_on_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- A sequence of functions `F‚Çô` converges uniformly on a set `s` to a limiting function `f` w.r.t.\nfilter `p` iff the function `(n, x) ‚Ü¶ (f x, F‚Çô x)` converges along `p √ó·∂† ùìü s` to the uniformity.\nIn other words: one knows nothing about the behavior of `x` in this limit besides it being in `s`.\n-/\ntheorem tendsto_uniformly_on_iff_tendsto {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : filter Œπ} {s : set Œ±} :\n    tendsto_uniformly_on F f p s ‚Üî\n      tendsto (fun q : Œπ √ó Œ± => (f q.2, F q.1 q.2)) (filter.prod p ((filter.principal) s)) ((uniformity) Œ≤) :=\n  by simp [tendsto_uniformly_on_iff_tendsto_uniformly_on_filter, tendsto_uniformly_on_filter_iff_tendsto]\n#align tendsto_uniformly_on_iff_tendsto tendsto_uniformly_on_iff_tendsto\n\n",
 "tendsto_uniformly_on_iff_seq_tendsto_uniformly_on":
 "theorem tendsto_uniformly_on_iff_seq_tendsto_uniformly_on {l : filter Œπ} [l.is_countably_generated] :\n    tendsto_uniformly_on F f l s ‚Üî\n      ‚àÄ u : ‚Ñï ‚Üí Œπ, tendsto u at_top l ‚Üí tendsto_uniformly_on (fun n => F (u n)) f at_top s :=\n  ‚ü®tendsto_uniformly_on.seq_tendsto_uniformly_on, tendsto_uniformly_on_of_seq_tendsto_uniformly_on‚ü©\n#align tendsto_uniformly_on_iff_seq_tendsto_uniformly_on tendsto_uniformly_on_iff_seq_tendsto_uniformly_on\n\n",
 "tendsto_uniformly_on_filter_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem uniform_cauchy_seq_on_filter.tendsto_uniformly_on_filter_of_tendsto [ne_bot p]\n    (hF : uniform_cauchy_seq_on_filter F p p')\n    (hF' :\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" p'\n        (tendsto (fun n => F n x) p ((nhds) (f x)))) :\n    tendsto_uniformly_on_filter F f p p' :=\n  by\n  -- Proof idea: |f_n(x) - f(x)| ‚â§ |f_n(x) - f_m(x)| + |f_m(x) - f(x)|. We choose `n`\n  -- so that |f_n(x) - f_m(x)| is uniformly small across `s` whenever `m ‚â• n`. Then for\n  -- a fixed `x`, we choose `m` sufficiently large such that |f_m(x) - f(x)| is small.\n  intro u hu\n  rcases comp_symm_of_uniformity hu with ‚ü®t, ht, htsymm, htmem‚ü©\n  -- We will choose n, x, and m simultaneously. n and x come from hF. m comes from hF'\n  -- But we need to promote hF' to the full product filter to use it\n  have hmc :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n      (filter.prod (filter.prod p p) p') (tendsto (fun n : Œπ => F n x.snd) p ((nhds) (f x.snd))) :=\n    by\n    rw [eventually_prod_iff]\n    refine' ‚ü®fun x => true, by simp, _, hF', by simp‚ü©\n  -- To apply filter operations we'll need to do some order manipulation\n  rw [filter.eventually_swap_iff]\n  have := tendsto_prod_assoc.eventually (tendsto_prod_swap.eventually ((hF t ht).and hmc))\n  apply this.curry.mono\n  simp only [equiv.prod_assoc_apply, eventually_and, eventually_const, prod.snd_swap, prod.fst_swap, and_imp,\n    prod.forall]\n  -- Complete the proof\n  intro x n hx hm'\n  refine' Set.mem_of_mem_of_subset (mem_comp_rel.mpr _) htmem\n  rw [uniform.tendsto_nhds_right] at hm'\n  have := hx.and (hm' ht)\n  obtain ‚ü®m, hm‚ü© := this.exists\n  exact ‚ü®F m x, ‚ü®hm.2, htsymm hm.1‚ü©‚ü©\n#align\n  uniform_cauchy_seq_on_filter.tendsto_uniformly_on_filter_of_tendsto uniform_cauchy_seq_on_filter.tendsto_uniformly_on_filter_of_tendsto\n\n",
 "tendsto_uniformly_on_filter_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-\nCopyright (c) 2020 S√©bastien Gou√´zel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: S√©bastien Gou√´zel\n-/\n/-- A sequence of functions `F‚Çô` converges uniformly on a filter `p'` to a limiting function `f` w.r.t.\nfilter `p` iff the function `(n, x) ‚Ü¶ (f x, F‚Çô x)` converges along `p √ó·∂† p'` to the uniformity.\nIn other words: one knows nothing about the behavior of `x` in this limit besides it being in `p'`.\n-/\ntheorem tendsto_uniformly_on_filter_iff_tendsto :\n    tendsto_uniformly_on_filter F f p p' ‚Üî\n      tendsto (fun q : Œπ √ó Œ± => (f q.2, F q.1 q.2)) (filter.prod p p') ((uniformity) Œ≤) :=\n  forall‚ÇÇ_congr fun u u_in => by simp [mem_map, filter.eventually, mem_prod_iff, preimage]\n#align tendsto_uniformly_on_filter_iff_tendsto tendsto_uniformly_on_filter_iff_tendsto\n\n",
 "tendsto_uniformly_on_filter_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a sequence `g` converges to some `b`, then the sequence of constant functions\n`Œª n, Œª a, g n` converges to the constant function `Œª a, b` on any set `s` -/\ntheorem filter.tendsto.tendsto_uniformly_on_filter_const {g : Œπ ‚Üí Œ≤} {b : Œ≤} (hg : tendsto g p ((nhds) b))\n    (p' : filter Œ±) : tendsto_uniformly_on_filter (fun n : Œπ => fun a : Œ± => g n) (fun a : Œ± => b) p p' :=\n  by\n  rw [tendsto_uniformly_on_filter_iff_tendsto]\n  rw [uniform.tendsto_nhds_right] at hg\n  exact (hg.comp (tendsto_fst.comp ((@tendsto_id Œπ p).prod_map (@tendsto_id Œ± p')))).congr fun x => by simp\n#align filter.tendsto.tendsto_uniformly_on_filter_const filter.tendsto.tendsto_uniformly_on_filter_const\n\n",
 "tendsto_uniformly_on_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\ntheorem tendsto_uniformly.tendsto_uniformly_on_filter (h : tendsto_uniformly F f p) :\n    tendsto_uniformly_on_filter F f p (¬´expr‚ä§¬ª) := by rwa [‚Üê tendsto_uniformly_iff_tendsto_uniformly_on_filter]\n#align tendsto_uniformly.tendsto_uniformly_on_filter tendsto_uniformly.tendsto_uniformly_on_filter\n\n",
 "tendsto_uniformly_on_empty":
 "/-- Uniform convergence on the empty set is vacuously true -/\ntheorem tendsto_uniformly_on_empty : tendsto_uniformly_on F f p ‚àÖ := fun u hu => by simp\n#align tendsto_uniformly_on_empty tendsto_uniformly_on_empty\n\n",
 "tendsto_uniformly_on_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a sequence `g` converges to some `b`, then the sequence of constant functions\n`Œª n, Œª a, g n` converges to the constant function `Œª a, b` on any set `s` -/\ntheorem filter.tendsto.tendsto_uniformly_on_const {g : Œπ ‚Üí Œ≤} {b : Œ≤} (hg : tendsto g p ((nhds) b)) (s : set Œ±) :\n    tendsto_uniformly_on (fun n : Œπ => fun a : Œ± => g n) (fun a : Œ± => b) p s :=\n  tendsto_uniformly_on_iff_tendsto_uniformly_on_filter.mpr (hg.tendsto_uniformly_on_filter_const ((filter.principal) s))\n#align filter.tendsto.tendsto_uniformly_on_const filter.tendsto.tendsto_uniformly_on_const\n\n",
 "tendsto_uniformly_on":
 "protected theorem tendsto_uniformly.tendsto_uniformly_on (h : tendsto_uniformly F f p) : tendsto_uniformly_on F f p s :=\n  (tendsto_uniformly_on_univ.2 h).mono (subset_univ s)\n#align tendsto_uniformly.tendsto_uniformly_on tendsto_uniformly.tendsto_uniformly_on\n\n",
 "tendsto_uniformly_iff_tendsto_uniformly_on_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\ntheorem tendsto_uniformly_iff_tendsto_uniformly_on_filter :\n    tendsto_uniformly F f p ‚Üî tendsto_uniformly_on_filter F f p (¬´expr‚ä§¬ª) :=\n  by\n  simp only [tendsto_uniformly, tendsto_uniformly_on_filter]\n  apply forall‚ÇÇ_congr\n  simp_rw [‚Üê principal_univ, eventually_prod_principal_iff]\n  simp\n#align tendsto_uniformly_iff_tendsto_uniformly_on_filter tendsto_uniformly_iff_tendsto_uniformly_on_filter\n\n",
 "tendsto_uniformly_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- A sequence of functions `F‚Çô` converges uniformly to a limiting function `f` w.r.t.\nfilter `p` iff the function `(n, x) ‚Ü¶ (f x, F‚Çô x)` converges along `p √ó·∂† ‚ä§` to the uniformity.\nIn other words: one knows nothing about the behavior of `x` in this limit.\n-/\ntheorem tendsto_uniformly_iff_tendsto {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : filter Œπ} :\n    tendsto_uniformly F f p ‚Üî\n      tendsto (fun q : Œπ √ó Œ± => (f q.2, F q.1 q.2)) (filter.prod p (¬´expr‚ä§¬ª)) ((uniformity) Œ≤) :=\n  by simp [tendsto_uniformly_iff_tendsto_uniformly_on_filter, tendsto_uniformly_on_filter_iff_tendsto]\n#align tendsto_uniformly_iff_tendsto tendsto_uniformly_iff_tendsto\n\n",
 "tendsto_uniformly_iff_seq_tendsto_uniformly":
 "theorem tendsto_uniformly_iff_seq_tendsto_uniformly {l : filter Œπ} [l.is_countably_generated] :\n    tendsto_uniformly F f l ‚Üî ‚àÄ u : ‚Ñï ‚Üí Œπ, tendsto u at_top l ‚Üí tendsto_uniformly (fun n => F (u n)) f at_top :=\n  by\n  simp_rw [‚Üê tendsto_uniformly_on_univ]\n  exact tendsto_uniformly_on_iff_seq_tendsto_uniformly_on\n#align tendsto_uniformly_iff_seq_tendsto_uniformly tendsto_uniformly_iff_seq_tendsto_uniformly\n\n",
 "tendsto_uniformly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem uniform_continuous‚ÇÇ.tendsto_uniformly [uniform_space Œ±] [uniform_space Œ≥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥}\n    (h : uniform_continuous‚ÇÇ f) {x : Œ±} : tendsto_uniformly f (f x) ((nhds) x) :=\n  uniform_continuous_on.tendsto_uniformly univ_mem <| by rwa [univ_prod_univ, uniform_continuous_on_univ]\n#align uniform_continuous‚ÇÇ.tendsto_uniformly uniform_continuous‚ÇÇ.tendsto_uniformly\n\n",
 "tendsto_prod_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Uniform convergence to a constant function is equivalent to convergence in `p √ó·∂† ‚ä§`. -/\ntheorem tendsto_prod_top_iff {c : Œ≤} :\n    tendsto (uncurry F) (filter.prod p (¬´expr‚ä§¬ª)) ((nhds) c) ‚Üî tendsto_uniformly F (fun _ => c) p :=\n  by\n  rw [tendsto_uniformly_iff_tendsto_uniformly_on_filter]\n  exact tendsto_prod_filter_iff\n#align tendsto_prod_top_iff tendsto_prod_top_iff\n\n",
 "tendsto_prod_principal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Uniform convergence on a set `s` to a constant function is equivalent to convergence in\n`p √ó·∂† ùìü s`. -/\ntheorem tendsto_prod_principal_iff {c : Œ≤} :\n    tendsto (uncurry F) (filter.prod p ((filter.principal) s)) ((nhds) c) ‚Üî tendsto_uniformly_on F (fun _ => c) p s :=\n  by\n  rw [tendsto_uniformly_on_iff_tendsto_uniformly_on_filter]\n  exact tendsto_prod_filter_iff\n#align tendsto_prod_principal_iff tendsto_prod_principal_iff\n\n",
 "tendsto_prod_filter_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Uniform convergence on a filter `p'` to a constant function is equivalent to convergence in\n`p √ó·∂† p'`. -/\ntheorem tendsto_prod_filter_iff {c : Œ≤} :\n    tendsto (uncurry F) (filter.prod p p') ((nhds) c) ‚Üî tendsto_uniformly_on_filter F (fun _ => c) p p' :=\n  by\n  simp_rw [tendsto, nhds_eq_comap_uniformity, map_le_iff_le_comap.symm, map_map, le_def, mem_map]\n  exact forall‚ÇÇ_congr fun u hu => by simpa [eventually_iff]\n#align tendsto_prod_filter_iff tendsto_prod_filter_iff\n\n",
 "tendsto_locally_uniformly_on_univ":
 "theorem tendsto_locally_uniformly_on_univ : tendsto_locally_uniformly_on F f p univ ‚Üî tendsto_locally_uniformly F f p :=\n  by simp [tendsto_locally_uniformly_on, tendsto_locally_uniformly, nhds_within_univ]\n#align tendsto_locally_uniformly_on_univ tendsto_locally_uniformly_on_univ\n\n",
 "tendsto_locally_uniformly_on_tfae":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (K ¬´expr ‚äÜ ¬ª s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `tendsto_locally_uniformly_on_tfae [])\n      (Command.declSig\n       [(Term.instBinder \"[\" [] (Term.app `locally_compact_space [`Œ±]) \"]\")\n        (Term.explicitBinder \"(\" [`G] [\":\" (Term.arrow `Œπ \"‚Üí\" (Term.arrow `Œ± \"‚Üí\" `Œ≤))] [] \")\")\n        (Term.explicitBinder \"(\" [`g] [\":\" (Term.arrow `Œ± \"‚Üí\" `Œ≤)] [] \")\")\n        (Term.explicitBinder \"(\" [`p] [\":\" (Term.app `filter [`Œπ])] [] \")\")\n        (Term.explicitBinder \"(\" [`hs] [\":\" (Term.app `is_open [`s])] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(¬´term[_]¬ª\n           \"[\"\n           [(Term.app `tendsto_locally_uniformly_on [`G `g `p `s])\n            \",\"\n            (Term.forall\n             \"‚àÄ\"\n             [(Term.explicitBinder \"(\" [`K] [] [] \")\")\n              (Term.explicitBinder \"(\" [(Term.hole \"_\")] [\":\" (¬´term_‚äÜ_¬ª `K \"‚äÜ\" `s)] [] \")\")]\n             []\n             \",\"\n             (Term.arrow (Term.app `is_compact [`K]) \"‚Üí\" (Term.app `tendsto_uniformly_on [`G `g `p `K])))\n            \",\"\n            (Std.ExtendedBinder.¬´term‚àÄ__,_¬ª\n             \"‚àÄ\"\n             (Lean.binderIdent `x)\n             (¬´binderTerm‚àà_¬ª \"‚àà\" `s)\n             \",\"\n             (Std.ExtendedBinder.¬´term‚àÉ__,_¬ª\n              \"‚àÉ\"\n              (Lean.binderIdent `v)\n              (¬´binderTerm‚àà_¬ª \"‚àà\" (Term.app `nhds_within [`s `x]))\n              \",\"\n              (Term.app `tendsto_uniformly_on [`G `g `p `v])))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"‚Üí\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `h))\n               (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `K))\n               (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hK1))\n               (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hK2))]\n              [])\n             []\n             (Tactic.exact\n              \"exact\"\n              (Term.app\n               (Term.proj (Term.app `tendsto_locally_uniformly_on_iff_tendsto_uniformly_on_of_compact [`hK2]) \".\" `mp)\n               [(Term.app `h.mono [`hK1])]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"‚Üí\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `h))\n               (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `x))\n               (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hx))]\n              [])\n             []\n             (Std.Tactic.obtain\n              \"obtain\"\n              [(Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.tuple\n                  \"‚ü®\"\n                  [(Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `K)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed\n                     [(Std.Tactic.RCases.rcasesPat.tuple\n                       \"‚ü®\"\n                       [(Std.Tactic.RCases.rcasesPatLo\n                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hK1)])\n                         [])\n                        \",\"\n                        (Std.Tactic.RCases.rcasesPatLo\n                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hK2)])\n                         [])]\n                       \"‚ü©\")])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hK3)])\n                    [])]\n                  \"‚ü©\")])]\n              []\n              [\":=\"\n               [(Term.app\n                 (Term.proj (Term.proj (Term.app `compact_basis_nhds [`x]) \".\" `mem_iff) \".\" `mp)\n                 [(Term.app `hs.mem_nhds [`hx])])]])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor\n               \"‚ü®\"\n               [`K \",\" (Term.app `nhds_within_le_nhds [`hK1]) \",\" (Term.app `h [`K `hK3 `hK2])]\n               \"‚ü©\"))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"‚Üí\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `h))\n               (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `u))\n               (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hu))\n               (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `x))\n               (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hx))]\n              [])\n             []\n             (Std.Tactic.obtain\n              \"obtain\"\n              [(Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.tuple\n                  \"‚ü®\"\n                  [(Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `v)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv1)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv2)])\n                    [])]\n                  \"‚ü©\")])]\n              []\n              [\":=\" [(Term.app `h [`x `hx])]])\n             []\n             (Tactic.exact \"exact\" (Term.anonymousCtor \"‚ü®\" [`v \",\" `hv1 \",\" (Term.app `hv2 [`u `hu])] \"‚ü©\"))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"‚Üí\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `h))\n              (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `K))\n              (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hK1))\n              (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hK2))]\n             [])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.app\n              (Term.proj (Term.app `tendsto_locally_uniformly_on_iff_tendsto_uniformly_on_of_compact [`hK2]) \".\" `mp)\n              [(Term.app `h.mono [`hK1])]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"‚Üí\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `h))\n              (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `x))\n              (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hx))]\n             [])\n            []\n            (Std.Tactic.obtain\n             \"obtain\"\n             [(Std.Tactic.RCases.rcasesPatMed\n               [(Std.Tactic.RCases.rcasesPat.tuple\n                 \"‚ü®\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `K)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed\n                    [(Std.Tactic.RCases.rcasesPat.tuple\n                      \"‚ü®\"\n                      [(Std.Tactic.RCases.rcasesPatLo\n                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hK1)])\n                        [])\n                       \",\"\n                       (Std.Tactic.RCases.rcasesPatLo\n                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hK2)])\n                        [])]\n                      \"‚ü©\")])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hK3)])\n                   [])]\n                 \"‚ü©\")])]\n             []\n             [\":=\"\n              [(Term.app\n                (Term.proj (Term.proj (Term.app `compact_basis_nhds [`x]) \".\" `mem_iff) \".\" `mp)\n                [(Term.app `hs.mem_nhds [`hx])])]])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor\n              \"‚ü®\"\n              [`K \",\" (Term.app `nhds_within_le_nhds [`hK1]) \",\" (Term.app `h [`K `hK3 `hK2])]\n              \"‚ü©\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"‚Üí\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `h))\n              (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `u))\n              (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hu))\n              (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `x))\n              (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hx))]\n             [])\n            []\n            (Std.Tactic.obtain\n             \"obtain\"\n             [(Std.Tactic.RCases.rcasesPatMed\n               [(Std.Tactic.RCases.rcasesPat.tuple\n                 \"‚ü®\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `v)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv1)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv2)])\n                   [])]\n                 \"‚ü©\")])]\n             []\n             [\":=\" [(Term.app `h [`x `hx])]])\n            []\n            (Tactic.exact \"exact\" (Term.anonymousCtor \"‚ü®\" [`v \",\" `hv1 \",\" (Term.app `hv2 [`u `hu])] \"‚ü©\"))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.¬´¬∑ ¬ª \"¬∑\")))\n       [(Std.Tactic.rintro\n         \"rintro\"\n         [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `h))\n          (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `u))\n          (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hu))\n          (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `x))\n          (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hx))]\n         [])\n        []\n        (Std.Tactic.obtain\n         \"obtain\"\n         [(Std.Tactic.RCases.rcasesPatMed\n           [(Std.Tactic.RCases.rcasesPat.tuple\n             \"‚ü®\"\n             [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `v)]) [])\n              \",\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv1)])\n               [])\n              \",\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv2)])\n               [])]\n             \"‚ü©\")])]\n         []\n         [\":=\" [(Term.app `h [`x `hx])]])\n        []\n        (Tactic.exact \"exact\" (Term.anonymousCtor \"‚ü®\" [`v \",\" `hv1 \",\" (Term.app `hv2 [`u `hu])] \"‚ü©\"))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.anonymousCtor \"‚ü®\" [`v \",\" `hv1 \",\" (Term.app `hv2 [`u `hu])] \"‚ü©\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor \"‚ü®\" [`v \",\" `hv1 \",\" (Term.app `hv2 [`u `hu])] \"‚ü©\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `hv2 [`u `hu])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hu\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `u\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `hv2\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hv1\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `v\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.obtain\n       \"obtain\"\n       [(Std.Tactic.RCases.rcasesPatMed\n         [(Std.Tactic.RCases.rcasesPat.tuple\n           \"‚ü®\"\n           [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `v)]) [])\n            \",\"\n            (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv1)]) [])\n            \",\"\n            (Std.Tactic.RCases.rcasesPatLo\n             (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv2)])\n             [])]\n           \"‚ü©\")])]\n       []\n       [\":=\" [(Term.app `h [`x `hx])]])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `h [`x `hx])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hx\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rintro\n       \"rintro\"\n       [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `h))\n        (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `u))\n        (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hu))\n        (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `x))\n        (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `hx))]\n       [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"‚Üí\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '¬´‚Üí¬ª', expected 'token.¬´ ‚Üí ¬ª'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '¬´‚Üí¬ª', expected 'token.¬´ ‚Üî ¬ª'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '¬´‚Üí¬ª', expected 'token.¬´ ‚Üê ¬ª'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  tendsto_locally_uniformly_on_tfae\n  [ locally_compact_space Œ± ] ( G : Œπ ‚Üí Œ± ‚Üí Œ≤ ) ( g : Œ± ‚Üí Œ≤ ) ( p : filter Œπ ) ( hs : is_open s )\n    :\n      TFAE\n        [\n          tendsto_locally_uniformly_on G g p s\n            ,\n            ‚àÄ ( K ) ( _ : K ‚äÜ s ) , is_compact K ‚Üí tendsto_uniformly_on G g p K\n            ,\n            ‚àÄ x ‚àà s , ‚àÉ v ‚àà nhds_within s x , tendsto_uniformly_on G g p v\n          ]\n  :=\n    by\n      tfae_have 1 ‚Üí 2\n        ¬∑ rintro h K hK1 hK2 exact tendsto_locally_uniformly_on_iff_tendsto_uniformly_on_of_compact hK2 . mp h.mono hK1\n        tfae_have 2 ‚Üí 3\n        ¬∑\n          rintro h x hx\n            obtain ‚ü® K , ‚ü® hK1 , hK2 ‚ü© , hK3 ‚ü© := compact_basis_nhds x . mem_iff . mp hs.mem_nhds hx\n            refine' ‚ü® K , nhds_within_le_nhds hK1 , h K hK3 hK2 ‚ü©\n        tfae_have 3 ‚Üí 1\n        ¬∑ rintro h u hu x hx obtain ‚ü® v , hv1 , hv2 ‚ü© := h x hx exact ‚ü® v , hv1 , hv2 u hu ‚ü©\n        tfae_finish\n#align tendsto_locally_uniformly_on_tfae tendsto_locally_uniformly_on_tfae\n\n",
 "tendsto_locally_uniformly_on_sUnion":
 "theorem tendsto_locally_uniformly_on_sUnion (S : set (set Œ±)) (hS : ‚àÄ s ‚àà S, is_open s)\n    (h : ‚àÄ s ‚àà S, tendsto_locally_uniformly_on F f p s) : tendsto_locally_uniformly_on F f p (‚ãÉ‚ÇÄ S) :=\n  by\n  rw [sUnion_eq_bUnion]\n  exact tendsto_locally_uniformly_on_bUnion hS h\n#align tendsto_locally_uniformly_on_sUnion tendsto_locally_uniformly_on_sUnion\n\n",
 "tendsto_locally_uniformly_on_iff_tendsto_uniformly_on_of_compact":
 "/-- For a compact set `s`, locally uniform convergence on `s` is just uniform convergence on `s`. -/\ntheorem tendsto_locally_uniformly_on_iff_tendsto_uniformly_on_of_compact (hs : is_compact s) :\n    tendsto_locally_uniformly_on F f p s ‚Üî tendsto_uniformly_on F f p s :=\n  by\n  haveI : compact_space s := is_compact_iff_compact_space.mp hs\n  refine' ‚ü®fun h => _, tendsto_uniformly_on.tendsto_locally_uniformly_on‚ü©\n  rwa [tendsto_locally_uniformly_on_iff_tendsto_locally_uniformly_comp_coe,\n    tendsto_locally_uniformly_iff_tendsto_uniformly_of_compact_space, ‚Üê\n    tendsto_uniformly_on_iff_tendsto_uniformly_comp_coe] at h\n#align\n  tendsto_locally_uniformly_on_iff_tendsto_uniformly_on_of_compact tendsto_locally_uniformly_on_iff_tendsto_uniformly_on_of_compact\n\n",
 "tendsto_locally_uniformly_on_iff_tendsto_locally_uniformly_comp_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\ntheorem tendsto_locally_uniformly_on_iff_tendsto_locally_uniformly_comp_coe :\n    tendsto_locally_uniformly_on F f p s ‚Üî tendsto_locally_uniformly (fun i (x : s) => F i x) (f ‚àò coe) p :=\n  by\n  refine' forall‚ÇÇ_congr fun V hV => _\n  simp only [exists_prop, Function.comp_apply, SetCoe.forall, subtype.coe_mk]\n  refine' forall‚ÇÇ_congr fun x hx => ‚ü®_, _‚ü©\n  ¬∑ rintro ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü©\n    obtain ‚ü®u, hu‚ÇÅ, hu‚ÇÇ‚ü© := mem_nhds_within_iff_exists_mem_nhds_inter.mp ht‚ÇÅ\n    exact\n      ‚ü®¬´expr ‚Åª¬π' ¬ª coe u, (mem_nhds_subtype _ _ _).mpr ‚ü®u, hu‚ÇÅ, rfl.subset‚ü©,\n        ht‚ÇÇ.mono fun i hi y hy‚ÇÅ hy‚ÇÇ => hi y (hu‚ÇÇ ‚ü®hy‚ÇÇ, hy‚ÇÅ‚ü©)‚ü©\n  ¬∑ rintro ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü©\n    obtain ‚ü®u, hu‚ÇÅ, hu‚ÇÇ‚ü© := (mem_nhds_subtype _ _ _).mp ht‚ÇÅ\n    exact\n      ‚ü®u ‚à© s, mem_nhds_within_iff_exists_mem_nhds_inter.mpr ‚ü®u, hu‚ÇÅ, rfl.subset‚ü©,\n        ht‚ÇÇ.mono fun i hi y hy => hi y hy.2 (hu‚ÇÇ (by simp [hy.1]))‚ü©\n#align\n  tendsto_locally_uniformly_on_iff_tendsto_locally_uniformly_comp_coe tendsto_locally_uniformly_on_iff_tendsto_locally_uniformly_comp_coe\n\n",
 "tendsto_locally_uniformly_on_iff_forall_is_compact":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (K ¬´expr ‚äÜ ¬ª s) -/\ntheorem tendsto_locally_uniformly_on_iff_forall_is_compact [locally_compact_space Œ±] (hs : is_open s) :\n    tendsto_locally_uniformly_on F f p s ‚Üî ‚àÄ (K) (_ : K ‚äÜ s), is_compact K ‚Üí tendsto_uniformly_on F f p K :=\n  (tendsto_locally_uniformly_on_tfae F f p hs).out 0 1\n#align tendsto_locally_uniformly_on_iff_forall_is_compact tendsto_locally_uniformly_on_iff_forall_is_compact\n\n",
 "tendsto_locally_uniformly_on_iff_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem tendsto_locally_uniformly_on_iff_filter :\n    tendsto_locally_uniformly_on F f p s ‚Üî ‚àÄ x ‚àà s, tendsto_uniformly_on_filter F f p (nhds_within s x) :=\n  by\n  simp only [tendsto_uniformly_on_filter, eventually_prod_iff]\n  constructor\n  ¬∑ rintro h x hx u hu\n    obtain ‚ü®s, hs1, hs2‚ü© := h u hu x hx\n    exact ‚ü®_, hs2, _, eventually_of_mem hs1 fun x => id, fun i hi y hy => hi y hy‚ü©\n  ¬∑ rintro h u hu x hx\n    obtain ‚ü®pa, hpa, pb, hpb, h‚ü© := h x hx u hu\n    refine' ‚ü®pb, hpb, eventually_of_mem hpa fun i hi y hy => h hi hy‚ü©\n#align tendsto_locally_uniformly_on_iff_filter tendsto_locally_uniformly_on_iff_filter\n\n",
 "tendsto_locally_uniformly_on_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\ntheorem tendsto_locally_uniformly_on_bUnion {s : set Œ≥} {S : Œ≥ ‚Üí set Œ±} (hS : ‚àÄ i ‚àà s, is_open (S i))\n    (h : ‚àÄ i ‚àà s, tendsto_locally_uniformly_on F f p (S i)) :\n    tendsto_locally_uniformly_on F f p\n      (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (S i)) :=\n  by\n  rw [bUnion_eq_Union]\n  exact tendsto_locally_uniformly_on_Union (fun i => hS _ i.2) fun i => h _ i.2\n#align tendsto_locally_uniformly_on_bUnion tendsto_locally_uniformly_on_bUnion\n\n",
 "tendsto_locally_uniformly_on_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\ntheorem tendsto_locally_uniformly_on_Union {S : Œ≥ ‚Üí set Œ±} (hS : ‚àÄ i, is_open (S i))\n    (h : ‚àÄ i, tendsto_locally_uniformly_on F f p (S i)) :\n    tendsto_locally_uniformly_on F f p\n      (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (S i)) :=\n  by\n  rintro v hv x ‚ü®_, ‚ü®i, rfl‚ü©, hi : x ‚àà S i‚ü©\n  obtain ‚ü®t, ht, ht'‚ü© := h i v hv x hi\n  refine' ‚ü®t, _, ht'‚ü©\n  rw [(hS _).nhds_within_eq hi] at ht\n  exact mem_nhds_within_of_mem_nhds ht\n#align tendsto_locally_uniformly_on_Union tendsto_locally_uniformly_on_Union\n\n",
 "tendsto_locally_uniformly_on":
 "protected theorem tendsto_locally_uniformly.tendsto_locally_uniformly_on (h : tendsto_locally_uniformly F f p) :\n    tendsto_locally_uniformly_on F f p s :=\n  (tendsto_locally_uniformly_on_univ.mpr h).mono (subset_univ _)\n#align tendsto_locally_uniformly.tendsto_locally_uniformly_on tendsto_locally_uniformly.tendsto_locally_uniformly_on\n\n",
 "tendsto_locally_uniformly_iff_tendsto_uniformly_of_compact_space":
 "/-- On a compact space, locally uniform convergence is just uniform convergence. -/\ntheorem tendsto_locally_uniformly_iff_tendsto_uniformly_of_compact_space [compact_space Œ±] :\n    tendsto_locally_uniformly F f p ‚Üî tendsto_uniformly F f p :=\n  by\n  refine' ‚ü®fun h V hV => _, tendsto_uniformly.tendsto_locally_uniformly‚ü©\n  choose U hU using h V hV\n  obtain ‚ü®t, ht‚ü© := is_compact_univ.elim_nhds_subcover' (fun k hk => U k) fun k hk => (hU k).1\n  replace hU := fun x : t => (hU x).2\n  rw [‚Üê eventually_all] at hU\n  refine' hU.mono fun i hi x => _\n  specialize ht (mem_univ x)\n  simp only [exists_prop, mem_Union, SetCoe.exists, exists_and_right, subtype.coe_mk] at ht\n  obtain ‚ü®y, ‚ü®hy‚ÇÅ, hy‚ÇÇ‚ü©, hy‚ÇÉ‚ü© := ht\n  exact hi ‚ü®‚ü®y, hy‚ÇÅ‚ü©, hy‚ÇÇ‚ü© x hy‚ÇÉ\n#align\n  tendsto_locally_uniformly_iff_tendsto_uniformly_of_compact_space tendsto_locally_uniformly_iff_tendsto_uniformly_of_compact_space\n\n",
 "tendsto_locally_uniformly_iff_forall_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem tendsto_locally_uniformly_iff_forall_tendsto :\n    tendsto_locally_uniformly F f p ‚Üî\n      ‚àÄ x, tendsto (fun y : Œπ √ó Œ± => (f y.2, F y.1 y.2)) (filter.prod p ((nhds) x)) ((uniformity) Œ≤) :=\n  by\n  simp only [tendsto_locally_uniformly, filter.forall_in_swap, tendsto_def, mem_prod_iff, Set.prod_subset_iff]\n  refine' forall‚ÇÉ_congr fun x u hu => ‚ü®_, _‚ü©\n  ¬∑ rintro ‚ü®n, hn, hp‚ü©\n    exact ‚ü®_, hp, n, hn, fun i hi a ha => hi a ha‚ü©\n  ¬∑ rintro ‚ü®I, hI, n, hn, hu‚ü©\n    exact ‚ü®n, hn, by filter_upwards [hI] using hu‚ü©\n#align tendsto_locally_uniformly_iff_forall_tendsto tendsto_locally_uniformly_iff_forall_tendsto\n\n",
 "tendsto_locally_uniformly_iff_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_locally_uniformly_iff_filter :\n    tendsto_locally_uniformly F f p ‚Üî ‚àÄ x, tendsto_uniformly_on_filter F f p ((nhds) x) := by\n  simpa [‚Üê tendsto_locally_uniformly_on_univ, ‚Üê nhds_within_univ] using\n    @tendsto_locally_uniformly_on_iff_filter _ _ _ _ F f univ p _\n#align tendsto_locally_uniformly_iff_filter tendsto_locally_uniformly_iff_filter\n\n",
 "tendsto_locally_uniformly":
 "protected theorem tendsto_uniformly.tendsto_locally_uniformly (h : tendsto_uniformly F f p) :\n    tendsto_locally_uniformly F f p := fun u hu x => ‚ü®univ, univ_mem, by simpa using h u hu‚ü©\n#align tendsto_uniformly.tendsto_locally_uniformly tendsto_uniformly.tendsto_locally_uniformly\n\n",
 "tendsto_comp_of_locally_uniform_limit_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `F‚Çô` converges locally uniformly on a neighborhood of `x` within a set `s` to a function `f`\nwhich is continuous at `x` within `s `, and `g‚Çô` tends to `x` within `s`, then `F‚Çô (g‚Çô)` tends\nto `f x`. -/\ntheorem tendsto_comp_of_locally_uniform_limit_within (h : continuous_within_at f s x)\n    (hg : tendsto g p (nhds_within s x))\n    (hunif :\n      ‚àÄ u ‚àà (uniformity) Œ≤,\n        ‚àÉ t ‚àà nhds_within s x,\n          ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" p\n            (‚àÄ y ‚àà t, (f y, F n y) ‚àà u)) :\n    tendsto (fun n => F n (g n)) p ((nhds) (f x)) :=\n  by\n  apply uniform.tendsto_nhds_right.2 fun u‚ÇÄ hu‚ÇÄ => _\n  obtain ‚ü®u‚ÇÅ, h‚ÇÅ, u‚ÇÅ‚ÇÄ‚ü© : ‚àÉ (u : set (Œ≤ √ó Œ≤))(H : u ‚àà (uniformity) Œ≤), comp_rel u u ‚äÜ u‚ÇÄ := comp_mem_uniformity_sets hu‚ÇÄ\n  rcases hunif u‚ÇÅ h‚ÇÅ with ‚ü®s, sx, hs‚ü©\n  have A :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" p\n      (g n ‚àà s) :=\n    hg sx\n  have B :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" p\n      ((f x, f (g n)) ‚àà u‚ÇÅ) :=\n    hg (uniform.continuous_within_at_iff'_right.1 h h‚ÇÅ)\n  refine' ((hs.and A).and B).mono fun y hy => _\n  rcases hy with ‚ü®‚ü®H1, H2‚ü©, H3‚ü©\n  exact u‚ÇÅ‚ÇÄ (prod_mk_mem_comp_rel H3 (H1 _ H2))\n#align tendsto_comp_of_locally_uniform_limit_within tendsto_comp_of_locally_uniform_limit_within\n\n",
 "tendsto_comp_of_locally_uniform_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `F‚Çô` converges locally uniformly on a neighborhood of `x` to a function `f` which is\ncontinuous at `x`, and `g‚Çô` tends to `x`, then `F‚Çô (g‚Çô)` tends to `f x`. -/\ntheorem tendsto_comp_of_locally_uniform_limit (h : continuous_at f x) (hg : tendsto g p ((nhds) x))\n    (hunif :\n      ‚àÄ u ‚àà (uniformity) Œ≤,\n        ‚àÉ t ‚àà (nhds) x,\n          ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" p\n            (‚àÄ y ‚àà t, (f y, F n y) ‚àà u)) :\n    tendsto (fun n => F n (g n)) p ((nhds) (f x)) :=\n  by\n  rw [‚Üê continuous_within_at_univ] at h\n  rw [‚Üê nhds_within_univ] at hunif hg\n  exact tendsto_comp_of_locally_uniform_limit_within h hg hunif\n#align tendsto_comp_of_locally_uniform_limit tendsto_comp_of_locally_uniform_limit\n\n",
 "tendsto_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `F‚Çô` tends uniformly to `f`, and `g‚Çô` tends to `x`, then `F‚Çô g‚Çô` tends to `f x`. -/\ntheorem tendsto_uniformly.tendsto_comp (h : tendsto_uniformly F f p) (hf : continuous_at f x)\n    (hg : tendsto g p ((nhds) x)) : tendsto (fun n => F n (g n)) p ((nhds) (f x)) :=\n  h.tendsto_locally_uniformly.tendsto_comp hf hg\n#align tendsto_uniformly.tendsto_comp tendsto_uniformly.tendsto_comp\n\n",
 "tendsto_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_locally_uniformly_on.tendsto_at (hf : tendsto_locally_uniformly_on F f p s) {a : Œ±} (ha : a ‚àà s) :\n    tendsto (fun i => F i a) p ((nhds) (f a)) :=\n  by\n  refine' ((tendsto_locally_uniformly_on_iff_filter.mp hf) a ha).tendsto_at _\n  simpa only [filter.principal_singleton] using pure_le_nhds_within ha\n#align tendsto_locally_uniformly_on.tendsto_at tendsto_locally_uniformly_on.tendsto_at\n\n",
 "seq_tendsto_uniformly_on":
 "theorem tendsto_uniformly_on.seq_tendsto_uniformly_on {l : filter Œπ} (h : tendsto_uniformly_on F f l s) (u : ‚Ñï ‚Üí Œπ)\n    (hu : tendsto u at_top l) : tendsto_uniformly_on (fun n => F (u n)) f at_top s :=\n  by\n  rw [tendsto_uniformly_on_iff_tendsto] at h‚ä¢\n  have :\n    (fun q : ‚Ñï √ó Œ± => (f q.snd, F (u q.fst) q.snd)) =\n      (fun q : Œπ √ó Œ± => (f q.snd, F q.fst q.snd)) ‚àò fun p : ‚Ñï √ó Œ± => (u p.fst, p.snd) :=\n    by\n    ext1 x\n    simp\n  rw [this]\n  refine' h.comp _\n  rw [tendsto_prod_iff']\n  exact ‚ü®hu.comp tendsto_fst, tendsto_snd‚ü©\n#align tendsto_uniformly_on.seq_tendsto_uniformly_on tendsto_uniformly_on.seq_tendsto_uniformly_on\n\n",
 "prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem uniform_cauchy_seq_on.prod_map {Œπ' Œ±' Œ≤' : Type _} [uniform_space Œ≤'] {F' : Œπ' ‚Üí Œ±' ‚Üí Œ≤'} {p' : filter Œπ'}\n    {s' : set Œ±'} (h : uniform_cauchy_seq_on F p s) (h' : uniform_cauchy_seq_on F' p' s') :\n    uniform_cauchy_seq_on (fun i : Œπ √ó Œπ' => prod.map (F i.1) (F' i.2)) (p.prod p') (lower_set.prod s s') :=\n  by\n  intro u hu\n  rw [uniformity_prod_eq_prod, mem_map, mem_prod_iff] at hu\n  obtain ‚ü®v, hv, w, hw, hvw‚ü© := hu\n  simp_rw [mem_prod, Prod_map, and_imp, prod.forall]\n  rw [‚Üê Set.image_subset_iff] at hvw\n  apply (tendsto_swap4_prod.eventually ((h v hv).prod_mk (h' w hw))).mono\n  intro x hx a b ha hb\n  refine' hvw ‚ü®_, mk_mem_prod (hx.1 a ha) (hx.2 b hb), rfl‚ü©\n#align uniform_cauchy_seq_on.prod_map uniform_cauchy_seq_on.prod_map\n\n",
 "prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem uniform_cauchy_seq_on.prod' {Œ≤' : Type _} [uniform_space Œ≤'] {F' : Œπ ‚Üí Œ± ‚Üí Œ≤'} (h : uniform_cauchy_seq_on F p s)\n    (h' : uniform_cauchy_seq_on F' p s) : uniform_cauchy_seq_on (fun (i : Œπ) a => (F i a, F' i a)) p s :=\n  by\n  intro u hu\n  have hh : tendsto (fun x : Œπ => (x, x)) p (filter.prod p p) := tendsto_diag\n  exact (hh.prod_map hh).eventually ((h.prod h') u hu)\n#align uniform_cauchy_seq_on.prod' uniform_cauchy_seq_on.prod'\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem uniform_cauchy_seq_on.prod {Œπ' Œ≤' : Type _} [uniform_space Œ≤'] {F' : Œπ' ‚Üí Œ± ‚Üí Œ≤'} {p' : filter Œπ'}\n    (h : uniform_cauchy_seq_on F p s) (h' : uniform_cauchy_seq_on F' p' s) :\n    uniform_cauchy_seq_on (fun (i : Œπ √ó Œπ') a => (F i.fst a, F' i.snd a)) (filter.prod p p') s :=\n  (congr_arg _ s.inter_self).mp ((h.prod_map h').comp fun a => (a, a))\n#align uniform_cauchy_seq_on.prod uniform_cauchy_seq_on.prod\n\n",
 "mono_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem uniform_cauchy_seq_on_filter.mono_right {p'' : filter Œ±} (hf : uniform_cauchy_seq_on_filter F p p')\n    (hp : p'' ‚â§ p') : uniform_cauchy_seq_on_filter F p p'' :=\n  by\n  intro u hu\n  have := (hf u hu).filter_mono ((filter.prod p p).prod_mono_right hp)\n  exact this.mono (by simp)\n#align uniform_cauchy_seq_on_filter.mono_right uniform_cauchy_seq_on_filter.mono_right\n\n",
 "mono_left":
 "theorem uniform_cauchy_seq_on_filter.mono_left {p'' : filter Œπ} (hf : uniform_cauchy_seq_on_filter F p p')\n    (hp : p'' ‚â§ p) : uniform_cauchy_seq_on_filter F p'' p' :=\n  by\n  intro u hu\n  have := (hf u hu).filter_mono (p'.prod_mono_left (filter.prod_mono hp hp))\n  exact this.mono (by simp)\n#align uniform_cauchy_seq_on_filter.mono_left uniform_cauchy_seq_on_filter.mono_left\n\n",
 "mono":
 "theorem tendsto_locally_uniformly_on.mono (h : tendsto_locally_uniformly_on F f p s) (h' : s' ‚äÜ s) :\n    tendsto_locally_uniformly_on F f p s' := by\n  intro u hu x hx\n  rcases h u hu x (h' hx) with ‚ü®t, ht, H‚ü©\n  exact ‚ü®t, nhds_within_mono x h' ht, H.mono fun n => id‚ü©\n#align tendsto_locally_uniformly_on.mono tendsto_locally_uniformly_on.mono\n\n",
 "continuous_within_at_of_locally_uniform_approx_of_continuous_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- A function which can be locally uniformly approximated by functions which are continuous\nwithin a set at a point is continuous within this set at this point. -/\ntheorem continuous_within_at_of_locally_uniform_approx_of_continuous_within_at (hx : x ‚àà s)\n    (L :\n      ‚àÄ u ‚àà (uniformity) Œ≤, ‚àÉ t ‚àà nhds_within s x, ‚àÉ F : Œ± ‚Üí Œ≤, continuous_within_at F s x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) :\n    continuous_within_at f s x :=\n  by\n  apply uniform.continuous_within_at_iff'_left.2 fun u‚ÇÄ hu‚ÇÄ => _\n  obtain ‚ü®u‚ÇÅ, h‚ÇÅ, u‚ÇÅ‚ÇÄ‚ü© : ‚àÉ (u : set (Œ≤ √ó Œ≤))(H : u ‚àà (uniformity) Œ≤), comp_rel u u ‚äÜ u‚ÇÄ := comp_mem_uniformity_sets hu‚ÇÄ\n  obtain ‚ü®u‚ÇÇ, h‚ÇÇ, hsymm, u‚ÇÇ‚ÇÅ‚ü© :\n    ‚àÉ (u : set (Œ≤ √ó Œ≤))(H : u ‚àà (uniformity) Œ≤), (‚àÄ {a b}, (a, b) ‚àà u ‚Üí (b, a) ‚àà u) ‚àß comp_rel u u ‚äÜ u‚ÇÅ :=\n    comp_symm_of_uniformity h‚ÇÅ\n  rcases L u‚ÇÇ h‚ÇÇ with ‚ü®t, tx, F, hFc, hF‚ü©\n  have A :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n      (nhds_within s x) ((f y, F y) ‚àà u‚ÇÇ) :=\n    eventually.mono tx hF\n  have B :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n      (nhds_within s x) ((F y, F x) ‚àà u‚ÇÇ) :=\n    uniform.continuous_within_at_iff'_left.1 hFc h‚ÇÇ\n  have C :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n      (nhds_within s x) ((f y, F x) ‚àà u‚ÇÅ) :=\n    (A.and B).mono fun y hy => u‚ÇÇ‚ÇÅ (prod_mk_mem_comp_rel hy.1 hy.2)\n  have : (F x, f x) ‚àà u‚ÇÅ := u‚ÇÇ‚ÇÅ (prod_mk_mem_comp_rel (refl_mem_uniformity h‚ÇÇ) (hsymm (A.self_of_nhds_within hx)))\n  exact C.mono fun y hy => u‚ÇÅ‚ÇÄ (prod_mk_mem_comp_rel hy this)\n#align\n  continuous_within_at_of_locally_uniform_approx_of_continuous_within_at continuous_within_at_of_locally_uniform_approx_of_continuous_within_at\n\n",
 "continuous_on_of_uniform_approx_of_continuous_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem continuous_on_of_uniform_approx_of_continuous_on\n    (L : ‚àÄ u ‚àà (uniformity) Œ≤, ‚àÉ F, continuous_on F s ‚àß ‚àÄ y ‚àà s, (f y, F y) ‚àà u) : continuous_on f s :=\n  continuous_on_of_locally_uniform_approx_of_continuous_within_at fun x hx u hu =>\n    ‚ü®s, self_mem_nhds_within, (L u hu).imp fun F hF => ‚ü®hF.1.continuous_within_at hx, hF.2‚ü©‚ü©\n#align continuous_on_of_uniform_approx_of_continuous_on continuous_on_of_uniform_approx_of_continuous_on\n\n",
 "continuous_on_of_locally_uniform_approx_of_continuous_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem continuous_on_of_locally_uniform_approx_of_continuous_within_at\n    (L :\n      ‚àÄ x ‚àà s, ‚àÄ u ‚àà (uniformity) Œ≤, ‚àÉ t ‚àà nhds_within s x, ‚àÉ F, continuous_within_at F s x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) :\n    continuous_on f s := fun x hx => continuous_within_at_of_locally_uniform_approx_of_continuous_within_at hx (L x hx)\n#align\n  continuous_on_of_locally_uniform_approx_of_continuous_within_at continuous_on_of_locally_uniform_approx_of_continuous_within_at\n\n",
 "continuous_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\nprotected theorem tendsto_uniformly_on.continuous_on (h : tendsto_uniformly_on F f p s)\n    (hc :\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" p\n        (continuous_on (F n) s))\n    [ne_bot p] : continuous_on f s :=\n  h.tendsto_locally_uniformly_on.continuous_on hc\n#align tendsto_uniformly_on.continuous_on tendsto_uniformly_on.continuous_on\n\n",
 "continuous_of_uniform_approx_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem continuous_of_uniform_approx_of_continuous (L : ‚àÄ u ‚àà (uniformity) Œ≤, ‚àÉ F, continuous F ‚àß ‚àÄ y, (f y, F y) ‚àà u) :\n    continuous f :=\n  continuous_iff_continuous_on_univ.mpr <|\n    continuous_on_of_uniform_approx_of_continuous_on <| by simpa [continuous_iff_continuous_on_univ] using L\n#align continuous_of_uniform_approx_of_continuous continuous_of_uniform_approx_of_continuous\n\n",
 "continuous_of_locally_uniform_approx_of_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem continuous_of_locally_uniform_approx_of_continuous_at\n    (L : ‚àÄ x : Œ±, ‚àÄ u ‚àà (uniformity) Œ≤, ‚àÉ t ‚àà (nhds) x, ‚àÉ F, continuous_at F x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) :\n    continuous f :=\n  continuous_iff_continuous_at.2 fun x => continuous_at_of_locally_uniform_approx_of_continuous_at (L x)\n#align continuous_of_locally_uniform_approx_of_continuous_at continuous_of_locally_uniform_approx_of_continuous_at\n\n",
 "continuous_at_of_locally_uniform_approx_of_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem continuous_at_of_locally_uniform_approx_of_continuous_at\n    (L : ‚àÄ u ‚àà (uniformity) Œ≤, ‚àÉ t ‚àà (nhds) x, ‚àÉ F, continuous_at F x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) : continuous_at f x :=\n  by\n  rw [‚Üê continuous_within_at_univ]\n  apply continuous_within_at_of_locally_uniform_approx_of_continuous_within_at (mem_univ _) _\n  simpa only [exists_prop, nhds_within_univ, continuous_within_at_univ] using L\n#align continuous_at_of_locally_uniform_approx_of_continuous_at continuous_at_of_locally_uniform_approx_of_continuous_at\n\n",
 "continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/-- A uniform limit of continuous functions is continuous. -/\nprotected theorem tendsto_uniformly.continuous (h : tendsto_uniformly F f p)\n    (hc :\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" p\n        (continuous (F n)))\n    [ne_bot p] : continuous f :=\n  h.tendsto_locally_uniformly.continuous hc\n#align tendsto_uniformly.continuous tendsto_uniformly.continuous\n\n",
 "congr_right":
 "theorem tendsto_locally_uniformly_on.congr_right {g : Œ± ‚Üí Œ≤} (hf : tendsto_locally_uniformly_on F f p s)\n    (hg : s.eq_on f g) : tendsto_locally_uniformly_on F g p s :=\n  by\n  rintro u hu x hx\n  obtain ‚ü®t, ht, h‚ü© := hf u hu x hx\n  refine' ‚ü®s ‚à© t, inter_mem self_mem_nhds_within ht, _‚ü©\n  filter_upwards [h] with i hi y hy using hg hy.1 ‚ñ∏ hi y hy.2\n#align tendsto_locally_uniformly_on.congr_right tendsto_locally_uniformly_on.congr_right\n\n",
 "congr":
 "theorem tendsto_locally_uniformly_on.congr {G : Œπ ‚Üí Œ± ‚Üí Œ≤} (hf : tendsto_locally_uniformly_on F f p s)\n    (hg : ‚àÄ n, s.eq_on (F n) (G n)) : tendsto_locally_uniformly_on G f p s :=\n  by\n  rintro u hu x hx\n  obtain ‚ü®t, ht, h‚ü© := hf u hu x hx\n  refine' ‚ü®s ‚à© t, inter_mem self_mem_nhds_within ht, _‚ü©\n  filter_upwards [h] with i hi y hy using hg i hy.1 ‚ñ∏ hi y hy.2\n#align tendsto_locally_uniformly_on.congr tendsto_locally_uniformly_on.congr\n\n",
 "comp_uniform_cauchy_seq_on":
 "/-- Composing on the left by a uniformly continuous function preserves\nuniform Cauchy sequences -/\ntheorem uniform_continuous.comp_uniform_cauchy_seq_on [uniform_space Œ≥] {g : Œ≤ ‚Üí Œ≥} (hg : uniform_continuous g)\n    (hf : uniform_cauchy_seq_on F p s) : uniform_cauchy_seq_on (fun n => g ‚àò F n) p s := fun u hu => hf _ (hg hu)\n#align uniform_continuous.comp_uniform_cauchy_seq_on uniform_continuous.comp_uniform_cauchy_seq_on\n\n",
 "comp_tendsto_uniformly_on_filter":
 "/-- Composing on the left by a uniformly continuous function preserves\n  uniform convergence on a filter -/\ntheorem uniform_continuous.comp_tendsto_uniformly_on_filter [uniform_space Œ≥] {g : Œ≤ ‚Üí Œ≥} (hg : uniform_continuous g)\n    (h : tendsto_uniformly_on_filter F f p p') : tendsto_uniformly_on_filter (fun i => g ‚àò F i) (g ‚àò f) p p' :=\n  fun u hu => h _ (hg hu)\n#align uniform_continuous.comp_tendsto_uniformly_on_filter uniform_continuous.comp_tendsto_uniformly_on_filter\n\n",
 "comp_tendsto_uniformly_on":
 "/-- Composing on the left by a uniformly continuous function preserves\n  uniform convergence on a set -/\ntheorem uniform_continuous.comp_tendsto_uniformly_on [uniform_space Œ≥] {g : Œ≤ ‚Üí Œ≥} (hg : uniform_continuous g)\n    (h : tendsto_uniformly_on F f p s) : tendsto_uniformly_on (fun i => g ‚àò F i) (g ‚àò f) p s := fun u hu => h _ (hg hu)\n#align uniform_continuous.comp_tendsto_uniformly_on uniform_continuous.comp_tendsto_uniformly_on\n\n",
 "comp_tendsto_uniformly":
 "/-- Composing on the left by a uniformly continuous function preserves uniform convergence -/\ntheorem uniform_continuous.comp_tendsto_uniformly [uniform_space Œ≥] {g : Œ≤ ‚Üí Œ≥} (hg : uniform_continuous g)\n    (h : tendsto_uniformly F f p) : tendsto_uniformly (fun i => g ‚àò F i) (g ‚àò f) p := fun u hu => h _ (hg hu)\n#align uniform_continuous.comp_tendsto_uniformly uniform_continuous.comp_tendsto_uniformly\n\n",
 "comp":
 "theorem tendsto_locally_uniformly.comp [topological_space Œ≥] (h : tendsto_locally_uniformly F f p) (g : Œ≥ ‚Üí Œ±)\n    (cg : continuous g) : tendsto_locally_uniformly (fun n => F n ‚àò g) (f ‚àò g) p :=\n  by\n  rw [‚Üê tendsto_locally_uniformly_on_univ] at h‚ä¢\n  rw [continuous_iff_continuous_on_univ] at cg\n  exact h.comp _ (maps_to_univ _ _) cg\n#align tendsto_locally_uniformly.comp tendsto_locally_uniformly.comp\n\n",
 "cauchy_map":
 "/-- If a sequence of functions is uniformly Cauchy on a set, then the values at each point form\na Cauchy sequence. -/\ntheorem uniform_cauchy_seq_on.cauchy_map [hp : ne_bot p] (hf : uniform_cauchy_seq_on F p s) (hx : x ‚àà s) :\n    cauchy (map (fun i => F i x) p) :=\n  by\n  simp only [cauchy_map_iff, hp, true_and_iff]\n  intro u hu\n  rw [mem_map]\n  filter_upwards [hf u hu] with p hp using hp x hx\n#align uniform_cauchy_seq_on.cauchy_map uniform_cauchy_seq_on.cauchy_map\n\n"}