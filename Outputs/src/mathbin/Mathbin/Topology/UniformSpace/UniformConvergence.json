{"unique":
 "#print TendstoLocallyUniformlyOn.unique /-\ntheorem TendstoLocallyUniformlyOn.unique [p.ne_bot] [T2Space Œ≤] {g : Œ± ‚Üí Œ≤} (hf : TendstoLocallyUniformlyOn F f p s)\n    (hg : TendstoLocallyUniformlyOn F g p s) : s.eq_on f g := fun a ha =>\n  tendsto_nhds_unique (hf.tendsto_at ha) (hg.tendsto_at ha)\n#align tendsto_locally_uniformly_on.unique TendstoLocallyUniformlyOn.unique\n-/\n\n",
 "union":
 "#print TendstoLocallyUniformlyOn.union /-\ntheorem TendstoLocallyUniformlyOn.union {s‚ÇÅ s‚ÇÇ : Set Œ±} (hs‚ÇÅ : IsOpen s‚ÇÅ) (hs‚ÇÇ : IsOpen s‚ÇÇ)\n    (h‚ÇÅ : TendstoLocallyUniformlyOn F f p s‚ÇÅ) (h‚ÇÇ : TendstoLocallyUniformlyOn F f p s‚ÇÇ) :\n    TendstoLocallyUniformlyOn F f p (s‚ÇÅ ‚à™ s‚ÇÇ) := by\n  rw [‚Üê sUnion_pair]\n  refine' tendstoLocallyUniformlyOn_union‚Çõ _ _ _ <;> simp [*]\n#align tendsto_locally_uniformly_on.union TendstoLocallyUniformlyOn.union\n-/\n\n",
 "uniformCauchySeqOn_iff_uniformCauchySeqOnFilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print uniformCauchySeqOn_iff_uniformCauchySeqOnFilter /-\ntheorem uniformCauchySeqOn_iff_uniformCauchySeqOnFilter :\n    UniformCauchySeqOn F p s ‚Üî UniformCauchySeqOnFilter F p ((filter.principal) s) :=\n  by\n  simp only [UniformCauchySeqOn, UniformCauchySeqOnFilter]\n  refine' forall‚ÇÇ_congr fun u hu => _\n  rw [eventually_prod_principal_iff]\n#align uniform_cauchy_seq_on_iff_uniform_cauchy_seq_on_filter uniformCauchySeqOn_iff_uniformCauchySeqOnFilter\n-/\n\n",
 "uniformCauchySeqOnFilter":
 "#print TendstoUniformlyOnFilter.uniformCauchySeqOnFilter /-\n/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem TendstoUniformlyOnFilter.uniformCauchySeqOnFilter (hF : TendstoUniformlyOnFilter F f p p') :\n    UniformCauchySeqOnFilter F p p' := by\n  intro u hu\n  rcases comp_symm_of_uniformity hu with ‚ü®t, ht, htsymm, htmem‚ü©\n  have := tendsto_swap4_prod.eventually ((hF t ht).prod_mk (hF t ht))\n  apply this.diag_of_prod_right.mono\n  simp only [and_imp, Prod.forall]\n  intro n1 n2 x hl hr\n  exact Set.mem_of_mem_of_subset (prod_mk_mem_compRel (htsymm hl) hr) htmem\n#align tendsto_uniformly_on_filter.uniform_cauchy_seq_on_filter TendstoUniformlyOnFilter.uniformCauchySeqOnFilter\n-/\n\n",
 "uniformCauchySeqOn":
 "#print TendstoUniformlyOn.uniformCauchySeqOn /-\n/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem TendstoUniformlyOn.uniformCauchySeqOn (hF : TendstoUniformlyOn F f p s) : UniformCauchySeqOn F p s :=\n  uniformCauchySeqOn_iff_uniformCauchySeqOnFilter.mpr hF.tendsto_uniformly_on_filter.uniform_cauchy_seq_on_filter\n#align tendsto_uniformly_on.uniform_cauchy_seq_on TendstoUniformlyOn.uniformCauchySeqOn\n-/\n\n",
 "tendsto_prod_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_prod_top_iff /-\n/-- Uniform convergence to a constant function is equivalent to convergence in `p √ó·∂† ‚ä§`. -/\ntheorem tendsto_prod_top_iff {c : Œ≤} :\n    Tendsto (uncurry F) (filter.prod p (¬´expr‚ä§¬ª)) ((nhds) c) ‚Üî TendstoUniformly F (fun _ => c) p :=\n  by\n  rw [tendstoUniformly_iff_tendstoUniformlyOnFilter]\n  exact tendsto_prod_filter_iff\n#align tendsto_prod_top_iff tendsto_prod_top_iff\n-/\n\n",
 "tendsto_prod_principal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_prod_principal_iff /-\n/-- Uniform convergence on a set `s` to a constant function is equivalent to convergence in\n`p √ó·∂† ùìü s`. -/\ntheorem tendsto_prod_principal_iff {c : Œ≤} :\n    Tendsto (uncurry F) (filter.prod p ((filter.principal) s)) ((nhds) c) ‚Üî TendstoUniformlyOn F (fun _ => c) p s :=\n  by\n  rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter]\n  exact tendsto_prod_filter_iff\n#align tendsto_prod_principal_iff tendsto_prod_principal_iff\n-/\n\n",
 "tendsto_prod_filter_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uncurry -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_prod_filter_iff /-\n/-- Uniform convergence on a filter `p'` to a constant function is equivalent to convergence in\n`p √ó·∂† p'`. -/\ntheorem tendsto_prod_filter_iff {c : Œ≤} :\n    Tendsto (uncurry F) (filter.prod p p') ((nhds) c) ‚Üî TendstoUniformlyOnFilter F (fun _ => c) p p' :=\n  by\n  simp_rw [tendsto, nhds_eq_comap_uniformity, map_le_iff_le_comap.symm, map_map, le_def, mem_map]\n  exact forall‚ÇÇ_congr fun u hu => by simpa [eventually_iff]\n#align tendsto_prod_filter_iff tendsto_prod_filter_iff\n-/\n\n",
 "tendsto_comp_of_locally_uniform_limit_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_comp_of_locally_uniform_limit_within /-\n/-- If `F‚Çô` converges locally uniformly on a neighborhood of `x` within a set `s` to a function `f`\nwhich is continuous at `x` within `s `, and `g‚Çô` tends to `x` within `s`, then `F‚Çô (g‚Çô)` tends\nto `f x`. -/\ntheorem tendsto_comp_of_locally_uniform_limit_within (h : ContinuousWithinAt f s x) (hg : Tendsto g p (nhds_within s x))\n    (hunif :\n      ‚àÄ u ‚àà (uniformity) Œ≤,\n        ‚àÉ t ‚àà nhds_within s x,\n          ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" p\n            (‚àÄ y ‚àà t, (f y, F n y) ‚àà u)) :\n    Tendsto (fun n => F n (g n)) p ((nhds) (f x)) :=\n  by\n  apply Uniform.tendsto_nhds_right.2 fun u‚ÇÄ hu‚ÇÄ => _\n  obtain ‚ü®u‚ÇÅ, h‚ÇÅ, u‚ÇÅ‚ÇÄ‚ü© : ‚àÉ (u : Set (Œ≤ √ó Œ≤))(H : u ‚àà (uniformity) Œ≤), compRel u u ‚äÜ u‚ÇÄ := comp_mem_uniformity_sets hu‚ÇÄ\n  rcases hunif u‚ÇÅ h‚ÇÅ with ‚ü®s, sx, hs‚ü©\n  have A :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" p\n      (g n ‚àà s) :=\n    hg sx\n  have B :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" p\n      ((f x, f (g n)) ‚àà u‚ÇÅ) :=\n    hg (Uniform.continuousWithinAt_iff'_right.1 h h‚ÇÅ)\n  refine' ((hs.and A).and B).mono fun y hy => _\n  rcases hy with ‚ü®‚ü®H1, H2‚ü©, H3‚ü©\n  exact u‚ÇÅ‚ÇÄ (prod_mk_mem_compRel H3 (H1 _ H2))\n#align tendsto_comp_of_locally_uniform_limit_within tendsto_comp_of_locally_uniform_limit_within\n-/\n\n",
 "tendsto_comp_of_locally_uniform_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_comp_of_locally_uniform_limit /-\n/-- If `F‚Çô` converges locally uniformly on a neighborhood of `x` to a function `f` which is\ncontinuous at `x`, and `g‚Çô` tends to `x`, then `F‚Çô (g‚Çô)` tends to `f x`. -/\ntheorem tendsto_comp_of_locally_uniform_limit (h : ContinuousAt f x) (hg : Tendsto g p ((nhds) x))\n    (hunif :\n      ‚àÄ u ‚àà (uniformity) Œ≤,\n        ‚àÉ t ‚àà (nhds) x,\n          ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" p\n            (‚àÄ y ‚àà t, (f y, F n y) ‚àà u)) :\n    Tendsto (fun n => F n (g n)) p ((nhds) (f x)) :=\n  by\n  rw [‚Üê continuousWithinAt_univ] at h\n  rw [‚Üê nhdsWithin_univ] at hunif hg\n  exact tendsto_comp_of_locally_uniform_limit_within h hg hunif\n#align tendsto_comp_of_locally_uniform_limit tendsto_comp_of_locally_uniform_limit\n-/\n\n",
 "tendsto_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print TendstoUniformly.tendsto_comp /-\n/-- If `F‚Çô` tends uniformly to `f`, and `g‚Çô` tends to `x`, then `F‚Çô g‚Çô` tends to `f x`. -/\ntheorem TendstoUniformly.tendsto_comp (h : TendstoUniformly F f p) (hf : ContinuousAt f x)\n    (hg : Tendsto g p ((nhds) x)) : Tendsto (fun n => F n (g n)) p ((nhds) (f x)) :=\n  h.tendsto_locally_uniformly.tendsto_comp hf hg\n#align tendsto_uniformly.tendsto_comp TendstoUniformly.tendsto_comp\n-/\n\n",
 "tendsto_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print TendstoLocallyUniformlyOn.tendsto_at /-\ntheorem TendstoLocallyUniformlyOn.tendsto_at (hf : TendstoLocallyUniformlyOn F f p s) {a : Œ±} (ha : a ‚àà s) :\n    Tendsto (fun i => F i a) p ((nhds) (f a)) :=\n  by\n  refine' ((tendsto_locally_uniformly_on_iff_filter.mp hf) a ha).tendsto_at _\n  simpa only [Filter.principal_singleton] using pure_le_nhdsWithin ha\n#align tendsto_locally_uniformly_on.tendsto_at TendstoLocallyUniformlyOn.tendsto_at\n-/\n\n",
 "tendstoUniformly_iff_tendstoUniformlyOnFilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n#print tendstoUniformly_iff_tendstoUniformlyOnFilter /-\ntheorem tendstoUniformly_iff_tendstoUniformlyOnFilter :\n    TendstoUniformly F f p ‚Üî TendstoUniformlyOnFilter F f p (¬´expr‚ä§¬ª) :=\n  by\n  simp only [TendstoUniformly, TendstoUniformlyOnFilter]\n  apply forall‚ÇÇ_congr\n  simp_rw [‚Üê principal_univ, eventually_prod_principal_iff]\n  simp\n#align tendsto_uniformly_iff_tendsto_uniformly_on_filter tendstoUniformly_iff_tendstoUniformlyOnFilter\n-/\n\n",
 "tendstoUniformly_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print tendstoUniformly_iff_tendsto /-\n/-- A sequence of functions `F‚Çô` converges uniformly to a limiting function `f` w.r.t.\nfilter `p` iff the function `(n, x) ‚Ü¶ (f x, F‚Çô x)` converges along `p √ó·∂† ‚ä§` to the uniformity.\nIn other words: one knows nothing about the behavior of `x` in this limit.\n-/\ntheorem tendstoUniformly_iff_tendsto {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ} :\n    TendstoUniformly F f p ‚Üî Tendsto (fun q : Œπ √ó Œ± => (f q.2, F q.1 q.2)) (filter.prod p (¬´expr‚ä§¬ª)) ((uniformity) Œ≤) :=\n  by simp [tendstoUniformly_iff_tendstoUniformlyOnFilter, tendstoUniformlyOnFilter_iff_tendsto]\n#align tendsto_uniformly_iff_tendsto tendstoUniformly_iff_tendsto\n-/\n\n",
 "tendstoUniformly_iff_seq_tendstoUniformly":
 "#print tendstoUniformly_iff_seq_tendstoUniformly /-\ntheorem tendstoUniformly_iff_seq_tendstoUniformly {l : Filter Œπ} [l.is_countably_generated] :\n    TendstoUniformly F f l ‚Üî ‚àÄ u : ‚Ñï ‚Üí Œπ, Tendsto u atTop l ‚Üí TendstoUniformly (fun n => F (u n)) f atTop :=\n  by\n  simp_rw [‚Üê tendstoUniformlyOn_univ]\n  exact tendstoUniformlyOn_iff_seq_tendstoUniformlyOn\n#align tendsto_uniformly_iff_seq_tendsto_uniformly tendstoUniformly_iff_seq_tendstoUniformly\n-/\n\n",
 "tendstoUniformlyOn_univ":
 "#print tendstoUniformlyOn_univ /-\ntheorem tendstoUniformlyOn_univ : TendstoUniformlyOn F f p univ ‚Üî TendstoUniformly F f p := by\n  simp [TendstoUniformlyOn, TendstoUniformly]\n#align tendsto_uniformly_on_univ tendstoUniformlyOn_univ\n-/\n\n",
 "tendstoUniformlyOn_singleton_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendstoUniformlyOn_singleton_iff_tendsto /-\n/-- Uniform convergence on a singleton is equivalent to regular convergence -/\ntheorem tendstoUniformlyOn_singleton_iff_tendsto :\n    TendstoUniformlyOn F f p {x} ‚Üî Tendsto (fun n : Œπ => F n x) p ((nhds) (f x)) :=\n  by\n  simp_rw [tendstoUniformlyOn_iff_tendsto, Uniform.tendsto_nhds_right, tendsto_def]\n  exact forall‚ÇÇ_congr fun u hu => by simp [mem_prod_principal, preimage]\n#align tendsto_uniformly_on_singleton_iff_tendsto tendstoUniformlyOn_singleton_iff_tendsto\n-/\n\n",
 "tendstoUniformlyOn_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print UniformCauchySeqOn.tendstoUniformlyOn_of_tendsto /-\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem UniformCauchySeqOn.tendstoUniformlyOn_of_tendsto [NeBot p] (hF : UniformCauchySeqOn F p s)\n    (hF' : ‚àÄ x : Œ±, x ‚àà s ‚Üí Tendsto (fun n => F n x) p ((nhds) (f x))) : TendstoUniformlyOn F f p s :=\n  tendstoUniformlyOn_iff_tendstoUniformlyOnFilter.mpr\n    (hF.uniform_cauchy_seq_on_filter.tendsto_uniformly_on_filter_of_tendsto hF')\n#align uniform_cauchy_seq_on.tendsto_uniformly_on_of_tendsto UniformCauchySeqOn.tendstoUniformlyOn_of_tendsto\n-/\n\n",
 "tendstoUniformlyOn_of_seq_tendstoUniformlyOn":
 "#print tendstoUniformlyOn_of_seq_tendstoUniformlyOn /-\ntheorem tendstoUniformlyOn_of_seq_tendstoUniformlyOn {l : Filter Œπ} [l.is_countably_generated]\n    (h : ‚àÄ u : ‚Ñï ‚Üí Œπ, Tendsto u atTop l ‚Üí TendstoUniformlyOn (fun n => F (u n)) f atTop s) :\n    TendstoUniformlyOn F f l s :=\n  by\n  rw [tendstoUniformlyOn_iff_tendsto, tendsto_iff_seq_tendsto]\n  intro u hu\n  rw [tendsto_prod_iff'] at hu\n  specialize h (fun n => (u n).fst) hu.1\n  rw [tendstoUniformlyOn_iff_tendsto] at h\n  have :\n    (fun q : Œπ √ó Œ± => (f q.snd, F q.fst q.snd)) ‚àò u =\n      (fun q : ‚Ñï √ó Œ± => (f q.snd, F ((fun n : ‚Ñï => (u n).fst) q.fst) q.snd)) ‚àò fun n => (n, (u n).snd) :=\n    by\n    ext1 n\n    simp\n  rw [this]\n  refine' tendsto.comp h _\n  rw [tendsto_prod_iff']\n  exact ‚ü®tendsto_id, hu.2‚ü©\n#align tendsto_uniformly_on_of_seq_tendsto_uniformly_on tendstoUniformlyOn_of_seq_tendstoUniformlyOn\n-/\n\n",
 "tendstoUniformlyOn_iff_tendstoUniformly_comp_coe":
 "#print tendstoUniformlyOn_iff_tendstoUniformly_comp_coe /-\ntheorem tendstoUniformlyOn_iff_tendstoUniformly_comp_coe :\n    TendstoUniformlyOn F f p s ‚Üî TendstoUniformly (fun i (x : s) => F i x) (f ‚àò coe) p :=\n  by\n  apply forall‚ÇÇ_congr\n  intro u hu\n  simp\n#align tendsto_uniformly_on_iff_tendsto_uniformly_comp_coe tendstoUniformlyOn_iff_tendstoUniformly_comp_coe\n-/\n\n",
 "tendstoUniformlyOn_iff_tendstoUniformlyOnFilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print tendstoUniformlyOn_iff_tendstoUniformlyOnFilter /-\ntheorem tendstoUniformlyOn_iff_tendstoUniformlyOnFilter :\n    TendstoUniformlyOn F f p s ‚Üî TendstoUniformlyOnFilter F f p ((filter.principal) s) :=\n  by\n  simp only [TendstoUniformlyOn, TendstoUniformlyOnFilter]\n  apply forall‚ÇÇ_congr\n  simp_rw [eventually_prod_principal_iff]\n  simp\n#align tendsto_uniformly_on_iff_tendsto_uniformly_on_filter tendstoUniformlyOn_iff_tendstoUniformlyOnFilter\n-/\n\n",
 "tendstoUniformlyOn_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print tendstoUniformlyOn_iff_tendsto /-\n/-- A sequence of functions `F‚Çô` converges uniformly on a set `s` to a limiting function `f` w.r.t.\nfilter `p` iff the function `(n, x) ‚Ü¶ (f x, F‚Çô x)` converges along `p √ó·∂† ùìü s` to the uniformity.\nIn other words: one knows nothing about the behavior of `x` in this limit besides it being in `s`.\n-/\ntheorem tendstoUniformlyOn_iff_tendsto {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ} {s : Set Œ±} :\n    TendstoUniformlyOn F f p s ‚Üî\n      Tendsto (fun q : Œπ √ó Œ± => (f q.2, F q.1 q.2)) (filter.prod p ((filter.principal) s)) ((uniformity) Œ≤) :=\n  by simp [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter, tendstoUniformlyOnFilter_iff_tendsto]\n#align tendsto_uniformly_on_iff_tendsto tendstoUniformlyOn_iff_tendsto\n-/\n\n",
 "tendstoUniformlyOn_iff_seq_tendstoUniformlyOn":
 "#print tendstoUniformlyOn_iff_seq_tendstoUniformlyOn /-\ntheorem tendstoUniformlyOn_iff_seq_tendstoUniformlyOn {l : Filter Œπ} [l.is_countably_generated] :\n    TendstoUniformlyOn F f l s ‚Üî ‚àÄ u : ‚Ñï ‚Üí Œπ, Tendsto u atTop l ‚Üí TendstoUniformlyOn (fun n => F (u n)) f atTop s :=\n  ‚ü®TendstoUniformlyOn.seq_tendstoUniformlyOn, tendstoUniformlyOn_of_seq_tendstoUniformlyOn‚ü©\n#align tendsto_uniformly_on_iff_seq_tendsto_uniformly_on tendstoUniformlyOn_iff_seq_tendstoUniformlyOn\n-/\n\n",
 "tendstoUniformlyOn_empty":
 "#print tendstoUniformlyOn_empty /-\n/-- Uniform convergence on the empty set is vacuously true -/\ntheorem tendstoUniformlyOn_empty : TendstoUniformlyOn F f p ‚àÖ := fun u hu => by simp\n#align tendsto_uniformly_on_empty tendstoUniformlyOn_empty\n-/\n\n",
 "tendstoUniformlyOn_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.tendstoUniformlyOn_const /-\n/-- If a sequence `g` converges to some `b`, then the sequence of constant functions\n`Œª n, Œª a, g n` converges to the constant function `Œª a, b` on any set `s` -/\ntheorem Filter.Tendsto.tendstoUniformlyOn_const {g : Œπ ‚Üí Œ≤} {b : Œ≤} (hg : Tendsto g p ((nhds) b)) (s : Set Œ±) :\n    TendstoUniformlyOn (fun n : Œπ => fun a : Œ± => g n) (fun a : Œ± => b) p s :=\n  tendstoUniformlyOn_iff_tendstoUniformlyOnFilter.mpr (hg.tendsto_uniformly_on_filter_const ((filter.principal) s))\n#align filter.tendsto.tendsto_uniformly_on_const Filter.Tendsto.tendstoUniformlyOn_const\n-/\n\n",
 "tendstoUniformlyOnFilter_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print UniformCauchySeqOnFilter.tendstoUniformlyOnFilter_of_tendsto /-\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem UniformCauchySeqOnFilter.tendstoUniformlyOnFilter_of_tendsto [NeBot p] (hF : UniformCauchySeqOnFilter F p p')\n    (hF' :\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" p'\n        (Tendsto (fun n => F n x) p ((nhds) (f x)))) :\n    TendstoUniformlyOnFilter F f p p' :=\n  by\n  -- Proof idea: |f_n(x) - f(x)| ‚â§ |f_n(x) - f_m(x)| + |f_m(x) - f(x)|. We choose `n`\n  -- so that |f_n(x) - f_m(x)| is uniformly small across `s` whenever `m ‚â• n`. Then for\n  -- a fixed `x`, we choose `m` sufficiently large such that |f_m(x) - f(x)| is small.\n  intro u hu\n  rcases comp_symm_of_uniformity hu with ‚ü®t, ht, htsymm, htmem‚ü©\n  -- We will choose n, x, and m simultaneously. n and x come from hF. m comes from hF'\n  -- But we need to promote hF' to the full product filter to use it\n  have hmc :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n      (filter.prod (filter.prod p p) p') (tendsto (fun n : Œπ => F n x.snd) p ((nhds) (f x.snd))) :=\n    by\n    rw [eventually_prod_iff]\n    refine' ‚ü®fun x => True, by simp, _, hF', by simp‚ü©\n  -- To apply filter operations we'll need to do some order manipulation\n  rw [Filter.eventually_swap_iff]\n  have := tendsto_prod_assoc.eventually (tendsto_prod_swap.eventually ((hF t ht).and hmc))\n  apply this.curry.mono\n  simp only [Equiv.prodAssoc_apply, eventually_and, eventually_const, Prod.snd_swap, Prod.fst_swap, and_imp,\n    Prod.forall]\n  -- Complete the proof\n  intro x n hx hm'\n  refine' Set.mem_of_mem_of_subset (mem_comp_rel.mpr _) htmem\n  rw [Uniform.tendsto_nhds_right] at hm'\n  have := hx.and (hm' ht)\n  obtain ‚ü®m, hm‚ü© := this.exists\n  exact ‚ü®F m x, ‚ü®hm.2, htsymm hm.1‚ü©‚ü©\n#align uniform_cauchy_seq_on_filter.tendsto_uniformly_on_filter_of_tendsto UniformCauchySeqOnFilter.tendstoUniformlyOnFilter_of_tendsto\n-/\n\n",
 "tendstoUniformlyOnFilter_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print tendstoUniformlyOnFilter_iff_tendsto /-\n/-\nCopyright (c) 2020 S√©bastien Gou√´zel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: S√©bastien Gou√´zel\n-/\n/-- A sequence of functions `F‚Çô` converges uniformly on a filter `p'` to a limiting function `f` w.r.t.\nfilter `p` iff the function `(n, x) ‚Ü¶ (f x, F‚Çô x)` converges along `p √ó·∂† p'` to the uniformity.\nIn other words: one knows nothing about the behavior of `x` in this limit besides it being in `p'`.\n-/\ntheorem tendstoUniformlyOnFilter_iff_tendsto :\n    TendstoUniformlyOnFilter F f p p' ‚Üî\n      Tendsto (fun q : Œπ √ó Œ± => (f q.2, F q.1 q.2)) (filter.prod p p') ((uniformity) Œ≤) :=\n  forall‚ÇÇ_congr fun u u_in => by simp [mem_map, Filter.Eventually, mem_prod_iff, preimage]\n#align tendsto_uniformly_on_filter_iff_tendsto tendstoUniformlyOnFilter_iff_tendsto\n-/\n\n",
 "tendstoUniformlyOnFilter_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.tendstoUniformlyOnFilter_const /-\n/-- If a sequence `g` converges to some `b`, then the sequence of constant functions\n`Œª n, Œª a, g n` converges to the constant function `Œª a, b` on any set `s` -/\ntheorem Filter.Tendsto.tendstoUniformlyOnFilter_const {g : Œπ ‚Üí Œ≤} {b : Œ≤} (hg : Tendsto g p ((nhds) b))\n    (p' : Filter Œ±) : TendstoUniformlyOnFilter (fun n : Œπ => fun a : Œ± => g n) (fun a : Œ± => b) p p' :=\n  by\n  rw [tendstoUniformlyOnFilter_iff_tendsto]\n  rw [Uniform.tendsto_nhds_right] at hg\n  exact (hg.comp (tendsto_fst.comp ((@tendsto_id Œπ p).prod_map (@tendsto_id Œ± p')))).congr fun x => by simp\n#align filter.tendsto.tendsto_uniformly_on_filter_const Filter.Tendsto.tendstoUniformlyOnFilter_const\n-/\n\n",
 "tendstoUniformlyOnFilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n#print TendstoUniformly.tendstoUniformlyOnFilter /-\ntheorem TendstoUniformly.tendstoUniformlyOnFilter (h : TendstoUniformly F f p) :\n    TendstoUniformlyOnFilter F f p (¬´expr‚ä§¬ª) := by rwa [‚Üê tendstoUniformly_iff_tendstoUniformlyOnFilter]\n#align tendsto_uniformly.tendsto_uniformly_on_filter TendstoUniformly.tendstoUniformlyOnFilter\n-/\n\n",
 "tendstoUniformlyOn":
 "#print TendstoUniformly.tendstoUniformlyOn /-\nprotected theorem TendstoUniformly.tendstoUniformlyOn (h : TendstoUniformly F f p) : TendstoUniformlyOn F f p s :=\n  (tendstoUniformlyOn_univ.2 h).mono (subset_univ s)\n#align tendsto_uniformly.tendsto_uniformly_on TendstoUniformly.tendstoUniformlyOn\n-/\n\n",
 "tendstoUniformly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print UniformContinuous‚ÇÇ.tendstoUniformly /-\ntheorem UniformContinuous‚ÇÇ.tendstoUniformly [UniformSpace Œ±] [UniformSpace Œ≥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (h : UniformContinuous‚ÇÇ f)\n    {x : Œ±} : TendstoUniformly f (f x) ((nhds) x) :=\n  UniformContinuousOn.tendstoUniformly univ_mem <| by rwa [univ_prod_univ, uniformContinuousOn_univ]\n#align uniform_continuous‚ÇÇ.tendsto_uniformly UniformContinuous‚ÇÇ.tendstoUniformly\n-/\n\n",
 "tendstoLocallyUniformly_iff_tendstoUniformly_of_compactSpace":
 "#print tendstoLocallyUniformly_iff_tendstoUniformly_of_compactSpace /-\n/-- On a compact space, locally uniform convergence is just uniform convergence. -/\ntheorem tendstoLocallyUniformly_iff_tendstoUniformly_of_compactSpace [CompactSpace Œ±] :\n    TendstoLocallyUniformly F f p ‚Üî TendstoUniformly F f p :=\n  by\n  refine' ‚ü®fun h V hV => _, TendstoUniformly.tendstoLocallyUniformly‚ü©\n  choose U hU using h V hV\n  obtain ‚ü®t, ht‚ü© := is_compact_univ.elim_nhds_subcover' (fun k hk => U k) fun k hk => (hU k).1\n  replace hU := fun x : t => (hU x).2\n  rw [‚Üê eventually_all] at hU\n  refine' hU.mono fun i hi x => _\n  specialize ht (mem_univ x)\n  simp only [exists_prop, mem_Union, SetCoe.exists, exists_and_right, Subtype.coe_mk] at ht\n  obtain ‚ü®y, ‚ü®hy‚ÇÅ, hy‚ÇÇ‚ü©, hy‚ÇÉ‚ü© := ht\n  exact hi ‚ü®‚ü®y, hy‚ÇÅ‚ü©, hy‚ÇÇ‚ü© x hy‚ÇÉ\n#align tendsto_locally_uniformly_iff_tendsto_uniformly_of_compact_space tendstoLocallyUniformly_iff_tendstoUniformly_of_compactSpace\n-/\n\n",
 "tendstoLocallyUniformly_iff_forall_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print tendstoLocallyUniformly_iff_forall_tendsto /-\ntheorem tendstoLocallyUniformly_iff_forall_tendsto :\n    TendstoLocallyUniformly F f p ‚Üî\n      ‚àÄ x, Tendsto (fun y : Œπ √ó Œ± => (f y.2, F y.1 y.2)) (filter.prod p ((nhds) x)) ((uniformity) Œ≤) :=\n  by\n  simp only [TendstoLocallyUniformly, Filter.forall_in_swap, tendsto_def, mem_prod_iff, Set.prod_subset_iff]\n  refine' forall‚ÇÉ_congr fun x u hu => ‚ü®_, _‚ü©\n  ¬∑ rintro ‚ü®n, hn, hp‚ü©\n    exact ‚ü®_, hp, n, hn, fun i hi a ha => hi a ha‚ü©\n  ¬∑ rintro ‚ü®I, hI, n, hn, hu‚ü©\n    exact ‚ü®n, hn, by filter_upwards [hI]using hu‚ü©\n#align tendsto_locally_uniformly_iff_forall_tendsto tendstoLocallyUniformly_iff_forall_tendsto\n-/\n\n",
 "tendstoLocallyUniformly_iff_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendstoLocallyUniformly_iff_filter /-\ntheorem tendstoLocallyUniformly_iff_filter :\n    TendstoLocallyUniformly F f p ‚Üî ‚àÄ x, TendstoUniformlyOnFilter F f p ((nhds) x) := by\n  simpa [‚Üê tendstoLocallyUniformlyOn_univ, ‚Üê nhdsWithin_univ] using\n    @tendstoLocallyUniformlyOn_iff_filter _ _ _ _ F f univ p _\n#align tendsto_locally_uniformly_iff_filter tendstoLocallyUniformly_iff_filter\n-/\n\n",
 "tendstoLocallyUniformlyOn_univ":
 "#print tendstoLocallyUniformlyOn_univ /-\ntheorem tendstoLocallyUniformlyOn_univ : TendstoLocallyUniformlyOn F f p univ ‚Üî TendstoLocallyUniformly F f p := by\n  simp [TendstoLocallyUniformlyOn, TendstoLocallyUniformly, nhdsWithin_univ]\n#align tendsto_locally_uniformly_on_univ tendstoLocallyUniformlyOn_univ\n-/\n\n",
 "tendstoLocallyUniformlyOn_union‚Çõ":
 "#print tendstoLocallyUniformlyOn_union‚Çõ /-\ntheorem tendstoLocallyUniformlyOn_union‚Çõ (S : Set (Set Œ±)) (hS : ‚àÄ s ‚àà S, IsOpen s)\n    (h : ‚àÄ s ‚àà S, TendstoLocallyUniformlyOn F f p s) : TendstoLocallyUniformlyOn F f p (‚ãÉ‚ÇÄ S) :=\n  by\n  rw [sUnion_eq_bUnion]\n  exact tendstoLocallyUniformlyOn_bunion·µ¢ hS h\n#align tendsto_locally_uniformly_on_sUnion tendstoLocallyUniformlyOn_union‚Çõ\n-/\n\n",
 "tendstoLocallyUniformlyOn_union·µ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n#print tendstoLocallyUniformlyOn_union·µ¢ /-\ntheorem tendstoLocallyUniformlyOn_union·µ¢ {S : Œ≥ ‚Üí Set Œ±} (hS : ‚àÄ i, IsOpen (S i))\n    (h : ‚àÄ i, TendstoLocallyUniformlyOn F f p (S i)) :\n    TendstoLocallyUniformlyOn F f p\n      (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (S i)) :=\n  by\n  rintro v hv x ‚ü®_, ‚ü®i, rfl‚ü©, hi : x ‚àà S i‚ü©\n  obtain ‚ü®t, ht, ht'‚ü© := h i v hv x hi\n  refine' ‚ü®t, _, ht'‚ü©\n  rw [(hS _).nhds_within_eq hi] at ht\n  exact mem_nhdsWithin_of_mem_nhds ht\n#align tendsto_locally_uniformly_on_Union tendstoLocallyUniformlyOn_union·µ¢\n-/\n\n",
 "tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact":
 "#print tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact /-\n/-- For a compact set `s`, locally uniform convergence on `s` is just uniform convergence on `s`. -/\ntheorem tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact (hs : IsCompact s) :\n    TendstoLocallyUniformlyOn F f p s ‚Üî TendstoUniformlyOn F f p s :=\n  by\n  haveI : CompactSpace s := is_compact_iff_compact_space.mp hs\n  refine' ‚ü®fun h => _, TendstoUniformlyOn.tendstoLocallyUniformlyOn‚ü©\n  rwa [tendstoLocallyUniformlyOn_iff_tendstoLocallyUniformly_comp_coe,\n    tendstoLocallyUniformly_iff_tendstoUniformly_of_compactSpace, ‚Üê tendstoUniformlyOn_iff_tendstoUniformly_comp_coe] at\n    h\n#align tendsto_locally_uniformly_on_iff_tendsto_uniformly_on_of_compact tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact\n-/\n\n",
 "tendstoLocallyUniformlyOn_iff_tendstoLocallyUniformly_comp_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n#print tendstoLocallyUniformlyOn_iff_tendstoLocallyUniformly_comp_coe /-\ntheorem tendstoLocallyUniformlyOn_iff_tendstoLocallyUniformly_comp_coe :\n    TendstoLocallyUniformlyOn F f p s ‚Üî TendstoLocallyUniformly (fun i (x : s) => F i x) (f ‚àò coe) p :=\n  by\n  refine' forall‚ÇÇ_congr fun V hV => _\n  simp only [exists_prop, Function.comp_apply, SetCoe.forall, Subtype.coe_mk]\n  refine' forall‚ÇÇ_congr fun x hx => ‚ü®_, _‚ü©\n  ¬∑ rintro ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü©\n    obtain ‚ü®u, hu‚ÇÅ, hu‚ÇÇ‚ü© := mem_nhds_within_iff_exists_mem_nhds_inter.mp ht‚ÇÅ\n    exact\n      ‚ü®¬´expr ‚Åª¬π' ¬ª coe u, (mem_nhds_subtype _ _ _).mpr ‚ü®u, hu‚ÇÅ, rfl.subset‚ü©,\n        ht‚ÇÇ.mono fun i hi y hy‚ÇÅ hy‚ÇÇ => hi y (hu‚ÇÇ ‚ü®hy‚ÇÇ, hy‚ÇÅ‚ü©)‚ü©\n  ¬∑ rintro ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü©\n    obtain ‚ü®u, hu‚ÇÅ, hu‚ÇÇ‚ü© := (mem_nhds_subtype _ _ _).mp ht‚ÇÅ\n    exact\n      ‚ü®u ‚à© s, mem_nhds_within_iff_exists_mem_nhds_inter.mpr ‚ü®u, hu‚ÇÅ, rfl.subset‚ü©,\n        ht‚ÇÇ.mono fun i hi y hy => hi y hy.2 (hu‚ÇÇ (by simp [hy.1]))‚ü©\n#align tendsto_locally_uniformly_on_iff_tendsto_locally_uniformly_comp_coe tendstoLocallyUniformlyOn_iff_tendstoLocallyUniformly_comp_coe\n-/\n\n",
 "tendstoLocallyUniformlyOn_iff_forall_isCompact":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (K ¬´expr ‚äÜ ¬ª s) -/\n#print tendstoLocallyUniformlyOn_iff_forall_isCompact /-\ntheorem tendstoLocallyUniformlyOn_iff_forall_isCompact [LocallyCompactSpace Œ±] (hs : IsOpen s) :\n    TendstoLocallyUniformlyOn F f p s ‚Üî ‚àÄ (K) (_ : K ‚äÜ s), IsCompact K ‚Üí TendstoUniformlyOn F f p K :=\n  (tendstoLocallyUniformlyOn_TFAE F f p hs).out 0 1\n#align tendsto_locally_uniformly_on_iff_forall_is_compact tendstoLocallyUniformlyOn_iff_forall_isCompact\n-/\n\n",
 "tendstoLocallyUniformlyOn_iff_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print tendstoLocallyUniformlyOn_iff_filter /-\ntheorem tendstoLocallyUniformlyOn_iff_filter :\n    TendstoLocallyUniformlyOn F f p s ‚Üî ‚àÄ x ‚àà s, TendstoUniformlyOnFilter F f p (nhds_within s x) :=\n  by\n  simp only [TendstoUniformlyOnFilter, eventually_prod_iff]\n  constructor\n  ¬∑ rintro h x hx u hu\n    obtain ‚ü®s, hs1, hs2‚ü© := h u hu x hx\n    exact ‚ü®_, hs2, _, eventually_of_mem hs1 fun x => id, fun i hi y hy => hi y hy‚ü©\n  ¬∑ rintro h u hu x hx\n    obtain ‚ü®pa, hpa, pb, hpb, h‚ü© := h x hx u hu\n    refine' ‚ü®pb, hpb, eventually_of_mem hpa fun i hi y hy => h hi hy‚ü©\n#align tendsto_locally_uniformly_on_iff_filter tendstoLocallyUniformlyOn_iff_filter\n-/\n\n",
 "tendstoLocallyUniformlyOn_bunion·µ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n#print tendstoLocallyUniformlyOn_bunion·µ¢ /-\ntheorem tendstoLocallyUniformlyOn_bunion·µ¢ {s : Set Œ≥} {S : Œ≥ ‚Üí Set Œ±} (hS : ‚àÄ i ‚àà s, IsOpen (S i))\n    (h : ‚àÄ i ‚àà s, TendstoLocallyUniformlyOn F f p (S i)) :\n    TendstoLocallyUniformlyOn F f p\n      (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (S i)) :=\n  by\n  rw [bUnion_eq_Union]\n  exact tendstoLocallyUniformlyOn_union·µ¢ (fun i => hS _ i.2) fun i => h _ i.2\n#align tendsto_locally_uniformly_on_bUnion tendstoLocallyUniformlyOn_bunion·µ¢\n-/\n\n",
 "tendstoLocallyUniformlyOn_TFAE":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (K ¬´expr ‚äÜ ¬ª s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print tendstoLocallyUniformlyOn_TFAE /-\ntheorem tendstoLocallyUniformlyOn_TFAE [LocallyCompactSpace Œ±] (G : Œπ ‚Üí Œ± ‚Üí Œ≤) (g : Œ± ‚Üí Œ≤) (p : Filter Œπ)\n    (hs : IsOpen s) :\n    TFAE\n      [TendstoLocallyUniformlyOn G g p s, ‚àÄ (K) (_ : K ‚äÜ s), IsCompact K ‚Üí TendstoUniformlyOn G g p K,\n        ‚àÄ x ‚àà s, ‚àÉ v ‚àà nhds_within s x, TendstoUniformlyOn G g p v] :=\n  by\n  tfae_have 1 ‚Üí 2\n  ¬∑ rintro h K hK1 hK2\n    exact (tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact hK2).mp (h.mono hK1)\n  tfae_have 2 ‚Üí 3\n  ¬∑ rintro h x hx\n    obtain ‚ü®K, ‚ü®hK1, hK2‚ü©, hK3‚ü© := (compact_basis_nhds x).mem_iff.mp (hs.mem_nhds hx)\n    refine' ‚ü®K, nhdsWithin_le_nhds hK1, h K hK3 hK2‚ü©\n  tfae_have 3 ‚Üí 1\n  ¬∑ rintro h u hu x hx\n    obtain ‚ü®v, hv1, hv2‚ü© := h x hx\n    exact ‚ü®v, hv1, hv2 u hu‚ü©\n  tfae_finish\n#align tendsto_locally_uniformly_on_tfae tendstoLocallyUniformlyOn_TFAE\n-/\n\n",
 "tendstoLocallyUniformlyOn":
 "#print TendstoLocallyUniformly.tendstoLocallyUniformlyOn /-\nprotected theorem TendstoLocallyUniformly.tendstoLocallyUniformlyOn (h : TendstoLocallyUniformly F f p) :\n    TendstoLocallyUniformlyOn F f p s :=\n  (tendstoLocallyUniformlyOn_univ.mpr h).mono (subset_univ _)\n#align tendsto_locally_uniformly.tendsto_locally_uniformly_on TendstoLocallyUniformly.tendstoLocallyUniformlyOn\n-/\n\n",
 "tendstoLocallyUniformly":
 "#print TendstoUniformly.tendstoLocallyUniformly /-\nprotected theorem TendstoUniformly.tendstoLocallyUniformly (h : TendstoUniformly F f p) :\n    TendstoLocallyUniformly F f p := fun u hu x => ‚ü®univ, univ_mem, by simpa using h u hu‚ü©\n#align tendsto_uniformly.tendsto_locally_uniformly TendstoUniformly.tendstoLocallyUniformly\n-/\n\n",
 "seq_tendstoUniformlyOn":
 "#print TendstoUniformlyOn.seq_tendstoUniformlyOn /-\ntheorem TendstoUniformlyOn.seq_tendstoUniformlyOn {l : Filter Œπ} (h : TendstoUniformlyOn F f l s) (u : ‚Ñï ‚Üí Œπ)\n    (hu : Tendsto u atTop l) : TendstoUniformlyOn (fun n => F (u n)) f atTop s :=\n  by\n  rw [tendstoUniformlyOn_iff_tendsto] at h‚ä¢\n  have :\n    (fun q : ‚Ñï √ó Œ± => (f q.snd, F (u q.fst) q.snd)) =\n      (fun q : Œπ √ó Œ± => (f q.snd, F q.fst q.snd)) ‚àò fun p : ‚Ñï √ó Œ± => (u p.fst, p.snd) :=\n    by\n    ext1 x\n    simp\n  rw [this]\n  refine' h.comp _\n  rw [tendsto_prod_iff']\n  exact ‚ü®hu.comp tendsto_fst, tendsto_snd‚ü©\n#align tendsto_uniformly_on.seq_tendsto_uniformly_on TendstoUniformlyOn.seq_tendstoUniformlyOn\n-/\n\n",
 "prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print UniformCauchySeqOn.prod_map /-\ntheorem UniformCauchySeqOn.prod_map {Œπ' Œ±' Œ≤' : Type _} [UniformSpace Œ≤'] {F' : Œπ' ‚Üí Œ±' ‚Üí Œ≤'} {p' : Filter Œπ'}\n    {s' : Set Œ±'} (h : UniformCauchySeqOn F p s) (h' : UniformCauchySeqOn F' p' s') :\n    UniformCauchySeqOn (fun i : Œπ √ó Œπ' => prod.map (F i.1) (F' i.2)) (p.prod p') (lower_set.prod s s') :=\n  by\n  intro u hu\n  rw [uniformity_prod_eq_prod, mem_map, mem_prod_iff] at hu\n  obtain ‚ü®v, hv, w, hw, hvw‚ü© := hu\n  simp_rw [mem_prod, Prod_map, and_imp, Prod.forall]\n  rw [‚Üê Set.image_subset_iff] at hvw\n  apply (tendsto_swap4_prod.eventually ((h v hv).prod_mk (h' w hw))).mono\n  intro x hx a b ha hb\n  refine' hvw ‚ü®_, mk_mem_prod (hx.1 a ha) (hx.2 b hb), rfl‚ü©\n#align uniform_cauchy_seq_on.prod_map UniformCauchySeqOn.prod_map\n-/\n\n",
 "prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n#print UniformCauchySeqOn.prod' /-\ntheorem UniformCauchySeqOn.prod' {Œ≤' : Type _} [UniformSpace Œ≤'] {F' : Œπ ‚Üí Œ± ‚Üí Œ≤'} (h : UniformCauchySeqOn F p s)\n    (h' : UniformCauchySeqOn F' p s) : UniformCauchySeqOn (fun (i : Œπ) a => (F i a, F' i a)) p s :=\n  by\n  intro u hu\n  have hh : tendsto (fun x : Œπ => (x, x)) p (filter.prod p p) := tendsto_diag\n  exact (hh.prod_map hh).eventually ((h.prod h') u hu)\n#align uniform_cauchy_seq_on.prod' UniformCauchySeqOn.prod'\n-/\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n#print UniformCauchySeqOn.prod /-\ntheorem UniformCauchySeqOn.prod {Œπ' Œ≤' : Type _} [UniformSpace Œ≤'] {F' : Œπ' ‚Üí Œ± ‚Üí Œ≤'} {p' : Filter Œπ'}\n    (h : UniformCauchySeqOn F p s) (h' : UniformCauchySeqOn F' p' s) :\n    UniformCauchySeqOn (fun (i : Œπ √ó Œπ') a => (F i.fst a, F' i.snd a)) (filter.prod p p') s :=\n  (congr_arg _ s.inter_self).mp ((h.prod_map h').comp fun a => (a, a))\n#align uniform_cauchy_seq_on.prod UniformCauchySeqOn.prod\n-/\n\n",
 "mono_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n#print UniformCauchySeqOnFilter.mono_right /-\ntheorem UniformCauchySeqOnFilter.mono_right {p'' : Filter Œ±} (hf : UniformCauchySeqOnFilter F p p') (hp : p'' ‚â§ p') :\n    UniformCauchySeqOnFilter F p p'' := by\n  intro u hu\n  have := (hf u hu).filter_mono ((filter.prod p p).prod_mono_right hp)\n  exact this.mono (by simp)\n#align uniform_cauchy_seq_on_filter.mono_right UniformCauchySeqOnFilter.mono_right\n-/\n\n",
 "mono_left":
 "#print UniformCauchySeqOnFilter.mono_left /-\ntheorem UniformCauchySeqOnFilter.mono_left {p'' : Filter Œπ} (hf : UniformCauchySeqOnFilter F p p') (hp : p'' ‚â§ p) :\n    UniformCauchySeqOnFilter F p'' p' := by\n  intro u hu\n  have := (hf u hu).filter_mono (p'.prod_mono_left (Filter.prod_mono hp hp))\n  exact this.mono (by simp)\n#align uniform_cauchy_seq_on_filter.mono_left UniformCauchySeqOnFilter.mono_left\n-/\n\n",
 "mono":
 "#print TendstoLocallyUniformlyOn.mono /-\ntheorem TendstoLocallyUniformlyOn.mono (h : TendstoLocallyUniformlyOn F f p s) (h' : s' ‚äÜ s) :\n    TendstoLocallyUniformlyOn F f p s' := by\n  intro u hu x hx\n  rcases h u hu x (h' hx) with ‚ü®t, ht, H‚ü©\n  exact ‚ü®t, nhdsWithin_mono x h' ht, H.mono fun n => id‚ü©\n#align tendsto_locally_uniformly_on.mono TendstoLocallyUniformlyOn.mono\n-/\n\n",
 "continuous_of_uniform_approx_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print continuous_of_uniform_approx_of_continuous /-\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem continuous_of_uniform_approx_of_continuous (L : ‚àÄ u ‚àà (uniformity) Œ≤, ‚àÉ F, Continuous F ‚àß ‚àÄ y, (f y, F y) ‚àà u) :\n    Continuous f :=\n  continuous_iff_continuousOn_univ.mpr <|\n    continuousOn_of_uniform_approx_of_continuousOn <| by simpa [continuous_iff_continuousOn_univ] using L\n#align continuous_of_uniform_approx_of_continuous continuous_of_uniform_approx_of_continuous\n-/\n\n",
 "continuous_of_locally_uniform_approx_of_continuousAt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print continuous_of_locally_uniform_approx_of_continuousAt /-\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem continuous_of_locally_uniform_approx_of_continuousAt\n    (L : ‚àÄ x : Œ±, ‚àÄ u ‚àà (uniformity) Œ≤, ‚àÉ t ‚àà (nhds) x, ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) :\n    Continuous f :=\n  continuous_iff_continuousAt.2 fun x => continuousAt_of_locally_uniform_approx_of_continuousAt (L x)\n#align continuous_of_locally_uniform_approx_of_continuous_at continuous_of_locally_uniform_approx_of_continuousAt\n-/\n\n",
 "continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt /-\n/-- A function which can be locally uniformly approximated by functions which are continuous\nwithin a set at a point is continuous within this set at this point. -/\ntheorem continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt (hx : x ‚àà s)\n    (L : ‚àÄ u ‚àà (uniformity) Œ≤, ‚àÉ t ‚àà nhds_within s x, ‚àÉ F : Œ± ‚Üí Œ≤, ContinuousWithinAt F s x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) :\n    ContinuousWithinAt f s x :=\n  by\n  apply Uniform.continuousWithinAt_iff'_left.2 fun u‚ÇÄ hu‚ÇÄ => _\n  obtain ‚ü®u‚ÇÅ, h‚ÇÅ, u‚ÇÅ‚ÇÄ‚ü© : ‚àÉ (u : Set (Œ≤ √ó Œ≤))(H : u ‚àà (uniformity) Œ≤), compRel u u ‚äÜ u‚ÇÄ := comp_mem_uniformity_sets hu‚ÇÄ\n  obtain ‚ü®u‚ÇÇ, h‚ÇÇ, hsymm, u‚ÇÇ‚ÇÅ‚ü© :\n    ‚àÉ (u : Set (Œ≤ √ó Œ≤))(H : u ‚àà (uniformity) Œ≤), (‚àÄ {a b}, (a, b) ‚àà u ‚Üí (b, a) ‚àà u) ‚àß compRel u u ‚äÜ u‚ÇÅ :=\n    comp_symm_of_uniformity h‚ÇÅ\n  rcases L u‚ÇÇ h‚ÇÇ with ‚ü®t, tx, F, hFc, hF‚ü©\n  have A :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n      (nhds_within s x) ((f y, F y) ‚àà u‚ÇÇ) :=\n    eventually.mono tx hF\n  have B :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n      (nhds_within s x) ((F y, F x) ‚àà u‚ÇÇ) :=\n    Uniform.continuousWithinAt_iff'_left.1 hFc h‚ÇÇ\n  have C :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n      (nhds_within s x) ((f y, F x) ‚àà u‚ÇÅ) :=\n    (A.and B).mono fun y hy => u‚ÇÇ‚ÇÅ (prod_mk_mem_compRel hy.1 hy.2)\n  have : (F x, f x) ‚àà u‚ÇÅ := u‚ÇÇ‚ÇÅ (prod_mk_mem_compRel (refl_mem_uniformity h‚ÇÇ) (hsymm (A.self_of_nhds_within hx)))\n  exact C.mono fun y hy => u‚ÇÅ‚ÇÄ (prod_mk_mem_compRel hy this)\n#align continuous_within_at_of_locally_uniform_approx_of_continuous_within_at continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt\n-/\n\n",
 "continuousOn_of_uniform_approx_of_continuousOn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print continuousOn_of_uniform_approx_of_continuousOn /-\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem continuousOn_of_uniform_approx_of_continuousOn\n    (L : ‚àÄ u ‚àà (uniformity) Œ≤, ‚àÉ F, ContinuousOn F s ‚àß ‚àÄ y ‚àà s, (f y, F y) ‚àà u) : ContinuousOn f s :=\n  continuousOn_of_locally_uniform_approx_of_continuousWithinAt fun x hx u hu =>\n    ‚ü®s, self_mem_nhdsWithin, (L u hu).imp fun F hF => ‚ü®hF.1.continuous_within_at hx, hF.2‚ü©‚ü©\n#align continuous_on_of_uniform_approx_of_continuous_on continuousOn_of_uniform_approx_of_continuousOn\n-/\n\n",
 "continuousOn_of_locally_uniform_approx_of_continuousWithinAt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print continuousOn_of_locally_uniform_approx_of_continuousWithinAt /-\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem continuousOn_of_locally_uniform_approx_of_continuousWithinAt\n    (L :\n      ‚àÄ x ‚àà s, ‚àÄ u ‚àà (uniformity) Œ≤, ‚àÉ t ‚àà nhds_within s x, ‚àÉ F, ContinuousWithinAt F s x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) :\n    ContinuousOn f s := fun x hx => continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt hx (L x hx)\n#align continuous_on_of_locally_uniform_approx_of_continuous_within_at continuousOn_of_locally_uniform_approx_of_continuousWithinAt\n-/\n\n",
 "continuousOn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n#print TendstoUniformlyOn.continuousOn /-\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\nprotected theorem TendstoUniformlyOn.continuousOn (h : TendstoUniformlyOn F f p s)\n    (hc :\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" p\n        (ContinuousOn (F n) s))\n    [NeBot p] : ContinuousOn f s :=\n  h.tendsto_locally_uniformly_on.continuous_on hc\n#align tendsto_uniformly_on.continuous_on TendstoUniformlyOn.continuousOn\n-/\n\n",
 "continuousAt_of_locally_uniform_approx_of_continuousAt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print continuousAt_of_locally_uniform_approx_of_continuousAt /-\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem continuousAt_of_locally_uniform_approx_of_continuousAt\n    (L : ‚àÄ u ‚àà (uniformity) Œ≤, ‚àÉ t ‚àà (nhds) x, ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) : ContinuousAt f x :=\n  by\n  rw [‚Üê continuousWithinAt_univ]\n  apply continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt (mem_univ _) _\n  simpa only [exists_prop, nhdsWithin_univ, continuousWithinAt_univ] using L\n#align continuous_at_of_locally_uniform_approx_of_continuous_at continuousAt_of_locally_uniform_approx_of_continuousAt\n-/\n\n",
 "continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n#print TendstoUniformly.continuous /-\n/-- A uniform limit of continuous functions is continuous. -/\nprotected theorem TendstoUniformly.continuous (h : TendstoUniformly F f p)\n    (hc :\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" p\n        (Continuous (F n)))\n    [NeBot p] : Continuous f :=\n  h.tendsto_locally_uniformly.continuous hc\n#align tendsto_uniformly.continuous TendstoUniformly.continuous\n-/\n\n",
 "congr_right":
 "#print TendstoLocallyUniformlyOn.congr_right /-\ntheorem TendstoLocallyUniformlyOn.congr_right {g : Œ± ‚Üí Œ≤} (hf : TendstoLocallyUniformlyOn F f p s) (hg : s.eq_on f g) :\n    TendstoLocallyUniformlyOn F g p s := by\n  rintro u hu x hx\n  obtain ‚ü®t, ht, h‚ü© := hf u hu x hx\n  refine' ‚ü®s ‚à© t, inter_mem self_mem_nhdsWithin ht, _‚ü©\n  filter_upwards [h]with i hi y hy using hg hy.1 ‚ñ∏ hi y hy.2\n#align tendsto_locally_uniformly_on.congr_right TendstoLocallyUniformlyOn.congr_right\n-/\n\n",
 "congr":
 "#print TendstoLocallyUniformlyOn.congr /-\ntheorem TendstoLocallyUniformlyOn.congr {G : Œπ ‚Üí Œ± ‚Üí Œ≤} (hf : TendstoLocallyUniformlyOn F f p s)\n    (hg : ‚àÄ n, s.eq_on (F n) (G n)) : TendstoLocallyUniformlyOn G f p s :=\n  by\n  rintro u hu x hx\n  obtain ‚ü®t, ht, h‚ü© := hf u hu x hx\n  refine' ‚ü®s ‚à© t, inter_mem self_mem_nhdsWithin ht, _‚ü©\n  filter_upwards [h]with i hi y hy using hg i hy.1 ‚ñ∏ hi y hy.2\n#align tendsto_locally_uniformly_on.congr TendstoLocallyUniformlyOn.congr\n-/\n\n",
 "comp_uniformCauchySeqOn":
 "#print UniformContinuous.comp_uniformCauchySeqOn /-\n/-- Composing on the left by a uniformly continuous function preserves\nuniform Cauchy sequences -/\ntheorem UniformContinuous.comp_uniformCauchySeqOn [UniformSpace Œ≥] {g : Œ≤ ‚Üí Œ≥} (hg : UniformContinuous g)\n    (hf : UniformCauchySeqOn F p s) : UniformCauchySeqOn (fun n => g ‚àò F n) p s := fun u hu => hf _ (hg hu)\n#align uniform_continuous.comp_uniform_cauchy_seq_on UniformContinuous.comp_uniformCauchySeqOn\n-/\n\n",
 "comp_tendstoUniformlyOnFilter":
 "#print UniformContinuous.comp_tendstoUniformlyOnFilter /-\n/-- Composing on the left by a uniformly continuous function preserves\n  uniform convergence on a filter -/\ntheorem UniformContinuous.comp_tendstoUniformlyOnFilter [UniformSpace Œ≥] {g : Œ≤ ‚Üí Œ≥} (hg : UniformContinuous g)\n    (h : TendstoUniformlyOnFilter F f p p') : TendstoUniformlyOnFilter (fun i => g ‚àò F i) (g ‚àò f) p p' := fun u hu =>\n  h _ (hg hu)\n#align uniform_continuous.comp_tendsto_uniformly_on_filter UniformContinuous.comp_tendstoUniformlyOnFilter\n-/\n\n",
 "comp_tendstoUniformlyOn":
 "#print UniformContinuous.comp_tendstoUniformlyOn /-\n/-- Composing on the left by a uniformly continuous function preserves\n  uniform convergence on a set -/\ntheorem UniformContinuous.comp_tendstoUniformlyOn [UniformSpace Œ≥] {g : Œ≤ ‚Üí Œ≥} (hg : UniformContinuous g)\n    (h : TendstoUniformlyOn F f p s) : TendstoUniformlyOn (fun i => g ‚àò F i) (g ‚àò f) p s := fun u hu => h _ (hg hu)\n#align uniform_continuous.comp_tendsto_uniformly_on UniformContinuous.comp_tendstoUniformlyOn\n-/\n\n",
 "comp_tendstoUniformly":
 "#print UniformContinuous.comp_tendstoUniformly /-\n/-- Composing on the left by a uniformly continuous function preserves uniform convergence -/\ntheorem UniformContinuous.comp_tendstoUniformly [UniformSpace Œ≥] {g : Œ≤ ‚Üí Œ≥} (hg : UniformContinuous g)\n    (h : TendstoUniformly F f p) : TendstoUniformly (fun i => g ‚àò F i) (g ‚àò f) p := fun u hu => h _ (hg hu)\n#align uniform_continuous.comp_tendsto_uniformly UniformContinuous.comp_tendstoUniformly\n-/\n\n",
 "comp":
 "#print TendstoLocallyUniformly.comp /-\ntheorem TendstoLocallyUniformly.comp [TopologicalSpace Œ≥] (h : TendstoLocallyUniformly F f p) (g : Œ≥ ‚Üí Œ±)\n    (cg : Continuous g) : TendstoLocallyUniformly (fun n => F n ‚àò g) (f ‚àò g) p :=\n  by\n  rw [‚Üê tendstoLocallyUniformlyOn_univ] at h‚ä¢\n  rw [continuous_iff_continuousOn_univ] at cg\n  exact h.comp _ (maps_to_univ _ _) cg\n#align tendsto_locally_uniformly.comp TendstoLocallyUniformly.comp\n-/\n\n",
 "cauchy_map":
 "#print UniformCauchySeqOn.cauchy_map /-\n/-- If a sequence of functions is uniformly Cauchy on a set, then the values at each point form\na Cauchy sequence. -/\ntheorem UniformCauchySeqOn.cauchy_map [hp : NeBot p] (hf : UniformCauchySeqOn F p s) (hx : x ‚àà s) :\n    Cauchy (map (fun i => F i x) p) :=\n  by\n  simp only [cauchy_map_iff, hp, true_and_iff]\n  intro u hu\n  rw [mem_map]\n  filter_upwards [hf u hu]with p hp using hp x hx\n#align uniform_cauchy_seq_on.cauchy_map UniformCauchySeqOn.cauchy_map\n-/\n\n"}