{"uniformEquicontinuous_iff_uniformContinuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ » -/\n#print uniformEquicontinuous_iff_uniformContinuous /-\n/-- A family `𝓕 : ι → β → α` is uniformly equicontinuous iff the function `swap 𝓕 : β → ι → α` is\nuniformly continuous *when `ι → α` is equipped with the uniform structure of uniform convergence*.\nThis is very useful for developping the equicontinuity API, but it should not be used directly\nfor other purposes. -/\ntheorem uniformEquicontinuous_iff_uniformContinuous {F : ι → β → α} :\n    UniformEquicontinuous F ↔ UniformContinuous (ofFun ∘ function.swap F : β → «expr →ᵤ » ι α) := by\n  rw [UniformContinuous, (UniformFun.hasBasis_uniformity ι α).tendsto_right_iff] <;> rfl\n#align uniform_equicontinuous_iff_uniform_continuous uniformEquicontinuous_iff_uniformContinuous\n-/\n\n",
 "uniformEquicontinuous_iff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.uniformEquicontinuous_iff_right /-\ntheorem Filter.HasBasis.uniformEquicontinuous_iff_right {κ : Type _} {p : κ → Prop} {s : κ → Set (α × α)}\n    {F : ι → β → α} (hα : ((uniformity) α).has_basis p s) :\n    UniformEquicontinuous F ↔\n      ∀ k,\n        p k →\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n            ((uniformity) β) (∀ i, (F i xy.1, F i xy.2) ∈ s k) :=\n  by\n  rw [uniformEquicontinuous_iff_uniformContinuous, UniformContinuous,\n    (UniformFun.hasBasis_uniformity_of_basis ι α hα).tendsto_right_iff]\n  rfl\n#align filter.has_basis.uniform_equicontinuous_iff_right Filter.HasBasis.uniformEquicontinuous_iff_right\n-/\n\n",
 "uniformEquicontinuous_iff_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.uniformEquicontinuous_iff_left /-\ntheorem Filter.HasBasis.uniformEquicontinuous_iff_left {κ : Type _} {p : κ → Prop} {s : κ → Set (β × β)} {F : ι → β → α}\n    (hβ : ((uniformity) β).has_basis p s) :\n    UniformEquicontinuous F ↔ ∀ U ∈ (uniformity) α, ∃ (k : _)(_ : p k), ∀ x y, (x, y) ∈ s k → ∀ i, (F i x, F i y) ∈ U :=\n  by\n  rw [uniformEquicontinuous_iff_uniformContinuous, UniformContinuous,\n    hβ.tendsto_iff (UniformFun.hasBasis_uniformity ι α)]\n  simp_rw [Prod.forall]\n  rfl\n#align filter.has_basis.uniform_equicontinuous_iff_left Filter.HasBasis.uniformEquicontinuous_iff_left\n-/\n\n",
 "uniformEquicontinuous_iff":
 "#print UniformInducing.uniformEquicontinuous_iff /-\n/-- Given `u : α → γ` a uniform inducing map, a family `𝓕 : ι → β → α` is uniformly equicontinuous\niff the family `𝓕'`, obtained by precomposing each function of `𝓕` by `u`, is uniformly\nequicontinuous. -/\ntheorem UniformInducing.uniformEquicontinuous_iff {F : ι → β → α} {u : α → γ} (hu : UniformInducing u) :\n    UniformEquicontinuous F ↔ UniformEquicontinuous ((· ∘ ·) u ∘ F) :=\n  by\n  have := UniformFun.postcomp_uniformInducing hu\n  rw [uniformEquicontinuous_iff_uniformContinuous, uniformEquicontinuous_iff_uniformContinuous,\n    this.uniform_continuous_iff]\n  rfl\n#align uniform_inducing.uniform_equicontinuous_iff UniformInducing.uniformEquicontinuous_iff\n-/\n\n",
 "uniformEquicontinuous_at_iff_range":
 "#print uniformEquicontinuous_at_iff_range /-\n/-- A family `𝓕 : ι → β → α` is uniformly equicontinuous iff `range 𝓕` is uniformly equicontinuous,\ni.e the family `coe : range F → β → α` is uniformly equicontinuous. -/\ntheorem uniformEquicontinuous_at_iff_range {F : ι → β → α} :\n    UniformEquicontinuous F ↔ UniformEquicontinuous (coe : range F → β → α) :=\n  ⟨fun h => by rw [← comp_range_splitting F] <;> exact h.comp _, fun h => h.comp (rangeFactorization F)⟩\n#align uniform_equicontinuous_at_iff_range uniformEquicontinuous_at_iff_range\n-/\n\n",
 "uniformContinuous_of_uniformEquicontinuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.uniformContinuous_of_uniformEquicontinuous /-\n/-- If `𝓕 : ι → β → α` tends to `f : β → α` *pointwise* along some nontrivial filter, and if the\nfamily `𝓕` is uniformly equicontinuous, then the limit is uniformly continuous. -/\ntheorem Filter.Tendsto.uniformContinuous_of_uniformEquicontinuous {l : Filter ι} [l.ne_bot] {F : ι → β → α} {f : β → α}\n    (h₁ : Tendsto F l ((nhds) f)) (h₂ : UniformEquicontinuous F) : UniformContinuous f :=\n  (uniformEquicontinuous_at_iff_range.mp h₂).closure.uniform_continuous\n    ⟨f, mem_closure_of_tendsto h₁ <| eventually_of_forall mem_range_self⟩\n#align filter.tendsto.uniform_continuous_of_uniform_equicontinuous Filter.Tendsto.uniformContinuous_of_uniformEquicontinuous\n-/\n\n",
 "uniformContinuous_of_mem":
 "#print Set.UniformEquicontinuous.uniformContinuous_of_mem /-\nprotected theorem Set.UniformEquicontinuous.uniformContinuous_of_mem {H : Set <| β → α} (h : H.uniform_equicontinuous)\n    {f : β → α} (hf : f ∈ H) : UniformContinuous f :=\n  h.uniform_continuous ⟨f, hf⟩\n#align set.uniform_equicontinuous.uniform_continuous_of_mem Set.UniformEquicontinuous.uniformContinuous_of_mem\n-/\n\n",
 "uniformContinuous":
 "#print UniformEquicontinuous.uniformContinuous /-\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem UniformEquicontinuous.uniformContinuous {F : ι → β → α} (h : UniformEquicontinuous F) (i : ι) :\n    UniformContinuous (F i) := fun U hU => mem_map.mpr (mem_of_superset (h U hU) fun xy hxy => hxy i)\n#align uniform_equicontinuous.uniform_continuous UniformEquicontinuous.uniformContinuous\n-/\n\n",
 "mono":
 "#print Set.UniformEquicontinuous.mono /-\nprotected theorem Set.UniformEquicontinuous.mono {H H' : Set <| β → α} (h : H.uniform_equicontinuous) (hH : H' ⊆ H) :\n    H'.uniform_equicontinuous :=\n  h.comp (inclusion hH)\n#align set.uniform_equicontinuous.mono Set.UniformEquicontinuous.mono\n-/\n\n",
 "equicontinuous_iff_range":
 "#print equicontinuous_iff_range /-\n/-- A family `𝓕 : ι → X → α` is equicontinuous iff `range 𝓕` is equicontinuous,\ni.e the family `coe : range F → X → α` is equicontinuous. -/\ntheorem equicontinuous_iff_range {F : ι → X → α} : Equicontinuous F ↔ Equicontinuous (coe : range F → X → α) :=\n  forall_congr' fun x₀ => equicontinuousAt_iff_range\n#align equicontinuous_iff_range equicontinuous_iff_range\n-/\n\n",
 "equicontinuous_iff_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ » -/\n#print equicontinuous_iff_continuous /-\n/-- A family `𝓕 : ι → X → α` is equicontinuous iff the function `swap 𝓕 : X → ι → α` is\ncontinuous *when `ι → α` is equipped with the topology of uniform convergence*. This is\nvery useful for developping the equicontinuity API, but it should not be used directly for other\npurposes. -/\ntheorem equicontinuous_iff_continuous {F : ι → X → α} :\n    Equicontinuous F ↔ Continuous (ofFun ∘ function.swap F : X → «expr →ᵤ » ι α) := by\n  simp_rw [Equicontinuous, continuous_iff_continuousAt, equicontinuousAt_iff_continuousAt]\n#align equicontinuous_iff_continuous equicontinuous_iff_continuous\n-/\n\n",
 "equicontinuous_iff":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr ∀ x, (_ : exprProp())]] -/\n#print UniformInducing.equicontinuous_iff /-\n/-- Given `u : α → β` a uniform inducing map, a family `𝓕 : ι → X → α` is equicontinuous iff the\nfamily `𝓕'`, obtained by precomposing each function of `𝓕` by `u`, is equicontinuous. -/\ntheorem UniformInducing.equicontinuous_iff {F : ι → X → α} {u : α → β} (hu : UniformInducing u) :\n    Equicontinuous F ↔ Equicontinuous ((· ∘ ·) u ∘ F) :=\n  by\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr ∀ x, (_ : exprProp())]]\"\n  rw [hu.equicontinuous_at_iff]\n#align uniform_inducing.equicontinuous_iff UniformInducing.equicontinuous_iff\n-/\n\n",
 "equicontinuousAt_iff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.HasBasis.equicontinuousAt_iff_right /-\ntheorem Filter.HasBasis.equicontinuousAt_iff_right {κ : Type _} {p : κ → Prop} {s : κ → Set (α × α)} {F : ι → X → α}\n    {x₀ : X} (hα : ((uniformity) α).has_basis p s) :\n    EquicontinuousAt F x₀ ↔\n      ∀ k,\n        p k →\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n            ((nhds) x₀) (∀ i, (F i x₀, F i x) ∈ s k) :=\n  by\n  rw [equicontinuousAt_iff_continuousAt, ContinuousAt, (UniformFun.hasBasis_nhds_of_basis ι α _ hα).tendsto_right_iff]\n  rfl\n#align filter.has_basis.equicontinuous_at_iff_right Filter.HasBasis.equicontinuousAt_iff_right\n-/\n\n",
 "equicontinuousAt_iff_range":
 "#print equicontinuousAt_iff_range /-\n/-- A family `𝓕 : ι → X → α` is equicontinuous at `x₀` iff `range 𝓕` is equicontinuous at `x₀`,\ni.e the family `coe : range F → X → α` is equicontinuous at `x₀`. -/\ntheorem equicontinuousAt_iff_range {F : ι → X → α} {x₀ : X} :\n    EquicontinuousAt F x₀ ↔ EquicontinuousAt (coe : range F → X → α) x₀ :=\n  ⟨fun h => by rw [← comp_range_splitting F] <;> exact h.comp _, fun h => h.comp (rangeFactorization F)⟩\n#align equicontinuous_at_iff_range equicontinuousAt_iff_range\n-/\n\n",
 "equicontinuousAt_iff_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » V) -/\n#print equicontinuousAt_iff_pair /-\n/-\nCopyright (c) 2022 Anatole Dedecker. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anatole Dedecker\n-/\n/-- Reformulation of equicontinuity at `x₀` comparing two variables near `x₀` instead of comparing\nonly one with `x₀`. -/\ntheorem equicontinuousAt_iff_pair {F : ι → X → α} {x₀ : X} :\n    EquicontinuousAt F x₀ ↔\n      ∀ U ∈ (uniformity) α, ∃ V ∈ (nhds) x₀, ∀ (x) (_ : x ∈ V) (y) (_ : y ∈ V) (i), (F i x, F i y) ∈ U :=\n  by\n  constructor <;> intro H U hU\n  · rcases comp_symm_mem_uniformity_sets hU with ⟨V, hV, hVsymm, hVU⟩\n    refine' ⟨_, H V hV, fun x hx y hy i => hVU (prod_mk_mem_compRel _ (hy i))⟩\n    exact hVsymm.mk_mem_comm.mp (hx i)\n  · rcases H U hU with ⟨V, hV, hVU⟩\n    filter_upwards [hV]using fun x hx i => hVU x₀ (mem_of_mem_nhds hV) x hx i\n#align equicontinuous_at_iff_pair equicontinuousAt_iff_pair\n-/\n\n",
 "equicontinuousAt_iff_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.equicontinuousAt_iff_left /-\ntheorem Filter.HasBasis.equicontinuousAt_iff_left {κ : Type _} {p : κ → Prop} {s : κ → Set X} {F : ι → X → α} {x₀ : X}\n    (hX : ((nhds) x₀).has_basis p s) :\n    EquicontinuousAt F x₀ ↔ ∀ U ∈ (uniformity) α, ∃ (k : _)(_ : p k), ∀ x ∈ s k, ∀ i, (F i x₀, F i x) ∈ U :=\n  by\n  rw [equicontinuousAt_iff_continuousAt, ContinuousAt, hX.tendsto_iff (UniformFun.hasBasis_nhds ι α _)]\n  rfl\n#align filter.has_basis.equicontinuous_at_iff_left Filter.HasBasis.equicontinuousAt_iff_left\n-/\n\n",
 "equicontinuousAt_iff_continuousAt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ » -/\n#print equicontinuousAt_iff_continuousAt /-\n/-- A family `𝓕 : ι → X → α` is equicontinuous at `x₀` iff the function `swap 𝓕 : X → ι → α` is\ncontinuous at `x₀` *when `ι → α` is equipped with the topology of uniform convergence*. This is\nvery useful for developping the equicontinuity API, but it should not be used directly for other\npurposes. -/\ntheorem equicontinuousAt_iff_continuousAt {F : ι → X → α} {x₀ : X} :\n    EquicontinuousAt F x₀ ↔ ContinuousAt (ofFun ∘ function.swap F : X → «expr →ᵤ » ι α) x₀ := by\n  rw [ContinuousAt, (UniformFun.hasBasis_nhds ι α _).tendsto_right_iff] <;> rfl\n#align equicontinuous_at_iff_continuous_at equicontinuousAt_iff_continuousAt\n-/\n\n",
 "equicontinuousAt_iff":
 "#print UniformInducing.equicontinuousAt_iff /-\n/-- Given `u : α → β` a uniform inducing map, a family `𝓕 : ι → X → α` is equicontinuous at a point\n`x₀ : X` iff the family `𝓕'`, obtained by precomposing each function of `𝓕` by `u`, is\nequicontinuous at `x₀`. -/\ntheorem UniformInducing.equicontinuousAt_iff {F : ι → X → α} {x₀ : X} {u : α → β} (hu : UniformInducing u) :\n    EquicontinuousAt F x₀ ↔ EquicontinuousAt ((· ∘ ·) u ∘ F) x₀ :=\n  by\n  have := (UniformFun.postcomp_uniformInducing hu).inducing\n  rw [equicontinuousAt_iff_continuousAt, equicontinuousAt_iff_continuousAt, this.continuous_at_iff]\n  rfl\n#align uniform_inducing.equicontinuous_at_iff UniformInducing.equicontinuousAt_iff\n-/\n\n",
 "equicontinuous":
 "#print UniformEquicontinuous.equicontinuous /-\n/-- Uniform equicontinuity implies equicontinuity. -/\ntheorem UniformEquicontinuous.equicontinuous {F : ι → β → α} (h : UniformEquicontinuous F) : Equicontinuous F :=\n  fun x₀ U hU => mem_of_superset (ball_mem_nhds x₀ (h U hU)) fun x hx i => hx i\n#align uniform_equicontinuous.equicontinuous UniformEquicontinuous.equicontinuous\n-/\n\n",
 "continuous_of_mem":
 "#print Set.Equicontinuous.continuous_of_mem /-\nprotected theorem Set.Equicontinuous.continuous_of_mem {H : Set <| X → α} (h : H.equicontinuous) {f : X → α}\n    (hf : f ∈ H) : Continuous f :=\n  h.continuous ⟨f, hf⟩\n#align set.equicontinuous.continuous_of_mem Set.Equicontinuous.continuous_of_mem\n-/\n\n",
 "continuous_of_equicontinuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.continuous_of_equicontinuous_at /-\n/-- If `𝓕 : ι → X → α` tends to `f : X → α` *pointwise* along some nontrivial filter, and if the\nfamily `𝓕` is equicontinuous, then the limit is continuous. -/\ntheorem Filter.Tendsto.continuous_of_equicontinuous_at {l : Filter ι} [l.ne_bot] {F : ι → X → α} {f : X → α}\n    (h₁ : Tendsto F l ((nhds) f)) (h₂ : Equicontinuous F) : Continuous f :=\n  continuous_iff_continuousAt.mpr fun x => h₁.continuous_at_of_equicontinuous_at (h₂ x)\n#align filter.tendsto.continuous_of_equicontinuous_at Filter.Tendsto.continuous_of_equicontinuous_at\n-/\n\n",
 "continuousAt_of_mem":
 "#print Set.EquicontinuousAt.continuousAt_of_mem /-\nprotected theorem Set.EquicontinuousAt.continuousAt_of_mem {H : Set <| X → α} {x₀ : X} (h : H.equicontinuous_at x₀)\n    {f : X → α} (hf : f ∈ H) : ContinuousAt f x₀ :=\n  h.continuous_at ⟨f, hf⟩\n#align set.equicontinuous_at.continuous_at_of_mem Set.EquicontinuousAt.continuousAt_of_mem\n-/\n\n",
 "continuousAt_of_equicontinuousAt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.continuousAt_of_equicontinuousAt /-\n/-- If `𝓕 : ι → X → α` tends to `f : X → α` *pointwise* along some nontrivial filter, and if the\nfamily `𝓕` is equicontinuous at some `x₀ : X`, then the limit is continuous at `x₀`. -/\ntheorem Filter.Tendsto.continuousAt_of_equicontinuousAt {l : Filter ι} [l.ne_bot] {F : ι → X → α} {f : X → α} {x₀ : X}\n    (h₁ : Tendsto F l ((nhds) f)) (h₂ : EquicontinuousAt F x₀) : ContinuousAt f x₀ :=\n  (equicontinuousAt_iff_range.mp h₂).closure.continuous_at\n    ⟨f, mem_closure_of_tendsto h₁ <| eventually_of_forall mem_range_self⟩\n#align filter.tendsto.continuous_at_of_equicontinuous_at Filter.Tendsto.continuousAt_of_equicontinuousAt\n-/\n\n",
 "continuousAt":
 "#print EquicontinuousAt.continuousAt /-\n/-- Each function of a family equicontinuous at `x₀` is continuous at `x₀`. -/\ntheorem EquicontinuousAt.continuousAt {F : ι → X → α} {x₀ : X} (h : EquicontinuousAt F x₀) (i : ι) :\n    ContinuousAt (F i) x₀ := by\n  intro U hU\n  rw [UniformSpace.mem_nhds_iff] at hU\n  rcases hU with ⟨V, hV₁, hV₂⟩\n  exact mem_map.mpr (mem_of_superset (h V hV₁) fun x hx => hV₂ (hx i))\n#align equicontinuous_at.continuous_at EquicontinuousAt.continuousAt\n-/\n\n",
 "continuous":
 "#print Equicontinuous.continuous /-\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem Equicontinuous.continuous {F : ι → X → α} (h : Equicontinuous F) (i : ι) : Continuous (F i) :=\n  continuous_iff_continuousAt.mpr fun x => (h x).continuous_at i\n#align equicontinuous.continuous Equicontinuous.continuous\n-/\n\n",
 "comp":
 "#print UniformEquicontinuous.comp /-\n/-- Taking sub-families preserves uniform equicontinuity. -/\ntheorem UniformEquicontinuous.comp {F : ι → β → α} (h : UniformEquicontinuous F) (u : κ → ι) :\n    UniformEquicontinuous (F ∘ u) := fun U hU => (h U hU).mono fun x H k => H (u k)\n#align uniform_equicontinuous.comp UniformEquicontinuous.comp\n-/\n\n",
 "closure'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print UniformEquicontinuous.closure' /-\n/-- A version of `uniform_equicontinuous.closure` applicable to subsets of types which embed\ncontinuously into `β → α` with the product topology. It turns out we don't need any other condition\non the embedding than continuity, but in practice this will mostly be applied to `fun_like` types\nwhere the coercion is injective. -/\ntheorem UniformEquicontinuous.closure' {A : Set Y} {u : Y → β → α} (hA : UniformEquicontinuous (u ∘ coe : A → β → α))\n    (hu : Continuous u) : UniformEquicontinuous (u ∘ coe : closure A → β → α) :=\n  by\n  intro U hU\n  rcases mem_uniformity_isClosed hU with ⟨V, hV, hVclosed, hVU⟩\n  filter_upwards [hA V hV]\n  rintro ⟨x, y⟩ hxy\n  rw [SetCoe.forall] at *\n  change A ⊆ «expr ⁻¹' » (fun f => (u f x, u f y)) V at hxy\n  refine' (closure_minimal hxy <| hVclosed.preimage <| _).trans (preimage_mono hVU)\n  exact Continuous.prod_mk ((continuous_apply x).comp hu) ((continuous_apply y).comp hu)\n#align uniform_equicontinuous.closure' UniformEquicontinuous.closure'\n-/\n\n",
 "closure":
 "#print UniformEquicontinuous.closure /-\n/-- If a set of functions is uniformly equicontinuous, its closure for the product topology is also\nuniformly equicontinuous. -/\ntheorem UniformEquicontinuous.closure {A : Set <| β → α} (hA : A.uniform_equicontinuous) :\n    (closure A).uniform_equicontinuous :=\n  @UniformEquicontinuous.closure' _ _ _ _ _ _ _ id hA continuous_id\n#align uniform_equicontinuous.closure UniformEquicontinuous.closure\n-/\n\n"}