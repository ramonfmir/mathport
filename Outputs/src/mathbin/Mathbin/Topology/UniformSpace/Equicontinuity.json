{"uniformEquicontinuous_iff_uniformContinuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤ Â» -/\n#print uniformEquicontinuous_iff_uniformContinuous /-\n/-- A family `ğ“• : Î¹ â†’ Î² â†’ Î±` is uniformly equicontinuous iff the function `swap ğ“• : Î² â†’ Î¹ â†’ Î±` is\nuniformly continuous *when `Î¹ â†’ Î±` is equipped with the uniform structure of uniform convergence*.\nThis is very useful for developping the equicontinuity API, but it should not be used directly\nfor other purposes. -/\ntheorem uniformEquicontinuous_iff_uniformContinuous {F : Î¹ â†’ Î² â†’ Î±} :\n    UniformEquicontinuous F â†” UniformContinuous (ofFun âˆ˜ function.swap F : Î² â†’ Â«expr â†’áµ¤ Â» Î¹ Î±) := by\n  rw [UniformContinuous, (UniformFun.hasBasis_uniformity Î¹ Î±).tendsto_right_iff] <;> rfl\n#align uniform_equicontinuous_iff_uniform_continuous uniformEquicontinuous_iff_uniformContinuous\n-/\n\n",
 "uniformEquicontinuous_iff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.uniformEquicontinuous_iff_right /-\ntheorem Filter.HasBasis.uniformEquicontinuous_iff_right {Îº : Type _} {p : Îº â†’ Prop} {s : Îº â†’ Set (Î± Ã— Î±)}\n    {F : Î¹ â†’ Î² â†’ Î±} (hÎ± : ((uniformity) Î±).has_basis p s) :\n    UniformEquicontinuous F â†”\n      âˆ€ k,\n        p k â†’\n          Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n            ((uniformity) Î²) (âˆ€ i, (F i xy.1, F i xy.2) âˆˆ s k) :=\n  by\n  rw [uniformEquicontinuous_iff_uniformContinuous, UniformContinuous,\n    (UniformFun.hasBasis_uniformity_of_basis Î¹ Î± hÎ±).tendsto_right_iff]\n  rfl\n#align filter.has_basis.uniform_equicontinuous_iff_right Filter.HasBasis.uniformEquicontinuous_iff_right\n-/\n\n",
 "uniformEquicontinuous_iff_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.uniformEquicontinuous_iff_left /-\ntheorem Filter.HasBasis.uniformEquicontinuous_iff_left {Îº : Type _} {p : Îº â†’ Prop} {s : Îº â†’ Set (Î² Ã— Î²)} {F : Î¹ â†’ Î² â†’ Î±}\n    (hÎ² : ((uniformity) Î²).has_basis p s) :\n    UniformEquicontinuous F â†” âˆ€ U âˆˆ (uniformity) Î±, âˆƒ (k : _)(_ : p k), âˆ€ x y, (x, y) âˆˆ s k â†’ âˆ€ i, (F i x, F i y) âˆˆ U :=\n  by\n  rw [uniformEquicontinuous_iff_uniformContinuous, UniformContinuous,\n    hÎ².tendsto_iff (UniformFun.hasBasis_uniformity Î¹ Î±)]\n  simp_rw [Prod.forall]\n  rfl\n#align filter.has_basis.uniform_equicontinuous_iff_left Filter.HasBasis.uniformEquicontinuous_iff_left\n-/\n\n",
 "uniformEquicontinuous_iff":
 "#print UniformInducing.uniformEquicontinuous_iff /-\n/-- Given `u : Î± â†’ Î³` a uniform inducing map, a family `ğ“• : Î¹ â†’ Î² â†’ Î±` is uniformly equicontinuous\niff the family `ğ“•'`, obtained by precomposing each function of `ğ“•` by `u`, is uniformly\nequicontinuous. -/\ntheorem UniformInducing.uniformEquicontinuous_iff {F : Î¹ â†’ Î² â†’ Î±} {u : Î± â†’ Î³} (hu : UniformInducing u) :\n    UniformEquicontinuous F â†” UniformEquicontinuous ((Â· âˆ˜ Â·) u âˆ˜ F) :=\n  by\n  have := UniformFun.postcomp_uniformInducing hu\n  rw [uniformEquicontinuous_iff_uniformContinuous, uniformEquicontinuous_iff_uniformContinuous,\n    this.uniform_continuous_iff]\n  rfl\n#align uniform_inducing.uniform_equicontinuous_iff UniformInducing.uniformEquicontinuous_iff\n-/\n\n",
 "uniformEquicontinuous_at_iff_range":
 "#print uniformEquicontinuous_at_iff_range /-\n/-- A family `ğ“• : Î¹ â†’ Î² â†’ Î±` is uniformly equicontinuous iff `range ğ“•` is uniformly equicontinuous,\ni.e the family `coe : range F â†’ Î² â†’ Î±` is uniformly equicontinuous. -/\ntheorem uniformEquicontinuous_at_iff_range {F : Î¹ â†’ Î² â†’ Î±} :\n    UniformEquicontinuous F â†” UniformEquicontinuous (coe : range F â†’ Î² â†’ Î±) :=\n  âŸ¨fun h => by rw [â† comp_range_splitting F] <;> exact h.comp _, fun h => h.comp (rangeFactorization F)âŸ©\n#align uniform_equicontinuous_at_iff_range uniformEquicontinuous_at_iff_range\n-/\n\n",
 "uniformContinuous_of_uniformEquicontinuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.uniformContinuous_of_uniformEquicontinuous /-\n/-- If `ğ“• : Î¹ â†’ Î² â†’ Î±` tends to `f : Î² â†’ Î±` *pointwise* along some nontrivial filter, and if the\nfamily `ğ“•` is uniformly equicontinuous, then the limit is uniformly continuous. -/\ntheorem Filter.Tendsto.uniformContinuous_of_uniformEquicontinuous {l : Filter Î¹} [l.ne_bot] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±}\n    (hâ‚ : Tendsto F l ((nhds) f)) (hâ‚‚ : UniformEquicontinuous F) : UniformContinuous f :=\n  (uniformEquicontinuous_at_iff_range.mp hâ‚‚).closure.uniform_continuous\n    âŸ¨f, mem_closure_of_tendsto hâ‚ <| eventually_of_forall mem_range_selfâŸ©\n#align filter.tendsto.uniform_continuous_of_uniform_equicontinuous Filter.Tendsto.uniformContinuous_of_uniformEquicontinuous\n-/\n\n",
 "uniformContinuous_of_mem":
 "#print Set.UniformEquicontinuous.uniformContinuous_of_mem /-\nprotected theorem Set.UniformEquicontinuous.uniformContinuous_of_mem {H : Set <| Î² â†’ Î±} (h : H.uniform_equicontinuous)\n    {f : Î² â†’ Î±} (hf : f âˆˆ H) : UniformContinuous f :=\n  h.uniform_continuous âŸ¨f, hfâŸ©\n#align set.uniform_equicontinuous.uniform_continuous_of_mem Set.UniformEquicontinuous.uniformContinuous_of_mem\n-/\n\n",
 "uniformContinuous":
 "#print UniformEquicontinuous.uniformContinuous /-\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem UniformEquicontinuous.uniformContinuous {F : Î¹ â†’ Î² â†’ Î±} (h : UniformEquicontinuous F) (i : Î¹) :\n    UniformContinuous (F i) := fun U hU => mem_map.mpr (mem_of_superset (h U hU) fun xy hxy => hxy i)\n#align uniform_equicontinuous.uniform_continuous UniformEquicontinuous.uniformContinuous\n-/\n\n",
 "mono":
 "#print Set.UniformEquicontinuous.mono /-\nprotected theorem Set.UniformEquicontinuous.mono {H H' : Set <| Î² â†’ Î±} (h : H.uniform_equicontinuous) (hH : H' âŠ† H) :\n    H'.uniform_equicontinuous :=\n  h.comp (inclusion hH)\n#align set.uniform_equicontinuous.mono Set.UniformEquicontinuous.mono\n-/\n\n",
 "equicontinuous_iff_range":
 "#print equicontinuous_iff_range /-\n/-- A family `ğ“• : Î¹ â†’ X â†’ Î±` is equicontinuous iff `range ğ“•` is equicontinuous,\ni.e the family `coe : range F â†’ X â†’ Î±` is equicontinuous. -/\ntheorem equicontinuous_iff_range {F : Î¹ â†’ X â†’ Î±} : Equicontinuous F â†” Equicontinuous (coe : range F â†’ X â†’ Î±) :=\n  forall_congr' fun xâ‚€ => equicontinuousAt_iff_range\n#align equicontinuous_iff_range equicontinuous_iff_range\n-/\n\n",
 "equicontinuous_iff_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤ Â» -/\n#print equicontinuous_iff_continuous /-\n/-- A family `ğ“• : Î¹ â†’ X â†’ Î±` is equicontinuous iff the function `swap ğ“• : X â†’ Î¹ â†’ Î±` is\ncontinuous *when `Î¹ â†’ Î±` is equipped with the topology of uniform convergence*. This is\nvery useful for developping the equicontinuity API, but it should not be used directly for other\npurposes. -/\ntheorem equicontinuous_iff_continuous {F : Î¹ â†’ X â†’ Î±} :\n    Equicontinuous F â†” Continuous (ofFun âˆ˜ function.swap F : X â†’ Â«expr â†’áµ¤ Â» Î¹ Î±) := by\n  simp_rw [Equicontinuous, continuous_iff_continuousAt, equicontinuousAt_iff_continuousAt]\n#align equicontinuous_iff_continuous equicontinuous_iff_continuous\n-/\n\n",
 "equicontinuous_iff":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr âˆ€ x, (_ : exprProp())]] -/\n#print UniformInducing.equicontinuous_iff /-\n/-- Given `u : Î± â†’ Î²` a uniform inducing map, a family `ğ“• : Î¹ â†’ X â†’ Î±` is equicontinuous iff the\nfamily `ğ“•'`, obtained by precomposing each function of `ğ“•` by `u`, is equicontinuous. -/\ntheorem UniformInducing.equicontinuous_iff {F : Î¹ â†’ X â†’ Î±} {u : Î± â†’ Î²} (hu : UniformInducing u) :\n    Equicontinuous F â†” Equicontinuous ((Â· âˆ˜ Â·) u âˆ˜ F) :=\n  by\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr âˆ€ x, (_ : exprProp())]]\"\n  rw [hu.equicontinuous_at_iff]\n#align uniform_inducing.equicontinuous_iff UniformInducing.equicontinuous_iff\n-/\n\n",
 "equicontinuousAt_iff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.HasBasis.equicontinuousAt_iff_right /-\ntheorem Filter.HasBasis.equicontinuousAt_iff_right {Îº : Type _} {p : Îº â†’ Prop} {s : Îº â†’ Set (Î± Ã— Î±)} {F : Î¹ â†’ X â†’ Î±}\n    {xâ‚€ : X} (hÎ± : ((uniformity) Î±).has_basis p s) :\n    EquicontinuousAt F xâ‚€ â†”\n      âˆ€ k,\n        p k â†’\n          Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n            ((nhds) xâ‚€) (âˆ€ i, (F i xâ‚€, F i x) âˆˆ s k) :=\n  by\n  rw [equicontinuousAt_iff_continuousAt, ContinuousAt, (UniformFun.hasBasis_nhds_of_basis Î¹ Î± _ hÎ±).tendsto_right_iff]\n  rfl\n#align filter.has_basis.equicontinuous_at_iff_right Filter.HasBasis.equicontinuousAt_iff_right\n-/\n\n",
 "equicontinuousAt_iff_range":
 "#print equicontinuousAt_iff_range /-\n/-- A family `ğ“• : Î¹ â†’ X â†’ Î±` is equicontinuous at `xâ‚€` iff `range ğ“•` is equicontinuous at `xâ‚€`,\ni.e the family `coe : range F â†’ X â†’ Î±` is equicontinuous at `xâ‚€`. -/\ntheorem equicontinuousAt_iff_range {F : Î¹ â†’ X â†’ Î±} {xâ‚€ : X} :\n    EquicontinuousAt F xâ‚€ â†” EquicontinuousAt (coe : range F â†’ X â†’ Î±) xâ‚€ :=\n  âŸ¨fun h => by rw [â† comp_range_splitting F] <;> exact h.comp _, fun h => h.comp (rangeFactorization F)âŸ©\n#align equicontinuous_at_iff_range equicontinuousAt_iff_range\n-/\n\n",
 "equicontinuousAt_iff_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y Â«expr âˆˆ Â» V) -/\n#print equicontinuousAt_iff_pair /-\n/-\nCopyright (c) 2022 Anatole Dedecker. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anatole Dedecker\n-/\n/-- Reformulation of equicontinuity at `xâ‚€` comparing two variables near `xâ‚€` instead of comparing\nonly one with `xâ‚€`. -/\ntheorem equicontinuousAt_iff_pair {F : Î¹ â†’ X â†’ Î±} {xâ‚€ : X} :\n    EquicontinuousAt F xâ‚€ â†”\n      âˆ€ U âˆˆ (uniformity) Î±, âˆƒ V âˆˆ (nhds) xâ‚€, âˆ€ (x) (_ : x âˆˆ V) (y) (_ : y âˆˆ V) (i), (F i x, F i y) âˆˆ U :=\n  by\n  constructor <;> intro H U hU\n  Â· rcases comp_symm_mem_uniformity_sets hU with âŸ¨V, hV, hVsymm, hVUâŸ©\n    refine' âŸ¨_, H V hV, fun x hx y hy i => hVU (prod_mk_mem_compRel _ (hy i))âŸ©\n    exact hVsymm.mk_mem_comm.mp (hx i)\n  Â· rcases H U hU with âŸ¨V, hV, hVUâŸ©\n    filter_upwards [hV]using fun x hx i => hVU xâ‚€ (mem_of_mem_nhds hV) x hx i\n#align equicontinuous_at_iff_pair equicontinuousAt_iff_pair\n-/\n\n",
 "equicontinuousAt_iff_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.equicontinuousAt_iff_left /-\ntheorem Filter.HasBasis.equicontinuousAt_iff_left {Îº : Type _} {p : Îº â†’ Prop} {s : Îº â†’ Set X} {F : Î¹ â†’ X â†’ Î±} {xâ‚€ : X}\n    (hX : ((nhds) xâ‚€).has_basis p s) :\n    EquicontinuousAt F xâ‚€ â†” âˆ€ U âˆˆ (uniformity) Î±, âˆƒ (k : _)(_ : p k), âˆ€ x âˆˆ s k, âˆ€ i, (F i xâ‚€, F i x) âˆˆ U :=\n  by\n  rw [equicontinuousAt_iff_continuousAt, ContinuousAt, hX.tendsto_iff (UniformFun.hasBasis_nhds Î¹ Î± _)]\n  rfl\n#align filter.has_basis.equicontinuous_at_iff_left Filter.HasBasis.equicontinuousAt_iff_left\n-/\n\n",
 "equicontinuousAt_iff_continuousAt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤ Â» -/\n#print equicontinuousAt_iff_continuousAt /-\n/-- A family `ğ“• : Î¹ â†’ X â†’ Î±` is equicontinuous at `xâ‚€` iff the function `swap ğ“• : X â†’ Î¹ â†’ Î±` is\ncontinuous at `xâ‚€` *when `Î¹ â†’ Î±` is equipped with the topology of uniform convergence*. This is\nvery useful for developping the equicontinuity API, but it should not be used directly for other\npurposes. -/\ntheorem equicontinuousAt_iff_continuousAt {F : Î¹ â†’ X â†’ Î±} {xâ‚€ : X} :\n    EquicontinuousAt F xâ‚€ â†” ContinuousAt (ofFun âˆ˜ function.swap F : X â†’ Â«expr â†’áµ¤ Â» Î¹ Î±) xâ‚€ := by\n  rw [ContinuousAt, (UniformFun.hasBasis_nhds Î¹ Î± _).tendsto_right_iff] <;> rfl\n#align equicontinuous_at_iff_continuous_at equicontinuousAt_iff_continuousAt\n-/\n\n",
 "equicontinuousAt_iff":
 "#print UniformInducing.equicontinuousAt_iff /-\n/-- Given `u : Î± â†’ Î²` a uniform inducing map, a family `ğ“• : Î¹ â†’ X â†’ Î±` is equicontinuous at a point\n`xâ‚€ : X` iff the family `ğ“•'`, obtained by precomposing each function of `ğ“•` by `u`, is\nequicontinuous at `xâ‚€`. -/\ntheorem UniformInducing.equicontinuousAt_iff {F : Î¹ â†’ X â†’ Î±} {xâ‚€ : X} {u : Î± â†’ Î²} (hu : UniformInducing u) :\n    EquicontinuousAt F xâ‚€ â†” EquicontinuousAt ((Â· âˆ˜ Â·) u âˆ˜ F) xâ‚€ :=\n  by\n  have := (UniformFun.postcomp_uniformInducing hu).inducing\n  rw [equicontinuousAt_iff_continuousAt, equicontinuousAt_iff_continuousAt, this.continuous_at_iff]\n  rfl\n#align uniform_inducing.equicontinuous_at_iff UniformInducing.equicontinuousAt_iff\n-/\n\n",
 "equicontinuous":
 "#print UniformEquicontinuous.equicontinuous /-\n/-- Uniform equicontinuity implies equicontinuity. -/\ntheorem UniformEquicontinuous.equicontinuous {F : Î¹ â†’ Î² â†’ Î±} (h : UniformEquicontinuous F) : Equicontinuous F :=\n  fun xâ‚€ U hU => mem_of_superset (ball_mem_nhds xâ‚€ (h U hU)) fun x hx i => hx i\n#align uniform_equicontinuous.equicontinuous UniformEquicontinuous.equicontinuous\n-/\n\n",
 "continuous_of_mem":
 "#print Set.Equicontinuous.continuous_of_mem /-\nprotected theorem Set.Equicontinuous.continuous_of_mem {H : Set <| X â†’ Î±} (h : H.equicontinuous) {f : X â†’ Î±}\n    (hf : f âˆˆ H) : Continuous f :=\n  h.continuous âŸ¨f, hfâŸ©\n#align set.equicontinuous.continuous_of_mem Set.Equicontinuous.continuous_of_mem\n-/\n\n",
 "continuous_of_equicontinuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.continuous_of_equicontinuous_at /-\n/-- If `ğ“• : Î¹ â†’ X â†’ Î±` tends to `f : X â†’ Î±` *pointwise* along some nontrivial filter, and if the\nfamily `ğ“•` is equicontinuous, then the limit is continuous. -/\ntheorem Filter.Tendsto.continuous_of_equicontinuous_at {l : Filter Î¹} [l.ne_bot] {F : Î¹ â†’ X â†’ Î±} {f : X â†’ Î±}\n    (hâ‚ : Tendsto F l ((nhds) f)) (hâ‚‚ : Equicontinuous F) : Continuous f :=\n  continuous_iff_continuousAt.mpr fun x => hâ‚.continuous_at_of_equicontinuous_at (hâ‚‚ x)\n#align filter.tendsto.continuous_of_equicontinuous_at Filter.Tendsto.continuous_of_equicontinuous_at\n-/\n\n",
 "continuousAt_of_mem":
 "#print Set.EquicontinuousAt.continuousAt_of_mem /-\nprotected theorem Set.EquicontinuousAt.continuousAt_of_mem {H : Set <| X â†’ Î±} {xâ‚€ : X} (h : H.equicontinuous_at xâ‚€)\n    {f : X â†’ Î±} (hf : f âˆˆ H) : ContinuousAt f xâ‚€ :=\n  h.continuous_at âŸ¨f, hfâŸ©\n#align set.equicontinuous_at.continuous_at_of_mem Set.EquicontinuousAt.continuousAt_of_mem\n-/\n\n",
 "continuousAt_of_equicontinuousAt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.continuousAt_of_equicontinuousAt /-\n/-- If `ğ“• : Î¹ â†’ X â†’ Î±` tends to `f : X â†’ Î±` *pointwise* along some nontrivial filter, and if the\nfamily `ğ“•` is equicontinuous at some `xâ‚€ : X`, then the limit is continuous at `xâ‚€`. -/\ntheorem Filter.Tendsto.continuousAt_of_equicontinuousAt {l : Filter Î¹} [l.ne_bot] {F : Î¹ â†’ X â†’ Î±} {f : X â†’ Î±} {xâ‚€ : X}\n    (hâ‚ : Tendsto F l ((nhds) f)) (hâ‚‚ : EquicontinuousAt F xâ‚€) : ContinuousAt f xâ‚€ :=\n  (equicontinuousAt_iff_range.mp hâ‚‚).closure.continuous_at\n    âŸ¨f, mem_closure_of_tendsto hâ‚ <| eventually_of_forall mem_range_selfâŸ©\n#align filter.tendsto.continuous_at_of_equicontinuous_at Filter.Tendsto.continuousAt_of_equicontinuousAt\n-/\n\n",
 "continuousAt":
 "#print EquicontinuousAt.continuousAt /-\n/-- Each function of a family equicontinuous at `xâ‚€` is continuous at `xâ‚€`. -/\ntheorem EquicontinuousAt.continuousAt {F : Î¹ â†’ X â†’ Î±} {xâ‚€ : X} (h : EquicontinuousAt F xâ‚€) (i : Î¹) :\n    ContinuousAt (F i) xâ‚€ := by\n  intro U hU\n  rw [UniformSpace.mem_nhds_iff] at hU\n  rcases hU with âŸ¨V, hVâ‚, hVâ‚‚âŸ©\n  exact mem_map.mpr (mem_of_superset (h V hVâ‚) fun x hx => hVâ‚‚ (hx i))\n#align equicontinuous_at.continuous_at EquicontinuousAt.continuousAt\n-/\n\n",
 "continuous":
 "#print Equicontinuous.continuous /-\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem Equicontinuous.continuous {F : Î¹ â†’ X â†’ Î±} (h : Equicontinuous F) (i : Î¹) : Continuous (F i) :=\n  continuous_iff_continuousAt.mpr fun x => (h x).continuous_at i\n#align equicontinuous.continuous Equicontinuous.continuous\n-/\n\n",
 "comp":
 "#print UniformEquicontinuous.comp /-\n/-- Taking sub-families preserves uniform equicontinuity. -/\ntheorem UniformEquicontinuous.comp {F : Î¹ â†’ Î² â†’ Î±} (h : UniformEquicontinuous F) (u : Îº â†’ Î¹) :\n    UniformEquicontinuous (F âˆ˜ u) := fun U hU => (h U hU).mono fun x H k => H (u k)\n#align uniform_equicontinuous.comp UniformEquicontinuous.comp\n-/\n\n",
 "closure'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n#print UniformEquicontinuous.closure' /-\n/-- A version of `uniform_equicontinuous.closure` applicable to subsets of types which embed\ncontinuously into `Î² â†’ Î±` with the product topology. It turns out we don't need any other condition\non the embedding than continuity, but in practice this will mostly be applied to `fun_like` types\nwhere the coercion is injective. -/\ntheorem UniformEquicontinuous.closure' {A : Set Y} {u : Y â†’ Î² â†’ Î±} (hA : UniformEquicontinuous (u âˆ˜ coe : A â†’ Î² â†’ Î±))\n    (hu : Continuous u) : UniformEquicontinuous (u âˆ˜ coe : closure A â†’ Î² â†’ Î±) :=\n  by\n  intro U hU\n  rcases mem_uniformity_isClosed hU with âŸ¨V, hV, hVclosed, hVUâŸ©\n  filter_upwards [hA V hV]\n  rintro âŸ¨x, yâŸ© hxy\n  rw [SetCoe.forall] at *\n  change A âŠ† Â«expr â»Â¹' Â» (fun f => (u f x, u f y)) V at hxy\n  refine' (closure_minimal hxy <| hVclosed.preimage <| _).trans (preimage_mono hVU)\n  exact Continuous.prod_mk ((continuous_apply x).comp hu) ((continuous_apply y).comp hu)\n#align uniform_equicontinuous.closure' UniformEquicontinuous.closure'\n-/\n\n",
 "closure":
 "#print UniformEquicontinuous.closure /-\n/-- If a set of functions is uniformly equicontinuous, its closure for the product topology is also\nuniformly equicontinuous. -/\ntheorem UniformEquicontinuous.closure {A : Set <| Î² â†’ Î±} (hA : A.uniform_equicontinuous) :\n    (closure A).uniform_equicontinuous :=\n  @UniformEquicontinuous.closure' _ _ _ _ _ _ _ id hA continuous_id\n#align uniform_equicontinuous.closure UniformEquicontinuous.closure\n-/\n\n"}