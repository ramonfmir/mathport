{"uniformly_extend_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏˆ -/\n#print uniformly_extend_unique /-\ntheorem uniformly_extend_unique {g : Î± â†’ Î³} (hg : âˆ€ b, g (e b) = f b) (hc : Continuous g) : exprÏˆ = g :=\n  DenseInducing.extend_unique _ hg hc\n#align uniformly_extend_unique uniformly_extend_unique\n-/\n\n",
 "uniformly_extend_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏˆ -/\n#print uniformly_extend_spec /-\ntheorem uniformly_extend_spec [CompleteSpace Î³] (a : Î±) : Tendsto f (comap e ((nhds) a)) ((nhds) ((exprÏˆ) a)) := by\n  simpa only [DenseInducing.extend] using tendsto_nhds_limUnder (uniformly_extend_exists h_e â€¹_â€º h_f _)\n#align uniformly_extend_spec uniformly_extend_spec\n-/\n\n",
 "uniformly_extend_of_ind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏˆ -/\n#print uniformly_extend_of_ind /-\ntheorem uniformly_extend_of_ind (b : Î²) : (exprÏˆ) (e b) = f b :=\n  DenseInducing.extend_eq_at _ h_f.continuous.continuous_at\n#align uniformly_extend_of_ind uniformly_extend_of_ind\n-/\n\n",
 "uniformly_extend_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print uniformly_extend_exists /-\ntheorem uniformly_extend_exists [CompleteSpace Î³] (a : Î±) : âˆƒ c, Tendsto f (comap e ((nhds) a)) ((nhds) c) :=\n  let de := h_e.dense_inducing h_dense\n  have : Cauchy ((nhds) a) := cauchy_nhds\n  have : Cauchy (comap e ((nhds) a)) := this.comap' (le_of_eq h_e.comap_uniformity) (de.comap_nhds_ne_bot _)\n  have : Cauchy (map f (comap e ((nhds) a))) := this.map h_f\n  complete_space.complete this\n#align uniformly_extend_exists uniformly_extend_exists\n-/\n\n",
 "uniform_extend_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print uniform_extend_subtype /-\ntheorem uniform_extend_subtype [CompleteSpace Î³] {p : Î± â†’ Prop} {e : Î± â†’ Î²} {f : Î± â†’ Î³} {b : Î²} {s : Set Î±}\n    (hf : UniformContinuous fun x : Subtype p => f x.val) (he : UniformEmbedding e)\n    (hd : âˆ€ x : Î², x âˆˆ closure (range e)) (hb : closure (Â«expr '' Â» e s) âˆˆ (nhds) b) (hs : IsClosed s)\n    (hp : âˆ€ x âˆˆ s, p x) : âˆƒ c, Tendsto f (comap e ((nhds) b)) ((nhds) c) :=\n  by\n  have de : DenseEmbedding e := he.dense_embedding hd\n  have de' : DenseEmbedding (DenseEmbedding.subtypeEmb p e) := de.subtype p\n  have ue' : UniformEmbedding (DenseEmbedding.subtypeEmb p e) := uniformEmbedding_subtypeEmb _ he de\n  have : b âˆˆ closure (Â«expr '' Â» e { x | p x }) := (closure_mono <| monotone_image <| hp) (mem_of_mem_nhds hb)\n  let âŸ¨c, (hc : tendsto (f âˆ˜ Subtype.val) (comap (DenseEmbedding.subtypeEmb p e) ((nhds) âŸ¨b, thisâŸ©)) ((nhds) c))âŸ© :=\n    uniformly_extend_exists ue'.to_uniform_inducing de'.dense hf _\n  rw [nhds_subtype_eq_comap] at hc\n  simp [comap_comap] at hc\n  change tendsto (f âˆ˜ @Subtype.val Î± p) (comap (e âˆ˜ @Subtype.val Î± p) ((nhds) b)) ((nhds) c) at hc\n  rw [â† comap_comap, tendsto_comap'_iff] at hc\n  exact âŸ¨c, hcâŸ©\n  exact\n    âŸ¨_, hb, fun x => by\n      change e x âˆˆ closure (Â«expr '' Â» e s) â†’ x âˆˆ range Subtype.val\n      rw [â† closure_induced, mem_closure_iff_clusterPt, ClusterPt, ne_bot_iff, nhds_induced, â†\n        de.to_dense_inducing.nhds_eq_comap, â† mem_closure_iff_nhds_neBot, hs.closure_eq]\n      exact fun hxs => âŸ¨âŸ¨x, hp x hxsâŸ©, rflâŸ©âŸ©\n#align uniform_extend_subtype uniform_extend_subtype\n-/\n\n",
 "uniformInducing_of_compose":
 "#print uniformInducing_of_compose /-\ntheorem uniformInducing_of_compose {f : Î± â†’ Î²} {g : Î² â†’ Î³} (hf : UniformContinuous f) (hg : UniformContinuous g)\n    (hgf : UniformInducing (g âˆ˜ f)) : UniformInducing f :=\n  by\n  refine' âŸ¨le_antisymm _ hf.le_comapâŸ©\n  rw [â† hgf.1, â† Prod.map_def, â† Prod.map_def, â† Prod.map_comp_map f f g g, â† @comap_comap _ _ _ _ (prod.map f f)]\n  exact comap_mono hg.le_comap\n#align uniform_inducing_of_compose uniformInducing_of_compose\n-/\n\n",
 "uniformInducing_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformInducing_iff' /-\ntheorem uniformInducing_iff' {f : Î± â†’ Î²} :\n    UniformInducing f â†” UniformContinuous f âˆ§ comap (prod.map f f) ((uniformity) Î²) â‰¤ (uniformity) Î± := by\n  rw [uniformInducing_iff, UniformContinuous, tendsto_iff_comap, le_antisymm_iff, and_comm'] <;> rfl\n#align uniform_inducing_iff' uniformInducing_iff'\n-/\n\n",
 "uniformInducing_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.uniformInducing_iff /-\nprotected theorem Filter.HasBasis.uniformInducing_iff {Î¹ Î¹'} {p : Î¹ â†’ Prop} {p' : Î¹' â†’ Prop} {s s'}\n    (h : ((uniformity) Î±).has_basis p s) (h' : ((uniformity) Î²).has_basis p' s') {f : Î± â†’ Î²} :\n    UniformInducing f â†”\n      (âˆ€ i, p' i â†’ âˆƒ j, p j âˆ§ âˆ€ x y, (x, y) âˆˆ s j â†’ (f x, f y) âˆˆ s' i) âˆ§\n        âˆ€ j, p j â†’ âˆƒ i, p' i âˆ§ âˆ€ x y, (f x, f y) âˆˆ s' i â†’ (x, y) âˆˆ s j :=\n  by simp [uniformInducing_iff', h.uniform_continuous_iff h', (h'.comap _).le_basis_iff h, subset_def]\n#align filter.has_basis.uniform_inducing_iff Filter.HasBasis.uniformInducing_iff\n-/\n\n",
 "uniformInducing_id":
 "#print uniformInducing_id /-\ntheorem uniformInducing_id : UniformInducing (@id Î±) :=\n  âŸ¨by rw [â† Prod.map_def, Prod.map_id, comap_id]âŸ©\n#align uniform_inducing_id uniformInducing_id\n-/\n\n",
 "uniformEmbedding_subtype_val":
 "/- warning: uniform_embedding_subtype_coe clashes with uniform_embedding_subtype_val -> uniformEmbedding_subtype_val\nCase conversion may be inaccurate. Consider using '#align uniform_embedding_subtype_coe uniformEmbedding_subtype_valâ‚“'. -/\n#print uniformEmbedding_subtype_val /-\ntheorem uniformEmbedding_subtype_val {p : Î± â†’ Prop} : UniformEmbedding (coe : Subtype p â†’ Î±) :=\n  uniformEmbedding_subtype_val\n#align uniform_embedding_subtype_coe uniformEmbedding_subtype_val\n-/\n\n",
 "uniformEmbedding_subtypeEmb":
 "#print uniformEmbedding_subtypeEmb /-\ntheorem uniformEmbedding_subtypeEmb (p : Î± â†’ Prop) {e : Î± â†’ Î²} (ue : UniformEmbedding e) (de : DenseEmbedding e) :\n    UniformEmbedding (DenseEmbedding.subtypeEmb p e) :=\n  { comap_uniformity := by\n      simp [comap_comap, (Â· âˆ˜ Â·), DenseEmbedding.subtypeEmb, uniformity_subtype, ue.comap_uniformity.symm]\n    inj := (de.subtype p).inj }\n#align uniform_embedding_subtype_emb uniformEmbedding_subtypeEmb\n-/\n\n",
 "uniformEmbedding_set_inclusion":
 "#print uniformEmbedding_set_inclusion /-\ntheorem uniformEmbedding_set_inclusion {s t : Set Î±} (hst : s âŠ† t) : UniformEmbedding (inclusion hst) :=\n  { comap_uniformity := by\n      erw [uniformity_subtype, uniformity_subtype, comap_comap]\n      congr\n    inj := inclusion_injective hst }\n#align uniform_embedding_set_inclusion uniformEmbedding_set_inclusion\n-/\n\n",
 "uniformEmbedding_of_spaced_out":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n#print uniformEmbedding_of_spaced_out /-\n/-- If a map `f : Î± â†’ Î²` sends any two distinct points to point that are **not** related by a fixed\n`s âˆˆ ğ“¤ Î²`, then `f` is a uniform embedding with respect to the discrete uniformity on `Î±`. -/\ntheorem uniformEmbedding_of_spaced_out {Î±} {f : Î± â†’ Î²} {s : Set (Î² Ã— Î²)} (hs : s âˆˆ (uniformity) Î²)\n    (hf : Pairwise fun x y => (f x, f y) âˆ‰ s) : @UniformEmbedding Î± Î² (Â«exprâŠ¥Â») â€¹_â€º f :=\n  by\n  letI : UniformSpace Î± := Â«exprâŠ¥Â»; haveI := discreteTopology_bot Î±\n  haveI : SeparatedSpace Î± := separated_iff_t2.2 inferInstance\n  exact UniformInducing.uniformEmbedding âŸ¨comap_uniformity_of_spaced_out hs hfâŸ©\n#align uniform_embedding_of_spaced_out uniformEmbedding_of_spaced_out\n-/\n\n",
 "uniformEmbedding_inr":
 "#print uniformEmbedding_inr /-\ntheorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : Î² â†’ Sum Î± Î²) :=\n  by\n  refine' âŸ¨âŸ¨_âŸ©, Sum.inr_injectiveâŸ©\n  rw [Sum.uniformity, comap_sup, comap_eq_bot_iff_compl_range.2 _, comap_map, bot_sup_eq]\n  Â· exact sum.inr_injective.prod_map Sum.inr_injective\n  Â· refine' mem_map.2 (univ_mem' _)\n    simp\n#align uniform_embedding_inr uniformEmbedding_inr\n-/\n\n",
 "uniformEmbedding_inl":
 "#print uniformEmbedding_inl /-\ntheorem uniformEmbedding_inl : UniformEmbedding (Sum.inl : Î± â†’ Sum Î± Î²) :=\n  by\n  refine' âŸ¨âŸ¨_âŸ©, Sum.inl_injectiveâŸ©\n  rw [Sum.uniformity, comap_sup, comap_map, comap_eq_bot_iff_compl_range.2 _, sup_bot_eq]\n  Â· refine' mem_map.2 (univ_mem' _)\n    simp\n  Â· exact sum.inl_injective.prod_map Sum.inl_injective\n#align uniform_embedding_inl uniformEmbedding_inl\n-/\n\n",
 "uniformEmbedding_iff_uniformInducing":
 "#print uniformEmbedding_iff_uniformInducing /-\ntheorem uniformEmbedding_iff_uniformInducing [T0Space Î±] {f : Î± â†’ Î²} : UniformEmbedding f â†” UniformInducing f :=\n  âŸ¨uniform_embedding.to_uniform_inducing, UniformInducing.uniformEmbeddingâŸ©\n#align uniform_embedding_iff_uniform_inducing uniformEmbedding_iff_uniformInducing\n-/\n\n",
 "uniformEmbedding_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.uniformEmbedding_iff' /-\ntheorem Filter.HasBasis.uniformEmbedding_iff' {Î¹ Î¹'} {p : Î¹ â†’ Prop} {p' : Î¹' â†’ Prop} {s s'}\n    (h : ((uniformity) Î±).has_basis p s) (h' : ((uniformity) Î²).has_basis p' s') {f : Î± â†’ Î²} :\n    UniformEmbedding f â†”\n      injective f âˆ§\n        (âˆ€ i, p' i â†’ âˆƒ j, p j âˆ§ âˆ€ x y, (x, y) âˆˆ s j â†’ (f x, f y) âˆˆ s' i) âˆ§\n          âˆ€ j, p j â†’ âˆƒ i, p' i âˆ§ âˆ€ x y, (f x, f y) âˆˆ s' i â†’ (x, y) âˆˆ s j :=\n  by rw [uniformEmbedding_iff, and_comm', h.uniform_inducing_iff h']\n#align filter.has_basis.uniform_embedding_iff' Filter.HasBasis.uniformEmbedding_iff'\n-/\n\n",
 "uniformEmbedding_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.uniformEmbedding_iff /-\ntheorem Filter.HasBasis.uniformEmbedding_iff {Î¹ Î¹'} {p : Î¹ â†’ Prop} {p' : Î¹' â†’ Prop} {s s'}\n    (h : ((uniformity) Î±).has_basis p s) (h' : ((uniformity) Î²).has_basis p' s') {f : Î± â†’ Î²} :\n    UniformEmbedding f â†”\n      injective f âˆ§ UniformContinuous f âˆ§ âˆ€ j, p j â†’ âˆƒ i, p' i âˆ§ âˆ€ x y, (f x, f y) âˆˆ s' i â†’ (x, y) âˆˆ s j :=\n  by simp only [h.uniform_embedding_iff' h', h.uniform_continuous_iff h', exists_prop]\n#align filter.has_basis.uniform_embedding_iff Filter.HasBasis.uniformEmbedding_iff\n-/\n\n",
 "uniformEmbedding_comap":
 "#print uniformEmbedding_comap /-\ntheorem uniformEmbedding_comap {Î± : Type _} {Î² : Type _} {f : Î± â†’ Î²} [u : UniformSpace Î²] (hf : function.injective f) :\n    @UniformEmbedding Î± Î² (UniformSpace.comap f u) u f :=\n  @uniform_embedding.mk _ _ (UniformSpace.comap f u) _ _ (@uniform_inducing.mk _ _ (UniformSpace.comap f u) _ _ rfl) hf\n#align uniform_embedding_comap uniformEmbedding_comap\n-/\n\n",
 "uniformEmbedding":
 "#print UniformInducing.uniformEmbedding /-\n/-- If the domain of a `uniform_inducing` map `f` is a `separated_space`, then `f` is injective,\nhence it is a `uniform_embedding`. -/\nprotected theorem UniformInducing.uniformEmbedding [T0Space Î±] {f : Î± â†’ Î²} (hf : UniformInducing f) :\n    UniformEmbedding f :=\n  âŸ¨hf, hf.injectiveâŸ©\n#align uniform_inducing.uniform_embedding UniformInducing.uniformEmbedding\n-/\n\n",
 "uniformContinuous_uniformly_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏˆ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏˆ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏˆ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏˆ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏˆ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏˆ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏˆ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏˆ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprÏˆ -/\n#print uniformContinuous_uniformly_extend /-\ntheorem uniformContinuous_uniformly_extend [cÎ³ : CompleteSpace Î³] : UniformContinuous (exprÏˆ) := fun d hd =>\n  let âŸ¨s, hs, hs_compâŸ© :=\n    (mem_lift'_sets <| monotone_id.comp_rel <| monotone_id.comp_rel monotone_id).mp (comp_le_uniformity3 hd)\n  have h_pnt : âˆ€ {a m}, m âˆˆ (nhds) a â†’ âˆƒ c, c âˆˆ Â«expr '' Â» f (preimage e m) âˆ§ (c, (exprÏˆ) a) âˆˆ s âˆ§ ((exprÏˆ) a, c) âˆˆ s :=\n    fun a m hm =>\n    have nb : NeBot (map f (comap e ((nhds) a))) := ((h_e.dense_inducing h_dense).comap_nhds_ne_bot _).map _\n    have :\n      Â«expr '' Â» f (preimage e m) âˆ© ({ c | (c, (exprÏˆ) a) âˆˆ s } âˆ© { c | ((exprÏˆ) a, c) âˆˆ s }) âˆˆ\n        map f (comap e ((nhds) a)) :=\n      inter_mem (image_mem_map <| preimage_mem_comap <| hm)\n        (uniformly_extend_spec h_e h_dense h_f _ (inter_mem (mem_nhds_right _ hs) (mem_nhds_left _ hs)))\n    nb.nonempty_of_mem this\n  have : preimage (fun p : Î² Ã— Î² => (f p.1, f p.2)) s âˆˆ (uniformity) Î² := h_f hs\n  have : preimage (fun p : Î² Ã— Î² => (f p.1, f p.2)) s âˆˆ comap (fun x : Î² Ã— Î² => (e x.1, e x.2)) ((uniformity) Î±) := by\n    rwa [h_e.comap_uniformity.symm] at this\n  let âŸ¨t, ht, tsâŸ© := this\n  show preimage (fun p : Î± Ã— Î± => ((exprÏˆ) p.1, (exprÏˆ) p.2)) d âˆˆ (uniformity) Î± from\n    ((uniformity) Î±).sets_of_superset (interior_mem_uniformity ht) fun âŸ¨xâ‚, xâ‚‚âŸ© hx_t =>\n      have : (nhds) (xâ‚, xâ‚‚) â‰¤ (filter.principal) (interior t) := isOpen_iff_nhds.mp isOpen_interior (xâ‚, xâ‚‚) hx_t\n      have : interior t âˆˆ filter.prod ((nhds) xâ‚) ((nhds) xâ‚‚) := by rwa [nhds_prod_eq, le_principal_iff] at this\n      let âŸ¨mâ‚, hmâ‚, mâ‚‚, hmâ‚‚, (hm : lower_set.prod mâ‚ mâ‚‚ âŠ† interior t)âŸ© := mem_prod_iff.mp this\n      let âŸ¨a, haâ‚, _, haâ‚‚âŸ© := h_pnt hmâ‚\n      let âŸ¨b, hbâ‚, hbâ‚‚, _âŸ© := h_pnt hmâ‚‚\n      have : lower_set.prod (Â«expr â»Â¹' Â» e mâ‚) (Â«expr â»Â¹' Â» e mâ‚‚) âŠ† Â«expr â»Â¹' Â» (fun p : Î² Ã— Î² => (f p.1, f p.2)) s :=\n        calc\n          _ âŠ† preimage (fun p : Î² Ã— Î² => (e p.1, e p.2)) (interior t) := preimage_mono hm\n          _ âŠ† preimage (fun p : Î² Ã— Î² => (e p.1, e p.2)) t := (preimage_mono interior_subset)\n          _ âŠ† preimage (fun p : Î² Ã— Î² => (f p.1, f p.2)) s := ts\n          \n      have : lower_set.prod (Â«expr '' Â» f (Â«expr â»Â¹' Â» e mâ‚)) (Â«expr '' Â» f (Â«expr â»Â¹' Â» e mâ‚‚)) âŠ† s :=\n        calc\n          lower_set.prod (Â«expr '' Â» f (Â«expr â»Â¹' Â» e mâ‚)) (Â«expr '' Â» f (Â«expr â»Â¹' Â» e mâ‚‚)) =\n              Â«expr '' Â» (fun p : Î² Ã— Î² => (f p.1, f p.2)) (lower_set.prod (Â«expr â»Â¹' Â» e mâ‚) (Â«expr â»Â¹' Â» e mâ‚‚)) :=\n            prod_image_image_eq\n          _ âŠ† Â«expr '' Â» (fun p : Î² Ã— Î² => (f p.1, f p.2)) (Â«expr â»Â¹' Â» (fun p : Î² Ã— Î² => (f p.1, f p.2)) s) :=\n            (monotone_image this)\n          _ âŠ† s := image_preimage_subset _ _\n          \n      have : (a, b) âˆˆ s := @this (a, b) âŸ¨haâ‚, hbâ‚âŸ©\n      hs_comp <| show ((exprÏˆ) xâ‚, (exprÏˆ) xâ‚‚) âˆˆ compRel s (compRel s s) from âŸ¨a, haâ‚‚, âŸ¨b, this, hbâ‚‚âŸ©âŸ©\n#align uniform_continuous_uniformly_extend uniformContinuous_uniformly_extend\n-/\n\n",
 "uniformContinuous_iff":
 "#print UniformInducing.uniformContinuous_iff /-\ntheorem UniformInducing.uniformContinuous_iff {f : Î± â†’ Î²} {g : Î² â†’ Î³} (hg : UniformInducing g) :\n    UniformContinuous f â†” UniformContinuous (g âˆ˜ f) :=\n  by\n  dsimp only [UniformContinuous, tendsto]\n  rw [â† hg.comap_uniformity, â† map_le_iff_le_comap, Filter.map_map]\n#align uniform_inducing.uniform_continuous_iff UniformInducing.uniformContinuous_iff\n-/\n\n",
 "uniformContinuous":
 "#print UniformInducing.uniformContinuous /-\ntheorem UniformInducing.uniformContinuous {f : Î± â†’ Î²} (hf : UniformInducing f) : UniformContinuous f :=\n  (uniformInducing_iff'.1 hf).1\n#align uniform_inducing.uniform_continuous UniformInducing.uniformContinuous\n-/\n\n",
 "totallyBounded_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n#print totallyBounded_preimage /-\ntheorem totallyBounded_preimage {f : Î± â†’ Î²} {s : Set Î²} (hf : UniformEmbedding f) (hs : TotallyBounded s) :\n    TotallyBounded (Â«expr â»Â¹' Â» f s) := fun t ht =>\n  by\n  rw [â† hf.comap_uniformity] at ht\n  rcases mem_comap.2 ht with âŸ¨t', ht', tsâŸ©\n  rcases totallyBounded_iff_subset.1 (totallyBounded_subset (image_preimage_subset f s) hs) _ ht' with âŸ¨c, cs, hfc, hctâŸ©\n  refine' âŸ¨Â«expr â»Â¹' Â» f c, hfc.preimage (hf.inj.inj_on _), fun x h => _âŸ©\n  have := hct (mem_image_of_mem f h); simp at thisâŠ¢\n  rcases this with âŸ¨z, zc, ztâŸ©\n  rcases cs zc with âŸ¨y, yc, rflâŸ©\n  exact âŸ¨y, zc, ts ztâŸ©\n#align totally_bounded_preimage totallyBounded_preimage\n-/\n\n",
 "to_uniformEmbedding":
 "#print Embedding.to_uniformEmbedding /-\ntheorem Embedding.to_uniformEmbedding {Î± Î²} [TopologicalSpace Î±] [u : UniformSpace Î²] (f : Î± â†’ Î²) (h : Embedding f) :\n    @UniformEmbedding Î± Î² (h.comap_uniform_space f) u f :=\n  { comap_uniformity := rfl\n    inj := h.inj }\n#align embedding.to_uniform_embedding Embedding.to_uniformEmbedding\n-/\n\n",
 "prod":
 "#print UniformEmbedding.prod /-\ntheorem UniformEmbedding.prod {Î±' : Type _} {Î²' : Type _} [UniformSpace Î±'] [UniformSpace Î²'] {eâ‚ : Î± â†’ Î±'}\n    {eâ‚‚ : Î² â†’ Î²'} (hâ‚ : UniformEmbedding eâ‚) (hâ‚‚ : UniformEmbedding eâ‚‚) :\n    UniformEmbedding fun p : Î± Ã— Î² => (eâ‚ p.1, eâ‚‚ p.2) :=\n  { hâ‚.to_uniform_inducing.prod hâ‚‚.to_uniform_inducing with inj := hâ‚.inj.prod_map hâ‚‚.inj }\n#align uniform_embedding.prod UniformEmbedding.prod\n-/\n\n",
 "mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print UniformInducing.mk' /-\ntheorem UniformInducing.mk' {f : Î± â†’ Î²}\n    (h : âˆ€ s, s âˆˆ (uniformity) Î± â†” âˆƒ t âˆˆ (uniformity) Î², âˆ€ x y : Î±, (f x, f y) âˆˆ t â†’ (x, y) âˆˆ s) : UniformInducing f :=\n  âŸ¨by simp [eq_comm, Filter.ext_iff, subset_def, h]âŸ©\n#align uniform_inducing.mk' UniformInducing.mk'\n-/\n\n",
 "isComplete_range":
 "#print UniformInducing.isComplete_range /-\ntheorem UniformInducing.isComplete_range [CompleteSpace Î±] {f : Î± â†’ Î²} (hf : UniformInducing f) :\n    IsComplete (range f) :=\n  (completeSpace_iff_isComplete_range hf).1 â€¹_â€º\n#align uniform_inducing.is_complete_range UniformInducing.isComplete_range\n-/\n\n",
 "isComplete_of_complete_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print isComplete_of_complete_image /-\ntheorem isComplete_of_complete_image {m : Î± â†’ Î²} {s : Set Î±} (hm : UniformInducing m)\n    (hs : IsComplete (Â«expr '' Â» m s)) : IsComplete s :=\n  by\n  intro f hf hfs\n  rw [le_principal_iff] at hfs\n  obtain âŸ¨_, âŸ¨x, hx, rflâŸ©, hyfâŸ© : âˆƒ y âˆˆ Â«expr '' Â» m s, map m f â‰¤ (nhds) y\n  exact hs (f.map m) (hf.map hm.uniform_continuous) (le_principal_iff.2 (image_mem_map hfs))\n  rw [map_le_iff_le_comap, â† nhds_induced, â† hm.inducing.induced] at hyf\n  exact âŸ¨x, hx, hyfâŸ©\n#align is_complete_of_complete_image isComplete_of_complete_image\n-/\n\n",
 "isComplete_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print isComplete_image_iff /-\n/-- A set is complete iff its image under a uniform inducing map is complete. -/\ntheorem isComplete_image_iff {m : Î± â†’ Î²} {s : Set Î±} (hm : UniformInducing m) :\n    IsComplete (Â«expr '' Â» m s) â†” IsComplete s :=\n  by\n  refine' âŸ¨isComplete_of_complete_image hm, fun c => _âŸ©\n  haveI : CompleteSpace s := c.complete_space_coe\n  set m' : s â†’ Î² := m âˆ˜ coe\n  suffices IsComplete (range m') by rwa [range_comp, Subtype.range_coe] at this\n  have hm' : UniformInducing m' := hm.comp uniform_embedding_subtype_coe.to_uniform_inducing\n  intro f hf hfm\n  rw [Filter.le_principal_iff] at hfm\n  have cf' : Cauchy (comap m' f) := hf.comap' hm'.comap_uniformity.le (ne_bot.comap_of_range_mem hf.1 hfm)\n  rcases complete_space.complete cf' with âŸ¨x, hxâŸ©\n  rw [hm'.inducing.nhds_eq_comap, comap_le_comap_iff hfm] at hx\n  use m' x, mem_range_self _, hx\n#align is_complete_image_iff isComplete_image_iff\n-/\n\n",
 "injective":
 "protected theorem uniform_inducing.injective [T0Space Î±] {f : Î± â†’ Î²} (h : UniformInducing f) : injective f :=\n  h.inducing.injective\n#align uniform_inducing.injective uniform_inducing.injective\n\n",
 "inducing":
 "#print UniformInducing.inducing /-\nprotected theorem UniformInducing.inducing {f : Î± â†’ Î²} (h : UniformInducing f) : Inducing f :=\n  by\n  obtain rfl := h.comap_uniform_space\n  letI := UniformSpace.comap f _\n  exact âŸ¨rflâŸ©\n#align uniform_inducing.inducing UniformInducing.inducing\n-/\n\n",
 "embedding":
 "#print UniformEmbedding.embedding /-\nprotected theorem UniformEmbedding.embedding {f : Î± â†’ Î²} (h : UniformEmbedding f) : Embedding f :=\n  { induced := h.to_uniform_inducing.inducing.induced\n    inj := h.inj }\n#align uniform_embedding.embedding UniformEmbedding.embedding\n-/\n\n",
 "denseInducing":
 "#print UniformInducing.denseInducing /-\ntheorem UniformInducing.denseInducing {f : Î± â†’ Î²} (h : UniformInducing f) (hd : DenseRange f) : DenseInducing f :=\n  { dense := hd\n    induced := h.inducing.induced }\n#align uniform_inducing.dense_inducing UniformInducing.denseInducing\n-/\n\n",
 "denseEmbedding":
 "#print UniformEmbedding.denseEmbedding /-\ntheorem UniformEmbedding.denseEmbedding {f : Î± â†’ Î²} (h : UniformEmbedding f) (hd : DenseRange f) : DenseEmbedding f :=\n  { dense := hd\n    inj := h.inj\n    induced := h.embedding.induced }\n#align uniform_embedding.dense_embedding UniformEmbedding.denseEmbedding\n-/\n\n",
 "completeSpace_iff_isComplete_range":
 "#print completeSpace_iff_isComplete_range /-\ntheorem completeSpace_iff_isComplete_range {f : Î± â†’ Î²} (hf : UniformInducing f) :\n    CompleteSpace Î± â†” IsComplete (range f) := by\n  rw [completeSpace_iff_isComplete_univ, â† isComplete_image_iff hf, image_univ]\n#align complete_space_iff_is_complete_range completeSpace_iff_isComplete_range\n-/\n\n",
 "completeSpace_extension":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print completeSpace_extension /-\ntheorem completeSpace_extension {m : Î² â†’ Î±} (hm : UniformInducing m) (dense : DenseRange m)\n    (h : âˆ€ f : Filter Î², Cauchy f â†’ âˆƒ x : Î±, map m f â‰¤ (nhds) x) : CompleteSpace Î± :=\n  âŸ¨fun f : Filter Î± => fun hf : Cauchy f =>\n    let p : Set (Î± Ã— Î±) â†’ Set Î± â†’ Set Î± := fun s t => { y : Î± | âˆƒ x : Î±, x âˆˆ t âˆ§ (x, y) âˆˆ s }\n    let g := ((uniformity) Î±).lift fun s => f.lift' (p s)\n    have mpâ‚€ : Monotone p := fun a b h t s âŸ¨x, xs, xaâŸ© => âŸ¨x, xs, h xaâŸ©\n    have mpâ‚ : âˆ€ {s}, Monotone (p s) := fun s a b h x âŸ¨y, ya, yxsâŸ© => âŸ¨y, h ya, yxsâŸ©\n    have : f â‰¤ g :=\n      le_infáµ¢ fun s =>\n        le_infáµ¢ fun hs =>\n          le_infáµ¢ fun t =>\n            le_infáµ¢ fun ht => le_principal_iff.mpr <| mem_of_superset ht fun x hx => âŸ¨x, hx, refl_mem_uniformity hsâŸ©\n    have : NeBot g := hf.left.mono this\n    have : NeBot (comap m g) :=\n      comap_neBot fun t ht =>\n        let âŸ¨t', ht', ht_memâŸ© := (mem_lift_sets <| monotone_lift' monotone_const mpâ‚€).mp ht\n        let âŸ¨t'', ht'', ht'_subâŸ© := (mem_lift'_sets mpâ‚).mp ht_mem\n        let âŸ¨x, (hx : x âˆˆ t'')âŸ© := hf.left.nonempty_of_mem ht''\n        have hâ‚€ : NeBot (nhds_within (range m) x) := Dense.nhds_within_ne_bot x\n        have hâ‚ : { y | (x, y) âˆˆ t' } âˆˆ nhds_within (range m) x :=\n          @mem_inf_of_left Î± ((nhds) x) ((filter.principal) (range m)) _ <| mem_nhds_left x ht'\n        have hâ‚‚ : range m âˆˆ nhds_within (range m) x :=\n          @mem_inf_of_right Î± ((nhds) x) ((filter.principal) (range m)) _ <| Subset.refl _\n        have : { y | (x, y) âˆˆ t' } âˆ© range m âˆˆ nhds_within (range m) x :=\n          @inter_mem Î± (nhds_within (range m) x) _ _ hâ‚ hâ‚‚\n        let âŸ¨y, xyt', b, b_eqâŸ© := hâ‚€.nonempty_of_mem this\n        âŸ¨b, b_eq.symm â–¸ ht'_sub âŸ¨x, hx, xyt'âŸ©âŸ©\n    have : Cauchy g :=\n      âŸ¨â€¹NeBot gâ€º, fun s hs =>\n        let âŸ¨sâ‚, hsâ‚, (comp_sâ‚ : compRel sâ‚ sâ‚ âŠ† s)âŸ© := comp_mem_uniformity_sets hs\n        let âŸ¨sâ‚‚, hsâ‚‚, (comp_sâ‚‚ : compRel sâ‚‚ sâ‚‚ âŠ† sâ‚)âŸ© := comp_mem_uniformity_sets hsâ‚\n        let âŸ¨t, ht, (prod_t : lower_set.prod t t âŠ† sâ‚‚)âŸ© := mem_prod_same_iff.mp (hf.right hsâ‚‚)\n        have hgâ‚ : p (preimage Prod.swap sâ‚) t âˆˆ g := mem_lift (symm_le_uniformity hsâ‚) <| @mem_lift' Î± Î± f _ t ht\n        have hgâ‚‚ : p sâ‚‚ t âˆˆ g := mem_lift hsâ‚‚ <| @mem_lift' Î± Î± f _ t ht\n        have hg : lower_set.prod (p (Â«expr â»Â¹' Â» Prod.swap sâ‚) t) (p sâ‚‚ t) âˆˆ filter.prod g g :=\n          @prod_mem_prod Î± Î± _ _ g g hgâ‚ hgâ‚‚\n        (filter.prod g g).sets_of_superset hg fun âŸ¨a, bâŸ© âŸ¨âŸ¨câ‚, câ‚t, hcâ‚âŸ©, âŸ¨câ‚‚, câ‚‚t, hcâ‚‚âŸ©âŸ© =>\n          have : (câ‚, câ‚‚) âˆˆ lower_set.prod t t := âŸ¨câ‚t, câ‚‚tâŸ©\n          comp_sâ‚ <| prod_mk_mem_compRel hcâ‚ <| comp_sâ‚‚ <| prod_mk_mem_compRel (prod_t this) hcâ‚‚âŸ©\n    have : Cauchy (Filter.comap m g) := â€¹Cauchy gâ€º.comap' (le_of_eq hm.comap_uniformity) â€¹_â€º\n    let âŸ¨x, (hx : map m (Filter.comap m g) â‰¤ (nhds) x)âŸ© := h _ this\n    have : ClusterPt x (map m (Filter.comap m g)) := (le_nhds_iff_adhp_of_cauchy (this.map hm.uniform_continuous)).mp hx\n    have : ClusterPt x g := this.mono map_comap_le\n    âŸ¨x,\n      calc\n        f â‰¤ g := by assumption\n        _ â‰¤ (nhds) x := le_nhds_of_cauchy_adhp â€¹Cauchy gâ€º this\n        âŸ©âŸ©\n#align complete_space_extension completeSpace_extension\n-/\n\n",
 "completeSpace_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒ Â» -/\n#print completeSpace_congr /-\ntheorem completeSpace_congr {e : Â«expr â‰ƒ Â» Î± Î²} (he : UniformEmbedding e) : CompleteSpace Î± â†” CompleteSpace Î² := by\n  rw [completeSpace_iff_isComplete_range he.to_uniform_inducing, e.range_eq_univ, completeSpace_iff_isComplete_univ]\n#align complete_space_congr completeSpace_congr\n-/\n\n",
 "completeSpace_coe_iff_isComplete":
 "#print completeSpace_coe_iff_isComplete /-\ntheorem completeSpace_coe_iff_isComplete {s : Set Î±} : CompleteSpace s â†” IsComplete s :=\n  (completeSpace_iff_isComplete_range uniformEmbedding_subtype_val.to_uniform_inducing).trans <| by\n    rw [Subtype.range_coe]\n#align complete_space_coe_iff_is_complete completeSpace_coe_iff_isComplete\n-/\n\n",
 "completeSpace_coe":
 "#print IsClosed.completeSpace_coe /-\ntheorem IsClosed.completeSpace_coe [CompleteSpace Î±] {s : Set Î±} (hs : IsClosed s) : CompleteSpace s :=\n  hs.is_complete.complete_space_coe\n#align is_closed.complete_space_coe IsClosed.completeSpace_coe\n-/\n\n",
 "comp":
 "#print UniformEmbedding.comp /-\ntheorem UniformEmbedding.comp {g : Î² â†’ Î³} (hg : UniformEmbedding g) {f : Î± â†’ Î²} (hf : UniformEmbedding f) :\n    UniformEmbedding (g âˆ˜ f) :=\n  { hg.to_uniform_inducing.comp hf.to_uniform_inducing with inj := hg.inj.comp hf.inj }\n#align uniform_embedding.comp UniformEmbedding.comp\n-/\n\n",
 "comap_uniformity_of_spaced_out":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print comap_uniformity_of_spaced_out /-\n/-- If a map `f : Î± â†’ Î²` sends any two distinct points to point that are **not** related by a fixed\n`s âˆˆ ğ“¤ Î²`, then `f` is uniform inducing with respect to the discrete uniformity on `Î±`:\nthe preimage of `ğ“¤ Î²` under `prod.map f f` is the principal filter generated by the diagonal in\n`Î± Ã— Î±`. -/\ntheorem comap_uniformity_of_spaced_out {Î±} {f : Î± â†’ Î²} {s : Set (Î² Ã— Î²)} (hs : s âˆˆ (uniformity) Î²)\n    (hf : Pairwise fun x y => (f x, f y) âˆ‰ s) : comap (prod.map f f) ((uniformity) Î²) = (filter.principal) idRel :=\n  by\n  refine' le_antisymm _ (@refl_le_uniformity Î± (UniformSpace.comap f â€¹_â€º))\n  calc\n    comap (prod.map f f) ((uniformity) Î²) â‰¤ comap (prod.map f f) ((filter.principal) s) :=\n      comap_mono (le_principal_iff.2 hs)\n    _ = (filter.principal) (Â«expr â»Â¹' Â» (prod.map f f) s) := comap_principal\n    _ â‰¤ (filter.principal) idRel := principal_mono.2 _\n    \n  rintro âŸ¨x, yâŸ©; simpa [not_imp_not] using @hf x y\n#align comap_uniformity_of_spaced_out comap_uniformity_of_spaced_out\n-/\n\n",
 "comap_uniformSpace":
 "#print UniformInducing.comap_uniformSpace /-\n/-\nCopyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes HÃ¶lzl, SÃ©bastien GouÃ«zel, Patrick Massot\n-/\nprotected theorem UniformInducing.comap_uniformSpace {f : Î± â†’ Î²} (hf : UniformInducing f) :\n    â€¹UniformSpace Î²â€º.comap f = â€¹UniformSpace Î±â€º :=\n  uniformSpace_eq hf.1\n#align uniform_inducing.comap_uniform_space UniformInducing.comap_uniformSpace\n-/\n\n",
 "closure_image_mem_nhds_of_uniformInducing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print closure_image_mem_nhds_of_uniformInducing /-\ntheorem closure_image_mem_nhds_of_uniformInducing {s : Set (Î± Ã— Î±)} {e : Î± â†’ Î²} (b : Î²) (heâ‚ : UniformInducing e)\n    (heâ‚‚ : DenseInducing e) (hs : s âˆˆ (uniformity) Î±) : âˆƒ a, closure (Â«expr '' Â» e { a' | (a, a') âˆˆ s }) âˆˆ (nhds) b :=\n  have : s âˆˆ comap (fun p : Î± Ã— Î± => (e p.1, e p.2)) ((uniformity) Î²) := heâ‚.comap_uniformity.symm â–¸ hs\n  let âŸ¨tâ‚, htâ‚u, htâ‚âŸ© := this\n  have htâ‚ : âˆ€ p : Î± Ã— Î±, (e p.1, e p.2) âˆˆ tâ‚ â†’ p âˆˆ s := htâ‚\n  let âŸ¨tâ‚‚, htâ‚‚u, htâ‚‚s, htâ‚‚câŸ© := comp_symm_of_uniformity htâ‚u\n  let âŸ¨t, htu, hts, htcâŸ© := comp_symm_of_uniformity htâ‚‚u\n  have : preimage e { b' | (b, b') âˆˆ tâ‚‚ } âˆˆ comap e ((nhds) b) := preimage_mem_comap <| mem_nhds_left b htâ‚‚u\n  let âŸ¨a, (ha : (b, e a) âˆˆ tâ‚‚)âŸ© := (heâ‚‚.comap_nhds_ne_bot _).nonempty_of_mem this\n  have :\n    âˆ€ (b') (s' : Set (Î² Ã— Î²)),\n      (b, b') âˆˆ t â†’ s' âˆˆ (uniformity) Î² â†’ ({ y : Î² | (b', y) âˆˆ s' } âˆ© Â«expr '' Â» e { a' : Î± | (a, a') âˆˆ s }).nonempty :=\n    fun b' s' hb' hs' =>\n    have : preimage e { b'' | (b', b'') âˆˆ s' âˆ© t } âˆˆ comap e ((nhds) b') :=\n      preimage_mem_comap <| mem_nhds_left b' <| inter_mem hs' htu\n    let âŸ¨aâ‚‚, haâ‚‚s', haâ‚‚tâŸ© := (heâ‚‚.comap_nhds_ne_bot _).nonempty_of_mem this\n    have : (e a, e aâ‚‚) âˆˆ tâ‚ := htâ‚‚c <| prod_mk_mem_compRel (htâ‚‚s ha) <| htc <| prod_mk_mem_compRel hb' haâ‚‚t\n    have : e aâ‚‚ âˆˆ { b'' : Î² | (b', b'') âˆˆ s' } âˆ© Â«expr '' Â» e { a' | (a, a') âˆˆ s } :=\n      âŸ¨haâ‚‚s', mem_image_of_mem _ <| htâ‚ (a, aâ‚‚) thisâŸ©\n    âŸ¨_, thisâŸ©\n  have : âˆ€ b', (b, b') âˆˆ t â†’ NeBot (Â«expr âŠ“ Â» ((nhds) b') ((filter.principal) (Â«expr '' Â» e { a' | (a, a') âˆˆ s }))) :=\n    by\n    intro b' hb'\n    rw [nhds_eq_uniformity, lift'_inf_principal_eq, lift'_ne_bot_iff]\n    exact fun s => this b' s hb'\n    exact monotone_preimage.inter monotone_const\n  have : âˆ€ b', (b, b') âˆˆ t â†’ b' âˆˆ closure (Â«expr '' Â» e { a' | (a, a') âˆˆ s }) := fun b' hb' => by\n    rw [closure_eq_cluster_pts] <;> exact this b' hb'\n  âŸ¨a, ((nhds) b).sets_of_superset (mem_nhds_left b htu) thisâŸ©\n#align closure_image_mem_nhds_of_uniform_inducing closure_image_mem_nhds_of_uniformInducing\n-/\n\n",
 "closedEmbedding_of_spaced_out":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print closedEmbedding_of_spaced_out /-\ntheorem closedEmbedding_of_spaced_out {Î±} [TopologicalSpace Î±] [DiscreteTopology Î±] [SeparatedSpace Î²] {f : Î± â†’ Î²}\n    {s : Set (Î² Ã— Î²)} (hs : s âˆˆ (uniformity) Î²) (hf : Pairwise fun x y => (f x, f y) âˆ‰ s) : ClosedEmbedding f :=\n  by\n  rcases discrete_topology.eq_bot Î± with rfl; letI : UniformSpace Î± := Â«exprâŠ¥Â»\n  exact { (uniformEmbedding_of_spaced_out hs hf).embedding with closed_range := isClosed_range_of_spaced_out hs hf }\n#align closed_embedding_of_spaced_out closedEmbedding_of_spaced_out\n-/\n\n",
 "cauchy_map_iff":
 "#print UniformInducing.cauchy_map_iff /-\ntheorem UniformInducing.cauchy_map_iff {f : Î± â†’ Î²} (hf : UniformInducing f) {F : Filter Î±} :\n    Cauchy (map f F) â†” Cauchy F := by\n  simp only [Cauchy, map_ne_bot_iff, prod_map_map_eq, map_le_iff_le_comap, â† hf.comap_uniformity]\n#align uniform_inducing.cauchy_map_iff UniformInducing.cauchy_map_iff\n-/\n\n",
 "basis_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n#print UniformInducing.basis_uniformity /-\ntheorem UniformInducing.basis_uniformity {f : Î± â†’ Î²} (hf : UniformInducing f) {Î¹ : Sort _} {p : Î¹ â†’ Prop}\n    {s : Î¹ â†’ Set (Î² Ã— Î²)} (H : ((uniformity) Î²).has_basis p s) :\n    ((uniformity) Î±).has_basis p fun i => Â«expr â»Â¹' Â» (prod.map f f) (s i) :=\n  hf.1 â–¸ H.comap _\n#align uniform_inducing.basis_uniformity UniformInducing.basis_uniformity\n-/\n\n"}