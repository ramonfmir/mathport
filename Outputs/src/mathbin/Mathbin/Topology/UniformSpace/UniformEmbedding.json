{"uniformly_extend_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\ntheorem uniformly_extend_unique {g : α → γ} (hg : ∀ b, g (e b) = f b) (hc : continuous g) : exprψ = g :=\n  dense_inducing.extend_unique _ hg hc\n#align uniformly_extend_unique uniformly_extend_unique\n\n",
 "uniformly_extend_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\ntheorem uniformly_extend_spec [complete_space γ] (a : α) : tendsto f (comap e ((nhds) a)) ((nhds) ((exprψ) a)) := by\n  simpa only [dense_inducing.extend] using tendsto_nhds_lim (uniformly_extend_exists h_e ‹_› h_f _)\n#align uniformly_extend_spec uniformly_extend_spec\n\n",
 "uniformly_extend_of_ind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\ntheorem uniformly_extend_of_ind (b : β) : (exprψ) (e b) = f b :=\n  dense_inducing.extend_eq_at _ h_f.continuous.continuous_at\n#align uniformly_extend_of_ind uniformly_extend_of_ind\n\n",
 "uniformly_extend_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem uniformly_extend_exists [complete_space γ] (a : α) : ∃ c, tendsto f (comap e ((nhds) a)) ((nhds) c) :=\n  let de := h_e.dense_inducing h_dense\n  have : cauchy ((nhds) a) := cauchy_nhds\n  have : cauchy (comap e ((nhds) a)) := this.comap' (le_of_eq h_e.comap_uniformity) (de.comap_nhds_ne_bot _)\n  have : cauchy (map f (comap e ((nhds) a))) := this.map h_f\n  complete_space.complete this\n#align uniformly_extend_exists uniformly_extend_exists\n\n",
 "uniform_inducing_of_compose":
 "theorem uniform_inducing_of_compose {f : α → β} {g : β → γ} (hf : uniform_continuous f) (hg : uniform_continuous g)\n    (hgf : uniform_inducing (g ∘ f)) : uniform_inducing f :=\n  by\n  refine' ⟨le_antisymm _ hf.le_comap⟩\n  rw [← hgf.1, ← prod.map_def, ← prod.map_def, ← prod.map_comp_map f f g g, ← @comap_comap _ _ _ _ (prod.map f f)]\n  exact comap_mono hg.le_comap\n#align uniform_inducing_of_compose uniform_inducing_of_compose\n\n",
 "uniform_inducing_id":
 "theorem uniform_inducing_id : uniform_inducing (@id α) :=\n  ⟨by rw [← prod.map_def, prod.map_id, comap_id]⟩\n#align uniform_inducing_id uniform_inducing_id\n\n",
 "uniform_extend_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem uniform_extend_subtype [complete_space γ] {p : α → Prop} {e : α → β} {f : α → γ} {b : β} {s : set α}\n    (hf : uniform_continuous fun x : subtype p => f x.val) (he : uniform_embedding e)\n    (hd : ∀ x : β, x ∈ closure (range e)) (hb : closure («expr '' » e s) ∈ (nhds) b) (hs : is_closed s)\n    (hp : ∀ x ∈ s, p x) : ∃ c, tendsto f (comap e ((nhds) b)) ((nhds) c) :=\n  by\n  have de : dense_embedding e := he.dense_embedding hd\n  have de' : dense_embedding (dense_embedding.subtype_emb p e) := de.subtype p\n  have ue' : uniform_embedding (dense_embedding.subtype_emb p e) := uniform_embedding_subtype_emb _ he de\n  have : b ∈ closure («expr '' » e { x | p x }) := (closure_mono <| monotone_image <| hp) (mem_of_mem_nhds hb)\n  let ⟨c, (hc : tendsto (f ∘ subtype.val) (comap (dense_embedding.subtype_emb p e) ((nhds) ⟨b, this⟩)) ((nhds) c))⟩ :=\n    uniformly_extend_exists ue'.to_uniform_inducing de'.dense hf _\n  rw [nhds_subtype_eq_comap] at hc\n  simp [comap_comap] at hc\n  change tendsto (f ∘ @subtype.val α p) (comap (e ∘ @subtype.val α p) ((nhds) b)) ((nhds) c) at hc\n  rw [← comap_comap, tendsto_comap'_iff] at hc\n  exact ⟨c, hc⟩\n  exact\n    ⟨_, hb, fun x => by\n      change e x ∈ closure («expr '' » e s) → x ∈ range subtype.val\n      rw [← closure_induced, mem_closure_iff_cluster_pt, cluster_pt, ne_bot_iff, nhds_induced, ←\n        de.to_dense_inducing.nhds_eq_comap, ← mem_closure_iff_nhds_ne_bot, hs.closure_eq]\n      exact fun hxs => ⟨⟨x, hp x hxs⟩, rfl⟩⟩\n#align uniform_extend_subtype uniform_extend_subtype\n\n",
 "uniform_embedding_subtype_val":
 "theorem uniform_embedding_subtype_val {p : α → Prop} : uniform_embedding (subtype.val : subtype p → α) :=\n  { comap_uniformity := rfl\n    inj := subtype.val_injective }\n#align uniform_embedding_subtype_val uniform_embedding_subtype_val\n\n",
 "uniform_embedding_subtype_emb":
 "theorem uniform_embedding_subtype_emb (p : α → Prop) {e : α → β} (ue : uniform_embedding e) (de : dense_embedding e) :\n    uniform_embedding (dense_embedding.subtype_emb p e) :=\n  { comap_uniformity := by\n      simp [comap_comap, (· ∘ ·), dense_embedding.subtype_emb, uniformity_subtype, ue.comap_uniformity.symm]\n    inj := (de.subtype p).inj }\n#align uniform_embedding_subtype_emb uniform_embedding_subtype_emb\n\n",
 "uniform_embedding_subtype_coe":
 "theorem uniform_embedding_subtype_coe {p : α → Prop} : uniform_embedding (coe : subtype p → α) :=\n  uniform_embedding_subtype_val\n#align uniform_embedding_subtype_coe uniform_embedding_subtype_coe\n\n",
 "uniform_embedding_set_inclusion":
 "theorem uniform_embedding_set_inclusion {s t : set α} (hst : s ⊆ t) : uniform_embedding (inclusion hst) :=\n  { comap_uniformity := by\n      erw [uniformity_subtype, uniformity_subtype, comap_comap]\n      congr\n    inj := inclusion_injective hst }\n#align uniform_embedding_set_inclusion uniform_embedding_set_inclusion\n\n",
 "uniform_embedding_of_spaced_out":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- If a map `f : α → β` sends any two distinct points to point that are **not** related by a fixed\n`s ∈ 𝓤 β`, then `f` is a uniform embedding with respect to the discrete uniformity on `α`. -/\ntheorem uniform_embedding_of_spaced_out {α} {f : α → β} {s : set (β × β)} (hs : s ∈ (uniformity) β)\n    (hf : Pairwise fun x y => (f x, f y) ∉ s) : @uniform_embedding α β («expr⊥») ‹_› f :=\n  by\n  letI : uniform_space α := «expr⊥»; haveI : separated_space α := separated_iff_t2.2 infer_instance\n  exact uniform_inducing.uniform_embedding ⟨comap_uniformity_of_spaced_out hs hf⟩\n#align uniform_embedding_of_spaced_out uniform_embedding_of_spaced_out\n\n",
 "uniform_embedding_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem uniform_embedding_inr : uniform_embedding (sum.inr : β → Sum α β) :=\n  by\n  apply uniform_embedding_def.2 ⟨sum.inr_injective, fun s => ⟨_, _⟩⟩\n  · intro hs\n    refine'\n      ⟨«expr '' » (fun p : α × α => (sum.inl p.1, sum.inl p.2)) univ ∪\n          «expr '' » (fun p : β × β => (sum.inr p.1, sum.inr p.2)) s,\n        _, _⟩\n    · exact union_mem_uniformity_sum univ_mem hs\n    · simp\n  · rintro ⟨t, ht, h't⟩\n    simp only [sum.uniformity, mem_sup, mem_map] at ht\n    apply filter.mem_of_superset ht.2\n    rintro ⟨x, y⟩ hx\n    exact h't _ _ hx\n#align uniform_embedding_inr uniform_embedding_inr\n\n",
 "uniform_embedding_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem uniform_embedding_inl : uniform_embedding (sum.inl : α → Sum α β) :=\n  by\n  apply uniform_embedding_def.2 ⟨sum.inl_injective, fun s => ⟨_, _⟩⟩\n  · intro hs\n    refine'\n      ⟨«expr '' » (fun p : α × α => (sum.inl p.1, sum.inl p.2)) s ∪\n          «expr '' » (fun p : β × β => (sum.inr p.1, sum.inr p.2)) univ,\n        _, _⟩\n    · exact union_mem_uniformity_sum hs univ_mem\n    · simp\n  · rintro ⟨t, ht, h't⟩\n    simp only [sum.uniformity, mem_sup, mem_map] at ht\n    apply filter.mem_of_superset ht.1\n    rintro ⟨x, y⟩ hx\n    exact h't _ _ hx\n#align uniform_embedding_inl uniform_embedding_inl\n\n",
 "uniform_embedding_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniform_embedding_def' {f : α → β} :\n    uniform_embedding f ↔\n      function.injective f ∧\n        uniform_continuous f ∧ ∀ s, s ∈ (uniformity) α → ∃ t ∈ (uniformity) β, ∀ x y : α, (f x, f y) ∈ t → (x, y) ∈ s :=\n  by\n  simp only [uniform_embedding_def, uniform_continuous_def] <;>\n    exact\n      ⟨fun ⟨I, H⟩ => ⟨I, fun s su => (H _).2 ⟨s, su, fun x y => id⟩, fun s => (H s).1⟩, fun ⟨I, H₁, H₂⟩ =>\n        ⟨I, fun s => ⟨H₂ s, fun ⟨t, tu, h⟩ => mem_of_superset (H₁ t tu) fun ⟨a, b⟩ => h a b⟩⟩⟩\n#align uniform_embedding_def' uniform_embedding_def'\n\n",
 "uniform_embedding_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniform_embedding_def {f : α → β} :\n    uniform_embedding f ↔\n      function.injective f ∧ ∀ s, s ∈ (uniformity) α ↔ ∃ t ∈ (uniformity) β, ∀ x y : α, (f x, f y) ∈ t → (x, y) ∈ s :=\n  by\n  constructor\n  · rintro ⟨⟨h⟩, h'⟩\n    rw [eq_comm, filter.ext_iff] at h\n    simp [*, subset_def]\n  · rintro ⟨h, h'⟩\n    refine' uniform_embedding.mk ⟨_⟩ h\n    rw [eq_comm, filter.ext_iff]\n    simp [*, subset_def]\n#align uniform_embedding_def uniform_embedding_def\n\n",
 "uniform_embedding_comap":
 "theorem uniform_embedding_comap {α : Type _} {β : Type _} {f : α → β} [u : uniform_space β]\n    (hf : function.injective f) : @uniform_embedding α β (uniform_space.comap f u) u f :=\n  @uniform_embedding.mk _ _ (uniform_space.comap f u) _ _ (@uniform_inducing.mk _ _ (uniform_space.comap f u) _ _ rfl)\n    hf\n#align uniform_embedding_comap uniform_embedding_comap\n\n",
 "uniform_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- If the domain of a `uniform_inducing` map `f` is a `separated_space`, then `f` is injective,\nhence it is a `uniform_embedding`. -/\nprotected theorem uniform_inducing.uniform_embedding [separated_space α] {f : α → β} (hf : uniform_inducing f) :\n    uniform_embedding f :=\n  ⟨hf, fun x y h =>\n    eq_of_uniformity_basis (hf.basis_uniformity ((uniformity) β).basis_sets) fun s hs =>\n      mem_preimage.2 <| mem_uniformity_of_eq hs h⟩\n#align uniform_inducing.uniform_embedding uniform_inducing.uniform_embedding\n\n",
 "uniform_continuous_uniformly_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprψ -/\ntheorem uniform_continuous_uniformly_extend [cγ : complete_space γ] : uniform_continuous (exprψ) := fun d hd =>\n  let ⟨s, hs, hs_comp⟩ :=\n    (mem_lift'_sets <| monotone_comp_rel monotone_id <| monotone_comp_rel monotone_id monotone_id).mp\n      (comp_le_uniformity3 hd)\n  have h_pnt : ∀ {a m}, m ∈ (nhds) a → ∃ c, c ∈ «expr '' » f (preimage e m) ∧ (c, (exprψ) a) ∈ s ∧ ((exprψ) a, c) ∈ s :=\n    fun a m hm =>\n    have nb : ne_bot (map f (comap e ((nhds) a))) := ((h_e.dense_inducing h_dense).comap_nhds_ne_bot _).map _\n    have :\n      «expr '' » f (preimage e m) ∩ ({ c | (c, (exprψ) a) ∈ s } ∩ { c | ((exprψ) a, c) ∈ s }) ∈\n        map f (comap e ((nhds) a)) :=\n      inter_mem (image_mem_map <| preimage_mem_comap <| hm)\n        (uniformly_extend_spec h_e h_dense h_f _ (inter_mem (mem_nhds_right _ hs) (mem_nhds_left _ hs)))\n    nb.nonempty_of_mem this\n  have : preimage (fun p : β × β => (f p.1, f p.2)) s ∈ (uniformity) β := h_f hs\n  have : preimage (fun p : β × β => (f p.1, f p.2)) s ∈ comap (fun x : β × β => (e x.1, e x.2)) ((uniformity) α) := by\n    rwa [h_e.comap_uniformity.symm] at this\n  let ⟨t, ht, ts⟩ := this\n  show preimage (fun p : α × α => ((exprψ) p.1, (exprψ) p.2)) d ∈ (uniformity) α from\n    ((uniformity) α).sets_of_superset (interior_mem_uniformity ht) fun ⟨x₁, x₂⟩ hx_t =>\n      have : (nhds) (x₁, x₂) ≤ (filter.principal) (interior t) := is_open_iff_nhds.mp is_open_interior (x₁, x₂) hx_t\n      have : interior t ∈ filter.prod ((nhds) x₁) ((nhds) x₂) := by rwa [nhds_prod_eq, le_principal_iff] at this\n      let ⟨m₁, hm₁, m₂, hm₂, (hm : lower_set.prod m₁ m₂ ⊆ interior t)⟩ := mem_prod_iff.mp this\n      let ⟨a, ha₁, _, ha₂⟩ := h_pnt hm₁\n      let ⟨b, hb₁, hb₂, _⟩ := h_pnt hm₂\n      have : lower_set.prod («expr ⁻¹' » e m₁) («expr ⁻¹' » e m₂) ⊆ «expr ⁻¹' » (fun p : β × β => (f p.1, f p.2)) s :=\n        calc\n          _ ⊆ preimage (fun p : β × β => (e p.1, e p.2)) (interior t) := preimage_mono hm\n          _ ⊆ preimage (fun p : β × β => (e p.1, e p.2)) t := preimage_mono interior_subset\n          _ ⊆ preimage (fun p : β × β => (f p.1, f p.2)) s := ts\n          \n      have : lower_set.prod («expr '' » f («expr ⁻¹' » e m₁)) («expr '' » f («expr ⁻¹' » e m₂)) ⊆ s :=\n        calc\n          lower_set.prod («expr '' » f («expr ⁻¹' » e m₁)) («expr '' » f («expr ⁻¹' » e m₂)) =\n              «expr '' » (fun p : β × β => (f p.1, f p.2)) (lower_set.prod («expr ⁻¹' » e m₁) («expr ⁻¹' » e m₂)) :=\n            prod_image_image_eq\n          _ ⊆ «expr '' » (fun p : β × β => (f p.1, f p.2)) («expr ⁻¹' » (fun p : β × β => (f p.1, f p.2)) s) :=\n            monotone_image this\n          _ ⊆ s := image_preimage_subset _ _\n          \n      have : (a, b) ∈ s := @this (a, b) ⟨ha₁, hb₁⟩\n      hs_comp <| show ((exprψ) x₁, (exprψ) x₂) ∈ comp_rel s (comp_rel s s) from ⟨a, ha₂, ⟨b, this, hb₂⟩⟩\n#align uniform_continuous_uniformly_extend uniform_continuous_uniformly_extend\n\n",
 "uniform_continuous_iff":
 "theorem uniform_inducing.uniform_continuous_iff {f : α → β} {g : β → γ} (hg : uniform_inducing g) :\n    uniform_continuous f ↔ uniform_continuous (g ∘ f) :=\n  by\n  dsimp only [uniform_continuous, tendsto]\n  rw [← hg.comap_uniformity, ← map_le_iff_le_comap, filter.map_map]\n#align uniform_inducing.uniform_continuous_iff uniform_inducing.uniform_continuous_iff\n\n",
 "uniform_continuous":
 "theorem uniform_inducing.uniform_continuous {f : α → β} (hf : uniform_inducing f) : uniform_continuous f := by\n  simp [uniform_continuous, hf.comap_uniformity.symm, tendsto_comap]\n#align uniform_inducing.uniform_continuous uniform_inducing.uniform_continuous\n\n",
 "totally_bounded_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem totally_bounded_preimage {f : α → β} {s : set β} (hf : uniform_embedding f) (hs : totally_bounded s) :\n    totally_bounded («expr ⁻¹' » f s) := fun t ht =>\n  by\n  rw [← hf.comap_uniformity] at ht\n  rcases mem_comap.2 ht with ⟨t', ht', ts⟩\n  rcases totally_bounded_iff_subset.1 (totally_bounded_subset (image_preimage_subset f s) hs) _ ht' with\n    ⟨c, cs, hfc, hct⟩\n  refine' ⟨«expr ⁻¹' » f c, hfc.preimage (hf.inj.inj_on _), fun x h => _⟩\n  have := hct (mem_image_of_mem f h); simp at this⊢\n  rcases this with ⟨z, zc, zt⟩\n  rcases cs zc with ⟨y, yc, rfl⟩\n  exact ⟨y, zc, ts zt⟩\n#align totally_bounded_preimage totally_bounded_preimage\n\n",
 "to_uniform_embedding":
 "theorem embedding.to_uniform_embedding {α β} [topological_space α] [u : uniform_space β] (f : α → β) (h : embedding f) :\n    @uniform_embedding α β (h.comap_uniform_space f) u f :=\n  { comap_uniformity := rfl\n    inj := h.inj }\n#align embedding.to_uniform_embedding embedding.to_uniform_embedding\n\n",
 "prod":
 "theorem uniform_embedding.prod {α' : Type _} {β' : Type _} [uniform_space α'] [uniform_space β'] {e₁ : α → α'}\n    {e₂ : β → β'} (h₁ : uniform_embedding e₁) (h₂ : uniform_embedding e₂) :\n    uniform_embedding fun p : α × β => (e₁ p.1, e₂ p.2) :=\n  { h₁.to_uniform_inducing.prod h₂.to_uniform_inducing with inj := h₁.inj.prod_map h₂.inj }\n#align uniform_embedding.prod uniform_embedding.prod\n\n",
 "mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Sébastien Gouëzel, Patrick Massot\n-/\ntheorem uniform_inducing.mk' {f : α → β}\n    (h : ∀ s, s ∈ (uniformity) α ↔ ∃ t ∈ (uniformity) β, ∀ x y : α, (f x, f y) ∈ t → (x, y) ∈ s) : uniform_inducing f :=\n  ⟨by simp [eq_comm, filter.ext_iff, subset_def, h]⟩\n#align uniform_inducing.mk' uniform_inducing.mk'\n\n",
 "is_complete_range":
 "theorem uniform_inducing.is_complete_range [complete_space α] {f : α → β} (hf : uniform_inducing f) :\n    is_complete (range f) :=\n  (complete_space_iff_is_complete_range hf).1 ‹_›\n#align uniform_inducing.is_complete_range uniform_inducing.is_complete_range\n\n",
 "is_complete_of_complete_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_complete_of_complete_image {m : α → β} {s : set α} (hm : uniform_inducing m)\n    (hs : is_complete («expr '' » m s)) : is_complete s :=\n  by\n  intro f hf hfs\n  rw [le_principal_iff] at hfs\n  obtain ⟨_, ⟨x, hx, rfl⟩, hyf⟩ : ∃ y ∈ «expr '' » m s, map m f ≤ (nhds) y\n  exact hs (f.map m) (hf.map hm.uniform_continuous) (le_principal_iff.2 (image_mem_map hfs))\n  rw [map_le_iff_le_comap, ← nhds_induced, ← hm.inducing.induced] at hyf\n  exact ⟨x, hx, hyf⟩\n#align is_complete_of_complete_image is_complete_of_complete_image\n\n",
 "is_complete_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A set is complete iff its image under a uniform inducing map is complete. -/\ntheorem is_complete_image_iff {m : α → β} {s : set α} (hm : uniform_inducing m) :\n    is_complete («expr '' » m s) ↔ is_complete s :=\n  by\n  refine' ⟨is_complete_of_complete_image hm, fun c => _⟩\n  haveI : complete_space s := c.complete_space_coe\n  set m' : s → β := m ∘ coe\n  suffices is_complete (range m') by rwa [range_comp, Subtype.range_coe] at this\n  have hm' : uniform_inducing m' := hm.comp uniform_embedding_subtype_coe.to_uniform_inducing\n  intro f hf hfm\n  rw [filter.le_principal_iff] at hfm\n  have cf' : cauchy (comap m' f) := hf.comap' hm'.comap_uniformity.le (ne_bot.comap_of_range_mem hf.1 hfm)\n  rcases complete_space.complete cf' with ⟨x, hx⟩\n  rw [hm'.inducing.nhds_eq_comap, comap_le_comap_iff hfm] at hx\n  use m' x, mem_range_self _, hx\n#align is_complete_image_iff is_complete_image_iff\n\n",
 "inducing":
 "theorem uniform_inducing.inducing {f : α → β} (h : uniform_inducing f) : inducing f :=\n  by\n  refine' ⟨eq_of_nhds_eq_nhds fun a => _⟩\n  rw [nhds_induced, nhds_eq_uniformity, nhds_eq_uniformity, ← h.comap_uniformity, comap_lift'_eq, comap_lift'_eq2]\n  exacts[rfl, monotone_preimage]\n#align uniform_inducing.inducing uniform_inducing.inducing\n\n",
 "embedding":
 "theorem uniform_embedding.embedding {f : α → β} (h : uniform_embedding f) : embedding f :=\n  { induced := h.to_uniform_inducing.inducing.induced\n    inj := h.inj }\n#align uniform_embedding.embedding uniform_embedding.embedding\n\n",
 "dense_inducing":
 "theorem uniform_inducing.dense_inducing {f : α → β} (h : uniform_inducing f) (hd : dense_range f) : dense_inducing f :=\n  { dense := hd\n    induced := h.inducing.induced }\n#align uniform_inducing.dense_inducing uniform_inducing.dense_inducing\n\n",
 "dense_embedding":
 "theorem uniform_embedding.dense_embedding {f : α → β} (h : uniform_embedding f) (hd : dense_range f) :\n    dense_embedding f :=\n  { dense := hd\n    inj := h.inj\n    induced := h.embedding.induced }\n#align uniform_embedding.dense_embedding uniform_embedding.dense_embedding\n\n",
 "complete_space_iff_is_complete_range":
 "theorem complete_space_iff_is_complete_range {f : α → β} (hf : uniform_inducing f) :\n    complete_space α ↔ is_complete (range f) := by\n  rw [complete_space_iff_is_complete_univ, ← is_complete_image_iff hf, image_univ]\n#align complete_space_iff_is_complete_range complete_space_iff_is_complete_range\n\n",
 "complete_space_extension":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem complete_space_extension {m : β → α} (hm : uniform_inducing m) (dense : dense_range m)\n    (h : ∀ f : filter β, cauchy f → ∃ x : α, map m f ≤ (nhds) x) : complete_space α :=\n  ⟨fun f : filter α => fun hf : cauchy f =>\n    let p : set (α × α) → set α → set α := fun s t => { y : α | ∃ x : α, x ∈ t ∧ (x, y) ∈ s }\n    let g := ((uniformity) α).lift fun s => f.lift' (p s)\n    have mp₀ : monotone p := fun a b h t s ⟨x, xs, xa⟩ => ⟨x, xs, h xa⟩\n    have mp₁ : ∀ {s}, monotone (p s) := fun s a b h x ⟨y, ya, yxs⟩ => ⟨y, h ya, yxs⟩\n    have : f ≤ g :=\n      le_infᵢ fun s =>\n        le_infᵢ fun hs =>\n          le_infᵢ fun t =>\n            le_infᵢ fun ht => le_principal_iff.mpr <| mem_of_superset ht fun x hx => ⟨x, hx, refl_mem_uniformity hs⟩\n    have : ne_bot g := hf.left.mono this\n    have : ne_bot (comap m g) :=\n      comap_ne_bot fun t ht =>\n        let ⟨t', ht', ht_mem⟩ := (mem_lift_sets <| monotone_lift' monotone_const mp₀).mp ht\n        let ⟨t'', ht'', ht'_sub⟩ := (mem_lift'_sets mp₁).mp ht_mem\n        let ⟨x, (hx : x ∈ t'')⟩ := hf.left.nonempty_of_mem ht''\n        have h₀ : ne_bot (nhds_within (range m) x) := dense.nhds_within_ne_bot x\n        have h₁ : { y | (x, y) ∈ t' } ∈ nhds_within (range m) x :=\n          @mem_inf_of_left α ((nhds) x) ((filter.principal) (range m)) _ <| mem_nhds_left x ht'\n        have h₂ : range m ∈ nhds_within (range m) x :=\n          @mem_inf_of_right α ((nhds) x) ((filter.principal) (range m)) _ <| Subset.refl _\n        have : { y | (x, y) ∈ t' } ∩ range m ∈ nhds_within (range m) x :=\n          @inter_mem α (nhds_within (range m) x) _ _ h₁ h₂\n        let ⟨y, xyt', b, b_eq⟩ := h₀.nonempty_of_mem this\n        ⟨b, b_eq.symm ▸ ht'_sub ⟨x, hx, xyt'⟩⟩\n    have : cauchy g :=\n      ⟨‹ne_bot g›, fun s hs =>\n        let ⟨s₁, hs₁, (comp_s₁ : comp_rel s₁ s₁ ⊆ s)⟩ := comp_mem_uniformity_sets hs\n        let ⟨s₂, hs₂, (comp_s₂ : comp_rel s₂ s₂ ⊆ s₁)⟩ := comp_mem_uniformity_sets hs₁\n        let ⟨t, ht, (prod_t : lower_set.prod t t ⊆ s₂)⟩ := mem_prod_same_iff.mp (hf.right hs₂)\n        have hg₁ : p (preimage prod.swap s₁) t ∈ g := mem_lift (symm_le_uniformity hs₁) <| @mem_lift' α α f _ t ht\n        have hg₂ : p s₂ t ∈ g := mem_lift hs₂ <| @mem_lift' α α f _ t ht\n        have hg : lower_set.prod (p («expr ⁻¹' » prod.swap s₁) t) (p s₂ t) ∈ filter.prod g g :=\n          @prod_mem_prod α α _ _ g g hg₁ hg₂\n        (filter.prod g g).sets_of_superset hg fun ⟨a, b⟩ ⟨⟨c₁, c₁t, hc₁⟩, ⟨c₂, c₂t, hc₂⟩⟩ =>\n          have : (c₁, c₂) ∈ lower_set.prod t t := ⟨c₁t, c₂t⟩\n          comp_s₁ <| prod_mk_mem_comp_rel hc₁ <| comp_s₂ <| prod_mk_mem_comp_rel (prod_t this) hc₂⟩\n    have : cauchy (filter.comap m g) := ‹cauchy g›.comap' (le_of_eq hm.comap_uniformity) ‹_›\n    let ⟨x, (hx : map m (filter.comap m g) ≤ (nhds) x)⟩ := h _ this\n    have : cluster_pt x (map m (filter.comap m g)) :=\n      (le_nhds_iff_adhp_of_cauchy (this.map hm.uniform_continuous)).mp hx\n    have : cluster_pt x g := this.mono map_comap_le\n    ⟨x,\n      calc\n        f ≤ g := by assumption\n        _ ≤ (nhds) x := le_nhds_of_cauchy_adhp ‹cauchy g› this\n        ⟩⟩\n#align complete_space_extension complete_space_extension\n\n",
 "complete_space_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem complete_space_congr {e : «expr ≃ » α β} (he : uniform_embedding e) : complete_space α ↔ complete_space β := by\n  rw [complete_space_iff_is_complete_range he.to_uniform_inducing, e.range_eq_univ, complete_space_iff_is_complete_univ]\n#align complete_space_congr complete_space_congr\n\n",
 "complete_space_coe_iff_is_complete":
 "theorem complete_space_coe_iff_is_complete {s : set α} : complete_space s ↔ is_complete s :=\n  (complete_space_iff_is_complete_range uniform_embedding_subtype_coe.to_uniform_inducing).trans <| by\n    rw [Subtype.range_coe]\n#align complete_space_coe_iff_is_complete complete_space_coe_iff_is_complete\n\n",
 "complete_space_coe":
 "theorem is_closed.complete_space_coe [complete_space α] {s : set α} (hs : is_closed s) : complete_space s :=\n  hs.is_complete.complete_space_coe\n#align is_closed.complete_space_coe is_closed.complete_space_coe\n\n",
 "comp":
 "theorem uniform_embedding.comp {g : β → γ} (hg : uniform_embedding g) {f : α → β} (hf : uniform_embedding f) :\n    uniform_embedding (g ∘ f) :=\n  { hg.to_uniform_inducing.comp hf.to_uniform_inducing with inj := hg.inj.comp hf.inj }\n#align uniform_embedding.comp uniform_embedding.comp\n\n",
 "comap_uniformity_of_spaced_out":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/-- If a map `f : α → β` sends any two distinct points to point that are **not** related by a fixed\n`s ∈ 𝓤 β`, then `f` is uniform inducing with respect to the discrete uniformity on `α`:\nthe preimage of `𝓤 β` under `prod.map f f` is the principal filter generated by the diagonal in\n`α × α`. -/\ntheorem comap_uniformity_of_spaced_out {α} {f : α → β} {s : set (β × β)} (hs : s ∈ (uniformity) β)\n    (hf : Pairwise fun x y => (f x, f y) ∉ s) : comap (prod.map f f) ((uniformity) β) = (filter.principal) id_rel :=\n  by\n  refine' le_antisymm _ (@refl_le_uniformity α (uniform_space.comap f ‹_›))\n  calc\n    comap (prod.map f f) ((uniformity) β) ≤ comap (prod.map f f) ((filter.principal) s) :=\n      comap_mono (le_principal_iff.2 hs)\n    _ = (filter.principal) («expr ⁻¹' » (prod.map f f) s) := comap_principal\n    _ ≤ (filter.principal) id_rel := principal_mono.2 _\n    \n  rintro ⟨x, y⟩; simpa [not_imp_not] using @hf x y\n#align comap_uniformity_of_spaced_out comap_uniformity_of_spaced_out\n\n",
 "closure_image_mem_nhds_of_uniform_inducing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem closure_image_mem_nhds_of_uniform_inducing {s : set (α × α)} {e : α → β} (b : β) (he₁ : uniform_inducing e)\n    (he₂ : dense_inducing e) (hs : s ∈ (uniformity) α) : ∃ a, closure («expr '' » e { a' | (a, a') ∈ s }) ∈ (nhds) b :=\n  have : s ∈ comap (fun p : α × α => (e p.1, e p.2)) ((uniformity) β) := he₁.comap_uniformity.symm ▸ hs\n  let ⟨t₁, ht₁u, ht₁⟩ := this\n  have ht₁ : ∀ p : α × α, (e p.1, e p.2) ∈ t₁ → p ∈ s := ht₁\n  let ⟨t₂, ht₂u, ht₂s, ht₂c⟩ := comp_symm_of_uniformity ht₁u\n  let ⟨t, htu, hts, htc⟩ := comp_symm_of_uniformity ht₂u\n  have : preimage e { b' | (b, b') ∈ t₂ } ∈ comap e ((nhds) b) := preimage_mem_comap <| mem_nhds_left b ht₂u\n  let ⟨a, (ha : (b, e a) ∈ t₂)⟩ := (he₂.comap_nhds_ne_bot _).nonempty_of_mem this\n  have :\n    ∀ (b') (s' : set (β × β)),\n      (b, b') ∈ t → s' ∈ (uniformity) β → ({ y : β | (b', y) ∈ s' } ∩ «expr '' » e { a' : α | (a, a') ∈ s }).nonempty :=\n    fun b' s' hb' hs' =>\n    have : preimage e { b'' | (b', b'') ∈ s' ∩ t } ∈ comap e ((nhds) b') :=\n      preimage_mem_comap <| mem_nhds_left b' <| inter_mem hs' htu\n    let ⟨a₂, ha₂s', ha₂t⟩ := (he₂.comap_nhds_ne_bot _).nonempty_of_mem this\n    have : (e a, e a₂) ∈ t₁ := ht₂c <| prod_mk_mem_comp_rel (ht₂s ha) <| htc <| prod_mk_mem_comp_rel hb' ha₂t\n    have : e a₂ ∈ { b'' : β | (b', b'') ∈ s' } ∩ «expr '' » e { a' | (a, a') ∈ s } :=\n      ⟨ha₂s', mem_image_of_mem _ <| ht₁ (a, a₂) this⟩\n    ⟨_, this⟩\n  have : ∀ b', (b, b') ∈ t → ne_bot («expr ⊓ » ((nhds) b') ((filter.principal) («expr '' » e { a' | (a, a') ∈ s }))) :=\n    by\n    intro b' hb'\n    rw [nhds_eq_uniformity, lift'_inf_principal_eq, lift'_ne_bot_iff]\n    exact fun s => this b' s hb'\n    exact monotone_preimage.inter monotone_const\n  have : ∀ b', (b, b') ∈ t → b' ∈ closure («expr '' » e { a' | (a, a') ∈ s }) := fun b' hb' => by\n    rw [closure_eq_cluster_pts] <;> exact this b' hb'\n  ⟨a, ((nhds) b).sets_of_superset (mem_nhds_left b htu) this⟩\n#align closure_image_mem_nhds_of_uniform_inducing closure_image_mem_nhds_of_uniform_inducing\n\n",
 "closed_embedding_of_spaced_out":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem closed_embedding_of_spaced_out {α} [topological_space α] [discrete_topology α] [separated_space β] {f : α → β}\n    {s : set (β × β)} (hs : s ∈ (uniformity) β) (hf : Pairwise fun x y => (f x, f y) ∉ s) : closed_embedding f :=\n  by\n  rcases discrete_topology.eq_bot α with rfl; letI : uniform_space α := «expr⊥»\n  exact { (uniform_embedding_of_spaced_out hs hf).embedding with closed_range := is_closed_range_of_spaced_out hs hf }\n#align closed_embedding_of_spaced_out closed_embedding_of_spaced_out\n\n",
 "cauchy_map_iff":
 "theorem uniform_inducing.cauchy_map_iff {f : α → β} (hf : uniform_inducing f) {F : filter α} :\n    cauchy (map f F) ↔ cauchy F := by\n  simp only [cauchy, map_ne_bot_iff, prod_map_map_eq, map_le_iff_le_comap, ← hf.comap_uniformity]\n#align uniform_inducing.cauchy_map_iff uniform_inducing.cauchy_map_iff\n\n",
 "basis_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem uniform_inducing.basis_uniformity {f : α → β} (hf : uniform_inducing f) {ι : Sort _} {p : ι → Prop}\n    {s : ι → set (β × β)} (H : ((uniformity) β).has_basis p s) :\n    ((uniformity) α).has_basis p fun i => «expr ⁻¹' » (prod.map f f) (s i) :=\n  hf.1 ▸ H.comap _\n#align uniform_inducing.basis_uniformity uniform_inducing.basis_uniformity\n\n"}