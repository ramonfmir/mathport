{"union_mem_uniformity_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print union_mem_uniformity_sum /-\n/-- The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\nof the diagonal. -/\ntheorem union_mem_uniformity_sum {a : Set (α × α)} (ha : a ∈ (uniformity) α) {b : Set (β × β)}\n    (hb : b ∈ (uniformity) β) :\n    «expr '' » (fun p : α × α => (inl p.1, inl p.2)) a ∪ «expr '' » (fun p : β × β => (inr p.1, inr p.2)) b ∈\n      (@UniformSpace.Core.sum α β _ _).uniformity :=\n  ⟨mem_map_iff_exists_image.2 ⟨_, ha, subset_union_left _ _⟩,\n    mem_map_iff_exists_image.2 ⟨_, hb, subset_union_right _ _⟩⟩\n#align union_mem_uniformity_sum union_mem_uniformity_sum\n-/\n\n",
 "uniformity_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.Tendsto.uniformity_trans /-\n/-- Relation `λ f g, tendsto (λ x, (f x, g x)) l (𝓤 α)` is transitive. -/\ntheorem Filter.Tendsto.uniformity_trans {l : Filter β} {f₁ f₂ f₃ : β → α}\n    (h₁₂ : Tendsto (fun x => (f₁ x, f₂ x)) l ((uniformity) α))\n    (h₂₃ : Tendsto (fun x => (f₂ x, f₃ x)) l ((uniformity) α)) : Tendsto (fun x => (f₁ x, f₃ x)) l ((uniformity) α) :=\n  by\n  refine' le_trans (le_lift'.2 fun s hs => mem_map.2 _) comp_le_uniformity\n  filter_upwards [h₁₂ hs, h₂₃ hs]with x hx₁₂ hx₂₃ using⟨_, hx₁₂, hx₂₃⟩\n#align filter.tendsto.uniformity_trans Filter.Tendsto.uniformity_trans\n-/\n\n",
 "uniformity_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.Tendsto.uniformity_symm /-\n/-- Relation `λ f g, tendsto (λ x, (f x, g x)) l (𝓤 α)` is symmetric -/\ntheorem Filter.Tendsto.uniformity_symm {l : Filter β} {f : β → α × α} (h : Tendsto f l ((uniformity) α)) :\n    Tendsto (fun x => ((f x).2, (f x).1)) l ((uniformity) α) :=\n  tendsto_swap_uniformity.comp h\n#align filter.tendsto.uniformity_symm Filter.Tendsto.uniformity_symm\n-/\n\n",
 "uniformity_sum_of_open_aux":
 "#print uniformity_sum_of_open_aux /-\n/- To prove that the topology defined by the uniform structure on the disjoint union coincides with\nthe disjoint union topology, we need two lemmas saying that open sets can be characterized by\nthe uniform structure -/\ntheorem uniformity_sum_of_open_aux {s : Set (Sum α β)} (hs : IsOpen s) {x : Sum α β} (xs : x ∈ s) :\n    { p : Sum α β × Sum α β | p.1 = x → p.2 ∈ s } ∈ (@UniformSpace.Core.sum α β _ _).uniformity :=\n  by\n  cases x\n  · refine'\n        mem_of_superset (union_mem_uniformity_sum (mem_nhds_uniformity_iff_right.1 (IsOpen.mem_nhds hs.1 xs)) univ_mem)\n          (union_subset _ _) <;>\n      rintro _ ⟨⟨_, b⟩, h, ⟨⟩⟩ ⟨⟩\n    exact h rfl\n  · refine'\n        mem_of_superset (union_mem_uniformity_sum univ_mem (mem_nhds_uniformity_iff_right.1 (IsOpen.mem_nhds hs.2 xs)))\n          (union_subset _ _) <;>\n      rintro _ ⟨⟨a, _⟩, h, ⟨⟩⟩ ⟨⟩\n    exact h rfl\n#align uniformity_sum_of_open_aux uniformity_sum_of_open_aux\n-/\n\n",
 "uniformity_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_subtype /-\ntheorem uniformity_subtype {p : α → Prop} [t : UniformSpace α] :\n    (uniformity) (Subtype p) = comap (fun q : Subtype p × Subtype p => (q.1.1, q.2.1)) ((uniformity) α) :=\n  rfl\n#align uniformity_subtype uniformity_subtype\n-/\n\n",
 "uniformity_setCoe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_setCoe /-\ntheorem uniformity_setCoe {s : Set α} [t : UniformSpace α] :\n    (uniformity) s = comap (prod.map (coe : s → α) (coe : s → α)) ((uniformity) α) :=\n  rfl\n#align uniformity_set_coe uniformity_setCoe\n-/\n\n",
 "uniformity_prod_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_prod_eq_prod /-\ntheorem uniformity_prod_eq_prod [UniformSpace α] [UniformSpace β] :\n    (uniformity) (α × β) =\n      map (fun p : (α × α) × β × β => ((p.1.1, p.2.1), (p.1.2, p.2.2)))\n        (filter.prod ((uniformity) α) ((uniformity) β)) :=\n  by rw [map_swap4_eq_comap, uniformity_prod_eq_comap_prod]\n#align uniformity_prod_eq_prod uniformity_prod_eq_prod\n-/\n\n",
 "uniformity_prod_eq_comap_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_prod_eq_comap_prod /-\ntheorem uniformity_prod_eq_comap_prod [UniformSpace α] [UniformSpace β] :\n    (uniformity) (α × β) =\n      comap (fun p : (α × β) × α × β => ((p.1.1, p.2.1), (p.1.2, p.2.2)))\n        (filter.prod ((uniformity) α) ((uniformity) β)) :=\n  by rw [uniformity_prod, Filter.prod, comap_inf, comap_comap, comap_comap]\n#align uniformity_prod_eq_comap_prod uniformity_prod_eq_comap_prod\n-/\n\n",
 "uniformity_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_prod /-\n/- a similar product space is possible on the function space (uniformity of pointwise convergence),\n  but we want to have the uniformity of uniform convergence on function spaces -/\n-- check the above produces no diamond\ntheorem uniformity_prod [UniformSpace α] [UniformSpace β] :\n    (uniformity) (α × β) =\n      «expr ⊓ » (((uniformity) α).comap fun p : (α × β) × α × β => (p.1.1, p.2.1))\n        (((uniformity) β).comap fun p : (α × β) × α × β => (p.1.2, p.2.2)) :=\n  rfl\n#align uniformity_prod uniformity_prod\n-/\n\n",
 "uniformity_multiplicative":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_multiplicative /-\ntheorem uniformity_multiplicative : (uniformity) (Multiplicative α) = ((uniformity) α).map (prod.map ofAdd ofAdd) :=\n  by\n  convert map_id.symm\n  exact Prod.map_id\n#align uniformity_multiplicative uniformity_multiplicative\n-/\n\n",
 "uniformity_mulOpposite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_mulOpposite /-\n@[to_additive]\ntheorem uniformity_mulOpposite [UniformSpace α] :\n    (uniformity) («expr ᵐᵒᵖ» α) =\n      comap (fun q : «expr ᵐᵒᵖ» α × «expr ᵐᵒᵖ» α => (q.1.unop, q.2.unop)) ((uniformity) α) :=\n  rfl\n#align uniformity_mul_opposite uniformity_mulOpposite\n#align uniformity_add_opposite uniformity_addOpposite\n-/\n\n",
 "uniformity_lift_le_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_lift_le_swap /-\ntheorem uniformity_lift_le_swap {g : Set (α × α) → Filter β} {f : Filter β} (hg : Monotone g)\n    (h : (((uniformity) α).lift fun s => g (preimage Prod.swap s)) ≤ f) : ((uniformity) α).lift g ≤ f :=\n  calc\n    ((uniformity) α).lift g ≤ (Filter.map (@Prod.swap α α) <| (uniformity) α).lift g :=\n      lift_mono uniformity_le_symm le_rfl\n    _ ≤ _ := by rw [map_lift_eq2 hg, image_swap_eq_preimage_swap] <;> exact h\n    \n#align uniformity_lift_le_swap uniformity_lift_le_swap\n-/\n\n",
 "uniformity_lift_le_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_lift_le_comp /-\ntheorem uniformity_lift_le_comp {f : Set (α × α) → Filter β} (h : Monotone f) :\n    (((uniformity) α).lift fun s => f (uniformity.comp_rel s s)) ≤ ((uniformity) α).lift f :=\n  calc\n    (((uniformity) α).lift fun s => f (uniformity.comp_rel s s)) =\n        (((uniformity) α).lift' fun s : Set (α × α) => uniformity.comp_rel s s).lift f :=\n      by\n      rw [lift_lift'_assoc]\n      exact monotone_id.comp_rel monotone_id\n      exact h\n    _ ≤ ((uniformity) α).lift f := lift_mono comp_le_uniformity le_rfl\n    \n#align uniformity_lift_le_comp uniformity_lift_le_comp\n-/\n\n",
 "uniformity_le_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_le_symm /-\ntheorem uniformity_le_symm : (uniformity) α ≤ @Prod.swap α α <$> (uniformity) α := by\n  rw [map_swap_eq_comap_swap] <;> exact map_le_iff_le_comap.1 tendsto_swap_uniformity\n#align uniformity_le_symm uniformity_le_symm\n-/\n\n",
 "uniformity_hasBasis_open_symmetric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_hasBasis_open_symmetric /-\n/-- Open elements `s : set (α × α)` of `𝓤 α` such that `(x, y) ∈ s ↔ (y, x) ∈ s` form a basis\nof `𝓤 α`. -/\ntheorem uniformity_hasBasis_open_symmetric :\n    HasBasis ((uniformity) α) (fun V : Set (α × α) => V ∈ (uniformity) α ∧ IsOpen V ∧ SymmetricRel V) id :=\n  by\n  simp only [← and_assoc']\n  refine' uniformity_has_basis_open.restrict fun s hs => ⟨symmetrizeRel s, _⟩\n  exact\n    ⟨⟨symmetrize_mem_uniformity hs.1, IsOpen.inter hs.2 (hs.2.preimage continuous_swap)⟩, symmetric_symmetrizeRel s,\n      symmetrizeRel_subset_self s⟩\n#align uniformity_has_basis_open_symmetric uniformity_hasBasis_open_symmetric\n-/\n\n",
 "uniformity_hasBasis_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_hasBasis_open /-\n/-- Open elements of `𝓤 α` form a basis of `𝓤 α`. -/\ntheorem uniformity_hasBasis_open :\n    HasBasis ((uniformity) α) (fun V : Set (α × α) => V ∈ (uniformity) α ∧ IsOpen V) id :=\n  hasBasis_self.2 fun s hs => ⟨interior s, interior_mem_uniformity hs, isOpen_interior, interior_subset⟩\n#align uniformity_has_basis_open uniformity_hasBasis_open\n-/\n\n",
 "uniformity_hasBasis_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_hasBasis_closure /-\n/-- Closed entourages form a basis of the uniformity filter. -/\ntheorem uniformity_hasBasis_closure : HasBasis ((uniformity) α) (fun V : Set (α × α) => V ∈ (uniformity) α) closure :=\n  ((uniformity) α).basis_sets.uniformity_closure\n#align uniformity_has_basis_closure uniformity_hasBasis_closure\n-/\n\n",
 "uniformity_hasBasis_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_hasBasis_closed /-\ntheorem uniformity_hasBasis_closed :\n    HasBasis ((uniformity) α) (fun V : Set (α × α) => V ∈ (uniformity) α ∧ IsClosed V) id :=\n  by\n  refine' Filter.hasBasis_self.2 fun t h => _\n  rcases comp_comp_symm_mem_uniformity_sets h with ⟨w, w_in, w_symm, r⟩\n  refine' ⟨closure w, mem_of_superset w_in subset_closure, isClosed_closure, _⟩\n  refine' subset.trans _ r\n  rw [closure_eq_uniformity]\n  apply Inter_subset_of_subset\n  apply Inter_subset\n  exact ⟨w_in, w_symm⟩\n#align uniformity_has_basis_closed uniformity_hasBasis_closed\n-/\n\n",
 "uniformity_eq_uniformity_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_eq_uniformity_interior /-\ntheorem uniformity_eq_uniformity_interior : (uniformity) α = ((uniformity) α).lift' interior :=\n  le_antisymm\n    (le_infᵢ fun d =>\n      le_infᵢ fun hd =>\n        by\n        let ⟨s, hs, hs_comp⟩ :=\n          (mem_lift'_sets <| monotone_id.comp_rel <| monotone_id.comp_rel monotone_id).mp (comp_le_uniformity3 hd)\n        let ⟨t, ht, hst, ht_comp⟩ := nhdset_of_mem_uniformity s hs\n        have : s ⊆ interior d :=\n          calc\n            s ⊆ t := hst\n            _ ⊆ interior d :=\n              ht.subset_interior_iff.mpr fun x (hx : x ∈ t) =>\n                let ⟨x, y, h₁, h₂, h₃⟩ := ht_comp hx\n                hs_comp ⟨x, h₁, y, h₂, h₃⟩\n            \n        have : interior d ∈ (uniformity) α := by filter_upwards [hs]using this\n        simp [this])\n    fun s hs => (((uniformity) α).lift' interior).sets_of_superset (mem_lift' hs) interior_subset\n#align uniformity_eq_uniformity_interior uniformity_eq_uniformity_interior\n-/\n\n",
 "uniformity_eq_uniformity_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_eq_uniformity_closure /-\ntheorem uniformity_eq_uniformity_closure : (uniformity) α = ((uniformity) α).lift' closure :=\n  Eq.symm <| uniformity_hasBasis_closed.lift'_closure_eq_self fun _ => And.right\n#align uniformity_eq_uniformity_closure uniformity_eq_uniformity_closure\n-/\n\n",
 "uniformity_eq_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_eq_symm /-\ntheorem uniformity_eq_symm : (uniformity) α = @Prod.swap α α <$> (uniformity) α :=\n  le_antisymm uniformity_le_symm symm_le_uniformity\n#align uniformity_eq_symm uniformity_eq_symm\n-/\n\n",
 "uniformity_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_comap /-\ntheorem uniformity_comap [UniformSpace β] (f : α → β) :\n    uniformity_of (UniformSpace.comap f ‹_›) = comap (prod.map f f) ((uniformity) β) :=\n  rfl\n#align uniformity_comap uniformity_comap\n-/\n\n",
 "uniformity_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.uniformity_closure /-\ntheorem Filter.HasBasis.uniformity_closure {p : ι → Prop} {U : ι → Set (α × α)} (h : ((uniformity) α).has_basis p U) :\n    ((uniformity) α).has_basis p fun i => closure (U i) :=\n  (@uniformity_eq_uniformity_closure α _).symm ▸ h.lift'_closure\n#align filter.has_basis.uniformity_closure Filter.HasBasis.uniformity_closure\n-/\n\n",
 "uniformity_additive":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformity_additive /-\ntheorem uniformity_additive : (uniformity) (Additive α) = ((uniformity) α).map (prod.map ofMul ofMul) :=\n  by\n  convert map_id.symm\n  exact Prod.map_id\n#align uniformity_additive uniformity_additive\n-/\n\n",
 "uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Sum.uniformity /-\n-- We can now define the uniform structure on the disjoint union\ntheorem Sum.uniformity :\n    (uniformity) (Sum α β) =\n      «expr ⊔ » (map (fun p : α × α => (inl p.1, inl p.2)) ((uniformity) α))\n        (map (fun p : β × β => (inr p.1, inr p.2)) ((uniformity) β)) :=\n  rfl\n#align sum.uniformity Sum.uniformity\n-/\n\n",
 "uniform_continuous_unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[to_additive]\ntheorem uniform_continuous_unop [UniformSpace α] : UniformContinuous (unop : «expr ᵐᵒᵖ» α → α) :=\n  uniformContinuous_comap\n#align uniform_continuous_unop uniform_continuous_unop\n\n",
 "uniform_continuous_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[to_additive]\ntheorem uniform_continuous_op [UniformSpace α] : UniformContinuous (op : α → «expr ᵐᵒᵖ» α) :=\n  uniformContinuous_comap' uniformContinuous_id\n#align uniform_continuous_op uniform_continuous_op\n\n",
 "uniformSpace_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity_of -/\n#print uniformSpace_eq /-\n@[ext]\ntheorem uniformSpace_eq : ∀ {u₁ u₂ : UniformSpace α}, uniformity_of u₁ = uniformity_of u₂ → u₁ = u₂\n  | UniformSpace.mk' t₁ u₁ o₁, UniformSpace.mk' t₂ u₂ o₂, h =>\n    by\n    have : u₁ = u₂ := UniformSpace.core_eq h\n    have : t₁ = t₂ := topologicalSpace_eq <| funext fun s => by rw [o₁, o₂] <;> simp [this]\n    simp [*]\n#align uniform_space_eq uniformSpace_eq\n-/\n\n",
 "uniformSpace_comap_id":
 "#print uniformSpace_comap_id /-\n@[simp]\ntheorem uniformSpace_comap_id {α : Type _} : UniformSpace.comap (id : α → α) = id :=\n  by\n  ext : 2\n  rw [uniformity_comap, Prod.map_id, comap_id]\n#align uniform_space_comap_id uniformSpace_comap_id\n-/\n\n",
 "uniformContinuous₂_def":
 "#print uniformContinuous₂_def /-\ntheorem uniformContinuous₂_def (f : α → β → γ) : UniformContinuous₂ f ↔ UniformContinuous (uncurry f) :=\n  iff.rfl\n#align uniform_continuous₂_def uniformContinuous₂_def\n-/\n\n",
 "uniformContinuous₂_curry":
 "#print uniformContinuous₂_curry /-\ntheorem uniformContinuous₂_curry (f : α × β → γ) : UniformContinuous₂ (function.curry f) ↔ UniformContinuous f := by\n  rw [UniformContinuous₂, uncurry_curry]\n#align uniform_continuous₂_curry uniformContinuous₂_curry\n-/\n\n",
 "uniformContinuous_toMul":
 "#print uniformContinuous_toMul /-\ntheorem uniformContinuous_toMul : UniformContinuous (toMul : Additive α → α) :=\n  uniformContinuous_id\n#align uniform_continuous_to_mul uniformContinuous_toMul\n-/\n\n",
 "uniformContinuous_toAdd":
 "#print uniformContinuous_toAdd /-\ntheorem uniformContinuous_toAdd : UniformContinuous (toAdd : Multiplicative α → α) :=\n  uniformContinuous_id\n#align uniform_continuous_to_add uniformContinuous_toAdd\n-/\n\n",
 "uniformContinuous_subtype_val":
 "/- warning: uniform_continuous_subtype_coe clashes with uniform_continuous_subtype_val -> uniformContinuous_subtype_val\nCase conversion may be inaccurate. Consider using '#align uniform_continuous_subtype_coe uniformContinuous_subtype_valₓ'. -/\n#print uniformContinuous_subtype_val /-\ntheorem uniformContinuous_subtype_val {p : α → Prop} [UniformSpace α] :\n    UniformContinuous (coe : { a : α // p a } → α) :=\n  uniformContinuous_subtype_val\n#align uniform_continuous_subtype_coe uniformContinuous_subtype_val\n-/\n\n",
 "uniformContinuous_snd":
 "#print uniformContinuous_snd /-\ntheorem uniformContinuous_snd [UniformSpace α] [UniformSpace β] : UniformContinuous fun p : α × β => p.2 :=\n  tendsto_prod_uniformity_snd\n#align uniform_continuous_snd uniformContinuous_snd\n-/\n\n",
 "uniformContinuous_of_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print uniformContinuous_of_const /-\ntheorem uniformContinuous_of_const [UniformSpace β] {c : α → β} (h : ∀ a b, c a = c b) : UniformContinuous c :=\n  have : «expr ⁻¹' » (fun x : α × α => (c x.fst, c x.snd)) idRel = univ := eq_univ_iff_forall.2 fun ⟨a, b⟩ => h a b\n  le_trans (map_le_iff_le_comap.2 <| by simp [comap_principal, this, univ_mem]) refl_le_uniformity\n#align uniform_continuous_of_const uniformContinuous_of_const\n-/\n\n",
 "uniformContinuous_ofMul":
 "#print uniformContinuous_ofMul /-\ntheorem uniformContinuous_ofMul : UniformContinuous (ofMul : α → Additive α) :=\n  uniformContinuous_id\n#align uniform_continuous_of_mul uniformContinuous_ofMul\n-/\n\n",
 "uniformContinuous_ofAdd":
 "#print uniformContinuous_ofAdd /-\ntheorem uniformContinuous_ofAdd : UniformContinuous (ofAdd : α → Multiplicative α) :=\n  uniformContinuous_id\n#align uniform_continuous_of_add uniformContinuous_ofAdd\n-/\n\n",
 "uniformContinuous_infₛ_rng":
 "#print uniformContinuous_infₛ_rng /-\ntheorem uniformContinuous_infₛ_rng {f : α → β} {u₁ : UniformSpace α} {u₂ : Set (UniformSpace β)}\n    (h : ∀ u ∈ u₂, @UniformContinuous u₁ u f) : @UniformContinuous u₁ (infₛ u₂) f :=\n  by\n  rw [UniformContinuous, infₛ_eq_infᵢ', infᵢ_uniformity]\n  exact tendsto_infi.mpr fun ⟨u, hu⟩ => h u hu\n#align uniform_continuous_Inf_rng uniformContinuous_infₛ_rng\n-/\n\n",
 "uniformContinuous_infₛ_dom₂":
 "#print uniformContinuous_infₛ_dom₂ /-\n/-- A version of `uniform_continuous_Inf_dom` for binary functions -/\ntheorem uniformContinuous_infₛ_dom₂ {α β γ} {f : α → β → γ} {uas : Set (UniformSpace α)} {ubs : Set (UniformSpace β)}\n    {ua : UniformSpace α} {ub : UniformSpace β} {uc : UniformSpace γ} (ha : ua ∈ uas) (hb : ub ∈ ubs)\n    (hf : UniformContinuous fun p : α × β => f p.1 p.2) : by\n    haveI := Inf uas <;> haveI := Inf ubs <;> exact @UniformContinuous _ _ _ uc fun p : α × β => f p.1 p.2 :=\n  by\n  -- proof essentially copied from ``continuous_Inf_dom`\n  let t : UniformSpace (α × β) := prod.uniform_space\n  have ha := uniformContinuous_infₛ_dom ha uniformContinuous_id\n  have hb := uniformContinuous_infₛ_dom hb uniformContinuous_id\n  have h_unif_cont_id := @UniformContinuous.prod_map _ _ _ _ (Inf uas) (Inf ubs) ua ub _ _ ha hb\n  exact @UniformContinuous.comp _ _ _ (id _) (id _) _ _ _ hf h_unif_cont_id\n#align uniform_continuous_Inf_dom₂ uniformContinuous_infₛ_dom₂\n-/\n\n",
 "uniformContinuous_infₛ_dom":
 "#print uniformContinuous_infₛ_dom /-\ntheorem uniformContinuous_infₛ_dom {f : α → β} {u₁ : Set (UniformSpace α)} {u₂ : UniformSpace β} {u : UniformSpace α}\n    (h₁ : u ∈ u₁) (hf : @UniformContinuous u u₂ f) : @UniformContinuous (infₛ u₁) u₂ f :=\n  by\n  rw [UniformContinuous, infₛ_eq_infᵢ', infᵢ_uniformity]\n  exact tendsto_infi' ⟨u, h₁⟩ hf\n#align uniform_continuous_Inf_dom uniformContinuous_infₛ_dom\n-/\n\n",
 "uniformContinuous_infᵢ_rng":
 "#print uniformContinuous_infᵢ_rng /-\ntheorem uniformContinuous_infᵢ_rng {f : α → β} {u₁ : UniformSpace α} {u₂ : ι → UniformSpace β}\n    (h : ∀ i, @UniformContinuous u₁ (u₂ i) f) : @UniformContinuous u₁ (infᵢ u₂) f := by\n  rwa [UniformContinuous, infᵢ_uniformity, tendsto_infi]\n#align uniform_continuous_infi_rng uniformContinuous_infᵢ_rng\n-/\n\n",
 "uniformContinuous_infᵢ_dom":
 "#print uniformContinuous_infᵢ_dom /-\ntheorem uniformContinuous_infᵢ_dom {f : α → β} {u₁ : ι → UniformSpace α} {u₂ : UniformSpace β} {i : ι}\n    (hf : @UniformContinuous (u₁ i) u₂ f) : @UniformContinuous (infᵢ u₁) u₂ f :=\n  by\n  rw [UniformContinuous, infᵢ_uniformity]\n  exact tendsto_infi' i hf\n#align uniform_continuous_infi_dom uniformContinuous_infᵢ_dom\n-/\n\n",
 "uniformContinuous_inf_dom_right₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print uniformContinuous_inf_dom_right₂ /-\n/-- A version of `uniform_continuous_inf_dom_right` for binary functions -/\ntheorem uniformContinuous_inf_dom_right₂ {α β γ} {f : α → β → γ} {ua1 ua2 : UniformSpace α} {ub1 ub2 : UniformSpace β}\n    {uc1 : UniformSpace γ}\n    (h : by haveI := ua2 <;> haveI := ub2 <;> exact UniformContinuous fun p : α × β => f p.1 p.2) : by\n    haveI := «expr ⊓ » ua1 ua2 <;> haveI := «expr ⊓ » ub1 ub2 <;> exact UniformContinuous fun p : α × β => f p.1 p.2 :=\n  by\n  -- proof essentially copied from ``continuous_inf_dom_right₂`\n  have ha := @UniformContinuous.inf_dom_right _ _ id ua1 ua2 ua2 (@uniformContinuous_id _ (id _))\n  have hb := @UniformContinuous.inf_dom_right _ _ id ub1 ub2 ub2 (@uniformContinuous_id _ (id _))\n  have h_unif_cont_id := @UniformContinuous.prod_map _ _ _ _ («expr ⊓ » ua1 ua2) («expr ⊓ » ub1 ub2) ua2 ub2 _ _ ha hb\n  exact @UniformContinuous.comp _ _ _ (id _) (id _) _ _ _ h h_unif_cont_id\n#align uniform_continuous_inf_dom_right₂ uniformContinuous_inf_dom_right₂\n-/\n\n",
 "uniformContinuous_inf_dom_left₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print uniformContinuous_inf_dom_left₂ /-\n/-- A version of `uniform_continuous_inf_dom_left` for binary functions -/\ntheorem uniformContinuous_inf_dom_left₂ {α β γ} {f : α → β → γ} {ua1 ua2 : UniformSpace α} {ub1 ub2 : UniformSpace β}\n    {uc1 : UniformSpace γ}\n    (h : by haveI := ua1 <;> haveI := ub1 <;> exact UniformContinuous fun p : α × β => f p.1 p.2) : by\n    haveI := «expr ⊓ » ua1 ua2 <;> haveI := «expr ⊓ » ub1 ub2 <;> exact UniformContinuous fun p : α × β => f p.1 p.2 :=\n  by\n  -- proof essentially copied from ``continuous_inf_dom_left₂`\n  have ha := @UniformContinuous.inf_dom_left _ _ id ua1 ua2 ua1 (@uniformContinuous_id _ (id _))\n  have hb := @UniformContinuous.inf_dom_left _ _ id ub1 ub2 ub1 (@uniformContinuous_id _ (id _))\n  have h_unif_cont_id := @UniformContinuous.prod_map _ _ _ _ («expr ⊓ » ua1 ua2) («expr ⊓ » ub1 ub2) ua1 ub1 _ _ ha hb\n  exact @UniformContinuous.comp _ _ _ (id _) (id _) _ _ _ h h_unif_cont_id\n#align uniform_continuous_inf_dom_left₂ uniformContinuous_inf_dom_left₂\n-/\n\n",
 "uniformContinuous_iff_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformContinuous_iff_eventually /-\ntheorem uniformContinuous_iff_eventually [UniformSpace β] {f : α → β} :\n    UniformContinuous f ↔\n      ∀ r ∈ (uniformity) β,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          ((uniformity) α) ((f x.1, f x.2) ∈ r) :=\n  iff.rfl\n#align uniform_continuous_iff_eventually uniformContinuous_iff_eventually\n-/\n\n",
 "uniformContinuous_iff":
 "#print uniformContinuous_iff /-\ntheorem uniformContinuous_iff {α β} {uα : UniformSpace α} {uβ : UniformSpace β} {f : α → β} :\n    UniformContinuous f ↔ uα ≤ uβ.comap f :=\n  Filter.map_le_iff_le_comap\n#align uniform_continuous_iff uniformContinuous_iff\n-/\n\n",
 "uniformContinuous_id":
 "#print uniformContinuous_id /-\ntheorem uniformContinuous_id : UniformContinuous (@id α) := by simp [UniformContinuous] <;> exact tendsto_id\n#align uniform_continuous_id uniformContinuous_id\n-/\n\n",
 "uniformContinuous_fst":
 "#print uniformContinuous_fst /-\ntheorem uniformContinuous_fst [UniformSpace α] [UniformSpace β] : UniformContinuous fun p : α × β => p.1 :=\n  tendsto_prod_uniformity_fst\n#align uniform_continuous_fst uniformContinuous_fst\n-/\n\n",
 "uniformContinuous_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print uniformContinuous_def /-\ntheorem uniformContinuous_def [UniformSpace β] {f : α → β} :\n    UniformContinuous f ↔ ∀ r ∈ (uniformity) β, { x : α × α | (f x.1, f x.2) ∈ r } ∈ (uniformity) α :=\n  iff.rfl\n#align uniform_continuous_def uniformContinuous_def\n-/\n\n",
 "uniformContinuous_const":
 "#print uniformContinuous_const /-\ntheorem uniformContinuous_const [UniformSpace β] {b : β} : UniformContinuous fun a : α => b :=\n  uniformContinuous_of_const fun _ _ => rfl\n#align uniform_continuous_const uniformContinuous_const\n-/\n\n",
 "uniformContinuous_comap'":
 "#print uniformContinuous_comap' /-\ntheorem uniformContinuous_comap' {f : γ → β} {g : α → γ} [v : UniformSpace β] [u : UniformSpace α]\n    (h : UniformContinuous (f ∘ g)) : @UniformContinuous α γ u (UniformSpace.comap f v) g :=\n  tendsto_comap_iff.2 h\n#align uniform_continuous_comap' uniformContinuous_comap'\n-/\n\n",
 "uniformContinuous_comap":
 "#print uniformContinuous_comap /-\ntheorem uniformContinuous_comap {f : α → β} [u : UniformSpace β] :\n    @UniformContinuous α β (UniformSpace.comap f u) u f :=\n  tendsto_comap\n#align uniform_continuous_comap uniformContinuous_comap\n-/\n\n",
 "uniformContinuousOn_univ":
 "#print uniformContinuousOn_univ /-\ntheorem uniformContinuousOn_univ [UniformSpace β] {f : α → β} : UniformContinuousOn f univ ↔ UniformContinuous f := by\n  rw [UniformContinuousOn, UniformContinuous, univ_prod_univ, principal_univ, inf_top_eq]\n#align uniform_continuous_on_univ uniformContinuousOn_univ\n-/\n\n",
 "uniformContinuousOn_iff_restrict":
 "#print uniformContinuousOn_iff_restrict /-\ntheorem uniformContinuousOn_iff_restrict [UniformSpace α] [UniformSpace β] {f : α → β} {s : Set α} :\n    UniformContinuousOn f s ↔ UniformContinuous (s.restrict f) :=\n  by\n  unfold UniformContinuousOn Set.restrict UniformContinuous tendsto\n  conv_rhs =>\n    rw [show (fun x : s × s => (f x.1, f x.2)) = prod.map f f ∘ prod.map coe coe from rfl, uniformity_setCoe, ← map_map,\n      map_comap, range_prod_map, Subtype.range_coe]\n  rfl\n#align uniform_continuous_on_iff_restrict uniformContinuousOn_iff_restrict\n-/\n\n",
 "uniformContinuousOn_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » S) -/\n#print Filter.HasBasis.uniformContinuousOn_iff /-\ntheorem Filter.HasBasis.uniformContinuousOn_iff {ι'} [UniformSpace β] {p : ι → Prop} {s : ι → Set (α × α)}\n    (ha : ((uniformity) α).has_basis p s) {q : ι' → Prop} {t : ι' → Set (β × β)} (hb : ((uniformity) β).has_basis q t)\n    {f : α → β} {S : Set α} :\n    UniformContinuousOn f S ↔\n      ∀ (i) (hi : q i), ∃ (j : _)(hj : p j), ∀ (x) (_ : x ∈ S) (y) (_ : y ∈ S), (x, y) ∈ s j → (f x, f y) ∈ t i :=\n  ((ha.inf_principal (lower_set.prod S S)).tendsto_iff hb).trans <| by\n    simp_rw [Prod.forall, Set.inter_comm (s _), ball_mem_comm, mem_inter_iff, mem_prod, and_imp]\n#align filter.has_basis.uniform_continuous_on_iff Filter.HasBasis.uniformContinuousOn_iff\n-/\n\n",
 "uniformContinuous":
 "#print UniformContinuous₂.uniformContinuous /-\ntheorem UniformContinuous₂.uniformContinuous {f : α → β → γ} (h : UniformContinuous₂ f) :\n    UniformContinuous (uncurry f) :=\n  h\n#align uniform_continuous₂.uniform_continuous UniformContinuous₂.uniformContinuous\n-/\n\n",
 "to_nhds_mono":
 "#print to_nhds_mono /-\ntheorem to_nhds_mono {u₁ u₂ : UniformSpace α} (h : u₁ ≤ u₂) (a : α) :\n    @nhds _ (@uniform_space.to_topological_space _ u₁) a ≤ @nhds _ (@uniform_space.to_topological_space _ u₂) a := by\n  rw [@nhds_eq_uniformity α u₁ a, @nhds_eq_uniformity α u₂ a] <;> exact lift'_mono h le_rfl\n#align to_nhds_mono to_nhds_mono\n-/\n\n",
 "toTopologicalSpace_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print toTopologicalSpace_top /-\ntheorem toTopologicalSpace_top : @uniform_space.to_topological_space α («expr⊤») = «expr⊤» :=\n  top_unique fun s hs =>\n    s.eq_empty_or_nonempty.elim (fun this : s = ∅ => this.symm ▸ @isOpen_empty _ («expr⊤»)) fun ⟨x, hx⟩ =>\n      have : s = univ := top_unique fun y hy => hs x hx (x, y) rfl\n      this.symm ▸ @isOpen_univ _ («expr⊤»)\n#align to_topological_space_top toTopologicalSpace_top\n-/\n\n",
 "toTopologicalSpace_subtype":
 "#print toTopologicalSpace_subtype /-\ntheorem toTopologicalSpace_subtype [u : UniformSpace α] {p : α → Prop} :\n    @uniform_space.to_topological_space (Subtype p) subtype.uniform_space =\n      @subtype.topological_space α p u.to_topological_space :=\n  rfl\n#align to_topological_space_subtype toTopologicalSpace_subtype\n-/\n\n",
 "toTopologicalSpace_prod":
 "#print toTopologicalSpace_prod /-\ntheorem toTopologicalSpace_prod {α} {β} [u : UniformSpace α] [v : UniformSpace β] :\n    @uniform_space.to_topological_space (α × β) prod.uniform_space =\n      @prod.topological_space α β u.to_topological_space v.to_topological_space :=\n  rfl\n#align to_topological_space_prod toTopologicalSpace_prod\n-/\n\n",
 "toTopologicalSpace_mono":
 "#print toTopologicalSpace_mono /-\ntheorem toTopologicalSpace_mono {u₁ u₂ : UniformSpace α} (h : u₁ ≤ u₂) :\n    @uniform_space.to_topological_space _ u₁ ≤ @uniform_space.to_topological_space _ u₂ :=\n  le_of_nhds_le_nhds <| to_nhds_mono h\n#align to_topological_space_mono toTopologicalSpace_mono\n-/\n\n",
 "toTopologicalSpace_infₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print toTopologicalSpace_infₛ /-\ntheorem toTopologicalSpace_infₛ {s : Set (UniformSpace α)} :\n    (infₛ s).to_topological_space =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (@uniform_space.to_topological_space α i) :=\n  by\n  rw [infₛ_eq_infᵢ]\n  simp only [← toTopologicalSpace_infᵢ]\n#align to_topological_space_Inf toTopologicalSpace_infₛ\n-/\n\n",
 "toTopologicalSpace_infᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print toTopologicalSpace_infᵢ /-\ntheorem toTopologicalSpace_infᵢ {ι : Sort _} {u : ι → UniformSpace α} :\n    (infᵢ u).to_topological_space =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (u i).to_topological_space :=\n  by\n  refine' eq_of_nhds_eq_nhds fun a => _\n  simp only [nhds_infᵢ, nhds_eq_uniformity, infᵢ_uniformity]\n  exact lift'_infi_of_map_univ (ball_inter _) preimage_univ\n#align to_topological_space_infi toTopologicalSpace_infᵢ\n-/\n\n",
 "toTopologicalSpace_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print toTopologicalSpace_inf /-\ntheorem toTopologicalSpace_inf {u v : UniformSpace α} :\n    («expr ⊓ » u v).to_topological_space = «expr ⊓ » u.to_topological_space v.to_topological_space :=\n  rfl\n#align to_topological_space_inf toTopologicalSpace_inf\n-/\n\n",
 "toTopologicalSpace_comap":
 "#print toTopologicalSpace_comap /-\ntheorem toTopologicalSpace_comap {f : α → β} {u : UniformSpace β} :\n    @uniform_space.to_topological_space _ (UniformSpace.comap f u) =\n      TopologicalSpace.induced f (@uniform_space.to_topological_space β u) :=\n  rfl\n#align to_topological_space_comap toTopologicalSpace_comap\n-/\n\n",
 "toTopologicalSpace_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print toTopologicalSpace_bot /-\ntheorem toTopologicalSpace_bot : @uniform_space.to_topological_space α («expr⊥») = «expr⊥» :=\n  rfl\n#align to_topological_space_bot toTopologicalSpace_bot\n-/\n\n",
 "toCore_toTopologicalSpace":
 "#print UniformSpace.toCore_toTopologicalSpace /-\n-- the topological structure is embedded in the uniform structure\n-- to avoid instance diamond issues. See Note [forgetful inheritance].\ntheorem UniformSpace.toCore_toTopologicalSpace (u : UniformSpace α) :\n    u.to_core.to_topological_space = u.to_topological_space :=\n  topologicalSpace_eq <| funext fun s => by rw [uniform_space.is_open_uniformity, isOpen_mk]\n#align uniform_space.to_core_to_topological_space UniformSpace.toCore_toTopologicalSpace\n-/\n\n",
 "tendsto_swap_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print tendsto_swap_uniformity /-\ntheorem tendsto_swap_uniformity : Tendsto (@Prod.swap α α) ((uniformity) α) ((uniformity) α) :=\n  symm_le_uniformity\n#align tendsto_swap_uniformity tendsto_swap_uniformity\n-/\n\n",
 "tendsto_right_nhds_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print tendsto_right_nhds_uniformity /-\ntheorem tendsto_right_nhds_uniformity {a : α} : Tendsto (fun a' => (a', a)) ((nhds) a) ((uniformity) α) := fun s =>\n  mem_nhds_right a\n#align tendsto_right_nhds_uniformity tendsto_right_nhds_uniformity\n-/\n\n",
 "tendsto_prod_uniformity_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print tendsto_prod_uniformity_snd /-\ntheorem tendsto_prod_uniformity_snd [UniformSpace α] [UniformSpace β] :\n    Tendsto (fun p : (α × β) × α × β => (p.1.2, p.2.2)) ((uniformity) (α × β)) ((uniformity) β) :=\n  le_trans (map_mono inf_le_right) map_comap_le\n#align tendsto_prod_uniformity_snd tendsto_prod_uniformity_snd\n-/\n\n",
 "tendsto_prod_uniformity_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print tendsto_prod_uniformity_fst /-\ntheorem tendsto_prod_uniformity_fst [UniformSpace α] [UniformSpace β] :\n    Tendsto (fun p : (α × β) × α × β => (p.1.1, p.2.1)) ((uniformity) (α × β)) ((uniformity) α) :=\n  le_trans (map_mono inf_le_left) map_comap_le\n#align tendsto_prod_uniformity_fst tendsto_prod_uniformity_fst\n-/\n\n",
 "tendsto_of_uniformContinuous_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_of_uniformContinuous_subtype /-\ntheorem tendsto_of_uniformContinuous_subtype [UniformSpace α] [UniformSpace β] {f : α → β} {s : Set α} {a : α}\n    (hf : UniformContinuous fun x : s => f x.val) (ha : s ∈ (nhds) a) : Tendsto f ((nhds) a) ((nhds) (f a)) := by\n  rw [(@map_nhds_subtype_coe_eq_nhds α _ s a (mem_of_mem_nhds ha) ha).symm] <;>\n    exact tendsto_map' (continuous_iff_continuous_at.mp hf.continuous _)\n#align tendsto_of_uniform_continuous_subtype tendsto_of_uniformContinuous_subtype\n-/\n\n",
 "tendsto_nhds_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem tendsto_nhds_right {f : Filter β} {u : β → α} {a : α} :\n    Tendsto u f ((nhds) a) ↔ Tendsto (fun x => (a, u x)) f ((uniformity) α) := by\n  rw [nhds_eq_comap_uniformity, tendsto_comap_iff]\n#align tendsto_nhds_right tendsto_nhds_right\n\n",
 "tendsto_nhds_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem tendsto_nhds_left {f : Filter β} {u : β → α} {a : α} :\n    Tendsto u f ((nhds) a) ↔ Tendsto (fun x => (u x, a)) f ((uniformity) α) := by\n  rw [nhds_eq_comap_uniformity', tendsto_comap_iff]\n#align tendsto_nhds_left tendsto_nhds_left\n\n",
 "tendsto_left_nhds_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print tendsto_left_nhds_uniformity /-\ntheorem tendsto_left_nhds_uniformity {a : α} : Tendsto (fun a' => (a, a')) ((nhds) a) ((uniformity) α) := fun s =>\n  mem_nhds_left a\n#align tendsto_left_nhds_uniformity tendsto_left_nhds_uniformity\n-/\n\n",
 "tendsto_diag_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print tendsto_diag_uniformity /-\n/-- Relation `λ f g, tendsto (λ x, (f x, g x)) l (𝓤 α)` is reflexive. -/\ntheorem tendsto_diag_uniformity (f : β → α) (l : Filter β) : Tendsto (fun x => (f x, f x)) l ((uniformity) α) :=\n  fun s hs => mem_map.2 <| univ_mem' fun x => refl_mem_uniformity hs\n#align tendsto_diag_uniformity tendsto_diag_uniformity\n-/\n\n",
 "tendsto_const_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print tendsto_const_uniformity /-\ntheorem tendsto_const_uniformity {a : α} {f : Filter β} : Tendsto (fun _ => (a, a)) f ((uniformity) α) :=\n  tendsto_diag_uniformity (fun _ => a) f\n#align tendsto_const_uniformity tendsto_const_uniformity\n-/\n\n",
 "tendsto_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Uniform.tendsto_congr /-\ntheorem Uniform.tendsto_congr {α β} [UniformSpace β] {f g : α → β} {l : Filter α} {b : β}\n    (hfg : Tendsto (fun x => (f x, g x)) l ((uniformity) β)) : Tendsto f l ((nhds) b) ↔ Tendsto g l ((nhds) b) :=\n  ⟨fun h => h.congr_uniformity hfg, fun h => h.congr_uniformity hfg.uniformity_symm⟩\n#align uniform.tendsto_congr Uniform.tendsto_congr\n-/\n\n",
 "symmetrize_mono":
 "#print symmetrize_mono /-\n@[mono]\ntheorem symmetrize_mono {V W : Set (α × α)} (h : V ⊆ W) : symmetrizeRel V ⊆ symmetrizeRel W :=\n  inter_subset_inter h <| preimage_mono h\n#align symmetrize_mono symmetrize_mono\n-/\n\n",
 "symmetrize_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print symmetrize_mem_uniformity /-\ntheorem symmetrize_mem_uniformity {V : Set (α × α)} (h : V ∈ (uniformity) α) : symmetrizeRel V ∈ (uniformity) α :=\n  by\n  apply ((uniformity) α).inter_sets h\n  rw [← image_swap_eq_preimage_swap, uniformity_eq_symm]\n  exact image_mem_map h\n#align symmetrize_mem_uniformity symmetrize_mem_uniformity\n-/\n\n",
 "symmetrizeRel_subset_self":
 "#print symmetrizeRel_subset_self /-\ntheorem symmetrizeRel_subset_self (V : Set (α × α)) : symmetrizeRel V ⊆ V :=\n  sep_subset _ _\n#align symmetrize_rel_subset_self symmetrizeRel_subset_self\n-/\n\n",
 "symmetric_symmetrizeRel":
 "#print symmetric_symmetrizeRel /-\ntheorem symmetric_symmetrizeRel (V : Set (α × α)) : SymmetricRel (symmetrizeRel V) := by\n  simp [SymmetricRel, symmetrizeRel, preimage_inter, inter_comm, ← preimage_comp]\n#align symmetric_symmetrize_rel symmetric_symmetrizeRel\n-/\n\n",
 "symm_of_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print symm_of_uniformity /-\ntheorem symm_of_uniformity {s : Set (α × α)} (hs : s ∈ (uniformity) α) :\n    ∃ t ∈ (uniformity) α, (∀ a b, (a, b) ∈ t → (b, a) ∈ t) ∧ t ⊆ s :=\n  have : preimage Prod.swap s ∈ (uniformity) α := symm_le_uniformity hs\n  ⟨s ∩ preimage Prod.swap s, inter_mem hs this, fun a b ⟨h₁, h₂⟩ => ⟨h₂, h₁⟩, inter_subset_left _ _⟩\n#align symm_of_uniformity symm_of_uniformity\n-/\n\n",
 "symm_le_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print symm_le_uniformity /-\ntheorem symm_le_uniformity : map (@Prod.swap α α) ((uniformity) _) ≤ (uniformity) _ :=\n  (@uniform_space.to_core α _).symm\n#align symm_le_uniformity symm_le_uniformity\n-/\n\n",
 "swap_idRel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print swap_idRel /-\n@[simp]\ntheorem swap_idRel : «expr '' » Prod.swap idRel = @idRel α :=\n  Set.ext fun ⟨a, b⟩ => by simp [image_swap_eq_preimage_swap] <;> exact eq_comm\n#align swap_id_rel swap_idRel\n-/\n\n",
 "supᵢ_nhds_le_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print supᵢ_nhds_le_uniformity /-\n/-- Entourages are neighborhoods of the diagonal. -/\ntheorem supᵢ_nhds_le_uniformity :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((nhds) (x, x)) ≤\n      (uniformity) α :=\n  supᵢ_le nhds_le_uniformity\n#align supr_nhds_le_uniformity supᵢ_nhds_le_uniformity\n-/\n\n",
 "subtype_mk":
 "#print UniformContinuous.subtype_mk /-\ntheorem UniformContinuous.subtype_mk {p : α → Prop} [UniformSpace α] [UniformSpace β] {f : β → α}\n    (hf : UniformContinuous f) (h : ∀ x, p (f x)) : UniformContinuous (fun x => ⟨f x, h x⟩ : β → Subtype p) :=\n  uniformContinuous_comap' hf\n#align uniform_continuous.subtype_mk UniformContinuous.subtype_mk\n-/\n\n",
 "subset_iterate_compRel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `uniformity.comp_rel -/\n#print subset_iterate_compRel /-\ntheorem subset_iterate_compRel {s t : Set (α × α)} (h : idRel ⊆ s) (n : ℕ) :\n    t ⊆ («expr ^[ ]» ((uniformity.comp_rel · ·) s) n) t :=\n  by\n  induction' n with n ihn generalizing t\n  exacts[subset.rfl, (right_subset_compRel h).trans ihn]\n#align subset_iterate_comp_rel subset_iterate_compRel\n-/\n\n",
 "subset_comp_self_of_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print subset_comp_self_of_mem_uniformity /-\ntheorem subset_comp_self_of_mem_uniformity {s : Set (α × α)} (h : s ∈ (uniformity) α) : s ⊆ uniformity.comp_rel s s :=\n  subset_comp_self (refl_le_uniformity h)\n#align subset_comp_self_of_mem_uniformity subset_comp_self_of_mem_uniformity\n-/\n\n",
 "subset_comp_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print subset_comp_self /-\ntheorem subset_comp_self {s : Set (α × α)} (h : idRel ⊆ s) : s ⊆ uniformity.comp_rel s s :=\n  left_subset_compRel h\n#align subset_comp_self subset_comp_self\n-/\n\n",
 "right_subset_compRel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print right_subset_compRel /-\ntheorem right_subset_compRel {s t : Set (α × α)} (h : idRel ⊆ s) : t ⊆ uniformity.comp_rel s t := fun ⟨x, y⟩ xy_in =>\n  ⟨x, h <| rfl, xy_in⟩\n#align right_subset_comp_rel right_subset_compRel\n-/\n\n",
 "replaceTopology_eq":
 "#print UniformSpace.replaceTopology_eq /-\ntheorem UniformSpace.replaceTopology_eq {α : Type _} [i : TopologicalSpace α] (u : UniformSpace α)\n    (h : i = u.to_topological_space) : u.replace_topology h = u :=\n  u.of_core_eq_to_core _ _\n#align uniform_space.replace_topology_eq UniformSpace.replaceTopology_eq\n-/\n\n",
 "refl_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print refl_mem_uniformity /-\ntheorem refl_mem_uniformity {x : α} {s : Set (α × α)} (h : s ∈ (uniformity) α) : (x, x) ∈ s :=\n  refl_le_uniformity h rfl\n#align refl_mem_uniformity refl_mem_uniformity\n-/\n\n",
 "refl_le_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print refl_le_uniformity /-\ntheorem refl_le_uniformity : (filter.principal) idRel ≤ (uniformity) α :=\n  (@uniform_space.to_core α _).refl\n#align refl_le_uniformity refl_le_uniformity\n-/\n\n",
 "prod_mk_right":
 "#print UniformContinuous.prod_mk_right /-\ntheorem UniformContinuous.prod_mk_right {f : α × β → γ} (h : UniformContinuous f) (a) :\n    UniformContinuous fun b => f (a, b) :=\n  h.comp (uniformContinuous_const.prod_mk uniformContinuous_id)\n#align uniform_continuous.prod_mk_right UniformContinuous.prod_mk_right\n-/\n\n",
 "prod_mk_mem_compRel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print prod_mk_mem_compRel /-\ntheorem prod_mk_mem_compRel {a b c : α} {s t : Set (α × α)} (h₁ : (a, c) ∈ s) (h₂ : (c, b) ∈ t) :\n    (a, b) ∈ uniformity.comp_rel s t :=\n  ⟨c, h₁, h₂⟩\n#align prod_mk_mem_comp_rel prod_mk_mem_compRel\n-/\n\n",
 "prod_mk_left":
 "#print UniformContinuous.prod_mk_left /-\ntheorem UniformContinuous.prod_mk_left {f : α × β → γ} (h : UniformContinuous f) (b) :\n    UniformContinuous fun a => f (a, b) :=\n  h.comp (uniformContinuous_id.prod_mk uniformContinuous_const)\n#align uniform_continuous.prod_mk_left UniformContinuous.prod_mk_left\n-/\n\n",
 "prod_mk":
 "#print UniformContinuous.prod_mk /-\ntheorem UniformContinuous.prod_mk {f₁ : α → β} {f₂ : α → γ} (h₁ : UniformContinuous f₁) (h₂ : UniformContinuous f₂) :\n    UniformContinuous fun a => (f₁ a, f₂ a) := by\n  rw [UniformContinuous, uniformity_prod] <;> exact tendsto_inf.2 ⟨tendsto_comap_iff.2 h₁, tendsto_comap_iff.2 h₂⟩\n#align uniform_continuous.prod_mk UniformContinuous.prod_mk\n-/\n\n",
 "prod_map":
 "#print UniformContinuous.prod_map /-\ntheorem UniformContinuous.prod_map [UniformSpace δ] {f : α → γ} {g : β → δ} (hf : UniformContinuous f)\n    (hg : UniformContinuous g) : UniformContinuous (prod.map f g) :=\n  (hf.comp uniformContinuous_fst).prod_mk (hg.comp uniformContinuous_snd)\n#align uniform_continuous.prod_map UniformContinuous.prod_map\n-/\n\n",
 "open_of_uniformity_sum_aux":
 "#print open_of_uniformity_sum_aux /-\ntheorem open_of_uniformity_sum_aux {s : Set (Sum α β)}\n    (hs : ∀ x ∈ s, { p : Sum α β × Sum α β | p.1 = x → p.2 ∈ s } ∈ (@UniformSpace.Core.sum α β _ _).uniformity) :\n    IsOpen s := by\n  constructor\n  · refine' (@isOpen_iff_mem_nhds α _ _).2 fun a ha => mem_nhds_uniformity_iff_right.2 _\n    rcases mem_map_iff_exists_image.1 (hs _ ha).1 with ⟨t, ht, st⟩\n    refine' mem_of_superset ht _\n    rintro p pt rfl\n    exact st ⟨_, pt, rfl⟩ rfl\n  · refine' (@isOpen_iff_mem_nhds β _ _).2 fun b hb => mem_nhds_uniformity_iff_right.2 _\n    rcases mem_map_iff_exists_image.1 (hs _ hb).2 with ⟨t, ht, st⟩\n    refine' mem_of_superset ht _\n    rintro p pt rfl\n    exact st ⟨_, pt, rfl⟩ rfl\n#align open_of_uniformity_sum_aux open_of_uniformity_sum_aux\n-/\n\n",
 "ofCoreEq_toCore":
 "#print UniformSpace.ofCoreEq_toCore /-\ntheorem UniformSpace.ofCoreEq_toCore (u : UniformSpace α) (t : TopologicalSpace α)\n    (h : t = u.to_core.to_topological_space) : UniformSpace.ofCoreEq u.to_core t h = u :=\n  uniformSpace_eq rfl\n#align uniform_space.of_core_eq_to_core UniformSpace.ofCoreEq_toCore\n-/\n\n",
 "nhdset_of_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » cl_d) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print nhdset_of_mem_uniformity /-\ntheorem nhdset_of_mem_uniformity {d : Set (α × α)} (s : Set (α × α)) (hd : d ∈ (uniformity) α) :\n    ∃ t : Set (α × α), IsOpen t ∧ s ⊆ t ∧ t ⊆ { p | ∃ x y, (p.1, x) ∈ d ∧ (x, y) ∈ s ∧ (y, p.2) ∈ d } :=\n  let cl_d := { p : α × α | ∃ x y, (p.1, x) ∈ d ∧ (x, y) ∈ s ∧ (y, p.2) ∈ d }\n  have : ∀ p ∈ s, ∃ (t : _)(_ : t ⊆ cl_d), IsOpen t ∧ p ∈ t := fun ⟨x, y⟩ hp =>\n    mem_nhds_iff.mp <|\n      show cl_d ∈ (nhds) (x, y) by\n        rw [nhds_eq_uniformity_prod, mem_lift'_sets]\n        exact ⟨d, hd, fun ⟨a, b⟩ ⟨ha, hb⟩ => ⟨x, y, ha, hp, hb⟩⟩\n        exact monotone_preimage.set_prod monotone_preimage\n  have : ∃ t : ∀ (p : α × α) (h : p ∈ s), Set (α × α), ∀ p, ∀ h : p ∈ s, t p h ⊆ cl_d ∧ IsOpen (t p h) ∧ p ∈ t p h := by\n    simp [classical.skolem] at this <;> simp <;> assumption\n  match this with\n  | ⟨t, ht⟩ =>\n    ⟨(«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t p h)) :\n        Set (α × α)),\n      isOpen_unionᵢ fun p : α × α => isOpen_unionᵢ fun hp => (ht p hp).right.left, fun ⟨a, b⟩ hp => by\n      simp <;> exact ⟨a, b, hp, (ht (a, b) hp).right.right⟩,\n      unionᵢ_subset fun p => unionᵢ_subset fun hp => (ht p hp).left⟩\n#align nhdset_of_mem_uniformity nhdset_of_mem_uniformity\n-/\n\n",
 "nhds_nhds_eq_uniformity_uniformity_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print nhds_nhds_eq_uniformity_uniformity_prod /-\ntheorem nhds_nhds_eq_uniformity_uniformity_prod {a b : α} :\n    filter.prod ((nhds) a) ((nhds) b) =\n      ((uniformity) α).lift fun s : Set (α × α) =>\n        ((uniformity) α).lift' fun t : Set (α × α) => lower_set.prod { y : α | (y, a) ∈ s } { y : α | (b, y) ∈ t } :=\n  by\n  rw [nhds_eq_uniformity', nhds_eq_uniformity, prod_lift'_lift']\n  exacts[rfl, monotone_preimage, monotone_preimage]\n#align nhds_nhds_eq_uniformity_uniformity_prod nhds_nhds_eq_uniformity_uniformity_prod\n-/\n\n",
 "nhds_le_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print nhds_le_uniformity /-\n/-- Entourages are neighborhoods of the diagonal. -/\ntheorem nhds_le_uniformity (x : α) : (nhds) (x, x) ≤ (uniformity) α :=\n  by\n  intro V V_in\n  rcases comp_symm_mem_uniformity_sets V_in with ⟨w, w_in, w_symm, w_sub⟩\n  have : lower_set.prod (ball x w) (ball x w) ∈ (nhds) (x, x) :=\n    by\n    rw [nhds_prod_eq]\n    exact prod_mem_prod (ball_mem_nhds x w_in) (ball_mem_nhds x w_in)\n  apply mem_of_superset this\n  rintro ⟨u, v⟩ ⟨u_in, v_in⟩\n  exact w_sub (mem_comp_of_mem_ball w_symm u_in v_in)\n#align nhds_le_uniformity nhds_le_uniformity\n-/\n\n",
 "nhds_eq_uniformity_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print nhds_eq_uniformity_prod /-\ntheorem nhds_eq_uniformity_prod {a b : α} :\n    (nhds) (a, b) =\n      ((uniformity) α).lift' fun s : Set (α × α) => lower_set.prod { y : α | (y, a) ∈ s } { y : α | (b, y) ∈ s } :=\n  by\n  rw [nhds_prod_eq, nhds_nhds_eq_uniformity_uniformity_prod, lift_lift'_same_eq_lift']\n  · intro s\n    exact monotone_const.set_prod monotone_preimage\n  · intro t\n    exact monotone_preimage.set_prod monotone_const\n#align nhds_eq_uniformity_prod nhds_eq_uniformity_prod\n-/\n\n",
 "nhds_eq_uniformity'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print nhds_eq_uniformity' /-\ntheorem nhds_eq_uniformity' {x : α} : (nhds) x = ((uniformity) α).lift' fun s => { y | (y, x) ∈ s } :=\n  (nhds_basis_uniformity ((uniformity) α).basis_sets).eq_binfi\n#align nhds_eq_uniformity' nhds_eq_uniformity'\n-/\n\n",
 "nhds_eq_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print nhds_eq_uniformity /-\ntheorem nhds_eq_uniformity {x : α} : (nhds) x = ((uniformity) α).lift' (ball x) :=\n  (nhds_basis_uniformity' ((uniformity) α).basis_sets).eq_binfi\n#align nhds_eq_uniformity nhds_eq_uniformity\n-/\n\n",
 "nhds_eq_comap_uniformity'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print nhds_eq_comap_uniformity' /-\ntheorem nhds_eq_comap_uniformity' {x : α} : (nhds) x = ((uniformity) α).comap fun y => (y, x) :=\n  (nhds_basis_uniformity ((uniformity) α).basis_sets).eq_of_same_basis <| ((uniformity) α).basis_sets.comap _\n#align nhds_eq_comap_uniformity' nhds_eq_comap_uniformity'\n-/\n\n",
 "nhds_eq_comap_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print nhds_eq_comap_uniformity /-\ntheorem nhds_eq_comap_uniformity {x : α} : (nhds) x = ((uniformity) α).comap (prod.mk x) :=\n  by\n  ext s\n  rw [mem_nhds_uniformity_iff_right, mem_comap_prod_mk]\n#align nhds_eq_comap_uniformity nhds_eq_comap_uniformity\n-/\n\n",
 "nhds_basis_uniformity'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_basis_uniformity' /-\ntheorem nhds_basis_uniformity' {p : ι → Prop} {s : ι → Set (α × α)} (h : ((uniformity) α).has_basis p s) {x : α} :\n    ((nhds) x).has_basis p fun i => ball x (s i) :=\n  by\n  rw [nhds_eq_comap_uniformity]\n  exact h.comap (prod.mk x)\n#align nhds_basis_uniformity' nhds_basis_uniformity'\n-/\n\n",
 "nhds_basis_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_basis_uniformity /-\ntheorem nhds_basis_uniformity {p : ι → Prop} {s : ι → Set (α × α)} (h : ((uniformity) α).has_basis p s) {x : α} :\n    ((nhds) x).has_basis p fun i => { y | (y, x) ∈ s i } :=\n  by\n  replace h := h.comap Prod.swap\n  rw [← map_swap_eq_comap_swap, ← uniformity_eq_symm] at h\n  exact nhds_basis_uniformity' h\n#align nhds_basis_uniformity nhds_basis_uniformity\n-/\n\n",
 "nhdsSet_diagonal_le_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print nhdsSet_diagonal_le_uniformity /-\n/-- Entourages are neighborhoods of the diagonal. -/\ntheorem nhdsSet_diagonal_le_uniformity : (nhds_set) (diagonal α) ≤ (uniformity) α :=\n  (nhdsSet_diagonal α).trans_le supᵢ_nhds_le_uniformity\n#align nhds_set_diagonal_le_uniformity nhdsSet_diagonal_le_uniformity\n-/\n\n",
 "nhdsSet_basis_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print IsCompact.nhdsSet_basis_uniformity /-\ntheorem IsCompact.nhdsSet_basis_uniformity {p : ι → Prop} {s : ι → Set (α × α)} (hU : ((uniformity) α).has_basis p s)\n    {K : Set α} (hK : IsCompact K) :\n    ((nhds_set) K).has_basis p fun i =>\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (ball x (s i)) :=\n  by\n  refine' ⟨fun U => _⟩\n  simp only [mem_nhdsSet_iff_forall, (nhds_basis_uniformity' hU).mem_iff, Union₂_subset_iff]\n  refine' ⟨fun H => _, fun ⟨i, hpi, hi⟩ x hx => ⟨i, hpi, hi x hx⟩⟩\n  replace H : ∀ x ∈ K, ∃ i : { i // p i }, ball x (uniformity.comp_rel (s i) (s i)) ⊆ U\n  · intro x hx\n    rcases H x hx with ⟨i, hpi, hi⟩\n    rcases comp_mem_uniformity_sets (hU.mem_of_mem hpi) with ⟨t, ht_mem, ht⟩\n    rcases hU.mem_iff.1 ht_mem with ⟨j, hpj, hj⟩\n    exact ⟨⟨j, hpj⟩, subset.trans (ball_mono ((compRel_mono hj hj).trans ht) _) hi⟩\n  have : Nonempty { a // p a } := nonempty_subtype.2 hU.ex_mem\n  choose! I hI using H\n  rcases hK.elim_nhds_subcover (fun x => ball x <| s (I x)) fun x hx => ball_mem_nhds _ <| hU.mem_of_mem (I x).2 with\n    ⟨t, htK, ht⟩\n  obtain ⟨i, hpi, hi⟩ :\n    ∃ (i : _)(hpi : p i),\n      s i ⊆ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s (I x))\n  exact hU.mem_iff.1 ((bInter_finset_mem t).2 fun x hx => hU.mem_of_mem (I x).2)\n  rw [subset_Inter₂_iff] at hi\n  refine' ⟨i, hpi, fun x hx => _⟩\n  rcases mem_Union₂.1 (ht hx) with ⟨z, hzt : z ∈ t, hzx : x ∈ ball z (s (I z))⟩\n  calc\n    ball x (s i) ⊆ ball z (uniformity.comp_rel (s (I z)) (s (I z))) := fun y hy => ⟨x, hzx, hi z hzt hy⟩\n    _ ⊆ U := hI z (htK z hzt)\n    \n#align is_compact.nhds_set_basis_uniformity IsCompact.nhdsSet_basis_uniformity\n-/\n\n",
 "mk_mem_comm":
 "#print SymmetricRel.mk_mem_comm /-\ntheorem SymmetricRel.mk_mem_comm {V : Set (α × α)} (hV : SymmetricRel V) {x y : α} : (x, y) ∈ V ↔ (y, x) ∈ V :=\n  Set.ext_iff.1 hV (y, x)\n#align symmetric_rel.mk_mem_comm SymmetricRel.mk_mem_comm\n-/\n\n",
 "mem_uniformity_of_uniformContinuous_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print mem_uniformity_of_uniformContinuous_invariant /-\ntheorem mem_uniformity_of_uniformContinuous_invariant [UniformSpace α] [UniformSpace β] {s : Set (β × β)}\n    {f : α → α → β} (hf : UniformContinuous fun p : α × α => f p.1 p.2) (hs : s ∈ (uniformity) β) :\n    ∃ u ∈ (uniformity) α, ∀ a b c, (a, b) ∈ u → (f a c, f b c) ∈ s :=\n  by\n  rw [UniformContinuous, uniformity_prod_eq_prod, tendsto_map'_iff, (· ∘ ·)] at hf\n  rcases mem_prod_iff.1 (mem_map.1 <| hf hs) with ⟨u, hu, v, hv, huvt⟩\n  exact ⟨u, hu, fun a b c hab => @huvt ((_, _), (_, _)) ⟨hab, refl_mem_uniformity hv⟩⟩\n#align mem_uniformity_of_uniform_continuous_invariant mem_uniformity_of_uniformContinuous_invariant\n-/\n\n",
 "mem_uniformity_of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print mem_uniformity_of_eq /-\ntheorem mem_uniformity_of_eq {x y : α} {s : Set (α × α)} (h : s ∈ (uniformity) α) (hx : x = y) : (x, y) ∈ s :=\n  refl_le_uniformity h hx\n#align mem_uniformity_of_eq mem_uniformity_of_eq\n-/\n\n",
 "mem_uniformity_isClosed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print mem_uniformity_isClosed /-\ntheorem mem_uniformity_isClosed {s : Set (α × α)} (h : s ∈ (uniformity) α) : ∃ t ∈ (uniformity) α, IsClosed t ∧ t ⊆ s :=\n  let ⟨t, ⟨ht_mem, htc⟩, hts⟩ := uniformity_hasBasis_closed.mem_iff.1 h\n  ⟨t, ht_mem, htc, hts⟩\n#align mem_uniformity_is_closed mem_uniformity_isClosed\n-/\n\n",
 "mem_uniformity_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.mem_uniformity_iff /-\ntheorem Filter.HasBasis.mem_uniformity_iff {p : β → Prop} {s : β → Set (α × α)} (h : ((uniformity) α).has_basis p s)\n    {t : Set (α × α)} : t ∈ (uniformity) α ↔ ∃ (i : _)(hi : p i), ∀ a b, (a, b) ∈ s i → (a, b) ∈ t :=\n  h.mem_iff.trans <| by simp only [Prod.forall, subset_def]\n#align filter.has_basis.mem_uniformity_iff Filter.HasBasis.mem_uniformity_iff\n-/\n\n",
 "mem_uniform_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print mem_uniform_prod /-\ntheorem mem_uniform_prod [t₁ : UniformSpace α] [t₂ : UniformSpace β] {a : Set (α × α)} {b : Set (β × β)}\n    (ha : a ∈ (uniformity) α) (hb : b ∈ (uniformity) β) :\n    { p : (α × β) × α × β | (p.1.1, p.2.1) ∈ a ∧ (p.1.2, p.2.2) ∈ b } ∈ (uniformity) (α × β) := by\n  rw [uniformity_prod] <;> exact inter_mem_inf (preimage_mem_comap ha) (preimage_mem_comap hb)\n#align mem_uniform_prod mem_uniform_prod\n-/\n\n",
 "mem_nhds_uniformity_iff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print mem_nhds_uniformity_iff_right /-\ntheorem mem_nhds_uniformity_iff_right {x : α} {s : Set α} :\n    s ∈ (nhds) x ↔ { p : α × α | p.1 = x → p.2 ∈ s } ∈ (uniformity) α :=\n  by\n  refine' ⟨_, fun hs => _⟩\n  · simp only [mem_nhds_iff, isOpen_uniformity, and_imp, exists_imp]\n    intro t ts ht xt\n    filter_upwards [ht x xt]using fun y h eq => ts (h Eq)\n  · refine' mem_nhds_iff.mpr ⟨{ x | { p : α × α | p.1 = x → p.2 ∈ s } ∈ (uniformity) α }, _, _, hs⟩\n    · exact fun y hy => refl_mem_uniformity hy rfl\n    · refine' is_open_uniformity.mpr fun y hy => _\n      rcases comp_mem_uniformity_sets hy with ⟨t, ht, tr⟩\n      filter_upwards [ht]\n      rintro ⟨a, b⟩ hp' rfl\n      filter_upwards [ht]\n      rintro ⟨a', b'⟩ hp'' rfl\n      exact @tr (a, b') ⟨a', hp', hp''⟩ rfl\n#align mem_nhds_uniformity_iff_right mem_nhds_uniformity_iff_right\n-/\n\n",
 "mem_nhds_uniformity_iff_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print mem_nhds_uniformity_iff_left /-\ntheorem mem_nhds_uniformity_iff_left {x : α} {s : Set α} :\n    s ∈ (nhds) x ↔ { p : α × α | p.2 = x → p.1 ∈ s } ∈ (uniformity) α :=\n  by\n  rw [uniformity_eq_symm, mem_nhds_uniformity_iff_right]\n  rfl\n#align mem_nhds_uniformity_iff_left mem_nhds_uniformity_iff_left\n-/\n\n",
 "mem_nhds_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_nhds_right /-\ntheorem mem_nhds_right (y : α) {s : Set (α × α)} (h : s ∈ (uniformity) α) : { x : α | (x, y) ∈ s } ∈ (nhds) y :=\n  mem_nhds_left _ (symm_le_uniformity h)\n#align mem_nhds_right mem_nhds_right\n-/\n\n",
 "mem_nhds_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_nhds_left /-\ntheorem mem_nhds_left (x : α) {s : Set (α × α)} (h : s ∈ (uniformity) α) : { y : α | (x, y) ∈ s } ∈ (nhds) x :=\n  ball_mem_nhds x h\n#align mem_nhds_left mem_nhds_left\n-/\n\n",
 "mem_nhds_iff_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print UniformSpace.mem_nhds_iff_symm /-\ntheorem UniformSpace.mem_nhds_iff_symm {x : α} {s : Set α} :\n    s ∈ (nhds) x ↔ ∃ V ∈ (uniformity) α, SymmetricRel V ∧ ball x V ⊆ s :=\n  by\n  rw [UniformSpace.mem_nhds_iff]\n  constructor\n  · rintro ⟨V, V_in, V_sub⟩\n    use symmetrizeRel V, symmetrize_mem_uniformity V_in, symmetric_symmetrizeRel V\n    exact subset.trans (ball_mono (symmetrizeRel_subset_self V) x) V_sub\n  · rintro ⟨V, V_in, V_symm, V_sub⟩\n    exact ⟨V, V_in, V_sub⟩\n#align uniform_space.mem_nhds_iff_symm UniformSpace.mem_nhds_iff_symm\n-/\n\n",
 "mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print UniformSpace.mem_nhds_iff /-\ntheorem UniformSpace.mem_nhds_iff {x : α} {s : Set α} : s ∈ (nhds) x ↔ ∃ V ∈ (uniformity) α, ball x V ⊆ s :=\n  by\n  rw [nhds_eq_comap_uniformity, mem_comap]\n  exact iff.rfl\n#align uniform_space.mem_nhds_iff UniformSpace.mem_nhds_iff\n-/\n\n",
 "mem_idRel":
 "#print mem_idRel /-\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Patrick Massot\n-/\n@[simp]\ntheorem mem_idRel {a b : α} : (a, b) ∈ @idRel α ↔ a = b :=\n  iff.rfl\n#align mem_id_rel mem_idRel\n-/\n\n",
 "mem_comp_of_mem_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print mem_comp_of_mem_ball /-\ntheorem mem_comp_of_mem_ball {V W : Set (β × β)} {x y z : β} (hV : SymmetricRel V) (hx : x ∈ ball z V)\n    (hy : y ∈ ball z W) : (x, y) ∈ uniformity.comp_rel V W :=\n  by\n  rw [mem_ball_symmetry hV] at hx\n  exact ⟨z, hx, hy⟩\n#align mem_comp_of_mem_ball mem_comp_of_mem_ball\n-/\n\n",
 "mem_comp_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print mem_comp_comp /-\ntheorem mem_comp_comp {V W M : Set (β × β)} (hW' : SymmetricRel W) {p : β × β} :\n    p ∈ uniformity.comp_rel (uniformity.comp_rel V M) W ↔ (lower_set.prod (ball p.1 V) (ball p.2 W) ∩ M).nonempty :=\n  by\n  cases' p with x y\n  constructor\n  · rintro ⟨z, ⟨w, hpw, hwz⟩, hzy⟩\n    exact ⟨(w, z), ⟨hpw, by rwa [mem_ball_symmetry hW']⟩, hwz⟩\n  · rintro ⟨⟨w, z⟩, ⟨w_in, z_in⟩, hwz⟩\n    rwa [mem_ball_symmetry hW'] at z_in\n    use z, w <;> tauto\n#align mem_comp_comp mem_comp_comp\n-/\n\n",
 "mem_compRel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print mem_compRel /-\n@[simp]\ntheorem mem_compRel {r₁ r₂ : Set (α × α)} {x y : α} :\n    (x, y) ∈ uniformity.comp_rel r₁ r₂ ↔ ∃ z, (x, z) ∈ r₁ ∧ (z, y) ∈ r₂ :=\n  iff.rfl\n#align mem_comp_rel mem_compRel\n-/\n\n",
 "mem_closure_iff_symm_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print UniformSpace.mem_closure_iff_symm_ball /-\ntheorem UniformSpace.mem_closure_iff_symm_ball {s : Set α} {x} :\n    x ∈ closure s ↔ ∀ {V}, V ∈ (uniformity) α → SymmetricRel V → (s ∩ ball x V).nonempty := by\n  simp [mem_closure_iff_nhds_basis (has_basis_nhds x), Set.Nonempty]\n#align uniform_space.mem_closure_iff_symm_ball UniformSpace.mem_closure_iff_symm_ball\n-/\n\n",
 "mem_closure_iff_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print UniformSpace.mem_closure_iff_ball /-\ntheorem UniformSpace.mem_closure_iff_ball {s : Set α} {x} :\n    x ∈ closure s ↔ ∀ {V}, V ∈ (uniformity) α → (ball x V ∩ s).nonempty := by\n  simp [mem_closure_iff_nhds_basis' (nhds_basis_uniformity' ((uniformity) α).basis_sets)]\n#align uniform_space.mem_closure_iff_ball UniformSpace.mem_closure_iff_ball\n-/\n\n",
 "mem_ball_symmetry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print mem_ball_symmetry /-\ntheorem mem_ball_symmetry {V : Set (β × β)} (hV : SymmetricRel V) {x y} : x ∈ ball y V ↔ y ∈ ball x V :=\n  show (x, y) ∈ «expr ⁻¹' » Prod.swap V ↔ (x, y) ∈ V\n    by\n    unfold SymmetricRel at hV\n    rw [hV]\n#align mem_ball_symmetry mem_ball_symmetry\n-/\n\n",
 "mem_ball_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print UniformSpace.mem_ball_self /-\ntheorem UniformSpace.mem_ball_self (x : α) {V : Set (α × α)} (hV : V ∈ (uniformity) α) : x ∈ ball x V :=\n  refl_mem_uniformity hV\n#align uniform_space.mem_ball_self UniformSpace.mem_ball_self\n-/\n\n",
 "mem_ball_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print mem_ball_comp /-\n/-- The triangle inequality for `uniform_space.ball` -/\ntheorem mem_ball_comp {V W : Set (β × β)} {x y z} (h : y ∈ ball x V) (h' : z ∈ ball y W) :\n    z ∈ ball x (uniformity.comp_rel V W) :=\n  prod_mk_mem_compRel h h'\n#align mem_ball_comp mem_ball_comp\n-/\n\n",
 "lift_nhds_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print lift_nhds_right /-\ntheorem lift_nhds_right {x : α} {g : Set α → Filter β} (hg : Monotone g) :\n    ((nhds) x).lift g = ((uniformity) α).lift fun s : Set (α × α) => g { y | (y, x) ∈ s } :=\n  by\n  rw [nhds_eq_comap_uniformity', comap_lift_eq2 hg]\n  rfl\n#align lift_nhds_right lift_nhds_right\n-/\n\n",
 "lift_nhds_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print lift_nhds_left /-\ntheorem lift_nhds_left {x : α} {g : Set α → Filter β} (hg : Monotone g) :\n    ((nhds) x).lift g = ((uniformity) α).lift fun s : Set (α × α) => g (ball x s) :=\n  by\n  rw [nhds_eq_comap_uniformity, comap_lift_eq2 hg]\n  rfl\n#align lift_nhds_left lift_nhds_left\n-/\n\n",
 "left_subset_compRel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print left_subset_compRel /-\ntheorem left_subset_compRel {s t : Set (α × α)} (h : idRel ⊆ t) : s ⊆ uniformity.comp_rel s t := fun ⟨x, y⟩ xy_in =>\n  ⟨y, xy_in, h <| rfl⟩\n#align left_subset_comp_rel left_subset_compRel\n-/\n\n",
 "lebesgue_number_of_compact_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print lebesgue_number_of_compact_open /-\n/-- A useful consequence of the Lebesgue number lemma: given any compact set `K` contained in an\nopen set `U`, we can find an (open) entourage `V` such that the ball of size `V` about any point of\n`K` is contained in `U`. -/\ntheorem lebesgue_number_of_compact_open [UniformSpace α] {K U : Set α} (hK : IsCompact K) (hU : IsOpen U)\n    (hKU : K ⊆ U) : ∃ V ∈ (uniformity) α, IsOpen V ∧ ∀ x ∈ K, UniformSpace.ball x V ⊆ U :=\n  by\n  let W : K → Set (α × α) := fun k => Classical.choose <| is_open_iff_open_ball_subset.mp hU k.1 <| hKU k.2\n  have hW : ∀ k, W k ∈ (uniformity) α ∧ IsOpen (W k) ∧ UniformSpace.ball k.1 (W k) ⊆ U :=\n    by\n    intro k\n    obtain ⟨h₁, h₂, h₃⟩ := Classical.choose_spec (is_open_iff_open_ball_subset.mp hU k.1 (hKU k.2))\n    exact ⟨h₁, h₂, h₃⟩\n  let c : K → Set α := fun k => UniformSpace.ball k.1 (W k)\n  have hc₁ : ∀ k, IsOpen (c k) := fun k => UniformSpace.isOpen_ball k.1 (hW k).2.1\n  have hc₂ :\n    K ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (c i) :=\n    by\n    intro k hk\n    simp only [mem_Union, SetCoe.exists]\n    exact ⟨k, hk, UniformSpace.mem_ball_self k (hW ⟨k, hk⟩).1⟩\n  have hc₃ : ∀ k, c k ⊆ U := fun k => (hW k).2.2\n  obtain ⟨V, hV, hV'⟩ := lebesgue_number_lemma hK hc₁ hc₂\n  refine' ⟨interior V, interior_mem_uniformity hV, isOpen_interior, _⟩\n  intro k hk\n  obtain ⟨k', hk'⟩ := hV' k hk\n  exact ((ball_mono interior_subset k).trans hk').trans (hc₃ k')\n#align lebesgue_number_of_compact_open lebesgue_number_of_compact_open\n-/\n\n",
 "lebesgue_number_lemma_unionₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print lebesgue_number_lemma_unionₛ /-\n/-- Let `c : set (set α)` be an open cover of a compact set `s`. Then there exists an entourage\n`n` such that for each `x ∈ s` its `n`-neighborhood is contained in some `t ∈ c`. -/\ntheorem lebesgue_number_lemma_unionₛ {α : Type u} [UniformSpace α] {s : Set α} {c : Set (Set α)} (hs : IsCompact s)\n    (hc₁ : ∀ t ∈ c, IsOpen t) (hc₂ : s ⊆ ⋃₀ c) : ∃ n ∈ (uniformity) α, ∀ x ∈ s, ∃ t ∈ c, ∀ y, (x, y) ∈ n → y ∈ t := by\n  rw [sUnion_eq_Union] at hc₂ <;> simpa using lebesgue_number_lemma hs (by simpa) hc₂\n#align lebesgue_number_lemma_sUnion lebesgue_number_lemma_unionₛ\n-/\n\n",
 "lebesgue_number_lemma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print lebesgue_number_lemma /-\n/-- Let `c : ι → set α` be an open cover of a compact set `s`. Then there exists an entourage\n`n` such that for each `x ∈ s` its `n`-neighborhood is contained in some `c i`. -/\ntheorem lebesgue_number_lemma {α : Type u} [UniformSpace α] {s : Set α} {ι} {c : ι → Set α} (hs : IsCompact s)\n    (hc₁ : ∀ i, IsOpen (c i))\n    (hc₂ : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (c i)) :\n    ∃ n ∈ (uniformity) α, ∀ x ∈ s, ∃ i, { y | (x, y) ∈ n } ⊆ c i :=\n  by\n  let u n := { x | ∃ i, ∃ m ∈ (uniformity) α, { y | (x, y) ∈ uniformity.comp_rel m n } ⊆ c i }\n  have hu₁ : ∀ n ∈ (uniformity) α, IsOpen (u n) :=\n    by\n    refine' fun n hn => isOpen_uniformity.2 _\n    rintro x ⟨i, m, hm, h⟩\n    rcases comp_mem_uniformity_sets hm with ⟨m', hm', mm'⟩\n    apply ((uniformity) α).sets_of_superset hm'\n    rintro ⟨x, y⟩ hp rfl\n    refine' ⟨i, m', hm', fun z hz => h (monotone_id.comp_rel monotone_const mm' _)⟩\n    dsimp [-mem_compRel] at hz⊢\n    rw [compRel_assoc]\n    exact ⟨y, hp, hz⟩\n  have hu₂ :\n    s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u n) :=\n    by\n    intro x hx\n    rcases mem_Union.1 (hc₂ hx) with ⟨i, h⟩\n    rcases comp_mem_uniformity_sets (isOpen_uniformity.1 (hc₁ i) x h) with ⟨m', hm', mm'⟩\n    exact mem_bUnion hm' ⟨i, _, hm', fun y hy => mm' hy rfl⟩\n  rcases hs.elim_finite_subcover_image hu₁ hu₂ with ⟨b, bu, b_fin, b_cover⟩\n  refine' ⟨_, (bInter_mem b_fin).2 bu, fun x hx => _⟩\n  rcases mem_Union₂.1 (b_cover hx) with ⟨n, bn, i, m, hm, h⟩\n  refine' ⟨i, fun y hy => h _⟩\n  exact prod_mk_mem_compRel (refl_mem_uniformity hm) (bInter_subset_of_mem bn hy)\n#align lebesgue_number_lemma lebesgue_number_lemma\n-/\n\n",
 "le_infₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity_of -/\n#print le_infₛ /-\nprivate theorem le_infₛ {tt : Set (UniformSpace α)} {t : UniformSpace α} (h : ∀ t' ∈ tt, t ≤ t') : t ≤ infₛ tt :=\n  show\n    uniformity_of t ≤\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (uniformity_of u)\n    from le_infᵢ₂ h\n#align le_Inf le_infₛ\n-/\n\n",
 "le_iff_uniformContinuous_id":
 "#print le_iff_uniformContinuous_id /-\ntheorem le_iff_uniformContinuous_id {u v : UniformSpace α} : u ≤ v ↔ @UniformContinuous _ _ u v id := by\n  rw [uniformContinuous_iff, uniformSpace_comap_id, id]\n#align le_iff_uniform_continuous_id le_iff_uniformContinuous_id\n-/\n\n",
 "isOpen_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print isOpen_uniformity /-\ntheorem isOpen_uniformity {s : Set α} : IsOpen s ↔ ∀ x ∈ s, { p : α × α | p.1 = x → p.2 ∈ s } ∈ (uniformity) α :=\n  uniform_space.is_open_uniformity s\n#align is_open_uniformity isOpen_uniformity\n-/\n\n",
 "isOpen_iff_open_ball_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print isOpen_iff_open_ball_subset /-\ntheorem isOpen_iff_open_ball_subset {s : Set α} : IsOpen s ↔ ∀ x ∈ s, ∃ V ∈ (uniformity) α, IsOpen V ∧ ball x V ⊆ s :=\n  by\n  rw [isOpen_iff_ball_subset]\n  constructor <;> intro h x hx\n  · obtain ⟨V, hV, hV'⟩ := h x hx\n    exact ⟨interior V, interior_mem_uniformity hV, isOpen_interior, (ball_mono interior_subset x).trans hV'⟩\n  · obtain ⟨V, hV, -, hV'⟩ := h x hx\n    exact ⟨V, hV, hV'⟩\n#align is_open_iff_open_ball_subset isOpen_iff_open_ball_subset\n-/\n\n",
 "isOpen_iff_ball_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print isOpen_iff_ball_subset /-\n/-- See also `is_open_iff_open_ball_subset`. -/\ntheorem isOpen_iff_ball_subset {s : Set α} : IsOpen s ↔ ∀ x ∈ s, ∃ V ∈ (uniformity) α, ball x V ⊆ s :=\n  by\n  simp_rw [isOpen_iff_mem_nhds, nhds_eq_comap_uniformity]\n  exact iff.rfl\n#align is_open_iff_ball_subset isOpen_iff_ball_subset\n-/\n\n",
 "isOpen_ball":
 "#print UniformSpace.isOpen_ball /-\ntheorem UniformSpace.isOpen_ball (x : α) {V : Set (α × α)} (hV : IsOpen V) : IsOpen (ball x V) :=\n  hV.preimage <| continuous_const.prod_mk continuous_id\n#align uniform_space.is_open_ball UniformSpace.isOpen_ball\n-/\n\n",
 "interior_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print interior_mem_uniformity /-\ntheorem interior_mem_uniformity {s : Set (α × α)} (hs : s ∈ (uniformity) α) : interior s ∈ (uniformity) α := by\n  rw [uniformity_eq_uniformity_interior] <;> exact mem_lift' hs\n#align interior_mem_uniformity interior_mem_uniformity\n-/\n\n",
 "inter":
 "#print SymmetricRel.inter /-\ntheorem SymmetricRel.inter {U V : Set (α × α)} (hU : SymmetricRel U) (hV : SymmetricRel V) : SymmetricRel (U ∩ V) := by\n  rw [SymmetricRel, preimage_inter, hU.eq, hV.eq]\n#align symmetric_rel.inter SymmetricRel.inter\n-/\n\n",
 "infₛ_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity_of -/\n#print infₛ_le /-\nprivate theorem infₛ_le {tt : Set (UniformSpace α)} {t : UniformSpace α} (h : t ∈ tt) : infₛ tt ≤ t :=\n  show\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (uniformity_of u) ≤\n      uniformity_of t\n    from infᵢ₂_le t h\n#align Inf_le infₛ_le\n-/\n\n",
 "infᵢ_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity_of -/\n#print infᵢ_uniformity /-\ntheorem infᵢ_uniformity {ι : Sort _} {u : ι → UniformSpace α} :\n    uniformity_of (infᵢ u) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (uniformity_of (u i)) :=\n  infᵢ_range\n#align infi_uniformity infᵢ_uniformity\n-/\n\n",
 "inf_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity_of -/\n#print inf_uniformity /-\ntheorem inf_uniformity {u v : UniformSpace α} :\n    uniformity_of («expr ⊓ » u v) = «expr ⊓ » (uniformity_of u) (uniformity_of v) :=\n  rfl\n#align inf_uniformity inf_uniformity\n-/\n\n",
 "inf_rng":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print UniformContinuous.inf_rng /-\ntheorem UniformContinuous.inf_rng {f : α → β} {u₁ : UniformSpace α} {u₂ u₃ : UniformSpace β}\n    (h₁ : @UniformContinuous u₁ u₂ f) (h₂ : @UniformContinuous u₁ u₃ f) : @UniformContinuous u₁ («expr ⊓ » u₂ u₃) f :=\n  tendsto_inf.mpr ⟨h₁, h₂⟩\n#align uniform_continuous_inf_rng UniformContinuous.inf_rng\n-/\n\n",
 "inf_dom_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print UniformContinuous.inf_dom_right /-\ntheorem UniformContinuous.inf_dom_right {f : α → β} {u₁ u₂ : UniformSpace α} {u₃ : UniformSpace β}\n    (hf : @UniformContinuous u₂ u₃ f) : @UniformContinuous («expr ⊓ » u₁ u₂) u₃ f :=\n  tendsto_inf_right hf\n#align uniform_continuous_inf_dom_right UniformContinuous.inf_dom_right\n-/\n\n",
 "inf_dom_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print UniformContinuous.inf_dom_left /-\ntheorem UniformContinuous.inf_dom_left {f : α → β} {u₁ u₂ : UniformSpace α} {u₃ : UniformSpace β}\n    (hf : @UniformContinuous u₁ u₃ f) : @UniformContinuous («expr ⊓ » u₁ u₂) u₃ f :=\n  tendsto_inf_left hf\n#align uniform_continuous_inf_dom_left UniformContinuous.inf_dom_left\n-/\n\n",
 "id_compRel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print id_compRel /-\n@[simp]\ntheorem id_compRel {r : Set (α × α)} : uniformity.comp_rel idRel r = r :=\n  Set.ext fun ⟨a, b⟩ => by simp\n#align id_comp_rel id_compRel\n-/\n\n",
 "idRel_subset":
 "#print idRel_subset /-\n@[simp]\ntheorem idRel_subset {s : Set (α × α)} : idRel ⊆ s ↔ ∀ a, (a, a) ∈ s := by\n  simp [subset_def] <;> exact forall_congr' fun a => by simp\n#align id_rel_subset idRel_subset\n-/\n\n",
 "has_seq_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print UniformSpace.has_seq_basis /-\ntheorem UniformSpace.has_seq_basis [IsCountablyGenerated <| (uniformity) α] :\n    ∃ V : ℕ → Set (α × α), HasAntitoneBasis ((uniformity) α) V ∧ ∀ n, SymmetricRel (V n) :=\n  let ⟨U, hsym, hbasis⟩ := UniformSpace.hasBasis_symmetric.exists_antitone_subbasis\n  ⟨U, hbasis, fun n => (hsym n).2⟩\n#align uniform_space.has_seq_basis UniformSpace.has_seq_basis\n-/\n\n",
 "hasBasis_symmetric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print UniformSpace.hasBasis_symmetric /-\n/-- Symmetric entourages form a basis of `𝓤 α` -/\ntheorem UniformSpace.hasBasis_symmetric :\n    ((uniformity) α).has_basis (fun s : Set (α × α) => s ∈ (uniformity) α ∧ SymmetricRel s) id :=\n  hasBasis_self.2 fun t t_in =>\n    ⟨symmetrizeRel t, symmetrize_mem_uniformity t_in, symmetric_symmetrizeRel t, symmetrizeRel_subset_self t⟩\n#align uniform_space.has_basis_symmetric UniformSpace.hasBasis_symmetric\n-/\n\n",
 "hasBasis_ofFun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity_of -/\n#print UniformSpace.hasBasis_ofFun /-\ntheorem UniformSpace.hasBasis_ofFun {α β : Type _} [LinearOrderedAddCommMonoid β] (h₀ : ∃ x : β, 0 < x) (d : α → α → β)\n    (refl : ∀ x, d x x = 0) (symm : ∀ x y, d x y = d y x) (triangle : ∀ x y z, d x z ≤ d x y + d y z)\n    (half : ∀ ε > (0 : β), ∃ δ > (0 : β), ∀ x < δ, ∀ y < δ, x + y < ε) :\n    (uniformity_of (UniformSpace.ofFun d refl symm triangle half)).has_basis ((· < ·) (0 : β)) fun ε =>\n      { x | d x.1 x.2 < ε } :=\n  hasBasis_binfᵢ_principal'\n    (fun ε₁ h₁ ε₂ h₂ =>\n      ⟨min ε₁ ε₂, lt_min h₁ h₂, fun _x hx => lt_of_lt_of_le hx (min_le_left _ _), fun _x hx =>\n        lt_of_lt_of_le hx (min_le_right _ _)⟩)\n    h₀\n#align uniform_space.has_basis_of_fun UniformSpace.hasBasis_ofFun\n-/\n\n",
 "hasBasis_nhds_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print UniformSpace.hasBasis_nhds_prod /-\ntheorem UniformSpace.hasBasis_nhds_prod (x y : α) :\n    HasBasis ((nhds) (x, y)) (fun s => s ∈ (uniformity) α ∧ SymmetricRel s) fun s =>\n      lower_set.prod (ball x s) (ball y s) :=\n  by\n  rw [nhds_prod_eq]\n  apply (has_basis_nhds x).prod_same_index (has_basis_nhds y)\n  rintro U V ⟨U_in, U_symm⟩ ⟨V_in, V_symm⟩\n  exact\n    ⟨U ∩ V, ⟨((uniformity) α).inter_sets U_in V_in, U_symm.inter V_symm⟩, ball_inter_left x U V, ball_inter_right y U V⟩\n#align uniform_space.has_basis_nhds_prod UniformSpace.hasBasis_nhds_prod\n-/\n\n",
 "hasBasis_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print UniformSpace.hasBasis_nhds /-\ntheorem UniformSpace.hasBasis_nhds (x : α) :\n    HasBasis ((nhds) x) (fun s : Set (α × α) => s ∈ (uniformity) α ∧ SymmetricRel s) fun s => ball x s :=\n  ⟨fun t => by simp [UniformSpace.mem_nhds_iff_symm, and_assoc']⟩\n#align uniform_space.has_basis_nhds UniformSpace.hasBasis_nhds\n-/\n\n",
 "exists_uniform_thickening_of_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print Disjoint.exists_uniform_thickening_of_basis /-\ntheorem Disjoint.exists_uniform_thickening_of_basis {p : ι → Prop} {s : ι → Set (α × α)}\n    (hU : ((uniformity) α).has_basis p s) {A B : Set α} (hA : IsCompact A) (hB : IsClosed B) (h : Disjoint A B) :\n    ∃ i,\n      p i ∧\n        Disjoint\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (ball x (s i)))\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (ball x (s i))) :=\n  by\n  rcases h.exists_uniform_thickening hA hB with ⟨V, hV, hVAB⟩\n  rcases hU.mem_iff.1 hV with ⟨i, hi, hiV⟩\n  exact ⟨i, hi, hVAB.mono (Union₂_mono fun a _ => ball_mono hiV a) (Union₂_mono fun b _ => ball_mono hiV b)⟩\n#align disjoint.exists_uniform_thickening_of_basis Disjoint.exists_uniform_thickening_of_basis\n-/\n\n",
 "exists_uniform_thickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print Disjoint.exists_uniform_thickening /-\ntheorem Disjoint.exists_uniform_thickening {A B : Set α} (hA : IsCompact A) (hB : IsClosed B) (h : Disjoint A B) :\n    ∃ V ∈ (uniformity) α,\n      Disjoint\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (ball x V))\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (ball x V)) :=\n  by\n  have : «expr ᶜ» B ∈ (nhds_set) A := hB.is_open_compl.mem_nhds_set.mpr h.le_compl_right\n  rw [(hA.nhds_set_basis_uniformity (Filter.basis_sets _)).mem_iff] at this\n  rcases this with ⟨U, hU, hUAB⟩\n  rcases comp_symm_mem_uniformity_sets hU with ⟨V, hV, hVsymm, hVU⟩\n  refine' ⟨V, hV, set.disjoint_left.mpr fun x => _⟩\n  simp only [mem_Union₂]\n  rintro ⟨a, ha, hxa⟩ ⟨b, hb, hxb⟩\n  rw [mem_ball_symmetry hVsymm] at hxa hxb\n  exact hUAB (mem_Union₂_of_mem ha <| hVU <| mem_comp_of_mem_ball hVsymm hxa hxb) hb\n#align disjoint.exists_uniform_thickening Disjoint.exists_uniform_thickening\n-/\n\n",
 "exists_mem_nhds_ball_subset_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print exists_mem_nhds_ball_subset_of_mem_nhds /-\ntheorem exists_mem_nhds_ball_subset_of_mem_nhds {a : α} {U : Set α} (h : U ∈ (nhds) a) :\n    ∃ V ∈ (nhds) a, ∃ t ∈ (uniformity) α, ∀ a' ∈ V, UniformSpace.ball a' t ⊆ U :=\n  let ⟨t, ht, htU⟩ := comp_mem_uniformity_sets (mem_nhds_uniformity_iff_right.1 h)\n  ⟨_, mem_nhds_left a ht, t, ht, fun a₁ h₁ a₂ h₂ => @htU (a, a₂) ⟨a₁, h₁, h₂⟩ rfl⟩\n#align exists_mem_nhds_ball_subset_of_mem_nhds exists_mem_nhds_ball_subset_of_mem_nhds\n-/\n\n",
 "eventually_uniformity_iterate_comp_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `uniformity.comp_rel -/\n#print eventually_uniformity_iterate_comp_subset /-\n/-- If `s ∈ 𝓤 α`, then for any natural `n`, for a subset `t` of a sufficiently small set in `𝓤 α`,\nwe have `t ○ t ○ ... ○ t ⊆ s` (`n` compositions). -/\ntheorem eventually_uniformity_iterate_comp_subset {s : Set (α × α)} (hs : s ∈ (uniformity) α) (n : ℕ) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((uniformity) α).small_sets ((«expr ^[ ]» ((uniformity.comp_rel · ·) t) n) t ⊆ s) :=\n  by\n  suffices :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((uniformity) α).small_sets (t ⊆ s ∧ («expr ^[ ]» ((uniformity.comp_rel · ·) t) n) t ⊆ s)\n  exact (eventually_and.1 this).2\n  induction' n with n ihn generalizing s; · simpa\n  rcases comp_mem_uniformity_sets hs with ⟨t, htU, hts⟩\n  refine' (ihn htU).mono fun U hU => _\n  rw [Function.iterate_succ_apply']\n  exact ⟨hU.1.trans <| (subset_comp_self <| refl_le_uniformity htU).trans hts, (compRel_mono hU.1 hU.2).trans hts⟩\n#align eventually_uniformity_iterate_comp_subset eventually_uniformity_iterate_comp_subset\n-/\n\n",
 "eventually_uniformity_comp_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print eventually_uniformity_comp_subset /-\n/-- If `s ∈ 𝓤 α`, then for any natural `n`, for a subset `t` of a sufficiently small set in `𝓤 α`,\nwe have `t ○ t ⊆ s`. -/\ntheorem eventually_uniformity_comp_subset {s : Set (α × α)} (hs : s ∈ (uniformity) α) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((uniformity) α).small_sets (uniformity.comp_rel t t ⊆ s) :=\n  eventually_uniformity_iterate_comp_subset hs 1\n#align eventually_uniformity_comp_subset eventually_uniformity_comp_subset\n-/\n\n",
 "eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print SymmetricRel.eq /-\ntheorem SymmetricRel.eq {U : Set (α × α)} (hU : SymmetricRel U) : «expr ⁻¹' » Prod.swap U = U :=\n  hU\n#align symmetric_rel.eq SymmetricRel.eq\n-/\n\n",
 "discreteTopology_of_discrete_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print discreteTopology_of_discrete_uniformity /-\n/-- A uniform space with the discrete uniformity has the discrete topology. -/\ntheorem discreteTopology_of_discrete_uniformity [hα : UniformSpace α] (h : uniformity α = (filter.principal) idRel) :\n    DiscreteTopology α :=\n  ⟨(uniformSpace_eq h.symm : «expr⊥» = hα) ▸ rfl⟩\n#align discrete_topology_of_discrete_uniformity discreteTopology_of_discrete_uniformity\n-/\n\n",
 "core_eq":
 "#print UniformSpace.core_eq /-\ntheorem UniformSpace.core_eq : ∀ {u₁ u₂ : UniformSpace.Core α}, u₁.uniformity = u₂.uniformity → u₁ = u₂\n  | ⟨u₁, _, _, _⟩, ⟨u₂, _, _, _⟩, rfl => by congr\n#align uniform_space.core_eq UniformSpace.core_eq\n-/\n\n",
 "continuous_within_at_iff'_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_within_at_iff'_right [TopologicalSpace β] {f : β → α} {b : β} {s : Set β} :\n    ContinuousWithinAt f s b ↔ Tendsto (fun x => (f b, f x)) (nhds_within s b) ((uniformity) α) := by\n  rw [ContinuousWithinAt, tendsto_nhds_right]\n#align continuous_within_at_iff'_right continuous_within_at_iff'_right\n\n",
 "continuous_within_at_iff'_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_within_at_iff'_left [TopologicalSpace β] {f : β → α} {b : β} {s : Set β} :\n    ContinuousWithinAt f s b ↔ Tendsto (fun x => (f x, f b)) (nhds_within s b) ((uniformity) α) := by\n  rw [ContinuousWithinAt, tendsto_nhds_left]\n#align continuous_within_at_iff'_left continuous_within_at_iff'_left\n\n",
 "continuous_on_iff'_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_on_iff'_right [TopologicalSpace β] {f : β → α} {s : Set β} :\n    ContinuousOn f s ↔ ∀ b ∈ s, Tendsto (fun x => (f b, f x)) (nhds_within s b) ((uniformity) α) := by\n  simp [ContinuousOn, continuous_within_at_iff'_right]\n#align continuous_on_iff'_right continuous_on_iff'_right\n\n",
 "continuous_on_iff'_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_on_iff'_left [TopologicalSpace β] {f : β → α} {s : Set β} :\n    ContinuousOn f s ↔ ∀ b ∈ s, Tendsto (fun x => (f x, f b)) (nhds_within s b) ((uniformity) α) := by\n  simp [ContinuousOn, continuous_within_at_iff'_left]\n#align continuous_on_iff'_left continuous_on_iff'_left\n\n",
 "continuous_iff'_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_iff'_right [TopologicalSpace β] {f : β → α} :\n    Continuous f ↔ ∀ b, Tendsto (fun x => (f b, f x)) ((nhds) b) ((uniformity) α) :=\n  continuous_iff_continuousAt.trans <| forall_congr' fun b => tendsto_nhds_right\n#align continuous_iff'_right continuous_iff'_right\n\n",
 "continuous_iff'_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_iff'_left [TopologicalSpace β] {f : β → α} :\n    Continuous f ↔ ∀ b, Tendsto (fun x => (f x, f b)) ((nhds) b) ((uniformity) α) :=\n  continuous_iff_continuousAt.trans <| forall_congr' fun b => tendsto_nhds_left\n#align continuous_iff'_left continuous_iff'_left\n\n",
 "continuous_at_iff_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_at_iff_prod [TopologicalSpace β] {f : β → α} {b : β} :\n    ContinuousAt f b ↔ Tendsto (fun x : β × β => (f x.1, f x.2)) ((nhds) (b, b)) ((uniformity) α) :=\n  ⟨fun H => le_trans (H.prod_map' H) (nhds_le_uniformity _), fun H =>\n    continuousAt_iff'_left.2 <| H.comp <| tendsto_id.prod_mk_nhds tendsto_const_nhds⟩\n#align continuous_at_iff_prod continuous_at_iff_prod\n\n",
 "continuous_at_iff'_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_at_iff'_right [TopologicalSpace β] {f : β → α} {b : β} :\n    ContinuousAt f b ↔ Tendsto (fun x => (f b, f x)) ((nhds) b) ((uniformity) α) := by\n  rw [ContinuousAt, tendsto_nhds_right]\n#align continuous_at_iff'_right continuous_at_iff'_right\n\n",
 "continuous_at_iff'_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_at_iff'_left [TopologicalSpace β] {f : β → α} {b : β} :\n    ContinuousAt f b ↔ Tendsto (fun x => (f x, f b)) ((nhds) b) ((uniformity) α) := by\n  rw [ContinuousAt, tendsto_nhds_left]\n#align continuous_at_iff'_left continuous_at_iff'_left\n\n",
 "continuousOn":
 "#print UniformContinuousOn.continuousOn /-\ntheorem UniformContinuousOn.continuousOn [UniformSpace α] [UniformSpace β] {f : α → β} {s : Set α}\n    (h : UniformContinuousOn f s) : ContinuousOn f s :=\n  by\n  rw [uniformContinuousOn_iff_restrict] at h\n  rw [continuousOn_iff_continuous_restrict]\n  exact h.continuous\n#align uniform_continuous_on.continuous_on UniformContinuousOn.continuousOn\n-/\n\n",
 "continuous":
 "#print UniformContinuous.continuous /-\ntheorem UniformContinuous.continuous [UniformSpace α] [UniformSpace β] {f : α → β} (hf : UniformContinuous f) :\n    Continuous f :=\n  continuous_iff_le_induced.mpr <| toTopologicalSpace_mono <| uniformContinuous_iff.1 hf\n#align uniform_continuous.continuous UniformContinuous.continuous\n-/\n\n",
 "congr_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.congr_uniformity /-\ntheorem Filter.Tendsto.congr_uniformity {α β} [UniformSpace β] {f g : α → β} {l : Filter α} {b : β}\n    (hf : Tendsto f l ((nhds) b)) (hg : Tendsto (fun x => (f x, g x)) l ((uniformity) β)) : Tendsto g l ((nhds) b) :=\n  Uniform.tendsto_nhds_right.2 <| (Uniform.tendsto_nhds_right.1 hf).uniformity_trans hg\n#align filter.tendsto.congr_uniformity Filter.Tendsto.congr_uniformity\n-/\n\n",
 "comp_symm_of_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print comp_symm_of_uniformity /-\ntheorem comp_symm_of_uniformity {s : Set (α × α)} (hs : s ∈ (uniformity) α) :\n    ∃ t ∈ (uniformity) α, (∀ {a b}, (a, b) ∈ t → (b, a) ∈ t) ∧ uniformity.comp_rel t t ⊆ s :=\n  let ⟨t, ht₁, ht₂⟩ := comp_mem_uniformity_sets hs\n  let ⟨t', ht', ht'₁, ht'₂⟩ := symm_of_uniformity ht₁\n  ⟨t', ht', ht'₁, Subset.trans (monotone_id.comp_rel monotone_id ht'₂) ht₂⟩\n#align comp_symm_of_uniformity comp_symm_of_uniformity\n-/\n\n",
 "comp_symm_mem_uniformity_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print comp_symm_mem_uniformity_sets /-\n/-- See also `comp_open_symm_mem_uniformity_sets`. -/\ntheorem comp_symm_mem_uniformity_sets {s : Set (α × α)} (hs : s ∈ (uniformity) α) :\n    ∃ t ∈ (uniformity) α, SymmetricRel t ∧ uniformity.comp_rel t t ⊆ s :=\n  by\n  obtain ⟨w, w_in, w_sub⟩ : ∃ w ∈ (uniformity) α, uniformity.comp_rel w w ⊆ s := comp_mem_uniformity_sets hs\n  use symmetrizeRel w, symmetrize_mem_uniformity w_in, symmetric_symmetrizeRel w\n  have : symmetrizeRel w ⊆ w := symmetrizeRel_subset_self w\n  calc\n    uniformity.comp_rel (symmetrizeRel w) (symmetrizeRel w) ⊆ uniformity.comp_rel w w := by mono\n    _ ⊆ s := w_sub\n    \n#align comp_symm_mem_uniformity_sets comp_symm_mem_uniformity_sets\n-/\n\n",
 "comp_open_symm_mem_uniformity_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print comp_open_symm_mem_uniformity_sets /-\ntheorem comp_open_symm_mem_uniformity_sets {s : Set (α × α)} (hs : s ∈ (uniformity) α) :\n    ∃ t ∈ (uniformity) α, IsOpen t ∧ SymmetricRel t ∧ uniformity.comp_rel t t ⊆ s :=\n  by\n  obtain ⟨t, ht₁, ht₂⟩ := comp_mem_uniformity_sets hs\n  obtain ⟨u, ⟨hu₁, hu₂, hu₃⟩, hu₄ : u ⊆ t⟩ := uniformity_has_basis_open_symmetric.mem_iff.mp ht₁\n  exact ⟨u, hu₁, hu₂, hu₃, (compRel_mono hu₄ hu₄).trans ht₂⟩\n#align comp_open_symm_mem_uniformity_sets comp_open_symm_mem_uniformity_sets\n-/\n\n",
 "comp_mem_uniformity_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print comp_mem_uniformity_sets /-\ntheorem comp_mem_uniformity_sets {s : Set (α × α)} (hs : s ∈ (uniformity) α) :\n    ∃ t ∈ (uniformity) α, uniformity.comp_rel t t ⊆ s :=\n  have : s ∈ ((uniformity) α).lift' fun t : Set (α × α) => uniformity.comp_rel t t := comp_le_uniformity hs\n  (mem_lift'_sets <| monotone_id.comp_rel monotone_id).mp this\n#align comp_mem_uniformity_sets comp_mem_uniformity_sets\n-/\n\n",
 "comp_le_uniformity3":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print comp_le_uniformity3 /-\ntheorem comp_le_uniformity3 :\n    (((uniformity) α).lift' fun s : Set (α × α) => uniformity.comp_rel s (uniformity.comp_rel s s)) ≤ (uniformity) α :=\n  calc\n    (((uniformity) α).lift' fun d => uniformity.comp_rel d (uniformity.comp_rel d d)) =\n        ((uniformity) α).lift fun s =>\n          ((uniformity) α).lift' fun t : Set (α × α) => uniformity.comp_rel s (uniformity.comp_rel t t) :=\n      by\n      rw [lift_lift'_same_eq_lift']\n      exact fun x => monotone_const.comp_rel <| monotone_id.comp_rel monotone_id\n      exact fun x => monotone_id.comp_rel monotone_const\n    _ ≤ ((uniformity) α).lift fun s => ((uniformity) α).lift' fun t : Set (α × α) => uniformity.comp_rel s t :=\n      (lift_mono' fun s hs =>\n        @uniformity_lift_le_comp α _ _ (filter.principal ∘ (uniformity.comp_rel · ·) s) <|\n          monotone_principal.comp (monotone_const.comp_rel monotone_id))\n    _ = ((uniformity) α).lift' fun s : Set (α × α) => uniformity.comp_rel s s :=\n      (lift_lift'_same_eq_lift' (fun s => monotone_const.comp_rel monotone_id) fun s =>\n        monotone_id.comp_rel monotone_const)\n    _ ≤ (uniformity) α := comp_le_uniformity\n    \n#align comp_le_uniformity3 comp_le_uniformity3\n-/\n\n",
 "comp_le_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print comp_le_uniformity /-\ntheorem comp_le_uniformity : (((uniformity) α).lift' fun s : Set (α × α) => uniformity.comp_rel s s) ≤ (uniformity) α :=\n  (@uniform_space.to_core α _).comp\n#align comp_le_uniformity comp_le_uniformity\n-/\n\n",
 "comp_comp_symm_mem_uniformity_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print comp_comp_symm_mem_uniformity_sets /-\ntheorem comp_comp_symm_mem_uniformity_sets {s : Set (α × α)} (hs : s ∈ (uniformity) α) :\n    ∃ t ∈ (uniformity) α, SymmetricRel t ∧ uniformity.comp_rel (uniformity.comp_rel t t) t ⊆ s :=\n  by\n  rcases comp_symm_mem_uniformity_sets hs with ⟨w, w_in, w_symm, w_sub⟩\n  rcases comp_symm_mem_uniformity_sets w_in with ⟨t, t_in, t_symm, t_sub⟩\n  use t, t_in, t_symm\n  have : t ⊆ uniformity.comp_rel t t := subset_comp_self_of_mem_uniformity t_in\n  calc\n    uniformity.comp_rel (uniformity.comp_rel t t) t ⊆ uniformity.comp_rel w t := by mono\n    _ ⊆ uniformity.comp_rel w (uniformity.comp_rel t t) := by mono\n    _ ⊆ uniformity.comp_rel w w := by mono\n    _ ⊆ s := w_sub\n    \n#align comp_comp_symm_mem_uniformity_sets comp_comp_symm_mem_uniformity_sets\n-/\n\n",
 "compRel_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print compRel_mono /-\n@[mono]\ntheorem compRel_mono {f g h k : Set (α × α)} (h₁ : f ⊆ h) (h₂ : g ⊆ k) :\n    uniformity.comp_rel f g ⊆ uniformity.comp_rel h k := fun ⟨x, y⟩ ⟨z, h, h'⟩ => ⟨z, h₁ h, h₂ h'⟩\n#align comp_rel_mono compRel_mono\n-/\n\n",
 "compRel_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print compRel_assoc /-\ntheorem compRel_assoc {r s t : Set (α × α)} :\n    uniformity.comp_rel (uniformity.comp_rel r s) t = uniformity.comp_rel r (uniformity.comp_rel s t) := by\n  ext p <;> cases p <;> simp only [mem_compRel] <;> tauto\n#align comp_rel_assoc compRel_assoc\n-/\n\n",
 "compRel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print Monotone.compRel /-\ntheorem Monotone.compRel [preorder β] {f g : β → Set (α × α)} (hf : Monotone f) (hg : Monotone g) :\n    Monotone fun x => uniformity.comp_rel (f x) (g x) := fun a b h p ⟨z, h₁, h₂⟩ => ⟨z, hf h h₁, hg h h₂⟩\n#align monotone.comp_rel Monotone.compRel\n-/\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘₂ » -/\n#print UniformContinuous₂.comp /-\ntheorem UniformContinuous₂.comp {f : α → β → γ} {g : γ → δ} (hg : UniformContinuous g) (hf : UniformContinuous₂ f) :\n    UniformContinuous₂ («expr ∘₂ » g f) :=\n  hg.comp hf\n#align uniform_continuous₂.comp UniformContinuous₂.comp\n-/\n\n",
 "comap_uniformity_mulOpposite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print comap_uniformity_mulOpposite /-\n@[simp, to_additive]\ntheorem comap_uniformity_mulOpposite [UniformSpace α] :\n    comap (fun p : α × α => (MulOpposite.op p.1, MulOpposite.op p.2)) ((uniformity) («expr ᵐᵒᵖ» α)) = (uniformity) α :=\n  by simpa [uniformity_mulOpposite, comap_comap, (· ∘ ·)] using comap_id\n#align comap_uniformity_mul_opposite comap_uniformity_mulOpposite\n#align comap_uniformity_add_opposite comap_uniformity_addOpposite\n-/\n\n",
 "comap_swap_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print comap_swap_uniformity /-\n@[simp]\ntheorem comap_swap_uniformity : comap (@Prod.swap α α) ((uniformity) α) = (uniformity) α :=\n  (congr_arg _ uniformity_eq_symm).trans <| comap_map Prod.swap_injective\n#align comap_swap_uniformity comap_swap_uniformity\n-/\n\n",
 "comap_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print UniformSpace.comap_mono /-\ntheorem UniformSpace.comap_mono {α γ} {f : α → γ} : Monotone fun u : UniformSpace γ => u.comap f :=\n  by\n  intro u₁ u₂ hu\n  change (uniformity) _ ≤ (uniformity) _\n  rw [uniformity_comap]\n  exact comap_mono hu\n#align uniform_space.comap_mono UniformSpace.comap_mono\n-/\n\n",
 "comap_infᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print UniformSpace.comap_infᵢ /-\ntheorem UniformSpace.comap_infᵢ {ι α γ} {u : ι → UniformSpace γ} {f : α → γ} :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u i)).comap f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((u i).comap f) :=\n  by\n  ext : 1\n  simp [uniformity_comap, infᵢ_uniformity]\n#align uniform_space.comap_infi UniformSpace.comap_infᵢ\n-/\n\n",
 "comap_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print UniformSpace.comap_inf /-\ntheorem UniformSpace.comap_inf {α γ} {u₁ u₂ : UniformSpace γ} {f : α → γ} :\n    («expr ⊓ » u₁ u₂).comap f = «expr ⊓ » (u₁.comap f) (u₂.comap f) :=\n  uniformSpace_eq comap_inf\n#align uniform_space.comap_inf UniformSpace.comap_inf\n-/\n\n",
 "comap_comap":
 "#print UniformSpace.comap_comap /-\ntheorem UniformSpace.comap_comap {α β γ} [uγ : UniformSpace γ] {f : α → β} {g : β → γ} :\n    UniformSpace.comap (g ∘ f) uγ = UniformSpace.comap f (UniformSpace.comap g uγ) :=\n  by\n  ext1\n  simp only [uniformity_comap, comap_comap, Prod.map_comp_map]\n#align uniform_space.comap_comap UniformSpace.comap_comap\n-/\n\n",
 "closure_eq_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print closure_eq_uniformity /-\ntheorem closure_eq_uniformity (s : Set <| α × α) :\n    closure s =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (uniformity.comp_rel (uniformity.comp_rel V s) V) :=\n  by\n  ext ⟨x, y⟩\n  simp (config := { contextual := true }) only [mem_closure_iff_nhds_basis (UniformSpace.hasBasis_nhds_prod x y),\n    mem_Inter, mem_set_of_eq, and_imp, mem_comp_comp, exists_prop, ← mem_inter_iff, inter_comm, Set.Nonempty]\n#align closure_eq_uniformity closure_eq_uniformity\n-/\n\n",
 "closure_eq_inter_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print closure_eq_inter_uniformity /-\ntheorem closure_eq_inter_uniformity {t : Set (α × α)} :\n    closure t =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (uniformity.comp_rel d (uniformity.comp_rel t d)) :=\n  calc\n    closure t =\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (uniformity.comp_rel (uniformity.comp_rel V t) V) :=\n      closure_eq_uniformity t\n    _ =\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (uniformity.comp_rel (uniformity.comp_rel V t) V) :=\n      (Eq.symm <|\n        UniformSpace.hasBasis_symmetric.bInter_mem fun V₁ V₂ hV => compRel_mono (compRel_mono hV Subset.rfl) hV)\n    _ =\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (uniformity.comp_rel V (uniformity.comp_rel t V)) :=\n      by simp only [compRel_assoc]\n    \n#align closure_eq_inter_uniformity closure_eq_inter_uniformity\n-/\n\n",
 "bunionᵢ_uniformity_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print Dense.bunionᵢ_uniformity_ball /-\n/-- The uniform neighborhoods of all points of a dense set cover the whole space. -/\ntheorem Dense.bunionᵢ_uniformity_ball {s : Set α} {U : Set (α × α)} (hs : Dense s) (hU : U ∈ (uniformity) α) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (ball x U) = univ :=\n  by\n  refine' Union₂_eq_univ_iff.2 fun y => _\n  rcases hs.inter_nhds_nonempty (mem_nhds_right y hU) with ⟨x, hxs, hxy : (x, y) ∈ U⟩\n  exact ⟨x, hxs, hxy⟩\n#align dense.bUnion_uniformity_ball Dense.bunionᵢ_uniformity_ball\n-/\n\n",
 "binterᵢ_bunionᵢ_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print Filter.HasBasis.binterᵢ_bunionᵢ_ball /-\ntheorem Filter.HasBasis.binterᵢ_bunionᵢ_ball {p : ι → Prop} {U : ι → Set (α × α)} (h : HasBasis ((uniformity) α) p U)\n    (s : Set α) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (ball x (U i))) =\n      closure s :=\n  by\n  ext x\n  simp [mem_closure_iff_nhds_basis (nhds_basis_uniformity h), ball]\n#align filter.has_basis.bInter_bUnion_ball Filter.HasBasis.binterᵢ_bunionᵢ_ball\n-/\n\n",
 "bicompl":
 "#print UniformContinuous₂.bicompl /-\ntheorem UniformContinuous₂.bicompl {f : α → β → γ} {ga : δ → α} {gb : δ' → β} (hf : UniformContinuous₂ f)\n    (hga : UniformContinuous ga) (hgb : UniformContinuous gb) : UniformContinuous₂ (bicompl f ga gb) :=\n  hf.uniform_continuous.comp (hga.prod_map hgb)\n#align uniform_continuous₂.bicompl UniformContinuous₂.bicompl\n-/\n\n",
 "ball_subset_of_comp_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n#print ball_subset_of_comp_subset /-\ntheorem ball_subset_of_comp_subset {V W : Set (β × β)} {x y} (h : x ∈ ball y W) (h' : uniformity.comp_rel W W ⊆ V) :\n    ball x W ⊆ ball y V := fun z z_in => h' (mem_ball_comp h z_in)\n#align ball_subset_of_comp_subset ball_subset_of_comp_subset\n-/\n\n",
 "ball_mono":
 "#print ball_mono /-\ntheorem ball_mono {V W : Set (β × β)} (h : V ⊆ W) (x : β) : ball x V ⊆ ball x W :=\n  preimage_mono h\n#align ball_mono ball_mono\n-/\n\n",
 "ball_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print UniformSpace.ball_mem_nhds /-\ntheorem UniformSpace.ball_mem_nhds (x : α) ⦃V : Set (α × α)⦄ (V_in : V ∈ (uniformity) α) : ball x V ∈ (nhds) x :=\n  by\n  rw [UniformSpace.mem_nhds_iff]\n  exact ⟨V, V_in, subset.refl _⟩\n#align uniform_space.ball_mem_nhds UniformSpace.ball_mem_nhds\n-/\n\n",
 "ball_inter_right":
 "#print ball_inter_right /-\ntheorem ball_inter_right (x : β) (V W : Set (β × β)) : ball x (V ∩ W) ⊆ ball x W :=\n  ball_mono (inter_subset_right V W) x\n#align ball_inter_right ball_inter_right\n-/\n\n",
 "ball_inter_left":
 "#print ball_inter_left /-\ntheorem ball_inter_left (x : β) (V W : Set (β × β)) : ball x (V ∩ W) ⊆ ball x V :=\n  ball_mono (inter_subset_left V W) x\n#align ball_inter_left ball_inter_left\n-/\n\n",
 "ball_inter":
 "#print ball_inter /-\ntheorem ball_inter (x : β) (V W : Set (β × β)) : ball x (V ∩ W) = ball x V ∩ ball x W :=\n  preimage_inter\n#align ball_inter ball_inter\n-/\n\n",
 "ball_eq_of_symmetry":
 "#print ball_eq_of_symmetry /-\ntheorem ball_eq_of_symmetry {V : Set (β × β)} (hV : SymmetricRel V) {x} : ball x V = { y | (y, x) ∈ V } :=\n  by\n  ext y\n  rw [mem_ball_symmetry hV]\n  exact iff.rfl\n#align ball_eq_of_symmetry ball_eq_of_symmetry\n-/\n\n"}