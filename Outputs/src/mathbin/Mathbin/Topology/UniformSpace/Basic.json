{"union_mem_uniformity_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\nof the diagonal. -/\ntheorem union_mem_uniformity_sum {a : set (α × α)} (ha : a ∈ (uniformity) α) {b : set (β × β)}\n    (hb : b ∈ (uniformity) β) :\n    «expr '' » (fun p : α × α => (inl p.1, inl p.2)) a ∪ «expr '' » (fun p : β × β => (inr p.1, inr p.2)) b ∈\n      (@uniform_space.core.sum α β _ _).uniformity :=\n  ⟨mem_map_iff_exists_image.2 ⟨_, ha, subset_union_left _ _⟩,\n    mem_map_iff_exists_image.2 ⟨_, hb, subset_union_right _ _⟩⟩\n#align union_mem_uniformity_sum union_mem_uniformity_sum\n\n",
 "uniformity_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Relation `λ f g, tendsto (λ x, (f x, g x)) l (𝓤 α)` is transitive. -/\ntheorem filter.tendsto.uniformity_trans {l : filter β} {f₁ f₂ f₃ : β → α}\n    (h₁₂ : tendsto (fun x => (f₁ x, f₂ x)) l ((uniformity) α))\n    (h₂₃ : tendsto (fun x => (f₂ x, f₃ x)) l ((uniformity) α)) : tendsto (fun x => (f₁ x, f₃ x)) l ((uniformity) α) :=\n  by\n  refine' le_trans (le_lift'.2 fun s hs => mem_map.2 _) comp_le_uniformity\n  filter_upwards [h₁₂ hs, h₂₃ hs] with x hx₁₂ hx₂₃ using⟨_, hx₁₂, hx₂₃⟩\n#align filter.tendsto.uniformity_trans filter.tendsto.uniformity_trans\n\n",
 "uniformity_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Relation `λ f g, tendsto (λ x, (f x, g x)) l (𝓤 α)` is symmetric -/\ntheorem filter.tendsto.uniformity_symm {l : filter β} {f : β → α × α} (h : tendsto f l ((uniformity) α)) :\n    tendsto (fun x => ((f x).2, (f x).1)) l ((uniformity) α) :=\n  tendsto_swap_uniformity.comp h\n#align filter.tendsto.uniformity_symm filter.tendsto.uniformity_symm\n\n",
 "uniformity_sum_of_open_aux":
 "/- To prove that the topology defined by the uniform structure on the disjoint union coincides with\nthe disjoint union topology, we need two lemmas saying that open sets can be characterized by\nthe uniform structure -/\ntheorem uniformity_sum_of_open_aux {s : set (Sum α β)} (hs : is_open s) {x : Sum α β} (xs : x ∈ s) :\n    { p : Sum α β × Sum α β | p.1 = x → p.2 ∈ s } ∈ (@uniform_space.core.sum α β _ _).uniformity :=\n  by\n  cases x\n  · refine'\n        mem_of_superset (union_mem_uniformity_sum (mem_nhds_uniformity_iff_right.1 (is_open.mem_nhds hs.1 xs)) univ_mem)\n          (union_subset _ _) <;>\n      rintro _ ⟨⟨_, b⟩, h, ⟨⟩⟩ ⟨⟩\n    exact h rfl\n  · refine'\n        mem_of_superset (union_mem_uniformity_sum univ_mem (mem_nhds_uniformity_iff_right.1 (is_open.mem_nhds hs.2 xs)))\n          (union_subset _ _) <;>\n      rintro _ ⟨⟨a, _⟩, h, ⟨⟩⟩ ⟨⟩\n    exact h rfl\n#align uniformity_sum_of_open_aux uniformity_sum_of_open_aux\n\n",
 "uniformity_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_subtype {p : α → Prop} [t : uniform_space α] :\n    (uniformity) (subtype p) = comap (fun q : subtype p × subtype p => (q.1.1, q.2.1)) ((uniformity) α) :=\n  rfl\n#align uniformity_subtype uniformity_subtype\n\n",
 "uniformity_prod_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_prod_eq_prod [uniform_space α] [uniform_space β] :\n    (uniformity) (α × β) =\n      map (fun p : (α × α) × β × β => ((p.1.1, p.2.1), (p.1.2, p.2.2)))\n        (filter.prod ((uniformity) α) ((uniformity) β)) :=\n  by rw [map_swap4_eq_comap, uniformity_prod_eq_comap_prod]\n#align uniformity_prod_eq_prod uniformity_prod_eq_prod\n\n",
 "uniformity_prod_eq_comap_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_prod_eq_comap_prod [uniform_space α] [uniform_space β] :\n    (uniformity) (α × β) =\n      comap (fun p : (α × β) × α × β => ((p.1.1, p.2.1), (p.1.2, p.2.2)))\n        (filter.prod ((uniformity) α) ((uniformity) β)) :=\n  by rw [uniformity_prod, filter.prod, comap_inf, comap_comap, comap_comap]\n#align uniformity_prod_eq_comap_prod uniformity_prod_eq_comap_prod\n\n",
 "uniformity_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- a similar product space is possible on the function space (uniformity of pointwise convergence),\n  but we want to have the uniformity of uniform convergence on function spaces -/\n-- check the above produces no diamond\ntheorem uniformity_prod [uniform_space α] [uniform_space β] :\n    (uniformity) (α × β) =\n      «expr ⊓ » (((uniformity) α).comap fun p : (α × β) × α × β => (p.1.1, p.2.1))\n        (((uniformity) β).comap fun p : (α × β) × α × β => (p.1.2, p.2.2)) :=\n  rfl\n#align uniformity_prod uniformity_prod\n\n",
 "uniformity_multiplicative":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_multiplicative : (uniformity) (Multiplicative α) = ((uniformity) α).map (prod.map ofAdd ofAdd) :=\n  by\n  convert map_id.symm\n  exact prod.map_id\n#align uniformity_multiplicative uniformity_multiplicative\n\n",
 "uniformity_mul_opposite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n@[to_additive]\ntheorem uniformity_mul_opposite [uniform_space α] :\n    (uniformity) («expr ᵐᵒᵖ» α) =\n      comap (fun q : «expr ᵐᵒᵖ» α × «expr ᵐᵒᵖ» α => (q.1.unop, q.2.unop)) ((uniformity) α) :=\n  rfl\n#align uniformity_mul_opposite uniformity_mul_opposite\n\n",
 "uniformity_lift_le_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_lift_le_swap {g : set (α × α) → filter β} {f : filter β} (hg : monotone g)\n    (h : (((uniformity) α).lift fun s => g (preimage prod.swap s)) ≤ f) : ((uniformity) α).lift g ≤ f :=\n  calc\n    ((uniformity) α).lift g ≤ (filter.map (@prod.swap α α) <| (uniformity) α).lift g :=\n      lift_mono uniformity_le_symm le_rfl\n    _ ≤ _ := by rw [map_lift_eq2 hg, image_swap_eq_preimage_swap] <;> exact h\n    \n#align uniformity_lift_le_swap uniformity_lift_le_swap\n\n",
 "uniformity_lift_le_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_lift_le_comp {f : set (α × α) → filter β} (h : monotone f) :\n    (((uniformity) α).lift fun s => f (uniformity.comp_rel s s)) ≤ ((uniformity) α).lift f :=\n  calc\n    (((uniformity) α).lift fun s => f (uniformity.comp_rel s s)) =\n        (((uniformity) α).lift' fun s : set (α × α) => uniformity.comp_rel s s).lift f :=\n      by\n      rw [lift_lift'_assoc]\n      exact monotone_comp_rel monotone_id monotone_id\n      exact h\n    _ ≤ ((uniformity) α).lift f := lift_mono comp_le_uniformity le_rfl\n    \n#align uniformity_lift_le_comp uniformity_lift_le_comp\n\n",
 "uniformity_le_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_le_symm : (uniformity) α ≤ @prod.swap α α <$> (uniformity) α := by\n  rw [map_swap_eq_comap_swap] <;> exact map_le_iff_le_comap.1 tendsto_swap_uniformity\n#align uniformity_le_symm uniformity_le_symm\n\n",
 "uniformity_has_basis_open_symmetric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Open elements `s : set (α × α)` of `𝓤 α` such that `(x, y) ∈ s ↔ (y, x) ∈ s` form a basis\nof `𝓤 α`. -/\ntheorem uniformity_has_basis_open_symmetric :\n    has_basis ((uniformity) α) (fun V : set (α × α) => V ∈ (uniformity) α ∧ is_open V ∧ symmetric_rel V) id :=\n  by\n  simp only [← and_assoc']\n  refine' uniformity_has_basis_open.restrict fun s hs => ⟨symmetrize_rel s, _⟩\n  exact\n    ⟨⟨symmetrize_mem_uniformity hs.1, is_open.inter hs.2 (hs.2.preimage continuous_swap)⟩, symmetric_symmetrize_rel s,\n      symmetrize_rel_subset_self s⟩\n#align uniformity_has_basis_open_symmetric uniformity_has_basis_open_symmetric\n\n",
 "uniformity_has_basis_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Open elements of `𝓤 α` form a basis of `𝓤 α`. -/\ntheorem uniformity_has_basis_open :\n    has_basis ((uniformity) α) (fun V : set (α × α) => V ∈ (uniformity) α ∧ is_open V) id :=\n  has_basis_self.2 fun s hs => ⟨interior s, interior_mem_uniformity hs, is_open_interior, interior_subset⟩\n#align uniformity_has_basis_open uniformity_has_basis_open\n\n",
 "uniformity_has_basis_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Closed entourages form a basis of the uniformity filter. -/\ntheorem uniformity_has_basis_closure : has_basis ((uniformity) α) (fun V : set (α × α) => V ∈ (uniformity) α) closure :=\n  ((uniformity) α).basis_sets.uniformity_closure\n#align uniformity_has_basis_closure uniformity_has_basis_closure\n\n",
 "uniformity_has_basis_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_has_basis_closed :\n    has_basis ((uniformity) α) (fun V : set (α × α) => V ∈ (uniformity) α ∧ is_closed V) id :=\n  by\n  refine' filter.has_basis_self.2 fun t h => _\n  rcases comp_comp_symm_mem_uniformity_sets h with ⟨w, w_in, w_symm, r⟩\n  refine' ⟨closure w, mem_of_superset w_in subset_closure, is_closed_closure, _⟩\n  refine' subset.trans _ r\n  rw [closure_eq_uniformity]\n  apply Inter_subset_of_subset\n  apply Inter_subset\n  exact ⟨w_in, w_symm⟩\n#align uniformity_has_basis_closed uniformity_has_basis_closed\n\n",
 "uniformity_eq_uniformity_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_eq_uniformity_interior : (uniformity) α = ((uniformity) α).lift' interior :=\n  le_antisymm\n    (le_infᵢ fun d =>\n      le_infᵢ fun hd =>\n        by\n        let ⟨s, hs, hs_comp⟩ :=\n          (mem_lift'_sets <| monotone_comp_rel monotone_id <| monotone_comp_rel monotone_id monotone_id).mp\n            (comp_le_uniformity3 hd)\n        let ⟨t, ht, hst, ht_comp⟩ := nhdset_of_mem_uniformity s hs\n        have : s ⊆ interior d :=\n          calc\n            s ⊆ t := hst\n            _ ⊆ interior d :=\n              ht.subset_interior_iff.mpr fun x (hx : x ∈ t) =>\n                let ⟨x, y, h₁, h₂, h₃⟩ := ht_comp hx\n                hs_comp ⟨x, h₁, y, h₂, h₃⟩\n            \n        have : interior d ∈ (uniformity) α := by filter_upwards [hs] using this\n        simp [this])\n    fun s hs => (((uniformity) α).lift' interior).sets_of_superset (mem_lift' hs) interior_subset\n#align uniformity_eq_uniformity_interior uniformity_eq_uniformity_interior\n\n",
 "uniformity_eq_uniformity_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_eq_uniformity_closure : (uniformity) α = ((uniformity) α).lift' closure :=\n  eq.symm <| uniformity_has_basis_closed.lift'_closure_eq_self fun _ => And.right\n#align uniformity_eq_uniformity_closure uniformity_eq_uniformity_closure\n\n",
 "uniformity_eq_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_eq_symm : (uniformity) α = @prod.swap α α <$> (uniformity) α :=\n  le_antisymm uniformity_le_symm symm_le_uniformity\n#align uniformity_eq_symm uniformity_eq_symm\n\n",
 "uniformity_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_comap [uniform_space α] [uniform_space β] {f : α → β}\n    (h : ‹uniform_space α› = uniform_space.comap f ‹uniform_space β›) :\n    (uniformity) α = comap (prod.map f f) ((uniformity) β) :=\n  by\n  rw [h]\n  rfl\n#align uniformity_comap uniformity_comap\n\n",
 "uniformity_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem filter.has_basis.uniformity_closure {p : ι → Prop} {U : ι → set (α × α)} (h : ((uniformity) α).has_basis p U) :\n    ((uniformity) α).has_basis p fun i => closure (U i) :=\n  (@uniformity_eq_uniformity_closure α _).symm ▸ h.lift'_closure\n#align filter.has_basis.uniformity_closure filter.has_basis.uniformity_closure\n\n",
 "uniformity_additive":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniformity_additive : (uniformity) (Additive α) = ((uniformity) α).map (prod.map ofMul ofMul) :=\n  by\n  convert map_id.symm\n  exact prod.map_id\n#align uniformity_additive uniformity_additive\n\n",
 "uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n-- We can now define the uniform structure on the disjoint union\ntheorem sum.uniformity :\n    (uniformity) (Sum α β) =\n      «expr ⊔ » (map (fun p : α × α => (inl p.1, inl p.2)) ((uniformity) α))\n        (map (fun p : β × β => (inr p.1, inr p.2)) ((uniformity) β)) :=\n  rfl\n#align sum.uniformity sum.uniformity\n\n",
 "uniform_space_eq":
 "@[ext]\ntheorem uniform_space_eq : ∀ {u₁ u₂ : uniform_space α}, u₁.uniformity = u₂.uniformity → u₁ = u₂\n  | uniform_space.mk' t₁ u₁ o₁, uniform_space.mk' t₂ u₂ o₂, h =>\n    by\n    have : u₁ = u₂ := uniform_space.core_eq h\n    have : t₁ = t₂ := topological_space_eq <| funext fun s => by rw [o₁, o₂] <;> simp [this]\n    simp [*]\n#align uniform_space_eq uniform_space_eq\n\n",
 "uniform_space_comap_id":
 "theorem uniform_space_comap_id {α : Type _} : uniform_space.comap (id : α → α) = id := by\n  ext u <;> dsimp only [uniform_space.comap, id] <;> rw [prod.id_prod, filter.comap_id]\n#align uniform_space_comap_id uniform_space_comap_id\n\n",
 "uniform_continuous₂_def":
 "theorem uniform_continuous₂_def (f : α → β → γ) : uniform_continuous₂ f ↔ uniform_continuous (uncurry f) :=\n  iff.rfl\n#align uniform_continuous₂_def uniform_continuous₂_def\n\n",
 "uniform_continuous₂_curry":
 "theorem uniform_continuous₂_curry (f : α × β → γ) : uniform_continuous₂ (function.curry f) ↔ uniform_continuous f := by\n  rw [uniform_continuous₂, uncurry_curry]\n#align uniform_continuous₂_curry uniform_continuous₂_curry\n\n",
 "uniform_continuous_unop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[to_additive]\ntheorem uniform_continuous_unop [uniform_space α] : uniform_continuous (unop : «expr ᵐᵒᵖ» α → α) :=\n  uniform_continuous_comap\n#align uniform_continuous_unop uniform_continuous_unop\n\n",
 "uniform_continuous_to_mul":
 "theorem uniform_continuous_to_mul : uniform_continuous (toMul : Additive α → α) :=\n  uniform_continuous_id\n#align uniform_continuous_to_mul uniform_continuous_to_mul\n\n",
 "uniform_continuous_to_add":
 "theorem uniform_continuous_to_add : uniform_continuous (toAdd : Multiplicative α → α) :=\n  uniform_continuous_id\n#align uniform_continuous_to_add uniform_continuous_to_add\n\n",
 "uniform_continuous_subtype_val":
 "theorem uniform_continuous_subtype_val {p : α → Prop} [uniform_space α] :\n    uniform_continuous (subtype.val : { a : α // p a } → α) :=\n  uniform_continuous_comap\n#align uniform_continuous_subtype_val uniform_continuous_subtype_val\n\n",
 "uniform_continuous_subtype_coe":
 "theorem uniform_continuous_subtype_coe {p : α → Prop} [uniform_space α] :\n    uniform_continuous (coe : { a : α // p a } → α) :=\n  uniform_continuous_subtype_val\n#align uniform_continuous_subtype_coe uniform_continuous_subtype_coe\n\n",
 "uniform_continuous_snd":
 "theorem uniform_continuous_snd [uniform_space α] [uniform_space β] : uniform_continuous fun p : α × β => p.2 :=\n  tendsto_prod_uniformity_snd\n#align uniform_continuous_snd uniform_continuous_snd\n\n",
 "uniform_continuous_op":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[to_additive]\ntheorem uniform_continuous_op [uniform_space α] : uniform_continuous (op : α → «expr ᵐᵒᵖ» α) :=\n  uniform_continuous_comap' uniform_continuous_id\n#align uniform_continuous_op uniform_continuous_op\n\n",
 "uniform_continuous_on_univ":
 "theorem uniform_continuous_on_univ [uniform_space β] {f : α → β} :\n    uniform_continuous_on f univ ↔ uniform_continuous f := by\n  rw [uniform_continuous_on, uniform_continuous, univ_prod_univ, principal_univ, inf_top_eq]\n#align uniform_continuous_on_univ uniform_continuous_on_univ\n\n",
 "uniform_continuous_on_iff_restrict":
 "theorem uniform_continuous_on_iff_restrict [uniform_space α] [uniform_space β] {f : α → β} {s : set α} :\n    uniform_continuous_on f s ↔ uniform_continuous (s.restrict f) :=\n  by\n  unfold uniform_continuous_on Set.restrict uniform_continuous tendsto\n  rw [show (fun x : s × s => (f x.1, f x.2)) = prod.map f f ∘ coe by ext x <;> cases x <;> rfl, uniformity_comap rfl,\n    show prod.map subtype.val subtype.val = (coe : s × s → α × α) by ext x <;> cases x <;> rfl]\n  conv in map _ (comap _ _) => rw [← filter.map_map]\n  rw [subtype_coe_map_comap_prod]; rfl\n#align uniform_continuous_on_iff_restrict uniform_continuous_on_iff_restrict\n\n",
 "uniform_continuous_on_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x y «expr ∈ » S) -/\ntheorem filter.has_basis.uniform_continuous_on_iff [uniform_space β] {p : γ → Prop} {s : γ → set (α × α)}\n    (ha : ((uniformity) α).has_basis p s) {q : δ → Prop} {t : δ → set (β × β)} (hb : ((uniformity) β).has_basis q t)\n    {f : α → β} {S : set α} :\n    uniform_continuous_on f S ↔\n      ∀ (i) (hi : q i), ∃ (j : _)(hj : p j), ∀ (x) (_ : x ∈ S) (y) (_ : y ∈ S), (x, y) ∈ s j → (f x, f y) ∈ t i :=\n  ((ha.inf_principal (lower_set.prod S S)).tendsto_iff hb).trans <| by\n    simp_rw [prod.forall, Set.inter_comm (s _), ball_mem_comm, mem_inter_iff, mem_prod, and_imp]\n#align filter.has_basis.uniform_continuous_on_iff filter.has_basis.uniform_continuous_on_iff\n\n",
 "uniform_continuous_of_mul":
 "theorem uniform_continuous_of_mul : uniform_continuous (ofMul : α → Additive α) :=\n  uniform_continuous_id\n#align uniform_continuous_of_mul uniform_continuous_of_mul\n\n",
 "uniform_continuous_of_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem uniform_continuous_of_const [uniform_space β] {c : α → β} (h : ∀ a b, c a = c b) : uniform_continuous c :=\n  have : «expr ⁻¹' » (fun x : α × α => (c x.fst, c x.snd)) id_rel = univ := eq_univ_iff_forall.2 fun ⟨a, b⟩ => h a b\n  le_trans (map_le_iff_le_comap.2 <| by simp [comap_principal, this, univ_mem]) refl_le_uniformity\n#align uniform_continuous_of_const uniform_continuous_of_const\n\n",
 "uniform_continuous_of_add":
 "theorem uniform_continuous_of_add : uniform_continuous (ofAdd : α → Multiplicative α) :=\n  uniform_continuous_id\n#align uniform_continuous_of_add uniform_continuous_of_add\n\n",
 "uniform_continuous_infi_rng":
 "theorem uniform_continuous_infi_rng {f : α → β} {u₁ : uniform_space α} {u₂ : ι → uniform_space β}\n    (h : ∀ i, @uniform_continuous u₁ (u₂ i) f) : @uniform_continuous u₁ (infᵢ u₂) f := by\n  rwa [uniform_continuous, infi_uniformity', tendsto_infi]\n#align uniform_continuous_infi_rng uniform_continuous_infi_rng\n\n",
 "uniform_continuous_infi_dom":
 "theorem uniform_continuous_infi_dom {f : α → β} {u₁ : ι → uniform_space α} {u₂ : uniform_space β} {i : ι}\n    (hf : @uniform_continuous (u₁ i) u₂ f) : @uniform_continuous (infᵢ u₁) u₂ f :=\n  by\n  rw [uniform_continuous, infi_uniformity']\n  exact tendsto_infi' i hf\n#align uniform_continuous_infi_dom uniform_continuous_infi_dom\n\n",
 "uniform_continuous_inf_rng":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem uniform_continuous_inf_rng {f : α → β} {u₁ : uniform_space α} {u₂ u₃ : uniform_space β}\n    (h₁ : @uniform_continuous u₁ u₂ f) (h₂ : @uniform_continuous u₁ u₃ f) :\n    @uniform_continuous u₁ («expr ⊓ » u₂ u₃) f :=\n  tendsto_inf.mpr ⟨h₁, h₂⟩\n#align uniform_continuous_inf_rng uniform_continuous_inf_rng\n\n",
 "uniform_continuous_inf_dom_right₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- A version of `uniform_continuous_inf_dom_right` for binary functions -/\ntheorem uniform_continuous_inf_dom_right₂ {α β γ} {f : α → β → γ} {ua1 ua2 : uniform_space α}\n    {ub1 ub2 : uniform_space β} {uc1 : uniform_space γ}\n    (h : by haveI := ua2 <;> haveI := ub2 <;> exact uniform_continuous fun p : α × β => f p.1 p.2) : by\n    haveI := «expr ⊓ » ua1 ua2 <;> haveI := «expr ⊓ » ub1 ub2 <;> exact uniform_continuous fun p : α × β => f p.1 p.2 :=\n  by\n  -- proof essentially copied from ``continuous_inf_dom_right₂`\n  have ha := @uniform_continuous_inf_dom_right _ _ id ua1 ua2 ua2 (@uniform_continuous_id _ (id _))\n  have hb := @uniform_continuous_inf_dom_right _ _ id ub1 ub2 ub2 (@uniform_continuous_id _ (id _))\n  have h_unif_cont_id := @uniform_continuous.prod_map _ _ _ _ («expr ⊓ » ua1 ua2) («expr ⊓ » ub1 ub2) ua2 ub2 _ _ ha hb\n  exact @uniform_continuous.comp _ _ _ (id _) (id _) _ _ _ h h_unif_cont_id\n#align uniform_continuous_inf_dom_right₂ uniform_continuous_inf_dom_right₂\n\n",
 "uniform_continuous_inf_dom_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem uniform_continuous_inf_dom_right {f : α → β} {u₁ u₂ : uniform_space α} {u₃ : uniform_space β}\n    (hf : @uniform_continuous u₂ u₃ f) : @uniform_continuous («expr ⊓ » u₁ u₂) u₃ f :=\n  tendsto_inf_right hf\n#align uniform_continuous_inf_dom_right uniform_continuous_inf_dom_right\n\n",
 "uniform_continuous_inf_dom_left₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- A version of `uniform_continuous_inf_dom_left` for binary functions -/\ntheorem uniform_continuous_inf_dom_left₂ {α β γ} {f : α → β → γ} {ua1 ua2 : uniform_space α} {ub1 ub2 : uniform_space β}\n    {uc1 : uniform_space γ}\n    (h : by haveI := ua1 <;> haveI := ub1 <;> exact uniform_continuous fun p : α × β => f p.1 p.2) : by\n    haveI := «expr ⊓ » ua1 ua2 <;> haveI := «expr ⊓ » ub1 ub2 <;> exact uniform_continuous fun p : α × β => f p.1 p.2 :=\n  by\n  -- proof essentially copied from ``continuous_inf_dom_left₂`\n  have ha := @uniform_continuous_inf_dom_left _ _ id ua1 ua2 ua1 (@uniform_continuous_id _ (id _))\n  have hb := @uniform_continuous_inf_dom_left _ _ id ub1 ub2 ub1 (@uniform_continuous_id _ (id _))\n  have h_unif_cont_id := @uniform_continuous.prod_map _ _ _ _ («expr ⊓ » ua1 ua2) («expr ⊓ » ub1 ub2) ua1 ub1 _ _ ha hb\n  exact @uniform_continuous.comp _ _ _ (id _) (id _) _ _ _ h h_unif_cont_id\n#align uniform_continuous_inf_dom_left₂ uniform_continuous_inf_dom_left₂\n\n",
 "uniform_continuous_inf_dom_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem uniform_continuous_inf_dom_left {f : α → β} {u₁ u₂ : uniform_space α} {u₃ : uniform_space β}\n    (hf : @uniform_continuous u₁ u₃ f) : @uniform_continuous («expr ⊓ » u₁ u₂) u₃ f :=\n  tendsto_inf_left hf\n#align uniform_continuous_inf_dom_left uniform_continuous_inf_dom_left\n\n",
 "uniform_continuous_iff_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniform_continuous_iff_eventually [uniform_space β] {f : α → β} :\n    uniform_continuous f ↔\n      ∀ r ∈ (uniformity) β,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          ((uniformity) α) ((f x.1, f x.2) ∈ r) :=\n  iff.rfl\n#align uniform_continuous_iff_eventually uniform_continuous_iff_eventually\n\n",
 "uniform_continuous_iff":
 "theorem uniform_continuous_iff {α β} {uα : uniform_space α} {uβ : uniform_space β} {f : α → β} :\n    uniform_continuous f ↔ uα ≤ uβ.comap f :=\n  filter.map_le_iff_le_comap\n#align uniform_continuous_iff uniform_continuous_iff\n\n",
 "uniform_continuous_id":
 "theorem uniform_continuous_id : uniform_continuous (@id α) := by simp [uniform_continuous] <;> exact tendsto_id\n#align uniform_continuous_id uniform_continuous_id\n\n",
 "uniform_continuous_fst":
 "theorem uniform_continuous_fst [uniform_space α] [uniform_space β] : uniform_continuous fun p : α × β => p.1 :=\n  tendsto_prod_uniformity_fst\n#align uniform_continuous_fst uniform_continuous_fst\n\n",
 "uniform_continuous_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniform_continuous_def [uniform_space β] {f : α → β} :\n    uniform_continuous f ↔ ∀ r ∈ (uniformity) β, { x : α × α | (f x.1, f x.2) ∈ r } ∈ (uniformity) α :=\n  iff.rfl\n#align uniform_continuous_def uniform_continuous_def\n\n",
 "uniform_continuous_const":
 "theorem uniform_continuous_const [uniform_space β] {b : β} : uniform_continuous fun a : α => b :=\n  uniform_continuous_of_const fun _ _ => rfl\n#align uniform_continuous_const uniform_continuous_const\n\n",
 "uniform_continuous_comap'":
 "theorem uniform_continuous_comap' {f : γ → β} {g : α → γ} [v : uniform_space β] [u : uniform_space α]\n    (h : uniform_continuous (f ∘ g)) : @uniform_continuous α γ u (uniform_space.comap f v) g :=\n  tendsto_comap_iff.2 h\n#align uniform_continuous_comap' uniform_continuous_comap'\n\n",
 "uniform_continuous_comap":
 "theorem uniform_continuous_comap {f : α → β} [u : uniform_space β] :\n    @uniform_continuous α β (uniform_space.comap f u) u f :=\n  tendsto_comap\n#align uniform_continuous_comap uniform_continuous_comap\n\n",
 "uniform_continuous_Inf_rng":
 "theorem uniform_continuous_Inf_rng {f : α → β} {u₁ : uniform_space α} {u₂ : set (uniform_space β)}\n    (h : ∀ u ∈ u₂, @uniform_continuous u₁ u f) : @uniform_continuous u₁ (infₛ u₂) f :=\n  by\n  rw [uniform_continuous, infₛ_eq_infᵢ', infi_uniformity']\n  exact tendsto_infi.mpr fun ⟨u, hu⟩ => h u hu\n#align uniform_continuous_Inf_rng uniform_continuous_Inf_rng\n\n",
 "uniform_continuous_Inf_dom₂":
 "/-- A version of `uniform_continuous_Inf_dom` for binary functions -/\ntheorem uniform_continuous_Inf_dom₂ {α β γ} {f : α → β → γ} {uas : set (uniform_space α)} {ubs : set (uniform_space β)}\n    {ua : uniform_space α} {ub : uniform_space β} {uc : uniform_space γ} (ha : ua ∈ uas) (hb : ub ∈ ubs)\n    (hf : uniform_continuous fun p : α × β => f p.1 p.2) : by\n    haveI := Inf uas <;> haveI := Inf ubs <;> exact @uniform_continuous _ _ _ uc fun p : α × β => f p.1 p.2 :=\n  by\n  -- proof essentially copied from ``continuous_Inf_dom`\n  let t : uniform_space (α × β) := prod.uniform_space\n  have ha := uniform_continuous_Inf_dom ha uniform_continuous_id\n  have hb := uniform_continuous_Inf_dom hb uniform_continuous_id\n  have h_unif_cont_id := @uniform_continuous.prod_map _ _ _ _ (Inf uas) (Inf ubs) ua ub _ _ ha hb\n  exact @uniform_continuous.comp _ _ _ (id _) (id _) _ _ _ hf h_unif_cont_id\n#align uniform_continuous_Inf_dom₂ uniform_continuous_Inf_dom₂\n\n",
 "uniform_continuous_Inf_dom":
 "theorem uniform_continuous_Inf_dom {f : α → β} {u₁ : set (uniform_space α)} {u₂ : uniform_space β} {u : uniform_space α}\n    (h₁ : u ∈ u₁) (hf : @uniform_continuous u u₂ f) : @uniform_continuous (infₛ u₁) u₂ f :=\n  by\n  rw [uniform_continuous, infₛ_eq_infᵢ', infi_uniformity']\n  exact tendsto_infi' ⟨u, h₁⟩ hf\n#align uniform_continuous_Inf_dom uniform_continuous_Inf_dom\n\n",
 "uniform_continuous":
 "theorem uniform_continuous₂.uniform_continuous {f : α → β → γ} (h : uniform_continuous₂ f) :\n    uniform_continuous (uncurry f) :=\n  h\n#align uniform_continuous₂.uniform_continuous uniform_continuous₂.uniform_continuous\n\n",
 "to_topological_space_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem to_topological_space_top : @uniform_space.to_topological_space α («expr⊤») = «expr⊤» :=\n  top_unique fun s hs =>\n    s.eq_empty_or_nonempty.elim (fun this : s = ∅ => this.symm ▸ @is_open_empty _ («expr⊤»)) fun ⟨x, hx⟩ =>\n      have : s = univ := top_unique fun y hy => hs x hx (x, y) rfl\n      this.symm ▸ @is_open_univ _ («expr⊤»)\n#align to_topological_space_top to_topological_space_top\n\n",
 "to_topological_space_subtype":
 "theorem to_topological_space_subtype [u : uniform_space α] {p : α → Prop} :\n    @uniform_space.to_topological_space (subtype p) subtype.uniform_space =\n      @subtype.topological_space α p u.to_topological_space :=\n  rfl\n#align to_topological_space_subtype to_topological_space_subtype\n\n",
 "to_topological_space_prod":
 "theorem to_topological_space_prod {α} {β} [u : uniform_space α] [v : uniform_space β] :\n    @uniform_space.to_topological_space (α × β) prod.uniform_space =\n      @prod.topological_space α β u.to_topological_space v.to_topological_space :=\n  rfl\n#align to_topological_space_prod to_topological_space_prod\n\n",
 "to_topological_space_mono":
 "theorem to_topological_space_mono {u₁ u₂ : uniform_space α} (h : u₁ ≤ u₂) :\n    @uniform_space.to_topological_space _ u₁ ≤ @uniform_space.to_topological_space _ u₂ :=\n  le_of_nhds_le_nhds <| to_nhds_mono h\n#align to_topological_space_mono to_topological_space_mono\n\n",
 "to_topological_space_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem to_topological_space_infi {ι : Sort _} {u : ι → uniform_space α} :\n    (infᵢ u).to_topological_space =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (u i).to_topological_space :=\n  by\n  refine' eq_of_nhds_eq_nhds fun a => _\n  rw [nhds_infi, nhds_eq_uniformity]\n  change (infᵢ u).uniformity.lift' (preimage <| prod.mk a) = _\n  rw [infi_uniformity, lift'_infi_of_map_univ _ preimage_univ]\n  · simp only [nhds_eq_uniformity]\n    rfl\n  · exact ball_inter _\n#align to_topological_space_infi to_topological_space_infi\n\n",
 "to_topological_space_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem to_topological_space_inf {u v : uniform_space α} :\n    («expr ⊓ » u v).to_topological_space = «expr ⊓ » u.to_topological_space v.to_topological_space :=\n  rfl\n#align to_topological_space_inf to_topological_space_inf\n\n",
 "to_topological_space_comap":
 "theorem to_topological_space_comap {f : α → β} {u : uniform_space β} :\n    @uniform_space.to_topological_space _ (uniform_space.comap f u) =\n      topological_space.induced f (@uniform_space.to_topological_space β u) :=\n  rfl\n#align to_topological_space_comap to_topological_space_comap\n\n",
 "to_topological_space_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem to_topological_space_bot : @uniform_space.to_topological_space α («expr⊥») = «expr⊥» :=\n  rfl\n#align to_topological_space_bot to_topological_space_bot\n\n",
 "to_topological_space_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem to_topological_space_Inf {s : set (uniform_space α)} :\n    (infₛ s).to_topological_space =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (@uniform_space.to_topological_space α i) :=\n  by\n  rw [infₛ_eq_infᵢ]\n  simp only [← to_topological_space_infi]\n#align to_topological_space_Inf to_topological_space_Inf\n\n",
 "to_nhds_mono":
 "theorem to_nhds_mono {u₁ u₂ : uniform_space α} (h : u₁ ≤ u₂) (a : α) :\n    @nhds _ (@uniform_space.to_topological_space _ u₁) a ≤ @nhds _ (@uniform_space.to_topological_space _ u₂) a := by\n  rw [@nhds_eq_uniformity α u₁ a, @nhds_eq_uniformity α u₂ a] <;> exact lift'_mono h le_rfl\n#align to_nhds_mono to_nhds_mono\n\n",
 "to_core_to_topological_space":
 "-- the topological structure is embedded in the uniform structure\n-- to avoid instance diamond issues. See Note [forgetful inheritance].\ntheorem uniform_space.to_core_to_topological_space (u : uniform_space α) :\n    u.to_core.to_topological_space = u.to_topological_space :=\n  topological_space_eq <|\n    funext fun s => by rw [uniform_space.core.to_topological_space, uniform_space.is_open_uniformity]\n#align uniform_space.to_core_to_topological_space uniform_space.to_core_to_topological_space\n\n",
 "tendsto_swap_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem tendsto_swap_uniformity : tendsto (@prod.swap α α) ((uniformity) α) ((uniformity) α) :=\n  symm_le_uniformity\n#align tendsto_swap_uniformity tendsto_swap_uniformity\n\n",
 "tendsto_right_nhds_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem tendsto_right_nhds_uniformity {a : α} : tendsto (fun a' => (a', a)) ((nhds) a) ((uniformity) α) := fun s =>\n  mem_nhds_right a\n#align tendsto_right_nhds_uniformity tendsto_right_nhds_uniformity\n\n",
 "tendsto_prod_uniformity_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem tendsto_prod_uniformity_snd [uniform_space α] [uniform_space β] :\n    tendsto (fun p : (α × β) × α × β => (p.1.2, p.2.2)) ((uniformity) (α × β)) ((uniformity) β) :=\n  le_trans (map_mono inf_le_right) map_comap_le\n#align tendsto_prod_uniformity_snd tendsto_prod_uniformity_snd\n\n",
 "tendsto_prod_uniformity_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem tendsto_prod_uniformity_fst [uniform_space α] [uniform_space β] :\n    tendsto (fun p : (α × β) × α × β => (p.1.1, p.2.1)) ((uniformity) (α × β)) ((uniformity) α) :=\n  le_trans (map_mono inf_le_left) map_comap_le\n#align tendsto_prod_uniformity_fst tendsto_prod_uniformity_fst\n\n",
 "tendsto_of_uniform_continuous_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_of_uniform_continuous_subtype [uniform_space α] [uniform_space β] {f : α → β} {s : set α} {a : α}\n    (hf : uniform_continuous fun x : s => f x.val) (ha : s ∈ (nhds) a) : tendsto f ((nhds) a) ((nhds) (f a)) := by\n  rw [(@map_nhds_subtype_coe_eq α _ s a (mem_of_mem_nhds ha) ha).symm] <;>\n    exact tendsto_map' (continuous_iff_continuous_at.mp hf.continuous _)\n#align tendsto_of_uniform_continuous_subtype tendsto_of_uniform_continuous_subtype\n\n",
 "tendsto_nhds_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem tendsto_nhds_right {f : filter β} {u : β → α} {a : α} :\n    tendsto u f ((nhds) a) ↔ tendsto (fun x => (a, u x)) f ((uniformity) α) :=\n  ⟨fun H => tendsto_left_nhds_uniformity.comp H, fun H s hs => by\n    simpa [mem_of_mem_nhds hs] using H (mem_nhds_uniformity_iff_right.1 hs)⟩\n#align tendsto_nhds_right tendsto_nhds_right\n\n",
 "tendsto_nhds_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem tendsto_nhds_left {f : filter β} {u : β → α} {a : α} :\n    tendsto u f ((nhds) a) ↔ tendsto (fun x => (u x, a)) f ((uniformity) α) :=\n  ⟨fun H => tendsto_right_nhds_uniformity.comp H, fun H s hs => by\n    simpa [mem_of_mem_nhds hs] using H (mem_nhds_uniformity_iff_left.1 hs)⟩\n#align tendsto_nhds_left tendsto_nhds_left\n\n",
 "tendsto_left_nhds_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem tendsto_left_nhds_uniformity {a : α} : tendsto (fun a' => (a, a')) ((nhds) a) ((uniformity) α) := fun s =>\n  mem_nhds_left a\n#align tendsto_left_nhds_uniformity tendsto_left_nhds_uniformity\n\n",
 "tendsto_diag_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Relation `λ f g, tendsto (λ x, (f x, g x)) l (𝓤 α)` is reflexive. -/\ntheorem tendsto_diag_uniformity (f : β → α) (l : filter β) : tendsto (fun x => (f x, f x)) l ((uniformity) α) :=\n  fun s hs => mem_map.2 <| univ_mem' fun x => refl_mem_uniformity hs\n#align tendsto_diag_uniformity tendsto_diag_uniformity\n\n",
 "tendsto_const_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem tendsto_const_uniformity {a : α} {f : filter β} : tendsto (fun _ => (a, a)) f ((uniformity) α) :=\n  tendsto_diag_uniformity (fun _ => a) f\n#align tendsto_const_uniformity tendsto_const_uniformity\n\n",
 "tendsto_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem uniform.tendsto_congr {α β} [uniform_space β] {f g : α → β} {l : filter α} {b : β}\n    (hfg : tendsto (fun x => (f x, g x)) l ((uniformity) β)) : tendsto f l ((nhds) b) ↔ tendsto g l ((nhds) b) :=\n  ⟨fun h => h.congr_uniformity hfg, fun h => h.congr_uniformity hfg.uniformity_symm⟩\n#align uniform.tendsto_congr uniform.tendsto_congr\n\n",
 "symmetrize_rel_subset_self":
 "theorem symmetrize_rel_subset_self (V : set (α × α)) : symmetrize_rel V ⊆ V :=\n  sep_subset _ _\n#align symmetrize_rel_subset_self symmetrize_rel_subset_self\n\n",
 "symmetrize_mono":
 "@[mono]\ntheorem symmetrize_mono {V W : set (α × α)} (h : V ⊆ W) : symmetrize_rel V ⊆ symmetrize_rel W :=\n  inter_subset_inter h <| preimage_mono h\n#align symmetrize_mono symmetrize_mono\n\n",
 "symmetrize_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem symmetrize_mem_uniformity {V : set (α × α)} (h : V ∈ (uniformity) α) : symmetrize_rel V ∈ (uniformity) α :=\n  by\n  apply ((uniformity) α).inter_sets h\n  rw [← image_swap_eq_preimage_swap, uniformity_eq_symm]\n  exact image_mem_map h\n#align symmetrize_mem_uniformity symmetrize_mem_uniformity\n\n",
 "symmetric_symmetrize_rel":
 "theorem symmetric_symmetrize_rel (V : set (α × α)) : symmetric_rel (symmetrize_rel V) := by\n  simp [symmetric_rel, symmetrize_rel, preimage_inter, inter_comm, ← preimage_comp]\n#align symmetric_symmetrize_rel symmetric_symmetrize_rel\n\n",
 "symm_of_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem symm_of_uniformity {s : set (α × α)} (hs : s ∈ (uniformity) α) :\n    ∃ t ∈ (uniformity) α, (∀ a b, (a, b) ∈ t → (b, a) ∈ t) ∧ t ⊆ s :=\n  have : preimage prod.swap s ∈ (uniformity) α := symm_le_uniformity hs\n  ⟨s ∩ preimage prod.swap s, inter_mem hs this, fun a b ⟨h₁, h₂⟩ => ⟨h₂, h₁⟩, inter_subset_left _ _⟩\n#align symm_of_uniformity symm_of_uniformity\n\n",
 "symm_le_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem symm_le_uniformity : map (@prod.swap α α) ((uniformity) _) ≤ (uniformity) _ :=\n  (@uniform_space.to_core α _).symm\n#align symm_le_uniformity symm_le_uniformity\n\n",
 "swap_id_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem swap_id_rel : «expr '' » prod.swap id_rel = @id_rel α :=\n  Set.ext fun ⟨a, b⟩ => by simp [image_swap_eq_preimage_swap] <;> exact eq_comm\n#align swap_id_rel swap_id_rel\n\n",
 "supr_nhds_le_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Entourages are neighborhoods of the diagonal. -/\ntheorem supr_nhds_le_uniformity :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((nhds) (x, x)) ≤\n      (uniformity) α :=\n  supᵢ_le nhds_le_uniformity\n#align supr_nhds_le_uniformity supr_nhds_le_uniformity\n\n",
 "subtype_mk":
 "theorem uniform_continuous.subtype_mk {p : α → Prop} [uniform_space α] [uniform_space β] {f : β → α}\n    (hf : uniform_continuous f) (h : ∀ x, p (f x)) : uniform_continuous (fun x => ⟨f x, h x⟩ : β → subtype p) :=\n  uniform_continuous_comap' hf\n#align uniform_continuous.subtype_mk uniform_continuous.subtype_mk\n\n",
 "subset_iterate_comp_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `uniformity.comp_rel -/\ntheorem subset_iterate_comp_rel {s t : set (α × α)} (h : id_rel ⊆ s) (n : ℕ) :\n    t ⊆ («expr ^[ ]» ((uniformity.comp_rel · ·) s) n) t :=\n  by\n  induction' n with n ihn generalizing t\n  exacts[subset.rfl, (right_subset_comp_rel h).trans ihn]\n#align subset_iterate_comp_rel subset_iterate_comp_rel\n\n",
 "subset_comp_self_of_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem subset_comp_self_of_mem_uniformity {s : set (α × α)} (h : s ∈ (uniformity) α) : s ⊆ uniformity.comp_rel s s :=\n  subset_comp_self (refl_le_uniformity h)\n#align subset_comp_self_of_mem_uniformity subset_comp_self_of_mem_uniformity\n\n",
 "subset_comp_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem subset_comp_self {s : set (α × α)} (h : id_rel ⊆ s) : s ⊆ uniformity.comp_rel s s :=\n  left_subset_comp_rel h\n#align subset_comp_self subset_comp_self\n\n",
 "right_subset_comp_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem right_subset_comp_rel {s t : set (α × α)} (h : id_rel ⊆ s) : t ⊆ uniformity.comp_rel s t := fun ⟨x, y⟩ xy_in =>\n  ⟨x, h <| rfl, xy_in⟩\n#align right_subset_comp_rel right_subset_comp_rel\n\n",
 "replace_topology_eq":
 "theorem uniform_space.replace_topology_eq {α : Type _} [i : topological_space α] (u : uniform_space α)\n    (h : i = u.to_topological_space) : u.replace_topology h = u :=\n  u.of_core_eq_to_core _ _\n#align uniform_space.replace_topology_eq uniform_space.replace_topology_eq\n\n",
 "refl_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem refl_mem_uniformity {x : α} {s : set (α × α)} (h : s ∈ (uniformity) α) : (x, x) ∈ s :=\n  refl_le_uniformity h rfl\n#align refl_mem_uniformity refl_mem_uniformity\n\n",
 "refl_le_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem refl_le_uniformity : (filter.principal) id_rel ≤ (uniformity) α :=\n  (@uniform_space.to_core α _).refl\n#align refl_le_uniformity refl_le_uniformity\n\n",
 "prod_mk_right":
 "theorem uniform_continuous.prod_mk_right {f : α × β → γ} (h : uniform_continuous f) (a) :\n    uniform_continuous fun b => f (a, b) :=\n  h.comp (uniform_continuous_const.prod_mk uniform_continuous_id)\n#align uniform_continuous.prod_mk_right uniform_continuous.prod_mk_right\n\n",
 "prod_mk_mem_comp_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem prod_mk_mem_comp_rel {a b c : α} {s t : set (α × α)} (h₁ : (a, c) ∈ s) (h₂ : (c, b) ∈ t) :\n    (a, b) ∈ uniformity.comp_rel s t :=\n  ⟨c, h₁, h₂⟩\n#align prod_mk_mem_comp_rel prod_mk_mem_comp_rel\n\n",
 "prod_mk_left":
 "theorem uniform_continuous.prod_mk_left {f : α × β → γ} (h : uniform_continuous f) (b) :\n    uniform_continuous fun a => f (a, b) :=\n  h.comp (uniform_continuous_id.prod_mk uniform_continuous_const)\n#align uniform_continuous.prod_mk_left uniform_continuous.prod_mk_left\n\n",
 "prod_mk":
 "theorem uniform_continuous.prod_mk {f₁ : α → β} {f₂ : α → γ} (h₁ : uniform_continuous f₁) (h₂ : uniform_continuous f₂) :\n    uniform_continuous fun a => (f₁ a, f₂ a) := by\n  rw [uniform_continuous, uniformity_prod] <;> exact tendsto_inf.2 ⟨tendsto_comap_iff.2 h₁, tendsto_comap_iff.2 h₂⟩\n#align uniform_continuous.prod_mk uniform_continuous.prod_mk\n\n",
 "prod_map":
 "theorem uniform_continuous.prod_map [uniform_space δ] {f : α → γ} {g : β → δ} (hf : uniform_continuous f)\n    (hg : uniform_continuous g) : uniform_continuous (prod.map f g) :=\n  (hf.comp uniform_continuous_fst).prod_mk (hg.comp uniform_continuous_snd)\n#align uniform_continuous.prod_map uniform_continuous.prod_map\n\n",
 "open_of_uniformity_sum_aux":
 "theorem open_of_uniformity_sum_aux {s : set (Sum α β)}\n    (hs : ∀ x ∈ s, { p : Sum α β × Sum α β | p.1 = x → p.2 ∈ s } ∈ (@uniform_space.core.sum α β _ _).uniformity) :\n    is_open s := by\n  constructor\n  · refine' (@is_open_iff_mem_nhds α _ _).2 fun a ha => mem_nhds_uniformity_iff_right.2 _\n    rcases mem_map_iff_exists_image.1 (hs _ ha).1 with ⟨t, ht, st⟩\n    refine' mem_of_superset ht _\n    rintro p pt rfl\n    exact st ⟨_, pt, rfl⟩ rfl\n  · refine' (@is_open_iff_mem_nhds β _ _).2 fun b hb => mem_nhds_uniformity_iff_right.2 _\n    rcases mem_map_iff_exists_image.1 (hs _ hb).2 with ⟨t, ht, st⟩\n    refine' mem_of_superset ht _\n    rintro p pt rfl\n    exact st ⟨_, pt, rfl⟩ rfl\n#align open_of_uniformity_sum_aux open_of_uniformity_sum_aux\n\n",
 "of_core_eq_to_core":
 "theorem uniform_space.of_core_eq_to_core (u : uniform_space α) (t : topological_space α)\n    (h : t = u.to_core.to_topological_space) : uniform_space.of_core_eq u.to_core t h = u :=\n  uniform_space_eq rfl\n#align uniform_space.of_core_eq_to_core uniform_space.of_core_eq_to_core\n\n",
 "nhdset_of_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » cl_d) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem nhdset_of_mem_uniformity {d : set (α × α)} (s : set (α × α)) (hd : d ∈ (uniformity) α) :\n    ∃ t : set (α × α), is_open t ∧ s ⊆ t ∧ t ⊆ { p | ∃ x y, (p.1, x) ∈ d ∧ (x, y) ∈ s ∧ (y, p.2) ∈ d } :=\n  let cl_d := { p : α × α | ∃ x y, (p.1, x) ∈ d ∧ (x, y) ∈ s ∧ (y, p.2) ∈ d }\n  have : ∀ p ∈ s, ∃ (t : _)(_ : t ⊆ cl_d), is_open t ∧ p ∈ t := fun ⟨x, y⟩ hp =>\n    _root_.mem_nhds_iff.mp <|\n      show cl_d ∈ (nhds) (x, y) by\n        rw [nhds_eq_uniformity_prod, mem_lift'_sets]\n        exact ⟨d, hd, fun ⟨a, b⟩ ⟨ha, hb⟩ => ⟨x, y, ha, hp, hb⟩⟩\n        exact monotone_preimage.set_prod monotone_preimage\n  have : ∃ t : ∀ (p : α × α) (h : p ∈ s), set (α × α), ∀ p, ∀ h : p ∈ s, t p h ⊆ cl_d ∧ is_open (t p h) ∧ p ∈ t p h :=\n    by simp [classical.skolem] at this <;> simp <;> assumption\n  match this with\n  | ⟨t, ht⟩ =>\n    ⟨(«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t p h)) :\n        set (α × α)),\n      is_open_Union fun p : α × α => is_open_Union fun hp => (ht p hp).right.left, fun ⟨a, b⟩ hp => by\n      simp <;> exact ⟨a, b, hp, (ht (a, b) hp).right.right⟩,\n      Union_subset fun p => Union_subset fun hp => (ht p hp).left⟩\n#align nhdset_of_mem_uniformity nhdset_of_mem_uniformity\n\n",
 "nhds_set_diagonal_le_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Entourages are neighborhoods of the diagonal. -/\ntheorem nhds_set_diagonal_le_uniformity : (nhds_set) (diagonal α) ≤ (uniformity) α :=\n  (nhds_set_diagonal α).trans_le supr_nhds_le_uniformity\n#align nhds_set_diagonal_le_uniformity nhds_set_diagonal_le_uniformity\n\n",
 "nhds_set_basis_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_compact.nhds_set_basis_uniformity {p : ι → Prop} {s : ι → set (α × α)} (hU : ((uniformity) α).has_basis p s)\n    {K : set α} (hK : is_compact K) :\n    ((nhds_set) K).has_basis p fun i =>\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (ball x (s i)) :=\n  by\n  refine' ⟨fun U => _⟩\n  simp only [mem_nhds_set_iff_forall, (nhds_basis_uniformity' hU).mem_iff, Union₂_subset_iff]\n  refine' ⟨fun H => _, fun ⟨i, hpi, hi⟩ x hx => ⟨i, hpi, hi x hx⟩⟩\n  replace H : ∀ x ∈ K, ∃ i : { i // p i }, ball x (uniformity.comp_rel (s i) (s i)) ⊆ U\n  · intro x hx\n    rcases H x hx with ⟨i, hpi, hi⟩\n    rcases comp_mem_uniformity_sets (hU.mem_of_mem hpi) with ⟨t, ht_mem, ht⟩\n    rcases hU.mem_iff.1 ht_mem with ⟨j, hpj, hj⟩\n    exact ⟨⟨j, hpj⟩, subset.trans (ball_mono ((comp_rel_mono hj hj).trans ht) _) hi⟩\n  have : nonempty { a // p a } := nonempty_subtype.2 hU.ex_mem\n  choose! I hI using H\n  rcases hK.elim_nhds_subcover (fun x => ball x <| s (I x)) fun x hx => ball_mem_nhds _ <| hU.mem_of_mem (I x).2 with\n    ⟨t, htK, ht⟩\n  obtain ⟨i, hpi, hi⟩ :\n    ∃ (i : _)(hpi : p i),\n      s i ⊆ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s (I x))\n  exact hU.mem_iff.1 ((bInter_finset_mem t).2 fun x hx => hU.mem_of_mem (I x).2)\n  rw [subset_Inter₂_iff] at hi\n  refine' ⟨i, hpi, fun x hx => _⟩\n  rcases mem_Union₂.1 (ht hx) with ⟨z, hzt : z ∈ t, hzx : x ∈ ball z (s (I z))⟩\n  calc\n    ball x (s i) ⊆ ball z (uniformity.comp_rel (s (I z)) (s (I z))) := fun y hy => ⟨x, hzx, hi z hzt hy⟩\n    _ ⊆ U := hI z (htK z hzt)\n    \n#align is_compact.nhds_set_basis_uniformity is_compact.nhds_set_basis_uniformity\n\n",
 "nhds_nhds_eq_uniformity_uniformity_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem nhds_nhds_eq_uniformity_uniformity_prod {a b : α} :\n    filter.prod ((nhds) a) ((nhds) b) =\n      ((uniformity) α).lift fun s : set (α × α) =>\n        ((uniformity) α).lift' fun t : set (α × α) => lower_set.prod { y : α | (y, a) ∈ s } { y : α | (b, y) ∈ t } :=\n  by\n  rw [nhds_eq_uniformity', nhds_eq_uniformity, prod_lift'_lift']\n  · rfl\n  · exact monotone_preimage\n  · exact monotone_preimage\n#align nhds_nhds_eq_uniformity_uniformity_prod nhds_nhds_eq_uniformity_uniformity_prod\n\n",
 "nhds_le_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Entourages are neighborhoods of the diagonal. -/\ntheorem nhds_le_uniformity (x : α) : (nhds) (x, x) ≤ (uniformity) α :=\n  by\n  intro V V_in\n  rcases comp_symm_mem_uniformity_sets V_in with ⟨w, w_in, w_symm, w_sub⟩\n  have : lower_set.prod (ball x w) (ball x w) ∈ (nhds) (x, x) :=\n    by\n    rw [nhds_prod_eq]\n    exact prod_mem_prod (ball_mem_nhds x w_in) (ball_mem_nhds x w_in)\n  apply mem_of_superset this\n  rintro ⟨u, v⟩ ⟨u_in, v_in⟩\n  exact w_sub (mem_comp_of_mem_ball w_symm u_in v_in)\n#align nhds_le_uniformity nhds_le_uniformity\n\n",
 "nhds_eq_uniformity_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem nhds_eq_uniformity_prod {a b : α} :\n    (nhds) (a, b) =\n      ((uniformity) α).lift' fun s : set (α × α) => lower_set.prod { y : α | (y, a) ∈ s } { y : α | (b, y) ∈ s } :=\n  by\n  rw [nhds_prod_eq, nhds_nhds_eq_uniformity_uniformity_prod, lift_lift'_same_eq_lift']\n  · intro s\n    exact monotone_const.set_prod monotone_preimage\n  · intro t\n    exact monotone_preimage.set_prod monotone_const\n#align nhds_eq_uniformity_prod nhds_eq_uniformity_prod\n\n",
 "nhds_eq_uniformity'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem nhds_eq_uniformity' {x : α} : (nhds) x = ((uniformity) α).lift' fun s => { y | (y, x) ∈ s } :=\n  (nhds_basis_uniformity ((uniformity) α).basis_sets).eq_binfi\n#align nhds_eq_uniformity' nhds_eq_uniformity'\n\n",
 "nhds_eq_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem nhds_eq_uniformity {x : α} : (nhds) x = ((uniformity) α).lift' (ball x) :=\n  (nhds_basis_uniformity' ((uniformity) α).basis_sets).eq_binfi\n#align nhds_eq_uniformity nhds_eq_uniformity\n\n",
 "nhds_eq_comap_uniformity_aux":
 "theorem nhds_eq_comap_uniformity_aux {α : Type u} {x : α} {s : set α} {F : filter (α × α)} :\n    { p : α × α | p.fst = x → p.snd ∈ s } ∈ F ↔ s ∈ comap (prod.mk x) F := by\n  rw [mem_comap] <;>\n    exact\n      iff.intro (fun hs => ⟨_, hs, fun x hx => hx rfl⟩) fun ⟨t, h, ht⟩ =>\n        F.sets_of_superset h fun ⟨p₁, p₂⟩ hp (h : p₁ = x) => ht <| by simp [h.symm, hp]\n#align nhds_eq_comap_uniformity_aux nhds_eq_comap_uniformity_aux\n\n",
 "nhds_eq_comap_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem nhds_eq_comap_uniformity {x : α} : (nhds) x = ((uniformity) α).comap (prod.mk x) :=\n  by\n  ext s\n  rw [mem_nhds_uniformity_iff_right]\n  exact nhds_eq_comap_uniformity_aux\n#align nhds_eq_comap_uniformity nhds_eq_comap_uniformity\n\n",
 "nhds_basis_uniformity'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_uniformity' {p : ι → Prop} {s : ι → set (α × α)} (h : ((uniformity) α).has_basis p s) {x : α} :\n    ((nhds) x).has_basis p fun i => ball x (s i) :=\n  by\n  rw [nhds_eq_comap_uniformity]\n  exact h.comap (prod.mk x)\n#align nhds_basis_uniformity' nhds_basis_uniformity'\n\n",
 "nhds_basis_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_uniformity {p : ι → Prop} {s : ι → set (α × α)} (h : ((uniformity) α).has_basis p s) {x : α} :\n    ((nhds) x).has_basis p fun i => { y | (y, x) ∈ s i } :=\n  by\n  replace h := h.comap prod.swap\n  rw [← map_swap_eq_comap_swap, ← uniformity_eq_symm] at h\n  exact nhds_basis_uniformity' h\n#align nhds_basis_uniformity nhds_basis_uniformity\n\n",
 "monotone_comp_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem monotone_comp_rel [preorder β] {f g : β → set (α × α)} (hf : monotone f) (hg : monotone g) :\n    monotone fun x => uniformity.comp_rel (f x) (g x) := fun a b h p ⟨z, h₁, h₂⟩ => ⟨z, hf h h₁, hg h h₂⟩\n#align monotone_comp_rel monotone_comp_rel\n\n",
 "mk_mem_comm":
 "theorem symmetric_rel.mk_mem_comm {V : set (α × α)} (hV : symmetric_rel V) {x y : α} : (x, y) ∈ V ↔ (y, x) ∈ V :=\n  Set.ext_iff.1 hV (y, x)\n#align symmetric_rel.mk_mem_comm symmetric_rel.mk_mem_comm\n\n",
 "mem_uniformity_of_uniform_continuous_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem mem_uniformity_of_uniform_continuous_invariant [uniform_space α] [uniform_space β] {s : set (β × β)}\n    {f : α → α → β} (hf : uniform_continuous fun p : α × α => f p.1 p.2) (hs : s ∈ (uniformity) β) :\n    ∃ u ∈ (uniformity) α, ∀ a b c, (a, b) ∈ u → (f a c, f b c) ∈ s :=\n  by\n  rw [uniform_continuous, uniformity_prod_eq_prod, tendsto_map'_iff, (· ∘ ·)] at hf\n  rcases mem_prod_iff.1 (mem_map.1 <| hf hs) with ⟨u, hu, v, hv, huvt⟩\n  exact ⟨u, hu, fun a b c hab => @huvt ((_, _), (_, _)) ⟨hab, refl_mem_uniformity hv⟩⟩\n#align mem_uniformity_of_uniform_continuous_invariant mem_uniformity_of_uniform_continuous_invariant\n\n",
 "mem_uniformity_of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem mem_uniformity_of_eq {x y : α} {s : set (α × α)} (h : s ∈ (uniformity) α) (hx : x = y) : (x, y) ∈ s :=\n  hx ▸ refl_mem_uniformity h\n#align mem_uniformity_of_eq mem_uniformity_of_eq\n\n",
 "mem_uniformity_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem mem_uniformity_is_closed {s : set (α × α)} (h : s ∈ (uniformity) α) :\n    ∃ t ∈ (uniformity) α, is_closed t ∧ t ⊆ s :=\n  let ⟨t, ⟨ht_mem, htc⟩, hts⟩ := uniformity_has_basis_closed.mem_iff.1 h\n  ⟨t, ht_mem, htc, hts⟩\n#align mem_uniformity_is_closed mem_uniformity_is_closed\n\n",
 "mem_uniformity_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem filter.has_basis.mem_uniformity_iff {p : β → Prop} {s : β → set (α × α)} (h : ((uniformity) α).has_basis p s)\n    {t : set (α × α)} : t ∈ (uniformity) α ↔ ∃ (i : _)(hi : p i), ∀ a b, (a, b) ∈ s i → (a, b) ∈ t :=\n  h.mem_iff.trans <| by simp only [prod.forall, subset_def]\n#align filter.has_basis.mem_uniformity_iff filter.has_basis.mem_uniformity_iff\n\n",
 "mem_uniform_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem mem_uniform_prod [t₁ : uniform_space α] [t₂ : uniform_space β] {a : set (α × α)} {b : set (β × β)}\n    (ha : a ∈ (uniformity) α) (hb : b ∈ (uniformity) β) :\n    { p : (α × β) × α × β | (p.1.1, p.2.1) ∈ a ∧ (p.1.2, p.2.2) ∈ b } ∈ @uniformity (α × β) _ := by\n  rw [uniformity_prod] <;> exact inter_mem_inf (preimage_mem_comap ha) (preimage_mem_comap hb)\n#align mem_uniform_prod mem_uniform_prod\n\n",
 "mem_nhds_uniformity_iff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem mem_nhds_uniformity_iff_right {x : α} {s : set α} :\n    s ∈ (nhds) x ↔ { p : α × α | p.1 = x → p.2 ∈ s } ∈ (uniformity) α :=\n  by\n  refine' ⟨_, fun hs => _⟩\n  · simp only [mem_nhds_iff, is_open_uniformity, and_imp, exists_imp]\n    intro t ts ht xt\n    filter_upwards [ht x xt] using fun y h eq => ts (h eq)\n  · refine' mem_nhds_iff.mpr ⟨{ x | { p : α × α | p.1 = x → p.2 ∈ s } ∈ (uniformity) α }, _, _, hs⟩\n    · exact fun y hy => refl_mem_uniformity hy rfl\n    · refine' is_open_uniformity.mpr fun y hy => _\n      rcases comp_mem_uniformity_sets hy with ⟨t, ht, tr⟩\n      filter_upwards [ht]\n      rintro ⟨a, b⟩ hp' rfl\n      filter_upwards [ht]\n      rintro ⟨a', b'⟩ hp'' rfl\n      exact @tr (a, b') ⟨a', hp', hp''⟩ rfl\n#align mem_nhds_uniformity_iff_right mem_nhds_uniformity_iff_right\n\n",
 "mem_nhds_uniformity_iff_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem mem_nhds_uniformity_iff_left {x : α} {s : set α} :\n    s ∈ (nhds) x ↔ { p : α × α | p.2 = x → p.1 ∈ s } ∈ (uniformity) α :=\n  by\n  rw [uniformity_eq_symm, mem_nhds_uniformity_iff_right]\n  rfl\n#align mem_nhds_uniformity_iff_left mem_nhds_uniformity_iff_left\n\n",
 "mem_nhds_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_nhds_right (y : α) {s : set (α × α)} (h : s ∈ (uniformity) α) : { x : α | (x, y) ∈ s } ∈ (nhds) y :=\n  mem_nhds_left _ (symm_le_uniformity h)\n#align mem_nhds_right mem_nhds_right\n\n",
 "mem_nhds_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_nhds_left (x : α) {s : set (α × α)} (h : s ∈ (uniformity) α) : { y : α | (x, y) ∈ s } ∈ (nhds) x :=\n  ball_mem_nhds x h\n#align mem_nhds_left mem_nhds_left\n\n",
 "mem_nhds_iff_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniform_space.mem_nhds_iff_symm {x : α} {s : set α} :\n    s ∈ (nhds) x ↔ ∃ V ∈ (uniformity) α, symmetric_rel V ∧ ball x V ⊆ s :=\n  by\n  rw [uniform_space.mem_nhds_iff]\n  constructor\n  · rintro ⟨V, V_in, V_sub⟩\n    use symmetrize_rel V, symmetrize_mem_uniformity V_in, symmetric_symmetrize_rel V\n    exact subset.trans (ball_mono (symmetrize_rel_subset_self V) x) V_sub\n  · rintro ⟨V, V_in, V_symm, V_sub⟩\n    exact ⟨V, V_in, V_sub⟩\n#align uniform_space.mem_nhds_iff_symm uniform_space.mem_nhds_iff_symm\n\n",
 "mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniform_space.mem_nhds_iff {x : α} {s : set α} : s ∈ (nhds) x ↔ ∃ V ∈ (uniformity) α, ball x V ⊆ s :=\n  by\n  rw [nhds_eq_comap_uniformity, mem_comap]\n  exact iff.rfl\n#align uniform_space.mem_nhds_iff uniform_space.mem_nhds_iff\n\n",
 "mem_id_rel":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Patrick Massot\n-/\n@[simp]\ntheorem mem_id_rel {a b : α} : (a, b) ∈ @id_rel α ↔ a = b :=\n  iff.rfl\n#align mem_id_rel mem_id_rel\n\n",
 "mem_comp_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n@[simp]\ntheorem mem_comp_rel {r₁ r₂ : set (α × α)} {x y : α} :\n    (x, y) ∈ uniformity.comp_rel r₁ r₂ ↔ ∃ z, (x, z) ∈ r₁ ∧ (z, y) ∈ r₂ :=\n  iff.rfl\n#align mem_comp_rel mem_comp_rel\n\n",
 "mem_comp_of_mem_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem mem_comp_of_mem_ball {V W : set (β × β)} {x y z : β} (hV : symmetric_rel V) (hx : x ∈ ball z V)\n    (hy : y ∈ ball z W) : (x, y) ∈ uniformity.comp_rel V W :=\n  by\n  rw [mem_ball_symmetry hV] at hx\n  exact ⟨z, hx, hy⟩\n#align mem_comp_of_mem_ball mem_comp_of_mem_ball\n\n",
 "mem_comp_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem mem_comp_comp {V W M : set (β × β)} (hW' : symmetric_rel W) {p : β × β} :\n    p ∈ uniformity.comp_rel (uniformity.comp_rel V M) W ↔ (lower_set.prod (ball p.1 V) (ball p.2 W) ∩ M).nonempty :=\n  by\n  cases' p with x y\n  constructor\n  · rintro ⟨z, ⟨w, hpw, hwz⟩, hzy⟩\n    exact ⟨(w, z), ⟨hpw, by rwa [mem_ball_symmetry hW']⟩, hwz⟩\n  · rintro ⟨⟨w, z⟩, ⟨w_in, z_in⟩, hwz⟩\n    rwa [mem_ball_symmetry hW'] at z_in\n    use z, w <;> tauto\n#align mem_comp_comp mem_comp_comp\n\n",
 "mem_closure_iff_symm_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniform_space.mem_closure_iff_symm_ball {s : set α} {x} :\n    x ∈ closure s ↔ ∀ {V}, V ∈ (uniformity) α → symmetric_rel V → (s ∩ ball x V).nonempty := by\n  simp [mem_closure_iff_nhds_basis (has_basis_nhds x), Set.Nonempty]\n#align uniform_space.mem_closure_iff_symm_ball uniform_space.mem_closure_iff_symm_ball\n\n",
 "mem_closure_iff_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniform_space.mem_closure_iff_ball {s : set α} {x} :\n    x ∈ closure s ↔ ∀ {V}, V ∈ (uniformity) α → (ball x V ∩ s).nonempty := by\n  simp [mem_closure_iff_nhds_basis' (nhds_basis_uniformity' ((uniformity) α).basis_sets)]\n#align uniform_space.mem_closure_iff_ball uniform_space.mem_closure_iff_ball\n\n",
 "mem_ball_symmetry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mem_ball_symmetry {V : set (β × β)} (hV : symmetric_rel V) {x y} : x ∈ ball y V ↔ y ∈ ball x V :=\n  show (x, y) ∈ «expr ⁻¹' » prod.swap V ↔ (x, y) ∈ V\n    by\n    unfold symmetric_rel at hV\n    rw [hV]\n#align mem_ball_symmetry mem_ball_symmetry\n\n",
 "mem_ball_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniform_space.mem_ball_self (x : α) {V : set (α × α)} (hV : V ∈ (uniformity) α) : x ∈ ball x V :=\n  refl_mem_uniformity hV\n#align uniform_space.mem_ball_self uniform_space.mem_ball_self\n\n",
 "mem_ball_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/-- The triangle inequality for `uniform_space.ball` -/\ntheorem mem_ball_comp {V W : set (β × β)} {x y z} (h : y ∈ ball x V) (h' : z ∈ ball y W) :\n    z ∈ ball x (uniformity.comp_rel V W) :=\n  prod_mk_mem_comp_rel h h'\n#align mem_ball_comp mem_ball_comp\n\n",
 "lift_nhds_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem lift_nhds_right {x : α} {g : set α → filter β} (hg : monotone g) :\n    ((nhds) x).lift g = ((uniformity) α).lift fun s : set (α × α) => g { y | (y, x) ∈ s } :=\n  calc\n    ((nhds) x).lift g = ((uniformity) α).lift fun s : set (α × α) => g { y | (x, y) ∈ s } := lift_nhds_left hg\n    _ = (@prod.swap α α <$> (uniformity) α).lift fun s : set (α × α) => g { y | (x, y) ∈ s } := by\n      rw [← uniformity_eq_symm]\n    _ = ((uniformity) α).lift fun s : set (α × α) => g { y | (x, y) ∈ image prod.swap s } :=\n      map_lift_eq2 <| hg.comp monotone_preimage\n    _ = _ := by simp [image_swap_eq_preimage_swap]\n    \n#align lift_nhds_right lift_nhds_right\n\n",
 "lift_nhds_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem lift_nhds_left {x : α} {g : set α → filter β} (hg : monotone g) :\n    ((nhds) x).lift g = ((uniformity) α).lift fun s : set (α × α) => g { y | (x, y) ∈ s } :=\n  eq.trans\n    (by\n      rw [nhds_eq_uniformity]\n      exact filter.lift_assoc <| monotone_principal.comp <| monotone_preimage.comp monotone_preimage)\n    (congr_arg _ <| funext fun s => filter.lift_principal hg)\n#align lift_nhds_left lift_nhds_left\n\n",
 "left_subset_comp_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem left_subset_comp_rel {s t : set (α × α)} (h : id_rel ⊆ t) : s ⊆ uniformity.comp_rel s t := fun ⟨x, y⟩ xy_in =>\n  ⟨y, xy_in, h <| rfl⟩\n#align left_subset_comp_rel left_subset_comp_rel\n\n",
 "lebesgue_number_of_compact_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- A useful consequence of the Lebesgue number lemma: given any compact set `K` contained in an\nopen set `U`, we can find an (open) entourage `V` such that the ball of size `V` about any point of\n`K` is contained in `U`. -/\ntheorem lebesgue_number_of_compact_open [uniform_space α] {K U : set α} (hK : is_compact K) (hU : is_open U)\n    (hKU : K ⊆ U) : ∃ V ∈ (uniformity) α, is_open V ∧ ∀ x ∈ K, uniform_space.ball x V ⊆ U :=\n  by\n  let W : K → set (α × α) := fun k => Classical.choose <| is_open_iff_open_ball_subset.mp hU k.1 <| hKU k.2\n  have hW : ∀ k, W k ∈ (uniformity) α ∧ is_open (W k) ∧ uniform_space.ball k.1 (W k) ⊆ U :=\n    by\n    intro k\n    obtain ⟨h₁, h₂, h₃⟩ := Classical.choose_spec (is_open_iff_open_ball_subset.mp hU k.1 (hKU k.2))\n    exact ⟨h₁, h₂, h₃⟩\n  let c : K → set α := fun k => uniform_space.ball k.1 (W k)\n  have hc₁ : ∀ k, is_open (c k) := fun k => uniform_space.is_open_ball k.1 (hW k).2.1\n  have hc₂ :\n    K ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (c i) :=\n    by\n    intro k hk\n    simp only [mem_Union, SetCoe.exists]\n    exact ⟨k, hk, uniform_space.mem_ball_self k (hW ⟨k, hk⟩).1⟩\n  have hc₃ : ∀ k, c k ⊆ U := fun k => (hW k).2.2\n  obtain ⟨V, hV, hV'⟩ := lebesgue_number_lemma hK hc₁ hc₂\n  refine' ⟨interior V, interior_mem_uniformity hV, is_open_interior, _⟩\n  intro k hk\n  obtain ⟨k', hk'⟩ := hV' k hk\n  exact ((ball_mono interior_subset k).trans hk').trans (hc₃ k')\n#align lebesgue_number_of_compact_open lebesgue_number_of_compact_open\n\n",
 "lebesgue_number_lemma_sUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Let `c : set (set α)` be an open cover of a compact set `s`. Then there exists an entourage\n`n` such that for each `x ∈ s` its `n`-neighborhood is contained in some `t ∈ c`. -/\ntheorem lebesgue_number_lemma_sUnion {α : Type u} [uniform_space α] {s : set α} {c : set (set α)} (hs : is_compact s)\n    (hc₁ : ∀ t ∈ c, is_open t) (hc₂ : s ⊆ ⋃₀ c) : ∃ n ∈ (uniformity) α, ∀ x ∈ s, ∃ t ∈ c, ∀ y, (x, y) ∈ n → y ∈ t := by\n  rw [sUnion_eq_Union] at hc₂ <;> simpa using lebesgue_number_lemma hs (by simpa) hc₂\n#align lebesgue_number_lemma_sUnion lebesgue_number_lemma_sUnion\n\n",
 "lebesgue_number_lemma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n-- For a version of the Lebesgue number lemma assuming only a sequentially compact space,\n-- see topology/sequences.lean\n/-- Let `c : ι → set α` be an open cover of a compact set `s`. Then there exists an entourage\n`n` such that for each `x ∈ s` its `n`-neighborhood is contained in some `c i`. -/\ntheorem lebesgue_number_lemma {α : Type u} [uniform_space α] {s : set α} {ι} {c : ι → set α} (hs : is_compact s)\n    (hc₁ : ∀ i, is_open (c i))\n    (hc₂ : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (c i)) :\n    ∃ n ∈ (uniformity) α, ∀ x ∈ s, ∃ i, { y | (x, y) ∈ n } ⊆ c i :=\n  by\n  let u n := { x | ∃ i, ∃ m ∈ (uniformity) α, { y | (x, y) ∈ uniformity.comp_rel m n } ⊆ c i }\n  have hu₁ : ∀ n ∈ (uniformity) α, is_open (u n) :=\n    by\n    refine' fun n hn => is_open_uniformity.2 _\n    rintro x ⟨i, m, hm, h⟩\n    rcases comp_mem_uniformity_sets hm with ⟨m', hm', mm'⟩\n    apply ((uniformity) α).sets_of_superset hm'\n    rintro ⟨x, y⟩ hp rfl\n    refine' ⟨i, m', hm', fun z hz => h (monotone_comp_rel monotone_id monotone_const mm' _)⟩\n    dsimp [-mem_comp_rel] at hz⊢\n    rw [comp_rel_assoc]\n    exact ⟨y, hp, hz⟩\n  have hu₂ :\n    s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u n) :=\n    by\n    intro x hx\n    rcases mem_Union.1 (hc₂ hx) with ⟨i, h⟩\n    rcases comp_mem_uniformity_sets (is_open_uniformity.1 (hc₁ i) x h) with ⟨m', hm', mm'⟩\n    exact mem_bUnion hm' ⟨i, _, hm', fun y hy => mm' hy rfl⟩\n  rcases hs.elim_finite_subcover_image hu₁ hu₂ with ⟨b, bu, b_fin, b_cover⟩\n  refine' ⟨_, (bInter_mem b_fin).2 bu, fun x hx => _⟩\n  rcases mem_Union₂.1 (b_cover hx) with ⟨n, bn, i, m, hm, h⟩\n  refine' ⟨i, fun y hy => h _⟩\n  exact prod_mk_mem_comp_rel (refl_mem_uniformity hm) (bInter_subset_of_mem bn hy)\n#align lebesgue_number_lemma lebesgue_number_lemma\n\n",
 "le_infₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print le_infₛ /-\nprivate theorem le_infₛ {tt : set (uniform_space α)} {t : uniform_space α} (h : ∀ t' ∈ tt, t ≤ t') : t ≤ infₛ tt :=\n  show\n    t.uniformity ≤\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (@uniformity α u)\n    from le_infᵢ fun t' => le_infᵢ fun ht' => h t' ht'\n#align le_Inf le_infₛ\n-/\n\n",
 "le_iff_uniform_continuous_id":
 "theorem le_iff_uniform_continuous_id {u v : uniform_space α} : u ≤ v ↔ @uniform_continuous _ _ u v id := by\n  rw [uniform_continuous_iff, uniform_space_comap_id, id]\n#align le_iff_uniform_continuous_id le_iff_uniform_continuous_id\n\n",
 "is_open_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem is_open_uniformity {s : set α} : is_open s ↔ ∀ x ∈ s, { p : α × α | p.1 = x → p.2 ∈ s } ∈ (uniformity) α :=\n  uniform_space.is_open_uniformity s\n#align is_open_uniformity is_open_uniformity\n\n",
 "is_open_iff_open_ball_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem is_open_iff_open_ball_subset {s : set α} :\n    is_open s ↔ ∀ x ∈ s, ∃ V ∈ (uniformity) α, is_open V ∧ ball x V ⊆ s :=\n  by\n  rw [is_open_iff_ball_subset]\n  constructor <;> intro h x hx\n  · obtain ⟨V, hV, hV'⟩ := h x hx\n    exact ⟨interior V, interior_mem_uniformity hV, is_open_interior, (ball_mono interior_subset x).trans hV'⟩\n  · obtain ⟨V, hV, -, hV'⟩ := h x hx\n    exact ⟨V, hV, hV'⟩\n#align is_open_iff_open_ball_subset is_open_iff_open_ball_subset\n\n",
 "is_open_iff_ball_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- See also `is_open_iff_open_ball_subset`. -/\ntheorem is_open_iff_ball_subset {s : set α} : is_open s ↔ ∀ x ∈ s, ∃ V ∈ (uniformity) α, ball x V ⊆ s :=\n  by\n  simp_rw [is_open_iff_mem_nhds, nhds_eq_comap_uniformity]\n  exact iff.rfl\n#align is_open_iff_ball_subset is_open_iff_ball_subset\n\n",
 "is_open_ball":
 "theorem uniform_space.is_open_ball (x : α) {V : set (α × α)} (hV : is_open V) : is_open (ball x V) :=\n  hV.preimage <| continuous_const.prod_mk continuous_id\n#align uniform_space.is_open_ball uniform_space.is_open_ball\n\n",
 "interior_mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem interior_mem_uniformity {s : set (α × α)} (hs : s ∈ (uniformity) α) : interior s ∈ (uniformity) α := by\n  rw [uniformity_eq_uniformity_interior] <;> exact mem_lift' hs\n#align interior_mem_uniformity interior_mem_uniformity\n\n",
 "inter":
 "theorem symmetric_rel.inter {U V : set (α × α)} (hU : symmetric_rel U) (hV : symmetric_rel V) : symmetric_rel (U ∩ V) :=\n  by rw [symmetric_rel, preimage_inter, hU.eq, hV.eq]\n#align symmetric_rel.inter symmetric_rel.inter\n\n",
 "infₛ_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print infₛ_le /-\nprivate theorem infₛ_le {tt : set (uniform_space α)} {t : uniform_space α} (h : t ∈ tt) : infₛ tt ≤ t :=\n  show\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (@uniformity α u) ≤\n      t.uniformity\n    from infᵢ_le_of_le t <| infᵢ_le _ h\n#align Inf_le infₛ_le\n-/\n\n",
 "infi_uniformity'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem infi_uniformity' {ι : Sort _} {u : ι → uniform_space α} :\n    @uniformity α (infᵢ u) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (@uniformity α (u i)) :=\n  infi_uniformity\n#align infi_uniformity' infi_uniformity'\n\n",
 "infi_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem infi_uniformity {ι : Sort _} {u : ι → uniform_space α} :\n    (infᵢ u).uniformity =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (u i).uniformity :=\n  show «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" a.uniformity = _\n    from\n    le_antisymm (le_infᵢ fun i => infᵢ_le_of_le (u i) <| infᵢ_le _ ⟨i, rfl⟩)\n      (le_infᵢ fun a => le_infᵢ fun ⟨i, (ha : u i = a)⟩ => ha ▸ infᵢ_le _ _)\n#align infi_uniformity infi_uniformity\n\n",
 "inf_uniformity'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_uniformity' {u v : uniform_space α} :\n    @uniformity α («expr ⊓ » u v) = «expr ⊓ » (@uniformity α u) (@uniformity α v) :=\n  rfl\n#align inf_uniformity' inf_uniformity'\n\n",
 "inf_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_uniformity {u v : uniform_space α} : («expr ⊓ » u v).uniformity = «expr ⊓ » u.uniformity v.uniformity :=\n  rfl\n#align inf_uniformity inf_uniformity\n\n",
 "id_rel_subset":
 "@[simp]\ntheorem id_rel_subset {s : set (α × α)} : id_rel ⊆ s ↔ ∀ a, (a, a) ∈ s := by\n  simp [subset_def] <;> exact forall_congr' fun a => by simp\n#align id_rel_subset id_rel_subset\n\n",
 "id_comp_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n@[simp]\ntheorem id_comp_rel {r : set (α × α)} : uniformity.comp_rel id_rel r = r :=\n  Set.ext fun ⟨a, b⟩ => by simp\n#align id_comp_rel id_comp_rel\n\n",
 "has_seq_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniform_space.has_seq_basis [is_countably_generated <| (uniformity) α] :\n    ∃ V : ℕ → set (α × α), has_antitone_basis ((uniformity) α) V ∧ ∀ n, symmetric_rel (V n) :=\n  let ⟨U, hsym, hbasis⟩ := uniform_space.has_basis_symmetric.exists_antitone_subbasis\n  ⟨U, hbasis, fun n => (hsym n).2⟩\n#align uniform_space.has_seq_basis uniform_space.has_seq_basis\n\n",
 "has_basis_symmetric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Symmetric entourages form a basis of `𝓤 α` -/\ntheorem uniform_space.has_basis_symmetric :\n    ((uniformity) α).has_basis (fun s : set (α × α) => s ∈ (uniformity) α ∧ symmetric_rel s) id :=\n  has_basis_self.2 fun t t_in =>\n    ⟨symmetrize_rel t, symmetrize_mem_uniformity t_in, symmetric_symmetrize_rel t, symmetrize_rel_subset_self t⟩\n#align uniform_space.has_basis_symmetric uniform_space.has_basis_symmetric\n\n",
 "has_basis_nhds_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem uniform_space.has_basis_nhds_prod (x y : α) :\n    has_basis ((nhds) (x, y)) (fun s => s ∈ (uniformity) α ∧ symmetric_rel s) fun s =>\n      lower_set.prod (ball x s) (ball y s) :=\n  by\n  rw [nhds_prod_eq]\n  apply (has_basis_nhds x).prod_same_index (has_basis_nhds y)\n  rintro U V ⟨U_in, U_symm⟩ ⟨V_in, V_symm⟩\n  exact\n    ⟨U ∩ V, ⟨((uniformity) α).inter_sets U_in V_in, U_symm.inter V_symm⟩, ball_inter_left x U V, ball_inter_right y U V⟩\n#align uniform_space.has_basis_nhds_prod uniform_space.has_basis_nhds_prod\n\n",
 "has_basis_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniform_space.has_basis_nhds (x : α) :\n    has_basis ((nhds) x) (fun s : set (α × α) => s ∈ (uniformity) α ∧ symmetric_rel s) fun s => ball x s :=\n  ⟨fun t => by simp [uniform_space.mem_nhds_iff_symm, and_assoc']⟩\n#align uniform_space.has_basis_nhds uniform_space.has_basis_nhds\n\n",
 "exists_uniform_thickening_of_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem disjoint.exists_uniform_thickening_of_basis {p : ι → Prop} {s : ι → set (α × α)}\n    (hU : ((uniformity) α).has_basis p s) {A B : set α} (hA : is_compact A) (hB : is_closed B) (h : Disjoint A B) :\n    ∃ i,\n      p i ∧\n        Disjoint\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (ball x (s i)))\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (ball x (s i))) :=\n  by\n  rcases h.exists_uniform_thickening hA hB with ⟨V, hV, hVAB⟩\n  rcases hU.mem_iff.1 hV with ⟨i, hi, hiV⟩\n  exact ⟨i, hi, hVAB.mono (Union₂_mono fun a _ => ball_mono hiV a) (Union₂_mono fun b _ => ball_mono hiV b)⟩\n#align disjoint.exists_uniform_thickening_of_basis disjoint.exists_uniform_thickening_of_basis\n\n",
 "exists_uniform_thickening":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem disjoint.exists_uniform_thickening {A B : set α} (hA : is_compact A) (hB : is_closed B) (h : Disjoint A B) :\n    ∃ V ∈ (uniformity) α,\n      Disjoint\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (ball x V))\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (ball x V)) :=\n  by\n  have : «expr ᶜ» B ∈ (nhds_set) A := hB.is_open_compl.mem_nhds_set.mpr h.le_compl_right\n  rw [(hA.nhds_set_basis_uniformity (filter.basis_sets _)).mem_iff] at this\n  rcases this with ⟨U, hU, hUAB⟩\n  rcases comp_symm_mem_uniformity_sets hU with ⟨V, hV, hVsymm, hVU⟩\n  refine' ⟨V, hV, set.disjoint_left.mpr fun x => _⟩\n  simp only [mem_Union₂]\n  rintro ⟨a, ha, hxa⟩ ⟨b, hb, hxb⟩\n  rw [mem_ball_symmetry hVsymm] at hxa hxb\n  exact hUAB (mem_Union₂_of_mem ha <| hVU <| mem_comp_of_mem_ball hVsymm hxa hxb) hb\n#align disjoint.exists_uniform_thickening disjoint.exists_uniform_thickening\n\n",
 "exists_mem_nhds_ball_subset_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem exists_mem_nhds_ball_subset_of_mem_nhds {a : α} {U : set α} (h : U ∈ (nhds) a) :\n    ∃ V ∈ (nhds) a, ∃ t ∈ (uniformity) α, ∀ a' ∈ V, uniform_space.ball a' t ⊆ U :=\n  let ⟨t, ht, htU⟩ := comp_mem_uniformity_sets (mem_nhds_uniformity_iff_right.1 h)\n  ⟨_, mem_nhds_left a ht, t, ht, fun a₁ h₁ a₂ h₂ => @htU (a, a₂) ⟨a₁, h₁, h₂⟩ rfl⟩\n#align exists_mem_nhds_ball_subset_of_mem_nhds exists_mem_nhds_ball_subset_of_mem_nhds\n\n",
 "eventually_uniformity_iterate_comp_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `uniformity.comp_rel -/\n/-- If `s ∈ 𝓤 α`, then for any natural `n`, for a subset `t` of a sufficiently small set in `𝓤 α`,\nwe have `t ○ t ○ ... ○ t ⊆ s` (`n` compositions). -/\ntheorem eventually_uniformity_iterate_comp_subset {s : set (α × α)} (hs : s ∈ (uniformity) α) (n : ℕ) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((uniformity) α).small_sets ((«expr ^[ ]» ((uniformity.comp_rel · ·) t) n) t ⊆ s) :=\n  by\n  suffices :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((uniformity) α).small_sets (t ⊆ s ∧ («expr ^[ ]» ((uniformity.comp_rel · ·) t) n) t ⊆ s)\n  exact (eventually_and.1 this).2\n  induction' n with n ihn generalizing s; · simpa\n  rcases comp_mem_uniformity_sets hs with ⟨t, htU, hts⟩\n  refine' (ihn htU).mono fun U hU => _\n  rw [function.iterate_succ_apply']\n  exact ⟨hU.1.trans <| (subset_comp_self <| refl_le_uniformity htU).trans hts, (comp_rel_mono hU.1 hU.2).trans hts⟩\n#align eventually_uniformity_iterate_comp_subset eventually_uniformity_iterate_comp_subset\n\n",
 "eventually_uniformity_comp_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/-- If `s ∈ 𝓤 α`, then for any natural `n`, for a subset `t` of a sufficiently small set in `𝓤 α`,\nwe have `t ○ t ⊆ s`. -/\ntheorem eventually_uniformity_comp_subset {s : set (α × α)} (hs : s ∈ (uniformity) α) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((uniformity) α).small_sets (uniformity.comp_rel t t ⊆ s) :=\n  eventually_uniformity_iterate_comp_subset hs 1\n#align eventually_uniformity_comp_subset eventually_uniformity_comp_subset\n\n",
 "eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem symmetric_rel.eq {U : set (α × α)} (hU : symmetric_rel U) : «expr ⁻¹' » prod.swap U = U :=\n  hU\n#align symmetric_rel.eq symmetric_rel.eq\n\n",
 "discrete_topology_of_discrete_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/-- A uniform space with the discrete uniformity has the discrete topology. -/\ntheorem discrete_topology_of_discrete_uniformity [hα : uniform_space α] (h : uniformity α = (filter.principal) id_rel) :\n    discrete_topology α :=\n  ⟨(uniform_space_eq h.symm : «expr⊥» = hα) ▸ rfl⟩\n#align discrete_topology_of_discrete_uniformity discrete_topology_of_discrete_uniformity\n\n",
 "core_eq":
 "theorem uniform_space.core_eq : ∀ {u₁ u₂ : uniform_space.core α}, u₁.uniformity = u₂.uniformity → u₁ = u₂\n  | ⟨u₁, _, _, _⟩, ⟨u₂, _, _, _⟩, h => by\n    congr\n    exact h\n#align uniform_space.core_eq uniform_space.core_eq\n\n",
 "continuous_within_at_iff'_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_within_at_iff'_right [topological_space β] {f : β → α} {b : β} {s : set β} :\n    continuous_within_at f s b ↔ tendsto (fun x => (f b, f x)) (nhds_within s b) ((uniformity) α) := by\n  rw [continuous_within_at, tendsto_nhds_right]\n#align continuous_within_at_iff'_right continuous_within_at_iff'_right\n\n",
 "continuous_within_at_iff'_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_within_at_iff'_left [topological_space β] {f : β → α} {b : β} {s : set β} :\n    continuous_within_at f s b ↔ tendsto (fun x => (f x, f b)) (nhds_within s b) ((uniformity) α) := by\n  rw [continuous_within_at, tendsto_nhds_left]\n#align continuous_within_at_iff'_left continuous_within_at_iff'_left\n\n",
 "continuous_on_iff'_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_on_iff'_right [topological_space β] {f : β → α} {s : set β} :\n    continuous_on f s ↔ ∀ b ∈ s, tendsto (fun x => (f b, f x)) (nhds_within s b) ((uniformity) α) := by\n  simp [continuous_on, continuous_within_at_iff'_right]\n#align continuous_on_iff'_right continuous_on_iff'_right\n\n",
 "continuous_on_iff'_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_on_iff'_left [topological_space β] {f : β → α} {s : set β} :\n    continuous_on f s ↔ ∀ b ∈ s, tendsto (fun x => (f x, f b)) (nhds_within s b) ((uniformity) α) := by\n  simp [continuous_on, continuous_within_at_iff'_left]\n#align continuous_on_iff'_left continuous_on_iff'_left\n\n",
 "continuous_on":
 "theorem uniform_continuous_on.continuous_on [uniform_space α] [uniform_space β] {f : α → β} {s : set α}\n    (h : uniform_continuous_on f s) : continuous_on f s :=\n  by\n  rw [uniform_continuous_on_iff_restrict] at h\n  rw [continuous_on_iff_continuous_restrict]\n  exact h.continuous\n#align uniform_continuous_on.continuous_on uniform_continuous_on.continuous_on\n\n",
 "continuous_iff'_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_iff'_right [topological_space β] {f : β → α} :\n    continuous f ↔ ∀ b, tendsto (fun x => (f b, f x)) ((nhds) b) ((uniformity) α) :=\n  continuous_iff_continuous_at.trans <| forall_congr' fun b => tendsto_nhds_right\n#align continuous_iff'_right continuous_iff'_right\n\n",
 "continuous_iff'_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_iff'_left [topological_space β] {f : β → α} :\n    continuous f ↔ ∀ b, tendsto (fun x => (f x, f b)) ((nhds) b) ((uniformity) α) :=\n  continuous_iff_continuous_at.trans <| forall_congr' fun b => tendsto_nhds_left\n#align continuous_iff'_left continuous_iff'_left\n\n",
 "continuous_at_iff_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_at_iff_prod [topological_space β] {f : β → α} {b : β} :\n    continuous_at f b ↔ tendsto (fun x : β × β => (f x.1, f x.2)) ((nhds) (b, b)) ((uniformity) α) :=\n  ⟨fun H => le_trans (H.prod_map' H) (nhds_le_uniformity _), fun H =>\n    continuous_at_iff'_left.2 <| H.comp <| tendsto_id.prod_mk_nhds tendsto_const_nhds⟩\n#align continuous_at_iff_prod continuous_at_iff_prod\n\n",
 "continuous_at_iff'_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_at_iff'_right [topological_space β] {f : β → α} {b : β} :\n    continuous_at f b ↔ tendsto (fun x => (f b, f x)) ((nhds) b) ((uniformity) α) := by\n  rw [continuous_at, tendsto_nhds_right]\n#align continuous_at_iff'_right continuous_at_iff'_right\n\n",
 "continuous_at_iff'_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem continuous_at_iff'_left [topological_space β] {f : β → α} {b : β} :\n    continuous_at f b ↔ tendsto (fun x => (f x, f b)) ((nhds) b) ((uniformity) α) := by\n  rw [continuous_at, tendsto_nhds_left]\n#align continuous_at_iff'_left continuous_at_iff'_left\n\n",
 "continuous":
 "theorem uniform_continuous.continuous [uniform_space α] [uniform_space β] {f : α → β} (hf : uniform_continuous f) :\n    continuous f :=\n  continuous_iff_le_induced.mpr <| to_topological_space_mono <| uniform_continuous_iff.1 hf\n#align uniform_continuous.continuous uniform_continuous.continuous\n\n",
 "congr_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.congr_uniformity {α β} [uniform_space β] {f g : α → β} {l : filter α} {b : β}\n    (hf : tendsto f l ((nhds) b)) (hg : tendsto (fun x => (f x, g x)) l ((uniformity) β)) : tendsto g l ((nhds) b) :=\n  uniform.tendsto_nhds_right.2 <| (uniform.tendsto_nhds_right.1 hf).uniformity_trans hg\n#align filter.tendsto.congr_uniformity filter.tendsto.congr_uniformity\n\n",
 "comp_symm_of_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem comp_symm_of_uniformity {s : set (α × α)} (hs : s ∈ (uniformity) α) :\n    ∃ t ∈ (uniformity) α, (∀ {a b}, (a, b) ∈ t → (b, a) ∈ t) ∧ uniformity.comp_rel t t ⊆ s :=\n  let ⟨t, ht₁, ht₂⟩ := comp_mem_uniformity_sets hs\n  let ⟨t', ht', ht'₁, ht'₂⟩ := symm_of_uniformity ht₁\n  ⟨t', ht', ht'₁, Subset.trans (monotone_comp_rel monotone_id monotone_id ht'₂) ht₂⟩\n#align comp_symm_of_uniformity comp_symm_of_uniformity\n\n",
 "comp_symm_mem_uniformity_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/-- See also `comp_open_symm_mem_uniformity_sets`. -/\ntheorem comp_symm_mem_uniformity_sets {s : set (α × α)} (hs : s ∈ (uniformity) α) :\n    ∃ t ∈ (uniformity) α, symmetric_rel t ∧ uniformity.comp_rel t t ⊆ s :=\n  by\n  obtain ⟨w, w_in, w_sub⟩ : ∃ w ∈ (uniformity) α, uniformity.comp_rel w w ⊆ s := comp_mem_uniformity_sets hs\n  use symmetrize_rel w, symmetrize_mem_uniformity w_in, symmetric_symmetrize_rel w\n  have : symmetrize_rel w ⊆ w := symmetrize_rel_subset_self w\n  calc\n    uniformity.comp_rel (symmetrize_rel w) (symmetrize_rel w) ⊆ uniformity.comp_rel w w := by mono\n    _ ⊆ s := w_sub\n    \n#align comp_symm_mem_uniformity_sets comp_symm_mem_uniformity_sets\n\n",
 "comp_rel_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n@[mono]\ntheorem comp_rel_mono {f g h k : set (α × α)} (h₁ : f ⊆ h) (h₂ : g ⊆ k) :\n    uniformity.comp_rel f g ⊆ uniformity.comp_rel h k := fun ⟨x, y⟩ ⟨z, h, h'⟩ => ⟨z, h₁ h, h₂ h'⟩\n#align comp_rel_mono comp_rel_mono\n\n",
 "comp_rel_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem comp_rel_assoc {r s t : set (α × α)} :\n    uniformity.comp_rel (uniformity.comp_rel r s) t = uniformity.comp_rel r (uniformity.comp_rel s t) := by\n  ext p <;> cases p <;> simp only [mem_comp_rel] <;> tauto\n#align comp_rel_assoc comp_rel_assoc\n\n",
 "comp_open_symm_mem_uniformity_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem comp_open_symm_mem_uniformity_sets {s : set (α × α)} (hs : s ∈ (uniformity) α) :\n    ∃ t ∈ (uniformity) α, is_open t ∧ symmetric_rel t ∧ uniformity.comp_rel t t ⊆ s :=\n  by\n  obtain ⟨t, ht₁, ht₂⟩ := comp_mem_uniformity_sets hs\n  obtain ⟨u, ⟨hu₁, hu₂, hu₃⟩, hu₄ : u ⊆ t⟩ := uniformity_has_basis_open_symmetric.mem_iff.mp ht₁\n  exact ⟨u, hu₁, hu₂, hu₃, (comp_rel_mono hu₄ hu₄).trans ht₂⟩\n#align comp_open_symm_mem_uniformity_sets comp_open_symm_mem_uniformity_sets\n\n",
 "comp_mem_uniformity_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem comp_mem_uniformity_sets {s : set (α × α)} (hs : s ∈ (uniformity) α) :\n    ∃ t ∈ (uniformity) α, uniformity.comp_rel t t ⊆ s :=\n  have : s ∈ ((uniformity) α).lift' fun t : set (α × α) => uniformity.comp_rel t t := comp_le_uniformity hs\n  (mem_lift'_sets <| monotone_comp_rel monotone_id monotone_id).mp this\n#align comp_mem_uniformity_sets comp_mem_uniformity_sets\n\n",
 "comp_le_uniformity3":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem comp_le_uniformity3 :\n    (((uniformity) α).lift' fun s : set (α × α) => uniformity.comp_rel s (uniformity.comp_rel s s)) ≤ (uniformity) α :=\n  calc\n    (((uniformity) α).lift' fun d => uniformity.comp_rel d (uniformity.comp_rel d d)) =\n        ((uniformity) α).lift fun s =>\n          ((uniformity) α).lift' fun t : set (α × α) => uniformity.comp_rel s (uniformity.comp_rel t t) :=\n      by\n      rw [lift_lift'_same_eq_lift']\n      exact fun x => monotone_comp_rel monotone_const <| monotone_comp_rel monotone_id monotone_id\n      exact fun x => monotone_comp_rel monotone_id monotone_const\n    _ ≤ ((uniformity) α).lift fun s => ((uniformity) α).lift' fun t : set (α × α) => uniformity.comp_rel s t :=\n      lift_mono' fun s hs =>\n        @uniformity_lift_le_comp α _ _ (filter.principal ∘ (uniformity.comp_rel · ·) s) <|\n          monotone_principal.comp (monotone_comp_rel monotone_const monotone_id)\n    _ = ((uniformity) α).lift' fun s : set (α × α) => uniformity.comp_rel s s :=\n      lift_lift'_same_eq_lift' (fun s => monotone_comp_rel monotone_const monotone_id) fun s =>\n        monotone_comp_rel monotone_id monotone_const\n    _ ≤ (uniformity) α := comp_le_uniformity\n    \n#align comp_le_uniformity3 comp_le_uniformity3\n\n",
 "comp_le_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem comp_le_uniformity : (((uniformity) α).lift' fun s : set (α × α) => uniformity.comp_rel s s) ≤ (uniformity) α :=\n  (@uniform_space.to_core α _).comp\n#align comp_le_uniformity comp_le_uniformity\n\n",
 "comp_comp_symm_mem_uniformity_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem comp_comp_symm_mem_uniformity_sets {s : set (α × α)} (hs : s ∈ (uniformity) α) :\n    ∃ t ∈ (uniformity) α, symmetric_rel t ∧ uniformity.comp_rel (uniformity.comp_rel t t) t ⊆ s :=\n  by\n  rcases comp_symm_mem_uniformity_sets hs with ⟨w, w_in, w_symm, w_sub⟩\n  rcases comp_symm_mem_uniformity_sets w_in with ⟨t, t_in, t_symm, t_sub⟩\n  use t, t_in, t_symm\n  have : t ⊆ uniformity.comp_rel t t := subset_comp_self_of_mem_uniformity t_in\n  calc\n    uniformity.comp_rel (uniformity.comp_rel t t) t ⊆ uniformity.comp_rel w t := by mono\n    _ ⊆ uniformity.comp_rel w (uniformity.comp_rel t t) := by mono\n    _ ⊆ uniformity.comp_rel w w := by mono\n    _ ⊆ s := w_sub\n    \n#align comp_comp_symm_mem_uniformity_sets comp_comp_symm_mem_uniformity_sets\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘₂ » -/\ntheorem uniform_continuous₂.comp {f : α → β → γ} {g : γ → δ} (hg : uniform_continuous g) (hf : uniform_continuous₂ f) :\n    uniform_continuous₂ («expr ∘₂ » g f) :=\n  hg.comp hf\n#align uniform_continuous₂.comp uniform_continuous₂.comp\n\n",
 "comap_uniformity_mul_opposite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n@[simp, to_additive]\ntheorem comap_uniformity_mul_opposite [uniform_space α] :\n    comap (fun p : α × α => (MulOpposite.op p.1, MulOpposite.op p.2)) ((uniformity) («expr ᵐᵒᵖ» α)) = (uniformity) α :=\n  by simpa [uniformity_mul_opposite, comap_comap, (· ∘ ·)] using comap_id\n#align comap_uniformity_mul_opposite comap_uniformity_mul_opposite\n\n",
 "comap_swap_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n@[simp]\ntheorem comap_swap_uniformity : comap (@prod.swap α α) ((uniformity) α) = (uniformity) α :=\n  (congr_arg _ uniformity_eq_symm).trans <| comap_map prod.swap_injective\n#align comap_swap_uniformity comap_swap_uniformity\n\n",
 "comap_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniform_space.comap_mono {α γ} {f : α → γ} : monotone fun u : uniform_space γ => u.comap f :=\n  by\n  intro u₁ u₂ hu\n  change (uniformity) _ ≤ (uniformity) _\n  rw [uniformity_comap rfl]\n  exact comap_mono hu\n#align uniform_space.comap_mono uniform_space.comap_mono\n\n",
 "comap_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem uniform_space.comap_infi {ι α γ} {u : ι → uniform_space γ} {f : α → γ} :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u i)).comap f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((u i).comap f) :=\n  by\n  ext : 1\n  change (uniformity) _ = (uniformity) _\n  simp [uniformity_comap rfl, infi_uniformity']\n#align uniform_space.comap_infi uniform_space.comap_infi\n\n",
 "comap_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem uniform_space.comap_inf {α γ} {u₁ u₂ : uniform_space γ} {f : α → γ} :\n    («expr ⊓ » u₁ u₂).comap f = «expr ⊓ » (u₁.comap f) (u₂.comap f) :=\n  uniform_space_eq comap_inf\n#align uniform_space.comap_inf uniform_space.comap_inf\n\n",
 "comap_comap":
 "theorem uniform_space.comap_comap {α β γ} [uγ : uniform_space γ] {f : α → β} {g : β → γ} :\n    uniform_space.comap (g ∘ f) uγ = uniform_space.comap f (uniform_space.comap g uγ) := by\n  ext <;> dsimp only [uniform_space.comap] <;> rw [filter.comap_comap]\n#align uniform_space.comap_comap uniform_space.comap_comap\n\n",
 "closure_eq_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem closure_eq_uniformity (s : set <| α × α) :\n    closure s =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (uniformity.comp_rel (uniformity.comp_rel V s) V) :=\n  by\n  ext ⟨x, y⟩\n  simp (config := { contextual := true }) only [mem_closure_iff_nhds_basis (uniform_space.has_basis_nhds_prod x y),\n    mem_Inter, mem_set_of_eq, and_imp, mem_comp_comp, exists_prop, ← mem_inter_iff, inter_comm, Set.Nonempty]\n#align closure_eq_uniformity closure_eq_uniformity\n\n",
 "closure_eq_inter_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem closure_eq_inter_uniformity {t : set (α × α)} :\n    closure t =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (uniformity.comp_rel d (uniformity.comp_rel t d)) :=\n  calc\n    closure t =\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (uniformity.comp_rel (uniformity.comp_rel V t) V) :=\n      closure_eq_uniformity t\n    _ =\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (uniformity.comp_rel (uniformity.comp_rel V t) V) :=\n      eq.symm <|\n        uniform_space.has_basis_symmetric.bInter_mem fun V₁ V₂ hV => comp_rel_mono (comp_rel_mono hV Subset.rfl) hV\n    _ =\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (uniformity.comp_rel V (uniformity.comp_rel t V)) :=\n      by simp only [comp_rel_assoc]\n    \n#align closure_eq_inter_uniformity closure_eq_inter_uniformity\n\n",
 "bicompl":
 "theorem uniform_continuous₂.bicompl {f : α → β → γ} {ga : δ → α} {gb : δ' → β} (hf : uniform_continuous₂ f)\n    (hga : uniform_continuous ga) (hgb : uniform_continuous gb) : uniform_continuous₂ (bicompl f ga gb) :=\n  hf.uniform_continuous.comp (hga.prod_map hgb)\n#align uniform_continuous₂.bicompl uniform_continuous₂.bicompl\n\n",
 "ball_subset_of_comp_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem ball_subset_of_comp_subset {V W : set (β × β)} {x y} (h : x ∈ ball y W) (h' : uniformity.comp_rel W W ⊆ V) :\n    ball x W ⊆ ball y V := fun z z_in => h' (mem_ball_comp h z_in)\n#align ball_subset_of_comp_subset ball_subset_of_comp_subset\n\n",
 "ball_mono":
 "theorem ball_mono {V W : set (β × β)} (h : V ⊆ W) (x : β) : ball x V ⊆ ball x W :=\n  preimage_mono h\n#align ball_mono ball_mono\n\n",
 "ball_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem uniform_space.ball_mem_nhds (x : α) ⦃V : set (α × α)⦄ (V_in : V ∈ (uniformity) α) : ball x V ∈ (nhds) x :=\n  by\n  rw [uniform_space.mem_nhds_iff]\n  exact ⟨V, V_in, subset.refl _⟩\n#align uniform_space.ball_mem_nhds uniform_space.ball_mem_nhds\n\n",
 "ball_inter_right":
 "theorem ball_inter_right (x : β) (V W : set (β × β)) : ball x (V ∩ W) ⊆ ball x W :=\n  ball_mono (inter_subset_right V W) x\n#align ball_inter_right ball_inter_right\n\n",
 "ball_inter_left":
 "theorem ball_inter_left (x : β) (V W : set (β × β)) : ball x (V ∩ W) ⊆ ball x V :=\n  ball_mono (inter_subset_left V W) x\n#align ball_inter_left ball_inter_left\n\n",
 "ball_inter":
 "theorem ball_inter (x : β) (V W : set (β × β)) : ball x (V ∩ W) = ball x V ∩ ball x W :=\n  preimage_inter\n#align ball_inter ball_inter\n\n",
 "ball_eq_of_symmetry":
 "theorem ball_eq_of_symmetry {V : set (β × β)} (hV : symmetric_rel V) {x} : ball x V = { y | (y, x) ∈ V } :=\n  by\n  ext y\n  rw [mem_ball_symmetry hV]\n  exact iff.rfl\n#align ball_eq_of_symmetry ball_eq_of_symmetry\n\n",
 "bUnion_uniformity_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- The uniform neighborhoods of all points of a dense set cover the whole space. -/\ntheorem dense.bUnion_uniformity_ball {s : set α} {U : set (α × α)} (hs : dense s) (hU : U ∈ (uniformity) α) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (ball x U) = univ :=\n  by\n  refine' Union₂_eq_univ_iff.2 fun y => _\n  rcases hs.inter_nhds_nonempty (mem_nhds_right y hU) with ⟨x, hxs, hxy : (x, y) ∈ U⟩\n  exact ⟨x, hxs, hxy⟩\n#align dense.bUnion_uniformity_ball dense.bUnion_uniformity_ball\n\n",
 "bInter_bUnion_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem filter.has_basis.bInter_bUnion_ball {p : ι → Prop} {U : ι → set (α × α)} (h : has_basis ((uniformity) α) p U)\n    (s : set α) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (ball x (U i))) =\n      closure s :=\n  by\n  ext x\n  simp [mem_closure_iff_nhds_basis (nhds_basis_uniformity h), ball]\n#align filter.has_basis.bInter_bUnion_ball filter.has_basis.bInter_bUnion_ball\n\n"}