{"union":
 "#print IsComplete.union /-\nprotected theorem IsComplete.union {s t : Set Œ±} (hs : IsComplete s) (ht : IsComplete t) : IsComplete (s ‚à™ t) :=\n  by\n  simp only [isComplete_iff_ultrafilter', Ultrafilter.union_mem_iff, or_imp] at *\n  exact fun l hl =>\n    ‚ü®fun hsl => (hs l hl hsl).imp fun x hx => ‚ü®or.inl hx.fst, hx.snd‚ü©, fun htl =>\n      (ht l hl htl).imp fun x hx => ‚ü®or.inr hx.fst, hx.snd‚ü©‚ü©\n#align is_complete.union IsComplete.union\n-/\n\n",
 "ultrafilter_of":
 "#print Cauchy.ultrafilter_of /-\ntheorem Cauchy.ultrafilter_of {l : Filter Œ±} (h : Cauchy l) : Cauchy (@Ultrafilter.of _ l h.1 : Filter Œ±) :=\n  by\n  haveI := h.1\n  have := Ultrafilter.of_le l\n  exact ‚ü®Ultrafilter.neBot _, (Filter.prod_mono this this).trans h.2‚ü©\n#align cauchy.ultrafilter_of Cauchy.ultrafilter_of\n-/\n\n",
 "totallyBounded_subset":
 "#print totallyBounded_subset /-\ntheorem totallyBounded_subset {s‚ÇÅ s‚ÇÇ : Set Œ±} (hs : s‚ÇÅ ‚äÜ s‚ÇÇ) (h : TotallyBounded s‚ÇÇ) : TotallyBounded s‚ÇÅ := fun d hd =>\n  let ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü© := h d hd\n  ‚ü®t, ht‚ÇÅ, Subset.trans hs ht‚ÇÇ‚ü©\n#align totally_bounded_subset totallyBounded_subset\n-/\n\n",
 "totallyBounded_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n#print CauchySeq.totallyBounded_range /-\n/-- Every Cauchy sequence over `‚Ñï` is totally bounded. -/\ntheorem CauchySeq.totallyBounded_range {s : ‚Ñï ‚Üí Œ±} (hs : CauchySeq s) : TotallyBounded (range s) :=\n  by\n  refine' totallyBounded_iff_subset.2 fun a ha => _\n  cases' cauchySeq_iff.1 hs a ha with n hn\n  refine' ‚ü®¬´expr '' ¬ª s { k | k ‚â§ n }, image_subset_range _ _, (finite_le_nat _).image _, _‚ü©\n  rw [range_subset_iff, bUnion_image]\n  intro m\n  rw [mem_Union‚ÇÇ]\n  cases' le_total m n with hm hm\n  exacts[‚ü®m, hm, refl_mem_uniformity ha‚ü©, ‚ü®n, le_refl n, hn m hm n le_rfl‚ü©]\n#align cauchy_seq.totally_bounded_range CauchySeq.totallyBounded_range\n-/\n\n",
 "totallyBounded_of_forall_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n#print totallyBounded_of_forall_symm /-\ntheorem totallyBounded_of_forall_symm {s : Set Œ±}\n    (h :\n      ‚àÄ V ‚àà (uniformity) Œ±,\n        SymmetricRel V ‚Üí\n          ‚àÉ t : Set Œ±,\n            Set.Finite t ‚àß\n              s ‚äÜ\n                ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\"\n                  (ball y V)) :\n    TotallyBounded s :=\n  UniformSpace.hasBasis_symmetric.totally_bounded_iff.2 fun V hV => by\n    simpa only [ball_eq_of_symmetry hV.2] using h V hV.1 hV.2\n#align totally_bounded_of_forall_symm totallyBounded_of_forall_symm\n-/\n\n",
 "totallyBounded_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print totallyBounded_iff_ultrafilter /-\ntheorem totallyBounded_iff_ultrafilter {s : Set Œ±} :\n    TotallyBounded s ‚Üî ‚àÄ f : Ultrafilter Œ±, ‚Üëf ‚â§ (filter.principal) s ‚Üí Cauchy (f : Filter Œ±) :=\n  by\n  refine' ‚ü®fun hs f => f.cauchy_of_totally_bounded hs, fun H => totallyBounded_iff_filter.2 _‚ü©\n  intro f hf hfs\n  exact ‚ü®Ultrafilter.of f, Ultrafilter.of_le f, H _ ((Ultrafilter.of_le f).trans hfs)‚ü©\n#align totally_bounded_iff_ultrafilter totallyBounded_iff_ultrafilter\n-/\n\n",
 "totallyBounded_iff_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t ¬´expr ‚äÜ ¬ª s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n#print totallyBounded_iff_subset /-\ntheorem totallyBounded_iff_subset {s : Set Œ±} :\n    TotallyBounded s ‚Üî\n      ‚àÄ d ‚àà (uniformity) Œ±,\n        ‚àÉ (t : _)(_ : t ‚äÜ s),\n          Set.Finite t ‚àß\n            s ‚äÜ\n              ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\"\n                { x | (x, y) ‚àà d } :=\n  ‚ü®fun H d hd => H.exists_subset hd, fun H d hd =>\n    let ‚ü®t, _, ht‚ü© := H d hd\n    ‚ü®t, ht‚ü©‚ü©\n#align totally_bounded_iff_subset totallyBounded_iff_subset\n-/\n\n",
 "totallyBounded_iff_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ö , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print totallyBounded_iff_filter /-\ntheorem totallyBounded_iff_filter {s : Set Œ±} :\n    TotallyBounded s ‚Üî ‚àÄ f, NeBot f ‚Üí f ‚â§ (filter.principal) s ‚Üí ‚àÉ c ‚â§ f, Cauchy c :=\n  by\n  constructor\n  ¬∑ intro H f hf hfs\n    exact\n      ‚ü®Ultrafilter.of f, Ultrafilter.of_le f,\n        (Ultrafilter.of f).cauchy_of_totally_bounded H ((Ultrafilter.of_le f).trans hfs)‚ü©\n  ¬∑ intro H d hd\n    contrapose! H with hd_cover\n    set f :=\n      ¬´expr‚®Ö , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª\"\n        ((filter.principal)\n          (s \\\n            ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\"\n              { x | (x, y) ‚àà d }))\n    have : ne_bot f := by\n      refine' infi_ne_bot_of_directed' (directed_of_sup _) _\n      ¬∑ intro t‚ÇÅ t‚ÇÇ h\n        exact principal_mono.2 (diff_subset_diff_right <| bUnion_subset_bUnion_left h)\n      ¬∑ intro t\n        simpa [nonempty_diff] using hd_cover t t.finite_to_set\n    have : f ‚â§ (filter.principal) s := inf·µ¢_le_of_le ‚àÖ (by simp)\n    refine' ‚ü®f, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, fun c hcf hc => _‚ü©\n    rcases mem_prod_same_iff.1 (hc.2 hd) with ‚ü®m, hm, hmd‚ü©\n    have : m ‚à© s ‚àà c := inter_mem hm (le_principal_iff.mp (hcf.trans ‚Äπ_‚Ä∫))\n    rcases hc.1.nonempty_of_mem this with ‚ü®y, hym, hys‚ü©\n    set ys :=\n      ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\"\n        { x | (x, y') ‚àà d }\n    have : m ‚äÜ ys := by simpa [ys] using fun x hx => hmd (mk_mem_prod hx hym)\n    have : c ‚â§ (filter.principal) (s \\ ys) := hcf.trans (inf·µ¢_le_of_le {y} le_rfl)\n    refine' hc.1.ne (empty_mem_iff_bot.mp _)\n    filter_upwards [le_principal_iff.1 this, hm]\n    refine' fun x hx hxm => hx.2 _\n    simpa [ys] using hmd (mk_mem_prod hxm hym)\n#align totally_bounded_iff_filter totallyBounded_iff_filter\n-/\n\n",
 "totallyBounded_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n#print Filter.HasBasis.totallyBounded_iff /-\ntheorem Filter.HasBasis.totallyBounded_iff {Œπ} {p : Œπ ‚Üí Prop} {U : Œπ ‚Üí Set (Œ± √ó Œ±)} (H : ((uniformity) Œ±).has_basis p U)\n    {s : Set Œ±} :\n    TotallyBounded s ‚Üî\n      ‚àÄ i,\n        p i ‚Üí\n          ‚àÉ t : Set Œ±,\n            Set.Finite t ‚àß\n              s ‚äÜ\n                ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\"\n                  { x | (x, y) ‚àà U i } :=\n  H.forall_iff fun U V hUV h => h.imp fun t ht => ‚ü®ht.1, ht.2.trans <| union·µ¢‚ÇÇ_mono fun x hx y hy => hUV hy‚ü©\n#align filter.has_basis.totally_bounded_iff Filter.HasBasis.totallyBounded_iff\n-/\n\n",
 "totallyBounded_empty":
 "#print totallyBounded_empty /-\ntheorem totallyBounded_empty : TotallyBounded (‚àÖ : Set Œ±) := fun d hd => ‚ü®‚àÖ, finite_empty, empty_subset _‚ü©\n#align totally_bounded_empty totallyBounded_empty\n-/\n\n",
 "totallyBounded":
 "#print IsCompact.totallyBounded /-\nprotected theorem IsCompact.totallyBounded {s : Set Œ±} (h : IsCompact s) : TotallyBounded s :=\n  (isCompact_iff_totallyBounded_isComplete.1 h).1\n#align is_compact.totally_bounded IsCompact.totallyBounded\n-/\n\n",
 "tendsto_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print CauchySeq.tendsto_uniformity /-\ntheorem CauchySeq.tendsto_uniformity [SemilatticeSup Œ≤] {u : Œ≤ ‚Üí Œ±} (h : CauchySeq u) :\n    Tendsto (prod.map u u) atTop ((uniformity) Œ±) := by\n  simpa only [tendsto, prod_map_map_eq', prod_at_top_at_top_eq] using h.right\n#align cauchy_seq.tendsto_uniformity CauchySeq.tendsto_uniformity\n-/\n\n",
 "tendsto_nhds_of_cauchySeq_of_subseq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_nhds_of_cauchySeq_of_subseq /-\n/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem tendsto_nhds_of_cauchySeq_of_subseq [SemilatticeSup Œ≤] {u : Œ≤ ‚Üí Œ±} (hu : CauchySeq u) {Œπ : Type _} {f : Œπ ‚Üí Œ≤}\n    {p : Filter Œπ} [NeBot p] (hf : Tendsto f p atTop) {a : Œ±} (ha : Tendsto (u ‚àò f) p ((nhds) a)) :\n    Tendsto u atTop ((nhds) a) :=\n  le_nhds_of_cauchy_adhp hu (mapClusterPt_of_comp hf ha)\n#align tendsto_nhds_of_cauchy_seq_of_subseq tendsto_nhds_of_cauchySeq_of_subseq\n-/\n\n",
 "tendsto_limUnder":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print CauchySeq.tendsto_limUnder /-\ntheorem CauchySeq.tendsto_limUnder [SemilatticeSup Œ≤] [CompleteSpace Œ±] [Nonempty Œ±] {u : Œ≤ ‚Üí Œ±} (h : CauchySeq u) :\n    Tendsto u atTop (nhds <| limUnder atTop u) :=\n  h.le_nhds_Lim\n#align cauchy_seq.tendsto_lim CauchySeq.tendsto_limUnder\n-/\n\n",
 "subseq_subseq_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print CauchySeq.subseq_subseq_mem /-\ntheorem CauchySeq.subseq_subseq_mem {V : ‚Ñï ‚Üí Set (Œ± √ó Œ±)} (hV : ‚àÄ n, V n ‚àà (uniformity) Œ±) {u : ‚Ñï ‚Üí Œ±}\n    (hu : CauchySeq u) {f g : ‚Ñï ‚Üí ‚Ñï} (hf : Tendsto f atTop atTop) (hg : Tendsto g atTop atTop) :\n    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, ((u ‚àò f ‚àò œÜ) n, (u ‚àò g ‚àò œÜ) n) ‚àà V n :=\n  by\n  rw [cauchySeq_iff_tendsto] at hu\n  exact ((hu.comp <| hf.prod_at_top hg).comp tendsto_at_top_diagonal).subseq_mem hV\n#align cauchy_seq.subseq_subseq_mem CauchySeq.subseq_subseq_mem\n-/\n\n",
 "subseq_mem_entourage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.subseq_mem_entourage /-\ntheorem Filter.Tendsto.subseq_mem_entourage {V : ‚Ñï ‚Üí Set (Œ± √ó Œ±)} (hV : ‚àÄ n, V n ‚àà (uniformity) Œ±) {u : ‚Ñï ‚Üí Œ±} {a : Œ±}\n    (hu : Tendsto u atTop ((nhds) a)) :\n    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß (u (œÜ 0), a) ‚àà V 0 ‚àß ‚àÄ n, (u <| œÜ (n + 1), u <| œÜ n) ‚àà V (n + 1) :=\n  by\n  rcases mem_at_top_sets.1 (hu (ball_mem_nhds a (symm_le_uniformity <| hV 0))) with ‚ü®n, hn‚ü©\n  rcases(hu.comp (tendsto_add_at_top_nat n)).cauchy_seq.subseq_mem fun n => hV (n + 1) with ‚ü®œÜ, œÜ_mono, hœÜV‚ü©\n  exact ‚ü®fun k => œÜ k + n, œÜ_mono.add_const _, hn _ le_add_self, hœÜV‚ü©\n#align filter.tendsto.subseq_mem_entourage Filter.Tendsto.subseq_mem_entourage\n-/\n\n",
 "subseq_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print CauchySeq.subseq_mem /-\ntheorem CauchySeq.subseq_mem {V : ‚Ñï ‚Üí Set (Œ± √ó Œ±)} (hV : ‚àÄ n, V n ‚àà (uniformity) Œ±) {u : ‚Ñï ‚Üí Œ±} (hu : CauchySeq u) :\n    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, (u <| œÜ (n + 1), u <| œÜ n) ‚àà V n :=\n  by\n  have : ‚àÄ n, ‚àÉ N, ‚àÄ k ‚â• N, ‚àÄ l ‚â• k, (u l, u k) ‚àà V n := by\n    intro n\n    rw [cauchySeq_iff] at hu\n    rcases hu _ (hV n) with ‚ü®N, H‚ü©\n    exact ‚ü®N, fun k hk l hl => H _ (le_trans hk hl) _ hk‚ü©\n  obtain ‚ü®œÜ : ‚Ñï ‚Üí ‚Ñï, œÜ_extr : StrictMono œÜ, hœÜ : ‚àÄ n, ‚àÄ l ‚â• œÜ n, (u l, u <| œÜ n) ‚àà V n‚ü© :=\n    extraction_forall_of_eventually' this\n  exact ‚ü®œÜ, œÜ_extr, fun n => hœÜ _ _ (œÜ_extr <| lt_add_one n).le‚ü©\n#align cauchy_seq.subseq_mem CauchySeq.subseq_mem\n-/\n\n",
 "set_seq_sub_aux":
 "theorem set_seq_sub_aux (n : ‚Ñï) : setSeq hf U_mem n ‚äÜ setSeqAux hf U_mem n :=\n  binter·µ¢_subset_of_mem right_mem_Iic\n#align set_seq_sub_aux set_seq_sub_aux\n\n",
 "set_seq_prod_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem set_seq_prod_subset {N m n} (hm : N ‚â§ m) (hn : N ‚â§ n) :\n    lower_set.prod (setSeq hf U_mem m) (setSeq hf U_mem n) ‚äÜ U N :=\n  by\n  intro p hp\n  refine' (set_seq_aux hf U_mem N).2.snd ‚ü®_, _‚ü© <;> apply set_seq_sub_aux\n  exact set_seq_mono hf U_mem hm hp.1\n  exact set_seq_mono hf U_mem hn hp.2\n#align set_seq_prod_subset set_seq_prod_subset\n\n",
 "set_seq_mono":
 "theorem set_seq_mono ‚¶Ém n : ‚Ñï‚¶Ñ (h : m ‚â§ n) : setSeq hf U_mem n ‚äÜ setSeq hf U_mem m :=\n  binter·µ¢_subset_binter·µ¢_left fun k hk => le_trans hk h\n#align set_seq_mono set_seq_mono\n\n",
 "set_seq_mem":
 "theorem set_seq_mem (n : ‚Ñï) : setSeq hf U_mem n ‚àà f :=\n  (binter·µ¢_mem (finite_le_nat n)).2 fun m _ => (setSeqAux hf U_mem m).2.fst\n#align set_seq_mem set_seq_mem\n\n",
 "seq_pair_mem":
 "theorem seq_pair_mem ‚¶ÉN m n : ‚Ñï‚¶Ñ (hm : N ‚â§ m) (hn : N ‚â§ n) : (seq hf U_mem m, seq hf U_mem n) ‚àà U N :=\n  setSeq_prod_subset hf U_mem hm hn ‚ü®seq_mem hf U_mem m, seq_mem hf U_mem n‚ü©\n#align seq_pair_mem seq_pair_mem\n\n",
 "seq_mem":
 "theorem seq_mem (n : ‚Ñï) : seq hf U_mem n ‚àà setSeq hf U_mem n :=\n  choose_spec <| hf.1.nonempty_of_mem (setSeq_mem hf U_mem n)\n#align seq_mem seq_mem\n\n",
 "seq_is_cauchy_seq":
 "theorem seq_is_cauchy_seq : CauchySeq <| seq hf U_mem :=\n  cauchySeq_of_controlled U U_le <| seq_pair_mem hf U_mem\n#align seq_is_cauchy_seq seq_is_cauchy_seq\n\n",
 "second_countable_of_separable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/-- A separable uniform space with countably generated uniformity filter is second countable:\none obtains a countable basis by taking the balls centered at points in a dense subset,\nand with rational \"radii\" from a countable open symmetric antitone basis of `ùì§ Œ±`. We do not\nregister this as an instance, as there is already an instance going in the other direction\nfrom second countable spaces to separable spaces, and we want to avoid loops. -/\ntheorem second_countable_of_separable [SeparableSpace Œ±] : SecondCountableTopology Œ± :=\n  by\n  rcases exists_countable_dense Œ± with ‚ü®s, hsc, hsd‚ü©\n  obtain\n    ‚ü®t : ‚Ñï ‚Üí Set (Œ± √ó Œ±), hto : ‚àÄ i : ‚Ñï, t i ‚àà ((uniformity) Œ±).sets ‚àß IsOpen (t i) ‚àß SymmetricRel (t i), h_basis :\n      ((uniformity) Œ±).has_antitone_basis t‚ü© :=\n    (@uniformity_hasBasis_open_symmetric Œ± _).exists_antitone_subbasis\n  choose ht_mem hto hts using hto\n  refine'\n    ‚ü®‚ü®¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\"\n          (range fun k => ball x (t k)),\n        hsc.bUnion fun x hx => countable_range _, _‚ü©‚ü©\n  refine' (is_topological_basis_of_open_of_nhds _ _).eq_generate_from\n  ¬∑ simp only [mem_Union‚ÇÇ, mem_range]\n    rintro _ ‚ü®x, hxs, k, rfl‚ü©\n    exact is_open_ball x (hto k)\n  ¬∑ intro x V hxV hVo\n    simp only [mem_Union‚ÇÇ, mem_range, exists_prop]\n    rcases UniformSpace.mem_nhds_iff.1 (IsOpen.mem_nhds hVo hxV) with ‚ü®U, hU, hUV‚ü©\n    rcases comp_symm_of_uniformity hU with ‚ü®U', hU', hsymm, hUU'‚ü©\n    rcases h_basis.to_has_basis.mem_iff.1 hU' with ‚ü®k, -, hk‚ü©\n    rcases hsd.inter_open_nonempty (ball x <| t k) (is_open_ball x (hto k))\n        ‚ü®x, UniformSpace.mem_ball_self _ (ht_mem k)‚ü© with\n      ‚ü®y, hxy, hys‚ü©\n    refine' ‚ü®_, ‚ü®y, hys, k, rfl‚ü©, (hts k).subset hxy, fun z hz => _‚ü©\n    exact hUV (ball_subset_of_comp_subset (hk hxy) hUU' (hk hz))\n#align second_countable_of_separable second_countable_of_separable\n\n",
 "prod_map":
 "#print CauchySeq.prod_map /-\ntheorem CauchySeq.prod_map {Œ≥ Œ¥} [UniformSpace Œ≤] [SemilatticeSup Œ≥] [SemilatticeSup Œ¥] {u : Œ≥ ‚Üí Œ±} {v : Œ¥ ‚Üí Œ≤}\n    (hu : CauchySeq u) (hv : CauchySeq v) : CauchySeq (prod.map u v) := by\n  simpa only [CauchySeq, prod_map_map_eq', prod_at_top_at_top_eq] using hu.prod hv\n#align cauchy_seq.prod_map CauchySeq.prod_map\n-/\n\n",
 "prod":
 "#print CauchySeq.prod /-\ntheorem CauchySeq.prod {Œ≥} [UniformSpace Œ≤] [SemilatticeSup Œ≥] {u : Œ≥ ‚Üí Œ±} {v : Œ≥ ‚Üí Œ≤} (hu : CauchySeq u)\n    (hv : CauchySeq v) : CauchySeq fun x => (u x, v x) :=\n  haveI := hu.nonempty\n  (hu.prod hv).mono (tendsto.prod_mk le_rfl le_rfl)\n#align cauchy_seq.prod CauchySeq.prod\n-/\n\n",
 "nonempty":
 "#print CauchySeq.nonempty /-\ntheorem CauchySeq.nonempty [SemilatticeSup Œ≤] {u : Œ≤ ‚Üí Œ±} (hu : CauchySeq u) : Nonempty Œ≤ :=\n  @nonempty_of_neBot _ _ <| (map_neBot_iff _).1 hu.1\n#align cauchy_seq.nonempty CauchySeq.nonempty\n-/\n\n",
 "mono'":
 "#print Cauchy.mono' /-\ntheorem Cauchy.mono' {f g : Filter Œ±} (h_c : Cauchy f) (hg : NeBot g) (h_le : g ‚â§ f) : Cauchy g :=\n  h_c.mono h_le\n#align cauchy.mono' Cauchy.mono'\n-/\n\n",
 "mono":
 "#print Cauchy.mono /-\ntheorem Cauchy.mono {f g : Filter Œ±} [hg : NeBot g] (h_c : Cauchy f) (h_le : g ‚â§ f) : Cauchy g :=\n  ‚ü®hg, le_trans (Filter.prod_mono h_le h_le) h_c.right‚ü©\n#align cauchy.mono Cauchy.mono\n-/\n\n",
 "mem_entourage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print CauchySeq.mem_entourage /-\ntheorem CauchySeq.mem_entourage {Œ≤ : Type _} [SemilatticeSup Œ≤] {u : Œ≤ ‚Üí Œ±} (h : CauchySeq u) {V : Set (Œ± √ó Œ±)}\n    (hV : V ‚àà (uniformity) Œ±) : ‚àÉ k‚ÇÄ, ‚àÄ i j, k‚ÇÄ ‚â§ i ‚Üí k‚ÇÄ ‚â§ j ‚Üí (u i, u j) ‚àà V :=\n  by\n  haveI := h.nonempty\n  have := h.tendsto_uniformity; rw [‚Üê prod_at_top_at_top_eq] at this\n  simpa [maps_to] using at_top_basis.prod_self.tendsto_left_iff.1 this V hV\n#align cauchy_seq.mem_entourage CauchySeq.mem_entourage\n-/\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n#print Cauchy.map /-\ntheorem Cauchy.map [UniformSpace Œ≤] {f : Filter Œ±} {m : Œ± ‚Üí Œ≤} (hf : Cauchy f) (hm : UniformContinuous m) :\n    Cauchy (map m f) :=\n  ‚ü®hf.1.map _,\n    calc\n      filter.prod (map m f) (map m f) = map (fun p : Œ± √ó Œ± => (m p.1, m p.2)) (filter.prod f f) :=\n        Filter.prod_map_map_eq\n      _ ‚â§ map (fun p : Œ± √ó Œ± => (m p.1, m p.2)) ((uniformity) Œ±) := (map_mono hf.right)\n      _ ‚â§ (uniformity) Œ≤ := hm\n      ‚ü©\n#align cauchy.map Cauchy.map\n-/\n\n",
 "le_nhds_of_seq_tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If the sequence `sequentially_complete.seq` converges to `a`, then `f ‚â§ ùìù a`. -/\ntheorem le_nhds_of_seq_tendsto_nhds ‚¶Éa : Œ±‚¶Ñ (ha : Tendsto (seq hf U_mem) atTop ((nhds) a)) : f ‚â§ (nhds) a :=\n  le_nhds_of_cauchy_adhp_aux\n    (by\n      intro s hs\n      rcases U_le s hs with ‚ü®m, hm‚ü©\n      rcases tendsto_at_top'.1 ha _ (mem_nhds_left a (U_mem m)) with ‚ü®n, hn‚ü©\n      refine' ‚ü®set_seq hf U_mem (max m n), set_seq_mem hf U_mem _, _, seq hf U_mem (max m n), _, seq_mem hf U_mem _‚ü©\n      ¬∑ have := le_max_left m n\n        exact Set.Subset.trans (set_seq_prod_subset hf U_mem this this) hm\n      ¬∑ exact hm (hn _ <| le_max_right m n))\n#align le_nhds_of_seq_tendsto_nhds le_nhds_of_seq_tendsto_nhds\n\n",
 "le_nhds_of_cauchy_adhp_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print le_nhds_of_cauchy_adhp_aux /-\n/-- The common part of the proofs of `le_nhds_of_cauchy_adhp` and\n`sequentially_complete.le_nhds_of_seq_tendsto_nhds`: if for any entourage `s`\none can choose a set `t ‚àà f` of diameter `s` such that it contains a point `y`\nwith `(x, y) ‚àà s`, then `f` converges to `x`. -/\ntheorem le_nhds_of_cauchy_adhp_aux {f : Filter Œ±} {x : Œ±}\n    (adhs : ‚àÄ s ‚àà (uniformity) Œ±, ‚àÉ t ‚àà f, lower_set.prod t t ‚äÜ s ‚àß ‚àÉ y, (x, y) ‚àà s ‚àß y ‚àà t) : f ‚â§ (nhds) x :=\n  by\n  -- Consider a neighborhood `s` of `x`\n  intro s hs\n  -- Take an entourage twice smaller than `s`\n  rcases comp_mem_uniformity_sets (mem_nhds_uniformity_iff_right.1 hs) with ‚ü®U, U_mem, hU‚ü©\n  -- Take a set `t ‚àà f`, `t √ó t ‚äÜ U`, and a point `y ‚àà t` such that `(x, y) ‚àà U`\n  rcases adhs U U_mem with ‚ü®t, t_mem, ht, y, hxy, hy‚ü©\n  apply mem_of_superset t_mem\n  -- Given a point `z ‚àà t`, we have `(x, y) ‚àà U` and `(y, z) ‚àà t √ó t ‚äÜ U`, hence `z ‚àà s`\n  exact fun z hz => hU (prod_mk_mem_compRel hxy (ht <| mk_mem_prod hy hz)) rfl\n#align le_nhds_of_cauchy_adhp_aux le_nhds_of_cauchy_adhp_aux\n-/\n\n",
 "le_nhds_of_cauchy_adhp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print le_nhds_of_cauchy_adhp /-\n/-- If `x` is an adherent (cluster) point for a Cauchy filter `f`, then it is a limit point\nfor `f`. -/\ntheorem le_nhds_of_cauchy_adhp {f : Filter Œ±} {x : Œ±} (hf : Cauchy f) (adhs : ClusterPt x f) : f ‚â§ (nhds) x :=\n  le_nhds_of_cauchy_adhp_aux\n    (by\n      intro s hs\n      obtain ‚ü®t, t_mem, ht‚ü© : ‚àÉ t ‚àà f, lower_set.prod t t ‚äÜ s\n      exact (cauchy_iff.1 hf).2 s hs\n      use t, t_mem, ht\n      exact forall_mem_nonempty_iff_ne_bot.2 adhs _ (inter_mem_inf (mem_nhds_left x hs) t_mem))\n#align le_nhds_of_cauchy_adhp le_nhds_of_cauchy_adhp\n-/\n\n",
 "le_nhds_lim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Cauchy.le_nhds_lim /-\ntheorem Cauchy.le_nhds_lim [CompleteSpace Œ±] [Nonempty Œ±] {f : Filter Œ±} (hf : Cauchy f) : f ‚â§ (nhds) (lim f) :=\n  le_nhds_lim (complete_space.complete hf)\n#align cauchy.le_nhds_Lim Cauchy.le_nhds_lim\n-/\n\n",
 "le_nhds_iff_adhp_of_cauchy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print le_nhds_iff_adhp_of_cauchy /-\ntheorem le_nhds_iff_adhp_of_cauchy {f : Filter Œ±} {x : Œ±} (hf : Cauchy f) : f ‚â§ (nhds) x ‚Üî ClusterPt x f :=\n  ‚ü®fun h => ClusterPt.of_le_nhds' h hf.1, le_nhds_of_cauchy_adhp hf‚ü©\n#align le_nhds_iff_adhp_of_cauchy le_nhds_iff_adhp_of_cauchy\n-/\n\n",
 "isComplete_union·µ¢_separated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t ¬´expr ‚äÜ ¬ª S) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n#print isComplete_union·µ¢_separated /-\ntheorem isComplete_union·µ¢_separated {Œπ : Sort _} {s : Œπ ‚Üí Set Œ±} (hs : ‚àÄ i, IsComplete (s i)) {U : Set (Œ± √ó Œ±)}\n    (hU : U ‚àà (uniformity) Œ±) (hd : ‚àÄ (i j : Œπ), ‚àÄ x ‚àà s i, ‚àÄ y ‚àà s j, (x, y) ‚àà U ‚Üí i = j) :\n    IsComplete\n      (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (s i)) :=\n  by\n  set S := ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (s i)\n  intro l hl hls\n  rw [le_principal_iff] at hls\n  cases' cauchy_iff.1 hl with hl_ne hl'\n  obtain ‚ü®t, htS, htl, htU‚ü© : ‚àÉ (t : _)(_ : t ‚äÜ S), t ‚àà l ‚àß lower_set.prod t t ‚äÜ U :=\n    by\n    rcases hl' U hU with ‚ü®t, htl, htU‚ü©\n    exact\n      ‚ü®t ‚à© S, inter_subset_right _ _, inter_mem htl hls,\n        (Set.prod_mono (inter_subset_left _ _) (inter_subset_left _ _)).trans htU‚ü©\n  obtain ‚ü®i, hi‚ü© : ‚àÉ i, t ‚äÜ s i := by\n    rcases Filter.nonempty_of_mem htl with ‚ü®x, hx‚ü©\n    rcases mem_Union.1 (htS hx) with ‚ü®i, hi‚ü©\n    refine' ‚ü®i, fun y hy => _‚ü©\n    rcases mem_Union.1 (htS hy) with ‚ü®j, hj‚ü©\n    convert hj\n    exact hd i j x hi y hj (htU <| mk_mem_prod hx hy)\n  rcases hs i l hl (le_principal_iff.2 <| mem_of_superset htl hi) with ‚ü®x, hxs, hlx‚ü©\n  exact ‚ü®x, mem_Union.2 ‚ü®i, hxs‚ü©, hlx‚ü©\n#align is_complete_Union_separated isComplete_union·µ¢_separated\n-/\n\n",
 "isComplete_iff_ultrafilter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isComplete_iff_ultrafilter' /-\ntheorem isComplete_iff_ultrafilter' {s : Set Œ±} :\n    IsComplete s ‚Üî ‚àÄ l : Ultrafilter Œ±, Cauchy (l : Filter Œ±) ‚Üí s ‚àà l ‚Üí ‚àÉ x ‚àà s, ‚Üël ‚â§ (nhds) x :=\n  isComplete_iff_ultrafilter.trans <| by simp only [le_principal_iff, Ultrafilter.mem_coe]\n#align is_complete_iff_ultrafilter' isComplete_iff_ultrafilter'\n-/\n\n",
 "isComplete_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isComplete_iff_ultrafilter /-\ntheorem isComplete_iff_ultrafilter {s : Set Œ±} :\n    IsComplete s ‚Üî ‚àÄ l : Ultrafilter Œ±, Cauchy (l : Filter Œ±) ‚Üí ‚Üël ‚â§ (filter.principal) s ‚Üí ‚àÉ x ‚àà s, ‚Üël ‚â§ (nhds) x :=\n  by\n  refine' ‚ü®fun h l => h l, fun H => isComplete_iff_clusterPt.2 fun l hl hls => _‚ü©\n  haveI := hl.1\n  rcases H (Ultrafilter.of l) hl.ultrafilter_of ((Ultrafilter.of_le l).trans hls) with ‚ü®x, hxs, hxl‚ü©\n  exact ‚ü®x, hxs, (ClusterPt.of_le_nhds hxl).mono (Ultrafilter.of_le l)‚ü©\n#align is_complete_iff_ultrafilter isComplete_iff_ultrafilter\n-/\n\n",
 "isComplete_iff_clusterPt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print isComplete_iff_clusterPt /-\ntheorem isComplete_iff_clusterPt {s : Set Œ±} :\n    IsComplete s ‚Üî ‚àÄ l, Cauchy l ‚Üí l ‚â§ (filter.principal) s ‚Üí ‚àÉ x ‚àà s, ClusterPt x l :=\n  forall‚ÇÉ_congr fun l hl hls => exists‚ÇÇ_congr fun x hx => le_nhds_iff_adhp_of_cauchy hl\n#align is_complete_iff_cluster_pt isComplete_iff_clusterPt\n-/\n\n",
 "isComplete":
 "#print IsCompact.isComplete /-\nprotected theorem IsCompact.isComplete {s : Set Œ±} (h : IsCompact s) : IsComplete s :=\n  (isCompact_iff_totallyBounded_isComplete.1 h).2\n#align is_compact.is_complete IsCompact.isComplete\n-/\n\n",
 "isCompact_of_totallyBounded_isClosed":
 "#print isCompact_of_totallyBounded_isClosed /-\n-- see Note [lower instance priority]\ntheorem isCompact_of_totallyBounded_isClosed [CompleteSpace Œ±] {s : Set Œ±} (ht : TotallyBounded s) (hc : IsClosed s) :\n    IsCompact s :=\n  (@isCompact_iff_totallyBounded_isComplete Œ± _ s).2 ‚ü®ht, hc.is_complete‚ü©\n#align is_compact_of_totally_bounded_is_closed isCompact_of_totallyBounded_isClosed\n-/\n\n",
 "isCompact_iff_totallyBounded_isComplete":
 "#print isCompact_iff_totallyBounded_isComplete /-\ntheorem isCompact_iff_totallyBounded_isComplete {s : Set Œ±} : IsCompact s ‚Üî TotallyBounded s ‚àß IsComplete s :=\n  ‚ü®fun hs =>\n    ‚ü®totallyBounded_iff_ultrafilter.2 fun f hf =>\n        let ‚ü®x, xs, fx‚ü© := isCompact_iff_ultrafilter_le_nhds.1 hs f hf\n        cauchy_nhds.mono fx,\n      fun f fc fs =>\n      let ‚ü®a, as, fa‚ü© := @hs f fc.1 fs\n      ‚ü®a, as, le_nhds_of_cauchy_adhp fc fa‚ü©‚ü©,\n    fun ‚ü®ht, hc‚ü© => isCompact_iff_ultrafilter_le_nhds.2 fun f hf => hc _ (totallyBounded_iff_ultrafilter.1 ht f hf) hf‚ü©\n#align is_compact_iff_totally_bounded_is_complete isCompact_iff_totallyBounded_isComplete\n-/\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n#print TotallyBounded.image /-\n/-- The image of a totally bounded set under a uniformly continuous map is totally bounded. -/\ntheorem TotallyBounded.image [UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (hs : TotallyBounded s)\n    (hf : UniformContinuous f) : TotallyBounded (¬´expr '' ¬ª f s) := fun t ht =>\n  have : { p : Œ± √ó Œ± | (f p.1, f p.2) ‚àà t } ‚àà (uniformity) Œ± := hf ht\n  let ‚ü®c, hfc, hct‚ü© := hs _ this\n  ‚ü®¬´expr '' ¬ª f c, hfc.image f, by\n    simp [image_subset_iff]\n    simp [subset_def] at hct\n    intro x hx; simp\n    exact hct x hx‚ü©\n#align totally_bounded.image TotallyBounded.image\n-/\n\n",
 "exists_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚Ü• ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t ¬´expr ‚äÜ ¬ª s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n#print TotallyBounded.exists_subset /-\ntheorem TotallyBounded.exists_subset {s : Set Œ±} (hs : TotallyBounded s) {U : Set (Œ± √ó Œ±)} (hU : U ‚àà (uniformity) Œ±) :\n    ‚àÉ (t : _)(_ : t ‚äÜ s),\n      Set.Finite t ‚àß\n        s ‚äÜ\n          ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\"\n            { x | (x, y) ‚àà U } :=\n  by\n  rcases comp_symm_of_uniformity hU with ‚ü®r, hr, rs, rU‚ü©\n  rcases hs r hr with ‚ü®k, fk, ks‚ü©\n  let u := k ‚à© { y | ‚àÉ x ‚àà s, (x, y) ‚àà r }\n  choose hk f hfs hfr using fun x : u => x.coe_prop\n  refine' ‚ü®range f, _, _, _‚ü©\n  ¬∑ exact range_subset_iff.2 hfs\n  ¬∑ haveI : Fintype u := (fk.inter_of_left _).fintype\n    exact finite_range f\n  ¬∑ intro x xs\n    obtain ‚ü®y, hy, xy‚ü© : ‚àÉ y ‚àà k, (x, y) ‚àà r\n    exact mem_Union‚ÇÇ.1 (ks xs)\n    rw [bUnion_range, mem_Union]\n    set z : ¬´expr‚Ü• ¬ª u := ‚ü®y, hy, ‚ü®x, xs, xy‚ü©‚ü©\n    exact ‚ü®z, rU <| mem_compRel.2 ‚ü®y, xy, rs (hfr z)‚ü©‚ü©\n#align totally_bounded.exists_subset TotallyBounded.exists_subset\n-/\n\n",
 "eventually_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n#print CauchySeq.eventually_eventually /-\ntheorem CauchySeq.eventually_eventually [SemilatticeSup Œ≤] {u : Œ≤ ‚Üí Œ±} (hu : CauchySeq u) {V : Set (Œ± √ó Œ±)}\n    (hV : V ‚àà (uniformity) Œ±) :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" atTop\n      (¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" atTop\n        ((u k, u l) ‚àà V)) :=\n  eventually_atTop_curry <| hu.tendsto_uniformity hV\n#align cauchy_seq.eventually_eventually CauchySeq.eventually_eventually\n-/\n\n",
 "complete_univ":
 "#print complete_univ /-\ntheorem complete_univ {Œ± : Type u} [UniformSpace Œ±] [CompleteSpace Œ±] : IsComplete (univ : Set Œ±) :=\n  by\n  intro f hf _\n  rcases complete_space.complete hf with ‚ü®x, hx‚ü©\n  exact ‚ü®x, mem_univ x, hx‚ü©\n#align complete_univ complete_univ\n-/\n\n",
 "complete_of_convergent_controlled_sequences":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A uniform space is complete provided that (a) its uniformity filter has a countable basis;\n(b) any sequence satisfying a \"controlled\" version of the Cauchy condition converges. -/\ntheorem complete_of_convergent_controlled_sequences (U : ‚Ñï ‚Üí Set (Œ± √ó Œ±)) (U_mem : ‚àÄ n, U n ‚àà (uniformity) Œ±)\n    (HU : ‚àÄ u : ‚Ñï ‚Üí Œ±, (‚àÄ N m n, N ‚â§ m ‚Üí N ‚â§ n ‚Üí (u m, u n) ‚àà U N) ‚Üí ‚àÉ a, Tendsto u atTop ((nhds) a)) :\n    CompleteSpace Œ± := by\n  obtain ‚ü®U', U'_mono, hU'‚ü© := ((uniformity) Œ±).exists_antitone_seq\n  have Hmem : ‚àÄ n, U n ‚à© U' n ‚àà (uniformity) Œ± := fun n => inter_mem (U_mem n) (hU'.2 ‚ü®n, subset.refl _‚ü©)\n  refine' ‚ü®fun f hf => (HU (seq hf Hmem) fun N m n hm hn => _).imp <| le_nhds_of_seq_tendsto_nhds _ _ fun s hs => _‚ü©\n  ¬∑ rcases hU'.1 hs with ‚ü®N, hN‚ü©\n    exact ‚ü®N, subset.trans (inter_subset_right _ _) hN‚ü©\n  ¬∑ exact inter_subset_left _ _ (seq_pair_mem hf Hmem hm hn)\n#align complete_of_convergent_controlled_sequences complete_of_convergent_controlled_sequences\n\n",
 "complete_of_cauchy_seq_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A sequentially complete uniform space with a countable basis of the uniformity filter is\ncomplete. -/\ntheorem complete_of_cauchy_seq_tendsto (H' : ‚àÄ u : ‚Ñï ‚Üí Œ±, CauchySeq u ‚Üí ‚àÉ a, Tendsto u atTop ((nhds) a)) :\n    CompleteSpace Œ± :=\n  let ‚ü®U', U'_mono, hU'‚ü© := ((uniformity) Œ±).exists_antitone_seq\n  complete_of_convergent_controlled_sequences U' (fun n => hU'.2 ‚ü®n, Subset.refl _‚ü©) fun u hu =>\n    H' u <| cauchySeq_of_controlled U' (fun s hs => hU'.1 hs) hu\n#align complete_of_cauchy_seq_tendsto complete_of_cauchy_seq_tendsto\n\n",
 "completeSpace_of_isComplete_univ":
 "#print completeSpace_of_isComplete_univ /-\n/-- If `univ` is complete, the space is a complete space -/\ntheorem completeSpace_of_isComplete_univ (h : IsComplete (univ : Set Œ±)) : CompleteSpace Œ± :=\n  ‚ü®fun f hf =>\n    let ‚ü®x, _, hx‚ü© := h f hf ((@principal_univ Œ±).symm ‚ñ∏ le_top)\n    ‚ü®x, hx‚ü©‚ü©\n#align complete_space_of_is_complete_univ completeSpace_of_isComplete_univ\n-/\n\n",
 "completeSpace_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print completeSpace_iff_ultrafilter /-\ntheorem completeSpace_iff_ultrafilter :\n    CompleteSpace Œ± ‚Üî ‚àÄ l : Ultrafilter Œ±, Cauchy (l : Filter Œ±) ‚Üí ‚àÉ x : Œ±, ‚Üël ‚â§ (nhds) x := by\n  simp [completeSpace_iff_isComplete_univ, isComplete_iff_ultrafilter]\n#align complete_space_iff_ultrafilter completeSpace_iff_ultrafilter\n-/\n\n",
 "completeSpace_iff_isComplete_univ":
 "#print completeSpace_iff_isComplete_univ /-\ntheorem completeSpace_iff_isComplete_univ : CompleteSpace Œ± ‚Üî IsComplete (univ : Set Œ±) :=\n  ‚ü®@complete_univ Œ± _, completeSpace_of_isComplete_univ‚ü©\n#align complete_space_iff_is_complete_univ completeSpace_iff_isComplete_univ\n-/\n\n",
 "comp_tendsto":
 "#print CauchySeq.comp_tendsto /-\ntheorem CauchySeq.comp_tendsto {Œ≥} [SemilatticeSup Œ≤] [SemilatticeSup Œ≥] [Nonempty Œ≥] {f : Œ≤ ‚Üí Œ±} (hf : CauchySeq f)\n    {g : Œ≥ ‚Üí Œ≤} (hg : Tendsto g atTop atTop) : CauchySeq (f ‚àò g) :=\n  cauchySeq_iff_tendsto.2 <| hf.tendsto_uniformity.comp (hg.prod_at_top hg)\n#align cauchy_seq.comp_tendsto CauchySeq.comp_tendsto\n-/\n\n",
 "comp_injective":
 "#print CauchySeq.comp_injective /-\ntheorem CauchySeq.comp_injective [SemilatticeSup Œ≤] [NoMaxOrder Œ≤] [Nonempty Œ≤] {u : ‚Ñï ‚Üí Œ±} (hu : CauchySeq u)\n    {f : Œ≤ ‚Üí ‚Ñï} (hf : injective f) : CauchySeq (u ‚àò f) :=\n  hu.comp_tendsto <| Nat.cofinite_eq_atTop ‚ñ∏ hf.tendsto_cofinite.mono_left atTop_le_cofinite\n#align cauchy_seq.comp_injective CauchySeq.comp_injective\n-/\n\n",
 "comp_cauchySeq":
 "#print UniformContinuous.comp_cauchySeq /-\ntheorem UniformContinuous.comp_cauchySeq {Œ≥} [UniformSpace Œ≤] [SemilatticeSup Œ≥] {f : Œ± ‚Üí Œ≤} (hf : UniformContinuous f)\n    {u : Œ≥ ‚Üí Œ±} (hu : CauchySeq u) : CauchySeq (f ‚àò u) :=\n  hu.map hf\n#align uniform_continuous.comp_cauchy_seq UniformContinuous.comp_cauchySeq\n-/\n\n",
 "comap'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Cauchy.comap' /-\ntheorem Cauchy.comap' [UniformSpace Œ≤] {f : Filter Œ≤} {m : Œ± ‚Üí Œ≤} (hf : Cauchy f)\n    (hm : comap (fun p : Œ± √ó Œ± => (m p.1, m p.2)) ((uniformity) Œ≤) ‚â§ (uniformity) Œ±) (hb : NeBot (comap m f)) :\n    Cauchy (comap m f) :=\n  hf.comap hm\n#align cauchy.comap' Cauchy.comap'\n-/\n\n",
 "comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Cauchy.comap /-\ntheorem Cauchy.comap [UniformSpace Œ≤] {f : Filter Œ≤} {m : Œ± ‚Üí Œ≤} (hf : Cauchy f)\n    (hm : comap (fun p : Œ± √ó Œ± => (m p.1, m p.2)) ((uniformity) Œ≤) ‚â§ (uniformity) Œ±) [NeBot (comap m f)] :\n    Cauchy (comap m f) :=\n  ‚ü®‚Äπ_‚Ä∫,\n    calc\n      filter.prod (comap m f) (comap m f) = comap (fun p : Œ± √ó Œ± => (m p.1, m p.2)) (filter.prod f f) :=\n        Filter.prod_comap_comap_eq\n      _ ‚â§ comap (fun p : Œ± √ó Œ± => (m p.1, m p.2)) ((uniformity) Œ≤) := (comap_mono hf.right)\n      _ ‚â§ (uniformity) Œ± := hm\n      ‚ü©\n#align cauchy.comap Cauchy.comap\n-/\n\n",
 "closure":
 "#print TotallyBounded.closure /-\n/-- The closure of a totally bounded set is totally bounded. -/\ntheorem TotallyBounded.closure {s : Set Œ±} (h : TotallyBounded s) : TotallyBounded (closure s) :=\n  uniformity_hasBasis_closed.totally_bounded_iff.2 fun V hV =>\n    let ‚ü®t, htf, hst‚ü© := h V hV.1\n    ‚ü®t, htf,\n      closure_minimal hst <| isClosed_bunion·µ¢ htf fun y hy => hV.2.preimage (continuous_id.prod_mk continuous_const)‚ü©\n#align totally_bounded.closure TotallyBounded.closure\n-/\n\n",
 "cauchy_pure":
 "#print cauchy_pure /-\ntheorem cauchy_pure {a : Œ±} : Cauchy (pure a) :=\n  cauchy_nhds.mono (pure_le_nhds a)\n#align cauchy_pure cauchy_pure\n-/\n\n",
 "cauchy_of_totallyBounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print Ultrafilter.cauchy_of_totallyBounded /-\ntheorem Ultrafilter.cauchy_of_totallyBounded {s : Set Œ±} (f : Ultrafilter Œ±) (hs : TotallyBounded s)\n    (h : ‚Üëf ‚â§ (filter.principal) s) : Cauchy (f : Filter Œ±) :=\n  ‚ü®f.ne_bot', fun t ht =>\n    let ‚ü®t', ht'‚ÇÅ, ht'_symm, ht'_t‚ü© := comp_symm_of_uniformity ht\n    let ‚ü®i, hi, hs_union‚ü© := hs t' ht'‚ÇÅ\n    have :\n      ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\"\n          { x | (x, y) ‚àà t' } ‚àà\n        f :=\n      mem_of_superset (le_principal_iff.mp h) hs_union\n    have : ‚àÉ y ‚àà i, { x | (x, y) ‚àà t' } ‚àà f := (Ultrafilter.finite_bunion·µ¢_mem_iff hi).1 this\n    let ‚ü®y, hy, hif‚ü© := this\n    have : lower_set.prod { x | (x, y) ‚àà t' } { x | (x, y) ‚àà t' } ‚äÜ compRel t' t' :=\n      fun ‚ü®x‚ÇÅ, x‚ÇÇ‚ü© ‚ü®(h‚ÇÅ : (x‚ÇÅ, y) ‚àà t'), (h‚ÇÇ : (x‚ÇÇ, y) ‚àà t')‚ü© => ‚ü®y, h‚ÇÅ, ht'_symm h‚ÇÇ‚ü©\n    mem_of_superset (prod_mem_prod hif hif) (Subset.trans this ht'_t)‚ü©\n#align ultrafilter.cauchy_of_totally_bounded Ultrafilter.cauchy_of_totallyBounded\n-/\n\n",
 "cauchy_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print cauchy_nhds /-\ntheorem cauchy_nhds {a : Œ±} : Cauchy ((nhds) a) :=\n  ‚ü®nhds_neBot, nhds_prod_eq.symm.trans_le (nhds_le_uniformity a)‚ü©\n#align cauchy_nhds cauchy_nhds\n-/\n\n",
 "cauchy_map_iff_exists_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print cauchy_map_iff_exists_tendsto /-\ntheorem cauchy_map_iff_exists_tendsto [CompleteSpace Œ±] {l : Filter Œ≤} {f : Œ≤ ‚Üí Œ±} [NeBot l] :\n    Cauchy (l.map f) ‚Üî ‚àÉ x, Tendsto f l ((nhds) x) :=\n  cauchy_iff_exists_le_nhds\n#align cauchy_map_iff_exists_tendsto cauchy_map_iff_exists_tendsto\n-/\n\n",
 "cauchy_map_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print cauchy_map_iff' /-\ntheorem cauchy_map_iff' {l : Filter Œ≤} [hl : NeBot l] {f : Œ≤ ‚Üí Œ±} :\n    Cauchy (l.map f) ‚Üî Tendsto (fun p : Œ≤ √ó Œ≤ => (f p.1, f p.2)) (filter.prod l l) ((uniformity) Œ±) :=\n  cauchy_map_iff.trans <| and_iff_right hl\n#align cauchy_map_iff' cauchy_map_iff'\n-/\n\n",
 "cauchy_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print cauchy_map_iff /-\ntheorem cauchy_map_iff {l : Filter Œ≤} {f : Œ≤ ‚Üí Œ±} :\n    Cauchy (l.map f) ‚Üî NeBot l ‚àß Tendsto (fun p : Œ≤ √ó Œ≤ => (f p.1, f p.2)) (filter.prod l l) ((uniformity) Œ±) := by\n  rw [Cauchy, map_ne_bot_iff, prod_map_map_eq, tendsto]\n#align cauchy_map_iff cauchy_map_iff\n-/\n\n",
 "cauchy_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.cauchy_map /-\ntheorem Filter.Tendsto.cauchy_map {l : Filter Œ≤} [NeBot l] {f : Œ≤ ‚Üí Œ±} {a : Œ±} (h : Tendsto f l ((nhds) a)) :\n    Cauchy (map f l) :=\n  cauchy_nhds.mono h\n#align filter.tendsto.cauchy_map Filter.Tendsto.cauchy_map\n-/\n\n",
 "cauchy_iff_exists_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print cauchy_iff_exists_le_nhds /-\ntheorem cauchy_iff_exists_le_nhds [CompleteSpace Œ±] {l : Filter Œ±} [NeBot l] : Cauchy l ‚Üî ‚àÉ x, l ‚â§ (nhds) x :=\n  ‚ü®complete_space.complete, fun ‚ü®x, hx‚ü© => cauchy_nhds.mono hx‚ü©\n#align cauchy_iff_exists_le_nhds cauchy_iff_exists_le_nhds\n-/\n\n",
 "cauchy_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y ¬´expr ‚àà ¬ª t) -/\n#print cauchy_iff' /-\ntheorem cauchy_iff' {f : Filter Œ±} :\n    Cauchy f ‚Üî NeBot f ‚àß ‚àÄ s ‚àà (uniformity) Œ±, ‚àÉ t ‚àà f, ‚àÄ (x) (_ : x ‚àà t) (y) (_ : y ‚àà t), (x, y) ‚àà s :=\n  ((uniformity) Œ±).basis_sets.cauchy_iff\n#align cauchy_iff' cauchy_iff'\n-/\n\n",
 "cauchy_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print cauchy_iff /-\ntheorem cauchy_iff {f : Filter Œ±} : Cauchy f ‚Üî NeBot f ‚àß ‚àÄ s ‚àà (uniformity) Œ±, ‚àÉ t ‚àà f, lower_set.prod t t ‚äÜ s :=\n  cauchy_iff'.trans <| by simp only [subset_def, Prod.forall, mem_prod_eq, and_imp, id, ball_mem_comm]\n#align cauchy_iff cauchy_iff\n-/\n\n",
 "cauchySeq_tendsto_of_isComplete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print cauchySeq_tendsto_of_isComplete /-\n/-- If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` -/\ntheorem cauchySeq_tendsto_of_isComplete [SemilatticeSup Œ≤] {K : Set Œ±} (h‚ÇÅ : IsComplete K) {u : Œ≤ ‚Üí Œ±}\n    (h‚ÇÇ : ‚àÄ n, u n ‚àà K) (h‚ÇÉ : CauchySeq u) : ‚àÉ v ‚àà K, Tendsto u atTop ((nhds) v) :=\n  h‚ÇÅ _ h‚ÇÉ <|\n    le_principal_iff.2 <|\n      mem_map_iff_exists_image.2\n        ‚ü®univ, univ_mem, by\n          simp only [image_univ]\n          rintro _ ‚ü®n, rfl‚ü©\n          exact h‚ÇÇ n‚ü©\n#align cauchy_seq_tendsto_of_is_complete cauchySeq_tendsto_of_isComplete\n-/\n\n",
 "cauchySeq_tendsto_of_complete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print cauchySeq_tendsto_of_complete /-\n/-- A Cauchy sequence in a complete space converges -/\ntheorem cauchySeq_tendsto_of_complete [SemilatticeSup Œ≤] [CompleteSpace Œ±] {u : Œ≤ ‚Üí Œ±} (H : CauchySeq u) :\n    ‚àÉ x, Tendsto u atTop ((nhds) x) :=\n  complete_space.complete H\n#align cauchy_seq_tendsto_of_complete cauchySeq_tendsto_of_complete\n-/\n\n",
 "cauchySeq_of_controlled":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print cauchySeq_of_controlled /-\ntheorem cauchySeq_of_controlled [SemilatticeSup Œ≤] [Nonempty Œ≤] (U : Œ≤ ‚Üí Set (Œ± √ó Œ±))\n    (hU : ‚àÄ s ‚àà (uniformity) Œ±, ‚àÉ n, U n ‚äÜ s) {f : Œ≤ ‚Üí Œ±} (hf : ‚àÄ {N m n : Œ≤}, N ‚â§ m ‚Üí N ‚â§ n ‚Üí (f m, f n) ‚àà U N) :\n    CauchySeq f :=\n  cauchySeq_iff_tendsto.2\n    (by\n      intro s hs\n      rw [mem_map, mem_at_top_sets]\n      cases' hU s hs with N hN\n      refine' ‚ü®(N, N), fun mn hmn => _‚ü©\n      cases' mn with m n\n      exact hN (hf hmn.1 hmn.2))\n#align cauchy_seq_of_controlled cauchySeq_of_controlled\n-/\n\n",
 "cauchySeq_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print cauchySeq_iff_tendsto /-\ntheorem cauchySeq_iff_tendsto [Nonempty Œ≤] [SemilatticeSup Œ≤] {u : Œ≤ ‚Üí Œ±} :\n    CauchySeq u ‚Üî Tendsto (prod.map u u) atTop ((uniformity) Œ±) :=\n  cauchy_map_iff'.trans <| by simp only [prod_at_top_at_top_eq, Prod.map_def]\n#align cauchy_seq_iff_tendsto cauchySeq_iff_tendsto\n-/\n\n",
 "cauchySeq_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print Filter.HasBasis.cauchySeq_iff' /-\ntheorem Filter.HasBasis.cauchySeq_iff' {Œ≥} [Nonempty Œ≤] [SemilatticeSup Œ≤] {u : Œ≤ ‚Üí Œ±} {p : Œ≥ ‚Üí Prop}\n    {s : Œ≥ ‚Üí Set (Œ± √ó Œ±)} (H : ((uniformity) Œ±).has_basis p s) :\n    CauchySeq u ‚Üî ‚àÄ i, p i ‚Üí ‚àÉ N, ‚àÄ n ‚â• N, (u n, u N) ‚àà s i :=\n  by\n  refine' H.cauchy_seq_iff.trans ‚ü®fun h i hi => _, fun h i hi => _‚ü©\n  ¬∑ exact (h i hi).imp fun N hN n hn => hN n hn N le_rfl\n  ¬∑ rcases comp_symm_of_uniformity (H.mem_of_mem hi) with ‚ü®t, ht, ht', hts‚ü©\n    rcases H.mem_iff.1 ht with ‚ü®j, hj, hjt‚ü©\n    refine' (h j hj).imp fun N hN m hm n hn => hts ‚ü®u N, hjt _, ht' <| hjt _‚ü©\n    ¬∑ exact hN m hm\n    ¬∑ exact hN n hn\n#align filter.has_basis.cauchy_seq_iff' Filter.HasBasis.cauchySeq_iff'\n-/\n\n",
 "cauchySeq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (m n ¬´expr ‚â• ¬ª N) -/\n#print Filter.HasBasis.cauchySeq_iff /-\n-- see Note [nolint_ge]\n@[nolint ge_or_gt]\ntheorem Filter.HasBasis.cauchySeq_iff {Œ≥} [Nonempty Œ≤] [SemilatticeSup Œ≤] {u : Œ≤ ‚Üí Œ±} {p : Œ≥ ‚Üí Prop}\n    {s : Œ≥ ‚Üí Set (Œ± √ó Œ±)} (h : ((uniformity) Œ±).has_basis p s) :\n    CauchySeq u ‚Üî ‚àÄ i, p i ‚Üí ‚àÉ N, ‚àÄ (m) (_ : m ‚â• N) (n) (_ : n ‚â• N), (u m, u n) ‚àà s i :=\n  by\n  rw [cauchySeq_iff_tendsto, ‚Üê prod_at_top_at_top_eq]\n  refine' (at_top_basis.prod_self.tendsto_iff h).trans _\n  simp only [exists_prop, true_and_iff, maps_to, preimage, subset_def, Prod.forall, mem_prod_eq, mem_set_of_eq, mem_Ici,\n    and_imp, prod.map, ge_iff_le, @forall_swap (_ ‚â§ _) Œ≤]\n#align filter.has_basis.cauchy_seq_iff Filter.HasBasis.cauchySeq_iff\n-/\n\n",
 "cauchySeq_const":
 "#print cauchySeq_const /-\ntheorem cauchySeq_const [SemilatticeSup Œ≤] [Nonempty Œ≤] (x : Œ±) : CauchySeq fun n : Œ≤ => x :=\n  tendsto_const_nhds.cauchy_seq\n#align cauchy_seq_const cauchySeq_const\n-/\n\n",
 "cauchySeq_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚âÉ ¬ª -/\n#print Function.Bijective.cauchySeq_comp_iff /-\ntheorem Function.Bijective.cauchySeq_comp_iff {f : ‚Ñï ‚Üí ‚Ñï} (hf : bijective f) (u : ‚Ñï ‚Üí Œ±) :\n    CauchySeq (u ‚àò f) ‚Üî CauchySeq u :=\n  by\n  refine' ‚ü®fun H => _, fun H => H.comp_injective hf.injective‚ü©\n  lift f to ¬´expr ‚âÉ ¬ª ‚Ñï ‚Ñï using hf\n  simpa only [(¬∑ ‚àò ¬∑), f.apply_symm_apply] using H.comp_injective f.symm.injective\n#align function.bijective.cauchy_seq_comp_iff Function.Bijective.cauchySeq_comp_iff\n-/\n\n",
 "cauchySeq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.cauchySeq /-\ntheorem Filter.Tendsto.cauchySeq [SemilatticeSup Œ≤] [Nonempty Œ≤] {f : Œ≤ ‚Üí Œ±} {x} (hx : Tendsto f atTop ((nhds) x)) :\n    CauchySeq f :=\n  hx.cauchy_map\n#align filter.tendsto.cauchy_seq Filter.Tendsto.cauchySeq\n-/\n\n"}