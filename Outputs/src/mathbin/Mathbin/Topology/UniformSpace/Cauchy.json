{"union":
 "protected theorem is_complete.union {s t : set Î±} (hs : is_complete s) (ht : is_complete t) : is_complete (s âˆª t) :=\n  by\n  simp only [is_complete_iff_ultrafilter', ultrafilter.union_mem_iff, or_imp] at *\n  exact fun l hl =>\n    âŸ¨fun hsl => (hs l hl hsl).imp fun x hx => âŸ¨or.inl hx.fst, hx.sndâŸ©, fun htl =>\n      (ht l hl htl).imp fun x hx => âŸ¨or.inr hx.fst, hx.sndâŸ©âŸ©\n#align is_complete.union is_complete.union\n\n",
 "ultrafilter_of":
 "theorem cauchy.ultrafilter_of {l : filter Î±} (h : cauchy l) : cauchy (@ultrafilter.of _ l h.1 : filter Î±) :=\n  by\n  haveI := h.1\n  have := ultrafilter.of_le l\n  exact âŸ¨ultrafilter.ne_bot _, (filter.prod_mono this this).trans h.2âŸ©\n#align cauchy.ultrafilter_of cauchy.ultrafilter_of\n\n",
 "totally_bounded_subset":
 "theorem totally_bounded_subset {sâ‚ sâ‚‚ : set Î±} (hs : sâ‚ âŠ† sâ‚‚) (h : totally_bounded sâ‚‚) : totally_bounded sâ‚ :=\n  fun d hd =>\n  let âŸ¨t, htâ‚, htâ‚‚âŸ© := h d hd\n  âŸ¨t, htâ‚, Subset.trans hs htâ‚‚âŸ©\n#align totally_bounded_subset totally_bounded_subset\n\n",
 "totally_bounded_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- Every Cauchy sequence over `â„•` is totally bounded. -/\ntheorem cauchy_seq.totally_bounded_range {s : â„• â†’ Î±} (hs : cauchy_seq s) : totally_bounded (range s) :=\n  by\n  refine' totally_bounded_iff_subset.2 fun a ha => _\n  cases' cauchy_seq_iff.1 hs a ha with n hn\n  refine' âŸ¨Â«expr '' Â» s { k | k â‰¤ n }, image_subset_range _ _, (finite_le_nat _).image _, _âŸ©\n  rw [range_subset_iff, bUnion_image]\n  intro m\n  rw [mem_Unionâ‚‚]\n  cases' le_total m n with hm hm\n  exacts[âŸ¨m, hm, refl_mem_uniformity haâŸ©, âŸ¨n, le_refl n, hn m hm n le_rflâŸ©]\n#align cauchy_seq.totally_bounded_range cauchy_seq.totally_bounded_range\n\n",
 "totally_bounded_of_forall_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem totally_bounded_of_forall_symm {s : set Î±}\n    (h :\n      âˆ€ V âˆˆ (uniformity) Î±,\n        symmetric_rel V â†’\n          âˆƒ t : set Î±,\n            set.finite t âˆ§\n              s âŠ†\n                Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n                  (ball y V)) :\n    totally_bounded s :=\n  uniform_space.has_basis_symmetric.totally_bounded_iff.2 fun V hV => by\n    simpa only [ball_eq_of_symmetry hV.2] using h V hV.1 hV.2\n#align totally_bounded_of_forall_symm totally_bounded_of_forall_symm\n\n",
 "totally_bounded_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem totally_bounded_iff_ultrafilter {s : set Î±} :\n    totally_bounded s â†” âˆ€ f : ultrafilter Î±, â†‘f â‰¤ (filter.principal) s â†’ cauchy (f : filter Î±) :=\n  by\n  refine' âŸ¨fun hs f => f.cauchy_of_totally_bounded hs, fun H => totally_bounded_iff_filter.2 _âŸ©\n  intro f hf hfs\n  exact âŸ¨ultrafilter.of f, ultrafilter.of_le f, H _ ((ultrafilter.of_le f).trans hfs)âŸ©\n#align totally_bounded_iff_ultrafilter totally_bounded_iff_ultrafilter\n\n",
 "totally_bounded_iff_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem totally_bounded_iff_subset {s : set Î±} :\n    totally_bounded s â†”\n      âˆ€ d âˆˆ (uniformity) Î±,\n        âˆƒ (t : _)(_ : t âŠ† s),\n          set.finite t âˆ§\n            s âŠ†\n              Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n                { x | (x, y) âˆˆ d } :=\n  âŸ¨fun H d hd => H.exists_subset hd, fun H d hd =>\n    let âŸ¨t, _, htâŸ© := H d hd\n    âŸ¨t, htâŸ©âŸ©\n#align totally_bounded_iff_subset totally_bounded_iff_subset\n\n",
 "totally_bounded_iff_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem totally_bounded_iff_filter {s : set Î±} :\n    totally_bounded s â†” âˆ€ f, ne_bot f â†’ f â‰¤ (filter.principal) s â†’ âˆƒ c â‰¤ f, cauchy c :=\n  by\n  constructor\n  Â· intro H f hf hfs\n    exact\n      âŸ¨ultrafilter.of f, ultrafilter.of_le f,\n        (ultrafilter.of f).cauchy_of_totally_bounded H ((ultrafilter.of_le f).trans hfs)âŸ©\n  Â· intro H d hd\n    contrapose! H with hd_cover\n    set f :=\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal)\n          (s \\\n            Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n              { x | (x, y) âˆˆ d }))\n    have : ne_bot f := by\n      refine' infi_ne_bot_of_directed' (directed_of_sup _) _\n      Â· intro tâ‚ tâ‚‚ h\n        exact principal_mono.2 (diff_subset_diff_right <| bUnion_subset_bUnion_left h)\n      Â· intro t\n        simpa [nonempty_diff] using hd_cover t t.finite_to_set\n    have : f â‰¤ (filter.principal) s := infáµ¢_le_of_le âˆ… (by simp)\n    refine' âŸ¨f, â€¹_â€º, â€¹_â€º, fun c hcf hc => _âŸ©\n    rcases mem_prod_same_iff.1 (hc.2 hd) with âŸ¨m, hm, hmdâŸ©\n    have : m âˆ© s âˆˆ c := inter_mem hm (le_principal_iff.mp (hcf.trans â€¹_â€º))\n    rcases hc.1.nonempty_of_mem this with âŸ¨y, hym, hysâŸ©\n    set ys :=\n      Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n        { x | (x, y') âˆˆ d }\n    have : m âŠ† ys := by simpa [ys] using fun x hx => hmd (mk_mem_prod hx hym)\n    have : c â‰¤ (filter.principal) (s \\ ys) := hcf.trans (infáµ¢_le_of_le {y} le_rfl)\n    refine' hc.1.ne (empty_mem_iff_bot.mp _)\n    filter_upwards [le_principal_iff.1 this, hm]\n    refine' fun x hx hxm => hx.2 _\n    simpa [ys] using hmd (mk_mem_prod hxm hym)\n#align totally_bounded_iff_filter totally_bounded_iff_filter\n\n",
 "totally_bounded_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem filter.has_basis.totally_bounded_iff {Î¹} {p : Î¹ â†’ Prop} {U : Î¹ â†’ set (Î± Ã— Î±)}\n    (H : ((uniformity) Î±).has_basis p U) {s : set Î±} :\n    totally_bounded s â†”\n      âˆ€ i,\n        p i â†’\n          âˆƒ t : set Î±,\n            set.finite t âˆ§\n              s âŠ†\n                Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n                  { x | (x, y) âˆˆ U i } :=\n  H.forall_iff fun U V hUV h => h.imp fun t ht => âŸ¨ht.1, ht.2.trans <| Unionâ‚‚_mono fun x hx y hy => hUV hyâŸ©\n#align filter.has_basis.totally_bounded_iff filter.has_basis.totally_bounded_iff\n\n",
 "totally_bounded_empty":
 "theorem totally_bounded_empty : totally_bounded (âˆ… : set Î±) := fun d hd => âŸ¨âˆ…, finite_empty, empty_subset _âŸ©\n#align totally_bounded_empty totally_bounded_empty\n\n",
 "totally_bounded":
 "protected theorem is_compact.totally_bounded {s : set Î±} (h : is_compact s) : totally_bounded s :=\n  (is_compact_iff_totally_bounded_is_complete.1 h).1\n#align is_compact.totally_bounded is_compact.totally_bounded\n\n",
 "tendsto_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem cauchy_seq.tendsto_uniformity [SemilatticeSup Î²] {u : Î² â†’ Î±} (h : cauchy_seq u) :\n    tendsto (prod.map u u) at_top ((uniformity) Î±) := by\n  simpa only [tendsto, prod_map_map_eq', prod_at_top_at_top_eq] using h.right\n#align cauchy_seq.tendsto_uniformity cauchy_seq.tendsto_uniformity\n\n",
 "tendsto_nhds_of_cauchy_seq_of_subseq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem tendsto_nhds_of_cauchy_seq_of_subseq [SemilatticeSup Î²] {u : Î² â†’ Î±} (hu : cauchy_seq u) {Î¹ : Type _} {f : Î¹ â†’ Î²}\n    {p : filter Î¹} [ne_bot p] (hf : tendsto f p at_top) {a : Î±} (ha : tendsto (u âˆ˜ f) p ((nhds) a)) :\n    tendsto u at_top ((nhds) a) :=\n  le_nhds_of_cauchy_adhp hu (map_cluster_pt_of_comp hf ha)\n#align tendsto_nhds_of_cauchy_seq_of_subseq tendsto_nhds_of_cauchy_seq_of_subseq\n\n",
 "tendsto_lim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cauchy_seq.tendsto_lim [SemilatticeSup Î²] [complete_space Î±] [nonempty Î±] {u : Î² â†’ Î±} (h : cauchy_seq u) :\n    tendsto u at_top (nhds <| lim at_top u) :=\n  h.le_nhds_Lim\n#align cauchy_seq.tendsto_lim cauchy_seq.tendsto_lim\n\n",
 "subseq_subseq_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem cauchy_seq.subseq_subseq_mem {V : â„• â†’ set (Î± Ã— Î±)} (hV : âˆ€ n, V n âˆˆ (uniformity) Î±) {u : â„• â†’ Î±}\n    (hu : cauchy_seq u) {f g : â„• â†’ â„•} (hf : tendsto f at_top at_top) (hg : tendsto g at_top at_top) :\n    âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ âˆ€ n, ((u âˆ˜ f âˆ˜ Ï†) n, (u âˆ˜ g âˆ˜ Ï†) n) âˆˆ V n :=\n  by\n  rw [cauchy_seq_iff_tendsto] at hu\n  exact ((hu.comp <| hf.prod_at_top hg).comp tendsto_at_top_diagonal).subseq_mem hV\n#align cauchy_seq.subseq_subseq_mem cauchy_seq.subseq_subseq_mem\n\n",
 "subseq_mem_entourage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.subseq_mem_entourage {V : â„• â†’ set (Î± Ã— Î±)} (hV : âˆ€ n, V n âˆˆ (uniformity) Î±) {u : â„• â†’ Î±} {a : Î±}\n    (hu : tendsto u at_top ((nhds) a)) :\n    âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ (u (Ï† 0), a) âˆˆ V 0 âˆ§ âˆ€ n, (u <| Ï† (n + 1), u <| Ï† n) âˆˆ V (n + 1) :=\n  by\n  rcases mem_at_top_sets.1 (hu (ball_mem_nhds a (symm_le_uniformity <| hV 0))) with âŸ¨n, hnâŸ©\n  rcases(hu.comp (tendsto_add_at_top_nat n)).cauchy_seq.subseq_mem fun n => hV (n + 1) with âŸ¨Ï†, Ï†_mono, hÏ†VâŸ©\n  exact âŸ¨fun k => Ï† k + n, Ï†_mono.add_const _, hn _ le_add_self, hÏ†VâŸ©\n#align filter.tendsto.subseq_mem_entourage filter.tendsto.subseq_mem_entourage\n\n",
 "subseq_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem cauchy_seq.subseq_mem {V : â„• â†’ set (Î± Ã— Î±)} (hV : âˆ€ n, V n âˆˆ (uniformity) Î±) {u : â„• â†’ Î±} (hu : cauchy_seq u) :\n    âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ âˆ€ n, (u <| Ï† (n + 1), u <| Ï† n) âˆˆ V n :=\n  by\n  have : âˆ€ n, âˆƒ N, âˆ€ k â‰¥ N, âˆ€ l â‰¥ k, (u l, u k) âˆˆ V n := by\n    intro n\n    rw [cauchy_seq_iff] at hu\n    rcases hu _ (hV n) with âŸ¨N, HâŸ©\n    exact âŸ¨N, fun k hk l hl => H _ (le_trans hk hl) _ hkâŸ©\n  obtain âŸ¨Ï† : â„• â†’ â„•, Ï†_extr : strict_mono Ï†, hÏ† : âˆ€ n, âˆ€ l â‰¥ Ï† n, (u l, u <| Ï† n) âˆˆ V nâŸ© :=\n    extraction_forall_of_eventually' this\n  exact âŸ¨Ï†, Ï†_extr, fun n => hÏ† _ _ (Ï†_extr <| lt_add_one n).leâŸ©\n#align cauchy_seq.subseq_mem cauchy_seq.subseq_mem\n\n",
 "set_seq_sub_aux":
 "theorem set_seq_sub_aux (n : â„•) : set_seq hf U_mem n âŠ† set_seq_aux hf U_mem n :=\n  binteráµ¢_subset_of_mem right_mem_Iic\n#align set_seq_sub_aux set_seq_sub_aux\n\n",
 "set_seq_prod_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem set_seq_prod_subset {N m n} (hm : N â‰¤ m) (hn : N â‰¤ n) :\n    lower_set.prod (set_seq hf U_mem m) (set_seq hf U_mem n) âŠ† U N :=\n  by\n  intro p hp\n  refine' (set_seq_aux hf U_mem N).2.snd âŸ¨_, _âŸ© <;> apply set_seq_sub_aux\n  exact set_seq_mono hf U_mem hm hp.1\n  exact set_seq_mono hf U_mem hn hp.2\n#align set_seq_prod_subset set_seq_prod_subset\n\n",
 "set_seq_mono":
 "theorem set_seq_mono â¦ƒm n : â„•â¦„ (h : m â‰¤ n) : set_seq hf U_mem n âŠ† set_seq hf U_mem m :=\n  binteráµ¢_subset_binteráµ¢_left fun k hk => le_trans hk h\n#align set_seq_mono set_seq_mono\n\n",
 "set_seq_mem":
 "theorem set_seq_mem (n : â„•) : set_seq hf U_mem n âˆˆ f :=\n  (bInter_mem (finite_le_nat n)).2 fun m _ => (set_seq_aux hf U_mem m).2.fst\n#align set_seq_mem set_seq_mem\n\n",
 "seq_pair_mem":
 "theorem seq_pair_mem â¦ƒN m n : â„•â¦„ (hm : N â‰¤ m) (hn : N â‰¤ n) : (seq hf U_mem m, seq hf U_mem n) âˆˆ U N :=\n  set_seq_prod_subset hf U_mem hm hn âŸ¨seq_mem hf U_mem m, seq_mem hf U_mem nâŸ©\n#align seq_pair_mem seq_pair_mem\n\n",
 "seq_mem":
 "theorem seq_mem (n : â„•) : seq hf U_mem n âˆˆ set_seq hf U_mem n :=\n  some_spec <| hf.1.nonempty_of_mem (set_seq_mem hf U_mem n)\n#align seq_mem seq_mem\n\n",
 "seq_is_cauchy_seq":
 "theorem seq_is_cauchy_seq : cauchy_seq <| seq hf U_mem :=\n  cauchy_seq_of_controlled U U_le <| seq_pair_mem hf U_mem\n#align seq_is_cauchy_seq seq_is_cauchy_seq\n\n",
 "second_countable_of_separable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/-- A separable uniform space with countably generated uniformity filter is second countable:\none obtains a countable basis by taking the balls centered at points in a dense subset,\nand with rational \"radii\" from a countable open symmetric antitone basis of `ğ“¤ Î±`. We do not\nregister this as an instance, as there is already an instance going in the other direction\nfrom second countable spaces to separable spaces, and we want to avoid loops. -/\ntheorem second_countable_of_separable [separable_space Î±] : second_countable_topology Î± :=\n  by\n  rcases exists_countable_dense Î± with âŸ¨s, hsc, hsdâŸ©\n  obtain\n    âŸ¨t : â„• â†’ set (Î± Ã— Î±), hto : âˆ€ i : â„•, t i âˆˆ ((uniformity) Î±).sets âˆ§ is_open (t i) âˆ§ symmetric_rel (t i), h_basis :\n      ((uniformity) Î±).has_antitone_basis tâŸ© :=\n    (@uniformity_has_basis_open_symmetric Î± _).exists_antitone_subbasis\n  choose ht_mem hto hts using hto\n  refine'\n    âŸ¨âŸ¨Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n          (range fun k => ball x (t k)),\n        hsc.bUnion fun x hx => countable_range _, _âŸ©âŸ©\n  refine' (is_topological_basis_of_open_of_nhds _ _).eq_generate_from\n  Â· simp only [mem_Unionâ‚‚, mem_range]\n    rintro _ âŸ¨x, hxs, k, rflâŸ©\n    exact is_open_ball x (hto k)\n  Â· intro x V hxV hVo\n    simp only [mem_Unionâ‚‚, mem_range, exists_prop]\n    rcases uniform_space.mem_nhds_iff.1 (is_open.mem_nhds hVo hxV) with âŸ¨U, hU, hUVâŸ©\n    rcases comp_symm_of_uniformity hU with âŸ¨U', hU', hsymm, hUU'âŸ©\n    rcases h_basis.to_has_basis.mem_iff.1 hU' with âŸ¨k, -, hkâŸ©\n    rcases hsd.inter_open_nonempty (ball x <| t k) (is_open_ball x (hto k))\n        âŸ¨x, uniform_space.mem_ball_self _ (ht_mem k)âŸ© with\n      âŸ¨y, hxy, hysâŸ©\n    refine' âŸ¨_, âŸ¨y, hys, k, rflâŸ©, (hts k).subset hxy, fun z hz => _âŸ©\n    exact hUV (ball_subset_of_comp_subset (hk hxy) hUU' (hk hz))\n#align second_countable_of_separable second_countable_of_separable\n\n",
 "prod_map":
 "theorem cauchy_seq.prod_map {Î³ Î´} [uniform_space Î²] [SemilatticeSup Î³] [SemilatticeSup Î´] {u : Î³ â†’ Î±} {v : Î´ â†’ Î²}\n    (hu : cauchy_seq u) (hv : cauchy_seq v) : cauchy_seq (prod.map u v) := by\n  simpa only [cauchy_seq, prod_map_map_eq', prod_at_top_at_top_eq] using hu.prod hv\n#align cauchy_seq.prod_map cauchy_seq.prod_map\n\n",
 "prod":
 "theorem cauchy_seq.prod {Î³} [uniform_space Î²] [SemilatticeSup Î³] {u : Î³ â†’ Î±} {v : Î³ â†’ Î²} (hu : cauchy_seq u)\n    (hv : cauchy_seq v) : cauchy_seq fun x => (u x, v x) :=\n  haveI := hu.nonempty\n  (hu.prod hv).mono (tendsto.prod_mk le_rfl le_rfl)\n#align cauchy_seq.prod cauchy_seq.prod\n\n",
 "nonempty":
 "theorem cauchy_seq.nonempty [SemilatticeSup Î²] {u : Î² â†’ Î±} (hu : cauchy_seq u) : nonempty Î² :=\n  @nonempty_of_ne_bot _ _ <| (map_ne_bot_iff _).1 hu.1\n#align cauchy_seq.nonempty cauchy_seq.nonempty\n\n",
 "mono'":
 "theorem cauchy.mono' {f g : filter Î±} (h_c : cauchy f) (hg : ne_bot g) (h_le : g â‰¤ f) : cauchy g :=\n  h_c.mono h_le\n#align cauchy.mono' cauchy.mono'\n\n",
 "mono":
 "theorem cauchy.mono {f g : filter Î±} [hg : ne_bot g] (h_c : cauchy f) (h_le : g â‰¤ f) : cauchy g :=\n  âŸ¨hg, le_trans (filter.prod_mono h_le h_le) h_c.rightâŸ©\n#align cauchy.mono cauchy.mono\n\n",
 "mem_entourage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem cauchy_seq.mem_entourage {Î² : Type _} [SemilatticeSup Î²] {u : Î² â†’ Î±} (h : cauchy_seq u) {V : set (Î± Ã— Î±)}\n    (hV : V âˆˆ (uniformity) Î±) : âˆƒ kâ‚€, âˆ€ i j, kâ‚€ â‰¤ i â†’ kâ‚€ â‰¤ j â†’ (u i, u j) âˆˆ V :=\n  by\n  haveI := h.nonempty\n  have := h.tendsto_uniformity; rw [â† prod_at_top_at_top_eq] at this\n  simpa [maps_to] using at_top_basis.prod_self.tendsto_left_iff.1 this V hV\n#align cauchy_seq.mem_entourage cauchy_seq.mem_entourage\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem cauchy.map [uniform_space Î²] {f : filter Î±} {m : Î± â†’ Î²} (hf : cauchy f) (hm : uniform_continuous m) :\n    cauchy (map m f) :=\n  âŸ¨hf.1.map _,\n    calc\n      filter.prod (map m f) (map m f) = map (fun p : Î± Ã— Î± => (m p.1, m p.2)) (filter.prod f f) :=\n        filter.prod_map_map_eq\n      _ â‰¤ map (fun p : Î± Ã— Î± => (m p.1, m p.2)) ((uniformity) Î±) := map_mono hf.right\n      _ â‰¤ (uniformity) Î² := hm\n      âŸ©\n#align cauchy.map cauchy.map\n\n",
 "le_nhds_of_seq_tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If the sequence `sequentially_complete.seq` converges to `a`, then `f â‰¤ ğ“ a`. -/\ntheorem le_nhds_of_seq_tendsto_nhds â¦ƒa : Î±â¦„ (ha : tendsto (seq hf U_mem) at_top ((nhds) a)) : f â‰¤ (nhds) a :=\n  le_nhds_of_cauchy_adhp_aux\n    (by\n      intro s hs\n      rcases U_le s hs with âŸ¨m, hmâŸ©\n      rcases tendsto_at_top'.1 ha _ (mem_nhds_left a (U_mem m)) with âŸ¨n, hnâŸ©\n      refine' âŸ¨set_seq hf U_mem (max m n), set_seq_mem hf U_mem _, _, seq hf U_mem (max m n), _, seq_mem hf U_mem _âŸ©\n      Â· have := le_max_left m n\n        exact Set.Subset.trans (set_seq_prod_subset hf U_mem this this) hm\n      Â· exact hm (hn _ <| le_max_right m n))\n#align le_nhds_of_seq_tendsto_nhds le_nhds_of_seq_tendsto_nhds\n\n",
 "le_nhds_of_cauchy_adhp_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The common part of the proofs of `le_nhds_of_cauchy_adhp` and\n`sequentially_complete.le_nhds_of_seq_tendsto_nhds`: if for any entourage `s`\none can choose a set `t âˆˆ f` of diameter `s` such that it contains a point `y`\nwith `(x, y) âˆˆ s`, then `f` converges to `x`. -/\ntheorem le_nhds_of_cauchy_adhp_aux {f : filter Î±} {x : Î±}\n    (adhs : âˆ€ s âˆˆ (uniformity) Î±, âˆƒ t âˆˆ f, lower_set.prod t t âŠ† s âˆ§ âˆƒ y, (x, y) âˆˆ s âˆ§ y âˆˆ t) : f â‰¤ (nhds) x :=\n  by\n  -- Consider a neighborhood `s` of `x`\n  intro s hs\n  -- Take an entourage twice smaller than `s`\n  rcases comp_mem_uniformity_sets (mem_nhds_uniformity_iff_right.1 hs) with âŸ¨U, U_mem, hUâŸ©\n  -- Take a set `t âˆˆ f`, `t Ã— t âŠ† U`, and a point `y âˆˆ t` such that `(x, y) âˆˆ U`\n  rcases adhs U U_mem with âŸ¨t, t_mem, ht, y, hxy, hyâŸ©\n  apply mem_of_superset t_mem\n  -- Given a point `z âˆˆ t`, we have `(x, y) âˆˆ U` and `(y, z) âˆˆ t Ã— t âŠ† U`, hence `z âˆˆ s`\n  exact fun z hz => hU (prod_mk_mem_comp_rel hxy (ht <| mk_mem_prod hy hz)) rfl\n#align le_nhds_of_cauchy_adhp_aux le_nhds_of_cauchy_adhp_aux\n\n",
 "le_nhds_of_cauchy_adhp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `x` is an adherent (cluster) point for a Cauchy filter `f`, then it is a limit point\nfor `f`. -/\ntheorem le_nhds_of_cauchy_adhp {f : filter Î±} {x : Î±} (hf : cauchy f) (adhs : cluster_pt x f) : f â‰¤ (nhds) x :=\n  le_nhds_of_cauchy_adhp_aux\n    (by\n      intro s hs\n      obtain âŸ¨t, t_mem, htâŸ© : âˆƒ t âˆˆ f, lower_set.prod t t âŠ† s\n      exact (cauchy_iff.1 hf).2 s hs\n      use t, t_mem, ht\n      exact forall_mem_nonempty_iff_ne_bot.2 adhs _ (inter_mem_inf (mem_nhds_left x hs) t_mem))\n#align le_nhds_of_cauchy_adhp le_nhds_of_cauchy_adhp\n\n",
 "le_nhds_iff_adhp_of_cauchy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem le_nhds_iff_adhp_of_cauchy {f : filter Î±} {x : Î±} (hf : cauchy f) : f â‰¤ (nhds) x â†” cluster_pt x f :=\n  âŸ¨fun h => cluster_pt.of_le_nhds' h hf.1, le_nhds_of_cauchy_adhp hfâŸ©\n#align le_nhds_iff_adhp_of_cauchy le_nhds_iff_adhp_of_cauchy\n\n",
 "le_nhds_Lim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cauchy.le_nhds_Lim [complete_space Î±] [nonempty Î±] {f : filter Î±} (hf : cauchy f) : f â‰¤ (nhds) (Lim f) :=\n  le_nhds_Lim (complete_space.complete hf)\n#align cauchy.le_nhds_Lim cauchy.le_nhds_Lim\n\n",
 "is_complete_iff_ultrafilter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_complete_iff_ultrafilter' {s : set Î±} :\n    is_complete s â†” âˆ€ l : ultrafilter Î±, cauchy (l : filter Î±) â†’ s âˆˆ l â†’ âˆƒ x âˆˆ s, â†‘l â‰¤ (nhds) x :=\n  is_complete_iff_ultrafilter.trans <| by simp only [le_principal_iff, ultrafilter.mem_coe]\n#align is_complete_iff_ultrafilter' is_complete_iff_ultrafilter'\n\n",
 "is_complete_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_complete_iff_ultrafilter {s : set Î±} :\n    is_complete s â†” âˆ€ l : ultrafilter Î±, cauchy (l : filter Î±) â†’ â†‘l â‰¤ (filter.principal) s â†’ âˆƒ x âˆˆ s, â†‘l â‰¤ (nhds) x :=\n  by\n  refine' âŸ¨fun h l => h l, fun H => is_complete_iff_cluster_pt.2 fun l hl hls => _âŸ©\n  haveI := hl.1\n  rcases H (ultrafilter.of l) hl.ultrafilter_of ((ultrafilter.of_le l).trans hls) with âŸ¨x, hxs, hxlâŸ©\n  exact âŸ¨x, hxs, (cluster_pt.of_le_nhds hxl).mono (ultrafilter.of_le l)âŸ©\n#align is_complete_iff_ultrafilter is_complete_iff_ultrafilter\n\n",
 "is_complete_iff_cluster_pt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_complete_iff_cluster_pt {s : set Î±} :\n    is_complete s â†” âˆ€ l, cauchy l â†’ l â‰¤ (filter.principal) s â†’ âˆƒ x âˆˆ s, cluster_pt x l :=\n  forallâ‚ƒ_congr fun l hl hls => existsâ‚‚_congr fun x hx => le_nhds_iff_adhp_of_cauchy hl\n#align is_complete_iff_cluster_pt is_complete_iff_cluster_pt\n\n",
 "is_complete_Union_separated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t Â«expr âŠ† Â» S) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem is_complete_Union_separated {Î¹ : Sort _} {s : Î¹ â†’ set Î±} (hs : âˆ€ i, is_complete (s i)) {U : set (Î± Ã— Î±)}\n    (hU : U âˆˆ (uniformity) Î±) (hd : âˆ€ (i j : Î¹), âˆ€ x âˆˆ s i, âˆ€ y âˆˆ s j, (x, y) âˆˆ U â†’ i = j) :\n    is_complete\n      (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (s i)) :=\n  by\n  set S := Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (s i)\n  intro l hl hls\n  rw [le_principal_iff] at hls\n  cases' cauchy_iff.1 hl with hl_ne hl'\n  obtain âŸ¨t, htS, htl, htUâŸ© : âˆƒ (t : _)(_ : t âŠ† S), t âˆˆ l âˆ§ lower_set.prod t t âŠ† U :=\n    by\n    rcases hl' U hU with âŸ¨t, htl, htUâŸ©\n    exact\n      âŸ¨t âˆ© S, inter_subset_right _ _, inter_mem htl hls,\n        (Set.prod_mono (inter_subset_left _ _) (inter_subset_left _ _)).trans htUâŸ©\n  obtain âŸ¨i, hiâŸ© : âˆƒ i, t âŠ† s i := by\n    rcases filter.nonempty_of_mem htl with âŸ¨x, hxâŸ©\n    rcases mem_Union.1 (htS hx) with âŸ¨i, hiâŸ©\n    refine' âŸ¨i, fun y hy => _âŸ©\n    rcases mem_Union.1 (htS hy) with âŸ¨j, hjâŸ©\n    convert hj\n    exact hd i j x hi y hj (htU <| mk_mem_prod hx hy)\n  rcases hs i l hl (le_principal_iff.2 <| mem_of_superset htl hi) with âŸ¨x, hxs, hlxâŸ©\n  exact âŸ¨x, mem_Union.2 âŸ¨i, hxsâŸ©, hlxâŸ©\n#align is_complete_Union_separated is_complete_Union_separated\n\n",
 "is_complete":
 "protected theorem is_compact.is_complete {s : set Î±} (h : is_compact s) : is_complete s :=\n  (is_compact_iff_totally_bounded_is_complete.1 h).2\n#align is_compact.is_complete is_compact.is_complete\n\n",
 "is_compact_of_totally_bounded_is_closed":
 "-- see Note [lower instance priority]\ntheorem is_compact_of_totally_bounded_is_closed [complete_space Î±] {s : set Î±} (ht : totally_bounded s)\n    (hc : is_closed s) : is_compact s :=\n  (@is_compact_iff_totally_bounded_is_complete Î± _ s).2 âŸ¨ht, hc.is_completeâŸ©\n#align is_compact_of_totally_bounded_is_closed is_compact_of_totally_bounded_is_closed\n\n",
 "is_compact_iff_totally_bounded_is_complete":
 "theorem is_compact_iff_totally_bounded_is_complete {s : set Î±} : is_compact s â†” totally_bounded s âˆ§ is_complete s :=\n  âŸ¨fun hs =>\n    âŸ¨totally_bounded_iff_ultrafilter.2 fun f hf =>\n        let âŸ¨x, xs, fxâŸ© := is_compact_iff_ultrafilter_le_nhds.1 hs f hf\n        cauchy_nhds.mono fx,\n      fun f fc fs =>\n      let âŸ¨a, as, faâŸ© := @hs f fc.1 fs\n      âŸ¨a, as, le_nhds_of_cauchy_adhp fc faâŸ©âŸ©,\n    fun âŸ¨ht, hcâŸ© =>\n    is_compact_iff_ultrafilter_le_nhds.2 fun f hf => hc _ (totally_bounded_iff_ultrafilter.1 ht f hf) hfâŸ©\n#align is_compact_iff_totally_bounded_is_complete is_compact_iff_totally_bounded_is_complete\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- The image of a totally bounded set under a uniformly continuous map is totally bounded. -/\ntheorem totally_bounded.image [uniform_space Î²] {f : Î± â†’ Î²} {s : set Î±} (hs : totally_bounded s)\n    (hf : uniform_continuous f) : totally_bounded (Â«expr '' Â» f s) := fun t ht =>\n  have : { p : Î± Ã— Î± | (f p.1, f p.2) âˆˆ t } âˆˆ (uniformity) Î± := hf ht\n  let âŸ¨c, hfc, hctâŸ© := hs _ this\n  âŸ¨Â«expr '' Â» f c, hfc.image f, by\n    simp [image_subset_iff]\n    simp [subset_def] at hct\n    intro x hx; simp\n    exact hct x hxâŸ©\n#align totally_bounded.image totally_bounded.image\n\n",
 "exists_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†¥ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem totally_bounded.exists_subset {s : set Î±} (hs : totally_bounded s) {U : set (Î± Ã— Î±)} (hU : U âˆˆ (uniformity) Î±) :\n    âˆƒ (t : _)(_ : t âŠ† s),\n      set.finite t âˆ§\n        s âŠ†\n          Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n            { x | (x, y) âˆˆ U } :=\n  by\n  rcases comp_symm_of_uniformity hU with âŸ¨r, hr, rs, rUâŸ©\n  rcases hs r hr with âŸ¨k, fk, ksâŸ©\n  let u := k âˆ© { y | âˆƒ x âˆˆ s, (x, y) âˆˆ r }\n  choose hk f hfs hfr using fun x : u => x.coe_prop\n  refine' âŸ¨range f, _, _, _âŸ©\n  Â· exact range_subset_iff.2 hfs\n  Â· haveI : fintype u := (fk.inter_of_left _).fintype\n    exact finite_range f\n  Â· intro x xs\n    obtain âŸ¨y, hy, xyâŸ© : âˆƒ y âˆˆ k, (x, y) âˆˆ r\n    exact mem_Unionâ‚‚.1 (ks xs)\n    rw [bUnion_range, mem_Union]\n    set z : Â«exprâ†¥ Â» u := âŸ¨y, hy, âŸ¨x, xs, xyâŸ©âŸ©\n    exact âŸ¨z, rU <| mem_comp_rel.2 âŸ¨y, xy, rs (hfr z)âŸ©âŸ©\n#align totally_bounded.exists_subset totally_bounded.exists_subset\n\n",
 "eventually_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\ntheorem cauchy_seq.eventually_eventually [SemilatticeSup Î²] {u : Î² â†’ Î±} (hu : cauchy_seq u) {V : set (Î± Ã— Î±)}\n    (hV : V âˆˆ (uniformity) Î±) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" at_top\n      (Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" at_top\n        ((u k, u l) âˆˆ V)) :=\n  eventually_at_top_curry <| hu.tendsto_uniformity hV\n#align cauchy_seq.eventually_eventually cauchy_seq.eventually_eventually\n\n",
 "complete_univ":
 "theorem complete_univ {Î± : Type u} [uniform_space Î±] [complete_space Î±] : is_complete (univ : set Î±) :=\n  by\n  intro f hf _\n  rcases complete_space.complete hf with âŸ¨x, hxâŸ©\n  exact âŸ¨x, mem_univ x, hxâŸ©\n#align complete_univ complete_univ\n\n",
 "complete_space_of_is_complete_univ":
 "/-- If `univ` is complete, the space is a complete space -/\ntheorem complete_space_of_is_complete_univ (h : is_complete (univ : set Î±)) : complete_space Î± :=\n  âŸ¨fun f hf =>\n    let âŸ¨x, _, hxâŸ© := h f hf ((@principal_univ Î±).symm â–¸ le_top)\n    âŸ¨x, hxâŸ©âŸ©\n#align complete_space_of_is_complete_univ complete_space_of_is_complete_univ\n\n",
 "complete_space_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem complete_space_iff_ultrafilter :\n    complete_space Î± â†” âˆ€ l : ultrafilter Î±, cauchy (l : filter Î±) â†’ âˆƒ x : Î±, â†‘l â‰¤ (nhds) x := by\n  simp [complete_space_iff_is_complete_univ, is_complete_iff_ultrafilter]\n#align complete_space_iff_ultrafilter complete_space_iff_ultrafilter\n\n",
 "complete_space_iff_is_complete_univ":
 "theorem complete_space_iff_is_complete_univ : complete_space Î± â†” is_complete (univ : set Î±) :=\n  âŸ¨@complete_univ Î± _, complete_space_of_is_complete_univâŸ©\n#align complete_space_iff_is_complete_univ complete_space_iff_is_complete_univ\n\n",
 "complete_of_convergent_controlled_sequences":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A uniform space is complete provided that (a) its uniformity filter has a countable basis;\n(b) any sequence satisfying a \"controlled\" version of the Cauchy condition converges. -/\ntheorem complete_of_convergent_controlled_sequences (U : â„• â†’ set (Î± Ã— Î±)) (U_mem : âˆ€ n, U n âˆˆ (uniformity) Î±)\n    (HU : âˆ€ u : â„• â†’ Î±, (âˆ€ N m n, N â‰¤ m â†’ N â‰¤ n â†’ (u m, u n) âˆˆ U N) â†’ âˆƒ a, tendsto u at_top ((nhds) a)) :\n    complete_space Î± := by\n  obtain âŸ¨U', U'_mono, hU'âŸ© := ((uniformity) Î±).exists_antitone_seq\n  have Hmem : âˆ€ n, U n âˆ© U' n âˆˆ (uniformity) Î± := fun n => inter_mem (U_mem n) (hU'.2 âŸ¨n, subset.refl _âŸ©)\n  refine' âŸ¨fun f hf => (HU (seq hf Hmem) fun N m n hm hn => _).imp <| le_nhds_of_seq_tendsto_nhds _ _ fun s hs => _âŸ©\n  Â· rcases hU'.1 hs with âŸ¨N, hNâŸ©\n    exact âŸ¨N, subset.trans (inter_subset_right _ _) hNâŸ©\n  Â· exact inter_subset_left _ _ (seq_pair_mem hf Hmem hm hn)\n#align complete_of_convergent_controlled_sequences complete_of_convergent_controlled_sequences\n\n",
 "complete_of_cauchy_seq_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A sequentially complete uniform space with a countable basis of the uniformity filter is\ncomplete. -/\ntheorem complete_of_cauchy_seq_tendsto (H' : âˆ€ u : â„• â†’ Î±, cauchy_seq u â†’ âˆƒ a, tendsto u at_top ((nhds) a)) :\n    complete_space Î± :=\n  let âŸ¨U', U'_mono, hU'âŸ© := ((uniformity) Î±).exists_antitone_seq\n  complete_of_convergent_controlled_sequences U' (fun n => hU'.2 âŸ¨n, Subset.refl _âŸ©) fun u hu =>\n    H' u <| cauchy_seq_of_controlled U' (fun s hs => hU'.1 hs) hu\n#align complete_of_cauchy_seq_tendsto complete_of_cauchy_seq_tendsto\n\n",
 "comp_tendsto":
 "theorem cauchy_seq.comp_tendsto {Î³} [SemilatticeSup Î²] [SemilatticeSup Î³] [nonempty Î³] {f : Î² â†’ Î±} (hf : cauchy_seq f)\n    {g : Î³ â†’ Î²} (hg : tendsto g at_top at_top) : cauchy_seq (f âˆ˜ g) :=\n  cauchy_seq_iff_tendsto.2 <| hf.tendsto_uniformity.comp (hg.prod_at_top hg)\n#align cauchy_seq.comp_tendsto cauchy_seq.comp_tendsto\n\n",
 "comp_injective":
 "theorem cauchy_seq.comp_injective [SemilatticeSup Î²] [NoMaxOrder Î²] [nonempty Î²] {u : â„• â†’ Î±} (hu : cauchy_seq u)\n    {f : Î² â†’ â„•} (hf : injective f) : cauchy_seq (u âˆ˜ f) :=\n  hu.comp_tendsto <| nat.cofinite_eq_at_top â–¸ hf.tendsto_cofinite.mono_left at_top_le_cofinite\n#align cauchy_seq.comp_injective cauchy_seq.comp_injective\n\n",
 "comp_cauchy_seq":
 "theorem uniform_continuous.comp_cauchy_seq {Î³} [uniform_space Î²] [SemilatticeSup Î³] {f : Î± â†’ Î²}\n    (hf : uniform_continuous f) {u : Î³ â†’ Î±} (hu : cauchy_seq u) : cauchy_seq (f âˆ˜ u) :=\n  hu.map hf\n#align uniform_continuous.comp_cauchy_seq uniform_continuous.comp_cauchy_seq\n\n",
 "comap'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem cauchy.comap' [uniform_space Î²] {f : filter Î²} {m : Î± â†’ Î²} (hf : cauchy f)\n    (hm : comap (fun p : Î± Ã— Î± => (m p.1, m p.2)) ((uniformity) Î²) â‰¤ (uniformity) Î±) (hb : ne_bot (comap m f)) :\n    cauchy (comap m f) :=\n  hf.comap hm\n#align cauchy.comap' cauchy.comap'\n\n",
 "comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem cauchy.comap [uniform_space Î²] {f : filter Î²} {m : Î± â†’ Î²} (hf : cauchy f)\n    (hm : comap (fun p : Î± Ã— Î± => (m p.1, m p.2)) ((uniformity) Î²) â‰¤ (uniformity) Î±) [ne_bot (comap m f)] :\n    cauchy (comap m f) :=\n  âŸ¨â€¹_â€º,\n    calc\n      filter.prod (comap m f) (comap m f) = comap (fun p : Î± Ã— Î± => (m p.1, m p.2)) (filter.prod f f) :=\n        filter.prod_comap_comap_eq\n      _ â‰¤ comap (fun p : Î± Ã— Î± => (m p.1, m p.2)) ((uniformity) Î²) := comap_mono hf.right\n      _ â‰¤ (uniformity) Î± := hm\n      âŸ©\n#align cauchy.comap cauchy.comap\n\n",
 "closure":
 "/-- The closure of a totally bounded set is totally bounded. -/\ntheorem totally_bounded.closure {s : set Î±} (h : totally_bounded s) : totally_bounded (closure s) :=\n  uniformity_has_basis_closed.totally_bounded_iff.2 fun V hV =>\n    let âŸ¨t, htf, hstâŸ© := h V hV.1\n    âŸ¨t, htf,\n      closure_minimal hst <| is_closed_bUnion htf fun y hy => hV.2.preimage (continuous_id.prod_mk continuous_const)âŸ©\n#align totally_bounded.closure totally_bounded.closure\n\n",
 "cauchy_seq_tendsto_of_is_complete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` -/\ntheorem cauchy_seq_tendsto_of_is_complete [SemilatticeSup Î²] {K : set Î±} (hâ‚ : is_complete K) {u : Î² â†’ Î±}\n    (hâ‚‚ : âˆ€ n, u n âˆˆ K) (hâ‚ƒ : cauchy_seq u) : âˆƒ v âˆˆ K, tendsto u at_top ((nhds) v) :=\n  hâ‚ _ hâ‚ƒ <|\n    le_principal_iff.2 <|\n      mem_map_iff_exists_image.2\n        âŸ¨univ, univ_mem, by\n          simp only [image_univ]\n          rintro _ âŸ¨n, rflâŸ©\n          exact hâ‚‚ nâŸ©\n#align cauchy_seq_tendsto_of_is_complete cauchy_seq_tendsto_of_is_complete\n\n",
 "cauchy_seq_tendsto_of_complete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A Cauchy sequence in a complete space converges -/\ntheorem cauchy_seq_tendsto_of_complete [SemilatticeSup Î²] [complete_space Î±] {u : Î² â†’ Î±} (H : cauchy_seq u) :\n    âˆƒ x, tendsto u at_top ((nhds) x) :=\n  complete_space.complete H\n#align cauchy_seq_tendsto_of_complete cauchy_seq_tendsto_of_complete\n\n",
 "cauchy_seq_of_controlled":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem cauchy_seq_of_controlled [SemilatticeSup Î²] [nonempty Î²] (U : Î² â†’ set (Î± Ã— Î±))\n    (hU : âˆ€ s âˆˆ (uniformity) Î±, âˆƒ n, U n âŠ† s) {f : Î² â†’ Î±} (hf : âˆ€ {N m n : Î²}, N â‰¤ m â†’ N â‰¤ n â†’ (f m, f n) âˆˆ U N) :\n    cauchy_seq f :=\n  cauchy_seq_iff_tendsto.2\n    (by\n      intro s hs\n      rw [mem_map, mem_at_top_sets]\n      cases' hU s hs with N hN\n      refine' âŸ¨(N, N), fun mn hmn => _âŸ©\n      cases' mn with m n\n      exact hN (hf hmn.1 hmn.2))\n#align cauchy_seq_of_controlled cauchy_seq_of_controlled\n\n",
 "cauchy_seq_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem cauchy_seq_iff_tendsto [nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} :\n    cauchy_seq u â†” tendsto (prod.map u u) at_top ((uniformity) Î±) :=\n  cauchy_map_iff'.trans <| by simp only [prod_at_top_at_top_eq, prod.map_def]\n#align cauchy_seq_iff_tendsto cauchy_seq_iff_tendsto\n\n",
 "cauchy_seq_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem filter.has_basis.cauchy_seq_iff' {Î³} [nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} {p : Î³ â†’ Prop}\n    {s : Î³ â†’ set (Î± Ã— Î±)} (H : ((uniformity) Î±).has_basis p s) :\n    cauchy_seq u â†” âˆ€ i, p i â†’ âˆƒ N, âˆ€ n â‰¥ N, (u n, u N) âˆˆ s i :=\n  by\n  refine' H.cauchy_seq_iff.trans âŸ¨fun h i hi => _, fun h i hi => _âŸ©\n  Â· exact (h i hi).imp fun N hN n hn => hN n hn N le_rfl\n  Â· rcases comp_symm_of_uniformity (H.mem_of_mem hi) with âŸ¨t, ht, ht', htsâŸ©\n    rcases H.mem_iff.1 ht with âŸ¨j, hj, hjtâŸ©\n    refine' (h j hj).imp fun N hN m hm n hn => hts âŸ¨u N, hjt _, ht' <| hjt _âŸ©\n    Â· exact hN m hm\n    Â· exact hN n hn\n#align filter.has_basis.cauchy_seq_iff' filter.has_basis.cauchy_seq_iff'\n\n",
 "cauchy_seq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (m n Â«expr â‰¥ Â» N) -/\n-- see Note [nolint_ge]\n@[nolint ge_or_gt]\ntheorem filter.has_basis.cauchy_seq_iff {Î³} [nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} {p : Î³ â†’ Prop}\n    {s : Î³ â†’ set (Î± Ã— Î±)} (h : ((uniformity) Î±).has_basis p s) :\n    cauchy_seq u â†” âˆ€ i, p i â†’ âˆƒ N, âˆ€ (m) (_ : m â‰¥ N) (n) (_ : n â‰¥ N), (u m, u n) âˆˆ s i :=\n  by\n  rw [cauchy_seq_iff_tendsto, â† prod_at_top_at_top_eq]\n  refine' (at_top_basis.prod_self.tendsto_iff h).trans _\n  simp only [exists_prop, true_and_iff, maps_to, preimage, subset_def, prod.forall, mem_prod_eq, mem_set_of_eq, mem_Ici,\n    and_imp, prod.map, ge_iff_le, @forall_swap (_ â‰¤ _) Î²]\n#align filter.has_basis.cauchy_seq_iff filter.has_basis.cauchy_seq_iff\n\n",
 "cauchy_seq_const":
 "theorem cauchy_seq_const [SemilatticeSup Î²] [nonempty Î²] (x : Î±) : cauchy_seq fun n : Î² => x :=\n  tendsto_const_nhds.cauchy_seq\n#align cauchy_seq_const cauchy_seq_const\n\n",
 "cauchy_seq_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒ Â» -/\ntheorem function.bijective.cauchy_seq_comp_iff {f : â„• â†’ â„•} (hf : bijective f) (u : â„• â†’ Î±) :\n    cauchy_seq (u âˆ˜ f) â†” cauchy_seq u :=\n  by\n  refine' âŸ¨fun H => _, fun H => H.comp_injective hf.injectiveâŸ©\n  lift f to Â«expr â‰ƒ Â» â„• â„• using hf\n  simpa only [(Â· âˆ˜ Â·), f.apply_symm_apply] using H.comp_injective f.symm.injective\n#align function.bijective.cauchy_seq_comp_iff function.bijective.cauchy_seq_comp_iff\n\n",
 "cauchy_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.cauchy_seq [SemilatticeSup Î²] [nonempty Î²] {f : Î² â†’ Î±} {x} (hx : tendsto f at_top ((nhds) x)) :\n    cauchy_seq f :=\n  hx.cauchy_map\n#align filter.tendsto.cauchy_seq filter.tendsto.cauchy_seq\n\n",
 "cauchy_pure":
 "theorem cauchy_pure {a : Î±} : cauchy (pure a) :=\n  cauchy_nhds.mono (pure_le_nhds a)\n#align cauchy_pure cauchy_pure\n\n",
 "cauchy_of_totally_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem ultrafilter.cauchy_of_totally_bounded {s : set Î±} (f : ultrafilter Î±) (hs : totally_bounded s)\n    (h : â†‘f â‰¤ (filter.principal) s) : cauchy (f : filter Î±) :=\n  âŸ¨f.ne_bot', fun t ht =>\n    let âŸ¨t', ht'â‚, ht'_symm, ht'_tâŸ© := comp_symm_of_uniformity ht\n    let âŸ¨i, hi, hs_unionâŸ© := hs t' ht'â‚\n    have :\n      Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n          { x | (x, y) âˆˆ t' } âˆˆ\n        f :=\n      mem_of_superset (le_principal_iff.mp h) hs_union\n    have : âˆƒ y âˆˆ i, { x | (x, y) âˆˆ t' } âˆˆ f := (ultrafilter.finite_bUnion_mem_iff hi).1 this\n    let âŸ¨y, hy, hifâŸ© := this\n    have : lower_set.prod { x | (x, y) âˆˆ t' } { x | (x, y) âˆˆ t' } âŠ† comp_rel t' t' :=\n      fun âŸ¨xâ‚, xâ‚‚âŸ© âŸ¨(hâ‚ : (xâ‚, y) âˆˆ t'), (hâ‚‚ : (xâ‚‚, y) âˆˆ t')âŸ© => âŸ¨y, hâ‚, ht'_symm hâ‚‚âŸ©\n    mem_of_superset (prod_mem_prod hif hif) (Subset.trans this ht'_t)âŸ©\n#align ultrafilter.cauchy_of_totally_bounded ultrafilter.cauchy_of_totally_bounded\n\n",
 "cauchy_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cauchy_nhds {a : Î±} : cauchy ((nhds) a) :=\n  âŸ¨nhds_ne_bot, nhds_prod_eq.symm.trans_le (nhds_le_uniformity a)âŸ©\n#align cauchy_nhds cauchy_nhds\n\n",
 "cauchy_map_iff_exists_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cauchy_map_iff_exists_tendsto [complete_space Î±] {l : filter Î²} {f : Î² â†’ Î±} [ne_bot l] :\n    cauchy (l.map f) â†” âˆƒ x, tendsto f l ((nhds) x) :=\n  cauchy_iff_exists_le_nhds\n#align cauchy_map_iff_exists_tendsto cauchy_map_iff_exists_tendsto\n\n",
 "cauchy_map_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem cauchy_map_iff' {l : filter Î²} [hl : ne_bot l] {f : Î² â†’ Î±} :\n    cauchy (l.map f) â†” tendsto (fun p : Î² Ã— Î² => (f p.1, f p.2)) (filter.prod l l) ((uniformity) Î±) :=\n  cauchy_map_iff.trans <| and_iff_right hl\n#align cauchy_map_iff' cauchy_map_iff'\n\n",
 "cauchy_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem cauchy_map_iff {l : filter Î²} {f : Î² â†’ Î±} :\n    cauchy (l.map f) â†” ne_bot l âˆ§ tendsto (fun p : Î² Ã— Î² => (f p.1, f p.2)) (filter.prod l l) ((uniformity) Î±) := by\n  rw [cauchy, map_ne_bot_iff, prod_map_map_eq, tendsto]\n#align cauchy_map_iff cauchy_map_iff\n\n",
 "cauchy_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.cauchy_map {l : filter Î²} [ne_bot l] {f : Î² â†’ Î±} {a : Î±} (h : tendsto f l ((nhds) a)) :\n    cauchy (map f l) :=\n  cauchy_nhds.mono h\n#align filter.tendsto.cauchy_map filter.tendsto.cauchy_map\n\n",
 "cauchy_iff_exists_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cauchy_iff_exists_le_nhds [complete_space Î±] {l : filter Î±} [ne_bot l] : cauchy l â†” âˆƒ x, l â‰¤ (nhds) x :=\n  âŸ¨complete_space.complete, fun âŸ¨x, hxâŸ© => cauchy_nhds.mono hxâŸ©\n#align cauchy_iff_exists_le_nhds cauchy_iff_exists_le_nhds\n\n",
 "cauchy_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x y Â«expr âˆˆ Â» t) -/\ntheorem cauchy_iff' {f : filter Î±} :\n    cauchy f â†” ne_bot f âˆ§ âˆ€ s âˆˆ (uniformity) Î±, âˆƒ t âˆˆ f, âˆ€ (x) (_ : x âˆˆ t) (y) (_ : y âˆˆ t), (x, y) âˆˆ s :=\n  ((uniformity) Î±).basis_sets.cauchy_iff\n#align cauchy_iff' cauchy_iff'\n\n",
 "cauchy_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem cauchy_iff {f : filter Î±} : cauchy f â†” ne_bot f âˆ§ âˆ€ s âˆˆ (uniformity) Î±, âˆƒ t âˆˆ f, lower_set.prod t t âŠ† s :=\n  cauchy_iff'.trans <| by simp only [subset_def, prod.forall, mem_prod_eq, and_imp, id, ball_mem_comm]\n#align cauchy_iff cauchy_iff\n\n"}