{"uniform_inducing_pure_cauchy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniform_inducing_pure_cauchy : UniformInducing (pure_cauchy : α → CauchyFilter α) :=\n  ⟨have : (preimage fun x : α × α => (pure_cauchy x.fst, pure_cauchy x.snd)) ∘ gen = id :=\n      funext fun s => Set.ext fun ⟨a₁, a₂⟩ => by simp [preimage, gen, pure_cauchy, prod_principal_principal]\n    calc\n      comap (fun x : α × α => (pure_cauchy x.fst, pure_cauchy x.snd)) (((uniformity) α).lift' gen) =\n          ((uniformity) α).lift' ((preimage fun x : α × α => (pure_cauchy x.fst, pure_cauchy x.snd)) ∘ gen) :=\n        comap_lift'_eq\n      _ = (uniformity) α := by simp [this]\n      ⟩\n#align uniform_inducing_pure_cauchy uniform_inducing_pure_cauchy\n\n",
 "uniform_inducing_coe":
 "theorem uniform_inducing_coe : UniformInducing (coe : α → Completion α) :=\n  ⟨comap_coe_eq_uniformity α⟩\n#align uniform_inducing_coe uniform_inducing_coe\n\n",
 "uniform_embedding_pure_cauchy":
 "theorem uniform_embedding_pure_cauchy : UniformEmbedding (pure_cauchy : α → CauchyFilter α) :=\n  { uniform_inducing_pure_cauchy with inj := fun a₁ a₂ h => pure_injective <| Subtype.ext_iff_val.1 h }\n#align uniform_embedding_pure_cauchy uniform_embedding_pure_cauchy\n\n",
 "uniform_embedding_coe":
 "theorem uniform_embedding_coe [SeparatedSpace α] : UniformEmbedding (coe : α → Completion α) :=\n  { comap_uniformity := comap_coe_eq_uniformity α\n    inj := separated_pureCauchy_injective }\n#align uniform_embedding_coe uniform_embedding_coe\n\n",
 "uniform_continuous_map₂":
 "theorem uniform_continuous_map₂ (f : α → β → γ) : UniformContinuous₂ (Completion.map₂ f) :=\n  cPkg.uniform_continuous_map₂ cPkg cPkg f\n#align uniform_continuous_map₂ uniform_continuous_map₂\n\n",
 "uniform_continuous_map":
 "theorem uniform_continuous_map : UniformContinuous (Completion.map f) :=\n  cPkg.uniform_continuous_map cPkg f\n#align uniform_continuous_map uniform_continuous_map\n\n",
 "uniform_continuous_extension₂":
 "theorem uniform_continuous_extension₂ : UniformContinuous₂ (Completion.extension₂ f) :=\n  cPkg.uniform_continuous_extension₂ cPkg f\n#align uniform_continuous_extension₂ uniform_continuous_extension₂\n\n",
 "uniform_continuous_extension":
 "theorem uniform_continuous_extension : UniformContinuous (Completion.extension f) :=\n  cPkg.uniform_continuous_extend\n#align uniform_continuous_extension uniform_continuous_extension\n\n",
 "uniform_continuous_extend":
 "theorem uniform_continuous_extend {f : α → β} : UniformContinuous (extend f) :=\n  by\n  by_cases hf : UniformContinuous f\n  · rw [extend, if_pos hf]\n    exact uniformContinuous_uniformly_extend uniform_inducing_pure_cauchy dense_range_pure_cauchy hf\n  · rw [extend, if_neg hf]\n    exact uniformContinuous_of_const fun a b => by congr\n#align uniform_continuous_extend uniform_continuous_extend\n\n",
 "uniform_continuous_completion_separation_quotient_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem uniform_continuous_completion_separation_quotient_equiv_symm :\n    UniformContinuous («expr⇑ » (completionSeparationQuotientEquiv α).symm) :=\n  uniformContinuous_map\n#align uniform_continuous_completion_separation_quotient_equiv_symm uniform_continuous_completion_separation_quotient_equiv_symm\n\n",
 "uniform_continuous_completion_separation_quotient_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- In this section we construct isomorphisms between the completion of a uniform space and the\ncompletion of its separation quotient -/\ntheorem uniform_continuous_completion_separation_quotient_equiv :\n    UniformContinuous («expr⇑ » (completionSeparationQuotientEquiv α)) :=\n  uniformContinuous_extension\n#align uniform_continuous_completion_separation_quotient_equiv uniform_continuous_completion_separation_quotient_equiv\n\n",
 "uniform_continuous_coe":
 "theorem uniform_continuous_coe : UniformContinuous (coe : α → Completion α) :=\n  cPkg.uniform_continuous_coe\n#align uniform_continuous_coe uniform_continuous_coe\n\n",
 "symm_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\nprivate theorem symm_gen : map Prod.swap (((uniformity) α).lift' gen) ≤ ((uniformity) α).lift' gen :=\n  calc\n    map Prod.swap (((uniformity) α).lift' gen) =\n        ((uniformity) α).lift' fun s : Set (α × α) => { p | s ∈ filter.prod p.2.val p.1.val } :=\n      by\n      delta gen\n      simp [map_lift'_eq, monotone_set_of, Filter.monotone_mem, Function.comp, image_swap_eq_preimage_swap,\n        -subtype.val_eq_coe]\n    _ ≤ ((uniformity) α).lift' gen :=\n      uniformity_lift_le_swap\n        (monotone_principal.comp (monotone_setOf fun p => @Filter.monotone_mem _ (filter.prod p.2.val p.1.val)))\n        (by\n          have h := fun p : CauchyFilter α × CauchyFilter α => @Filter.prod_comm _ _ p.2.val p.1.val\n          simp [Function.comp, h, -subtype.val_eq_coe, mem_map']\n          exact le_rfl)\n    \n#align symm_gen symm_gen\n\n",
 "separated_pure_cauchy_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem separated_pure_cauchy_injective {α : Type _} [UniformSpace α] [s : SeparatedSpace α] :\n    function.injective fun a : α => «expr⟦ ⟧» (pureCauchy a)\n  | a, b, h =>\n    separated_def.1 s _ _ fun s hs =>\n      let ⟨t, ht, hts⟩ := by\n        rw [← (@uniform_embedding_pure_cauchy α _).comap_uniformity, Filter.mem_comap] at hs <;> exact hs\n      have : (pureCauchy a, pureCauchy b) ∈ t := quotient.exact h t ht\n      @hts (a, b) this\n#align separated_pure_cauchy_injective separated_pure_cauchy_injective\n\n",
 "nonempty_completion_iff":
 "theorem nonempty_completion_iff : Nonempty (Completion α) ↔ Nonempty α :=\n  cPkg.dense.nonempty_iff.symm\n#align nonempty_completion_iff nonempty_completion_iff\n\n",
 "nonempty_Cauchy_iff":
 "theorem nonempty_Cauchy_iff : Nonempty (CauchyFilter α) ↔ Nonempty α :=\n  by\n  constructor <;> rintro ⟨c⟩\n  · have := eq_univ_iff_forall.1 dense_embedding_pure_cauchy.to_dense_inducing.closure_range c\n    obtain ⟨_, ⟨_, a, _⟩⟩ := mem_closure_iff.1 this _ isOpen_univ trivial\n    exact ⟨a⟩\n  · exact ⟨pure_cauchy c⟩\n#align nonempty_Cauchy_iff nonempty_Cauchy_iff\n\n",
 "monotone_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/-\nCopyright (c) 2018 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Johannes Hölzl\n-/\ntheorem monotone_gen : Monotone gen :=\n  monotone_setOf fun p => @Filter.monotone_mem _ (filter.prod p.1.val p.2.val)\n#align monotone_gen monotone_gen\n\n",
 "mem_uniformity'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem mem_uniformity' {s : Set (CauchyFilter α × CauchyFilter α)} :\n    s ∈ (uniformity) (CauchyFilter α) ↔\n      ∃ t ∈ (uniformity) α, ∀ f g : CauchyFilter α, t ∈ filter.prod f.1 g.1 → (f, g) ∈ s :=\n  mem_uniformity.trans <| bex_congr fun t h => Prod.forall\n#align mem_uniformity' mem_uniformity'\n\n",
 "mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem mem_uniformity {s : Set (CauchyFilter α × CauchyFilter α)} :\n    s ∈ (uniformity) (CauchyFilter α) ↔ ∃ t ∈ (uniformity) α, gen t ⊆ s :=\n  mem_lift'_sets monotone_gen\n#align mem_uniformity mem_uniformity\n\n",
 "map₂_coe_coe":
 "theorem map₂_coe_coe (a : α) (b : β) (f : α → β → γ) (hf : UniformContinuous₂ f) :\n    Completion.map₂ f (a : Completion α) (b : Completion β) = f a b :=\n  cPkg.map₂_coe_coe cPkg cPkg a b f hf\n#align map₂_coe_coe map₂_coe_coe\n\n",
 "map_unique":
 "theorem map_unique {f : α → β} {g : Completion α → Completion β} (hg : UniformContinuous g)\n    (h : ∀ a : α, ↑(f a) = g a) : Completion.map f = g :=\n  cPkg.map_unique cPkg hg h\n#align map_unique map_unique\n\n",
 "map_id":
 "@[simp]\ntheorem map_id : Completion.map (@id α) = id :=\n  cPkg.map_id\n#align map_id map_id\n\n",
 "map_comp":
 "theorem map_comp {g : β → γ} {f : α → β} (hg : UniformContinuous g) (hf : UniformContinuous f) :\n    Completion.map g ∘ Completion.map f = Completion.map (g ∘ f) :=\n  extension_map ((uniformContinuous_coe _).comp hg) hf\n#align map_comp map_comp\n\n",
 "map_coe":
 "@[simp]\ntheorem map_coe (hf : UniformContinuous f) (a : α) : (Completion.map f) a = f a :=\n  cPkg.map_coe cPkg hf a\n#align map_coe map_coe\n\n",
 "induction_on₃":
 "@[elab_as_elim]\ntheorem induction_on₃ {p : Completion α → Completion β → Completion γ → Prop} (a : Completion α) (b : Completion β)\n    (c : Completion γ) (hp : IsClosed { x : Completion α × Completion β × Completion γ | p x.1 x.2.1 x.2.2 })\n    (ih : ∀ (a : α) (b : β) (c : γ), p a b c) : p a b c :=\n  have : ∀ x : Completion α × Completion β × Completion γ, p x.1 x.2.1 x.2.2 :=\n    isClosed_property denseRange_coe₃ hp fun ⟨a, b, c⟩ => ih a b c\n  this (a, b, c)\n#align induction_on₃ induction_on₃\n\n",
 "induction_on₂":
 "@[elab_as_elim]\ntheorem induction_on₂ {p : Completion α → Completion β → Prop} (a : Completion α) (b : Completion β)\n    (hp : IsClosed { x : Completion α × Completion β | p x.1 x.2 }) (ih : ∀ (a : α) (b : β), p a b) : p a b :=\n  have : ∀ x : Completion α × Completion β, p x.1 x.2 := isClosed_property denseRange_coe₂ hp fun ⟨a, b⟩ => ih a b\n  this (a, b)\n#align induction_on₂ induction_on₂\n\n",
 "induction_on":
 "@[elab_as_elim]\ntheorem induction_on {p : Completion α → Prop} (a : Completion α) (hp : IsClosed { a | p a }) (ih : ∀ a : α, p a) :\n    p a :=\n  isClosed_property denseRange_coe hp ih a\n#align induction_on induction_on\n\n",
 "extension₂_coe_coe":
 "@[simp]\ntheorem extension₂_coe_coe (hf : UniformContinuous₂ f) (a : α) (b : β) : Completion.extension₂ f a b = f a b :=\n  cPkg.extension₂_coe_coe cPkg hf a b\n#align extension₂_coe_coe extension₂_coe_coe\n\n",
 "extension_unique":
 "theorem extension_unique (hf : UniformContinuous f) {g : Completion α → β} (hg : UniformContinuous g)\n    (h : ∀ a : α, f a = g (a : Completion α)) : Completion.extension f = g :=\n  cPkg.extend_unique hf hg h\n#align extension_unique extension_unique\n\n",
 "extension_map":
 "theorem extension_map [CompleteSpace γ] [SeparatedSpace γ] {f : β → γ} {g : α → β} (hf : UniformContinuous f)\n    (hg : UniformContinuous g) : Completion.extension f ∘ Completion.map g = Completion.extension (f ∘ g) :=\n  Completion.ext (continuous_extension.comp continuous_map) continuous_extension <| by\n    intro a <;> simp only [hg, hf, hf.comp hg, (· ∘ ·), map_coe, extension_coe]\n#align extension_map extension_map\n\n",
 "extension_comp_coe":
 "@[simp]\ntheorem extension_comp_coe {f : Completion α → β} (hf : UniformContinuous f) : Completion.extension (f ∘ coe) = f :=\n  cPkg.extend_comp_coe hf\n#align extension_comp_coe extension_comp_coe\n\n",
 "extension_coe":
 "@[simp]\ntheorem extension_coe [SeparatedSpace β] (hf : UniformContinuous f) (a : α) : (Completion.extension f) a = f a :=\n  cPkg.extend_coe hf a\n#align extension_coe extension_coe\n\n",
 "extend_pure_cauchy":
 "theorem extend_pure_cauchy {f : α → β} (hf : UniformContinuous f) (a : α) : extend f (pure_cauchy a) = f a :=\n  by\n  rw [extend, if_pos hf]\n  exact uniformly_extend_of_ind uniform_inducing_pure_cauchy dense_range_pure_cauchy hf _\n#align extend_pure_cauchy extend_pure_cauchy\n\n",
 "ext'":
 "theorem ext' {Y : Type _} [TopologicalSpace Y] [T2Space Y] {f g : Completion α → Y} (hf : Continuous f)\n    (hg : Continuous g) (h : ∀ a : α, f a = g a) (a : Completion α) : f a = g a :=\n  congr_fun (ext hf hg h) a\n#align ext' ext'\n\n",
 "ext":
 "theorem ext {Y : Type _} [TopologicalSpace Y] [T2Space Y] {f g : Completion α → Y} (hf : Continuous f)\n    (hg : Continuous g) (h : ∀ a : α, f a = g a) : f = g :=\n  cPkg.funext hf hg h\n#align ext ext\n\n",
 "dense_range_pure_cauchy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem dense_range_pure_cauchy : DenseRange pure_cauchy := fun f =>\n  by\n  have h_ex : ∀ s ∈ (uniformity) (CauchyFilter α), ∃ y : α, (f, pure_cauchy y) ∈ s := fun s hs =>\n    let ⟨t'', ht''₁, (ht''₂ : gen t'' ⊆ s)⟩ := (mem_lift'_sets monotone_gen).mp hs\n    let ⟨t', ht'₁, ht'₂⟩ := comp_mem_uniformity_sets ht''₁\n    have : t' ∈ filter.prod f.val f.val := f.property.right ht'₁\n    let ⟨t, ht, (h : lower_set.prod t t ⊆ t')⟩ := mem_prod_same_iff.mp this\n    let ⟨x, (hx : x ∈ t)⟩ := f.property.left.nonempty_of_mem ht\n    have : t'' ∈ filter.prod f.val (pure x) :=\n      mem_prod_iff.mpr\n        ⟨t, ht, { y : α | (x, y) ∈ t' }, h <| mk_mem_prod hx hx, fun ⟨a, b⟩ ⟨(h₁ : a ∈ t), (h₂ : (x, b) ∈ t')⟩ =>\n          ht'₂ <| prod_mk_mem_compRel (@h (a, x) ⟨h₁, hx⟩) h₂⟩\n    ⟨x, ht''₂ <| by dsimp [gen] <;> exact this⟩\n  simp only [closure_eq_cluster_pts, ClusterPt, nhds_eq_uniformity, lift'_inf_principal_eq,\n    Set.inter_comm _ (range pure_cauchy), mem_set_of_eq]\n  exact\n    (lift'_ne_bot_iff <| monotone_const.inter monotone_preimage).mpr fun s hs =>\n      let ⟨y, hy⟩ := h_ex s hs\n      have : pure_cauchy y ∈ range pure_cauchy ∩ { y : CauchyFilter α | (f, y) ∈ s } := ⟨mem_range_self y, hy⟩\n      ⟨_, this⟩\n#align dense_range_pure_cauchy dense_range_pure_cauchy\n\n",
 "dense_range_coe₃":
 "theorem dense_range_coe₃ :\n    DenseRange fun x : α × β × γ => ((x.1 : Completion α), ((x.2.1 : Completion β), (x.2.2 : Completion γ))) :=\n  denseRange_coe.prod_map denseRange_coe₂\n#align dense_range_coe₃ dense_range_coe₃\n\n",
 "dense_range_coe₂":
 "theorem dense_range_coe₂ : DenseRange fun x : α × β => ((x.1 : Completion α), (x.2 : Completion β)) :=\n  denseRange_coe.prod_map denseRange_coe\n#align dense_range_coe₂ dense_range_coe₂\n\n",
 "dense_range_coe":
 "theorem dense_range_coe : DenseRange (coe : α → Completion α) :=\n  denseRange_pureCauchy.quotient\n#align dense_range_coe dense_range_coe\n\n",
 "dense_inducing_pure_cauchy":
 "theorem dense_inducing_pure_cauchy : DenseInducing pure_cauchy :=\n  uniform_inducing_pure_cauchy.dense_inducing dense_range_pure_cauchy\n#align dense_inducing_pure_cauchy dense_inducing_pure_cauchy\n\n",
 "dense_inducing_coe":
 "theorem dense_inducing_coe : DenseInducing (coe : α → Completion α) :=\n  { (uniformInducing_coe α).inducing with dense := denseRange_coe }\n#align dense_inducing_coe dense_inducing_coe\n\n",
 "dense_embedding_pure_cauchy":
 "theorem dense_embedding_pure_cauchy : DenseEmbedding pure_cauchy :=\n  uniform_embedding_pure_cauchy.dense_embedding dense_range_pure_cauchy\n#align dense_embedding_pure_cauchy dense_embedding_pure_cauchy\n\n",
 "dense_embedding_coe":
 "theorem dense_embedding_coe [SeparatedSpace α] : DenseEmbedding (coe : α → Completion α) :=\n  { denseInducing_coe with inj := separated_pureCauchy_injective }\n#align dense_embedding_coe dense_embedding_coe\n\n",
 "continuous_map₂":
 "theorem continuous_map₂ {δ} [TopologicalSpace δ] {f : α → β → γ} {a : δ → Completion α} {b : δ → Completion β}\n    (ha : Continuous a) (hb : Continuous b) : Continuous fun d : δ => Completion.map₂ f (a d) (b d) :=\n  cPkg.continuous_map₂ cPkg cPkg ha hb\n#align continuous_map₂ continuous_map₂\n\n",
 "continuous_extension":
 "theorem continuous_extension : Continuous (Completion.extension f) :=\n  cPkg.continuous_extend\n#align continuous_extension continuous_extension\n\n",
 "continuous_coe":
 "theorem continuous_coe : Continuous (coe : α → Completion α) :=\n  cPkg.continuous_coe\n#align continuous_coe continuous_coe\n\n",
 "comp_rel_gen_gen_subset_gen_comp_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\nprivate theorem comp_rel_gen_gen_subset_gen_comp_rel {s t : Set (α × α)} :\n    compRel (gen s) (gen t) ⊆ (gen (compRel s t) : Set (CauchyFilter α × CauchyFilter α)) := fun ⟨f, g⟩ ⟨h, h₁, h₂⟩ =>\n  let ⟨t₁, (ht₁ : t₁ ∈ f), t₂, (ht₂ : t₂ ∈ h), (h₁ : lower_set.prod t₁ t₂ ⊆ s)⟩ := mem_prod_iff.mp h₁\n  let ⟨t₃, (ht₃ : t₃ ∈ h), t₄, (ht₄ : t₄ ∈ g), (h₂ : lower_set.prod t₃ t₄ ⊆ t)⟩ := mem_prod_iff.mp h₂\n  have : t₂ ∩ t₃ ∈ h.val := inter_mem ht₂ ht₃\n  let ⟨x, xt₂, xt₃⟩ := h.property.left.nonempty_of_mem this\n  (filter.prod f.val g.val).sets_of_superset (prod_mem_prod ht₁ ht₄) fun ⟨a, b⟩ ⟨(ha : a ∈ t₁), (hb : b ∈ t₄)⟩ =>\n    ⟨x, h₁ (show (a, x) ∈ lower_set.prod t₁ t₂ from ⟨ha, xt₂⟩), h₂ (show (x, b) ∈ lower_set.prod t₃ t₄ from ⟨xt₃, hb⟩)⟩\n#align comp_rel_gen_gen_subset_gen_comp_rel comp_rel_gen_gen_subset_gen_comp_rel\n\n",
 "comp_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\nprivate theorem comp_gen : ((((uniformity) α).lift' gen).lift' fun s => compRel s s) ≤ ((uniformity) α).lift' gen :=\n  calc\n    ((((uniformity) α).lift' gen).lift' fun s => compRel s s) =\n        ((uniformity) α).lift' fun s => compRel (gen s) (gen s) :=\n      by\n      rw [lift'_lift'_assoc]\n      exact monotone_gen\n      exact monotone_id.comp_rel monotone_id\n    _ ≤ ((uniformity) α).lift' fun s => gen <| compRel s s :=\n      (lift'_mono' fun s hs => comp_rel_gen_gen_subset_gen_comp_rel)\n    _ = (((uniformity) α).lift' fun s : Set (α × α) => compRel s s).lift' gen :=\n      by\n      rw [lift'_lift'_assoc]\n      exact monotone_id.comp_rel monotone_id\n      exact monotone_gen\n    _ ≤ ((uniformity) α).lift' gen := lift'_mono comp_le_uniformity le_rfl\n    \n#align comp_gen comp_gen\n\n",
 "comap_coe_eq_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem comap_coe_eq_uniformity :\n    (((uniformity) _).comap fun p : α × α => ((p.1 : Completion α), (p.2 : Completion α))) = (uniformity) α :=\n  by\n  have :\n    (fun x : α × α => ((x.1 : completion α), (x.2 : completion α))) =\n      (fun x : CauchyFilter α × CauchyFilter α => («expr⟦ ⟧» x.1, «expr⟦ ⟧» x.2)) ∘ fun x : α × α =>\n        (pure_cauchy x.1, pure_cauchy x.2) :=\n    by ext ⟨a, b⟩ <;> simp <;> rfl\n  rw [this, ← Filter.comap_comap]\n  change\n    Filter.comap _ (Filter.comap _ (uniformity <| quotient <| separation_setoid <| CauchyFilter α)) = (uniformity) α\n  rw [comap_quotient_eq_uniformity, uniform_embedding_pure_cauchy.comap_uniformity]\n#align comap_coe_eq_uniformity comap_coe_eq_uniformity\n\n",
 "coe_injective":
 "theorem coe_injective [SeparatedSpace α] : function.injective (coe : α → Completion α) :=\n  uniform_embedding.inj (uniformEmbedding_coe _)\n#align coe_injective coe_injective\n\n",
 "coe_eq":
 "-- note [use has_coe_t]\nprotected theorem coe_eq : (coe : α → Completion α) = Quotient.mk' ∘ pureCauchy :=\n  rfl\n#align coe_eq coe_eq\n\n",
 "ContinuousMap":
 "#print ContinuousMap /-\ntheorem ContinuousMap : Continuous (Completion.map f) :=\n  cPkg.continuous_map cPkg f\n#align continuous_map ContinuousMap\n-/\n\n",
 "Cauchy_eq":
 "theorem Cauchy_eq {α : Type _} [Inhabited α] [UniformSpace α] [CompleteSpace α] [SeparatedSpace α]\n    {f g : CauchyFilter α} : lim f.1 = lim g.1 ↔ (f, g) ∈ separationRel (CauchyFilter α) :=\n  by\n  constructor\n  · intro e s hs\n    rcases CauchyFilter.mem_uniformity'.1 hs with ⟨t, tu, ts⟩\n    apply ts\n    rcases comp_mem_uniformity_sets tu with ⟨d, du, dt⟩\n    refine'\n      mem_prod_iff.2\n        ⟨_, f.2.le_nhds_Lim (mem_nhds_right (lim f.1) du), _, g.2.le_nhds_Lim (mem_nhds_left (lim g.1) du), fun x h =>\n          _⟩\n    cases' x with a b\n    cases' h with h₁ h₂\n    rw [← e] at h₂\n    exact dt ⟨_, h₁, h₂⟩\n  · intro H\n    refine' separated_def.1 (by infer_instance) _ _ fun t tu => _\n    rcases mem_uniformity_isClosed tu with ⟨d, du, dc, dt⟩\n    refine' H { p | (lim p.1.1, lim p.2.1) ∈ t } (CauchyFilter.mem_uniformity'.2 ⟨d, du, fun f g h => _⟩)\n    rcases mem_prod_iff.1 h with ⟨x, xf, y, yg, h⟩\n    have limc : ∀ (f : CauchyFilter α), ∀ x ∈ f.1, lim f.1 ∈ closure x :=\n      by\n      intro f x xf\n      rw [closure_eq_cluster_pts]\n      exact f.2.1.mono (le_inf f.2.le_nhds_Lim (le_principal_iff.2 xf))\n    have := dc.closure_subset_iff.2 h\n    rw [closure_prod_eq] at this\n    refine' dt (this ⟨_, _⟩) <;> dsimp <;> apply limc <;> assumption\n#align Cauchy_eq Cauchy_eq\n\n"}