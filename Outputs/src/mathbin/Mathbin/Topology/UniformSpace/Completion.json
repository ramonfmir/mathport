{"uniform_inducing_pure_cauchy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem uniform_inducing_pure_cauchy : uniform_inducing (pure_cauchy : α → Cauchy α) :=\n  ⟨have : (preimage fun x : α × α => (pure_cauchy x.fst, pure_cauchy x.snd)) ∘ gen = id :=\n      funext fun s => Set.ext fun ⟨a₁, a₂⟩ => by simp [preimage, gen, pure_cauchy, prod_principal_principal]\n    calc\n      comap (fun x : α × α => (pure_cauchy x.fst, pure_cauchy x.snd)) (((uniformity) α).lift' gen) =\n          ((uniformity) α).lift' ((preimage fun x : α × α => (pure_cauchy x.fst, pure_cauchy x.snd)) ∘ gen) :=\n        comap_lift'_eq\n      _ = (uniformity) α := by simp [this]\n      ⟩\n#align uniform_inducing_pure_cauchy uniform_inducing_pure_cauchy\n\n",
 "uniform_inducing_coe":
 "theorem uniform_inducing_coe : uniform_inducing (coe : α → completion α) :=\n  ⟨comap_coe_eq_uniformity α⟩\n#align uniform_inducing_coe uniform_inducing_coe\n\n",
 "uniform_embedding_pure_cauchy":
 "theorem uniform_embedding_pure_cauchy : uniform_embedding (pure_cauchy : α → Cauchy α) :=\n  { uniform_inducing_pure_cauchy with inj := fun a₁ a₂ h => pure_injective <| subtype.ext_iff_val.1 h }\n#align uniform_embedding_pure_cauchy uniform_embedding_pure_cauchy\n\n",
 "uniform_embedding_coe":
 "theorem uniform_embedding_coe [separated_space α] : uniform_embedding (coe : α → completion α) :=\n  { comap_uniformity := comap_coe_eq_uniformity α\n    inj := separated_pure_cauchy_injective }\n#align uniform_embedding_coe uniform_embedding_coe\n\n",
 "uniform_continuous_map₂":
 "theorem uniform_continuous_map₂ (f : α → β → γ) : uniform_continuous₂ (completion.map₂ f) :=\n  cpkg.uniform_continuous_map₂ cpkg cpkg f\n#align uniform_continuous_map₂ uniform_continuous_map₂\n\n",
 "uniform_continuous_map":
 "theorem uniform_continuous_map : uniform_continuous (completion.map f) :=\n  cpkg.uniform_continuous_map cpkg f\n#align uniform_continuous_map uniform_continuous_map\n\n",
 "uniform_continuous_extension₂":
 "theorem uniform_continuous_extension₂ : uniform_continuous₂ (completion.extension₂ f) :=\n  cpkg.uniform_continuous_extension₂ cpkg f\n#align uniform_continuous_extension₂ uniform_continuous_extension₂\n\n",
 "uniform_continuous_extension":
 "theorem uniform_continuous_extension : uniform_continuous (completion.extension f) :=\n  cpkg.uniform_continuous_extend\n#align uniform_continuous_extension uniform_continuous_extension\n\n",
 "uniform_continuous_extend":
 "theorem uniform_continuous_extend {f : α → β} : uniform_continuous (extend f) :=\n  by\n  by_cases hf : uniform_continuous f\n  · rw [extend, if_pos hf]\n    exact uniform_continuous_uniformly_extend uniform_inducing_pure_cauchy dense_range_pure_cauchy hf\n  · rw [extend, if_neg hf]\n    exact uniform_continuous_of_const fun a b => by congr\n#align uniform_continuous_extend uniform_continuous_extend\n\n",
 "uniform_continuous_completion_separation_quotient_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem uniform_continuous_completion_separation_quotient_equiv_symm :\n    uniform_continuous («expr⇑ » (completion_separation_quotient_equiv α).symm) :=\n  uniform_continuous_map\n#align\n  uniform_continuous_completion_separation_quotient_equiv_symm uniform_continuous_completion_separation_quotient_equiv_symm\n\n",
 "uniform_continuous_completion_separation_quotient_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- In this section we construct isomorphisms between the completion of a uniform space and the\ncompletion of its separation quotient -/\ntheorem uniform_continuous_completion_separation_quotient_equiv :\n    uniform_continuous («expr⇑ » (completion_separation_quotient_equiv α)) :=\n  uniform_continuous_extension\n#align uniform_continuous_completion_separation_quotient_equiv uniform_continuous_completion_separation_quotient_equiv\n\n",
 "uniform_continuous_coe":
 "theorem uniform_continuous_coe : uniform_continuous (coe : α → completion α) :=\n  cpkg.uniform_continuous_coe\n#align uniform_continuous_coe uniform_continuous_coe\n\n",
 "symm_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\nprivate theorem symm_gen : map prod.swap (((uniformity) α).lift' gen) ≤ ((uniformity) α).lift' gen :=\n  calc\n    map prod.swap (((uniformity) α).lift' gen) =\n        ((uniformity) α).lift' fun s : set (α × α) => { p | s ∈ filter.prod p.2.val p.1.val } :=\n      by\n      delta gen\n      simp [map_lift'_eq, monotone_set_of, filter.monotone_mem, function.comp, image_swap_eq_preimage_swap,\n        -subtype.val_eq_coe]\n    _ ≤ ((uniformity) α).lift' gen :=\n      uniformity_lift_le_swap\n        (monotone_principal.comp (monotone_set_of fun p => @filter.monotone_mem _ (filter.prod p.2.val p.1.val)))\n        (by\n          have h := fun p : Cauchy α × Cauchy α => @filter.prod_comm _ _ p.2.val p.1.val\n          simp [function.comp, h, -subtype.val_eq_coe, mem_map']\n          exact le_rfl)\n    \n#align symm_gen symm_gen\n\n",
 "separated_pure_cauchy_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem separated_pure_cauchy_injective {α : Type _} [uniform_space α] [s : separated_space α] :\n    function.injective fun a : α => «expr⟦ ⟧» (pure_cauchy a)\n  | a, b, h =>\n    separated_def.1 s _ _ fun s hs =>\n      let ⟨t, ht, hts⟩ := by\n        rw [← (@uniform_embedding_pure_cauchy α _).comap_uniformity, filter.mem_comap] at hs <;> exact hs\n      have : (pure_cauchy a, pure_cauchy b) ∈ t := quotient.exact h t ht\n      @hts (a, b) this\n#align separated_pure_cauchy_injective separated_pure_cauchy_injective\n\n",
 "nonempty_completion_iff":
 "theorem nonempty_completion_iff : nonempty (completion α) ↔ nonempty α :=\n  cpkg.dense.nonempty_iff.symm\n#align nonempty_completion_iff nonempty_completion_iff\n\n",
 "nonempty_Cauchy_iff":
 "theorem nonempty_Cauchy_iff : nonempty (Cauchy α) ↔ nonempty α :=\n  by\n  constructor <;> rintro ⟨c⟩\n  · have := eq_univ_iff_forall.1 dense_embedding_pure_cauchy.to_dense_inducing.closure_range c\n    obtain ⟨_, ⟨_, a, _⟩⟩ := mem_closure_iff.1 this _ is_open_univ trivial\n    exact ⟨a⟩\n  · exact ⟨pure_cauchy c⟩\n#align nonempty_Cauchy_iff nonempty_Cauchy_iff\n\n",
 "monotone_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/-\nCopyright (c) 2018 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Johannes Hölzl\n-/\ntheorem monotone_gen : monotone gen :=\n  monotone_set_of fun p => @filter.monotone_mem _ (filter.prod p.1.val p.2.val)\n#align monotone_gen monotone_gen\n\n",
 "mem_uniformity'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\ntheorem mem_uniformity' {s : set (Cauchy α × Cauchy α)} :\n    s ∈ (uniformity) (Cauchy α) ↔ ∃ t ∈ (uniformity) α, ∀ f g : Cauchy α, t ∈ filter.prod f.1 g.1 → (f, g) ∈ s :=\n  mem_uniformity.trans <| bex_congr fun t h => prod.forall\n#align mem_uniformity' mem_uniformity'\n\n",
 "mem_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem mem_uniformity {s : set (Cauchy α × Cauchy α)} :\n    s ∈ (uniformity) (Cauchy α) ↔ ∃ t ∈ (uniformity) α, gen t ⊆ s :=\n  mem_lift'_sets monotone_gen\n#align mem_uniformity mem_uniformity\n\n",
 "map₂_coe_coe":
 "theorem map₂_coe_coe (a : α) (b : β) (f : α → β → γ) (hf : uniform_continuous₂ f) :\n    completion.map₂ f (a : completion α) (b : completion β) = f a b :=\n  cpkg.map₂_coe_coe cpkg cpkg a b f hf\n#align map₂_coe_coe map₂_coe_coe\n\n",
 "map_unique":
 "theorem map_unique {f : α → β} {g : completion α → completion β} (hg : uniform_continuous g)\n    (h : ∀ a : α, ↑(f a) = g a) : completion.map f = g :=\n  cpkg.map_unique cpkg hg h\n#align map_unique map_unique\n\n",
 "map_id":
 "@[simp]\ntheorem map_id : completion.map (@id α) = id :=\n  cpkg.map_id\n#align map_id map_id\n\n",
 "map_comp":
 "theorem map_comp {g : β → γ} {f : α → β} (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    completion.map g ∘ completion.map f = completion.map (g ∘ f) :=\n  extension_map ((uniform_continuous_coe _).comp hg) hf\n#align map_comp map_comp\n\n",
 "map_coe":
 "@[simp]\ntheorem map_coe (hf : uniform_continuous f) (a : α) : (completion.map f) a = f a :=\n  cpkg.map_coe cpkg hf a\n#align map_coe map_coe\n\n",
 "induction_on₃":
 "@[elab_as_elim]\ntheorem induction_on₃ {p : completion α → completion β → completion γ → Prop} (a : completion α) (b : completion β)\n    (c : completion γ) (hp : is_closed { x : completion α × completion β × completion γ | p x.1 x.2.1 x.2.2 })\n    (ih : ∀ (a : α) (b : β) (c : γ), p a b c) : p a b c :=\n  have : ∀ x : completion α × completion β × completion γ, p x.1 x.2.1 x.2.2 :=\n    is_closed_property dense_range_coe₃ hp fun ⟨a, b, c⟩ => ih a b c\n  this (a, b, c)\n#align induction_on₃ induction_on₃\n\n",
 "induction_on₂":
 "@[elab_as_elim]\ntheorem induction_on₂ {p : completion α → completion β → Prop} (a : completion α) (b : completion β)\n    (hp : is_closed { x : completion α × completion β | p x.1 x.2 }) (ih : ∀ (a : α) (b : β), p a b) : p a b :=\n  have : ∀ x : completion α × completion β, p x.1 x.2 := is_closed_property dense_range_coe₂ hp fun ⟨a, b⟩ => ih a b\n  this (a, b)\n#align induction_on₂ induction_on₂\n\n",
 "induction_on":
 "@[elab_as_elim]\ntheorem induction_on {p : completion α → Prop} (a : completion α) (hp : is_closed { a | p a }) (ih : ∀ a : α, p a) :\n    p a :=\n  is_closed_property dense_range_coe hp ih a\n#align induction_on induction_on\n\n",
 "extension₂_coe_coe":
 "@[simp]\ntheorem extension₂_coe_coe (hf : uniform_continuous₂ f) (a : α) (b : β) : completion.extension₂ f a b = f a b :=\n  cpkg.extension₂_coe_coe cpkg hf a b\n#align extension₂_coe_coe extension₂_coe_coe\n\n",
 "extension_unique":
 "theorem extension_unique (hf : uniform_continuous f) {g : completion α → β} (hg : uniform_continuous g)\n    (h : ∀ a : α, f a = g (a : completion α)) : completion.extension f = g :=\n  cpkg.extend_unique hf hg h\n#align extension_unique extension_unique\n\n",
 "extension_map":
 "theorem extension_map [complete_space γ] [separated_space γ] {f : β → γ} {g : α → β} (hf : uniform_continuous f)\n    (hg : uniform_continuous g) : completion.extension f ∘ completion.map g = completion.extension (f ∘ g) :=\n  completion.ext (continuous_extension.comp continuous_map) continuous_extension <| by\n    intro a <;> simp only [hg, hf, hf.comp hg, (· ∘ ·), map_coe, extension_coe]\n#align extension_map extension_map\n\n",
 "extension_comp_coe":
 "@[simp]\ntheorem extension_comp_coe {f : completion α → β} (hf : uniform_continuous f) : completion.extension (f ∘ coe) = f :=\n  cpkg.extend_comp_coe hf\n#align extension_comp_coe extension_comp_coe\n\n",
 "extension_coe":
 "@[simp]\ntheorem extension_coe [separated_space β] (hf : uniform_continuous f) (a : α) : (completion.extension f) a = f a :=\n  cpkg.extend_coe hf a\n#align extension_coe extension_coe\n\n",
 "extend_pure_cauchy":
 "theorem extend_pure_cauchy {f : α → β} (hf : uniform_continuous f) (a : α) : extend f (pure_cauchy a) = f a :=\n  by\n  rw [extend, if_pos hf]\n  exact uniformly_extend_of_ind uniform_inducing_pure_cauchy dense_range_pure_cauchy hf _\n#align extend_pure_cauchy extend_pure_cauchy\n\n",
 "ext'":
 "theorem ext' {Y : Type _} [topological_space Y] [t2_space Y] {f g : completion α → Y} (hf : continuous f)\n    (hg : continuous g) (h : ∀ a : α, f a = g a) (a : completion α) : f a = g a :=\n  congr_fun (ext hf hg h) a\n#align ext' ext'\n\n",
 "ext":
 "theorem ext {Y : Type _} [topological_space Y] [t2_space Y] {f g : completion α → Y} (hf : continuous f)\n    (hg : continuous g) (h : ∀ a : α, f a = g a) : f = g :=\n  cpkg.funext hf hg h\n#align ext ext\n\n",
 "dense_range_pure_cauchy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem dense_range_pure_cauchy : dense_range pure_cauchy := fun f =>\n  by\n  have h_ex : ∀ s ∈ (uniformity) (Cauchy α), ∃ y : α, (f, pure_cauchy y) ∈ s := fun s hs =>\n    let ⟨t'', ht''₁, (ht''₂ : gen t'' ⊆ s)⟩ := (mem_lift'_sets monotone_gen).mp hs\n    let ⟨t', ht'₁, ht'₂⟩ := comp_mem_uniformity_sets ht''₁\n    have : t' ∈ filter.prod f.val f.val := f.property.right ht'₁\n    let ⟨t, ht, (h : lower_set.prod t t ⊆ t')⟩ := mem_prod_same_iff.mp this\n    let ⟨x, (hx : x ∈ t)⟩ := f.property.left.nonempty_of_mem ht\n    have : t'' ∈ filter.prod f.val (pure x) :=\n      mem_prod_iff.mpr\n        ⟨t, ht, { y : α | (x, y) ∈ t' }, h <| mk_mem_prod hx hx, fun ⟨a, b⟩ ⟨(h₁ : a ∈ t), (h₂ : (x, b) ∈ t')⟩ =>\n          ht'₂ <| prod_mk_mem_comp_rel (@h (a, x) ⟨h₁, hx⟩) h₂⟩\n    ⟨x, ht''₂ <| by dsimp [gen] <;> exact this⟩\n  simp only [closure_eq_cluster_pts, cluster_pt, nhds_eq_uniformity, lift'_inf_principal_eq,\n    Set.inter_comm _ (range pure_cauchy), mem_set_of_eq]\n  exact\n    (lift'_ne_bot_iff <| monotone_const.inter monotone_preimage).mpr fun s hs =>\n      let ⟨y, hy⟩ := h_ex s hs\n      have : pure_cauchy y ∈ range pure_cauchy ∩ { y : Cauchy α | (f, y) ∈ s } := ⟨mem_range_self y, hy⟩\n      ⟨_, this⟩\n#align dense_range_pure_cauchy dense_range_pure_cauchy\n\n",
 "dense_range_coe₃":
 "theorem dense_range_coe₃ :\n    dense_range fun x : α × β × γ => ((x.1 : completion α), ((x.2.1 : completion β), (x.2.2 : completion γ))) :=\n  dense_range_coe.prod_map dense_range_coe₂\n#align dense_range_coe₃ dense_range_coe₃\n\n",
 "dense_range_coe₂":
 "theorem dense_range_coe₂ : dense_range fun x : α × β => ((x.1 : completion α), (x.2 : completion β)) :=\n  dense_range_coe.prod_map dense_range_coe\n#align dense_range_coe₂ dense_range_coe₂\n\n",
 "dense_range_coe":
 "theorem dense_range_coe : dense_range (coe : α → completion α) :=\n  dense_range_pure_cauchy.quotient\n#align dense_range_coe dense_range_coe\n\n",
 "dense_inducing_pure_cauchy":
 "theorem dense_inducing_pure_cauchy : dense_inducing pure_cauchy :=\n  uniform_inducing_pure_cauchy.dense_inducing dense_range_pure_cauchy\n#align dense_inducing_pure_cauchy dense_inducing_pure_cauchy\n\n",
 "dense_inducing_coe":
 "theorem dense_inducing_coe : dense_inducing (coe : α → completion α) :=\n  { (uniform_inducing_coe α).inducing with dense := dense_range_coe }\n#align dense_inducing_coe dense_inducing_coe\n\n",
 "dense_embedding_pure_cauchy":
 "theorem dense_embedding_pure_cauchy : dense_embedding pure_cauchy :=\n  uniform_embedding_pure_cauchy.dense_embedding dense_range_pure_cauchy\n#align dense_embedding_pure_cauchy dense_embedding_pure_cauchy\n\n",
 "dense_embedding_coe":
 "theorem dense_embedding_coe [separated_space α] : dense_embedding (coe : α → completion α) :=\n  { dense_inducing_coe with inj := separated_pure_cauchy_injective }\n#align dense_embedding_coe dense_embedding_coe\n\n",
 "continuous_map₂":
 "theorem continuous_map₂ {δ} [topological_space δ] {f : α → β → γ} {a : δ → completion α} {b : δ → completion β}\n    (ha : continuous a) (hb : continuous b) : continuous fun d : δ => completion.map₂ f (a d) (b d) :=\n  cpkg.continuous_map₂ cpkg cpkg ha hb\n#align continuous_map₂ continuous_map₂\n\n",
 "continuous_map":
 "theorem continuous_map : continuous (completion.map f) :=\n  cpkg.continuous_map cpkg f\n#align continuous_map continuous_map\n\n",
 "continuous_extension":
 "theorem continuous_extension : continuous (completion.extension f) :=\n  cpkg.continuous_extend\n#align continuous_extension continuous_extension\n\n",
 "continuous_coe":
 "theorem continuous_coe : continuous (coe : α → completion α) :=\n  cpkg.continuous_coe\n#align continuous_coe continuous_coe\n\n",
 "comp_rel_gen_gen_subset_gen_comp_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\nprivate theorem comp_rel_gen_gen_subset_gen_comp_rel {s t : set (α × α)} :\n    comp_rel (gen s) (gen t) ⊆ (gen (comp_rel s t) : set (Cauchy α × Cauchy α)) := fun ⟨f, g⟩ ⟨h, h₁, h₂⟩ =>\n  let ⟨t₁, (ht₁ : t₁ ∈ f), t₂, (ht₂ : t₂ ∈ h), (h₁ : lower_set.prod t₁ t₂ ⊆ s)⟩ := mem_prod_iff.mp h₁\n  let ⟨t₃, (ht₃ : t₃ ∈ h), t₄, (ht₄ : t₄ ∈ g), (h₂ : lower_set.prod t₃ t₄ ⊆ t)⟩ := mem_prod_iff.mp h₂\n  have : t₂ ∩ t₃ ∈ h.val := inter_mem ht₂ ht₃\n  let ⟨x, xt₂, xt₃⟩ := h.property.left.nonempty_of_mem this\n  (filter.prod f.val g.val).sets_of_superset (prod_mem_prod ht₁ ht₄) fun ⟨a, b⟩ ⟨(ha : a ∈ t₁), (hb : b ∈ t₄)⟩ =>\n    ⟨x, h₁ (show (a, x) ∈ lower_set.prod t₁ t₂ from ⟨ha, xt₂⟩), h₂ (show (x, b) ∈ lower_set.prod t₃ t₄ from ⟨xt₃, hb⟩)⟩\n#align comp_rel_gen_gen_subset_gen_comp_rel comp_rel_gen_gen_subset_gen_comp_rel\n\n",
 "comp_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\nprivate theorem comp_gen : ((((uniformity) α).lift' gen).lift' fun s => comp_rel s s) ≤ ((uniformity) α).lift' gen :=\n  calc\n    ((((uniformity) α).lift' gen).lift' fun s => comp_rel s s) =\n        ((uniformity) α).lift' fun s => comp_rel (gen s) (gen s) :=\n      by\n      rw [lift'_lift'_assoc]\n      exact monotone_gen\n      exact monotone_comp_rel monotone_id monotone_id\n    _ ≤ ((uniformity) α).lift' fun s => gen <| comp_rel s s :=\n      lift'_mono' fun s hs => comp_rel_gen_gen_subset_gen_comp_rel\n    _ = (((uniformity) α).lift' fun s : set (α × α) => comp_rel s s).lift' gen :=\n      by\n      rw [lift'_lift'_assoc]\n      exact monotone_comp_rel monotone_id monotone_id\n      exact monotone_gen\n    _ ≤ ((uniformity) α).lift' gen := lift'_mono comp_le_uniformity le_rfl\n    \n#align comp_gen comp_gen\n\n",
 "comap_coe_eq_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem comap_coe_eq_uniformity :\n    (((uniformity) _).comap fun p : α × α => ((p.1 : completion α), (p.2 : completion α))) = (uniformity) α :=\n  by\n  have :\n    (fun x : α × α => ((x.1 : completion α), (x.2 : completion α))) =\n      (fun x : Cauchy α × Cauchy α => («expr⟦ ⟧» x.1, «expr⟦ ⟧» x.2)) ∘ fun x : α × α =>\n        (pure_cauchy x.1, pure_cauchy x.2) :=\n    by ext ⟨a, b⟩ <;> simp <;> rfl\n  rw [this, ← filter.comap_comap]\n  change filter.comap _ (filter.comap _ (uniformity <| quotient <| separation_setoid <| Cauchy α)) = (uniformity) α\n  rw [comap_quotient_eq_uniformity, uniform_embedding_pure_cauchy.comap_uniformity]\n#align comap_coe_eq_uniformity comap_coe_eq_uniformity\n\n",
 "coe_injective":
 "theorem coe_injective [separated_space α] : function.injective (coe : α → completion α) :=\n  uniform_embedding.inj (uniform_embedding_coe _)\n#align coe_injective coe_injective\n\n",
 "coe_eq":
 "-- note [use has_coe_t]\nprotected theorem coe_eq : (coe : α → completion α) = Quotient.mk'' ∘ pure_cauchy :=\n  rfl\n#align coe_eq coe_eq\n\n",
 "Cauchy_eq":
 "theorem Cauchy_eq {α : Type _} [inhabited α] [uniform_space α] [complete_space α] [separated_space α] {f g : Cauchy α} :\n    Lim f.1 = Lim g.1 ↔ (f, g) ∈ separation_rel (Cauchy α) :=\n  by\n  constructor\n  · intro e s hs\n    rcases Cauchy.mem_uniformity'.1 hs with ⟨t, tu, ts⟩\n    apply ts\n    rcases comp_mem_uniformity_sets tu with ⟨d, du, dt⟩\n    refine'\n      mem_prod_iff.2\n        ⟨_, f.2.le_nhds_Lim (mem_nhds_right (Lim f.1) du), _, g.2.le_nhds_Lim (mem_nhds_left (Lim g.1) du), fun x h =>\n          _⟩\n    cases' x with a b\n    cases' h with h₁ h₂\n    rw [← e] at h₂\n    exact dt ⟨_, h₁, h₂⟩\n  · intro H\n    refine' separated_def.1 (by infer_instance) _ _ fun t tu => _\n    rcases mem_uniformity_is_closed tu with ⟨d, du, dc, dt⟩\n    refine' H { p | (Lim p.1.1, Lim p.2.1) ∈ t } (Cauchy.mem_uniformity'.2 ⟨d, du, fun f g h => _⟩)\n    rcases mem_prod_iff.1 h with ⟨x, xf, y, yg, h⟩\n    have limc : ∀ (f : Cauchy α), ∀ x ∈ f.1, Lim f.1 ∈ closure x :=\n      by\n      intro f x xf\n      rw [closure_eq_cluster_pts]\n      exact f.2.1.mono (le_inf f.2.le_nhds_Lim (le_principal_iff.2 xf))\n    have := dc.closure_subset_iff.2 h\n    rw [closure_prod_eq] at this\n    refine' dt (this ⟨_, _⟩) <;> dsimp <;> apply limc <;> assumption\n#align Cauchy_eq Cauchy_eq\n\n"}