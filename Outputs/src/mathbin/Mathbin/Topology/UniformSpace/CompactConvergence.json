{"tendsto_of_tendsto_locally_uniformly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Locally uniform convergence implies convergence in the compact-open topology. -/\ntheorem tendsto_of_tendsto_locally_uniformly (h : tendsto_locally_uniformly (fun i a => F i a) f p) :\n    tendsto F p ((nhds) f) := by\n  rw [tendsto_iff_forall_compact_tendsto_uniformly_on]\n  intro K hK\n  rw [← tendsto_locally_uniformly_on_iff_tendsto_uniformly_on_of_compact hK]\n  exact h.tendsto_locally_uniformly_on\n#align tendsto_of_tendsto_locally_uniformly tendsto_of_tendsto_locally_uniformly\n\n",
 "tendsto_locally_uniformly_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If every point has a compact neighbourhood, then convergence in the compact-open topology\nimplies locally uniform convergence.\n\nSee also `tendsto_iff_tendsto_locally_uniformly`, especially for T2 spaces. -/\ntheorem tendsto_locally_uniformly_of_tendsto (hα : ∀ x : α, ∃ n, is_compact n ∧ n ∈ (nhds) x)\n    (h : tendsto F p ((nhds) f)) : tendsto_locally_uniformly (fun i a => F i a) f p :=\n  by\n  rw [tendsto_iff_forall_compact_tendsto_uniformly_on] at h\n  intro V hV x\n  obtain ⟨n, hn₁, hn₂⟩ := hα x\n  exact ⟨n, hn₂, h n hn₁ V hV⟩\n#align tendsto_locally_uniformly_of_tendsto tendsto_locally_uniformly_of_tendsto\n\n",
 "tendsto_iff_tendsto_uniformly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Convergence in the compact-open topology is the same as uniform convergence for sequences of\ncontinuous functions on a compact space. -/\ntheorem tendsto_iff_tendsto_uniformly : tendsto F p ((nhds) f) ↔ tendsto_uniformly (fun i a => F i a) f p :=\n  by\n  rw [tendsto_iff_forall_compact_tendsto_uniformly_on, ← tendsto_uniformly_on_univ]\n  exact ⟨fun h => h univ is_compact_univ, fun h K hK => h.mono (subset_univ K)⟩\n#align tendsto_iff_tendsto_uniformly tendsto_iff_tendsto_uniformly\n\n",
 "tendsto_iff_tendsto_locally_uniformly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Convergence in the compact-open topology is the same as locally uniform convergence on a locally\ncompact space.\n\nFor non-T2 spaces, the assumption `locally_compact_space α` is stronger than we need and in fact\nthe `←` direction is true unconditionally. See `tendsto_locally_uniformly_of_tendsto` and\n`tendsto_of_tendsto_locally_uniformly` for versions requiring weaker hypotheses. -/\ntheorem tendsto_iff_tendsto_locally_uniformly [locally_compact_space α] :\n    tendsto F p ((nhds) f) ↔ tendsto_locally_uniformly (fun i a => F i a) f p :=\n  ⟨tendsto_locally_uniformly_of_tendsto exists_compact_mem_nhds, tendsto_of_tendsto_locally_uniformly⟩\n#align tendsto_iff_tendsto_locally_uniformly tendsto_iff_tendsto_locally_uniformly\n\n",
 "tendsto_iff_forall_compact_tendsto_uniformly_on'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- This is an auxiliary lemma and is unlikely to be of direct use outside of this file. See\n`tendsto_iff_forall_compact_tendsto_uniformly_on` below for the useful version where the topology\nis picked up via typeclass inference. -/\ntheorem tendsto_iff_forall_compact_tendsto_uniformly_on' {ι : Type u₃} {p : filter ι} {F : ι → «exprC( , )» α β} :\n    filter.tendsto F p (@nhds _ compact_convergence_topology f) ↔\n      ∀ K, is_compact K → tendsto_uniformly_on (fun i a => F i a) f p K :=\n  by\n  simp only [(has_basis_nhds_compact_convergence f).tendsto_right_iff, tendsto_uniformly_on, and_imp, prod.forall]\n  refine' forall_congr' fun K => _\n  rw [forall_swap]\n  exact forall₃_congr fun hK V hV => iff.rfl\n#align tendsto_iff_forall_compact_tendsto_uniformly_on' tendsto_iff_forall_compact_tendsto_uniformly_on'\n\n",
 "tendsto_iff_forall_compact_tendsto_uniformly_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_iff_forall_compact_tendsto_uniformly_on :\n    tendsto F p ((nhds) f) ↔ ∀ K, is_compact K → tendsto_uniformly_on (fun i a => F i a) f p K := by\n  rw [compact_open_eq_compact_convergence, tendsto_iff_forall_compact_tendsto_uniformly_on']\n#align tendsto_iff_forall_compact_tendsto_uniformly_on tendsto_iff_forall_compact_tendsto_uniformly_on\n\n",
 "self_mem_compact_conv_nhd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-\nCopyright (c) 2021 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\ntheorem self_mem_compact_conv_nhd (hV : V ∈ (uniformity) β) : f ∈ compact_conv_nhd K V f := fun x hx =>\n  refl_mem_uniformity hV\n#align self_mem_compact_conv_nhd self_mem_compact_conv_nhd\n\n",
 "nhds_compact_convergence":
 "theorem nhds_compact_convergence :\n    @nhds _ compact_convergence_topology f = (compact_convergence_filter_basis f).filter :=\n  by\n  rw [topological_space.nhds_mk_of_nhds_filter_basis] <;> rintro g - ⟨⟨K, V⟩, ⟨hK, hV⟩, rfl⟩\n  · exact self_mem_compact_conv_nhd g hV\n  · obtain ⟨V', hV', h₁, h₂⟩ := compact_conv_nhd_nhd_basis g hV\n    exact\n      ⟨compact_conv_nhd K V' g, ⟨⟨K, V'⟩, ⟨hK, hV'⟩, rfl⟩, compact_conv_nhd_mono g h₁, fun g' hg' =>\n        ⟨compact_conv_nhd K V' g', ⟨⟨K, V'⟩, ⟨hK, hV'⟩, rfl⟩, h₂ g' hg'⟩⟩\n#align nhds_compact_convergence nhds_compact_convergence\n\n",
 "mem_compact_convergence_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- An intermediate lemma. Usually `mem_compact_convergence_entourage_iff` is more useful. -/\ntheorem mem_compact_convergence_uniformity (X : set («exprC( , )» α β × «exprC( , )» α β)) :\n    X ∈ @compact_convergence_uniformity α β _ _ ↔\n      ∃ (K : set α)(V : set (β × β))(hK : is_compact K)(hV : V ∈ (uniformity) β),\n        { fg : «exprC( , )» α β × «exprC( , )» α β | ∀ x ∈ K, (fg.1 x, fg.2 x) ∈ V } ⊆ X :=\n  by simp only [has_basis_compact_convergence_uniformity_aux.mem_iff, exists_prop, prod.exists, and_assoc']\n#align mem_compact_convergence_uniformity mem_compact_convergence_uniformity\n\n",
 "mem_compact_convergence_nhd_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem mem_compact_convergence_nhd_filter (Y : set («exprC( , )» α β)) :\n    Y ∈ (compact_convergence_filter_basis f).filter ↔\n      ∃ (K : set α)(V : set (β × β))(hK : is_compact K)(hV : V ∈ (uniformity) β), compact_conv_nhd K V f ⊆ Y :=\n  by\n  constructor\n  · rintro ⟨X, ⟨⟨K, V⟩, ⟨hK, hV⟩, rfl⟩, hY⟩\n    exact ⟨K, V, hK, hV, hY⟩\n  · rintro ⟨K, V, hK, hV, hY⟩\n    exact ⟨compact_conv_nhd K V f, ⟨⟨K, V⟩, ⟨hK, hV⟩, rfl⟩, hY⟩\n#align mem_compact_convergence_nhd_filter mem_compact_convergence_nhd_filter\n\n",
 "mem_compact_convergence_entourage_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem mem_compact_convergence_entourage_iff (X : set («exprC( , )» α β × «exprC( , )» α β)) :\n    X ∈ (uniformity) («exprC( , )» α β) ↔\n      ∃ (K : set α)(V : set (β × β))(hK : is_compact K)(hV : V ∈ (uniformity) β),\n        { fg : «exprC( , )» α β × «exprC( , )» α β | ∀ x ∈ K, (fg.1 x, fg.2 x) ∈ V } ⊆ X :=\n  mem_compact_convergence_uniformity X\n#align mem_compact_convergence_entourage_iff mem_compact_convergence_entourage_iff\n\n",
 "has_basis_nhds_compact_convergence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem has_basis_nhds_compact_convergence :\n    has_basis (@nhds _ compact_convergence_topology f)\n      (fun p : set α × set (β × β) => is_compact p.1 ∧ p.2 ∈ (uniformity) β) fun p => compact_conv_nhd p.1 p.2 f :=\n  (nhds_compact_convergence f).symm ▸ (compact_conv_nhd_filter_is_basis f).has_basis\n#align has_basis_nhds_compact_convergence has_basis_nhds_compact_convergence\n\n",
 "has_basis_compact_convergence_uniformity_of_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem has_basis_compact_convergence_uniformity_of_compact :\n    has_basis ((uniformity) («exprC( , )» α β)) (fun V : set (β × β) => V ∈ (uniformity) β) fun V =>\n      { fg : «exprC( , )» α β × «exprC( , )» α β | ∀ x, (fg.1 x, fg.2 x) ∈ V } :=\n  has_basis_compact_convergence_uniformity.to_has_basis (fun p hp => ⟨p.2, hp.2, fun fg hfg x hx => hfg x⟩) fun V hV =>\n    ⟨⟨univ, V⟩, ⟨is_compact_univ, hV⟩, fun fg hfg x => hfg x (mem_univ x)⟩\n#align has_basis_compact_convergence_uniformity_of_compact has_basis_compact_convergence_uniformity_of_compact\n\n",
 "has_basis_compact_convergence_uniformity_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem has_basis_compact_convergence_uniformity_aux :\n    has_basis (@compact_convergence_uniformity α β _ _)\n      (fun p : set α × set (β × β) => is_compact p.1 ∧ p.2 ∈ (uniformity) β) fun p =>\n      { fg : «exprC( , )» α β × «exprC( , )» α β | ∀ x ∈ p.1, (fg.1 x, fg.2 x) ∈ p.2 } :=\n  by\n  refine' filter.has_basis_binfi_principal _ compact_conv_nhd_compact_entourage_nonempty\n  rintro ⟨K₁, V₁⟩ ⟨hK₁, hV₁⟩ ⟨K₂, V₂⟩ ⟨hK₂, hV₂⟩\n  refine' ⟨⟨K₁ ∪ K₂, V₁ ∩ V₂⟩, ⟨hK₁.union hK₂, filter.inter_mem hV₁ hV₂⟩, _⟩\n  simp only [le_eq_subset, prod.forall, set_of_subset_set_of, ge_iff_le, Order.Preimage, ← forall_and, mem_inter_iff,\n    mem_union]\n  exact fun f g => forall_imp fun x => by tauto\n#align has_basis_compact_convergence_uniformity_aux has_basis_compact_convergence_uniformity_aux\n\n",
 "has_basis_compact_convergence_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem has_basis_compact_convergence_uniformity :\n    has_basis ((uniformity) («exprC( , )» α β)) (fun p : set α × set (β × β) => is_compact p.1 ∧ p.2 ∈ (uniformity) β)\n      fun p => { fg : «exprC( , )» α β × «exprC( , )» α β | ∀ x ∈ p.1, (fg.1 x, fg.2 x) ∈ p.2 } :=\n  has_basis_compact_convergence_uniformity_aux\n#align has_basis_compact_convergence_uniformity has_basis_compact_convergence_uniformity\n\n",
 "compact_open_eq_compact_convergence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- The compact-open topology is equal to the compact-convergence topology. -/\ntheorem compact_open_eq_compact_convergence :\n    continuous_map.compact_open = (compact_convergence_topology : topological_space («exprC( , )» α β)) :=\n  by\n  rw [compact_convergence_topology, continuous_map.compact_open]\n  refine' le_antisymm _ _\n  · refine' fun X hX => is_open_iff_forall_mem_open.mpr fun f hf => _\n    have hXf : X ∈ (compact_convergence_filter_basis f).filter :=\n      by\n      rw [← nhds_compact_convergence]\n      exact @is_open.mem_nhds («exprC( , )» α β) compact_convergence_topology _ _ hX hf\n    obtain ⟨-, ⟨⟨K, V⟩, ⟨hK, hV⟩, rfl⟩, hXf⟩ := hXf\n    obtain ⟨ι, hι, C, hC, U, hU, h₁, h₂⟩ := Inter_compact_open_gen_subset_compact_conv_nhd f hK hV\n    haveI := hι\n    exact\n      ⟨«expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (compact_open.gen (C i) (U i)),\n        h₂.trans hXf, is_open_Inter fun i => continuous_map.is_open_gen (hC i) (hU i), h₁⟩\n  · simp only [le_generate_from_iff_subset_is_open, and_imp, exists_prop, forall_exists_index, set_of_subset_set_of]\n    rintro - K hK U hU rfl f hf\n    obtain ⟨V, hV, hV', hVf⟩ := compact_conv_nhd_subset_compact_open f hK hU hf\n    exact filter.mem_of_superset (filter_basis.mem_filter_of_mem _ ⟨⟨K, V⟩, ⟨hK, hV⟩, rfl⟩) hVf\n#align compact_open_eq_compact_convergence compact_open_eq_compact_convergence\n\n",
 "compact_convergence_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem _root_.filter.has_basis.compact_convergence_uniformity {ι : Type _} {pi : ι → Prop} {s : ι → set (β × β)}\n    (h : ((uniformity) β).has_basis pi s) :\n    has_basis ((uniformity) («exprC( , )» α β)) (fun p : set α × ι => is_compact p.1 ∧ pi p.2) fun p =>\n      { fg : «exprC( , )» α β × «exprC( , )» α β | ∀ x ∈ p.1, (fg.1 x, fg.2 x) ∈ s p.2 } :=\n  by\n  refine' has_basis_compact_convergence_uniformity.to_has_basis _ _\n  · rintro ⟨t₁, t₂⟩ ⟨h₁, h₂⟩\n    rcases h.mem_iff.1 h₂ with ⟨i, hpi, hi⟩\n    exact ⟨(t₁, i), ⟨h₁, hpi⟩, fun fg hfg x hx => hi (hfg _ hx)⟩\n  · rintro ⟨t, i⟩ ⟨ht, hi⟩\n    exact ⟨(t, s i), ⟨ht, h.mem_of_mem hi⟩, subset.rfl⟩\n#align filter.has_basis.compact_convergence_uniformity filter.has_basis.compact_convergence_uniformity\n\n",
 "compact_conv_nhd_subset_inter":
 "theorem compact_conv_nhd_subset_inter (K₁ K₂ : set α) (V₁ V₂ : set (β × β)) :\n    compact_conv_nhd (K₁ ∪ K₂) (V₁ ∩ V₂) f ⊆ compact_conv_nhd K₁ V₁ f ∩ compact_conv_nhd K₂ V₂ f := fun g hg =>\n  ⟨fun x hx => mem_of_mem_inter_left (hg x (mem_union_left K₂ hx)), fun x hx =>\n    mem_of_mem_inter_right (hg x (mem_union_right K₁ hx))⟩\n#align compact_conv_nhd_subset_inter compact_conv_nhd_subset_inter\n\n",
 "compact_conv_nhd_subset_compact_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Any point of `compact_open.gen K U` is also an interior point wrt the topology of compact\nconvergence.\n\nThe topology of compact convergence is thus at least as fine as the compact-open topology. -/\ntheorem compact_conv_nhd_subset_compact_open (hK : is_compact K) {U : set β} (hU : is_open U)\n    (hf : f ∈ compact_open.gen K U) : ∃ V ∈ (uniformity) β, is_open V ∧ compact_conv_nhd K V f ⊆ compact_open.gen K U :=\n  by\n  obtain ⟨V, hV₁, hV₂, hV₃⟩ := lebesgue_number_of_compact_open (hK.image f.continuous) hU hf\n  refine' ⟨V, hV₁, hV₂, _⟩\n  rintro g hg _ ⟨x, hx, rfl⟩\n  exact hV₃ (f x) ⟨x, hx, rfl⟩ (hg x hx)\n#align compact_conv_nhd_subset_compact_open compact_conv_nhd_subset_compact_open\n\n",
 "compact_conv_nhd_nhd_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- A key property of `compact_conv_nhd`. It allows us to apply\n`topological_space.nhds_mk_of_nhds_filter_basis` below. -/\ntheorem compact_conv_nhd_nhd_basis (hV : V ∈ (uniformity) β) :\n    ∃ V' ∈ (uniformity) β, V' ⊆ V ∧ ∀ g ∈ compact_conv_nhd K V' f, compact_conv_nhd K V' g ⊆ compact_conv_nhd K V f :=\n  by\n  obtain ⟨V', h₁, h₂⟩ := comp_mem_uniformity_sets hV\n  exact\n    ⟨V', h₁, subset.trans (subset_comp_self_of_mem_uniformity h₁) h₂, fun g hg g' hg' =>\n      compact_conv_nhd_mono f h₂ (compact_conv_nhd_mem_comp f hg hg')⟩\n#align compact_conv_nhd_nhd_basis compact_conv_nhd_nhd_basis\n\n",
 "compact_conv_nhd_mono":
 "@[mono]\ntheorem compact_conv_nhd_mono {V' : set (β × β)} (hV' : V' ⊆ V) : compact_conv_nhd K V' f ⊆ compact_conv_nhd K V f :=\n  fun x hx a ha => hV' (hx a ha)\n#align compact_conv_nhd_mono compact_conv_nhd_mono\n\n",
 "compact_conv_nhd_mem_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity.comp_rel -/\ntheorem compact_conv_nhd_mem_comp {g₁ g₂ : «exprC( , )» α β} {V' : set (β × β)} (hg₁ : g₁ ∈ compact_conv_nhd K V f)\n    (hg₂ : g₂ ∈ compact_conv_nhd K V' g₁) : g₂ ∈ compact_conv_nhd K (uniformity.comp_rel V V') f := fun x hx =>\n  ⟨g₁ x, hg₁ x hx, hg₂ x hx⟩\n#align compact_conv_nhd_mem_comp compact_conv_nhd_mem_comp\n\n",
 "compact_conv_nhd_filter_is_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem compact_conv_nhd_filter_is_basis :\n    filter.is_basis (fun KV : set α × set (β × β) => is_compact KV.1 ∧ KV.2 ∈ (uniformity) β) fun KV =>\n      compact_conv_nhd KV.1 KV.2 f :=\n  { nonempty := compact_conv_nhd_compact_entourage_nonempty\n    inter := by\n      rintro ⟨K₁, V₁⟩ ⟨K₂, V₂⟩ ⟨hK₁, hV₁⟩ ⟨hK₂, hV₂⟩\n      exact\n        ⟨⟨K₁ ∪ K₂, V₁ ∩ V₂⟩, ⟨hK₁.union hK₂, filter.inter_mem hV₁ hV₂⟩, compact_conv_nhd_subset_inter f K₁ K₂ V₁ V₂⟩ }\n#align compact_conv_nhd_filter_is_basis compact_conv_nhd_filter_is_basis\n\n",
 "compact_conv_nhd_compact_entourage_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem compact_conv_nhd_compact_entourage_nonempty :\n    { KV : set α × set (β × β) | is_compact KV.1 ∧ KV.2 ∈ (uniformity) β }.nonempty :=\n  ⟨⟨∅, univ⟩, is_compact_empty, filter.univ_mem⟩\n#align compact_conv_nhd_compact_entourage_nonempty compact_conv_nhd_compact_entourage_nonempty\n\n",
 "Inter_compact_open_gen_subset_compact_conv_nhd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- The point `f` in `compact_conv_nhd K V f` is also an interior point wrt the compact-open\ntopology.\n\nSince `compact_conv_nhd K V f` are a neighbourhood basis at `f` for each `f`, it follows that\nthe compact-open topology is at least as fine as the topology of compact convergence. -/\ntheorem Inter_compact_open_gen_subset_compact_conv_nhd (hK : is_compact K) (hV : V ∈ (uniformity) β) :\n    ∃ (ι : Sort (u₁ + 1))(_ : fintype ι)(C : ι → set α)(hC : ∀ i, is_compact (C i))(U : ι → set β)(hU :\n      ∀ i, is_open (U i)),\n      f ∈\n          «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n            (compact_open.gen (C i) (U i)) ∧\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n            (compact_open.gen (C i) (U i)) ⊆\n          compact_conv_nhd K V f :=\n  by\n  obtain ⟨W, hW₁, hW₄, hW₂, hW₃⟩ := comp_open_symm_mem_uniformity_sets hV\n  obtain ⟨Z, hZ₁, hZ₄, hZ₂, hZ₃⟩ := comp_open_symm_mem_uniformity_sets hW₁\n  let U : α → set α := fun x => «expr ⁻¹' » f (ball (f x) Z)\n  have hU : ∀ x, is_open (U x) := fun x => f.continuous.is_open_preimage _ (is_open_ball _ hZ₄)\n  have hUK :\n    K ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U (x : K)) :=\n    by\n    intro x hx\n    simp only [exists_prop, mem_Union, Union_coe_set, mem_preimage]\n    exact ⟨(⟨x, hx⟩ : K), by simp [hx, mem_ball_self (f x) hZ₁]⟩\n  obtain ⟨t, ht⟩ := hK.elim_finite_subcover _ (fun x : K => hU x.val) hUK\n  let C : t → set α := fun i => K ∩ closure (U ((i : K) : α))\n  have hC : K ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (C i) :=\n    by\n    rw [← K.inter_Union, subset_inter_iff]\n    refine' ⟨subset.rfl, ht.trans _⟩\n    simp only [SetCoe.forall, subtype.coe_mk, Union_subset_iff]\n    exact fun x hx₁ hx₂ => subset_Union_of_subset (⟨_, hx₂⟩ : t) (by simp [subset_closure])\n  have hfC : ∀ i : t, C i ⊆ «expr ⁻¹' » f (ball (f ((i : K) : α)) W) :=\n    by\n    simp only [← image_subset_iff, ← mem_preimage]\n    rintro ⟨⟨x, hx₁⟩, hx₂⟩\n    have hZW : closure (ball (f x) Z) ⊆ ball (f x) W := by\n      intro y hy\n      obtain ⟨z, hz₁, hz₂⟩ := uniform_space.mem_closure_iff_ball.mp hy hZ₁\n      exact ball_mono hZ₃ _ (mem_ball_comp hz₂ ((mem_ball_symmetry hZ₂).mp hz₁))\n    calc\n      «expr '' » f (K ∩ closure (U x)) ⊆ «expr '' » f (closure (U x)) := image_subset _ (inter_subset_right _ _)\n      _ ⊆ closure («expr '' » f (U x)) := f.continuous.continuous_on.image_closure\n      _ ⊆ closure (ball (f x) Z) := by\n        apply closure_mono\n        simp\n      _ ⊆ ball (f x) W := hZW\n      \n  refine'\n    ⟨t, t.fintype_coe_sort, C, fun i => hK.inter_right is_closed_closure, fun i => ball (f ((i : K) : α)) W, fun i =>\n      is_open_ball _ hW₄, by simp [compact_open.gen, hfC], fun g hg x hx => hW₃ (mem_comp_rel.mpr _)⟩\n  simp only [mem_Inter, compact_open.gen, mem_set_of_eq, image_subset_iff] at hg\n  obtain ⟨y, hy⟩ := mem_Union.mp (hC hx)\n  exact ⟨f y, (mem_ball_symmetry hW₂).mp (hfC y hy), mem_preimage.mp (hg y hy)⟩\n#align Inter_compact_open_gen_subset_compact_conv_nhd Inter_compact_open_gen_subset_compact_conv_nhd\n\n"}