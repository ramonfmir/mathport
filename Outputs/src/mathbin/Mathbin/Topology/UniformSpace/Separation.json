{"uniformity_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem uniformity_quotient :\n    (uniformity) (quotient (separationSetoid α)) =\n      ((uniformity) α).map fun p : α × α => («expr⟦ ⟧» p.1, «expr⟦ ⟧» p.2) :=\n  rfl\n#align uniformity_quotient uniformity_quotient\n\n",
 "uniform_continuous_quotient_mk":
 "theorem uniform_continuous_quotient_mk : UniformContinuous (Quotient.mk' : α → quotient (separationSetoid α)) :=\n  le_rfl\n#align uniform_continuous_quotient_mk uniform_continuous_quotient_mk\n\n",
 "uniform_continuous_quotient_lift₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\ntheorem uniform_continuous_quotient_lift₂ {f : α → β → γ}\n    {h : ∀ a c b d, (a, b) ∈ (separation_rel) α → (c, d) ∈ (separation_rel) β → f a c = f b d}\n    (hf : UniformContinuous fun p : α × β => f p.1 p.2) :\n    UniformContinuous fun p : _ × _ => quotient.lift₂ f h p.1 p.2 :=\n  by\n  rw [UniformContinuous, uniformity_prod_eq_prod, uniformity_quotient, uniformity_quotient, Filter.prod_map_map_eq,\n    Filter.tendsto_map'_iff, Filter.tendsto_map'_iff]\n  rwa [UniformContinuous, uniformity_prod_eq_prod, Filter.tendsto_map'_iff] at hf\n#align uniform_continuous_quotient_lift₂ uniform_continuous_quotient_lift₂\n\n",
 "uniform_continuous_quotient_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\ntheorem uniform_continuous_quotient_lift {f : α → β} {h : ∀ a b, (a, b) ∈ (separation_rel) α → f a = f b}\n    (hf : UniformContinuous f) : UniformContinuous fun a => quotient.lift f h a :=\n  uniformContinuous_quotient hf\n#align uniform_continuous_quotient_lift uniform_continuous_quotient_lift\n\n",
 "uniform_continuous_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem uniform_continuous_quotient {f : quotient (separationSetoid α) → β}\n    (hf : UniformContinuous fun x => f («expr⟦ ⟧» x)) : UniformContinuous f :=\n  hf\n#align uniform_continuous_quotient uniform_continuous_quotient\n\n",
 "uniform_continuous_map":
 "theorem uniform_continuous_map (f : α → β) : UniformContinuous (map f) :=\n  uniformContinuous_lift (Quotient.mk' ∘ f)\n#align uniform_continuous_map uniform_continuous_map\n\n",
 "uniform_continuous_lift":
 "theorem uniform_continuous_lift [SeparatedSpace β] (f : α → β) : UniformContinuous (lift f) :=\n  by\n  by_cases hf : UniformContinuous f\n  · rw [lift, dif_pos hf]\n    exact uniform_continuous_quotient_lift hf\n  · rw [lift, dif_neg hf]\n    exact uniformContinuous_of_const fun a b => rfl\n#align uniform_continuous_lift uniform_continuous_lift\n\n",
 "separation_prod":
 "theorem separation_prod {a₁ a₂ : α} {b₁ b₂ : β} : (a₁, b₁) ≈ (a₂, b₂) ↔ a₁ ≈ a₂ ∧ b₁ ≈ b₂ :=\n  by\n  constructor\n  · intro h\n    exact\n      ⟨separated_of_uniform_continuous uniformContinuous_fst h, separated_of_uniform_continuous uniformContinuous_snd h⟩\n  · rintro ⟨eqv_α, eqv_β⟩ r r_in\n    rw [uniformity_prod] at r_in\n    rcases r_in with ⟨t_α, ⟨r_α, r_α_in, h_α⟩, t_β, ⟨r_β, r_β_in, h_β⟩, rfl⟩\n    let p_α := fun p : (α × β) × α × β => (p.1.1, p.2.1)\n    let p_β := fun p : (α × β) × α × β => (p.1.2, p.2.2)\n    have key_α : p_α ((a₁, b₁), (a₂, b₂)) ∈ r_α := by simp [p_α, eqv_α r_α r_α_in]\n    have key_β : p_β ((a₁, b₁), (a₂, b₂)) ∈ r_β := by simp [p_β, eqv_β r_β r_β_in]\n    exact ⟨h_α key_α, h_β key_β⟩\n#align separation_prod separation_prod\n\n",
 "separationRel_iff_specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n#print separationRel_iff_specializes /-\ntheorem separationRel_iff_specializes {a b : α} : (a, b) ∈ (separation_rel) α ↔ «expr ⤳ » a b := by\n  simp only [((uniformity) α).basis_sets.mem_separation_rel, id, mem_set_of_eq,\n    (nhds_basis_uniformity ((uniformity) α).basis_sets).specializes_iff]\n#align separation_rel_iff_specializes separationRel_iff_specializes\n-/\n\n",
 "separationRel_iff_inseparable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\n#print separationRel_iff_inseparable /-\ntheorem separationRel_iff_inseparable {a b : α} : (a, b) ∈ (separation_rel) α ↔ Inseparable a b :=\n  separationRel_iff_specializes.trans specializes_iff_inseparable\n#align separation_rel_iff_inseparable separationRel_iff_inseparable\n-/\n\n",
 "separationRel_eq_inter_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print separationRel_eq_inter_closure /-\ntheorem separationRel_eq_inter_closure : (separation_rel) α = «expr⋂₀ » («expr '' » closure ((uniformity) α).sets) := by\n  simp [uniformity_has_basis_closure.separation_rel]\n#align separation_rel_eq_inter_closure separationRel_eq_inter_closure\n-/\n\n",
 "separationRel_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\n#print separationRel_comap /-\ntheorem separationRel_comap {f : α → β} (h : ‹UniformSpace α› = UniformSpace.comap f ‹UniformSpace β›) :\n    (separation_rel) α = «expr ⁻¹' » (prod.map f f) ((separation_rel) β) :=\n  by\n  subst h\n  dsimp [separationRel]\n  simp_rw [uniformity_comap, (Filter.comap_hasBasis (prod.map f f) ((uniformity) β)).sInter_sets, ← preimage_Inter,\n    sInter_eq_bInter]\n  rfl\n#align separation_rel_comap separationRel_comap\n-/\n\n",
 "separationRel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print Filter.HasBasis.separationRel /-\nprotected theorem Filter.HasBasis.separationRel {ι : Sort _} {p : ι → Prop} {s : ι → Set (α × α)}\n    (h : HasBasis ((uniformity) α) p s) :\n    (separation_rel) α =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i) :=\n  by\n  unfold separationRel\n  rw [h.sInter_sets]\n#align filter.has_basis.separation_rel Filter.HasBasis.separationRel\n-/\n\n",
 "separated_of_uniform_continuous":
 "theorem separated_of_uniform_continuous {f : α → β} {x y : α} (H : UniformContinuous f) (h : x ≈ y) : f x ≈ f y :=\n  fun _ h' => h _ (H h')\n#align separated_of_uniform_continuous separated_of_uniform_continuous\n\n",
 "separated_iff_t2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\n#print separated_iff_t2 /-\ntheorem separated_iff_t2 : SeparatedSpace α ↔ T2Space α := by\n  classical\n    constructor <;> intro h\n    · rw [t2_iff_isClosed_diagonal, ← show (separation_rel) α = diagonal α from h.1]\n      exact isClosed_separationRel\n    · rw [separated_def']\n      intro x y hxy\n      rcases t2_separation hxy with ⟨u, v, uo, vo, hx, hy, h⟩\n      rcases isOpen_iff_ball_subset.1 uo x hx with ⟨r, hrU, hr⟩\n      exact ⟨r, hrU, fun H => h.le_bot ⟨hr H, hy⟩⟩\n#align separated_iff_t2 separated_iff_t2\n-/\n\n",
 "separated_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\n#print separated_equiv /-\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Patrick Massot\n-/\ntheorem separated_equiv : equivalence fun x y => (x, y) ∈ (separation_rel) α :=\n  ⟨fun x => fun s => refl_mem_uniformity, fun x y => fun h (s : Set (α × α)) hs =>\n    have : preimage Prod.swap s ∈ (uniformity) α := symm_le_uniformity hs\n    h _ this,\n    fun x y z (hxy : (x, y) ∈ (separation_rel) α) (hyz : (y, z) ∈ (separation_rel) α) s (hs : s ∈ (uniformity) α) =>\n    let ⟨t, ht, (h_ts : compRel t t ⊆ s)⟩ := comp_mem_uniformity_sets hs\n    h_ts <| show (x, z) ∈ compRel t t from ⟨y, hxy t ht, hyz t ht⟩⟩\n#align separated_equiv separated_equiv\n-/\n\n",
 "separated_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print separated_def' /-\ntheorem separated_def' {α : Type u} [UniformSpace α] :\n    SeparatedSpace α ↔ ∀ x y, x ≠ y → ∃ r ∈ (uniformity) α, (x, y) ∉ r :=\n  separated_def.trans <| forall₂_congr fun x y => by rw [← not_imp_not] <;> simp [not_forall]\n#align separated_def' separated_def'\n-/\n\n",
 "separated_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print separated_def /-\ntheorem separated_def {α : Type u} [UniformSpace α] :\n    SeparatedSpace α ↔ ∀ x y, (∀ r ∈ (uniformity) α, (x, y) ∈ r) → x = y := by\n  simp [separatedSpace_iff, idRel_subset.2 separated_equiv.1, subset.antisymm_iff] <;> simp [subset_def, separationRel]\n#align separated_def separated_def\n-/\n\n",
 "separatedSpace_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\n#print separatedSpace_iff /-\ntheorem separatedSpace_iff {α : Type u} [UniformSpace α] : SeparatedSpace α ↔ (separation_rel) α = idRel :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n#align separated_space_iff separatedSpace_iff\n-/\n\n",
 "mk_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem mk_eq_mk {x y : α} : («expr⟦ ⟧» x : SeparationQuotient α) = «expr⟦ ⟧» y ↔ Inseparable x y :=\n  Quotient.eq''.trans separationRel_iff_inseparable\n#align mk_eq_mk mk_eq_mk\n\n",
 "mem_separationRel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\n#print Filter.HasBasis.mem_separationRel /-\ntheorem Filter.HasBasis.mem_separationRel {ι : Sort _} {p : ι → Prop} {s : ι → Set (α × α)}\n    (h : ((uniformity) α).has_basis p s) {a : α × α} : a ∈ (separation_rel) α ↔ ∀ i, p i → a ∈ s i :=\n  h.forall_mem_mem\n#align filter.has_basis.mem_separation_rel Filter.HasBasis.mem_separationRel\n-/\n\n",
 "map_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem map_unique {f : α → β} (hf : UniformContinuous f) {g : SeparationQuotient α → SeparationQuotient β}\n    (comm : Quotient.mk' ∘ f = g ∘ Quotient.mk') : map f = g := by\n  ext ⟨a⟩ <;>\n    calc\n      map f («expr⟦ ⟧» a) = «expr⟦ ⟧» (f a) := map_mk hf a\n      _ = g («expr⟦ ⟧» a) := congr_fun comm a\n      \n#align map_unique map_unique\n\n",
 "map_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem map_mk {f : α → β} (h : UniformContinuous f) (a : α) : map f («expr⟦ ⟧» a) = «expr⟦ ⟧» (f a) := by\n  rw [map, lift_mk (uniform_continuous_quotient_mk.comp h)]\n#align map_mk map_mk\n\n",
 "map_id":
 "theorem map_id : map (@id α) = id :=\n  map_unique uniformContinuous_id rfl\n#align map_id map_id\n\n",
 "map_comp":
 "theorem map_comp {f : α → β} {g : β → γ} (hf : UniformContinuous f) (hg : UniformContinuous g) :\n    map g ∘ map f = map (g ∘ f) :=\n  (map_unique (hg.comp hf) <| by simp only [(· ∘ ·), map_mk, hf, hg]).symm\n#align map_comp map_comp\n\n",
 "lift_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem lift_mk [SeparatedSpace β] {f : α → β} (h : UniformContinuous f) (a : α) : lift f («expr⟦ ⟧» a) = f a := by\n  rw [lift, dif_pos h] <;> rfl\n#align lift_mk lift_mk\n\n",
 "isClosed_separationRel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\n#print isClosed_separationRel /-\ntheorem isClosed_separationRel : IsClosed ((separation_rel) α) :=\n  by\n  rw [separationRel_eq_inter_closure]\n  apply isClosed_interₛ\n  rintro _ ⟨t, t_in, rfl⟩\n  exact isClosed_closure\n#align is_closed_separation_rel isClosed_separationRel\n-/\n\n",
 "isClosed_range_of_spaced_out":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print isClosed_range_of_spaced_out /-\ntheorem isClosed_range_of_spaced_out {ι} [SeparatedSpace α] {V₀ : Set (α × α)} (V₀_in : V₀ ∈ (uniformity) α) {f : ι → α}\n    (hf : Pairwise fun x y => (f x, f y) ∉ V₀) : IsClosed (range f) :=\n  isClosed_of_spaced_out V₀_in <| by\n    rintro _ ⟨x, rfl⟩ _ ⟨y, rfl⟩ h\n    exact hf (ne_of_apply_ne f h)\n#align is_closed_range_of_spaced_out isClosed_range_of_spaced_out\n-/\n\n",
 "isClosed_of_spaced_out":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print isClosed_of_spaced_out /-\n-- see Note [lower instance priority]\ntheorem isClosed_of_spaced_out [SeparatedSpace α] {V₀ : Set (α × α)} (V₀_in : V₀ ∈ (uniformity) α) {s : Set α}\n    (hs : s.pairwise fun x y => (x, y) ∉ V₀) : IsClosed s :=\n  by\n  rcases comp_symm_mem_uniformity_sets V₀_in with ⟨V₁, V₁_in, V₁_symm, h_comp⟩\n  apply isClosed_of_closure_subset\n  intro x hx\n  rw [mem_closure_iff_ball] at hx\n  rcases hx V₁_in with ⟨y, hy, hy'⟩\n  suffices x = y by rwa [this]\n  apply eq_of_forall_symmetric\n  intro V V_in V_symm\n  rcases hx (inter_mem V₁_in V_in) with ⟨z, hz, hz'⟩\n  obtain rfl : z = y := by\n    by_contra hzy\n    exact hs hz' hy' hzy (h_comp <| mem_comp_of_mem_ball V₁_symm (ball_inter_left x _ _ hz) hy)\n  exact ball_inter_right x _ _ hz\n#align is_closed_of_spaced_out isClosed_of_spaced_out\n-/\n\n",
 "idRel_sub_separationRel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `separation_rel -/\n#print idRel_sub_separationRel /-\ntheorem idRel_sub_separationRel (α : Type _) [UniformSpace α] : idRel ⊆ (separation_rel) α :=\n  by\n  unfold separationRel\n  rw [idRel_subset]\n  intro x\n  suffices ∀ t ∈ (uniformity) α, (x, x) ∈ t by simpa only [refl_mem_uniformity]\n  exact fun t => refl_mem_uniformity\n#align id_rel_sub_separation_relation idRel_sub_separationRel\n-/\n\n",
 "eq_of_uniformity_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print eq_of_uniformity_basis /-\ntheorem eq_of_uniformity_basis {α : Type _} [UniformSpace α] [SeparatedSpace α] {ι : Type _} {p : ι → Prop}\n    {s : ι → Set (α × α)} (hs : ((uniformity) α).has_basis p s) {x y : α} (h : ∀ {i}, p i → (x, y) ∈ s i) : x = y :=\n  eq_of_uniformity fun V V_in =>\n    let ⟨i, hi, H⟩ := hs.mem_iff.mp V_in\n    H (h hi)\n#align eq_of_uniformity_basis eq_of_uniformity_basis\n-/\n\n",
 "eq_of_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print eq_of_uniformity /-\ntheorem eq_of_uniformity {α : Type _} [UniformSpace α] [SeparatedSpace α] {x y : α}\n    (h : ∀ {V}, V ∈ (uniformity) α → (x, y) ∈ V) : x = y :=\n  separated_def.mp ‹SeparatedSpace α› x y fun _ => h\n#align eq_of_uniformity eq_of_uniformity\n-/\n\n",
 "eq_of_separated_of_uniform_continuous":
 "theorem eq_of_separated_of_uniform_continuous [SeparatedSpace β] {f : α → β} {x y : α} (H : UniformContinuous f)\n    (h : x ≈ y) : f x = f y :=\n  separated_def.1 (by infer_instance) _ _ <| separated_of_uniformContinuous H h\n#align eq_of_separated_of_uniform_continuous eq_of_separated_of_uniform_continuous\n\n",
 "eq_of_forall_symmetric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print eq_of_forall_symmetric /-\ntheorem eq_of_forall_symmetric {α : Type _} [UniformSpace α] [SeparatedSpace α] {x y : α}\n    (h : ∀ {V}, V ∈ (uniformity) α → SymmetricRel V → (x, y) ∈ V) : x = y :=\n  eq_of_uniformity_basis hasBasis_symmetric (by simpa [and_imp] using fun _ => h)\n#align eq_of_forall_symmetric eq_of_forall_symmetric\n-/\n\n",
 "eq_of_clusterPt_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n#print eq_of_clusterPt_uniformity /-\ntheorem eq_of_clusterPt_uniformity [SeparatedSpace α] {x y : α} (h : ClusterPt (x, y) ((uniformity) α)) : x = y :=\n  eq_of_uniformity_basis uniformity_hasBasis_closed fun V ⟨hV, hVc⟩ =>\n    isClosed_iff_clusterPt.1 hVc _ <| h.mono <| le_principal_iff.2 hV\n#align eq_of_cluster_pt_uniformity eq_of_clusterPt_uniformity\n-/\n\n",
 "comap_quotient_le_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem comap_quotient_le_uniformity :\n    ((uniformity <| quotient <| separationSetoid α).comap fun p : α × α => («expr⟦ ⟧» p.fst, «expr⟦ ⟧» p.snd)) ≤\n      (uniformity) α :=\n  fun t' ht' =>\n  let ⟨t, ht, tt_t'⟩ := comp_mem_uniformity_sets ht'\n  let ⟨s, hs, ss_t⟩ := comp_mem_uniformity_sets ht\n  ⟨«expr '' » (fun p : α × α => («expr⟦ ⟧» p.1, «expr⟦ ⟧» p.2)) s,\n    ((uniformity) α).sets_of_superset hs fun x hx => ⟨x, hx, rfl⟩, fun ⟨a₁, a₂⟩ ⟨⟨b₁, b₂⟩, hb, ab_eq⟩ =>\n    have : «expr⟦ ⟧» b₁ = «expr⟦ ⟧» a₁ ∧ «expr⟦ ⟧» b₂ = «expr⟦ ⟧» a₂ := prod.mk.inj ab_eq\n    have : b₁ ≈ a₁ ∧ b₂ ≈ a₂ := and.imp quotient.exact quotient.exact this\n    have ab₁ : (a₁, b₁) ∈ t := (setoid.symm this.left) t ht\n    have ba₂ : (b₂, a₂) ∈ s := this.right s hs\n    tt_t' ⟨b₁, show ((a₁, a₂).1, b₁) ∈ t from ab₁, ss_t ⟨b₂, show ((b₁, a₂).1, b₂) ∈ s from hb, ba₂⟩⟩⟩\n#align comap_quotient_le_uniformity comap_quotient_le_uniformity\n\n",
 "comap_quotient_eq_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\ntheorem comap_quotient_eq_uniformity :\n    ((uniformity <| quotient <| separationSetoid α).comap fun p : α × α => («expr⟦ ⟧» p.fst, «expr⟦ ⟧» p.snd)) =\n      (uniformity) α :=\n  le_antisymm comap_quotient_le_uniformity le_comap_map\n#align comap_quotient_eq_uniformity comap_quotient_eq_uniformity\n\n"}