{"uniform_continuous_to_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n/-- If `𝔖` covers `α`, the natural map `uniform_on_fun.to_fun` from `α →ᵤ[𝔖] β` to `α → β` is\nuniformly continuous.\n\nIn other words, if `𝔖` covers `α`, then the uniform structure of `𝔖`-convergence is finer than\nthat of pointwise convergence. -/\nprotected theorem uniform_continuous_to_fun (h : ⋃₀ 𝔖 = univ) :\n    uniform_continuous (to_fun 𝔖 : «expr →ᵤ[ ] » α 𝔖 β → α → β) :=\n  by\n  rw [uniform_continuous_pi]\n  intro x\n  obtain ⟨s : set α, hs : s ∈ 𝔖, hxs : x ∈ s⟩ := sUnion_eq_univ_iff.mp h x\n  exact uniform_continuous_eval_of_mem β 𝔖 hxs hs\n#align uniform_continuous_to_fun uniform_continuous_to_fun\n\n",
 "uniform_continuous_restrict":
 "/-- If `S ∈ 𝔖`, then the restriction to `S` is a uniformly continuous map from `α →ᵤ[𝔖] β` to\n`↥S →ᵤ β`. -/\nprotected theorem uniform_continuous_restrict (h : s ∈ 𝔖) :\n    uniform_continuous (uniform_fun.of_fun ∘ (s.restrict : (α → β) → s → β) ∘ to_fun 𝔖) :=\n  by\n  change _ ≤ _\n  rw [uniform_on_fun.uniform_space, map_le_iff_le_comap, uniformity, infi_uniformity]\n  refine' infᵢ_le_of_le s _\n  rw [infi_uniformity]\n  exact infᵢ_le _ h\n#align uniform_continuous_restrict uniform_continuous_restrict\n\n",
 "uniform_continuous_eval_of_mem":
 "/-- If `x : α` is in some `S ∈ 𝔖`, then evaluation at `x` is uniformly continuous on\n`α →ᵤ[𝔖] β`. -/\ntheorem uniform_continuous_eval_of_mem {x : α} (hxs : x ∈ s) (hs : s ∈ 𝔖) :\n    uniform_continuous ((function.eval x : (α → β) → β) ∘ to_fun 𝔖) :=\n  (uniform_fun.uniform_continuous_eval β (⟨x, hxs⟩ : s)).comp (uniform_on_fun.uniform_continuous_restrict α β 𝔖 hs)\n#align uniform_continuous_eval_of_mem uniform_continuous_eval_of_mem\n\n",
 "uniform_continuous_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ » -/\n/-- Evaluation at a fixed point is uniformly continuous on `α →ᵤ β`. -/\ntheorem uniform_continuous_eval (x : α) : uniform_continuous (function.eval x ∘ to_fun : «expr →ᵤ » α β → β) :=\n  by\n  change _ ≤ _\n  rw [map_le_iff_le_comap, (uniform_fun.has_basis_uniformity α β).le_basis_iff (((uniformity) _).basis_sets.comap _)]\n  exact fun U hU => ⟨U, hU, fun uv huv => huv x⟩\n#align uniform_continuous_eval uniform_continuous_eval\n\n",
 "topological_space_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- The topology of `𝔖`-convergence is the infimum, for `S ∈ 𝔖`, of topology induced by the map\nof `S.restrict : (α →ᵤ[𝔖] β) → (↥S →ᵤ β)` of restriction to `S`, where `↥S →ᵤ β` is endowed with\nthe topology of uniform convergence. -/\nprotected theorem topological_space_eq :\n    uniform_on_fun.topological_space α β 𝔖 =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (topological_space.induced s.restrict (uniform_fun.topological_space s β)) :=\n  by\n  simp only [uniform_on_fun.topological_space, to_topological_space_infi, to_topological_space_infi,\n    to_topological_space_comap]\n  rfl\n#align topological_space_eq topological_space_eq\n\n",
 "tendsto_iff_tendsto_uniformly_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Convergence in the topology of `𝔖`-convergence means uniform convergence on `S` (in the sense\nof `tendsto_uniformly_on`) for all `S ∈ 𝔖`. -/\nprotected theorem tendsto_iff_tendsto_uniformly_on {F : ι → «expr →ᵤ[ ] » α 𝔖 β} {f : «expr →ᵤ[ ] » α 𝔖 β} :\n    tendsto F p ((nhds) f) ↔ ∀ s ∈ 𝔖, tendsto_uniformly_on F f p s :=\n  by\n  rw [uniform_on_fun.topological_space_eq, nhds_infi, tendsto_infi]\n  refine' forall_congr' fun s => _\n  rw [nhds_infi, tendsto_infi]\n  refine' forall_congr' fun hs => _\n  rw [nhds_induced, tendsto_comap_iff, tendsto_uniformly_on_iff_tendsto_uniformly_comp_coe,\n    uniform_fun.tendsto_iff_tendsto_uniformly]\n  rfl\n#align tendsto_iff_tendsto_uniformly_on tendsto_iff_tendsto_uniformly_on\n\n",
 "tendsto_iff_tendsto_uniformly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The topology of uniform convergence indeed gives the same notion of convergence as\n`tendsto_uniformly`. -/\nprotected theorem tendsto_iff_tendsto_uniformly {F : ι → «expr →ᵤ » α β} {f : «expr →ᵤ » α β} :\n    tendsto F p ((nhds) f) ↔ tendsto_uniformly F f p :=\n  by\n  rw [(uniform_fun.has_basis_nhds α β f).tendsto_right_iff, tendsto_uniformly]\n  exact iff.rfl\n#align tendsto_iff_tendsto_uniformly tendsto_iff_tendsto_uniformly\n\n",
 "t2_space_of_covering":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n/-- If `𝔖` covers `α`, then the topology of `𝔖`-convergence is T₂. -/\ntheorem t2_space_of_covering [t2_space β] (h : ⋃₀ 𝔖 = univ) : t2_space («expr →ᵤ[ ] » α 𝔖 β) :=\n  {\n    t2 := by\n      intro f g hfg\n      obtain ⟨x, hx⟩ := not_forall.mp (mt funext hfg)\n      obtain ⟨s, hs, hxs⟩ : ∃ s ∈ 𝔖, x ∈ s := mem_sUnion.mp (h.symm ▸ true.intro)\n      exact separated_by_continuous (uniform_continuous_eval_of_mem β 𝔖 hxs hs).continuous hx }\n#align t2_space_of_covering t2_space_of_covering\n\n",
 "precomp_uniform_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n/-- Let `f : γ → α`, `𝔖 : set (set α)`, `𝔗 : set (set γ)`, and assume that `∀ T ∈ 𝔗, f '' T ∈ 𝔖`.\nThen, the function `(λ g, g ∘ f) : (α →ᵤ[𝔖] β) → (γ →ᵤ[𝔗] β)` is uniformly continuous.\n\nNote that one can easily see that assuming `∀ T ∈ 𝔗, ∃ S ∈ 𝔖, f '' T ⊆ S` would work too, but\nwe will get this for free when we prove that `𝒱(α, β, 𝔖, uβ) = 𝒱(α, β, 𝔖', uβ)` where `𝔖'` is the\n***noncovering*** bornology generated by `𝔖`. -/\nprotected theorem precomp_uniform_continuous {𝔗 : set (set γ)} {f : γ → α} (hf : 𝔗 ⊆ «expr ⁻¹' » (image f) 𝔖) :\n    uniform_continuous fun g : «expr →ᵤ[ ] » α 𝔖 β => of_fun 𝔗 (g ∘ f) :=\n  by\n  -- Since `comap` distributes on `infi`, it suffices to prove that\n  -- `⨅ s ∈ 𝔖, comap s.restrict 𝒰(↥s, β, uβ) ≤ ⨅ t ∈ 𝔗, comap (t.restrict ∘ (— ∘ f)) 𝒰(↥t, β, uβ)`.\n  simp_rw [uniform_continuous_iff, uniform_on_fun.uniform_space, uniform_space.comap_infi, ← uniform_space.comap_comap]\n  -- For any `t ∈ 𝔗`, note `s := f '' t ∈ 𝔖`.\n  -- We will show that `comap s.restrict 𝒰(↥s, β, uβ) ≤ comap (t.restrict ∘ (— ∘ f)) 𝒰(↥t, β, uβ)`.\n  refine' le_infᵢ₂ fun t ht => infᵢ_le_of_le («expr '' » f t) <| infᵢ_le_of_le (hf ht) _\n  -- Let `f'` be the map from `t` to `f '' t` induced by `f`.\n  let f' : t → «expr '' » f t := (maps_to_image f t).restrict f t («expr '' » f t)\n  -- By definition `t.restrict ∘ (— ∘ f) = (— ∘ f') ∘ (f '' t).restrict`.\n  have :\n    (t.restrict ∘ fun g : «expr →ᵤ[ ] » α 𝔖 β => of_fun 𝔗 (g ∘ f)) =\n      (fun g : «expr '' » f t → β => g ∘ f') ∘ («expr '' » f t).restrict :=\n    rfl\n  -- Thus, we have to show `comap (f '' t).restrict 𝒰(↥(f '' t), β, uβ) ≤`\n  -- `comap (f '' t).restrict (comap (— ∘ f') 𝒰(↥t, β, uβ))`.\n  rw [this, @uniform_space.comap_comap («expr →ᵤ[ ] » α 𝔖 β) («expr →ᵤ » («expr '' » f t) β)]\n  -- But this is exactly monotonicity of `comap` applied to\n  -- `uniform_convergence.precomp_continuous`.\n  refine' uniform_space.comap_mono _\n  rw [← uniform_continuous_iff]\n  exact uniform_fun.precomp_uniform_continuous\n#align precomp_uniform_continuous precomp_uniform_continuous\n\n",
 "postcomp_uniform_inducing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Post-composition by a uniform inducing is a uniform inducing for the\nuniform structures of `𝔖`-convergence.\n\nMore precisely, if `f : γ → β` is a uniform inducing, then\n`(λ g, f ∘ g) : (α →ᵤ[𝔖] γ) → (α →ᵤ[𝔖] β)` is a uniform inducing. -/\nprotected theorem postcomp_uniform_inducing [uniform_space γ] {f : γ → β} (hf : uniform_inducing f) :\n    uniform_inducing (of_fun 𝔖 ∘ (· ∘ ·) f ∘ to_fun 𝔖) :=\n  by\n  -- This is a direct consequence of `uniform_convergence.comap_eq`\n  constructor\n  replace hf : ((uniformity) β).comap (prod.map f f) = _ := hf.comap_uniformity\n  change comap (prod.map (of_fun 𝔖 ∘ (· ∘ ·) f ∘ to_fun 𝔖) (of_fun 𝔖 ∘ (· ∘ ·) f ∘ to_fun 𝔖)) _ = _\n  rw [← uniformity_comap rfl] at hf⊢\n  congr\n  rw [← uniform_space_eq hf, uniform_on_fun.comap_eq]\n  rfl\n#align postcomp_uniform_inducing postcomp_uniform_inducing\n\n",
 "postcomp_uniform_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝒱( , , , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝒱( , , , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝒱( , , , )» -/\n-- by definition, `∀ S ∈ 𝔖, (f ∘ —) ∘ S.restrict = S.restrict ∘ (f ∘ —)`.\n/-- Post-composition by a uniformly continuous function is uniformly continuous for the\nuniform structures of `𝔖`-convergence.\n\nMore precisely, if `f : γ → β` is uniformly continuous, then\n`(λ g, f ∘ g) : (α →ᵤ[𝔖] γ) → (α →ᵤ[𝔖] β)` is uniformly continuous. -/\nprotected theorem postcomp_uniform_continuous [uniform_space γ] {f : γ → β} (hf : uniform_continuous f) :\n    uniform_continuous (of_fun 𝔖 ∘ (· ∘ ·) f ∘ to_fun 𝔖) :=\n  by\n  -- This is a direct consequence of `uniform_convergence.comap_eq`\n  rw [uniform_continuous_iff]\n  calc\n    «expr𝒱( , , , )» α γ 𝔖 _ ≤ «expr𝒱( , , , )» α γ 𝔖 (‹uniform_space β›.comap f) :=\n      uniform_on_fun.mono (uniform_continuous_iff.mp hf) subset_rfl\n    _ = («expr𝒱( , , , )» α β 𝔖 _).comap ((· ∘ ·) f) := uniform_on_fun.comap_eq\n    \n#align postcomp_uniform_continuous postcomp_uniform_continuous\n\n",
 "mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝒱( , , , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝒱( , , , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝒱( , , , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝒱( , , , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝒱( , , , )» -/\n/-- Let `u₁`, `u₂` be two uniform structures on `γ` and `𝔖₁ 𝔖₂ : set (set α)`. If `u₁ ≤ u₂` and\n`𝔖₂ ⊆ 𝔖₁` then `𝒱(α, γ, 𝔖₁, u₁) ≤ 𝒱(α, γ, 𝔖₂, u₂)`. -/\nprotected theorem mono ⦃u₁ u₂ : uniform_space γ⦄ (hu : u₁ ≤ u₂) ⦃𝔖₁ 𝔖₂ : set (set α)⦄ (h𝔖 : 𝔖₂ ⊆ 𝔖₁) :\n    «expr𝒱( , , , )» α γ 𝔖₁ u₁ ≤ «expr𝒱( , , , )» α γ 𝔖₂ u₂ :=\n  calc\n    «expr𝒱( , , , )» α γ 𝔖₁ u₁ ≤ «expr𝒱( , , , )» α γ 𝔖₂ u₁ := infᵢ_le_infᵢ_of_subset h𝔖\n    _ ≤ «expr𝒱( , , , )» α γ 𝔖₂ u₂ := infᵢ₂_mono fun i hi => uniform_space.comap_mono <| uniform_fun.mono hu\n    \n#align mono mono\n\n",
 "is_basis_gen":
 "/-- If `𝔖 : set (set α)` is nonempty and directed and `𝓑` is a filter basis on `β × β`, then the\nfamily `uniform_on_fun.gen 𝔖 S V` for `S ∈ 𝔖` and `V ∈ 𝓑` is a filter basis on\n`(α →ᵤ[𝔖] β) × (α →ᵤ[𝔖] β)`.\nWe will show in `has_basis_uniformity_of_basis` that, if `𝓑` is a basis for `𝓤 β`, then the\ncorresponding filter is the uniformity of `α →ᵤ[𝔖] β`. -/\nprotected theorem is_basis_gen (𝔖 : set (set α)) (h : 𝔖.nonempty) (h' : DirectedOn (· ⊆ ·) 𝔖)\n    (𝓑 : filter_basis <| β × β) :\n    is_basis (fun SV : set α × set (β × β) => SV.1 ∈ 𝔖 ∧ SV.2 ∈ 𝓑) fun SV => uniform_on_fun.gen 𝔖 SV.1 SV.2 :=\n  ⟨h.prod 𝓑.nonempty, fun U₁V₁ U₂V₂ h₁ h₂ =>\n    let ⟨U₃, hU₃, hU₁₃, hU₂₃⟩ := h' U₁V₁.1 h₁.1 U₂V₂.1 h₂.1\n    let ⟨V₃, hV₃, hV₁₂₃⟩ := 𝓑.inter_sets h₁.2 h₂.2\n    ⟨⟨U₃, V₃⟩,\n      ⟨⟨hU₃, hV₃⟩, fun uv huv =>\n        ⟨fun x hx => (hV₁₂₃ <| huv x <| hU₁₃ hx).1, fun x hx => (hV₁₂₃ <| huv x <| hU₂₃ hx).2⟩⟩⟩⟩\n#align is_basis_gen is_basis_gen\n\n",
 "infi_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝒱( , , , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝒱( , , , )» -/\n/-- If `u` is a family of uniform structures on `γ`, then\n`𝒱(α, γ, 𝔖, (⨅ i, u i)) = ⨅ i, 𝒱(α, γ, 𝔖, u i)`. -/\nprotected theorem infi_eq {u : ι → uniform_space γ} :\n    «expr𝒱( , , , )» α γ 𝔖\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr𝒱( , , , )» α γ 𝔖 (u i)) :=\n  by\n  simp_rw [uniform_on_fun.uniform_space, uniform_fun.infi_eq, uniform_space.comap_infi]\n  rw [infᵢ_comm]\n  exact infᵢ_congr fun s => infᵢ_comm\n#align infi_eq infi_eq\n\n",
 "inf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝒱( , , , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝒱( , , , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝒱( , , , )» -/\n/-- If `u₁` and `u₂` are two uniform structures on `γ`, then\n`𝒱(α, γ, 𝔖, u₁ ⊓ u₂) = 𝒱(α, γ, 𝔖, u₁) ⊓ 𝒱(α, γ, 𝔖, u₂)`. -/\nprotected theorem inf_eq {u₁ u₂ : uniform_space γ} :\n    «expr𝒱( , , , )» α γ 𝔖 («expr ⊓ » u₁ u₂) = «expr ⊓ » («expr𝒱( , , , )» α γ 𝔖 u₁) («expr𝒱( , , , )» α γ 𝔖 u₂) :=\n  by\n  rw [inf_eq_infᵢ, inf_eq_infᵢ, uniform_on_fun.infi_eq]\n  refine' infᵢ_congr fun i => _\n  cases i <;> rfl\n#align inf_eq inf_eq\n\n",
 "has_basis_uniformity_of_basis_aux₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹'o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ » -/\nprotected theorem has_basis_uniformity_of_basis_aux₂ (h : DirectedOn (· ⊆ ·) 𝔖) {p : ι → Prop} {s : ι → set (β × β)}\n    (hb : has_basis ((uniformity) β) p s) :\n    DirectedOn\n      («expr ⁻¹'o »\n        (fun s : set α => (uniform_fun.uniform_space s β).comap (s.restrict : «expr →ᵤ » α β → «expr →ᵤ » s β)) GE.ge)\n      𝔖 :=\n  h.mono fun s t hst =>\n    ((uniform_on_fun.has_basis_uniformity_of_basis_aux₁ α β 𝔖 hb _).le_basis_iff\n          (uniform_on_fun.has_basis_uniformity_of_basis_aux₁ α β 𝔖 hb _)).mpr\n      fun V hV => ⟨V, hV, uniform_on_fun.gen_mono hst subset_rfl⟩\n#align has_basis_uniformity_of_basis_aux₂ has_basis_uniformity_of_basis_aux₂\n\n",
 "has_basis_uniformity_of_basis_aux₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\nprotected theorem has_basis_uniformity_of_basis_aux₁ {p : ι → Prop} {s : ι → set (β × β)}\n    (hb : has_basis ((uniformity) β) p s) (S : set α) :\n    (@uniformity («expr →ᵤ[ ] » α 𝔖 β) ((uniform_fun.uniform_space S β).comap S.restrict)).has_basis p fun i =>\n      uniform_on_fun.gen 𝔖 S (s i) :=\n  by\n  simp_rw [uniform_on_fun.gen_eq_preimage_restrict, uniformity_comap rfl]\n  exact (uniform_fun.has_basis_uniformity_of_basis S β hb).comap _\n#align has_basis_uniformity_of_basis_aux₁ has_basis_uniformity_of_basis_aux₁\n\n",
 "has_basis_uniformity_of_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n/-- If `𝔖 : set (set α)` is nonempty and directed and `𝓑` is a filter basis of `𝓤 β`, then the\nuniformity of `α →ᵤ[𝔖] β` admits the family `{(f, g) | ∀ x ∈ S, (f x, g x) ∈ V}` for `S ∈ 𝔖` and\n`V ∈ 𝓑` as a filter basis. -/\nprotected theorem has_basis_uniformity_of_basis (h : 𝔖.nonempty) (h' : DirectedOn (· ⊆ ·) 𝔖) {p : ι → Prop}\n    {s : ι → set (β × β)} (hb : has_basis ((uniformity) β) p s) :\n    ((uniformity) («expr →ᵤ[ ] » α 𝔖 β)).has_basis (fun Si : set α × ι => Si.1 ∈ 𝔖 ∧ p Si.2) fun Si =>\n      uniform_on_fun.gen 𝔖 Si.1 (s Si.2) :=\n  by\n  simp only [infi_uniformity']\n  exact\n    has_basis_binfi_of_directed h (fun S => uniform_on_fun.gen 𝔖 S ∘ s) _\n      (fun S hS => uniform_on_fun.has_basis_uniformity_of_basis_aux₁ α β 𝔖 hb S)\n      (uniform_on_fun.has_basis_uniformity_of_basis_aux₂ α β 𝔖 h' hb)\n#align has_basis_uniformity_of_basis has_basis_uniformity_of_basis\n\n",
 "has_basis_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- If `𝔖 : set (set α)` is nonempty and directed, then the uniformity of `α →ᵤ[𝔖] β` admits the\nfamily `{(f, g) | ∀ x ∈ S, (f x, g x) ∈ V}` for `S ∈ 𝔖` and `V ∈ 𝓤 β` as a filter basis. -/\nprotected theorem has_basis_uniformity (h : 𝔖.nonempty) (h' : DirectedOn (· ⊆ ·) 𝔖) :\n    ((uniformity) («expr →ᵤ[ ] » α 𝔖 β)).has_basis (fun SV : set α × set (β × β) => SV.1 ∈ 𝔖 ∧ SV.2 ∈ (uniformity) β)\n      fun SV => uniform_on_fun.gen 𝔖 SV.1 SV.2 :=\n  uniform_on_fun.has_basis_uniformity_of_basis α β 𝔖 h h' ((uniformity) β).basis_sets\n#align has_basis_uniformity has_basis_uniformity\n\n",
 "has_basis_nhds_of_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- For `f : α →ᵤ[𝔖] β`, where `𝔖 : set (set α)` is nonempty and directed, `𝓝 f` admits the\nfamily `{g | ∀ x ∈ S, (f x, g x) ∈ V}` for `S ∈ 𝔖` and `V ∈ 𝓑` as a filter basis, for any basis\n`𝓑` of `𝓤 β`. -/\nprotected theorem has_basis_nhds_of_basis (f : «expr →ᵤ[ ] » α 𝔖 β) (h : 𝔖.nonempty) (h' : DirectedOn (· ⊆ ·) 𝔖)\n    {p : ι → Prop} {s : ι → set (β × β)} (hb : has_basis ((uniformity) β) p s) :\n    ((nhds) f).has_basis (fun Si : set α × ι => Si.1 ∈ 𝔖 ∧ p Si.2) fun Si =>\n      { g | (g, f) ∈ uniform_on_fun.gen 𝔖 Si.1 (s Si.2) } :=\n  letI : uniform_space (α → β) := uniform_on_fun.uniform_space α β 𝔖\n  nhds_basis_uniformity (uniform_on_fun.has_basis_uniformity_of_basis α β 𝔖 h h' hb)\n#align has_basis_nhds_of_basis has_basis_nhds_of_basis\n\n",
 "has_basis_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- For `f : α →ᵤ[𝔖] β`, where `𝔖 : set (set α)` is nonempty and directed, `𝓝 f` admits the\nfamily `{g | ∀ x ∈ S, (f x, g x) ∈ V}` for `S ∈ 𝔖` and `V ∈ 𝓤 β` as a filter basis. -/\nprotected theorem has_basis_nhds (f : «expr →ᵤ[ ] » α 𝔖 β) (h : 𝔖.nonempty) (h' : DirectedOn (· ⊆ ·) 𝔖) :\n    ((nhds) f).has_basis (fun SV : set α × set (β × β) => SV.1 ∈ 𝔖 ∧ SV.2 ∈ (uniformity) β) fun SV =>\n      { g | (g, f) ∈ uniform_on_fun.gen 𝔖 SV.1 SV.2 } :=\n  uniform_on_fun.has_basis_nhds_of_basis α β 𝔖 f h h' (filter.basis_sets _)\n#align has_basis_nhds has_basis_nhds\n\n",
 "gen_mono":
 "/-- `uniform_on_fun.gen` is antitone in the first argument and monotone in the second. -/\nprotected theorem gen_mono {𝔖} {S S' : set α} {V V' : set (β × β)} (hS : S' ⊆ S) (hV : V ⊆ V') :\n    uniform_on_fun.gen 𝔖 S V ⊆ uniform_on_fun.gen 𝔖 S' V' := fun uv h x hx => hV (h x <| hS hx)\n#align gen_mono gen_mono\n\n",
 "gen_eq_preimage_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n-- Denote `φ` this bijection. We want to show that\n-- `comap φ (𝒰(α, β, uβ) × 𝒰(α, γ, uγ)) = 𝒰(α, β × γ, uβ × uγ)`.\n-- But `uβ × uγ` is defined as `comap fst uβ ⊓ comap snd uγ`, so we just have to apply\n-- `uniform_convergence.inf_eq` and `uniform_convergence.comap_eq`, which leaves us to check\n-- that some square commutes.\n-- the relevant diagram commutes by definition\n-- Denote `φ` this bijection. We want to show that\n-- `comap φ (Π i, 𝒰(α, δ i, uδ i)) = 𝒰(α, (Π i, δ i), (Π i, uδ i))`.\n-- But `Π i, uδ i` is defined as `⨅ i, comap (eval i) (uδ i)`, so we just have to apply\n-- `uniform_convergence.infi_eq` and `uniform_convergence.comap_eq`, which leaves us to check\n-- that some square commutes.\n-- Like in the previous lemma, the diagram actually commutes by definition\n/-- For `S : set α` and `V : set (β × β)`, we have\n`uniform_on_fun.gen 𝔖 S V = (S.restrict × S.restrict) ⁻¹' (uniform_fun.gen S β V)`.\nThis is the crucial fact for proving that the family `uniform_on_fun.gen S V` for `S ∈ 𝔖` and\n`V ∈ 𝓤 β` is indeed a basis for the uniformity `α →ᵤ[𝔖] β` endowed with `𝒱(α, β, 𝔖, uβ)`\nthe uniform structure of `𝔖`-convergence, as defined in `uniform_on_fun.uniform_space`. -/\nprotected theorem gen_eq_preimage_restrict {𝔖} (S : set α) (V : set (β × β)) :\n    uniform_on_fun.gen 𝔖 S V = «expr ⁻¹' » (prod.map S.restrict S.restrict) (uniform_fun.gen S β V) :=\n  by\n  ext uv\n  exact ⟨fun h ⟨x, hx⟩ => h x hx, fun h x hx => h ⟨x, hx⟩⟩\n#align gen_eq_preimage_restrict gen_eq_preimage_restrict\n\n",
 "gc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprlower_adjoint -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprlower_adjoint -/\n/- This is a lower adjoint to `uniform_convergence.filter` (see `uniform_convergence.gc`).\nThe exact definition of the lower adjoint `l` is not interesting; we will only use that it exists\n(in `uniform_convergence.mono` and `uniform_convergence.infi_eq`) and that\n`l (filter.map (prod.map f f) 𝓕) = filter.map (prod.map ((∘) f) ((∘) f)) (l 𝓕)` for each\n`𝓕 : filter (γ × γ)` and `f : γ → α` (in `uniform_convergence.comap_eq`). -/\n/-- The function `uniform_convergence.filter α β : filter (β × β) → filter ((α →ᵤ β) × (α →ᵤ β))`\nhas a lower adjoint `l` (in the sense of `galois_connection`). The exact definition of `l` is not\ninteresting; we will only use that it exists (in `uniform_convergence.mono` and\n`uniform_convergence.infi_eq`) and that\n`l (filter.map (prod.map f f) 𝓕) = filter.map (prod.map ((∘) f) ((∘) f)) (l 𝓕)` for each\n`𝓕 : filter (γ × γ)` and `f : γ → α` (in `uniform_convergence.comap_eq`). -/\nprotected theorem gc : GaloisConnection (exprlower_adjoint) fun 𝓕 => uniform_fun.filter α β 𝓕 :=\n  by\n  intro 𝓐 𝓕\n  symm\n  calc\n    𝓐 ≤ uniform_fun.filter α β 𝓕 ↔ (uniform_fun.basis α β 𝓕).sets ⊆ 𝓐.sets := by\n      rw [uniform_fun.filter, ← filter_basis.generate, sets_iff_generate]\n    _ ↔ ∀ U ∈ 𝓕, uniform_fun.gen α β U ∈ 𝓐 := image_subset_iff\n    _ ↔\n        ∀ U ∈ 𝓕,\n          { uv | ∀ x, (uv, x) ∈ { t : («expr →ᵤ » α β × «expr →ᵤ » α β) × α | (t.1.1 t.2, t.1.2 t.2) ∈ U } } ∈ 𝓐 :=\n      iff.rfl\n    _ ↔\n        ∀ U ∈ 𝓕,\n          { uvx : («expr →ᵤ » α β × «expr →ᵤ » α β) × α | (uvx.1.1 uvx.2, uvx.1.2 uvx.2) ∈ U } ∈\n            filter.prod 𝓐 («expr⊤» : filter α) :=\n      forall₂_congr fun U hU => mem_prod_top.symm\n    _ ↔ (exprlower_adjoint) 𝓐 ≤ 𝓕 := iff.rfl\n    \n#align gc gc\n\n",
 "comap_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝒱( , , , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝒱( , , , )» -/\n/-- If `u` is a uniform structures on `β` and `f : γ → β`, then\n`𝒱(α, γ, 𝔖, comap f u) = comap (λ g, f ∘ g) 𝒱(α, γ, 𝔖, u₁)`. -/\nprotected theorem comap_eq {f : γ → β} :\n    «expr𝒱( , , , )» α γ 𝔖 (‹uniform_space β›.comap f) = («expr𝒱( , , , )» α β 𝔖 _).comap ((· ∘ ·) f) :=\n  by\n  -- We reduce this to `uniform_convergence.comap_eq` using the fact that `comap` distributes\n  -- on `infi`.\n  simp_rw [uniform_on_fun.uniform_space, uniform_space.comap_infi, uniform_fun.comap_eq, ← uniform_space.comap_comap]\n  rfl\n#align comap_eq comap_eq\n\n"}