{"uniform_continuous_to_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n/-- If `ğ”–` covers `Î±`, the natural map `uniform_on_fun.to_fun` from `Î± â†’áµ¤[ğ”–] Î²` to `Î± â†’ Î²` is\nuniformly continuous.\n\nIn other words, if `ğ”–` covers `Î±`, then the uniform structure of `ğ”–`-convergence is finer than\nthat of pointwise convergence. -/\nprotected theorem uniform_continuous_to_fun (h : â‹ƒâ‚€ ğ”– = univ) :\n    UniformContinuous (toFun ğ”– : Â«expr â†’áµ¤[ ] Â» Î± ğ”– Î² â†’ Î± â†’ Î²) :=\n  by\n  rw [uniformContinuous_pi]\n  intro x\n  obtain âŸ¨s : Set Î±, hs : s âˆˆ ğ”–, hxs : x âˆˆ sâŸ© := sUnion_eq_univ_iff.mp h x\n  exact uniform_continuous_eval_of_mem Î² ğ”– hxs hs\n#align uniform_continuous_to_fun uniform_continuous_to_fun\n\n",
 "uniform_continuous_restrict":
 "/-- If `S âˆˆ ğ”–`, then the restriction to `S` is a uniformly continuous map from `Î± â†’áµ¤[ğ”–] Î²` to\n`â†¥S â†’áµ¤ Î²`. -/\nprotected theorem uniform_continuous_restrict (h : s âˆˆ ğ”–) :\n    UniformContinuous (UniformFun.ofFun âˆ˜ (s.restrict : (Î± â†’ Î²) â†’ s â†’ Î²) âˆ˜ toFun ğ”–) :=\n  by\n  change _ â‰¤ _\n  simp only [uniform_on_fun.uniform_space, map_le_iff_le_comap, infáµ¢_uniformity]\n  exact infáµ¢â‚‚_le s h\n#align uniform_continuous_restrict uniform_continuous_restrict\n\n",
 "uniform_continuous_eval_of_mem":
 "/-- If `x : Î±` is in some `S âˆˆ ğ”–`, then evaluation at `x` is uniformly continuous on\n`Î± â†’áµ¤[ğ”–] Î²`. -/\ntheorem uniform_continuous_eval_of_mem {x : Î±} (hxs : x âˆˆ s) (hs : s âˆˆ ğ”–) :\n    UniformContinuous ((Function.eval x : (Î± â†’ Î²) â†’ Î²) âˆ˜ toFun ğ”–) :=\n  (UniformFun.uniformContinuous_eval Î² (âŸ¨x, hxsâŸ© : s)).comp (UniformOnFun.uniformContinuous_restrict Î± Î² ğ”– hs)\n#align uniform_continuous_eval_of_mem uniform_continuous_eval_of_mem\n\n",
 "uniform_continuous_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤ Â» -/\n/-- Evaluation at a fixed point is uniformly continuous on `Î± â†’áµ¤ Î²`. -/\ntheorem uniform_continuous_eval (x : Î±) : UniformContinuous (Function.eval x âˆ˜ toFun : Â«expr â†’áµ¤ Â» Î± Î² â†’ Î²) :=\n  by\n  change _ â‰¤ _\n  rw [map_le_iff_le_comap, (UniformFun.hasBasis_uniformity Î± Î²).le_basis_iff (((uniformity) _).basis_sets.comap _)]\n  exact fun U hU => âŸ¨U, hU, fun uv huv => huv xâŸ©\n#align uniform_continuous_eval uniform_continuous_eval\n\n",
 "topologicalSpace_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n#print topologicalSpace_eq /-\n/-- The topology of `ğ”–`-convergence is the infimum, for `S âˆˆ ğ”–`, of topology induced by the map\nof `S.restrict : (Î± â†’áµ¤[ğ”–] Î²) â†’ (â†¥S â†’áµ¤ Î²)` of restriction to `S`, where `â†¥S â†’áµ¤ Î²` is endowed with\nthe topology of uniform convergence. -/\nprotected theorem topologicalSpace_eq :\n    uniform_on_fun.topological_space Î± Î² ğ”– =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        (TopologicalSpace.induced s.restrict (uniform_fun.topological_space s Î²)) :=\n  by\n  simp only [uniform_on_fun.topological_space, toTopologicalSpace_infáµ¢, toTopologicalSpace_infáµ¢,\n    toTopologicalSpace_comap]\n  rfl\n#align topological_space_eq topologicalSpace_eq\n-/\n\n",
 "tendsto_iff_tendsto_uniformly_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Convergence in the topology of `ğ”–`-convergence means uniform convergence on `S` (in the sense\nof `tendsto_uniformly_on`) for all `S âˆˆ ğ”–`. -/\nprotected theorem tendsto_iff_tendsto_uniformly_on {F : Î¹ â†’ Â«expr â†’áµ¤[ ] Â» Î± ğ”– Î²} {f : Â«expr â†’áµ¤[ ] Â» Î± ğ”– Î²} :\n    Tendsto F p ((nhds) f) â†” âˆ€ s âˆˆ ğ”–, TendstoUniformlyOn F f p s :=\n  by\n  rw [UniformOnFun.topologicalSpace_eq, nhds_infáµ¢, tendsto_infi]\n  refine' forall_congr' fun s => _\n  rw [nhds_infáµ¢, tendsto_infi]\n  refine' forall_congr' fun hs => _\n  rw [nhds_induced, tendsto_comap_iff, tendstoUniformlyOn_iff_tendstoUniformly_comp_coe,\n    UniformFun.tendsto_iff_tendstoUniformly]\n  rfl\n#align tendsto_iff_tendsto_uniformly_on tendsto_iff_tendsto_uniformly_on\n\n",
 "tendsto_iff_tendsto_uniformly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The topology of uniform convergence indeed gives the same notion of convergence as\n`tendsto_uniformly`. -/\nprotected theorem tendsto_iff_tendsto_uniformly {F : Î¹ â†’ Â«expr â†’áµ¤ Â» Î± Î²} {f : Â«expr â†’áµ¤ Â» Î± Î²} :\n    Tendsto F p ((nhds) f) â†” TendstoUniformly F f p :=\n  by\n  rw [(UniformFun.hasBasis_nhds Î± Î² f).tendsto_right_iff, TendstoUniformly]\n  exact iff.rfl\n#align tendsto_iff_tendsto_uniformly tendsto_iff_tendsto_uniformly\n\n",
 "t2_space_of_covering":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n/-- If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. -/\ntheorem t2_space_of_covering [T2Space Î²] (h : â‹ƒâ‚€ ğ”– = univ) : T2Space (Â«expr â†’áµ¤[ ] Â» Î± ğ”– Î²) :=\n  {\n    t2 := by\n      intro f g hfg\n      obtain âŸ¨x, hxâŸ© := not_forall.mp (mt funext hfg)\n      obtain âŸ¨s, hs, hxsâŸ© : âˆƒ s âˆˆ ğ”–, x âˆˆ s := mem_sUnion.mp (h.symm â–¸ true.intro)\n      exact separated_by_continuous (uniform_continuous_eval_of_mem Î² ğ”– hxs hs).continuous hx }\n#align t2_space_of_covering t2_space_of_covering\n\n",
 "precomp_uniform_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n/-- Let `f : Î³ â†’ Î±`, `ğ”– : set (set Î±)`, `ğ”— : set (set Î³)`, and assume that `âˆ€ T âˆˆ ğ”—, f '' T âˆˆ ğ”–`.\nThen, the function `(Î» g, g âˆ˜ f) : (Î± â†’áµ¤[ğ”–] Î²) â†’ (Î³ â†’áµ¤[ğ”—] Î²)` is uniformly continuous.\n\nNote that one can easily see that assuming `âˆ€ T âˆˆ ğ”—, âˆƒ S âˆˆ ğ”–, f '' T âŠ† S` would work too, but\nwe will get this for free when we prove that `ğ’±(Î±, Î², ğ”–, uÎ²) = ğ’±(Î±, Î², ğ”–', uÎ²)` where `ğ”–'` is the\n***noncovering*** bornology generated by `ğ”–`. -/\nprotected theorem precomp_uniform_continuous {ğ”— : Set (Set Î³)} {f : Î³ â†’ Î±} (hf : ğ”— âŠ† Â«expr â»Â¹' Â» (image f) ğ”–) :\n    UniformContinuous fun g : Â«expr â†’áµ¤[ ] Â» Î± ğ”– Î² => ofFun ğ”— (g âˆ˜ f) :=\n  by\n  -- Since `comap` distributes on `infi`, it suffices to prove that\n  -- `â¨… s âˆˆ ğ”–, comap s.restrict ğ’°(â†¥s, Î², uÎ²) â‰¤ â¨… t âˆˆ ğ”—, comap (t.restrict âˆ˜ (â€” âˆ˜ f)) ğ’°(â†¥t, Î², uÎ²)`.\n  simp_rw [uniformContinuous_iff, uniform_on_fun.uniform_space, UniformSpace.comap_infáµ¢, â† UniformSpace.comap_comap]\n  -- For any `t âˆˆ ğ”—`, note `s := f '' t âˆˆ ğ”–`.\n  -- We will show that `comap s.restrict ğ’°(â†¥s, Î², uÎ²) â‰¤ comap (t.restrict âˆ˜ (â€” âˆ˜ f)) ğ’°(â†¥t, Î², uÎ²)`.\n  refine' le_infáµ¢â‚‚ fun t ht => infáµ¢_le_of_le (Â«expr '' Â» f t) <| infáµ¢_le_of_le (hf ht) _\n  -- Let `f'` be the map from `t` to `f '' t` induced by `f`.\n  let f' : t â†’ Â«expr '' Â» f t := (maps_to_image f t).restrict f t (Â«expr '' Â» f t)\n  -- By definition `t.restrict âˆ˜ (â€” âˆ˜ f) = (â€” âˆ˜ f') âˆ˜ (f '' t).restrict`.\n  have :\n    (t.restrict âˆ˜ fun g : Â«expr â†’áµ¤[ ] Â» Î± ğ”– Î² => of_fun ğ”— (g âˆ˜ f)) =\n      (fun g : Â«expr '' Â» f t â†’ Î² => g âˆ˜ f') âˆ˜ (Â«expr '' Â» f t).restrict :=\n    rfl\n  -- Thus, we have to show `comap (f '' t).restrict ğ’°(â†¥(f '' t), Î², uÎ²) â‰¤`\n  -- `comap (f '' t).restrict (comap (â€” âˆ˜ f') ğ’°(â†¥t, Î², uÎ²))`.\n  rw [this, @UniformSpace.comap_comap (Â«expr â†’áµ¤[ ] Â» Î± ğ”– Î²) (Â«expr â†’áµ¤ Â» (Â«expr '' Â» f t) Î²)]\n  -- But this is exactly monotonicity of `comap` applied to\n  -- `uniform_convergence.precomp_continuous`.\n  refine' UniformSpace.comap_mono _\n  rw [â† uniformContinuous_iff]\n  exact UniformFun.precomp_uniformContinuous\n#align precomp_uniform_continuous precomp_uniform_continuous\n\n",
 "postcomp_uniform_inducing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- Post-composition by a uniform inducing is a uniform inducing for the\nuniform structures of `ğ”–`-convergence.\n\nMore precisely, if `f : Î³ â†’ Î²` is a uniform inducing, then\n`(Î» g, f âˆ˜ g) : (Î± â†’áµ¤[ğ”–] Î³) â†’ (Î± â†’áµ¤[ğ”–] Î²)` is a uniform inducing. -/\nprotected theorem postcomp_uniform_inducing [UniformSpace Î³] {f : Î³ â†’ Î²} (hf : UniformInducing f) :\n    UniformInducing (ofFun ğ”– âˆ˜ (Â· âˆ˜ Â·) f âˆ˜ toFun ğ”–) :=\n  by\n  -- This is a direct consequence of `uniform_convergence.comap_eq`\n  constructor\n  replace hf : ((uniformity) Î²).comap (prod.map f f) = _ := hf.comap_uniformity\n  change comap (prod.map (of_fun ğ”– âˆ˜ (Â· âˆ˜ Â·) f âˆ˜ to_fun ğ”–) (of_fun ğ”– âˆ˜ (Â· âˆ˜ Â·) f âˆ˜ to_fun ğ”–)) _ = _\n  rw [â† uniformity_comap] at hfâŠ¢\n  congr\n  rw [â† uniformSpace_eq hf, UniformOnFun.comap_eq]\n  rfl\n#align postcomp_uniform_inducing postcomp_uniform_inducing\n\n",
 "postcomp_uniform_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğ’±( , , , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğ’±( , , , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğ’±( , , , )Â» -/\n-- by definition, `âˆ€ S âˆˆ ğ”–, (f âˆ˜ â€”) âˆ˜ S.restrict = S.restrict âˆ˜ (f âˆ˜ â€”)`.\n/-- Post-composition by a uniformly continuous function is uniformly continuous for the\nuniform structures of `ğ”–`-convergence.\n\nMore precisely, if `f : Î³ â†’ Î²` is uniformly continuous, then\n`(Î» g, f âˆ˜ g) : (Î± â†’áµ¤[ğ”–] Î³) â†’ (Î± â†’áµ¤[ğ”–] Î²)` is uniformly continuous. -/\nprotected theorem postcomp_uniform_continuous [UniformSpace Î³] {f : Î³ â†’ Î²} (hf : UniformContinuous f) :\n    UniformContinuous (ofFun ğ”– âˆ˜ (Â· âˆ˜ Â·) f âˆ˜ toFun ğ”–) :=\n  by\n  -- This is a direct consequence of `uniform_convergence.comap_eq`\n  rw [uniformContinuous_iff]\n  calc\n    Â«exprğ’±( , , , )Â» Î± Î³ ğ”– _ â‰¤ Â«exprğ’±( , , , )Â» Î± Î³ ğ”– (â€¹UniformSpace Î²â€º.comap f) :=\n      UniformOnFun.mono (uniform_continuous_iff.mp hf) subset_rfl\n    _ = (Â«exprğ’±( , , , )Â» Î± Î² ğ”– _).comap ((Â· âˆ˜ Â·) f) := UniformOnFun.comap_eq\n    \n#align postcomp_uniform_continuous postcomp_uniform_continuous\n\n",
 "mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğ’±( , , , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğ’±( , , , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğ’±( , , , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğ’±( , , , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğ’±( , , , )Â» -/\n/-- Let `uâ‚`, `uâ‚‚` be two uniform structures on `Î³` and `ğ”–â‚ ğ”–â‚‚ : set (set Î±)`. If `uâ‚ â‰¤ uâ‚‚` and\n`ğ”–â‚‚ âŠ† ğ”–â‚` then `ğ’±(Î±, Î³, ğ”–â‚, uâ‚) â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚)`. -/\nprotected theorem mono â¦ƒuâ‚ uâ‚‚ : UniformSpace Î³â¦„ (hu : uâ‚ â‰¤ uâ‚‚) â¦ƒğ”–â‚ ğ”–â‚‚ : Set (Set Î±)â¦„ (hğ”– : ğ”–â‚‚ âŠ† ğ”–â‚) :\n    Â«exprğ’±( , , , )Â» Î± Î³ ğ”–â‚ uâ‚ â‰¤ Â«exprğ’±( , , , )Â» Î± Î³ ğ”–â‚‚ uâ‚‚ :=\n  calc\n    Â«exprğ’±( , , , )Â» Î± Î³ ğ”–â‚ uâ‚ â‰¤ Â«exprğ’±( , , , )Â» Î± Î³ ğ”–â‚‚ uâ‚ := infáµ¢_le_infáµ¢_of_subset hğ”–\n    _ â‰¤ Â«exprğ’±( , , , )Â» Î± Î³ ğ”–â‚‚ uâ‚‚ := infáµ¢â‚‚_mono fun i hi => UniformSpace.comap_mono <| UniformFun.mono hu\n    \n#align mono mono\n\n",
 "is_basis_gen":
 "/-- If `ğ”– : set (set Î±)` is nonempty and directed and `ğ“‘` is a filter basis on `Î² Ã— Î²`, then the\nfamily `uniform_on_fun.gen ğ”– S V` for `S âˆˆ ğ”–` and `V âˆˆ ğ“‘` is a filter basis on\n`(Î± â†’áµ¤[ğ”–] Î²) Ã— (Î± â†’áµ¤[ğ”–] Î²)`.\nWe will show in `has_basis_uniformity_of_basis` that, if `ğ“‘` is a basis for `ğ“¤ Î²`, then the\ncorresponding filter is the uniformity of `Î± â†’áµ¤[ğ”–] Î²`. -/\nprotected theorem is_basis_gen (ğ”– : Set (Set Î±)) (h : ğ”–.nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–)\n    (ğ“‘ : FilterBasis <| Î² Ã— Î²) :\n    IsBasis (fun SV : Set Î± Ã— Set (Î² Ã— Î²) => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“‘) fun SV => UniformOnFun.gen ğ”– SV.1 SV.2 :=\n  âŸ¨h.prod ğ“‘.nonempty, fun Uâ‚Vâ‚ Uâ‚‚Vâ‚‚ hâ‚ hâ‚‚ =>\n    let âŸ¨Uâ‚ƒ, hUâ‚ƒ, hUâ‚â‚ƒ, hUâ‚‚â‚ƒâŸ© := h' Uâ‚Vâ‚.1 hâ‚.1 Uâ‚‚Vâ‚‚.1 hâ‚‚.1\n    let âŸ¨Vâ‚ƒ, hVâ‚ƒ, hVâ‚â‚‚â‚ƒâŸ© := ğ“‘.inter_sets hâ‚.2 hâ‚‚.2\n    âŸ¨âŸ¨Uâ‚ƒ, Vâ‚ƒâŸ©,\n      âŸ¨âŸ¨hUâ‚ƒ, hVâ‚ƒâŸ©, fun uv huv =>\n        âŸ¨fun x hx => (hVâ‚â‚‚â‚ƒ <| huv x <| hUâ‚â‚ƒ hx).1, fun x hx => (hVâ‚â‚‚â‚ƒ <| huv x <| hUâ‚‚â‚ƒ hx).2âŸ©âŸ©âŸ©âŸ©\n#align is_basis_gen is_basis_gen\n\n",
 "infi_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğ’±( , , , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğ’±( , , , )Â» -/\n/-- If `u` is a family of uniform structures on `Î³`, then\n`ğ’±(Î±, Î³, ğ”–, (â¨… i, u i)) = â¨… i, ğ’±(Î±, Î³, ğ”–, u i)`. -/\nprotected theorem infi_eq {u : Î¹ â†’ UniformSpace Î³} :\n    Â«exprğ’±( , , , )Â» Î± Î³ ğ”–\n        (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\" (u i)) =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        (Â«exprğ’±( , , , )Â» Î± Î³ ğ”– (u i)) :=\n  by\n  simp_rw [uniform_on_fun.uniform_space, UniformFun.infáµ¢_eq, UniformSpace.comap_infáµ¢]\n  rw [infáµ¢_comm]\n  exact infáµ¢_congr fun s => infáµ¢_comm\n#align infi_eq infi_eq\n\n",
 "inf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğ’±( , , , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğ’±( , , , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğ’±( , , , )Â» -/\n/-- If `uâ‚` and `uâ‚‚` are two uniform structures on `Î³`, then\n`ğ’±(Î±, Î³, ğ”–, uâ‚ âŠ“ uâ‚‚) = ğ’±(Î±, Î³, ğ”–, uâ‚) âŠ“ ğ’±(Î±, Î³, ğ”–, uâ‚‚)`. -/\nprotected theorem inf_eq {uâ‚ uâ‚‚ : UniformSpace Î³} :\n    Â«exprğ’±( , , , )Â» Î± Î³ ğ”– (Â«expr âŠ“ Â» uâ‚ uâ‚‚) = Â«expr âŠ“ Â» (Â«exprğ’±( , , , )Â» Î± Î³ ğ”– uâ‚) (Â«exprğ’±( , , , )Â» Î± Î³ ğ”– uâ‚‚) :=\n  by\n  rw [inf_eq_infáµ¢, inf_eq_infáµ¢, UniformOnFun.infáµ¢_eq]\n  refine' infáµ¢_congr fun i => _\n  cases i <;> rfl\n#align inf_eq inf_eq\n\n",
 "has_basis_uniformity_of_basis_auxâ‚‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹'o Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤ Â» -/\nprotected theorem has_basis_uniformity_of_basis_auxâ‚‚ (h : DirectedOn (Â· âŠ† Â·) ğ”–) {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)}\n    (hb : HasBasis ((uniformity) Î²) p s) :\n    DirectedOn\n      (Â«expr â»Â¹'o Â»\n        (fun s : Set Î± => (uniform_fun.uniform_space s Î²).comap (s.restrict : Â«expr â†’áµ¤ Â» Î± Î² â†’ Â«expr â†’áµ¤ Â» s Î²)) GE.ge)\n      ğ”– :=\n  h.mono fun s t hst =>\n    ((UniformOnFun.hasBasis_uniformity_of_basis_auxâ‚ Î± Î² ğ”– hb _).le_basis_iff\n          (UniformOnFun.hasBasis_uniformity_of_basis_auxâ‚ Î± Î² ğ”– hb _)).mpr\n      fun V hV => âŸ¨V, hV, UniformOnFun.gen_mono hst subset_rflâŸ©\n#align has_basis_uniformity_of_basis_auxâ‚‚ has_basis_uniformity_of_basis_auxâ‚‚\n\n",
 "has_basis_uniformity_of_basis_auxâ‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\nprotected theorem has_basis_uniformity_of_basis_auxâ‚ {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)}\n    (hb : HasBasis ((uniformity) Î²) p s) (S : Set Î±) :\n    (@uniformity (Â«expr â†’áµ¤[ ] Â» Î± ğ”– Î²) ((uniform_fun.uniform_space S Î²).comap S.restrict)).has_basis p fun i =>\n      UniformOnFun.gen ğ”– S (s i) :=\n  by\n  simp_rw [UniformOnFun.gen_eq_preimage_restrict, uniformity_comap]\n  exact (UniformFun.hasBasis_uniformity_of_basis S Î² hb).comap _\n#align has_basis_uniformity_of_basis_auxâ‚ has_basis_uniformity_of_basis_auxâ‚\n\n",
 "has_basis_uniformity_of_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n/-- If `ğ”– : set (set Î±)` is nonempty and directed and `ğ“‘` is a filter basis of `ğ“¤ Î²`, then the\nuniformity of `Î± â†’áµ¤[ğ”–] Î²` admits the family `{(f, g) | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and\n`V âˆˆ ğ“‘` as a filter basis. -/\nprotected theorem has_basis_uniformity_of_basis (h : ğ”–.nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–) {p : Î¹ â†’ Prop}\n    {s : Î¹ â†’ Set (Î² Ã— Î²)} (hb : HasBasis ((uniformity) Î²) p s) :\n    ((uniformity) (Â«expr â†’áµ¤[ ] Â» Î± ğ”– Î²)).has_basis (fun Si : Set Î± Ã— Î¹ => Si.1 âˆˆ ğ”– âˆ§ p Si.2) fun Si =>\n      UniformOnFun.gen ğ”– Si.1 (s Si.2) :=\n  by\n  simp only [infáµ¢_uniformity]\n  exact\n    has_basis_binfi_of_directed h (fun S => UniformOnFun.gen ğ”– S âˆ˜ s) _\n      (fun S hS => UniformOnFun.hasBasis_uniformity_of_basis_auxâ‚ Î± Î² ğ”– hb S)\n      (UniformOnFun.hasBasis_uniformity_of_basis_auxâ‚‚ Î± Î² ğ”– h' hb)\n#align has_basis_uniformity_of_basis has_basis_uniformity_of_basis\n\n",
 "has_basis_uniformity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- If `ğ”– : set (set Î±)` is nonempty and directed, then the uniformity of `Î± â†’áµ¤[ğ”–] Î²` admits the\nfamily `{(f, g) | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and `V âˆˆ ğ“¤ Î²` as a filter basis. -/\nprotected theorem has_basis_uniformity (h : ğ”–.nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–) :\n    ((uniformity) (Â«expr â†’áµ¤[ ] Â» Î± ğ”– Î²)).has_basis (fun SV : Set Î± Ã— Set (Î² Ã— Î²) => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ (uniformity) Î²)\n      fun SV => UniformOnFun.gen ğ”– SV.1 SV.2 :=\n  UniformOnFun.hasBasis_uniformity_of_basis Î± Î² ğ”– h h' ((uniformity) Î²).basis_sets\n#align has_basis_uniformity has_basis_uniformity\n\n",
 "has_basis_nhds_of_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- For `f : Î± â†’áµ¤[ğ”–] Î²`, where `ğ”– : set (set Î±)` is nonempty and directed, `ğ“ f` admits the\nfamily `{g | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and `V âˆˆ ğ“‘` as a filter basis, for any basis\n`ğ“‘` of `ğ“¤ Î²`. -/\nprotected theorem has_basis_nhds_of_basis (f : Â«expr â†’áµ¤[ ] Â» Î± ğ”– Î²) (h : ğ”–.nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–)\n    {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)} (hb : HasBasis ((uniformity) Î²) p s) :\n    ((nhds) f).has_basis (fun Si : Set Î± Ã— Î¹ => Si.1 âˆˆ ğ”– âˆ§ p Si.2) fun Si =>\n      { g | (g, f) âˆˆ UniformOnFun.gen ğ”– Si.1 (s Si.2) } :=\n  letI : UniformSpace (Î± â†’ Î²) := uniform_on_fun.uniform_space Î± Î² ğ”–\n  nhds_basis_uniformity (UniformOnFun.hasBasis_uniformity_of_basis Î± Î² ğ”– h h' hb)\n#align has_basis_nhds_of_basis has_basis_nhds_of_basis\n\n",
 "has_basis_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/-- For `f : Î± â†’áµ¤[ğ”–] Î²`, where `ğ”– : set (set Î±)` is nonempty and directed, `ğ“ f` admits the\nfamily `{g | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and `V âˆˆ ğ“¤ Î²` as a filter basis. -/\nprotected theorem has_basis_nhds (f : Â«expr â†’áµ¤[ ] Â» Î± ğ”– Î²) (h : ğ”–.nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–) :\n    ((nhds) f).has_basis (fun SV : Set Î± Ã— Set (Î² Ã— Î²) => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ (uniformity) Î²) fun SV =>\n      { g | (g, f) âˆˆ UniformOnFun.gen ğ”– SV.1 SV.2 } :=\n  UniformOnFun.hasBasis_nhds_of_basis Î± Î² ğ”– f h h' (Filter.basis_sets _)\n#align has_basis_nhds has_basis_nhds\n\n",
 "gen_mono":
 "/-- `uniform_on_fun.gen` is antitone in the first argument and monotone in the second. -/\nprotected theorem gen_mono {ğ”–} {S S' : Set Î±} {V V' : Set (Î² Ã— Î²)} (hS : S' âŠ† S) (hV : V âŠ† V') :\n    UniformOnFun.gen ğ”– S V âŠ† UniformOnFun.gen ğ”– S' V' := fun uv h x hx => hV (h x <| hS hx)\n#align gen_mono gen_mono\n\n",
 "gen_eq_preimage_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n-- Denote `Ï†` this bijection. We want to show that\n-- `comap Ï† (ğ’°(Î±, Î², uÎ²) Ã— ğ’°(Î±, Î³, uÎ³)) = ğ’°(Î±, Î² Ã— Î³, uÎ² Ã— uÎ³)`.\n-- But `uÎ² Ã— uÎ³` is defined as `comap fst uÎ² âŠ“ comap snd uÎ³`, so we just have to apply\n-- `uniform_convergence.inf_eq` and `uniform_convergence.comap_eq`, which leaves us to check\n-- that some square commutes.\n-- the relevant diagram commutes by definition\n-- Denote `Ï†` this bijection. We want to show that\n-- `comap Ï† (Î  i, ğ’°(Î±, Î´ i, uÎ´ i)) = ğ’°(Î±, (Î  i, Î´ i), (Î  i, uÎ´ i))`.\n-- But `Î  i, uÎ´ i` is defined as `â¨… i, comap (eval i) (uÎ´ i)`, so we just have to apply\n-- `uniform_convergence.infi_eq` and `uniform_convergence.comap_eq`, which leaves us to check\n-- that some square commutes.\n-- Like in the previous lemma, the diagram actually commutes by definition\n/-- For `S : set Î±` and `V : set (Î² Ã— Î²)`, we have\n`uniform_on_fun.gen ğ”– S V = (S.restrict Ã— S.restrict) â»Â¹' (uniform_fun.gen S Î² V)`.\nThis is the crucial fact for proving that the family `uniform_on_fun.gen S V` for `S âˆˆ ğ”–` and\n`V âˆˆ ğ“¤ Î²` is indeed a basis for the uniformity `Î± â†’áµ¤[ğ”–] Î²` endowed with `ğ’±(Î±, Î², ğ”–, uÎ²)`\nthe uniform structure of `ğ”–`-convergence, as defined in `uniform_on_fun.uniform_space`. -/\nprotected theorem gen_eq_preimage_restrict {ğ”–} (S : Set Î±) (V : Set (Î² Ã— Î²)) :\n    UniformOnFun.gen ğ”– S V = Â«expr â»Â¹' Â» (prod.map S.restrict S.restrict) (UniformFun.gen S Î² V) :=\n  by\n  ext uv\n  exact âŸ¨fun h âŸ¨x, hxâŸ© => h x hx, fun h x hx => h âŸ¨x, hxâŸ©âŸ©\n#align gen_eq_preimage_restrict gen_eq_preimage_restrict\n\n",
 "gc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’áµ¤ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprlower_adjoint -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprlower_adjoint -/\n/- This is a lower adjoint to `uniform_convergence.filter` (see `uniform_convergence.gc`).\nThe exact definition of the lower adjoint `l` is not interesting; we will only use that it exists\n(in `uniform_convergence.mono` and `uniform_convergence.infi_eq`) and that\n`l (filter.map (prod.map f f) ğ“•) = filter.map (prod.map ((âˆ˜) f) ((âˆ˜) f)) (l ğ“•)` for each\n`ğ“• : filter (Î³ Ã— Î³)` and `f : Î³ â†’ Î±` (in `uniform_convergence.comap_eq`). -/\n/-- The function `uniform_convergence.filter Î± Î² : filter (Î² Ã— Î²) â†’ filter ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²))`\nhas a lower adjoint `l` (in the sense of `galois_connection`). The exact definition of `l` is not\ninteresting; we will only use that it exists (in `uniform_convergence.mono` and\n`uniform_convergence.infi_eq`) and that\n`l (filter.map (prod.map f f) ğ“•) = filter.map (prod.map ((âˆ˜) f) ((âˆ˜) f)) (l ğ“•)` for each\n`ğ“• : filter (Î³ Ã— Î³)` and `f : Î³ â†’ Î±` (in `uniform_convergence.comap_eq`). -/\nprotected theorem gc : GaloisConnection (exprlower_adjoint) fun ğ“• => UniformFun.filter Î± Î² ğ“• :=\n  by\n  intro ğ“ ğ“•\n  symm\n  calc\n    ğ“ â‰¤ UniformFun.filter Î± Î² ğ“• â†” (UniformFun.basis Î± Î² ğ“•).sets âŠ† ğ“.sets := by\n      rw [UniformFun.filter, â† FilterBasis.generate, sets_iff_generate]\n    _ â†” âˆ€ U âˆˆ ğ“•, UniformFun.gen Î± Î² U âˆˆ ğ“ := image_subset_iff\n    _ â†”\n        âˆ€ U âˆˆ ğ“•,\n          { uv | âˆ€ x, (uv, x) âˆˆ { t : (Â«expr â†’áµ¤ Â» Î± Î² Ã— Â«expr â†’áµ¤ Â» Î± Î²) Ã— Î± | (t.1.1 t.2, t.1.2 t.2) âˆˆ U } } âˆˆ ğ“ :=\n      iff.rfl\n    _ â†”\n        âˆ€ U âˆˆ ğ“•,\n          { uvx : (Â«expr â†’áµ¤ Â» Î± Î² Ã— Â«expr â†’áµ¤ Â» Î± Î²) Ã— Î± | (uvx.1.1 uvx.2, uvx.1.2 uvx.2) âˆˆ U } âˆˆ\n            filter.prod ğ“ (Â«exprâŠ¤Â» : Filter Î±) :=\n      (forallâ‚‚_congr fun U hU => mem_prod_top.symm)\n    _ â†” (exprlower_adjoint) ğ“ â‰¤ ğ“• := iff.rfl\n    \n#align gc gc\n\n",
 "comap_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğ’±( , , , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğ’±( , , , )Â» -/\n/-- If `u` is a uniform structures on `Î²` and `f : Î³ â†’ Î²`, then\n`ğ’±(Î±, Î³, ğ”–, comap f u) = comap (Î» g, f âˆ˜ g) ğ’±(Î±, Î³, ğ”–, uâ‚)`. -/\nprotected theorem comap_eq {f : Î³ â†’ Î²} :\n    Â«exprğ’±( , , , )Â» Î± Î³ ğ”– (â€¹UniformSpace Î²â€º.comap f) = (Â«exprğ’±( , , , )Â» Î± Î² ğ”– _).comap ((Â· âˆ˜ Â·) f) :=\n  by\n  -- We reduce this to `uniform_convergence.comap_eq` using the fact that `comap` distributes\n  -- on `infi`.\n  simp_rw [uniform_on_fun.uniform_space, UniformSpace.comap_infáµ¢, UniformFun.comap_eq, â† UniformSpace.comap_comap]\n  rfl\n#align comap_eq comap_eq\n\n"}