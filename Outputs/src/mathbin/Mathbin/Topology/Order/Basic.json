{"tfae_mem_nhds_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers\n      [(Command.docComment\n        \"/--\"\n        \"The following statements are equivalent:\\n\\n0. `s` is a neighborhood of `a` within `(a, +∞)`\\n1. `s` is a neighborhood of `a` within `(a, b]`\\n2. `s` is a neighborhood of `a` within `(a, b)`\\n3. `s` includes `(a, u)` for some `u ∈ (a, b]`\\n4. `s` includes `(a, u)` for some `u > a` -/\")]\n      []\n      []\n      []\n      []\n      [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `tfae_mem_nhds_within_Ioi [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`a `b] [\":\" `α] \"}\")\n        (Term.explicitBinder \"(\" [`hab] [\":\" («term_<_» `a \"<\" `b)] [] \")\")\n        (Term.explicitBinder \"(\" [`s] [\":\" (Term.app `set [`α])] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(«term_∈_» `s \"∈\" (Term.app `nhds_within.gt [`a]))\n            \",\"\n            («term_∈_» `s \"∈\" (Term.app `nhds_within [(Term.app `Ioc [`a `b]) `a]))\n            \",\"\n            («term_∈_» `s \"∈\" (Term.app `nhds_within [(Term.app `Ioo [`a `b]) `a]))\n            \",\"\n            (Std.ExtendedBinder.«term∃__,_»\n             \"∃\"\n             (Lean.binderIdent `u)\n             («binderTerm∈_» \"∈\" (Term.app `Ioc [`a `b]))\n             \",\"\n             («term_⊆_» (Term.app `Ioo [`a `u]) \"⊆\" `s))\n            \",\"\n            (Std.ExtendedBinder.«term∃__,_»\n             \"∃\"\n             (Lean.binderIdent `u)\n             («binderTerm∈_» \"∈\" (Term.app `Ioi [`a]))\n             \",\"\n             («term_⊆_» (Term.app `Ioo [`a `u]) \"⊆\" `s))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"2\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] (Term.app `nhds_within_Ioc_eq_nhds_within_Ioi [`hab]))] \"]\")\n              [])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"3\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] (Term.app `nhds_within_Ioo_eq_nhds_within_Ioi [`hab]))] \"]\")\n              [])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"5\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [(Term.anonymousCtor \"⟨\" [`u \",\" `umem \",\" `hu] \"⟩\")]\n              []\n              \"=>\"\n              (Term.anonymousCtor \"⟨\" [`u \",\" (Term.proj `umem \".\" (fieldIdx \"1\")) \",\" `hu] \"⟩\"))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `u)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hau)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hu)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Tactic.exact\n              \"exact\"\n              (Term.app\n               `mem_of_superset\n               [(Term.app `Ioo_mem_nhds_within_Ioi [(Term.anonymousCtor \"⟨\" [(Term.app `le_refl [`a]) \",\" `hau] \"⟩\")])\n                `hu]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`h])\n             []\n             (Std.Tactic.rcases\n              \"rcases\"\n              [(Tactic.casesTarget\n                []\n                (Term.app (Term.proj `mem_nhds_within_iff_exists_mem_nhds_inter \".\" (fieldIdx \"1\")) [`h]))]\n              [\"with\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed\n                 [(Std.Tactic.RCases.rcasesPat.tuple\n                   \"⟨\"\n                   [(Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `v)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `va)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv)])\n                     [])]\n                   \"⟩\")])\n                [])])\n             []\n             (Std.Tactic.rcases\n              \"rcases\"\n              [(Tactic.casesTarget [] (Term.app `exists_Ico_subset_of_mem_nhds' [`va `hab]))]\n              [\"with\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed\n                 [(Std.Tactic.RCases.rcasesPat.tuple\n                   \"⟨\"\n                   [(Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `u)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `au)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hu)])\n                     [])]\n                   \"⟩\")])\n                [])])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [`u \",\" `au \",\" (Term.fun \"fun\" (Term.basicFun [`x `hx] [] \"=>\" (Term.hole \"_\")))]\n               \"⟩\"))\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.app\n               `hv\n               [(Term.anonymousCtor\n                 \"⟨\"\n                 [(Term.app\n                   `hu\n                   [(Term.anonymousCtor\n                     \"⟨\"\n                     [(Term.app `le_of_lt [(Term.proj `hx \".\" (fieldIdx \"1\"))]) \",\" (Term.proj `hx \".\" (fieldIdx \"2\"))]\n                     \"⟩\")])\n                  \",\"\n                  (Term.hole \"_\")]\n                 \"⟩\")]))\n             []\n             (Tactic.exact \"exact\" (Term.proj `hx \".\" (fieldIdx \"1\")))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"2\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] (Term.app `nhds_within_Ioc_eq_nhds_within_Ioi [`hab]))] \"]\")\n             [])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"3\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] (Term.app `nhds_within_Ioo_eq_nhds_within_Ioi [`hab]))] \"]\")\n             [])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"5\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [(Term.anonymousCtor \"⟨\" [`u \",\" `umem \",\" `hu] \"⟩\")]\n             []\n             \"=>\"\n             (Term.anonymousCtor \"⟨\" [`u \",\" (Term.proj `umem \".\" (fieldIdx \"1\")) \",\" `hu] \"⟩\"))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `u)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hau)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hu)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.app\n              `mem_of_superset\n              [(Term.app `Ioo_mem_nhds_within_Ioi [(Term.anonymousCtor \"⟨\" [(Term.app `le_refl [`a]) \",\" `hau] \"⟩\")])\n               `hu]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`h])\n            []\n            (Std.Tactic.rcases\n             \"rcases\"\n             [(Tactic.casesTarget\n               []\n               (Term.app (Term.proj `mem_nhds_within_iff_exists_mem_nhds_inter \".\" (fieldIdx \"1\")) [`h]))]\n             [\"with\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.tuple\n                  \"⟨\"\n                  [(Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `v)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `va)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv)])\n                    [])]\n                  \"⟩\")])\n               [])])\n            []\n            (Std.Tactic.rcases\n             \"rcases\"\n             [(Tactic.casesTarget [] (Term.app `exists_Ico_subset_of_mem_nhds' [`va `hab]))]\n             [\"with\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.tuple\n                  \"⟨\"\n                  [(Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `u)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `au)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hu)])\n                    [])]\n                  \"⟩\")])\n               [])])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [`u \",\" `au \",\" (Term.fun \"fun\" (Term.basicFun [`x `hx] [] \"=>\" (Term.hole \"_\")))]\n              \"⟩\"))\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.app\n              `hv\n              [(Term.anonymousCtor\n                \"⟨\"\n                [(Term.app\n                  `hu\n                  [(Term.anonymousCtor\n                    \"⟨\"\n                    [(Term.app `le_of_lt [(Term.proj `hx \".\" (fieldIdx \"1\"))]) \",\" (Term.proj `hx \".\" (fieldIdx \"2\"))]\n                    \"⟩\")])\n                 \",\"\n                 (Term.hole \"_\")]\n                \"⟩\")]))\n            []\n            (Tactic.exact \"exact\" (Term.proj `hx \".\" (fieldIdx \"1\")))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.intro \"intro\" [`h])\n        []\n        (Std.Tactic.rcases\n         \"rcases\"\n         [(Tactic.casesTarget\n           []\n           (Term.app (Term.proj `mem_nhds_within_iff_exists_mem_nhds_inter \".\" (fieldIdx \"1\")) [`h]))]\n         [\"with\"\n          (Std.Tactic.RCases.rcasesPatLo\n           (Std.Tactic.RCases.rcasesPatMed\n            [(Std.Tactic.RCases.rcasesPat.tuple\n              \"⟨\"\n              [(Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `v)])\n                [])\n               \",\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `va)])\n                [])\n               \",\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv)])\n                [])]\n              \"⟩\")])\n           [])])\n        []\n        (Std.Tactic.rcases\n         \"rcases\"\n         [(Tactic.casesTarget [] (Term.app `exists_Ico_subset_of_mem_nhds' [`va `hab]))]\n         [\"with\"\n          (Std.Tactic.RCases.rcasesPatLo\n           (Std.Tactic.RCases.rcasesPatMed\n            [(Std.Tactic.RCases.rcasesPat.tuple\n              \"⟨\"\n              [(Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `u)])\n                [])\n               \",\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `au)])\n                [])\n               \",\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hu)])\n                [])]\n              \"⟩\")])\n           [])])\n        []\n        (Tactic.refine'\n         \"refine'\"\n         (Term.anonymousCtor\n          \"⟨\"\n          [`u \",\" `au \",\" (Term.fun \"fun\" (Term.basicFun [`x `hx] [] \"=>\" (Term.hole \"_\")))]\n          \"⟩\"))\n        []\n        (Tactic.refine'\n         \"refine'\"\n         (Term.app\n          `hv\n          [(Term.anonymousCtor\n            \"⟨\"\n            [(Term.app\n              `hu\n              [(Term.anonymousCtor\n                \"⟨\"\n                [(Term.app `le_of_lt [(Term.proj `hx \".\" (fieldIdx \"1\"))]) \",\" (Term.proj `hx \".\" (fieldIdx \"2\"))]\n                \"⟩\")])\n             \",\"\n             (Term.hole \"_\")]\n            \"⟩\")]))\n        []\n        (Tactic.exact \"exact\" (Term.proj `hx \".\" (fieldIdx \"1\")))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.proj `hx \".\" (fieldIdx \"1\")))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.proj `hx \".\" (fieldIdx \"1\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hx\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.refine'\n       \"refine'\"\n       (Term.app\n        `hv\n        [(Term.anonymousCtor\n          \"⟨\"\n          [(Term.app\n            `hu\n            [(Term.anonymousCtor\n              \"⟨\"\n              [(Term.app `le_of_lt [(Term.proj `hx \".\" (fieldIdx \"1\"))]) \",\" (Term.proj `hx \".\" (fieldIdx \"2\"))]\n              \"⟩\")])\n           \",\"\n           (Term.hole \"_\")]\n          \"⟩\")]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       `hv\n       [(Term.anonymousCtor\n         \"⟨\"\n         [(Term.app\n           `hu\n           [(Term.anonymousCtor\n             \"⟨\"\n             [(Term.app `le_of_lt [(Term.proj `hx \".\" (fieldIdx \"1\"))]) \",\" (Term.proj `hx \".\" (fieldIdx \"2\"))]\n             \"⟩\")])\n          \",\"\n          (Term.hole \"_\")]\n         \"⟩\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor\n       \"⟨\"\n       [(Term.app\n         `hu\n         [(Term.anonymousCtor\n           \"⟨\"\n           [(Term.app `le_of_lt [(Term.proj `hx \".\" (fieldIdx \"1\"))]) \",\" (Term.proj `hx \".\" (fieldIdx \"2\"))]\n           \"⟩\")])\n        \",\"\n        (Term.hole \"_\")]\n       \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       `hu\n       [(Term.anonymousCtor\n         \"⟨\"\n         [(Term.app `le_of_lt [(Term.proj `hx \".\" (fieldIdx \"1\"))]) \",\" (Term.proj `hx \".\" (fieldIdx \"2\"))]\n         \"⟩\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor\n       \"⟨\"\n       [(Term.app `le_of_lt [(Term.proj `hx \".\" (fieldIdx \"1\"))]) \",\" (Term.proj `hx \".\" (fieldIdx \"2\"))]\n       \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.proj `hx \".\" (fieldIdx \"2\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hx\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `le_of_lt [(Term.proj `hx \".\" (fieldIdx \"1\"))])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.proj `hx \".\" (fieldIdx \"1\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hx\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `le_of_lt\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `hu\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `hv\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.refine'\n       \"refine'\"\n       (Term.anonymousCtor \"⟨\" [`u \",\" `au \",\" (Term.fun \"fun\" (Term.basicFun [`x `hx] [] \"=>\" (Term.hole \"_\")))] \"⟩\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor \"⟨\" [`u \",\" `au \",\" (Term.fun \"fun\" (Term.basicFun [`x `hx] [] \"=>\" (Term.hole \"_\")))] \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun \"fun\" (Term.basicFun [`x `hx] [] \"=>\" (Term.hole \"_\")))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hx\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `x\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `au\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `u\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rcases\n       \"rcases\"\n       [(Tactic.casesTarget [] (Term.app `exists_Ico_subset_of_mem_nhds' [`va `hab]))]\n       [\"with\"\n        (Std.Tactic.RCases.rcasesPatLo\n         (Std.Tactic.RCases.rcasesPatMed\n          [(Std.Tactic.RCases.rcasesPat.tuple\n            \"⟨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `u)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `au)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hu)])\n              [])]\n            \"⟩\")])\n         [])])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `exists_Ico_subset_of_mem_nhds' [`va `hab])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hab\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `va\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `exists_Ico_subset_of_mem_nhds'\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rcases\n       \"rcases\"\n       [(Tactic.casesTarget\n         []\n         (Term.app (Term.proj `mem_nhds_within_iff_exists_mem_nhds_inter \".\" (fieldIdx \"1\")) [`h]))]\n       [\"with\"\n        (Std.Tactic.RCases.rcasesPatLo\n         (Std.Tactic.RCases.rcasesPatMed\n          [(Std.Tactic.RCases.rcasesPat.tuple\n            \"⟨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `v)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `va)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hv)])\n              [])]\n            \"⟩\")])\n         [])])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app (Term.proj `mem_nhds_within_iff_exists_mem_nhds_inter \".\" (fieldIdx \"1\")) [`h])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      (Term.proj `mem_nhds_within_iff_exists_mem_nhds_inter \".\" (fieldIdx \"1\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `mem_nhds_within_iff_exists_mem_nhds_inter\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.intro \"intro\" [`h])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\n/--\n    The following statements are equivalent:\n    \n    0. `s` is a neighborhood of `a` within `(a, +∞)`\n    1. `s` is a neighborhood of `a` within `(a, b]`\n    2. `s` is a neighborhood of `a` within `(a, b)`\n    3. `s` includes `(a, u)` for some `u ∈ (a, b]`\n    4. `s` includes `(a, u)` for some `u > a` -/\n  theorem\n    tfae_mem_nhds_within_Ioi\n    { a b : α } ( hab : a < b ) ( s : set α )\n      :\n        TFAE\n          [\n            s ∈ nhds_within.gt a\n              ,\n              s ∈ nhds_within Ioc a b a\n              ,\n              s ∈ nhds_within Ioo a b a\n              ,\n              ∃ u ∈ Ioc a b , Ioo a u ⊆ s\n              ,\n              ∃ u ∈ Ioi a , Ioo a u ⊆ s\n            ]\n    :=\n      by\n        tfae_have 1 ↔ 2\n          ;\n          · rw [ nhds_within_Ioc_eq_nhds_within_Ioi hab ]\n          tfae_have 1 ↔ 3\n          ;\n          · rw [ nhds_within_Ioo_eq_nhds_within_Ioi hab ]\n          tfae_have 4 → 5\n          ;\n          exact fun ⟨ u , umem , hu ⟩ => ⟨ u , umem . 1 , hu ⟩\n          tfae_have 5 → 1\n          · rintro ⟨ u , hau , hu ⟩ exact mem_of_superset Ioo_mem_nhds_within_Ioi ⟨ le_refl a , hau ⟩ hu\n          tfae_have 1 → 4\n          ·\n            intro h\n              rcases mem_nhds_within_iff_exists_mem_nhds_inter . 1 h with ⟨ v , va , hv ⟩\n              rcases exists_Ico_subset_of_mem_nhds' va hab with ⟨ u , au , hu ⟩\n              refine' ⟨ u , au , fun x hx => _ ⟩\n              refine' hv ⟨ hu ⟨ le_of_lt hx . 1 , hx . 2 ⟩ , _ ⟩\n              exact hx . 1\n          tfae_finish\n#align tfae_mem_nhds_within_Ioi tfae_mem_nhds_within_Ioi\n\n",
 "tfae_mem_nhds_within_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- The following statements are equivalent:\n\n0. `s` is a neighborhood of `b` within `(-∞, b)`\n1. `s` is a neighborhood of `b` within `[a, b)`\n2. `s` is a neighborhood of `b` within `(a, b)`\n3. `s` includes `(l, b)` for some `l ∈ [a, b)`\n4. `s` includes `(l, b)` for some `l < b` -/\ntheorem tfae_mem_nhds_within_Iio {a b : α} (h : a < b) (s : set α) :\n    TFAE\n      [s ∈ nhds_within.lt b,-- 0 : `s` is a neighborhood of `b` within `(-∞, b)`\n          s ∈\n          nhds_within (Ico a b) b,-- 1 : `s` is a neighborhood of `b` within `[a, b)`\n          s ∈\n          nhds_within (Ioo a b) b,-- 2 : `s` is a neighborhood of `b` within `(a, b)`\n        ∃ l ∈ Ico a b, Ioo l b ⊆ s,-- 3 : `s` includes `(l, b)` for some `l ∈ [a, b)`\n        ∃ l ∈ Iio b, Ioo l b ⊆ s] :=\n  by-- 4 : `s` includes `(l, b)` for some `l < b`\n  simpa only [exists_prop, order_dual.exists, dual_Ioi, dual_Ioc, dual_Ioo] using\n    tfae_mem_nhds_within_Ioi h.dual («expr ⁻¹' » of_dual s)\n#align tfae_mem_nhds_within_Iio tfae_mem_nhds_within_Iio\n\n",
 "tfae_mem_nhds_within_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- The following statements are equivalent:\n\n0. `s` is a neighborhood of `b` within `(-∞, b]`\n1. `s` is a neighborhood of `b` within `[a, b]`\n2. `s` is a neighborhood of `b` within `(a, b]`\n3. `s` includes `(l, b]` for some `l ∈ [a, b)`\n4. `s` includes `(l, b]` for some `l < b` -/\ntheorem tfae_mem_nhds_within_Iic {a b : α} (h : a < b) (s : set α) :\n    TFAE\n      [s ∈ nhds_within.le b,-- 0 : `s` is a neighborhood of `b` within `(-∞, b]`\n          s ∈\n          nhds_within (Icc a b) b,-- 1 : `s` is a neighborhood of `b` within `[a, b]`\n          s ∈\n          nhds_within (Ioc a b) b,-- 2 : `s` is a neighborhood of `b` within `(a, b]`\n        ∃ l ∈ Ico a b, Ioc l b ⊆ s,-- 3 : `s` includes `(l, b]` for some `l ∈ [a, b)`\n        ∃ l ∈ Iio b, Ioc l b ⊆ s] :=\n  by-- 4 : `s` includes `(l, b]` for some `l < b`\n  simpa only [exists_prop, order_dual.exists, dual_Ici, dual_Ioc, dual_Icc, dual_Ico] using\n    tfae_mem_nhds_within_Ici h.dual («expr ⁻¹' » of_dual s)\n#align tfae_mem_nhds_within_Iic tfae_mem_nhds_within_Iic\n\n",
 "tfae_mem_nhds_within_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers\n      [(Command.docComment\n        \"/--\"\n        \"The following statements are equivalent:\\n\\n0. `s` is a neighborhood of `a` within `[a, +∞)`\\n1. `s` is a neighborhood of `a` within `[a, b]`\\n2. `s` is a neighborhood of `a` within `[a, b)`\\n3. `s` includes `[a, u)` for some `u ∈ (a, b]`\\n4. `s` includes `[a, u)` for some `u > a` -/\")]\n      []\n      []\n      []\n      []\n      [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `tfae_mem_nhds_within_Ici [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`a `b] [\":\" `α] \"}\")\n        (Term.explicitBinder \"(\" [`hab] [\":\" («term_<_» `a \"<\" `b)] [] \")\")\n        (Term.explicitBinder \"(\" [`s] [\":\" (Term.app `set [`α])] [] \")\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(«term_∈_» `s \"∈\" (Term.app `nhds_within.ge [`a]))\n            \",\"\n            («term_∈_» `s \"∈\" (Term.app `nhds_within [(Term.app `Icc [`a `b]) `a]))\n            \",\"\n            («term_∈_» `s \"∈\" (Term.app `nhds_within [(Term.app `Ico [`a `b]) `a]))\n            \",\"\n            (Std.ExtendedBinder.«term∃__,_»\n             \"∃\"\n             (Lean.binderIdent `u)\n             («binderTerm∈_» \"∈\" (Term.app `Ioc [`a `b]))\n             \",\"\n             («term_⊆_» (Term.app `Ico [`a `u]) \"⊆\" `s))\n            \",\"\n            (Std.ExtendedBinder.«term∃__,_»\n             \"∃\"\n             (Lean.binderIdent `u)\n             («binderTerm∈_» \"∈\" (Term.app `Ioi [`a]))\n             \",\"\n             («term_⊆_» (Term.app `Ico [`a `u]) \"⊆\" `s))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"2\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] (Term.app `nhds_within_Icc_eq_nhds_within_Ici [`hab]))] \"]\")\n              [])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"3\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] (Term.app `nhds_within_Ico_eq_nhds_within_Ici [`hab]))] \"]\")\n              [])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"5\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.proj (Term.app `nhds_within_Ici_basis' [(Term.anonymousCtor \"⟨\" [`b \",\" `hab] \"⟩\")]) \".\" `mem_iff))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"5\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [(Term.anonymousCtor \"⟨\" [`u \",\" `umem \",\" `hu] \"⟩\")]\n              []\n              \"=>\"\n              (Term.anonymousCtor \"⟨\" [`u \",\" (Term.proj `umem \".\" (fieldIdx \"1\")) \",\" `hu] \"⟩\"))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `u)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hua)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hus)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Tactic.exact\n              \"exact\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [(Term.app `min [`u `b])\n                \",\"\n                (Term.anonymousCtor\n                 \"⟨\"\n                 [(Term.app `lt_min [`hua `hab]) \",\" (Term.app `min_le_right [(Term.hole \"_\") (Term.hole \"_\")])]\n                 \"⟩\")\n                \",\"\n                (Term.app\n                 (Term.proj\n                  («term_<|_» `Ico_subset_Ico_right \"<|\" (Term.app `min_le_left [(Term.hole \"_\") (Term.hole \"_\")]))\n                  \".\"\n                  `trans)\n                 [`hus])]\n               \"⟩\"))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"2\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] (Term.app `nhds_within_Icc_eq_nhds_within_Ici [`hab]))] \"]\")\n             [])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"3\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] (Term.app `nhds_within_Ico_eq_nhds_within_Ici [`hab]))] \"]\")\n             [])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"5\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.proj (Term.app `nhds_within_Ici_basis' [(Term.anonymousCtor \"⟨\" [`b \",\" `hab] \"⟩\")]) \".\" `mem_iff))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"5\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [(Term.anonymousCtor \"⟨\" [`u \",\" `umem \",\" `hu] \"⟩\")]\n             []\n             \"=>\"\n             (Term.anonymousCtor \"⟨\" [`u \",\" (Term.proj `umem \".\" (fieldIdx \"1\")) \",\" `hu] \"⟩\"))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `u)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hua)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hus)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [(Term.app `min [`u `b])\n               \",\"\n               (Term.anonymousCtor\n                \"⟨\"\n                [(Term.app `lt_min [`hua `hab]) \",\" (Term.app `min_le_right [(Term.hole \"_\") (Term.hole \"_\")])]\n                \"⟩\")\n               \",\"\n               (Term.app\n                (Term.proj\n                 («term_<|_» `Ico_subset_Ico_right \"<|\" (Term.app `min_le_left [(Term.hole \"_\") (Term.hole \"_\")]))\n                 \".\"\n                 `trans)\n                [`hus])]\n              \"⟩\"))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Std.Tactic.rintro\n         \"rintro\"\n         [(Std.Tactic.RCases.rintroPat.one\n           (Std.Tactic.RCases.rcasesPat.tuple\n            \"⟨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `u)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hua)])\n              [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hus)])\n              [])]\n            \"⟩\"))]\n         [])\n        []\n        (Tactic.exact\n         \"exact\"\n         (Term.anonymousCtor\n          \"⟨\"\n          [(Term.app `min [`u `b])\n           \",\"\n           (Term.anonymousCtor\n            \"⟨\"\n            [(Term.app `lt_min [`hua `hab]) \",\" (Term.app `min_le_right [(Term.hole \"_\") (Term.hole \"_\")])]\n            \"⟩\")\n           \",\"\n           (Term.app\n            (Term.proj\n             («term_<|_» `Ico_subset_Ico_right \"<|\" (Term.app `min_le_left [(Term.hole \"_\") (Term.hole \"_\")]))\n             \".\"\n             `trans)\n            [`hus])]\n          \"⟩\"))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact\n       \"exact\"\n       (Term.anonymousCtor\n        \"⟨\"\n        [(Term.app `min [`u `b])\n         \",\"\n         (Term.anonymousCtor\n          \"⟨\"\n          [(Term.app `lt_min [`hua `hab]) \",\" (Term.app `min_le_right [(Term.hole \"_\") (Term.hole \"_\")])]\n          \"⟩\")\n         \",\"\n         (Term.app\n          (Term.proj\n           («term_<|_» `Ico_subset_Ico_right \"<|\" (Term.app `min_le_left [(Term.hole \"_\") (Term.hole \"_\")]))\n           \".\"\n           `trans)\n          [`hus])]\n        \"⟩\"))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor\n       \"⟨\"\n       [(Term.app `min [`u `b])\n        \",\"\n        (Term.anonymousCtor\n         \"⟨\"\n         [(Term.app `lt_min [`hua `hab]) \",\" (Term.app `min_le_right [(Term.hole \"_\") (Term.hole \"_\")])]\n         \"⟩\")\n        \",\"\n        (Term.app\n         (Term.proj\n          («term_<|_» `Ico_subset_Ico_right \"<|\" (Term.app `min_le_left [(Term.hole \"_\") (Term.hole \"_\")]))\n          \".\"\n          `trans)\n         [`hus])]\n       \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app\n       (Term.proj\n        («term_<|_» `Ico_subset_Ico_right \"<|\" (Term.app `min_le_left [(Term.hole \"_\") (Term.hole \"_\")]))\n        \".\"\n        `trans)\n       [`hus])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hus\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      (Term.proj\n       («term_<|_» `Ico_subset_Ico_right \"<|\" (Term.app `min_le_left [(Term.hole \"_\") (Term.hole \"_\")]))\n       \".\"\n       `trans)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      («term_<|_» `Ico_subset_Ico_right \"<|\" (Term.app `min_le_left [(Term.hole \"_\") (Term.hole \"_\")]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `min_le_left [(Term.hole \"_\") (Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `min_le_left\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 10 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 10, term))\n      `Ico_subset_Ico_right\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 10, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 10, (some 10, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren\n     \"(\"\n     («term_<|_» `Ico_subset_Ico_right \"<|\" (Term.app `min_le_left [(Term.hole \"_\") (Term.hole \"_\")]))\n     \")\")\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor\n       \"⟨\"\n       [(Term.app `lt_min [`hua `hab]) \",\" (Term.app `min_le_right [(Term.hole \"_\") (Term.hole \"_\")])]\n       \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `min_le_right [(Term.hole \"_\") (Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `min_le_right\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `lt_min [`hua `hab])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hab\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hua\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `lt_min\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `min [`u `b])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `b\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `u\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `min\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rintro\n       \"rintro\"\n       [(Std.Tactic.RCases.rintroPat.one\n         (Std.Tactic.RCases.rcasesPat.tuple\n          \"⟨\"\n          [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `u)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hua)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hus)]) [])]\n          \"⟩\"))]\n       [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"4\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\n/--\n    The following statements are equivalent:\n    \n    0. `s` is a neighborhood of `a` within `[a, +∞)`\n    1. `s` is a neighborhood of `a` within `[a, b]`\n    2. `s` is a neighborhood of `a` within `[a, b)`\n    3. `s` includes `[a, u)` for some `u ∈ (a, b]`\n    4. `s` includes `[a, u)` for some `u > a` -/\n  theorem\n    tfae_mem_nhds_within_Ici\n    { a b : α } ( hab : a < b ) ( s : set α )\n      :\n        TFAE\n          [\n            s ∈ nhds_within.ge a\n              ,\n              s ∈ nhds_within Icc a b a\n              ,\n              s ∈ nhds_within Ico a b a\n              ,\n              ∃ u ∈ Ioc a b , Ico a u ⊆ s\n              ,\n              ∃ u ∈ Ioi a , Ico a u ⊆ s\n            ]\n    :=\n      by\n        tfae_have 1 ↔ 2\n          ;\n          · rw [ nhds_within_Icc_eq_nhds_within_Ici hab ]\n          tfae_have 1 ↔ 3\n          ;\n          · rw [ nhds_within_Ico_eq_nhds_within_Ici hab ]\n          tfae_have 1 ↔ 5\n          ;\n          exact nhds_within_Ici_basis' ⟨ b , hab ⟩ . mem_iff\n          tfae_have 4 → 5\n          ;\n          exact fun ⟨ u , umem , hu ⟩ => ⟨ u , umem . 1 , hu ⟩\n          tfae_have 5 → 4\n          ·\n            rintro ⟨ u , hua , hus ⟩\n              exact\n                ⟨\n                  min u b , ⟨ lt_min hua hab , min_le_right _ _ ⟩ , Ico_subset_Ico_right <| min_le_left _ _ . trans hus\n                  ⟩\n          tfae_finish\n#align tfae_mem_nhds_within_Ici tfae_mem_nhds_within_Ici\n\n",
 "tendsto_zero_iff_abs_tendsto_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_zero_iff_abs_tendsto_zero (f : β → α) {l : filter β} :\n    tendsto f l ((nhds) 0) ↔ tendsto (abs ∘ f) l ((nhds) 0) :=\n  by\n  refine' ⟨fun h => (abs_zero : |(0 : α)| = 0) ▸ h.abs, fun h => _⟩\n  have : tendsto (fun a => -|f a|) l ((nhds) 0) := (neg_zero : -(0 : α) = 0) ▸ h.neg\n  exact tendsto_of_tendsto_of_tendsto_of_le_of_le this h (fun x => neg_abs_le_self <| f x) fun x => le_abs_self <| f x\n#align tendsto_zero_iff_abs_tendsto_zero tendsto_zero_iff_abs_tendsto_zero\n\n",
 "tendsto_order_unbounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_order_unbounded {f : β → α} {a : α} {x : filter β} (hu : ∃ u, a < u) (hl : ∃ l, l < a)\n    (h :\n      ∀ l u,\n        l < a →\n          a < u →\n            «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" x\n              (l < f b ∧ f b < u)) :\n    tendsto f x ((nhds) a) := by\n  rw [nhds_order_unbounded hu hl] <;>\n    exact\n      tendsto_infi.2 fun l =>\n        tendsto_infi.2 fun hl => tendsto_infi.2 fun u => tendsto_infi.2 fun hu => tendsto_principal.2 <| h l u hl hu\n#align tendsto_order_unbounded tendsto_order_unbounded\n\n",
 "tendsto_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem tendsto_order {f : β → α} {a : α} {x : filter β} :\n    tendsto f x ((nhds) a) ↔\n      (∀ a' < a,\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" x\n            (a' < f b)) ∧\n        ∀ a' > a,\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" x\n            (f b < a') :=\n  by simp [nhds_eq_order a, tendsto_inf, tendsto_infi, tendsto_principal]\n#align tendsto_order tendsto_order\n\n",
 "tendsto_of_tendsto_of_tendsto_of_le_of_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities\nhold eventually for the filter. -/\ntheorem tendsto_of_tendsto_of_tendsto_of_le_of_le' {f g h : β → α} {b : filter β} {a : α} (hg : tendsto g b ((nhds) a))\n    (hh : tendsto h b ((nhds) a))\n    (hgf :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" b\n        (g b ≤ f b))\n    (hfh :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" b\n        (f b ≤ h b)) :\n    tendsto f b ((nhds) a) :=\n  (hg.Icc hh).of_small_sets <| hgf.and hfh\n#align tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_of_tendsto_of_tendsto_of_le_of_le'\n\n",
 "tendsto_of_tendsto_of_tendsto_of_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities\nhold everywhere. -/\ntheorem tendsto_of_tendsto_of_tendsto_of_le_of_le {f g h : β → α} {b : filter β} {a : α} (hg : tendsto g b ((nhds) a))\n    (hh : tendsto h b ((nhds) a)) (hgf : g ≤ f) (hfh : f ≤ h) : tendsto f b ((nhds) a) :=\n  tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh (eventually_of_forall hgf) (eventually_of_forall hfh)\n#align tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_of_tendsto_of_tendsto_of_le_of_le\n\n",
 "tendsto_nhds_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A monotone map has a limit to the right of any point `x`, equal to `Inf (f '' (Ioi x))`. -/\ntheorem monotone.tendsto_nhds_within_Ioi {α β : Type _} [linear_order α] [topological_space α] [order_topology α]\n    [ConditionallyCompleteLinearOrder β] [topological_space β] [order_topology β] {f : α → β} (Mf : monotone f)\n    (x : α) : tendsto f (nhds_within.gt x) ((nhds) (infₛ («expr '' » f (Ioi x)))) :=\n  @monotone.tendsto_nhds_within_Iio («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ _ _ _ _ f Mf.dual x\n#align monotone.tendsto_nhds_within_Ioi monotone.tendsto_nhds_within_Ioi\n\n",
 "tendsto_nhds_within_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A monotone map has a limit to the left of any point `x`, equal to `Sup (f '' (Iio x))`. -/\ntheorem monotone.tendsto_nhds_within_Iio {α β : Type _} [linear_order α] [topological_space α] [order_topology α]\n    [ConditionallyCompleteLinearOrder β] [topological_space β] [order_topology β] {f : α → β} (Mf : monotone f)\n    (x : α) : tendsto f (nhds_within.lt x) ((nhds) (supₛ («expr '' » f (Iio x)))) :=\n  by\n  rcases eq_empty_or_nonempty (Iio x) with (h | h); · simp [h]\n  refine' tendsto_order.2 ⟨fun l hl => _, fun m hm => _⟩\n  · obtain ⟨z, zx, lz⟩ : ∃ a : α, a < x ∧ l < f a := by\n      simpa only [mem_image, exists_prop, exists_exists_and_eq_and] using\n        exists_lt_of_lt_csupₛ (nonempty_image_iff.2 h) hl\n    exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' zx).2 ⟨z, zx, fun y hy => lz.trans_le (Mf hy.1.le)⟩\n  · filter_upwards [self_mem_nhds_within] with _ hy\n    apply lt_of_le_of_lt _ hm\n    exact le_csupₛ (Mf.map_bdd_above bddAbove_Iio) (mem_image_of_mem _ hy)\n#align monotone.tendsto_nhds_within_Iio monotone.tendsto_nhds_within_Iio\n\n",
 "tendsto_nhds_top_mono'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem tendsto_nhds_top_mono' [topological_space β] [preorder β] [OrderTop β] [order_topology β] {l : filter α}\n    {f g : α → β} (hf : tendsto f l ((nhds) («expr⊤»))) (hg : f ≤ g) : tendsto g l ((nhds) («expr⊤»)) :=\n  tendsto_nhds_top_mono hf (eventually_of_forall hg)\n#align tendsto_nhds_top_mono' tendsto_nhds_top_mono'\n\n",
 "tendsto_nhds_top_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem tendsto_nhds_top_mono [topological_space β] [preorder β] [OrderTop β] [order_topology β] {l : filter α}\n    {f g : α → β} (hf : tendsto f l ((nhds) («expr⊤»))) (hg : «expr ≤ᶠ[ ] » f l g) : tendsto g l ((nhds) («expr⊤»)) :=\n  by\n  simp only [nhds_top_order, tendsto_infi, tendsto_principal] at hf⊢\n  intro x hx\n  filter_upwards [hf x hx, hg] with _ using lt_of_lt_of_le\n#align tendsto_nhds_top_mono tendsto_nhds_top_mono\n\n",
 "tendsto_nhds_min_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem filter.tendsto_nhds_min_right {l : filter β} {a : α} (h : tendsto f l (nhds_within.lt a)) :\n    tendsto (fun i => min a (f i)) l (nhds_within.lt a) :=\n  @filter.tendsto_nhds_max_right («expr ᵒᵈ» α) β _ _ _ f l a h\n#align filter.tendsto_nhds_min_right filter.tendsto_nhds_min_right\n\n",
 "tendsto_nhds_min_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem filter.tendsto_nhds_min_left {l : filter β} {a : α} (h : tendsto f l (nhds_within.lt a)) :\n    tendsto (fun i => min (f i) a) l (nhds_within.lt a) :=\n  @filter.tendsto_nhds_max_left («expr ᵒᵈ» α) β _ _ _ f l a h\n#align filter.tendsto_nhds_min_left filter.tendsto_nhds_min_left\n\n",
 "tendsto_nhds_max_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem filter.tendsto_nhds_max_right {l : filter β} {a : α} (h : tendsto f l (nhds_within.gt a)) :\n    tendsto (fun i => max a (f i)) l (nhds_within.gt a) :=\n  by\n  obtain\n    ⟨h₁ : tendsto f l ((nhds) a), h₂ :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (f i ∈ Ioi a)⟩ :=\n    tendsto_nhds_within_iff.mp h\n  exact tendsto_nhds_within_iff.mpr ⟨h₁.max_right, h₂.mono fun i hi => lt_max_of_lt_right hi⟩\n#align filter.tendsto_nhds_max_right filter.tendsto_nhds_max_right\n\n",
 "tendsto_nhds_max_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem filter.tendsto_nhds_max_left {l : filter β} {a : α} (h : tendsto f l (nhds_within.gt a)) :\n    tendsto (fun i => max (f i) a) l (nhds_within.gt a) :=\n  by\n  simp_rw [max_comm _ a]\n  exact filter.tendsto_nhds_max_right h\n#align filter.tendsto_nhds_max_left filter.tendsto_nhds_max_left\n\n",
 "tendsto_nhds_bot_mono'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem tendsto_nhds_bot_mono' [topological_space β] [preorder β] [OrderBot β] [order_topology β] {l : filter α}\n    {f g : α → β} (hf : tendsto f l ((nhds) («expr⊥»))) (hg : g ≤ f) : tendsto g l ((nhds) («expr⊥»)) :=\n  tendsto_nhds_bot_mono hf (eventually_of_forall hg)\n#align tendsto_nhds_bot_mono' tendsto_nhds_bot_mono'\n\n",
 "tendsto_nhds_bot_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem tendsto_nhds_bot_mono [topological_space β] [preorder β] [OrderBot β] [order_topology β] {l : filter α}\n    {f g : α → β} (hf : tendsto f l ((nhds) («expr⊥»))) (hg : «expr ≤ᶠ[ ] » g l f) : tendsto g l ((nhds) («expr⊥»)) :=\n  @tendsto_nhds_top_mono α («expr ᵒᵈ» β) _ _ _ _ _ _ _ hf hg\n#align tendsto_nhds_bot_mono tendsto_nhds_bot_mono\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem linear_ordered_add_comm_group.tendsto_nhds {x : filter β} {a : α} :\n    tendsto f x ((nhds) a) ↔\n      ∀ ε > (0 : α),\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" x\n          (|f b - a| < ε) :=\n  by simp [nhds_eq_infi_abs_sub, abs_sub_comm a]\n#align linear_ordered_add_comm_group.tendsto_nhds linear_ordered_add_comm_group.tendsto_nhds\n\n",
 "tendsto_comp_coe_Ioo_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n@[simp]\ntheorem tendsto_comp_coe_Ioo_at_top (h : a < b) :\n    tendsto (fun x : Ioo a b => f x) at_top l ↔ tendsto f (nhds_within.lt b) l := by\n  rw [← map_coe_Ioo_at_top h, tendsto_map'_iff]\n#align tendsto_comp_coe_Ioo_at_top tendsto_comp_coe_Ioo_at_top\n\n",
 "tendsto_comp_coe_Ioo_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n@[simp]\ntheorem tendsto_comp_coe_Ioo_at_bot (h : a < b) :\n    tendsto (fun x : Ioo a b => f x) at_bot l ↔ tendsto f (nhds_within.gt a) l := by\n  rw [← map_coe_Ioo_at_bot h, tendsto_map'_iff]\n#align tendsto_comp_coe_Ioo_at_bot tendsto_comp_coe_Ioo_at_bot\n\n",
 "tendsto_comp_coe_Ioi_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n@[simp]\ntheorem tendsto_comp_coe_Ioi_at_bot : tendsto (fun x : Ioi a => f x) at_bot l ↔ tendsto f (nhds_within.gt a) l := by\n  rw [← map_coe_Ioi_at_bot, tendsto_map'_iff]\n#align tendsto_comp_coe_Ioi_at_bot tendsto_comp_coe_Ioi_at_bot\n\n",
 "tendsto_comp_coe_Iio_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n@[simp]\ntheorem tendsto_comp_coe_Iio_at_top : tendsto (fun x : Iio a => f x) at_top l ↔ tendsto f (nhds_within.lt a) l := by\n  rw [← map_coe_Iio_at_top, tendsto_map'_iff]\n#align tendsto_comp_coe_Iio_at_top tendsto_comp_coe_Iio_at_top\n\n",
 "tendsto_abs_nhds_within_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem tendsto_abs_nhds_within_zero : tendsto (abs : α → α) (nhds_within.ne 0) (nhds_within.gt 0) :=\n  (continuous_abs.tendsto' (0 : α) 0 abs_zero).inf <| tendsto_principal_principal.2 fun x => abs_pos.2\n#align tendsto_abs_nhds_within_zero tendsto_abs_nhds_within_zero\n\n",
 "tendsto_Ioo_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n@[simp]\ntheorem tendsto_Ioo_at_top {f : β → Ioo a b} : tendsto f l at_top ↔ tendsto (fun x => (f x : α)) l (nhds_within.lt b) :=\n  by rw [← comap_coe_Ioo_nhds_within_Iio, tendsto_comap_iff]\n#align tendsto_Ioo_at_top tendsto_Ioo_at_top\n\n",
 "tendsto_Ioo_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n@[simp]\ntheorem tendsto_Ioo_at_bot {f : β → Ioo a b} : tendsto f l at_bot ↔ tendsto (fun x => (f x : α)) l (nhds_within.gt a) :=\n  by rw [← comap_coe_Ioo_nhds_within_Ioi, tendsto_comap_iff]\n#align tendsto_Ioo_at_bot tendsto_Ioo_at_bot\n\n",
 "tendsto_Ioi_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n@[simp]\ntheorem tendsto_Ioi_at_bot {f : β → Ioi a} : tendsto f l at_bot ↔ tendsto (fun x => (f x : α)) l (nhds_within.gt a) :=\n  by rw [← comap_coe_Ioi_nhds_within_Ioi, tendsto_comap_iff]\n#align tendsto_Ioi_at_bot tendsto_Ioi_at_bot\n\n",
 "tendsto_Iio_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n@[simp]\ntheorem tendsto_Iio_at_top {f : β → Iio a} : tendsto f l at_top ↔ tendsto (fun x => (f x : α)) l (nhds_within.lt a) :=\n  by rw [← comap_coe_Iio_nhds_within_Iio, tendsto_comap_iff]\n#align tendsto_Iio_at_top tendsto_Iio_at_top\n\n",
 "right_nhds_within_Ioo_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem right_nhds_within_Ioo_ne_bot {a b : α} (H : a < b) : ne_bot (nhds_within (Ioo a b) b) :=\n  (isLUB_Ioo H).nhds_within_ne_bot (nonempty_Ioo.2 H)\n#align right_nhds_within_Ioo_ne_bot right_nhds_within_Ioo_ne_bot\n\n",
 "right_nhds_within_Ico_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem right_nhds_within_Ico_ne_bot {a b : α} (H : a < b) : ne_bot (nhds_within (Ico a b) b) :=\n  (isLUB_Ico H).nhds_within_ne_bot (nonempty_Ico.2 H)\n#align right_nhds_within_Ico_ne_bot right_nhds_within_Ico_ne_bot\n\n",
 "preimage_neg":
 "theorem preimage_neg [add_group α] : preimage (has_neg.neg : α → α) = image (has_neg.neg : α → α) :=\n  (image_eq_preimage_of_inverse neg_neg neg_neg).symm\n#align preimage_neg preimage_neg\n\n",
 "pi_Ioo_mem_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Ioo_mem_nhds' (ha : ∀ i, a' i < x' i) (hb : ∀ i, x' i < b' i) : Ioo a' b' ∈ (nhds) x' :=\n  pi_Ioo_mem_nhds ha hb\n#align pi_Ioo_mem_nhds' pi_Ioo_mem_nhds'\n\n",
 "pi_Ioo_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Ioo_mem_nhds (ha : ∀ i, a i < x i) (hb : ∀ i, x i < b i) : Ioo a b ∈ (nhds) x :=\n  by\n  refine' mem_of_superset (set_pi_mem_nhds (set.to_finite _) fun i _ => _) (pi_univ_Ioo_subset a b)\n  exact Ioo_mem_nhds (ha i) (hb i)\n#align pi_Ioo_mem_nhds pi_Ioo_mem_nhds\n\n",
 "pi_Ioi_mem_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Ioi_mem_nhds' (ha : ∀ i, a' i < x' i) : Ioi a' ∈ (nhds) x' :=\n  pi_Ioi_mem_nhds ha\n#align pi_Ioi_mem_nhds' pi_Ioi_mem_nhds'\n\n",
 "pi_Ioi_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Ioi_mem_nhds (ha : ∀ i, a i < x i) : Ioi a ∈ (nhds) x :=\n  @pi_Iio_mem_nhds ι (fun i => «expr ᵒᵈ» (π i)) _ _ _ _ _ _ _ ha\n#align pi_Ioi_mem_nhds pi_Ioi_mem_nhds\n\n",
 "pi_Ioc_mem_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Ioc_mem_nhds' (ha : ∀ i, a' i < x' i) (hb : ∀ i, x' i < b' i) : Ioc a' b' ∈ (nhds) x' :=\n  pi_Ioc_mem_nhds ha hb\n#align pi_Ioc_mem_nhds' pi_Ioc_mem_nhds'\n\n",
 "pi_Ioc_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Ioc_mem_nhds (ha : ∀ i, a i < x i) (hb : ∀ i, x i < b i) : Ioc a b ∈ (nhds) x :=\n  by\n  refine' mem_of_superset (set_pi_mem_nhds (set.to_finite _) fun i _ => _) (pi_univ_Ioc_subset a b)\n  exact Ioc_mem_nhds (ha i) (hb i)\n#align pi_Ioc_mem_nhds pi_Ioc_mem_nhds\n\n",
 "pi_Iio_mem_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Iio_mem_nhds' (ha : ∀ i, x' i < a' i) : Iio a' ∈ (nhds) x' :=\n  pi_Iio_mem_nhds ha\n#align pi_Iio_mem_nhds' pi_Iio_mem_nhds'\n\n",
 "pi_Iio_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Iio_mem_nhds (ha : ∀ i, x i < a i) : Iio a ∈ (nhds) x :=\n  by\n  refine' mem_of_superset (set_pi_mem_nhds (set.to_finite _) fun i _ => _) (pi_univ_Iio_subset a)\n  exact Iio_mem_nhds (ha i)\n#align pi_Iio_mem_nhds pi_Iio_mem_nhds\n\n",
 "pi_Iic_mem_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Iic_mem_nhds' (ha : ∀ i, x' i < a' i) : Iic a' ∈ (nhds) x' :=\n  pi_Iic_mem_nhds ha\n#align pi_Iic_mem_nhds' pi_Iic_mem_nhds'\n\n",
 "pi_Iic_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Iic_mem_nhds (ha : ∀ i, x i < a i) : Iic a ∈ (nhds) x :=\n  pi_univ_Iic a ▸ set_pi_mem_nhds (set.to_finite _) fun i _ => Iic_mem_nhds (ha _)\n#align pi_Iic_mem_nhds pi_Iic_mem_nhds\n\n",
 "pi_Ico_mem_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Ico_mem_nhds' (ha : ∀ i, a' i < x' i) (hb : ∀ i, x' i < b' i) : Ico a' b' ∈ (nhds) x' :=\n  pi_Ico_mem_nhds ha hb\n#align pi_Ico_mem_nhds' pi_Ico_mem_nhds'\n\n",
 "pi_Ico_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Ico_mem_nhds (ha : ∀ i, a i < x i) (hb : ∀ i, x i < b i) : Ico a b ∈ (nhds) x :=\n  by\n  refine' mem_of_superset (set_pi_mem_nhds (set.to_finite _) fun i _ => _) (pi_univ_Ico_subset a b)\n  exact Ico_mem_nhds (ha i) (hb i)\n#align pi_Ico_mem_nhds pi_Ico_mem_nhds\n\n",
 "pi_Ici_mem_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Ici_mem_nhds' (ha : ∀ i, a' i < x' i) : Ici a' ∈ (nhds) x' :=\n  pi_Ici_mem_nhds ha\n#align pi_Ici_mem_nhds' pi_Ici_mem_nhds'\n\n",
 "pi_Ici_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Ici_mem_nhds (ha : ∀ i, a i < x i) : Ici a ∈ (nhds) x :=\n  pi_univ_Ici a ▸ set_pi_mem_nhds (set.to_finite _) fun i _ => Ici_mem_nhds (ha _)\n#align pi_Ici_mem_nhds pi_Ici_mem_nhds\n\n",
 "pi_Icc_mem_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Icc_mem_nhds' (ha : ∀ i, a' i < x' i) (hb : ∀ i, x' i < b' i) : Icc a' b' ∈ (nhds) x' :=\n  pi_Icc_mem_nhds ha hb\n#align pi_Icc_mem_nhds' pi_Icc_mem_nhds'\n\n",
 "pi_Icc_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pi_Icc_mem_nhds (ha : ∀ i, a i < x i) (hb : ∀ i, x i < b i) : Icc a b ∈ (nhds) x :=\n  pi_univ_Icc a b ▸ set_pi_mem_nhds finite_univ fun i _ => Icc_mem_nhds (ha _) (hb _)\n#align pi_Icc_mem_nhds pi_Icc_mem_nhds\n\n",
 "order_topology_of_nhds_abs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem order_topology_of_nhds_abs {α : Type _} [topological_space α] [LinearOrderedAddCommGroup α]\n    (h_nhds :\n      ∀ a : α,\n        (nhds) a =\n          «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            ((filter.principal) { b | |a - b| < r })) :\n    order_topology α := by\n  refine' ⟨eq_of_nhds_eq_nhds fun a => _⟩\n  rw [h_nhds]\n  letI := preorder.topology α; letI : order_topology α := ⟨rfl⟩\n  exact (nhds_eq_infi_abs_sub a).symm\n#align order_topology_of_nhds_abs order_topology_of_nhds_abs\n\n",
 "order_separated":
 "theorem order_separated {a₁ a₂ : α} (h : a₁ < a₂) :\n    ∃ u v : set α, is_open u ∧ is_open v ∧ a₁ ∈ u ∧ a₂ ∈ v ∧ ∀ b₁ ∈ u, ∀ b₂ ∈ v, b₁ < b₂ :=\n  match dense_or_discrete a₁ a₂ with\n  | or.inl ⟨a, ha₁, ha₂⟩ =>\n    ⟨{ a' | a' < a }, { a' | a < a' }, is_open_gt' a, is_open_lt' a, ha₁, ha₂, fun b₁ h₁ b₂ h₂ => lt_trans h₁ h₂⟩\n  | or.inr ⟨h₁, h₂⟩ =>\n    ⟨{ a | a < a₂ }, { a | a₁ < a }, is_open_gt' a₂, is_open_lt' a₁, h, h, fun b₁ hb₁ b₂ hb₂ =>\n      calc\n        b₁ ≤ a₁ := h₂ _ hb₁\n        _ < a₂ := h\n        _ ≤ b₂ := h₁ _ hb₂\n        ⟩\n#align order_separated order_separated\n\n",
 "order_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Yury Kudryashov\n-/\ntheorem dense.order_dual [topological_space α] {s : set α} (hs : dense s) : dense («expr ⁻¹' » OrderDual.ofDual s) :=\n  hs\n#align dense.order_dual dense.order_dual\n\n",
 "not_tendsto_nhds_of_tendsto_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem not_tendsto_nhds_of_tendsto_at_top [NoMaxOrder α] {F : filter β} [ne_bot F] {f : β → α}\n    (hf : tendsto f F at_top) (x : α) : ¬tendsto f F ((nhds) x) :=\n  hf.not_tendsto (disjoint_nhds_at_top x).symm\n#align not_tendsto_nhds_of_tendsto_at_top not_tendsto_nhds_of_tendsto_at_top\n\n",
 "not_tendsto_nhds_of_tendsto_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem not_tendsto_nhds_of_tendsto_at_bot [NoMinOrder α] {F : filter β} [ne_bot F] {f : β → α}\n    (hf : tendsto f F at_bot) (x : α) : ¬tendsto f F ((nhds) x) :=\n  hf.not_tendsto (disjoint_nhds_at_bot x).symm\n#align not_tendsto_nhds_of_tendsto_at_bot not_tendsto_nhds_of_tendsto_at_bot\n\n",
 "not_tendsto_at_top_of_tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem not_tendsto_at_top_of_tendsto_nhds [NoMaxOrder α] {F : filter β} [ne_bot F] {f : β → α} {x : α}\n    (hf : tendsto f F ((nhds) x)) : ¬tendsto f F at_top :=\n  hf.not_tendsto (disjoint_nhds_at_top x)\n#align not_tendsto_at_top_of_tendsto_nhds not_tendsto_at_top_of_tendsto_nhds\n\n",
 "not_tendsto_at_bot_of_tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem not_tendsto_at_bot_of_tendsto_nhds [NoMinOrder α] {F : filter β} [ne_bot F] {f : β → α} {x : α}\n    (hf : tendsto f F ((nhds) x)) : ¬tendsto f F at_bot :=\n  hf.not_tendsto (disjoint_nhds_at_bot x)\n#align not_tendsto_at_bot_of_tendsto_nhds not_tendsto_at_bot_of_tendsto_nhds\n\n",
 "nhds_within_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem is_glb.nhds_within_ne_bot : ∀ {a : α} {s : set α}, IsGLB s a → s.nonempty → ne_bot (nhds_within s a) :=\n  @is_lub.nhds_within_ne_bot («expr ᵒᵈ» α) _ _ _\n#align is_glb.nhds_within_ne_bot is_glb.nhds_within_ne_bot\n\n",
 "nhds_within_Ioo_eq_nhds_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n@[simp]\ntheorem nhds_within_Ioo_eq_nhds_within_Ioi {a b : α} (h : a < b) : nhds_within (Ioo a b) a = nhds_within.gt a :=\n  le_antisymm (nhds_within_mono _ Ioo_subset_Ioi_self) <|\n    nhds_within_le_of_mem <| Ioo_mem_nhds_within_Ioi <| left_mem_Ico.2 h\n#align nhds_within_Ioo_eq_nhds_within_Ioi nhds_within_Ioo_eq_nhds_within_Ioi\n\n",
 "nhds_within_Ioo_eq_nhds_within_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n@[simp]\ntheorem nhds_within_Ioo_eq_nhds_within_Iio {a b : α} (h : a < b) : nhds_within (Ioo a b) b = nhds_within.lt b := by\n  simpa only [dual_Ioo] using nhds_within_Ioo_eq_nhds_within_Ioi h.dual\n#align nhds_within_Ioo_eq_nhds_within_Iio nhds_within_Ioo_eq_nhds_within_Iio\n\n",
 "nhds_within_Ioi_self_ne_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem nhds_within_Ioi_self_ne_bot' {a : α} (H : (Ioi a).nonempty) : ne_bot (nhds_within.gt a) :=\n  nhds_within_Ioi_ne_bot' H (le_refl a)\n#align nhds_within_Ioi_self_ne_bot' nhds_within_Ioi_self_ne_bot'\n\n",
 "nhds_within_Ioi_self_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n@[instance]\ntheorem nhds_within_Ioi_self_ne_bot [NoMaxOrder α] (a : α) : ne_bot (nhds_within.gt a) :=\n  nhds_within_Ioi_ne_bot (le_refl a)\n#align nhds_within_Ioi_self_ne_bot nhds_within_Ioi_self_ne_bot\n\n",
 "nhds_within_Ioi_ne_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem nhds_within_Ioi_ne_bot' {a b : α} (H₁ : (Ioi a).nonempty) (H₂ : a ≤ b) : ne_bot (nhds_within (Ioi a) b) :=\n  mem_closure_iff_nhds_within_ne_bot.1 <| by rwa [closure_Ioi' H₁]\n#align nhds_within_Ioi_ne_bot' nhds_within_Ioi_ne_bot'\n\n",
 "nhds_within_Ioi_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem nhds_within_Ioi_ne_bot [NoMaxOrder α] {a b : α} (H : a ≤ b) : ne_bot (nhds_within (Ioi a) b) :=\n  nhds_within_Ioi_ne_bot' nonempty_Ioi H\n#align nhds_within_Ioi_ne_bot nhds_within_Ioi_ne_bot\n\n",
 "nhds_within_Ioc_eq_nhds_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n@[simp]\ntheorem nhds_within_Ioc_eq_nhds_within_Ioi {a b : α} (h : a < b) : nhds_within (Ioc a b) a = nhds_within.gt a :=\n  le_antisymm (nhds_within_mono _ Ioc_subset_Ioi_self) <|\n    nhds_within_le_of_mem <| Ioc_mem_nhds_within_Ioi <| left_mem_Ico.2 h\n#align nhds_within_Ioc_eq_nhds_within_Ioi nhds_within_Ioc_eq_nhds_within_Ioi\n\n",
 "nhds_within_Ioc_eq_nhds_within_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n@[simp]\ntheorem nhds_within_Ioc_eq_nhds_within_Iic {a b : α} (h : a < b) : nhds_within (Ioc a b) b = nhds_within.le b := by\n  simpa only [dual_Ico] using nhds_within_Ico_eq_nhds_within_Ici h.dual\n#align nhds_within_Ioc_eq_nhds_within_Iic nhds_within_Ioc_eq_nhds_within_Iic\n\n",
 "nhds_within_Iio_self_ne_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem nhds_within_Iio_self_ne_bot' {b : α} (H : (Iio b).nonempty) : ne_bot (nhds_within.lt b) :=\n  nhds_within_Iio_ne_bot' H (le_refl b)\n#align nhds_within_Iio_self_ne_bot' nhds_within_Iio_self_ne_bot'\n\n",
 "nhds_within_Iio_self_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n@[instance]\ntheorem nhds_within_Iio_self_ne_bot [NoMinOrder α] (a : α) : ne_bot (nhds_within.lt a) :=\n  nhds_within_Iio_ne_bot (le_refl a)\n#align nhds_within_Iio_self_ne_bot nhds_within_Iio_self_ne_bot\n\n",
 "nhds_within_Iio_ne_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem nhds_within_Iio_ne_bot' {b c : α} (H₁ : (Iio c).nonempty) (H₂ : b ≤ c) : ne_bot (nhds_within (Iio c) b) :=\n  mem_closure_iff_nhds_within_ne_bot.1 <| by rwa [closure_Iio' H₁]\n#align nhds_within_Iio_ne_bot' nhds_within_Iio_ne_bot'\n\n",
 "nhds_within_Iio_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem nhds_within_Iio_ne_bot [NoMinOrder α] {a b : α} (H : a ≤ b) : ne_bot (nhds_within (Iio b) a) :=\n  nhds_within_Iio_ne_bot' nonempty_Iio H\n#align nhds_within_Iio_ne_bot nhds_within_Iio_ne_bot\n\n",
 "nhds_within_Iic_self_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n@[instance]\ntheorem nhds_within_Iic_self_ne_bot (a : α) : ne_bot (nhds_within.le a) :=\n  nhds_within_Iic_ne_bot (le_refl a)\n#align nhds_within_Iic_self_ne_bot nhds_within_Iic_self_ne_bot\n\n",
 "nhds_within_Iic_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem nhds_within_Iic_ne_bot {a b : α} (H : a ≤ b) : ne_bot (nhds_within (Iic b) a) :=\n  nhds_within_ne_bot_of_mem H\n#align nhds_within_Iic_ne_bot nhds_within_Iic_ne_bot\n\n",
 "nhds_within_Iic_eq''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_within_Iic_eq'' [topological_space α] [preorder α] [order_topology α] (a : α) :\n    nhds_within.le a =\n      «expr ⊓ »\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          ((filter.principal) (Ioi l)))\n        ((filter.principal) (Iic a)) :=\n  nhds_within_Ici_eq'' (toDual a)\n#align nhds_within_Iic_eq'' nhds_within_Iic_eq''\n\n",
 "nhds_within_Iic_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_within_Iic_eq' [topological_space α] [preorder α] [order_topology α] {a : α} (ha : ∃ l, l < a) :\n    nhds_within.le a =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (Ioc l a)) :=\n  by simp only [nhds_within_Iic_eq'', binfᵢ_inf ha, inf_principal, Ioi_inter_Iic]\n#align nhds_within_Iic_eq' nhds_within_Iic_eq'\n\n",
 "nhds_within_Iic_basis'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\ntheorem nhds_within_Iic_basis' [topological_space α] [linear_order α] [order_topology α] {a : α} (ha : ∃ l, l < a) :\n    (nhds_within.le a).has_basis (fun l => l < a) fun l => Ioc l a :=\n  by\n  convert @nhds_within_Ici_basis' («expr ᵒᵈ» α) _ _ _ (to_dual a) ha\n  exact funext fun x => (@dual_Ico _ _ _ _).symm\n#align nhds_within_Iic_basis' nhds_within_Iic_basis'\n\n",
 "nhds_within_Iic_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\ntheorem nhds_within_Iic_basis [topological_space α] [linear_order α] [order_topology α] [NoMinOrder α] (a : α) :\n    (nhds_within.le a).has_basis (fun l => l < a) fun l => Ioc l a :=\n  nhds_within_Iic_basis' (exists_lt a)\n#align nhds_within_Iic_basis nhds_within_Iic_basis\n\n",
 "nhds_within_Ico_eq_nhds_within_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n@[simp]\ntheorem nhds_within_Ico_eq_nhds_within_Iio {a b : α} (h : a < b) : nhds_within (Ico a b) b = nhds_within.lt b := by\n  simpa only [dual_Ioc] using nhds_within_Ioc_eq_nhds_within_Ioi h.dual\n#align nhds_within_Ico_eq_nhds_within_Iio nhds_within_Ico_eq_nhds_within_Iio\n\n",
 "nhds_within_Ico_eq_nhds_within_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n@[simp]\ntheorem nhds_within_Ico_eq_nhds_within_Ici {a b : α} (h : a < b) : nhds_within (Ico a b) a = nhds_within.ge a :=\n  le_antisymm (nhds_within_mono _ fun x => And.left) <|\n    nhds_within_le_of_mem <| Ico_mem_nhds_within_Ici <| left_mem_Ico.2 h\n#align nhds_within_Ico_eq_nhds_within_Ici nhds_within_Ico_eq_nhds_within_Ici\n\n",
 "nhds_within_Ici_self_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n@[instance]\ntheorem nhds_within_Ici_self_ne_bot (a : α) : ne_bot (nhds_within.ge a) :=\n  nhds_within_Ici_ne_bot (le_refl a)\n#align nhds_within_Ici_self_ne_bot nhds_within_Ici_self_ne_bot\n\n",
 "nhds_within_Ici_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem nhds_within_Ici_ne_bot {a b : α} (H₂ : a ≤ b) : ne_bot (nhds_within (Ici a) b) :=\n  nhds_within_ne_bot_of_mem H₂\n#align nhds_within_Ici_ne_bot nhds_within_Ici_ne_bot\n\n",
 "nhds_within_Ici_eq''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n-- here we use the `ord_connected` hypothesis\n-- here we use the `ord_connected` hypothesis\ntheorem nhds_within_Ici_eq'' [topological_space α] [preorder α] [order_topology α] (a : α) :\n    nhds_within.ge a =\n      «expr ⊓ »\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          ((filter.principal) (Iio u)))\n        ((filter.principal) (Ici a)) :=\n  by\n  rw [nhds_within, nhds_eq_order]\n  refine' le_antisymm (inf_le_inf_right _ inf_le_right) (le_inf (le_inf _ inf_le_left) inf_le_right)\n  exact inf_le_right.trans (le_infᵢ₂ fun l hl => principal_mono.2 <| Ici_subset_Ioi.2 hl)\n#align nhds_within_Ici_eq'' nhds_within_Ici_eq''\n\n",
 "nhds_within_Ici_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_within_Ici_eq' [topological_space α] [preorder α] [order_topology α] {a : α} (ha : ∃ u, a < u) :\n    nhds_within.ge a =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (Ico a u)) :=\n  by simp only [nhds_within_Ici_eq'', binfᵢ_inf ha, inf_principal, Iio_inter_Ici]\n#align nhds_within_Ici_eq' nhds_within_Ici_eq'\n\n",
 "nhds_within_Ici_basis_Ico":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\ntheorem nhds_within_Ici_basis_Ico [NoMaxOrder α] (a : α) : (nhds_within.ge a).has_basis (fun u => a < u) (Ico a) :=\n  ⟨fun s => mem_nhds_within_Ici_iff_exists_Ico_subset⟩\n#align nhds_within_Ici_basis_Ico nhds_within_Ici_basis_Ico\n\n",
 "nhds_within_Ici_basis'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\ntheorem nhds_within_Ici_basis' [topological_space α] [linear_order α] [order_topology α] {a : α} (ha : ∃ u, a < u) :\n    (nhds_within.ge a).has_basis (fun u => a < u) fun u => Ico a u :=\n  (nhds_within_Ici_eq' ha).symm ▸\n    has_basis_binfi_principal\n      (fun b hb c hc =>\n        ⟨min b c, lt_min hb hc, Ico_subset_Ico_right (min_le_left _ _), Ico_subset_Ico_right (min_le_right _ _)⟩)\n      ha\n#align nhds_within_Ici_basis' nhds_within_Ici_basis'\n\n",
 "nhds_within_Ici_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\ntheorem nhds_within_Ici_basis [topological_space α] [linear_order α] [order_topology α] [NoMaxOrder α] (a : α) :\n    (nhds_within.ge a).has_basis (fun u => a < u) fun u => Ico a u :=\n  nhds_within_Ici_basis' (exists_gt a)\n#align nhds_within_Ici_basis nhds_within_Ici_basis\n\n",
 "nhds_within_Icc_eq_nhds_within_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n@[simp]\ntheorem nhds_within_Icc_eq_nhds_within_Iic {a b : α} (h : a < b) : nhds_within (Icc a b) b = nhds_within.le b := by\n  simpa only [dual_Icc] using nhds_within_Icc_eq_nhds_within_Ici h.dual\n#align nhds_within_Icc_eq_nhds_within_Iic nhds_within_Icc_eq_nhds_within_Iic\n\n",
 "nhds_within_Icc_eq_nhds_within_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n@[simp]\ntheorem nhds_within_Icc_eq_nhds_within_Ici {a b : α} (h : a < b) : nhds_within (Icc a b) a = nhds_within.ge a :=\n  le_antisymm (nhds_within_mono _ Icc_subset_Ici_self) <|\n    nhds_within_le_of_mem <| Icc_mem_nhds_within_Ici <| left_mem_Ico.2 h\n#align nhds_within_Icc_eq_nhds_within_Ici nhds_within_Icc_eq_nhds_within_Ici\n\n",
 "nhds_top_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_top_order [topological_space α] [preorder α] [OrderTop α] [order_topology α] :\n    (nhds) («expr⊤» : α) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (Ioi l)) :=\n  by simp [nhds_eq_order («expr⊤» : α)]\n#align nhds_top_order nhds_top_order\n\n",
 "nhds_top_basis_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem nhds_top_basis_Ici [topological_space α] [linear_order α] [OrderTop α] [order_topology α] [nontrivial α]\n    [DenselyOrdered α] : ((nhds) («expr⊤»)).has_basis (fun a : α => a < «expr⊤») Ici :=\n  nhds_top_basis.to_has_basis\n    (fun a ha =>\n      let ⟨b, hab, hb⟩ := exists_between ha\n      ⟨b, hb, Ici_subset_Ioi.mpr hab⟩)\n    fun a ha => ⟨a, ha, Ioi_subset_Ici_self⟩\n#align nhds_top_basis_Ici nhds_top_basis_Ici\n\n",
 "nhds_top_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem nhds_top_basis [topological_space α] [linear_order α] [OrderTop α] [order_topology α] [nontrivial α] :\n    ((nhds) («expr⊤»)).has_basis (fun a : α => a < «expr⊤») fun a : α => Ioi a :=\n  by\n  have : ∃ x : α, x < «expr⊤» := (exists_ne («expr⊤»)).imp fun x hx => hx.lt_top\n  simpa only [Iic_top, nhds_within_univ, Ioc_top] using nhds_within_Iic_basis' this\n#align nhds_top_basis nhds_top_basis\n\n",
 "nhds_order_unbounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_order_unbounded {a : α} (hu : ∃ u, a < u) (hl : ∃ l, l < a) :\n    (nhds) a =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (Ioo l u)) :=\n  by\n  have : ∃ u, u ∈ Ioi a := hu\n  have : ∃ l, l ∈ Iio a := hl\n  simp only [nhds_eq_order, inf_binfᵢ, binfᵢ_inf, *, inf_principal, Ioi_inter_Iio]\n  rfl\n#align nhds_order_unbounded nhds_order_unbounded\n\n",
 "nhds_eq_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_eq_order (a : α) :\n    (nhds) a =\n      «expr ⊓ »\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          ((filter.principal) (Ioi b)))\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          ((filter.principal) (Iio b))) :=\n  by\n  rw [t.topology_eq_generate_intervals, nhds_generate_from] <;>\n    exact\n      le_antisymm\n        (le_inf (le_infᵢ₂ fun b hb => infᵢ_le_of_le { c : α | b < c } <| infᵢ_le _ ⟨hb, b, or.inl rfl⟩)\n          (le_infᵢ₂ fun b hb => infᵢ_le_of_le { c : α | c < b } <| infᵢ_le _ ⟨hb, b, or.inr rfl⟩))\n        (le_infᵢ fun s =>\n          le_infᵢ fun ⟨ha, b, hs⟩ =>\n            match s, ha, hs with\n            | _, h, or.inl rfl => inf_le_of_left_le <| infᵢ_le_of_le b <| infᵢ_le _ h\n            | _, h, or.inr rfl => inf_le_of_right_le <| infᵢ_le_of_le b <| infᵢ_le _ h)\n#align nhds_eq_order nhds_eq_order\n\n",
 "nhds_eq_infi_abs_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_eq_infi_abs_sub (a : α) :\n    (nhds) a =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) { b | |a - b| < r }) :=\n  by\n  simp only [le_antisymm_iff, nhds_eq_order, le_inf_iff, le_infᵢ_iff, le_principal_iff, mem_Ioi, mem_Iio,\n    abs_sub_lt_iff, @sub_lt_iff_lt_add _ _ _ _ _ _ a, @sub_lt_comm _ _ _ _ a, set_of_and]\n  refine' ⟨_, _, _⟩\n  · intro ε ε0\n    exact\n      inter_mem_inf (mem_infi_of_mem (a - ε) <| mem_infi_of_mem (sub_lt_self a ε0) (mem_principal_self _))\n        (mem_infi_of_mem (ε + a) <| mem_infi_of_mem (by simpa) (mem_principal_self _))\n  · intro b hb\n    exact mem_infi_of_mem (a - b) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Ioi]))\n  · intro b hb\n    exact mem_infi_of_mem (b - a) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Iio]))\n#align nhds_eq_infi_abs_sub nhds_eq_infi_abs_sub\n\n",
 "nhds_bot_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_bot_order [topological_space α] [preorder α] [OrderBot α] [order_topology α] :\n    (nhds) («expr⊥» : α) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (Iio l)) :=\n  by simp [nhds_eq_order («expr⊥» : α)]\n#align nhds_bot_order nhds_bot_order\n\n",
 "nhds_bot_basis_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem nhds_bot_basis_Iic [topological_space α] [linear_order α] [OrderBot α] [order_topology α] [nontrivial α]\n    [DenselyOrdered α] : ((nhds) («expr⊥»)).has_basis (fun a : α => «expr⊥» < a) Iic :=\n  @nhds_top_basis_Ici («expr ᵒᵈ» α) _ _ _ _ _ _\n#align nhds_bot_basis_Iic nhds_bot_basis_Iic\n\n",
 "nhds_bot_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem nhds_bot_basis [topological_space α] [linear_order α] [OrderBot α] [order_topology α] [nontrivial α] :\n    ((nhds) («expr⊥»)).has_basis (fun a : α => «expr⊥» < a) fun a : α => Iio a :=\n  @nhds_top_basis («expr ᵒᵈ» α) _ _ _ _ _\n#align nhds_bot_basis nhds_bot_basis\n\n",
 "nhds_basis_zero_abs_sub_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_zero_abs_sub_lt [NoMinOrder α] [NoMaxOrder α] :\n    ((nhds) (0 : α)).has_basis (fun ε : α => (0 : α) < ε) fun ε => { b | |b| < ε } := by\n  simpa using nhds_basis_abs_sub_lt (0 : α)\n#align nhds_basis_zero_abs_sub_lt nhds_basis_zero_abs_sub_lt\n\n",
 "nhds_basis_abs_sub_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_abs_sub_lt [NoMinOrder α] [NoMaxOrder α] (a : α) :\n    ((nhds) a).has_basis (fun ε : α => (0 : α) < ε) fun ε => { b | |b - a| < ε } :=\n  by\n  convert nhds_basis_Ioo_pos a\n  · ext ε\n    change |x - a| < ε ↔ a - ε < x ∧ x < a + ε\n    simp [abs_lt, sub_lt_iff_lt_add, add_comm ε a, add_comm x ε]\n#align nhds_basis_abs_sub_lt nhds_basis_abs_sub_lt\n\n",
 "nhds_basis_Ioo_pos_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `a` is positive we can form a basis from only nonnegative `Ioo` intervals -/\ntheorem nhds_basis_Ioo_pos_of_pos [NoMinOrder α] [NoMaxOrder α] {a : α} (ha : 0 < a) :\n    ((nhds) a).has_basis (fun ε : α => (0 : α) < ε ∧ ε ≤ a) fun ε => Ioo (a - ε) (a + ε) :=\n  ⟨fun t =>\n    (nhds_basis_Ioo_pos a).mem_iff.trans\n      ⟨fun h =>\n        let ⟨i, hi, hit⟩ := h\n        ⟨min i a, ⟨lt_min hi ha, min_le_right i a⟩,\n          trans (Ioo_subset_Ioo (sub_le_sub_left (min_le_left i a) a) (add_le_add_left (min_le_left i a) a)) hit⟩,\n        fun h =>\n        let ⟨i, hi, hit⟩ := h\n        ⟨i, hi.1, hit⟩⟩⟩\n#align nhds_basis_Ioo_pos_of_pos nhds_basis_Ioo_pos_of_pos\n\n",
 "nhds_basis_Ioo_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_Ioo_pos [NoMinOrder α] [NoMaxOrder α] (a : α) :\n    ((nhds) a).has_basis (fun ε : α => (0 : α) < ε) fun ε => Ioo (a - ε) (a + ε) :=\n  ⟨by\n    refine' fun t => (nhds_basis_Ioo a).mem_iff.trans ⟨_, _⟩\n    · rintro ⟨⟨l, u⟩, ⟨hl : l < a, hu : a < u⟩, h' : Ioo l u ⊆ t⟩\n      refine' ⟨min (a - l) (u - a), by apply lt_min <;> rwa [sub_pos], _⟩\n      rintro x ⟨hx, hx'⟩\n      apply h'\n      rw [sub_lt_comm, lt_min_iff, sub_lt_sub_iff_left] at hx\n      rw [← sub_lt_iff_lt_add', lt_min_iff, sub_lt_sub_iff_right] at hx'\n      exact ⟨hx.1, hx'.2⟩\n    · rintro ⟨ε, ε_pos, h⟩\n      exact ⟨(a - ε, a + ε), by simp [ε_pos], h⟩⟩\n#align nhds_basis_Ioo_pos nhds_basis_Ioo_pos\n\n",
 "nhds_basis_Ioo'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_Ioo' {a : α} (hl : ∃ l, l < a) (hu : ∃ u, a < u) :\n    ((nhds) a).has_basis (fun b : α × α => b.1 < a ∧ a < b.2) fun b => Ioo b.1 b.2 :=\n  ⟨fun s => (mem_nhds_iff_exists_Ioo_subset' hl hu).trans <| by simp⟩\n#align nhds_basis_Ioo' nhds_basis_Ioo'\n\n",
 "nhds_basis_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_Ioo [NoMaxOrder α] [NoMinOrder α] (a : α) :\n    ((nhds) a).has_basis (fun b : α × α => b.1 < a ∧ a < b.2) fun b => Ioo b.1 b.2 :=\n  nhds_basis_Ioo' (exists_lt a) (exists_gt a)\n#align nhds_basis_Ioo nhds_basis_Ioo\n\n",
 "min_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.min_right {l : filter β} {a : α} (h : tendsto f l ((nhds) a)) :\n    tendsto (fun i => min a (f i)) l ((nhds) a) :=\n  @filter.tendsto.max_right («expr ᵒᵈ» α) β _ _ _ f l a h\n#align filter.tendsto.min_right filter.tendsto.min_right\n\n",
 "min_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.min_left {l : filter β} {a : α} (h : tendsto f l ((nhds) a)) :\n    tendsto (fun i => min (f i) a) l ((nhds) a) :=\n  @filter.tendsto.max_left («expr ᵒᵈ» α) β _ _ _ f l a h\n#align filter.tendsto.min_left filter.tendsto.min_left\n\n",
 "min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.min {b : filter β} {a₁ a₂ : α} (hf : tendsto f b ((nhds) a₁)) (hg : tendsto g b ((nhds) a₂)) :\n    tendsto (fun b => min (f b) (g b)) b ((nhds) (min a₁ a₂)) :=\n  (continuous_min.tendsto (a₁, a₂)).comp (hf.prod_mk_nhds hg)\n#align filter.tendsto.min filter.tendsto.min\n\n",
 "mem_upper_bounds_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_glb.mem_upper_bounds_of_tendsto [preorder γ] [topological_space γ] [order_closed_topology γ] {f : α → γ}\n    {s : set α} {a : α} {b : γ} (hf : antitone_on f s) (ha : IsGLB s a) (hb : tendsto f (nhds_within s a) ((nhds) b)) :\n    b ∈ upperBounds («expr '' » f s) :=\n  @is_glb.mem_lower_bounds_of_tendsto α («expr ᵒᵈ» γ) _ _ _ _ _ _ _ _ _ _ hf ha hb\n#align is_glb.mem_upper_bounds_of_tendsto is_glb.mem_upper_bounds_of_tendsto\n\n",
 "mem_of_is_closed":
 "theorem is_glb.mem_of_is_closed {a : α} {s : set α} (ha : IsGLB s a) (hs : s.nonempty) (sc : is_closed s) : a ∈ s :=\n  sc.closure_subset <| ha.mem_closure hs\n#align is_glb.mem_of_is_closed is_glb.mem_of_is_closed\n\n",
 "mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset {a u' : α} {s : set α} (hu' : a < u') :\n    s ∈ nhds_within.gt a ↔ ∃ u ∈ Ioc a u', Ioo a u ⊆ s :=\n  (tfae_mem_nhds_within_Ioi hu' s).out 0 3\n#align mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset\n\n",
 "mem_nhds_within_Ioi_iff_exists_Ioo_subset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/-- A set is a neighborhood of `a` within `(a, +∞)` if and only if it contains an interval `(a, u)`\nwith `a < u < u'`, provided `a` is not a top element. -/\ntheorem mem_nhds_within_Ioi_iff_exists_Ioo_subset' {a u' : α} {s : set α} (hu' : a < u') :\n    s ∈ nhds_within.gt a ↔ ∃ u ∈ Ioi a, Ioo a u ⊆ s :=\n  (tfae_mem_nhds_within_Ioi hu' s).out 0 4\n#align mem_nhds_within_Ioi_iff_exists_Ioo_subset' mem_nhds_within_Ioi_iff_exists_Ioo_subset'\n\n",
 "mem_nhds_within_Ioi_iff_exists_Ioo_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/-- A set is a neighborhood of `a` within `(a, +∞)` if and only if it contains an interval `(a, u)`\nwith `a < u`. -/\ntheorem mem_nhds_within_Ioi_iff_exists_Ioo_subset [NoMaxOrder α] {a : α} {s : set α} :\n    s ∈ nhds_within.gt a ↔ ∃ u ∈ Ioi a, Ioo a u ⊆ s :=\n  let ⟨u', hu'⟩ := exists_gt a\n  mem_nhds_within_Ioi_iff_exists_Ioo_subset' hu'\n#align mem_nhds_within_Ioi_iff_exists_Ioo_subset mem_nhds_within_Ioi_iff_exists_Ioo_subset\n\n",
 "mem_nhds_within_Ioi_iff_exists_Ioc_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/-- A set is a neighborhood of `a` within `(a, +∞)` if and only if it contains an interval `(a, u]`\nwith `a < u`. -/\ntheorem mem_nhds_within_Ioi_iff_exists_Ioc_subset [NoMaxOrder α] [DenselyOrdered α] {a : α} {s : set α} :\n    s ∈ nhds_within.gt a ↔ ∃ u ∈ Ioi a, Ioc a u ⊆ s :=\n  by\n  rw [mem_nhds_within_Ioi_iff_exists_Ioo_subset]\n  constructor\n  · rintro ⟨u, au, as⟩\n    rcases exists_between au with ⟨v, hv⟩\n    exact ⟨v, hv.1, fun x hx => as ⟨hx.1, lt_of_le_of_lt hx.2 hv.2⟩⟩\n  · rintro ⟨u, au, as⟩\n    exact ⟨u, au, subset.trans Ioo_subset_Ioc_self as⟩\n#align mem_nhds_within_Ioi_iff_exists_Ioc_subset mem_nhds_within_Ioi_iff_exists_Ioc_subset\n\n",
 "mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset {a l' : α} {s : set α} (hl' : l' < a) :\n    s ∈ nhds_within.lt a ↔ ∃ l ∈ Ico l' a, Ioo l a ⊆ s :=\n  (tfae_mem_nhds_within_Iio hl' s).out 0 3\n#align mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset\n\n",
 "mem_nhds_within_Iio_iff_exists_Ioo_subset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/-- A set is a neighborhood of `a` within `(-∞, a)` if and only if it contains an interval `(l, a)`\nwith `l < a`, provided `a` is not a bottom element. -/\ntheorem mem_nhds_within_Iio_iff_exists_Ioo_subset' {a l' : α} {s : set α} (hl' : l' < a) :\n    s ∈ nhds_within.lt a ↔ ∃ l ∈ Iio a, Ioo l a ⊆ s :=\n  (tfae_mem_nhds_within_Iio hl' s).out 0 4\n#align mem_nhds_within_Iio_iff_exists_Ioo_subset' mem_nhds_within_Iio_iff_exists_Ioo_subset'\n\n",
 "mem_nhds_within_Iio_iff_exists_Ioo_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/-- A set is a neighborhood of `a` within `(-∞, a)` if and only if it contains an interval `(l, a)`\nwith `l < a`. -/\ntheorem mem_nhds_within_Iio_iff_exists_Ioo_subset [NoMinOrder α] {a : α} {s : set α} :\n    s ∈ nhds_within.lt a ↔ ∃ l ∈ Iio a, Ioo l a ⊆ s :=\n  let ⟨l', hl'⟩ := exists_lt a\n  mem_nhds_within_Iio_iff_exists_Ioo_subset' hl'\n#align mem_nhds_within_Iio_iff_exists_Ioo_subset mem_nhds_within_Iio_iff_exists_Ioo_subset\n\n",
 "mem_nhds_within_Iio_iff_exists_Ico_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/-- A set is a neighborhood of `a` within `(-∞, a)` if and only if it contains an interval `[l, a)`\nwith `l < a`. -/\ntheorem mem_nhds_within_Iio_iff_exists_Ico_subset [NoMinOrder α] [DenselyOrdered α] {a : α} {s : set α} :\n    s ∈ nhds_within.lt a ↔ ∃ l ∈ Iio a, Ico l a ⊆ s :=\n  by\n  have : «expr ⁻¹' » of_dual s ∈ nhds_within.gt (to_dual a) ↔ _ := mem_nhds_within_Ioi_iff_exists_Ioc_subset\n  simpa only [order_dual.exists, exists_prop, dual_Ioc] using this\n#align mem_nhds_within_Iio_iff_exists_Ico_subset mem_nhds_within_Iio_iff_exists_Ico_subset\n\n",
 "mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\ntheorem mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset {a l' : α} {s : set α} (hl' : l' < a) :\n    s ∈ nhds_within.le a ↔ ∃ l ∈ Ico l' a, Ioc l a ⊆ s :=\n  (tfae_mem_nhds_within_Iic hl' s).out 0 3 (by norm_num) (by norm_num)\n#align mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset\n\n",
 "mem_nhds_within_Iic_iff_exists_Ioc_subset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n/-- A set is a neighborhood of `a` within `(-∞, a]` if and only if it contains an interval `(l, a]`\nwith `l < a`, provided `a` is not a bottom element. -/\ntheorem mem_nhds_within_Iic_iff_exists_Ioc_subset' {a l' : α} {s : set α} (hl' : l' < a) :\n    s ∈ nhds_within.le a ↔ ∃ l ∈ Iio a, Ioc l a ⊆ s :=\n  (tfae_mem_nhds_within_Iic hl' s).out 0 4 (by norm_num) (by norm_num)\n#align mem_nhds_within_Iic_iff_exists_Ioc_subset' mem_nhds_within_Iic_iff_exists_Ioc_subset'\n\n",
 "mem_nhds_within_Iic_iff_exists_Ioc_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n/-- A set is a neighborhood of `a` within `(-∞, a]` if and only if it contains an interval `(l, a]`\nwith `l < a`. -/\ntheorem mem_nhds_within_Iic_iff_exists_Ioc_subset [NoMinOrder α] {a : α} {s : set α} :\n    s ∈ nhds_within.le a ↔ ∃ l ∈ Iio a, Ioc l a ⊆ s :=\n  let ⟨l', hl'⟩ := exists_lt a\n  mem_nhds_within_Iic_iff_exists_Ioc_subset' hl'\n#align mem_nhds_within_Iic_iff_exists_Ioc_subset mem_nhds_within_Iic_iff_exists_Ioc_subset\n\n",
 "mem_nhds_within_Iic_iff_exists_Icc_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n/-- A set is a neighborhood of `a` within `(-∞, a]` if and only if it contains an interval `[l, a]`\nwith `l < a`. -/\ntheorem mem_nhds_within_Iic_iff_exists_Icc_subset [NoMinOrder α] [DenselyOrdered α] {a : α} {s : set α} :\n    s ∈ nhds_within.le a ↔ ∃ l, l < a ∧ Icc l a ⊆ s :=\n  by\n  convert @mem_nhds_within_Ici_iff_exists_Icc_subset («expr ᵒᵈ» α) _ _ _ _ _ _ _\n  simp_rw [show ∀ u : «expr ᵒᵈ» α, @Icc («expr ᵒᵈ» α) _ a u = @Icc α _ u a from fun u => dual_Icc]\n  rfl\n#align mem_nhds_within_Iic_iff_exists_Icc_subset mem_nhds_within_Iic_iff_exists_Icc_subset\n\n",
 "mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\ntheorem mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset {a u' : α} {s : set α} (hu' : a < u') :\n    s ∈ nhds_within.ge a ↔ ∃ u ∈ Ioc a u', Ico a u ⊆ s :=\n  (tfae_mem_nhds_within_Ici hu' s).out 0 3 (by norm_num) (by norm_num)\n#align mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset\n\n",
 "mem_nhds_within_Ici_iff_exists_Ico_subset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n/-- A set is a neighborhood of `a` within `[a, +∞)` if and only if it contains an interval `[a, u)`\nwith `a < u < u'`, provided `a` is not a top element. -/\ntheorem mem_nhds_within_Ici_iff_exists_Ico_subset' {a u' : α} {s : set α} (hu' : a < u') :\n    s ∈ nhds_within.ge a ↔ ∃ u ∈ Ioi a, Ico a u ⊆ s :=\n  (tfae_mem_nhds_within_Ici hu' s).out 0 4 (by norm_num) (by norm_num)\n#align mem_nhds_within_Ici_iff_exists_Ico_subset' mem_nhds_within_Ici_iff_exists_Ico_subset'\n\n",
 "mem_nhds_within_Ici_iff_exists_Ico_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n/-- A set is a neighborhood of `a` within `[a, +∞)` if and only if it contains an interval `[a, u)`\nwith `a < u`. -/\ntheorem mem_nhds_within_Ici_iff_exists_Ico_subset [NoMaxOrder α] {a : α} {s : set α} :\n    s ∈ nhds_within.ge a ↔ ∃ u ∈ Ioi a, Ico a u ⊆ s :=\n  let ⟨u', hu'⟩ := exists_gt a\n  mem_nhds_within_Ici_iff_exists_Ico_subset' hu'\n#align mem_nhds_within_Ici_iff_exists_Ico_subset mem_nhds_within_Ici_iff_exists_Ico_subset\n\n",
 "mem_nhds_within_Ici_iff_exists_Icc_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n/-- A set is a neighborhood of `a` within `[a, +∞)` if and only if it contains an interval `[a, u]`\nwith `a < u`. -/\ntheorem mem_nhds_within_Ici_iff_exists_Icc_subset [NoMaxOrder α] [DenselyOrdered α] {a : α} {s : set α} :\n    s ∈ nhds_within.ge a ↔ ∃ u, a < u ∧ Icc a u ⊆ s :=\n  by\n  rw [mem_nhds_within_Ici_iff_exists_Ico_subset]\n  constructor\n  · rintro ⟨u, au, as⟩\n    rcases exists_between au with ⟨v, hv⟩\n    exact ⟨v, hv.1, fun x hx => as ⟨hx.1, lt_of_le_of_lt hx.2 hv.2⟩⟩\n  · rintro ⟨u, au, as⟩\n    exact ⟨u, au, subset.trans Ico_subset_Icc_self as⟩\n#align mem_nhds_within_Ici_iff_exists_Icc_subset mem_nhds_within_Ici_iff_exists_Icc_subset\n\n",
 "mem_nhds_iff_exists_Ioo_subset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,\nprovided `a` is neither a bottom element nor a top element. -/\ntheorem mem_nhds_iff_exists_Ioo_subset' {a : α} {s : set α} (hl : ∃ l, l < a) (hu : ∃ u, a < u) :\n    s ∈ (nhds) a ↔ ∃ l u, a ∈ Ioo l u ∧ Ioo l u ⊆ s :=\n  by\n  constructor\n  · intro h\n    rcases exists_Ico_subset_of_mem_nhds h hu with ⟨u, au, hu⟩\n    rcases exists_Ioc_subset_of_mem_nhds h hl with ⟨l, la, hl⟩\n    exact ⟨l, u, ⟨la, au⟩, Ioc_union_Ico_eq_Ioo la au ▸ union_subset hl hu⟩\n  · rintro ⟨l, u, ha, h⟩\n    apply mem_of_superset (Ioo_mem_nhds ha.1 ha.2) h\n#align mem_nhds_iff_exists_Ioo_subset' mem_nhds_iff_exists_Ioo_subset'\n\n",
 "mem_nhds_iff_exists_Ioo_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`.\n-/\ntheorem mem_nhds_iff_exists_Ioo_subset [NoMaxOrder α] [NoMinOrder α] {a : α} {s : set α} :\n    s ∈ (nhds) a ↔ ∃ l u, a ∈ Ioo l u ∧ Ioo l u ⊆ s :=\n  mem_nhds_iff_exists_Ioo_subset' (exists_lt a) (exists_gt a)\n#align mem_nhds_iff_exists_Ioo_subset mem_nhds_iff_exists_Ioo_subset\n\n",
 "mem_lower_bounds_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_lub.mem_lower_bounds_of_tendsto [preorder γ] [topological_space γ] [order_closed_topology γ] {f : α → γ}\n    {s : set α} {a : α} {b : γ} (hf : antitone_on f s) (ha : IsLUB s a) (hb : tendsto f (nhds_within s a) ((nhds) b)) :\n    b ∈ lowerBounds («expr '' » f s) :=\n  @is_lub.mem_upper_bounds_of_tendsto α («expr ᵒᵈ» γ) _ _ _ _ _ _ _ _ _ _ hf ha hb\n#align is_lub.mem_lower_bounds_of_tendsto is_lub.mem_lower_bounds_of_tendsto\n\n",
 "mem_closure":
 "theorem is_glb.mem_closure {a : α} {s : set α} (ha : IsGLB s a) (hs : s.nonempty) : a ∈ closure s :=\n  (ha.frequently_nhds_mem hs).mem_closure\n#align is_glb.mem_closure is_glb.mem_closure\n\n",
 "max_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.max_right {l : filter β} {a : α} (h : tendsto f l ((nhds) a)) :\n    tendsto (fun i => max a (f i)) l ((nhds) a) :=\n  by\n  convert ((continuous_max.comp (@continuous.prod.mk α α _ _ a)).tendsto a).comp h\n  simp\n#align filter.tendsto.max_right filter.tendsto.max_right\n\n",
 "max_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.max_left {l : filter β} {a : α} (h : tendsto f l ((nhds) a)) :\n    tendsto (fun i => max (f i) a) l ((nhds) a) :=\n  by\n  simp_rw [max_comm _ a]\n  exact h.max_right\n#align filter.tendsto.max_left filter.tendsto.max_left\n\n",
 "max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.max {b : filter β} {a₁ a₂ : α} (hf : tendsto f b ((nhds) a₁)) (hg : tendsto g b ((nhds) a₂)) :\n    tendsto (fun b => max (f b) (g b)) b ((nhds) (max a₁ a₂)) :=\n  (continuous_max.tendsto (a₁, a₂)).comp (hf.prod_mk_nhds hg)\n#align filter.tendsto.max filter.tendsto.max\n\n",
 "map_supr_of_continuous_at'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- An antitone function continuous at the indexed supremum over a nonempty `Sort` sends this\nindexed supremum to the indexed infimum of the composition. -/\ntheorem antitone.map_supr_of_continuous_at' {ι : Sort _} [nonempty ι] {f : α → β} {g : ι → α}\n    (Cf : continuous_at f (supᵢ g)) (Af : antitone f) :\n    f («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (g i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f (g i)) :=\n  monotone.map_supr_of_continuous_at' (show continuous_at (OrderDual.toDual ∘ f) (supᵢ g) from Cf) Af\n#align antitone.map_supr_of_continuous_at' antitone.map_supr_of_continuous_at'\n\n",
 "map_supr_of_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- An antitone function sending `bot` to `top` is continuous at the indexed supremum over\na `Sort`, then it sends this indexed supremum to the indexed supremum of the composition. -/\ntheorem antitone.map_supr_of_continuous_at {ι : Sort _} {f : α → β} {g : ι → α} (Cf : continuous_at f (supᵢ g))\n    (Af : antitone f) (fbot : f («expr⊥») = «expr⊤») :\n    f («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (g i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f (g i)) :=\n  monotone.map_supr_of_continuous_at (show continuous_at (OrderDual.toDual ∘ f) (supᵢ g) from Cf) Af fbot\n#align antitone.map_supr_of_continuous_at antitone.map_supr_of_continuous_at\n\n",
 "map_neg_eq_comap_neg":
 "theorem filter.map_neg_eq_comap_neg [add_group α] : map (has_neg.neg : α → α) = comap (has_neg.neg : α → α) :=\n  funext fun f => map_eq_comap_of_inverse (funext neg_neg) (funext neg_neg)\n#align filter.map_neg_eq_comap_neg filter.map_neg_eq_comap_neg\n\n",
 "map_infi_of_continuous_at'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- An antitone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed\ninfimum to the indexed supremum of the composition. -/\ntheorem antitone.map_infi_of_continuous_at' {ι : Sort _} [nonempty ι] {f : α → β} {g : ι → α}\n    (Cf : continuous_at f (infᵢ g)) (Af : antitone f) :\n    f («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (g i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f (g i)) :=\n  monotone.map_infi_of_continuous_at' (show continuous_at (OrderDual.toDual ∘ f) (infᵢ g) from Cf) Af\n#align antitone.map_infi_of_continuous_at' antitone.map_infi_of_continuous_at'\n\n",
 "map_infi_of_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- If an antitone function sending `top` to `bot` is continuous at the indexed infimum over\na `Sort`, then it sends this indexed infimum to the indexed supremum of the composition. -/\ntheorem antitone.map_infi_of_continuous_at {ι : Sort _} {f : α → β} {g : ι → α} (Cf : continuous_at f (infᵢ g))\n    (Af : antitone f) (ftop : f («expr⊤») = «expr⊥») : f (infᵢ g) = supᵢ (f ∘ g) :=\n  monotone.map_infi_of_continuous_at (show continuous_at (OrderDual.toDual ∘ f) (infᵢ g) from Cf) Af ftop\n#align antitone.map_infi_of_continuous_at antitone.map_infi_of_continuous_at\n\n",
 "map_csupr_of_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- If an antitone function is continuous at the indexed supremum of a bounded function on\na nonempty `Sort`, then it sends this supremum to the infimum of the composition. -/\ntheorem antitone.map_csupr_of_continuous_at {f : α → β} {g : γ → α}\n    (Cf :\n      continuous_at f\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (g i)))\n    (Af : antitone f) (H : BddAbove (range g)) :\n    f («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (g i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f (g i)) :=\n  monotone.map_csupr_of_continuous_at\n    (show\n      continuous_at (OrderDual.toDual ∘ f)\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (g i))\n      from Cf)\n    Af H\n#align antitone.map_csupr_of_continuous_at antitone.map_csupr_of_continuous_at\n\n",
 "map_coe_at_top_of_Ioo_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem map_coe_at_top_of_Ioo_subset (hb : s ⊆ Iio b) (hs : ∀ a' < b, ∃ a < b, Ioo a b ⊆ s) :\n    map (coe : s → α) at_top = nhds_within.lt b :=\n  by\n  rcases eq_empty_or_nonempty (Iio b) with (hb' | ⟨a, ha⟩)\n  · rw [filter_eq_bot_of_is_empty at_top, filter.map_bot, hb', nhds_within_empty]\n    exact ⟨fun x => hb'.subset (hb x.2)⟩\n  · rw [← comap_coe_nhds_within_Iio_of_Ioo_subset hb fun _ => hs a ha, map_comap_of_mem]\n    rw [Subtype.range_coe]\n    exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' ha).2 (hs a ha)\n#align map_coe_at_top_of_Ioo_subset map_coe_at_top_of_Ioo_subset\n\n",
 "map_coe_at_bot_of_Ioo_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem map_coe_at_bot_of_Ioo_subset (ha : s ⊆ Ioi a) (hs : ∀ b' > a, ∃ b > a, Ioo a b ⊆ s) :\n    map (coe : s → α) at_bot = nhds_within.gt a :=\n  by\n  -- the elaborator gets stuck without `(... : _)`\n  refine' (map_coe_at_top_of_Ioo_subset (show «expr ⁻¹' » of_dual s ⊆ Iio (to_dual a) from ha) fun b' hb' => _ : _)\n  simpa only [order_dual.exists, dual_Ioo] using hs b' hb'\n#align map_coe_at_bot_of_Ioo_subset map_coe_at_bot_of_Ioo_subset\n\n",
 "map_coe_Ioo_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n@[simp]\ntheorem map_coe_Ioo_at_top {a b : α} (h : a < b) : map (coe : Ioo a b → α) at_top = nhds_within.lt b :=\n  map_coe_at_top_of_Ioo_subset Ioo_subset_Iio_self fun _ _ => ⟨_, h, Subset.refl _⟩\n#align map_coe_Ioo_at_top map_coe_Ioo_at_top\n\n",
 "map_coe_Ioo_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n@[simp]\ntheorem map_coe_Ioo_at_bot {a b : α} (h : a < b) : map (coe : Ioo a b → α) at_bot = nhds_within.gt a :=\n  map_coe_at_bot_of_Ioo_subset Ioo_subset_Ioi_self fun _ _ => ⟨_, h, Subset.refl _⟩\n#align map_coe_Ioo_at_bot map_coe_Ioo_at_bot\n\n",
 "map_coe_Ioi_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n@[simp]\ntheorem map_coe_Ioi_at_bot (a : α) : map (coe : Ioi a → α) at_bot = nhds_within.gt a :=\n  map_coe_at_bot_of_Ioo_subset (Subset.refl _) fun b hb => ⟨b, hb, Ioo_subset_Ioi_self⟩\n#align map_coe_Ioi_at_bot map_coe_Ioi_at_bot\n\n",
 "map_coe_Iio_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n@[simp]\ntheorem map_coe_Iio_at_top (a : α) : map (coe : Iio a → α) at_top = nhds_within.lt a :=\n  @map_coe_Ioi_at_bot («expr ᵒᵈ» α) _ _ _ _ _\n#align map_coe_Iio_at_top map_coe_Iio_at_top\n\n",
 "map_cinfi_of_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- A continuous antitone function sends indexed infimum to indexed supremum in conditionally\ncomplete linear order, under a boundedness assumption. -/\ntheorem antitone.map_cinfi_of_continuous_at {f : α → β} {g : γ → α}\n    (Cf :\n      continuous_at f\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (g i)))\n    (Af : antitone f) (H : BddBelow (range g)) :\n    f («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (g i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f (g i)) :=\n  monotone.map_cinfi_of_continuous_at\n    (show\n      continuous_at (OrderDual.toDual ∘ f)\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (g i))\n      from Cf)\n    Af H\n#align antitone.map_cinfi_of_continuous_at antitone.map_cinfi_of_continuous_at\n\n",
 "map_cSup_of_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If an antitone function is continuous at the supremum of a nonempty bounded above set `s`,\nthen it sends this supremum to the infimum of the image of `s`. -/\ntheorem antitone.map_cSup_of_continuous_at {f : α → β} {s : set α} (Cf : continuous_at f (supₛ s)) (Af : antitone f)\n    (ne : s.nonempty) (H : BddAbove s) : f (supₛ s) = infₛ («expr '' » f s) :=\n  monotone.map_cSup_of_continuous_at (show continuous_at (OrderDual.toDual ∘ f) (supₛ s) from Cf) Af ne H\n#align antitone.map_cSup_of_continuous_at antitone.map_cSup_of_continuous_at\n\n",
 "map_cInf_of_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If an antitone function is continuous at the infimum of a nonempty bounded below set `s`,\nthen it sends this infimum to the supremum of the image of `s`. -/\ntheorem antitone.map_cInf_of_continuous_at {f : α → β} {s : set α} (Cf : continuous_at f (infₛ s)) (Af : antitone f)\n    (ne : s.nonempty) (H : BddBelow s) : f (infₛ s) = supₛ («expr '' » f s) :=\n  monotone.map_cInf_of_continuous_at (show continuous_at (OrderDual.toDual ∘ f) (infₛ s) from Cf) Af ne H\n#align antitone.map_cInf_of_continuous_at antitone.map_cInf_of_continuous_at\n\n",
 "map_Sup_of_continuous_at'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- An antitone function continuous at the supremum of a nonempty set sends this supremum to\nthe infimum of the image of this set. -/\ntheorem antitone.map_Sup_of_continuous_at' {f : α → β} {s : set α} (Cf : continuous_at f (supₛ s)) (Af : antitone f)\n    (hs : s.nonempty) : f (supₛ s) = infₛ («expr '' » f s) :=\n  monotone.map_Sup_of_continuous_at' (show continuous_at (OrderDual.toDual ∘ f) (supₛ s) from Cf) Af hs\n#align antitone.map_Sup_of_continuous_at' antitone.map_Sup_of_continuous_at'\n\n",
 "map_Sup_of_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- An antitone function `f` sending `bot` to `top` and continuous at the supremum of a set sends\nthis supremum to the infimum of the image of this set. -/\ntheorem antitone.map_Sup_of_continuous_at {f : α → β} {s : set α} (Cf : continuous_at f (supₛ s)) (Af : antitone f)\n    (fbot : f («expr⊥») = «expr⊤») : f (supₛ s) = infₛ («expr '' » f s) :=\n  monotone.map_Sup_of_continuous_at (show continuous_at (OrderDual.toDual ∘ f) (supₛ s) from Cf) Af fbot\n#align antitone.map_Sup_of_continuous_at antitone.map_Sup_of_continuous_at\n\n",
 "map_Inf_of_continuous_at'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- An antitone function continuous at the infimum of a nonempty set sends this infimum to\nthe supremum of the image of this set. -/\ntheorem antitone.map_Inf_of_continuous_at' {f : α → β} {s : set α} (Cf : continuous_at f (infₛ s)) (Af : antitone f)\n    (hs : s.nonempty) : f (infₛ s) = supₛ («expr '' » f s) :=\n  monotone.map_Inf_of_continuous_at' (show continuous_at (OrderDual.toDual ∘ f) (infₛ s) from Cf) Af hs\n#align antitone.map_Inf_of_continuous_at' antitone.map_Inf_of_continuous_at'\n\n",
 "map_Inf_of_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- An antitone function `f` sending `top` to `bot` and continuous at the infimum of a set sends\nthis infimum to the supremum of the image of this set. -/\ntheorem antitone.map_Inf_of_continuous_at {f : α → β} {s : set α} (Cf : continuous_at f (infₛ s)) (Af : antitone f)\n    (ftop : f («expr⊤») = «expr⊥») : f (infₛ s) = supₛ («expr '' » f s) :=\n  monotone.map_Inf_of_continuous_at (show continuous_at (OrderDual.toDual ∘ f) (infₛ s) from Cf) Af ftop\n#align antitone.map_Inf_of_continuous_at antitone.map_Inf_of_continuous_at\n\n",
 "lt_subset_interior_le":
 "theorem lt_subset_interior_le (hf : continuous f) (hg : continuous g) :\n    { b | f b < g b } ⊆ interior { b | f b ≤ g b } :=\n  (interior_maximal fun p => le_of_lt) <| is_open_lt hf hg\n#align lt_subset_interior_le lt_subset_interior_le\n\n",
 "lt_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem lt_mem_nhds {a b : α} (h : a < b) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) b)\n      (a < x) :=\n  is_open.mem_nhds (is_open_lt' _) h\n#align lt_mem_nhds lt_mem_nhds\n\n",
 "left_nhds_within_Ioo_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem left_nhds_within_Ioo_ne_bot {a b : α} (H : a < b) : ne_bot (nhds_within (Ioo a b) a) :=\n  (isGLB_Ioo H).nhds_within_ne_bot (nonempty_Ioo.2 H)\n#align left_nhds_within_Ioo_ne_bot left_nhds_within_Ioo_ne_bot\n\n",
 "left_nhds_within_Ioc_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem left_nhds_within_Ioc_ne_bot {a b : α} (H : a < b) : ne_bot (nhds_within (Ioc a b) a) :=\n  (isGLB_Ioc H).nhds_within_ne_bot (nonempty_Ioc.2 H)\n#align left_nhds_within_Ioc_ne_bot left_nhds_within_Ioc_ne_bot\n\n",
 "le_on_closure":
 "theorem le_on_closure [topological_space β] {f g : β → α} {s : set β} (h : ∀ x ∈ s, f x ≤ g x)\n    (hf : continuous_on f (closure s)) (hg : continuous_on g (closure s)) ⦃x⦄ (hx : x ∈ closure s) : f x ≤ g x :=\n  have : s ⊆ { y ∈ closure s | f y ≤ g y } := fun y hy => ⟨subset_closure hy, h y hy⟩\n  (closure_minimal this (is_closed_closure.is_closed_le hf hg) hx).2\n#align le_on_closure le_on_closure\n\n",
 "le_of_tendsto_of_tendsto'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem le_of_tendsto_of_tendsto' {f g : β → α} {b : filter β} {a₁ a₂ : α} [ne_bot b] (hf : tendsto f b ((nhds) a₁))\n    (hg : tendsto g b ((nhds) a₂)) (h : ∀ x, f x ≤ g x) : a₁ ≤ a₂ :=\n  le_of_tendsto_of_tendsto hf hg (eventually_of_forall h)\n#align le_of_tendsto_of_tendsto' le_of_tendsto_of_tendsto'\n\n",
 "le_of_tendsto_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\ntheorem le_of_tendsto_of_tendsto {f g : β → α} {b : filter β} {a₁ a₂ : α} [ne_bot b] (hf : tendsto f b ((nhds) a₁))\n    (hg : tendsto g b ((nhds) a₂)) (h : «expr ≤ᶠ[ ] » f b g) : a₁ ≤ a₂ :=\n  have : tendsto (fun b => (f b, g b)) b ((nhds) (a₁, a₂)) := by rw [nhds_prod_eq] <;> exact hf.prod_mk hg\n  show (a₁, a₂) ∈ { p : α × α | p.1 ≤ p.2 } from t.is_closed_le'.mem_of_tendsto this h\n#align le_of_tendsto_of_tendsto le_of_tendsto_of_tendsto\n\n",
 "le_of_tendsto'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem le_of_tendsto' {f : β → α} {a b : α} {x : filter β} [ne_bot x] (lim : tendsto f x ((nhds) a))\n    (h : ∀ c, f c ≤ b) : a ≤ b :=\n  le_of_tendsto lim (eventually_of_forall h)\n#align le_of_tendsto' le_of_tendsto'\n\n",
 "le_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem le_of_tendsto {f : β → α} {a b : α} {x : filter β} [ne_bot x] (lim : tendsto f x ((nhds) a))\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" x\n        (f c ≤ b)) :\n    a ≤ b :=\n  le_of_tendsto_of_tendsto lim tendsto_const_nhds h\n#align le_of_tendsto le_of_tendsto\n\n",
 "le_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem le_mem_nhds {a b : α} (h : a < b) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) b)\n      (a ≤ x) :=\n  ((nhds) b).sets_of_superset (lt_mem_nhds h) fun b hb => le_of_lt hb\n#align le_mem_nhds le_mem_nhds\n\n",
 "is_open_lt_prod":
 "-- see Note [lower instance priority]\ntheorem is_open_lt_prod : is_open { p : α × α | p.1 < p.2 } :=\n  by\n  simp_rw [← is_closed_compl_iff, compl_set_of, not_lt]\n  exact is_closed_le continuous_snd continuous_fst\n#align is_open_lt_prod is_open_lt_prod\n\n",
 "is_open_lt'":
 "theorem is_open_lt' (a : α) : is_open { b : α | a < b } := by\n  rw [@is_open_iff_generate_intervals α _ _ t] <;> exact generate_open.basic _ ⟨a, or.inl rfl⟩\n#align is_open_lt' is_open_lt'\n\n",
 "is_open_lt":
 "theorem is_open_lt [topological_space β] {f g : β → α} (hf : continuous f) (hg : continuous g) :\n    is_open { b | f b < g b } := by simp [lt_iff_not_ge, -not_le] <;> exact (is_closed_le hg hf).is_open_compl\n#align is_open_lt is_open_lt\n\n",
 "is_open_iff_generate_intervals":
 "theorem is_open_iff_generate_intervals {s : set α} : is_open s ↔ generate_open { s | ∃ a, s = Ioi a ∨ s = Iio a } s :=\n  by rw [t.topology_eq_generate_intervals] <;> rfl\n#align is_open_iff_generate_intervals is_open_iff_generate_intervals\n\n",
 "is_open_gt'":
 "theorem is_open_gt' (a : α) : is_open { b : α | b < a } := by\n  rw [@is_open_iff_generate_intervals α _ _ t] <;> exact generate_open.basic _ ⟨a, or.inr rfl⟩\n#align is_open_gt' is_open_gt'\n\n",
 "is_open_Ioo":
 "theorem is_open_Ioo : is_open (Ioo a b) :=\n  is_open.inter is_open_Ioi is_open_Iio\n#align is_open_Ioo is_open_Ioo\n\n",
 "is_open_Ioi":
 "theorem is_open_Ioi : is_open (Ioi a) :=\n  is_open_lt continuous_const continuous_id\n#align is_open_Ioi is_open_Ioi\n\n",
 "is_open_Iio":
 "theorem is_open_Iio : is_open (Iio a) :=\n  is_open_lt continuous_id continuous_const\n#align is_open_Iio is_open_Iio\n\n",
 "is_lub_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_glb.is_lub_of_tendsto [preorder γ] [topological_space γ] [order_closed_topology γ] :\n    ∀ {f : α → γ} {s : set α} {a : α} {b : γ},\n      antitone_on f s → IsGLB s a → s.nonempty → tendsto f (nhds_within s a) ((nhds) b) → IsLUB («expr '' » f s) b :=\n  @is_glb.is_glb_of_tendsto α («expr ᵒᵈ» γ) _ _ _ _ _ _\n#align is_glb.is_lub_of_tendsto is_glb.is_lub_of_tendsto\n\n",
 "is_lub_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_lub_of_mem_nhds {s : set α} {a : α} {f : filter α} (hsa : a ∈ upperBounds s) (hsf : s ∈ f)\n    [ne_bot («expr ⊓ » f ((nhds) a))] : IsLUB s a :=\n  ⟨hsa, fun b hb =>\n    not_lt.1 fun hba =>\n      have : s ∩ { a | b < a } ∈ «expr ⊓ » f ((nhds) a) := inter_mem_inf hsf (is_open.mem_nhds (is_open_lt' _) hba)\n      let ⟨x, ⟨hxs, hxb⟩⟩ := filter.nonempty_of_mem this\n      have : b < b := lt_of_lt_of_le hxb <| hb hxs\n      lt_irrefl b this⟩\n#align is_lub_of_mem_nhds is_lub_of_mem_nhds\n\n",
 "is_lub_of_mem_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_lub_of_mem_closure {s : set α} {a : α} (hsa : a ∈ upperBounds s) (hsf : a ∈ closure s) : IsLUB s a :=\n  by\n  rw [mem_closure_iff_cluster_pt, cluster_pt, inf_comm] at hsf\n  haveI : («expr ⊓ » ((filter.principal) s) ((nhds) a)).ne_bot := hsf\n  exact is_lub_of_mem_nhds hsa (mem_principal_self s)\n#align is_lub_of_mem_closure is_lub_of_mem_closure\n\n",
 "is_glb_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_lub.is_glb_of_tendsto [preorder γ] [topological_space γ] [order_closed_topology γ] :\n    ∀ {f : α → γ} {s : set α} {a : α} {b : γ},\n      antitone_on f s → IsLUB s a → s.nonempty → tendsto f (nhds_within s a) ((nhds) b) → IsGLB («expr '' » f s) b :=\n  @is_lub.is_lub_of_tendsto α («expr ᵒᵈ» γ) _ _ _ _ _ _\n#align is_lub.is_glb_of_tendsto is_lub.is_glb_of_tendsto\n\n",
 "is_glb_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_glb_of_mem_nhds :\n    ∀ {s : set α} {a : α} {f : filter α}, a ∈ lowerBounds s → s ∈ f → ne_bot («expr ⊓ » f ((nhds) a)) → IsGLB s a :=\n  @is_lub_of_mem_nhds («expr ᵒᵈ» α) _ _ _\n#align is_glb_of_mem_nhds is_glb_of_mem_nhds\n\n",
 "is_glb_of_mem_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem is_glb_of_mem_closure {s : set α} {a : α} (hsa : a ∈ lowerBounds s) (hsf : a ∈ closure s) : IsGLB s a :=\n  @is_lub_of_mem_closure («expr ᵒᵈ» α) _ _ _ s a hsa hsf\n#align is_glb_of_mem_closure is_glb_of_mem_closure\n\n",
 "is_closed_le_prod":
 "theorem is_closed_le_prod : is_closed { p : α × α | p.1 ≤ p.2 } :=\n  t.is_closed_le'\n#align is_closed_le_prod is_closed_le_prod\n\n",
 "is_closed_le'":
 "theorem is_closed_le' (a : α) : is_closed { b | b ≤ a } :=\n  is_closed_le continuous_id continuous_const\n#align is_closed_le' is_closed_le'\n\n",
 "is_closed_le":
 "/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. -/\ntheorem is_closed.is_closed_le [topological_space β] {f g : β → α} {s : set β} (hs : is_closed s)\n    (hf : continuous_on f s) (hg : continuous_on g s) : is_closed ({ x ∈ s | f x ≤ g x }) :=\n  (hf.prod hg).preimage_closed_of_closed hs order_closed_topology.is_closed_le'\n#align is_closed.is_closed_le is_closed.is_closed_le\n\n",
 "is_closed_ge'":
 "theorem is_closed_ge' (a : α) : is_closed { b | a ≤ b } :=\n  is_closed_le continuous_const continuous_id\n#align is_closed_ge' is_closed_ge'\n\n",
 "is_closed_Iic":
 "theorem is_closed_Iic {a : α} : is_closed (Iic a) :=\n  is_closed_le' a\n#align is_closed_Iic is_closed_Iic\n\n",
 "is_closed_Ici":
 "theorem is_closed_Ici {a : α} : is_closed (Ici a) :=\n  is_closed_ge' a\n#align is_closed_Ici is_closed_Ici\n\n",
 "is_closed_Icc":
 "theorem is_closed_Icc {a b : α} : is_closed (Icc a b) :=\n  is_closed.inter is_closed_Ici is_closed_Iic\n#align is_closed_Icc is_closed_Icc\n\n",
 "interior_Ioo":
 "@[simp]\ntheorem interior_Ioo : interior (Ioo a b) = Ioo a b :=\n  is_open_Ioo.interior_eq\n#align interior_Ioo interior_Ioo\n\n",
 "interior_Ioi":
 "@[simp]\ntheorem interior_Ioi : interior (Ioi a) = Ioi a :=\n  is_open_Ioi.interior_eq\n#align interior_Ioi interior_Ioi\n\n",
 "interior_Ioc":
 "@[simp]\ntheorem interior_Ioc [NoMaxOrder α] {a b : α} : interior (Ioc a b) = Ioo a b := by\n  rw [← Ioi_inter_Iic, interior_inter, interior_Ioi, interior_Iic, Ioi_inter_Iio]\n#align interior_Ioc interior_Ioc\n\n",
 "interior_Iio":
 "@[simp]\ntheorem interior_Iio : interior (Iio a) = Iio a :=\n  is_open_Iio.interior_eq\n#align interior_Iio interior_Iio\n\n",
 "interior_Iic'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem interior_Iic' {a : α} (ha : (Ioi a).nonempty) : interior (Iic a) = Iio a :=\n  @interior_Ici' («expr ᵒᵈ» α) _ _ _ _ _ ha\n#align interior_Iic' interior_Iic'\n\n",
 "interior_Iic":
 "theorem interior_Iic [NoMaxOrder α] {a : α} : interior (Iic a) = Iio a :=\n  interior_Iic' nonempty_Ioi\n#align interior_Iic interior_Iic\n\n",
 "interior_Ico":
 "@[simp]\ntheorem interior_Ico [NoMinOrder α] {a b : α} : interior (Ico a b) = Ioo a b := by\n  rw [← Ici_inter_Iio, interior_inter, interior_Ici, interior_Iio, Ioi_inter_Iio]\n#align interior_Ico interior_Ico\n\n",
 "interior_Ici'":
 "@[simp]\ntheorem interior_Ici' {a : α} (ha : (Iio a).nonempty) : interior (Ici a) = Ioi a := by\n  rw [← compl_Iio, interior_compl, closure_Iio' ha, compl_Iic]\n#align interior_Ici' interior_Ici'\n\n",
 "interior_Ici":
 "theorem interior_Ici [NoMinOrder α] {a : α} : interior (Ici a) = Ioi a :=\n  interior_Ici' nonempty_Iio\n#align interior_Ici interior_Ici\n\n",
 "interior_Icc":
 "@[simp]\ntheorem interior_Icc [NoMinOrder α] [NoMaxOrder α] {a b : α} : interior (Icc a b) = Ioo a b := by\n  rw [← Ici_inter_Iic, interior_inter, interior_Ici, interior_Iic, Ioi_inter_Iio]\n#align interior_Icc interior_Icc\n\n",
 "inf_nhds_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem inf_nhds_at_top [NoMaxOrder α] (x : α) : «expr ⊓ » ((nhds) x) at_top = «expr⊥» :=\n  disjoint_iff.1 (disjoint_nhds_at_top x)\n#align inf_nhds_at_top inf_nhds_at_top\n\n",
 "inf_nhds_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem inf_nhds_at_bot [NoMinOrder α] (x : α) : «expr ⊓ » ((nhds) x) at_bot = «expr⊥» :=\n  @inf_nhds_at_top («expr ᵒᵈ» α) _ _ _ _ x\n#align inf_nhds_at_bot inf_nhds_at_bot\n\n",
 "induced_order_topology'":
 "theorem induced_order_topology' {α : Type u} {β : Type v} [preorder α] [ta : topological_space β] [preorder β]\n    [order_topology β] (f : α → β) (hf : ∀ {x y}, f x < f y ↔ x < y) (H₁ : ∀ {a x}, x < f a → ∃ b < a, x ≤ f b)\n    (H₂ : ∀ {a x}, f a < x → ∃ b > a, f b ≤ x) : @order_topology _ (induced f ta) _ :=\n  by\n  letI := induced f ta\n  refine' ⟨eq_of_nhds_eq_nhds fun a => _⟩\n  rw [nhds_induced, nhds_generate_from, nhds_eq_order (f a)]\n  apply le_antisymm\n  · refine' le_infᵢ fun s => le_infᵢ fun hs => le_principal_iff.2 _\n    rcases hs with ⟨ab, b, rfl | rfl⟩\n    ·\n      exact\n        mem_comap.2\n          ⟨{ x | f b < x }, mem_inf_of_left <| mem_infi_of_mem _ <| mem_infi_of_mem (hf.2 ab) <| mem_principal_self _,\n            fun x => hf.1⟩\n    ·\n      exact\n        mem_comap.2\n          ⟨{ x | x < f b }, mem_inf_of_right <| mem_infi_of_mem _ <| mem_infi_of_mem (hf.2 ab) <| mem_principal_self _,\n            fun x => hf.1⟩\n  · rw [← map_le_iff_le_comap]\n    refine' le_inf _ _ <;> refine' le_infᵢ fun x => le_infᵢ fun h => le_principal_iff.2 _ <;> simp\n    · rcases H₁ h with ⟨b, ab, xb⟩\n      refine' mem_infi_of_mem _ (mem_infi_of_mem ⟨ab, b, or.inl rfl⟩ (mem_principal.2 _))\n      exact fun c hc => lt_of_le_of_lt xb (hf.2 hc)\n    · rcases H₂ h with ⟨b, ab, xb⟩\n      refine' mem_infi_of_mem _ (mem_infi_of_mem ⟨ab, b, or.inr rfl⟩ (mem_principal.2 _))\n      exact fun c hc => lt_of_lt_of_le (hf.2 hc) xb\n#align induced_order_topology' induced_order_topology'\n\n",
 "induced_order_topology":
 "theorem induced_order_topology {α : Type u} {β : Type v} [preorder α] [ta : topological_space β] [preorder β]\n    [order_topology β] (f : α → β) (hf : ∀ {x y}, f x < f y ↔ x < y) (H : ∀ {x y}, x < y → ∃ a, x < f a ∧ f a < y) :\n    @order_topology _ (induced f ta) _ :=\n  induced_order_topology' f (@hf)\n    (fun a x xa =>\n      let ⟨b, xb, ba⟩ := H xa\n      ⟨b, hf.1 ba, le_of_lt xb⟩)\n    fun a x ax =>\n    let ⟨b, ab, bx⟩ := H ax\n    ⟨b, hf.1 ab, le_of_lt bx⟩\n#align induced_order_topology induced_order_topology\n\n",
 "if_le":
 "theorem continuous.if_le [topological_space γ] [∀ x, decidable (f x ≤ g x)] {f' g' : β → γ} (hf' : continuous f')\n    (hg' : continuous g') (hf : continuous f) (hg : continuous g) (hfg : ∀ x, f x = g x → f' x = g' x) :\n    continuous fun x => if f x ≤ g x then f' x else g' x :=\n  continuous_if_le hf hg hf'.continuous_on hg'.continuous_on hfg\n#align continuous.if_le continuous.if_le\n\n",
 "hypograph":
 "theorem is_closed.hypograph [topological_space β] {f : β → α} {s : set β} (hs : is_closed s) (hf : continuous_on f s) :\n    is_closed { p : β × α | p.1 ∈ s ∧ p.2 ≤ f p.1 } :=\n  (hs.preimage continuous_fst).is_closed_le continuous_on_snd (hf.comp continuous_on_fst Subset.rfl)\n#align is_closed.hypograph is_closed.hypograph\n\n",
 "gt_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem gt_mem_nhds {a b : α} (h : a < b) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      (x < b) :=\n  is_open.mem_nhds (is_open_gt' _) h\n#align gt_mem_nhds gt_mem_nhds\n\n",
 "ge_of_tendsto'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ge_of_tendsto' {f : β → α} {a b : α} {x : filter β} [ne_bot x] (lim : tendsto f x ((nhds) a))\n    (h : ∀ c, b ≤ f c) : b ≤ a :=\n  ge_of_tendsto lim (eventually_of_forall h)\n#align ge_of_tendsto' ge_of_tendsto'\n\n",
 "ge_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem ge_of_tendsto {f : β → α} {a b : α} {x : filter β} [ne_bot x] (lim : tendsto f x ((nhds) a))\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" x\n        (b ≤ f c)) :\n    b ≤ a :=\n  le_of_tendsto_of_tendsto tendsto_const_nhds lim h\n#align ge_of_tendsto ge_of_tendsto\n\n",
 "ge_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ge_mem_nhds {a b : α} (h : a < b) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      (x ≤ b) :=\n  ((nhds) a).sets_of_superset (gt_mem_nhds h) fun b hb => le_of_lt hb\n#align ge_mem_nhds ge_mem_nhds\n\n",
 "frontier_lt_subset_eq":
 "theorem frontier_lt_subset_eq (hf : continuous f) (hg : continuous g) :\n    frontier { b | f b < g b } ⊆ { b | f b = g b } := by\n  rw [← frontier_compl] <;> convert frontier_le_subset_eq hg hf <;> simp [ext_iff, eq_comm]\n#align frontier_lt_subset_eq frontier_lt_subset_eq\n\n",
 "frontier_le_subset_eq":
 "theorem frontier_le_subset_eq (hf : continuous f) (hg : continuous g) :\n    frontier { b | f b ≤ g b } ⊆ { b | f b = g b } :=\n  by\n  rw [frontier_eq_closure_inter_closure, closure_le_eq hf hg]\n  rintro b ⟨hb₁, hb₂⟩\n  refine' le_antisymm hb₁ (closure_lt_subset_le hg hf _)\n  convert hb₂ using 2; simp only [not_le.symm]; rfl\n#align frontier_le_subset_eq frontier_le_subset_eq\n\n",
 "frontier_Ioo":
 "@[simp]\ntheorem frontier_Ioo {a b : α} (h : a < b) : frontier (Ioo a b) = {a, b} := by\n  rw [frontier, closure_Ioo h.ne, interior_Ioo, Icc_diff_Ioo_same h.le]\n#align frontier_Ioo frontier_Ioo\n\n",
 "frontier_Ioi'":
 "@[simp]\ntheorem frontier_Ioi' {a : α} (ha : (Ioi a).nonempty) : frontier (Ioi a) = {a} := by\n  simp [frontier, closure_Ioi' ha, Iic_diff_Iio, Icc_self]\n#align frontier_Ioi' frontier_Ioi'\n\n",
 "frontier_Ioi":
 "theorem frontier_Ioi [NoMaxOrder α] {a : α} : frontier (Ioi a) = {a} :=\n  frontier_Ioi' nonempty_Ioi\n#align frontier_Ioi frontier_Ioi\n\n",
 "frontier_Ioc":
 "@[simp]\ntheorem frontier_Ioc [NoMaxOrder α] {a b : α} (h : a < b) : frontier (Ioc a b) = {a, b} := by\n  rw [frontier, closure_Ioc h.ne, interior_Ioc, Icc_diff_Ioo_same h.le]\n#align frontier_Ioc frontier_Ioc\n\n",
 "frontier_Iio'":
 "@[simp]\ntheorem frontier_Iio' {a : α} (ha : (Iio a).nonempty) : frontier (Iio a) = {a} := by\n  simp [frontier, closure_Iio' ha, Iic_diff_Iio, Icc_self]\n#align frontier_Iio' frontier_Iio'\n\n",
 "frontier_Iio":
 "theorem frontier_Iio [NoMinOrder α] {a : α} : frontier (Iio a) = {a} :=\n  frontier_Iio' nonempty_Iio\n#align frontier_Iio frontier_Iio\n\n",
 "frontier_Iic_subset":
 "theorem frontier_Iic_subset (a : α) : frontier (Iic a) ⊆ {a} :=\n  frontier_le_subset_eq (@continuous_id α _) continuous_const\n#align frontier_Iic_subset frontier_Iic_subset\n\n",
 "frontier_Iic'":
 "@[simp]\ntheorem frontier_Iic' {a : α} (ha : (Ioi a).nonempty) : frontier (Iic a) = {a} := by simp [frontier, ha]\n#align frontier_Iic' frontier_Iic'\n\n",
 "frontier_Iic":
 "theorem frontier_Iic [NoMaxOrder α] {a : α} : frontier (Iic a) = {a} :=\n  frontier_Iic' nonempty_Ioi\n#align frontier_Iic frontier_Iic\n\n",
 "frontier_Ico":
 "@[simp]\ntheorem frontier_Ico [NoMinOrder α] {a b : α} (h : a < b) : frontier (Ico a b) = {a, b} := by\n  rw [frontier, closure_Ico h.ne, interior_Ico, Icc_diff_Ioo_same h.le]\n#align frontier_Ico frontier_Ico\n\n",
 "frontier_Ici_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem frontier_Ici_subset (a : α) : frontier (Ici a) ⊆ {a} :=\n  @frontier_Iic_subset («expr ᵒᵈ» α) _ _ _ _\n#align frontier_Ici_subset frontier_Ici_subset\n\n",
 "frontier_Ici'":
 "@[simp]\ntheorem frontier_Ici' {a : α} (ha : (Iio a).nonempty) : frontier (Ici a) = {a} := by simp [frontier, ha]\n#align frontier_Ici' frontier_Ici'\n\n",
 "frontier_Ici":
 "theorem frontier_Ici [NoMinOrder α] {a : α} : frontier (Ici a) = {a} :=\n  frontier_Ici' nonempty_Iio\n#align frontier_Ici frontier_Ici\n\n",
 "frontier_Icc":
 "@[simp]\ntheorem frontier_Icc [NoMinOrder α] [NoMaxOrder α] {a b : α} (h : a < b) : frontier (Icc a b) = {a, b} := by\n  simp [frontier, le_of_lt h, Icc_diff_Ioo_same]\n#align frontier_Icc frontier_Icc\n\n",
 "frequently_nhds_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_glb.frequently_nhds_mem {a : α} {s : set α} (ha : IsGLB s a) (hs : s.nonempty) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" ((nhds) a)\n      (x ∈ s) :=\n  (ha.frequently_mem hs).filter_mono inf_le_left\n#align is_glb.frequently_nhds_mem is_glb.frequently_nhds_mem\n\n",
 "frequently_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\ntheorem is_glb.frequently_mem {a : α} {s : set α} (ha : IsGLB s a) (hs : s.nonempty) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n      (nhds_within.ge a) (x ∈ s) :=\n  @is_lub.frequently_mem («expr ᵒᵈ» α) _ _ _ _ _ ha hs\n#align is_glb.frequently_mem is_glb.frequently_mem\n\n",
 "exists_seq_tendsto_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_seq_tendsto_Sup {α : Type _} [ConditionallyCompleteLinearOrder α] [topological_space α]\n    [order_topology α] [first_countable_topology α] {S : set α} (hS : S.nonempty) (hS' : BddAbove S) :\n    ∃ u : ℕ → α, monotone u ∧ tendsto u at_top ((nhds) (supₛ S)) ∧ ∀ n, u n ∈ S :=\n  by\n  rcases(isLUB_csupₛ hS hS').exists_seq_monotone_tendsto hS with ⟨u, hu⟩\n  exact ⟨u, hu.1, hu.2.2⟩\n#align exists_seq_tendsto_Sup exists_seq_tendsto_Sup\n\n",
 "exists_seq_tendsto_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_seq_tendsto_Inf {α : Type _} [ConditionallyCompleteLinearOrder α] [topological_space α]\n    [order_topology α] [first_countable_topology α] {S : set α} (hS : S.nonempty) (hS' : BddBelow S) :\n    ∃ u : ℕ → α, antitone u ∧ tendsto u at_top ((nhds) (infₛ S)) ∧ ∀ n, u n ∈ S :=\n  @exists_seq_tendsto_Sup («expr ᵒᵈ» α) _ _ _ _ S hS hS'\n#align exists_seq_tendsto_Inf exists_seq_tendsto_Inf\n\n",
 "exists_seq_strict_mono_tendsto_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_lub.exists_seq_strict_mono_tendsto_of_not_mem {t : set α} {x : α} [is_countably_generated ((nhds) x)]\n    (htx : IsLUB t x) (not_mem : x ∉ t) (ht : t.nonempty) :\n    ∃ u : ℕ → α, strict_mono u ∧ (∀ n, u n < x) ∧ tendsto u at_top ((nhds) x) ∧ ∀ n, u n ∈ t :=\n  by\n  rcases ht with ⟨l, hl⟩\n  have hl : l < x := (htx.1 hl).eq_or_lt.resolve_left fun h => (not_mem <| h ▸ hl).elim\n  obtain ⟨s, hs⟩ : ∃ s : ℕ → set α, ((nhds) x).has_basis (fun _x : ℕ => true) s :=\n    let ⟨s, hs⟩ := ((nhds) x).exists_antitone_basis\n    ⟨s, hs.to_has_basis⟩\n  have : ∀ n k, k < x → ∃ y, Icc y x ⊆ s n ∧ k < y ∧ y < x ∧ y ∈ t :=\n    by\n    intro n k hk\n    obtain ⟨L, hL, h⟩ : ∃ (L : α)(hL : L ∈ Ico k x), Ioc L x ⊆ s n :=\n      exists_Ioc_subset_of_mem_nhds' (hs.mem_of_mem trivial) hk\n    obtain ⟨y, hy⟩ : ∃ y : α, L < y ∧ y < x ∧ y ∈ t :=\n      by\n      rcases htx.exists_between' not_mem hL.2 with ⟨y, yt, hy⟩\n      refine' ⟨y, hy.1, hy.2, yt⟩\n    exact ⟨y, fun z hz => h ⟨hy.1.trans_le hz.1, hz.2⟩, hL.1.trans_lt hy.1, hy.2⟩\n  choose! f hf using this\n  let u : ℕ → α := fun n => nat.rec_on n (f 0 l) fun n h => f n.succ h\n  have I : ∀ n, u n < x := by\n    intro n\n    induction' n with n IH\n    · exact (hf 0 l hl).2.2.1\n    · exact (hf n.succ _ IH).2.2.1\n  have S : strict_mono u := strictMono_nat_of_lt_succ fun n => (hf n.succ _ (I n)).2.1\n  refine' ⟨u, S, I, hs.tendsto_right_iff.2 fun n _ => _, fun n => _⟩\n  · simp only [ge_iff_le, eventually_at_top]\n    refine' ⟨n, fun p hp => _⟩\n    have up : u p ∈ Icc (u n) x := ⟨S.monotone hp, (I p).le⟩\n    have : Icc (u n) x ⊆ s n := by\n      cases n\n      · exact (hf 0 l hl).1\n      · exact (hf n.succ (u n) (I n)).1\n    exact this up\n  · cases n\n    · exact (hf 0 l hl).2.2.2\n    · exact (hf n.succ _ (I n)).2.2.2\n#align is_lub.exists_seq_strict_mono_tendsto_of_not_mem is_lub.exists_seq_strict_mono_tendsto_of_not_mem\n\n",
 "exists_seq_strict_mono_tendsto_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem exists_seq_strict_mono_tendsto_nhds_within [DenselyOrdered α] [NoMinOrder α] [first_countable_topology α]\n    (x : α) : ∃ u : ℕ → α, strict_mono u ∧ (∀ n, u n < x) ∧ tendsto u at_top (nhds_within.lt x) :=\n  let ⟨u, hu, hx, h⟩ := exists_seq_strict_mono_tendsto x\n  ⟨u, hu, hx, tendsto_nhds_within_mono_right (range_subset_iff.2 hx) <| tendsto_nhds_within_range.2 h⟩\n#align exists_seq_strict_mono_tendsto_nhds_within exists_seq_strict_mono_tendsto_nhds_within\n\n",
 "exists_seq_strict_mono_tendsto'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_seq_strict_mono_tendsto' {α : Type _} [linear_order α] [topological_space α] [DenselyOrdered α]\n    [order_topology α] [first_countable_topology α] {x y : α} (hy : y < x) :\n    ∃ u : ℕ → α, strict_mono u ∧ (∀ n, u n ∈ Ioo y x) ∧ tendsto u at_top ((nhds) x) :=\n  by\n  have hx : x ∉ Ioo y x := fun h => (lt_irrefl x h.2).elim\n  have ht : Set.Nonempty (Ioo y x) := nonempty_Ioo.2 hy\n  rcases(isLUB_Ioo hy).exists_seq_strict_mono_tendsto_of_not_mem hx ht with ⟨u, hu⟩\n  exact ⟨u, hu.1, hu.2.2.symm⟩\n#align exists_seq_strict_mono_tendsto' exists_seq_strict_mono_tendsto'\n\n",
 "exists_seq_strict_mono_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_seq_strict_mono_tendsto [DenselyOrdered α] [NoMinOrder α] [first_countable_topology α] (x : α) :\n    ∃ u : ℕ → α, strict_mono u ∧ (∀ n, u n < x) ∧ tendsto u at_top ((nhds) x) :=\n  by\n  obtain ⟨y, hy⟩ : ∃ y, y < x := exists_lt x\n  rcases exists_seq_strict_mono_tendsto' hy with ⟨u, hu_mono, hu_mem, hux⟩\n  exact ⟨u, hu_mono, fun n => (hu_mem n).2, hux⟩\n#align exists_seq_strict_mono_tendsto exists_seq_strict_mono_tendsto\n\n",
 "exists_seq_strict_anti_tendsto_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_glb.exists_seq_strict_anti_tendsto_of_not_mem {t : set α} {x : α} [is_countably_generated ((nhds) x)]\n    (htx : IsGLB t x) (not_mem : x ∉ t) (ht : t.nonempty) :\n    ∃ u : ℕ → α, strict_anti u ∧ (∀ n, x < u n) ∧ tendsto u at_top ((nhds) x) ∧ ∀ n, u n ∈ t :=\n  @is_lub.exists_seq_strict_mono_tendsto_of_not_mem («expr ᵒᵈ» α) _ _ _ t x _ htx not_mem ht\n#align is_glb.exists_seq_strict_anti_tendsto_of_not_mem is_glb.exists_seq_strict_anti_tendsto_of_not_mem\n\n",
 "exists_seq_strict_anti_tendsto_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem exists_seq_strict_anti_tendsto_nhds_within [DenselyOrdered α] [NoMaxOrder α] [first_countable_topology α]\n    (x : α) : ∃ u : ℕ → α, strict_anti u ∧ (∀ n, x < u n) ∧ tendsto u at_top (nhds_within.gt x) :=\n  @exists_seq_strict_mono_tendsto_nhds_within («expr ᵒᵈ» α) _ _ _ _ _ _ _\n#align exists_seq_strict_anti_tendsto_nhds_within exists_seq_strict_anti_tendsto_nhds_within\n\n",
 "exists_seq_strict_anti_tendsto'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_seq_strict_anti_tendsto' [DenselyOrdered α] [first_countable_topology α] {x y : α} (hy : x < y) :\n    ∃ u : ℕ → α, strict_anti u ∧ (∀ n, u n ∈ Ioo x y) ∧ tendsto u at_top ((nhds) x) := by\n  simpa only [dual_Ioo] using exists_seq_strict_mono_tendsto' (OrderDual.toDual_lt_toDual.2 hy)\n#align exists_seq_strict_anti_tendsto' exists_seq_strict_anti_tendsto'\n\n",
 "exists_seq_strict_anti_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_seq_strict_anti_tendsto [DenselyOrdered α] [NoMaxOrder α] [first_countable_topology α] (x : α) :\n    ∃ u : ℕ → α, strict_anti u ∧ (∀ n, x < u n) ∧ tendsto u at_top ((nhds) x) :=\n  @exists_seq_strict_mono_tendsto («expr ᵒᵈ» α) _ _ _ _ _ _ x\n#align exists_seq_strict_anti_tendsto exists_seq_strict_anti_tendsto\n\n",
 "exists_seq_strict_anti_strict_mono_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_seq_strict_anti_strict_mono_tendsto [DenselyOrdered α] [first_countable_topology α] {x y : α}\n    (h : x < y) :\n    ∃ u v : ℕ → α,\n      strict_anti u ∧\n        strict_mono v ∧\n          (∀ k, u k ∈ Ioo x y) ∧\n            (∀ l, v l ∈ Ioo x y) ∧ (∀ k l, u k < v l) ∧ tendsto u at_top ((nhds) x) ∧ tendsto v at_top ((nhds) y) :=\n  by\n  rcases exists_seq_strict_anti_tendsto' h with ⟨u, hu_anti, hu_mem, hux⟩\n  rcases exists_seq_strict_mono_tendsto' (hu_mem 0).2 with ⟨v, hv_mono, hv_mem, hvy⟩\n  exact\n    ⟨u, v, hu_anti, hv_mono, hu_mem, fun l => ⟨(hu_mem 0).1.trans (hv_mem l).1, (hv_mem l).2⟩, fun k l =>\n      (hu_anti.antitone (zero_le k)).trans_lt (hv_mem l).1, hux, hvy⟩\n#align exists_seq_strict_anti_strict_mono_tendsto exists_seq_strict_anti_strict_mono_tendsto\n\n",
 "exists_seq_monotone_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_lub.exists_seq_monotone_tendsto {t : set α} {x : α} [is_countably_generated ((nhds) x)] (htx : IsLUB t x)\n    (ht : t.nonempty) : ∃ u : ℕ → α, monotone u ∧ (∀ n, u n ≤ x) ∧ tendsto u at_top ((nhds) x) ∧ ∀ n, u n ∈ t :=\n  by\n  by_cases h : x ∈ t\n  · exact ⟨fun n => x, monotone_const, fun n => le_rfl, tendsto_const_nhds, fun n => h⟩\n  · rcases htx.exists_seq_strict_mono_tendsto_of_not_mem h ht with ⟨u, hu⟩\n    exact ⟨u, hu.1.monotone, fun n => (hu.2.1 n).le, hu.2.2⟩\n#align is_lub.exists_seq_monotone_tendsto is_lub.exists_seq_monotone_tendsto\n\n",
 "exists_seq_antitone_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_glb.exists_seq_antitone_tendsto {t : set α} {x : α} [is_countably_generated ((nhds) x)] (htx : IsGLB t x)\n    (ht : t.nonempty) : ∃ u : ℕ → α, antitone u ∧ (∀ n, x ≤ u n) ∧ tendsto u at_top ((nhds) x) ∧ ∀ n, u n ∈ t :=\n  @is_lub.exists_seq_monotone_tendsto («expr ᵒᵈ» α) _ _ _ t x _ htx ht\n#align is_glb.exists_seq_antitone_tendsto is_glb.exists_seq_antitone_tendsto\n\n",
 "exists_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually.exists_lt [NoMinOrder α] {a : α} {p : α → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p x)) :\n    ∃ b < a, p b :=\n  @filter.eventually.exists_gt («expr ᵒᵈ» α) _ _ _ _ _ _ _ h\n#align filter.eventually.exists_lt filter.eventually.exists_lt\n\n",
 "exists_le'":
 "theorem dense.exists_le' {s : set α} (hs : dense s) (hbot : ∀ x, is_bot x → x ∈ s) (x : α) : ∃ y ∈ s, y ≤ x :=\n  by\n  by_cases hx : is_bot x\n  · exact ⟨x, hbot x hx, le_rfl⟩\n  · simp only [is_bot, not_forall, not_le] at hx\n    rcases hs.exists_mem_open is_open_Iio hx with ⟨y, hys, hy : y < x⟩\n    exact ⟨y, hys, hy.le⟩\n#align dense.exists_le' dense.exists_le'\n\n",
 "exists_le":
 "theorem dense.exists_le [NoMinOrder α] {s : set α} (hs : dense s) (x : α) : ∃ y ∈ s, y ≤ x :=\n  (hs.exists_lt x).imp fun y hy => ⟨hy.fst, hy.snd.le⟩\n#align dense.exists_le dense.exists_le\n\n",
 "exists_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually.exists_gt [NoMaxOrder α] {a : α} {p : α → Prop}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p x)) :\n    ∃ b > a, p b := by\n  simpa only [exists_prop, gt_iff_lt, and_comm'] using\n    ((h.filter_mono (@nhds_within_le_nhds _ _ a (Ioi a))).and self_mem_nhds_within).exists\n#align filter.eventually.exists_gt filter.eventually.exists_gt\n\n",
 "exists_ge'":
 "theorem dense.exists_ge' {s : set α} (hs : dense s) (htop : ∀ x, is_top x → x ∈ s) (x : α) : ∃ y ∈ s, x ≤ y :=\n  hs.order_dual.exists_le' htop x\n#align dense.exists_ge' dense.exists_ge'\n\n",
 "exists_ge":
 "theorem dense.exists_ge [NoMaxOrder α] {s : set α} (hs : dense s) (x : α) : ∃ y ∈ s, x ≤ y :=\n  hs.order_dual.exists_le x\n#align dense.exists_ge dense.exists_ge\n\n",
 "exists_countable_dense_subset_no_bot_top":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/-- Let `s` be a dense set in a nontrivial dense linear order `α`. If `s` is a\nseparable space (e.g., if `α` has a second countable topology), then there exists a countable\ndense subset `t ⊆ s` such that `t` does not contain bottom/top elements of `α`. -/\ntheorem dense.exists_countable_dense_subset_no_bot_top [nontrivial α] {s : set α} [separable_space s] (hs : dense s) :\n    ∃ (t : _)(_ : t ⊆ s), t.countable ∧ dense t ∧ (∀ x, is_bot x → x ∉ t) ∧ ∀ x, is_top x → x ∉ t :=\n  by\n  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩\n  refine' ⟨t \\ ({ x | is_bot x } ∪ { x | is_top x }), _, _, _, _, _⟩\n  · exact (diff_subset _ _).trans hts\n  · exact htc.mono (diff_subset _ _)\n  · exact htd.diff_finite ((subsingleton_is_bot α).finite.union (subsingleton_is_top α).finite)\n  · intro x hx\n    simp [hx]\n  · intro x hx\n    simp [hx]\n#align dense.exists_countable_dense_subset_no_bot_top dense.exists_countable_dense_subset_no_bot_top\n\n",
 "exists_countable_dense_no_bot_top":
 "/-- If `α` is a nontrivial separable dense linear order, then there exists a\ncountable dense set `s : set α` that contains neither top nor bottom elements of `α`.\nFor a dense set containing both bot and top elements, see\n`exists_countable_dense_bot_top`. -/\ntheorem exists_countable_dense_no_bot_top [separable_space α] [nontrivial α] :\n    ∃ s : set α, s.countable ∧ dense s ∧ (∀ x, is_bot x → x ∉ s) ∧ ∀ x, is_top x → x ∉ s := by\n  simpa using dense_univ.exists_countable_dense_subset_no_bot_top\n#align exists_countable_dense_no_bot_top exists_countable_dense_no_bot_top\n\n",
 "exists_between":
 "theorem dense.exists_between [DenselyOrdered α] {s : set α} (hs : dense s) {x y : α} (h : x < y) :\n    ∃ z ∈ s, z ∈ Ioo x y :=\n  hs.exists_mem_open is_open_Ioo (nonempty_Ioo.2 h)\n#align dense.exists_between dense.exists_between\n\n",
 "exists_Ioo_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually.exists_Ioo_subset [NoMaxOrder α] [NoMinOrder α] {a : α} {p : α → Prop}\n    (hp :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p x)) :\n    ∃ l u, a ∈ Ioo l u ∧ Ioo l u ⊆ { x | p x } :=\n  mem_nhds_iff_exists_Ioo_subset.1 hp\n#align filter.eventually.exists_Ioo_subset filter.eventually.exists_Ioo_subset\n\n",
 "exists_Ioc_subset_of_mem_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_Ioc_subset_of_mem_nhds' {a : α} {s : set α} (hs : s ∈ (nhds) a) {l : α} (hl : l < a) :\n    ∃ l' ∈ Ico l a, Ioc l' a ⊆ s :=\n  let ⟨l', hl'a, hl's⟩ := exists_Ioc_subset_of_mem_nhds hs ⟨l, hl⟩\n  ⟨max l l', ⟨le_max_left _ _, max_lt hl hl'a⟩, (Ioc_subset_Ioc_left <| le_max_right _ _).trans hl's⟩\n#align exists_Ioc_subset_of_mem_nhds' exists_Ioc_subset_of_mem_nhds'\n\n",
 "exists_Ioc_subset_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n-- see Note [lower instance priority]\ntheorem exists_Ioc_subset_of_mem_nhds {a : α} {s : set α} (hs : s ∈ (nhds) a) (h : ∃ l, l < a) : ∃ l < a, Ioc l a ⊆ s :=\n  (nhds_within_Iic_basis' h).mem_iff.mp (nhds_within_le_nhds hs)\n#align exists_Ioc_subset_of_mem_nhds exists_Ioc_subset_of_mem_nhds\n\n",
 "exists_Ico_subset_of_mem_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_Ico_subset_of_mem_nhds' {a : α} {s : set α} (hs : s ∈ (nhds) a) {u : α} (hu : a < u) :\n    ∃ u' ∈ Ioc a u, Ico a u' ⊆ s := by\n  simpa only [order_dual.exists, exists_prop, dual_Ico, dual_Ioc] using\n    exists_Ioc_subset_of_mem_nhds' (show «expr ⁻¹' » of_dual s ∈ (nhds) (to_dual a) from hs) hu.dual\n#align exists_Ico_subset_of_mem_nhds' exists_Ico_subset_of_mem_nhds'\n\n",
 "exists_Ico_subset_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_Ico_subset_of_mem_nhds {a : α} {s : set α} (hs : s ∈ (nhds) a) (h : ∃ u, a < u) :\n    ∃ (u : _)(_ : a < u), Ico a u ⊆ s :=\n  let ⟨l', hl'⟩ := h\n  let ⟨l, hl⟩ := exists_Ico_subset_of_mem_nhds' hs hl'\n  ⟨l, hl.fst.1, hl.snd⟩\n#align exists_Ico_subset_of_mem_nhds exists_Ico_subset_of_mem_nhds\n\n",
 "exists_Icc_mem_subset_of_mem_nhds_within_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\ntheorem exists_Icc_mem_subset_of_mem_nhds_within_Iic {a : α} {s : set α} (hs : s ∈ nhds_within.le a) :\n    ∃ b ≤ a, Icc b a ∈ nhds_within.le a ∧ Icc b a ⊆ s := by\n  simpa only [dual_Icc, to_dual.surjective.exists] using\n    @exists_Icc_mem_subset_of_mem_nhds_within_Ici («expr ᵒᵈ» α) _ _ _ (to_dual a) _ hs\n#align exists_Icc_mem_subset_of_mem_nhds_within_Iic exists_Icc_mem_subset_of_mem_nhds_within_Iic\n\n",
 "exists_Icc_mem_subset_of_mem_nhds_within_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\ntheorem exists_Icc_mem_subset_of_mem_nhds_within_Ici {a : α} {s : set α} (hs : s ∈ nhds_within.ge a) :\n    ∃ (b : _)(_ : a ≤ b), Icc a b ∈ nhds_within.ge a ∧ Icc a b ⊆ s :=\n  by\n  rcases(em (is_max a)).imp_right not_is_max_iff.mp with (ha | ha)\n  · use a\n    simpa [ha.Ici_eq] using hs\n  · rcases(nhds_within_Ici_basis' ha).mem_iff.mp hs with ⟨b, hab, hbs⟩\n    rcases eq_empty_or_nonempty (Ioo a b) with (H | ⟨c, hac, hcb⟩)\n    · have : Ico a b = Icc a a := by rw [← Icc_union_Ioo_eq_Ico le_rfl hab, H, union_empty]\n      exact ⟨a, le_rfl, this ▸ ⟨Ico_mem_nhds_within_Ici <| left_mem_Ico.2 hab, hbs⟩⟩\n    · refine' ⟨c, hac.le, Icc_mem_nhds_within_Ici <| left_mem_Ico.mpr hac, _⟩\n      exact (Icc_subset_Ico_right hcb).trans hbs\n#align exists_Icc_mem_subset_of_mem_nhds_within_Ici exists_Icc_mem_subset_of_mem_nhds_within_Ici\n\n",
 "exists_Icc_mem_subset_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_Icc_mem_subset_of_mem_nhds {a : α} {s : set α} (hs : s ∈ (nhds) a) :\n    ∃ b c, a ∈ Icc b c ∧ Icc b c ∈ (nhds) a ∧ Icc b c ⊆ s :=\n  by\n  rcases exists_Icc_mem_subset_of_mem_nhds_within_Iic (nhds_within_le_nhds hs) with ⟨b, hba, hb_nhds, hbs⟩\n  rcases exists_Icc_mem_subset_of_mem_nhds_within_Ici (nhds_within_le_nhds hs) with ⟨c, hac, hc_nhds, hcs⟩\n  refine' ⟨b, c, ⟨hba, hac⟩, _⟩\n  rw [← Icc_union_Icc_eq_Icc hba hac, ← nhds_left_sup_nhds_right]\n  exact ⟨union_mem_sup hb_nhds hc_nhds, union_subset hbs hcs⟩\n#align exists_Icc_mem_subset_of_mem_nhds exists_Icc_mem_subset_of_mem_nhds\n\n",
 "eventually_nhds_within_pos_mem_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem eventually_nhds_within_pos_mem_Ioo {ε : α} (h : 0 < ε) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.gt 0) (x ∈ Ioo 0 ε) :=\n  by\n  rw [eventually_iff, mem_nhds_within]\n  exact ⟨Ioo (-ε) ε, is_open_Ioo, by simp [h], fun x hx => ⟨hx.2, hx.1.2⟩⟩\n#align eventually_nhds_within_pos_mem_Ioo eventually_nhds_within_pos_mem_Ioo\n\n",
 "eventually_nhds_within_pos_mem_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem eventually_nhds_within_pos_mem_Ioc {ε : α} (h : 0 < ε) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.gt 0) (x ∈ Ioc 0 ε) :=\n  (eventually_nhds_within_pos_mem_Ioo h).mono Ioo_subset_Ioc_self\n#align eventually_nhds_within_pos_mem_Ioc eventually_nhds_within_pos_mem_Ioc\n\n",
 "eventually_lt_of_tendsto_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_lt_of_tendsto_lt {l : filter γ} {f : γ → α} {u v : α} (hv : v < u)\n    (h : filter.tendsto f l ((nhds) v)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (f a < u) :=\n  tendsto_nhds.1 h (· < u) is_open_Iio hv\n#align eventually_lt_of_tendsto_lt eventually_lt_of_tendsto_lt\n\n",
 "eventually_lt_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_lt_nhds (hab : a < b) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      (x < b) :=\n  eventually_iff.mpr (mem_nhds_iff.mpr ⟨Iio b, rfl.subset, is_open_Iio, hab⟩)\n#align eventually_lt_nhds eventually_lt_nhds\n\n",
 "eventually_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_at.eventually_lt {x₀ : β} (hf : continuous_at f x₀) (hg : continuous_at g x₀) (hfg : f x₀ < g x₀) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x₀)\n      (f x < g x) :=\n  tendsto.eventually_lt hf hg hfg\n#align continuous_at.eventually_lt continuous_at.eventually_lt\n\n",
 "eventually_le_of_tendsto_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_le_of_tendsto_lt {l : filter γ} {f : γ → α} {u v : α} (hv : v < u) (h : tendsto f l ((nhds) v)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (f a ≤ u) :=\n  (eventually_lt_of_tendsto_lt hv h).mono fun v => le_of_lt\n#align eventually_le_of_tendsto_lt eventually_le_of_tendsto_lt\n\n",
 "eventually_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_le_nhds (hab : a < b) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      (x ≤ b) :=\n  eventually_iff.mpr (mem_nhds_iff.mpr ⟨Iio b, Iio_subset_Iic_self, is_open_Iio, hab⟩)\n#align eventually_le_nhds eventually_le_nhds\n\n",
 "eventually_gt_of_tendsto_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_gt_of_tendsto_gt {l : filter γ} {f : γ → α} {u v : α} (hv : u < v)\n    (h : filter.tendsto f l ((nhds) v)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (u < f a) :=\n  tendsto_nhds.1 h (· > u) is_open_Ioi hv\n#align eventually_gt_of_tendsto_gt eventually_gt_of_tendsto_gt\n\n",
 "eventually_gt_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_gt_nhds (hab : b < a) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      (b < x) :=\n  eventually_iff.mpr (mem_nhds_iff.mpr ⟨Ioi b, rfl.subset, is_open_Ioi, hab⟩)\n#align eventually_gt_nhds eventually_gt_nhds\n\n",
 "eventually_ge_of_tendsto_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_ge_of_tendsto_gt {l : filter γ} {f : γ → α} {u v : α} (hv : u < v) (h : tendsto f l ((nhds) v)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (u ≤ f a) :=\n  (eventually_gt_of_tendsto_gt hv h).mono fun v => le_of_lt\n#align eventually_ge_of_tendsto_gt eventually_ge_of_tendsto_gt\n\n",
 "eventually_ge_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_ge_nhds (hab : b < a) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      (b ≤ x) :=\n  eventually_iff.mpr (mem_nhds_iff.mpr ⟨Ioi b, Ioi_subset_Ici_self, is_open_Ioi, hab⟩)\n#align eventually_ge_nhds eventually_ge_nhds\n\n",
 "eventually_abs_sub_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_abs_sub_lt (a : α) {ε : α} (hε : 0 < ε) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      (|x - a| < ε) :=\n  (nhds_eq_infi_abs_sub a).symm ▸\n    mem_infi_of_mem ε (mem_infi_of_mem hε <| by simp only [abs_sub_comm, mem_principal_self])\n#align eventually_abs_sub_lt eventually_abs_sub_lt\n\n",
 "epigraph":
 "theorem is_closed.epigraph [topological_space β] {f : β → α} {s : set β} (hs : is_closed s) (hf : continuous_on f s) :\n    is_closed { p : β × α | p.1 ∈ s ∧ f p.1 ≤ p.2 } :=\n  (hs.preimage continuous_fst).is_closed_le (hf.comp continuous_on_fst Subset.rfl) continuous_on_snd\n#align is_closed.epigraph is_closed.epigraph\n\n",
 "disjoint_nhds_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem disjoint_nhds_at_top [NoMaxOrder α] (x : α) : Disjoint ((nhds) x) at_top :=\n  by\n  rcases exists_gt x with ⟨y, hy : x < y⟩\n  refine' disjoint_of_disjoint_of_mem _ (Iio_mem_nhds hy) (mem_at_top y)\n  exact disjoint_left.mpr fun z => not_le.2\n#align disjoint_nhds_at_top disjoint_nhds_at_top\n\n",
 "disjoint_nhds_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem disjoint_nhds_at_bot [NoMinOrder α] (x : α) : Disjoint ((nhds) x) at_bot :=\n  @disjoint_nhds_at_top («expr ᵒᵈ» α) _ _ _ _ x\n#align disjoint_nhds_at_bot disjoint_nhds_at_bot\n\n",
 "dense_of_exists_between":
 "theorem dense_of_exists_between [nontrivial α] {s : set α} (h : ∀ ⦃a b⦄, a < b → ∃ c ∈ s, a < c ∧ c < b) : dense s :=\n  by\n  apply dense_iff_inter_open.2 fun U U_open U_nonempty => _\n  obtain ⟨a, b, hab, H⟩ : ∃ a b : α, a < b ∧ Ioo a b ⊆ U := U_open.exists_Ioo_subset U_nonempty\n  obtain ⟨x, xs, hx⟩ : ∃ (x : α)(H : x ∈ s), a < x ∧ x < b := h hab\n  exact ⟨x, ⟨H hx, xs⟩⟩\n#align dense_of_exists_between dense_of_exists_between\n\n",
 "dense_iff_exists_between":
 "/-- A set in a nontrivial densely linear ordered type is dense in the sense of topology if and only\nif for any `a < b` there exists `c ∈ s`, `a < c < b`. Each implication requires less typeclass\nassumptions. -/\ntheorem dense_iff_exists_between [DenselyOrdered α] [nontrivial α] {s : set α} :\n    dense s ↔ ∀ a b, a < b → ∃ c ∈ s, a < c ∧ c < b :=\n  ⟨fun h a b hab => h.exists_between hab, dense_of_exists_between⟩\n#align dense_iff_exists_between dense_iff_exists_between\n\n",
 "countable_of_isolated_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- The set of points which are isolated on the right is countable when the space is\nsecond-countable. -/\ntheorem countable_of_isolated_right [second_countable_topology α] :\n    set.countable { x : α | ∃ y, x < y ∧ Ioo x y = ∅ } :=\n  by\n  nontriviality α\n  let s := { x : α | ∃ y, x < y ∧ Ioo x y = ∅ }\n  have : ∀ x ∈ s, ∃ y, x < y ∧ Ioo x y = ∅ := fun x => id\n  choose! y hy h'y using this\n  have Hy : ∀ x z, x ∈ s → z < y x → z ≤ x := by\n    intro x z xs hz\n    have A : Ioo x (y x) = ∅ := h'y _ xs\n    contrapose! A\n    exact nonempty.ne_empty ⟨z, A, hz⟩\n  suffices H : ∀ a : set α, is_open a → set.countable { x | x ∈ s ∧ x ∈ a ∧ y x ∉ a }\n  · have :\n      s ⊆\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          { x | x ∈ s ∧ x ∈ a ∧ y x ∉ a } :=\n      by\n      intro x hx\n      rcases(is_basis_countable_basis α).exists_mem_of_ne (hy x hx).ne with ⟨a, ab, xa, ya⟩\n      simp only [mem_set_of_eq, mem_Union]\n      exact ⟨a, ab, hx, xa, ya⟩\n    apply countable.mono this\n    refine' countable.bUnion (countable_countable_basis α) fun a ha => H _ _\n    exact is_open_of_mem_countable_basis ha\n  intro a ha\n  suffices H : set.countable { x | x ∈ s ∧ x ∈ a ∧ y x ∉ a ∧ ¬is_bot x }\n  · have : { x | x ∈ s ∧ x ∈ a ∧ y x ∉ a } ⊆ { x | x ∈ s ∧ x ∈ a ∧ y x ∉ a ∧ ¬is_bot x } ∪ { x | is_bot x } :=\n      by\n      intro x hx\n      by_cases h'x : is_bot x\n      · simp only [h'x, mem_set_of_eq, mem_union, not_true, and_false_iff, false_or_iff]\n      ·\n        simpa only [h'x, hx.2.1, hx.2.2, mem_set_of_eq, mem_union, not_false_iff, and_true_iff, or_false_iff] using\n          hx.left\n    exact countable.mono this (H.union (subsingleton_is_bot α).countable)\n  let t := { x | x ∈ s ∧ x ∈ a ∧ y x ∉ a ∧ ¬is_bot x }\n  have : ∀ x ∈ t, ∃ z < x, Ioc z x ⊆ a := by\n    intro x hx\n    apply exists_Ioc_subset_of_mem_nhds (ha.mem_nhds hx.2.1)\n    simpa only [is_bot, not_forall, not_le] using hx.right.right.right\n  choose! z hz h'z using this\n  have : pairwise_disjoint t fun x => Ioc (z x) x :=\n    by\n    intro x xt x' x't hxx'\n    rcases lt_or_gt_of_ne hxx' with (h' | h')\n    · refine' disjoint_left.2 fun u ux ux' => xt.2.2.1 _\n      refine' h'z x' x't ⟨ux'.1.trans_le (ux.2.trans (hy x xt.1).le), _⟩\n      by_contra' H\n      exact false.elim (lt_irrefl _ ((Hy _ _ xt.1 H).trans_lt h'))\n    · refine' disjoint_left.2 fun u ux ux' => x't.2.2.1 _\n      refine' h'z x xt ⟨ux.1.trans_le (ux'.2.trans (hy x' x't.1).le), _⟩\n      by_contra' H\n      exact false.elim (lt_irrefl _ ((Hy _ _ x't.1 H).trans_lt h'))\n  refine' this.countable_of_is_open (fun x hx => _) fun x hx => ⟨x, hz x hx, le_rfl⟩\n  suffices H : Ioc (z x) x = Ioo (z x) (y x)\n  · rw [H]\n    exact is_open_Ioo\n  exact subset.antisymm (Ioc_subset_Ioo_right (hy x hx.1)) fun u hu => ⟨hu.1, Hy _ _ hx.1 hu.2⟩\n#align countable_of_isolated_right countable_of_isolated_right\n\n",
 "countable_of_isolated_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- The set of points which are isolated on the left is countable when the space is\nsecond-countable. -/\ntheorem countable_of_isolated_left [second_countable_topology α] : set.countable { x : α | ∃ y, y < x ∧ Ioo y x = ∅ } :=\n  by\n  convert @countable_of_isolated_right («expr ᵒᵈ» α) _ _ _ _\n  have : ∀ x y : α, Ioo x y = { z | z < y ∧ x < z } :=\n    by\n    simp_rw [and_comm', Ioo]\n    simp only [eq_self_iff_true, forall₂_true_iff]\n  simp_rw [this]\n  rfl\n#align countable_of_isolated_left countable_of_isolated_left\n\n",
 "countable_of_Ioo":
 "/-- Consider a disjoint family of intervals `(x, y)` with `x < y` in a second-countable space.\nThen the family is countable.\nThis is not a straightforward consequence of second-countability as some of these intervals might be\nempty (but in fact this can happen only for countably many of them). -/\ntheorem set.pairwise_disjoint.countable_of_Ioo [second_countable_topology α] {y : α → α} {s : set α}\n    (h : PairwiseDisjoint s fun x => Ioo x (y x)) (h' : ∀ x ∈ s, x < y x) : s.countable :=\n  by\n  let t := { x | x ∈ s ∧ (Ioo x (y x)).nonempty }\n  have t_count : t.countable :=\n    haveI : t ⊆ s := fun x hx => hx.1\n    (h.subset this).countable_of_is_open (fun x hx => is_open_Ioo) fun x hx => hx.2\n  have : s ⊆ t ∪ { x : α | ∃ x', x < x' ∧ Ioo x x' = ∅ } :=\n    by\n    intro x hx\n    by_cases h'x : (Ioo x (y x)).nonempty\n    · exact or.inl ⟨hx, h'x⟩\n    · exact or.inr ⟨y x, h' x hx, not_nonempty_iff_eq_empty.1 h'x⟩\n  exact countable.mono this (t_count.union countable_of_isolated_right)\n#align set.pairwise_disjoint.countable_of_Ioo set.pairwise_disjoint.countable_of_Ioo\n\n",
 "continuous_within_at_Ioo_iff_Ioi":
 "@[simp]\ntheorem continuous_within_at_Ioo_iff_Ioi [topological_space β] {a b : α} {f : α → β} (h : a < b) :\n    continuous_within_at f (Ioo a b) a ↔ continuous_within_at f (Ioi a) a := by\n  simp only [continuous_within_at, nhds_within_Ioo_eq_nhds_within_Ioi h]\n#align continuous_within_at_Ioo_iff_Ioi continuous_within_at_Ioo_iff_Ioi\n\n",
 "continuous_within_at_Ioo_iff_Iio":
 "@[simp]\ntheorem continuous_within_at_Ioo_iff_Iio {a b : α} {f : α → γ} (h : a < b) :\n    continuous_within_at f (Ioo a b) b ↔ continuous_within_at f (Iio b) b := by\n  simp only [continuous_within_at, nhds_within_Ioo_eq_nhds_within_Iio h]\n#align continuous_within_at_Ioo_iff_Iio continuous_within_at_Ioo_iff_Iio\n\n",
 "continuous_within_at_Ioc_iff_Ioi":
 "@[simp]\ntheorem continuous_within_at_Ioc_iff_Ioi [topological_space β] {a b : α} {f : α → β} (h : a < b) :\n    continuous_within_at f (Ioc a b) a ↔ continuous_within_at f (Ioi a) a := by\n  simp only [continuous_within_at, nhds_within_Ioc_eq_nhds_within_Ioi h]\n#align continuous_within_at_Ioc_iff_Ioi continuous_within_at_Ioc_iff_Ioi\n\n",
 "continuous_within_at_Ioc_iff_Iic":
 "@[simp]\ntheorem continuous_within_at_Ioc_iff_Iic [topological_space β] {a b : α} {f : α → β} (h : a < b) :\n    continuous_within_at f (Ioc a b) b ↔ continuous_within_at f (Iic b) b := by\n  simp only [continuous_within_at, nhds_within_Ioc_eq_nhds_within_Iic h]\n#align continuous_within_at_Ioc_iff_Iic continuous_within_at_Ioc_iff_Iic\n\n",
 "continuous_within_at_Ico_iff_Iio":
 "@[simp]\ntheorem continuous_within_at_Ico_iff_Iio {a b : α} {f : α → γ} (h : a < b) :\n    continuous_within_at f (Ico a b) b ↔ continuous_within_at f (Iio b) b := by\n  simp only [continuous_within_at, nhds_within_Ico_eq_nhds_within_Iio h]\n#align continuous_within_at_Ico_iff_Iio continuous_within_at_Ico_iff_Iio\n\n",
 "continuous_within_at_Ico_iff_Ici":
 "@[simp]\ntheorem continuous_within_at_Ico_iff_Ici [topological_space β] {a b : α} {f : α → β} (h : a < b) :\n    continuous_within_at f (Ico a b) a ↔ continuous_within_at f (Ici a) a := by\n  simp only [continuous_within_at, nhds_within_Ico_eq_nhds_within_Ici h]\n#align continuous_within_at_Ico_iff_Ici continuous_within_at_Ico_iff_Ici\n\n",
 "continuous_within_at_Icc_iff_Iic":
 "@[simp]\ntheorem continuous_within_at_Icc_iff_Iic [topological_space β] {a b : α} {f : α → β} (h : a < b) :\n    continuous_within_at f (Icc a b) b ↔ continuous_within_at f (Iic b) b := by\n  simp only [continuous_within_at, nhds_within_Icc_eq_nhds_within_Iic h]\n#align continuous_within_at_Icc_iff_Iic continuous_within_at_Icc_iff_Iic\n\n",
 "continuous_within_at_Icc_iff_Ici":
 "@[simp]\ntheorem continuous_within_at_Icc_iff_Ici [topological_space β] {a b : α} {f : α → β} (h : a < b) :\n    continuous_within_at f (Icc a b) a ↔ continuous_within_at f (Ici a) a := by\n  simp only [continuous_within_at, nhds_within_Icc_eq_nhds_within_Ici h]\n#align continuous_within_at_Icc_iff_Ici continuous_within_at_Icc_iff_Ici\n\n",
 "continuous_min":
 "theorem continuous_min : continuous fun p : α × α => min p.1 p.2 :=\n  continuous_fst.min continuous_snd\n#align continuous_min continuous_min\n\n",
 "continuous_max":
 "theorem continuous_max : continuous fun p : α × α => max p.1 p.2 :=\n  continuous_fst.max continuous_snd\n#align continuous_max continuous_max\n\n",
 "continuous_if_le":
 "theorem continuous_if_le [topological_space γ] [∀ x, decidable (f x ≤ g x)] {f' g' : β → γ} (hf : continuous f)\n    (hg : continuous g) (hf' : continuous_on f' { x | f x ≤ g x }) (hg' : continuous_on g' { x | g x ≤ f x })\n    (hfg : ∀ x, f x = g x → f' x = g' x) : continuous fun x => if f x ≤ g x then f' x else g' x :=\n  by\n  refine' continuous_if (fun a ha => hfg _ (frontier_le_subset_eq hf hg ha)) _ (hg'.mono _)\n  · rwa [(is_closed_le hf hg).closure_eq]\n  · simp only [not_le]\n    exact closure_lt_subset_le hg hf\n#align continuous_if_le continuous_if_le\n\n",
 "continuous_abs":
 "-- see Note [lower instance priority]\n-- If there exists `δ ∈ (0, ε)`, then we choose `δ`-nhd of `a` and `(ε-δ)`-nhd of `b`\n-- Otherwise `ε`-nhd of each point `a` is `{a}`\n@[continuity]\ntheorem continuous_abs : continuous (abs : α → α) :=\n  continuous_id.max continuous_neg\n#align continuous_abs continuous_abs\n\n",
 "comap_coe_nhds_within_Ioi_of_Ioo_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem comap_coe_nhds_within_Ioi_of_Ioo_subset (ha : s ⊆ Ioi a) (hs : s.nonempty → ∃ b > a, Ioo a b ⊆ s) :\n    comap (coe : s → α) (nhds_within.gt a) = at_bot :=\n  comap_coe_nhds_within_Iio_of_Ioo_subset (show «expr ⁻¹' » of_dual s ⊆ Iio (toDual a) from ha) fun h => by\n    simpa only [order_dual.exists, dual_Ioo] using hs h\n#align comap_coe_nhds_within_Ioi_of_Ioo_subset comap_coe_nhds_within_Ioi_of_Ioo_subset\n\n",
 "comap_coe_nhds_within_Iio_of_Ioo_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem comap_coe_nhds_within_Iio_of_Ioo_subset (hb : s ⊆ Iio b) (hs : s.nonempty → ∃ a < b, Ioo a b ⊆ s) :\n    comap (coe : s → α) (nhds_within.lt b) = at_top :=\n  by\n  nontriviality\n  haveI : nonempty s := nontrivial_iff_nonempty.1 ‹_›\n  rcases hs (nonempty_subtype.1 ‹_›) with ⟨a, h, hs⟩\n  ext u; constructor\n  · rintro ⟨t, ht, hts⟩\n    obtain ⟨x, ⟨hxa : a ≤ x, hxb : x < b⟩, hxt : Ioo x b ⊆ t⟩ :=\n      (mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset h).mp ht\n    obtain ⟨y, hxy, hyb⟩ := exists_between hxb\n    refine' mem_of_superset (mem_at_top ⟨y, hs ⟨hxa.trans_lt hxy, hyb⟩⟩) _\n    rintro ⟨z, hzs⟩ (hyz : y ≤ z)\n    refine' hts (hxt ⟨hxy.trans_le _, hb _⟩) <;> assumption\n  · intro hu\n    obtain ⟨x : s, hx : ∀ z, x ≤ z → z ∈ u⟩ := mem_at_top_sets.1 hu\n    exact ⟨Ioo x b, Ioo_mem_nhds_within_Iio (right_mem_Ioc.2 <| hb x.2), fun z hz => hx _ hz.1.le⟩\n#align comap_coe_nhds_within_Iio_of_Ioo_subset comap_coe_nhds_within_Iio_of_Ioo_subset\n\n",
 "comap_coe_Ioo_nhds_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/-- The `at_bot` filter for an open interval `Ioo a b` comes from the right-neighbourhoods filter at\nthe left endpoint in the ambient order. -/\ntheorem comap_coe_Ioo_nhds_within_Ioi (a b : α) : comap (coe : Ioo a b → α) (nhds_within.gt a) = at_bot :=\n  comap_coe_nhds_within_Ioi_of_Ioo_subset Ioo_subset_Ioi_self fun h => ⟨b, nonempty_Ioo.1 h, Subset.refl _⟩\n#align comap_coe_Ioo_nhds_within_Ioi comap_coe_Ioo_nhds_within_Ioi\n\n",
 "comap_coe_Ioo_nhds_within_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/-- The `at_top` filter for an open interval `Ioo a b` comes from the left-neighbourhoods filter at\nthe right endpoint in the ambient order. -/\ntheorem comap_coe_Ioo_nhds_within_Iio (a b : α) : comap (coe : Ioo a b → α) (nhds_within.lt b) = at_top :=\n  comap_coe_nhds_within_Iio_of_Ioo_subset Ioo_subset_Iio_self fun h => ⟨a, nonempty_Ioo.1 h, Subset.refl _⟩\n#align comap_coe_Ioo_nhds_within_Iio comap_coe_Ioo_nhds_within_Iio\n\n",
 "comap_coe_Ioi_nhds_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem comap_coe_Ioi_nhds_within_Ioi (a : α) : comap (coe : Ioi a → α) (nhds_within.gt a) = at_bot :=\n  comap_coe_nhds_within_Ioi_of_Ioo_subset (Subset.refl _) fun ⟨x, hx⟩ => ⟨x, hx, Ioo_subset_Ioi_self⟩\n#align comap_coe_Ioi_nhds_within_Ioi comap_coe_Ioi_nhds_within_Ioi\n\n",
 "comap_coe_Iio_nhds_within_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem comap_coe_Iio_nhds_within_Iio (a : α) : comap (coe : Iio a → α) (nhds_within.lt a) = at_top :=\n  @comap_coe_Ioi_nhds_within_Ioi («expr ᵒᵈ» α) _ _ _ _ a\n#align comap_coe_Iio_nhds_within_Iio comap_coe_Iio_nhds_within_Iio\n\n",
 "closure_lt_subset_le":
 "theorem closure_lt_subset_le [topological_space β] {f g : β → α} (hf : continuous f) (hg : continuous g) :\n    closure { b | f b < g b } ⊆ { b | f b ≤ g b } :=\n  (closure_minimal fun x => le_of_lt) <| is_closed_le hf hg\n#align closure_lt_subset_le closure_lt_subset_le\n\n",
 "closure_le_eq":
 "@[simp]\ntheorem closure_le_eq [topological_space β] {f g : β → α} (hf : continuous f) (hg : continuous g) :\n    closure { b | f b ≤ g b } = { b | f b ≤ g b } :=\n  (is_closed_le hf hg).closure_eq\n#align closure_le_eq closure_le_eq\n\n",
 "closure_le":
 "theorem continuous_within_at.closure_le [topological_space β] {f g : β → α} {s : set β} {x : β} (hx : x ∈ closure s)\n    (hf : continuous_within_at f s x) (hg : continuous_within_at g s x) (h : ∀ y ∈ s, f y ≤ g y) : f x ≤ g x :=\n  show (f x, g x) ∈ { p : α × α | p.1 ≤ p.2 } from\n    order_closed_topology.is_closed_le'.closure_subset ((hf.prod hg).mem_closure hx h)\n#align continuous_within_at.closure_le continuous_within_at.closure_le\n\n",
 "closure_interior_Icc":
 "theorem closure_interior_Icc {a b : α} (h : a ≠ b) : closure (interior (Icc a b)) = Icc a b :=\n  (closure_minimal interior_subset is_closed_Icc).antisymm <|\n    calc\n      Icc a b = closure (Ioo a b) := (closure_Ioo h).symm\n      _ ⊆ closure (interior (Icc a b)) := closure_mono (interior_maximal Ioo_subset_Icc_self is_open_Ioo)\n      \n#align closure_interior_Icc closure_interior_Icc\n\n",
 "closure_Ioo":
 "/-- The closure of the open interval `(a, b)` is the closed interval `[a, b]`. -/\n@[simp]\ntheorem closure_Ioo {a b : α} (hab : a ≠ b) : closure (Ioo a b) = Icc a b :=\n  by\n  apply subset.antisymm\n  · exact closure_minimal Ioo_subset_Icc_self is_closed_Icc\n  · cases' hab.lt_or_lt with hab hab\n    · rw [← diff_subset_closure_iff, Icc_diff_Ioo_same hab.le]\n      have hab' : (Ioo a b).nonempty := nonempty_Ioo.2 hab\n      simp only [insert_subset, singleton_subset_iff]\n      exact ⟨(isGLB_Ioo hab).mem_closure hab', (isLUB_Ioo hab).mem_closure hab'⟩\n    · rw [Icc_eq_empty_of_lt hab]\n      exact empty_subset _\n#align closure_Ioo closure_Ioo\n\n",
 "closure_Ioi'":
 "/-- The closure of the interval `(a, +∞)` is the closed interval `[a, +∞)`, unless `a` is a top\nelement. -/\ntheorem closure_Ioi' {a : α} (h : (Ioi a).nonempty) : closure (Ioi a) = Ici a :=\n  by\n  apply subset.antisymm\n  · exact closure_minimal Ioi_subset_Ici_self is_closed_Ici\n  · rw [← diff_subset_closure_iff, Ici_diff_Ioi_same, singleton_subset_iff]\n    exact is_glb_Ioi.mem_closure h\n#align closure_Ioi' closure_Ioi'\n\n",
 "closure_Ioi":
 "/-- The closure of the interval `(a, +∞)` is the closed interval `[a, +∞)`. -/\n@[simp]\ntheorem closure_Ioi (a : α) [NoMaxOrder α] : closure (Ioi a) = Ici a :=\n  closure_Ioi' nonempty_Ioi\n#align closure_Ioi closure_Ioi\n\n",
 "closure_Ioc":
 "/-- The closure of the interval `(a, b]` is the closed interval `[a, b]`. -/\n@[simp]\ntheorem closure_Ioc {a b : α} (hab : a ≠ b) : closure (Ioc a b) = Icc a b :=\n  by\n  apply subset.antisymm\n  · exact closure_minimal Ioc_subset_Icc_self is_closed_Icc\n  · apply subset.trans _ (closure_mono Ioo_subset_Ioc_self)\n    rw [closure_Ioo hab]\n#align closure_Ioc closure_Ioc\n\n",
 "closure_Iio'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- The closure of the interval `(-∞, a)` is the closed interval `(-∞, a]`, unless `a` is a bottom\nelement. -/\ntheorem closure_Iio' (h : (Iio a).nonempty) : closure (Iio a) = Iic a :=\n  @closure_Ioi' («expr ᵒᵈ» α) _ _ _ _ _ h\n#align closure_Iio' closure_Iio'\n\n",
 "closure_Iio":
 "/-- The closure of the interval `(-∞, a)` is the interval `(-∞, a]`. -/\n@[simp]\ntheorem closure_Iio (a : α) [NoMinOrder α] : closure (Iio a) = Iic a :=\n  closure_Iio' nonempty_Iio\n#align closure_Iio closure_Iio\n\n",
 "closure_Iic":
 "@[simp]\ntheorem closure_Iic (a : α) : closure (Iic a) = Iic a :=\n  is_closed_Iic.closure_eq\n#align closure_Iic closure_Iic\n\n",
 "closure_Ico":
 "/-- The closure of the interval `[a, b)` is the closed interval `[a, b]`. -/\n@[simp]\ntheorem closure_Ico {a b : α} (hab : a ≠ b) : closure (Ico a b) = Icc a b :=\n  by\n  apply subset.antisymm\n  · exact closure_minimal Ico_subset_Icc_self is_closed_Icc\n  · apply subset.trans _ (closure_mono Ioo_subset_Ico_self)\n    rw [closure_Ioo hab]\n#align closure_Ico closure_Ico\n\n",
 "closure_Ici":
 "@[simp]\ntheorem closure_Ici (a : α) : closure (Ici a) = Ici a :=\n  is_closed_Ici.closure_eq\n#align closure_Ici closure_Ici\n\n",
 "closure_Icc":
 "@[simp]\ntheorem closure_Icc (a b : α) : closure (Icc a b) = Icc a b :=\n  is_closed_Icc.closure_eq\n#align closure_Icc closure_Icc\n\n",
 "cSup_mem_closure":
 "theorem cSup_mem_closure {s : set α} (hs : s.nonempty) (B : BddAbove s) : supₛ s ∈ closure s :=\n  (isLUB_csupₛ hs B).mem_closure hs\n#align cSup_mem_closure cSup_mem_closure\n\n",
 "cSup_mem":
 "theorem is_closed.cSup_mem {s : set α} (hc : is_closed s) (hs : s.nonempty) (B : BddAbove s) : supₛ s ∈ s :=\n  (isLUB_csupₛ hs B).mem_of_is_closed hs hc\n#align is_closed.cSup_mem is_closed.cSup_mem\n\n",
 "cInf_mem_closure":
 "theorem cInf_mem_closure {s : set α} (hs : s.nonempty) (B : BddBelow s) : infₛ s ∈ closure s :=\n  (isGLB_cinfₛ hs B).mem_closure hs\n#align cInf_mem_closure cInf_mem_closure\n\n",
 "cInf_mem":
 "theorem is_closed.cInf_mem {s : set α} (hc : is_closed s) (hs : s.nonempty) (B : BddBelow s) : infₛ s ∈ s :=\n  (isGLB_cinfₛ hs B).mem_of_is_closed hs hc\n#align is_closed.cInf_mem is_closed.cInf_mem\n\n",
 "bdd_below_range_of_has_compact_mul_support":
 "/-- A continuous function with compact support is bounded below. -/\n@[to_additive \" A continuous function with compact support is bounded below. \"]\ntheorem continuous.bdd_below_range_of_has_compact_mul_support [One α] {f : β → α} (hf : continuous f)\n    (h : has_compact_mul_support f) : BddBelow (range f) :=\n  (h.is_compact_range hf).bdd_below\n#align continuous.bdd_below_range_of_has_compact_mul_support continuous.bdd_below_range_of_has_compact_mul_support\n\n",
 "bdd_below_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A continuous function is bounded below on a compact set. -/\ntheorem is_compact.bdd_below_image {f : β → α} {K : set β} (hK : is_compact K) (hf : continuous_on f K) :\n    BddBelow («expr '' » f K) :=\n  (hK.image_of_continuous_on hf).bdd_below\n#align is_compact.bdd_below_image is_compact.bdd_below_image\n\n",
 "bdd_below":
 "/-- A compact set is bounded below -/\ntheorem is_compact.bdd_below {s : set α} (hs : is_compact s) : BddBelow s :=\n  by\n  by_contra H\n  rcases hs.elim_finite_subcover_image (fun x (_ : x ∈ s) => @is_open_Ioi _ _ _ _ x) _ with ⟨t, st, ft, ht⟩\n  · refine' H (ft.bdd_below.imp fun C hC y hy => _)\n    rcases mem_Union₂.1 (ht hy) with ⟨x, hx, xy⟩\n    exact le_trans (hC hx) (le_of_lt xy)\n  · refine' fun x hx => mem_Union₂.2 (not_imp_comm.1 _ H)\n    exact fun h => ⟨x, fun y hy => le_of_not_lt (h.imp fun ys => ⟨_, hy, ys⟩)⟩\n#align is_compact.bdd_below is_compact.bdd_below\n\n",
 "bdd_above_range_of_has_compact_mul_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- A continuous function with compact support is bounded above. -/\n@[to_additive \" A continuous function with compact support is bounded above. \"]\ntheorem continuous.bdd_above_range_of_has_compact_mul_support [One α] {f : β → α} (hf : continuous f)\n    (h : has_compact_mul_support f) : BddAbove (range f) :=\n  @continuous.bdd_below_range_of_has_compact_mul_support («expr ᵒᵈ» α) _ _ _ _ _ _ _ _ hf h\n#align continuous.bdd_above_range_of_has_compact_mul_support continuous.bdd_above_range_of_has_compact_mul_support\n\n",
 "bdd_above_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A continuous function is bounded above on a compact set. -/\ntheorem is_compact.bdd_above_image {f : β → α} {K : set β} (hK : is_compact K) (hf : continuous_on f K) :\n    BddAbove («expr '' » f K) :=\n  @is_compact.bdd_below_image («expr ᵒᵈ» α) _ _ _ _ _ _ _ _ hK hf\n#align is_compact.bdd_above_image is_compact.bdd_above_image\n\n",
 "bdd_above":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- A compact set is bounded above -/\ntheorem is_compact.bdd_above {s : set α} (hs : is_compact s) : BddAbove s :=\n  @is_compact.bdd_below («expr ᵒᵈ» α) _ _ _ _ _ hs\n#align is_compact.bdd_above is_compact.bdd_above\n\n",
 "at_top_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to\n`at_top` and `g` tends to `C` then `f + g` tends to `at_top`. -/\ntheorem filter.tendsto.at_top_add {C : α} (hf : tendsto f l at_top) (hg : tendsto g l ((nhds) C)) :\n    tendsto (fun x => f x + g x) l at_top :=\n  by\n  conv in _ + _ => rw [add_comm]\n  exact hg.add_at_top hf\n#align filter.tendsto.at_top_add filter.tendsto.at_top_add\n\n",
 "at_bot_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to\n`at_bot` and `g` tends to `C` then `f + g` tends to `at_bot`. -/\ntheorem filter.tendsto.at_bot_add {C : α} (hf : tendsto f l at_bot) (hg : tendsto g l ((nhds) C)) :\n    tendsto (fun x => f x + g x) l at_bot :=\n  by\n  conv in _ + _ => rw [add_comm]\n  exact hg.add_at_bot hf\n#align filter.tendsto.at_bot_add filter.tendsto.at_bot_add\n\n",
 "add_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`\nand `g` tends to `at_top` then `f + g` tends to `at_top`. -/\ntheorem filter.tendsto.add_at_top {C : α} (hf : tendsto f l ((nhds) C)) (hg : tendsto g l at_top) :\n    tendsto (fun x => f x + g x) l at_top := by\n  nontriviality α\n  obtain ⟨C', hC'⟩ : ∃ C', C' < C := exists_lt C\n  refine' tendsto_at_top_add_left_of_le' _ C' _ hg\n  exact (hf.eventually (lt_mem_nhds hC')).mono fun x => le_of_lt\n#align filter.tendsto.add_at_top filter.tendsto.add_at_top\n\n",
 "add_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`\nand `g` tends to `at_bot` then `f + g` tends to `at_bot`. -/\ntheorem filter.tendsto.add_at_bot {C : α} (hf : tendsto f l ((nhds) C)) (hg : tendsto g l at_bot) :\n    tendsto (fun x => f x + g x) l at_bot :=\n  @filter.tendsto.add_at_top («expr ᵒᵈ» α) _ _ _ _ _ _ _ _ hf hg\n#align filter.tendsto.add_at_bot filter.tendsto.add_at_bot\n\n",
 "abs":
 "theorem continuous_on.abs (h : continuous_on f s) : continuous_on (fun x => |f x|) s := fun x hx => (h x hx).abs\n#align continuous_on.abs continuous_on.abs\n\n",
 "Sup_mem_closure":
 "theorem Sup_mem_closure {α : Type u} [topological_space α] [CompleteLinearOrder α] [order_topology α] {s : set α}\n    (hs : s.nonempty) : supₛ s ∈ closure s :=\n  (isLUB_supₛ s).mem_closure hs\n#align Sup_mem_closure Sup_mem_closure\n\n",
 "Sup_mem":
 "theorem is_closed.Sup_mem {α : Type u} [topological_space α] [CompleteLinearOrder α] [order_topology α] {s : set α}\n    (hs : s.nonempty) (hc : is_closed s) : supₛ s ∈ s :=\n  (isLUB_supₛ s).mem_of_is_closed hs hc\n#align is_closed.Sup_mem is_closed.Sup_mem\n\n",
 "Ioo_subset_closure_interior":
 "theorem Ioo_subset_closure_interior : Ioo a b ⊆ closure (interior (Ioo a b)) := by\n  simp only [interior_Ioo, subset_closure]\n#align Ioo_subset_closure_interior Ioo_subset_closure_interior\n\n",
 "Ioo_mem_nhds_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem Ioo_mem_nhds_within_Ioi {a b c : α} (H : b ∈ Ico a c) : Ioo a c ∈ nhds_within.gt b :=\n  mem_nhds_within.2 ⟨Iio c, is_open_Iio, H.2, by rw [inter_comm, Ioi_inter_Iio] <;> exact Ioo_subset_Ioo_left H.1⟩\n#align Ioo_mem_nhds_within_Ioi Ioo_mem_nhds_within_Ioi\n\n",
 "Ioo_mem_nhds_within_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem Ioo_mem_nhds_within_Iio {a b c : α} (H : b ∈ Ioc a c) : Ioo a c ∈ nhds_within.lt b := by\n  simpa only [dual_Ioo] using Ioo_mem_nhds_within_Ioi (show to_dual b ∈ Ico (to_dual c) (to_dual a) from H.symm)\n#align Ioo_mem_nhds_within_Iio Ioo_mem_nhds_within_Iio\n\n",
 "Ioo_mem_nhds_within_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\ntheorem Ioo_mem_nhds_within_Iic {a b c : α} (H : b ∈ Ioo a c) : Ioo a c ∈ nhds_within.le b :=\n  mem_nhds_within_of_mem_nhds <| is_open.mem_nhds is_open_Ioo H\n#align Ioo_mem_nhds_within_Iic Ioo_mem_nhds_within_Iic\n\n",
 "Ioo_mem_nhds_within_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\ntheorem Ioo_mem_nhds_within_Ici {a b c : α} (H : b ∈ Ioo a c) : Ioo a c ∈ nhds_within.ge b :=\n  mem_nhds_within_of_mem_nhds <| is_open.mem_nhds is_open_Ioo H\n#align Ioo_mem_nhds_within_Ici Ioo_mem_nhds_within_Ici\n\n",
 "Ioo_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem Ioo_mem_nhds {a b x : α} (ha : a < x) (hb : x < b) : Ioo a b ∈ (nhds) x :=\n  is_open.mem_nhds is_open_Ioo ⟨ha, hb⟩\n#align Ioo_mem_nhds Ioo_mem_nhds\n\n",
 "Ioi_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem Ioi_mem_nhds {a b : α} (h : a < b) : Ioi a ∈ (nhds) b :=\n  is_open.mem_nhds is_open_Ioi h\n#align Ioi_mem_nhds Ioi_mem_nhds\n\n",
 "Ioc_subset_closure_interior":
 "theorem Ioc_subset_closure_interior (a b : α) : Ioc a b ⊆ closure (interior (Ioc a b)) :=\n  by\n  rcases eq_or_ne a b with (rfl | h)\n  · simp\n  ·\n    calc\n      Ioc a b ⊆ Icc a b := Ioc_subset_Icc_self\n      _ = closure (Ioo a b) := (closure_Ioo h).symm\n      _ ⊆ closure (interior (Ioc a b)) := closure_mono (interior_maximal Ioo_subset_Ioc_self is_open_Ioo)\n      \n#align Ioc_subset_closure_interior Ioc_subset_closure_interior\n\n",
 "Ioc_mem_nhds_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem Ioc_mem_nhds_within_Ioi {a b c : α} (H : b ∈ Ico a c) : Ioc a c ∈ nhds_within.gt b :=\n  mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ioc_self\n#align Ioc_mem_nhds_within_Ioi Ioc_mem_nhds_within_Ioi\n\n",
 "Ioc_mem_nhds_within_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem Ioc_mem_nhds_within_Iio {a b c : α} (H : b ∈ Ioc a c) : Ioc a c ∈ nhds_within.lt b :=\n  mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ioc_self\n#align Ioc_mem_nhds_within_Iio Ioc_mem_nhds_within_Iio\n\n",
 "Ioc_mem_nhds_within_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\ntheorem Ioc_mem_nhds_within_Iic {a b c : α} (H : b ∈ Ioc a c) : Ioc a c ∈ nhds_within.le b := by\n  simpa only [dual_Ico] using Ico_mem_nhds_within_Ici (show to_dual b ∈ Ico (to_dual c) (to_dual a) from H.symm)\n#align Ioc_mem_nhds_within_Iic Ioc_mem_nhds_within_Iic\n\n",
 "Ioc_mem_nhds_within_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\ntheorem Ioc_mem_nhds_within_Ici {a b c : α} (H : b ∈ Ioo a c) : Ioc a c ∈ nhds_within.ge b :=\n  mem_of_superset (Ioo_mem_nhds_within_Ici H) Ioo_subset_Ioc_self\n#align Ioc_mem_nhds_within_Ici Ioc_mem_nhds_within_Ici\n\n",
 "Ioc_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem Ioc_mem_nhds {a b x : α} (ha : a < x) (hb : x < b) : Ioc a b ∈ (nhds) x :=\n  mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Ioc_self\n#align Ioc_mem_nhds Ioc_mem_nhds\n\n",
 "Inf_mem_closure":
 "theorem Inf_mem_closure {α : Type u} [topological_space α] [CompleteLinearOrder α] [order_topology α] {s : set α}\n    (hs : s.nonempty) : infₛ s ∈ closure s :=\n  (isGLB_infₛ s).mem_closure hs\n#align Inf_mem_closure Inf_mem_closure\n\n",
 "Inf_mem":
 "theorem is_closed.Inf_mem {α : Type u} [topological_space α] [CompleteLinearOrder α] [order_topology α] {s : set α}\n    (hs : s.nonempty) (hc : is_closed s) : infₛ s ∈ s :=\n  (isGLB_infₛ s).mem_of_is_closed hs hc\n#align is_closed.Inf_mem is_closed.Inf_mem\n\n",
 "Iio_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem Iio_mem_nhds {a b : α} (h : a < b) : Iio b ∈ (nhds) a :=\n  is_open.mem_nhds is_open_Iio h\n#align Iio_mem_nhds Iio_mem_nhds\n\n",
 "Iic_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem Iic_mem_nhds {a b : α} (h : a < b) : Iic b ∈ (nhds) a :=\n  mem_of_superset (Iio_mem_nhds h) Iio_subset_Iic_self\n#align Iic_mem_nhds Iic_mem_nhds\n\n",
 "Ico_subset_closure_interior":
 "theorem Ico_subset_closure_interior (a b : α) : Ico a b ⊆ closure (interior (Ico a b)) := by\n  simpa only [dual_Ioc] using Ioc_subset_closure_interior (OrderDual.toDual b) (OrderDual.toDual a)\n#align Ico_subset_closure_interior Ico_subset_closure_interior\n\n",
 "Ico_mem_nhds_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem Ico_mem_nhds_within_Ioi {a b c : α} (H : b ∈ Ico a c) : Ico a c ∈ nhds_within.gt b :=\n  mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ico_self\n#align Ico_mem_nhds_within_Ioi Ico_mem_nhds_within_Ioi\n\n",
 "Ico_mem_nhds_within_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem Ico_mem_nhds_within_Iio {a b c : α} (H : b ∈ Ioc a c) : Ico a c ∈ nhds_within.lt b :=\n  mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ico_self\n#align Ico_mem_nhds_within_Iio Ico_mem_nhds_within_Iio\n\n",
 "Ico_mem_nhds_within_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\ntheorem Ico_mem_nhds_within_Iic {a b c : α} (H : b ∈ Ioo a c) : Ico a c ∈ nhds_within.le b :=\n  mem_of_superset (Ioo_mem_nhds_within_Iic H) Ioo_subset_Ico_self\n#align Ico_mem_nhds_within_Iic Ico_mem_nhds_within_Iic\n\n",
 "Ico_mem_nhds_within_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\ntheorem Ico_mem_nhds_within_Ici {a b c : α} (H : b ∈ Ico a c) : Ico a c ∈ nhds_within.ge b :=\n  mem_nhds_within.2 ⟨Iio c, is_open_Iio, H.2, by simp only [inter_comm, Ici_inter_Iio, Ico_subset_Ico_left H.1]⟩\n#align Ico_mem_nhds_within_Ici Ico_mem_nhds_within_Ici\n\n",
 "Ico_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem Ico_mem_nhds {a b x : α} (ha : a < x) (hb : x < b) : Ico a b ∈ (nhds) x :=\n  mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Ico_self\n#align Ico_mem_nhds Ico_mem_nhds\n\n",
 "Ici_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem Ici_mem_nhds {a b : α} (h : a < b) : Ici a ∈ (nhds) b :=\n  mem_of_superset (Ioi_mem_nhds h) Ioi_subset_Ici_self\n#align Ici_mem_nhds Ici_mem_nhds\n\n",
 "Icc_mem_nhds_within_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem Icc_mem_nhds_within_Ioi {a b c : α} (H : b ∈ Ico a c) : Icc a c ∈ nhds_within.gt b :=\n  mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Icc_self\n#align Icc_mem_nhds_within_Ioi Icc_mem_nhds_within_Ioi\n\n",
 "Icc_mem_nhds_within_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\ntheorem Icc_mem_nhds_within_Iio {a b c : α} (H : b ∈ Ioc a c) : Icc a c ∈ nhds_within.lt b :=\n  mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Icc_self\n#align Icc_mem_nhds_within_Iio Icc_mem_nhds_within_Iio\n\n",
 "Icc_mem_nhds_within_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.le -/\ntheorem Icc_mem_nhds_within_Iic {a b c : α} (H : b ∈ Ioc a c) : Icc a c ∈ nhds_within.le b :=\n  mem_of_superset (Ioc_mem_nhds_within_Iic H) Ioc_subset_Icc_self\n#align Icc_mem_nhds_within_Iic Icc_mem_nhds_within_Iic\n\n",
 "Icc_mem_nhds_within_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ge -/\ntheorem Icc_mem_nhds_within_Ici {a b c : α} (H : b ∈ Ico a c) : Icc a c ∈ nhds_within.ge b :=\n  mem_of_superset (Ico_mem_nhds_within_Ici H) Ico_subset_Icc_self\n#align Icc_mem_nhds_within_Ici Icc_mem_nhds_within_Ici\n\n",
 "Icc_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem Icc_mem_nhds {a b x : α} (ha : a < x) (hb : x < b) : Icc a b ∈ (nhds) x :=\n  mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Icc_self\n#align Icc_mem_nhds Icc_mem_nhds\n\n"}