{"not_below_is_open":
 "theorem not_below_is_open : is_open (not_below y) :=\n  by\n  have h : monotone (not_below y) := by\n    intro x y' h\n    simp only [not_below, set_of, le_Prop_eq]\n    intro h₀ h₁\n    apply h₀ (le_trans h h₁)\n  exists h\n  rintro c\n  apply eq_of_forall_ge_iff\n  intro z\n  rw [ωSup_le_iff]\n  simp only [ωSup_le_iff, not_below, mem_set_of_eq, le_Prop_eq, OrderHom.coe_fun_mk, chain.map_coe, Function.comp_apply,\n    exists_imp, not_forall]\n#align not_below_is_open not_below_is_open\n\n",
 "is_ωSup_ωSup":
 "theorem is_ωSup_ωSup {α} [omega_complete_partial_order α] (c : chain α) : is_ωSup c (ωSup c) :=\n  by\n  constructor\n  · apply le_ωSup\n  · apply ωSup_le\n#align is_ωSup_ωSup is_ωSup_ωSup\n\n",
 "is_ωSup_iff_is_lub":
 "/-\nCopyright (c) 2020 Simon Hudon. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Simon Hudon\n-/\ntheorem is_ωSup_iff_is_lub {α : Type u} [preorder α] {c : chain α} {x : α} : is_ωSup c x ↔ IsLUB (range c) x := by\n  simp [is_ωSup, IsLUB, IsLeast, upperBounds, lowerBounds]\n#align is_ωSup_iff_is_lub is_ωSup_iff_is_lub\n\n",
 "is_open_univ":
 "theorem is_open_univ : is_open α univ :=\n  ⟨fun x y h hx => mem_univ _, @complete_lattice.top_continuous α Prop _ _⟩\n#align is_open_univ is_open_univ\n\n",
 "is_open_sUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_open_sUnion (s : set (set α)) (hs : ∀ t ∈ s, is_open α t) : is_open α (⋃₀ s) :=\n  by\n  simp only [is_open] at hs⊢\n  convert complete_lattice.Sup_continuous' («expr ⁻¹' » set_of s) _\n  · ext1 x\n    simp only [supₛ_apply, set_of_bijective.surjective.exists, exists_prop, mem_preimage, SetCoe.exists, supᵢ_Prop_eq,\n      mem_set_of_eq, subtype.coe_mk, mem_sUnion]\n  · intro p hp\n    exact hs (set_of p) (mem_preimage.1 hp)\n#align is_open_sUnion is_open_sUnion\n\n",
 "inter":
 "theorem is_open.inter (s t : set α) : is_open α s → is_open α t → is_open α (s ∩ t) :=\n  complete_lattice.inf_continuous'\n#align is_open.inter is_open.inter\n\n",
 "continuous_of_Scott_continuous":
 "theorem continuous_of_Scott_continuous {α β} [omega_complete_partial_order α] [omega_complete_partial_order β]\n    (f : Scott α → Scott β) (hf : omega_complete_partial_order.continuous' f) : continuous f :=\n  by\n  rw [continuous_def]\n  intro s hs\n  change continuous' (s ∘ f)\n  cases' hs with hs hs'\n  cases' hf with hf hf'\n  apply continuous.of_bundled\n  apply continuous_comp _ _ hf' hs'\n#align continuous_of_Scott_continuous continuous_of_Scott_continuous\n\n",
 "Scott_continuous_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:565:11: unsupported: specialize non-hyp -/\ntheorem Scott_continuous_of_continuous {α β} [omega_complete_partial_order α] [omega_complete_partial_order β]\n    (f : Scott α → Scott β) (hf : continuous f) : omega_complete_partial_order.continuous' f :=\n  by\n  simp only [continuous_def, («expr ⁻¹' » · ·)] at hf\n  have h : monotone f := by\n    intro x y h\n    cases' hf { x | ¬x ≤ f y } (not_below_is_open _) with hf hf'\n    clear hf'\n    specialize hf h\n    simp only [preimage, mem_set_of_eq, le_Prop_eq] at hf\n    by_contra H\n    apply hf H le_rfl\n  exists h\n  intro c\n  apply eq_of_forall_ge_iff\n  intro z\n  specialize «./././Mathport/Syntax/Translate/Tactic/Lean3.lean:565:11: unsupported: specialize non-hyp»\n  cases hf\n  specialize hf_h c\n  simp only [not_below, OrderHom.coe_fun_mk, eq_iff_iff, mem_set_of_eq] at hf_h\n  rw [← not_iff_not]\n  simp only [ωSup_le_iff, hf_h, ωSup, supᵢ, Sup, complete_lattice.Sup, complete_semilattice_Sup.Sup, exists_prop,\n    mem_range, OrderHom.coe_fun_mk, chain.map_coe, Function.comp_apply, eq_iff_iff, not_forall]\n  tauto\n#align Scott_continuous_of_continuous Scott_continuous_of_continuous\n\n"}