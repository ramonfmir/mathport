{"tendsto_compact_open_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_compact_open_restrict {ι : Type _} {l : Filter ι} {F : ι → «exprC( , )» α β} {f : «exprC( , )» α β}\n    (hFf : Filter.Tendsto F l ((nhds) f)) (s : Set α) :\n    Filter.Tendsto (fun i => (F i).restrict s) l ((nhds) (f.restrict s)) :=\n  (continuous_restrict s).continuous_at.tendsto.comp hFf\n#align tendsto_compact_open_restrict tendsto_compact_open_restrict\n\n",
 "tendsto_compact_open_iff_forall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_compact_open_iff_forall {ι : Type _} {l : Filter ι} (F : ι → «exprC( , )» α β) (f : «exprC( , )» α β) :\n    Filter.Tendsto F l ((nhds) f) ↔\n      ∀ (s) (hs : IsCompact s), Filter.Tendsto (fun i => (F i).restrict s) l ((nhds) (f.restrict s)) :=\n  by\n  rw [compact_open_eq_Inf_induced]\n  simp [nhds_infᵢ, nhds_induced, Filter.tendsto_comap_iff]\n#align tendsto_compact_open_iff_forall tendsto_compact_open_iff_forall\n\n",
 "preimage_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprivate theorem preimage_gen {s : Set α} (hs : IsCompact s) {u : Set γ} (hu : IsOpen u) :\n    «expr ⁻¹' » (ContinuousMap.comp g) (CompactOpen.gen s u) = CompactOpen.gen s («expr ⁻¹' » g u) :=\n  by\n  ext ⟨f, _⟩\n  change «expr '' » (g ∘ f) s ⊆ u ↔ «expr '' » f s ⊆ «expr ⁻¹' » g u\n  rw [image_comp, image_subset_iff]\n#align preimage_gen preimage_gen\n\n",
 "nhds_compact_open_eq_Inf_nhds_induced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_compact_open_eq_Inf_nhds_induced (f : «exprC( , )» α β) :\n    (nhds) f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (((nhds) (f.restrict s)).comap (ContinuousMap.restrict s)) :=\n  by\n  rw [compact_open_eq_Inf_induced]\n  simp [nhds_infᵢ, nhds_induced]\n#align nhds_compact_open_eq_Inf_nhds_induced nhds_compact_open_eq_Inf_nhds_induced\n\n",
 "is_open_gen":
 "-- The compact-open topology on the space of continuous maps α → β.\nprotected theorem is_open_gen {s : Set α} (hs : IsCompact s) {u : Set β} (hu : IsOpen u) :\n    IsOpen (CompactOpen.gen s u) :=\n  topological_space.generate_open.basic _ (by dsimp [mem_set_of_eq] <;> tauto)\n#align is_open_gen is_open_gen\n\n",
 "image_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\nprivate theorem image_gen {s : Set α} (hs : IsCompact s) {u : Set γ} (hu : IsOpen u) :\n    «expr ⁻¹' » (fun g : «exprC( , )» β γ => g.comp f) (CompactOpen.gen s u) = CompactOpen.gen («expr '' » f s) u :=\n  by\n  ext ⟨g, _⟩\n  change «expr '' » (g ∘ f) s ⊆ u ↔ «expr '' » g («expr '' » f s) ⊆ u\n  rw [Set.image_comp]\n#align image_gen image_gen\n\n",
 "image_coev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem image_coev {y : β} (s : Set α) : «expr '' » (coev α β y) s = lower_set.prod ({y} : Set β) s := by tidy\n#align image_coev image_coev\n\n",
 "gen_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem gen_univ (s : Set α) : CompactOpen.gen s (Set.univ : Set β) = Set.univ :=\n  Set.ext fun f => iff_true_intro («expr '' » f s).subset_univ\n#align gen_univ gen_univ\n\n",
 "gen_union":
 "@[simp]\ntheorem gen_union (s t : Set α) (u : Set β) : CompactOpen.gen (s ∪ t) u = CompactOpen.gen s u ∩ CompactOpen.gen t u :=\n  Set.ext fun f => (iff_of_eq (congr_arg (· ⊆ u) (image_union f s t))).trans union_subset_iff\n#align gen_union gen_union\n\n",
 "gen_inter":
 "@[simp]\ntheorem gen_inter (s : Set α) (u v : Set β) : CompactOpen.gen s (u ∩ v) = CompactOpen.gen s u ∩ CompactOpen.gen s v :=\n  Set.ext fun f => subset_inter_iff\n#align gen_inter gen_inter\n\n",
 "gen_empty_right":
 "theorem gen_empty_right {s : Set α} (h : s.nonempty) : CompactOpen.gen s (∅ : Set β) = ∅ :=\n  eq_empty_of_forall_not_mem fun f => (h.image _).not_subset_empty\n#align gen_empty_right gen_empty_right\n\n",
 "gen_empty":
 "/-\nCopyright (c) 2018 Reid Barton. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Reid Barton\n-/\n@[simp]\ntheorem gen_empty (u : Set β) : CompactOpen.gen (∅ : Set α) u = Set.univ :=\n  Set.ext fun f => iff_true_intro ((congr_arg (· ⊆ u) (image_empty f)).mpr u.empty_subset)\n#align gen_empty gen_empty\n\n",
 "exists_tendsto_compact_open_iff_forall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A family `F` of functions in `C(α, β)` converges in the compact-open topology, if and only if\nit converges in the compact-open topology on each compact subset of `α`. -/\ntheorem exists_tendsto_compact_open_iff_forall [LocallyCompactSpace α] [T2Space α] [T2Space β] {ι : Type _}\n    {l : Filter ι} [Filter.NeBot l] (F : ι → «exprC( , )» α β) :\n    (∃ f, Filter.Tendsto F l ((nhds) f)) ↔\n      ∀ (s : Set α) (hs : IsCompact s), ∃ f, Filter.Tendsto (fun i => (F i).restrict s) l ((nhds) f) :=\n  by\n  constructor\n  · rintro ⟨f, hf⟩ s hs\n    exact ⟨f.restrict s, tendsto_compact_open_restrict hf s⟩\n  · intro h\n    choose f hf using h\n    -- By uniqueness of limits in a `t2_space`, since `λ i, F i x` tends to both `f s₁ hs₁ x` and\n    -- `f s₂ hs₂ x`, we have `f s₁ hs₁ x = f s₂ hs₂ x`\n    have h :\n      ∀ (s₁) (hs₁ : IsCompact s₁) (s₂) (hs₂ : IsCompact s₂) (x : α) (hxs₁ : x ∈ s₁) (hxs₂ : x ∈ s₂),\n        f s₁ hs₁ ⟨x, hxs₁⟩ = f s₂ hs₂ ⟨x, hxs₂⟩ :=\n      by\n      rintro s₁ hs₁ s₂ hs₂ x hxs₁ hxs₂\n      haveI := is_compact_iff_compact_space.mp hs₁\n      haveI := is_compact_iff_compact_space.mp hs₂\n      have h₁ := (continuous_eval_const' (⟨x, hxs₁⟩ : s₁)).continuous_at.tendsto.comp (hf s₁ hs₁)\n      have h₂ := (continuous_eval_const' (⟨x, hxs₂⟩ : s₂)).continuous_at.tendsto.comp (hf s₂ hs₂)\n      exact tendsto_nhds_unique h₁ h₂\n    -- So glue the `f s hs` together and prove that this glued function `f₀` is a limit on each\n    -- compact set `s`\n    have hs : ∀ x : α, ∃ (s : _)(hs : IsCompact s), s ∈ (nhds) x :=\n      by\n      intro x\n      obtain ⟨s, hs, hs'⟩ := exists_compact_mem_nhds x\n      exact ⟨s, hs, hs'⟩\n    refine' ⟨lift_cover' _ _ h hs, _⟩\n    rw [tendsto_compact_open_iff_forall]\n    intro s hs\n    rw [lift_cover_restrict']\n    exact hf s hs\n#align exists_tendsto_compact_open_iff_forall exists_tendsto_compact_open_iff_forall\n\n",
 "curry_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp]\ntheorem curry_apply (f : «exprC( , )» (α × β) γ) (a : α) (b : β) : f.curry a b = f (a, b) :=\n  rfl\n#align curry_apply curry_apply\n\n",
 "continuous_uncurry_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- The uncurried form of a continuous map `α → C(β, γ)` is a continuous map `α × β → γ`. -/\ntheorem continuous_uncurry_of_continuous [LocallyCompactSpace β] (f : «exprC( , )» α («exprC( , )» β γ)) :\n    Continuous (function.uncurry fun x y => f x y) :=\n  continuous_eval'.comp <| f.continuous.prod_map continuous_id\n#align continuous_uncurry_of_continuous continuous_uncurry_of_continuous\n\n",
 "continuous_uncurry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- The uncurrying process is a continuous map between function spaces. -/\ntheorem continuous_uncurry [LocallyCompactSpace α] [LocallyCompactSpace β] :\n    Continuous (uncurry : «exprC( , )» α («exprC( , )» β γ) → «exprC( , )» (α × β) γ) :=\n  by\n  apply continuous_of_continuous_uncurry\n  rw [← Homeomorph.comp_continuous_iff' (Homeomorph.prodAssoc _ _ _)]\n  apply Continuous.comp continuous_eval' (Continuous.prod_map continuous_eval' continuous_id) <;> infer_instance\n#align continuous_uncurry continuous_uncurry\n\n",
 "continuous_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- For any subset `s` of `α`, the restriction of continuous functions to `s` is continuous as a\nfunction from `C(α, β)` to `C(s, β)` with their respective compact-open topologies. -/\ntheorem continuous_restrict (s : Set α) : Continuous fun F : «exprC( , )» α β => F.restrict s :=\n  by\n  rw [continuous_iff_le_induced]\n  exact compact_open_le_induced s\n#align continuous_restrict continuous_restrict\n\n",
 "continuous_of_continuous_uncurry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- To show continuity of a map `α → C(β, γ)`, it suffices to show that its uncurried form\n    `α × β → γ` is continuous. -/\ntheorem continuous_of_continuous_uncurry (f : α → «exprC( , )» β γ)\n    (h : Continuous (function.uncurry fun x y => f x y)) : Continuous f :=\n  by\n  convert continuous_curry' ⟨_, h⟩\n  ext\n  rfl\n#align continuous_of_continuous_uncurry continuous_of_continuous_uncurry\n\n",
 "continuous_map_of_unique_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp]\ntheorem continuous_map_of_unique_symm_apply [Unique α] (f : «exprC( , )» α β) :\n    continuousMapOfUnique.symm f = f default :=\n  rfl\n#align continuous_map_of_unique_symm_apply continuous_map_of_unique_symm_apply\n\n",
 "continuous_map_of_unique_apply":
 "@[simp]\ntheorem continuous_map_of_unique_apply [Unique α] (b : β) (a : α) : continuousMapOfUnique b a = b :=\n  rfl\n#align continuous_map_of_unique_apply continuous_map_of_unique_apply\n\n",
 "continuous_lift_prod_right":
 "#print QuotientMap.continuous_lift_prod_right /-\ntheorem QuotientMap.continuous_lift_prod_right (hf : QuotientMap f) {g : Y × X → Z}\n    (hg : Continuous fun p : Y × X₀ => g (p.1, f p.2)) : Continuous g :=\n  by\n  have : Continuous fun p : X₀ × Y => g ((Prod.swap p).1, f (Prod.swap p).2) := hg.comp continuous_swap\n  have : Continuous fun p : X₀ × Y => (g ∘ Prod.swap) (f p.1, p.2) := this\n  convert(hf.continuous_lift_prod_left this).comp continuous_swap\n  ext x\n  simp\n#align quotient_map.continuous_lift_prod_right QuotientMap.continuous_lift_prod_right\n-/\n\n",
 "continuous_lift_prod_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n#print QuotientMap.continuous_lift_prod_left /-\ntheorem QuotientMap.continuous_lift_prod_left (hf : QuotientMap f) {g : X × Y → Z}\n    (hg : Continuous fun p : X₀ × Y => g (f p.1, p.2)) : Continuous g :=\n  by\n  let Gf : «exprC( , )» X₀ («exprC( , )» Y Z) := ContinuousMap.curry ⟨_, hg⟩\n  have h : ∀ x : X, Continuous fun y => g (x, y) := by\n    intro x\n    obtain ⟨x₀, rfl⟩ := hf.surjective x\n    exact (Gf x₀).continuous\n  let G : X → «exprC( , )» Y Z := fun x => ⟨_, h x⟩\n  have : Continuous G := by\n    rw [hf.continuous_iff]\n    exact Gf.continuous\n  convert ContinuousMap.continuous_uncurry_of_continuous ⟨G, this⟩\n  ext x\n  cases x\n  rfl\n#align quotient_map.continuous_lift_prod_left QuotientMap.continuous_lift_prod_left\n-/\n\n",
 "continuous_eval_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- See also `continuous_map.continuous_eval_const` -/\ntheorem continuous_eval_const' [LocallyCompactSpace α] (a : α) : Continuous fun f : «exprC( , )» α β => f a :=\n  continuous_eval'.comp (continuous_id.prod_mk continuous_const)\n#align continuous_eval_const' continuous_eval_const'\n\n",
 "continuous_eval'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- The evaluation map `C(α, β) × α → β` is continuous if `α` is locally compact.\n\nSee also `continuous_map.continuous_eval` -/\ntheorem continuous_eval' [LocallyCompactSpace α] : Continuous fun p : «exprC( , )» α β × α => p.1 p.2 :=\n  continuous_iff_continuousAt.mpr fun ⟨f, x⟩ n hn =>\n    let ⟨v, vn, vo, fxv⟩ := mem_nhds_iff.mp hn\n    have : v ∈ (nhds) (f x) := IsOpen.mem_nhds vo fxv\n    let ⟨s, hs, sv, sc⟩ := locally_compact_space.local_compact_nhds x («expr ⁻¹' » f v) (f.continuous.tendsto x this)\n    let ⟨u, us, uo, xu⟩ := mem_nhds_iff.mp hs\n    show «expr ⁻¹' » (fun p : «exprC( , )» α β × α => p.1 p.2) n ∈ (nhds) (f, x) from\n      let w := lower_set.prod (CompactOpen.gen s v) u\n      have : w ⊆ «expr ⁻¹' » (fun p : «exprC( , )» α β × α => p.1 p.2) n := fun ⟨f', x'⟩ ⟨hf', hx'⟩ =>\n        calc\n          f' x' ∈ «expr '' » f' s := mem_image_of_mem f' (us hx')\n          _ ⊆ v := hf'\n          _ ⊆ n := vn\n          \n      have : IsOpen w := (ContinuousMap.isOpen_gen sc vo).prod uo\n      have : (f, x) ∈ w := ⟨image_subset_iff.mpr sv, xu⟩\n      mem_nhds_iff.mpr ⟨w, by assumption, by assumption, by assumption⟩\n#align continuous_eval' continuous_eval'\n\n",
 "continuous_curry'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- If a map `α × β → γ` is continuous, then its curried form `α → C(β, γ)` is continuous. -/\ntheorem continuous_curry' (f : «exprC( , )» (α × β) γ) : Continuous (curry' f) :=\n  have hf : curry' f = ContinuousMap.comp f ∘ coev _ _ := by\n    ext\n    rfl\n  hf ▸ Continuous.comp (continuous_comp f) continuous_coev\n#align continuous_curry' continuous_curry'\n\n",
 "continuous_curry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n#print continuous_curry /-\n/-- The currying process is a continuous map between function spaces. -/\ntheorem continuous_curry [LocallyCompactSpace (α × β)] :\n    Continuous (curry : «exprC( , )» (α × β) γ → «exprC( , )» α («exprC( , )» β γ)) :=\n  by\n  apply continuous_of_continuous_uncurry\n  apply continuous_of_continuous_uncurry\n  rw [← Homeomorph.comp_continuous_iff' (Homeomorph.prodAssoc _ _ _).symm]\n  convert continuous_eval' <;> tidy\n#align continuous_curry continuous_curry\n-/\n\n",
 "continuous_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem continuous_const' : Continuous (const α : β → «exprC( , )» α β) :=\n  const'.continuous\n#align continuous_const' continuous_const'\n\n",
 "continuous_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- C(-, γ) is a functor. -/\ntheorem continuous_comp_left : Continuous (fun g => g.comp f : «exprC( , )» β γ → «exprC( , )» α γ) :=\n  continuous_generateFrom fun m ⟨s, hs, u, hu, hm⟩ =>\n    by\n    rw [hm, image_gen f hs hu]\n    exact ContinuousMap.isOpen_gen (hs.image f.2) hu\n#align continuous_comp_left continuous_comp_left\n\n",
 "continuous_comp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- Composition is a continuous map from `C(α, β) × C(β, γ)` to `C(α, γ)`, provided that `β` is\n  locally compact. This is Prop. 9 of Chap. X, §3, №. 4 of Bourbaki's *Topologie Générale*. -/\ntheorem continuous_comp' [LocallyCompactSpace β] :\n    Continuous fun x : «exprC( , )» α β × «exprC( , )» β γ => x.2.comp x.1 :=\n  continuous_generateFrom\n    (by\n      rintro M ⟨K, hK, U, hU, rfl⟩\n      conv =>\n        congr\n        rw [compact_open.gen, preimage_set_of_eq]\n        congr\n        ext\n        rw [coe_comp, image_comp, image_subset_iff]\n      rw [isOpen_iff_forall_mem_open]\n      rintro ⟨φ₀, ψ₀⟩ H\n      obtain ⟨L, hL, hKL, hLU⟩ := exists_compact_between (hK.image φ₀.2) (hU.preimage ψ₀.2) H\n      use\n        lower_set.prod { φ : «exprC( , )» α β | «expr '' » φ K ⊆ interior L }\n          { ψ : «exprC( , )» β γ | «expr '' » ψ L ⊆ U }\n      use fun ⟨φ, ψ⟩ ⟨hφ, hψ⟩ => subset_trans hφ (interior_subset.trans <| image_subset_iff.mp hψ)\n      use (ContinuousMap.isOpen_gen hK isOpen_interior).prod (ContinuousMap.isOpen_gen hL hU)\n      exact mem_prod.mpr ⟨hKL, image_subset_iff.mpr hLU⟩)\n#align continuous_comp' continuous_comp'\n\n",
 "continuous_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- C(α, -) is a functor. -/\ntheorem continuous_comp : Continuous (ContinuousMap.comp g : «exprC( , )» α β → «exprC( , )» α γ) :=\n  continuous_generateFrom fun m ⟨s, hs, u, hu, hm⟩ => by\n    rw [hm, preimage_gen g hs hu] <;> exact ContinuousMap.isOpen_gen hs (hu.preimage g.2)\n#align continuous_comp continuous_comp\n\n",
 "continuous_coev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n-- The coevaluation map β → C(α, β × α) is continuous (always).\ntheorem continuous_coev : Continuous (coev α β) :=\n  continuous_generateFrom <| by\n    rintro _ ⟨s, sc, u, uo, rfl⟩\n    rw [isOpen_iff_forall_mem_open]\n    intro y hy\n    change «expr '' » (coev α β y) s ⊆ u at hy\n    rw [image_coev s] at hy\n    rcases generalized_tube_lemma isCompact_singleton sc uo hy with ⟨v, w, vo, wo, yv, sw, vwu⟩\n    refine' ⟨v, _, vo, singleton_subset_iff.mp yv⟩\n    intro y' hy'\n    change «expr '' » (coev α β y') s ⊆ u\n    rw [image_coev s]\n    exact subset.trans (prod_mono (singleton_subset_iff.mpr hy') sw) vwu\n#align continuous_coev continuous_coev\n\n",
 "continuous_coe'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- See also `continuous_map.continuous_coe` -/\ntheorem continuous_coe' [LocallyCompactSpace α] : @Continuous («exprC( , )» α β) (α → β) _ _ coe_fn :=\n  continuous_pi continuous_eval_const'\n#align continuous_coe' continuous_coe'\n\n",
 "compact_open_le_induced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem compact_open_le_induced (s : Set α) :\n    (ContinuousMap.compactOpen : TopologicalSpace («exprC( , )» α β)) ≤\n      TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen :=\n  by\n  simp only [induced_generateFrom_eq, ContinuousMap.compactOpen]\n  apply TopologicalSpace.generateFrom_anti\n  rintro b ⟨a, ⟨c, hc, u, hu, rfl⟩, rfl⟩\n  refine' ⟨«expr '' » coe c, hc.image continuous_subtype_val, u, hu, _⟩\n  ext f\n  simp only [compact_open.gen, mem_set_of_eq, mem_preimage, ContinuousMap.coe_restrict]\n  rw [image_comp f (coe : s → α)]\n#align compact_open_le_induced compact_open_le_induced\n\n",
 "compact_open_eq_Inf_induced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- The compact-open topology on `C(α, β)` is equal to the infimum of the compact-open topologies\non `C(s, β)` for `s` a compact subset of `α`.  The key point of the proof is that the union of the\ncompact subsets of `α` is equal to the union of compact subsets of the compact subsets of `α`. -/\ntheorem compact_open_eq_Inf_induced :\n    (ContinuousMap.compactOpen : TopologicalSpace («exprC( , )» α β)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen) :=\n  by\n  refine' le_antisymm _ _\n  · refine' le_infᵢ₂ _\n    exact fun s hs => compact_open_le_induced s\n  simp only [← generateFrom_unionᵢ, induced_generateFrom_eq, ContinuousMap.compactOpen]\n  apply TopologicalSpace.generateFrom_anti\n  rintro _ ⟨s, hs, u, hu, rfl⟩\n  rw [mem_Union₂]\n  refine' ⟨s, hs, _, ⟨univ, is_compact_iff_is_compact_univ.mp hs, u, hu, rfl⟩, _⟩\n  ext f\n  simp only [compact_open.gen, mem_set_of_eq, mem_preimage, ContinuousMap.coe_restrict]\n  rw [image_comp f (coe : s → α)]\n  simp\n#align compact_open_eq_Inf_induced compact_open_eq_Inf_induced\n\n",
 "comp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem continuous.comp' {X : Type _} [TopologicalSpace X] [LocallyCompactSpace β] {f : X → «exprC( , )» α β}\n    {g : X → «exprC( , )» β γ} (hf : Continuous f) (hg : Continuous g) : Continuous fun x => (g x).comp (f x) :=\n  continuous_comp'.comp (hf.prod_mk hg : Continuous fun x => (f x, g x))\n#align continuous.comp' continuous.comp'\n\n",
 "coe_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp]\ntheorem coe_const' : (const' : β → «exprC( , )» α β) = const α :=\n  rfl\n#align coe_const' coe_const'\n\n"}