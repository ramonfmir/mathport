{"tendsto_compact_open_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_compact_open_restrict {ι : Type _} {l : filter ι} {F : ι → «exprC( , )» α β} {f : «exprC( , )» α β}\n    (hFf : filter.tendsto F l ((nhds) f)) (s : set α) :\n    filter.tendsto (fun i => (F i).restrict s) l ((nhds) (f.restrict s)) :=\n  (continuous_restrict s).continuous_at.tendsto.comp hFf\n#align tendsto_compact_open_restrict tendsto_compact_open_restrict\n\n",
 "tendsto_compact_open_iff_forall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_compact_open_iff_forall {ι : Type _} {l : filter ι} (F : ι → «exprC( , )» α β) (f : «exprC( , )» α β) :\n    filter.tendsto F l ((nhds) f) ↔\n      ∀ (s) (hs : is_compact s), filter.tendsto (fun i => (F i).restrict s) l ((nhds) (f.restrict s)) :=\n  by\n  rw [compact_open_eq_Inf_induced]\n  simp [nhds_infi, nhds_induced, filter.tendsto_comap_iff]\n#align tendsto_compact_open_iff_forall tendsto_compact_open_iff_forall\n\n",
 "preimage_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprivate theorem preimage_gen {s : set α} (hs : is_compact s) {u : set γ} (hu : is_open u) :\n    «expr ⁻¹' » (continuous_map.comp g) (compact_open.gen s u) = compact_open.gen s («expr ⁻¹' » g u) :=\n  by\n  ext ⟨f, _⟩\n  change «expr '' » (g ∘ f) s ⊆ u ↔ «expr '' » f s ⊆ «expr ⁻¹' » g u\n  rw [image_comp, image_subset_iff]\n#align preimage_gen preimage_gen\n\n",
 "nhds_compact_open_eq_Inf_nhds_induced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_compact_open_eq_Inf_nhds_induced (f : «exprC( , )» α β) :\n    (nhds) f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (((nhds) (f.restrict s)).comap (continuous_map.restrict s)) :=\n  by\n  rw [compact_open_eq_Inf_induced]\n  simp [nhds_infi, nhds_induced]\n#align nhds_compact_open_eq_Inf_nhds_induced nhds_compact_open_eq_Inf_nhds_induced\n\n",
 "is_open_gen":
 "-- The compact-open topology on the space of continuous maps α → β.\nprotected theorem is_open_gen {s : set α} (hs : is_compact s) {u : set β} (hu : is_open u) :\n    is_open (compact_open.gen s u) :=\n  topological_space.generate_open.basic _ (by dsimp [mem_set_of_eq] <;> tauto)\n#align is_open_gen is_open_gen\n\n",
 "image_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\nprivate theorem image_gen {s : set α} (hs : is_compact s) {u : set γ} (hu : is_open u) :\n    «expr ⁻¹' » (fun g : «exprC( , )» β γ => g.comp f) (compact_open.gen s u) = compact_open.gen («expr '' » f s) u :=\n  by\n  ext ⟨g, _⟩\n  change «expr '' » (g ∘ f) s ⊆ u ↔ «expr '' » g («expr '' » f s) ⊆ u\n  rw [Set.image_comp]\n#align image_gen image_gen\n\n",
 "image_coev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\ntheorem image_coev {y : β} (s : set α) : «expr '' » (coev α β y) s = lower_set.prod ({y} : set β) s := by tidy\n#align image_coev image_coev\n\n",
 "gen_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem gen_univ (s : set α) : compact_open.gen s (Set.univ : set β) = Set.univ :=\n  Set.ext fun f => iff_true_intro («expr '' » f s).subset_univ\n#align gen_univ gen_univ\n\n",
 "gen_union":
 "@[simp]\ntheorem gen_union (s t : set α) (u : set β) :\n    compact_open.gen (s ∪ t) u = compact_open.gen s u ∩ compact_open.gen t u :=\n  Set.ext fun f => (iff_of_eq (congr_arg (· ⊆ u) (image_union f s t))).trans union_subset_iff\n#align gen_union gen_union\n\n",
 "gen_inter":
 "@[simp]\ntheorem gen_inter (s : set α) (u v : set β) :\n    compact_open.gen s (u ∩ v) = compact_open.gen s u ∩ compact_open.gen s v :=\n  Set.ext fun f => subset_inter_iff\n#align gen_inter gen_inter\n\n",
 "gen_empty_right":
 "theorem gen_empty_right {s : set α} (h : s.nonempty) : compact_open.gen s (∅ : set β) = ∅ :=\n  eq_empty_of_forall_not_mem fun f => (h.image _).not_subset_empty\n#align gen_empty_right gen_empty_right\n\n",
 "gen_empty":
 "/-\nCopyright (c) 2018 Reid Barton. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Reid Barton\n-/\n@[simp]\ntheorem gen_empty (u : set β) : compact_open.gen (∅ : set α) u = Set.univ :=\n  Set.ext fun f => iff_true_intro ((congr_arg (· ⊆ u) (image_empty f)).mpr u.empty_subset)\n#align gen_empty gen_empty\n\n",
 "exists_tendsto_compact_open_iff_forall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A family `F` of functions in `C(α, β)` converges in the compact-open topology, if and only if\nit converges in the compact-open topology on each compact subset of `α`. -/\ntheorem exists_tendsto_compact_open_iff_forall [locally_compact_space α] [t2_space α] [t2_space β] {ι : Type _}\n    {l : filter ι} [filter.ne_bot l] (F : ι → «exprC( , )» α β) :\n    (∃ f, filter.tendsto F l ((nhds) f)) ↔\n      ∀ (s : set α) (hs : is_compact s), ∃ f, filter.tendsto (fun i => (F i).restrict s) l ((nhds) f) :=\n  by\n  constructor\n  · rintro ⟨f, hf⟩ s hs\n    exact ⟨f.restrict s, tendsto_compact_open_restrict hf s⟩\n  · intro h\n    choose f hf using h\n    -- By uniqueness of limits in a `t2_space`, since `λ i, F i x` tends to both `f s₁ hs₁ x` and\n    -- `f s₂ hs₂ x`, we have `f s₁ hs₁ x = f s₂ hs₂ x`\n    have h :\n      ∀ (s₁) (hs₁ : is_compact s₁) (s₂) (hs₂ : is_compact s₂) (x : α) (hxs₁ : x ∈ s₁) (hxs₂ : x ∈ s₂),\n        f s₁ hs₁ ⟨x, hxs₁⟩ = f s₂ hs₂ ⟨x, hxs₂⟩ :=\n      by\n      rintro s₁ hs₁ s₂ hs₂ x hxs₁ hxs₂\n      haveI := is_compact_iff_compact_space.mp hs₁\n      haveI := is_compact_iff_compact_space.mp hs₂\n      have h₁ := (continuous_eval_const' (⟨x, hxs₁⟩ : s₁)).continuous_at.tendsto.comp (hf s₁ hs₁)\n      have h₂ := (continuous_eval_const' (⟨x, hxs₂⟩ : s₂)).continuous_at.tendsto.comp (hf s₂ hs₂)\n      exact tendsto_nhds_unique h₁ h₂\n    -- So glue the `f s hs` together and prove that this glued function `f₀` is a limit on each\n    -- compact set `s`\n    have hs : ∀ x : α, ∃ (s : _)(hs : is_compact s), s ∈ (nhds) x :=\n      by\n      intro x\n      obtain ⟨s, hs, hs'⟩ := exists_compact_mem_nhds x\n      exact ⟨s, hs, hs'⟩\n    refine' ⟨lift_cover' _ _ h hs, _⟩\n    rw [tendsto_compact_open_iff_forall]\n    intro s hs\n    rw [lift_cover_restrict']\n    exact hf s hs\n#align exists_tendsto_compact_open_iff_forall exists_tendsto_compact_open_iff_forall\n\n",
 "curry_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp]\ntheorem curry_apply (f : «exprC( , )» (α × β) γ) (a : α) (b : β) : f.curry a b = f (a, b) :=\n  rfl\n#align curry_apply curry_apply\n\n",
 "continuous_uncurry_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- The uncurried form of a continuous map `α → C(β, γ)` is a continuous map `α × β → γ`. -/\ntheorem continuous_uncurry_of_continuous [locally_compact_space β] (f : «exprC( , )» α («exprC( , )» β γ)) :\n    continuous (function.uncurry fun x y => f x y) :=\n  continuous_eval'.comp <| f.continuous.prod_map continuous_id\n#align continuous_uncurry_of_continuous continuous_uncurry_of_continuous\n\n",
 "continuous_uncurry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- The uncurrying process is a continuous map between function spaces. -/\ntheorem continuous_uncurry [locally_compact_space α] [locally_compact_space β] :\n    continuous (uncurry : «exprC( , )» α («exprC( , )» β γ) → «exprC( , )» (α × β) γ) :=\n  by\n  apply continuous_of_continuous_uncurry\n  rw [← homeomorph.comp_continuous_iff' (homeomorph.prod_assoc _ _ _)]\n  apply continuous.comp continuous_eval' (continuous.prod_map continuous_eval' continuous_id) <;> infer_instance\n#align continuous_uncurry continuous_uncurry\n\n",
 "continuous_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- For any subset `s` of `α`, the restriction of continuous functions to `s` is continuous as a\nfunction from `C(α, β)` to `C(s, β)` with their respective compact-open topologies. -/\ntheorem continuous_restrict (s : set α) : continuous fun F : «exprC( , )» α β => F.restrict s :=\n  by\n  rw [continuous_iff_le_induced]\n  exact compact_open_le_induced s\n#align continuous_restrict continuous_restrict\n\n",
 "continuous_of_continuous_uncurry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- To show continuity of a map `α → C(β, γ)`, it suffices to show that its uncurried form\n    `α × β → γ` is continuous. -/\ntheorem continuous_of_continuous_uncurry (f : α → «exprC( , )» β γ)\n    (h : continuous (function.uncurry fun x y => f x y)) : continuous f :=\n  by\n  convert continuous_curry' ⟨_, h⟩\n  ext\n  rfl\n#align continuous_of_continuous_uncurry continuous_of_continuous_uncurry\n\n",
 "continuous_map_of_unique_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp]\ntheorem continuous_map_of_unique_symm_apply [unique α] (f : «exprC( , )» α β) :\n    continuous_map_of_unique.symm f = f default :=\n  rfl\n#align continuous_map_of_unique_symm_apply continuous_map_of_unique_symm_apply\n\n",
 "continuous_map_of_unique_apply":
 "@[simp]\ntheorem continuous_map_of_unique_apply [unique α] (b : β) (a : α) : continuous_map_of_unique b a = b :=\n  rfl\n#align continuous_map_of_unique_apply continuous_map_of_unique_apply\n\n",
 "continuous_lift_prod_right":
 "theorem quotient_map.continuous_lift_prod_right (hf : quotient_map f) {g : Y × X → Z}\n    (hg : continuous fun p : Y × X₀ => g (p.1, f p.2)) : continuous g :=\n  by\n  have : continuous fun p : X₀ × Y => g ((prod.swap p).1, f (prod.swap p).2) := hg.comp continuous_swap\n  have : continuous fun p : X₀ × Y => (g ∘ prod.swap) (f p.1, p.2) := this\n  convert (hf.continuous_lift_prod_left this).comp continuous_swap\n  ext x\n  simp\n#align quotient_map.continuous_lift_prod_right quotient_map.continuous_lift_prod_right\n\n",
 "continuous_lift_prod_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem quotient_map.continuous_lift_prod_left (hf : quotient_map f) {g : X × Y → Z}\n    (hg : continuous fun p : X₀ × Y => g (f p.1, p.2)) : continuous g :=\n  by\n  let Gf : «exprC( , )» X₀ («exprC( , )» Y Z) := continuous_map.curry ⟨_, hg⟩\n  have h : ∀ x : X, continuous fun y => g (x, y) := by\n    intro x\n    obtain ⟨x₀, rfl⟩ := hf.surjective x\n    exact (Gf x₀).continuous\n  let G : X → «exprC( , )» Y Z := fun x => ⟨_, h x⟩\n  have : continuous G := by\n    rw [hf.continuous_iff]\n    exact Gf.continuous\n  convert continuous_map.continuous_uncurry_of_continuous ⟨G, this⟩\n  ext x\n  cases x\n  rfl\n#align quotient_map.continuous_lift_prod_left quotient_map.continuous_lift_prod_left\n\n",
 "continuous_eval_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- See also `continuous_map.continuous_eval_const` -/\ntheorem continuous_eval_const' [locally_compact_space α] (a : α) : continuous fun f : «exprC( , )» α β => f a :=\n  continuous_eval'.comp (continuous_id.prod_mk continuous_const)\n#align continuous_eval_const' continuous_eval_const'\n\n",
 "continuous_eval'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- The evaluation map `C(α, β) × α → β` is continuous if `α` is locally compact.\n\nSee also `continuous_map.continuous_eval` -/\ntheorem continuous_eval' [locally_compact_space α] : continuous fun p : «exprC( , )» α β × α => p.1 p.2 :=\n  continuous_iff_continuous_at.mpr fun ⟨f, x⟩ n hn =>\n    let ⟨v, vn, vo, fxv⟩ := mem_nhds_iff.mp hn\n    have : v ∈ (nhds) (f x) := is_open.mem_nhds vo fxv\n    let ⟨s, hs, sv, sc⟩ := locally_compact_space.local_compact_nhds x («expr ⁻¹' » f v) (f.continuous.tendsto x this)\n    let ⟨u, us, uo, xu⟩ := mem_nhds_iff.mp hs\n    show «expr ⁻¹' » (fun p : «exprC( , )» α β × α => p.1 p.2) n ∈ (nhds) (f, x) from\n      let w := lower_set.prod (compact_open.gen s v) u\n      have : w ⊆ «expr ⁻¹' » (fun p : «exprC( , )» α β × α => p.1 p.2) n := fun ⟨f', x'⟩ ⟨hf', hx'⟩ =>\n        calc\n          f' x' ∈ «expr '' » f' s := mem_image_of_mem f' (us hx')\n          _ ⊆ v := hf'\n          _ ⊆ n := vn\n          \n      have : is_open w := (continuous_map.is_open_gen sc vo).prod uo\n      have : (f, x) ∈ w := ⟨image_subset_iff.mpr sv, xu⟩\n      mem_nhds_iff.mpr ⟨w, by assumption, by assumption, by assumption⟩\n#align continuous_eval' continuous_eval'\n\n",
 "continuous_curry'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- If a map `α × β → γ` is continuous, then its curried form `α → C(β, γ)` is continuous. -/\ntheorem continuous_curry' (f : «exprC( , )» (α × β) γ) : continuous (curry' f) :=\n  have hf : curry' f = continuous_map.comp f ∘ coev _ _ := by\n    ext\n    rfl\n  hf ▸ continuous.comp (continuous_comp f) continuous_coev\n#align continuous_curry' continuous_curry'\n\n",
 "continuous_curry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- The currying process is a continuous map between function spaces. -/\ntheorem continuous_curry [locally_compact_space (α × β)] :\n    continuous (curry : «exprC( , )» (α × β) γ → «exprC( , )» α («exprC( , )» β γ)) :=\n  by\n  apply continuous_of_continuous_uncurry\n  apply continuous_of_continuous_uncurry\n  rw [← homeomorph.comp_continuous_iff' (homeomorph.prod_assoc _ _ _).symm]\n  convert continuous_eval' <;> tidy\n#align continuous_curry continuous_curry\n\n",
 "continuous_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem continuous_const' : continuous (const α : β → «exprC( , )» α β) :=\n  const'.continuous\n#align continuous_const' continuous_const'\n\n",
 "continuous_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- C(-, γ) is a functor. -/\ntheorem continuous_comp_left : continuous (fun g => g.comp f : «exprC( , )» β γ → «exprC( , )» α γ) :=\n  continuous_generated_from fun m ⟨s, hs, u, hu, hm⟩ =>\n    by\n    rw [hm, image_gen f hs hu]\n    exact continuous_map.is_open_gen (hs.image f.2) hu\n#align continuous_comp_left continuous_comp_left\n\n",
 "continuous_comp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- Composition is a continuous map from `C(α, β) × C(β, γ)` to `C(α, γ)`, provided that `β` is\n  locally compact. This is Prop. 9 of Chap. X, §3, №. 4 of Bourbaki's *Topologie Générale*. -/\ntheorem continuous_comp' [locally_compact_space β] :\n    continuous fun x : «exprC( , )» α β × «exprC( , )» β γ => x.2.comp x.1 :=\n  continuous_generated_from\n    (by\n      rintro M ⟨K, hK, U, hU, rfl⟩\n      conv =>\n        congr\n        rw [compact_open.gen, preimage_set_of_eq]\n        congr\n        ext\n        rw [coe_comp, image_comp, image_subset_iff]\n      rw [is_open_iff_forall_mem_open]\n      rintro ⟨φ₀, ψ₀⟩ H\n      obtain ⟨L, hL, hKL, hLU⟩ := exists_compact_between (hK.image φ₀.2) (hU.preimage ψ₀.2) H\n      use\n        lower_set.prod { φ : «exprC( , )» α β | «expr '' » φ K ⊆ interior L }\n          { ψ : «exprC( , )» β γ | «expr '' » ψ L ⊆ U }\n      use fun ⟨φ, ψ⟩ ⟨hφ, hψ⟩ => subset_trans hφ (interior_subset.trans <| image_subset_iff.mp hψ)\n      use (continuous_map.is_open_gen hK is_open_interior).prod (continuous_map.is_open_gen hL hU)\n      exact mem_prod.mpr ⟨hKL, image_subset_iff.mpr hLU⟩)\n#align continuous_comp' continuous_comp'\n\n",
 "continuous_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- C(α, -) is a functor. -/\ntheorem continuous_comp : continuous (continuous_map.comp g : «exprC( , )» α β → «exprC( , )» α γ) :=\n  continuous_generated_from fun m ⟨s, hs, u, hu, hm⟩ => by\n    rw [hm, preimage_gen g hs hu] <;> exact continuous_map.is_open_gen hs (hu.preimage g.2)\n#align continuous_comp continuous_comp\n\n",
 "continuous_coev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n-- The coevaluation map β → C(α, β × α) is continuous (always).\ntheorem continuous_coev : continuous (coev α β) :=\n  continuous_generated_from <| by\n    rintro _ ⟨s, sc, u, uo, rfl⟩\n    rw [is_open_iff_forall_mem_open]\n    intro y hy\n    change «expr '' » (coev α β y) s ⊆ u at hy\n    rw [image_coev s] at hy\n    rcases generalized_tube_lemma is_compact_singleton sc uo hy with ⟨v, w, vo, wo, yv, sw, vwu⟩\n    refine' ⟨v, _, vo, singleton_subset_iff.mp yv⟩\n    intro y' hy'\n    change «expr '' » (coev α β y') s ⊆ u\n    rw [image_coev s]\n    exact subset.trans (prod_mono (singleton_subset_iff.mpr hy') sw) vwu\n#align continuous_coev continuous_coev\n\n",
 "continuous_coe'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- See also `continuous_map.continuous_coe` -/\ntheorem continuous_coe' [locally_compact_space α] : @continuous («exprC( , )» α β) (α → β) _ _ coe_fn :=\n  continuous_pi continuous_eval_const'\n#align continuous_coe' continuous_coe'\n\n",
 "compact_open_le_induced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem compact_open_le_induced (s : set α) :\n    (continuous_map.compact_open : topological_space («exprC( , )» α β)) ≤\n      topological_space.induced (continuous_map.restrict s) continuous_map.compact_open :=\n  by\n  simp only [induced_generate_from_eq, continuous_map.compact_open]\n  apply generate_from_mono\n  rintro b ⟨a, ⟨c, hc, u, hu, rfl⟩, rfl⟩\n  refine' ⟨«expr '' » coe c, hc.image continuous_subtype_coe, u, hu, _⟩\n  ext f\n  simp only [compact_open.gen, mem_set_of_eq, mem_preimage, continuous_map.coe_restrict]\n  rw [image_comp f (coe : s → α)]\n#align compact_open_le_induced compact_open_le_induced\n\n",
 "compact_open_eq_Inf_induced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- The compact-open topology on `C(α, β)` is equal to the infimum of the compact-open topologies\non `C(s, β)` for `s` a compact subset of `α`.  The key point of the proof is that the union of the\ncompact subsets of `α` is equal to the union of compact subsets of the compact subsets of `α`. -/\ntheorem compact_open_eq_Inf_induced :\n    (continuous_map.compact_open : topological_space («exprC( , )» α β)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (topological_space.induced (continuous_map.restrict s) continuous_map.compact_open) :=\n  by\n  refine' le_antisymm _ _\n  · refine' le_infᵢ₂ _\n    exact fun s hs => compact_open_le_induced s\n  simp only [← generate_from_Union, induced_generate_from_eq, continuous_map.compact_open]\n  apply generate_from_mono\n  rintro _ ⟨s, hs, u, hu, rfl⟩\n  rw [mem_Union₂]\n  refine' ⟨s, hs, _, ⟨univ, is_compact_iff_is_compact_univ.mp hs, u, hu, rfl⟩, _⟩\n  ext f\n  simp only [compact_open.gen, mem_set_of_eq, mem_preimage, continuous_map.coe_restrict]\n  rw [image_comp f (coe : s → α)]\n  simp\n#align compact_open_eq_Inf_induced compact_open_eq_Inf_induced\n\n",
 "comp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem continuous.comp' {X : Type _} [topological_space X] [locally_compact_space β] {f : X → «exprC( , )» α β}\n    {g : X → «exprC( , )» β γ} (hf : continuous f) (hg : continuous g) : continuous fun x => (g x).comp (f x) :=\n  continuous_comp'.comp (hf.prod_mk hg : continuous fun x => (f x, g x))\n#align continuous.comp' continuous.comp'\n\n",
 "coe_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp]\ntheorem coe_const' : (const' : β → «exprC( , )» α β) = const α :=\n  rfl\n#align coe_const' coe_const'\n\n"}