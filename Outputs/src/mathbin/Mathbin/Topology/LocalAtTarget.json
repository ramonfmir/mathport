{"restrict_preimage_open_embedding":
 "theorem set.restrict_preimage_open_embedding (s : set β) (h : open_embedding f) :\n    open_embedding (s.restrict_preimage f) :=\n  ⟨h.1.restrict_preimage s, (s.range_restrict_preimage f).symm ▸ continuous_subtype_coe.is_open_preimage _ h.2⟩\n#align set.restrict_preimage_open_embedding set.restrict_preimage_open_embedding\n\n",
 "restrict_preimage_is_closed_map":
 "theorem set.restrict_preimage_is_closed_map (s : set β) (H : is_closed_map f) : is_closed_map (s.restrict_preimage f) :=\n  by\n  rintro t ⟨u, hu, e⟩\n  refine' ⟨⟨_, (H _ (is_open.is_closed_compl hu)).1, _⟩⟩\n  rw [← (congr_arg has_compl.compl e).trans (compl_compl t)]\n  simp only [Set.preimage_compl, compl_inj_iff]\n  ext ⟨x, hx⟩\n  suffices (∃ y, y ∉ u ∧ f y = x) ↔ ∃ y, f y ∈ s ∧ y ∉ u ∧ f y = x by simpa [Set.restrictPreimage, ← subtype.coe_inj]\n  exact ⟨fun ⟨a, b, c⟩ => ⟨a, c.symm ▸ hx, b, c⟩, fun ⟨a, _, b, c⟩ => ⟨a, b, c⟩⟩\n#align set.restrict_preimage_is_closed_map set.restrict_preimage_is_closed_map\n\n",
 "restrict_preimage_inducing":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem set.restrict_preimage_inducing (s : set β) (h : inducing f) : inducing (s.restrict_preimage f) :=\n  by\n  simp_rw [inducing_coe.inducing_iff, inducing_iff_nhds, restrict_preimage, maps_to.coe_restrict, restrict_eq, ←\n    @filter.comap_comap _ _ _ _ coe f] at h⊢\n  intro a\n  rw [← h, ← inducing_coe.nhds_eq_comap]\n#align set.restrict_preimage_inducing set.restrict_preimage_inducing\n\n",
 "restrict_preimage_embedding":
 "theorem set.restrict_preimage_embedding (s : set β) (h : embedding f) : embedding (s.restrict_preimage f) :=\n  ⟨h.1.restrict_preimage s, h.2.restrict_preimage s⟩\n#align set.restrict_preimage_embedding set.restrict_preimage_embedding\n\n",
 "restrict_preimage_closed_embedding":
 "theorem set.restrict_preimage_closed_embedding (s : set β) (h : closed_embedding f) :\n    closed_embedding (s.restrict_preimage f) :=\n  ⟨h.1.restrict_preimage s, (s.range_restrict_preimage f).symm ▸ inducing_coe.is_closed_preimage _ h.2⟩\n#align set.restrict_preimage_closed_embedding set.restrict_preimage_closed_embedding\n\n",
 "open_embedding_iff_open_embedding_of_supr_eq_top":
 "theorem open_embedding_iff_open_embedding_of_supr_eq_top (h : continuous f) :\n    open_embedding f ↔ ∀ i, open_embedding ((U i).1.restrict_preimage f) :=\n  by\n  simp_rw [open_embedding_iff]\n  rw [forall_and]\n  apply and_congr\n  · apply embedding_iff_embedding_of_supr_eq_top <;> assumption\n  · simp_rw [Set.range_restrictPreimage]\n    apply is_open_iff_coe_preimage_of_supr_eq_top hU\n#align open_embedding_iff_open_embedding_of_supr_eq_top open_embedding_iff_open_embedding_of_supr_eq_top\n\n",
 "is_open_iff_inter_of_supr_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_open_iff_inter_of_supr_eq_top (s : set β) : is_open s ↔ ∀ i, is_open (s ∩ U i) :=\n  by\n  constructor\n  · exact fun H i => H.inter (U i).2\n  · intro H\n    have :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i : set β) =\n        Set.univ :=\n      by\n      convert congr_arg coe hU\n      simp\n    rw [← s.inter_univ, ← this, Set.inter_unionᵢ]\n    exact is_open_Union H\n#align is_open_iff_inter_of_supr_eq_top is_open_iff_inter_of_supr_eq_top\n\n",
 "is_open_iff_coe_preimage_of_supr_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_open_iff_coe_preimage_of_supr_eq_top (s : set β) :\n    is_open s ↔ ∀ i, is_open («expr ⁻¹' » coe s : set (U i)) :=\n  by\n  simp_rw [(U _).2.open_embedding_subtype_coe.open_iff_image_open, Set.image_preimage_eq_inter_range, Subtype.range_coe]\n  apply is_open_iff_inter_of_supr_eq_top\n  assumption\n#align is_open_iff_coe_preimage_of_supr_eq_top is_open_iff_coe_preimage_of_supr_eq_top\n\n",
 "is_closed_map_iff_is_closed_map_of_supr_eq_top":
 "theorem is_closed_map_iff_is_closed_map_of_supr_eq_top :\n    is_closed_map f ↔ ∀ i, is_closed_map ((U i).1.restrict_preimage f) :=\n  by\n  refine' ⟨fun h i => set.restrict_preimage_is_closed_map _ h, _⟩\n  rintro H s hs\n  rw [is_closed_iff_coe_preimage_of_supr_eq_top hU]\n  intro i\n  convert H i _ ⟨⟨_, hs.1, eq_compl_comm.mpr rfl⟩⟩\n  ext ⟨x, hx⟩\n  suffices (∃ y, y ∈ s ∧ f y = x) ↔ ∃ y, f y ∈ U i ∧ y ∈ s ∧ f y = x by simpa [Set.restrictPreimage, ← subtype.coe_inj]\n  exact ⟨fun ⟨a, b, c⟩ => ⟨a, c.symm ▸ hx, b, c⟩, fun ⟨a, _, b, c⟩ => ⟨a, b, c⟩⟩\n#align is_closed_map_iff_is_closed_map_of_supr_eq_top is_closed_map_iff_is_closed_map_of_supr_eq_top\n\n",
 "is_closed_iff_coe_preimage_of_supr_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_closed_iff_coe_preimage_of_supr_eq_top (s : set β) :\n    is_closed s ↔ ∀ i, is_closed («expr ⁻¹' » coe s : set (U i)) := by\n  simpa using is_open_iff_coe_preimage_of_supr_eq_top hU («expr ᶜ» s)\n#align is_closed_iff_coe_preimage_of_supr_eq_top is_closed_iff_coe_preimage_of_supr_eq_top\n\n",
 "inducing_iff_inducing_of_supr_eq_top":
 "theorem inducing_iff_inducing_of_supr_eq_top (h : continuous f) :\n    inducing f ↔ ∀ i, inducing ((U i).1.restrict_preimage f) :=\n  by\n  simp_rw [inducing_coe.inducing_iff, inducing_iff_nhds, restrict_preimage, maps_to.coe_restrict, restrict_eq, ←\n    @filter.comap_comap _ _ _ _ coe f]\n  constructor\n  · intro H i x\n    rw [← H, ← inducing_coe.nhds_eq_comap]\n  · intro H x\n    obtain ⟨i, hi⟩ :=\n      opens.mem_supr.mp\n        (show f x ∈ supᵢ U by\n          rw [hU]\n          triv)\n    erw [← open_embedding.map_nhds_eq (h.1 _ (U i).2).open_embedding_subtype_coe ⟨x, hi⟩]\n    rw [(H i) ⟨x, hi⟩, filter.subtype_coe_map_comap, function.comp_apply, subtype.coe_mk, inf_eq_left,\n      filter.le_principal_iff]\n    exact filter.preimage_mem_comap ((U i).2.mem_nhds hi)\n#align inducing_iff_inducing_of_supr_eq_top inducing_iff_inducing_of_supr_eq_top\n\n",
 "embedding_iff_embedding_of_supr_eq_top":
 "theorem embedding_iff_embedding_of_supr_eq_top (h : continuous f) :\n    embedding f ↔ ∀ i, embedding ((U i).1.restrict_preimage f) :=\n  by\n  simp_rw [embedding_iff]\n  rw [forall_and]\n  apply and_congr\n  · apply inducing_iff_inducing_of_supr_eq_top <;> assumption\n  · apply Set.injective_iff_injective_of_unionᵢ_eq_univ\n    convert congr_arg coe hU\n    simp\n#align embedding_iff_embedding_of_supr_eq_top embedding_iff_embedding_of_supr_eq_top\n\n",
 "closed_embedding_iff_closed_embedding_of_supr_eq_top":
 "theorem closed_embedding_iff_closed_embedding_of_supr_eq_top (h : continuous f) :\n    closed_embedding f ↔ ∀ i, closed_embedding ((U i).1.restrict_preimage f) :=\n  by\n  simp_rw [closed_embedding_iff]\n  rw [forall_and]\n  apply and_congr\n  · apply embedding_iff_embedding_of_supr_eq_top <;> assumption\n  · simp_rw [Set.range_restrictPreimage]\n    apply is_closed_iff_coe_preimage_of_supr_eq_top hU\n#align closed_embedding_iff_closed_embedding_of_supr_eq_top closed_embedding_iff_closed_embedding_of_supr_eq_top\n\n"}