{"restrictPreimage_openEmbedding":
 "#print Set.restrictPreimage_openEmbedding /-\ntheorem Set.restrictPreimage_openEmbedding (s : Set β) (h : OpenEmbedding f) : OpenEmbedding (s.restrict_preimage f) :=\n  ⟨h.1.restrict_preimage s, (s.range_restrict_preimage f).symm ▸ continuous_subtype_val.is_open_preimage _ h.2⟩\n#align set.restrict_preimage_open_embedding Set.restrictPreimage_openEmbedding\n-/\n\n",
 "restrictPreimage_isClosedMap":
 "#print Set.restrictPreimage_isClosedMap /-\ntheorem Set.restrictPreimage_isClosedMap (s : Set β) (H : IsClosedMap f) : IsClosedMap (s.restrict_preimage f) :=\n  by\n  rintro t ⟨u, hu, e⟩\n  refine' ⟨⟨_, (H _ (IsOpen.isClosed_compl hu)).1, _⟩⟩\n  rw [← (congr_arg has_compl.compl e).trans (compl_compl t)]\n  simp only [Set.preimage_compl, compl_inj_iff]\n  ext ⟨x, hx⟩\n  suffices (∃ y, y ∉ u ∧ f y = x) ↔ ∃ y, f y ∈ s ∧ y ∉ u ∧ f y = x by simpa [Set.restrictPreimage, ← Subtype.coe_inj]\n  exact ⟨fun ⟨a, b, c⟩ => ⟨a, c.symm ▸ hx, b, c⟩, fun ⟨a, _, b, c⟩ => ⟨a, b, c⟩⟩\n#align set.restrict_preimage_is_closed_map Set.restrictPreimage_isClosedMap\n-/\n\n",
 "restrictPreimage_inducing":
 "#print Set.restrictPreimage_inducing /-\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem Set.restrictPreimage_inducing (s : Set β) (h : Inducing f) : Inducing (s.restrict_preimage f) :=\n  by\n  simp_rw [inducing_coe.inducing_iff, inducing_iff_nhds, restrict_preimage, maps_to.coe_restrict, restrict_eq, ←\n    @Filter.comap_comap _ _ _ _ coe f] at h⊢\n  intro a\n  rw [← h, ← inducing_coe.nhds_eq_comap]\n#align set.restrict_preimage_inducing Set.restrictPreimage_inducing\n-/\n\n",
 "restrictPreimage_embedding":
 "#print Set.restrictPreimage_embedding /-\ntheorem Set.restrictPreimage_embedding (s : Set β) (h : Embedding f) : Embedding (s.restrict_preimage f) :=\n  ⟨h.1.restrict_preimage s, h.2.restrict_preimage s⟩\n#align set.restrict_preimage_embedding Set.restrictPreimage_embedding\n-/\n\n",
 "restrictPreimage_closedEmbedding":
 "#print Set.restrictPreimage_closedEmbedding /-\ntheorem Set.restrictPreimage_closedEmbedding (s : Set β) (h : ClosedEmbedding f) :\n    ClosedEmbedding (s.restrict_preimage f) :=\n  ⟨h.1.restrict_preimage s, (s.range_restrict_preimage f).symm ▸ inducing_subtype_val.is_closed_preimage _ h.2⟩\n#align set.restrict_preimage_closed_embedding Set.restrictPreimage_closedEmbedding\n-/\n\n",
 "openEmbedding_iff_openEmbedding_of_supᵢ_eq_top":
 "#print openEmbedding_iff_openEmbedding_of_supᵢ_eq_top /-\ntheorem openEmbedding_iff_openEmbedding_of_supᵢ_eq_top (h : Continuous f) :\n    OpenEmbedding f ↔ ∀ i, OpenEmbedding ((U i).1.restrict_preimage f) :=\n  by\n  simp_rw [openEmbedding_iff]\n  rw [forall_and]\n  apply and_congr\n  · apply embedding_iff_embedding_of_supᵢ_eq_top <;> assumption\n  · simp_rw [Set.range_restrictPreimage]\n    apply isOpen_iff_coe_preimage_of_supᵢ_eq_top hU\n#align open_embedding_iff_open_embedding_of_supr_eq_top openEmbedding_iff_openEmbedding_of_supᵢ_eq_top\n-/\n\n",
 "isOpen_iff_inter_of_supᵢ_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isOpen_iff_inter_of_supᵢ_eq_top /-\ntheorem isOpen_iff_inter_of_supᵢ_eq_top (s : Set β) : IsOpen s ↔ ∀ i, IsOpen (s ∩ U i) :=\n  by\n  constructor\n  · exact fun H i => H.inter (U i).2\n  · intro H\n    have :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i : Set β) =\n        Set.univ :=\n      by\n      convert congr_arg coe hU\n      simp\n    rw [← s.inter_univ, ← this, Set.inter_unionᵢ]\n    exact isOpen_unionᵢ H\n#align is_open_iff_inter_of_supr_eq_top isOpen_iff_inter_of_supᵢ_eq_top\n-/\n\n",
 "isOpen_iff_coe_preimage_of_supᵢ_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print isOpen_iff_coe_preimage_of_supᵢ_eq_top /-\ntheorem isOpen_iff_coe_preimage_of_supᵢ_eq_top (s : Set β) : IsOpen s ↔ ∀ i, IsOpen («expr ⁻¹' » coe s : Set (U i)) :=\n  by\n  simp_rw [(U _).2.open_embedding_subtype_coe.open_iff_image_open, Set.image_preimage_eq_inter_range, Subtype.range_coe]\n  apply isOpen_iff_inter_of_supᵢ_eq_top\n  assumption\n#align is_open_iff_coe_preimage_of_supr_eq_top isOpen_iff_coe_preimage_of_supᵢ_eq_top\n-/\n\n",
 "isClosed_iff_coe_preimage_of_supᵢ_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print isClosed_iff_coe_preimage_of_supᵢ_eq_top /-\ntheorem isClosed_iff_coe_preimage_of_supᵢ_eq_top (s : Set β) :\n    IsClosed s ↔ ∀ i, IsClosed («expr ⁻¹' » coe s : Set (U i)) := by\n  simpa using isOpen_iff_coe_preimage_of_supᵢ_eq_top hU («expr ᶜ» s)\n#align is_closed_iff_coe_preimage_of_supr_eq_top isClosed_iff_coe_preimage_of_supᵢ_eq_top\n-/\n\n",
 "isClosedMap_iff_isClosedMap_of_supᵢ_eq_top":
 "#print isClosedMap_iff_isClosedMap_of_supᵢ_eq_top /-\ntheorem isClosedMap_iff_isClosedMap_of_supᵢ_eq_top : IsClosedMap f ↔ ∀ i, IsClosedMap ((U i).1.restrict_preimage f) :=\n  by\n  refine' ⟨fun h i => Set.restrictPreimage_isClosedMap _ h, _⟩\n  rintro H s hs\n  rw [isClosed_iff_coe_preimage_of_supᵢ_eq_top hU]\n  intro i\n  convert H i _ ⟨⟨_, hs.1, eq_compl_comm.mpr rfl⟩⟩\n  ext ⟨x, hx⟩\n  suffices (∃ y, y ∈ s ∧ f y = x) ↔ ∃ y, f y ∈ U i ∧ y ∈ s ∧ f y = x by simpa [Set.restrictPreimage, ← Subtype.coe_inj]\n  exact ⟨fun ⟨a, b, c⟩ => ⟨a, c.symm ▸ hx, b, c⟩, fun ⟨a, _, b, c⟩ => ⟨a, b, c⟩⟩\n#align is_closed_map_iff_is_closed_map_of_supr_eq_top isClosedMap_iff_isClosedMap_of_supᵢ_eq_top\n-/\n\n",
 "inducing_iff_inducing_of_supᵢ_eq_top":
 "#print inducing_iff_inducing_of_supᵢ_eq_top /-\ntheorem inducing_iff_inducing_of_supᵢ_eq_top (h : Continuous f) :\n    Inducing f ↔ ∀ i, Inducing ((U i).1.restrict_preimage f) :=\n  by\n  simp_rw [inducing_coe.inducing_iff, inducing_iff_nhds, restrict_preimage, maps_to.coe_restrict, restrict_eq, ←\n    @Filter.comap_comap _ _ _ _ coe f]\n  constructor\n  · intro H i x\n    rw [← H, ← inducing_coe.nhds_eq_comap]\n  · intro H x\n    obtain ⟨i, hi⟩ :=\n      opens.mem_supr.mp\n        (show f x ∈ supᵢ U by\n          rw [hU]\n          triv)\n    erw [← OpenEmbedding.map_nhds_eq (h.1 _ (U i).2).open_embedding_subtype_coe ⟨x, hi⟩]\n    rw [(H i) ⟨x, hi⟩, Filter.subtype_coe_map_comap, Function.comp_apply, Subtype.coe_mk, inf_eq_left,\n      Filter.le_principal_iff]\n    exact Filter.preimage_mem_comap ((U i).2.mem_nhds hi)\n#align inducing_iff_inducing_of_supr_eq_top inducing_iff_inducing_of_supᵢ_eq_top\n-/\n\n",
 "embedding_iff_embedding_of_supᵢ_eq_top":
 "#print embedding_iff_embedding_of_supᵢ_eq_top /-\ntheorem embedding_iff_embedding_of_supᵢ_eq_top (h : Continuous f) :\n    Embedding f ↔ ∀ i, Embedding ((U i).1.restrict_preimage f) :=\n  by\n  simp_rw [embedding_iff]\n  rw [forall_and]\n  apply and_congr\n  · apply inducing_iff_inducing_of_supᵢ_eq_top <;> assumption\n  · apply Set.injective_iff_injective_of_unionᵢ_eq_univ\n    convert congr_arg coe hU\n    simp\n#align embedding_iff_embedding_of_supr_eq_top embedding_iff_embedding_of_supᵢ_eq_top\n-/\n\n",
 "closedEmbedding_iff_closedEmbedding_of_supᵢ_eq_top":
 "#print closedEmbedding_iff_closedEmbedding_of_supᵢ_eq_top /-\ntheorem closedEmbedding_iff_closedEmbedding_of_supᵢ_eq_top (h : Continuous f) :\n    ClosedEmbedding f ↔ ∀ i, ClosedEmbedding ((U i).1.restrict_preimage f) :=\n  by\n  simp_rw [closedEmbedding_iff]\n  rw [forall_and]\n  apply and_congr\n  · apply embedding_iff_embedding_of_supᵢ_eq_top <;> assumption\n  · simp_rw [Set.range_restrictPreimage]\n    apply isClosed_iff_coe_preimage_of_supᵢ_eq_top hU\n#align closed_embedding_iff_closed_embedding_of_supr_eq_top closedEmbedding_iff_closedEmbedding_of_supᵢ_eq_top\n-/\n\n"}