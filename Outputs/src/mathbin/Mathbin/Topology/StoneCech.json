{"ultrafilter_pure_injective":
 "#print ultrafilter_pure_injective /-\ntheorem ultrafilter_pure_injective : function.injective (pure : α → Ultrafilter α) :=\n  by\n  intro x y h\n  have : {x} ∈ (pure x : Ultrafilter α) := singleton_mem_pure\n  rw [h] at this\n  exact (mem_singleton_iff.mp (mem_pure.mp this)).symm\n#align ultrafilter_pure_injective ultrafilter_pure_injective\n-/\n\n",
 "ultrafilter_isOpen_basic":
 "#print ultrafilter_isOpen_basic /-\n/-- The basic open sets for the topology on ultrafilters are open. -/\ntheorem ultrafilter_isOpen_basic (s : Set α) : IsOpen { u : Ultrafilter α | s ∈ u } :=\n  ultrafilterBasis_is_basis.is_open ⟨s, rfl⟩\n#align ultrafilter_is_open_basic ultrafilter_isOpen_basic\n-/\n\n",
 "ultrafilter_isClosed_basic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print ultrafilter_isClosed_basic /-\n/-- The basic open sets for the topology on ultrafilters are also closed. -/\ntheorem ultrafilter_isClosed_basic (s : Set α) : IsClosed { u : Ultrafilter α | s ∈ u } :=\n  by\n  rw [← isOpen_compl_iff]\n  convert ultrafilter_isOpen_basic («expr ᶜ» s)\n  ext u\n  exact ultrafilter.compl_mem_iff_not_mem.symm\n#align ultrafilter_is_closed_basic ultrafilter_isClosed_basic\n-/\n\n",
 "ultrafilter_extend_extends":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print ultrafilter_extend_extends /-\n/- Goal: Any function `α → γ` to a compact Hausdorff space `γ` has a\n  unique extension to a continuous function `ultrafilter α → γ`. We\n  already know it must be unique because `α → ultrafilter α` is a\n  dense embedding and `γ` is Hausdorff. For existence, we will invoke\n  `dense_embedding.continuous_extend`. -/\ntheorem ultrafilter_extend_extends (f : α → γ) : Ultrafilter.extend f ∘ pure = f :=\n  by\n  letI : TopologicalSpace α := «expr⊥»\n  haveI : DiscreteTopology α := ⟨rfl⟩\n  exact funext (dense_inducing_pure.extend_eq continuous_of_discreteTopology)\n#align ultrafilter_extend_extends ultrafilter_extend_extends\n-/\n\n",
 "ultrafilter_extend_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ultrafilter_extend_eq_iff /-\n/-- The value of `ultrafilter.extend f` on an ultrafilter `b` is the\n  unique limit of the ultrafilter `b.map f` in `γ`. -/\ntheorem ultrafilter_extend_eq_iff {f : α → γ} {b : Ultrafilter α} {c : γ} :\n    Ultrafilter.extend f b = c ↔ ↑(b.map f) ≤ (nhds) c :=\n  ⟨fun h =>\n    by\n    -- Write b as an ultrafilter limit of pure ultrafilters, and use\n    -- the facts that ultrafilter.extend is a continuous extension of f.\n    let b' : Ultrafilter (Ultrafilter α) := b.map pure\n    have t : ↑b' ≤ (nhds) b := ultrafilter_converges_iff.mpr (bind_pure _).symm\n    rw [← h]\n    have := (continuous_ultrafilter_extend f).tendsto b\n    refine' le_trans _ (le_trans (map_mono t) this)\n    change _ ≤ map (Ultrafilter.extend f ∘ pure) ↑b\n    rw [ultrafilter_extend_extends]\n    exact le_rfl, fun h =>\n    letI : TopologicalSpace α := «expr⊥»\n    dense_inducing_pure.extend_eq_of_tendsto (le_trans (map_mono (ultrafilter_comap_pure_nhds _)) h)⟩\n#align ultrafilter_extend_eq_iff ultrafilter_extend_eq_iff\n-/\n\n",
 "ultrafilter_converges_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ultrafilter_converges_iff /-\n/-- Every ultrafilter `u` on `ultrafilter α` converges to a unique\n  point of `ultrafilter α`, namely `mjoin u`. -/\ntheorem ultrafilter_converges_iff {u : Ultrafilter (Ultrafilter α)} {x : Ultrafilter α} : ↑u ≤ (nhds) x ↔ x = joinM u :=\n  by\n  rw [eq_comm, ← Ultrafilter.coe_le_coe]\n  change ↑u ≤ (nhds) x ↔ ∀ s ∈ x, { v : Ultrafilter α | s ∈ v } ∈ u\n  simp only [TopologicalSpace.nhds_generateFrom, le_infᵢ_iff, ultrafilterBasis, le_principal_iff, mem_set_of_eq]\n  constructor\n  · intro h a ha\n    exact h _ ⟨ha, a, rfl⟩\n  · rintro h a ⟨xi, a, rfl⟩\n    exact h _ xi\n#align ultrafilter_converges_iff ultrafilter_converges_iff\n-/\n\n",
 "ultrafilter_comap_pure_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ultrafilter_comap_pure_nhds /-\ntheorem ultrafilter_comap_pure_nhds (b : Ultrafilter α) : comap pure ((nhds) b) ≤ b :=\n  by\n  rw [TopologicalSpace.nhds_generateFrom]\n  simp only [comap_infi, comap_principal]\n  intro s hs\n  rw [← le_principal_iff]\n  refine' infᵢ_le_of_le { u | s ∈ u } _\n  refine' infᵢ_le_of_le ⟨hs, ⟨s, rfl⟩⟩ _\n  exact principal_mono.2 fun a => id\n#align ultrafilter_comap_pure_nhds ultrafilter_comap_pure_nhds\n-/\n\n",
 "ultrafilterBasis_is_basis":
 "#print ultrafilterBasis_is_basis /-\n/-\nCopyright (c) 2018 Reid Barton. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Reid Barton\n-/\n/- The set of ultrafilters on α carries a natural topology which makes\n  it the Stone-Čech compactification of α (viewed as a discrete space). -/\ntheorem ultrafilterBasis_is_basis : TopologicalSpace.IsTopologicalBasis (ultrafilterBasis α) :=\n  ⟨by\n    rintro _ ⟨a, rfl⟩ _ ⟨b, rfl⟩ u ⟨ua, ub⟩\n    refine' ⟨_, ⟨a ∩ b, rfl⟩, inter_mem ua ub, fun v hv => ⟨_, _⟩⟩ <;> apply mem_of_superset hv <;>\n      simp [inter_subset_right a b],\n    eq_univ_of_univ_subset <| subset_unionₛ_of_mem <| ⟨univ, eq_univ_of_forall fun u => univ_mem⟩, rfl⟩\n#align ultrafilter_basis_is_basis ultrafilterBasis_is_basis\n-/\n\n",
 "stoneCech_hom_ext":
 "#print stoneCech_hom_ext /-\ntheorem stoneCech_hom_ext {g₁ g₂ : StoneCech α → γ'} (h₁ : Continuous g₁) (h₂ : Continuous g₂)\n    (h : g₁ ∘ stoneCechUnit = g₂ ∘ stoneCechUnit) : g₁ = g₂ :=\n  by\n  apply Continuous.ext_on denseRange_stoneCechUnit h₁ h₂\n  rintro x ⟨x, rfl⟩\n  apply congr_fun h x\n#align stone_cech_hom_ext stoneCech_hom_ext\n-/\n\n",
 "stoneCechExtend_extends":
 "#print stoneCechExtend_extends /-\ntheorem stoneCechExtend_extends : stoneCechExtend hf ∘ stoneCechUnit = f :=\n  ultrafilter_extend_extends f\n#align stone_cech_extend_extends stoneCechExtend_extends\n-/\n\n",
 "induced_topology_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print induced_topology_pure /-\n/-- The map `pure : α → ultra_filter α` induces on `α` the discrete topology. -/\ntheorem induced_topology_pure :\n    TopologicalSpace.induced (pure : α → Ultrafilter α) Ultrafilter.topologicalSpace = «expr⊥» :=\n  by\n  apply eq_bot_of_singletons_open\n  intro x\n  use { u : Ultrafilter α | {x} ∈ u }, ultrafilter_isOpen_basic _\n  simp\n#align induced_topology_pure induced_topology_pure\n-/\n\n",
 "denseRange_stoneCechUnit":
 "#print denseRange_stoneCechUnit /-\n/- Now, we start with a (not necessarily discrete) topological space α\n  and we want to construct its Stone-Čech compactification. We can\n  build it as a quotient of `ultrafilter α` by the relation which\n  identifies two points if the extension of every continuous function\n  α → γ to a compact Hausdorff space sends the two points to the same\n  point of γ. -/\n/-- The image of stone_cech_unit is dense. (But stone_cech_unit need\n  not be an embedding, for example if α is not Hausdorff.) -/\ntheorem denseRange_stoneCechUnit : DenseRange (stoneCechUnit : α → StoneCech α) :=\n  denseRange_pure.quotient\n#align dense_range_stone_cech_unit denseRange_stoneCechUnit\n-/\n\n",
 "denseRange_pure":
 "#print denseRange_pure /-\n/-- The range of `pure : α → ultrafilter α` is dense in `ultrafilter α`. -/\ntheorem denseRange_pure : DenseRange (pure : α → Ultrafilter α) := fun x =>\n  mem_closure_iff_ultrafilter.mpr ⟨x.map pure, range_mem_map, ultrafilter_converges_iff.mpr (bind_pure x).symm⟩\n#align dense_range_pure denseRange_pure\n-/\n\n",
 "denseInducing_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print denseInducing_pure /-\n/-- `pure : α → ultrafilter α` defines a dense inducing of `α` in `ultrafilter α`. -/\ntheorem denseInducing_pure : @DenseInducing _ _ («expr⊥») _ (pure : α → Ultrafilter α) :=\n  letI : TopologicalSpace α := «expr⊥»\n  ⟨⟨induced_topology_pure.symm⟩, denseRange_pure⟩\n#align dense_inducing_pure denseInducing_pure\n-/\n\n",
 "denseEmbedding_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print denseEmbedding_pure /-\n-- The following refined version will never be used\n/-- `pure : α → ultrafilter α` defines a dense embedding of `α` in `ultrafilter α`. -/\ntheorem denseEmbedding_pure : @DenseEmbedding _ _ («expr⊥») _ (pure : α → Ultrafilter α) :=\n  letI : TopologicalSpace α := «expr⊥»\n  { denseInducing_pure with inj := ultrafilter_pure_injective }\n#align dense_embedding_pure denseEmbedding_pure\n-/\n\n",
 "convergent_eqv_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print convergent_eqv_pure /-\ntheorem convergent_eqv_pure {u : Ultrafilter α} {x : α} (ux : ↑u ≤ (nhds) x) : u ≈ pure x := fun γ tγ h₁ h₂ f hf =>\n  by\n  skip\n  trans f x; swap; symm\n  all_goals refine' ultrafilter_extend_eq_iff.mpr (le_trans (map_mono _) (hf.tendsto _))\n  · apply pure_le_nhds; · exact ux\n#align convergent_eqv_pure convergent_eqv_pure\n-/\n\n",
 "continuous_ultrafilter_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print continuous_ultrafilter_extend /-\ntheorem continuous_ultrafilter_extend (f : α → γ) : Continuous (Ultrafilter.extend f) :=\n  by\n  have : ∀ b : Ultrafilter α, ∃ c, Tendsto f (comap pure ((nhds) b)) ((nhds) c) := fun b =>\n    -- b.map f is an ultrafilter on γ, which is compact, so it converges to some c in γ.\n    let ⟨c, _, h⟩ := isCompact_univ.ultrafilter_le_nhds (b.map f) (by rw [le_principal_iff] <;> exact univ_mem)\n    ⟨c, le_trans (map_mono (ultrafilter_comap_pure_nhds _)) h⟩\n  letI : TopologicalSpace α := «expr⊥»\n  haveI : NormalSpace γ := normalOfCompactT2\n  exact dense_inducing_pure.continuous_extend this\n#align continuous_ultrafilter_extend continuous_ultrafilter_extend\n-/\n\n",
 "continuous_stoneCechUnit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n#print continuous_stoneCechUnit /-\ntheorem continuous_stoneCechUnit : Continuous (stoneCechUnit : α → StoneCech α) :=\n  continuous_iff_ultrafilter.mpr fun x g gx =>\n    by\n    have : ↑(g.map pure) ≤ (nhds) g := by rw [ultrafilter_converges_iff] <;> exact (bind_pure _).symm\n    have : (g.map stoneCechUnit : Filter (StoneCech α)) ≤ (nhds) («expr⟦ ⟧» g) :=\n      continuousAt_iff_ultrafilter.mp (continuous_quotient_mk'.tendsto g) _ this\n    rwa [show «expr⟦ ⟧» g = «expr⟦ ⟧» (pure x) from quotient.sound <| convergent_eqv_pure gx] at this\n#align continuous_stone_cech_unit continuous_stoneCechUnit\n-/\n\n",
 "continuous_stoneCechExtend":
 "#print continuous_stoneCechExtend /-\ntheorem continuous_stoneCechExtend : Continuous (stoneCechExtend hf) :=\n  continuous_quot_lift _ (continuous_ultrafilter_extend f)\n#align continuous_stone_cech_extend continuous_stoneCechExtend\n-/\n\n"}