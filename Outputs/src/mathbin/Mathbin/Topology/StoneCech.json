{"ultrafilter_pure_injective":
 "theorem ultrafilter_pure_injective : function.injective (pure : α → ultrafilter α) :=\n  by\n  intro x y h\n  have : {x} ∈ (pure x : ultrafilter α) := singleton_mem_pure\n  rw [h] at this\n  exact (mem_singleton_iff.mp (mem_pure.mp this)).symm\n#align ultrafilter_pure_injective ultrafilter_pure_injective\n\n",
 "ultrafilter_is_open_basic":
 "/-- The basic open sets for the topology on ultrafilters are open. -/\ntheorem ultrafilter_is_open_basic (s : set α) : is_open { u : ultrafilter α | s ∈ u } :=\n  ultrafilter_basis_is_basis.is_open ⟨s, rfl⟩\n#align ultrafilter_is_open_basic ultrafilter_is_open_basic\n\n",
 "ultrafilter_is_closed_basic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- The basic open sets for the topology on ultrafilters are also closed. -/\ntheorem ultrafilter_is_closed_basic (s : set α) : is_closed { u : ultrafilter α | s ∈ u } :=\n  by\n  rw [← is_open_compl_iff]\n  convert ultrafilter_is_open_basic («expr ᶜ» s)\n  ext u\n  exact ultrafilter.compl_mem_iff_not_mem.symm\n#align ultrafilter_is_closed_basic ultrafilter_is_closed_basic\n\n",
 "ultrafilter_extend_extends":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- Goal: Any function `α → γ` to a compact Hausdorff space `γ` has a\n  unique extension to a continuous function `ultrafilter α → γ`. We\n  already know it must be unique because `α → ultrafilter α` is a\n  dense embedding and `γ` is Hausdorff. For existence, we will invoke\n  `dense_embedding.continuous_extend`. -/\ntheorem ultrafilter_extend_extends (f : α → γ) : ultrafilter.extend f ∘ pure = f :=\n  by\n  letI : topological_space α := «expr⊥»\n  haveI : discrete_topology α := ⟨rfl⟩\n  exact funext (dense_inducing_pure.extend_eq continuous_of_discrete_topology)\n#align ultrafilter_extend_extends ultrafilter_extend_extends\n\n",
 "ultrafilter_extend_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The value of `ultrafilter.extend f` on an ultrafilter `b` is the\n  unique limit of the ultrafilter `b.map f` in `γ`. -/\ntheorem ultrafilter_extend_eq_iff {f : α → γ} {b : ultrafilter α} {c : γ} :\n    ultrafilter.extend f b = c ↔ ↑(b.map f) ≤ (nhds) c :=\n  ⟨fun h =>\n    by\n    -- Write b as an ultrafilter limit of pure ultrafilters, and use\n    -- the facts that ultrafilter.extend is a continuous extension of f.\n    let b' : ultrafilter (ultrafilter α) := b.map pure\n    have t : ↑b' ≤ (nhds) b := ultrafilter_converges_iff.mpr (bind_pure _).symm\n    rw [← h]\n    have := (continuous_ultrafilter_extend f).tendsto b\n    refine' le_trans _ (le_trans (map_mono t) this)\n    change _ ≤ map (ultrafilter.extend f ∘ pure) ↑b\n    rw [ultrafilter_extend_extends]\n    exact le_rfl, fun h =>\n    letI : topological_space α := «expr⊥»\n    dense_inducing_pure.extend_eq_of_tendsto (le_trans (map_mono (ultrafilter_comap_pure_nhds _)) h)⟩\n#align ultrafilter_extend_eq_iff ultrafilter_extend_eq_iff\n\n",
 "ultrafilter_converges_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Every ultrafilter `u` on `ultrafilter α` converges to a unique\n  point of `ultrafilter α`, namely `mjoin u`. -/\ntheorem ultrafilter_converges_iff {u : ultrafilter (ultrafilter α)} {x : ultrafilter α} : ↑u ≤ (nhds) x ↔ x = joinM u :=\n  by\n  rw [eq_comm, ← ultrafilter.coe_le_coe]\n  change ↑u ≤ (nhds) x ↔ ∀ s ∈ x, { v : ultrafilter α | s ∈ v } ∈ u\n  simp only [topological_space.nhds_generate_from, le_infᵢ_iff, ultrafilter_basis, le_principal_iff, mem_set_of_eq]\n  constructor\n  · intro h a ha\n    exact h _ ⟨ha, a, rfl⟩\n  · rintro h a ⟨xi, a, rfl⟩\n    exact h _ xi\n#align ultrafilter_converges_iff ultrafilter_converges_iff\n\n",
 "ultrafilter_comap_pure_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ultrafilter_comap_pure_nhds (b : ultrafilter α) : comap pure ((nhds) b) ≤ b :=\n  by\n  rw [topological_space.nhds_generate_from]\n  simp only [comap_infi, comap_principal]\n  intro s hs\n  rw [← le_principal_iff]\n  refine' infᵢ_le_of_le { u | s ∈ u } _\n  refine' infᵢ_le_of_le ⟨hs, ⟨s, rfl⟩⟩ _\n  exact principal_mono.2 fun a => id\n#align ultrafilter_comap_pure_nhds ultrafilter_comap_pure_nhds\n\n",
 "ultrafilter_basis_is_basis":
 "/-\nCopyright (c) 2018 Reid Barton. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Reid Barton\n-/\n/- The set of ultrafilters on α carries a natural topology which makes\n  it the Stone-Čech compactification of α (viewed as a discrete space). -/\ntheorem ultrafilter_basis_is_basis : topological_space.is_topological_basis (ultrafilter_basis α) :=\n  ⟨by\n    rintro _ ⟨a, rfl⟩ _ ⟨b, rfl⟩ u ⟨ua, ub⟩\n    refine' ⟨_, ⟨a ∩ b, rfl⟩, inter_mem ua ub, fun v hv => ⟨_, _⟩⟩ <;> apply mem_of_superset hv <;>\n      simp [inter_subset_right a b],\n    eq_univ_of_univ_subset <| subset_sUnion_of_mem <| ⟨univ, eq_univ_of_forall fun u => univ_mem⟩, rfl⟩\n#align ultrafilter_basis_is_basis ultrafilter_basis_is_basis\n\n",
 "stone_cech_hom_ext":
 "theorem stone_cech_hom_ext {g₁ g₂ : stone_cech α → γ'} (h₁ : continuous g₁) (h₂ : continuous g₂)\n    (h : g₁ ∘ stone_cech_unit = g₂ ∘ stone_cech_unit) : g₁ = g₂ :=\n  by\n  apply continuous.ext_on dense_range_stone_cech_unit h₁ h₂\n  rintro x ⟨x, rfl⟩\n  apply congr_fun h x\n#align stone_cech_hom_ext stone_cech_hom_ext\n\n",
 "stone_cech_extend_extends":
 "theorem stone_cech_extend_extends : stone_cech_extend hf ∘ stone_cech_unit = f :=\n  ultrafilter_extend_extends f\n#align stone_cech_extend_extends stone_cech_extend_extends\n\n",
 "induced_topology_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- The map `pure : α → ultra_filter α` induces on `α` the discrete topology. -/\ntheorem induced_topology_pure :\n    topological_space.induced (pure : α → ultrafilter α) ultrafilter.topological_space = «expr⊥» :=\n  by\n  apply eq_bot_of_singletons_open\n  intro x\n  use { u : ultrafilter α | {x} ∈ u }, ultrafilter_is_open_basic _\n  simp\n#align induced_topology_pure induced_topology_pure\n\n",
 "dense_range_stone_cech_unit":
 "/- Now, we start with a (not necessarily discrete) topological space α\n  and we want to construct its Stone-Čech compactification. We can\n  build it as a quotient of `ultrafilter α` by the relation which\n  identifies two points if the extension of every continuous function\n  α → γ to a compact Hausdorff space sends the two points to the same\n  point of γ. -/\n/-- The image of stone_cech_unit is dense. (But stone_cech_unit need\n  not be an embedding, for example if α is not Hausdorff.) -/\ntheorem dense_range_stone_cech_unit : dense_range (stone_cech_unit : α → stone_cech α) :=\n  dense_range_pure.quotient\n#align dense_range_stone_cech_unit dense_range_stone_cech_unit\n\n",
 "dense_range_pure":
 "/-- The range of `pure : α → ultrafilter α` is dense in `ultrafilter α`. -/\ntheorem dense_range_pure : dense_range (pure : α → ultrafilter α) := fun x =>\n  mem_closure_iff_ultrafilter.mpr ⟨x.map pure, range_mem_map, ultrafilter_converges_iff.mpr (bind_pure x).symm⟩\n#align dense_range_pure dense_range_pure\n\n",
 "dense_inducing_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- `pure : α → ultrafilter α` defines a dense inducing of `α` in `ultrafilter α`. -/\ntheorem dense_inducing_pure : @dense_inducing _ _ («expr⊥») _ (pure : α → ultrafilter α) :=\n  letI : topological_space α := «expr⊥»\n  ⟨⟨induced_topology_pure.symm⟩, dense_range_pure⟩\n#align dense_inducing_pure dense_inducing_pure\n\n",
 "dense_embedding_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n-- The following refined version will never be used\n/-- `pure : α → ultrafilter α` defines a dense embedding of `α` in `ultrafilter α`. -/\ntheorem dense_embedding_pure : @dense_embedding _ _ («expr⊥») _ (pure : α → ultrafilter α) :=\n  letI : topological_space α := «expr⊥»\n  { dense_inducing_pure with inj := ultrafilter_pure_injective }\n#align dense_embedding_pure dense_embedding_pure\n\n",
 "convergent_eqv_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem convergent_eqv_pure {u : ultrafilter α} {x : α} (ux : ↑u ≤ (nhds) x) : u ≈ pure x := fun γ tγ h₁ h₂ f hf =>\n  by\n  skip\n  trans f x; swap; symm\n  all_goals refine' ultrafilter_extend_eq_iff.mpr (le_trans (map_mono _) (hf.tendsto _))\n  · apply pure_le_nhds; · exact ux\n#align convergent_eqv_pure convergent_eqv_pure\n\n",
 "continuous_ultrafilter_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem continuous_ultrafilter_extend (f : α → γ) : continuous (ultrafilter.extend f) :=\n  by\n  have : ∀ b : ultrafilter α, ∃ c, tendsto f (comap pure ((nhds) b)) ((nhds) c) := fun b =>\n    -- b.map f is an ultrafilter on γ, which is compact, so it converges to some c in γ.\n    let ⟨c, _, h⟩ := is_compact_univ.ultrafilter_le_nhds (b.map f) (by rw [le_principal_iff] <;> exact univ_mem)\n    ⟨c, le_trans (map_mono (ultrafilter_comap_pure_nhds _)) h⟩\n  letI : topological_space α := «expr⊥»\n  haveI : normal_space γ := normal_of_compact_t2\n  exact dense_inducing_pure.continuous_extend this\n#align continuous_ultrafilter_extend continuous_ultrafilter_extend\n\n",
 "continuous_stone_cech_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem continuous_stone_cech_unit : continuous (stone_cech_unit : α → stone_cech α) :=\n  continuous_iff_ultrafilter.mpr fun x g gx =>\n    by\n    have : ↑(g.map pure) ≤ (nhds) g := by rw [ultrafilter_converges_iff] <;> exact (bind_pure _).symm\n    have : (g.map stone_cech_unit : filter (stone_cech α)) ≤ (nhds) («expr⟦ ⟧» g) :=\n      continuous_at_iff_ultrafilter.mp (continuous_quotient_mk.tendsto g) _ this\n    rwa [show «expr⟦ ⟧» g = «expr⟦ ⟧» (pure x) from quotient.sound <| convergent_eqv_pure gx] at this\n#align continuous_stone_cech_unit continuous_stone_cech_unit\n\n",
 "continuous_stone_cech_extend":
 "theorem continuous_stone_cech_extend : continuous (stone_cech_extend hf) :=\n  continuous_quot_lift _ (continuous_ultrafilter_extend f)\n#align continuous_stone_cech_extend continuous_stone_cech_extend\n\n"}