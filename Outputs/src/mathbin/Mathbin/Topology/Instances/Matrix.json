{"transpose_tsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n#print Matrix.transpose_tsum /-\ntheorem Matrix.transpose_tsum [T2Space R] {f : X → Matrix m n R} :\n    matrix.transpose\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (f x)) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (matrix.transpose (f x)) :=\n  by\n  by_cases hf : Summable f\n  · exact hf.has_sum.matrix_transpose.tsum_eq.symm\n  · have hft := summable_matrix_transpose.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hft, transpose_zero]\n#align matrix.transpose_tsum Matrix.transpose_tsum\n-/\n\n",
 "summable_matrix_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n#print summable_matrix_transpose /-\n@[simp]\ntheorem summable_matrix_transpose {f : X → Matrix m n R} : (Summable fun x => matrix.transpose (f x)) ↔ Summable f :=\n  (Summable.map_iff_of_equiv (Matrix.transposeAddEquiv m n R) (@continuous_id (Matrix m n R) _).matrix_transpose\n      continuous_id.matrix_transpose :\n    _)\n#align summable_matrix_transpose summable_matrix_transpose\n-/\n\n",
 "summable_matrix_diagonal":
 "#print summable_matrix_diagonal /-\n@[simp]\ntheorem summable_matrix_diagonal [DecidableEq n] {f : X → n → R} : (Summable fun x => diagonal (f x)) ↔ Summable f :=\n  (Summable.map_iff_of_leftInverse (@Matrix.diagonalAddMonoidHom n R _ _) (Matrix.diagAddMonoidHom n R)\n      (Continuous.matrix_diagonal continuous_id) continuous_matrix_diag fun A => diag_diagonal A :\n    _)\n#align summable_matrix_diagonal summable_matrix_diagonal\n-/\n\n",
 "summable_matrix_conjTranspose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n#print summable_matrix_conjTranspose /-\n@[simp]\ntheorem summable_matrix_conjTranspose [StarAddMonoid R] [ContinuousStar R] {f : X → Matrix m n R} :\n    (Summable fun x => matrix.conj_transpose (f x)) ↔ Summable f :=\n  (Summable.map_iff_of_equiv (Matrix.conjTransposeAddEquiv m n R)\n      (@continuous_id (Matrix m n R) _).matrix_conj_transpose continuous_id.matrix_conj_transpose :\n    _)\n#align summable_matrix_conj_transpose summable_matrix_conjTranspose\n-/\n\n",
 "summable_matrix_blockDiagonal'":
 "#print summable_matrix_blockDiagonal' /-\ntheorem summable_matrix_blockDiagonal' [DecidableEq l] {f : X → ∀ i, Matrix (m' i) (n' i) R} :\n    (Summable fun x => blockDiagonal' (f x)) ↔ Summable f :=\n  (Summable.map_iff_of_leftInverse (Matrix.blockDiagonal'AddMonoidHom m' n' R) (Matrix.blockDiag'AddMonoidHom m' n' R)\n      (Continuous.matrix_blockDiagonal' continuous_id) (Continuous.matrix_blockDiag' continuous_id) fun A =>\n      blockDiag'_blockDiagonal' A :\n    _)\n#align summable_matrix_block_diagonal' summable_matrix_blockDiagonal'\n-/\n\n",
 "summable_matrix_blockDiagonal":
 "#print summable_matrix_blockDiagonal /-\ntheorem summable_matrix_blockDiagonal [DecidableEq p] {f : X → p → Matrix m n R} :\n    (Summable fun x => blockDiagonal (f x)) ↔ Summable f :=\n  (Summable.map_iff_of_leftInverse (Matrix.blockDiagonalAddMonoidHom m n p R) (Matrix.blockDiagAddMonoidHom m n p R)\n      (Continuous.matrix_blockDiagonal continuous_id) (Continuous.matrix_blockDiag continuous_id) fun A =>\n      blockDiag_blockDiagonal A :\n    _)\n#align summable_matrix_block_diagonal summable_matrix_blockDiagonal\n-/\n\n",
 "matrix_vecMulVec":
 "#print Continuous.matrix_vecMulVec /-\n@[continuity]\ntheorem Continuous.matrix_vecMulVec [Mul R] [ContinuousMul R] {A : X → m → R} {B : X → n → R} (hA : Continuous A)\n    (hB : Continuous B) : Continuous fun x => vecMulVec (A x) (B x) :=\n  continuous_matrix fun i j => ((continuous_apply _).comp hA).mul ((continuous_apply _).comp hB)\n#align continuous.matrix_vec_mul_vec Continuous.matrix_vecMulVec\n-/\n\n",
 "matrix_vecMul":
 "#print Continuous.matrix_vecMul /-\n@[continuity]\ntheorem Continuous.matrix_vecMul [NonUnitalNonAssocSemiring R] [ContinuousAdd R] [ContinuousMul R] [Fintype m]\n    {A : X → m → R} {B : X → Matrix m n R} (hA : Continuous A) (hB : Continuous B) :\n    Continuous fun x => vecMul (A x) (B x) :=\n  continuous_pi fun i => hA.matrix_dot_product <| continuous_pi fun j => hB.matrix_elem _ _\n#align continuous.matrix_vec_mul Continuous.matrix_vecMul\n-/\n\n",
 "matrix_updateRow":
 "#print Continuous.matrix_updateRow /-\n@[continuity]\ntheorem Continuous.matrix_updateRow [DecidableEq m] (i : m) {A : X → Matrix m n R} {B : X → n → R} (hA : Continuous A)\n    (hB : Continuous B) : Continuous fun x => (A x).update_row i (B x) :=\n  hA.update i hB\n#align continuous.matrix_update_row Continuous.matrix_updateRow\n-/\n\n",
 "matrix_updateColumn":
 "#print Continuous.matrix_updateColumn /-\n@[continuity]\ntheorem Continuous.matrix_updateColumn [DecidableEq n] (i : n) {A : X → Matrix m n R} {B : X → m → R}\n    (hA : Continuous A) (hB : Continuous B) : Continuous fun x => (A x).update_column i (B x) :=\n  continuous_matrix fun j k =>\n    (continuous_apply k).comp <| ((continuous_apply _).comp hA).update i ((continuous_apply _).comp hB)\n#align continuous.matrix_update_column Continuous.matrix_updateColumn\n-/\n\n",
 "matrix_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n#print Summable.matrix_transpose /-\ntheorem Summable.matrix_transpose {f : X → Matrix m n R} (hf : Summable f) : Summable fun x => matrix.transpose (f x) :=\n  hf.has_sum.matrix_transpose.summable\n#align summable.matrix_transpose Summable.matrix_transpose\n-/\n\n",
 "matrix_trace":
 "#print Continuous.matrix_trace /-\n@[continuity]\ntheorem Continuous.matrix_trace [Fintype n] [AddCommMonoid R] [ContinuousAdd R] {A : X → Matrix n n R}\n    (hA : Continuous A) : Continuous fun x => trace (A x) :=\n  continuous_finset_sum _ fun i hi => hA.matrix_elem _ _\n#align continuous.matrix_trace Continuous.matrix_trace\n-/\n\n",
 "matrix_submatrix":
 "#print Continuous.matrix_submatrix /-\n@[continuity]\ntheorem Continuous.matrix_submatrix {A : X → Matrix l n R} (hA : Continuous A) (e₁ : m → l) (e₂ : p → n) :\n    Continuous fun x => (A x).submatrix e₁ e₂ :=\n  continuous_matrix fun i j => hA.matrix_elem _ _\n#align continuous.matrix_submatrix Continuous.matrix_submatrix\n-/\n\n",
 "matrix_row":
 "#print Continuous.matrix_row /-\n@[continuity]\ntheorem Continuous.matrix_row {A : X → n → R} (hA : Continuous A) : Continuous fun x => row (A x) :=\n  continuous_matrix fun i j => (continuous_apply _).comp hA\n#align continuous.matrix_row Continuous.matrix_row\n-/\n\n",
 "matrix_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n#print Continuous.matrix_reindex /-\n@[continuity]\ntheorem Continuous.matrix_reindex {A : X → Matrix l n R} (hA : Continuous A) (e₁ : «expr ≃ » l m) (e₂ : «expr ≃ » n p) :\n    Continuous fun x => reindex e₁ e₂ (A x) :=\n  hA.matrix_submatrix _ _\n#align continuous.matrix_reindex Continuous.matrix_reindex\n-/\n\n",
 "matrix_mulVec":
 "#print Continuous.matrix_mulVec /-\n@[continuity]\ntheorem Continuous.matrix_mulVec [NonUnitalNonAssocSemiring R] [ContinuousAdd R] [ContinuousMul R] [Fintype n]\n    {A : X → Matrix m n R} {B : X → n → R} (hA : Continuous A) (hB : Continuous B) :\n    Continuous fun x => (A x).mul_vec (B x) :=\n  continuous_pi fun i => ((continuous_apply i).comp hA).matrix_dot_product hB\n#align continuous.matrix_mul_vec Continuous.matrix_mulVec\n-/\n\n",
 "matrix_mul":
 "#print Continuous.matrix_mul /-\n/-- For square matrices the usual `continuous_mul` can be used. -/\n@[continuity]\ntheorem Continuous.matrix_mul [Fintype n] [Mul R] [AddCommMonoid R] [ContinuousAdd R] [ContinuousMul R]\n    {A : X → Matrix m n R} {B : X → Matrix n p R} (hA : Continuous A) (hB : Continuous B) :\n    Continuous fun x => (A x).mul (B x) :=\n  continuous_matrix fun i j => continuous_finset_sum _ fun k _ => (hA.matrix_elem _ _).mul (hB.matrix_elem _ _)\n#align continuous.matrix_mul Continuous.matrix_mul\n-/\n\n",
 "matrix_map":
 "#print Continuous.matrix_map /-\n@[continuity]\ntheorem Continuous.matrix_map [TopologicalSpace S] {A : X → Matrix m n S} {f : S → R} (hA : Continuous A)\n    (hf : Continuous f) : Continuous fun x => (A x).map f :=\n  continuous_matrix fun i j => hf.comp <| hA.matrix_elem _ _\n#align continuous.matrix_map Continuous.matrix_map\n-/\n\n",
 "matrix_fromBlocks":
 "#print Continuous.matrix_fromBlocks /-\n-- lemmas about functions in `data/matrix/block.lean`\n@[continuity]\ntheorem Continuous.matrix_fromBlocks {A : X → Matrix n l R} {B : X → Matrix n m R} {C : X → Matrix p l R}\n    {D : X → Matrix p m R} (hA : Continuous A) (hB : Continuous B) (hC : Continuous C) (hD : Continuous D) :\n    Continuous fun x => Matrix.fromBlocks (A x) (B x) (C x) (D x) :=\n  continuous_matrix fun i j => by cases i <;> cases j <;> refine' Continuous.matrix_elem _ i j <;> assumption\n#align continuous.matrix_from_blocks Continuous.matrix_fromBlocks\n-/\n\n",
 "matrix_elem":
 "#print Continuous.matrix_elem /-\ntheorem Continuous.matrix_elem {A : X → Matrix m n R} (hA : Continuous A) (i : m) (j : n) :\n    Continuous fun x => A x i j :=\n  (continuous_apply_apply i j).comp hA\n#align continuous.matrix_elem Continuous.matrix_elem\n-/\n\n",
 "matrix_dotProduct":
 "#print Continuous.matrix_dotProduct /-\n@[continuity]\ntheorem Continuous.matrix_dotProduct [Fintype n] [Mul R] [AddCommMonoid R] [ContinuousAdd R] [ContinuousMul R]\n    {A : X → n → R} {B : X → n → R} (hA : Continuous A) (hB : Continuous B) :\n    Continuous fun x => dotProduct (A x) (B x) :=\n  continuous_finset_sum _ fun i _ => ((continuous_apply i).comp hA).mul ((continuous_apply i).comp hB)\n#align continuous.matrix_dot_product Continuous.matrix_dotProduct\n-/\n\n",
 "matrix_diagonal":
 "#print Summable.matrix_diagonal /-\ntheorem Summable.matrix_diagonal [DecidableEq n] {f : X → n → R} (hf : Summable f) : Summable fun x => diagonal (f x) :=\n  hf.has_sum.matrix_diagonal.summable\n#align summable.matrix_diagonal Summable.matrix_diagonal\n-/\n\n",
 "matrix_diag":
 "#print Summable.matrix_diag /-\ntheorem Summable.matrix_diag {f : X → Matrix n n R} (hf : Summable f) : Summable fun x => diag (f x) :=\n  hf.has_sum.matrix_diag.summable\n#align summable.matrix_diag Summable.matrix_diag\n-/\n\n",
 "matrix_det":
 "#print Continuous.matrix_det /-\n@[continuity]\ntheorem Continuous.matrix_det [Fintype n] [DecidableEq n] [CommRing R] [TopologicalRing R] {A : X → Matrix n n R}\n    (hA : Continuous A) : Continuous fun x => (A x).det :=\n  by\n  simp_rw [Matrix.det_apply]\n  refine' continuous_finset_sum _ fun l _ => Continuous.const_smul _ _\n  refine' continuous_finset_prod _ fun l _ => hA.matrix_elem _ _\n#align continuous.matrix_det Continuous.matrix_det\n-/\n\n",
 "matrix_cramer":
 "#print Continuous.matrix_cramer /-\n@[continuity]\ntheorem Continuous.matrix_cramer [Fintype n] [DecidableEq n] [CommRing R] [TopologicalRing R] {A : X → Matrix n n R}\n    {B : X → n → R} (hA : Continuous A) (hB : Continuous B) : Continuous fun x => (A x).cramer (B x) :=\n  continuous_pi fun i => (hA.matrix_update_column _ hB).matrix_det\n#align continuous.matrix_cramer Continuous.matrix_cramer\n-/\n\n",
 "matrix_conjTranspose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n#print Summable.matrix_conjTranspose /-\ntheorem Summable.matrix_conjTranspose [StarAddMonoid R] [ContinuousStar R] {f : X → Matrix m n R} (hf : Summable f) :\n    Summable fun x => matrix.conj_transpose (f x) :=\n  hf.has_sum.matrix_conj_transpose.summable\n#align summable.matrix_conj_transpose Summable.matrix_conjTranspose\n-/\n\n",
 "matrix_col":
 "#print Continuous.matrix_col /-\n@[continuity]\ntheorem Continuous.matrix_col {A : X → n → R} (hA : Continuous A) : Continuous fun x => col (A x) :=\n  continuous_matrix fun i j => (continuous_apply _).comp hA\n#align continuous.matrix_col Continuous.matrix_col\n-/\n\n",
 "matrix_blockDiagonal'":
 "#print Summable.matrix_blockDiagonal' /-\ntheorem Summable.matrix_blockDiagonal' [DecidableEq l] {f : X → ∀ i, Matrix (m' i) (n' i) R} (hf : Summable f) :\n    Summable fun x => blockDiagonal' (f x) :=\n  hf.has_sum.matrix_block_diagonal'.summable\n#align summable.matrix_block_diagonal' Summable.matrix_blockDiagonal'\n-/\n\n",
 "matrix_blockDiagonal":
 "#print Summable.matrix_blockDiagonal /-\ntheorem Summable.matrix_blockDiagonal [DecidableEq p] {f : X → p → Matrix m n R} (hf : Summable f) :\n    Summable fun x => blockDiagonal (f x) :=\n  hf.has_sum.matrix_block_diagonal.summable\n#align summable.matrix_block_diagonal Summable.matrix_blockDiagonal\n-/\n\n",
 "matrix_blockDiag'":
 "#print Summable.matrix_blockDiag' /-\ntheorem Summable.matrix_blockDiag' {f : X → Matrix (Σi, m' i) (Σi, n' i) R} (hf : Summable f) :\n    Summable fun x => blockDiag' (f x) :=\n  hf.has_sum.matrix_block_diag'.summable\n#align summable.matrix_block_diag' Summable.matrix_blockDiag'\n-/\n\n",
 "matrix_blockDiag":
 "#print Summable.matrix_blockDiag /-\ntheorem Summable.matrix_blockDiag {f : X → Matrix (m × p) (n × p) R} (hf : Summable f) :\n    Summable fun x => blockDiag (f x) :=\n  hf.has_sum.matrix_block_diag.summable\n#align summable.matrix_block_diag Summable.matrix_blockDiag\n-/\n\n",
 "matrix_adjugate":
 "#print Continuous.matrix_adjugate /-\n@[continuity]\ntheorem Continuous.matrix_adjugate [Fintype n] [DecidableEq n] [CommRing R] [TopologicalRing R] {A : X → Matrix n n R}\n    (hA : Continuous A) : Continuous fun x => (A x).adjugate :=\n  continuous_matrix fun j k => (hA.matrix_transpose.matrix_update_column k continuous_const).matrix_det\n#align continuous.matrix_adjugate Continuous.matrix_adjugate\n-/\n\n",
 "diagonal_tsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n#print Matrix.diagonal_tsum /-\ntheorem Matrix.diagonal_tsum [DecidableEq n] [T2Space R] {f : X → n → R} :\n    diagonal («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (f x)) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (diagonal (f x)) :=\n  by\n  by_cases hf : Summable f\n  · exact hf.has_sum.matrix_diagonal.tsum_eq.symm\n  · have hft := summable_matrix_diagonal.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hft]\n    exact diagonal_zero\n#align matrix.diagonal_tsum Matrix.diagonal_tsum\n-/\n\n",
 "continuous_matrix_diag":
 "#print continuous_matrix_diag /-\n-- note this doesn't elaborate well from the above\ntheorem continuous_matrix_diag : Continuous (Matrix.diag : Matrix n n R → n → R) :=\n  show Continuous fun x : Matrix n n R => Matrix.diag x from continuous_id.matrix_diag\n#align continuous_matrix_diag continuous_matrix_diag\n-/\n\n",
 "continuous_matrix":
 "#print continuous_matrix /-\n/-\nCopyright (c) 2021 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash, Eric Wieser\n-/\n/-- To show a function into matrices is continuous it suffices to show the coefficients of the\nresulting matrix are continuous -/\n@[continuity]\ntheorem continuous_matrix [TopologicalSpace α] {f : α → Matrix m n R} (h : ∀ i j, Continuous fun a => f a i j) :\n    Continuous f :=\n  continuous_pi fun _ => continuous_pi fun j => h _ _\n#align continuous_matrix continuous_matrix\n-/\n\n",
 "continuousAt_matrix_inv":
 "#print continuousAt_matrix_inv /-\n/-- When `ring.inverse` is continuous at the determinant (such as in a `normed_ring`, or a\n`topological_field`), so is `matrix.has_inv`. -/\ntheorem continuousAt_matrix_inv [Fintype n] [DecidableEq n] [CommRing R] [TopologicalRing R] (A : Matrix n n R)\n    (h : ContinuousAt Ring.inverse A.det) : ContinuousAt has_inv.inv A :=\n  (h.comp continuous_id.matrix_det.continuous_at).smul continuous_id.matrix_adjugate.continuous_at\n#align continuous_at_matrix_inv continuousAt_matrix_inv\n-/\n\n",
 "conjTranspose_tsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n#print Matrix.conjTranspose_tsum /-\ntheorem Matrix.conjTranspose_tsum [StarAddMonoid R] [ContinuousStar R] [T2Space R] {f : X → Matrix m n R} :\n    matrix.conj_transpose\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (f x)) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (matrix.conj_transpose (f x)) :=\n  by\n  by_cases hf : Summable f\n  · exact hf.has_sum.matrix_conj_transpose.tsum_eq.symm\n  · have hft := summable_matrix_conj_transpose.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hft, conj_transpose_zero]\n#align matrix.conj_transpose_tsum Matrix.conjTranspose_tsum\n-/\n\n",
 "blockDiagonal_tsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n#print Matrix.blockDiagonal_tsum /-\ntheorem Matrix.blockDiagonal_tsum [DecidableEq p] [T2Space R] {f : X → p → Matrix m n R} :\n    blockDiagonal\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (f x)) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (blockDiagonal (f x)) :=\n  by\n  by_cases hf : Summable f\n  · exact hf.has_sum.matrix_block_diagonal.tsum_eq.symm\n  · have hft := summable_matrix_block_diagonal.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hft]\n    exact block_diagonal_zero\n#align matrix.block_diagonal_tsum Matrix.blockDiagonal_tsum\n-/\n\n",
 "blockDiagonal'_tsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n#print Matrix.blockDiagonal'_tsum /-\ntheorem Matrix.blockDiagonal'_tsum [DecidableEq l] [T2Space R] {f : X → ∀ i, Matrix (m' i) (n' i) R} :\n    blockDiagonal'\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (f x)) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (blockDiagonal' (f x)) :=\n  by\n  by_cases hf : Summable f\n  · exact hf.has_sum.matrix_block_diagonal'.tsum_eq.symm\n  · have hft := summable_matrix_block_diagonal'.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hft]\n    exact block_diagonal'_zero\n#align matrix.block_diagonal'_tsum Matrix.blockDiagonal'_tsum\n-/\n\n"}