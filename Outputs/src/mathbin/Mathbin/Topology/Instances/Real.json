{"uniform_continuous_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.uniform_continuous_neg : uniform_continuous (@has_neg.neg (exprℝ) _) :=\n  metric.uniform_continuous_iff.2 fun ε ε0 =>\n    ⟨_, ε0, fun a b h => by rw [dist_comm] at h <;> simpa [real.dist_eq] using h⟩\n#align real.uniform_continuous_neg real.uniform_continuous_neg\n\n",
 "uniform_continuous_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.uniform_continuous_mul (s : set (exprℝ × exprℝ)) {r₁ r₂ : exprℝ}\n    (H : ∀ x ∈ s, |(x : exprℝ × exprℝ).1| < r₁ ∧ |x.2| < r₂) : uniform_continuous fun p : s => p.1.1 * p.1.2 :=\n  metric.uniform_continuous_iff.2 fun ε ε0 =>\n    let ⟨δ, δ0, Hδ⟩ := rat_mul_continuous_lemma abs ε0\n    ⟨δ, δ0, fun a b h =>\n      let ⟨h₁, h₂⟩ := max_lt_iff.1 h\n      Hδ (H _ a.2).1 (H _ b.2).2 h₁ h₂⟩\n#align real.uniform_continuous_mul real.uniform_continuous_mul\n\n",
 "uniform_continuous_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.uniform_continuous_inv (s : set (exprℝ)) {r : exprℝ} (r0 : 0 < r) (H : ∀ x ∈ s, r ≤ |x|) :\n    uniform_continuous fun p : s => p.1⁻¹ :=\n  metric.uniform_continuous_iff.2 fun ε ε0 =>\n    let ⟨δ, δ0, Hδ⟩ := rat_inv_continuous_lemma abs ε0 r0\n    ⟨δ, δ0, fun a b h => Hδ (H _ a.2) (H _ b.2) h⟩\n#align real.uniform_continuous_inv real.uniform_continuous_inv\n\n",
 "uniform_continuous_const_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.uniform_continuous_const_mul {x : exprℝ} : uniform_continuous ((· * ·) x) :=\n  uniform_continuous_const_smul x\n#align real.uniform_continuous_const_mul real.uniform_continuous_const_mul\n\n",
 "uniform_continuous_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\ntheorem real.uniform_continuous_add : uniform_continuous fun p : exprℝ × exprℝ => p.1 + p.2 :=\n  metric.uniform_continuous_iff.2 fun ε ε0 =>\n    let ⟨δ, δ0, Hδ⟩ := rat_add_continuous_lemma abs ε0\n    ⟨δ, δ0, fun a b h =>\n      let ⟨h₁, h₂⟩ := max_lt_iff.1 h\n      Hδ h₁ h₂⟩\n#align real.uniform_continuous_add real.uniform_continuous_add\n\n",
 "uniform_continuous_abs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.uniform_continuous_abs : uniform_continuous (abs : exprℝ → exprℝ) :=\n  metric.uniform_continuous_iff.2 fun ε ε0 => ⟨ε, ε0, fun a b => lt_of_le_of_lt (abs_abs_sub_abs_le_abs_sub _ _)⟩\n#align real.uniform_continuous_abs real.uniform_continuous_abs\n\n",
 "totally_bounded_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.totally_bounded_ball (x ε : exprℝ) : totally_bounded (ball x ε) := by\n  rw [real.ball_eq_Ioo] <;> apply totally_bounded_Ioo\n#align real.totally_bounded_ball real.totally_bounded_ball\n\n",
 "tendsto_zmultiples_subtype_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The subgroup \"multiples of `a`\" (`zmultiples a`) is a discrete subgroup of `ℝ`, i.e. its\nintersection with compact sets is finite. -/\ntheorem tendsto_zmultiples_subtype_cofinite (a : exprℝ) : tendsto (zmultiples a).subtype cofinite (cocompact (exprℝ)) :=\n  by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · rw [add_subgroup.zmultiples_zero_eq_bot]\n    intro K hK\n    rw [filter.mem_map, mem_cofinite]\n    apply set.to_finite\n  intro K hK\n  have H := int.tendsto_zmultiples_hom_cofinite ha hK\n  simp only [filter.mem_map, mem_cofinite, ← preimage_compl] at H⊢\n  rw [←\n    (zmultiplesHom (exprℝ) a).range_restrict_surjective.image_preimage\n      («expr ⁻¹' » (zmultiples a).subtype («expr ᶜ» K)),\n    ← preimage_comp, ← add_monoid_hom.coe_comp_range_restrict]\n  exact finite.image _ H\n#align tendsto_zmultiples_subtype_cofinite tendsto_zmultiples_subtype_cofinite\n\n",
 "tendsto_zmultiples_hom_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- For nonzero `a`, the \"multiples of `a`\" map `zmultiples_hom` from `ℤ` to `ℝ` is discrete, i.e.\ninverse images of compact sets are finite. -/\ntheorem tendsto_zmultiples_hom_cofinite {a : exprℝ} (ha : a ≠ 0) :\n    tendsto (zmultiplesHom (exprℝ) a) cofinite (cocompact (exprℝ)) :=\n  by\n  convert (tendsto_cocompact_mul_right₀ ha).comp int.tendsto_coe_cofinite\n  ext n\n  simp\n#align tendsto_zmultiples_hom_cofinite tendsto_zmultiples_hom_cofinite\n\n",
 "tendsto_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem real.tendsto_inv {r : exprℝ} (r0 : r ≠ 0) : tendsto (fun q => q⁻¹) ((nhds) r) ((nhds) r⁻¹) := by\n  rw [← abs_pos] at r0 <;>\n    exact\n      tendsto_of_uniform_continuous_subtype\n        (real.uniform_continuous_inv { x | |r| / 2 < |x| } (half_pos r0) fun x h => le_of_lt h)\n        (is_open.mem_nhds ((is_open_lt' (|r| / 2)).preimage continuous_abs) (half_lt_self r0))\n#align real.tendsto_inv real.tendsto_inv\n\n",
 "tendsto_coe_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Under the coercion from `ℤ` to `ℝ`, inverse images of compact sets are finite. -/\ntheorem tendsto_coe_cofinite : tendsto (coe : ℤ → exprℝ) cofinite (cocompact (exprℝ)) :=\n  by\n  refine' tendsto_cocompact_of_tendsto_dist_comp_at_top (0 : exprℝ) _\n  simp only [filter.tendsto_at_top, eventually_cofinite, not_le, ← mem_ball]\n  change ∀ r : exprℝ, («expr ⁻¹' » coe (ball (0 : exprℝ) r)).finite\n  simp [real.ball_eq_Ioo, set.finite_Ioo]\n#align tendsto_coe_cofinite tendsto_coe_cofinite\n\n",
 "subset_Icc_Inf_Sup_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.subset_Icc_Inf_Sup_of_bounded {s : set (exprℝ)} (h : bounded s) : s ⊆ Icc (infₛ s) (supₛ s) :=\n  subset_Icc_cinfₛ_csupₛ (real.bounded_iff_bdd_below_bdd_above.1 h).1 (real.bounded_iff_bdd_below_bdd_above.1 h).2\n#align real.subset_Icc_Inf_Sup_of_bounded real.subset_Icc_Inf_Sup_of_bounded\n\n",
 "subgroup_dense_or_cyclic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Subgroups of `ℝ` are either dense or cyclic. See `real.subgroup_dense_of_no_min` and\n`subgroup_cyclic_of_min` for more precise statements. -/\ntheorem real.subgroup_dense_or_cyclic (G : add_subgroup (exprℝ)) :\n    dense (G : set (exprℝ)) ∨ ∃ a : exprℝ, G = add_subgroup.closure {a} :=\n  by\n  cases' add_subgroup.bot_or_exists_ne_zero G with H H\n  · right\n    use 0\n    rw [H, add_subgroup.closure_singleton_zero]\n  · let G_pos := { g : exprℝ | g ∈ G ∧ 0 < g }\n    by_cases H' : ∃ a, IsLeast G_pos a\n    · right\n      rcases H' with ⟨a, ha⟩\n      exact ⟨a, add_subgroup.cyclic_of_min ha⟩\n    · left\n      rcases H with ⟨g₀, g₀_in, g₀_ne⟩\n      exact real.subgroup_dense_of_no_min g₀_in g₀_ne H'\n#align real.subgroup_dense_or_cyclic real.subgroup_dense_or_cyclic\n\n",
 "subgroup_dense_of_no_min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Given a nontrivial subgroup `G ⊆ ℝ`, if `G ∩ ℝ_{>0}` has no minimum then `G` is dense. -/\ntheorem real.subgroup_dense_of_no_min {G : add_subgroup (exprℝ)} {g₀ : exprℝ} (g₀_in : g₀ ∈ G) (g₀_ne : g₀ ≠ 0)\n    (H' : ¬∃ a : exprℝ, IsLeast { g : exprℝ | g ∈ G ∧ 0 < g } a) : dense (G : set (exprℝ)) :=\n  by\n  let G_pos := { g : exprℝ | g ∈ G ∧ 0 < g }\n  push_neg  at H'\n  intro x\n  suffices ∀ ε > (0 : exprℝ), ∃ g ∈ G, |x - g| < ε by simpa only [real.mem_closure_iff, abs_sub_comm]\n  intro ε ε_pos\n  obtain ⟨g₁, g₁_in, g₁_pos⟩ : ∃ g₁ : exprℝ, g₁ ∈ G ∧ 0 < g₁ :=\n    by\n    cases' lt_or_gt_of_ne g₀_ne with Hg₀ Hg₀\n    · exact ⟨-g₀, G.neg_mem g₀_in, neg_pos.mpr Hg₀⟩\n    · exact ⟨g₀, g₀_in, Hg₀⟩\n  obtain ⟨a, ha⟩ : ∃ a, IsGLB G_pos a := ⟨Inf G_pos, isGLB_cinfₛ ⟨g₁, g₁_in, g₁_pos⟩ ⟨0, fun _ hx => le_of_lt hx.2⟩⟩\n  have a_notin : a ∉ G_pos := by\n    intro H\n    exact H' a ⟨H, ha.1⟩\n  obtain ⟨g₂, g₂_in, g₂_pos, g₂_lt⟩ : ∃ g₂ : exprℝ, g₂ ∈ G ∧ 0 < g₂ ∧ g₂ < ε :=\n    by\n    obtain ⟨b, hb, hb', hb''⟩ := ha.exists_between_self_add' a_notin ε_pos\n    obtain ⟨c, hc, hc', hc''⟩ := ha.exists_between_self_add' a_notin (sub_pos.2 hb')\n    refine' ⟨b - c, G.sub_mem hb.1 hc.1, _, _⟩ <;> linarith\n  refine' ⟨floor (x / g₂) * g₂, _, _⟩\n  · exact add_subgroup.int_mul_mem _ g₂_in\n  · rw [abs_of_nonneg (sub_floor_div_mul_nonneg x g₂_pos)]\n    linarith [sub_floor_div_mul_lt x g₂_pos]\n#align real.subgroup_dense_of_no_min real.subgroup_dense_of_no_min\n\n",
 "mem_closure_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- TODO(Mario): Prove that these are uniform isomorphisms instead of uniform embeddings\nlemma uniform_embedding_add_rat {r : ℚ} : uniform_embedding (λp:ℚ, p + r) :=\n_\n\nlemma uniform_embedding_mul_rat {q : ℚ} (hq : q ≠ 0) : uniform_embedding ((*) q) :=\n_ -/\ntheorem real.mem_closure_iff {s : set (exprℝ)} {x : exprℝ} : x ∈ closure s ↔ ∀ ε > 0, ∃ y ∈ s, |y - x| < ε := by\n  simp [mem_closure_iff_nhds_basis nhds_basis_ball, real.dist_eq]\n#align real.mem_closure_iff real.mem_closure_iff\n\n",
 "is_topological_basis_Ioo_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n-- short-circuit type class inference\ntheorem real.is_topological_basis_Ioo_rat :\n    @is_topological_basis (exprℝ) _\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" {Ioo a b}) :=\n  is_topological_basis_of_open_of_nhds (by simp (config := { contextual := true }) [is_open_Ioo]) fun a v hav hv =>\n    let ⟨l, u, ⟨hl, hu⟩, h⟩ := mem_nhds_iff_exists_Ioo_subset.mp (is_open.mem_nhds hv hav)\n    let ⟨q, hlq, hqa⟩ := exists_rat_btwn hl\n    let ⟨p, hap, hpu⟩ := exists_rat_btwn hu\n    ⟨Ioo q p, by\n      simp only [mem_Union]\n      exact ⟨q, p, Rat.cast_lt.1 <| hqa.trans hap, rfl⟩, ⟨hqa, hap⟩, fun a' ⟨hqa', ha'p⟩ =>\n      h ⟨hlq.trans hqa', ha'p.trans hpu⟩⟩\n#align real.is_topological_basis_Ioo_rat real.is_topological_basis_Ioo_rat\n\n",
 "inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.continuous.inv [topological_space α] {f : α → exprℝ} (h : ∀ a, f a ≠ 0) (hf : continuous f) :\n    continuous fun a => (f a)⁻¹ :=\n  show continuous ((has_inv.inv ∘ @subtype.val (exprℝ) fun r => r ≠ 0) ∘ fun a => ⟨f a, h a⟩) from\n    real.continuous_inv.comp (hf.subtype_mk _)\n#align real.continuous.inv real.continuous.inv\n\n",
 "continuous_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprotected theorem real.continuous_mul : continuous fun p : exprℝ × exprℝ => p.1 * p.2 :=\n  continuous_iff_continuous_at.2 fun ⟨a₁, a₂⟩ =>\n    tendsto_of_uniform_continuous_subtype\n      (real.uniform_continuous_mul (lower_set.prod { x | |x| < |a₁| + 1 } { x | |x| < |a₂| + 1 }) fun x => id)\n      (is_open.mem_nhds\n        (((is_open_gt' (|a₁| + 1)).preimage continuous_abs).prod ((is_open_gt' (|a₂| + 1)).preimage continuous_abs))\n        ⟨lt_add_one (|a₁|), lt_add_one (|a₂|)⟩)\n#align real.continuous_mul real.continuous_mul\n\n",
 "continuous_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem real.continuous_inv : continuous fun a : { r : exprℝ // r ≠ 0 } => a.val⁻¹ :=\n  continuous_iff_continuous_at.mpr fun ⟨r, hr⟩ =>\n    tendsto.comp (real.tendsto_inv hr) (continuous_iff_continuous_at.mp continuous_subtype_val _)\n#align real.continuous_inv real.continuous_inv\n\n",
 "compact_of_continuous'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem periodic.compact_of_continuous' [topological_space α] {f : exprℝ → α} {c : exprℝ} (hp : periodic f c)\n    (hc : 0 < c) (hf : continuous f) : is_compact (range f) :=\n  by\n  convert is_compact_Icc.image hf\n  ext x\n  refine' ⟨_, mem_range_of_mem_image f (Icc 0 c)⟩\n  rintro ⟨y, h1⟩\n  obtain ⟨z, hz, h2⟩ := hp.exists_mem_Ico₀ hc y\n  exact ⟨z, mem_Icc_of_Ico hz, h2.symm.trans h1⟩\n#align periodic.compact_of_continuous' periodic.compact_of_continuous'\n\n",
 "compact_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A continuous, periodic function has compact range. -/\ntheorem periodic.compact_of_continuous [topological_space α] {f : exprℝ → α} {c : exprℝ} (hp : periodic f c)\n    (hc : c ≠ 0) (hf : continuous f) : is_compact (range f) :=\n  by\n  cases' lt_or_gt_of_ne hc with hneg hpos\n  exacts[hp.neg.compact_of_continuous' (neg_pos.mpr hneg) hf, hp.compact_of_continuous' hpos hf]\n#align periodic.compact_of_continuous periodic.compact_of_continuous\n\n",
 "cocompact_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem real.cocompact_eq : cocompact (exprℝ) = «expr ⊔ » at_bot at_top := by\n  simp only [← comap_dist_right_at_top_eq_cocompact (0 : exprℝ), real.dist_eq, sub_zero, comap_abs_at_top]\n#align real.cocompact_eq real.cocompact_eq\n\n",
 "closure_of_rat_image_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem closure_of_rat_image_lt {q : exprℚ} :\n    closure («expr '' » (coe : exprℚ → exprℝ) { x | q < x }) = { r | ↑q ≤ r } :=\n  Subset.antisymm\n    ((is_closed_ge' _).closure_subset_iff.2\n      (image_subset_iff.2 fun p h => le_of_lt <| (@Rat.cast_lt (exprℝ) _ _ _).2 h))\n    fun x hx =>\n    mem_closure_iff_nhds.2 fun t ht =>\n      let ⟨ε, ε0, hε⟩ := metric.mem_nhds_iff.1 ht\n      let ⟨p, h₁, h₂⟩ := exists_rat_btwn ((lt_add_iff_pos_right x).2 ε0)\n      ⟨_, hε (show abs _ < _ by rwa [abs_of_nonneg (le_of_lt <| sub_pos.2 h₁), sub_lt_iff_lt_add']), p,\n        Rat.cast_lt.1 (@lt_of_le_of_lt (exprℝ) _ _ _ _ hx h₁), rfl⟩\n#align closure_of_rat_image_lt closure_of_rat_image_lt\n\n",
 "bounded_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A continuous, periodic function is bounded. -/\ntheorem periodic.bounded_of_continuous [pseudo_metric_space α] {f : exprℝ → α} {c : exprℝ} (hp : periodic f c)\n    (hc : c ≠ 0) (hf : continuous f) : bounded (range f) :=\n  (hp.compact_of_continuous hc hf).bounded\n#align periodic.bounded_of_continuous periodic.bounded_of_continuous\n\n",
 "bounded_iff_bdd_below_bdd_above":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- TODO(Mario): Put these back only if needed later\nlemma closure_of_rat_image_le_eq {q : ℚ} : closure ((coe:ℚ → ℝ) '' {x | q ≤ x}) = {r | ↑q ≤ r} :=\n_\n\nlemma closure_of_rat_image_le_le_eq {a b : ℚ} (hab : a ≤ b) :\n  closure (of_rat '' {q:ℚ | a ≤ q ∧ q ≤ b}) = {r:ℝ | of_rat a ≤ r ∧ r ≤ of_rat b} :=\n_-/\ntheorem real.bounded_iff_bdd_below_bdd_above {s : set (exprℝ)} : bounded s ↔ BddBelow s ∧ BddAbove s :=\n  ⟨by\n    intro bdd\n    rcases(bounded_iff_subset_ball 0).1 bdd with ⟨r, hr⟩\n    -- hr : s ⊆ closed_ball 0 r\n    rw [real.closed_ball_eq_Icc] at hr\n    -- hr : s ⊆ Icc (0 - r) (0 + r)\n    exact ⟨bdd_below_Icc.mono hr, bdd_above_Icc.mono hr⟩,\n    fun h => bounded_of_bdd_above_of_bdd_below h.2 h.1⟩\n#align real.bounded_iff_bdd_below_bdd_above real.bounded_iff_bdd_below_bdd_above\n\n"}