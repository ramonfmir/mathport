{"uniformContinuous_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Real.uniformContinuous_neg /-\ntheorem Real.uniformContinuous_neg : UniformContinuous (@has_neg.neg (exprℝ) _) :=\n  Metric.uniformContinuous_iff.2 fun ε ε0 =>\n    ⟨_, ε0, fun a b h => by rw [dist_comm] at h <;> simpa [Real.dist_eq] using h⟩\n#align real.uniform_continuous_neg Real.uniformContinuous_neg\n-/\n\n",
 "uniformContinuous_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Real.uniformContinuous_mul /-\ntheorem Real.uniformContinuous_mul (s : Set (exprℝ × exprℝ)) {r₁ r₂ : exprℝ}\n    (H : ∀ x ∈ s, |(x : exprℝ × exprℝ).1| < r₁ ∧ |x.2| < r₂) : UniformContinuous fun p : s => p.1.1 * p.1.2 :=\n  Metric.uniformContinuous_iff.2 fun ε ε0 =>\n    let ⟨δ, δ0, Hδ⟩ := rat_mul_continuous_lemma abs ε0\n    ⟨δ, δ0, fun a b h =>\n      let ⟨h₁, h₂⟩ := max_lt_iff.1 h\n      Hδ (H _ a.2).1 (H _ b.2).2 h₁ h₂⟩\n#align real.uniform_continuous_mul Real.uniformContinuous_mul\n-/\n\n",
 "uniformContinuous_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Real.uniformContinuous_inv /-\ntheorem Real.uniformContinuous_inv (s : Set (exprℝ)) {r : exprℝ} (r0 : 0 < r) (H : ∀ x ∈ s, r ≤ |x|) :\n    UniformContinuous fun p : s => p.1⁻¹ :=\n  Metric.uniformContinuous_iff.2 fun ε ε0 =>\n    let ⟨δ, δ0, Hδ⟩ := rat_inv_continuous_lemma abs ε0 r0\n    ⟨δ, δ0, fun a b h => Hδ (H _ a.2) (H _ b.2) h⟩\n#align real.uniform_continuous_inv Real.uniformContinuous_inv\n-/\n\n",
 "uniformContinuous_const_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Real.uniformContinuous_const_mul /-\ntheorem Real.uniformContinuous_const_mul {x : exprℝ} : UniformContinuous ((· * ·) x) :=\n  uniform_continuous_const_smul x\n#align real.uniform_continuous_const_mul Real.uniformContinuous_const_mul\n-/\n\n",
 "uniformContinuous_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Real.uniformContinuous_add /-\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\ntheorem Real.uniformContinuous_add : UniformContinuous fun p : exprℝ × exprℝ => p.1 + p.2 :=\n  Metric.uniformContinuous_iff.2 fun ε ε0 =>\n    let ⟨δ, δ0, Hδ⟩ := rat_add_continuous_lemma abs ε0\n    ⟨δ, δ0, fun a b h =>\n      let ⟨h₁, h₂⟩ := max_lt_iff.1 h\n      Hδ h₁ h₂⟩\n#align real.uniform_continuous_add Real.uniformContinuous_add\n-/\n\n",
 "uniformContinuous_abs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Real.uniformContinuous_abs /-\ntheorem Real.uniformContinuous_abs : UniformContinuous (abs : exprℝ → exprℝ) :=\n  Metric.uniformContinuous_iff.2 fun ε ε0 => ⟨ε, ε0, fun a b => lt_of_le_of_lt (abs_abs_sub_abs_le_abs_sub _ _)⟩\n#align real.uniform_continuous_abs Real.uniformContinuous_abs\n-/\n\n",
 "totallyBounded_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Real.totallyBounded_ball /-\ntheorem Real.totallyBounded_ball (x ε : exprℝ) : TotallyBounded (ball x ε) := by\n  rw [Real.ball_eq_Ioo] <;> apply totallyBounded_Ioo\n#align real.totally_bounded_ball Real.totallyBounded_ball\n-/\n\n",
 "tendsto_zmultiples_subtype_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The subgroup \"multiples of `a`\" (`zmultiples a`) is a discrete subgroup of `ℝ`, i.e. its\nintersection with compact sets is finite. -/\ntheorem tendsto_zmultiples_subtype_cofinite (a : exprℝ) : Tendsto (zmultiples a).subtype cofinite (cocompact (exprℝ)) :=\n  by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · rw [AddSubgroup.zmultiples_zero_eq_bot]\n    intro K hK\n    rw [Filter.mem_map, mem_cofinite]\n    apply Set.toFinite\n  intro K hK\n  have H := Int.tendsto_zmultiplesHom_cofinite ha hK\n  simp only [Filter.mem_map, mem_cofinite, ← preimage_compl] at H⊢\n  rw [←\n    (zmultiplesHom (exprℝ) a).range_restrict_surjective.image_preimage\n      («expr ⁻¹' » (zmultiples a).subtype («expr ᶜ» K)),\n    ← preimage_comp, ← AddMonoidHom.coe_comp_rangeRestrict]\n  exact finite.image _ H\n#align tendsto_zmultiples_subtype_cofinite tendsto_zmultiples_subtype_cofinite\n\n",
 "tendsto_zmultiples_hom_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- For nonzero `a`, the \"multiples of `a`\" map `zmultiples_hom` from `ℤ` to `ℝ` is discrete, i.e.\ninverse images of compact sets are finite. -/\ntheorem tendsto_zmultiples_hom_cofinite {a : exprℝ} (ha : a ≠ 0) :\n    Tendsto (zmultiplesHom (exprℝ) a) cofinite (cocompact (exprℝ)) :=\n  by\n  convert(tendsto_cocompact_mul_right₀ ha).comp Int.tendsto_coe_cofinite\n  ext n\n  simp\n#align tendsto_zmultiples_hom_cofinite tendsto_zmultiples_hom_cofinite\n\n",
 "tendsto_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Real.tendsto_inv /-\ntheorem Real.tendsto_inv {r : exprℝ} (r0 : r ≠ 0) : Tendsto (fun q => q⁻¹) ((nhds) r) ((nhds) r⁻¹) := by\n  rw [← abs_pos] at r0 <;>\n    exact\n      tendsto_of_uniformContinuous_subtype\n        (Real.uniformContinuous_inv { x | |r| / 2 < |x| } (half_pos r0) fun x h => le_of_lt h)\n        (IsOpen.mem_nhds ((isOpen_lt' (|r| / 2)).preimage continuous_abs) (half_lt_self r0))\n#align real.tendsto_inv Real.tendsto_inv\n-/\n\n",
 "tendsto_coe_cofinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Under the coercion from `ℤ` to `ℝ`, inverse images of compact sets are finite. -/\ntheorem tendsto_coe_cofinite : Tendsto (coe : ℤ → exprℝ) cofinite (cocompact (exprℝ)) :=\n  by\n  refine' tendsto_cocompact_of_tendsto_dist_comp_atTop (0 : exprℝ) _\n  simp only [Filter.tendsto_atTop, eventually_cofinite, not_le, ← mem_ball]\n  change ∀ r : exprℝ, («expr ⁻¹' » coe (ball (0 : exprℝ) r)).finite\n  simp [Real.ball_eq_Ioo, Set.finite_Ioo]\n#align tendsto_coe_cofinite tendsto_coe_cofinite\n\n",
 "subset_Icc_infₛ_supₛ_of_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Real.subset_Icc_infₛ_supₛ_of_bounded /-\ntheorem Real.subset_Icc_infₛ_supₛ_of_bounded {s : Set (exprℝ)} (h : Bounded s) : s ⊆ Icc (infₛ s) (supₛ s) :=\n  subset_Icc_cinfₛ_csupₛ (Real.bounded_iff_bddBelow_bddAbove.1 h).1 (Real.bounded_iff_bddBelow_bddAbove.1 h).2\n#align real.subset_Icc_Inf_Sup_of_bounded Real.subset_Icc_infₛ_supₛ_of_bounded\n-/\n\n",
 "mem_closure_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Real.mem_closure_iff /-\n/- TODO(Mario): Prove that these are uniform isomorphisms instead of uniform embeddings\nlemma uniform_embedding_add_rat {r : ℚ} : uniform_embedding (λp:ℚ, p + r) :=\n_\n\nlemma uniform_embedding_mul_rat {q : ℚ} (hq : q ≠ 0) : uniform_embedding ((*) q) :=\n_ -/\ntheorem Real.mem_closure_iff {s : Set (exprℝ)} {x : exprℝ} : x ∈ closure s ↔ ∀ ε > 0, ∃ y ∈ s, |y - x| < ε := by\n  simp [mem_closure_iff_nhds_basis nhds_basis_ball, Real.dist_eq]\n#align real.mem_closure_iff Real.mem_closure_iff\n-/\n\n",
 "isTopologicalBasis_Ioo_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print Real.isTopologicalBasis_Ioo_rat /-\n-- short-circuit type class inference\ntheorem Real.isTopologicalBasis_Ioo_rat :\n    @IsTopologicalBasis (exprℝ) _\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" {Ioo a b}) :=\n  isTopologicalBasis_of_open_of_nhds (by simp (config := { contextual := true }) [isOpen_Ioo]) fun a v hav hv =>\n    let ⟨l, u, ⟨hl, hu⟩, h⟩ := mem_nhds_iff_exists_Ioo_subset.mp (IsOpen.mem_nhds hv hav)\n    let ⟨q, hlq, hqa⟩ := exists_rat_btwn hl\n    let ⟨p, hap, hpu⟩ := exists_rat_btwn hu\n    ⟨Ioo q p, by\n      simp only [mem_Union]\n      exact ⟨q, p, Rat.cast_lt.1 <| hqa.trans hap, rfl⟩, ⟨hqa, hap⟩, fun a' ⟨hqa', ha'p⟩ =>\n      h ⟨hlq.trans hqa', ha'p.trans hpu⟩⟩\n#align real.is_topological_basis_Ioo_rat Real.isTopologicalBasis_Ioo_rat\n-/\n\n",
 "inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Real.Continuous.inv /-\ntheorem Real.Continuous.inv [TopologicalSpace α] {f : α → exprℝ} (h : ∀ a, f a ≠ 0) (hf : Continuous f) :\n    Continuous fun a => (f a)⁻¹ :=\n  show Continuous ((has_inv.inv ∘ @Subtype.val (exprℝ) fun r => r ≠ 0) ∘ fun a => ⟨f a, h a⟩) from\n    Real.continuous_inv.comp (hf.subtype_mk _)\n#align real.continuous.inv Real.Continuous.inv\n-/\n\n",
 "dense_or_cyclic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Subgroups of `ℝ` are either dense or cyclic. See `real.subgroup_dense_of_no_min` and\n`subgroup_cyclic_of_min` for more precise statements. -/\ntheorem AddSubgroup.dense_or_cyclic (G : AddSubgroup (exprℝ)) :\n    Dense (G : Set (exprℝ)) ∨ ∃ a : exprℝ, G = AddSubgroup.closure {a} :=\n  by\n  cases' AddSubgroup.bot_or_exists_ne_zero G with H H\n  · right\n    use 0\n    rw [H, AddSubgroup.closure_singleton_zero]\n  · let G_pos := { g : exprℝ | g ∈ G ∧ 0 < g }\n    by_cases H' : ∃ a, IsLeast G_pos a\n    · right\n      rcases H' with ⟨a, ha⟩\n      exact ⟨a, AddSubgroup.cyclic_of_min ha⟩\n    · left\n      rcases H with ⟨g₀, g₀_in, g₀_ne⟩\n      exact AddSubgroup.dense_of_no_min g₀_in g₀_ne H'\n#align real.subgroup_dense_or_cyclic AddSubgroup.dense_or_cyclicₓ\n\n",
 "dense_of_no_min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Given a nontrivial subgroup `G ⊆ ℝ`, if `G ∩ ℝ_{>0}` has no minimum then `G` is dense. -/\ntheorem AddSubgroup.dense_of_no_min {G : AddSubgroup (exprℝ)} {g₀ : exprℝ} (g₀_in : g₀ ∈ G) (g₀_ne : g₀ ≠ 0)\n    (H' : ¬∃ a : exprℝ, IsLeast { g : exprℝ | g ∈ G ∧ 0 < g } a) : Dense (G : Set (exprℝ)) :=\n  by\n  let G_pos := { g : exprℝ | g ∈ G ∧ 0 < g }\n  push_neg  at H'\n  intro x\n  suffices ∀ ε > (0 : exprℝ), ∃ g ∈ G, |x - g| < ε by simpa only [Real.mem_closure_iff, abs_sub_comm]\n  intro ε ε_pos\n  obtain ⟨g₁, g₁_in, g₁_pos⟩ : ∃ g₁ : exprℝ, g₁ ∈ G ∧ 0 < g₁ :=\n    by\n    cases' lt_or_gt_of_ne g₀_ne with Hg₀ Hg₀\n    · exact ⟨-g₀, G.neg_mem g₀_in, neg_pos.mpr Hg₀⟩\n    · exact ⟨g₀, g₀_in, Hg₀⟩\n  obtain ⟨a, ha⟩ : ∃ a, IsGLB G_pos a := ⟨Inf G_pos, isGLB_cinfₛ ⟨g₁, g₁_in, g₁_pos⟩ ⟨0, fun _ hx => le_of_lt hx.2⟩⟩\n  have a_notin : a ∉ G_pos := by\n    intro H\n    exact H' a ⟨H, ha.1⟩\n  obtain ⟨g₂, g₂_in, g₂_pos, g₂_lt⟩ : ∃ g₂ : exprℝ, g₂ ∈ G ∧ 0 < g₂ ∧ g₂ < ε :=\n    by\n    obtain ⟨b, hb, hb', hb''⟩ := ha.exists_between_self_add' a_notin ε_pos\n    obtain ⟨c, hc, hc', hc''⟩ := ha.exists_between_self_add' a_notin (sub_pos.2 hb')\n    refine' ⟨b - c, G.sub_mem hb.1 hc.1, _, _⟩ <;> linarith\n  refine' ⟨floor (x / g₂) * g₂, _, _⟩\n  · exact AddSubgroup.int_mul_mem _ g₂_in\n  · rw [abs_of_nonneg (sub_floor_div_mul_nonneg x g₂_pos)]\n    linarith [sub_floor_div_mul_lt x g₂_pos]\n#align real.subgroup_dense_of_no_min AddSubgroup.dense_of_no_minₓ\n\n",
 "continuous_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Real.continuous_mul /-\nprotected theorem Real.continuous_mul : Continuous fun p : exprℝ × exprℝ => p.1 * p.2 :=\n  continuous_iff_continuousAt.2 fun ⟨a₁, a₂⟩ =>\n    tendsto_of_uniformContinuous_subtype\n      (Real.uniformContinuous_mul (lower_set.prod { x | |x| < |a₁| + 1 } { x | |x| < |a₂| + 1 }) fun x => id)\n      (IsOpen.mem_nhds\n        (((isOpen_gt' (|a₁| + 1)).preimage continuous_abs).prod ((isOpen_gt' (|a₂| + 1)).preimage continuous_abs))\n        ⟨lt_add_one (|a₁|), lt_add_one (|a₂|)⟩)\n#align real.continuous_mul Real.continuous_mul\n-/\n\n",
 "continuous_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Real.continuous_inv /-\ntheorem Real.continuous_inv : Continuous fun a : { r : exprℝ // r ≠ 0 } => a.val⁻¹ :=\n  continuous_iff_continuousAt.mpr fun ⟨r, hr⟩ =>\n    Tendsto.comp (Real.tendsto_inv hr) (continuous_iff_continuousAt.mp continuous_subtype_val _)\n#align real.continuous_inv Real.continuous_inv\n-/\n\n",
 "compact_of_continuous'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem periodic.compact_of_continuous' [TopologicalSpace α] {f : exprℝ → α} {c : exprℝ} (hp : Periodic f c)\n    (hc : 0 < c) (hf : Continuous f) : IsCompact (range f) :=\n  by\n  convert is_compact_Icc.image hf\n  ext x\n  refine' ⟨_, mem_range_of_mem_image f (Icc 0 c)⟩\n  rintro ⟨y, h1⟩\n  obtain ⟨z, hz, h2⟩ := hp.exists_mem_Ico₀ hc y\n  exact ⟨z, mem_Icc_of_Ico hz, h2.symm.trans h1⟩\n#align periodic.compact_of_continuous' periodic.compact_of_continuous'\n\n",
 "compact_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A continuous, periodic function has compact range. -/\ntheorem periodic.compact_of_continuous [TopologicalSpace α] {f : exprℝ → α} {c : exprℝ} (hp : Periodic f c) (hc : c ≠ 0)\n    (hf : Continuous f) : IsCompact (range f) :=\n  by\n  cases' lt_or_gt_of_ne hc with hneg hpos\n  exacts[hp.neg.compact_of_continuous' (neg_pos.mpr hneg) hf, hp.compact_of_continuous' hpos hf]\n#align periodic.compact_of_continuous periodic.compact_of_continuous\n\n",
 "cocompact_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print Real.cocompact_eq /-\n@[simp]\ntheorem Real.cocompact_eq : cocompact (exprℝ) = «expr ⊔ » atBot atTop := by\n  simp only [← comap_dist_right_atTop_eq_cocompact (0 : exprℝ), Real.dist_eq, sub_zero, comap_abs_at_top]\n#align real.cocompact_eq Real.cocompact_eq\n-/\n\n",
 "closure_of_rat_image_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print closure_of_rat_image_lt /-\ntheorem closure_of_rat_image_lt {q : exprℚ} :\n    closure («expr '' » (coe : exprℚ → exprℝ) { x | q < x }) = { r | ↑q ≤ r } :=\n  Subset.antisymm\n    ((isClosed_ge' _).closure_subset_iff.2 (image_subset_iff.2 fun p h => le_of_lt <| (@Rat.cast_lt (exprℝ) _ _ _).2 h))\n    fun x hx =>\n    mem_closure_iff_nhds.2 fun t ht =>\n      let ⟨ε, ε0, hε⟩ := Metric.mem_nhds_iff.1 ht\n      let ⟨p, h₁, h₂⟩ := exists_rat_btwn ((lt_add_iff_pos_right x).2 ε0)\n      ⟨_, hε (show abs _ < _ by rwa [abs_of_nonneg (le_of_lt <| sub_pos.2 h₁), sub_lt_iff_lt_add']), p,\n        Rat.cast_lt.1 (@lt_of_le_of_lt (exprℝ) _ _ _ _ hx h₁), rfl⟩\n#align closure_of_rat_image_lt closure_of_rat_image_lt\n-/\n\n",
 "bounded_of_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A continuous, periodic function is bounded. -/\ntheorem periodic.bounded_of_continuous [PseudoMetricSpace α] {f : exprℝ → α} {c : exprℝ} (hp : Periodic f c)\n    (hc : c ≠ 0) (hf : Continuous f) : Bounded (range f) :=\n  (hp.compact_of_continuous hc hf).bounded\n#align periodic.bounded_of_continuous periodic.bounded_of_continuous\n\n",
 "bounded_iff_bddBelow_bddAbove":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print Real.bounded_iff_bddBelow_bddAbove /-\n/- TODO(Mario): Put these back only if needed later\nlemma closure_of_rat_image_le_eq {q : ℚ} : closure ((coe:ℚ → ℝ) '' {x | q ≤ x}) = {r | ↑q ≤ r} :=\n_\n\nlemma closure_of_rat_image_le_le_eq {a b : ℚ} (hab : a ≤ b) :\n  closure (of_rat '' {q:ℚ | a ≤ q ∧ q ≤ b}) = {r:ℝ | of_rat a ≤ r ∧ r ≤ of_rat b} :=\n_-/\ntheorem Real.bounded_iff_bddBelow_bddAbove {s : Set (exprℝ)} : Bounded s ↔ BddBelow s ∧ BddAbove s :=\n  ⟨by\n    intro bdd\n    rcases(bounded_iff_subset_ball 0).1 bdd with ⟨r, hr⟩\n    -- hr : s ⊆ closed_ball 0 r\n    rw [Real.closedBall_eq_Icc] at hr\n    -- hr : s ⊆ Icc (0 - r) (0 + r)\n    exact ⟨bdd_below_Icc.mono hr, bdd_above_Icc.mono hr⟩,\n    fun h => bounded_of_bddAbove_of_bddBelow h.2 h.1⟩\n#align real.bounded_iff_bdd_below_bdd_above Real.bounded_iff_bddBelow_bddAbove\n-/\n\n"}