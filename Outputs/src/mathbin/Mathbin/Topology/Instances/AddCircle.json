{"to_Ico_mod_eventually_eq_to_Ioc_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem to_Ico_mod_eventually_eq_to_Ioc_mod : Â«expr =á¶ [ ] Â» (to_Ico_mod a hp) ((nhds) x) (to_Ioc_mod a hp) :=\n  is_open.mem_nhds\n      (by\n        rw [Ico_eq_locus_Ioc_eq_Union_Ioo]\n        exact is_open_Union fun i => is_open_Ioo) <|\n    (mem_Ioo_mod_iff_to_Ico_mod_eq_to_Ioc_mod hp).1 ((mem_Ioo_mod_iff_ne_mod_zmultiples hp).2 hx)\n#align to_Ico_mod_eventually_eq_to_Ioc_mod to_Ico_mod_eventually_eq_to_Ioc_mod\n\n",
 "lift_Ioc_coe_apply":
 "theorem lift_Ioc_coe_apply {f : ğ•œ â†’ B} {x : ğ•œ} (hx : x âˆˆ Ioc a (a + p)) : lift_Ioc p a f â†‘x = f x :=\n  by\n  have : (equiv_Ioc p a) x = âŸ¨x, hxâŸ© := by\n    rw [equiv.apply_eq_iff_eq_symm_apply]\n    rfl\n  rw [lift_Ioc, comp_apply, this]\n  rfl\n#align lift_Ioc_coe_apply lift_Ioc_coe_apply\n\n",
 "lift_Ico_zero_continuous":
 "theorem lift_Ico_zero_continuous [topological_space B] {f : ğ•œ â†’ B} (hf : f 0 = f p) (hc : continuous_on f <| Icc 0 p) :\n    continuous (lift_Ico p 0 f) :=\n  lift_Ico_continuous (by rwa [zero_add] : f 0 = f (0 + p)) (by rwa [zero_add])\n#align lift_Ico_zero_continuous lift_Ico_zero_continuous\n\n",
 "lift_Ico_zero_coe_apply":
 "theorem lift_Ico_zero_coe_apply {f : ğ•œ â†’ B} {x : ğ•œ} (hx : x âˆˆ Ico 0 p) : lift_Ico p 0 f â†‘x = f x :=\n  lift_Ico_coe_apply (by rwa [zero_add])\n#align lift_Ico_zero_coe_apply lift_Ico_zero_coe_apply\n\n",
 "lift_Ico_eq_lift_Icc":
 "theorem lift_Ico_eq_lift_Icc {f : ğ•œ â†’ B} (h : f a = f (a + p)) :\n    lift_Ico p a f =\n      Quot.lift (restrict (Icc a <| a + p) f)\n          (by\n            rintro _ _ âŸ¨_âŸ©\n            exact h) âˆ˜\n        equiv_Icc_quot p a :=\n  rfl\n#align lift_Ico_eq_lift_Icc lift_Ico_eq_lift_Icc\n\n",
 "lift_Ico_continuous":
 "theorem lift_Ico_continuous [topological_space B] {f : ğ•œ â†’ B} (hf : f a = f (a + p))\n    (hc : continuous_on f <| Icc a (a + p)) : continuous (lift_Ico p a f) :=\n  by\n  rw [lift_Ico_eq_lift_Icc hf]\n  refine' continuous.comp _ (homeo_Icc_quot p a).continuous_to_fun\n  exact continuous_coinduced_dom.mpr (continuous_on_iff_continuous_restrict.mp hc)\n#align lift_Ico_continuous lift_Ico_continuous\n\n",
 "lift_Ico_coe_apply":
 "theorem lift_Ico_coe_apply {f : ğ•œ â†’ B} {x : ğ•œ} (hx : x âˆˆ Ico a (a + p)) : lift_Ico p a f â†‘x = f x :=\n  by\n  have : (equiv_Ico p a) x = âŸ¨x, hxâŸ© := by\n    rw [equiv.apply_eq_iff_eq_symm_apply]\n    rfl\n  rw [lift_Ico, comp_apply, this]\n  rfl\n#align lift_Ico_coe_apply lift_Ico_coe_apply\n\n",
 "gcd_mul_add_order_of_div_eq":
 "theorem gcd_mul_add_order_of_div_eq {n : â„•} (m : â„•) (hn : 0 < n) :\n    m.gcd n * add_order_of (â†‘(â†‘m / â†‘n * p) : add_circle p) = n :=\n  by\n  rw [mul_comm_div, â† nsmul_eq_mul, coe_nsmul, add_order_of_nsmul'']\n  Â· rw [add_order_of_period_div hn, nat.gcd_comm, Nat.mul_div_cancel']\n    exacts[n.gcd_dvd_left m, hp]\n  Â· rw [â† add_order_of_pos_iff, add_order_of_period_div hn]\n    exacts[hn, hp]\n#align gcd_mul_add_order_of_div_eq gcd_mul_add_order_of_div_eq\n\n",
 "finite_set_of_add_order_eq":
 "theorem finite_set_of_add_order_eq {n : â„•} (hn : 0 < n) : { u : add_circle p | add_order_of u = n }.finite :=\n  finite_coe_iff.mp <|\n    nat.finite_of_card_ne_zero <| by\n      simpa only [coe_set_of, card_add_order_of_eq_totient p] using (nat.totient_pos hn).ne'\n#align finite_set_of_add_order_eq finite_set_of_add_order_eq\n\n",
 "exists_gcd_eq_one_of_is_of_fin_add_order":
 "theorem exists_gcd_eq_one_of_is_of_fin_add_order {u : add_circle p} (h : is_of_fin_add_order u) :\n    âˆƒ m : â„•, m.gcd (add_order_of u) = 1 âˆ§ m < add_order_of u âˆ§ â†‘((m : ğ•œ) / add_order_of u * p) = u :=\n  let âŸ¨m, hl, hg, heâŸ© := (add_order_of_eq_pos_iff <| add_order_of_pos' h).1 rfl\n  âŸ¨m, hg, hl, heâŸ©\n#align exists_gcd_eq_one_of_is_of_fin_add_order exists_gcd_eq_one_of_is_of_fin_add_order\n\n",
 "equiv_add_circle_symm_apply_mk":
 "@[simp]\ntheorem equiv_add_circle_symm_apply_mk (hp : p â‰  0) (hq : q â‰  0) (x : ğ•œ) :\n    (equiv_add_circle p q hp hq).symm (x : ğ•œ) = (x * (qâ»Â¹ * p) : ğ•œ) :=\n  rfl\n#align equiv_add_circle_symm_apply_mk equiv_add_circle_symm_apply_mk\n\n",
 "equiv_add_circle_apply_mk":
 "@[simp]\ntheorem equiv_add_circle_apply_mk (hp : p â‰  0) (hq : q â‰  0) (x : ğ•œ) :\n    equiv_add_circle p q hp hq (x : ğ•œ) = (x * (pâ»Â¹ * q) : ğ•œ) :=\n  rfl\n#align equiv_add_circle_apply_mk equiv_add_circle_apply_mk\n\n",
 "equiv_Icc_quot_comp_mk_eq_to_Ioc_mod":
 "theorem equiv_Icc_quot_comp_mk_eq_to_Ioc_mod :\n    equiv_Icc_quot p a âˆ˜ quotient.mk' = fun x =>\n      Quot.mk _ âŸ¨to_Ioc_mod a hp.out x, Ioc_subset_Icc_self <| to_Ioc_mod_mem_Ioc a _ xâŸ© :=\n  by\n  rw [equiv_Icc_quot_comp_mk_eq_to_Ico_mod]; funext\n  by_cases mem_Ioo_mod a p x\n  Â· simp_rw [(mem_Ioo_mod_iff_to_Ico_mod_eq_to_Ioc_mod hp.out).1 h]\n  Â· simp_rw [not_imp_comm.1 (mem_Ioo_mod_iff_to_Ico_mod_ne_left hp.out).2 h,\n      not_imp_comm.1 (mem_Ioo_mod_iff_to_Ioc_mod_ne_right hp.out).2 h]\n    exact quot.sound endpoint_ident.mk\n#align equiv_Icc_quot_comp_mk_eq_to_Ioc_mod equiv_Icc_quot_comp_mk_eq_to_Ioc_mod\n\n",
 "equiv_Icc_quot_comp_mk_eq_to_Ico_mod":
 "theorem equiv_Icc_quot_comp_mk_eq_to_Ico_mod :\n    equiv_Icc_quot p a âˆ˜ quotient.mk' = fun x =>\n      Quot.mk _ âŸ¨to_Ico_mod a hp.out x, Ico_subset_Icc_self <| to_Ico_mod_mem_Ico a _ xâŸ© :=\n  rfl\n#align equiv_Icc_quot_comp_mk_eq_to_Ico_mod equiv_Icc_quot_comp_mk_eq_to_Ico_mod\n\n",
 "continuous_right_to_Ico_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-\nCopyright (c) 2022 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\ntheorem continuous_right_to_Ico_mod : continuous_within_at (to_Ico_mod a hp) (Ici x) x :=\n  by\n  intro s h\n  rw [filter.mem_map, mem_nhds_within_iff_exists_mem_nhds_inter]\n  haveI : nontrivial ğ•œ := âŸ¨âŸ¨0, p, hp.neâŸ©âŸ©\n  simp_rw [mem_nhds_iff_exists_Ioo_subset] at hâŠ¢\n  obtain âŸ¨l, u, hxI, hIsâŸ© := h\n  let d := Â«expr â€¢ Â» (to_Ico_div a hp x) p\n  have hd := to_Ico_mod_mem_Ico a hp x\n  simp_rw [subset_def, mem_inter_iff]\n  refine' âŸ¨_, âŸ¨l + d, min (a + p) u + d, _, fun x => idâŸ©, fun y => _âŸ© <;>\n    simp_rw [â† sub_mem_Ioo_iff_left, mem_Ioo, lt_min_iff]\n  Â· exact âŸ¨hxI.1, hd.2, hxI.2âŸ©\n  Â· rintro âŸ¨h, h'âŸ©\n    apply hIs\n    rw [â† to_Ico_mod_sub_zsmul, (to_Ico_mod_eq_self _).2]\n    exacts[âŸ¨h.1, h.2.2âŸ©, âŸ¨hd.1.trans (sub_le_sub_right h' _), h.2.1âŸ©]\n#align continuous_right_to_Ico_mod continuous_right_to_Ico_mod\n\n",
 "continuous_mk'":
 "@[continuity, nolint unused_arguments]\nprotected theorem continuous_mk' : continuous (quotient_add_group.mk' (zmultiples p) : ğ•œ â†’ add_circle p) :=\n  continuous_coinduced_rng\n#align continuous_mk' continuous_mk'\n\n",
 "continuous_left_to_Ioc_mod":
 "theorem continuous_left_to_Ioc_mod : continuous_within_at (to_Ioc_mod a hp) (Iic x) x :=\n  by\n  rw [(funext fun y => eq.trans (by rw [neg_neg]) <| to_Ioc_mod_neg _ _ _ :\n      to_Ioc_mod a hp = (fun x => p - x) âˆ˜ to_Ico_mod (-a) hp âˆ˜ has_neg.neg)]\n  exact\n    (continuous_sub_left _).continuous_at.comp_continuous_within_at <|\n      (continuous_right_to_Ico_mod _ _ _).comp continuous_neg.continuous_within_at fun y => neg_le_neg\n#align continuous_left_to_Ioc_mod continuous_left_to_Ioc_mod\n\n",
 "continuous_equiv_Ioc_symm":
 "@[continuity]\ntheorem continuous_equiv_Ioc_symm : continuous (equiv_Ioc p a).symm :=\n  continuous_quotient_mk.comp continuous_subtype_coe\n#align continuous_equiv_Ioc_symm continuous_equiv_Ioc_symm\n\n",
 "continuous_equiv_Ico_symm":
 "@[continuity]\ntheorem continuous_equiv_Ico_symm : continuous (equiv_Ico p a).symm :=\n  continuous_quotient_mk.comp continuous_subtype_coe\n#align continuous_equiv_Ico_symm continuous_equiv_Ico_symm\n\n",
 "continuous_at_to_Ioc_mod":
 "theorem continuous_at_to_Ioc_mod : continuous_at (to_Ioc_mod a hp) x :=\n  let h := to_Ico_mod_eventually_eq_to_Ioc_mod a hp hx\n  continuous_at_iff_continuous_left_right.2 <|\n    âŸ¨continuous_left_to_Ioc_mod a hp x,\n      (continuous_right_to_Ico_mod a hp x).congr_of_eventually_eq (h.symm.filter_mono nhds_within_le_nhds)\n        h.symm.eq_of_nhdsâŸ©\n#align continuous_at_to_Ioc_mod continuous_at_to_Ioc_mod\n\n",
 "continuous_at_to_Ico_mod":
 "theorem continuous_at_to_Ico_mod : continuous_at (to_Ico_mod a hp) x :=\n  let h := to_Ico_mod_eventually_eq_to_Ioc_mod a hp hx\n  continuous_at_iff_continuous_left_right.2 <|\n    âŸ¨(continuous_left_to_Ioc_mod a hp x).congr_of_eventually_eq (h.filter_mono nhds_within_le_nhds) h.eq_of_nhds,\n      continuous_right_to_Ico_mod a hp xâŸ©\n#align continuous_at_to_Ico_mod continuous_at_to_Ico_mod\n\n",
 "continuous_at_equiv_Ioc":
 "theorem continuous_at_equiv_Ioc : continuous_at (equiv_Ioc p a) x :=\n  by\n  induction x using quotient_add_group.induction_on'\n  rw [continuous_at, filter.tendsto, quotient_add_group.nhds_eq, filter.map_map]\n  apply continuous_at.cod_restrict; exact continuous_at_to_Ioc_mod a hp.out hx\n#align continuous_at_equiv_Ioc continuous_at_equiv_Ioc\n\n",
 "continuous_at_equiv_Ico":
 "theorem continuous_at_equiv_Ico : continuous_at (equiv_Ico p a) x :=\n  by\n  induction x using quotient_add_group.induction_on'\n  rw [continuous_at, filter.tendsto, quotient_add_group.nhds_eq, filter.map_map]\n  apply continuous_at.cod_restrict; exact continuous_at_to_Ico_mod a hp.out hx\n#align continuous_at_equiv_Ico continuous_at_equiv_Ico\n\n",
 "coe_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem coe_zsmul {n : â„¤} {x : ğ•œ} : (â†‘(Â«expr â€¢ Â» n x) : add_circle p) = Â«expr â€¢ Â» n (x : add_circle p) :=\n  rfl\n#align coe_zsmul coe_zsmul\n\n",
 "coe_sub":
 "theorem coe_sub (x y : ğ•œ) : (â†‘(x - y) : add_circle p) = (x : add_circle p) - (y : add_circle p) :=\n  rfl\n#align coe_sub coe_sub\n\n",
 "coe_period":
 "theorem coe_period : (p : add_circle p) = 0 :=\n  (quotient_add_group.eq_zero_iff p).2 <| mem_zmultiples p\n#align coe_period coe_period\n\n",
 "coe_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem coe_nsmul {n : â„•} {x : ğ•œ} : (â†‘(Â«expr â€¢ Â» n x) : add_circle p) = Â«expr â€¢ Â» n (x : add_circle p) :=\n  rfl\n#align coe_nsmul coe_nsmul\n\n",
 "coe_neg":
 "theorem coe_neg {x : ğ•œ} : (â†‘(-x) : add_circle p) = -(x : add_circle p) :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_image_Ioc_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- The image of the closed-open interval `[a, a + p)` under the quotient map `ğ•œ â†’ add_circle p` is\nthe entire space. -/\n@[simp]\ntheorem coe_image_Ioc_eq : Â«expr '' Â» (coe : ğ•œ â†’ add_circle p) (Ioc a (a + p)) = univ :=\n  by\n  rw [image_eq_range]\n  exact (equiv_Ioc p a).symm.range_eq_univ\n#align coe_image_Ioc_eq coe_image_Ioc_eq\n\n",
 "coe_image_Ico_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- The image of the closed-open interval `[a, a + p)` under the quotient map `ğ•œ â†’ add_circle p` is\nthe entire space. -/\n@[simp]\ntheorem coe_image_Ico_eq : Â«expr '' Â» (coe : ğ•œ â†’ add_circle p) (Ico a (a + p)) = univ :=\n  by\n  rw [image_eq_range]\n  exact (equiv_Ico p a).symm.range_eq_univ\n#align coe_image_Ico_eq coe_image_Ico_eq\n\n",
 "coe_image_Icc_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- The image of the closed interval `[0, p]` under the quotient map `ğ•œ â†’ add_circle p` is the\nentire space. -/\n@[simp]\ntheorem coe_image_Icc_eq : Â«expr '' Â» (coe : ğ•œ â†’ add_circle p) (Icc a (a + p)) = univ :=\n  eq_top_mono (image_subset _ Ico_subset_Icc_self) <| coe_image_Ico_eq _ _\n#align coe_image_Icc_eq coe_image_Icc_eq\n\n",
 "coe_equiv_Ico_mk_apply":
 "@[simp]\ntheorem coe_equiv_Ico_mk_apply (x : ğ•œ) : (equiv_Ico p 0 <| quotient_add_group.mk x : ğ•œ) = Int.fract (x / p) * p :=\n  to_Ico_mod_eq_fract_mul _ x\n#align coe_equiv_Ico_mk_apply coe_equiv_Ico_mk_apply\n\n",
 "coe_eq_zero_of_pos_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem coe_eq_zero_of_pos_iff (hp : 0 < p) {x : ğ•œ} (hx : 0 < x) :\n    (x : add_circle p) = 0 â†” âˆƒ n : â„•, Â«expr â€¢ Â» n p = x :=\n  by\n  rw [coe_eq_zero_iff]\n  constructor <;> rintro âŸ¨n, rflâŸ©\n  Â· replace hx : 0 < n\n    Â· contrapose! hx\n      simpa only [â† neg_nonneg, â† zsmul_neg, zsmul_neg'] using zsmul_nonneg hp.le (neg_nonneg.2 hx)\n    exact âŸ¨n.to_nat, by rw [â† coe_nat_zsmul, Int.toNat_of_nonneg hx.le]âŸ©\n  Â· exact âŸ¨(n : â„¤), by simpâŸ©\n#align coe_eq_zero_of_pos_iff coe_eq_zero_of_pos_iff\n\n",
 "coe_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem coe_eq_zero_iff {x : ğ•œ} : (x : add_circle p) = 0 â†” âˆƒ n : â„¤, Â«expr â€¢ Â» n p = x := by\n  simp [add_subgroup.mem_zmultiples_iff]\n#align coe_eq_zero_iff coe_eq_zero_iff\n\n",
 "coe_eq_coe_iff_of_mem_Ico":
 "theorem coe_eq_coe_iff_of_mem_Ico {x y : ğ•œ} (hx : x âˆˆ Ico a (a + p)) (hy : y âˆˆ Ico a (a + p)) :\n    (x : add_circle p) = y â†” x = y := by\n  refine' âŸ¨fun h => _, by tautoâŸ©\n  suffices (âŸ¨x, hxâŸ© : Ico a (a + p)) = âŸ¨y, hyâŸ© by exact subtype.mk.inj this\n  apply_fun equiv_Ico p a  at h\n  rw [â† (equiv_Ico p a).right_inv âŸ¨x, hxâŸ©, â† (equiv_Ico p a).right_inv âŸ¨y, hyâŸ©]\n  exact h\n#align coe_eq_coe_iff_of_mem_Ico coe_eq_coe_iff_of_mem_Ico\n\n",
 "coe_add_period":
 "@[simp]\ntheorem coe_add_period (x : ğ•œ) : ((x + p : ğ•œ) : add_circle p) = x := by\n  rw [coe_add, â† eq_sub_iff_add_eq', sub_self, coe_period]\n#align coe_add_period coe_add_period\n\n",
 "coe_add":
 "theorem coe_add (x y : ğ•œ) : (â†‘(x + y) : add_circle p) = (x : add_circle p) + (y : add_circle p) :=\n  rfl\n#align coe_add coe_add\n\n",
 "card_add_order_of_eq_totient":
 "@[simp]\ntheorem card_add_order_of_eq_totient {n : â„•} : nat.card { u : add_circle p // add_order_of u = n } = n.totient :=\n  by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  Â· simp only [nat.totient_zero, add_order_of_eq_zero_iff]\n    rcases em (âˆƒ u : add_circle p, Â¬is_of_fin_add_order u) with (âŸ¨u, huâŸ© | h)\n    Â· have : Infinite { u : add_circle p // Â¬is_of_fin_add_order u } :=\n        by\n        erw [infinite_coe_iff]\n        exact infinite_not_is_of_fin_add_order hu\n      exact nat.card_eq_zero_of_infinite\n    Â· have : is_empty { u : add_circle p // Â¬is_of_fin_add_order u } := by simpa using h\n      exact nat.card_of_is_empty\n  Â· rw [â† coe_set_of, nat.card_congr (set_add_order_of_equiv p hn), n.totient_eq_card_lt_and_coprime]\n    simp only [nat.gcd_comm]\n#align card_add_order_of_eq_totient card_add_order_of_eq_totient\n\n",
 "add_order_of_period_div":
 "theorem add_order_of_period_div {n : â„•} (h : 0 < n) : add_order_of ((p / n : ğ•œ) : add_circle p) = n :=\n  by\n  rw [add_order_of_eq_iff h]\n  replace h : 0 < (n : ğ•œ) := nat.cast_pos.2 h\n  refine' âŸ¨_, fun m hn h0 => _âŸ© <;> simp only [ne, â† coe_nsmul, nsmul_eq_mul]\n  Â· rw [mul_div_cancel' _ h.ne', coe_period]\n  rw [coe_eq_zero_of_pos_iff p hp.out (mul_pos (nat.cast_pos.2 h0) <| div_pos hp.out h)]\n  rintro âŸ¨k, hkâŸ©\n  rw [mul_div, eq_div_iff h.ne', nsmul_eq_mul, mul_right_comm, â† nat.cast_mul, (mul_left_injectiveâ‚€ hp.out.ne').eq_iff,\n    Nat.cast_inj, mul_comm] at hk\n  exact (nat.le_of_dvd h0 âŸ¨_, hk.symmâŸ©).not_lt hn\n#align add_order_of_period_div add_order_of_period_div\n\n",
 "add_order_of_eq_pos_iff":
 "theorem add_order_of_eq_pos_iff {u : add_circle p} {n : â„•} (h : 0 < n) :\n    add_order_of u = n â†” âˆƒ m < n, m.gcd n = 1 âˆ§ â†‘(â†‘m / â†‘n * p) = u :=\n  by\n  refine' âŸ¨quotient_add_group.induction_on' u fun k hk => _, _âŸ©; swap\n  Â· rintro âŸ¨m, hâ‚€, hâ‚, rflâŸ©\n    exact add_order_of_div_of_gcd_eq_one h hâ‚\n  have h0 := add_order_of_nsmul_eq_zero (k : add_circle p)\n  rw [hk, â† coe_nsmul, coe_eq_zero_iff] at h0\n  obtain âŸ¨a, haâŸ© := h0\n  have h0 : (_ : ğ•œ) â‰  0 := Nat.cast_ne_zero.2 h.ne'\n  rw [nsmul_eq_mul, mul_comm, â† div_eq_iff h0, â† a.div_add_mod' n, add_smul, add_div, zsmul_eq_mul, Int.cast_mul,\n    Int.cast_ofNat, mul_assoc, â† mul_div, mul_comm _ p, mul_div_cancel p h0] at ha\n  have han : _ = a % n := Int.toNat_of_nonneg (Int.emod_nonneg _ <| by exact_mod_cast h.ne')\n  have he := _; refine' âŸ¨(a % n).to_nat, _, _, heâŸ©\n  Â· rw [â† Int.ofNat_lt, han]\n    exact Int.emod_lt_of_pos _ (Int.ofNat_lt.2 h)\n  Â· have := (gcd_mul_add_order_of_div_eq p _ h).trans ((congr_arg add_order_of he).trans hk).symm\n    rw [he, Nat.mul_left_eq_self_iff] at this\n    Â· exact this\n    Â· rwa [hk]\n  convert congr_arg coe ha using 1\n  rw [coe_add, â† Int.cast_ofNat, han, zsmul_eq_mul, mul_div_right_comm, eq_comm, add_left_eq_self, â† zsmul_eq_mul,\n    coe_zsmul, coe_period, smul_zero]\n#align add_order_of_eq_pos_iff add_order_of_eq_pos_iff\n\n",
 "add_order_of_div_of_gcd_eq_one'":
 "theorem add_order_of_div_of_gcd_eq_one' {m : â„¤} {n : â„•} (hn : 0 < n) (h : m.nat_abs.gcd n = 1) :\n    add_order_of (â†‘(â†‘m / â†‘n * p) : add_circle p) = n :=\n  by\n  induction m\n  Â· simp only [Int.ofNat_eq_coe, Int.cast_ofNat, Int.natAbs_ofNat] at hâŠ¢\n    exact add_order_of_div_of_gcd_eq_one hn h\n  Â· simp only [Int.cast_negSucc, neg_div, neg_mul, coe_neg, order_of_neg]\n    exact add_order_of_div_of_gcd_eq_one hn h\n#align add_order_of_div_of_gcd_eq_one' add_order_of_div_of_gcd_eq_one'\n\n",
 "add_order_of_div_of_gcd_eq_one":
 "theorem add_order_of_div_of_gcd_eq_one {m n : â„•} (hn : 0 < n) (h : m.gcd n = 1) :\n    add_order_of (â†‘(â†‘m / â†‘n * p) : add_circle p) = n :=\n  by\n  convert gcd_mul_add_order_of_div_eq p m hn\n  rw [h, one_mul]\n#align add_order_of_div_of_gcd_eq_one add_order_of_div_of_gcd_eq_one\n\n",
 "add_order_of_coe_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„š -/\ntheorem add_order_of_coe_rat {q : exprâ„š} : add_order_of (â†‘(â†‘q * p) : add_circle p) = q.denom :=\n  by\n  have : (â†‘(q.denom : â„¤) : ğ•œ) â‰  0 := by\n    norm_cast\n    exact q.pos.ne.symm\n  rw [â† @Rat.num_den q, Rat.cast_mk_of_ne_zero _ _ this, Int.cast_ofNat, Rat.num_den,\n    add_order_of_div_of_gcd_eq_one' q.pos q.cop]\n  infer_instance\n#align add_order_of_coe_rat add_order_of_coe_rat\n\n"}