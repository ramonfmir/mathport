{"to_Ico_mod_eventually_eq_to_Ioc_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr =·∂†[ ] ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem to_Ico_mod_eventually_eq_to_Ioc_mod : ¬´expr =·∂†[ ] ¬ª (to_Ico_mod a hp) ((nhds) x) (to_Ioc_mod a hp) :=\n  is_open.mem_nhds\n      (by\n        rw [Ico_eq_locus_Ioc_eq_Union_Ioo]\n        exact is_open_Union fun i => is_open_Ioo) <|\n    (mem_Ioo_mod_iff_to_Ico_mod_eq_to_Ioc_mod hp).1 ((mem_Ioo_mod_iff_ne_mod_zmultiples hp).2 hx)\n#align to_Ico_mod_eventually_eq_to_Ioc_mod to_Ico_mod_eventually_eq_to_Ioc_mod\n\n",
 "lift_Ioc_coe_apply":
 "theorem lift_Ioc_coe_apply {f : ùïú ‚Üí B} {x : ùïú} (hx : x ‚àà Ioc a (a + p)) : lift_Ioc p a f ‚Üëx = f x :=\n  by\n  have : (equiv_Ioc p a) x = ‚ü®x, hx‚ü© := by\n    rw [equiv.apply_eq_iff_eq_symm_apply]\n    rfl\n  rw [lift_Ioc, comp_apply, this]\n  rfl\n#align lift_Ioc_coe_apply lift_Ioc_coe_apply\n\n",
 "lift_Ico_zero_continuous":
 "theorem lift_Ico_zero_continuous [topological_space B] {f : ùïú ‚Üí B} (hf : f 0 = f p) (hc : continuous_on f <| Icc 0 p) :\n    continuous (lift_Ico p 0 f) :=\n  lift_Ico_continuous (by rwa [zero_add] : f 0 = f (0 + p)) (by rwa [zero_add])\n#align lift_Ico_zero_continuous lift_Ico_zero_continuous\n\n",
 "lift_Ico_zero_coe_apply":
 "theorem lift_Ico_zero_coe_apply {f : ùïú ‚Üí B} {x : ùïú} (hx : x ‚àà Ico 0 p) : lift_Ico p 0 f ‚Üëx = f x :=\n  lift_Ico_coe_apply (by rwa [zero_add])\n#align lift_Ico_zero_coe_apply lift_Ico_zero_coe_apply\n\n",
 "lift_Ico_eq_lift_Icc":
 "theorem lift_Ico_eq_lift_Icc {f : ùïú ‚Üí B} (h : f a = f (a + p)) :\n    lift_Ico p a f =\n      Quot.lift (restrict (Icc a <| a + p) f)\n          (by\n            rintro _ _ ‚ü®_‚ü©\n            exact h) ‚àò\n        equiv_Icc_quot p a :=\n  rfl\n#align lift_Ico_eq_lift_Icc lift_Ico_eq_lift_Icc\n\n",
 "lift_Ico_continuous":
 "theorem lift_Ico_continuous [topological_space B] {f : ùïú ‚Üí B} (hf : f a = f (a + p))\n    (hc : continuous_on f <| Icc a (a + p)) : continuous (lift_Ico p a f) :=\n  by\n  rw [lift_Ico_eq_lift_Icc hf]\n  refine' continuous.comp _ (homeo_Icc_quot p a).continuous_to_fun\n  exact continuous_coinduced_dom.mpr (continuous_on_iff_continuous_restrict.mp hc)\n#align lift_Ico_continuous lift_Ico_continuous\n\n",
 "lift_Ico_coe_apply":
 "theorem lift_Ico_coe_apply {f : ùïú ‚Üí B} {x : ùïú} (hx : x ‚àà Ico a (a + p)) : lift_Ico p a f ‚Üëx = f x :=\n  by\n  have : (equiv_Ico p a) x = ‚ü®x, hx‚ü© := by\n    rw [equiv.apply_eq_iff_eq_symm_apply]\n    rfl\n  rw [lift_Ico, comp_apply, this]\n  rfl\n#align lift_Ico_coe_apply lift_Ico_coe_apply\n\n",
 "gcd_mul_add_order_of_div_eq":
 "theorem gcd_mul_add_order_of_div_eq {n : ‚Ñï} (m : ‚Ñï) (hn : 0 < n) :\n    m.gcd n * add_order_of (‚Üë(‚Üëm / ‚Üën * p) : add_circle p) = n :=\n  by\n  rw [mul_comm_div, ‚Üê nsmul_eq_mul, coe_nsmul, add_order_of_nsmul'']\n  ¬∑ rw [add_order_of_period_div hn, nat.gcd_comm, Nat.mul_div_cancel']\n    exacts[n.gcd_dvd_left m, hp]\n  ¬∑ rw [‚Üê add_order_of_pos_iff, add_order_of_period_div hn]\n    exacts[hn, hp]\n#align gcd_mul_add_order_of_div_eq gcd_mul_add_order_of_div_eq\n\n",
 "finite_set_of_add_order_eq":
 "theorem finite_set_of_add_order_eq {n : ‚Ñï} (hn : 0 < n) : { u : add_circle p | add_order_of u = n }.finite :=\n  finite_coe_iff.mp <|\n    nat.finite_of_card_ne_zero <| by\n      simpa only [coe_set_of, card_add_order_of_eq_totient p] using (nat.totient_pos hn).ne'\n#align finite_set_of_add_order_eq finite_set_of_add_order_eq\n\n",
 "exists_gcd_eq_one_of_is_of_fin_add_order":
 "theorem exists_gcd_eq_one_of_is_of_fin_add_order {u : add_circle p} (h : is_of_fin_add_order u) :\n    ‚àÉ m : ‚Ñï, m.gcd (add_order_of u) = 1 ‚àß m < add_order_of u ‚àß ‚Üë((m : ùïú) / add_order_of u * p) = u :=\n  let ‚ü®m, hl, hg, he‚ü© := (add_order_of_eq_pos_iff <| add_order_of_pos' h).1 rfl\n  ‚ü®m, hg, hl, he‚ü©\n#align exists_gcd_eq_one_of_is_of_fin_add_order exists_gcd_eq_one_of_is_of_fin_add_order\n\n",
 "equiv_add_circle_symm_apply_mk":
 "@[simp]\ntheorem equiv_add_circle_symm_apply_mk (hp : p ‚â† 0) (hq : q ‚â† 0) (x : ùïú) :\n    (equiv_add_circle p q hp hq).symm (x : ùïú) = (x * (q‚Åª¬π * p) : ùïú) :=\n  rfl\n#align equiv_add_circle_symm_apply_mk equiv_add_circle_symm_apply_mk\n\n",
 "equiv_add_circle_apply_mk":
 "@[simp]\ntheorem equiv_add_circle_apply_mk (hp : p ‚â† 0) (hq : q ‚â† 0) (x : ùïú) :\n    equiv_add_circle p q hp hq (x : ùïú) = (x * (p‚Åª¬π * q) : ùïú) :=\n  rfl\n#align equiv_add_circle_apply_mk equiv_add_circle_apply_mk\n\n",
 "equiv_Icc_quot_comp_mk_eq_to_Ioc_mod":
 "theorem equiv_Icc_quot_comp_mk_eq_to_Ioc_mod :\n    equiv_Icc_quot p a ‚àò quotient.mk' = fun x =>\n      Quot.mk _ ‚ü®to_Ioc_mod a hp.out x, Ioc_subset_Icc_self <| to_Ioc_mod_mem_Ioc a _ x‚ü© :=\n  by\n  rw [equiv_Icc_quot_comp_mk_eq_to_Ico_mod]; funext\n  by_cases mem_Ioo_mod a p x\n  ¬∑ simp_rw [(mem_Ioo_mod_iff_to_Ico_mod_eq_to_Ioc_mod hp.out).1 h]\n  ¬∑ simp_rw [not_imp_comm.1 (mem_Ioo_mod_iff_to_Ico_mod_ne_left hp.out).2 h,\n      not_imp_comm.1 (mem_Ioo_mod_iff_to_Ioc_mod_ne_right hp.out).2 h]\n    exact quot.sound endpoint_ident.mk\n#align equiv_Icc_quot_comp_mk_eq_to_Ioc_mod equiv_Icc_quot_comp_mk_eq_to_Ioc_mod\n\n",
 "equiv_Icc_quot_comp_mk_eq_to_Ico_mod":
 "theorem equiv_Icc_quot_comp_mk_eq_to_Ico_mod :\n    equiv_Icc_quot p a ‚àò quotient.mk' = fun x =>\n      Quot.mk _ ‚ü®to_Ico_mod a hp.out x, Ico_subset_Icc_self <| to_Ico_mod_mem_Ico a _ x‚ü© :=\n  rfl\n#align equiv_Icc_quot_comp_mk_eq_to_Ico_mod equiv_Icc_quot_comp_mk_eq_to_Ico_mod\n\n",
 "continuous_right_to_Ico_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/-\nCopyright (c) 2022 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\ntheorem continuous_right_to_Ico_mod : continuous_within_at (to_Ico_mod a hp) (Ici x) x :=\n  by\n  intro s h\n  rw [filter.mem_map, mem_nhds_within_iff_exists_mem_nhds_inter]\n  haveI : nontrivial ùïú := ‚ü®‚ü®0, p, hp.ne‚ü©‚ü©\n  simp_rw [mem_nhds_iff_exists_Ioo_subset] at h‚ä¢\n  obtain ‚ü®l, u, hxI, hIs‚ü© := h\n  let d := ¬´expr ‚Ä¢ ¬ª (to_Ico_div a hp x) p\n  have hd := to_Ico_mod_mem_Ico a hp x\n  simp_rw [subset_def, mem_inter_iff]\n  refine' ‚ü®_, ‚ü®l + d, min (a + p) u + d, _, fun x => id‚ü©, fun y => _‚ü© <;>\n    simp_rw [‚Üê sub_mem_Ioo_iff_left, mem_Ioo, lt_min_iff]\n  ¬∑ exact ‚ü®hxI.1, hd.2, hxI.2‚ü©\n  ¬∑ rintro ‚ü®h, h'‚ü©\n    apply hIs\n    rw [‚Üê to_Ico_mod_sub_zsmul, (to_Ico_mod_eq_self _).2]\n    exacts[‚ü®h.1, h.2.2‚ü©, ‚ü®hd.1.trans (sub_le_sub_right h' _), h.2.1‚ü©]\n#align continuous_right_to_Ico_mod continuous_right_to_Ico_mod\n\n",
 "continuous_mk'":
 "@[continuity, nolint unused_arguments]\nprotected theorem continuous_mk' : continuous (quotient_add_group.mk' (zmultiples p) : ùïú ‚Üí add_circle p) :=\n  continuous_coinduced_rng\n#align continuous_mk' continuous_mk'\n\n",
 "continuous_left_to_Ioc_mod":
 "theorem continuous_left_to_Ioc_mod : continuous_within_at (to_Ioc_mod a hp) (Iic x) x :=\n  by\n  rw [(funext fun y => eq.trans (by rw [neg_neg]) <| to_Ioc_mod_neg _ _ _ :\n      to_Ioc_mod a hp = (fun x => p - x) ‚àò to_Ico_mod (-a) hp ‚àò has_neg.neg)]\n  exact\n    (continuous_sub_left _).continuous_at.comp_continuous_within_at <|\n      (continuous_right_to_Ico_mod _ _ _).comp continuous_neg.continuous_within_at fun y => neg_le_neg\n#align continuous_left_to_Ioc_mod continuous_left_to_Ioc_mod\n\n",
 "continuous_equiv_Ioc_symm":
 "@[continuity]\ntheorem continuous_equiv_Ioc_symm : continuous (equiv_Ioc p a).symm :=\n  continuous_quotient_mk.comp continuous_subtype_coe\n#align continuous_equiv_Ioc_symm continuous_equiv_Ioc_symm\n\n",
 "continuous_equiv_Ico_symm":
 "@[continuity]\ntheorem continuous_equiv_Ico_symm : continuous (equiv_Ico p a).symm :=\n  continuous_quotient_mk.comp continuous_subtype_coe\n#align continuous_equiv_Ico_symm continuous_equiv_Ico_symm\n\n",
 "continuous_at_to_Ioc_mod":
 "theorem continuous_at_to_Ioc_mod : continuous_at (to_Ioc_mod a hp) x :=\n  let h := to_Ico_mod_eventually_eq_to_Ioc_mod a hp hx\n  continuous_at_iff_continuous_left_right.2 <|\n    ‚ü®continuous_left_to_Ioc_mod a hp x,\n      (continuous_right_to_Ico_mod a hp x).congr_of_eventually_eq (h.symm.filter_mono nhds_within_le_nhds)\n        h.symm.eq_of_nhds‚ü©\n#align continuous_at_to_Ioc_mod continuous_at_to_Ioc_mod\n\n",
 "continuous_at_to_Ico_mod":
 "theorem continuous_at_to_Ico_mod : continuous_at (to_Ico_mod a hp) x :=\n  let h := to_Ico_mod_eventually_eq_to_Ioc_mod a hp hx\n  continuous_at_iff_continuous_left_right.2 <|\n    ‚ü®(continuous_left_to_Ioc_mod a hp x).congr_of_eventually_eq (h.filter_mono nhds_within_le_nhds) h.eq_of_nhds,\n      continuous_right_to_Ico_mod a hp x‚ü©\n#align continuous_at_to_Ico_mod continuous_at_to_Ico_mod\n\n",
 "continuous_at_equiv_Ioc":
 "theorem continuous_at_equiv_Ioc : continuous_at (equiv_Ioc p a) x :=\n  by\n  induction x using quotient_add_group.induction_on'\n  rw [continuous_at, filter.tendsto, quotient_add_group.nhds_eq, filter.map_map]\n  apply continuous_at.cod_restrict; exact continuous_at_to_Ioc_mod a hp.out hx\n#align continuous_at_equiv_Ioc continuous_at_equiv_Ioc\n\n",
 "continuous_at_equiv_Ico":
 "theorem continuous_at_equiv_Ico : continuous_at (equiv_Ico p a) x :=\n  by\n  induction x using quotient_add_group.induction_on'\n  rw [continuous_at, filter.tendsto, quotient_add_group.nhds_eq, filter.map_map]\n  apply continuous_at.cod_restrict; exact continuous_at_to_Ico_mod a hp.out hx\n#align continuous_at_equiv_Ico continuous_at_equiv_Ico\n\n",
 "coe_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\ntheorem coe_zsmul {n : ‚Ñ§} {x : ùïú} : (‚Üë(¬´expr ‚Ä¢ ¬ª n x) : add_circle p) = ¬´expr ‚Ä¢ ¬ª n (x : add_circle p) :=\n  rfl\n#align coe_zsmul coe_zsmul\n\n",
 "coe_sub":
 "theorem coe_sub (x y : ùïú) : (‚Üë(x - y) : add_circle p) = (x : add_circle p) - (y : add_circle p) :=\n  rfl\n#align coe_sub coe_sub\n\n",
 "coe_period":
 "theorem coe_period : (p : add_circle p) = 0 :=\n  (quotient_add_group.eq_zero_iff p).2 <| mem_zmultiples p\n#align coe_period coe_period\n\n",
 "coe_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\ntheorem coe_nsmul {n : ‚Ñï} {x : ùïú} : (‚Üë(¬´expr ‚Ä¢ ¬ª n x) : add_circle p) = ¬´expr ‚Ä¢ ¬ª n (x : add_circle p) :=\n  rfl\n#align coe_nsmul coe_nsmul\n\n",
 "coe_neg":
 "theorem coe_neg {x : ùïú} : (‚Üë(-x) : add_circle p) = -(x : add_circle p) :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_image_Ioc_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n/-- The image of the closed-open interval `[a, a + p)` under the quotient map `ùïú ‚Üí add_circle p` is\nthe entire space. -/\n@[simp]\ntheorem coe_image_Ioc_eq : ¬´expr '' ¬ª (coe : ùïú ‚Üí add_circle p) (Ioc a (a + p)) = univ :=\n  by\n  rw [image_eq_range]\n  exact (equiv_Ioc p a).symm.range_eq_univ\n#align coe_image_Ioc_eq coe_image_Ioc_eq\n\n",
 "coe_image_Ico_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n/-- The image of the closed-open interval `[a, a + p)` under the quotient map `ùïú ‚Üí add_circle p` is\nthe entire space. -/\n@[simp]\ntheorem coe_image_Ico_eq : ¬´expr '' ¬ª (coe : ùïú ‚Üí add_circle p) (Ico a (a + p)) = univ :=\n  by\n  rw [image_eq_range]\n  exact (equiv_Ico p a).symm.range_eq_univ\n#align coe_image_Ico_eq coe_image_Ico_eq\n\n",
 "coe_image_Icc_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n/-- The image of the closed interval `[0, p]` under the quotient map `ùïú ‚Üí add_circle p` is the\nentire space. -/\n@[simp]\ntheorem coe_image_Icc_eq : ¬´expr '' ¬ª (coe : ùïú ‚Üí add_circle p) (Icc a (a + p)) = univ :=\n  eq_top_mono (image_subset _ Ico_subset_Icc_self) <| coe_image_Ico_eq _ _\n#align coe_image_Icc_eq coe_image_Icc_eq\n\n",
 "coe_equiv_Ico_mk_apply":
 "@[simp]\ntheorem coe_equiv_Ico_mk_apply (x : ùïú) : (equiv_Ico p 0 <| quotient_add_group.mk x : ùïú) = Int.fract (x / p) * p :=\n  to_Ico_mod_eq_fract_mul _ x\n#align coe_equiv_Ico_mk_apply coe_equiv_Ico_mk_apply\n\n",
 "coe_eq_zero_of_pos_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\ntheorem coe_eq_zero_of_pos_iff (hp : 0 < p) {x : ùïú} (hx : 0 < x) :\n    (x : add_circle p) = 0 ‚Üî ‚àÉ n : ‚Ñï, ¬´expr ‚Ä¢ ¬ª n p = x :=\n  by\n  rw [coe_eq_zero_iff]\n  constructor <;> rintro ‚ü®n, rfl‚ü©\n  ¬∑ replace hx : 0 < n\n    ¬∑ contrapose! hx\n      simpa only [‚Üê neg_nonneg, ‚Üê zsmul_neg, zsmul_neg'] using zsmul_nonneg hp.le (neg_nonneg.2 hx)\n    exact ‚ü®n.to_nat, by rw [‚Üê coe_nat_zsmul, Int.toNat_of_nonneg hx.le]‚ü©\n  ¬∑ exact ‚ü®(n : ‚Ñ§), by simp‚ü©\n#align coe_eq_zero_of_pos_iff coe_eq_zero_of_pos_iff\n\n",
 "coe_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\ntheorem coe_eq_zero_iff {x : ùïú} : (x : add_circle p) = 0 ‚Üî ‚àÉ n : ‚Ñ§, ¬´expr ‚Ä¢ ¬ª n p = x := by\n  simp [add_subgroup.mem_zmultiples_iff]\n#align coe_eq_zero_iff coe_eq_zero_iff\n\n",
 "coe_eq_coe_iff_of_mem_Ico":
 "theorem coe_eq_coe_iff_of_mem_Ico {x y : ùïú} (hx : x ‚àà Ico a (a + p)) (hy : y ‚àà Ico a (a + p)) :\n    (x : add_circle p) = y ‚Üî x = y := by\n  refine' ‚ü®fun h => _, by tauto‚ü©\n  suffices (‚ü®x, hx‚ü© : Ico a (a + p)) = ‚ü®y, hy‚ü© by exact subtype.mk.inj this\n  apply_fun equiv_Ico p a  at h\n  rw [‚Üê (equiv_Ico p a).right_inv ‚ü®x, hx‚ü©, ‚Üê (equiv_Ico p a).right_inv ‚ü®y, hy‚ü©]\n  exact h\n#align coe_eq_coe_iff_of_mem_Ico coe_eq_coe_iff_of_mem_Ico\n\n",
 "coe_add_period":
 "@[simp]\ntheorem coe_add_period (x : ùïú) : ((x + p : ùïú) : add_circle p) = x := by\n  rw [coe_add, ‚Üê eq_sub_iff_add_eq', sub_self, coe_period]\n#align coe_add_period coe_add_period\n\n",
 "coe_add":
 "theorem coe_add (x y : ùïú) : (‚Üë(x + y) : add_circle p) = (x : add_circle p) + (y : add_circle p) :=\n  rfl\n#align coe_add coe_add\n\n",
 "card_add_order_of_eq_totient":
 "@[simp]\ntheorem card_add_order_of_eq_totient {n : ‚Ñï} : nat.card { u : add_circle p // add_order_of u = n } = n.totient :=\n  by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  ¬∑ simp only [nat.totient_zero, add_order_of_eq_zero_iff]\n    rcases em (‚àÉ u : add_circle p, ¬¨is_of_fin_add_order u) with (‚ü®u, hu‚ü© | h)\n    ¬∑ have : Infinite { u : add_circle p // ¬¨is_of_fin_add_order u } :=\n        by\n        erw [infinite_coe_iff]\n        exact infinite_not_is_of_fin_add_order hu\n      exact nat.card_eq_zero_of_infinite\n    ¬∑ have : is_empty { u : add_circle p // ¬¨is_of_fin_add_order u } := by simpa using h\n      exact nat.card_of_is_empty\n  ¬∑ rw [‚Üê coe_set_of, nat.card_congr (set_add_order_of_equiv p hn), n.totient_eq_card_lt_and_coprime]\n    simp only [nat.gcd_comm]\n#align card_add_order_of_eq_totient card_add_order_of_eq_totient\n\n",
 "add_order_of_period_div":
 "theorem add_order_of_period_div {n : ‚Ñï} (h : 0 < n) : add_order_of ((p / n : ùïú) : add_circle p) = n :=\n  by\n  rw [add_order_of_eq_iff h]\n  replace h : 0 < (n : ùïú) := nat.cast_pos.2 h\n  refine' ‚ü®_, fun m hn h0 => _‚ü© <;> simp only [ne, ‚Üê coe_nsmul, nsmul_eq_mul]\n  ¬∑ rw [mul_div_cancel' _ h.ne', coe_period]\n  rw [coe_eq_zero_of_pos_iff p hp.out (mul_pos (nat.cast_pos.2 h0) <| div_pos hp.out h)]\n  rintro ‚ü®k, hk‚ü©\n  rw [mul_div, eq_div_iff h.ne', nsmul_eq_mul, mul_right_comm, ‚Üê nat.cast_mul, (mul_left_injective‚ÇÄ hp.out.ne').eq_iff,\n    Nat.cast_inj, mul_comm] at hk\n  exact (nat.le_of_dvd h0 ‚ü®_, hk.symm‚ü©).not_lt hn\n#align add_order_of_period_div add_order_of_period_div\n\n",
 "add_order_of_eq_pos_iff":
 "theorem add_order_of_eq_pos_iff {u : add_circle p} {n : ‚Ñï} (h : 0 < n) :\n    add_order_of u = n ‚Üî ‚àÉ m < n, m.gcd n = 1 ‚àß ‚Üë(‚Üëm / ‚Üën * p) = u :=\n  by\n  refine' ‚ü®quotient_add_group.induction_on' u fun k hk => _, _‚ü©; swap\n  ¬∑ rintro ‚ü®m, h‚ÇÄ, h‚ÇÅ, rfl‚ü©\n    exact add_order_of_div_of_gcd_eq_one h h‚ÇÅ\n  have h0 := add_order_of_nsmul_eq_zero (k : add_circle p)\n  rw [hk, ‚Üê coe_nsmul, coe_eq_zero_iff] at h0\n  obtain ‚ü®a, ha‚ü© := h0\n  have h0 : (_ : ùïú) ‚â† 0 := Nat.cast_ne_zero.2 h.ne'\n  rw [nsmul_eq_mul, mul_comm, ‚Üê div_eq_iff h0, ‚Üê a.div_add_mod' n, add_smul, add_div, zsmul_eq_mul, Int.cast_mul,\n    Int.cast_ofNat, mul_assoc, ‚Üê mul_div, mul_comm _ p, mul_div_cancel p h0] at ha\n  have han : _ = a % n := Int.toNat_of_nonneg (Int.emod_nonneg _ <| by exact_mod_cast h.ne')\n  have he := _; refine' ‚ü®(a % n).to_nat, _, _, he‚ü©\n  ¬∑ rw [‚Üê Int.ofNat_lt, han]\n    exact Int.emod_lt_of_pos _ (Int.ofNat_lt.2 h)\n  ¬∑ have := (gcd_mul_add_order_of_div_eq p _ h).trans ((congr_arg add_order_of he).trans hk).symm\n    rw [he, Nat.mul_left_eq_self_iff] at this\n    ¬∑ exact this\n    ¬∑ rwa [hk]\n  convert congr_arg coe ha using 1\n  rw [coe_add, ‚Üê Int.cast_ofNat, han, zsmul_eq_mul, mul_div_right_comm, eq_comm, add_left_eq_self, ‚Üê zsmul_eq_mul,\n    coe_zsmul, coe_period, smul_zero]\n#align add_order_of_eq_pos_iff add_order_of_eq_pos_iff\n\n",
 "add_order_of_div_of_gcd_eq_one'":
 "theorem add_order_of_div_of_gcd_eq_one' {m : ‚Ñ§} {n : ‚Ñï} (hn : 0 < n) (h : m.nat_abs.gcd n = 1) :\n    add_order_of (‚Üë(‚Üëm / ‚Üën * p) : add_circle p) = n :=\n  by\n  induction m\n  ¬∑ simp only [Int.ofNat_eq_coe, Int.cast_ofNat, Int.natAbs_ofNat] at h‚ä¢\n    exact add_order_of_div_of_gcd_eq_one hn h\n  ¬∑ simp only [Int.cast_negSucc, neg_div, neg_mul, coe_neg, order_of_neg]\n    exact add_order_of_div_of_gcd_eq_one hn h\n#align add_order_of_div_of_gcd_eq_one' add_order_of_div_of_gcd_eq_one'\n\n",
 "add_order_of_div_of_gcd_eq_one":
 "theorem add_order_of_div_of_gcd_eq_one {m n : ‚Ñï} (hn : 0 < n) (h : m.gcd n = 1) :\n    add_order_of (‚Üë(‚Üëm / ‚Üën * p) : add_circle p) = n :=\n  by\n  convert gcd_mul_add_order_of_div_eq p m hn\n  rw [h, one_mul]\n#align add_order_of_div_of_gcd_eq_one add_order_of_div_of_gcd_eq_one\n\n",
 "add_order_of_coe_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñö -/\ntheorem add_order_of_coe_rat {q : expr‚Ñö} : add_order_of (‚Üë(‚Üëq * p) : add_circle p) = q.denom :=\n  by\n  have : (‚Üë(q.denom : ‚Ñ§) : ùïú) ‚â† 0 := by\n    norm_cast\n    exact q.pos.ne.symm\n  rw [‚Üê @Rat.num_den q, Rat.cast_mk_of_ne_zero _ _ this, Int.cast_ofNat, Rat.num_den,\n    add_order_of_div_of_gcd_eq_one' q.pos q.cop]\n  infer_instance\n#align add_order_of_coe_rat add_order_of_coe_rat\n\n"}