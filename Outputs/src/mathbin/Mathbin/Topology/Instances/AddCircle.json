{"to_Ico_mod_eventually_eq_to_Ioc_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr =·∂†[ ] ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem to_Ico_mod_eventually_eq_to_Ioc_mod : ¬´expr =·∂†[ ] ¬ª (to_Ico_mod hp a) ((nhds) x) (to_Ioc_mod hp a) :=\n  IsOpen.mem_nhds\n      (by\n        rw [Ico_eq_locus_Ioc_eq_Union_Ioo]\n        exact isOpen_union·µ¢ fun i => isOpen_Ioo) <|\n    (add_comm_group.not_modeq_iff_to_Ico_mod_eq_to_Ioc_mod hp).1 <|\n      (AddCommGroup.not_modEq_iff_ne_mod_zmultiples hp).2 hx\n#align to_Ico_mod_eventually_eq_to_Ioc_mod to_Ico_mod_eventually_eq_to_Ioc_mod\n\n",
 "lift_Ioc_coe_apply":
 "theorem lift_Ioc_coe_apply {f : ùïú ‚Üí B} {x : ùïú} (hx : x ‚àà Ioc a (a + p)) : lift_Ioc p a f ‚Üëx = f x :=\n  by\n  have : (equiv_Ioc p a) x = ‚ü®x, hx‚ü© := by\n    rw [Equiv.apply_eq_iff_eq_symm_apply]\n    rfl\n  rw [lift_Ioc, comp_apply, this]\n  rfl\n#align lift_Ioc_coe_apply lift_Ioc_coe_apply\n\n",
 "lift_Ico_zero_continuous":
 "theorem lift_Ico_zero_continuous [TopologicalSpace B] {f : ùïú ‚Üí B} (hf : f 0 = f p) (hc : ContinuousOn f <| Icc 0 p) :\n    Continuous (lift_Ico p 0 f) :=\n  lift_Ico_continuous (by rwa [zero_add] : f 0 = f (0 + p)) (by rwa [zero_add])\n#align lift_Ico_zero_continuous lift_Ico_zero_continuous\n\n",
 "lift_Ico_zero_coe_apply":
 "theorem lift_Ico_zero_coe_apply {f : ùïú ‚Üí B} {x : ùïú} (hx : x ‚àà Ico 0 p) : lift_Ico p 0 f ‚Üëx = f x :=\n  lift_Ico_coe_apply (by rwa [zero_add])\n#align lift_Ico_zero_coe_apply lift_Ico_zero_coe_apply\n\n",
 "lift_Ico_eq_lift_Icc":
 "theorem lift_Ico_eq_lift_Icc {f : ùïú ‚Üí B} (h : f a = f (a + p)) :\n    lift_Ico p a f =\n      Quot.lift (restrict (Icc a <| a + p) f)\n          (by\n            rintro _ _ ‚ü®_‚ü©\n            exact h) ‚àò\n        equiv_Icc_quot p a :=\n  rfl\n#align lift_Ico_eq_lift_Icc lift_Ico_eq_lift_Icc\n\n",
 "lift_Ico_continuous":
 "theorem lift_Ico_continuous [TopologicalSpace B] {f : ùïú ‚Üí B} (hf : f a = f (a + p))\n    (hc : ContinuousOn f <| Icc a (a + p)) : Continuous (lift_Ico p a f) :=\n  by\n  rw [lift_Ico_eq_lift_Icc hf]\n  refine' Continuous.comp _ (homeo_Icc_quot p a).continuous_to_fun\n  exact continuous_coinduced_dom.mpr (continuous_on_iff_continuous_restrict.mp hc)\n#align lift_Ico_continuous lift_Ico_continuous\n\n",
 "lift_Ico_coe_apply":
 "theorem lift_Ico_coe_apply {f : ùïú ‚Üí B} {x : ùïú} (hx : x ‚àà Ico a (a + p)) : lift_Ico p a f ‚Üëx = f x :=\n  by\n  have : (equiv_Ico p a) x = ‚ü®x, hx‚ü© := by\n    rw [Equiv.apply_eq_iff_eq_symm_apply]\n    rfl\n  rw [lift_Ico, comp_apply, this]\n  rfl\n#align lift_Ico_coe_apply lift_Ico_coe_apply\n\n",
 "gcd_mul_add_order_of_div_eq":
 "theorem gcd_mul_add_order_of_div_eq {n : ‚Ñï} (m : ‚Ñï) (hn : 0 < n) :\n    m.gcd n * addOrderOf (‚Üë(‚Üëm / ‚Üën * p) : add_circle p) = n :=\n  by\n  rw [mul_comm_div, ‚Üê nsmul_eq_mul, coe_nsmul, addOrderOf_nsmul'']\n  ¬∑ rw [add_order_of_period_div hn, Nat.gcd_comm, Nat.mul_div_cancel']\n    exacts[n.gcd_dvd_left m, hp]\n  ¬∑ rw [‚Üê addOrderOf_pos_iff, add_order_of_period_div hn]\n    exacts[hn, hp]\n#align gcd_mul_add_order_of_div_eq gcd_mul_add_order_of_div_eq\n\n",
 "finite_set_of_add_order_eq":
 "theorem finite_set_of_add_order_eq {n : ‚Ñï} (hn : 0 < n) : { u : add_circle p | addOrderOf u = n }.finite :=\n  finite_coe_iff.mp <|\n    Nat.finite_of_card_ne_zero <| by\n      simpa only [coe_set_of, card_add_order_of_eq_totient p] using (Nat.totient_pos hn).ne'\n#align finite_set_of_add_order_eq finite_set_of_add_order_eq\n\n",
 "exists_gcd_eq_one_of_is_of_fin_add_order":
 "theorem exists_gcd_eq_one_of_is_of_fin_add_order {u : add_circle p} (h : IsOfFinAddOrder u) :\n    ‚àÉ m : ‚Ñï, m.gcd (addOrderOf u) = 1 ‚àß m < addOrderOf u ‚àß ‚Üë((m : ùïú) / addOrderOf u * p) = u :=\n  let ‚ü®m, hl, hg, he‚ü© := (add_order_of_eq_pos_iff <| addOrderOf_pos' h).1 rfl\n  ‚ü®m, hg, hl, he‚ü©\n#align exists_gcd_eq_one_of_is_of_fin_add_order exists_gcd_eq_one_of_is_of_fin_add_order\n\n",
 "equiv_add_circle_symm_apply_mk":
 "@[simp]\ntheorem equiv_add_circle_symm_apply_mk (hp : p ‚â† 0) (hq : q ‚â† 0) (x : ùïú) :\n    (equiv_add_circle p q hp hq).symm (x : ùïú) = (x * (q‚Åª¬π * p) : ùïú) :=\n  rfl\n#align equiv_add_circle_symm_apply_mk equiv_add_circle_symm_apply_mk\n\n",
 "equiv_add_circle_apply_mk":
 "@[simp]\ntheorem equiv_add_circle_apply_mk (hp : p ‚â† 0) (hq : q ‚â† 0) (x : ùïú) :\n    equiv_add_circle p q hp hq (x : ùïú) = (x * (p‚Åª¬π * q) : ùïú) :=\n  rfl\n#align equiv_add_circle_apply_mk equiv_add_circle_apply_mk\n\n",
 "equiv_Icc_quot_comp_mk_eq_to_Ioc_mod":
 "theorem equiv_Icc_quot_comp_mk_eq_to_Ioc_mod :\n    equiv_Icc_quot p a ‚àò Quotient.mk'' = fun x =>\n      Quot.mk _ ‚ü®to_Ioc_mod hp.out a x, Ioc_subset_Icc_self <| to_Ioc_mod_mem_Ioc _ _ x‚ü© :=\n  by\n  rw [equiv_Icc_quot_comp_mk_eq_to_Ico_mod]; funext\n  by_cases AddCommGroup.ModEq p a x\n  ¬∑ simp_rw [(add_comm_group.modeq_iff_to_Ico_mod_eq_left hp.out).1 h,\n      (add_comm_group.modeq_iff_to_Ioc_mod_eq_right hp.out).1 h]\n    exact quot.sound endpoint_ident.mk\n  ¬∑ simp_rw [(add_comm_group.not_modeq_iff_to_Ico_mod_eq_to_Ioc_mod hp.out).1 h]\n#align equiv_Icc_quot_comp_mk_eq_to_Ioc_mod equiv_Icc_quot_comp_mk_eq_to_Ioc_mod\n\n",
 "equiv_Icc_quot_comp_mk_eq_to_Ico_mod":
 "theorem equiv_Icc_quot_comp_mk_eq_to_Ico_mod :\n    equiv_Icc_quot p a ‚àò Quotient.mk'' = fun x =>\n      Quot.mk _ ‚ü®to_Ico_mod hp.out a x, Ico_subset_Icc_self <| to_Ico_mod_mem_Ico _ _ x‚ü© :=\n  rfl\n#align equiv_Icc_quot_comp_mk_eq_to_Ico_mod equiv_Icc_quot_comp_mk_eq_to_Ico_mod\n\n",
 "continuous_right_to_Ico_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/-\nCopyright (c) 2022 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\ntheorem continuous_right_to_Ico_mod : ContinuousWithinAt (to_Ico_mod hp a) (Ici x) x :=\n  by\n  intro s h\n  rw [Filter.mem_map, mem_nhdsWithin_iff_exists_mem_nhds_inter]\n  haveI : Nontrivial ùïú := ‚ü®‚ü®0, p, hp.ne‚ü©‚ü©\n  simp_rw [mem_nhds_iff_exists_Ioo_subset] at h‚ä¢\n  obtain ‚ü®l, u, hxI, hIs‚ü© := h\n  let d := ¬´expr ‚Ä¢ ¬ª (to_Ico_div hp a x) p\n  have hd := to_Ico_mod_mem_Ico hp a x\n  simp_rw [subset_def, mem_inter_iff]\n  refine' ‚ü®_, ‚ü®l + d, min (a + p) u + d, _, fun x => id‚ü©, fun y => _‚ü© <;>\n    simp_rw [‚Üê sub_mem_Ioo_iff_left, mem_Ioo, lt_min_iff]\n  ¬∑ exact ‚ü®hxI.1, hd.2, hxI.2‚ü©\n  ¬∑ rintro ‚ü®h, h'‚ü©\n    apply hIs\n    rw [‚Üê to_Ico_mod_sub_zsmul, (to_Ico_mod_eq_self _).2]\n    exacts[‚ü®h.1, h.2.2‚ü©, ‚ü®hd.1.trans (sub_le_sub_right h' _), h.2.1‚ü©]\n#align continuous_right_to_Ico_mod continuous_right_to_Ico_mod\n\n",
 "continuous_mk'":
 "@[continuity, nolint unused_arguments]\nprotected theorem continuous_mk' : Continuous (QuotientAddGroup.mk' (zmultiples p) : ùïú ‚Üí add_circle p) :=\n  continuous_coinduced_rng\n#align continuous_mk' continuous_mk'\n\n",
 "continuous_left_to_Ioc_mod":
 "theorem continuous_left_to_Ioc_mod : ContinuousWithinAt (to_Ioc_mod hp a) (Iic x) x :=\n  by\n  rw [(funext fun y => Eq.trans (by rw [neg_neg]) <| to_Ioc_mod_neg _ _ _ :\n      to_Ioc_mod hp a = (fun x => p - x) ‚àò to_Ico_mod hp (-a) ‚àò has_neg.neg)]\n  exact\n    (continuous_sub_left _).continuous_at.comp_continuous_within_at <|\n      (continuous_right_to_Ico_mod _ _ _).comp continuous_neg.continuous_within_at fun y => neg_le_neg\n#align continuous_left_to_Ioc_mod continuous_left_to_Ioc_mod\n\n",
 "continuous_equiv_Ioc_symm":
 "@[continuity]\ntheorem continuous_equiv_Ioc_symm : Continuous (equiv_Ioc p a).symm :=\n  continuous_quotient_mk'.comp continuous_subtype_val\n#align continuous_equiv_Ioc_symm continuous_equiv_Ioc_symm\n\n",
 "continuous_equiv_Ico_symm":
 "@[continuity]\ntheorem continuous_equiv_Ico_symm : Continuous (equiv_Ico p a).symm :=\n  continuous_quotient_mk'.comp continuous_subtype_val\n#align continuous_equiv_Ico_symm continuous_equiv_Ico_symm\n\n",
 "continuous_at_to_Ioc_mod":
 "theorem continuous_at_to_Ioc_mod : ContinuousAt (to_Ioc_mod hp a) x :=\n  let h := to_Ico_mod_eventually_eq_to_Ioc_mod hp a hx\n  continuousAt_iff_continuous_left_right.2 <|\n    ‚ü®continuous_left_to_Ioc_mod hp a x,\n      (continuous_right_to_Ico_mod hp a x).congr_of_eventually_eq (h.symm.filter_mono nhdsWithin_le_nhds)\n        h.symm.eq_of_nhds‚ü©\n#align continuous_at_to_Ioc_mod continuous_at_to_Ioc_mod\n\n",
 "continuous_at_to_Ico_mod":
 "theorem continuous_at_to_Ico_mod : ContinuousAt (to_Ico_mod hp a) x :=\n  let h := to_Ico_mod_eventually_eq_to_Ioc_mod hp a hx\n  continuousAt_iff_continuous_left_right.2 <|\n    ‚ü®(continuous_left_to_Ioc_mod hp a x).congr_of_eventually_eq (h.filter_mono nhdsWithin_le_nhds) h.eq_of_nhds,\n      continuous_right_to_Ico_mod hp a x‚ü©\n#align continuous_at_to_Ico_mod continuous_at_to_Ico_mod\n\n",
 "continuous_at_equiv_Ioc":
 "theorem continuous_at_equiv_Ioc : ContinuousAt (equiv_Ioc p a) x :=\n  by\n  induction x using QuotientAddGroup.induction_on'\n  rw [ContinuousAt, Filter.Tendsto, QuotientAddGroup.nhds_eq, Filter.map_map]\n  exact (continuous_at_to_Ioc_mod hp.out a hx).cod_restrict _\n#align continuous_at_equiv_Ioc continuous_at_equiv_Ioc\n\n",
 "continuous_at_equiv_Ico":
 "theorem continuous_at_equiv_Ico : ContinuousAt (equiv_Ico p a) x :=\n  by\n  induction x using QuotientAddGroup.induction_on'\n  rw [ContinuousAt, Filter.Tendsto, QuotientAddGroup.nhds_eq, Filter.map_map]\n  exact (continuous_at_to_Ico_mod hp.out a hx).cod_restrict _\n#align continuous_at_equiv_Ico continuous_at_equiv_Ico\n\n",
 "coe_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\ntheorem coe_zsmul {n : ‚Ñ§} {x : ùïú} : (‚Üë(¬´expr ‚Ä¢ ¬ª n x) : add_circle p) = ¬´expr ‚Ä¢ ¬ª n (x : add_circle p) :=\n  rfl\n#align coe_zsmul coe_zsmul\n\n",
 "coe_sub":
 "theorem coe_sub (x y : ùïú) : (‚Üë(x - y) : add_circle p) = (x : add_circle p) - (y : add_circle p) :=\n  rfl\n#align coe_sub coe_sub\n\n",
 "coe_period":
 "theorem coe_period : (p : add_circle p) = 0 :=\n  (QuotientAddGroup.eq_zero_iff p).2 <| mem_zmultiples p\n#align coe_period coe_period\n\n",
 "coe_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\ntheorem coe_nsmul {n : ‚Ñï} {x : ùïú} : (‚Üë(¬´expr ‚Ä¢ ¬ª n x) : add_circle p) = ¬´expr ‚Ä¢ ¬ª n (x : add_circle p) :=\n  rfl\n#align coe_nsmul coe_nsmul\n\n",
 "coe_neg":
 "theorem coe_neg {x : ùïú} : (‚Üë(-x) : add_circle p) = -(x : add_circle p) :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_image_Ioc_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n/-- The image of the closed-open interval `[a, a + p)` under the quotient map `ùïú ‚Üí add_circle p` is\nthe entire space. -/\n@[simp]\ntheorem coe_image_Ioc_eq : ¬´expr '' ¬ª (coe : ùïú ‚Üí add_circle p) (Ioc a (a + p)) = univ :=\n  by\n  rw [image_eq_range]\n  exact (equiv_Ioc p a).symm.range_eq_univ\n#align coe_image_Ioc_eq coe_image_Ioc_eq\n\n",
 "coe_image_Ico_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n/-- The image of the closed-open interval `[a, a + p)` under the quotient map `ùïú ‚Üí add_circle p` is\nthe entire space. -/\n@[simp]\ntheorem coe_image_Ico_eq : ¬´expr '' ¬ª (coe : ùïú ‚Üí add_circle p) (Ico a (a + p)) = univ :=\n  by\n  rw [image_eq_range]\n  exact (equiv_Ico p a).symm.range_eq_univ\n#align coe_image_Ico_eq coe_image_Ico_eq\n\n",
 "coe_image_Icc_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n/-- The image of the closed interval `[0, p]` under the quotient map `ùïú ‚Üí add_circle p` is the\nentire space. -/\n@[simp]\ntheorem coe_image_Icc_eq : ¬´expr '' ¬ª (coe : ùïú ‚Üí add_circle p) (Icc a (a + p)) = univ :=\n  eq_top_mono (image_subset _ Ico_subset_Icc_self) <| coe_image_Ico_eq _ _\n#align coe_image_Icc_eq coe_image_Icc_eq\n\n",
 "coe_equiv_Ico_mk_apply":
 "@[simp]\ntheorem coe_equiv_Ico_mk_apply (x : ùïú) : (equiv_Ico p 0 <| QuotientAddGroup.mk x : ùïú) = Int.fract (x / p) * p :=\n  to_Ico_mod_eq_fract_mul _ x\n#align coe_equiv_Ico_mk_apply coe_equiv_Ico_mk_apply\n\n",
 "coe_eq_zero_of_pos_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\ntheorem coe_eq_zero_of_pos_iff (hp : 0 < p) {x : ùïú} (hx : 0 < x) :\n    (x : add_circle p) = 0 ‚Üî ‚àÉ n : ‚Ñï, ¬´expr ‚Ä¢ ¬ª n p = x :=\n  by\n  rw [coe_eq_zero_iff]\n  constructor <;> rintro ‚ü®n, rfl‚ü©\n  ¬∑ replace hx : 0 < n\n    ¬∑ contrapose! hx\n      simpa only [‚Üê neg_nonneg, ‚Üê zsmul_neg, zsmul_neg'] using zsmul_nonneg hp.le (neg_nonneg.2 hx)\n    exact ‚ü®n.to_nat, by rw [‚Üê coe_nat_zsmul, Int.toNat_of_nonneg hx.le]‚ü©\n  ¬∑ exact ‚ü®(n : ‚Ñ§), by simp‚ü©\n#align coe_eq_zero_of_pos_iff coe_eq_zero_of_pos_iff\n\n",
 "coe_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Ä¢ ¬ª -/\ntheorem coe_eq_zero_iff {x : ùïú} : (x : add_circle p) = 0 ‚Üî ‚àÉ n : ‚Ñ§, ¬´expr ‚Ä¢ ¬ª n p = x := by\n  simp [AddSubgroup.mem_zmultiples_iff]\n#align coe_eq_zero_iff coe_eq_zero_iff\n\n",
 "coe_eq_coe_iff_of_mem_Ico":
 "theorem coe_eq_coe_iff_of_mem_Ico {x y : ùïú} (hx : x ‚àà Ico a (a + p)) (hy : y ‚àà Ico a (a + p)) :\n    (x : add_circle p) = y ‚Üî x = y := by\n  refine' ‚ü®fun h => _, by tauto‚ü©\n  suffices (‚ü®x, hx‚ü© : Ico a (a + p)) = ‚ü®y, hy‚ü© by exact subtype.mk.inj this\n  apply_fun equiv_Ico p a  at h\n  rw [‚Üê (equiv_Ico p a).right_inv ‚ü®x, hx‚ü©, ‚Üê (equiv_Ico p a).right_inv ‚ü®y, hy‚ü©]\n  exact h\n#align coe_eq_coe_iff_of_mem_Ico coe_eq_coe_iff_of_mem_Ico\n\n",
 "coe_add_period":
 "@[simp]\ntheorem coe_add_period (x : ùïú) : ((x + p : ùïú) : add_circle p) = x := by\n  rw [coe_add, ‚Üê eq_sub_iff_add_eq', sub_self, coe_period]\n#align coe_add_period coe_add_period\n\n",
 "coe_add":
 "theorem coe_add (x y : ùïú) : (‚Üë(x + y) : add_circle p) = (x : add_circle p) + (y : add_circle p) :=\n  rfl\n#align coe_add coe_add\n\n",
 "card_add_order_of_eq_totient":
 "@[simp]\ntheorem card_add_order_of_eq_totient {n : ‚Ñï} : Nat.card { u : add_circle p // addOrderOf u = n } = n.totient :=\n  by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  ¬∑ simp only [Nat.totient_zero, addOrderOf_eq_zero_iff]\n    rcases em (‚àÉ u : add_circle p, ¬¨IsOfFinAddOrder u) with (‚ü®u, hu‚ü© | h)\n    ¬∑ have : Infinite { u : add_circle p // ¬¨IsOfFinAddOrder u } :=\n        by\n        erw [infinite_coe_iff]\n        exact infinite_not_isOfFinAddOrder hu\n      exact Nat.card_eq_zero_of_infinite\n    ¬∑ have : IsEmpty { u : add_circle p // ¬¨IsOfFinAddOrder u } := by simpa using h\n      exact Nat.card_of_isEmpty\n  ¬∑ rw [‚Üê coe_set_of, Nat.card_congr (set_add_order_of_equiv p hn), n.totient_eq_card_lt_and_coprime]\n    simp only [Nat.gcd_comm]\n#align card_add_order_of_eq_totient card_add_order_of_eq_totient\n\n",
 "add_order_of_period_div":
 "theorem add_order_of_period_div {n : ‚Ñï} (h : 0 < n) : addOrderOf ((p / n : ùïú) : add_circle p) = n :=\n  by\n  rw [addOrderOf_eq_iff h]\n  replace h : 0 < (n : ùïú) := Nat.cast_pos.2 h\n  refine' ‚ü®_, fun m hn h0 => _‚ü© <;> simp only [ne, ‚Üê coe_nsmul, nsmul_eq_mul]\n  ¬∑ rw [mul_div_cancel' _ h.ne', coe_period]\n  rw [coe_eq_zero_of_pos_iff p hp.out (mul_pos (Nat.cast_pos.2 h0) <| div_pos hp.out h)]\n  rintro ‚ü®k, hk‚ü©\n  rw [mul_div, eq_div_iff h.ne', nsmul_eq_mul, mul_right_comm, ‚Üê Nat.cast_mul, (mul_left_injective‚ÇÄ hp.out.ne').eq_iff,\n    Nat.cast_inj, mul_comm] at hk\n  exact (nat.le_of_dvd h0 ‚ü®_, hk.symm‚ü©).not_lt hn\n#align add_order_of_period_div add_order_of_period_div\n\n",
 "add_order_of_eq_pos_iff":
 "theorem add_order_of_eq_pos_iff {u : add_circle p} {n : ‚Ñï} (h : 0 < n) :\n    addOrderOf u = n ‚Üî ‚àÉ m < n, m.gcd n = 1 ‚àß ‚Üë(‚Üëm / ‚Üën * p) = u :=\n  by\n  refine' ‚ü®QuotientAddGroup.induction_on' u fun k hk => _, _‚ü©; swap\n  ¬∑ rintro ‚ü®m, h‚ÇÄ, h‚ÇÅ, rfl‚ü©\n    exact add_order_of_div_of_gcd_eq_one h h‚ÇÅ\n  have h0 := addOrderOf_nsmul_eq_zero (k : add_circle p)\n  rw [hk, ‚Üê coe_nsmul, coe_eq_zero_iff] at h0\n  obtain ‚ü®a, ha‚ü© := h0\n  have h0 : (_ : ùïú) ‚â† 0 := Nat.cast_ne_zero.2 h.ne'\n  rw [nsmul_eq_mul, mul_comm, ‚Üê div_eq_iff h0, ‚Üê a.div_add_mod' n, add_smul, add_div, zsmul_eq_mul, Int.cast_mul,\n    Int.cast_ofNat, mul_assoc, ‚Üê mul_div, mul_comm _ p, mul_div_cancel p h0] at ha\n  have han : _ = a % n := Int.toNat_of_nonneg (Int.emod_nonneg _ <| by exact_mod_cast h.ne')\n  have he := _; refine' ‚ü®(a % n).to_nat, _, _, he‚ü©\n  ¬∑ rw [‚Üê Int.ofNat_lt, han]\n    exact Int.emod_lt_of_pos _ (Int.ofNat_lt.2 h)\n  ¬∑ have := (gcd_mul_add_order_of_div_eq p _ h).trans ((congr_arg addOrderOf he).trans hk).symm\n    rw [he, Nat.mul_left_eq_self_iff] at this\n    ¬∑ exact this\n    ¬∑ rwa [hk]\n  convert congr_arg coe ha using 1\n  rw [coe_add, ‚Üê Int.cast_ofNat, han, zsmul_eq_mul, mul_div_right_comm, eq_comm, add_left_eq_self, ‚Üê zsmul_eq_mul,\n    coe_zsmul, coe_period, smul_zero]\n#align add_order_of_eq_pos_iff add_order_of_eq_pos_iff\n\n",
 "add_order_of_div_of_gcd_eq_one'":
 "theorem add_order_of_div_of_gcd_eq_one' {m : ‚Ñ§} {n : ‚Ñï} (hn : 0 < n) (h : m.nat_abs.gcd n = 1) :\n    addOrderOf (‚Üë(‚Üëm / ‚Üën * p) : add_circle p) = n := by\n  induction m\n  ¬∑ simp only [Int.ofNat_eq_coe, Int.cast_ofNat, Int.natAbs_ofNat] at h‚ä¢\n    exact add_order_of_div_of_gcd_eq_one hn h\n  ¬∑ simp only [Int.cast_negSucc, neg_div, neg_mul, coe_neg, addOrderOf_neg]\n    exact add_order_of_div_of_gcd_eq_one hn h\n#align add_order_of_div_of_gcd_eq_one' add_order_of_div_of_gcd_eq_one'\n\n",
 "add_order_of_div_of_gcd_eq_one":
 "theorem add_order_of_div_of_gcd_eq_one {m n : ‚Ñï} (hn : 0 < n) (h : m.gcd n = 1) :\n    addOrderOf (‚Üë(‚Üëm / ‚Üën * p) : add_circle p) = n :=\n  by\n  convert gcd_mul_add_order_of_div_eq p m hn\n  rw [h, one_mul]\n#align add_order_of_div_of_gcd_eq_one add_order_of_div_of_gcd_eq_one\n\n",
 "add_order_of_coe_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñö -/\ntheorem add_order_of_coe_rat {q : expr‚Ñö} : addOrderOf (‚Üë(‚Üëq * p) : add_circle p) = q.denom :=\n  by\n  have : (‚Üë(q.denom : ‚Ñ§) : ùïú) ‚â† 0 := by\n    norm_cast\n    exact q.pos.ne.symm\n  rw [‚Üê @Rat.num_den q, Rat.cast_mk_of_ne_zero _ _ this, Int.cast_ofNat, Rat.num_den,\n    add_order_of_div_of_gcd_eq_one' q.pos q.cop]\n  infer_instance\n#align add_order_of_coe_rat add_order_of_coe_rat\n\n"}