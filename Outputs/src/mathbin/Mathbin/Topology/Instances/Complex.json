{"uniform_continuous_ring_hom_eq_id_or_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Tactic/Mathlib/Misc2.lean:301:22: continuitity! not supported at the moment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Tactic/Mathlib/Misc2.lean:301:22: continuitity! not supported at the moment -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/-- Let `K` a subfield of `ℂ` and let `ψ : K →+* ℂ` a ring homomorphism. Assume that `ψ` is uniform\ncontinuous, then `ψ` is either the inclusion map or the composition of the inclusion map with the\ncomplex conjugation. -/\ntheorem complex.uniform_continuous_ring_hom_eq_id_or_conj (K : Subfield (exprℂ)) {ψ : «expr →+* » K (exprℂ)}\n    (hc : UniformContinuous ψ) : ψ.to_fun = K.subtype ∨ ψ.to_fun = star_ring_end ∘ K.subtype :=\n  by\n  letI : TopologicalDivisionRing (exprℂ) := topological_division_ring.mk\n  letI : TopologicalRing K.topological_closure := subring.topological_ring K.topological_closure.to_subring\n  set ι : K → K.topological_closure := Subfield.inclusion K.le_topological_closure\n  have ui : UniformInducing ι :=\n    ⟨by\n      erw [uniformity_subtype, uniformity_subtype, Filter.comap_comap]\n      congr ⟩\n  let di := ui.dense_inducing _\n  · -- extψ : closure(K) →+* ℂ is the extension of ψ : K →+* ℂ\n    let extψ := DenseInducing.extendRingHom ui di.dense hc\n    haveI := (uniformContinuous_uniformly_extend ui di.dense hc).continuous\n    cases complex.subfield_eq_of_closed (Subfield.isClosed_topologicalClosure K)\n    · left\n      let j := RingEquiv.subfieldCongr h\n      -- ψ₁ is the continuous ring hom `ℝ →+* ℂ` constructed from `j : closure (K) ≃+* ℝ`\n      -- and `extψ : closure (K) →+* ℂ`\n      let ψ₁ := RingHom.comp extψ (RingHom.comp j.symm.to_ring_hom of_real.range_restrict)\n      ext1 x\n      rsuffices ⟨r, hr⟩ : ∃ r : exprℝ, of_real.range_restrict r = j (ι x)\n      · have := RingHom.congr_fun (ring_hom_eq_of_real_of_continuous (by continuity : Continuous ψ₁)) r\n        rw [RingHom.comp_apply, RingHom.comp_apply, hr, RingEquiv.toRingHom_eq_coe] at this\n        convert this using 1\n        · exact (DenseInducing.extend_eq di hc.continuous _).symm\n        · rw [← of_real.coe_range_restrict, hr]\n          rfl\n      obtain ⟨r, hr⟩ := SetLike.coe_mem (j (ι x))\n      exact ⟨r, Subtype.ext hr⟩\n    · -- ψ₁ is the continuous ring hom `ℂ →+* ℂ` constructed from `closure (K) ≃+* ℂ`\n      -- and `extψ : closure (K) →+* ℂ`\n      let ψ₁ :=\n        RingHom.comp extψ\n          (RingHom.comp (RingEquiv.subfieldCongr h).symm.to_ring_hom (@Subfield.topEquiv (exprℂ) _).symm.to_ring_hom)\n      cases' ring_hom_eq_id_or_conj_of_continuous (by continuity : Continuous ψ₁) with h h\n      · left\n        ext1 z\n        convert RingHom.congr_fun h z using 1\n        exact (DenseInducing.extend_eq di hc.continuous z).symm\n      · right\n        ext1 z\n        convert RingHom.congr_fun h z using 1\n        exact (DenseInducing.extend_eq di hc.continuous z).symm\n  · let j : { x // x ∈ closure («expr '' » id { x | (K : Set (exprℂ)) x }) } → (K.topological_closure : Set (exprℂ)) :=\n      fun x =>\n      ⟨x, by\n        convert x.prop\n        simpa only [id.def, Set.image_id'] ⟩\n    convert DenseRange.comp (Function.Surjective.denseRange _)\n        (DenseEmbedding.subtype denseEmbedding_id (K : Set (exprℂ))).dense (by continuity : Continuous j)\n    rintro ⟨y, hy⟩\n    use\n      ⟨y, by\n        convert hy\n        simpa only [id.def, Set.image_id'] ⟩\n    simp only [Subtype.mk_eq_mk, Subtype.coe_mk]\n#align complex.uniform_continuous_ring_hom_eq_id_or_conj complex.uniform_continuous_ring_hom_eq_id_or_conj\n\n",
 "subfield_eq_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2022 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\n/-- The only closed subfields of `ℂ` are `ℝ` and `ℂ`. -/\ntheorem complex.subfield_eq_of_closed {K : Subfield (exprℂ)} (hc : IsClosed (K : Set (exprℂ))) :\n    K = ofReal.field_range ∨ K = «expr⊤» :=\n  by\n  suffices range (coe : exprℝ → exprℂ) ⊆ K\n    by\n    rw [range_subset_iff, ← coe_algebra_map] at this\n    have :=\n      (Subalgebra.isSimpleOrder_of_finrank finrank_real_complex).eq_bot_or_eq_top\n        (subfield.to_intermediate_field K this).to_subalgebra\n    simp_rw [← SetLike.coe_set_eq] at this⊢\n    convert this using 2\n    simpa only [RingHom.coe_fieldRange, Algebra.coe_bot, coe_algebra_map]\n  suffices range (coe : exprℝ → exprℂ) ⊆ closure (Set.range ((coe : exprℝ → exprℂ) ∘ (coe : exprℚ → exprℝ)))\n    by\n    refine' subset_trans this _\n    rw [← IsClosed.closure_eq hc]\n    apply closure_mono\n    rintro _ ⟨_, rfl⟩\n    simp only [Function.comp_apply, of_real_rat_cast, SetLike.mem_coe, SubfieldClass.coe_rat_mem]\n  nth_rw 2 [range_comp]\n  refine' subset_trans _ (image_closure_subset_closure_image continuous_of_real)\n  rw [DenseRange.closure_range rat.dense_embedding_coe_real.dense]\n  simp only [image_univ]\n#align complex.subfield_eq_of_closed complex.subfield_eq_of_closed\n\n"}