{"set_of_top_eq_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp]\ntheorem set_of_top_eq_univ [nontrivial R] : set_of_ideal («expr⊤» : ideal («exprC( , )» X R)) = Set.univ :=\n  Set.univ_subset_iff.mp fun x hx => mem_set_of_ideal.mpr ⟨1, submodule.mem_top, one_ne_zero⟩\n#align set_of_top_eq_univ set_of_top_eq_univ\n\n",
 "set_of_ideal_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem set_of_ideal_open [t2_space R] (I : ideal («exprC( , )» X R)) : is_open (set_of_ideal I) :=\n  by\n  simp only [set_of_ideal, Set.setOf_forall, is_open_compl_iff]\n  exact is_closed_Inter fun f => is_closed_Inter fun hf => is_closed_eq (map_continuous f) continuous_const\n#align set_of_ideal_open set_of_ideal_open\n\n",
 "set_of_ideal_of_set_of_is_open":
 "theorem set_of_ideal_of_set_of_is_open {s : set X} (hs : is_open s) : set_of_ideal (ideal_of_set 𝕜 s) = s :=\n  (set_of_ideal_of_set_eq_interior 𝕜 s).trans hs.interior_eq\n#align set_of_ideal_of_set_of_is_open set_of_ideal_of_set_of_is_open\n\n",
 "set_of_ideal_of_set_eq_interior":
 "@[simp]\ntheorem set_of_ideal_of_set_eq_interior (s : set X) : set_of_ideal (ideal_of_set 𝕜 s) = interior s :=\n  by\n  refine'\n    Set.Subset.antisymm\n      ((set_of_ideal_open (ideal_of_set 𝕜 s)).subset_interior_iff.mpr fun x hx =>\n        let ⟨f, hf, hfx⟩ := mem_set_of_ideal.mp hx\n        set.not_mem_compl_iff.mp (mt (@hf x) hfx))\n      fun x hx => _\n  -- If `x ∉ closure sᶜ`, we must produce `f : C(X, 𝕜)` which is zero on `sᶜ` and `f x ≠ 0`.\n  rw [← compl_compl (interior s), ← closure_compl] at hx\n  simp_rw [mem_set_of_ideal, mem_ideal_of_set]\n  haveI : normal_space X := normal_of_compact_t2\n  /- Apply Urysohn's lemma to get `g : C(X, ℝ)` which is zero on `sᶜ` and `g x ≠ 0`, then compose\n    with the natural embedding `ℝ ↪ 𝕜` to produce the desired `f`. -/\n  obtain ⟨g, hgs, hgx : Set.EqOn g 1 {x}, -⟩ :=\n    exists_continuous_zero_one_of_closed is_closed_closure is_closed_singleton (set.disjoint_singleton_right.mpr hx)\n  exact\n    ⟨⟨fun x => g x, continuous_of_real.comp (map_continuous g)⟩, by\n      simpa only [coe_mk, of_real_eq_zero] using fun x hx => hgs (subset_closure hx), by\n      simpa only [coe_mk, hgx (Set.mem_singleton x), pi.one_apply, is_R_or_C.of_real_one] using one_ne_zero⟩\n#align set_of_ideal_of_set_eq_interior set_of_ideal_of_set_eq_interior\n\n",
 "set_of_ideal_eq_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem set_of_ideal_eq_compl_singleton (I : ideal («exprC( , )» X 𝕜)) [hI : I.is_maximal] :\n    ∃ x : X, set_of_ideal I = «expr ᶜ» {x} :=\n  by\n  have h : (ideal_of_set 𝕜 (set_of_ideal I)).is_maximal :=\n    (ideal_of_set_of_ideal_is_closed (infer_instance : is_closed (I : set («exprC( , )» X 𝕜)))).symm ▸ hI\n  obtain ⟨x, hx⟩ := opens.is_coatom_iff.1 ((ideal_of_set_is_maximal_iff 𝕜 (opens_of_ideal I)).1 h)\n  exact ⟨x, congr_arg coe hx⟩\n#align set_of_ideal_eq_compl_singleton set_of_ideal_eq_compl_singleton\n\n",
 "not_mem_set_of_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem not_mem_set_of_ideal {I : ideal («exprC( , )» X R)} {x : X} :\n    x ∉ set_of_ideal I ↔ ∀ ⦃f : «exprC( , )» X R⦄, f ∈ I → f x = 0 := by\n  rw [← Set.mem_compl_iff, set_of_ideal, compl_compl, Set.mem_setOf]\n#align not_mem_set_of_ideal not_mem_set_of_ideal\n\n",
 "not_mem_ideal_of_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem not_mem_ideal_of_set {s : set X} {f : «exprC( , )» X R} : f ∉ ideal_of_set R s ↔ ∃ x ∈ «expr ᶜ» s, f x ≠ 0 :=\n  by\n  simp_rw [mem_ideal_of_set, exists_prop]\n  push_neg\n#align not_mem_ideal_of_set not_mem_ideal_of_set\n\n",
 "mem_set_of_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem mem_set_of_ideal {I : ideal («exprC( , )» X R)} {x : X} :\n    x ∈ set_of_ideal I ↔ ∃ f ∈ I, (f : «exprC( , )» X R) x ≠ 0 :=\n  by\n  simp_rw [set_of_ideal, Set.mem_compl_iff, Set.mem_setOf, exists_prop]\n  push_neg\n#align mem_set_of_ideal mem_set_of_ideal\n\n",
 "mem_ideal_of_set_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem mem_ideal_of_set_compl_singleton (x : X) (f : «exprC( , )» X R) :\n    f ∈ ideal_of_set R («expr ᶜ» {x} : set X) ↔ f x = 0 := by\n  simp only [mem_ideal_of_set, compl_compl, Set.mem_singleton_iff, forall_eq]\n#align mem_ideal_of_set_compl_singleton mem_ideal_of_set_compl_singleton\n\n",
 "mem_ideal_of_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_ideal_of_set {s : set X} {f : «exprC( , )» X R} :\n    f ∈ ideal_of_set R s ↔ ∀ ⦃x : X⦄, x ∈ «expr ᶜ» s → f x = 0 :=\n  iff.rfl\n#align mem_ideal_of_set mem_ideal_of_set\n\n",
 "ideal_of_set_of_ideal_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem ideal_of_set_of_ideal_is_closed {I : ideal («exprC( , )» X 𝕜)} (hI : is_closed (I : set («exprC( , )» X 𝕜))) :\n    ideal_of_set 𝕜 (set_of_ideal I) = I :=\n  (ideal_of_set_of_ideal_eq_closure I).trans (ideal.ext <| Set.ext_iff.mp hI.closure_eq)\n#align ideal_of_set_of_ideal_is_closed ideal_of_set_of_ideal_is_closed\n\n",
 "ideal_of_set_of_ideal_eq_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp]\ntheorem ideal_of_set_of_ideal_eq_closure (I : ideal («exprC( , )» X 𝕜)) : ideal_of_set 𝕜 (set_of_ideal I) = I.closure :=\n  by\n  /- Since `ideal_of_set 𝕜 (set_of_ideal I)` is closed and contains `I`, it contains `I.closure`.\n    For the reverse inclusion, given `f ∈ ideal_of_set 𝕜 (set_of_ideal I)` and `(ε : ℝ≥0) > 0` it\n    suffices to show that `f` is within `ε` of `I`.-/\n  refine'\n    le_antisymm (fun f hf => metric.mem_closure_iff.mpr fun ε hε => _)\n      ((ideal_of_set_closed 𝕜 <| set_of_ideal I).closure_subset_iff.mpr fun f hf x hx => not_mem_set_of_ideal.mp hx hf)\n  lift ε to nnreal using hε.lt.le\n  replace hε := show (0 : nnreal) < ε from hε\n  simp_rw [dist_nndist]\n  norm_cast\n  -- Let `t := {x : X | ε / 2 ≤ ‖f x‖₊}}` which is closed and disjoint from `set_of_ideal I`.\n  set t := { x : X | ε / 2 ≤ «expr‖ ‖₊» (f x) }\n  have ht : is_closed t := is_closed_le continuous_const (map_continuous f).nnnorm\n  have htI : Disjoint t («expr ᶜ» (set_of_ideal I)) :=\n    by\n    refine' set.subset_compl_iff_disjoint_left.mp fun x hx => _\n    simpa only [t, Set.mem_setOf, Set.mem_compl_iff, not_le] using\n      (nnnorm_eq_zero.mpr (mem_ideal_of_set.mp hf hx)).trans_lt (half_pos hε)\n  /- It suffices to produce `g : C(X, ℝ≥0)` which takes values in `[0,1]` and is constantly `1` on\n    `t` such that when composed with the natural embedding of `ℝ≥0` into `𝕜` lies in the ideal `I`.\n    Indeed, then `‖f - f * ↑g‖ ≤ ‖f * (1 - ↑g)‖ ≤ ⨆ ‖f * (1 - ↑g) x‖`. When `x ∉ t`, `‖f x‖ < ε / 2`\n    and `‖(1 - ↑g) x‖ ≤ 1`, and when `x ∈ t`, `(1 - ↑g) x = 0`, and clearly `f * ↑g ∈ I`. -/\n  suffices\n    ∃ g : «exprC( , )» X (nnreal),\n      (algebra_map_clm (nnreal) 𝕜 : «exprC( , )» (nnreal) 𝕜).comp g ∈ I ∧ (∀ x, g x ≤ 1) ∧ t.eq_on g 1\n    by\n    obtain ⟨g, hgI, hg, hgt⟩ := this\n    refine' ⟨f * (algebra_map_clm (nnreal) 𝕜 : «exprC( , )» (nnreal) 𝕜).comp g, I.mul_mem_left f hgI, _⟩\n    rw [nndist_eq_nnnorm]\n    refine' (nnnorm_lt_iff _ hε).2 fun x => _\n    simp only [coe_sub, coe_mul, pi.sub_apply, pi.mul_apply]\n    by_cases hx : x ∈ t\n    ·\n      simpa only [hgt hx, comp_apply, pi.one_apply, continuous_map.coe_coe, algebra_map_clm_apply, map_one, mul_one,\n        sub_self, nnnorm_zero] using hε\n    · refine' lt_of_le_of_lt _ (half_lt_self hε)\n      have :=\n        calc\n          «expr‖ ‖₊» ((1 - (algebra_map_clm (nnreal) 𝕜 : «exprC( , )» (nnreal) 𝕜).comp g) x : 𝕜) =\n              «expr‖ ‖₊» (1 - algebra_map (nnreal) 𝕜 (g x)) :=\n            by\n            simp only [coe_sub, coe_one, coe_comp, continuous_map.coe_coe, pi.sub_apply, pi.one_apply,\n              Function.comp_apply, algebra_map_clm_apply]\n          _ = «expr‖ ‖₊» (algebra_map (nnreal) 𝕜 (1 - g x)) := by\n            simp only [algebra.algebra_map_eq_smul_one, nnreal.smul_def, nnreal.coe_sub (hg x), sub_smul,\n              nonneg.coe_one, one_smul]\n          _ ≤ 1 := (nnnorm_algebra_map_nnreal 𝕜 (1 - g x)).trans_le tsub_le_self\n          \n      calc\n        «expr‖ ‖₊» (f x - f x * (algebra_map_clm (nnreal) 𝕜 : «exprC( , )» (nnreal) 𝕜).comp g x) =\n            «expr‖ ‖₊» (f x * (1 - (algebra_map_clm (nnreal) 𝕜 : «exprC( , )» (nnreal) 𝕜).comp g) x) :=\n          by simp only [mul_sub, coe_sub, coe_one, pi.sub_apply, pi.one_apply, mul_one]\n        _ ≤ ε / 2 * «expr‖ ‖₊» ((1 - (algebra_map_clm (nnreal) 𝕜 : «exprC( , )» (nnreal) 𝕜).comp g) x) :=\n          (nnnorm_mul_le _ _).trans (mul_le_mul_right' (not_le.mp <| show ¬ε / 2 ≤ «expr‖ ‖₊» (f x) from hx).le _)\n        _ ≤ ε / 2 := by simpa only [mul_one] using mul_le_mul_left' this _\n        \n  /- There is some `g' : C(X, ℝ≥0)` which is strictly positive on `t` such that the composition\n    `↑g` with the natural embedding of `ℝ≥0` into `𝕜` lies in `I`. This follows from compactness of\n    `t` and that we can do it in any neighborhood of a point `x ∈ t`. Indeed, since `x ∈ t`, then\n    `fₓ x ≠ 0` for some `fₓ ∈ I` and so `λ y, ‖(star fₓ * fₓ) y‖₊` is strictly posiive in a\n    neighborhood of `y`. Moreover, `(‖(star fₓ * fₓ) y‖₊ : 𝕜) = (star fₓ * fₓ) y`, so composition of\n    this map with the natural embedding is just `star fₓ * fₓ ∈ I`. -/\n  have :\n    ∃ g' : «exprC( , )» X (nnreal),\n      (algebra_map_clm (nnreal) 𝕜 : «exprC( , )» (nnreal) 𝕜).comp g' ∈ I ∧ ∀ x ∈ t, 0 < g' x :=\n    by\n    refine'\n      @is_compact.induction_on _ _ _ ht.is_compact\n        (fun s =>\n          ∃ g' : «exprC( , )» X (nnreal),\n            (algebra_map_clm (nnreal) 𝕜 : «exprC( , )» (nnreal) 𝕜).comp g' ∈ I ∧ ∀ x ∈ s, 0 < g' x)\n        _ _ _ _\n    · refine' ⟨0, _, fun x hx => false.elim hx⟩\n      convert I.zero_mem\n      ext\n      simp only [coe_zero, pi.zero_apply, continuous_map.coe_coe, continuous_map.coe_comp, map_zero, pi.comp_zero]\n    · rintro s₁ s₂ hs ⟨g, hI, hgt⟩\n      exact ⟨g, hI, fun x hx => hgt x (hs hx)⟩\n    · rintro s₁ s₂ ⟨g₁, hI₁, hgt₁⟩ ⟨g₂, hI₂, hgt₂⟩\n      refine' ⟨g₁ + g₂, _, fun x hx => _⟩\n      · convert I.add_mem hI₁ hI₂\n        ext y\n        simp only [coe_add, pi.add_apply, map_add, coe_comp, Function.comp_apply, continuous_map.coe_coe]\n      · rcases hx with (hx | hx)\n        simpa only [zero_add] using add_lt_add_of_lt_of_le (hgt₁ x hx) zero_le'\n        simpa only [zero_add] using add_lt_add_of_le_of_lt zero_le' (hgt₂ x hx)\n    · intro x hx\n      replace hx := htI.subset_compl_right hx\n      rw [compl_compl, mem_set_of_ideal] at hx\n      obtain ⟨g, hI, hgx⟩ := hx\n      have := (map_continuous g).continuous_at.eventually_ne hgx\n      refine'\n        ⟨{ y : X | g y ≠ 0 } ∩ t, mem_nhds_within_iff_exists_mem_nhds_inter.mpr ⟨_, this, Set.Subset.rfl⟩,\n          ⟨⟨fun x => «expr‖ ‖₊» (g x) ^ 2, (map_continuous g).nnnorm.pow 2⟩, _, fun x hx =>\n            pow_pos (norm_pos_iff.mpr hx.1) 2⟩⟩\n      convert I.mul_mem_left (star g) hI\n      ext\n      simp only [comp_apply, coe_mk, algebra_map_clm_coe, map_pow, coe_mul, coe_star, pi.mul_apply, Pi.star_apply,\n        star_def, continuous_map.coe_coe]\n      simpa only [norm_sq_eq_def', conj_mul_eq_norm_sq_left, of_real_pow]\n  /- Get the function `g'` which is guaranteed to exist above. By the extreme value theorem and\n    compactness of `t`, there is some `0 < c` such that `c ≤ g' x` for all `x ∈ t`. Then by\n    `main_lemma_aux` there is some `g` for which `g * g'` is the desired function. -/\n  obtain ⟨g', hI', hgt'⟩ := this\n  obtain ⟨c, hc, hgc'⟩ : ∃ (c : _)(hc : 0 < c), ∀ y : X, y ∈ t → c ≤ g' y :=\n    t.eq_empty_or_nonempty.elim (fun ht' => ⟨1, zero_lt_one, fun y hy => false.elim (by rwa [ht'] at hy)⟩) fun ht' =>\n      let ⟨x, hx, hx'⟩ := ht.is_compact.exists_forall_le ht' (map_continuous g').continuous_on\n      ⟨g' x, hgt' x hx, hx'⟩\n  obtain ⟨g, hg, hgc⟩ := exists_mul_le_one_eq_on_ge g' hc\n  refine' ⟨g * g', _, hg, hgc.mono hgc'⟩\n  convert I.mul_mem_left ((algebra_map_clm (nnreal) 𝕜 : «exprC( , )» (nnreal) 𝕜).comp g) hI'\n  ext\n  simp only [algebra_map_clm_coe, continuous_map.coe_coe, comp_apply, coe_mul, pi.mul_apply, map_mul]\n#align ideal_of_set_of_ideal_eq_closure ideal_of_set_of_ideal_eq_closure\n\n",
 "ideal_of_set_is_maximal_iff":
 "theorem ideal_of_set_is_maximal_iff (s : opens X) : (ideal_of_set 𝕜 (s : set X)).is_maximal ↔ IsCoatom s :=\n  by\n  rw [ideal.is_maximal_def]\n  refine' (ideal_opens_gi X 𝕜).is_coatom_iff (fun I hI => _) s\n  rw [← ideal.is_maximal_def] at hI\n  skip\n  exact ideal_of_set_of_ideal_is_closed infer_instance\n#align ideal_of_set_is_maximal_iff ideal_of_set_is_maximal_iff\n\n",
 "ideal_of_set_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-\nCopyright (c) 2022 Jireh Loreaux. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jireh Loreaux\n-/\ntheorem ideal_of_set_closed [locally_compact_space X] [t2_space R] (s : set X) :\n    is_closed (ideal_of_set R s : set («exprC( , )» X R)) :=\n  by\n  simp only [ideal_of_set, submodule.coe_set_mk, Set.setOf_forall]\n  exact is_closed_Inter fun x => is_closed_Inter fun hx => is_closed_eq (continuous_eval_const' x) continuous_const\n#align ideal_of_set_closed ideal_of_set_closed\n\n",
 "ideal_of_empty_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ideal_of_empty_eq_bot : ideal_of_set R (∅ : set X) = «expr⊥» :=\n  ideal.ext fun f => by\n    simpa only [mem_ideal_of_set, Set.compl_empty, Set.mem_univ, forall_true_left, ideal.mem_bot,\n      fun_like.ext_iff] using iff.rfl\n#align ideal_of_empty_eq_bot ideal_of_empty_eq_bot\n\n",
 "ideal_of_compl_singleton_is_maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem ideal_of_compl_singleton_is_maximal (x : X) : (ideal_of_set 𝕜 («expr ᶜ» {x} : set X)).is_maximal :=\n  (ideal_of_set_is_maximal_iff 𝕜 (closeds.singleton x).compl).mpr <| opens.is_coatom_iff.mpr ⟨x, rfl⟩\n#align ideal_of_compl_singleton_is_maximal ideal_of_compl_singleton_is_maximal\n\n",
 "ideal_is_maximal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem ideal_is_maximal_iff (I : ideal («exprC( , )» X 𝕜)) [hI : is_closed (I : set («exprC( , )» X 𝕜))] :\n    I.is_maximal ↔ ∃ x : X, ideal_of_set 𝕜 («expr ᶜ» {x}) = I :=\n  by\n  refine'\n    ⟨_, fun h =>\n      let ⟨x, hx⟩ := h\n      hx ▸ ideal_of_compl_singleton_is_maximal 𝕜 x⟩\n  intro hI'\n  obtain ⟨x, hx⟩ := set_of_ideal_eq_compl_singleton I\n  exact\n    ⟨x, by\n      simpa only [ideal_of_set_of_ideal_eq_closure, ideal.closure_eq_of_is_closed] using\n        congr_arg (ideal_of_set 𝕜) hx.symm⟩\n#align ideal_is_maximal_iff ideal_is_maximal_iff\n\n",
 "ideal_gc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem ideal_gc : GaloisConnection (set_of_ideal : ideal («exprC( , )» X R) → set X) (ideal_of_set R) :=\n  by\n  refine' fun I s => ⟨fun h f hf => _, fun h x hx => _⟩\n  · by_contra h'\n    rcases not_mem_ideal_of_set.mp h' with ⟨x, hx, hfx⟩\n    exact hfx (not_mem_set_of_ideal.mp (mt (@h x) hx) hf)\n  · obtain ⟨f, hf, hfx⟩ := mem_set_of_ideal.mp hx\n    by_contra hx'\n    exact not_mem_ideal_of_set.mpr ⟨x, hx', hfx⟩ (h hf)\n#align ideal_gc ideal_gc\n\n",
 "exists_mul_le_one_eq_on_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-- An auxiliary lemma used in the proof of `ideal_of_set_of_ideal_eq_closure` which may be useful\non its own. -/\ntheorem exists_mul_le_one_eq_on_ge (f : «exprC( , )» X (nnreal)) {c : nnreal} (hc : 0 < c) :\n    ∃ g : «exprC( , )» X (nnreal), (∀ x : X, (g * f) x ≤ 1) ∧ { x : X | c ≤ f x }.eq_on (g * f) 1 :=\n  ⟨{  to_fun := («expr ⊔ » f (const X c))⁻¹\n      continuous_to_fun := ((map_continuous f).sup <| map_continuous _).inv₀ fun _ => (hc.trans_le le_sup_right).ne' },\n    fun x => (inv_mul_le_iff (hc.trans_le le_sup_right)).mpr ((mul_one («expr ⊔ » (f x) c)).symm ▸ le_sup_left),\n    fun x hx => by\n    simpa only [coe_const, coe_mk, pi.mul_apply, pi.inv_apply, Pi.sup_apply, function.const_apply, pi.one_apply,\n      sup_eq_left.mpr (set.mem_set_of.mp hx)] using inv_mul_cancel (hc.trans_le hx).ne'⟩\n#align exists_mul_le_one_eq_on_ge exists_mul_le_one_eq_on_ge\n\n",
 "continuous_map_eval_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem continuous_map_eval_bijective : bijective (continuous_map_eval X 𝕜) :=\n  by\n  refine' ⟨fun x y hxy => _, fun φ => _⟩\n  · contrapose! hxy\n    haveI := @normal_of_compact_t2 X _ _ _\n    rcases exists_continuous_zero_one_of_closed (is_closed_singleton : _root_.is_closed {x})\n        (is_closed_singleton : _root_.is_closed {y}) (set.disjoint_singleton.mpr hxy) with\n      ⟨f, fx, fy, -⟩\n    rw [← ne.def, fun_like.ne_iff]\n    use (⟨coe, is_R_or_C.continuous_of_real⟩ : «exprC( , )» (exprℝ) 𝕜).comp f\n    simpa only [continuous_map_eval_apply_apply, continuous_map.comp_apply, coe_mk, ne.def, is_R_or_C.of_real_inj] using\n      ((fx (Set.mem_singleton x)).symm ▸ (fy (Set.mem_singleton y)).symm ▸ zero_ne_one : f x ≠ f y)\n  · obtain ⟨x, hx⟩ := (ideal_is_maximal_iff (ring_hom.ker φ)).mp infer_instance\n    refine' ⟨x, ext_ker <| ideal.ext fun f => _⟩\n    simpa only [ring_hom.mem_ker, continuous_map_eval_apply_apply, mem_ideal_of_set_compl_singleton,\n      ring_hom.mem_ker] using set_like.ext_iff.mp hx f\n#align continuous_map_eval_bijective continuous_map_eval_bijective\n\n",
 "continuous_map_eval_apply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp]\ntheorem continuous_map_eval_apply_apply (x : X) (f : «exprC( , )» X 𝕜) : continuous_map_eval X 𝕜 x f = f x :=\n  rfl\n#align continuous_map_eval_apply_apply continuous_map_eval_apply_apply\n\n"}