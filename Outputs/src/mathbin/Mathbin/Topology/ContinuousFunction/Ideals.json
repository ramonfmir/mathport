{"set_of_top_eq_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp]\ntheorem set_of_top_eq_univ [Nontrivial R] : set_of_ideal (Â«exprâŠ¤Â» : Ideal (Â«exprC( , )Â» X R)) = Set.univ :=\n  Set.univ_subset_iff.mp fun x hx => mem_set_of_ideal.mpr âŸ¨1, Submodule.mem_top, one_ne_zeroâŸ©\n#align set_of_top_eq_univ set_of_top_eq_univ\n\n",
 "set_of_ideal_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\ntheorem set_of_ideal_open [T2Space R] (I : Ideal (Â«exprC( , )Â» X R)) : IsOpen (set_of_ideal I) :=\n  by\n  simp only [set_of_ideal, Set.setOf_forall, isOpen_compl_iff]\n  exact isClosed_interáµ¢ fun f => isClosed_interáµ¢ fun hf => isClosed_eq (map_continuous f) continuous_const\n#align set_of_ideal_open set_of_ideal_open\n\n",
 "set_of_ideal_of_set_of_is_open":
 "theorem set_of_ideal_of_set_of_is_open {s : Set X} (hs : IsOpen s) : set_of_ideal (ideal_of_set ğ•œ s) = s :=\n  (set_of_ideal_of_set_eq_interior ğ•œ s).trans hs.interior_eq\n#align set_of_ideal_of_set_of_is_open set_of_ideal_of_set_of_is_open\n\n",
 "set_of_ideal_of_set_eq_interior":
 "@[simp]\ntheorem set_of_ideal_of_set_eq_interior (s : Set X) : set_of_ideal (ideal_of_set ğ•œ s) = interior s :=\n  by\n  refine'\n    Set.Subset.antisymm\n      ((set_of_ideal_open (ideal_of_set ğ•œ s)).subset_interior_iff.mpr fun x hx =>\n        let âŸ¨f, hf, hfxâŸ© := mem_set_of_ideal.mp hx\n        set.not_mem_compl_iff.mp (mt (@hf x) hfx))\n      fun x hx => _\n  -- If `x âˆ‰ closure sá¶œ`, we must produce `f : C(X, ğ•œ)` which is zero on `sá¶œ` and `f x â‰  0`.\n  rw [â† compl_compl (interior s), â† closure_compl] at hx\n  simp_rw [mem_set_of_ideal, mem_ideal_of_set]\n  haveI : NormalSpace X := normalOfCompactT2\n  /- Apply Urysohn's lemma to get `g : C(X, â„)` which is zero on `sá¶œ` and `g x â‰  0`, then compose\n    with the natural embedding `â„ â†ª ğ•œ` to produce the desired `f`. -/\n  obtain âŸ¨g, hgs, hgx : Set.EqOn g 1 {x}, -âŸ© :=\n    exists_continuous_zero_one_of_closed isClosed_closure isClosed_singleton (set.disjoint_singleton_right.mpr hx)\n  exact\n    âŸ¨âŸ¨fun x => g x, continuous_of_real.comp (map_continuous g)âŸ©, by\n      simpa only [coe_mk, of_real_eq_zero] using fun x hx => hgs (subset_closure hx), by\n      simpa only [coe_mk, hgx (Set.mem_singleton x), Pi.one_apply, IsROrC.ofReal_one] using one_ne_zeroâŸ©\n#align set_of_ideal_of_set_eq_interior set_of_ideal_of_set_eq_interior\n\n",
 "set_of_ideal_eq_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem set_of_ideal_eq_compl_singleton (I : Ideal (Â«exprC( , )Â» X ğ•œ)) [hI : I.is_maximal] :\n    âˆƒ x : X, set_of_ideal I = Â«expr á¶œÂ» {x} :=\n  by\n  have h : (ideal_of_set ğ•œ (set_of_ideal I)).is_maximal :=\n    (ideal_of_set_of_ideal_is_closed (inferInstance : IsClosed (I : Set (Â«exprC( , )Â» X ğ•œ)))).symm â–¸ hI\n  obtain âŸ¨x, hxâŸ© := opens.is_coatom_iff.1 ((ideal_of_set_is_maximal_iff ğ•œ (opens_of_ideal I)).1 h)\n  exact âŸ¨x, congr_arg coe hxâŸ©\n#align set_of_ideal_eq_compl_singleton set_of_ideal_eq_compl_singleton\n\n",
 "not_mem_set_of_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\ntheorem not_mem_set_of_ideal {I : Ideal (Â«exprC( , )Â» X R)} {x : X} :\n    x âˆ‰ set_of_ideal I â†” âˆ€ â¦ƒf : Â«exprC( , )Â» X Râ¦„, f âˆˆ I â†’ f x = 0 := by\n  rw [â† Set.mem_compl_iff, set_of_ideal, compl_compl, Set.mem_setOf]\n#align not_mem_set_of_ideal not_mem_set_of_ideal\n\n",
 "not_mem_ideal_of_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem not_mem_ideal_of_set {s : Set X} {f : Â«exprC( , )Â» X R} : f âˆ‰ ideal_of_set R s â†” âˆƒ x âˆˆ Â«expr á¶œÂ» s, f x â‰  0 :=\n  by\n  simp_rw [mem_ideal_of_set, exists_prop]\n  push_neg\n#align not_mem_ideal_of_set not_mem_ideal_of_set\n\n",
 "mem_set_of_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\ntheorem mem_set_of_ideal {I : Ideal (Â«exprC( , )Â» X R)} {x : X} :\n    x âˆˆ set_of_ideal I â†” âˆƒ f âˆˆ I, (f : Â«exprC( , )Â» X R) x â‰  0 :=\n  by\n  simp_rw [set_of_ideal, Set.mem_compl_iff, Set.mem_setOf, exists_prop]\n  push_neg\n#align mem_set_of_ideal mem_set_of_ideal\n\n",
 "mem_ideal_of_set_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n@[simp]\ntheorem mem_ideal_of_set_compl_singleton (x : X) (f : Â«exprC( , )Â» X R) :\n    f âˆˆ ideal_of_set R (Â«expr á¶œÂ» {x} : Set X) â†” f x = 0 := by\n  simp only [mem_ideal_of_set, compl_compl, Set.mem_singleton_iff, forall_eq]\n#align mem_ideal_of_set_compl_singleton mem_ideal_of_set_compl_singleton\n\n",
 "mem_ideal_of_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem mem_ideal_of_set {s : Set X} {f : Â«exprC( , )Â» X R} :\n    f âˆˆ ideal_of_set R s â†” âˆ€ â¦ƒx : Xâ¦„, x âˆˆ Â«expr á¶œÂ» s â†’ f x = 0 :=\n  iff.rfl\n#align mem_ideal_of_set mem_ideal_of_set\n\n",
 "ideal_of_set_of_ideal_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\ntheorem ideal_of_set_of_ideal_is_closed {I : Ideal (Â«exprC( , )Â» X ğ•œ)} (hI : IsClosed (I : Set (Â«exprC( , )Â» X ğ•œ))) :\n    ideal_of_set ğ•œ (set_of_ideal I) = I :=\n  (ideal_of_set_of_ideal_eq_closure I).trans (Ideal.ext <| Set.ext_iff.mp hI.closure_eq)\n#align ideal_of_set_of_ideal_is_closed ideal_of_set_of_ideal_is_closed\n\n",
 "ideal_of_set_of_ideal_eq_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp]\ntheorem ideal_of_set_of_ideal_eq_closure (I : Ideal (Â«exprC( , )Â» X ğ•œ)) : ideal_of_set ğ•œ (set_of_ideal I) = I.closure :=\n  by\n  /- Since `ideal_of_set ğ•œ (set_of_ideal I)` is closed and contains `I`, it contains `I.closure`.\n    For the reverse inclusion, given `f âˆˆ ideal_of_set ğ•œ (set_of_ideal I)` and `(Îµ : â„â‰¥0) > 0` it\n    suffices to show that `f` is within `Îµ` of `I`.-/\n  refine'\n    le_antisymm (fun f hf => metric.mem_closure_iff.mpr fun Îµ hÎµ => _)\n      ((ideal_of_set_closed ğ•œ <| set_of_ideal I).closure_subset_iff.mpr fun f hf x hx => not_mem_set_of_ideal.mp hx hf)\n  lift Îµ to nnreal using hÎµ.lt.le\n  replace hÎµ := show (0 : nnreal) < Îµ from hÎµ\n  simp_rw [dist_nndist]\n  norm_cast\n  -- Let `t := {x : X | Îµ / 2 â‰¤ â€–f xâ€–â‚Š}}` which is closed and disjoint from `set_of_ideal I`.\n  set t := { x : X | Îµ / 2 â‰¤ Â«exprâ€– â€–â‚ŠÂ» (f x) }\n  have ht : IsClosed t := isClosed_le continuous_const (map_continuous f).nnnorm\n  have htI : Disjoint t (Â«expr á¶œÂ» (set_of_ideal I)) :=\n    by\n    refine' set.subset_compl_iff_disjoint_left.mp fun x hx => _\n    simpa only [t, Set.mem_setOf, Set.mem_compl_iff, not_le] using\n      (nnnorm_eq_zero.mpr (mem_ideal_of_set.mp hf hx)).trans_lt (half_pos hÎµ)\n  /- It suffices to produce `g : C(X, â„â‰¥0)` which takes values in `[0,1]` and is constantly `1` on\n    `t` such that when composed with the natural embedding of `â„â‰¥0` into `ğ•œ` lies in the ideal `I`.\n    Indeed, then `â€–f - f * â†‘gâ€– â‰¤ â€–f * (1 - â†‘g)â€– â‰¤ â¨† â€–f * (1 - â†‘g) xâ€–`. When `x âˆ‰ t`, `â€–f xâ€– < Îµ / 2`\n    and `â€–(1 - â†‘g) xâ€– â‰¤ 1`, and when `x âˆˆ t`, `(1 - â†‘g) x = 0`, and clearly `f * â†‘g âˆˆ I`. -/\n  suffices\n    âˆƒ g : Â«exprC( , )Â» X (nnreal),\n      (algebraMapClm (nnreal) ğ•œ : Â«exprC( , )Â» (nnreal) ğ•œ).comp g âˆˆ I âˆ§ (âˆ€ x, g x â‰¤ 1) âˆ§ t.eq_on g 1\n    by\n    obtain âŸ¨g, hgI, hg, hgtâŸ© := this\n    refine' âŸ¨f * (algebraMapClm (nnreal) ğ•œ : Â«exprC( , )Â» (nnreal) ğ•œ).comp g, I.mul_mem_left f hgI, _âŸ©\n    rw [nndist_eq_nnnorm]\n    refine' (nnnorm_lt_iff _ hÎµ).2 fun x => _\n    simp only [coe_sub, coe_mul, Pi.sub_apply, Pi.mul_apply]\n    by_cases hx : x âˆˆ t\n    Â·\n      simpa only [hgt hx, comp_apply, Pi.one_apply, ContinuousMap.coe_coe, algebra_map_clm_apply, map_one, mul_one,\n        sub_self, nnnorm_zero] using hÎµ\n    Â· refine' lt_of_le_of_lt _ (half_lt_self hÎµ)\n      have :=\n        calc\n          Â«exprâ€– â€–â‚ŠÂ» ((1 - (algebraMapClm (nnreal) ğ•œ : Â«exprC( , )Â» (nnreal) ğ•œ).comp g) x : ğ•œ) =\n              Â«exprâ€– â€–â‚ŠÂ» (1 - algebraMap (nnreal) ğ•œ (g x)) :=\n            by\n            simp only [coe_sub, coe_one, coe_comp, ContinuousMap.coe_coe, Pi.sub_apply, Pi.one_apply,\n              Function.comp_apply, algebra_map_clm_apply]\n          _ = Â«exprâ€– â€–â‚ŠÂ» (algebraMap (nnreal) ğ•œ (1 - g x)) := by\n            simp only [Algebra.algebraMap_eq_smul_one, NNReal.smul_def, NNReal.coe_sub (hg x), sub_smul, Nonneg.coe_one,\n              one_smul]\n          _ â‰¤ 1 := (nnnorm_algebraMap_nNReal ğ•œ (1 - g x)).trans_le tsub_le_self\n          \n      calc\n        Â«exprâ€– â€–â‚ŠÂ» (f x - f x * (algebraMapClm (nnreal) ğ•œ : Â«exprC( , )Â» (nnreal) ğ•œ).comp g x) =\n            Â«exprâ€– â€–â‚ŠÂ» (f x * (1 - (algebraMapClm (nnreal) ğ•œ : Â«exprC( , )Â» (nnreal) ğ•œ).comp g) x) :=\n          by simp only [mul_sub, coe_sub, coe_one, Pi.sub_apply, Pi.one_apply, mul_one]\n        _ â‰¤ Îµ / 2 * Â«exprâ€– â€–â‚ŠÂ» ((1 - (algebraMapClm (nnreal) ğ•œ : Â«exprC( , )Â» (nnreal) ğ•œ).comp g) x) :=\n          ((nnnorm_mul_le _ _).trans (mul_le_mul_right' (not_le.mp <| show Â¬Îµ / 2 â‰¤ Â«exprâ€– â€–â‚ŠÂ» (f x) from hx).le _))\n        _ â‰¤ Îµ / 2 := by simpa only [mul_one] using mul_le_mul_left' this _\n        \n  /- There is some `g' : C(X, â„â‰¥0)` which is strictly positive on `t` such that the composition\n    `â†‘g` with the natural embedding of `â„â‰¥0` into `ğ•œ` lies in `I`. This follows from compactness of\n    `t` and that we can do it in any neighborhood of a point `x âˆˆ t`. Indeed, since `x âˆˆ t`, then\n    `fâ‚“ x â‰  0` for some `fâ‚“ âˆˆ I` and so `Î» y, â€–(star fâ‚“ * fâ‚“) yâ€–â‚Š` is strictly posiive in a\n    neighborhood of `y`. Moreover, `(â€–(star fâ‚“ * fâ‚“) yâ€–â‚Š : ğ•œ) = (star fâ‚“ * fâ‚“) y`, so composition of\n    this map with the natural embedding is just `star fâ‚“ * fâ‚“ âˆˆ I`. -/\n  have :\n    âˆƒ g' : Â«exprC( , )Â» X (nnreal),\n      (algebraMapClm (nnreal) ğ•œ : Â«exprC( , )Â» (nnreal) ğ•œ).comp g' âˆˆ I âˆ§ âˆ€ x âˆˆ t, 0 < g' x :=\n    by\n    refine'\n      @IsCompact.induction_on _ _ _ ht.is_compact\n        (fun s =>\n          âˆƒ g' : Â«exprC( , )Â» X (nnreal),\n            (algebraMapClm (nnreal) ğ•œ : Â«exprC( , )Â» (nnreal) ğ•œ).comp g' âˆˆ I âˆ§ âˆ€ x âˆˆ s, 0 < g' x)\n        _ _ _ _\n    Â· refine' âŸ¨0, _, fun x hx => false.elim hxâŸ©\n      convert I.zero_mem\n      ext\n      simp only [coe_zero, Pi.zero_apply, ContinuousMap.coe_coe, ContinuousMap.coe_comp, map_zero, Pi.comp_zero]\n    Â· rintro sâ‚ sâ‚‚ hs âŸ¨g, hI, hgtâŸ©\n      exact âŸ¨g, hI, fun x hx => hgt x (hs hx)âŸ©\n    Â· rintro sâ‚ sâ‚‚ âŸ¨gâ‚, hIâ‚, hgtâ‚âŸ© âŸ¨gâ‚‚, hIâ‚‚, hgtâ‚‚âŸ©\n      refine' âŸ¨gâ‚ + gâ‚‚, _, fun x hx => _âŸ©\n      Â· convert I.add_mem hIâ‚ hIâ‚‚\n        ext y\n        simp only [coe_add, Pi.add_apply, map_add, coe_comp, Function.comp_apply, ContinuousMap.coe_coe]\n      Â· rcases hx with (hx | hx)\n        simpa only [zero_add] using add_lt_add_of_lt_of_le (hgtâ‚ x hx) zero_le'\n        simpa only [zero_add] using add_lt_add_of_le_of_lt zero_le' (hgtâ‚‚ x hx)\n    Â· intro x hx\n      replace hx := htI.subset_compl_right hx\n      rw [compl_compl, mem_set_of_ideal] at hx\n      obtain âŸ¨g, hI, hgxâŸ© := hx\n      have := (map_continuous g).continuous_at.eventually_ne hgx\n      refine'\n        âŸ¨{ y : X | g y â‰  0 } âˆ© t, mem_nhds_within_iff_exists_mem_nhds_inter.mpr âŸ¨_, this, Set.Subset.rflâŸ©,\n          âŸ¨âŸ¨fun x => Â«exprâ€– â€–â‚ŠÂ» (g x) ^ 2, (map_continuous g).nnnorm.pow 2âŸ©, _, fun x hx =>\n            pow_pos (norm_pos_iff.mpr hx.1) 2âŸ©âŸ©\n      convert I.mul_mem_left (star g) hI\n      ext\n      simp only [comp_apply, coe_mk, algebraMapClm_coe, map_pow, coe_mul, coe_star, Pi.mul_apply, Pi.star_apply,\n        star_def, ContinuousMap.coe_coe]\n      simpa only [norm_sq_eq_def', IsROrC.conj_mul, of_real_pow]\n  /- Get the function `g'` which is guaranteed to exist above. By the extreme value theorem and\n    compactness of `t`, there is some `0 < c` such that `c â‰¤ g' x` for all `x âˆˆ t`. Then by\n    `main_lemma_aux` there is some `g` for which `g * g'` is the desired function. -/\n  obtain âŸ¨g', hI', hgt'âŸ© := this\n  obtain âŸ¨c, hc, hgc'âŸ© : âˆƒ (c : _)(hc : 0 < c), âˆ€ y : X, y âˆˆ t â†’ c â‰¤ g' y :=\n    t.eq_empty_or_nonempty.elim (fun ht' => âŸ¨1, zero_lt_one, fun y hy => false.elim (by rwa [ht'] at hy)âŸ©) fun ht' =>\n      let âŸ¨x, hx, hx'âŸ© := ht.is_compact.exists_forall_le ht' (map_continuous g').continuous_on\n      âŸ¨g' x, hgt' x hx, hx'âŸ©\n  obtain âŸ¨g, hg, hgcâŸ© := exists_mul_le_one_eq_on_ge g' hc\n  refine' âŸ¨g * g', _, hg, hgc.mono hgc'âŸ©\n  convert I.mul_mem_left ((algebraMapClm (nnreal) ğ•œ : Â«exprC( , )Â» (nnreal) ğ•œ).comp g) hI'\n  ext\n  simp only [algebraMapClm_coe, ContinuousMap.coe_coe, comp_apply, coe_mul, Pi.mul_apply, map_mul]\n#align ideal_of_set_of_ideal_eq_closure ideal_of_set_of_ideal_eq_closure\n\n",
 "ideal_of_set_is_maximal_iff":
 "theorem ideal_of_set_is_maximal_iff (s : Opens X) : (ideal_of_set ğ•œ (s : Set X)).is_maximal â†” IsCoatom s :=\n  by\n  rw [Ideal.isMaximal_def]\n  refine' (ideal_opens_gi X ğ•œ).is_coatom_iff (fun I hI => _) s\n  rw [â† Ideal.isMaximal_def] at hI\n  skip\n  exact ideal_of_set_of_ideal_is_closed inferInstance\n#align ideal_of_set_is_maximal_iff ideal_of_set_is_maximal_iff\n\n",
 "ideal_of_set_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/-\nCopyright (c) 2022 Jireh Loreaux. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jireh Loreaux\n-/\ntheorem ideal_of_set_closed [LocallyCompactSpace X] [T2Space R] (s : Set X) :\n    IsClosed (ideal_of_set R s : Set (Â«exprC( , )Â» X R)) :=\n  by\n  simp only [ideal_of_set, Submodule.coe_set_mk, Set.setOf_forall]\n  exact isClosed_interáµ¢ fun x => isClosed_interáµ¢ fun hx => isClosed_eq (continuous_eval_const' x) continuous_const\n#align ideal_of_set_closed ideal_of_set_closed\n\n",
 "ideal_of_empty_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n@[simp]\ntheorem ideal_of_empty_eq_bot : ideal_of_set R (âˆ… : Set X) = Â«exprâŠ¥Â» :=\n  Ideal.ext fun f => by\n    simpa only [mem_ideal_of_set, Set.compl_empty, Set.mem_univ, forall_true_left, Ideal.mem_bot, FunLike.ext_iff] using\n      iff.rfl\n#align ideal_of_empty_eq_bot ideal_of_empty_eq_bot\n\n",
 "ideal_of_compl_singleton_is_maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem ideal_of_compl_singleton_is_maximal (x : X) : (ideal_of_set ğ•œ (Â«expr á¶œÂ» {x} : Set X)).is_maximal :=\n  (ideal_of_set_is_maximal_iff ğ•œ (Closeds.singleton x).compl).mpr <| Opens.isCoatom_iff.mpr âŸ¨x, rflâŸ©\n#align ideal_of_compl_singleton_is_maximal ideal_of_compl_singleton_is_maximal\n\n",
 "ideal_is_maximal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem ideal_is_maximal_iff (I : Ideal (Â«exprC( , )Â» X ğ•œ)) [hI : IsClosed (I : Set (Â«exprC( , )Â» X ğ•œ))] :\n    I.is_maximal â†” âˆƒ x : X, ideal_of_set ğ•œ (Â«expr á¶œÂ» {x}) = I :=\n  by\n  refine'\n    âŸ¨_, fun h =>\n      let âŸ¨x, hxâŸ© := h\n      hx â–¸ ideal_of_compl_singleton_is_maximal ğ•œ xâŸ©\n  intro hI'\n  obtain âŸ¨x, hxâŸ© := set_of_ideal_eq_compl_singleton I\n  exact\n    âŸ¨x, by\n      simpa only [ideal_of_set_of_ideal_eq_closure, Ideal.closure_eq_of_isClosed] using\n        congr_arg (ideal_of_set ğ•œ) hx.symmâŸ©\n#align ideal_is_maximal_iff ideal_is_maximal_iff\n\n",
 "ideal_gc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\ntheorem ideal_gc : GaloisConnection (set_of_ideal : Ideal (Â«exprC( , )Â» X R) â†’ Set X) (ideal_of_set R) :=\n  by\n  refine' fun I s => âŸ¨fun h f hf => _, fun h x hx => _âŸ©\n  Â· by_contra h'\n    rcases not_mem_ideal_of_set.mp h' with âŸ¨x, hx, hfxâŸ©\n    exact hfx (not_mem_set_of_ideal.mp (mt (@h x) hx) hf)\n  Â· obtain âŸ¨f, hf, hfxâŸ© := mem_set_of_ideal.mp hx\n    by_contra hx'\n    exact not_mem_ideal_of_set.mpr âŸ¨x, hx', hfxâŸ© (h hf)\n#align ideal_gc ideal_gc\n\n",
 "exists_mul_le_one_eq_on_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-- An auxiliary lemma used in the proof of `ideal_of_set_of_ideal_eq_closure` which may be useful\non its own. -/\ntheorem exists_mul_le_one_eq_on_ge (f : Â«exprC( , )Â» X (nnreal)) {c : nnreal} (hc : 0 < c) :\n    âˆƒ g : Â«exprC( , )Â» X (nnreal), (âˆ€ x : X, (g * f) x â‰¤ 1) âˆ§ { x : X | c â‰¤ f x }.eq_on (g * f) 1 :=\n  âŸ¨{  to_fun := (Â«expr âŠ” Â» f (const X c))â»Â¹\n      continuous_to_fun := ((map_continuous f).sup <| map_continuous _).invâ‚€ fun _ => (hc.trans_le le_sup_right).ne' },\n    fun x => (inv_mul_le_iff (hc.trans_le le_sup_right)).mpr ((mul_one (Â«expr âŠ” Â» (f x) c)).symm â–¸ le_sup_left),\n    fun x hx => by\n    simpa only [coe_const, coe_mk, Pi.mul_apply, Pi.inv_apply, Pi.sup_apply, Function.const_apply, Pi.one_apply,\n      sup_eq_left.mpr (set.mem_set_of.mp hx)] using inv_mul_cancel (hc.trans_le hx).ne'âŸ©\n#align exists_mul_le_one_eq_on_ge exists_mul_le_one_eq_on_ge\n\n",
 "continuous_map_eval_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem continuous_map_eval_bijective : bijective (continuous_map_eval X ğ•œ) :=\n  by\n  refine' âŸ¨fun x y hxy => _, fun Ï† => _âŸ©\n  Â· contrapose! hxy\n    haveI := @normalOfCompactT2 X _ _ _\n    rcases exists_continuous_zero_one_of_closed (isClosed_singleton : _root_.is_closed {x})\n        (isClosed_singleton : _root_.is_closed {y}) (set.disjoint_singleton.mpr hxy) with\n      âŸ¨f, fx, fy, -âŸ©\n    rw [â† ne.def, FunLike.ne_iff]\n    use (âŸ¨coe, IsROrC.continuous_ofRealâŸ© : Â«exprC( , )Â» (exprâ„) ğ•œ).comp f\n    simpa only [continuous_map_eval_apply_apply, ContinuousMap.comp_apply, coe_mk, ne.def, IsROrC.ofReal_inj] using\n      ((fx (Set.mem_singleton x)).symm â–¸ (fy (Set.mem_singleton y)).symm â–¸ zero_ne_one : f x â‰  f y)\n  Â· obtain âŸ¨x, hxâŸ© := (ideal_is_maximal_iff (RingHom.ker Ï†)).mp inferInstance\n    refine' âŸ¨x, ext_ker <| Ideal.ext fun f => _âŸ©\n    simpa only [RingHom.mem_ker, continuous_map_eval_apply_apply, mem_ideal_of_set_compl_singleton,\n      RingHom.mem_ker] using set_like.ext_iff.mp hx f\n#align continuous_map_eval_bijective continuous_map_eval_bijective\n\n",
 "continuous_map_eval_apply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp]\ntheorem continuous_map_eval_apply_apply (x : X) (f : Â«exprC( , )Â» X ğ•œ) : continuous_map_eval X ğ•œ x f = f x :=\n  rfl\n#align continuous_map_eval_apply_apply continuous_map_eval_apply_apply\n\n"}