{"sup_mem_subalgebra_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem sup_mem_subalgebra_closure (A : subalgebra (exprâ„) (Â«exprC( , )Â» X (exprâ„))) (f g : A) :\n    Â«expr âŠ” Â» (f : Â«exprC( , )Â» X (exprâ„)) (g : Â«exprC( , )Â» X (exprâ„)) âˆˆ A.topological_closure :=\n  by\n  rw [sup_eq]\n  refine'\n    A.topological_closure.smul_mem\n      (A.topological_closure.add_mem\n        (A.topological_closure.add_mem (A.le_topological_closure f.property) (A.le_topological_closure g.property)) _)\n      _\n  exact_mod_cast abs_mem_subalgebra_closure A _\n#align sup_mem_subalgebra_closure sup_mem_subalgebra_closure\n\n",
 "sup_mem_closed_subalgebra":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem sup_mem_closed_subalgebra (A : subalgebra (exprâ„) (Â«exprC( , )Â» X (exprâ„)))\n    (h : is_closed (A : set (Â«exprC( , )Â» X (exprâ„)))) (f g : A) :\n    Â«expr âŠ” Â» (f : Â«exprC( , )Â» X (exprâ„)) (g : Â«exprC( , )Â» X (exprâ„)) âˆˆ A :=\n  by\n  convert sup_mem_subalgebra_closure A f g\n  apply SetLike.ext'\n  symm\n  erw [closure_eq_iff_is_closed]\n  exact h\n#align sup_mem_closed_subalgebra sup_mem_closed_subalgebra\n\n",
 "sublattice_closure_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (f g Â«expr âˆˆ Â» L) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (f g Â«expr âˆˆ Â» L) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n-- Here's the fun part of Stone-Weierstrass!\ntheorem sublattice_closure_eq_top (L : set (Â«exprC( , )Â» X (exprâ„))) (nA : L.nonempty)\n    (inf_mem : âˆ€ (f) (_ : f âˆˆ L) (g) (_ : g âˆˆ L), Â«expr âŠ“ Â» f g âˆˆ L)\n    (sup_mem : âˆ€ (f) (_ : f âˆˆ L) (g) (_ : g âˆˆ L), Â«expr âŠ” Â» f g âˆˆ L) (sep : L.separates_points_strongly) :\n    closure L = Â«exprâŠ¤Â» :=\n  by\n  -- We start by boiling down to a statement about close approximation.\n  apply eq_top_iff.mpr\n  rintro f -\n  refine' filter.frequently.mem_closure ((filter.has_basis.frequently_iff metric.nhds_basis_ball).mpr fun Îµ pos => _)\n  simp only [exists_prop, metric.mem_ball]\n  -- It will be helpful to assume `X` is nonempty later,\n  -- so we get that out of the way here.\n  by_cases nX : nonempty X\n  swap\n  exact âŸ¨nA.some, (dist_lt_iff pos).mpr fun x => false.elim (nX âŸ¨xâŸ©), nA.some_specâŸ©\n  /-\n    The strategy now is to pick a family of continuous functions `g x y` in `A`\n    with the property that `g x y x = f x` and `g x y y = f y`\n    (this is immediate from `h : separates_points_strongly`)\n    then use continuity to see that `g x y` is close to `f` near both `x` and `y`,\n    and finally using compactness to produce the desired function `h`\n    as a maximum over finitely many `x` of a minimum over finitely many `y` of the `g x y`.\n    -/\n  dsimp [set.separates_points_strongly] at sep\n  let g : X â†’ X â†’ L := fun x y => (sep f x y).some\n  have wâ‚ : âˆ€ x y, g x y x = f x := fun x y => (sep f x y).some_spec.1\n  have wâ‚‚ : âˆ€ x y, g x y y = f y := fun x y => (sep f x y).some_spec.2\n  -- For each `x y`, we define `U x y` to be `{z | f z - Îµ < g x y z}`,\n  -- and observe this is a neighbourhood of `y`.\n  let U : X â†’ X â†’ set X := fun x y => { z | f z - Îµ < g x y z }\n  have U_nhd_y : âˆ€ x y, U x y âˆˆ (nhds) y := by\n    intro x y\n    refine' is_open.mem_nhds _ _\n    Â· apply is_open_lt <;> continuity\n    Â· rw [Set.mem_setOf_eq, wâ‚‚]\n      exact sub_lt_self _ pos\n  -- Fixing `x` for a moment, we have a family of functions `Î» y, g x y`\n  -- which on different patches (the `U x y`) are greater than `f z - Îµ`.\n  -- Taking the supremum of these functions\n  -- indexed by a finite collection of patches which cover `X`\n  -- will give us an element of `A` that is globally greater than `f z - Îµ`\n  -- and still equal to `f x` at `x`.\n  -- Since `X` is compact, for every `x` there is some finset `ys t`\n  -- so the union of the `U x y` for `y âˆˆ ys x` still covers everything.\n  let ys : âˆ€ x, Finset X := fun x => (compact_space.elim_nhds_subcover (U x) (U_nhd_y x)).some\n  let ys_w :\n    âˆ€ x,\n      Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (U x y) =\n        Â«exprâŠ¤Â» :=\n    fun x => (compact_space.elim_nhds_subcover (U x) (U_nhd_y x)).some_spec\n  have ys_nonempty : âˆ€ x, (ys x).nonempty := fun x => Set.nonempty_of_union_eq_top_of_nonempty _ _ nX (ys_w x)\n  -- Thus for each `x` we have the desired `h x : A` so `f z - Îµ < h x z` everywhere\n  -- and `h x x = f x`.\n  let h : âˆ€ x, L := fun x =>\n    âŸ¨(ys x).sup' (ys_nonempty x) fun y => (g x y : Â«exprC( , )Â» X (exprâ„)),\n      finset.sup'_mem _ sup_mem _ _ _ fun y _ => (g x y).2âŸ©\n  have lt_h : âˆ€ x z, f z - Îµ < h x z := by\n    intro x z\n    obtain âŸ¨y, ym, zmâŸ© := Set.exists_set_mem_of_union_eq_top _ _ (ys_w x) z\n    dsimp [h]\n    simp only [coe_fn_coe_base', subtype.coe_mk, sup'_coe, finset.sup'_apply, finset.lt_sup'_iff]\n    exact âŸ¨y, ym, zmâŸ©\n  have h_eq : âˆ€ x, h x x = f x := by\n    intro x\n    simp only [coe_fn_coe_base'] at wâ‚\n    simp [coe_fn_coe_base', wâ‚]\n  -- For each `x`, we define `W x` to be `{z | h x z < f z + Îµ}`,\n  let W : âˆ€ x, set X := fun x => { z | h x z < f z + Îµ }\n  -- This is still a neighbourhood of `x`.\n  have W_nhd : âˆ€ x, W x âˆˆ (nhds) x := by\n    intro x\n    refine' is_open.mem_nhds _ _\n    Â· apply is_open_lt <;> continuity\n    Â· dsimp only [W, Set.mem_setOf_eq]\n      rw [h_eq]\n      exact lt_add_of_pos_right _ pos\n  -- Since `X` is compact, there is some finset `ys t`\n  -- so the union of the `W x` for `x âˆˆ xs` still covers everything.\n  let xs : Finset X := (compact_space.elim_nhds_subcover W W_nhd).some\n  let xs_w :\n    Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (W x) = Â«exprâŠ¤Â» :=\n    (compact_space.elim_nhds_subcover W W_nhd).some_spec\n  have xs_nonempty : xs.nonempty := Set.nonempty_of_union_eq_top_of_nonempty _ _ nX xs_w\n  -- Finally our candidate function is the infimum over `x âˆˆ xs` of the `h x`.\n  -- This function is then globally less than `f z + Îµ`.\n  let k : (L : Type _) :=\n    âŸ¨xs.inf' xs_nonempty fun x => (h x : Â«exprC( , )Â» X (exprâ„)), finset.inf'_mem _ inf_mem _ _ _ fun x _ => (h x).2âŸ©\n  refine' âŸ¨k.1, _, k.2âŸ©\n  -- We just need to verify the bound, which we do pointwise.\n  rw [dist_lt_iff pos]\n  intro z\n  -- We rewrite into this particular form,\n  -- so that simp lemmas about inequalities involving `finset.inf'` can fire.\n  rw [show âˆ€ a b Îµ : exprâ„, dist a b < Îµ â†” a < b + Îµ âˆ§ b - Îµ < a\n      by\n      intros\n      simp only [â† metric.mem_ball, real.ball_eq_Ioo, Set.mem_Ioo, and_comm']]\n  fconstructor\n  Â· dsimp [k]\n    simp only [finset.inf'_lt_iff, continuous_map.inf'_apply]\n    exact Set.exists_set_mem_of_union_eq_top _ _ xs_w z\n  Â· dsimp [k]\n    simp only [finset.lt_inf'_iff, continuous_map.inf'_apply]\n    intro x xm\n    apply lt_h\n#align sublattice_closure_eq_top sublattice_closure_eq_top\n\n",
 "subalgebra_topological_closure_eq_top_of_separates_points":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- The **Stone-Weierstrass Approximation Theorem**,\nthat a subalgebra `A` of `C(X, â„)`, where `X` is a compact topological space,\nis dense if it separates points.\n-/\ntheorem subalgebra_topological_closure_eq_top_of_separates_points (A : subalgebra (exprâ„) (Â«exprC( , )Â» X (exprâ„)))\n    (w : A.separates_points) : A.topological_closure = Â«exprâŠ¤Â» :=\n  by\n  -- The closure of `A` is closed under taking `sup` and `inf`,\n  -- and separates points strongly (since `A` does),\n  -- so we can apply `sublattice_closure_eq_top`.\n  apply SetLike.ext'\n  let L := A.topological_closure\n  have n : Set.Nonempty (L : set (Â«exprC( , )Â» X (exprâ„))) :=\n    âŸ¨(1 : Â«exprC( , )Â» X (exprâ„)), A.le_topological_closure A.one_memâŸ©\n  convert\n    sublattice_closure_eq_top (L : set (Â«exprC( , )Â» X (exprâ„))) n\n      (fun f fm g gm => inf_mem_closed_subalgebra L A.is_closed_topological_closure âŸ¨f, fmâŸ© âŸ¨g, gmâŸ©)\n      (fun f fm g gm => sup_mem_closed_subalgebra L A.is_closed_topological_closure âŸ¨f, fmâŸ© âŸ¨g, gmâŸ©)\n      (subalgebra.separates_points.strongly (subalgebra.separates_points_monotone A.le_topological_closure w))\n  Â· simp\n#align\n  subalgebra_topological_closure_eq_top_of_separates_points subalgebra_topological_closure_eq_top_of_separates_points\n\n",
 "subalgebra_is_R_or_C_topological_closure_eq_top_of_separates_points":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- The Stone-Weierstrass approximation theorem, `is_R_or_C` version,\nthat a subalgebra `A` of `C(X, ğ•œ)`, where `X` is a compact topological space and `is_R_or_C ğ•œ`,\nis dense if it is conjugation-invariant and separates points.\n-/\ntheorem continuous_map.subalgebra_is_R_or_C_topological_closure_eq_top_of_separates_points\n    (A : subalgebra ğ•œ (Â«exprC( , )Â» X ğ•œ)) (hA : A.separates_points)\n    (hA' : conj_invariant_subalgebra (A.restrict_scalars (exprâ„))) : A.topological_closure = Â«exprâŠ¤Â» :=\n  by\n  rw [algebra.eq_top_iff]\n  -- Let `I` be the natural inclusion of `C(X, â„)` into `C(X, ğ•œ)`\n  let I : Â«expr â†’â‚—[ ] Â» (Â«exprC( , )Â» X (exprâ„)) (exprâ„) (Â«exprC( , )Â» X ğ•œ) :=\n    of_real_clm.comp_left_continuous (exprâ„) X\n  -- The main point of the proof is that its range (i.e., every real-valued function) is contained\n  -- in the closure of `A`\n  have key : I.range â‰¤ (A.to_submodule.restrict_scalars (exprâ„)).topological_closure :=\n    by\n    -- Let `Aâ‚€` be the subalgebra of `C(X, â„)` consisting of `A`'s purely real elements; it is the\n    -- preimage of `A` under `I`.  In this argument we only need its submodule structure.\n    let Aâ‚€ : submodule (exprâ„) (Â«exprC( , )Â» X (exprâ„)) := (A.to_submodule.restrict_scalars (exprâ„)).comap I\n    -- By `subalgebra.separates_points.complex_to_real`, this subalgebra also separates points, so\n    -- we may apply the real Stone-Weierstrass result to it.\n    have SW : Aâ‚€.topological_closure = Â«exprâŠ¤Â» :=\n      haveI := subalgebra_topological_closure_eq_top_of_separates_points _ (hA.is_R_or_C_to_real hA')\n      congr_arg subalgebra.to_submodule this\n    rw [â† submodule.map_top, â† SW]\n    -- So it suffices to prove that the image under `I` of the closure of `Aâ‚€` is contained in the\n    -- closure of `A`, which follows by abstract nonsense\n    have hâ‚ := Aâ‚€.topological_closure_map ((@of_real_clm ğ•œ _).comp_left_continuous_compact X)\n    have hâ‚‚ := (A.to_submodule.restrict_scalars (exprâ„)).map_comap_le I\n    exact hâ‚.trans (submodule.topological_closure_mono hâ‚‚)\n  -- In particular, for a function `f` in `C(X, ğ•œ)`, the real and imaginary parts of `f` are in the\n  -- closure of `A`\n  intro f\n  let f_re : Â«exprC( , )Â» X (exprâ„) := (âŸ¨is_R_or_C.re, is_R_or_C.re_clm.continuousâŸ© : Â«exprC( , )Â» ğ•œ (exprâ„)).comp f\n  let f_im : Â«exprC( , )Â» X (exprâ„) := (âŸ¨is_R_or_C.im, is_R_or_C.im_clm.continuousâŸ© : Â«exprC( , )Â» ğ•œ (exprâ„)).comp f\n  have h_f_re : I f_re âˆˆ A.topological_closure := key âŸ¨f_re, rflâŸ©\n  have h_f_im : I f_im âˆˆ A.topological_closure := key âŸ¨f_im, rflâŸ©\n  -- So `f_re + I â€¢ f_im` is in the closure of `A`\n  convert A.topological_closure.add_mem h_f_re (A.topological_closure.smul_mem h_f_im is_R_or_C.I)\n  -- And this, of course, is just `f`\n  ext\n  apply eq.symm\n  simp [I, mul_comm is_R_or_C.I _]\n#align\n  continuous_map.subalgebra_is_R_or_C_topological_closure_eq_top_of_separates_points continuous_map.subalgebra_is_R_or_C_topological_closure_eq_top_of_separates_points\n\n",
 "subalgebra_conj_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- If a set `S` is conjugation-invariant, then its `ğ•œ`-span is conjugation-invariant. -/\ntheorem subalgebra_conj_invariant {S : set (Â«exprC( , )Â» X ğ•œ)}\n    (hS : âˆ€ f, f âˆˆ S â†’ (conj_ae.to_alg_hom.comp_left_continuous (exprâ„) conj_cle.continuous) f âˆˆ S) :\n    conj_invariant_subalgebra ((algebra.adjoin ğ•œ S).restrict_scalars (exprâ„)) :=\n  by\n  rintro _ âŸ¨f, hf, rflâŸ©\n  change _ âˆˆ (algebra.adjoin ğ•œ S).restrict_scalars (exprâ„)\n  change _ âˆˆ (algebra.adjoin ğ•œ S).restrict_scalars (exprâ„) at hf\n  rw [subalgebra.mem_restrict_scalars] at hfâŠ¢\n  apply algebra.adjoin_induction hf\n  Â· exact fun g hg => algebra.subset_adjoin (hS g hg)\n  Â· exact fun c => subalgebra.algebra_map_mem _ (starRingEnd ğ•œ c)\n  Â· intro f g hf hg\n    convert subalgebra.add_mem _ hf hg\n    exact alg_hom.map_add _ f g\n  Â· intro f g hf hg\n    convert subalgebra.mul_mem _ hf hg\n    exact alg_hom.map_mul _ f g\n#align subalgebra_conj_invariant subalgebra_conj_invariant\n\n",
 "polynomial_comp_attach_bound_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- Given a continuous function `f` in a subalgebra of `C(X, â„)`, postcomposing by a polynomial\ngives another function in `A`.\n\nThis lemma proves something slightly more subtle than this:\nwe take `f`, and think of it as a function into the restricted target `set.Icc (-â€–fâ€–) â€–fâ€–)`,\nand then postcompose with a polynomial function on that interval.\nThis is in fact the same situation as above, and so also gives a function in `A`.\n-/\ntheorem polynomial_comp_attach_bound_mem (A : subalgebra (exprâ„) (Â«exprC( , )Â» X (exprâ„))) (f : A)\n    (g : polynomial (exprâ„)) :\n    (g.to_continuous_map_on (Set.Icc (-Â«exprâ€– â€–Â» f) (Â«exprâ€– â€–Â» f))).comp (f : Â«exprC( , )Â» X (exprâ„)).attach_bound âˆˆ\n      A :=\n  by\n  rw [polynomial_comp_attach_bound]\n  apply SetLike.coe_mem\n#align polynomial_comp_attach_bound_mem polynomial_comp_attach_bound_mem\n\n",
 "polynomial_comp_attach_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem polynomial_comp_attach_bound (A : subalgebra (exprâ„) (Â«exprC( , )Â» X (exprâ„))) (f : A)\n    (g : polynomial (exprâ„)) :\n    (g.to_continuous_map_on (Set.Icc (-Â«exprâ€– â€–Â» f) (Â«exprâ€– â€–Â» f))).comp (f : Â«exprC( , )Â» X (exprâ„)).attach_bound =\n      polynomial.aeval f g :=\n  by\n  ext\n  simp only [continuous_map.coe_comp, Function.comp_apply, continuous_map.attach_bound_apply_coe,\n    polynomial.to_continuous_map_on_apply, polynomial.aeval_subalgebra_coe, polynomial.aeval_continuous_map_apply,\n    polynomial.to_continuous_map_apply]\n#align polynomial_comp_attach_bound polynomial_comp_attach_bound\n\n",
 "mem_conj_invariant_subalgebra":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n-- Redefine `X`, since for the next few lemmas it need not be compact\ntheorem mem_conj_invariant_subalgebra {A : subalgebra (exprâ„) (Â«exprC( , )Â» X ğ•œ)} (hA : conj_invariant_subalgebra A)\n    {f : Â«exprC( , )Â» X ğ•œ} (hf : f âˆˆ A) : (conj_ae.to_alg_hom.comp_left_continuous (exprâ„) conj_cle.continuous) f âˆˆ A :=\n  hA âŸ¨f, hf, rflâŸ©\n#align mem_conj_invariant_subalgebra mem_conj_invariant_subalgebra\n\n",
 "is_R_or_C_to_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- If a conjugation-invariant subalgebra of `C(X, ğ•œ)` separates points, then the real subalgebra\nof its purely real-valued elements also separates points. -/\ntheorem subalgebra.separates_points.is_R_or_C_to_real {A : subalgebra ğ•œ (Â«exprC( , )Â» X ğ•œ)} (hA : A.separates_points)\n    (hA' : conj_invariant_subalgebra (A.restrict_scalars (exprâ„))) :\n    ((A.restrict_scalars (exprâ„)).comap\n        (of_real_am.comp_left_continuous (exprâ„) continuous_of_real)).separates_points :=\n  by\n  intro xâ‚ xâ‚‚ hx\n  -- Let `f` in the subalgebra `A` separate the points `xâ‚`, `xâ‚‚`\n  obtain âŸ¨_, âŸ¨f, hfA, rflâŸ©, hfâŸ© := hA hx\n  let F : Â«exprC( , )Â» X ğ•œ := f - const _ (f xâ‚‚)\n  -- Subtract the constant `f xâ‚‚` from `f`; this is still an element of the subalgebra\n  have hFA : F âˆˆ A :=\n    by\n    refine' A.sub_mem hfA (@eq.subst _ (Â· âˆˆ A) _ _ _ <| A.smul_mem A.one_mem <| f xâ‚‚)\n    ext1\n    simp only [coe_smul, coe_one, pi.smul_apply, pi.one_apply, algebra.id.smul_eq_mul, mul_one, const_apply]\n  -- Consider now the function `Î» x, |f x - f xâ‚‚| ^ 2`\n  refine' âŸ¨_, âŸ¨(âŸ¨is_R_or_C.norm_sq, continuous_norm_sqâŸ© : Â«exprC( , )Â» ğ•œ (exprâ„)).comp F, _, rflâŸ©, _âŸ©\n  Â· -- This is also an element of the subalgebra, and takes only real values\n    rw [SetLike.mem_coe, subalgebra.mem_comap]\n    convert (A.restrict_scalars (exprâ„)).mul_mem (mem_conj_invariant_subalgebra hA' hFA) hFA\n    ext1\n    rw [mul_comm]\n    exact (is_R_or_C.mul_conj _).symm\n  Â· -- And it also separates the points `xâ‚`, `xâ‚‚`\n    have : f xâ‚ - f xâ‚‚ â‰  0 := sub_ne_zero.mpr hf\n    simpa only [comp_apply, coe_sub, coe_const, pi.sub_apply, coe_mk, sub_self, map_zero, ne.def, norm_sq_eq_zero] using\n      this\n#align subalgebra.separates_points.is_R_or_C_to_real subalgebra.separates_points.is_R_or_C_to_real\n\n",
 "inf_mem_subalgebra_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem inf_mem_subalgebra_closure (A : subalgebra (exprâ„) (Â«exprC( , )Â» X (exprâ„))) (f g : A) :\n    Â«expr âŠ“ Â» (f : Â«exprC( , )Â» X (exprâ„)) (g : Â«exprC( , )Â» X (exprâ„)) âˆˆ A.topological_closure :=\n  by\n  rw [inf_eq]\n  refine'\n    A.topological_closure.smul_mem\n      (A.topological_closure.sub_mem\n        (A.topological_closure.add_mem (A.le_topological_closure f.property) (A.le_topological_closure g.property)) _)\n      _\n  exact_mod_cast abs_mem_subalgebra_closure A _\n#align inf_mem_subalgebra_closure inf_mem_subalgebra_closure\n\n",
 "inf_mem_closed_subalgebra":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem inf_mem_closed_subalgebra (A : subalgebra (exprâ„) (Â«exprC( , )Â» X (exprâ„)))\n    (h : is_closed (A : set (Â«exprC( , )Â» X (exprâ„)))) (f g : A) :\n    Â«expr âŠ“ Â» (f : Â«exprC( , )Â» X (exprâ„)) (g : Â«exprC( , )Â» X (exprâ„)) âˆˆ A :=\n  by\n  convert inf_mem_subalgebra_closure A f g\n  apply SetLike.ext'\n  symm\n  erw [closure_eq_iff_is_closed]\n  exact h\n#align inf_mem_closed_subalgebra inf_mem_closed_subalgebra\n\n",
 "exists_mem_subalgebra_near_continuous_of_separates_points":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-- An alternative statement of the Stone-Weierstrass theorem,\nfor those who like their epsilons and don't like bundled continuous functions.\n\nIf `A` is a subalgebra of `C(X, â„)` which separates points (and `X` is compact),\nevery real-valued continuous function on `X` is within any `Îµ > 0` of some element of `A`.\n-/\ntheorem exists_mem_subalgebra_near_continuous_of_separates_points (A : subalgebra (exprâ„) (Â«exprC( , )Â» X (exprâ„)))\n    (w : A.separates_points) (f : X â†’ exprâ„) (c : continuous f) (Îµ : exprâ„) (pos : 0 < Îµ) :\n    âˆƒ g : A, âˆ€ x, Â«exprâ€– â€–Â» (g x - f x) < Îµ :=\n  by\n  obtain âŸ¨g, bâŸ© := exists_mem_subalgebra_near_continuous_map_of_separates_points A w âŸ¨f, câŸ© Îµ pos\n  use g\n  rwa [norm_lt_iff _ pos] at b\n#align\n  exists_mem_subalgebra_near_continuous_of_separates_points exists_mem_subalgebra_near_continuous_of_separates_points\n\n",
 "exists_mem_subalgebra_near_continuous_map_of_separates_points":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- An alternative statement of the Stone-Weierstrass theorem,\nfor those who like their epsilons.\n\nIf `A` is a subalgebra of `C(X, â„)` which separates points (and `X` is compact),\nevery real-valued continuous function on `X` is within any `Îµ > 0` of some element of `A`.\n-/\ntheorem exists_mem_subalgebra_near_continuous_map_of_separates_points (A : subalgebra (exprâ„) (Â«exprC( , )Â» X (exprâ„)))\n    (w : A.separates_points) (f : Â«exprC( , )Â» X (exprâ„)) (Îµ : exprâ„) (pos : 0 < Îµ) :\n    âˆƒ g : A, Â«exprâ€– â€–Â» ((g : Â«exprC( , )Â» X (exprâ„)) - f) < Îµ :=\n  by\n  have w := mem_closure_iff_frequently.mp (continuous_map_mem_subalgebra_closure_of_separates_points A w f)\n  rw [metric.nhds_basis_ball.frequently_iff] at w\n  obtain âŸ¨g, H, mâŸ© := w Îµ pos\n  rw [metric.mem_ball, dist_eq_norm] at H\n  exact âŸ¨âŸ¨g, mâŸ©, HâŸ©\n#align\n  exists_mem_subalgebra_near_continuous_map_of_separates_points exists_mem_subalgebra_near_continuous_map_of_separates_points\n\n",
 "continuous_map_mem_subalgebra_closure_of_separates_points":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- An alternative statement of the Stone-Weierstrass theorem.\n\nIf `A` is a subalgebra of `C(X, â„)` which separates points (and `X` is compact),\nevery real-valued continuous function on `X` is a uniform limit of elements of `A`.\n-/\ntheorem continuous_map_mem_subalgebra_closure_of_separates_points (A : subalgebra (exprâ„) (Â«exprC( , )Â» X (exprâ„)))\n    (w : A.separates_points) (f : Â«exprC( , )Â» X (exprâ„)) : f âˆˆ A.topological_closure :=\n  by\n  rw [subalgebra_topological_closure_eq_top_of_separates_points A w]\n  simp\n#align\n  continuous_map_mem_subalgebra_closure_of_separates_points continuous_map_mem_subalgebra_closure_of_separates_points\n\n",
 "comp_attach_bound_mem_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem comp_attach_bound_mem_closure (A : subalgebra (exprâ„) (Â«exprC( , )Â» X (exprâ„))) (f : A)\n    (p : Â«exprC( , )Â» (Set.Icc (-Â«exprâ€– â€–Â» f) (Â«exprâ€– â€–Â» f)) (exprâ„)) :\n    p.comp (attach_bound f) âˆˆ A.topological_closure :=\n  by\n  -- `p` itself is in the closure of polynomials, by the Weierstrass theorem,\n  have mem_closure : p âˆˆ (polynomial_functions (Set.Icc (-Â«exprâ€– â€–Â» f) (Â«exprâ€– â€–Â» f))).topological_closure :=\n    continuous_map_mem_polynomial_functions_closure _ _ p\n  -- and so there are polynomials arbitrarily close.\n  have frequently_mem_polynomials := mem_closure_iff_frequently.mp mem_closure\n  -- To prove `p.comp (attached_bound f)` is in the closure of `A`,\n  -- we show there are elements of `A` arbitrarily close.\n  apply mem_closure_iff_frequently.mpr\n  -- To show that, we pull back the polynomials close to `p`,\n  refine'\n    ((comp_right_continuous_map (exprâ„) (attach_bound (f : Â«exprC( , )Â» X (exprâ„)))).continuous_at\n            p).tendsto.frequently_map\n      _ _ frequently_mem_polynomials\n  -- but need to show that those pullbacks are actually in `A`.\n  rintro _ âŸ¨g, âŸ¨-, rflâŸ©âŸ©\n  simp only [SetLike.mem_coe, alg_hom.coe_to_ring_hom, comp_right_continuous_map_apply,\n    polynomial.to_continuous_map_on_alg_hom_apply]\n  apply polynomial_comp_attach_bound_mem\n#align comp_attach_bound_mem_closure comp_attach_bound_mem_closure\n\n",
 "attach_bound_apply_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-\nCopyright (c) 2021 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Heather Macbeth\n-/\n@[simp]\ntheorem attach_bound_apply_coe (f : Â«exprC( , )Â» X (exprâ„)) (x : X) : ((attach_bound f) x : exprâ„) = f x :=\n  rfl\n#align attach_bound_apply_coe attach_bound_apply_coe\n\n",
 "abs_mem_subalgebra_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem abs_mem_subalgebra_closure (A : subalgebra (exprâ„) (Â«exprC( , )Â» X (exprâ„))) (f : A) :\n    (f : Â«exprC( , )Â» X (exprâ„)).abs âˆˆ A.topological_closure :=\n  by\n  let M := Â«exprâ€– â€–Â» f\n  let f' := attach_bound (f : Â«exprC( , )Â» X (exprâ„))\n  let abs : Â«exprC( , )Â» (Set.Icc (-Â«exprâ€– â€–Â» f) (Â«exprâ€– â€–Â» f)) (exprâ„) :=\n    { to_fun := fun x : Set.Icc (-Â«exprâ€– â€–Â» f) (Â«exprâ€– â€–Â» f) => |(x : exprâ„)| }\n  change abs.comp f' âˆˆ A.topological_closure\n  apply comp_attach_bound_mem_closure\n#align abs_mem_subalgebra_closure abs_mem_subalgebra_closure\n\n"}