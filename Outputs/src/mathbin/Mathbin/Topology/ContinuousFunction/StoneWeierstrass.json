{"sup_mem_subalgebra_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem sup_mem_subalgebra_closure (A : subalgebra (exprℝ) («exprC( , )» X (exprℝ))) (f g : A) :\n    «expr ⊔ » (f : «exprC( , )» X (exprℝ)) (g : «exprC( , )» X (exprℝ)) ∈ A.topological_closure :=\n  by\n  rw [sup_eq]\n  refine'\n    A.topological_closure.smul_mem\n      (A.topological_closure.add_mem\n        (A.topological_closure.add_mem (A.le_topological_closure f.property) (A.le_topological_closure g.property)) _)\n      _\n  exact_mod_cast abs_mem_subalgebra_closure A _\n#align sup_mem_subalgebra_closure sup_mem_subalgebra_closure\n\n",
 "sup_mem_closed_subalgebra":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem sup_mem_closed_subalgebra (A : subalgebra (exprℝ) («exprC( , )» X (exprℝ)))\n    (h : is_closed (A : set («exprC( , )» X (exprℝ)))) (f g : A) :\n    «expr ⊔ » (f : «exprC( , )» X (exprℝ)) (g : «exprC( , )» X (exprℝ)) ∈ A :=\n  by\n  convert sup_mem_subalgebra_closure A f g\n  apply SetLike.ext'\n  symm\n  erw [closure_eq_iff_is_closed]\n  exact h\n#align sup_mem_closed_subalgebra sup_mem_closed_subalgebra\n\n",
 "sublattice_closure_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (f g «expr ∈ » L) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (f g «expr ∈ » L) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n-- Here's the fun part of Stone-Weierstrass!\ntheorem sublattice_closure_eq_top (L : set («exprC( , )» X (exprℝ))) (nA : L.nonempty)\n    (inf_mem : ∀ (f) (_ : f ∈ L) (g) (_ : g ∈ L), «expr ⊓ » f g ∈ L)\n    (sup_mem : ∀ (f) (_ : f ∈ L) (g) (_ : g ∈ L), «expr ⊔ » f g ∈ L) (sep : L.separates_points_strongly) :\n    closure L = «expr⊤» :=\n  by\n  -- We start by boiling down to a statement about close approximation.\n  apply eq_top_iff.mpr\n  rintro f -\n  refine' filter.frequently.mem_closure ((filter.has_basis.frequently_iff metric.nhds_basis_ball).mpr fun ε pos => _)\n  simp only [exists_prop, metric.mem_ball]\n  -- It will be helpful to assume `X` is nonempty later,\n  -- so we get that out of the way here.\n  by_cases nX : nonempty X\n  swap\n  exact ⟨nA.some, (dist_lt_iff pos).mpr fun x => false.elim (nX ⟨x⟩), nA.some_spec⟩\n  /-\n    The strategy now is to pick a family of continuous functions `g x y` in `A`\n    with the property that `g x y x = f x` and `g x y y = f y`\n    (this is immediate from `h : separates_points_strongly`)\n    then use continuity to see that `g x y` is close to `f` near both `x` and `y`,\n    and finally using compactness to produce the desired function `h`\n    as a maximum over finitely many `x` of a minimum over finitely many `y` of the `g x y`.\n    -/\n  dsimp [set.separates_points_strongly] at sep\n  let g : X → X → L := fun x y => (sep f x y).some\n  have w₁ : ∀ x y, g x y x = f x := fun x y => (sep f x y).some_spec.1\n  have w₂ : ∀ x y, g x y y = f y := fun x y => (sep f x y).some_spec.2\n  -- For each `x y`, we define `U x y` to be `{z | f z - ε < g x y z}`,\n  -- and observe this is a neighbourhood of `y`.\n  let U : X → X → set X := fun x y => { z | f z - ε < g x y z }\n  have U_nhd_y : ∀ x y, U x y ∈ (nhds) y := by\n    intro x y\n    refine' is_open.mem_nhds _ _\n    · apply is_open_lt <;> continuity\n    · rw [Set.mem_setOf_eq, w₂]\n      exact sub_lt_self _ pos\n  -- Fixing `x` for a moment, we have a family of functions `λ y, g x y`\n  -- which on different patches (the `U x y`) are greater than `f z - ε`.\n  -- Taking the supremum of these functions\n  -- indexed by a finite collection of patches which cover `X`\n  -- will give us an element of `A` that is globally greater than `f z - ε`\n  -- and still equal to `f x` at `x`.\n  -- Since `X` is compact, for every `x` there is some finset `ys t`\n  -- so the union of the `U x y` for `y ∈ ys x` still covers everything.\n  let ys : ∀ x, Finset X := fun x => (compact_space.elim_nhds_subcover (U x) (U_nhd_y x)).some\n  let ys_w :\n    ∀ x,\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U x y) =\n        «expr⊤» :=\n    fun x => (compact_space.elim_nhds_subcover (U x) (U_nhd_y x)).some_spec\n  have ys_nonempty : ∀ x, (ys x).nonempty := fun x => Set.nonempty_of_union_eq_top_of_nonempty _ _ nX (ys_w x)\n  -- Thus for each `x` we have the desired `h x : A` so `f z - ε < h x z` everywhere\n  -- and `h x x = f x`.\n  let h : ∀ x, L := fun x =>\n    ⟨(ys x).sup' (ys_nonempty x) fun y => (g x y : «exprC( , )» X (exprℝ)),\n      finset.sup'_mem _ sup_mem _ _ _ fun y _ => (g x y).2⟩\n  have lt_h : ∀ x z, f z - ε < h x z := by\n    intro x z\n    obtain ⟨y, ym, zm⟩ := Set.exists_set_mem_of_union_eq_top _ _ (ys_w x) z\n    dsimp [h]\n    simp only [coe_fn_coe_base', subtype.coe_mk, sup'_coe, finset.sup'_apply, finset.lt_sup'_iff]\n    exact ⟨y, ym, zm⟩\n  have h_eq : ∀ x, h x x = f x := by\n    intro x\n    simp only [coe_fn_coe_base'] at w₁\n    simp [coe_fn_coe_base', w₁]\n  -- For each `x`, we define `W x` to be `{z | h x z < f z + ε}`,\n  let W : ∀ x, set X := fun x => { z | h x z < f z + ε }\n  -- This is still a neighbourhood of `x`.\n  have W_nhd : ∀ x, W x ∈ (nhds) x := by\n    intro x\n    refine' is_open.mem_nhds _ _\n    · apply is_open_lt <;> continuity\n    · dsimp only [W, Set.mem_setOf_eq]\n      rw [h_eq]\n      exact lt_add_of_pos_right _ pos\n  -- Since `X` is compact, there is some finset `ys t`\n  -- so the union of the `W x` for `x ∈ xs` still covers everything.\n  let xs : Finset X := (compact_space.elim_nhds_subcover W W_nhd).some\n  let xs_w :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (W x) = «expr⊤» :=\n    (compact_space.elim_nhds_subcover W W_nhd).some_spec\n  have xs_nonempty : xs.nonempty := Set.nonempty_of_union_eq_top_of_nonempty _ _ nX xs_w\n  -- Finally our candidate function is the infimum over `x ∈ xs` of the `h x`.\n  -- This function is then globally less than `f z + ε`.\n  let k : (L : Type _) :=\n    ⟨xs.inf' xs_nonempty fun x => (h x : «exprC( , )» X (exprℝ)), finset.inf'_mem _ inf_mem _ _ _ fun x _ => (h x).2⟩\n  refine' ⟨k.1, _, k.2⟩\n  -- We just need to verify the bound, which we do pointwise.\n  rw [dist_lt_iff pos]\n  intro z\n  -- We rewrite into this particular form,\n  -- so that simp lemmas about inequalities involving `finset.inf'` can fire.\n  rw [show ∀ a b ε : exprℝ, dist a b < ε ↔ a < b + ε ∧ b - ε < a\n      by\n      intros\n      simp only [← metric.mem_ball, real.ball_eq_Ioo, Set.mem_Ioo, and_comm']]\n  fconstructor\n  · dsimp [k]\n    simp only [finset.inf'_lt_iff, continuous_map.inf'_apply]\n    exact Set.exists_set_mem_of_union_eq_top _ _ xs_w z\n  · dsimp [k]\n    simp only [finset.lt_inf'_iff, continuous_map.inf'_apply]\n    intro x xm\n    apply lt_h\n#align sublattice_closure_eq_top sublattice_closure_eq_top\n\n",
 "subalgebra_topological_closure_eq_top_of_separates_points":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The **Stone-Weierstrass Approximation Theorem**,\nthat a subalgebra `A` of `C(X, ℝ)`, where `X` is a compact topological space,\nis dense if it separates points.\n-/\ntheorem subalgebra_topological_closure_eq_top_of_separates_points (A : subalgebra (exprℝ) («exprC( , )» X (exprℝ)))\n    (w : A.separates_points) : A.topological_closure = «expr⊤» :=\n  by\n  -- The closure of `A` is closed under taking `sup` and `inf`,\n  -- and separates points strongly (since `A` does),\n  -- so we can apply `sublattice_closure_eq_top`.\n  apply SetLike.ext'\n  let L := A.topological_closure\n  have n : Set.Nonempty (L : set («exprC( , )» X (exprℝ))) :=\n    ⟨(1 : «exprC( , )» X (exprℝ)), A.le_topological_closure A.one_mem⟩\n  convert\n    sublattice_closure_eq_top (L : set («exprC( , )» X (exprℝ))) n\n      (fun f fm g gm => inf_mem_closed_subalgebra L A.is_closed_topological_closure ⟨f, fm⟩ ⟨g, gm⟩)\n      (fun f fm g gm => sup_mem_closed_subalgebra L A.is_closed_topological_closure ⟨f, fm⟩ ⟨g, gm⟩)\n      (subalgebra.separates_points.strongly (subalgebra.separates_points_monotone A.le_topological_closure w))\n  · simp\n#align\n  subalgebra_topological_closure_eq_top_of_separates_points subalgebra_topological_closure_eq_top_of_separates_points\n\n",
 "subalgebra_is_R_or_C_topological_closure_eq_top_of_separates_points":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The Stone-Weierstrass approximation theorem, `is_R_or_C` version,\nthat a subalgebra `A` of `C(X, 𝕜)`, where `X` is a compact topological space and `is_R_or_C 𝕜`,\nis dense if it is conjugation-invariant and separates points.\n-/\ntheorem continuous_map.subalgebra_is_R_or_C_topological_closure_eq_top_of_separates_points\n    (A : subalgebra 𝕜 («exprC( , )» X 𝕜)) (hA : A.separates_points)\n    (hA' : conj_invariant_subalgebra (A.restrict_scalars (exprℝ))) : A.topological_closure = «expr⊤» :=\n  by\n  rw [algebra.eq_top_iff]\n  -- Let `I` be the natural inclusion of `C(X, ℝ)` into `C(X, 𝕜)`\n  let I : «expr →ₗ[ ] » («exprC( , )» X (exprℝ)) (exprℝ) («exprC( , )» X 𝕜) :=\n    of_real_clm.comp_left_continuous (exprℝ) X\n  -- The main point of the proof is that its range (i.e., every real-valued function) is contained\n  -- in the closure of `A`\n  have key : I.range ≤ (A.to_submodule.restrict_scalars (exprℝ)).topological_closure :=\n    by\n    -- Let `A₀` be the subalgebra of `C(X, ℝ)` consisting of `A`'s purely real elements; it is the\n    -- preimage of `A` under `I`.  In this argument we only need its submodule structure.\n    let A₀ : submodule (exprℝ) («exprC( , )» X (exprℝ)) := (A.to_submodule.restrict_scalars (exprℝ)).comap I\n    -- By `subalgebra.separates_points.complex_to_real`, this subalgebra also separates points, so\n    -- we may apply the real Stone-Weierstrass result to it.\n    have SW : A₀.topological_closure = «expr⊤» :=\n      haveI := subalgebra_topological_closure_eq_top_of_separates_points _ (hA.is_R_or_C_to_real hA')\n      congr_arg subalgebra.to_submodule this\n    rw [← submodule.map_top, ← SW]\n    -- So it suffices to prove that the image under `I` of the closure of `A₀` is contained in the\n    -- closure of `A`, which follows by abstract nonsense\n    have h₁ := A₀.topological_closure_map ((@of_real_clm 𝕜 _).comp_left_continuous_compact X)\n    have h₂ := (A.to_submodule.restrict_scalars (exprℝ)).map_comap_le I\n    exact h₁.trans (submodule.topological_closure_mono h₂)\n  -- In particular, for a function `f` in `C(X, 𝕜)`, the real and imaginary parts of `f` are in the\n  -- closure of `A`\n  intro f\n  let f_re : «exprC( , )» X (exprℝ) := (⟨is_R_or_C.re, is_R_or_C.re_clm.continuous⟩ : «exprC( , )» 𝕜 (exprℝ)).comp f\n  let f_im : «exprC( , )» X (exprℝ) := (⟨is_R_or_C.im, is_R_or_C.im_clm.continuous⟩ : «exprC( , )» 𝕜 (exprℝ)).comp f\n  have h_f_re : I f_re ∈ A.topological_closure := key ⟨f_re, rfl⟩\n  have h_f_im : I f_im ∈ A.topological_closure := key ⟨f_im, rfl⟩\n  -- So `f_re + I • f_im` is in the closure of `A`\n  convert A.topological_closure.add_mem h_f_re (A.topological_closure.smul_mem h_f_im is_R_or_C.I)\n  -- And this, of course, is just `f`\n  ext\n  apply eq.symm\n  simp [I, mul_comm is_R_or_C.I _]\n#align\n  continuous_map.subalgebra_is_R_or_C_topological_closure_eq_top_of_separates_points continuous_map.subalgebra_is_R_or_C_topological_closure_eq_top_of_separates_points\n\n",
 "subalgebra_conj_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If a set `S` is conjugation-invariant, then its `𝕜`-span is conjugation-invariant. -/\ntheorem subalgebra_conj_invariant {S : set («exprC( , )» X 𝕜)}\n    (hS : ∀ f, f ∈ S → (conj_ae.to_alg_hom.comp_left_continuous (exprℝ) conj_cle.continuous) f ∈ S) :\n    conj_invariant_subalgebra ((algebra.adjoin 𝕜 S).restrict_scalars (exprℝ)) :=\n  by\n  rintro _ ⟨f, hf, rfl⟩\n  change _ ∈ (algebra.adjoin 𝕜 S).restrict_scalars (exprℝ)\n  change _ ∈ (algebra.adjoin 𝕜 S).restrict_scalars (exprℝ) at hf\n  rw [subalgebra.mem_restrict_scalars] at hf⊢\n  apply algebra.adjoin_induction hf\n  · exact fun g hg => algebra.subset_adjoin (hS g hg)\n  · exact fun c => subalgebra.algebra_map_mem _ (starRingEnd 𝕜 c)\n  · intro f g hf hg\n    convert subalgebra.add_mem _ hf hg\n    exact alg_hom.map_add _ f g\n  · intro f g hf hg\n    convert subalgebra.mul_mem _ hf hg\n    exact alg_hom.map_mul _ f g\n#align subalgebra_conj_invariant subalgebra_conj_invariant\n\n",
 "polynomial_comp_attach_bound_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Given a continuous function `f` in a subalgebra of `C(X, ℝ)`, postcomposing by a polynomial\ngives another function in `A`.\n\nThis lemma proves something slightly more subtle than this:\nwe take `f`, and think of it as a function into the restricted target `set.Icc (-‖f‖) ‖f‖)`,\nand then postcompose with a polynomial function on that interval.\nThis is in fact the same situation as above, and so also gives a function in `A`.\n-/\ntheorem polynomial_comp_attach_bound_mem (A : subalgebra (exprℝ) («exprC( , )» X (exprℝ))) (f : A)\n    (g : polynomial (exprℝ)) :\n    (g.to_continuous_map_on (Set.Icc (-«expr‖ ‖» f) («expr‖ ‖» f))).comp (f : «exprC( , )» X (exprℝ)).attach_bound ∈\n      A :=\n  by\n  rw [polynomial_comp_attach_bound]\n  apply SetLike.coe_mem\n#align polynomial_comp_attach_bound_mem polynomial_comp_attach_bound_mem\n\n",
 "polynomial_comp_attach_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem polynomial_comp_attach_bound (A : subalgebra (exprℝ) («exprC( , )» X (exprℝ))) (f : A)\n    (g : polynomial (exprℝ)) :\n    (g.to_continuous_map_on (Set.Icc (-«expr‖ ‖» f) («expr‖ ‖» f))).comp (f : «exprC( , )» X (exprℝ)).attach_bound =\n      polynomial.aeval f g :=\n  by\n  ext\n  simp only [continuous_map.coe_comp, Function.comp_apply, continuous_map.attach_bound_apply_coe,\n    polynomial.to_continuous_map_on_apply, polynomial.aeval_subalgebra_coe, polynomial.aeval_continuous_map_apply,\n    polynomial.to_continuous_map_apply]\n#align polynomial_comp_attach_bound polynomial_comp_attach_bound\n\n",
 "mem_conj_invariant_subalgebra":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n-- Redefine `X`, since for the next few lemmas it need not be compact\ntheorem mem_conj_invariant_subalgebra {A : subalgebra (exprℝ) («exprC( , )» X 𝕜)} (hA : conj_invariant_subalgebra A)\n    {f : «exprC( , )» X 𝕜} (hf : f ∈ A) : (conj_ae.to_alg_hom.comp_left_continuous (exprℝ) conj_cle.continuous) f ∈ A :=\n  hA ⟨f, hf, rfl⟩\n#align mem_conj_invariant_subalgebra mem_conj_invariant_subalgebra\n\n",
 "is_R_or_C_to_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If a conjugation-invariant subalgebra of `C(X, 𝕜)` separates points, then the real subalgebra\nof its purely real-valued elements also separates points. -/\ntheorem subalgebra.separates_points.is_R_or_C_to_real {A : subalgebra 𝕜 («exprC( , )» X 𝕜)} (hA : A.separates_points)\n    (hA' : conj_invariant_subalgebra (A.restrict_scalars (exprℝ))) :\n    ((A.restrict_scalars (exprℝ)).comap\n        (of_real_am.comp_left_continuous (exprℝ) continuous_of_real)).separates_points :=\n  by\n  intro x₁ x₂ hx\n  -- Let `f` in the subalgebra `A` separate the points `x₁`, `x₂`\n  obtain ⟨_, ⟨f, hfA, rfl⟩, hf⟩ := hA hx\n  let F : «exprC( , )» X 𝕜 := f - const _ (f x₂)\n  -- Subtract the constant `f x₂` from `f`; this is still an element of the subalgebra\n  have hFA : F ∈ A :=\n    by\n    refine' A.sub_mem hfA (@eq.subst _ (· ∈ A) _ _ _ <| A.smul_mem A.one_mem <| f x₂)\n    ext1\n    simp only [coe_smul, coe_one, pi.smul_apply, pi.one_apply, algebra.id.smul_eq_mul, mul_one, const_apply]\n  -- Consider now the function `λ x, |f x - f x₂| ^ 2`\n  refine' ⟨_, ⟨(⟨is_R_or_C.norm_sq, continuous_norm_sq⟩ : «exprC( , )» 𝕜 (exprℝ)).comp F, _, rfl⟩, _⟩\n  · -- This is also an element of the subalgebra, and takes only real values\n    rw [SetLike.mem_coe, subalgebra.mem_comap]\n    convert (A.restrict_scalars (exprℝ)).mul_mem (mem_conj_invariant_subalgebra hA' hFA) hFA\n    ext1\n    rw [mul_comm]\n    exact (is_R_or_C.mul_conj _).symm\n  · -- And it also separates the points `x₁`, `x₂`\n    have : f x₁ - f x₂ ≠ 0 := sub_ne_zero.mpr hf\n    simpa only [comp_apply, coe_sub, coe_const, pi.sub_apply, coe_mk, sub_self, map_zero, ne.def, norm_sq_eq_zero] using\n      this\n#align subalgebra.separates_points.is_R_or_C_to_real subalgebra.separates_points.is_R_or_C_to_real\n\n",
 "inf_mem_subalgebra_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem inf_mem_subalgebra_closure (A : subalgebra (exprℝ) («exprC( , )» X (exprℝ))) (f g : A) :\n    «expr ⊓ » (f : «exprC( , )» X (exprℝ)) (g : «exprC( , )» X (exprℝ)) ∈ A.topological_closure :=\n  by\n  rw [inf_eq]\n  refine'\n    A.topological_closure.smul_mem\n      (A.topological_closure.sub_mem\n        (A.topological_closure.add_mem (A.le_topological_closure f.property) (A.le_topological_closure g.property)) _)\n      _\n  exact_mod_cast abs_mem_subalgebra_closure A _\n#align inf_mem_subalgebra_closure inf_mem_subalgebra_closure\n\n",
 "inf_mem_closed_subalgebra":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem inf_mem_closed_subalgebra (A : subalgebra (exprℝ) («exprC( , )» X (exprℝ)))\n    (h : is_closed (A : set («exprC( , )» X (exprℝ)))) (f g : A) :\n    «expr ⊓ » (f : «exprC( , )» X (exprℝ)) (g : «exprC( , )» X (exprℝ)) ∈ A :=\n  by\n  convert inf_mem_subalgebra_closure A f g\n  apply SetLike.ext'\n  symm\n  erw [closure_eq_iff_is_closed]\n  exact h\n#align inf_mem_closed_subalgebra inf_mem_closed_subalgebra\n\n",
 "exists_mem_subalgebra_near_continuous_of_separates_points":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- An alternative statement of the Stone-Weierstrass theorem,\nfor those who like their epsilons and don't like bundled continuous functions.\n\nIf `A` is a subalgebra of `C(X, ℝ)` which separates points (and `X` is compact),\nevery real-valued continuous function on `X` is within any `ε > 0` of some element of `A`.\n-/\ntheorem exists_mem_subalgebra_near_continuous_of_separates_points (A : subalgebra (exprℝ) («exprC( , )» X (exprℝ)))\n    (w : A.separates_points) (f : X → exprℝ) (c : continuous f) (ε : exprℝ) (pos : 0 < ε) :\n    ∃ g : A, ∀ x, «expr‖ ‖» (g x - f x) < ε :=\n  by\n  obtain ⟨g, b⟩ := exists_mem_subalgebra_near_continuous_map_of_separates_points A w ⟨f, c⟩ ε pos\n  use g\n  rwa [norm_lt_iff _ pos] at b\n#align\n  exists_mem_subalgebra_near_continuous_of_separates_points exists_mem_subalgebra_near_continuous_of_separates_points\n\n",
 "exists_mem_subalgebra_near_continuous_map_of_separates_points":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- An alternative statement of the Stone-Weierstrass theorem,\nfor those who like their epsilons.\n\nIf `A` is a subalgebra of `C(X, ℝ)` which separates points (and `X` is compact),\nevery real-valued continuous function on `X` is within any `ε > 0` of some element of `A`.\n-/\ntheorem exists_mem_subalgebra_near_continuous_map_of_separates_points (A : subalgebra (exprℝ) («exprC( , )» X (exprℝ)))\n    (w : A.separates_points) (f : «exprC( , )» X (exprℝ)) (ε : exprℝ) (pos : 0 < ε) :\n    ∃ g : A, «expr‖ ‖» ((g : «exprC( , )» X (exprℝ)) - f) < ε :=\n  by\n  have w := mem_closure_iff_frequently.mp (continuous_map_mem_subalgebra_closure_of_separates_points A w f)\n  rw [metric.nhds_basis_ball.frequently_iff] at w\n  obtain ⟨g, H, m⟩ := w ε pos\n  rw [metric.mem_ball, dist_eq_norm] at H\n  exact ⟨⟨g, m⟩, H⟩\n#align\n  exists_mem_subalgebra_near_continuous_map_of_separates_points exists_mem_subalgebra_near_continuous_map_of_separates_points\n\n",
 "continuous_map_mem_subalgebra_closure_of_separates_points":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- An alternative statement of the Stone-Weierstrass theorem.\n\nIf `A` is a subalgebra of `C(X, ℝ)` which separates points (and `X` is compact),\nevery real-valued continuous function on `X` is a uniform limit of elements of `A`.\n-/\ntheorem continuous_map_mem_subalgebra_closure_of_separates_points (A : subalgebra (exprℝ) («exprC( , )» X (exprℝ)))\n    (w : A.separates_points) (f : «exprC( , )» X (exprℝ)) : f ∈ A.topological_closure :=\n  by\n  rw [subalgebra_topological_closure_eq_top_of_separates_points A w]\n  simp\n#align\n  continuous_map_mem_subalgebra_closure_of_separates_points continuous_map_mem_subalgebra_closure_of_separates_points\n\n",
 "comp_attach_bound_mem_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem comp_attach_bound_mem_closure (A : subalgebra (exprℝ) («exprC( , )» X (exprℝ))) (f : A)\n    (p : «exprC( , )» (Set.Icc (-«expr‖ ‖» f) («expr‖ ‖» f)) (exprℝ)) :\n    p.comp (attach_bound f) ∈ A.topological_closure :=\n  by\n  -- `p` itself is in the closure of polynomials, by the Weierstrass theorem,\n  have mem_closure : p ∈ (polynomial_functions (Set.Icc (-«expr‖ ‖» f) («expr‖ ‖» f))).topological_closure :=\n    continuous_map_mem_polynomial_functions_closure _ _ p\n  -- and so there are polynomials arbitrarily close.\n  have frequently_mem_polynomials := mem_closure_iff_frequently.mp mem_closure\n  -- To prove `p.comp (attached_bound f)` is in the closure of `A`,\n  -- we show there are elements of `A` arbitrarily close.\n  apply mem_closure_iff_frequently.mpr\n  -- To show that, we pull back the polynomials close to `p`,\n  refine'\n    ((comp_right_continuous_map (exprℝ) (attach_bound (f : «exprC( , )» X (exprℝ)))).continuous_at\n            p).tendsto.frequently_map\n      _ _ frequently_mem_polynomials\n  -- but need to show that those pullbacks are actually in `A`.\n  rintro _ ⟨g, ⟨-, rfl⟩⟩\n  simp only [SetLike.mem_coe, alg_hom.coe_to_ring_hom, comp_right_continuous_map_apply,\n    polynomial.to_continuous_map_on_alg_hom_apply]\n  apply polynomial_comp_attach_bound_mem\n#align comp_attach_bound_mem_closure comp_attach_bound_mem_closure\n\n",
 "attach_bound_apply_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2021 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Heather Macbeth\n-/\n@[simp]\ntheorem attach_bound_apply_coe (f : «exprC( , )» X (exprℝ)) (x : X) : ((attach_bound f) x : exprℝ) = f x :=\n  rfl\n#align attach_bound_apply_coe attach_bound_apply_coe\n\n",
 "abs_mem_subalgebra_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem abs_mem_subalgebra_closure (A : subalgebra (exprℝ) («exprC( , )» X (exprℝ))) (f : A) :\n    (f : «exprC( , )» X (exprℝ)).abs ∈ A.topological_closure :=\n  by\n  let M := «expr‖ ‖» f\n  let f' := attach_bound (f : «exprC( , )» X (exprℝ))\n  let abs : «exprC( , )» (Set.Icc (-«expr‖ ‖» f) («expr‖ ‖» f)) (exprℝ) :=\n    { to_fun := fun x : Set.Icc (-«expr‖ ‖» f) («expr‖ ‖» f) => |(x : exprℝ)| }\n  change abs.comp f' ∈ A.topological_closure\n  apply comp_attach_bound_mem_closure\n#align abs_mem_subalgebra_closure abs_mem_subalgebra_closure\n\n"}