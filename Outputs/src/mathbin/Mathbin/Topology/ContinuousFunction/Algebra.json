{"zpow_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n-- don't make auto-generated `coe_zsmul` and `zsmul_apply` simp as the linter complains they're\n-- redundant WRT `coe_smul`\n@[to_additive]\ntheorem zpow_comp [Group γ] [TopologicalGroup γ] (f : «exprC( , )» β γ) (z : ℤ) (g : «exprC( , )» α β) :\n    (f ^ z).comp g = f.comp g ^ z :=\n  rfl\n#align zpow_comp zpow_comp\n\n",
 "zpow_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[to_additive]\ntheorem zpow_apply [Group β] [TopologicalGroup β] (f : «exprC( , )» α β) (z : ℤ) (x : α) : (f ^ z) x = f x ^ z :=\n  rfl\n#align zpow_apply zpow_apply\n\n",
 "tsum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n#print tsum_apply /-\ntheorem tsum_apply [LocallyCompactSpace α] [T2Space β] [AddCommMonoid β] [ContinuousAdd β] {γ : Type _}\n    {f : γ → «exprC( , )» α β} (hf : Summable f) (x : α) :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (f i x) =\n      («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (f i)) x :=\n  (hasSum_apply hf.has_sum x).tsum_eq\n#align tsum_apply tsum_apply\n-/\n\n",
 "sup_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- Not sure why this is grosser than `inf_eq`:\ntheorem sup_eq (f g : «exprC( , )» α β) : «expr ⊔ » f g = «expr • » (2⁻¹ : β) (f + g + |f - g|) :=\n  ext fun x => by simpa [mul_add] using @max_eq_half_add_add_abs_sub _ _ (f x) (g x)\n#align sup_eq sup_eq\n\n",
 "summable_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem summable_apply [LocallyCompactSpace α] [AddCommMonoid β] [ContinuousAdd β] {γ : Type _}\n    {f : γ → «exprC( , )» α β} (hf : Summable f) (x : α) : Summable fun i : γ => f i x :=\n  (hasSum_apply hf.has_sum x).summable\n#align summable_apply summable_apply\n\n",
 "strongly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n#print Subalgebra.SeparatesPoints.strongly /-\n/-- Working in continuous functions into a topological field,\na subalgebra of functions that separates points also separates points strongly.\n\nBy the hypothesis, we can find a function `f` so `f x ≠ f y`.\nBy an affine transformation in the field we can arrange so that `f x = a` and `f x = b`.\n-/\ntheorem Subalgebra.SeparatesPoints.strongly {s : Subalgebra 𝕜 («exprC( , )» α 𝕜)} (h : s.separates_points) :\n    (s : Set («exprC( , )» α 𝕜)).separates_points_strongly := fun v x y =>\n  by\n  by_cases n : x = y\n  · subst n\n    refine' ⟨_, («expr • » (v x) 1 : s).prop, mul_one _, mul_one _⟩\n  obtain ⟨_, ⟨f, hf, rfl⟩, hxy⟩ := h n\n  replace hxy : f x - f y ≠ 0 := sub_ne_zero_of_ne hxy\n  let a := v x\n  let b := v y\n  let f' : s := «expr • » ((b - a) * (f x - f y)⁻¹) (algebraMap _ _ (f x) - ⟨f, hf⟩) + algebraMap _ _ a\n  refine' ⟨f', f'.prop, _, _⟩\n  · simp [f']\n  · simp [f', inv_mul_cancel_right₀ hxy]\n#align subalgebra.separates_points.strongly Subalgebra.SeparatesPoints.strongly\n-/\n\n",
 "star_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp]\ntheorem star_apply (f : «exprC( , )» α β) (x : α) : star f x = star (f x) :=\n  rfl\n#align star_apply star_apply\n\n",
 "smul_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem smul_comp [SMul R M] [ContinuousConstSMul R M] (r : R) (f : «exprC( , )» β M) (g : «exprC( , )» α β) :\n    («expr • » r f).comp g = «expr • » r (f.comp g) :=\n  rfl\n#align smul_comp smul_comp\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_apply [SMul R M] [ContinuousConstSMul R M] (c : R) (f : «exprC( , )» α M) (a : α) :\n    («expr • » c f) a = «expr • » c (f a) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "separatesPoints_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n#print Subalgebra.separatesPoints_monotone /-\ntheorem Subalgebra.separatesPoints_monotone : Monotone fun s : Subalgebra R («exprC( , )» α A) => s.separates_points :=\n  fun s s' r h x y n => by\n  obtain ⟨f, m, w⟩ := h n\n  rcases m with ⟨f, ⟨m, rfl⟩⟩\n  exact ⟨_, ⟨f, ⟨r m, rfl⟩⟩, w⟩\n#align subalgebra.separates_points_monotone Subalgebra.separatesPoints_monotone\n-/\n\n",
 "prod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_apply [CommMonoid β] [ContinuousMul β] {ι : Type _} (s : Finset ι) (f : ι → «exprC( , )» α β) (a : α) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) a =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a) :=\n  by simp\n#align prod_apply prod_apply\n\n",
 "pow_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n-- don't make auto-generated `coe_nsmul` and `nsmul_apply` simp, as the linter complains they're\n-- redundant WRT `coe_smul`\n@[to_additive]\ntheorem pow_comp [Monoid γ] [ContinuousMul γ] (f : «exprC( , )» β γ) (n : ℕ) (g : «exprC( , )» α β) :\n    (f ^ n).comp g = f.comp g ^ n :=\n  rfl\n#align pow_comp pow_comp\n\n",
 "pow_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[to_additive]\ntheorem pow_apply [Monoid β] [ContinuousMul β] (f : «exprC( , )» α β) (n : ℕ) (x : α) : (f ^ n) x = f x ^ n :=\n  rfl\n#align pow_apply pow_apply\n\n",
 "periodic_tsum_comp_add_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Summing the translates of `f` by `ℤ • p` gives a map which is periodic with period `p`.\n(This is true without any convergence conditions, since if the sum doesn't converge it is taken to\nbe the zero map, which is periodic.) -/\ntheorem periodic_tsum_comp_add_zsmul [LocallyCompactSpace X] [AddCommGroup X] [TopologicalAddGroup X] [AddCommMonoid Y]\n    [ContinuousAdd Y] [T2Space Y] (f : «exprC( , )» X Y) (p : X) :\n    Function.Periodic\n      («expr⇑ »\n        («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (f.comp (ContinuousMap.addRight («expr • » n p)))))\n      p :=\n  by\n  intro x\n  by_cases h : Summable fun n : ℤ => f.comp (ContinuousMap.addRight («expr • » n p))\n  · convert congr_arg (fun f : «exprC( , )» X Y => f x) ((Equiv.addRight (1 : ℤ)).tsum_eq _) using 1\n    simp_rw [← tsum_apply h, ← tsum_apply ((Equiv.addRight (1 : ℤ)).summable_iff.mpr h), Equiv.coe_addRight, comp_apply,\n      coe_add_right, add_one_zsmul, add_comm («expr • » _ p) p, ← add_assoc]\n  · rw [tsum_eq_zero_of_not_summable h]\n    simp only [coe_zero, Pi.zero_apply]\n#align periodic_tsum_comp_add_zsmul periodic_tsum_comp_add_zsmul\n\n",
 "one_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp, to_additive]\ntheorem one_comp [One γ] (g : «exprC( , )» α β) : (1 : «exprC( , )» β γ).comp g = 1 :=\n  rfl\n#align one_comp one_comp\n\n",
 "one_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp, to_additive]\ntheorem one_apply [One β] (x : α) : (1 : «exprC( , )» α β) x = 1 :=\n  rfl\n#align one_apply one_apply\n\n",
 "nat_cast_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp]\ntheorem nat_cast_apply [NatCast β] (n : ℕ) (x : α) : (n : «exprC( , )» α β) x = n :=\n  rfl\n#align nat_cast_apply nat_cast_apply\n\n",
 "mul_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp, to_additive]\ntheorem mul_comp [Mul γ] [ContinuousMul γ] (f₁ f₂ : «exprC( , )» β γ) (g : «exprC( , )» α β) :\n    (f₁ * f₂).comp g = f₁.comp g * f₂.comp g :=\n  rfl\n#align mul_comp mul_comp\n\n",
 "mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp, to_additive]\ntheorem mul_apply [Mul β] [ContinuousMul β] (f g : «exprC( , )» α β) (x : α) : (f * g) x = f x * g x :=\n  rfl\n#align mul_apply mul_apply\n\n",
 "min_eq_half_add_sub_abs_sub":
 "#print min_eq_half_add_sub_abs_sub /-\n-- TODO:\n-- This lemma (and the next) could go all the way back in `algebra.order.field`,\n-- except that it is tedious to prove without tactics.\n-- Rather than stranding it at some intermediate location,\n-- it's here, immediately prior to the point of use.\ntheorem min_eq_half_add_sub_abs_sub {x y : R} : min x y = 2⁻¹ * (x + y - |x - y|) := by\n  cases' le_total x y with h h <;> field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two] <;> abel\n#align min_eq_half_add_sub_abs_sub min_eq_half_add_sub_abs_sub\n-/\n\n",
 "max_eq_half_add_add_abs_sub":
 "#print max_eq_half_add_add_abs_sub /-\ntheorem max_eq_half_add_add_abs_sub {x y : R} : max x y = 2⁻¹ * (x + y + |x - y|) := by\n  cases' le_total x y with h h <;> field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two] <;> abel\n#align max_eq_half_add_add_abs_sub max_eq_half_add_add_abs_sub\n-/\n\n",
 "inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp, to_additive]\ntheorem inv_comp [Group γ] [TopologicalGroup γ] (f : «exprC( , )» β γ) (g : «exprC( , )» α β) :\n    f⁻¹.comp g = (f.comp g)⁻¹ :=\n  rfl\n#align inv_comp inv_comp\n\n",
 "inv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp, to_additive]\ntheorem inv_apply [Group β] [TopologicalGroup β] (f : «exprC( , )» α β) (x : α) : f⁻¹ x = (f x)⁻¹ :=\n  rfl\n#align inv_apply inv_apply\n\n",
 "int_cast_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp]\ntheorem int_cast_apply [IntCast β] (n : ℤ) (x : α) : (n : «exprC( , )» α β) x = n :=\n  rfl\n#align int_cast_apply int_cast_apply\n\n",
 "inf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem inf_eq (f g : «exprC( , )» α β) : «expr ⊓ » f g = «expr • » (2⁻¹ : β) (f + g - |f - g|) :=\n  ext fun x => by simpa using min_eq_half_add_sub_abs_sub\n#align inf_eq inf_eq\n\n",
 "has_sum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n-- TODO: rewrite the next three lemmas for products and deduce sum case via `to_additive`, once\n-- definition of `tprod` is in place\n/-- If `α` is locally compact, and an infinite sum of functions in `C(α, β)`\nconverges to `g` (for the compact-open topology), then the pointwise sum converges to `g x` for\nall `x ∈ α`. -/\ntheorem has_sum_apply {γ : Type _} [LocallyCompactSpace α] [AddCommMonoid β] [ContinuousAdd β]\n    {f : γ → «exprC( , )» α β} {g : «exprC( , )» α β} (hf : HasSum f g) (x : α) : HasSum (fun i : γ => f i x) (g x) :=\n  by\n  let evₓ : AddMonoidHom («exprC( , )» α β) β := (Pi.evalAddMonoidHom _ x).comp coe_fn_add_monoid_hom\n  exact hf.map evₓ (ContinuousMap.continuous_eval_const' x)\n#align has_sum_apply has_sum_apply\n\n",
 "div_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp, to_additive]\ntheorem div_comp [Div γ] [ContinuousDiv γ] (f g : «exprC( , )» β γ) (h : «exprC( , )» α β) :\n    (f / g).comp h = f.comp h / g.comp h :=\n  rfl\n#align div_comp div_comp\n\n",
 "div_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp, to_additive]\ntheorem div_apply [Div β] [ContinuousDiv β] (f g : «exprC( , )» α β) (x : α) : (f / g) x = f x / g x :=\n  rfl\n#align div_apply div_apply\n\n",
 "comp_star_alg_hom'_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- `continuous_map.comp_star_alg_hom'` sends the identity continuous map to the identity\n`star_alg_hom` -/\ntheorem comp_star_alg_hom'_id : compStarAlgHom' 𝕜 A (ContinuousMap.id X) = StarAlgHom.id 𝕜 («exprC( , )» X A) :=\n  StarAlgHom.ext fun _ => ContinuousMap.ext fun _ => rfl\n#align comp_star_alg_hom'_id comp_star_alg_hom'_id\n\n",
 "comp_star_alg_hom'_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- `continuous_map.comp_star_alg_hom` is functorial. -/\ntheorem comp_star_alg_hom'_comp (g : «exprC( , )» Y Z) (f : «exprC( , )» X Y) :\n    compStarAlgHom' 𝕜 A (g.comp f) = (compStarAlgHom' 𝕜 A f).comp (compStarAlgHom' 𝕜 A g) :=\n  StarAlgHom.ext fun _ => ContinuousMap.ext fun _ => rfl\n#align comp_star_alg_hom'_comp comp_star_alg_hom'_comp\n\n",
 "coe_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n-- ### \"zpow\" and \"zsmul\"\n@[norm_cast, to_additive]\ntheorem coe_zpow [Group β] [TopologicalGroup β] (f : «exprC( , )» α β) (z : ℤ) : «expr⇑ » (f ^ z) = f ^ z :=\n  rfl\n#align coe_zpow coe_zpow\n\n",
 "coe_star":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_star (f : «exprC( , )» α β) : «expr⇑ » (star f) = star f :=\n  rfl\n#align coe_star coe_star\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, norm_cast, to_additive]\ntheorem coe_smul [SMul R M] [ContinuousConstSMul R M] (c : R) (f : «exprC( , )» α M) :\n    «expr⇑ » («expr • » c f) = «expr • » c f :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n-- don't make `zsmul_comp` simp as the linter complains it's redundant WRT `smul_comp`\n@[simp, to_additive]\ntheorem coe_prod [CommMonoid β] [ContinuousMul β] {ι : Type _} (s : Finset ι) (f : ι → «exprC( , )» α β) :\n    «expr⇑ »\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (f i : α → β) :=\n  (coeFnMonoidHom : «expr →* » («exprC( , )» α β) _).map_prod f s\n#align coe_prod coe_prod\n\n",
 "coe_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n-- ### \"nsmul\" and \"pow\"\n@[norm_cast, to_additive]\ntheorem coe_pow [Monoid β] [ContinuousMul β] (f : «exprC( , )» α β) (n : ℕ) : «expr⇑ » (f ^ n) = f ^ n :=\n  rfl\n#align coe_pow coe_pow\n\n",
 "coe_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n-- ### \"one\"\n@[simp, norm_cast, to_additive]\ntheorem coe_one [One β] : «expr⇑ » (1 : «exprC( , )» α β) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_nat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n-- ### \"nat_cast\"\n@[simp, norm_cast]\ntheorem coe_nat_cast [NatCast β] (n : ℕ) : ((n : «exprC( , )» α β) : α → β) = n :=\n  rfl\n#align coe_nat_cast coe_nat_cast\n\n",
 "coe_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Nicolò Cavalleri\n-/\n-- ### \"mul\" and \"add\"\n@[simp, norm_cast, to_additive]\ntheorem coe_mul [Mul β] [ContinuousMul β] (f g : «exprC( , )» α β) : «expr⇑ » (f * g) = f * g :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n-- don't make `nsmul_comp` simp as the linter complains it's redundant WRT `smul_comp`\n-- ### \"inv\" and \"neg\"\n@[simp, norm_cast, to_additive]\ntheorem coe_inv [Group β] [TopologicalGroup β] (f : «exprC( , )» α β) : «expr⇑ » f⁻¹ = f⁻¹ :=\n  rfl\n#align coe_inv coe_inv\n\n",
 "coe_int_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n-- ### \"int_cast\"\n@[simp, norm_cast]\ntheorem coe_int_cast [IntCast β] (n : ℤ) : ((n : «exprC( , )» α β) : α → β) = n :=\n  rfl\n#align coe_int_cast coe_int_cast\n\n",
 "coe_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n-- ### \"div\" and \"sub\"\n@[simp, norm_cast, to_additive]\ntheorem coe_div [Div β] [ContinuousDiv β] (f g : «exprC( , )» α β) : «expr⇑ » (f / g) = f / g :=\n  rfl\n#align coe_div coe_div\n\n",
 "algebraMap_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print algebraMap_apply /-\n@[simp]\ntheorem algebraMap_apply (k : R) (a : α) : algebraMap R («exprC( , )» α A) k a = «expr • » k 1 :=\n  by\n  rw [Algebra.algebraMap_eq_smul_one]\n  rfl\n#align algebra_map_apply algebraMap_apply\n-/\n\n",
 "C_apply":
 "#print ContinuousMap.C_apply /-\n@[simp]\ntheorem ContinuousMap.C_apply (r : R) (a : α) : ContinuousMap.C r a = algebraMap R A r :=\n  rfl\n#align continuous_map.C_apply ContinuousMap.C_apply\n-/\n\n"}