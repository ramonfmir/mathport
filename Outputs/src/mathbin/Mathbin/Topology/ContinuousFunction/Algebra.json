{"zpow_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n-- don't make auto-generated `coe_zsmul` and `zsmul_apply` simp as the linter complains they're\n-- redundant WRT `coe_smul`\n@[to_additive]\ntheorem zpow_comp [Group Î³] [TopologicalGroup Î³] (f : Â«exprC( , )Â» Î² Î³) (z : â„¤) (g : Â«exprC( , )Â» Î± Î²) :\n    (f ^ z).comp g = f.comp g ^ z :=\n  rfl\n#align zpow_comp zpow_comp\n\n",
 "zpow_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[to_additive]\ntheorem zpow_apply [Group Î²] [TopologicalGroup Î²] (f : Â«exprC( , )Â» Î± Î²) (z : â„¤) (x : Î±) : (f ^ z) x = f x ^ z :=\n  rfl\n#align zpow_apply zpow_apply\n\n",
 "tsum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n#print tsum_apply /-\ntheorem tsum_apply [LocallyCompactSpace Î±] [T2Space Î²] [AddCommMonoid Î²] [ContinuousAdd Î²] {Î³ : Type _}\n    {f : Î³ â†’ Â«exprC( , )Â» Î± Î²} (hf : Summable f) (x : Î±) :\n    Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\" (f i x) =\n      (Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\" (f i)) x :=\n  (hasSum_apply hf.has_sum x).tsum_eq\n#align tsum_apply tsum_apply\n-/\n\n",
 "sup_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n-- Not sure why this is grosser than `inf_eq`:\ntheorem sup_eq (f g : Â«exprC( , )Â» Î± Î²) : Â«expr âŠ” Â» f g = Â«expr â€¢ Â» (2â»Â¹ : Î²) (f + g + |f - g|) :=\n  ext fun x => by simpa [mul_add] using @max_eq_half_add_add_abs_sub _ _ (f x) (g x)\n#align sup_eq sup_eq\n\n",
 "summable_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\ntheorem summable_apply [LocallyCompactSpace Î±] [AddCommMonoid Î²] [ContinuousAdd Î²] {Î³ : Type _}\n    {f : Î³ â†’ Â«exprC( , )Â» Î± Î²} (hf : Summable f) (x : Î±) : Summable fun i : Î³ => f i x :=\n  (hasSum_apply hf.has_sum x).summable\n#align summable_apply summable_apply\n\n",
 "strongly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n#print Subalgebra.SeparatesPoints.strongly /-\n/-- Working in continuous functions into a topological field,\na subalgebra of functions that separates points also separates points strongly.\n\nBy the hypothesis, we can find a function `f` so `f x â‰  f y`.\nBy an affine transformation in the field we can arrange so that `f x = a` and `f x = b`.\n-/\ntheorem Subalgebra.SeparatesPoints.strongly {s : Subalgebra ğ•œ (Â«exprC( , )Â» Î± ğ•œ)} (h : s.separates_points) :\n    (s : Set (Â«exprC( , )Â» Î± ğ•œ)).separates_points_strongly := fun v x y =>\n  by\n  by_cases n : x = y\n  Â· subst n\n    refine' âŸ¨_, (Â«expr â€¢ Â» (v x) 1 : s).prop, mul_one _, mul_one _âŸ©\n  obtain âŸ¨_, âŸ¨f, hf, rflâŸ©, hxyâŸ© := h n\n  replace hxy : f x - f y â‰  0 := sub_ne_zero_of_ne hxy\n  let a := v x\n  let b := v y\n  let f' : s := Â«expr â€¢ Â» ((b - a) * (f x - f y)â»Â¹) (algebraMap _ _ (f x) - âŸ¨f, hfâŸ©) + algebraMap _ _ a\n  refine' âŸ¨f', f'.prop, _, _âŸ©\n  Â· simp [f']\n  Â· simp [f', inv_mul_cancel_rightâ‚€ hxy]\n#align subalgebra.separates_points.strongly Subalgebra.SeparatesPoints.strongly\n-/\n\n",
 "star_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp]\ntheorem star_apply (f : Â«exprC( , )Â» Î± Î²) (x : Î±) : star f x = star (f x) :=\n  rfl\n#align star_apply star_apply\n\n",
 "smul_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[simp, to_additive]\ntheorem smul_comp [SMul R M] [ContinuousConstSMul R M] (r : R) (f : Â«exprC( , )Â» Î² M) (g : Â«exprC( , )Â» Î± Î²) :\n    (Â«expr â€¢ Â» r f).comp g = Â«expr â€¢ Â» r (f.comp g) :=\n  rfl\n#align smul_comp smul_comp\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[to_additive]\ntheorem smul_apply [SMul R M] [ContinuousConstSMul R M] (c : R) (f : Â«exprC( , )Â» Î± M) (a : Î±) :\n    (Â«expr â€¢ Â» c f) a = Â«expr â€¢ Â» c (f a) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "separatesPoints_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n#print Subalgebra.separatesPoints_monotone /-\ntheorem Subalgebra.separatesPoints_monotone : Monotone fun s : Subalgebra R (Â«exprC( , )Â» Î± A) => s.separates_points :=\n  fun s s' r h x y n => by\n  obtain âŸ¨f, m, wâŸ© := h n\n  rcases m with âŸ¨f, âŸ¨m, rflâŸ©âŸ©\n  exact âŸ¨_, âŸ¨f, âŸ¨r m, rflâŸ©âŸ©, wâŸ©\n#align subalgebra.separates_points_monotone Subalgebra.separatesPoints_monotone\n-/\n\n",
 "prod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_apply [CommMonoid Î²] [ContinuousMul Î²] {Î¹ : Type _} (s : Finset Î¹) (f : Î¹ â†’ Â«exprC( , )Â» Î± Î²) (a : Î±) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) a =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a) :=\n  by simp\n#align prod_apply prod_apply\n\n",
 "pow_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n-- don't make auto-generated `coe_nsmul` and `nsmul_apply` simp, as the linter complains they're\n-- redundant WRT `coe_smul`\n@[to_additive]\ntheorem pow_comp [Monoid Î³] [ContinuousMul Î³] (f : Â«exprC( , )Â» Î² Î³) (n : â„•) (g : Â«exprC( , )Â» Î± Î²) :\n    (f ^ n).comp g = f.comp g ^ n :=\n  rfl\n#align pow_comp pow_comp\n\n",
 "pow_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[to_additive]\ntheorem pow_apply [Monoid Î²] [ContinuousMul Î²] (f : Â«exprC( , )Â» Î± Î²) (n : â„•) (x : Î±) : (f ^ n) x = f x ^ n :=\n  rfl\n#align pow_apply pow_apply\n\n",
 "periodic_tsum_comp_add_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- Summing the translates of `f` by `â„¤ â€¢ p` gives a map which is periodic with period `p`.\n(This is true without any convergence conditions, since if the sum doesn't converge it is taken to\nbe the zero map, which is periodic.) -/\ntheorem periodic_tsum_comp_add_zsmul [LocallyCompactSpace X] [AddCommGroup X] [TopologicalAddGroup X] [AddCommMonoid Y]\n    [ContinuousAdd Y] [T2Space Y] (f : Â«exprC( , )Â» X Y) (p : X) :\n    Function.Periodic\n      (Â«exprâ‡‘ Â»\n        (Â«exprâˆ‘' , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ‘' , Â»\"\n          (f.comp (ContinuousMap.addRight (Â«expr â€¢ Â» n p)))))\n      p :=\n  by\n  intro x\n  by_cases h : Summable fun n : â„¤ => f.comp (ContinuousMap.addRight (Â«expr â€¢ Â» n p))\n  Â· convert congr_arg (fun f : Â«exprC( , )Â» X Y => f x) ((Equiv.addRight (1 : â„¤)).tsum_eq _) using 1\n    simp_rw [â† tsum_apply h, â† tsum_apply ((Equiv.addRight (1 : â„¤)).summable_iff.mpr h), Equiv.coe_addRight, comp_apply,\n      coe_add_right, add_one_zsmul, add_comm (Â«expr â€¢ Â» _ p) p, â† add_assoc]\n  Â· rw [tsum_eq_zero_of_not_summable h]\n    simp only [coe_zero, Pi.zero_apply]\n#align periodic_tsum_comp_add_zsmul periodic_tsum_comp_add_zsmul\n\n",
 "one_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp, to_additive]\ntheorem one_comp [One Î³] (g : Â«exprC( , )Â» Î± Î²) : (1 : Â«exprC( , )Â» Î² Î³).comp g = 1 :=\n  rfl\n#align one_comp one_comp\n\n",
 "one_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp, to_additive]\ntheorem one_apply [One Î²] (x : Î±) : (1 : Â«exprC( , )Â» Î± Î²) x = 1 :=\n  rfl\n#align one_apply one_apply\n\n",
 "nat_cast_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp]\ntheorem nat_cast_apply [NatCast Î²] (n : â„•) (x : Î±) : (n : Â«exprC( , )Â» Î± Î²) x = n :=\n  rfl\n#align nat_cast_apply nat_cast_apply\n\n",
 "mul_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp, to_additive]\ntheorem mul_comp [Mul Î³] [ContinuousMul Î³] (fâ‚ fâ‚‚ : Â«exprC( , )Â» Î² Î³) (g : Â«exprC( , )Â» Î± Î²) :\n    (fâ‚ * fâ‚‚).comp g = fâ‚.comp g * fâ‚‚.comp g :=\n  rfl\n#align mul_comp mul_comp\n\n",
 "mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp, to_additive]\ntheorem mul_apply [Mul Î²] [ContinuousMul Î²] (f g : Â«exprC( , )Â» Î± Î²) (x : Î±) : (f * g) x = f x * g x :=\n  rfl\n#align mul_apply mul_apply\n\n",
 "min_eq_half_add_sub_abs_sub":
 "#print min_eq_half_add_sub_abs_sub /-\n-- TODO:\n-- This lemma (and the next) could go all the way back in `algebra.order.field`,\n-- except that it is tedious to prove without tactics.\n-- Rather than stranding it at some intermediate location,\n-- it's here, immediately prior to the point of use.\ntheorem min_eq_half_add_sub_abs_sub {x y : R} : min x y = 2â»Â¹ * (x + y - |x - y|) := by\n  cases' le_total x y with h h <;> field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two] <;> abel\n#align min_eq_half_add_sub_abs_sub min_eq_half_add_sub_abs_sub\n-/\n\n",
 "max_eq_half_add_add_abs_sub":
 "#print max_eq_half_add_add_abs_sub /-\ntheorem max_eq_half_add_add_abs_sub {x y : R} : max x y = 2â»Â¹ * (x + y + |x - y|) := by\n  cases' le_total x y with h h <;> field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two] <;> abel\n#align max_eq_half_add_add_abs_sub max_eq_half_add_add_abs_sub\n-/\n\n",
 "inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp, to_additive]\ntheorem inv_comp [Group Î³] [TopologicalGroup Î³] (f : Â«exprC( , )Â» Î² Î³) (g : Â«exprC( , )Â» Î± Î²) :\n    fâ»Â¹.comp g = (f.comp g)â»Â¹ :=\n  rfl\n#align inv_comp inv_comp\n\n",
 "inv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp, to_additive]\ntheorem inv_apply [Group Î²] [TopologicalGroup Î²] (f : Â«exprC( , )Â» Î± Î²) (x : Î±) : fâ»Â¹ x = (f x)â»Â¹ :=\n  rfl\n#align inv_apply inv_apply\n\n",
 "int_cast_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp]\ntheorem int_cast_apply [IntCast Î²] (n : â„¤) (x : Î±) : (n : Â«exprC( , )Â» Î± Î²) x = n :=\n  rfl\n#align int_cast_apply int_cast_apply\n\n",
 "inf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem inf_eq (f g : Â«exprC( , )Â» Î± Î²) : Â«expr âŠ“ Â» f g = Â«expr â€¢ Â» (2â»Â¹ : Î²) (f + g - |f - g|) :=\n  ext fun x => by simpa using min_eq_half_add_sub_abs_sub\n#align inf_eq inf_eq\n\n",
 "has_sum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n-- TODO: rewrite the next three lemmas for products and deduce sum case via `to_additive`, once\n-- definition of `tprod` is in place\n/-- If `Î±` is locally compact, and an infinite sum of functions in `C(Î±, Î²)`\nconverges to `g` (for the compact-open topology), then the pointwise sum converges to `g x` for\nall `x âˆˆ Î±`. -/\ntheorem has_sum_apply {Î³ : Type _} [LocallyCompactSpace Î±] [AddCommMonoid Î²] [ContinuousAdd Î²]\n    {f : Î³ â†’ Â«exprC( , )Â» Î± Î²} {g : Â«exprC( , )Â» Î± Î²} (hf : HasSum f g) (x : Î±) : HasSum (fun i : Î³ => f i x) (g x) :=\n  by\n  let evâ‚“ : AddMonoidHom (Â«exprC( , )Â» Î± Î²) Î² := (Pi.evalAddMonoidHom _ x).comp coe_fn_add_monoid_hom\n  exact hf.map evâ‚“ (ContinuousMap.continuous_eval_const' x)\n#align has_sum_apply has_sum_apply\n\n",
 "div_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp, to_additive]\ntheorem div_comp [Div Î³] [ContinuousDiv Î³] (f g : Â«exprC( , )Â» Î² Î³) (h : Â«exprC( , )Â» Î± Î²) :\n    (f / g).comp h = f.comp h / g.comp h :=\n  rfl\n#align div_comp div_comp\n\n",
 "div_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp, to_additive]\ntheorem div_apply [Div Î²] [ContinuousDiv Î²] (f g : Â«exprC( , )Â» Î± Î²) (x : Î±) : (f / g) x = f x / g x :=\n  rfl\n#align div_apply div_apply\n\n",
 "comp_star_alg_hom'_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/-- `continuous_map.comp_star_alg_hom'` sends the identity continuous map to the identity\n`star_alg_hom` -/\ntheorem comp_star_alg_hom'_id : compStarAlgHom' ğ•œ A (ContinuousMap.id X) = StarAlgHom.id ğ•œ (Â«exprC( , )Â» X A) :=\n  StarAlgHom.ext fun _ => ContinuousMap.ext fun _ => rfl\n#align comp_star_alg_hom'_id comp_star_alg_hom'_id\n\n",
 "comp_star_alg_hom'_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/-- `continuous_map.comp_star_alg_hom` is functorial. -/\ntheorem comp_star_alg_hom'_comp (g : Â«exprC( , )Â» Y Z) (f : Â«exprC( , )Â» X Y) :\n    compStarAlgHom' ğ•œ A (g.comp f) = (compStarAlgHom' ğ•œ A f).comp (compStarAlgHom' ğ•œ A g) :=\n  StarAlgHom.ext fun _ => ContinuousMap.ext fun _ => rfl\n#align comp_star_alg_hom'_comp comp_star_alg_hom'_comp\n\n",
 "coe_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n-- ### \"zpow\" and \"zsmul\"\n@[norm_cast, to_additive]\ntheorem coe_zpow [Group Î²] [TopologicalGroup Î²] (f : Â«exprC( , )Â» Î± Î²) (z : â„¤) : Â«exprâ‡‘ Â» (f ^ z) = f ^ z :=\n  rfl\n#align coe_zpow coe_zpow\n\n",
 "coe_star":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n@[simp]\ntheorem coe_star (f : Â«exprC( , )Â» Î± Î²) : Â«exprâ‡‘ Â» (star f) = star f :=\n  rfl\n#align coe_star coe_star\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[simp, norm_cast, to_additive]\ntheorem coe_smul [SMul R M] [ContinuousConstSMul R M] (c : R) (f : Â«exprC( , )Â» Î± M) :\n    Â«exprâ‡‘ Â» (Â«expr â€¢ Â» c f) = Â«expr â€¢ Â» c f :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n-- don't make `zsmul_comp` simp as the linter complains it's redundant WRT `smul_comp`\n@[simp, to_additive]\ntheorem coe_prod [CommMonoid Î²] [ContinuousMul Î²] {Î¹ : Type _} (s : Finset Î¹) (f : Î¹ â†’ Â«exprC( , )Â» Î± Î²) :\n    Â«exprâ‡‘ Â»\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (f i : Î± â†’ Î²) :=\n  (coeFnMonoidHom : Â«expr â†’* Â» (Â«exprC( , )Â» Î± Î²) _).map_prod f s\n#align coe_prod coe_prod\n\n",
 "coe_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n-- ### \"nsmul\" and \"pow\"\n@[norm_cast, to_additive]\ntheorem coe_pow [Monoid Î²] [ContinuousMul Î²] (f : Â«exprC( , )Â» Î± Î²) (n : â„•) : Â«exprâ‡‘ Â» (f ^ n) = f ^ n :=\n  rfl\n#align coe_pow coe_pow\n\n",
 "coe_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n-- ### \"one\"\n@[simp, norm_cast, to_additive]\ntheorem coe_one [One Î²] : Â«exprâ‡‘ Â» (1 : Â«exprC( , )Â» Î± Î²) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_nat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n-- ### \"nat_cast\"\n@[simp, norm_cast]\ntheorem coe_nat_cast [NatCast Î²] (n : â„•) : ((n : Â«exprC( , )Â» Î± Î²) : Î± â†’ Î²) = n :=\n  rfl\n#align coe_nat_cast coe_nat_cast\n\n",
 "coe_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, NicolÃ² Cavalleri\n-/\n-- ### \"mul\" and \"add\"\n@[simp, norm_cast, to_additive]\ntheorem coe_mul [Mul Î²] [ContinuousMul Î²] (f g : Â«exprC( , )Â» Î± Î²) : Â«exprâ‡‘ Â» (f * g) = f * g :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n-- don't make `nsmul_comp` simp as the linter complains it's redundant WRT `smul_comp`\n-- ### \"inv\" and \"neg\"\n@[simp, norm_cast, to_additive]\ntheorem coe_inv [Group Î²] [TopologicalGroup Î²] (f : Â«exprC( , )Â» Î± Î²) : Â«exprâ‡‘ Â» fâ»Â¹ = fâ»Â¹ :=\n  rfl\n#align coe_inv coe_inv\n\n",
 "coe_int_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n-- ### \"int_cast\"\n@[simp, norm_cast]\ntheorem coe_int_cast [IntCast Î²] (n : â„¤) : ((n : Â«exprC( , )Â» Î± Î²) : Î± â†’ Î²) = n :=\n  rfl\n#align coe_int_cast coe_int_cast\n\n",
 "coe_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n-- ### \"div\" and \"sub\"\n@[simp, norm_cast, to_additive]\ntheorem coe_div [Div Î²] [ContinuousDiv Î²] (f g : Â«exprC( , )Â» Î± Î²) : Â«exprâ‡‘ Â» (f / g) = f / g :=\n  rfl\n#align coe_div coe_div\n\n",
 "algebraMap_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print algebraMap_apply /-\n@[simp]\ntheorem algebraMap_apply (k : R) (a : Î±) : algebraMap R (Â«exprC( , )Â» Î± A) k a = Â«expr â€¢ Â» k 1 :=\n  by\n  rw [Algebra.algebraMap_eq_smul_one]\n  rfl\n#align algebra_map_apply algebraMap_apply\n-/\n\n",
 "C_apply":
 "#print ContinuousMap.C_apply /-\n@[simp]\ntheorem ContinuousMap.C_apply (r : R) (a : Î±) : ContinuousMap.C r a = algebraMap R A r :=\n  rfl\n#align continuous_map.C_apply ContinuousMap.C_apply\n-/\n\n"}