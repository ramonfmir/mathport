{"zpow_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n-- don't make `coe_zsmul` simp as the linter complains it's redundant WRT `coe_smul`\n@[to_additive]\ntheorem zpow_comp [group Î³] [topological_group Î³] (f : Â«exprC( , )Â» Î² Î³) (z : â„¤) (g : Â«exprC( , )Â» Î± Î²) :\n    (f ^ z).comp g = f.comp g ^ z :=\n  rfl\n#align zpow_comp zpow_comp\n\n",
 "sup_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n-- Not sure why this is grosser than `inf_eq`:\ntheorem sup_eq (f g : Â«exprC( , )Â» Î± Î²) : Â«expr âŠ” Â» f g = Â«expr â€¢ Â» (2â»Â¹ : Î²) (f + g + |f - g|) :=\n  ext fun x => by simpa [mul_add] using @max_eq_half_add_add_abs_sub _ _ (f x) (g x)\n#align sup_eq sup_eq\n\n",
 "strongly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/-- Working in continuous functions into a topological field,\na subalgebra of functions that separates points also separates points strongly.\n\nBy the hypothesis, we can find a function `f` so `f x â‰  f y`.\nBy an affine transformation in the field we can arrange so that `f x = a` and `f x = b`.\n-/\ntheorem subalgebra.separates_points.strongly {s : subalgebra ğ•œ (Â«exprC( , )Â» Î± ğ•œ)} (h : s.separates_points) :\n    (s : set (Â«exprC( , )Â» Î± ğ•œ)).separates_points_strongly := fun v x y =>\n  by\n  by_cases n : x = y\n  Â· subst n\n    use (Â«expr â€¢ Â» (v x) 1 : Â«exprC( , )Â» Î± ğ•œ)\n    Â· apply s.smul_mem\n      apply s.one_mem\n    Â· simp [coe_fn_coe_base']\n  obtain âŸ¨f, âŸ¨f, âŸ¨m, rflâŸ©âŸ©, wâŸ© := h n\n  replace w : f x - f y â‰  0 := sub_ne_zero_of_ne w\n  let a := v x\n  let b := v y\n  let f' := Â«expr â€¢ Â» ((b - a) * (f x - f y)â»Â¹) (continuous_map.C (f x) - f) + continuous_map.C a\n  refine' âŸ¨âŸ¨f', _âŸ©, _, _âŸ©\n  Â· simp only [f', SetLike.mem_coe, subalgebra.mem_to_submodule]\n    -- TODO should there be a tactic for this?\n    -- We could add an attribute `@[subobject_mem]`, and a tactic\n    -- ``def subobject_mem := `[solve_by_elim with subobject_mem { max_depth := 10 }]``\n    solve_by_elim (config := { max_depth := 6 }) [subalgebra.add_mem, subalgebra.smul_mem, subalgebra.sub_mem,\n      subalgebra.algebra_map_mem]\n  Â· simp [f', coe_fn_coe_base']\n  Â· simp [f', coe_fn_coe_base', inv_mul_cancel_rightâ‚€ w]\n#align subalgebra.separates_points.strongly subalgebra.separates_points.strongly\n\n",
 "star_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp]\ntheorem star_apply (f : Â«exprC( , )Â» Î± Î²) (x : Î±) : star f x = star (f x) :=\n  rfl\n#align star_apply star_apply\n\n",
 "smul_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[simp, to_additive]\ntheorem smul_comp [SMul R M] [has_continuous_const_smul R M] (r : R) (f : Â«exprC( , )Â» Î² M) (g : Â«exprC( , )Â» Î± Î²) :\n    (Â«expr â€¢ Â» r f).comp g = Â«expr â€¢ Â» r (f.comp g) :=\n  rfl\n#align smul_comp smul_comp\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[to_additive]\ntheorem smul_apply [SMul R M] [has_continuous_const_smul R M] (c : R) (f : Â«exprC( , )Â» Î± M) (a : Î±) :\n    (Â«expr â€¢ Â» c f) a = Â«expr â€¢ Â» c (f a) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "separates_points_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\ntheorem subalgebra.separates_points_monotone : monotone fun s : subalgebra R (Â«exprC( , )Â» Î± A) => s.separates_points :=\n  fun s s' r h x y n => by\n  obtain âŸ¨f, m, wâŸ© := h n\n  rcases m with âŸ¨f, âŸ¨m, rflâŸ©âŸ©\n  exact âŸ¨_, âŸ¨f, âŸ¨r m, rflâŸ©âŸ©, wâŸ©\n#align subalgebra.separates_points_monotone subalgebra.separates_points_monotone\n\n",
 "prod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_apply {Î± : Type _} {Î² : Type _} [comm_monoid Î²] [topological_space Î±] [topological_space Î²]\n    [has_continuous_mul Î²] {Î¹ : Type _} (s : Finset Î¹) (f : Î¹ â†’ Â«exprC( , )Â» Î± Î²) (a : Î±) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) a =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a) :=\n  by simp\n#align prod_apply prod_apply\n\n",
 "pow_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n-- don't make `coe_nsmul` simp as the linter complains it's redundant WRT `coe_smul`\n@[to_additive]\ntheorem pow_comp [monoid Î³] [has_continuous_mul Î³] (f : Â«exprC( , )Â» Î² Î³) (n : â„•) (g : Â«exprC( , )Â» Î± Î²) :\n    (f ^ n).comp g = f.comp g ^ n :=\n  rfl\n#align pow_comp pow_comp\n\n",
 "one_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp, to_additive]\ntheorem one_comp [One Î³] (g : Â«exprC( , )Â» Î± Î²) : (1 : Â«exprC( , )Â» Î² Î³).comp g = 1 :=\n  rfl\n#align one_comp one_comp\n\n",
 "mul_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp, to_additive]\ntheorem mul_comp [Mul Î³] [has_continuous_mul Î³] (fâ‚ fâ‚‚ : Â«exprC( , )Â» Î² Î³) (g : Â«exprC( , )Â» Î± Î²) :\n    (fâ‚ * fâ‚‚).comp g = fâ‚.comp g * fâ‚‚.comp g :=\n  rfl\n#align mul_comp mul_comp\n\n",
 "min_eq_half_add_sub_abs_sub":
 "-- TODO:\n-- This lemma (and the next) could go all the way back in `algebra.order.field`,\n-- except that it is tedious to prove without tactics.\n-- Rather than stranding it at some intermediate location,\n-- it's here, immediately prior to the point of use.\ntheorem min_eq_half_add_sub_abs_sub {x y : R} : min x y = 2â»Â¹ * (x + y - |x - y|) := by\n  cases' le_total x y with h h <;> field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two] <;> abel\n#align min_eq_half_add_sub_abs_sub min_eq_half_add_sub_abs_sub\n\n",
 "max_eq_half_add_add_abs_sub":
 "theorem max_eq_half_add_add_abs_sub {x y : R} : max x y = 2â»Â¹ * (x + y + |x - y|) := by\n  cases' le_total x y with h h <;> field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two] <;> abel\n#align max_eq_half_add_add_abs_sub max_eq_half_add_add_abs_sub\n\n",
 "inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp, to_additive]\ntheorem inv_comp [group Î³] [topological_group Î³] (f : Â«exprC( , )Â» Î² Î³) (g : Â«exprC( , )Â» Î± Î²) :\n    fâ»Â¹.comp g = (f.comp g)â»Â¹ :=\n  rfl\n#align inv_comp inv_comp\n\n",
 "inf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem inf_eq (f g : Â«exprC( , )Â» Î± Î²) : Â«expr âŠ“ Â» f g = Â«expr â€¢ Â» (2â»Â¹ : Î²) (f + g - |f - g|) :=\n  ext fun x => by simpa using min_eq_half_add_sub_abs_sub\n#align inf_eq inf_eq\n\n",
 "div_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp, to_additive]\ntheorem div_comp [Div Î³] [has_continuous_div Î³] (f g : Â«exprC( , )Â» Î² Î³) (h : Â«exprC( , )Â» Î± Î²) :\n    (f / g).comp h = f.comp h / g.comp h :=\n  rfl\n#align div_comp div_comp\n\n",
 "comp_star_alg_hom'_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/-- `continuous_map.comp_star_alg_hom'` sends the identity continuous map to the identity\n`star_alg_hom` -/\ntheorem comp_star_alg_hom'_id : comp_star_alg_hom' ğ•œ A (continuous_map.id X) = star_alg_hom.id ğ•œ (Â«exprC( , )Â» X A) :=\n  star_alg_hom.ext fun _ => continuous_map.ext fun _ => rfl\n#align comp_star_alg_hom'_id comp_star_alg_hom'_id\n\n",
 "comp_star_alg_hom'_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/-- `continuous_map.comp_star_alg_hom` is functorial. -/\ntheorem comp_star_alg_hom'_comp (g : Â«exprC( , )Â» Y Z) (f : Â«exprC( , )Â» X Y) :\n    comp_star_alg_hom' ğ•œ A (g.comp f) = (comp_star_alg_hom' ğ•œ A f).comp (comp_star_alg_hom' ğ•œ A g) :=\n  star_alg_hom.ext fun _ => continuous_map.ext fun _ => rfl\n#align comp_star_alg_hom'_comp comp_star_alg_hom'_comp\n\n",
 "coe_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n@[norm_cast, to_additive]\ntheorem coe_zpow [group Î²] [topological_group Î²] (f : Â«exprC( , )Â» Î± Î²) (z : â„¤) : Â«exprâ‡‘ Â» (f ^ z) = f ^ z :=\n  rfl\n#align coe_zpow coe_zpow\n\n",
 "coe_star":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n@[simp]\ntheorem coe_star (f : Â«exprC( , )Â» Î± Î²) : Â«exprâ‡‘ Â» (star f) = star f :=\n  rfl\n#align coe_star coe_star\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[simp, norm_cast, to_additive]\ntheorem coe_smul [SMul R M] [has_continuous_const_smul R M] (c : R) (f : Â«exprC( , )Â» Î± M) :\n    Â«exprâ‡‘ Â» (Â«expr â€¢ Â» c f) = Â«expr â€¢ Â» c f :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n-- don't make `zsmul_comp` simp as the linter complains it's redundant WRT `smul_comp`\n@[simp, to_additive]\ntheorem coe_prod {Î± : Type _} {Î² : Type _} [comm_monoid Î²] [topological_space Î±] [topological_space Î²]\n    [has_continuous_mul Î²] {Î¹ : Type _} (s : Finset Î¹) (f : Î¹ â†’ Â«exprC( , )Â» Î± Î²) :\n    Â«exprâ‡‘ Â»\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (f i : Î± â†’ Î²) :=\n  (coe_fn_monoid_hom : Â«expr â†’* Â» (Â«exprC( , )Â» Î± Î²) _).map_prod f s\n#align coe_prod coe_prod\n\n",
 "coe_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n@[norm_cast, to_additive]\ntheorem coe_pow [monoid Î²] [has_continuous_mul Î²] (f : Â«exprC( , )Â» Î± Î²) (n : â„•) : Â«exprâ‡‘ Â» (f ^ n) = f ^ n :=\n  rfl\n#align coe_pow coe_pow\n\n",
 "coe_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp, norm_cast, to_additive]\ntheorem coe_one [One Î²] : Â«exprâ‡‘ Â» (1 : Â«exprC( , )Â» Î± Î²) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_nat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp, norm_cast]\ntheorem coe_nat_cast [NatCast Î²] (n : â„•) : ((n : Â«exprC( , )Â» Î± Î²) : Î± â†’ Î²) = n :=\n  rfl\n#align coe_nat_cast coe_nat_cast\n\n",
 "coe_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, NicolÃ² Cavalleri\n-/\n@[simp, norm_cast, to_additive]\ntheorem coe_mul [Mul Î²] [has_continuous_mul Î²] (f g : Â«exprC( , )Â» Î± Î²) : Â«exprâ‡‘ Â» (f * g) = f * g :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n-- don't make `nsmul_comp` simp as the linter complains it's redundant WRT `smul_comp`\n@[simp, norm_cast, to_additive]\ntheorem coe_inv [group Î²] [topological_group Î²] (f : Â«exprC( , )Â» Î± Î²) : Â«exprâ‡‘ Â» fâ»Â¹ = fâ»Â¹ :=\n  rfl\n#align coe_inv coe_inv\n\n",
 "coe_int_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n@[simp, norm_cast]\ntheorem coe_int_cast [IntCast Î²] (n : â„¤) : ((n : Â«exprC( , )Â» Î± Î²) : Î± â†’ Î²) = n :=\n  rfl\n#align coe_int_cast coe_int_cast\n\n",
 "coe_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n@[simp, norm_cast, to_additive]\ntheorem coe_div [Div Î²] [has_continuous_div Î²] (f g : Â«exprC( , )Â» Î± Î²) : Â«exprâ‡‘ Â» (f / g) = f / g :=\n  rfl\n#align coe_div coe_div\n\n",
 "algebra_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[simp]\ntheorem algebra_map_apply (k : R) (a : Î±) : algebra_map R (Â«exprC( , )Â» Î± A) k a = Â«expr â€¢ Â» k 1 :=\n  by\n  rw [algebra.algebra_map_eq_smul_one]\n  rfl\n#align algebra_map_apply algebra_map_apply\n\n",
 "C_apply":
 "@[simp]\ntheorem continuous_map.C_apply (r : R) (a : Î±) : continuous_map.C r a = algebra_map R A r :=\n  rfl\n#align continuous_map.C_apply continuous_map.C_apply\n\n"}