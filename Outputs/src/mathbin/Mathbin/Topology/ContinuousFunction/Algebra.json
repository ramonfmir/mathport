{"zpow_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n-- don't make `coe_zsmul` simp as the linter complains it's redundant WRT `coe_smul`\n@[to_additive]\ntheorem zpow_comp [group γ] [topological_group γ] (f : «exprC( , )» β γ) (z : ℤ) (g : «exprC( , )» α β) :\n    (f ^ z).comp g = f.comp g ^ z :=\n  rfl\n#align zpow_comp zpow_comp\n\n",
 "sup_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- Not sure why this is grosser than `inf_eq`:\ntheorem sup_eq (f g : «exprC( , )» α β) : «expr ⊔ » f g = «expr • » (2⁻¹ : β) (f + g + |f - g|) :=\n  ext fun x => by simpa [mul_add] using @max_eq_half_add_add_abs_sub _ _ (f x) (g x)\n#align sup_eq sup_eq\n\n",
 "strongly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- Working in continuous functions into a topological field,\na subalgebra of functions that separates points also separates points strongly.\n\nBy the hypothesis, we can find a function `f` so `f x ≠ f y`.\nBy an affine transformation in the field we can arrange so that `f x = a` and `f x = b`.\n-/\ntheorem subalgebra.separates_points.strongly {s : subalgebra 𝕜 («exprC( , )» α 𝕜)} (h : s.separates_points) :\n    (s : set («exprC( , )» α 𝕜)).separates_points_strongly := fun v x y =>\n  by\n  by_cases n : x = y\n  · subst n\n    use («expr • » (v x) 1 : «exprC( , )» α 𝕜)\n    · apply s.smul_mem\n      apply s.one_mem\n    · simp [coe_fn_coe_base']\n  obtain ⟨f, ⟨f, ⟨m, rfl⟩⟩, w⟩ := h n\n  replace w : f x - f y ≠ 0 := sub_ne_zero_of_ne w\n  let a := v x\n  let b := v y\n  let f' := «expr • » ((b - a) * (f x - f y)⁻¹) (continuous_map.C (f x) - f) + continuous_map.C a\n  refine' ⟨⟨f', _⟩, _, _⟩\n  · simp only [f', SetLike.mem_coe, subalgebra.mem_to_submodule]\n    -- TODO should there be a tactic for this?\n    -- We could add an attribute `@[subobject_mem]`, and a tactic\n    -- ``def subobject_mem := `[solve_by_elim with subobject_mem { max_depth := 10 }]``\n    solve_by_elim (config := { max_depth := 6 }) [subalgebra.add_mem, subalgebra.smul_mem, subalgebra.sub_mem,\n      subalgebra.algebra_map_mem]\n  · simp [f', coe_fn_coe_base']\n  · simp [f', coe_fn_coe_base', inv_mul_cancel_right₀ w]\n#align subalgebra.separates_points.strongly subalgebra.separates_points.strongly\n\n",
 "star_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp]\ntheorem star_apply (f : «exprC( , )» α β) (x : α) : star f x = star (f x) :=\n  rfl\n#align star_apply star_apply\n\n",
 "smul_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem smul_comp [SMul R M] [has_continuous_const_smul R M] (r : R) (f : «exprC( , )» β M) (g : «exprC( , )» α β) :\n    («expr • » r f).comp g = «expr • » r (f.comp g) :=\n  rfl\n#align smul_comp smul_comp\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_apply [SMul R M] [has_continuous_const_smul R M] (c : R) (f : «exprC( , )» α M) (a : α) :\n    («expr • » c f) a = «expr • » c (f a) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "separates_points_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\ntheorem subalgebra.separates_points_monotone : monotone fun s : subalgebra R («exprC( , )» α A) => s.separates_points :=\n  fun s s' r h x y n => by\n  obtain ⟨f, m, w⟩ := h n\n  rcases m with ⟨f, ⟨m, rfl⟩⟩\n  exact ⟨_, ⟨f, ⟨r m, rfl⟩⟩, w⟩\n#align subalgebra.separates_points_monotone subalgebra.separates_points_monotone\n\n",
 "prod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_apply {α : Type _} {β : Type _} [comm_monoid β] [topological_space α] [topological_space β]\n    [has_continuous_mul β] {ι : Type _} (s : Finset ι) (f : ι → «exprC( , )» α β) (a : α) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) a =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i a) :=\n  by simp\n#align prod_apply prod_apply\n\n",
 "pow_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n-- don't make `coe_nsmul` simp as the linter complains it's redundant WRT `coe_smul`\n@[to_additive]\ntheorem pow_comp [monoid γ] [has_continuous_mul γ] (f : «exprC( , )» β γ) (n : ℕ) (g : «exprC( , )» α β) :\n    (f ^ n).comp g = f.comp g ^ n :=\n  rfl\n#align pow_comp pow_comp\n\n",
 "one_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp, to_additive]\ntheorem one_comp [One γ] (g : «exprC( , )» α β) : (1 : «exprC( , )» β γ).comp g = 1 :=\n  rfl\n#align one_comp one_comp\n\n",
 "mul_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp, to_additive]\ntheorem mul_comp [Mul γ] [has_continuous_mul γ] (f₁ f₂ : «exprC( , )» β γ) (g : «exprC( , )» α β) :\n    (f₁ * f₂).comp g = f₁.comp g * f₂.comp g :=\n  rfl\n#align mul_comp mul_comp\n\n",
 "min_eq_half_add_sub_abs_sub":
 "-- TODO:\n-- This lemma (and the next) could go all the way back in `algebra.order.field`,\n-- except that it is tedious to prove without tactics.\n-- Rather than stranding it at some intermediate location,\n-- it's here, immediately prior to the point of use.\ntheorem min_eq_half_add_sub_abs_sub {x y : R} : min x y = 2⁻¹ * (x + y - |x - y|) := by\n  cases' le_total x y with h h <;> field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two] <;> abel\n#align min_eq_half_add_sub_abs_sub min_eq_half_add_sub_abs_sub\n\n",
 "max_eq_half_add_add_abs_sub":
 "theorem max_eq_half_add_add_abs_sub {x y : R} : max x y = 2⁻¹ * (x + y + |x - y|) := by\n  cases' le_total x y with h h <;> field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two] <;> abel\n#align max_eq_half_add_add_abs_sub max_eq_half_add_add_abs_sub\n\n",
 "inv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp, to_additive]\ntheorem inv_comp [group γ] [topological_group γ] (f : «exprC( , )» β γ) (g : «exprC( , )» α β) :\n    f⁻¹.comp g = (f.comp g)⁻¹ :=\n  rfl\n#align inv_comp inv_comp\n\n",
 "inf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem inf_eq (f g : «exprC( , )» α β) : «expr ⊓ » f g = «expr • » (2⁻¹ : β) (f + g - |f - g|) :=\n  ext fun x => by simpa using min_eq_half_add_sub_abs_sub\n#align inf_eq inf_eq\n\n",
 "div_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp, to_additive]\ntheorem div_comp [Div γ] [has_continuous_div γ] (f g : «exprC( , )» β γ) (h : «exprC( , )» α β) :\n    (f / g).comp h = f.comp h / g.comp h :=\n  rfl\n#align div_comp div_comp\n\n",
 "comp_star_alg_hom'_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- `continuous_map.comp_star_alg_hom'` sends the identity continuous map to the identity\n`star_alg_hom` -/\ntheorem comp_star_alg_hom'_id : comp_star_alg_hom' 𝕜 A (continuous_map.id X) = star_alg_hom.id 𝕜 («exprC( , )» X A) :=\n  star_alg_hom.ext fun _ => continuous_map.ext fun _ => rfl\n#align comp_star_alg_hom'_id comp_star_alg_hom'_id\n\n",
 "comp_star_alg_hom'_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/-- `continuous_map.comp_star_alg_hom` is functorial. -/\ntheorem comp_star_alg_hom'_comp (g : «exprC( , )» Y Z) (f : «exprC( , )» X Y) :\n    comp_star_alg_hom' 𝕜 A (g.comp f) = (comp_star_alg_hom' 𝕜 A f).comp (comp_star_alg_hom' 𝕜 A g) :=\n  star_alg_hom.ext fun _ => continuous_map.ext fun _ => rfl\n#align comp_star_alg_hom'_comp comp_star_alg_hom'_comp\n\n",
 "coe_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[norm_cast, to_additive]\ntheorem coe_zpow [group β] [topological_group β] (f : «exprC( , )» α β) (z : ℤ) : «expr⇑ » (f ^ z) = f ^ z :=\n  rfl\n#align coe_zpow coe_zpow\n\n",
 "coe_star":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_star (f : «exprC( , )» α β) : «expr⇑ » (star f) = star f :=\n  rfl\n#align coe_star coe_star\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, norm_cast, to_additive]\ntheorem coe_smul [SMul R M] [has_continuous_const_smul R M] (c : R) (f : «exprC( , )» α M) :\n    «expr⇑ » («expr • » c f) = «expr • » c f :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n-- don't make `zsmul_comp` simp as the linter complains it's redundant WRT `smul_comp`\n@[simp, to_additive]\ntheorem coe_prod {α : Type _} {β : Type _} [comm_monoid β] [topological_space α] [topological_space β]\n    [has_continuous_mul β] {ι : Type _} (s : Finset ι) (f : ι → «exprC( , )» α β) :\n    «expr⇑ »\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (f i : α → β) :=\n  (coe_fn_monoid_hom : «expr →* » («exprC( , )» α β) _).map_prod f s\n#align coe_prod coe_prod\n\n",
 "coe_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[norm_cast, to_additive]\ntheorem coe_pow [monoid β] [has_continuous_mul β] (f : «exprC( , )» α β) (n : ℕ) : «expr⇑ » (f ^ n) = f ^ n :=\n  rfl\n#align coe_pow coe_pow\n\n",
 "coe_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp, norm_cast, to_additive]\ntheorem coe_one [One β] : «expr⇑ » (1 : «exprC( , )» α β) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_nat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp, norm_cast]\ntheorem coe_nat_cast [NatCast β] (n : ℕ) : ((n : «exprC( , )» α β) : α → β) = n :=\n  rfl\n#align coe_nat_cast coe_nat_cast\n\n",
 "coe_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Nicolò Cavalleri\n-/\n@[simp, norm_cast, to_additive]\ntheorem coe_mul [Mul β] [has_continuous_mul β] (f g : «exprC( , )» α β) : «expr⇑ » (f * g) = f * g :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n-- don't make `nsmul_comp` simp as the linter complains it's redundant WRT `smul_comp`\n@[simp, norm_cast, to_additive]\ntheorem coe_inv [group β] [topological_group β] (f : «exprC( , )» α β) : «expr⇑ » f⁻¹ = f⁻¹ :=\n  rfl\n#align coe_inv coe_inv\n\n",
 "coe_int_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n@[simp, norm_cast]\ntheorem coe_int_cast [IntCast β] (n : ℤ) : ((n : «exprC( , )» α β) : α → β) = n :=\n  rfl\n#align coe_int_cast coe_int_cast\n\n",
 "coe_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast, to_additive]\ntheorem coe_div [Div β] [has_continuous_div β] (f g : «exprC( , )» α β) : «expr⇑ » (f / g) = f / g :=\n  rfl\n#align coe_div coe_div\n\n",
 "algebra_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem algebra_map_apply (k : R) (a : α) : algebra_map R («exprC( , )» α A) k a = «expr • » k 1 :=\n  by\n  rw [algebra.algebra_map_eq_smul_one]\n  rfl\n#align algebra_map_apply algebra_map_apply\n\n",
 "C_apply":
 "@[simp]\ntheorem continuous_map.C_apply (r : R) (a : α) : continuous_map.C r a = algebra_map R A r :=\n  rfl\n#align continuous_map.C_apply continuous_map.C_apply\n\n"}