{"union_right":
 "theorem union_right (ht : separated_nhds s t) (hu : separated_nhds s u) : separated_nhds s (t ∪ u) :=\n  (ht.symm.union_left hu.symm).symm\n#align union_right union_right\n\n",
 "union_left":
 "theorem union_left : separated_nhds s u → separated_nhds t u → separated_nhds (s ∪ t) u := by\n  simpa only [separated_nhds_iff_disjoint, nhds_set_union, disjoint_sup_left] using and.intro\n#align union_left union_left\n\n",
 "trivial_of_discrete":
 "theorem preconnected_space.trivial_of_discrete [preconnected_space α] [discrete_topology α] : subsingleton α :=\n  by\n  rw [← not_nontrivial_iff_subsingleton]\n  rintro ⟨x, y, hxy⟩\n  rw [ne.def, ← mem_singleton_iff, (is_clopen_discrete _).eq_univ <| singleton_nonempty y] at hxy\n  exact hxy (mem_univ x)\n#align preconnected_space.trivial_of_discrete preconnected_space.trivial_of_discrete\n\n",
 "totally_separated_space_of_t1_of_basis_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- A T1 space with a clopen basis is totally separated. -/\ntheorem totally_separated_space_of_t1_of_basis_clopen [t1_space α]\n    (h : is_topological_basis { s : set α | is_clopen s }) : totally_separated_space α :=\n  by\n  constructor\n  rintro x - y - hxy\n  rcases h.mem_nhds_iff.mp (is_open_ne.mem_nhds hxy) with ⟨U, hU, hxU, hyU⟩\n  exact\n    ⟨U, «expr ᶜ» U, hU.is_open, hU.compl.is_open, hxU, fun h => hyU h rfl, (union_compl_self U).superset,\n      disjoint_compl_right⟩\n#align totally_separated_space_of_t1_of_basis_clopen totally_separated_space_of_t1_of_basis_clopen\n\n",
 "tendsto_nhds_unique_of_frequently_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem tendsto_nhds_unique_of_frequently_eq [t2_space α] {f g : β → α} {l : filter β} {a b : α}\n    (ha : tendsto f l ((nhds) a)) (hb : tendsto g l ((nhds) b))\n    (hfg :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l\n        (f x = g x)) :\n    a = b :=\n  have :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n      ((nhds) (a, b)) (z.1 = z.2) :=\n    (ha.prod_mk_nhds hb).frequently hfg\n  not_not.1 fun hne => this (is_closed_diagonal.is_open_compl.mem_nhds hne)\n#align tendsto_nhds_unique_of_frequently_eq tendsto_nhds_unique_of_frequently_eq\n\n",
 "tendsto_nhds_unique_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem tendsto_nhds_unique_of_eventually_eq [t2_space α] {f g : β → α} {l : filter β} {a b : α} [ne_bot l]\n    (ha : tendsto f l ((nhds) a)) (hb : tendsto g l ((nhds) b)) (hfg : «expr =ᶠ[ ] » f l g) : a = b :=\n  tendsto_nhds_unique (ha.congr' hfg) hb\n#align tendsto_nhds_unique_of_eventually_eq tendsto_nhds_unique_of_eventually_eq\n\n",
 "tendsto_nhds_unique'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_nhds_unique' [t2_space α] {f : β → α} {l : filter β} {a b : α} (hl : ne_bot l)\n    (ha : tendsto f l ((nhds) a)) (hb : tendsto f l ((nhds) b)) : a = b :=\n  eq_of_nhds_ne_bot <| ne_bot_of_le <| le_inf ha hb\n#align tendsto_nhds_unique' tendsto_nhds_unique'\n\n",
 "tendsto_nhds_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_nhds_unique [t2_space α] {f : β → α} {l : filter β} {a b : α} [ne_bot l] (ha : tendsto f l ((nhds) a))\n    (hb : tendsto f l ((nhds) b)) : a = b :=\n  eq_of_nhds_ne_bot <| ne_bot_of_le <| le_inf ha hb\n#align tendsto_nhds_unique tendsto_nhds_unique\n\n",
 "tendsto_const_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem tendsto_const_nhds_iff [t1_space α] {l : filter β} [ne_bot l] {c d : α} :\n    tendsto (fun x => c) l ((nhds) d) ↔ c = d := by simp_rw [tendsto, filter.map_const, pure_le_nhds_iff]\n#align tendsto_const_nhds_iff tendsto_const_nhds_iff\n\n",
 "t5_space":
 "theorem embedding.t5_space [topological_space β] [t5_space β] {e : α → β} (he : embedding e) : t5_space α :=\n  by\n  haveI := he.t1_space\n  refine' ⟨fun s t hd₁ hd₂ => _⟩\n  simp only [he.to_inducing.nhds_set_eq_comap]\n  refine' disjoint_comap (completely_normal _ _)\n  ·\n    rwa [← subset_compl_iff_disjoint_left, image_subset_iff, preimage_compl, ← he.closure_eq_preimage_closure_image,\n      subset_compl_iff_disjoint_left]\n  ·\n    rwa [← subset_compl_iff_disjoint_right, image_subset_iff, preimage_compl, ← he.closure_eq_preimage_closure_image,\n      subset_compl_iff_disjoint_right]\n#align embedding.t5_space embedding.t5_space\n\n",
 "t3_space":
 "-- see Note [lower instance priority]\nprotected theorem embedding.t3_space [topological_space β] [t3_space β] {f : α → β} (hf : embedding f) : t3_space α :=\n  { to_t0_space := hf.t0_space\n    to_regular_space := hf.to_inducing.regular_space }\n#align embedding.t3_space embedding.t3_space\n\n",
 "t2_space_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem t2_space_iff_nhds : t2_space α ↔ ∀ {x y : α}, x ≠ y → ∃ U ∈ (nhds) x, ∃ V ∈ (nhds) y, Disjoint U V := by\n  simp only [t2_space_iff_disjoint_nhds, filter.disjoint_iff]\n#align t2_space_iff_nhds t2_space_iff_nhds\n\n",
 "t2_space_iff_disjoint_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem t2_space_iff_disjoint_nhds : t2_space α ↔ ∀ x y : α, x ≠ y → Disjoint ((nhds) x) ((nhds) y) :=\n  by\n  refine' (t2_space_iff α).trans (forall₃_congr fun x y hne => _)\n  simp only [(nhds_basis_opens x).disjoint_iff (nhds_basis_opens y), exists_prop, ← exists_and_left, and_assoc,\n    and_comm', and_left_comm]\n#align t2_space_iff_disjoint_nhds t2_space_iff_disjoint_nhds\n\n",
 "t2_space":
 "theorem embedding.t2_space [topological_space β] [t2_space β] {f : α → β} (hf : embedding f) : t2_space α :=\n  ⟨fun x y h => separated_by_continuous hf.continuous (hf.inj.ne h)⟩\n#align embedding.t2_space embedding.t2_space\n\n",
 "t2_separation_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem t2_separation_nhds [t2_space α] {x y : α} (h : x ≠ y) : ∃ u v, u ∈ (nhds) x ∧ v ∈ (nhds) y ∧ Disjoint u v :=\n  let ⟨u, v, open_u, open_v, x_in, y_in, huv⟩ := t2_separation h\n  ⟨u, v, open_u.mem_nhds x_in, open_v.mem_nhds y_in, huv⟩\n#align t2_separation_nhds t2_separation_nhds\n\n",
 "t2_separation_compact_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem t2_separation_compact_nhds [locally_compact_space α] [t2_space α] {x y : α} (h : x ≠ y) :\n    ∃ u v, u ∈ (nhds) x ∧ v ∈ (nhds) y ∧ is_compact u ∧ is_compact v ∧ Disjoint u v := by\n  simpa only [exists_prop, ← exists_and_left, and_comm', and_assoc, and_left_comm] using\n    ((compact_basis_nhds x).disjoint_iff (compact_basis_nhds y)).1 (disjoint_nhds_nhds.2 h)\n#align t2_separation_compact_nhds t2_separation_compact_nhds\n\n",
 "t2_separation":
 "/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem set.finite.t2_separation [t2_space α] {s : set α} (hs : s.finite) :\n    ∃ U : α → set α, (∀ x, x ∈ U x ∧ is_open (U x)) ∧ s.pairwise_disjoint U :=\n  s.pairwise_disjoint_nhds.exists_mem_filter_basis hs nhds_basis_opens\n#align set.finite.t2_separation set.finite.t2_separation\n\n",
 "t2_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem t2_iff_ultrafilter : t2_space α ↔ ∀ {x y : α} (f : ultrafilter α), ↑f ≤ (nhds) x → ↑f ≤ (nhds) y → x = y :=\n  t2_iff_nhds.trans <| by simp only [← exists_ultrafilter_iff, and_imp, le_inf_iff, exists_imp]\n#align t2_iff_ultrafilter t2_iff_ultrafilter\n\n",
 "t2_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n-- see Note [lower instance priority]\n/-- A space is T₂ iff the neighbourhoods of distinct points generate the bottom filter. -/\ntheorem t2_iff_nhds : t2_space α ↔ ∀ {x y : α}, ne_bot («expr ⊓ » ((nhds) x) ((nhds) y)) → x = y := by\n  simp only [t2_space_iff_disjoint_nhds, disjoint_iff, ne_bot_iff, ne.def, not_imp_comm]\n#align t2_iff_nhds t2_iff_nhds\n\n",
 "t2_iff_is_closed_diagonal":
 "theorem t2_iff_is_closed_diagonal : t2_space α ↔ is_closed (diagonal α) := by\n  simp only [t2_space_iff_disjoint_nhds, ← is_open_compl_iff, is_open_iff_mem_nhds, prod.forall, nhds_prod_eq,\n    compl_diagonal_mem_prod, mem_compl_iff, mem_diagonal_iff]\n#align t2_iff_is_closed_diagonal t2_iff_is_closed_diagonal\n\n",
 "t1_space_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `t1_space_tfae [])\n      (Command.declSig\n       [(Term.explicitBinder \"(\" [`α] [\":\" (Term.type \"Type\" [`u])] [] \")\")\n        (Term.instBinder \"[\" [] (Term.app `topological_space [`α]) \"]\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `t1_space [`α])\n            \",\"\n            (Term.forall\n             \"∀\"\n             [`x]\n             []\n             \",\"\n             (Term.app `is_closed [(Term.typeAscription \"(\" («term{_}» \"{\" [`x] \"}\") \":\" [(Term.app `set [`α])] \")\")]))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [`x]\n             []\n             \",\"\n             (Term.app\n              `is_open\n              [(Term.typeAscription\n                \"(\"\n                (Term.app `«expr ᶜ» [(«term{_}» \"{\" [`x] \"}\")])\n                \":\"\n                [(Term.app `set [`α])]\n                \")\")]))\n            \",\"\n            (Term.app `continuous [(Term.app (Term.explicit \"@\" `cofinite_topology.of) [`α])])\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.strictImplicitBinder \"⦃\" [`x `y] [\":\" `α] \"⦄\")]\n             []\n             \",\"\n             (Term.arrow\n              («term_≠_» `x \"≠\" `y)\n              \"→\"\n              («term_∈_» (Term.app `«expr ᶜ» [(«term{_}» \"{\" [`y] \"}\")]) \"∈\" (Term.app (Term.app `nhds []) [`x]))))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.strictImplicitBinder \"⦃\" [`x `y] [\":\" `α] \"⦄\")]\n             []\n             \",\"\n             (Term.arrow\n              («term_≠_» `x \"≠\" `y)\n              \"→\"\n              (Std.ExtendedBinder.«term∃__,_»\n               \"∃\"\n               (Lean.binderIdent `s)\n               («binderTerm∈_» \"∈\" (Term.app (Term.app `nhds []) [`x]))\n               \",\"\n               («term_∉_» `y \"∉\" `s))))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.strictImplicitBinder \"⦃\" [`x `y] [\":\" `α] \"⦄\")]\n             []\n             \",\"\n             (Term.arrow\n              («term_≠_» `x \"≠\" `y)\n              \"→\"\n              («term∃_,_»\n               \"∃\"\n               (Lean.explicitBinders\n                [(Lean.bracketedExplicitBinders \"(\" [(Lean.binderIdent `U)] \":\" (Term.app `set [`α]) \")\")\n                 (Lean.bracketedExplicitBinders \"(\" [(Lean.binderIdent `hU)] \":\" (Term.app `is_open [`U]) \")\")])\n               \",\"\n               («term_∧_» («term_∈_» `x \"∈\" `U) \"∧\" («term_∉_» `y \"∉\" `U)))))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.strictImplicitBinder \"⦃\" [`x `y] [\":\" `α] \"⦄\")]\n             []\n             \",\"\n             (Term.arrow\n              («term_≠_» `x \"≠\" `y)\n              \"→\"\n              (Term.app `Disjoint [(Term.app (Term.app `nhds []) [`x]) (Term.app `pure [`y])])))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.strictImplicitBinder \"⦃\" [`x `y] [\":\" `α] \"⦄\")]\n             []\n             \",\"\n             (Term.arrow\n              («term_≠_» `x \"≠\" `y)\n              \"→\"\n              (Term.app `Disjoint [(Term.app `pure [`x]) (Term.app (Term.app `nhds []) [`y])])))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.strictImplicitBinder \"⦃\" [`x `y] [\":\" `α] \"⦄\")]\n             []\n             \",\"\n             (Term.arrow (Term.app `«expr ⤳ » [`x `y]) \"→\" («term_=_» `x \"=\" `y)))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"2\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.anonymousCtor\n             \"⟨\"\n             [(Term.fun \"fun\" (Term.basicFun [`h] [] \"=>\" (Term.proj `h \".\" (fieldIdx \"1\"))))\n              \",\"\n              (Term.fun \"fun\" (Term.basicFun [`h] [] \"=>\" (Term.anonymousCtor \"⟨\" [`h] \"⟩\")))]\n             \"⟩\"))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"↔\" (num \"3\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.simp \"simp\" [] [] [\"only\"] [\"[\" [(Tactic.simpLemma [] [] `is_open_compl_iff)] \"]\"] [])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"↔\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.refine' \"refine'\" (Term.app `forall_swap.trans [(Term.hole \"_\")]))\n             []\n             (Tactic.simp\n              \"simp\"\n              []\n              []\n              [\"only\"]\n              [\"[\"\n               [(Tactic.simpLemma [] [] `is_open_iff_mem_nhds)\n                \",\"\n                (Tactic.simpLemma [] [] `mem_compl_iff)\n                \",\"\n                (Tactic.simpLemma [] [] `mem_singleton_iff)]\n               \"]\"]\n              [])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"↔\" (num \"6\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.simp\n              \"simp\"\n              []\n              []\n              [\"only\"]\n              [\"[\"\n               [(Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] `subset_compl_singleton_iff)\n                \",\"\n                (Tactic.simpLemma [] [] `exists_mem_subset_iff)]\n               \"]\"]\n              [])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"↔\" (num \"7\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.simp\n              \"simp\"\n              []\n              []\n              [\"only\"]\n              [\"[\"\n               [(Tactic.simpLemma [] [] (Term.proj (Term.app `nhds_basis_opens [(Term.hole \"_\")]) \".\" `mem_iff))\n                \",\"\n                (Tactic.simpLemma [] [] `subset_compl_singleton_iff)\n                \",\"\n                (Tactic.simpLemma [] [] `exists_prop)\n                \",\"\n                (Tactic.simpLemma [] [] `and_assoc)\n                \",\"\n                (Tactic.simpLemma [] [] `and_left_comm)]\n               \"]\"]\n              [])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"↔\" (num \"8\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.simp\n              \"simp\"\n              []\n              []\n              [\"only\"]\n              [\"[\"\n               [(Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] `principal_singleton)\n                \",\"\n                (Tactic.simpLemma [] [] `disjoint_principal_right)]\n               \"]\"]\n              [])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"8\") \"↔\" (num \"9\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.app\n             `forall_swap.trans\n             [(Term.byTactic\n               \"by\"\n               (Tactic.tacticSeq\n                (Tactic.tacticSeq1Indented\n                 [(Tactic.simp\n                   \"simp\"\n                   []\n                   []\n                   [\"only\"]\n                   [\"[\" [(Tactic.simpLemma [] [] `disjoint_comm) \",\" (Tactic.simpLemma [] [] `ne_comm)] \"]\"]\n                   [])])))]))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.simp\n              \"simp\"\n              []\n              []\n              [\"only\"]\n              [\"[\"\n               [(Tactic.simpLemma [] [] `continuous_def) \",\" (Tactic.simpLemma [] [] `cofinite_topology.is_open_iff')]\n               \"]\"]\n              [])\n             []\n             (Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `H))\n               (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `s))\n               (Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.paren\n                 \"(\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed\n                   [(Std.Tactic.RCases.rcasesPat.one `rfl) \"|\" (Std.Tactic.RCases.rcasesPat.one `hs)])\n                  [])\n                 \")\"))]\n              [])\n             []\n             (Std.Tactic.exacts\n              \"exacts\"\n              \"[\"\n              [`is_open_empty\n               \",\"\n               (Term.subst\n                (Term.app `compl_compl [`s])\n                \"▸\"\n                [(Term.proj\n                  (Term.app\n                   (Term.explicit \"@\" `set.finite.is_closed)\n                   [(Term.hole \"_\") (Term.hole \"_\") `H (Term.hole \"_\") `hs])\n                  \".\"\n                  `is_open_compl)])]\n              \"]\")])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"2\"))\n           []\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [`h `x]\n              []\n              \"=>\"\n              (Term.app\n               (Term.proj\n                («term_<|_»\n                 (Term.proj `cofinite_topology.is_closed_iff \".\" (fieldIdx \"2\"))\n                 \"<|\"\n                 (Term.app `or.inr [(Term.app `finite_singleton [(Term.hole \"_\")])]))\n                \".\"\n                `preimage)\n               [`h]))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"↔\" (num \"10\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.simp\n              \"simp\"\n              []\n              []\n              [\"only\"]\n              [\"[\"\n               [(Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] `closure_subset_iff_is_closed)\n                \",\"\n                (Tactic.simpLemma [] [] `specializes_iff_mem_closure)\n                \",\"\n                (Tactic.simpLemma [] [] `subset_def)\n                \",\"\n                (Tactic.simpLemma [] [] `mem_singleton_iff)\n                \",\"\n                (Tactic.simpLemma [] [] `eq_comm)]\n               \"]\"]\n              [])])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"2\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.anonymousCtor\n            \"⟨\"\n            [(Term.fun \"fun\" (Term.basicFun [`h] [] \"=>\" (Term.proj `h \".\" (fieldIdx \"1\"))))\n             \",\"\n             (Term.fun \"fun\" (Term.basicFun [`h] [] \"=>\" (Term.anonymousCtor \"⟨\" [`h] \"⟩\")))]\n            \"⟩\"))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"↔\" (num \"3\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.simp \"simp\" [] [] [\"only\"] [\"[\" [(Tactic.simpLemma [] [] `is_open_compl_iff)] \"]\"] [])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"↔\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.refine' \"refine'\" (Term.app `forall_swap.trans [(Term.hole \"_\")]))\n            []\n            (Tactic.simp\n             \"simp\"\n             []\n             []\n             [\"only\"]\n             [\"[\"\n              [(Tactic.simpLemma [] [] `is_open_iff_mem_nhds)\n               \",\"\n               (Tactic.simpLemma [] [] `mem_compl_iff)\n               \",\"\n               (Tactic.simpLemma [] [] `mem_singleton_iff)]\n              \"]\"]\n             [])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"↔\" (num \"6\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.simp\n             \"simp\"\n             []\n             []\n             [\"only\"]\n             [\"[\"\n              [(Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] `subset_compl_singleton_iff)\n               \",\"\n               (Tactic.simpLemma [] [] `exists_mem_subset_iff)]\n              \"]\"]\n             [])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"↔\" (num \"7\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.simp\n             \"simp\"\n             []\n             []\n             [\"only\"]\n             [\"[\"\n              [(Tactic.simpLemma [] [] (Term.proj (Term.app `nhds_basis_opens [(Term.hole \"_\")]) \".\" `mem_iff))\n               \",\"\n               (Tactic.simpLemma [] [] `subset_compl_singleton_iff)\n               \",\"\n               (Tactic.simpLemma [] [] `exists_prop)\n               \",\"\n               (Tactic.simpLemma [] [] `and_assoc)\n               \",\"\n               (Tactic.simpLemma [] [] `and_left_comm)]\n              \"]\"]\n             [])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"↔\" (num \"8\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.simp\n             \"simp\"\n             []\n             []\n             [\"only\"]\n             [\"[\"\n              [(Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] `principal_singleton)\n               \",\"\n               (Tactic.simpLemma [] [] `disjoint_principal_right)]\n              \"]\"]\n             [])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"8\") \"↔\" (num \"9\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.app\n            `forall_swap.trans\n            [(Term.byTactic\n              \"by\"\n              (Tactic.tacticSeq\n               (Tactic.tacticSeq1Indented\n                [(Tactic.simp\n                  \"simp\"\n                  []\n                  []\n                  [\"only\"]\n                  [\"[\" [(Tactic.simpLemma [] [] `disjoint_comm) \",\" (Tactic.simpLemma [] [] `ne_comm)] \"]\"]\n                  [])])))]))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.simp\n             \"simp\"\n             []\n             []\n             [\"only\"]\n             [\"[\"\n              [(Tactic.simpLemma [] [] `continuous_def) \",\" (Tactic.simpLemma [] [] `cofinite_topology.is_open_iff')]\n              \"]\"]\n             [])\n            []\n            (Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `H))\n              (Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `s))\n              (Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.paren\n                \"(\"\n                (Std.Tactic.RCases.rcasesPatLo\n                 (Std.Tactic.RCases.rcasesPatMed\n                  [(Std.Tactic.RCases.rcasesPat.one `rfl) \"|\" (Std.Tactic.RCases.rcasesPat.one `hs)])\n                 [])\n                \")\"))]\n             [])\n            []\n            (Std.Tactic.exacts\n             \"exacts\"\n             \"[\"\n             [`is_open_empty\n              \",\"\n              (Term.subst\n               (Term.app `compl_compl [`s])\n               \"▸\"\n               [(Term.proj\n                 (Term.app\n                  (Term.explicit \"@\" `set.finite.is_closed)\n                  [(Term.hole \"_\") (Term.hole \"_\") `H (Term.hole \"_\") `hs])\n                 \".\"\n                 `is_open_compl)])]\n             \"]\")])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"2\"))\n          []\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [`h `x]\n             []\n             \"=>\"\n             (Term.app\n              (Term.proj\n               («term_<|_»\n                (Term.proj `cofinite_topology.is_closed_iff \".\" (fieldIdx \"2\"))\n                \"<|\"\n                (Term.app `or.inr [(Term.app `finite_singleton [(Term.hole \"_\")])]))\n               \".\"\n               `preimage)\n              [`h]))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"↔\" (num \"10\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.simp\n             \"simp\"\n             []\n             []\n             [\"only\"]\n             [\"[\"\n              [(Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] `closure_subset_iff_is_closed)\n               \",\"\n               (Tactic.simpLemma [] [] `specializes_iff_mem_closure)\n               \",\"\n               (Tactic.simpLemma [] [] `subset_def)\n               \",\"\n               (Tactic.simpLemma [] [] `mem_singleton_iff)\n               \",\"\n               (Tactic.simpLemma [] [] `eq_comm)]\n              \"]\"]\n             [])])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.simp\n         \"simp\"\n         []\n         []\n         [\"only\"]\n         [\"[\"\n          [(Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] `closure_subset_iff_is_closed)\n           \",\"\n           (Tactic.simpLemma [] [] `specializes_iff_mem_closure)\n           \",\"\n           (Tactic.simpLemma [] [] `subset_def)\n           \",\"\n           (Tactic.simpLemma [] [] `mem_singleton_iff)\n           \",\"\n           (Tactic.simpLemma [] [] `eq_comm)]\n          \"]\"]\n         [])])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.simp\n       \"simp\"\n       []\n       []\n       [\"only\"]\n       [\"[\"\n        [(Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] `closure_subset_iff_is_closed)\n         \",\"\n         (Tactic.simpLemma [] [] `specializes_iff_mem_closure)\n         \",\"\n         (Tactic.simpLemma [] [] `subset_def)\n         \",\"\n         (Tactic.simpLemma [] [] `mem_singleton_iff)\n         \",\"\n         (Tactic.simpLemma [] [] `eq_comm)]\n        \"]\"]\n       [])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `eq_comm\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `mem_singleton_iff\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `subset_def\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `specializes_iff_mem_closure\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `closure_subset_iff_is_closed\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"↔\" (num \"10\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«↔»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«↔»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«↔»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  t1_space_tfae\n  ( α : Type u ) [ topological_space α ]\n    :\n      TFAE\n        [\n          t1_space α\n            ,\n            ∀ x , is_closed ( { x } : set α )\n            ,\n            ∀ x , is_open ( «expr ᶜ» { x } : set α )\n            ,\n            continuous @ cofinite_topology.of α\n            ,\n            ∀ ⦃ x y : α ⦄ , x ≠ y → «expr ᶜ» { y } ∈ nhds x\n            ,\n            ∀ ⦃ x y : α ⦄ , x ≠ y → ∃ s ∈ nhds x , y ∉ s\n            ,\n            ∀ ⦃ x y : α ⦄ , x ≠ y → ∃ ( U : set α ) ( hU : is_open U ) , x ∈ U ∧ y ∉ U\n            ,\n            ∀ ⦃ x y : α ⦄ , x ≠ y → Disjoint nhds x pure y\n            ,\n            ∀ ⦃ x y : α ⦄ , x ≠ y → Disjoint pure x nhds y\n            ,\n            ∀ ⦃ x y : α ⦄ , «expr ⤳ » x y → x = y\n          ]\n  :=\n    by\n      tfae_have 1 ↔ 2\n        ;\n        exact ⟨ fun h => h . 1 , fun h => ⟨ h ⟩ ⟩\n        tfae_have 2 ↔ 3\n        ;\n        · simp only [ is_open_compl_iff ]\n        tfae_have 5 ↔ 3\n        · refine' forall_swap.trans _ simp only [ is_open_iff_mem_nhds , mem_compl_iff , mem_singleton_iff ]\n        tfae_have 5 ↔ 6\n        · simp only [ ← subset_compl_singleton_iff , exists_mem_subset_iff ]\n        tfae_have 5 ↔ 7\n        ·\n          simp\n            only\n            [ nhds_basis_opens _ . mem_iff , subset_compl_singleton_iff , exists_prop , and_assoc , and_left_comm ]\n        tfae_have 5 ↔ 8\n        · simp only [ ← principal_singleton , disjoint_principal_right ]\n        tfae_have 8 ↔ 9\n        ;\n        exact forall_swap.trans by simp only [ disjoint_comm , ne_comm ]\n        tfae_have 1 → 4\n        ·\n          simp only [ continuous_def , cofinite_topology.is_open_iff' ]\n            rintro H s ( rfl | hs )\n            exacts [ is_open_empty , compl_compl s ▸ @ set.finite.is_closed _ _ H _ hs . is_open_compl ]\n        tfae_have 4 → 2\n        exact fun h x => cofinite_topology.is_closed_iff . 2 <| or.inr finite_singleton _ . preimage h\n        tfae_have 2 ↔ 10\n        ·\n          simp\n            only\n            [ ← closure_subset_iff_is_closed , specializes_iff_mem_closure , subset_def , mem_singleton_iff , eq_comm ]\n        tfae_finish\n#align t1_space_tfae t1_space_tfae\n\n",
 "t1_space_of_injective_of_continuous":
 "theorem t1_space_of_injective_of_continuous [topological_space β] {f : α → β} (hf : function.injective f)\n    (hf' : continuous f) [t1_space β] : t1_space α :=\n  t1_space_iff_specializes_imp_eq.2 fun x y h => hf (h.map hf').eq\n#align t1_space_of_injective_of_continuous t1_space_of_injective_of_continuous\n\n",
 "t1_space_iff_specializes_imp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem t1_space_iff_specializes_imp_eq : t1_space α ↔ ∀ ⦃x y : α⦄, «expr ⤳ » x y → x = y :=\n  (t1_space_tfae α).out 0 9\n#align t1_space_iff_specializes_imp_eq t1_space_iff_specializes_imp_eq\n\n",
 "t1_space_iff_exists_open":
 "theorem t1_space_iff_exists_open : t1_space α ↔ ∀ x y, x ≠ y → ∃ (U : set α)(hU : is_open U), x ∈ U ∧ y ∉ U :=\n  (t1_space_tfae α).out 0 6\n#align t1_space_iff_exists_open t1_space_iff_exists_open\n\n",
 "t1_space_iff_disjoint_pure_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem t1_space_iff_disjoint_pure_nhds : t1_space α ↔ ∀ ⦃x y : α⦄, x ≠ y → Disjoint (pure x) ((nhds) y) :=\n  (t1_space_tfae α).out 0 8\n#align t1_space_iff_disjoint_pure_nhds t1_space_iff_disjoint_pure_nhds\n\n",
 "t1_space_iff_disjoint_nhds_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem t1_space_iff_disjoint_nhds_pure : t1_space α ↔ ∀ ⦃x y : α⦄, x ≠ y → Disjoint ((nhds) x) (pure y) :=\n  (t1_space_tfae α).out 0 7\n#align t1_space_iff_disjoint_nhds_pure t1_space_iff_disjoint_nhds_pure\n\n",
 "t1_space_iff_continuous_cofinite_of":
 "theorem t1_space_iff_continuous_cofinite_of {α : Type _} [topological_space α] :\n    t1_space α ↔ continuous (@cofinite_topology.of α) :=\n  (t1_space_tfae α).out 0 3\n#align t1_space_iff_continuous_cofinite_of t1_space_iff_continuous_cofinite_of\n\n",
 "t1_space_antitone":
 "theorem t1_space_antitone {α : Type _} : antitone (@t1_space α) :=\n  by\n  simp only [antitone, t1_space_iff_continuous_cofinite_of, continuous_iff_le_induced]\n  exact fun t₁ t₂ h => h.trans\n#align t1_space_antitone t1_space_antitone\n\n",
 "t1_space":
 "protected theorem embedding.t1_space [topological_space β] [t1_space β] {f : α → β} (hf : embedding f) : t1_space α :=\n  t1_space_of_injective_of_continuous hf.inj hf.continuous\n#align embedding.t1_space embedding.t1_space\n\n",
 "t0_space_of_injective_of_continuous":
 "theorem t0_space_of_injective_of_continuous [topological_space β] {f : α → β} (hf : function.injective f)\n    (hf' : continuous f) [t0_space β] : t0_space α :=\n  ⟨fun x y h => hf <| (h.map hf').eq⟩\n#align t0_space_of_injective_of_continuous t0_space_of_injective_of_continuous\n\n",
 "t0_space_iff_or_not_mem_closure":
 "theorem t0_space_iff_or_not_mem_closure (α : Type u) [topological_space α] :\n    t0_space α ↔ ∀ a b : α, a ≠ b → a ∉ closure ({b} : set α) ∨ b ∉ closure ({a} : set α) := by\n  simp only [t0_space_iff_not_inseparable, inseparable_iff_mem_closure, not_and_or]\n#align t0_space_iff_or_not_mem_closure t0_space_iff_or_not_mem_closure\n\n",
 "t0_space_iff_not_inseparable":
 "theorem t0_space_iff_not_inseparable (α : Type u) [topological_space α] :\n    t0_space α ↔ ∀ x y : α, x ≠ y → ¬inseparable x y := by simp only [t0_space_iff_inseparable, ne.def, not_imp_not]\n#align t0_space_iff_not_inseparable t0_space_iff_not_inseparable\n\n",
 "t0_space_iff_nhds_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem t0_space_iff_nhds_injective (α : Type u) [topological_space α] : t0_space α ↔ injective (nhds : α → filter α) :=\n  t0_space_iff_inseparable α\n#align t0_space_iff_nhds_injective t0_space_iff_nhds_injective\n\n",
 "t0_space_iff_inseparable":
 "theorem t0_space_iff_inseparable (α : Type u) [topological_space α] : t0_space α ↔ ∀ x y : α, inseparable x y → x = y :=\n  ⟨fun ⟨h⟩ => h, fun h => ⟨h⟩⟩\n#align t0_space_iff_inseparable t0_space_iff_inseparable\n\n",
 "t0_space_iff_exists_is_open_xor_mem":
 "theorem t0_space_iff_exists_is_open_xor_mem (α : Type u) [topological_space α] :\n    t0_space α ↔ ∀ x y, x ≠ y → ∃ U : set α, is_open U ∧ Xor' (x ∈ U) (y ∈ U) := by\n  simp only [t0_space_iff_not_inseparable, xor_iff_not_iff, not_forall, exists_prop, inseparable_iff_forall_open]\n#align t0_space_iff_exists_is_open_xor_mem t0_space_iff_exists_is_open_xor_mem\n\n",
 "t0_space":
 "protected theorem embedding.t0_space [topological_space β] [t0_space β] {f : α → β} (hf : embedding f) : t0_space α :=\n  t0_space_of_injective_of_continuous hf.inj hf.continuous\n#align embedding.t0_space embedding.t0_space\n\n",
 "symm":
 "#print symm /-\n@[symm]\ntheorem symm : separated_nhds s t → separated_nhds t s := fun ⟨U, V, oU, oV, aU, bV, UV⟩ =>\n  ⟨V, U, oV, oU, bV, aU, Disjoint.symm UV⟩\n#align symm symm\n-/\n\n",
 "subsingleton_closure":
 "@[simp]\ntheorem subsingleton_closure [t1_space α] {s : set α} : (closure s).subsingleton ↔ s.subsingleton :=\n  ⟨fun h => h.anti subset_closure, fun h => h.closure⟩\n#align subsingleton_closure subsingleton_closure\n\n",
 "subset_trans":
 "/-- Let `X` be a topological space and let `s, t ⊆ X` be two subsets.  If there is an inclusion\n`t ⊆ s`, then the topological space structure on `t` induced by `X` is the same as the one\nobtained by the induced topological space structure on `s`. -/\ntheorem topological_space.subset_trans {X : Type _} [tX : topological_space X] {s t : set X} (ts : t ⊆ s) :\n    (subtype.topological_space : topological_space t) =\n      (subtype.topological_space : topological_space s).induced (Set.inclusion ts) :=\n  by\n  change tX.induced ((coe : s → X) ∘ Set.inclusion ts) = topological_space.induced (Set.inclusion ts) (tX.induced _)\n  rw [← induced_compose]\n#align topological_space.subset_trans topological_space.subset_trans\n\n",
 "strict_mono_nhds_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\ntheorem strict_mono_nhds_set [t1_space α] : strict_mono (nhds_set : set α → filter α) :=\n  monotone_nhds_set.strict_mono_of_injective injective_nhds_set\n#align strict_mono_nhds_set strict_mono_nhds_set\n\n",
 "specializes_iff_inseparable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes_iff_inseparable {a b : α} : «expr ⤳ » a b ↔ inseparable a b :=\n  ⟨fun h => h.antisymm h.symm, le_of_eq⟩\n#align specializes_iff_inseparable specializes_iff_inseparable\n\n",
 "specializes_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes_iff_eq [t1_space α] {x y : α} : «expr ⤳ » x y ↔ x = y :=\n  ⟨specializes.eq, fun h => h ▸ specializes_rfl⟩\n#align specializes_iff_eq specializes_iff_eq\n\n",
 "specializes_eq_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⤳ » -/\n@[simp]\ntheorem specializes_eq_eq [t1_space α] : («expr ⤳ » · ·) = @eq α :=\n  funext₂ fun x y => propext specializes_iff_eq\n#align specializes_eq_eq specializes_eq_eq\n\n",
 "specializes_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes_comm {a b : α} : «expr ⤳ » a b ↔ «expr ⤳ » b a := by\n  simp only [← disjoint_nhds_nhds_iff_not_specializes.not_left, disjoint_comm]\n#align specializes_comm specializes_comm\n\n",
 "singleton_mem_nhds_within_of_mem_discrete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem singleton_mem_nhds_within_of_mem_discrete {s : set α} [discrete_topology s] {x : α} (hx : x ∈ s) :\n    {x} ∈ nhds_within s x :=\n  by\n  have : ({⟨x, hx⟩} : set s) ∈ (nhds) (⟨x, hx⟩ : s) := by simp [nhds_discrete]\n  simpa only [nhds_within_eq_map_subtype_coe hx, image_singleton] using @image_mem_map _ _ _ (coe : s → α) _ this\n#align singleton_mem_nhds_within_of_mem_discrete singleton_mem_nhds_within_of_mem_discrete\n\n",
 "separated_nhds_iff_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\ntheorem separated_nhds_iff_disjoint {s t : set α} : separated_nhds s t ↔ Disjoint ((nhds_set) s) ((nhds_set) t) := by\n  simp only [(has_basis_nhds_set s).disjoint_iff (has_basis_nhds_set t), separated_nhds, exists_prop, ← exists_and_left,\n    and_assoc, and_comm, and_left_comm]\n#align separated_nhds_iff_disjoint separated_nhds_iff_disjoint\n\n",
 "separated_by_open_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem separated_by_open_embedding {α β : Type _} [topological_space α] [topological_space β] [t2_space α] {f : α → β}\n    (hf : open_embedding f) {x y : α} (h : x ≠ y) :\n    ∃ u v : set β, is_open u ∧ is_open v ∧ f x ∈ u ∧ f y ∈ v ∧ Disjoint u v :=\n  let ⟨u, v, uo, vo, xu, yv, uv⟩ := t2_separation h\n  ⟨«expr '' » f u, «expr '' » f v, hf.is_open_map _ uo, hf.is_open_map _ vo, mem_image_of_mem _ xu,\n    mem_image_of_mem _ yv, disjoint_image_of_injective hf.inj uv⟩\n#align separated_by_open_embedding separated_by_open_embedding\n\n",
 "separated_by_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n-- see Note [lower instance priority]\ntheorem separated_by_continuous {α : Type _} {β : Type _} [topological_space α] [topological_space β] [t2_space β]\n    {f : α → β} (hf : continuous f) {x y : α} (h : f x ≠ f y) :\n    ∃ u v : set α, is_open u ∧ is_open v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n  let ⟨u, v, uo, vo, xu, yv, uv⟩ := t2_separation h\n  ⟨«expr ⁻¹' » f u, «expr ⁻¹' » f v, uo.preimage hf, vo.preimage hf, xu, yv, uv.preimage _⟩\n#align separated_by_continuous separated_by_continuous\n\n",
 "relatively_compact_eq_in_compact":
 "@[simp]\ntheorem bornology.relatively_compact_eq_in_compact [t2_space α] :\n    bornology.relatively_compact α = bornology.in_compact α := by\n  rw [bornology.ext_iff] <;> exact filter.coclosed_compact_eq_cocompact\n#align bornology.relatively_compact_eq_in_compact bornology.relatively_compact_eq_in_compact\n\n",
 "regular_space_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (a «expr ∉ » closure[closure] s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `regular_space_tfae [])\n      (Command.declSig\n       [(Term.explicitBinder \"(\" [`X] [\":\" (Term.type \"Type\" [`u])] [] \")\")\n        (Term.instBinder \"[\" [] (Term.app `topological_space [`X]) \"]\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `regular_space [`X])\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.explicitBinder \"(\" [`s] [\":\" (Term.app `set [`X])] [] \")\")\n              (Term.explicitBinder \"(\" [`a] [] [] \")\")\n              (Term.explicitBinder \"(\" [(Term.hole \"_\")] [\":\" («term_∉_» `a \"∉\" (Term.app `closure [`s]))] [] \")\")]\n             []\n             \",\"\n             (Term.app `Disjoint [(Term.app (Term.app `nhds_set []) [`s]) (Term.app (Term.app `nhds []) [`a])]))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.explicitBinder \"(\" [`a] [\":\" `X] [] \")\")\n              (Term.explicitBinder \"(\" [`s] [\":\" (Term.app `set [`X])] [] \")\")]\n             []\n             \",\"\n             («term_↔_»\n              (Term.app `Disjoint [(Term.app (Term.app `nhds_set []) [`s]) (Term.app (Term.app `nhds []) [`a])])\n              \"↔\"\n              («term_∉_» `a \"∉\" (Term.app `closure [`s]))))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.explicitBinder \"(\" [`a] [\":\" `X] [] \")\")]\n             []\n             \",\"\n             (Std.ExtendedBinder.«term∀__,_»\n              \"∀\"\n              (Lean.binderIdent `s)\n              («binderTerm∈_» \"∈\" (Term.app (Term.app `nhds []) [`a]))\n              \",\"\n              (Std.ExtendedBinder.«term∃__,_»\n               \"∃\"\n               (Lean.binderIdent `t)\n               («binderTerm∈_» \"∈\" (Term.app (Term.app `nhds []) [`a]))\n               \",\"\n               («term_∧_» (Term.app `is_closed [`t]) \"∧\" («term_⊆_» `t \"⊆\" `s)))))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [`a]\n             [(Term.typeSpec \":\" `X)]\n             \",\"\n             («term_≤_»\n              (Term.app (Term.proj (Term.app (Term.app `nhds []) [`a]) \".\" `lift') [`closure])\n              \"≤\"\n              (Term.app (Term.app `nhds []) [`a])))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [`a]\n             [(Term.typeSpec \":\" `X)]\n             \",\"\n             («term_=_»\n              (Term.app (Term.proj (Term.app (Term.app `nhds []) [`a]) \".\" `lift') [`closure])\n              \"=\"\n              (Term.app (Term.app `nhds []) [`a])))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"5\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule [] `regular_space_iff)\n                \",\"\n                (Tactic.rwRule\n                 []\n                 (Term.proj\n                  (Term.app (Term.explicit \"@\" `compl_surjective) [(Term.app `set [`X]) (Term.hole \"_\")])\n                  \".\"\n                  `forall))\n                \",\"\n                (Tactic.rwRule [] `forall_swap)]\n               \"]\")\n              [])\n             []\n             (Tactic.simp\n              \"simp\"\n              []\n              []\n              [\"only\"]\n              [\"[\"\n               [(Tactic.simpLemma [] [] `is_closed_compl_iff)\n                \",\"\n                (Tactic.simpLemma [] [] `mem_compl_iff)\n                \",\"\n                (Tactic.simpLemma [] [] `not_not)\n                \",\"\n                (Tactic.simpLemma\n                 []\n                 []\n                 (Term.app (Term.explicit \"@\" `and_comm') [(«term_∈_» (Term.hole \"_\") \"∈\" (Term.hole \"_\"))]))\n                \",\"\n                (Tactic.simpLemma\n                 []\n                 []\n                 (Term.app\n                  (Term.proj\n                   (Term.proj (Term.app `nhds_basis_opens [(Term.hole \"_\")]) \".\" `lift'_closure)\n                   \".\"\n                   `le_basis_iff)\n                  [(Term.app `nhds_basis_opens [(Term.hole \"_\")])]))\n                \",\"\n                (Tactic.simpLemma [] [] `and_imp)\n                \",\"\n                (Tactic.simpLemma\n                 []\n                 []\n                 (Term.proj (Term.app `nhds_basis_opens [(Term.hole \"_\")]) \".\" `disjoint_iff_right))\n                \",\"\n                (Tactic.simpLemma [] [] `exists_prop)\n                \",\"\n                (Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] `subset_interior_iff_mem_nhds_set)\n                \",\"\n                (Tactic.simpLemma [] [] `interior_compl)\n                \",\"\n                (Tactic.simpLemma [] [] `compl_subset_compl)]\n               \"]\"]\n              [])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"6\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [`h `a]\n              []\n              \"=>\"\n              (Term.app\n               (Term.proj (Term.app `h [`a]) \".\" `antisymm)\n               [(Term.proj (Term.app (Term.app `nhds []) [(Term.hole \"_\")]) \".\" `le_lift'_closure)]))))\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"→\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`H `a `s `hs])\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `H)] \"]\")\n              [(Tactic.location \"at\" (Tactic.locationHyp [`hs] []))])\n             []\n             (Std.Tactic.rcases\n              \"rcases\"\n              [(Tactic.casesTarget\n                []\n                (Term.app\n                 (Term.proj\n                  (Term.proj\n                   (Term.proj (Term.proj (Term.app (Term.app `nhds []) [`a]) \".\" `basis_sets) \".\" `lift'_closure)\n                   \".\"\n                   `mem_iff)\n                  \".\"\n                  `mp)\n                 [`hs]))]\n              [\"with\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed\n                 [(Std.Tactic.RCases.rcasesPat.tuple\n                   \"⟨\"\n                   [(Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hUs)])\n                     [])]\n                   \"⟩\")])\n                [])])\n             []\n             (Tactic.exact\n              \"exact\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [(Term.app `closure [`U])\n                \",\"\n                (Term.app `mem_of_superset [`hU `subset_closure])\n                \",\"\n                `is_closed_closure\n                \",\"\n                `hUs]\n               \"⟩\"))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`H `s `a `ha])\n             []\n             (Tactic.tacticHave_\n              \"have\"\n              (Term.haveDecl\n               (Term.haveIdDecl\n                [`ha' []]\n                [(Term.typeSpec \":\" («term_∈_» (Term.app `«expr ᶜ» [`s]) \"∈\" (Term.app (Term.app `nhds []) [`a])))]\n                \":=\"\n                (Term.byTactic\n                 \"by\"\n                 (Tactic.tacticSeq\n                  (Tactic.tacticSeq1Indented\n                   [(Std.Tactic.tacticRwa__\n                     \"rwa\"\n                     (Tactic.rwRuleSeq\n                      \"[\"\n                      [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `mem_interior_iff_mem_nhds)\n                       \",\"\n                       (Tactic.rwRule [] `interior_compl)]\n                      \"]\")\n                     [])]))))))\n             []\n             (Std.Tactic.rcases\n              \"rcases\"\n              [(Tactic.casesTarget [] (Term.app `H [(Term.hole \"_\") (Term.hole \"_\") `ha']))]\n              [\"with\"\n               (Std.Tactic.RCases.rcasesPatLo\n                (Std.Tactic.RCases.rcasesPatMed\n                 [(Std.Tactic.RCases.rcasesPat.tuple\n                   \"⟨\"\n                   [(Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hUc)])\n                     [])\n                    \",\"\n                    (Std.Tactic.RCases.rcasesPatLo\n                     (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hUs)])\n                     [])]\n                   \"⟩\")])\n                [])])\n             []\n             (Tactic.refine'\n              \"refine'\"\n              (Term.app `disjoint_of_disjoint_of_mem [`disjoint_compl_left (Term.hole \"_\") `hU]))\n             []\n             (Std.Tactic.tacticRwa__\n              \"rwa\"\n              (Tactic.rwRuleSeq\n               \"[\"\n               [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `subset_interior_iff_mem_nhds_set)\n                \",\"\n                (Tactic.rwRule [] `hUc.is_open_compl.interior_eq)\n                \",\"\n                (Tactic.rwRule [] `subset_compl_comm)]\n               \"]\")\n              [])])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.refine'\n              \"refine'\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`H `a `s]\n                []\n                \"=>\"\n                (Term.anonymousCtor\n                 \"⟨\"\n                 [(Term.fun\n                   \"fun\"\n                   (Term.basicFun [`hd `has] [] \"=>\" (Term.app `mem_closure_iff_nhds_ne_bot.mp [`has (Term.hole \"_\")])))\n                  \",\"\n                  (Term.app `H [`s `a])]\n                 \"⟩\"))))\n             []\n             (Tactic.exact\n              \"exact\"\n              (Term.proj\n               («term_<|_»\n                `hd.symm.mono_right\n                \"<|\"\n                (Term.app (Term.explicit \"@\" `principal_le_nhds_set) [(Term.hole \"_\") (Term.hole \"_\") `s]))\n               \".\"\n               `eq_bot))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"1\"))\n           \";\"\n           (Tactic.exact\n            \"exact\"\n            (Term.fun\n             \"fun\"\n             (Term.basicFun\n              [`H]\n              []\n              \"=>\"\n              (Term.anonymousCtor\n               \"⟨\"\n               [(Term.fun\n                 \"fun\"\n                 (Term.basicFun\n                  [`s `a `hs `ha]\n                  []\n                  \"=>\"\n                  («term_<|_»\n                   (Term.proj (Term.app `H [(Term.hole \"_\") (Term.hole \"_\")]) \".\" `mpr)\n                   \"<|\"\n                   (Term.subst `hs.closure_eq.symm \"▸\" [`ha]))))]\n               \"⟩\"))))\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"↔\" (num \"5\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [] `regular_space_iff)\n               \",\"\n               (Tactic.rwRule\n                []\n                (Term.proj\n                 (Term.app (Term.explicit \"@\" `compl_surjective) [(Term.app `set [`X]) (Term.hole \"_\")])\n                 \".\"\n                 `forall))\n               \",\"\n               (Tactic.rwRule [] `forall_swap)]\n              \"]\")\n             [])\n            []\n            (Tactic.simp\n             \"simp\"\n             []\n             []\n             [\"only\"]\n             [\"[\"\n              [(Tactic.simpLemma [] [] `is_closed_compl_iff)\n               \",\"\n               (Tactic.simpLemma [] [] `mem_compl_iff)\n               \",\"\n               (Tactic.simpLemma [] [] `not_not)\n               \",\"\n               (Tactic.simpLemma\n                []\n                []\n                (Term.app (Term.explicit \"@\" `and_comm') [(«term_∈_» (Term.hole \"_\") \"∈\" (Term.hole \"_\"))]))\n               \",\"\n               (Tactic.simpLemma\n                []\n                []\n                (Term.app\n                 (Term.proj\n                  (Term.proj (Term.app `nhds_basis_opens [(Term.hole \"_\")]) \".\" `lift'_closure)\n                  \".\"\n                  `le_basis_iff)\n                 [(Term.app `nhds_basis_opens [(Term.hole \"_\")])]))\n               \",\"\n               (Tactic.simpLemma [] [] `and_imp)\n               \",\"\n               (Tactic.simpLemma\n                []\n                []\n                (Term.proj (Term.app `nhds_basis_opens [(Term.hole \"_\")]) \".\" `disjoint_iff_right))\n               \",\"\n               (Tactic.simpLemma [] [] `exists_prop)\n               \",\"\n               (Tactic.simpLemma [] [(patternIgnore (token.«← » \"←\"))] `subset_interior_iff_mem_nhds_set)\n               \",\"\n               (Tactic.simpLemma [] [] `interior_compl)\n               \",\"\n               (Tactic.simpLemma [] [] `compl_subset_compl)]\n              \"]\"]\n             [])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"6\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [`h `a]\n             []\n             \"=>\"\n             (Term.app\n              (Term.proj (Term.app `h [`a]) \".\" `antisymm)\n              [(Term.proj (Term.app (Term.app `nhds []) [(Term.hole \"_\")]) \".\" `le_lift'_closure)]))))\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"6\") \"→\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H `a `s `hs])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `H)] \"]\")\n             [(Tactic.location \"at\" (Tactic.locationHyp [`hs] []))])\n            []\n            (Std.Tactic.rcases\n             \"rcases\"\n             [(Tactic.casesTarget\n               []\n               (Term.app\n                (Term.proj\n                 (Term.proj\n                  (Term.proj (Term.proj (Term.app (Term.app `nhds []) [`a]) \".\" `basis_sets) \".\" `lift'_closure)\n                  \".\"\n                  `mem_iff)\n                 \".\"\n                 `mp)\n                [`hs]))]\n             [\"with\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.tuple\n                  \"⟨\"\n                  [(Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hUs)])\n                    [])]\n                  \"⟩\")])\n               [])])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [(Term.app `closure [`U])\n               \",\"\n               (Term.app `mem_of_superset [`hU `subset_closure])\n               \",\"\n               `is_closed_closure\n               \",\"\n               `hUs]\n              \"⟩\"))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`H `s `a `ha])\n            []\n            (Tactic.tacticHave_\n             \"have\"\n             (Term.haveDecl\n              (Term.haveIdDecl\n               [`ha' []]\n               [(Term.typeSpec \":\" («term_∈_» (Term.app `«expr ᶜ» [`s]) \"∈\" (Term.app (Term.app `nhds []) [`a])))]\n               \":=\"\n               (Term.byTactic\n                \"by\"\n                (Tactic.tacticSeq\n                 (Tactic.tacticSeq1Indented\n                  [(Std.Tactic.tacticRwa__\n                    \"rwa\"\n                    (Tactic.rwRuleSeq\n                     \"[\"\n                     [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `mem_interior_iff_mem_nhds)\n                      \",\"\n                      (Tactic.rwRule [] `interior_compl)]\n                     \"]\")\n                    [])]))))))\n            []\n            (Std.Tactic.rcases\n             \"rcases\"\n             [(Tactic.casesTarget [] (Term.app `H [(Term.hole \"_\") (Term.hole \"_\") `ha']))]\n             [\"with\"\n              (Std.Tactic.RCases.rcasesPatLo\n               (Std.Tactic.RCases.rcasesPatMed\n                [(Std.Tactic.RCases.rcasesPat.tuple\n                  \"⟨\"\n                  [(Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `U)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hU)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hUc)])\n                    [])\n                   \",\"\n                   (Std.Tactic.RCases.rcasesPatLo\n                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hUs)])\n                    [])]\n                  \"⟩\")])\n               [])])\n            []\n            (Tactic.refine'\n             \"refine'\"\n             (Term.app `disjoint_of_disjoint_of_mem [`disjoint_compl_left (Term.hole \"_\") `hU]))\n            []\n            (Std.Tactic.tacticRwa__\n             \"rwa\"\n             (Tactic.rwRuleSeq\n              \"[\"\n              [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `subset_interior_iff_mem_nhds_set)\n               \",\"\n               (Tactic.rwRule [] `hUc.is_open_compl.interior_eq)\n               \",\"\n               (Tactic.rwRule [] `subset_compl_comm)]\n              \"]\")\n             [])])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.refine'\n             \"refine'\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`H `a `s]\n               []\n               \"=>\"\n               (Term.anonymousCtor\n                \"⟨\"\n                [(Term.fun\n                  \"fun\"\n                  (Term.basicFun [`hd `has] [] \"=>\" (Term.app `mem_closure_iff_nhds_ne_bot.mp [`has (Term.hole \"_\")])))\n                 \",\"\n                 (Term.app `H [`s `a])]\n                \"⟩\"))))\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.proj\n              («term_<|_»\n               `hd.symm.mono_right\n               \"<|\"\n               (Term.app (Term.explicit \"@\" `principal_le_nhds_set) [(Term.hole \"_\") (Term.hole \"_\") `s]))\n              \".\"\n              `eq_bot))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"1\"))\n          \";\"\n          (Tactic.exact\n           \"exact\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [`H]\n             []\n             \"=>\"\n             (Term.anonymousCtor\n              \"⟨\"\n              [(Term.fun\n                \"fun\"\n                (Term.basicFun\n                 [`s `a `hs `ha]\n                 []\n                 \"=>\"\n                 («term_<|_»\n                  (Term.proj (Term.app `H [(Term.hole \"_\") (Term.hole \"_\")]) \".\" `mpr)\n                  \"<|\"\n                  (Term.subst `hs.closure_eq.symm \"▸\" [`ha]))))]\n              \"⟩\"))))\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact\n       \"exact\"\n       (Term.fun\n        \"fun\"\n        (Term.basicFun\n         [`H]\n         []\n         \"=>\"\n         (Term.anonymousCtor\n          \"⟨\"\n          [(Term.fun\n            \"fun\"\n            (Term.basicFun\n             [`s `a `hs `ha]\n             []\n             \"=>\"\n             («term_<|_»\n              (Term.proj (Term.app `H [(Term.hole \"_\") (Term.hole \"_\")]) \".\" `mpr)\n              \"<|\"\n              (Term.subst `hs.closure_eq.symm \"▸\" [`ha]))))]\n          \"⟩\"))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun\n       \"fun\"\n       (Term.basicFun\n        [`H]\n        []\n        \"=>\"\n        (Term.anonymousCtor\n         \"⟨\"\n         [(Term.fun\n           \"fun\"\n           (Term.basicFun\n            [`s `a `hs `ha]\n            []\n            \"=>\"\n            («term_<|_»\n             (Term.proj (Term.app `H [(Term.hole \"_\") (Term.hole \"_\")]) \".\" `mpr)\n             \"<|\"\n             (Term.subst `hs.closure_eq.symm \"▸\" [`ha]))))]\n         \"⟩\")))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.anonymousCtor\n       \"⟨\"\n       [(Term.fun\n         \"fun\"\n         (Term.basicFun\n          [`s `a `hs `ha]\n          []\n          \"=>\"\n          («term_<|_»\n           (Term.proj (Term.app `H [(Term.hole \"_\") (Term.hole \"_\")]) \".\" `mpr)\n           \"<|\"\n           (Term.subst `hs.closure_eq.symm \"▸\" [`ha]))))]\n       \"⟩\")\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.fun\n       \"fun\"\n       (Term.basicFun\n        [`s `a `hs `ha]\n        []\n        \"=>\"\n        («term_<|_»\n         (Term.proj (Term.app `H [(Term.hole \"_\") (Term.hole \"_\")]) \".\" `mpr)\n         \"<|\"\n         (Term.subst `hs.closure_eq.symm \"▸\" [`ha]))))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      («term_<|_»\n       (Term.proj (Term.app `H [(Term.hole \"_\") (Term.hole \"_\")]) \".\" `mpr)\n       \"<|\"\n       (Term.subst `hs.closure_eq.symm \"▸\" [`ha]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.subst `hs.closure_eq.symm \"▸\" [`ha])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `ha\n[PrettyPrinter.parenthesize] ...precedences are 75 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 75, term))\n      `hs.closure_eq.symm\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 75, term)\n[PrettyPrinter.parenthesize] ...precedences are 10 >? 75, (some 75, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 10, term))\n      (Term.proj (Term.app `H [(Term.hole \"_\") (Term.hole \"_\")]) \".\" `mpr)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app `H [(Term.hole \"_\") (Term.hole \"_\")])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))\n      (Term.hole \"_\")\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `H [(Term.hole \"_\") (Term.hole \"_\")]) \")\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 10, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 10, (some 10, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `ha\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `hs\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `a\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      `s\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.strictImplicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.implicitBinder'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.instBinder'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  regular_space_tfae\n  ( X : Type u ) [ topological_space X ]\n    :\n      TFAE\n        [\n          regular_space X\n            ,\n            ∀ ( s : set X ) ( a ) ( _ : a ∉ closure s ) , Disjoint nhds_set s nhds a\n            ,\n            ∀ ( a : X ) ( s : set X ) , Disjoint nhds_set s nhds a ↔ a ∉ closure s\n            ,\n            ∀ ( a : X ) , ∀ s ∈ nhds a , ∃ t ∈ nhds a , is_closed t ∧ t ⊆ s\n            ,\n            ∀ a : X , nhds a . lift' closure ≤ nhds a\n            ,\n            ∀ a : X , nhds a . lift' closure = nhds a\n          ]\n  :=\n    by\n      tfae_have 1 ↔ 5\n        ·\n          rw [ regular_space_iff , @ compl_surjective set X _ . forall , forall_swap ]\n            simp\n              only\n              [\n                is_closed_compl_iff\n                  ,\n                  mem_compl_iff\n                  ,\n                  not_not\n                  ,\n                  @ and_comm' _ ∈ _\n                  ,\n                  nhds_basis_opens _ . lift'_closure . le_basis_iff nhds_basis_opens _\n                  ,\n                  and_imp\n                  ,\n                  nhds_basis_opens _ . disjoint_iff_right\n                  ,\n                  exists_prop\n                  ,\n                  ← subset_interior_iff_mem_nhds_set\n                  ,\n                  interior_compl\n                  ,\n                  compl_subset_compl\n                ]\n        tfae_have 5 → 6\n        ;\n        exact fun h a => h a . antisymm nhds _ . le_lift'_closure\n        tfae_have 6 → 4\n        ·\n          intro H a s hs\n            rw [ ← H ] at hs\n            rcases nhds a . basis_sets . lift'_closure . mem_iff . mp hs with ⟨ U , hU , hUs ⟩\n            exact ⟨ closure U , mem_of_superset hU subset_closure , is_closed_closure , hUs ⟩\n        tfae_have 4 → 2\n        ·\n          intro H s a ha\n            have ha' : «expr ᶜ» s ∈ nhds a := by rwa [ ← mem_interior_iff_mem_nhds , interior_compl ]\n            rcases H _ _ ha' with ⟨ U , hU , hUc , hUs ⟩\n            refine' disjoint_of_disjoint_of_mem disjoint_compl_left _ hU\n            rwa [ ← subset_interior_iff_mem_nhds_set , hUc.is_open_compl.interior_eq , subset_compl_comm ]\n        tfae_have 2 → 3\n        ·\n          refine' fun H a s => ⟨ fun hd has => mem_closure_iff_nhds_ne_bot.mp has _ , H s a ⟩\n            exact hd.symm.mono_right <| @ principal_le_nhds_set _ _ s . eq_bot\n        tfae_have 3 → 1\n        ;\n        exact fun H => ⟨ fun s a hs ha => H _ _ . mpr <| hs.closure_eq.symm ▸ ha ⟩\n        tfae_finish\n#align regular_space_tfae regular_space_tfae\n\n",
 "regular_space_infi":
 "theorem regular_space_infi {ι X} {t : ι → topological_space X} (h : ∀ i, @regular_space X (t i)) :\n    @regular_space X (infᵢ t) :=\n  regular_space_Inf <| forall_range_iff.mpr h\n#align regular_space_infi regular_space_infi\n\n",
 "regular_space_induced":
 "theorem regular_space_induced (f : β → α) : @regular_space β (induced f ‹_›) :=\n  letI := induced f ‹_›\n  inducing.regular_space ⟨rfl⟩\n#align regular_space_induced regular_space_induced\n\n",
 "regular_space_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem regular_space_Inf {X} {T : set (topological_space X)} (h : ∀ t ∈ T, @regular_space X t) :\n    @regular_space X (infₛ T) := by\n  letI := Inf T\n  have :\n    ∀ a,\n      ((nhds) a).has_basis\n        (fun If : ΣI : set T, I → set X => If.1.finite ∧ ∀ i : If.1, If.2 i ∈ @nhds X i a ∧ @is_closed X i (If.2 i))\n        fun If =>\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (If.snd i) :=\n    by\n    intro a\n    rw [nhds_Inf, ← infᵢ_subtype'']\n    exact has_basis_infi fun t : T => @closed_nhds_basis X t (h t t.2) a\n  refine' regular_space.of_basis this fun a If hIf => is_closed_Inter fun i => _\n  exact (hIf.2 i).2.mono (infₛ_le (i : T).2)\n#align regular_space_Inf regular_space_Inf\n\n",
 "regular_space":
 "protected theorem inducing.regular_space [topological_space β] {f : β → α} (hf : inducing f) : regular_space β :=\n  regular_space.of_basis\n    (fun b => by\n      rw [hf.nhds_eq_comap b]\n      exact (closed_nhds_basis _).comap _)\n    fun b s hs => hs.2.preimage hf.continuous\n#align inducing.regular_space inducing.regular_space\n\n",
 "pure_le_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem pure_le_nhds_iff [t1_space α] {a b : α} : pure a ≤ (nhds) b ↔ a = b :=\n  specializes_iff_pure.symm.trans specializes_iff_eq\n#align pure_le_nhds_iff pure_le_nhds_iff\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage [topological_space β] {f : α → β} {s t : set β} (h : separated_nhds s t) (hf : continuous f) :\n    separated_nhds («expr ⁻¹' » f s) («expr ⁻¹' » f t) :=\n  let ⟨U, V, oU, oV, sU, tV, UV⟩ := h\n  ⟨«expr ⁻¹' » f U, «expr ⁻¹' » f V, oU.preimage hf, oV.preimage hf, preimage_mono sU, preimage_mono tV, UV.preimage f⟩\n#align preimage preimage\n\n",
 "point_disjoint_finset_opens_of_t2":
 "theorem point_disjoint_finset_opens_of_t2 [t2_space α] {x : α} {s : Finset α} (h : x ∉ s) :\n    separated_nhds ({x} : set α) s := by\n  exact_mod_cast finset_disjoint_finset_opens_of_t2 {x} s (finset.disjoint_singleton_left.mpr h)\n#align point_disjoint_finset_opens_of_t2 point_disjoint_finset_opens_of_t2\n\n",
 "pairwise_disjoint_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\nprotected theorem set.pairwise_disjoint_nhds [t2_space α] (s : set α) : s.pairwise_disjoint (nhds) :=\n  pairwise_disjoint_nhds.set_pairwise s\n#align set.pairwise_disjoint_nhds set.pairwise_disjoint_nhds\n\n",
 "of_subset_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- If `f x = g x` for all `x ∈ s` and `f`, `g` are continuous on `t`, `s ⊆ t ⊆ closure s`, then\n`f x = g x` for all `x ∈ t`. See also `set.eq_on.closure`. -/\ntheorem set.eq_on.of_subset_closure [t2_space α] {s t : set β} {f g : β → α} (h : EqOn f g s) (hf : continuous_on f t)\n    (hg : continuous_on g t) (hst : s ⊆ t) (hts : t ⊆ closure s) : EqOn f g t :=\n  by\n  intro x hx\n  have : (nhds_within s x).ne_bot := mem_closure_iff_cluster_pt.mp (hts hx)\n  exact\n    tendsto_nhds_unique_of_eventually_eq ((hf x hx).mono_left <| nhds_within_mono _ hst)\n      ((hg x hx).mono_left <| nhds_within_mono _ hst) (h.eventually_eq_of_mem self_mem_nhds_within)\n#align set.eq_on.of_subset_closure set.eq_on.of_subset_closure\n\n",
 "of_subset":
 "/-- Let `s, t ⊆ X` be two subsets of a topological space `X`.  If `t ⊆ s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  -/\ntheorem discrete_topology.of_subset {X : Type _} [topological_space X] {s t : set X} (ds : discrete_topology s)\n    (ts : t ⊆ s) : discrete_topology t :=\n  by\n  rw [topological_space.subset_trans ts, ds.eq_bot]\n  exact { eq_bot := induced_bot (Set.inclusion_injective ts) }\n#align discrete_topology.of_subset discrete_topology.of_subset\n\n",
 "of_open_cover":
 "theorem t0_space.of_open_cover (h : ∀ x, ∃ s : set α, x ∈ s ∧ is_open s ∧ t0_space s) : t0_space α :=\n  t0_space.of_cover fun x y hxy =>\n    let ⟨s, hxs, hso, hs⟩ := h x\n    ⟨s, hxs, (hxy.mem_open_iff hso).1 hxs, hs⟩\n#align t0_space.of_open_cover t0_space.of_open_cover\n\n",
 "of_lift'_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem regular_space.of_lift'_closure (h : ∀ a : α, ((nhds) a).lift' closure = (nhds) a) : regular_space α :=\n  Iff.mpr ((regular_space_tfae α).out 0 5) h\n#align regular_space.of_lift'_closure regular_space.of_lift'_closure\n\n",
 "of_exists_mem_nhds_is_closed_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem regular_space.of_exists_mem_nhds_is_closed_subset\n    (h : ∀ (a : α), ∀ s ∈ (nhds) a, ∃ t ∈ (nhds) a, is_closed t ∧ t ⊆ s) : regular_space α :=\n  Iff.mpr ((regular_space_tfae α).out 0 3) h\n#align regular_space.of_exists_mem_nhds_is_closed_subset regular_space.of_exists_mem_nhds_is_closed_subset\n\n",
 "of_cover":
 "theorem t0_space.of_cover (h : ∀ x y, inseparable x y → ∃ s : set α, x ∈ s ∧ y ∈ s ∧ t0_space s) : t0_space α :=\n  by\n  refine' ⟨fun x y hxy => _⟩\n  rcases h x y hxy with ⟨s, hxs, hys, hs⟩; skip\n  lift x to s using hxs; lift y to s using hys\n  rw [← subtype_inseparable_iff] at hxy\n  exact congr_arg coe hxy.eq\n#align t0_space.of_cover t0_space.of_cover\n\n",
 "of_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem regular_space.of_basis {ι : α → Sort _} {p : ∀ a, ι a → Prop} {s : ∀ a, ι a → set α}\n    (h₁ : ∀ a, ((nhds) a).has_basis (p a) (s a)) (h₂ : ∀ a i, p a i → is_closed (s a i)) : regular_space α :=\n  regular_space.of_lift'_closure fun a => (h₁ a).lift'_closure_eq_self (h₂ a)\n#align regular_space.of_basis regular_space.of_basis\n\n",
 "not_preirreducible_nontrivial_t2":
 "/-- There does not exist a nontrivial preirreducible T₂ space. -/\ntheorem not_preirreducible_nontrivial_t2 (α) [topological_space α] [preirreducible_space α] [nontrivial α]\n    [t2_space α] : false :=\n  (preirreducible_space.is_preirreducible_univ α).subsingleton.not_nontrivial nontrivial_univ\n#align not_preirreducible_nontrivial_t2 not_preirreducible_nontrivial_t2\n\n",
 "normal_space_of_t3_second_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A T₃ topological space with second countable topology is a normal space.\nThis lemma is not an instance to avoid a loop. -/\ntheorem normal_space_of_t3_second_countable [second_countable_topology α] [t3_space α] : normal_space α :=\n  by\n  have key :\n    ∀ {s t : set α},\n      is_closed t →\n        Disjoint s t →\n          ∃ U : set (countable_basis α),\n            s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑u ∧\n              (∀ u ∈ U, Disjoint (closure ↑u) t) ∧\n                ∀ n : ℕ,\n                  is_closed\n                    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                      (closure (u : set α))) :=\n    by\n    intro s t hc hd\n    rw [disjoint_left] at hd\n    have : ∀ x ∈ s, ∃ U ∈ countable_basis α, x ∈ U ∧ Disjoint (closure U) t :=\n      by\n      intro x hx\n      rcases(is_basis_countable_basis α).exists_closure_subset (hc.is_open_compl.mem_nhds (hd hx)) with\n        ⟨u, hu, hxu, hut⟩\n      exact ⟨u, hu, hxu, disjoint_left.2 hut⟩\n    choose! U hu hxu hd\n    set V : s → countable_basis α := maps_to.restrict _ _ _ hu\n    refine' ⟨range V, _, forall_range_iff.2 <| subtype.forall.2 hd, fun n => _⟩\n    · rw [bUnion_range]\n      exact fun x hx => mem_Union.2 ⟨⟨x, hx⟩, hxu x hx⟩\n    · simp only [← supr_eq_Union, supᵢ_and']\n      exact\n        is_closed_bUnion (((finite_le_nat n).preimage_embedding (Encodable.encode' _)).subset <| inter_subset_right _ _)\n          fun u hu => is_closed_closure\n  refine' ⟨fun s t hs ht hd => _⟩\n  rcases key ht hd with ⟨U, hsU, hUd, hUc⟩\n  rcases key hs hd.symm with ⟨V, htV, hVd, hVc⟩\n  refine'\n    ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (↑u \\\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (closure ↑v)),\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (↑v \\\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (closure ↑u)),\n      is_open_bUnion fun u hu => (is_open_of_mem_countable_basis u.2).sdiff (hVc _),\n      is_open_bUnion fun v hv => (is_open_of_mem_countable_basis v.2).sdiff (hUc _), fun x hx => _, fun x hx => _, _⟩\n  · rcases mem_Union₂.1 (hsU hx) with ⟨u, huU, hxu⟩\n    refine' mem_bUnion huU ⟨hxu, _⟩\n    simp only [mem_Union]\n    rintro ⟨v, hvV, -, hxv⟩\n    exact (hVd v hvV).le_bot ⟨hxv, hx⟩\n  · rcases mem_Union₂.1 (htV hx) with ⟨v, hvV, hxv⟩\n    refine' mem_bUnion hvV ⟨hxv, _⟩\n    simp only [mem_Union]\n    rintro ⟨u, huU, -, hxu⟩\n    exact (hUd u huU).le_bot ⟨hxu, hx⟩\n  · simp only [disjoint_left, mem_Union, mem_diff, not_exists, not_and, not_forall, not_not]\n    rintro a ⟨u, huU, hau, haV⟩ v hvV hav\n    cases' le_total (encodable.encode u) (encodable.encode v) with hle hle\n    exacts[⟨u, huU, hle, subset_closure hau⟩, (haV _ hvV hle <| subset_closure hav).elim]\n#align normal_space_of_t3_second_countable normal_space_of_t3_second_countable\n\n",
 "normal_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\nprotected theorem closed_embedding.normal_space [topological_space β] [normal_space β] {f : α → β}\n    (hf : closed_embedding f) : normal_space α :=\n  { to_t1_space := hf.to_embedding.t1_space\n    normal := by\n      intro s t hs ht hst\n      have H : separated_nhds («expr '' » f s) («expr '' » f t) :=\n        normal_space.normal («expr '' » f s) («expr '' » f t) (hf.is_closed_map s hs) (hf.is_closed_map t ht)\n          (disjoint_image_of_injective hf.inj hst)\n      exact (H.preimage hf.continuous).mono (subset_preimage_image _ _) (subset_preimage_image _ _) }\n#align closed_embedding.normal_space closed_embedding.normal_space\n\n",
 "normal_separation":
 "theorem normal_separation [normal_space α] {s t : set α} (H1 : is_closed s) (H2 : is_closed t) (H3 : Disjoint s t) :\n    separated_nhds s t :=\n  normal_space.normal s t H1 H2 H3\n#align normal_separation normal_separation\n\n",
 "normal_of_compact_t2":
 "-- see Note [lower instance priority]\n-- We can't make this an instance because it could cause an instance loop.\ntheorem normal_of_compact_t2 [compact_space α] [t2_space α] : normal_space α :=\n  ⟨fun s t hs ht => is_compact_is_compact_separated hs.is_compact ht.is_compact⟩\n#align normal_of_compact_t2 normal_of_compact_t2\n\n",
 "normal_exists_closure_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem normal_exists_closure_subset [normal_space α] {s t : set α} (hs : is_closed s) (ht : is_open t) (hst : s ⊆ t) :\n    ∃ u, is_open u ∧ s ⊆ u ∧ closure u ⊆ t :=\n  by\n  have : Disjoint s («expr ᶜ» t) := set.disjoint_left.mpr fun x hxs hxt => hxt (hst hxs)\n  rcases normal_separation hs (is_closed_compl_iff.2 ht) this with ⟨s', t', hs', ht', hss', htt', hs't'⟩\n  refine' ⟨s', hs', hss', subset.trans (closure_minimal _ (is_closed_compl_iff.2 ht')) (compl_subset_comm.1 htt')⟩\n  exact fun x hxs hxt => hs't'.le_bot ⟨hxs, hxt⟩\n#align normal_exists_closure_subset normal_exists_closure_subset\n\n",
 "nhds_within_of_mem_discrete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- The neighbourhoods filter of `x` within `s`, under the discrete topology, is equal to\nthe pure `x` filter (which is the principal filter at the singleton `{x}`.) -/\ntheorem nhds_within_of_mem_discrete {s : set α} [discrete_topology s] {x : α} (hx : x ∈ s) : nhds_within s x = pure x :=\n  le_antisymm (le_pure_iff.2 <| singleton_mem_nhds_within_of_mem_discrete hx) (pure_le_nhds_within hx)\n#align nhds_within_of_mem_discrete nhds_within_of_mem_discrete\n\n",
 "nhds_within_insert_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem nhds_within_insert_of_ne [t1_space α] {x y : α} {s : set α} (hxy : x ≠ y) :\n    nhds_within (insert y s) x = nhds_within s x :=\n  by\n  refine' le_antisymm (fun t ht => _) (nhds_within_mono x <| subset_insert y s)\n  obtain ⟨o, ho, hxo, host⟩ := mem_nhds_within.mp ht\n  refine' mem_nhds_within.mpr ⟨o \\ {y}, ho.sdiff is_closed_singleton, ⟨hxo, hxy⟩, _⟩\n  rw [inter_insert_of_not_mem <| not_mem_diff_of_mem (mem_singleton y)]\n  exact (inter_subset_inter (diff_subset _ _) subset.rfl).trans host\n#align nhds_within_insert_of_ne nhds_within_insert_of_ne\n\n",
 "nhds_within_diff_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem ne.nhds_within_diff_singleton [t1_space α] {x y : α} (h : x ≠ y) (s : set α) :\n    nhds_within (s \\ {y}) x = nhds_within s x :=\n  by\n  rw [diff_eq, inter_comm, nhds_within_inter_of_mem]\n  exact mem_nhds_within_of_mem_nhds (is_open_ne.mem_nhds h)\n#align ne.nhds_within_diff_singleton ne.nhds_within_diff_singleton\n\n",
 "nhds_within_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ne.nhds_within_compl_singleton [t1_space α] {x y : α} (h : x ≠ y) : nhds_within («expr ᶜ» {y}) x = (nhds) x :=\n  is_open_ne.nhds_within_eq h\n#align ne.nhds_within_compl_singleton ne.nhds_within_compl_singleton\n\n",
 "nhds_set_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n@[simp]\ntheorem nhds_set_le_iff [t1_space α] {s t : set α} : (nhds_set) s ≤ (nhds_set) t ↔ s ⊆ t :=\n  by\n  refine' ⟨_, fun h => monotone_nhds_set h⟩\n  simp_rw [filter.le_def]; intro h x hx\n  specialize h («expr ᶜ» {x})\n  simp_rw [compl_singleton_mem_nhds_set_iff] at h\n  by_contra hxt\n  exact h hxt hx\n#align nhds_set_le_iff nhds_set_le_iff\n\n",
 "nhds_set_inj_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n@[simp]\ntheorem nhds_set_inj_iff [t1_space α] {s t : set α} : (nhds_set) s = (nhds_set) t ↔ s = t :=\n  by\n  simp_rw [le_antisymm_iff]\n  exact and_congr nhds_set_le_iff nhds_set_le_iff\n#align nhds_set_inj_iff nhds_set_inj_iff\n\n",
 "nhds_le_nhds_set_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n@[simp]\ntheorem nhds_le_nhds_set_iff [t1_space α] {s : set α} {x : α} : (nhds) x ≤ (nhds_set) s ↔ x ∈ s := by\n  rw [← nhds_set_singleton, nhds_set_le_iff, singleton_subset_iff]\n#align nhds_le_nhds_set_iff nhds_le_nhds_set_iff\n\n",
 "nhds_le_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem nhds_le_nhds_iff [t1_space α] {a b : α} : (nhds) a ≤ (nhds) b ↔ a = b :=\n  specializes_iff_eq\n#align nhds_le_nhds_iff nhds_le_nhds_iff\n\n",
 "nhds_inter_eq_singleton_of_mem_discrete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A point `x` in a discrete subset `s` of a topological space admits a neighbourhood\nthat only meets `s` at `x`.  -/\ntheorem nhds_inter_eq_singleton_of_mem_discrete {s : set α} [discrete_topology s] {x : α} (hx : x ∈ s) :\n    ∃ U ∈ (nhds) x, U ∩ s = {x} := by simpa using ((nhds) x).basis_sets.exists_inter_eq_singleton_of_mem_discrete hx\n#align nhds_inter_eq_singleton_of_mem_discrete nhds_inter_eq_singleton_of_mem_discrete\n\n",
 "nhds_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_injective [t0_space α] : injective (nhds : α → filter α) :=\n  (t0_space_iff_nhds_injective α).1 ‹_›\n#align nhds_injective nhds_injective\n\n",
 "nhds_eq_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem nhds_eq_nhds_iff [t0_space α] {a b : α} : (nhds) a = (nhds) b ↔ a = b :=\n  nhds_injective.eq_iff\n#align nhds_eq_nhds_iff nhds_eq_nhds_iff\n\n",
 "nhds_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.has_basis.nhds_closure {ι : Sort _} {a : α} {p : ι → Prop} {s : ι → set α}\n    (h : ((nhds) a).has_basis p s) : ((nhds) a).has_basis p fun i => closure (s i) :=\n  lift'_nhds_closure a ▸ h.lift'_closure\n#align filter.has_basis.nhds_closure filter.has_basis.nhds_closure\n\n",
 "nhds_basis_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem topological_space.is_topological_basis.nhds_basis_closure {B : set (set α)}\n    (hB : topological_space.is_topological_basis B) (a : α) :\n    ((nhds) a).has_basis (fun s : set α => a ∈ s ∧ s ∈ B) closure := by\n  simpa only [and_comm'] using hB.nhds_has_basis.nhds_closure\n#align\n  topological_space.is_topological_basis.nhds_basis_closure topological_space.is_topological_basis.nhds_basis_closure\n\n",
 "nhds_basis_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_clopen (x : α) : ((nhds) x).has_basis (fun s : set α => x ∈ s ∧ is_clopen s) id :=\n  ⟨fun U => by\n    constructor\n    · have : connected_component x = {x} := totally_disconnected_space_iff_connected_component_singleton.mp ‹_› x\n      rw [connected_component_eq_Inter_clopen] at this\n      intro hU\n      let N := { Z // is_clopen Z ∧ x ∈ Z }\n      rsuffices ⟨⟨s, hs, hs'⟩, hs''⟩ : ∃ Z : N, Z.val ⊆ U\n      · exact ⟨s, ⟨hs', hs⟩, hs''⟩\n      haveI : nonempty N := ⟨⟨univ, is_clopen_univ, mem_univ x⟩⟩\n      have hNcl : ∀ Z : N, is_closed Z.val := fun Z => Z.property.1.2\n      have hdir : Directed superset fun Z : N => Z.val :=\n        by\n        rintro ⟨s, hs, hxs⟩ ⟨t, ht, hxt⟩\n        exact ⟨⟨s ∩ t, hs.inter ht, ⟨hxs, hxt⟩⟩, inter_subset_left s t, inter_subset_right s t⟩\n      have h_nhd :\n        ∀ y ∈ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" Z.val,\n          U ∈ (nhds) y :=\n        by\n        intro y y_in\n        erw [this, mem_singleton_iff] at y_in\n        rwa [y_in]\n      exact exists_subset_nhds_of_compact_space hdir hNcl h_nhd\n    · rintro ⟨V, ⟨hxV, V_op, -⟩, hUV : V ⊆ U⟩\n      rw [mem_nhds_iff]\n      exact ⟨V, hUV, V_op, hxV⟩⟩\n#align nhds_basis_clopen nhds_basis_clopen\n\n",
 "mono":
 "theorem mono (h : separated_nhds s₂ t₂) (hs : s₁ ⊆ s₂) (ht : t₁ ⊆ t₂) : separated_nhds s₁ t₁ :=\n  let ⟨U, V, hU, hV, hsU, htV, hd⟩ := h\n  ⟨U, V, hU, hV, hs.trans hsU, ht.trans htV, hd⟩\n#align mono mono\n\n",
 "minimal_nonempty_open_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\ntheorem minimal_nonempty_open_subsingleton [t0_space α] {s : set α} (hs : is_open s)\n    (hmin : ∀ (t) (_ : t ⊆ s), t.nonempty → is_open t → t = s) : s.subsingleton :=\n  by\n  refine' fun x hx y hy => of_not_not fun hxy => _\n  rcases exists_is_open_xor_mem hxy with ⟨U, hUo, hU⟩\n  wlog h : x ∈ U ∧ y ∉ U := hU using x y, y x; cases' h with hxU hyU\n  have : s ∩ U = s := hmin (s ∩ U) (inter_subset_left _ _) ⟨x, hx, hxU⟩ (hs.inter hUo)\n  exact hyU (this.symm.subset hy).2\n#align minimal_nonempty_open_subsingleton minimal_nonempty_open_subsingleton\n\n",
 "minimal_nonempty_open_eq_singleton":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\ntheorem minimal_nonempty_open_eq_singleton [t0_space α] {s : set α} (hs : is_open s) (hne : s.nonempty)\n    (hmin : ∀ (t) (_ : t ⊆ s), t.nonempty → is_open t → t = s) : ∃ x, s = {x} :=\n  exists_eq_singleton_iff_nonempty_subsingleton.2 ⟨hne, minimal_nonempty_open_subsingleton hs hmin⟩\n#align minimal_nonempty_open_eq_singleton minimal_nonempty_open_eq_singleton\n\n",
 "minimal_nonempty_closed_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\ntheorem minimal_nonempty_closed_subsingleton [t0_space α] {s : set α} (hs : is_closed s)\n    (hmin : ∀ (t) (_ : t ⊆ s), t.nonempty → is_closed t → t = s) : s.subsingleton :=\n  by\n  refine' fun x hx y hy => of_not_not fun hxy => _\n  rcases exists_is_open_xor_mem hxy with ⟨U, hUo, hU⟩\n  wlog h : x ∈ U ∧ y ∉ U := hU using x y, y x; cases' h with hxU hyU\n  have : s \\ U = s := hmin (s \\ U) (diff_subset _ _) ⟨y, hy, hyU⟩ (hs.sdiff hUo)\n  exact (this.symm.subset hx).2 hxU\n#align minimal_nonempty_closed_subsingleton minimal_nonempty_closed_subsingleton\n\n",
 "minimal_nonempty_closed_eq_singleton":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\ntheorem minimal_nonempty_closed_eq_singleton [t0_space α] {s : set α} (hs : is_closed s) (hne : s.nonempty)\n    (hmin : ∀ (t) (_ : t ⊆ s), t.nonempty → is_closed t → t = s) : ∃ x, s = {x} :=\n  exists_eq_singleton_iff_nonempty_subsingleton.2 ⟨hne, minimal_nonempty_closed_subsingleton hs hmin⟩\n#align minimal_nonempty_closed_eq_singleton minimal_nonempty_closed_eq_singleton\n\n",
 "locally_compact_of_compact_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem locally_compact_of_compact_nhds [t2_space α] (h : ∀ x : α, ∃ s, s ∈ (nhds) x ∧ is_compact s) :\n    locally_compact_space α :=\n  ⟨fun x n hn =>\n    let ⟨u, un, uo, xu⟩ := mem_nhds_iff.mp hn\n    let ⟨k, kx, kc⟩ := h x\n    -- K is compact but not necessarily contained in N.\n    -- K \\ U is again compact and doesn't contain x, so\n    -- we may find open sets V, W separating x from K \\ U.\n    -- Then K \\ W is a compact neighborhood of x contained in U.\n    let ⟨v, w, vo, wo, xv, kuw, vw⟩ :=\n      is_compact_is_compact_separated is_compact_singleton (kc.diff uo) (disjoint_singleton_left.2 fun h => h.2 xu)\n    have wn : «expr ᶜ» w ∈ (nhds) x := mem_nhds_iff.mpr ⟨v, vw.subset_compl_right, vo, singleton_subset_iff.mp xv⟩\n    ⟨k \\ w, filter.inter_mem kx wn, Subset.trans (diff_subset_comm.mp kuw) un, kc.diff wo⟩⟩\n#align locally_compact_of_compact_nhds locally_compact_of_compact_nhds\n\n",
 "loc_compact_t2_tot_disc_iff_tot_sep":
 "/-- A locally compact Hausdorff space is totally disconnected\n  if and only if it is totally separated. -/\ntheorem loc_compact_t2_tot_disc_iff_tot_sep : totally_disconnected_space H ↔ totally_separated_space H :=\n  by\n  constructor\n  · intro h\n    exact totally_separated_space_of_t1_of_basis_clopen loc_compact_Haus_tot_disc_of_zero_dim\n  apply totally_separated_space.totally_disconnected_space\n#align loc_compact_t2_tot_disc_iff_tot_sep loc_compact_t2_tot_disc_iff_tot_sep\n\n",
 "loc_compact_Haus_tot_disc_of_zero_dim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem loc_compact_Haus_tot_disc_of_zero_dim [totally_disconnected_space H] :\n    is_topological_basis { s : set H | is_clopen s } :=\n  by\n  refine' is_topological_basis_of_open_of_nhds (fun u hu => hu.1) _\n  rintro x U memU hU\n  obtain ⟨s, comp, xs, sU⟩ := exists_compact_subset hU memU\n  obtain ⟨t, h, ht, xt⟩ := mem_interior.1 xs\n  let u : set s := «expr ⁻¹' » (coe : s → H) (interior s)\n  have u_open_in_s : is_open u := is_open_interior.preimage continuous_subtype_coe\n  let X : s := ⟨x, h xt⟩\n  have Xu : X ∈ u := xs\n  haveI : compact_space s := is_compact_iff_compact_space.1 comp\n  obtain ⟨V : set s, clopen_in_s, Vx, V_sub⟩ := compact_exists_clopen_in_open u_open_in_s Xu\n  have V_clopen : is_clopen («expr '' » (coe : s → H) V) :=\n    by\n    refine' ⟨_, comp.is_closed.closed_embedding_subtype_coe.closed_iff_image_closed.1 clopen_in_s.2⟩\n    let v : set u := «expr ⁻¹' » (coe : u → s) V\n    have : (coe : u → H) = (coe : s → H) ∘ (coe : u → s) := rfl\n    have f0 : embedding (coe : u → H) := embedding_subtype_coe.comp embedding_subtype_coe\n    have f1 : open_embedding (coe : u → H) := by\n      refine' ⟨f0, _⟩\n      · have : Set.range (coe : u → H) = interior s :=\n          by\n          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]\n          apply Set.inter_eq_self_of_subset_left interior_subset\n        rw [this]\n        apply is_open_interior\n    have f2 : is_open v := clopen_in_s.1.preimage continuous_subtype_coe\n    have f3 : «expr '' » (coe : s → H) V = «expr '' » (coe : u → H) v := by\n      rw [this, image_comp coe coe, Subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub]\n    rw [f3]\n    apply f1.is_open_map v f2\n  refine' ⟨«expr '' » coe V, V_clopen, by simp [Vx, h xt], _⟩\n  trans s\n  · simp\n  assumption\n#align loc_compact_Haus_tot_disc_of_zero_dim loc_compact_Haus_tot_disc_of_zero_dim\n\n",
 "lim_nhds_within_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n@[simp]\ntheorem lim_nhds_within_id {a : α} {s : set α} (h : a ∈ closure s) : @lim _ _ _ ⟨a⟩ (nhds_within s a) id = a :=\n  Lim_nhds_within h\n#align lim_nhds_within_id lim_nhds_within_id\n\n",
 "lim_nhds_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem lim_nhds_id (a : α) : @lim _ _ _ ⟨a⟩ ((nhds) a) id = a :=\n  Lim_nhds a\n#align lim_nhds_id lim_nhds_id\n\n",
 "lim_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.lim_eq_iff {f : filter β} [ne_bot f] {g : β → α} (h : ∃ a, tendsto g f ((nhds) a)) {a} :\n    @lim _ _ _ ⟨a⟩ f g = a ↔ tendsto g f ((nhds) a) :=\n  ⟨fun c => c ▸ tendsto_nhds_lim h, filter.tendsto.lim_eq⟩\n#align filter.lim_eq_iff filter.lim_eq_iff\n\n",
 "lim_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous.lim_eq [topological_space β] {f : β → α} (h : continuous f) (a : β) :\n    @lim _ _ _ ⟨f a⟩ ((nhds) a) f = f a :=\n  (h.tendsto a).lim_eq\n#align continuous.lim_eq continuous.lim_eq\n\n",
 "lift'_nhds_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem lift'_nhds_closure (a : α) : ((nhds) a).lift' closure = (nhds) a :=\n  (closed_nhds_basis a).lift'_closure_eq_self fun s hs => hs.2\n#align lift'_nhds_closure lift'_nhds_closure\n\n",
 "is_topological_basis_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_topological_basis_clopen : is_topological_basis { s : set α | is_clopen s } :=\n  by\n  apply is_topological_basis_of_open_of_nhds fun U (hU : is_clopen U) => hU.1\n  intro x U hxU U_op\n  have : U ∈ (nhds) x := is_open.mem_nhds U_op hxU\n  rcases(nhds_basis_clopen x).mem_iff.mp this with ⟨V, ⟨hxV, hV⟩, hVU : V ⊆ U⟩\n  use V\n  tauto\n#align is_topological_basis_clopen is_topological_basis_clopen\n\n",
 "is_preirreducible_iff_subsingleton":
 "theorem is_preirreducible_iff_subsingleton [t2_space α] {S : set α} : is_preirreducible S ↔ S.subsingleton :=\n  by\n  refine' ⟨fun h x hx y hy => _, set.subsingleton.is_preirreducible⟩\n  by_contra e\n  obtain ⟨U, V, hU, hV, hxU, hyV, h'⟩ := t2_separation e\n  exact ((h U V hU hV ⟨x, hx, hxU⟩ ⟨y, hy, hyV⟩).mono <| inter_subset_right _ _).not_disjoint h'\n#align is_preirreducible_iff_subsingleton is_preirreducible_iff_subsingleton\n\n",
 "is_open_singleton_of_finite_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A point with a finite neighborhood has to be isolated. -/\ntheorem is_open_singleton_of_finite_mem_nhds {α : Type _} [topological_space α] [t1_space α] (x : α) {s : set α}\n    (hs : s ∈ (nhds) x) (hsf : s.finite) : is_open ({x} : set α) :=\n  by\n  have A : {x} ⊆ s := by simp only [singleton_subset_iff, mem_of_mem_nhds hs]\n  have B : is_closed (s \\ {x}) := (hsf.subset (diff_subset _ _)).is_closed\n  have C : «expr ᶜ» (s \\ {x}) ∈ (nhds) x := B.is_open_compl.mem_nhds fun h => h.2 rfl\n  have D : {x} ∈ (nhds) x := by simpa only [← diff_eq, diff_diff_cancel_left A] using inter_mem hs C\n  rwa [← mem_interior_iff_mem_nhds, ← singleton_subset_iff, subset_interior_iff_is_open] at D\n#align is_open_singleton_of_finite_mem_nhds is_open_singleton_of_finite_mem_nhds\n\n",
 "is_open_set_of_eventually_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\ntheorem is_open_set_of_eventually_nhds_within [t1_space α] {p : α → Prop} :\n    is_open\n      { x |\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          (nhds_within.ne x) (p y) } :=\n  by\n  refine' is_open_iff_mem_nhds.mpr fun a ha => _\n  filter_upwards [eventually_nhds_nhds_within.mpr ha] with b hb\n  by_cases a = b\n  · subst h\n    exact hb\n  · rw [(ne.symm h).nhds_within_compl_singleton] at hb\n    exact hb.filter_mono nhds_within_le_nhds\n#align is_open_set_of_eventually_nhds_within is_open_set_of_eventually_nhds_within\n\n",
 "is_open_set_of_disjoint_nhds_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_open_set_of_disjoint_nhds_nhds : is_open { p : α × α | Disjoint ((nhds) p.1) ((nhds) p.2) } :=\n  by\n  simp only [is_open_iff_mem_nhds, prod.forall, mem_set_of_eq]\n  intro x y h\n  obtain ⟨U, hU, V, hV, hd⟩ := ((nhds_basis_opens x).disjoint_iff (nhds_basis_opens y)).mp h\n  exact\n    mem_nhds_prod_iff.mpr\n      ⟨U, hU.2.mem_nhds hU.1, V, hV.2.mem_nhds hV.1, fun ⟨x', y'⟩ ⟨hx', hy'⟩ =>\n        disjoint_of_disjoint_of_mem hd (hU.2.mem_nhds hx') (hV.2.mem_nhds hy')⟩\n#align is_open_set_of_disjoint_nhds_nhds is_open_set_of_disjoint_nhds_nhds\n\n",
 "is_open_ne_fun":
 "theorem is_open_ne_fun [t2_space α] {f g : β → α} (hf : continuous f) (hg : continuous g) :\n    is_open { x : β | f x ≠ g x } :=\n  is_open_compl_iff.mpr <| is_closed_eq hf hg\n#align is_open_ne_fun is_open_ne_fun\n\n",
 "is_open_ne":
 "theorem is_open_ne [t1_space α] {x : α} : is_open { y | y ≠ x } :=\n  is_open_compl_singleton\n#align is_open_ne is_open_ne\n\n",
 "is_open_mul_support":
 "@[to_additive]\ntheorem continuous.is_open_mul_support [t1_space α] [One α] [topological_space β] {f : β → α} (hf : continuous f) :\n    is_open (mul_support f) :=\n  is_open_ne.preimage hf\n#align continuous.is_open_mul_support continuous.is_open_mul_support\n\n",
 "is_open_iff_ultrafilter'":
 "theorem is_open_iff_ultrafilter' [compact_space α] (U : set α) : is_open U ↔ ∀ F : ultrafilter α, F.Lim ∈ U → U ∈ F.1 :=\n  by\n  rw [is_open_iff_ultrafilter]\n  refine' ⟨fun h F hF => h F.Lim hF F F.le_nhds_Lim, _⟩\n  intro cond x hx f h\n  rw [← ultrafilter.Lim_eq_iff_le_nhds.2 h] at hx\n  exact cond _ hx\n#align is_open_iff_ultrafilter' is_open_iff_ultrafilter'\n\n",
 "is_open_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_open_compl_singleton [t1_space α] {x : α} : is_open («expr ᶜ» {x} : set α) :=\n  is_closed_singleton.is_open_compl\n#align is_open_compl_singleton is_open_compl_singleton\n\n",
 "is_irreducible_iff_singleton":
 "theorem is_irreducible_iff_singleton [t2_space α] {S : set α} : is_irreducible S ↔ ∃ x, S = {x} := by\n  rw [is_irreducible, is_preirreducible_iff_subsingleton, exists_eq_singleton_iff_nonempty_subsingleton]\n#align is_irreducible_iff_singleton is_irreducible_iff_singleton\n\n",
 "is_compact_is_compact_separated":
 "theorem is_compact_is_compact_separated [t2_space α] {s t : set α} (hs : is_compact s) (ht : is_compact t)\n    (hst : Disjoint s t) : separated_nhds s t := by\n  simp only [separated_nhds, prod_subset_compl_diagonal_iff_disjoint.symm] at hst⊢ <;>\n    exact generalized_tube_lemma hs ht is_closed_diagonal.is_open_compl hst\n#align is_compact_is_compact_separated is_compact_is_compact_separated\n\n",
 "is_compact_closure_of_subset_compact":
 "theorem is_compact_closure_of_subset_compact [t2_space α] {s t : set α} (ht : is_compact t) (h : s ⊆ t) :\n    is_compact (closure s) :=\n  is_compact_of_is_closed_subset ht is_closed_closure (closure_minimal h ht.is_closed)\n#align is_compact_closure_of_subset_compact is_compact_closure_of_subset_compact\n\n",
 "is_closed_singleton":
 "theorem is_closed_singleton [t1_space α] {x : α} : is_closed ({x} : set α) :=\n  t1_space.t1 x\n#align is_closed_singleton is_closed_singleton\n\n",
 "is_closed_set_of_specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem is_closed_set_of_specializes : is_closed { p : α × α | «expr ⤳ » p.1 p.2 } := by\n  simp only [← is_open_compl_iff, compl_set_of, ← disjoint_nhds_nhds_iff_not_specializes,\n    is_open_set_of_disjoint_nhds_nhds]\n#align is_closed_set_of_specializes is_closed_set_of_specializes\n\n",
 "is_closed_set_of_inseparable":
 "theorem is_closed_set_of_inseparable : is_closed { p : α × α | inseparable p.1 p.2 } := by\n  simp only [← specializes_iff_inseparable, is_closed_set_of_specializes]\n#align is_closed_set_of_inseparable is_closed_set_of_inseparable\n\n",
 "is_closed_map_const":
 "theorem is_closed_map_const {α β} [topological_space α] [topological_space β] [t1_space β] {y : β} :\n    is_closed_map (function.const α y) :=\n  is_closed_map.of_nonempty fun s hs h2s => by simp_rw [h2s.image_const, is_closed_singleton]\n#align is_closed_map_const is_closed_map_const\n\n",
 "is_closed_map":
 "theorem continuous.is_closed_map [compact_space α] [t2_space β] {f : α → β} (h : continuous f) : is_closed_map f :=\n  fun s hs => (hs.is_compact.image h).is_closed\n#align continuous.is_closed_map continuous.is_closed_map\n\n",
 "is_closed_eq":
 "theorem is_closed_eq [t2_space α] {f g : β → α} (hf : continuous f) (hg : continuous g) :\n    is_closed { x : β | f x = g x } :=\n  continuous_iff_is_closed.mp (hf.prod_mk hg) _ is_closed_diagonal\n#align is_closed_eq is_closed_eq\n\n",
 "is_closed_diagonal":
 "theorem is_closed_diagonal [t2_space α] : is_closed (diagonal α) :=\n  t2_iff_is_closed_diagonal.mp ‹_›\n#align is_closed_diagonal is_closed_diagonal\n\n",
 "is_closed":
 "theorem compact_exhaustion.is_closed [t2_space α] (K : compact_exhaustion α) (n : ℕ) : is_closed (K n) :=\n  (K.is_compact n).is_closed\n#align compact_exhaustion.is_closed compact_exhaustion.is_closed\n\n",
 "is_bounded_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem bornology.relatively_compact.is_bounded_iff [t1_space α] {s : set α} :\n    @bornology.is_bounded _ (bornology.relatively_compact α) s ↔ is_compact (closure s) :=\n  by\n  change «expr ᶜ» s ∈ filter.coclosed_compact α ↔ _\n  rw [filter.mem_coclosed_compact]\n  constructor\n  · rintro ⟨t, ht₁, ht₂, hst⟩\n    rw [compl_subset_compl] at hst\n    exact is_compact_of_is_closed_subset ht₂ is_closed_closure (closure_minimal hst ht₁)\n  · intro h\n    exact ⟨closure s, is_closed_closure, h, compl_subset_compl.mpr subset_closure⟩\n#align bornology.relatively_compact.is_bounded_iff bornology.relatively_compact.is_bounded_iff\n\n",
 "inter":
 "theorem is_compact.inter [t2_space α] {s t : set α} (hs : is_compact s) (ht : is_compact t) : is_compact (s ∩ t) :=\n  hs.inter_right <| ht.is_closed\n#align is_compact.inter is_compact.inter\n\n",
 "insert_mem_nhds_within_of_subset_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/-- If `t` is a subset of `s`, except for one point,\nthen `insert x s` is a neighborhood of `x` within `t`. -/\ntheorem insert_mem_nhds_within_of_subset_insert [t1_space α] {x y : α} {s t : set α} (hu : t ⊆ insert y s) :\n    insert x s ∈ nhds_within t x := by\n  rcases eq_or_ne x y with (rfl | h)\n  · exact mem_of_superset self_mem_nhds_within hu\n  refine' nhds_within_mono x hu _\n  rw [nhds_within_insert_of_ne h]\n  exact mem_of_superset self_mem_nhds_within (subset_insert x s)\n#align insert_mem_nhds_within_of_subset_insert insert_mem_nhds_within_of_subset_insert\n\n",
 "inseparable_iff_eq":
 "theorem inseparable_iff_eq [t0_space α] {x y : α} : inseparable x y ↔ x = y :=\n  nhds_injective.eq_iff\n#align inseparable_iff_eq inseparable_iff_eq\n\n",
 "inseparable_eq_eq":
 "@[simp]\ntheorem inseparable_eq_eq [t0_space α] : inseparable = @eq α :=\n  funext₂ fun x y => propext inseparable_iff_eq\n#align inseparable_eq_eq inseparable_eq_eq\n\n",
 "injective_nhds_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\ntheorem injective_nhds_set [t1_space α] : function.injective (nhds_set : set α → filter α) := fun s t hst =>\n  nhds_set_inj_iff.mp hst\n#align injective_nhds_set injective_nhds_set\n\n",
 "infinite_of_nontrivial":
 "theorem is_preconnected.infinite_of_nontrivial [t1_space α] {s : set α} (h : is_preconnected s) (hs : s.nontrivial) :\n    s.infinite := by\n  refine' mt (fun hf => (subsingleton_coe s).mp _) (not_subsingleton_iff.mpr hs)\n  haveI := @discrete_of_t1_of_finite s _ _ hf.to_subtype\n  exact @preconnected_space.trivial_of_discrete _ _ (subtype.preconnected_space h) _\n#align is_preconnected.infinite_of_nontrivial is_preconnected.infinite_of_nontrivial\n\n",
 "infinite_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If the punctured neighborhoods of a point form a nontrivial filter, then any neighborhood is\ninfinite. -/\ntheorem infinite_of_mem_nhds {α} [topological_space α] [t1_space α] (x : α) [hx : ne_bot (nhds_within.ne x)] {s : set α}\n    (hs : s ∈ (nhds) x) : set.infinite s := by\n  refine' fun hsf => hx.1 _\n  rw [← is_open_singleton_iff_punctured_nhds]\n  exact is_open_singleton_of_finite_mem_nhds x hs hsf\n#align infinite_of_mem_nhds infinite_of_mem_nhds\n\n",
 "infinite":
 "theorem connected_space.infinite [connected_space α] [nontrivial α] [t1_space α] : Infinite α :=\n  infinite_univ_iff.mp <| is_preconnected_univ.infinite_of_nontrivial nontrivial_univ\n#align connected_space.infinite connected_space.infinite\n\n",
 "inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem regular_space.inf {X} {t₁ t₂ : topological_space X} (h₁ : @regular_space X t₁) (h₂ : @regular_space X t₂) :\n    @regular_space X («expr ⊓ » t₁ t₂) := by\n  rw [inf_eq_infᵢ]\n  exact regular_space_infi (bool.forall_bool.2 ⟨h₂, h₁⟩)\n#align regular_space.inf regular_space.inf\n\n",
 "induced_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- The topology pulled-back under an inclusion `f : X → Y` from the discrete topology (`⊥`) is the\ndiscrete topology.\nThis version does not assume the choice of a topology on either the source `X`\nnor the target `Y` of the inclusion `f`. -/\ntheorem induced_bot {X Y : Type _} {f : X → Y} (hf : function.injective f) :\n    topological_space.induced f («expr⊥») = «expr⊥» :=\n  eq_of_nhds_eq_nhds (by simp [nhds_induced, ← Set.image_singleton, hf.preimage_image, nhds_bot])\n#align induced_bot induced_bot\n\n",
 "image_closure_of_is_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_closure_of_is_compact [t2_space β] {s : set α} (hs : is_compact (closure s)) {f : α → β}\n    (hf : continuous_on f (closure s)) : «expr '' » f (closure s) = closure («expr '' » f s) :=\n  Subset.antisymm hf.image_closure <|\n    closure_minimal (image_subset f subset_closure) (hs.image_of_continuous_on hf).is_closed\n#align image_closure_of_is_compact image_closure_of_is_compact\n\n",
 "has_basis_opens_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_basis_opens_closure (a : α) : ((nhds) a).has_basis (fun s => a ∈ s ∧ is_open s) closure :=\n  (nhds_basis_opens a).nhds_closure\n#align has_basis_opens_closure has_basis_opens_closure\n\n",
 "has_basis_nhds_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_basis_nhds_closure (a : α) : ((nhds) a).has_basis (fun s => s ∈ (nhds) a) closure :=\n  ((nhds) a).basis_sets.nhds_closure\n#align has_basis_nhds_closure has_basis_nhds_closure\n\n",
 "finset_disjoint_finset_opens_of_t2":
 "theorem finset_disjoint_finset_opens_of_t2 [t2_space α] :\n    ∀ s t : Finset α, Disjoint s t → separated_nhds (s : set α) t :=\n  by\n  refine' induction_on_union _ (fun a b hi d => (hi d.symm).symm) (fun a d => empty_right a) (fun a b ab => _) _\n  · obtain ⟨U, V, oU, oV, aU, bV, UV⟩ := t2_separation (Finset.disjoint_singleton.1 ab)\n    refine' ⟨U, V, oU, oV, _, _, UV⟩ <;> exact singleton_subset_set_iff.mpr ‹_›\n  · intro a b c ac bc d\n    apply_mod_cast union_left (ac (disjoint_of_subset_left (a.subset_union_left b) d)) (bc _)\n    exact disjoint_of_subset_left (a.subset_union_right b) d\n#align finset_disjoint_finset_opens_of_t2 finset_disjoint_finset_opens_of_t2\n\n",
 "finite_compact_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. -/\ntheorem is_compact.finite_compact_cover [t2_space α] {s : set α} (hs : is_compact s) {ι} (t : Finset ι) (U : ι → set α)\n    (hU : ∀ i ∈ t, is_open (U i))\n    (hsC : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i)) :\n    ∃ K : ι → set α,\n      (∀ i, is_compact (K i)) ∧\n        (∀ i, K i ⊆ U i) ∧\n          s = «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (K i) :=\n  by\n  classical\n    induction' t using Finset.induction with x t hx ih generalizing U hU s hs hsC\n    · refine' ⟨fun _ => ∅, fun i => is_compact_empty, fun i => empty_subset _, _⟩\n      simpa only [subset_empty_iff, Union_false, Union_empty] using hsC\n    simp only [finset.set_bUnion_insert] at hsC\n    simp only [Finset.mem_insert] at hU\n    have hU' : ∀ i ∈ t, is_open (U i) := fun i hi => hU i (or.inr hi)\n    rcases hs.binary_compact_cover (hU x (or.inl rfl)) (is_open_bUnion hU') hsC with\n      ⟨K₁, K₂, h1K₁, h1K₂, h2K₁, h2K₂, hK⟩\n    rcases ih U hU' h1K₂ h2K₂ with ⟨K, h1K, h2K, h3K⟩\n    refine' ⟨update K x K₁, _, _, _⟩\n    · intro i\n      by_cases hi : i = x\n      · simp only [update_same, hi, h1K₁]\n      · rw [← ne.def] at hi\n        simp only [update_noteq hi, h1K]\n    · intro i\n      by_cases hi : i = x\n      · simp only [update_same, hi, h2K₁]\n      · rw [← ne.def] at hi\n        simp only [update_noteq hi, h2K]\n    · simp only [set_bUnion_insert_update _ hx, hK, h3K]\n#align is_compact.finite_compact_cover is_compact.finite_compact_cover\n\n",
 "ext_on":
 "/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem continuous.ext_on [t2_space α] {s : set β} (hs : dense s) {f g : β → α} (hf : continuous f) (hg : continuous g)\n    (h : EqOn f g s) : f = g :=\n  funext fun x => h.closure hf hg (hs x)\n#align continuous.ext_on continuous.ext_on\n\n",
 "exists_subset_nhds_of_is_compact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `V : ι → set α` is a decreasing family of compact sets then any neighborhood of\n`⋂ i, V i` contains some `V i`. This is a version of `exists_subset_nhd_of_compact'` where we\ndon't need to assume each `V i` closed because it follows from compactness since `α` is\nassumed to be Hausdorff. -/\ntheorem exists_subset_nhds_of_is_compact [t2_space α] {ι : Type _} [nonempty ι] {V : ι → set α}\n    (hV : Directed («expr ⊇ » · ·) V) (hV_cpct : ∀ i, is_compact (V i)) {U : set α}\n    (hU :\n      ∀ x ∈ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (V i),\n        U ∈ (nhds) x) :\n    ∃ i, V i ⊆ U :=\n  exists_subset_nhds_of_is_compact' hV hV_cpct (fun i => (hV_cpct i).is_closed) hU\n#align exists_subset_nhds_of_is_compact exists_subset_nhds_of_is_compact\n\n",
 "exists_open_with_compact_closure":
 "-- see Note [lower instance priority]\n/-- In a locally compact T₂ space, every point has an open neighborhood with compact closure -/\ntheorem exists_open_with_compact_closure [locally_compact_space α] [t2_space α] (x : α) :\n    ∃ U : set α, is_open U ∧ x ∈ U ∧ is_compact (closure U) :=\n  by\n  rcases exists_compact_mem_nhds x with ⟨K, hKc, hxK⟩\n  rcases mem_nhds_iff.1 hxK with ⟨t, h1t, h2t, h3t⟩\n  exact ⟨t, h2t, h3t, is_compact_closure_of_subset_compact hKc h1t⟩\n#align exists_open_with_compact_closure exists_open_with_compact_closure\n\n",
 "exists_open_superset_and_is_compact_closure":
 "/-- In a locally compact T₂ space, every compact set has an open neighborhood with compact closure.\n-/\ntheorem exists_open_superset_and_is_compact_closure [locally_compact_space α] [t2_space α] {K : set α}\n    (hK : is_compact K) : ∃ V, is_open V ∧ K ⊆ V ∧ is_compact (closure V) :=\n  by\n  rcases exists_compact_superset hK with ⟨K', hK', hKK'⟩\n  refine' ⟨interior K', is_open_interior, hKK', is_compact_closure_of_subset_compact hK' interior_subset⟩\n#align exists_open_superset_and_is_compact_closure exists_open_superset_and_is_compact_closure\n\n",
 "exists_open_singleton_of_open_finite":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊂ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/-- Given an open finite set `S` in a T₀ space, there is some `x ∈ S` such that `{x}` is open. -/\ntheorem exists_open_singleton_of_open_finite [t0_space α] {s : set α} (hfin : s.finite) (hne : s.nonempty)\n    (ho : is_open s) : ∃ x ∈ s, is_open ({x} : set α) :=\n  by\n  lift s to Finset α using hfin\n  induction' s using finset.strong_induction_on with s ihs\n  rcases em (∃ (t : _)(_ : «expr ⊂ » t s), t.nonempty ∧ is_open (t : set α)) with (⟨t, hts, htne, hto⟩ | ht)\n  · rcases ihs t hts htne hto with ⟨x, hxt, hxo⟩\n    exact ⟨x, hts.1 hxt, hxo⟩\n  · rcases minimal_nonempty_open_eq_singleton ho hne _ with ⟨x, hx⟩\n    · exact ⟨x, hx.symm ▸ rfl, hx ▸ ho⟩\n    refine' fun t hts htne hto => of_not_not fun hts' => ht _\n    lift t to Finset α using s.finite_to_set.subset hts\n    exact ⟨t, ssubset_iff_subset_ne.2 ⟨hts, mt Finset.coe_inj.2 hts'⟩, htne, hto⟩\n#align exists_open_singleton_of_open_finite exists_open_singleton_of_open_finite\n\n",
 "exists_open_singleton_of_fintype":
 "theorem exists_open_singleton_of_fintype [t0_space α] [Finite α] [nonempty α] : ∃ x : α, is_open ({x} : set α) :=\n  let ⟨x, _, h⟩ := exists_open_singleton_of_open_finite (set.to_finite _) univ_nonempty is_open_univ\n  ⟨x, h⟩\n#align exists_open_singleton_of_fintype exists_open_singleton_of_fintype\n\n",
 "exists_open_nhds_disjoint_closure":
 "theorem exists_open_nhds_disjoint_closure [t2_5_space α] {x y : α} (h : x ≠ y) :\n    ∃ u : set α, x ∈ u ∧ is_open u ∧ ∃ v : set α, y ∈ v ∧ is_open v ∧ Disjoint (closure u) (closure v) := by\n  simpa only [exists_prop, and_assoc] using\n    ((nhds_basis_opens x).lift'_closure.disjoint_iff (nhds_basis_opens y).lift'_closure).1\n      (disjoint_lift'_closure_nhds.2 h)\n#align exists_open_nhds_disjoint_closure exists_open_nhds_disjoint_closure\n\n",
 "exists_open_between_and_is_compact_closure":
 "/-- In a locally compact T₂ space, given a compact set `K` inside an open set `U`, we can find a\nopen set `V` between these sets with compact closure: `K ⊆ V` and the closure of `V` is inside `U`.\n-/\ntheorem exists_open_between_and_is_compact_closure [locally_compact_space α] [t2_space α] {K U : set α}\n    (hK : is_compact K) (hU : is_open U) (hKU : K ⊆ U) :\n    ∃ V, is_open V ∧ K ⊆ V ∧ closure V ⊆ U ∧ is_compact (closure V) :=\n  by\n  rcases exists_compact_between hK hU hKU with ⟨V, hV, hKV, hVU⟩\n  exact\n    ⟨interior V, is_open_interior, hKV, (closure_minimal interior_subset hV.is_closed).trans hVU,\n      is_compact_closure_of_subset_compact hV interior_subset⟩\n#align exists_open_between_and_is_compact_closure exists_open_between_and_is_compact_closure\n\n",
 "exists_nhds_disjoint_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n-- see Note [lower instance priority]\ntheorem exists_nhds_disjoint_closure [t2_5_space α] {x y : α} (h : x ≠ y) :\n    ∃ s ∈ (nhds) x, ∃ t ∈ (nhds) y, Disjoint (closure s) (closure t) :=\n  (((nhds) x).basis_sets.lift'_closure.disjoint_iff ((nhds) y).basis_sets.lift'_closure).1 <|\n    disjoint_lift'_closure_nhds.2 h\n#align exists_nhds_disjoint_closure exists_nhds_disjoint_closure\n\n",
 "exists_mem_of_ne":
 "theorem topological_space.is_topological_basis.exists_mem_of_ne [t1_space α] {b : set (set α)}\n    (hb : is_topological_basis b) {x y : α} (h : x ≠ y) : ∃ a ∈ b, x ∈ a ∧ y ∉ a :=\n  by\n  rcases hb.is_open_iff.1 is_open_ne x h with ⟨a, ab, xa, ha⟩\n  exact ⟨a, ab, xa, fun h => ha h rfl⟩\n#align topological_space.is_topological_basis.exists_mem_of_ne topological_space.is_topological_basis.exists_mem_of_ne\n\n",
 "exists_mem_nhds_is_closed_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_mem_nhds_is_closed_subset {a : α} {s : set α} (h : s ∈ (nhds) a) : ∃ t ∈ (nhds) a, is_closed t ∧ t ⊆ s :=\n  Iff.mp ((regular_space_tfae α).out 0 3) ‹_› _ _ h\n#align exists_mem_nhds_is_closed_subset exists_mem_nhds_is_closed_subset\n\n",
 "exists_is_open_xor_mem":
 "theorem exists_is_open_xor_mem [t0_space α] {x y : α} (h : x ≠ y) : ∃ U : set α, is_open U ∧ Xor' (x ∈ U) (y ∈ U) :=\n  (t0_space_iff_exists_is_open_xor_mem α).1 ‹_› x y h\n#align exists_is_open_xor_mem exists_is_open_xor_mem\n\n",
 "exists_inter_eq_singleton_of_mem_discrete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.has_basis.exists_inter_eq_singleton_of_mem_discrete {ι : Type _} {p : ι → Prop} {t : ι → set α}\n    {s : set α} [discrete_topology s] {x : α} (hb : ((nhds) x).has_basis p t) (hx : x ∈ s) :\n    ∃ (i : _)(hi : p i), t i ∩ s = {x} :=\n  by\n  rcases(nhds_within_has_basis hb s).mem_iff.1 (singleton_mem_nhds_within_of_mem_discrete hx) with ⟨i, hi, hix⟩\n  exact ⟨i, hi, subset.antisymm hix <| singleton_subset_iff.2 ⟨mem_of_mem_nhds <| hb.mem_of_mem hi, hx⟩⟩\n#align\n  filter.has_basis.exists_inter_eq_singleton_of_mem_discrete filter.has_basis.exists_inter_eq_singleton_of_mem_discrete\n\n",
 "exists_compact_superset_iff":
 "@[simp]\ntheorem exists_compact_superset_iff [t2_space α] {s : set α} : (∃ K, is_compact K ∧ s ⊆ K) ↔ is_compact (closure s) :=\n  ⟨fun ⟨K, hK, hsK⟩ => is_compact_closure_of_subset_compact hK hsK, fun h => ⟨closure s, h, subset_closure⟩⟩\n#align exists_compact_superset_iff exists_compact_superset_iff\n\n",
 "exists_closure_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem topological_space.is_topological_basis.exists_closure_subset {B : set (set α)}\n    (hB : topological_space.is_topological_basis B) {a : α} {s : set α} (h : s ∈ (nhds) a) :\n    ∃ t ∈ B, a ∈ t ∧ closure t ⊆ s := by\n  simpa only [exists_prop, and_assoc] using hB.nhds_has_basis.nhds_closure.mem_iff.mp h\n#align\n  topological_space.is_topological_basis.exists_closure_subset topological_space.is_topological_basis.exists_closure_subset\n\n",
 "exists_closed_singleton":
 "/-- Given a closed set `S` in a compact T₀ space,\nthere is some `x ∈ S` such that `{x}` is closed. -/\ntheorem is_closed.exists_closed_singleton {α : Type _} [topological_space α] [t0_space α] [compact_space α] {S : set α}\n    (hS : is_closed S) (hne : S.nonempty) : ∃ x : α, x ∈ S ∧ is_closed ({x} : set α) :=\n  by\n  obtain ⟨V, Vsub, Vne, Vcls, hV⟩ := hS.exists_minimal_nonempty_closed_subset hne\n  rcases minimal_nonempty_closed_eq_singleton Vcls Vne hV with ⟨x, rfl⟩\n  exact ⟨x, Vsub (mem_singleton x), Vcls⟩\n#align is_closed.exists_closed_singleton is_closed.exists_closed_singleton\n\n",
 "eventually_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_at.eventually_ne [topological_space β] [t1_space β] {g : α → β} {a : α} {b : β}\n    (hg1 : continuous_at g a) (hg2 : g a ≠ b) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      (g z ≠ b) :=\n  hg1.tendsto.eventually_ne hg2\n#align continuous_at.eventually_ne continuous_at.eventually_ne\n\n",
 "eq_on_closure₂'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem eq_on_closure₂' [t2_space α] {s : set β} {t : set γ} {f g : β → γ → α} (h : ∀ x ∈ s, ∀ y ∈ t, f x y = g x y)\n    (hf₁ : ∀ x, continuous (f x)) (hf₂ : ∀ y, continuous fun x => f x y) (hg₁ : ∀ x, continuous (g x))\n    (hg₂ : ∀ y, continuous fun x => g x y) : ∀ x ∈ closure s, ∀ y ∈ closure t, f x y = g x y :=\n  suffices\n    closure s ⊆\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        { x | f x y = g x y }\n    by simpa only [subset_def, mem_Inter]\n  (closure_minimal fun x hx => mem_interᵢ₂.2 <| set.eq_on.closure (h x hx) (hf₁ _) (hg₁ _)) <|\n    is_closed_bInter fun y hy => is_closed_eq (hf₂ _) (hg₂ _)\n#align eq_on_closure₂' eq_on_closure₂'\n\n",
 "eq_on_closure₂":
 "theorem eq_on_closure₂ [t2_space α] {s : set β} {t : set γ} {f g : β → γ → α} (h : ∀ x ∈ s, ∀ y ∈ t, f x y = g x y)\n    (hf : continuous (uncurry f)) (hg : continuous (uncurry g)) : ∀ x ∈ closure s, ∀ y ∈ closure t, f x y = g x y :=\n  eq_on_closure₂' h (fun x => continuous_uncurry_left x hf) (fun x => continuous_uncurry_right x hf)\n    (fun y => continuous_uncurry_left y hg) fun y => continuous_uncurry_right y hg\n#align eq_on_closure₂ eq_on_closure₂\n\n",
 "eq_of_tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a function to a `t1_space` tends to some limit `b` at some point `a`, then necessarily\n`b = f a`. -/\ntheorem eq_of_tendsto_nhds [topological_space β] [t1_space β] {f : α → β} {a : α} {b : β}\n    (h : tendsto f ((nhds) a) ((nhds) b)) : f a = b :=\n  by_contra fun hfa : f a ≠ b =>\n    have fact₁ : «expr ᶜ» {f a} ∈ (nhds) b := compl_singleton_mem_nhds hfa.symm\n    have fact₂ : tendsto f (pure a) ((nhds) b) := h.comp (tendsto_id'.2 <| pure_le_nhds a)\n    fact₂ fact₁ (eq.refl <| f a)\n#align eq_of_tendsto_nhds eq_of_tendsto_nhds\n\n",
 "eq_of_nhds_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eq_of_nhds_ne_bot [t2_space α] {x y : α} (h : ne_bot («expr ⊓ » ((nhds) x) ((nhds) y))) : x = y :=\n  t2_iff_nhds.mp ‹_› h\n#align eq_of_nhds_ne_bot eq_of_nhds_ne_bot\n\n",
 "eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes.eq [t1_space α] {x y : α} (h : «expr ⤳ » x y) : x = y :=\n  t1_space_iff_specializes_imp_eq.1 ‹_› h\n#align specializes.eq specializes.eq\n\n",
 "empty_right":
 "theorem empty_right (s : set α) : separated_nhds s ∅ :=\n  ⟨_, _, is_open_univ, is_open_empty, fun a h => mem_univ a, fun a h => by cases h, disjoint_empty _⟩\n#align empty_right empty_right\n\n",
 "empty_left":
 "theorem empty_left (s : set α) : separated_nhds ∅ s :=\n  (empty_right _).symm\n#align empty_left empty_left\n\n",
 "disjoint_pure_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem disjoint_pure_nhds [t1_space α] {x y : α} (h : x ≠ y) : Disjoint (pure x) ((nhds) y) :=\n  t1_space_iff_disjoint_pure_nhds.mp ‹_› h\n#align disjoint_pure_nhds disjoint_pure_nhds\n\n",
 "disjoint_nhds_within_of_mem_discrete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/-- For point `x` in a discrete subset `s` of a topological space, there is a set `U`\nsuch that\n1. `U` is a punctured neighborhood of `x` (ie. `U ∪ {x}` is a neighbourhood of `x`),\n2. `U` is disjoint from `s`.\n-/\ntheorem disjoint_nhds_within_of_mem_discrete {s : set α} [discrete_topology s] {x : α} (hx : x ∈ s) :\n    ∃ U ∈ nhds_within.ne x, Disjoint U s :=\n  let ⟨V, h, h'⟩ := nhds_inter_eq_singleton_of_mem_discrete hx\n  ⟨«expr ᶜ» {x} ∩ V, inter_mem_nhds_within _ h,\n    disjoint_iff_inter_eq_empty.mpr (by rw [inter_assoc, h', compl_inter_self])⟩\n#align disjoint_nhds_within_of_mem_discrete disjoint_nhds_within_of_mem_discrete\n\n",
 "disjoint_nhds_set_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem disjoint_nhds_set_nhds : Disjoint ((nhds_set) s) ((nhds) a) ↔ a ∉ closure s :=\n  Iff.mp ((regular_space_tfae α).out 0 2) ‹_› _ _\n#align disjoint_nhds_set_nhds disjoint_nhds_set_nhds\n\n",
 "disjoint_nhds_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem disjoint_nhds_pure [t1_space α] {x y : α} (h : x ≠ y) : Disjoint ((nhds) x) (pure y) :=\n  t1_space_iff_disjoint_nhds_pure.mp ‹_› h\n#align disjoint_nhds_pure disjoint_nhds_pure\n\n",
 "disjoint_nhds_nhds_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\ntheorem disjoint_nhds_nhds_set : Disjoint ((nhds) a) ((nhds_set) s) ↔ a ∉ closure s :=\n  disjoint_comm.trans disjoint_nhds_set_nhds\n#align disjoint_nhds_nhds_set disjoint_nhds_nhds_set\n\n",
 "disjoint_nhds_nhds_iff_not_specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem disjoint_nhds_nhds_iff_not_specializes {a b : α} : Disjoint ((nhds) a) ((nhds) b) ↔ ¬«expr ⤳ » a b := by\n  rw [← nhds_set_singleton, disjoint_nhds_set_nhds, specializes_iff_mem_closure]\n#align disjoint_nhds_nhds_iff_not_specializes disjoint_nhds_nhds_iff_not_specializes\n\n",
 "disjoint_nhds_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem disjoint_nhds_nhds [t2_space α] {x y : α} : Disjoint ((nhds) x) ((nhds) y) ↔ x ≠ y :=\n  ⟨fun hd he => by simpa [he, nhds_ne_bot.ne] using hd, t2_space_iff_disjoint_nhds.mp ‹_› x y⟩\n#align disjoint_nhds_nhds disjoint_nhds_nhds\n\n",
 "disjoint_nested_nhds":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (U₁ V₁ «expr ∈ » nhds() x) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (U₂ V₂ «expr ∈ » nhds() y) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Given two points `x ≠ y`, we can find neighbourhoods `x ∈ V₁ ⊆ U₁` and `y ∈ V₂ ⊆ U₂`,\nwith the `Vₖ` closed and the `Uₖ` open, such that the `Uₖ` are disjoint. -/\ntheorem disjoint_nested_nhds [t3_space α] {x y : α} (h : x ≠ y) :\n    ∃ (U₁ : _)(_ : U₁ ∈ (nhds) x)(V₁ : _)(_ : V₁ ∈ (nhds) x)(U₂ : _)(_ : U₂ ∈ (nhds) y)(V₂ : _)(_ : V₂ ∈ (nhds) y),\n      is_closed V₁ ∧ is_closed V₂ ∧ is_open U₁ ∧ is_open U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ Disjoint U₁ U₂ :=\n  by\n  rcases t2_separation h with ⟨U₁, U₂, U₁_op, U₂_op, x_in, y_in, H⟩\n  rcases exists_mem_nhds_is_closed_subset (U₁_op.mem_nhds x_in) with ⟨V₁, V₁_in, V₁_closed, h₁⟩\n  rcases exists_mem_nhds_is_closed_subset (U₂_op.mem_nhds y_in) with ⟨V₂, V₂_in, V₂_closed, h₂⟩\n  exact\n    ⟨U₁, mem_of_superset V₁_in h₁, V₁, V₁_in, U₂, mem_of_superset V₂_in h₂, V₂, V₂_in, V₁_closed, V₂_closed, U₁_op,\n      U₂_op, h₁, h₂, H⟩\n#align disjoint_nested_nhds disjoint_nested_nhds\n\n",
 "disjoint_lift'_closure_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem disjoint_lift'_closure_nhds [t2_5_space α] {x y : α} :\n    Disjoint (((nhds) x).lift' closure) (((nhds) y).lift' closure) ↔ x ≠ y :=\n  ⟨fun h hxy => by simpa [hxy, nhds_ne_bot.ne] using h, fun h => t2_5_space.t2_5 h⟩\n#align disjoint_lift'_closure_nhds disjoint_lift'_closure_nhds\n\n",
 "disjoint_closure_right":
 "theorem disjoint_closure_right (h : separated_nhds s t) : Disjoint s (closure t) :=\n  h.symm.disjoint_closure_left.symm\n#align disjoint_closure_right disjoint_closure_right\n\n",
 "disjoint_closure_left":
 "theorem disjoint_closure_left (h : separated_nhds s t) : Disjoint (closure s) t :=\n  let ⟨U, V, hU, hV, hsU, htV, hd⟩ := h\n  (hd.closure_left hV).mono (closure_mono hsU) htV\n#align disjoint_closure_left disjoint_closure_left\n\n",
 "discrete_topology_induced":
 "/-- The topology induced under an inclusion `f : X → Y` from the discrete topological space `Y`\nis the discrete topology on `X`. -/\ntheorem discrete_topology_induced {X Y : Type _} [tY : topological_space Y] [discrete_topology Y] {f : X → Y}\n    (hf : function.injective f) : @discrete_topology X (topological_space.induced f tY) := by\n  apply discrete_topology.mk <;> · rw [discrete_topology.eq_bot Y, induced_bot hf]\n#align discrete_topology_induced discrete_topology_induced\n\n",
 "discrete_topology":
 "theorem embedding.discrete_topology {X Y : Type _} [topological_space X] [tY : topological_space Y]\n    [discrete_topology Y] {f : X → Y} (hf : embedding f) : discrete_topology X :=\n  ⟨by rw [hf.induced, discrete_topology.eq_bot Y, induced_bot hf.inj]⟩\n#align embedding.discrete_topology embedding.discrete_topology\n\n",
 "discrete_of_t1_of_finite":
 "theorem discrete_of_t1_of_finite {X : Type _} [topological_space X] [t1_space X] [Finite X] : discrete_topology X :=\n  by\n  apply singletons_open_iff_discrete.mp\n  intro x\n  rw [← is_closed_compl_iff]\n  exact (set.to_finite _).is_closed\n#align discrete_of_t1_of_finite discrete_of_t1_of_finite\n\n",
 "diff_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/-- Removing a non-isolated point from a dense set, one still obtains a dense set. -/\ntheorem dense.diff_singleton [t1_space α] {s : set α} (hs : dense s) (x : α) [ne_bot (nhds_within.ne x)] :\n    dense (s \\ {x}) :=\n  hs.inter_of_open_right (dense_compl_singleton x) is_open_compl_singleton\n#align dense.diff_singleton dense.diff_singleton\n\n",
 "diff_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/-- Removing a finset from a dense set in a space without isolated points, one still\nobtains a dense set. -/\ntheorem dense.diff_finset [t1_space α] [∀ x : α, ne_bot (nhds_within.ne x)] {s : set α} (hs : dense s) (t : Finset α) :\n    dense (s \\ t) := by\n  induction' t using Finset.induction_on with x s hxs ih hd\n  · simpa using hs\n  · rw [Finset.coe_insert, ← union_singleton, ← diff_diff]\n    exact ih.diff_singleton _\n#align dense.diff_finset dense.diff_finset\n\n",
 "diff_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/-- Removing a finite set from a dense set in a space without isolated points, one still\nobtains a dense set. -/\ntheorem dense.diff_finite [t1_space α] [∀ x : α, ne_bot (nhds_within.ne x)] {s : set α} (hs : dense s) {t : set α}\n    (ht : t.finite) : dense (s \\ t) := by\n  convert hs.diff_finset ht.to_finset\n  exact (finite.coe_to_finset _).symm\n#align dense.diff_finite dense.diff_finite\n\n",
 "continuous_within_at_update_of_ne":
 "theorem continuous_within_at_update_of_ne [t1_space α] [decidable_eq α] [topological_space β] {f : α → β} {s : set α}\n    {x y : α} {z : β} (hne : y ≠ x) : continuous_within_at (function.update f x z) s y ↔ continuous_within_at f s y :=\n  eventually_eq.congr_continuous_within_at\n    (mem_nhds_within_of_mem_nhds <|\n      mem_of_superset (is_open_ne.mem_nhds hne) fun y' hy' => function.update_noteq hy' _ _)\n    (function.update_noteq hne _ _)\n#align continuous_within_at_update_of_ne continuous_within_at_update_of_ne\n\n",
 "continuous_on_update_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_on_update_iff [t1_space α] [decidable_eq α] [topological_space β] {f : α → β} {s : set α} {x : α}\n    {y : β} :\n    continuous_on (function.update f x y) s ↔\n      continuous_on f (s \\ {x}) ∧ (x ∈ s → tendsto f (nhds_within (s \\ {x}) x) ((nhds) y)) :=\n  by\n  rw [continuous_on, ← and_forall_ne x, and_comm']\n  refine' and_congr ⟨fun H z hz => _, fun H z hzx hzs => _⟩ (forall_congr' fun hxs => _)\n  · specialize H z hz.2 hz.1\n    rw [continuous_within_at_update_of_ne hz.2] at H\n    exact H.mono (diff_subset _ _)\n  · rw [continuous_within_at_update_of_ne hzx]\n    refine' (H z ⟨hzs, hzx⟩).mono_of_mem (inter_mem_nhds_within _ _)\n    exact is_open_ne.mem_nhds hzx\n  · exact continuous_within_at_update_same\n#align continuous_on_update_iff continuous_on_update_iff\n\n",
 "continuous_of":
 "theorem cofinite_topology.continuous_of [t1_space α] : continuous (@cofinite_topology.of α) :=\n  t1_space_iff_continuous_cofinite_of.mp ‹_›\n#align cofinite_topology.continuous_of cofinite_topology.continuous_of\n\n",
 "continuous_at_update_of_ne":
 "theorem continuous_at_update_of_ne [t1_space α] [decidable_eq α] [topological_space β] {f : α → β} {x y : α} {z : β}\n    (hne : y ≠ x) : continuous_at (function.update f x z) y ↔ continuous_at f y := by\n  simp only [← continuous_within_at_univ, continuous_within_at_update_of_ne hne]\n#align continuous_at_update_of_ne continuous_at_update_of_ne\n\n",
 "continuous_at_of_tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- To prove a function to a `t1_space` is continuous at some point `a`, it suffices to prove that\n`f` admits *some* limit at `a`. -/\ntheorem continuous_at_of_tendsto_nhds [topological_space β] [t1_space β] {f : α → β} {a : α} {b : β}\n    (h : tendsto f ((nhds) a) ((nhds) b)) : continuous_at f a :=\n  show tendsto f ((nhds) a) (nhds <| f a) by rwa [eq_of_tendsto_nhds h]\n#align continuous_at_of_tendsto_nhds continuous_at_of_tendsto_nhds\n\n",
 "connected_component_eq_Inter_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n-- see Note [lower instance priority]\n/-- In a compact t2 space, the connected component of a point equals the intersection of all\nits clopen neighbourhoods. -/\ntheorem connected_component_eq_Inter_clopen [t2_space α] [compact_space α] (x : α) :\n    connected_component x =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" Z :=\n  by\n  apply eq_of_subset_of_subset connected_component_subset_Inter_clopen\n  -- Reduce to showing that the clopen intersection is connected.\n  refine' is_preconnected.subset_connected_component _ (mem_Inter.2 fun Z => Z.2.2)\n  -- We do this by showing that any disjoint cover by two closed sets implies\n  -- that one of these closed sets must contain our whole thing.\n  -- To reduce to the case where the cover is disjoint on all of `α` we need that `s` is closed\n  have hs :\n    @is_closed α _\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" Z) :=\n    is_closed_Inter fun Z => Z.2.1.2\n  rw [is_preconnected_iff_subset_of_fully_disjoint_closed hs]\n  intro a b ha hb hab ab_disj\n  haveI := @normal_of_compact_t2 α _ _ _\n  -- Since our space is normal, we get two larger disjoint open sets containing the disjoint\n  -- closed sets. If we can show that our intersection is a subset of any of these we can then\n  -- \"descend\" this to show that it is a subset of either a or b.\n  rcases normal_separation ha hb ab_disj with ⟨u, v, hu, hv, hau, hbv, huv⟩\n  -- If we can find a clopen set around x, contained in u ∪ v, we get a disjoint decomposition\n  -- Z = Z ∩ u ∪ Z ∩ v of clopen sets. The intersection of all clopen neighbourhoods will then lie\n  -- in whichever of u or v x lies in and hence will be a subset of either a or b.\n  rsuffices ⟨Z, H⟩ : ∃ Z : set α, is_clopen Z ∧ x ∈ Z ∧ Z ⊆ u ∪ v\n  · have H1 := is_clopen_inter_of_disjoint_cover_clopen H.1 H.2.2 hu hv huv\n    rw [union_comm] at H\n    have H2 := is_clopen_inter_of_disjoint_cover_clopen H.1 H.2.2 hv hu huv.symm\n    by_cases x ∈ u\n    -- The x ∈ u case.\n    · left\n      suffices «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑Z ⊆ u\n        by\n        replace hab :\n          «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑Z ≤ a ∪ b :=\n          hab\n        replace this :\n          «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑Z ≤ u := this\n        exact Disjoint.left_le_of_le_sup_right hab (huv.mono this hbv)\n      · apply subset.trans _ (inter_subset_right Z u)\n        apply Inter_subset (fun Z : { Z : set α // is_clopen Z ∧ x ∈ Z } => ↑Z) ⟨Z ∩ u, H1, mem_inter H.2.1 h⟩\n    -- If x ∉ u, we get x ∈ v since x ∈ u ∪ v. The rest is then like the x ∈ u case.\n    have h1 : x ∈ v :=\n      by\n      cases'\n        (mem_union x u v).1\n          (mem_of_subset_of_mem (subset.trans hab (union_subset_union hau hbv)) (mem_Inter.2 fun i => i.2.2)) with\n        h1 h1\n      · exfalso\n        exact h h1\n      · exact h1\n    right\n    suffices «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑Z ⊆ v\n      by\n      replace this :\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑Z ≤ v := this\n      exact (huv.symm.mono this hau).left_le_of_le_sup_left hab\n    · apply subset.trans _ (inter_subset_right Z v)\n      apply Inter_subset (fun Z : { Z : set α // is_clopen Z ∧ x ∈ Z } => ↑Z) ⟨Z ∩ v, H2, mem_inter H.2.1 h1⟩\n  -- Now we find the required Z. We utilize the fact that X \\ u ∪ v will be compact,\n  -- so there must be some finite intersection of clopen neighbourhoods of X disjoint to it,\n  -- but a finite intersection of clopen sets is clopen so we let this be our Z.\n  have H1 :=\n    (hu.union hv).is_closed_compl.is_compact.inter_Inter_nonempty (fun Z : { Z : set α // is_clopen Z ∧ x ∈ Z } => Z)\n      fun Z => Z.2.1.2\n  rw [← not_disjoint_iff_nonempty_inter, imp_not_comm, not_forall] at H1\n  cases' H1 (disjoint_compl_left_iff_subset.2 <| hab.trans <| union_subset_union hau hbv) with Zi H2\n  refine'\n    ⟨«expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (subtype.val U), _,\n      _, _⟩\n  · exact is_clopen_bInter_finset fun Z hZ => Z.2.1\n  · exact mem_Inter₂.2 fun Z hZ => Z.2.2\n  · rwa [← disjoint_compl_left_iff_subset, disjoint_iff_inter_eq_empty, ← not_nonempty_iff_eq_empty]\n#align connected_component_eq_Inter_clopen connected_component_eq_Inter_clopen\n\n",
 "compl_singleton_mem_nhds_set_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n@[simp]\ntheorem compl_singleton_mem_nhds_set_iff [t1_space α] {x : α} {s : set α} : «expr ᶜ» {x} ∈ (nhds_set) s ↔ x ∉ s := by\n  rwa [is_open_compl_singleton.mem_nhds_set, subset_compl_singleton_iff]\n#align compl_singleton_mem_nhds_set_iff compl_singleton_mem_nhds_set_iff\n\n",
 "compl_singleton_mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n-- see Note [lower instance priority]\n@[simp]\ntheorem compl_singleton_mem_nhds_iff [t1_space α] {x y : α} : «expr ᶜ» {x} ∈ (nhds) y ↔ y ≠ x :=\n  is_open_compl_singleton.mem_nhds_iff\n#align compl_singleton_mem_nhds_iff compl_singleton_mem_nhds_iff\n\n",
 "compl_singleton_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem compl_singleton_mem_nhds [t1_space α] {x y : α} (h : y ≠ x) : «expr ᶜ» {x} ∈ (nhds) y :=\n  compl_singleton_mem_nhds_iff.mpr h\n#align compl_singleton_mem_nhds compl_singleton_mem_nhds\n\n",
 "compact_t2_tot_disc_iff_tot_sep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\n  is also true for locally compact spaces. -/\ntheorem compact_t2_tot_disc_iff_tot_sep : totally_disconnected_space α ↔ totally_separated_space α :=\n  by\n  constructor\n  · intro h\n    constructor\n    rintro x - y -\n    contrapose!\n    intro hyp\n    suffices x ∈ connected_component y by\n      simpa [totally_disconnected_space_iff_connected_component_singleton.1 h y, mem_singleton_iff]\n    rw [connected_component_eq_Inter_clopen, mem_Inter]\n    rintro ⟨w : set α, hw : is_clopen w, hy : y ∈ w⟩\n    by_contra hx\n    exact\n      hyp («expr ᶜ» w) w hw.2.is_open_compl hw.1 hx hy (@isCompl_compl _ w _).symm.codisjoint.top_le disjoint_compl_left\n  apply totally_separated_space.totally_disconnected_space\n#align compact_t2_tot_disc_iff_tot_sep compact_t2_tot_disc_iff_tot_sep\n\n",
 "compact_exists_clopen_in_open":
 "/-- Every member of an open set in a compact Hausdorff totally disconnected space\n  is contained in a clopen set contained in the open set.  -/\ntheorem compact_exists_clopen_in_open {x : α} {U : set α} (is_open : is_open U) (memU : x ∈ U) :\n    ∃ (V : set α)(hV : is_clopen V), x ∈ V ∧ V ⊆ U :=\n  (is_topological_basis.mem_nhds_iff is_topological_basis_clopen).1 (is_open.mem_nhds memU)\n#align compact_exists_clopen_in_open compact_exists_clopen_in_open\n\n",
 "comm":
 "#print comm /-\ntheorem comm (s t : set α) : separated_nhds s t ↔ separated_nhds t s :=\n  ⟨symm, symm⟩\n#align comm comm\n-/\n\n",
 "coclosed_compact_le_cofinite":
 "theorem filter.coclosed_compact_le_cofinite [t1_space α] : filter.coclosed_compact α ≤ filter.cofinite := fun s hs =>\n  compl_compl s ▸ hs.is_compact.compl_mem_coclosed_compact_of_is_closed hs.is_closed\n#align filter.coclosed_compact_le_cofinite filter.coclosed_compact_le_cofinite\n\n",
 "coclosed_compact_eq_cocompact":
 "@[simp]\ntheorem filter.coclosed_compact_eq_cocompact [t2_space α] : coclosed_compact α = cocompact α := by\n  simp [coclosed_compact, cocompact, infᵢ_and', and_iff_right_of_imp is_compact.is_closed]\n#align filter.coclosed_compact_eq_cocompact filter.coclosed_compact_eq_cocompact\n\n",
 "closure_singleton":
 "@[simp]\ntheorem closure_singleton [t1_space α] {a : α} : closure ({a} : set α) = {a} :=\n  is_closed_singleton.closure_eq\n#align closure_singleton closure_singleton\n\n",
 "closure":
 "/-- If two continuous maps are equal on `s`, then they are equal on the closure of `s`. See also\n`set.eq_on.of_subset_closure` for a more general version. -/\ntheorem set.eq_on.closure [t2_space α] {s : set β} {f g : β → α} (h : EqOn f g s) (hf : continuous f)\n    (hg : continuous g) : EqOn f g (closure s) :=\n  closure_minimal h (is_closed_eq hf hg)\n#align set.eq_on.closure set.eq_on.closure\n\n",
 "closed_range":
 "theorem function.left_inverse.closed_range [t2_space α] {f : α → β} {g : β → α} (h : function.left_inverse f g)\n    (hf : continuous f) (hg : continuous g) : is_closed (range g) :=\n  have : EqOn (g ∘ f) id (closure <| range g) := h.right_inv_on_range.eq_on.closure (hg.comp hf) continuous_id\n  is_closed_of_closure_subset fun x hx =>\n    calc\n      x = g (f x) := (this hx).symm\n      _ ∈ _ := mem_range_self _\n      \n#align function.left_inverse.closed_range function.left_inverse.closed_range\n\n",
 "closed_nhds_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem closed_nhds_basis (a : α) : ((nhds) a).has_basis (fun s : set α => s ∈ (nhds) a ∧ is_closed s) id :=\n  has_basis_self.2 fun _ => exists_mem_nhds_is_closed_subset\n#align closed_nhds_basis closed_nhds_basis\n\n",
 "closed_embedding":
 "theorem continuous.closed_embedding [compact_space α] [t2_space β] {f : α → β} (h : continuous f)\n    (hf : function.injective f) : closed_embedding f :=\n  closed_embedding_of_continuous_injective_closed h hf h.is_closed_map\n#align continuous.closed_embedding continuous.closed_embedding\n\n",
 "binary_compact_cover":
 "/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem is_compact.binary_compact_cover [t2_space α] {K U V : set α} (hK : is_compact K) (hU : is_open U)\n    (hV : is_open V) (h2K : K ⊆ U ∪ V) :\n    ∃ K₁ K₂ : set α, is_compact K₁ ∧ is_compact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂ :=\n  by\n  obtain ⟨O₁, O₂, h1O₁, h1O₂, h2O₁, h2O₂, hO⟩ :=\n    is_compact_is_compact_separated (hK.diff hU) (hK.diff hV)\n      (by rwa [disjoint_iff_inter_eq_empty, diff_inter_diff, diff_eq_empty])\n  exact\n    ⟨_, _, hK.diff h1O₁, hK.diff h1O₂, by rwa [diff_subset_comm], by rwa [diff_subset_comm], by\n      rw [← diff_inter, hO.inter_eq, diff_empty]⟩\n#align is_compact.binary_compact_cover is_compact.binary_compact_cover\n\n",
 "bInter_basis_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem bInter_basis_nhds [t1_space α] {ι : Sort _} {p : ι → Prop} {s : ι → set α} {x : α}\n    (h : ((nhds) x).has_basis p s) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i) = {x} :=\n  by\n  simp only [eq_singleton_iff_unique_mem, mem_Inter]\n  refine' ⟨fun i hi => mem_of_mem_nhds <| h.mem_of_mem hi, fun y hy => _⟩\n  contrapose! hy\n  rcases h.mem_iff.1 (compl_singleton_mem_nhds hy.symm) with ⟨i, hi, hsub⟩\n  exact ⟨i, hi, fun h => hsub h rfl⟩\n#align bInter_basis_nhds bInter_basis_nhds\n\n",
 "Lim_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n@[simp]\ntheorem Lim_nhds_within {a : α} {s : set α} (h : a ∈ closure s) : @Lim _ _ ⟨a⟩ (nhds_within s a) = a :=\n  haveI : ne_bot (nhds_within s a) := mem_closure_iff_cluster_pt.1 h\n  Lim_eq inf_le_left\n#align Lim_nhds_within Lim_nhds_within\n\n",
 "Lim_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem Lim_nhds (a : α) : @Lim _ _ ⟨a⟩ ((nhds) a) = a :=\n  Lim_eq le_rfl\n#align Lim_nhds Lim_nhds\n\n",
 "Lim_eq_iff_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ultrafilter.Lim_eq_iff_le_nhds [compact_space α] {x : α} {F : ultrafilter α} : F.Lim = x ↔ ↑F ≤ (nhds) x :=\n  ⟨fun h => h ▸ F.le_nhds_Lim, Lim_eq⟩\n#align ultrafilter.Lim_eq_iff_le_nhds ultrafilter.Lim_eq_iff_le_nhds\n\n",
 "Lim_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem Lim_eq_iff [ne_bot f] (h : ∃ a : α, f ≤ nhds a) {a} : @Lim _ _ ⟨a⟩ f = a ↔ f ≤ (nhds) a :=\n  ⟨fun c => c ▸ le_nhds_Lim h, Lim_eq⟩\n#align Lim_eq_iff Lim_eq_iff\n\n",
 "Lim_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem Lim_eq {a : α} [ne_bot f] (h : f ≤ (nhds) a) : @Lim _ _ ⟨a⟩ f = a :=\n  tendsto_nhds_unique (le_nhds_Lim ⟨a, h⟩) h\n#align Lim_eq Lim_eq\n\n",
 "Disjoint":
 "#print Disjoint /-\nprotected theorem Disjoint (h : separated_nhds s t) : Disjoint s t :=\n  let ⟨U, V, hU, hV, hsU, htV, hd⟩ := h\n  hd.mono hsU htV\n#align disjoint Disjoint\n-/\n\n"}