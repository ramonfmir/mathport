{"union_right":
 "theorem union_right (ht : SeparatedNhds s t) (hu : SeparatedNhds s u) : SeparatedNhds s (t ∪ u) :=\n  (ht.symm.union_left hu.symm).symm\n#align union_right union_right\n\n",
 "union_left":
 "theorem union_left : SeparatedNhds s u → SeparatedNhds t u → SeparatedNhds (s ∪ t) u := by\n  simpa only [separatedNhds_iff_disjoint, nhdsSet_union, disjoint_sup_left] using and.intro\n#align union_left union_left\n\n",
 "trivial_of_discrete":
 "#print PreconnectedSpace.trivial_of_discrete /-\ntheorem PreconnectedSpace.trivial_of_discrete [PreconnectedSpace α] [DiscreteTopology α] : subsingleton α :=\n  by\n  rw [← not_nontrivial_iff_subsingleton]\n  rintro ⟨x, y, hxy⟩\n  rw [ne.def, ← mem_singleton_iff, (isClopen_discrete _).eq_univ <| singleton_nonempty y] at hxy\n  exact hxy (mem_univ x)\n#align preconnected_space.trivial_of_discrete PreconnectedSpace.trivial_of_discrete\n-/\n\n",
 "totallySeparatedSpace_of_t1_of_basis_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print totallySeparatedSpace_of_t1_of_basis_clopen /-\n/-- A T1 space with a clopen basis is totally separated. -/\ntheorem totallySeparatedSpace_of_t1_of_basis_clopen [T1Space α] (h : IsTopologicalBasis { s : Set α | IsClopen s }) :\n    TotallySeparatedSpace α := by\n  constructor\n  rintro x - y - hxy\n  rcases h.mem_nhds_iff.mp (is_open_ne.mem_nhds hxy) with ⟨U, hU, hxU, hyU⟩\n  exact\n    ⟨U, «expr ᶜ» U, hU.is_open, hU.compl.is_open, hxU, fun h => hyU h rfl, (union_compl_self U).superset,\n      disjoint_compl_right⟩\n#align totally_separated_space_of_t1_of_basis_clopen totallySeparatedSpace_of_t1_of_basis_clopen\n-/\n\n",
 "tendsto_nhds_unique_of_frequently_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n#print tendsto_nhds_unique_of_frequently_eq /-\ntheorem tendsto_nhds_unique_of_frequently_eq [T2Space α] {f g : β → α} {l : Filter β} {a b : α}\n    (ha : Tendsto f l ((nhds) a)) (hb : Tendsto g l ((nhds) b))\n    (hfg :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" l\n        (f x = g x)) :\n    a = b :=\n  have :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n      ((nhds) (a, b)) (z.1 = z.2) :=\n    (ha.prod_mk_nhds hb).frequently hfg\n  Classical.not_not.1 fun hne => this (isClosed_diagonal.is_open_compl.mem_nhds hne)\n#align tendsto_nhds_unique_of_frequently_eq tendsto_nhds_unique_of_frequently_eq\n-/\n\n",
 "tendsto_nhds_unique_of_eventuallyEq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n#print tendsto_nhds_unique_of_eventuallyEq /-\ntheorem tendsto_nhds_unique_of_eventuallyEq [T2Space α] {f g : β → α} {l : Filter β} {a b : α} [NeBot l]\n    (ha : Tendsto f l ((nhds) a)) (hb : Tendsto g l ((nhds) b)) (hfg : «expr =ᶠ[ ] » f l g) : a = b :=\n  tendsto_nhds_unique (ha.congr' hfg) hb\n#align tendsto_nhds_unique_of_eventually_eq tendsto_nhds_unique_of_eventuallyEq\n-/\n\n",
 "tendsto_nhds_unique'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_nhds_unique' /-\ntheorem tendsto_nhds_unique' [T2Space α] {f : β → α} {l : Filter β} {a b : α} (hl : NeBot l)\n    (ha : Tendsto f l ((nhds) a)) (hb : Tendsto f l ((nhds) b)) : a = b :=\n  eq_of_nhds_neBot <| neBot_of_le <| le_inf ha hb\n#align tendsto_nhds_unique' tendsto_nhds_unique'\n-/\n\n",
 "tendsto_nhds_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_nhds_unique /-\ntheorem tendsto_nhds_unique [T2Space α] {f : β → α} {l : Filter β} {a b : α} [NeBot l] (ha : Tendsto f l ((nhds) a))\n    (hb : Tendsto f l ((nhds) b)) : a = b :=\n  eq_of_nhds_neBot <| neBot_of_le <| le_inf ha hb\n#align tendsto_nhds_unique tendsto_nhds_unique\n-/\n\n",
 "tendsto_const_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_const_nhds_iff /-\n@[simp]\ntheorem tendsto_const_nhds_iff [T1Space α] {l : Filter β} [NeBot l] {c d : α} :\n    Tendsto (fun x => c) l ((nhds) d) ↔ c = d := by simp_rw [tendsto, Filter.map_const, pure_le_nhds_iff]\n#align tendsto_const_nhds_iff tendsto_const_nhds_iff\n-/\n\n",
 "t5Space":
 "#print Embedding.t5Space /-\ntheorem Embedding.t5Space [TopologicalSpace β] [T5Space β] {e : α → β} (he : Embedding e) : T5Space α :=\n  by\n  haveI := he.t1_space\n  refine' ⟨fun s t hd₁ hd₂ => _⟩\n  simp only [he.to_inducing.nhds_set_eq_comap]\n  refine' disjoint_comap (completely_normal _ _)\n  ·\n    rwa [← subset_compl_iff_disjoint_left, image_subset_iff, preimage_compl, ← he.closure_eq_preimage_closure_image,\n      subset_compl_iff_disjoint_left]\n  ·\n    rwa [← subset_compl_iff_disjoint_right, image_subset_iff, preimage_compl, ← he.closure_eq_preimage_closure_image,\n      subset_compl_iff_disjoint_right]\n#align embedding.t5_space Embedding.t5Space\n-/\n\n",
 "t3Space":
 "#print Embedding.t3Space /-\n-- see Note [lower instance priority]\nprotected theorem Embedding.t3Space [TopologicalSpace β] [T3Space β] {f : α → β} (hf : Embedding f) : T3Space α :=\n  { to_t0_space := hf.t0_space\n    to_regular_space := hf.to_inducing.regular_space }\n#align embedding.t3_space Embedding.t3Space\n-/\n\n",
 "t2_separation_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print t2_separation_nhds /-\ntheorem t2_separation_nhds [T2Space α] {x y : α} (h : x ≠ y) : ∃ u v, u ∈ (nhds) x ∧ v ∈ (nhds) y ∧ Disjoint u v :=\n  let ⟨u, v, open_u, open_v, x_in, y_in, huv⟩ := t2_separation h\n  ⟨u, v, open_u.mem_nhds x_in, open_v.mem_nhds y_in, huv⟩\n#align t2_separation_nhds t2_separation_nhds\n-/\n\n",
 "t2_separation_compact_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print t2_separation_compact_nhds /-\ntheorem t2_separation_compact_nhds [LocallyCompactSpace α] [T2Space α] {x y : α} (h : x ≠ y) :\n    ∃ u v, u ∈ (nhds) x ∧ v ∈ (nhds) y ∧ IsCompact u ∧ IsCompact v ∧ Disjoint u v := by\n  simpa only [exists_prop, ← exists_and_left, and_comm', and_assoc, and_left_comm] using\n    ((compact_basis_nhds x).disjoint_iff (compact_basis_nhds y)).1 (disjoint_nhds_nhds.2 h)\n#align t2_separation_compact_nhds t2_separation_compact_nhds\n-/\n\n",
 "t2_separation":
 "#print Set.Finite.t2_separation /-\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem Set.Finite.t2_separation [T2Space α] {s : Set α} (hs : s.finite) :\n    ∃ U : α → Set α, (∀ x, x ∈ U x ∧ IsOpen (U x)) ∧ s.pairwise_disjoint U :=\n  s.pairwise_disjoint_nhds.exists_mem_filter_basis hs nhds_basis_opens\n#align set.finite.t2_separation Set.Finite.t2_separation\n-/\n\n",
 "t2_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print t2_iff_ultrafilter /-\ntheorem t2_iff_ultrafilter : T2Space α ↔ ∀ {x y : α} (f : Ultrafilter α), ↑f ≤ (nhds) x → ↑f ≤ (nhds) y → x = y :=\n  t2_iff_nhds.trans <| by simp only [← exists_ultrafilter_iff, and_imp, le_inf_iff, exists_imp]\n#align t2_iff_ultrafilter t2_iff_ultrafilter\n-/\n\n",
 "t2_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print t2_iff_nhds /-\n-- see Note [lower instance priority]\n/-- A space is T₂ iff the neighbourhoods of distinct points generate the bottom filter. -/\ntheorem t2_iff_nhds : T2Space α ↔ ∀ {x y : α}, NeBot («expr ⊓ » ((nhds) x) ((nhds) y)) → x = y := by\n  simp only [t2Space_iff_disjoint_nhds, disjoint_iff, ne_bot_iff, ne.def, not_imp_comm]\n#align t2_iff_nhds t2_iff_nhds\n-/\n\n",
 "t2_iff_isClosed_diagonal":
 "#print t2_iff_isClosed_diagonal /-\ntheorem t2_iff_isClosed_diagonal : T2Space α ↔ IsClosed (diagonal α) := by\n  simp only [t2Space_iff_disjoint_nhds, ← isOpen_compl_iff, isOpen_iff_mem_nhds, Prod.forall, nhds_prod_eq,\n    compl_diagonal_mem_prod, mem_compl_iff, mem_diagonal_iff]\n#align t2_iff_is_closed_diagonal t2_iff_isClosed_diagonal\n-/\n\n",
 "t2Space_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print t2Space_iff_nhds /-\ntheorem t2Space_iff_nhds : T2Space α ↔ ∀ {x y : α}, x ≠ y → ∃ U ∈ (nhds) x, ∃ V ∈ (nhds) y, Disjoint U V := by\n  simp only [t2Space_iff_disjoint_nhds, Filter.disjoint_iff]\n#align t2_space_iff_nhds t2Space_iff_nhds\n-/\n\n",
 "t2Space_iff_disjoint_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print t2Space_iff_disjoint_nhds /-\ntheorem t2Space_iff_disjoint_nhds : T2Space α ↔ ∀ x y : α, x ≠ y → Disjoint ((nhds) x) ((nhds) y) :=\n  by\n  refine' (t2_space_iff α).trans (forall₃_congr fun x y hne => _)\n  simp only [(nhds_basis_opens x).disjoint_iff (nhds_basis_opens y), exists_prop, ← exists_and_left, and_assoc,\n    and_comm', and_left_comm]\n#align t2_space_iff_disjoint_nhds t2Space_iff_disjoint_nhds\n-/\n\n",
 "t2Space":
 "#print Embedding.t2Space /-\ntheorem Embedding.t2Space [TopologicalSpace β] [T2Space β] {f : α → β} (hf : Embedding f) : T2Space α :=\n  ⟨fun x y h => separated_by_continuous hf.continuous (hf.inj.ne h)⟩\n#align embedding.t2_space Embedding.t2Space\n-/\n\n",
 "t1Space_of_injective_of_continuous":
 "#print t1Space_of_injective_of_continuous /-\ntheorem t1Space_of_injective_of_continuous [TopologicalSpace β] {f : α → β} (hf : function.injective f)\n    (hf' : Continuous f) [T1Space β] : T1Space α :=\n  t1Space_iff_specializes_imp_eq.2 fun x y h => hf (h.map hf').eq\n#align t1_space_of_injective_of_continuous t1Space_of_injective_of_continuous\n-/\n\n",
 "t1Space_iff_specializes_imp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n#print t1Space_iff_specializes_imp_eq /-\ntheorem t1Space_iff_specializes_imp_eq : T1Space α ↔ ∀ ⦃x y : α⦄, «expr ⤳ » x y → x = y :=\n  (t1Space_TFAE α).out 0 9\n#align t1_space_iff_specializes_imp_eq t1Space_iff_specializes_imp_eq\n-/\n\n",
 "t1Space_iff_exists_open":
 "#print t1Space_iff_exists_open /-\ntheorem t1Space_iff_exists_open : T1Space α ↔ ∀ x y, x ≠ y → ∃ (U : Set α)(hU : IsOpen U), x ∈ U ∧ y ∉ U :=\n  (t1Space_TFAE α).out 0 6\n#align t1_space_iff_exists_open t1Space_iff_exists_open\n-/\n\n",
 "t1Space_iff_disjoint_pure_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print t1Space_iff_disjoint_pure_nhds /-\ntheorem t1Space_iff_disjoint_pure_nhds : T1Space α ↔ ∀ ⦃x y : α⦄, x ≠ y → Disjoint (pure x) ((nhds) y) :=\n  (t1Space_TFAE α).out 0 8\n#align t1_space_iff_disjoint_pure_nhds t1Space_iff_disjoint_pure_nhds\n-/\n\n",
 "t1Space_iff_disjoint_nhds_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print t1Space_iff_disjoint_nhds_pure /-\ntheorem t1Space_iff_disjoint_nhds_pure : T1Space α ↔ ∀ ⦃x y : α⦄, x ≠ y → Disjoint ((nhds) x) (pure y) :=\n  (t1Space_TFAE α).out 0 7\n#align t1_space_iff_disjoint_nhds_pure t1Space_iff_disjoint_nhds_pure\n-/\n\n",
 "t1Space_iff_continuous_cofinite_of":
 "#print t1Space_iff_continuous_cofinite_of /-\ntheorem t1Space_iff_continuous_cofinite_of {α : Type _} [TopologicalSpace α] :\n    T1Space α ↔ Continuous (@CofiniteTopology.of α) :=\n  (t1Space_TFAE α).out 0 3\n#align t1_space_iff_continuous_cofinite_of t1Space_iff_continuous_cofinite_of\n-/\n\n",
 "t1Space_antitone":
 "#print t1Space_antitone /-\ntheorem t1Space_antitone {α : Type _} : Antitone (@T1Space α) :=\n  by\n  simp only [Antitone, t1Space_iff_continuous_cofinite_of, continuous_iff_le_induced]\n  exact fun t₁ t₂ h => h.trans\n#align t1_space_antitone t1Space_antitone\n-/\n\n",
 "t1Space_TFAE":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n#print t1Space_TFAE /-\ntheorem t1Space_TFAE (α : Type u) [TopologicalSpace α] :\n    TFAE\n      [T1Space α, ∀ x, IsClosed ({x} : Set α), ∀ x, IsOpen («expr ᶜ» {x} : Set α), Continuous (@CofiniteTopology.of α),\n        ∀ ⦃x y : α⦄, x ≠ y → «expr ᶜ» {y} ∈ (nhds) x, ∀ ⦃x y : α⦄, x ≠ y → ∃ s ∈ (nhds) x, y ∉ s,\n        ∀ ⦃x y : α⦄, x ≠ y → ∃ (U : Set α)(hU : IsOpen U), x ∈ U ∧ y ∉ U,\n        ∀ ⦃x y : α⦄, x ≠ y → Disjoint ((nhds) x) (pure y), ∀ ⦃x y : α⦄, x ≠ y → Disjoint (pure x) ((nhds) y),\n        ∀ ⦃x y : α⦄, «expr ⤳ » x y → x = y] :=\n  by\n  tfae_have 1 ↔ 2; exact ⟨fun h => h.1, fun h => ⟨h⟩⟩\n  tfae_have 2 ↔ 3; · simp only [isOpen_compl_iff]\n  tfae_have 5 ↔ 3\n  · refine' forall_swap.trans _\n    simp only [isOpen_iff_mem_nhds, mem_compl_iff, mem_singleton_iff]\n  tfae_have 5 ↔ 6\n  · simp only [← subset_compl_singleton_iff, exists_mem_subset_iff]\n  tfae_have 5 ↔ 7\n  · simp only [(nhds_basis_opens _).mem_iff, subset_compl_singleton_iff, exists_prop, and_assoc, and_left_comm]\n  tfae_have 5 ↔ 8\n  · simp only [← principal_singleton, disjoint_principal_right]\n  tfae_have 8 ↔ 9; exact forall_swap.trans (by simp only [disjoint_comm, ne_comm])\n  tfae_have 1 → 4\n  · simp only [continuous_def, CofiniteTopology.isOpen_iff']\n    rintro H s (rfl | hs)\n    exacts[isOpen_empty, compl_compl s ▸ (@Set.Finite.isClosed _ _ H _ hs).is_open_compl]\n  tfae_have 4 → 2\n  exact fun h x => (CofiniteTopology.isClosed_iff.2 <| or.inr (finite_singleton _)).preimage h\n  tfae_have 2 ↔ 10\n  · simp only [← closure_subset_iff_isClosed, specializes_iff_mem_closure, subset_def, mem_singleton_iff, eq_comm]\n  tfae_finish\n#align t1_space_tfae t1Space_TFAE\n-/\n\n",
 "t1Space":
 "#print Embedding.t1Space /-\nprotected theorem Embedding.t1Space [TopologicalSpace β] [T1Space β] {f : α → β} (hf : Embedding f) : T1Space α :=\n  t1Space_of_injective_of_continuous hf.inj hf.continuous\n#align embedding.t1_space Embedding.t1Space\n-/\n\n",
 "t0Space_of_injective_of_continuous":
 "#print t0Space_of_injective_of_continuous /-\ntheorem t0Space_of_injective_of_continuous [TopologicalSpace β] {f : α → β} (hf : function.injective f)\n    (hf' : Continuous f) [T0Space β] : T0Space α :=\n  ⟨fun x y h => hf <| (h.map hf').eq⟩\n#align t0_space_of_injective_of_continuous t0Space_of_injective_of_continuous\n-/\n\n",
 "t0Space_iff_or_not_mem_closure":
 "#print t0Space_iff_or_not_mem_closure /-\ntheorem t0Space_iff_or_not_mem_closure (α : Type u) [TopologicalSpace α] :\n    T0Space α ↔ ∀ a b : α, a ≠ b → a ∉ closure ({b} : Set α) ∨ b ∉ closure ({a} : Set α) := by\n  simp only [t0Space_iff_not_inseparable, inseparable_iff_mem_closure, not_and_or]\n#align t0_space_iff_or_not_mem_closure t0Space_iff_or_not_mem_closure\n-/\n\n",
 "t0Space_iff_not_inseparable":
 "#print t0Space_iff_not_inseparable /-\ntheorem t0Space_iff_not_inseparable (α : Type u) [TopologicalSpace α] :\n    T0Space α ↔ ∀ x y : α, x ≠ y → ¬Inseparable x y := by simp only [t0Space_iff_inseparable, ne.def, not_imp_not]\n#align t0_space_iff_not_inseparable t0Space_iff_not_inseparable\n-/\n\n",
 "t0Space_iff_nhds_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print t0Space_iff_nhds_injective /-\ntheorem t0Space_iff_nhds_injective (α : Type u) [TopologicalSpace α] : T0Space α ↔ injective (nhds : α → Filter α) :=\n  t0Space_iff_inseparable α\n#align t0_space_iff_nhds_injective t0Space_iff_nhds_injective\n-/\n\n",
 "t0Space_iff_inseparable":
 "#print t0Space_iff_inseparable /-\ntheorem t0Space_iff_inseparable (α : Type u) [TopologicalSpace α] : T0Space α ↔ ∀ x y : α, Inseparable x y → x = y :=\n  ⟨fun ⟨h⟩ => h, fun h => ⟨h⟩⟩\n#align t0_space_iff_inseparable t0Space_iff_inseparable\n-/\n\n",
 "t0Space_iff_exists_isOpen_xor'_mem":
 "#print t0Space_iff_exists_isOpen_xor'_mem /-\ntheorem t0Space_iff_exists_isOpen_xor'_mem (α : Type u) [TopologicalSpace α] :\n    T0Space α ↔ ∀ x y, x ≠ y → ∃ U : Set α, IsOpen U ∧ Xor' (x ∈ U) (y ∈ U) := by\n  simp only [t0Space_iff_not_inseparable, xor_iff_not_iff, not_forall, exists_prop, inseparable_iff_forall_open]\n#align t0_space_iff_exists_is_open_xor_mem t0Space_iff_exists_isOpen_xor'_mem\n-/\n\n",
 "t0Space":
 "#print Embedding.t0Space /-\nprotected theorem Embedding.t0Space [TopologicalSpace β] [T0Space β] {f : α → β} (hf : Embedding f) : T0Space α :=\n  t0Space_of_injective_of_continuous hf.inj hf.continuous\n#align embedding.t0_space Embedding.t0Space\n-/\n\n",
 "symm":
 "#print symm /-\n@[symm]\ntheorem symm : SeparatedNhds s t → SeparatedNhds t s := fun ⟨U, V, oU, oV, aU, bV, UV⟩ =>\n  ⟨V, U, oV, oU, bV, aU, Disjoint.symm UV⟩\n#align symm symm\n-/\n\n",
 "subsingleton_closure":
 "#print subsingleton_closure /-\n@[simp]\ntheorem subsingleton_closure [T1Space α] {s : Set α} : (closure s).subsingleton ↔ s.subsingleton :=\n  ⟨fun h => h.anti subset_closure, fun h => h.closure⟩\n#align subsingleton_closure subsingleton_closure\n-/\n\n",
 "subset_trans":
 "#print TopologicalSpace.subset_trans /-\n/-- Let `X` be a topological space and let `s, t ⊆ X` be two subsets.  If there is an inclusion\n`t ⊆ s`, then the topological space structure on `t` induced by `X` is the same as the one\nobtained by the induced topological space structure on `s`. -/\ntheorem TopologicalSpace.subset_trans {X : Type _} [tX : TopologicalSpace X] {s t : Set X} (ts : t ⊆ s) :\n    (subtype.topological_space : TopologicalSpace t) =\n      (subtype.topological_space : TopologicalSpace s).induced (Set.inclusion ts) :=\n  by\n  change tX.induced ((coe : s → X) ∘ Set.inclusion ts) = TopologicalSpace.induced (Set.inclusion ts) (tX.induced _)\n  rw [← induced_compose]\n#align topological_space.subset_trans TopologicalSpace.subset_trans\n-/\n\n",
 "strictMono_nhdsSet":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n#print strictMono_nhdsSet /-\ntheorem strictMono_nhdsSet [T1Space α] : StrictMono (nhds_set : Set α → Filter α) :=\n  monotone_nhdsSet.strict_mono_of_injective injective_nhdsSet\n#align strict_mono_nhds_set strictMono_nhdsSet\n-/\n\n",
 "specializes_iff_inseparable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n#print specializes_iff_inseparable /-\ntheorem specializes_iff_inseparable {a b : α} : «expr ⤳ » a b ↔ Inseparable a b :=\n  ⟨fun h => h.antisymm h.symm, le_of_eq⟩\n#align specializes_iff_inseparable specializes_iff_inseparable\n-/\n\n",
 "specializes_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n#print specializes_iff_eq /-\ntheorem specializes_iff_eq [T1Space α] {x y : α} : «expr ⤳ » x y ↔ x = y :=\n  ⟨Specializes.eq, fun h => h ▸ specializes_rfl⟩\n#align specializes_iff_eq specializes_iff_eq\n-/\n\n",
 "specializes_eq_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⤳ » -/\n#print specializes_eq_eq /-\n@[simp]\ntheorem specializes_eq_eq [T1Space α] : («expr ⤳ » · ·) = @Eq α :=\n  funext₂ fun x y => propext specializes_iff_eq\n#align specializes_eq_eq specializes_eq_eq\n-/\n\n",
 "specializes_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n#print specializes_comm /-\ntheorem specializes_comm {a b : α} : «expr ⤳ » a b ↔ «expr ⤳ » b a := by\n  simp only [← disjoint_nhds_nhds_iff_not_specializes.not_left, disjoint_comm]\n#align specializes_comm specializes_comm\n-/\n\n",
 "singleton_mem_nhdsWithin_of_mem_discrete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print singleton_mem_nhdsWithin_of_mem_discrete /-\ntheorem singleton_mem_nhdsWithin_of_mem_discrete {s : Set α} [DiscreteTopology s] {x : α} (hx : x ∈ s) :\n    {x} ∈ nhds_within s x :=\n  by\n  have : ({⟨x, hx⟩} : Set s) ∈ (nhds) (⟨x, hx⟩ : s) := by simp [nhds_discrete]\n  simpa only [nhdsWithin_eq_map_subtype_coe hx, image_singleton] using @image_mem_map _ _ _ (coe : s → α) _ this\n#align singleton_mem_nhds_within_of_mem_discrete singleton_mem_nhdsWithin_of_mem_discrete\n-/\n\n",
 "separated_by_openEmbedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print separated_by_openEmbedding /-\ntheorem separated_by_openEmbedding {α β : Type _} [TopologicalSpace α] [TopologicalSpace β] [T2Space α] {f : α → β}\n    (hf : OpenEmbedding f) {x y : α} (h : x ≠ y) :\n    ∃ u v : Set β, IsOpen u ∧ IsOpen v ∧ f x ∈ u ∧ f y ∈ v ∧ Disjoint u v :=\n  let ⟨u, v, uo, vo, xu, yv, uv⟩ := t2_separation h\n  ⟨«expr '' » f u, «expr '' » f v, hf.is_open_map _ uo, hf.is_open_map _ vo, mem_image_of_mem _ xu,\n    mem_image_of_mem _ yv, disjoint_image_of_injective hf.inj uv⟩\n#align separated_by_open_embedding separated_by_openEmbedding\n-/\n\n",
 "separated_by_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print separated_by_continuous /-\n-- see Note [lower instance priority]\ntheorem separated_by_continuous {α : Type _} {β : Type _} [TopologicalSpace α] [TopologicalSpace β] [T2Space β]\n    {f : α → β} (hf : Continuous f) {x y : α} (h : f x ≠ f y) :\n    ∃ u v : Set α, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n  let ⟨u, v, uo, vo, xu, yv, uv⟩ := t2_separation h\n  ⟨«expr ⁻¹' » f u, «expr ⁻¹' » f v, uo.preimage hf, vo.preimage hf, xu, yv, uv.preimage _⟩\n#align separated_by_continuous separated_by_continuous\n-/\n\n",
 "separatedNhds_iff_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n#print separatedNhds_iff_disjoint /-\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\ntheorem separatedNhds_iff_disjoint {s t : Set α} : SeparatedNhds s t ↔ Disjoint ((nhds_set) s) ((nhds_set) t) := by\n  simp only [(hasBasis_nhdsSet s).disjoint_iff (hasBasis_nhdsSet t), SeparatedNhds, exists_prop, ← exists_and_left,\n    and_assoc, and_comm, and_left_comm]\n#align separated_nhds_iff_disjoint separatedNhds_iff_disjoint\n-/\n\n",
 "relativelyCompact_eq_inCompact":
 "#print Bornology.relativelyCompact_eq_inCompact /-\n@[simp]\ntheorem Bornology.relativelyCompact_eq_inCompact [T2Space α] : Bornology.relativelyCompact α = Bornology.inCompact α :=\n  by rw [Bornology.ext_iff] <;> exact Filter.coclosedCompact_eq_cocompact\n#align bornology.relatively_compact_eq_in_compact Bornology.relativelyCompact_eq_inCompact\n-/\n\n",
 "regularSpace_infₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_closed_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print regularSpace_infₛ /-\ntheorem regularSpace_infₛ {X} {T : Set (TopologicalSpace X)} (h : ∀ t ∈ T, @RegularSpace X t) :\n    @RegularSpace X (infₛ T) := by\n  letI := Inf T\n  have :\n    ∀ a,\n      ((nhds) a).has_basis\n        (fun If : ΣI : Set T, I → Set X => If.1.finite ∧ ∀ i : If.1, If.2 i ∈ @nhds X i a ∧ (is_closed_of ↑i) (If.2 i))\n        fun If =>\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (If.snd i) :=\n    by\n    intro a\n    rw [nhds_infₛ, ← infᵢ_subtype'']\n    exact has_basis_infi fun t : T => @closed_nhds_basis X t (h t t.2) a\n  refine' RegularSpace.ofBasis this fun a If hIf => isClosed_interᵢ fun i => _\n  exact (hIf.2 i).2.mono (infₛ_le (i : T).2)\n#align regular_space_Inf regularSpace_infₛ\n-/\n\n",
 "regularSpace_infᵢ":
 "#print regularSpace_infᵢ /-\ntheorem regularSpace_infᵢ {ι X} {t : ι → TopologicalSpace X} (h : ∀ i, @RegularSpace X (t i)) :\n    @RegularSpace X (infᵢ t) :=\n  regularSpace_infₛ <| forall_range_iff.mpr h\n#align regular_space_infi regularSpace_infᵢ\n-/\n\n",
 "regularSpace_induced":
 "#print regularSpace_induced /-\ntheorem regularSpace_induced (f : β → α) : @RegularSpace β (induced f ‹_›) :=\n  letI := induced f ‹_›\n  Inducing.regularSpace ⟨rfl⟩\n#align regular_space_induced regularSpace_induced\n-/\n\n",
 "regularSpace_TFAE":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (a «expr ∉ » closure[closure] s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print regularSpace_TFAE /-\ntheorem regularSpace_TFAE (X : Type u) [TopologicalSpace X] :\n    TFAE\n      [RegularSpace X, ∀ (s : Set X) (a) (_ : a ∉ closure s), Disjoint ((nhds_set) s) ((nhds) a),\n        ∀ (a : X) (s : Set X), Disjoint ((nhds_set) s) ((nhds) a) ↔ a ∉ closure s,\n        ∀ (a : X), ∀ s ∈ (nhds) a, ∃ t ∈ (nhds) a, IsClosed t ∧ t ⊆ s, ∀ a : X, ((nhds) a).lift' closure ≤ (nhds) a,\n        ∀ a : X, ((nhds) a).lift' closure = (nhds) a] :=\n  by\n  tfae_have 1 ↔ 5\n  · rw [regular_space_iff, (@compl_surjective (Set X) _).forall, forall_swap]\n    simp only [isClosed_compl_iff, mem_compl_iff, Classical.not_not, @and_comm' (_ ∈ _),\n      (nhds_basis_opens _).lift'_closure.le_basis_iff (nhds_basis_opens _), and_imp,\n      (nhds_basis_opens _).disjoint_iff_right, exists_prop, ← subset_interior_iff_mem_nhdsSet, interior_compl,\n      compl_subset_compl]\n  tfae_have 5 → 6; exact fun h a => (h a).antisymm ((nhds) _).le_lift'_closure\n  tfae_have 6 → 4\n  · intro H a s hs\n    rw [← H] at hs\n    rcases((nhds) a).basis_sets.lift'_closure.mem_iff.mp hs with ⟨U, hU, hUs⟩\n    exact ⟨closure U, mem_of_superset hU subset_closure, isClosed_closure, hUs⟩\n  tfae_have 4 → 2\n  · intro H s a ha\n    have ha' : «expr ᶜ» s ∈ (nhds) a := by rwa [← mem_interior_iff_mem_nhds, interior_compl]\n    rcases H _ _ ha' with ⟨U, hU, hUc, hUs⟩\n    refine' disjoint_of_disjoint_of_mem disjoint_compl_left _ hU\n    rwa [← subset_interior_iff_mem_nhdsSet, hUc.is_open_compl.interior_eq, subset_compl_comm]\n  tfae_have 2 → 3\n  · refine' fun H a s => ⟨fun hd has => mem_closure_iff_nhds_ne_bot.mp has _, H s a⟩\n    exact (hd.symm.mono_right <| @principal_le_nhdsSet _ _ s).eq_bot\n  tfae_have 3 → 1; exact fun H => ⟨fun s a hs ha => (H _ _).mpr <| hs.closure_eq.symm ▸ ha⟩\n  tfae_finish\n#align regular_space_tfae regularSpace_TFAE\n-/\n\n",
 "regularSpace":
 "#print Inducing.regularSpace /-\nprotected theorem Inducing.regularSpace [TopologicalSpace β] {f : β → α} (hf : Inducing f) : RegularSpace β :=\n  RegularSpace.ofBasis\n    (fun b => by\n      rw [hf.nhds_eq_comap b]\n      exact (closed_nhds_basis _).comap _)\n    fun b s hs => hs.2.preimage hf.continuous\n#align inducing.regular_space Inducing.regularSpace\n-/\n\n",
 "pure_le_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print pure_le_nhds_iff /-\n@[simp]\ntheorem pure_le_nhds_iff [T1Space α] {a b : α} : pure a ≤ (nhds) b ↔ a = b :=\n  specializes_iff_pure.symm.trans specializes_iff_eq\n#align pure_le_nhds_iff pure_le_nhds_iff\n-/\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage [TopologicalSpace β] {f : α → β} {s t : Set β} (h : SeparatedNhds s t) (hf : Continuous f) :\n    SeparatedNhds («expr ⁻¹' » f s) («expr ⁻¹' » f t) :=\n  let ⟨U, V, oU, oV, sU, tV, UV⟩ := h\n  ⟨«expr ⁻¹' » f U, «expr ⁻¹' » f V, oU.preimage hf, oV.preimage hf, preimage_mono sU, preimage_mono tV, UV.preimage f⟩\n#align preimage preimage\n\n",
 "point_disjoint_finset_opens_of_t2":
 "#print point_disjoint_finset_opens_of_t2 /-\ntheorem point_disjoint_finset_opens_of_t2 [T2Space α] {x : α} {s : Finset α} (h : x ∉ s) :\n    SeparatedNhds ({x} : Set α) s := by\n  exact_mod_cast finset_disjoint_finset_opens_of_t2 {x} s (finset.disjoint_singleton_left.mpr h)\n#align point_disjoint_finset_opens_of_t2 point_disjoint_finset_opens_of_t2\n-/\n\n",
 "pairwise_disjoint_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print pairwise_disjoint_nhds /-\ntheorem pairwise_disjoint_nhds [T2Space α] : Pairwise («expr on » Disjoint (nhds : α → Filter α)) := fun x y =>\n  disjoint_nhds_nhds.2\n#align pairwise_disjoint_nhds pairwise_disjoint_nhds\n-/\n\n",
 "pairwiseDisjoint_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Set.pairwiseDisjoint_nhds /-\nprotected theorem Set.pairwiseDisjoint_nhds [T2Space α] (s : Set α) : s.pairwise_disjoint (nhds) :=\n  pairwise_disjoint_nhds.set_pairwise s\n#align set.pairwise_disjoint_nhds Set.pairwiseDisjoint_nhds\n-/\n\n",
 "of_subset_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print Set.EqOn.of_subset_closure /-\n/-- If `f x = g x` for all `x ∈ s` and `f`, `g` are continuous on `t`, `s ⊆ t ⊆ closure s`, then\n`f x = g x` for all `x ∈ t`. See also `set.eq_on.closure`. -/\ntheorem Set.EqOn.of_subset_closure [T2Space α] {s t : Set β} {f g : β → α} (h : EqOn f g s) (hf : ContinuousOn f t)\n    (hg : ContinuousOn g t) (hst : s ⊆ t) (hts : t ⊆ closure s) : EqOn f g t :=\n  by\n  intro x hx\n  have : (nhds_within s x).ne_bot := mem_closure_iff_cluster_pt.mp (hts hx)\n  exact\n    tendsto_nhds_unique_of_eventuallyEq ((hf x hx).mono_left <| nhdsWithin_mono _ hst)\n      ((hg x hx).mono_left <| nhdsWithin_mono _ hst) (h.eventually_eq_of_mem self_mem_nhdsWithin)\n#align set.eq_on.of_subset_closure Set.EqOn.of_subset_closure\n-/\n\n",
 "of_open_cover":
 "#print T0Space.of_open_cover /-\ntheorem T0Space.of_open_cover (h : ∀ x, ∃ s : Set α, x ∈ s ∧ IsOpen s ∧ T0Space s) : T0Space α :=\n  T0Space.of_cover fun x y hxy =>\n    let ⟨s, hxs, hso, hs⟩ := h x\n    ⟨s, hxs, (hxy.mem_open_iff hso).1 hxs, hs⟩\n#align t0_space.of_open_cover T0Space.of_open_cover\n-/\n\n",
 "of_cover":
 "#print T0Space.of_cover /-\ntheorem T0Space.of_cover (h : ∀ x y, Inseparable x y → ∃ s : Set α, x ∈ s ∧ y ∈ s ∧ T0Space s) : T0Space α :=\n  by\n  refine' ⟨fun x y hxy => _⟩\n  rcases h x y hxy with ⟨s, hxs, hys, hs⟩; skip\n  lift x to s using hxs; lift y to s using hys\n  rw [← subtype_inseparable_iff] at hxy\n  exact congr_arg coe hxy.eq\n#align t0_space.of_cover T0Space.of_cover\n-/\n\n",
 "ofLift'_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print RegularSpace.ofLift'_closure /-\ntheorem RegularSpace.ofLift'_closure (h : ∀ a : α, ((nhds) a).lift' closure = (nhds) a) : RegularSpace α :=\n  Iff.mpr ((regularSpace_TFAE α).out 0 5) h\n#align regular_space.of_lift'_closure RegularSpace.ofLift'_closure\n-/\n\n",
 "ofExistsMemNhdsIsClosedSubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print RegularSpace.ofExistsMemNhdsIsClosedSubset /-\ntheorem RegularSpace.ofExistsMemNhdsIsClosedSubset (h : ∀ (a : α), ∀ s ∈ (nhds) a, ∃ t ∈ (nhds) a, IsClosed t ∧ t ⊆ s) :\n    RegularSpace α :=\n  Iff.mpr ((regularSpace_TFAE α).out 0 3) h\n#align regular_space.of_exists_mem_nhds_is_closed_subset RegularSpace.ofExistsMemNhdsIsClosedSubset\n-/\n\n",
 "ofBasis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print RegularSpace.ofBasis /-\ntheorem RegularSpace.ofBasis {ι : α → Sort _} {p : ∀ a, ι a → Prop} {s : ∀ a, ι a → Set α}\n    (h₁ : ∀ a, ((nhds) a).has_basis (p a) (s a)) (h₂ : ∀ a i, p a i → IsClosed (s a i)) : RegularSpace α :=\n  RegularSpace.ofLift'_closure fun a => (h₁ a).lift'_closure_eq_self (h₂ a)\n#align regular_space.of_basis RegularSpace.ofBasis\n-/\n\n",
 "not_preirreducible_nontrivial_t2":
 "#print not_preirreducible_nontrivial_t2 /-\n/-- There does not exist a nontrivial preirreducible T₂ space. -/\ntheorem not_preirreducible_nontrivial_t2 (α) [TopologicalSpace α] [PreirreducibleSpace α] [Nontrivial α] [T2Space α] :\n    False :=\n  (preirreducible_space.is_preirreducible_univ α).subsingleton.not_nontrivial nontrivial_univ\n#align not_preirreducible_nontrivial_t2 not_preirreducible_nontrivial_t2\n-/\n\n",
 "normal_separation":
 "#print normal_separation /-\ntheorem normal_separation [NormalSpace α] {s t : Set α} (H1 : IsClosed s) (H2 : IsClosed t) (H3 : Disjoint s t) :\n    SeparatedNhds s t :=\n  normal_space.normal s t H1 H2 H3\n#align normal_separation normal_separation\n-/\n\n",
 "normal_exists_closure_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print normal_exists_closure_subset /-\ntheorem normal_exists_closure_subset [NormalSpace α] {s t : Set α} (hs : IsClosed s) (ht : IsOpen t) (hst : s ⊆ t) :\n    ∃ u, IsOpen u ∧ s ⊆ u ∧ closure u ⊆ t :=\n  by\n  have : Disjoint s («expr ᶜ» t) := set.disjoint_left.mpr fun x hxs hxt => hxt (hst hxs)\n  rcases normal_separation hs (isClosed_compl_iff.2 ht) this with ⟨s', t', hs', ht', hss', htt', hs't'⟩\n  refine' ⟨s', hs', hss', subset.trans (closure_minimal _ (isClosed_compl_iff.2 ht')) (compl_subset_comm.1 htt')⟩\n  exact fun x hxs hxt => hs't'.le_bot ⟨hxs, hxt⟩\n#align normal_exists_closure_subset normal_exists_closure_subset\n-/\n\n",
 "normalSpaceOfT3SecondCountable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print normalSpaceOfT3SecondCountable /-\n/-- A T₃ topological space with second countable topology is a normal space.\nThis lemma is not an instance to avoid a loop. -/\ntheorem normalSpaceOfT3SecondCountable [SecondCountableTopology α] [T3Space α] : NormalSpace α :=\n  by\n  have key :\n    ∀ {s t : Set α},\n      IsClosed t →\n        Disjoint s t →\n          ∃ U : Set (countable_basis α),\n            s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑u ∧\n              (∀ u ∈ U, Disjoint (closure ↑u) t) ∧\n                ∀ n : ℕ,\n                  IsClosed\n                    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                      (closure (u : Set α))) :=\n    by\n    intro s t hc hd\n    rw [disjoint_left] at hd\n    have : ∀ x ∈ s, ∃ U ∈ countable_basis α, x ∈ U ∧ Disjoint (closure U) t :=\n      by\n      intro x hx\n      rcases(is_basis_countable_basis α).exists_closure_subset (hc.is_open_compl.mem_nhds (hd hx)) with\n        ⟨u, hu, hxu, hut⟩\n      exact ⟨u, hu, hxu, disjoint_left.2 hut⟩\n    choose! U hu hxu hd\n    set V : s → countable_basis α := maps_to.restrict _ _ _ hu\n    refine' ⟨range V, _, forall_range_iff.2 <| Subtype.forall.2 hd, fun n => _⟩\n    · rw [bUnion_range]\n      exact fun x hx => mem_Union.2 ⟨⟨x, hx⟩, hxu x hx⟩\n    · simp only [← supr_eq_Union, supᵢ_and']\n      exact\n        isClosed_bunionᵢ (((finite_le_nat n).preimage_embedding (Encodable.encode' _)).subset <| inter_subset_right _ _)\n          fun u hu => isClosed_closure\n  refine' ⟨fun s t hs ht hd => _⟩\n  rcases key ht hd with ⟨U, hsU, hUd, hUc⟩\n  rcases key hs hd.symm with ⟨V, htV, hVd, hVc⟩\n  refine'\n    ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (↑u \\\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (closure ↑v)),\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (↑v \\\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (closure ↑u)),\n      isOpen_bunionᵢ fun u hu => (is_open_of_mem_countable_basis u.2).sdiff (hVc _),\n      isOpen_bunionᵢ fun v hv => (is_open_of_mem_countable_basis v.2).sdiff (hUc _), fun x hx => _, fun x hx => _, _⟩\n  · rcases mem_Union₂.1 (hsU hx) with ⟨u, huU, hxu⟩\n    refine' mem_bUnion huU ⟨hxu, _⟩\n    simp only [mem_Union]\n    rintro ⟨v, hvV, -, hxv⟩\n    exact (hVd v hvV).le_bot ⟨hxv, hx⟩\n  · rcases mem_Union₂.1 (htV hx) with ⟨v, hvV, hxv⟩\n    refine' mem_bUnion hvV ⟨hxv, _⟩\n    simp only [mem_Union]\n    rintro ⟨u, huU, -, hxu⟩\n    exact (hUd u huU).le_bot ⟨hxu, hx⟩\n  · simp only [disjoint_left, mem_Union, mem_diff, not_exists, not_and, not_forall, Classical.not_not]\n    rintro a ⟨u, huU, hau, haV⟩ v hvV hav\n    cases' le_total (encodable.encode u) (encodable.encode v) with hle hle\n    exacts[⟨u, huU, hle, subset_closure hau⟩, (haV _ hvV hle <| subset_closure hav).elim]\n#align normal_space_of_t3_second_countable normalSpaceOfT3SecondCountable\n-/\n\n",
 "normalSpace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print ClosedEmbedding.normalSpace /-\nprotected theorem ClosedEmbedding.normalSpace [TopologicalSpace β] [NormalSpace β] {f : α → β}\n    (hf : ClosedEmbedding f) : NormalSpace α :=\n  { to_t1_space := hf.to_embedding.t1_space\n    normal := by\n      intro s t hs ht hst\n      have H : SeparatedNhds («expr '' » f s) («expr '' » f t) :=\n        normal_space.normal («expr '' » f s) («expr '' » f t) (hf.is_closed_map s hs) (hf.is_closed_map t ht)\n          (disjoint_image_of_injective hf.inj hst)\n      exact (H.preimage hf.continuous).mono (subset_preimage_image _ _) (subset_preimage_image _ _) }\n#align closed_embedding.normal_space ClosedEmbedding.normalSpace\n-/\n\n",
 "normalOfCompactT2":
 "#print normalOfCompactT2 /-\n-- see Note [lower instance priority]\n-- We can't make this an instance because it could cause an instance loop.\ntheorem normalOfCompactT2 [CompactSpace α] [T2Space α] : NormalSpace α :=\n  ⟨fun s t hs ht => isCompact_isCompact_separated hs.is_compact ht.is_compact⟩\n#align normal_of_compact_t2 normalOfCompactT2\n-/\n\n",
 "nhds_le_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_le_nhds_iff /-\n@[simp]\ntheorem nhds_le_nhds_iff [T1Space α] {a b : α} : (nhds) a ≤ (nhds) b ↔ a = b :=\n  specializes_iff_eq\n#align nhds_le_nhds_iff nhds_le_nhds_iff\n-/\n\n",
 "nhds_le_nhdsSet_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n#print nhds_le_nhdsSet_iff /-\n@[simp]\ntheorem nhds_le_nhdsSet_iff [T1Space α] {s : Set α} {x : α} : (nhds) x ≤ (nhds_set) s ↔ x ∈ s := by\n  rw [← nhdsSet_singleton, nhdsSet_le_iff, singleton_subset_iff]\n#align nhds_le_nhds_set_iff nhds_le_nhdsSet_iff\n-/\n\n",
 "nhds_inter_eq_singleton_of_mem_discrete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_inter_eq_singleton_of_mem_discrete /-\n/-- A point `x` in a discrete subset `s` of a topological space admits a neighbourhood\nthat only meets `s` at `x`.  -/\ntheorem nhds_inter_eq_singleton_of_mem_discrete {s : Set α} [DiscreteTopology s] {x : α} (hx : x ∈ s) :\n    ∃ U ∈ (nhds) x, U ∩ s = {x} := by simpa using ((nhds) x).basis_sets.exists_inter_eq_singleton_of_mem_discrete hx\n#align nhds_inter_eq_singleton_of_mem_discrete nhds_inter_eq_singleton_of_mem_discrete\n-/\n\n",
 "nhds_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_injective /-\ntheorem nhds_injective [T0Space α] : injective (nhds : α → Filter α) :=\n  (t0Space_iff_nhds_injective α).1 ‹_›\n#align nhds_injective nhds_injective\n-/\n\n",
 "nhds_eq_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_eq_nhds_iff /-\n@[simp]\ntheorem nhds_eq_nhds_iff [T0Space α] {a b : α} : (nhds) a = (nhds) b ↔ a = b :=\n  nhds_injective.eq_iff\n#align nhds_eq_nhds_iff nhds_eq_nhds_iff\n-/\n\n",
 "nhds_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.HasBasis.nhds_closure /-\ntheorem Filter.HasBasis.nhds_closure {ι : Sort _} {a : α} {p : ι → Prop} {s : ι → Set α}\n    (h : ((nhds) a).has_basis p s) : ((nhds) a).has_basis p fun i => closure (s i) :=\n  lift'_nhds_closure a ▸ h.lift'_closure\n#align filter.has_basis.nhds_closure Filter.HasBasis.nhds_closure\n-/\n\n",
 "nhds_basis_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print TopologicalSpace.IsTopologicalBasis.nhds_basis_closure /-\ntheorem TopologicalSpace.IsTopologicalBasis.nhds_basis_closure {B : Set (Set α)}\n    (hB : TopologicalSpace.IsTopologicalBasis B) (a : α) :\n    ((nhds) a).has_basis (fun s : Set α => a ∈ s ∧ s ∈ B) closure := by\n  simpa only [and_comm'] using hB.nhds_has_basis.nhds_closure\n#align topological_space.is_topological_basis.nhds_basis_closure TopologicalSpace.IsTopologicalBasis.nhds_basis_closure\n-/\n\n",
 "nhds_basis_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_basis_clopen /-\ntheorem nhds_basis_clopen (x : α) : ((nhds) x).has_basis (fun s : Set α => x ∈ s ∧ IsClopen s) id :=\n  ⟨fun U => by\n    constructor\n    · have : connectedComponent x = {x} := totally_disconnected_space_iff_connected_component_singleton.mp ‹_› x\n      rw [connectedComponent_eq_interᵢ_clopen] at this\n      intro hU\n      let N := { Z // IsClopen Z ∧ x ∈ Z }\n      rsuffices ⟨⟨s, hs, hs'⟩, hs''⟩ : ∃ Z : N, Z.val ⊆ U\n      · exact ⟨s, ⟨hs', hs⟩, hs''⟩\n      haveI : Nonempty N := ⟨⟨univ, isClopen_univ, mem_univ x⟩⟩\n      have hNcl : ∀ Z : N, IsClosed Z.val := fun Z => Z.property.1.2\n      have hdir : Directed superset fun Z : N => Z.val :=\n        by\n        rintro ⟨s, hs, hxs⟩ ⟨t, ht, hxt⟩\n        exact ⟨⟨s ∩ t, hs.inter ht, ⟨hxs, hxt⟩⟩, inter_subset_left s t, inter_subset_right s t⟩\n      have h_nhd :\n        ∀ y ∈ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" Z.val,\n          U ∈ (nhds) y :=\n        by\n        intro y y_in\n        erw [this, mem_singleton_iff] at y_in\n        rwa [y_in]\n      exact exists_subset_nhds_of_compactSpace hdir hNcl h_nhd\n    · rintro ⟨V, ⟨hxV, V_op, -⟩, hUV : V ⊆ U⟩\n      rw [mem_nhds_iff]\n      exact ⟨V, hUV, V_op, hxV⟩⟩\n#align nhds_basis_clopen nhds_basis_clopen\n-/\n\n",
 "nhdsWithin_of_mem_discrete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print nhdsWithin_of_mem_discrete /-\n/-- The neighbourhoods filter of `x` within `s`, under the discrete topology, is equal to\nthe pure `x` filter (which is the principal filter at the singleton `{x}`.) -/\ntheorem nhdsWithin_of_mem_discrete {s : Set α} [DiscreteTopology s] {x : α} (hx : x ∈ s) : nhds_within s x = pure x :=\n  le_antisymm (le_pure_iff.2 <| singleton_mem_nhdsWithin_of_mem_discrete hx) (pure_le_nhdsWithin hx)\n#align nhds_within_of_mem_discrete nhdsWithin_of_mem_discrete\n-/\n\n",
 "nhdsWithin_insert_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print nhdsWithin_insert_of_ne /-\ntheorem nhdsWithin_insert_of_ne [T1Space α] {x y : α} {s : Set α} (hxy : x ≠ y) :\n    nhds_within (insert y s) x = nhds_within s x :=\n  by\n  refine' le_antisymm (fun t ht => _) (nhdsWithin_mono x <| subset_insert y s)\n  obtain ⟨o, ho, hxo, host⟩ := mem_nhds_within.mp ht\n  refine' mem_nhds_within.mpr ⟨o \\ {y}, ho.sdiff isClosed_singleton, ⟨hxo, hxy⟩, _⟩\n  rw [inter_insert_of_not_mem <| not_mem_diff_of_mem (mem_singleton y)]\n  exact (inter_subset_inter (diff_subset _ _) subset.rfl).trans host\n#align nhds_within_insert_of_ne nhdsWithin_insert_of_ne\n-/\n\n",
 "nhdsWithin_diff_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print Ne.nhdsWithin_diff_singleton /-\ntheorem Ne.nhdsWithin_diff_singleton [T1Space α] {x y : α} (h : x ≠ y) (s : Set α) :\n    nhds_within (s \\ {y}) x = nhds_within s x :=\n  by\n  rw [diff_eq, inter_comm, nhdsWithin_inter_of_mem]\n  exact mem_nhdsWithin_of_mem_nhds (is_open_ne.mem_nhds h)\n#align ne.nhds_within_diff_singleton Ne.nhdsWithin_diff_singleton\n-/\n\n",
 "nhdsWithin_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Ne.nhdsWithin_compl_singleton /-\ntheorem Ne.nhdsWithin_compl_singleton [T1Space α] {x y : α} (h : x ≠ y) : nhds_within («expr ᶜ» {y}) x = (nhds) x :=\n  isOpen_ne.nhds_within_eq h\n#align ne.nhds_within_compl_singleton Ne.nhdsWithin_compl_singleton\n-/\n\n",
 "nhdsSet_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n#print nhdsSet_le_iff /-\n@[simp]\ntheorem nhdsSet_le_iff [T1Space α] {s t : Set α} : (nhds_set) s ≤ (nhds_set) t ↔ s ⊆ t :=\n  by\n  refine' ⟨_, fun h => monotone_nhdsSet h⟩\n  simp_rw [Filter.le_def]; intro h x hx\n  specialize h («expr ᶜ» {x})\n  simp_rw [compl_singleton_mem_nhdsSet_iff] at h\n  by_contra hxt\n  exact h hxt hx\n#align nhds_set_le_iff nhdsSet_le_iff\n-/\n\n",
 "nhdsSet_inj_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n#print nhdsSet_inj_iff /-\n@[simp]\ntheorem nhdsSet_inj_iff [T1Space α] {s t : Set α} : (nhds_set) s = (nhds_set) t ↔ s = t :=\n  by\n  simp_rw [le_antisymm_iff]\n  exact and_congr nhdsSet_le_iff nhdsSet_le_iff\n#align nhds_set_inj_iff nhdsSet_inj_iff\n-/\n\n",
 "mono":
 "theorem mono (h : SeparatedNhds s₂ t₂) (hs : s₁ ⊆ s₂) (ht : t₁ ⊆ t₂) : SeparatedNhds s₁ t₁ :=\n  let ⟨U, V, hU, hV, hsU, htV, hd⟩ := h\n  ⟨U, V, hU, hV, hs.trans hsU, ht.trans htV, hd⟩\n#align mono mono\n\n",
 "minimal_nonempty_open_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n#print minimal_nonempty_open_subsingleton /-\ntheorem minimal_nonempty_open_subsingleton [T0Space α] {s : Set α} (hs : IsOpen s)\n    (hmin : ∀ (t) (_ : t ⊆ s), t.nonempty → IsOpen t → t = s) : s.subsingleton :=\n  by\n  refine' fun x hx y hy => of_not_not fun hxy => _\n  rcases exists_isOpen_xor'_mem hxy with ⟨U, hUo, hU⟩\n  wlog h : x ∈ U ∧ y ∉ U\n  · exact this hs hmin y hy x hx (ne.symm hxy) U hUo hU.symm (hU.resolve_left h)\n  cases' h with hxU hyU\n  have : s ∩ U = s := hmin (s ∩ U) (inter_subset_left _ _) ⟨x, hx, hxU⟩ (hs.inter hUo)\n  exact hyU (this.symm.subset hy).2\n#align minimal_nonempty_open_subsingleton minimal_nonempty_open_subsingleton\n-/\n\n",
 "minimal_nonempty_open_eq_singleton":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n#print minimal_nonempty_open_eq_singleton /-\ntheorem minimal_nonempty_open_eq_singleton [T0Space α] {s : Set α} (hs : IsOpen s) (hne : s.nonempty)\n    (hmin : ∀ (t) (_ : t ⊆ s), t.nonempty → IsOpen t → t = s) : ∃ x, s = {x} :=\n  exists_eq_singleton_iff_nonempty_subsingleton.2 ⟨hne, minimal_nonempty_open_subsingleton hs hmin⟩\n#align minimal_nonempty_open_eq_singleton minimal_nonempty_open_eq_singleton\n-/\n\n",
 "minimal_nonempty_closed_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n#print minimal_nonempty_closed_subsingleton /-\ntheorem minimal_nonempty_closed_subsingleton [T0Space α] {s : Set α} (hs : IsClosed s)\n    (hmin : ∀ (t) (_ : t ⊆ s), t.nonempty → IsClosed t → t = s) : s.subsingleton :=\n  by\n  refine' fun x hx y hy => of_not_not fun hxy => _\n  rcases exists_isOpen_xor'_mem hxy with ⟨U, hUo, hU⟩\n  wlog h : x ∈ U ∧ y ∉ U\n  · exact this hmin y hy x hx (ne.symm hxy) U hUo hU.symm (hU.resolve_left h)\n  cases' h with hxU hyU\n  have : s \\ U = s := hmin (s \\ U) (diff_subset _ _) ⟨y, hy, hyU⟩ (hs.sdiff hUo)\n  exact (this.symm.subset hx).2 hxU\n#align minimal_nonempty_closed_subsingleton minimal_nonempty_closed_subsingleton\n-/\n\n",
 "minimal_nonempty_closed_eq_singleton":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n#print minimal_nonempty_closed_eq_singleton /-\ntheorem minimal_nonempty_closed_eq_singleton [T0Space α] {s : Set α} (hs : IsClosed s) (hne : s.nonempty)\n    (hmin : ∀ (t) (_ : t ⊆ s), t.nonempty → IsClosed t → t = s) : ∃ x, s = {x} :=\n  exists_eq_singleton_iff_nonempty_subsingleton.2 ⟨hne, minimal_nonempty_closed_subsingleton hs hmin⟩\n#align minimal_nonempty_closed_eq_singleton minimal_nonempty_closed_eq_singleton\n-/\n\n",
 "locally_compact_of_compact_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print locally_compact_of_compact_nhds /-\ntheorem locally_compact_of_compact_nhds [T2Space α] (h : ∀ x : α, ∃ s, s ∈ (nhds) x ∧ IsCompact s) :\n    LocallyCompactSpace α :=\n  ⟨fun x n hn =>\n    let ⟨u, un, uo, xu⟩ := mem_nhds_iff.mp hn\n    let ⟨k, kx, kc⟩ := h x\n    -- K is compact but not necessarily contained in N.\n    -- K \\ U is again compact and doesn't contain x, so\n    -- we may find open sets V, W separating x from K \\ U.\n    -- Then K \\ W is a compact neighborhood of x contained in U.\n    let ⟨v, w, vo, wo, xv, kuw, vw⟩ :=\n      isCompact_isCompact_separated isCompact_singleton (kc.diff uo) (disjoint_singleton_left.2 fun h => h.2 xu)\n    have wn : «expr ᶜ» w ∈ (nhds) x := mem_nhds_iff.mpr ⟨v, vw.subset_compl_right, vo, singleton_subset_iff.mp xv⟩\n    ⟨k \\ w, Filter.inter_mem kx wn, Subset.trans (diff_subset_comm.mp kuw) un, kc.diff wo⟩⟩\n#align locally_compact_of_compact_nhds locally_compact_of_compact_nhds\n-/\n\n",
 "loc_compact_t2_tot_disc_iff_tot_sep":
 "#print loc_compact_t2_tot_disc_iff_tot_sep /-\n/-- A locally compact Hausdorff space is totally disconnected\n  if and only if it is totally separated. -/\ntheorem loc_compact_t2_tot_disc_iff_tot_sep : TotallyDisconnectedSpace H ↔ TotallySeparatedSpace H :=\n  by\n  constructor\n  · intro h\n    exact totallySeparatedSpace_of_t1_of_basis_clopen loc_compact_Haus_tot_disc_of_zero_dim\n  apply TotallySeparatedSpace.totallyDisconnectedSpace\n#align loc_compact_t2_tot_disc_iff_tot_sep loc_compact_t2_tot_disc_iff_tot_sep\n-/\n\n",
 "loc_compact_Haus_tot_disc_of_zero_dim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print loc_compact_Haus_tot_disc_of_zero_dim /-\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem loc_compact_Haus_tot_disc_of_zero_dim [TotallyDisconnectedSpace H] :\n    IsTopologicalBasis { s : Set H | IsClopen s } :=\n  by\n  refine' is_topological_basis_of_open_of_nhds (fun u hu => hu.1) _\n  rintro x U memU hU\n  obtain ⟨s, comp, xs, sU⟩ := exists_compact_subset hU memU\n  obtain ⟨t, h, ht, xt⟩ := mem_interior.1 xs\n  let u : Set s := «expr ⁻¹' » (coe : s → H) (interior s)\n  have u_open_in_s : IsOpen u := is_open_interior.preimage continuous_subtype_val\n  let X : s := ⟨x, h xt⟩\n  have Xu : X ∈ u := xs\n  haveI : CompactSpace s := isCompact_iff_compactSpace.1 comp\n  obtain ⟨V : Set s, clopen_in_s, Vx, V_sub⟩ := compact_exists_clopen_in_open u_open_in_s Xu\n  have V_clopen : IsClopen («expr '' » (coe : s → H) V) :=\n    by\n    refine' ⟨_, comp.is_closed.closed_embedding_subtype_coe.closed_iff_image_closed.1 clopen_in_s.2⟩\n    let v : Set u := «expr ⁻¹' » (coe : u → s) V\n    have : (coe : u → H) = (coe : s → H) ∘ (coe : u → s) := rfl\n    have f0 : Embedding (coe : u → H) := embedding_subtype_coe.comp embedding_subtype_val\n    have f1 : OpenEmbedding (coe : u → H) := by\n      refine' ⟨f0, _⟩\n      · have : Set.range (coe : u → H) = interior s :=\n          by\n          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]\n          apply Set.inter_eq_self_of_subset_left interior_subset\n        rw [this]\n        apply isOpen_interior\n    have f2 : IsOpen v := clopen_in_s.1.preimage continuous_subtype_val\n    have f3 : «expr '' » (coe : s → H) V = «expr '' » (coe : u → H) v := by\n      rw [this, image_comp coe coe, Subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub]\n    rw [f3]\n    apply f1.is_open_map v f2\n  refine' ⟨«expr '' » coe V, V_clopen, by simp [Vx, h xt], _⟩\n  trans s\n  · simp\n  assumption\n#align loc_compact_Haus_tot_disc_of_zero_dim loc_compact_Haus_tot_disc_of_zero_dim\n-/\n\n",
 "lim_nhdsWithin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print lim_nhdsWithin /-\n@[simp]\ntheorem lim_nhdsWithin {a : α} {s : Set α} (h : a ∈ closure s) : @lim _ _ ⟨a⟩ (nhds_within s a) = a :=\n  haveI : ne_bot (nhds_within s a) := mem_closure_iff_clusterPt.1 h\n  lim_eq inf_le_left\n#align Lim_nhds_within lim_nhdsWithin\n-/\n\n",
 "lim_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print lim_nhds /-\n@[simp]\ntheorem lim_nhds (a : α) : @lim _ _ ⟨a⟩ ((nhds) a) = a :=\n  lim_eq le_rfl\n#align Lim_nhds lim_nhds\n-/\n\n",
 "lim_eq_iff_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Ultrafilter.lim_eq_iff_le_nhds /-\ntheorem Ultrafilter.lim_eq_iff_le_nhds [CompactSpace α] {x : α} {F : Ultrafilter α} : F.Lim = x ↔ ↑F ≤ (nhds) x :=\n  ⟨fun h => h ▸ F.le_nhds_Lim, lim_eq⟩\n#align ultrafilter.Lim_eq_iff_le_nhds Ultrafilter.lim_eq_iff_le_nhds\n-/\n\n",
 "lim_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print lim_eq_iff /-\ntheorem lim_eq_iff [NeBot f] (h : ∃ a : α, f ≤ nhds a) {a} : @lim _ _ ⟨a⟩ f = a ↔ f ≤ (nhds) a :=\n  ⟨fun c => c ▸ le_nhds_lim h, lim_eq⟩\n#align Lim_eq_iff lim_eq_iff\n-/\n\n",
 "lim_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print lim_eq /-\ntheorem lim_eq {a : α} [NeBot f] (h : f ≤ (nhds) a) : @lim _ _ ⟨a⟩ f = a :=\n  tendsto_nhds_unique (le_nhds_lim ⟨a, h⟩) h\n#align Lim_eq lim_eq\n-/\n\n",
 "limUnder_nhds_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print limUnder_nhds_id /-\n@[simp]\ntheorem limUnder_nhds_id (a : α) : @limUnder _ _ _ ⟨a⟩ ((nhds) a) id = a :=\n  lim_nhds a\n#align lim_nhds_id limUnder_nhds_id\n-/\n\n",
 "limUnder_nhdsWithin_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print limUnder_nhdsWithin_id /-\n@[simp]\ntheorem limUnder_nhdsWithin_id {a : α} {s : Set α} (h : a ∈ closure s) : @limUnder _ _ _ ⟨a⟩ (nhds_within s a) id = a :=\n  lim_nhdsWithin h\n#align lim_nhds_within_id limUnder_nhdsWithin_id\n-/\n\n",
 "limUnder_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.limUnder_eq_iff /-\ntheorem Filter.limUnder_eq_iff {f : Filter β} [NeBot f] {g : β → α} (h : ∃ a, Tendsto g f ((nhds) a)) {a} :\n    @limUnder _ _ _ ⟨a⟩ f g = a ↔ Tendsto g f ((nhds) a) :=\n  ⟨fun c => c ▸ tendsto_nhds_limUnder h, Filter.Tendsto.limUnder_eq⟩\n#align filter.lim_eq_iff Filter.limUnder_eq_iff\n-/\n\n",
 "limUnder_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Continuous.limUnder_eq /-\ntheorem Continuous.limUnder_eq [TopologicalSpace β] {f : β → α} (h : Continuous f) (a : β) :\n    @limUnder _ _ _ ⟨f a⟩ ((nhds) a) f = f a :=\n  (h.tendsto a).lim_eq\n#align continuous.lim_eq Continuous.limUnder_eq\n-/\n\n",
 "lift'_nhds_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print lift'_nhds_closure /-\ntheorem lift'_nhds_closure (a : α) : ((nhds) a).lift' closure = (nhds) a :=\n  (closed_nhds_basis a).lift'_closure_eq_self fun s hs => hs.2\n#align lift'_nhds_closure lift'_nhds_closure\n-/\n\n",
 "isTopologicalBasis_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isTopologicalBasis_clopen /-\ntheorem isTopologicalBasis_clopen : IsTopologicalBasis { s : Set α | IsClopen s } :=\n  by\n  apply is_topological_basis_of_open_of_nhds fun U (hU : IsClopen U) => hU.1\n  intro x U hxU U_op\n  have : U ∈ (nhds) x := IsOpen.mem_nhds U_op hxU\n  rcases(nhds_basis_clopen x).mem_iff.mp this with ⟨V, ⟨hxV, hV⟩, hVU : V ⊆ U⟩\n  use V\n  tauto\n#align is_topological_basis_clopen isTopologicalBasis_clopen\n-/\n\n",
 "isPreirreducible_iff_subsingleton":
 "#print isPreirreducible_iff_subsingleton /-\ntheorem isPreirreducible_iff_subsingleton [T2Space α] {S : Set α} : IsPreirreducible S ↔ S.subsingleton :=\n  by\n  refine' ⟨fun h x hx y hy => _, Set.Subsingleton.isPreirreducible⟩\n  by_contra e\n  obtain ⟨U, V, hU, hV, hxU, hyV, h'⟩ := t2_separation e\n  exact ((h U V hU hV ⟨x, hx, hxU⟩ ⟨y, hy, hyV⟩).mono <| inter_subset_right _ _).not_disjoint h'\n#align is_preirreducible_iff_subsingleton isPreirreducible_iff_subsingleton\n-/\n\n",
 "isOpen_singleton_of_finite_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isOpen_singleton_of_finite_mem_nhds /-\n/-- A point with a finite neighborhood has to be isolated. -/\ntheorem isOpen_singleton_of_finite_mem_nhds {α : Type _} [TopologicalSpace α] [T1Space α] (x : α) {s : Set α}\n    (hs : s ∈ (nhds) x) (hsf : s.finite) : IsOpen ({x} : Set α) :=\n  by\n  have A : {x} ⊆ s := by simp only [singleton_subset_iff, mem_of_mem_nhds hs]\n  have B : IsClosed (s \\ {x}) := (hsf.subset (diff_subset _ _)).is_closed\n  have C : «expr ᶜ» (s \\ {x}) ∈ (nhds) x := B.is_open_compl.mem_nhds fun h => h.2 rfl\n  have D : {x} ∈ (nhds) x := by simpa only [← diff_eq, diff_diff_cancel_left A] using inter_mem hs C\n  rwa [← mem_interior_iff_mem_nhds, ← singleton_subset_iff, subset_interior_iff_isOpen] at D\n#align is_open_singleton_of_finite_mem_nhds isOpen_singleton_of_finite_mem_nhds\n-/\n\n",
 "isOpen_setOf_eventually_nhdsWithin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n#print isOpen_setOf_eventually_nhdsWithin /-\ntheorem isOpen_setOf_eventually_nhdsWithin [T1Space α] {p : α → Prop} :\n    IsOpen\n      { x |\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          (nhds_within.ne x) (p y) } :=\n  by\n  refine' is_open_iff_mem_nhds.mpr fun a ha => _\n  filter_upwards [eventually_nhds_nhds_within.mpr ha]with b hb\n  by_cases a = b\n  · subst h\n    exact hb\n  · rw [(ne.symm h).nhds_within_compl_singleton] at hb\n    exact hb.filter_mono nhdsWithin_le_nhds\n#align is_open_set_of_eventually_nhds_within isOpen_setOf_eventually_nhdsWithin\n-/\n\n",
 "isOpen_setOf_disjoint_nhds_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isOpen_setOf_disjoint_nhds_nhds /-\ntheorem isOpen_setOf_disjoint_nhds_nhds : IsOpen { p : α × α | Disjoint ((nhds) p.1) ((nhds) p.2) } :=\n  by\n  simp only [isOpen_iff_mem_nhds, Prod.forall, mem_set_of_eq]\n  intro x y h\n  obtain ⟨U, hU, V, hV, hd⟩ := ((nhds_basis_opens x).disjoint_iff (nhds_basis_opens y)).mp h\n  exact\n    mem_nhds_prod_iff.mpr\n      ⟨U, hU.2.mem_nhds hU.1, V, hV.2.mem_nhds hV.1, fun ⟨x', y'⟩ ⟨hx', hy'⟩ =>\n        disjoint_of_disjoint_of_mem hd (hU.2.mem_nhds hx') (hV.2.mem_nhds hy')⟩\n#align is_open_set_of_disjoint_nhds_nhds isOpen_setOf_disjoint_nhds_nhds\n-/\n\n",
 "isOpen_ne_fun":
 "#print isOpen_ne_fun /-\ntheorem isOpen_ne_fun [T2Space α] {f g : β → α} (hf : Continuous f) (hg : Continuous g) :\n    IsOpen { x : β | f x ≠ g x } :=\n  isOpen_compl_iff.mpr <| isClosed_eq hf hg\n#align is_open_ne_fun isOpen_ne_fun\n-/\n\n",
 "isOpen_ne":
 "#print isOpen_ne /-\ntheorem isOpen_ne [T1Space α] {x : α} : IsOpen { y | y ≠ x } :=\n  isOpen_compl_singleton\n#align is_open_ne isOpen_ne\n-/\n\n",
 "isOpen_mulSupport":
 "#print Continuous.isOpen_mulSupport /-\n@[to_additive]\ntheorem Continuous.isOpen_mulSupport [T1Space α] [One α] [TopologicalSpace β] {f : β → α} (hf : Continuous f) :\n    IsOpen (mulSupport f) :=\n  isOpen_ne.preimage hf\n#align continuous.is_open_mul_support Continuous.isOpen_mulSupport\n#align continuous.is_open_support Continuous.isOpen_support\n-/\n\n",
 "isOpen_iff_ultrafilter'":
 "#print isOpen_iff_ultrafilter' /-\ntheorem isOpen_iff_ultrafilter' [CompactSpace α] (U : Set α) : IsOpen U ↔ ∀ F : Ultrafilter α, F.Lim ∈ U → U ∈ F.1 :=\n  by\n  rw [isOpen_iff_ultrafilter]\n  refine' ⟨fun h F hF => h F.Lim hF F F.le_nhds_Lim, _⟩\n  intro cond x hx f h\n  rw [← Ultrafilter.lim_eq_iff_le_nhds.2 h] at hx\n  exact cond _ hx\n#align is_open_iff_ultrafilter' isOpen_iff_ultrafilter'\n-/\n\n",
 "isOpen_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print isOpen_compl_singleton /-\ntheorem isOpen_compl_singleton [T1Space α] {x : α} : IsOpen («expr ᶜ» {x} : Set α) :=\n  isClosed_singleton.is_open_compl\n#align is_open_compl_singleton isOpen_compl_singleton\n-/\n\n",
 "isIrreducible_iff_singleton":
 "#print isIrreducible_iff_singleton /-\ntheorem isIrreducible_iff_singleton [T2Space α] {S : Set α} : IsIrreducible S ↔ ∃ x, S = {x} := by\n  rw [IsIrreducible, isPreirreducible_iff_subsingleton, exists_eq_singleton_iff_nonempty_subsingleton]\n#align is_irreducible_iff_singleton isIrreducible_iff_singleton\n-/\n\n",
 "isCompact_isCompact_separated":
 "#print isCompact_isCompact_separated /-\ntheorem isCompact_isCompact_separated [T2Space α] {s t : Set α} (hs : IsCompact s) (ht : IsCompact t)\n    (hst : Disjoint s t) : SeparatedNhds s t := by\n  simp only [SeparatedNhds, prod_subset_compl_diagonal_iff_disjoint.symm] at hst⊢ <;>\n    exact generalized_tube_lemma hs ht is_closed_diagonal.is_open_compl hst\n#align is_compact_is_compact_separated isCompact_isCompact_separated\n-/\n\n",
 "isCompact_closure_of_subset_compact":
 "#print isCompact_closure_of_subset_compact /-\ntheorem isCompact_closure_of_subset_compact [T2Space α] {s t : Set α} (ht : IsCompact t) (h : s ⊆ t) :\n    IsCompact (closure s) :=\n  isCompact_of_isClosed_subset ht isClosed_closure (closure_minimal h ht.is_closed)\n#align is_compact_closure_of_subset_compact isCompact_closure_of_subset_compact\n-/\n\n",
 "isClosed_singleton":
 "#print isClosed_singleton /-\ntheorem isClosed_singleton [T1Space α] {x : α} : IsClosed ({x} : Set α) :=\n  t1_space.t1 x\n#align is_closed_singleton isClosed_singleton\n-/\n\n",
 "isClosed_setOf_specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n#print isClosed_setOf_specializes /-\ntheorem isClosed_setOf_specializes : IsClosed { p : α × α | «expr ⤳ » p.1 p.2 } := by\n  simp only [← isOpen_compl_iff, compl_set_of, ← disjoint_nhds_nhds_iff_not_specializes,\n    isOpen_setOf_disjoint_nhds_nhds]\n#align is_closed_set_of_specializes isClosed_setOf_specializes\n-/\n\n",
 "isClosed_setOf_inseparable":
 "#print isClosed_setOf_inseparable /-\ntheorem isClosed_setOf_inseparable : IsClosed { p : α × α | Inseparable p.1 p.2 } := by\n  simp only [← specializes_iff_inseparable, isClosed_setOf_specializes]\n#align is_closed_set_of_inseparable isClosed_setOf_inseparable\n-/\n\n",
 "isClosed_eq":
 "#print isClosed_eq /-\ntheorem isClosed_eq [T2Space α] {f g : β → α} (hf : Continuous f) (hg : Continuous g) :\n    IsClosed { x : β | f x = g x } :=\n  continuous_iff_isClosed.mp (hf.prod_mk hg) _ isClosed_diagonal\n#align is_closed_eq isClosed_eq\n-/\n\n",
 "isClosed_diagonal":
 "#print isClosed_diagonal /-\ntheorem isClosed_diagonal [T2Space α] : IsClosed (diagonal α) :=\n  t2_iff_isClosed_diagonal.mp ‹_›\n#align is_closed_diagonal isClosed_diagonal\n-/\n\n",
 "isClosedMap_const":
 "#print isClosedMap_const /-\ntheorem isClosedMap_const {α β} [TopologicalSpace α] [TopologicalSpace β] [T1Space β] {y : β} :\n    IsClosedMap (Function.const α y) :=\n  IsClosedMap.of_nonempty fun s hs h2s => by simp_rw [h2s.image_const, isClosed_singleton]\n#align is_closed_map_const isClosedMap_const\n-/\n\n",
 "isClosedMap":
 "#print Continuous.isClosedMap /-\ntheorem Continuous.isClosedMap [CompactSpace α] [T2Space β] {f : α → β} (h : Continuous f) : IsClosedMap f :=\n  fun s hs => (hs.is_compact.image h).is_closed\n#align continuous.is_closed_map Continuous.isClosedMap\n-/\n\n",
 "isClosed":
 "#print CompactExhaustion.isClosed /-\ntheorem CompactExhaustion.isClosed [T2Space α] (K : CompactExhaustion α) (n : ℕ) : IsClosed (K n) :=\n  (K.is_compact n).is_closed\n#align compact_exhaustion.is_closed CompactExhaustion.isClosed\n-/\n\n",
 "isBounded_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print Bornology.relativelyCompact.isBounded_iff /-\ntheorem Bornology.relativelyCompact.isBounded_iff [T1Space α] {s : Set α} :\n    @Bornology.IsBounded _ (Bornology.relativelyCompact α) s ↔ IsCompact (closure s) :=\n  by\n  change «expr ᶜ» s ∈ Filter.coclosedCompact α ↔ _\n  rw [Filter.mem_coclosedCompact]\n  constructor\n  · rintro ⟨t, ht₁, ht₂, hst⟩\n    rw [compl_subset_compl] at hst\n    exact isCompact_of_isClosed_subset ht₂ isClosed_closure (closure_minimal hst ht₁)\n  · intro h\n    exact ⟨closure s, isClosed_closure, h, compl_subset_compl.mpr subset_closure⟩\n#align bornology.relatively_compact.is_bounded_iff Bornology.relativelyCompact.isBounded_iff\n-/\n\n",
 "inter":
 "#print IsCompact.inter /-\ntheorem IsCompact.inter [T2Space α] {s t : Set α} (hs : IsCompact s) (ht : IsCompact t) : IsCompact (s ∩ t) :=\n  hs.inter_right <| ht.is_closed\n#align is_compact.inter IsCompact.inter\n-/\n\n",
 "insert_mem_nhdsWithin_of_subset_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print insert_mem_nhdsWithin_of_subset_insert /-\n/-- If `t` is a subset of `s`, except for one point,\nthen `insert x s` is a neighborhood of `x` within `t`. -/\ntheorem insert_mem_nhdsWithin_of_subset_insert [T1Space α] {x y : α} {s t : Set α} (hu : t ⊆ insert y s) :\n    insert x s ∈ nhds_within t x := by\n  rcases eq_or_ne x y with (rfl | h)\n  · exact mem_of_superset self_mem_nhdsWithin hu\n  refine' nhdsWithin_mono x hu _\n  rw [nhdsWithin_insert_of_ne h]\n  exact mem_of_superset self_mem_nhdsWithin (subset_insert x s)\n#align insert_mem_nhds_within_of_subset_insert insert_mem_nhdsWithin_of_subset_insert\n-/\n\n",
 "inseparable_iff_eq":
 "#print inseparable_iff_eq /-\ntheorem inseparable_iff_eq [T0Space α] {x y : α} : Inseparable x y ↔ x = y :=\n  nhds_injective.eq_iff\n#align inseparable_iff_eq inseparable_iff_eq\n-/\n\n",
 "inseparable_eq_eq":
 "#print inseparable_eq_eq /-\n@[simp]\ntheorem inseparable_eq_eq [T0Space α] : Inseparable = @Eq α :=\n  funext₂ fun x y => propext inseparable_iff_eq\n#align inseparable_eq_eq inseparable_eq_eq\n-/\n\n",
 "injective_nhdsSet":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n#print injective_nhdsSet /-\ntheorem injective_nhdsSet [T1Space α] : function.injective (nhds_set : Set α → Filter α) := fun s t hst =>\n  nhdsSet_inj_iff.mp hst\n#align injective_nhds_set injective_nhdsSet\n-/\n\n",
 "injective":
 "#print Inducing.injective /-\nprotected theorem Inducing.injective [TopologicalSpace β] [T0Space α] {f : α → β} (hf : Inducing f) : injective f :=\n  fun x y h => Inseparable.eq <| hf.inseparable_iff.1 <| h ▸ Inseparable.refl _\n#align inducing.injective Inducing.injective\n-/\n\n",
 "infinite_of_nontrivial":
 "#print IsPreconnected.infinite_of_nontrivial /-\ntheorem IsPreconnected.infinite_of_nontrivial [T1Space α] {s : Set α} (h : IsPreconnected s) (hs : s.nontrivial) :\n    s.infinite := by\n  refine' mt (fun hf => (subsingleton_coe s).mp _) (not_subsingleton_iff.mpr hs)\n  haveI := @discrete_of_t1_of_finite s _ _ hf.to_subtype\n  exact @PreconnectedSpace.trivial_of_discrete _ _ (Subtype.preconnectedSpace h) _\n#align is_preconnected.infinite_of_nontrivial IsPreconnected.infinite_of_nontrivial\n-/\n\n",
 "infinite_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print infinite_of_mem_nhds /-\n/-- If the punctured neighborhoods of a point form a nontrivial filter, then any neighborhood is\ninfinite. -/\ntheorem infinite_of_mem_nhds {α} [TopologicalSpace α] [T1Space α] (x : α) [hx : NeBot (nhds_within.ne x)] {s : Set α}\n    (hs : s ∈ (nhds) x) : Set.Infinite s := by\n  refine' fun hsf => hx.1 _\n  rw [← isOpen_singleton_iff_punctured_nhds]\n  exact isOpen_singleton_of_finite_mem_nhds x hs hsf\n#align infinite_of_mem_nhds infinite_of_mem_nhds\n-/\n\n",
 "infinite":
 "#print ConnectedSpace.infinite /-\ntheorem ConnectedSpace.infinite [ConnectedSpace α] [Nontrivial α] [T1Space α] : Infinite α :=\n  infinite_univ_iff.mp <| is_preconnected_univ.infinite_of_nontrivial nontrivial_univ\n#align connected_space.infinite ConnectedSpace.infinite\n-/\n\n",
 "inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print RegularSpace.inf /-\ntheorem RegularSpace.inf {X} {t₁ t₂ : TopologicalSpace X} (h₁ : @RegularSpace X t₁) (h₂ : @RegularSpace X t₂) :\n    @RegularSpace X («expr ⊓ » t₁ t₂) := by\n  rw [inf_eq_infᵢ]\n  exact regularSpace_infᵢ (Bool.forall_bool.2 ⟨h₂, h₁⟩)\n#align regular_space.inf RegularSpace.inf\n-/\n\n",
 "image_closure_of_isCompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print image_closure_of_isCompact /-\ntheorem image_closure_of_isCompact [T2Space β] {s : Set α} (hs : IsCompact (closure s)) {f : α → β}\n    (hf : ContinuousOn f (closure s)) : «expr '' » f (closure s) = closure («expr '' » f s) :=\n  Subset.antisymm hf.image_closure <|\n    closure_minimal (image_subset f subset_closure) (hs.image_of_continuous_on hf).is_closed\n#align image_closure_of_is_compact image_closure_of_isCompact\n-/\n\n",
 "hasBasis_opens_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print hasBasis_opens_closure /-\ntheorem hasBasis_opens_closure (a : α) : ((nhds) a).has_basis (fun s => a ∈ s ∧ IsOpen s) closure :=\n  (nhds_basis_opens a).nhds_closure\n#align has_basis_opens_closure hasBasis_opens_closure\n-/\n\n",
 "hasBasis_nhds_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print hasBasis_nhds_closure /-\ntheorem hasBasis_nhds_closure (a : α) : ((nhds) a).has_basis (fun s => s ∈ (nhds) a) closure :=\n  ((nhds) a).basis_sets.nhds_closure\n#align has_basis_nhds_closure hasBasis_nhds_closure\n-/\n\n",
 "finset_disjoint_finset_opens_of_t2":
 "#print finset_disjoint_finset_opens_of_t2 /-\ntheorem finset_disjoint_finset_opens_of_t2 [T2Space α] : ∀ s t : Finset α, Disjoint s t → SeparatedNhds (s : Set α) t :=\n  by\n  refine' induction_on_union _ (fun a b hi d => (hi d.symm).symm) (fun a d => empty_right a) (fun a b ab => _) _\n  · obtain ⟨U, V, oU, oV, aU, bV, UV⟩ := t2_separation (Finset.disjoint_singleton.1 ab)\n    refine' ⟨U, V, oU, oV, _, _, UV⟩ <;> exact singleton_subset_set_iff.mpr ‹_›\n  · intro a b c ac bc d\n    apply_mod_cast union_left (ac (disjoint_of_subset_left (a.subset_union_left b) d)) (bc _)\n    exact disjoint_of_subset_left (a.subset_union_right b) d\n#align finset_disjoint_finset_opens_of_t2 finset_disjoint_finset_opens_of_t2\n-/\n\n",
 "finite_compact_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print IsCompact.finite_compact_cover /-\n/-- For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. -/\ntheorem IsCompact.finite_compact_cover [T2Space α] {s : Set α} (hs : IsCompact s) {ι} (t : Finset ι) (U : ι → Set α)\n    (hU : ∀ i ∈ t, IsOpen (U i))\n    (hsC : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i)) :\n    ∃ K : ι → Set α,\n      (∀ i, IsCompact (K i)) ∧\n        (∀ i, K i ⊆ U i) ∧\n          s = «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (K i) :=\n  by\n  classical\n    induction' t using Finset.induction with x t hx ih generalizing U hU s hs hsC\n    · refine' ⟨fun _ => ∅, fun i => isCompact_empty, fun i => empty_subset _, _⟩\n      simpa only [subset_empty_iff, Union_false, Union_empty] using hsC\n    simp only [Finset.set_bunionᵢ_insert] at hsC\n    simp only [Finset.mem_insert] at hU\n    have hU' : ∀ i ∈ t, IsOpen (U i) := fun i hi => hU i (or.inr hi)\n    rcases hs.binary_compact_cover (hU x (or.inl rfl)) (isOpen_bunionᵢ hU') hsC with\n      ⟨K₁, K₂, h1K₁, h1K₂, h2K₁, h2K₂, hK⟩\n    rcases ih U hU' h1K₂ h2K₂ with ⟨K, h1K, h2K, h3K⟩\n    refine' ⟨update K x K₁, _, _, _⟩\n    · intro i\n      by_cases hi : i = x\n      · simp only [update_same, hi, h1K₁]\n      · rw [← ne.def] at hi\n        simp only [update_noteq hi, h1K]\n    · intro i\n      by_cases hi : i = x\n      · simp only [update_same, hi, h2K₁]\n      · rw [← ne.def] at hi\n        simp only [update_noteq hi, h2K]\n    · simp only [set_bUnion_insert_update _ hx, hK, h3K]\n#align is_compact.finite_compact_cover IsCompact.finite_compact_cover\n-/\n\n",
 "ext_on":
 "#print Continuous.ext_on /-\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem Continuous.ext_on [T2Space α] {s : Set β} (hs : Dense s) {f g : β → α} (hf : Continuous f) (hg : Continuous g)\n    (h : EqOn f g s) : f = g :=\n  funext fun x => h.closure hf hg (hs x)\n#align continuous.ext_on Continuous.ext_on\n-/\n\n",
 "exists_subset_nhds_of_isCompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_subset_nhds_of_isCompact /-\n/-- If `V : ι → set α` is a decreasing family of compact sets then any neighborhood of\n`⋂ i, V i` contains some `V i`. This is a version of `exists_subset_nhd_of_compact'` where we\ndon't need to assume each `V i` closed because it follows from compactness since `α` is\nassumed to be Hausdorff. -/\ntheorem exists_subset_nhds_of_isCompact [T2Space α] {ι : Type _} [Nonempty ι] {V : ι → Set α}\n    (hV : Directed («expr ⊇ » · ·) V) (hV_cpct : ∀ i, IsCompact (V i)) {U : Set α}\n    (hU :\n      ∀ x ∈ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (V i),\n        U ∈ (nhds) x) :\n    ∃ i, V i ⊆ U :=\n  exists_subset_nhds_of_isCompact' hV hV_cpct (fun i => (hV_cpct i).is_closed) hU\n#align exists_subset_nhds_of_is_compact exists_subset_nhds_of_isCompact\n-/\n\n",
 "exists_open_with_compact_closure":
 "#print exists_open_with_compact_closure /-\n-- see Note [lower instance priority]\n/-- In a locally compact T₂ space, every point has an open neighborhood with compact closure -/\ntheorem exists_open_with_compact_closure [LocallyCompactSpace α] [T2Space α] (x : α) :\n    ∃ U : Set α, IsOpen U ∧ x ∈ U ∧ IsCompact (closure U) :=\n  by\n  rcases exists_compact_mem_nhds x with ⟨K, hKc, hxK⟩\n  rcases mem_nhds_iff.1 hxK with ⟨t, h1t, h2t, h3t⟩\n  exact ⟨t, h2t, h3t, isCompact_closure_of_subset_compact hKc h1t⟩\n#align exists_open_with_compact_closure exists_open_with_compact_closure\n-/\n\n",
 "exists_open_superset_and_isCompact_closure":
 "#print exists_open_superset_and_isCompact_closure /-\n/-- In a locally compact T₂ space, every compact set has an open neighborhood with compact closure.\n-/\ntheorem exists_open_superset_and_isCompact_closure [LocallyCompactSpace α] [T2Space α] {K : Set α} (hK : IsCompact K) :\n    ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V) :=\n  by\n  rcases exists_compact_superset hK with ⟨K', hK', hKK'⟩\n  refine' ⟨interior K', isOpen_interior, hKK', isCompact_closure_of_subset_compact hK' interior_subset⟩\n#align exists_open_superset_and_is_compact_closure exists_open_superset_and_isCompact_closure\n-/\n\n",
 "exists_open_singleton_of_open_finite":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊂ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n#print exists_open_singleton_of_open_finite /-\n/-- Given an open finite set `S` in a T₀ space, there is some `x ∈ S` such that `{x}` is open. -/\ntheorem exists_open_singleton_of_open_finite [T0Space α] {s : Set α} (hfin : s.finite) (hne : s.nonempty)\n    (ho : IsOpen s) : ∃ x ∈ s, IsOpen ({x} : Set α) :=\n  by\n  lift s to Finset α using hfin\n  induction' s using Finset.strongInductionOn with s ihs\n  rcases em (∃ (t : _)(_ : «expr ⊂ » t s), t.nonempty ∧ IsOpen (t : Set α)) with (⟨t, hts, htne, hto⟩ | ht)\n  · rcases ihs t hts htne hto with ⟨x, hxt, hxo⟩\n    exact ⟨x, hts.1 hxt, hxo⟩\n  · rcases minimal_nonempty_open_eq_singleton ho hne _ with ⟨x, hx⟩\n    · exact ⟨x, hx.symm ▸ rfl, hx ▸ ho⟩\n    refine' fun t hts htne hto => of_not_not fun hts' => ht _\n    lift t to Finset α using s.finite_to_set.subset hts\n    exact ⟨t, ssubset_iff_subset_ne.2 ⟨hts, mt Finset.coe_inj.2 hts'⟩, htne, hto⟩\n#align exists_open_singleton_of_open_finite exists_open_singleton_of_open_finite\n-/\n\n",
 "exists_open_singleton_of_finite":
 "#print exists_open_singleton_of_finite /-\ntheorem exists_open_singleton_of_finite [T0Space α] [Finite α] [Nonempty α] : ∃ x : α, IsOpen ({x} : Set α) :=\n  let ⟨x, _, h⟩ := exists_open_singleton_of_open_finite (Set.toFinite _) univ_nonempty isOpen_univ\n  ⟨x, h⟩\n#align exists_open_singleton_of_fintype exists_open_singleton_of_finite\n-/\n\n",
 "exists_open_nhds_disjoint_closure":
 "#print exists_open_nhds_disjoint_closure /-\ntheorem exists_open_nhds_disjoint_closure [T25Space α] {x y : α} (h : x ≠ y) :\n    ∃ u : Set α, x ∈ u ∧ IsOpen u ∧ ∃ v : Set α, y ∈ v ∧ IsOpen v ∧ Disjoint (closure u) (closure v) := by\n  simpa only [exists_prop, and_assoc] using\n    ((nhds_basis_opens x).lift'_closure.disjoint_iff (nhds_basis_opens y).lift'_closure).1\n      (disjoint_lift'_closure_nhds.2 h)\n#align exists_open_nhds_disjoint_closure exists_open_nhds_disjoint_closure\n-/\n\n",
 "exists_open_between_and_isCompact_closure":
 "#print exists_open_between_and_isCompact_closure /-\n/-- In a locally compact T₂ space, given a compact set `K` inside an open set `U`, we can find a\nopen set `V` between these sets with compact closure: `K ⊆ V` and the closure of `V` is inside `U`.\n-/\ntheorem exists_open_between_and_isCompact_closure [LocallyCompactSpace α] [T2Space α] {K U : Set α} (hK : IsCompact K)\n    (hU : IsOpen U) (hKU : K ⊆ U) : ∃ V, IsOpen V ∧ K ⊆ V ∧ closure V ⊆ U ∧ IsCompact (closure V) :=\n  by\n  rcases exists_compact_between hK hU hKU with ⟨V, hV, hKV, hVU⟩\n  exact\n    ⟨interior V, isOpen_interior, hKV, (closure_minimal interior_subset hV.is_closed).trans hVU,\n      isCompact_closure_of_subset_compact hV interior_subset⟩\n#align exists_open_between_and_is_compact_closure exists_open_between_and_isCompact_closure\n-/\n\n",
 "exists_nhds_disjoint_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_nhds_disjoint_closure /-\n-- see Note [lower instance priority]\ntheorem exists_nhds_disjoint_closure [T25Space α] {x y : α} (h : x ≠ y) :\n    ∃ s ∈ (nhds) x, ∃ t ∈ (nhds) y, Disjoint (closure s) (closure t) :=\n  (((nhds) x).basis_sets.lift'_closure.disjoint_iff ((nhds) y).basis_sets.lift'_closure).1 <|\n    disjoint_lift'_closure_nhds.2 h\n#align exists_nhds_disjoint_closure exists_nhds_disjoint_closure\n-/\n\n",
 "exists_mem_of_ne":
 "#print TopologicalSpace.IsTopologicalBasis.exists_mem_of_ne /-\ntheorem TopologicalSpace.IsTopologicalBasis.exists_mem_of_ne [T1Space α] {b : Set (Set α)} (hb : IsTopologicalBasis b)\n    {x y : α} (h : x ≠ y) : ∃ a ∈ b, x ∈ a ∧ y ∉ a :=\n  by\n  rcases hb.is_open_iff.1 isOpen_ne x h with ⟨a, ab, xa, ha⟩\n  exact ⟨a, ab, xa, fun h => ha h rfl⟩\n#align topological_space.is_topological_basis.exists_mem_of_ne TopologicalSpace.IsTopologicalBasis.exists_mem_of_ne\n-/\n\n",
 "exists_mem_nhds_isClosed_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_mem_nhds_isClosed_subset /-\ntheorem exists_mem_nhds_isClosed_subset {a : α} {s : Set α} (h : s ∈ (nhds) a) : ∃ t ∈ (nhds) a, IsClosed t ∧ t ⊆ s :=\n  Iff.mp ((regularSpace_TFAE α).out 0 3) ‹_› _ _ h\n#align exists_mem_nhds_is_closed_subset exists_mem_nhds_isClosed_subset\n-/\n\n",
 "exists_isOpen_xor'_mem":
 "#print exists_isOpen_xor'_mem /-\ntheorem exists_isOpen_xor'_mem [T0Space α] {x y : α} (h : x ≠ y) : ∃ U : Set α, IsOpen U ∧ Xor' (x ∈ U) (y ∈ U) :=\n  (t0Space_iff_exists_isOpen_xor'_mem α).1 ‹_› x y h\n#align exists_is_open_xor_mem exists_isOpen_xor'_mem\n-/\n\n",
 "exists_inter_eq_singleton_of_mem_discrete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.HasBasis.exists_inter_eq_singleton_of_mem_discrete /-\ntheorem Filter.HasBasis.exists_inter_eq_singleton_of_mem_discrete {ι : Type _} {p : ι → Prop} {t : ι → Set α}\n    {s : Set α} [DiscreteTopology s] {x : α} (hb : ((nhds) x).has_basis p t) (hx : x ∈ s) :\n    ∃ (i : _)(hi : p i), t i ∩ s = {x} :=\n  by\n  rcases(nhdsWithin_hasBasis hb s).mem_iff.1 (singleton_mem_nhdsWithin_of_mem_discrete hx) with ⟨i, hi, hix⟩\n  exact ⟨i, hi, subset.antisymm hix <| singleton_subset_iff.2 ⟨mem_of_mem_nhds <| hb.mem_of_mem hi, hx⟩⟩\n#align filter.has_basis.exists_inter_eq_singleton_of_mem_discrete Filter.HasBasis.exists_inter_eq_singleton_of_mem_discrete\n-/\n\n",
 "exists_compact_superset_iff":
 "#print exists_compact_superset_iff /-\n@[simp]\ntheorem exists_compact_superset_iff [T2Space α] {s : Set α} : (∃ K, IsCompact K ∧ s ⊆ K) ↔ IsCompact (closure s) :=\n  ⟨fun ⟨K, hK, hsK⟩ => isCompact_closure_of_subset_compact hK hsK, fun h => ⟨closure s, h, subset_closure⟩⟩\n#align exists_compact_superset_iff exists_compact_superset_iff\n-/\n\n",
 "exists_closure_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print TopologicalSpace.IsTopologicalBasis.exists_closure_subset /-\ntheorem TopologicalSpace.IsTopologicalBasis.exists_closure_subset {B : Set (Set α)}\n    (hB : TopologicalSpace.IsTopologicalBasis B) {a : α} {s : Set α} (h : s ∈ (nhds) a) :\n    ∃ t ∈ B, a ∈ t ∧ closure t ⊆ s := by\n  simpa only [exists_prop, and_assoc] using hB.nhds_has_basis.nhds_closure.mem_iff.mp h\n#align topological_space.is_topological_basis.exists_closure_subset TopologicalSpace.IsTopologicalBasis.exists_closure_subset\n-/\n\n",
 "exists_closed_singleton":
 "#print IsClosed.exists_closed_singleton /-\n/-- Given a closed set `S` in a compact T₀ space,\nthere is some `x ∈ S` such that `{x}` is closed. -/\ntheorem IsClosed.exists_closed_singleton {α : Type _} [TopologicalSpace α] [T0Space α] [CompactSpace α] {S : Set α}\n    (hS : IsClosed S) (hne : S.nonempty) : ∃ x : α, x ∈ S ∧ IsClosed ({x} : Set α) :=\n  by\n  obtain ⟨V, Vsub, Vne, Vcls, hV⟩ := hS.exists_minimal_nonempty_closed_subset hne\n  rcases minimal_nonempty_closed_eq_singleton Vcls Vne hV with ⟨x, rfl⟩\n  exact ⟨x, Vsub (mem_singleton x), Vcls⟩\n#align is_closed.exists_closed_singleton IsClosed.exists_closed_singleton\n-/\n\n",
 "eventually_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ContinuousAt.eventually_ne /-\ntheorem ContinuousAt.eventually_ne [TopologicalSpace β] [T1Space β] {g : α → β} {a : α} {b : β} (hg1 : ContinuousAt g a)\n    (hg2 : g a ≠ b) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      (g z ≠ b) :=\n  hg1.tendsto.eventually_ne hg2\n#align continuous_at.eventually_ne ContinuousAt.eventually_ne\n-/\n\n",
 "eq_of_tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print eq_of_tendsto_nhds /-\n/-- If a function to a `t1_space` tends to some limit `b` at some point `a`, then necessarily\n`b = f a`. -/\ntheorem eq_of_tendsto_nhds [TopologicalSpace β] [T1Space β] {f : α → β} {a : α} {b : β}\n    (h : Tendsto f ((nhds) a) ((nhds) b)) : f a = b :=\n  by_contra fun hfa : f a ≠ b =>\n    have fact₁ : «expr ᶜ» {f a} ∈ (nhds) b := compl_singleton_mem_nhds hfa.symm\n    have fact₂ : Tendsto f (pure a) ((nhds) b) := h.comp (tendsto_id'.2 <| pure_le_nhds a)\n    fact₂ fact₁ (Eq.refl <| f a)\n#align eq_of_tendsto_nhds eq_of_tendsto_nhds\n-/\n\n",
 "eq_of_nhds_neBot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print eq_of_nhds_neBot /-\ntheorem eq_of_nhds_neBot [T2Space α] {x y : α} (h : NeBot («expr ⊓ » ((nhds) x) ((nhds) y))) : x = y :=\n  t2_iff_nhds.mp ‹_› h\n#align eq_of_nhds_ne_bot eq_of_nhds_neBot\n-/\n\n",
 "eqOn_closure₂'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print eqOn_closure₂' /-\ntheorem eqOn_closure₂' [T2Space α] {s : Set β} {t : Set γ} {f g : β → γ → α} (h : ∀ x ∈ s, ∀ y ∈ t, f x y = g x y)\n    (hf₁ : ∀ x, Continuous (f x)) (hf₂ : ∀ y, Continuous fun x => f x y) (hg₁ : ∀ x, Continuous (g x))\n    (hg₂ : ∀ y, Continuous fun x => g x y) : ∀ x ∈ closure s, ∀ y ∈ closure t, f x y = g x y :=\n  suffices\n    closure s ⊆\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        { x | f x y = g x y }\n    by simpa only [subset_def, mem_Inter]\n  (closure_minimal fun x hx => mem_interᵢ₂.2 <| Set.EqOn.closure (h x hx) (hf₁ _) (hg₁ _)) <|\n    isClosed_binterᵢ fun y hy => isClosed_eq (hf₂ _) (hg₂ _)\n#align eq_on_closure₂' eqOn_closure₂'\n-/\n\n",
 "eqOn_closure₂":
 "#print eqOn_closure₂ /-\ntheorem eqOn_closure₂ [T2Space α] {s : Set β} {t : Set γ} {f g : β → γ → α} (h : ∀ x ∈ s, ∀ y ∈ t, f x y = g x y)\n    (hf : Continuous (uncurry f)) (hg : Continuous (uncurry g)) : ∀ x ∈ closure s, ∀ y ∈ closure t, f x y = g x y :=\n  eqOn_closure₂' h (fun x => continuous_uncurry_left x hf) (fun x => continuous_uncurry_right x hf)\n    (fun y => continuous_uncurry_left y hg) fun y => continuous_uncurry_right y hg\n#align eq_on_closure₂ eqOn_closure₂\n-/\n\n",
 "eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n#print Specializes.eq /-\ntheorem Specializes.eq [T1Space α] {x y : α} (h : «expr ⤳ » x y) : x = y :=\n  t1Space_iff_specializes_imp_eq.1 ‹_› h\n#align specializes.eq Specializes.eq\n-/\n\n",
 "empty_right":
 "theorem empty_right (s : Set α) : SeparatedNhds s ∅ :=\n  ⟨_, _, isOpen_univ, isOpen_empty, fun a h => mem_univ a, fun a h => by cases h, disjoint_empty _⟩\n#align empty_right empty_right\n\n",
 "empty_left":
 "theorem empty_left (s : Set α) : SeparatedNhds ∅ s :=\n  (empty_right _).symm\n#align empty_left empty_left\n\n",
 "embedding_iff_inducing":
 "#print embedding_iff_inducing /-\ntheorem embedding_iff_inducing [TopologicalSpace β] [T0Space α] {f : α → β} : Embedding f ↔ Inducing f :=\n  ⟨embedding.to_inducing, Inducing.embedding⟩\n#align embedding_iff_inducing embedding_iff_inducing\n-/\n\n",
 "embedding":
 "#print Inducing.embedding /-\nprotected theorem Inducing.embedding [TopologicalSpace β] [T0Space α] {f : α → β} (hf : Inducing f) : Embedding f :=\n  ⟨hf, hf.injective⟩\n#align inducing.embedding Inducing.embedding\n-/\n\n",
 "disjoint_pure_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print disjoint_pure_nhds /-\ntheorem disjoint_pure_nhds [T1Space α] {x y : α} (h : x ≠ y) : Disjoint (pure x) ((nhds) y) :=\n  t1Space_iff_disjoint_pure_nhds.mp ‹_› h\n#align disjoint_pure_nhds disjoint_pure_nhds\n-/\n\n",
 "disjoint_nhds_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print disjoint_nhds_pure /-\ntheorem disjoint_nhds_pure [T1Space α] {x y : α} (h : x ≠ y) : Disjoint ((nhds) x) (pure y) :=\n  t1Space_iff_disjoint_nhds_pure.mp ‹_› h\n#align disjoint_nhds_pure disjoint_nhds_pure\n-/\n\n",
 "disjoint_nhds_nhds_iff_not_specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n#print disjoint_nhds_nhds_iff_not_specializes /-\ntheorem disjoint_nhds_nhds_iff_not_specializes {a b : α} : Disjoint ((nhds) a) ((nhds) b) ↔ ¬«expr ⤳ » a b := by\n  rw [← nhdsSet_singleton, disjoint_nhdsSet_nhds, specializes_iff_mem_closure]\n#align disjoint_nhds_nhds_iff_not_specializes disjoint_nhds_nhds_iff_not_specializes\n-/\n\n",
 "disjoint_nhds_nhdsSet":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n#print disjoint_nhds_nhdsSet /-\ntheorem disjoint_nhds_nhdsSet : Disjoint ((nhds) a) ((nhds_set) s) ↔ a ∉ closure s :=\n  disjoint_comm.trans disjoint_nhdsSet_nhds\n#align disjoint_nhds_nhds_set disjoint_nhds_nhdsSet\n-/\n\n",
 "disjoint_nhds_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print disjoint_nhds_nhds /-\n@[simp]\ntheorem disjoint_nhds_nhds [T2Space α] {x y : α} : Disjoint ((nhds) x) ((nhds) y) ↔ x ≠ y :=\n  ⟨fun hd he => by simpa [he, nhds_ne_bot.ne] using hd, t2Space_iff_disjoint_nhds.mp ‹_› x y⟩\n#align disjoint_nhds_nhds disjoint_nhds_nhds\n-/\n\n",
 "disjoint_nhdsWithin_of_mem_discrete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n#print disjoint_nhdsWithin_of_mem_discrete /-\n/-- For point `x` in a discrete subset `s` of a topological space, there is a set `U`\nsuch that\n1. `U` is a punctured neighborhood of `x` (ie. `U ∪ {x}` is a neighbourhood of `x`),\n2. `U` is disjoint from `s`.\n-/\ntheorem disjoint_nhdsWithin_of_mem_discrete {s : Set α} [DiscreteTopology s] {x : α} (hx : x ∈ s) :\n    ∃ U ∈ nhds_within.ne x, Disjoint U s :=\n  let ⟨V, h, h'⟩ := nhds_inter_eq_singleton_of_mem_discrete hx\n  ⟨«expr ᶜ» {x} ∩ V, inter_mem_nhdsWithin _ h,\n    disjoint_iff_inter_eq_empty.mpr (by rw [inter_assoc, h', compl_inter_self])⟩\n#align disjoint_nhds_within_of_mem_discrete disjoint_nhdsWithin_of_mem_discrete\n-/\n\n",
 "disjoint_nhdsSet_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print disjoint_nhdsSet_nhds /-\ntheorem disjoint_nhdsSet_nhds : Disjoint ((nhds_set) s) ((nhds) a) ↔ a ∉ closure s :=\n  Iff.mp ((regularSpace_TFAE α).out 0 2) ‹_› _ _\n#align disjoint_nhds_set_nhds disjoint_nhdsSet_nhds\n-/\n\n",
 "disjoint_nested_nhds":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (U₁ V₁ «expr ∈ » nhds() x) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (U₂ V₂ «expr ∈ » nhds() y) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print disjoint_nested_nhds /-\n/-- Given two points `x ≠ y`, we can find neighbourhoods `x ∈ V₁ ⊆ U₁` and `y ∈ V₂ ⊆ U₂`,\nwith the `Vₖ` closed and the `Uₖ` open, such that the `Uₖ` are disjoint. -/\ntheorem disjoint_nested_nhds [T3Space α] {x y : α} (h : x ≠ y) :\n    ∃ (U₁ : _)(_ : U₁ ∈ (nhds) x)(V₁ : _)(_ : V₁ ∈ (nhds) x)(U₂ : _)(_ : U₂ ∈ (nhds) y)(V₂ : _)(_ : V₂ ∈ (nhds) y),\n      IsClosed V₁ ∧ IsClosed V₂ ∧ IsOpen U₁ ∧ IsOpen U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ Disjoint U₁ U₂ :=\n  by\n  rcases t2_separation h with ⟨U₁, U₂, U₁_op, U₂_op, x_in, y_in, H⟩\n  rcases exists_mem_nhds_isClosed_subset (U₁_op.mem_nhds x_in) with ⟨V₁, V₁_in, V₁_closed, h₁⟩\n  rcases exists_mem_nhds_isClosed_subset (U₂_op.mem_nhds y_in) with ⟨V₂, V₂_in, V₂_closed, h₂⟩\n  exact\n    ⟨U₁, mem_of_superset V₁_in h₁, V₁, V₁_in, U₂, mem_of_superset V₂_in h₂, V₂, V₂_in, V₁_closed, V₂_closed, U₁_op,\n      U₂_op, h₁, h₂, H⟩\n#align disjoint_nested_nhds disjoint_nested_nhds\n-/\n\n",
 "disjoint_lift'_closure_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print disjoint_lift'_closure_nhds /-\n@[simp]\ntheorem disjoint_lift'_closure_nhds [T25Space α] {x y : α} :\n    Disjoint (((nhds) x).lift' closure) (((nhds) y).lift' closure) ↔ x ≠ y :=\n  ⟨fun h hxy => by simpa [hxy, nhds_ne_bot.ne] using h, fun h => t2_5_space.t2_5 h⟩\n#align disjoint_lift'_closure_nhds disjoint_lift'_closure_nhds\n-/\n\n",
 "disjoint_closure_right":
 "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=\n  h.symm.disjoint_closure_left.symm\n#align disjoint_closure_right disjoint_closure_right\n\n",
 "disjoint_closure_left":
 "theorem disjoint_closure_left (h : SeparatedNhds s t) : Disjoint (closure s) t :=\n  let ⟨U, V, hU, hV, hsU, htV, hd⟩ := h\n  (hd.closure_left hV).mono (closure_mono hsU) htV\n#align disjoint_closure_left disjoint_closure_left\n\n",
 "discrete_of_t1_of_finite":
 "#print discrete_of_t1_of_finite /-\ntheorem discrete_of_t1_of_finite {X : Type _} [TopologicalSpace X] [T1Space X] [Finite X] : DiscreteTopology X :=\n  by\n  apply singletons_open_iff_discrete.mp\n  intro x\n  rw [← isClosed_compl_iff]\n  exact (Set.toFinite _).is_closed\n#align discrete_of_t1_of_finite discrete_of_t1_of_finite\n-/\n\n",
 "diff_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n#print Dense.diff_singleton /-\n/-- Removing a non-isolated point from a dense set, one still obtains a dense set. -/\ntheorem Dense.diff_singleton [T1Space α] {s : Set α} (hs : Dense s) (x : α) [NeBot (nhds_within.ne x)] :\n    Dense (s \\ {x}) :=\n  hs.inter_of_open_right (dense_compl_singleton x) isOpen_compl_singleton\n#align dense.diff_singleton Dense.diff_singleton\n-/\n\n",
 "diff_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n#print Dense.diff_finset /-\n/-- Removing a finset from a dense set in a space without isolated points, one still\nobtains a dense set. -/\ntheorem Dense.diff_finset [T1Space α] [∀ x : α, NeBot (nhds_within.ne x)] {s : Set α} (hs : Dense s) (t : Finset α) :\n    Dense (s \\ t) := by\n  induction' t using Finset.induction_on with x s hxs ih hd\n  · simpa using hs\n  · rw [Finset.coe_insert, ← union_singleton, ← diff_diff]\n    exact ih.diff_singleton _\n#align dense.diff_finset Dense.diff_finset\n-/\n\n",
 "diff_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n#print Dense.diff_finite /-\n/-- Removing a finite set from a dense set in a space without isolated points, one still\nobtains a dense set. -/\ntheorem Dense.diff_finite [T1Space α] [∀ x : α, NeBot (nhds_within.ne x)] {s : Set α} (hs : Dense s) {t : Set α}\n    (ht : t.finite) : Dense (s \\ t) := by\n  convert hs.diff_finset ht.to_finset\n  exact (finite.coe_to_finset _).symm\n#align dense.diff_finite Dense.diff_finite\n-/\n\n",
 "continuous_of":
 "#print CofiniteTopology.continuous_of /-\ntheorem CofiniteTopology.continuous_of [T1Space α] : Continuous (@CofiniteTopology.of α) :=\n  t1Space_iff_continuous_cofinite_of.mp ‹_›\n#align cofinite_topology.continuous_of CofiniteTopology.continuous_of\n-/\n\n",
 "continuousWithinAt_update_of_ne":
 "#print continuousWithinAt_update_of_ne /-\ntheorem continuousWithinAt_update_of_ne [T1Space α] [DecidableEq α] [TopologicalSpace β] {f : α → β} {s : Set α}\n    {x y : α} {z : β} (hne : y ≠ x) : ContinuousWithinAt (Function.update f x z) s y ↔ ContinuousWithinAt f s y :=\n  EventuallyEq.congr_continuousWithinAt\n    (mem_nhdsWithin_of_mem_nhds <| mem_of_superset (isOpen_ne.mem_nhds hne) fun y' hy' => Function.update_noteq hy' _ _)\n    (Function.update_noteq hne _ _)\n#align continuous_within_at_update_of_ne continuousWithinAt_update_of_ne\n-/\n\n",
 "continuousOn_update_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print continuousOn_update_iff /-\ntheorem continuousOn_update_iff [T1Space α] [DecidableEq α] [TopologicalSpace β] {f : α → β} {s : Set α} {x : α}\n    {y : β} :\n    ContinuousOn (Function.update f x y) s ↔\n      ContinuousOn f (s \\ {x}) ∧ (x ∈ s → Tendsto f (nhds_within (s \\ {x}) x) ((nhds) y)) :=\n  by\n  rw [ContinuousOn, ← and_forall_ne x, and_comm']\n  refine' and_congr ⟨fun H z hz => _, fun H z hzx hzs => _⟩ (forall_congr' fun hxs => _)\n  · specialize H z hz.2 hz.1\n    rw [continuousWithinAt_update_of_ne hz.2] at H\n    exact H.mono (diff_subset _ _)\n  · rw [continuousWithinAt_update_of_ne hzx]\n    refine' (H z ⟨hzs, hzx⟩).mono_of_mem (inter_mem_nhdsWithin _ _)\n    exact is_open_ne.mem_nhds hzx\n  · exact continuousWithinAt_update_same\n#align continuous_on_update_iff continuousOn_update_iff\n-/\n\n",
 "continuousAt_update_of_ne":
 "#print continuousAt_update_of_ne /-\ntheorem continuousAt_update_of_ne [T1Space α] [DecidableEq α] [TopologicalSpace β] {f : α → β} {x y : α} {z : β}\n    (hne : y ≠ x) : ContinuousAt (Function.update f x z) y ↔ ContinuousAt f y := by\n  simp only [← continuousWithinAt_univ, continuousWithinAt_update_of_ne hne]\n#align continuous_at_update_of_ne continuousAt_update_of_ne\n-/\n\n",
 "continuousAt_of_tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print continuousAt_of_tendsto_nhds /-\n/-- To prove a function to a `t1_space` is continuous at some point `a`, it suffices to prove that\n`f` admits *some* limit at `a`. -/\ntheorem continuousAt_of_tendsto_nhds [TopologicalSpace β] [T1Space β] {f : α → β} {a : α} {b : β}\n    (h : Tendsto f ((nhds) a) ((nhds) b)) : ContinuousAt f a :=\n  show Tendsto f ((nhds) a) (nhds <| f a) by rwa [eq_of_tendsto_nhds h]\n#align continuous_at_of_tendsto_nhds continuousAt_of_tendsto_nhds\n-/\n\n",
 "connectedComponent_eq_interᵢ_clopen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print connectedComponent_eq_interᵢ_clopen /-\n-- see Note [lower instance priority]\n/-- In a compact t2 space, the connected component of a point equals the intersection of all\nits clopen neighbourhoods. -/\ntheorem connectedComponent_eq_interᵢ_clopen [T2Space α] [CompactSpace α] (x : α) :\n    connectedComponent x =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" Z :=\n  by\n  apply eq_of_subset_of_subset connectedComponent_subset_interᵢ_clopen\n  -- Reduce to showing that the clopen intersection is connected.\n  refine' IsPreconnected.subset_connectedComponent _ (mem_Inter.2 fun Z => Z.2.2)\n  -- We do this by showing that any disjoint cover by two closed sets implies\n  -- that one of these closed sets must contain our whole thing.\n  -- To reduce to the case where the cover is disjoint on all of `α` we need that `s` is closed\n  have hs :\n    IsClosed\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" Z : Set α) :=\n    isClosed_interᵢ fun Z => Z.2.1.2\n  rw [isPreconnected_iff_subset_of_fully_disjoint_closed hs]\n  intro a b ha hb hab ab_disj\n  haveI := @normalOfCompactT2 α _ _ _\n  -- Since our space is normal, we get two larger disjoint open sets containing the disjoint\n  -- closed sets. If we can show that our intersection is a subset of any of these we can then\n  -- \"descend\" this to show that it is a subset of either a or b.\n  rcases normal_separation ha hb ab_disj with ⟨u, v, hu, hv, hau, hbv, huv⟩\n  -- If we can find a clopen set around x, contained in u ∪ v, we get a disjoint decomposition\n  -- Z = Z ∩ u ∪ Z ∩ v of clopen sets. The intersection of all clopen neighbourhoods will then lie\n  -- in whichever of u or v x lies in and hence will be a subset of either a or b.\n  rsuffices ⟨Z, H⟩ : ∃ Z : Set α, IsClopen Z ∧ x ∈ Z ∧ Z ⊆ u ∪ v\n  · have H1 := isClopen_inter_of_disjoint_cover_clopen H.1 H.2.2 hu hv huv\n    rw [union_comm] at H\n    have H2 := isClopen_inter_of_disjoint_cover_clopen H.1 H.2.2 hv hu huv.symm\n    by_cases x ∈ u\n    -- The x ∈ u case.\n    · left\n      suffices «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑Z ⊆ u\n        by\n        replace hab :\n          «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑Z ≤ a ∪ b :=\n          hab\n        replace this :\n          «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑Z ≤ u := this\n        exact Disjoint.left_le_of_le_sup_right hab (huv.mono this hbv)\n      · apply subset.trans _ (inter_subset_right Z u)\n        apply Inter_subset (fun Z : { Z : Set α // IsClopen Z ∧ x ∈ Z } => ↑Z) ⟨Z ∩ u, H1, mem_inter H.2.1 h⟩\n    -- If x ∉ u, we get x ∈ v since x ∈ u ∪ v. The rest is then like the x ∈ u case.\n    have h1 : x ∈ v :=\n      by\n      cases'\n        (mem_union x u v).1\n          (mem_of_subset_of_mem (subset.trans hab (union_subset_union hau hbv)) (mem_Inter.2 fun i => i.2.2)) with\n        h1 h1\n      · exfalso\n        exact h h1\n      · exact h1\n    right\n    suffices «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑Z ⊆ v\n      by\n      replace this :\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑Z ≤ v := this\n      exact (huv.symm.mono this hau).left_le_of_le_sup_left hab\n    · apply subset.trans _ (inter_subset_right Z v)\n      apply Inter_subset (fun Z : { Z : Set α // IsClopen Z ∧ x ∈ Z } => ↑Z) ⟨Z ∩ v, H2, mem_inter H.2.1 h1⟩\n  -- Now we find the required Z. We utilize the fact that X \\ u ∪ v will be compact,\n  -- so there must be some finite intersection of clopen neighbourhoods of X disjoint to it,\n  -- but a finite intersection of clopen sets is clopen so we let this be our Z.\n  have H1 :=\n    (hu.union hv).is_closed_compl.is_compact.inter_Inter_nonempty (fun Z : { Z : Set α // IsClopen Z ∧ x ∈ Z } => Z)\n      fun Z => Z.2.1.2\n  rw [← not_disjoint_iff_nonempty_inter, imp_not_comm, not_forall] at H1\n  cases' H1 (disjoint_compl_left_iff_subset.2 <| hab.trans <| union_subset_union hau hbv) with Zi H2\n  refine'\n    ⟨«expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (Subtype.val U), _,\n      _, _⟩\n  · exact isClopen_binterᵢ_finset fun Z hZ => Z.2.1\n  · exact mem_Inter₂.2 fun Z hZ => Z.2.2\n  · rwa [← disjoint_compl_left_iff_subset, disjoint_iff_inter_eq_empty, ← not_nonempty_iff_eq_empty]\n#align connected_component_eq_Inter_clopen connectedComponent_eq_interᵢ_clopen\n-/\n\n",
 "compl_singleton_mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print compl_singleton_mem_nhds_iff /-\n-- see Note [lower instance priority]\n@[simp]\ntheorem compl_singleton_mem_nhds_iff [T1Space α] {x y : α} : «expr ᶜ» {x} ∈ (nhds) y ↔ y ≠ x :=\n  isOpen_compl_singleton.mem_nhds_iff\n#align compl_singleton_mem_nhds_iff compl_singleton_mem_nhds_iff\n-/\n\n",
 "compl_singleton_mem_nhdsSet_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_set -/\n#print compl_singleton_mem_nhdsSet_iff /-\n@[simp]\ntheorem compl_singleton_mem_nhdsSet_iff [T1Space α] {x : α} {s : Set α} : «expr ᶜ» {x} ∈ (nhds_set) s ↔ x ∉ s := by\n  rwa [is_open_compl_singleton.mem_nhds_set, subset_compl_singleton_iff]\n#align compl_singleton_mem_nhds_set_iff compl_singleton_mem_nhdsSet_iff\n-/\n\n",
 "compl_singleton_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print compl_singleton_mem_nhds /-\ntheorem compl_singleton_mem_nhds [T1Space α] {x y : α} (h : y ≠ x) : «expr ᶜ» {x} ∈ (nhds) y :=\n  compl_singleton_mem_nhds_iff.mpr h\n#align compl_singleton_mem_nhds compl_singleton_mem_nhds\n-/\n\n",
 "compact_t2_tot_disc_iff_tot_sep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print compact_t2_tot_disc_iff_tot_sep /-\n/-- A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\n  is also true for locally compact spaces. -/\ntheorem compact_t2_tot_disc_iff_tot_sep : TotallyDisconnectedSpace α ↔ TotallySeparatedSpace α :=\n  by\n  constructor\n  · intro h\n    constructor\n    rintro x - y -\n    contrapose!\n    intro hyp\n    suffices x ∈ connectedComponent y by\n      simpa [totallyDisconnectedSpace_iff_connectedComponent_singleton.1 h y, mem_singleton_iff]\n    rw [connectedComponent_eq_interᵢ_clopen, mem_Inter]\n    rintro ⟨w : Set α, hw : IsClopen w, hy : y ∈ w⟩\n    by_contra hx\n    exact\n      hyp («expr ᶜ» w) w hw.2.is_open_compl hw.1 hx hy (@isCompl_compl _ w _).symm.codisjoint.top_le disjoint_compl_left\n  apply TotallySeparatedSpace.totallyDisconnectedSpace\n#align compact_t2_tot_disc_iff_tot_sep compact_t2_tot_disc_iff_tot_sep\n-/\n\n",
 "compact_exists_clopen_in_open":
 "#print compact_exists_clopen_in_open /-\n/-- Every member of an open set in a compact Hausdorff totally disconnected space\n  is contained in a clopen set contained in the open set.  -/\ntheorem compact_exists_clopen_in_open {x : α} {U : Set α} (is_open : IsOpen U) (memU : x ∈ U) :\n    ∃ (V : Set α)(hV : IsClopen V), x ∈ V ∧ V ⊆ U :=\n  (IsTopologicalBasis.mem_nhds_iff isTopologicalBasis_clopen).1 (IsOpen.mem_nhds memU)\n#align compact_exists_clopen_in_open compact_exists_clopen_in_open\n-/\n\n",
 "comm":
 "#print comm /-\ntheorem comm (s t : Set α) : SeparatedNhds s t ↔ SeparatedNhds t s :=\n  ⟨symm, symm⟩\n#align comm comm\n-/\n\n",
 "coclosedCompact_le_cofinite":
 "#print Filter.coclosedCompact_le_cofinite /-\ntheorem Filter.coclosedCompact_le_cofinite [T1Space α] : Filter.coclosedCompact α ≤ Filter.cofinite := fun s hs =>\n  compl_compl s ▸ hs.is_compact.compl_mem_coclosed_compact_of_is_closed hs.is_closed\n#align filter.coclosed_compact_le_cofinite Filter.coclosedCompact_le_cofinite\n-/\n\n",
 "coclosedCompact_eq_cocompact":
 "#print Filter.coclosedCompact_eq_cocompact /-\n@[simp]\ntheorem Filter.coclosedCompact_eq_cocompact [T2Space α] : coclosedCompact α = cocompact α := by\n  simp [coclosed_compact, cocompact, infᵢ_and', and_iff_right_of_imp IsCompact.isClosed]\n#align filter.coclosed_compact_eq_cocompact Filter.coclosedCompact_eq_cocompact\n-/\n\n",
 "closure_singleton":
 "#print closure_singleton /-\n@[simp]\ntheorem closure_singleton [T1Space α] {a : α} : closure ({a} : Set α) = {a} :=\n  isClosed_singleton.closure_eq\n#align closure_singleton closure_singleton\n-/\n\n",
 "closure":
 "#print Set.EqOn.closure /-\n/-- If two continuous maps are equal on `s`, then they are equal on the closure of `s`. See also\n`set.eq_on.of_subset_closure` for a more general version. -/\ntheorem Set.EqOn.closure [T2Space α] {s : Set β} {f g : β → α} (h : EqOn f g s) (hf : Continuous f)\n    (hg : Continuous g) : EqOn f g (closure s) :=\n  closure_minimal h (isClosed_eq hf hg)\n#align set.eq_on.closure Set.EqOn.closure\n-/\n\n",
 "closed_range":
 "#print Function.LeftInverse.closed_range /-\ntheorem Function.LeftInverse.closed_range [T2Space α] {f : α → β} {g : β → α} (h : function.left_inverse f g)\n    (hf : Continuous f) (hg : Continuous g) : IsClosed (range g) :=\n  have : EqOn (g ∘ f) id (closure <| range g) := h.right_inv_on_range.eq_on.closure (hg.comp hf) continuous_id\n  isClosed_of_closure_subset fun x hx =>\n    calc\n      x = g (f x) := (this hx).symm\n      _ ∈ _ := mem_range_self _\n      \n#align function.left_inverse.closed_range Function.LeftInverse.closed_range\n-/\n\n",
 "closed_nhds_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print closed_nhds_basis /-\ntheorem closed_nhds_basis (a : α) : ((nhds) a).has_basis (fun s : Set α => s ∈ (nhds) a ∧ IsClosed s) id :=\n  hasBasis_self.2 fun _ => exists_mem_nhds_isClosed_subset\n#align closed_nhds_basis closed_nhds_basis\n-/\n\n",
 "closedEmbedding":
 "#print Continuous.closedEmbedding /-\ntheorem Continuous.closedEmbedding [CompactSpace α] [T2Space β] {f : α → β} (h : Continuous f)\n    (hf : function.injective f) : ClosedEmbedding f :=\n  closedEmbedding_of_continuous_injective_closed h hf h.is_closed_map\n#align continuous.closed_embedding Continuous.closedEmbedding\n-/\n\n",
 "binterᵢ_basis_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print binterᵢ_basis_nhds /-\ntheorem binterᵢ_basis_nhds [T1Space α] {ι : Sort _} {p : ι → Prop} {s : ι → Set α} {x : α}\n    (h : ((nhds) x).has_basis p s) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i) = {x} :=\n  by\n  simp only [eq_singleton_iff_unique_mem, mem_Inter]\n  refine' ⟨fun i hi => mem_of_mem_nhds <| h.mem_of_mem hi, fun y hy => _⟩\n  contrapose! hy\n  rcases h.mem_iff.1 (compl_singleton_mem_nhds hy.symm) with ⟨i, hi, hsub⟩\n  exact ⟨i, hi, fun h => hsub h rfl⟩\n#align bInter_basis_nhds binterᵢ_basis_nhds\n-/\n\n",
 "binary_compact_cover":
 "#print IsCompact.binary_compact_cover /-\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem IsCompact.binary_compact_cover [T2Space α] {K U V : Set α} (hK : IsCompact K) (hU : IsOpen U) (hV : IsOpen V)\n    (h2K : K ⊆ U ∪ V) : ∃ K₁ K₂ : Set α, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂ :=\n  by\n  obtain ⟨O₁, O₂, h1O₁, h1O₂, h2O₁, h2O₂, hO⟩ :=\n    isCompact_isCompact_separated (hK.diff hU) (hK.diff hV)\n      (by rwa [disjoint_iff_inter_eq_empty, diff_inter_diff, diff_eq_empty])\n  exact\n    ⟨_, _, hK.diff h1O₁, hK.diff h1O₂, by rwa [diff_subset_comm], by rwa [diff_subset_comm], by\n      rw [← diff_inter, hO.inter_eq, diff_empty]⟩\n#align is_compact.binary_compact_cover IsCompact.binary_compact_cover\n-/\n\n",
 "Disjoint":
 "#print Disjoint /-\nprotected theorem Disjoint (h : SeparatedNhds s t) : Disjoint s t :=\n  let ⟨U, V, hU, hV, hsU, htV, hd⟩ := h\n  hd.mono hsU htV\n#align disjoint Disjoint\n-/\n\n"}