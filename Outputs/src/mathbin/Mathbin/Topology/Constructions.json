{"update":
 "#print Continuous.update /-\ntheorem Continuous.update [DecidableEq Œπ] (hf : Continuous f) (i : Œπ) {g : Œ± ‚Üí œÄ i} (hg : Continuous g) :\n    Continuous fun a => update (f a) i (g a) :=\n  continuous_iff_continuousAt.2 fun x => hf.continuous_at.update i hg.continuous_at\n#align continuous.update Continuous.update\n-/\n\n",
 "tendsto_subtype_rng":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_subtype_rng /-\ntheorem tendsto_subtype_rng {Œ≤ : Type _} {p : Œ± ‚Üí Prop} {b : Filter Œ≤} {f : Œ≤ ‚Üí Subtype p} :\n    ‚àÄ {a : Subtype p}, Tendsto f b ((nhds) a) ‚Üî Tendsto (fun x => (f x : Œ±)) b ((nhds) (a : Œ±))\n  | ‚ü®a, ha‚ü© => by rw [nhds_subtype_eq_comap, tendsto_comap_iff, Subtype.coe_mk]\n#align tendsto_subtype_rng tendsto_subtype_rng\n-/\n\n",
 "tendsto_pi_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_pi_nhds /-\ntheorem tendsto_pi_nhds {f : Œ≤ ‚Üí ‚àÄ i, œÄ i} {g : ‚àÄ i, œÄ i} {u : Filter Œ≤} :\n    Tendsto f u ((nhds) g) ‚Üî ‚àÄ x, Tendsto (fun i => f i x) u ((nhds) (g x)) := by rw [nhds_pi, Filter.tendsto_pi]\n#align tendsto_pi_nhds tendsto_pi_nhds\n-/\n\n",
 "tendsto_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Prod.tendsto_iff /-\ntheorem Prod.tendsto_iff {Œ±} (seq : Œ± ‚Üí Œ≤ √ó Œ≥) {f : Filter Œ±} (x : Œ≤ √ó Œ≥) :\n    Tendsto seq f ((nhds) x) ‚Üî\n      Tendsto (fun n => (seq n).fst) f ((nhds) x.fst) ‚àß Tendsto (fun n => (seq n).snd) f ((nhds) x.snd) :=\n  by\n  cases x\n  rw [nhds_prod_eq, Filter.tendsto_prod_iff']\n#align prod.tendsto_iff Prod.tendsto_iff\n-/\n\n",
 "sum_map":
 "#print Continuous.sum_map /-\n@[continuity]\ntheorem Continuous.sum_map {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥} (hf : Continuous f) (hg : Continuous g) : Continuous (Sum.map f g) :=\n  continuous_sum_map.2 ‚ü®hf, hg‚ü©\n#align continuous.sum_map Continuous.sum_map\n-/\n\n",
 "sum_elim":
 "#print IsOpenMap.sum_elim /-\ntheorem IsOpenMap.sum_elim {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≥} (hf : IsOpenMap f) (hg : IsOpenMap g) : IsOpenMap (Sum.elim f g) :=\n  isOpenMap_sum_elim.2 ‚ü®hf, hg‚ü©\n#align is_open_map.sum_elim IsOpenMap.sum_elim\n-/\n\n",
 "subtype_val":
 "#print Continuous.subtype_val /-\ntheorem Continuous.subtype_val {f : Œ≤ ‚Üí Subtype p} (hf : Continuous f) : Continuous fun x => (f x : Œ±) :=\n  continuous_subtype_val.comp hf\n#align continuous.subtype_coe Continuous.subtype_val\n-/\n\n",
 "subtype_mk":
 "#print Continuous.subtype_mk /-\n@[continuity]\ntheorem Continuous.subtype_mk {f : Œ≤ ‚Üí Œ±} (h : Continuous f) (hp : ‚àÄ x, p (f x)) :\n    Continuous fun x => (‚ü®f x, hp x‚ü© : Subtype p) :=\n  continuous_induced_rng.2 h\n#align continuous.subtype_mk Continuous.subtype_mk\n-/\n\n",
 "subtype_map":
 "#print Continuous.subtype_map /-\ntheorem Continuous.subtype_map {f : Œ± ‚Üí Œ≤} (h : Continuous f) {q : Œ≤ ‚Üí Prop} (hpq : ‚àÄ x, p x ‚Üí q (f x)) :\n    Continuous (Subtype.map f hpq) :=\n  (h.comp continuous_subtype_val).subtype_mk _\n#align continuous.subtype_map Continuous.subtype_map\n-/\n\n",
 "snd''":
 "#print ContinuousAt.snd'' /-\n/-- Precomposing `f` with `prod.snd` is continuous at `x : Œ± √ó Œ≤` -/\ntheorem ContinuousAt.snd'' {f : Œ≤ ‚Üí Œ≥} {x : Œ± √ó Œ≤} (hf : ContinuousAt f x.snd) :\n    ContinuousAt (fun x : Œ± √ó Œ≤ => f x.snd) x :=\n  hf.comp continuousAt_snd\n#align continuous_at.snd'' ContinuousAt.snd''\n-/\n\n",
 "snd'":
 "#print ContinuousAt.snd' /-\n/-- Precomposing `f` with `prod.snd` is continuous at `(x, y)` -/\ntheorem ContinuousAt.snd' {f : Œ≤ ‚Üí Œ≥} {x : Œ±} {y : Œ≤} (hf : ContinuousAt f y) :\n    ContinuousAt (fun x : Œ± √ó Œ≤ => f x.snd) (x, y) :=\n  ContinuousAt.comp hf continuousAt_snd\n#align continuous_at.snd' ContinuousAt.snd'\n-/\n\n",
 "snd":
 "#print ContinuousAt.snd /-\n/-- Postcomposing `f` with `prod.snd` is continuous at `x` -/\ntheorem ContinuousAt.snd {f : Œ± ‚Üí Œ≤ √ó Œ≥} {x : Œ±} (hf : ContinuousAt f x) : ContinuousAt (fun a : Œ± => (f a).2) x :=\n  continuousAt_snd.comp hf\n#align continuous_at.snd ContinuousAt.snd\n-/\n\n",
 "sigma_map":
 "#print Continuous.sigma_map /-\n@[continuity]\ntheorem Continuous.sigma_map {f‚ÇÅ : Œπ ‚Üí Œ∫} {f‚ÇÇ : ‚àÄ i, œÉ i ‚Üí œÑ (f‚ÇÅ i)} (hf : ‚àÄ i, Continuous (f‚ÇÇ i)) :\n    Continuous (Sigma.map f‚ÇÅ f‚ÇÇ) :=\n  continuous_sigma_map.2 hf\n#align continuous.sigma_map Continuous.sigma_map\n-/\n\n",
 "set_pi_mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print set_pi_mem_nhds_iff /-\ntheorem set_pi_mem_nhds_iff {I : Set Œπ} (hI : I.finite) {s : ‚àÄ i, Set (œÄ i)} (a : ‚àÄ i, œÄ i) :\n    I.pi s ‚àà (nhds) a ‚Üî ‚àÄ i : Œπ, i ‚àà I ‚Üí s i ‚àà (nhds) (a i) :=\n  by\n  rw [nhds_pi, pi_mem_pi_iff hI]\n  infer_instance\n#align set_pi_mem_nhds_iff set_pi_mem_nhds_iff\n-/\n\n",
 "set_pi_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print set_pi_mem_nhds /-\ntheorem set_pi_mem_nhds {i : Set Œπ} {s : ‚àÄ a, Set (œÄ a)} {x : ‚àÄ a, œÄ a} (hi : i.finite)\n    (hs : ‚àÄ a ‚àà i, s a ‚àà (nhds) (x a)) : pi i s ‚àà (nhds) x :=\n  by\n  rw [pi_def, bInter_mem hi]\n  exact fun a ha => (continuous_apply a).continuous_at (hs a ha)\n#align set_pi_mem_nhds set_pi_mem_nhds\n-/\n\n",
 "restrictPreimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n#print ContinuousAt.restrictPreimage /-\ntheorem ContinuousAt.restrictPreimage {f : Œ± ‚Üí Œ≤} {s : Set Œ≤} {x : ¬´expr ‚Åª¬π' ¬ª f s} (h : ContinuousAt f x) :\n    ContinuousAt (s.restrict_preimage f) x :=\n  h.restrict _\n#align continuous_at.restrict_preimage ContinuousAt.restrictPreimage\n-/\n\n",
 "restrict":
 "#print ContinuousAt.restrict /-\ntheorem ContinuousAt.restrict {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {t : Set Œ≤} (h1 : MapsTo f s t) {x : s} (h2 : ContinuousAt f x) :\n    ContinuousAt (h1.restrict f s t) x :=\n  (h2.comp continuousAt_subtype_val).cod_restrict _\n#align continuous_at.restrict ContinuousAt.restrict\n-/\n\n",
 "quotient_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚áí ¬ª -/\n#print Continuous.quotient_map' /-\ntheorem Continuous.quotient_map' {t : setoid Œ≤} {f : Œ± ‚Üí Œ≤} (hf : Continuous f) (H : (¬´expr ‚áí ¬ª s.r t.r) f f) :\n    Continuous (Quotient.map' f H) :=\n  (continuous_quotient_mk'.comp hf).quotient_lift _\n#align continuous.quotient_map' Continuous.quotient_map'\n-/\n\n",
 "quotient_liftOn'":
 "#print Continuous.quotient_liftOn' /-\ntheorem Continuous.quotient_liftOn' {f : Œ± ‚Üí Œ≤} (h : Continuous f) (hs : ‚àÄ a b, @Setoid.r _ s a b ‚Üí f a = f b) :\n    Continuous (fun x => Quotient.liftOn' x f hs : quotient s ‚Üí Œ≤) :=\n  h.quotient_lift hs\n#align continuous.quotient_lift_on' Continuous.quotient_liftOn'\n-/\n\n",
 "quotient_lift":
 "#print Continuous.quotient_lift /-\ntheorem Continuous.quotient_lift {f : Œ± ‚Üí Œ≤} (h : Continuous f) (hs : ‚àÄ a b, a ‚âà b ‚Üí f a = f b) :\n    Continuous (quotient.lift f hs : quotient s ‚Üí Œ≤) :=\n  continuous_coinduced_dom.2 h\n#align continuous.quotient_lift Continuous.quotient_lift\n-/\n\n",
 "quotientMap_quotient_mk'":
 "#print quotientMap_quotient_mk' /-\ntheorem quotientMap_quotient_mk' : QuotientMap (@Quotient.mk' Œ± s) :=\n  quotientMap_quot_mk\n#align quotient_map_quotient_mk quotientMap_quotient_mk'\n-/\n\n",
 "quotientMap_quot_mk":
 "#print quotientMap_quot_mk /-\ntheorem quotientMap_quot_mk : QuotientMap (@Quot.mk Œ± r) :=\n  ‚ü®quot.exists_rep, rfl‚ü©\n#align quotient_map_quot_mk quotientMap_quot_mk\n-/\n\n",
 "quotient":
 "#print DenseRange.quotient /-\n/-- The composition of `quotient.mk` and a function with dense range has dense range. -/\ntheorem DenseRange.quotient [setoid Œ±] [TopologicalSpace Œ±] {f : Œ≤ ‚Üí Œ±} (hf : DenseRange f) :\n    DenseRange (Quotient.mk' ‚àò f) :=\n  (surjective_quotient_mk Œ±).dense_range.comp hf continuous_coinduced_rng\n#align dense_range.quotient DenseRange.quotient\n-/\n\n",
 "prod_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print Filter.HasBasis.prod_nhds' /-\ntheorem Filter.HasBasis.prod_nhds' {Œπa Œπb : Type _} {pa : Œπa ‚Üí Prop} {pb : Œπb ‚Üí Prop} {sa : Œπa ‚Üí Set Œ±}\n    {sb : Œπb ‚Üí Set Œ≤} {ab : Œ± √ó Œ≤} (ha : ((nhds) ab.1).has_basis pa sa) (hb : ((nhds) ab.2).has_basis pb sb) :\n    ((nhds) ab).has_basis (fun i : Œπa √ó Œπb => pa i.1 ‚àß pb i.2) fun i => finset.product (sa i.1) (sb i.2) :=\n  by\n  cases ab\n  exact ha.prod_nhds hb\n#align filter.has_basis.prod_nhds' Filter.HasBasis.prod_nhds'\n-/\n\n",
 "prod_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Eventually.prod_nhds /-\ntheorem Filter.Eventually.prod_nhds {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop} {a : Œ±} {b : Œ≤}\n    (ha :\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" ((nhds) a)\n        (p x))\n    (hb :\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" ((nhds) b)\n        (q y)) :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n      ((nhds) (a, b)) (p z.1 ‚àß q z.2) :=\n  prod_mem_nhds ha hb\n#align filter.eventually.prod_nhds Filter.Eventually.prod_nhds\n-/\n\n",
 "prod_mk_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.prod_mk_nhds /-\ntheorem Filter.Tendsto.prod_mk_nhds {Œ≥} {a : Œ±} {b : Œ≤} {f : Filter Œ≥} {ma : Œ≥ ‚Üí Œ±} {mb : Œ≥ ‚Üí Œ≤}\n    (ha : Tendsto ma f ((nhds) a)) (hb : Tendsto mb f ((nhds) b)) : Tendsto (fun c => (ma c, mb c)) f ((nhds) (a, b)) :=\n  by rw [nhds_prod_eq] <;> exact Filter.Tendsto.prod_mk ha hb\n#align filter.tendsto.prod_mk_nhds Filter.Tendsto.prod_mk_nhds\n-/\n\n",
 "prod_mk":
 "#print Continuous.prod_mk /-\n@[continuity]\ntheorem Continuous.prod_mk {f : Œ≥ ‚Üí Œ±} {g : Œ≥ ‚Üí Œ≤} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun x => (f x, g x) :=\n  continuous_inf_rng.2 ‚ü®continuous_induced_rng.2 hf, continuous_induced_rng.2 hg‚ü©\n#align continuous.prod_mk Continuous.prod_mk\n-/\n\n",
 "prod_mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print prod_mem_nhds_iff /-\ntheorem prod_mem_nhds_iff {s : Set Œ±} {t : Set Œ≤} {a : Œ±} {b : Œ≤} :\n    finset.product s t ‚àà (nhds) (a, b) ‚Üî s ‚àà (nhds) a ‚àß t ‚àà (nhds) b := by rw [nhds_prod_eq, prod_mem_prod_iff]\n#align prod_mem_nhds_iff prod_mem_nhds_iff\n-/\n\n",
 "prod_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print prod_mem_nhds /-\ntheorem prod_mem_nhds {s : Set Œ±} {t : Set Œ≤} {a : Œ±} {b : Œ≤} (ha : s ‚àà (nhds) a) (hb : t ‚àà (nhds) b) :\n    finset.product s t ‚àà (nhds) (a, b) :=\n  prod_mem_nhds_iff.2 ‚ü®ha, hb‚ü©\n#align prod_mem_nhds prod_mem_nhds\n-/\n\n",
 "prod_map'":
 "#print ContinuousAt.prod_map' /-\ntheorem ContinuousAt.prod_map' {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ¥} {x : Œ±} {y : Œ≤} (hf : ContinuousAt f x) (hg : ContinuousAt g y) :\n    ContinuousAt (fun p : Œ± √ó Œ≤ => (f p.1, g p.2)) (x, y) :=\n  hf.fst'.prod hg.snd'\n#align continuous_at.prod_map' ContinuousAt.prod_map'\n-/\n\n",
 "prod_map":
 "#print Embedding.prod_map /-\ntheorem Embedding.prod_map {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥} (hf : Embedding f) (hg : Embedding g) :\n    Embedding fun x : Œ± √ó Œ≥ => (f x.1, g x.2) :=\n  { hf.to_inducing.prod_mk hg.to_inducing with\n    inj := fun ‚ü®x‚ÇÅ, x‚ÇÇ‚ü© ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© => by simp <;> exact fun h‚ÇÅ h‚ÇÇ => ‚ü®hf.inj h‚ÇÅ, hg.inj h‚ÇÇ‚ü© }\n#align embedding.prod_mk Embedding.prod_map\n-/\n\n",
 "prod_inr_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Eventually.prod_inr_nhds /-\ntheorem Filter.Eventually.prod_inr_nhds {p : Œ≤ ‚Üí Prop} {b : Œ≤}\n    (h :\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" ((nhds) b)\n        (p x))\n    (a : Œ±) :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n      ((nhds) (a, b)) (p (x : Œ± √ó Œ≤).2) :=\n  continuousAt_snd h\n#align filter.eventually.prod_inr_nhds Filter.Eventually.prod_inr_nhds\n-/\n\n",
 "prod_inl_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Eventually.prod_inl_nhds /-\ntheorem Filter.Eventually.prod_inl_nhds {p : Œ± ‚Üí Prop} {a : Œ±}\n    (h :\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" ((nhds) a)\n        (p x))\n    (b : Œ≤) :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n      ((nhds) (a, b)) (p (x : Œ± √ó Œ≤).1) :=\n  continuousAt_fst h\n#align filter.eventually.prod_inl_nhds Filter.Eventually.prod_inl_nhds\n-/\n\n",
 "prod_induced_induced":
 "#print prod_induced_induced /-\n/-- A product of induced topologies is induced by the product map -/\ntheorem prod_induced_induced {Œ± Œ≥ : Type _} (f : Œ± ‚Üí Œ≤) (g : Œ≥ ‚Üí Œ¥) :\n    @prod.topological_space Œ± Œ≥ (induced f ‚Äπ_‚Ä∫) (induced g ‚Äπ_‚Ä∫) =\n      induced (fun p => (f p.1, g p.2)) prod.topological_space :=\n  by simp_rw [prod.topological_space, induced_inf, induced_compose]\n#align prod_induced_induced prod_induced_induced\n-/\n\n",
 "prod_generateFrom_generateFrom_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print prod_generateFrom_generateFrom_eq /-\ntheorem prod_generateFrom_generateFrom_eq {Œ± Œ≤ : Type _} {s : Set (Set Œ±)} {t : Set (Set Œ≤)} (hs : ‚ãÉ‚ÇÄ s = univ)\n    (ht : ‚ãÉ‚ÇÄ t = univ) :\n    @prod.topological_space Œ± Œ≤ (generateFrom s) (generateFrom t) =\n      generateFrom { g | ‚àÉ u ‚àà s, ‚àÉ v ‚àà t, g = finset.product u v } :=\n  let G := generateFrom { g | ‚àÉ u ‚àà s, ‚àÉ v ‚àà t, g = finset.product u v }\n  le_antisymm\n    (le_generateFrom fun g ‚ü®u, hu, v, hv, g_eq‚ü© =>\n      g_eq.symm ‚ñ∏\n        @IsOpen.prod _ _ (generateFrom s) (generateFrom t) _ _ (generate_open.basic _ hu) (generate_open.basic _ hv))\n    (le_inf\n      (coinduced_le_iff_le_induced.mp <|\n        le_generateFrom fun u hu =>\n          have :\n            ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\"\n                (finset.product u v) =\n              ¬´expr ‚Åª¬π' ¬ª Prod.fst u :=\n            by simp_rw [‚Üê prod_Union, ‚Üê sUnion_eq_bUnion, ht, prod_univ]\n          show G.is_open (¬´expr ‚Åª¬π' ¬ª Prod.fst u) by\n            rw [‚Üê this]\n            exact isOpen_union·µ¢ fun v => isOpen_union·µ¢ fun hv => generate_open.basic _ ‚ü®_, hu, _, hv, rfl‚ü©)\n      (coinduced_le_iff_le_induced.mp <|\n        le_generateFrom fun v hv =>\n          have :\n            ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\"\n                (finset.product u v) =\n              ¬´expr ‚Åª¬π' ¬ª Prod.snd v :=\n            by simp_rw [‚Üê Union_prod_const, ‚Üê sUnion_eq_bUnion, hs, univ_prod]\n          show G.is_open (¬´expr ‚Åª¬π' ¬ª Prod.snd v) by\n            rw [‚Üê this]\n            exact isOpen_union·µ¢ fun u => isOpen_union·µ¢ fun hu => generate_open.basic _ ‚ü®_, hu, _, hv, rfl‚ü©))\n#align prod_generate_from_generate_from_eq prod_generateFrom_generateFrom_eq\n-/\n\n",
 "prod_eq_generateFrom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print prod_eq_generateFrom /-\ntheorem prod_eq_generateFrom :\n    prod.topological_space =\n      generateFrom { g | ‚àÉ (s : Set Œ±)(t : Set Œ≤), IsOpen s ‚àß IsOpen t ‚àß g = finset.product s t } :=\n  le_antisymm (le_generateFrom fun g ‚ü®s, t, hs, ht, g_eq‚ü© => g_eq.symm ‚ñ∏ hs.prod ht)\n    (le_inf (ball_image_of_ball fun t ht => generate_open.basic _ ‚ü®t, univ, by simpa [Set.prod_eq] using ht‚ü©)\n      (ball_image_of_ball fun t ht => generate_open.basic _ ‚ü®univ, t, by simpa [Set.prod_eq] using ht‚ü©))\n#align prod_eq_generate_from prod_eq_generateFrom\n-/\n\n",
 "prod":
 "#print OpenEmbedding.prod /-\nprotected theorem OpenEmbedding.prod {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥} (hf : OpenEmbedding f) (hg : OpenEmbedding g) :\n    OpenEmbedding fun x : Œ± √ó Œ≥ => (f x.1, g x.2) :=\n  openEmbedding_of_embedding_open (hf.1.prod_mk hg.1) (hf.is_open_map.prod hg.is_open_map)\n#align open_embedding.prod OpenEmbedding.prod\n-/\n\n",
 "preimage_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Quotient.preimage_mem_nhds /-\ntheorem Quotient.preimage_mem_nhds [TopologicalSpace Œ±] [s : setoid Œ±] {V : Set <| quotient s} {a : Œ±}\n    (hs : V ‚àà (nhds) (Quotient.mk' a)) : ¬´expr ‚Åª¬π' ¬ª Quotient.mk' V ‚àà (nhds) a :=\n  preimage_nhds_coinduced hs\n#align quotient.preimage_mem_nhds Quotient.preimage_mem_nhds\n-/\n\n",
 "pi_generateFrom_eq_finite":
 "#print pi_generateFrom_eq_finite /-\ntheorem pi_generateFrom_eq_finite {œÄ : Œπ ‚Üí Type _} {g : ‚àÄ a, Set (Set (œÄ a))} [Finite Œπ] (hg : ‚àÄ a, ‚ãÉ‚ÇÄ g a = univ) :\n    (@Pi.topologicalSpace Œπ œÄ fun a => generateFrom (g a)) =\n      generateFrom { t | ‚àÉ s : ‚àÄ a, Set (œÄ a), (‚àÄ a, s a ‚àà g a) ‚àß t = pi univ s } :=\n  by\n  cases nonempty_fintype Œπ\n  rw [pi_generateFrom_eq]\n  refine' le_antisymm (generate_from_anti _) (le_generateFrom _)\n  ¬∑ rintro s ‚ü®t, ht, rfl‚ü©\n    exact ‚ü®t, Finset.univ, by simp [ht]‚ü©\n  ¬∑ rintro s ‚ü®t, i, ht, rfl‚ü©\n    apply isOpen_iff_forall_mem_open.2 _\n    intro f hf\n    choose c hc using\n      show ‚àÄ a, ‚àÉ s, s ‚àà g a ‚àß f a ‚àà s by\n        intro a\n        have : f a ‚àà ‚ãÉ‚ÇÄ g a := by\n          rw [hg]\n          apply mem_univ\n        simpa\n    refine' ‚ü®pi univ fun a => if a ‚àà i then t a else (c : ‚àÄ a, Set (œÄ a)) a, _, _, _‚ü©\n    ¬∑ simp [pi_if]\n    ¬∑ refine' generate_open.basic _ ‚ü®_, fun a => _, rfl‚ü©\n      by_cases a ‚àà i <;> simp_all [Set.pi]\n    ¬∑ have : f ‚àà pi { a | a ‚àâ i } c := by simp_all [Set.pi]\n      simpa [pi_if, hf]\n#align pi_generate_from_eq_finite pi_generateFrom_eq_finite\n-/\n\n",
 "pi_generateFrom_eq":
 "#print pi_generateFrom_eq /-\ntheorem pi_generateFrom_eq {œÄ : Œπ ‚Üí Type _} {g : ‚àÄ a, Set (Set (œÄ a))} :\n    (@Pi.topologicalSpace Œπ œÄ fun a => generateFrom (g a)) =\n      generateFrom { t | ‚àÉ (s : ‚àÄ a, Set (œÄ a))(i : Finset Œπ), (‚àÄ a ‚àà i, s a ‚àà g a) ‚àß t = pi (‚Üëi) s } :=\n  by\n  let G := { t | ‚àÉ (s : ‚àÄ a, Set (œÄ a))(i : Finset Œπ), (‚àÄ a ‚àà i, s a ‚àà g a) ‚àß t = pi (‚Üëi) s }\n  rw [pi_eq_generateFrom]\n  refine' le_antisymm (generate_from_anti _) (le_generateFrom _)\n  exact fun s ‚ü®t, i, ht, Eq‚ü© => ‚ü®t, i, fun a ha => generate_open.basic _ (ht a ha), Eq‚ü©\n  ¬∑ rintro s ‚ü®t, i, hi, rfl‚ü©\n    rw [pi_def]\n    apply isOpen_binter·µ¢ (Finset.finite_toSet _)\n    intro a ha\n    show ((generate_from G).coinduced fun f : ‚àÄ a, œÄ a => f a).is_open (t a)\n    refine' le_generateFrom _ _ (hi a ha)\n    exact fun s hs => generate_open.basic _ ‚ü®update (fun a => univ) a s, {a}, by simp [hs]‚ü©\n#align pi_generate_from_eq pi_generateFrom_eq\n-/\n\n",
 "pi_eq_generateFrom":
 "#print pi_eq_generateFrom /-\ntheorem pi_eq_generateFrom :\n    Pi.topologicalSpace =\n      generateFrom { g | ‚àÉ (s : ‚àÄ a, Set (œÄ a))(i : Finset Œπ), (‚àÄ a ‚àà i, IsOpen (s a)) ‚àß g = pi (‚Üëi) s } :=\n  le_antisymm (le_generateFrom fun g ‚ü®s, i, hi, Eq‚ü© => Eq.symm ‚ñ∏ isOpen_set_pi (Finset.finite_toSet _) hi)\n    (le_inf·µ¢ fun a s ‚ü®t, ht, s_eq‚ü© =>\n      generate_open.basic _ <| ‚ü®update (fun a => univ) a t, {a}, by simpa using ht, s_eq ‚ñ∏ by ext f <;> simp [Set.pi]‚ü©)\n#align pi_eq_generate_from pi_eq_generateFrom\n-/\n\n",
 "openEmbedding_subtype_val":
 "#print IsOpen.openEmbedding_subtype_val /-\ntheorem IsOpen.openEmbedding_subtype_val {s : Set Œ±} (hs : IsOpen s) : OpenEmbedding (coe : s ‚Üí Œ±) :=\n  { induced := rfl\n    inj := Subtype.coe_injective\n    open_range := (Subtype.range_coe : range coe = s).symm ‚ñ∏ hs }\n#align is_open.open_embedding_subtype_coe IsOpen.openEmbedding_subtype_val\n-/\n\n",
 "openEmbedding_sigma_map":
 "#print openEmbedding_sigma_map /-\ntheorem openEmbedding_sigma_map {f‚ÇÅ : Œπ ‚Üí Œ∫} {f‚ÇÇ : ‚àÄ i, œÉ i ‚Üí œÑ (f‚ÇÅ i)} (h : injective f‚ÇÅ) :\n    OpenEmbedding (Sigma.map f‚ÇÅ f‚ÇÇ) ‚Üî ‚àÄ i, OpenEmbedding (f‚ÇÇ i) := by\n  simp only [openEmbedding_iff_embedding_open, isOpenMap_sigma_map, embedding_sigma_map h, forall_and]\n#align open_embedding_sigma_map openEmbedding_sigma_map\n-/\n\n",
 "openEmbedding_sigmaMk":
 "#print openEmbedding_sigmaMk /-\ntheorem openEmbedding_sigmaMk {i : Œπ} : OpenEmbedding (@sigma.mk Œπ œÉ i) :=\n  openEmbedding_of_continuous_injective_open continuous_sigmaMk sigma_mk_injective isOpenMap_sigmaMk\n#align open_embedding_sigma_mk openEmbedding_sigmaMk\n-/\n\n",
 "openEmbedding_inr":
 "#print openEmbedding_inr /-\ntheorem openEmbedding_inr : OpenEmbedding (@inr Œ± Œ≤) :=\n  openEmbedding_of_continuous_injective_open continuous_inr inr_injective isOpenMap_inr\n#align open_embedding_inr openEmbedding_inr\n-/\n\n",
 "openEmbedding_inl":
 "#print openEmbedding_inl /-\ntheorem openEmbedding_inl : OpenEmbedding (@inl Œ± Œ≤) :=\n  openEmbedding_of_continuous_injective_open continuous_inl inl_injective isOpenMap_inl\n#align open_embedding_inl openEmbedding_inl\n-/\n\n",
 "of_subset":
 "#print DiscreteTopology.of_subset /-\n/-- Let `s, t ‚äÜ X` be two subsets of a topological space `X`.  If `t ‚äÜ s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  -/\ntheorem DiscreteTopology.of_subset {X : Type _} [TopologicalSpace X] {s t : Set X} (ds : DiscreteTopology s)\n    (ts : t ‚äÜ s) : DiscreteTopology t :=\n  (embedding_inclusion ts).discrete_topology\n#align discrete_topology.of_subset DiscreteTopology.of_subset\n-/\n\n",
 "of_codRestrict":
 "#print Inducing.of_codRestrict /-\ntheorem Inducing.of_codRestrict {f : Œ± ‚Üí Œ≤} {b : Set Œ≤} (hb : ‚àÄ a, f a ‚àà b) (h : Inducing (b.cod_restrict f hb)) :\n    Inducing f :=\n  inducing_subtype_val.comp h\n#align inducing.of_cod_restrict Inducing.of_codRestrict\n-/\n\n",
 "nhds_toMul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_toMul /-\ntheorem nhds_toMul (a : Additive Œ±) : (nhds) (toMul a) = map toMul ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_to_mul nhds_toMul\n-/\n\n",
 "nhds_toDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_toDual /-\ntheorem nhds_toDual (a : Œ±) : (nhds) (toDual a) = map toDual ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_to_dual nhds_toDual\n-/\n\n",
 "nhds_toAdd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_toAdd /-\ntheorem nhds_toAdd (a : Multiplicative Œ±) : (nhds) (toAdd a) = map toAdd ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_to_add nhds_toAdd\n-/\n\n",
 "nhds_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_swap /-\ntheorem nhds_swap (a : Œ±) (b : Œ≤) : (nhds) (a, b) = ((nhds) (b, a)).map Prod.swap := by\n  rw [nhds_prod_eq, Filter.prod_comm, nhds_prod_eq] <;> rfl\n#align nhds_swap nhds_swap\n-/\n\n",
 "nhds_subtype_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_subtype_eq_comap /-\ntheorem nhds_subtype_eq_comap {a : Œ±} {h : p a} : (nhds) (‚ü®a, h‚ü© : Subtype p) = comap coe ((nhds) a) :=\n  nhds_induced _ _\n#align nhds_subtype_eq_comap nhds_subtype_eq_comap\n-/\n\n",
 "nhds_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_subtype /-\ntheorem nhds_subtype (s : Set Œ±) (a : { x // x ‚àà s }) : (nhds) a = comap coe ((nhds) (a : Œ±)) :=\n  nhds_induced coe a\n#align nhds_subtype nhds_subtype\n-/\n\n",
 "nhds_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_prod_eq /-\ntheorem nhds_prod_eq {a : Œ±} {b : Œ≤} : (nhds) (a, b) = filter.prod ((nhds) a) ((nhds) b) := by\n  rw [Filter.prod, prod.topological_space, nhds_inf, nhds_induced, nhds_induced]\n#align nhds_prod_eq nhds_prod_eq\n-/\n\n",
 "nhds_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_pi /-\ntheorem nhds_pi {a : ‚àÄ i, œÄ i} : (nhds) a = pi fun i => (nhds) (a i) := by\n  simp only [nhds_inf·µ¢, nhds_induced, Filter.pi]\n#align nhds_pi nhds_pi\n-/\n\n",
 "nhds_ofMul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_ofMul /-\ntheorem nhds_ofMul (a : Œ±) : (nhds) (ofMul a) = map ofMul ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_of_mul nhds_ofMul\n-/\n\n",
 "nhds_ofDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_ofDual /-\ntheorem nhds_ofDual (a : Œ±) : (nhds) (ofDual a) = map ofDual ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_of_dual nhds_ofDual\n-/\n\n",
 "nhds_ofAdd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_ofAdd /-\ntheorem nhds_ofAdd (a : Œ±) : (nhds) (ofAdd a) = map ofAdd ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_of_add nhds_ofAdd\n-/\n\n",
 "nhds_ne_subtype_neBot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print nhds_ne_subtype_neBot_iff /-\ntheorem nhds_ne_subtype_neBot_iff {S : Set Œ±} {x : S} :\n    (nhds_within (¬´expr ·∂ú¬ª {x}) x).ne_bot ‚Üî\n      (¬´expr ‚äì ¬ª (nhds_within (¬´expr ·∂ú¬ª {x}) (x : Œ±)) ((filter.principal) S)).ne_bot :=\n  by rw [ne_bot_iff, ne_bot_iff, not_iff_not, nhds_ne_subtype_eq_bot_iff]\n#align nhds_ne_subtype_ne_bot_iff nhds_ne_subtype_neBot_iff\n-/\n\n",
 "nhds_ne_subtype_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä•¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä•¬ª -/\n#print nhds_ne_subtype_eq_bot_iff /-\ntheorem nhds_ne_subtype_eq_bot_iff {S : Set Œ±} {x : S} :\n    nhds_within (¬´expr ·∂ú¬ª {x}) x = ¬´expr‚ä•¬ª ‚Üî\n      ¬´expr ‚äì ¬ª (nhds_within (¬´expr ·∂ú¬ª {x}) (x : Œ±)) ((filter.principal) S) = ¬´expr‚ä•¬ª :=\n  by rw [‚Üê nhdsWithin_subtype_eq_bot_iff, preimage_compl, ‚Üê image_singleton, subtype.coe_injective.preimage_image]\n#align nhds_ne_subtype_eq_bot_iff nhds_ne_subtype_eq_bot_iff\n-/\n\n",
 "nhds_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Sigma.nhds_mk /-\ntheorem Sigma.nhds_mk (i : Œπ) (x : œÉ i) : (nhds) (‚ü®i, x‚ü© : Sigma œÉ) = map (sigma.mk i) ((nhds) x) :=\n  (openEmbedding_sigmaMk.map_nhds_eq x).symm\n#align sigma.nhds_mk Sigma.nhds_mk\n-/\n\n",
 "nhds_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_inr /-\ntheorem nhds_inr (x : Œ≤) : (nhds) (inr x : Sum Œ± Œ≤) = map inr ((nhds) x) :=\n  (openEmbedding_inr.map_nhds_eq _).symm\n#align nhds_inr nhds_inr\n-/\n\n",
 "nhds_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_inl /-\ntheorem nhds_inl (x : Œ±) : (nhds) (inl x : Sum Œ± Œ≤) = map inl ((nhds) x) :=\n  (openEmbedding_inl.map_nhds_eq _).symm\n#align nhds_inl nhds_inl\n-/\n\n",
 "nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Sigma.nhds_eq /-\ntheorem Sigma.nhds_eq (x : Sigma œÉ) : (nhds) x = map (sigma.mk x.1) ((nhds) x.2) :=\n  by\n  cases x\n  apply Sigma.nhds_mk\n#align sigma.nhds_eq Sigma.nhds_eq\n-/\n\n",
 "nhdsWithin_subtype_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä•¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä•¬ª -/\n#print nhdsWithin_subtype_eq_bot_iff /-\ntheorem nhdsWithin_subtype_eq_bot_iff {s t : Set Œ±} {x : s} :\n    nhds_within (¬´expr ‚Åª¬π' ¬ª (coe : s ‚Üí Œ±) t) x = ¬´expr‚ä•¬ª ‚Üî\n      ¬´expr ‚äì ¬ª (nhds_within t (x : Œ±)) ((filter.principal) s) = ¬´expr‚ä•¬ª :=\n  by rw [inf_principal_eq_bot_iff_comap, nhdsWithin, nhdsWithin, comap_inf, comap_principal, nhds_induced]\n#align nhds_within_subtype_eq_bot_iff nhdsWithin_subtype_eq_bot_iff\n-/\n\n",
 "mk_left":
 "#print Continuous.Prod.mk_left /-\n@[continuity]\ntheorem Continuous.Prod.mk_left (b : Œ≤) : Continuous fun a : Œ± => (a, b) :=\n  continuous_id'.prod_mk continuous_const\n#align continuous.prod.mk_left Continuous.Prod.mk_left\n-/\n\n",
 "mk":
 "#print Continuous.Prod.mk /-\n@[continuity]\ntheorem Continuous.Prod.mk (a : Œ±) : Continuous fun b : Œ≤ => (a, b) :=\n  continuous_const.prod_mk continuous_id'\n#align continuous.prod.mk Continuous.Prod.mk\n-/\n\n",
 "mem_nhds_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n#print mem_nhds_subtype /-\n/-\nThe ùìù filter and the subspace topology.\n-/\ntheorem mem_nhds_subtype (s : Set Œ±) (a : { x // x ‚àà s }) (t : Set { x // x ‚àà s }) :\n    t ‚àà (nhds) a ‚Üî ‚àÉ u ‚àà (nhds) (a : Œ±), ¬´expr ‚Åª¬π' ¬ª coe u ‚äÜ t :=\n  mem_nhds_induced coe a t\n#align mem_nhds_subtype mem_nhds_subtype\n-/\n\n",
 "mem_nhds_prod_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print mem_nhds_prod_iff' /-\ntheorem mem_nhds_prod_iff' {a : Œ±} {b : Œ≤} {s : Set (Œ± √ó Œ≤)} :\n    s ‚àà (nhds) (a, b) ‚Üî ‚àÉ (u : Set Œ±)(v : Set Œ≤), IsOpen u ‚àß a ‚àà u ‚àß IsOpen v ‚àß b ‚àà v ‚àß finset.product u v ‚äÜ s :=\n  by\n  rw [mem_nhds_prod_iff]\n  constructor\n  ¬∑ rintro ‚ü®u, Hu, v, Hv, h‚ü©\n    rcases mem_nhds_iff.1 Hu with ‚ü®u', u'u, u'_open, Hu'‚ü©\n    rcases mem_nhds_iff.1 Hv with ‚ü®v', v'v, v'_open, Hv'‚ü©\n    exact ‚ü®u', v', u'_open, Hu', v'_open, Hv', (Set.prod_mono u'u v'v).trans h‚ü©\n  ¬∑ rintro ‚ü®u, v, u_open, au, v_open, bv, huv‚ü©\n    exact ‚ü®u, u_open.mem_nhds au, v, v_open.mem_nhds bv, huv‚ü©\n#align mem_nhds_prod_iff' mem_nhds_prod_iff'\n-/\n\n",
 "mem_nhds_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print mem_nhds_prod_iff /-\ntheorem mem_nhds_prod_iff {a : Œ±} {b : Œ≤} {s : Set (Œ± √ó Œ≤)} :\n    s ‚àà (nhds) (a, b) ‚Üî ‚àÉ u ‚àà (nhds) a, ‚àÉ v ‚àà (nhds) b, finset.product u v ‚äÜ s := by rw [nhds_prod_eq, mem_prod_iff]\n#align mem_nhds_prod_iff mem_nhds_prod_iff\n-/\n\n",
 "mem_nhds_of_pi_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_nhds_of_pi_mem_nhds /-\ntheorem mem_nhds_of_pi_mem_nhds {I : Set Œπ} {s : ‚àÄ i, Set (œÄ i)} (a : ‚àÄ i, œÄ i) (hs : I.pi s ‚àà (nhds) a) {i : Œπ}\n    (hi : i ‚àà I) : s i ‚àà (nhds) (a i) := by\n  rw [nhds_pi] at hs\n  exact mem_of_pi_mem_pi hs hi\n#align mem_nhds_of_pi_mem_nhds mem_nhds_of_pi_mem_nhds\n-/\n\n",
 "mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem mem_nhds_iff {a : CofiniteTopology Œ±} {s : Set (CofiniteTopology Œ±)} :\n    s ‚àà (nhds) a ‚Üî a ‚àà s ‚àß (¬´expr ·∂ú¬ª s).finite := by simp [nhds_eq]\n#align mem_nhds_iff mem_nhds_iff‚Çì\n\n",
 "map_snd_nhdsWithin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print map_snd_nhdsWithin /-\n/-- `prod.snd` maps neighborhood of `x : Œ± √ó Œ≤` within the section `prod.fst ‚Åª¬π' {x.1}`\nto `ùìù x.2`. -/\ntheorem map_snd_nhdsWithin (x : Œ± √ó Œ≤) : map Prod.snd (nhds_within (¬´expr ‚Åª¬π' ¬ª Prod.fst {x.1}) x) = (nhds) x.2 :=\n  by\n  refine' le_antisymm (continuous_at_snd.mono_left inf_le_left) fun s hs => _\n  rcases x with ‚ü®x, y‚ü©\n  rw [mem_map, nhdsWithin, mem_inf_principal, mem_nhds_prod_iff] at hs\n  rcases hs with ‚ü®u, hu, v, hv, H‚ü©\n  simp only [prod_subset_iff, mem_singleton_iff, mem_set_of_eq, mem_preimage] at H\n  exact mem_of_superset hv fun z hz => H _ (mem_of_mem_nhds hu) _ hz rfl\n#align map_snd_nhds_within map_snd_nhdsWithin\n-/\n\n",
 "map_snd_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print map_snd_nhds /-\n@[simp]\ntheorem map_snd_nhds (x : Œ± √ó Œ≤) : map Prod.snd ((nhds) x) = (nhds) x.2 :=\n  le_antisymm continuousAt_snd <| (map_snd_nhdsWithin x).symm.trans_le (map_mono inf_le_left)\n#align map_snd_nhds map_snd_nhds\n-/\n\n",
 "map_nhds_subtype_coe_eq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print map_nhds_subtype_coe_eq_nhds /-\ntheorem map_nhds_subtype_coe_eq_nhds {a : Œ±} (ha : p a) (h : { a | p a } ‚àà (nhds) a) :\n    map (coe : Subtype p ‚Üí Œ±) ((nhds) ‚ü®a, ha‚ü©) = (nhds) a :=\n  map_nhds_induced_of_mem <| by simpa only [Subtype.coe_mk, Subtype.range_coe] using h\n#align map_nhds_subtype_coe_eq map_nhds_subtype_coe_eq_nhds\n-/\n\n",
 "map_mem_closure‚ÇÇ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print map_mem_closure‚ÇÇ /-\ntheorem map_mem_closure‚ÇÇ {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {a : Œ±} {b : Œ≤} {s : Set Œ±} {t : Set Œ≤} {u : Set Œ≥}\n    (hf : Continuous (uncurry f)) (ha : a ‚àà closure s) (hb : b ‚àà closure t) (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b ‚àà u) :\n    f a b ‚àà closure u :=\n  have H‚ÇÅ : (a, b) ‚àà closure (finset.product s t) := by simpa only [closure_prod_eq] using mk_mem_prod ha hb\n  have H‚ÇÇ : MapsTo (uncurry f) (finset.product s t) u := forall_prod_set.2 h\n  H‚ÇÇ.closure hf H‚ÇÅ\n#align map_mem_closure‚ÇÇ map_mem_closure‚ÇÇ\n-/\n\n",
 "map_fst_nhdsWithin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print map_fst_nhdsWithin /-\n/-- `prod.fst` maps neighborhood of `x : Œ± √ó Œ≤` within the section `prod.snd ‚Åª¬π' {x.2}`\nto `ùìù x.1`. -/\ntheorem map_fst_nhdsWithin (x : Œ± √ó Œ≤) : map Prod.fst (nhds_within (¬´expr ‚Åª¬π' ¬ª Prod.snd {x.2}) x) = (nhds) x.1 :=\n  by\n  refine' le_antisymm (continuous_at_fst.mono_left inf_le_left) fun s hs => _\n  rcases x with ‚ü®x, y‚ü©\n  rw [mem_map, nhdsWithin, mem_inf_principal, mem_nhds_prod_iff] at hs\n  rcases hs with ‚ü®u, hu, v, hv, H‚ü©\n  simp only [prod_subset_iff, mem_singleton_iff, mem_set_of_eq, mem_preimage] at H\n  exact mem_of_superset hu fun z hz => H _ hz _ (mem_of_mem_nhds hv) rfl\n#align map_fst_nhds_within map_fst_nhdsWithin\n-/\n\n",
 "map_fst_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print map_fst_nhds /-\n@[simp]\ntheorem map_fst_nhds (x : Œ± √ó Œ≤) : map Prod.fst ((nhds) x) = (nhds) x.1 :=\n  le_antisymm continuousAt_fst <| (map_fst_nhdsWithin x).symm.trans_le (map_mono inf_le_left)\n#align map_fst_nhds map_fst_nhds\n-/\n\n",
 "is_open_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem is_open_iff' {s : Set (CofiniteTopology Œ±)} : IsOpen s ‚Üî s = ‚àÖ ‚à® (¬´expr ·∂ú¬ª s).finite := by\n  simp only [is_open_iff, nonempty_iff_ne_empty, or_iff_not_imp_left]\n#align is_open_iff' is_open_iff'\n\n",
 "is_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem is_open_iff {s : Set (CofiniteTopology Œ±)} : IsOpen s ‚Üî s.nonempty ‚Üí (¬´expr ·∂ú¬ª s).finite :=\n  iff.rfl\n#align is_open_iff is_open_iff\n\n",
 "is_closed_iff":
 "theorem is_closed_iff {s : Set (CofiniteTopology Œ±)} : IsClosed s ‚Üî s = univ ‚à® s.finite := by\n  simp [‚Üê isOpen_compl_iff, is_open_iff']\n#align is_closed_iff is_closed_iff\n\n",
 "isOpen_sum_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n#print isOpen_sum_iff /-\ntheorem isOpen_sum_iff {s : Set (Sum Œ± Œ≤)} : IsOpen s ‚Üî IsOpen (¬´expr ‚Åª¬π' ¬ª inl s) ‚àß IsOpen (¬´expr ‚Åª¬π' ¬ª inr s) :=\n  iff.rfl\n#align is_open_sum_iff isOpen_sum_iff\n-/\n\n",
 "isOpen_sigma_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n#print isOpen_sigma_iff /-\ntheorem isOpen_sigma_iff {s : Set (Sigma œÉ)} : IsOpen s ‚Üî ‚àÄ i, IsOpen (¬´expr ‚Åª¬π' ¬ª (sigma.mk i) s) := by\n  simp only [isOpen_sup·µ¢_iff, isOpen_coinduced]\n#align is_open_sigma_iff isOpen_sigma_iff\n-/\n\n",
 "isOpen_sigma_fst_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n#print isOpen_sigma_fst_preimage /-\ntheorem isOpen_sigma_fst_preimage (s : Set Œπ) : IsOpen (¬´expr ‚Åª¬π' ¬ª Sigma.fst s : Set (Œ£a, œÉ a)) :=\n  by\n  rw [‚Üê bUnion_of_singleton s, preimage_Union‚ÇÇ]\n  simp only [‚Üê range_sigma_mk]\n  exact isOpen_bunion·µ¢ fun _ _ => isOpen_range_sigmaMk\n#align is_open_sigma_fst_preimage isOpen_sigma_fst_preimage\n-/\n\n",
 "isOpen_set_pi":
 "#print isOpen_set_pi /-\ntheorem isOpen_set_pi {i : Set Œπ} {s : ‚àÄ a, Set (œÄ a)} (hi : i.finite) (hs : ‚àÄ a ‚àà i, IsOpen (s a)) : IsOpen (pi i s) :=\n  by rw [pi_def] <;> exact isOpen_binter·µ¢ hi fun a ha => (hs _ ha).preimage (continuous_apply _)\n#align is_open_set_pi isOpen_set_pi\n-/\n\n",
 "isOpen_range_sigmaMk":
 "#print isOpen_range_sigmaMk /-\ntheorem isOpen_range_sigmaMk {i : Œπ} : IsOpen (Set.range (@sigma.mk Œπ œÉ i)) :=\n  isOpenMap_sigmaMk.is_open_range\n#align is_open_range_sigma_mk isOpen_range_sigmaMk\n-/\n\n",
 "isOpen_range_inr":
 "#print isOpen_range_inr /-\ntheorem isOpen_range_inr : IsOpen (range (inr : Œ≤ ‚Üí Sum Œ± Œ≤)) :=\n  openEmbedding_inr.2\n#align is_open_range_inr isOpen_range_inr\n-/\n\n",
 "isOpen_range_inl":
 "#print isOpen_range_inl /-\ntheorem isOpen_range_inl : IsOpen (range (inl : Œ± ‚Üí Sum Œ± Œ≤)) :=\n  openEmbedding_inl.2\n#align is_open_range_inl isOpen_range_inl\n-/\n\n",
 "isOpen_prod_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print isOpen_prod_iff' /-\n/-- A product set is open in a product space if and only if each factor is open, or one of them is\nempty -/\ntheorem isOpen_prod_iff' {s : Set Œ±} {t : Set Œ≤} : IsOpen (finset.product s t) ‚Üî IsOpen s ‚àß IsOpen t ‚à® s = ‚àÖ ‚à® t = ‚àÖ :=\n  by\n  cases' (finset.product s t).eq_empty_or_nonempty with h h\n  ¬∑ simp [h, prod_eq_empty_iff.1 h]\n  ¬∑ have st : s.nonempty ‚àß t.nonempty := prod_nonempty_iff.1 h\n    constructor\n    ¬∑ intro (H : IsOpen (finset.product s t))\n      refine' or.inl ‚ü®_, _‚ü©\n      show IsOpen s\n      ¬∑ rw [‚Üê fst_image_prod s st.2]\n        exact isOpenMap_fst _ H\n      show IsOpen t\n      ¬∑ rw [‚Üê snd_image_prod st.1 t]\n        exact isOpenMap_snd _ H\n    ¬∑ intro H\n      simp only [st.1.ne_empty, st.2.ne_empty, not_false_iff, or_false_iff] at H\n      exact H.1.prod H.2\n#align is_open_prod_iff' isOpen_prod_iff'\n-/\n\n",
 "isOpen_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print isOpen_prod_iff /-\ntheorem isOpen_prod_iff {s : Set (Œ± √ó Œ≤)} :\n    IsOpen s ‚Üî\n      ‚àÄ a b, (a, b) ‚àà s ‚Üí ‚àÉ (u : Set Œ±)(v : Set Œ≤), IsOpen u ‚àß IsOpen v ‚àß a ‚àà u ‚àß b ‚àà v ‚àß finset.product u v ‚äÜ s :=\n  by\n  rw [isOpen_iff_nhds]\n  simp_rw [le_principal_iff, Prod.forall, ((nhds_basis_opens _).prod_nhds (nhds_basis_opens _)).mem_iff, Prod.exists,\n    exists_prop]\n  simp only [and_assoc', and_left_comm]\n#align is_open_prod_iff isOpen_prod_iff\n-/\n\n",
 "isOpen_pi_iff'":
 "#print isOpen_pi_iff' /-\ntheorem isOpen_pi_iff' [Finite Œπ] {s : Set (‚àÄ a, œÄ a)} :\n    IsOpen s ‚Üî ‚àÄ f, f ‚àà s ‚Üí ‚àÉ u : ‚àÄ a, Set (œÄ a), (‚àÄ a, IsOpen (u a) ‚àß f a ‚àà u a) ‚àß Set.univ.pi u ‚äÜ s :=\n  by\n  cases nonempty_fintype Œπ\n  rw [isOpen_iff_nhds]\n  simp_rw [le_principal_iff, nhds_pi, Filter.mem_pi', mem_nhds_iff, exists_prop]\n  refine' ball_congr fun a h => ‚ü®_, _‚ü©\n  ¬∑ rintro ‚ü®I, t, ‚ü®h1, h2‚ü©‚ü©\n    refine'\n      ‚ü®fun i => (h1 i).some,\n        ‚ü®fun i => (h1 i).some_spec.2, (Set.pi_mono fun i _ => (h1 i).some_spec.1).trans (subset.trans _ h2)‚ü©‚ü©\n    rw [‚Üê Set.pi_inter_compl (I : Set Œπ)]\n    exact inter_subset_left _ _\n  ¬∑ exact fun ‚ü®u, ‚ü®h1, _‚ü©‚ü© => ‚ü®Finset.univ, u, ‚ü®fun i => ‚ü®u i, ‚ü®rfl.subset, h1 i‚ü©‚ü©, by rwa [Finset.coe_univ]‚ü©‚ü©\n#align is_open_pi_iff' isOpen_pi_iff'\n-/\n\n",
 "isOpen_pi_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n#print isOpen_pi_iff /-\ntheorem isOpen_pi_iff {s : Set (‚àÄ a, œÄ a)} :\n    IsOpen s ‚Üî\n      ‚àÄ f,\n        f ‚àà s ‚Üí ‚àÉ (I : Finset Œπ)(u : ‚àÄ a, Set (œÄ a)), (‚àÄ a, a ‚àà I ‚Üí IsOpen (u a) ‚àß f a ‚àà u a) ‚àß (I : Set Œπ).pi u ‚äÜ s :=\n  by\n  rw [isOpen_iff_nhds]\n  simp_rw [le_principal_iff, nhds_pi, Filter.mem_pi', mem_nhds_iff, exists_prop]\n  refine' ball_congr fun a h => ‚ü®_, _‚ü©\n  ¬∑ rintro ‚ü®I, t, ‚ü®h1, h2‚ü©‚ü©\n    refine' ‚ü®I, fun a => ¬´expr '' ¬ª (eval a) ((I : Set Œπ).pi fun a => (h1 a).some), fun i hi => _, _‚ü©\n    ¬∑ simp_rw [Set.eval_image_pi (finset.mem_coe.mpr hi)\n          (pi_nonempty_iff.mpr fun i => ‚ü®_, fun _ => (h1 i).some_spec.2.2‚ü©)]\n      exact (h1 i).some_spec.2\n    ¬∑ refine' subset.trans (Set.pi_mono fun i hi => (Set.eval_image_pi_subset hi).trans (h1 i).some_spec.1) h2\n  ¬∑ rintro ‚ü®I, t, ‚ü®h1, h2‚ü©‚ü©\n    refine' ‚ü®I, fun a => ite (a ‚àà I) (t a) Set.univ, fun i => _, _‚ü©\n    ¬∑ by_cases hi : i ‚àà I\n      ¬∑ use t i\n        rw [if_pos hi]\n        exact ‚ü®subset.rfl, (h1 i) hi‚ü©\n      ¬∑ use Set.univ\n        rw [if_neg hi]\n        exact ‚ü®subset.rfl, isOpen_univ, mem_univ _‚ü©\n    ¬∑ rw [‚Üê Set.univ_pi_ite]\n      simp only [‚Üê ite_and, ‚Üê Finset.mem_coe, and_self_iff, Set.univ_pi_ite, h2]\n#align is_open_pi_iff isOpen_pi_iff\n-/\n\n",
 "isOpenMap_toMul":
 "#print isOpenMap_toMul /-\ntheorem isOpenMap_toMul : IsOpenMap (toMul : Additive Œ± ‚Üí Œ±) :=\n  IsOpenMap.id\n#align is_open_map_to_mul isOpenMap_toMul\n-/\n\n",
 "isOpenMap_toDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µà¬ª -/\n#print isOpenMap_toDual /-\ntheorem isOpenMap_toDual : IsOpenMap (toDual : Œ± ‚Üí ¬´expr ·µí·µà¬ª Œ±) :=\n  IsOpenMap.id\n#align is_open_map_to_dual isOpenMap_toDual\n-/\n\n",
 "isOpenMap_toAdd":
 "#print isOpenMap_toAdd /-\ntheorem isOpenMap_toAdd : IsOpenMap (toAdd : Multiplicative Œ± ‚Üí Œ±) :=\n  IsOpenMap.id\n#align is_open_map_to_add isOpenMap_toAdd\n-/\n\n",
 "isOpenMap_sum_elim":
 "#print isOpenMap_sum_elim /-\n@[simp]\ntheorem isOpenMap_sum_elim {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≥} : IsOpenMap (Sum.elim f g) ‚Üî IsOpenMap f ‚àß IsOpenMap g := by\n  simp only [isOpenMap_sum, elim_inl, elim_inr]\n#align is_open_map_sum_elim isOpenMap_sum_elim\n-/\n\n",
 "isOpenMap_sum":
 "#print isOpenMap_sum /-\ntheorem isOpenMap_sum {f : Sum Œ± Œ≤ ‚Üí Œ≥} : IsOpenMap f ‚Üî (IsOpenMap fun a => f (inl a)) ‚àß IsOpenMap fun b => f (inr b) :=\n  by simp only [isOpenMap_iff_nhds_le, Sum.forall, nhds_inl, nhds_inr, Filter.map_map]\n#align is_open_map_sum isOpenMap_sum\n-/\n\n",
 "isOpenMap_subtype_val":
 "#print IsOpen.isOpenMap_subtype_val /-\ntheorem IsOpen.isOpenMap_subtype_val {s : Set Œ±} (hs : IsOpen s) : IsOpenMap (coe : s ‚Üí Œ±) :=\n  hs.open_embedding_subtype_coe.is_open_map\n#align is_open.is_open_map_subtype_coe IsOpen.isOpenMap_subtype_val\n-/\n\n",
 "isOpenMap_snd":
 "#print isOpenMap_snd /-\n/-- The second projection in a product of topological spaces sends open sets to open sets. -/\ntheorem isOpenMap_snd : IsOpenMap (@Prod.snd Œ± Œ≤) :=\n  isOpenMap_iff_nhds_le.2 fun x => (map_snd_nhds x).ge\n#align is_open_map_snd isOpenMap_snd\n-/\n\n",
 "isOpenMap_sigma_map":
 "#print isOpenMap_sigma_map /-\ntheorem isOpenMap_sigma_map {f‚ÇÅ : Œπ ‚Üí Œ∫} {f‚ÇÇ : ‚àÄ i, œÉ i ‚Üí œÑ (f‚ÇÅ i)} :\n    IsOpenMap (Sigma.map f‚ÇÅ f‚ÇÇ) ‚Üî ‚àÄ i, IsOpenMap (f‚ÇÇ i) :=\n  isOpenMap_sigma.trans <| forall_congr' fun i => (@openEmbedding_sigmaMk _ _ _ (f‚ÇÅ i)).is_open_map_iff.symm\n#align is_open_map_sigma_map isOpenMap_sigma_map\n-/\n\n",
 "isOpenMap_sigmaMk":
 "#print isOpenMap_sigmaMk /-\ntheorem isOpenMap_sigmaMk {i : Œπ} : IsOpenMap (@sigma.mk Œπ œÉ i) :=\n  by\n  intro s hs\n  rw [isOpen_sigma_iff]\n  intro j\n  rcases eq_or_ne j i with (rfl | hne)\n  ¬∑ rwa [Set.preimage_image_eq _ sigma_mk_injective]\n  ¬∑ rw [preimage_image_sigma_mk_of_ne hne]\n    exact isOpen_empty\n#align is_open_map_sigma_mk isOpenMap_sigmaMk\n-/\n\n",
 "isOpenMap_sigma":
 "#print isOpenMap_sigma /-\ntheorem isOpenMap_sigma {f : Sigma œÉ ‚Üí Œ±} : IsOpenMap f ‚Üî ‚àÄ i, IsOpenMap fun a => f ‚ü®i, a‚ü© := by\n  simp only [isOpenMap_iff_nhds_le, Sigma.forall, Sigma.nhds_eq, map_map]\n#align is_open_map_sigma isOpenMap_sigma\n-/\n\n",
 "isOpenMap_ofMul":
 "#print isOpenMap_ofMul /-\ntheorem isOpenMap_ofMul : IsOpenMap (ofMul : Œ± ‚Üí Additive Œ±) :=\n  IsOpenMap.id\n#align is_open_map_of_mul isOpenMap_ofMul\n-/\n\n",
 "isOpenMap_ofDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µà¬ª -/\n#print isOpenMap_ofDual /-\ntheorem isOpenMap_ofDual : IsOpenMap (ofDual : ¬´expr ·µí·µà¬ª Œ± ‚Üí Œ±) :=\n  IsOpenMap.id\n#align is_open_map_of_dual isOpenMap_ofDual\n-/\n\n",
 "isOpenMap_ofAdd":
 "#print isOpenMap_ofAdd /-\ntheorem isOpenMap_ofAdd : IsOpenMap (ofAdd : Œ± ‚Üí Multiplicative Œ±) :=\n  IsOpenMap.id\n#align is_open_map_of_add isOpenMap_ofAdd\n-/\n\n",
 "isOpenMap_inr":
 "#print isOpenMap_inr /-\ntheorem isOpenMap_inr : IsOpenMap (@inr Œ± Œ≤) := fun u hu => by\n  simpa [isOpen_sum_iff, preimage_image_eq u Sum.inr_injective]\n#align is_open_map_inr isOpenMap_inr\n-/\n\n",
 "isOpenMap_inl":
 "#print isOpenMap_inl /-\ntheorem isOpenMap_inl : IsOpenMap (@inl Œ± Œ≤) := fun u hu => by\n  simpa [isOpen_sum_iff, preimage_image_eq u Sum.inl_injective]\n#align is_open_map_inl isOpenMap_inl\n-/\n\n",
 "isOpenMap_fst":
 "#print isOpenMap_fst /-\n/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem isOpenMap_fst : IsOpenMap (@Prod.fst Œ± Œ≤) :=\n  isOpenMap_iff_nhds_le.2 fun x => (map_fst_nhds x).ge\n#align is_open_map_fst isOpenMap_fst\n-/\n\n",
 "isClosed_sigma_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n#print isClosed_sigma_iff /-\ntheorem isClosed_sigma_iff {s : Set (Sigma œÉ)} : IsClosed s ‚Üî ‚àÄ i, IsClosed (¬´expr ‚Åª¬π' ¬ª (sigma.mk i) s) := by\n  simp only [‚Üê isOpen_compl_iff, isOpen_sigma_iff, preimage_compl]\n#align is_closed_sigma_iff isClosed_sigma_iff\n-/\n\n",
 "isClosed_set_pi":
 "#print isClosed_set_pi /-\ntheorem isClosed_set_pi {i : Set Œπ} {s : ‚àÄ a, Set (œÄ a)} (hs : ‚àÄ a ‚àà i, IsClosed (s a)) : IsClosed (pi i s) := by\n  rw [pi_def] <;> exact isClosed_inter·µ¢ fun a => isClosed_inter·µ¢ fun ha => (hs _ ha).preimage (continuous_apply _)\n#align is_closed_set_pi isClosed_set_pi\n-/\n\n",
 "isClosed_range_sigmaMk":
 "#print isClosed_range_sigmaMk /-\ntheorem isClosed_range_sigmaMk {i : Œπ} : IsClosed (Set.range (@sigma.mk Œπ œÉ i)) :=\n  isClosedMap_sigmaMk.closed_range\n#align is_closed_range_sigma_mk isClosed_range_sigmaMk\n-/\n\n",
 "isClosed_range_inr":
 "#print isClosed_range_inr /-\ntheorem isClosed_range_inr : IsClosed (range (inr : Œ≤ ‚Üí Sum Œ± Œ≤)) :=\n  by\n  rw [‚Üê isOpen_compl_iff, compl_range_inr]\n  exact isOpen_range_inl\n#align is_closed_range_inr isClosed_range_inr\n-/\n\n",
 "isClosed_range_inl":
 "#print isClosed_range_inl /-\ntheorem isClosed_range_inl : IsClosed (range (inl : Œ± ‚Üí Sum Œ± Œ≤)) :=\n  by\n  rw [‚Üê isOpen_compl_iff, compl_range_inl]\n  exact isOpen_range_inr\n#align is_closed_range_inl isClosed_range_inl\n-/\n\n",
 "isClosedMap_toMul":
 "#print isClosedMap_toMul /-\ntheorem isClosedMap_toMul : IsClosedMap (toMul : Additive Œ± ‚Üí Œ±) :=\n  IsClosedMap.id\n#align is_closed_map_to_mul isClosedMap_toMul\n-/\n\n",
 "isClosedMap_toDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µà¬ª -/\n#print isClosedMap_toDual /-\ntheorem isClosedMap_toDual : IsClosedMap (toDual : Œ± ‚Üí ¬´expr ·µí·µà¬ª Œ±) :=\n  IsClosedMap.id\n#align is_closed_map_to_dual isClosedMap_toDual\n-/\n\n",
 "isClosedMap_toAdd":
 "#print isClosedMap_toAdd /-\ntheorem isClosedMap_toAdd : IsClosedMap (toAdd : Multiplicative Œ± ‚Üí Œ±) :=\n  IsClosedMap.id\n#align is_closed_map_to_add isClosedMap_toAdd\n-/\n\n",
 "isClosedMap_sigmaMk":
 "#print isClosedMap_sigmaMk /-\ntheorem isClosedMap_sigmaMk {i : Œπ} : IsClosedMap (@sigma.mk Œπ œÉ i) :=\n  by\n  intro s hs\n  rw [isClosed_sigma_iff]\n  intro j\n  rcases eq_or_ne j i with (rfl | hne)\n  ¬∑ rwa [Set.preimage_image_eq _ sigma_mk_injective]\n  ¬∑ rw [preimage_image_sigma_mk_of_ne hne]\n    exact isClosed_empty\n#align is_closed_map_sigma_mk isClosedMap_sigmaMk\n-/\n\n",
 "isClosedMap_ofMul":
 "#print isClosedMap_ofMul /-\ntheorem isClosedMap_ofMul : IsClosedMap (ofMul : Œ± ‚Üí Additive Œ±) :=\n  IsClosedMap.id\n#align is_closed_map_of_mul isClosedMap_ofMul\n-/\n\n",
 "isClosedMap_ofDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µà¬ª -/\n#print isClosedMap_ofDual /-\ntheorem isClosedMap_ofDual : IsClosedMap (ofDual : ¬´expr ·µí·µà¬ª Œ± ‚Üí Œ±) :=\n  IsClosedMap.id\n#align is_closed_map_of_dual isClosedMap_ofDual\n-/\n\n",
 "isClosedMap_ofAdd":
 "#print isClosedMap_ofAdd /-\ntheorem isClosedMap_ofAdd : IsClosedMap (ofAdd : Œ± ‚Üí Multiplicative Œ±) :=\n  IsClosedMap.id\n#align is_closed_map_of_add isClosedMap_ofAdd\n-/\n\n",
 "interior_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print interior_prod_eq /-\ntheorem interior_prod_eq (s : Set Œ±) (t : Set Œ≤) :\n    interior (finset.product s t) = finset.product (interior s) (interior t) :=\n  Set.ext fun ‚ü®a, b‚ü© => by simp only [mem_interior_iff_mem_nhds, mem_prod, prod_mem_nhds_iff]\n#align interior_prod_eq interior_prod_eq\n-/\n\n",
 "interior_pi_set":
 "#print interior_pi_set /-\ntheorem interior_pi_set {I : Set Œπ} (hI : I.finite) {s : ‚àÄ i, Set (œÄ i)} :\n    interior (pi I s) = I.pi fun i => interior (s i) := by\n  ext a\n  simp only [Set.mem_pi, mem_interior_iff_mem_nhds, set_pi_mem_nhds_iff hI]\n#align interior_pi_set interior_pi_set\n-/\n\n",
 "inducing_subtype_val":
 "#print inducing_subtype_val /-\ntheorem inducing_subtype_val {b : Set Œ≤} : Inducing (coe : b ‚Üí Œ≤) :=\n  ‚ü®rfl‚ü©\n#align inducing_coe inducing_subtype_val\n-/\n\n",
 "inducing_sigma_map":
 "#print inducing_sigma_map /-\ntheorem inducing_sigma_map {f‚ÇÅ : Œπ ‚Üí Œ∫} {f‚ÇÇ : ‚àÄ i, œÉ i ‚Üí œÑ (f‚ÇÅ i)} (h‚ÇÅ : injective f‚ÇÅ) :\n    Inducing (Sigma.map f‚ÇÅ f‚ÇÇ) ‚Üî ‚àÄ i, Inducing (f‚ÇÇ i) := by\n  simp only [inducing_iff_nhds, Sigma.forall, Sigma.nhds_mk, Sigma.map, ‚Üê map_sigma_mk_comap h‚ÇÅ,\n    map_inj sigma_mk_injective]\n#align inducing_sigma_map inducing_sigma_map\n-/\n\n",
 "inducing_inf·µ¢_to_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚®Ö , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª -/\n#print inducing_inf·µ¢_to_pi /-\n/-- Suppose `œÄ i` is a family of topological spaces indexed by `i : Œπ`, and `X` is a type\nendowed with a family of maps `f i : X ‚Üí œÄ i` for every `i : Œπ`, hence inducing a\nmap `g : X ‚Üí Œ† i, œÄ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Œπ` varies is simply the topology on `X` induced by `g : X ‚Üí Œ† i, œÄ i`\nwhere `Œ† i, œÄ i` is endowed with the usual product topology. -/\ntheorem inducing_inf·µ¢_to_pi {X : Type _} (f : ‚àÄ i, X ‚Üí œÄ i) :\n    @Inducing X (‚àÄ i, œÄ i)\n      (¬´expr‚®Ö , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚®Ö , ¬ª\"\n        (induced (f i) inferInstance))\n      _ fun x i => f i x :=\n  by\n  constructor\n  erw [induced_inf·µ¢]\n  congr 1\n  funext\n  erw [induced_compose]\n#align inducing_infi_to_pi inducing_inf·µ¢_to_pi\n-/\n\n",
 "fst''":
 "#print ContinuousAt.fst'' /-\n/-- Precomposing `f` with `prod.fst` is continuous at `x : Œ± √ó Œ≤` -/\ntheorem ContinuousAt.fst'' {f : Œ± ‚Üí Œ≥} {x : Œ± √ó Œ≤} (hf : ContinuousAt f x.fst) :\n    ContinuousAt (fun x : Œ± √ó Œ≤ => f x.fst) x :=\n  hf.comp continuousAt_fst\n#align continuous_at.fst'' ContinuousAt.fst''\n-/\n\n",
 "fst'":
 "#print ContinuousAt.fst' /-\n/-- Precomposing `f` with `prod.fst` is continuous at `(x, y)` -/\ntheorem ContinuousAt.fst' {f : Œ± ‚Üí Œ≥} {x : Œ±} {y : Œ≤} (hf : ContinuousAt f x) :\n    ContinuousAt (fun x : Œ± √ó Œ≤ => f x.fst) (x, y) :=\n  ContinuousAt.comp hf continuousAt_fst\n#align continuous_at.fst' ContinuousAt.fst'\n-/\n\n",
 "fst":
 "#print ContinuousAt.fst /-\n/-- Postcomposing `f` with `prod.fst` is continuous at `x` -/\ntheorem ContinuousAt.fst {f : Œ± ‚Üí Œ≤ √ó Œ≥} {x : Œ±} (hf : ContinuousAt f x) : ContinuousAt (fun a : Œ± => (f a).1) x :=\n  continuousAt_fst.comp hf\n#align continuous_at.fst ContinuousAt.fst\n-/\n\n",
 "frontier_univ_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print frontier_univ_prod_eq /-\n@[simp]\ntheorem frontier_univ_prod_eq (s : Set Œ≤) :\n    frontier (finset.product (univ : Set Œ±) s) = finset.product univ (frontier s) := by simp [frontier_prod_eq]\n#align frontier_univ_prod_eq frontier_univ_prod_eq\n-/\n\n",
 "frontier_prod_univ_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print frontier_prod_univ_eq /-\n@[simp]\ntheorem frontier_prod_univ_eq (s : Set Œ±) :\n    frontier (finset.product s (univ : Set Œ≤)) = finset.product (frontier s) univ := by simp [frontier_prod_eq]\n#align frontier_prod_univ_eq frontier_prod_univ_eq\n-/\n\n",
 "frontier_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print frontier_prod_eq /-\ntheorem frontier_prod_eq (s : Set Œ±) (t : Set Œ≤) :\n    frontier (finset.product s t) = finset.product (closure s) (frontier t) ‚à™ finset.product (frontier s) (closure t) :=\n  by simp only [frontier, closure_prod_eq, interior_prod_eq, prod_diff_prod]\n#align frontier_prod_eq frontier_prod_eq\n-/\n\n",
 "fin_insertNth":
 "#print Continuous.fin_insertNth /-\ntheorem Continuous.fin_insertNth {n} {œÄ : Fin (n + 1) ‚Üí Type _} [‚àÄ i, TopologicalSpace (œÄ i)] (i : Fin (n + 1))\n    {f : Œ± ‚Üí œÄ i} (hf : Continuous f) {g : Œ± ‚Üí ‚àÄ j : Fin n, œÄ (i.succ_above j)} (hg : Continuous g) :\n    Continuous fun a => i.insert_nth (f a) (g a) :=\n  continuous_iff_continuousAt.2 fun a => hf.continuous_at.fin_insert_nth i hg.continuous_at\n#align continuous.fin_insert_nth Continuous.fin_insertNth\n-/\n\n",
 "exists_nhds_square":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print exists_nhds_square /-\n/-- Given a neighborhood `s` of `(x, x)`, then `(x, x)` has a square open neighborhood\n  that is a subset of `s`. -/\ntheorem exists_nhds_square {s : Set (Œ± √ó Œ±)} {x : Œ±} (hx : s ‚àà (nhds) (x, x)) :\n    ‚àÉ U : Set Œ±, IsOpen U ‚àß x ‚àà U ‚àß finset.product U U ‚äÜ s := by\n  simpa [nhds_prod_eq, (nhds_basis_opens x).prod_self.mem_iff, and_assoc, and_left_comm] using hx\n#align exists_nhds_square exists_nhds_square\n-/\n\n",
 "exists_finset_piecewise_mem_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_finset_piecewise_mem_of_mem_nhds /-\ntheorem exists_finset_piecewise_mem_of_mem_nhds [DecidableEq Œπ] {s : Set (‚àÄ a, œÄ a)} {x : ‚àÄ a, œÄ a} (hs : s ‚àà (nhds) x)\n    (y : ‚àÄ a, œÄ a) : ‚àÉ I : Finset Œπ, I.piecewise x y ‚àà s :=\n  by\n  simp only [nhds_pi, Filter.mem_pi'] at hs\n  rcases hs with ‚ü®I, t, htx, hts‚ü©\n  refine' ‚ü®I, hts fun i hi => _‚ü©\n  simpa [Finset.mem_coe.1 hi] using mem_of_mem_nhds (htx i)\n#align exists_finset_piecewise_mem_of_mem_nhds exists_finset_piecewise_mem_of_mem_nhds\n-/\n\n",
 "embedding_uLift_down":
 "#print embedding_uLift_down /-\ntheorem embedding_uLift_down [TopologicalSpace Œ±] : Embedding (ULift.down : ULift.{v, u} Œ± ‚Üí Œ±) :=\n  ‚ü®‚ü®rfl‚ü©, ULift.down_injective‚ü©\n#align embedding_ulift_down embedding_uLift_down\n-/\n\n",
 "embedding_subtype_val":
 "#print embedding_subtype_val /-\ntheorem embedding_subtype_val : Embedding (coe : Subtype p ‚Üí Œ±) :=\n  ‚ü®‚ü®rfl‚ü©, Subtype.coe_injective‚ü©\n#align embedding_subtype_coe embedding_subtype_val\n-/\n\n",
 "embedding_sigma_map":
 "#print embedding_sigma_map /-\ntheorem embedding_sigma_map {f‚ÇÅ : Œπ ‚Üí Œ∫} {f‚ÇÇ : ‚àÄ i, œÉ i ‚Üí œÑ (f‚ÇÅ i)} (h : injective f‚ÇÅ) :\n    Embedding (Sigma.map f‚ÇÅ f‚ÇÇ) ‚Üî ‚àÄ i, Embedding (f‚ÇÇ i) := by\n  simp only [embedding_iff, injective.sigma_map, inducing_sigma_map h, forall_and, h.sigma_map_iff]\n#align embedding_sigma_map embedding_sigma_map\n-/\n\n",
 "embedding_sigmaMk":
 "#print embedding_sigmaMk /-\ntheorem embedding_sigmaMk {i : Œπ} : Embedding (@sigma.mk Œπ œÉ i) :=\n  closedEmbedding_sigmaMk.1\n#align embedding_sigma_mk embedding_sigmaMk\n-/\n\n",
 "embedding_inr":
 "#print embedding_inr /-\ntheorem embedding_inr : Embedding (@inr Œ± Œ≤) :=\n  openEmbedding_inr.1\n#align embedding_inr embedding_inr\n-/\n\n",
 "embedding_inl":
 "#print embedding_inl /-\ntheorem embedding_inl : Embedding (@inl Œ± Œ≤) :=\n  openEmbedding_inl.1\n#align embedding_inl embedding_inl\n-/\n\n",
 "embedding_inclusion":
 "#print embedding_inclusion /-\ntheorem embedding_inclusion {s t : Set Œ±} (h : s ‚äÜ t) : Embedding (Set.inclusion h) :=\n  embedding_subtype_val.cod_restrict _ _\n#align embedding_inclusion embedding_inclusion\n-/\n\n",
 "embedding_graph":
 "#print embedding_graph /-\ntheorem embedding_graph {f : Œ± ‚Üí Œ≤} (hf : Continuous f) : Embedding fun x => (x, f x) :=\n  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id\n#align embedding_graph embedding_graph\n-/\n\n",
 "discreteTopology_subtype_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä•¬ª -/\n#print discreteTopology_subtype_iff /-\ntheorem discreteTopology_subtype_iff {S : Set Œ±} :\n    DiscreteTopology S ‚Üî ‚àÄ x ‚àà S, ¬´expr ‚äì ¬ª (nhds_within.ne x) ((filter.principal) S) = ¬´expr‚ä•¬ª := by\n  simp_rw [discreteTopology_iff_nhds_ne, SetCoe.forall', nhds_ne_subtype_eq_bot_iff]\n#align discrete_topology_subtype_iff discreteTopology_subtype_iff\n-/\n\n",
 "dense_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n#print Subtype.dense_iff /-\ntheorem Subtype.dense_iff {s : Set Œ±} {t : Set s} : Dense t ‚Üî s ‚äÜ closure (¬´expr '' ¬ª coe t) :=\n  by\n  rw [inducing_coe.dense_iff, SetCoe.forall]\n  rfl\n#align subtype.dense_iff Subtype.dense_iff\n-/\n\n",
 "curry_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Eventually.curry_nhds /-\ntheorem Filter.Eventually.curry_nhds {p : Œ± √ó Œ≤ ‚Üí Prop} {x : Œ±} {y : Œ≤}\n    (h :\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n        ((nhds) (x, y)) (p x)) :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" ((nhds) x)\n      (¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n        ((nhds) y) (p (x', y'))) :=\n  by\n  rw [nhds_prod_eq] at h\n  exact h.curry\n#align filter.eventually.curry_nhds Filter.Eventually.curry_nhds\n-/\n\n",
 "continuous_update":
 "#print continuous_update /-\n/-- `function.update f i x` is continuous in `(f, x)`. -/\n@[continuity]\ntheorem continuous_update [DecidableEq Œπ] (i : Œπ) : Continuous fun f : (‚àÄ j, œÄ j) √ó œÄ i => update f.1 i f.2 :=\n  continuous_fst.update i continuous_snd\n#align continuous_update continuous_update\n-/\n\n",
 "continuous_uncurry_right":
 "#print continuous_uncurry_right /-\ntheorem continuous_uncurry_right {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (b : Œ≤) (h : Continuous (uncurry f)) : Continuous fun a => f a b :=\n  show Continuous (uncurry f ‚àò fun a => (a, b)) from h.comp (by continuity)\n#align continuous_uncurry_right continuous_uncurry_right\n-/\n\n",
 "continuous_uncurry_of_discreteTopology_left":
 "#print continuous_uncurry_of_discreteTopology_left /-\ntheorem continuous_uncurry_of_discreteTopology_left [DiscreteTopology Œ±] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (h : ‚àÄ a, Continuous (f a)) :\n    Continuous (uncurry f) :=\n  continuous_iff_continuousAt.2 fun ‚ü®a, b‚ü© => by\n    simp only [ContinuousAt, nhds_prod_eq, nhds_discrete Œ±, pure_prod, tendsto_map'_iff, (¬∑ ‚àò ¬∑), uncurry,\n      (h a).tendsto]\n#align continuous_uncurry_of_discrete_topology_left continuous_uncurry_of_discreteTopology_left\n-/\n\n",
 "continuous_uncurry_of_discreteTopology":
 "#print continuous_uncurry_of_discreteTopology /-\n/-- If a function `f x y` is such that `y ‚Ü¶ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem continuous_uncurry_of_discreteTopology [DiscreteTopology Œ±] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (hf : ‚àÄ a, Continuous (f a)) :\n    Continuous (uncurry f) := by\n  apply continuous_iff_continuousAt.2\n  rintro ‚ü®a, x‚ü©\n  change map _ _ ‚â§ _\n  rw [nhds_prod_eq, nhds_discrete, Filter.map_pure_prod]\n  exact (hf a).continuous_at\n#align continuous_uncurry_of_discrete_topology continuous_uncurry_of_discreteTopology\n-/\n\n",
 "continuous_uncurry_left":
 "#print continuous_uncurry_left /-\ntheorem continuous_uncurry_left {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (a : Œ±) (h : Continuous (uncurry f)) : Continuous (f a) :=\n  show Continuous (uncurry f ‚àò fun b => (a, b)) from h.comp (by continuity)\n#align continuous_uncurry_left continuous_uncurry_left\n-/\n\n",
 "continuous_uLift_up":
 "#print continuous_uLift_up /-\n@[continuity]\ntheorem continuous_uLift_up [TopologicalSpace Œ±] : Continuous (ULift.up : Œ± ‚Üí ULift.{v, u} Œ±) :=\n  continuous_induced_rng.2 continuous_id\n#align continuous_ulift_up continuous_uLift_up\n-/\n\n",
 "continuous_uLift_down":
 "#print continuous_uLift_down /-\n@[continuity]\ntheorem continuous_uLift_down [TopologicalSpace Œ±] : Continuous (ULift.down : ULift.{v, u} Œ± ‚Üí Œ±) :=\n  continuous_induced_dom\n#align continuous_ulift_down continuous_uLift_down\n-/\n\n",
 "continuous_toMul":
 "#print continuous_toMul /-\ntheorem continuous_toMul : Continuous (toMul : Additive Œ± ‚Üí Œ±) :=\n  continuous_id\n#align continuous_to_mul continuous_toMul\n-/\n\n",
 "continuous_toDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µà¬ª -/\n#print continuous_toDual /-\ntheorem continuous_toDual : Continuous (toDual : Œ± ‚Üí ¬´expr ·µí·µà¬ª Œ±) :=\n  continuous_id\n#align continuous_to_dual continuous_toDual\n-/\n\n",
 "continuous_toAdd":
 "#print continuous_toAdd /-\ntheorem continuous_toAdd : Continuous (toAdd : Multiplicative Œ± ‚Üí Œ±) :=\n  continuous_id\n#align continuous_to_add continuous_toAdd\n-/\n\n",
 "continuous_swap":
 "#print continuous_swap /-\ntheorem continuous_swap : Continuous (Prod.swap : Œ± √ó Œ≤ ‚Üí Œ≤ √ó Œ±) :=\n  continuous_snd.prod_mk continuous_fst\n#align continuous_swap continuous_swap\n-/\n\n",
 "continuous_sum_map":
 "#print continuous_sum_map /-\n@[simp]\ntheorem continuous_sum_map {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥} : Continuous (Sum.map f g) ‚Üî Continuous f ‚àß Continuous g :=\n  continuous_sum_elim.trans <| embedding_inl.continuous_iff.symm.and embedding_inr.continuous_iff.symm\n#align continuous_sum_map continuous_sum_map\n-/\n\n",
 "continuous_sum_elim":
 "#print continuous_sum_elim /-\ntheorem continuous_sum_elim {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≥} : Continuous (Sum.elim f g) ‚Üî Continuous f ‚àß Continuous g :=\n  continuous_sum_dom\n#align continuous_sum_elim continuous_sum_elim\n-/\n\n",
 "continuous_sum_dom":
 "#print continuous_sum_dom /-\ntheorem continuous_sum_dom {f : Sum Œ± Œ≤ ‚Üí Œ≥} : Continuous f ‚Üî Continuous (f ‚àò Sum.inl) ‚àß Continuous (f ‚àò Sum.inr) := by\n  simp only [continuous_sup_dom, continuous_coinduced_dom]\n#align continuous_sum_dom continuous_sum_dom\n-/\n\n",
 "continuous_subtype_val":
 "/- warning: continuous_subtype_coe clashes with continuous_subtype_val -> continuous_subtype_val\nCase conversion may be inaccurate. Consider using '#align continuous_subtype_coe continuous_subtype_val‚Çì'. -/\n#print continuous_subtype_val /-\ntheorem continuous_subtype_val : Continuous (coe : Subtype p ‚Üí Œ±) :=\n  continuous_subtype_val\n#align continuous_subtype_coe continuous_subtype_val\n-/\n\n",
 "continuous_snd":
 "#print continuous_snd /-\n@[continuity]\ntheorem continuous_snd : Continuous (@Prod.snd Œ± Œ≤) :=\n  continuous_inf_dom_right continuous_induced_dom\n#align continuous_snd continuous_snd\n-/\n\n",
 "continuous_sigma_map":
 "#print continuous_sigma_map /-\n@[simp]\ntheorem continuous_sigma_map {f‚ÇÅ : Œπ ‚Üí Œ∫} {f‚ÇÇ : ‚àÄ i, œÉ i ‚Üí œÑ (f‚ÇÅ i)} :\n    Continuous (Sigma.map f‚ÇÅ f‚ÇÇ) ‚Üî ‚àÄ i, Continuous (f‚ÇÇ i) :=\n  continuous_sigma_iff.trans <| by simp only [Sigma.map, embedding_sigma_mk.continuous_iff]\n#align continuous_sigma_map continuous_sigma_map\n-/\n\n",
 "continuous_sigma_iff":
 "#print continuous_sigma_iff /-\n/-- A map out of a sum type is continuous iff its restriction to each summand is. -/\n@[simp]\ntheorem continuous_sigma_iff {f : Sigma œÉ ‚Üí Œ±} : Continuous f ‚Üî ‚àÄ i, Continuous fun a => f ‚ü®i, a‚ü© := by\n  simp only [continuous_sup·µ¢_dom, continuous_coinduced_dom]\n#align continuous_sigma_iff continuous_sigma_iff\n-/\n\n",
 "continuous_sigmaMk":
 "#print continuous_sigmaMk /-\n@[continuity]\ntheorem continuous_sigmaMk {i : Œπ} : Continuous (@sigma.mk Œπ œÉ i) :=\n  continuous_sup·µ¢_rng continuous_coinduced_rng\n#align continuous_sigma_mk continuous_sigmaMk\n-/\n\n",
 "continuous_sigma":
 "#print continuous_sigma /-\n/-- A map out of a sum type is continuous if its restriction to each summand is. -/\n@[continuity]\ntheorem continuous_sigma {f : Sigma œÉ ‚Üí Œ±} (hf : ‚àÄ i, Continuous fun a => f ‚ü®i, a‚ü©) : Continuous f :=\n  continuous_sigma_iff.2 hf\n#align continuous_sigma continuous_sigma\n-/\n\n",
 "continuous_quotient_mk'":
 "#print continuous_quotient_mk' /-\ntheorem continuous_quotient_mk' : Continuous (@Quotient.mk' Œ± s) :=\n  continuous_coinduced_rng\n#align continuous_quotient_mk continuous_quotient_mk'\n-/\n\n",
 "continuous_quot_mk":
 "#print continuous_quot_mk /-\n@[continuity]\ntheorem continuous_quot_mk : Continuous (@Quot.mk Œ± r) :=\n  continuous_coinduced_rng\n#align continuous_quot_mk continuous_quot_mk\n-/\n\n",
 "continuous_quot_lift":
 "#print continuous_quot_lift /-\n@[continuity]\ntheorem continuous_quot_lift {f : Œ± ‚Üí Œ≤} (hr : ‚àÄ a b, r a b ‚Üí f a = f b) (h : Continuous f) :\n    Continuous (Quot.lift f hr : Quot r ‚Üí Œ≤) :=\n  continuous_coinduced_dom.2 h\n#align continuous_quot_lift continuous_quot_lift\n-/\n\n",
 "continuous_prod_mk":
 "#print continuous_prod_mk /-\n@[simp]\ntheorem continuous_prod_mk {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≥} : (Continuous fun x => (f x, g x)) ‚Üî Continuous f ‚àß Continuous g :=\n  ‚ü®fun h => ‚ü®h.fst, h.snd‚ü©, fun h => h.1.prod_mk h.2‚ü©\n#align continuous_prod_mk continuous_prod_mk\n-/\n\n",
 "continuous_pi_iff":
 "#print continuous_pi_iff /-\ntheorem continuous_pi_iff : Continuous f ‚Üî ‚àÄ i, Continuous fun a => f a i := by\n  simp only [continuous_inf·µ¢_rng, continuous_induced_rng]\n#align continuous_pi_iff continuous_pi_iff\n-/\n\n",
 "continuous_pi":
 "#print continuous_pi /-\n@[continuity]\ntheorem continuous_pi (h : ‚àÄ i, Continuous fun a => f a i) : Continuous f :=\n  continuous_pi_iff.2 h\n#align continuous_pi continuous_pi\n-/\n\n",
 "continuous_ofMul":
 "#print continuous_ofMul /-\n/-\nCopyright (c) 2017 Johannes H√∂lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes H√∂lzl, Mario Carneiro, Patrick Massot\n-/\ntheorem continuous_ofMul : Continuous (ofMul : Œ± ‚Üí Additive Œ±) :=\n  continuous_id\n#align continuous_of_mul continuous_ofMul\n-/\n\n",
 "continuous_ofDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·µí·µà¬ª -/\n#print continuous_ofDual /-\ntheorem continuous_ofDual : Continuous (ofDual : ¬´expr ·µí·µà¬ª Œ± ‚Üí Œ±) :=\n  continuous_id\n#align continuous_of_dual continuous_ofDual\n-/\n\n",
 "continuous_ofAdd":
 "#print continuous_ofAdd /-\ntheorem continuous_ofAdd : Continuous (ofAdd : Œ± ‚Üí Multiplicative Œ±) :=\n  continuous_id\n#align continuous_of_add continuous_ofAdd\n-/\n\n",
 "continuous_mulSingle":
 "#print continuous_mulSingle /-\n/-- `pi.mul_single i x` is continuous in `x`. -/\n@[continuity, to_additive \"`pi.single i x` is continuous in `x`.\"]\ntheorem continuous_mulSingle [‚àÄ i, One (œÄ i)] [DecidableEq Œπ] (i : Œπ) :\n    Continuous fun x => (Pi.mulSingle i x : ‚àÄ i, œÄ i) :=\n  continuous_const.update _ continuous_id\n#align continuous_mul_single continuous_mulSingle\n#align continuous_single continuous_single\n-/\n\n",
 "continuous_inr":
 "#print continuous_inr /-\n@[continuity]\ntheorem continuous_inr : Continuous (@inr Œ± Œ≤) :=\n  continuous_sup_rng_right continuous_coinduced_rng\n#align continuous_inr continuous_inr\n-/\n\n",
 "continuous_inl":
 "#print continuous_inl /-\n@[continuity]\ntheorem continuous_inl : Continuous (@inl Œ± Œ≤) :=\n  continuous_sup_rng_left continuous_coinduced_rng\n#align continuous_inl continuous_inl\n-/\n\n",
 "continuous_inf‚Çõ_dom‚ÇÇ":
 "#print continuous_inf‚Çõ_dom‚ÇÇ /-\n/-- A version of `continuous_Inf_dom` for binary functions -/\ntheorem continuous_inf‚Çõ_dom‚ÇÇ {Œ± Œ≤ Œ≥} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {tas : Set (TopologicalSpace Œ±)} {tbs : Set (TopologicalSpace Œ≤)}\n    {ta : TopologicalSpace Œ±} {tb : TopologicalSpace Œ≤} {tc : TopologicalSpace Œ≥} (ha : ta ‚àà tas) (hb : tb ‚àà tbs)\n    (hf : Continuous fun p : Œ± √ó Œ≤ => f p.1 p.2) : by\n    haveI := Inf tas <;> haveI := Inf tbs <;> exact @Continuous _ _ _ tc fun p : Œ± √ó Œ≤ => f p.1 p.2 :=\n  by\n  let t : TopologicalSpace (Œ± √ó Œ≤) := prod.topological_space\n  have ha := continuous_inf‚Çõ_dom ha continuous_id\n  have hb := continuous_inf‚Çõ_dom hb continuous_id\n  have h_continuous_id := @Continuous.prod_map _ _ _ _ ta tb (Inf tas) (Inf tbs) _ _ ha hb\n  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ hf h_continuous_id\n#align continuous_Inf_dom‚ÇÇ continuous_inf‚Çõ_dom‚ÇÇ\n-/\n\n",
 "continuous_inf_dom_right‚ÇÇ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n#print continuous_inf_dom_right‚ÇÇ /-\n/-- A version of `continuous_inf_dom_right` for binary functions -/\ntheorem continuous_inf_dom_right‚ÇÇ {Œ± Œ≤ Œ≥} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {ta1 ta2 : TopologicalSpace Œ±} {tb1 tb2 : TopologicalSpace Œ≤}\n    {tc1 : TopologicalSpace Œ≥} (h : by haveI := ta2 <;> haveI := tb2 <;> exact Continuous fun p : Œ± √ó Œ≤ => f p.1 p.2) :\n    by haveI := ¬´expr ‚äì ¬ª ta1 ta2 <;> haveI := ¬´expr ‚äì ¬ª tb1 tb2 <;> exact Continuous fun p : Œ± √ó Œ≤ => f p.1 p.2 :=\n  by\n  have ha := @continuous_inf_dom_right _ _ id ta1 ta2 ta2 (@continuous_id _ (id _))\n  have hb := @continuous_inf_dom_right _ _ id tb1 tb2 tb2 (@continuous_id _ (id _))\n  have h_continuous_id := @Continuous.prod_map _ _ _ _ ta2 tb2 (¬´expr ‚äì ¬ª ta1 ta2) (¬´expr ‚äì ¬ª tb1 tb2) _ _ ha hb\n  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id\n#align continuous_inf_dom_right‚ÇÇ continuous_inf_dom_right‚ÇÇ\n-/\n\n",
 "continuous_inf_dom_left‚ÇÇ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n#print continuous_inf_dom_left‚ÇÇ /-\n/-- A version of `continuous_inf_dom_left` for binary functions -/\ntheorem continuous_inf_dom_left‚ÇÇ {Œ± Œ≤ Œ≥} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {ta1 ta2 : TopologicalSpace Œ±} {tb1 tb2 : TopologicalSpace Œ≤}\n    {tc1 : TopologicalSpace Œ≥} (h : by haveI := ta1 <;> haveI := tb1 <;> exact Continuous fun p : Œ± √ó Œ≤ => f p.1 p.2) :\n    by haveI := ¬´expr ‚äì ¬ª ta1 ta2 <;> haveI := ¬´expr ‚äì ¬ª tb1 tb2 <;> exact Continuous fun p : Œ± √ó Œ≤ => f p.1 p.2 :=\n  by\n  have ha := @continuous_inf_dom_left _ _ id ta1 ta2 ta1 (@continuous_id _ (id _))\n  have hb := @continuous_inf_dom_left _ _ id tb1 tb2 tb1 (@continuous_id _ (id _))\n  have h_continuous_id := @Continuous.prod_map _ _ _ _ ta1 tb1 (¬´expr ‚äì ¬ª ta1 ta2) (¬´expr ‚äì ¬ª tb1 tb2) _ _ ha hb\n  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id\n#align continuous_inf_dom_left‚ÇÇ continuous_inf_dom_left‚ÇÇ\n-/\n\n",
 "continuous_inclusion":
 "#print continuous_inclusion /-\ntheorem continuous_inclusion {s t : Set Œ±} (h : s ‚äÜ t) : Continuous (inclusion h) :=\n  continuous_id.subtype_map h\n#align continuous_inclusion continuous_inclusion\n-/\n\n",
 "continuous_fst":
 "#print continuous_fst /-\n@[continuity]\ntheorem continuous_fst : Continuous (@Prod.fst Œ± Œ≤) :=\n  continuous_inf_dom_left continuous_induced_dom\n#align continuous_fst continuous_fst\n-/\n\n",
 "continuous_curry":
 "#print continuous_curry /-\ntheorem continuous_curry {g : Œ± √ó Œ≤ ‚Üí Œ≥} (a : Œ±) (h : Continuous g) : Continuous (curry g a) :=\n  show Continuous (g ‚àò fun b => (a, b)) from h.comp (by continuity)\n#align continuous_curry continuous_curry\n-/\n\n",
 "continuous_apply_apply":
 "#print continuous_apply_apply /-\n@[continuity]\ntheorem continuous_apply_apply {œÅ : Œ∫ ‚Üí Œπ ‚Üí Type _} [‚àÄ j i, TopologicalSpace (œÅ j i)] (j : Œ∫) (i : Œπ) :\n    Continuous fun p : ‚àÄ j, ‚àÄ i, œÅ j i => p j i :=\n  (continuous_apply i).comp (continuous_apply j)\n#align continuous_apply_apply continuous_apply_apply\n-/\n\n",
 "continuous_apply":
 "#print continuous_apply /-\n@[continuity]\ntheorem continuous_apply (i : Œπ) : Continuous fun p : ‚àÄ i, œÄ i => p i :=\n  continuous_inf·µ¢_dom continuous_induced_dom\n#align continuous_apply continuous_apply\n-/\n\n",
 "continuousAt_subtype_val":
 "#print continuousAt_subtype_val /-\ntheorem continuousAt_subtype_val {p : Œ± ‚Üí Prop} {a : Subtype p} : ContinuousAt (coe : Subtype p ‚Üí Œ±) a :=\n  continuous_iff_continuousAt.mp continuous_subtype_val _\n#align continuous_at_subtype_coe continuousAt_subtype_val\n-/\n\n",
 "continuousAt_snd":
 "#print continuousAt_snd /-\ntheorem continuousAt_snd {p : Œ± √ó Œ≤} : ContinuousAt Prod.snd p :=\n  continuous_snd.continuous_at\n#align continuous_at_snd continuousAt_snd\n-/\n\n",
 "continuousAt_pi":
 "#print continuousAt_pi /-\ntheorem continuousAt_pi {f : Œ± ‚Üí ‚àÄ i, œÄ i} {x : Œ±} : ContinuousAt f x ‚Üî ‚àÄ i, ContinuousAt (fun y => f y i) x :=\n  tendsto_pi_nhds\n#align continuous_at_pi continuousAt_pi\n-/\n\n",
 "continuousAt_fst":
 "#print continuousAt_fst /-\ntheorem continuousAt_fst {p : Œ± √ó Œ≤} : ContinuousAt Prod.fst p :=\n  continuous_fst.continuous_at\n#align continuous_at_fst continuousAt_fst\n-/\n\n",
 "continuousAt_codRestrict_iff":
 "#print continuousAt_codRestrict_iff /-\ntheorem continuousAt_codRestrict_iff {f : Œ± ‚Üí Œ≤} {t : Set Œ≤} (h1 : ‚àÄ x, f x ‚àà t) {x : Œ±} :\n    ContinuousAt (codRestrict f t h1) x ‚Üî ContinuousAt f x := by\n  simp_rw [inducing_coe.continuous_at_iff, Function.comp, coe_cod_restrict_apply]\n#align continuous_at_cod_restrict_iff continuousAt_codRestrict_iff\n-/\n\n",
 "continuousAt_apply":
 "#print continuousAt_apply /-\ntheorem continuousAt_apply (i : Œπ) (x : ‚àÄ i, œÄ i) : ContinuousAt (fun p : ‚àÄ i, œÄ i => p i) x :=\n  (continuous_apply i).continuous_at\n#align continuous_at_apply continuousAt_apply\n-/\n\n",
 "comp‚ÇÑ":
 "#print Continuous.comp‚ÇÑ /-\ntheorem Continuous.comp‚ÇÑ {g : Œ± √ó Œ≤ √ó Œ≥ √ó Œ∂ ‚Üí Œµ} (hg : Continuous g) {e : Œ¥ ‚Üí Œ±} (he : Continuous e) {f : Œ¥ ‚Üí Œ≤}\n    (hf : Continuous f) {k : Œ¥ ‚Üí Œ≥} (hk : Continuous k) {l : Œ¥ ‚Üí Œ∂} (hl : Continuous l) :\n    Continuous fun x => g (e x, f x, k x, l x) :=\n  hg.comp‚ÇÉ he hf <| hk.prod_mk hl\n#align continuous.comp‚ÇÑ Continuous.comp‚ÇÑ\n-/\n\n",
 "comp‚ÇÉ":
 "#print Continuous.comp‚ÇÉ /-\ntheorem Continuous.comp‚ÇÉ {g : Œ± √ó Œ≤ √ó Œ≥ ‚Üí Œµ} (hg : Continuous g) {e : Œ¥ ‚Üí Œ±} (he : Continuous e) {f : Œ¥ ‚Üí Œ≤}\n    (hf : Continuous f) {k : Œ¥ ‚Üí Œ≥} (hk : Continuous k) : Continuous fun x => g (e x, f x, k x) :=\n  hg.comp‚ÇÇ he <| hf.prod_mk hk\n#align continuous.comp‚ÇÉ Continuous.comp‚ÇÉ\n-/\n\n",
 "comp‚ÇÇ":
 "#print Continuous.comp‚ÇÇ /-\ntheorem Continuous.comp‚ÇÇ {g : Œ± √ó Œ≤ ‚Üí Œ≥} (hg : Continuous g) {e : Œ¥ ‚Üí Œ±} (he : Continuous e) {f : Œ¥ ‚Üí Œ≤}\n    (hf : Continuous f) : Continuous fun x => g (e x, f x) :=\n  hg.comp <| he.prod_mk hf\n#align continuous.comp‚ÇÇ Continuous.comp‚ÇÇ\n-/\n\n",
 "comap_sigmaMk_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print comap_sigmaMk_nhds /-\ntheorem comap_sigmaMk_nhds (i : Œπ) (x : œÉ i) : comap (sigma.mk i) ((nhds) ‚ü®i, x‚ü©) = (nhds) x :=\n  (embedding_sigmaMk.to_inducing.nhds_eq_comap _).symm\n#align comap_sigma_mk_nhds comap_sigmaMk_nhds\n-/\n\n",
 "codRestrict":
 "#print Embedding.codRestrict /-\ntheorem Embedding.codRestrict {e : Œ± ‚Üí Œ≤} (he : Embedding e) (s : Set Œ≤) (hs : ‚àÄ x, e x ‚àà s) :\n    Embedding (codRestrict e s hs) :=\n  embedding_of_embedding_compose (he.continuous.cod_restrict hs) continuous_subtype_val he\n#align embedding.cod_restrict Embedding.codRestrict\n-/\n\n",
 "closure_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr '' ¬ª -/\n#print closure_subtype /-\ntheorem closure_subtype {x : { a // p a }} {s : Set { a // p a }} :\n    x ‚àà closure s ‚Üî (x : Œ±) ‚àà closure (¬´expr '' ¬ª (coe : _ ‚Üí Œ±) s) :=\n  closure_induced\n#align closure_subtype closure_subtype\n-/\n\n",
 "closure_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äì ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print closure_prod_eq /-\ntheorem closure_prod_eq {s : Set Œ±} {t : Set Œ≤} :\n    closure (finset.product s t) = finset.product (closure s) (closure t) :=\n  Set.ext fun ‚ü®a, b‚ü© =>\n    by\n    have :\n      ¬´expr ‚äì ¬ª (filter.prod ((nhds) a) ((nhds) b)) ((filter.principal) (finset.product s t)) =\n        filter.prod (¬´expr ‚äì ¬ª ((nhds) a) ((filter.principal) s)) (¬´expr ‚äì ¬ª ((nhds) b) ((filter.principal) t)) :=\n      by rw [‚Üê prod_inf_prod, prod_principal_principal]\n    simp [closure_eq_cluster_pts, ClusterPt, nhds_prod_eq, this] <;> exact prod_ne_bot\n#align closure_prod_eq closure_prod_eq\n-/\n\n",
 "closedEmbedding_subtype_val":
 "#print IsClosed.closedEmbedding_subtype_val /-\ntheorem IsClosed.closedEmbedding_subtype_val {s : Set Œ±} (hs : IsClosed s) :\n    ClosedEmbedding (coe : { x // x ‚àà s } ‚Üí Œ±) :=\n  { induced := rfl\n    inj := Subtype.coe_injective\n    closed_range := (Subtype.range_coe : range coe = s).symm ‚ñ∏ hs }\n#align is_closed.closed_embedding_subtype_coe IsClosed.closedEmbedding_subtype_val\n-/\n\n",
 "closedEmbedding_sigmaMk":
 "#print closedEmbedding_sigmaMk /-\ntheorem closedEmbedding_sigmaMk {i : Œπ} : ClosedEmbedding (@sigma.mk Œπ œÉ i) :=\n  closedEmbedding_of_continuous_injective_closed continuous_sigmaMk sigma_mk_injective isClosedMap_sigmaMk\n#align closed_embedding_sigma_mk closedEmbedding_sigmaMk\n-/\n\n",
 "closedEmbedding_inr":
 "#print closedEmbedding_inr /-\ntheorem closedEmbedding_inr : ClosedEmbedding (inr : Œ≤ ‚Üí Sum Œ± Œ≤) :=\n  ‚ü®embedding_inr, isClosed_range_inr‚ü©\n#align closed_embedding_inr closedEmbedding_inr\n-/\n\n",
 "closedEmbedding_inl":
 "#print closedEmbedding_inl /-\ntheorem closedEmbedding_inl : ClosedEmbedding (inl : Œ± ‚Üí Sum Œ± Œ≤) :=\n  ‚ü®embedding_inl, isClosed_range_inl‚ü©\n#align closed_embedding_inl closedEmbedding_inl\n-/\n\n",
 "apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.apply /-\ntheorem Filter.Tendsto.apply {l : Filter Œ≤} {f : Œ≤ ‚Üí ‚àÄ i, œÄ i} {x : ‚àÄ i, œÄ i} (h : Tendsto f l ((nhds) x)) (i : Œπ) :\n    Tendsto (fun a => f a i) l (nhds <| x i) :=\n  (continuousAt_apply i _).tendsto.comp h\n#align filter.tendsto.apply Filter.Tendsto.apply\n-/\n\n"}