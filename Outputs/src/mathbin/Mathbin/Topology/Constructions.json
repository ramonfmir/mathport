{"update":
 "theorem continuous.update [decidable_eq ι] (hf : continuous f) (i : ι) {g : α → π i} (hg : continuous g) :\n    continuous fun a => update (f a) i (g a) :=\n  continuous_iff_continuous_at.2 fun x => hf.continuous_at.update i hg.continuous_at\n#align continuous.update continuous.update\n\n",
 "tendsto_subtype_rng":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_subtype_rng {β : Type _} {p : α → Prop} {b : filter β} {f : β → subtype p} :\n    ∀ {a : subtype p}, tendsto f b ((nhds) a) ↔ tendsto (fun x => (f x : α)) b ((nhds) (a : α))\n  | ⟨a, ha⟩ => by rw [nhds_subtype_eq_comap, tendsto_comap_iff, subtype.coe_mk]\n#align tendsto_subtype_rng tendsto_subtype_rng\n\n",
 "tendsto_pi_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_pi_nhds {f : β → ∀ i, π i} {g : ∀ i, π i} {u : filter β} :\n    tendsto f u ((nhds) g) ↔ ∀ x, tendsto (fun i => f i x) u ((nhds) (g x)) := by rw [nhds_pi, filter.tendsto_pi]\n#align tendsto_pi_nhds tendsto_pi_nhds\n\n",
 "tendsto_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem _root_.prod.tendsto_iff {α} (seq : α → β × γ) {f : filter α} (x : β × γ) :\n    tendsto seq f ((nhds) x) ↔\n      tendsto (fun n => (seq n).fst) f ((nhds) x.fst) ∧ tendsto (fun n => (seq n).snd) f ((nhds) x.snd) :=\n  by\n  cases x\n  rw [nhds_prod_eq, filter.tendsto_prod_iff']\n#align prod.tendsto_iff prod.tendsto_iff\n\n",
 "sum_map":
 "@[continuity]\ntheorem continuous.sum_map {f : α → β} {g : γ → δ} (hf : continuous f) (hg : continuous g) : continuous (sum.map f g) :=\n  continuous_sum_map.2 ⟨hf, hg⟩\n#align continuous.sum_map continuous.sum_map\n\n",
 "sum_elim":
 "theorem is_open_map.sum_elim {f : α → γ} {g : β → γ} (hf : is_open_map f) (hg : is_open_map g) :\n    is_open_map (sum.elim f g) :=\n  is_open_map_sum_elim.2 ⟨hf, hg⟩\n#align is_open_map.sum_elim is_open_map.sum_elim\n\n",
 "subtype_mk":
 "@[continuity]\ntheorem continuous.subtype_mk {f : β → α} (h : continuous f) (hp : ∀ x, p (f x)) :\n    continuous fun x => (⟨f x, hp x⟩ : subtype p) :=\n  continuous_induced_rng.2 h\n#align continuous.subtype_mk continuous.subtype_mk\n\n",
 "subtype_map":
 "theorem continuous.subtype_map {f : α → β} (h : continuous f) {q : β → Prop} (hpq : ∀ x, p x → q (f x)) :\n    continuous (subtype.map f hpq) :=\n  (h.comp continuous_subtype_coe).subtype_mk _\n#align continuous.subtype_map continuous.subtype_map\n\n",
 "subtype_coe":
 "theorem continuous.subtype_coe {f : β → subtype p} (hf : continuous f) : continuous fun x => (f x : α) :=\n  continuous_subtype_coe.comp hf\n#align continuous.subtype_coe continuous.subtype_coe\n\n",
 "snd''":
 "/-- Precomposing `f` with `prod.snd` is continuous at `x : α × β` -/\ntheorem continuous_at.snd'' {f : β → γ} {x : α × β} (hf : continuous_at f x.snd) :\n    continuous_at (fun x : α × β => f x.snd) x :=\n  hf.comp continuous_at_snd\n#align continuous_at.snd'' continuous_at.snd''\n\n",
 "snd'":
 "/-- Precomposing `f` with `prod.snd` is continuous at `(x, y)` -/\ntheorem continuous_at.snd' {f : β → γ} {x : α} {y : β} (hf : continuous_at f y) :\n    continuous_at (fun x : α × β => f x.snd) (x, y) :=\n  continuous_at.comp hf continuous_at_snd\n#align continuous_at.snd' continuous_at.snd'\n\n",
 "snd":
 "/-- Postcomposing `f` with `prod.snd` is continuous at `x` -/\ntheorem continuous_at.snd {f : α → β × γ} {x : α} (hf : continuous_at f x) : continuous_at (fun a : α => (f a).2) x :=\n  continuous_at_snd.comp hf\n#align continuous_at.snd continuous_at.snd\n\n",
 "sigma_map":
 "@[continuity]\ntheorem continuous.sigma_map {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} (hf : ∀ i, continuous (f₂ i)) :\n    continuous (sigma.map f₁ f₂) :=\n  continuous_sigma_map.2 hf\n#align continuous.sigma_map continuous.sigma_map\n\n",
 "set_pi_mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem set_pi_mem_nhds_iff {I : set ι} (hI : I.finite) {s : ∀ i, set (π i)} (a : ∀ i, π i) :\n    I.pi s ∈ (nhds) a ↔ ∀ i : ι, i ∈ I → s i ∈ (nhds) (a i) :=\n  by\n  rw [nhds_pi, pi_mem_pi_iff hI]\n  infer_instance\n#align set_pi_mem_nhds_iff set_pi_mem_nhds_iff\n\n",
 "set_pi_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem set_pi_mem_nhds {i : set ι} {s : ∀ a, set (π a)} {x : ∀ a, π a} (hi : i.finite)\n    (hs : ∀ a ∈ i, s a ∈ (nhds) (x a)) : pi i s ∈ (nhds) x :=\n  by\n  rw [pi_def, bInter_mem hi]\n  exact fun a ha => (continuous_apply a).continuous_at (hs a ha)\n#align set_pi_mem_nhds set_pi_mem_nhds\n\n",
 "restrict_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem continuous_at.restrict_preimage {f : α → β} {s : set β} {x : «expr ⁻¹' » f s} (h : continuous_at f x) :\n    continuous_at (s.restrict_preimage f) x :=\n  h.restrict _\n#align continuous_at.restrict_preimage continuous_at.restrict_preimage\n\n",
 "restrict":
 "theorem continuous_at.restrict {f : α → β} {s : set α} {t : set β} (h1 : MapsTo f s t) {x : s}\n    (h2 : continuous_at f x) : continuous_at (h1.restrict f s t) x :=\n  (h2.comp continuous_at_subtype_coe).cod_restrict _\n#align continuous_at.restrict continuous_at.restrict\n\n",
 "quotient_map_quotient_mk":
 "theorem quotient_map_quotient_mk : quotient_map (@Quotient.mk'' α s) :=\n  quotient_map_quot_mk\n#align quotient_map_quotient_mk quotient_map_quotient_mk\n\n",
 "quotient_map_quot_mk":
 "theorem quotient_map_quot_mk : quotient_map (@Quot.mk α r) :=\n  ⟨quot.exists_rep, rfl⟩\n#align quotient_map_quot_mk quotient_map_quot_mk\n\n",
 "quotient_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\ntheorem continuous.quotient_map' {t : setoid β} {f : α → β} (hf : continuous f) (H : («expr ⇒ » s.r t.r) f f) :\n    continuous (quotient.map' f H) :=\n  (continuous_quotient_mk.comp hf).quotient_lift _\n#align continuous.quotient_map' continuous.quotient_map'\n\n",
 "quotient_lift_on'":
 "theorem continuous.quotient_lift_on' {f : α → β} (h : continuous f) (hs : ∀ a b, @Setoid.r _ s a b → f a = f b) :\n    continuous (fun x => quotient.lift_on' x f hs : quotient s → β) :=\n  h.quotient_lift hs\n#align continuous.quotient_lift_on' continuous.quotient_lift_on'\n\n",
 "quotient_lift":
 "theorem continuous.quotient_lift {f : α → β} (h : continuous f) (hs : ∀ a b, a ≈ b → f a = f b) :\n    continuous (quotient.lift f hs : quotient s → β) :=\n  continuous_coinduced_dom.2 h\n#align continuous.quotient_lift continuous.quotient_lift\n\n",
 "quotient":
 "/-- The composition of `quotient.mk` and a function with dense range has dense range. -/\ntheorem dense_range.quotient [setoid α] [topological_space α] {f : β → α} (hf : dense_range f) :\n    dense_range (Quotient.mk'' ∘ f) :=\n  (surjective_quotient_mk α).dense_range.comp hf continuous_coinduced_rng\n#align dense_range.quotient dense_range.quotient\n\n",
 "prod_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem filter.has_basis.prod_nhds' {ιa ιb : Type _} {pa : ιa → Prop} {pb : ιb → Prop} {sa : ιa → set α}\n    {sb : ιb → set β} {ab : α × β} (ha : ((nhds) ab.1).has_basis pa sa) (hb : ((nhds) ab.2).has_basis pb sb) :\n    ((nhds) ab).has_basis (fun i : ιa × ιb => pa i.1 ∧ pb i.2) fun i => finset.product (sa i.1) (sb i.2) :=\n  by\n  cases ab\n  exact ha.prod_nhds hb\n#align filter.has_basis.prod_nhds' filter.has_basis.prod_nhds'\n\n",
 "prod_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually.prod_nhds {p : α → Prop} {q : β → Prop} {a : α} {b : β}\n    (ha :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p x))\n    (hb :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) b)\n        (q y)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((nhds) (a, b)) (p z.1 ∧ q z.2) :=\n  prod_mem_nhds ha hb\n#align filter.eventually.prod_nhds filter.eventually.prod_nhds\n\n",
 "prod_mk_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.prod_mk_nhds {γ} {a : α} {b : β} {f : filter γ} {ma : γ → α} {mb : γ → β}\n    (ha : tendsto ma f ((nhds) a)) (hb : tendsto mb f ((nhds) b)) : tendsto (fun c => (ma c, mb c)) f ((nhds) (a, b)) :=\n  by rw [nhds_prod_eq] <;> exact filter.tendsto.prod_mk ha hb\n#align filter.tendsto.prod_mk_nhds filter.tendsto.prod_mk_nhds\n\n",
 "prod_mk":
 "theorem embedding.prod_mk {f : α → β} {g : γ → δ} (hf : embedding f) (hg : embedding g) :\n    embedding fun x : α × γ => (f x.1, g x.2) :=\n  { hf.to_inducing.prod_mk hg.to_inducing with\n    inj := fun ⟨x₁, x₂⟩ ⟨y₁, y₂⟩ => by simp <;> exact fun h₁ h₂ => ⟨hf.inj h₁, hg.inj h₂⟩ }\n#align embedding.prod_mk embedding.prod_mk\n\n",
 "prod_mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem prod_mem_nhds_iff {s : set α} {t : set β} {a : α} {b : β} :\n    finset.product s t ∈ (nhds) (a, b) ↔ s ∈ (nhds) a ∧ t ∈ (nhds) b := by rw [nhds_prod_eq, prod_mem_prod_iff]\n#align prod_mem_nhds_iff prod_mem_nhds_iff\n\n",
 "prod_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem prod_mem_nhds {s : set α} {t : set β} {a : α} {b : β} (ha : s ∈ (nhds) a) (hb : t ∈ (nhds) b) :\n    finset.product s t ∈ (nhds) (a, b) :=\n  prod_mem_nhds_iff.2 ⟨ha, hb⟩\n#align prod_mem_nhds prod_mem_nhds\n\n",
 "prod_map'":
 "theorem continuous_at.prod_map' {f : α → γ} {g : β → δ} {x : α} {y : β} (hf : continuous_at f x)\n    (hg : continuous_at g y) : continuous_at (fun p : α × β => (f p.1, g p.2)) (x, y) :=\n  hf.fst'.prod hg.snd'\n#align continuous_at.prod_map' continuous_at.prod_map'\n\n",
 "prod_map":
 "/-- If `f` and `g` are maps with dense range, then `prod.map f g` has dense range. -/\ntheorem dense_range.prod_map {ι : Type _} {κ : Type _} {f : ι → β} {g : κ → γ} (hf : dense_range f)\n    (hg : dense_range g) : dense_range (prod.map f g) := by\n  simpa only [dense_range, prod_range_range_eq] using hf.prod hg\n#align dense_range.prod_map dense_range.prod_map\n\n",
 "prod_inr_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually.prod_inr_nhds {p : β → Prop} {b : β}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) b)\n        (p x))\n    (a : α) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((nhds) (a, b)) (p (x : α × β).2) :=\n  continuous_at_snd h\n#align filter.eventually.prod_inr_nhds filter.eventually.prod_inr_nhds\n\n",
 "prod_inl_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually.prod_inl_nhds {p : α → Prop} {a : α}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p x))\n    (b : β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((nhds) (a, b)) (p (x : α × β).1) :=\n  continuous_at_fst h\n#align filter.eventually.prod_inl_nhds filter.eventually.prod_inl_nhds\n\n",
 "prod_induced_induced":
 "/-- A product of induced topologies is induced by the product map -/\ntheorem prod_induced_induced {α γ : Type _} (f : α → β) (g : γ → δ) :\n    @prod.topological_space α γ (induced f ‹_›) (induced g ‹_›) =\n      induced (fun p => (f p.1, g p.2)) prod.topological_space :=\n  by simp_rw [prod.topological_space, induced_inf, induced_compose]\n#align prod_induced_induced prod_induced_induced\n\n",
 "prod_generate_from_generate_from_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem prod_generate_from_generate_from_eq {α β : Type _} {s : set (set α)} {t : set (set β)} (hs : ⋃₀ s = univ)\n    (ht : ⋃₀ t = univ) :\n    @prod.topological_space α β (generate_from s) (generate_from t) =\n      generate_from { g | ∃ u ∈ s, ∃ v ∈ t, g = finset.product u v } :=\n  let G := generate_from { g | ∃ u ∈ s, ∃ v ∈ t, g = finset.product u v }\n  le_antisymm\n    (le_generate_from fun g ⟨u, hu, v, hv, g_eq⟩ =>\n      g_eq.symm ▸\n        @is_open.prod _ _ (generate_from s) (generate_from t) _ _ (generate_open.basic _ hu) (generate_open.basic _ hv))\n    (le_inf\n      (coinduced_le_iff_le_induced.mp <|\n        le_generate_from fun u hu =>\n          have :\n            «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                (finset.product u v) =\n              «expr ⁻¹' » prod.fst u :=\n            by simp_rw [← prod_Union, ← sUnion_eq_bUnion, ht, prod_univ]\n          show G.is_open («expr ⁻¹' » prod.fst u) by\n            rw [← this]\n            exact is_open_Union fun v => is_open_Union fun hv => generate_open.basic _ ⟨_, hu, _, hv, rfl⟩)\n      (coinduced_le_iff_le_induced.mp <|\n        le_generate_from fun v hv =>\n          have :\n            «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                (finset.product u v) =\n              «expr ⁻¹' » prod.snd v :=\n            by simp_rw [← Union_prod_const, ← sUnion_eq_bUnion, hs, univ_prod]\n          show G.is_open («expr ⁻¹' » prod.snd v) by\n            rw [← this]\n            exact is_open_Union fun u => is_open_Union fun hu => generate_open.basic _ ⟨_, hu, _, hv, rfl⟩))\n#align prod_generate_from_generate_from_eq prod_generate_from_generate_from_eq\n\n",
 "prod_eq_generate_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem prod_eq_generate_from :\n    prod.topological_space =\n      generate_from { g | ∃ (s : set α)(t : set β), is_open s ∧ is_open t ∧ g = finset.product s t } :=\n  le_antisymm (le_generate_from fun g ⟨s, t, hs, ht, g_eq⟩ => g_eq.symm ▸ hs.prod ht)\n    (le_inf (ball_image_of_ball fun t ht => generate_open.basic _ ⟨t, univ, by simpa [Set.prod_eq] using ht⟩)\n      (ball_image_of_ball fun t ht => generate_open.basic _ ⟨univ, t, by simpa [Set.prod_eq] using ht⟩))\n#align prod_eq_generate_from prod_eq_generate_from\n\n",
 "prod":
 "protected theorem open_embedding.prod {f : α → β} {g : γ → δ} (hf : open_embedding f) (hg : open_embedding g) :\n    open_embedding fun x : α × γ => (f x.1, g x.2) :=\n  open_embedding_of_embedding_open (hf.1.prod_mk hg.1) (hf.is_open_map.prod hg.is_open_map)\n#align open_embedding.prod open_embedding.prod\n\n",
 "preimage_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem quotient.preimage_mem_nhds [topological_space α] [s : setoid α] {V : set <| quotient s} {a : α}\n    (hs : V ∈ (nhds) (Quotient.mk'' a)) : «expr ⁻¹' » Quotient.mk'' V ∈ (nhds) a :=\n  preimage_nhds_coinduced hs\n#align quotient.preimage_mem_nhds quotient.preimage_mem_nhds\n\n",
 "pi_generate_from_eq_finite":
 "theorem pi_generate_from_eq_finite {π : ι → Type _} {g : ∀ a, set (set (π a))} [Finite ι] (hg : ∀ a, ⋃₀ g a = univ) :\n    (@Pi.topological_space ι π fun a => generate_from (g a)) =\n      generate_from { t | ∃ s : ∀ a, set (π a), (∀ a, s a ∈ g a) ∧ t = pi univ s } :=\n  by\n  cases nonempty_fintype ι\n  rw [pi_generate_from_eq]\n  refine' le_antisymm (generate_from_mono _) (le_generate_from _)\n  exact fun s ⟨t, ht, eq⟩ => ⟨t, finset.univ, by simp [ht, eq]⟩\n  · rintro s ⟨t, i, ht, rfl⟩\n    apply is_open_iff_forall_mem_open.2 _\n    intro f hf\n    choose c hc using\n      show ∀ a, ∃ s, s ∈ g a ∧ f a ∈ s by\n        intro a\n        have : f a ∈ ⋃₀ g a := by\n          rw [hg]\n          apply mem_univ\n        simpa\n    refine' ⟨pi univ fun a => if a ∈ i then t a else (c : ∀ a, set (π a)) a, _, _, _⟩\n    · simp [pi_if]\n    · refine' generate_open.basic _ ⟨_, fun a => _, rfl⟩\n      by_cases a ∈ i <;> simp_all [Set.pi]\n    · have : f ∈ pi { a | a ∉ i } c := by simp_all [Set.pi]\n      simpa [pi_if, hf]\n#align pi_generate_from_eq_finite pi_generate_from_eq_finite\n\n",
 "pi_generate_from_eq":
 "theorem pi_generate_from_eq {π : ι → Type _} {g : ∀ a, set (set (π a))} :\n    (@Pi.topological_space ι π fun a => generate_from (g a)) =\n      generate_from { t | ∃ (s : ∀ a, set (π a))(i : Finset ι), (∀ a ∈ i, s a ∈ g a) ∧ t = pi (↑i) s } :=\n  by\n  let G := { t | ∃ (s : ∀ a, set (π a))(i : Finset ι), (∀ a ∈ i, s a ∈ g a) ∧ t = pi (↑i) s }\n  rw [pi_eq_generate_from]\n  refine' le_antisymm (generate_from_mono _) (le_generate_from _)\n  exact fun s ⟨t, i, ht, eq⟩ => ⟨t, i, fun a ha => generate_open.basic _ (ht a ha), eq⟩\n  · rintro s ⟨t, i, hi, rfl⟩\n    rw [pi_def]\n    apply is_open_bInter (finset.finite_to_set _)\n    intro a ha\n    show ((generate_from G).coinduced fun f : ∀ a, π a => f a).is_open (t a)\n    refine' le_generate_from _ _ (hi a ha)\n    exact fun s hs => generate_open.basic _ ⟨update (fun a => univ) a s, {a}, by simp [hs]⟩\n#align pi_generate_from_eq pi_generate_from_eq\n\n",
 "pi_eq_generate_from":
 "theorem pi_eq_generate_from :\n    Pi.topological_space =\n      generate_from { g | ∃ (s : ∀ a, set (π a))(i : Finset ι), (∀ a ∈ i, is_open (s a)) ∧ g = pi (↑i) s } :=\n  le_antisymm (le_generate_from fun g ⟨s, i, hi, eq⟩ => eq.symm ▸ is_open_set_pi (finset.finite_to_set _) hi)\n    (le_infᵢ fun a s ⟨t, ht, s_eq⟩ =>\n      generate_open.basic _ <| ⟨update (fun a => univ) a t, {a}, by simpa using ht, s_eq ▸ by ext f <;> simp [Set.pi]⟩)\n#align pi_eq_generate_from pi_eq_generate_from\n\n",
 "open_embedding_subtype_coe":
 "theorem is_open.open_embedding_subtype_coe {s : set α} (hs : is_open s) : open_embedding (coe : s → α) :=\n  { induced := rfl\n    inj := subtype.coe_injective\n    open_range := (Subtype.range_coe : range coe = s).symm ▸ hs }\n#align is_open.open_embedding_subtype_coe is_open.open_embedding_subtype_coe\n\n",
 "open_embedding_sigma_mk":
 "theorem open_embedding_sigma_mk {i : ι} : open_embedding (@sigma.mk ι σ i) :=\n  open_embedding_of_continuous_injective_open continuous_sigma_mk sigma_mk_injective is_open_map_sigma_mk\n#align open_embedding_sigma_mk open_embedding_sigma_mk\n\n",
 "open_embedding_sigma_map":
 "theorem open_embedding_sigma_map {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} (h : injective f₁) :\n    open_embedding (sigma.map f₁ f₂) ↔ ∀ i, open_embedding (f₂ i) := by\n  simp only [open_embedding_iff_embedding_open, is_open_map_sigma_map, embedding_sigma_map h, forall_and]\n#align open_embedding_sigma_map open_embedding_sigma_map\n\n",
 "open_embedding_inr":
 "theorem open_embedding_inr : open_embedding (@inr α β) :=\n  open_embedding_of_continuous_injective_open continuous_inr inr_injective is_open_map_inr\n#align open_embedding_inr open_embedding_inr\n\n",
 "open_embedding_inl":
 "theorem open_embedding_inl : open_embedding (@inl α β) :=\n  open_embedding_of_continuous_injective_open continuous_inl inl_injective is_open_map_inl\n#align open_embedding_inl open_embedding_inl\n\n",
 "of_cod_restrict":
 "theorem inducing.of_cod_restrict {f : α → β} {b : set β} (hb : ∀ a, f a ∈ b) (h : inducing (b.cod_restrict f hb)) :\n    inducing f :=\n  inducing_coe.comp h\n#align inducing.of_cod_restrict inducing.of_cod_restrict\n\n",
 "nhds_within_subtype_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem nhds_within_subtype_eq_bot_iff {s t : set α} {x : s} :\n    nhds_within («expr ⁻¹' » (coe : s → α) t) x = «expr⊥» ↔\n      «expr ⊓ » (nhds_within t (x : α)) ((filter.principal) s) = «expr⊥» :=\n  by rw [inf_principal_eq_bot_iff_comap, nhds_within, nhds_within, comap_inf, comap_principal, nhds_induced]\n#align nhds_within_subtype_eq_bot_iff nhds_within_subtype_eq_bot_iff\n\n",
 "nhds_to_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_to_mul (a : Additive α) : (nhds) (toMul a) = map toMul ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_to_mul nhds_to_mul\n\n",
 "nhds_to_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_to_dual (a : α) : (nhds) (toDual a) = map toDual ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_to_dual nhds_to_dual\n\n",
 "nhds_to_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_to_add (a : Multiplicative α) : (nhds) (toAdd a) = map toAdd ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_to_add nhds_to_add\n\n",
 "nhds_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_swap (a : α) (b : β) : (nhds) (a, b) = ((nhds) (b, a)).map prod.swap := by\n  rw [nhds_prod_eq, filter.prod_comm, nhds_prod_eq] <;> rfl\n#align nhds_swap nhds_swap\n\n",
 "nhds_subtype_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_subtype_eq_comap {a : α} {h : p a} : (nhds) (⟨a, h⟩ : subtype p) = comap coe ((nhds) a) :=\n  nhds_induced _ _\n#align nhds_subtype_eq_comap nhds_subtype_eq_comap\n\n",
 "nhds_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_subtype (s : set α) (a : { x // x ∈ s }) : (nhds) a = comap coe ((nhds) (a : α)) :=\n  nhds_induced coe a\n#align nhds_subtype nhds_subtype\n\n",
 "nhds_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_prod_eq {a : α} {b : β} : (nhds) (a, b) = filter.prod ((nhds) a) ((nhds) b) := by\n  rw [filter.prod, prod.topological_space, nhds_inf, nhds_induced, nhds_induced]\n#align nhds_prod_eq nhds_prod_eq\n\n",
 "nhds_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_pi {a : ∀ i, π i} : (nhds) a = pi fun i => (nhds) (a i) := by\n  simp only [nhds_infi, nhds_induced, filter.pi]\n#align nhds_pi nhds_pi\n\n",
 "nhds_of_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_of_mul (a : α) : (nhds) (ofMul a) = map ofMul ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_of_mul nhds_of_mul\n\n",
 "nhds_of_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_of_dual (a : α) : (nhds) (ofDual a) = map ofDual ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_of_dual nhds_of_dual\n\n",
 "nhds_of_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_of_add (a : α) : (nhds) (ofAdd a) = map ofAdd ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_of_add nhds_of_add\n\n",
 "nhds_ne_subtype_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_ne_subtype_ne_bot_iff {S : set α} {x : S} :\n    (nhds_within («expr ᶜ» {x}) x).ne_bot ↔\n      («expr ⊓ » (nhds_within («expr ᶜ» {x}) (x : α)) ((filter.principal) S)).ne_bot :=\n  by rw [ne_bot_iff, ne_bot_iff, not_iff_not, nhds_ne_subtype_eq_bot_iff]\n#align nhds_ne_subtype_ne_bot_iff nhds_ne_subtype_ne_bot_iff\n\n",
 "nhds_ne_subtype_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem nhds_ne_subtype_eq_bot_iff {S : set α} {x : S} :\n    nhds_within («expr ᶜ» {x}) x = «expr⊥» ↔\n      «expr ⊓ » (nhds_within («expr ᶜ» {x}) (x : α)) ((filter.principal) S) = «expr⊥» :=\n  by rw [← nhds_within_subtype_eq_bot_iff, preimage_compl, ← image_singleton, subtype.coe_injective.preimage_image]\n#align nhds_ne_subtype_eq_bot_iff nhds_ne_subtype_eq_bot_iff\n\n",
 "nhds_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem sigma.nhds_mk (i : ι) (x : σ i) : (nhds) (⟨i, x⟩ : sigma σ) = map (sigma.mk i) ((nhds) x) :=\n  (open_embedding_sigma_mk.map_nhds_eq x).symm\n#align sigma.nhds_mk sigma.nhds_mk\n\n",
 "nhds_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_inr (x : β) : (nhds) (inr x : Sum α β) = map inr ((nhds) x) :=\n  (open_embedding_inr.map_nhds_eq _).symm\n#align nhds_inr nhds_inr\n\n",
 "nhds_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_inl (x : α) : (nhds) (inl x : Sum α β) = map inl ((nhds) x) :=\n  (open_embedding_inl.map_nhds_eq _).symm\n#align nhds_inl nhds_inl\n\n",
 "nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem sigma.nhds_eq (x : sigma σ) : (nhds) x = map (sigma.mk x.1) ((nhds) x.2) :=\n  by\n  cases x\n  apply sigma.nhds_mk\n#align sigma.nhds_eq sigma.nhds_eq\n\n",
 "mk_left":
 "@[continuity]\ntheorem continuous.prod.mk_left (b : β) : continuous fun a : α => (a, b) :=\n  continuous_id'.prod_mk continuous_const\n#align continuous.prod.mk_left continuous.prod.mk_left\n\n",
 "mk":
 "@[continuity]\ntheorem continuous.prod.mk (a : α) : continuous fun b : β => (a, b) :=\n  continuous_const.prod_mk continuous_id'\n#align continuous.prod.mk continuous.prod.mk\n\n",
 "mem_nhds_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-\nThe 𝓝 filter and the subspace topology.\n-/\ntheorem mem_nhds_subtype (s : set α) (a : { x // x ∈ s }) (t : set { x // x ∈ s }) :\n    t ∈ (nhds) a ↔ ∃ u ∈ (nhds) (a : α), «expr ⁻¹' » coe u ⊆ t :=\n  mem_nhds_induced coe a t\n#align mem_nhds_subtype mem_nhds_subtype\n\n",
 "mem_nhds_prod_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem mem_nhds_prod_iff' {a : α} {b : β} {s : set (α × β)} :\n    s ∈ (nhds) (a, b) ↔ ∃ (u : set α)(v : set β), is_open u ∧ a ∈ u ∧ is_open v ∧ b ∈ v ∧ finset.product u v ⊆ s :=\n  by\n  rw [mem_nhds_prod_iff]\n  constructor\n  · rintro ⟨u, Hu, v, Hv, h⟩\n    rcases mem_nhds_iff.1 Hu with ⟨u', u'u, u'_open, Hu'⟩\n    rcases mem_nhds_iff.1 Hv with ⟨v', v'v, v'_open, Hv'⟩\n    exact ⟨u', v', u'_open, Hu', v'_open, Hv', (Set.prod_mono u'u v'v).trans h⟩\n  · rintro ⟨u, v, u_open, au, v_open, bv, huv⟩\n    exact ⟨u, u_open.mem_nhds au, v, v_open.mem_nhds bv, huv⟩\n#align mem_nhds_prod_iff' mem_nhds_prod_iff'\n\n",
 "mem_nhds_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem mem_nhds_prod_iff {a : α} {b : β} {s : set (α × β)} :\n    s ∈ (nhds) (a, b) ↔ ∃ u ∈ (nhds) a, ∃ v ∈ (nhds) b, finset.product u v ⊆ s := by rw [nhds_prod_eq, mem_prod_iff]\n#align mem_nhds_prod_iff mem_nhds_prod_iff\n\n",
 "mem_nhds_of_pi_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_nhds_of_pi_mem_nhds {I : set ι} {s : ∀ i, set (π i)} (a : ∀ i, π i) (hs : I.pi s ∈ (nhds) a) {i : ι}\n    (hi : i ∈ I) : s i ∈ (nhds) (a i) := by\n  rw [nhds_pi] at hs\n  exact mem_of_pi_mem_pi hs hi\n#align mem_nhds_of_pi_mem_nhds mem_nhds_of_pi_mem_nhds\n\n",
 "mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_nhds_iff {a : cofinite_topology α} {s : set (cofinite_topology α)} :\n    s ∈ (nhds) a ↔ a ∈ s ∧ («expr ᶜ» s).finite := by simp [nhds_eq]\n#align mem_nhds_iff mem_nhds_iff\n\n",
 "map_snd_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- `prod.snd` maps neighborhood of `x : α × β` within the section `prod.fst ⁻¹' {x.1}`\nto `𝓝 x.2`. -/\ntheorem map_snd_nhds_within (x : α × β) : map prod.snd (nhds_within («expr ⁻¹' » prod.fst {x.1}) x) = (nhds) x.2 :=\n  by\n  refine' le_antisymm (continuous_at_snd.mono_left inf_le_left) fun s hs => _\n  rcases x with ⟨x, y⟩\n  rw [mem_map, nhds_within, mem_inf_principal, mem_nhds_prod_iff] at hs\n  rcases hs with ⟨u, hu, v, hv, H⟩\n  simp only [prod_subset_iff, mem_singleton_iff, mem_set_of_eq, mem_preimage] at H\n  exact mem_of_superset hv fun z hz => H _ (mem_of_mem_nhds hu) _ hz rfl\n#align map_snd_nhds_within map_snd_nhds_within\n\n",
 "map_snd_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem map_snd_nhds (x : α × β) : map prod.snd ((nhds) x) = (nhds) x.2 :=\n  le_antisymm continuous_at_snd <| (map_snd_nhds_within x).symm.trans_le (map_mono inf_le_left)\n#align map_snd_nhds map_snd_nhds\n\n",
 "map_nhds_subtype_coe_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem map_nhds_subtype_coe_eq {a : α} (ha : p a) (h : { a | p a } ∈ (nhds) a) :\n    map (coe : subtype p → α) ((nhds) ⟨a, ha⟩) = (nhds) a :=\n  map_nhds_induced_of_mem <| by simpa only [subtype.coe_mk, Subtype.range_coe] using h\n#align map_nhds_subtype_coe_eq map_nhds_subtype_coe_eq\n\n",
 "map_mem_closure₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem map_mem_closure₂ {f : α → β → γ} {a : α} {b : β} {s : set α} {t : set β} {u : set γ}\n    (hf : continuous (uncurry f)) (ha : a ∈ closure s) (hb : b ∈ closure t) (h : ∀ a ∈ s, ∀ b ∈ t, f a b ∈ u) :\n    f a b ∈ closure u :=\n  have H₁ : (a, b) ∈ closure (finset.product s t) := by simpa only [closure_prod_eq] using mk_mem_prod ha hb\n  have H₂ : MapsTo (uncurry f) (finset.product s t) u := forall_prod_set.2 h\n  H₂.closure hf H₁\n#align map_mem_closure₂ map_mem_closure₂\n\n",
 "map_fst_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- `prod.fst` maps neighborhood of `x : α × β` within the section `prod.snd ⁻¹' {x.2}`\nto `𝓝 x.1`. -/\ntheorem map_fst_nhds_within (x : α × β) : map prod.fst (nhds_within («expr ⁻¹' » prod.snd {x.2}) x) = (nhds) x.1 :=\n  by\n  refine' le_antisymm (continuous_at_fst.mono_left inf_le_left) fun s hs => _\n  rcases x with ⟨x, y⟩\n  rw [mem_map, nhds_within, mem_inf_principal, mem_nhds_prod_iff] at hs\n  rcases hs with ⟨u, hu, v, hv, H⟩\n  simp only [prod_subset_iff, mem_singleton_iff, mem_set_of_eq, mem_preimage] at H\n  exact mem_of_superset hu fun z hz => H _ hz _ (mem_of_mem_nhds hv) rfl\n#align map_fst_nhds_within map_fst_nhds_within\n\n",
 "map_fst_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem map_fst_nhds (x : α × β) : map prod.fst ((nhds) x) = (nhds) x.1 :=\n  le_antisymm continuous_at_fst <| (map_fst_nhds_within x).symm.trans_le (map_mono inf_le_left)\n#align map_fst_nhds map_fst_nhds\n\n",
 "is_open_sum_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_open_sum_iff {s : set (Sum α β)} : is_open s ↔ is_open («expr ⁻¹' » inl s) ∧ is_open («expr ⁻¹' » inr s) :=\n  iff.rfl\n#align is_open_sum_iff is_open_sum_iff\n\n",
 "is_open_sigma_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_open_sigma_iff {s : set (sigma σ)} : is_open s ↔ ∀ i, is_open («expr ⁻¹' » (sigma.mk i) s) := by\n  simp only [is_open_supr_iff, is_open_coinduced]\n#align is_open_sigma_iff is_open_sigma_iff\n\n",
 "is_open_sigma_fst_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_open_sigma_fst_preimage (s : set ι) : is_open («expr ⁻¹' » sigma.fst s : set (Σa, σ a)) :=\n  by\n  rw [← bUnion_of_singleton s, preimage_Union₂]\n  simp only [← range_sigma_mk]\n  exact is_open_bUnion fun _ _ => is_open_range_sigma_mk\n#align is_open_sigma_fst_preimage is_open_sigma_fst_preimage\n\n",
 "is_open_set_pi":
 "theorem is_open_set_pi {i : set ι} {s : ∀ a, set (π a)} (hi : i.finite) (hs : ∀ a ∈ i, is_open (s a)) :\n    is_open (pi i s) := by rw [pi_def] <;> exact is_open_bInter hi fun a ha => (hs _ ha).preimage (continuous_apply _)\n#align is_open_set_pi is_open_set_pi\n\n",
 "is_open_range_sigma_mk":
 "theorem is_open_range_sigma_mk {i : ι} : is_open (Set.range (@sigma.mk ι σ i)) :=\n  is_open_map_sigma_mk.is_open_range\n#align is_open_range_sigma_mk is_open_range_sigma_mk\n\n",
 "is_open_range_inr":
 "theorem is_open_range_inr : is_open (range (inr : β → Sum α β)) :=\n  open_embedding_inr.2\n#align is_open_range_inr is_open_range_inr\n\n",
 "is_open_range_inl":
 "theorem is_open_range_inl : is_open (range (inl : α → Sum α β)) :=\n  open_embedding_inl.2\n#align is_open_range_inl is_open_range_inl\n\n",
 "is_open_prod_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/-- A product set is open in a product space if and only if each factor is open, or one of them is\nempty -/\ntheorem is_open_prod_iff' {s : set α} {t : set β} :\n    is_open (finset.product s t) ↔ is_open s ∧ is_open t ∨ s = ∅ ∨ t = ∅ :=\n  by\n  cases' (finset.product s t).eq_empty_or_nonempty with h h\n  · simp [h, prod_eq_empty_iff.1 h]\n  · have st : s.nonempty ∧ t.nonempty := prod_nonempty_iff.1 h\n    constructor\n    · intro (H : is_open (finset.product s t))\n      refine' or.inl ⟨_, _⟩\n      show is_open s\n      · rw [← fst_image_prod s st.2]\n        exact is_open_map_fst _ H\n      show is_open t\n      · rw [← snd_image_prod st.1 t]\n        exact is_open_map_snd _ H\n    · intro H\n      simp only [st.1.ne_empty, st.2.ne_empty, not_false_iff, or_false_iff] at H\n      exact H.1.prod H.2\n#align is_open_prod_iff' is_open_prod_iff'\n\n",
 "is_open_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem is_open_prod_iff {s : set (α × β)} :\n    is_open s ↔\n      ∀ a b, (a, b) ∈ s → ∃ (u : set α)(v : set β), is_open u ∧ is_open v ∧ a ∈ u ∧ b ∈ v ∧ finset.product u v ⊆ s :=\n  by\n  rw [is_open_iff_nhds]\n  simp_rw [le_principal_iff, prod.forall, ((nhds_basis_opens _).prod_nhds (nhds_basis_opens _)).mem_iff, prod.exists,\n    exists_prop]\n  simp only [and_assoc', and_left_comm]\n#align is_open_prod_iff is_open_prod_iff\n\n",
 "is_open_map_to_mul":
 "theorem is_open_map_to_mul : is_open_map (toMul : Additive α → α) :=\n  is_open_map.id\n#align is_open_map_to_mul is_open_map_to_mul\n\n",
 "is_open_map_to_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem is_open_map_to_dual : is_open_map (toDual : α → «expr ᵒᵈ» α) :=\n  is_open_map.id\n#align is_open_map_to_dual is_open_map_to_dual\n\n",
 "is_open_map_to_add":
 "theorem is_open_map_to_add : is_open_map (toAdd : Multiplicative α → α) :=\n  is_open_map.id\n#align is_open_map_to_add is_open_map_to_add\n\n",
 "is_open_map_sum_elim":
 "@[simp]\ntheorem is_open_map_sum_elim {f : α → γ} {g : β → γ} : is_open_map (sum.elim f g) ↔ is_open_map f ∧ is_open_map g := by\n  simp only [is_open_map_sum, elim_inl, elim_inr]\n#align is_open_map_sum_elim is_open_map_sum_elim\n\n",
 "is_open_map_sum":
 "theorem is_open_map_sum {f : Sum α β → γ} :\n    is_open_map f ↔ (is_open_map fun a => f (inl a)) ∧ is_open_map fun b => f (inr b) := by\n  simp only [is_open_map_iff_nhds_le, sum.forall, nhds_inl, nhds_inr, filter.map_map]\n#align is_open_map_sum is_open_map_sum\n\n",
 "is_open_map_subtype_coe":
 "theorem is_open.is_open_map_subtype_coe {s : set α} (hs : is_open s) : is_open_map (coe : s → α) :=\n  hs.open_embedding_subtype_coe.is_open_map\n#align is_open.is_open_map_subtype_coe is_open.is_open_map_subtype_coe\n\n",
 "is_open_map_snd":
 "/-- The second projection in a product of topological spaces sends open sets to open sets. -/\ntheorem is_open_map_snd : is_open_map (@prod.snd α β) :=\n  is_open_map_iff_nhds_le.2 fun x => (map_snd_nhds x).ge\n#align is_open_map_snd is_open_map_snd\n\n",
 "is_open_map_sigma_mk":
 "theorem is_open_map_sigma_mk {i : ι} : is_open_map (@sigma.mk ι σ i) :=\n  by\n  intro s hs\n  rw [is_open_sigma_iff]\n  intro j\n  rcases eq_or_ne j i with (rfl | hne)\n  · rwa [Set.preimage_image_eq _ sigma_mk_injective]\n  · rw [preimage_image_sigma_mk_of_ne hne]\n    exact is_open_empty\n#align is_open_map_sigma_mk is_open_map_sigma_mk\n\n",
 "is_open_map_sigma_map":
 "theorem is_open_map_sigma_map {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} :\n    is_open_map (sigma.map f₁ f₂) ↔ ∀ i, is_open_map (f₂ i) :=\n  is_open_map_sigma.trans <| forall_congr' fun i => (@open_embedding_sigma_mk _ _ _ (f₁ i)).is_open_map_iff.symm\n#align is_open_map_sigma_map is_open_map_sigma_map\n\n",
 "is_open_map_sigma":
 "theorem is_open_map_sigma {f : sigma σ → α} : is_open_map f ↔ ∀ i, is_open_map fun a => f ⟨i, a⟩ := by\n  simp only [is_open_map_iff_nhds_le, sigma.forall, sigma.nhds_eq, map_map]\n#align is_open_map_sigma is_open_map_sigma\n\n",
 "is_open_map_of_mul":
 "theorem is_open_map_of_mul : is_open_map (ofMul : α → Additive α) :=\n  is_open_map.id\n#align is_open_map_of_mul is_open_map_of_mul\n\n",
 "is_open_map_of_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem is_open_map_of_dual : is_open_map (ofDual : «expr ᵒᵈ» α → α) :=\n  is_open_map.id\n#align is_open_map_of_dual is_open_map_of_dual\n\n",
 "is_open_map_of_add":
 "theorem is_open_map_of_add : is_open_map (ofAdd : α → Multiplicative α) :=\n  is_open_map.id\n#align is_open_map_of_add is_open_map_of_add\n\n",
 "is_open_map_inr":
 "theorem is_open_map_inr : is_open_map (@inr α β) := fun u hu => by\n  simpa [is_open_sum_iff, preimage_image_eq u sum.inr_injective]\n#align is_open_map_inr is_open_map_inr\n\n",
 "is_open_map_inl":
 "theorem is_open_map_inl : is_open_map (@inl α β) := fun u hu => by\n  simpa [is_open_sum_iff, preimage_image_eq u sum.inl_injective]\n#align is_open_map_inl is_open_map_inl\n\n",
 "is_open_map_fst":
 "/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem is_open_map_fst : is_open_map (@prod.fst α β) :=\n  is_open_map_iff_nhds_le.2 fun x => (map_fst_nhds x).ge\n#align is_open_map_fst is_open_map_fst\n\n",
 "is_open_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_open_iff' {s : set (cofinite_topology α)} : is_open s ↔ s = ∅ ∨ («expr ᶜ» s).finite := by\n  simp only [is_open_iff, nonempty_iff_ne_empty, or_iff_not_imp_left]\n#align is_open_iff' is_open_iff'\n\n",
 "is_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_open_iff {s : set (cofinite_topology α)} : is_open s ↔ s.nonempty → («expr ᶜ» s).finite :=\n  iff.rfl\n#align is_open_iff is_open_iff\n\n",
 "is_closed_sigma_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_closed_sigma_iff {s : set (sigma σ)} : is_closed s ↔ ∀ i, is_closed («expr ⁻¹' » (sigma.mk i) s) := by\n  simp only [← is_open_compl_iff, is_open_sigma_iff, preimage_compl]\n#align is_closed_sigma_iff is_closed_sigma_iff\n\n",
 "is_closed_set_pi":
 "theorem is_closed_set_pi {i : set ι} {s : ∀ a, set (π a)} (hs : ∀ a ∈ i, is_closed (s a)) : is_closed (pi i s) := by\n  rw [pi_def] <;> exact is_closed_Inter fun a => is_closed_Inter fun ha => (hs _ ha).preimage (continuous_apply _)\n#align is_closed_set_pi is_closed_set_pi\n\n",
 "is_closed_range_sigma_mk":
 "theorem is_closed_range_sigma_mk {i : ι} : is_closed (Set.range (@sigma.mk ι σ i)) :=\n  is_closed_map_sigma_mk.closed_range\n#align is_closed_range_sigma_mk is_closed_range_sigma_mk\n\n",
 "is_closed_range_inr":
 "theorem is_closed_range_inr : is_closed (range (inr : β → Sum α β)) :=\n  by\n  rw [← is_open_compl_iff, compl_range_inr]\n  exact is_open_range_inl\n#align is_closed_range_inr is_closed_range_inr\n\n",
 "is_closed_range_inl":
 "theorem is_closed_range_inl : is_closed (range (inl : α → Sum α β)) :=\n  by\n  rw [← is_open_compl_iff, compl_range_inl]\n  exact is_open_range_inr\n#align is_closed_range_inl is_closed_range_inl\n\n",
 "is_closed_map_to_mul":
 "theorem is_closed_map_to_mul : is_closed_map (toMul : Additive α → α) :=\n  is_closed_map.id\n#align is_closed_map_to_mul is_closed_map_to_mul\n\n",
 "is_closed_map_to_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem is_closed_map_to_dual : is_closed_map (toDual : α → «expr ᵒᵈ» α) :=\n  is_closed_map.id\n#align is_closed_map_to_dual is_closed_map_to_dual\n\n",
 "is_closed_map_to_add":
 "theorem is_closed_map_to_add : is_closed_map (toAdd : Multiplicative α → α) :=\n  is_closed_map.id\n#align is_closed_map_to_add is_closed_map_to_add\n\n",
 "is_closed_map_sigma_mk":
 "theorem is_closed_map_sigma_mk {i : ι} : is_closed_map (@sigma.mk ι σ i) :=\n  by\n  intro s hs\n  rw [is_closed_sigma_iff]\n  intro j\n  rcases eq_or_ne j i with (rfl | hne)\n  · rwa [Set.preimage_image_eq _ sigma_mk_injective]\n  · rw [preimage_image_sigma_mk_of_ne hne]\n    exact is_closed_empty\n#align is_closed_map_sigma_mk is_closed_map_sigma_mk\n\n",
 "is_closed_map_of_mul":
 "theorem is_closed_map_of_mul : is_closed_map (ofMul : α → Additive α) :=\n  is_closed_map.id\n#align is_closed_map_of_mul is_closed_map_of_mul\n\n",
 "is_closed_map_of_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem is_closed_map_of_dual : is_closed_map (ofDual : «expr ᵒᵈ» α → α) :=\n  is_closed_map.id\n#align is_closed_map_of_dual is_closed_map_of_dual\n\n",
 "is_closed_map_of_add":
 "theorem is_closed_map_of_add : is_closed_map (ofAdd : α → Multiplicative α) :=\n  is_closed_map.id\n#align is_closed_map_of_add is_closed_map_of_add\n\n",
 "is_closed_iff":
 "theorem is_closed_iff {s : set (cofinite_topology α)} : is_closed s ↔ s = univ ∨ s.finite := by\n  simp [← is_open_compl_iff, is_open_iff']\n#align is_closed_iff is_closed_iff\n\n",
 "interior_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem interior_prod_eq (s : set α) (t : set β) :\n    interior (finset.product s t) = finset.product (interior s) (interior t) :=\n  Set.ext fun ⟨a, b⟩ => by simp only [mem_interior_iff_mem_nhds, mem_prod, prod_mem_nhds_iff]\n#align interior_prod_eq interior_prod_eq\n\n",
 "interior_pi_set":
 "theorem interior_pi_set {I : set ι} (hI : I.finite) {s : ∀ i, set (π i)} :\n    interior (pi I s) = I.pi fun i => interior (s i) := by\n  ext a\n  simp only [Set.mem_pi, mem_interior_iff_mem_nhds, set_pi_mem_nhds_iff hI]\n#align interior_pi_set interior_pi_set\n\n",
 "inducing_sigma_map":
 "theorem inducing_sigma_map {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} (h₁ : injective f₁) :\n    inducing (sigma.map f₁ f₂) ↔ ∀ i, inducing (f₂ i) := by\n  simp only [inducing_iff_nhds, sigma.forall, sigma.nhds_mk, sigma.map, ← map_sigma_mk_comap h₁,\n    map_inj sigma_mk_injective]\n#align inducing_sigma_map inducing_sigma_map\n\n",
 "inducing_infi_to_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\nwhere `Π i, π i` is endowed with the usual product topology. -/\ntheorem inducing_infi_to_pi {X : Type _} (f : ∀ i, X → π i) :\n    @inducing X (∀ i, π i)\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (induced (f i) infer_instance))\n      _ fun x i => f i x :=\n  by\n  constructor\n  erw [induced_infi]\n  congr 1\n  funext\n  erw [induced_compose]\n#align inducing_infi_to_pi inducing_infi_to_pi\n\n",
 "inducing_coe":
 "theorem inducing_coe {b : set β} : inducing (coe : b → β) :=\n  ⟨rfl⟩\n#align inducing_coe inducing_coe\n\n",
 "fst''":
 "/-- Precomposing `f` with `prod.fst` is continuous at `x : α × β` -/\ntheorem continuous_at.fst'' {f : α → γ} {x : α × β} (hf : continuous_at f x.fst) :\n    continuous_at (fun x : α × β => f x.fst) x :=\n  hf.comp continuous_at_fst\n#align continuous_at.fst'' continuous_at.fst''\n\n",
 "fst'":
 "/-- Precomposing `f` with `prod.fst` is continuous at `(x, y)` -/\ntheorem continuous_at.fst' {f : α → γ} {x : α} {y : β} (hf : continuous_at f x) :\n    continuous_at (fun x : α × β => f x.fst) (x, y) :=\n  continuous_at.comp hf continuous_at_fst\n#align continuous_at.fst' continuous_at.fst'\n\n",
 "fst":
 "/-- Postcomposing `f` with `prod.fst` is continuous at `x` -/\ntheorem continuous_at.fst {f : α → β × γ} {x : α} (hf : continuous_at f x) : continuous_at (fun a : α => (f a).1) x :=\n  continuous_at_fst.comp hf\n#align continuous_at.fst continuous_at.fst\n\n",
 "frontier_univ_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem frontier_univ_prod_eq (s : set β) :\n    frontier (finset.product (univ : set α) s) = finset.product univ (frontier s) := by simp [frontier_prod_eq]\n#align frontier_univ_prod_eq frontier_univ_prod_eq\n\n",
 "frontier_prod_univ_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem frontier_prod_univ_eq (s : set α) :\n    frontier (finset.product s (univ : set β)) = finset.product (frontier s) univ := by simp [frontier_prod_eq]\n#align frontier_prod_univ_eq frontier_prod_univ_eq\n\n",
 "frontier_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem frontier_prod_eq (s : set α) (t : set β) :\n    frontier (finset.product s t) = finset.product (closure s) (frontier t) ∪ finset.product (frontier s) (closure t) :=\n  by simp only [frontier, closure_prod_eq, interior_prod_eq, prod_diff_prod]\n#align frontier_prod_eq frontier_prod_eq\n\n",
 "fin_insert_nth":
 "theorem continuous.fin_insert_nth {n} {π : fin (n + 1) → Type _} [∀ i, topological_space (π i)] (i : fin (n + 1))\n    {f : α → π i} (hf : continuous f) {g : α → ∀ j : fin n, π (i.succ_above j)} (hg : continuous g) :\n    continuous fun a => i.insert_nth (f a) (g a) :=\n  continuous_iff_continuous_at.2 fun a => hf.continuous_at.fin_insert_nth i hg.continuous_at\n#align continuous.fin_insert_nth continuous.fin_insert_nth\n\n",
 "exists_nhds_square":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/-- Given a neighborhood `s` of `(x, x)`, then `(x, x)` has a square open neighborhood\n  that is a subset of `s`. -/\ntheorem exists_nhds_square {s : set (α × α)} {x : α} (hx : s ∈ (nhds) (x, x)) :\n    ∃ U : set α, is_open U ∧ x ∈ U ∧ finset.product U U ⊆ s := by\n  simpa [nhds_prod_eq, (nhds_basis_opens x).prod_self.mem_iff, and_assoc, and_left_comm] using hx\n#align exists_nhds_square exists_nhds_square\n\n",
 "exists_finset_piecewise_mem_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_finset_piecewise_mem_of_mem_nhds [decidable_eq ι] {s : set (∀ a, π a)} {x : ∀ a, π a} (hs : s ∈ (nhds) x)\n    (y : ∀ a, π a) : ∃ I : Finset ι, I.piecewise x y ∈ s :=\n  by\n  simp only [nhds_pi, filter.mem_pi'] at hs\n  rcases hs with ⟨I, t, htx, hts⟩\n  refine' ⟨I, hts fun i hi => _⟩\n  simpa [Finset.mem_coe.1 hi] using mem_of_mem_nhds (htx i)\n#align exists_finset_piecewise_mem_of_mem_nhds exists_finset_piecewise_mem_of_mem_nhds\n\n",
 "embedding_subtype_coe":
 "theorem embedding_subtype_coe : embedding (coe : subtype p → α) :=\n  ⟨⟨rfl⟩, subtype.coe_injective⟩\n#align embedding_subtype_coe embedding_subtype_coe\n\n",
 "embedding_sigma_mk":
 "theorem embedding_sigma_mk {i : ι} : embedding (@sigma.mk ι σ i) :=\n  closed_embedding_sigma_mk.1\n#align embedding_sigma_mk embedding_sigma_mk\n\n",
 "embedding_sigma_map":
 "theorem embedding_sigma_map {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} (h : injective f₁) :\n    embedding (sigma.map f₁ f₂) ↔ ∀ i, embedding (f₂ i) := by\n  simp only [embedding_iff, injective.sigma_map, inducing_sigma_map h, forall_and, h.sigma_map_iff]\n#align embedding_sigma_map embedding_sigma_map\n\n",
 "embedding_inr":
 "theorem embedding_inr : embedding (@inr α β) :=\n  open_embedding_inr.1\n#align embedding_inr embedding_inr\n\n",
 "embedding_inl":
 "theorem embedding_inl : embedding (@inl α β) :=\n  open_embedding_inl.1\n#align embedding_inl embedding_inl\n\n",
 "embedding_graph":
 "theorem embedding_graph {f : α → β} (hf : continuous f) : embedding fun x => (x, f x) :=\n  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id\n#align embedding_graph embedding_graph\n\n",
 "discrete_topology_subtype_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem discrete_topology_subtype_iff {S : set α} :\n    discrete_topology S ↔ ∀ x ∈ S, «expr ⊓ » (nhds_within.ne x) ((filter.principal) S) = «expr⊥» := by\n  simp_rw [discrete_topology_iff_nhds_ne, SetCoe.forall', nhds_ne_subtype_eq_bot_iff]\n#align discrete_topology_subtype_iff discrete_topology_subtype_iff\n\n",
 "dense_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem subtype.dense_iff {s : set α} {t : set s} : dense t ↔ s ⊆ closure («expr '' » coe t) :=\n  by\n  rw [inducing_coe.dense_iff, SetCoe.forall]\n  rfl\n#align subtype.dense_iff subtype.dense_iff\n\n",
 "curry_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually.curry_nhds {p : α × β → Prop} {x : α} {y : β}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        ((nhds) (x, y)) (p x)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n      («expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        ((nhds) y) (p (x', y'))) :=\n  by\n  rw [nhds_prod_eq] at h\n  exact h.curry\n#align filter.eventually.curry_nhds filter.eventually.curry_nhds\n\n",
 "continuous_update":
 "/-- `update f i x` is continuous in `(f, x)`. -/\n@[continuity]\ntheorem continuous_update [decidable_eq ι] (i : ι) : continuous fun f : (∀ j, π j) × π i => update f.1 i f.2 :=\n  continuous_fst.update i continuous_snd\n#align continuous_update continuous_update\n\n",
 "continuous_uncurry_right":
 "theorem continuous_uncurry_right {f : α → β → γ} (b : β) (h : continuous (uncurry f)) : continuous fun a => f a b :=\n  show continuous (uncurry f ∘ fun a => (a, b)) from h.comp (by continuity)\n#align continuous_uncurry_right continuous_uncurry_right\n\n",
 "continuous_uncurry_of_discrete_topology_left":
 "theorem continuous_uncurry_of_discrete_topology_left [discrete_topology α] {f : α → β → γ} (h : ∀ a, continuous (f a)) :\n    continuous (uncurry f) :=\n  continuous_iff_continuous_at.2 fun ⟨a, b⟩ => by\n    simp only [continuous_at, nhds_prod_eq, nhds_discrete α, pure_prod, tendsto_map'_iff, (· ∘ ·), uncurry,\n      (h a).tendsto]\n#align continuous_uncurry_of_discrete_topology_left continuous_uncurry_of_discrete_topology_left\n\n",
 "continuous_uncurry_of_discrete_topology":
 "/-- If a function `f x y` is such that `y ↦ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem continuous_uncurry_of_discrete_topology [discrete_topology α] {f : α → β → γ} (hf : ∀ a, continuous (f a)) :\n    continuous (uncurry f) := by\n  apply continuous_iff_continuous_at.2\n  rintro ⟨a, x⟩\n  change map _ _ ≤ _\n  rw [nhds_prod_eq, nhds_discrete, filter.map_pure_prod]\n  exact (hf a).continuous_at\n#align continuous_uncurry_of_discrete_topology continuous_uncurry_of_discrete_topology\n\n",
 "continuous_uncurry_left":
 "theorem continuous_uncurry_left {f : α → β → γ} (a : α) (h : continuous (uncurry f)) : continuous (f a) :=\n  show continuous (uncurry f ∘ fun b => (a, b)) from h.comp (by continuity)\n#align continuous_uncurry_left continuous_uncurry_left\n\n",
 "continuous_ulift_up":
 "@[continuity]\ntheorem continuous_ulift_up [topological_space α] : continuous (ulift.up : α → ULift.{v, u} α) :=\n  continuous_induced_rng.2 continuous_id\n#align continuous_ulift_up continuous_ulift_up\n\n",
 "continuous_ulift_down":
 "@[continuity]\ntheorem continuous_ulift_down [topological_space α] : continuous (ulift.down : ULift.{v, u} α → α) :=\n  continuous_induced_dom\n#align continuous_ulift_down continuous_ulift_down\n\n",
 "continuous_to_mul":
 "theorem continuous_to_mul : continuous (toMul : Additive α → α) :=\n  continuous_id\n#align continuous_to_mul continuous_to_mul\n\n",
 "continuous_to_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem continuous_to_dual : continuous (toDual : α → «expr ᵒᵈ» α) :=\n  continuous_id\n#align continuous_to_dual continuous_to_dual\n\n",
 "continuous_to_add":
 "theorem continuous_to_add : continuous (toAdd : Multiplicative α → α) :=\n  continuous_id\n#align continuous_to_add continuous_to_add\n\n",
 "continuous_swap":
 "theorem continuous_swap : continuous (prod.swap : α × β → β × α) :=\n  continuous_snd.prod_mk continuous_fst\n#align continuous_swap continuous_swap\n\n",
 "continuous_sum_map":
 "@[simp]\ntheorem continuous_sum_map {f : α → β} {g : γ → δ} : continuous (sum.map f g) ↔ continuous f ∧ continuous g :=\n  continuous_sum_elim.trans <| embedding_inl.continuous_iff.symm.and embedding_inr.continuous_iff.symm\n#align continuous_sum_map continuous_sum_map\n\n",
 "continuous_sum_elim":
 "theorem continuous_sum_elim {f : α → γ} {g : β → γ} : continuous (sum.elim f g) ↔ continuous f ∧ continuous g := by\n  simp only [continuous_sup_dom, continuous_coinduced_dom, sum.elim_comp_inl, sum.elim_comp_inr]\n#align continuous_sum_elim continuous_sum_elim\n\n",
 "continuous_subtype_val":
 "@[continuity]\ntheorem continuous_subtype_val : continuous (@subtype.val α p) :=\n  continuous_induced_dom\n#align continuous_subtype_val continuous_subtype_val\n\n",
 "continuous_subtype_nhds_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_subtype_nhds_cover {ι : Sort _} {f : α → β} {c : ι → α → Prop}\n    (c_cover : ∀ x : α, ∃ i, { x | c i x } ∈ (nhds) x) (f_cont : ∀ i, continuous fun x : subtype (c i) => f x) :\n    continuous f :=\n  continuous_iff_continuous_at.mpr fun x =>\n    let ⟨i, (c_sets : { x | c i x } ∈ (nhds) x)⟩ := c_cover x\n    let x' : subtype (c i) := ⟨x, mem_of_mem_nhds c_sets⟩\n    calc\n      map f ((nhds) x) = map f (map coe ((nhds) x')) := congr_arg (map f) (map_nhds_subtype_coe_eq _ <| c_sets).symm\n      _ = map (fun x : subtype (c i) => f x) ((nhds) x') := rfl\n      _ ≤ (nhds) (f x) := continuous_iff_continuous_at.mp (f_cont i) x'\n      \n#align continuous_subtype_nhds_cover continuous_subtype_nhds_cover\n\n",
 "continuous_subtype_is_closed_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem continuous_subtype_is_closed_cover {ι : Sort _} {f : α → β} (c : ι → α → Prop)\n    (h_lf : locally_finite fun i => { x | c i x }) (h_is_closed : ∀ i, is_closed { x | c i x })\n    (h_cover : ∀ x, ∃ i, c i x) (f_cont : ∀ i, continuous fun x : subtype (c i) => f x) : continuous f :=\n  continuous_iff_is_closed.mpr fun s hs =>\n    by\n    have : ∀ i, is_closed («expr '' » (coe : { x | c i x } → α) («expr ⁻¹' » (f ∘ coe) s)) := fun i =>\n      (closed_embedding_subtype_coe (h_is_closed _)).is_closed_map _ (hs.preimage (f_cont i))\n    have :\n      is_closed\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr '' » (coe : { x | c i x } → α) («expr ⁻¹' » (f ∘ coe) s))) :=\n      locally_finite.is_closed_Union (h_lf.subset fun i x ⟨⟨x', hx'⟩, _, HEq⟩ => HEq ▸ hx') this\n    have :\n      «expr ⁻¹' » f s =\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr '' » (coe : { x | c i x } → α) («expr ⁻¹' » (f ∘ coe) s)) :=\n      by\n      apply Set.ext\n      have : ∀ x : α, f x ∈ s ↔ ∃ i : ι, c i x ∧ f x ∈ s := fun x =>\n        ⟨fun hx =>\n          let ⟨i, hi⟩ := h_cover x\n          ⟨i, hi, hx⟩,\n          fun ⟨i, hi, hx⟩ => hx⟩\n      simpa [and_comm, @and_left_comm (c _ _), ← exists_and_right]\n    rwa [this]\n#align continuous_subtype_is_closed_cover continuous_subtype_is_closed_cover\n\n",
 "continuous_subtype_coe":
 "theorem continuous_subtype_coe : continuous (coe : subtype p → α) :=\n  continuous_subtype_val\n#align continuous_subtype_coe continuous_subtype_coe\n\n",
 "continuous_snd":
 "@[continuity]\ntheorem continuous_snd : continuous (@prod.snd α β) :=\n  continuous_inf_dom_right continuous_induced_dom\n#align continuous_snd continuous_snd\n\n",
 "continuous_sigma_mk":
 "@[continuity]\ntheorem continuous_sigma_mk {i : ι} : continuous (@sigma.mk ι σ i) :=\n  continuous_supr_rng continuous_coinduced_rng\n#align continuous_sigma_mk continuous_sigma_mk\n\n",
 "continuous_sigma_map":
 "@[simp]\ntheorem continuous_sigma_map {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} :\n    continuous (sigma.map f₁ f₂) ↔ ∀ i, continuous (f₂ i) :=\n  continuous_sigma_iff.trans <| by simp only [sigma.map, embedding_sigma_mk.continuous_iff]\n#align continuous_sigma_map continuous_sigma_map\n\n",
 "continuous_sigma_iff":
 "/-- A map out of a sum type is continuous iff its restriction to each summand is. -/\n@[simp]\ntheorem continuous_sigma_iff {f : sigma σ → α} : continuous f ↔ ∀ i, continuous fun a => f ⟨i, a⟩ := by\n  simp only [continuous_supr_dom, continuous_coinduced_dom]\n#align continuous_sigma_iff continuous_sigma_iff\n\n",
 "continuous_sigma":
 "/-- A map out of a sum type is continuous if its restriction to each summand is. -/\n@[continuity]\ntheorem continuous_sigma {f : sigma σ → α} (hf : ∀ i, continuous fun a => f ⟨i, a⟩) : continuous f :=\n  continuous_sigma_iff.2 hf\n#align continuous_sigma continuous_sigma\n\n",
 "continuous_quotient_mk":
 "theorem continuous_quotient_mk : continuous (@Quotient.mk'' α s) :=\n  continuous_coinduced_rng\n#align continuous_quotient_mk continuous_quotient_mk\n\n",
 "continuous_quot_mk":
 "@[continuity]\ntheorem continuous_quot_mk : continuous (@Quot.mk α r) :=\n  continuous_coinduced_rng\n#align continuous_quot_mk continuous_quot_mk\n\n",
 "continuous_quot_lift":
 "@[continuity]\ntheorem continuous_quot_lift {f : α → β} (hr : ∀ a b, r a b → f a = f b) (h : continuous f) :\n    continuous (Quot.lift f hr : Quot r → β) :=\n  continuous_coinduced_dom.2 h\n#align continuous_quot_lift continuous_quot_lift\n\n",
 "continuous_prod_mk":
 "@[simp]\ntheorem continuous_prod_mk {f : α → β} {g : α → γ} : (continuous fun x => (f x, g x)) ↔ continuous f ∧ continuous g :=\n  ⟨fun h => ⟨h.fst, h.snd⟩, fun h => h.1.prod_mk h.2⟩\n#align continuous_prod_mk continuous_prod_mk\n\n",
 "continuous_pi_iff":
 "theorem continuous_pi_iff : continuous f ↔ ∀ i, continuous fun a => f a i := by\n  simp only [continuous_infi_rng, continuous_induced_rng]\n#align continuous_pi_iff continuous_pi_iff\n\n",
 "continuous_pi":
 "@[continuity]\ntheorem continuous_pi (h : ∀ i, continuous fun a => f a i) : continuous f :=\n  continuous_pi_iff.2 h\n#align continuous_pi continuous_pi\n\n",
 "continuous_of_mul":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Patrick Massot\n-/\ntheorem continuous_of_mul : continuous (ofMul : α → Additive α) :=\n  continuous_id\n#align continuous_of_mul continuous_of_mul\n\n",
 "continuous_of_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem continuous_of_dual : continuous (ofDual : «expr ᵒᵈ» α → α) :=\n  continuous_id\n#align continuous_of_dual continuous_of_dual\n\n",
 "continuous_of_add":
 "theorem continuous_of_add : continuous (ofAdd : α → Multiplicative α) :=\n  continuous_id\n#align continuous_of_add continuous_of_add\n\n",
 "continuous_inr":
 "@[continuity]\ntheorem continuous_inr : continuous (@inr α β) :=\n  continuous_sup_rng_right continuous_coinduced_rng\n#align continuous_inr continuous_inr\n\n",
 "continuous_inl":
 "@[continuity]\ntheorem continuous_inl : continuous (@inl α β) :=\n  continuous_sup_rng_left continuous_coinduced_rng\n#align continuous_inl continuous_inl\n\n",
 "continuous_inf_dom_right₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- A version of `continuous_inf_dom_right` for binary functions -/\ntheorem continuous_inf_dom_right₂ {α β γ} {f : α → β → γ} {ta1 ta2 : topological_space α}\n    {tb1 tb2 : topological_space β} {tc1 : topological_space γ}\n    (h : by haveI := ta2 <;> haveI := tb2 <;> exact continuous fun p : α × β => f p.1 p.2) : by\n    haveI := «expr ⊓ » ta1 ta2 <;> haveI := «expr ⊓ » tb1 tb2 <;> exact continuous fun p : α × β => f p.1 p.2 :=\n  by\n  have ha := @continuous_inf_dom_right _ _ id ta1 ta2 ta2 (@continuous_id _ (id _))\n  have hb := @continuous_inf_dom_right _ _ id tb1 tb2 tb2 (@continuous_id _ (id _))\n  have h_continuous_id := @continuous.prod_map _ _ _ _ ta2 tb2 («expr ⊓ » ta1 ta2) («expr ⊓ » tb1 tb2) _ _ ha hb\n  exact @continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id\n#align continuous_inf_dom_right₂ continuous_inf_dom_right₂\n\n",
 "continuous_inf_dom_left₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- A version of `continuous_inf_dom_left` for binary functions -/\ntheorem continuous_inf_dom_left₂ {α β γ} {f : α → β → γ} {ta1 ta2 : topological_space α} {tb1 tb2 : topological_space β}\n    {tc1 : topological_space γ} (h : by haveI := ta1 <;> haveI := tb1 <;> exact continuous fun p : α × β => f p.1 p.2) :\n    by haveI := «expr ⊓ » ta1 ta2 <;> haveI := «expr ⊓ » tb1 tb2 <;> exact continuous fun p : α × β => f p.1 p.2 :=\n  by\n  have ha := @continuous_inf_dom_left _ _ id ta1 ta2 ta1 (@continuous_id _ (id _))\n  have hb := @continuous_inf_dom_left _ _ id tb1 tb2 tb1 (@continuous_id _ (id _))\n  have h_continuous_id := @continuous.prod_map _ _ _ _ ta1 tb1 («expr ⊓ » ta1 ta2) («expr ⊓ » tb1 tb2) _ _ ha hb\n  exact @continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id\n#align continuous_inf_dom_left₂ continuous_inf_dom_left₂\n\n",
 "continuous_inclusion":
 "theorem continuous_inclusion {s t : set α} (h : s ⊆ t) : continuous (inclusion h) :=\n  continuous_id.subtype_map h\n#align continuous_inclusion continuous_inclusion\n\n",
 "continuous_fst":
 "@[continuity]\ntheorem continuous_fst : continuous (@prod.fst α β) :=\n  continuous_inf_dom_left continuous_induced_dom\n#align continuous_fst continuous_fst\n\n",
 "continuous_curry":
 "theorem continuous_curry {g : α × β → γ} (a : α) (h : continuous g) : continuous (curry g a) :=\n  show continuous (g ∘ fun b => (a, b)) from h.comp (by continuity)\n#align continuous_curry continuous_curry\n\n",
 "continuous_at_subtype_coe":
 "theorem continuous_at_subtype_coe {p : α → Prop} {a : subtype p} : continuous_at (coe : subtype p → α) a :=\n  continuous_iff_continuous_at.mp continuous_subtype_coe _\n#align continuous_at_subtype_coe continuous_at_subtype_coe\n\n",
 "continuous_at_snd":
 "theorem continuous_at_snd {p : α × β} : continuous_at prod.snd p :=\n  continuous_snd.continuous_at\n#align continuous_at_snd continuous_at_snd\n\n",
 "continuous_at_pi":
 "theorem continuous_at_pi {f : α → ∀ i, π i} {x : α} : continuous_at f x ↔ ∀ i, continuous_at (fun y => f y i) x :=\n  tendsto_pi_nhds\n#align continuous_at_pi continuous_at_pi\n\n",
 "continuous_at_fst":
 "theorem continuous_at_fst {p : α × β} : continuous_at prod.fst p :=\n  continuous_fst.continuous_at\n#align continuous_at_fst continuous_at_fst\n\n",
 "continuous_at_cod_restrict_iff":
 "theorem continuous_at_cod_restrict_iff {f : α → β} {t : set β} (h1 : ∀ x, f x ∈ t) {x : α} :\n    continuous_at (codRestrict f t h1) x ↔ continuous_at f x := by\n  simp_rw [inducing_coe.continuous_at_iff, function.comp, coe_cod_restrict_apply]\n#align continuous_at_cod_restrict_iff continuous_at_cod_restrict_iff\n\n",
 "continuous_at_apply":
 "theorem continuous_at_apply (i : ι) (x : ∀ i, π i) : continuous_at (fun p : ∀ i, π i => p i) x :=\n  (continuous_apply i).continuous_at\n#align continuous_at_apply continuous_at_apply\n\n",
 "continuous_apply_apply":
 "@[continuity]\ntheorem continuous_apply_apply {ρ : κ → ι → Type _} [∀ j i, topological_space (ρ j i)] (j : κ) (i : ι) :\n    continuous fun p : ∀ j, ∀ i, ρ j i => p j i :=\n  (continuous_apply i).comp (continuous_apply j)\n#align continuous_apply_apply continuous_apply_apply\n\n",
 "continuous_apply":
 "@[continuity]\ntheorem continuous_apply (i : ι) : continuous fun p : ∀ i, π i => p i :=\n  continuous_infi_dom continuous_induced_dom\n#align continuous_apply continuous_apply\n\n",
 "continuous_Inf_dom₂":
 "/-- A version of `continuous_Inf_dom` for binary functions -/\ntheorem continuous_Inf_dom₂ {α β γ} {f : α → β → γ} {tas : set (topological_space α)} {tbs : set (topological_space β)}\n    {ta : topological_space α} {tb : topological_space β} {tc : topological_space γ} (ha : ta ∈ tas) (hb : tb ∈ tbs)\n    (hf : continuous fun p : α × β => f p.1 p.2) : by\n    haveI := Inf tas <;> haveI := Inf tbs <;> exact @continuous _ _ _ tc fun p : α × β => f p.1 p.2 :=\n  by\n  let t : topological_space (α × β) := prod.topological_space\n  have ha := continuous_Inf_dom ha continuous_id\n  have hb := continuous_Inf_dom hb continuous_id\n  have h_continuous_id := @continuous.prod_map _ _ _ _ ta tb (Inf tas) (Inf tbs) _ _ ha hb\n  exact @continuous.comp _ _ _ (id _) (id _) _ _ _ hf h_continuous_id\n#align continuous_Inf_dom₂ continuous_Inf_dom₂\n\n",
 "comp₄":
 "theorem continuous.comp₄ {g : α × β × γ × ζ → ε} (hg : continuous g) {e : δ → α} (he : continuous e) {f : δ → β}\n    (hf : continuous f) {k : δ → γ} (hk : continuous k) {l : δ → ζ} (hl : continuous l) :\n    continuous fun x => g (e x, f x, k x, l x) :=\n  hg.comp₃ he hf <| hk.prod_mk hl\n#align continuous.comp₄ continuous.comp₄\n\n",
 "comp₃":
 "theorem continuous.comp₃ {g : α × β × γ → ε} (hg : continuous g) {e : δ → α} (he : continuous e) {f : δ → β}\n    (hf : continuous f) {k : δ → γ} (hk : continuous k) : continuous fun x => g (e x, f x, k x) :=\n  hg.comp₂ he <| hf.prod_mk hk\n#align continuous.comp₃ continuous.comp₃\n\n",
 "comp₂":
 "theorem continuous.comp₂ {g : α × β → γ} (hg : continuous g) {e : δ → α} (he : continuous e) {f : δ → β}\n    (hf : continuous f) : continuous fun x => g (e x, f x) :=\n  hg.comp <| he.prod_mk hf\n#align continuous.comp₂ continuous.comp₂\n\n",
 "comap_sigma_mk_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem comap_sigma_mk_nhds (i : ι) (x : σ i) : comap (sigma.mk i) ((nhds) ⟨i, x⟩) = (nhds) x :=\n  (embedding_sigma_mk.to_inducing.nhds_eq_comap _).symm\n#align comap_sigma_mk_nhds comap_sigma_mk_nhds\n\n",
 "cod_restrict":
 "theorem embedding.cod_restrict {e : α → β} (he : embedding e) (s : set β) (hs : ∀ x, e x ∈ s) :\n    embedding (codRestrict e s hs) :=\n  embedding_of_embedding_compose (he.continuous.cod_restrict hs) continuous_subtype_coe he\n#align embedding.cod_restrict embedding.cod_restrict\n\n",
 "closure_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem closure_subtype {x : { a // p a }} {s : set { a // p a }} :\n    x ∈ closure s ↔ (x : α) ∈ closure («expr '' » (coe : _ → α) s) :=\n  closure_induced\n#align closure_subtype closure_subtype\n\n",
 "closure_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem closure_prod_eq {s : set α} {t : set β} :\n    closure (finset.product s t) = finset.product (closure s) (closure t) :=\n  Set.ext fun ⟨a, b⟩ =>\n    by\n    have :\n      «expr ⊓ » (filter.prod ((nhds) a) ((nhds) b)) ((filter.principal) (finset.product s t)) =\n        filter.prod («expr ⊓ » ((nhds) a) ((filter.principal) s)) («expr ⊓ » ((nhds) b) ((filter.principal) t)) :=\n      by rw [← prod_inf_prod, prod_principal_principal]\n    simp [closure_eq_cluster_pts, cluster_pt, nhds_prod_eq, this] <;> exact prod_ne_bot\n#align closure_prod_eq closure_prod_eq\n\n",
 "closed_embedding_subtype_coe":
 "theorem is_closed.closed_embedding_subtype_coe {s : set α} (hs : is_closed s) :\n    closed_embedding (coe : { x // x ∈ s } → α) :=\n  { induced := rfl\n    inj := subtype.coe_injective\n    closed_range := (Subtype.range_coe : range coe = s).symm ▸ hs }\n#align is_closed.closed_embedding_subtype_coe is_closed.closed_embedding_subtype_coe\n\n",
 "closed_embedding_sigma_mk":
 "theorem closed_embedding_sigma_mk {i : ι} : closed_embedding (@sigma.mk ι σ i) :=\n  closed_embedding_of_continuous_injective_closed continuous_sigma_mk sigma_mk_injective is_closed_map_sigma_mk\n#align closed_embedding_sigma_mk closed_embedding_sigma_mk\n\n",
 "closed_embedding_inr":
 "theorem closed_embedding_inr : closed_embedding (inr : β → Sum α β) :=\n  ⟨embedding_inr, is_closed_range_inr⟩\n#align closed_embedding_inr closed_embedding_inr\n\n",
 "closed_embedding_inl":
 "theorem closed_embedding_inl : closed_embedding (inl : α → Sum α β) :=\n  ⟨embedding_inl, is_closed_range_inl⟩\n#align closed_embedding_inl closed_embedding_inl\n\n",
 "apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.apply {l : filter β} {f : β → ∀ i, π i} {x : ∀ i, π i} (h : tendsto f l ((nhds) x)) (i : ι) :\n    tendsto (fun a => f a i) l (nhds <| x i) :=\n  (continuous_at_apply i _).tendsto.comp h\n#align filter.tendsto.apply filter.tendsto.apply\n\n"}