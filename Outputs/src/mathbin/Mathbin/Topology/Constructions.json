{"update":
 "theorem continuous.update [decidable_eq Î¹] (hf : continuous f) (i : Î¹) {g : Î± â†’ Ï€ i} (hg : continuous g) :\n    continuous fun a => update (f a) i (g a) :=\n  continuous_iff_continuous_at.2 fun x => hf.continuous_at.update i hg.continuous_at\n#align continuous.update continuous.update\n\n",
 "tendsto_subtype_rng":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_subtype_rng {Î² : Type _} {p : Î± â†’ Prop} {b : filter Î²} {f : Î² â†’ subtype p} :\n    âˆ€ {a : subtype p}, tendsto f b ((nhds) a) â†” tendsto (fun x => (f x : Î±)) b ((nhds) (a : Î±))\n  | âŸ¨a, haâŸ© => by rw [nhds_subtype_eq_comap, tendsto_comap_iff, subtype.coe_mk]\n#align tendsto_subtype_rng tendsto_subtype_rng\n\n",
 "tendsto_pi_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_pi_nhds {f : Î² â†’ âˆ€ i, Ï€ i} {g : âˆ€ i, Ï€ i} {u : filter Î²} :\n    tendsto f u ((nhds) g) â†” âˆ€ x, tendsto (fun i => f i x) u ((nhds) (g x)) := by rw [nhds_pi, filter.tendsto_pi]\n#align tendsto_pi_nhds tendsto_pi_nhds\n\n",
 "tendsto_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem _root_.prod.tendsto_iff {Î±} (seq : Î± â†’ Î² Ã— Î³) {f : filter Î±} (x : Î² Ã— Î³) :\n    tendsto seq f ((nhds) x) â†”\n      tendsto (fun n => (seq n).fst) f ((nhds) x.fst) âˆ§ tendsto (fun n => (seq n).snd) f ((nhds) x.snd) :=\n  by\n  cases x\n  rw [nhds_prod_eq, filter.tendsto_prod_iff']\n#align prod.tendsto_iff prod.tendsto_iff\n\n",
 "sum_map":
 "@[continuity]\ntheorem continuous.sum_map {f : Î± â†’ Î²} {g : Î³ â†’ Î´} (hf : continuous f) (hg : continuous g) : continuous (sum.map f g) :=\n  continuous_sum_map.2 âŸ¨hf, hgâŸ©\n#align continuous.sum_map continuous.sum_map\n\n",
 "sum_elim":
 "theorem is_open_map.sum_elim {f : Î± â†’ Î³} {g : Î² â†’ Î³} (hf : is_open_map f) (hg : is_open_map g) :\n    is_open_map (sum.elim f g) :=\n  is_open_map_sum_elim.2 âŸ¨hf, hgâŸ©\n#align is_open_map.sum_elim is_open_map.sum_elim\n\n",
 "subtype_mk":
 "@[continuity]\ntheorem continuous.subtype_mk {f : Î² â†’ Î±} (h : continuous f) (hp : âˆ€ x, p (f x)) :\n    continuous fun x => (âŸ¨f x, hp xâŸ© : subtype p) :=\n  continuous_induced_rng.2 h\n#align continuous.subtype_mk continuous.subtype_mk\n\n",
 "subtype_map":
 "theorem continuous.subtype_map {f : Î± â†’ Î²} (h : continuous f) {q : Î² â†’ Prop} (hpq : âˆ€ x, p x â†’ q (f x)) :\n    continuous (subtype.map f hpq) :=\n  (h.comp continuous_subtype_coe).subtype_mk _\n#align continuous.subtype_map continuous.subtype_map\n\n",
 "subtype_coe":
 "theorem continuous.subtype_coe {f : Î² â†’ subtype p} (hf : continuous f) : continuous fun x => (f x : Î±) :=\n  continuous_subtype_coe.comp hf\n#align continuous.subtype_coe continuous.subtype_coe\n\n",
 "snd''":
 "/-- Precomposing `f` with `prod.snd` is continuous at `x : Î± Ã— Î²` -/\ntheorem continuous_at.snd'' {f : Î² â†’ Î³} {x : Î± Ã— Î²} (hf : continuous_at f x.snd) :\n    continuous_at (fun x : Î± Ã— Î² => f x.snd) x :=\n  hf.comp continuous_at_snd\n#align continuous_at.snd'' continuous_at.snd''\n\n",
 "snd'":
 "/-- Precomposing `f` with `prod.snd` is continuous at `(x, y)` -/\ntheorem continuous_at.snd' {f : Î² â†’ Î³} {x : Î±} {y : Î²} (hf : continuous_at f y) :\n    continuous_at (fun x : Î± Ã— Î² => f x.snd) (x, y) :=\n  continuous_at.comp hf continuous_at_snd\n#align continuous_at.snd' continuous_at.snd'\n\n",
 "snd":
 "/-- Postcomposing `f` with `prod.snd` is continuous at `x` -/\ntheorem continuous_at.snd {f : Î± â†’ Î² Ã— Î³} {x : Î±} (hf : continuous_at f x) : continuous_at (fun a : Î± => (f a).2) x :=\n  continuous_at_snd.comp hf\n#align continuous_at.snd continuous_at.snd\n\n",
 "sigma_map":
 "@[continuity]\ntheorem continuous.sigma_map {fâ‚ : Î¹ â†’ Îº} {fâ‚‚ : âˆ€ i, Ïƒ i â†’ Ï„ (fâ‚ i)} (hf : âˆ€ i, continuous (fâ‚‚ i)) :\n    continuous (sigma.map fâ‚ fâ‚‚) :=\n  continuous_sigma_map.2 hf\n#align continuous.sigma_map continuous.sigma_map\n\n",
 "set_pi_mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem set_pi_mem_nhds_iff {I : set Î¹} (hI : I.finite) {s : âˆ€ i, set (Ï€ i)} (a : âˆ€ i, Ï€ i) :\n    I.pi s âˆˆ (nhds) a â†” âˆ€ i : Î¹, i âˆˆ I â†’ s i âˆˆ (nhds) (a i) :=\n  by\n  rw [nhds_pi, pi_mem_pi_iff hI]\n  infer_instance\n#align set_pi_mem_nhds_iff set_pi_mem_nhds_iff\n\n",
 "set_pi_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem set_pi_mem_nhds {i : set Î¹} {s : âˆ€ a, set (Ï€ a)} {x : âˆ€ a, Ï€ a} (hi : i.finite)\n    (hs : âˆ€ a âˆˆ i, s a âˆˆ (nhds) (x a)) : pi i s âˆˆ (nhds) x :=\n  by\n  rw [pi_def, bInter_mem hi]\n  exact fun a ha => (continuous_apply a).continuous_at (hs a ha)\n#align set_pi_mem_nhds set_pi_mem_nhds\n\n",
 "restrict_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem continuous_at.restrict_preimage {f : Î± â†’ Î²} {s : set Î²} {x : Â«expr â»Â¹' Â» f s} (h : continuous_at f x) :\n    continuous_at (s.restrict_preimage f) x :=\n  h.restrict _\n#align continuous_at.restrict_preimage continuous_at.restrict_preimage\n\n",
 "restrict":
 "theorem continuous_at.restrict {f : Î± â†’ Î²} {s : set Î±} {t : set Î²} (h1 : MapsTo f s t) {x : s}\n    (h2 : continuous_at f x) : continuous_at (h1.restrict f s t) x :=\n  (h2.comp continuous_at_subtype_coe).cod_restrict _\n#align continuous_at.restrict continuous_at.restrict\n\n",
 "quotient_map_quotient_mk":
 "theorem quotient_map_quotient_mk : quotient_map (@Quotient.mk'' Î± s) :=\n  quotient_map_quot_mk\n#align quotient_map_quotient_mk quotient_map_quotient_mk\n\n",
 "quotient_map_quot_mk":
 "theorem quotient_map_quot_mk : quotient_map (@Quot.mk Î± r) :=\n  âŸ¨quot.exists_rep, rflâŸ©\n#align quotient_map_quot_mk quotient_map_quot_mk\n\n",
 "quotient_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‡’ Â» -/\ntheorem continuous.quotient_map' {t : setoid Î²} {f : Î± â†’ Î²} (hf : continuous f) (H : (Â«expr â‡’ Â» s.r t.r) f f) :\n    continuous (quotient.map' f H) :=\n  (continuous_quotient_mk.comp hf).quotient_lift _\n#align continuous.quotient_map' continuous.quotient_map'\n\n",
 "quotient_lift_on'":
 "theorem continuous.quotient_lift_on' {f : Î± â†’ Î²} (h : continuous f) (hs : âˆ€ a b, @Setoid.r _ s a b â†’ f a = f b) :\n    continuous (fun x => quotient.lift_on' x f hs : quotient s â†’ Î²) :=\n  h.quotient_lift hs\n#align continuous.quotient_lift_on' continuous.quotient_lift_on'\n\n",
 "quotient_lift":
 "theorem continuous.quotient_lift {f : Î± â†’ Î²} (h : continuous f) (hs : âˆ€ a b, a â‰ˆ b â†’ f a = f b) :\n    continuous (quotient.lift f hs : quotient s â†’ Î²) :=\n  continuous_coinduced_dom.2 h\n#align continuous.quotient_lift continuous.quotient_lift\n\n",
 "quotient":
 "/-- The composition of `quotient.mk` and a function with dense range has dense range. -/\ntheorem dense_range.quotient [setoid Î±] [topological_space Î±] {f : Î² â†’ Î±} (hf : dense_range f) :\n    dense_range (Quotient.mk'' âˆ˜ f) :=\n  (surjective_quotient_mk Î±).dense_range.comp hf continuous_coinduced_rng\n#align dense_range.quotient dense_range.quotient\n\n",
 "prod_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem filter.has_basis.prod_nhds' {Î¹a Î¹b : Type _} {pa : Î¹a â†’ Prop} {pb : Î¹b â†’ Prop} {sa : Î¹a â†’ set Î±}\n    {sb : Î¹b â†’ set Î²} {ab : Î± Ã— Î²} (ha : ((nhds) ab.1).has_basis pa sa) (hb : ((nhds) ab.2).has_basis pb sb) :\n    ((nhds) ab).has_basis (fun i : Î¹a Ã— Î¹b => pa i.1 âˆ§ pb i.2) fun i => finset.product (sa i.1) (sb i.2) :=\n  by\n  cases ab\n  exact ha.prod_nhds hb\n#align filter.has_basis.prod_nhds' filter.has_basis.prod_nhds'\n\n",
 "prod_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually.prod_nhds {p : Î± â†’ Prop} {q : Î² â†’ Prop} {a : Î±} {b : Î²}\n    (ha :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (p x))\n    (hb :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) b)\n        (q y)) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      ((nhds) (a, b)) (p z.1 âˆ§ q z.2) :=\n  prod_mem_nhds ha hb\n#align filter.eventually.prod_nhds filter.eventually.prod_nhds\n\n",
 "prod_mk_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.prod_mk_nhds {Î³} {a : Î±} {b : Î²} {f : filter Î³} {ma : Î³ â†’ Î±} {mb : Î³ â†’ Î²}\n    (ha : tendsto ma f ((nhds) a)) (hb : tendsto mb f ((nhds) b)) : tendsto (fun c => (ma c, mb c)) f ((nhds) (a, b)) :=\n  by rw [nhds_prod_eq] <;> exact filter.tendsto.prod_mk ha hb\n#align filter.tendsto.prod_mk_nhds filter.tendsto.prod_mk_nhds\n\n",
 "prod_mk":
 "theorem embedding.prod_mk {f : Î± â†’ Î²} {g : Î³ â†’ Î´} (hf : embedding f) (hg : embedding g) :\n    embedding fun x : Î± Ã— Î³ => (f x.1, g x.2) :=\n  { hf.to_inducing.prod_mk hg.to_inducing with\n    inj := fun âŸ¨xâ‚, xâ‚‚âŸ© âŸ¨yâ‚, yâ‚‚âŸ© => by simp <;> exact fun hâ‚ hâ‚‚ => âŸ¨hf.inj hâ‚, hg.inj hâ‚‚âŸ© }\n#align embedding.prod_mk embedding.prod_mk\n\n",
 "prod_mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem prod_mem_nhds_iff {s : set Î±} {t : set Î²} {a : Î±} {b : Î²} :\n    finset.product s t âˆˆ (nhds) (a, b) â†” s âˆˆ (nhds) a âˆ§ t âˆˆ (nhds) b := by rw [nhds_prod_eq, prod_mem_prod_iff]\n#align prod_mem_nhds_iff prod_mem_nhds_iff\n\n",
 "prod_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem prod_mem_nhds {s : set Î±} {t : set Î²} {a : Î±} {b : Î²} (ha : s âˆˆ (nhds) a) (hb : t âˆˆ (nhds) b) :\n    finset.product s t âˆˆ (nhds) (a, b) :=\n  prod_mem_nhds_iff.2 âŸ¨ha, hbâŸ©\n#align prod_mem_nhds prod_mem_nhds\n\n",
 "prod_map'":
 "theorem continuous_at.prod_map' {f : Î± â†’ Î³} {g : Î² â†’ Î´} {x : Î±} {y : Î²} (hf : continuous_at f x)\n    (hg : continuous_at g y) : continuous_at (fun p : Î± Ã— Î² => (f p.1, g p.2)) (x, y) :=\n  hf.fst'.prod hg.snd'\n#align continuous_at.prod_map' continuous_at.prod_map'\n\n",
 "prod_map":
 "/-- If `f` and `g` are maps with dense range, then `prod.map f g` has dense range. -/\ntheorem dense_range.prod_map {Î¹ : Type _} {Îº : Type _} {f : Î¹ â†’ Î²} {g : Îº â†’ Î³} (hf : dense_range f)\n    (hg : dense_range g) : dense_range (prod.map f g) := by\n  simpa only [dense_range, prod_range_range_eq] using hf.prod hg\n#align dense_range.prod_map dense_range.prod_map\n\n",
 "prod_inr_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually.prod_inr_nhds {p : Î² â†’ Prop} {b : Î²}\n    (h :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) b)\n        (p x))\n    (a : Î±) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      ((nhds) (a, b)) (p (x : Î± Ã— Î²).2) :=\n  continuous_at_snd h\n#align filter.eventually.prod_inr_nhds filter.eventually.prod_inr_nhds\n\n",
 "prod_inl_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually.prod_inl_nhds {p : Î± â†’ Prop} {a : Î±}\n    (h :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (p x))\n    (b : Î²) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      ((nhds) (a, b)) (p (x : Î± Ã— Î²).1) :=\n  continuous_at_fst h\n#align filter.eventually.prod_inl_nhds filter.eventually.prod_inl_nhds\n\n",
 "prod_induced_induced":
 "/-- A product of induced topologies is induced by the product map -/\ntheorem prod_induced_induced {Î± Î³ : Type _} (f : Î± â†’ Î²) (g : Î³ â†’ Î´) :\n    @prod.topological_space Î± Î³ (induced f â€¹_â€º) (induced g â€¹_â€º) =\n      induced (fun p => (f p.1, g p.2)) prod.topological_space :=\n  by simp_rw [prod.topological_space, induced_inf, induced_compose]\n#align prod_induced_induced prod_induced_induced\n\n",
 "prod_generate_from_generate_from_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem prod_generate_from_generate_from_eq {Î± Î² : Type _} {s : set (set Î±)} {t : set (set Î²)} (hs : â‹ƒâ‚€ s = univ)\n    (ht : â‹ƒâ‚€ t = univ) :\n    @prod.topological_space Î± Î² (generate_from s) (generate_from t) =\n      generate_from { g | âˆƒ u âˆˆ s, âˆƒ v âˆˆ t, g = finset.product u v } :=\n  let G := generate_from { g | âˆƒ u âˆˆ s, âˆƒ v âˆˆ t, g = finset.product u v }\n  le_antisymm\n    (le_generate_from fun g âŸ¨u, hu, v, hv, g_eqâŸ© =>\n      g_eq.symm â–¸\n        @is_open.prod _ _ (generate_from s) (generate_from t) _ _ (generate_open.basic _ hu) (generate_open.basic _ hv))\n    (le_inf\n      (coinduced_le_iff_le_induced.mp <|\n        le_generate_from fun u hu =>\n          have :\n            Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n                (finset.product u v) =\n              Â«expr â»Â¹' Â» prod.fst u :=\n            by simp_rw [â† prod_Union, â† sUnion_eq_bUnion, ht, prod_univ]\n          show G.is_open (Â«expr â»Â¹' Â» prod.fst u) by\n            rw [â† this]\n            exact is_open_Union fun v => is_open_Union fun hv => generate_open.basic _ âŸ¨_, hu, _, hv, rflâŸ©)\n      (coinduced_le_iff_le_induced.mp <|\n        le_generate_from fun v hv =>\n          have :\n            Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n                (finset.product u v) =\n              Â«expr â»Â¹' Â» prod.snd v :=\n            by simp_rw [â† Union_prod_const, â† sUnion_eq_bUnion, hs, univ_prod]\n          show G.is_open (Â«expr â»Â¹' Â» prod.snd v) by\n            rw [â† this]\n            exact is_open_Union fun u => is_open_Union fun hu => generate_open.basic _ âŸ¨_, hu, _, hv, rflâŸ©))\n#align prod_generate_from_generate_from_eq prod_generate_from_generate_from_eq\n\n",
 "prod_eq_generate_from":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem prod_eq_generate_from :\n    prod.topological_space =\n      generate_from { g | âˆƒ (s : set Î±)(t : set Î²), is_open s âˆ§ is_open t âˆ§ g = finset.product s t } :=\n  le_antisymm (le_generate_from fun g âŸ¨s, t, hs, ht, g_eqâŸ© => g_eq.symm â–¸ hs.prod ht)\n    (le_inf (ball_image_of_ball fun t ht => generate_open.basic _ âŸ¨t, univ, by simpa [Set.prod_eq] using htâŸ©)\n      (ball_image_of_ball fun t ht => generate_open.basic _ âŸ¨univ, t, by simpa [Set.prod_eq] using htâŸ©))\n#align prod_eq_generate_from prod_eq_generate_from\n\n",
 "prod":
 "protected theorem open_embedding.prod {f : Î± â†’ Î²} {g : Î³ â†’ Î´} (hf : open_embedding f) (hg : open_embedding g) :\n    open_embedding fun x : Î± Ã— Î³ => (f x.1, g x.2) :=\n  open_embedding_of_embedding_open (hf.1.prod_mk hg.1) (hf.is_open_map.prod hg.is_open_map)\n#align open_embedding.prod open_embedding.prod\n\n",
 "preimage_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem quotient.preimage_mem_nhds [topological_space Î±] [s : setoid Î±] {V : set <| quotient s} {a : Î±}\n    (hs : V âˆˆ (nhds) (Quotient.mk'' a)) : Â«expr â»Â¹' Â» Quotient.mk'' V âˆˆ (nhds) a :=\n  preimage_nhds_coinduced hs\n#align quotient.preimage_mem_nhds quotient.preimage_mem_nhds\n\n",
 "pi_generate_from_eq_finite":
 "theorem pi_generate_from_eq_finite {Ï€ : Î¹ â†’ Type _} {g : âˆ€ a, set (set (Ï€ a))} [Finite Î¹] (hg : âˆ€ a, â‹ƒâ‚€ g a = univ) :\n    (@Pi.topological_space Î¹ Ï€ fun a => generate_from (g a)) =\n      generate_from { t | âˆƒ s : âˆ€ a, set (Ï€ a), (âˆ€ a, s a âˆˆ g a) âˆ§ t = pi univ s } :=\n  by\n  cases nonempty_fintype Î¹\n  rw [pi_generate_from_eq]\n  refine' le_antisymm (generate_from_mono _) (le_generate_from _)\n  exact fun s âŸ¨t, ht, eqâŸ© => âŸ¨t, finset.univ, by simp [ht, eq]âŸ©\n  Â· rintro s âŸ¨t, i, ht, rflâŸ©\n    apply is_open_iff_forall_mem_open.2 _\n    intro f hf\n    choose c hc using\n      show âˆ€ a, âˆƒ s, s âˆˆ g a âˆ§ f a âˆˆ s by\n        intro a\n        have : f a âˆˆ â‹ƒâ‚€ g a := by\n          rw [hg]\n          apply mem_univ\n        simpa\n    refine' âŸ¨pi univ fun a => if a âˆˆ i then t a else (c : âˆ€ a, set (Ï€ a)) a, _, _, _âŸ©\n    Â· simp [pi_if]\n    Â· refine' generate_open.basic _ âŸ¨_, fun a => _, rflâŸ©\n      by_cases a âˆˆ i <;> simp_all [Set.pi]\n    Â· have : f âˆˆ pi { a | a âˆ‰ i } c := by simp_all [Set.pi]\n      simpa [pi_if, hf]\n#align pi_generate_from_eq_finite pi_generate_from_eq_finite\n\n",
 "pi_generate_from_eq":
 "theorem pi_generate_from_eq {Ï€ : Î¹ â†’ Type _} {g : âˆ€ a, set (set (Ï€ a))} :\n    (@Pi.topological_space Î¹ Ï€ fun a => generate_from (g a)) =\n      generate_from { t | âˆƒ (s : âˆ€ a, set (Ï€ a))(i : Finset Î¹), (âˆ€ a âˆˆ i, s a âˆˆ g a) âˆ§ t = pi (â†‘i) s } :=\n  by\n  let G := { t | âˆƒ (s : âˆ€ a, set (Ï€ a))(i : Finset Î¹), (âˆ€ a âˆˆ i, s a âˆˆ g a) âˆ§ t = pi (â†‘i) s }\n  rw [pi_eq_generate_from]\n  refine' le_antisymm (generate_from_mono _) (le_generate_from _)\n  exact fun s âŸ¨t, i, ht, eqâŸ© => âŸ¨t, i, fun a ha => generate_open.basic _ (ht a ha), eqâŸ©\n  Â· rintro s âŸ¨t, i, hi, rflâŸ©\n    rw [pi_def]\n    apply is_open_bInter (finset.finite_to_set _)\n    intro a ha\n    show ((generate_from G).coinduced fun f : âˆ€ a, Ï€ a => f a).is_open (t a)\n    refine' le_generate_from _ _ (hi a ha)\n    exact fun s hs => generate_open.basic _ âŸ¨update (fun a => univ) a s, {a}, by simp [hs]âŸ©\n#align pi_generate_from_eq pi_generate_from_eq\n\n",
 "pi_eq_generate_from":
 "theorem pi_eq_generate_from :\n    Pi.topological_space =\n      generate_from { g | âˆƒ (s : âˆ€ a, set (Ï€ a))(i : Finset Î¹), (âˆ€ a âˆˆ i, is_open (s a)) âˆ§ g = pi (â†‘i) s } :=\n  le_antisymm (le_generate_from fun g âŸ¨s, i, hi, eqâŸ© => eq.symm â–¸ is_open_set_pi (finset.finite_to_set _) hi)\n    (le_infáµ¢ fun a s âŸ¨t, ht, s_eqâŸ© =>\n      generate_open.basic _ <| âŸ¨update (fun a => univ) a t, {a}, by simpa using ht, s_eq â–¸ by ext f <;> simp [Set.pi]âŸ©)\n#align pi_eq_generate_from pi_eq_generate_from\n\n",
 "open_embedding_subtype_coe":
 "theorem is_open.open_embedding_subtype_coe {s : set Î±} (hs : is_open s) : open_embedding (coe : s â†’ Î±) :=\n  { induced := rfl\n    inj := subtype.coe_injective\n    open_range := (Subtype.range_coe : range coe = s).symm â–¸ hs }\n#align is_open.open_embedding_subtype_coe is_open.open_embedding_subtype_coe\n\n",
 "open_embedding_sigma_mk":
 "theorem open_embedding_sigma_mk {i : Î¹} : open_embedding (@sigma.mk Î¹ Ïƒ i) :=\n  open_embedding_of_continuous_injective_open continuous_sigma_mk sigma_mk_injective is_open_map_sigma_mk\n#align open_embedding_sigma_mk open_embedding_sigma_mk\n\n",
 "open_embedding_sigma_map":
 "theorem open_embedding_sigma_map {fâ‚ : Î¹ â†’ Îº} {fâ‚‚ : âˆ€ i, Ïƒ i â†’ Ï„ (fâ‚ i)} (h : injective fâ‚) :\n    open_embedding (sigma.map fâ‚ fâ‚‚) â†” âˆ€ i, open_embedding (fâ‚‚ i) := by\n  simp only [open_embedding_iff_embedding_open, is_open_map_sigma_map, embedding_sigma_map h, forall_and]\n#align open_embedding_sigma_map open_embedding_sigma_map\n\n",
 "open_embedding_inr":
 "theorem open_embedding_inr : open_embedding (@inr Î± Î²) :=\n  open_embedding_of_continuous_injective_open continuous_inr inr_injective is_open_map_inr\n#align open_embedding_inr open_embedding_inr\n\n",
 "open_embedding_inl":
 "theorem open_embedding_inl : open_embedding (@inl Î± Î²) :=\n  open_embedding_of_continuous_injective_open continuous_inl inl_injective is_open_map_inl\n#align open_embedding_inl open_embedding_inl\n\n",
 "of_cod_restrict":
 "theorem inducing.of_cod_restrict {f : Î± â†’ Î²} {b : set Î²} (hb : âˆ€ a, f a âˆˆ b) (h : inducing (b.cod_restrict f hb)) :\n    inducing f :=\n  inducing_coe.comp h\n#align inducing.of_cod_restrict inducing.of_cod_restrict\n\n",
 "nhds_within_subtype_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem nhds_within_subtype_eq_bot_iff {s t : set Î±} {x : s} :\n    nhds_within (Â«expr â»Â¹' Â» (coe : s â†’ Î±) t) x = Â«exprâŠ¥Â» â†”\n      Â«expr âŠ“ Â» (nhds_within t (x : Î±)) ((filter.principal) s) = Â«exprâŠ¥Â» :=\n  by rw [inf_principal_eq_bot_iff_comap, nhds_within, nhds_within, comap_inf, comap_principal, nhds_induced]\n#align nhds_within_subtype_eq_bot_iff nhds_within_subtype_eq_bot_iff\n\n",
 "nhds_to_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_to_mul (a : Additive Î±) : (nhds) (toMul a) = map toMul ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_to_mul nhds_to_mul\n\n",
 "nhds_to_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_to_dual (a : Î±) : (nhds) (toDual a) = map toDual ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_to_dual nhds_to_dual\n\n",
 "nhds_to_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_to_add (a : Multiplicative Î±) : (nhds) (toAdd a) = map toAdd ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_to_add nhds_to_add\n\n",
 "nhds_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_swap (a : Î±) (b : Î²) : (nhds) (a, b) = ((nhds) (b, a)).map prod.swap := by\n  rw [nhds_prod_eq, filter.prod_comm, nhds_prod_eq] <;> rfl\n#align nhds_swap nhds_swap\n\n",
 "nhds_subtype_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_subtype_eq_comap {a : Î±} {h : p a} : (nhds) (âŸ¨a, hâŸ© : subtype p) = comap coe ((nhds) a) :=\n  nhds_induced _ _\n#align nhds_subtype_eq_comap nhds_subtype_eq_comap\n\n",
 "nhds_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_subtype (s : set Î±) (a : { x // x âˆˆ s }) : (nhds) a = comap coe ((nhds) (a : Î±)) :=\n  nhds_induced coe a\n#align nhds_subtype nhds_subtype\n\n",
 "nhds_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_prod_eq {a : Î±} {b : Î²} : (nhds) (a, b) = filter.prod ((nhds) a) ((nhds) b) := by\n  rw [filter.prod, prod.topological_space, nhds_inf, nhds_induced, nhds_induced]\n#align nhds_prod_eq nhds_prod_eq\n\n",
 "nhds_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_pi {a : âˆ€ i, Ï€ i} : (nhds) a = pi fun i => (nhds) (a i) := by\n  simp only [nhds_infi, nhds_induced, filter.pi]\n#align nhds_pi nhds_pi\n\n",
 "nhds_of_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_of_mul (a : Î±) : (nhds) (ofMul a) = map ofMul ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_of_mul nhds_of_mul\n\n",
 "nhds_of_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_of_dual (a : Î±) : (nhds) (ofDual a) = map ofDual ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_of_dual nhds_of_dual\n\n",
 "nhds_of_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_of_add (a : Î±) : (nhds) (ofAdd a) = map ofAdd ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_of_add nhds_of_add\n\n",
 "nhds_ne_subtype_ne_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_ne_subtype_ne_bot_iff {S : set Î±} {x : S} :\n    (nhds_within (Â«expr á¶œÂ» {x}) x).ne_bot â†”\n      (Â«expr âŠ“ Â» (nhds_within (Â«expr á¶œÂ» {x}) (x : Î±)) ((filter.principal) S)).ne_bot :=\n  by rw [ne_bot_iff, ne_bot_iff, not_iff_not, nhds_ne_subtype_eq_bot_iff]\n#align nhds_ne_subtype_ne_bot_iff nhds_ne_subtype_ne_bot_iff\n\n",
 "nhds_ne_subtype_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem nhds_ne_subtype_eq_bot_iff {S : set Î±} {x : S} :\n    nhds_within (Â«expr á¶œÂ» {x}) x = Â«exprâŠ¥Â» â†”\n      Â«expr âŠ“ Â» (nhds_within (Â«expr á¶œÂ» {x}) (x : Î±)) ((filter.principal) S) = Â«exprâŠ¥Â» :=\n  by rw [â† nhds_within_subtype_eq_bot_iff, preimage_compl, â† image_singleton, subtype.coe_injective.preimage_image]\n#align nhds_ne_subtype_eq_bot_iff nhds_ne_subtype_eq_bot_iff\n\n",
 "nhds_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem sigma.nhds_mk (i : Î¹) (x : Ïƒ i) : (nhds) (âŸ¨i, xâŸ© : sigma Ïƒ) = map (sigma.mk i) ((nhds) x) :=\n  (open_embedding_sigma_mk.map_nhds_eq x).symm\n#align sigma.nhds_mk sigma.nhds_mk\n\n",
 "nhds_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_inr (x : Î²) : (nhds) (inr x : Sum Î± Î²) = map inr ((nhds) x) :=\n  (open_embedding_inr.map_nhds_eq _).symm\n#align nhds_inr nhds_inr\n\n",
 "nhds_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_inl (x : Î±) : (nhds) (inl x : Sum Î± Î²) = map inl ((nhds) x) :=\n  (open_embedding_inl.map_nhds_eq _).symm\n#align nhds_inl nhds_inl\n\n",
 "nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem sigma.nhds_eq (x : sigma Ïƒ) : (nhds) x = map (sigma.mk x.1) ((nhds) x.2) :=\n  by\n  cases x\n  apply sigma.nhds_mk\n#align sigma.nhds_eq sigma.nhds_eq\n\n",
 "mk_left":
 "@[continuity]\ntheorem continuous.prod.mk_left (b : Î²) : continuous fun a : Î± => (a, b) :=\n  continuous_id'.prod_mk continuous_const\n#align continuous.prod.mk_left continuous.prod.mk_left\n\n",
 "mk":
 "@[continuity]\ntheorem continuous.prod.mk (a : Î±) : continuous fun b : Î² => (a, b) :=\n  continuous_const.prod_mk continuous_id'\n#align continuous.prod.mk continuous.prod.mk\n\n",
 "mem_nhds_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-\nThe ğ“ filter and the subspace topology.\n-/\ntheorem mem_nhds_subtype (s : set Î±) (a : { x // x âˆˆ s }) (t : set { x // x âˆˆ s }) :\n    t âˆˆ (nhds) a â†” âˆƒ u âˆˆ (nhds) (a : Î±), Â«expr â»Â¹' Â» coe u âŠ† t :=\n  mem_nhds_induced coe a t\n#align mem_nhds_subtype mem_nhds_subtype\n\n",
 "mem_nhds_prod_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem mem_nhds_prod_iff' {a : Î±} {b : Î²} {s : set (Î± Ã— Î²)} :\n    s âˆˆ (nhds) (a, b) â†” âˆƒ (u : set Î±)(v : set Î²), is_open u âˆ§ a âˆˆ u âˆ§ is_open v âˆ§ b âˆˆ v âˆ§ finset.product u v âŠ† s :=\n  by\n  rw [mem_nhds_prod_iff]\n  constructor\n  Â· rintro âŸ¨u, Hu, v, Hv, hâŸ©\n    rcases mem_nhds_iff.1 Hu with âŸ¨u', u'u, u'_open, Hu'âŸ©\n    rcases mem_nhds_iff.1 Hv with âŸ¨v', v'v, v'_open, Hv'âŸ©\n    exact âŸ¨u', v', u'_open, Hu', v'_open, Hv', (Set.prod_mono u'u v'v).trans hâŸ©\n  Â· rintro âŸ¨u, v, u_open, au, v_open, bv, huvâŸ©\n    exact âŸ¨u, u_open.mem_nhds au, v, v_open.mem_nhds bv, huvâŸ©\n#align mem_nhds_prod_iff' mem_nhds_prod_iff'\n\n",
 "mem_nhds_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem mem_nhds_prod_iff {a : Î±} {b : Î²} {s : set (Î± Ã— Î²)} :\n    s âˆˆ (nhds) (a, b) â†” âˆƒ u âˆˆ (nhds) a, âˆƒ v âˆˆ (nhds) b, finset.product u v âŠ† s := by rw [nhds_prod_eq, mem_prod_iff]\n#align mem_nhds_prod_iff mem_nhds_prod_iff\n\n",
 "mem_nhds_of_pi_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_nhds_of_pi_mem_nhds {I : set Î¹} {s : âˆ€ i, set (Ï€ i)} (a : âˆ€ i, Ï€ i) (hs : I.pi s âˆˆ (nhds) a) {i : Î¹}\n    (hi : i âˆˆ I) : s i âˆˆ (nhds) (a i) := by\n  rw [nhds_pi] at hs\n  exact mem_of_pi_mem_pi hs hi\n#align mem_nhds_of_pi_mem_nhds mem_nhds_of_pi_mem_nhds\n\n",
 "mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem mem_nhds_iff {a : cofinite_topology Î±} {s : set (cofinite_topology Î±)} :\n    s âˆˆ (nhds) a â†” a âˆˆ s âˆ§ (Â«expr á¶œÂ» s).finite := by simp [nhds_eq]\n#align mem_nhds_iff mem_nhds_iff\n\n",
 "map_snd_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- `prod.snd` maps neighborhood of `x : Î± Ã— Î²` within the section `prod.fst â»Â¹' {x.1}`\nto `ğ“ x.2`. -/\ntheorem map_snd_nhds_within (x : Î± Ã— Î²) : map prod.snd (nhds_within (Â«expr â»Â¹' Â» prod.fst {x.1}) x) = (nhds) x.2 :=\n  by\n  refine' le_antisymm (continuous_at_snd.mono_left inf_le_left) fun s hs => _\n  rcases x with âŸ¨x, yâŸ©\n  rw [mem_map, nhds_within, mem_inf_principal, mem_nhds_prod_iff] at hs\n  rcases hs with âŸ¨u, hu, v, hv, HâŸ©\n  simp only [prod_subset_iff, mem_singleton_iff, mem_set_of_eq, mem_preimage] at H\n  exact mem_of_superset hv fun z hz => H _ (mem_of_mem_nhds hu) _ hz rfl\n#align map_snd_nhds_within map_snd_nhds_within\n\n",
 "map_snd_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem map_snd_nhds (x : Î± Ã— Î²) : map prod.snd ((nhds) x) = (nhds) x.2 :=\n  le_antisymm continuous_at_snd <| (map_snd_nhds_within x).symm.trans_le (map_mono inf_le_left)\n#align map_snd_nhds map_snd_nhds\n\n",
 "map_nhds_subtype_coe_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem map_nhds_subtype_coe_eq {a : Î±} (ha : p a) (h : { a | p a } âˆˆ (nhds) a) :\n    map (coe : subtype p â†’ Î±) ((nhds) âŸ¨a, haâŸ©) = (nhds) a :=\n  map_nhds_induced_of_mem <| by simpa only [subtype.coe_mk, Subtype.range_coe] using h\n#align map_nhds_subtype_coe_eq map_nhds_subtype_coe_eq\n\n",
 "map_mem_closureâ‚‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem map_mem_closureâ‚‚ {f : Î± â†’ Î² â†’ Î³} {a : Î±} {b : Î²} {s : set Î±} {t : set Î²} {u : set Î³}\n    (hf : continuous (uncurry f)) (ha : a âˆˆ closure s) (hb : b âˆˆ closure t) (h : âˆ€ a âˆˆ s, âˆ€ b âˆˆ t, f a b âˆˆ u) :\n    f a b âˆˆ closure u :=\n  have Hâ‚ : (a, b) âˆˆ closure (finset.product s t) := by simpa only [closure_prod_eq] using mk_mem_prod ha hb\n  have Hâ‚‚ : MapsTo (uncurry f) (finset.product s t) u := forall_prod_set.2 h\n  Hâ‚‚.closure hf Hâ‚\n#align map_mem_closureâ‚‚ map_mem_closureâ‚‚\n\n",
 "map_fst_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- `prod.fst` maps neighborhood of `x : Î± Ã— Î²` within the section `prod.snd â»Â¹' {x.2}`\nto `ğ“ x.1`. -/\ntheorem map_fst_nhds_within (x : Î± Ã— Î²) : map prod.fst (nhds_within (Â«expr â»Â¹' Â» prod.snd {x.2}) x) = (nhds) x.1 :=\n  by\n  refine' le_antisymm (continuous_at_fst.mono_left inf_le_left) fun s hs => _\n  rcases x with âŸ¨x, yâŸ©\n  rw [mem_map, nhds_within, mem_inf_principal, mem_nhds_prod_iff] at hs\n  rcases hs with âŸ¨u, hu, v, hv, HâŸ©\n  simp only [prod_subset_iff, mem_singleton_iff, mem_set_of_eq, mem_preimage] at H\n  exact mem_of_superset hu fun z hz => H _ hz _ (mem_of_mem_nhds hv) rfl\n#align map_fst_nhds_within map_fst_nhds_within\n\n",
 "map_fst_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem map_fst_nhds (x : Î± Ã— Î²) : map prod.fst ((nhds) x) = (nhds) x.1 :=\n  le_antisymm continuous_at_fst <| (map_fst_nhds_within x).symm.trans_le (map_mono inf_le_left)\n#align map_fst_nhds map_fst_nhds\n\n",
 "is_open_sum_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem is_open_sum_iff {s : set (Sum Î± Î²)} : is_open s â†” is_open (Â«expr â»Â¹' Â» inl s) âˆ§ is_open (Â«expr â»Â¹' Â» inr s) :=\n  iff.rfl\n#align is_open_sum_iff is_open_sum_iff\n\n",
 "is_open_sigma_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem is_open_sigma_iff {s : set (sigma Ïƒ)} : is_open s â†” âˆ€ i, is_open (Â«expr â»Â¹' Â» (sigma.mk i) s) := by\n  simp only [is_open_supr_iff, is_open_coinduced]\n#align is_open_sigma_iff is_open_sigma_iff\n\n",
 "is_open_sigma_fst_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem is_open_sigma_fst_preimage (s : set Î¹) : is_open (Â«expr â»Â¹' Â» sigma.fst s : set (Î£a, Ïƒ a)) :=\n  by\n  rw [â† bUnion_of_singleton s, preimage_Unionâ‚‚]\n  simp only [â† range_sigma_mk]\n  exact is_open_bUnion fun _ _ => is_open_range_sigma_mk\n#align is_open_sigma_fst_preimage is_open_sigma_fst_preimage\n\n",
 "is_open_set_pi":
 "theorem is_open_set_pi {i : set Î¹} {s : âˆ€ a, set (Ï€ a)} (hi : i.finite) (hs : âˆ€ a âˆˆ i, is_open (s a)) :\n    is_open (pi i s) := by rw [pi_def] <;> exact is_open_bInter hi fun a ha => (hs _ ha).preimage (continuous_apply _)\n#align is_open_set_pi is_open_set_pi\n\n",
 "is_open_range_sigma_mk":
 "theorem is_open_range_sigma_mk {i : Î¹} : is_open (Set.range (@sigma.mk Î¹ Ïƒ i)) :=\n  is_open_map_sigma_mk.is_open_range\n#align is_open_range_sigma_mk is_open_range_sigma_mk\n\n",
 "is_open_range_inr":
 "theorem is_open_range_inr : is_open (range (inr : Î² â†’ Sum Î± Î²)) :=\n  open_embedding_inr.2\n#align is_open_range_inr is_open_range_inr\n\n",
 "is_open_range_inl":
 "theorem is_open_range_inl : is_open (range (inl : Î± â†’ Sum Î± Î²)) :=\n  open_embedding_inl.2\n#align is_open_range_inl is_open_range_inl\n\n",
 "is_open_prod_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/-- A product set is open in a product space if and only if each factor is open, or one of them is\nempty -/\ntheorem is_open_prod_iff' {s : set Î±} {t : set Î²} :\n    is_open (finset.product s t) â†” is_open s âˆ§ is_open t âˆ¨ s = âˆ… âˆ¨ t = âˆ… :=\n  by\n  cases' (finset.product s t).eq_empty_or_nonempty with h h\n  Â· simp [h, prod_eq_empty_iff.1 h]\n  Â· have st : s.nonempty âˆ§ t.nonempty := prod_nonempty_iff.1 h\n    constructor\n    Â· intro (H : is_open (finset.product s t))\n      refine' or.inl âŸ¨_, _âŸ©\n      show is_open s\n      Â· rw [â† fst_image_prod s st.2]\n        exact is_open_map_fst _ H\n      show is_open t\n      Â· rw [â† snd_image_prod st.1 t]\n        exact is_open_map_snd _ H\n    Â· intro H\n      simp only [st.1.ne_empty, st.2.ne_empty, not_false_iff, or_false_iff] at H\n      exact H.1.prod H.2\n#align is_open_prod_iff' is_open_prod_iff'\n\n",
 "is_open_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem is_open_prod_iff {s : set (Î± Ã— Î²)} :\n    is_open s â†”\n      âˆ€ a b, (a, b) âˆˆ s â†’ âˆƒ (u : set Î±)(v : set Î²), is_open u âˆ§ is_open v âˆ§ a âˆˆ u âˆ§ b âˆˆ v âˆ§ finset.product u v âŠ† s :=\n  by\n  rw [is_open_iff_nhds]\n  simp_rw [le_principal_iff, prod.forall, ((nhds_basis_opens _).prod_nhds (nhds_basis_opens _)).mem_iff, prod.exists,\n    exists_prop]\n  simp only [and_assoc', and_left_comm]\n#align is_open_prod_iff is_open_prod_iff\n\n",
 "is_open_map_to_mul":
 "theorem is_open_map_to_mul : is_open_map (toMul : Additive Î± â†’ Î±) :=\n  is_open_map.id\n#align is_open_map_to_mul is_open_map_to_mul\n\n",
 "is_open_map_to_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\ntheorem is_open_map_to_dual : is_open_map (toDual : Î± â†’ Â«expr áµ’áµˆÂ» Î±) :=\n  is_open_map.id\n#align is_open_map_to_dual is_open_map_to_dual\n\n",
 "is_open_map_to_add":
 "theorem is_open_map_to_add : is_open_map (toAdd : Multiplicative Î± â†’ Î±) :=\n  is_open_map.id\n#align is_open_map_to_add is_open_map_to_add\n\n",
 "is_open_map_sum_elim":
 "@[simp]\ntheorem is_open_map_sum_elim {f : Î± â†’ Î³} {g : Î² â†’ Î³} : is_open_map (sum.elim f g) â†” is_open_map f âˆ§ is_open_map g := by\n  simp only [is_open_map_sum, elim_inl, elim_inr]\n#align is_open_map_sum_elim is_open_map_sum_elim\n\n",
 "is_open_map_sum":
 "theorem is_open_map_sum {f : Sum Î± Î² â†’ Î³} :\n    is_open_map f â†” (is_open_map fun a => f (inl a)) âˆ§ is_open_map fun b => f (inr b) := by\n  simp only [is_open_map_iff_nhds_le, sum.forall, nhds_inl, nhds_inr, filter.map_map]\n#align is_open_map_sum is_open_map_sum\n\n",
 "is_open_map_subtype_coe":
 "theorem is_open.is_open_map_subtype_coe {s : set Î±} (hs : is_open s) : is_open_map (coe : s â†’ Î±) :=\n  hs.open_embedding_subtype_coe.is_open_map\n#align is_open.is_open_map_subtype_coe is_open.is_open_map_subtype_coe\n\n",
 "is_open_map_snd":
 "/-- The second projection in a product of topological spaces sends open sets to open sets. -/\ntheorem is_open_map_snd : is_open_map (@prod.snd Î± Î²) :=\n  is_open_map_iff_nhds_le.2 fun x => (map_snd_nhds x).ge\n#align is_open_map_snd is_open_map_snd\n\n",
 "is_open_map_sigma_mk":
 "theorem is_open_map_sigma_mk {i : Î¹} : is_open_map (@sigma.mk Î¹ Ïƒ i) :=\n  by\n  intro s hs\n  rw [is_open_sigma_iff]\n  intro j\n  rcases eq_or_ne j i with (rfl | hne)\n  Â· rwa [Set.preimage_image_eq _ sigma_mk_injective]\n  Â· rw [preimage_image_sigma_mk_of_ne hne]\n    exact is_open_empty\n#align is_open_map_sigma_mk is_open_map_sigma_mk\n\n",
 "is_open_map_sigma_map":
 "theorem is_open_map_sigma_map {fâ‚ : Î¹ â†’ Îº} {fâ‚‚ : âˆ€ i, Ïƒ i â†’ Ï„ (fâ‚ i)} :\n    is_open_map (sigma.map fâ‚ fâ‚‚) â†” âˆ€ i, is_open_map (fâ‚‚ i) :=\n  is_open_map_sigma.trans <| forall_congr' fun i => (@open_embedding_sigma_mk _ _ _ (fâ‚ i)).is_open_map_iff.symm\n#align is_open_map_sigma_map is_open_map_sigma_map\n\n",
 "is_open_map_sigma":
 "theorem is_open_map_sigma {f : sigma Ïƒ â†’ Î±} : is_open_map f â†” âˆ€ i, is_open_map fun a => f âŸ¨i, aâŸ© := by\n  simp only [is_open_map_iff_nhds_le, sigma.forall, sigma.nhds_eq, map_map]\n#align is_open_map_sigma is_open_map_sigma\n\n",
 "is_open_map_of_mul":
 "theorem is_open_map_of_mul : is_open_map (ofMul : Î± â†’ Additive Î±) :=\n  is_open_map.id\n#align is_open_map_of_mul is_open_map_of_mul\n\n",
 "is_open_map_of_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\ntheorem is_open_map_of_dual : is_open_map (ofDual : Â«expr áµ’áµˆÂ» Î± â†’ Î±) :=\n  is_open_map.id\n#align is_open_map_of_dual is_open_map_of_dual\n\n",
 "is_open_map_of_add":
 "theorem is_open_map_of_add : is_open_map (ofAdd : Î± â†’ Multiplicative Î±) :=\n  is_open_map.id\n#align is_open_map_of_add is_open_map_of_add\n\n",
 "is_open_map_inr":
 "theorem is_open_map_inr : is_open_map (@inr Î± Î²) := fun u hu => by\n  simpa [is_open_sum_iff, preimage_image_eq u sum.inr_injective]\n#align is_open_map_inr is_open_map_inr\n\n",
 "is_open_map_inl":
 "theorem is_open_map_inl : is_open_map (@inl Î± Î²) := fun u hu => by\n  simpa [is_open_sum_iff, preimage_image_eq u sum.inl_injective]\n#align is_open_map_inl is_open_map_inl\n\n",
 "is_open_map_fst":
 "/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem is_open_map_fst : is_open_map (@prod.fst Î± Î²) :=\n  is_open_map_iff_nhds_le.2 fun x => (map_fst_nhds x).ge\n#align is_open_map_fst is_open_map_fst\n\n",
 "is_open_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem is_open_iff' {s : set (cofinite_topology Î±)} : is_open s â†” s = âˆ… âˆ¨ (Â«expr á¶œÂ» s).finite := by\n  simp only [is_open_iff, nonempty_iff_ne_empty, or_iff_not_imp_left]\n#align is_open_iff' is_open_iff'\n\n",
 "is_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem is_open_iff {s : set (cofinite_topology Î±)} : is_open s â†” s.nonempty â†’ (Â«expr á¶œÂ» s).finite :=\n  iff.rfl\n#align is_open_iff is_open_iff\n\n",
 "is_closed_sigma_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem is_closed_sigma_iff {s : set (sigma Ïƒ)} : is_closed s â†” âˆ€ i, is_closed (Â«expr â»Â¹' Â» (sigma.mk i) s) := by\n  simp only [â† is_open_compl_iff, is_open_sigma_iff, preimage_compl]\n#align is_closed_sigma_iff is_closed_sigma_iff\n\n",
 "is_closed_set_pi":
 "theorem is_closed_set_pi {i : set Î¹} {s : âˆ€ a, set (Ï€ a)} (hs : âˆ€ a âˆˆ i, is_closed (s a)) : is_closed (pi i s) := by\n  rw [pi_def] <;> exact is_closed_Inter fun a => is_closed_Inter fun ha => (hs _ ha).preimage (continuous_apply _)\n#align is_closed_set_pi is_closed_set_pi\n\n",
 "is_closed_range_sigma_mk":
 "theorem is_closed_range_sigma_mk {i : Î¹} : is_closed (Set.range (@sigma.mk Î¹ Ïƒ i)) :=\n  is_closed_map_sigma_mk.closed_range\n#align is_closed_range_sigma_mk is_closed_range_sigma_mk\n\n",
 "is_closed_range_inr":
 "theorem is_closed_range_inr : is_closed (range (inr : Î² â†’ Sum Î± Î²)) :=\n  by\n  rw [â† is_open_compl_iff, compl_range_inr]\n  exact is_open_range_inl\n#align is_closed_range_inr is_closed_range_inr\n\n",
 "is_closed_range_inl":
 "theorem is_closed_range_inl : is_closed (range (inl : Î± â†’ Sum Î± Î²)) :=\n  by\n  rw [â† is_open_compl_iff, compl_range_inl]\n  exact is_open_range_inr\n#align is_closed_range_inl is_closed_range_inl\n\n",
 "is_closed_map_to_mul":
 "theorem is_closed_map_to_mul : is_closed_map (toMul : Additive Î± â†’ Î±) :=\n  is_closed_map.id\n#align is_closed_map_to_mul is_closed_map_to_mul\n\n",
 "is_closed_map_to_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\ntheorem is_closed_map_to_dual : is_closed_map (toDual : Î± â†’ Â«expr áµ’áµˆÂ» Î±) :=\n  is_closed_map.id\n#align is_closed_map_to_dual is_closed_map_to_dual\n\n",
 "is_closed_map_to_add":
 "theorem is_closed_map_to_add : is_closed_map (toAdd : Multiplicative Î± â†’ Î±) :=\n  is_closed_map.id\n#align is_closed_map_to_add is_closed_map_to_add\n\n",
 "is_closed_map_sigma_mk":
 "theorem is_closed_map_sigma_mk {i : Î¹} : is_closed_map (@sigma.mk Î¹ Ïƒ i) :=\n  by\n  intro s hs\n  rw [is_closed_sigma_iff]\n  intro j\n  rcases eq_or_ne j i with (rfl | hne)\n  Â· rwa [Set.preimage_image_eq _ sigma_mk_injective]\n  Â· rw [preimage_image_sigma_mk_of_ne hne]\n    exact is_closed_empty\n#align is_closed_map_sigma_mk is_closed_map_sigma_mk\n\n",
 "is_closed_map_of_mul":
 "theorem is_closed_map_of_mul : is_closed_map (ofMul : Î± â†’ Additive Î±) :=\n  is_closed_map.id\n#align is_closed_map_of_mul is_closed_map_of_mul\n\n",
 "is_closed_map_of_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\ntheorem is_closed_map_of_dual : is_closed_map (ofDual : Â«expr áµ’áµˆÂ» Î± â†’ Î±) :=\n  is_closed_map.id\n#align is_closed_map_of_dual is_closed_map_of_dual\n\n",
 "is_closed_map_of_add":
 "theorem is_closed_map_of_add : is_closed_map (ofAdd : Î± â†’ Multiplicative Î±) :=\n  is_closed_map.id\n#align is_closed_map_of_add is_closed_map_of_add\n\n",
 "is_closed_iff":
 "theorem is_closed_iff {s : set (cofinite_topology Î±)} : is_closed s â†” s = univ âˆ¨ s.finite := by\n  simp [â† is_open_compl_iff, is_open_iff']\n#align is_closed_iff is_closed_iff\n\n",
 "interior_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem interior_prod_eq (s : set Î±) (t : set Î²) :\n    interior (finset.product s t) = finset.product (interior s) (interior t) :=\n  Set.ext fun âŸ¨a, bâŸ© => by simp only [mem_interior_iff_mem_nhds, mem_prod, prod_mem_nhds_iff]\n#align interior_prod_eq interior_prod_eq\n\n",
 "interior_pi_set":
 "theorem interior_pi_set {I : set Î¹} (hI : I.finite) {s : âˆ€ i, set (Ï€ i)} :\n    interior (pi I s) = I.pi fun i => interior (s i) := by\n  ext a\n  simp only [Set.mem_pi, mem_interior_iff_mem_nhds, set_pi_mem_nhds_iff hI]\n#align interior_pi_set interior_pi_set\n\n",
 "inducing_sigma_map":
 "theorem inducing_sigma_map {fâ‚ : Î¹ â†’ Îº} {fâ‚‚ : âˆ€ i, Ïƒ i â†’ Ï„ (fâ‚ i)} (hâ‚ : injective fâ‚) :\n    inducing (sigma.map fâ‚ fâ‚‚) â†” âˆ€ i, inducing (fâ‚‚ i) := by\n  simp only [inducing_iff_nhds, sigma.forall, sigma.nhds_mk, sigma.map, â† map_sigma_mk_comap hâ‚,\n    map_inj sigma_mk_injective]\n#align inducing_sigma_map inducing_sigma_map\n\n",
 "inducing_infi_to_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/-- Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. -/\ntheorem inducing_infi_to_pi {X : Type _} (f : âˆ€ i, X â†’ Ï€ i) :\n    @inducing X (âˆ€ i, Ï€ i)\n      (Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        (induced (f i) infer_instance))\n      _ fun x i => f i x :=\n  by\n  constructor\n  erw [induced_infi]\n  congr 1\n  funext\n  erw [induced_compose]\n#align inducing_infi_to_pi inducing_infi_to_pi\n\n",
 "inducing_coe":
 "theorem inducing_coe {b : set Î²} : inducing (coe : b â†’ Î²) :=\n  âŸ¨rflâŸ©\n#align inducing_coe inducing_coe\n\n",
 "fst''":
 "/-- Precomposing `f` with `prod.fst` is continuous at `x : Î± Ã— Î²` -/\ntheorem continuous_at.fst'' {f : Î± â†’ Î³} {x : Î± Ã— Î²} (hf : continuous_at f x.fst) :\n    continuous_at (fun x : Î± Ã— Î² => f x.fst) x :=\n  hf.comp continuous_at_fst\n#align continuous_at.fst'' continuous_at.fst''\n\n",
 "fst'":
 "/-- Precomposing `f` with `prod.fst` is continuous at `(x, y)` -/\ntheorem continuous_at.fst' {f : Î± â†’ Î³} {x : Î±} {y : Î²} (hf : continuous_at f x) :\n    continuous_at (fun x : Î± Ã— Î² => f x.fst) (x, y) :=\n  continuous_at.comp hf continuous_at_fst\n#align continuous_at.fst' continuous_at.fst'\n\n",
 "fst":
 "/-- Postcomposing `f` with `prod.fst` is continuous at `x` -/\ntheorem continuous_at.fst {f : Î± â†’ Î² Ã— Î³} {x : Î±} (hf : continuous_at f x) : continuous_at (fun a : Î± => (f a).1) x :=\n  continuous_at_fst.comp hf\n#align continuous_at.fst continuous_at.fst\n\n",
 "frontier_univ_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem frontier_univ_prod_eq (s : set Î²) :\n    frontier (finset.product (univ : set Î±) s) = finset.product univ (frontier s) := by simp [frontier_prod_eq]\n#align frontier_univ_prod_eq frontier_univ_prod_eq\n\n",
 "frontier_prod_univ_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem frontier_prod_univ_eq (s : set Î±) :\n    frontier (finset.product s (univ : set Î²)) = finset.product (frontier s) univ := by simp [frontier_prod_eq]\n#align frontier_prod_univ_eq frontier_prod_univ_eq\n\n",
 "frontier_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem frontier_prod_eq (s : set Î±) (t : set Î²) :\n    frontier (finset.product s t) = finset.product (closure s) (frontier t) âˆª finset.product (frontier s) (closure t) :=\n  by simp only [frontier, closure_prod_eq, interior_prod_eq, prod_diff_prod]\n#align frontier_prod_eq frontier_prod_eq\n\n",
 "fin_insert_nth":
 "theorem continuous.fin_insert_nth {n} {Ï€ : fin (n + 1) â†’ Type _} [âˆ€ i, topological_space (Ï€ i)] (i : fin (n + 1))\n    {f : Î± â†’ Ï€ i} (hf : continuous f) {g : Î± â†’ âˆ€ j : fin n, Ï€ (i.succ_above j)} (hg : continuous g) :\n    continuous fun a => i.insert_nth (f a) (g a) :=\n  continuous_iff_continuous_at.2 fun a => hf.continuous_at.fin_insert_nth i hg.continuous_at\n#align continuous.fin_insert_nth continuous.fin_insert_nth\n\n",
 "exists_nhds_square":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/-- Given a neighborhood `s` of `(x, x)`, then `(x, x)` has a square open neighborhood\n  that is a subset of `s`. -/\ntheorem exists_nhds_square {s : set (Î± Ã— Î±)} {x : Î±} (hx : s âˆˆ (nhds) (x, x)) :\n    âˆƒ U : set Î±, is_open U âˆ§ x âˆˆ U âˆ§ finset.product U U âŠ† s := by\n  simpa [nhds_prod_eq, (nhds_basis_opens x).prod_self.mem_iff, and_assoc, and_left_comm] using hx\n#align exists_nhds_square exists_nhds_square\n\n",
 "exists_finset_piecewise_mem_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_finset_piecewise_mem_of_mem_nhds [decidable_eq Î¹] {s : set (âˆ€ a, Ï€ a)} {x : âˆ€ a, Ï€ a} (hs : s âˆˆ (nhds) x)\n    (y : âˆ€ a, Ï€ a) : âˆƒ I : Finset Î¹, I.piecewise x y âˆˆ s :=\n  by\n  simp only [nhds_pi, filter.mem_pi'] at hs\n  rcases hs with âŸ¨I, t, htx, htsâŸ©\n  refine' âŸ¨I, hts fun i hi => _âŸ©\n  simpa [Finset.mem_coe.1 hi] using mem_of_mem_nhds (htx i)\n#align exists_finset_piecewise_mem_of_mem_nhds exists_finset_piecewise_mem_of_mem_nhds\n\n",
 "embedding_subtype_coe":
 "theorem embedding_subtype_coe : embedding (coe : subtype p â†’ Î±) :=\n  âŸ¨âŸ¨rflâŸ©, subtype.coe_injectiveâŸ©\n#align embedding_subtype_coe embedding_subtype_coe\n\n",
 "embedding_sigma_mk":
 "theorem embedding_sigma_mk {i : Î¹} : embedding (@sigma.mk Î¹ Ïƒ i) :=\n  closed_embedding_sigma_mk.1\n#align embedding_sigma_mk embedding_sigma_mk\n\n",
 "embedding_sigma_map":
 "theorem embedding_sigma_map {fâ‚ : Î¹ â†’ Îº} {fâ‚‚ : âˆ€ i, Ïƒ i â†’ Ï„ (fâ‚ i)} (h : injective fâ‚) :\n    embedding (sigma.map fâ‚ fâ‚‚) â†” âˆ€ i, embedding (fâ‚‚ i) := by\n  simp only [embedding_iff, injective.sigma_map, inducing_sigma_map h, forall_and, h.sigma_map_iff]\n#align embedding_sigma_map embedding_sigma_map\n\n",
 "embedding_inr":
 "theorem embedding_inr : embedding (@inr Î± Î²) :=\n  open_embedding_inr.1\n#align embedding_inr embedding_inr\n\n",
 "embedding_inl":
 "theorem embedding_inl : embedding (@inl Î± Î²) :=\n  open_embedding_inl.1\n#align embedding_inl embedding_inl\n\n",
 "embedding_graph":
 "theorem embedding_graph {f : Î± â†’ Î²} (hf : continuous f) : embedding fun x => (x, f x) :=\n  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id\n#align embedding_graph embedding_graph\n\n",
 "discrete_topology_subtype_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem discrete_topology_subtype_iff {S : set Î±} :\n    discrete_topology S â†” âˆ€ x âˆˆ S, Â«expr âŠ“ Â» (nhds_within.ne x) ((filter.principal) S) = Â«exprâŠ¥Â» := by\n  simp_rw [discrete_topology_iff_nhds_ne, SetCoe.forall', nhds_ne_subtype_eq_bot_iff]\n#align discrete_topology_subtype_iff discrete_topology_subtype_iff\n\n",
 "dense_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem subtype.dense_iff {s : set Î±} {t : set s} : dense t â†” s âŠ† closure (Â«expr '' Â» coe t) :=\n  by\n  rw [inducing_coe.dense_iff, SetCoe.forall]\n  rfl\n#align subtype.dense_iff subtype.dense_iff\n\n",
 "curry_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually.curry_nhds {p : Î± Ã— Î² â†’ Prop} {x : Î±} {y : Î²}\n    (h :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n        ((nhds) (x, y)) (p x)) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) x)\n      (Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n        ((nhds) y) (p (x', y'))) :=\n  by\n  rw [nhds_prod_eq] at h\n  exact h.curry\n#align filter.eventually.curry_nhds filter.eventually.curry_nhds\n\n",
 "continuous_update":
 "/-- `update f i x` is continuous in `(f, x)`. -/\n@[continuity]\ntheorem continuous_update [decidable_eq Î¹] (i : Î¹) : continuous fun f : (âˆ€ j, Ï€ j) Ã— Ï€ i => update f.1 i f.2 :=\n  continuous_fst.update i continuous_snd\n#align continuous_update continuous_update\n\n",
 "continuous_uncurry_right":
 "theorem continuous_uncurry_right {f : Î± â†’ Î² â†’ Î³} (b : Î²) (h : continuous (uncurry f)) : continuous fun a => f a b :=\n  show continuous (uncurry f âˆ˜ fun a => (a, b)) from h.comp (by continuity)\n#align continuous_uncurry_right continuous_uncurry_right\n\n",
 "continuous_uncurry_of_discrete_topology_left":
 "theorem continuous_uncurry_of_discrete_topology_left [discrete_topology Î±] {f : Î± â†’ Î² â†’ Î³} (h : âˆ€ a, continuous (f a)) :\n    continuous (uncurry f) :=\n  continuous_iff_continuous_at.2 fun âŸ¨a, bâŸ© => by\n    simp only [continuous_at, nhds_prod_eq, nhds_discrete Î±, pure_prod, tendsto_map'_iff, (Â· âˆ˜ Â·), uncurry,\n      (h a).tendsto]\n#align continuous_uncurry_of_discrete_topology_left continuous_uncurry_of_discrete_topology_left\n\n",
 "continuous_uncurry_of_discrete_topology":
 "/-- If a function `f x y` is such that `y â†¦ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem continuous_uncurry_of_discrete_topology [discrete_topology Î±] {f : Î± â†’ Î² â†’ Î³} (hf : âˆ€ a, continuous (f a)) :\n    continuous (uncurry f) := by\n  apply continuous_iff_continuous_at.2\n  rintro âŸ¨a, xâŸ©\n  change map _ _ â‰¤ _\n  rw [nhds_prod_eq, nhds_discrete, filter.map_pure_prod]\n  exact (hf a).continuous_at\n#align continuous_uncurry_of_discrete_topology continuous_uncurry_of_discrete_topology\n\n",
 "continuous_uncurry_left":
 "theorem continuous_uncurry_left {f : Î± â†’ Î² â†’ Î³} (a : Î±) (h : continuous (uncurry f)) : continuous (f a) :=\n  show continuous (uncurry f âˆ˜ fun b => (a, b)) from h.comp (by continuity)\n#align continuous_uncurry_left continuous_uncurry_left\n\n",
 "continuous_ulift_up":
 "@[continuity]\ntheorem continuous_ulift_up [topological_space Î±] : continuous (ulift.up : Î± â†’ ULift.{v, u} Î±) :=\n  continuous_induced_rng.2 continuous_id\n#align continuous_ulift_up continuous_ulift_up\n\n",
 "continuous_ulift_down":
 "@[continuity]\ntheorem continuous_ulift_down [topological_space Î±] : continuous (ulift.down : ULift.{v, u} Î± â†’ Î±) :=\n  continuous_induced_dom\n#align continuous_ulift_down continuous_ulift_down\n\n",
 "continuous_to_mul":
 "theorem continuous_to_mul : continuous (toMul : Additive Î± â†’ Î±) :=\n  continuous_id\n#align continuous_to_mul continuous_to_mul\n\n",
 "continuous_to_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\ntheorem continuous_to_dual : continuous (toDual : Î± â†’ Â«expr áµ’áµˆÂ» Î±) :=\n  continuous_id\n#align continuous_to_dual continuous_to_dual\n\n",
 "continuous_to_add":
 "theorem continuous_to_add : continuous (toAdd : Multiplicative Î± â†’ Î±) :=\n  continuous_id\n#align continuous_to_add continuous_to_add\n\n",
 "continuous_swap":
 "theorem continuous_swap : continuous (prod.swap : Î± Ã— Î² â†’ Î² Ã— Î±) :=\n  continuous_snd.prod_mk continuous_fst\n#align continuous_swap continuous_swap\n\n",
 "continuous_sum_map":
 "@[simp]\ntheorem continuous_sum_map {f : Î± â†’ Î²} {g : Î³ â†’ Î´} : continuous (sum.map f g) â†” continuous f âˆ§ continuous g :=\n  continuous_sum_elim.trans <| embedding_inl.continuous_iff.symm.and embedding_inr.continuous_iff.symm\n#align continuous_sum_map continuous_sum_map\n\n",
 "continuous_sum_elim":
 "theorem continuous_sum_elim {f : Î± â†’ Î³} {g : Î² â†’ Î³} : continuous (sum.elim f g) â†” continuous f âˆ§ continuous g := by\n  simp only [continuous_sup_dom, continuous_coinduced_dom, sum.elim_comp_inl, sum.elim_comp_inr]\n#align continuous_sum_elim continuous_sum_elim\n\n",
 "continuous_subtype_val":
 "@[continuity]\ntheorem continuous_subtype_val : continuous (@subtype.val Î± p) :=\n  continuous_induced_dom\n#align continuous_subtype_val continuous_subtype_val\n\n",
 "continuous_subtype_nhds_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_subtype_nhds_cover {Î¹ : Sort _} {f : Î± â†’ Î²} {c : Î¹ â†’ Î± â†’ Prop}\n    (c_cover : âˆ€ x : Î±, âˆƒ i, { x | c i x } âˆˆ (nhds) x) (f_cont : âˆ€ i, continuous fun x : subtype (c i) => f x) :\n    continuous f :=\n  continuous_iff_continuous_at.mpr fun x =>\n    let âŸ¨i, (c_sets : { x | c i x } âˆˆ (nhds) x)âŸ© := c_cover x\n    let x' : subtype (c i) := âŸ¨x, mem_of_mem_nhds c_setsâŸ©\n    calc\n      map f ((nhds) x) = map f (map coe ((nhds) x')) := congr_arg (map f) (map_nhds_subtype_coe_eq _ <| c_sets).symm\n      _ = map (fun x : subtype (c i) => f x) ((nhds) x') := rfl\n      _ â‰¤ (nhds) (f x) := continuous_iff_continuous_at.mp (f_cont i) x'\n      \n#align continuous_subtype_nhds_cover continuous_subtype_nhds_cover\n\n",
 "continuous_subtype_is_closed_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem continuous_subtype_is_closed_cover {Î¹ : Sort _} {f : Î± â†’ Î²} (c : Î¹ â†’ Î± â†’ Prop)\n    (h_lf : locally_finite fun i => { x | c i x }) (h_is_closed : âˆ€ i, is_closed { x | c i x })\n    (h_cover : âˆ€ x, âˆƒ i, c i x) (f_cont : âˆ€ i, continuous fun x : subtype (c i) => f x) : continuous f :=\n  continuous_iff_is_closed.mpr fun s hs =>\n    by\n    have : âˆ€ i, is_closed (Â«expr '' Â» (coe : { x | c i x } â†’ Î±) (Â«expr â»Â¹' Â» (f âˆ˜ coe) s)) := fun i =>\n      (closed_embedding_subtype_coe (h_is_closed _)).is_closed_map _ (hs.preimage (f_cont i))\n    have :\n      is_closed\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n          (Â«expr '' Â» (coe : { x | c i x } â†’ Î±) (Â«expr â»Â¹' Â» (f âˆ˜ coe) s))) :=\n      locally_finite.is_closed_Union (h_lf.subset fun i x âŸ¨âŸ¨x', hx'âŸ©, _, HEqâŸ© => HEq â–¸ hx') this\n    have :\n      Â«expr â»Â¹' Â» f s =\n        Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n          (Â«expr '' Â» (coe : { x | c i x } â†’ Î±) (Â«expr â»Â¹' Â» (f âˆ˜ coe) s)) :=\n      by\n      apply Set.ext\n      have : âˆ€ x : Î±, f x âˆˆ s â†” âˆƒ i : Î¹, c i x âˆ§ f x âˆˆ s := fun x =>\n        âŸ¨fun hx =>\n          let âŸ¨i, hiâŸ© := h_cover x\n          âŸ¨i, hi, hxâŸ©,\n          fun âŸ¨i, hi, hxâŸ© => hxâŸ©\n      simpa [and_comm, @and_left_comm (c _ _), â† exists_and_right]\n    rwa [this]\n#align continuous_subtype_is_closed_cover continuous_subtype_is_closed_cover\n\n",
 "continuous_subtype_coe":
 "theorem continuous_subtype_coe : continuous (coe : subtype p â†’ Î±) :=\n  continuous_subtype_val\n#align continuous_subtype_coe continuous_subtype_coe\n\n",
 "continuous_snd":
 "@[continuity]\ntheorem continuous_snd : continuous (@prod.snd Î± Î²) :=\n  continuous_inf_dom_right continuous_induced_dom\n#align continuous_snd continuous_snd\n\n",
 "continuous_sigma_mk":
 "@[continuity]\ntheorem continuous_sigma_mk {i : Î¹} : continuous (@sigma.mk Î¹ Ïƒ i) :=\n  continuous_supr_rng continuous_coinduced_rng\n#align continuous_sigma_mk continuous_sigma_mk\n\n",
 "continuous_sigma_map":
 "@[simp]\ntheorem continuous_sigma_map {fâ‚ : Î¹ â†’ Îº} {fâ‚‚ : âˆ€ i, Ïƒ i â†’ Ï„ (fâ‚ i)} :\n    continuous (sigma.map fâ‚ fâ‚‚) â†” âˆ€ i, continuous (fâ‚‚ i) :=\n  continuous_sigma_iff.trans <| by simp only [sigma.map, embedding_sigma_mk.continuous_iff]\n#align continuous_sigma_map continuous_sigma_map\n\n",
 "continuous_sigma_iff":
 "/-- A map out of a sum type is continuous iff its restriction to each summand is. -/\n@[simp]\ntheorem continuous_sigma_iff {f : sigma Ïƒ â†’ Î±} : continuous f â†” âˆ€ i, continuous fun a => f âŸ¨i, aâŸ© := by\n  simp only [continuous_supr_dom, continuous_coinduced_dom]\n#align continuous_sigma_iff continuous_sigma_iff\n\n",
 "continuous_sigma":
 "/-- A map out of a sum type is continuous if its restriction to each summand is. -/\n@[continuity]\ntheorem continuous_sigma {f : sigma Ïƒ â†’ Î±} (hf : âˆ€ i, continuous fun a => f âŸ¨i, aâŸ©) : continuous f :=\n  continuous_sigma_iff.2 hf\n#align continuous_sigma continuous_sigma\n\n",
 "continuous_quotient_mk":
 "theorem continuous_quotient_mk : continuous (@Quotient.mk'' Î± s) :=\n  continuous_coinduced_rng\n#align continuous_quotient_mk continuous_quotient_mk\n\n",
 "continuous_quot_mk":
 "@[continuity]\ntheorem continuous_quot_mk : continuous (@Quot.mk Î± r) :=\n  continuous_coinduced_rng\n#align continuous_quot_mk continuous_quot_mk\n\n",
 "continuous_quot_lift":
 "@[continuity]\ntheorem continuous_quot_lift {f : Î± â†’ Î²} (hr : âˆ€ a b, r a b â†’ f a = f b) (h : continuous f) :\n    continuous (Quot.lift f hr : Quot r â†’ Î²) :=\n  continuous_coinduced_dom.2 h\n#align continuous_quot_lift continuous_quot_lift\n\n",
 "continuous_prod_mk":
 "@[simp]\ntheorem continuous_prod_mk {f : Î± â†’ Î²} {g : Î± â†’ Î³} : (continuous fun x => (f x, g x)) â†” continuous f âˆ§ continuous g :=\n  âŸ¨fun h => âŸ¨h.fst, h.sndâŸ©, fun h => h.1.prod_mk h.2âŸ©\n#align continuous_prod_mk continuous_prod_mk\n\n",
 "continuous_pi_iff":
 "theorem continuous_pi_iff : continuous f â†” âˆ€ i, continuous fun a => f a i := by\n  simp only [continuous_infi_rng, continuous_induced_rng]\n#align continuous_pi_iff continuous_pi_iff\n\n",
 "continuous_pi":
 "@[continuity]\ntheorem continuous_pi (h : âˆ€ i, continuous fun a => f a i) : continuous f :=\n  continuous_pi_iff.2 h\n#align continuous_pi continuous_pi\n\n",
 "continuous_of_mul":
 "/-\nCopyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes HÃ¶lzl, Mario Carneiro, Patrick Massot\n-/\ntheorem continuous_of_mul : continuous (ofMul : Î± â†’ Additive Î±) :=\n  continuous_id\n#align continuous_of_mul continuous_of_mul\n\n",
 "continuous_of_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr áµ’áµˆÂ» -/\ntheorem continuous_of_dual : continuous (ofDual : Â«expr áµ’áµˆÂ» Î± â†’ Î±) :=\n  continuous_id\n#align continuous_of_dual continuous_of_dual\n\n",
 "continuous_of_add":
 "theorem continuous_of_add : continuous (ofAdd : Î± â†’ Multiplicative Î±) :=\n  continuous_id\n#align continuous_of_add continuous_of_add\n\n",
 "continuous_inr":
 "@[continuity]\ntheorem continuous_inr : continuous (@inr Î± Î²) :=\n  continuous_sup_rng_right continuous_coinduced_rng\n#align continuous_inr continuous_inr\n\n",
 "continuous_inl":
 "@[continuity]\ntheorem continuous_inl : continuous (@inl Î± Î²) :=\n  continuous_sup_rng_left continuous_coinduced_rng\n#align continuous_inl continuous_inl\n\n",
 "continuous_inf_dom_rightâ‚‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/-- A version of `continuous_inf_dom_right` for binary functions -/\ntheorem continuous_inf_dom_rightâ‚‚ {Î± Î² Î³} {f : Î± â†’ Î² â†’ Î³} {ta1 ta2 : topological_space Î±}\n    {tb1 tb2 : topological_space Î²} {tc1 : topological_space Î³}\n    (h : by haveI := ta2 <;> haveI := tb2 <;> exact continuous fun p : Î± Ã— Î² => f p.1 p.2) : by\n    haveI := Â«expr âŠ“ Â» ta1 ta2 <;> haveI := Â«expr âŠ“ Â» tb1 tb2 <;> exact continuous fun p : Î± Ã— Î² => f p.1 p.2 :=\n  by\n  have ha := @continuous_inf_dom_right _ _ id ta1 ta2 ta2 (@continuous_id _ (id _))\n  have hb := @continuous_inf_dom_right _ _ id tb1 tb2 tb2 (@continuous_id _ (id _))\n  have h_continuous_id := @continuous.prod_map _ _ _ _ ta2 tb2 (Â«expr âŠ“ Â» ta1 ta2) (Â«expr âŠ“ Â» tb1 tb2) _ _ ha hb\n  exact @continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id\n#align continuous_inf_dom_rightâ‚‚ continuous_inf_dom_rightâ‚‚\n\n",
 "continuous_inf_dom_leftâ‚‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/-- A version of `continuous_inf_dom_left` for binary functions -/\ntheorem continuous_inf_dom_leftâ‚‚ {Î± Î² Î³} {f : Î± â†’ Î² â†’ Î³} {ta1 ta2 : topological_space Î±} {tb1 tb2 : topological_space Î²}\n    {tc1 : topological_space Î³} (h : by haveI := ta1 <;> haveI := tb1 <;> exact continuous fun p : Î± Ã— Î² => f p.1 p.2) :\n    by haveI := Â«expr âŠ“ Â» ta1 ta2 <;> haveI := Â«expr âŠ“ Â» tb1 tb2 <;> exact continuous fun p : Î± Ã— Î² => f p.1 p.2 :=\n  by\n  have ha := @continuous_inf_dom_left _ _ id ta1 ta2 ta1 (@continuous_id _ (id _))\n  have hb := @continuous_inf_dom_left _ _ id tb1 tb2 tb1 (@continuous_id _ (id _))\n  have h_continuous_id := @continuous.prod_map _ _ _ _ ta1 tb1 (Â«expr âŠ“ Â» ta1 ta2) (Â«expr âŠ“ Â» tb1 tb2) _ _ ha hb\n  exact @continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id\n#align continuous_inf_dom_leftâ‚‚ continuous_inf_dom_leftâ‚‚\n\n",
 "continuous_inclusion":
 "theorem continuous_inclusion {s t : set Î±} (h : s âŠ† t) : continuous (inclusion h) :=\n  continuous_id.subtype_map h\n#align continuous_inclusion continuous_inclusion\n\n",
 "continuous_fst":
 "@[continuity]\ntheorem continuous_fst : continuous (@prod.fst Î± Î²) :=\n  continuous_inf_dom_left continuous_induced_dom\n#align continuous_fst continuous_fst\n\n",
 "continuous_curry":
 "theorem continuous_curry {g : Î± Ã— Î² â†’ Î³} (a : Î±) (h : continuous g) : continuous (curry g a) :=\n  show continuous (g âˆ˜ fun b => (a, b)) from h.comp (by continuity)\n#align continuous_curry continuous_curry\n\n",
 "continuous_at_subtype_coe":
 "theorem continuous_at_subtype_coe {p : Î± â†’ Prop} {a : subtype p} : continuous_at (coe : subtype p â†’ Î±) a :=\n  continuous_iff_continuous_at.mp continuous_subtype_coe _\n#align continuous_at_subtype_coe continuous_at_subtype_coe\n\n",
 "continuous_at_snd":
 "theorem continuous_at_snd {p : Î± Ã— Î²} : continuous_at prod.snd p :=\n  continuous_snd.continuous_at\n#align continuous_at_snd continuous_at_snd\n\n",
 "continuous_at_pi":
 "theorem continuous_at_pi {f : Î± â†’ âˆ€ i, Ï€ i} {x : Î±} : continuous_at f x â†” âˆ€ i, continuous_at (fun y => f y i) x :=\n  tendsto_pi_nhds\n#align continuous_at_pi continuous_at_pi\n\n",
 "continuous_at_fst":
 "theorem continuous_at_fst {p : Î± Ã— Î²} : continuous_at prod.fst p :=\n  continuous_fst.continuous_at\n#align continuous_at_fst continuous_at_fst\n\n",
 "continuous_at_cod_restrict_iff":
 "theorem continuous_at_cod_restrict_iff {f : Î± â†’ Î²} {t : set Î²} (h1 : âˆ€ x, f x âˆˆ t) {x : Î±} :\n    continuous_at (codRestrict f t h1) x â†” continuous_at f x := by\n  simp_rw [inducing_coe.continuous_at_iff, function.comp, coe_cod_restrict_apply]\n#align continuous_at_cod_restrict_iff continuous_at_cod_restrict_iff\n\n",
 "continuous_at_apply":
 "theorem continuous_at_apply (i : Î¹) (x : âˆ€ i, Ï€ i) : continuous_at (fun p : âˆ€ i, Ï€ i => p i) x :=\n  (continuous_apply i).continuous_at\n#align continuous_at_apply continuous_at_apply\n\n",
 "continuous_apply_apply":
 "@[continuity]\ntheorem continuous_apply_apply {Ï : Îº â†’ Î¹ â†’ Type _} [âˆ€ j i, topological_space (Ï j i)] (j : Îº) (i : Î¹) :\n    continuous fun p : âˆ€ j, âˆ€ i, Ï j i => p j i :=\n  (continuous_apply i).comp (continuous_apply j)\n#align continuous_apply_apply continuous_apply_apply\n\n",
 "continuous_apply":
 "@[continuity]\ntheorem continuous_apply (i : Î¹) : continuous fun p : âˆ€ i, Ï€ i => p i :=\n  continuous_infi_dom continuous_induced_dom\n#align continuous_apply continuous_apply\n\n",
 "continuous_Inf_domâ‚‚":
 "/-- A version of `continuous_Inf_dom` for binary functions -/\ntheorem continuous_Inf_domâ‚‚ {Î± Î² Î³} {f : Î± â†’ Î² â†’ Î³} {tas : set (topological_space Î±)} {tbs : set (topological_space Î²)}\n    {ta : topological_space Î±} {tb : topological_space Î²} {tc : topological_space Î³} (ha : ta âˆˆ tas) (hb : tb âˆˆ tbs)\n    (hf : continuous fun p : Î± Ã— Î² => f p.1 p.2) : by\n    haveI := Inf tas <;> haveI := Inf tbs <;> exact @continuous _ _ _ tc fun p : Î± Ã— Î² => f p.1 p.2 :=\n  by\n  let t : topological_space (Î± Ã— Î²) := prod.topological_space\n  have ha := continuous_Inf_dom ha continuous_id\n  have hb := continuous_Inf_dom hb continuous_id\n  have h_continuous_id := @continuous.prod_map _ _ _ _ ta tb (Inf tas) (Inf tbs) _ _ ha hb\n  exact @continuous.comp _ _ _ (id _) (id _) _ _ _ hf h_continuous_id\n#align continuous_Inf_domâ‚‚ continuous_Inf_domâ‚‚\n\n",
 "compâ‚„":
 "theorem continuous.compâ‚„ {g : Î± Ã— Î² Ã— Î³ Ã— Î¶ â†’ Îµ} (hg : continuous g) {e : Î´ â†’ Î±} (he : continuous e) {f : Î´ â†’ Î²}\n    (hf : continuous f) {k : Î´ â†’ Î³} (hk : continuous k) {l : Î´ â†’ Î¶} (hl : continuous l) :\n    continuous fun x => g (e x, f x, k x, l x) :=\n  hg.compâ‚ƒ he hf <| hk.prod_mk hl\n#align continuous.compâ‚„ continuous.compâ‚„\n\n",
 "compâ‚ƒ":
 "theorem continuous.compâ‚ƒ {g : Î± Ã— Î² Ã— Î³ â†’ Îµ} (hg : continuous g) {e : Î´ â†’ Î±} (he : continuous e) {f : Î´ â†’ Î²}\n    (hf : continuous f) {k : Î´ â†’ Î³} (hk : continuous k) : continuous fun x => g (e x, f x, k x) :=\n  hg.compâ‚‚ he <| hf.prod_mk hk\n#align continuous.compâ‚ƒ continuous.compâ‚ƒ\n\n",
 "compâ‚‚":
 "theorem continuous.compâ‚‚ {g : Î± Ã— Î² â†’ Î³} (hg : continuous g) {e : Î´ â†’ Î±} (he : continuous e) {f : Î´ â†’ Î²}\n    (hf : continuous f) : continuous fun x => g (e x, f x) :=\n  hg.comp <| he.prod_mk hf\n#align continuous.compâ‚‚ continuous.compâ‚‚\n\n",
 "comap_sigma_mk_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem comap_sigma_mk_nhds (i : Î¹) (x : Ïƒ i) : comap (sigma.mk i) ((nhds) âŸ¨i, xâŸ©) = (nhds) x :=\n  (embedding_sigma_mk.to_inducing.nhds_eq_comap _).symm\n#align comap_sigma_mk_nhds comap_sigma_mk_nhds\n\n",
 "cod_restrict":
 "theorem embedding.cod_restrict {e : Î± â†’ Î²} (he : embedding e) (s : set Î²) (hs : âˆ€ x, e x âˆˆ s) :\n    embedding (codRestrict e s hs) :=\n  embedding_of_embedding_compose (he.continuous.cod_restrict hs) continuous_subtype_coe he\n#align embedding.cod_restrict embedding.cod_restrict\n\n",
 "closure_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem closure_subtype {x : { a // p a }} {s : set { a // p a }} :\n    x âˆˆ closure s â†” (x : Î±) âˆˆ closure (Â«expr '' Â» (coe : _ â†’ Î±) s) :=\n  closure_induced\n#align closure_subtype closure_subtype\n\n",
 "closure_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem closure_prod_eq {s : set Î±} {t : set Î²} :\n    closure (finset.product s t) = finset.product (closure s) (closure t) :=\n  Set.ext fun âŸ¨a, bâŸ© =>\n    by\n    have :\n      Â«expr âŠ“ Â» (filter.prod ((nhds) a) ((nhds) b)) ((filter.principal) (finset.product s t)) =\n        filter.prod (Â«expr âŠ“ Â» ((nhds) a) ((filter.principal) s)) (Â«expr âŠ“ Â» ((nhds) b) ((filter.principal) t)) :=\n      by rw [â† prod_inf_prod, prod_principal_principal]\n    simp [closure_eq_cluster_pts, cluster_pt, nhds_prod_eq, this] <;> exact prod_ne_bot\n#align closure_prod_eq closure_prod_eq\n\n",
 "closed_embedding_subtype_coe":
 "theorem is_closed.closed_embedding_subtype_coe {s : set Î±} (hs : is_closed s) :\n    closed_embedding (coe : { x // x âˆˆ s } â†’ Î±) :=\n  { induced := rfl\n    inj := subtype.coe_injective\n    closed_range := (Subtype.range_coe : range coe = s).symm â–¸ hs }\n#align is_closed.closed_embedding_subtype_coe is_closed.closed_embedding_subtype_coe\n\n",
 "closed_embedding_sigma_mk":
 "theorem closed_embedding_sigma_mk {i : Î¹} : closed_embedding (@sigma.mk Î¹ Ïƒ i) :=\n  closed_embedding_of_continuous_injective_closed continuous_sigma_mk sigma_mk_injective is_closed_map_sigma_mk\n#align closed_embedding_sigma_mk closed_embedding_sigma_mk\n\n",
 "closed_embedding_inr":
 "theorem closed_embedding_inr : closed_embedding (inr : Î² â†’ Sum Î± Î²) :=\n  âŸ¨embedding_inr, is_closed_range_inrâŸ©\n#align closed_embedding_inr closed_embedding_inr\n\n",
 "closed_embedding_inl":
 "theorem closed_embedding_inl : closed_embedding (inl : Î± â†’ Sum Î± Î²) :=\n  âŸ¨embedding_inl, is_closed_range_inlâŸ©\n#align closed_embedding_inl closed_embedding_inl\n\n",
 "apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.tendsto.apply {l : filter Î²} {f : Î² â†’ âˆ€ i, Ï€ i} {x : âˆ€ i, Ï€ i} (h : tendsto f l ((nhds) x)) (i : Î¹) :\n    tendsto (fun a => f a i) l (nhds <| x i) :=\n  (continuous_at_apply i _).tendsto.comp h\n#align filter.tendsto.apply filter.tendsto.apply\n\n"}