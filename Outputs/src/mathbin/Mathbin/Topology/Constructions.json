{"update":
 "#print Continuous.update /-\ntheorem Continuous.update [DecidableEq ι] (hf : Continuous f) (i : ι) {g : α → π i} (hg : Continuous g) :\n    Continuous fun a => update (f a) i (g a) :=\n  continuous_iff_continuousAt.2 fun x => hf.continuous_at.update i hg.continuous_at\n#align continuous.update Continuous.update\n-/\n\n",
 "tendsto_subtype_rng":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_subtype_rng /-\ntheorem tendsto_subtype_rng {β : Type _} {p : α → Prop} {b : Filter β} {f : β → Subtype p} :\n    ∀ {a : Subtype p}, Tendsto f b ((nhds) a) ↔ Tendsto (fun x => (f x : α)) b ((nhds) (a : α))\n  | ⟨a, ha⟩ => by rw [nhds_subtype_eq_comap, tendsto_comap_iff, Subtype.coe_mk]\n#align tendsto_subtype_rng tendsto_subtype_rng\n-/\n\n",
 "tendsto_pi_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_pi_nhds /-\ntheorem tendsto_pi_nhds {f : β → ∀ i, π i} {g : ∀ i, π i} {u : Filter β} :\n    Tendsto f u ((nhds) g) ↔ ∀ x, Tendsto (fun i => f i x) u ((nhds) (g x)) := by rw [nhds_pi, Filter.tendsto_pi]\n#align tendsto_pi_nhds tendsto_pi_nhds\n-/\n\n",
 "tendsto_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Prod.tendsto_iff /-\ntheorem Prod.tendsto_iff {α} (seq : α → β × γ) {f : Filter α} (x : β × γ) :\n    Tendsto seq f ((nhds) x) ↔\n      Tendsto (fun n => (seq n).fst) f ((nhds) x.fst) ∧ Tendsto (fun n => (seq n).snd) f ((nhds) x.snd) :=\n  by\n  cases x\n  rw [nhds_prod_eq, Filter.tendsto_prod_iff']\n#align prod.tendsto_iff Prod.tendsto_iff\n-/\n\n",
 "sum_map":
 "#print Continuous.sum_map /-\n@[continuity]\ntheorem Continuous.sum_map {f : α → β} {g : γ → δ} (hf : Continuous f) (hg : Continuous g) : Continuous (Sum.map f g) :=\n  continuous_sum_map.2 ⟨hf, hg⟩\n#align continuous.sum_map Continuous.sum_map\n-/\n\n",
 "sum_elim":
 "#print IsOpenMap.sum_elim /-\ntheorem IsOpenMap.sum_elim {f : α → γ} {g : β → γ} (hf : IsOpenMap f) (hg : IsOpenMap g) : IsOpenMap (Sum.elim f g) :=\n  isOpenMap_sum_elim.2 ⟨hf, hg⟩\n#align is_open_map.sum_elim IsOpenMap.sum_elim\n-/\n\n",
 "subtype_val":
 "#print Continuous.subtype_val /-\ntheorem Continuous.subtype_val {f : β → Subtype p} (hf : Continuous f) : Continuous fun x => (f x : α) :=\n  continuous_subtype_val.comp hf\n#align continuous.subtype_coe Continuous.subtype_val\n-/\n\n",
 "subtype_mk":
 "#print Continuous.subtype_mk /-\n@[continuity]\ntheorem Continuous.subtype_mk {f : β → α} (h : Continuous f) (hp : ∀ x, p (f x)) :\n    Continuous fun x => (⟨f x, hp x⟩ : Subtype p) :=\n  continuous_induced_rng.2 h\n#align continuous.subtype_mk Continuous.subtype_mk\n-/\n\n",
 "subtype_map":
 "#print Continuous.subtype_map /-\ntheorem Continuous.subtype_map {f : α → β} (h : Continuous f) {q : β → Prop} (hpq : ∀ x, p x → q (f x)) :\n    Continuous (Subtype.map f hpq) :=\n  (h.comp continuous_subtype_val).subtype_mk _\n#align continuous.subtype_map Continuous.subtype_map\n-/\n\n",
 "snd''":
 "#print ContinuousAt.snd'' /-\n/-- Precomposing `f` with `prod.snd` is continuous at `x : α × β` -/\ntheorem ContinuousAt.snd'' {f : β → γ} {x : α × β} (hf : ContinuousAt f x.snd) :\n    ContinuousAt (fun x : α × β => f x.snd) x :=\n  hf.comp continuousAt_snd\n#align continuous_at.snd'' ContinuousAt.snd''\n-/\n\n",
 "snd'":
 "#print ContinuousAt.snd' /-\n/-- Precomposing `f` with `prod.snd` is continuous at `(x, y)` -/\ntheorem ContinuousAt.snd' {f : β → γ} {x : α} {y : β} (hf : ContinuousAt f y) :\n    ContinuousAt (fun x : α × β => f x.snd) (x, y) :=\n  ContinuousAt.comp hf continuousAt_snd\n#align continuous_at.snd' ContinuousAt.snd'\n-/\n\n",
 "snd":
 "#print ContinuousAt.snd /-\n/-- Postcomposing `f` with `prod.snd` is continuous at `x` -/\ntheorem ContinuousAt.snd {f : α → β × γ} {x : α} (hf : ContinuousAt f x) : ContinuousAt (fun a : α => (f a).2) x :=\n  continuousAt_snd.comp hf\n#align continuous_at.snd ContinuousAt.snd\n-/\n\n",
 "sigma_map":
 "#print Continuous.sigma_map /-\n@[continuity]\ntheorem Continuous.sigma_map {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} (hf : ∀ i, Continuous (f₂ i)) :\n    Continuous (Sigma.map f₁ f₂) :=\n  continuous_sigma_map.2 hf\n#align continuous.sigma_map Continuous.sigma_map\n-/\n\n",
 "set_pi_mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print set_pi_mem_nhds_iff /-\ntheorem set_pi_mem_nhds_iff {I : Set ι} (hI : I.finite) {s : ∀ i, Set (π i)} (a : ∀ i, π i) :\n    I.pi s ∈ (nhds) a ↔ ∀ i : ι, i ∈ I → s i ∈ (nhds) (a i) :=\n  by\n  rw [nhds_pi, pi_mem_pi_iff hI]\n  infer_instance\n#align set_pi_mem_nhds_iff set_pi_mem_nhds_iff\n-/\n\n",
 "set_pi_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print set_pi_mem_nhds /-\ntheorem set_pi_mem_nhds {i : Set ι} {s : ∀ a, Set (π a)} {x : ∀ a, π a} (hi : i.finite)\n    (hs : ∀ a ∈ i, s a ∈ (nhds) (x a)) : pi i s ∈ (nhds) x :=\n  by\n  rw [pi_def, bInter_mem hi]\n  exact fun a ha => (continuous_apply a).continuous_at (hs a ha)\n#align set_pi_mem_nhds set_pi_mem_nhds\n-/\n\n",
 "restrictPreimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print ContinuousAt.restrictPreimage /-\ntheorem ContinuousAt.restrictPreimage {f : α → β} {s : Set β} {x : «expr ⁻¹' » f s} (h : ContinuousAt f x) :\n    ContinuousAt (s.restrict_preimage f) x :=\n  h.restrict _\n#align continuous_at.restrict_preimage ContinuousAt.restrictPreimage\n-/\n\n",
 "restrict":
 "#print ContinuousAt.restrict /-\ntheorem ContinuousAt.restrict {f : α → β} {s : Set α} {t : Set β} (h1 : MapsTo f s t) {x : s} (h2 : ContinuousAt f x) :\n    ContinuousAt (h1.restrict f s t) x :=\n  (h2.comp continuousAt_subtype_val).cod_restrict _\n#align continuous_at.restrict ContinuousAt.restrict\n-/\n\n",
 "quotient_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n#print Continuous.quotient_map' /-\ntheorem Continuous.quotient_map' {t : setoid β} {f : α → β} (hf : Continuous f) (H : («expr ⇒ » s.r t.r) f f) :\n    Continuous (Quotient.map' f H) :=\n  (continuous_quotient_mk'.comp hf).quotient_lift _\n#align continuous.quotient_map' Continuous.quotient_map'\n-/\n\n",
 "quotient_liftOn'":
 "#print Continuous.quotient_liftOn' /-\ntheorem Continuous.quotient_liftOn' {f : α → β} (h : Continuous f) (hs : ∀ a b, @Setoid.r _ s a b → f a = f b) :\n    Continuous (fun x => Quotient.liftOn' x f hs : quotient s → β) :=\n  h.quotient_lift hs\n#align continuous.quotient_lift_on' Continuous.quotient_liftOn'\n-/\n\n",
 "quotient_lift":
 "#print Continuous.quotient_lift /-\ntheorem Continuous.quotient_lift {f : α → β} (h : Continuous f) (hs : ∀ a b, a ≈ b → f a = f b) :\n    Continuous (quotient.lift f hs : quotient s → β) :=\n  continuous_coinduced_dom.2 h\n#align continuous.quotient_lift Continuous.quotient_lift\n-/\n\n",
 "quotientMap_quotient_mk'":
 "#print quotientMap_quotient_mk' /-\ntheorem quotientMap_quotient_mk' : QuotientMap (@Quotient.mk' α s) :=\n  quotientMap_quot_mk\n#align quotient_map_quotient_mk quotientMap_quotient_mk'\n-/\n\n",
 "quotientMap_quot_mk":
 "#print quotientMap_quot_mk /-\ntheorem quotientMap_quot_mk : QuotientMap (@Quot.mk α r) :=\n  ⟨quot.exists_rep, rfl⟩\n#align quotient_map_quot_mk quotientMap_quot_mk\n-/\n\n",
 "quotient":
 "#print DenseRange.quotient /-\n/-- The composition of `quotient.mk` and a function with dense range has dense range. -/\ntheorem DenseRange.quotient [setoid α] [TopologicalSpace α] {f : β → α} (hf : DenseRange f) :\n    DenseRange (Quotient.mk' ∘ f) :=\n  (surjective_quotient_mk α).dense_range.comp hf continuous_coinduced_rng\n#align dense_range.quotient DenseRange.quotient\n-/\n\n",
 "prod_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print Filter.HasBasis.prod_nhds' /-\ntheorem Filter.HasBasis.prod_nhds' {ιa ιb : Type _} {pa : ιa → Prop} {pb : ιb → Prop} {sa : ιa → Set α}\n    {sb : ιb → Set β} {ab : α × β} (ha : ((nhds) ab.1).has_basis pa sa) (hb : ((nhds) ab.2).has_basis pb sb) :\n    ((nhds) ab).has_basis (fun i : ιa × ιb => pa i.1 ∧ pb i.2) fun i => finset.product (sa i.1) (sb i.2) :=\n  by\n  cases ab\n  exact ha.prod_nhds hb\n#align filter.has_basis.prod_nhds' Filter.HasBasis.prod_nhds'\n-/\n\n",
 "prod_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Eventually.prod_nhds /-\ntheorem Filter.Eventually.prod_nhds {p : α → Prop} {q : β → Prop} {a : α} {b : β}\n    (ha :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p x))\n    (hb :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) b)\n        (q y)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((nhds) (a, b)) (p z.1 ∧ q z.2) :=\n  prod_mem_nhds ha hb\n#align filter.eventually.prod_nhds Filter.Eventually.prod_nhds\n-/\n\n",
 "prod_mk_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.prod_mk_nhds /-\ntheorem Filter.Tendsto.prod_mk_nhds {γ} {a : α} {b : β} {f : Filter γ} {ma : γ → α} {mb : γ → β}\n    (ha : Tendsto ma f ((nhds) a)) (hb : Tendsto mb f ((nhds) b)) : Tendsto (fun c => (ma c, mb c)) f ((nhds) (a, b)) :=\n  by rw [nhds_prod_eq] <;> exact Filter.Tendsto.prod_mk ha hb\n#align filter.tendsto.prod_mk_nhds Filter.Tendsto.prod_mk_nhds\n-/\n\n",
 "prod_mk":
 "#print Continuous.prod_mk /-\n@[continuity]\ntheorem Continuous.prod_mk {f : γ → α} {g : γ → β} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun x => (f x, g x) :=\n  continuous_inf_rng.2 ⟨continuous_induced_rng.2 hf, continuous_induced_rng.2 hg⟩\n#align continuous.prod_mk Continuous.prod_mk\n-/\n\n",
 "prod_mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print prod_mem_nhds_iff /-\ntheorem prod_mem_nhds_iff {s : Set α} {t : Set β} {a : α} {b : β} :\n    finset.product s t ∈ (nhds) (a, b) ↔ s ∈ (nhds) a ∧ t ∈ (nhds) b := by rw [nhds_prod_eq, prod_mem_prod_iff]\n#align prod_mem_nhds_iff prod_mem_nhds_iff\n-/\n\n",
 "prod_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print prod_mem_nhds /-\ntheorem prod_mem_nhds {s : Set α} {t : Set β} {a : α} {b : β} (ha : s ∈ (nhds) a) (hb : t ∈ (nhds) b) :\n    finset.product s t ∈ (nhds) (a, b) :=\n  prod_mem_nhds_iff.2 ⟨ha, hb⟩\n#align prod_mem_nhds prod_mem_nhds\n-/\n\n",
 "prod_map'":
 "#print ContinuousAt.prod_map' /-\ntheorem ContinuousAt.prod_map' {f : α → γ} {g : β → δ} {x : α} {y : β} (hf : ContinuousAt f x) (hg : ContinuousAt g y) :\n    ContinuousAt (fun p : α × β => (f p.1, g p.2)) (x, y) :=\n  hf.fst'.prod hg.snd'\n#align continuous_at.prod_map' ContinuousAt.prod_map'\n-/\n\n",
 "prod_map":
 "#print Embedding.prod_map /-\ntheorem Embedding.prod_map {f : α → β} {g : γ → δ} (hf : Embedding f) (hg : Embedding g) :\n    Embedding fun x : α × γ => (f x.1, g x.2) :=\n  { hf.to_inducing.prod_mk hg.to_inducing with\n    inj := fun ⟨x₁, x₂⟩ ⟨y₁, y₂⟩ => by simp <;> exact fun h₁ h₂ => ⟨hf.inj h₁, hg.inj h₂⟩ }\n#align embedding.prod_mk Embedding.prod_map\n-/\n\n",
 "prod_inr_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Eventually.prod_inr_nhds /-\ntheorem Filter.Eventually.prod_inr_nhds {p : β → Prop} {b : β}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) b)\n        (p x))\n    (a : α) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((nhds) (a, b)) (p (x : α × β).2) :=\n  continuousAt_snd h\n#align filter.eventually.prod_inr_nhds Filter.Eventually.prod_inr_nhds\n-/\n\n",
 "prod_inl_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Eventually.prod_inl_nhds /-\ntheorem Filter.Eventually.prod_inl_nhds {p : α → Prop} {a : α}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p x))\n    (b : β) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((nhds) (a, b)) (p (x : α × β).1) :=\n  continuousAt_fst h\n#align filter.eventually.prod_inl_nhds Filter.Eventually.prod_inl_nhds\n-/\n\n",
 "prod_induced_induced":
 "#print prod_induced_induced /-\n/-- A product of induced topologies is induced by the product map -/\ntheorem prod_induced_induced {α γ : Type _} (f : α → β) (g : γ → δ) :\n    @prod.topological_space α γ (induced f ‹_›) (induced g ‹_›) =\n      induced (fun p => (f p.1, g p.2)) prod.topological_space :=\n  by simp_rw [prod.topological_space, induced_inf, induced_compose]\n#align prod_induced_induced prod_induced_induced\n-/\n\n",
 "prod_generateFrom_generateFrom_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print prod_generateFrom_generateFrom_eq /-\ntheorem prod_generateFrom_generateFrom_eq {α β : Type _} {s : Set (Set α)} {t : Set (Set β)} (hs : ⋃₀ s = univ)\n    (ht : ⋃₀ t = univ) :\n    @prod.topological_space α β (generateFrom s) (generateFrom t) =\n      generateFrom { g | ∃ u ∈ s, ∃ v ∈ t, g = finset.product u v } :=\n  let G := generateFrom { g | ∃ u ∈ s, ∃ v ∈ t, g = finset.product u v }\n  le_antisymm\n    (le_generateFrom fun g ⟨u, hu, v, hv, g_eq⟩ =>\n      g_eq.symm ▸\n        @IsOpen.prod _ _ (generateFrom s) (generateFrom t) _ _ (generate_open.basic _ hu) (generate_open.basic _ hv))\n    (le_inf\n      (coinduced_le_iff_le_induced.mp <|\n        le_generateFrom fun u hu =>\n          have :\n            «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                (finset.product u v) =\n              «expr ⁻¹' » Prod.fst u :=\n            by simp_rw [← prod_Union, ← sUnion_eq_bUnion, ht, prod_univ]\n          show G.is_open («expr ⁻¹' » Prod.fst u) by\n            rw [← this]\n            exact isOpen_unionᵢ fun v => isOpen_unionᵢ fun hv => generate_open.basic _ ⟨_, hu, _, hv, rfl⟩)\n      (coinduced_le_iff_le_induced.mp <|\n        le_generateFrom fun v hv =>\n          have :\n            «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                (finset.product u v) =\n              «expr ⁻¹' » Prod.snd v :=\n            by simp_rw [← Union_prod_const, ← sUnion_eq_bUnion, hs, univ_prod]\n          show G.is_open («expr ⁻¹' » Prod.snd v) by\n            rw [← this]\n            exact isOpen_unionᵢ fun u => isOpen_unionᵢ fun hu => generate_open.basic _ ⟨_, hu, _, hv, rfl⟩))\n#align prod_generate_from_generate_from_eq prod_generateFrom_generateFrom_eq\n-/\n\n",
 "prod_eq_generateFrom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print prod_eq_generateFrom /-\ntheorem prod_eq_generateFrom :\n    prod.topological_space =\n      generateFrom { g | ∃ (s : Set α)(t : Set β), IsOpen s ∧ IsOpen t ∧ g = finset.product s t } :=\n  le_antisymm (le_generateFrom fun g ⟨s, t, hs, ht, g_eq⟩ => g_eq.symm ▸ hs.prod ht)\n    (le_inf (ball_image_of_ball fun t ht => generate_open.basic _ ⟨t, univ, by simpa [Set.prod_eq] using ht⟩)\n      (ball_image_of_ball fun t ht => generate_open.basic _ ⟨univ, t, by simpa [Set.prod_eq] using ht⟩))\n#align prod_eq_generate_from prod_eq_generateFrom\n-/\n\n",
 "prod":
 "#print OpenEmbedding.prod /-\nprotected theorem OpenEmbedding.prod {f : α → β} {g : γ → δ} (hf : OpenEmbedding f) (hg : OpenEmbedding g) :\n    OpenEmbedding fun x : α × γ => (f x.1, g x.2) :=\n  openEmbedding_of_embedding_open (hf.1.prod_mk hg.1) (hf.is_open_map.prod hg.is_open_map)\n#align open_embedding.prod OpenEmbedding.prod\n-/\n\n",
 "preimage_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Quotient.preimage_mem_nhds /-\ntheorem Quotient.preimage_mem_nhds [TopologicalSpace α] [s : setoid α] {V : Set <| quotient s} {a : α}\n    (hs : V ∈ (nhds) (Quotient.mk' a)) : «expr ⁻¹' » Quotient.mk' V ∈ (nhds) a :=\n  preimage_nhds_coinduced hs\n#align quotient.preimage_mem_nhds Quotient.preimage_mem_nhds\n-/\n\n",
 "pi_generateFrom_eq_finite":
 "#print pi_generateFrom_eq_finite /-\ntheorem pi_generateFrom_eq_finite {π : ι → Type _} {g : ∀ a, Set (Set (π a))} [Finite ι] (hg : ∀ a, ⋃₀ g a = univ) :\n    (@Pi.topologicalSpace ι π fun a => generateFrom (g a)) =\n      generateFrom { t | ∃ s : ∀ a, Set (π a), (∀ a, s a ∈ g a) ∧ t = pi univ s } :=\n  by\n  cases nonempty_fintype ι\n  rw [pi_generateFrom_eq]\n  refine' le_antisymm (generate_from_anti _) (le_generateFrom _)\n  · rintro s ⟨t, ht, rfl⟩\n    exact ⟨t, Finset.univ, by simp [ht]⟩\n  · rintro s ⟨t, i, ht, rfl⟩\n    apply isOpen_iff_forall_mem_open.2 _\n    intro f hf\n    choose c hc using\n      show ∀ a, ∃ s, s ∈ g a ∧ f a ∈ s by\n        intro a\n        have : f a ∈ ⋃₀ g a := by\n          rw [hg]\n          apply mem_univ\n        simpa\n    refine' ⟨pi univ fun a => if a ∈ i then t a else (c : ∀ a, Set (π a)) a, _, _, _⟩\n    · simp [pi_if]\n    · refine' generate_open.basic _ ⟨_, fun a => _, rfl⟩\n      by_cases a ∈ i <;> simp_all [Set.pi]\n    · have : f ∈ pi { a | a ∉ i } c := by simp_all [Set.pi]\n      simpa [pi_if, hf]\n#align pi_generate_from_eq_finite pi_generateFrom_eq_finite\n-/\n\n",
 "pi_generateFrom_eq":
 "#print pi_generateFrom_eq /-\ntheorem pi_generateFrom_eq {π : ι → Type _} {g : ∀ a, Set (Set (π a))} :\n    (@Pi.topologicalSpace ι π fun a => generateFrom (g a)) =\n      generateFrom { t | ∃ (s : ∀ a, Set (π a))(i : Finset ι), (∀ a ∈ i, s a ∈ g a) ∧ t = pi (↑i) s } :=\n  by\n  let G := { t | ∃ (s : ∀ a, Set (π a))(i : Finset ι), (∀ a ∈ i, s a ∈ g a) ∧ t = pi (↑i) s }\n  rw [pi_eq_generateFrom]\n  refine' le_antisymm (generate_from_anti _) (le_generateFrom _)\n  exact fun s ⟨t, i, ht, Eq⟩ => ⟨t, i, fun a ha => generate_open.basic _ (ht a ha), Eq⟩\n  · rintro s ⟨t, i, hi, rfl⟩\n    rw [pi_def]\n    apply isOpen_binterᵢ (Finset.finite_toSet _)\n    intro a ha\n    show ((generate_from G).coinduced fun f : ∀ a, π a => f a).is_open (t a)\n    refine' le_generateFrom _ _ (hi a ha)\n    exact fun s hs => generate_open.basic _ ⟨update (fun a => univ) a s, {a}, by simp [hs]⟩\n#align pi_generate_from_eq pi_generateFrom_eq\n-/\n\n",
 "pi_eq_generateFrom":
 "#print pi_eq_generateFrom /-\ntheorem pi_eq_generateFrom :\n    Pi.topologicalSpace =\n      generateFrom { g | ∃ (s : ∀ a, Set (π a))(i : Finset ι), (∀ a ∈ i, IsOpen (s a)) ∧ g = pi (↑i) s } :=\n  le_antisymm (le_generateFrom fun g ⟨s, i, hi, Eq⟩ => Eq.symm ▸ isOpen_set_pi (Finset.finite_toSet _) hi)\n    (le_infᵢ fun a s ⟨t, ht, s_eq⟩ =>\n      generate_open.basic _ <| ⟨update (fun a => univ) a t, {a}, by simpa using ht, s_eq ▸ by ext f <;> simp [Set.pi]⟩)\n#align pi_eq_generate_from pi_eq_generateFrom\n-/\n\n",
 "openEmbedding_subtype_val":
 "#print IsOpen.openEmbedding_subtype_val /-\ntheorem IsOpen.openEmbedding_subtype_val {s : Set α} (hs : IsOpen s) : OpenEmbedding (coe : s → α) :=\n  { induced := rfl\n    inj := Subtype.coe_injective\n    open_range := (Subtype.range_coe : range coe = s).symm ▸ hs }\n#align is_open.open_embedding_subtype_coe IsOpen.openEmbedding_subtype_val\n-/\n\n",
 "openEmbedding_sigma_map":
 "#print openEmbedding_sigma_map /-\ntheorem openEmbedding_sigma_map {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} (h : injective f₁) :\n    OpenEmbedding (Sigma.map f₁ f₂) ↔ ∀ i, OpenEmbedding (f₂ i) := by\n  simp only [openEmbedding_iff_embedding_open, isOpenMap_sigma_map, embedding_sigma_map h, forall_and]\n#align open_embedding_sigma_map openEmbedding_sigma_map\n-/\n\n",
 "openEmbedding_sigmaMk":
 "#print openEmbedding_sigmaMk /-\ntheorem openEmbedding_sigmaMk {i : ι} : OpenEmbedding (@sigma.mk ι σ i) :=\n  openEmbedding_of_continuous_injective_open continuous_sigmaMk sigma_mk_injective isOpenMap_sigmaMk\n#align open_embedding_sigma_mk openEmbedding_sigmaMk\n-/\n\n",
 "openEmbedding_inr":
 "#print openEmbedding_inr /-\ntheorem openEmbedding_inr : OpenEmbedding (@inr α β) :=\n  openEmbedding_of_continuous_injective_open continuous_inr inr_injective isOpenMap_inr\n#align open_embedding_inr openEmbedding_inr\n-/\n\n",
 "openEmbedding_inl":
 "#print openEmbedding_inl /-\ntheorem openEmbedding_inl : OpenEmbedding (@inl α β) :=\n  openEmbedding_of_continuous_injective_open continuous_inl inl_injective isOpenMap_inl\n#align open_embedding_inl openEmbedding_inl\n-/\n\n",
 "of_subset":
 "#print DiscreteTopology.of_subset /-\n/-- Let `s, t ⊆ X` be two subsets of a topological space `X`.  If `t ⊆ s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  -/\ntheorem DiscreteTopology.of_subset {X : Type _} [TopologicalSpace X] {s t : Set X} (ds : DiscreteTopology s)\n    (ts : t ⊆ s) : DiscreteTopology t :=\n  (embedding_inclusion ts).discrete_topology\n#align discrete_topology.of_subset DiscreteTopology.of_subset\n-/\n\n",
 "of_codRestrict":
 "#print Inducing.of_codRestrict /-\ntheorem Inducing.of_codRestrict {f : α → β} {b : Set β} (hb : ∀ a, f a ∈ b) (h : Inducing (b.cod_restrict f hb)) :\n    Inducing f :=\n  inducing_subtype_val.comp h\n#align inducing.of_cod_restrict Inducing.of_codRestrict\n-/\n\n",
 "nhds_toMul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_toMul /-\ntheorem nhds_toMul (a : Additive α) : (nhds) (toMul a) = map toMul ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_to_mul nhds_toMul\n-/\n\n",
 "nhds_toDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_toDual /-\ntheorem nhds_toDual (a : α) : (nhds) (toDual a) = map toDual ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_to_dual nhds_toDual\n-/\n\n",
 "nhds_toAdd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_toAdd /-\ntheorem nhds_toAdd (a : Multiplicative α) : (nhds) (toAdd a) = map toAdd ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_to_add nhds_toAdd\n-/\n\n",
 "nhds_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_swap /-\ntheorem nhds_swap (a : α) (b : β) : (nhds) (a, b) = ((nhds) (b, a)).map Prod.swap := by\n  rw [nhds_prod_eq, Filter.prod_comm, nhds_prod_eq] <;> rfl\n#align nhds_swap nhds_swap\n-/\n\n",
 "nhds_subtype_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_subtype_eq_comap /-\ntheorem nhds_subtype_eq_comap {a : α} {h : p a} : (nhds) (⟨a, h⟩ : Subtype p) = comap coe ((nhds) a) :=\n  nhds_induced _ _\n#align nhds_subtype_eq_comap nhds_subtype_eq_comap\n-/\n\n",
 "nhds_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_subtype /-\ntheorem nhds_subtype (s : Set α) (a : { x // x ∈ s }) : (nhds) a = comap coe ((nhds) (a : α)) :=\n  nhds_induced coe a\n#align nhds_subtype nhds_subtype\n-/\n\n",
 "nhds_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_prod_eq /-\ntheorem nhds_prod_eq {a : α} {b : β} : (nhds) (a, b) = filter.prod ((nhds) a) ((nhds) b) := by\n  rw [Filter.prod, prod.topological_space, nhds_inf, nhds_induced, nhds_induced]\n#align nhds_prod_eq nhds_prod_eq\n-/\n\n",
 "nhds_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_pi /-\ntheorem nhds_pi {a : ∀ i, π i} : (nhds) a = pi fun i => (nhds) (a i) := by\n  simp only [nhds_infᵢ, nhds_induced, Filter.pi]\n#align nhds_pi nhds_pi\n-/\n\n",
 "nhds_ofMul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_ofMul /-\ntheorem nhds_ofMul (a : α) : (nhds) (ofMul a) = map ofMul ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_of_mul nhds_ofMul\n-/\n\n",
 "nhds_ofDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_ofDual /-\ntheorem nhds_ofDual (a : α) : (nhds) (ofDual a) = map ofDual ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_of_dual nhds_ofDual\n-/\n\n",
 "nhds_ofAdd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_ofAdd /-\ntheorem nhds_ofAdd (a : α) : (nhds) (ofAdd a) = map ofAdd ((nhds) a) :=\n  by\n  unfold nhds\n  rfl\n#align nhds_of_add nhds_ofAdd\n-/\n\n",
 "nhds_ne_subtype_neBot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print nhds_ne_subtype_neBot_iff /-\ntheorem nhds_ne_subtype_neBot_iff {S : Set α} {x : S} :\n    (nhds_within («expr ᶜ» {x}) x).ne_bot ↔\n      («expr ⊓ » (nhds_within («expr ᶜ» {x}) (x : α)) ((filter.principal) S)).ne_bot :=\n  by rw [ne_bot_iff, ne_bot_iff, not_iff_not, nhds_ne_subtype_eq_bot_iff]\n#align nhds_ne_subtype_ne_bot_iff nhds_ne_subtype_neBot_iff\n-/\n\n",
 "nhds_ne_subtype_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print nhds_ne_subtype_eq_bot_iff /-\ntheorem nhds_ne_subtype_eq_bot_iff {S : Set α} {x : S} :\n    nhds_within («expr ᶜ» {x}) x = «expr⊥» ↔\n      «expr ⊓ » (nhds_within («expr ᶜ» {x}) (x : α)) ((filter.principal) S) = «expr⊥» :=\n  by rw [← nhdsWithin_subtype_eq_bot_iff, preimage_compl, ← image_singleton, subtype.coe_injective.preimage_image]\n#align nhds_ne_subtype_eq_bot_iff nhds_ne_subtype_eq_bot_iff\n-/\n\n",
 "nhds_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Sigma.nhds_mk /-\ntheorem Sigma.nhds_mk (i : ι) (x : σ i) : (nhds) (⟨i, x⟩ : Sigma σ) = map (sigma.mk i) ((nhds) x) :=\n  (openEmbedding_sigmaMk.map_nhds_eq x).symm\n#align sigma.nhds_mk Sigma.nhds_mk\n-/\n\n",
 "nhds_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_inr /-\ntheorem nhds_inr (x : β) : (nhds) (inr x : Sum α β) = map inr ((nhds) x) :=\n  (openEmbedding_inr.map_nhds_eq _).symm\n#align nhds_inr nhds_inr\n-/\n\n",
 "nhds_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_inl /-\ntheorem nhds_inl (x : α) : (nhds) (inl x : Sum α β) = map inl ((nhds) x) :=\n  (openEmbedding_inl.map_nhds_eq _).symm\n#align nhds_inl nhds_inl\n-/\n\n",
 "nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Sigma.nhds_eq /-\ntheorem Sigma.nhds_eq (x : Sigma σ) : (nhds) x = map (sigma.mk x.1) ((nhds) x.2) :=\n  by\n  cases x\n  apply Sigma.nhds_mk\n#align sigma.nhds_eq Sigma.nhds_eq\n-/\n\n",
 "nhdsWithin_subtype_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print nhdsWithin_subtype_eq_bot_iff /-\ntheorem nhdsWithin_subtype_eq_bot_iff {s t : Set α} {x : s} :\n    nhds_within («expr ⁻¹' » (coe : s → α) t) x = «expr⊥» ↔\n      «expr ⊓ » (nhds_within t (x : α)) ((filter.principal) s) = «expr⊥» :=\n  by rw [inf_principal_eq_bot_iff_comap, nhdsWithin, nhdsWithin, comap_inf, comap_principal, nhds_induced]\n#align nhds_within_subtype_eq_bot_iff nhdsWithin_subtype_eq_bot_iff\n-/\n\n",
 "mk_left":
 "#print Continuous.Prod.mk_left /-\n@[continuity]\ntheorem Continuous.Prod.mk_left (b : β) : Continuous fun a : α => (a, b) :=\n  continuous_id'.prod_mk continuous_const\n#align continuous.prod.mk_left Continuous.Prod.mk_left\n-/\n\n",
 "mk":
 "#print Continuous.Prod.mk /-\n@[continuity]\ntheorem Continuous.Prod.mk (a : α) : Continuous fun b : β => (a, b) :=\n  continuous_const.prod_mk continuous_id'\n#align continuous.prod.mk Continuous.Prod.mk\n-/\n\n",
 "mem_nhds_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print mem_nhds_subtype /-\n/-\nThe 𝓝 filter and the subspace topology.\n-/\ntheorem mem_nhds_subtype (s : Set α) (a : { x // x ∈ s }) (t : Set { x // x ∈ s }) :\n    t ∈ (nhds) a ↔ ∃ u ∈ (nhds) (a : α), «expr ⁻¹' » coe u ⊆ t :=\n  mem_nhds_induced coe a t\n#align mem_nhds_subtype mem_nhds_subtype\n-/\n\n",
 "mem_nhds_prod_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print mem_nhds_prod_iff' /-\ntheorem mem_nhds_prod_iff' {a : α} {b : β} {s : Set (α × β)} :\n    s ∈ (nhds) (a, b) ↔ ∃ (u : Set α)(v : Set β), IsOpen u ∧ a ∈ u ∧ IsOpen v ∧ b ∈ v ∧ finset.product u v ⊆ s :=\n  by\n  rw [mem_nhds_prod_iff]\n  constructor\n  · rintro ⟨u, Hu, v, Hv, h⟩\n    rcases mem_nhds_iff.1 Hu with ⟨u', u'u, u'_open, Hu'⟩\n    rcases mem_nhds_iff.1 Hv with ⟨v', v'v, v'_open, Hv'⟩\n    exact ⟨u', v', u'_open, Hu', v'_open, Hv', (Set.prod_mono u'u v'v).trans h⟩\n  · rintro ⟨u, v, u_open, au, v_open, bv, huv⟩\n    exact ⟨u, u_open.mem_nhds au, v, v_open.mem_nhds bv, huv⟩\n#align mem_nhds_prod_iff' mem_nhds_prod_iff'\n-/\n\n",
 "mem_nhds_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print mem_nhds_prod_iff /-\ntheorem mem_nhds_prod_iff {a : α} {b : β} {s : Set (α × β)} :\n    s ∈ (nhds) (a, b) ↔ ∃ u ∈ (nhds) a, ∃ v ∈ (nhds) b, finset.product u v ⊆ s := by rw [nhds_prod_eq, mem_prod_iff]\n#align mem_nhds_prod_iff mem_nhds_prod_iff\n-/\n\n",
 "mem_nhds_of_pi_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_nhds_of_pi_mem_nhds /-\ntheorem mem_nhds_of_pi_mem_nhds {I : Set ι} {s : ∀ i, Set (π i)} (a : ∀ i, π i) (hs : I.pi s ∈ (nhds) a) {i : ι}\n    (hi : i ∈ I) : s i ∈ (nhds) (a i) := by\n  rw [nhds_pi] at hs\n  exact mem_of_pi_mem_pi hs hi\n#align mem_nhds_of_pi_mem_nhds mem_nhds_of_pi_mem_nhds\n-/\n\n",
 "mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_nhds_iff {a : CofiniteTopology α} {s : Set (CofiniteTopology α)} :\n    s ∈ (nhds) a ↔ a ∈ s ∧ («expr ᶜ» s).finite := by simp [nhds_eq]\n#align mem_nhds_iff mem_nhds_iffₓ\n\n",
 "map_snd_nhdsWithin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print map_snd_nhdsWithin /-\n/-- `prod.snd` maps neighborhood of `x : α × β` within the section `prod.fst ⁻¹' {x.1}`\nto `𝓝 x.2`. -/\ntheorem map_snd_nhdsWithin (x : α × β) : map Prod.snd (nhds_within («expr ⁻¹' » Prod.fst {x.1}) x) = (nhds) x.2 :=\n  by\n  refine' le_antisymm (continuous_at_snd.mono_left inf_le_left) fun s hs => _\n  rcases x with ⟨x, y⟩\n  rw [mem_map, nhdsWithin, mem_inf_principal, mem_nhds_prod_iff] at hs\n  rcases hs with ⟨u, hu, v, hv, H⟩\n  simp only [prod_subset_iff, mem_singleton_iff, mem_set_of_eq, mem_preimage] at H\n  exact mem_of_superset hv fun z hz => H _ (mem_of_mem_nhds hu) _ hz rfl\n#align map_snd_nhds_within map_snd_nhdsWithin\n-/\n\n",
 "map_snd_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print map_snd_nhds /-\n@[simp]\ntheorem map_snd_nhds (x : α × β) : map Prod.snd ((nhds) x) = (nhds) x.2 :=\n  le_antisymm continuousAt_snd <| (map_snd_nhdsWithin x).symm.trans_le (map_mono inf_le_left)\n#align map_snd_nhds map_snd_nhds\n-/\n\n",
 "map_nhds_subtype_coe_eq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print map_nhds_subtype_coe_eq_nhds /-\ntheorem map_nhds_subtype_coe_eq_nhds {a : α} (ha : p a) (h : { a | p a } ∈ (nhds) a) :\n    map (coe : Subtype p → α) ((nhds) ⟨a, ha⟩) = (nhds) a :=\n  map_nhds_induced_of_mem <| by simpa only [Subtype.coe_mk, Subtype.range_coe] using h\n#align map_nhds_subtype_coe_eq map_nhds_subtype_coe_eq_nhds\n-/\n\n",
 "map_mem_closure₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print map_mem_closure₂ /-\ntheorem map_mem_closure₂ {f : α → β → γ} {a : α} {b : β} {s : Set α} {t : Set β} {u : Set γ}\n    (hf : Continuous (uncurry f)) (ha : a ∈ closure s) (hb : b ∈ closure t) (h : ∀ a ∈ s, ∀ b ∈ t, f a b ∈ u) :\n    f a b ∈ closure u :=\n  have H₁ : (a, b) ∈ closure (finset.product s t) := by simpa only [closure_prod_eq] using mk_mem_prod ha hb\n  have H₂ : MapsTo (uncurry f) (finset.product s t) u := forall_prod_set.2 h\n  H₂.closure hf H₁\n#align map_mem_closure₂ map_mem_closure₂\n-/\n\n",
 "map_fst_nhdsWithin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print map_fst_nhdsWithin /-\n/-- `prod.fst` maps neighborhood of `x : α × β` within the section `prod.snd ⁻¹' {x.2}`\nto `𝓝 x.1`. -/\ntheorem map_fst_nhdsWithin (x : α × β) : map Prod.fst (nhds_within («expr ⁻¹' » Prod.snd {x.2}) x) = (nhds) x.1 :=\n  by\n  refine' le_antisymm (continuous_at_fst.mono_left inf_le_left) fun s hs => _\n  rcases x with ⟨x, y⟩\n  rw [mem_map, nhdsWithin, mem_inf_principal, mem_nhds_prod_iff] at hs\n  rcases hs with ⟨u, hu, v, hv, H⟩\n  simp only [prod_subset_iff, mem_singleton_iff, mem_set_of_eq, mem_preimage] at H\n  exact mem_of_superset hu fun z hz => H _ hz _ (mem_of_mem_nhds hv) rfl\n#align map_fst_nhds_within map_fst_nhdsWithin\n-/\n\n",
 "map_fst_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print map_fst_nhds /-\n@[simp]\ntheorem map_fst_nhds (x : α × β) : map Prod.fst ((nhds) x) = (nhds) x.1 :=\n  le_antisymm continuousAt_fst <| (map_fst_nhdsWithin x).symm.trans_le (map_mono inf_le_left)\n#align map_fst_nhds map_fst_nhds\n-/\n\n",
 "is_open_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_open_iff' {s : Set (CofiniteTopology α)} : IsOpen s ↔ s = ∅ ∨ («expr ᶜ» s).finite := by\n  simp only [is_open_iff, nonempty_iff_ne_empty, or_iff_not_imp_left]\n#align is_open_iff' is_open_iff'\n\n",
 "is_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_open_iff {s : Set (CofiniteTopology α)} : IsOpen s ↔ s.nonempty → («expr ᶜ» s).finite :=\n  iff.rfl\n#align is_open_iff is_open_iff\n\n",
 "is_closed_iff":
 "theorem is_closed_iff {s : Set (CofiniteTopology α)} : IsClosed s ↔ s = univ ∨ s.finite := by\n  simp [← isOpen_compl_iff, is_open_iff']\n#align is_closed_iff is_closed_iff\n\n",
 "isOpen_sum_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print isOpen_sum_iff /-\ntheorem isOpen_sum_iff {s : Set (Sum α β)} : IsOpen s ↔ IsOpen («expr ⁻¹' » inl s) ∧ IsOpen («expr ⁻¹' » inr s) :=\n  iff.rfl\n#align is_open_sum_iff isOpen_sum_iff\n-/\n\n",
 "isOpen_sigma_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print isOpen_sigma_iff /-\ntheorem isOpen_sigma_iff {s : Set (Sigma σ)} : IsOpen s ↔ ∀ i, IsOpen («expr ⁻¹' » (sigma.mk i) s) := by\n  simp only [isOpen_supᵢ_iff, isOpen_coinduced]\n#align is_open_sigma_iff isOpen_sigma_iff\n-/\n\n",
 "isOpen_sigma_fst_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print isOpen_sigma_fst_preimage /-\ntheorem isOpen_sigma_fst_preimage (s : Set ι) : IsOpen («expr ⁻¹' » Sigma.fst s : Set (Σa, σ a)) :=\n  by\n  rw [← bUnion_of_singleton s, preimage_Union₂]\n  simp only [← range_sigma_mk]\n  exact isOpen_bunionᵢ fun _ _ => isOpen_range_sigmaMk\n#align is_open_sigma_fst_preimage isOpen_sigma_fst_preimage\n-/\n\n",
 "isOpen_set_pi":
 "#print isOpen_set_pi /-\ntheorem isOpen_set_pi {i : Set ι} {s : ∀ a, Set (π a)} (hi : i.finite) (hs : ∀ a ∈ i, IsOpen (s a)) : IsOpen (pi i s) :=\n  by rw [pi_def] <;> exact isOpen_binterᵢ hi fun a ha => (hs _ ha).preimage (continuous_apply _)\n#align is_open_set_pi isOpen_set_pi\n-/\n\n",
 "isOpen_range_sigmaMk":
 "#print isOpen_range_sigmaMk /-\ntheorem isOpen_range_sigmaMk {i : ι} : IsOpen (Set.range (@sigma.mk ι σ i)) :=\n  isOpenMap_sigmaMk.is_open_range\n#align is_open_range_sigma_mk isOpen_range_sigmaMk\n-/\n\n",
 "isOpen_range_inr":
 "#print isOpen_range_inr /-\ntheorem isOpen_range_inr : IsOpen (range (inr : β → Sum α β)) :=\n  openEmbedding_inr.2\n#align is_open_range_inr isOpen_range_inr\n-/\n\n",
 "isOpen_range_inl":
 "#print isOpen_range_inl /-\ntheorem isOpen_range_inl : IsOpen (range (inl : α → Sum α β)) :=\n  openEmbedding_inl.2\n#align is_open_range_inl isOpen_range_inl\n-/\n\n",
 "isOpen_prod_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print isOpen_prod_iff' /-\n/-- A product set is open in a product space if and only if each factor is open, or one of them is\nempty -/\ntheorem isOpen_prod_iff' {s : Set α} {t : Set β} : IsOpen (finset.product s t) ↔ IsOpen s ∧ IsOpen t ∨ s = ∅ ∨ t = ∅ :=\n  by\n  cases' (finset.product s t).eq_empty_or_nonempty with h h\n  · simp [h, prod_eq_empty_iff.1 h]\n  · have st : s.nonempty ∧ t.nonempty := prod_nonempty_iff.1 h\n    constructor\n    · intro (H : IsOpen (finset.product s t))\n      refine' or.inl ⟨_, _⟩\n      show IsOpen s\n      · rw [← fst_image_prod s st.2]\n        exact isOpenMap_fst _ H\n      show IsOpen t\n      · rw [← snd_image_prod st.1 t]\n        exact isOpenMap_snd _ H\n    · intro H\n      simp only [st.1.ne_empty, st.2.ne_empty, not_false_iff, or_false_iff] at H\n      exact H.1.prod H.2\n#align is_open_prod_iff' isOpen_prod_iff'\n-/\n\n",
 "isOpen_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print isOpen_prod_iff /-\ntheorem isOpen_prod_iff {s : Set (α × β)} :\n    IsOpen s ↔\n      ∀ a b, (a, b) ∈ s → ∃ (u : Set α)(v : Set β), IsOpen u ∧ IsOpen v ∧ a ∈ u ∧ b ∈ v ∧ finset.product u v ⊆ s :=\n  by\n  rw [isOpen_iff_nhds]\n  simp_rw [le_principal_iff, Prod.forall, ((nhds_basis_opens _).prod_nhds (nhds_basis_opens _)).mem_iff, Prod.exists,\n    exists_prop]\n  simp only [and_assoc', and_left_comm]\n#align is_open_prod_iff isOpen_prod_iff\n-/\n\n",
 "isOpen_pi_iff'":
 "#print isOpen_pi_iff' /-\ntheorem isOpen_pi_iff' [Finite ι] {s : Set (∀ a, π a)} :\n    IsOpen s ↔ ∀ f, f ∈ s → ∃ u : ∀ a, Set (π a), (∀ a, IsOpen (u a) ∧ f a ∈ u a) ∧ Set.univ.pi u ⊆ s :=\n  by\n  cases nonempty_fintype ι\n  rw [isOpen_iff_nhds]\n  simp_rw [le_principal_iff, nhds_pi, Filter.mem_pi', mem_nhds_iff, exists_prop]\n  refine' ball_congr fun a h => ⟨_, _⟩\n  · rintro ⟨I, t, ⟨h1, h2⟩⟩\n    refine'\n      ⟨fun i => (h1 i).some,\n        ⟨fun i => (h1 i).some_spec.2, (Set.pi_mono fun i _ => (h1 i).some_spec.1).trans (subset.trans _ h2)⟩⟩\n    rw [← Set.pi_inter_compl (I : Set ι)]\n    exact inter_subset_left _ _\n  · exact fun ⟨u, ⟨h1, _⟩⟩ => ⟨Finset.univ, u, ⟨fun i => ⟨u i, ⟨rfl.subset, h1 i⟩⟩, by rwa [Finset.coe_univ]⟩⟩\n#align is_open_pi_iff' isOpen_pi_iff'\n-/\n\n",
 "isOpen_pi_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print isOpen_pi_iff /-\ntheorem isOpen_pi_iff {s : Set (∀ a, π a)} :\n    IsOpen s ↔\n      ∀ f,\n        f ∈ s → ∃ (I : Finset ι)(u : ∀ a, Set (π a)), (∀ a, a ∈ I → IsOpen (u a) ∧ f a ∈ u a) ∧ (I : Set ι).pi u ⊆ s :=\n  by\n  rw [isOpen_iff_nhds]\n  simp_rw [le_principal_iff, nhds_pi, Filter.mem_pi', mem_nhds_iff, exists_prop]\n  refine' ball_congr fun a h => ⟨_, _⟩\n  · rintro ⟨I, t, ⟨h1, h2⟩⟩\n    refine' ⟨I, fun a => «expr '' » (eval a) ((I : Set ι).pi fun a => (h1 a).some), fun i hi => _, _⟩\n    · simp_rw [Set.eval_image_pi (finset.mem_coe.mpr hi)\n          (pi_nonempty_iff.mpr fun i => ⟨_, fun _ => (h1 i).some_spec.2.2⟩)]\n      exact (h1 i).some_spec.2\n    · refine' subset.trans (Set.pi_mono fun i hi => (Set.eval_image_pi_subset hi).trans (h1 i).some_spec.1) h2\n  · rintro ⟨I, t, ⟨h1, h2⟩⟩\n    refine' ⟨I, fun a => ite (a ∈ I) (t a) Set.univ, fun i => _, _⟩\n    · by_cases hi : i ∈ I\n      · use t i\n        rw [if_pos hi]\n        exact ⟨subset.rfl, (h1 i) hi⟩\n      · use Set.univ\n        rw [if_neg hi]\n        exact ⟨subset.rfl, isOpen_univ, mem_univ _⟩\n    · rw [← Set.univ_pi_ite]\n      simp only [← ite_and, ← Finset.mem_coe, and_self_iff, Set.univ_pi_ite, h2]\n#align is_open_pi_iff isOpen_pi_iff\n-/\n\n",
 "isOpenMap_toMul":
 "#print isOpenMap_toMul /-\ntheorem isOpenMap_toMul : IsOpenMap (toMul : Additive α → α) :=\n  IsOpenMap.id\n#align is_open_map_to_mul isOpenMap_toMul\n-/\n\n",
 "isOpenMap_toDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isOpenMap_toDual /-\ntheorem isOpenMap_toDual : IsOpenMap (toDual : α → «expr ᵒᵈ» α) :=\n  IsOpenMap.id\n#align is_open_map_to_dual isOpenMap_toDual\n-/\n\n",
 "isOpenMap_toAdd":
 "#print isOpenMap_toAdd /-\ntheorem isOpenMap_toAdd : IsOpenMap (toAdd : Multiplicative α → α) :=\n  IsOpenMap.id\n#align is_open_map_to_add isOpenMap_toAdd\n-/\n\n",
 "isOpenMap_sum_elim":
 "#print isOpenMap_sum_elim /-\n@[simp]\ntheorem isOpenMap_sum_elim {f : α → γ} {g : β → γ} : IsOpenMap (Sum.elim f g) ↔ IsOpenMap f ∧ IsOpenMap g := by\n  simp only [isOpenMap_sum, elim_inl, elim_inr]\n#align is_open_map_sum_elim isOpenMap_sum_elim\n-/\n\n",
 "isOpenMap_sum":
 "#print isOpenMap_sum /-\ntheorem isOpenMap_sum {f : Sum α β → γ} : IsOpenMap f ↔ (IsOpenMap fun a => f (inl a)) ∧ IsOpenMap fun b => f (inr b) :=\n  by simp only [isOpenMap_iff_nhds_le, Sum.forall, nhds_inl, nhds_inr, Filter.map_map]\n#align is_open_map_sum isOpenMap_sum\n-/\n\n",
 "isOpenMap_subtype_val":
 "#print IsOpen.isOpenMap_subtype_val /-\ntheorem IsOpen.isOpenMap_subtype_val {s : Set α} (hs : IsOpen s) : IsOpenMap (coe : s → α) :=\n  hs.open_embedding_subtype_coe.is_open_map\n#align is_open.is_open_map_subtype_coe IsOpen.isOpenMap_subtype_val\n-/\n\n",
 "isOpenMap_snd":
 "#print isOpenMap_snd /-\n/-- The second projection in a product of topological spaces sends open sets to open sets. -/\ntheorem isOpenMap_snd : IsOpenMap (@Prod.snd α β) :=\n  isOpenMap_iff_nhds_le.2 fun x => (map_snd_nhds x).ge\n#align is_open_map_snd isOpenMap_snd\n-/\n\n",
 "isOpenMap_sigma_map":
 "#print isOpenMap_sigma_map /-\ntheorem isOpenMap_sigma_map {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} :\n    IsOpenMap (Sigma.map f₁ f₂) ↔ ∀ i, IsOpenMap (f₂ i) :=\n  isOpenMap_sigma.trans <| forall_congr' fun i => (@openEmbedding_sigmaMk _ _ _ (f₁ i)).is_open_map_iff.symm\n#align is_open_map_sigma_map isOpenMap_sigma_map\n-/\n\n",
 "isOpenMap_sigmaMk":
 "#print isOpenMap_sigmaMk /-\ntheorem isOpenMap_sigmaMk {i : ι} : IsOpenMap (@sigma.mk ι σ i) :=\n  by\n  intro s hs\n  rw [isOpen_sigma_iff]\n  intro j\n  rcases eq_or_ne j i with (rfl | hne)\n  · rwa [Set.preimage_image_eq _ sigma_mk_injective]\n  · rw [preimage_image_sigma_mk_of_ne hne]\n    exact isOpen_empty\n#align is_open_map_sigma_mk isOpenMap_sigmaMk\n-/\n\n",
 "isOpenMap_sigma":
 "#print isOpenMap_sigma /-\ntheorem isOpenMap_sigma {f : Sigma σ → α} : IsOpenMap f ↔ ∀ i, IsOpenMap fun a => f ⟨i, a⟩ := by\n  simp only [isOpenMap_iff_nhds_le, Sigma.forall, Sigma.nhds_eq, map_map]\n#align is_open_map_sigma isOpenMap_sigma\n-/\n\n",
 "isOpenMap_ofMul":
 "#print isOpenMap_ofMul /-\ntheorem isOpenMap_ofMul : IsOpenMap (ofMul : α → Additive α) :=\n  IsOpenMap.id\n#align is_open_map_of_mul isOpenMap_ofMul\n-/\n\n",
 "isOpenMap_ofDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isOpenMap_ofDual /-\ntheorem isOpenMap_ofDual : IsOpenMap (ofDual : «expr ᵒᵈ» α → α) :=\n  IsOpenMap.id\n#align is_open_map_of_dual isOpenMap_ofDual\n-/\n\n",
 "isOpenMap_ofAdd":
 "#print isOpenMap_ofAdd /-\ntheorem isOpenMap_ofAdd : IsOpenMap (ofAdd : α → Multiplicative α) :=\n  IsOpenMap.id\n#align is_open_map_of_add isOpenMap_ofAdd\n-/\n\n",
 "isOpenMap_inr":
 "#print isOpenMap_inr /-\ntheorem isOpenMap_inr : IsOpenMap (@inr α β) := fun u hu => by\n  simpa [isOpen_sum_iff, preimage_image_eq u Sum.inr_injective]\n#align is_open_map_inr isOpenMap_inr\n-/\n\n",
 "isOpenMap_inl":
 "#print isOpenMap_inl /-\ntheorem isOpenMap_inl : IsOpenMap (@inl α β) := fun u hu => by\n  simpa [isOpen_sum_iff, preimage_image_eq u Sum.inl_injective]\n#align is_open_map_inl isOpenMap_inl\n-/\n\n",
 "isOpenMap_fst":
 "#print isOpenMap_fst /-\n/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem isOpenMap_fst : IsOpenMap (@Prod.fst α β) :=\n  isOpenMap_iff_nhds_le.2 fun x => (map_fst_nhds x).ge\n#align is_open_map_fst isOpenMap_fst\n-/\n\n",
 "isClosed_sigma_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print isClosed_sigma_iff /-\ntheorem isClosed_sigma_iff {s : Set (Sigma σ)} : IsClosed s ↔ ∀ i, IsClosed («expr ⁻¹' » (sigma.mk i) s) := by\n  simp only [← isOpen_compl_iff, isOpen_sigma_iff, preimage_compl]\n#align is_closed_sigma_iff isClosed_sigma_iff\n-/\n\n",
 "isClosed_set_pi":
 "#print isClosed_set_pi /-\ntheorem isClosed_set_pi {i : Set ι} {s : ∀ a, Set (π a)} (hs : ∀ a ∈ i, IsClosed (s a)) : IsClosed (pi i s) := by\n  rw [pi_def] <;> exact isClosed_interᵢ fun a => isClosed_interᵢ fun ha => (hs _ ha).preimage (continuous_apply _)\n#align is_closed_set_pi isClosed_set_pi\n-/\n\n",
 "isClosed_range_sigmaMk":
 "#print isClosed_range_sigmaMk /-\ntheorem isClosed_range_sigmaMk {i : ι} : IsClosed (Set.range (@sigma.mk ι σ i)) :=\n  isClosedMap_sigmaMk.closed_range\n#align is_closed_range_sigma_mk isClosed_range_sigmaMk\n-/\n\n",
 "isClosed_range_inr":
 "#print isClosed_range_inr /-\ntheorem isClosed_range_inr : IsClosed (range (inr : β → Sum α β)) :=\n  by\n  rw [← isOpen_compl_iff, compl_range_inr]\n  exact isOpen_range_inl\n#align is_closed_range_inr isClosed_range_inr\n-/\n\n",
 "isClosed_range_inl":
 "#print isClosed_range_inl /-\ntheorem isClosed_range_inl : IsClosed (range (inl : α → Sum α β)) :=\n  by\n  rw [← isOpen_compl_iff, compl_range_inl]\n  exact isOpen_range_inr\n#align is_closed_range_inl isClosed_range_inl\n-/\n\n",
 "isClosedMap_toMul":
 "#print isClosedMap_toMul /-\ntheorem isClosedMap_toMul : IsClosedMap (toMul : Additive α → α) :=\n  IsClosedMap.id\n#align is_closed_map_to_mul isClosedMap_toMul\n-/\n\n",
 "isClosedMap_toDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isClosedMap_toDual /-\ntheorem isClosedMap_toDual : IsClosedMap (toDual : α → «expr ᵒᵈ» α) :=\n  IsClosedMap.id\n#align is_closed_map_to_dual isClosedMap_toDual\n-/\n\n",
 "isClosedMap_toAdd":
 "#print isClosedMap_toAdd /-\ntheorem isClosedMap_toAdd : IsClosedMap (toAdd : Multiplicative α → α) :=\n  IsClosedMap.id\n#align is_closed_map_to_add isClosedMap_toAdd\n-/\n\n",
 "isClosedMap_sigmaMk":
 "#print isClosedMap_sigmaMk /-\ntheorem isClosedMap_sigmaMk {i : ι} : IsClosedMap (@sigma.mk ι σ i) :=\n  by\n  intro s hs\n  rw [isClosed_sigma_iff]\n  intro j\n  rcases eq_or_ne j i with (rfl | hne)\n  · rwa [Set.preimage_image_eq _ sigma_mk_injective]\n  · rw [preimage_image_sigma_mk_of_ne hne]\n    exact isClosed_empty\n#align is_closed_map_sigma_mk isClosedMap_sigmaMk\n-/\n\n",
 "isClosedMap_ofMul":
 "#print isClosedMap_ofMul /-\ntheorem isClosedMap_ofMul : IsClosedMap (ofMul : α → Additive α) :=\n  IsClosedMap.id\n#align is_closed_map_of_mul isClosedMap_ofMul\n-/\n\n",
 "isClosedMap_ofDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print isClosedMap_ofDual /-\ntheorem isClosedMap_ofDual : IsClosedMap (ofDual : «expr ᵒᵈ» α → α) :=\n  IsClosedMap.id\n#align is_closed_map_of_dual isClosedMap_ofDual\n-/\n\n",
 "isClosedMap_ofAdd":
 "#print isClosedMap_ofAdd /-\ntheorem isClosedMap_ofAdd : IsClosedMap (ofAdd : α → Multiplicative α) :=\n  IsClosedMap.id\n#align is_closed_map_of_add isClosedMap_ofAdd\n-/\n\n",
 "interior_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print interior_prod_eq /-\ntheorem interior_prod_eq (s : Set α) (t : Set β) :\n    interior (finset.product s t) = finset.product (interior s) (interior t) :=\n  Set.ext fun ⟨a, b⟩ => by simp only [mem_interior_iff_mem_nhds, mem_prod, prod_mem_nhds_iff]\n#align interior_prod_eq interior_prod_eq\n-/\n\n",
 "interior_pi_set":
 "#print interior_pi_set /-\ntheorem interior_pi_set {I : Set ι} (hI : I.finite) {s : ∀ i, Set (π i)} :\n    interior (pi I s) = I.pi fun i => interior (s i) := by\n  ext a\n  simp only [Set.mem_pi, mem_interior_iff_mem_nhds, set_pi_mem_nhds_iff hI]\n#align interior_pi_set interior_pi_set\n-/\n\n",
 "inducing_subtype_val":
 "#print inducing_subtype_val /-\ntheorem inducing_subtype_val {b : Set β} : Inducing (coe : b → β) :=\n  ⟨rfl⟩\n#align inducing_coe inducing_subtype_val\n-/\n\n",
 "inducing_sigma_map":
 "#print inducing_sigma_map /-\ntheorem inducing_sigma_map {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} (h₁ : injective f₁) :\n    Inducing (Sigma.map f₁ f₂) ↔ ∀ i, Inducing (f₂ i) := by\n  simp only [inducing_iff_nhds, Sigma.forall, Sigma.nhds_mk, Sigma.map, ← map_sigma_mk_comap h₁,\n    map_inj sigma_mk_injective]\n#align inducing_sigma_map inducing_sigma_map\n-/\n\n",
 "inducing_infᵢ_to_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print inducing_infᵢ_to_pi /-\n/-- Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\nwhere `Π i, π i` is endowed with the usual product topology. -/\ntheorem inducing_infᵢ_to_pi {X : Type _} (f : ∀ i, X → π i) :\n    @Inducing X (∀ i, π i)\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (induced (f i) inferInstance))\n      _ fun x i => f i x :=\n  by\n  constructor\n  erw [induced_infᵢ]\n  congr 1\n  funext\n  erw [induced_compose]\n#align inducing_infi_to_pi inducing_infᵢ_to_pi\n-/\n\n",
 "fst''":
 "#print ContinuousAt.fst'' /-\n/-- Precomposing `f` with `prod.fst` is continuous at `x : α × β` -/\ntheorem ContinuousAt.fst'' {f : α → γ} {x : α × β} (hf : ContinuousAt f x.fst) :\n    ContinuousAt (fun x : α × β => f x.fst) x :=\n  hf.comp continuousAt_fst\n#align continuous_at.fst'' ContinuousAt.fst''\n-/\n\n",
 "fst'":
 "#print ContinuousAt.fst' /-\n/-- Precomposing `f` with `prod.fst` is continuous at `(x, y)` -/\ntheorem ContinuousAt.fst' {f : α → γ} {x : α} {y : β} (hf : ContinuousAt f x) :\n    ContinuousAt (fun x : α × β => f x.fst) (x, y) :=\n  ContinuousAt.comp hf continuousAt_fst\n#align continuous_at.fst' ContinuousAt.fst'\n-/\n\n",
 "fst":
 "#print ContinuousAt.fst /-\n/-- Postcomposing `f` with `prod.fst` is continuous at `x` -/\ntheorem ContinuousAt.fst {f : α → β × γ} {x : α} (hf : ContinuousAt f x) : ContinuousAt (fun a : α => (f a).1) x :=\n  continuousAt_fst.comp hf\n#align continuous_at.fst ContinuousAt.fst\n-/\n\n",
 "frontier_univ_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print frontier_univ_prod_eq /-\n@[simp]\ntheorem frontier_univ_prod_eq (s : Set β) :\n    frontier (finset.product (univ : Set α) s) = finset.product univ (frontier s) := by simp [frontier_prod_eq]\n#align frontier_univ_prod_eq frontier_univ_prod_eq\n-/\n\n",
 "frontier_prod_univ_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print frontier_prod_univ_eq /-\n@[simp]\ntheorem frontier_prod_univ_eq (s : Set α) :\n    frontier (finset.product s (univ : Set β)) = finset.product (frontier s) univ := by simp [frontier_prod_eq]\n#align frontier_prod_univ_eq frontier_prod_univ_eq\n-/\n\n",
 "frontier_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print frontier_prod_eq /-\ntheorem frontier_prod_eq (s : Set α) (t : Set β) :\n    frontier (finset.product s t) = finset.product (closure s) (frontier t) ∪ finset.product (frontier s) (closure t) :=\n  by simp only [frontier, closure_prod_eq, interior_prod_eq, prod_diff_prod]\n#align frontier_prod_eq frontier_prod_eq\n-/\n\n",
 "fin_insertNth":
 "#print Continuous.fin_insertNth /-\ntheorem Continuous.fin_insertNth {n} {π : Fin (n + 1) → Type _} [∀ i, TopologicalSpace (π i)] (i : Fin (n + 1))\n    {f : α → π i} (hf : Continuous f) {g : α → ∀ j : Fin n, π (i.succ_above j)} (hg : Continuous g) :\n    Continuous fun a => i.insert_nth (f a) (g a) :=\n  continuous_iff_continuousAt.2 fun a => hf.continuous_at.fin_insert_nth i hg.continuous_at\n#align continuous.fin_insert_nth Continuous.fin_insertNth\n-/\n\n",
 "exists_nhds_square":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print exists_nhds_square /-\n/-- Given a neighborhood `s` of `(x, x)`, then `(x, x)` has a square open neighborhood\n  that is a subset of `s`. -/\ntheorem exists_nhds_square {s : Set (α × α)} {x : α} (hx : s ∈ (nhds) (x, x)) :\n    ∃ U : Set α, IsOpen U ∧ x ∈ U ∧ finset.product U U ⊆ s := by\n  simpa [nhds_prod_eq, (nhds_basis_opens x).prod_self.mem_iff, and_assoc, and_left_comm] using hx\n#align exists_nhds_square exists_nhds_square\n-/\n\n",
 "exists_finset_piecewise_mem_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_finset_piecewise_mem_of_mem_nhds /-\ntheorem exists_finset_piecewise_mem_of_mem_nhds [DecidableEq ι] {s : Set (∀ a, π a)} {x : ∀ a, π a} (hs : s ∈ (nhds) x)\n    (y : ∀ a, π a) : ∃ I : Finset ι, I.piecewise x y ∈ s :=\n  by\n  simp only [nhds_pi, Filter.mem_pi'] at hs\n  rcases hs with ⟨I, t, htx, hts⟩\n  refine' ⟨I, hts fun i hi => _⟩\n  simpa [Finset.mem_coe.1 hi] using mem_of_mem_nhds (htx i)\n#align exists_finset_piecewise_mem_of_mem_nhds exists_finset_piecewise_mem_of_mem_nhds\n-/\n\n",
 "embedding_uLift_down":
 "#print embedding_uLift_down /-\ntheorem embedding_uLift_down [TopologicalSpace α] : Embedding (ULift.down : ULift.{v, u} α → α) :=\n  ⟨⟨rfl⟩, ULift.down_injective⟩\n#align embedding_ulift_down embedding_uLift_down\n-/\n\n",
 "embedding_subtype_val":
 "#print embedding_subtype_val /-\ntheorem embedding_subtype_val : Embedding (coe : Subtype p → α) :=\n  ⟨⟨rfl⟩, Subtype.coe_injective⟩\n#align embedding_subtype_coe embedding_subtype_val\n-/\n\n",
 "embedding_sigma_map":
 "#print embedding_sigma_map /-\ntheorem embedding_sigma_map {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} (h : injective f₁) :\n    Embedding (Sigma.map f₁ f₂) ↔ ∀ i, Embedding (f₂ i) := by\n  simp only [embedding_iff, injective.sigma_map, inducing_sigma_map h, forall_and, h.sigma_map_iff]\n#align embedding_sigma_map embedding_sigma_map\n-/\n\n",
 "embedding_sigmaMk":
 "#print embedding_sigmaMk /-\ntheorem embedding_sigmaMk {i : ι} : Embedding (@sigma.mk ι σ i) :=\n  closedEmbedding_sigmaMk.1\n#align embedding_sigma_mk embedding_sigmaMk\n-/\n\n",
 "embedding_inr":
 "#print embedding_inr /-\ntheorem embedding_inr : Embedding (@inr α β) :=\n  openEmbedding_inr.1\n#align embedding_inr embedding_inr\n-/\n\n",
 "embedding_inl":
 "#print embedding_inl /-\ntheorem embedding_inl : Embedding (@inl α β) :=\n  openEmbedding_inl.1\n#align embedding_inl embedding_inl\n-/\n\n",
 "embedding_inclusion":
 "#print embedding_inclusion /-\ntheorem embedding_inclusion {s t : Set α} (h : s ⊆ t) : Embedding (Set.inclusion h) :=\n  embedding_subtype_val.cod_restrict _ _\n#align embedding_inclusion embedding_inclusion\n-/\n\n",
 "embedding_graph":
 "#print embedding_graph /-\ntheorem embedding_graph {f : α → β} (hf : Continuous f) : Embedding fun x => (x, f x) :=\n  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id\n#align embedding_graph embedding_graph\n-/\n\n",
 "discreteTopology_subtype_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print discreteTopology_subtype_iff /-\ntheorem discreteTopology_subtype_iff {S : Set α} :\n    DiscreteTopology S ↔ ∀ x ∈ S, «expr ⊓ » (nhds_within.ne x) ((filter.principal) S) = «expr⊥» := by\n  simp_rw [discreteTopology_iff_nhds_ne, SetCoe.forall', nhds_ne_subtype_eq_bot_iff]\n#align discrete_topology_subtype_iff discreteTopology_subtype_iff\n-/\n\n",
 "dense_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Subtype.dense_iff /-\ntheorem Subtype.dense_iff {s : Set α} {t : Set s} : Dense t ↔ s ⊆ closure («expr '' » coe t) :=\n  by\n  rw [inducing_coe.dense_iff, SetCoe.forall]\n  rfl\n#align subtype.dense_iff Subtype.dense_iff\n-/\n\n",
 "curry_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Eventually.curry_nhds /-\ntheorem Filter.Eventually.curry_nhds {p : α × β → Prop} {x : α} {y : β}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        ((nhds) (x, y)) (p x)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) x)\n      («expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        ((nhds) y) (p (x', y'))) :=\n  by\n  rw [nhds_prod_eq] at h\n  exact h.curry\n#align filter.eventually.curry_nhds Filter.Eventually.curry_nhds\n-/\n\n",
 "continuous_update":
 "#print continuous_update /-\n/-- `function.update f i x` is continuous in `(f, x)`. -/\n@[continuity]\ntheorem continuous_update [DecidableEq ι] (i : ι) : Continuous fun f : (∀ j, π j) × π i => update f.1 i f.2 :=\n  continuous_fst.update i continuous_snd\n#align continuous_update continuous_update\n-/\n\n",
 "continuous_uncurry_right":
 "#print continuous_uncurry_right /-\ntheorem continuous_uncurry_right {f : α → β → γ} (b : β) (h : Continuous (uncurry f)) : Continuous fun a => f a b :=\n  show Continuous (uncurry f ∘ fun a => (a, b)) from h.comp (by continuity)\n#align continuous_uncurry_right continuous_uncurry_right\n-/\n\n",
 "continuous_uncurry_of_discreteTopology_left":
 "#print continuous_uncurry_of_discreteTopology_left /-\ntheorem continuous_uncurry_of_discreteTopology_left [DiscreteTopology α] {f : α → β → γ} (h : ∀ a, Continuous (f a)) :\n    Continuous (uncurry f) :=\n  continuous_iff_continuousAt.2 fun ⟨a, b⟩ => by\n    simp only [ContinuousAt, nhds_prod_eq, nhds_discrete α, pure_prod, tendsto_map'_iff, (· ∘ ·), uncurry,\n      (h a).tendsto]\n#align continuous_uncurry_of_discrete_topology_left continuous_uncurry_of_discreteTopology_left\n-/\n\n",
 "continuous_uncurry_of_discreteTopology":
 "#print continuous_uncurry_of_discreteTopology /-\n/-- If a function `f x y` is such that `y ↦ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem continuous_uncurry_of_discreteTopology [DiscreteTopology α] {f : α → β → γ} (hf : ∀ a, Continuous (f a)) :\n    Continuous (uncurry f) := by\n  apply continuous_iff_continuousAt.2\n  rintro ⟨a, x⟩\n  change map _ _ ≤ _\n  rw [nhds_prod_eq, nhds_discrete, Filter.map_pure_prod]\n  exact (hf a).continuous_at\n#align continuous_uncurry_of_discrete_topology continuous_uncurry_of_discreteTopology\n-/\n\n",
 "continuous_uncurry_left":
 "#print continuous_uncurry_left /-\ntheorem continuous_uncurry_left {f : α → β → γ} (a : α) (h : Continuous (uncurry f)) : Continuous (f a) :=\n  show Continuous (uncurry f ∘ fun b => (a, b)) from h.comp (by continuity)\n#align continuous_uncurry_left continuous_uncurry_left\n-/\n\n",
 "continuous_uLift_up":
 "#print continuous_uLift_up /-\n@[continuity]\ntheorem continuous_uLift_up [TopologicalSpace α] : Continuous (ULift.up : α → ULift.{v, u} α) :=\n  continuous_induced_rng.2 continuous_id\n#align continuous_ulift_up continuous_uLift_up\n-/\n\n",
 "continuous_uLift_down":
 "#print continuous_uLift_down /-\n@[continuity]\ntheorem continuous_uLift_down [TopologicalSpace α] : Continuous (ULift.down : ULift.{v, u} α → α) :=\n  continuous_induced_dom\n#align continuous_ulift_down continuous_uLift_down\n-/\n\n",
 "continuous_toMul":
 "#print continuous_toMul /-\ntheorem continuous_toMul : Continuous (toMul : Additive α → α) :=\n  continuous_id\n#align continuous_to_mul continuous_toMul\n-/\n\n",
 "continuous_toDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print continuous_toDual /-\ntheorem continuous_toDual : Continuous (toDual : α → «expr ᵒᵈ» α) :=\n  continuous_id\n#align continuous_to_dual continuous_toDual\n-/\n\n",
 "continuous_toAdd":
 "#print continuous_toAdd /-\ntheorem continuous_toAdd : Continuous (toAdd : Multiplicative α → α) :=\n  continuous_id\n#align continuous_to_add continuous_toAdd\n-/\n\n",
 "continuous_swap":
 "#print continuous_swap /-\ntheorem continuous_swap : Continuous (Prod.swap : α × β → β × α) :=\n  continuous_snd.prod_mk continuous_fst\n#align continuous_swap continuous_swap\n-/\n\n",
 "continuous_sum_map":
 "#print continuous_sum_map /-\n@[simp]\ntheorem continuous_sum_map {f : α → β} {g : γ → δ} : Continuous (Sum.map f g) ↔ Continuous f ∧ Continuous g :=\n  continuous_sum_elim.trans <| embedding_inl.continuous_iff.symm.and embedding_inr.continuous_iff.symm\n#align continuous_sum_map continuous_sum_map\n-/\n\n",
 "continuous_sum_elim":
 "#print continuous_sum_elim /-\ntheorem continuous_sum_elim {f : α → γ} {g : β → γ} : Continuous (Sum.elim f g) ↔ Continuous f ∧ Continuous g :=\n  continuous_sum_dom\n#align continuous_sum_elim continuous_sum_elim\n-/\n\n",
 "continuous_sum_dom":
 "#print continuous_sum_dom /-\ntheorem continuous_sum_dom {f : Sum α β → γ} : Continuous f ↔ Continuous (f ∘ Sum.inl) ∧ Continuous (f ∘ Sum.inr) := by\n  simp only [continuous_sup_dom, continuous_coinduced_dom]\n#align continuous_sum_dom continuous_sum_dom\n-/\n\n",
 "continuous_subtype_val":
 "/- warning: continuous_subtype_coe clashes with continuous_subtype_val -> continuous_subtype_val\nCase conversion may be inaccurate. Consider using '#align continuous_subtype_coe continuous_subtype_valₓ'. -/\n#print continuous_subtype_val /-\ntheorem continuous_subtype_val : Continuous (coe : Subtype p → α) :=\n  continuous_subtype_val\n#align continuous_subtype_coe continuous_subtype_val\n-/\n\n",
 "continuous_snd":
 "#print continuous_snd /-\n@[continuity]\ntheorem continuous_snd : Continuous (@Prod.snd α β) :=\n  continuous_inf_dom_right continuous_induced_dom\n#align continuous_snd continuous_snd\n-/\n\n",
 "continuous_sigma_map":
 "#print continuous_sigma_map /-\n@[simp]\ntheorem continuous_sigma_map {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} :\n    Continuous (Sigma.map f₁ f₂) ↔ ∀ i, Continuous (f₂ i) :=\n  continuous_sigma_iff.trans <| by simp only [Sigma.map, embedding_sigma_mk.continuous_iff]\n#align continuous_sigma_map continuous_sigma_map\n-/\n\n",
 "continuous_sigma_iff":
 "#print continuous_sigma_iff /-\n/-- A map out of a sum type is continuous iff its restriction to each summand is. -/\n@[simp]\ntheorem continuous_sigma_iff {f : Sigma σ → α} : Continuous f ↔ ∀ i, Continuous fun a => f ⟨i, a⟩ := by\n  simp only [continuous_supᵢ_dom, continuous_coinduced_dom]\n#align continuous_sigma_iff continuous_sigma_iff\n-/\n\n",
 "continuous_sigmaMk":
 "#print continuous_sigmaMk /-\n@[continuity]\ntheorem continuous_sigmaMk {i : ι} : Continuous (@sigma.mk ι σ i) :=\n  continuous_supᵢ_rng continuous_coinduced_rng\n#align continuous_sigma_mk continuous_sigmaMk\n-/\n\n",
 "continuous_sigma":
 "#print continuous_sigma /-\n/-- A map out of a sum type is continuous if its restriction to each summand is. -/\n@[continuity]\ntheorem continuous_sigma {f : Sigma σ → α} (hf : ∀ i, Continuous fun a => f ⟨i, a⟩) : Continuous f :=\n  continuous_sigma_iff.2 hf\n#align continuous_sigma continuous_sigma\n-/\n\n",
 "continuous_quotient_mk'":
 "#print continuous_quotient_mk' /-\ntheorem continuous_quotient_mk' : Continuous (@Quotient.mk' α s) :=\n  continuous_coinduced_rng\n#align continuous_quotient_mk continuous_quotient_mk'\n-/\n\n",
 "continuous_quot_mk":
 "#print continuous_quot_mk /-\n@[continuity]\ntheorem continuous_quot_mk : Continuous (@Quot.mk α r) :=\n  continuous_coinduced_rng\n#align continuous_quot_mk continuous_quot_mk\n-/\n\n",
 "continuous_quot_lift":
 "#print continuous_quot_lift /-\n@[continuity]\ntheorem continuous_quot_lift {f : α → β} (hr : ∀ a b, r a b → f a = f b) (h : Continuous f) :\n    Continuous (Quot.lift f hr : Quot r → β) :=\n  continuous_coinduced_dom.2 h\n#align continuous_quot_lift continuous_quot_lift\n-/\n\n",
 "continuous_prod_mk":
 "#print continuous_prod_mk /-\n@[simp]\ntheorem continuous_prod_mk {f : α → β} {g : α → γ} : (Continuous fun x => (f x, g x)) ↔ Continuous f ∧ Continuous g :=\n  ⟨fun h => ⟨h.fst, h.snd⟩, fun h => h.1.prod_mk h.2⟩\n#align continuous_prod_mk continuous_prod_mk\n-/\n\n",
 "continuous_pi_iff":
 "#print continuous_pi_iff /-\ntheorem continuous_pi_iff : Continuous f ↔ ∀ i, Continuous fun a => f a i := by\n  simp only [continuous_infᵢ_rng, continuous_induced_rng]\n#align continuous_pi_iff continuous_pi_iff\n-/\n\n",
 "continuous_pi":
 "#print continuous_pi /-\n@[continuity]\ntheorem continuous_pi (h : ∀ i, Continuous fun a => f a i) : Continuous f :=\n  continuous_pi_iff.2 h\n#align continuous_pi continuous_pi\n-/\n\n",
 "continuous_ofMul":
 "#print continuous_ofMul /-\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Patrick Massot\n-/\ntheorem continuous_ofMul : Continuous (ofMul : α → Additive α) :=\n  continuous_id\n#align continuous_of_mul continuous_ofMul\n-/\n\n",
 "continuous_ofDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print continuous_ofDual /-\ntheorem continuous_ofDual : Continuous (ofDual : «expr ᵒᵈ» α → α) :=\n  continuous_id\n#align continuous_of_dual continuous_ofDual\n-/\n\n",
 "continuous_ofAdd":
 "#print continuous_ofAdd /-\ntheorem continuous_ofAdd : Continuous (ofAdd : α → Multiplicative α) :=\n  continuous_id\n#align continuous_of_add continuous_ofAdd\n-/\n\n",
 "continuous_mulSingle":
 "#print continuous_mulSingle /-\n/-- `pi.mul_single i x` is continuous in `x`. -/\n@[continuity, to_additive \"`pi.single i x` is continuous in `x`.\"]\ntheorem continuous_mulSingle [∀ i, One (π i)] [DecidableEq ι] (i : ι) :\n    Continuous fun x => (Pi.mulSingle i x : ∀ i, π i) :=\n  continuous_const.update _ continuous_id\n#align continuous_mul_single continuous_mulSingle\n#align continuous_single continuous_single\n-/\n\n",
 "continuous_inr":
 "#print continuous_inr /-\n@[continuity]\ntheorem continuous_inr : Continuous (@inr α β) :=\n  continuous_sup_rng_right continuous_coinduced_rng\n#align continuous_inr continuous_inr\n-/\n\n",
 "continuous_inl":
 "#print continuous_inl /-\n@[continuity]\ntheorem continuous_inl : Continuous (@inl α β) :=\n  continuous_sup_rng_left continuous_coinduced_rng\n#align continuous_inl continuous_inl\n-/\n\n",
 "continuous_infₛ_dom₂":
 "#print continuous_infₛ_dom₂ /-\n/-- A version of `continuous_Inf_dom` for binary functions -/\ntheorem continuous_infₛ_dom₂ {α β γ} {f : α → β → γ} {tas : Set (TopologicalSpace α)} {tbs : Set (TopologicalSpace β)}\n    {ta : TopologicalSpace α} {tb : TopologicalSpace β} {tc : TopologicalSpace γ} (ha : ta ∈ tas) (hb : tb ∈ tbs)\n    (hf : Continuous fun p : α × β => f p.1 p.2) : by\n    haveI := Inf tas <;> haveI := Inf tbs <;> exact @Continuous _ _ _ tc fun p : α × β => f p.1 p.2 :=\n  by\n  let t : TopologicalSpace (α × β) := prod.topological_space\n  have ha := continuous_infₛ_dom ha continuous_id\n  have hb := continuous_infₛ_dom hb continuous_id\n  have h_continuous_id := @Continuous.prod_map _ _ _ _ ta tb (Inf tas) (Inf tbs) _ _ ha hb\n  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ hf h_continuous_id\n#align continuous_Inf_dom₂ continuous_infₛ_dom₂\n-/\n\n",
 "continuous_inf_dom_right₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print continuous_inf_dom_right₂ /-\n/-- A version of `continuous_inf_dom_right` for binary functions -/\ntheorem continuous_inf_dom_right₂ {α β γ} {f : α → β → γ} {ta1 ta2 : TopologicalSpace α} {tb1 tb2 : TopologicalSpace β}\n    {tc1 : TopologicalSpace γ} (h : by haveI := ta2 <;> haveI := tb2 <;> exact Continuous fun p : α × β => f p.1 p.2) :\n    by haveI := «expr ⊓ » ta1 ta2 <;> haveI := «expr ⊓ » tb1 tb2 <;> exact Continuous fun p : α × β => f p.1 p.2 :=\n  by\n  have ha := @continuous_inf_dom_right _ _ id ta1 ta2 ta2 (@continuous_id _ (id _))\n  have hb := @continuous_inf_dom_right _ _ id tb1 tb2 tb2 (@continuous_id _ (id _))\n  have h_continuous_id := @Continuous.prod_map _ _ _ _ ta2 tb2 («expr ⊓ » ta1 ta2) («expr ⊓ » tb1 tb2) _ _ ha hb\n  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id\n#align continuous_inf_dom_right₂ continuous_inf_dom_right₂\n-/\n\n",
 "continuous_inf_dom_left₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print continuous_inf_dom_left₂ /-\n/-- A version of `continuous_inf_dom_left` for binary functions -/\ntheorem continuous_inf_dom_left₂ {α β γ} {f : α → β → γ} {ta1 ta2 : TopologicalSpace α} {tb1 tb2 : TopologicalSpace β}\n    {tc1 : TopologicalSpace γ} (h : by haveI := ta1 <;> haveI := tb1 <;> exact Continuous fun p : α × β => f p.1 p.2) :\n    by haveI := «expr ⊓ » ta1 ta2 <;> haveI := «expr ⊓ » tb1 tb2 <;> exact Continuous fun p : α × β => f p.1 p.2 :=\n  by\n  have ha := @continuous_inf_dom_left _ _ id ta1 ta2 ta1 (@continuous_id _ (id _))\n  have hb := @continuous_inf_dom_left _ _ id tb1 tb2 tb1 (@continuous_id _ (id _))\n  have h_continuous_id := @Continuous.prod_map _ _ _ _ ta1 tb1 («expr ⊓ » ta1 ta2) («expr ⊓ » tb1 tb2) _ _ ha hb\n  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id\n#align continuous_inf_dom_left₂ continuous_inf_dom_left₂\n-/\n\n",
 "continuous_inclusion":
 "#print continuous_inclusion /-\ntheorem continuous_inclusion {s t : Set α} (h : s ⊆ t) : Continuous (inclusion h) :=\n  continuous_id.subtype_map h\n#align continuous_inclusion continuous_inclusion\n-/\n\n",
 "continuous_fst":
 "#print continuous_fst /-\n@[continuity]\ntheorem continuous_fst : Continuous (@Prod.fst α β) :=\n  continuous_inf_dom_left continuous_induced_dom\n#align continuous_fst continuous_fst\n-/\n\n",
 "continuous_curry":
 "#print continuous_curry /-\ntheorem continuous_curry {g : α × β → γ} (a : α) (h : Continuous g) : Continuous (curry g a) :=\n  show Continuous (g ∘ fun b => (a, b)) from h.comp (by continuity)\n#align continuous_curry continuous_curry\n-/\n\n",
 "continuous_apply_apply":
 "#print continuous_apply_apply /-\n@[continuity]\ntheorem continuous_apply_apply {ρ : κ → ι → Type _} [∀ j i, TopologicalSpace (ρ j i)] (j : κ) (i : ι) :\n    Continuous fun p : ∀ j, ∀ i, ρ j i => p j i :=\n  (continuous_apply i).comp (continuous_apply j)\n#align continuous_apply_apply continuous_apply_apply\n-/\n\n",
 "continuous_apply":
 "#print continuous_apply /-\n@[continuity]\ntheorem continuous_apply (i : ι) : Continuous fun p : ∀ i, π i => p i :=\n  continuous_infᵢ_dom continuous_induced_dom\n#align continuous_apply continuous_apply\n-/\n\n",
 "continuousAt_subtype_val":
 "#print continuousAt_subtype_val /-\ntheorem continuousAt_subtype_val {p : α → Prop} {a : Subtype p} : ContinuousAt (coe : Subtype p → α) a :=\n  continuous_iff_continuousAt.mp continuous_subtype_val _\n#align continuous_at_subtype_coe continuousAt_subtype_val\n-/\n\n",
 "continuousAt_snd":
 "#print continuousAt_snd /-\ntheorem continuousAt_snd {p : α × β} : ContinuousAt Prod.snd p :=\n  continuous_snd.continuous_at\n#align continuous_at_snd continuousAt_snd\n-/\n\n",
 "continuousAt_pi":
 "#print continuousAt_pi /-\ntheorem continuousAt_pi {f : α → ∀ i, π i} {x : α} : ContinuousAt f x ↔ ∀ i, ContinuousAt (fun y => f y i) x :=\n  tendsto_pi_nhds\n#align continuous_at_pi continuousAt_pi\n-/\n\n",
 "continuousAt_fst":
 "#print continuousAt_fst /-\ntheorem continuousAt_fst {p : α × β} : ContinuousAt Prod.fst p :=\n  continuous_fst.continuous_at\n#align continuous_at_fst continuousAt_fst\n-/\n\n",
 "continuousAt_codRestrict_iff":
 "#print continuousAt_codRestrict_iff /-\ntheorem continuousAt_codRestrict_iff {f : α → β} {t : Set β} (h1 : ∀ x, f x ∈ t) {x : α} :\n    ContinuousAt (codRestrict f t h1) x ↔ ContinuousAt f x := by\n  simp_rw [inducing_coe.continuous_at_iff, Function.comp, coe_cod_restrict_apply]\n#align continuous_at_cod_restrict_iff continuousAt_codRestrict_iff\n-/\n\n",
 "continuousAt_apply":
 "#print continuousAt_apply /-\ntheorem continuousAt_apply (i : ι) (x : ∀ i, π i) : ContinuousAt (fun p : ∀ i, π i => p i) x :=\n  (continuous_apply i).continuous_at\n#align continuous_at_apply continuousAt_apply\n-/\n\n",
 "comp₄":
 "#print Continuous.comp₄ /-\ntheorem Continuous.comp₄ {g : α × β × γ × ζ → ε} (hg : Continuous g) {e : δ → α} (he : Continuous e) {f : δ → β}\n    (hf : Continuous f) {k : δ → γ} (hk : Continuous k) {l : δ → ζ} (hl : Continuous l) :\n    Continuous fun x => g (e x, f x, k x, l x) :=\n  hg.comp₃ he hf <| hk.prod_mk hl\n#align continuous.comp₄ Continuous.comp₄\n-/\n\n",
 "comp₃":
 "#print Continuous.comp₃ /-\ntheorem Continuous.comp₃ {g : α × β × γ → ε} (hg : Continuous g) {e : δ → α} (he : Continuous e) {f : δ → β}\n    (hf : Continuous f) {k : δ → γ} (hk : Continuous k) : Continuous fun x => g (e x, f x, k x) :=\n  hg.comp₂ he <| hf.prod_mk hk\n#align continuous.comp₃ Continuous.comp₃\n-/\n\n",
 "comp₂":
 "#print Continuous.comp₂ /-\ntheorem Continuous.comp₂ {g : α × β → γ} (hg : Continuous g) {e : δ → α} (he : Continuous e) {f : δ → β}\n    (hf : Continuous f) : Continuous fun x => g (e x, f x) :=\n  hg.comp <| he.prod_mk hf\n#align continuous.comp₂ Continuous.comp₂\n-/\n\n",
 "comap_sigmaMk_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print comap_sigmaMk_nhds /-\ntheorem comap_sigmaMk_nhds (i : ι) (x : σ i) : comap (sigma.mk i) ((nhds) ⟨i, x⟩) = (nhds) x :=\n  (embedding_sigmaMk.to_inducing.nhds_eq_comap _).symm\n#align comap_sigma_mk_nhds comap_sigmaMk_nhds\n-/\n\n",
 "codRestrict":
 "#print Embedding.codRestrict /-\ntheorem Embedding.codRestrict {e : α → β} (he : Embedding e) (s : Set β) (hs : ∀ x, e x ∈ s) :\n    Embedding (codRestrict e s hs) :=\n  embedding_of_embedding_compose (he.continuous.cod_restrict hs) continuous_subtype_val he\n#align embedding.cod_restrict Embedding.codRestrict\n-/\n\n",
 "closure_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print closure_subtype /-\ntheorem closure_subtype {x : { a // p a }} {s : Set { a // p a }} :\n    x ∈ closure s ↔ (x : α) ∈ closure («expr '' » (coe : _ → α) s) :=\n  closure_induced\n#align closure_subtype closure_subtype\n-/\n\n",
 "closure_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print closure_prod_eq /-\ntheorem closure_prod_eq {s : Set α} {t : Set β} :\n    closure (finset.product s t) = finset.product (closure s) (closure t) :=\n  Set.ext fun ⟨a, b⟩ =>\n    by\n    have :\n      «expr ⊓ » (filter.prod ((nhds) a) ((nhds) b)) ((filter.principal) (finset.product s t)) =\n        filter.prod («expr ⊓ » ((nhds) a) ((filter.principal) s)) («expr ⊓ » ((nhds) b) ((filter.principal) t)) :=\n      by rw [← prod_inf_prod, prod_principal_principal]\n    simp [closure_eq_cluster_pts, ClusterPt, nhds_prod_eq, this] <;> exact prod_ne_bot\n#align closure_prod_eq closure_prod_eq\n-/\n\n",
 "closedEmbedding_subtype_val":
 "#print IsClosed.closedEmbedding_subtype_val /-\ntheorem IsClosed.closedEmbedding_subtype_val {s : Set α} (hs : IsClosed s) :\n    ClosedEmbedding (coe : { x // x ∈ s } → α) :=\n  { induced := rfl\n    inj := Subtype.coe_injective\n    closed_range := (Subtype.range_coe : range coe = s).symm ▸ hs }\n#align is_closed.closed_embedding_subtype_coe IsClosed.closedEmbedding_subtype_val\n-/\n\n",
 "closedEmbedding_sigmaMk":
 "#print closedEmbedding_sigmaMk /-\ntheorem closedEmbedding_sigmaMk {i : ι} : ClosedEmbedding (@sigma.mk ι σ i) :=\n  closedEmbedding_of_continuous_injective_closed continuous_sigmaMk sigma_mk_injective isClosedMap_sigmaMk\n#align closed_embedding_sigma_mk closedEmbedding_sigmaMk\n-/\n\n",
 "closedEmbedding_inr":
 "#print closedEmbedding_inr /-\ntheorem closedEmbedding_inr : ClosedEmbedding (inr : β → Sum α β) :=\n  ⟨embedding_inr, isClosed_range_inr⟩\n#align closed_embedding_inr closedEmbedding_inr\n-/\n\n",
 "closedEmbedding_inl":
 "#print closedEmbedding_inl /-\ntheorem closedEmbedding_inl : ClosedEmbedding (inl : α → Sum α β) :=\n  ⟨embedding_inl, isClosed_range_inl⟩\n#align closed_embedding_inl closedEmbedding_inl\n-/\n\n",
 "apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Tendsto.apply /-\ntheorem Filter.Tendsto.apply {l : Filter β} {f : β → ∀ i, π i} {x : ∀ i, π i} (h : Tendsto f l ((nhds) x)) (i : ι) :\n    Tendsto (fun a => f a i) l (nhds <| x i) :=\n  (continuousAt_apply i _).tendsto.comp h\n#align filter.tendsto.apply Filter.Tendsto.apply\n-/\n\n"}