{"splitting":
 "#print Perfect.splitting /-\n/-- Given a perfect nonempty set in a T2.5 space, we can find two disjoint perfect subsets\nThis is the main inductive step in the proof of the Cantor-Bendixson Theorem-/\ntheorem Perfect.splitting [T25Space α] (hC : Perfect C) (hnonempty : C.nonempty) :\n    ∃ C₀ C₁ : Set α, (Perfect C₀ ∧ C₀.nonempty ∧ C₀ ⊆ C) ∧ (Perfect C₁ ∧ C₁.nonempty ∧ C₁ ⊆ C) ∧ Disjoint C₀ C₁ :=\n  by\n  cases' hnonempty with y yC\n  obtain ⟨x, xC, hxy⟩ : ∃ x ∈ C, x ≠ y := by\n    have := hC.acc _ yC\n    rw [accPt_iff_nhds] at this\n    rcases this univ univ_mem with ⟨x, xC, hxy⟩\n    exact ⟨x, xC.2, hxy⟩\n  obtain ⟨U, xU, Uop, V, yV, Vop, hUV⟩ := exists_open_nhds_disjoint_closure hxy\n  use closure (U ∩ C), closure (V ∩ C)\n  constructor <;> rw [← and_assoc']\n  · refine' ⟨hC.closure_nhds_inter x xC xU Uop, _⟩\n    rw [hC.closed.closure_subset_iff]\n    exact inter_subset_right _ _\n  constructor\n  · refine' ⟨hC.closure_nhds_inter y yC yV Vop, _⟩\n    rw [hC.closed.closure_subset_iff]\n    exact inter_subset_right _ _\n  apply Disjoint.mono _ _ hUV <;> apply closure_mono <;> exact inter_subset_left _ _\n#align perfect.splitting Perfect.splitting\n-/\n\n",
 "small_diam_splitting":
 "#print Perfect.small_diam_splitting /-\n/-- A refinement of `perfect.splitting` for metric spaces, where we also control\nthe diameter of the new perfect sets. -/\ntheorem Perfect.small_diam_splitting (ε_pos : 0 < ε) :\n    ∃ C₀ C₁ : Set α,\n      (Perfect C₀ ∧ C₀.nonempty ∧ C₀ ⊆ C ∧ EMetric.diam C₀ ≤ ε) ∧\n        (Perfect C₁ ∧ C₁.nonempty ∧ C₁ ⊆ C ∧ EMetric.diam C₁ ≤ ε) ∧ Disjoint C₀ C₁ :=\n  by\n  rcases hC.splitting hnonempty with ⟨D₀, D₁, ⟨perf0, non0, sub0⟩, ⟨perf1, non1, sub1⟩, hdisj⟩\n  cases' non0 with x₀ hx₀\n  cases' non1 with x₁ hx₁\n  rcases perf0.small_diam_aux ε_pos hx₀ with ⟨perf0', non0', sub0', diam0⟩\n  rcases perf1.small_diam_aux ε_pos hx₁ with ⟨perf1', non1', sub1', diam1⟩\n  refine'\n    ⟨closure (EMetric.ball x₀ (ε / 2) ∩ D₀), closure (EMetric.ball x₁ (ε / 2) ∩ D₁),\n      ⟨perf0', non0', sub0'.trans sub0, diam0⟩, ⟨perf1', non1', sub1'.trans sub1, diam1⟩, _⟩\n  apply Disjoint.mono _ _ hdisj <;> assumption\n#align perfect.small_diam_splitting Perfect.small_diam_splitting\n-/\n\n",
 "small_diam_aux":
 "private theorem perfect.small_diam_aux (ε_pos : 0 < ε) {x : α} (xC : x ∈ C) :\n    let D := closure (EMetric.ball x (ε / 2) ∩ C)\n    Perfect D ∧ D.nonempty ∧ D ⊆ C ∧ EMetric.diam D ≤ ε :=\n  by\n  have : x ∈ EMetric.ball x (ε / 2) := by\n    apply EMetric.mem_ball_self\n    rw [ENNReal.div_pos_iff]\n    exact ⟨ne_of_gt ε_pos, by norm_num⟩\n  have := hC.closure_nhds_inter x xC this EMetric.isOpen_ball\n  refine' ⟨this.1, this.2, _, _⟩\n  · rw [IsClosed.closure_subset_iff hC.closed]\n    apply inter_subset_right\n  rw [EMetric.diam_closure]\n  apply le_trans (EMetric.diam_mono (inter_subset_left _ _))\n  convert EMetric.diam_ball\n  rw [mul_comm, ENNReal.div_mul_cancel] <;> norm_num\n#align perfect.small_diam_aux perfect.small_diam_aux\n\n",
 "preperfect_iff_perfect_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print preperfect_iff_perfect_closure /-\n/-- In a T1 space, being preperfect is equivalent to having perfect closure.-/\ntheorem preperfect_iff_perfect_closure [T1Space α] : Preperfect C ↔ Perfect (closure C) :=\n  by\n  constructor <;> intro h\n  · exact h.perfect_closure\n  intro x xC\n  have H : AccPt x ((filter.principal) (closure C)) := h.acc _ (subset_closure xC)\n  rw [accPt_iff_frequently] at *\n  have :\n    ∀ y,\n      y ≠ x ∧ y ∈ closure C →\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n          ((nhds) y) (z ≠ x ∧ z ∈ C) :=\n    by\n    rintro y ⟨hyx, yC⟩\n    simp only [← mem_compl_singleton_iff, @and_comm' _ (_ ∈ C), ← frequently_nhdsWithin_iff,\n      hyx.nhds_within_compl_singleton, ← mem_closure_iff_frequently]\n    exact yC\n  rw [← frequently_frequently_nhds]\n  exact H.mono this\n#align preperfect_iff_perfect_closure preperfect_iff_perfect_closure\n-/\n\n",
 "preperfect_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print preperfect_iff_nhds /-\ntheorem preperfect_iff_nhds : Preperfect C ↔ ∀ x ∈ C, ∀ U ∈ (nhds) x, ∃ y ∈ U ∩ C, y ≠ x := by\n  simp only [Preperfect, accPt_iff_nhds]\n#align preperfect_iff_nhds preperfect_iff_nhds\n-/\n\n",
 "perfect_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print Preperfect.perfect_closure /-\n/-- The closure of a preperfect set is perfect.\nFor a converse, see `preperfect_iff_perfect_closure`-/\ntheorem Preperfect.perfect_closure (hC : Preperfect C) : Perfect (closure C) :=\n  by\n  constructor; · exact isClosed_closure\n  intro x hx\n  by_cases h : x ∈ C <;> apply AccPt.mono _ (principal_mono.mpr subset_closure)\n  · exact hC _ h\n  have : «expr ᶜ» {x} ∩ C = C := by simp [h]\n  rw [AccPt, nhdsWithin, inf_assoc, inf_principal, this]\n  rw [closure_eq_cluster_pts] at hx\n  exact hx\n#align preperfect.perfect_closure Preperfect.perfect_closure\n-/\n\n",
 "open_inter":
 "#print Preperfect.open_inter /-\n/-- The intersection of a preperfect set and an open set is preperfect-/\ntheorem Preperfect.open_inter {U : Set α} (hC : Preperfect C) (hU : IsOpen U) : Preperfect (U ∩ C) :=\n  by\n  rintro x ⟨xU, xC⟩\n  apply (hC _ xC).nhds_inter\n  exact hU.mem_nhds xU\n#align preperfect.open_inter Preperfect.open_inter\n-/\n\n",
 "nhds_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print AccPt.nhds_inter /-\n/-\nCopyright (c) 2022 Felix Weilacher. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Felix Weilacher\n-/\n/-- If `x` is an accumulation point of a set `C` and `U` is a neighborhood of `x`,\nthen `x` is an accumulation point of `U ∩ C`. -/\ntheorem AccPt.nhds_inter {x : α} {U : Set α} (h_acc : AccPt x ((filter.principal) C)) (hU : U ∈ (nhds) x) :\n    AccPt x ((filter.principal) (U ∩ C)) :=\n  by\n  have : nhds_within.ne x ≤ (filter.principal) U :=\n    by\n    rw [le_principal_iff]\n    exact mem_nhdsWithin_of_mem_nhds hU\n  rw [AccPt, ← inf_principal, ← inf_assoc, inf_of_le_left this]\n  exact h_acc\n#align acc_pt.nhds_inter AccPt.nhds_inter\n-/\n\n",
 "exists_perfect_nonempty_of_isClosed_of_not_countable":
 "#print exists_perfect_nonempty_of_isClosed_of_not_countable /-\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset.-/\ntheorem exists_perfect_nonempty_of_isClosed_of_not_countable [SecondCountableTopology α] (hclosed : IsClosed C)\n    (hunc : ¬C.countable) : ∃ D : Set α, Perfect D ∧ D.nonempty ∧ D ⊆ C :=\n  by\n  rcases exists_countable_union_perfect_of_isClosed hclosed with ⟨V, D, Vct, Dperf, VD⟩\n  refine' ⟨D, ⟨Dperf, _⟩⟩\n  constructor\n  · rw [nonempty_iff_ne_empty]\n    by_contra\n    rw [h, union_empty] at VD\n    rw [VD] at hunc\n    contradiction\n  rw [VD]\n  exact subset_union_right _ _\n#align exists_perfect_nonempty_of_is_closed_of_not_countable exists_perfect_nonempty_of_isClosed_of_not_countable\n-/\n\n",
 "exists_nat_bool_injection_of_not_countable":
 "#print IsClosed.exists_nat_bool_injection_of_not_countable /-\n/-- Any closed uncountable subset of a Polish space admits a continuous injection\nfrom the Cantor space `ℕ → bool`.-/\ntheorem IsClosed.exists_nat_bool_injection_of_not_countable {α : Type _} [TopologicalSpace α] [PolishSpace α]\n    {C : Set α} (hC : IsClosed C) (hunc : ¬C.countable) :\n    ∃ f : (ℕ → Bool) → α, range f ⊆ C ∧ Continuous f ∧ function.injective f :=\n  by\n  letI := upgradePolishSpace α\n  obtain ⟨D, hD, Dnonempty, hDC⟩ := exists_perfect_nonempty_of_isClosed_of_not_countable hC hunc\n  obtain ⟨f, hfD, hf⟩ := hD.exists_nat_bool_injection Dnonempty\n  exact ⟨f, hfD.trans hDC, hf⟩\n#align is_closed.exists_nat_bool_injection_of_not_countable IsClosed.exists_nat_bool_injection_of_not_countable\n-/\n\n",
 "exists_nat_bool_injection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n#print Perfect.exists_nat_bool_injection /-\n/-- Any nonempty perfect set in a complete metric space admits a continuous injection\nfrom the cantor space, `ℕ → bool`. -/\ntheorem Perfect.exists_nat_bool_injection [CompleteSpace α] :\n    ∃ f : (ℕ → Bool) → α, range f ⊆ C ∧ Continuous f ∧ injective f :=\n  by\n  obtain ⟨u, -, upos', hu⟩ := exists_seq_strictAnti_tendsto' (zero_lt_one' (ennreal))\n  have upos := fun n => (upos' n).1\n  let P := Subtype fun E : Set α => Perfect E ∧ E.nonempty\n  choose C0 C1 h0 h1 hdisj using fun {C : Set α} (hC : Perfect C) (hnonempty : C.nonempty) {ε : ennreal} (hε : 0 < ε) =>\n    hC.small_diam_splitting hnonempty hε\n  let DP : List Bool → P := fun l => by\n    induction' l with a l ih; · exact ⟨C, ⟨hC, hnonempty⟩⟩\n    cases a\n    · use C0 ih.property.1 ih.property.2 (upos l.length.succ)\n      exact ⟨(h0 _ _ _).1, (h0 _ _ _).2.1⟩\n    use C1 ih.property.1 ih.property.2 (upos l.length.succ)\n    exact ⟨(h1 _ _ _).1, (h1 _ _ _).2.1⟩\n  let D : List Bool → Set α := fun l => (DP l).val\n  have hanti : closure_antitone D :=\n    by\n    refine' antitone.closure_antitone _ fun l => (DP l).property.1.closed\n    intro l a\n    cases a\n    · exact (h0 _ _ _).2.2.1\n    exact (h1 _ _ _).2.2.1\n  have hdiam : vanishing_diam D := by\n    intro x\n    apply tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds hu\n    · simp\n    rw [eventually_at_top]\n    refine' ⟨1, fun m (hm : 1 ≤ m) => _⟩\n    rw [Nat.one_le_iff_ne_zero] at hm\n    rcases nat.exists_eq_succ_of_ne_zero hm with ⟨n, rfl⟩\n    dsimp\n    cases x n\n    · convert(h0 _ _ _).2.2.2\n      rw [PiNat.res_length]\n    convert(h1 _ _ _).2.2.2\n    rw [PiNat.res_length]\n  have hdisj' : CantorScheme.Disjoint D :=\n    by\n    rintro l (a | a) (b | b) hab <;> try contradiction\n    · exact hdisj _ _ _\n    exact (hdisj _ _ _).symm\n  have hdom : ∀ {x : ℕ → Bool}, x ∈ ([anonymous] D).1 := fun x => by\n    simp [hanti.map_of_vanishing_diam hdiam fun l => (DP l).property.2]\n  refine' ⟨fun x => ([anonymous] D).2 ⟨x, hdom⟩, _, _, _⟩\n  · rintro y ⟨x, rfl⟩\n    exact map_mem ⟨_, hdom⟩ 0\n  · continuity\n    exact hdiam.map_continuous\n  intro x y hxy\n  simpa only [← Subtype.val_inj] using hdisj'.map_injective hxy\n#align perfect.exists_nat_bool_injection Perfect.exists_nat_bool_injection\n-/\n\n",
 "exists_countable_union_perfect_of_isClosed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print exists_countable_union_perfect_of_isClosed /-\n/-- The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\ncan be written as the union of a countable set and a perfect set.-/\ntheorem exists_countable_union_perfect_of_isClosed [SecondCountableTopology α] (hclosed : IsClosed C) :\n    ∃ V D : Set α, V.countable ∧ Perfect D ∧ C = V ∪ D :=\n  by\n  obtain ⟨b, bct, bnontrivial, bbasis⟩ := TopologicalSpace.exists_countable_basis α\n  let v := { U ∈ b | (U ∩ C).countable }\n  let V := «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" U\n  let D := C \\ V\n  have Vct : (V ∩ C).countable := by\n    simp only [Union_inter, mem_sep_iff]\n    apply countable.bUnion\n    · exact countable.mono (inter_subset_left _ _) bct\n    · exact inter_subset_right _ _\n  refine' ⟨V ∩ C, D, Vct, ⟨_, _⟩, _⟩\n  · refine' hclosed.sdiff (isOpen_bunionᵢ fun U => _)\n    exact fun ⟨Ub, _⟩ => is_topological_basis.is_open bbasis Ub\n  · rw [preperfect_iff_nhds]\n    intro x xD E xE\n    have : ¬(E ∩ D).countable := by\n      intro h\n      obtain ⟨U, hUb, xU, hU⟩ : ∃ U ∈ b, x ∈ U ∧ U ⊆ E := (is_topological_basis.mem_nhds_iff bbasis).mp xE\n      have hU_cnt : (U ∩ C).countable := by\n        apply @countable.mono _ _ (E ∩ D ∪ V ∩ C)\n        · rintro y ⟨yU, yC⟩\n          by_cases y ∈ V\n          · exact mem_union_right _ (mem_inter h yC)\n          · exact mem_union_left _ (mem_inter (hU yU) ⟨yC, h⟩)\n        exact countable.union h Vct\n      have : U ∈ v := ⟨hUb, hU_cnt⟩\n      apply xD.2\n      exact mem_bUnion this xU\n    by_contra h\n    push_neg  at h\n    exact absurd (countable.mono h (Set.countable_singleton _)) this\n  · rw [inter_comm, inter_union_diff]\n#align exists_countable_union_perfect_of_is_closed exists_countable_union_perfect_of_isClosed\n-/\n\n",
 "closure_nhds_inter":
 "#print Perfect.closure_nhds_inter /-\ntheorem Perfect.closure_nhds_inter {U : Set α} (hC : Perfect C) (x : α) (xC : x ∈ C) (xU : x ∈ U) (Uop : IsOpen U) :\n    Perfect (closure (U ∩ C)) ∧ (closure (U ∩ C)).nonempty :=\n  by\n  constructor\n  · apply Preperfect.perfect_closure\n    exact hC.acc.open_inter Uop\n  apply nonempty.closure\n  exact ⟨x, ⟨xU, xC⟩⟩\n#align perfect.closure_nhds_inter Perfect.closure_nhds_inter\n-/\n\n"}