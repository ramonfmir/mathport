{"splitting":
 "/-- Given a perfect nonempty set in a T2.5 space, we can find two disjoint perfect subsets\nThis is the main inductive step in the proof of the Cantor-Bendixson Theorem-/\ntheorem perfect.splitting [t2_5_space α] (hC : perfect C) (hnonempty : C.nonempty) :\n    ∃ C₀ C₁ : set α, (perfect C₀ ∧ C₀.nonempty ∧ C₀ ⊆ C) ∧ (perfect C₁ ∧ C₁.nonempty ∧ C₁ ⊆ C) ∧ Disjoint C₀ C₁ :=\n  by\n  cases' hnonempty with y yC\n  obtain ⟨x, xC, hxy⟩ : ∃ x ∈ C, x ≠ y := by\n    have := hC.acc _ yC\n    rw [acc_pt_iff_nhds] at this\n    rcases this univ univ_mem with ⟨x, xC, hxy⟩\n    exact ⟨x, xC.2, hxy⟩\n  obtain ⟨U, xU, Uop, V, yV, Vop, hUV⟩ := exists_open_nhds_disjoint_closure hxy\n  use closure (U ∩ C), closure (V ∩ C)\n  constructor <;> rw [← and_assoc']\n  · refine' ⟨hC.closure_nhds_inter x xC xU Uop, _⟩\n    rw [hC.closed.closure_subset_iff]\n    exact inter_subset_right _ _\n  constructor\n  · refine' ⟨hC.closure_nhds_inter y yC yV Vop, _⟩\n    rw [hC.closed.closure_subset_iff]\n    exact inter_subset_right _ _\n  apply Disjoint.mono _ _ hUV <;> apply closure_mono <;> exact inter_subset_left _ _\n#align perfect.splitting perfect.splitting\n\n",
 "preperfect_iff_perfect_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a T1 space, being preperfect is equivalent to having perfect closure.-/\ntheorem preperfect_iff_perfect_closure [t1_space α] : preperfect C ↔ perfect (closure C) :=\n  by\n  constructor <;> intro h\n  · exact h.perfect_closure\n  intro x xC\n  have H : acc_pt x ((filter.principal) (closure C)) := h.acc _ (subset_closure xC)\n  rw [acc_pt_iff_frequently] at *\n  have :\n    ∀ y,\n      y ≠ x ∧ y ∈ closure C →\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n          ((nhds) y) (z ≠ x ∧ z ∈ C) :=\n    by\n    rintro y ⟨hyx, yC⟩\n    simp only [← mem_compl_singleton_iff, @and_comm' _ (_ ∈ C), ← frequently_nhds_within_iff,\n      hyx.nhds_within_compl_singleton, ← mem_closure_iff_frequently]\n    exact yC\n  rw [← frequently_frequently_nhds]\n  exact H.mono this\n#align preperfect_iff_perfect_closure preperfect_iff_perfect_closure\n\n",
 "preperfect_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem preperfect_iff_nhds : preperfect C ↔ ∀ x ∈ C, ∀ U ∈ (nhds) x, ∃ y ∈ U ∩ C, y ≠ x := by\n  simp only [preperfect, acc_pt_iff_nhds]\n#align preperfect_iff_nhds preperfect_iff_nhds\n\n",
 "perfect_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- The closure of a preperfect set is perfect.\nFor a converse, see `preperfect_iff_perfect_closure`-/\ntheorem preperfect.perfect_closure (hC : preperfect C) : perfect (closure C) :=\n  by\n  constructor; · exact is_closed_closure\n  intro x hx\n  by_cases h : x ∈ C <;> apply acc_pt.mono _ (principal_mono.mpr subset_closure)\n  · exact hC _ h\n  have : «expr ᶜ» {x} ∩ C = C := by simp [h]\n  rw [acc_pt, nhds_within, inf_assoc, inf_principal, this]\n  rw [closure_eq_cluster_pts] at hx\n  exact hx\n#align preperfect.perfect_closure preperfect.perfect_closure\n\n",
 "open_inter":
 "/-- The intersection of a preperfect set and an open set is preperfect-/\ntheorem preperfect.open_inter {U : set α} (hC : preperfect C) (hU : is_open U) : preperfect (U ∩ C) :=\n  by\n  rintro x ⟨xU, xC⟩\n  apply (hC _ xC).nhds_inter\n  exact hU.mem_nhds xU\n#align preperfect.open_inter preperfect.open_inter\n\n",
 "nhds_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/-\nCopyright (c) 2022 Felix Weilacher. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Felix Weilacher\n-/\n/-- If `x` is an accumulation point of a set `C` and `U` is a neighborhood of `x`,\nthen `x` is an accumulation point of `U ∩ C`. -/\ntheorem acc_pt.nhds_inter {x : α} {U : set α} (h_acc : acc_pt x ((filter.principal) C)) (hU : U ∈ (nhds) x) :\n    acc_pt x ((filter.principal) (U ∩ C)) :=\n  by\n  have : nhds_within.ne x ≤ (filter.principal) U :=\n    by\n    rw [le_principal_iff]\n    exact mem_nhds_within_of_mem_nhds hU\n  rw [acc_pt, ← inf_principal, ← inf_assoc, inf_of_le_left this]\n  exact h_acc\n#align acc_pt.nhds_inter acc_pt.nhds_inter\n\n",
 "exists_perfect_nonempty_of_is_closed_of_not_countable":
 "/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset.-/\ntheorem exists_perfect_nonempty_of_is_closed_of_not_countable [second_countable_topology α] (hclosed : is_closed C)\n    (hunc : ¬C.countable) : ∃ D : set α, perfect D ∧ D.nonempty ∧ D ⊆ C :=\n  by\n  rcases exists_countable_union_perfect_of_is_closed hclosed with ⟨V, D, Vct, Dperf, VD⟩\n  refine' ⟨D, ⟨Dperf, _⟩⟩\n  constructor\n  · rw [nonempty_iff_ne_empty]\n    by_contra\n    rw [h, union_empty] at VD\n    rw [VD] at hunc\n    contradiction\n  rw [VD]\n  exact subset_union_right _ _\n#align exists_perfect_nonempty_of_is_closed_of_not_countable exists_perfect_nonempty_of_is_closed_of_not_countable\n\n",
 "exists_countable_union_perfect_of_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\ncan be written as the union of a countable set and a perfect set.-/\ntheorem exists_countable_union_perfect_of_is_closed [second_countable_topology α] (hclosed : is_closed C) :\n    ∃ V D : set α, V.countable ∧ perfect D ∧ C = V ∪ D :=\n  by\n  obtain ⟨b, bct, bnontrivial, bbasis⟩ := topological_space.exists_countable_basis α\n  let v := { U ∈ b | (U ∩ C).countable }\n  let V := «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" U\n  let D := C \\ V\n  have Vct : (V ∩ C).countable := by\n    simp only [Union_inter, mem_sep_iff]\n    apply countable.bUnion\n    · exact countable.mono (inter_subset_left _ _) bct\n    · exact inter_subset_right _ _\n  refine' ⟨V ∩ C, D, Vct, ⟨_, _⟩, _⟩\n  · refine' hclosed.sdiff (is_open_bUnion fun U => _)\n    exact fun ⟨Ub, _⟩ => is_topological_basis.is_open bbasis Ub\n  · rw [preperfect_iff_nhds]\n    intro x xD E xE\n    have : ¬(E ∩ D).countable := by\n      intro h\n      obtain ⟨U, hUb, xU, hU⟩ : ∃ U ∈ b, x ∈ U ∧ U ⊆ E := (is_topological_basis.mem_nhds_iff bbasis).mp xE\n      have hU_cnt : (U ∩ C).countable := by\n        apply @countable.mono _ _ (E ∩ D ∪ V ∩ C)\n        · rintro y ⟨yU, yC⟩\n          by_cases y ∈ V\n          · exact mem_union_right _ (mem_inter h yC)\n          · exact mem_union_left _ (mem_inter (hU yU) ⟨yC, h⟩)\n        exact countable.union h Vct\n      have : U ∈ v := ⟨hUb, hU_cnt⟩\n      apply xD.2\n      exact mem_bUnion this xU\n    by_contra h\n    push_neg  at h\n    exact absurd (countable.mono h (set.countable_singleton _)) this\n  · rw [inter_comm, inter_union_diff]\n#align exists_countable_union_perfect_of_is_closed exists_countable_union_perfect_of_is_closed\n\n",
 "closure_nhds_inter":
 "theorem perfect.closure_nhds_inter {U : set α} (hC : perfect C) (x : α) (xC : x ∈ C) (xU : x ∈ U) (Uop : is_open U) :\n    perfect (closure (U ∩ C)) ∧ (closure (U ∩ C)).nonempty :=\n  by\n  constructor\n  · apply preperfect.perfect_closure\n    exact hC.acc.open_inter Uop\n  apply nonempty.closure\n  exact ⟨x, ⟨xU, xC⟩⟩\n#align perfect.closure_nhds_inter perfect.closure_nhds_inter\n\n"}