{"specializes_iff_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes_iff_mem (h : is_generic_point x S) : «expr ⤳ » x y ↔ y ∈ S :=\n  is_generic_point_iff_specializes.1 h y\n#align specializes_iff_mem specializes_iff_mem\n\n",
 "specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes (h : is_generic_point x S) (h' : y ∈ S) : «expr ⤳ » x y :=\n  h.specializes_iff_mem.2 h'\n#align specializes specializes\n\n",
 "quasi_sober_of_open_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A space is quasi sober if it can be covered by open quasi sober subsets. -/\ntheorem quasi_sober_of_open_cover (S : set (set α)) (hS : ∀ s : S, is_open (s : set α)) [hS' : ∀ s : S, quasi_sober s]\n    (hS'' : ⋃₀ S = «expr⊤») : quasi_sober α := by\n  rw [quasi_sober_iff]\n  intro t h h'\n  obtain ⟨x, hx⟩ := h.1\n  obtain ⟨U, hU, hU'⟩ : x ∈ ⋃₀ S := by\n    rw [hS'']\n    trivial\n  haveI : quasi_sober U := hS' ⟨U, hU⟩\n  have H : is_preirreducible («expr ⁻¹' » coe t : set U) := h.2.preimage (hS ⟨U, hU⟩).open_embedding_subtype_coe\n  replace H : is_irreducible («expr ⁻¹' » coe t : set U) := ⟨⟨⟨x, hU'⟩, by simpa using hx⟩, H⟩\n  use H.generic_point\n  have := continuous_subtype_coe.closure_preimage_subset _ H.generic_point_spec.mem\n  rw [h'.closure_eq] at this\n  apply le_antisymm\n  · apply h'.closure_subset_iff.mpr\n    simpa using this\n  rw [← Set.image_singleton, ← closure_closure]\n  have := closure_mono (image_closure_subset_closure_image (@continuous_subtype_coe α _ U))\n  refine' Set.Subset.trans _ this\n  rw [H.generic_point_spec.def]\n  refine' (subset_closure_inter_of_is_preirreducible_of_is_open h.2 (hS ⟨U, hU⟩) ⟨x, hx, hU'⟩).trans (closure_mono _)\n  rw [← Subtype.image_preimage_coe]\n  exact Set.image_subset _ subset_closure\n#align quasi_sober_of_open_cover quasi_sober_of_open_cover\n\n",
 "quasi_sober":
 "theorem open_embedding.quasi_sober {f : α → β} (hf : open_embedding f) [quasi_sober β] : quasi_sober α :=\n  by\n  constructor\n  intro S hS hS'\n  have hS'' := hS.image f hf.continuous.continuous_on\n  obtain ⟨x, hx⟩ := quasi_sober.sober hS''.closure is_closed_closure\n  obtain ⟨T, hT, rfl⟩ := hf.to_inducing.is_closed_iff.mp hS'\n  rw [Set.image_preimage_eq_inter_range] at hx hS''\n  have hxT : x ∈ T := by\n    rw [← hT.closure_eq]\n    exact closure_mono (Set.inter_subset_left _ _) hx.mem\n  have hxU : x ∈ Set.range f := by\n    rw [hx.mem_open_set_iff hf.open_range]\n    refine' Set.Nonempty.mono _ hS''.1\n    simpa using subset_closure\n  rcases hxU with ⟨y, rfl⟩\n  use y\n  change _ = _\n  rw [hf.to_embedding.closure_eq_preimage_closure_image, Set.image_singleton, show _ = _ from hx]\n  apply set.image_injective.mpr hf.inj\n  ext z\n  simp only [Set.image_preimage_eq_inter_range, Set.mem_inter_iff, and_congr_left_iff]\n  exact fun hy => ⟨fun h => hT.closure_eq ▸ closure_mono (Set.inter_subset_left _ _) h, fun h => subset_closure ⟨h, hy⟩⟩\n#align open_embedding.quasi_sober open_embedding.quasi_sober\n\n",
 "mem_open_set_iff":
 "theorem mem_open_set_iff (h : is_generic_point x S) (hU : is_open U) : x ∈ U ↔ (S ∩ U).nonempty :=\n  ⟨fun h' => ⟨x, h.mem, h'⟩, fun ⟨y, hyS, hyU⟩ => (h.specializes hyS).mem_open hU hyU⟩\n#align mem_open_set_iff mem_open_set_iff\n\n",
 "mem_closed_set_iff":
 "theorem mem_closed_set_iff (h : is_generic_point x S) (hZ : is_closed Z) : x ∈ Z ↔ S ⊆ Z := by\n  rw [← h.def, hZ.closure_subset_iff, singleton_subset_iff]\n#align mem_closed_set_iff mem_closed_set_iff\n\n",
 "mem":
 "theorem mem (h : is_generic_point x S) : x ∈ S :=\n  h.specializes_iff_mem.1 specializes_rfl\n#align mem mem\n\n",
 "is_irreducible":
 "protected theorem is_irreducible (h : is_generic_point x S) : is_irreducible S :=\n  h.def ▸ is_irreducible_singleton.closure\n#align is_irreducible is_irreducible\n\n",
 "is_generic_point_iff_specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem is_generic_point_iff_specializes : is_generic_point x S ↔ ∀ y, «expr ⤳ » x y ↔ y ∈ S := by\n  simp only [specializes_iff_mem_closure, is_generic_point, Set.ext_iff]\n#align is_generic_point_iff_specializes is_generic_point_iff_specializes\n\n",
 "is_generic_point_iff_forall_closed":
 "theorem is_generic_point_iff_forall_closed (hS : is_closed S) (hxS : x ∈ S) :\n    is_generic_point x S ↔ ∀ Z : set α, is_closed Z → x ∈ Z → S ⊆ Z :=\n  by\n  have : closure {x} ⊆ S := closure_minimal (singleton_subset_iff.2 hxS) hS\n  simp_rw [is_generic_point, subset_antisymm_iff, this, true_and_iff, closure, subset_sInter_iff, mem_set_of_eq,\n    and_imp, singleton_subset_iff]\n#align is_generic_point_iff_forall_closed is_generic_point_iff_forall_closed\n\n",
 "is_generic_point_def":
 "/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem is_generic_point_def {x : α} {S : set α} : is_generic_point x S ↔ closure ({x} : set α) = S :=\n  iff.rfl\n#align is_generic_point_def is_generic_point_def\n\n",
 "is_generic_point_closure":
 "theorem is_generic_point_closure {x : α} : is_generic_point x (closure ({x} : set α)) :=\n  refl _\n#align is_generic_point_closure is_generic_point_closure\n\n",
 "is_closed":
 "protected theorem is_closed (h : is_generic_point x S) : is_closed S :=\n  h.def ▸ is_closed_closure\n#align is_closed is_closed\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\nprotected theorem image (h : is_generic_point x S) {f : α → β} (hf : continuous f) :\n    is_generic_point (f x) (closure («expr '' » f S)) :=\n  by\n  rw [is_generic_point_def, ← h.def, ← image_singleton]\n  exact\n    subset.antisymm (closure_mono (image_subset _ subset_closure))\n      (closure_minimal (image_closure_subset_closure_image hf) is_closed_closure)\n#align image image\n\n",
 "generic_point_specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem generic_point_specializes [quasi_sober α] [irreducible_space α] (x : α) : «expr ⤳ » (generic_point α) x :=\n  (is_irreducible.generic_point_spec _).specializes (by simp)\n#align generic_point_specializes generic_point_specializes\n\n",
 "generic_point_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem generic_point_spec [quasi_sober α] [irreducible_space α] : is_generic_point (generic_point α) («expr⊤») := by\n  simpa using (irreducible_space.is_irreducible_univ α).generic_point_spec\n#align generic_point_spec generic_point_spec\n\n",
 "generic_point_closure_eq":
 "@[simp]\ntheorem is_irreducible.generic_point_closure_eq [quasi_sober α] {S : set α} (hS : is_irreducible S) :\n    closure ({hS.generic_point} : set α) = closure S :=\n  hS.generic_point_spec\n#align is_irreducible.generic_point_closure_eq is_irreducible.generic_point_closure_eq\n\n",
 "generic_point_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem generic_point_closure [quasi_sober α] [irreducible_space α] : closure ({generic_point α} : set α) = «expr⊤» :=\n  generic_point_spec α\n#align generic_point_closure generic_point_closure\n\n",
 "eq":
 "/-- In a T₀ space, each set has at most one generic point. -/\nprotected theorem eq [t0_space α] (h : is_generic_point x S) (h' : is_generic_point y S) : x = y :=\n  ((h.specializes h'.mem).antisymm (h'.specializes h.mem)).eq\n#align eq eq\n\n",
 "disjoint_iff":
 "#print disjoint_iff /-\ntheorem disjoint_iff (h : is_generic_point x S) (hU : is_open U) : Disjoint S U ↔ x ∉ U := by\n  rw [h.mem_open_set_iff hU, ← not_disjoint_iff_nonempty_inter, not_not]\n#align disjoint_iff disjoint_iff\n-/\n\n",
 "def":
 "theorem is_generic_point.def {x : α} {S : set α} (h : is_generic_point x S) : closure ({x} : set α) = S :=\n  h\n#align is_generic_point.def is_generic_point.def\n\n"}