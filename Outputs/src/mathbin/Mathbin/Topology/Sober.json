{"specializes_iff_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\ntheorem specializes_iff_mem (h : IsGenericPoint x S) : «expr ⤳ » x y ↔ y ∈ S :=\n  isGenericPoint_iff_specializes.1 h y\n#align specializes_iff_mem specializes_iff_mem\n\n",
 "quasiSober_of_open_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print quasiSober_of_open_cover /-\n/-- A space is quasi sober if it can be covered by open quasi sober subsets. -/\ntheorem quasiSober_of_open_cover (S : Set (Set α)) (hS : ∀ s : S, IsOpen (s : Set α)) [hS' : ∀ s : S, QuasiSober s]\n    (hS'' : ⋃₀ S = «expr⊤») : QuasiSober α := by\n  rw [quasi_sober_iff]\n  intro t h h'\n  obtain ⟨x, hx⟩ := h.1\n  obtain ⟨U, hU, hU'⟩ : x ∈ ⋃₀ S := by\n    rw [hS'']\n    trivial\n  haveI : QuasiSober U := hS' ⟨U, hU⟩\n  have H : IsPreirreducible («expr ⁻¹' » coe t : Set U) := h.2.preimage (hS ⟨U, hU⟩).open_embedding_subtype_coe\n  replace H : IsIrreducible («expr ⁻¹' » coe t : Set U) := ⟨⟨⟨x, hU'⟩, by simpa using hx⟩, H⟩\n  use H.generic_point\n  have := continuous_subtype_coe.closure_preimage_subset _ H.generic_point_spec.mem\n  rw [h'.closure_eq] at this\n  apply le_antisymm\n  · apply h'.closure_subset_iff.mpr\n    simpa using this\n  rw [← Set.image_singleton, ← closure_closure]\n  have := closure_mono (image_closure_subset_closure_image (@continuous_subtype_val α _ U))\n  refine' Set.Subset.trans _ this\n  rw [H.generic_point_spec.def]\n  refine' (subset_closure_inter_of_isPreirreducible_of_isOpen h.2 (hS ⟨U, hU⟩) ⟨x, hx, hU'⟩).trans (closure_mono _)\n  rw [← Subtype.image_preimage_coe]\n  exact Set.image_subset _ subset_closure\n#align quasi_sober_of_open_cover quasiSober_of_open_cover\n-/\n\n",
 "quasiSober":
 "#print OpenEmbedding.quasiSober /-\ntheorem OpenEmbedding.quasiSober {f : α → β} (hf : OpenEmbedding f) [QuasiSober β] : QuasiSober α :=\n  by\n  constructor\n  intro S hS hS'\n  have hS'' := hS.image f hf.continuous.continuous_on\n  obtain ⟨x, hx⟩ := quasi_sober.sober hS''.closure isClosed_closure\n  obtain ⟨T, hT, rfl⟩ := hf.to_inducing.is_closed_iff.mp hS'\n  rw [Set.image_preimage_eq_inter_range] at hx hS''\n  have hxT : x ∈ T := by\n    rw [← hT.closure_eq]\n    exact closure_mono (Set.inter_subset_left _ _) hx.mem\n  have hxU : x ∈ Set.range f := by\n    rw [hx.mem_open_set_iff hf.open_range]\n    refine' Set.Nonempty.mono _ hS''.1\n    simpa using subset_closure\n  rcases hxU with ⟨y, rfl⟩\n  use y\n  change _ = _\n  rw [hf.to_embedding.closure_eq_preimage_closure_image, Set.image_singleton, show _ = _ from hx]\n  apply set.image_injective.mpr hf.inj\n  ext z\n  simp only [Set.image_preimage_eq_inter_range, Set.mem_inter_iff, and_congr_left_iff]\n  exact fun hy => ⟨fun h => hT.closure_eq ▸ closure_mono (Set.inter_subset_left _ _) h, fun h => subset_closure ⟨h, hy⟩⟩\n#align open_embedding.quasi_sober OpenEmbedding.quasiSober\n-/\n\n",
 "mem_open_set_iff":
 "theorem mem_open_set_iff (h : IsGenericPoint x S) (hU : IsOpen U) : x ∈ U ↔ (S ∩ U).nonempty :=\n  ⟨fun h' => ⟨x, h.mem, h'⟩, fun ⟨y, hyS, hyU⟩ => (h.specializes hyS).mem_open hU hyU⟩\n#align mem_open_set_iff mem_open_set_iff\n\n",
 "mem_closed_set_iff":
 "theorem mem_closed_set_iff (h : IsGenericPoint x S) (hZ : IsClosed Z) : x ∈ Z ↔ S ⊆ Z := by\n  rw [← h.def, hZ.closure_subset_iff, singleton_subset_iff]\n#align mem_closed_set_iff mem_closed_set_iff\n\n",
 "mem":
 "theorem mem (h : IsGenericPoint x S) : x ∈ S :=\n  h.specializes_iff_mem.1 specializes_rfl\n#align mem mem\n\n",
 "isGenericPoint_iff_specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n#print isGenericPoint_iff_specializes /-\ntheorem isGenericPoint_iff_specializes : IsGenericPoint x S ↔ ∀ y, «expr ⤳ » x y ↔ y ∈ S := by\n  simp only [specializes_iff_mem_closure, IsGenericPoint, Set.ext_iff]\n#align is_generic_point_iff_specializes isGenericPoint_iff_specializes\n-/\n\n",
 "isGenericPoint_iff_forall_closed":
 "#print isGenericPoint_iff_forall_closed /-\ntheorem isGenericPoint_iff_forall_closed (hS : IsClosed S) (hxS : x ∈ S) :\n    IsGenericPoint x S ↔ ∀ Z : Set α, IsClosed Z → x ∈ Z → S ⊆ Z :=\n  by\n  have : closure {x} ⊆ S := closure_minimal (singleton_subset_iff.2 hxS) hS\n  simp_rw [IsGenericPoint, subset_antisymm_iff, this, true_and_iff, closure, subset_sInter_iff, mem_set_of_eq, and_imp,\n    singleton_subset_iff]\n#align is_generic_point_iff_forall_closed isGenericPoint_iff_forall_closed\n-/\n\n",
 "isGenericPoint_def":
 "#print isGenericPoint_def /-\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem isGenericPoint_def {x : α} {S : Set α} : IsGenericPoint x S ↔ closure ({x} : Set α) = S :=\n  iff.rfl\n#align is_generic_point_def isGenericPoint_def\n-/\n\n",
 "isGenericPoint_closure":
 "#print isGenericPoint_closure /-\ntheorem isGenericPoint_closure {x : α} : IsGenericPoint x (closure ({x} : Set α)) :=\n  refl _\n#align is_generic_point_closure isGenericPoint_closure\n-/\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\nprotected theorem image (h : IsGenericPoint x S) {f : α → β} (hf : Continuous f) :\n    IsGenericPoint (f x) (closure («expr '' » f S)) :=\n  by\n  rw [isGenericPoint_def, ← h.def, ← image_singleton]\n  exact\n    subset.antisymm (closure_mono (image_subset _ subset_closure))\n      (closure_minimal (image_closure_subset_closure_image hf) isClosed_closure)\n#align image image\n\n",
 "genericPoint_specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n#print genericPoint_specializes /-\ntheorem genericPoint_specializes [QuasiSober α] [IrreducibleSpace α] (x : α) : «expr ⤳ » (genericPoint α) x :=\n  (IsIrreducible.genericPoint_spec _).specializes (by simp)\n#align generic_point_specializes genericPoint_specializes\n-/\n\n",
 "genericPoint_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print genericPoint_spec /-\ntheorem genericPoint_spec [QuasiSober α] [IrreducibleSpace α] : IsGenericPoint (genericPoint α) («expr⊤») := by\n  simpa using (IrreducibleSpace.isIrreducible_univ α).generic_point_spec\n#align generic_point_spec genericPoint_spec\n-/\n\n",
 "genericPoint_closure_eq":
 "#print IsIrreducible.genericPoint_closure_eq /-\n@[simp]\ntheorem IsIrreducible.genericPoint_closure_eq [QuasiSober α] {S : Set α} (hS : IsIrreducible S) :\n    closure ({hS.generic_point} : Set α) = closure S :=\n  hS.generic_point_spec\n#align is_irreducible.generic_point_closure_eq IsIrreducible.genericPoint_closure_eq\n-/\n\n",
 "genericPoint_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print genericPoint_closure /-\n@[simp]\ntheorem genericPoint_closure [QuasiSober α] [IrreducibleSpace α] : closure ({genericPoint α} : Set α) = «expr⊤» :=\n  genericPoint_spec α\n#align generic_point_closure genericPoint_closure\n-/\n\n",
 "disjoint_iff":
 "#print disjoint_iff /-\ntheorem disjoint_iff (h : IsGenericPoint x S) (hU : IsOpen U) : Disjoint S U ↔ x ∉ U := by\n  rw [h.mem_open_set_iff hU, ← not_disjoint_iff_nonempty_inter, Classical.not_not]\n#align disjoint_iff disjoint_iff\n-/\n\n",
 "def":
 "#print IsGenericPoint.def /-\ntheorem IsGenericPoint.def {x : α} {S : Set α} (h : IsGenericPoint x S) : closure ({x} : Set α) = S :=\n  h\n#align is_generic_point.def IsGenericPoint.def\n-/\n\n",
 "Specializes":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⤳ » -/\n#print Specializes /-\ntheorem Specializes (h : IsGenericPoint x S) (h' : y ∈ S) : «expr ⤳ » x y :=\n  h.specializes_iff_mem.2 h'\n#align specializes Specializes\n-/\n\n",
 "IsIrreducible":
 "#print IsIrreducible /-\nprotected theorem IsIrreducible (h : IsGenericPoint x S) : IsIrreducible S :=\n  h.def ▸ isIrreducible_singleton.closure\n#align is_irreducible IsIrreducible\n-/\n\n",
 "IsClosed":
 "#print IsClosed /-\nprotected theorem IsClosed (h : IsGenericPoint x S) : IsClosed S :=\n  h.def ▸ isClosed_closure\n#align is_closed IsClosed\n-/\n\n",
 "Eq":
 "#print Eq /-\n/-- In a T₀ space, each set has at most one generic point. -/\nprotected theorem Eq [T0Space α] (h : IsGenericPoint x S) (h' : IsGenericPoint y S) : x = y :=\n  ((h.specializes h'.mem).antisymm (h'.specializes h.mem)).eq\n#align eq Eq\n-/\n\n"}