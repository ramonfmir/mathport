{"tietze_extension_step":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-\nCopyright (c) 2021 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov\n-/\n/-- One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\nof a topological space into a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous\nfunction, then there exists a bounded continuous function `g : Y →ᵇ ℝ` of the norm `‖g‖ ≤ ‖f‖ / 3`\nsuch that the distance between `g ∘ e` and `f` is at most `(2 / 3) * ‖f‖`. -/\ntheorem tietze_extension_step (f : bounded_continuous_function X (exprℝ)) (e : «exprC( , )» X Y)\n    (he : ClosedEmbedding e) :\n    ∃ g : bounded_continuous_function Y (exprℝ),\n      «expr‖ ‖» g ≤ «expr‖ ‖» f / 3 ∧ dist (g.comp_continuous e) f ≤ 2 / 3 * «expr‖ ‖» f :=\n  by\n  have h3 : (0 : exprℝ) < 3 := by norm_num1\n  have h23 : 0 < (2 / 3 : exprℝ) := by norm_num1\n  -- In the trivial case `f = 0`, we take `g = 0`\n  rcases eq_or_ne f 0 with (rfl | hf)\n  · use 0\n    simp\n  replace hf : 0 < «expr‖ ‖» f := norm_pos_iff.2 hf\n  /- Otherwise, the closed sets `e '' (f ⁻¹' (Iic (-‖f‖ / 3)))` and `e '' (f ⁻¹' (Ici (‖f‖ / 3)))`\n    are disjoint, hence by Urysohn's lemma there exists a function `g` that is equal to `-‖f‖ / 3`\n    on the former set and is equal to `‖f‖ / 3` on the latter set. This function `g` satisfies the\n    assertions of the lemma. -/\n  have hf3 : -«expr‖ ‖» f / 3 < «expr‖ ‖» f / 3 := (div_lt_div_right h3).2 (Left.neg_lt_self hf)\n  have hc₁ : IsClosed («expr '' » e («expr ⁻¹' » f (Iic (-«expr‖ ‖» f / 3)))) :=\n    he.is_closed_map _ (is_closed_Iic.preimage f.continuous)\n  have hc₂ : IsClosed («expr '' » e («expr ⁻¹' » f (Ici («expr‖ ‖» f / 3)))) :=\n    he.is_closed_map _ (is_closed_Ici.preimage f.continuous)\n  have hd :\n    Disjoint («expr '' » e («expr ⁻¹' » f (Iic (-«expr‖ ‖» f / 3))))\n      («expr '' » e («expr ⁻¹' » f (Ici («expr‖ ‖» f / 3)))) :=\n    by\n    refine' disjoint_image_of_injective he.inj (Disjoint.preimage _ _)\n    rwa [Iic_disjoint_Ici, not_le]\n  rcases exists_bounded_mem_Icc_of_closed_of_le hc₁ hc₂ hd hf3.le with ⟨g, hg₁, hg₂, hgf⟩\n  refine' ⟨g, _, _⟩\n  · refine' (norm_le <| div_nonneg hf.le h3.le).mpr fun y => _\n    simpa [abs_le, neg_div] using hgf y\n  · refine' (dist_le <| mul_nonneg h23.le hf.le).mpr fun x => _\n    have hfx : -«expr‖ ‖» f ≤ f x ∧ f x ≤ «expr‖ ‖» f := by\n      simpa only [Real.norm_eq_abs, abs_le] using f.norm_coe_le_norm x\n    cases' le_total (f x) (-«expr‖ ‖» f / 3) with hle₁ hle₁\n    ·\n      calc\n        |g (e x) - f x| = -«expr‖ ‖» f / 3 - f x := by\n          rw [hg₁ (mem_image_of_mem _ hle₁), abs_of_nonneg (sub_nonneg.2 hle₁)]\n        _ ≤ 2 / 3 * «expr‖ ‖» f := by linarith\n        \n    · cases' le_total (f x) («expr‖ ‖» f / 3) with hle₂ hle₂\n      · simp only [neg_div] at *\n        calc\n          dist (g (e x)) (f x) ≤ |g (e x)| + |f x| := dist_le_norm_add_norm _ _\n          _ ≤ «expr‖ ‖» f / 3 + «expr‖ ‖» f / 3 := (add_le_add (abs_le.2 <| hgf _) (abs_le.2 ⟨hle₁, hle₂⟩))\n          _ = 2 / 3 * «expr‖ ‖» f := by linarith\n          \n      ·\n        calc\n          |g (e x) - f x| = f x - «expr‖ ‖» f / 3 := by\n            rw [hg₂ (mem_image_of_mem _ hle₂), abs_sub_comm, abs_of_nonneg (sub_nonneg.2 hle₂)]\n          _ ≤ 2 / 3 * «expr‖ ‖» f := by linarith\n          \n#align tietze_extension_step tietze_extension_step\n\n",
 "exists_restrict_eq_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\non `s`. Then there exists a continuous real-valued function `g : C(Y, ℝ)` such that\n`g.restrict s = f`. -/\ntheorem exists_restrict_eq_of_closed {s : Set Y} (f : «exprC( , )» s (exprℝ)) (hs : IsClosed s) :\n    ∃ g : «exprC( , )» Y (exprℝ), g.restrict s = f :=\n  let ⟨g, hg, hgf⟩ := exists_restrict_eq_forall_mem_of_closed f (fun _ => mem_univ _) univ_nonempty hs\n  ⟨g, hgf⟩\n#align exists_restrict_eq_of_closed exists_restrict_eq_of_closed\n\n",
 "exists_restrict_eq_forall_mem_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\non `s`. Let `t` be a nonempty convex set of real numbers (we use `ord_connected` instead of `convex`\nto automatically deduce this argument by typeclass search) such that `f x ∈ t` for all `x : s`. Then\nthere exists a continuous real-valued function `g : C(Y, ℝ)` such that `g y ∈ t` for all `y` and\n`g.restrict s = f`. -/\ntheorem exists_restrict_eq_forall_mem_of_closed {s : Set Y} (f : «exprC( , )» s (exprℝ)) {t : Set (exprℝ)}\n    [OrdConnected t] (ht : ∀ x, f x ∈ t) (hne : t.nonempty) (hs : IsClosed s) :\n    ∃ g : «exprC( , )» Y (exprℝ), (∀ y, g y ∈ t) ∧ g.restrict s = f :=\n  let ⟨g, hgt, hgf⟩ := exists_extension_forall_mem_of_closed_embedding f ht hne (closedEmbedding_subtype_val hs)\n  ⟨g, hgt, coe_injective hgf⟩\n#align exists_restrict_eq_forall_mem_of_closed exists_restrict_eq_forall_mem_of_closed\n\n",
 "exists_norm_eq_restrict_eq_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nset. If `f` is a bounded continuous real-valued function defined on a closed set in a normal\ntopological space, then it can be extended to a bounded continuous function of the same norm defined\non the whole space. -/\ntheorem exists_norm_eq_restrict_eq_of_closed {s : Set Y} (f : bounded_continuous_function s (exprℝ)) (hs : IsClosed s) :\n    ∃ g : bounded_continuous_function Y (exprℝ), «expr‖ ‖» g = «expr‖ ‖» f ∧ g.restrict s = f :=\n  exists_extension_norm_eq_of_closed_embedding' f ((ContinuousMap.id _).restrict s) (closedEmbedding_subtype_val hs)\n#align exists_norm_eq_restrict_eq_of_closed exists_norm_eq_restrict_eq_of_closed\n\n",
 "exists_forall_mem_restrict_eq_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nset. Let `s` be a closed set in a normal topological space `Y`. Let `f` be a bounded continuous\nreal-valued function on `s`. Let `t` be a nonempty convex set of real numbers (we use\n`ord_connected` instead of `convex` to automatically deduce this argument by typeclass search) such\nthat `f x ∈ t` for all `x : s`. Then there exists a bounded continuous real-valued function\n`g : Y →ᵇ ℝ` such that `g y ∈ t` for all `y` and `g.restrict s = f`. -/\ntheorem exists_forall_mem_restrict_eq_of_closed {s : Set Y} (f : bounded_continuous_function s (exprℝ))\n    (hs : IsClosed s) {t : Set (exprℝ)} [OrdConnected t] (hf : ∀ x, f x ∈ t) (hne : t.nonempty) :\n    ∃ g : bounded_continuous_function Y (exprℝ), (∀ y, g y ∈ t) ∧ g.restrict s = f :=\n  by\n  rcases exists_extension_forall_mem_of_closed_embedding f hf hne (closedEmbedding_subtype_val hs) with ⟨g, hg, hgf⟩\n  exact ⟨g, hg, FunLike.coe_injective hgf⟩\n#align exists_forall_mem_restrict_eq_of_closed exists_forall_mem_restrict_eq_of_closed\n\n",
 "exists_extension_of_closed_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Then there exists a\ncontinuous real-valued function `g : C(Y, ℝ)` such that `g ∘ e = f`. -/\ntheorem exists_extension_of_closed_embedding (f : «exprC( , )» X (exprℝ)) (e : X → Y) (he : ClosedEmbedding e) :\n    ∃ g : «exprC( , )» Y (exprℝ), g ∘ e = f :=\n  (exists_extension_forall_mem_of_closed_embedding f (fun x => mem_univ _) univ_nonempty he).imp fun g => And.right\n#align exists_extension_of_closed_embedding exists_extension_of_closed_embedding\n\n",
 "exists_extension_norm_eq_of_closed_embedding'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\ninto a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous function, then there exists\na bounded continuous function `g : Y →ᵇ ℝ` of the same norm such that `g ∘ e = f`. -/\ntheorem exists_extension_norm_eq_of_closed_embedding' (f : bounded_continuous_function X (exprℝ)) (e : «exprC( , )» X Y)\n    (he : ClosedEmbedding e) :\n    ∃ g : bounded_continuous_function Y (exprℝ), «expr‖ ‖» g = «expr‖ ‖» f ∧ g.comp_continuous e = f :=\n  by\n  /- For the proof, we iterate `tietze_extension_step`. Each time we apply it to the difference\n    between the previous approximation and `f`. -/\n  choose F hF_norm hF_dist using fun f : bounded_continuous_function X (exprℝ) => tietze_extension_step f e he\n  set g : ℕ → bounded_continuous_function Y (exprℝ) := fun n =>\n    («expr ^[ ]» (fun g => g + F (f - g.comp_continuous e)) n) 0\n  have g0 : g 0 = 0 := rfl\n  have g_succ : ∀ n, g (n + 1) = g n + F (f - (g n).comp_continuous e) := fun n => Function.iterate_succ_apply' _ _ _\n  have hgf : ∀ n, dist ((g n).comp_continuous e) f ≤ (2 / 3) ^ n * «expr‖ ‖» f :=\n    by\n    intro n\n    induction' n with n ihn\n    · simp [g0]\n    · rw [g_succ n, add_comp_continuous, ← dist_sub_right, add_sub_cancel', pow_succ, mul_assoc]\n      refine' (hF_dist _).trans (mul_le_mul_of_nonneg_left _ (by norm_num1))\n      rwa [← dist_eq_norm']\n  have hg_dist : ∀ n, dist (g n) (g (n + 1)) ≤ 1 / 3 * «expr‖ ‖» f * (2 / 3) ^ n :=\n    by\n    intro n\n    calc\n      dist (g n) (g (n + 1)) = «expr‖ ‖» (F (f - (g n).comp_continuous e)) := by\n        rw [g_succ, dist_eq_norm', add_sub_cancel']\n      _ ≤ «expr‖ ‖» (f - (g n).comp_continuous e) / 3 := (hF_norm _)\n      _ = 1 / 3 * dist ((g n).comp_continuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]\n      _ ≤ 1 / 3 * ((2 / 3) ^ n * «expr‖ ‖» f) := (mul_le_mul_of_nonneg_left (hgf n) (by norm_num1))\n      _ = 1 / 3 * «expr‖ ‖» f * (2 / 3) ^ n := by ac_rfl\n      \n  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist\n  have : tendsto (fun n => (g n).comp_continuous e) at_top (nhds <| (limUnder at_top g).comp_continuous e) :=\n    ((continuous_comp_continuous e).tendsto _).comp hg_cau.tendsto_lim\n  have hge : (limUnder at_top g).comp_continuous e = f :=\n    by\n    refine' tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 _)\n    refine' squeeze_zero (fun _ => dist_nonneg) hgf _\n    rw [← MulZeroClass.zero_mul («expr‖ ‖» f)]\n    refine' (tendsto_pow_atTop_nhds_0_of_lt_1 _ _).mul tendsto_const_nhds <;> norm_num1\n  refine' ⟨limUnder at_top g, le_antisymm _ _, hge⟩\n  · rw [← dist_zero_left, ← g0]\n    refine' (dist_le_of_le_geometric_of_tendsto₀ _ _ (by norm_num1) hg_dist hg_cau.tendsto_lim).trans_eq _\n    field_simp [show (3 - 2 : exprℝ) = 1 by norm_num1]\n  · rw [← hge]\n    exact norm_comp_continuous_le _ _\n#align exists_extension_norm_eq_of_closed_embedding' exists_extension_norm_eq_of_closed_embedding'\n\n",
 "exists_extension_norm_eq_of_closed_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\nembedding and unbundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\ninto a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous function, then there exists\na bounded continuous function `g : Y →ᵇ ℝ` of the same norm such that `g ∘ e = f`. -/\ntheorem exists_extension_norm_eq_of_closed_embedding (f : bounded_continuous_function X (exprℝ)) {e : X → Y}\n    (he : ClosedEmbedding e) : ∃ g : bounded_continuous_function Y (exprℝ), «expr‖ ‖» g = «expr‖ ‖» f ∧ g ∘ e = f :=\n  by\n  rcases exists_extension_norm_eq_of_closed_embedding' f ⟨e, he.continuous⟩ he with ⟨g, hg, rfl⟩\n  exact ⟨g, hg, rfl⟩\n#align exists_extension_norm_eq_of_closed_embedding exists_extension_norm_eq_of_closed_embedding\n\n",
 "exists_extension_forall_mem_of_closed_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Let `t` be a nonempty\nconvex set of real numbers (we use `ord_connected` instead of `convex` to automatically deduce this\nargument by typeclass search) such that `f x ∈ t` for all `x`. Then there exists a continuous\nreal-valued function `g : C(Y, ℝ)` such that `g y ∈ t` for all `y` and `g ∘ e = f`. -/\ntheorem exists_extension_forall_mem_of_closed_embedding (f : «exprC( , )» X (exprℝ)) {t : Set (exprℝ)} {e : X → Y}\n    [hs : OrdConnected t] (hf : ∀ x, f x ∈ t) (hne : t.nonempty) (he : ClosedEmbedding e) :\n    ∃ g : «exprC( , )» Y (exprℝ), (∀ y, g y ∈ t) ∧ g ∘ e = f :=\n  by\n  have h : «expr ≃o » (exprℝ) (Ioo (-1 : exprℝ) 1) := orderIsoIooNegOneOne (exprℝ)\n  set F : bounded_continuous_function X (exprℝ) :=\n    { to_fun := coe ∘ h ∘ f\n      continuous_to_fun := continuous_subtype_coe.comp (h.continuous.comp f.continuous)\n      map_bounded' :=\n        bounded_range_iff.1 ((bounded_Ioo (-1 : exprℝ) 1).mono <| forall_range_iff.2 fun x => (h (f x)).2) }\n  set t' : Set (exprℝ) := «expr '' » (coe ∘ h) t\n  have ht_sub : t' ⊆ Ioo (-1 : exprℝ) 1 := image_subset_iff.2 fun x hx => (h x).2\n  have : ord_connected t' := by\n    constructor\n    rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩ z hz\n    lift z to Ioo (-1 : exprℝ) 1 using Icc_subset_Ioo (h x).2.1 (h y).2.2 hz\n    change z ∈ Icc (h x) (h y) at hz\n    rw [← h.image_Icc] at hz\n    rcases hz with ⟨z, hz, rfl⟩\n    exact ⟨z, hs.out hx hy hz, rfl⟩\n  have hFt : ∀ x, F x ∈ t' := fun x => mem_image_of_mem _ (hf x)\n  rcases F.exists_extension_forall_mem_of_closed_embedding hFt (hne.image _) he with ⟨G, hG, hGF⟩\n  set g : «exprC( , )» Y (exprℝ) :=\n    ⟨h.symm ∘ cod_restrict G _ fun y => ht_sub (hG y), h.symm.continuous.comp <| G.continuous.subtype_mk _⟩\n  have hgG : ∀ {y a}, g y = a ↔ G y = h a := fun y a => h.to_equiv.symm_apply_eq.trans Subtype.ext_iff\n  refine' ⟨g, fun y => _, _⟩\n  · rcases hG y with ⟨a, ha, hay⟩\n    convert ha\n    exact hgG.2 hay.symm\n  · ext x\n    exact hgG.2 (congr_fun hGF _)\n#align exists_extension_forall_mem_of_closed_embedding exists_extension_forall_mem_of_closed_embedding\n\n",
 "exists_extension_forall_mem_Icc_of_closed_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nembedding and a bounded continuous function that takes values in a non-trivial closed interval.\nSee also `exists_extension_forall_mem_of_closed_embedding` for a more general statement that works\nfor any interval (finite or infinite, open or closed).\n\nIf `e : X → Y` is a closed embedding and `f : X →ᵇ ℝ` is a bounded continuous function such that\n`f x ∈ [a, b]` for all `x`, where `a ≤ b`, then there exists a bounded continuous function\n`g : Y →ᵇ ℝ` such that `g y ∈ [a, b]` for all `y` and `g ∘ e = f`. -/\ntheorem exists_extension_forall_mem_Icc_of_closed_embedding (f : bounded_continuous_function X (exprℝ)) {a b : exprℝ}\n    {e : X → Y} (hf : ∀ x, f x ∈ Icc a b) (hle : a ≤ b) (he : ClosedEmbedding e) :\n    ∃ g : bounded_continuous_function Y (exprℝ), (∀ y, g y ∈ Icc a b) ∧ g ∘ e = f :=\n  by\n  rcases exists_extension_norm_eq_of_closed_embedding (f - const X ((a + b) / 2)) he with ⟨g, hgf, hge⟩\n  refine' ⟨const Y ((a + b) / 2) + g, fun y => _, _⟩\n  · suffices «expr‖ ‖» (f - const X ((a + b) / 2)) ≤ (b - a) / 2 by\n      simpa [Real.Icc_eq_closedBall, add_mem_closedBall_iff_norm] using (norm_coe_le_norm g y).trans (hgf.trans_le this)\n    refine' (norm_le <| div_nonneg (sub_nonneg.2 hle) zero_le_two).2 fun x => _\n    simpa only [Real.Icc_eq_closedBall] using hf x\n  · ext x\n    have : g (e x) = f x - (a + b) / 2 := congr_fun hge x\n    simp [this]\n#align exists_extension_forall_mem_Icc_of_closed_embedding exists_extension_forall_mem_Icc_of_closed_embedding\n\n",
 "exists_extension_forall_exists_le_ge_of_closed_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `bounded_continuous_function -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a bounded continuous real-valued function on `X`. Then there\nexists a bounded continuous function `g : Y →ᵇ ℝ` such that `g ∘ e = f` and each value `g y` belongs\nto a closed interval `[f x₁, f x₂]` for some `x₁` and `x₂`.  -/\ntheorem exists_extension_forall_exists_le_ge_of_closed_embedding [Nonempty X]\n    (f : bounded_continuous_function X (exprℝ)) {e : X → Y} (he : ClosedEmbedding e) :\n    ∃ g : bounded_continuous_function Y (exprℝ), (∀ y, ∃ x₁ x₂, g y ∈ Icc (f x₁) (f x₂)) ∧ g ∘ e = f :=\n  by\n  inhabit X\n  -- Put `a = ⨅ x, f x` and `b = ⨆ x, f x`\n  obtain ⟨a, ha⟩ : ∃ a, IsGLB (range f) a\n  exact ⟨_, isGLB_cinfᵢ (Real.bounded_iff_bddBelow_bddAbove.1 f.bounded_range).1⟩\n  obtain ⟨b, hb⟩ : ∃ b, IsLUB (range f) b\n  exact ⟨_, isLUB_csupᵢ (Real.bounded_iff_bddBelow_bddAbove.1 f.bounded_range).2⟩\n  -- Then `f x ∈ [a, b]` for all `x`\n  have hmem : ∀ x, f x ∈ Icc a b := fun x => ⟨ha.1 ⟨x, rfl⟩, hb.1 ⟨x, rfl⟩⟩\n  -- Rule out the trivial case `a = b`\n  have hle : a ≤ b := (hmem default).1.trans (hmem default).2\n  rcases hle.eq_or_lt with (rfl | hlt)\n  · have : ∀ x, f x = a := by simpa using hmem\n    use const Y a\n    simp [this, Function.funext_iff]\n  -- Put `c = (a + b) / 2`. Then `a < c < b` and `c - a = b - c`.\n  set c := (a + b) / 2\n  have hac : a < c := left_lt_add_div_two.2 hlt\n  have hcb : c < b := add_div_two_lt_right.2 hlt\n  have hsub : c - a = b - c := by\n    simp only [c]\n    field_simp\n    ring\n  /- Due to `exists_extension_forall_mem_Icc_of_closed_embedding`, there exists an extension `g`\n    such that `g y ∈ [a, b]` for all `y`. However, if `a` and/or `b` do not belong to the range of\n    `f`, then we need to ensure that these points do not belong to the range of `g`. This is done\n    in two almost identical steps. First we deal with the case `∀ x, f x ≠ a`. -/\n  obtain ⟨g, hg_mem, hgf⟩ : ∃ g : bounded_continuous_function Y (exprℝ), (∀ y, ∃ x, g y ∈ Icc (f x) b) ∧ g ∘ e = f :=\n    by\n    rcases exists_extension_forall_mem_Icc_of_closed_embedding f hmem hle he with ⟨g, hg_mem, hgf⟩\n    -- If `a ∈ range f`, then we are done.\n    rcases em (∃ x, f x = a) with (⟨x, rfl⟩ | ha')\n    · exact ⟨g, fun y => ⟨x, hg_mem _⟩, hgf⟩\n    /- Otherwise, `g ⁻¹' {a}` is disjoint with `range e ∪ g ⁻¹' (Ici c)`, hence there exists a\n        function `dg : Y → ℝ` such that `dg ∘ e = 0`, `dg y = 0` whenever `c ≤ g y`, `dg y = c - a`\n        whenever `g y = a`, and `0 ≤ dg y ≤ c - a` for all `y`.  -/\n    have hd : Disjoint (range e ∪ «expr ⁻¹' » g (Ici c)) («expr ⁻¹' » g {a}) :=\n      by\n      refine' disjoint_union_left.2 ⟨_, Disjoint.preimage _ _⟩\n      · rw [Set.disjoint_left]\n        rintro _ ⟨x, rfl⟩ (rfl : g (e x) = a)\n        exact ha' ⟨x, (congr_fun hgf x).symm⟩\n      · exact Set.disjoint_singleton_right.2 hac.not_le\n    rcases exists_bounded_mem_Icc_of_closed_of_le (he.closed_range.union <| is_closed_Ici.preimage g.continuous)\n        (is_closed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with\n      ⟨dg, dg0, dga, dgmem⟩\n    replace hgf : ∀ x, (g + dg) (e x) = f x\n    · intro x\n      simp [dg0 (or.inl <| mem_range_self _), ← hgf]\n    refine' ⟨g + dg, fun y => _, funext hgf⟩\n    · have hay : a < (g + dg) y := by\n        rcases(hg_mem y).1.eq_or_lt with (rfl | hlt)\n        · refine' (lt_add_iff_pos_right _).2 _\n          calc\n            0 < c - g y := sub_pos.2 hac\n            _ = dg y := (dga rfl).symm\n            \n        · exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)\n      rcases ha.exists_between hay with ⟨_, ⟨x, rfl⟩, hax, hxy⟩\n      refine' ⟨x, hxy.le, _⟩\n      cases' le_total c (g y) with hc hc\n      · simp [dg0 (or.inr hc), (hg_mem y).2]\n      ·\n        calc\n          g y + dg y ≤ c + (c - a) := add_le_add hc (dgmem _).2\n          _ = b := by rw [hsub, add_sub_cancel'_right]\n          \n  /- Now we deal with the case `∀ x, f x ≠ b`. The proof is the same as in the first case, with\n    minor modifications that make it hard to deduplicate code. -/\n  choose xl hxl hgb using hg_mem\n  rcases em (∃ x, f x = b) with (⟨x, rfl⟩ | hb')\n  · exact ⟨g, fun y => ⟨xl y, x, hxl y, hgb y⟩, hgf⟩\n  have hd : Disjoint (range e ∪ «expr ⁻¹' » g (Iic c)) («expr ⁻¹' » g {b}) :=\n    by\n    refine' disjoint_union_left.2 ⟨_, Disjoint.preimage _ _⟩\n    · rw [Set.disjoint_left]\n      rintro _ ⟨x, rfl⟩ (rfl : g (e x) = b)\n      exact hb' ⟨x, (congr_fun hgf x).symm⟩\n    · exact Set.disjoint_singleton_right.2 hcb.not_le\n  rcases exists_bounded_mem_Icc_of_closed_of_le (he.closed_range.union <| is_closed_Iic.preimage g.continuous)\n      (is_closed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with\n    ⟨dg, dg0, dgb, dgmem⟩\n  replace hgf : ∀ x, (g - dg) (e x) = f x\n  · intro x\n    simp [dg0 (or.inl <| mem_range_self _), ← hgf]\n  refine' ⟨g - dg, fun y => _, funext hgf⟩\n  · have hyb : (g - dg) y < b := by\n      rcases(hgb y).eq_or_lt with (rfl | hlt)\n      · refine' (sub_lt_self_iff _).2 _\n        calc\n          0 < g y - c := sub_pos.2 hcb\n          _ = dg y := (dgb rfl).symm\n          \n      · exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt\n    rcases hb.exists_between hyb with ⟨_, ⟨xu, rfl⟩, hyxu, hxub⟩\n    cases' lt_or_le c (g y) with hc hc\n    · rcases em (a ∈ range f) with (⟨x, rfl⟩ | ha')\n      · refine' ⟨x, xu, _, hyxu.le⟩\n        calc\n          f x = c - (b - c) := by rw [← hsub, sub_sub_cancel]\n          _ ≤ g y - dg y := sub_le_sub hc.le (dgmem _).2\n          \n      · have hay : a < (g - dg) y := by\n          calc\n            a = c - (b - c) := by rw [← hsub, sub_sub_cancel]\n            _ < g y - (b - c) := (sub_lt_sub_right hc _)\n            _ ≤ g y - dg y := sub_le_sub_left (dgmem _).2 _\n            \n        rcases ha.exists_between hay with ⟨_, ⟨x, rfl⟩, ha, hxy⟩\n        exact ⟨x, xu, hxy.le, hyxu.le⟩\n    · refine' ⟨xl y, xu, _, hyxu.le⟩\n      simp [dg0 (or.inr hc), hxl]\n#align exists_extension_forall_exists_le_ge_of_closed_embedding exists_extension_forall_exists_le_ge_of_closed_embedding\n\n"}