{"refinement_of_locally_compact_sigma_compact_of_nhds_basis_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n-- See note [lower instance priority]\n-- the proof is trivial: we choose a finite subcover using compactness, and use it\n/-- Let `X` be a locally compact sigma compact Hausdorff topological space, let `s` be a closed set\nin `X`. Suppose that for each `x ∈ s` the sets `B x : ι x → set X` with the predicate\n`p x : ι x → Prop` form a basis of the filter `𝓝 x`. Then there exists a locally finite covering\n`λ i, B (c i) (r i)` of `s` such that all “centers” `c i` belong to `s` and each `r i` satisfies\n`p (c i)`.\n\nThe notation is inspired by the case `B x r = metric.ball x r` but the theorem applies to\n`nhds_basis_opens` as well. If the covering must be subordinate to some open covering of `s`, then\nthe user should use a basis obtained by `filter.has_basis.restrict_subset` or a similar lemma, see\nthe proof of `paracompact_of_locally_compact_sigma_compact` for an example.\n\nThe formalization is based on two [ncatlab](https://ncatlab.org/) proofs:\n* [locally compact and sigma compact spaces are paracompact](https://ncatlab.org/nlab/show/locally+compact+and+sigma-compact+spaces+are+paracompact);\n* [open cover of smooth manifold admits locally finite refinement by closed balls](https://ncatlab.org/nlab/show/partition+of+unity#ExistenceOnSmoothManifolds).\n\nSee also `refinement_of_locally_compact_sigma_compact_of_nhds_basis` for a version of this lemma\ndealing with a covering of the whole space.\n\nIn most cases (namely, if `B c r ∪ B c r'` is again a set of the form `B c r''`) it is possible\nto choose `α = X`. This fact is not yet formalized in `mathlib`. -/\ntheorem refinement_of_locally_compact_sigma_compact_of_nhds_basis_set [locally_compact_space X] [sigma_compact_space X]\n    [t2_space X] {ι : X → Type u} {p : ∀ x, ι x → Prop} {B : ∀ x, ι x → set X} {s : set X} (hs : is_closed s)\n    (hB : ∀ x ∈ s, ((nhds) x).has_basis (p x) (B x)) :\n    ∃ (α : Type v)(c : α → X)(r : ∀ a, ι (c a)),\n      (∀ a, c a ∈ s ∧ p (c a) (r a)) ∧\n        s ⊆\n            «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n              (B (c a) (r a)) ∧\n          locally_finite fun a => B (c a) (r a) :=\n  by\n  classical\n    -- For technical reasons we prepend two empty sets to the sequence `compact_exhaustion.choice X`\n    set K' : compact_exhaustion X := compact_exhaustion.choice X\n    set K : compact_exhaustion X := K'.shiftr.shiftr\n    set Kdiff := fun n => K (n + 1) \\ interior (K n)\n    -- Now we restate some properties of `compact_exhaustion` for `K`/`Kdiff`\n    have hKcov : ∀ x, x ∈ Kdiff (K'.find x + 1) := by\n      intro x\n      simpa only [K'.find_shiftr] using diff_subset_diff_right interior_subset (K'.shiftr.mem_diff_shiftr_find x)\n    have Kdiffc : ∀ n, is_compact (Kdiff n ∩ s) := fun n => ((K.is_compact _).diff is_open_interior).inter_right hs\n    -- Next we choose a finite covering `B (c n i) (r n i)` of each\n    -- `Kdiff (n + 1) ∩ s` such that `B (c n i) (r n i) ∩ s` is disjoint with `K n`\n    have : ∀ (n) (x : Kdiff (n + 1) ∩ s), «expr ᶜ» (K n) ∈ (nhds) (x : X) := fun n x =>\n      is_open.mem_nhds (K.is_closed n).is_open_compl fun hx' => x.2.1.2 <| K.subset_interior_succ _ hx'\n    haveI : ∀ (n) (x : Kdiff n ∩ s), nonempty (ι x) := fun n x => (hB x x.2.2).nonempty\n    choose! r hrp hr using fun n (x : Kdiff (n + 1) ∩ s) => (hB x x.2.2).mem_iff.1 (this n x)\n    have hxr : ∀ (n x) (hx : x ∈ Kdiff (n + 1) ∩ s), B x (r n ⟨x, hx⟩) ∈ (nhds) x := fun n x hx =>\n      (hB x hx.2).mem_of_mem (hrp _ ⟨x, hx⟩)\n    choose T hT using fun n => (Kdiffc (n + 1)).elim_nhds_subcover' _ (hxr n)\n    set T' : ∀ n, set («expr↥ » (Kdiff (n + 1) ∩ s)) := fun n => T n\n    -- Finally, we take the union of all these coverings\n    refine' ⟨Σn, T' n, fun a => a.2, fun a => r a.1 a.2, _, _, _⟩\n    · rintro ⟨n, x, hx⟩\n      exact ⟨x.2.2, hrp _ _⟩\n    · refine' fun x hx => mem_Union.2 _\n      rcases mem_Union₂.1 (hT _ ⟨hKcov x, hx⟩) with ⟨⟨c, hc⟩, hcT, hcx⟩\n      exact ⟨⟨_, ⟨c, hc⟩, hcT⟩, hcx⟩\n    · intro x\n      refine'\n        ⟨interior (K (K'.find x + 3)), is_open.mem_nhds is_open_interior (K.subset_interior_succ _ (hKcov x).1), _⟩\n      have :\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n              (range <| sigma.mk k) :\n            set (Σn, T' n)).finite :=\n        (finite_le_nat _).bUnion fun k hk => finite_range _\n      apply this.subset\n      rintro ⟨k, c, hc⟩\n      simp only [mem_Union, mem_set_of_eq, mem_image, subtype.coe_mk]\n      rintro ⟨x, hxB : x ∈ B c (r k c), hxK⟩\n      refine' ⟨k, _, ⟨c, hc⟩, rfl⟩\n      have := (mem_compl_iff _ _).1 (hr k c hxB)\n      contrapose! this with hnk\n      exact K.subset hnk (interior_subset hxK)\n#align\n  refinement_of_locally_compact_sigma_compact_of_nhds_basis_set refinement_of_locally_compact_sigma_compact_of_nhds_basis_set\n\n",
 "refinement_of_locally_compact_sigma_compact_of_nhds_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- Let `X` be a locally compact sigma compact Hausdorff topological space. Suppose that for each\n`x` the sets `B x : ι x → set X` with the predicate `p x : ι x → Prop` form a basis of the filter\n`𝓝 x`. Then there exists a locally finite covering `λ i, B (c i) (r i)` of `X` such that each `r i`\nsatisfies `p (c i)`\n\nThe notation is inspired by the case `B x r = metric.ball x r` but the theorem applies to\n`nhds_basis_opens` as well. If the covering must be subordinate to some open covering of `s`, then\nthe user should use a basis obtained by `filter.has_basis.restrict_subset` or a similar lemma, see\nthe proof of `paracompact_of_locally_compact_sigma_compact` for an example.\n\nThe formalization is based on two [ncatlab](https://ncatlab.org/) proofs:\n* [locally compact and sigma compact spaces are paracompact](https://ncatlab.org/nlab/show/locally+compact+and+sigma-compact+spaces+are+paracompact);\n* [open cover of smooth manifold admits locally finite refinement by closed balls](https://ncatlab.org/nlab/show/partition+of+unity#ExistenceOnSmoothManifolds).\n\nSee also `refinement_of_locally_compact_sigma_compact_of_nhds_basis_set` for a version of this lemma\ndealing with a covering of a closed set.\n\nIn most cases (namely, if `B c r ∪ B c r'` is again a set of the form `B c r''`) it is possible\nto choose `α = X`. This fact is not yet formalized in `mathlib`. -/\ntheorem refinement_of_locally_compact_sigma_compact_of_nhds_basis [locally_compact_space X] [sigma_compact_space X]\n    [t2_space X] {ι : X → Type u} {p : ∀ x, ι x → Prop} {B : ∀ x, ι x → set X}\n    (hB : ∀ x, ((nhds) x).has_basis (p x) (B x)) :\n    ∃ (α : Type v)(c : α → X)(r : ∀ a, ι (c a)),\n      (∀ a, p (c a) (r a)) ∧\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n              (B (c a) (r a)) =\n            univ ∧\n          locally_finite fun a => B (c a) (r a) :=\n  let ⟨α, c, r, hp, hU, hfin⟩ :=\n    refinement_of_locally_compact_sigma_compact_of_nhds_basis_set is_closed_univ fun x _ => hB x\n  ⟨α, c, r, fun a => (hp a).2, univ_subset_iff.1 hU, hfin⟩\n#align\n  refinement_of_locally_compact_sigma_compact_of_nhds_basis refinement_of_locally_compact_sigma_compact_of_nhds_basis\n\n",
 "precise_refinement_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- In a paracompact space, every open covering of a closed set admits a locally finite refinement\nindexed by the same type. -/\ntheorem precise_refinement_set [paracompact_space X] {s : set X} (hs : is_closed s) (u : ι → set X)\n    (uo : ∀ i, is_open (u i))\n    (us : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u i)) :\n    ∃ v : ι → set X,\n      (∀ i, is_open (v i)) ∧\n        s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (v i) ∧\n          locally_finite v ∧ ∀ i, v i ⊆ u i :=\n  by\n  rcases precise_refinement (Option.elim' («expr ᶜ» s) u) (option.forall.2 ⟨is_open_compl_iff.2 hs, uo⟩) _ with\n    ⟨v, vo, vc, vf, vu⟩\n  refine' ⟨v ∘ some, fun i => vo _, _, vf.comp_injective (option.some_injective _), fun i => vu _⟩\n  · simp only [Union_option, ← compl_subset_iff_union] at vc\n    exact subset.trans (subset_compl_comm.1 <| vu option.none) vc\n  · simpa only [Union_option, Option.elim', ← compl_subset_iff_union, compl_compl]\n#align precise_refinement_set precise_refinement_set\n\n",
 "precise_refinement":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Reid Barton, Yury Kudryashov\n-/\n/-- Any open cover of a paracompact space has a locally finite *precise* refinement, that is,\none indexed on the same type with each open set contained in the corresponding original one. -/\ntheorem precise_refinement [paracompact_space X] (u : ι → set X) (uo : ∀ a, is_open (u a))\n    (uc :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u i) = univ) :\n    ∃ v : ι → set X,\n      (∀ a, is_open (v a)) ∧\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (v i) = univ ∧\n          locally_finite v ∧ ∀ a, v a ⊆ u a :=\n  by\n  -- Apply definition to `range u`, then turn existence quantifiers into functions using `choose`\n  have :=\n    paracompact_space.locally_finite_refinement (range u) coe (SetCoe.forall.2 <| forall_range_iff.2 uo)\n      (by rwa [← sUnion_range, Subtype.range_coe])\n  simp only [SetCoe.exists, subtype.coe_mk, exists_range_iff', Union_eq_univ_iff, exists_prop] at this\n  choose α t hto hXt htf ind hind; choose t_inv ht_inv using hXt; choose U hxU hU using htf\n  -- Send each `i` to the union of `t a` over `a ∈ ind ⁻¹' {i}`\n  refine'\n    ⟨fun i => «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t a), _,\n      _, _, _⟩\n  · exact fun a => is_open_Union fun a => is_open_Union fun ha => hto a\n  · simp only [eq_univ_iff_forall, mem_Union]\n    exact fun x => ⟨ind (t_inv x), _, rfl, ht_inv _⟩\n  · refine' fun x => ⟨U x, hxU x, ((hU x).image ind).subset _⟩\n    simp only [subset_def, mem_Union, mem_set_of_eq, Set.Nonempty, mem_inter_iff]\n    rintro i ⟨y, ⟨a, rfl, hya⟩, hyU⟩\n    exact mem_image_of_mem _ ⟨y, hya, hyU⟩\n  · simp only [subset_def, mem_Union]\n    rintro i x ⟨a, rfl, hxa⟩\n    exact hind _ hxa\n#align precise_refinement precise_refinement\n\n",
 "normal_of_paracompact_t2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n-- See note [lower instance priority]\n/- Dieudonné‘s theorem: a paracompact Hausdorff space is normal. Formalization is based on the proof\nat [ncatlab](https://ncatlab.org/nlab/show/paracompact+Hausdorff+spaces+are+normal). -/\ntheorem normal_of_paracompact_t2 [t2_space X] [paracompact_space X] : normal_space X :=\n  by\n  -- First we show how to go from points to a set on one side.\n  have :\n    ∀ s t : set X,\n      is_closed s →\n        is_closed t →\n          (∀ x ∈ s, ∃ u v, is_open u ∧ is_open v ∧ x ∈ u ∧ t ⊆ v ∧ Disjoint u v) →\n            ∃ u v, is_open u ∧ is_open v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint u v :=\n    by\n    /- For each `x ∈ s` we choose open disjoint `u x ∋ x` and `v x ⊇ t`. The sets `u x` form an\n        open covering of `s`. We choose a locally finite refinement `u' : s → set X`, then `⋃ i, u' i`\n        and `(closure (⋃ i, u' i))ᶜ` are disjoint open neighborhoods of `s` and `t`. -/\n    intro s t hs ht H\n    choose u v hu hv hxu htv huv using SetCoe.forall'.1 H\n    rcases precise_refinement_set hs u hu fun x hx => mem_Union.2 ⟨⟨x, hx⟩, hxu _⟩ with ⟨u', hu'o, hcov', hu'fin, hsub⟩\n    refine'\n      ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u' i),\n        «expr ᶜ»\n          (closure\n            («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u' i))),\n        is_open_Union hu'o, is_closed_closure.is_open_compl, hcov', _,\n        disjoint_compl_right.mono le_rfl (compl_le_compl subset_closure)⟩\n    rw [hu'fin.closure_Union, compl_Union, subset_Inter_iff]\n    refine' fun i x hxt hxu => absurd (htv i hxt) (closure_minimal _ (is_closed_compl_iff.2 <| hv _) hxu)\n    exact fun y hyu hyv => (huv i).le_bot ⟨hsub _ hyu, hyv⟩\n  -- Now we apply the lemma twice: first to `s` and `t`, then to `t` and each point of `s`.\n  refine' ⟨fun s t hs ht hst => this s t hs ht fun x hx => _⟩\n  rcases this t {x} ht is_closed_singleton fun y hy => _ with ⟨v, u, hv, hu, htv, hxu, huv⟩\n  · exact ⟨u, v, hu, hv, singleton_subset_iff.1 hxu, htv, huv.symm⟩\n  · simp_rw [singleton_subset_iff]\n    exact t2_separation (hst.symm.ne_of_mem hy hx)\n#align normal_of_paracompact_t2 normal_of_paracompact_t2\n\n"}