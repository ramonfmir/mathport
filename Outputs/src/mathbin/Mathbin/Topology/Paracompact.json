{"refinement_of_locally_compact_sigma_compact_of_nhds_basis_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†¥ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n-- See note [lower instance priority]\n-- the proof is trivial: we choose a finite subcover using compactness, and use it\n/-- Let `X` be a locally compact sigma compact Hausdorff topological space, let `s` be a closed set\nin `X`. Suppose that for each `x âˆˆ s` the sets `B x : Î¹ x â†’ set X` with the predicate\n`p x : Î¹ x â†’ Prop` form a basis of the filter `ğ“ x`. Then there exists a locally finite covering\n`Î» i, B (c i) (r i)` of `s` such that all â€œcentersâ€ `c i` belong to `s` and each `r i` satisfies\n`p (c i)`.\n\nThe notation is inspired by the case `B x r = metric.ball x r` but the theorem applies to\n`nhds_basis_opens` as well. If the covering must be subordinate to some open covering of `s`, then\nthe user should use a basis obtained by `filter.has_basis.restrict_subset` or a similar lemma, see\nthe proof of `paracompact_of_locally_compact_sigma_compact` for an example.\n\nThe formalization is based on two [ncatlab](https://ncatlab.org/) proofs:\n* [locally compact and sigma compact spaces are paracompact](https://ncatlab.org/nlab/show/locally+compact+and+sigma-compact+spaces+are+paracompact);\n* [open cover of smooth manifold admits locally finite refinement by closed balls](https://ncatlab.org/nlab/show/partition+of+unity#ExistenceOnSmoothManifolds).\n\nSee also `refinement_of_locally_compact_sigma_compact_of_nhds_basis` for a version of this lemma\ndealing with a covering of the whole space.\n\nIn most cases (namely, if `B c r âˆª B c r'` is again a set of the form `B c r''`) it is possible\nto choose `Î± = X`. This fact is not yet formalized in `mathlib`. -/\ntheorem refinement_of_locally_compact_sigma_compact_of_nhds_basis_set [locally_compact_space X] [sigma_compact_space X]\n    [t2_space X] {Î¹ : X â†’ Type u} {p : âˆ€ x, Î¹ x â†’ Prop} {B : âˆ€ x, Î¹ x â†’ set X} {s : set X} (hs : is_closed s)\n    (hB : âˆ€ x âˆˆ s, ((nhds) x).has_basis (p x) (B x)) :\n    âˆƒ (Î± : Type v)(c : Î± â†’ X)(r : âˆ€ a, Î¹ (c a)),\n      (âˆ€ a, c a âˆˆ s âˆ§ p (c a) (r a)) âˆ§\n        s âŠ†\n            Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n              (B (c a) (r a)) âˆ§\n          locally_finite fun a => B (c a) (r a) :=\n  by\n  classical\n    -- For technical reasons we prepend two empty sets to the sequence `compact_exhaustion.choice X`\n    set K' : compact_exhaustion X := compact_exhaustion.choice X\n    set K : compact_exhaustion X := K'.shiftr.shiftr\n    set Kdiff := fun n => K (n + 1) \\ interior (K n)\n    -- Now we restate some properties of `compact_exhaustion` for `K`/`Kdiff`\n    have hKcov : âˆ€ x, x âˆˆ Kdiff (K'.find x + 1) := by\n      intro x\n      simpa only [K'.find_shiftr] using diff_subset_diff_right interior_subset (K'.shiftr.mem_diff_shiftr_find x)\n    have Kdiffc : âˆ€ n, is_compact (Kdiff n âˆ© s) := fun n => ((K.is_compact _).diff is_open_interior).inter_right hs\n    -- Next we choose a finite covering `B (c n i) (r n i)` of each\n    -- `Kdiff (n + 1) âˆ© s` such that `B (c n i) (r n i) âˆ© s` is disjoint with `K n`\n    have : âˆ€ (n) (x : Kdiff (n + 1) âˆ© s), Â«expr á¶œÂ» (K n) âˆˆ (nhds) (x : X) := fun n x =>\n      is_open.mem_nhds (K.is_closed n).is_open_compl fun hx' => x.2.1.2 <| K.subset_interior_succ _ hx'\n    haveI : âˆ€ (n) (x : Kdiff n âˆ© s), nonempty (Î¹ x) := fun n x => (hB x x.2.2).nonempty\n    choose! r hrp hr using fun n (x : Kdiff (n + 1) âˆ© s) => (hB x x.2.2).mem_iff.1 (this n x)\n    have hxr : âˆ€ (n x) (hx : x âˆˆ Kdiff (n + 1) âˆ© s), B x (r n âŸ¨x, hxâŸ©) âˆˆ (nhds) x := fun n x hx =>\n      (hB x hx.2).mem_of_mem (hrp _ âŸ¨x, hxâŸ©)\n    choose T hT using fun n => (Kdiffc (n + 1)).elim_nhds_subcover' _ (hxr n)\n    set T' : âˆ€ n, set (Â«exprâ†¥ Â» (Kdiff (n + 1) âˆ© s)) := fun n => T n\n    -- Finally, we take the union of all these coverings\n    refine' âŸ¨Î£n, T' n, fun a => a.2, fun a => r a.1 a.2, _, _, _âŸ©\n    Â· rintro âŸ¨n, x, hxâŸ©\n      exact âŸ¨x.2.2, hrp _ _âŸ©\n    Â· refine' fun x hx => mem_Union.2 _\n      rcases mem_Unionâ‚‚.1 (hT _ âŸ¨hKcov x, hxâŸ©) with âŸ¨âŸ¨c, hcâŸ©, hcT, hcxâŸ©\n      exact âŸ¨âŸ¨_, âŸ¨c, hcâŸ©, hcTâŸ©, hcxâŸ©\n    Â· intro x\n      refine'\n        âŸ¨interior (K (K'.find x + 3)), is_open.mem_nhds is_open_interior (K.subset_interior_succ _ (hKcov x).1), _âŸ©\n      have :\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n              (range <| sigma.mk k) :\n            set (Î£n, T' n)).finite :=\n        (finite_le_nat _).bUnion fun k hk => finite_range _\n      apply this.subset\n      rintro âŸ¨k, c, hcâŸ©\n      simp only [mem_Union, mem_set_of_eq, mem_image, subtype.coe_mk]\n      rintro âŸ¨x, hxB : x âˆˆ B c (r k c), hxKâŸ©\n      refine' âŸ¨k, _, âŸ¨c, hcâŸ©, rflâŸ©\n      have := (mem_compl_iff _ _).1 (hr k c hxB)\n      contrapose! this with hnk\n      exact K.subset hnk (interior_subset hxK)\n#align\n  refinement_of_locally_compact_sigma_compact_of_nhds_basis_set refinement_of_locally_compact_sigma_compact_of_nhds_basis_set\n\n",
 "refinement_of_locally_compact_sigma_compact_of_nhds_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/-- Let `X` be a locally compact sigma compact Hausdorff topological space. Suppose that for each\n`x` the sets `B x : Î¹ x â†’ set X` with the predicate `p x : Î¹ x â†’ Prop` form a basis of the filter\n`ğ“ x`. Then there exists a locally finite covering `Î» i, B (c i) (r i)` of `X` such that each `r i`\nsatisfies `p (c i)`\n\nThe notation is inspired by the case `B x r = metric.ball x r` but the theorem applies to\n`nhds_basis_opens` as well. If the covering must be subordinate to some open covering of `s`, then\nthe user should use a basis obtained by `filter.has_basis.restrict_subset` or a similar lemma, see\nthe proof of `paracompact_of_locally_compact_sigma_compact` for an example.\n\nThe formalization is based on two [ncatlab](https://ncatlab.org/) proofs:\n* [locally compact and sigma compact spaces are paracompact](https://ncatlab.org/nlab/show/locally+compact+and+sigma-compact+spaces+are+paracompact);\n* [open cover of smooth manifold admits locally finite refinement by closed balls](https://ncatlab.org/nlab/show/partition+of+unity#ExistenceOnSmoothManifolds).\n\nSee also `refinement_of_locally_compact_sigma_compact_of_nhds_basis_set` for a version of this lemma\ndealing with a covering of a closed set.\n\nIn most cases (namely, if `B c r âˆª B c r'` is again a set of the form `B c r''`) it is possible\nto choose `Î± = X`. This fact is not yet formalized in `mathlib`. -/\ntheorem refinement_of_locally_compact_sigma_compact_of_nhds_basis [locally_compact_space X] [sigma_compact_space X]\n    [t2_space X] {Î¹ : X â†’ Type u} {p : âˆ€ x, Î¹ x â†’ Prop} {B : âˆ€ x, Î¹ x â†’ set X}\n    (hB : âˆ€ x, ((nhds) x).has_basis (p x) (B x)) :\n    âˆƒ (Î± : Type v)(c : Î± â†’ X)(r : âˆ€ a, Î¹ (c a)),\n      (âˆ€ a, p (c a) (r a)) âˆ§\n        Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n              (B (c a) (r a)) =\n            univ âˆ§\n          locally_finite fun a => B (c a) (r a) :=\n  let âŸ¨Î±, c, r, hp, hU, hfinâŸ© :=\n    refinement_of_locally_compact_sigma_compact_of_nhds_basis_set is_closed_univ fun x _ => hB x\n  âŸ¨Î±, c, r, fun a => (hp a).2, univ_subset_iff.1 hU, hfinâŸ©\n#align\n  refinement_of_locally_compact_sigma_compact_of_nhds_basis refinement_of_locally_compact_sigma_compact_of_nhds_basis\n\n",
 "precise_refinement_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/-- In a paracompact space, every open covering of a closed set admits a locally finite refinement\nindexed by the same type. -/\ntheorem precise_refinement_set [paracompact_space X] {s : set X} (hs : is_closed s) (u : Î¹ â†’ set X)\n    (uo : âˆ€ i, is_open (u i))\n    (us : s âŠ† Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (u i)) :\n    âˆƒ v : Î¹ â†’ set X,\n      (âˆ€ i, is_open (v i)) âˆ§\n        s âŠ† Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (v i) âˆ§\n          locally_finite v âˆ§ âˆ€ i, v i âŠ† u i :=\n  by\n  rcases precise_refinement (Option.elim' (Â«expr á¶œÂ» s) u) (option.forall.2 âŸ¨is_open_compl_iff.2 hs, uoâŸ©) _ with\n    âŸ¨v, vo, vc, vf, vuâŸ©\n  refine' âŸ¨v âˆ˜ some, fun i => vo _, _, vf.comp_injective (option.some_injective _), fun i => vu _âŸ©\n  Â· simp only [Union_option, â† compl_subset_iff_union] at vc\n    exact subset.trans (subset_compl_comm.1 <| vu option.none) vc\n  Â· simpa only [Union_option, Option.elim', â† compl_subset_iff_union, compl_compl]\n#align precise_refinement_set precise_refinement_set\n\n",
 "precise_refinement":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Reid Barton, Yury Kudryashov\n-/\n/-- Any open cover of a paracompact space has a locally finite *precise* refinement, that is,\none indexed on the same type with each open set contained in the corresponding original one. -/\ntheorem precise_refinement [paracompact_space X] (u : Î¹ â†’ set X) (uo : âˆ€ a, is_open (u a))\n    (uc :\n      Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (u i) = univ) :\n    âˆƒ v : Î¹ â†’ set X,\n      (âˆ€ a, is_open (v a)) âˆ§\n        Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (v i) = univ âˆ§\n          locally_finite v âˆ§ âˆ€ a, v a âŠ† u a :=\n  by\n  -- Apply definition to `range u`, then turn existence quantifiers into functions using `choose`\n  have :=\n    paracompact_space.locally_finite_refinement (range u) coe (SetCoe.forall.2 <| forall_range_iff.2 uo)\n      (by rwa [â† sUnion_range, Subtype.range_coe])\n  simp only [SetCoe.exists, subtype.coe_mk, exists_range_iff', Union_eq_univ_iff, exists_prop] at this\n  choose Î± t hto hXt htf ind hind; choose t_inv ht_inv using hXt; choose U hxU hU using htf\n  -- Send each `i` to the union of `t a` over `a âˆˆ ind â»Â¹' {i}`\n  refine'\n    âŸ¨fun i => Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (t a), _,\n      _, _, _âŸ©\n  Â· exact fun a => is_open_Union fun a => is_open_Union fun ha => hto a\n  Â· simp only [eq_univ_iff_forall, mem_Union]\n    exact fun x => âŸ¨ind (t_inv x), _, rfl, ht_inv _âŸ©\n  Â· refine' fun x => âŸ¨U x, hxU x, ((hU x).image ind).subset _âŸ©\n    simp only [subset_def, mem_Union, mem_set_of_eq, Set.Nonempty, mem_inter_iff]\n    rintro i âŸ¨y, âŸ¨a, rfl, hyaâŸ©, hyUâŸ©\n    exact mem_image_of_mem _ âŸ¨y, hya, hyUâŸ©\n  Â· simp only [subset_def, mem_Union]\n    rintro i x âŸ¨a, rfl, hxaâŸ©\n    exact hind _ hxa\n#align precise_refinement precise_refinement\n\n",
 "normal_of_paracompact_t2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n-- See note [lower instance priority]\n/- DieudonnÃ©â€˜s theorem: a paracompact Hausdorff space is normal. Formalization is based on the proof\nat [ncatlab](https://ncatlab.org/nlab/show/paracompact+Hausdorff+spaces+are+normal). -/\ntheorem normal_of_paracompact_t2 [t2_space X] [paracompact_space X] : normal_space X :=\n  by\n  -- First we show how to go from points to a set on one side.\n  have :\n    âˆ€ s t : set X,\n      is_closed s â†’\n        is_closed t â†’\n          (âˆ€ x âˆˆ s, âˆƒ u v, is_open u âˆ§ is_open v âˆ§ x âˆˆ u âˆ§ t âŠ† v âˆ§ Disjoint u v) â†’\n            âˆƒ u v, is_open u âˆ§ is_open v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint u v :=\n    by\n    /- For each `x âˆˆ s` we choose open disjoint `u x âˆ‹ x` and `v x âŠ‡ t`. The sets `u x` form an\n        open covering of `s`. We choose a locally finite refinement `u' : s â†’ set X`, then `â‹ƒ i, u' i`\n        and `(closure (â‹ƒ i, u' i))á¶œ` are disjoint open neighborhoods of `s` and `t`. -/\n    intro s t hs ht H\n    choose u v hu hv hxu htv huv using SetCoe.forall'.1 H\n    rcases precise_refinement_set hs u hu fun x hx => mem_Union.2 âŸ¨âŸ¨x, hxâŸ©, hxu _âŸ© with âŸ¨u', hu'o, hcov', hu'fin, hsubâŸ©\n    refine'\n      âŸ¨Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (u' i),\n        Â«expr á¶œÂ»\n          (closure\n            (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (u' i))),\n        is_open_Union hu'o, is_closed_closure.is_open_compl, hcov', _,\n        disjoint_compl_right.mono le_rfl (compl_le_compl subset_closure)âŸ©\n    rw [hu'fin.closure_Union, compl_Union, subset_Inter_iff]\n    refine' fun i x hxt hxu => absurd (htv i hxt) (closure_minimal _ (is_closed_compl_iff.2 <| hv _) hxu)\n    exact fun y hyu hyv => (huv i).le_bot âŸ¨hsub _ hyu, hyvâŸ©\n  -- Now we apply the lemma twice: first to `s` and `t`, then to `t` and each point of `s`.\n  refine' âŸ¨fun s t hs ht hst => this s t hs ht fun x hx => _âŸ©\n  rcases this t {x} ht is_closed_singleton fun y hy => _ with âŸ¨v, u, hv, hu, htv, hxu, huvâŸ©\n  Â· exact âŸ¨u, v, hu, hv, singleton_subset_iff.1 hxu, htv, huv.symmâŸ©\n  Â· simp_rw [singleton_subset_iff]\n    exact t2_separation (hst.symm.ne_of_mem hy hx)\n#align normal_of_paracompact_t2 normal_of_paracompact_t2\n\n"}