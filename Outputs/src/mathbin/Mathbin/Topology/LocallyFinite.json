{"sum_elim":
 "theorem locally_finite.sum_elim {g : Œπ' ‚Üí set X} (hf : locally_finite f) (hg : locally_finite g) :\n    locally_finite (sum.elim f g) :=\n  locally_finite_sum.mpr ‚ü®hf, hg‚ü©\n#align locally_finite.sum_elim locally_finite.sum_elim\n\n",
 "subset":
 "protected theorem subset (hf : locally_finite f) (hg : ‚àÄ i, g i ‚äÜ f i) : locally_finite g := fun a =>\n  let ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü© := hf a\n  ‚ü®t, ht‚ÇÅ, ht‚ÇÇ.subset fun i hi => hi.mono <| inter_subset_inter (hg i) Subset.rfl‚ü©\n#align subset subset\n\n",
 "preimage_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚Åª¬π' ¬ª -/\ntheorem preimage_continuous {g : Y ‚Üí X} (hf : locally_finite f) (hg : continuous g) :\n    locally_finite fun i => ¬´expr ‚Åª¬π' ¬ª g (f i) := fun x =>\n  let ‚ü®s, hsx, hs‚ü© := hf (g x)\n  ‚ü®¬´expr ‚Åª¬π' ¬ª g s, hg.continuous_at hsx, hs.subset fun i ‚ü®y, hy‚ü© => ‚ü®g y, hy‚ü©‚ü©\n#align preimage_continuous preimage_continuous\n\n",
 "point_finite":
 "theorem point_finite (hf : locally_finite f) (x : X) : { b | x ‚àà f b }.finite :=\n  let ‚ü®t, hxt, ht‚ü© := hf x\n  ht.subset fun b hb => ‚ü®x, hb, mem_of_mem_nhds hxt‚ü©\n#align point_finite point_finite\n\n",
 "option_elim":
 "theorem locally_finite.option_elim (hf : locally_finite f) (s : set X) : locally_finite (Option.elim' s f) :=\n  locally_finite_option.2 hf\n#align locally_finite.option_elim locally_finite.option_elim\n\n",
 "locally_finite_sum":
 "theorem locally_finite_sum {f : Sum Œπ Œπ' ‚Üí set X} :\n    locally_finite f ‚Üî locally_finite (f ‚àò sum.inl) ‚àß locally_finite (f ‚àò sum.inr) := by\n  simp only [locally_finite_iff_small_sets, ‚Üê forall_and, ‚Üê finite_preimage_inl_and_inr, preimage_set_of_eq, (¬∑ ‚àò ¬∑),\n    eventually_and]\n#align locally_finite_sum locally_finite_sum\n\n",
 "locally_finite_option":
 "theorem locally_finite_option {f : option Œπ ‚Üí set X} : locally_finite f ‚Üî locally_finite (f ‚àò some) :=\n  by\n  simp only [‚Üê (Equiv.optionEquivSumPUnit.{u} Œπ).symm.locally_finite_comp_iff, locally_finite_sum,\n    locally_finite_of_finite, and_true_iff]\n  rfl\n#align locally_finite_option locally_finite_option\n\n",
 "locally_finite_of_finite":
 "/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\n-- locally finite family [General Topology (Bourbaki, 1995)]\ntheorem locally_finite_of_finite [Finite Œπ] (f : Œπ ‚Üí set X) : locally_finite f := fun x => ‚ü®univ, univ_mem, to_finite _‚ü©\n#align locally_finite_of_finite locally_finite_of_finite\n\n",
 "locally_finite_iff_small_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem _root_.locally_finite_iff_small_sets :\n    locally_finite f ‚Üî\n      ‚àÄ x,\n        ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n          ((nhds) x).small_sets { i | (f i ‚à© s).nonempty }.finite :=\n  forall_congr' fun x =>\n    iff.symm <| eventually_small_sets' fun s t hst ht => ht.subset fun i hi => hi.mono <| inter_subset_inter_right _ hst\n#align locally_finite_iff_small_sets locally_finite_iff_small_sets\n\n",
 "locally_finite_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚âÉ ¬ª -/\n@[simp]\ntheorem equiv.locally_finite_comp_iff (e : ¬´expr ‚âÉ ¬ª Œπ' Œπ) : locally_finite (f ‚àò e) ‚Üî locally_finite f :=\n  ‚ü®fun h => by simpa only [(¬∑ ‚àò ¬∑), e.apply_symm_apply] using h.comp_injective e.symm.injective, fun h =>\n    h.comp_injective e.injective‚ü©\n#align equiv.locally_finite_comp_iff equiv.locally_finite_comp_iff\n\n",
 "is_closed_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\ntheorem is_closed_Union (hf : locally_finite f) (hc : ‚àÄ i, is_closed (f i)) :\n    is_closed (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (f i)) :=\n  by\n  simp only [‚Üê is_open_compl_iff, compl_Union, is_open_iff_mem_nhds, mem_Inter]\n  intro a ha\n  replace ha : ‚àÄ i, ¬´expr ·∂ú¬ª (f i) ‚àà (nhds) a := fun i => (hc i).is_open_compl.mem_nhds (ha i)\n  rcases hf a with ‚ü®t, h_nhds, h_fin‚ü©\n  have :\n    t ‚à©\n        ¬´expr‚ãÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÇ , ¬ª\"\n          (¬´expr ·∂ú¬ª (f i)) ‚àà\n      (nhds) a :=\n    inter_mem h_nhds ((bInter_mem h_fin).2 fun i _ => ha i)\n  filter_upwards [this]\n  simp only [mem_inter_iff, mem_Inter]\n  rintro b ‚ü®hbt, hn‚ü© i hfb\n  exact hn i ‚ü®b, hfb, hbt‚ü© hfb\n#align is_closed_Union is_closed_Union\n\n",
 "exists_mem_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_mem_basis {Œπ' : Sort _} (hf : locally_finite f) {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí set X} {x : X}\n    (hb : ((nhds) x).has_basis p s) : ‚àÉ (i : _)(hi : p i), { j | (f j ‚à© s i).nonempty }.finite :=\n  let ‚ü®i, hpi, hi‚ü© := hb.small_sets.eventually_iff.mp (hf.eventually_small_sets x)\n  ‚ü®i, hpi, hi Subset.rfl‚ü©\n#align exists_mem_basis exists_mem_basis\n\n",
 "exists_forall_eventually_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Let `f : ‚Ñï ‚Üí Œ† a, Œ≤ a` be a sequence of (dependent) functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x ‚â† f n x}` is locally finite. Then there exists a\nfunction `F : Œ† a, Œ≤ a` such that for any `x`, we have `f n x = F x` on the product of an infinite\ninterval `[N, +‚àû)` and a neighbourhood of `x`.\n\nWe formulate the conclusion in terms of the product of filter `filter.at_top` and `ùìù x`. -/\ntheorem exists_forall_eventually_eq_prod {œÄ : X ‚Üí Sort _} {f : ‚Ñï ‚Üí ‚àÄ x : X, œÄ x}\n    (hf : locally_finite fun n => { x | f (n + 1) x ‚â† f n x }) :\n    ‚àÉ F : ‚àÄ x : X, œÄ x,\n      ‚àÄ x,\n        ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n          (filter.prod at_top ((nhds) x)) (f p.1 p.2 = F p.2) :=\n  by\n  choose U hUx hU using hf\n  choose N hN using fun x => (hU x).bdd_above\n  replace hN : ‚àÄ (x), ‚àÄ n > N x, ‚àÄ y ‚àà U x, f (n + 1) y = f n y\n  exact fun x n hn y hy => by_contra fun hne => hn.lt.not_le <| hN x ‚ü®y, hne, hy‚ü©\n  replace hN : ‚àÄ (x), ‚àÄ n ‚â• N x + 1, ‚àÄ y ‚àà U x, f n y = f (N x + 1) y\n  exact fun x n hn y hy => Nat.le_induction rfl (fun k hle => (hN x _ hle _ hy).trans) n hn\n  refine' ‚ü®fun x => f (N x + 1) x, fun x => _‚ü©\n  filter_upwards [filter.prod_mem_prod (eventually_gt_at_top (N x)) (hUx x)]\n  rintro ‚ü®n, y‚ü© ‚ü®hn : N x < n, hy : y ‚àà U x‚ü©\n  calc\n    f n y = f (N x + 1) y := hN _ _ hn _ hy\n    _ = f (max (N x + 1) (N y + 1)) y := (hN _ _ (le_max_left _ _) _ hy).symm\n    _ = f (N y + 1) y := hN _ _ (le_max_right _ _) _ (mem_of_mem_nhds <| hUx y)\n    \n#align exists_forall_eventually_eq_prod exists_forall_eventually_eq_prod\n\n",
 "exists_forall_eventually_at_top_eventually_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Let `f : ‚Ñï ‚Üí Œ† a, Œ≤ a` be a sequence of (dependent) functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x ‚â† f n x}` is locally finite. Then there exists a\nfunction `F : Œ† a, Œ≤ a` such that for any `x`, for sufficiently large values of `n`, we have\n`f n y = F y` in a neighbourhood of `x`. -/\ntheorem exists_forall_eventually_at_top_eventually_eq' {œÄ : X ‚Üí Sort _} {f : ‚Ñï ‚Üí ‚àÄ x : X, œÄ x}\n    (hf : locally_finite fun n => { x | f (n + 1) x ‚â† f n x }) :\n    ‚àÉ F : ‚àÄ x : X, œÄ x,\n      ‚àÄ x,\n        ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" at_top\n          (¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n            ((nhds) x) (f n y = F y)) :=\n  hf.exists_forall_eventually_eq_prod.imp fun F hF x => (hF x).curry\n#align exists_forall_eventually_at_top_eventually_eq' exists_forall_eventually_at_top_eventually_eq'\n\n",
 "exists_forall_eventually_at_top_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr =·∂†[ ] ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Let `f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤` be a sequence of functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x ‚â† f n x}` is locally finite. Then there exists a\nfunction `F :  Œ± ‚Üí Œ≤` such that for any `x`, for sufficiently large values of `n`, we have\n`f n =·∂†[ùìù x] F`. -/\ntheorem exists_forall_eventually_at_top_eventually_eq {f : ‚Ñï ‚Üí X ‚Üí Œ±}\n    (hf : locally_finite fun n => { x | f (n + 1) x ‚â† f n x }) :\n    ‚àÉ F : X ‚Üí Œ±,\n      ‚àÄ x,\n        ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" at_top\n          (¬´expr =·∂†[ ] ¬ª (f n) ((nhds) x) F) :=\n  hf.exists_forall_eventually_at_top_eventually_eq'\n#align exists_forall_eventually_at_top_eventually_eq exists_forall_eventually_at_top_eventually_eq\n\n",
 "eventually_small_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\nprotected theorem eventually_small_sets (hf : locally_finite f) (x : X) :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\"\n      ((nhds) x).small_sets { i | (f i ‚à© s).nonempty }.finite :=\n  locally_finite_iff_small_sets.mp hf x\n#align eventually_small_sets eventually_small_sets\n\n",
 "comp_injective":
 "theorem comp_injective {g : Œπ' ‚Üí Œπ} (hf : locally_finite f) (hg : injective g) : locally_finite (f ‚àò g) :=\n  hf.comp_inj_on (hg.inj_on _)\n#align comp_injective comp_injective\n\n",
 "comp_inj_on":
 "theorem comp_inj_on {g : Œπ' ‚Üí Œπ} (hf : locally_finite f) (hg : InjOn g { i | (f (g i)).nonempty }) :\n    locally_finite (f ‚àò g) := fun x =>\n  let ‚ü®t, htx, htf‚ü© := hf x\n  ‚ü®t, htx, htf.preimage <| hg.mono fun i hi => hi.out.mono <| inter_subset_left _ _‚ü©\n#align comp_inj_on comp_inj_on\n\n",
 "closure_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\ntheorem closure_Union (h : locally_finite f) :\n    closure (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (f i)) =\n      ¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (closure (f i)) :=\n  Subset.antisymm\n    (closure_minimal (Union_mono fun _ => subset_closure) <| h.closure.is_closed_Union fun _ => is_closed_closure)\n    (Union_subset fun i => closure_mono <| subset_union·µ¢ _ _)\n#align closure_Union closure_Union\n\n",
 "closure":
 "protected theorem closure (hf : locally_finite f) : locally_finite fun i => closure (f i) :=\n  by\n  intro x\n  rcases hf x with ‚ü®s, hsx, hsf‚ü©\n  refine' ‚ü®interior s, interior_mem_nhds.2 hsx, hsf.subset fun i hi => _‚ü©\n  exact (hi.mono is_open_interior.closure_inter).of_closure.mono (inter_subset_inter_right _ interior_subset)\n#align closure closure\n\n",
 "Inter_compl_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÇ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f : Œ≤ ‚Üí set Œ±` is a locally finite family of closed sets, then for any `x : Œ±`, the\nintersection of the complements to `f i`, `x ‚àâ f i`, is a neighbourhood of `x`. -/\ntheorem Inter_compl_mem_nhds (hf : locally_finite f) (hc : ‚àÄ i, is_closed (f i)) (x : X) :\n    ¬´expr‚ãÇ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÇ , ¬ª\" (¬´expr ·∂ú¬ª (f i)) ‚àà\n      (nhds) x :=\n  by\n  refine' is_open.mem_nhds _ (mem_Inter‚ÇÇ.2 fun i => id)\n  suffices\n    is_closed (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (f i)) by\n    rwa [‚Üê is_open_compl_iff, compl_Union, Inter_subtype] at this\n  exact (hf.comp_injective subtype.coe_injective).is_closed_Union fun i => hc _\n#align Inter_compl_mem_nhds Inter_compl_mem_nhds\n\n"}