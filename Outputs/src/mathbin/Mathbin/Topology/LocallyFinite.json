{"sum_elim":
 "#print LocallyFinite.sum_elim /-\ntheorem LocallyFinite.sum_elim {g : Î¹' â†’ Set X} (hf : LocallyFinite f) (hg : LocallyFinite g) :\n    LocallyFinite (Sum.elim f g) :=\n  locallyFinite_sum.mpr âŸ¨hf, hgâŸ©\n#align locally_finite.sum_elim LocallyFinite.sum_elim\n-/\n\n",
 "subset":
 "protected theorem subset (hf : LocallyFinite f) (hg : âˆ€ i, g i âŠ† f i) : LocallyFinite g := fun a =>\n  let âŸ¨t, htâ‚, htâ‚‚âŸ© := hf a\n  âŸ¨t, htâ‚, htâ‚‚.subset fun i hi => hi.mono <| inter_subset_inter (hg i) Subset.rflâŸ©\n#align subset subset\n\n",
 "preimage_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_continuous {g : Y â†’ X} (hf : LocallyFinite f) (hg : Continuous g) :\n    LocallyFinite fun i => Â«expr â»Â¹' Â» g (f i) := fun x =>\n  let âŸ¨s, hsx, hsâŸ© := hf (g x)\n  âŸ¨Â«expr â»Â¹' Â» g s, hg.continuous_at hsx, hs.subset fun i âŸ¨y, hyâŸ© => âŸ¨g y, hyâŸ©âŸ©\n#align preimage_continuous preimage_continuous\n\n",
 "point_finite":
 "theorem point_finite (hf : LocallyFinite f) (x : X) : { b | x âˆˆ f b }.finite :=\n  let âŸ¨t, hxt, htâŸ© := hf x\n  ht.subset fun b hb => âŸ¨x, hb, mem_of_mem_nhds hxtâŸ©\n#align point_finite point_finite\n\n",
 "option_elim'":
 "#print LocallyFinite.option_elim' /-\ntheorem LocallyFinite.option_elim' (hf : LocallyFinite f) (s : Set X) : LocallyFinite (Option.elim' s f) :=\n  locallyFinite_option.2 hf\n#align locally_finite.option_elim LocallyFinite.option_elim'\n-/\n\n",
 "nhdsWithin_unionáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print nhdsWithin_unionáµ¢ /-\nprotected theorem nhdsWithin_unionáµ¢ (hf : LocallyFinite f) (a : X) :\n    nhds_within (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i))\n        a =\n      Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n        (nhds_within (f i) a) :=\n  by\n  rcases hf a with âŸ¨U, haU, hfinâŸ©\n  refine' le_antisymm _ (supáµ¢_le fun i => nhdsWithin_mono _ (subset_Union _ _))\n  calc\n    nhds_within (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i))\n          a =\n        nhds_within\n          (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i âˆ© U))\n          a :=\n      by rw [â† Union_inter, â† nhdsWithin_inter_of_mem' (nhdsWithin_le_nhds haU)]\n    _ =\n        nhds_within\n          (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i âˆ© U))\n          a :=\n      by simp only [mem_set_of_eq, Union_nonempty_self]\n    _ =\n        Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n          (nhds_within (f i âˆ© U) a) :=\n      (nhdsWithin_bunionáµ¢ hfin _ _)\n    _ â‰¤\n        Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n          (nhds_within (f i âˆ© U) a) :=\n      (supáµ¢â‚‚_le_supáµ¢ _ _)\n    _ â‰¤\n        Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\"\n          (nhds_within (f i) a) :=\n      supáµ¢_mono fun i => nhdsWithin_mono _ <| inter_subset_left _ _\n    \n#align nhds_within_Union nhdsWithin_unionáµ¢\n-/\n\n",
 "locally_finite_iff_small_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print locallyFinite_iff_smallSets /-\ntheorem locallyFinite_iff_smallSets :\n    LocallyFinite f â†”\n      âˆ€ x,\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n          ((nhds) x).small_sets { i | (f i âˆ© s).nonempty }.finite :=\n  forall_congr' fun x =>\n    iff.symm <| eventually_small_sets' fun s t hst ht => ht.subset fun i hi => hi.mono <| inter_subset_inter_right _ hst\n#align locally_finite_iff_small_sets locallyFinite_iff_smallSets\n-/\n\n",
 "locallyFinite_sum":
 "#print locallyFinite_sum /-\ntheorem locallyFinite_sum {f : Sum Î¹ Î¹' â†’ Set X} :\n    LocallyFinite f â†” LocallyFinite (f âˆ˜ Sum.inl) âˆ§ LocallyFinite (f âˆ˜ Sum.inr) := by\n  simp only [locallyFinite_iff_smallSets, â† forall_and, â† finite_preimage_inl_and_inr, preimage_set_of_eq, (Â· âˆ˜ Â·),\n    eventually_and]\n#align locally_finite_sum locallyFinite_sum\n-/\n\n",
 "locallyFinite_option":
 "#print locallyFinite_option /-\ntheorem locallyFinite_option {f : Option Î¹ â†’ Set X} : LocallyFinite f â†” LocallyFinite (f âˆ˜ some) :=\n  by\n  simp only [â† (Equiv.optionEquivSumPUnit.{u} Î¹).symm.locally_finite_comp_iff, locallyFinite_sum,\n    locallyFinite_of_finite, and_true_iff]\n  rfl\n#align locally_finite_option locallyFinite_option\n-/\n\n",
 "locallyFinite_of_finite":
 "#print locallyFinite_of_finite /-\n/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\n-- locally finite family [General Topology (Bourbaki, 1995)]\ntheorem locallyFinite_of_finite [Finite Î¹] (f : Î¹ â†’ Set X) : LocallyFinite f := fun x => âŸ¨univ, univ_mem, toFinite _âŸ©\n#align locally_finite_of_finite locallyFinite_of_finite\n-/\n\n",
 "locallyFinite_comp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒ Â» -/\n#print Equiv.locallyFinite_comp_iff /-\n@[simp]\ntheorem Equiv.locallyFinite_comp_iff (e : Â«expr â‰ƒ Â» Î¹' Î¹) : LocallyFinite (f âˆ˜ e) â†” LocallyFinite f :=\n  âŸ¨fun h => by simpa only [(Â· âˆ˜ Â·), e.apply_symm_apply] using h.comp_injective e.symm.injective, fun h =>\n    h.comp_injective e.injectiveâŸ©\n#align equiv.locally_finite_comp_iff Equiv.locallyFinite_comp_iff\n-/\n\n",
 "isClosed_unionáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n#print isClosed_unionáµ¢ /-\ntheorem isClosed_unionáµ¢ (hf : LocallyFinite f) (hc : âˆ€ i, IsClosed (f i)) :\n    IsClosed (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) :=\n  by simp only [â† closure_eq_iff_isClosed, hf.closure_Union, (hc _).closure_eq]\n#align is_closed_Union isClosed_unionáµ¢\n-/\n\n",
 "exists_mem_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_mem_basis {Î¹' : Sort _} (hf : LocallyFinite f) {p : Î¹' â†’ Prop} {s : Î¹' â†’ Set X} {x : X}\n    (hb : ((nhds) x).has_basis p s) : âˆƒ (i : _)(hi : p i), { j | (f j âˆ© s i).nonempty }.finite :=\n  let âŸ¨i, hpi, hiâŸ© := hb.small_sets.eventually_iff.mp (hf.eventually_small_sets x)\n  âŸ¨i, hpi, hi Subset.rflâŸ©\n#align exists_mem_basis exists_mem_basis\n\n",
 "exists_forall_eventually_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Let `f : â„• â†’ Î  a, Î² a` be a sequence of (dependent) functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\nfunction `F : Î  a, Î² a` such that for any `x`, we have `f n x = F x` on the product of an infinite\ninterval `[N, +âˆž)` and a neighbourhood of `x`.\n\nWe formulate the conclusion in terms of the product of filter `filter.at_top` and `ð“ x`. -/\ntheorem exists_forall_eventually_eq_prod {Ï€ : X â†’ Sort _} {f : â„• â†’ âˆ€ x : X, Ï€ x}\n    (hf : LocallyFinite fun n => { x | f (n + 1) x â‰  f n x }) :\n    âˆƒ F : âˆ€ x : X, Ï€ x,\n      âˆ€ x,\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n          (filter.prod atTop ((nhds) x)) (f p.1 p.2 = F p.2) :=\n  by\n  choose U hUx hU using hf\n  choose N hN using fun x => (hU x).bdd_above\n  replace hN : âˆ€ (x), âˆ€ n > N x, âˆ€ y âˆˆ U x, f (n + 1) y = f n y\n  exact fun x n hn y hy => by_contra fun hne => hn.lt.not_le <| hN x âŸ¨y, hne, hyâŸ©\n  replace hN : âˆ€ (x), âˆ€ n â‰¥ N x + 1, âˆ€ y âˆˆ U x, f n y = f (N x + 1) y\n  exact fun x n hn y hy => Nat.le_induction rfl (fun k hle => (hN x _ hle _ hy).trans) n hn\n  refine' âŸ¨fun x => f (N x + 1) x, fun x => _âŸ©\n  filter_upwards [Filter.prod_mem_prod (eventually_gt_at_top (N x)) (hUx x)]\n  rintro âŸ¨n, yâŸ© âŸ¨hn : N x < n, hy : y âˆˆ U xâŸ©\n  calc\n    f n y = f (N x + 1) y := hN _ _ hn _ hy\n    _ = f (max (N x + 1) (N y + 1)) y := (hN _ _ (le_max_left _ _) _ hy).symm\n    _ = f (N y + 1) y := hN _ _ (le_max_right _ _) _ (mem_of_mem_nhds <| hUx y)\n    \n#align exists_forall_eventually_eq_prod exists_forall_eventually_eq_prod\n\n",
 "exists_forall_eventually_at_top_eventually_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Let `f : â„• â†’ Î  a, Î² a` be a sequence of (dependent) functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\nfunction `F : Î  a, Î² a` such that for any `x`, for sufficiently large values of `n`, we have\n`f n y = F y` in a neighbourhood of `x`. -/\ntheorem exists_forall_eventually_at_top_eventually_eq' {Ï€ : X â†’ Sort _} {f : â„• â†’ âˆ€ x : X, Ï€ x}\n    (hf : LocallyFinite fun n => { x | f (n + 1) x â‰  f n x }) :\n    âˆƒ F : âˆ€ x : X, Ï€ x,\n      âˆ€ x,\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" atTop\n          (Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n            ((nhds) x) (f n y = F y)) :=\n  hf.exists_forall_eventually_eq_prod.imp fun F hF x => (hF x).curry\n#align exists_forall_eventually_at_top_eventually_eq' exists_forall_eventually_at_top_eventually_eq'\n\n",
 "exists_forall_eventually_at_top_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Let `f : â„• â†’ Î± â†’ Î²` be a sequence of functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\nfunction `F :  Î± â†’ Î²` such that for any `x`, for sufficiently large values of `n`, we have\n`f n =á¶ [ð“ x] F`. -/\ntheorem exists_forall_eventually_at_top_eventually_eq {f : â„• â†’ X â†’ Î±}\n    (hf : LocallyFinite fun n => { x | f (n + 1) x â‰  f n x }) :\n    âˆƒ F : X â†’ Î±,\n      âˆ€ x,\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" atTop\n          (Â«expr =á¶ [ ] Â» (f n) ((nhds) x) F) :=\n  hf.exists_forall_eventually_at_top_eventually_eq'\n#align exists_forall_eventually_at_top_eventually_eq exists_forall_eventually_at_top_eventually_eq\n\n",
 "eventually_small_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\nprotected theorem eventually_small_sets (hf : LocallyFinite f) (x : X) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      ((nhds) x).small_sets { i | (f i âˆ© s).nonempty }.finite :=\n  locallyFinite_iff_smallSets.mp hf x\n#align eventually_small_sets eventually_small_sets\n\n",
 "continuous_on_Union'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem continuous_on_Union' {g : X â†’ Y} (hf : LocallyFinite f)\n    (hc : âˆ€ i x, x âˆˆ closure (f i) â†’ ContinuousWithinAt g (f i) x) :\n    ContinuousOn g\n      (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) :=\n  by\n  rintro x -\n  rw [ContinuousWithinAt, hf.nhds_within_Union, tendsto_supr]\n  intro i\n  by_cases hx : x âˆˆ closure (f i)\n  Â· exact hc i _ hx\n  Â· rw [mem_closure_iff_nhdsWithin_neBot, not_ne_bot] at hx\n    rw [hx]\n    exact tendsto_bot\n#align continuous_on_Union' continuous_on_Union'\n\n",
 "continuous_on_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem continuous_on_Union {g : X â†’ Y} (hf : LocallyFinite f) (h_cl : âˆ€ i, IsClosed (f i))\n    (h_cont : âˆ€ i, ContinuousOn g (f i)) :\n    ContinuousOn g\n      (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) :=\n  hf.continuous_on_Union' fun i x hx => h_cont i x <| (h_cl i).closure_subset hx\n#align continuous_on_Union continuous_on_Union\n\n",
 "continuous'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\nprotected theorem continuous' {g : X â†’ Y} (hf : LocallyFinite f)\n    (h_cov :\n      Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i) = univ)\n    (hc : âˆ€ i x, x âˆˆ closure (f i) â†’ ContinuousWithinAt g (f i) x) : Continuous g :=\n  continuous_iff_continuousOn_univ.2 <| h_cov â–¸ hf.continuous_on_Union' hc\n#align continuous' continuous'\n\n",
 "comp_injective":
 "theorem comp_injective {g : Î¹' â†’ Î¹} (hf : LocallyFinite f) (hg : injective g) : LocallyFinite (f âˆ˜ g) :=\n  hf.comp_inj_on (hg.inj_on _)\n#align comp_injective comp_injective\n\n",
 "comp_inj_on":
 "theorem comp_inj_on {g : Î¹' â†’ Î¹} (hf : LocallyFinite f) (hg : InjOn g { i | (f (g i)).nonempty }) :\n    LocallyFinite (f âˆ˜ g) := fun x =>\n  let âŸ¨t, htx, htfâŸ© := hf x\n  âŸ¨t, htx, htf.preimage <| hg.mono fun i hi => hi.out.mono <| inter_subset_left _ _âŸ©\n#align comp_inj_on comp_inj_on\n\n",
 "closure_unionáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n#print closure_unionáµ¢ /-\ntheorem closure_unionáµ¢ (h : LocallyFinite f) :\n    closure (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) =\n      Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (closure (f i)) :=\n  by\n  ext x\n  simp only [mem_closure_iff_nhdsWithin_neBot, h.nhds_within_Union, supr_ne_bot, mem_Union]\n#align closure_Union closure_unionáµ¢\n-/\n\n",
 "closure":
 "#print closure /-\nprotected theorem closure (hf : LocallyFinite f) : LocallyFinite fun i => closure (f i) :=\n  by\n  intro x\n  rcases hf x with âŸ¨s, hsx, hsfâŸ©\n  refine' âŸ¨interior s, interior_mem_nhds.2 hsx, hsf.subset fun i hi => _âŸ©\n  exact (hi.mono is_open_interior.closure_inter).of_closure.mono (inter_subset_inter_right _ interior_subset)\n#align closure closure\n-/\n\n",
 "Inter_compl_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f : Î² â†’ set Î±` is a locally finite family of closed sets, then for any `x : Î±`, the\nintersection of the complements to `f i`, `x âˆ‰ f i`, is a neighbourhood of `x`. -/\ntheorem Inter_compl_mem_nhds (hf : LocallyFinite f) (hc : âˆ€ i, IsClosed (f i)) (x : X) :\n    Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (Â«expr á¶œÂ» (f i)) âˆˆ\n      (nhds) x :=\n  by\n  refine' IsOpen.mem_nhds _ (mem_Interâ‚‚.2 fun i => id)\n  suffices\n    IsClosed (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) by\n    rwa [â† isOpen_compl_iff, compl_Union, Inter_subtype] at this\n  exact (hf.comp_injective Subtype.coe_injective).is_closed_Union fun i => hc _\n#align Inter_compl_mem_nhds Inter_compl_mem_nhds\n\n",
 "Continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n#print Continuous /-\nprotected theorem Continuous {g : X â†’ Y} (hf : LocallyFinite f)\n    (h_cov :\n      Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i) = univ)\n    (h_cl : âˆ€ i, IsClosed (f i)) (h_cont : âˆ€ i, ContinuousOn g (f i)) : Continuous g :=\n  continuous_iff_continuousOn_univ.2 <| h_cov â–¸ hf.continuous_on_Union h_cl h_cont\n#align continuous Continuous\n-/\n\n"}