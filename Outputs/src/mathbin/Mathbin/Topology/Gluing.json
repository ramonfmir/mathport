{"π_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/-\nCopyright (c) 2021 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem π_surjective : function.surjective («expr𝖣»).π :=\n  (TopCat.epi_iff_surjective («expr𝖣»).π).mp inferInstance\n#align π_surjective π_surjective\n\n",
 "ι_open_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\ntheorem ι_open_embedding (i : D.J) : OpenEmbedding ((«expr𝖣»).ι i) :=\n  openEmbedding_of_continuous_injective_open ((«expr𝖣»).ι i).continuous_to_fun (D.ι_injective i) fun U h =>\n    D.open_image_open i ⟨U, h⟩\n#align ι_open_embedding ι_open_embedding\n\n",
 "ι_jointly_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\ntheorem ι_jointly_surjective (x : («expr𝖣»).glued) : ∃ (i : _)(y : D.U i), («expr𝖣»).ι i y = x :=\n  («expr𝖣»).ι_jointly_surjective (forget TopCat) x\n#align ι_jointly_surjective ι_jointly_surjective\n\n",
 "ι_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\ntheorem ι_injective (i : D.J) : function.injective ((«expr𝖣»).ι i) :=\n  by\n  intro x y h\n  rcases(D.ι_eq_iff_rel _ _ _ _).mp h with (⟨⟨⟩⟩ | ⟨_, e₁, e₂⟩)\n  · rfl\n  · dsimp only at *\n    cases e₁\n    cases e₂\n    simp\n#align ι_injective ι_injective\n\n",
 "ι_from_open_subsets_glue":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, elementwise]\ntheorem ι_from_open_subsets_glue (i : J) :\n    «expr ≫ » ((of_open_subsets U).to_glue_data.ι i) (from_open_subsets_glue U) = Opens.inclusion _ :=\n  Multicoequalizer.π_desc _ _ _ _ _\n#align ι_from_open_subsets_glue ι_from_open_subsets_glue\n\n",
 "ι_eq_iff_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\ntheorem ι_eq_iff_rel (i j : D.J) (x : D.U i) (y : D.U j) : («expr𝖣»).ι i x = («expr𝖣»).ι j y ↔ D.rel ⟨i, x⟩ ⟨j, y⟩ :=\n  by\n  constructor\n  · delta glue_data.ι\n    simp_rw [← multicoequalizer.ι_sigma_π]\n    intro h\n    rw [← show _ = sigma.mk i x from concrete_category.congr_hom (sigmaIsoSigma.{u} D.U).inv_hom_id _]\n    rw [← show _ = sigma.mk j y from concrete_category.congr_hom (sigmaIsoSigma.{u} D.U).inv_hom_id _]\n    change inv_image D.rel (sigmaIsoSigma.{u} D.U).hom _ _\n    simp only [TopCat.sigmaIsoSigma_inv_apply]\n    rw [← (InvImage.equivalence _ _ D.rel_equiv).eqv_gen_iff]\n    refine' EqvGen.mono _ (D.eqv_gen_of_π_eq h : _)\n    rintro _ _ ⟨x⟩\n    rw [← show (sigmaIsoSigma.{u} _).inv _ = x from concrete_category.congr_hom (sigmaIsoSigma.{u} _).hom_inv_id x]\n    generalize (sigmaIsoSigma.{u} D.V).hom x = x'\n    obtain ⟨⟨i, j⟩, y⟩ := x'\n    unfold inv_image multispan_index.fst_sigma_map multispan_index.snd_sigma_map\n    simp only [opens.inclusion_apply, TopCat.comp_app, sigma_iso_sigma_inv_apply,\n      category_theory.limits.colimit.ι_desc_apply, cofan.mk_ι_app, sigma_iso_sigma_hom_ι_apply,\n      ContinuousMap.toFun_eq_coe]\n    erw [sigma_iso_sigma_hom_ι_apply, sigma_iso_sigma_hom_ι_apply]\n    exact\n      or.inr\n        ⟨y, by\n          dsimp [glue_data.diagram]\n          simp⟩\n  · rintro (⟨⟨⟩⟩ | ⟨z, e₁, e₂⟩)\n    rfl\n    dsimp only at *\n    subst e₁\n    subst e₂\n    simp\n#align ι_eq_iff_rel ι_eq_iff_rel\n\n",
 "t_inv":
 "theorem mk_core.t_inv (h : mk_core) (i j : h.J) (x : h.V j i) : h.t i j ((h.t j i) x) = x :=\n  by\n  have := h.cocycle j i j x _\n  rw [h.t_id] at this\n  convert Subtype.eq this\n  · ext\n    rfl\n  all_goals rw [h.V_id]; trivial\n#align mk_core.t_inv mk_core.t_inv\n\n",
 "rel_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\ntheorem rel_equiv : equivalence D.rel :=\n  ⟨fun x => or.inl (refl x), by\n    rintro a b (⟨⟨⟩⟩ | ⟨x, e₁, e₂⟩)\n    exacts[or.inl rfl, or.inr ⟨D.t _ _ x, by simp [e₁, e₂]⟩],\n    by\n    rintro ⟨i, a⟩ ⟨j, b⟩ ⟨k, c⟩ (⟨⟨⟩⟩ | ⟨x, e₁, e₂⟩)\n    exact id\n    rintro (⟨⟨⟩⟩ | ⟨y, e₃, e₄⟩)\n    exact or.inr ⟨x, e₁, e₂⟩\n    let z := (pullback_iso_prod_subtype (D.f j i) (D.f j k)).inv ⟨⟨_, _⟩, e₂.trans e₃.symm⟩\n    have eq₁ : (D.t j i) ((pullback.fst : «expr ⟶ » _ (D.V _)) z) = x := by simp\n    have eq₂ : (pullback.snd : «expr ⟶ » _ (D.V _)) z = y := pullback_iso_prod_subtype_inv_snd_apply _ _ _\n    clear_value z\n    right\n    use (pullback.fst : «expr ⟶ » _ (D.V (i, k))) (D.t' _ _ _ z)\n    dsimp only at *\n    substs e₁ e₃ e₄ eq₁ eq₂\n    have h₁ :\n      «expr ≫ » (D.t' j i k) («expr ≫ » pullback.fst (D.f i k)) =\n        «expr ≫ » pullback.fst («expr ≫ » (D.t j i) (D.f i j)) :=\n      by\n      rw [← («expr𝖣»).t_fac_assoc]\n      congr 1\n      exact pullback.condition\n    have h₂ :\n      «expr ≫ » (D.t' j i k) («expr ≫ » pullback.fst («expr ≫ » (D.t i k) (D.f k i))) =\n        «expr ≫ » pullback.snd («expr ≫ » (D.t j k) (D.f k j)) :=\n      by\n      rw [← («expr𝖣»).t_fac_assoc]\n      apply @epi.left_cancellation _ _ _ _ (D.t' k j i)\n      rw [(«expr𝖣»).cocycle_assoc, («expr𝖣»).t_fac_assoc, («expr𝖣»).t_inv_assoc]\n      exact pullback.condition.symm\n    exact ⟨ContinuousMap.congr_fun h₁ z, ContinuousMap.congr_fun h₂ z⟩⟩\n#align rel_equiv rel_equiv\n\n",
 "range_from_open_subsets_glue":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem range_from_open_subsets_glue :\n    Set.range (from_open_subsets_glue U) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i : Set α) :=\n  by\n  ext\n  constructor\n  · rintro ⟨x, rfl⟩\n    obtain ⟨i, ⟨x, hx'⟩, rfl⟩ := (of_open_subsets U).ι_jointly_surjective x\n    rw [ι_from_open_subsets_glue_apply]\n    exact Set.subset_unionᵢ _ i hx'\n  · rintro ⟨_, ⟨i, rfl⟩, hx⟩\n    refine' ⟨(of_open_subsets U).to_glue_data.ι i ⟨x, hx⟩, ι_from_open_subsets_glue_apply _ _ _⟩\n#align range_from_open_subsets_glue range_from_open_subsets_glue\n\n",
 "preimage_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\ntheorem preimage_range (i j : D.J) : «expr ⁻¹' » ((«expr𝖣»).ι j) (Set.range ((«expr𝖣»).ι i)) = Set.range (D.f j i) := by\n  rw [← Set.preimage_image_eq (Set.range (D.f j i)) (D.ι_injective j), ← Set.image_univ, ← Set.image_univ, ←\n    Set.image_comp, ← coe_comp, Set.image_univ, Set.image_univ, ← image_inter, Set.preimage_range_inter]\n#align preimage_range preimage_range\n\n",
 "preimage_image_eq_image'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_image_eq_image' (i j : D.J) (U : Set ((«expr𝖣»).U i)) :\n    «expr ⁻¹' » ((«expr𝖣»).ι j) («expr '' » ((«expr𝖣»).ι i) U) =\n      «expr '' » («expr ≫ » (D.t i j) (D.f _ _)) («expr ⁻¹' » (D.f _ _) U) :=\n  by\n  convert D.preimage_image_eq_image i j U using 1\n  rw [coe_comp, coe_comp, ← Set.image_image]\n  congr 1\n  rw [← Set.eq_preimage_iff_image_eq, Set.preimage_preimage]\n  change _ = «expr ⁻¹' » («expr ≫ » (D.t i j) («expr ≫ » (D.t j i) _)) _\n  rw [(«expr𝖣»).t_inv_assoc]\n  rw [← is_iso_iff_bijective]\n  apply (forget TopCat).map_is_iso\n#align preimage_image_eq_image' preimage_image_eq_image'\n\n",
 "preimage_image_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem preimage_image_eq_image (i j : D.J) (U : Set ((«expr𝖣»).U i)) :\n    «expr ⁻¹' » ((«expr𝖣»).ι j) («expr '' » ((«expr𝖣»).ι i) U) =\n      «expr '' » (D.f _ _) («expr ⁻¹' » («expr ≫ » (D.t j i) (D.f _ _)) U) :=\n  by\n  have :\n    «expr ⁻¹' » (D.f _ _) («expr ⁻¹' » ((«expr𝖣»).ι j) («expr '' » ((«expr𝖣»).ι i) U)) =\n      «expr ⁻¹' » («expr ≫ » (D.t j i) (D.f _ _)) U :=\n    by\n    ext x\n    conv_rhs => rw [← Set.preimage_image_eq U (D.ι_injective _)]\n    generalize «expr '' » ((«expr𝖣»).ι i) U = U'\n    simp\n  rw [← this, Set.image_preimage_eq_inter_range]\n  symm\n  apply Set.inter_eq_self_of_subset_left\n  rw [← D.preimage_range i j]\n  exact Set.preimage_mono (Set.image_subset_range _ _)\n#align preimage_image_eq_image preimage_image_eq_image\n\n",
 "open_image_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\ntheorem open_image_open (i : D.J) (U : Opens ((«expr𝖣»).U i)) : IsOpen («expr '' » ((«expr𝖣»).ι i) U) :=\n  by\n  rw [is_open_iff]\n  intro j\n  rw [preimage_image_eq_image]\n  apply (D.f_open _ _).is_open_map\n  apply («expr ≫ » (D.t j i) (D.f i j)).continuous_to_fun.is_open_preimage\n  exact U.is_open\n#align open_image_open open_image_open\n\n",
 "is_open_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\ntheorem is_open_iff (U : Set («expr𝖣»).glued) : IsOpen U ↔ ∀ i, IsOpen («expr ⁻¹' » ((«expr𝖣»).ι i) U) :=\n  by\n  delta CategoryTheory.GlueData.ι\n  simp_rw [← multicoequalizer.ι_sigma_π («expr𝖣»).diagram]\n  rw [← (homeo_of_iso (multicoequalizer.iso_coequalizer («expr𝖣»).diagram).symm).is_open_preimage]\n  rw [coequalizer_is_open_iff, colimit_isOpen_iff.{u}]\n  constructor\n  · intro h j\n    exact h ⟨j⟩\n  · intro h j\n    cases j\n    exact h j\n#align is_open_iff is_open_iff\n\n",
 "image_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\ntheorem image_inter (i j : D.J) :\n    Set.range ((«expr𝖣»).ι i) ∩ Set.range ((«expr𝖣»).ι j) = Set.range («expr ≫ » (D.f i j) ((«expr𝖣»).ι _)) :=\n  by\n  ext x\n  constructor\n  · rintro ⟨⟨x₁, eq₁⟩, ⟨x₂, eq₂⟩⟩\n    obtain ⟨⟨⟩⟩ | ⟨y, e₁, e₂⟩ := (D.ι_eq_iff_rel _ _ _ _).mp (eq₁.trans eq₂.symm)\n    · exact ⟨inv (D.f i i) x₁, by simp [eq₁]⟩\n    · dsimp only at *\n      substs e₁ eq₁\n      exact ⟨y, by simp⟩\n  · rintro ⟨x, hx⟩\n    exact ⟨⟨D.f i j x, hx⟩, ⟨D.f j i (D.t _ _ x), by simp [← hx]⟩⟩\n#align image_inter image_inter\n\n",
 "from_open_subsets_glue_open_embedding":
 "theorem from_open_subsets_glue_open_embedding : OpenEmbedding (from_open_subsets_glue U) :=\n  openEmbedding_of_continuous_injective_open (continuous_map.continuous_to_fun _) (from_open_subsets_glue_injective U)\n    (from_open_subsets_glue_is_open_map U)\n#align from_open_subsets_glue_open_embedding from_open_subsets_glue_open_embedding\n\n",
 "from_open_subsets_glue_is_open_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem from_open_subsets_glue_is_open_map : IsOpenMap (from_open_subsets_glue U) :=\n  by\n  intro s hs\n  rw [(of_open_subsets U).is_open_iff] at hs\n  rw [isOpen_iff_forall_mem_open]\n  rintro _ ⟨x, hx, rfl⟩\n  obtain ⟨i, ⟨x, hx'⟩, rfl⟩ := (of_open_subsets U).ι_jointly_surjective x\n  use «expr '' » (from_open_subsets_glue U) s ∩ Set.range (@opens.inclusion (TopCat.of α) (U i))\n  use Set.inter_subset_left _ _\n  constructor\n  · erw [← Set.image_preimage_eq_inter_range]\n    apply (@opens.open_embedding (TopCat.of α) (U i)).is_open_map\n    convert hs i using 1\n    rw [← ι_from_open_subsets_glue, coe_comp, Set.preimage_comp]\n    congr 1\n    refine' Set.preimage_image_eq _ (from_open_subsets_glue_injective U)\n  · refine' ⟨Set.mem_image_of_mem _ hx, _⟩\n    rw [ι_from_open_subsets_glue_apply]\n    exact Set.mem_range_self _\n#align from_open_subsets_glue_is_open_map from_open_subsets_glue_is_open_map\n\n",
 "from_open_subsets_glue_injective":
 "theorem from_open_subsets_glue_injective : function.injective (from_open_subsets_glue U) :=\n  by\n  intro x y e\n  obtain ⟨i, ⟨x, hx⟩, rfl⟩ := (of_open_subsets U).ι_jointly_surjective x\n  obtain ⟨j, ⟨y, hy⟩, rfl⟩ := (of_open_subsets U).ι_jointly_surjective y\n  rw [ι_from_open_subsets_glue_apply, ι_from_open_subsets_glue_apply] at e\n  change x = y at e\n  subst e\n  rw [(of_open_subsets U).ι_eq_iff_rel]\n  right\n  exact ⟨⟨⟨x, hx⟩, hy⟩, rfl, rfl⟩\n#align from_open_subsets_glue_injective from_open_subsets_glue_injective\n\n",
 "eqv_gen_of_π_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝖣» -/\ntheorem eqv_gen_of_π_eq {x y : «expr∐ » D.U} (h : («expr𝖣»).π x = («expr𝖣»).π y) :\n    EqvGen (Types.CoequalizerRel («expr𝖣»).diagram.fst_sigma_map («expr𝖣»).diagram.snd_sigma_map) x y :=\n  by\n  delta glue_data.π multicoequalizer.sigma_π at h\n  simp_rw [comp_app] at h\n  replace h := (TopCat.mono_iff_injective (multicoequalizer.iso_coequalizer («expr𝖣»).diagram).inv).mp _ h\n  let diagram := «expr ⋙ » (parallel_pair («expr𝖣»).diagram.fst_sigma_map («expr𝖣»).diagram.snd_sigma_map) (forget _)\n  have : colimit.ι diagram one x = colimit.ι diagram one y :=\n    by\n    rw [← ι_preserves_colimits_iso_hom]\n    simp [h]\n  have :\n    («expr ≫ » (colimit.ι diagram _) («expr ≫ » (colim.map _) (colimit.iso_colimit_cocone _).hom)) _ =\n      («expr ≫ » (colimit.ι diagram _) («expr ≫ » (colim.map _) (colimit.iso_colimit_cocone _).hom)) _ :=\n    (congr_arg\n        («expr ≫ » (colim.map (diagram_iso_parallel_pair diagram).hom)\n          (colimit.iso_colimit_cocone (types.coequalizer_colimit _ _)).hom)\n        this :\n      _)\n  simp only [eq_to_hom_refl, types_comp_apply, colimit.ι_map_assoc, diagram_iso_parallel_pair_hom_app,\n    colimit.iso_colimit_cocone_ι_hom, types_id_apply] at this\n  exact Quot.eq.1 this\n  infer_instance\n#align eqv_gen_of_π_eq eqv_gen_of_π_eq\n\n"}