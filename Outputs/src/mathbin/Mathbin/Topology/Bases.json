{"union":
 "theorem is_separable.union {s u : Set α} (hs : IsSeparable s) (hu : IsSeparable u) : IsSeparable (s ∪ u) :=\n  by\n  rcases hs with ⟨cs, cs_count, hcs⟩\n  rcases hu with ⟨cu, cu_count, hcu⟩\n  refine' ⟨cs ∪ cu, cs_count.union cu_count, _⟩\n  exact\n    union_subset (hcs.trans (closure_mono (subset_union_left _ _))) (hcu.trans (closure_mono (subset_union_right _ _)))\n#align is_separable.union is_separable.union\n\n",
 "tendsto_subseq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- In a first-countable space, a cluster point `x` of a sequence\nis the limit of some subsequence. -/\ntheorem tendsto_subseq [FirstCountableTopology α] {u : ℕ → α} {x : α} (hx : MapClusterPt x atTop u) :\n    ∃ ψ : ℕ → ℕ, StrictMono ψ ∧ Tendsto (u ∘ ψ) atTop ((nhds) x) :=\n  subseq_tendsto_of_neBot hx\n#align tendsto_subseq tendsto_subseq\n\n",
 "sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- In a sum space `α ⊕ β`, one can form a topological basis by taking the union of\ntopological bases on each of the two components. -/\ntheorem is_topological_basis.sum {s : Set (Set α)} (hs : IsTopologicalBasis s) {t : Set (Set β)}\n    (ht : IsTopologicalBasis t) :\n    IsTopologicalBasis («expr '' » (fun u => «expr '' » Sum.inl u) s ∪ «expr '' » (fun u => «expr '' » Sum.inr u) t) :=\n  by\n  apply is_topological_basis_of_open_of_nhds\n  · intro u hu\n    cases hu\n    · rcases hu with ⟨w, hw, rfl⟩\n      exact open_embedding_inl.is_open_map w (hs.is_open hw)\n    · rcases hu with ⟨w, hw, rfl⟩\n      exact open_embedding_inr.is_open_map w (ht.is_open hw)\n  · rintro x u hxu u_open\n    cases x\n    · have h'x : x ∈ «expr ⁻¹' » Sum.inl u := hxu\n      obtain ⟨v, vs, xv, vu⟩ : ∃ (v : Set α)(H : v ∈ s), x ∈ v ∧ v ⊆ «expr ⁻¹' » Sum.inl u :=\n        hs.exists_subset_of_mem_open h'x (isOpen_sum_iff.1 u_open).1\n      exact\n        ⟨«expr '' » Sum.inl v, mem_union_left _ (mem_image_of_mem _ vs), mem_image_of_mem _ xv, image_subset_iff.2 vu⟩\n    · have h'x : x ∈ «expr ⁻¹' » Sum.inr u := hxu\n      obtain ⟨v, vs, xv, vu⟩ : ∃ (v : Set β)(H : v ∈ t), x ∈ v ∧ v ⊆ «expr ⁻¹' » Sum.inr u :=\n        ht.exists_subset_of_mem_open h'x (isOpen_sum_iff.1 u_open).2\n      exact\n        ⟨«expr '' » Sum.inr v, mem_union_right _ (mem_image_of_mem _ vs), mem_image_of_mem _ xv, image_subset_iff.2 vu⟩\n#align is_topological_basis.sum is_topological_basis.sum\n\n",
 "sigma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- In a disjoint union space `Σ i, E i`, one can form a topological basis by taking the union of\ntopological bases on each of the parts of the space. -/\ntheorem is_topological_basis.sigma {s : ∀ i : ι, Set (Set (E i))} (hs : ∀ i, IsTopologicalBasis (s i)) :\n    IsTopologicalBasis\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr '' » (fun u => («expr '' » (sigma.mk i) u : Set (Σi, E i))) (s i))) :=\n  by\n  apply is_topological_basis_of_open_of_nhds\n  · intro u hu\n    obtain ⟨i, t, ts, rfl⟩ : ∃ (i : ι)(t : Set (E i)), t ∈ s i ∧ «expr '' » (sigma.mk i) t = u := by\n      simpa only [mem_Union, mem_image] using hu\n    exact isOpenMap_sigmaMk _ ((hs i).is_open ts)\n  · rintro ⟨i, x⟩ u hxu u_open\n    have hx : x ∈ «expr ⁻¹' » (sigma.mk i) u := hxu\n    obtain ⟨v, vs, xv, hv⟩ : ∃ (v : Set (E i))(H : v ∈ s i), x ∈ v ∧ v ⊆ «expr ⁻¹' » (sigma.mk i) u :=\n      (hs i).exists_subset_of_mem_open hx (isOpen_sigma_iff.1 u_open i)\n    exact\n      ⟨«expr '' » (sigma.mk i) v, mem_Union.2 ⟨i, mem_image_of_mem _ vs⟩, mem_image_of_mem _ xv, image_subset_iff.2 hv⟩\n#align is_topological_basis.sigma is_topological_basis.sigma\n\n",
 "separable_space_of_dense_range":
 "theorem separable_space_of_dense_range {ι : Type _} [Countable ι] (u : ι → α) (hu : DenseRange u) : SeparableSpace α :=\n  ⟨⟨range u, countable_range u, hu⟩⟩\n#align separable_space_of_dense_range separable_space_of_dense_range\n\n",
 "separableSpace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print DenseRange.separableSpace /-\n/-- If `α` is a separable space and `f : α → β` is a continuous map with dense range, then `β` is\na separable space as well. E.g., the completion of a separable uniform space is separable. -/\nprotected theorem DenseRange.separableSpace {α β : Type _} [TopologicalSpace α] [SeparableSpace α] [TopologicalSpace β]\n    {f : α → β} (h : DenseRange f) (h' : Continuous f) : SeparableSpace β :=\n  let ⟨s, s_cnt, s_dense⟩ := exists_countable_dense α\n  ⟨⟨«expr '' » f s, Countable.image s_cnt f, h.dense_image h' s_dense⟩⟩\n#align dense_range.separable_space DenseRange.separableSpace\n-/\n\n",
 "second_countable_topology_of_countable_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n-- TODO: more fine grained instances for first_countable_topology, separable_space, t2_space, ... \n-- see Note [lower instance priority]\n/-- A countable open cover induces a second-countable topology if all open covers\nare themselves second countable. -/\ntheorem second_countable_topology_of_countable_cover {ι} [Encodable ι] {U : ι → Set α}\n    [∀ i, SecondCountableTopology (U i)] (Uo : ∀ i, IsOpen (U i))\n    (hc :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i) = univ) :\n    SecondCountableTopology α :=\n  haveI :\n    is_topological_basis\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr '' » (image (coe : U i → α)) (countable_basis (U i)))) :=\n    is_topological_basis_of_cover Uo hc fun i => is_basis_countable_basis (U i)\n  this.second_countable_topology (countable_Union fun i => (countable_countable_basis _).image _)\n#align second_countable_topology_of_countable_cover second_countable_topology_of_countable_cover\n\n",
 "second_countable_topology_induced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n-- see Note [lower instance priority]\n/-- If `β` is a second-countable space, then its induced topology\nvia `f` on `α` is also second-countable. -/\ntheorem second_countable_topology_induced (β) [t : TopologicalSpace β] [SecondCountableTopology β] (f : α → β) :\n    @SecondCountableTopology α (t.induced f) :=\n  by\n  rcases second_countable_topology.is_open_generated_countable β with ⟨b, hb, eq⟩\n  refine' { is_open_generated_countable := ⟨«expr '' » (preimage f) b, hb.image _, _⟩ }\n  rw [Eq, induced_generateFrom_eq]\n#align second_countable_topology_induced second_countable_topology_induced\n\n",
 "second_countable_topology":
 "/-- An open quotient of a second countable space is second countable. -/\ntheorem quotient.second_countable_topology [SecondCountableTopology X] (h : IsOpenMap (Quotient.mk' : X → quotient S)) :\n    SecondCountableTopology (quotient S) :=\n  quotientMap_quotient_mk'.second_countable_topology h\n#align quotient.second_countable_topology quotient.second_countable_topology\n\n",
 "secondCountableTopology":
 "#print Embedding.secondCountableTopology /-\nprotected theorem Embedding.secondCountableTopology [SecondCountableTopology β] (hf : Embedding f) :\n    SecondCountableTopology α :=\n  hf.1.second_countable_topology\n#align embedding.second_countable_topology Embedding.secondCountableTopology\n-/\n\n",
 "quotient_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem is_topological_basis.quotient_map {V : Set (Set X)} (hV : IsTopologicalBasis V) (h' : QuotientMap π)\n    (h : IsOpenMap π) : IsTopologicalBasis («expr '' » (Set.image π) V) :=\n  by\n  apply is_topological_basis_of_open_of_nhds\n  · rintro - ⟨U, U_in_V, rfl⟩\n    apply h U (hV.is_open U_in_V)\n  · intro y U y_in_U U_open\n    obtain ⟨x, rfl⟩ := h'.surjective y\n    let W := «expr ⁻¹' » π U\n    have x_in_W : x ∈ W := y_in_U\n    have W_open : IsOpen W := U_open.preimage h'.continuous\n    obtain ⟨Z, Z_in_V, x_in_Z, Z_in_W⟩ := hV.exists_subset_of_mem_open x_in_W W_open\n    have πZ_in_U : «expr '' » π Z ⊆ U := (Set.image_subset _ Z_in_W).trans (image_preimage_subset π U)\n    exact ⟨«expr '' » π Z, ⟨Z, Z_in_V, rfl⟩, ⟨x, x_in_Z, rfl⟩, πZ_in_U⟩\n#align is_topological_basis.quotient_map is_topological_basis.quotient_map\n\n",
 "quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem is_topological_basis.quotient {V : Set (Set X)} (hV : IsTopologicalBasis V)\n    (h : IsOpenMap (Quotient.mk' : X → quotient S)) :\n    IsTopologicalBasis («expr '' » (Set.image (Quotient.mk' : X → quotient S)) V) :=\n  hV.quotient_map quotientMap_quotient_mk' h\n#align is_topological_basis.quotient is_topological_basis.quotient\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:228:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `finset.product -/\nprotected theorem is_topological_basis.prod {β} [TopologicalSpace β] {B₁ : Set (Set α)} {B₂ : Set (Set β)}\n    (h₁ : IsTopologicalBasis B₁) (h₂ : IsTopologicalBasis B₂) :\n    IsTopologicalBasis (image2 (finset.product · ·) B₁ B₂) :=\n  by\n  refine' is_topological_basis_of_open_of_nhds _ _\n  · rintro _ ⟨u₁, u₂, hu₁, hu₂, rfl⟩\n    exact (h₁.is_open hu₁).prod (h₂.is_open hu₂)\n  · rintro ⟨a, b⟩ u hu uo\n    rcases(h₁.nhds_has_basis.prod_nhds h₂.nhds_has_basis).mem_iff.1 (IsOpen.mem_nhds uo hu) with\n      ⟨⟨s, t⟩, ⟨⟨hs, ha⟩, ht, hb⟩, hu⟩\n    exact ⟨finset.product s t, mem_image2_of_mem hs ht, ⟨ha, hb⟩, hu⟩\n#align is_topological_basis.prod is_topological_basis.prod\n\n",
 "open_iff_eq_sUnion":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (S «expr ⊆ » B) -/\ntheorem is_topological_basis.open_iff_eq_sUnion {B : Set (Set α)} (hB : IsTopologicalBasis B) {u : Set α} :\n    IsOpen u ↔ ∃ (S : _)(_ : S ⊆ B), u = ⋃₀ S :=\n  ⟨hB.open_eq_sUnion, fun ⟨S, hSB, hu⟩ => hu.symm ▸ isOpen_unionₛ fun s hs => hB.is_open (hSB hs)⟩\n#align is_topological_basis.open_iff_eq_sUnion is_topological_basis.open_iff_eq_sUnion\n\n",
 "open_eq_sUnion'":
 "/-- Any open set is the union of the basis sets contained in it. -/\ntheorem is_topological_basis.open_eq_sUnion' {B : Set (Set α)} (hB : IsTopologicalBasis B) {u : Set α} (ou : IsOpen u) :\n    u = ⋃₀ { s ∈ B | s ⊆ u } :=\n  ext fun a =>\n    ⟨fun ha =>\n      let ⟨b, hb, ab, bu⟩ := hB.exists_subset_of_mem_open ha ou\n      ⟨b, ⟨hb, bu⟩, ab⟩,\n      fun ⟨b, ⟨hb, bu⟩, ab⟩ => bu ab⟩\n#align is_topological_basis.open_eq_sUnion' is_topological_basis.open_eq_sUnion'\n\n",
 "open_eq_sUnion":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (S «expr ⊆ » B) -/\ntheorem is_topological_basis.open_eq_sUnion {B : Set (Set α)} (hB : IsTopologicalBasis B) {u : Set α} (ou : IsOpen u) :\n    ∃ (S : _)(_ : S ⊆ B), u = ⋃₀ S :=\n  ⟨{ s ∈ B | s ⊆ u }, fun s h => h.1, hB.open_eq_sUnion' ou⟩\n#align is_topological_basis.open_eq_sUnion is_topological_basis.open_eq_sUnion\n\n",
 "open_eq_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_topological_basis.open_eq_Union {B : Set (Set α)} (hB : IsTopologicalBasis B) {u : Set α} (ou : IsOpen u) :\n    ∃ (β : Type u)(f : β → Set α),\n      u = «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i) ∧\n        ∀ i, f i ∈ B :=\n  ⟨«expr↥ » ({ s ∈ B | s ⊆ u }), coe, by\n    rw [← sUnion_eq_Union]\n    apply hB.open_eq_sUnion' ou, fun s => And.left s.2⟩\n#align is_topological_basis.open_eq_Union is_topological_basis.open_eq_Union\n\n",
 "nonempty_of_mem_countable_basis":
 "theorem nonempty_of_mem_countable_basis [SecondCountableTopology α] {s : Set α} (hs : s ∈ countableBasis α) :\n    s.nonempty :=\n  nonempty_iff_ne_empty.2 <| ne_of_mem_of_not_mem hs <| empty_nmem_countableBasis α\n#align nonempty_of_mem_countable_basis nonempty_of_mem_countable_basis\n\n",
 "nhds_has_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_topological_basis.nhds_has_basis {b : Set (Set α)} (hb : IsTopologicalBasis b) {a : α} :\n    ((nhds) a).has_basis (fun t : Set α => t ∈ b ∧ a ∈ t) fun t => t :=\n  ⟨fun s => hb.mem_nhds_iff.trans <| by simp only [exists_prop, and_assoc']⟩\n#align is_topological_basis.nhds_has_basis is_topological_basis.nhds_has_basis\n\n",
 "mono":
 "theorem is_separable.mono {s u : Set α} (hs : IsSeparable s) (hu : u ⊆ s) : IsSeparable u :=\n  by\n  rcases hs with ⟨c, c_count, hs⟩\n  exact ⟨c, c_count, hu.trans hs⟩\n#align is_separable.mono is_separable.mono\n\n",
 "mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A set `s` is in the neighbourhood of `a` iff there is some basis set `t`, which\ncontains `a` and is itself contained in `s`. -/\ntheorem is_topological_basis.mem_nhds_iff {a : α} {s : Set α} {b : Set (Set α)} (hb : IsTopologicalBasis b) :\n    s ∈ (nhds) a ↔ ∃ t ∈ b, a ∈ t ∧ t ⊆ s :=\n  by\n  change s ∈ ((nhds) a).sets ↔ ∃ t ∈ b, a ∈ t ∧ t ⊆ s\n  rw [hb.eq_generate_from, nhds_generate_from, binfi_sets_eq]\n  · simp [and_assoc', and_left_comm]\n  ·\n    exact fun s ⟨hs₁, hs₂⟩ t ⟨ht₁, ht₂⟩ =>\n      have : a ∈ s ∩ t := ⟨hs₁, ht₁⟩\n      let ⟨u, hu₁, hu₂, hu₃⟩ := hb.1 _ hs₂ _ ht₂ _ this\n      ⟨u, ⟨hu₂, hu₁⟩, le_principal_iff.2 (subset.trans hu₃ (inter_subset_left _ _)),\n        le_principal_iff.2 (subset.trans hu₃ (inter_subset_right _ _))⟩\n  · rcases eq_univ_iff_forall.1 hb.sUnion_eq a with ⟨i, h1, h2⟩\n    exact ⟨i, h2, h1⟩\n#align is_topological_basis.mem_nhds_iff is_topological_basis.mem_nhds_iff\n\n",
 "mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\nprotected theorem is_topological_basis.mem_nhds {a : α} {s : Set α} {b : Set (Set α)} (hb : IsTopologicalBasis b)\n    (hs : s ∈ b) (ha : a ∈ s) : s ∈ (nhds) a :=\n  (hb.is_open hs).mem_nhds ha\n#align is_topological_basis.mem_nhds is_topological_basis.mem_nhds\n\n",
 "mem_closure_iff":
 "/-- A point `a` is in the closure of `s` iff all basis sets containing `a` intersect `s`. -/\ntheorem is_topological_basis.mem_closure_iff {b : Set (Set α)} (hb : IsTopologicalBasis b) {s : Set α} {a : α} :\n    a ∈ closure s ↔ ∀ o ∈ b, a ∈ o → (o ∩ s).nonempty :=\n  (mem_closure_iff_nhds_basis' hb.nhds_has_basis).trans <| by simp only [and_imp]\n#align is_topological_basis.mem_closure_iff is_topological_basis.mem_closure_iff\n\n",
 "is_topological_basis_opens":
 "theorem is_topological_basis_opens : IsTopologicalBasis { U : Set α | IsOpen U } :=\n  isTopologicalBasis_of_open_of_nhds (by tauto) (by tauto)\n#align is_topological_basis_opens is_topological_basis_opens\n\n",
 "is_topological_basis_of_subbasis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem is_topological_basis_of_subbasis {s : Set (Set α)} (hs : t = generateFrom s) :\n    IsTopologicalBasis («expr '' » (fun f => «expr⋂₀ » f) { f : Set (Set α) | f.finite ∧ f ⊆ s }) :=\n  by\n  refine' ⟨_, _, hs.trans (le_antisymm (le_generateFrom _) <| generate_from_anti fun t ht => _)⟩\n  · rintro _ ⟨t₁, ⟨hft₁, ht₁b⟩, rfl⟩ _ ⟨t₂, ⟨hft₂, ht₂b⟩, rfl⟩ x h\n    exact ⟨_, ⟨_, ⟨hft₁.union hft₂, union_subset ht₁b ht₂b⟩, sInter_union t₁ t₂⟩, h, subset.rfl⟩\n  · rw [sUnion_image, Union₂_eq_univ_iff]\n    exact fun x => ⟨∅, ⟨finite_empty, empty_subset _⟩, sInter_empty.substr <| mem_univ x⟩\n  · rintro _ ⟨t, ⟨hft, htb⟩, rfl⟩\n    apply isOpen_interₛ\n    exacts[hft, fun s hs => generate_open.basic _ <| htb hs]\n  · rw [← sInter_singleton t]\n    exact ⟨{t}, ⟨finite_singleton t, singleton_subset_iff.2 ht⟩, rfl⟩\n#align is_topological_basis_of_subbasis is_topological_basis_of_subbasis\n\n",
 "is_topological_basis_of_open_of_nhds":
 "/-- If a family of open sets `s` is such that every open neighbourhood contains some\nmember of `s`, then `s` is a topological basis. -/\ntheorem is_topological_basis_of_open_of_nhds {s : Set (Set α)} (h_open : ∀ u ∈ s, IsOpen u)\n    (h_nhds : ∀ (a : α) (u : Set α), a ∈ u → IsOpen u → ∃ v ∈ s, a ∈ v ∧ v ⊆ u) : IsTopologicalBasis s :=\n  by\n  refine' ⟨fun t₁ ht₁ t₂ ht₂ x hx => h_nhds _ _ hx (IsOpen.inter (h_open _ ht₁) (h_open _ ht₂)), _, _⟩\n  · refine' sUnion_eq_univ_iff.2 fun a => _\n    rcases h_nhds a univ trivial isOpen_univ with ⟨u, h₁, h₂, -⟩\n    exact ⟨u, h₁, h₂⟩\n  · refine' (le_generateFrom h_open).antisymm fun u hu => _\n    refine' (@isOpen_iff_nhds α (generate_from s) u).mpr fun a ha => _\n    rcases h_nhds a u ha hu with ⟨v, hvs, hav, hvu⟩\n    rw [nhds_generate_from]\n    exact infᵢ₂_le_of_le v ⟨hav, hvs⟩ (le_principal_iff.2 hvu)\n#align is_topological_basis_of_open_of_nhds is_topological_basis_of_open_of_nhds\n\n",
 "is_topological_basis_of_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_topological_basis_of_cover {ι} {U : ι → Set α} (Uo : ∀ i, IsOpen (U i))\n    (Uc : «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (U i) = univ)\n    {b : ∀ i, Set (Set (U i))} (hb : ∀ i, IsTopologicalBasis (b i)) :\n    IsTopologicalBasis\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr '' » (image (coe : U i → α)) (b i))) :=\n  by\n  refine' is_topological_basis_of_open_of_nhds (fun u hu => _) _\n  · simp only [mem_Union, mem_image] at hu\n    rcases hu with ⟨i, s, sb, rfl⟩\n    exact (Uo i).is_open_map_subtype_coe _ ((hb i).is_open sb)\n  · intro a u ha uo\n    rcases Union_eq_univ_iff.1 Uc a with ⟨i, hi⟩\n    lift a to «expr↥ » (U i) using hi\n    rcases(hb i).exists_subset_of_mem_open ha (uo.preimage continuous_subtype_val) with ⟨v, hvb, hav, hvu⟩\n    exact ⟨«expr '' » coe v, mem_Union.2 ⟨i, mem_image_of_mem _ hvb⟩, mem_image_of_mem _ hav, image_subset_iff.2 hvu⟩\n#align is_topological_basis_of_cover is_topological_basis_of_cover\n\n",
 "is_separable_univ_iff":
 "theorem is_separable_univ_iff : IsSeparable (univ : Set α) ↔ SeparableSpace α :=\n  by\n  constructor\n  · rintro ⟨c, c_count, hc⟩\n    refine' ⟨⟨c, c_count, by rwa [dense_iff_closure_eq, ← univ_subset_iff]⟩⟩\n  · intro h\n    rcases exists_countable_dense α with ⟨c, c_count, hc⟩\n    exact ⟨c, c_count, by rwa [univ_subset_iff, ← dense_iff_closure_eq]⟩\n#align is_separable_univ_iff is_separable_univ_iff\n\n",
 "is_separable_of_separable_space_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_separable_of_separable_space_subtype (s : Set α) [SeparableSpace s] : IsSeparable s :=\n  by\n  have : is_separable («expr '' » (coe : s → α) (univ : Set s)) :=\n    (is_separable_of_separable_space _).image continuous_subtype_val\n  simpa only [image_univ, Subtype.range_coe_subtype]\n#align is_separable_of_separable_space_subtype is_separable_of_separable_space_subtype\n\n",
 "is_separable_of_separable_space":
 "theorem is_separable_of_separable_space [h : SeparableSpace α] (s : Set α) : IsSeparable s :=\n  IsSeparable.mono (isSeparable_univ_iff.2 h) (subset_univ _)\n#align is_separable_of_separable_space is_separable_of_separable_space\n\n",
 "is_separable_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_separable_Union {ι : Type _} [Countable ι] {s : ι → Set α} (hs : ∀ i, IsSeparable (s i)) :\n    IsSeparable\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  by\n  choose c hc h'c using hs\n  refine'\n    ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (c i),\n      countable_Union hc, Union_subset_iff.2 fun i => _⟩\n  exact (h'c i).trans (closure_mono (subset_Union _ i))\n#align is_separable_Union is_separable_Union\n\n",
 "is_separable":
 "#print Set.Finite.isSeparable /-\ntheorem Set.Finite.isSeparable {s : Set α} (hs : s.finite) : IsSeparable s :=\n  hs.countable.is_separable\n#align set.finite.is_separable Set.Finite.isSeparable\n-/\n\n",
 "is_open_sUnion_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_open_sUnion_countable [SecondCountableTopology α] (S : Set (Set α)) (H : ∀ s ∈ S, IsOpen s) :\n    ∃ T : Set (Set α), T.countable ∧ T ⊆ S ∧ ⋃₀ T = ⋃₀ S :=\n  let ⟨T, cT, hT⟩ := isOpen_unionᵢ_countable (fun s : S => s.1) fun s => H s.1 s.2\n  ⟨«expr '' » Subtype.val T, cT.image _, image_subset_iff.2 fun ⟨x, xs⟩ xt => xs, by\n    rwa [sUnion_image, sUnion_eq_Union]⟩\n#align is_open_sUnion_countable is_open_sUnion_countable\n\n",
 "is_open_of_mem_countable_basis":
 "theorem is_open_of_mem_countable_basis [SecondCountableTopology α] {s : Set α} (hs : s ∈ countableBasis α) : IsOpen s :=\n  (isBasis_countableBasis α).is_open hs\n#align is_open_of_mem_countable_basis is_open_of_mem_countable_basis\n\n",
 "is_open_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_topological_basis.is_open_map_iff {β} [TopologicalSpace β] {B : Set (Set α)} (hB : IsTopologicalBasis B)\n    {f : α → β} : IsOpenMap f ↔ ∀ s ∈ B, IsOpen («expr '' » f s) :=\n  by\n  refine' ⟨fun H o ho => H _ (hB.is_open ho), fun hf o ho => _⟩\n  rw [hB.open_eq_sUnion' ho, sUnion_eq_Union, image_Union]\n  exact isOpen_unionᵢ fun s => hf s s.2.1\n#align is_topological_basis.is_open_map_iff is_topological_basis.is_open_map_iff\n\n",
 "is_open_iff":
 "theorem is_topological_basis.is_open_iff {s : Set α} {b : Set (Set α)} (hb : IsTopologicalBasis b) :\n    IsOpen s ↔ ∀ a ∈ s, ∃ t ∈ b, a ∈ t ∧ t ⊆ s := by simp [isOpen_iff_mem_nhds, hb.mem_nhds_iff]\n#align is_topological_basis.is_open_iff is_topological_basis.is_open_iff\n\n",
 "is_open_Union_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem is_open_Union_countable [SecondCountableTopology α] {ι} (s : ι → Set α) (H : ∀ i, IsOpen (s i)) :\n    ∃ T : Set ι,\n      T.countable ∧\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i) =\n          «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i) :=\n  by\n  let B := { b ∈ countable_basis α | ∃ i, b ⊆ s i }\n  choose f hf using fun b : B => b.2.2\n  haveI : Encodable B := ((countable_countable_basis α).mono (sep_subset _ _)).to_encodable\n  refine' ⟨_, countable_range f, (Union₂_subset_Union _ _).antisymm (sUnion_subset _)⟩\n  rintro _ ⟨i, rfl⟩ x xs\n  rcases(is_basis_countable_basis α).exists_subset_of_mem_open xs (H _) with ⟨b, hb, xb, bs⟩\n  exact ⟨_, ⟨_, rfl⟩, _, ⟨⟨⟨_, hb, _, bs⟩, rfl⟩, rfl⟩, hf _ xb⟩\n#align is_open_Union_countable is_open_Union_countable\n\n",
 "is_open":
 "protected theorem is_topological_basis.is_open {s : Set α} {b : Set (Set α)} (hb : IsTopologicalBasis b) (hs : s ∈ b) :\n    IsOpen s := by\n  rw [hb.eq_generate_from]\n  exact generate_open.basic s hs\n#align is_topological_basis.is_open is_topological_basis.is_open\n\n",
 "is_basis_countable_basis":
 "theorem is_basis_countable_basis [SecondCountableTopology α] : IsTopologicalBasis (countableBasis α) :=\n  (exists_countable_basis α).some_spec.2.2\n#align is_basis_countable_basis is_basis_countable_basis\n\n",
 "isTopologicalBasis_singletons":
 "#print isTopologicalBasis_singletons /-\ntheorem isTopologicalBasis_singletons (α : Type _) [TopologicalSpace α] [DiscreteTopology α] :\n    IsTopologicalBasis { s | ∃ x : α, (s : Set α) = {x} } :=\n  isTopologicalBasis_of_open_of_nhds (fun u hu => isOpen_discrete _) fun x u hx u_open =>\n    ⟨{x}, ⟨x, rfl⟩, mem_singleton x, singleton_subset_iff.2 hx⟩\n#align is_topological_basis_singletons isTopologicalBasis_singletons\n-/\n\n",
 "isTopologicalBasis_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isTopologicalBasis_pi /-\ntheorem isTopologicalBasis_pi {ι : Type _} {X : ι → Type _} [∀ i, TopologicalSpace (X i)] {T : ∀ i, Set (Set (X i))}\n    (cond : ∀ i, IsTopologicalBasis (T i)) :\n    IsTopologicalBasis\n      { S : Set (∀ i, X i) | ∃ (U : ∀ i, Set (X i))(F : Finset ι), (∀ i, i ∈ F → U i ∈ T i) ∧ S = (F : Set ι).pi U } :=\n  by\n  refine' is_topological_basis_of_open_of_nhds _ _\n  · rintro _ ⟨U, F, h1, rfl⟩\n    apply isOpen_set_pi F.finite_to_set\n    intro i hi\n    exact (cond i).is_open (h1 i hi)\n  · intro a U ha hU\n    obtain ⟨I, t, hta, htU⟩ : ∃ (I : Finset ι)(t : ∀ i : ι, Set (X i)), (∀ i, t i ∈ (nhds) (a i)) ∧ Set.pi (↑I) t ⊆ U :=\n      by\n      rw [← Filter.mem_pi', ← nhds_pi]\n      exact hU.mem_nhds ha\n    have : ∀ i, ∃ V ∈ T i, a i ∈ V ∧ V ⊆ t i := fun i => (cond i).mem_nhds_iff.1 (hta i)\n    choose V hVT haV hVt\n    exact ⟨_, ⟨V, I, fun i hi => hVT i, rfl⟩, fun i hi => haV i, (pi_mono fun i hi => hVt i).trans htU⟩\n#align is_topological_basis_pi isTopologicalBasis_pi\n-/\n\n",
 "isTopologicalBasis_infᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print isTopologicalBasis_infᵢ /-\ntheorem isTopologicalBasis_infᵢ {β : Type _} {ι : Type _} {X : ι → Type _} [t : ∀ i, TopologicalSpace (X i)]\n    {T : ∀ i, Set (Set (X i))} (cond : ∀ i, IsTopologicalBasis (T i)) (f : ∀ i, β → X i) :\n    @IsTopologicalBasis β\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (induced (f i) (t i)))\n      { S |\n        ∃ (U : ∀ i, Set (X i))(F : Finset ι),\n          (∀ i, i ∈ F → U i ∈ T i) ∧\n            S =\n              «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n                («expr ⁻¹' » (f i) (U i)) } :=\n  by\n  convert(isTopologicalBasis_pi cond).inducing (inducing_infᵢ_to_pi _)\n  ext V\n  constructor\n  · rintro ⟨U, F, h1, h2⟩\n    have :\n      (F : Set ι).pi U =\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          («expr ⁻¹' » (fun z : ∀ j, X j => z i) (U i)) :=\n      by\n      ext\n      simp\n    refine' ⟨(F : Set ι).pi U, ⟨U, F, h1, rfl⟩, _⟩\n    rw [this, h2, Set.preimage_interᵢ]\n    congr 1\n    ext1\n    rw [Set.preimage_interᵢ]\n    rfl\n  · rintro ⟨U, ⟨U, F, h1, rfl⟩, h⟩\n    refine' ⟨U, F, h1, _⟩\n    have :\n      (F : Set ι).pi U =\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          («expr ⁻¹' » (fun z : ∀ j, X j => z i) (U i)) :=\n      by\n      ext\n      simp\n    rw [← h, this, Set.preimage_interᵢ]\n    congr 1\n    ext1\n    rw [Set.preimage_interᵢ]\n    rfl\n#align is_topological_basis_infi isTopologicalBasis_infᵢ\n-/\n\n",
 "insert_empty":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\ntheorem is_topological_basis.insert_empty {s : Set (Set α)} (h : IsTopologicalBasis s) :\n    IsTopologicalBasis (insert ∅ s) :=\n  by\n  refine' ⟨_, by rw [sUnion_insert, empty_union, h.sUnion_eq], _⟩\n  · rintro t₁ (rfl | h₁) t₂ (rfl | h₂) x ⟨hx₁, hx₂⟩\n    · cases hx₁\n    · cases hx₁\n    · cases hx₂\n    obtain ⟨t₃, h₃, hs⟩ := h.exists_subset_inter _ h₁ _ h₂ x ⟨hx₁, hx₂⟩\n    exact ⟨t₃, or.inr h₃, hs⟩\n  · rw [h.eq_generate_from]\n    refine' le_antisymm (le_generateFrom fun t => _) (generate_from_anti <| subset_insert ∅ s)\n    rintro (rfl | ht)\n    · convert isOpen_empty\n    · exact generate_open.basic t ht\n#align is_topological_basis.insert_empty is_topological_basis.insert_empty\n\n",
 "inducing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem is_topological_basis.inducing {β} [TopologicalSpace β] {f : α → β} {T : Set (Set β)} (hf : Inducing f)\n    (h : IsTopologicalBasis T) : IsTopologicalBasis (image (preimage f) T) :=\n  by\n  refine' is_topological_basis_of_open_of_nhds _ _\n  · rintro _ ⟨V, hV, rfl⟩\n    rwa [hf.is_open_iff]\n    refine' ⟨V, h.is_open hV, rfl⟩\n  · intro a U ha hU\n    rw [hf.is_open_iff] at hU\n    obtain ⟨V, hV, rfl⟩ := hU\n    obtain ⟨S, hS, rfl⟩ := h.open_eq_sUnion hV\n    obtain ⟨W, hW, ha⟩ := ha\n    refine' ⟨«expr ⁻¹' » f W, ⟨_, hS hW, rfl⟩, ha, Set.preimage_mono <| Set.subset_unionₛ_of_mem hW⟩\n#align is_topological_basis.inducing is_topological_basis.inducing\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_separable.image {β : Type _} [TopologicalSpace β] {s : Set α} (hs : IsSeparable s) {f : α → β}\n    (hf : Continuous f) : IsSeparable («expr '' » f s) :=\n  by\n  rcases hs with ⟨c, c_count, hc⟩\n  refine' ⟨«expr '' » f c, c_count.image _, _⟩\n  rw [image_subset_iff]\n  exact hc.trans (closure_subset_preimage_closure_image hf)\n#align is_separable.image is_separable.image\n\n",
 "exists_subset_of_mem_open":
 "theorem is_topological_basis.exists_subset_of_mem_open {b : Set (Set α)} (hb : IsTopologicalBasis b) {a : α} {u : Set α}\n    (au : a ∈ u) (ou : IsOpen u) : ∃ v ∈ b, a ∈ v ∧ v ⊆ u :=\n  hb.mem_nhds_iff.1 <| IsOpen.mem_nhds ou au\n#align is_topological_basis.exists_subset_of_mem_open is_topological_basis.exists_subset_of_mem_open\n\n",
 "exists_nonempty_subset":
 "theorem is_topological_basis.exists_nonempty_subset {B : Set (Set α)} (hb : IsTopologicalBasis B) {u : Set α}\n    (hu : u.nonempty) (ou : IsOpen u) : ∃ v ∈ B, Set.Nonempty v ∧ v ⊆ u :=\n  by\n  cases' hu with x hx\n  rw [hb.open_eq_sUnion' ou, mem_sUnion] at hx\n  rcases hx with ⟨v, hv, hxv⟩\n  exact ⟨v, hv.1, ⟨x, hxv⟩, hv.2⟩\n#align is_topological_basis.exists_nonempty_subset is_topological_basis.exists_nonempty_subset\n\n",
 "exists_dense_seq":
 "/-- A nonempty separable space admits a sequence with dense range. Instead of running `cases` on the\nconclusion of this lemma, you might want to use `topological_space.dense_seq` and\n`topological_space.dense_range_dense_seq`.\n\nIf `α` might be empty, then `exists_countable_dense` is the main way to use separability of `α`. -/\ntheorem exists_dense_seq [SeparableSpace α] [Nonempty α] : ∃ u : ℕ → α, DenseRange u :=\n  by\n  obtain ⟨s : Set α, hs, s_dense⟩ := exists_countable_dense α\n  cases' set.countable_iff_exists_subset_range.mp hs with u hu\n  exact ⟨u, s_dense.mono hu⟩\n#align exists_dense_seq exists_dense_seq\n\n",
 "exists_countable_dense_subset_bot_top":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n#print Dense.exists_countable_dense_subset_bot_top /-\n/-- Let `s` be a dense set in a topological space `α` with partial order structure. If `s` is a\nseparable space (e.g., if `α` has a second countable topology), then there exists a countable\ndense subset `t ⊆ s` such that `t` contains bottom/top element of `α` when they exist and belong\nto `s`. For a dense subset containing neither bot nor top elements, see\n`dense.exists_countable_dense_subset_no_bot_top`. -/\ntheorem Dense.exists_countable_dense_subset_bot_top {α : Type _} [TopologicalSpace α] [partial_order α] {s : Set α}\n    [SeparableSpace s] (hs : Dense s) :\n    ∃ (t : _)(_ : t ⊆ s), t.countable ∧ Dense t ∧ (∀ x, IsBot x → x ∈ s → x ∈ t) ∧ ∀ x, IsTop x → x ∈ s → x ∈ t :=\n  by\n  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩\n  refine' ⟨(t ∪ ({ x | IsBot x } ∪ { x | IsTop x })) ∩ s, _, _, _, _, _⟩\n  exacts[inter_subset_right _ _,\n    (htc.union ((countable_is_bot α).union (countable_is_top α))).mono (inter_subset_left _ _),\n    htd.mono (subset_inter (subset_union_left _ _) hts), fun x hx hxs => ⟨or.inr <| or.inl hx, hxs⟩, fun x hx hxs =>\n    ⟨or.inr <| or.inr hx, hxs⟩]\n#align dense.exists_countable_dense_subset_bot_top Dense.exists_countable_dense_subset_bot_top\n-/\n\n",
 "exists_countable_dense_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\ntheorem Dense.exists_countable_dense_subset {α : Type _} [TopologicalSpace α] {s : Set α} [SeparableSpace s]\n    (hs : Dense s) : ∃ (t : _)(_ : t ⊆ s), t.countable ∧ Dense t :=\n  let ⟨t, htc, htd⟩ := exists_countable_dense s\n  ⟨«expr '' » coe t, image_subset_iff.2 fun x _ => mem_preimage.2 <| Subtype.coe_prop _, htc.image coe,\n    hs.dense_range_coe.dense_image continuous_subtype_val htd⟩\n#align dense.exists_countable_dense_subset Dense.exists_countable_dense_subsetₓ\n\n",
 "exists_countable_dense_bot_top":
 "#print exists_countable_dense_bot_top /-\n/-- If `α` is a separable topological space with a partial order, then there exists a countable\ndense set `s : set α` that contains those of both bottom and top elements of `α` that actually\nexist. For a dense set containing neither bot nor top elements, see\n`exists_countable_dense_no_bot_top`. -/\ntheorem exists_countable_dense_bot_top (α : Type _) [TopologicalSpace α] [SeparableSpace α] [partial_order α] :\n    ∃ s : Set α, s.countable ∧ Dense s ∧ (∀ x, IsBot x → x ∈ s) ∧ ∀ x, IsTop x → x ∈ s := by\n  simpa using dense_univ.exists_countable_dense_subset_bot_top\n#align exists_countable_dense_bot_top exists_countable_dense_bot_top\n-/\n\n",
 "exists_countable_dense":
 "theorem exists_countable_dense [SeparableSpace α] : ∃ s : Set α, s.countable ∧ Dense s :=\n  separable_space.exists_countable_dense\n#align exists_countable_dense exists_countable_dense\n\n",
 "exists_countable_basis":
 "theorem exists_countable_basis [SecondCountableTopology α] :\n    ∃ b : Set (Set α), b.countable ∧ ∅ ∉ b ∧ IsTopologicalBasis b :=\n  by\n  obtain ⟨b, hb₁, hb₂⟩ := second_countable_topology.is_open_generated_countable α\n  refine' ⟨_, _, not_mem_diff_of_mem _, (is_topological_basis_of_subbasis hb₂).diff_empty⟩\n  exacts[((countable_set_of_finite_subset hb₁).image _).mono (diff_subset _ _), rfl]\n#align exists_countable_basis exists_countable_basis\n\n",
 "eq_generate_from_countable_basis":
 "theorem eq_generate_from_countable_basis [SecondCountableTopology α] :\n    ‹TopologicalSpace α› = generateFrom (countableBasis α) :=\n  (isBasis_countableBasis α).eq_generate_from\n#align eq_generate_from_countable_basis eq_generate_from_countable_basis\n\n",
 "empty_nmem_countable_basis":
 "theorem empty_nmem_countable_basis [SecondCountableTopology α] : ∅ ∉ countableBasis α :=\n  (exists_countable_basis α).some_spec.2.1\n#align empty_nmem_countable_basis empty_nmem_countable_basis\n\n",
 "diff_empty":
 "theorem is_topological_basis.diff_empty {s : Set (Set α)} (h : IsTopologicalBasis s) : IsTopologicalBasis (s \\ {∅}) :=\n  by\n  refine' ⟨_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq], _⟩\n  · rintro t₁ ⟨h₁, -⟩ t₂ ⟨h₂, -⟩ x hx\n    obtain ⟨t₃, h₃, hs⟩ := h.exists_subset_inter _ h₁ _ h₂ x hx\n    exact ⟨t₃, ⟨h₃, nonempty.ne_empty ⟨x, hs.1⟩⟩, hs⟩\n  · rw [h.eq_generate_from]\n    refine' le_antisymm (generate_from_anti <| diff_subset s _) (le_generateFrom fun t ht => _)\n    obtain rfl | he := eq_or_ne t ∅\n    · convert isOpen_empty\n    exact generate_open.basic t ⟨ht, he⟩\n#align is_topological_basis.diff_empty is_topological_basis.diff_empty\n\n",
 "dense_range_dense_seq":
 "/-- The sequence `dense_seq α` has dense range. -/\n@[simp]\ntheorem dense_range_dense_seq [SeparableSpace α] [Nonempty α] : DenseRange (denseSeq α) :=\n  Classical.choose_spec (exists_dense_seq α)\n#align dense_range_dense_seq dense_range_dense_seq\n\n",
 "dense_iff":
 "/-- A set is dense iff it has non-trivial intersection with all basis sets. -/\ntheorem is_topological_basis.dense_iff {b : Set (Set α)} (hb : IsTopologicalBasis b) {s : Set α} :\n    Dense s ↔ ∀ o ∈ b, Set.Nonempty o → (o ∩ s).nonempty :=\n  by\n  simp only [Dense, hb.mem_closure_iff]\n  exact ⟨fun h o hb ⟨a, ha⟩ => h a o hb ha, fun h a o hb ha => h o hb ⟨a, ha⟩⟩\n#align is_topological_basis.dense_iff is_topological_basis.dense_iff\n\n",
 "countable_of_nonempty_interior":
 "#print Set.PairwiseDisjoint.countable_of_nonempty_interior /-\n/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/\ntheorem Set.PairwiseDisjoint.countable_of_nonempty_interior [SeparableSpace α] {ι : Type _} {s : ι → Set α} {a : Set ι}\n    (h : a.pairwise_disjoint s) (ha : ∀ i ∈ a, (interior (s i)).nonempty) : a.countable :=\n  (h.mono fun i => interior_subset).countable_of_is_open (fun i hi => isOpen_interior) ha\n#align set.pairwise_disjoint.countable_of_nonempty_interior Set.PairwiseDisjoint.countable_of_nonempty_interior\n-/\n\n",
 "countable_of_is_open":
 "#print Set.PairwiseDisjoint.countable_of_isOpen /-\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem Set.PairwiseDisjoint.countable_of_isOpen [SeparableSpace α] {ι : Type _} {s : ι → Set α} {a : Set ι}\n    (h : a.pairwise_disjoint s) (ha : ∀ i ∈ a, IsOpen (s i)) (h'a : ∀ i ∈ a, (s i).nonempty) : a.countable :=\n  by\n  rcases exists_countable_dense α with ⟨u, ⟨u_encodable⟩, u_dense⟩\n  have : ∀ i : a, ∃ y, y ∈ s i ∩ u := fun i => dense_iff_inter_open.1 u_dense (s i) (ha i i.2) (h'a i i.2)\n  choose f hfs hfu using this\n  lift f to a → u using hfu\n  have f_inj : injective f :=\n    by\n    refine' injective_iff_pairwise_ne.mpr ((h.subtype _ _).mono fun i j hij hfij => hij.le_bot ⟨hfs i, _⟩)\n    simp only [congr_arg coe hfij, hfs j]\n  exact ⟨@Encodable.ofInj _ _ u_encodable f f_inj⟩\n#align set.pairwise_disjoint.countable_of_is_open Set.PairwiseDisjoint.countable_of_isOpen\n-/\n\n",
 "countable_cover_nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem countable_cover_nhds_within [SecondCountableTopology α] {f : α → Set α} {s : Set α}\n    (hf : ∀ x ∈ s, f x ∈ nhds_within s x) :\n    ∃ (t : _)(_ : t ⊆ s),\n      t.countable ∧\n        s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f x) :=\n  by\n  have : ∀ x : s, «expr ⁻¹' » coe (f x) ∈ (nhds) x := fun x => preimage_coe_mem_nhds_subtype.2 (hf x x.2)\n  rcases countable_cover_nhds this with ⟨t, htc, htU⟩\n  refine' ⟨«expr '' » coe t, Subtype.coe_image_subset _ _, htc.image _, fun x hx => _⟩\n  simp only [bUnion_image, eq_univ_iff_forall, ← preimage_Union, mem_preimage] at htU⊢\n  exact htU ⟨x, hx⟩\n#align countable_cover_nhds_within countable_cover_nhds_within\n\n",
 "countable_cover_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- In a topological space with second countable topology, if `f` is a function that sends each\npoint `x` to a neighborhood of `x`, then for some countable set `s`, the neighborhoods `f x`,\n`x ∈ s`, cover the whole space. -/\ntheorem countable_cover_nhds [SecondCountableTopology α] {f : α → Set α} (hf : ∀ x, f x ∈ (nhds) x) :\n    ∃ s : Set α,\n      s.countable ∧\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f x) = univ :=\n  by\n  rcases is_open_Union_countable (fun x => interior (f x)) fun x => isOpen_interior with ⟨s, hsc, hsU⟩\n  suffices :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (interior (f x)) =\n      univ\n  exact ⟨s, hsc, flip eq_univ_of_subset this <| Union₂_mono fun _ _ => interior_subset⟩\n  simp only [hsU, eq_univ_iff_forall, mem_Union]\n  exact fun x => ⟨x, mem_interior_iff_mem_nhds.2 (hf x)⟩\n#align countable_cover_nhds countable_cover_nhds\n\n",
 "countable_countable_basis":
 "theorem countable_countable_basis [SecondCountableTopology α] : (countableBasis α).countable :=\n  (exists_countable_basis α).some_spec.1\n#align countable_countable_basis countable_countable_basis\n\n",
 "continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem is_topological_basis.continuous {β : Type _} [TopologicalSpace β] {B : Set (Set β)}\n    (hB : IsTopologicalBasis B) (f : α → β) (hf : ∀ s ∈ B, IsOpen («expr ⁻¹' » f s)) : Continuous f := by\n  rw [hB.eq_generate_from]; exact continuous_generateFrom hf\n#align is_topological_basis.continuous is_topological_basis.continuous\n\n",
 "closure":
 "theorem is_separable.closure {s : Set α} (hs : IsSeparable s) : IsSeparable (closure s) :=\n  by\n  rcases hs with ⟨c, c_count, hs⟩\n  exact ⟨c, c_count, by simpa using closure_mono hs⟩\n#align is_separable.closure is_separable.closure\n\n"}