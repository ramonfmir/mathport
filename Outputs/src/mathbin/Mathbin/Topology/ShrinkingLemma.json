{"subset_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov, Reid Barton\n-/\n-- the trivial refinement needs `u` to be a covering\ntheorem subset_Union (v : PartialRefinement u s) :\n    s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (v i) :=\n  v.subset_Union'\n#align subset_Union subset_Union\n\n",
 "subset":
 "protected theorem subset (v : PartialRefinement u s) (i : ι) : v i ⊆ u i :=\n  if h : i ∈ v.carrier then Subset.trans subset_closure (v.closure_subset h) else (v.apply_eq h).le\n#align subset subset\n\n",
 "mem_find_carrier_iff":
 "theorem mem_find_carrier_iff {c : Set (PartialRefinement u s)} {i : ι} (ne : c.nonempty) :\n    i ∈ (find c ne i).carrier ↔ i ∈ chainSupCarrier c :=\n  by\n  rw [find]\n  split_ifs\n  · have : i ∈ h.some.carrier ∧ i ∈ chain_Sup_carrier c := ⟨h.some_spec.snd, mem_Union₂.2 h⟩\n    simp only [this]\n  · have : i ∉ ne.some.carrier ∧ i ∉ chain_Sup_carrier c := ⟨fun hi => h ⟨_, ne.some_spec, hi⟩, mt mem_Union₂.1 h⟩\n    simp only [this]\n#align mem_find_carrier_iff mem_find_carrier_iff\n\n",
 "le_chain_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- `chain_Sup hu c hc ne hfin hU` is an upper bound of the chain `c`. -/\ntheorem le_chain_Sup {c : Set (PartialRefinement u s)} (hc : IsChain (· ≤ ·) c) (ne : c.nonempty)\n    (hfin : ∀ x ∈ s, { i | x ∈ u i }.finite)\n    (hU : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u i)) {v}\n    (hv : v ∈ c) : v ≤ chainSup c hc ne hfin hU :=\n  ⟨fun i hi => mem_bunionᵢ hv hi, fun i hi => (find_apply_of_mem hc _ hv hi).symm⟩\n#align le_chain_Sup le_chain_Sup\n\n",
 "find_mem":
 "theorem find_mem {c : Set (PartialRefinement u s)} (i : ι) (ne : c.nonempty) : find c ne i ∈ c :=\n  by\n  rw [find]\n  split_ifs\n  exacts[h.some_spec.fst, ne.some_spec]\n#align find_mem find_mem\n\n",
 "find_apply_of_mem":
 "theorem find_apply_of_mem {c : Set (PartialRefinement u s)} (hc : IsChain (· ≤ ·) c) (ne : c.nonempty) {i v}\n    (hv : v ∈ c) (hi : i ∈ carrier v) : find c ne i i = v i :=\n  apply_eq_of_chain hc (find_mem _ _) hv ((mem_find_carrier_iff _).2 <| mem_unionᵢ₂.2 ⟨v, hv, hi⟩) hi\n#align find_apply_of_mem find_apply_of_mem\n\n",
 "exists_unionᵢ_eq_closure_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print exists_unionᵢ_eq_closure_subset /-\n/-- Shrinking lemma. A point-finite open cover of a closed subset of a normal space can be \"shrunk\"\nto a new open cover so that the closure of each new open set is contained in the corresponding\noriginal open set. -/\ntheorem exists_unionᵢ_eq_closure_subset (uo : ∀ i, IsOpen (u i)) (uf : ∀ x, { i | x ∈ u i }.finite)\n    (uU :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u i) = univ) :\n    ∃ v : ι → Set X, unionᵢ v = univ ∧ (∀ i, IsOpen (v i)) ∧ ∀ i, closure (v i) ⊆ u i :=\n  let ⟨v, vU, hv⟩ := exists_subset_unionᵢ_closure_subset isClosed_univ uo (fun x _ => uf x) uU.ge\n  ⟨v, univ_subset_iff.1 vU, hv⟩\n#align exists_Union_eq_closure_subset exists_unionᵢ_eq_closure_subset\n-/\n\n",
 "exists_unionᵢ_eq_closed_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print exists_unionᵢ_eq_closed_subset /-\n/-- Shrinking lemma. A point-finite open cover of a closed subset of a normal space can be \"shrunk\"\nto a new closed cover so that each of the new closed sets is contained in the corresponding\noriginal open set. See also `exists_Union_eq_closure_subset` for a stronger statement. -/\ntheorem exists_unionᵢ_eq_closed_subset (uo : ∀ i, IsOpen (u i)) (uf : ∀ x, { i | x ∈ u i }.finite)\n    (uU :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u i) = univ) :\n    ∃ v : ι → Set X, unionᵢ v = univ ∧ (∀ i, IsClosed (v i)) ∧ ∀ i, v i ⊆ u i :=\n  let ⟨v, vU, hv⟩ := exists_subset_unionᵢ_closed_subset isClosed_univ uo (fun x _ => uf x) uU.ge\n  ⟨v, univ_subset_iff.1 vU, hv⟩\n#align exists_Union_eq_closed_subset exists_unionᵢ_eq_closed_subset\n-/\n\n",
 "exists_subset_unionᵢ_closure_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print exists_subset_unionᵢ_closure_subset /-\n/-- Shrinking lemma. A point-finite open cover of a closed subset of a normal space can be \"shrunk\"\nto a new open cover so that the closure of each new open set is contained in the corresponding\noriginal open set. -/\ntheorem exists_subset_unionᵢ_closure_subset (hs : IsClosed s) (uo : ∀ i, IsOpen (u i))\n    (uf : ∀ x ∈ s, { i | x ∈ u i }.finite)\n    (us : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u i)) :\n    ∃ v : ι → Set X, s ⊆ unionᵢ v ∧ (∀ i, IsOpen (v i)) ∧ ∀ i, closure (v i) ⊆ u i := by\n  classical\n    haveI : Nonempty (partial_refinement u s) := ⟨⟨u, ∅, uo, us, fun _ => false.elim, fun _ _ => rfl⟩⟩\n    have : ∀ c : Set (partial_refinement u s), IsChain (· ≤ ·) c → c.nonempty → ∃ ub, ∀ v ∈ c, v ≤ ub := fun c hc ne =>\n      ⟨partial_refinement.chain_Sup c hc ne uf us, fun v hv => partial_refinement.le_chain_Sup _ _ _ _ hv⟩\n    rcases zorn_nonempty_partialOrder this with ⟨v, hv⟩\n    suffices : ∀ i, i ∈ v.carrier\n    exact ⟨v, v.subset_Union, fun i => v.is_open _, fun i => v.closure_subset (this i)⟩\n    contrapose! hv\n    rcases hv with ⟨i, hi⟩\n    rcases v.exists_gt hs i hi with ⟨v', hlt⟩\n    exact ⟨v', hlt.le, hlt.ne'⟩\n#align exists_subset_Union_closure_subset exists_subset_unionᵢ_closure_subset\n-/\n\n",
 "exists_subset_unionᵢ_closed_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print exists_subset_unionᵢ_closed_subset /-\n/-- Shrinking lemma. A point-finite open cover of a closed subset of a normal space can be \"shrunk\"\nto a new closed cover so that each new closed set is contained in the corresponding original open\nset. See also `exists_subset_Union_closure_subset` for a stronger statement. -/\ntheorem exists_subset_unionᵢ_closed_subset (hs : IsClosed s) (uo : ∀ i, IsOpen (u i))\n    (uf : ∀ x ∈ s, { i | x ∈ u i }.finite)\n    (us : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u i)) :\n    ∃ v : ι → Set X, s ⊆ unionᵢ v ∧ (∀ i, IsClosed (v i)) ∧ ∀ i, v i ⊆ u i :=\n  let ⟨v, hsv, hvo, hv⟩ := exists_subset_unionᵢ_closure_subset hs uo uf us\n  ⟨fun i => closure (v i), Subset.trans hsv (unionᵢ_mono fun i => subset_closure), fun i => isClosed_closure, hv⟩\n#align exists_subset_Union_closed_subset exists_subset_unionᵢ_closed_subset\n-/\n\n",
 "exists_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (j «expr ≠ » i) -/\n/-- If `s` is a closed set, `v` is a partial refinement, and `i` is an index such that\n`i ∉ v.carrier`, then there exists a partial refinement that is strictly greater than `v`. -/\ntheorem exists_gt (v : PartialRefinement u s) (hs : IsClosed s) (i : ι) (hi : i ∉ v.carrier) :\n    ∃ v' : PartialRefinement u s, v < v' :=\n  by\n  have I :\n    s ∩\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          («expr ᶜ» (v j)) ⊆\n      v i :=\n    by\n    simp only [subset_def, mem_inter_iff, mem_Inter, and_imp]\n    intro x hxs H\n    rcases mem_Union.1 (v.subset_Union hxs) with ⟨j, hj⟩\n    exact (em (j = i)).elim (fun h => h ▸ hj) fun h => (H j h hj).elim\n  have C :\n    IsClosed\n      (s ∩\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          («expr ᶜ» (v j))) :=\n    IsClosed.inter hs (isClosed_binterᵢ fun _ _ => isClosed_compl_iff.2 <| v.is_open _)\n  rcases normal_exists_closure_subset C (v.is_open i) I with ⟨vi, ovi, hvi, cvi⟩\n  refine' ⟨⟨update v i vi, insert i v.carrier, _, _, _, _⟩, _, _⟩\n  · intro j\n    by_cases h : j = i <;> simp [h, ovi, v.is_open]\n  · refine' fun x hx => mem_Union.2 _\n    rcases em (∃ (j : _)(_ : j ≠ i), x ∈ v j) with (⟨j, hji, hj⟩ | h)\n    · use j\n      rwa [update_noteq hji]\n    · push_neg  at h\n      use i\n      rw [update_same]\n      exact hvi ⟨hx, mem_bInter h⟩\n  · rintro j (rfl | hj)\n    · rwa [update_same, ← v.apply_eq hi]\n    · rw [update_noteq (ne_of_mem_of_not_mem hj hi)]\n      exact v.closure_subset hj\n  · intro j hj\n    rw [mem_insert_iff, not_or] at hj\n    rw [update_noteq hj.1, v.apply_eq hj.2]\n  · refine' ⟨subset_insert _ _, fun j hj => _⟩\n    exact (update_noteq (ne_of_mem_of_not_mem hj hi) _ _).symm\n  · exact fun hle => hi (hle.1 <| mem_insert _ _)\n#align exists_gt exists_gt\n\n",
 "closure_subset":
 "theorem closure_subset (v : PartialRefinement u s) {i : ι} (hi : i ∈ v.carrier) : closure (v i) ⊆ u i :=\n  v.closure_subset' i hi\n#align closure_subset closure_subset\n\n",
 "apply_eq_of_chain":
 "/-- If two partial refinements `v₁`, `v₂` belong to a chain (hence, they are comparable)\nand `i` belongs to the carriers of both partial refinements, then `v₁ i = v₂ i`. -/\ntheorem apply_eq_of_chain {c : Set (PartialRefinement u s)} (hc : IsChain (· ≤ ·) c) {v₁ v₂} (h₁ : v₁ ∈ c) (h₂ : v₂ ∈ c)\n    {i} (hi₁ : i ∈ v₁.carrier) (hi₂ : i ∈ v₂.carrier) : v₁ i = v₂ i :=\n  by\n  wlog hle : v₁ ≤ v₂\n  · cases hc.total h₁ h₂ <;> [skip, symm] <;> apply_assumption <;> assumption'\n  exact hle.2 _ hi₁\n#align apply_eq_of_chain apply_eq_of_chain\n\n",
 "apply_eq":
 "theorem apply_eq (v : PartialRefinement u s) {i : ι} (hi : i ∉ v.carrier) : v i = u i :=\n  v.apply_eq' i hi\n#align apply_eq apply_eq\n\n",
 "IsOpen":
 "#print IsOpen /-\nprotected theorem IsOpen (v : PartialRefinement u s) (i : ι) : IsOpen (v i) :=\n  v.is_open' i\n#align is_open IsOpen\n-/\n\n"}