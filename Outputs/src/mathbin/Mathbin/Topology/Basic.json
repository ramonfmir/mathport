{"union":
 "#print IsClosed.union /-\ntheorem IsClosed.union : IsClosed s₁ → IsClosed s₂ → IsClosed (s₁ ∪ s₂) := fun h₁ h₂ =>\n  by\n  rw [← isOpen_compl_iff] at *\n  rw [compl_union]\n  exact IsOpen.inter h₁ h₂\n#align is_closed.union IsClosed.union\n-/\n\n",
 "topologicalSpace_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n#print topologicalSpace_eq_iff /-\ntheorem topologicalSpace_eq_iff {t t' : TopologicalSpace α} : t = t' ↔ ∀ s, (is_open_of t) s ↔ (is_open_of t') s :=\n  ⟨fun h s => h ▸ iff.rfl, fun h => by\n    ext\n    exact h _⟩\n#align topological_space_eq_iff topologicalSpace_eq_iff\n-/\n\n",
 "topologicalSpace_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n#print topologicalSpace_eq /-\n@[ext]\ntheorem topologicalSpace_eq {f g : TopologicalSpace α} (h : is_open_of f = is_open_of g) : f = g :=\n  by\n  cases f\n  cases g\n  congr\n  exact h\n#align topological_space_eq topologicalSpace_eq\n-/\n\n",
 "tendsto_pure_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_pure_nhds /-\ntheorem tendsto_pure_nhds {α : Type _} [TopologicalSpace β] (f : α → β) (a : α) : Tendsto f (pure a) ((nhds) (f a)) :=\n  (tendsto_pure_pure f a).mono_right (pure_le_nhds _)\n#align tendsto_pure_nhds tendsto_pure_nhds\n-/\n\n",
 "tendsto_nhds_limUnder":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_nhds_limUnder /-\n/-- If `g` tends to some `𝓝 a` along `f`, then it tends to `𝓝 (lim f g)`. We formulate\nthis lemma with a `[nonempty α]` argument of `lim` derived from `h` to make it useful for types\nwithout a `[nonempty α]` instance. Because of the built-in proof irrelevance, Lean will unify\nthis instance with any other instance. -/\ntheorem tendsto_nhds_limUnder {f : Filter β} {g : β → α} (h : ∃ a, Tendsto g f ((nhds) a)) :\n    Tendsto g f (nhds <| @limUnder _ _ _ (nonempty_of_exists h) f g) :=\n  le_nhds_lim h\n#align tendsto_nhds_lim tendsto_nhds_limUnder\n-/\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print tendsto_nhds /-\ntheorem tendsto_nhds {f : β → α} {l : Filter β} {a : α} :\n    Tendsto f l ((nhds) a) ↔ ∀ s, IsOpen s → a ∈ s → «expr ⁻¹' » f s ∈ l :=\n  all_mem_nhds_filter _ _ (fun s t h => preimage_mono h) _\n#align tendsto_nhds tendsto_nhds\n-/\n\n",
 "tendsto_inf_principal_nhds_iff_of_forall_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_inf_principal_nhds_iff_of_forall_eq /-\n/-- Suppose that `f` sends the complement to `s` to a single point `a`, and `l` is some filter.\nThen `f` tends to `a` along `l` restricted to `s` if and only if it tends to `a` along `l`. -/\ntheorem tendsto_inf_principal_nhds_iff_of_forall_eq {f : β → α} {l : Filter β} {s : Set β} {a : α}\n    (h : ∀ (x) (_ : x ∉ s), f x = a) :\n    Tendsto f («expr ⊓ » l ((filter.principal) s)) ((nhds) a) ↔ Tendsto f l ((nhds) a) :=\n  by\n  rw [tendsto_iff_comap, tendsto_iff_comap]\n  replace h : (filter.principal) («expr ᶜ» s) ≤ comap f ((nhds) a)\n  · rintro U ⟨t, ht, htU⟩ x hx\n    have : f x ∈ t := (h x hx).symm ▸ mem_of_mem_nhds ht\n    exact htU this\n  refine' ⟨fun h' => _, le_trans inf_le_left⟩\n  have := sup_le h' h\n  rw [sup_inf_right, sup_principal, union_compl_self, principal_univ, inf_top_eq, sup_le_iff] at this\n  exact this.1\n#align tendsto_inf_principal_nhds_iff_of_forall_eq tendsto_inf_principal_nhds_iff_of_forall_eq\n-/\n\n",
 "tendsto_const_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_const_nhds /-\ntheorem tendsto_const_nhds {a : α} {f : Filter β} : Tendsto (fun b : β => a) f ((nhds) a) :=\n  tendsto_nhds.mpr fun s hs ha => univ_mem' fun _ => ha\n#align tendsto_const_nhds tendsto_const_nhds\n-/\n\n",
 "tendsto_atTop_of_eventually_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_atTop_of_eventually_const /-\ntheorem tendsto_atTop_of_eventually_const {ι : Type _} [SemilatticeSup ι] [Nonempty ι] {x : α} {u : ι → α} {i₀ : ι}\n    (h : ∀ i ≥ i₀, u i = x) : Tendsto u atTop ((nhds) x) :=\n  Tendsto.congr' (EventuallyEq.symm (eventually_atTop.mpr ⟨i₀, h⟩)) tendsto_const_nhds\n#align tendsto_at_top_of_eventually_const tendsto_atTop_of_eventually_const\n-/\n\n",
 "tendsto_atTop_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print OrderTop.tendsto_atTop_nhds /-\ntheorem OrderTop.tendsto_atTop_nhds {α : Type _} [partial_order α] [OrderTop α] [TopologicalSpace β] (f : α → β) :\n    Tendsto f atTop (nhds <| f («expr⊤»)) :=\n  (tendsto_atTop_pure f).mono_right (pure_le_nhds _)\n#align order_top.tendsto_at_top_nhds OrderTop.tendsto_atTop_nhds\n-/\n\n",
 "tendsto_atBot_of_eventually_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_atBot_of_eventually_const /-\ntheorem tendsto_atBot_of_eventually_const {ι : Type _} [SemilatticeInf ι] [Nonempty ι] {x : α} {u : ι → α} {i₀ : ι}\n    (h : ∀ i ≤ i₀, u i = x) : Tendsto u atBot ((nhds) x) :=\n  Tendsto.congr' (EventuallyEq.symm (eventually_atBot.mpr ⟨i₀, h⟩)) tendsto_const_nhds\n#align tendsto_at_bot_of_eventually_const tendsto_atBot_of_eventually_const\n-/\n\n",
 "tendsto'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Continuous.tendsto' /-\n/-- A version of `continuous.tendsto` that allows one to specify a simpler form of the limit.\nE.g., one can write `continuous_exp.tendsto' 0 1 exp_zero`. -/\ntheorem Continuous.tendsto' {f : α → β} (hf : Continuous f) (x : α) (y : β) (h : f x = y) :\n    Tendsto f ((nhds) x) ((nhds) y) :=\n  h ▸ hf.tendsto x\n#align continuous.tendsto' Continuous.tendsto'\n-/\n\n",
 "tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Continuous.tendsto /-\ntheorem Continuous.tendsto {f : α → β} (hf : Continuous f) (x) : Tendsto f ((nhds) x) ((nhds) (f x)) :=\n  ((nhds_basis_opens x).tendsto_iff <| nhds_basis_opens <| f x).2 fun t ⟨hxt, ht⟩ =>\n    ⟨«expr ⁻¹' » f t, ⟨hxt, ht.preimage hf⟩, Subset.refl _⟩\n#align continuous.tendsto Continuous.tendsto\n-/\n\n",
 "subset_interior_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print subset_interior_iff_nhds /-\ntheorem subset_interior_iff_nhds {s V : Set α} : s ⊆ interior V ↔ ∀ x ∈ s, V ∈ (nhds) x :=\n  show (∀ x, x ∈ s → x ∈ _) ↔ _ by simp_rw [mem_interior_iff_mem_nhds]\n#align subset_interior_iff_nhds subset_interior_iff_nhds\n-/\n\n",
 "subset_interior_iff_isOpen":
 "#print subset_interior_iff_isOpen /-\ntheorem subset_interior_iff_isOpen {s : Set α} : s ⊆ interior s ↔ IsOpen s := by\n  simp only [interior_eq_iff_is_open.symm, subset.antisymm_iff, interior_subset, true_and_iff]\n#align subset_interior_iff_is_open subset_interior_iff_isOpen\n-/\n\n",
 "subset_interior_iff":
 "#print subset_interior_iff /-\ntheorem subset_interior_iff {s t : Set α} : t ⊆ interior s ↔ ∃ U, IsOpen U ∧ t ⊆ U ∧ U ⊆ s :=\n  ⟨fun h => ⟨interior s, isOpen_interior, h, interior_subset⟩, fun ⟨U, hU, htU, hUs⟩ =>\n    htU.trans (interior_maximal hUs hU)⟩\n#align subset_interior_iff subset_interior_iff\n-/\n\n",
 "subset_closure_image_preimage_of_isOpen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print DenseRange.subset_closure_image_preimage_of_isOpen /-\n/-- If `f` has dense range and `s` is an open set in the codomain of `f`, then the image of the\npreimage of `s` under `f` is dense in `s`. -/\ntheorem DenseRange.subset_closure_image_preimage_of_isOpen (hf : DenseRange f) {s : Set β} (hs : IsOpen s) :\n    s ⊆ closure («expr '' » f («expr ⁻¹' » f s)) :=\n  by\n  rw [image_preimage_eq_inter_range]\n  exact hf.open_subset_closure_inter hs\n#align dense_range.subset_closure_image_preimage_of_is_open DenseRange.subset_closure_image_preimage_of_isOpen\n-/\n\n",
 "subset_closure":
 "#print subset_closure /-\ntheorem subset_closure {s : Set α} : s ⊆ closure s :=\n  subset_interₛ fun t ⟨h₁, h₂⟩ => h₂\n#align subset_closure subset_closure\n-/\n\n",
 "self_of_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Eventually.self_of_nhds /-\n/-- If a predicate is true in a neighborhood of `a`, then it is true for `a`. -/\ntheorem Filter.Eventually.self_of_nhds {p : α → Prop} {a : α}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p y)) :\n    p a :=\n  mem_of_mem_nhds h\n#align filter.eventually.self_of_nhds Filter.Eventually.self_of_nhds\n-/\n\n",
 "self_diff_frontier":
 "#print self_diff_frontier /-\n@[simp]\ntheorem self_diff_frontier (s : Set α) : s \\ frontier s = interior s := by\n  rw [frontier, diff_diff_right, diff_eq_empty.2 subset_closure, inter_eq_self_of_subset_right interior_subset,\n    empty_union]\n#align self_diff_frontier self_diff_frontier\n-/\n\n",
 "sdiff":
 "#print IsClosed.sdiff /-\ntheorem IsClosed.sdiff {s t : Set α} (h₁ : IsClosed s) (h₂ : IsOpen t) : IsClosed (s \\ t) :=\n  IsClosed.inter h₁ (isClosed_compl_iff.mpr h₂)\n#align is_closed.sdiff IsClosed.sdiff\n-/\n\n",
 "range_subset_closure_image_dense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Continuous.range_subset_closure_image_dense /-\ntheorem Continuous.range_subset_closure_image_dense {f : α → β} (hf : Continuous f) {s : Set α} (hs : Dense s) :\n    range f ⊆ closure («expr '' » f s) := by\n  rw [← image_univ, ← hs.closure_eq]\n  exact image_closure_subset_closure_image hf\n#align continuous.range_subset_closure_image_dense Continuous.range_subset_closure_image_dense\n-/\n\n",
 "pure_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print pure_le_nhds /-\ntheorem pure_le_nhds : pure ≤ (nhds : α → Filter α) := fun a s hs => mem_pure.2 <| mem_of_mem_nhds hs\n#align pure_le_nhds pure_le_nhds\n-/\n\n",
 "preimage_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ContinuousAt.preimage_mem_nhds /-\ntheorem ContinuousAt.preimage_mem_nhds {f : α → β} {x : α} {t : Set β} (h : ContinuousAt f x) (ht : t ∈ (nhds) (f x)) :\n    «expr ⁻¹' » f t ∈ (nhds) x :=\n  h ht\n#align continuous_at.preimage_mem_nhds ContinuousAt.preimage_mem_nhds\n-/\n\n",
 "preimage_interior_subset_interior_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print preimage_interior_subset_interior_preimage /-\n/-- See also `interior_preimage_subset_preimage_interior`. -/\ntheorem preimage_interior_subset_interior_preimage {f : α → β} {s : Set β} (hf : Continuous f) :\n    «expr ⁻¹' » f (interior s) ⊆ interior («expr ⁻¹' » f s) :=\n  interior_maximal (preimage_mono interior_subset) (isOpen_interior.preimage hf)\n#align preimage_interior_subset_interior_preimage preimage_interior_subset_interior_preimage\n-/\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print IsClosed.preimage /-\ntheorem IsClosed.preimage {f : α → β} (hf : Continuous f) {s : Set β} (h : IsClosed s) : IsClosed («expr ⁻¹' » f s) :=\n  continuous_iff_isClosed.mp hf s h\n#align is_closed.preimage IsClosed.preimage\n-/\n\n",
 "open_subset_closure_inter":
 "#print Dense.open_subset_closure_inter /-\ntheorem Dense.open_subset_closure_inter {s t : Set α} (hs : Dense s) (ht : IsOpen t) : t ⊆ closure (t ∩ s) :=\n  calc\n    t = t ∩ closure s := by rw [hs.closure_eq, inter_univ]\n    _ ⊆ closure (t ∩ s) := ht.inter_closure\n    \n#align dense.open_subset_closure_inter Dense.open_subset_closure_inter\n-/\n\n",
 "of_nhds_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ClusterPt.of_nhds_le /-\ntheorem ClusterPt.of_nhds_le {x : α} {f : Filter α} (H : (nhds) x ≤ f) : ClusterPt x f := by\n  simp only [ClusterPt, inf_eq_left.mpr H, nhds_neBot]\n#align cluster_pt.of_nhds_le ClusterPt.of_nhds_le\n-/\n\n",
 "of_le_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ClusterPt.of_le_nhds' /-\ntheorem ClusterPt.of_le_nhds' {x : α} {f : Filter α} (H : f ≤ (nhds) x) (hf : NeBot f) : ClusterPt x f :=\n  ClusterPt.of_le_nhds H\n#align cluster_pt.of_le_nhds' ClusterPt.of_le_nhds'\n-/\n\n",
 "of_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ClusterPt.of_le_nhds /-\ntheorem ClusterPt.of_le_nhds {x : α} {f : Filter α} (H : f ≤ (nhds) x) [NeBot f] : ClusterPt x f := by\n  rwa [ClusterPt, inf_eq_right.mpr H]\n#align cluster_pt.of_le_nhds ClusterPt.of_le_nhds\n-/\n\n",
 "of_inf_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print ClusterPt.of_inf_right /-\ntheorem ClusterPt.of_inf_right {x : α} {f g : Filter α} (H : ClusterPt x <| «expr ⊓ » f g) : ClusterPt x g :=\n  H.mono inf_le_right\n#align cluster_pt.of_inf_right ClusterPt.of_inf_right\n-/\n\n",
 "of_inf_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print ClusterPt.of_inf_left /-\ntheorem ClusterPt.of_inf_left {x : α} {f g : Filter α} (H : ClusterPt x <| «expr ⊓ » f g) : ClusterPt x f :=\n  H.mono inf_le_left\n#align cluster_pt.of_inf_left ClusterPt.of_inf_left\n-/\n\n",
 "not_mem_of_not_mem_closure":
 "#print not_mem_of_not_mem_closure /-\ntheorem not_mem_of_not_mem_closure {s : Set α} {P : α} (hP : P ∉ closure s) : P ∉ s := fun h => hP (subset_closure h)\n#align not_mem_of_not_mem_closure not_mem_of_not_mem_closure\n-/\n\n",
 "not_isOpen_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n#print not_isOpen_singleton /-\ntheorem not_isOpen_singleton (x : α) [NeBot (nhds_within.ne x)] : ¬IsOpen ({x} : Set α) :=\n  dense_compl_singleton_iff_not_open.1 (dense_compl_singleton x)\n#align not_is_open_singleton not_isOpen_singleton\n-/\n\n",
 "not":
 "#print IsClosed.not /-\ntheorem IsClosed.not : IsClosed { a | p a } → IsOpen { a | ¬p a } :=\n  isOpen_compl_iff.mpr\n#align is_closed.not IsClosed.not\n-/\n\n",
 "nonempty_iff":
 "#print DenseRange.nonempty_iff /-\ntheorem DenseRange.nonempty_iff (hf : DenseRange f) : Nonempty κ ↔ Nonempty β :=\n  range_nonempty_iff_nonempty.symm.trans hf.nonempty_iff\n#align dense_range.nonempty_iff DenseRange.nonempty_iff\n-/\n\n",
 "nonempty":
 "#print DenseRange.nonempty /-\ntheorem DenseRange.nonempty [h : Nonempty β] (hf : DenseRange f) : Nonempty κ :=\n  hf.nonempty_iff.mpr h\n#align dense_range.nonempty DenseRange.nonempty\n-/\n\n",
 "nhds_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_le_of_le /-\n/-- To show a filter is above the neighborhood filter at `a`, it suffices to show that it is above\nthe principal filter of some open set `s` containing `a`. -/\ntheorem nhds_le_of_le {f a} {s : Set α} (h : a ∈ s) (o : IsOpen s) (sf : (filter.principal) s ≤ f) : (nhds) a ≤ f := by\n  rw [nhds_def] <;> exact infᵢ_le_of_le s (infᵢ_le_of_le ⟨h, o⟩ sf)\n#align nhds_le_of_le nhds_le_of_le\n-/\n\n",
 "nhds_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print nhds_def' /-\ntheorem nhds_def' (a : α) :\n    (nhds) a =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) s) :=\n  by simp only [nhds_def, mem_set_of_eq, and_comm' (a ∈ _), infᵢ_and]\n#align nhds_def' nhds_def'\n-/\n\n",
 "nhds_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print nhds_def /-\ntheorem nhds_def (a : α) :\n    (nhds) a =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) s) :=\n  by rw [nhds]\n#align nhds_def nhds_def\n-/\n\n",
 "nhds_bind_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_bind_nhds /-\n@[simp]\ntheorem nhds_bind_nhds : ((nhds) a).bind (nhds) = (nhds) a :=\n  Filter.ext fun s => eventually_eventually_nhds\n#align nhds_bind_nhds nhds_bind_nhds\n-/\n\n",
 "nhds_basis_opens'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_basis_opens' /-\n/-- The open neighborhoods of `a` are a basis for the neighborhood filter. See `nhds_basis_opens`\nfor a variant using open sets around `a` instead. -/\ntheorem nhds_basis_opens' (a : α) : ((nhds) a).has_basis (fun s : Set α => s ∈ (nhds) a ∧ IsOpen s) fun x => x :=\n  by\n  convert nhds_basis_opens a\n  ext s\n  exact and_congr_left_iff.2 IsOpen.mem_nhds_iff\n#align nhds_basis_opens' nhds_basis_opens'\n-/\n\n",
 "nhds_basis_opens":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_basis_opens /-\n/-- The open sets containing `a` are a basis for the neighborhood filter. See `nhds_basis_opens'`\nfor a variant using open neighborhoods instead. -/\ntheorem nhds_basis_opens (a : α) : ((nhds) a).has_basis (fun s : Set α => a ∈ s ∧ IsOpen s) fun s => s :=\n  by\n  rw [nhds_def]\n  exact\n    has_basis_binfi_principal\n      (fun s ⟨has, hs⟩ t ⟨hat, ht⟩ =>\n        ⟨s ∩ t, ⟨⟨has, hat⟩, IsOpen.inter hs ht⟩, ⟨inter_subset_left _ _, inter_subset_right _ _⟩⟩)\n      ⟨univ, ⟨mem_univ a, isOpen_univ⟩⟩\n#align nhds_basis_opens nhds_basis_opens\n-/\n\n",
 "nhds_basis_closeds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_basis_closeds /-\ntheorem nhds_basis_closeds (a : α) : ((nhds) a).has_basis (fun s : Set α => a ∉ s ∧ IsClosed s) compl :=\n  ⟨fun t =>\n    (nhds_basis_opens a).mem_iff.trans <|\n      compl_surjective.exists.trans <| by simp only [isOpen_compl_iff, mem_compl_iff]⟩\n#align nhds_basis_closeds nhds_basis_closeds\n-/\n\n",
 "neBot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ClusterPt.neBot /-\ntheorem ClusterPt.neBot {x : α} {F : Filter α} (h : ClusterPt x F) : NeBot («expr ⊓ » ((nhds) x) F) :=\n  h\n#align cluster_pt.ne_bot ClusterPt.neBot\n-/\n\n",
 "monotone_closure":
 "#print monotone_closure /-\ntheorem monotone_closure (α : Type _) [TopologicalSpace α] : Monotone (@closure α _) := fun _ _ => closure_mono\n#align monotone_closure monotone_closure\n-/\n\n",
 "mono":
 "#print AccPt.mono /-\n/-- If `x` is an accumulation point of `F` and `F ≤ G`, then\n`x` is an accumulation point of `D. -/\ntheorem AccPt.mono {x : α} {F G : Filter α} (h : AccPt x F) (hFG : F ≤ G) : AccPt x G :=\n  ⟨ne_bot_of_le_ne_bot h.ne (inf_le_inf_left _ hFG)⟩\n#align acc_pt.mono AccPt.mono\n-/\n\n",
 "mem_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n#print IsClosed.mem_of_tendsto /-\ntheorem IsClosed.mem_of_tendsto {f : β → α} {b : Filter β} {a : α} {s : Set α} [NeBot b] (hs : IsClosed s)\n    (hf : Tendsto f b ((nhds) a))\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" b\n        (f x ∈ s)) :\n    a ∈ s :=\n  hs.mem_of_frequently_of_tendsto h.frequently hf\n#align is_closed.mem_of_tendsto IsClosed.mem_of_tendsto\n-/\n\n",
 "mem_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_of_mem_nhds /-\ntheorem mem_of_mem_nhds {a : α} {s : Set α} : s ∈ (nhds) a → a ∈ s := fun H =>\n  let ⟨t, ht, _, hs⟩ := mem_nhds_iff.1 H\n  ht hs\n#align mem_of_mem_nhds mem_of_mem_nhds\n-/\n\n",
 "mem_of_frequently_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsClosed.mem_of_frequently_of_tendsto /-\ntheorem IsClosed.mem_of_frequently_of_tendsto {f : β → α} {b : Filter β} {a : α} {s : Set α} (hs : IsClosed s)\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" b\n        (f x ∈ s))\n    (hf : Tendsto f b ((nhds) a)) : a ∈ s :=\n  (hf.frequently <|\n        show\n          «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" b\n            ((fun y => y ∈ s) (f x))\n          from h).mem_of_closed\n    hs\n#align is_closed.mem_of_frequently_of_tendsto IsClosed.mem_of_frequently_of_tendsto\n-/\n\n",
 "mem_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Frequently.mem_of_closed /-\ntheorem Filter.Frequently.mem_of_closed {a : α} {s : Set α}\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" ((nhds) a)\n        (x ∈ s))\n    (hs : IsClosed s) : a ∈ s :=\n  hs.closure_subset h.mem_closure\n#align filter.frequently.mem_of_closed Filter.Frequently.mem_of_closed\n-/\n\n",
 "mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsOpen.mem_nhds_iff /-\ntheorem IsOpen.mem_nhds_iff {a : α} {s : Set α} (hs : IsOpen s) : s ∈ (nhds) a ↔ a ∈ s :=\n  ⟨mem_of_mem_nhds, fun ha => mem_nhds_iff.2 ⟨s, Subset.refl _, hs, ha⟩⟩\n#align is_open.mem_nhds_iff IsOpen.mem_nhds_iff\n-/\n\n",
 "mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print DenseRange.mem_nhds /-\ntheorem DenseRange.mem_nhds {f : κ → β} (h : DenseRange f) {b : β} {U : Set β} (U_in : U ∈ (nhds) b) : ∃ a, f a ∈ U :=\n  let ⟨a, ha⟩ := h.exists_mem_open isOpen_interior ⟨b, mem_interior_iff_mem_nhds.2 U_in⟩\n  ⟨a, interior_subset ha⟩\n#align dense_range.mem_nhds DenseRange.mem_nhds\n-/\n\n",
 "mem_interior_iff_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_interior_iff_mem_nhds /-\ntheorem mem_interior_iff_mem_nhds {s : Set α} {a : α} : a ∈ interior s ↔ s ∈ (nhds) a := by\n  rw [interior_eq_nhds', mem_set_of_eq]\n#align mem_interior_iff_mem_nhds mem_interior_iff_mem_nhds\n-/\n\n",
 "mem_interior":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\ntheorem mem_interior {s : Set α} {x : α} : x ∈ interior s ↔ ∃ (t : _)(_ : t ⊆ s), IsOpen t ∧ x ∈ t := by\n  simp only [interior, mem_sUnion, mem_set_of_eq, exists_prop, and_assoc', and_left_comm]\n#align mem_interior mem_interiorₓ\n\n",
 "mem_iff_closure_subset":
 "#print IsClosed.mem_iff_closure_subset /-\ntheorem IsClosed.mem_iff_closure_subset {s : Set α} (hs : IsClosed s) {x : α} : x ∈ s ↔ closure ({x} : Set α) ⊆ s :=\n  (hs.closure_subset_iff.trans Set.singleton_subset_iff).symm\n#align is_closed.mem_iff_closure_subset IsClosed.mem_iff_closure_subset\n-/\n\n",
 "mem_closure_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n#print mem_closure_of_tendsto /-\ntheorem mem_closure_of_tendsto {f : β → α} {b : Filter β} {a : α} {s : Set α} [NeBot b] (hf : Tendsto f b ((nhds) a))\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" b\n        (f x ∈ s)) :\n    a ∈ closure s :=\n  mem_closure_of_frequently_of_tendsto h.frequently hf\n#align mem_closure_of_tendsto mem_closure_of_tendsto\n-/\n\n",
 "mem_closure_of_mem_closure_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_of_mem_closure_union /-\ntheorem mem_closure_of_mem_closure_union {s₁ s₂ : Set α} {x : α} (h : x ∈ closure (s₁ ∪ s₂))\n    (h₁ : «expr ᶜ» s₁ ∈ (nhds) x) : x ∈ closure s₂ :=\n  by\n  rw [mem_closure_iff_nhds_neBot] at *\n  rwa [←\n    calc\n      «expr ⊓ » ((nhds) x) (principal (s₁ ∪ s₂)) = «expr ⊓ » ((nhds) x) («expr ⊔ » (principal s₁) (principal s₂)) := by\n        rw [sup_principal]\n      _ = «expr ⊔ » («expr ⊓ » ((nhds) x) (principal s₁)) («expr ⊓ » ((nhds) x) (principal s₂)) := inf_sup_left\n      _ = «expr ⊔ » («expr⊥») («expr ⊓ » ((nhds) x) (principal s₂)) := by rw [inf_principal_eq_bot.mpr h₁]\n      _ = «expr ⊓ » ((nhds) x) (principal s₂) := bot_sup_eq\n      ]\n#align mem_closure_of_mem_closure_union mem_closure_of_mem_closure_union\n-/\n\n",
 "mem_closure_of_frequently_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_of_frequently_of_tendsto /-\ntheorem mem_closure_of_frequently_of_tendsto {f : β → α} {b : Filter β} {a : α} {s : Set α}\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" b\n        (f x ∈ s))\n    (hf : Tendsto f b ((nhds) a)) : a ∈ closure s :=\n  Filter.Frequently.mem_closure <| hf.frequently h\n#align mem_closure_of_frequently_of_tendsto mem_closure_of_frequently_of_tendsto\n-/\n\n",
 "mem_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print mem_closure_image /-\ntheorem mem_closure_image {f : α → β} {x : α} {s : Set α} (hf : ContinuousAt f x) (hx : x ∈ closure s) :\n    f x ∈ closure («expr '' » f s) :=\n  mem_closure_of_frequently_of_tendsto ((mem_closure_iff_frequently.1 hx).mono fun x => mem_image_of_mem _) hf\n#align mem_closure_image mem_closure_image\n-/\n\n",
 "mem_closure_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_ultrafilter /-\n/-- `x` belongs to the closure of `s` if and only if some ultrafilter\n  supported on `s` converges to `x`. -/\ntheorem mem_closure_iff_ultrafilter {s : Set α} {x : α} : x ∈ closure s ↔ ∃ u : Ultrafilter α, s ∈ u ∧ ↑u ≤ (nhds) x :=\n  by simp [closure_eq_cluster_pts, ClusterPt, ← exists_ultrafilter_iff, and_comm]\n#align mem_closure_iff_ultrafilter mem_closure_iff_ultrafilter\n-/\n\n",
 "mem_closure_iff_nhds_neBot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print mem_closure_iff_nhds_neBot /-\ntheorem mem_closure_iff_nhds_neBot {s : Set α} :\n    a ∈ closure s ↔ «expr ⊓ » ((nhds) a) ((filter.principal) s) ≠ «expr⊥» :=\n  mem_closure_iff_clusterPt.trans neBot_iff\n#align mem_closure_iff_nhds_ne_bot mem_closure_iff_nhds_neBot\n-/\n\n",
 "mem_closure_iff_nhds_basis'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_nhds_basis' /-\ntheorem mem_closure_iff_nhds_basis' {a : α} {p : ι → Prop} {s : ι → Set α} (h : ((nhds) a).has_basis p s) {t : Set α} :\n    a ∈ closure t ↔ ∀ i, p i → (s i ∩ t).nonempty :=\n  mem_closure_iff_clusterPt.trans <|\n    (h.cluster_pt_iff (hasBasis_principal _)).trans <| by simp only [exists_prop, forall_const]\n#align mem_closure_iff_nhds_basis' mem_closure_iff_nhds_basis'\n-/\n\n",
 "mem_closure_iff_nhds_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_nhds_basis /-\ntheorem mem_closure_iff_nhds_basis {a : α} {p : ι → Prop} {s : ι → Set α} (h : ((nhds) a).has_basis p s) {t : Set α} :\n    a ∈ closure t ↔ ∀ i, p i → ∃ y ∈ t, y ∈ s i :=\n  (mem_closure_iff_nhds_basis' h).trans <| by simp only [Set.Nonempty, mem_inter_iff, exists_prop, and_comm']\n#align mem_closure_iff_nhds_basis mem_closure_iff_nhds_basis\n-/\n\n",
 "mem_closure_iff_nhdsWithin_neBot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print mem_closure_iff_nhdsWithin_neBot /-\ntheorem mem_closure_iff_nhdsWithin_neBot {s : Set α} {x : α} : x ∈ closure s ↔ NeBot (nhds_within s x) :=\n  mem_closure_iff_clusterPt\n#align mem_closure_iff_nhds_within_ne_bot mem_closure_iff_nhdsWithin_neBot\n-/\n\n",
 "mem_closure_iff_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_nhds' /-\ntheorem mem_closure_iff_nhds' {s : Set α} {a : α} : a ∈ closure s ↔ ∀ t ∈ (nhds) a, ∃ y : s, ↑y ∈ t := by\n  simp only [mem_closure_iff_nhds, Set.inter_nonempty_iff_exists_right, SetCoe.exists, Subtype.coe_mk]\n#align mem_closure_iff_nhds' mem_closure_iff_nhds'\n-/\n\n",
 "mem_closure_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_nhds /-\ntheorem mem_closure_iff_nhds {s : Set α} {a : α} : a ∈ closure s ↔ ∀ t ∈ (nhds) a, (t ∩ s).nonempty :=\n  mem_closure_iff_clusterPt.trans clusterPt_principal_iff\n#align mem_closure_iff_nhds mem_closure_iff_nhds\n-/\n\n",
 "mem_closure_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_frequently /-\ntheorem mem_closure_iff_frequently {s : Set α} {a : α} :\n    a ∈ closure s ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" ((nhds) a)\n        (x ∈ s) :=\n  by rw [Filter.Frequently, Filter.Eventually, ← mem_interior_iff_mem_nhds, closure_eq_compl_interior_compl] <;> rfl\n#align mem_closure_iff_frequently mem_closure_iff_frequently\n-/\n\n",
 "mem_closure_iff_comap_neBot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_comap_neBot /-\ntheorem mem_closure_iff_comap_neBot {A : Set α} {x : α} : x ∈ closure A ↔ NeBot (comap (coe : A → α) ((nhds) x)) := by\n  simp_rw [mem_closure_iff_nhds, comap_ne_bot_iff, Set.inter_nonempty_iff_exists_right, SetCoe.exists, Subtype.coe_mk]\n#align mem_closure_iff_comap_ne_bot mem_closure_iff_comap_neBot\n-/\n\n",
 "mem_closure_iff_clusterPt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print mem_closure_iff_clusterPt /-\ntheorem mem_closure_iff_clusterPt {s : Set α} {a : α} : a ∈ closure s ↔ ClusterPt a ((filter.principal) s) :=\n  mem_closure_iff_frequently.trans clusterPt_principal_iff_frequently.symm\n#align mem_closure_iff_cluster_pt mem_closure_iff_clusterPt\n-/\n\n",
 "mem_closure_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print mem_closure_iff /-\ntheorem mem_closure_iff {s : Set α} {a : α} : a ∈ closure s ↔ ∀ o, IsOpen o → a ∈ o → (o ∩ s).nonempty :=\n  ⟨fun h o oo ao =>\n    by_contradiction fun os =>\n      have : s ⊆ «expr ᶜ» o := fun x xs xo => os ⟨x, xo, xs⟩\n      closure_minimal this (isClosed_compl_iff.2 oo) h ao,\n    fun H c ⟨h₁, h₂⟩ =>\n    by_contradiction fun nc =>\n      let ⟨x, hc, hs⟩ := H _ h₁.is_open_compl nc\n      hc (h₂ hs)⟩\n#align mem_closure_iff mem_closure_iff\n-/\n\n",
 "map_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print map_nhds /-\ntheorem map_nhds {a : α} {f : α → β} :\n    map f ((nhds) a) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (image f s)) :=\n  ((nhds_basis_opens a).map f).eq_binfi\n#align map_nhds map_nhds\n-/\n\n",
 "map_mem_closure":
 "#print map_mem_closure /-\ntheorem map_mem_closure {s : Set α} {t : Set β} {f : α → β} {a : α} (hf : Continuous f) (ha : a ∈ closure s)\n    (ht : MapsTo f s t) : f a ∈ closure t :=\n  ht.closure hf ha\n#align map_mem_closure map_mem_closure\n-/\n\n",
 "mapClusterPt_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mapClusterPt_of_comp /-\ntheorem mapClusterPt_of_comp {ι δ : Type _} {F : Filter ι} {φ : δ → ι} {p : Filter δ} {x : α} {u : ι → α} [NeBot p]\n    (h : Tendsto φ p F) (H : Tendsto (u ∘ φ) p ((nhds) x)) : MapClusterPt x F u :=\n  by\n  have :=\n    calc\n      map (u ∘ φ) p = map u (map φ p) := map_map\n      _ ≤ map u F := map_mono h\n      \n  have : map (u ∘ φ) p ≤ «expr ⊓ » ((nhds) x) (map u F) := le_inf H this\n  exact ne_bot_of_le this\n#align map_cluster_pt_of_comp mapClusterPt_of_comp\n-/\n\n",
 "mapClusterPt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n#print mapClusterPt_iff /-\ntheorem mapClusterPt_iff {ι : Type _} (x : α) (F : Filter ι) (u : ι → α) :\n    MapClusterPt x F u ↔\n      ∀ s ∈ (nhds) x,\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" F\n          (u a ∈ s) :=\n  by\n  simp_rw [MapClusterPt, ClusterPt, inf_ne_bot_iff_frequently_left, frequently_map]\n  rfl\n#align map_cluster_pt_iff mapClusterPt_iff\n-/\n\n",
 "map":
 "#print ClusterPt.map /-\ntheorem ClusterPt.map {x : α} {la : Filter α} {lb : Filter β} (H : ClusterPt x la) {f : α → β} (hfc : ContinuousAt f x)\n    (hf : Tendsto f la lb) : ClusterPt (f x) lb :=\n  ⟨ne_bot_of_le_ne_bot ((map_neBot_iff f).2 H).ne <| hfc.tendsto.inf hf⟩\n#align cluster_pt.map ClusterPt.map\n-/\n\n",
 "lift'_closure_eq_self":
 "#print Filter.HasBasis.lift'_closure_eq_self /-\ntheorem Filter.HasBasis.lift'_closure_eq_self {l : Filter α} {p : ι → Prop} {s : ι → Set α} (h : l.has_basis p s)\n    (hc : ∀ i, p i → IsClosed (s i)) : l.lift' closure = l :=\n  le_antisymm (h.ge_iff.2 fun i hi => (hc i hi).closure_eq ▸ mem_lift' (h.mem_of_mem hi)) l.le_lift'_closure\n#align filter.has_basis.lift'_closure_eq_self Filter.HasBasis.lift'_closure_eq_self\n-/\n\n",
 "lift'_closure_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Filter.lift'_closure_eq_bot /-\n@[simp]\ntheorem Filter.lift'_closure_eq_bot {l : Filter α} : l.lift' closure = «expr⊥» ↔ l = «expr⊥» :=\n  ⟨fun h => bot_unique <| h ▸ l.le_lift'_closure, fun h =>\n    h.symm ▸ by rw [lift'_bot (monotone_closure _), closure_empty, principal_empty]⟩\n#align filter.lift'_closure_eq_bot Filter.lift'_closure_eq_bot\n-/\n\n",
 "lift'_closure":
 "#print Filter.HasBasis.lift'_closure /-\ntheorem Filter.HasBasis.lift'_closure {l : Filter α} {p : ι → Prop} {s : ι → Set α} (h : l.has_basis p s) :\n    (l.lift' closure).has_basis p fun i => closure (s i) :=\n  h.lift' (monotone_closure α)\n#align filter.has_basis.lift'_closure Filter.HasBasis.lift'_closure\n-/\n\n",
 "le_nhds_lim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print le_nhds_lim /-\n/-- If a filter `f` is majorated by some `𝓝 a`, then it is majorated by `𝓝 (Lim f)`. We formulate\nthis lemma with a `[nonempty α]` argument of `Lim` derived from `h` to make it useful for types\nwithout a `[nonempty α]` instance. Because of the built-in proof irrelevance, Lean will unify\nthis instance with any other instance. -/\ntheorem le_nhds_lim {f : Filter α} (h : ∃ a, f ≤ (nhds) a) : f ≤ (nhds) (@lim _ _ (nonempty_of_exists h) f) :=\n  epsilon_spec h\n#align le_nhds_Lim le_nhds_lim\n-/\n\n",
 "le_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print le_nhds_iff /-\n/-- A filter lies below the neighborhood filter at `a` iff it contains every open set around `a`. -/\ntheorem le_nhds_iff {f a} : f ≤ (nhds) a ↔ ∀ s : Set α, a ∈ s → IsOpen s → s ∈ f := by simp [nhds_def]\n#align le_nhds_iff le_nhds_iff\n-/\n\n",
 "le_lift'_closure":
 "#print Filter.le_lift'_closure /-\ntheorem Filter.le_lift'_closure (l : Filter α) : l ≤ l.lift' closure :=\n  le_lift'.2 fun s hs => mem_of_superset hs subset_closure\n#align filter.le_lift'_closure Filter.le_lift'_closure\n-/\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n#print ContinuousAt.iterate /-\ntheorem ContinuousAt.iterate {f : α → α} {x : α} (hf : ContinuousAt f x) (hx : f x = x) (n : ℕ) :\n    ContinuousAt («expr ^[ ]» f n) x :=\n  nat.rec_on n continuousAt_id fun n ihn =>\n    show ContinuousAt («expr ^[ ]» f n ∘ f) x from ContinuousAt.comp (hx.symm ▸ ihn) hf\n#align continuous_at.iterate ContinuousAt.iterate\n-/\n\n",
 "isOpen_univ":
 "#print isOpen_univ /-\n@[simp]\ntheorem isOpen_univ : IsOpen (univ : Set α) :=\n  topological_space.is_open_univ\n#align is_open_univ isOpen_univ\n-/\n\n",
 "isOpen_unionₛ":
 "#print isOpen_unionₛ /-\ntheorem isOpen_unionₛ {s : Set (Set α)} (h : ∀ t ∈ s, IsOpen t) : IsOpen (⋃₀ s) :=\n  topological_space.is_open_sUnion s h\n#align is_open_sUnion isOpen_unionₛ\n-/\n\n",
 "isOpen_unionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isOpen_unionᵢ /-\ntheorem isOpen_unionᵢ {f : ι → Set α} (h : ∀ i, IsOpen (f i)) :\n    IsOpen («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  isOpen_unionₛ <| by rintro _ ⟨i, rfl⟩ <;> exact h i\n#align is_open_Union isOpen_unionᵢ\n-/\n\n",
 "isOpen_singleton_iff_punctured_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print isOpen_singleton_iff_punctured_nhds /-\ntheorem isOpen_singleton_iff_punctured_nhds {α : Type _} [TopologicalSpace α] (a : α) :\n    IsOpen ({a} : Set α) ↔ nhds_within.ne a = «expr⊥» := by\n  rw [isOpen_singleton_iff_nhds_eq_pure, nhdsWithin, ← mem_iff_inf_principal_compl, ← le_pure_iff,\n    nhds_ne_bot.le_pure_iff]\n#align is_open_singleton_iff_punctured_nhds isOpen_singleton_iff_punctured_nhds\n-/\n\n",
 "isOpen_singleton_iff_nhds_eq_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isOpen_singleton_iff_nhds_eq_pure /-\ntheorem isOpen_singleton_iff_nhds_eq_pure (a : α) : IsOpen ({a} : Set α) ↔ (nhds) a = pure a :=\n  by\n  constructor\n  · intro h\n    apply le_antisymm _ (pure_le_nhds a)\n    rw [le_pure_iff]\n    exact h.mem_nhds (mem_singleton a)\n  · intro h\n    simp [isOpen_iff_nhds, h]\n#align is_open_singleton_iff_nhds_eq_pure isOpen_singleton_iff_nhds_eq_pure\n-/\n\n",
 "isOpen_setOf_eventually_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isOpen_setOf_eventually_nhds /-\ntheorem isOpen_setOf_eventually_nhds {p : α → Prop} :\n    IsOpen\n      { x |\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          ((nhds) x) (p y) } :=\n  by simp only [← interior_setOf_eq, isOpen_interior]\n#align is_open_set_of_eventually_nhds isOpen_setOf_eventually_nhds\n-/\n\n",
 "isOpen_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n#print isOpen_mk /-\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Jeremy Avigad\n-/\ntheorem isOpen_mk {p h₁ h₂ h₃} {s : Set α} : (is_open_of ⟨p, h₁, h₂, h₃⟩) s ↔ p s :=\n  iff.rfl\n#align is_open_mk isOpen_mk\n-/\n\n",
 "isOpen_interₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n#print isOpen_interₛ /-\ntheorem isOpen_interₛ {s : Set (Set α)} (hs : s.finite) : (∀ t ∈ s, IsOpen t) → IsOpen («expr⋂₀ » s) :=\n  Finite.induction_on hs (fun _ => by rw [sInter_empty] <;> exact isOpen_univ) fun a s has hs ih h => by\n    rw [sInter_insert] <;> exact IsOpen.inter (h _ <| mem_insert _ _) (ih fun t => h t ∘ mem_insert_of_mem _)\n#align is_open_sInter isOpen_interₛ\n-/\n\n",
 "isOpen_interᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print isOpen_interᵢ /-\ntheorem isOpen_interᵢ [Finite ι] {s : ι → Set α} (h : ∀ i, IsOpen (s i)) :\n    IsOpen («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)) :=\n  isOpen_interₛ (finite_range _) (forall_range_iff.2 h)\n#align is_open_Inter isOpen_interᵢ\n-/\n\n",
 "isOpen_interior":
 "#print isOpen_interior /-\n@[simp]\ntheorem isOpen_interior {s : Set α} : IsOpen (interior s) :=\n  isOpen_unionₛ fun t ⟨h₁, h₂⟩ => h₁\n#align is_open_interior isOpen_interior\n-/\n\n",
 "isOpen_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isOpen_iff_ultrafilter /-\ntheorem isOpen_iff_ultrafilter {s : Set α} : IsOpen s ↔ ∀ x ∈ s, ∀ (l : Ultrafilter α), ↑l ≤ (nhds) x → s ∈ l := by\n  simp_rw [isOpen_iff_mem_nhds, ← mem_iff_ultrafilter]\n#align is_open_iff_ultrafilter isOpen_iff_ultrafilter\n-/\n\n",
 "isOpen_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print isOpen_iff_nhds /-\ntheorem isOpen_iff_nhds {s : Set α} : IsOpen s ↔ ∀ a ∈ s, (nhds) a ≤ (filter.principal) s :=\n  calc\n    IsOpen s ↔ s ⊆ interior s := subset_interior_iff_isOpen.symm\n    _ ↔ ∀ a ∈ s, (nhds) a ≤ (filter.principal) s := by rw [interior_eq_nhds] <;> rfl\n    \n#align is_open_iff_nhds isOpen_iff_nhds\n-/\n\n",
 "isOpen_iff_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isOpen_iff_mem_nhds /-\ntheorem isOpen_iff_mem_nhds {s : Set α} : IsOpen s ↔ ∀ a ∈ s, s ∈ (nhds) a :=\n  isOpen_iff_nhds.trans <| forall_congr' fun _ => imp_congr_right fun _ => le_principal_iff\n#align is_open_iff_mem_nhds isOpen_iff_mem_nhds\n-/\n\n",
 "isOpen_iff_forall_mem_open":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n#print isOpen_iff_forall_mem_open /-\ntheorem isOpen_iff_forall_mem_open : IsOpen s ↔ ∀ x ∈ s, ∃ (t : _)(_ : t ⊆ s), IsOpen t ∧ x ∈ t := by\n  rw [← subset_interior_iff_isOpen] <;> simp only [subset_def, mem_interior]\n#align is_open_iff_forall_mem_open isOpen_iff_forall_mem_open\n-/\n\n",
 "isOpen_iff_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isOpen_iff_eventually /-\n/-- A set `s` is open iff for every point `x` in `s` and every `y` close to `x`, `y` is in `s`. -/\ntheorem isOpen_iff_eventually {s : Set α} :\n    IsOpen s ↔\n      ∀ x,\n        x ∈ s →\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n            ((nhds) x) (y ∈ s) :=\n  isOpen_iff_mem_nhds\n#align is_open_iff_eventually isOpen_iff_eventually\n-/\n\n",
 "isOpen_fold":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n#print isOpen_fold /-\ntheorem isOpen_fold {s : Set α} {t : TopologicalSpace α} : t.is_open s = (is_open_of t) s :=\n  rfl\n#align is_open_fold isOpen_fold\n-/\n\n",
 "isOpen_empty":
 "#print isOpen_empty /-\n@[simp]\ntheorem isOpen_empty : IsOpen (∅ : Set α) := by rw [← sUnion_empty] <;> exact isOpen_unionₛ fun a => false.elim\n#align is_open_empty isOpen_empty\n-/\n\n",
 "isOpen_const":
 "#print isOpen_const /-\ntheorem isOpen_const {p : Prop} : IsOpen { a : α | p } :=\n  by_cases (fun this : p => by simp only [this] <;> exact isOpen_univ) fun this : ¬p => by\n    simp only [this] <;> exact isOpen_empty\n#align is_open_const isOpen_const\n-/\n\n",
 "isOpen_compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print isOpen_compl_iff /-\n@[simp]\ntheorem isOpen_compl_iff {s : Set α} : IsOpen («expr ᶜ» s) ↔ IsClosed s :=\n  ⟨fun h => ⟨h⟩, fun h => h.is_open_compl⟩\n#align is_open_compl_iff isOpen_compl_iff\n-/\n\n",
 "isOpen_bunionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isOpen_bunionᵢ /-\ntheorem isOpen_bunionᵢ {s : Set β} {f : β → Set α} (h : ∀ i ∈ s, IsOpen (f i)) :\n    IsOpen («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  isOpen_unionᵢ fun i => isOpen_unionᵢ fun hi => h i hi\n#align is_open_bUnion isOpen_bunionᵢ\n-/\n\n",
 "isOpen_binterᵢ_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print isOpen_binterᵢ_finset /-\ntheorem isOpen_binterᵢ_finset {s : Finset β} {f : β → Set α} (h : ∀ i ∈ s, IsOpen (f i)) :\n    IsOpen («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  isOpen_binterᵢ (toFinite _) h\n#align is_open_bInter_finset isOpen_binterᵢ_finset\n-/\n\n",
 "isOpen_binterᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print isOpen_binterᵢ /-\ntheorem isOpen_binterᵢ {s : Set β} {f : β → Set α} (hs : s.finite) :\n    (∀ i ∈ s, IsOpen (f i)) →\n      IsOpen («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  Finite.induction_on hs (fun _ => by rw [bInter_empty] <;> exact isOpen_univ) fun a s has hs ih h => by\n    rw [bInter_insert] <;> exact IsOpen.inter (h a (mem_insert _ _)) (ih fun i hi => h i (mem_insert_of_mem _ hi))\n#align is_open_bInter isOpen_binterᵢ\n-/\n\n",
 "isClosed_univ":
 "#print isClosed_univ /-\n@[simp]\ntheorem isClosed_univ : IsClosed (univ : Set α) :=\n  by\n  rw [← isOpen_compl_iff, compl_univ]\n  exact isOpen_empty\n#align is_closed_univ isClosed_univ\n-/\n\n",
 "isClosed_unionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isClosed_unionᵢ /-\ntheorem isClosed_unionᵢ [Finite ι] {s : ι → Set α} (h : ∀ i, IsClosed (s i)) :\n    IsClosed («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  by\n  simp only [← isOpen_compl_iff, compl_Union] at *\n  exact isOpen_interᵢ h\n#align is_closed_Union isClosed_unionᵢ\n-/\n\n",
 "isClosed_setOf_clusterPt":
 "#print isClosed_setOf_clusterPt /-\n/-- The set of cluster points of a filter is closed. In particular, the set of limit points\nof a sequence is closed. -/\ntheorem isClosed_setOf_clusterPt {f : Filter α} : IsClosed { x | ClusterPt x f } :=\n  by\n  simp only [ClusterPt, inf_ne_bot_iff_frequently_left, set_of_forall, imp_iff_not_or]\n  refine' isClosed_interᵢ fun p => IsClosed.union _ _ <;> apply isClosed_compl_iff.2\n  exacts[isOpen_setOf_eventually_nhds, isOpen_const]\n#align is_closed_set_of_cluster_pt isClosed_setOf_clusterPt\n-/\n\n",
 "isClosed_of_closure_subset":
 "#print isClosed_of_closure_subset /-\ntheorem isClosed_of_closure_subset {s : Set α} (h : closure s ⊆ s) : IsClosed s := by\n  rw [subset.antisymm subset_closure h] <;> exact isClosed_closure\n#align is_closed_of_closure_subset isClosed_of_closure_subset\n-/\n\n",
 "isClosed_interₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n#print isClosed_interₛ /-\ntheorem isClosed_interₛ {s : Set (Set α)} : (∀ t ∈ s, IsClosed t) → IsClosed («expr⋂₀ » s) := by\n  simpa only [← isOpen_compl_iff, compl_sInter, sUnion_image] using isOpen_bunionᵢ\n#align is_closed_sInter isClosed_interₛ\n-/\n\n",
 "isClosed_interᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print isClosed_interᵢ /-\ntheorem isClosed_interᵢ {f : ι → Set α} (h : ∀ i, IsClosed (f i)) :\n    IsClosed («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  isClosed_interₛ fun t ⟨i, (HEq : f i = t)⟩ => HEq ▸ h i\n#align is_closed_Inter isClosed_interᵢ\n-/\n\n",
 "isClosed_imp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print isClosed_imp /-\ntheorem isClosed_imp {p q : α → Prop} (hp : IsOpen { x | p x }) (hq : IsClosed { x | q x }) :\n    IsClosed { x | p x → q x } :=\n  by\n  have : { x | p x → q x } = «expr ᶜ» { x | p x } ∪ { x | q x } := Set.ext fun x => imp_iff_not_or\n  rw [this] <;> exact IsClosed.union (is_closed_compl_iff.mpr hp) hq\n#align is_closed_imp isClosed_imp\n-/\n\n",
 "isClosed_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isClosed_iff_nhds /-\ntheorem isClosed_iff_nhds {s : Set α} : IsClosed s ↔ ∀ x, (∀ U ∈ (nhds) x, (U ∩ s).nonempty) → x ∈ s := by\n  simp_rw [isClosed_iff_clusterPt, ClusterPt, inf_principal_ne_bot_iff]\n#align is_closed_iff_nhds isClosed_iff_nhds\n-/\n\n",
 "isClosed_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isClosed_iff_frequently /-\n/-- A set `s` is closed iff for every point `x`, if there is a point `y` close to `x` that belongs\nto `s` then `x` is in `s`. -/\ntheorem isClosed_iff_frequently {s : Set α} :\n    IsClosed s ↔\n      ∀ x,\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n            ((nhds) x) (y ∈ s) →\n          x ∈ s :=\n  by\n  rw [← closure_subset_iff_isClosed]\n  apply forall_congr' fun x => _\n  rw [mem_closure_iff_frequently]\n#align is_closed_iff_frequently isClosed_iff_frequently\n-/\n\n",
 "isClosed_iff_clusterPt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print isClosed_iff_clusterPt /-\ntheorem isClosed_iff_clusterPt {s : Set α} : IsClosed s ↔ ∀ a, ClusterPt a ((filter.principal) s) → a ∈ s :=\n  calc\n    IsClosed s ↔ closure s ⊆ s := closure_subset_iff_isClosed.symm\n    _ ↔ ∀ a, ClusterPt a ((filter.principal) s) → a ∈ s := by simp only [subset_def, mem_closure_iff_clusterPt]\n    \n#align is_closed_iff_cluster_pt isClosed_iff_clusterPt\n-/\n\n",
 "isClosed_frontier":
 "#print isClosed_frontier /-\n/-- The frontier of a set is closed. -/\ntheorem isClosed_frontier {s : Set α} : IsClosed (frontier s) := by\n  rw [frontier_eq_closure_inter_closure] <;> exact IsClosed.inter isClosed_closure isClosed_closure\n#align is_closed_frontier isClosed_frontier\n-/\n\n",
 "isClosed_empty":
 "#print isClosed_empty /-\n@[simp]\ntheorem isClosed_empty : IsClosed (∅ : Set α) :=\n  by\n  rw [← isOpen_compl_iff, compl_empty]\n  exact isOpen_univ\n#align is_closed_empty isClosed_empty\n-/\n\n",
 "isClosed_compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print isClosed_compl_iff /-\n@[simp]\ntheorem isClosed_compl_iff {s : Set α} : IsClosed («expr ᶜ» s) ↔ IsOpen s := by rw [← isOpen_compl_iff, compl_compl]\n#align is_closed_compl_iff isClosed_compl_iff\n-/\n\n",
 "isClosed_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print IsOpen.isClosed_compl /-\ntheorem IsOpen.isClosed_compl {s : Set α} (hs : IsOpen s) : IsClosed («expr ᶜ» s) :=\n  isClosed_compl_iff.2 hs\n#align is_open.is_closed_compl IsOpen.isClosed_compl\n-/\n\n",
 "isClosed_closure":
 "#print isClosed_closure /-\n@[simp]\ntheorem isClosed_closure {s : Set α} : IsClosed (closure s) :=\n  isClosed_interₛ fun t ⟨h₁, h₂⟩ => h₁\n#align is_closed_closure isClosed_closure\n-/\n\n",
 "isClosed_bunionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print isClosed_bunionᵢ /-\ntheorem isClosed_bunionᵢ {s : Set β} {f : β → Set α} (hs : s.finite) :\n    (∀ i ∈ s, IsClosed (f i)) →\n      IsClosed\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  Finite.induction_on hs (fun _ => by rw [bUnion_empty] <;> exact isClosed_empty) fun a s has hs ih h => by\n    rw [bUnion_insert] <;> exact IsClosed.union (h a (mem_insert _ _)) (ih fun i hi => h i (mem_insert_of_mem _ hi))\n#align is_closed_bUnion isClosed_bunionᵢ\n-/\n\n",
 "isClosed_binterᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print isClosed_binterᵢ /-\ntheorem isClosed_binterᵢ {s : Set β} {f : β → Set α} (h : ∀ i ∈ s, IsClosed (f i)) :\n    IsClosed («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  isClosed_interᵢ fun i => isClosed_interᵢ <| h i\n#align is_closed_bInter isClosed_binterᵢ\n-/\n\n",
 "interior_univ":
 "#print interior_univ /-\n@[simp]\ntheorem interior_univ : interior (univ : Set α) = univ :=\n  isOpen_univ.interior_eq\n#align interior_univ interior_univ\n-/\n\n",
 "interior_union_right":
 "#print IsClosed.interior_union_right /-\ntheorem IsClosed.interior_union_right {s t : Set α} (h : IsClosed t) : interior (s ∪ t) ⊆ interior s ∪ t := by\n  simpa only [union_comm] using h.interior_union_left\n#align is_closed.interior_union_right IsClosed.interior_union_right\n-/\n\n",
 "interior_union_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print IsClosed.interior_union_left /-\ntheorem IsClosed.interior_union_left {s t : Set α} (h : IsClosed s) : interior (s ∪ t) ⊆ s ∪ interior t :=\n  fun a ⟨u, ⟨⟨hu₁, hu₂⟩, ha⟩⟩ =>\n  (classical.em (a ∈ s)).imp_right fun h =>\n    mem_interior.mpr\n      ⟨u ∩ «expr ᶜ» s, fun x hx => (hu₂ hx.1).resolve_left hx.2, IsOpen.inter hu₁ is_closed.is_open_compl, ⟨ha, h⟩⟩\n#align is_closed.interior_union_left IsClosed.interior_union_left\n-/\n\n",
 "interior_union_isClosed_of_interior_empty":
 "#print interior_union_isClosed_of_interior_empty /-\ntheorem interior_union_isClosed_of_interior_empty {s t : Set α} (h₁ : IsClosed s) (h₂ : interior t = ∅) :\n    interior (s ∪ t) = interior s :=\n  have : interior (s ∪ t) ⊆ s := fun x ⟨u, ⟨(hu₁ : IsOpen u), (hu₂ : u ⊆ s ∪ t)⟩, (hx₁ : x ∈ u)⟩ =>\n    by_contradiction fun hx₂ : x ∉ s =>\n      have : u \\ s ⊆ t := fun x ⟨h₁, h₂⟩ => or.resolve_left (hu₂ h₁) h₂\n      have : u \\ s ⊆ interior t := by rwa [(IsOpen.sdiff hu₁ h₁).subset_interior_iff]\n      have : u \\ s ⊆ ∅ := by rwa [h₂] at this\n      this ⟨hx₁, hx₂⟩\n  Subset.antisymm (interior_maximal this isOpen_interior) (interior_mono <| subset_union_left _ _)\n#align interior_union_is_closed_of_interior_empty interior_union_isClosed_of_interior_empty\n-/\n\n",
 "interior_subset_closure":
 "#print interior_subset_closure /-\ntheorem interior_subset_closure {s : Set α} : interior s ⊆ closure s :=\n  Subset.trans interior_subset subset_closure\n#align interior_subset_closure interior_subset_closure\n-/\n\n",
 "interior_subset":
 "#print interior_subset /-\ntheorem interior_subset {s : Set α} : interior s ⊆ s :=\n  unionₛ_subset fun t ⟨h₁, h₂⟩ => h₂\n#align interior_subset interior_subset\n-/\n\n",
 "interior_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n#print interior_singleton /-\n/-- If `x` is not an isolated point of a topological space, then the interior of `{x}` is empty. -/\n@[simp]\ntheorem interior_singleton (x : α) [NeBot (nhds_within.ne x)] : interior {x} = (∅ : Set α) :=\n  interior_eq_empty_iff_dense_compl.2 (dense_compl_singleton x)\n#align interior_singleton interior_singleton\n-/\n\n",
 "interior_setOf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print interior_setOf_eq /-\ntheorem interior_setOf_eq {p : α → Prop} :\n    interior { x | p x } =\n      { x |\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          ((nhds) x) (p y) } :=\n  interior_eq_nhds'\n#align interior_set_of_eq interior_setOf_eq\n-/\n\n",
 "interior_mono":
 "#print interior_mono /-\n@[mono]\ntheorem interior_mono {s t : Set α} (h : s ⊆ t) : interior s ⊆ interior t :=\n  interior_maximal (Subset.trans interior_subset h) isOpen_interior\n#align interior_mono interior_mono\n-/\n\n",
 "interior_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print interior_mem_nhds /-\n@[simp]\ntheorem interior_mem_nhds {s : Set α} {a : α} : interior s ∈ (nhds) a ↔ s ∈ (nhds) a :=\n  ⟨fun h => mem_of_superset h interior_subset, fun h => IsOpen.mem_nhds isOpen_interior (mem_interior_iff_mem_nhds.2 h)⟩\n#align interior_mem_nhds interior_mem_nhds\n-/\n\n",
 "interior_maximal":
 "#print interior_maximal /-\ntheorem interior_maximal {s t : Set α} (h₁ : t ⊆ s) (h₂ : IsOpen t) : t ⊆ interior s :=\n  subset_unionₛ_of_mem ⟨h₂, h₁⟩\n#align interior_maximal interior_maximal\n-/\n\n",
 "interior_interₛ_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print interior_interₛ_subset /-\ntheorem interior_interₛ_subset (S : Set (Set α)) :\n    interior («expr⋂₀ » S) ⊆\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (interior s) :=\n  calc\n    interior («expr⋂₀ » S) =\n        interior («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" s) :=\n      by rw [sInter_eq_bInter]\n    _ ⊆ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (interior s) :=\n      interior_Inter₂_subset _ _\n    \n#align interior_sInter_subset interior_interₛ_subset\n-/\n\n",
 "interior_interᵢ_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print interior_interᵢ_subset /-\ntheorem interior_interᵢ_subset (s : ι → Set α) :\n    interior («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)) ⊆\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (interior (s i)) :=\n  subset_interᵢ fun i => interior_mono <| interᵢ_subset _ _\n#align interior_Inter_subset interior_interᵢ_subset\n-/\n\n",
 "interior_interᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print interior_interᵢ /-\n@[simp]\ntheorem interior_interᵢ {ι : Type _} [Finite ι] (f : ι → Set α) :\n    interior («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (interior (f i)) :=\n  by\n  cases nonempty_fintype ι\n  convert finset.univ.interior_Inter f <;> simp\n#align interior_Inter interior_interᵢ\n-/\n\n",
 "interior_interior":
 "#print interior_interior /-\n@[simp]\ntheorem interior_interior {s : Set α} : interior (interior s) = interior s :=\n  isOpen_interior.interior_eq\n#align interior_interior interior_interior\n-/\n\n",
 "interior_inter":
 "#print interior_inter /-\n@[simp]\ntheorem interior_inter {s t : Set α} : interior (s ∩ t) = interior s ∩ interior t :=\n  Subset.antisymm (subset_inter (interior_mono <| inter_subset_left s t) (interior_mono <| inter_subset_right s t))\n    (interior_maximal (inter_subset_inter interior_subset interior_subset) <|\n      IsOpen.inter isOpen_interior isOpen_interior)\n#align interior_inter interior_inter\n-/\n\n",
 "interior_frontier":
 "#print interior_frontier /-\n/-- The frontier of a closed set has no interior point. -/\ntheorem interior_frontier {s : Set α} (h : IsClosed s) : interior (frontier s) = ∅ :=\n  by\n  have A : frontier s = s \\ interior s := h.frontier_eq\n  have B : interior (frontier s) ⊆ interior s := by rw [A] <;> exact interior_mono (diff_subset _ _)\n  have C : interior (frontier s) ⊆ frontier s := interior_subset\n  have : interior (frontier s) ⊆ interior s ∩ (s \\ interior s) := subset_inter B (by simpa [A] using C)\n  rwa [inter_diff_self, subset_empty_iff] at this\n#align interior_frontier interior_frontier\n-/\n\n",
 "interior_eq_univ":
 "#print interior_eq_univ /-\n@[simp]\ntheorem interior_eq_univ {s : Set α} : interior s = univ ↔ s = univ :=\n  ⟨fun h => univ_subset_iff.mp <| h.symm.trans_le interior_subset, fun h => h.symm ▸ interior_univ⟩\n#align interior_eq_univ interior_eq_univ\n-/\n\n",
 "interior_eq_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print interior_eq_nhds' /-\ntheorem interior_eq_nhds' {s : Set α} : interior s = { a | s ∈ (nhds) a } :=\n  Set.ext fun x => by simp only [mem_interior, mem_nhds_iff, mem_set_of_eq]\n#align interior_eq_nhds' interior_eq_nhds'\n-/\n\n",
 "interior_eq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print interior_eq_nhds /-\ntheorem interior_eq_nhds {s : Set α} : interior s = { a | (nhds) a ≤ (filter.principal) s } :=\n  interior_eq_nhds'.trans <| by simp only [le_principal_iff]\n#align interior_eq_nhds interior_eq_nhds\n-/\n\n",
 "interior_eq_iff_isOpen":
 "#print interior_eq_iff_isOpen /-\ntheorem interior_eq_iff_isOpen {s : Set α} : interior s = s ↔ IsOpen s :=\n  ⟨fun h => h ▸ isOpen_interior, IsOpen.interior_eq⟩\n#align interior_eq_iff_is_open interior_eq_iff_isOpen\n-/\n\n",
 "interior_eq_empty_iff_dense_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print interior_eq_empty_iff_dense_compl /-\ntheorem interior_eq_empty_iff_dense_compl {s : Set α} : interior s = ∅ ↔ Dense («expr ᶜ» s) := by\n  rw [dense_iff_closure_eq, closure_compl, compl_univ_iff]\n#align interior_eq_empty_iff_dense_compl interior_eq_empty_iff_dense_compl\n-/\n\n",
 "interior_eq":
 "#print IsOpen.interior_eq /-\ntheorem IsOpen.interior_eq {s : Set α} (h : IsOpen s) : interior s = s :=\n  Subset.antisymm interior_subset (interior_maximal (Subset.refl s) h)\n#align is_open.interior_eq IsOpen.interior_eq\n-/\n\n",
 "interior_empty":
 "#print interior_empty /-\n@[simp]\ntheorem interior_empty : interior (∅ : Set α) = ∅ :=\n  isOpen_empty.interior_eq\n#align interior_empty interior_empty\n-/\n\n",
 "interior_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print Dense.interior_compl /-\ntheorem Dense.interior_compl {s : Set α} (h : Dense s) : interior («expr ᶜ» s) = ∅ :=\n  interior_eq_empty_iff_dense_compl.2 <| by rwa [compl_compl]\n#align dense.interior_compl Dense.interior_compl\n-/\n\n",
 "interior_Inter₂_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print interior_Inter₂_subset /-\ntheorem interior_Inter₂_subset (p : ι → Sort _) (s : ∀ i, p i → Set α) :\n    interior («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i j)) ⊆\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (interior (s i j)) :=\n  (interior_interᵢ_subset _).trans <| interᵢ_mono fun i => interior_interᵢ_subset _\n#align interior_Inter₂_subset interior_Inter₂_subset\n-/\n\n",
 "inter_of_open_right":
 "#print Dense.inter_of_open_right /-\n/-- The intersection of a dense set with an open dense set is a dense set. -/\ntheorem Dense.inter_of_open_right {s t : Set α} (hs : Dense s) (ht : Dense t) (hto : IsOpen t) : Dense (s ∩ t) :=\n  inter_comm t s ▸ ht.inter_of_open_left hs hto\n#align dense.inter_of_open_right Dense.inter_of_open_right\n-/\n\n",
 "inter_of_open_left":
 "#print Dense.inter_of_open_left /-\n/-- The intersection of an open dense set with a dense set is a dense set. -/\ntheorem Dense.inter_of_open_left {s t : Set α} (hs : Dense s) (ht : Dense t) (hso : IsOpen s) : Dense (s ∩ t) :=\n  fun x => closure_minimal hso.inter_closure isClosed_closure <| by simp [hs.closure_eq, ht.closure_eq]\n#align dense.inter_of_open_left Dense.inter_of_open_left\n-/\n\n",
 "inter_nhds_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Dense.inter_nhds_nonempty /-\ntheorem Dense.inter_nhds_nonempty {s t : Set α} (hs : Dense s) {x : α} (ht : t ∈ (nhds) x) : (s ∩ t).nonempty :=\n  let ⟨U, hsub, ho, hx⟩ := mem_nhds_iff.1 ht\n  (hs.inter_open_nonempty U ho ⟨x, hx⟩).mono fun y hy => ⟨hy.2, hsub hy.1⟩\n#align dense.inter_nhds_nonempty Dense.inter_nhds_nonempty\n-/\n\n",
 "inter_frontier_eq":
 "#print IsOpen.inter_frontier_eq /-\ntheorem IsOpen.inter_frontier_eq {s : Set α} (hs : IsOpen s) : s ∩ frontier s = ∅ := by\n  rw [hs.frontier_eq, inter_diff_self]\n#align is_open.inter_frontier_eq IsOpen.inter_frontier_eq\n-/\n\n",
 "inter_closure":
 "#print IsOpen.inter_closure /-\ntheorem IsOpen.inter_closure {s t : Set α} (h : IsOpen s) : s ∩ closure t ⊆ closure (s ∩ t) :=\n  compl_subset_compl.mp <| by\n    simpa only [← interior_compl, compl_inter] using IsClosed.interior_union_left h.is_closed_compl\n#align is_open.inter_closure IsOpen.inter_closure\n-/\n\n",
 "inter":
 "#print IsClosed.inter /-\ntheorem IsClosed.inter (h₁ : IsClosed s₁) (h₂ : IsClosed s₂) : IsClosed (s₁ ∩ s₂) :=\n  by\n  rw [← isOpen_compl_iff] at *\n  rw [compl_inter]\n  exact IsOpen.union h₁ h₂\n#align is_closed.inter IsClosed.inter\n-/\n\n",
 "image_closure_subset_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print image_closure_subset_closure_image /-\ntheorem image_closure_subset_closure_image {f : α → β} {s : Set α} (h : Continuous f) :\n    «expr '' » f (closure s) ⊆ closure («expr '' » f s) :=\n  ((mapsTo_image f s).closure h).image_subset\n#align image_closure_subset_closure_image image_closure_subset_closure_image\n-/\n\n",
 "frontier_univ":
 "#print frontier_univ /-\n@[simp]\ntheorem frontier_univ : frontier (univ : Set α) = ∅ := by simp [frontier]\n#align frontier_univ frontier_univ\n-/\n\n",
 "frontier_union_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print frontier_union_subset /-\ntheorem frontier_union_subset (s t : Set α) :\n    frontier (s ∪ t) ⊆ frontier s ∩ closure («expr ᶜ» t) ∪ closure («expr ᶜ» s) ∩ frontier t := by\n  simpa only [frontier_compl, ← compl_union] using frontier_inter_subset («expr ᶜ» s) («expr ᶜ» t)\n#align frontier_union_subset frontier_union_subset\n-/\n\n",
 "frontier_subset_closure":
 "#print frontier_subset_closure /-\ntheorem frontier_subset_closure {s : Set α} : frontier s ⊆ closure s :=\n  diff_subset _ _\n#align frontier_subset_closure frontier_subset_closure\n-/\n\n",
 "frontier_subset":
 "#print IsClosed.frontier_subset /-\ntheorem IsClosed.frontier_subset (hs : IsClosed s) : frontier s ⊆ s :=\n  frontier_subset_closure.trans hs.closure_eq.subset\n#align is_closed.frontier_subset IsClosed.frontier_subset\n-/\n\n",
 "frontier_right":
 "#print Disjoint.frontier_right /-\ntheorem Disjoint.frontier_right (hs : IsOpen s) (hd : Disjoint s t) : Disjoint s (frontier t) :=\n  (hd.symm.frontier_left hs).symm\n#align disjoint.frontier_right Disjoint.frontier_right\n-/\n\n",
 "frontier_preimage_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print Continuous.frontier_preimage_subset /-\ntheorem Continuous.frontier_preimage_subset {f : α → β} (hf : Continuous f) (t : Set β) :\n    frontier («expr ⁻¹' » f t) ⊆ «expr ⁻¹' » f (frontier t) :=\n  diff_subset_diff (hf.closure_preimage_subset t) (preimage_interior_subset_interior_preimage hf)\n#align continuous.frontier_preimage_subset Continuous.frontier_preimage_subset\n-/\n\n",
 "frontier_left":
 "#print Disjoint.frontier_left /-\ntheorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=\n  subset_compl_iff_disjoint_right.1 <|\n    frontier_subset_closure.trans <| closure_minimal (disjoint_left.1 hd) <| isClosed_compl_iff.2 ht\n#align disjoint.frontier_left Disjoint.frontier_left\n-/\n\n",
 "frontier_interior_subset":
 "#print frontier_interior_subset /-\ntheorem frontier_interior_subset {s : Set α} : frontier (interior s) ⊆ frontier s :=\n  diff_subset_diff (closure_mono interior_subset) interior_interior.symm.subset\n#align frontier_interior_subset frontier_interior_subset\n-/\n\n",
 "frontier_inter_subset":
 "#print frontier_inter_subset /-\ntheorem frontier_inter_subset (s t : Set α) : frontier (s ∩ t) ⊆ frontier s ∩ closure t ∪ closure s ∩ frontier t :=\n  by\n  simp only [frontier_eq_closure_inter_closure, compl_inter, closure_union]\n  convert inter_subset_inter_left _ (closure_inter_subset_inter_closure s t)\n  simp only [inter_distrib_left, inter_distrib_right, inter_assoc]\n  congr 2\n  apply inter_comm\n#align frontier_inter_subset frontier_inter_subset\n-/\n\n",
 "frontier_eq_inter_compl_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print frontier_eq_inter_compl_interior /-\ntheorem frontier_eq_inter_compl_interior {s : Set α} :\n    frontier s = «expr ᶜ» (interior s) ∩ «expr ᶜ» (interior («expr ᶜ» s)) :=\n  by\n  rw [← frontier_compl, ← closure_compl]\n  rfl\n#align frontier_eq_inter_compl_interior frontier_eq_inter_compl_interior\n-/\n\n",
 "frontier_eq_closure_inter_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print frontier_eq_closure_inter_closure /-\ntheorem frontier_eq_closure_inter_closure {s : Set α} : frontier s = closure s ∩ closure («expr ᶜ» s) := by\n  rw [closure_compl, frontier, diff_eq]\n#align frontier_eq_closure_inter_closure frontier_eq_closure_inter_closure\n-/\n\n",
 "frontier_eq":
 "#print IsOpen.frontier_eq /-\ntheorem IsOpen.frontier_eq {s : Set α} (hs : IsOpen s) : frontier s = closure s \\ s := by rw [frontier, hs.interior_eq]\n#align is_open.frontier_eq IsOpen.frontier_eq\n-/\n\n",
 "frontier_empty":
 "#print frontier_empty /-\n@[simp]\ntheorem frontier_empty : frontier (∅ : Set α) = ∅ := by simp [frontier]\n#align frontier_empty frontier_empty\n-/\n\n",
 "frontier_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print frontier_compl /-\n/-- The complement of a set has the same frontier as the original set. -/\n@[simp]\ntheorem frontier_compl (s : Set α) : frontier («expr ᶜ» s) = frontier s := by\n  simp only [frontier_eq_closure_inter_closure, compl_compl, inter_comm]\n#align frontier_compl frontier_compl\n-/\n\n",
 "frontier_closure_subset":
 "#print frontier_closure_subset /-\ntheorem frontier_closure_subset {s : Set α} : frontier (closure s) ⊆ frontier s :=\n  diff_subset_diff closure_closure.subset <| interior_mono subset_closure\n#align frontier_closure_subset frontier_closure_subset\n-/\n\n",
 "frequently_frequently_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print frequently_frequently_nhds /-\n@[simp]\ntheorem frequently_frequently_nhds {p : α → Prop} {a : α} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" ((nhds) a)\n        («expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n          ((nhds) y) (p x)) ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" ((nhds) a)\n        (p x) :=\n  by\n  rw [← not_iff_not]\n  simp_rw [not_frequently]\n  exact eventually_eventually_nhds\n#align frequently_frequently_nhds frequently_frequently_nhds\n-/\n\n",
 "exists_open_set_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_open_set_nhds' /-\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\nit contains an open set containing `s`. -/\ntheorem exists_open_set_nhds' {s U : Set α}\n    (h :\n      U ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((nhds) x)) :\n    ∃ V : Set α, s ⊆ V ∧ IsOpen V ∧ V ⊆ U :=\n  exists_open_set_nhds (by simpa using h)\n#align exists_open_set_nhds' exists_open_set_nhds'\n-/\n\n",
 "exists_open_set_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_open_set_nhds /-\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. -/\ntheorem exists_open_set_nhds {s U : Set α} (h : ∀ x ∈ s, U ∈ (nhds) x) : ∃ V : Set α, s ⊆ V ∧ IsOpen V ∧ V ⊆ U :=\n  by\n  have := fun x hx => (nhds_basis_opens x).mem_iff.1 (h x hx)\n  choose! Z hZ hZU using this; choose hZmem hZo using hZ\n  exact\n    ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (Z x), fun x hx =>\n      mem_bUnion hx (hZmem x hx), isOpen_bunionᵢ hZo, Union₂_subset hZU⟩\n#align exists_open_set_nhds exists_open_set_nhds\n-/\n\n",
 "exists_mem_open":
 "#print DenseRange.exists_mem_open /-\ntheorem DenseRange.exists_mem_open (hf : DenseRange f) {s : Set β} (ho : IsOpen s) (hs : s.nonempty) : ∃ a, f a ∈ s :=\n  exists_range_iff.1 <| hf.exists_mem_open ho hs\n#align dense_range.exists_mem_open DenseRange.exists_mem_open\n-/\n\n",
 "eventually_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print eventually_nhds_iff /-\n/-- A predicate is true in a neighborhood of `a` iff it is true for all the points in an open set\ncontaining `a`. -/\ntheorem eventually_nhds_iff {a : α} {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p x) ↔\n      ∃ t : Set α, (∀ x ∈ t, p x) ∧ IsOpen t ∧ a ∈ t :=\n  mem_nhds_iff.trans <| by simp only [subset_def, exists_prop, mem_set_of_eq]\n#align eventually_nhds_iff eventually_nhds_iff\n-/\n\n",
 "eventually_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Eventually.eventually_nhds /-\n/-- If a predicate is true in a neighbourhood of `a`, then for `y` sufficiently close\nto `a` this predicate is true in a neighbourhood of `y`. -/\ntheorem Filter.Eventually.eventually_nhds {p : α → Prop} {a : α}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p y)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      («expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        ((nhds) y) (p x)) :=\n  let ⟨t, htp, hto, ha⟩ := eventually_nhds_iff.1 h\n  eventually_nhds_iff.2 ⟨t, fun x hx => eventually_nhds_iff.2 ⟨t, htp, hto, hx⟩, hto, ha⟩\n#align filter.eventually.eventually_nhds Filter.Eventually.eventually_nhds\n-/\n\n",
 "eventually_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print eventually_mem_nhds /-\n@[simp]\ntheorem eventually_mem_nhds {s : Set α} {a : α} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (s ∈ (nhds) x) ↔\n      s ∈ (nhds) a :=\n  eventually_eventually_nhds\n#align eventually_mem_nhds eventually_mem_nhds\n-/\n\n",
 "eventually_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsOpen.eventually_mem /-\ntheorem IsOpen.eventually_mem {a : α} {s : Set α} (hs : IsOpen s) (ha : a ∈ s) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      (x ∈ s) :=\n  IsOpen.mem_nhds hs ha\n#align is_open.eventually_mem IsOpen.eventually_mem\n-/\n\n",
 "eventually_eventually_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print eventually_eventually_nhds /-\n@[simp]\ntheorem eventually_eventually_nhds {p : α → Prop} {a : α} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        («expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          ((nhds) y) (p x)) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p x) :=\n  ⟨fun h => h.self_of_nhds, fun h => h.eventually_nhds⟩\n#align eventually_eventually_nhds eventually_eventually_nhds\n-/\n\n",
 "eventually_eventuallyLE_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print eventually_eventuallyLE_nhds /-\n@[simp]\ntheorem eventually_eventuallyLE_nhds [LE β] {f g : α → β} {a : α} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        («expr ≤ᶠ[ ] » f ((nhds) y) g) ↔\n      «expr ≤ᶠ[ ] » f ((nhds) a) g :=\n  eventually_eventually_nhds\n#align eventually_eventually_le_nhds eventually_eventuallyLE_nhds\n-/\n\n",
 "eventually_eventuallyEq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print eventually_eventuallyEq_nhds /-\n@[simp]\ntheorem eventually_eventuallyEq_nhds {f g : α → β} {a : α} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        («expr =ᶠ[ ] » f ((nhds) y) g) ↔\n      «expr =ᶠ[ ] » f ((nhds) a) g :=\n  eventually_eventually_nhds\n#align eventually_eventually_eq_nhds eventually_eventuallyEq_nhds\n-/\n\n",
 "eventuallyLE_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.EventuallyLE.eventuallyLE_nhds /-\n/-- If `f x ≤ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\n`f x ≤ g x` in a neighbourhood of `y`. -/\ntheorem Filter.EventuallyLE.eventuallyLE_nhds [LE β] {f g : α → β} {a : α} (h : «expr ≤ᶠ[ ] » f ((nhds) a) g) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      («expr ≤ᶠ[ ] » f ((nhds) y) g) :=\n  h.eventually_nhds\n#align filter.eventually_le.eventually_le_nhds Filter.EventuallyLE.eventuallyLE_nhds\n-/\n\n",
 "eventuallyEq_zero_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print eventuallyEq_zero_nhds /-\ntheorem eventuallyEq_zero_nhds {M₀} [Zero M₀] {a : α} {f : α → M₀} :\n    «expr =ᶠ[ ] » f ((nhds) a) 0 ↔ a ∉ closure (Function.support f) := by\n  rw [← mem_compl_iff, ← interior_compl, mem_interior_iff_mem_nhds, Function.compl_support] <;> rfl\n#align eventually_eq_zero_nhds eventuallyEq_zero_nhds\n-/\n\n",
 "eventuallyEq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.EventuallyEq.eventuallyEq_nhds /-\n/-- If two functions are equal in a neighbourhood of `a`, then for `y` sufficiently close\nto `a` these functions are equal in a neighbourhood of `y`. -/\ntheorem Filter.EventuallyEq.eventuallyEq_nhds {f g : α → β} {a : α} (h : «expr =ᶠ[ ] » f ((nhds) a) g) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      («expr =ᶠ[ ] » f ((nhds) y) g) :=\n  h.eventually_nhds\n#align filter.eventually_eq.eventually_eq_nhds Filter.EventuallyEq.eventuallyEq_nhds\n-/\n\n",
 "eq_of_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.EventuallyEq.eq_of_nhds /-\ntheorem Filter.EventuallyEq.eq_of_nhds {f g : α → β} {a : α} (h : «expr =ᶠ[ ] » f ((nhds) a) g) : f a = g a :=\n  h.self_of_nhds\n#align filter.eventually_eq.eq_of_nhds Filter.EventuallyEq.eq_of_nhds\n-/\n\n",
 "diff_subset_closure_iff":
 "#print diff_subset_closure_iff /-\ntheorem diff_subset_closure_iff {s t : Set α} : s \\ t ⊆ closure t ↔ s ⊆ closure t := by\n  rw [diff_subset_iff, union_eq_self_of_subset_left subset_closure]\n#align diff_subset_closure_iff diff_subset_closure_iff\n-/\n\n",
 "dense_univ":
 "#print dense_univ /-\n@[simp]\ntheorem dense_univ : Dense (univ : Set α) := fun x => subset_closure trivial\n#align dense_univ dense_univ\n-/\n\n",
 "dense_of_mapsTo":
 "#print DenseRange.dense_of_mapsTo /-\n/-- If a continuous map with dense range maps a dense set to a subset of `t`, then `t` is a dense\nset. -/\ntheorem DenseRange.dense_of_mapsTo {f : α → β} (hf' : DenseRange f) (hf : Continuous f) {s : Set α} (hs : Dense s)\n    {t : Set β} (ht : MapsTo f s t) : Dense t :=\n  (hf'.dense_image hf hs).mono ht.image_subset\n#align dense_range.dense_of_maps_to DenseRange.dense_of_mapsTo\n-/\n\n",
 "dense_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print DenseRange.dense_image /-\n/-- The image of a dense set under a continuous map with dense range is a dense set. -/\ntheorem DenseRange.dense_image {f : α → β} (hf' : DenseRange f) (hf : Continuous f) {s : Set α} (hs : Dense s) :\n    Dense («expr '' » f s) :=\n  (hf'.mono <| hf.range_subset_closure_image_dense hs).of_closure\n#align dense_range.dense_image DenseRange.dense_image\n-/\n\n",
 "dense_iff_inter_open":
 "#print dense_iff_inter_open /-\n/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem dense_iff_inter_open {s : Set α} : Dense s ↔ ∀ U, IsOpen U → U.nonempty → (U ∩ s).nonempty :=\n  by\n  constructor <;> intro h\n  · rintro U U_op ⟨x, x_in⟩\n    exact mem_closure_iff.1 (by simp only [h.closure_eq]) U U_op x_in\n  · intro x\n    rw [mem_closure_iff]\n    intro U U_op x_in\n    exact h U U_op ⟨_, x_in⟩\n#align dense_iff_inter_open dense_iff_inter_open\n-/\n\n",
 "dense_iff_closure_eq":
 "#print dense_iff_closure_eq /-\ntheorem dense_iff_closure_eq {s : Set α} : Dense s ↔ closure s = univ :=\n  eq_univ_iff_forall.symm\n#align dense_iff_closure_eq dense_iff_closure_eq\n-/\n\n",
 "dense_compl_singleton_iff_not_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print dense_compl_singleton_iff_not_open /-\n/-- Complement to a singleton is dense if and only if the singleton is not an open set. -/\ntheorem dense_compl_singleton_iff_not_open {x : α} : Dense («expr ᶜ» {x} : Set α) ↔ ¬IsOpen ({x} : Set α) :=\n  by\n  fconstructor\n  · intro hd ho\n    exact (hd.inter_open_nonempty _ ho (singleton_nonempty _)).ne_empty (inter_compl_self _)\n  · refine' fun ho => dense_iff_inter_open.2 fun U hU hne => inter_compl_nonempty_iff.2 fun hUx => _\n    obtain rfl : U = {x}\n    exact eq_singleton_iff_nonempty_unique_mem.2 ⟨hne, hUx⟩\n    exact ho hU\n#align dense_compl_singleton_iff_not_open dense_compl_singleton_iff_not_open\n-/\n\n",
 "dense_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print dense_compl_singleton /-\n/-- If `x` is not an isolated point of a topological space, then `{x}ᶜ` is dense in the whole\nspace. -/\ntheorem dense_compl_singleton (x : α) [NeBot (nhds_within.ne x)] : Dense («expr ᶜ» {x} : Set α) :=\n  by\n  intro y\n  rcases eq_or_ne y x with (rfl | hne)\n  · rwa [mem_closure_iff_nhdsWithin_neBot]\n  · exact subset_closure hne\n#align dense_compl_singleton dense_compl_singleton\n-/\n\n",
 "dense_closure":
 "#print dense_closure /-\n/-- The closure of a set `s` is dense if and only if `s` is dense. -/\n@[simp]\ntheorem dense_closure {s : Set α} : Dense (closure s) ↔ Dense s := by rw [Dense, Dense, closure_closure]\n#align dense_closure dense_closure\n-/\n\n",
 "denseRange_val":
 "#print Dense.denseRange_val /-\ntheorem Dense.denseRange_val {s : Set α} (h : Dense s) : DenseRange (coe : s → α) := by\n  simpa only [DenseRange, Subtype.range_coe_subtype]\n#align dense.dense_range_coe Dense.denseRange_val\n-/\n\n",
 "denseRange_iff_closure_range":
 "#print denseRange_iff_closure_range /-\ntheorem denseRange_iff_closure_range : DenseRange f ↔ closure (range f) = univ :=\n  dense_iff_closure_eq\n#align dense_range_iff_closure_range denseRange_iff_closure_range\n-/\n\n",
 "denseRange_id":
 "#print denseRange_id /-\ntheorem denseRange_id : DenseRange (id : α → α) :=\n  Function.Surjective.denseRange function.surjective_id\n#align dense_range_id denseRange_id\n-/\n\n",
 "denseRange":
 "#print Function.Surjective.denseRange /-\n/-- A surjective map has dense range. -/\ntheorem Function.Surjective.denseRange (hf : function.surjective f) : DenseRange f := fun x => by simp [hf.range_eq]\n#align function.surjective.dense_range Function.Surjective.denseRange\n-/\n\n",
 "continuous_of_const":
 "#print continuous_of_const /-\ntheorem continuous_of_const {f : α → β} (h : ∀ x y, f x = f y) : Continuous f :=\n  continuous_iff_continuousAt.mpr fun x => Filter.EventuallyEq.continuousAt <| eventually_of_forall fun y => h y x\n#align continuous_of_const continuous_of_const\n-/\n\n",
 "continuous_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print continuous_iff_ultrafilter /-\ntheorem continuous_iff_ultrafilter {f : α → β} :\n    Continuous f ↔ ∀ (x) (g : Ultrafilter α), ↑g ≤ (nhds) x → Tendsto f g ((nhds) (f x)) := by\n  simp only [continuous_iff_continuousAt, continuousAt_iff_ultrafilter]\n#align continuous_iff_ultrafilter continuous_iff_ultrafilter\n-/\n\n",
 "continuous_iff_isClosed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print continuous_iff_isClosed /-\ntheorem continuous_iff_isClosed {f : α → β} : Continuous f ↔ ∀ s, IsClosed s → IsClosed («expr ⁻¹' » f s) :=\n  ⟨fun hf s hs => by simpa using (continuous_def.1 hf («expr ᶜ» s) hs.is_open_compl).is_closed_compl, fun hf =>\n    continuous_def.2 fun s => by rw [← isClosed_compl_iff, ← isClosed_compl_iff] <;> exact hf _⟩\n#align continuous_iff_is_closed continuous_iff_isClosed\n-/\n\n",
 "continuous_iff_continuousAt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print continuous_iff_continuousAt /-\ntheorem continuous_iff_continuousAt {f : α → β} : Continuous f ↔ ∀ x, ContinuousAt f x :=\n  ⟨Continuous.tendsto, fun hf : ∀ x, Tendsto f ((nhds) x) ((nhds) (f x)) =>\n    continuous_def.2 fun s => fun hs : IsOpen s =>\n      have : ∀ a, f a ∈ s → s ∈ (nhds) (f a) := fun a ha => IsOpen.mem_nhds hs ha\n      show IsOpen («expr ⁻¹' » f s) from isOpen_iff_nhds.2 fun a ha => le_principal_iff.2 <| hf _ (this a ha)⟩\n#align continuous_iff_continuous_at continuous_iff_continuousAt\n-/\n\n",
 "continuous_id":
 "#print continuous_id /-\ntheorem continuous_id : Continuous (id : α → α) :=\n  continuous_def.2 fun s h => h\n#align continuous_id continuous_id\n-/\n\n",
 "continuous_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print continuous_def /-\ntheorem continuous_def {f : α → β} : Continuous f ↔ ∀ s, IsOpen s → IsOpen («expr ⁻¹' » f s) :=\n  ⟨fun hf s hs => hf.is_open_preimage s hs, fun h => ⟨h⟩⟩\n#align continuous_def continuous_def\n-/\n\n",
 "continuous_const":
 "#print continuous_const /-\ntheorem continuous_const {b : β} : Continuous fun a : α => b :=\n  continuous_iff_continuousAt.mpr fun a => continuousAt_const\n#align continuous_const continuous_const\n-/\n\n",
 "continuousAt_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print continuousAt_iff_ultrafilter /-\ntheorem continuousAt_iff_ultrafilter {f : α → β} {x} :\n    ContinuousAt f x ↔ ∀ g : Ultrafilter α, ↑g ≤ (nhds) x → Tendsto f g ((nhds) (f x)) :=\n  tendsto_iff_ultrafilter f ((nhds) x) ((nhds) (f x))\n#align continuous_at_iff_ultrafilter continuousAt_iff_ultrafilter\n-/\n\n",
 "continuousAt_id":
 "#print continuousAt_id /-\ntheorem continuousAt_id {x : α} : ContinuousAt id x :=\n  continuous_id.continuous_at\n#align continuous_at_id continuousAt_id\n-/\n\n",
 "continuousAt_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print continuousAt_def /-\ntheorem continuousAt_def {f : α → β} {x : α} : ContinuousAt f x ↔ ∀ A ∈ (nhds) (f x), «expr ⁻¹' » f A ∈ (nhds) x :=\n  iff.rfl\n#align continuous_at_def continuousAt_def\n-/\n\n",
 "continuousAt_const":
 "#print continuousAt_const /-\ntheorem continuousAt_const {x : α} {b : β} : ContinuousAt (fun a : α => b) x :=\n  tendsto_const_nhds\n#align continuous_at_const continuousAt_const\n-/\n\n",
 "continuousAt_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print continuousAt_congr /-\ntheorem continuousAt_congr {f g : α → β} {x : α} (h : «expr =ᶠ[ ] » f ((nhds) x) g) :\n    ContinuousAt f x ↔ ContinuousAt g x := by simp only [ContinuousAt, tendsto_congr' h, h.eq_of_nhds]\n#align continuous_at_congr continuousAt_congr\n-/\n\n",
 "continuousAt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.EventuallyEq.continuousAt /-\ntheorem Filter.EventuallyEq.continuousAt {x : α} {f : α → β} {y : β} (h : «expr =ᶠ[ ] » f ((nhds) x) fun _ => y) :\n    ContinuousAt f x :=\n  (continuousAt_congr h).2 tendsto_const_nhds\n#align filter.eventually_eq.continuous_at Filter.EventuallyEq.continuousAt\n-/\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ContinuousAt.congr /-\ntheorem ContinuousAt.congr {f g : α → β} {x : α} (hf : ContinuousAt f x) (h : «expr =ᶠ[ ] » f ((nhds) x) g) :\n    ContinuousAt g x :=\n  (continuousAt_congr h).1 hf\n#align continuous_at.congr ContinuousAt.congr\n-/\n\n",
 "compl_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsClosed.compl_mem_nhds /-\ntheorem IsClosed.compl_mem_nhds {a : α} {s : Set α} (hs : IsClosed s) (ha : a ∉ s) : «expr ᶜ» s ∈ (nhds) a :=\n  hs.is_open_compl.mem_nhds (mem_compl ha)\n#align is_closed.compl_mem_nhds IsClosed.compl_mem_nhds\n-/\n\n",
 "compl_frontier_eq_union_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print compl_frontier_eq_union_interior /-\ntheorem compl_frontier_eq_union_interior {s : Set α} : «expr ᶜ» (frontier s) = interior s ∪ interior («expr ᶜ» s) :=\n  by\n  rw [frontier_eq_inter_compl_interior]\n  simp only [compl_inter, compl_compl]\n#align compl_frontier_eq_union_interior compl_frontier_eq_union_interior\n-/\n\n",
 "comp":
 "#print DenseRange.comp /-\n/-- Composition of a continuous map with dense range and a function with dense range has dense\nrange. -/\ntheorem DenseRange.comp {g : β → γ} {f : κ → β} (hg : DenseRange g) (hf : DenseRange f) (cg : Continuous g) :\n    DenseRange (g ∘ f) := by\n  rw [DenseRange, range_comp]\n  exact hg.dense_image cg hf\n#align dense_range.comp DenseRange.comp\n-/\n\n",
 "clusterPt_principal_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print clusterPt_principal_iff_frequently /-\ntheorem clusterPt_principal_iff_frequently {x : α} {s : Set α} :\n    ClusterPt x ((filter.principal) s) ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" ((nhds) x)\n        (y ∈ s) :=\n  by simp only [clusterPt_principal_iff, frequently_iff, Set.Nonempty, exists_prop, mem_inter_iff]\n#align cluster_pt_principal_iff_frequently clusterPt_principal_iff_frequently\n-/\n\n",
 "clusterPt_principal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print clusterPt_principal_iff /-\n/-- `x` is a cluster point of a set `s` if every neighbourhood of `x` meets `s` on a nonempty\nset. See also `mem_closure_iff_cluster_pt`. -/\ntheorem clusterPt_principal_iff {x : α} {s : Set α} :\n    ClusterPt x ((filter.principal) s) ↔ ∀ U ∈ (nhds) x, (U ∩ s).nonempty :=\n  inf_principal_neBot_iff\n#align cluster_pt_principal_iff clusterPt_principal_iff\n-/\n\n",
 "clusterPt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Ultrafilter.clusterPt_iff /-\ntheorem Ultrafilter.clusterPt_iff {x : α} {f : Ultrafilter α} : ClusterPt x f ↔ ↑f ≤ (nhds) x :=\n  ⟨f.le_of_inf_ne_bot', fun h => ClusterPt.of_le_nhds h⟩\n#align ultrafilter.cluster_pt_iff Ultrafilter.clusterPt_iff\n-/\n\n",
 "closure_univ":
 "#print closure_univ /-\n@[simp]\ntheorem closure_univ : closure (univ : Set α) = univ :=\n  isClosed_univ.closure_eq\n#align closure_univ closure_univ\n-/\n\n",
 "closure_unionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print closure_unionᵢ /-\n@[simp]\ntheorem closure_unionᵢ {ι : Type _} [Finite ι] (f : ι → Set α) :\n    closure («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (closure (f i)) :=\n  by\n  cases nonempty_fintype ι\n  convert finset.univ.closure_bUnion f <;> simp\n#align closure_Union closure_unionᵢ\n-/\n\n",
 "closure_union":
 "#print closure_union /-\n@[simp]\ntheorem closure_union {s t : Set α} : closure (s ∪ t) = closure s ∪ closure t :=\n  Subset.antisymm\n    (closure_minimal (union_subset_union subset_closure subset_closure) <|\n      IsClosed.union isClosed_closure isClosed_closure)\n    ((monotone_closure α).le_map_sup s t)\n#align closure_union closure_union\n-/\n\n",
 "closure_subset_preimage_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print closure_subset_preimage_closure_image /-\ntheorem closure_subset_preimage_closure_image {f : α → β} {s : Set α} (h : Continuous f) :\n    closure s ⊆ «expr ⁻¹' » f (closure («expr '' » f s)) :=\n  by\n  rw [← Set.image_subset_iff]\n  exact image_closure_subset_closure_image h\n#align closure_subset_preimage_closure_image closure_subset_preimage_closure_image\n-/\n\n",
 "closure_subset_iff_isClosed":
 "#print closure_subset_iff_isClosed /-\ntheorem closure_subset_iff_isClosed {s : Set α} : closure s ⊆ s ↔ IsClosed s :=\n  ⟨isClosed_of_closure_subset, IsClosed.closure_subset⟩\n#align closure_subset_iff_is_closed closure_subset_iff_isClosed\n-/\n\n",
 "closure_subset_iff":
 "#print IsClosed.closure_subset_iff /-\ntheorem IsClosed.closure_subset_iff {s t : Set α} (h₁ : IsClosed t) : closure s ⊆ t ↔ s ⊆ t :=\n  ⟨Subset.trans subset_closure, fun h => closure_minimal h h₁⟩\n#align is_closed.closure_subset_iff IsClosed.closure_subset_iff\n-/\n\n",
 "closure_subset":
 "#print IsClosed.closure_subset /-\ntheorem IsClosed.closure_subset {s : Set α} (hs : IsClosed s) : closure s ⊆ s :=\n  closure_minimal (Subset.refl _) hs\n#align is_closed.closure_subset IsClosed.closure_subset\n-/\n\n",
 "closure_right":
 "#print Disjoint.closure_right /-\ntheorem Disjoint.closure_right {s t : Set α} (hd : Disjoint s t) (hs : IsOpen s) : Disjoint s (closure t) :=\n  (hd.symm.closure_left hs).symm\n#align disjoint.closure_right Disjoint.closure_right\n-/\n\n",
 "closure_range":
 "#print DenseRange.closure_range /-\ntheorem DenseRange.closure_range (h : DenseRange f) : closure (range f) = univ :=\n  h.closure_eq\n#align dense_range.closure_range DenseRange.closure_range\n-/\n\n",
 "closure_preimage_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print Continuous.closure_preimage_subset /-\ntheorem Continuous.closure_preimage_subset {f : α → β} (hf : Continuous f) (t : Set β) :\n    closure («expr ⁻¹' » f t) ⊆ «expr ⁻¹' » f (closure t) :=\n  by\n  rw [← (is_closed_closure.preimage hf).closure_eq]\n  exact closure_mono (preimage_mono subset_closure)\n#align continuous.closure_preimage_subset Continuous.closure_preimage_subset\n-/\n\n",
 "closure_nonempty_iff":
 "#print closure_nonempty_iff /-\n@[simp]\ntheorem closure_nonempty_iff {s : Set α} : (closure s).nonempty ↔ s.nonempty := by\n  simp only [nonempty_iff_ne_empty, ne.def, closure_empty_iff]\n#align closure_nonempty_iff closure_nonempty_iff\n-/\n\n",
 "closure_mono":
 "#print closure_mono /-\n@[mono]\ntheorem closure_mono {s t : Set α} (h : s ⊆ t) : closure s ⊆ closure t :=\n  closure_minimal (Subset.trans h subset_closure) isClosed_closure\n#align closure_mono closure_mono\n-/\n\n",
 "closure_minimal":
 "#print closure_minimal /-\ntheorem closure_minimal {s t : Set α} (h₁ : s ⊆ t) (h₂ : IsClosed t) : closure s ⊆ t :=\n  interₛ_subset_of_mem ⟨h₂, h₁⟩\n#align closure_minimal closure_minimal\n-/\n\n",
 "closure_left":
 "#print Set.MapsTo.closure_left /-\n/-- If a continuous map `f` maps `s` to a closed set `t`, then it maps `closure s` to `t`. -/\ntheorem Set.MapsTo.closure_left {s : Set α} {t : Set β} {f : α → β} (h : MapsTo f s t) (hc : Continuous f)\n    (ht : IsClosed t) : MapsTo f (closure s) t :=\n  ht.closure_eq ▸ h.closure hc\n#align set.maps_to.closure_left Set.MapsTo.closure_left\n-/\n\n",
 "closure_inter_subset_inter_closure":
 "#print closure_inter_subset_inter_closure /-\ntheorem closure_inter_subset_inter_closure (s t : Set α) : closure (s ∩ t) ⊆ closure s ∩ closure t :=\n  (monotone_closure α).map_inf_le s t\n#align closure_inter_subset_inter_closure closure_inter_subset_inter_closure\n-/\n\n",
 "closure_inter_open_nonempty_iff":
 "#print closure_inter_open_nonempty_iff /-\ntheorem closure_inter_open_nonempty_iff {s t : Set α} (h : IsOpen t) : (closure s ∩ t).nonempty ↔ (s ∩ t).nonempty :=\n  ⟨fun ⟨x, hxcs, hxt⟩ => inter_comm t s ▸ mem_closure_iff.1 hxcs t h hxt, fun h =>\n    h.mono <| inf_le_inf_right t subset_closure⟩\n#align closure_inter_open_nonempty_iff closure_inter_open_nonempty_iff\n-/\n\n",
 "closure_inter":
 "#print IsOpen.closure_inter /-\ntheorem IsOpen.closure_inter {s t : Set α} (h : IsOpen t) : closure s ∩ t ⊆ closure (s ∩ t) := by\n  simpa only [inter_comm] using h.inter_closure\n#align is_open.closure_inter IsOpen.closure_inter\n-/\n\n",
 "closure_eq_self_union_frontier":
 "#print closure_eq_self_union_frontier /-\ntheorem closure_eq_self_union_frontier (s : Set α) : closure s = s ∪ frontier s :=\n  (union_diff_cancel' interior_subset subset_closure).symm\n#align closure_eq_self_union_frontier closure_eq_self_union_frontier\n-/\n\n",
 "closure_eq_interior_union_frontier":
 "#print closure_eq_interior_union_frontier /-\ntheorem closure_eq_interior_union_frontier (s : Set α) : closure s = interior s ∪ frontier s :=\n  (union_diff_cancel interior_subset_closure).symm\n#align closure_eq_interior_union_frontier closure_eq_interior_union_frontier\n-/\n\n",
 "closure_eq_iff_isClosed":
 "#print closure_eq_iff_isClosed /-\ntheorem closure_eq_iff_isClosed {s : Set α} : closure s = s ↔ IsClosed s :=\n  ⟨fun h => h ▸ isClosed_closure, IsClosed.closure_eq⟩\n#align closure_eq_iff_is_closed closure_eq_iff_isClosed\n-/\n\n",
 "closure_eq_compl_interior_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print closure_eq_compl_interior_compl /-\ntheorem closure_eq_compl_interior_compl {s : Set α} : closure s = «expr ᶜ» (interior («expr ᶜ» s)) :=\n  by\n  rw [interior, closure, compl_sUnion, compl_image_set_of]\n  simp only [compl_subset_compl, isOpen_compl_iff]\n#align closure_eq_compl_interior_compl closure_eq_compl_interior_compl\n-/\n\n",
 "closure_eq_cluster_pts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print closure_eq_cluster_pts /-\ntheorem closure_eq_cluster_pts {s : Set α} : closure s = { a | ClusterPt a ((filter.principal) s) } :=\n  Set.ext fun x => mem_closure_iff_clusterPt\n#align closure_eq_cluster_pts closure_eq_cluster_pts\n-/\n\n",
 "closure_eq":
 "#print Dense.closure_eq /-\ntheorem Dense.closure_eq {s : Set α} (h : Dense s) : closure s = univ :=\n  dense_iff_closure_eq.mp h\n#align dense.closure_eq Dense.closure_eq\n-/\n\n",
 "closure_empty_iff":
 "#print closure_empty_iff /-\n@[simp]\ntheorem closure_empty_iff (s : Set α) : closure s = ∅ ↔ s = ∅ :=\n  ⟨subset_eq_empty subset_closure, fun h => h.symm ▸ closure_empty⟩\n#align closure_empty_iff closure_empty_iff\n-/\n\n",
 "closure_empty":
 "#print closure_empty /-\n@[simp]\ntheorem closure_empty : closure (∅ : Set α) = ∅ :=\n  isClosed_empty.closure_eq\n#align closure_empty closure_empty\n-/\n\n",
 "closure_diff_interior":
 "#print closure_diff_interior /-\n@[simp]\ntheorem closure_diff_interior (s : Set α) : closure s \\ interior s = frontier s :=\n  rfl\n#align closure_diff_interior closure_diff_interior\n-/\n\n",
 "closure_diff_frontier":
 "#print closure_diff_frontier /-\n@[simp]\ntheorem closure_diff_frontier (s : Set α) : closure s \\ frontier s = interior s := by\n  rw [frontier, diff_diff_right_self, inter_eq_self_of_subset_right interior_subset_closure]\n#align closure_diff_frontier closure_diff_frontier\n-/\n\n",
 "closure_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print closure_diff /-\ntheorem closure_diff {s t : Set α} : closure s \\ closure t ⊆ closure (s \\ t) :=\n  calc\n    closure s \\ closure t = «expr ᶜ» (closure t) ∩ closure s := by simp only [diff_eq, inter_comm]\n    _ ⊆ closure («expr ᶜ» (closure t) ∩ s) := (isOpen_compl_iff.mpr <| isClosed_closure).inter_closure\n    _ = closure (s \\ closure t) := by simp only [diff_eq, inter_comm]\n    _ ⊆ closure (s \\ t) := closure_mono <| diff_subset_diff (Subset.refl s) subset_closure\n    \n#align closure_diff closure_diff\n-/\n\n",
 "closure_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print closure_compl_singleton /-\n/-- If `x` is not an isolated point of a topological space, then the closure of `{x}ᶜ` is the whole\nspace. -/\n@[simp]\ntheorem closure_compl_singleton (x : α) [NeBot (nhds_within.ne x)] : closure («expr ᶜ» {x}) = (univ : Set α) :=\n  (dense_compl_singleton x).closure_eq\n#align closure_compl_singleton closure_compl_singleton\n-/\n\n",
 "closure_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print closure_compl /-\n@[simp]\ntheorem closure_compl {s : Set α} : closure («expr ᶜ» s) = «expr ᶜ» (interior s) := by\n  simp [closure_eq_compl_interior_compl]\n#align closure_compl closure_compl\n-/\n\n",
 "closure_closure":
 "#print closure_closure /-\n@[simp]\ntheorem closure_closure {s : Set α} : closure (closure s) = closure s :=\n  isClosed_closure.closure_eq\n#align closure_closure closure_closure\n-/\n\n",
 "closure_bunionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print Finset.closure_bunionᵢ /-\n@[simp]\ntheorem Finset.closure_bunionᵢ {ι : Type _} (s : Finset ι) (f : ι → Set α) :\n    closure («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (closure (f i)) :=\n  by\n  classical\n    refine' s.induction_on (by simp) _\n    intro i s h₁ h₂\n    simp [h₂]\n#align finset.closure_bUnion Finset.closure_bunionᵢ\n-/\n\n",
 "closure":
 "#print Set.MapsTo.closure /-\n/-- If a continuous map `f` maps `s` to `t`, then it maps `closure s` to `closure t`. -/\ntheorem Set.MapsTo.closure {s : Set α} {t : Set β} {f : α → β} (h : MapsTo f s t) (hc : Continuous f) :\n    MapsTo f (closure s) (closure t) :=\n  by\n  simp only [maps_to, mem_closure_iff_clusterPt]\n  exact fun x hx => hx.map hc.continuous_at (tendsto_principal_principal.2 h)\n#align set.maps_to.closure Set.MapsTo.closure\n-/\n\n",
 "and":
 "#print IsOpen.and /-\ntheorem IsOpen.and : IsOpen { a | p₁ a } → IsOpen { a | p₂ a } → IsOpen { a | p₁ a ∧ p₂ a } :=\n  IsOpen.inter\n#align is_open.and IsOpen.and\n-/\n\n",
 "all_mem_nhds_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print all_mem_nhds_filter /-\ntheorem all_mem_nhds_filter (x : α) (f : Set α → Set β) (hf : ∀ s t, s ⊆ t → f s ⊆ f t) (l : Filter β) :\n    (∀ s ∈ (nhds) x, f s ∈ l) ↔ ∀ s, IsOpen s → x ∈ s → f s ∈ l :=\n  all_mem_nhds _ _ fun s t ssubt h => mem_of_superset h (hf s t ssubt)\n#align all_mem_nhds_filter all_mem_nhds_filter\n-/\n\n",
 "all_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print all_mem_nhds /-\ntheorem all_mem_nhds (x : α) (P : Set α → Prop) (hP : ∀ s t, s ⊆ t → P s → P t) :\n    (∀ s ∈ (nhds) x, P s) ↔ ∀ s, IsOpen s → x ∈ s → P s :=\n  ((nhds_basis_opens x).forall_iff hP).trans <| by simp only [and_comm' (x ∈ _), and_imp]\n#align all_mem_nhds all_mem_nhds\n-/\n\n",
 "acc_principal_iff_cluster":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print acc_principal_iff_cluster /-\n/-- `x` is an accumulation point of a set `C` iff it is a cluster point of `C ∖ {x}`.-/\ntheorem acc_principal_iff_cluster (x : α) (C : Set α) :\n    AccPt x ((filter.principal) C) ↔ ClusterPt x ((filter.principal) (C \\ {x})) := by\n  rw [acc_iff_cluster, inf_principal, inter_comm] <;> rfl\n#align acc_principal_iff_cluster acc_principal_iff_cluster\n-/\n\n",
 "acc_iff_cluster":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print acc_iff_cluster /-\ntheorem acc_iff_cluster (x : α) (F : Filter α) :\n    AccPt x F ↔ ClusterPt x («expr ⊓ » ((filter.principal) («expr ᶜ» {x})) F) := by\n  rw [AccPt, nhdsWithin, ClusterPt, inf_assoc]\n#align acc_iff_cluster acc_iff_cluster\n-/\n\n",
 "accPt_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print accPt_iff_nhds /-\n/-- `x` is an accumulation point of a set `C` iff every neighborhood\nof `x` contains a point of `C` other than `x`. -/\ntheorem accPt_iff_nhds (x : α) (C : Set α) : AccPt x ((filter.principal) C) ↔ ∀ U ∈ (nhds) x, ∃ y ∈ U ∩ C, y ≠ x := by\n  simp [acc_principal_iff_cluster, clusterPt_principal_iff, Set.Nonempty, exists_prop, and_assoc', and_comm' ¬_ = x]\n#align acc_pt_iff_nhds accPt_iff_nhds\n-/\n\n",
 "accPt_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print accPt_iff_frequently /-\n/-- `x` is an accumulation point of a set `C` iff\nthere are points near `x` in `C` and different from `x`.-/\ntheorem accPt_iff_frequently (x : α) (C : Set α) :\n    AccPt x ((filter.principal) C) ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" ((nhds) x)\n        (y ≠ x ∧ y ∈ C) :=\n  by simp [acc_principal_iff_cluster, clusterPt_principal_iff_frequently, and_comm']\n#align acc_pt_iff_frequently accPt_iff_frequently\n-/\n\n"}