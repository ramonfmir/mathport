{"union":
 "theorem is_closed.union : is_closed s₁ → is_closed s₂ → is_closed (s₁ ∪ s₂) := fun h₁ h₂ =>\n  by\n  rw [← is_open_compl_iff] at *\n  rw [compl_union]\n  exact is_open.inter h₁ h₂\n#align is_closed.union is_closed.union\n\n",
 "topological_space_eq_iff":
 "theorem topological_space_eq_iff {t t' : topological_space α} : t = t' ↔ ∀ s, @is_open α t s ↔ @is_open α t' s :=\n  ⟨fun h s => h ▸ iff.rfl, fun h => by\n    ext\n    exact h _⟩\n#align topological_space_eq_iff topological_space_eq_iff\n\n",
 "topological_space_eq":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Jeremy Avigad\n-/\n@[ext]\ntheorem topological_space_eq : ∀ {f g : topological_space α}, f.is_open = g.is_open → f = g\n  | ⟨a, _, _, _⟩, ⟨b, _, _, _⟩, rfl => rfl\n#align topological_space_eq topological_space_eq\n\n",
 "tendsto_pure_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_pure_nhds {α : Type _} [topological_space β] (f : α → β) (a : α) : tendsto f (pure a) ((nhds) (f a)) :=\n  (tendsto_pure_pure f a).mono_right (pure_le_nhds _)\n#align tendsto_pure_nhds tendsto_pure_nhds\n\n",
 "tendsto_nhds_lim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `g` tends to some `𝓝 a` along `f`, then it tends to `𝓝 (lim f g)`. We formulate\nthis lemma with a `[nonempty α]` argument of `lim` derived from `h` to make it useful for types\nwithout a `[nonempty α]` instance. Because of the built-in proof irrelevance, Lean will unify\nthis instance with any other instance. -/\ntheorem tendsto_nhds_lim {f : filter β} {g : β → α} (h : ∃ a, tendsto g f ((nhds) a)) :\n    tendsto g f (nhds <| @lim _ _ _ (nonempty_of_exists h) f g) :=\n  le_nhds_Lim h\n#align tendsto_nhds_lim tendsto_nhds_lim\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem tendsto_nhds {f : β → α} {l : filter β} {a : α} :\n    tendsto f l ((nhds) a) ↔ ∀ s, is_open s → a ∈ s → «expr ⁻¹' » f s ∈ l :=\n  all_mem_nhds_filter _ _ (fun s t h => preimage_mono h) _\n#align tendsto_nhds tendsto_nhds\n\n",
 "tendsto_inf_principal_nhds_iff_of_forall_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x «expr ∉ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Suppose that `f` sends the complement to `s` to a single point `a`, and `l` is some filter.\nThen `f` tends to `a` along `l` restricted to `s` if and only if it tends to `a` along `l`. -/\ntheorem tendsto_inf_principal_nhds_iff_of_forall_eq {f : β → α} {l : filter β} {s : set β} {a : α}\n    (h : ∀ (x) (_ : x ∉ s), f x = a) :\n    tendsto f («expr ⊓ » l ((filter.principal) s)) ((nhds) a) ↔ tendsto f l ((nhds) a) :=\n  by\n  rw [tendsto_iff_comap, tendsto_iff_comap]\n  replace h : (filter.principal) («expr ᶜ» s) ≤ comap f ((nhds) a)\n  · rintro U ⟨t, ht, htU⟩ x hx\n    have : f x ∈ t := (h x hx).symm ▸ mem_of_mem_nhds ht\n    exact htU this\n  refine' ⟨fun h' => _, le_trans inf_le_left⟩\n  have := sup_le h' h\n  rw [sup_inf_right, sup_principal, union_compl_self, principal_univ, inf_top_eq, sup_le_iff] at this\n  exact this.1\n#align tendsto_inf_principal_nhds_iff_of_forall_eq tendsto_inf_principal_nhds_iff_of_forall_eq\n\n",
 "tendsto_const_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_const_nhds {a : α} {f : filter β} : tendsto (fun b : β => a) f ((nhds) a) :=\n  tendsto_nhds.mpr fun s hs ha => univ_mem' fun _ => ha\n#align tendsto_const_nhds tendsto_const_nhds\n\n",
 "tendsto_at_top_of_eventually_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_at_top_of_eventually_const {ι : Type _} [SemilatticeSup ι] [nonempty ι] {x : α} {u : ι → α} {i₀ : ι}\n    (h : ∀ i ≥ i₀, u i = x) : tendsto u at_top ((nhds) x) :=\n  tendsto.congr' (eventually_eq.symm (eventually_at_top.mpr ⟨i₀, h⟩)) tendsto_const_nhds\n#align tendsto_at_top_of_eventually_const tendsto_at_top_of_eventually_const\n\n",
 "tendsto_at_top_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem order_top.tendsto_at_top_nhds {α : Type _} [partial_order α] [OrderTop α] [topological_space β] (f : α → β) :\n    tendsto f at_top (nhds <| f («expr⊤»)) :=\n  (tendsto_at_top_pure f).mono_right (pure_le_nhds _)\n#align order_top.tendsto_at_top_nhds order_top.tendsto_at_top_nhds\n\n",
 "tendsto_at_bot_of_eventually_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_at_bot_of_eventually_const {ι : Type _} [SemilatticeInf ι] [nonempty ι] {x : α} {u : ι → α} {i₀ : ι}\n    (h : ∀ i ≤ i₀, u i = x) : tendsto u at_bot ((nhds) x) :=\n  tendsto.congr' (eventually_eq.symm (eventually_at_bot.mpr ⟨i₀, h⟩)) tendsto_const_nhds\n#align tendsto_at_bot_of_eventually_const tendsto_at_bot_of_eventually_const\n\n",
 "tendsto'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A version of `continuous.tendsto` that allows one to specify a simpler form of the limit.\nE.g., one can write `continuous_exp.tendsto' 0 1 exp_zero`. -/\ntheorem continuous.tendsto' {f : α → β} (hf : continuous f) (x : α) (y : β) (h : f x = y) :\n    tendsto f ((nhds) x) ((nhds) y) :=\n  h ▸ hf.tendsto x\n#align continuous.tendsto' continuous.tendsto'\n\n",
 "tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous.tendsto {f : α → β} (hf : continuous f) (x) : tendsto f ((nhds) x) ((nhds) (f x)) :=\n  ((nhds_basis_opens x).tendsto_iff <| nhds_basis_opens <| f x).2 fun t ⟨hxt, ht⟩ =>\n    ⟨«expr ⁻¹' » f t, ⟨hxt, ht.preimage hf⟩, Subset.refl _⟩\n#align continuous.tendsto continuous.tendsto\n\n",
 "subset_interior_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem subset_interior_iff_nhds {s V : set α} : s ⊆ interior V ↔ ∀ x ∈ s, V ∈ (nhds) x :=\n  show (∀ x, x ∈ s → x ∈ _) ↔ _ by simp_rw [mem_interior_iff_mem_nhds]\n#align subset_interior_iff_nhds subset_interior_iff_nhds\n\n",
 "subset_interior_iff_is_open":
 "theorem subset_interior_iff_is_open {s : set α} : s ⊆ interior s ↔ is_open s := by\n  simp only [interior_eq_iff_is_open.symm, subset.antisymm_iff, interior_subset, true_and_iff]\n#align subset_interior_iff_is_open subset_interior_iff_is_open\n\n",
 "subset_interior_iff":
 "theorem subset_interior_iff {s t : set α} : t ⊆ interior s ↔ ∃ U, is_open U ∧ t ⊆ U ∧ U ⊆ s :=\n  ⟨fun h => ⟨interior s, is_open_interior, h, interior_subset⟩, fun ⟨U, hU, htU, hUs⟩ =>\n    htU.trans (interior_maximal hUs hU)⟩\n#align subset_interior_iff subset_interior_iff\n\n",
 "subset_closure_image_preimage_of_is_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If `f` has dense range and `s` is an open set in the codomain of `f`, then the image of the\npreimage of `s` under `f` is dense in `s`. -/\ntheorem dense_range.subset_closure_image_preimage_of_is_open (hf : dense_range f) {s : set β} (hs : is_open s) :\n    s ⊆ closure («expr '' » f («expr ⁻¹' » f s)) :=\n  by\n  rw [image_preimage_eq_inter_range]\n  exact hf.open_subset_closure_inter hs\n#align dense_range.subset_closure_image_preimage_of_is_open dense_range.subset_closure_image_preimage_of_is_open\n\n",
 "subset_closure":
 "theorem subset_closure {s : set α} : s ⊆ closure s :=\n  subset_sInter fun t ⟨h₁, h₂⟩ => h₂\n#align subset_closure subset_closure\n\n",
 "self_of_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a predicate is true in a neighborhood of `a`, then it is true for `a`. -/\ntheorem filter.eventually.self_of_nhds {p : α → Prop} {a : α}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p y)) :\n    p a :=\n  mem_of_mem_nhds h\n#align filter.eventually.self_of_nhds filter.eventually.self_of_nhds\n\n",
 "self_diff_frontier":
 "@[simp]\ntheorem self_diff_frontier (s : set α) : s \\ frontier s = interior s := by\n  rw [frontier, diff_diff_right, diff_eq_empty.2 subset_closure, inter_eq_self_of_subset_right interior_subset,\n    empty_union]\n#align self_diff_frontier self_diff_frontier\n\n",
 "sdiff":
 "theorem is_closed.sdiff {s t : set α} (h₁ : is_closed s) (h₂ : is_open t) : is_closed (s \\ t) :=\n  is_closed.inter h₁ (is_closed_compl_iff.mpr h₂)\n#align is_closed.sdiff is_closed.sdiff\n\n",
 "rtendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem rtendsto_nhds {r : Rel β α} {l : filter β} {a : α} :\n    rtendsto r l ((nhds) a) ↔ ∀ s, is_open s → a ∈ s → r.core s ∈ l :=\n  all_mem_nhds_filter _ _ (fun s t => id) _\n#align rtendsto_nhds rtendsto_nhds\n\n",
 "rtendsto'_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem rtendsto'_nhds {r : Rel β α} {l : filter β} {a : α} :\n    rtendsto' r l ((nhds) a) ↔ ∀ s, is_open s → a ∈ s → r.preimage s ∈ l :=\n  by\n  rw [rtendsto'_def]\n  apply all_mem_nhds_filter\n  apply Rel.preimage_mono\n#align rtendsto'_nhds rtendsto'_nhds\n\n",
 "range_subset_closure_image_dense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem continuous.range_subset_closure_image_dense {f : α → β} (hf : continuous f) {s : set α} (hs : dense s) :\n    range f ⊆ closure («expr '' » f s) := by\n  rw [← image_univ, ← hs.closure_eq]\n  exact image_closure_subset_closure_image hf\n#align continuous.range_subset_closure_image_dense continuous.range_subset_closure_image_dense\n\n",
 "pure_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pure_le_nhds : pure ≤ (nhds : α → filter α) := fun a s hs => mem_pure.2 <| mem_of_mem_nhds hs\n#align pure_le_nhds pure_le_nhds\n\n",
 "ptendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ptendsto_nhds {f : «expr →. » β α} {l : filter β} {a : α} :\n    ptendsto f l ((nhds) a) ↔ ∀ s, is_open s → a ∈ s → f.core s ∈ l :=\n  rtendsto_nhds\n#align ptendsto_nhds ptendsto_nhds\n\n",
 "ptendsto'_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ptendsto'_nhds {f : «expr →. » β α} {l : filter β} {a : α} :\n    ptendsto' f l ((nhds) a) ↔ ∀ s, is_open s → a ∈ s → f.preimage s ∈ l :=\n  rtendsto'_nhds\n#align ptendsto'_nhds ptendsto'_nhds\n\n",
 "preimage_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_at.preimage_mem_nhds {f : α → β} {x : α} {t : set β} (h : continuous_at f x)\n    (ht : t ∈ (nhds) (f x)) : «expr ⁻¹' » f t ∈ (nhds) x :=\n  h ht\n#align continuous_at.preimage_mem_nhds continuous_at.preimage_mem_nhds\n\n",
 "preimage_interior_subset_interior_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- See also `interior_preimage_subset_preimage_interior`. -/\ntheorem preimage_interior_subset_interior_preimage {f : α → β} {s : set β} (hf : continuous f) :\n    «expr ⁻¹' » f (interior s) ⊆ interior («expr ⁻¹' » f s) :=\n  interior_maximal (preimage_mono interior_subset) (is_open_interior.preimage hf)\n#align preimage_interior_subset_interior_preimage preimage_interior_subset_interior_preimage\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem is_closed.preimage {f : α → β} (hf : continuous f) {s : set β} (h : is_closed s) :\n    is_closed («expr ⁻¹' » f s) :=\n  continuous_iff_is_closed.mp hf s h\n#align is_closed.preimage is_closed.preimage\n\n",
 "pcontinuous_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem pcontinuous_iff' {f : «expr →. » α β} :\n    pcontinuous f ↔ ∀ {x y} (h : y ∈ f x), ptendsto' f ((nhds) x) ((nhds) y) :=\n  by\n  constructor\n  · intro h x y h'\n    simp only [ptendsto'_def, mem_nhds_iff]\n    rintro s ⟨t, tsubs, opent, yt⟩\n    exact ⟨f.preimage t, pfun.preimage_mono _ tsubs, h _ opent, ⟨y, yt, h'⟩⟩\n  intro hf s os\n  rw [is_open_iff_nhds]\n  rintro x ⟨y, ys, fxy⟩ t\n  rw [mem_principal]\n  intro (h : f.preimage s ⊆ t)\n  change t ∈ (nhds) x\n  apply mem_of_superset _ h\n  have h' : ∀ s ∈ (nhds) y, f.preimage s ∈ (nhds) x := by\n    intro s hs\n    have : ptendsto' f ((nhds) x) ((nhds) y) := hf fxy\n    rw [ptendsto'_def] at this\n    exact this s hs\n  show f.preimage s ∈ (nhds) x\n  apply h'\n  rw [mem_nhds_iff]\n  exact ⟨s, Set.Subset.refl _, os, ys⟩\n#align pcontinuous_iff' pcontinuous_iff'\n\n",
 "open_subset_closure_inter":
 "theorem dense.open_subset_closure_inter {s t : set α} (hs : dense s) (ht : is_open t) : t ⊆ closure (t ∩ s) :=\n  calc\n    t = t ∩ closure s := by rw [hs.closure_eq, inter_univ]\n    _ ⊆ closure (t ∩ s) := ht.inter_closure\n    \n#align dense.open_subset_closure_inter dense.open_subset_closure_inter\n\n",
 "open_dom_of_pcontinuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem open_dom_of_pcontinuous {f : «expr →. » α β} (h : pcontinuous f) : is_open f.dom := by\n  rw [← pfun.preimage_univ] <;> exact h _ is_open_univ\n#align open_dom_of_pcontinuous open_dom_of_pcontinuous\n\n",
 "of_nhds_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cluster_pt.of_nhds_le {x : α} {f : filter α} (H : (nhds) x ≤ f) : cluster_pt x f := by\n  simp only [cluster_pt, inf_eq_left.mpr H, nhds_ne_bot]\n#align cluster_pt.of_nhds_le cluster_pt.of_nhds_le\n\n",
 "of_le_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cluster_pt.of_le_nhds' {x : α} {f : filter α} (H : f ≤ (nhds) x) (hf : ne_bot f) : cluster_pt x f :=\n  cluster_pt.of_le_nhds H\n#align cluster_pt.of_le_nhds' cluster_pt.of_le_nhds'\n\n",
 "of_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cluster_pt.of_le_nhds {x : α} {f : filter α} (H : f ≤ (nhds) x) [ne_bot f] : cluster_pt x f := by\n  rwa [cluster_pt, inf_eq_right.mpr H]\n#align cluster_pt.of_le_nhds cluster_pt.of_le_nhds\n\n",
 "of_inf_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem cluster_pt.of_inf_right {x : α} {f g : filter α} (H : cluster_pt x <| «expr ⊓ » f g) : cluster_pt x g :=\n  H.mono inf_le_right\n#align cluster_pt.of_inf_right cluster_pt.of_inf_right\n\n",
 "of_inf_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem cluster_pt.of_inf_left {x : α} {f g : filter α} (H : cluster_pt x <| «expr ⊓ » f g) : cluster_pt x f :=\n  H.mono inf_le_left\n#align cluster_pt.of_inf_left cluster_pt.of_inf_left\n\n",
 "not_mem_of_not_mem_closure":
 "theorem not_mem_of_not_mem_closure {s : set α} {P : α} (hP : P ∉ closure s) : P ∉ s := fun h => hP (subset_closure h)\n#align not_mem_of_not_mem_closure not_mem_of_not_mem_closure\n\n",
 "not_is_open_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\ntheorem not_is_open_singleton (x : α) [ne_bot (nhds_within.ne x)] : ¬is_open ({x} : set α) :=\n  dense_compl_singleton_iff_not_open.1 (dense_compl_singleton x)\n#align not_is_open_singleton not_is_open_singleton\n\n",
 "not":
 "theorem is_closed.not : is_closed { a | p a } → is_open { a | ¬p a } :=\n  is_open_compl_iff.mpr\n#align is_closed.not is_closed.not\n\n",
 "nonempty_iff":
 "theorem dense_range.nonempty_iff (hf : dense_range f) : nonempty κ ↔ nonempty β :=\n  range_nonempty_iff_nonempty.symm.trans hf.nonempty_iff\n#align dense_range.nonempty_iff dense_range.nonempty_iff\n\n",
 "nonempty":
 "theorem dense_range.nonempty [h : nonempty β] (hf : dense_range f) : nonempty κ :=\n  hf.nonempty_iff.mpr h\n#align dense_range.nonempty dense_range.nonempty\n\n",
 "nhds_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- To show a filter is above the neighborhood filter at `a`, it suffices to show that it is above\nthe principal filter of some open set `s` containing `a`. -/\ntheorem nhds_le_of_le {f a} {s : set α} (h : a ∈ s) (o : is_open s) (sf : (filter.principal) s ≤ f) : (nhds) a ≤ f := by\n  rw [nhds_def] <;> exact infᵢ_le_of_le s (infᵢ_le_of_le ⟨h, o⟩ sf)\n#align nhds_le_of_le nhds_le_of_le\n\n",
 "nhds_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_def' (a : α) :\n    (nhds) a =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) s) :=\n  by simp only [nhds_def, mem_set_of_eq, and_comm' (a ∈ _), infᵢ_and]\n#align nhds_def' nhds_def'\n\n",
 "nhds_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem nhds_def (a : α) :\n    (nhds) a =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) s) :=\n  by rw [nhds]\n#align nhds_def nhds_def\n\n",
 "nhds_bind_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem nhds_bind_nhds : ((nhds) a).bind (nhds) = (nhds) a :=\n  filter.ext fun s => eventually_eventually_nhds\n#align nhds_bind_nhds nhds_bind_nhds\n\n",
 "nhds_basis_opens'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The open neighborhoods of `a` are a basis for the neighborhood filter. See `nhds_basis_opens`\nfor a variant using open sets around `a` instead. -/\ntheorem nhds_basis_opens' (a : α) : ((nhds) a).has_basis (fun s : set α => s ∈ (nhds) a ∧ is_open s) fun x => x :=\n  by\n  convert nhds_basis_opens a\n  ext s\n  exact and_congr_left_iff.2 is_open.mem_nhds_iff\n#align nhds_basis_opens' nhds_basis_opens'\n\n",
 "nhds_basis_opens":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The open sets containing `a` are a basis for the neighborhood filter. See `nhds_basis_opens'`\nfor a variant using open neighborhoods instead. -/\ntheorem nhds_basis_opens (a : α) : ((nhds) a).has_basis (fun s : set α => a ∈ s ∧ is_open s) fun s => s :=\n  by\n  rw [nhds_def]\n  exact\n    has_basis_binfi_principal\n      (fun s ⟨has, hs⟩ t ⟨hat, ht⟩ =>\n        ⟨s ∩ t, ⟨⟨has, hat⟩, is_open.inter hs ht⟩, ⟨inter_subset_left _ _, inter_subset_right _ _⟩⟩)\n      ⟨univ, ⟨mem_univ a, is_open_univ⟩⟩\n#align nhds_basis_opens nhds_basis_opens\n\n",
 "nhds_basis_closeds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_closeds (a : α) : ((nhds) a).has_basis (fun s : set α => a ∉ s ∧ is_closed s) compl :=\n  ⟨fun t =>\n    (nhds_basis_opens a).mem_iff.trans <|\n      compl_surjective.exists.trans <| by simp only [is_open_compl_iff, mem_compl_iff]⟩\n#align nhds_basis_closeds nhds_basis_closeds\n\n",
 "ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cluster_pt.ne_bot {x : α} {F : filter α} (h : cluster_pt x F) : ne_bot («expr ⊓ » ((nhds) x) F) :=\n  h\n#align cluster_pt.ne_bot cluster_pt.ne_bot\n\n",
 "monotone_closure":
 "theorem monotone_closure (α : Type _) [topological_space α] : monotone (@closure α _) := fun _ _ => closure_mono\n#align monotone_closure monotone_closure\n\n",
 "mono":
 "/-- If `x` is an accumulation point of `F` and `F ≤ G`, then\n`x` is an accumulation point of `D. -/\ntheorem acc_pt.mono {x : α} {F G : filter α} (h : acc_pt x F) (hFG : F ≤ G) : acc_pt x G :=\n  ⟨ne_bot_of_le_ne_bot h.ne (inf_le_inf_left _ hFG)⟩\n#align acc_pt.mono acc_pt.mono\n\n",
 "mem_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem is_closed.mem_of_tendsto {f : β → α} {b : filter β} {a : α} {s : set α} [ne_bot b] (hs : is_closed s)\n    (hf : tendsto f b ((nhds) a))\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" b\n        (f x ∈ s)) :\n    a ∈ s :=\n  hs.mem_of_frequently_of_tendsto h.frequently hf\n#align is_closed.mem_of_tendsto is_closed.mem_of_tendsto\n\n",
 "mem_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_of_mem_nhds {a : α} {s : set α} : s ∈ (nhds) a → a ∈ s := fun H =>\n  let ⟨t, ht, _, hs⟩ := mem_nhds_iff.1 H\n  ht hs\n#align mem_of_mem_nhds mem_of_mem_nhds\n\n",
 "mem_of_frequently_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_closed.mem_of_frequently_of_tendsto {f : β → α} {b : filter β} {a : α} {s : set α} (hs : is_closed s)\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" b\n        (f x ∈ s))\n    (hf : tendsto f b ((nhds) a)) : a ∈ s :=\n  (hf.frequently <|\n        show\n          «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" b\n            ((fun y => y ∈ s) (f x))\n          from h).mem_of_closed\n    hs\n#align is_closed.mem_of_frequently_of_tendsto is_closed.mem_of_frequently_of_tendsto\n\n",
 "mem_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.frequently.mem_of_closed {a : α} {s : set α}\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" ((nhds) a)\n        (x ∈ s))\n    (hs : is_closed s) : a ∈ s :=\n  hs.closure_subset h.mem_closure\n#align filter.frequently.mem_of_closed filter.frequently.mem_of_closed\n\n",
 "mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_open.mem_nhds_iff {a : α} {s : set α} (hs : is_open s) : s ∈ (nhds) a ↔ a ∈ s :=\n  ⟨mem_of_mem_nhds, fun ha => mem_nhds_iff.2 ⟨s, Subset.refl _, hs, ha⟩⟩\n#align is_open.mem_nhds_iff is_open.mem_nhds_iff\n\n",
 "mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem dense_range.mem_nhds {f : κ → β} (h : dense_range f) {b : β} {U : set β} (U_in : U ∈ (nhds) b) : ∃ a, f a ∈ U :=\n  let ⟨a, ha⟩ := h.exists_mem_open is_open_interior ⟨b, mem_interior_iff_mem_nhds.2 U_in⟩\n  ⟨a, interior_subset ha⟩\n#align dense_range.mem_nhds dense_range.mem_nhds\n\n",
 "mem_interior_iff_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_interior_iff_mem_nhds {s : set α} {a : α} : a ∈ interior s ↔ s ∈ (nhds) a := by\n  rw [interior_eq_nhds', mem_set_of_eq]\n#align mem_interior_iff_mem_nhds mem_interior_iff_mem_nhds\n\n",
 "mem_interior":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\ntheorem mem_interior {s : set α} {x : α} : x ∈ interior s ↔ ∃ (t : _)(_ : t ⊆ s), is_open t ∧ x ∈ t := by\n  simp only [interior, mem_sUnion, mem_set_of_eq, exists_prop, and_assoc', and_left_comm]\n#align mem_interior mem_interior\n\n",
 "mem_iff_closure_subset":
 "theorem is_closed.mem_iff_closure_subset {s : set α} (hs : is_closed s) {x : α} : x ∈ s ↔ closure ({x} : set α) ⊆ s :=\n  (hs.closure_subset_iff.trans Set.singleton_subset_iff).symm\n#align is_closed.mem_iff_closure_subset is_closed.mem_iff_closure_subset\n\n",
 "mem_closure_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem mem_closure_of_tendsto {f : β → α} {b : filter β} {a : α} {s : set α} [ne_bot b] (hf : tendsto f b ((nhds) a))\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" b\n        (f x ∈ s)) :\n    a ∈ closure s :=\n  mem_closure_of_frequently_of_tendsto h.frequently hf\n#align mem_closure_of_tendsto mem_closure_of_tendsto\n\n",
 "mem_closure_of_mem_closure_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_of_mem_closure_union {s₁ s₂ : set α} {x : α} (h : x ∈ closure (s₁ ∪ s₂))\n    (h₁ : «expr ᶜ» s₁ ∈ (nhds) x) : x ∈ closure s₂ :=\n  by\n  rw [mem_closure_iff_nhds_ne_bot] at *\n  rwa [←\n    calc\n      «expr ⊓ » ((nhds) x) (principal (s₁ ∪ s₂)) = «expr ⊓ » ((nhds) x) («expr ⊔ » (principal s₁) (principal s₂)) := by\n        rw [sup_principal]\n      _ = «expr ⊔ » («expr ⊓ » ((nhds) x) (principal s₁)) («expr ⊓ » ((nhds) x) (principal s₂)) := inf_sup_left\n      _ = «expr ⊔ » («expr⊥») («expr ⊓ » ((nhds) x) (principal s₂)) := by rw [inf_principal_eq_bot.mpr h₁]\n      _ = «expr ⊓ » ((nhds) x) (principal s₂) := bot_sup_eq\n      ]\n#align mem_closure_of_mem_closure_union mem_closure_of_mem_closure_union\n\n",
 "mem_closure_of_frequently_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_of_frequently_of_tendsto {f : β → α} {b : filter β} {a : α} {s : set α}\n    (h :\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" b\n        (f x ∈ s))\n    (hf : tendsto f b ((nhds) a)) : a ∈ closure s :=\n  filter.frequently.mem_closure <| hf.frequently h\n#align mem_closure_of_frequently_of_tendsto mem_closure_of_frequently_of_tendsto\n\n",
 "mem_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_closure_image {f : α → β} {x : α} {s : set α} (hf : continuous_at f x) (hx : x ∈ closure s) :\n    f x ∈ closure («expr '' » f s) :=\n  mem_closure_of_frequently_of_tendsto ((mem_closure_iff_frequently.1 hx).mono fun x => mem_image_of_mem _) hf\n#align mem_closure_image mem_closure_image\n\n",
 "mem_closure_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- `x` belongs to the closure of `s` if and only if some ultrafilter\n  supported on `s` converges to `x`. -/\ntheorem mem_closure_iff_ultrafilter {s : set α} {x : α} : x ∈ closure s ↔ ∃ u : ultrafilter α, s ∈ u ∧ ↑u ≤ (nhds) x :=\n  by simp [closure_eq_cluster_pts, cluster_pt, ← exists_ultrafilter_iff, and_comm]\n#align mem_closure_iff_ultrafilter mem_closure_iff_ultrafilter\n\n",
 "mem_closure_iff_nhds_within_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem mem_closure_iff_nhds_within_ne_bot {s : set α} {x : α} : x ∈ closure s ↔ ne_bot (nhds_within s x) :=\n  mem_closure_iff_cluster_pt\n#align mem_closure_iff_nhds_within_ne_bot mem_closure_iff_nhds_within_ne_bot\n\n",
 "mem_closure_iff_nhds_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem mem_closure_iff_nhds_ne_bot {s : set α} :\n    a ∈ closure s ↔ «expr ⊓ » ((nhds) a) ((filter.principal) s) ≠ «expr⊥» :=\n  mem_closure_iff_cluster_pt.trans ne_bot_iff\n#align mem_closure_iff_nhds_ne_bot mem_closure_iff_nhds_ne_bot\n\n",
 "mem_closure_iff_nhds_basis'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_iff_nhds_basis' {a : α} {p : ι → Prop} {s : ι → set α} (h : ((nhds) a).has_basis p s) {t : set α} :\n    a ∈ closure t ↔ ∀ i, p i → (s i ∩ t).nonempty :=\n  mem_closure_iff_cluster_pt.trans <|\n    (h.cluster_pt_iff (has_basis_principal _)).trans <| by simp only [exists_prop, forall_const]\n#align mem_closure_iff_nhds_basis' mem_closure_iff_nhds_basis'\n\n",
 "mem_closure_iff_nhds_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_iff_nhds_basis {a : α} {p : ι → Prop} {s : ι → set α} (h : ((nhds) a).has_basis p s) {t : set α} :\n    a ∈ closure t ↔ ∀ i, p i → ∃ y ∈ t, y ∈ s i :=\n  (mem_closure_iff_nhds_basis' h).trans <| by simp only [Set.Nonempty, mem_inter_iff, exists_prop, and_comm']\n#align mem_closure_iff_nhds_basis mem_closure_iff_nhds_basis\n\n",
 "mem_closure_iff_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_iff_nhds' {s : set α} {a : α} : a ∈ closure s ↔ ∀ t ∈ (nhds) a, ∃ y : s, ↑y ∈ t := by\n  simp only [mem_closure_iff_nhds, Set.inter_nonempty_iff_exists_right, SetCoe.exists, subtype.coe_mk]\n#align mem_closure_iff_nhds' mem_closure_iff_nhds'\n\n",
 "mem_closure_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_iff_nhds {s : set α} {a : α} : a ∈ closure s ↔ ∀ t ∈ (nhds) a, (t ∩ s).nonempty :=\n  mem_closure_iff_cluster_pt.trans cluster_pt_principal_iff\n#align mem_closure_iff_nhds mem_closure_iff_nhds\n\n",
 "mem_closure_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_iff_frequently {s : set α} {a : α} :\n    a ∈ closure s ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" ((nhds) a)\n        (x ∈ s) :=\n  by rw [filter.frequently, filter.eventually, ← mem_interior_iff_mem_nhds, closure_eq_compl_interior_compl] <;> rfl\n#align mem_closure_iff_frequently mem_closure_iff_frequently\n\n",
 "mem_closure_iff_comap_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem mem_closure_iff_comap_ne_bot {A : set α} {x : α} : x ∈ closure A ↔ ne_bot (comap (coe : A → α) ((nhds) x)) := by\n  simp_rw [mem_closure_iff_nhds, comap_ne_bot_iff, Set.inter_nonempty_iff_exists_right, SetCoe.exists, subtype.coe_mk]\n#align mem_closure_iff_comap_ne_bot mem_closure_iff_comap_ne_bot\n\n",
 "mem_closure_iff_cluster_pt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem mem_closure_iff_cluster_pt {s : set α} {a : α} : a ∈ closure s ↔ cluster_pt a ((filter.principal) s) :=\n  mem_closure_iff_frequently.trans cluster_pt_principal_iff_frequently.symm\n#align mem_closure_iff_cluster_pt mem_closure_iff_cluster_pt\n\n",
 "mem_closure_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_closure_iff {s : set α} {a : α} : a ∈ closure s ↔ ∀ o, is_open o → a ∈ o → (o ∩ s).nonempty :=\n  ⟨fun h o oo ao =>\n    by_contradiction fun os =>\n      have : s ⊆ «expr ᶜ» o := fun x xs xo => os ⟨x, xo, xs⟩\n      closure_minimal this (is_closed_compl_iff.2 oo) h ao,\n    fun H c ⟨h₁, h₂⟩ =>\n    by_contradiction fun nc =>\n      let ⟨x, hc, hs⟩ := H _ h₁.is_open_compl nc\n      hc (h₂ hs)⟩\n#align mem_closure_iff mem_closure_iff\n\n",
 "map_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem map_nhds {a : α} {f : α → β} :\n    map f ((nhds) a) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        ((filter.principal) (image f s)) :=\n  ((nhds_basis_opens a).map f).eq_binfi\n#align map_nhds map_nhds\n\n",
 "map_mem_closure":
 "theorem map_mem_closure {s : set α} {t : set β} {f : α → β} {a : α} (hf : continuous f) (ha : a ∈ closure s)\n    (ht : MapsTo f s t) : f a ∈ closure t :=\n  ht.closure hf ha\n#align map_mem_closure map_mem_closure\n\n",
 "map_cluster_pt_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem map_cluster_pt_of_comp {ι δ : Type _} {F : filter ι} {φ : δ → ι} {p : filter δ} {x : α} {u : ι → α} [ne_bot p]\n    (h : tendsto φ p F) (H : tendsto (u ∘ φ) p ((nhds) x)) : map_cluster_pt x F u :=\n  by\n  have :=\n    calc\n      map (u ∘ φ) p = map u (map φ p) := map_map\n      _ ≤ map u F := map_mono h\n      \n  have : map (u ∘ φ) p ≤ «expr ⊓ » ((nhds) x) (map u F) := le_inf H this\n  exact ne_bot_of_le this\n#align map_cluster_pt_of_comp map_cluster_pt_of_comp\n\n",
 "map_cluster_pt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\ntheorem map_cluster_pt_iff {ι : Type _} (x : α) (F : filter ι) (u : ι → α) :\n    map_cluster_pt x F u ↔\n      ∀ s ∈ (nhds) x,\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" F\n          (u a ∈ s) :=\n  by\n  simp_rw [map_cluster_pt, cluster_pt, inf_ne_bot_iff_frequently_left, frequently_map]\n  rfl\n#align map_cluster_pt_iff map_cluster_pt_iff\n\n",
 "map":
 "theorem cluster_pt.map {x : α} {la : filter α} {lb : filter β} (H : cluster_pt x la) {f : α → β}\n    (hfc : continuous_at f x) (hf : tendsto f la lb) : cluster_pt (f x) lb :=\n  ⟨ne_bot_of_le_ne_bot ((map_ne_bot_iff f).2 H).ne <| hfc.tendsto.inf hf⟩\n#align cluster_pt.map cluster_pt.map\n\n",
 "lift'_closure_eq_self":
 "theorem filter.has_basis.lift'_closure_eq_self {l : filter α} {p : ι → Prop} {s : ι → set α} (h : l.has_basis p s)\n    (hc : ∀ i, p i → is_closed (s i)) : l.lift' closure = l :=\n  le_antisymm (h.ge_iff.2 fun i hi => (hc i hi).closure_eq ▸ mem_lift' (h.mem_of_mem hi)) l.le_lift'_closure\n#align filter.has_basis.lift'_closure_eq_self filter.has_basis.lift'_closure_eq_self\n\n",
 "lift'_closure_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem filter.lift'_closure_eq_bot {l : filter α} : l.lift' closure = «expr⊥» ↔ l = «expr⊥» :=\n  ⟨fun h => bot_unique <| h ▸ l.le_lift'_closure, fun h =>\n    h.symm ▸ by rw [lift'_bot (monotone_closure _), closure_empty, principal_empty]⟩\n#align filter.lift'_closure_eq_bot filter.lift'_closure_eq_bot\n\n",
 "lift'_closure":
 "theorem filter.has_basis.lift'_closure {l : filter α} {p : ι → Prop} {s : ι → set α} (h : l.has_basis p s) :\n    (l.lift' closure).has_basis p fun i => closure (s i) :=\n  h.lift' (monotone_closure α)\n#align filter.has_basis.lift'_closure filter.has_basis.lift'_closure\n\n",
 "le_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A filter lies below the neighborhood filter at `a` iff it contains every open set around `a`. -/\ntheorem le_nhds_iff {f a} : f ≤ (nhds) a ↔ ∀ s : set α, a ∈ s → is_open s → s ∈ f := by simp [nhds_def]\n#align le_nhds_iff le_nhds_iff\n\n",
 "le_nhds_Lim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a filter `f` is majorated by some `𝓝 a`, then it is majorated by `𝓝 (Lim f)`. We formulate\nthis lemma with a `[nonempty α]` argument of `Lim` derived from `h` to make it useful for types\nwithout a `[nonempty α]` instance. Because of the built-in proof irrelevance, Lean will unify\nthis instance with any other instance. -/\ntheorem le_nhds_Lim {f : filter α} (h : ∃ a, f ≤ (nhds) a) : f ≤ (nhds) (@Lim _ _ (nonempty_of_exists h) f) :=\n  epsilon_spec h\n#align le_nhds_Lim le_nhds_Lim\n\n",
 "le_lift'_closure":
 "theorem filter.le_lift'_closure (l : filter α) : l ≤ l.lift' closure :=\n  le_lift'.2 fun s hs => mem_of_superset hs subset_closure\n#align filter.le_lift'_closure filter.le_lift'_closure\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem continuous_at.iterate {f : α → α} {x : α} (hf : continuous_at f x) (hx : f x = x) (n : ℕ) :\n    continuous_at («expr ^[ ]» f n) x :=\n  nat.rec_on n continuous_at_id fun n ihn =>\n    show continuous_at («expr ^[ ]» f n ∘ f) x from continuous_at.comp (hx.symm ▸ ihn) hf\n#align continuous_at.iterate continuous_at.iterate\n\n",
 "is_open_univ":
 "@[simp]\ntheorem is_open_univ : is_open (univ : set α) :=\n  topological_space.is_open_univ _\n#align is_open_univ is_open_univ\n\n",
 "is_open_singleton_iff_punctured_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_open_singleton_iff_punctured_nhds {α : Type _} [topological_space α] (a : α) :\n    is_open ({a} : set α) ↔ nhds_within.ne a = «expr⊥» := by\n  rw [is_open_singleton_iff_nhds_eq_pure, nhds_within, ← mem_iff_inf_principal_compl, ← le_pure_iff,\n    nhds_ne_bot.le_pure_iff]\n#align is_open_singleton_iff_punctured_nhds is_open_singleton_iff_punctured_nhds\n\n",
 "is_open_singleton_iff_nhds_eq_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_open_singleton_iff_nhds_eq_pure (a : α) : is_open ({a} : set α) ↔ (nhds) a = pure a :=\n  by\n  constructor\n  · intro h\n    apply le_antisymm _ (pure_le_nhds a)\n    rw [le_pure_iff]\n    exact h.mem_nhds (mem_singleton a)\n  · intro h\n    simp [is_open_iff_nhds, h]\n#align is_open_singleton_iff_nhds_eq_pure is_open_singleton_iff_nhds_eq_pure\n\n",
 "is_open_set_of_eventually_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_open_set_of_eventually_nhds {p : α → Prop} :\n    is_open\n      { x |\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          ((nhds) x) (p y) } :=\n  by simp only [← interior_set_of_eq, is_open_interior]\n#align is_open_set_of_eventually_nhds is_open_set_of_eventually_nhds\n\n",
 "is_open_sUnion":
 "theorem is_open_sUnion {s : set (set α)} (h : ∀ t ∈ s, is_open t) : is_open (⋃₀ s) :=\n  topological_space.is_open_sUnion _ s h\n#align is_open_sUnion is_open_sUnion\n\n",
 "is_open_sInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\ntheorem is_open_sInter {s : set (set α)} (hs : s.finite) : (∀ t ∈ s, is_open t) → is_open («expr⋂₀ » s) :=\n  finite.induction_on hs (fun _ => by rw [sInter_empty] <;> exact is_open_univ) fun a s has hs ih h => by\n    rw [sInter_insert] <;> exact is_open.inter (h _ <| mem_insert _ _) (ih fun t => h t ∘ mem_insert_of_mem _)\n#align is_open_sInter is_open_sInter\n\n",
 "is_open_interior":
 "@[simp]\ntheorem is_open_interior {s : set α} : is_open (interior s) :=\n  is_open_sUnion fun t ⟨h₁, h₂⟩ => h₁\n#align is_open_interior is_open_interior\n\n",
 "is_open_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_open_iff_ultrafilter {s : set α} : is_open s ↔ ∀ x ∈ s, ∀ (l : ultrafilter α), ↑l ≤ (nhds) x → s ∈ l := by\n  simp_rw [is_open_iff_mem_nhds, ← mem_iff_ultrafilter]\n#align is_open_iff_ultrafilter is_open_iff_ultrafilter\n\n",
 "is_open_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_open_iff_nhds {s : set α} : is_open s ↔ ∀ a ∈ s, (nhds) a ≤ (filter.principal) s :=\n  calc\n    is_open s ↔ s ⊆ interior s := subset_interior_iff_is_open.symm\n    _ ↔ ∀ a ∈ s, (nhds) a ≤ (filter.principal) s := by rw [interior_eq_nhds] <;> rfl\n    \n#align is_open_iff_nhds is_open_iff_nhds\n\n",
 "is_open_iff_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_open_iff_mem_nhds {s : set α} : is_open s ↔ ∀ a ∈ s, s ∈ (nhds) a :=\n  is_open_iff_nhds.trans <| forall_congr' fun _ => imp_congr_right fun _ => le_principal_iff\n#align is_open_iff_mem_nhds is_open_iff_mem_nhds\n\n",
 "is_open_iff_forall_mem_open":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\ntheorem is_open_iff_forall_mem_open : is_open s ↔ ∀ x ∈ s, ∃ (t : _)(_ : t ⊆ s), is_open t ∧ x ∈ t := by\n  rw [← subset_interior_iff_is_open] <;> simp only [subset_def, mem_interior]\n#align is_open_iff_forall_mem_open is_open_iff_forall_mem_open\n\n",
 "is_open_iff_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A set `s` is open iff for every point `x` in `s` and every `y` close to `x`, `y` is in `s`. -/\ntheorem is_open_iff_eventually {s : set α} :\n    is_open s ↔\n      ∀ x,\n        x ∈ s →\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n            ((nhds) x) (y ∈ s) :=\n  is_open_iff_mem_nhds\n#align is_open_iff_eventually is_open_iff_eventually\n\n",
 "is_open_fold":
 "theorem is_open_fold {s : set α} {t : topological_space α} : t.is_open s = @is_open α t s :=\n  rfl\n#align is_open_fold is_open_fold\n\n",
 "is_open_empty":
 "@[simp]\ntheorem is_open_empty : is_open (∅ : set α) := by rw [← sUnion_empty] <;> exact is_open_sUnion fun a => false.elim\n#align is_open_empty is_open_empty\n\n",
 "is_open_const":
 "theorem is_open_const {p : Prop} : is_open { a : α | p } :=\n  by_cases (fun this : p => by simp only [this] <;> exact is_open_univ) fun this : ¬p => by\n    simp only [this] <;> exact is_open_empty\n#align is_open_const is_open_const\n\n",
 "is_open_compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem is_open_compl_iff {s : set α} : is_open («expr ᶜ» s) ↔ is_closed s :=\n  ⟨fun h => ⟨h⟩, fun h => h.is_open_compl⟩\n#align is_open_compl_iff is_open_compl_iff\n\n",
 "is_open_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_open_bUnion {s : set β} {f : β → set α} (h : ∀ i ∈ s, is_open (f i)) :\n    is_open («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  is_open_Union fun i => is_open_Union fun hi => h i hi\n#align is_open_bUnion is_open_bUnion\n\n",
 "is_open_bInter_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem is_open_bInter_finset {s : Finset β} {f : β → set α} (h : ∀ i ∈ s, is_open (f i)) :\n    is_open («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  is_open_bInter (to_finite _) h\n#align is_open_bInter_finset is_open_bInter_finset\n\n",
 "is_open_bInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem is_open_bInter {s : set β} {f : β → set α} (hs : s.finite) :\n    (∀ i ∈ s, is_open (f i)) →\n      is_open («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  finite.induction_on hs (fun _ => by rw [bInter_empty] <;> exact is_open_univ) fun a s has hs ih h => by\n    rw [bInter_insert] <;> exact is_open.inter (h a (mem_insert _ _)) (ih fun i hi => h i (mem_insert_of_mem _ hi))\n#align is_open_bInter is_open_bInter\n\n",
 "is_open_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_open_Union {f : ι → set α} (h : ∀ i, is_open (f i)) :\n    is_open («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  is_open_sUnion <| by rintro _ ⟨i, rfl⟩ <;> exact h i\n#align is_open_Union is_open_Union\n\n",
 "is_open_Inter_prop":
 "theorem is_open_Inter_prop {p : Prop} {s : p → set α} (h : ∀ h : p, is_open (s h)) : is_open (interᵢ s) := by\n  by_cases p <;> simp [*]\n#align is_open_Inter_prop is_open_Inter_prop\n\n",
 "is_open_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem is_open_Inter [Finite β] {s : β → set α} (h : ∀ i, is_open (s i)) :\n    is_open («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)) :=\n  suffices\n    is_open («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)) by\n    simpa\n  is_open_bInter finite_univ fun i _ => h i\n#align is_open_Inter is_open_Inter\n\n",
 "is_closed_univ":
 "@[simp]\ntheorem is_closed_univ : is_closed (univ : set α) :=\n  by\n  rw [← is_open_compl_iff, compl_univ]\n  exact is_open_empty\n#align is_closed_univ is_closed_univ\n\n",
 "is_closed_set_of_cluster_pt":
 "/-- The set of cluster points of a filter is closed. In particular, the set of limit points\nof a sequence is closed. -/\ntheorem is_closed_set_of_cluster_pt {f : filter α} : is_closed { x | cluster_pt x f } :=\n  by\n  simp only [cluster_pt, inf_ne_bot_iff_frequently_left, set_of_forall, imp_iff_not_or]\n  refine' is_closed_Inter fun p => is_closed.union _ _ <;> apply is_closed_compl_iff.2\n  exacts[is_open_set_of_eventually_nhds, is_open_const]\n#align is_closed_set_of_cluster_pt is_closed_set_of_cluster_pt\n\n",
 "is_closed_sInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\ntheorem is_closed_sInter {s : set (set α)} : (∀ t ∈ s, is_closed t) → is_closed («expr⋂₀ » s) := by\n  simpa only [← is_open_compl_iff, compl_sInter, sUnion_image] using is_open_bUnion\n#align is_closed_sInter is_closed_sInter\n\n",
 "is_closed_of_closure_subset":
 "theorem is_closed_of_closure_subset {s : set α} (h : closure s ⊆ s) : is_closed s := by\n  rw [subset.antisymm subset_closure h] <;> exact is_closed_closure\n#align is_closed_of_closure_subset is_closed_of_closure_subset\n\n",
 "is_closed_imp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_closed_imp {p q : α → Prop} (hp : is_open { x | p x }) (hq : is_closed { x | q x }) :\n    is_closed { x | p x → q x } :=\n  by\n  have : { x | p x → q x } = «expr ᶜ» { x | p x } ∪ { x | q x } := Set.ext fun x => imp_iff_not_or\n  rw [this] <;> exact is_closed.union (is_closed_compl_iff.mpr hp) hq\n#align is_closed_imp is_closed_imp\n\n",
 "is_closed_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_closed_iff_nhds {s : set α} : is_closed s ↔ ∀ x, (∀ U ∈ (nhds) x, (U ∩ s).nonempty) → x ∈ s := by\n  simp_rw [is_closed_iff_cluster_pt, cluster_pt, inf_principal_ne_bot_iff]\n#align is_closed_iff_nhds is_closed_iff_nhds\n\n",
 "is_closed_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A set `s` is closed iff for every point `x`, if there is a point `y` close to `x` that belongs\nto `s` then `x` is in `s`. -/\ntheorem is_closed_iff_frequently {s : set α} :\n    is_closed s ↔\n      ∀ x,\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n            ((nhds) x) (y ∈ s) →\n          x ∈ s :=\n  by\n  rw [← closure_subset_iff_is_closed]\n  apply forall_congr' fun x => _\n  rw [mem_closure_iff_frequently]\n#align is_closed_iff_frequently is_closed_iff_frequently\n\n",
 "is_closed_iff_cluster_pt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem is_closed_iff_cluster_pt {s : set α} : is_closed s ↔ ∀ a, cluster_pt a ((filter.principal) s) → a ∈ s :=\n  calc\n    is_closed s ↔ closure s ⊆ s := closure_subset_iff_is_closed.symm\n    _ ↔ ∀ a, cluster_pt a ((filter.principal) s) → a ∈ s := by simp only [subset_def, mem_closure_iff_cluster_pt]\n    \n#align is_closed_iff_cluster_pt is_closed_iff_cluster_pt\n\n",
 "is_closed_frontier":
 "/-- The frontier of a set is closed. -/\ntheorem is_closed_frontier {s : set α} : is_closed (frontier s) := by\n  rw [frontier_eq_closure_inter_closure] <;> exact is_closed.inter is_closed_closure is_closed_closure\n#align is_closed_frontier is_closed_frontier\n\n",
 "is_closed_empty":
 "@[simp]\ntheorem is_closed_empty : is_closed (∅ : set α) :=\n  by\n  rw [← is_open_compl_iff, compl_empty]\n  exact is_open_univ\n#align is_closed_empty is_closed_empty\n\n",
 "is_closed_compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem is_closed_compl_iff {s : set α} : is_closed («expr ᶜ» s) ↔ is_open s := by rw [← is_open_compl_iff, compl_compl]\n#align is_closed_compl_iff is_closed_compl_iff\n\n",
 "is_closed_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_open.is_closed_compl {s : set α} (hs : is_open s) : is_closed («expr ᶜ» s) :=\n  is_closed_compl_iff.2 hs\n#align is_open.is_closed_compl is_open.is_closed_compl\n\n",
 "is_closed_closure":
 "@[simp]\ntheorem is_closed_closure {s : set α} : is_closed (closure s) :=\n  is_closed_sInter fun t ⟨h₁, h₂⟩ => h₁\n#align is_closed_closure is_closed_closure\n\n",
 "is_closed_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_closed_bUnion {s : set β} {f : β → set α} (hs : s.finite) :\n    (∀ i ∈ s, is_closed (f i)) →\n      is_closed\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  finite.induction_on hs (fun _ => by rw [bUnion_empty] <;> exact is_closed_empty) fun a s has hs ih h => by\n    rw [bUnion_insert] <;> exact is_closed.union (h a (mem_insert _ _)) (ih fun i hi => h i (mem_insert_of_mem _ hi))\n#align is_closed_bUnion is_closed_bUnion\n\n",
 "is_closed_bInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem is_closed_bInter {s : set β} {f : β → set α} (h : ∀ i ∈ s, is_closed (f i)) :\n    is_closed («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  is_closed_Inter fun i => is_closed_Inter <| h i\n#align is_closed_bInter is_closed_bInter\n\n",
 "is_closed_Union_prop":
 "theorem is_closed_Union_prop {p : Prop} {s : p → set α} (h : ∀ h : p, is_closed (s h)) : is_closed (unionᵢ s) := by\n  by_cases p <;> simp [*]\n#align is_closed_Union_prop is_closed_Union_prop\n\n",
 "is_closed_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_closed_Union [Finite β] {s : β → set α} (h : ∀ i, is_closed (s i)) :\n    is_closed («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  suffices\n    is_closed («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) by\n    convert this <;> simp [Set.ext_iff]\n  is_closed_bUnion finite_univ fun i _ => h i\n#align is_closed_Union is_closed_Union\n\n",
 "is_closed_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem is_closed_Inter {f : ι → set α} (h : ∀ i, is_closed (f i)) :\n    is_closed («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  is_closed_sInter fun t ⟨i, (HEq : f i = t)⟩ => HEq ▸ h i\n#align is_closed_Inter is_closed_Inter\n\n",
 "interior_univ":
 "@[simp]\ntheorem interior_univ : interior (univ : set α) = univ :=\n  is_open_univ.interior_eq\n#align interior_univ interior_univ\n\n",
 "interior_union_right":
 "theorem is_closed.interior_union_right {s t : set α} (h : is_closed t) : interior (s ∪ t) ⊆ interior s ∪ t := by\n  simpa only [union_comm] using h.interior_union_left\n#align is_closed.interior_union_right is_closed.interior_union_right\n\n",
 "interior_union_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_closed.interior_union_left {s t : set α} (h : is_closed s) : interior (s ∪ t) ⊆ s ∪ interior t :=\n  fun a ⟨u, ⟨⟨hu₁, hu₂⟩, ha⟩⟩ =>\n  (classical.em (a ∈ s)).imp_right fun h =>\n    mem_interior.mpr\n      ⟨u ∩ «expr ᶜ» s, fun x hx => (hu₂ hx.1).resolve_left hx.2, is_open.inter hu₁ is_closed.is_open_compl, ⟨ha, h⟩⟩\n#align is_closed.interior_union_left is_closed.interior_union_left\n\n",
 "interior_union_is_closed_of_interior_empty":
 "theorem interior_union_is_closed_of_interior_empty {s t : set α} (h₁ : is_closed s) (h₂ : interior t = ∅) :\n    interior (s ∪ t) = interior s :=\n  have : interior (s ∪ t) ⊆ s := fun x ⟨u, ⟨(hu₁ : is_open u), (hu₂ : u ⊆ s ∪ t)⟩, (hx₁ : x ∈ u)⟩ =>\n    by_contradiction fun hx₂ : x ∉ s =>\n      have : u \\ s ⊆ t := fun x ⟨h₁, h₂⟩ => or.resolve_left (hu₂ h₁) h₂\n      have : u \\ s ⊆ interior t := by rwa [(is_open.sdiff hu₁ h₁).subset_interior_iff]\n      have : u \\ s ⊆ ∅ := by rwa [h₂] at this\n      this ⟨hx₁, hx₂⟩\n  Subset.antisymm (interior_maximal this is_open_interior) (interior_mono <| subset_union_left _ _)\n#align interior_union_is_closed_of_interior_empty interior_union_is_closed_of_interior_empty\n\n",
 "interior_subset_closure":
 "theorem interior_subset_closure {s : set α} : interior s ⊆ closure s :=\n  Subset.trans interior_subset subset_closure\n#align interior_subset_closure interior_subset_closure\n\n",
 "interior_subset":
 "theorem interior_subset {s : set α} : interior s ⊆ s :=\n  sUnion_subset fun t ⟨h₁, h₂⟩ => h₂\n#align interior_subset interior_subset\n\n",
 "interior_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/-- If `x` is not an isolated point of a topological space, then the interior of `{x}` is empty. -/\n@[simp]\ntheorem interior_singleton (x : α) [ne_bot (nhds_within.ne x)] : interior {x} = (∅ : set α) :=\n  interior_eq_empty_iff_dense_compl.2 (dense_compl_singleton x)\n#align interior_singleton interior_singleton\n\n",
 "interior_set_of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem interior_set_of_eq {p : α → Prop} :\n    interior { x | p x } =\n      { x |\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          ((nhds) x) (p y) } :=\n  interior_eq_nhds'\n#align interior_set_of_eq interior_set_of_eq\n\n",
 "interior_sInter_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem interior_sInter_subset (S : set (set α)) :\n    interior («expr⋂₀ » S) ⊆\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (interior s) :=\n  calc\n    interior («expr⋂₀ » S) =\n        interior («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" s) :=\n      by rw [sInter_eq_bInter]\n    _ ⊆ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (interior s) :=\n      interior_Inter₂_subset _ _\n    \n#align interior_sInter_subset interior_sInter_subset\n\n",
 "interior_mono":
 "@[mono]\ntheorem interior_mono {s t : set α} (h : s ⊆ t) : interior s ⊆ interior t :=\n  interior_maximal (Subset.trans interior_subset h) is_open_interior\n#align interior_mono interior_mono\n\n",
 "interior_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem interior_mem_nhds {s : set α} {a : α} : interior s ∈ (nhds) a ↔ s ∈ (nhds) a :=\n  ⟨fun h => mem_of_superset h interior_subset, fun h =>\n    is_open.mem_nhds is_open_interior (mem_interior_iff_mem_nhds.2 h)⟩\n#align interior_mem_nhds interior_mem_nhds\n\n",
 "interior_maximal":
 "theorem interior_maximal {s t : set α} (h₁ : t ⊆ s) (h₂ : is_open t) : t ⊆ interior s :=\n  subset_unionₛ_of_mem ⟨h₂, h₁⟩\n#align interior_maximal interior_maximal\n\n",
 "interior_interior":
 "@[simp]\ntheorem interior_interior {s : set α} : interior (interior s) = interior s :=\n  is_open_interior.interior_eq\n#align interior_interior interior_interior\n\n",
 "interior_inter":
 "@[simp]\ntheorem interior_inter {s t : set α} : interior (s ∩ t) = interior s ∩ interior t :=\n  Subset.antisymm (subset_inter (interior_mono <| inter_subset_left s t) (interior_mono <| inter_subset_right s t))\n    (interior_maximal (inter_subset_inter interior_subset interior_subset) <|\n      is_open.inter is_open_interior is_open_interior)\n#align interior_inter interior_inter\n\n",
 "interior_frontier":
 "/-- The frontier of a closed set has no interior point. -/\ntheorem interior_frontier {s : set α} (h : is_closed s) : interior (frontier s) = ∅ :=\n  by\n  have A : frontier s = s \\ interior s := h.frontier_eq\n  have B : interior (frontier s) ⊆ interior s := by rw [A] <;> exact interior_mono (diff_subset _ _)\n  have C : interior (frontier s) ⊆ frontier s := interior_subset\n  have : interior (frontier s) ⊆ interior s ∩ (s \\ interior s) := subset_inter B (by simpa [A] using C)\n  rwa [inter_diff_self, subset_empty_iff] at this\n#align interior_frontier interior_frontier\n\n",
 "interior_eq_univ":
 "@[simp]\ntheorem interior_eq_univ {s : set α} : interior s = univ ↔ s = univ :=\n  ⟨fun h => univ_subset_iff.mp <| h.symm.trans_le interior_subset, fun h => h.symm ▸ interior_univ⟩\n#align interior_eq_univ interior_eq_univ\n\n",
 "interior_eq_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem interior_eq_nhds' {s : set α} : interior s = { a | s ∈ (nhds) a } :=\n  Set.ext fun x => by simp only [mem_interior, mem_nhds_iff, mem_set_of_eq]\n#align interior_eq_nhds' interior_eq_nhds'\n\n",
 "interior_eq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem interior_eq_nhds {s : set α} : interior s = { a | (nhds) a ≤ (filter.principal) s } :=\n  interior_eq_nhds'.trans <| by simp only [le_principal_iff]\n#align interior_eq_nhds interior_eq_nhds\n\n",
 "interior_eq_iff_is_open":
 "theorem interior_eq_iff_is_open {s : set α} : interior s = s ↔ is_open s :=\n  ⟨fun h => h ▸ is_open_interior, is_open.interior_eq⟩\n#align interior_eq_iff_is_open interior_eq_iff_is_open\n\n",
 "interior_eq_empty_iff_dense_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem interior_eq_empty_iff_dense_compl {s : set α} : interior s = ∅ ↔ dense («expr ᶜ» s) := by\n  rw [dense_iff_closure_eq, closure_compl, compl_univ_iff]\n#align interior_eq_empty_iff_dense_compl interior_eq_empty_iff_dense_compl\n\n",
 "interior_eq":
 "theorem is_open.interior_eq {s : set α} (h : is_open s) : interior s = s :=\n  Subset.antisymm interior_subset (interior_maximal (Subset.refl s) h)\n#align is_open.interior_eq is_open.interior_eq\n\n",
 "interior_empty":
 "@[simp]\ntheorem interior_empty : interior (∅ : set α) = ∅ :=\n  is_open_empty.interior_eq\n#align interior_empty interior_empty\n\n",
 "interior_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem dense.interior_compl {s : set α} (h : dense s) : interior («expr ᶜ» s) = ∅ :=\n  interior_eq_empty_iff_dense_compl.2 <| by rwa [compl_compl]\n#align dense.interior_compl dense.interior_compl\n\n",
 "interior_Inter₂_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem interior_Inter₂_subset (p : ι → Sort _) (s : ∀ i, p i → set α) :\n    interior («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i j)) ⊆\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (interior (s i j)) :=\n  (interior_Inter_subset _).trans <| Inter_mono fun i => interior_Inter_subset _\n#align interior_Inter₂_subset interior_Inter₂_subset\n\n",
 "interior_Inter_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem interior_Inter_subset (s : ι → set α) :\n    interior («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)) ⊆\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (interior (s i)) :=\n  subset_Inter fun i => interior_mono <| interᵢ_subset _ _\n#align interior_Inter_subset interior_Inter_subset\n\n",
 "interior_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp]\ntheorem interior_Inter {ι : Type _} [Finite ι] (f : ι → set α) :\n    interior («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (interior (f i)) :=\n  by\n  cases nonempty_fintype ι\n  convert finset.univ.interior_Inter f <;> simp\n#align interior_Inter interior_Inter\n\n",
 "inter_of_open_right":
 "/-- The intersection of a dense set with an open dense set is a dense set. -/\ntheorem dense.inter_of_open_right {s t : set α} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s ∩ t) :=\n  inter_comm t s ▸ ht.inter_of_open_left hs hto\n#align dense.inter_of_open_right dense.inter_of_open_right\n\n",
 "inter_of_open_left":
 "/-- The intersection of an open dense set with a dense set is a dense set. -/\ntheorem dense.inter_of_open_left {s t : set α} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s ∩ t) :=\n  fun x => closure_minimal hso.inter_closure is_closed_closure <| by simp [hs.closure_eq, ht.closure_eq]\n#align dense.inter_of_open_left dense.inter_of_open_left\n\n",
 "inter_nhds_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem dense.inter_nhds_nonempty {s t : set α} (hs : dense s) {x : α} (ht : t ∈ (nhds) x) : (s ∩ t).nonempty :=\n  let ⟨U, hsub, ho, hx⟩ := mem_nhds_iff.1 ht\n  (hs.inter_open_nonempty U ho ⟨x, hx⟩).mono fun y hy => ⟨hy.2, hsub hy.1⟩\n#align dense.inter_nhds_nonempty dense.inter_nhds_nonempty\n\n",
 "inter_frontier_eq":
 "theorem is_open.inter_frontier_eq {s : set α} (hs : is_open s) : s ∩ frontier s = ∅ := by\n  rw [hs.frontier_eq, inter_diff_self]\n#align is_open.inter_frontier_eq is_open.inter_frontier_eq\n\n",
 "inter_closure":
 "theorem is_open.inter_closure {s t : set α} (h : is_open s) : s ∩ closure t ⊆ closure (s ∩ t) :=\n  compl_subset_compl.mp <| by\n    simpa only [← interior_compl, compl_inter] using is_closed.interior_union_left h.is_closed_compl\n#align is_open.inter_closure is_open.inter_closure\n\n",
 "inter":
 "theorem is_closed.inter (h₁ : is_closed s₁) (h₂ : is_closed s₂) : is_closed (s₁ ∩ s₂) :=\n  by\n  rw [← is_open_compl_iff] at *\n  rw [compl_inter]\n  exact is_open.union h₁ h₂\n#align is_closed.inter is_closed.inter\n\n",
 "image_closure_subset_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_closure_subset_closure_image {f : α → β} {s : set α} (h : continuous f) :\n    «expr '' » f (closure s) ⊆ closure («expr '' » f s) :=\n  ((mapsTo_image f s).closure h).image_subset\n#align image_closure_subset_closure_image image_closure_subset_closure_image\n\n",
 "frontier_univ":
 "@[simp]\ntheorem frontier_univ : frontier (univ : set α) = ∅ := by simp [frontier]\n#align frontier_univ frontier_univ\n\n",
 "frontier_union_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem frontier_union_subset (s t : set α) :\n    frontier (s ∪ t) ⊆ frontier s ∩ closure («expr ᶜ» t) ∪ closure («expr ᶜ» s) ∩ frontier t := by\n  simpa only [frontier_compl, ← compl_union] using frontier_inter_subset («expr ᶜ» s) («expr ᶜ» t)\n#align frontier_union_subset frontier_union_subset\n\n",
 "frontier_subset_closure":
 "theorem frontier_subset_closure {s : set α} : frontier s ⊆ closure s :=\n  diff_subset _ _\n#align frontier_subset_closure frontier_subset_closure\n\n",
 "frontier_subset":
 "theorem is_closed.frontier_subset (hs : is_closed s) : frontier s ⊆ s :=\n  frontier_subset_closure.trans hs.closure_eq.subset\n#align is_closed.frontier_subset is_closed.frontier_subset\n\n",
 "frontier_right":
 "theorem disjoint.frontier_right (hs : is_open s) (hd : Disjoint s t) : Disjoint s (frontier t) :=\n  (hd.symm.frontier_left hs).symm\n#align disjoint.frontier_right disjoint.frontier_right\n\n",
 "frontier_preimage_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem continuous.frontier_preimage_subset {f : α → β} (hf : continuous f) (t : set β) :\n    frontier («expr ⁻¹' » f t) ⊆ «expr ⁻¹' » f (frontier t) :=\n  diff_subset_diff (hf.closure_preimage_subset t) (preimage_interior_subset_interior_preimage hf)\n#align continuous.frontier_preimage_subset continuous.frontier_preimage_subset\n\n",
 "frontier_left":
 "theorem disjoint.frontier_left (ht : is_open t) (hd : Disjoint s t) : Disjoint (frontier s) t :=\n  subset_compl_iff_disjoint_right.1 <|\n    frontier_subset_closure.trans <| closure_minimal (disjoint_left.1 hd) <| is_closed_compl_iff.2 ht\n#align disjoint.frontier_left disjoint.frontier_left\n\n",
 "frontier_interior_subset":
 "theorem frontier_interior_subset {s : set α} : frontier (interior s) ⊆ frontier s :=\n  diff_subset_diff (closure_mono interior_subset) interior_interior.symm.subset\n#align frontier_interior_subset frontier_interior_subset\n\n",
 "frontier_inter_subset":
 "theorem frontier_inter_subset (s t : set α) : frontier (s ∩ t) ⊆ frontier s ∩ closure t ∪ closure s ∩ frontier t :=\n  by\n  simp only [frontier_eq_closure_inter_closure, compl_inter, closure_union]\n  convert inter_subset_inter_left _ (closure_inter_subset_inter_closure s t)\n  simp only [inter_distrib_left, inter_distrib_right, inter_assoc]\n  congr 2\n  apply inter_comm\n#align frontier_inter_subset frontier_inter_subset\n\n",
 "frontier_eq_inter_compl_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem frontier_eq_inter_compl_interior {s : set α} :\n    frontier s = «expr ᶜ» (interior s) ∩ «expr ᶜ» (interior («expr ᶜ» s)) :=\n  by\n  rw [← frontier_compl, ← closure_compl]\n  rfl\n#align frontier_eq_inter_compl_interior frontier_eq_inter_compl_interior\n\n",
 "frontier_eq_closure_inter_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem frontier_eq_closure_inter_closure {s : set α} : frontier s = closure s ∩ closure («expr ᶜ» s) := by\n  rw [closure_compl, frontier, diff_eq]\n#align frontier_eq_closure_inter_closure frontier_eq_closure_inter_closure\n\n",
 "frontier_eq":
 "theorem is_open.frontier_eq {s : set α} (hs : is_open s) : frontier s = closure s \\ s := by\n  rw [frontier, hs.interior_eq]\n#align is_open.frontier_eq is_open.frontier_eq\n\n",
 "frontier_empty":
 "@[simp]\ntheorem frontier_empty : frontier (∅ : set α) = ∅ := by simp [frontier]\n#align frontier_empty frontier_empty\n\n",
 "frontier_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- The complement of a set has the same frontier as the original set. -/\n@[simp]\ntheorem frontier_compl (s : set α) : frontier («expr ᶜ» s) = frontier s := by\n  simp only [frontier_eq_closure_inter_closure, compl_compl, inter_comm]\n#align frontier_compl frontier_compl\n\n",
 "frontier_closure_subset":
 "theorem frontier_closure_subset {s : set α} : frontier (closure s) ⊆ frontier s :=\n  diff_subset_diff closure_closure.subset <| interior_mono subset_closure\n#align frontier_closure_subset frontier_closure_subset\n\n",
 "frequently_frequently_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem frequently_frequently_nhds {p : α → Prop} {a : α} :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" ((nhds) a)\n        («expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n          ((nhds) y) (p x)) ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" ((nhds) a)\n        (p x) :=\n  by\n  rw [← not_iff_not]\n  simp_rw [not_frequently]\n  exact eventually_eventually_nhds\n#align frequently_frequently_nhds frequently_frequently_nhds\n\n",
 "exists_open_set_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\nit contains an open set containing `s`. -/\ntheorem exists_open_set_nhds' {s U : set α}\n    (h :\n      U ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((nhds) x)) :\n    ∃ V : set α, s ⊆ V ∧ is_open V ∧ V ⊆ U :=\n  exists_open_set_nhds (by simpa using h)\n#align exists_open_set_nhds' exists_open_set_nhds'\n\n",
 "exists_open_set_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. -/\ntheorem exists_open_set_nhds {s U : set α} (h : ∀ x ∈ s, U ∈ (nhds) x) : ∃ V : set α, s ⊆ V ∧ is_open V ∧ V ⊆ U :=\n  by\n  have := fun x hx => (nhds_basis_opens x).mem_iff.1 (h x hx)\n  choose! Z hZ hZU using this; choose hZmem hZo using hZ\n  exact\n    ⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (Z x), fun x hx =>\n      mem_bUnion hx (hZmem x hx), is_open_bUnion hZo, Union₂_subset hZU⟩\n#align exists_open_set_nhds exists_open_set_nhds\n\n",
 "exists_mem_open":
 "theorem dense_range.exists_mem_open (hf : dense_range f) {s : set β} (ho : is_open s) (hs : s.nonempty) :\n    ∃ a, f a ∈ s :=\n  exists_range_iff.1 <| hf.exists_mem_open ho hs\n#align dense_range.exists_mem_open dense_range.exists_mem_open\n\n",
 "eventually_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A predicate is true in a neighborhood of `a` iff it is true for all the points in an open set\ncontaining `a`. -/\ntheorem eventually_nhds_iff {a : α} {p : α → Prop} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p x) ↔\n      ∃ t : set α, (∀ x ∈ t, p x) ∧ is_open t ∧ a ∈ t :=\n  mem_nhds_iff.trans <| by simp only [subset_def, exists_prop, mem_set_of_eq]\n#align eventually_nhds_iff eventually_nhds_iff\n\n",
 "eventually_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If a predicate is true in a neighbourhood of `a`, then for `y` sufficiently close\nto `a` this predicate is true in a neighbourhood of `y`. -/\ntheorem filter.eventually.eventually_nhds {p : α → Prop} {a : α}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p y)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      («expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n        ((nhds) y) (p x)) :=\n  let ⟨t, htp, hto, ha⟩ := eventually_nhds_iff.1 h\n  eventually_nhds_iff.2 ⟨t, fun x hx => eventually_nhds_iff.2 ⟨t, htp, hto, hx⟩, hto, ha⟩\n#align filter.eventually.eventually_nhds filter.eventually.eventually_nhds\n\n",
 "eventually_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem eventually_mem_nhds {s : set α} {a : α} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (s ∈ (nhds) x) ↔\n      s ∈ (nhds) a :=\n  eventually_eventually_nhds\n#align eventually_mem_nhds eventually_mem_nhds\n\n",
 "eventually_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_open.eventually_mem {a : α} {s : set α} (hs : is_open s) (ha : a ∈ s) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      (x ∈ s) :=\n  is_open.mem_nhds hs ha\n#align is_open.eventually_mem is_open.eventually_mem\n\n",
 "eventually_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f x ≤ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\n`f x ≤ g x` in a neighbourhood of `y`. -/\ntheorem filter.eventually_le.eventually_le_nhds [LE β] {f g : α → β} {a : α} (h : «expr ≤ᶠ[ ] » f ((nhds) a) g) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      («expr ≤ᶠ[ ] » f ((nhds) y) g) :=\n  h.eventually_nhds\n#align filter.eventually_le.eventually_le_nhds filter.eventually_le.eventually_le_nhds\n\n",
 "eventually_eventually_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem eventually_eventually_nhds {p : α → Prop} {a : α} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        («expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n          ((nhds) y) (p x)) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (p x) :=\n  ⟨fun h => h.self_of_nhds, fun h => h.eventually_nhds⟩\n#align eventually_eventually_nhds eventually_eventually_nhds\n\n",
 "eventually_eventually_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem eventually_eventually_le_nhds [LE β] {f g : α → β} {a : α} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        («expr ≤ᶠ[ ] » f ((nhds) y) g) ↔\n      «expr ≤ᶠ[ ] » f ((nhds) a) g :=\n  eventually_eventually_nhds\n#align eventually_eventually_le_nhds eventually_eventually_le_nhds\n\n",
 "eventually_eventually_eq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[simp]\ntheorem eventually_eventually_eq_nhds {f g : α → β} {a : α} :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        («expr =ᶠ[ ] » f ((nhds) y) g) ↔\n      «expr =ᶠ[ ] » f ((nhds) a) g :=\n  eventually_eventually_nhds\n#align eventually_eventually_eq_nhds eventually_eventually_eq_nhds\n\n",
 "eventually_eq_zero_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_eq_zero_nhds {M₀} [Zero M₀] {a : α} {f : α → M₀} :\n    «expr =ᶠ[ ] » f ((nhds) a) 0 ↔ a ∉ closure (function.support f) := by\n  rw [← mem_compl_iff, ← interior_compl, mem_interior_iff_mem_nhds, function.compl_support] <;> rfl\n#align eventually_eq_zero_nhds eventually_eq_zero_nhds\n\n",
 "eventually_eq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If two functions are equal in a neighbourhood of `a`, then for `y` sufficiently close\nto `a` these functions are equal in a neighbourhood of `y`. -/\ntheorem filter.eventually_eq.eventually_eq_nhds {f g : α → β} {a : α} (h : «expr =ᶠ[ ] » f ((nhds) a) g) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      («expr =ᶠ[ ] » f ((nhds) y) g) :=\n  h.eventually_nhds\n#align filter.eventually_eq.eventually_eq_nhds filter.eventually_eq.eventually_eq_nhds\n\n",
 "eq_of_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.eq_of_nhds {f g : α → β} {a : α} (h : «expr =ᶠ[ ] » f ((nhds) a) g) : f a = g a :=\n  h.self_of_nhds\n#align filter.eventually_eq.eq_of_nhds filter.eventually_eq.eq_of_nhds\n\n",
 "diff_subset_closure_iff":
 "theorem diff_subset_closure_iff {s t : set α} : s \\ t ⊆ closure t ↔ s ⊆ closure t := by\n  rw [diff_subset_iff, union_eq_self_of_subset_left subset_closure]\n#align diff_subset_closure_iff diff_subset_closure_iff\n\n",
 "dense_univ":
 "@[simp]\ntheorem dense_univ : dense (univ : set α) := fun x => subset_closure trivial\n#align dense_univ dense_univ\n\n",
 "dense_range_iff_closure_range":
 "theorem dense_range_iff_closure_range : dense_range f ↔ closure (range f) = univ :=\n  dense_iff_closure_eq\n#align dense_range_iff_closure_range dense_range_iff_closure_range\n\n",
 "dense_range_id":
 "theorem dense_range_id : dense_range (id : α → α) :=\n  function.surjective.dense_range function.surjective_id\n#align dense_range_id dense_range_id\n\n",
 "dense_range_coe":
 "theorem dense.dense_range_coe {s : set α} (h : dense s) : dense_range (coe : s → α) := by\n  simpa only [dense_range, Subtype.range_coe_subtype]\n#align dense.dense_range_coe dense.dense_range_coe\n\n",
 "dense_range":
 "/-- A surjective map has dense range. -/\ntheorem function.surjective.dense_range (hf : function.surjective f) : dense_range f := fun x => by simp [hf.range_eq]\n#align function.surjective.dense_range function.surjective.dense_range\n\n",
 "dense_of_maps_to":
 "/-- If a continuous map with dense range maps a dense set to a subset of `t`, then `t` is a dense\nset. -/\ntheorem dense_range.dense_of_maps_to {f : α → β} (hf' : dense_range f) (hf : continuous f) {s : set α} (hs : dense s)\n    {t : set β} (ht : MapsTo f s t) : dense t :=\n  (hf'.dense_image hf hs).mono ht.image_subset\n#align dense_range.dense_of_maps_to dense_range.dense_of_maps_to\n\n",
 "dense_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image of a dense set under a continuous map with dense range is a dense set. -/\ntheorem dense_range.dense_image {f : α → β} (hf' : dense_range f) (hf : continuous f) {s : set α} (hs : dense s) :\n    dense («expr '' » f s) :=\n  (hf'.mono <| hf.range_subset_closure_image_dense hs).of_closure\n#align dense_range.dense_image dense_range.dense_image\n\n",
 "dense_iff_inter_open":
 "/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem dense_iff_inter_open {s : set α} : dense s ↔ ∀ U, is_open U → U.nonempty → (U ∩ s).nonempty :=\n  by\n  constructor <;> intro h\n  · rintro U U_op ⟨x, x_in⟩\n    exact mem_closure_iff.1 (by simp only [h.closure_eq]) U U_op x_in\n  · intro x\n    rw [mem_closure_iff]\n    intro U U_op x_in\n    exact h U U_op ⟨_, x_in⟩\n#align dense_iff_inter_open dense_iff_inter_open\n\n",
 "dense_iff_closure_eq":
 "theorem dense_iff_closure_eq {s : set α} : dense s ↔ closure s = univ :=\n  eq_univ_iff_forall.symm\n#align dense_iff_closure_eq dense_iff_closure_eq\n\n",
 "dense_compl_singleton_iff_not_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- Complement to a singleton is dense if and only if the singleton is not an open set. -/\ntheorem dense_compl_singleton_iff_not_open {x : α} : dense («expr ᶜ» {x} : set α) ↔ ¬is_open ({x} : set α) :=\n  by\n  fconstructor\n  · intro hd ho\n    exact (hd.inter_open_nonempty _ ho (singleton_nonempty _)).ne_empty (inter_compl_self _)\n  · refine' fun ho => dense_iff_inter_open.2 fun U hU hne => inter_compl_nonempty_iff.2 fun hUx => _\n    obtain rfl : U = {x}\n    exact eq_singleton_iff_nonempty_unique_mem.2 ⟨hne, hUx⟩\n    exact ho hU\n#align dense_compl_singleton_iff_not_open dense_compl_singleton_iff_not_open\n\n",
 "dense_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- If `x` is not an isolated point of a topological space, then `{x}ᶜ` is dense in the whole\nspace. -/\ntheorem dense_compl_singleton (x : α) [ne_bot (nhds_within.ne x)] : dense («expr ᶜ» {x} : set α) :=\n  by\n  intro y\n  rcases eq_or_ne y x with (rfl | hne)\n  · rwa [mem_closure_iff_nhds_within_ne_bot]\n  · exact subset_closure hne\n#align dense_compl_singleton dense_compl_singleton\n\n",
 "dense_closure":
 "/-- The closure of a set `s` is dense if and only if `s` is dense. -/\n@[simp]\ntheorem dense_closure {s : set α} : dense (closure s) ↔ dense s := by rw [dense, dense, closure_closure]\n#align dense_closure dense_closure\n\n",
 "continuous_of_const":
 "theorem continuous_of_const {f : α → β} (h : ∀ x y, f x = f y) : continuous f :=\n  continuous_iff_continuous_at.mpr fun x => filter.eventually_eq.continuous_at <| eventually_of_forall fun y => h y x\n#align continuous_of_const continuous_of_const\n\n",
 "continuous_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_iff_ultrafilter {f : α → β} :\n    continuous f ↔ ∀ (x) (g : ultrafilter α), ↑g ≤ (nhds) x → tendsto f g ((nhds) (f x)) := by\n  simp only [continuous_iff_continuous_at, continuous_at_iff_ultrafilter]\n#align continuous_iff_ultrafilter continuous_iff_ultrafilter\n\n",
 "continuous_iff_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem continuous_iff_is_closed {f : α → β} : continuous f ↔ ∀ s, is_closed s → is_closed («expr ⁻¹' » f s) :=\n  ⟨fun hf s hs => by simpa using (continuous_def.1 hf («expr ᶜ» s) hs.is_open_compl).is_closed_compl, fun hf =>\n    continuous_def.2 fun s => by rw [← is_closed_compl_iff, ← is_closed_compl_iff] <;> exact hf _⟩\n#align continuous_iff_is_closed continuous_iff_is_closed\n\n",
 "continuous_iff_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem continuous_iff_continuous_at {f : α → β} : continuous f ↔ ∀ x, continuous_at f x :=\n  ⟨continuous.tendsto, fun hf : ∀ x, tendsto f ((nhds) x) ((nhds) (f x)) =>\n    continuous_def.2 fun s => fun hs : is_open s =>\n      have : ∀ a, f a ∈ s → s ∈ (nhds) (f a) := fun a ha => is_open.mem_nhds hs ha\n      show is_open («expr ⁻¹' » f s) from is_open_iff_nhds.2 fun a ha => le_principal_iff.2 <| hf _ (this a ha)⟩\n#align continuous_iff_continuous_at continuous_iff_continuous_at\n\n",
 "continuous_id":
 "theorem continuous_id : continuous (id : α → α) :=\n  continuous_def.2 fun s h => h\n#align continuous_id continuous_id\n\n",
 "continuous_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem continuous_def {f : α → β} : continuous f ↔ ∀ s, is_open s → is_open («expr ⁻¹' » f s) :=\n  ⟨fun hf s hs => hf.is_open_preimage s hs, fun h => ⟨h⟩⟩\n#align continuous_def continuous_def\n\n",
 "continuous_const":
 "theorem continuous_const {b : β} : continuous fun a : α => b :=\n  continuous_iff_continuous_at.mpr fun a => continuous_at_const\n#align continuous_const continuous_const\n\n",
 "continuous_at_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_at_iff_ultrafilter {f : α → β} {x} :\n    continuous_at f x ↔ ∀ g : ultrafilter α, ↑g ≤ (nhds) x → tendsto f g ((nhds) (f x)) :=\n  tendsto_iff_ultrafilter f ((nhds) x) ((nhds) (f x))\n#align continuous_at_iff_ultrafilter continuous_at_iff_ultrafilter\n\n",
 "continuous_at_id":
 "theorem continuous_at_id {x : α} : continuous_at id x :=\n  continuous_id.continuous_at\n#align continuous_at_id continuous_at_id\n\n",
 "continuous_at_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_at_def {f : α → β} {x : α} : continuous_at f x ↔ ∀ A ∈ (nhds) (f x), «expr ⁻¹' » f A ∈ (nhds) x :=\n  iff.rfl\n#align continuous_at_def continuous_at_def\n\n",
 "continuous_at_const":
 "theorem continuous_at_const {x : α} {b : β} : continuous_at (fun a : α => b) x :=\n  tendsto_const_nhds\n#align continuous_at_const continuous_at_const\n\n",
 "continuous_at_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_at_congr {f g : α → β} {x : α} (h : «expr =ᶠ[ ] » f ((nhds) x) g) :\n    continuous_at f x ↔ continuous_at g x := by simp only [continuous_at, tendsto_congr' h, h.eq_of_nhds]\n#align continuous_at_congr continuous_at_congr\n\n",
 "continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.continuous_at {x : α} {f : α → β} {y : β} (h : «expr =ᶠ[ ] » f ((nhds) x) fun _ => y) :\n    continuous_at f x :=\n  (continuous_at_congr h).2 tendsto_const_nhds\n#align filter.eventually_eq.continuous_at filter.eventually_eq.continuous_at\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem continuous_at.congr {f g : α → β} {x : α} (hf : continuous_at f x) (h : «expr =ᶠ[ ] » f ((nhds) x) g) :\n    continuous_at g x :=\n  (continuous_at_congr h).1 hf\n#align continuous_at.congr continuous_at.congr\n\n",
 "compl_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_closed.compl_mem_nhds {a : α} {s : set α} (hs : is_closed s) (ha : a ∉ s) : «expr ᶜ» s ∈ (nhds) a :=\n  hs.is_open_compl.mem_nhds (mem_compl ha)\n#align is_closed.compl_mem_nhds is_closed.compl_mem_nhds\n\n",
 "compl_frontier_eq_union_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem compl_frontier_eq_union_interior {s : set α} : «expr ᶜ» (frontier s) = interior s ∪ interior («expr ᶜ» s) :=\n  by\n  rw [frontier_eq_inter_compl_interior]\n  simp only [compl_inter, compl_compl]\n#align compl_frontier_eq_union_interior compl_frontier_eq_union_interior\n\n",
 "comp":
 "/-- Composition of a continuous map with dense range and a function with dense range has dense\nrange. -/\ntheorem dense_range.comp {g : β → γ} {f : κ → β} (hg : dense_range g) (hf : dense_range f) (cg : continuous g) :\n    dense_range (g ∘ f) := by\n  rw [dense_range, range_comp]\n  exact hg.dense_image cg hf\n#align dense_range.comp dense_range.comp\n\n",
 "cluster_pt_principal_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem cluster_pt_principal_iff_frequently {x : α} {s : set α} :\n    cluster_pt x ((filter.principal) s) ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" ((nhds) x)\n        (y ∈ s) :=\n  by simp only [cluster_pt_principal_iff, frequently_iff, Set.Nonempty, exists_prop, mem_inter_iff]\n#align cluster_pt_principal_iff_frequently cluster_pt_principal_iff_frequently\n\n",
 "cluster_pt_principal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- `x` is a cluster point of a set `s` if every neighbourhood of `x` meets `s` on a nonempty\nset. See also `mem_closure_iff_cluster_pt`. -/\ntheorem cluster_pt_principal_iff {x : α} {s : set α} :\n    cluster_pt x ((filter.principal) s) ↔ ∀ U ∈ (nhds) x, (U ∩ s).nonempty :=\n  inf_principal_ne_bot_iff\n#align cluster_pt_principal_iff cluster_pt_principal_iff\n\n",
 "cluster_pt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem ultrafilter.cluster_pt_iff {x : α} {f : ultrafilter α} : cluster_pt x f ↔ ↑f ≤ (nhds) x :=\n  ⟨f.le_of_inf_ne_bot', fun h => cluster_pt.of_le_nhds h⟩\n#align ultrafilter.cluster_pt_iff ultrafilter.cluster_pt_iff\n\n",
 "closure_univ":
 "@[simp]\ntheorem closure_univ : closure (univ : set α) = univ :=\n  is_closed_univ.closure_eq\n#align closure_univ closure_univ\n\n",
 "closure_union":
 "@[simp]\ntheorem closure_union {s t : set α} : closure (s ∪ t) = closure s ∪ closure t :=\n  Subset.antisymm\n    (closure_minimal (union_subset_union subset_closure subset_closure) <|\n      is_closed.union is_closed_closure is_closed_closure)\n    ((monotone_closure α).le_map_sup s t)\n#align closure_union closure_union\n\n",
 "closure_subset_preimage_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem closure_subset_preimage_closure_image {f : α → β} {s : set α} (h : continuous f) :\n    closure s ⊆ «expr ⁻¹' » f (closure («expr '' » f s)) :=\n  by\n  rw [← Set.image_subset_iff]\n  exact image_closure_subset_closure_image h\n#align closure_subset_preimage_closure_image closure_subset_preimage_closure_image\n\n",
 "closure_subset_iff_is_closed":
 "theorem closure_subset_iff_is_closed {s : set α} : closure s ⊆ s ↔ is_closed s :=\n  ⟨is_closed_of_closure_subset, is_closed.closure_subset⟩\n#align closure_subset_iff_is_closed closure_subset_iff_is_closed\n\n",
 "closure_subset_iff":
 "theorem is_closed.closure_subset_iff {s t : set α} (h₁ : is_closed t) : closure s ⊆ t ↔ s ⊆ t :=\n  ⟨Subset.trans subset_closure, fun h => closure_minimal h h₁⟩\n#align is_closed.closure_subset_iff is_closed.closure_subset_iff\n\n",
 "closure_subset":
 "theorem is_closed.closure_subset {s : set α} (hs : is_closed s) : closure s ⊆ s :=\n  closure_minimal (Subset.refl _) hs\n#align is_closed.closure_subset is_closed.closure_subset\n\n",
 "closure_right":
 "theorem disjoint.closure_right {s t : set α} (hd : Disjoint s t) (hs : is_open s) : Disjoint s (closure t) :=\n  (hd.symm.closure_left hs).symm\n#align disjoint.closure_right disjoint.closure_right\n\n",
 "closure_range":
 "theorem dense_range.closure_range (h : dense_range f) : closure (range f) = univ :=\n  h.closure_eq\n#align dense_range.closure_range dense_range.closure_range\n\n",
 "closure_preimage_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem continuous.closure_preimage_subset {f : α → β} (hf : continuous f) (t : set β) :\n    closure («expr ⁻¹' » f t) ⊆ «expr ⁻¹' » f (closure t) :=\n  by\n  rw [← (is_closed_closure.preimage hf).closure_eq]\n  exact closure_mono (preimage_mono subset_closure)\n#align continuous.closure_preimage_subset continuous.closure_preimage_subset\n\n",
 "closure_nonempty_iff":
 "@[simp]\ntheorem closure_nonempty_iff {s : set α} : (closure s).nonempty ↔ s.nonempty := by\n  simp only [nonempty_iff_ne_empty, ne.def, closure_empty_iff]\n#align closure_nonempty_iff closure_nonempty_iff\n\n",
 "closure_mono":
 "@[mono]\ntheorem closure_mono {s t : set α} (h : s ⊆ t) : closure s ⊆ closure t :=\n  closure_minimal (Subset.trans h subset_closure) is_closed_closure\n#align closure_mono closure_mono\n\n",
 "closure_minimal":
 "theorem closure_minimal {s t : set α} (h₁ : s ⊆ t) (h₂ : is_closed t) : closure s ⊆ t :=\n  interₛ_subset_of_mem ⟨h₂, h₁⟩\n#align closure_minimal closure_minimal\n\n",
 "closure_left":
 "/-- If a continuous map `f` maps `s` to a closed set `t`, then it maps `closure s` to `t`. -/\ntheorem set.maps_to.closure_left {s : set α} {t : set β} {f : α → β} (h : MapsTo f s t) (hc : continuous f)\n    (ht : is_closed t) : MapsTo f (closure s) t :=\n  ht.closure_eq ▸ h.closure hc\n#align set.maps_to.closure_left set.maps_to.closure_left\n\n",
 "closure_inter_subset_inter_closure":
 "theorem closure_inter_subset_inter_closure (s t : set α) : closure (s ∩ t) ⊆ closure s ∩ closure t :=\n  (monotone_closure α).map_inf_le s t\n#align closure_inter_subset_inter_closure closure_inter_subset_inter_closure\n\n",
 "closure_inter_open_nonempty_iff":
 "theorem closure_inter_open_nonempty_iff {s t : set α} (h : is_open t) : (closure s ∩ t).nonempty ↔ (s ∩ t).nonempty :=\n  ⟨fun ⟨x, hxcs, hxt⟩ => inter_comm t s ▸ mem_closure_iff.1 hxcs t h hxt, fun h =>\n    h.mono <| inf_le_inf_right t subset_closure⟩\n#align closure_inter_open_nonempty_iff closure_inter_open_nonempty_iff\n\n",
 "closure_inter":
 "theorem is_open.closure_inter {s t : set α} (h : is_open t) : closure s ∩ t ⊆ closure (s ∩ t) := by\n  simpa only [inter_comm] using h.inter_closure\n#align is_open.closure_inter is_open.closure_inter\n\n",
 "closure_eq_self_union_frontier":
 "theorem closure_eq_self_union_frontier (s : set α) : closure s = s ∪ frontier s :=\n  (union_diff_cancel' interior_subset subset_closure).symm\n#align closure_eq_self_union_frontier closure_eq_self_union_frontier\n\n",
 "closure_eq_interior_union_frontier":
 "theorem closure_eq_interior_union_frontier (s : set α) : closure s = interior s ∪ frontier s :=\n  (union_diff_cancel interior_subset_closure).symm\n#align closure_eq_interior_union_frontier closure_eq_interior_union_frontier\n\n",
 "closure_eq_iff_is_closed":
 "theorem closure_eq_iff_is_closed {s : set α} : closure s = s ↔ is_closed s :=\n  ⟨fun h => h ▸ is_closed_closure, is_closed.closure_eq⟩\n#align closure_eq_iff_is_closed closure_eq_iff_is_closed\n\n",
 "closure_eq_compl_interior_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem closure_eq_compl_interior_compl {s : set α} : closure s = «expr ᶜ» (interior («expr ᶜ» s)) :=\n  by\n  rw [interior, closure, compl_sUnion, compl_image_set_of]\n  simp only [compl_subset_compl, is_open_compl_iff]\n#align closure_eq_compl_interior_compl closure_eq_compl_interior_compl\n\n",
 "closure_eq_cluster_pts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\ntheorem closure_eq_cluster_pts {s : set α} : closure s = { a | cluster_pt a ((filter.principal) s) } :=\n  Set.ext fun x => mem_closure_iff_cluster_pt\n#align closure_eq_cluster_pts closure_eq_cluster_pts\n\n",
 "closure_eq":
 "theorem dense.closure_eq {s : set α} (h : dense s) : closure s = univ :=\n  dense_iff_closure_eq.mp h\n#align dense.closure_eq dense.closure_eq\n\n",
 "closure_empty_iff":
 "@[simp]\ntheorem closure_empty_iff (s : set α) : closure s = ∅ ↔ s = ∅ :=\n  ⟨subset_eq_empty subset_closure, fun h => h.symm ▸ closure_empty⟩\n#align closure_empty_iff closure_empty_iff\n\n",
 "closure_empty":
 "@[simp]\ntheorem closure_empty : closure (∅ : set α) = ∅ :=\n  is_closed_empty.closure_eq\n#align closure_empty closure_empty\n\n",
 "closure_diff_interior":
 "@[simp]\ntheorem closure_diff_interior (s : set α) : closure s \\ interior s = frontier s :=\n  rfl\n#align closure_diff_interior closure_diff_interior\n\n",
 "closure_diff_frontier":
 "@[simp]\ntheorem closure_diff_frontier (s : set α) : closure s \\ frontier s = interior s := by\n  rw [frontier, diff_diff_right_self, inter_eq_self_of_subset_right interior_subset_closure]\n#align closure_diff_frontier closure_diff_frontier\n\n",
 "closure_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem closure_diff {s t : set α} : closure s \\ closure t ⊆ closure (s \\ t) :=\n  calc\n    closure s \\ closure t = «expr ᶜ» (closure t) ∩ closure s := by simp only [diff_eq, inter_comm]\n    _ ⊆ closure («expr ᶜ» (closure t) ∩ s) := (is_open_compl_iff.mpr <| is_closed_closure).inter_closure\n    _ = closure (s \\ closure t) := by simp only [diff_eq, inter_comm]\n    _ ⊆ closure (s \\ t) := closure_mono <| diff_subset_diff (Subset.refl s) subset_closure\n    \n#align closure_diff closure_diff\n\n",
 "closure_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- If `x` is not an isolated point of a topological space, then the closure of `{x}ᶜ` is the whole\nspace. -/\n@[simp]\ntheorem closure_compl_singleton (x : α) [ne_bot (nhds_within.ne x)] : closure («expr ᶜ» {x}) = (univ : set α) :=\n  (dense_compl_singleton x).closure_eq\n#align closure_compl_singleton closure_compl_singleton\n\n",
 "closure_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem closure_compl {s : set α} : closure («expr ᶜ» s) = «expr ᶜ» (interior s) := by\n  simp [closure_eq_compl_interior_compl]\n#align closure_compl closure_compl\n\n",
 "closure_closure":
 "@[simp]\ntheorem closure_closure {s : set α} : closure (closure s) = closure s :=\n  is_closed_closure.closure_eq\n#align closure_closure closure_closure\n\n",
 "closure_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem finset.closure_bUnion {ι : Type _} (s : Finset ι) (f : ι → set α) :\n    closure («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (closure (f i)) :=\n  by\n  classical\n    refine' s.induction_on (by simp) _\n    intro i s h₁ h₂\n    simp [h₂]\n#align finset.closure_bUnion finset.closure_bUnion\n\n",
 "closure_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem closure_Union {ι : Type _} [Finite ι] (f : ι → set α) :\n    closure («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (closure (f i)) :=\n  by\n  cases nonempty_fintype ι\n  convert finset.univ.closure_bUnion f <;> simp\n#align closure_Union closure_Union\n\n",
 "closure":
 "/-- If a continuous map `f` maps `s` to `t`, then it maps `closure s` to `closure t`. -/\ntheorem set.maps_to.closure {s : set α} {t : set β} {f : α → β} (h : MapsTo f s t) (hc : continuous f) :\n    MapsTo f (closure s) (closure t) :=\n  by\n  simp only [maps_to, mem_closure_iff_cluster_pt]\n  exact fun x hx => hx.map hc.continuous_at (tendsto_principal_principal.2 h)\n#align set.maps_to.closure set.maps_to.closure\n\n",
 "and":
 "theorem is_open.and : is_open { a | p₁ a } → is_open { a | p₂ a } → is_open { a | p₁ a ∧ p₂ a } :=\n  is_open.inter\n#align is_open.and is_open.and\n\n",
 "all_mem_nhds_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem all_mem_nhds_filter (x : α) (f : set α → set β) (hf : ∀ s t, s ⊆ t → f s ⊆ f t) (l : filter β) :\n    (∀ s ∈ (nhds) x, f s ∈ l) ↔ ∀ s, is_open s → x ∈ s → f s ∈ l :=\n  all_mem_nhds _ _ fun s t ssubt h => mem_of_superset h (hf s t ssubt)\n#align all_mem_nhds_filter all_mem_nhds_filter\n\n",
 "all_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem all_mem_nhds (x : α) (P : set α → Prop) (hP : ∀ s t, s ⊆ t → P s → P t) :\n    (∀ s ∈ (nhds) x, P s) ↔ ∀ s, is_open s → x ∈ s → P s :=\n  ((nhds_basis_opens x).forall_iff hP).trans <| by simp only [and_comm' (x ∈ _), and_imp]\n#align all_mem_nhds all_mem_nhds\n\n",
 "acc_pt_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- `x` is an accumulation point of a set `C` iff every neighborhood\nof `x` contains a point of `C` other than `x`. -/\ntheorem acc_pt_iff_nhds (x : α) (C : set α) : acc_pt x ((filter.principal) C) ↔ ∀ U ∈ (nhds) x, ∃ y ∈ U ∩ C, y ≠ x := by\n  simp [acc_principal_iff_cluster, cluster_pt_principal_iff, Set.Nonempty, exists_prop, and_assoc', and_comm' ¬_ = x]\n#align acc_pt_iff_nhds acc_pt_iff_nhds\n\n",
 "acc_pt_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- `x` is an accumulation point of a set `C` iff\nthere are points near `x` in `C` and different from `x`.-/\ntheorem acc_pt_iff_frequently (x : α) (C : set α) :\n    acc_pt x ((filter.principal) C) ↔\n      «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" ((nhds) x)\n        (y ≠ x ∧ y ∈ C) :=\n  by simp [acc_principal_iff_cluster, cluster_pt_principal_iff_frequently, and_comm']\n#align acc_pt_iff_frequently acc_pt_iff_frequently\n\n",
 "acc_principal_iff_cluster":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/-- `x` is an accumulation point of a set `C` iff it is a cluster point of `C ∖ {x}`.-/\ntheorem acc_principal_iff_cluster (x : α) (C : set α) :\n    acc_pt x ((filter.principal) C) ↔ cluster_pt x ((filter.principal) (C \\ {x})) := by\n  rw [acc_iff_cluster, inf_principal, inter_comm] <;> rfl\n#align acc_principal_iff_cluster acc_principal_iff_cluster\n\n",
 "acc_iff_cluster":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem acc_iff_cluster (x : α) (F : filter α) :\n    acc_pt x F ↔ cluster_pt x («expr ⊓ » ((filter.principal) («expr ᶜ» {x})) F) := by\n  rw [acc_pt, nhds_within, cluster_pt, inf_assoc]\n#align acc_iff_cluster acc_iff_cluster\n\n"}