{"union":
 "#print IsClosed.union /-\ntheorem IsClosed.union : IsClosed sâ‚ â†’ IsClosed sâ‚‚ â†’ IsClosed (sâ‚ âˆª sâ‚‚) := fun hâ‚ hâ‚‚ =>\n  by\n  rw [â† isOpen_compl_iff] at *\n  rw [compl_union]\n  exact IsOpen.inter hâ‚ hâ‚‚\n#align is_closed.union IsClosed.union\n-/\n\n",
 "topologicalSpace_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n#print topologicalSpace_eq_iff /-\ntheorem topologicalSpace_eq_iff {t t' : TopologicalSpace Î±} : t = t' â†” âˆ€ s, (is_open_of t) s â†” (is_open_of t') s :=\n  âŸ¨fun h s => h â–¸ iff.rfl, fun h => by\n    ext\n    exact h _âŸ©\n#align topological_space_eq_iff topologicalSpace_eq_iff\n-/\n\n",
 "topologicalSpace_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n#print topologicalSpace_eq /-\n@[ext]\ntheorem topologicalSpace_eq {f g : TopologicalSpace Î±} (h : is_open_of f = is_open_of g) : f = g :=\n  by\n  cases f\n  cases g\n  congr\n  exact h\n#align topological_space_eq topologicalSpace_eq\n-/\n\n",
 "tendsto_pure_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_pure_nhds /-\ntheorem tendsto_pure_nhds {Î± : Type _} [TopologicalSpace Î²] (f : Î± â†’ Î²) (a : Î±) : Tendsto f (pure a) ((nhds) (f a)) :=\n  (tendsto_pure_pure f a).mono_right (pure_le_nhds _)\n#align tendsto_pure_nhds tendsto_pure_nhds\n-/\n\n",
 "tendsto_nhds_limUnder":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_nhds_limUnder /-\n/-- If `g` tends to some `ğ“ a` along `f`, then it tends to `ğ“ (lim f g)`. We formulate\nthis lemma with a `[nonempty Î±]` argument of `lim` derived from `h` to make it useful for types\nwithout a `[nonempty Î±]` instance. Because of the built-in proof irrelevance, Lean will unify\nthis instance with any other instance. -/\ntheorem tendsto_nhds_limUnder {f : Filter Î²} {g : Î² â†’ Î±} (h : âˆƒ a, Tendsto g f ((nhds) a)) :\n    Tendsto g f (nhds <| @limUnder _ _ _ (nonempty_of_exists h) f g) :=\n  le_nhds_lim h\n#align tendsto_nhds_lim tendsto_nhds_limUnder\n-/\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n#print tendsto_nhds /-\ntheorem tendsto_nhds {f : Î² â†’ Î±} {l : Filter Î²} {a : Î±} :\n    Tendsto f l ((nhds) a) â†” âˆ€ s, IsOpen s â†’ a âˆˆ s â†’ Â«expr â»Â¹' Â» f s âˆˆ l :=\n  all_mem_nhds_filter _ _ (fun s t h => preimage_mono h) _\n#align tendsto_nhds tendsto_nhds\n-/\n\n",
 "tendsto_inf_principal_nhds_iff_of_forall_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x Â«expr âˆ‰ Â» s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_inf_principal_nhds_iff_of_forall_eq /-\n/-- Suppose that `f` sends the complement to `s` to a single point `a`, and `l` is some filter.\nThen `f` tends to `a` along `l` restricted to `s` if and only if it tends to `a` along `l`. -/\ntheorem tendsto_inf_principal_nhds_iff_of_forall_eq {f : Î² â†’ Î±} {l : Filter Î²} {s : Set Î²} {a : Î±}\n    (h : âˆ€ (x) (_ : x âˆ‰ s), f x = a) :\n    Tendsto f (Â«expr âŠ“ Â» l ((filter.principal) s)) ((nhds) a) â†” Tendsto f l ((nhds) a) :=\n  by\n  rw [tendsto_iff_comap, tendsto_iff_comap]\n  replace h : (filter.principal) (Â«expr á¶œÂ» s) â‰¤ comap f ((nhds) a)\n  Â· rintro U âŸ¨t, ht, htUâŸ© x hx\n    have : f x âˆˆ t := (h x hx).symm â–¸ mem_of_mem_nhds ht\n    exact htU this\n  refine' âŸ¨fun h' => _, le_trans inf_le_leftâŸ©\n  have := sup_le h' h\n  rw [sup_inf_right, sup_principal, union_compl_self, principal_univ, inf_top_eq, sup_le_iff] at this\n  exact this.1\n#align tendsto_inf_principal_nhds_iff_of_forall_eq tendsto_inf_principal_nhds_iff_of_forall_eq\n-/\n\n",
 "tendsto_const_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_const_nhds /-\ntheorem tendsto_const_nhds {a : Î±} {f : Filter Î²} : Tendsto (fun b : Î² => a) f ((nhds) a) :=\n  tendsto_nhds.mpr fun s hs ha => univ_mem' fun _ => ha\n#align tendsto_const_nhds tendsto_const_nhds\n-/\n\n",
 "tendsto_atTop_of_eventually_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_atTop_of_eventually_const /-\ntheorem tendsto_atTop_of_eventually_const {Î¹ : Type _} [SemilatticeSup Î¹] [Nonempty Î¹] {x : Î±} {u : Î¹ â†’ Î±} {iâ‚€ : Î¹}\n    (h : âˆ€ i â‰¥ iâ‚€, u i = x) : Tendsto u atTop ((nhds) x) :=\n  Tendsto.congr' (EventuallyEq.symm (eventually_atTop.mpr âŸ¨iâ‚€, hâŸ©)) tendsto_const_nhds\n#align tendsto_at_top_of_eventually_const tendsto_atTop_of_eventually_const\n-/\n\n",
 "tendsto_atTop_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n#print OrderTop.tendsto_atTop_nhds /-\ntheorem OrderTop.tendsto_atTop_nhds {Î± : Type _} [partial_order Î±] [OrderTop Î±] [TopologicalSpace Î²] (f : Î± â†’ Î²) :\n    Tendsto f atTop (nhds <| f (Â«exprâŠ¤Â»)) :=\n  (tendsto_atTop_pure f).mono_right (pure_le_nhds _)\n#align order_top.tendsto_at_top_nhds OrderTop.tendsto_atTop_nhds\n-/\n\n",
 "tendsto_atBot_of_eventually_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print tendsto_atBot_of_eventually_const /-\ntheorem tendsto_atBot_of_eventually_const {Î¹ : Type _} [SemilatticeInf Î¹] [Nonempty Î¹] {x : Î±} {u : Î¹ â†’ Î±} {iâ‚€ : Î¹}\n    (h : âˆ€ i â‰¤ iâ‚€, u i = x) : Tendsto u atBot ((nhds) x) :=\n  Tendsto.congr' (EventuallyEq.symm (eventually_atBot.mpr âŸ¨iâ‚€, hâŸ©)) tendsto_const_nhds\n#align tendsto_at_bot_of_eventually_const tendsto_atBot_of_eventually_const\n-/\n\n",
 "tendsto'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Continuous.tendsto' /-\n/-- A version of `continuous.tendsto` that allows one to specify a simpler form of the limit.\nE.g., one can write `continuous_exp.tendsto' 0 1 exp_zero`. -/\ntheorem Continuous.tendsto' {f : Î± â†’ Î²} (hf : Continuous f) (x : Î±) (y : Î²) (h : f x = y) :\n    Tendsto f ((nhds) x) ((nhds) y) :=\n  h â–¸ hf.tendsto x\n#align continuous.tendsto' Continuous.tendsto'\n-/\n\n",
 "tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Continuous.tendsto /-\ntheorem Continuous.tendsto {f : Î± â†’ Î²} (hf : Continuous f) (x) : Tendsto f ((nhds) x) ((nhds) (f x)) :=\n  ((nhds_basis_opens x).tendsto_iff <| nhds_basis_opens <| f x).2 fun t âŸ¨hxt, htâŸ© =>\n    âŸ¨Â«expr â»Â¹' Â» f t, âŸ¨hxt, ht.preimage hfâŸ©, Subset.refl _âŸ©\n#align continuous.tendsto Continuous.tendsto\n-/\n\n",
 "subset_interior_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print subset_interior_iff_nhds /-\ntheorem subset_interior_iff_nhds {s V : Set Î±} : s âŠ† interior V â†” âˆ€ x âˆˆ s, V âˆˆ (nhds) x :=\n  show (âˆ€ x, x âˆˆ s â†’ x âˆˆ _) â†” _ by simp_rw [mem_interior_iff_mem_nhds]\n#align subset_interior_iff_nhds subset_interior_iff_nhds\n-/\n\n",
 "subset_interior_iff_isOpen":
 "#print subset_interior_iff_isOpen /-\ntheorem subset_interior_iff_isOpen {s : Set Î±} : s âŠ† interior s â†” IsOpen s := by\n  simp only [interior_eq_iff_is_open.symm, subset.antisymm_iff, interior_subset, true_and_iff]\n#align subset_interior_iff_is_open subset_interior_iff_isOpen\n-/\n\n",
 "subset_interior_iff":
 "#print subset_interior_iff /-\ntheorem subset_interior_iff {s t : Set Î±} : t âŠ† interior s â†” âˆƒ U, IsOpen U âˆ§ t âŠ† U âˆ§ U âŠ† s :=\n  âŸ¨fun h => âŸ¨interior s, isOpen_interior, h, interior_subsetâŸ©, fun âŸ¨U, hU, htU, hUsâŸ© =>\n    htU.trans (interior_maximal hUs hU)âŸ©\n#align subset_interior_iff subset_interior_iff\n-/\n\n",
 "subset_closure_image_preimage_of_isOpen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n#print DenseRange.subset_closure_image_preimage_of_isOpen /-\n/-- If `f` has dense range and `s` is an open set in the codomain of `f`, then the image of the\npreimage of `s` under `f` is dense in `s`. -/\ntheorem DenseRange.subset_closure_image_preimage_of_isOpen (hf : DenseRange f) {s : Set Î²} (hs : IsOpen s) :\n    s âŠ† closure (Â«expr '' Â» f (Â«expr â»Â¹' Â» f s)) :=\n  by\n  rw [image_preimage_eq_inter_range]\n  exact hf.open_subset_closure_inter hs\n#align dense_range.subset_closure_image_preimage_of_is_open DenseRange.subset_closure_image_preimage_of_isOpen\n-/\n\n",
 "subset_closure":
 "#print subset_closure /-\ntheorem subset_closure {s : Set Î±} : s âŠ† closure s :=\n  subset_interâ‚› fun t âŸ¨hâ‚, hâ‚‚âŸ© => hâ‚‚\n#align subset_closure subset_closure\n-/\n\n",
 "self_of_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Eventually.self_of_nhds /-\n/-- If a predicate is true in a neighborhood of `a`, then it is true for `a`. -/\ntheorem Filter.Eventually.self_of_nhds {p : Î± â†’ Prop} {a : Î±}\n    (h :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (p y)) :\n    p a :=\n  mem_of_mem_nhds h\n#align filter.eventually.self_of_nhds Filter.Eventually.self_of_nhds\n-/\n\n",
 "self_diff_frontier":
 "#print self_diff_frontier /-\n@[simp]\ntheorem self_diff_frontier (s : Set Î±) : s \\ frontier s = interior s := by\n  rw [frontier, diff_diff_right, diff_eq_empty.2 subset_closure, inter_eq_self_of_subset_right interior_subset,\n    empty_union]\n#align self_diff_frontier self_diff_frontier\n-/\n\n",
 "sdiff":
 "#print IsClosed.sdiff /-\ntheorem IsClosed.sdiff {s t : Set Î±} (hâ‚ : IsClosed s) (hâ‚‚ : IsOpen t) : IsClosed (s \\ t) :=\n  IsClosed.inter hâ‚ (isClosed_compl_iff.mpr hâ‚‚)\n#align is_closed.sdiff IsClosed.sdiff\n-/\n\n",
 "range_subset_closure_image_dense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print Continuous.range_subset_closure_image_dense /-\ntheorem Continuous.range_subset_closure_image_dense {f : Î± â†’ Î²} (hf : Continuous f) {s : Set Î±} (hs : Dense s) :\n    range f âŠ† closure (Â«expr '' Â» f s) := by\n  rw [â† image_univ, â† hs.closure_eq]\n  exact image_closure_subset_closure_image hf\n#align continuous.range_subset_closure_image_dense Continuous.range_subset_closure_image_dense\n-/\n\n",
 "pure_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print pure_le_nhds /-\ntheorem pure_le_nhds : pure â‰¤ (nhds : Î± â†’ Filter Î±) := fun a s hs => mem_pure.2 <| mem_of_mem_nhds hs\n#align pure_le_nhds pure_le_nhds\n-/\n\n",
 "preimage_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ContinuousAt.preimage_mem_nhds /-\ntheorem ContinuousAt.preimage_mem_nhds {f : Î± â†’ Î²} {x : Î±} {t : Set Î²} (h : ContinuousAt f x) (ht : t âˆˆ (nhds) (f x)) :\n    Â«expr â»Â¹' Â» f t âˆˆ (nhds) x :=\n  h ht\n#align continuous_at.preimage_mem_nhds ContinuousAt.preimage_mem_nhds\n-/\n\n",
 "preimage_interior_subset_interior_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n#print preimage_interior_subset_interior_preimage /-\n/-- See also `interior_preimage_subset_preimage_interior`. -/\ntheorem preimage_interior_subset_interior_preimage {f : Î± â†’ Î²} {s : Set Î²} (hf : Continuous f) :\n    Â«expr â»Â¹' Â» f (interior s) âŠ† interior (Â«expr â»Â¹' Â» f s) :=\n  interior_maximal (preimage_mono interior_subset) (isOpen_interior.preimage hf)\n#align preimage_interior_subset_interior_preimage preimage_interior_subset_interior_preimage\n-/\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n#print IsClosed.preimage /-\ntheorem IsClosed.preimage {f : Î± â†’ Î²} (hf : Continuous f) {s : Set Î²} (h : IsClosed s) : IsClosed (Â«expr â»Â¹' Â» f s) :=\n  continuous_iff_isClosed.mp hf s h\n#align is_closed.preimage IsClosed.preimage\n-/\n\n",
 "open_subset_closure_inter":
 "#print Dense.open_subset_closure_inter /-\ntheorem Dense.open_subset_closure_inter {s t : Set Î±} (hs : Dense s) (ht : IsOpen t) : t âŠ† closure (t âˆ© s) :=\n  calc\n    t = t âˆ© closure s := by rw [hs.closure_eq, inter_univ]\n    _ âŠ† closure (t âˆ© s) := ht.inter_closure\n    \n#align dense.open_subset_closure_inter Dense.open_subset_closure_inter\n-/\n\n",
 "of_nhds_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ClusterPt.of_nhds_le /-\ntheorem ClusterPt.of_nhds_le {x : Î±} {f : Filter Î±} (H : (nhds) x â‰¤ f) : ClusterPt x f := by\n  simp only [ClusterPt, inf_eq_left.mpr H, nhds_neBot]\n#align cluster_pt.of_nhds_le ClusterPt.of_nhds_le\n-/\n\n",
 "of_le_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ClusterPt.of_le_nhds' /-\ntheorem ClusterPt.of_le_nhds' {x : Î±} {f : Filter Î±} (H : f â‰¤ (nhds) x) (hf : NeBot f) : ClusterPt x f :=\n  ClusterPt.of_le_nhds H\n#align cluster_pt.of_le_nhds' ClusterPt.of_le_nhds'\n-/\n\n",
 "of_le_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ClusterPt.of_le_nhds /-\ntheorem ClusterPt.of_le_nhds {x : Î±} {f : Filter Î±} (H : f â‰¤ (nhds) x) [NeBot f] : ClusterPt x f := by\n  rwa [ClusterPt, inf_eq_right.mpr H]\n#align cluster_pt.of_le_nhds ClusterPt.of_le_nhds\n-/\n\n",
 "of_inf_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n#print ClusterPt.of_inf_right /-\ntheorem ClusterPt.of_inf_right {x : Î±} {f g : Filter Î±} (H : ClusterPt x <| Â«expr âŠ“ Â» f g) : ClusterPt x g :=\n  H.mono inf_le_right\n#align cluster_pt.of_inf_right ClusterPt.of_inf_right\n-/\n\n",
 "of_inf_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n#print ClusterPt.of_inf_left /-\ntheorem ClusterPt.of_inf_left {x : Î±} {f g : Filter Î±} (H : ClusterPt x <| Â«expr âŠ“ Â» f g) : ClusterPt x f :=\n  H.mono inf_le_left\n#align cluster_pt.of_inf_left ClusterPt.of_inf_left\n-/\n\n",
 "not_mem_of_not_mem_closure":
 "#print not_mem_of_not_mem_closure /-\ntheorem not_mem_of_not_mem_closure {s : Set Î±} {P : Î±} (hP : P âˆ‰ closure s) : P âˆ‰ s := fun h => hP (subset_closure h)\n#align not_mem_of_not_mem_closure not_mem_of_not_mem_closure\n-/\n\n",
 "not_isOpen_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n#print not_isOpen_singleton /-\ntheorem not_isOpen_singleton (x : Î±) [NeBot (nhds_within.ne x)] : Â¬IsOpen ({x} : Set Î±) :=\n  dense_compl_singleton_iff_not_open.1 (dense_compl_singleton x)\n#align not_is_open_singleton not_isOpen_singleton\n-/\n\n",
 "not":
 "#print IsClosed.not /-\ntheorem IsClosed.not : IsClosed { a | p a } â†’ IsOpen { a | Â¬p a } :=\n  isOpen_compl_iff.mpr\n#align is_closed.not IsClosed.not\n-/\n\n",
 "nonempty_iff":
 "#print DenseRange.nonempty_iff /-\ntheorem DenseRange.nonempty_iff (hf : DenseRange f) : Nonempty Îº â†” Nonempty Î² :=\n  range_nonempty_iff_nonempty.symm.trans hf.nonempty_iff\n#align dense_range.nonempty_iff DenseRange.nonempty_iff\n-/\n\n",
 "nonempty":
 "#print DenseRange.nonempty /-\ntheorem DenseRange.nonempty [h : Nonempty Î²] (hf : DenseRange f) : Nonempty Îº :=\n  hf.nonempty_iff.mpr h\n#align dense_range.nonempty DenseRange.nonempty\n-/\n\n",
 "nhds_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_le_of_le /-\n/-- To show a filter is above the neighborhood filter at `a`, it suffices to show that it is above\nthe principal filter of some open set `s` containing `a`. -/\ntheorem nhds_le_of_le {f a} {s : Set Î±} (h : a âˆˆ s) (o : IsOpen s) (sf : (filter.principal) s â‰¤ f) : (nhds) a â‰¤ f := by\n  rw [nhds_def] <;> exact infáµ¢_le_of_le s (infáµ¢_le_of_le âŸ¨h, oâŸ© sf)\n#align nhds_le_of_le nhds_le_of_le\n-/\n\n",
 "nhds_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print nhds_def' /-\ntheorem nhds_def' (a : Î±) :\n    (nhds) a =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) s) :=\n  by simp only [nhds_def, mem_set_of_eq, and_comm' (a âˆˆ _), infáµ¢_and]\n#align nhds_def' nhds_def'\n-/\n\n",
 "nhds_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print nhds_def /-\ntheorem nhds_def (a : Î±) :\n    (nhds) a =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) s) :=\n  by rw [nhds]\n#align nhds_def nhds_def\n-/\n\n",
 "nhds_bind_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_bind_nhds /-\n@[simp]\ntheorem nhds_bind_nhds : ((nhds) a).bind (nhds) = (nhds) a :=\n  Filter.ext fun s => eventually_eventually_nhds\n#align nhds_bind_nhds nhds_bind_nhds\n-/\n\n",
 "nhds_basis_opens'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_basis_opens' /-\n/-- The open neighborhoods of `a` are a basis for the neighborhood filter. See `nhds_basis_opens`\nfor a variant using open sets around `a` instead. -/\ntheorem nhds_basis_opens' (a : Î±) : ((nhds) a).has_basis (fun s : Set Î± => s âˆˆ (nhds) a âˆ§ IsOpen s) fun x => x :=\n  by\n  convert nhds_basis_opens a\n  ext s\n  exact and_congr_left_iff.2 IsOpen.mem_nhds_iff\n#align nhds_basis_opens' nhds_basis_opens'\n-/\n\n",
 "nhds_basis_opens":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_basis_opens /-\n/-- The open sets containing `a` are a basis for the neighborhood filter. See `nhds_basis_opens'`\nfor a variant using open neighborhoods instead. -/\ntheorem nhds_basis_opens (a : Î±) : ((nhds) a).has_basis (fun s : Set Î± => a âˆˆ s âˆ§ IsOpen s) fun s => s :=\n  by\n  rw [nhds_def]\n  exact\n    has_basis_binfi_principal\n      (fun s âŸ¨has, hsâŸ© t âŸ¨hat, htâŸ© =>\n        âŸ¨s âˆ© t, âŸ¨âŸ¨has, hatâŸ©, IsOpen.inter hs htâŸ©, âŸ¨inter_subset_left _ _, inter_subset_right _ _âŸ©âŸ©)\n      âŸ¨univ, âŸ¨mem_univ a, isOpen_univâŸ©âŸ©\n#align nhds_basis_opens nhds_basis_opens\n-/\n\n",
 "nhds_basis_closeds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print nhds_basis_closeds /-\ntheorem nhds_basis_closeds (a : Î±) : ((nhds) a).has_basis (fun s : Set Î± => a âˆ‰ s âˆ§ IsClosed s) compl :=\n  âŸ¨fun t =>\n    (nhds_basis_opens a).mem_iff.trans <|\n      compl_surjective.exists.trans <| by simp only [isOpen_compl_iff, mem_compl_iff]âŸ©\n#align nhds_basis_closeds nhds_basis_closeds\n-/\n\n",
 "neBot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ClusterPt.neBot /-\ntheorem ClusterPt.neBot {x : Î±} {F : Filter Î±} (h : ClusterPt x F) : NeBot (Â«expr âŠ“ Â» ((nhds) x) F) :=\n  h\n#align cluster_pt.ne_bot ClusterPt.neBot\n-/\n\n",
 "monotone_closure":
 "#print monotone_closure /-\ntheorem monotone_closure (Î± : Type _) [TopologicalSpace Î±] : Monotone (@closure Î± _) := fun _ _ => closure_mono\n#align monotone_closure monotone_closure\n-/\n\n",
 "mono":
 "#print AccPt.mono /-\n/-- If `x` is an accumulation point of `F` and `F â‰¤ G`, then\n`x` is an accumulation point of `D. -/\ntheorem AccPt.mono {x : Î±} {F G : Filter Î±} (h : AccPt x F) (hFG : F â‰¤ G) : AccPt x G :=\n  âŸ¨ne_bot_of_le_ne_bot h.ne (inf_le_inf_left _ hFG)âŸ©\n#align acc_pt.mono AccPt.mono\n-/\n\n",
 "mem_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n#print IsClosed.mem_of_tendsto /-\ntheorem IsClosed.mem_of_tendsto {f : Î² â†’ Î±} {b : Filter Î²} {a : Î±} {s : Set Î±} [NeBot b] (hs : IsClosed s)\n    (hf : Tendsto f b ((nhds) a))\n    (h :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" b\n        (f x âˆˆ s)) :\n    a âˆˆ s :=\n  hs.mem_of_frequently_of_tendsto h.frequently hf\n#align is_closed.mem_of_tendsto IsClosed.mem_of_tendsto\n-/\n\n",
 "mem_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_of_mem_nhds /-\ntheorem mem_of_mem_nhds {a : Î±} {s : Set Î±} : s âˆˆ (nhds) a â†’ a âˆˆ s := fun H =>\n  let âŸ¨t, ht, _, hsâŸ© := mem_nhds_iff.1 H\n  ht hs\n#align mem_of_mem_nhds mem_of_mem_nhds\n-/\n\n",
 "mem_of_frequently_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsClosed.mem_of_frequently_of_tendsto /-\ntheorem IsClosed.mem_of_frequently_of_tendsto {f : Î² â†’ Î±} {b : Filter Î²} {a : Î±} {s : Set Î±} (hs : IsClosed s)\n    (h :\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" b\n        (f x âˆˆ s))\n    (hf : Tendsto f b ((nhds) a)) : a âˆˆ s :=\n  (hf.frequently <|\n        show\n          Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" b\n            ((fun y => y âˆˆ s) (f x))\n          from h).mem_of_closed\n    hs\n#align is_closed.mem_of_frequently_of_tendsto IsClosed.mem_of_frequently_of_tendsto\n-/\n\n",
 "mem_of_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Frequently.mem_of_closed /-\ntheorem Filter.Frequently.mem_of_closed {a : Î±} {s : Set Î±}\n    (h :\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" ((nhds) a)\n        (x âˆˆ s))\n    (hs : IsClosed s) : a âˆˆ s :=\n  hs.closure_subset h.mem_closure\n#align filter.frequently.mem_of_closed Filter.Frequently.mem_of_closed\n-/\n\n",
 "mem_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsOpen.mem_nhds_iff /-\ntheorem IsOpen.mem_nhds_iff {a : Î±} {s : Set Î±} (hs : IsOpen s) : s âˆˆ (nhds) a â†” a âˆˆ s :=\n  âŸ¨mem_of_mem_nhds, fun ha => mem_nhds_iff.2 âŸ¨s, Subset.refl _, hs, haâŸ©âŸ©\n#align is_open.mem_nhds_iff IsOpen.mem_nhds_iff\n-/\n\n",
 "mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print DenseRange.mem_nhds /-\ntheorem DenseRange.mem_nhds {f : Îº â†’ Î²} (h : DenseRange f) {b : Î²} {U : Set Î²} (U_in : U âˆˆ (nhds) b) : âˆƒ a, f a âˆˆ U :=\n  let âŸ¨a, haâŸ© := h.exists_mem_open isOpen_interior âŸ¨b, mem_interior_iff_mem_nhds.2 U_inâŸ©\n  âŸ¨a, interior_subset haâŸ©\n#align dense_range.mem_nhds DenseRange.mem_nhds\n-/\n\n",
 "mem_interior_iff_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_interior_iff_mem_nhds /-\ntheorem mem_interior_iff_mem_nhds {s : Set Î±} {a : Î±} : a âˆˆ interior s â†” s âˆˆ (nhds) a := by\n  rw [interior_eq_nhds', mem_set_of_eq]\n#align mem_interior_iff_mem_nhds mem_interior_iff_mem_nhds\n-/\n\n",
 "mem_interior":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\ntheorem mem_interior {s : Set Î±} {x : Î±} : x âˆˆ interior s â†” âˆƒ (t : _)(_ : t âŠ† s), IsOpen t âˆ§ x âˆˆ t := by\n  simp only [interior, mem_sUnion, mem_set_of_eq, exists_prop, and_assoc', and_left_comm]\n#align mem_interior mem_interiorâ‚“\n\n",
 "mem_iff_closure_subset":
 "#print IsClosed.mem_iff_closure_subset /-\ntheorem IsClosed.mem_iff_closure_subset {s : Set Î±} (hs : IsClosed s) {x : Î±} : x âˆˆ s â†” closure ({x} : Set Î±) âŠ† s :=\n  (hs.closure_subset_iff.trans Set.singleton_subset_iff).symm\n#align is_closed.mem_iff_closure_subset IsClosed.mem_iff_closure_subset\n-/\n\n",
 "mem_closure_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n#print mem_closure_of_tendsto /-\ntheorem mem_closure_of_tendsto {f : Î² â†’ Î±} {b : Filter Î²} {a : Î±} {s : Set Î±} [NeBot b] (hf : Tendsto f b ((nhds) a))\n    (h :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" b\n        (f x âˆˆ s)) :\n    a âˆˆ closure s :=\n  mem_closure_of_frequently_of_tendsto h.frequently hf\n#align mem_closure_of_tendsto mem_closure_of_tendsto\n-/\n\n",
 "mem_closure_of_mem_closure_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ” Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_of_mem_closure_union /-\ntheorem mem_closure_of_mem_closure_union {sâ‚ sâ‚‚ : Set Î±} {x : Î±} (h : x âˆˆ closure (sâ‚ âˆª sâ‚‚))\n    (hâ‚ : Â«expr á¶œÂ» sâ‚ âˆˆ (nhds) x) : x âˆˆ closure sâ‚‚ :=\n  by\n  rw [mem_closure_iff_nhds_neBot] at *\n  rwa [â†\n    calc\n      Â«expr âŠ“ Â» ((nhds) x) (principal (sâ‚ âˆª sâ‚‚)) = Â«expr âŠ“ Â» ((nhds) x) (Â«expr âŠ” Â» (principal sâ‚) (principal sâ‚‚)) := by\n        rw [sup_principal]\n      _ = Â«expr âŠ” Â» (Â«expr âŠ“ Â» ((nhds) x) (principal sâ‚)) (Â«expr âŠ“ Â» ((nhds) x) (principal sâ‚‚)) := inf_sup_left\n      _ = Â«expr âŠ” Â» (Â«exprâŠ¥Â») (Â«expr âŠ“ Â» ((nhds) x) (principal sâ‚‚)) := by rw [inf_principal_eq_bot.mpr hâ‚]\n      _ = Â«expr âŠ“ Â» ((nhds) x) (principal sâ‚‚) := bot_sup_eq\n      ]\n#align mem_closure_of_mem_closure_union mem_closure_of_mem_closure_union\n-/\n\n",
 "mem_closure_of_frequently_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_of_frequently_of_tendsto /-\ntheorem mem_closure_of_frequently_of_tendsto {f : Î² â†’ Î±} {b : Filter Î²} {a : Î±} {s : Set Î±}\n    (h :\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" b\n        (f x âˆˆ s))\n    (hf : Tendsto f b ((nhds) a)) : a âˆˆ closure s :=\n  Filter.Frequently.mem_closure <| hf.frequently h\n#align mem_closure_of_frequently_of_tendsto mem_closure_of_frequently_of_tendsto\n-/\n\n",
 "mem_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print mem_closure_image /-\ntheorem mem_closure_image {f : Î± â†’ Î²} {x : Î±} {s : Set Î±} (hf : ContinuousAt f x) (hx : x âˆˆ closure s) :\n    f x âˆˆ closure (Â«expr '' Â» f s) :=\n  mem_closure_of_frequently_of_tendsto ((mem_closure_iff_frequently.1 hx).mono fun x => mem_image_of_mem _) hf\n#align mem_closure_image mem_closure_image\n-/\n\n",
 "mem_closure_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_ultrafilter /-\n/-- `x` belongs to the closure of `s` if and only if some ultrafilter\n  supported on `s` converges to `x`. -/\ntheorem mem_closure_iff_ultrafilter {s : Set Î±} {x : Î±} : x âˆˆ closure s â†” âˆƒ u : Ultrafilter Î±, s âˆˆ u âˆ§ â†‘u â‰¤ (nhds) x :=\n  by simp [closure_eq_cluster_pts, ClusterPt, â† exists_ultrafilter_iff, and_comm]\n#align mem_closure_iff_ultrafilter mem_closure_iff_ultrafilter\n-/\n\n",
 "mem_closure_iff_nhds_neBot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n#print mem_closure_iff_nhds_neBot /-\ntheorem mem_closure_iff_nhds_neBot {s : Set Î±} :\n    a âˆˆ closure s â†” Â«expr âŠ“ Â» ((nhds) a) ((filter.principal) s) â‰  Â«exprâŠ¥Â» :=\n  mem_closure_iff_clusterPt.trans neBot_iff\n#align mem_closure_iff_nhds_ne_bot mem_closure_iff_nhds_neBot\n-/\n\n",
 "mem_closure_iff_nhds_basis'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_nhds_basis' /-\ntheorem mem_closure_iff_nhds_basis' {a : Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : ((nhds) a).has_basis p s) {t : Set Î±} :\n    a âˆˆ closure t â†” âˆ€ i, p i â†’ (s i âˆ© t).nonempty :=\n  mem_closure_iff_clusterPt.trans <|\n    (h.cluster_pt_iff (hasBasis_principal _)).trans <| by simp only [exists_prop, forall_const]\n#align mem_closure_iff_nhds_basis' mem_closure_iff_nhds_basis'\n-/\n\n",
 "mem_closure_iff_nhds_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_nhds_basis /-\ntheorem mem_closure_iff_nhds_basis {a : Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : ((nhds) a).has_basis p s) {t : Set Î±} :\n    a âˆˆ closure t â†” âˆ€ i, p i â†’ âˆƒ y âˆˆ t, y âˆˆ s i :=\n  (mem_closure_iff_nhds_basis' h).trans <| by simp only [Set.Nonempty, mem_inter_iff, exists_prop, and_comm']\n#align mem_closure_iff_nhds_basis mem_closure_iff_nhds_basis\n-/\n\n",
 "mem_closure_iff_nhdsWithin_neBot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n#print mem_closure_iff_nhdsWithin_neBot /-\ntheorem mem_closure_iff_nhdsWithin_neBot {s : Set Î±} {x : Î±} : x âˆˆ closure s â†” NeBot (nhds_within s x) :=\n  mem_closure_iff_clusterPt\n#align mem_closure_iff_nhds_within_ne_bot mem_closure_iff_nhdsWithin_neBot\n-/\n\n",
 "mem_closure_iff_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_nhds' /-\ntheorem mem_closure_iff_nhds' {s : Set Î±} {a : Î±} : a âˆˆ closure s â†” âˆ€ t âˆˆ (nhds) a, âˆƒ y : s, â†‘y âˆˆ t := by\n  simp only [mem_closure_iff_nhds, Set.inter_nonempty_iff_exists_right, SetCoe.exists, Subtype.coe_mk]\n#align mem_closure_iff_nhds' mem_closure_iff_nhds'\n-/\n\n",
 "mem_closure_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_nhds /-\ntheorem mem_closure_iff_nhds {s : Set Î±} {a : Î±} : a âˆˆ closure s â†” âˆ€ t âˆˆ (nhds) a, (t âˆ© s).nonempty :=\n  mem_closure_iff_clusterPt.trans clusterPt_principal_iff\n#align mem_closure_iff_nhds mem_closure_iff_nhds\n-/\n\n",
 "mem_closure_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_frequently /-\ntheorem mem_closure_iff_frequently {s : Set Î±} {a : Î±} :\n    a âˆˆ closure s â†”\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" ((nhds) a)\n        (x âˆˆ s) :=\n  by rw [Filter.Frequently, Filter.Eventually, â† mem_interior_iff_mem_nhds, closure_eq_compl_interior_compl] <;> rfl\n#align mem_closure_iff_frequently mem_closure_iff_frequently\n-/\n\n",
 "mem_closure_iff_comap_neBot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mem_closure_iff_comap_neBot /-\ntheorem mem_closure_iff_comap_neBot {A : Set Î±} {x : Î±} : x âˆˆ closure A â†” NeBot (comap (coe : A â†’ Î±) ((nhds) x)) := by\n  simp_rw [mem_closure_iff_nhds, comap_ne_bot_iff, Set.inter_nonempty_iff_exists_right, SetCoe.exists, Subtype.coe_mk]\n#align mem_closure_iff_comap_ne_bot mem_closure_iff_comap_neBot\n-/\n\n",
 "mem_closure_iff_clusterPt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print mem_closure_iff_clusterPt /-\ntheorem mem_closure_iff_clusterPt {s : Set Î±} {a : Î±} : a âˆˆ closure s â†” ClusterPt a ((filter.principal) s) :=\n  mem_closure_iff_frequently.trans clusterPt_principal_iff_frequently.symm\n#align mem_closure_iff_cluster_pt mem_closure_iff_clusterPt\n-/\n\n",
 "mem_closure_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print mem_closure_iff /-\ntheorem mem_closure_iff {s : Set Î±} {a : Î±} : a âˆˆ closure s â†” âˆ€ o, IsOpen o â†’ a âˆˆ o â†’ (o âˆ© s).nonempty :=\n  âŸ¨fun h o oo ao =>\n    by_contradiction fun os =>\n      have : s âŠ† Â«expr á¶œÂ» o := fun x xs xo => os âŸ¨x, xo, xsâŸ©\n      closure_minimal this (isClosed_compl_iff.2 oo) h ao,\n    fun H c âŸ¨hâ‚, hâ‚‚âŸ© =>\n    by_contradiction fun nc =>\n      let âŸ¨x, hc, hsâŸ© := H _ hâ‚.is_open_compl nc\n      hc (hâ‚‚ hs)âŸ©\n#align mem_closure_iff mem_closure_iff\n-/\n\n",
 "map_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print map_nhds /-\ntheorem map_nhds {a : Î±} {f : Î± â†’ Î²} :\n    map f ((nhds) a) =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        ((filter.principal) (image f s)) :=\n  ((nhds_basis_opens a).map f).eq_binfi\n#align map_nhds map_nhds\n-/\n\n",
 "map_mem_closure":
 "#print map_mem_closure /-\ntheorem map_mem_closure {s : Set Î±} {t : Set Î²} {f : Î± â†’ Î²} {a : Î±} (hf : Continuous f) (ha : a âˆˆ closure s)\n    (ht : MapsTo f s t) : f a âˆˆ closure t :=\n  ht.closure hf ha\n#align map_mem_closure map_mem_closure\n-/\n\n",
 "mapClusterPt_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print mapClusterPt_of_comp /-\ntheorem mapClusterPt_of_comp {Î¹ Î´ : Type _} {F : Filter Î¹} {Ï† : Î´ â†’ Î¹} {p : Filter Î´} {x : Î±} {u : Î¹ â†’ Î±} [NeBot p]\n    (h : Tendsto Ï† p F) (H : Tendsto (u âˆ˜ Ï†) p ((nhds) x)) : MapClusterPt x F u :=\n  by\n  have :=\n    calc\n      map (u âˆ˜ Ï†) p = map u (map Ï† p) := map_map\n      _ â‰¤ map u F := map_mono h\n      \n  have : map (u âˆ˜ Ï†) p â‰¤ Â«expr âŠ“ Â» ((nhds) x) (map u F) := le_inf H this\n  exact ne_bot_of_le this\n#align map_cluster_pt_of_comp mapClusterPt_of_comp\n-/\n\n",
 "mapClusterPt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n#print mapClusterPt_iff /-\ntheorem mapClusterPt_iff {Î¹ : Type _} (x : Î±) (F : Filter Î¹) (u : Î¹ â†’ Î±) :\n    MapClusterPt x F u â†”\n      âˆ€ s âˆˆ (nhds) x,\n        Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" F\n          (u a âˆˆ s) :=\n  by\n  simp_rw [MapClusterPt, ClusterPt, inf_ne_bot_iff_frequently_left, frequently_map]\n  rfl\n#align map_cluster_pt_iff mapClusterPt_iff\n-/\n\n",
 "map":
 "#print ClusterPt.map /-\ntheorem ClusterPt.map {x : Î±} {la : Filter Î±} {lb : Filter Î²} (H : ClusterPt x la) {f : Î± â†’ Î²} (hfc : ContinuousAt f x)\n    (hf : Tendsto f la lb) : ClusterPt (f x) lb :=\n  âŸ¨ne_bot_of_le_ne_bot ((map_neBot_iff f).2 H).ne <| hfc.tendsto.inf hfâŸ©\n#align cluster_pt.map ClusterPt.map\n-/\n\n",
 "lift'_closure_eq_self":
 "#print Filter.HasBasis.lift'_closure_eq_self /-\ntheorem Filter.HasBasis.lift'_closure_eq_self {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : l.has_basis p s)\n    (hc : âˆ€ i, p i â†’ IsClosed (s i)) : l.lift' closure = l :=\n  le_antisymm (h.ge_iff.2 fun i hi => (hc i hi).closure_eq â–¸ mem_lift' (h.mem_of_mem hi)) l.le_lift'_closure\n#align filter.has_basis.lift'_closure_eq_self Filter.HasBasis.lift'_closure_eq_self\n-/\n\n",
 "lift'_closure_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n#print Filter.lift'_closure_eq_bot /-\n@[simp]\ntheorem Filter.lift'_closure_eq_bot {l : Filter Î±} : l.lift' closure = Â«exprâŠ¥Â» â†” l = Â«exprâŠ¥Â» :=\n  âŸ¨fun h => bot_unique <| h â–¸ l.le_lift'_closure, fun h =>\n    h.symm â–¸ by rw [lift'_bot (monotone_closure _), closure_empty, principal_empty]âŸ©\n#align filter.lift'_closure_eq_bot Filter.lift'_closure_eq_bot\n-/\n\n",
 "lift'_closure":
 "#print Filter.HasBasis.lift'_closure /-\ntheorem Filter.HasBasis.lift'_closure {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : l.has_basis p s) :\n    (l.lift' closure).has_basis p fun i => closure (s i) :=\n  h.lift' (monotone_closure Î±)\n#align filter.has_basis.lift'_closure Filter.HasBasis.lift'_closure\n-/\n\n",
 "le_nhds_lim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print le_nhds_lim /-\n/-- If a filter `f` is majorated by some `ğ“ a`, then it is majorated by `ğ“ (Lim f)`. We formulate\nthis lemma with a `[nonempty Î±]` argument of `Lim` derived from `h` to make it useful for types\nwithout a `[nonempty Î±]` instance. Because of the built-in proof irrelevance, Lean will unify\nthis instance with any other instance. -/\ntheorem le_nhds_lim {f : Filter Î±} (h : âˆƒ a, f â‰¤ (nhds) a) : f â‰¤ (nhds) (@lim _ _ (nonempty_of_exists h) f) :=\n  epsilon_spec h\n#align le_nhds_Lim le_nhds_lim\n-/\n\n",
 "le_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print le_nhds_iff /-\n/-- A filter lies below the neighborhood filter at `a` iff it contains every open set around `a`. -/\ntheorem le_nhds_iff {f a} : f â‰¤ (nhds) a â†” âˆ€ s : Set Î±, a âˆˆ s â†’ IsOpen s â†’ s âˆˆ f := by simp [nhds_def]\n#align le_nhds_iff le_nhds_iff\n-/\n\n",
 "le_lift'_closure":
 "#print Filter.le_lift'_closure /-\ntheorem Filter.le_lift'_closure (l : Filter Î±) : l â‰¤ l.lift' closure :=\n  le_lift'.2 fun s hs => mem_of_superset hs subset_closure\n#align filter.le_lift'_closure Filter.le_lift'_closure\n-/\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n#print ContinuousAt.iterate /-\ntheorem ContinuousAt.iterate {f : Î± â†’ Î±} {x : Î±} (hf : ContinuousAt f x) (hx : f x = x) (n : â„•) :\n    ContinuousAt (Â«expr ^[ ]Â» f n) x :=\n  nat.rec_on n continuousAt_id fun n ihn =>\n    show ContinuousAt (Â«expr ^[ ]Â» f n âˆ˜ f) x from ContinuousAt.comp (hx.symm â–¸ ihn) hf\n#align continuous_at.iterate ContinuousAt.iterate\n-/\n\n",
 "isOpen_univ":
 "#print isOpen_univ /-\n@[simp]\ntheorem isOpen_univ : IsOpen (univ : Set Î±) :=\n  topological_space.is_open_univ\n#align is_open_univ isOpen_univ\n-/\n\n",
 "isOpen_unionâ‚›":
 "#print isOpen_unionâ‚› /-\ntheorem isOpen_unionâ‚› {s : Set (Set Î±)} (h : âˆ€ t âˆˆ s, IsOpen t) : IsOpen (â‹ƒâ‚€ s) :=\n  topological_space.is_open_sUnion s h\n#align is_open_sUnion isOpen_unionâ‚›\n-/\n\n",
 "isOpen_unionáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n#print isOpen_unionáµ¢ /-\ntheorem isOpen_unionáµ¢ {f : Î¹ â†’ Set Î±} (h : âˆ€ i, IsOpen (f i)) :\n    IsOpen (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) :=\n  isOpen_unionâ‚› <| by rintro _ âŸ¨i, rflâŸ© <;> exact h i\n#align is_open_Union isOpen_unionáµ¢\n-/\n\n",
 "isOpen_singleton_iff_punctured_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n#print isOpen_singleton_iff_punctured_nhds /-\ntheorem isOpen_singleton_iff_punctured_nhds {Î± : Type _} [TopologicalSpace Î±] (a : Î±) :\n    IsOpen ({a} : Set Î±) â†” nhds_within.ne a = Â«exprâŠ¥Â» := by\n  rw [isOpen_singleton_iff_nhds_eq_pure, nhdsWithin, â† mem_iff_inf_principal_compl, â† le_pure_iff,\n    nhds_ne_bot.le_pure_iff]\n#align is_open_singleton_iff_punctured_nhds isOpen_singleton_iff_punctured_nhds\n-/\n\n",
 "isOpen_singleton_iff_nhds_eq_pure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isOpen_singleton_iff_nhds_eq_pure /-\ntheorem isOpen_singleton_iff_nhds_eq_pure (a : Î±) : IsOpen ({a} : Set Î±) â†” (nhds) a = pure a :=\n  by\n  constructor\n  Â· intro h\n    apply le_antisymm _ (pure_le_nhds a)\n    rw [le_pure_iff]\n    exact h.mem_nhds (mem_singleton a)\n  Â· intro h\n    simp [isOpen_iff_nhds, h]\n#align is_open_singleton_iff_nhds_eq_pure isOpen_singleton_iff_nhds_eq_pure\n-/\n\n",
 "isOpen_setOf_eventually_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isOpen_setOf_eventually_nhds /-\ntheorem isOpen_setOf_eventually_nhds {p : Î± â†’ Prop} :\n    IsOpen\n      { x |\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n          ((nhds) x) (p y) } :=\n  by simp only [â† interior_setOf_eq, isOpen_interior]\n#align is_open_set_of_eventually_nhds isOpen_setOf_eventually_nhds\n-/\n\n",
 "isOpen_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n#print isOpen_mk /-\n/-\nCopyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes HÃ¶lzl, Mario Carneiro, Jeremy Avigad\n-/\ntheorem isOpen_mk {p hâ‚ hâ‚‚ hâ‚ƒ} {s : Set Î±} : (is_open_of âŸ¨p, hâ‚, hâ‚‚, hâ‚ƒâŸ©) s â†” p s :=\n  iff.rfl\n#align is_open_mk isOpen_mk\n-/\n\n",
 "isOpen_interâ‚›":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚â‚€ Â» -/\n#print isOpen_interâ‚› /-\ntheorem isOpen_interâ‚› {s : Set (Set Î±)} (hs : s.finite) : (âˆ€ t âˆˆ s, IsOpen t) â†’ IsOpen (Â«exprâ‹‚â‚€ Â» s) :=\n  Finite.induction_on hs (fun _ => by rw [sInter_empty] <;> exact isOpen_univ) fun a s has hs ih h => by\n    rw [sInter_insert] <;> exact IsOpen.inter (h _ <| mem_insert _ _) (ih fun t => h t âˆ˜ mem_insert_of_mem _)\n#align is_open_sInter isOpen_interâ‚›\n-/\n\n",
 "isOpen_interáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n#print isOpen_interáµ¢ /-\ntheorem isOpen_interáµ¢ [Finite Î¹] {s : Î¹ â†’ Set Î±} (h : âˆ€ i, IsOpen (s i)) :\n    IsOpen (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (s i)) :=\n  isOpen_interâ‚› (finite_range _) (forall_range_iff.2 h)\n#align is_open_Inter isOpen_interáµ¢\n-/\n\n",
 "isOpen_interior":
 "#print isOpen_interior /-\n@[simp]\ntheorem isOpen_interior {s : Set Î±} : IsOpen (interior s) :=\n  isOpen_unionâ‚› fun t âŸ¨hâ‚, hâ‚‚âŸ© => hâ‚\n#align is_open_interior isOpen_interior\n-/\n\n",
 "isOpen_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isOpen_iff_ultrafilter /-\ntheorem isOpen_iff_ultrafilter {s : Set Î±} : IsOpen s â†” âˆ€ x âˆˆ s, âˆ€ (l : Ultrafilter Î±), â†‘l â‰¤ (nhds) x â†’ s âˆˆ l := by\n  simp_rw [isOpen_iff_mem_nhds, â† mem_iff_ultrafilter]\n#align is_open_iff_ultrafilter isOpen_iff_ultrafilter\n-/\n\n",
 "isOpen_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print isOpen_iff_nhds /-\ntheorem isOpen_iff_nhds {s : Set Î±} : IsOpen s â†” âˆ€ a âˆˆ s, (nhds) a â‰¤ (filter.principal) s :=\n  calc\n    IsOpen s â†” s âŠ† interior s := subset_interior_iff_isOpen.symm\n    _ â†” âˆ€ a âˆˆ s, (nhds) a â‰¤ (filter.principal) s := by rw [interior_eq_nhds] <;> rfl\n    \n#align is_open_iff_nhds isOpen_iff_nhds\n-/\n\n",
 "isOpen_iff_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isOpen_iff_mem_nhds /-\ntheorem isOpen_iff_mem_nhds {s : Set Î±} : IsOpen s â†” âˆ€ a âˆˆ s, s âˆˆ (nhds) a :=\n  isOpen_iff_nhds.trans <| forall_congr' fun _ => imp_congr_right fun _ => le_principal_iff\n#align is_open_iff_mem_nhds isOpen_iff_mem_nhds\n-/\n\n",
 "isOpen_iff_forall_mem_open":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\n#print isOpen_iff_forall_mem_open /-\ntheorem isOpen_iff_forall_mem_open : IsOpen s â†” âˆ€ x âˆˆ s, âˆƒ (t : _)(_ : t âŠ† s), IsOpen t âˆ§ x âˆˆ t := by\n  rw [â† subset_interior_iff_isOpen] <;> simp only [subset_def, mem_interior]\n#align is_open_iff_forall_mem_open isOpen_iff_forall_mem_open\n-/\n\n",
 "isOpen_iff_eventually":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isOpen_iff_eventually /-\n/-- A set `s` is open iff for every point `x` in `s` and every `y` close to `x`, `y` is in `s`. -/\ntheorem isOpen_iff_eventually {s : Set Î±} :\n    IsOpen s â†”\n      âˆ€ x,\n        x âˆˆ s â†’\n          Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n            ((nhds) x) (y âˆˆ s) :=\n  isOpen_iff_mem_nhds\n#align is_open_iff_eventually isOpen_iff_eventually\n-/\n\n",
 "isOpen_fold":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `is_open_of -/\n#print isOpen_fold /-\ntheorem isOpen_fold {s : Set Î±} {t : TopologicalSpace Î±} : t.is_open s = (is_open_of t) s :=\n  rfl\n#align is_open_fold isOpen_fold\n-/\n\n",
 "isOpen_empty":
 "#print isOpen_empty /-\n@[simp]\ntheorem isOpen_empty : IsOpen (âˆ… : Set Î±) := by rw [â† sUnion_empty] <;> exact isOpen_unionâ‚› fun a => false.elim\n#align is_open_empty isOpen_empty\n-/\n\n",
 "isOpen_const":
 "#print isOpen_const /-\ntheorem isOpen_const {p : Prop} : IsOpen { a : Î± | p } :=\n  by_cases (fun this : p => by simp only [this] <;> exact isOpen_univ) fun this : Â¬p => by\n    simp only [this] <;> exact isOpen_empty\n#align is_open_const isOpen_const\n-/\n\n",
 "isOpen_compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print isOpen_compl_iff /-\n@[simp]\ntheorem isOpen_compl_iff {s : Set Î±} : IsOpen (Â«expr á¶œÂ» s) â†” IsClosed s :=\n  âŸ¨fun h => âŸ¨hâŸ©, fun h => h.is_open_complâŸ©\n#align is_open_compl_iff isOpen_compl_iff\n-/\n\n",
 "isOpen_bunionáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n#print isOpen_bunionáµ¢ /-\ntheorem isOpen_bunionáµ¢ {s : Set Î²} {f : Î² â†’ Set Î±} (h : âˆ€ i âˆˆ s, IsOpen (f i)) :\n    IsOpen (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) :=\n  isOpen_unionáµ¢ fun i => isOpen_unionáµ¢ fun hi => h i hi\n#align is_open_bUnion isOpen_bunionáµ¢\n-/\n\n",
 "isOpen_binteráµ¢_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n#print isOpen_binteráµ¢_finset /-\ntheorem isOpen_binteráµ¢_finset {s : Finset Î²} {f : Î² â†’ Set Î±} (h : âˆ€ i âˆˆ s, IsOpen (f i)) :\n    IsOpen (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f i)) :=\n  isOpen_binteráµ¢ (toFinite _) h\n#align is_open_bInter_finset isOpen_binteráµ¢_finset\n-/\n\n",
 "isOpen_binteráµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n#print isOpen_binteráµ¢ /-\ntheorem isOpen_binteráµ¢ {s : Set Î²} {f : Î² â†’ Set Î±} (hs : s.finite) :\n    (âˆ€ i âˆˆ s, IsOpen (f i)) â†’\n      IsOpen (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f i)) :=\n  Finite.induction_on hs (fun _ => by rw [bInter_empty] <;> exact isOpen_univ) fun a s has hs ih h => by\n    rw [bInter_insert] <;> exact IsOpen.inter (h a (mem_insert _ _)) (ih fun i hi => h i (mem_insert_of_mem _ hi))\n#align is_open_bInter isOpen_binteráµ¢\n-/\n\n",
 "isClosed_univ":
 "#print isClosed_univ /-\n@[simp]\ntheorem isClosed_univ : IsClosed (univ : Set Î±) :=\n  by\n  rw [â† isOpen_compl_iff, compl_univ]\n  exact isOpen_empty\n#align is_closed_univ isClosed_univ\n-/\n\n",
 "isClosed_unionáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n#print isClosed_unionáµ¢ /-\ntheorem isClosed_unionáµ¢ [Finite Î¹] {s : Î¹ â†’ Set Î±} (h : âˆ€ i, IsClosed (s i)) :\n    IsClosed (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (s i)) :=\n  by\n  simp only [â† isOpen_compl_iff, compl_Union] at *\n  exact isOpen_interáµ¢ h\n#align is_closed_Union isClosed_unionáµ¢\n-/\n\n",
 "isClosed_setOf_clusterPt":
 "#print isClosed_setOf_clusterPt /-\n/-- The set of cluster points of a filter is closed. In particular, the set of limit points\nof a sequence is closed. -/\ntheorem isClosed_setOf_clusterPt {f : Filter Î±} : IsClosed { x | ClusterPt x f } :=\n  by\n  simp only [ClusterPt, inf_ne_bot_iff_frequently_left, set_of_forall, imp_iff_not_or]\n  refine' isClosed_interáµ¢ fun p => IsClosed.union _ _ <;> apply isClosed_compl_iff.2\n  exacts[isOpen_setOf_eventually_nhds, isOpen_const]\n#align is_closed_set_of_cluster_pt isClosed_setOf_clusterPt\n-/\n\n",
 "isClosed_of_closure_subset":
 "#print isClosed_of_closure_subset /-\ntheorem isClosed_of_closure_subset {s : Set Î±} (h : closure s âŠ† s) : IsClosed s := by\n  rw [subset.antisymm subset_closure h] <;> exact isClosed_closure\n#align is_closed_of_closure_subset isClosed_of_closure_subset\n-/\n\n",
 "isClosed_interâ‚›":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚â‚€ Â» -/\n#print isClosed_interâ‚› /-\ntheorem isClosed_interâ‚› {s : Set (Set Î±)} : (âˆ€ t âˆˆ s, IsClosed t) â†’ IsClosed (Â«exprâ‹‚â‚€ Â» s) := by\n  simpa only [â† isOpen_compl_iff, compl_sInter, sUnion_image] using isOpen_bunionáµ¢\n#align is_closed_sInter isClosed_interâ‚›\n-/\n\n",
 "isClosed_interáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n#print isClosed_interáµ¢ /-\ntheorem isClosed_interáµ¢ {f : Î¹ â†’ Set Î±} (h : âˆ€ i, IsClosed (f i)) :\n    IsClosed (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f i)) :=\n  isClosed_interâ‚› fun t âŸ¨i, (HEq : f i = t)âŸ© => HEq â–¸ h i\n#align is_closed_Inter isClosed_interáµ¢\n-/\n\n",
 "isClosed_imp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print isClosed_imp /-\ntheorem isClosed_imp {p q : Î± â†’ Prop} (hp : IsOpen { x | p x }) (hq : IsClosed { x | q x }) :\n    IsClosed { x | p x â†’ q x } :=\n  by\n  have : { x | p x â†’ q x } = Â«expr á¶œÂ» { x | p x } âˆª { x | q x } := Set.ext fun x => imp_iff_not_or\n  rw [this] <;> exact IsClosed.union (is_closed_compl_iff.mpr hp) hq\n#align is_closed_imp isClosed_imp\n-/\n\n",
 "isClosed_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isClosed_iff_nhds /-\ntheorem isClosed_iff_nhds {s : Set Î±} : IsClosed s â†” âˆ€ x, (âˆ€ U âˆˆ (nhds) x, (U âˆ© s).nonempty) â†’ x âˆˆ s := by\n  simp_rw [isClosed_iff_clusterPt, ClusterPt, inf_principal_ne_bot_iff]\n#align is_closed_iff_nhds isClosed_iff_nhds\n-/\n\n",
 "isClosed_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print isClosed_iff_frequently /-\n/-- A set `s` is closed iff for every point `x`, if there is a point `y` close to `x` that belongs\nto `s` then `x` is in `s`. -/\ntheorem isClosed_iff_frequently {s : Set Î±} :\n    IsClosed s â†”\n      âˆ€ x,\n        Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\"\n            ((nhds) x) (y âˆˆ s) â†’\n          x âˆˆ s :=\n  by\n  rw [â† closure_subset_iff_isClosed]\n  apply forall_congr' fun x => _\n  rw [mem_closure_iff_frequently]\n#align is_closed_iff_frequently isClosed_iff_frequently\n-/\n\n",
 "isClosed_iff_clusterPt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print isClosed_iff_clusterPt /-\ntheorem isClosed_iff_clusterPt {s : Set Î±} : IsClosed s â†” âˆ€ a, ClusterPt a ((filter.principal) s) â†’ a âˆˆ s :=\n  calc\n    IsClosed s â†” closure s âŠ† s := closure_subset_iff_isClosed.symm\n    _ â†” âˆ€ a, ClusterPt a ((filter.principal) s) â†’ a âˆˆ s := by simp only [subset_def, mem_closure_iff_clusterPt]\n    \n#align is_closed_iff_cluster_pt isClosed_iff_clusterPt\n-/\n\n",
 "isClosed_frontier":
 "#print isClosed_frontier /-\n/-- The frontier of a set is closed. -/\ntheorem isClosed_frontier {s : Set Î±} : IsClosed (frontier s) := by\n  rw [frontier_eq_closure_inter_closure] <;> exact IsClosed.inter isClosed_closure isClosed_closure\n#align is_closed_frontier isClosed_frontier\n-/\n\n",
 "isClosed_empty":
 "#print isClosed_empty /-\n@[simp]\ntheorem isClosed_empty : IsClosed (âˆ… : Set Î±) :=\n  by\n  rw [â† isOpen_compl_iff, compl_empty]\n  exact isOpen_univ\n#align is_closed_empty isClosed_empty\n-/\n\n",
 "isClosed_compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print isClosed_compl_iff /-\n@[simp]\ntheorem isClosed_compl_iff {s : Set Î±} : IsClosed (Â«expr á¶œÂ» s) â†” IsOpen s := by rw [â† isOpen_compl_iff, compl_compl]\n#align is_closed_compl_iff isClosed_compl_iff\n-/\n\n",
 "isClosed_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print IsOpen.isClosed_compl /-\ntheorem IsOpen.isClosed_compl {s : Set Î±} (hs : IsOpen s) : IsClosed (Â«expr á¶œÂ» s) :=\n  isClosed_compl_iff.2 hs\n#align is_open.is_closed_compl IsOpen.isClosed_compl\n-/\n\n",
 "isClosed_closure":
 "#print isClosed_closure /-\n@[simp]\ntheorem isClosed_closure {s : Set Î±} : IsClosed (closure s) :=\n  isClosed_interâ‚› fun t âŸ¨hâ‚, hâ‚‚âŸ© => hâ‚\n#align is_closed_closure isClosed_closure\n-/\n\n",
 "isClosed_bunionáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n#print isClosed_bunionáµ¢ /-\ntheorem isClosed_bunionáµ¢ {s : Set Î²} {f : Î² â†’ Set Î±} (hs : s.finite) :\n    (âˆ€ i âˆˆ s, IsClosed (f i)) â†’\n      IsClosed\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) :=\n  Finite.induction_on hs (fun _ => by rw [bUnion_empty] <;> exact isClosed_empty) fun a s has hs ih h => by\n    rw [bUnion_insert] <;> exact IsClosed.union (h a (mem_insert _ _)) (ih fun i hi => h i (mem_insert_of_mem _ hi))\n#align is_closed_bUnion isClosed_bunionáµ¢\n-/\n\n",
 "isClosed_binteráµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n#print isClosed_binteráµ¢ /-\ntheorem isClosed_binteráµ¢ {s : Set Î²} {f : Î² â†’ Set Î±} (h : âˆ€ i âˆˆ s, IsClosed (f i)) :\n    IsClosed (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f i)) :=\n  isClosed_interáµ¢ fun i => isClosed_interáµ¢ <| h i\n#align is_closed_bInter isClosed_binteráµ¢\n-/\n\n",
 "interior_univ":
 "#print interior_univ /-\n@[simp]\ntheorem interior_univ : interior (univ : Set Î±) = univ :=\n  isOpen_univ.interior_eq\n#align interior_univ interior_univ\n-/\n\n",
 "interior_union_right":
 "#print IsClosed.interior_union_right /-\ntheorem IsClosed.interior_union_right {s t : Set Î±} (h : IsClosed t) : interior (s âˆª t) âŠ† interior s âˆª t := by\n  simpa only [union_comm] using h.interior_union_left\n#align is_closed.interior_union_right IsClosed.interior_union_right\n-/\n\n",
 "interior_union_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print IsClosed.interior_union_left /-\ntheorem IsClosed.interior_union_left {s t : Set Î±} (h : IsClosed s) : interior (s âˆª t) âŠ† s âˆª interior t :=\n  fun a âŸ¨u, âŸ¨âŸ¨huâ‚, huâ‚‚âŸ©, haâŸ©âŸ© =>\n  (classical.em (a âˆˆ s)).imp_right fun h =>\n    mem_interior.mpr\n      âŸ¨u âˆ© Â«expr á¶œÂ» s, fun x hx => (huâ‚‚ hx.1).resolve_left hx.2, IsOpen.inter huâ‚ is_closed.is_open_compl, âŸ¨ha, hâŸ©âŸ©\n#align is_closed.interior_union_left IsClosed.interior_union_left\n-/\n\n",
 "interior_union_isClosed_of_interior_empty":
 "#print interior_union_isClosed_of_interior_empty /-\ntheorem interior_union_isClosed_of_interior_empty {s t : Set Î±} (hâ‚ : IsClosed s) (hâ‚‚ : interior t = âˆ…) :\n    interior (s âˆª t) = interior s :=\n  have : interior (s âˆª t) âŠ† s := fun x âŸ¨u, âŸ¨(huâ‚ : IsOpen u), (huâ‚‚ : u âŠ† s âˆª t)âŸ©, (hxâ‚ : x âˆˆ u)âŸ© =>\n    by_contradiction fun hxâ‚‚ : x âˆ‰ s =>\n      have : u \\ s âŠ† t := fun x âŸ¨hâ‚, hâ‚‚âŸ© => or.resolve_left (huâ‚‚ hâ‚) hâ‚‚\n      have : u \\ s âŠ† interior t := by rwa [(IsOpen.sdiff huâ‚ hâ‚).subset_interior_iff]\n      have : u \\ s âŠ† âˆ… := by rwa [hâ‚‚] at this\n      this âŸ¨hxâ‚, hxâ‚‚âŸ©\n  Subset.antisymm (interior_maximal this isOpen_interior) (interior_mono <| subset_union_left _ _)\n#align interior_union_is_closed_of_interior_empty interior_union_isClosed_of_interior_empty\n-/\n\n",
 "interior_subset_closure":
 "#print interior_subset_closure /-\ntheorem interior_subset_closure {s : Set Î±} : interior s âŠ† closure s :=\n  Subset.trans interior_subset subset_closure\n#align interior_subset_closure interior_subset_closure\n-/\n\n",
 "interior_subset":
 "#print interior_subset /-\ntheorem interior_subset {s : Set Î±} : interior s âŠ† s :=\n  unionâ‚›_subset fun t âŸ¨hâ‚, hâ‚‚âŸ© => hâ‚‚\n#align interior_subset interior_subset\n-/\n\n",
 "interior_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n#print interior_singleton /-\n/-- If `x` is not an isolated point of a topological space, then the interior of `{x}` is empty. -/\n@[simp]\ntheorem interior_singleton (x : Î±) [NeBot (nhds_within.ne x)] : interior {x} = (âˆ… : Set Î±) :=\n  interior_eq_empty_iff_dense_compl.2 (dense_compl_singleton x)\n#align interior_singleton interior_singleton\n-/\n\n",
 "interior_setOf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print interior_setOf_eq /-\ntheorem interior_setOf_eq {p : Î± â†’ Prop} :\n    interior { x | p x } =\n      { x |\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n          ((nhds) x) (p y) } :=\n  interior_eq_nhds'\n#align interior_set_of_eq interior_setOf_eq\n-/\n\n",
 "interior_mono":
 "#print interior_mono /-\n@[mono]\ntheorem interior_mono {s t : Set Î±} (h : s âŠ† t) : interior s âŠ† interior t :=\n  interior_maximal (Subset.trans interior_subset h) isOpen_interior\n#align interior_mono interior_mono\n-/\n\n",
 "interior_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print interior_mem_nhds /-\n@[simp]\ntheorem interior_mem_nhds {s : Set Î±} {a : Î±} : interior s âˆˆ (nhds) a â†” s âˆˆ (nhds) a :=\n  âŸ¨fun h => mem_of_superset h interior_subset, fun h => IsOpen.mem_nhds isOpen_interior (mem_interior_iff_mem_nhds.2 h)âŸ©\n#align interior_mem_nhds interior_mem_nhds\n-/\n\n",
 "interior_maximal":
 "#print interior_maximal /-\ntheorem interior_maximal {s t : Set Î±} (hâ‚ : t âŠ† s) (hâ‚‚ : IsOpen t) : t âŠ† interior s :=\n  subset_unionâ‚›_of_mem âŸ¨hâ‚‚, hâ‚âŸ©\n#align interior_maximal interior_maximal\n-/\n\n",
 "interior_interâ‚›_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚â‚€ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚â‚€ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n#print interior_interâ‚›_subset /-\ntheorem interior_interâ‚›_subset (S : Set (Set Î±)) :\n    interior (Â«exprâ‹‚â‚€ Â» S) âŠ†\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (interior s) :=\n  calc\n    interior (Â«exprâ‹‚â‚€ Â» S) =\n        interior (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" s) :=\n      by rw [sInter_eq_bInter]\n    _ âŠ† Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (interior s) :=\n      interior_Interâ‚‚_subset _ _\n    \n#align interior_sInter_subset interior_interâ‚›_subset\n-/\n\n",
 "interior_interáµ¢_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n#print interior_interáµ¢_subset /-\ntheorem interior_interáµ¢_subset (s : Î¹ â†’ Set Î±) :\n    interior (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (s i)) âŠ†\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\"\n        (interior (s i)) :=\n  subset_interáµ¢ fun i => interior_mono <| interáµ¢_subset _ _\n#align interior_Inter_subset interior_interáµ¢_subset\n-/\n\n",
 "interior_interáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n#print interior_interáµ¢ /-\n@[simp]\ntheorem interior_interáµ¢ {Î¹ : Type _} [Finite Î¹] (f : Î¹ â†’ Set Î±) :\n    interior (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f i)) =\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\"\n        (interior (f i)) :=\n  by\n  cases nonempty_fintype Î¹\n  convert finset.univ.interior_Inter f <;> simp\n#align interior_Inter interior_interáµ¢\n-/\n\n",
 "interior_interior":
 "#print interior_interior /-\n@[simp]\ntheorem interior_interior {s : Set Î±} : interior (interior s) = interior s :=\n  isOpen_interior.interior_eq\n#align interior_interior interior_interior\n-/\n\n",
 "interior_inter":
 "#print interior_inter /-\n@[simp]\ntheorem interior_inter {s t : Set Î±} : interior (s âˆ© t) = interior s âˆ© interior t :=\n  Subset.antisymm (subset_inter (interior_mono <| inter_subset_left s t) (interior_mono <| inter_subset_right s t))\n    (interior_maximal (inter_subset_inter interior_subset interior_subset) <|\n      IsOpen.inter isOpen_interior isOpen_interior)\n#align interior_inter interior_inter\n-/\n\n",
 "interior_frontier":
 "#print interior_frontier /-\n/-- The frontier of a closed set has no interior point. -/\ntheorem interior_frontier {s : Set Î±} (h : IsClosed s) : interior (frontier s) = âˆ… :=\n  by\n  have A : frontier s = s \\ interior s := h.frontier_eq\n  have B : interior (frontier s) âŠ† interior s := by rw [A] <;> exact interior_mono (diff_subset _ _)\n  have C : interior (frontier s) âŠ† frontier s := interior_subset\n  have : interior (frontier s) âŠ† interior s âˆ© (s \\ interior s) := subset_inter B (by simpa [A] using C)\n  rwa [inter_diff_self, subset_empty_iff] at this\n#align interior_frontier interior_frontier\n-/\n\n",
 "interior_eq_univ":
 "#print interior_eq_univ /-\n@[simp]\ntheorem interior_eq_univ {s : Set Î±} : interior s = univ â†” s = univ :=\n  âŸ¨fun h => univ_subset_iff.mp <| h.symm.trans_le interior_subset, fun h => h.symm â–¸ interior_univâŸ©\n#align interior_eq_univ interior_eq_univ\n-/\n\n",
 "interior_eq_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print interior_eq_nhds' /-\ntheorem interior_eq_nhds' {s : Set Î±} : interior s = { a | s âˆˆ (nhds) a } :=\n  Set.ext fun x => by simp only [mem_interior, mem_nhds_iff, mem_set_of_eq]\n#align interior_eq_nhds' interior_eq_nhds'\n-/\n\n",
 "interior_eq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print interior_eq_nhds /-\ntheorem interior_eq_nhds {s : Set Î±} : interior s = { a | (nhds) a â‰¤ (filter.principal) s } :=\n  interior_eq_nhds'.trans <| by simp only [le_principal_iff]\n#align interior_eq_nhds interior_eq_nhds\n-/\n\n",
 "interior_eq_iff_isOpen":
 "#print interior_eq_iff_isOpen /-\ntheorem interior_eq_iff_isOpen {s : Set Î±} : interior s = s â†” IsOpen s :=\n  âŸ¨fun h => h â–¸ isOpen_interior, IsOpen.interior_eqâŸ©\n#align interior_eq_iff_is_open interior_eq_iff_isOpen\n-/\n\n",
 "interior_eq_empty_iff_dense_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print interior_eq_empty_iff_dense_compl /-\ntheorem interior_eq_empty_iff_dense_compl {s : Set Î±} : interior s = âˆ… â†” Dense (Â«expr á¶œÂ» s) := by\n  rw [dense_iff_closure_eq, closure_compl, compl_univ_iff]\n#align interior_eq_empty_iff_dense_compl interior_eq_empty_iff_dense_compl\n-/\n\n",
 "interior_eq":
 "#print IsOpen.interior_eq /-\ntheorem IsOpen.interior_eq {s : Set Î±} (h : IsOpen s) : interior s = s :=\n  Subset.antisymm interior_subset (interior_maximal (Subset.refl s) h)\n#align is_open.interior_eq IsOpen.interior_eq\n-/\n\n",
 "interior_empty":
 "#print interior_empty /-\n@[simp]\ntheorem interior_empty : interior (âˆ… : Set Î±) = âˆ… :=\n  isOpen_empty.interior_eq\n#align interior_empty interior_empty\n-/\n\n",
 "interior_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print Dense.interior_compl /-\ntheorem Dense.interior_compl {s : Set Î±} (h : Dense s) : interior (Â«expr á¶œÂ» s) = âˆ… :=\n  interior_eq_empty_iff_dense_compl.2 <| by rwa [compl_compl]\n#align dense.interior_compl Dense.interior_compl\n-/\n\n",
 "interior_Interâ‚‚_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n#print interior_Interâ‚‚_subset /-\ntheorem interior_Interâ‚‚_subset (p : Î¹ â†’ Sort _) (s : âˆ€ i, p i â†’ Set Î±) :\n    interior (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (s i j)) âŠ†\n      Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\"\n        (interior (s i j)) :=\n  (interior_interáµ¢_subset _).trans <| interáµ¢_mono fun i => interior_interáµ¢_subset _\n#align interior_Interâ‚‚_subset interior_Interâ‚‚_subset\n-/\n\n",
 "inter_of_open_right":
 "#print Dense.inter_of_open_right /-\n/-- The intersection of a dense set with an open dense set is a dense set. -/\ntheorem Dense.inter_of_open_right {s t : Set Î±} (hs : Dense s) (ht : Dense t) (hto : IsOpen t) : Dense (s âˆ© t) :=\n  inter_comm t s â–¸ ht.inter_of_open_left hs hto\n#align dense.inter_of_open_right Dense.inter_of_open_right\n-/\n\n",
 "inter_of_open_left":
 "#print Dense.inter_of_open_left /-\n/-- The intersection of an open dense set with a dense set is a dense set. -/\ntheorem Dense.inter_of_open_left {s t : Set Î±} (hs : Dense s) (ht : Dense t) (hso : IsOpen s) : Dense (s âˆ© t) :=\n  fun x => closure_minimal hso.inter_closure isClosed_closure <| by simp [hs.closure_eq, ht.closure_eq]\n#align dense.inter_of_open_left Dense.inter_of_open_left\n-/\n\n",
 "inter_nhds_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Dense.inter_nhds_nonempty /-\ntheorem Dense.inter_nhds_nonempty {s t : Set Î±} (hs : Dense s) {x : Î±} (ht : t âˆˆ (nhds) x) : (s âˆ© t).nonempty :=\n  let âŸ¨U, hsub, ho, hxâŸ© := mem_nhds_iff.1 ht\n  (hs.inter_open_nonempty U ho âŸ¨x, hxâŸ©).mono fun y hy => âŸ¨hy.2, hsub hy.1âŸ©\n#align dense.inter_nhds_nonempty Dense.inter_nhds_nonempty\n-/\n\n",
 "inter_frontier_eq":
 "#print IsOpen.inter_frontier_eq /-\ntheorem IsOpen.inter_frontier_eq {s : Set Î±} (hs : IsOpen s) : s âˆ© frontier s = âˆ… := by\n  rw [hs.frontier_eq, inter_diff_self]\n#align is_open.inter_frontier_eq IsOpen.inter_frontier_eq\n-/\n\n",
 "inter_closure":
 "#print IsOpen.inter_closure /-\ntheorem IsOpen.inter_closure {s t : Set Î±} (h : IsOpen s) : s âˆ© closure t âŠ† closure (s âˆ© t) :=\n  compl_subset_compl.mp <| by\n    simpa only [â† interior_compl, compl_inter] using IsClosed.interior_union_left h.is_closed_compl\n#align is_open.inter_closure IsOpen.inter_closure\n-/\n\n",
 "inter":
 "#print IsClosed.inter /-\ntheorem IsClosed.inter (hâ‚ : IsClosed sâ‚) (hâ‚‚ : IsClosed sâ‚‚) : IsClosed (sâ‚ âˆ© sâ‚‚) :=\n  by\n  rw [â† isOpen_compl_iff] at *\n  rw [compl_inter]\n  exact IsOpen.union hâ‚ hâ‚‚\n#align is_closed.inter IsClosed.inter\n-/\n\n",
 "image_closure_subset_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print image_closure_subset_closure_image /-\ntheorem image_closure_subset_closure_image {f : Î± â†’ Î²} {s : Set Î±} (h : Continuous f) :\n    Â«expr '' Â» f (closure s) âŠ† closure (Â«expr '' Â» f s) :=\n  ((mapsTo_image f s).closure h).image_subset\n#align image_closure_subset_closure_image image_closure_subset_closure_image\n-/\n\n",
 "frontier_univ":
 "#print frontier_univ /-\n@[simp]\ntheorem frontier_univ : frontier (univ : Set Î±) = âˆ… := by simp [frontier]\n#align frontier_univ frontier_univ\n-/\n\n",
 "frontier_union_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print frontier_union_subset /-\ntheorem frontier_union_subset (s t : Set Î±) :\n    frontier (s âˆª t) âŠ† frontier s âˆ© closure (Â«expr á¶œÂ» t) âˆª closure (Â«expr á¶œÂ» s) âˆ© frontier t := by\n  simpa only [frontier_compl, â† compl_union] using frontier_inter_subset (Â«expr á¶œÂ» s) (Â«expr á¶œÂ» t)\n#align frontier_union_subset frontier_union_subset\n-/\n\n",
 "frontier_subset_closure":
 "#print frontier_subset_closure /-\ntheorem frontier_subset_closure {s : Set Î±} : frontier s âŠ† closure s :=\n  diff_subset _ _\n#align frontier_subset_closure frontier_subset_closure\n-/\n\n",
 "frontier_subset":
 "#print IsClosed.frontier_subset /-\ntheorem IsClosed.frontier_subset (hs : IsClosed s) : frontier s âŠ† s :=\n  frontier_subset_closure.trans hs.closure_eq.subset\n#align is_closed.frontier_subset IsClosed.frontier_subset\n-/\n\n",
 "frontier_right":
 "#print Disjoint.frontier_right /-\ntheorem Disjoint.frontier_right (hs : IsOpen s) (hd : Disjoint s t) : Disjoint s (frontier t) :=\n  (hd.symm.frontier_left hs).symm\n#align disjoint.frontier_right Disjoint.frontier_right\n-/\n\n",
 "frontier_preimage_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n#print Continuous.frontier_preimage_subset /-\ntheorem Continuous.frontier_preimage_subset {f : Î± â†’ Î²} (hf : Continuous f) (t : Set Î²) :\n    frontier (Â«expr â»Â¹' Â» f t) âŠ† Â«expr â»Â¹' Â» f (frontier t) :=\n  diff_subset_diff (hf.closure_preimage_subset t) (preimage_interior_subset_interior_preimage hf)\n#align continuous.frontier_preimage_subset Continuous.frontier_preimage_subset\n-/\n\n",
 "frontier_left":
 "#print Disjoint.frontier_left /-\ntheorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=\n  subset_compl_iff_disjoint_right.1 <|\n    frontier_subset_closure.trans <| closure_minimal (disjoint_left.1 hd) <| isClosed_compl_iff.2 ht\n#align disjoint.frontier_left Disjoint.frontier_left\n-/\n\n",
 "frontier_interior_subset":
 "#print frontier_interior_subset /-\ntheorem frontier_interior_subset {s : Set Î±} : frontier (interior s) âŠ† frontier s :=\n  diff_subset_diff (closure_mono interior_subset) interior_interior.symm.subset\n#align frontier_interior_subset frontier_interior_subset\n-/\n\n",
 "frontier_inter_subset":
 "#print frontier_inter_subset /-\ntheorem frontier_inter_subset (s t : Set Î±) : frontier (s âˆ© t) âŠ† frontier s âˆ© closure t âˆª closure s âˆ© frontier t :=\n  by\n  simp only [frontier_eq_closure_inter_closure, compl_inter, closure_union]\n  convert inter_subset_inter_left _ (closure_inter_subset_inter_closure s t)\n  simp only [inter_distrib_left, inter_distrib_right, inter_assoc]\n  congr 2\n  apply inter_comm\n#align frontier_inter_subset frontier_inter_subset\n-/\n\n",
 "frontier_eq_inter_compl_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print frontier_eq_inter_compl_interior /-\ntheorem frontier_eq_inter_compl_interior {s : Set Î±} :\n    frontier s = Â«expr á¶œÂ» (interior s) âˆ© Â«expr á¶œÂ» (interior (Â«expr á¶œÂ» s)) :=\n  by\n  rw [â† frontier_compl, â† closure_compl]\n  rfl\n#align frontier_eq_inter_compl_interior frontier_eq_inter_compl_interior\n-/\n\n",
 "frontier_eq_closure_inter_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print frontier_eq_closure_inter_closure /-\ntheorem frontier_eq_closure_inter_closure {s : Set Î±} : frontier s = closure s âˆ© closure (Â«expr á¶œÂ» s) := by\n  rw [closure_compl, frontier, diff_eq]\n#align frontier_eq_closure_inter_closure frontier_eq_closure_inter_closure\n-/\n\n",
 "frontier_eq":
 "#print IsOpen.frontier_eq /-\ntheorem IsOpen.frontier_eq {s : Set Î±} (hs : IsOpen s) : frontier s = closure s \\ s := by rw [frontier, hs.interior_eq]\n#align is_open.frontier_eq IsOpen.frontier_eq\n-/\n\n",
 "frontier_empty":
 "#print frontier_empty /-\n@[simp]\ntheorem frontier_empty : frontier (âˆ… : Set Î±) = âˆ… := by simp [frontier]\n#align frontier_empty frontier_empty\n-/\n\n",
 "frontier_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print frontier_compl /-\n/-- The complement of a set has the same frontier as the original set. -/\n@[simp]\ntheorem frontier_compl (s : Set Î±) : frontier (Â«expr á¶œÂ» s) = frontier s := by\n  simp only [frontier_eq_closure_inter_closure, compl_compl, inter_comm]\n#align frontier_compl frontier_compl\n-/\n\n",
 "frontier_closure_subset":
 "#print frontier_closure_subset /-\ntheorem frontier_closure_subset {s : Set Î±} : frontier (closure s) âŠ† frontier s :=\n  diff_subset_diff closure_closure.subset <| interior_mono subset_closure\n#align frontier_closure_subset frontier_closure_subset\n-/\n\n",
 "frequently_frequently_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print frequently_frequently_nhds /-\n@[simp]\ntheorem frequently_frequently_nhds {p : Î± â†’ Prop} {a : Î±} :\n    Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" ((nhds) a)\n        (Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\"\n          ((nhds) y) (p x)) â†”\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" ((nhds) a)\n        (p x) :=\n  by\n  rw [â† not_iff_not]\n  simp_rw [not_frequently]\n  exact eventually_eventually_nhds\n#align frequently_frequently_nhds frequently_frequently_nhds\n-/\n\n",
 "exists_open_set_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_open_set_nhds' /-\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\nit contains an open set containing `s`. -/\ntheorem exists_open_set_nhds' {s U : Set Î±}\n    (h :\n      U âˆˆ Â«exprâ¨† , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨† , Â»\" ((nhds) x)) :\n    âˆƒ V : Set Î±, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U :=\n  exists_open_set_nhds (by simpa using h)\n#align exists_open_set_nhds' exists_open_set_nhds'\n-/\n\n",
 "exists_open_set_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print exists_open_set_nhds /-\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. -/\ntheorem exists_open_set_nhds {s U : Set Î±} (h : âˆ€ x âˆˆ s, U âˆˆ (nhds) x) : âˆƒ V : Set Î±, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U :=\n  by\n  have := fun x hx => (nhds_basis_opens x).mem_iff.1 (h x hx)\n  choose! Z hZ hZU using this; choose hZmem hZo using hZ\n  exact\n    âŸ¨Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (Z x), fun x hx =>\n      mem_bUnion hx (hZmem x hx), isOpen_bunionáµ¢ hZo, Unionâ‚‚_subset hZUâŸ©\n#align exists_open_set_nhds exists_open_set_nhds\n-/\n\n",
 "exists_mem_open":
 "#print DenseRange.exists_mem_open /-\ntheorem DenseRange.exists_mem_open (hf : DenseRange f) {s : Set Î²} (ho : IsOpen s) (hs : s.nonempty) : âˆƒ a, f a âˆˆ s :=\n  exists_range_iff.1 <| hf.exists_mem_open ho hs\n#align dense_range.exists_mem_open DenseRange.exists_mem_open\n-/\n\n",
 "eventually_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print eventually_nhds_iff /-\n/-- A predicate is true in a neighborhood of `a` iff it is true for all the points in an open set\ncontaining `a`. -/\ntheorem eventually_nhds_iff {a : Î±} {p : Î± â†’ Prop} :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (p x) â†”\n      âˆƒ t : Set Î±, (âˆ€ x âˆˆ t, p x) âˆ§ IsOpen t âˆ§ a âˆˆ t :=\n  mem_nhds_iff.trans <| by simp only [subset_def, exists_prop, mem_set_of_eq]\n#align eventually_nhds_iff eventually_nhds_iff\n-/\n\n",
 "eventually_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.Eventually.eventually_nhds /-\n/-- If a predicate is true in a neighbourhood of `a`, then for `y` sufficiently close\nto `a` this predicate is true in a neighbourhood of `y`. -/\ntheorem Filter.Eventually.eventually_nhds {p : Î± â†’ Prop} {a : Î±}\n    (h :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (p y)) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n      (Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n        ((nhds) y) (p x)) :=\n  let âŸ¨t, htp, hto, haâŸ© := eventually_nhds_iff.1 h\n  eventually_nhds_iff.2 âŸ¨t, fun x hx => eventually_nhds_iff.2 âŸ¨t, htp, hto, hxâŸ©, hto, haâŸ©\n#align filter.eventually.eventually_nhds Filter.Eventually.eventually_nhds\n-/\n\n",
 "eventually_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print eventually_mem_nhds /-\n@[simp]\ntheorem eventually_mem_nhds {s : Set Î±} {a : Î±} :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (s âˆˆ (nhds) x) â†”\n      s âˆˆ (nhds) a :=\n  eventually_eventually_nhds\n#align eventually_mem_nhds eventually_mem_nhds\n-/\n\n",
 "eventually_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsOpen.eventually_mem /-\ntheorem IsOpen.eventually_mem {a : Î±} {s : Set Î±} (hs : IsOpen s) (ha : a âˆˆ s) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n      (x âˆˆ s) :=\n  IsOpen.mem_nhds hs ha\n#align is_open.eventually_mem IsOpen.eventually_mem\n-/\n\n",
 "eventually_eventually_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print eventually_eventually_nhds /-\n@[simp]\ntheorem eventually_eventually_nhds {p : Î± â†’ Prop} {a : Î±} :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n          ((nhds) y) (p x)) â†”\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (p x) :=\n  âŸ¨fun h => h.self_of_nhds, fun h => h.eventually_nhdsâŸ©\n#align eventually_eventually_nhds eventually_eventually_nhds\n-/\n\n",
 "eventually_eventuallyLE_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰¤á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰¤á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print eventually_eventuallyLE_nhds /-\n@[simp]\ntheorem eventually_eventuallyLE_nhds [LE Î²] {f g : Î± â†’ Î²} {a : Î±} :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (Â«expr â‰¤á¶ [ ] Â» f ((nhds) y) g) â†”\n      Â«expr â‰¤á¶ [ ] Â» f ((nhds) a) g :=\n  eventually_eventually_nhds\n#align eventually_eventually_le_nhds eventually_eventuallyLE_nhds\n-/\n\n",
 "eventually_eventuallyEq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print eventually_eventuallyEq_nhds /-\n@[simp]\ntheorem eventually_eventuallyEq_nhds {f g : Î± â†’ Î²} {a : Î±} :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (Â«expr =á¶ [ ] Â» f ((nhds) y) g) â†”\n      Â«expr =á¶ [ ] Â» f ((nhds) a) g :=\n  eventually_eventually_nhds\n#align eventually_eventually_eq_nhds eventually_eventuallyEq_nhds\n-/\n\n",
 "eventuallyLE_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰¤á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰¤á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.EventuallyLE.eventuallyLE_nhds /-\n/-- If `f x â‰¤ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\n`f x â‰¤ g x` in a neighbourhood of `y`. -/\ntheorem Filter.EventuallyLE.eventuallyLE_nhds [LE Î²] {f g : Î± â†’ Î²} {a : Î±} (h : Â«expr â‰¤á¶ [ ] Â» f ((nhds) a) g) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n      (Â«expr â‰¤á¶ [ ] Â» f ((nhds) y) g) :=\n  h.eventually_nhds\n#align filter.eventually_le.eventually_le_nhds Filter.EventuallyLE.eventuallyLE_nhds\n-/\n\n",
 "eventuallyEq_zero_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print eventuallyEq_zero_nhds /-\ntheorem eventuallyEq_zero_nhds {Mâ‚€} [Zero Mâ‚€] {a : Î±} {f : Î± â†’ Mâ‚€} :\n    Â«expr =á¶ [ ] Â» f ((nhds) a) 0 â†” a âˆ‰ closure (Function.support f) := by\n  rw [â† mem_compl_iff, â† interior_compl, mem_interior_iff_mem_nhds, Function.compl_support] <;> rfl\n#align eventually_eq_zero_nhds eventuallyEq_zero_nhds\n-/\n\n",
 "eventuallyEq_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.EventuallyEq.eventuallyEq_nhds /-\n/-- If two functions are equal in a neighbourhood of `a`, then for `y` sufficiently close\nto `a` these functions are equal in a neighbourhood of `y`. -/\ntheorem Filter.EventuallyEq.eventuallyEq_nhds {f g : Î± â†’ Î²} {a : Î±} (h : Â«expr =á¶ [ ] Â» f ((nhds) a) g) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n      (Â«expr =á¶ [ ] Â» f ((nhds) y) g) :=\n  h.eventually_nhds\n#align filter.eventually_eq.eventually_eq_nhds Filter.EventuallyEq.eventuallyEq_nhds\n-/\n\n",
 "eq_of_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.EventuallyEq.eq_of_nhds /-\ntheorem Filter.EventuallyEq.eq_of_nhds {f g : Î± â†’ Î²} {a : Î±} (h : Â«expr =á¶ [ ] Â» f ((nhds) a) g) : f a = g a :=\n  h.self_of_nhds\n#align filter.eventually_eq.eq_of_nhds Filter.EventuallyEq.eq_of_nhds\n-/\n\n",
 "diff_subset_closure_iff":
 "#print diff_subset_closure_iff /-\ntheorem diff_subset_closure_iff {s t : Set Î±} : s \\ t âŠ† closure t â†” s âŠ† closure t := by\n  rw [diff_subset_iff, union_eq_self_of_subset_left subset_closure]\n#align diff_subset_closure_iff diff_subset_closure_iff\n-/\n\n",
 "dense_univ":
 "#print dense_univ /-\n@[simp]\ntheorem dense_univ : Dense (univ : Set Î±) := fun x => subset_closure trivial\n#align dense_univ dense_univ\n-/\n\n",
 "dense_of_mapsTo":
 "#print DenseRange.dense_of_mapsTo /-\n/-- If a continuous map with dense range maps a dense set to a subset of `t`, then `t` is a dense\nset. -/\ntheorem DenseRange.dense_of_mapsTo {f : Î± â†’ Î²} (hf' : DenseRange f) (hf : Continuous f) {s : Set Î±} (hs : Dense s)\n    {t : Set Î²} (ht : MapsTo f s t) : Dense t :=\n  (hf'.dense_image hf hs).mono ht.image_subset\n#align dense_range.dense_of_maps_to DenseRange.dense_of_mapsTo\n-/\n\n",
 "dense_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print DenseRange.dense_image /-\n/-- The image of a dense set under a continuous map with dense range is a dense set. -/\ntheorem DenseRange.dense_image {f : Î± â†’ Î²} (hf' : DenseRange f) (hf : Continuous f) {s : Set Î±} (hs : Dense s) :\n    Dense (Â«expr '' Â» f s) :=\n  (hf'.mono <| hf.range_subset_closure_image_dense hs).of_closure\n#align dense_range.dense_image DenseRange.dense_image\n-/\n\n",
 "dense_iff_inter_open":
 "#print dense_iff_inter_open /-\n/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem dense_iff_inter_open {s : Set Î±} : Dense s â†” âˆ€ U, IsOpen U â†’ U.nonempty â†’ (U âˆ© s).nonempty :=\n  by\n  constructor <;> intro h\n  Â· rintro U U_op âŸ¨x, x_inâŸ©\n    exact mem_closure_iff.1 (by simp only [h.closure_eq]) U U_op x_in\n  Â· intro x\n    rw [mem_closure_iff]\n    intro U U_op x_in\n    exact h U U_op âŸ¨_, x_inâŸ©\n#align dense_iff_inter_open dense_iff_inter_open\n-/\n\n",
 "dense_iff_closure_eq":
 "#print dense_iff_closure_eq /-\ntheorem dense_iff_closure_eq {s : Set Î±} : Dense s â†” closure s = univ :=\n  eq_univ_iff_forall.symm\n#align dense_iff_closure_eq dense_iff_closure_eq\n-/\n\n",
 "dense_compl_singleton_iff_not_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print dense_compl_singleton_iff_not_open /-\n/-- Complement to a singleton is dense if and only if the singleton is not an open set. -/\ntheorem dense_compl_singleton_iff_not_open {x : Î±} : Dense (Â«expr á¶œÂ» {x} : Set Î±) â†” Â¬IsOpen ({x} : Set Î±) :=\n  by\n  fconstructor\n  Â· intro hd ho\n    exact (hd.inter_open_nonempty _ ho (singleton_nonempty _)).ne_empty (inter_compl_self _)\n  Â· refine' fun ho => dense_iff_inter_open.2 fun U hU hne => inter_compl_nonempty_iff.2 fun hUx => _\n    obtain rfl : U = {x}\n    exact eq_singleton_iff_nonempty_unique_mem.2 âŸ¨hne, hUxâŸ©\n    exact ho hU\n#align dense_compl_singleton_iff_not_open dense_compl_singleton_iff_not_open\n-/\n\n",
 "dense_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print dense_compl_singleton /-\n/-- If `x` is not an isolated point of a topological space, then `{x}á¶œ` is dense in the whole\nspace. -/\ntheorem dense_compl_singleton (x : Î±) [NeBot (nhds_within.ne x)] : Dense (Â«expr á¶œÂ» {x} : Set Î±) :=\n  by\n  intro y\n  rcases eq_or_ne y x with (rfl | hne)\n  Â· rwa [mem_closure_iff_nhdsWithin_neBot]\n  Â· exact subset_closure hne\n#align dense_compl_singleton dense_compl_singleton\n-/\n\n",
 "dense_closure":
 "#print dense_closure /-\n/-- The closure of a set `s` is dense if and only if `s` is dense. -/\n@[simp]\ntheorem dense_closure {s : Set Î±} : Dense (closure s) â†” Dense s := by rw [Dense, Dense, closure_closure]\n#align dense_closure dense_closure\n-/\n\n",
 "denseRange_val":
 "#print Dense.denseRange_val /-\ntheorem Dense.denseRange_val {s : Set Î±} (h : Dense s) : DenseRange (coe : s â†’ Î±) := by\n  simpa only [DenseRange, Subtype.range_coe_subtype]\n#align dense.dense_range_coe Dense.denseRange_val\n-/\n\n",
 "denseRange_iff_closure_range":
 "#print denseRange_iff_closure_range /-\ntheorem denseRange_iff_closure_range : DenseRange f â†” closure (range f) = univ :=\n  dense_iff_closure_eq\n#align dense_range_iff_closure_range denseRange_iff_closure_range\n-/\n\n",
 "denseRange_id":
 "#print denseRange_id /-\ntheorem denseRange_id : DenseRange (id : Î± â†’ Î±) :=\n  Function.Surjective.denseRange function.surjective_id\n#align dense_range_id denseRange_id\n-/\n\n",
 "denseRange":
 "#print Function.Surjective.denseRange /-\n/-- A surjective map has dense range. -/\ntheorem Function.Surjective.denseRange (hf : function.surjective f) : DenseRange f := fun x => by simp [hf.range_eq]\n#align function.surjective.dense_range Function.Surjective.denseRange\n-/\n\n",
 "continuous_of_const":
 "#print continuous_of_const /-\ntheorem continuous_of_const {f : Î± â†’ Î²} (h : âˆ€ x y, f x = f y) : Continuous f :=\n  continuous_iff_continuousAt.mpr fun x => Filter.EventuallyEq.continuousAt <| eventually_of_forall fun y => h y x\n#align continuous_of_const continuous_of_const\n-/\n\n",
 "continuous_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print continuous_iff_ultrafilter /-\ntheorem continuous_iff_ultrafilter {f : Î± â†’ Î²} :\n    Continuous f â†” âˆ€ (x) (g : Ultrafilter Î±), â†‘g â‰¤ (nhds) x â†’ Tendsto f g ((nhds) (f x)) := by\n  simp only [continuous_iff_continuousAt, continuousAt_iff_ultrafilter]\n#align continuous_iff_ultrafilter continuous_iff_ultrafilter\n-/\n\n",
 "continuous_iff_isClosed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n#print continuous_iff_isClosed /-\ntheorem continuous_iff_isClosed {f : Î± â†’ Î²} : Continuous f â†” âˆ€ s, IsClosed s â†’ IsClosed (Â«expr â»Â¹' Â» f s) :=\n  âŸ¨fun hf s hs => by simpa using (continuous_def.1 hf (Â«expr á¶œÂ» s) hs.is_open_compl).is_closed_compl, fun hf =>\n    continuous_def.2 fun s => by rw [â† isClosed_compl_iff, â† isClosed_compl_iff] <;> exact hf _âŸ©\n#align continuous_iff_is_closed continuous_iff_isClosed\n-/\n\n",
 "continuous_iff_continuousAt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n#print continuous_iff_continuousAt /-\ntheorem continuous_iff_continuousAt {f : Î± â†’ Î²} : Continuous f â†” âˆ€ x, ContinuousAt f x :=\n  âŸ¨Continuous.tendsto, fun hf : âˆ€ x, Tendsto f ((nhds) x) ((nhds) (f x)) =>\n    continuous_def.2 fun s => fun hs : IsOpen s =>\n      have : âˆ€ a, f a âˆˆ s â†’ s âˆˆ (nhds) (f a) := fun a ha => IsOpen.mem_nhds hs ha\n      show IsOpen (Â«expr â»Â¹' Â» f s) from isOpen_iff_nhds.2 fun a ha => le_principal_iff.2 <| hf _ (this a ha)âŸ©\n#align continuous_iff_continuous_at continuous_iff_continuousAt\n-/\n\n",
 "continuous_id":
 "#print continuous_id /-\ntheorem continuous_id : Continuous (id : Î± â†’ Î±) :=\n  continuous_def.2 fun s h => h\n#align continuous_id continuous_id\n-/\n\n",
 "continuous_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n#print continuous_def /-\ntheorem continuous_def {f : Î± â†’ Î²} : Continuous f â†” âˆ€ s, IsOpen s â†’ IsOpen (Â«expr â»Â¹' Â» f s) :=\n  âŸ¨fun hf s hs => hf.is_open_preimage s hs, fun h => âŸ¨hâŸ©âŸ©\n#align continuous_def continuous_def\n-/\n\n",
 "continuous_const":
 "#print continuous_const /-\ntheorem continuous_const {b : Î²} : Continuous fun a : Î± => b :=\n  continuous_iff_continuousAt.mpr fun a => continuousAt_const\n#align continuous_const continuous_const\n-/\n\n",
 "continuousAt_iff_ultrafilter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print continuousAt_iff_ultrafilter /-\ntheorem continuousAt_iff_ultrafilter {f : Î± â†’ Î²} {x} :\n    ContinuousAt f x â†” âˆ€ g : Ultrafilter Î±, â†‘g â‰¤ (nhds) x â†’ Tendsto f g ((nhds) (f x)) :=\n  tendsto_iff_ultrafilter f ((nhds) x) ((nhds) (f x))\n#align continuous_at_iff_ultrafilter continuousAt_iff_ultrafilter\n-/\n\n",
 "continuousAt_id":
 "#print continuousAt_id /-\ntheorem continuousAt_id {x : Î±} : ContinuousAt id x :=\n  continuous_id.continuous_at\n#align continuous_at_id continuousAt_id\n-/\n\n",
 "continuousAt_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print continuousAt_def /-\ntheorem continuousAt_def {f : Î± â†’ Î²} {x : Î±} : ContinuousAt f x â†” âˆ€ A âˆˆ (nhds) (f x), Â«expr â»Â¹' Â» f A âˆˆ (nhds) x :=\n  iff.rfl\n#align continuous_at_def continuousAt_def\n-/\n\n",
 "continuousAt_const":
 "#print continuousAt_const /-\ntheorem continuousAt_const {x : Î±} {b : Î²} : ContinuousAt (fun a : Î± => b) x :=\n  tendsto_const_nhds\n#align continuous_at_const continuousAt_const\n-/\n\n",
 "continuousAt_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print continuousAt_congr /-\ntheorem continuousAt_congr {f g : Î± â†’ Î²} {x : Î±} (h : Â«expr =á¶ [ ] Â» f ((nhds) x) g) :\n    ContinuousAt f x â†” ContinuousAt g x := by simp only [ContinuousAt, tendsto_congr' h, h.eq_of_nhds]\n#align continuous_at_congr continuousAt_congr\n-/\n\n",
 "continuousAt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.EventuallyEq.continuousAt /-\ntheorem Filter.EventuallyEq.continuousAt {x : Î±} {f : Î± â†’ Î²} {y : Î²} (h : Â«expr =á¶ [ ] Â» f ((nhds) x) fun _ => y) :\n    ContinuousAt f x :=\n  (continuousAt_congr h).2 tendsto_const_nhds\n#align filter.eventually_eq.continuous_at Filter.EventuallyEq.continuousAt\n-/\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =á¶ [ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print ContinuousAt.congr /-\ntheorem ContinuousAt.congr {f g : Î± â†’ Î²} {x : Î±} (hf : ContinuousAt f x) (h : Â«expr =á¶ [ ] Â» f ((nhds) x) g) :\n    ContinuousAt g x :=\n  (continuousAt_congr h).1 hf\n#align continuous_at.congr ContinuousAt.congr\n-/\n\n",
 "compl_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print IsClosed.compl_mem_nhds /-\ntheorem IsClosed.compl_mem_nhds {a : Î±} {s : Set Î±} (hs : IsClosed s) (ha : a âˆ‰ s) : Â«expr á¶œÂ» s âˆˆ (nhds) a :=\n  hs.is_open_compl.mem_nhds (mem_compl ha)\n#align is_closed.compl_mem_nhds IsClosed.compl_mem_nhds\n-/\n\n",
 "compl_frontier_eq_union_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print compl_frontier_eq_union_interior /-\ntheorem compl_frontier_eq_union_interior {s : Set Î±} : Â«expr á¶œÂ» (frontier s) = interior s âˆª interior (Â«expr á¶œÂ» s) :=\n  by\n  rw [frontier_eq_inter_compl_interior]\n  simp only [compl_inter, compl_compl]\n#align compl_frontier_eq_union_interior compl_frontier_eq_union_interior\n-/\n\n",
 "comp":
 "#print DenseRange.comp /-\n/-- Composition of a continuous map with dense range and a function with dense range has dense\nrange. -/\ntheorem DenseRange.comp {g : Î² â†’ Î³} {f : Îº â†’ Î²} (hg : DenseRange g) (hf : DenseRange f) (cg : Continuous g) :\n    DenseRange (g âˆ˜ f) := by\n  rw [DenseRange, range_comp]\n  exact hg.dense_image cg hf\n#align dense_range.comp DenseRange.comp\n-/\n\n",
 "clusterPt_principal_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print clusterPt_principal_iff_frequently /-\ntheorem clusterPt_principal_iff_frequently {x : Î±} {s : Set Î±} :\n    ClusterPt x ((filter.principal) s) â†”\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" ((nhds) x)\n        (y âˆˆ s) :=\n  by simp only [clusterPt_principal_iff, frequently_iff, Set.Nonempty, exists_prop, mem_inter_iff]\n#align cluster_pt_principal_iff_frequently clusterPt_principal_iff_frequently\n-/\n\n",
 "clusterPt_principal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print clusterPt_principal_iff /-\n/-- `x` is a cluster point of a set `s` if every neighbourhood of `x` meets `s` on a nonempty\nset. See also `mem_closure_iff_cluster_pt`. -/\ntheorem clusterPt_principal_iff {x : Î±} {s : Set Î±} :\n    ClusterPt x ((filter.principal) s) â†” âˆ€ U âˆˆ (nhds) x, (U âˆ© s).nonempty :=\n  inf_principal_neBot_iff\n#align cluster_pt_principal_iff clusterPt_principal_iff\n-/\n\n",
 "clusterPt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Ultrafilter.clusterPt_iff /-\ntheorem Ultrafilter.clusterPt_iff {x : Î±} {f : Ultrafilter Î±} : ClusterPt x f â†” â†‘f â‰¤ (nhds) x :=\n  âŸ¨f.le_of_inf_ne_bot', fun h => ClusterPt.of_le_nhds hâŸ©\n#align ultrafilter.cluster_pt_iff Ultrafilter.clusterPt_iff\n-/\n\n",
 "closure_univ":
 "#print closure_univ /-\n@[simp]\ntheorem closure_univ : closure (univ : Set Î±) = univ :=\n  isClosed_univ.closure_eq\n#align closure_univ closure_univ\n-/\n\n",
 "closure_unionáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n#print closure_unionáµ¢ /-\n@[simp]\ntheorem closure_unionáµ¢ {Î¹ : Type _} [Finite Î¹] (f : Î¹ â†’ Set Î±) :\n    closure (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) =\n      Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (closure (f i)) :=\n  by\n  cases nonempty_fintype Î¹\n  convert finset.univ.closure_bUnion f <;> simp\n#align closure_Union closure_unionáµ¢\n-/\n\n",
 "closure_union":
 "#print closure_union /-\n@[simp]\ntheorem closure_union {s t : Set Î±} : closure (s âˆª t) = closure s âˆª closure t :=\n  Subset.antisymm\n    (closure_minimal (union_subset_union subset_closure subset_closure) <|\n      IsClosed.union isClosed_closure isClosed_closure)\n    ((monotone_closure Î±).le_map_sup s t)\n#align closure_union closure_union\n-/\n\n",
 "closure_subset_preimage_closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print closure_subset_preimage_closure_image /-\ntheorem closure_subset_preimage_closure_image {f : Î± â†’ Î²} {s : Set Î±} (h : Continuous f) :\n    closure s âŠ† Â«expr â»Â¹' Â» f (closure (Â«expr '' Â» f s)) :=\n  by\n  rw [â† Set.image_subset_iff]\n  exact image_closure_subset_closure_image h\n#align closure_subset_preimage_closure_image closure_subset_preimage_closure_image\n-/\n\n",
 "closure_subset_iff_isClosed":
 "#print closure_subset_iff_isClosed /-\ntheorem closure_subset_iff_isClosed {s : Set Î±} : closure s âŠ† s â†” IsClosed s :=\n  âŸ¨isClosed_of_closure_subset, IsClosed.closure_subsetâŸ©\n#align closure_subset_iff_is_closed closure_subset_iff_isClosed\n-/\n\n",
 "closure_subset_iff":
 "#print IsClosed.closure_subset_iff /-\ntheorem IsClosed.closure_subset_iff {s t : Set Î±} (hâ‚ : IsClosed t) : closure s âŠ† t â†” s âŠ† t :=\n  âŸ¨Subset.trans subset_closure, fun h => closure_minimal h hâ‚âŸ©\n#align is_closed.closure_subset_iff IsClosed.closure_subset_iff\n-/\n\n",
 "closure_subset":
 "#print IsClosed.closure_subset /-\ntheorem IsClosed.closure_subset {s : Set Î±} (hs : IsClosed s) : closure s âŠ† s :=\n  closure_minimal (Subset.refl _) hs\n#align is_closed.closure_subset IsClosed.closure_subset\n-/\n\n",
 "closure_right":
 "#print Disjoint.closure_right /-\ntheorem Disjoint.closure_right {s t : Set Î±} (hd : Disjoint s t) (hs : IsOpen s) : Disjoint s (closure t) :=\n  (hd.symm.closure_left hs).symm\n#align disjoint.closure_right Disjoint.closure_right\n-/\n\n",
 "closure_range":
 "#print DenseRange.closure_range /-\ntheorem DenseRange.closure_range (h : DenseRange f) : closure (range f) = univ :=\n  h.closure_eq\n#align dense_range.closure_range DenseRange.closure_range\n-/\n\n",
 "closure_preimage_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n#print Continuous.closure_preimage_subset /-\ntheorem Continuous.closure_preimage_subset {f : Î± â†’ Î²} (hf : Continuous f) (t : Set Î²) :\n    closure (Â«expr â»Â¹' Â» f t) âŠ† Â«expr â»Â¹' Â» f (closure t) :=\n  by\n  rw [â† (is_closed_closure.preimage hf).closure_eq]\n  exact closure_mono (preimage_mono subset_closure)\n#align continuous.closure_preimage_subset Continuous.closure_preimage_subset\n-/\n\n",
 "closure_nonempty_iff":
 "#print closure_nonempty_iff /-\n@[simp]\ntheorem closure_nonempty_iff {s : Set Î±} : (closure s).nonempty â†” s.nonempty := by\n  simp only [nonempty_iff_ne_empty, ne.def, closure_empty_iff]\n#align closure_nonempty_iff closure_nonempty_iff\n-/\n\n",
 "closure_mono":
 "#print closure_mono /-\n@[mono]\ntheorem closure_mono {s t : Set Î±} (h : s âŠ† t) : closure s âŠ† closure t :=\n  closure_minimal (Subset.trans h subset_closure) isClosed_closure\n#align closure_mono closure_mono\n-/\n\n",
 "closure_minimal":
 "#print closure_minimal /-\ntheorem closure_minimal {s t : Set Î±} (hâ‚ : s âŠ† t) (hâ‚‚ : IsClosed t) : closure s âŠ† t :=\n  interâ‚›_subset_of_mem âŸ¨hâ‚‚, hâ‚âŸ©\n#align closure_minimal closure_minimal\n-/\n\n",
 "closure_left":
 "#print Set.MapsTo.closure_left /-\n/-- If a continuous map `f` maps `s` to a closed set `t`, then it maps `closure s` to `t`. -/\ntheorem Set.MapsTo.closure_left {s : Set Î±} {t : Set Î²} {f : Î± â†’ Î²} (h : MapsTo f s t) (hc : Continuous f)\n    (ht : IsClosed t) : MapsTo f (closure s) t :=\n  ht.closure_eq â–¸ h.closure hc\n#align set.maps_to.closure_left Set.MapsTo.closure_left\n-/\n\n",
 "closure_inter_subset_inter_closure":
 "#print closure_inter_subset_inter_closure /-\ntheorem closure_inter_subset_inter_closure (s t : Set Î±) : closure (s âˆ© t) âŠ† closure s âˆ© closure t :=\n  (monotone_closure Î±).map_inf_le s t\n#align closure_inter_subset_inter_closure closure_inter_subset_inter_closure\n-/\n\n",
 "closure_inter_open_nonempty_iff":
 "#print closure_inter_open_nonempty_iff /-\ntheorem closure_inter_open_nonempty_iff {s t : Set Î±} (h : IsOpen t) : (closure s âˆ© t).nonempty â†” (s âˆ© t).nonempty :=\n  âŸ¨fun âŸ¨x, hxcs, hxtâŸ© => inter_comm t s â–¸ mem_closure_iff.1 hxcs t h hxt, fun h =>\n    h.mono <| inf_le_inf_right t subset_closureâŸ©\n#align closure_inter_open_nonempty_iff closure_inter_open_nonempty_iff\n-/\n\n",
 "closure_inter":
 "#print IsOpen.closure_inter /-\ntheorem IsOpen.closure_inter {s t : Set Î±} (h : IsOpen t) : closure s âˆ© t âŠ† closure (s âˆ© t) := by\n  simpa only [inter_comm] using h.inter_closure\n#align is_open.closure_inter IsOpen.closure_inter\n-/\n\n",
 "closure_eq_self_union_frontier":
 "#print closure_eq_self_union_frontier /-\ntheorem closure_eq_self_union_frontier (s : Set Î±) : closure s = s âˆª frontier s :=\n  (union_diff_cancel' interior_subset subset_closure).symm\n#align closure_eq_self_union_frontier closure_eq_self_union_frontier\n-/\n\n",
 "closure_eq_interior_union_frontier":
 "#print closure_eq_interior_union_frontier /-\ntheorem closure_eq_interior_union_frontier (s : Set Î±) : closure s = interior s âˆª frontier s :=\n  (union_diff_cancel interior_subset_closure).symm\n#align closure_eq_interior_union_frontier closure_eq_interior_union_frontier\n-/\n\n",
 "closure_eq_iff_isClosed":
 "#print closure_eq_iff_isClosed /-\ntheorem closure_eq_iff_isClosed {s : Set Î±} : closure s = s â†” IsClosed s :=\n  âŸ¨fun h => h â–¸ isClosed_closure, IsClosed.closure_eqâŸ©\n#align closure_eq_iff_is_closed closure_eq_iff_isClosed\n-/\n\n",
 "closure_eq_compl_interior_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print closure_eq_compl_interior_compl /-\ntheorem closure_eq_compl_interior_compl {s : Set Î±} : closure s = Â«expr á¶œÂ» (interior (Â«expr á¶œÂ» s)) :=\n  by\n  rw [interior, closure, compl_sUnion, compl_image_set_of]\n  simp only [compl_subset_compl, isOpen_compl_iff]\n#align closure_eq_compl_interior_compl closure_eq_compl_interior_compl\n-/\n\n",
 "closure_eq_cluster_pts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print closure_eq_cluster_pts /-\ntheorem closure_eq_cluster_pts {s : Set Î±} : closure s = { a | ClusterPt a ((filter.principal) s) } :=\n  Set.ext fun x => mem_closure_iff_clusterPt\n#align closure_eq_cluster_pts closure_eq_cluster_pts\n-/\n\n",
 "closure_eq":
 "#print Dense.closure_eq /-\ntheorem Dense.closure_eq {s : Set Î±} (h : Dense s) : closure s = univ :=\n  dense_iff_closure_eq.mp h\n#align dense.closure_eq Dense.closure_eq\n-/\n\n",
 "closure_empty_iff":
 "#print closure_empty_iff /-\n@[simp]\ntheorem closure_empty_iff (s : Set Î±) : closure s = âˆ… â†” s = âˆ… :=\n  âŸ¨subset_eq_empty subset_closure, fun h => h.symm â–¸ closure_emptyâŸ©\n#align closure_empty_iff closure_empty_iff\n-/\n\n",
 "closure_empty":
 "#print closure_empty /-\n@[simp]\ntheorem closure_empty : closure (âˆ… : Set Î±) = âˆ… :=\n  isClosed_empty.closure_eq\n#align closure_empty closure_empty\n-/\n\n",
 "closure_diff_interior":
 "#print closure_diff_interior /-\n@[simp]\ntheorem closure_diff_interior (s : Set Î±) : closure s \\ interior s = frontier s :=\n  rfl\n#align closure_diff_interior closure_diff_interior\n-/\n\n",
 "closure_diff_frontier":
 "#print closure_diff_frontier /-\n@[simp]\ntheorem closure_diff_frontier (s : Set Î±) : closure s \\ frontier s = interior s := by\n  rw [frontier, diff_diff_right_self, inter_eq_self_of_subset_right interior_subset_closure]\n#align closure_diff_frontier closure_diff_frontier\n-/\n\n",
 "closure_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print closure_diff /-\ntheorem closure_diff {s t : Set Î±} : closure s \\ closure t âŠ† closure (s \\ t) :=\n  calc\n    closure s \\ closure t = Â«expr á¶œÂ» (closure t) âˆ© closure s := by simp only [diff_eq, inter_comm]\n    _ âŠ† closure (Â«expr á¶œÂ» (closure t) âˆ© s) := (isOpen_compl_iff.mpr <| isClosed_closure).inter_closure\n    _ = closure (s \\ closure t) := by simp only [diff_eq, inter_comm]\n    _ âŠ† closure (s \\ t) := closure_mono <| diff_subset_diff (Subset.refl s) subset_closure\n    \n#align closure_diff closure_diff\n-/\n\n",
 "closure_compl_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print closure_compl_singleton /-\n/-- If `x` is not an isolated point of a topological space, then the closure of `{x}á¶œ` is the whole\nspace. -/\n@[simp]\ntheorem closure_compl_singleton (x : Î±) [NeBot (nhds_within.ne x)] : closure (Â«expr á¶œÂ» {x}) = (univ : Set Î±) :=\n  (dense_compl_singleton x).closure_eq\n#align closure_compl_singleton closure_compl_singleton\n-/\n\n",
 "closure_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print closure_compl /-\n@[simp]\ntheorem closure_compl {s : Set Î±} : closure (Â«expr á¶œÂ» s) = Â«expr á¶œÂ» (interior s) := by\n  simp [closure_eq_compl_interior_compl]\n#align closure_compl closure_compl\n-/\n\n",
 "closure_closure":
 "#print closure_closure /-\n@[simp]\ntheorem closure_closure {s : Set Î±} : closure (closure s) = closure s :=\n  isClosed_closure.closure_eq\n#align closure_closure closure_closure\n-/\n\n",
 "closure_bunionáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n#print Finset.closure_bunionáµ¢ /-\n@[simp]\ntheorem Finset.closure_bunionáµ¢ {Î¹ : Type _} (s : Finset Î¹) (f : Î¹ â†’ Set Î±) :\n    closure (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) =\n      Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (closure (f i)) :=\n  by\n  classical\n    refine' s.induction_on (by simp) _\n    intro i s hâ‚ hâ‚‚\n    simp [hâ‚‚]\n#align finset.closure_bUnion Finset.closure_bunionáµ¢\n-/\n\n",
 "closure":
 "#print Set.MapsTo.closure /-\n/-- If a continuous map `f` maps `s` to `t`, then it maps `closure s` to `closure t`. -/\ntheorem Set.MapsTo.closure {s : Set Î±} {t : Set Î²} {f : Î± â†’ Î²} (h : MapsTo f s t) (hc : Continuous f) :\n    MapsTo f (closure s) (closure t) :=\n  by\n  simp only [maps_to, mem_closure_iff_clusterPt]\n  exact fun x hx => hx.map hc.continuous_at (tendsto_principal_principal.2 h)\n#align set.maps_to.closure Set.MapsTo.closure\n-/\n\n",
 "and":
 "#print IsOpen.and /-\ntheorem IsOpen.and : IsOpen { a | pâ‚ a } â†’ IsOpen { a | pâ‚‚ a } â†’ IsOpen { a | pâ‚ a âˆ§ pâ‚‚ a } :=\n  IsOpen.inter\n#align is_open.and IsOpen.and\n-/\n\n",
 "all_mem_nhds_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print all_mem_nhds_filter /-\ntheorem all_mem_nhds_filter (x : Î±) (f : Set Î± â†’ Set Î²) (hf : âˆ€ s t, s âŠ† t â†’ f s âŠ† f t) (l : Filter Î²) :\n    (âˆ€ s âˆˆ (nhds) x, f s âˆˆ l) â†” âˆ€ s, IsOpen s â†’ x âˆˆ s â†’ f s âˆˆ l :=\n  all_mem_nhds _ _ fun s t ssubt h => mem_of_superset h (hf s t ssubt)\n#align all_mem_nhds_filter all_mem_nhds_filter\n-/\n\n",
 "all_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print all_mem_nhds /-\ntheorem all_mem_nhds (x : Î±) (P : Set Î± â†’ Prop) (hP : âˆ€ s t, s âŠ† t â†’ P s â†’ P t) :\n    (âˆ€ s âˆˆ (nhds) x, P s) â†” âˆ€ s, IsOpen s â†’ x âˆˆ s â†’ P s :=\n  ((nhds_basis_opens x).forall_iff hP).trans <| by simp only [and_comm' (x âˆˆ _), and_imp]\n#align all_mem_nhds all_mem_nhds\n-/\n\n",
 "acc_principal_iff_cluster":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n#print acc_principal_iff_cluster /-\n/-- `x` is an accumulation point of a set `C` iff it is a cluster point of `C âˆ– {x}`.-/\ntheorem acc_principal_iff_cluster (x : Î±) (C : Set Î±) :\n    AccPt x ((filter.principal) C) â†” ClusterPt x ((filter.principal) (C \\ {x})) := by\n  rw [acc_iff_cluster, inf_principal, inter_comm] <;> rfl\n#align acc_principal_iff_cluster acc_principal_iff_cluster\n-/\n\n",
 "acc_iff_cluster":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n#print acc_iff_cluster /-\ntheorem acc_iff_cluster (x : Î±) (F : Filter Î±) :\n    AccPt x F â†” ClusterPt x (Â«expr âŠ“ Â» ((filter.principal) (Â«expr á¶œÂ» {x})) F) := by\n  rw [AccPt, nhdsWithin, ClusterPt, inf_assoc]\n#align acc_iff_cluster acc_iff_cluster\n-/\n\n",
 "accPt_iff_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print accPt_iff_nhds /-\n/-- `x` is an accumulation point of a set `C` iff every neighborhood\nof `x` contains a point of `C` other than `x`. -/\ntheorem accPt_iff_nhds (x : Î±) (C : Set Î±) : AccPt x ((filter.principal) C) â†” âˆ€ U âˆˆ (nhds) x, âˆƒ y âˆˆ U âˆ© C, y â‰  x := by\n  simp [acc_principal_iff_cluster, clusterPt_principal_iff, Set.Nonempty, exists_prop, and_assoc', and_comm' Â¬_ = x]\n#align acc_pt_iff_nhds accPt_iff_nhds\n-/\n\n",
 "accPt_iff_frequently":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print accPt_iff_frequently /-\n/-- `x` is an accumulation point of a set `C` iff\nthere are points near `x` in `C` and different from `x`.-/\ntheorem accPt_iff_frequently (x : Î±) (C : Set Î±) :\n    AccPt x ((filter.principal) C) â†”\n      Â«exprâˆƒá¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆƒá¶  in , Â»\" ((nhds) x)\n        (y â‰  x âˆ§ y âˆˆ C) :=\n  by simp [acc_principal_iff_cluster, clusterPt_principal_iff_frequently, and_comm']\n#align acc_pt_iff_frequently accPt_iff_frequently\n-/\n\n"}